From 71d6a7d09ab2ef4416e79dee087e0412d7e3a71a Mon Sep 17 00:00:00 2001
From: Andy Walls <awalls@md.metrocast.net>
Date: Sat, 14 Jan 2012 13:12:32 -0500
Subject: [PATCH 01/20] acpioff: Add directory with basic Makefile for new
 acpioff com32 module

The acpioff.c32 module will power off a machine using ACPI.

Signed-off-by: Andy Walls <awalls@md.metrocast.net>
---
 com32/acpioff/Makefile | 35 +++++++++++++++++++++++++++++++++++
 1 file changed, 35 insertions(+)
 create mode 100644 com32/acpioff/Makefile

diff --git a/com32/acpioff/Makefile b/com32/acpioff/Makefile
new file mode 100644
index 00000000..050487bc
--- /dev/null
+++ b/com32/acpioff/Makefile
@@ -0,0 +1,35 @@
+## -----------------------------------------------------------------------
+##
+##   Copyright 2001-2008 H. Peter Anvin - All Rights Reserved
+##
+##   This program is free software; you can redistribute it and/or modify
+##   it under the terms of the GNU General Public License as published by
+##   the Free Software Foundation, Inc., 53 Temple Place Ste 330,
+##   Boston MA 02111-1307, USA; either version 2 of the License, or
+##   (at your option) any later version; incorporated herein by reference.
+##
+## -----------------------------------------------------------------------
+
+##
+## samples for syslinux users
+##
+
+topdir = ../..
+MAKEDIR = $(topdir)/mk
+include $(MAKEDIR)/com32.mk
+
+all:	acpioff.c32
+
+tidy dist:
+	rm -f *.o *.lo *.a *.lst *.elf .*.d *.tmp
+
+clean: tidy
+	rm -f *.lnx
+
+spotless: clean
+	rm -f *.lss *.c32 *.com
+	rm -f *~ \#*
+
+install:	
+
+-include .*.d

From cd77d258a257e7ba80a9cfc307b32ed4478e8777 Mon Sep 17 00:00:00 2001
From: Andy Walls <awalls@md.metrocast.net>
Date: Sat, 14 Jan 2012 13:22:29 -0500
Subject: [PATCH 02/20] acpioff: Add a "Linux-ized" version of the ACPICA.org
 source for ACPI

The acpioff.c32 module will use the ACPICA to implement ACPI as an "OS".
No OS Layer routines or environment changes had been added yet.  This is
simply a linuxized verison of the ACPICA source as created by utilities in
the ACPICA source distribution.  (I like Linux coding conventions.)

Initially created from the ACPICA Git repository on 14 Jan 2012
using the following steps:

	$ cd ~/foo
	$ git clone git://github.com/otcshare/acpica.git
	$ cd acpica/generate/linux/patches
	$ ./acpisrc.sh ~/foo/acpica/
	$ ./linuxize.sh ~/foo/acpica/
	$ mv new.linux ~/foo/syslinux/com32/acpioff/acpica_linuxized

Signed-off-by: Andy Walls <awalls@md.metrocast.net>
---
 com32/acpioff/acpica_linuxized/README         |   10 +
 .../drivers/acpi/acpica/accommon.h            |   63 +
 .../drivers/acpi/acpica/acconfig.h            |  210 +++
 .../drivers/acpi/acpica/acdebug.h             |  252 ++++
 .../drivers/acpi/acpica/acdispat.h            |  354 +++++
 .../drivers/acpi/acpica/acevents.h            |  244 ++++
 .../drivers/acpi/acpica/acglobal.h            |  465 ++++++
 .../drivers/acpi/acpica/achware.h             |  142 ++
 .../drivers/acpi/acpica/acinterp.h            |  532 +++++++
 .../drivers/acpi/acpica/aclocal.h             | 1115 +++++++++++++++
 .../drivers/acpi/acpica/acmacros.h            |  525 +++++++
 .../drivers/acpi/acpica/acnamesp.h            |  356 +++++
 .../drivers/acpi/acpica/acobject.h            |  460 ++++++
 .../drivers/acpi/acpica/acopcode.h            |  327 +++++
 .../drivers/acpi/acpica/acparser.h            |  231 +++
 .../drivers/acpi/acpica/acpredef.h            |  568 ++++++++
 .../drivers/acpi/acpica/acresrc.h             |  376 +++++
 .../drivers/acpi/acpica/acstruct.h            |  228 +++
 .../drivers/acpi/acpica/actables.h            |  120 ++
 .../drivers/acpi/acpica/acutils.h             |  642 +++++++++
 .../drivers/acpi/acpica/amlcode.h             |  487 +++++++
 .../drivers/acpi/acpica/amlresrc.h            |  453 ++++++
 .../drivers/acpi/acpica/dsargs.c              |  398 ++++++
 .../drivers/acpi/acpica/dscontrol.c           |  410 ++++++
 .../drivers/acpi/acpica/dsfield.c             |  707 +++++++++
 .../drivers/acpi/acpica/dsinit.c              |  217 +++
 .../drivers/acpi/acpica/dsmethod.c            |  681 +++++++++
 .../drivers/acpi/acpica/dsmthdat.c            |  714 ++++++++++
 .../drivers/acpi/acpica/dsobject.c            |  841 +++++++++++
 .../drivers/acpi/acpica/dsopcode.c            |  757 ++++++++++
 .../drivers/acpi/acpica/dsutils.c             |  870 ++++++++++++
 .../drivers/acpi/acpica/dswexec.c             |  760 ++++++++++
 .../drivers/acpi/acpica/dswload.c             |  539 +++++++
 .../drivers/acpi/acpica/dswload2.c            |  720 ++++++++++
 .../drivers/acpi/acpica/dswscope.c            |  214 +++
 .../drivers/acpi/acpica/dswstate.c            |  758 ++++++++++
 .../drivers/acpi/acpica/evevent.c             |  293 ++++
 .../drivers/acpi/acpica/evglock.c             |  341 +++++
 .../drivers/acpi/acpica/evgpe.c               |  757 ++++++++++
 .../drivers/acpi/acpica/evgpeblk.c            |  506 +++++++
 .../drivers/acpi/acpica/evgpeinit.c           |  438 ++++++
 .../drivers/acpi/acpica/evgpeutil.c           |  376 +++++
 .../drivers/acpi/acpica/evmisc.c              |  334 +++++
 .../drivers/acpi/acpica/evregion.c            | 1265 +++++++++++++++++
 .../drivers/acpi/acpica/evrgnini.c            |  673 +++++++++
 .../drivers/acpi/acpica/evsci.c               |  184 +++
 .../drivers/acpi/acpica/evxface.c             |  853 +++++++++++
 .../drivers/acpi/acpica/evxfevnt.c            |  323 +++++
 .../drivers/acpi/acpica/evxfgpe.c             |  770 ++++++++++
 .../drivers/acpi/acpica/evxfregn.c            |  292 ++++
 .../drivers/acpi/acpica/exconfig.c            |  630 ++++++++
 .../drivers/acpi/acpica/exconvrt.c            |  687 +++++++++
 .../drivers/acpi/acpica/excreate.c            |  531 +++++++
 .../drivers/acpi/acpica/exdebug.c             |  261 ++++
 .../drivers/acpi/acpica/exdump.c              | 1039 ++++++++++++++
 .../drivers/acpi/acpica/exfield.c             |  377 +++++
 .../drivers/acpi/acpica/exfldio.c             |  997 +++++++++++++
 .../drivers/acpi/acpica/exmisc.c              |  724 ++++++++++
 .../drivers/acpi/acpica/exmutex.c             |  499 +++++++
 .../drivers/acpi/acpica/exnames.c             |  436 ++++++
 .../drivers/acpi/acpica/exoparg1.c            | 1037 ++++++++++++++
 .../drivers/acpi/acpica/exoparg2.c            |  578 ++++++++
 .../drivers/acpi/acpica/exoparg3.c            |  272 ++++
 .../drivers/acpi/acpica/exoparg6.c            |  338 +++++
 .../drivers/acpi/acpica/exprep.c              |  623 ++++++++
 .../drivers/acpi/acpica/exregion.c            |  520 +++++++
 .../drivers/acpi/acpica/exresnte.c            |  278 ++++
 .../drivers/acpi/acpica/exresolv.c            |  551 +++++++
 .../drivers/acpi/acpica/exresop.c             |  701 +++++++++
 .../drivers/acpi/acpica/exstore.c             |  502 +++++++
 .../drivers/acpi/acpica/exstoren.c            |  299 ++++
 .../drivers/acpi/acpica/exstorob.c            |  221 +++
 .../drivers/acpi/acpica/exsystem.c            |  311 ++++
 .../drivers/acpi/acpica/exutils.c             |  463 ++++++
 .../drivers/acpi/acpica/hwacpi.c              |  185 +++
 .../drivers/acpi/acpica/hwgpe.c               |  485 +++++++
 .../drivers/acpi/acpica/hwpci.c               |  412 ++++++
 .../drivers/acpi/acpica/hwregs.c              |  658 +++++++++
 .../drivers/acpi/acpica/hwsleep.c             |  586 ++++++++
 .../drivers/acpi/acpica/hwtimer.c             |  187 +++
 .../drivers/acpi/acpica/hwvalid.c             |  329 +++++
 .../drivers/acpi/acpica/hwxface.c             |  573 ++++++++
 .../drivers/acpi/acpica/nsaccess.c            |  670 +++++++++
 .../drivers/acpi/acpica/nsalloc.c             |  516 +++++++
 .../drivers/acpi/acpica/nsdump.c              |  718 ++++++++++
 .../drivers/acpi/acpica/nsdumpdv.c            |  141 ++
 .../drivers/acpi/acpica/nseval.c              |  452 ++++++
 .../drivers/acpi/acpica/nsinit.c              |  611 ++++++++
 .../drivers/acpi/acpica/nsload.c              |  314 ++++
 .../drivers/acpi/acpica/nsnames.c             |  266 ++++
 .../drivers/acpi/acpica/nsobject.c            |  448 ++++++
 .../drivers/acpi/acpica/nsparse.c             |  202 +++
 .../drivers/acpi/acpica/nspredef.c            | 1172 +++++++++++++++
 .../drivers/acpi/acpica/nsrepair.c            |  730 ++++++++++
 .../drivers/acpi/acpica/nsrepair2.c           |  754 ++++++++++
 .../drivers/acpi/acpica/nssearch.c            |  399 ++++++
 .../drivers/acpi/acpica/nsutils.c             |  750 ++++++++++
 .../drivers/acpi/acpica/nswalk.c              |  357 +++++
 .../drivers/acpi/acpica/nsxfeval.c            |  857 +++++++++++
 .../drivers/acpi/acpica/nsxfname.c            |  637 +++++++++
 .../drivers/acpi/acpica/nsxfobj.c             |  244 ++++
 .../drivers/acpi/acpica/psargs.c              |  867 +++++++++++
 .../drivers/acpi/acpica/psloop.c              | 1215 ++++++++++++++++
 .../drivers/acpi/acpica/psopcode.c            |  824 +++++++++++
 .../drivers/acpi/acpica/psparse.c             |  689 +++++++++
 .../drivers/acpi/acpica/psscope.c             |  265 ++++
 .../drivers/acpi/acpica/pstree.c              |  316 ++++
 .../drivers/acpi/acpica/psutils.c             |  242 ++++
 .../drivers/acpi/acpica/pswalk.c              |  110 ++
 .../drivers/acpi/acpica/psxface.c             |  392 +++++
 .../drivers/acpi/acpica/rsaddr.c              |  381 +++++
 .../drivers/acpi/acpica/rscalc.c              |  693 +++++++++
 .../drivers/acpi/acpica/rscreate.c            |  507 +++++++
 .../drivers/acpi/acpica/rsdump.c              |  949 +++++++++++++
 .../drivers/acpi/acpica/rsinfo.c              |  248 ++++
 .../drivers/acpi/acpica/rsio.c                |  290 ++++
 .../drivers/acpi/acpica/rsirq.c               |  295 ++++
 .../drivers/acpi/acpica/rslist.c              |  250 ++++
 .../drivers/acpi/acpica/rsmemory.c            |  234 +++
 .../drivers/acpi/acpica/rsmisc.c              |  820 +++++++++++
 .../drivers/acpi/acpica/rsserial.c            |  441 ++++++
 .../drivers/acpi/acpica/rsutils.c             |  781 ++++++++++
 .../drivers/acpi/acpica/rsxface.c             |  618 ++++++++
 .../drivers/acpi/acpica/tbfadt.c              |  666 +++++++++
 .../drivers/acpi/acpica/tbfind.c              |  140 ++
 .../drivers/acpi/acpica/tbinstal.c            |  653 +++++++++
 .../drivers/acpi/acpica/tbutils.c             |  695 +++++++++
 .../drivers/acpi/acpica/tbxface.c             |  637 +++++++++
 .../drivers/acpi/acpica/tbxfroot.c            |  276 ++++
 .../drivers/acpi/acpica/utaddress.c           |  294 ++++
 .../drivers/acpi/acpica/utalloc.c             |  382 +++++
 .../drivers/acpi/acpica/utcache.c             |  323 +++++
 .../drivers/acpi/acpica/utclib.c              |  748 ++++++++++
 .../drivers/acpi/acpica/utcopy.c              | 1001 +++++++++++++
 .../drivers/acpi/acpica/utdebug.c             |  650 +++++++++
 .../drivers/acpi/acpica/utdecode.c            |  551 +++++++
 .../drivers/acpi/acpica/utdelete.c            |  707 +++++++++
 .../drivers/acpi/acpica/uteval.c              |  337 +++++
 .../drivers/acpi/acpica/utglobal.c            |  388 +++++
 .../drivers/acpi/acpica/utids.c               |  345 +++++
 .../drivers/acpi/acpica/utinit.c              |  143 ++
 .../drivers/acpi/acpica/utlock.c              |  175 +++
 .../drivers/acpi/acpica/utmath.c              |  324 +++++
 .../drivers/acpi/acpica/utmisc.c              | 1134 +++++++++++++++
 .../drivers/acpi/acpica/utmutex.c             |  351 +++++
 .../drivers/acpi/acpica/utobject.c            |  707 +++++++++
 .../drivers/acpi/acpica/utosi.c               |  380 +++++
 .../drivers/acpi/acpica/utresrc.c             |  824 +++++++++++
 .../drivers/acpi/acpica/utstate.c             |  346 +++++
 .../drivers/acpi/acpica/uttrack.c             |  648 +++++++++
 .../drivers/acpi/acpica/utxface.c             |  720 ++++++++++
 .../drivers/acpi/acpica/utxferror.c           |  415 ++++++
 .../drivers/acpi/acpica/utxfmutex.c           |  187 +++
 .../acpica_linuxized/include/acpi/acapps.h    |  161 +++
 .../acpica_linuxized/include/acpi/acdisasm.h  |  620 ++++++++
 .../acpica_linuxized/include/acpi/acexcep.h   |  297 ++++
 .../acpica_linuxized/include/acpi/acnames.h   |   84 ++
 .../acpica_linuxized/include/acpi/acoutput.h  |  283 ++++
 .../acpica_linuxized/include/acpi/acpi.h      |   66 +
 .../acpica_linuxized/include/acpi/acpiosxf.h  |  265 ++++
 .../acpica_linuxized/include/acpi/acpixf.h    |  450 ++++++
 .../acpica_linuxized/include/acpi/acrestyp.h  |  604 ++++++++
 .../acpica_linuxized/include/acpi/actbl.h     |  389 +++++
 .../acpica_linuxized/include/acpi/actbl1.h    |  963 +++++++++++++
 .../acpica_linuxized/include/acpi/actbl2.h    | 1048 ++++++++++++++
 .../acpica_linuxized/include/acpi/actbl3.h    |  552 +++++++
 .../acpica_linuxized/include/acpi/actypes.h   | 1105 ++++++++++++++
 .../include/acpi/platform/accygwin.h          |   91 ++
 .../include/acpi/platform/acefi.h             |   73 +
 .../include/acpi/platform/acenv.h             |  388 +++++
 .../include/acpi/platform/acfreebsd.h         |  104 ++
 .../include/acpi/platform/acgcc.h             |   67 +
 .../include/acpi/platform/acintel.h           |   81 ++
 .../include/acpi/platform/aclinux.h           |  159 +++
 .../include/acpi/platform/acmsvc.h            |  144 ++
 .../include/acpi/platform/acnetbsd.h          |  115 ++
 .../include/acpi/platform/acos2.h             |   93 ++
 .../include/acpi/platform/acwin.h             |  145 ++
 .../include/acpi/platform/acwin64.h           |   82 ++
 179 files changed, 85682 insertions(+)
 create mode 100644 com32/acpioff/acpica_linuxized/README
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/accommon.h
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acconfig.h
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acdebug.h
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acdispat.h
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acevents.h
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acglobal.h
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/achware.h
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acinterp.h
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/aclocal.h
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acmacros.h
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acnamesp.h
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acobject.h
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acopcode.h
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acparser.h
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acpredef.h
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acresrc.h
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acstruct.h
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/actables.h
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acutils.h
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/amlcode.h
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/amlresrc.h
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/dsargs.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/dscontrol.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/dsfield.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/dsinit.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/dsmethod.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/dsmthdat.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/dsobject.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/dsopcode.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/dsutils.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/dswexec.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/dswload.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/dswload2.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/dswscope.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/dswstate.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/evevent.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/evglock.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/evgpe.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/evgpeblk.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/evgpeinit.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/evgpeutil.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/evmisc.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/evregion.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/evrgnini.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/evsci.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/evxface.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/evxfevnt.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/evxfgpe.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/evxfregn.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exconfig.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exconvrt.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/excreate.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exdebug.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exdump.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exfield.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exfldio.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exmisc.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exmutex.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exnames.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exoparg1.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exoparg2.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exoparg3.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exoparg6.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exprep.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exregion.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exresnte.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exresolv.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exresop.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exstore.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exstoren.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exstorob.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exsystem.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exutils.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/hwacpi.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/hwgpe.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/hwpci.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/hwregs.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/hwsleep.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/hwtimer.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/hwvalid.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/hwxface.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nsaccess.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nsalloc.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nsdump.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nsdumpdv.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nseval.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nsinit.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nsload.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nsnames.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nsobject.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nsparse.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nspredef.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nsrepair.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nsrepair2.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nssearch.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nsutils.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nswalk.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nsxfeval.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nsxfname.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nsxfobj.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/psargs.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/psloop.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/psopcode.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/psparse.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/psscope.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/pstree.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/psutils.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/pswalk.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/psxface.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/rsaddr.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/rscalc.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/rscreate.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/rsdump.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/rsinfo.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/rsio.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/rsirq.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/rslist.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/rsmemory.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/rsmisc.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/rsserial.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/rsutils.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/rsxface.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/tbfadt.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/tbfind.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/tbinstal.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/tbutils.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/tbxface.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/tbxfroot.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utaddress.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utalloc.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utcache.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utclib.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utcopy.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utdebug.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utdecode.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utdelete.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/uteval.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utglobal.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utids.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utinit.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utlock.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utmath.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utmisc.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utmutex.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utobject.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utosi.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utresrc.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utstate.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/uttrack.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utxface.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utxferror.c
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utxfmutex.c
 create mode 100644 com32/acpioff/acpica_linuxized/include/acpi/acapps.h
 create mode 100644 com32/acpioff/acpica_linuxized/include/acpi/acdisasm.h
 create mode 100644 com32/acpioff/acpica_linuxized/include/acpi/acexcep.h
 create mode 100644 com32/acpioff/acpica_linuxized/include/acpi/acnames.h
 create mode 100644 com32/acpioff/acpica_linuxized/include/acpi/acoutput.h
 create mode 100644 com32/acpioff/acpica_linuxized/include/acpi/acpi.h
 create mode 100644 com32/acpioff/acpica_linuxized/include/acpi/acpiosxf.h
 create mode 100644 com32/acpioff/acpica_linuxized/include/acpi/acpixf.h
 create mode 100644 com32/acpioff/acpica_linuxized/include/acpi/acrestyp.h
 create mode 100644 com32/acpioff/acpica_linuxized/include/acpi/actbl.h
 create mode 100644 com32/acpioff/acpica_linuxized/include/acpi/actbl1.h
 create mode 100644 com32/acpioff/acpica_linuxized/include/acpi/actbl2.h
 create mode 100644 com32/acpioff/acpica_linuxized/include/acpi/actbl3.h
 create mode 100644 com32/acpioff/acpica_linuxized/include/acpi/actypes.h
 create mode 100644 com32/acpioff/acpica_linuxized/include/acpi/platform/accygwin.h
 create mode 100644 com32/acpioff/acpica_linuxized/include/acpi/platform/acefi.h
 create mode 100644 com32/acpioff/acpica_linuxized/include/acpi/platform/acenv.h
 create mode 100644 com32/acpioff/acpica_linuxized/include/acpi/platform/acfreebsd.h
 create mode 100644 com32/acpioff/acpica_linuxized/include/acpi/platform/acgcc.h
 create mode 100644 com32/acpioff/acpica_linuxized/include/acpi/platform/acintel.h
 create mode 100644 com32/acpioff/acpica_linuxized/include/acpi/platform/aclinux.h
 create mode 100644 com32/acpioff/acpica_linuxized/include/acpi/platform/acmsvc.h
 create mode 100644 com32/acpioff/acpica_linuxized/include/acpi/platform/acnetbsd.h
 create mode 100644 com32/acpioff/acpica_linuxized/include/acpi/platform/acos2.h
 create mode 100644 com32/acpioff/acpica_linuxized/include/acpi/platform/acwin.h
 create mode 100644 com32/acpioff/acpica_linuxized/include/acpi/platform/acwin64.h

diff --git a/com32/acpioff/acpica_linuxized/README b/com32/acpioff/acpica_linuxized/README
new file mode 100644
index 00000000..10cbc51e
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/README
@@ -0,0 +1,10 @@
+Initially created from the ACPICA Git repository on 14 Jan 2012
+using the following steps:
+
+	$ cd ~/foo
+	$ git clone git://github.com/otcshare/acpica.git
+	$ cd acpica/generate/linux/patches
+	$ ./acpisrc.sh  ~/foo/acpica/
+	$ ./linuxize.sh ~/foo/acpica/
+	$ mv new.linux ~/foo/syslinux/com32/acpioff/acpica_linuxized
+
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/accommon.h b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/accommon.h
new file mode 100644
index 00000000..a44bd424
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/accommon.h
@@ -0,0 +1,63 @@
+/******************************************************************************
+ *
+ * Name: accommon.h - Common include files for generation of ACPICA source
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACCOMMON_H__
+#define __ACCOMMON_H__
+
+/*
+ * Common set of includes for all ACPICA source files.
+ * We put them here because we don't want to duplicate them
+ * in the the source code again and again.
+ *
+ * Note: The order of these include files is important.
+ */
+#include "acconfig.h"		/* Global configuration constants */
+#include "acmacros.h"		/* C macros */
+#include "aclocal.h"		/* Internal data types */
+#include "acobject.h"		/* ACPI internal object */
+#include "acstruct.h"		/* Common structures */
+#include "acglobal.h"		/* All global variables */
+#include "achware.h"		/* Hardware defines and interfaces */
+#include "acutils.h"		/* Utility interfaces */
+
+#endif				/* __ACCOMMON_H__ */
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acconfig.h b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acconfig.h
new file mode 100644
index 00000000..a5b17600
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acconfig.h
@@ -0,0 +1,210 @@
+/******************************************************************************
+ *
+ * Name: acconfig.h - Global configuration constants
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef _ACCONFIG_H
+#define _ACCONFIG_H
+
+/******************************************************************************
+ *
+ * Configuration options
+ *
+ *****************************************************************************/
+
+/*
+ * ACPI_DEBUG_OUTPUT    - This switch enables all the debug facilities of the
+ *                        ACPI subsystem.  This includes the DEBUG_PRINT output
+ *                        statements.  When disabled, all DEBUG_PRINT
+ *                        statements are compiled out.
+ *
+ * ACPI_APPLICATION     - Use this switch if the subsystem is going to be run
+ *                        at the application level.
+ *
+ */
+
+/*
+ * OS name, used for the _OS object.  The _OS object is essentially obsolete,
+ * but there is a large base of ASL/AML code in existing machines that check
+ * for the string below.  The use of this string usually guarantees that
+ * the ASL will execute down the most tested code path.  Also, there is some
+ * code that will not execute the _OSI method unless _OS matches the string
+ * below.  Therefore, change this string at your own risk.
+ */
+#define ACPI_OS_NAME                    "Microsoft Windows NT"
+
+/* Maximum objects in the various object caches */
+
+#define ACPI_MAX_STATE_CACHE_DEPTH      96	/* State objects */
+#define ACPI_MAX_PARSE_CACHE_DEPTH      96	/* Parse tree objects */
+#define ACPI_MAX_EXTPARSE_CACHE_DEPTH   96	/* Parse tree objects */
+#define ACPI_MAX_OBJECT_CACHE_DEPTH     96	/* Interpreter operand objects */
+#define ACPI_MAX_NAMESPACE_CACHE_DEPTH  96	/* Namespace objects */
+
+/*
+ * Should the subsystem abort the loading of an ACPI table if the
+ * table checksum is incorrect?
+ */
+#define ACPI_CHECKSUM_ABORT             FALSE
+
+/******************************************************************************
+ *
+ * Subsystem Constants
+ *
+ *****************************************************************************/
+
+/* Version of ACPI supported */
+
+#define ACPI_CA_SUPPORT_LEVEL           3
+
+/* Maximum count for a semaphore object */
+
+#define ACPI_MAX_SEMAPHORE_COUNT        256
+
+/* Maximum object reference count (detects object deletion issues) */
+
+#define ACPI_MAX_REFERENCE_COUNT        0x800
+
+/* Default page size for use in mapping memory for operation regions */
+
+#define ACPI_DEFAULT_PAGE_SIZE          4096	/* Must be power of 2 */
+
+/* owner_id tracking. 8 entries allows for 255 owner_ids */
+
+#define ACPI_NUM_OWNERID_MASKS          8
+
+/* Size of the root table array is increased by this increment */
+
+#define ACPI_ROOT_TABLE_SIZE_INCREMENT  4
+
+/* Maximum number of While() loop iterations before forced abort */
+
+#define ACPI_MAX_LOOP_ITERATIONS        0xFFFF
+
+/* Maximum sleep allowed via Sleep() operator */
+
+#define ACPI_MAX_SLEEP                  2000	/* 2000 millisec == two seconds */
+
+/* Address Range lists are per-space_id (Memory and I/O only) */
+
+#define ACPI_ADDRESS_RANGE_MAX          2
+
+/******************************************************************************
+ *
+ * ACPI Specification constants (Do not change unless the specification changes)
+ *
+ *****************************************************************************/
+
+/* Method info (in WALK_STATE), containing local variables and argumetns */
+
+#define ACPI_METHOD_NUM_LOCALS          8
+#define ACPI_METHOD_MAX_LOCAL           7
+
+#define ACPI_METHOD_NUM_ARGS            7
+#define ACPI_METHOD_MAX_ARG             6
+
+/*
+ * Operand Stack (in WALK_STATE), Must be large enough to contain METHOD_MAX_ARG
+ */
+#define ACPI_OBJ_NUM_OPERANDS           8
+#define ACPI_OBJ_MAX_OPERAND            7
+
+/* Number of elements in the Result Stack frame, can be an arbitrary value */
+
+#define ACPI_RESULTS_FRAME_OBJ_NUM      8
+
+/*
+ * Maximal number of elements the Result Stack can contain,
+ * it may be an arbitray value not exceeding the types of
+ * result_size and result_count (now u8).
+ */
+#define ACPI_RESULTS_OBJ_NUM_MAX        255
+
+/* Constants used in searching for the RSDP in low memory */
+
+#define ACPI_EBDA_PTR_LOCATION          0x0000040E	/* Physical Address */
+#define ACPI_EBDA_PTR_LENGTH            2
+#define ACPI_EBDA_WINDOW_SIZE           1024
+#define ACPI_HI_RSDP_WINDOW_BASE        0x000E0000	/* Physical Address */
+#define ACPI_HI_RSDP_WINDOW_SIZE        0x00020000
+#define ACPI_RSDP_SCAN_STEP             16
+
+/* Operation regions */
+
+#define ACPI_USER_REGION_BEGIN          0x80
+
+/* Maximum space_ids for Operation Regions */
+
+#define ACPI_MAX_ADDRESS_SPACE          255
+
+/* Array sizes.  Used for range checking also */
+
+#define ACPI_MAX_MATCH_OPCODE           5
+
+/* RSDP checksums */
+
+#define ACPI_RSDP_CHECKSUM_LENGTH       20
+#define ACPI_RSDP_XCHECKSUM_LENGTH      36
+
+/* SMBus, GSBus and IPMI bidirectional buffer size */
+
+#define ACPI_SMBUS_BUFFER_SIZE          34
+#define ACPI_GSBUS_BUFFER_SIZE          34
+#define ACPI_IPMI_BUFFER_SIZE           66
+
+/* _sx_d and _sx_w control methods */
+
+#define ACPI_NUM_sx_d_METHODS           4
+#define ACPI_NUM_sx_w_METHODS           5
+
+/******************************************************************************
+ *
+ * ACPI AML Debugger
+ *
+ *****************************************************************************/
+
+#define ACPI_DEBUGGER_MAX_ARGS          ACPI_METHOD_NUM_ARGS + 2	/* Max command line arguments */
+#define ACPI_DB_LINE_BUFFER_SIZE        512
+
+#define ACPI_DEBUGGER_COMMAND_PROMPT    '-'
+#define ACPI_DEBUGGER_EXECUTE_PROMPT    '%'
+
+#endif				/* _ACCONFIG_H */
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acdebug.h b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acdebug.h
new file mode 100644
index 00000000..03fa1323
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acdebug.h
@@ -0,0 +1,252 @@
+/******************************************************************************
+ *
+ * Name: acdebug.h - ACPI/AML debugger
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACDEBUG_H__
+#define __ACDEBUG_H__
+
+#define ACPI_DEBUG_BUFFER_SIZE  0x4000	/* 16_k buffer for return objects */
+
+struct command_info {
+	char *name;		/* Command Name */
+	u8 min_args;		/* Minimum arguments required */
+};
+
+struct argument_info {
+	char *name;		/* Argument Name */
+};
+
+struct acpi_execute_walk {
+	u32 count;
+	u32 max_count;
+};
+
+#define PARAM_LIST(pl)                  pl
+#define DBTEST_OUTPUT_LEVEL(lvl)        if (acpi_gbl_db_opt_verbose)
+#define VERBOSE_PRINT(fp)               DBTEST_OUTPUT_LEVEL(lvl) {\
+			  acpi_os_printf PARAM_LIST(fp);}
+
+#define EX_NO_SINGLE_STEP               1
+#define EX_SINGLE_STEP                  2
+
+/*
+ * dbxface - external debugger interfaces
+ */
+acpi_status acpi_db_initialize(void);
+
+void acpi_db_terminate(void);
+
+acpi_status
+acpi_db_single_step(struct acpi_walk_state *walk_state,
+		    union acpi_parse_object *op, u32 op_type);
+
+/*
+ * dbcmds - debug commands and output routines
+ */
+struct acpi_namespace_node *acpi_db_convert_to_node(char *in_string);
+
+void acpi_db_display_table_info(char *table_arg);
+
+void acpi_db_display_template(char *buffer_arg);
+
+void acpi_db_unload_acpi_table(char *table_arg, char *instance_arg);
+
+void acpi_db_send_notify(char *name, u32 value);
+
+void acpi_db_display_interfaces(char *action_arg, char *interface_name_arg);
+
+acpi_status acpi_db_sleep(char *object_arg);
+
+void acpi_db_display_locks(void);
+
+void acpi_db_display_resources(char *object_arg);
+
+void acpi_db_display_gpes(void);
+
+void acpi_db_display_handlers(void);
+
+void acpi_db_generate_gpe(char *gpe_arg, char *block_arg);
+
+/*
+ * dbmethod - control method commands
+ */
+void
+acpi_db_set_method_breakpoint(char *location,
+			      struct acpi_walk_state *walk_state,
+			      union acpi_parse_object *op);
+
+void acpi_db_set_method_call_breakpoint(union acpi_parse_object *op);
+
+void acpi_db_set_method_data(char *type_arg, char *index_arg, char *value_arg);
+
+acpi_status acpi_db_disassemble_method(char *name);
+
+void acpi_db_disassemble_aml(char *statements, union acpi_parse_object *op);
+
+void acpi_db_batch_execute(char *count_arg);
+
+/*
+ * dbnames - namespace commands
+ */
+void acpi_db_set_scope(char *name);
+
+void acpi_db_dump_namespace(char *start_arg, char *depth_arg);
+
+void acpi_db_dump_namespace_by_owner(char *owner_arg, char *depth_arg);
+
+acpi_status acpi_db_find_name_in_namespace(char *name_arg);
+
+void acpi_db_check_predefined_names(void);
+
+acpi_status
+acpi_db_display_objects(char *obj_type_arg, char *display_count_arg);
+
+void acpi_db_check_integrity(void);
+
+void acpi_db_find_references(char *object_arg);
+
+void acpi_db_get_bus_info(void);
+
+/*
+ * dbdisply - debug display commands
+ */
+void acpi_db_display_method_info(union acpi_parse_object *op);
+
+void acpi_db_decode_and_display_object(char *target, char *output_type);
+
+void
+acpi_db_display_result_object(union acpi_operand_object *obj_desc,
+			      struct acpi_walk_state *walk_state);
+
+acpi_status acpi_db_display_all_methods(char *display_count_arg);
+
+void acpi_db_display_arguments(void);
+
+void acpi_db_display_locals(void);
+
+void acpi_db_display_results(void);
+
+void acpi_db_display_calling_tree(void);
+
+void acpi_db_display_object_type(char *object_arg);
+
+void
+acpi_db_display_argument_object(union acpi_operand_object *obj_desc,
+				struct acpi_walk_state *walk_state);
+
+/*
+ * dbexec - debugger control method execution
+ */
+void
+acpi_db_execute(char *name, char **args, acpi_object_type * types, u32 flags);
+
+void
+acpi_db_create_execution_threads(char *num_threads_arg,
+				 char *num_loops_arg, char *method_name_arg);
+
+#ifdef ACPI_DBG_TRACK_ALLOCATIONS
+u32 acpi_db_get_cache_info(struct acpi_memory_list *cache);
+#endif
+
+/*
+ * dbfileio - Debugger file I/O commands
+ */
+acpi_object_type
+acpi_db_match_argument(char *user_argument, struct argument_info *arguments);
+
+void acpi_db_close_debug_file(void);
+
+void acpi_db_open_debug_file(char *name);
+
+acpi_status acpi_db_load_acpi_table(char *filename);
+
+acpi_status
+acpi_db_get_table_from_file(char *filename, struct acpi_table_header **table);
+
+acpi_status
+acpi_db_read_table_from_file(char *filename, struct acpi_table_header **table);
+
+/*
+ * dbhistry - debugger HISTORY command
+ */
+void acpi_db_add_to_history(char *command_line);
+
+void acpi_db_display_history(void);
+
+char *acpi_db_get_from_history(char *command_num_arg);
+
+/*
+ * dbinput - user front-end to the AML debugger
+ */
+acpi_status
+acpi_db_command_dispatch(char *input_buffer,
+			 struct acpi_walk_state *walk_state,
+			 union acpi_parse_object *op);
+
+void ACPI_SYSTEM_XFACE acpi_db_execute_thread(void *context);
+
+acpi_status acpi_db_user_commands(char prompt, union acpi_parse_object *op);
+
+char *acpi_db_get_next_token(char *string,
+			     char **next, acpi_object_type * return_type);
+
+/*
+ * dbstats - Generation and display of ACPI table statistics
+ */
+void acpi_db_generate_statistics(union acpi_parse_object *root, u8 is_method);
+
+acpi_status acpi_db_display_statistics(char *type_arg);
+
+/*
+ * dbutils - AML debugger utilities
+ */
+void acpi_db_set_output_destination(u32 where);
+
+void acpi_db_dump_external_object(union acpi_object *obj_desc, u32 level);
+
+void acpi_db_prep_namestring(char *name);
+
+struct acpi_namespace_node *acpi_db_local_ns_lookup(char *name);
+
+void acpi_db_uint32_to_hex_string(u32 value, char *buffer);
+
+#endif				/* __ACDEBUG_H__ */
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acdispat.h b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acdispat.h
new file mode 100644
index 00000000..9dc1cc7c
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acdispat.h
@@ -0,0 +1,354 @@
+/******************************************************************************
+ *
+ * Name: acdispat.h - dispatcher (parser to interpreter interface)
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef _ACDISPAT_H_
+#define _ACDISPAT_H_
+
+#define NAMEOF_LOCAL_NTE    "__L0"
+#define NAMEOF_ARG_NTE      "__A0"
+
+/*
+ * dsargs - execution of dynamic arguments for static objects
+ */
+acpi_status
+acpi_ds_get_buffer_field_arguments(union acpi_operand_object *obj_desc);
+
+acpi_status
+acpi_ds_get_bank_field_arguments(union acpi_operand_object *obj_desc);
+
+acpi_status acpi_ds_get_region_arguments(union acpi_operand_object *rgn_desc);
+
+acpi_status acpi_ds_get_buffer_arguments(union acpi_operand_object *obj_desc);
+
+acpi_status acpi_ds_get_package_arguments(union acpi_operand_object *obj_desc);
+
+/*
+ * dscontrol - support for execution control opcodes
+ */
+acpi_status
+acpi_ds_exec_begin_control_op(struct acpi_walk_state *walk_state,
+			      union acpi_parse_object *op);
+
+acpi_status
+acpi_ds_exec_end_control_op(struct acpi_walk_state *walk_state,
+			    union acpi_parse_object *op);
+
+/*
+ * dsopcode - support for late operand evaluation
+ */
+acpi_status
+acpi_ds_eval_buffer_field_operands(struct acpi_walk_state *walk_state,
+				   union acpi_parse_object *op);
+
+acpi_status
+acpi_ds_eval_region_operands(struct acpi_walk_state *walk_state,
+			     union acpi_parse_object *op);
+
+acpi_status
+acpi_ds_eval_table_region_operands(struct acpi_walk_state *walk_state,
+				   union acpi_parse_object *op);
+
+acpi_status
+acpi_ds_eval_data_object_operands(struct acpi_walk_state *walk_state,
+				  union acpi_parse_object *op,
+				  union acpi_operand_object *obj_desc);
+
+acpi_status
+acpi_ds_eval_bank_field_operands(struct acpi_walk_state *walk_state,
+				 union acpi_parse_object *op);
+
+acpi_status acpi_ds_initialize_region(acpi_handle obj_handle);
+
+/*
+ * dsexec - Parser/Interpreter interface, method execution callbacks
+ */
+acpi_status
+acpi_ds_get_predicate_value(struct acpi_walk_state *walk_state,
+			    union acpi_operand_object *result_obj);
+
+acpi_status
+acpi_ds_exec_begin_op(struct acpi_walk_state *walk_state,
+		      union acpi_parse_object **out_op);
+
+acpi_status acpi_ds_exec_end_op(struct acpi_walk_state *state);
+
+/*
+ * dsfield - Parser/Interpreter interface for AML fields
+ */
+acpi_status
+acpi_ds_create_field(union acpi_parse_object *op,
+		     struct acpi_namespace_node *region_node,
+		     struct acpi_walk_state *walk_state);
+
+acpi_status
+acpi_ds_create_bank_field(union acpi_parse_object *op,
+			  struct acpi_namespace_node *region_node,
+			  struct acpi_walk_state *walk_state);
+
+acpi_status
+acpi_ds_create_index_field(union acpi_parse_object *op,
+			   struct acpi_namespace_node *region_node,
+			   struct acpi_walk_state *walk_state);
+
+acpi_status
+acpi_ds_create_buffer_field(union acpi_parse_object *op,
+			    struct acpi_walk_state *walk_state);
+
+acpi_status
+acpi_ds_init_field_objects(union acpi_parse_object *op,
+			   struct acpi_walk_state *walk_state);
+
+/*
+ * dsload - Parser/Interpreter interface, pass 1 namespace load callbacks
+ */
+acpi_status
+acpi_ds_init_callbacks(struct acpi_walk_state *walk_state, u32 pass_number);
+
+acpi_status
+acpi_ds_load1_begin_op(struct acpi_walk_state *walk_state,
+		       union acpi_parse_object **out_op);
+
+acpi_status acpi_ds_load1_end_op(struct acpi_walk_state *walk_state);
+
+/*
+ * dsload - Parser/Interpreter interface, pass 2 namespace load callbacks
+ */
+acpi_status
+acpi_ds_load2_begin_op(struct acpi_walk_state *walk_state,
+		       union acpi_parse_object **out_op);
+
+acpi_status acpi_ds_load2_end_op(struct acpi_walk_state *walk_state);
+
+/*
+ * dsmthdat - method data (locals/args)
+ */
+acpi_status
+acpi_ds_store_object_to_local(u8 type,
+			      u32 index,
+			      union acpi_operand_object *src_desc,
+			      struct acpi_walk_state *walk_state);
+
+acpi_status
+acpi_ds_method_data_get_entry(u16 opcode,
+			      u32 index,
+			      struct acpi_walk_state *walk_state,
+			      union acpi_operand_object ***node);
+
+void acpi_ds_method_data_delete_all(struct acpi_walk_state *walk_state);
+
+u8 acpi_ds_is_method_value(union acpi_operand_object *obj_desc);
+
+acpi_status
+acpi_ds_method_data_get_value(u8 type,
+			      u32 index,
+			      struct acpi_walk_state *walk_state,
+			      union acpi_operand_object **dest_desc);
+
+acpi_status
+acpi_ds_method_data_init_args(union acpi_operand_object **params,
+			      u32 max_param_count,
+			      struct acpi_walk_state *walk_state);
+
+acpi_status
+acpi_ds_method_data_get_node(u8 type,
+			     u32 index,
+			     struct acpi_walk_state *walk_state,
+			     struct acpi_namespace_node **node);
+
+void acpi_ds_method_data_init(struct acpi_walk_state *walk_state);
+
+/*
+ * dsmethod - Parser/Interpreter interface - control method parsing
+ */
+acpi_status acpi_ds_parse_method(struct acpi_namespace_node *node);
+
+acpi_status
+acpi_ds_call_control_method(struct acpi_thread_state *thread,
+			    struct acpi_walk_state *walk_state,
+			    union acpi_parse_object *op);
+
+acpi_status
+acpi_ds_restart_control_method(struct acpi_walk_state *walk_state,
+			       union acpi_operand_object *return_desc);
+
+void
+acpi_ds_terminate_control_method(union acpi_operand_object *method_desc,
+				 struct acpi_walk_state *walk_state);
+
+acpi_status
+acpi_ds_begin_method_execution(struct acpi_namespace_node *method_node,
+			       union acpi_operand_object *obj_desc,
+			       struct acpi_walk_state *walk_state);
+
+acpi_status
+acpi_ds_method_error(acpi_status status, struct acpi_walk_state *walk_state);
+
+/*
+ * dsinit
+ */
+acpi_status
+acpi_ds_initialize_objects(u32 table_index,
+			   struct acpi_namespace_node *start_node);
+
+/*
+ * dsobject - Parser/Interpreter interface - object initialization and conversion
+ */
+acpi_status
+acpi_ds_build_internal_buffer_obj(struct acpi_walk_state *walk_state,
+				  union acpi_parse_object *op,
+				  u32 buffer_length,
+				  union acpi_operand_object **obj_desc_ptr);
+
+acpi_status
+acpi_ds_build_internal_package_obj(struct acpi_walk_state *walk_state,
+				   union acpi_parse_object *op,
+				   u32 package_length,
+				   union acpi_operand_object **obj_desc);
+
+acpi_status
+acpi_ds_init_object_from_op(struct acpi_walk_state *walk_state,
+			    union acpi_parse_object *op,
+			    u16 opcode, union acpi_operand_object **obj_desc);
+
+acpi_status
+acpi_ds_create_node(struct acpi_walk_state *walk_state,
+		    struct acpi_namespace_node *node,
+		    union acpi_parse_object *op);
+
+/*
+ * dsutils - Parser/Interpreter interface utility routines
+ */
+void acpi_ds_clear_implicit_return(struct acpi_walk_state *walk_state);
+
+u8
+acpi_ds_do_implicit_return(union acpi_operand_object *return_desc,
+			   struct acpi_walk_state *walk_state,
+			   u8 add_reference);
+
+u8
+acpi_ds_is_result_used(union acpi_parse_object *op,
+		       struct acpi_walk_state *walk_state);
+
+void
+acpi_ds_delete_result_if_not_used(union acpi_parse_object *op,
+				  union acpi_operand_object *result_obj,
+				  struct acpi_walk_state *walk_state);
+
+acpi_status
+acpi_ds_create_operand(struct acpi_walk_state *walk_state,
+		       union acpi_parse_object *arg, u32 args_remaining);
+
+acpi_status
+acpi_ds_create_operands(struct acpi_walk_state *walk_state,
+			union acpi_parse_object *first_arg);
+
+acpi_status acpi_ds_resolve_operands(struct acpi_walk_state *walk_state);
+
+void acpi_ds_clear_operands(struct acpi_walk_state *walk_state);
+
+acpi_status acpi_ds_evaluate_name_path(struct acpi_walk_state *walk_state);
+
+/*
+ * dswscope - Scope Stack manipulation
+ */
+acpi_status
+acpi_ds_scope_stack_push(struct acpi_namespace_node *node,
+			 acpi_object_type type,
+			 struct acpi_walk_state *walk_state);
+
+acpi_status acpi_ds_scope_stack_pop(struct acpi_walk_state *walk_state);
+
+void acpi_ds_scope_stack_clear(struct acpi_walk_state *walk_state);
+
+/*
+ * dswstate - parser WALK_STATE management routines
+ */
+acpi_status
+acpi_ds_obj_stack_push(void *object, struct acpi_walk_state *walk_state);
+
+acpi_status
+acpi_ds_obj_stack_pop(u32 pop_count, struct acpi_walk_state *walk_state);
+
+struct acpi_walk_state *acpi_ds_create_walk_state(acpi_owner_id owner_id,
+						  union acpi_parse_object
+						  *origin,
+						  union acpi_operand_object
+						  *mth_desc,
+						  struct acpi_thread_state
+						  *thread);
+
+acpi_status
+acpi_ds_init_aml_walk(struct acpi_walk_state *walk_state,
+		      union acpi_parse_object *op,
+		      struct acpi_namespace_node *method_node,
+		      u8 *aml_start,
+		      u32 aml_length,
+		      struct acpi_evaluate_info *info, u8 pass_number);
+
+void
+acpi_ds_obj_stack_pop_and_delete(u32 pop_count,
+				 struct acpi_walk_state *walk_state);
+
+void acpi_ds_delete_walk_state(struct acpi_walk_state *walk_state);
+
+struct acpi_walk_state *acpi_ds_pop_walk_state(struct acpi_thread_state
+					       *thread);
+
+void
+acpi_ds_push_walk_state(struct acpi_walk_state *walk_state,
+			struct acpi_thread_state *thread);
+
+acpi_status acpi_ds_result_stack_clear(struct acpi_walk_state *walk_state);
+
+struct acpi_walk_state *acpi_ds_get_current_walk_state(struct acpi_thread_state
+						       *thread);
+
+acpi_status
+acpi_ds_result_pop(union acpi_operand_object **object,
+		   struct acpi_walk_state *walk_state);
+
+acpi_status
+acpi_ds_result_push(union acpi_operand_object *object,
+		    struct acpi_walk_state *walk_state);
+
+#endif				/* _ACDISPAT_H_ */
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acevents.h b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acevents.h
new file mode 100644
index 00000000..d78a8a82
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acevents.h
@@ -0,0 +1,244 @@
+/******************************************************************************
+ *
+ * Name: acevents.h - Event subcomponent prototypes and defines
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACEVENTS_H__
+#define __ACEVENTS_H__
+
+/*
+ * evevent
+ */
+acpi_status acpi_ev_initialize_events(void);
+
+acpi_status acpi_ev_install_xrupt_handlers(void);
+
+u32 acpi_ev_fixed_event_detect(void);
+
+/*
+ * evmisc
+ */
+u8 acpi_ev_is_notify_object(struct acpi_namespace_node *node);
+
+u32 acpi_ev_get_gpe_number_index(u32 gpe_number);
+
+acpi_status
+acpi_ev_queue_notify_request(struct acpi_namespace_node *node,
+			     u32 notify_value);
+
+/*
+ * evglock - Global Lock support
+ */
+acpi_status acpi_ev_init_global_lock_handler(void);
+
+acpi_status acpi_ev_acquire_global_lock(u16 timeout);
+
+acpi_status acpi_ev_release_global_lock(void);
+
+acpi_status acpi_ev_remove_global_lock_handler(void);
+
+/*
+ * evgpe - Low-level GPE support
+ */
+u32 acpi_ev_gpe_detect(struct acpi_gpe_xrupt_info *gpe_xrupt_list);
+
+acpi_status
+acpi_ev_update_gpe_enable_mask(struct acpi_gpe_event_info *gpe_event_info);
+
+acpi_status acpi_ev_enable_gpe(struct acpi_gpe_event_info *gpe_event_info);
+
+acpi_status
+acpi_ev_add_gpe_reference(struct acpi_gpe_event_info *gpe_event_info);
+
+acpi_status
+acpi_ev_remove_gpe_reference(struct acpi_gpe_event_info *gpe_event_info);
+
+struct acpi_gpe_event_info *acpi_ev_get_gpe_event_info(acpi_handle gpe_device,
+						       u32 gpe_number);
+
+struct acpi_gpe_event_info *acpi_ev_low_get_gpe_info(u32 gpe_number,
+						     struct acpi_gpe_block_info
+						     *gpe_block);
+
+acpi_status acpi_ev_finish_gpe(struct acpi_gpe_event_info *gpe_event_info);
+
+/*
+ * evgpeblk - Upper-level GPE block support
+ */
+acpi_status
+acpi_ev_create_gpe_block(struct acpi_namespace_node *gpe_device,
+			 struct acpi_generic_address *gpe_block_address,
+			 u32 register_count,
+			 u8 gpe_block_base_number,
+			 u32 interrupt_number,
+			 struct acpi_gpe_block_info **return_gpe_block);
+
+acpi_status
+acpi_ev_initialize_gpe_block(struct acpi_gpe_xrupt_info *gpe_xrupt_info,
+			     struct acpi_gpe_block_info *gpe_block,
+			     void *context);
+
+acpi_status acpi_ev_delete_gpe_block(struct acpi_gpe_block_info *gpe_block);
+
+u32
+acpi_ev_gpe_dispatch(struct acpi_namespace_node *gpe_device,
+		     struct acpi_gpe_event_info *gpe_event_info,
+		     u32 gpe_number);
+
+/*
+ * evgpeinit - GPE initialization and update
+ */
+acpi_status acpi_ev_gpe_initialize(void);
+
+void acpi_ev_update_gpes(acpi_owner_id table_owner_id);
+
+acpi_status
+acpi_ev_match_gpe_method(acpi_handle obj_handle,
+			 u32 level, void *context, void **return_value);
+
+/*
+ * evgpeutil - GPE utilities
+ */
+acpi_status
+acpi_ev_walk_gpe_list(acpi_gpe_callback gpe_walk_callback, void *context);
+
+u8 acpi_ev_valid_gpe_event(struct acpi_gpe_event_info *gpe_event_info);
+
+acpi_status
+acpi_ev_get_gpe_device(struct acpi_gpe_xrupt_info *gpe_xrupt_info,
+		       struct acpi_gpe_block_info *gpe_block, void *context);
+
+struct acpi_gpe_xrupt_info *acpi_ev_get_gpe_xrupt_block(u32 interrupt_number);
+
+acpi_status acpi_ev_delete_gpe_xrupt(struct acpi_gpe_xrupt_info *gpe_xrupt);
+
+acpi_status
+acpi_ev_delete_gpe_handlers(struct acpi_gpe_xrupt_info *gpe_xrupt_info,
+			    struct acpi_gpe_block_info *gpe_block,
+			    void *context);
+
+/*
+ * evregion - Address Space handling
+ */
+acpi_status acpi_ev_install_region_handlers(void);
+
+acpi_status acpi_ev_initialize_op_regions(void);
+
+acpi_status
+acpi_ev_address_space_dispatch(union acpi_operand_object *region_obj,
+			       union acpi_operand_object *field_obj,
+			       u32 function,
+			       u32 region_offset, u32 bit_width, u64 *value);
+
+acpi_status
+acpi_ev_attach_region(union acpi_operand_object *handler_obj,
+		      union acpi_operand_object *region_obj,
+		      u8 acpi_ns_is_locked);
+
+void
+acpi_ev_detach_region(union acpi_operand_object *region_obj,
+		      u8 acpi_ns_is_locked);
+
+acpi_status
+acpi_ev_install_space_handler(struct acpi_namespace_node *node,
+			      acpi_adr_space_type space_id,
+			      acpi_adr_space_handler handler,
+			      acpi_adr_space_setup setup, void *context);
+
+acpi_status
+acpi_ev_execute_reg_methods(struct acpi_namespace_node *node,
+			    acpi_adr_space_type space_id);
+
+acpi_status
+acpi_ev_execute_reg_method(union acpi_operand_object *region_obj, u32 function);
+
+/*
+ * evregini - Region initialization and setup
+ */
+acpi_status
+acpi_ev_system_memory_region_setup(acpi_handle handle,
+				   u32 function,
+				   void *handler_context,
+				   void **region_context);
+
+acpi_status
+acpi_ev_io_space_region_setup(acpi_handle handle,
+			      u32 function,
+			      void *handler_context, void **region_context);
+
+acpi_status
+acpi_ev_pci_config_region_setup(acpi_handle handle,
+				u32 function,
+				void *handler_context, void **region_context);
+
+acpi_status
+acpi_ev_cmos_region_setup(acpi_handle handle,
+			  u32 function,
+			  void *handler_context, void **region_context);
+
+acpi_status
+acpi_ev_pci_bar_region_setup(acpi_handle handle,
+			     u32 function,
+			     void *handler_context, void **region_context);
+
+acpi_status
+acpi_ev_default_region_setup(acpi_handle handle,
+			     u32 function,
+			     void *handler_context, void **region_context);
+
+acpi_status
+acpi_ev_initialize_region(union acpi_operand_object *region_obj,
+			  u8 acpi_ns_locked);
+
+/*
+ * evsci - SCI (System Control Interrupt) handling/dispatch
+ */
+u32 ACPI_SYSTEM_XFACE acpi_ev_gpe_xrupt_handler(void *context);
+
+u32 acpi_ev_install_sci_handler(void);
+
+acpi_status acpi_ev_remove_sci_handler(void);
+
+u32 acpi_ev_initialize_sCI(u32 program_sCI);
+
+void acpi_ev_terminate(void);
+
+#endif				/* __ACEVENTS_H__  */
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acglobal.h b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acglobal.h
new file mode 100644
index 00000000..5e9068c4
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acglobal.h
@@ -0,0 +1,465 @@
+/******************************************************************************
+ *
+ * Name: acglobal.h - Declarations for global variables
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACGLOBAL_H__
+#define __ACGLOBAL_H__
+
+/*
+ * Ensure that the globals are actually defined and initialized only once.
+ *
+ * The use of these macros allows a single list of globals (here) in order
+ * to simplify maintenance of the code.
+ */
+#ifdef DEFINE_ACPI_GLOBALS
+#define ACPI_EXTERN
+#define ACPI_INIT_GLOBAL(a,b) a=b
+#else
+#define ACPI_EXTERN extern
+#define ACPI_INIT_GLOBAL(a,b) a
+#endif
+
+#ifdef DEFINE_ACPI_GLOBALS
+
+/* Public globals, available from outside ACPICA subsystem */
+
+/*****************************************************************************
+ *
+ * Runtime configuration (static defaults that can be overriden at runtime)
+ *
+ ****************************************************************************/
+
+/*
+ * Enable "slack" in the AML interpreter?  Default is FALSE, and the
+ * interpreter strictly follows the ACPI specification.  Setting to TRUE
+ * allows the interpreter to ignore certain errors and/or bad AML constructs.
+ *
+ * Currently, these features are enabled by this flag:
+ *
+ * 1) Allow "implicit return" of last value in a control method
+ * 2) Allow access beyond the end of an operation region
+ * 3) Allow access to uninitialized locals/args (auto-init to integer 0)
+ * 4) Allow ANY object type to be a source operand for the Store() operator
+ * 5) Allow unresolved references (invalid target name) in package objects
+ * 6) Enable warning messages for behavior that is not ACPI spec compliant
+ */
+u8 ACPI_INIT_GLOBAL(acpi_gbl_enable_interpreter_slack, FALSE);
+
+/*
+ * Automatically serialize ALL control methods? Default is FALSE, meaning
+ * to use the Serialized/not_serialized method flags on a per method basis.
+ * Only change this if the ASL code is poorly written and cannot handle
+ * reentrancy even though methods are marked "NotSerialized".
+ */
+u8 ACPI_INIT_GLOBAL(acpi_gbl_all_methods_serialized, FALSE);
+
+/*
+ * Create the predefined _OSI method in the namespace? Default is TRUE
+ * because ACPI CA is fully compatible with other ACPI implementations.
+ * Changing this will revert ACPI CA (and machine ASL) to pre-OSI behavior.
+ */
+u8 ACPI_INIT_GLOBAL(acpi_gbl_create_osi_method, TRUE);
+
+/*
+ * Optionally use default values for the ACPI register widths. Set this to
+ * TRUE to use the defaults, if an FADT contains incorrect widths/lengths.
+ */
+u8 ACPI_INIT_GLOBAL(acpi_gbl_use_default_register_widths, TRUE);
+
+/*
+ * Optionally enable output from the AML Debug Object.
+ */
+u8 ACPI_INIT_GLOBAL(acpi_gbl_enable_aml_debug_object, FALSE);
+
+/*
+ * Optionally copy the entire DSDT to local memory (instead of simply
+ * mapping it.) There are some BIOSs that corrupt or replace the original
+ * DSDT, creating the need for this option. Default is FALSE, do not copy
+ * the DSDT.
+ */
+u8 ACPI_INIT_GLOBAL(acpi_gbl_copy_dsdt_locally, FALSE);
+
+/*
+ * Optionally truncate I/O addresses to 16 bits. Provides compatibility
+ * with other ACPI implementations. NOTE: During ACPICA initialization,
+ * this value is set to TRUE if any Windows OSI strings have been
+ * requested by the BIOS.
+ */
+u8 ACPI_INIT_GLOBAL(acpi_gbl_truncate_io_addresses, FALSE);
+
+/*
+ * Disable runtime checking and repair of values returned by control methods.
+ * Use only if the repair is causing a problem on a particular machine.
+ */
+u8 ACPI_INIT_GLOBAL(acpi_gbl_disable_auto_repair, FALSE);
+
+/* acpi_gbl_FADT is a local copy of the FADT, converted to a common format. */
+
+struct acpi_table_fadt acpi_gbl_FADT;
+u32 acpi_current_gpe_count;
+u32 acpi_gbl_trace_flags;
+acpi_name acpi_gbl_trace_method_name;
+u8 acpi_gbl_system_awake_and_running;
+
+/*
+ * ACPI 5.0 introduces the concept of a "reduced hardware platform", meaning
+ * that the ACPI hardware is no longer required. A flag in the FADT indicates
+ * a reduced HW machine, and that flag is duplicated here for convenience.
+ */
+u8 acpi_gbl_reduced_hardware;
+
+#endif
+
+/* Do not disassemble buffers to resource descriptors */
+
+ACPI_EXTERN u8 ACPI_INIT_GLOBAL(acpi_gbl_no_resource_disassembly, FALSE);
+
+/*****************************************************************************
+ *
+ * ACPI Table globals
+ *
+ ****************************************************************************/
+
+/*
+ * acpi_gbl_root_table_list is the master list of ACPI tables that were
+ * found in the RSDT/XSDT.
+ */
+ACPI_EXTERN struct acpi_table_list acpi_gbl_root_table_list;
+ACPI_EXTERN struct acpi_table_facs *acpi_gbl_FACS;
+
+/* These addresses are calculated from the FADT Event Block addresses */
+
+ACPI_EXTERN struct acpi_generic_address acpi_gbl_xpm1a_status;
+ACPI_EXTERN struct acpi_generic_address acpi_gbl_xpm1a_enable;
+
+ACPI_EXTERN struct acpi_generic_address acpi_gbl_xpm1b_status;
+ACPI_EXTERN struct acpi_generic_address acpi_gbl_xpm1b_enable;
+
+/* DSDT information. Used to check for DSDT corruption */
+
+ACPI_EXTERN struct acpi_table_header *acpi_gbl_DSDT;
+ACPI_EXTERN struct acpi_table_header acpi_gbl_original_dsdt_header;
+
+/*
+ * Handle both ACPI 1.0 and ACPI 2.0 Integer widths. The integer width is
+ * determined by the revision of the DSDT: If the DSDT revision is less than
+ * 2, use only the lower 32 bits of the internal 64-bit Integer.
+ */
+ACPI_EXTERN u8 acpi_gbl_integer_bit_width;
+ACPI_EXTERN u8 acpi_gbl_integer_byte_width;
+ACPI_EXTERN u8 acpi_gbl_integer_nybble_width;
+
+/*****************************************************************************
+ *
+ * Mutual exclusion within ACPICA subsystem
+ *
+ ****************************************************************************/
+
+/*
+ * Predefined mutex objects. This array contains the
+ * actual OS mutex handles, indexed by the local ACPI_MUTEX_HANDLEs.
+ * (The table maps local handles to the real OS handles)
+ */
+ACPI_EXTERN struct acpi_mutex_info acpi_gbl_mutex_info[ACPI_NUM_MUTEX];
+
+/*
+ * Global lock mutex is an actual AML mutex object
+ * Global lock semaphore works in conjunction with the actual global lock
+ * Global lock spinlock is used for "pending" handshake
+ */
+ACPI_EXTERN union acpi_operand_object *acpi_gbl_global_lock_mutex;
+ACPI_EXTERN acpi_semaphore acpi_gbl_global_lock_semaphore;
+ACPI_EXTERN acpi_spinlock acpi_gbl_global_lock_pending_lock;
+ACPI_EXTERN u16 acpi_gbl_global_lock_handle;
+ACPI_EXTERN u8 acpi_gbl_global_lock_acquired;
+ACPI_EXTERN u8 acpi_gbl_global_lock_present;
+ACPI_EXTERN u8 acpi_gbl_global_lock_pending;
+
+/*
+ * Spinlocks are used for interfaces that can be possibly called at
+ * interrupt level
+ */
+ACPI_EXTERN acpi_spinlock acpi_gbl_gpe_lock;	/* For GPE data structs and registers */
+ACPI_EXTERN acpi_spinlock acpi_gbl_hardware_lock;	/* For ACPI H/W except GPE registers */
+
+/* Mutex for _OSI support */
+
+ACPI_EXTERN acpi_mutex acpi_gbl_osi_mutex;
+
+/* Reader/Writer lock is used for namespace walk and dynamic table unload */
+
+ACPI_EXTERN struct acpi_rw_lock acpi_gbl_namespace_rw_lock;
+
+/*****************************************************************************
+ *
+ * Miscellaneous globals
+ *
+ ****************************************************************************/
+
+/* Object caches */
+
+ACPI_EXTERN acpi_cache_t *acpi_gbl_namespace_cache;
+ACPI_EXTERN acpi_cache_t *acpi_gbl_state_cache;
+ACPI_EXTERN acpi_cache_t *acpi_gbl_ps_node_cache;
+ACPI_EXTERN acpi_cache_t *acpi_gbl_ps_node_ext_cache;
+ACPI_EXTERN acpi_cache_t *acpi_gbl_operand_cache;
+
+/* Global handlers */
+
+ACPI_EXTERN struct acpi_object_notify_handler acpi_gbl_device_notify;
+ACPI_EXTERN struct acpi_object_notify_handler acpi_gbl_system_notify;
+ACPI_EXTERN acpi_exception_handler acpi_gbl_exception_handler;
+ACPI_EXTERN acpi_init_handler acpi_gbl_init_handler;
+ACPI_EXTERN acpi_table_handler acpi_gbl_table_handler;
+ACPI_EXTERN void *acpi_gbl_table_handler_context;
+ACPI_EXTERN struct acpi_walk_state *acpi_gbl_breakpoint_walk;
+ACPI_EXTERN acpi_interface_handler acpi_gbl_interface_handler;
+
+/* Owner ID support */
+
+ACPI_EXTERN u32 acpi_gbl_owner_id_mask[ACPI_NUM_OWNERID_MASKS];
+ACPI_EXTERN u8 acpi_gbl_last_owner_id_index;
+ACPI_EXTERN u8 acpi_gbl_next_owner_id_offset;
+
+/* Initialization sequencing */
+
+ACPI_EXTERN u8 acpi_gbl_reg_methods_executed;
+
+/* Misc */
+
+ACPI_EXTERN u32 acpi_gbl_original_mode;
+ACPI_EXTERN u32 acpi_gbl_rsdp_original_location;
+ACPI_EXTERN u32 acpi_gbl_ns_lookup_count;
+ACPI_EXTERN u32 acpi_gbl_ps_find_count;
+ACPI_EXTERN u16 acpi_gbl_pm1_enable_register_save;
+ACPI_EXTERN u8 acpi_gbl_debugger_configuration;
+ACPI_EXTERN u8 acpi_gbl_step_to_next_call;
+ACPI_EXTERN u8 acpi_gbl_acpi_hardware_present;
+ACPI_EXTERN u8 acpi_gbl_events_initialized;
+ACPI_EXTERN u8 acpi_gbl_osi_data;
+ACPI_EXTERN struct acpi_interface_info *acpi_gbl_supported_interfaces;
+ACPI_EXTERN ACPI_ADDRESS_RANGE
+    *acpi_gbl_address_range_list[ACPI_ADDRESS_RANGE_MAX];
+
+#ifndef DEFINE_ACPI_GLOBALS
+
+/* Exception codes */
+
+extern char const *acpi_gbl_exception_names_env[];
+extern char const *acpi_gbl_exception_names_pgm[];
+extern char const *acpi_gbl_exception_names_tbl[];
+extern char const *acpi_gbl_exception_names_aml[];
+extern char const *acpi_gbl_exception_names_ctrl[];
+
+/* Other miscellaneous */
+
+extern u8 acpi_gbl_shutdown;
+extern u32 acpi_gbl_startup_flags;
+extern const char *acpi_gbl_sleep_state_names[ACPI_S_STATE_COUNT];
+extern const char *acpi_gbl_lowest_dstate_names[ACPI_NUM_sx_w_METHODS];
+extern const char *acpi_gbl_highest_dstate_names[ACPI_NUM_sx_d_METHODS];
+extern const struct acpi_opcode_info acpi_gbl_aml_op_info[AML_NUM_OPCODES];
+extern const char *acpi_gbl_region_types[ACPI_NUM_PREDEFINED_REGIONS];
+#endif
+
+#ifdef ACPI_DBG_TRACK_ALLOCATIONS
+
+/* Lists for tracking memory allocations */
+
+ACPI_EXTERN struct acpi_memory_list *acpi_gbl_global_list;
+ACPI_EXTERN struct acpi_memory_list *acpi_gbl_ns_node_list;
+ACPI_EXTERN u8 acpi_gbl_display_final_mem_stats;
+ACPI_EXTERN u8 acpi_gbl_disable_mem_tracking;
+#endif
+
+/*****************************************************************************
+ *
+ * Namespace globals
+ *
+ ****************************************************************************/
+
+#if !defined (ACPI_NO_METHOD_EXECUTION) || defined (ACPI_CONSTANT_EVAL_ONLY)
+#define NUM_PREDEFINED_NAMES            10
+#else
+#define NUM_PREDEFINED_NAMES            9
+#endif
+
+ACPI_EXTERN struct acpi_namespace_node acpi_gbl_root_node_struct;
+ACPI_EXTERN struct acpi_namespace_node *acpi_gbl_root_node;
+ACPI_EXTERN struct acpi_namespace_node *acpi_gbl_fadt_gpe_device;
+ACPI_EXTERN union acpi_operand_object *acpi_gbl_module_code_list;
+
+extern const u8 acpi_gbl_ns_properties[ACPI_NUM_NS_TYPES];
+extern const struct acpi_predefined_names
+    acpi_gbl_pre_defined_names[NUM_PREDEFINED_NAMES];
+
+#ifdef ACPI_DEBUG_OUTPUT
+ACPI_EXTERN u32 acpi_gbl_current_node_count;
+ACPI_EXTERN u32 acpi_gbl_current_node_size;
+ACPI_EXTERN u32 acpi_gbl_max_concurrent_node_count;
+ACPI_EXTERN acpi_size *acpi_gbl_entry_stack_pointer;
+ACPI_EXTERN acpi_size *acpi_gbl_lowest_stack_pointer;
+ACPI_EXTERN u32 acpi_gbl_deepest_nesting;
+#endif
+
+/*****************************************************************************
+ *
+ * Interpreter globals
+ *
+ ****************************************************************************/
+
+ACPI_EXTERN struct acpi_thread_state *acpi_gbl_current_walk_list;
+
+/* Control method single step flag */
+
+ACPI_EXTERN u8 acpi_gbl_cm_single_step;
+
+/*****************************************************************************
+ *
+ * Hardware globals
+ *
+ ****************************************************************************/
+
+extern struct acpi_bit_register_info
+    acpi_gbl_bit_register_info[ACPI_NUM_BITREG];
+ACPI_EXTERN u8 acpi_gbl_sleep_type_a;
+ACPI_EXTERN u8 acpi_gbl_sleep_type_b;
+
+/*****************************************************************************
+ *
+ * Event and GPE globals
+ *
+ ****************************************************************************/
+
+ACPI_EXTERN u8 acpi_gbl_all_gpes_initialized;
+ACPI_EXTERN struct acpi_gpe_xrupt_info *acpi_gbl_gpe_xrupt_list_head;
+ACPI_EXTERN struct acpi_gpe_block_info
+    *acpi_gbl_gpe_fadt_blocks[ACPI_MAX_GPE_BLOCKS];
+ACPI_EXTERN acpi_gbl_event_handler acpi_gbl_global_event_handler;
+ACPI_EXTERN void *acpi_gbl_global_event_handler_context;
+ACPI_EXTERN struct acpi_fixed_event_handler
+    acpi_gbl_fixed_event_handlers[ACPI_NUM_FIXED_EVENTS];
+extern struct acpi_fixed_event_info
+    acpi_gbl_fixed_event_info[ACPI_NUM_FIXED_EVENTS];
+
+/*****************************************************************************
+ *
+ * Debug support
+ *
+ ****************************************************************************/
+
+/* Procedure nesting level for debug output */
+
+extern u32 acpi_gbl_nesting_level;
+
+/* Event counters */
+
+ACPI_EXTERN u32 acpi_method_count;
+ACPI_EXTERN u32 acpi_gpe_count;
+ACPI_EXTERN u32 acpi_sci_count;
+ACPI_EXTERN u32 acpi_fixed_event_count[ACPI_NUM_FIXED_EVENTS];
+
+/* Support for dynamic control method tracing mechanism */
+
+ACPI_EXTERN u32 acpi_gbl_original_dbg_level;
+ACPI_EXTERN u32 acpi_gbl_original_dbg_layer;
+ACPI_EXTERN u32 acpi_gbl_trace_dbg_level;
+ACPI_EXTERN u32 acpi_gbl_trace_dbg_layer;
+
+/*****************************************************************************
+ *
+ * Debugger globals
+ *
+ ****************************************************************************/
+
+ACPI_EXTERN u8 acpi_gbl_db_output_flags;
+
+#ifdef ACPI_DISASSEMBLER
+
+ACPI_EXTERN u8 acpi_gbl_db_opt_disasm;
+ACPI_EXTERN u8 acpi_gbl_db_opt_verbose;
+ACPI_EXTERN struct acpi_external_list *acpi_gbl_external_list;
+ACPI_EXTERN struct acpi_external_file *acpi_gbl_external_file_list;
+#endif
+
+#ifdef ACPI_DEBUGGER
+
+extern u8 acpi_gbl_method_executing;
+extern u8 acpi_gbl_abort_method;
+extern u8 acpi_gbl_db_terminate_threads;
+
+ACPI_EXTERN u8 acpi_gbl_db_opt_tables;
+ACPI_EXTERN u8 acpi_gbl_db_opt_stats;
+ACPI_EXTERN u8 acpi_gbl_db_opt_ini_methods;
+ACPI_EXTERN u8 acpi_gbl_db_opt_no_region_support;
+
+ACPI_EXTERN char *acpi_gbl_db_args[ACPI_DEBUGGER_MAX_ARGS];
+ACPI_EXTERN acpi_object_type acpi_gbl_db_arg_types[ACPI_DEBUGGER_MAX_ARGS];
+ACPI_EXTERN char acpi_gbl_db_line_buf[ACPI_DB_LINE_BUFFER_SIZE];
+ACPI_EXTERN char acpi_gbl_db_parsed_buf[ACPI_DB_LINE_BUFFER_SIZE];
+ACPI_EXTERN char acpi_gbl_db_scope_buf[80];
+ACPI_EXTERN char acpi_gbl_db_debug_filename[80];
+ACPI_EXTERN u8 acpi_gbl_db_output_to_file;
+ACPI_EXTERN char *acpi_gbl_db_buffer;
+ACPI_EXTERN char *acpi_gbl_db_filename;
+ACPI_EXTERN u32 acpi_gbl_db_debug_level;
+ACPI_EXTERN u32 acpi_gbl_db_console_debug_level;
+ACPI_EXTERN struct acpi_namespace_node *acpi_gbl_db_scope_node;
+
+/*
+ * Statistic globals
+ */
+ACPI_EXTERN u16 acpi_gbl_obj_type_count[ACPI_TYPE_NS_NODE_MAX + 1];
+ACPI_EXTERN u16 acpi_gbl_node_type_count[ACPI_TYPE_NS_NODE_MAX + 1];
+ACPI_EXTERN u16 acpi_gbl_obj_type_count_misc;
+ACPI_EXTERN u16 acpi_gbl_node_type_count_misc;
+ACPI_EXTERN u32 acpi_gbl_num_nodes;
+ACPI_EXTERN u32 acpi_gbl_num_objects;
+
+ACPI_EXTERN u32 acpi_gbl_size_of_parse_tree;
+ACPI_EXTERN u32 acpi_gbl_size_of_method_trees;
+ACPI_EXTERN u32 acpi_gbl_size_of_node_entries;
+ACPI_EXTERN u32 acpi_gbl_size_of_acpi_objects;
+
+#endif				/* ACPI_DEBUGGER */
+
+#endif				/* __ACGLOBAL_H__ */
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/achware.h b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/achware.h
new file mode 100644
index 00000000..0a19d645
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/achware.h
@@ -0,0 +1,142 @@
+/******************************************************************************
+ *
+ * Name: achware.h -- hardware specific interfaces
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACHWARE_H__
+#define __ACHWARE_H__
+
+/* Values for the _SST predefined method */
+
+#define ACPI_SST_INDICATOR_OFF  0
+#define ACPI_SST_WORKING        1
+#define ACPI_SST_WAKING         2
+#define ACPI_SST_SLEEPING       3
+#define ACPI_SST_SLEEP_CONTEXT  4
+
+/*
+ * hwacpi - high level functions
+ */
+acpi_status acpi_hw_set_mode(u32 mode);
+
+u32 acpi_hw_get_mode(void);
+
+/*
+ * hwregs - ACPI Register I/O
+ */
+acpi_status
+acpi_hw_validate_register(struct acpi_generic_address *reg,
+			  u8 max_bit_width, u64 *address);
+
+acpi_status acpi_hw_read(u32 *value, struct acpi_generic_address *reg);
+
+acpi_status acpi_hw_write(u32 value, struct acpi_generic_address *reg);
+
+struct acpi_bit_register_info *acpi_hw_get_bit_register_info(u32 register_id);
+
+acpi_status acpi_hw_write_pm1_control(u32 pm1a_control, u32 pm1b_control);
+
+acpi_status acpi_hw_register_read(u32 register_id, u32 *return_value);
+
+acpi_status acpi_hw_register_write(u32 register_id, u32 value);
+
+acpi_status acpi_hw_clear_acpi_status(void);
+
+/*
+ * hwvalid - Port I/O with validation
+ */
+acpi_status acpi_hw_read_port(acpi_io_address address, u32 *value, u32 width);
+
+acpi_status acpi_hw_write_port(acpi_io_address address, u32 value, u32 width);
+
+/*
+ * hwgpe - GPE support
+ */
+u32
+acpi_hw_get_gpe_register_bit(struct acpi_gpe_event_info *gpe_event_info,
+			     struct acpi_gpe_register_info *gpe_register_info);
+
+acpi_status
+acpi_hw_low_set_gpe(struct acpi_gpe_event_info *gpe_event_info, u32 action);
+
+acpi_status
+acpi_hw_disable_gpe_block(struct acpi_gpe_xrupt_info *gpe_xrupt_info,
+			  struct acpi_gpe_block_info *gpe_block, void *context);
+
+acpi_status acpi_hw_clear_gpe(struct acpi_gpe_event_info *gpe_event_info);
+
+acpi_status
+acpi_hw_clear_gpe_block(struct acpi_gpe_xrupt_info *gpe_xrupt_info,
+			struct acpi_gpe_block_info *gpe_block, void *context);
+
+acpi_status
+acpi_hw_get_gpe_status(struct acpi_gpe_event_info *gpe_event_info,
+		       acpi_event_status *event_status);
+
+acpi_status acpi_hw_disable_all_gpes(void);
+
+acpi_status acpi_hw_enable_all_runtime_gpes(void);
+
+acpi_status acpi_hw_enable_all_wakeup_gpes(void);
+
+acpi_status
+acpi_hw_enable_runtime_gpe_block(struct acpi_gpe_xrupt_info *gpe_xrupt_info,
+				 struct acpi_gpe_block_info *gpe_block,
+				 void *context);
+
+/*
+ * hwpci - PCI configuration support
+ */
+acpi_status
+acpi_hw_derive_pci_id(struct acpi_pci_id *pci_id,
+		      acpi_handle root_pci_device, acpi_handle pci_region);
+
+/*
+ * hwtimer - ACPI Timer prototypes
+ */
+acpi_status acpi_get_timer_resolution(u32 *resolution);
+
+acpi_status acpi_get_timer(u32 *ticks);
+
+acpi_status
+acpi_get_timer_duration(u32 start_ticks, u32 end_ticks, u32 *time_elapsed);
+
+#endif				/* __ACHWARE_H__ */
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acinterp.h b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acinterp.h
new file mode 100644
index 00000000..f73ad03c
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acinterp.h
@@ -0,0 +1,532 @@
+/******************************************************************************
+ *
+ * Name: acinterp.h - Interpreter subcomponent prototypes and defines
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACINTERP_H__
+#define __ACINTERP_H__
+
+#define ACPI_WALK_OPERANDS          (&(walk_state->operands [walk_state->num_operands -1]))
+
+/* Macros for tables used for debug output */
+
+#define ACPI_EXD_OFFSET(f)          (u8) ACPI_OFFSET (union acpi_operand_object,f)
+#define ACPI_EXD_NSOFFSET(f)        (u8) ACPI_OFFSET (struct acpi_namespace_node,f)
+#define ACPI_EXD_TABLE_SIZE(name)   (sizeof(name) / sizeof (struct acpi_exdump_info))
+
+/*
+ * If possible, pack the following structures to byte alignment, since we
+ * don't care about performance for debug output. Two cases where we cannot
+ * pack the structures:
+ *
+ * 1) Hardware does not support misaligned memory transfers
+ * 2) Compiler does not support pointers within packed structures
+ */
+#if (!defined(ACPI_MISALIGNMENT_NOT_SUPPORTED) && !defined(ACPI_PACKED_POINTERS_NOT_SUPPORTED))
+#pragma pack(1)
+#endif
+
+typedef const struct acpi_exdump_info {
+	u8 opcode;
+	u8 offset;
+	char *name;
+
+} acpi_exdump_info;
+
+/* Values for the Opcode field above */
+
+#define ACPI_EXD_INIT                   0
+#define ACPI_EXD_TYPE                   1
+#define ACPI_EXD_UINT8                  2
+#define ACPI_EXD_UINT16                 3
+#define ACPI_EXD_UINT32                 4
+#define ACPI_EXD_UINT64                 5
+#define ACPI_EXD_LITERAL                6
+#define ACPI_EXD_POINTER                7
+#define ACPI_EXD_ADDRESS                8
+#define ACPI_EXD_STRING                 9
+#define ACPI_EXD_BUFFER                 10
+#define ACPI_EXD_PACKAGE                11
+#define ACPI_EXD_FIELD                  12
+#define ACPI_EXD_REFERENCE              13
+
+/* restore default alignment */
+
+#pragma pack()
+
+/*
+ * exconvrt - object conversion
+ */
+acpi_status
+acpi_ex_convert_to_integer(union acpi_operand_object *obj_desc,
+			   union acpi_operand_object **result_desc, u32 flags);
+
+acpi_status
+acpi_ex_convert_to_buffer(union acpi_operand_object *obj_desc,
+			  union acpi_operand_object **result_desc);
+
+acpi_status
+acpi_ex_convert_to_string(union acpi_operand_object *obj_desc,
+			  union acpi_operand_object **result_desc, u32 type);
+
+/* Types for ->String conversion */
+
+#define ACPI_EXPLICIT_BYTE_COPY         0x00000000
+#define ACPI_EXPLICIT_CONVERT_HEX       0x00000001
+#define ACPI_IMPLICIT_CONVERT_HEX       0x00000002
+#define ACPI_EXPLICIT_CONVERT_DECIMAL   0x00000003
+
+acpi_status
+acpi_ex_convert_to_target_type(acpi_object_type destination_type,
+			       union acpi_operand_object *source_desc,
+			       union acpi_operand_object **result_desc,
+			       struct acpi_walk_state *walk_state);
+
+/*
+ * exdebug - AML debug object
+ */
+void
+acpi_ex_do_debug_object(union acpi_operand_object *source_desc,
+			u32 level, u32 index);
+
+/*
+ * exfield - ACPI AML (p-code) execution - field manipulation
+ */
+acpi_status
+acpi_ex_common_buffer_setup(union acpi_operand_object *obj_desc,
+			    u32 buffer_length, u32 *datum_count);
+
+acpi_status
+acpi_ex_write_with_update_rule(union acpi_operand_object *obj_desc,
+			       u64 mask,
+			       u64 field_value, u32 field_datum_byte_offset);
+
+void
+acpi_ex_get_buffer_datum(u64 *datum,
+			 void *buffer,
+			 u32 buffer_length,
+			 u32 byte_granularity, u32 buffer_offset);
+
+void
+acpi_ex_set_buffer_datum(u64 merged_datum,
+			 void *buffer,
+			 u32 buffer_length,
+			 u32 byte_granularity, u32 buffer_offset);
+
+acpi_status
+acpi_ex_read_data_from_field(struct acpi_walk_state *walk_state,
+			     union acpi_operand_object *obj_desc,
+			     union acpi_operand_object **ret_buffer_desc);
+
+acpi_status
+acpi_ex_write_data_to_field(union acpi_operand_object *source_desc,
+			    union acpi_operand_object *obj_desc,
+			    union acpi_operand_object **result_desc);
+
+/*
+ * exfldio - low level field I/O
+ */
+acpi_status
+acpi_ex_extract_from_field(union acpi_operand_object *obj_desc,
+			   void *buffer, u32 buffer_length);
+
+acpi_status
+acpi_ex_insert_into_field(union acpi_operand_object *obj_desc,
+			  void *buffer, u32 buffer_length);
+
+acpi_status
+acpi_ex_access_region(union acpi_operand_object *obj_desc,
+		      u32 field_datum_byte_offset, u64 *value, u32 read_write);
+
+/*
+ * exmisc - misc support routines
+ */
+acpi_status
+acpi_ex_get_object_reference(union acpi_operand_object *obj_desc,
+			     union acpi_operand_object **return_desc,
+			     struct acpi_walk_state *walk_state);
+
+acpi_status
+acpi_ex_concat_template(union acpi_operand_object *obj_desc,
+			union acpi_operand_object *obj_desc2,
+			union acpi_operand_object **actual_return_desc,
+			struct acpi_walk_state *walk_state);
+
+acpi_status
+acpi_ex_do_concatenate(union acpi_operand_object *obj_desc,
+		       union acpi_operand_object *obj_desc2,
+		       union acpi_operand_object **actual_return_desc,
+		       struct acpi_walk_state *walk_state);
+
+acpi_status
+acpi_ex_do_logical_numeric_op(u16 opcode,
+			      u64 integer0, u64 integer1, u8 *logical_result);
+
+acpi_status
+acpi_ex_do_logical_op(u16 opcode,
+		      union acpi_operand_object *operand0,
+		      union acpi_operand_object *operand1, u8 *logical_result);
+
+u64 acpi_ex_do_math_op(u16 opcode, u64 operand0, u64 operand1);
+
+acpi_status acpi_ex_create_mutex(struct acpi_walk_state *walk_state);
+
+acpi_status acpi_ex_create_processor(struct acpi_walk_state *walk_state);
+
+acpi_status acpi_ex_create_power_resource(struct acpi_walk_state *walk_state);
+
+acpi_status
+acpi_ex_create_region(u8 *aml_start,
+		      u32 aml_length,
+		      u8 region_space, struct acpi_walk_state *walk_state);
+
+acpi_status acpi_ex_create_event(struct acpi_walk_state *walk_state);
+
+acpi_status acpi_ex_create_alias(struct acpi_walk_state *walk_state);
+
+acpi_status
+acpi_ex_create_method(u8 *aml_start,
+		      u32 aml_length, struct acpi_walk_state *walk_state);
+
+/*
+ * exconfig - dynamic table load/unload
+ */
+acpi_status
+acpi_ex_load_op(union acpi_operand_object *obj_desc,
+		union acpi_operand_object *target,
+		struct acpi_walk_state *walk_state);
+
+acpi_status
+acpi_ex_load_table_op(struct acpi_walk_state *walk_state,
+		      union acpi_operand_object **return_desc);
+
+acpi_status acpi_ex_unload_table(union acpi_operand_object *ddb_handle);
+
+/*
+ * exmutex - mutex support
+ */
+acpi_status
+acpi_ex_acquire_mutex(union acpi_operand_object *time_desc,
+		      union acpi_operand_object *obj_desc,
+		      struct acpi_walk_state *walk_state);
+
+acpi_status
+acpi_ex_acquire_mutex_object(u16 timeout,
+			     union acpi_operand_object *obj_desc,
+			     acpi_thread_id thread_id);
+
+acpi_status
+acpi_ex_release_mutex(union acpi_operand_object *obj_desc,
+		      struct acpi_walk_state *walk_state);
+
+acpi_status acpi_ex_release_mutex_object(union acpi_operand_object *obj_desc);
+
+void acpi_ex_release_all_mutexes(struct acpi_thread_state *thread);
+
+void acpi_ex_unlink_mutex(union acpi_operand_object *obj_desc);
+
+/*
+ * exprep - ACPI AML execution - prep utilities
+ */
+acpi_status
+acpi_ex_prep_common_field_object(union acpi_operand_object *obj_desc,
+				 u8 field_flags,
+				 u8 field_attribute,
+				 u32 field_bit_position, u32 field_bit_length);
+
+acpi_status acpi_ex_prep_field_value(struct acpi_create_field_info *info);
+
+/*
+ * exsystem - Interface to OS services
+ */
+acpi_status
+acpi_ex_system_do_notify_op(union acpi_operand_object *value,
+			    union acpi_operand_object *obj_desc);
+
+acpi_status acpi_ex_system_do_sleep(u64 time);
+
+acpi_status acpi_ex_system_do_stall(u32 time);
+
+acpi_status acpi_ex_system_signal_event(union acpi_operand_object *obj_desc);
+
+acpi_status
+acpi_ex_system_wait_event(union acpi_operand_object *time,
+			  union acpi_operand_object *obj_desc);
+
+acpi_status acpi_ex_system_reset_event(union acpi_operand_object *obj_desc);
+
+acpi_status
+acpi_ex_system_wait_semaphore(acpi_semaphore semaphore, u16 timeout);
+
+acpi_status acpi_ex_system_wait_mutex(acpi_mutex mutex, u16 timeout);
+
+/*
+ * exoparg1 - ACPI AML execution, 1 operand
+ */
+acpi_status acpi_ex_opcode_0A_0T_1R(struct acpi_walk_state *walk_state);
+
+acpi_status acpi_ex_opcode_1A_0T_0R(struct acpi_walk_state *walk_state);
+
+acpi_status acpi_ex_opcode_1A_0T_1R(struct acpi_walk_state *walk_state);
+
+acpi_status acpi_ex_opcode_1A_1T_1R(struct acpi_walk_state *walk_state);
+
+acpi_status acpi_ex_opcode_1A_1T_0R(struct acpi_walk_state *walk_state);
+
+/*
+ * exoparg2 - ACPI AML execution, 2 operands
+ */
+acpi_status acpi_ex_opcode_2A_0T_0R(struct acpi_walk_state *walk_state);
+
+acpi_status acpi_ex_opcode_2A_0T_1R(struct acpi_walk_state *walk_state);
+
+acpi_status acpi_ex_opcode_2A_1T_1R(struct acpi_walk_state *walk_state);
+
+acpi_status acpi_ex_opcode_2A_2T_1R(struct acpi_walk_state *walk_state);
+
+/*
+ * exoparg3 - ACPI AML execution, 3 operands
+ */
+acpi_status acpi_ex_opcode_3A_0T_0R(struct acpi_walk_state *walk_state);
+
+acpi_status acpi_ex_opcode_3A_1T_1R(struct acpi_walk_state *walk_state);
+
+/*
+ * exoparg6 - ACPI AML execution, 6 operands
+ */
+acpi_status acpi_ex_opcode_6A_0T_1R(struct acpi_walk_state *walk_state);
+
+/*
+ * exresolv - Object resolution and get value functions
+ */
+acpi_status
+acpi_ex_resolve_to_value(union acpi_operand_object **stack_ptr,
+			 struct acpi_walk_state *walk_state);
+
+acpi_status
+acpi_ex_resolve_multiple(struct acpi_walk_state *walk_state,
+			 union acpi_operand_object *operand,
+			 acpi_object_type * return_type,
+			 union acpi_operand_object **return_desc);
+
+/*
+ * exresnte - resolve namespace node
+ */
+acpi_status
+acpi_ex_resolve_node_to_value(struct acpi_namespace_node **stack_ptr,
+			      struct acpi_walk_state *walk_state);
+
+/*
+ * exresop - resolve operand to value
+ */
+acpi_status
+acpi_ex_resolve_operands(u16 opcode,
+			 union acpi_operand_object **stack_ptr,
+			 struct acpi_walk_state *walk_state);
+
+/*
+ * exdump - Interpreter debug output routines
+ */
+void acpi_ex_dump_operand(union acpi_operand_object *obj_desc, u32 depth);
+
+void
+acpi_ex_dump_operands(union acpi_operand_object **operands,
+		      const char *opcode_name, u32 num_opcodes);
+
+void
+acpi_ex_dump_object_descriptor(union acpi_operand_object *object, u32 flags);
+
+void acpi_ex_dump_namespace_node(struct acpi_namespace_node *node, u32 flags);
+
+/*
+ * exnames - AML namestring support
+ */
+acpi_status
+acpi_ex_get_name_string(acpi_object_type data_type,
+			u8 *in_aml_address,
+			char **out_name_string, u32 *out_name_length);
+
+/*
+ * exstore - Object store support
+ */
+acpi_status
+acpi_ex_store(union acpi_operand_object *val_desc,
+	      union acpi_operand_object *dest_desc,
+	      struct acpi_walk_state *walk_state);
+
+acpi_status
+acpi_ex_store_object_to_node(union acpi_operand_object *source_desc,
+			     struct acpi_namespace_node *node,
+			     struct acpi_walk_state *walk_state,
+			     u8 implicit_conversion);
+
+#define ACPI_IMPLICIT_CONVERSION        TRUE
+#define ACPI_NO_IMPLICIT_CONVERSION     FALSE
+
+/*
+ * exstoren - resolve/store object
+ */
+acpi_status
+acpi_ex_resolve_object(union acpi_operand_object **source_desc_ptr,
+		       acpi_object_type target_type,
+		       struct acpi_walk_state *walk_state);
+
+acpi_status
+acpi_ex_store_object_to_object(union acpi_operand_object *source_desc,
+			       union acpi_operand_object *dest_desc,
+			       union acpi_operand_object **new_desc,
+			       struct acpi_walk_state *walk_state);
+
+/*
+ * exstorob - store object - buffer/string
+ */
+acpi_status
+acpi_ex_store_buffer_to_buffer(union acpi_operand_object *source_desc,
+			       union acpi_operand_object *target_desc);
+
+acpi_status
+acpi_ex_store_string_to_string(union acpi_operand_object *source_desc,
+			       union acpi_operand_object *target_desc);
+
+/*
+ * excopy - object copy
+ */
+acpi_status
+acpi_ex_copy_integer_to_index_field(union acpi_operand_object *source_desc,
+				    union acpi_operand_object *target_desc);
+
+acpi_status
+acpi_ex_copy_integer_to_bank_field(union acpi_operand_object *source_desc,
+				   union acpi_operand_object *target_desc);
+
+acpi_status
+acpi_ex_copy_data_to_named_field(union acpi_operand_object *source_desc,
+				 struct acpi_namespace_node *node);
+
+acpi_status
+acpi_ex_copy_integer_to_buffer_field(union acpi_operand_object *source_desc,
+				     union acpi_operand_object *target_desc);
+
+/*
+ * exutils - interpreter/scanner utilities
+ */
+void acpi_ex_enter_interpreter(void);
+
+void acpi_ex_exit_interpreter(void);
+
+void acpi_ex_reacquire_interpreter(void);
+
+void acpi_ex_relinquish_interpreter(void);
+
+void acpi_ex_truncate_for32bit_table(union acpi_operand_object *obj_desc);
+
+void acpi_ex_acquire_global_lock(u32 rule);
+
+void acpi_ex_release_global_lock(u32 rule);
+
+void acpi_ex_eisa_id_to_string(char *dest, u64 compressed_id);
+
+void acpi_ex_integer_to_string(char *dest, u64 value);
+
+u8 acpi_is_valid_space_id(u8 space_id);
+
+/*
+ * exregion - default op_region handlers
+ */
+acpi_status
+acpi_ex_system_memory_space_handler(u32 function,
+				    acpi_physical_address address,
+				    u32 bit_width,
+				    u64 *value,
+				    void *handler_context,
+				    void *region_context);
+
+acpi_status
+acpi_ex_system_io_space_handler(u32 function,
+				acpi_physical_address address,
+				u32 bit_width,
+				u64 *value,
+				void *handler_context, void *region_context);
+
+acpi_status
+acpi_ex_pci_config_space_handler(u32 function,
+				 acpi_physical_address address,
+				 u32 bit_width,
+				 u64 *value,
+				 void *handler_context, void *region_context);
+
+acpi_status
+acpi_ex_cmos_space_handler(u32 function,
+			   acpi_physical_address address,
+			   u32 bit_width,
+			   u64 *value,
+			   void *handler_context, void *region_context);
+
+acpi_status
+acpi_ex_pci_bar_space_handler(u32 function,
+			      acpi_physical_address address,
+			      u32 bit_width,
+			      u64 *value,
+			      void *handler_context, void *region_context);
+
+acpi_status
+acpi_ex_embedded_controller_space_handler(u32 function,
+					  acpi_physical_address address,
+					  u32 bit_width,
+					  u64 *value,
+					  void *handler_context,
+					  void *region_context);
+
+acpi_status
+acpi_ex_sm_bus_space_handler(u32 function,
+			     acpi_physical_address address,
+			     u32 bit_width,
+			     u64 *value,
+			     void *handler_context, void *region_context);
+
+acpi_status
+acpi_ex_data_table_space_handler(u32 function,
+				 acpi_physical_address address,
+				 u32 bit_width,
+				 u64 *value,
+				 void *handler_context, void *region_context);
+
+#endif				/* __INTERP_H__ */
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/aclocal.h b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/aclocal.h
new file mode 100644
index 00000000..bc52ba96
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/aclocal.h
@@ -0,0 +1,1115 @@
+/******************************************************************************
+ *
+ * Name: aclocal.h - Internal data types used across the ACPI subsystem
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACLOCAL_H__
+#define __ACLOCAL_H__
+
+/* acpisrc:struct_defs -- for acpisrc conversion */
+
+#define ACPI_SERIALIZED                 0xFF
+
+typedef u32 acpi_mutex_handle;
+#define ACPI_GLOBAL_LOCK                (acpi_semaphore) (-1)
+
+/* Total number of aml opcodes defined */
+
+#define AML_NUM_OPCODES                 0x81
+
+/* Forward declarations */
+
+struct acpi_walk_state;
+struct acpi_obj_mutex;
+union acpi_parse_object;
+
+/*****************************************************************************
+ *
+ * Mutex typedefs and structs
+ *
+ ****************************************************************************/
+
+/*
+ * Predefined handles for the mutex objects used within the subsystem
+ * All mutex objects are automatically created by acpi_ut_mutex_initialize.
+ *
+ * The acquire/release ordering protocol is implied via this list. Mutexes
+ * with a lower value must be acquired before mutexes with a higher value.
+ *
+ * NOTE: any changes here must be reflected in the acpi_gbl_mutex_names
+ * table below also!
+ */
+#define ACPI_MTX_INTERPRETER            0	/* AML Interpreter, main lock */
+#define ACPI_MTX_NAMESPACE              1	/* ACPI Namespace */
+#define ACPI_MTX_TABLES                 2	/* Data for ACPI tables */
+#define ACPI_MTX_EVENTS                 3	/* Data for ACPI events */
+#define ACPI_MTX_CACHES                 4	/* Internal caches, general purposes */
+#define ACPI_MTX_MEMORY                 5	/* Debug memory tracking lists */
+#define ACPI_MTX_DEBUG_CMD_COMPLETE     6	/* AML debugger */
+#define ACPI_MTX_DEBUG_CMD_READY        7	/* AML debugger */
+
+#define ACPI_MAX_MUTEX                  7
+#define ACPI_NUM_MUTEX                  ACPI_MAX_MUTEX+1
+
+/* Lock structure for reader/writer interfaces */
+
+struct acpi_rw_lock {
+	acpi_mutex writer_mutex;
+	acpi_mutex reader_mutex;
+	u32 num_readers;
+};
+
+/*
+ * Predefined handles for spinlocks used within the subsystem.
+ * These spinlocks are created by acpi_ut_mutex_initialize
+ */
+#define ACPI_LOCK_GPES                  0
+#define ACPI_LOCK_HARDWARE              1
+
+#define ACPI_MAX_LOCK                   1
+#define ACPI_NUM_LOCK                   ACPI_MAX_LOCK+1
+
+/* This Thread ID means that the mutex is not in use (unlocked) */
+
+#define ACPI_MUTEX_NOT_ACQUIRED         (acpi_thread_id) -1
+
+/* Table for the global mutexes */
+
+struct acpi_mutex_info {
+	acpi_mutex mutex;
+	u32 use_count;
+	acpi_thread_id thread_id;
+};
+
+/* Lock flag parameter for various interfaces */
+
+#define ACPI_MTX_DO_NOT_LOCK            0
+#define ACPI_MTX_LOCK                   1
+
+/* Field access granularities */
+
+#define ACPI_FIELD_BYTE_GRANULARITY     1
+#define ACPI_FIELD_WORD_GRANULARITY     2
+#define ACPI_FIELD_DWORD_GRANULARITY    4
+#define ACPI_FIELD_QWORD_GRANULARITY    8
+
+#define ACPI_ENTRY_NOT_FOUND            NULL
+
+/*****************************************************************************
+ *
+ * Namespace typedefs and structs
+ *
+ ****************************************************************************/
+
+/* Operational modes of the AML interpreter/scanner */
+
+typedef enum {
+	ACPI_IMODE_LOAD_PASS1 = 0x01,
+	ACPI_IMODE_LOAD_PASS2 = 0x02,
+	ACPI_IMODE_EXECUTE = 0x03
+} acpi_interpreter_mode;
+
+/*
+ * The Namespace Node describes a named object that appears in the AML.
+ * descriptor_type is used to differentiate between internal descriptors.
+ *
+ * The node is optimized for both 32-bit and 64-bit platforms:
+ * 20 bytes for the 32-bit case, 32 bytes for the 64-bit case.
+ *
+ * Note: The descriptor_type and Type fields must appear in the identical
+ * position in both the struct acpi_namespace_node and union acpi_operand_object
+ * structures.
+ */
+struct acpi_namespace_node {
+	union acpi_operand_object *object;	/* Interpreter object */
+	u8 descriptor_type;	/* Differentiate object descriptor types */
+	u8 type;		/* ACPI Type associated with this name */
+	u8 flags;		/* Miscellaneous flags */
+	acpi_owner_id owner_id;	/* Node creator */
+	union acpi_name_union name;	/* ACPI Name, always 4 chars per ACPI spec */
+	struct acpi_namespace_node *parent;	/* Parent node */
+	struct acpi_namespace_node *child;	/* First child */
+	struct acpi_namespace_node *peer;	/* First peer */
+
+	/*
+	 * The following fields are used by the ASL compiler and disassembler only
+	 */
+#ifdef ACPI_LARGE_NAMESPACE_NODE
+	union acpi_parse_object *op;
+	u32 value;
+	u32 length;
+#endif
+};
+
+/* Namespace Node flags */
+
+#define ANOBJ_RESERVED                  0x01	/* Available for use */
+#define ANOBJ_TEMPORARY                 0x02	/* Node is create by a method and is temporary */
+#define ANOBJ_METHOD_ARG                0x04	/* Node is a method argument */
+#define ANOBJ_METHOD_LOCAL              0x08	/* Node is a method local */
+#define ANOBJ_SUBTREE_HAS_INI           0x10	/* Used to optimize device initialization */
+#define ANOBJ_EVALUATED                 0x20	/* Set on first evaluation of node */
+#define ANOBJ_ALLOCATED_BUFFER          0x40	/* Method AML buffer is dynamic (install_method) */
+
+#define ANOBJ_IS_EXTERNAL               0x08	/* i_aSL only: This object created via External() */
+#define ANOBJ_METHOD_NO_RETVAL          0x10	/* i_aSL only: Method has no return value */
+#define ANOBJ_METHOD_SOME_NO_RETVAL     0x20	/* i_aSL only: Method has at least one return value */
+#define ANOBJ_IS_REFERENCED             0x80	/* i_aSL only: Object was referenced */
+
+/* Internal ACPI table management - master table list */
+
+struct acpi_table_list {
+	struct acpi_table_desc *tables;	/* Table descriptor array */
+	u32 current_table_count;	/* Tables currently in the array */
+	u32 max_table_count;	/* Max tables array will hold */
+	u8 flags;
+};
+
+/* Flags for above */
+
+#define ACPI_ROOT_ORIGIN_UNKNOWN        (0)	/* ~ORIGIN_ALLOCATED */
+#define ACPI_ROOT_ORIGIN_ALLOCATED      (1)
+#define ACPI_ROOT_ALLOW_RESIZE          (2)
+
+/* Predefined (fixed) table indexes */
+
+#define ACPI_TABLE_INDEX_DSDT           (0)
+#define ACPI_TABLE_INDEX_FACS           (1)
+
+struct acpi_find_context {
+	char *search_for;
+	acpi_handle *list;
+	u32 *count;
+};
+
+struct acpi_ns_search_data {
+	struct acpi_namespace_node *node;
+};
+
+/* Object types used during package copies */
+
+#define ACPI_COPY_TYPE_SIMPLE           0
+#define ACPI_COPY_TYPE_PACKAGE          1
+
+/* Info structure used to convert external<->internal namestrings */
+
+struct acpi_namestring_info {
+	const char *external_name;
+	const char *next_external_char;
+	char *internal_name;
+	u32 length;
+	u32 num_segments;
+	u32 num_carats;
+	u8 fully_qualified;
+};
+
+/* Field creation info */
+
+struct acpi_create_field_info {
+	struct acpi_namespace_node *region_node;
+	struct acpi_namespace_node *field_node;
+	struct acpi_namespace_node *register_node;
+	struct acpi_namespace_node *data_register_node;
+	struct acpi_namespace_node *connection_node;
+	u8 *resource_buffer;
+	u32 bank_value;
+	u32 field_bit_position;
+	u32 field_bit_length;
+	u16 resource_length;
+	u8 field_flags;
+	u8 attribute;
+	u8 field_type;
+	u8 access_length;
+};
+
+typedef
+acpi_status(*acpi_internal_method) (struct acpi_walk_state * walk_state);
+
+/*
+ * Bitmapped ACPI types.  Used internally only
+ */
+#define ACPI_BTYPE_ANY                  0x00000000
+#define ACPI_BTYPE_INTEGER              0x00000001
+#define ACPI_BTYPE_STRING               0x00000002
+#define ACPI_BTYPE_BUFFER               0x00000004
+#define ACPI_BTYPE_PACKAGE              0x00000008
+#define ACPI_BTYPE_FIELD_UNIT           0x00000010
+#define ACPI_BTYPE_DEVICE               0x00000020
+#define ACPI_BTYPE_EVENT                0x00000040
+#define ACPI_BTYPE_METHOD               0x00000080
+#define ACPI_BTYPE_MUTEX                0x00000100
+#define ACPI_BTYPE_REGION               0x00000200
+#define ACPI_BTYPE_POWER                0x00000400
+#define ACPI_BTYPE_PROCESSOR            0x00000800
+#define ACPI_BTYPE_THERMAL              0x00001000
+#define ACPI_BTYPE_BUFFER_FIELD         0x00002000
+#define ACPI_BTYPE_DDB_HANDLE           0x00004000
+#define ACPI_BTYPE_DEBUG_OBJECT         0x00008000
+#define ACPI_BTYPE_REFERENCE            0x00010000
+#define ACPI_BTYPE_RESOURCE             0x00020000
+
+#define ACPI_BTYPE_COMPUTE_DATA         (ACPI_BTYPE_INTEGER | ACPI_BTYPE_STRING | ACPI_BTYPE_BUFFER)
+
+#define ACPI_BTYPE_DATA                 (ACPI_BTYPE_COMPUTE_DATA  | ACPI_BTYPE_PACKAGE)
+#define ACPI_BTYPE_DATA_REFERENCE       (ACPI_BTYPE_DATA | ACPI_BTYPE_REFERENCE | ACPI_BTYPE_DDB_HANDLE)
+#define ACPI_BTYPE_DEVICE_OBJECTS       (ACPI_BTYPE_DEVICE | ACPI_BTYPE_THERMAL | ACPI_BTYPE_PROCESSOR)
+#define ACPI_BTYPE_OBJECTS_AND_REFS     0x0001FFFF	/* ARG or LOCAL */
+#define ACPI_BTYPE_ALL_OBJECTS          0x0000FFFF
+
+/*
+ * Information structure for ACPI predefined names.
+ * Each entry in the table contains the following items:
+ *
+ * Name                 - The ACPI reserved name
+ * param_count          - Number of arguments to the method
+ * expected_return_btypes - Allowed type(s) for the return value
+ */
+struct acpi_name_info {
+	char name[ACPI_NAME_SIZE];
+	u8 param_count;
+	u8 expected_btypes;
+};
+
+/*
+ * Secondary information structures for ACPI predefined objects that return
+ * package objects. This structure appears as the next entry in the table
+ * after the NAME_INFO structure above.
+ *
+ * The reason for this is to minimize the size of the predefined name table.
+ */
+
+/*
+ * Used for ACPI_PTYPE1_FIXED, ACPI_PTYPE1_VAR, ACPI_PTYPE2,
+ * ACPI_PTYPE2_MIN, ACPI_PTYPE2_PKG_COUNT, ACPI_PTYPE2_COUNT,
+ * ACPI_PTYPE2_FIX_VAR
+ */
+struct acpi_package_info {
+	u8 type;
+	u8 object_type1;
+	u8 count1;
+	u8 object_type2;
+	u8 count2;
+	u8 reserved;
+};
+
+/* Used for ACPI_PTYPE2_FIXED */
+
+struct acpi_package_info2 {
+	u8 type;
+	u8 count;
+	u8 object_type[4];
+};
+
+/* Used for ACPI_PTYPE1_OPTION */
+
+struct acpi_package_info3 {
+	u8 type;
+	u8 count;
+	u8 object_type[2];
+	u8 tail_object_type;
+	u8 reserved;
+};
+
+union acpi_predefined_info {
+	struct acpi_name_info info;
+	struct acpi_package_info ret_info;
+	struct acpi_package_info2 ret_info2;
+	struct acpi_package_info3 ret_info3;
+};
+
+/* Data block used during object validation */
+
+struct acpi_predefined_data {
+	char *pathname;
+	const union acpi_predefined_info *predefined;
+	union acpi_operand_object *parent_package;
+	struct acpi_namespace_node *node;
+	u32 flags;
+	u8 node_flags;
+};
+
+/* Defines for Flags field above */
+
+#define ACPI_OBJECT_REPAIRED    1
+
+/*
+ * Bitmapped return value types
+ * Note: the actual data types must be contiguous, a loop in nspredef.c
+ * depends on this.
+ */
+#define ACPI_RTYPE_ANY                  0x00
+#define ACPI_RTYPE_NONE                 0x01
+#define ACPI_RTYPE_INTEGER              0x02
+#define ACPI_RTYPE_STRING               0x04
+#define ACPI_RTYPE_BUFFER               0x08
+#define ACPI_RTYPE_PACKAGE              0x10
+#define ACPI_RTYPE_REFERENCE            0x20
+#define ACPI_RTYPE_ALL                  0x3F
+
+#define ACPI_NUM_RTYPES                 5	/* Number of actual object types */
+
+/*****************************************************************************
+ *
+ * Event typedefs and structs
+ *
+ ****************************************************************************/
+
+/* Dispatch info for each GPE -- either a method or handler, cannot be both */
+
+struct acpi_gpe_handler_info {
+	acpi_gpe_handler address;	/* Address of handler, if any */
+	void *context;		/* Context to be passed to handler */
+	struct acpi_namespace_node *method_node;	/* Method node for this GPE level (saved) */
+	u8 original_flags;	/* Original (pre-handler) GPE info */
+	u8 originally_enabled;	/* True if GPE was originally enabled */
+};
+
+/*
+ * GPE dispatch info. At any time, the GPE can have at most one type
+ * of dispatch - Method, Handler, or Implicit Notify.
+ */
+union acpi_gpe_dispatch_info {
+	struct acpi_namespace_node *method_node;	/* Method node for this GPE level */
+	struct acpi_gpe_handler_info *handler;	/* Installed GPE handler */
+	struct acpi_namespace_node *device_node;	/* Parent _PRW device for implicit notify */
+};
+
+/*
+ * Information about a GPE, one per each GPE in an array.
+ * NOTE: Important to keep this struct as small as possible.
+ */
+struct acpi_gpe_event_info {
+	union acpi_gpe_dispatch_info dispatch;	/* Either Method or Handler */
+	struct acpi_gpe_register_info *register_info;	/* Backpointer to register info */
+	u8 flags;		/* Misc info about this GPE */
+	u8 gpe_number;		/* This GPE */
+	u8 runtime_count;	/* References to a run GPE */
+};
+
+/* Information about a GPE register pair, one per each status/enable pair in an array */
+
+struct acpi_gpe_register_info {
+	struct acpi_generic_address status_address;	/* Address of status reg */
+	struct acpi_generic_address enable_address;	/* Address of enable reg */
+	u8 enable_for_wake;	/* GPEs to keep enabled when sleeping */
+	u8 enable_for_run;	/* GPEs to keep enabled when running */
+	u8 base_gpe_number;	/* Base GPE number for this register */
+};
+
+/*
+ * Information about a GPE register block, one per each installed block --
+ * GPE0, GPE1, and one per each installed GPE Block Device.
+ */
+struct acpi_gpe_block_info {
+	struct acpi_namespace_node *node;
+	struct acpi_gpe_block_info *previous;
+	struct acpi_gpe_block_info *next;
+	struct acpi_gpe_xrupt_info *xrupt_block;	/* Backpointer to interrupt block */
+	struct acpi_gpe_register_info *register_info;	/* One per GPE register pair */
+	struct acpi_gpe_event_info *event_info;	/* One for each GPE */
+	struct acpi_generic_address block_address;	/* Base address of the block */
+	u32 register_count;	/* Number of register pairs in block */
+	u16 gpe_count;		/* Number of individual GPEs in block */
+	u8 block_base_number;	/* Base GPE number for this block */
+	u8 initialized;		/* TRUE if this block is initialized */
+};
+
+/* Information about GPE interrupt handlers, one per each interrupt level used for GPEs */
+
+struct acpi_gpe_xrupt_info {
+	struct acpi_gpe_xrupt_info *previous;
+	struct acpi_gpe_xrupt_info *next;
+	struct acpi_gpe_block_info *gpe_block_list_head;	/* List of GPE blocks for this xrupt */
+	u32 interrupt_number;	/* System interrupt number */
+};
+
+struct acpi_gpe_walk_info {
+	struct acpi_namespace_node *gpe_device;
+	struct acpi_gpe_block_info *gpe_block;
+	u16 count;
+	acpi_owner_id owner_id;
+	u8 execute_by_owner_id;
+};
+
+struct acpi_gpe_device_info {
+	u32 index;
+	u32 next_block_base_index;
+	acpi_status status;
+	struct acpi_namespace_node *gpe_device;
+};
+
+typedef acpi_status(*acpi_gpe_callback) (struct acpi_gpe_xrupt_info *
+					 gpe_xrupt_info,
+					 struct acpi_gpe_block_info * gpe_block,
+					 void *context);
+
+/* Information about each particular fixed event */
+
+struct acpi_fixed_event_handler {
+	acpi_event_handler handler;	/* Address of handler. */
+	void *context;		/* Context to be passed to handler */
+};
+
+struct acpi_fixed_event_info {
+	u8 status_register_id;
+	u8 enable_register_id;
+	u16 status_bit_mask;
+	u16 enable_bit_mask;
+};
+
+/* Information used during field processing */
+
+struct acpi_field_info {
+	u8 skip_field;
+	u8 field_flag;
+	u32 pkg_length;
+};
+
+/*****************************************************************************
+ *
+ * Generic "state" object for stacks
+ *
+ ****************************************************************************/
+
+#define ACPI_CONTROL_NORMAL                  0xC0
+#define ACPI_CONTROL_CONDITIONAL_EXECUTING   0xC1
+#define ACPI_CONTROL_PREDICATE_EXECUTING     0xC2
+#define ACPI_CONTROL_PREDICATE_FALSE         0xC3
+#define ACPI_CONTROL_PREDICATE_TRUE          0xC4
+
+#define ACPI_STATE_COMMON \
+	void                            *next; \
+	u8                              descriptor_type; /* To differentiate various internal objs */\
+	u8                              flags; \
+	u16                             value; \
+	u16                             state;
+
+	/* There are 2 bytes available here until the next natural alignment boundary */
+
+struct acpi_common_state {
+ACPI_STATE_COMMON};
+
+/*
+ * Update state - used to traverse complex objects such as packages
+ */
+struct acpi_update_state {
+	ACPI_STATE_COMMON union acpi_operand_object *object;
+};
+
+/*
+ * Pkg state - used to traverse nested package structures
+ */
+struct acpi_pkg_state {
+	ACPI_STATE_COMMON u16 index;
+	union acpi_operand_object *source_object;
+	union acpi_operand_object *dest_object;
+	struct acpi_walk_state *walk_state;
+	void *this_target_obj;
+	u32 num_packages;
+};
+
+/*
+ * Control state - one per if/else and while constructs.
+ * Allows nesting of these constructs
+ */
+struct acpi_control_state {
+	ACPI_STATE_COMMON u16 opcode;
+	union acpi_parse_object *predicate_op;
+	u8 *aml_predicate_start;	/* Start of if/while predicate */
+	u8 *package_end;	/* End of if/while block */
+	u32 loop_count;		/* While() loop counter */
+};
+
+/*
+ * Scope state - current scope during namespace lookups
+ */
+struct acpi_scope_state {
+	ACPI_STATE_COMMON struct acpi_namespace_node *node;
+};
+
+struct acpi_pscope_state {
+	ACPI_STATE_COMMON u32 arg_count;	/* Number of fixed arguments */
+	union acpi_parse_object *op;	/* Current op being parsed */
+	u8 *arg_end;		/* Current argument end */
+	u8 *pkg_end;		/* Current package end */
+	u32 arg_list;		/* Next argument to parse */
+};
+
+/*
+ * Thread state - one per thread across multiple walk states.  Multiple walk
+ * states are created when there are nested control methods executing.
+ */
+struct acpi_thread_state {
+	ACPI_STATE_COMMON u8 current_sync_level;	/* Mutex Sync (nested acquire) level */
+	struct acpi_walk_state *walk_state_list;	/* Head of list of walk_states for this thread */
+	union acpi_operand_object *acquired_mutex_list;	/* List of all currently acquired mutexes */
+	acpi_thread_id thread_id;	/* Running thread ID */
+};
+
+/*
+ * Result values - used to accumulate the results of nested
+ * AML arguments
+ */
+struct acpi_result_values {
+	ACPI_STATE_COMMON
+	    union acpi_operand_object *obj_desc[ACPI_RESULTS_FRAME_OBJ_NUM];
+};
+
+typedef
+acpi_status(*acpi_parse_downwards) (struct acpi_walk_state * walk_state,
+				    union acpi_parse_object ** out_op);
+
+typedef acpi_status(*acpi_parse_upwards) (struct acpi_walk_state * walk_state);
+
+/*
+ * Notify info - used to pass info to the deferred notify
+ * handler/dispatcher.
+ */
+struct acpi_notify_info {
+	ACPI_STATE_COMMON struct acpi_namespace_node *node;
+	union acpi_operand_object *handler_obj;
+};
+
+/* Generic state is union of structs above */
+
+union acpi_generic_state {
+	struct acpi_common_state common;
+	struct acpi_control_state control;
+	struct acpi_update_state update;
+	struct acpi_scope_state scope;
+	struct acpi_pscope_state parse_scope;
+	struct acpi_pkg_state pkg;
+	struct acpi_thread_state thread;
+	struct acpi_result_values results;
+	struct acpi_notify_info notify;
+};
+
+/*****************************************************************************
+ *
+ * Interpreter typedefs and structs
+ *
+ ****************************************************************************/
+
+typedef acpi_status(*acpi_execute_op) (struct acpi_walk_state * walk_state);
+
+/* Address Range info block */
+
+struct acpi_address_range {
+	struct acpi_address_range *next;
+	struct acpi_namespace_node *region_node;
+	acpi_physical_address start_address;
+	acpi_physical_address end_address;
+};
+
+/*****************************************************************************
+ *
+ * Parser typedefs and structs
+ *
+ ****************************************************************************/
+
+/*
+ * AML opcode, name, and argument layout
+ */
+struct acpi_opcode_info {
+#if defined(ACPI_DISASSEMBLER) || defined(ACPI_DEBUG_OUTPUT)
+	char *name;		/* Opcode name (disassembler/debug only) */
+#endif
+	u32 parse_args;		/* Grammar/Parse time arguments */
+	u32 runtime_args;	/* Interpret time arguments */
+	u16 flags;		/* Misc flags */
+	u8 object_type;		/* Corresponding internal object type */
+	u8 class;		/* Opcode class */
+	u8 type;		/* Opcode type */
+};
+
+/* Structure for Resource Tag information */
+
+struct acpi_tag_info {
+	u32 bit_offset;
+	u32 bit_length;
+};
+
+/* Value associated with the parse object */
+
+union acpi_parse_value {
+	u64 integer;		/* Integer constant (Up to 64 bits) */
+	u32 size;		/* bytelist or field size */
+	char *string;		/* NULL terminated string */
+	u8 *buffer;		/* buffer or string */
+	char *name;		/* NULL terminated string */
+	union acpi_parse_object *arg;	/* arguments and contained ops */
+	struct acpi_tag_info tag;	/* Resource descriptor tag info  */
+};
+
+#ifdef ACPI_DISASSEMBLER
+#define ACPI_DISASM_ONLY_MEMBERS(a)     a;
+#else
+#define ACPI_DISASM_ONLY_MEMBERS(a)
+#endif
+
+#define ACPI_PARSE_COMMON \
+	union acpi_parse_object         *parent;        /* Parent op */\
+	u8                              descriptor_type; /* To differentiate various internal objs */\
+	u8                              flags;          /* Type of Op */\
+	u16                             aml_opcode;     /* AML opcode */\
+	u32                             aml_offset;     /* Offset of declaration in AML */\
+	union acpi_parse_object         *next;          /* Next op */\
+	struct acpi_namespace_node      *node;          /* For use by interpreter */\
+	union acpi_parse_value          value;          /* Value or args associated with the opcode */\
+	u8                              arg_list_length; /* Number of elements in the arg list */\
+	ACPI_DISASM_ONLY_MEMBERS (\
+	u8                              disasm_flags;   /* Used during AML disassembly */\
+	u8                              disasm_opcode;  /* Subtype used for disassembly */\
+	char                            aml_op_name[16])	/* Op name (debug only) */
+
+#define ACPI_DASM_BUFFER                0x00
+#define ACPI_DASM_RESOURCE              0x01
+#define ACPI_DASM_STRING                0x02
+#define ACPI_DASM_UNICODE               0x03
+#define ACPI_DASM_EISAID                0x04
+#define ACPI_DASM_MATCHOP               0x05
+#define ACPI_DASM_LNOT_PREFIX           0x06
+#define ACPI_DASM_LNOT_SUFFIX           0x07
+#define ACPI_DASM_IGNORE                0x08
+
+/*
+ * Generic operation (for example:  If, While, Store)
+ */
+struct acpi_parse_obj_common {
+ACPI_PARSE_COMMON};
+
+/*
+ * Extended Op for named ops (Scope, Method, etc.), deferred ops (Methods and op_regions),
+ * and bytelists.
+ */
+struct acpi_parse_obj_named {
+	ACPI_PARSE_COMMON u8 *path;
+	u8 *data;		/* AML body or bytelist data */
+	u32 length;		/* AML length */
+	u32 name;		/* 4-byte name or zero if no name */
+};
+
+/* This version is used by the i_aSL compiler only */
+
+#define ACPI_MAX_PARSEOP_NAME   20
+
+struct acpi_parse_obj_asl {
+	ACPI_PARSE_COMMON union acpi_parse_object *child;
+	union acpi_parse_object *parent_method;
+	char *filename;
+	char *external_name;
+	char *namepath;
+	char name_seg[4];
+	u32 extra_value;
+	u32 column;
+	u32 line_number;
+	u32 logical_line_number;
+	u32 logical_byte_offset;
+	u32 end_line;
+	u32 end_logical_line;
+	u32 acpi_btype;
+	u32 aml_length;
+	u32 aml_subtree_length;
+	u32 final_aml_length;
+	u32 final_aml_offset;
+	u32 compile_flags;
+	u16 parse_opcode;
+	u8 aml_opcode_length;
+	u8 aml_pkg_len_bytes;
+	u8 extra;
+	char parse_op_name[ACPI_MAX_PARSEOP_NAME];
+};
+
+union acpi_parse_object {
+	struct acpi_parse_obj_common common;
+	struct acpi_parse_obj_named named;
+	struct acpi_parse_obj_asl asl;
+};
+
+/*
+ * Parse state - one state per parser invocation and each control
+ * method.
+ */
+struct acpi_parse_state {
+	u8 *aml_start;		/* First AML byte */
+	u8 *aml;		/* Next AML byte */
+	u8 *aml_end;		/* (last + 1) AML byte */
+	u8 *pkg_start;		/* Current package begin */
+	u8 *pkg_end;		/* Current package end */
+	union acpi_parse_object *start_op;	/* Root of parse tree */
+	struct acpi_namespace_node *start_node;
+	union acpi_generic_state *scope;	/* Current scope */
+	union acpi_parse_object *start_scope;
+	u32 aml_size;
+};
+
+/* Parse object flags */
+
+#define ACPI_PARSEOP_GENERIC            0x01
+#define ACPI_PARSEOP_NAMED              0x02
+#define ACPI_PARSEOP_DEFERRED           0x04
+#define ACPI_PARSEOP_BYTELIST           0x08
+#define ACPI_PARSEOP_IN_STACK           0x10
+#define ACPI_PARSEOP_TARGET             0x20
+#define ACPI_PARSEOP_IN_CACHE           0x80
+
+/* Parse object disasm_flags */
+
+#define ACPI_PARSEOP_IGNORE             0x01
+#define ACPI_PARSEOP_PARAMLIST          0x02
+#define ACPI_PARSEOP_EMPTY_TERMLIST     0x04
+#define ACPI_PARSEOP_SPECIAL            0x10
+
+/*****************************************************************************
+ *
+ * Hardware (ACPI registers) and PNP
+ *
+ ****************************************************************************/
+
+struct acpi_bit_register_info {
+	u8 parent_register;
+	u8 bit_position;
+	u16 access_bit_mask;
+};
+
+/*
+ * Some ACPI registers have bits that must be ignored -- meaning that they
+ * must be preserved.
+ */
+#define ACPI_PM1_STATUS_PRESERVED_BITS          0x0800	/* Bit 11 */
+
+/* Write-only bits must be zeroed by software */
+
+#define ACPI_PM1_CONTROL_WRITEONLY_BITS         0x2004	/* Bits 13, 2 */
+
+/* For control registers, both ignored and reserved bits must be preserved */
+
+/*
+ * For PM1 control, the SCI enable bit (bit 0, SCI_EN) is defined by the
+ * ACPI specification to be a "preserved" bit - "OSPM always preserves this
+ * bit position", section 4.7.3.2.1. However, on some machines the OS must
+ * write a one to this bit after resume for the machine to work properly.
+ * To enable this, we no longer attempt to preserve this bit. No machines
+ * are known to fail if the bit is not preserved. (May 2009)
+ */
+#define ACPI_PM1_CONTROL_IGNORED_BITS           0x0200	/* Bit 9 */
+#define ACPI_PM1_CONTROL_RESERVED_BITS          0xC1F8	/* Bits 14-15, 3-8 */
+#define ACPI_PM1_CONTROL_PRESERVED_BITS \
+		 (ACPI_PM1_CONTROL_IGNORED_BITS | ACPI_PM1_CONTROL_RESERVED_BITS)
+
+#define ACPI_PM2_CONTROL_PRESERVED_BITS         0xFFFFFFFE	/* All except bit 0 */
+
+/*
+ * Register IDs
+ * These are the full ACPI registers
+ */
+#define ACPI_REGISTER_PM1_STATUS                0x01
+#define ACPI_REGISTER_PM1_ENABLE                0x02
+#define ACPI_REGISTER_PM1_CONTROL               0x03
+#define ACPI_REGISTER_PM2_CONTROL               0x04
+#define ACPI_REGISTER_PM_TIMER                  0x05
+#define ACPI_REGISTER_PROCESSOR_BLOCK           0x06
+#define ACPI_REGISTER_SMI_COMMAND_BLOCK         0x07
+
+/* Masks used to access the bit_registers */
+
+#define ACPI_BITMASK_TIMER_STATUS               0x0001
+#define ACPI_BITMASK_BUS_MASTER_STATUS          0x0010
+#define ACPI_BITMASK_GLOBAL_LOCK_STATUS         0x0020
+#define ACPI_BITMASK_POWER_BUTTON_STATUS        0x0100
+#define ACPI_BITMASK_SLEEP_BUTTON_STATUS        0x0200
+#define ACPI_BITMASK_RT_CLOCK_STATUS            0x0400
+#define ACPI_BITMASK_PCIEXP_WAKE_STATUS         0x4000	/* ACPI 3.0 */
+#define ACPI_BITMASK_WAKE_STATUS                0x8000
+
+#define ACPI_BITMASK_ALL_FIXED_STATUS           (\
+	ACPI_BITMASK_TIMER_STATUS          | \
+	ACPI_BITMASK_BUS_MASTER_STATUS     | \
+	ACPI_BITMASK_GLOBAL_LOCK_STATUS    | \
+	ACPI_BITMASK_POWER_BUTTON_STATUS   | \
+	ACPI_BITMASK_SLEEP_BUTTON_STATUS   | \
+	ACPI_BITMASK_RT_CLOCK_STATUS       | \
+	ACPI_BITMASK_PCIEXP_WAKE_STATUS    | \
+	ACPI_BITMASK_WAKE_STATUS)
+
+#define ACPI_BITMASK_TIMER_ENABLE               0x0001
+#define ACPI_BITMASK_GLOBAL_LOCK_ENABLE         0x0020
+#define ACPI_BITMASK_POWER_BUTTON_ENABLE        0x0100
+#define ACPI_BITMASK_SLEEP_BUTTON_ENABLE        0x0200
+#define ACPI_BITMASK_RT_CLOCK_ENABLE            0x0400
+#define ACPI_BITMASK_PCIEXP_WAKE_DISABLE        0x4000	/* ACPI 3.0 */
+
+#define ACPI_BITMASK_SCI_ENABLE                 0x0001
+#define ACPI_BITMASK_BUS_MASTER_RLD             0x0002
+#define ACPI_BITMASK_GLOBAL_LOCK_RELEASE        0x0004
+#define ACPI_BITMASK_SLEEP_TYPE                 0x1C00
+#define ACPI_BITMASK_SLEEP_ENABLE               0x2000
+
+#define ACPI_BITMASK_ARB_DISABLE                0x0001
+
+/* Raw bit position of each bit_register */
+
+#define ACPI_BITPOSITION_TIMER_STATUS           0x00
+#define ACPI_BITPOSITION_BUS_MASTER_STATUS      0x04
+#define ACPI_BITPOSITION_GLOBAL_LOCK_STATUS     0x05
+#define ACPI_BITPOSITION_POWER_BUTTON_STATUS    0x08
+#define ACPI_BITPOSITION_SLEEP_BUTTON_STATUS    0x09
+#define ACPI_BITPOSITION_RT_CLOCK_STATUS        0x0A
+#define ACPI_BITPOSITION_PCIEXP_WAKE_STATUS     0x0E	/* ACPI 3.0 */
+#define ACPI_BITPOSITION_WAKE_STATUS            0x0F
+
+#define ACPI_BITPOSITION_TIMER_ENABLE           0x00
+#define ACPI_BITPOSITION_GLOBAL_LOCK_ENABLE     0x05
+#define ACPI_BITPOSITION_POWER_BUTTON_ENABLE    0x08
+#define ACPI_BITPOSITION_SLEEP_BUTTON_ENABLE    0x09
+#define ACPI_BITPOSITION_RT_CLOCK_ENABLE        0x0A
+#define ACPI_BITPOSITION_PCIEXP_WAKE_DISABLE    0x0E	/* ACPI 3.0 */
+
+#define ACPI_BITPOSITION_SCI_ENABLE             0x00
+#define ACPI_BITPOSITION_BUS_MASTER_RLD         0x01
+#define ACPI_BITPOSITION_GLOBAL_LOCK_RELEASE    0x02
+#define ACPI_BITPOSITION_SLEEP_TYPE             0x0A
+#define ACPI_BITPOSITION_SLEEP_ENABLE           0x0D
+
+#define ACPI_BITPOSITION_ARB_DISABLE            0x00
+
+/* Structs and definitions for _OSI support and I/O port validation */
+
+#define ACPI_OSI_WIN_2000               0x01
+#define ACPI_OSI_WIN_XP                 0x02
+#define ACPI_OSI_WIN_XP_SP1             0x03
+#define ACPI_OSI_WINSRV_2003            0x04
+#define ACPI_OSI_WIN_XP_SP2             0x05
+#define ACPI_OSI_WINSRV_2003_SP1        0x06
+#define ACPI_OSI_WIN_VISTA              0x07
+#define ACPI_OSI_WINSRV_2008            0x08
+#define ACPI_OSI_WIN_VISTA_SP1          0x09
+#define ACPI_OSI_WIN_VISTA_SP2          0x0A
+#define ACPI_OSI_WIN_7                  0x0B
+
+#define ACPI_ALWAYS_ILLEGAL             0x00
+
+struct acpi_interface_info {
+	char *name;
+	struct acpi_interface_info *next;
+	u8 flags;
+	u8 value;
+};
+
+#define ACPI_OSI_INVALID                0x01
+#define ACPI_OSI_DYNAMIC                0x02
+
+struct acpi_port_info {
+	char *name;
+	u16 start;
+	u16 end;
+	u8 osi_dependency;
+};
+
+/*****************************************************************************
+ *
+ * Resource descriptors
+ *
+ ****************************************************************************/
+
+/* resource_type values */
+
+#define ACPI_ADDRESS_TYPE_MEMORY_RANGE          0
+#define ACPI_ADDRESS_TYPE_IO_RANGE              1
+#define ACPI_ADDRESS_TYPE_BUS_NUMBER_RANGE      2
+
+/* Resource descriptor types and masks */
+
+#define ACPI_RESOURCE_NAME_LARGE                0x80
+#define ACPI_RESOURCE_NAME_SMALL                0x00
+
+#define ACPI_RESOURCE_NAME_SMALL_MASK           0x78	/* Bits 6:3 contain the type */
+#define ACPI_RESOURCE_NAME_SMALL_LENGTH_MASK    0x07	/* Bits 2:0 contain the length */
+#define ACPI_RESOURCE_NAME_LARGE_MASK           0x7F	/* Bits 6:0 contain the type */
+
+/*
+ * Small resource descriptor "names" as defined by the ACPI specification.
+ * Note: Bits 2:0 are used for the descriptor length
+ */
+#define ACPI_RESOURCE_NAME_IRQ                  0x20
+#define ACPI_RESOURCE_NAME_DMA                  0x28
+#define ACPI_RESOURCE_NAME_START_DEPENDENT      0x30
+#define ACPI_RESOURCE_NAME_END_DEPENDENT        0x38
+#define ACPI_RESOURCE_NAME_IO                   0x40
+#define ACPI_RESOURCE_NAME_FIXED_IO             0x48
+#define ACPI_RESOURCE_NAME_FIXED_DMA            0x50
+#define ACPI_RESOURCE_NAME_RESERVED_S2          0x58
+#define ACPI_RESOURCE_NAME_RESERVED_S3          0x60
+#define ACPI_RESOURCE_NAME_RESERVED_S4          0x68
+#define ACPI_RESOURCE_NAME_VENDOR_SMALL         0x70
+#define ACPI_RESOURCE_NAME_END_TAG              0x78
+
+/*
+ * Large resource descriptor "names" as defined by the ACPI specification.
+ * Note: includes the Large Descriptor bit in bit[7]
+ */
+#define ACPI_RESOURCE_NAME_MEMORY24             0x81
+#define ACPI_RESOURCE_NAME_GENERIC_REGISTER     0x82
+#define ACPI_RESOURCE_NAME_RESERVED_L1          0x83
+#define ACPI_RESOURCE_NAME_VENDOR_LARGE         0x84
+#define ACPI_RESOURCE_NAME_MEMORY32             0x85
+#define ACPI_RESOURCE_NAME_FIXED_MEMORY32       0x86
+#define ACPI_RESOURCE_NAME_ADDRESS32            0x87
+#define ACPI_RESOURCE_NAME_ADDRESS16            0x88
+#define ACPI_RESOURCE_NAME_EXTENDED_IRQ         0x89
+#define ACPI_RESOURCE_NAME_ADDRESS64            0x8A
+#define ACPI_RESOURCE_NAME_EXTENDED_ADDRESS64   0x8B
+#define ACPI_RESOURCE_NAME_GPIO                 0x8C
+#define ACPI_RESOURCE_NAME_SERIAL_BUS           0x8E
+#define ACPI_RESOURCE_NAME_LARGE_MAX            0x8E
+
+/*****************************************************************************
+ *
+ * Miscellaneous
+ *
+ ****************************************************************************/
+
+#define ACPI_ASCII_ZERO                 0x30
+
+/*****************************************************************************
+ *
+ * Disassembler
+ *
+ ****************************************************************************/
+
+struct acpi_external_list {
+	char *path;
+	char *internal_path;
+	struct acpi_external_list *next;
+	u32 value;
+	u16 length;
+	u8 type;
+	u8 flags;
+};
+
+/* Values for Flags field above */
+
+#define ACPI_IPATH_ALLOCATED    0x01
+
+struct acpi_external_file {
+	char *path;
+	struct acpi_external_file *next;
+};
+
+/*****************************************************************************
+ *
+ * Debugger
+ *
+ ****************************************************************************/
+
+struct acpi_db_method_info {
+	acpi_handle main_thread_gate;
+	acpi_handle thread_complete_gate;
+	acpi_handle info_gate;
+	acpi_thread_id *threads;
+	u32 num_threads;
+	u32 num_created;
+	u32 num_completed;
+
+	char *name;
+	u32 flags;
+	u32 num_loops;
+	char pathname[128];
+	char **args;
+	acpi_object_type *types;
+
+	/*
+	 * Arguments to be passed to method for the command
+	 * Threads -
+	 *   the Number of threads, ID of current thread and
+	 *   Index of current thread inside all them created.
+	 */
+	char init_args;
+	acpi_object_type arg_types[4];
+	char *arguments[4];
+	char num_threads_str[11];
+	char id_of_thread_str[11];
+	char index_of_thread_str[11];
+};
+
+struct acpi_integrity_info {
+	u32 nodes;
+	u32 objects;
+};
+
+#define ACPI_DB_REDIRECTABLE_OUTPUT     0x01
+#define ACPI_DB_CONSOLE_OUTPUT          0x02
+#define ACPI_DB_DUPLICATE_OUTPUT        0x03
+
+/*****************************************************************************
+ *
+ * Debug
+ *
+ ****************************************************************************/
+
+/* Entry for a memory allocation (debug only) */
+
+#define ACPI_MEM_MALLOC                 0
+#define ACPI_MEM_CALLOC                 1
+#define ACPI_MAX_MODULE_NAME            16
+
+#define ACPI_COMMON_DEBUG_MEM_HEADER \
+	struct acpi_debug_mem_block     *previous; \
+	struct acpi_debug_mem_block     *next; \
+	u32                             size; \
+	u32                             component; \
+	u32                             line; \
+	char                            module[ACPI_MAX_MODULE_NAME]; \
+	u8                              alloc_type;
+
+struct acpi_debug_mem_header {
+ACPI_COMMON_DEBUG_MEM_HEADER};
+
+struct acpi_debug_mem_block {
+	ACPI_COMMON_DEBUG_MEM_HEADER u64 user_space;
+};
+
+#define ACPI_MEM_LIST_GLOBAL            0
+#define ACPI_MEM_LIST_NSNODE            1
+#define ACPI_MEM_LIST_MAX               1
+#define ACPI_NUM_MEM_LISTS              2
+
+#endif				/* __ACLOCAL_H__ */
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acmacros.h b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acmacros.h
new file mode 100644
index 00000000..70d897ff
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acmacros.h
@@ -0,0 +1,525 @@
+/******************************************************************************
+ *
+ * Name: acmacros.h - C macros for the entire subsystem.
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACMACROS_H__
+#define __ACMACROS_H__
+
+/*
+ * Extract data using a pointer. Any more than a byte and we
+ * get into potential aligment issues -- see the STORE macros below.
+ * Use with care.
+ */
+#define ACPI_GET8(ptr)                  *ACPI_CAST_PTR (u8, ptr)
+#define ACPI_GET16(ptr)                 *ACPI_CAST_PTR (u16, ptr)
+#define ACPI_GET32(ptr)                 *ACPI_CAST_PTR (u32, ptr)
+#define ACPI_GET64(ptr)                 *ACPI_CAST_PTR (u64, ptr)
+#define ACPI_SET8(ptr)                  *ACPI_CAST_PTR (u8, ptr)
+#define ACPI_SET16(ptr)                 *ACPI_CAST_PTR (u16, ptr)
+#define ACPI_SET32(ptr)                 *ACPI_CAST_PTR (u32, ptr)
+#define ACPI_SET64(ptr)                 *ACPI_CAST_PTR (u64, ptr)
+
+/*
+ * printf() format helpers
+ */
+
+/* Split 64-bit integer into two 32-bit values. Use with %8.8_x%8.8_x */
+
+#define ACPI_FORMAT_UINT64(i)           ACPI_HIDWORD(i), ACPI_LODWORD(i)
+
+#if ACPI_MACHINE_WIDTH == 64
+#define ACPI_FORMAT_NATIVE_UINT(i)      ACPI_FORMAT_UINT64(i)
+#else
+#define ACPI_FORMAT_NATIVE_UINT(i)      0, (i)
+#endif
+
+/*
+ * Macros for moving data around to/from buffers that are possibly unaligned.
+ * If the hardware supports the transfer of unaligned data, just do the store.
+ * Otherwise, we have to move one byte at a time.
+ */
+#ifdef ACPI_BIG_ENDIAN
+/*
+ * Macros for big-endian machines
+ */
+
+/* These macros reverse the bytes during the move, converting little-endian to big endian */
+
+	 /* Big Endian      <==        Little Endian */
+	 /*  Hi...Lo                     Lo...Hi     */
+/* 16-bit source, 16/32/64 destination */
+
+#define ACPI_MOVE_16_TO_16(d, s)        {((  u8 *)(void *)(d))[0] = ((u8 *)(void *)(s))[1];\
+			  ((  u8 *)(void *)(d))[1] = ((u8 *)(void *)(s))[0];}
+
+#define ACPI_MOVE_16_TO_32(d, s)        {(*(u32 *)(void *)(d))=0;\
+					  ((u8 *)(void *)(d))[2] = ((u8 *)(void *)(s))[1];\
+					  ((u8 *)(void *)(d))[3] = ((u8 *)(void *)(s))[0];}
+
+#define ACPI_MOVE_16_TO_64(d, s)        {(*(u64 *)(void *)(d))=0;\
+							   ((u8 *)(void *)(d))[6] = ((u8 *)(void *)(s))[1];\
+							   ((u8 *)(void *)(d))[7] = ((u8 *)(void *)(s))[0];}
+
+/* 32-bit source, 16/32/64 destination */
+
+#define ACPI_MOVE_32_TO_16(d, s)        ACPI_MOVE_16_TO_16(d, s)	/* Truncate to 16 */
+
+#define ACPI_MOVE_32_TO_32(d, s)        {((  u8 *)(void *)(d))[0] = ((u8 *)(void *)(s))[3];\
+									  ((  u8 *)(void *)(d))[1] = ((u8 *)(void *)(s))[2];\
+									  ((  u8 *)(void *)(d))[2] = ((u8 *)(void *)(s))[1];\
+									  ((  u8 *)(void *)(d))[3] = ((u8 *)(void *)(s))[0];}
+
+#define ACPI_MOVE_32_TO_64(d, s)        {(*(u64 *)(void *)(d))=0;\
+										   ((u8 *)(void *)(d))[4] = ((u8 *)(void *)(s))[3];\
+										   ((u8 *)(void *)(d))[5] = ((u8 *)(void *)(s))[2];\
+										   ((u8 *)(void *)(d))[6] = ((u8 *)(void *)(s))[1];\
+										   ((u8 *)(void *)(d))[7] = ((u8 *)(void *)(s))[0];}
+
+/* 64-bit source, 16/32/64 destination */
+
+#define ACPI_MOVE_64_TO_16(d, s)        ACPI_MOVE_16_TO_16(d, s)	/* Truncate to 16 */
+
+#define ACPI_MOVE_64_TO_32(d, s)        ACPI_MOVE_32_TO_32(d, s)	/* Truncate to 32 */
+
+#define ACPI_MOVE_64_TO_64(d, s)        {((  u8 *)(void *)(d))[0] = ((u8 *)(void *)(s))[7];\
+										 ((  u8 *)(void *)(d))[1] = ((u8 *)(void *)(s))[6];\
+										 ((  u8 *)(void *)(d))[2] = ((u8 *)(void *)(s))[5];\
+										 ((  u8 *)(void *)(d))[3] = ((u8 *)(void *)(s))[4];\
+										 ((  u8 *)(void *)(d))[4] = ((u8 *)(void *)(s))[3];\
+										 ((  u8 *)(void *)(d))[5] = ((u8 *)(void *)(s))[2];\
+										 ((  u8 *)(void *)(d))[6] = ((u8 *)(void *)(s))[1];\
+										 ((  u8 *)(void *)(d))[7] = ((u8 *)(void *)(s))[0];}
+#else
+/*
+ * Macros for little-endian machines
+ */
+
+#ifndef ACPI_MISALIGNMENT_NOT_SUPPORTED
+
+/* The hardware supports unaligned transfers, just do the little-endian move */
+
+/* 16-bit source, 16/32/64 destination */
+
+#define ACPI_MOVE_16_TO_16(d, s)        *(u16 *)(void *)(d) = *(u16 *)(void *)(s)
+#define ACPI_MOVE_16_TO_32(d, s)        *(u32 *)(void *)(d) = *(u16 *)(void *)(s)
+#define ACPI_MOVE_16_TO_64(d, s)        *(u64 *)(void *)(d) = *(u16 *)(void *)(s)
+
+/* 32-bit source, 16/32/64 destination */
+
+#define ACPI_MOVE_32_TO_16(d, s)        ACPI_MOVE_16_TO_16(d, s)	/* Truncate to 16 */
+#define ACPI_MOVE_32_TO_32(d, s)        *(u32 *)(void *)(d) = *(u32 *)(void *)(s)
+#define ACPI_MOVE_32_TO_64(d, s)        *(u64 *)(void *)(d) = *(u32 *)(void *)(s)
+
+/* 64-bit source, 16/32/64 destination */
+
+#define ACPI_MOVE_64_TO_16(d, s)        ACPI_MOVE_16_TO_16(d, s)	/* Truncate to 16 */
+#define ACPI_MOVE_64_TO_32(d, s)        ACPI_MOVE_32_TO_32(d, s)	/* Truncate to 32 */
+#define ACPI_MOVE_64_TO_64(d, s)        *(u64 *)(void *)(d) = *(u64 *)(void *)(s)
+
+#else
+/*
+ * The hardware does not support unaligned transfers. We must move the
+ * data one byte at a time. These macros work whether the source or
+ * the destination (or both) is/are unaligned. (Little-endian move)
+ */
+
+/* 16-bit source, 16/32/64 destination */
+
+#define ACPI_MOVE_16_TO_16(d, s)        {((  u8 *)(void *)(d))[0] = ((u8 *)(void *)(s))[0];\
+										 ((  u8 *)(void *)(d))[1] = ((u8 *)(void *)(s))[1];}
+
+#define ACPI_MOVE_16_TO_32(d, s)        {(*(u32 *)(void *)(d)) = 0; ACPI_MOVE_16_TO_16(d, s);}
+#define ACPI_MOVE_16_TO_64(d, s)        {(*(u64 *)(void *)(d)) = 0; ACPI_MOVE_16_TO_16(d, s);}
+
+/* 32-bit source, 16/32/64 destination */
+
+#define ACPI_MOVE_32_TO_16(d, s)        ACPI_MOVE_16_TO_16(d, s)	/* Truncate to 16 */
+
+#define ACPI_MOVE_32_TO_32(d, s)        {((  u8 *)(void *)(d))[0] = ((u8 *)(void *)(s))[0];\
+										 ((  u8 *)(void *)(d))[1] = ((u8 *)(void *)(s))[1];\
+										 ((  u8 *)(void *)(d))[2] = ((u8 *)(void *)(s))[2];\
+										 ((  u8 *)(void *)(d))[3] = ((u8 *)(void *)(s))[3];}
+
+#define ACPI_MOVE_32_TO_64(d, s)        {(*(u64 *)(void *)(d)) = 0; ACPI_MOVE_32_TO_32(d, s);}
+
+/* 64-bit source, 16/32/64 destination */
+
+#define ACPI_MOVE_64_TO_16(d, s)        ACPI_MOVE_16_TO_16(d, s)	/* Truncate to 16 */
+#define ACPI_MOVE_64_TO_32(d, s)        ACPI_MOVE_32_TO_32(d, s)	/* Truncate to 32 */
+#define ACPI_MOVE_64_TO_64(d, s)        {((  u8 *)(void *)(d))[0] = ((u8 *)(void *)(s))[0];\
+										 ((  u8 *)(void *)(d))[1] = ((u8 *)(void *)(s))[1];\
+										 ((  u8 *)(void *)(d))[2] = ((u8 *)(void *)(s))[2];\
+										 ((  u8 *)(void *)(d))[3] = ((u8 *)(void *)(s))[3];\
+										 ((  u8 *)(void *)(d))[4] = ((u8 *)(void *)(s))[4];\
+										 ((  u8 *)(void *)(d))[5] = ((u8 *)(void *)(s))[5];\
+										 ((  u8 *)(void *)(d))[6] = ((u8 *)(void *)(s))[6];\
+										 ((  u8 *)(void *)(d))[7] = ((u8 *)(void *)(s))[7];}
+#endif
+#endif
+
+/*
+ * Fast power-of-two math macros for non-optimized compilers
+ */
+#define _ACPI_DIV(value, power_of2)     ((u32) ((value) >> (power_of2)))
+#define _ACPI_MUL(value, power_of2)     ((u32) ((value) << (power_of2)))
+#define _ACPI_MOD(value, divisor)       ((u32) ((value) & ((divisor) -1)))
+
+#define ACPI_DIV_2(a)                   _ACPI_DIV(a, 1)
+#define ACPI_MUL_2(a)                   _ACPI_MUL(a, 1)
+#define ACPI_MOD_2(a)                   _ACPI_MOD(a, 2)
+
+#define ACPI_DIV_4(a)                   _ACPI_DIV(a, 2)
+#define ACPI_MUL_4(a)                   _ACPI_MUL(a, 2)
+#define ACPI_MOD_4(a)                   _ACPI_MOD(a, 4)
+
+#define ACPI_DIV_8(a)                   _ACPI_DIV(a, 3)
+#define ACPI_MUL_8(a)                   _ACPI_MUL(a, 3)
+#define ACPI_MOD_8(a)                   _ACPI_MOD(a, 8)
+
+#define ACPI_DIV_16(a)                  _ACPI_DIV(a, 4)
+#define ACPI_MUL_16(a)                  _ACPI_MUL(a, 4)
+#define ACPI_MOD_16(a)                  _ACPI_MOD(a, 16)
+
+#define ACPI_DIV_32(a)                  _ACPI_DIV(a, 5)
+#define ACPI_MUL_32(a)                  _ACPI_MUL(a, 5)
+#define ACPI_MOD_32(a)                  _ACPI_MOD(a, 32)
+
+/*
+ * Rounding macros (Power of two boundaries only)
+ */
+#define ACPI_ROUND_DOWN(value, boundary)    (((acpi_size)(value)) & \
+												(~(((acpi_size) boundary)-1)))
+
+#define ACPI_ROUND_UP(value, boundary)      ((((acpi_size)(value)) + \
+												(((acpi_size) boundary)-1)) & \
+												(~(((acpi_size) boundary)-1)))
+
+/* Note: sizeof(acpi_size) evaluates to either 4 or 8 (32- vs 64-bit mode) */
+
+#define ACPI_ROUND_DOWN_TO_32BIT(a)         ACPI_ROUND_DOWN(a, 4)
+#define ACPI_ROUND_DOWN_TO_64BIT(a)         ACPI_ROUND_DOWN(a, 8)
+#define ACPI_ROUND_DOWN_TO_NATIVE_WORD(a)   ACPI_ROUND_DOWN(a, sizeof(acpi_size))
+
+#define ACPI_ROUND_UP_TO_32BIT(a)           ACPI_ROUND_UP(a, 4)
+#define ACPI_ROUND_UP_TO_64BIT(a)           ACPI_ROUND_UP(a, 8)
+#define ACPI_ROUND_UP_TO_NATIVE_WORD(a)     ACPI_ROUND_UP(a, sizeof(acpi_size))
+
+#define ACPI_ROUND_BITS_UP_TO_BYTES(a)      ACPI_DIV_8((a) + 7)
+#define ACPI_ROUND_BITS_DOWN_TO_BYTES(a)    ACPI_DIV_8((a))
+
+#define ACPI_ROUND_UP_TO_1K(a)              (((a) + 1023) >> 10)
+
+/* Generic (non-power-of-two) rounding */
+
+#define ACPI_ROUND_UP_TO(value, boundary)   (((value) + ((boundary)-1)) / (boundary))
+
+#define ACPI_IS_MISALIGNED(value)           (((acpi_size) value) & (sizeof(acpi_size)-1))
+
+/*
+ * Bitmask creation
+ * Bit positions start at zero.
+ * MASK_BITS_ABOVE creates a mask starting AT the position and above
+ * MASK_BITS_BELOW creates a mask starting one bit BELOW the position
+ */
+#define ACPI_MASK_BITS_ABOVE(position)      (~((ACPI_UINT64_MAX) << ((u32) (position))))
+#define ACPI_MASK_BITS_BELOW(position)      ((ACPI_UINT64_MAX) << ((u32) (position)))
+
+/* Bitfields within ACPI registers */
+
+#define ACPI_REGISTER_PREPARE_BITS(val, pos, mask)      ((val << pos) & mask)
+#define ACPI_REGISTER_INSERT_VALUE(reg, pos, mask, val)  reg = (reg & (~(mask))) | ACPI_REGISTER_PREPARE_BITS(val, pos, mask)
+
+#define ACPI_INSERT_BITS(target, mask, source)          target = ((target & (~(mask))) | (source & mask))
+
+/*
+ * An struct acpi_namespace_node can appear in some contexts
+ * where a pointer to an union acpi_operand_object can also
+ * appear. This macro is used to distinguish them.
+ *
+ * The "Descriptor" field is the first field in both structures.
+ */
+#define ACPI_GET_DESCRIPTOR_TYPE(d)     (((union acpi_descriptor *)(void *)(d))->common.descriptor_type)
+#define ACPI_SET_DESCRIPTOR_TYPE(d, t)  (((union acpi_descriptor *)(void *)(d))->common.descriptor_type = t)
+
+/*
+ * Macros for the master AML opcode table
+ */
+#if defined (ACPI_DISASSEMBLER) || defined (ACPI_DEBUG_OUTPUT)
+#define ACPI_OP(name, Pargs, Iargs, obj_type, class, type, flags) \
+	{name, (u32)(Pargs), (u32)(Iargs), (u32)(flags), obj_type, class, type}
+#else
+#define ACPI_OP(name, Pargs, Iargs, obj_type, class, type, flags) \
+	{(u32)(Pargs), (u32)(Iargs), (u32)(flags), obj_type, class, type}
+#endif
+
+#define ARG_TYPE_WIDTH                  5
+#define ARG_1(x)                        ((u32)(x))
+#define ARG_2(x)                        ((u32)(x) << (1 * ARG_TYPE_WIDTH))
+#define ARG_3(x)                        ((u32)(x) << (2 * ARG_TYPE_WIDTH))
+#define ARG_4(x)                        ((u32)(x) << (3 * ARG_TYPE_WIDTH))
+#define ARG_5(x)                        ((u32)(x) << (4 * ARG_TYPE_WIDTH))
+#define ARG_6(x)                        ((u32)(x) << (5 * ARG_TYPE_WIDTH))
+
+#define ARGI_LIST1(a)                   (ARG_1(a))
+#define ARGI_LIST2(a, b)                (ARG_1(b)|ARG_2(a))
+#define ARGI_LIST3(a, b, c)             (ARG_1(c)|ARG_2(b)|ARG_3(a))
+#define ARGI_LIST4(a, b, c, d)          (ARG_1(d)|ARG_2(c)|ARG_3(b)|ARG_4(a))
+#define ARGI_LIST5(a, b, c, d, e)       (ARG_1(e)|ARG_2(d)|ARG_3(c)|ARG_4(b)|ARG_5(a))
+#define ARGI_LIST6(a, b, c, d, e, f)    (ARG_1(f)|ARG_2(e)|ARG_3(d)|ARG_4(c)|ARG_5(b)|ARG_6(a))
+
+#define ARGP_LIST1(a)                   (ARG_1(a))
+#define ARGP_LIST2(a, b)                (ARG_1(a)|ARG_2(b))
+#define ARGP_LIST3(a, b, c)             (ARG_1(a)|ARG_2(b)|ARG_3(c))
+#define ARGP_LIST4(a, b, c, d)          (ARG_1(a)|ARG_2(b)|ARG_3(c)|ARG_4(d))
+#define ARGP_LIST5(a, b, c, d, e)       (ARG_1(a)|ARG_2(b)|ARG_3(c)|ARG_4(d)|ARG_5(e))
+#define ARGP_LIST6(a, b, c, d, e, f)    (ARG_1(a)|ARG_2(b)|ARG_3(c)|ARG_4(d)|ARG_5(e)|ARG_6(f))
+
+#define GET_CURRENT_ARG_TYPE(list)      (list & ((u32) 0x1F))
+#define INCREMENT_ARG_LIST(list)        (list >>= ((u32) ARG_TYPE_WIDTH))
+
+/*
+ * Ascii error messages can be configured out
+ */
+#ifndef ACPI_NO_ERROR_MESSAGES
+/*
+ * Error reporting. Callers module and line number are inserted by AE_INFO,
+ * the plist contains a set of parens to allow variable-length lists.
+ * These macros are used for both the debug and non-debug versions of the code.
+ */
+#define ACPI_ERROR_NAMESPACE(s, e)      acpi_ut_namespace_error (AE_INFO, s, e);
+#define ACPI_ERROR_METHOD(s, n, p, e)   acpi_ut_method_error (AE_INFO, s, n, p, e);
+#define ACPI_WARN_PREDEFINED(plist)     acpi_ut_predefined_warning plist
+#define ACPI_INFO_PREDEFINED(plist)     acpi_ut_predefined_info plist
+
+#else
+
+/* No error messages */
+
+#define ACPI_ERROR_NAMESPACE(s, e)
+#define ACPI_ERROR_METHOD(s, n, p, e)
+#define ACPI_WARN_PREDEFINED(plist)
+#define ACPI_INFO_PREDEFINED(plist)
+
+#endif				/* ACPI_NO_ERROR_MESSAGES */
+
+/*
+ * Debug macros that are conditionally compiled
+ */
+#ifdef ACPI_DEBUG_OUTPUT
+/*
+ * Function entry tracing
+ */
+#define ACPI_FUNCTION_TRACE(a)          ACPI_FUNCTION_NAME(a) \
+			  acpi_ut_trace(ACPI_DEBUG_PARAMETERS)
+#define ACPI_FUNCTION_TRACE_PTR(a, b)   ACPI_FUNCTION_NAME(a) \
+					   acpi_ut_trace_ptr(ACPI_DEBUG_PARAMETERS, (void *)b)
+#define ACPI_FUNCTION_TRACE_U32(a, b)   ACPI_FUNCTION_NAME(a) \
+							 acpi_ut_trace_u32(ACPI_DEBUG_PARAMETERS, (u32)b)
+#define ACPI_FUNCTION_TRACE_STR(a, b)   ACPI_FUNCTION_NAME(a) \
+									  acpi_ut_trace_str(ACPI_DEBUG_PARAMETERS, (char *)b)
+
+#define ACPI_FUNCTION_ENTRY()           acpi_ut_track_stack_ptr()
+
+/*
+ * Function exit tracing.
+ * WARNING: These macros include a return statement. This is usually considered
+ * bad form, but having a separate exit macro is very ugly and difficult to maintain.
+ * One of the FUNCTION_TRACE macros above must be used in conjunction with these macros
+ * so that "_AcpiFunctionName" is defined.
+ *
+ * Note: the DO_WHILE0 macro is used to prevent some compilers from complaining
+ * about these constructs.
+ */
+#ifdef ACPI_USE_DO_WHILE_0
+#define ACPI_DO_WHILE0(a)               do a while(0)
+#else
+#define ACPI_DO_WHILE0(a)               a
+#endif
+
+#define return_VOID                     ACPI_DO_WHILE0 ({ \
+											acpi_ut_exit (ACPI_DEBUG_PARAMETERS); \
+											return;})
+/*
+ * There are two versions of most of the return macros. The default version is
+ * safer, since it avoids side-effects by guaranteeing that the argument will
+ * not be evaluated twice.
+ *
+ * A less-safe version of the macros is provided for optional use if the
+ * compiler uses excessive CPU stack (for example, this may happen in the
+ * debug case if code optimzation is disabled.)
+ */
+#ifndef ACPI_SIMPLE_RETURN_MACROS
+
+#define return_ACPI_STATUS(s)           ACPI_DO_WHILE0 ({ \
+											register acpi_status _s = (s); \
+											acpi_ut_status_exit (ACPI_DEBUG_PARAMETERS, _s); \
+											return (_s); })
+#define return_PTR(s)                   ACPI_DO_WHILE0 ({ \
+											register void *_s = (void *) (s); \
+											acpi_ut_ptr_exit (ACPI_DEBUG_PARAMETERS, (u8 *) _s); \
+											return (_s); })
+#define return_VALUE(s)                 ACPI_DO_WHILE0 ({ \
+											register u64 _s = (s); \
+											acpi_ut_value_exit (ACPI_DEBUG_PARAMETERS, _s); \
+											return (_s); })
+#define return_UINT8(s)                 ACPI_DO_WHILE0 ({ \
+											register u8 _s = (u8) (s); \
+											acpi_ut_value_exit (ACPI_DEBUG_PARAMETERS, (u64) _s); \
+											return (_s); })
+#define return_UINT32(s)                ACPI_DO_WHILE0 ({ \
+											register u32 _s = (u32) (s); \
+											acpi_ut_value_exit (ACPI_DEBUG_PARAMETERS, (u64) _s); \
+											return (_s); })
+#else				/* Use original less-safe macros */
+
+#define return_ACPI_STATUS(s)           ACPI_DO_WHILE0 ({ \
+											acpi_ut_status_exit (ACPI_DEBUG_PARAMETERS, (s)); \
+											return((s)); })
+#define return_PTR(s)                   ACPI_DO_WHILE0 ({ \
+											acpi_ut_ptr_exit (ACPI_DEBUG_PARAMETERS, (u8 *) (s)); \
+											return((s)); })
+#define return_VALUE(s)                 ACPI_DO_WHILE0 ({ \
+											acpi_ut_value_exit (ACPI_DEBUG_PARAMETERS, (u64) (s)); \
+											return((s)); })
+#define return_UINT8(s)                 return_VALUE(s)
+#define return_UINT32(s)                return_VALUE(s)
+
+#endif				/* ACPI_SIMPLE_RETURN_MACROS */
+
+/* Conditional execution */
+
+#define ACPI_DEBUG_EXEC(a)              a
+#define ACPI_DEBUG_ONLY_MEMBERS(a)      a;
+#define _VERBOSE_STRUCTURES
+
+/* Various object display routines for debug */
+
+#define ACPI_DUMP_STACK_ENTRY(a)        acpi_ex_dump_operand((a), 0)
+#define ACPI_DUMP_OPERANDS(a, b ,c)     acpi_ex_dump_operands(a, b, c)
+#define ACPI_DUMP_ENTRY(a, b)           acpi_ns_dump_entry (a, b)
+#define ACPI_DUMP_PATHNAME(a, b, c, d)  acpi_ns_dump_pathname(a, b, c, d)
+#define ACPI_DUMP_BUFFER(a, b)          acpi_ut_dump_buffer((u8 *) a, b, DB_BYTE_DISPLAY, _COMPONENT)
+
+#else
+/*
+ * This is the non-debug case -- make everything go away,
+ * leaving no executable debug code!
+ */
+#define ACPI_DEBUG_EXEC(a)
+#define ACPI_DEBUG_ONLY_MEMBERS(a)
+#define ACPI_FUNCTION_TRACE(a)
+#define ACPI_FUNCTION_TRACE_PTR(a, b)
+#define ACPI_FUNCTION_TRACE_U32(a, b)
+#define ACPI_FUNCTION_TRACE_STR(a, b)
+#define ACPI_FUNCTION_EXIT
+#define ACPI_FUNCTION_STATUS_EXIT(s)
+#define ACPI_FUNCTION_VALUE_EXIT(s)
+#define ACPI_FUNCTION_ENTRY()
+#define ACPI_DUMP_STACK_ENTRY(a)
+#define ACPI_DUMP_OPERANDS(a, b, c)
+#define ACPI_DUMP_ENTRY(a, b)
+#define ACPI_DUMP_TABLES(a, b)
+#define ACPI_DUMP_PATHNAME(a, b, c, d)
+#define ACPI_DUMP_BUFFER(a, b)
+#define ACPI_DEBUG_PRINT(pl)
+#define ACPI_DEBUG_PRINT_RAW(pl)
+
+#define return_VOID                     return
+#define return_ACPI_STATUS(s)           return(s)
+#define return_VALUE(s)                 return(s)
+#define return_UINT8(s)                 return(s)
+#define return_UINT32(s)                return(s)
+#define return_PTR(s)                   return(s)
+
+#endif				/* ACPI_DEBUG_OUTPUT */
+
+/*
+ * Some code only gets executed when the debugger is built in.
+ * Note that this is entirely independent of whether the
+ * DEBUG_PRINT stuff (set by ACPI_DEBUG_OUTPUT) is on, or not.
+ */
+#ifdef ACPI_DEBUGGER
+#define ACPI_DEBUGGER_EXEC(a)           a
+#else
+#define ACPI_DEBUGGER_EXEC(a)
+#endif
+
+/*
+ * Memory allocation tracking (DEBUG ONLY)
+ */
+#define ACPI_MEM_PARAMETERS         _COMPONENT, _acpi_module_name, __LINE__
+
+#ifndef ACPI_DBG_TRACK_ALLOCATIONS
+
+/* Memory allocation */
+
+#define ACPI_ALLOCATE(a)            acpi_ut_allocate((acpi_size) (a), ACPI_MEM_PARAMETERS)
+#define ACPI_ALLOCATE_ZEROED(a)     acpi_ut_allocate_zeroed((acpi_size) (a), ACPI_MEM_PARAMETERS)
+#define ACPI_FREE(a)                acpi_os_free(a)
+#define ACPI_MEM_TRACKING(a)
+
+#else
+
+/* Memory allocation */
+
+#define ACPI_ALLOCATE(a)            acpi_ut_allocate_and_track((acpi_size) (a), ACPI_MEM_PARAMETERS)
+#define ACPI_ALLOCATE_ZEROED(a)     acpi_ut_allocate_zeroed_and_track((acpi_size) (a), ACPI_MEM_PARAMETERS)
+#define ACPI_FREE(a)                acpi_ut_free_and_track(a, ACPI_MEM_PARAMETERS)
+#define ACPI_MEM_TRACKING(a)        a
+
+#endif				/* ACPI_DBG_TRACK_ALLOCATIONS */
+
+/*
+ * Macros used for ACPICA utilities only
+ */
+
+/* Generate a UUID */
+
+#define ACPI_INIT_UUID(a, b, c, d0, d1, d2, d3, d4, d5, d6, d7) \
+	(a) & 0xFF, ((a) >> 8) & 0xFF, ((a) >> 16) & 0xFF, ((a) >> 24) & 0xFF, \
+	(b) & 0xFF, ((b) >> 8) & 0xFF, \
+	(c) & 0xFF, ((c) >> 8) & 0xFF, \
+	(d0), (d1), (d2), (d3), (d4), (d5), (d6), (d7)
+
+#define ACPI_IS_OCTAL_DIGIT(d)              (((char)(d) >= '0') && ((char)(d) <= '7'))
+
+#endif				/* ACMACROS_H */
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acnamesp.h b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acnamesp.h
new file mode 100644
index 00000000..4cc8d17f
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acnamesp.h
@@ -0,0 +1,356 @@
+/******************************************************************************
+ *
+ * Name: acnamesp.h - Namespace subcomponent prototypes and defines
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACNAMESP_H__
+#define __ACNAMESP_H__
+
+/* To search the entire name space, pass this as search_base */
+
+#define ACPI_NS_ALL                 ((acpi_handle)0)
+
+/*
+ * Elements of acpi_ns_properties are bit significant
+ * and should be one-to-one with values of acpi_object_type
+ */
+#define ACPI_NS_NORMAL              0
+#define ACPI_NS_NEWSCOPE            1	/* a definition of this type opens a name scope */
+#define ACPI_NS_LOCAL               2	/* suppress search of enclosing scopes */
+
+/* Flags for acpi_ns_lookup, acpi_ns_search_and_enter */
+
+#define ACPI_NS_NO_UPSEARCH         0
+#define ACPI_NS_SEARCH_PARENT       0x01
+#define ACPI_NS_DONT_OPEN_SCOPE     0x02
+#define ACPI_NS_NO_PEER_SEARCH      0x04
+#define ACPI_NS_ERROR_IF_FOUND      0x08
+#define ACPI_NS_PREFIX_IS_SCOPE     0x10
+#define ACPI_NS_EXTERNAL            0x20
+#define ACPI_NS_TEMPORARY           0x40
+
+/* Flags for acpi_ns_walk_namespace */
+
+#define ACPI_NS_WALK_NO_UNLOCK      0
+#define ACPI_NS_WALK_UNLOCK         0x01
+#define ACPI_NS_WALK_TEMP_NODES     0x02
+
+/* Object is not a package element */
+
+#define ACPI_NOT_PACKAGE_ELEMENT    ACPI_UINT32_MAX
+
+/* Always emit warning message, not dependent on node flags */
+
+#define ACPI_WARN_ALWAYS            0
+
+/*
+ * nsinit - Namespace initialization
+ */
+acpi_status acpi_ns_initialize_objects(void);
+
+acpi_status acpi_ns_initialize_devices(void);
+
+/*
+ * nsload -  Namespace loading
+ */
+acpi_status acpi_ns_load_namespace(void);
+
+acpi_status
+acpi_ns_load_table(u32 table_index, struct acpi_namespace_node *node);
+
+/*
+ * nswalk - walk the namespace
+ */
+acpi_status
+acpi_ns_walk_namespace(acpi_object_type type,
+		       acpi_handle start_object,
+		       u32 max_depth,
+		       u32 flags,
+		       acpi_walk_callback pre_order_visit,
+		       acpi_walk_callback post_order_visit,
+		       void *context, void **return_value);
+
+struct acpi_namespace_node *acpi_ns_get_next_node(struct acpi_namespace_node
+						  *parent,
+						  struct acpi_namespace_node
+						  *child);
+
+struct acpi_namespace_node *acpi_ns_get_next_node_typed(acpi_object_type type,
+							struct
+							acpi_namespace_node
+							*parent,
+							struct
+							acpi_namespace_node
+							*child);
+
+/*
+ * nsparse - table parsing
+ */
+acpi_status
+acpi_ns_parse_table(u32 table_index, struct acpi_namespace_node *start_node);
+
+acpi_status
+acpi_ns_one_complete_parse(u32 pass_number,
+			   u32 table_index,
+			   struct acpi_namespace_node *start_node);
+
+/*
+ * nsaccess - Top-level namespace access
+ */
+acpi_status acpi_ns_root_initialize(void);
+
+acpi_status
+acpi_ns_lookup(union acpi_generic_state *scope_info,
+	       char *name,
+	       acpi_object_type type,
+	       acpi_interpreter_mode interpreter_mode,
+	       u32 flags,
+	       struct acpi_walk_state *walk_state,
+	       struct acpi_namespace_node **ret_node);
+
+/*
+ * nsalloc - Named object allocation/deallocation
+ */
+struct acpi_namespace_node *acpi_ns_create_node(u32 name);
+
+void acpi_ns_delete_node(struct acpi_namespace_node *node);
+
+void acpi_ns_remove_node(struct acpi_namespace_node *node);
+
+void
+acpi_ns_delete_namespace_subtree(struct acpi_namespace_node *parent_handle);
+
+void acpi_ns_delete_namespace_by_owner(acpi_owner_id owner_id);
+
+void acpi_ns_detach_object(struct acpi_namespace_node *node);
+
+void acpi_ns_delete_children(struct acpi_namespace_node *parent);
+
+int acpi_ns_compare_names(char *name1, char *name2);
+
+/*
+ * nsdump - Namespace dump/print utilities
+ */
+void acpi_ns_dump_tables(acpi_handle search_base, u32 max_depth);
+
+void acpi_ns_dump_entry(acpi_handle handle, u32 debug_level);
+
+void
+acpi_ns_dump_pathname(acpi_handle handle, char *msg, u32 level, u32 component);
+
+void acpi_ns_print_pathname(u32 num_segments, char *pathname);
+
+acpi_status
+acpi_ns_dump_one_object(acpi_handle obj_handle,
+			u32 level, void *context, void **return_value);
+
+void
+acpi_ns_dump_objects(acpi_object_type type,
+		     u8 display_type,
+		     u32 max_depth,
+		     acpi_owner_id owner_id, acpi_handle start_handle);
+
+/*
+ * nseval - Namespace evaluation functions
+ */
+acpi_status acpi_ns_evaluate(struct acpi_evaluate_info *info);
+
+void acpi_ns_exec_module_code_list(void);
+
+/*
+ * nspredef - Support for predefined/reserved names
+ */
+acpi_status
+acpi_ns_check_predefined_names(struct acpi_namespace_node *node,
+			       u32 user_param_count,
+			       acpi_status return_status,
+			       union acpi_operand_object **return_object);
+
+const union acpi_predefined_info *acpi_ns_check_for_predefined_name(struct
+								    acpi_namespace_node
+								    *node);
+
+void
+acpi_ns_check_parameter_count(char *pathname,
+			      struct acpi_namespace_node *node,
+			      u32 user_param_count,
+			      const union acpi_predefined_info *info);
+
+/*
+ * nsnames - Name and Scope manipulation
+ */
+u32 acpi_ns_opens_scope(acpi_object_type type);
+
+acpi_status
+acpi_ns_build_external_path(struct acpi_namespace_node *node,
+			    acpi_size size, char *name_buffer);
+
+char *acpi_ns_get_external_pathname(struct acpi_namespace_node *node);
+
+char *acpi_ns_name_of_current_scope(struct acpi_walk_state *walk_state);
+
+acpi_status
+acpi_ns_handle_to_pathname(acpi_handle target_handle,
+			   struct acpi_buffer *buffer);
+
+u8
+acpi_ns_pattern_match(struct acpi_namespace_node *obj_node, char *search_for);
+
+acpi_status
+acpi_ns_get_node(struct acpi_namespace_node *prefix_node,
+		 const char *external_pathname,
+		 u32 flags, struct acpi_namespace_node **out_node);
+
+acpi_size acpi_ns_get_pathname_length(struct acpi_namespace_node *node);
+
+/*
+ * nsobject - Object management for namespace nodes
+ */
+acpi_status
+acpi_ns_attach_object(struct acpi_namespace_node *node,
+		      union acpi_operand_object *object, acpi_object_type type);
+
+union acpi_operand_object *acpi_ns_get_attached_object(struct
+						       acpi_namespace_node
+						       *node);
+
+union acpi_operand_object *acpi_ns_get_secondary_object(union
+							acpi_operand_object
+							*obj_desc);
+
+acpi_status
+acpi_ns_attach_data(struct acpi_namespace_node *node,
+		    acpi_object_handler handler, void *data);
+
+acpi_status
+acpi_ns_detach_data(struct acpi_namespace_node *node,
+		    acpi_object_handler handler);
+
+acpi_status
+acpi_ns_get_attached_data(struct acpi_namespace_node *node,
+			  acpi_object_handler handler, void **data);
+
+/*
+ * nsrepair - General return object repair for all
+ * predefined methods/objects
+ */
+acpi_status
+acpi_ns_repair_object(struct acpi_predefined_data *data,
+		      u32 expected_btypes,
+		      u32 package_index,
+		      union acpi_operand_object **return_object_ptr);
+
+acpi_status
+acpi_ns_repair_package_list(struct acpi_predefined_data *data,
+			    union acpi_operand_object **obj_desc_ptr);
+
+acpi_status
+acpi_ns_repair_null_element(struct acpi_predefined_data *data,
+			    u32 expected_btypes,
+			    u32 package_index,
+			    union acpi_operand_object **return_object_ptr);
+
+void
+acpi_ns_remove_null_elements(struct acpi_predefined_data *data,
+			     u8 package_type,
+			     union acpi_operand_object *obj_desc);
+
+/*
+ * nsrepair2 - Return object repair for specific
+ * predefined methods/objects
+ */
+acpi_status
+acpi_ns_complex_repairs(struct acpi_predefined_data *data,
+			struct acpi_namespace_node *node,
+			acpi_status validate_status,
+			union acpi_operand_object **return_object_ptr);
+
+/*
+ * nssearch - Namespace searching and entry
+ */
+acpi_status
+acpi_ns_search_and_enter(u32 entry_name,
+			 struct acpi_walk_state *walk_state,
+			 struct acpi_namespace_node *node,
+			 acpi_interpreter_mode interpreter_mode,
+			 acpi_object_type type,
+			 u32 flags, struct acpi_namespace_node **ret_node);
+
+acpi_status
+acpi_ns_search_one_scope(u32 entry_name,
+			 struct acpi_namespace_node *node,
+			 acpi_object_type type,
+			 struct acpi_namespace_node **ret_node);
+
+void
+acpi_ns_install_node(struct acpi_walk_state *walk_state,
+		     struct acpi_namespace_node *parent_node,
+		     struct acpi_namespace_node *node, acpi_object_type type);
+
+/*
+ * nsutils - Utility functions
+ */
+u8 acpi_ns_valid_root_prefix(char prefix);
+
+acpi_object_type acpi_ns_get_type(struct acpi_namespace_node *node);
+
+u32 acpi_ns_local(acpi_object_type type);
+
+void
+acpi_ns_print_node_pathname(struct acpi_namespace_node *node, const char *msg);
+
+acpi_status acpi_ns_build_internal_name(struct acpi_namestring_info *info);
+
+void acpi_ns_get_internal_name_length(struct acpi_namestring_info *info);
+
+acpi_status
+acpi_ns_internalize_name(const char *dotted_name, char **converted_name);
+
+acpi_status
+acpi_ns_externalize_name(u32 internal_name_length,
+			 const char *internal_name,
+			 u32 *converted_name_length, char **converted_name);
+
+struct acpi_namespace_node *acpi_ns_validate_handle(acpi_handle handle);
+
+void acpi_ns_terminate(void);
+
+#endif				/* __ACNAMESP_H__ */
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acobject.h b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acobject.h
new file mode 100644
index 00000000..2fa6841d
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acobject.h
@@ -0,0 +1,460 @@
+
+/******************************************************************************
+ *
+ * Name: acobject.h - Definition of union acpi_operand_object  (Internal object only)
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef _ACOBJECT_H
+#define _ACOBJECT_H
+
+/* acpisrc:struct_defs -- for acpisrc conversion */
+
+/*
+ * The union acpi_operand_object is used to pass AML operands from the dispatcher
+ * to the interpreter, and to keep track of the various handlers such as
+ * address space handlers and notify handlers. The object is a constant
+ * size in order to allow it to be cached and reused.
+ *
+ * Note: The object is optimized to be aligned and will not work if it is
+ * byte-packed.
+ */
+#if ACPI_MACHINE_WIDTH == 64
+#pragma pack(8)
+#else
+#pragma pack(4)
+#endif
+
+/*******************************************************************************
+ *
+ * Common Descriptors
+ *
+ ******************************************************************************/
+
+/*
+ * Common area for all objects.
+ *
+ * descriptor_type is used to differentiate between internal descriptors, and
+ * must be in the same place across all descriptors
+ *
+ * Note: The descriptor_type and Type fields must appear in the identical
+ * position in both the struct acpi_namespace_node and union acpi_operand_object
+ * structures.
+ */
+#define ACPI_OBJECT_COMMON_HEADER \
+	union acpi_operand_object       *next_object;       /* Objects linked to parent NS node */\
+	u8                              descriptor_type;    /* To differentiate various internal objs */\
+	u8                              type;               /* acpi_object_type */\
+	u16                             reference_count;    /* For object deletion management */\
+	u8                              flags;
+	/*
+	 * Note: There are 3 bytes available here before the
+	 * next natural alignment boundary (for both 32/64 cases)
+	 */
+
+/* Values for Flag byte above */
+
+#define AOPOBJ_AML_CONSTANT         0x01	/* Integer is an AML constant */
+#define AOPOBJ_STATIC_POINTER       0x02	/* Data is part of an ACPI table, don't delete */
+#define AOPOBJ_DATA_VALID           0x04	/* Object is intialized and data is valid */
+#define AOPOBJ_OBJECT_INITIALIZED   0x08	/* Region is initialized, _REG was run */
+#define AOPOBJ_SETUP_COMPLETE       0x10	/* Region setup is complete */
+#define AOPOBJ_INVALID              0x20	/* Host OS won't allow a Region address */
+
+/******************************************************************************
+ *
+ * Basic data types
+ *
+ *****************************************************************************/
+
+struct acpi_object_common {
+ACPI_OBJECT_COMMON_HEADER};
+
+struct acpi_object_integer {
+	ACPI_OBJECT_COMMON_HEADER u8 fill[3];	/* Prevent warning on some compilers */
+	u64 value;
+};
+
+/*
+ * Note: The String and Buffer object must be identical through the Pointer
+ * and length elements.  There is code that depends on this.
+ *
+ * Fields common to both Strings and Buffers
+ */
+#define ACPI_COMMON_BUFFER_INFO(_type) \
+	_type                           *pointer; \
+	u32                             length;
+
+struct acpi_object_string {	/* Null terminated, ASCII characters only */
+	ACPI_OBJECT_COMMON_HEADER ACPI_COMMON_BUFFER_INFO(char)	/* String in AML stream or allocated string */
+};
+
+struct acpi_object_buffer {
+	ACPI_OBJECT_COMMON_HEADER ACPI_COMMON_BUFFER_INFO(u8)	/* Buffer in AML stream or allocated buffer */
+	u32 aml_length;
+	u8 *aml_start;
+	struct acpi_namespace_node *node;	/* Link back to parent node */
+};
+
+struct acpi_object_package {
+	ACPI_OBJECT_COMMON_HEADER struct acpi_namespace_node *node;	/* Link back to parent node */
+	union acpi_operand_object **elements;	/* Array of pointers to acpi_objects */
+	u8 *aml_start;
+	u32 aml_length;
+	u32 count;		/* # of elements in package */
+};
+
+/******************************************************************************
+ *
+ * Complex data types
+ *
+ *****************************************************************************/
+
+struct acpi_object_event {
+	ACPI_OBJECT_COMMON_HEADER acpi_semaphore os_semaphore;	/* Actual OS synchronization object */
+};
+
+struct acpi_object_mutex {
+	ACPI_OBJECT_COMMON_HEADER u8 sync_level;	/* 0-15, specified in Mutex() call */
+	u16 acquisition_depth;	/* Allow multiple Acquires, same thread */
+	acpi_mutex os_mutex;	/* Actual OS synchronization object */
+	acpi_thread_id thread_id;	/* Current owner of the mutex */
+	struct acpi_thread_state *owner_thread;	/* Current owner of the mutex */
+	union acpi_operand_object *prev;	/* Link for list of acquired mutexes */
+	union acpi_operand_object *next;	/* Link for list of acquired mutexes */
+	struct acpi_namespace_node *node;	/* Containing namespace node */
+	u8 original_sync_level;	/* Owner's original sync level (0-15) */
+};
+
+struct acpi_object_region {
+	ACPI_OBJECT_COMMON_HEADER u8 space_id;
+	struct acpi_namespace_node *node;	/* Containing namespace node */
+	union acpi_operand_object *handler;	/* Handler for region access */
+	union acpi_operand_object *next;
+	acpi_physical_address address;
+	u32 length;
+};
+
+struct acpi_object_method {
+	ACPI_OBJECT_COMMON_HEADER u8 info_flags;
+	u8 param_count;
+	u8 sync_level;
+	union acpi_operand_object *mutex;
+	u8 *aml_start;
+	union {
+		acpi_internal_method implementation;
+		union acpi_operand_object *handler;
+	} dispatch;
+
+	u32 aml_length;
+	u8 thread_count;
+	acpi_owner_id owner_id;
+};
+
+/* Flags for info_flags field above */
+
+#define ACPI_METHOD_MODULE_LEVEL        0x01	/* Method is actually module-level code */
+#define ACPI_METHOD_INTERNAL_ONLY       0x02	/* Method is implemented internally (_OSI) */
+#define ACPI_METHOD_SERIALIZED          0x04	/* Method is serialized */
+#define ACPI_METHOD_SERIALIZED_PENDING  0x08	/* Method is to be marked serialized */
+#define ACPI_METHOD_MODIFIED_NAMESPACE  0x10	/* Method modified the namespace */
+
+/******************************************************************************
+ *
+ * Objects that can be notified.  All share a common notify_info area.
+ *
+ *****************************************************************************/
+
+/*
+ * Common fields for objects that support ASL notifications
+ */
+#define ACPI_COMMON_NOTIFY_INFO \
+	union acpi_operand_object       *system_notify;     /* Handler for system notifies */\
+	union acpi_operand_object       *device_notify;     /* Handler for driver notifies */\
+	union acpi_operand_object       *handler;	/* Handler for Address space */
+
+struct acpi_object_notify_common {	/* COMMON NOTIFY for POWER, PROCESSOR, DEVICE, and THERMAL */
+ACPI_OBJECT_COMMON_HEADER ACPI_COMMON_NOTIFY_INFO};
+
+struct acpi_object_device {
+	ACPI_OBJECT_COMMON_HEADER
+	    ACPI_COMMON_NOTIFY_INFO struct acpi_gpe_block_info *gpe_block;
+};
+
+struct acpi_object_power_resource {
+	ACPI_OBJECT_COMMON_HEADER ACPI_COMMON_NOTIFY_INFO u32 system_level;
+	u32 resource_order;
+};
+
+struct acpi_object_processor {
+	ACPI_OBJECT_COMMON_HEADER
+	    /* The next two fields take advantage of the 3-byte space before NOTIFY_INFO */
+	u8 proc_id;
+	u8 length;
+	 ACPI_COMMON_NOTIFY_INFO acpi_io_address address;
+};
+
+struct acpi_object_thermal_zone {
+ACPI_OBJECT_COMMON_HEADER ACPI_COMMON_NOTIFY_INFO};
+
+/******************************************************************************
+ *
+ * Fields.  All share a common header/info field.
+ *
+ *****************************************************************************/
+
+/*
+ * Common bitfield for the field objects
+ * "Field Datum"  -- a datum from the actual field object
+ * "Buffer Datum" -- a datum from a user buffer, read from or to be written to the field
+ */
+#define ACPI_COMMON_FIELD_INFO \
+	u8                              field_flags;        /* Access, update, and lock bits */\
+	u8                              attribute;          /* From access_as keyword */\
+	u8                              access_byte_width;  /* Read/Write size in bytes */\
+	struct acpi_namespace_node      *node;              /* Link back to parent node */\
+	u32                             bit_length;         /* Length of field in bits */\
+	u32                             base_byte_offset;   /* Byte offset within containing object */\
+	u32                             value;              /* Value to store into the Bank or Index register */\
+	u8                              start_field_bit_offset;/* Bit offset within first field datum (0-63) */\
+	u8                              access_length;	/* For serial regions/fields */
+
+struct acpi_object_field_common {	/* COMMON FIELD (for BUFFER, REGION, BANK, and INDEX fields) */
+	ACPI_OBJECT_COMMON_HEADER ACPI_COMMON_FIELD_INFO union acpi_operand_object *region_obj;	/* Parent Operation Region object (REGION/BANK fields only) */
+};
+
+struct acpi_object_region_field {
+	ACPI_OBJECT_COMMON_HEADER ACPI_COMMON_FIELD_INFO u16 resource_length;
+	union acpi_operand_object *region_obj;	/* Containing op_region object */
+	u8 *resource_buffer;	/* resource_template for serial regions/fields */
+};
+
+struct acpi_object_bank_field {
+	ACPI_OBJECT_COMMON_HEADER ACPI_COMMON_FIELD_INFO union acpi_operand_object *region_obj;	/* Containing op_region object */
+	union acpi_operand_object *bank_obj;	/* bank_select Register object */
+};
+
+struct acpi_object_index_field {
+	ACPI_OBJECT_COMMON_HEADER ACPI_COMMON_FIELD_INFO
+	    /*
+	     * No "RegionObj" pointer needed since the Index and Data registers
+	     * are each field definitions unto themselves.
+	     */
+	union acpi_operand_object *index_obj;	/* Index register */
+	union acpi_operand_object *data_obj;	/* Data register */
+};
+
+/* The buffer_field is different in that it is part of a Buffer, not an op_region */
+
+struct acpi_object_buffer_field {
+	ACPI_OBJECT_COMMON_HEADER ACPI_COMMON_FIELD_INFO union acpi_operand_object *buffer_obj;	/* Containing Buffer object */
+};
+
+/******************************************************************************
+ *
+ * Objects for handlers
+ *
+ *****************************************************************************/
+
+struct acpi_object_notify_handler {
+	ACPI_OBJECT_COMMON_HEADER struct acpi_namespace_node *node;	/* Parent device */
+	acpi_notify_handler handler;
+	void *context;
+};
+
+struct acpi_object_addr_handler {
+	ACPI_OBJECT_COMMON_HEADER u8 space_id;
+	u8 handler_flags;
+	acpi_adr_space_handler handler;
+	struct acpi_namespace_node *node;	/* Parent device */
+	void *context;
+	acpi_adr_space_setup setup;
+	union acpi_operand_object *region_list;	/* regions using this handler */
+	union acpi_operand_object *next;
+};
+
+/* Flags for address handler (handler_flags) */
+
+#define ACPI_ADDR_HANDLER_DEFAULT_INSTALLED  0x01
+
+/******************************************************************************
+ *
+ * Special internal objects
+ *
+ *****************************************************************************/
+
+/*
+ * The Reference object is used for these opcodes:
+ * Arg[0-6], Local[0-7], index_op, name_op, ref_of_op, load_op, load_table_op, debug_op
+ * The Reference.Class differentiates these types.
+ */
+struct acpi_object_reference {
+	ACPI_OBJECT_COMMON_HEADER u8 class;	/* Reference Class */
+	u8 target_type;		/* Used for Index Op */
+	u8 reserved;
+	void *object;		/* name_op=>HANDLE to obj, index_op=>union acpi_operand_object */
+	struct acpi_namespace_node *node;	/* ref_of or Namepath */
+	union acpi_operand_object **where;	/* Target of Index */
+	u32 value;		/* Used for Local/Arg/Index/ddb_handle */
+};
+
+/* Values for Reference.Class above */
+
+typedef enum {
+	ACPI_REFCLASS_LOCAL = 0,	/* Method local */
+	ACPI_REFCLASS_ARG = 1,	/* Method argument */
+	ACPI_REFCLASS_REFOF = 2,	/* Result of ref_of() TBD: Split to Ref/Node and Ref/operand_obj? */
+	ACPI_REFCLASS_INDEX = 3,	/* Result of Index() */
+	ACPI_REFCLASS_TABLE = 4,	/* ddb_handle - Load(), load_table() */
+	ACPI_REFCLASS_NAME = 5,	/* Reference to a named object */
+	ACPI_REFCLASS_DEBUG = 6,	/* Debug object */
+
+	ACPI_REFCLASS_MAX = 6
+} ACPI_REFERENCE_CLASSES;
+
+/*
+ * Extra object is used as additional storage for types that
+ * have AML code in their declarations (term_args) that must be
+ * evaluated at run time.
+ *
+ * Currently: Region and field_unit types
+ */
+struct acpi_object_extra {
+	ACPI_OBJECT_COMMON_HEADER struct acpi_namespace_node *method_REG;	/* _REG method for this region (if any) */
+	struct acpi_namespace_node *scope_node;
+	void *region_context;	/* Region-specific data */
+	u8 *aml_start;
+	u32 aml_length;
+};
+
+/* Additional data that can be attached to namespace nodes */
+
+struct acpi_object_data {
+	ACPI_OBJECT_COMMON_HEADER acpi_object_handler handler;
+	void *pointer;
+};
+
+/* Structure used when objects are cached for reuse */
+
+struct acpi_object_cache_list {
+	ACPI_OBJECT_COMMON_HEADER union acpi_operand_object *next;	/* Link for object cache and internal lists */
+};
+
+/******************************************************************************
+ *
+ * union acpi_operand_object Descriptor - a giant union of all of the above
+ *
+ *****************************************************************************/
+
+union acpi_operand_object {
+	struct acpi_object_common common;
+	struct acpi_object_integer integer;
+	struct acpi_object_string string;
+	struct acpi_object_buffer buffer;
+	struct acpi_object_package package;
+	struct acpi_object_event event;
+	struct acpi_object_method method;
+	struct acpi_object_mutex mutex;
+	struct acpi_object_region region;
+	struct acpi_object_notify_common common_notify;
+	struct acpi_object_device device;
+	struct acpi_object_power_resource power_resource;
+	struct acpi_object_processor processor;
+	struct acpi_object_thermal_zone thermal_zone;
+	struct acpi_object_field_common common_field;
+	struct acpi_object_region_field field;
+	struct acpi_object_buffer_field buffer_field;
+	struct acpi_object_bank_field bank_field;
+	struct acpi_object_index_field index_field;
+	struct acpi_object_notify_handler notify;
+	struct acpi_object_addr_handler address_space;
+	struct acpi_object_reference reference;
+	struct acpi_object_extra extra;
+	struct acpi_object_data data;
+	struct acpi_object_cache_list cache;
+
+	/*
+	 * Add namespace node to union in order to simplify code that accepts both
+	 * ACPI_OPERAND_OBJECTs and ACPI_NAMESPACE_NODEs. The structures share
+	 * a common descriptor_type field in order to differentiate them.
+	 */
+	struct acpi_namespace_node node;
+};
+
+/******************************************************************************
+ *
+ * union acpi_descriptor - objects that share a common descriptor identifier
+ *
+ *****************************************************************************/
+
+/* Object descriptor types */
+
+#define ACPI_DESC_TYPE_CACHED           0x01	/* Used only when object is cached */
+#define ACPI_DESC_TYPE_STATE            0x02
+#define ACPI_DESC_TYPE_STATE_UPDATE     0x03
+#define ACPI_DESC_TYPE_STATE_PACKAGE    0x04
+#define ACPI_DESC_TYPE_STATE_CONTROL    0x05
+#define ACPI_DESC_TYPE_STATE_RPSCOPE    0x06
+#define ACPI_DESC_TYPE_STATE_PSCOPE     0x07
+#define ACPI_DESC_TYPE_STATE_WSCOPE     0x08
+#define ACPI_DESC_TYPE_STATE_RESULT     0x09
+#define ACPI_DESC_TYPE_STATE_NOTIFY     0x0A
+#define ACPI_DESC_TYPE_STATE_THREAD     0x0B
+#define ACPI_DESC_TYPE_WALK             0x0C
+#define ACPI_DESC_TYPE_PARSER           0x0D
+#define ACPI_DESC_TYPE_OPERAND          0x0E
+#define ACPI_DESC_TYPE_NAMED            0x0F
+#define ACPI_DESC_TYPE_MAX              0x0F
+
+struct acpi_common_descriptor {
+	void *common_pointer;
+	u8 descriptor_type;	/* To differentiate various internal objs */
+};
+
+union acpi_descriptor {
+	struct acpi_common_descriptor common;
+	union acpi_operand_object object;
+	struct acpi_namespace_node node;
+	union acpi_parse_object op;
+};
+
+#pragma pack()
+
+#endif				/* _ACOBJECT_H */
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acopcode.h b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acopcode.h
new file mode 100644
index 00000000..9440d053
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acopcode.h
@@ -0,0 +1,327 @@
+/******************************************************************************
+ *
+ * Name: acopcode.h - AML opcode information for the AML parser and interpreter
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACOPCODE_H__
+#define __ACOPCODE_H__
+
+#define MAX_EXTENDED_OPCODE         0x88
+#define NUM_EXTENDED_OPCODE         (MAX_EXTENDED_OPCODE + 1)
+#define MAX_INTERNAL_OPCODE
+#define NUM_INTERNAL_OPCODE         (MAX_INTERNAL_OPCODE + 1)
+
+/* Used for non-assigned opcodes */
+
+#define _UNK                        0x6B
+
+/*
+ * Reserved ASCII characters.  Do not use any of these for
+ * internal opcodes, since they are used to differentiate
+ * name strings from AML opcodes
+ */
+#define _ASC                        0x6C
+#define _NAM                        0x6C
+#define _PFX                        0x6D
+
+/*
+ * All AML opcodes and the parse-time arguments for each.  Used by the AML
+ * parser  Each list is compressed into a 32-bit number and stored in the
+ * master opcode table (in psopcode.c).
+ */
+#define ARGP_ACCESSFIELD_OP             ARGP_LIST1 (ARGP_NAMESTRING)
+#define ARGP_ACQUIRE_OP                 ARGP_LIST2 (ARGP_SUPERNAME,  ARGP_WORDDATA)
+#define ARGP_ADD_OP                     ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
+#define ARGP_ALIAS_OP                   ARGP_LIST2 (ARGP_NAMESTRING, ARGP_NAME)
+#define ARGP_ARG0                       ARG_NONE
+#define ARGP_ARG1                       ARG_NONE
+#define ARGP_ARG2                       ARG_NONE
+#define ARGP_ARG3                       ARG_NONE
+#define ARGP_ARG4                       ARG_NONE
+#define ARGP_ARG5                       ARG_NONE
+#define ARGP_ARG6                       ARG_NONE
+#define ARGP_BANK_FIELD_OP              ARGP_LIST6 (ARGP_PKGLENGTH,  ARGP_NAMESTRING,    ARGP_NAMESTRING,ARGP_TERMARG,   ARGP_BYTEDATA,  ARGP_FIELDLIST)
+#define ARGP_BIT_AND_OP                 ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
+#define ARGP_BIT_NAND_OP                ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
+#define ARGP_BIT_NOR_OP                 ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
+#define ARGP_BIT_NOT_OP                 ARGP_LIST2 (ARGP_TERMARG,    ARGP_TARGET)
+#define ARGP_BIT_OR_OP                  ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
+#define ARGP_BIT_XOR_OP                 ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
+#define ARGP_BREAK_OP                   ARG_NONE
+#define ARGP_BREAK_POINT_OP             ARG_NONE
+#define ARGP_BUFFER_OP                  ARGP_LIST3 (ARGP_PKGLENGTH,  ARGP_TERMARG,       ARGP_BYTELIST)
+#define ARGP_BYTE_OP                    ARGP_LIST1 (ARGP_BYTEDATA)
+#define ARGP_BYTELIST_OP                ARGP_LIST1 (ARGP_NAMESTRING)
+#define ARGP_CONCAT_OP                  ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
+#define ARGP_CONCAT_RES_OP              ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
+#define ARGP_COND_REF_OF_OP             ARGP_LIST2 (ARGP_SUPERNAME,  ARGP_SUPERNAME)
+#define ARGP_CONNECTFIELD_OP            ARGP_LIST1 (ARGP_NAMESTRING)
+#define ARGP_CONTINUE_OP                ARG_NONE
+#define ARGP_COPY_OP                    ARGP_LIST2 (ARGP_TERMARG,    ARGP_SIMPLENAME)
+#define ARGP_CREATE_BIT_FIELD_OP        ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_NAME)
+#define ARGP_CREATE_BYTE_FIELD_OP       ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_NAME)
+#define ARGP_CREATE_DWORD_FIELD_OP      ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_NAME)
+#define ARGP_CREATE_FIELD_OP            ARGP_LIST4 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TERMARG,   ARGP_NAME)
+#define ARGP_CREATE_QWORD_FIELD_OP      ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_NAME)
+#define ARGP_CREATE_WORD_FIELD_OP       ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_NAME)
+#define ARGP_DATA_REGION_OP             ARGP_LIST4 (ARGP_NAME,       ARGP_TERMARG,       ARGP_TERMARG,   ARGP_TERMARG)
+#define ARGP_DEBUG_OP                   ARG_NONE
+#define ARGP_DECREMENT_OP               ARGP_LIST1 (ARGP_SUPERNAME)
+#define ARGP_DEREF_OF_OP                ARGP_LIST1 (ARGP_TERMARG)
+#define ARGP_DEVICE_OP                  ARGP_LIST3 (ARGP_PKGLENGTH,  ARGP_NAME,          ARGP_OBJLIST)
+#define ARGP_DIVIDE_OP                  ARGP_LIST4 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET,    ARGP_TARGET)
+#define ARGP_DWORD_OP                   ARGP_LIST1 (ARGP_DWORDDATA)
+#define ARGP_ELSE_OP                    ARGP_LIST2 (ARGP_PKGLENGTH,  ARGP_TERMLIST)
+#define ARGP_EVENT_OP                   ARGP_LIST1 (ARGP_NAME)
+#define ARGP_FATAL_OP                   ARGP_LIST3 (ARGP_BYTEDATA,   ARGP_DWORDDATA,     ARGP_TERMARG)
+#define ARGP_FIELD_OP                   ARGP_LIST4 (ARGP_PKGLENGTH,  ARGP_NAMESTRING,    ARGP_BYTEDATA,  ARGP_FIELDLIST)
+#define ARGP_FIND_SET_LEFT_BIT_OP       ARGP_LIST2 (ARGP_TERMARG,    ARGP_TARGET)
+#define ARGP_FIND_SET_RIGHT_BIT_OP      ARGP_LIST2 (ARGP_TERMARG,    ARGP_TARGET)
+#define ARGP_FROM_BCD_OP                ARGP_LIST2 (ARGP_TERMARG,    ARGP_TARGET)
+#define ARGP_IF_OP                      ARGP_LIST3 (ARGP_PKGLENGTH,  ARGP_TERMARG,       ARGP_TERMLIST)
+#define ARGP_INCREMENT_OP               ARGP_LIST1 (ARGP_SUPERNAME)
+#define ARGP_INDEX_FIELD_OP             ARGP_LIST5 (ARGP_PKGLENGTH,  ARGP_NAMESTRING,    ARGP_NAMESTRING,ARGP_BYTEDATA,  ARGP_FIELDLIST)
+#define ARGP_INDEX_OP                   ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
+#define ARGP_LAND_OP                    ARGP_LIST2 (ARGP_TERMARG,    ARGP_TERMARG)
+#define ARGP_LEQUAL_OP                  ARGP_LIST2 (ARGP_TERMARG,    ARGP_TERMARG)
+#define ARGP_LGREATER_OP                ARGP_LIST2 (ARGP_TERMARG,    ARGP_TERMARG)
+#define ARGP_LGREATEREQUAL_OP           ARGP_LIST2 (ARGP_TERMARG,    ARGP_TERMARG)
+#define ARGP_LLESS_OP                   ARGP_LIST2 (ARGP_TERMARG,    ARGP_TERMARG)
+#define ARGP_LLESSEQUAL_OP              ARGP_LIST2 (ARGP_TERMARG,    ARGP_TERMARG)
+#define ARGP_LNOT_OP                    ARGP_LIST1 (ARGP_TERMARG)
+#define ARGP_LNOTEQUAL_OP               ARGP_LIST2 (ARGP_TERMARG,    ARGP_TERMARG)
+#define ARGP_LOAD_OP                    ARGP_LIST2 (ARGP_NAMESTRING, ARGP_SUPERNAME)
+#define ARGP_LOAD_TABLE_OP              ARGP_LIST6 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TERMARG,   ARGP_TERMARG,  ARGP_TERMARG,   ARGP_TERMARG)
+#define ARGP_LOCAL0                     ARG_NONE
+#define ARGP_LOCAL1                     ARG_NONE
+#define ARGP_LOCAL2                     ARG_NONE
+#define ARGP_LOCAL3                     ARG_NONE
+#define ARGP_LOCAL4                     ARG_NONE
+#define ARGP_LOCAL5                     ARG_NONE
+#define ARGP_LOCAL6                     ARG_NONE
+#define ARGP_LOCAL7                     ARG_NONE
+#define ARGP_LOR_OP                     ARGP_LIST2 (ARGP_TERMARG,    ARGP_TERMARG)
+#define ARGP_MATCH_OP                   ARGP_LIST6 (ARGP_TERMARG,    ARGP_BYTEDATA,      ARGP_TERMARG,   ARGP_BYTEDATA,  ARGP_TERMARG,   ARGP_TERMARG)
+#define ARGP_METHOD_OP                  ARGP_LIST4 (ARGP_PKGLENGTH,  ARGP_NAME,          ARGP_BYTEDATA,  ARGP_TERMLIST)
+#define ARGP_METHODCALL_OP              ARGP_LIST1 (ARGP_NAMESTRING)
+#define ARGP_MID_OP                     ARGP_LIST4 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TERMARG,   ARGP_TARGET)
+#define ARGP_MOD_OP                     ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
+#define ARGP_MULTIPLY_OP                ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
+#define ARGP_MUTEX_OP                   ARGP_LIST2 (ARGP_NAME,       ARGP_BYTEDATA)
+#define ARGP_NAME_OP                    ARGP_LIST2 (ARGP_NAME,       ARGP_DATAOBJ)
+#define ARGP_NAMEDFIELD_OP              ARGP_LIST1 (ARGP_NAMESTRING)
+#define ARGP_NAMEPATH_OP                ARGP_LIST1 (ARGP_NAMESTRING)
+#define ARGP_NOOP_OP                    ARG_NONE
+#define ARGP_NOTIFY_OP                  ARGP_LIST2 (ARGP_SUPERNAME,  ARGP_TERMARG)
+#define ARGP_ONE_OP                     ARG_NONE
+#define ARGP_ONES_OP                    ARG_NONE
+#define ARGP_PACKAGE_OP                 ARGP_LIST3 (ARGP_PKGLENGTH,  ARGP_BYTEDATA,      ARGP_DATAOBJLIST)
+#define ARGP_POWER_RES_OP               ARGP_LIST5 (ARGP_PKGLENGTH,  ARGP_NAME,          ARGP_BYTEDATA,  ARGP_WORDDATA,  ARGP_OBJLIST)
+#define ARGP_PROCESSOR_OP               ARGP_LIST6 (ARGP_PKGLENGTH,  ARGP_NAME,          ARGP_BYTEDATA,  ARGP_DWORDDATA, ARGP_BYTEDATA,  ARGP_OBJLIST)
+#define ARGP_QWORD_OP                   ARGP_LIST1 (ARGP_QWORDDATA)
+#define ARGP_REF_OF_OP                  ARGP_LIST1 (ARGP_SUPERNAME)
+#define ARGP_REGION_OP                  ARGP_LIST4 (ARGP_NAME,       ARGP_BYTEDATA,      ARGP_TERMARG,   ARGP_TERMARG)
+#define ARGP_RELEASE_OP                 ARGP_LIST1 (ARGP_SUPERNAME)
+#define ARGP_RESERVEDFIELD_OP           ARGP_LIST1 (ARGP_NAMESTRING)
+#define ARGP_RESET_OP                   ARGP_LIST1 (ARGP_SUPERNAME)
+#define ARGP_RETURN_OP                  ARGP_LIST1 (ARGP_TERMARG)
+#define ARGP_REVISION_OP                ARG_NONE
+#define ARGP_SCOPE_OP                   ARGP_LIST3 (ARGP_PKGLENGTH,  ARGP_NAME,          ARGP_TERMLIST)
+#define ARGP_SERIALFIELD_OP             ARGP_LIST1 (ARGP_NAMESTRING)
+#define ARGP_SHIFT_LEFT_OP              ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
+#define ARGP_SHIFT_RIGHT_OP             ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
+#define ARGP_SIGNAL_OP                  ARGP_LIST1 (ARGP_SUPERNAME)
+#define ARGP_SIZE_OF_OP                 ARGP_LIST1 (ARGP_SUPERNAME)
+#define ARGP_SLEEP_OP                   ARGP_LIST1 (ARGP_TERMARG)
+#define ARGP_STALL_OP                   ARGP_LIST1 (ARGP_TERMARG)
+#define ARGP_STATICSTRING_OP            ARGP_LIST1 (ARGP_NAMESTRING)
+#define ARGP_STORE_OP                   ARGP_LIST2 (ARGP_TERMARG,    ARGP_SUPERNAME)
+#define ARGP_STRING_OP                  ARGP_LIST1 (ARGP_CHARLIST)
+#define ARGP_SUBTRACT_OP                ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
+#define ARGP_THERMAL_ZONE_OP            ARGP_LIST3 (ARGP_PKGLENGTH,  ARGP_NAME,          ARGP_OBJLIST)
+#define ARGP_TIMER_OP                   ARG_NONE
+#define ARGP_TO_BCD_OP                  ARGP_LIST2 (ARGP_TERMARG,    ARGP_TARGET)
+#define ARGP_TO_BUFFER_OP               ARGP_LIST2 (ARGP_TERMARG,    ARGP_TARGET)
+#define ARGP_TO_DEC_STR_OP              ARGP_LIST2 (ARGP_TERMARG,    ARGP_TARGET)
+#define ARGP_TO_HEX_STR_OP              ARGP_LIST2 (ARGP_TERMARG,    ARGP_TARGET)
+#define ARGP_TO_INTEGER_OP              ARGP_LIST2 (ARGP_TERMARG,    ARGP_TARGET)
+#define ARGP_TO_STRING_OP               ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
+#define ARGP_TYPE_OP                    ARGP_LIST1 (ARGP_SUPERNAME)
+#define ARGP_UNLOAD_OP                  ARGP_LIST1 (ARGP_SUPERNAME)
+#define ARGP_VAR_PACKAGE_OP             ARGP_LIST3 (ARGP_PKGLENGTH,  ARGP_TERMARG,       ARGP_DATAOBJLIST)
+#define ARGP_WAIT_OP                    ARGP_LIST2 (ARGP_SUPERNAME,  ARGP_TERMARG)
+#define ARGP_WHILE_OP                   ARGP_LIST3 (ARGP_PKGLENGTH,  ARGP_TERMARG,       ARGP_TERMLIST)
+#define ARGP_WORD_OP                    ARGP_LIST1 (ARGP_WORDDATA)
+#define ARGP_ZERO_OP                    ARG_NONE
+
+/*
+ * All AML opcodes and the runtime arguments for each.  Used by the AML
+ * interpreter  Each list is compressed into a 32-bit number and stored
+ * in the master opcode table (in psopcode.c).
+ *
+ * (Used by prep_operands procedure and the ASL Compiler)
+ */
+#define ARGI_ACCESSFIELD_OP             ARGI_INVALID_OPCODE
+#define ARGI_ACQUIRE_OP                 ARGI_LIST2 (ARGI_MUTEX,      ARGI_INTEGER)
+#define ARGI_ADD_OP                     ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
+#define ARGI_ALIAS_OP                   ARGI_INVALID_OPCODE
+#define ARGI_ARG0                       ARG_NONE
+#define ARGI_ARG1                       ARG_NONE
+#define ARGI_ARG2                       ARG_NONE
+#define ARGI_ARG3                       ARG_NONE
+#define ARGI_ARG4                       ARG_NONE
+#define ARGI_ARG5                       ARG_NONE
+#define ARGI_ARG6                       ARG_NONE
+#define ARGI_BANK_FIELD_OP              ARGI_INVALID_OPCODE
+#define ARGI_BIT_AND_OP                 ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
+#define ARGI_BIT_NAND_OP                ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
+#define ARGI_BIT_NOR_OP                 ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
+#define ARGI_BIT_NOT_OP                 ARGI_LIST2 (ARGI_INTEGER,    ARGI_TARGETREF)
+#define ARGI_BIT_OR_OP                  ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
+#define ARGI_BIT_XOR_OP                 ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
+#define ARGI_BREAK_OP                   ARG_NONE
+#define ARGI_BREAK_POINT_OP             ARG_NONE
+#define ARGI_BUFFER_OP                  ARGI_LIST1 (ARGI_INTEGER)
+#define ARGI_BYTE_OP                    ARGI_INVALID_OPCODE
+#define ARGI_BYTELIST_OP                ARGI_INVALID_OPCODE
+#define ARGI_CONCAT_OP                  ARGI_LIST3 (ARGI_COMPUTEDATA,ARGI_COMPUTEDATA,   ARGI_TARGETREF)
+#define ARGI_CONCAT_RES_OP              ARGI_LIST3 (ARGI_BUFFER,     ARGI_BUFFER,        ARGI_TARGETREF)
+#define ARGI_COND_REF_OF_OP             ARGI_LIST2 (ARGI_OBJECT_REF, ARGI_TARGETREF)
+#define ARGI_CONNECTFIELD_OP            ARGI_INVALID_OPCODE
+#define ARGI_CONTINUE_OP                ARGI_INVALID_OPCODE
+#define ARGI_COPY_OP                    ARGI_LIST2 (ARGI_ANYTYPE,    ARGI_SIMPLE_TARGET)
+#define ARGI_CREATE_BIT_FIELD_OP        ARGI_LIST3 (ARGI_BUFFER,     ARGI_INTEGER,       ARGI_REFERENCE)
+#define ARGI_CREATE_BYTE_FIELD_OP       ARGI_LIST3 (ARGI_BUFFER,     ARGI_INTEGER,       ARGI_REFERENCE)
+#define ARGI_CREATE_DWORD_FIELD_OP      ARGI_LIST3 (ARGI_BUFFER,     ARGI_INTEGER,       ARGI_REFERENCE)
+#define ARGI_CREATE_FIELD_OP            ARGI_LIST4 (ARGI_BUFFER,     ARGI_INTEGER,       ARGI_INTEGER,      ARGI_REFERENCE)
+#define ARGI_CREATE_QWORD_FIELD_OP      ARGI_LIST3 (ARGI_BUFFER,     ARGI_INTEGER,       ARGI_REFERENCE)
+#define ARGI_CREATE_WORD_FIELD_OP       ARGI_LIST3 (ARGI_BUFFER,     ARGI_INTEGER,       ARGI_REFERENCE)
+#define ARGI_DATA_REGION_OP             ARGI_LIST3 (ARGI_STRING,     ARGI_STRING,        ARGI_STRING)
+#define ARGI_DEBUG_OP                   ARG_NONE
+#define ARGI_DECREMENT_OP               ARGI_LIST1 (ARGI_TARGETREF)
+#define ARGI_DEREF_OF_OP                ARGI_LIST1 (ARGI_REF_OR_STRING)
+#define ARGI_DEVICE_OP                  ARGI_INVALID_OPCODE
+#define ARGI_DIVIDE_OP                  ARGI_LIST4 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF,    ARGI_TARGETREF)
+#define ARGI_DWORD_OP                   ARGI_INVALID_OPCODE
+#define ARGI_ELSE_OP                    ARGI_INVALID_OPCODE
+#define ARGI_EVENT_OP                   ARGI_INVALID_OPCODE
+#define ARGI_FATAL_OP                   ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_INTEGER)
+#define ARGI_FIELD_OP                   ARGI_INVALID_OPCODE
+#define ARGI_FIND_SET_LEFT_BIT_OP       ARGI_LIST2 (ARGI_INTEGER,    ARGI_TARGETREF)
+#define ARGI_FIND_SET_RIGHT_BIT_OP      ARGI_LIST2 (ARGI_INTEGER,    ARGI_TARGETREF)
+#define ARGI_FROM_BCD_OP                ARGI_LIST2 (ARGI_INTEGER,    ARGI_FIXED_TARGET)
+#define ARGI_IF_OP                      ARGI_INVALID_OPCODE
+#define ARGI_INCREMENT_OP               ARGI_LIST1 (ARGI_TARGETREF)
+#define ARGI_INDEX_FIELD_OP             ARGI_INVALID_OPCODE
+#define ARGI_INDEX_OP                   ARGI_LIST3 (ARGI_COMPLEXOBJ, ARGI_INTEGER,       ARGI_TARGETREF)
+#define ARGI_LAND_OP                    ARGI_LIST2 (ARGI_INTEGER,    ARGI_INTEGER)
+#define ARGI_LEQUAL_OP                  ARGI_LIST2 (ARGI_COMPUTEDATA,ARGI_COMPUTEDATA)
+#define ARGI_LGREATER_OP                ARGI_LIST2 (ARGI_COMPUTEDATA,ARGI_COMPUTEDATA)
+#define ARGI_LGREATEREQUAL_OP           ARGI_INVALID_OPCODE
+#define ARGI_LLESS_OP                   ARGI_LIST2 (ARGI_COMPUTEDATA,ARGI_COMPUTEDATA)
+#define ARGI_LLESSEQUAL_OP              ARGI_INVALID_OPCODE
+#define ARGI_LNOT_OP                    ARGI_LIST1 (ARGI_INTEGER)
+#define ARGI_LNOTEQUAL_OP               ARGI_INVALID_OPCODE
+#define ARGI_LOAD_OP                    ARGI_LIST2 (ARGI_REGION_OR_BUFFER,ARGI_TARGETREF)
+#define ARGI_LOAD_TABLE_OP              ARGI_LIST6 (ARGI_STRING,     ARGI_STRING,        ARGI_STRING,       ARGI_STRING,    ARGI_STRING, ARGI_ANYTYPE)
+#define ARGI_LOCAL0                     ARG_NONE
+#define ARGI_LOCAL1                     ARG_NONE
+#define ARGI_LOCAL2                     ARG_NONE
+#define ARGI_LOCAL3                     ARG_NONE
+#define ARGI_LOCAL4                     ARG_NONE
+#define ARGI_LOCAL5                     ARG_NONE
+#define ARGI_LOCAL6                     ARG_NONE
+#define ARGI_LOCAL7                     ARG_NONE
+#define ARGI_LOR_OP                     ARGI_LIST2 (ARGI_INTEGER,    ARGI_INTEGER)
+#define ARGI_MATCH_OP                   ARGI_LIST6 (ARGI_PACKAGE,    ARGI_INTEGER,   ARGI_COMPUTEDATA,      ARGI_INTEGER,ARGI_COMPUTEDATA,ARGI_INTEGER)
+#define ARGI_METHOD_OP                  ARGI_INVALID_OPCODE
+#define ARGI_METHODCALL_OP              ARGI_INVALID_OPCODE
+#define ARGI_MID_OP                     ARGI_LIST4 (ARGI_BUFFER_OR_STRING,ARGI_INTEGER,  ARGI_INTEGER,      ARGI_TARGETREF)
+#define ARGI_MOD_OP                     ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
+#define ARGI_MULTIPLY_OP                ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
+#define ARGI_MUTEX_OP                   ARGI_INVALID_OPCODE
+#define ARGI_NAME_OP                    ARGI_INVALID_OPCODE
+#define ARGI_NAMEDFIELD_OP              ARGI_INVALID_OPCODE
+#define ARGI_NAMEPATH_OP                ARGI_INVALID_OPCODE
+#define ARGI_NOOP_OP                    ARG_NONE
+#define ARGI_NOTIFY_OP                  ARGI_LIST2 (ARGI_DEVICE_REF, ARGI_INTEGER)
+#define ARGI_ONE_OP                     ARG_NONE
+#define ARGI_ONES_OP                    ARG_NONE
+#define ARGI_PACKAGE_OP                 ARGI_LIST1 (ARGI_INTEGER)
+#define ARGI_POWER_RES_OP               ARGI_INVALID_OPCODE
+#define ARGI_PROCESSOR_OP               ARGI_INVALID_OPCODE
+#define ARGI_QWORD_OP                   ARGI_INVALID_OPCODE
+#define ARGI_REF_OF_OP                  ARGI_LIST1 (ARGI_OBJECT_REF)
+#define ARGI_REGION_OP                  ARGI_LIST2 (ARGI_INTEGER,    ARGI_INTEGER)
+#define ARGI_RELEASE_OP                 ARGI_LIST1 (ARGI_MUTEX)
+#define ARGI_RESERVEDFIELD_OP           ARGI_INVALID_OPCODE
+#define ARGI_RESET_OP                   ARGI_LIST1 (ARGI_EVENT)
+#define ARGI_RETURN_OP                  ARGI_INVALID_OPCODE
+#define ARGI_REVISION_OP                ARG_NONE
+#define ARGI_SCOPE_OP                   ARGI_INVALID_OPCODE
+#define ARGI_SERIALFIELD_OP             ARGI_INVALID_OPCODE
+#define ARGI_SHIFT_LEFT_OP              ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
+#define ARGI_SHIFT_RIGHT_OP             ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
+#define ARGI_SIGNAL_OP                  ARGI_LIST1 (ARGI_EVENT)
+#define ARGI_SIZE_OF_OP                 ARGI_LIST1 (ARGI_DATAOBJECT)
+#define ARGI_SLEEP_OP                   ARGI_LIST1 (ARGI_INTEGER)
+#define ARGI_STALL_OP                   ARGI_LIST1 (ARGI_INTEGER)
+#define ARGI_STATICSTRING_OP            ARGI_INVALID_OPCODE
+#define ARGI_STORE_OP                   ARGI_LIST2 (ARGI_DATAREFOBJ, ARGI_TARGETREF)
+#define ARGI_STRING_OP                  ARGI_INVALID_OPCODE
+#define ARGI_SUBTRACT_OP                ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
+#define ARGI_THERMAL_ZONE_OP            ARGI_INVALID_OPCODE
+#define ARGI_TIMER_OP                   ARG_NONE
+#define ARGI_TO_BCD_OP                  ARGI_LIST2 (ARGI_INTEGER,    ARGI_FIXED_TARGET)
+#define ARGI_TO_BUFFER_OP               ARGI_LIST2 (ARGI_COMPUTEDATA,ARGI_FIXED_TARGET)
+#define ARGI_TO_DEC_STR_OP              ARGI_LIST2 (ARGI_COMPUTEDATA,ARGI_FIXED_TARGET)
+#define ARGI_TO_HEX_STR_OP              ARGI_LIST2 (ARGI_COMPUTEDATA,ARGI_FIXED_TARGET)
+#define ARGI_TO_INTEGER_OP              ARGI_LIST2 (ARGI_COMPUTEDATA,ARGI_FIXED_TARGET)
+#define ARGI_TO_STRING_OP               ARGI_LIST3 (ARGI_BUFFER,     ARGI_INTEGER,       ARGI_FIXED_TARGET)
+#define ARGI_TYPE_OP                    ARGI_LIST1 (ARGI_ANYTYPE)
+#define ARGI_UNLOAD_OP                  ARGI_LIST1 (ARGI_DDBHANDLE)
+#define ARGI_VAR_PACKAGE_OP             ARGI_LIST1 (ARGI_INTEGER)
+#define ARGI_WAIT_OP                    ARGI_LIST2 (ARGI_EVENT,      ARGI_INTEGER)
+#define ARGI_WHILE_OP                   ARGI_INVALID_OPCODE
+#define ARGI_WORD_OP                    ARGI_INVALID_OPCODE
+#define ARGI_ZERO_OP                    ARG_NONE
+
+#endif				/* __ACOPCODE_H__ */
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acparser.h b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acparser.h
new file mode 100644
index 00000000..4015db00
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acparser.h
@@ -0,0 +1,231 @@
+/******************************************************************************
+ *
+ * Module Name: acparser.h - AML Parser subcomponent prototypes and defines
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACPARSER_H__
+#define __ACPARSER_H__
+
+#define OP_HAS_RETURN_VALUE             1
+
+/* Variable number of arguments. This field must be 32 bits */
+
+#define ACPI_VAR_ARGS                   ACPI_UINT32_MAX
+
+#define ACPI_PARSE_DELETE_TREE          0x0001
+#define ACPI_PARSE_NO_TREE_DELETE       0x0000
+#define ACPI_PARSE_TREE_MASK            0x0001
+
+#define ACPI_PARSE_LOAD_PASS1           0x0010
+#define ACPI_PARSE_LOAD_PASS2           0x0020
+#define ACPI_PARSE_EXECUTE              0x0030
+#define ACPI_PARSE_MODE_MASK            0x0030
+
+#define ACPI_PARSE_DEFERRED_OP          0x0100
+#define ACPI_PARSE_DISASSEMBLE          0x0200
+
+#define ACPI_PARSE_MODULE_LEVEL         0x0400
+
+/******************************************************************************
+ *
+ * Parser interfaces
+ *
+ *****************************************************************************/
+
+/*
+ * psxface - Parser external interfaces
+ */
+acpi_status acpi_ps_execute_method(struct acpi_evaluate_info *info);
+
+/*
+ * psargs - Parse AML opcode arguments
+ */
+u8 *acpi_ps_get_next_package_end(struct acpi_parse_state *parser_state);
+
+char *acpi_ps_get_next_namestring(struct acpi_parse_state *parser_state);
+
+void
+acpi_ps_get_next_simple_arg(struct acpi_parse_state *parser_state,
+			    u32 arg_type, union acpi_parse_object *arg);
+
+acpi_status
+acpi_ps_get_next_namepath(struct acpi_walk_state *walk_state,
+			  struct acpi_parse_state *parser_state,
+			  union acpi_parse_object *arg, u8 method_call);
+
+acpi_status
+acpi_ps_get_next_arg(struct acpi_walk_state *walk_state,
+		     struct acpi_parse_state *parser_state,
+		     u32 arg_type, union acpi_parse_object **return_arg);
+
+/*
+ * psfind
+ */
+union acpi_parse_object *acpi_ps_find_name(union acpi_parse_object *scope,
+					   u32 name, u32 opcode);
+
+union acpi_parse_object *acpi_ps_get_parent(union acpi_parse_object *op);
+
+/*
+ * psopcode - AML Opcode information
+ */
+const struct acpi_opcode_info *acpi_ps_get_opcode_info(u16 opcode);
+
+char *acpi_ps_get_opcode_name(u16 opcode);
+
+u8 acpi_ps_get_argument_count(u32 op_type);
+
+/*
+ * psparse - top level parsing routines
+ */
+acpi_status acpi_ps_parse_aml(struct acpi_walk_state *walk_state);
+
+u32 acpi_ps_get_opcode_size(u32 opcode);
+
+u16 acpi_ps_peek_opcode(struct acpi_parse_state *state);
+
+acpi_status
+acpi_ps_complete_this_op(struct acpi_walk_state *walk_state,
+			 union acpi_parse_object *op);
+
+acpi_status
+acpi_ps_next_parse_state(struct acpi_walk_state *walk_state,
+			 union acpi_parse_object *op,
+			 acpi_status callback_status);
+
+/*
+ * psloop - main parse loop
+ */
+acpi_status acpi_ps_parse_loop(struct acpi_walk_state *walk_state);
+
+/*
+ * psscope - Scope stack management routines
+ */
+acpi_status
+acpi_ps_init_scope(struct acpi_parse_state *parser_state,
+		   union acpi_parse_object *root);
+
+union acpi_parse_object *acpi_ps_get_parent_scope(struct acpi_parse_state
+						  *state);
+
+u8 acpi_ps_has_completed_scope(struct acpi_parse_state *parser_state);
+
+void
+acpi_ps_pop_scope(struct acpi_parse_state *parser_state,
+		  union acpi_parse_object **op, u32 *arg_list, u32 *arg_count);
+
+acpi_status
+acpi_ps_push_scope(struct acpi_parse_state *parser_state,
+		   union acpi_parse_object *op,
+		   u32 remaining_args, u32 arg_count);
+
+void acpi_ps_cleanup_scope(struct acpi_parse_state *state);
+
+/*
+ * pstree - parse tree manipulation routines
+ */
+void
+acpi_ps_append_arg(union acpi_parse_object *op, union acpi_parse_object *arg);
+
+union acpi_parse_object *acpi_ps_find(union acpi_parse_object *scope,
+				      char *path, u16 opcode, u32 create);
+
+union acpi_parse_object *acpi_ps_get_arg(union acpi_parse_object *op, u32 argn);
+
+union acpi_parse_object *acpi_ps_get_depth_next(union acpi_parse_object *origin,
+						union acpi_parse_object *op);
+
+/*
+ * pswalk - parse tree walk routines
+ */
+acpi_status
+acpi_ps_walk_parsed_aml(union acpi_parse_object *start_op,
+			union acpi_parse_object *end_op,
+			union acpi_operand_object *mth_desc,
+			struct acpi_namespace_node *start_node,
+			union acpi_operand_object **params,
+			union acpi_operand_object **caller_return_desc,
+			acpi_owner_id owner_id,
+			acpi_parse_downwards descending_callback,
+			acpi_parse_upwards ascending_callback);
+
+acpi_status
+acpi_ps_get_next_walk_op(struct acpi_walk_state *walk_state,
+			 union acpi_parse_object *op,
+			 acpi_parse_upwards ascending_callback);
+
+acpi_status acpi_ps_delete_completed_op(struct acpi_walk_state *walk_state);
+
+void acpi_ps_delete_parse_tree(union acpi_parse_object *root);
+
+/*
+ * psutils - parser utilities
+ */
+union acpi_parse_object *acpi_ps_create_scope_op(void);
+
+void acpi_ps_init_op(union acpi_parse_object *op, u16 opcode);
+
+union acpi_parse_object *acpi_ps_alloc_op(u16 opcode);
+
+void acpi_ps_free_op(union acpi_parse_object *op);
+
+u8 acpi_ps_is_leading_char(u32 c);
+
+u8 acpi_ps_is_prefix_char(u32 c);
+
+u32 acpi_ps_get_name(union acpi_parse_object *op);
+
+void acpi_ps_set_name(union acpi_parse_object *op, u32 name);
+
+/*
+ * psdump - display parser tree
+ */
+u32
+acpi_ps_sprint_path(char *buffer_start,
+		    u32 buffer_size, union acpi_parse_object *op);
+
+u32
+acpi_ps_sprint_op(char *buffer_start,
+		  u32 buffer_size, union acpi_parse_object *op);
+
+void acpi_ps_show(union acpi_parse_object *op);
+
+#endif				/* __ACPARSER_H__ */
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acpredef.h b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acpredef.h
new file mode 100644
index 00000000..6c446dca
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acpredef.h
@@ -0,0 +1,568 @@
+/******************************************************************************
+ *
+ * Name: acpredef - Information table for ACPI predefined methods and objects
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACPREDEF_H__
+#define __ACPREDEF_H__
+
+/******************************************************************************
+ *
+ * Return Package types
+ *
+ * 1) PTYPE1 packages do not contain sub-packages.
+ *
+ * ACPI_PTYPE1_FIXED: Fixed-length length, 1 or 2 object types:
+ *      object type
+ *      count
+ *      object type
+ *      count
+ *
+ * ACPI_PTYPE1_VAR: Variable-length length:
+ *      object type (Int/Buf/Ref)
+ *
+ * ACPI_PTYPE1_OPTION: Package has some required and some optional elements
+ *      (Used for _PRW)
+ *
+ *
+ * 2) PTYPE2 packages contain a Variable-length number of sub-packages. Each
+ *    of the different types describe the contents of each of the sub-packages.
+ *
+ * ACPI_PTYPE2: Each subpackage contains 1 or 2 object types:
+ *      object type
+ *      count
+ *      object type
+ *      count
+ *      (Used for _ALR,_MLS,_PSS,_TRT,_TSS)
+ *
+ * ACPI_PTYPE2_COUNT: Each subpackage has a count as first element:
+ *      object type
+ *      (Used for _CSD,_PSD,_TSD)
+ *
+ * ACPI_PTYPE2_PKG_COUNT: Count of subpackages at start, 1 or 2 object types:
+ *      object type
+ *      count
+ *      object type
+ *      count
+ *      (Used for _CST)
+ *
+ * ACPI_PTYPE2_FIXED: Each subpackage is of Fixed-length
+ *      (Used for _PRT)
+ *
+ * ACPI_PTYPE2_MIN: Each subpackage has a Variable-length but minimum length
+ *      (Used for _HPX)
+ *
+ * ACPI_PTYPE2_REV_FIXED: Revision at start, each subpackage is Fixed-length
+ *      (Used for _ART, _FPS)
+ *
+ * ACPI_PTYPE2_FIX_VAR: Each subpackage consists of some fixed-length elements
+ *      followed by an optional element
+ *      object type
+ *      count
+ *      object type
+ *      count = 0 (optional)
+ *      (Used for _DLM)
+ *
+ *****************************************************************************/
+
+enum acpi_return_package_types {
+	ACPI_PTYPE1_FIXED = 1,
+	ACPI_PTYPE1_VAR = 2,
+	ACPI_PTYPE1_OPTION = 3,
+	ACPI_PTYPE2 = 4,
+	ACPI_PTYPE2_COUNT = 5,
+	ACPI_PTYPE2_PKG_COUNT = 6,
+	ACPI_PTYPE2_FIXED = 7,
+	ACPI_PTYPE2_MIN = 8,
+	ACPI_PTYPE2_REV_FIXED = 9,
+	ACPI_PTYPE2_FIX_VAR = 10
+};
+
+#ifdef ACPI_CREATE_PREDEFINED_TABLE
+/*
+ * Predefined method/object information table.
+ *
+ * These are the names that can actually be evaluated via acpi_evaluate_object.
+ * Not present in this table are the following:
+ *
+ *      1) Predefined/Reserved names that are never evaluated via
+ *         acpi_evaluate_object:
+ *              _Lxx and _Exx GPE methods
+ *              _Qxx EC methods
+ *              _T_x compiler temporary variables
+ *
+ *      2) Predefined names that never actually exist within the AML code:
+ *              Predefined resource descriptor field names
+ *
+ *      3) Predefined names that are implemented within ACPICA:
+ *              _OSI
+ *
+ *      4) Some predefined names that are not documented within the ACPI spec.
+ *              _WDG, _WED
+ *
+ * The main entries in the table each contain the following items:
+ *
+ * Name                 - The ACPI reserved name
+ * param_count          - Number of arguments to the method
+ * expected_btypes      - Allowed type(s) for the return value.
+ *                        0 means that no return value is expected.
+ *
+ * For methods that return packages, the next entry in the table contains
+ * information about the expected structure of the package. This information
+ * is saved here (rather than in a separate table) in order to minimize the
+ * overall size of the stored data.
+ *
+ * Note: The additional braces are intended to promote portability.
+ */
+static const union acpi_predefined_info predefined_names[] = {
+	{{"_AC0", 0, ACPI_RTYPE_INTEGER}},
+	{{"_AC1", 0, ACPI_RTYPE_INTEGER}},
+	{{"_AC2", 0, ACPI_RTYPE_INTEGER}},
+	{{"_AC3", 0, ACPI_RTYPE_INTEGER}},
+	{{"_AC4", 0, ACPI_RTYPE_INTEGER}},
+	{{"_AC5", 0, ACPI_RTYPE_INTEGER}},
+	{{"_AC6", 0, ACPI_RTYPE_INTEGER}},
+	{{"_AC7", 0, ACPI_RTYPE_INTEGER}},
+	{{"_AC8", 0, ACPI_RTYPE_INTEGER}},
+	{{"_AC9", 0, ACPI_RTYPE_INTEGER}},
+	{{"_ADR", 0, ACPI_RTYPE_INTEGER}},
+	{{"_AEI", 0, ACPI_RTYPE_BUFFER}},
+	{{"_AL0", 0, ACPI_RTYPE_PACKAGE}},	/* Variable-length (Refs) */
+	{{{ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0, 0}, 0, 0}},
+
+	{{"_AL1", 0, ACPI_RTYPE_PACKAGE}},	/* Variable-length (Refs) */
+	{{{ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0, 0}, 0, 0}},
+
+	{{"_AL2", 0, ACPI_RTYPE_PACKAGE}},	/* Variable-length (Refs) */
+	{{{ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0, 0}, 0, 0}},
+
+	{{"_AL3", 0, ACPI_RTYPE_PACKAGE}},	/* Variable-length (Refs) */
+	{{{ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0, 0}, 0, 0}},
+
+	{{"_AL4", 0, ACPI_RTYPE_PACKAGE}},	/* Variable-length (Refs) */
+	{{{ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0, 0}, 0, 0}},
+
+	{{"_AL5", 0, ACPI_RTYPE_PACKAGE}},	/* Variable-length (Refs) */
+	{{{ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0, 0}, 0, 0}},
+
+	{{"_AL6", 0, ACPI_RTYPE_PACKAGE}},	/* Variable-length (Refs) */
+	{{{ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0, 0}, 0, 0}},
+
+	{{"_AL7", 0, ACPI_RTYPE_PACKAGE}},	/* Variable-length (Refs) */
+	{{{ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0, 0}, 0, 0}},
+
+	{{"_AL8", 0, ACPI_RTYPE_PACKAGE}},	/* Variable-length (Refs) */
+	{{{ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0, 0}, 0, 0}},
+
+	{{"_AL9", 0, ACPI_RTYPE_PACKAGE}},	/* Variable-length (Refs) */
+	{{{ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0, 0}, 0, 0}},
+
+	{{"_ALC", 0, ACPI_RTYPE_INTEGER}},
+	{{"_ALI", 0, ACPI_RTYPE_INTEGER}},
+	{{"_ALP", 0, ACPI_RTYPE_INTEGER}},
+	{{"_ALR", 0, ACPI_RTYPE_PACKAGE}},	/* Variable-length (Pkgs) each 2 (Ints) */
+	{{{ACPI_PTYPE2, ACPI_RTYPE_INTEGER, 2, 0}, 0, 0}},
+
+	{{"_ALT", 0, ACPI_RTYPE_INTEGER}},
+	{{"_ART", 0, ACPI_RTYPE_PACKAGE}},	/* Variable-length (1 Int(rev), n Pkg (2 Ref/11 Int) */
+	{{{ACPI_PTYPE2_REV_FIXED, ACPI_RTYPE_REFERENCE, 2, ACPI_RTYPE_INTEGER},
+	  11, 0}},
+
+	{{"_BBN", 0, ACPI_RTYPE_INTEGER}},
+	{{"_BCL", 0, ACPI_RTYPE_PACKAGE}},	/* Variable-length (Ints) */
+	{{{ACPI_PTYPE1_VAR, ACPI_RTYPE_INTEGER, 0, 0}, 0, 0}},
+
+	{{"_BCM", 1, 0}},
+	{{"_BCT", 1, ACPI_RTYPE_INTEGER}},
+	{{"_BDN", 0, ACPI_RTYPE_INTEGER}},
+	{{"_BFS", 1, 0}},
+	{{"_BIF", 0, ACPI_RTYPE_PACKAGE}},	/* Fixed-length (9 Int),(4 Str) */
+	{{{ACPI_PTYPE1_FIXED, ACPI_RTYPE_INTEGER, 9, ACPI_RTYPE_STRING}, 4, 0}},
+
+	{{"_BIX", 0, ACPI_RTYPE_PACKAGE}},	/* Fixed-length (16 Int),(4 Str) */
+	{{{ACPI_PTYPE1_FIXED, ACPI_RTYPE_INTEGER, 16, ACPI_RTYPE_STRING}, 4,
+	  0}},
+
+	{{"_BLT", 3, 0}},
+	{{"_BMA", 1, ACPI_RTYPE_INTEGER}},
+	{{"_BMC", 1, 0}},
+	{{"_BMD", 0, ACPI_RTYPE_PACKAGE}},	/* Fixed-length (5 Int) */
+	{{{ACPI_PTYPE1_FIXED, ACPI_RTYPE_INTEGER, 5, 0}, 0, 0}},
+
+	{{"_BMS", 1, ACPI_RTYPE_INTEGER}},
+	{{"_BQC", 0, ACPI_RTYPE_INTEGER}},
+	{{"_BST", 0, ACPI_RTYPE_PACKAGE}},	/* Fixed-length (4 Int) */
+	{{{ACPI_PTYPE1_FIXED, ACPI_RTYPE_INTEGER, 4, 0}, 0, 0}},
+
+	{{"_BTM", 1, ACPI_RTYPE_INTEGER}},
+	{{"_BTP", 1, 0}},
+	{{"_CBA", 0, ACPI_RTYPE_INTEGER}},	/* See PCI firmware spec 3.0 */
+	{{"_CDM", 0, ACPI_RTYPE_INTEGER}},
+	{{"_CID", 0, ACPI_RTYPE_INTEGER | ACPI_RTYPE_STRING | ACPI_RTYPE_PACKAGE}},	/* Variable-length (Ints/Strs) */
+	{{{ACPI_PTYPE1_VAR, ACPI_RTYPE_INTEGER | ACPI_RTYPE_STRING, 0, 0}, 0,
+	  0}},
+
+	{{"_CLS", 0, ACPI_RTYPE_PACKAGE}},	/* Fixed-length (3 Int) */
+	{{{ACPI_PTYPE1_FIXED, ACPI_RTYPE_INTEGER, 3, 0}, 0, 0}},
+
+	{{"_CPC", 0, ACPI_RTYPE_PACKAGE}},	/* Variable-length (Ints/Bufs) */
+	{{{ACPI_PTYPE1_VAR, ACPI_RTYPE_INTEGER | ACPI_RTYPE_BUFFER, 0, 0}, 0,
+	  0}},
+
+	{{"_CRS", 0, ACPI_RTYPE_BUFFER}},
+	{{"_CRT", 0, ACPI_RTYPE_INTEGER}},
+	{{"_CSD", 0, ACPI_RTYPE_PACKAGE}},	/* Variable-length (1 Int(n), n-1 Int) */
+	{{{ACPI_PTYPE2_COUNT, ACPI_RTYPE_INTEGER, 0, 0}, 0, 0}},
+
+	{{"_CST", 0, ACPI_RTYPE_PACKAGE}},	/* Variable-length (1 Int(n), n Pkg (1 Buf/3 Int) */
+	{{{ACPI_PTYPE2_PKG_COUNT, ACPI_RTYPE_BUFFER, 1, ACPI_RTYPE_INTEGER}, 3,
+	  0}},
+
+	{{"_CWS", 1, ACPI_RTYPE_INTEGER}},
+	{{"_DCK", 1, ACPI_RTYPE_INTEGER}},
+	{{"_DCS", 0, ACPI_RTYPE_INTEGER}},
+	{{"_DDC", 1, ACPI_RTYPE_INTEGER | ACPI_RTYPE_BUFFER}},
+	{{"_DDN", 0, ACPI_RTYPE_STRING}},
+	{{"_DEP", 0, ACPI_RTYPE_PACKAGE}},	/* Variable-length (Refs) */
+	{{{ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0, 0}, 0, 0}},
+
+	{{"_DGS", 0, ACPI_RTYPE_INTEGER}},
+	{{"_DIS", 0, 0}},
+
+	{{"_DLM", 0, ACPI_RTYPE_PACKAGE}},	/* Variable-length (Pkgs) each (1 Ref, 0/1 Optional Buf/Ref) */
+	{{{ACPI_PTYPE2_FIX_VAR, ACPI_RTYPE_REFERENCE, 1,
+	   ACPI_RTYPE_REFERENCE | ACPI_RTYPE_BUFFER}, 0, 0}},
+
+	{{"_DMA", 0, ACPI_RTYPE_BUFFER}},
+	{{"_DOD", 0, ACPI_RTYPE_PACKAGE}},	/* Variable-length (Ints) */
+	{{{ACPI_PTYPE1_VAR, ACPI_RTYPE_INTEGER, 0, 0}, 0, 0}},
+
+	{{"_DOS", 1, 0}},
+	{{"_DSM", 4, ACPI_RTYPE_ALL}},	/* Must return a type, but it can be of any type */
+	{{"_DSS", 1, 0}},
+	{{"_DSW", 3, 0}},
+	{{"_DTI", 1, 0}},
+	{{"_EC_", 0, ACPI_RTYPE_INTEGER}},
+	{{"_EDL", 0, ACPI_RTYPE_PACKAGE}},	/* Variable-length (Refs) */
+	{{{ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0, 0}, 0, 0}},
+
+	{{"_EJ0", 1, 0}},
+	{{"_EJ1", 1, 0}},
+	{{"_EJ2", 1, 0}},
+	{{"_EJ3", 1, 0}},
+	{{"_EJ4", 1, 0}},
+	{{"_EJD", 0, ACPI_RTYPE_STRING}},
+	{{"_ERR", 3, ACPI_RTYPE_INTEGER}},	/* Internal use only, used by ACPICA test suites */
+	{{"_EVT", 1, 0}},
+	{{"_FDE", 0, ACPI_RTYPE_BUFFER}},
+	{{"_FDI", 0, ACPI_RTYPE_PACKAGE}},	/* Fixed-length (16 Int) */
+	{{{ACPI_PTYPE1_FIXED, ACPI_RTYPE_INTEGER, 16, 0}, 0, 0}},
+
+	{{"_FDM", 1, 0}},
+	{{"_FIF", 0, ACPI_RTYPE_PACKAGE}},	/* Fixed-length (4 Int) */
+	{{{ACPI_PTYPE1_FIXED, ACPI_RTYPE_INTEGER, 4, 0}, 0, 0}},
+
+	{{"_FIX", 0, ACPI_RTYPE_PACKAGE}},	/* Variable-length (Ints) */
+	{{{ACPI_PTYPE1_VAR, ACPI_RTYPE_INTEGER, 0, 0}, 0, 0}},
+
+	{{"_FPS", 0, ACPI_RTYPE_PACKAGE}},	/* Variable-length (1 Int(rev), n Pkg (5 Int) */
+	{{{ACPI_PTYPE2_REV_FIXED, ACPI_RTYPE_INTEGER, 5, 0}, 0, 0}},
+
+	{{"_FSL", 1, 0}},
+	{{"_FST", 0, ACPI_RTYPE_PACKAGE}},	/* Fixed-length (3 Int) */
+	{{{ACPI_PTYPE1_FIXED, ACPI_RTYPE_INTEGER, 3, 0}, 0, 0}},
+
+	{{"_GAI", 0, ACPI_RTYPE_INTEGER}},
+	{{"_GCP", 0, ACPI_RTYPE_INTEGER}},
+	{{"_GHL", 0, ACPI_RTYPE_INTEGER}},
+	{{"_GLK", 0, ACPI_RTYPE_INTEGER}},
+	{{"_GPD", 0, ACPI_RTYPE_INTEGER}},
+	{{"_GPE", 0, ACPI_RTYPE_INTEGER}},	/* _GPE method, not _GPE scope */
+	{{"_GRT", 0, ACPI_RTYPE_BUFFER}},
+	{{"_GSB", 0, ACPI_RTYPE_INTEGER}},
+	{{"_GTF", 0, ACPI_RTYPE_BUFFER}},
+	{{"_GTM", 0, ACPI_RTYPE_BUFFER}},
+	{{"_GTS", 1, 0}},
+	{{"_GWS", 1, ACPI_RTYPE_INTEGER}},
+	{{"_HID", 0, ACPI_RTYPE_INTEGER | ACPI_RTYPE_STRING}},
+	{{"_HOT", 0, ACPI_RTYPE_INTEGER}},
+	{{"_HPP", 0, ACPI_RTYPE_PACKAGE}},	/* Fixed-length (4 Int) */
+	{{{ACPI_PTYPE1_FIXED, ACPI_RTYPE_INTEGER, 4, 0}, 0, 0}},
+
+	/*
+	 * For _HPX, a single package is returned, containing a Variable-length number
+	 * of sub-packages. Each sub-package contains a PCI record setting.
+	 * There are several different type of record settings, of different
+	 * lengths, but all elements of all settings are Integers.
+	 */
+	{{"_HPX", 0, ACPI_RTYPE_PACKAGE}},	/* Variable-length (Pkgs) each (var Ints) */
+	{{{ACPI_PTYPE2_MIN, ACPI_RTYPE_INTEGER, 5, 0}, 0, 0}},
+
+	{{"_HRV", 0, ACPI_RTYPE_INTEGER}},
+	{{"_IFT", 0, ACPI_RTYPE_INTEGER}},	/* See IPMI spec */
+	{{"_INI", 0, 0}},
+	{{"_IRC", 0, 0}},
+	{{"_LCK", 1, 0}},
+	{{"_LID", 0, ACPI_RTYPE_INTEGER}},
+	{{"_MAT", 0, ACPI_RTYPE_BUFFER}},
+	{{"_MBM", 0, ACPI_RTYPE_PACKAGE}},	/* Fixed-length (8 Int) */
+	{{{ACPI_PTYPE1_FIXED, ACPI_RTYPE_INTEGER, 8, 0}, 0, 0}},
+
+	{{"_MLS", 0, ACPI_RTYPE_PACKAGE}},	/* Variable-length (Pkgs) each (2 Str) */
+	{{{ACPI_PTYPE2, ACPI_RTYPE_STRING, 2, 0}, 0, 0}},
+
+	{{"_MSG", 1, 0}},
+	{{"_MSM", 4, ACPI_RTYPE_INTEGER}},
+	{{"_NTT", 0, ACPI_RTYPE_INTEGER}},
+	{{"_OFF", 0, 0}},
+	{{"_ON_", 0, 0}},
+	{{"_OS_", 0, ACPI_RTYPE_STRING}},
+	{{"_OSC", 4, ACPI_RTYPE_BUFFER}},
+	{{"_OST", 3, 0}},
+	{{"_PAI", 1, ACPI_RTYPE_INTEGER}},
+	{{"_PCL", 0, ACPI_RTYPE_PACKAGE}},	/* Variable-length (Refs) */
+	{{{ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0, 0}, 0, 0}},
+
+	{{"_PCT", 0, ACPI_RTYPE_PACKAGE}},	/* Fixed-length (2 Buf) */
+	{{{ACPI_PTYPE1_FIXED, ACPI_RTYPE_BUFFER, 2, 0}, 0, 0}},
+
+	{{"_PDC", 1, 0}},
+	{{"_PDL", 0, ACPI_RTYPE_INTEGER}},
+	{{"_PIC", 1, 0}},
+	{{"_PIF", 0, ACPI_RTYPE_PACKAGE}},	/* Fixed-length (3 Int),(3 Str) */
+	{{{ACPI_PTYPE1_FIXED, ACPI_RTYPE_INTEGER, 3, ACPI_RTYPE_STRING}, 3, 0}},
+
+	{{"_PLD", 0, ACPI_RTYPE_PACKAGE}},	/* Variable-length (Bufs) */
+	{{{ACPI_PTYPE1_VAR, ACPI_RTYPE_BUFFER, 0, 0}, 0, 0}},
+
+	{{"_PMC", 0, ACPI_RTYPE_PACKAGE}},	/* Fixed-length (11 Int),(3 Str) */
+	{{{ACPI_PTYPE1_FIXED, ACPI_RTYPE_INTEGER, 11, ACPI_RTYPE_STRING}, 3,
+	  0}},
+
+	{{"_PMD", 0, ACPI_RTYPE_PACKAGE}},	/* Variable-length (Refs) */
+	{{{ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0, 0}, 0, 0}},
+
+	{{"_PMM", 0, ACPI_RTYPE_INTEGER}},
+	{{"_PPC", 0, ACPI_RTYPE_INTEGER}},
+	{{"_PPE", 0, ACPI_RTYPE_INTEGER}},	/* See dig64 spec */
+	{{"_PR0", 0, ACPI_RTYPE_PACKAGE}},	/* Variable-length (Refs) */
+	{{{ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0, 0}, 0, 0}},
+
+	{{"_PR1", 0, ACPI_RTYPE_PACKAGE}},	/* Variable-length (Refs) */
+	{{{ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0, 0}, 0, 0}},
+
+	{{"_PR2", 0, ACPI_RTYPE_PACKAGE}},	/* Variable-length (Refs) */
+	{{{ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0, 0}, 0, 0}},
+
+	{{"_PR3", 0, ACPI_RTYPE_PACKAGE}},	/* Variable-length (Refs) */
+	{{{ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0, 0}, 0, 0}},
+
+	{{"_PRE", 0, ACPI_RTYPE_PACKAGE}},	/* Variable-length (Refs) */
+	{{{ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0, 0}, 0, 0}},
+
+	{{"_PRL", 0, ACPI_RTYPE_PACKAGE}},	/* Variable-length (Refs) */
+	{{{ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0, 0}, 0, 0}},
+
+	{{"_PRS", 0, ACPI_RTYPE_BUFFER}},
+
+	/*
+	 * For _PRT, many BIOSs reverse the 3rd and 4th Package elements (Source
+	 * and source_index). This bug is so prevalent that there is code in the
+	 * ACPICA Resource Manager to detect this and switch them back. For now,
+	 * do not allow and issue a warning. To allow this and eliminate the
+	 * warning, add the ACPI_RTYPE_REFERENCE type to the 4th element (index 3)
+	 * in the statement below.
+	 */
+	{{"_PRT", 0, ACPI_RTYPE_PACKAGE}},	/* Variable-length (Pkgs) each (4): Int,Int,Int/Ref,Int */
+	{{{ACPI_PTYPE2_FIXED, 4, ACPI_RTYPE_INTEGER, ACPI_RTYPE_INTEGER},
+	  ACPI_RTYPE_INTEGER | ACPI_RTYPE_REFERENCE,
+	  ACPI_RTYPE_INTEGER}},
+
+	{{"_PRW", 0, ACPI_RTYPE_PACKAGE}},	/* Variable-length (Pkgs) each: Pkg/Int,Int,[Variable-length Refs] (Pkg is Ref/Int) */
+	{{{ACPI_PTYPE1_OPTION, 2, ACPI_RTYPE_INTEGER | ACPI_RTYPE_PACKAGE,
+	   ACPI_RTYPE_INTEGER}, ACPI_RTYPE_REFERENCE, 0}},
+
+	{{"_PS0", 0, 0}},
+	{{"_PS1", 0, 0}},
+	{{"_PS2", 0, 0}},
+	{{"_PS3", 0, 0}},
+	{{"_PSC", 0, ACPI_RTYPE_INTEGER}},
+	{{"_PSD", 0, ACPI_RTYPE_PACKAGE}},	/* Variable-length (Pkgs) each (5 Int) with count */
+	{{{ACPI_PTYPE2_COUNT, ACPI_RTYPE_INTEGER, 0, 0}, 0, 0}},
+
+	{{"_PSE", 1, 0}},
+	{{"_PSL", 0, ACPI_RTYPE_PACKAGE}},	/* Variable-length (Refs) */
+	{{{ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0, 0}, 0, 0}},
+
+	{{"_PSR", 0, ACPI_RTYPE_INTEGER}},
+	{{"_PSS", 0, ACPI_RTYPE_PACKAGE}},	/* Variable-length (Pkgs) each (6 Int) */
+	{{{ACPI_PTYPE2, ACPI_RTYPE_INTEGER, 6, 0}, 0, 0}},
+
+	{{"_PSV", 0, ACPI_RTYPE_INTEGER}},
+	{{"_PSW", 1, 0}},
+	{{"_PTC", 0, ACPI_RTYPE_PACKAGE}},	/* Fixed-length (2 Buf) */
+	{{{ACPI_PTYPE1_FIXED, ACPI_RTYPE_BUFFER, 2, 0}, 0, 0}},
+
+	{{"_PTP", 2, ACPI_RTYPE_INTEGER}},
+	{{"_PTS", 1, 0}},
+	{{"_PUR", 0, ACPI_RTYPE_PACKAGE}},	/* Fixed-length (2 Int) */
+	{{{ACPI_PTYPE1_FIXED, ACPI_RTYPE_INTEGER, 2, 0}, 0, 0}},
+
+	{{"_PXM", 0, ACPI_RTYPE_INTEGER}},
+	{{"_REG", 2, 0}},
+	{{"_REV", 0, ACPI_RTYPE_INTEGER}},
+	{{"_RMV", 0, ACPI_RTYPE_INTEGER}},
+	{{"_ROM", 2, ACPI_RTYPE_BUFFER}},
+	{{"_RTV", 0, ACPI_RTYPE_INTEGER}},
+
+	/*
+	 * For _S0_ through _S5_, the ACPI spec defines a return Package
+	 * containing 1 Integer, but most DSDTs have it wrong - 2,3, or 4 integers.
+	 * Allow this by making the objects "Variable-length length", but all elements
+	 * must be Integers.
+	 */
+	{{"_S0_", 0, ACPI_RTYPE_PACKAGE}},	/* Fixed-length (1 Int) */
+	{{{ACPI_PTYPE1_VAR, ACPI_RTYPE_INTEGER, 1, 0}, 0, 0}},
+
+	{{"_S1_", 0, ACPI_RTYPE_PACKAGE}},	/* Fixed-length (1 Int) */
+	{{{ACPI_PTYPE1_VAR, ACPI_RTYPE_INTEGER, 1, 0}, 0, 0}},
+
+	{{"_S2_", 0, ACPI_RTYPE_PACKAGE}},	/* Fixed-length (1 Int) */
+	{{{ACPI_PTYPE1_VAR, ACPI_RTYPE_INTEGER, 1, 0}, 0, 0}},
+
+	{{"_S3_", 0, ACPI_RTYPE_PACKAGE}},	/* Fixed-length (1 Int) */
+	{{{ACPI_PTYPE1_VAR, ACPI_RTYPE_INTEGER, 1, 0}, 0, 0}},
+
+	{{"_S4_", 0, ACPI_RTYPE_PACKAGE}},	/* Fixed-length (1 Int) */
+	{{{ACPI_PTYPE1_VAR, ACPI_RTYPE_INTEGER, 1, 0}, 0, 0}},
+
+	{{"_S5_", 0, ACPI_RTYPE_PACKAGE}},	/* Fixed-length (1 Int) */
+	{{{ACPI_PTYPE1_VAR, ACPI_RTYPE_INTEGER, 1, 0}, 0, 0}},
+
+	{{"_S1D", 0, ACPI_RTYPE_INTEGER}},
+	{{"_S2D", 0, ACPI_RTYPE_INTEGER}},
+	{{"_S3D", 0, ACPI_RTYPE_INTEGER}},
+	{{"_S4D", 0, ACPI_RTYPE_INTEGER}},
+	{{"_S0W", 0, ACPI_RTYPE_INTEGER}},
+	{{"_S1W", 0, ACPI_RTYPE_INTEGER}},
+	{{"_S2W", 0, ACPI_RTYPE_INTEGER}},
+	{{"_S3W", 0, ACPI_RTYPE_INTEGER}},
+	{{"_S4W", 0, ACPI_RTYPE_INTEGER}},
+	{{"_SBS", 0, ACPI_RTYPE_INTEGER}},
+	{{"_SCP", 0x13, 0}},	/* Acpi 1.0 allowed 1 arg. Acpi 3.0 expanded to 3 args. Allow both. */
+	/* Note: the 3-arg definition may be removed for ACPI 4.0 */
+	{{"_SDD", 1, 0}},
+	{{"_SEG", 0, ACPI_RTYPE_INTEGER}},
+	{{"_SHL", 1, ACPI_RTYPE_INTEGER}},
+	{{"_SLI", 0, ACPI_RTYPE_BUFFER}},
+	{{"_SPD", 1, ACPI_RTYPE_INTEGER}},
+	{{"_SRS", 1, 0}},
+	{{"_SRT", 1, ACPI_RTYPE_INTEGER}},
+	{{"_SRV", 0, ACPI_RTYPE_INTEGER}},	/* See IPMI spec */
+	{{"_SST", 1, 0}},
+	{{"_STA", 0, ACPI_RTYPE_INTEGER}},
+	{{"_STM", 3, 0}},
+	{{"_STP", 2, ACPI_RTYPE_INTEGER}},
+	{{"_STR", 0, ACPI_RTYPE_BUFFER}},
+	{{"_STV", 2, ACPI_RTYPE_INTEGER}},
+	{{"_SUB", 0, ACPI_RTYPE_STRING}},
+	{{"_SUN", 0, ACPI_RTYPE_INTEGER}},
+	{{"_SWS", 0, ACPI_RTYPE_INTEGER}},
+	{{"_TC1", 0, ACPI_RTYPE_INTEGER}},
+	{{"_TC2", 0, ACPI_RTYPE_INTEGER}},
+	{{"_TDL", 0, ACPI_RTYPE_INTEGER}},
+	{{"_TIP", 1, ACPI_RTYPE_INTEGER}},
+	{{"_TIV", 1, ACPI_RTYPE_INTEGER}},
+	{{"_TMP", 0, ACPI_RTYPE_INTEGER}},
+	{{"_TPC", 0, ACPI_RTYPE_INTEGER}},
+	{{"_TPT", 1, 0}},
+	{{"_TRT", 0, ACPI_RTYPE_PACKAGE}},	/* Variable-length (Pkgs) each 2_ref/6_int */
+	{{{ACPI_PTYPE2, ACPI_RTYPE_REFERENCE, 2, ACPI_RTYPE_INTEGER}, 6, 0}},
+
+	{{"_TSD", 0, ACPI_RTYPE_PACKAGE}},	/* Variable-length (Pkgs) each 5_int with count */
+	{{{ACPI_PTYPE2_COUNT, ACPI_RTYPE_INTEGER, 5, 0}, 0, 0}},
+
+	{{"_TSP", 0, ACPI_RTYPE_INTEGER}},
+	{{"_TSS", 0, ACPI_RTYPE_PACKAGE}},	/* Variable-length (Pkgs) each 5_int */
+	{{{ACPI_PTYPE2, ACPI_RTYPE_INTEGER, 5, 0}, 0, 0}},
+
+	{{"_TST", 0, ACPI_RTYPE_INTEGER}},
+	{{"_TTS", 1, 0}},
+	{{"_TZD", 0, ACPI_RTYPE_PACKAGE}},	/* Variable-length (Refs) */
+	{{{ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0, 0}, 0, 0}},
+
+	{{"_TZM", 0, ACPI_RTYPE_REFERENCE}},
+	{{"_TZP", 0, ACPI_RTYPE_INTEGER}},
+	{{"_UID", 0, ACPI_RTYPE_INTEGER | ACPI_RTYPE_STRING}},
+	{{"_UPC", 0, ACPI_RTYPE_PACKAGE}},	/* Fixed-length (4 Int) */
+	{{{ACPI_PTYPE1_FIXED, ACPI_RTYPE_INTEGER, 4, 0}, 0, 0}},
+
+	{{"_UPD", 0, ACPI_RTYPE_INTEGER}},
+	{{"_UPP", 0, ACPI_RTYPE_INTEGER}},
+	{{"_VPO", 0, ACPI_RTYPE_INTEGER}},
+
+	/* Acpi 1.0 defined _WAK with no return value. Later, it was changed to return a package */
+
+	{{"_WAK", 1,
+	  ACPI_RTYPE_NONE | ACPI_RTYPE_INTEGER | ACPI_RTYPE_PACKAGE}},
+	{{{ACPI_PTYPE1_FIXED, ACPI_RTYPE_INTEGER, 2, 0}, 0, 0}},	/* Fixed-length (2 Int), but is optional */
+
+	/* _WDG/_WED are MS extensions defined by "Windows Instrumentation" */
+
+	{{"_WDG", 0, ACPI_RTYPE_BUFFER}},
+	{{"_WED", 1,
+	  ACPI_RTYPE_INTEGER | ACPI_RTYPE_STRING | ACPI_RTYPE_BUFFER}},
+
+	{{{0, 0, 0, 0}, 0, 0}}	/* Table terminator */
+};
+
+#if 0
+
+	/* This is an internally implemented control method, no need to check */
+{ {
+"_OSI", 1, ACPI_RTYPE_INTEGER}},
+
+    /* TBD: */
+    _PRT - currently ignore reversed entries.attempt to fix here ?
+    think about possibly fixing package elements like _BIF, etc.
+#endif
+#endif
+#endif
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acresrc.h b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acresrc.h
new file mode 100644
index 00000000..569dfa71
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acresrc.h
@@ -0,0 +1,376 @@
+/******************************************************************************
+ *
+ * Name: acresrc.h - Resource Manager function prototypes
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACRESRC_H__
+#define __ACRESRC_H__
+
+/* Need the AML resource descriptor structs */
+
+#include "amlresrc.h"
+
+/*
+ * If possible, pack the following structures to byte alignment, since we
+ * don't care about performance for debug output. Two cases where we cannot
+ * pack the structures:
+ *
+ * 1) Hardware does not support misaligned memory transfers
+ * 2) Compiler does not support pointers within packed structures
+ */
+#if (!defined(ACPI_MISALIGNMENT_NOT_SUPPORTED) && !defined(ACPI_PACKED_POINTERS_NOT_SUPPORTED))
+#pragma pack(1)
+#endif
+
+/*
+ * Individual entry for the resource conversion tables
+ */
+typedef const struct acpi_rsconvert_info {
+	u8 opcode;
+	u8 resource_offset;
+	u8 aml_offset;
+	u8 value;
+
+} acpi_rsconvert_info;
+
+/* Resource conversion opcodes */
+
+typedef enum {
+	ACPI_RSC_INITGET = 0,
+	ACPI_RSC_INITSET,
+	ACPI_RSC_FLAGINIT,
+	ACPI_RSC_1BITFLAG,
+	ACPI_RSC_2BITFLAG,
+	ACPI_RSC_3BITFLAG,
+	ACPI_RSC_ADDRESS,
+	ACPI_RSC_BITMASK,
+	ACPI_RSC_BITMASK16,
+	ACPI_RSC_COUNT,
+	ACPI_RSC_COUNT16,
+	ACPI_RSC_COUNT_GPIO_PIN,
+	ACPI_RSC_COUNT_GPIO_RES,
+	ACPI_RSC_COUNT_GPIO_VEN,
+	ACPI_RSC_COUNT_SERIAL_RES,
+	ACPI_RSC_COUNT_SERIAL_VEN,
+	ACPI_RSC_DATA8,
+	ACPI_RSC_EXIT_EQ,
+	ACPI_RSC_EXIT_LE,
+	ACPI_RSC_EXIT_NE,
+	ACPI_RSC_LENGTH,
+	ACPI_RSC_MOVE_GPIO_PIN,
+	ACPI_RSC_MOVE_GPIO_RES,
+	ACPI_RSC_MOVE_SERIAL_RES,
+	ACPI_RSC_MOVE_SERIAL_VEN,
+	ACPI_RSC_MOVE8,
+	ACPI_RSC_MOVE16,
+	ACPI_RSC_MOVE32,
+	ACPI_RSC_MOVE64,
+	ACPI_RSC_SET8,
+	ACPI_RSC_SOURCE,
+	ACPI_RSC_SOURCEX
+} ACPI_RSCONVERT_OPCODES;
+
+/* Resource Conversion sub-opcodes */
+
+#define ACPI_RSC_COMPARE_AML_LENGTH     0
+#define ACPI_RSC_COMPARE_VALUE          1
+
+#define ACPI_RSC_TABLE_SIZE(d)          (sizeof (d) / sizeof (struct acpi_rsconvert_info))
+
+#define ACPI_RS_OFFSET(f)               (u8) ACPI_OFFSET (struct acpi_resource,f)
+#define AML_OFFSET(f)                   (u8) ACPI_OFFSET (union aml_resource,f)
+
+/*
+ * Individual entry for the resource dump tables
+ */
+typedef const struct acpi_rsdump_info {
+	u8 opcode;
+	u8 offset;
+	char *name;
+	const char **pointer;
+
+} acpi_rsdump_info;
+
+/* Values for the Opcode field above */
+
+typedef enum {
+	ACPI_RSD_TITLE = 0,
+	ACPI_RSD_1BITFLAG,
+	ACPI_RSD_2BITFLAG,
+	ACPI_RSD_3BITFLAG,
+	ACPI_RSD_ADDRESS,
+	ACPI_RSD_DWORDLIST,
+	ACPI_RSD_LITERAL,
+	ACPI_RSD_LONGLIST,
+	ACPI_RSD_SHORTLIST,
+	ACPI_RSD_SHORTLISTX,
+	ACPI_RSD_SOURCE,
+	ACPI_RSD_STRING,
+	ACPI_RSD_UINT8,
+	ACPI_RSD_UINT16,
+	ACPI_RSD_UINT32,
+	ACPI_RSD_UINT64,
+	ACPI_RSD_WORDLIST
+} ACPI_RSDUMP_OPCODES;
+
+/* restore default alignment */
+
+#pragma pack()
+
+/* Resource tables indexed by internal resource type */
+
+extern const u8 acpi_gbl_aml_resource_sizes[];
+extern const u8 acpi_gbl_aml_resource_serial_bus_sizes[];
+extern struct acpi_rsconvert_info *acpi_gbl_set_resource_dispatch[];
+
+/* Resource tables indexed by raw AML resource descriptor type */
+
+extern const u8 acpi_gbl_resource_struct_sizes[];
+extern const u8 acpi_gbl_resource_struct_serial_bus_sizes[];
+extern struct acpi_rsconvert_info *acpi_gbl_get_resource_dispatch[];
+
+extern struct acpi_rsconvert_info
+    *acpi_gbl_convert_resource_serial_bus_dispatch[];
+
+struct acpi_vendor_walk_info {
+	struct acpi_vendor_uuid *uuid;
+	struct acpi_buffer *buffer;
+	acpi_status status;
+};
+
+/*
+ * rscreate
+ */
+acpi_status
+acpi_rs_create_resource_list(union acpi_operand_object *aml_buffer,
+			     struct acpi_buffer *output_buffer);
+
+acpi_status
+acpi_rs_create_aml_resources(struct acpi_resource *linked_list_buffer,
+			     struct acpi_buffer *output_buffer);
+
+acpi_status
+acpi_rs_create_pci_routing_table(union acpi_operand_object *package_object,
+				 struct acpi_buffer *output_buffer);
+
+/*
+ * rsutils
+ */
+acpi_status
+acpi_rs_get_prt_method_data(struct acpi_namespace_node *node,
+			    struct acpi_buffer *ret_buffer);
+
+acpi_status
+acpi_rs_get_crs_method_data(struct acpi_namespace_node *node,
+			    struct acpi_buffer *ret_buffer);
+
+acpi_status
+acpi_rs_get_prs_method_data(struct acpi_namespace_node *node,
+			    struct acpi_buffer *ret_buffer);
+
+acpi_status
+acpi_rs_get_method_data(acpi_handle handle,
+			char *path, struct acpi_buffer *ret_buffer);
+
+acpi_status
+acpi_rs_set_srs_method_data(struct acpi_namespace_node *node,
+			    struct acpi_buffer *ret_buffer);
+
+acpi_status
+acpi_rs_get_aei_method_data(struct acpi_namespace_node *node,
+			    struct acpi_buffer *ret_buffer);
+
+/*
+ * rscalc
+ */
+acpi_status
+acpi_rs_get_list_length(u8 *aml_buffer,
+			u32 aml_buffer_length, acpi_size * size_needed);
+
+acpi_status
+acpi_rs_get_aml_length(struct acpi_resource *linked_list_buffer,
+		       acpi_size * size_needed);
+
+acpi_status
+acpi_rs_get_pci_routing_table_length(union acpi_operand_object *package_object,
+				     acpi_size * buffer_size_needed);
+
+acpi_status
+acpi_rs_convert_aml_to_resources(u8 *aml,
+				 u32 length,
+				 u32 offset, u8 resource_index, void *context);
+
+acpi_status
+acpi_rs_convert_resources_to_aml(struct acpi_resource *resource,
+				 acpi_size aml_size_needed, u8 *output_buffer);
+
+/*
+ * rsaddr
+ */
+void
+acpi_rs_set_address_common(union aml_resource *aml,
+			   struct acpi_resource *resource);
+
+u8
+acpi_rs_get_address_common(struct acpi_resource *resource,
+			   union aml_resource *aml);
+
+/*
+ * rsmisc
+ */
+acpi_status
+acpi_rs_convert_aml_to_resource(struct acpi_resource *resource,
+				union aml_resource *aml,
+				struct acpi_rsconvert_info *info);
+
+acpi_status
+acpi_rs_convert_resource_to_aml(struct acpi_resource *resource,
+				union aml_resource *aml,
+				struct acpi_rsconvert_info *info);
+
+/*
+ * rsutils
+ */
+void
+acpi_rs_move_data(void *destination,
+		  void *source, u16 item_count, u8 move_type);
+
+u8 acpi_rs_decode_bitmask(u16 mask, u8 *list);
+
+u16 acpi_rs_encode_bitmask(u8 *list, u8 count);
+
+acpi_rs_length
+acpi_rs_get_resource_source(acpi_rs_length resource_length,
+			    acpi_rs_length minimum_length,
+			    struct acpi_resource_source *resource_source,
+			    union aml_resource *aml, char *string_ptr);
+
+acpi_rsdesc_size
+acpi_rs_set_resource_source(union aml_resource *aml,
+			    acpi_rs_length minimum_length,
+			    struct acpi_resource_source *resource_source);
+
+void
+acpi_rs_set_resource_header(u8 descriptor_type,
+			    acpi_rsdesc_size total_length,
+			    union aml_resource *aml);
+
+void
+acpi_rs_set_resource_length(acpi_rsdesc_size total_length,
+			    union aml_resource *aml);
+
+/*
+ * rsdump
+ */
+void acpi_rs_dump_resource_list(struct acpi_resource *resource);
+
+void acpi_rs_dump_irq_list(u8 *route_table);
+
+/*
+ * Resource conversion tables
+ */
+extern struct acpi_rsconvert_info acpi_rs_convert_dma[];
+extern struct acpi_rsconvert_info acpi_rs_convert_end_dpf[];
+extern struct acpi_rsconvert_info acpi_rs_convert_io[];
+extern struct acpi_rsconvert_info acpi_rs_convert_fixed_io[];
+extern struct acpi_rsconvert_info acpi_rs_convert_end_tag[];
+extern struct acpi_rsconvert_info acpi_rs_convert_memory24[];
+extern struct acpi_rsconvert_info acpi_rs_convert_generic_reg[];
+extern struct acpi_rsconvert_info acpi_rs_convert_memory32[];
+extern struct acpi_rsconvert_info acpi_rs_convert_fixed_memory32[];
+extern struct acpi_rsconvert_info acpi_rs_convert_address32[];
+extern struct acpi_rsconvert_info acpi_rs_convert_address16[];
+extern struct acpi_rsconvert_info acpi_rs_convert_ext_irq[];
+extern struct acpi_rsconvert_info acpi_rs_convert_address64[];
+extern struct acpi_rsconvert_info acpi_rs_convert_ext_address64[];
+extern struct acpi_rsconvert_info acpi_rs_convert_gpio[];
+extern struct acpi_rsconvert_info acpi_rs_convert_fixed_dma[];
+extern struct acpi_rsconvert_info acpi_rs_convert_i2c_serial_bus[];
+extern struct acpi_rsconvert_info acpi_rs_convert_spi_serial_bus[];
+extern struct acpi_rsconvert_info acpi_rs_convert_uart_serial_bus[];
+
+/* These resources require separate get/set tables */
+
+extern struct acpi_rsconvert_info acpi_rs_get_irq[];
+extern struct acpi_rsconvert_info acpi_rs_get_start_dpf[];
+extern struct acpi_rsconvert_info acpi_rs_get_vendor_small[];
+extern struct acpi_rsconvert_info acpi_rs_get_vendor_large[];
+
+extern struct acpi_rsconvert_info acpi_rs_set_irq[];
+extern struct acpi_rsconvert_info acpi_rs_set_start_dpf[];
+extern struct acpi_rsconvert_info acpi_rs_set_vendor[];
+
+#if defined(ACPI_DEBUG_OUTPUT) || defined(ACPI_DEBUGGER)
+/*
+ * rsinfo
+ */
+extern struct acpi_rsdump_info *acpi_gbl_dump_resource_dispatch[];
+extern struct acpi_rsdump_info *acpi_gbl_dump_serial_bus_dispatch[];
+
+/*
+ * rsdump
+ */
+extern struct acpi_rsdump_info acpi_rs_dump_irq[];
+extern struct acpi_rsdump_info acpi_rs_dump_dma[];
+extern struct acpi_rsdump_info acpi_rs_dump_start_dpf[];
+extern struct acpi_rsdump_info acpi_rs_dump_end_dpf[];
+extern struct acpi_rsdump_info acpi_rs_dump_io[];
+extern struct acpi_rsdump_info acpi_rs_dump_fixed_io[];
+extern struct acpi_rsdump_info acpi_rs_dump_vendor[];
+extern struct acpi_rsdump_info acpi_rs_dump_end_tag[];
+extern struct acpi_rsdump_info acpi_rs_dump_memory24[];
+extern struct acpi_rsdump_info acpi_rs_dump_memory32[];
+extern struct acpi_rsdump_info acpi_rs_dump_fixed_memory32[];
+extern struct acpi_rsdump_info acpi_rs_dump_address16[];
+extern struct acpi_rsdump_info acpi_rs_dump_address32[];
+extern struct acpi_rsdump_info acpi_rs_dump_address64[];
+extern struct acpi_rsdump_info acpi_rs_dump_ext_address64[];
+extern struct acpi_rsdump_info acpi_rs_dump_ext_irq[];
+extern struct acpi_rsdump_info acpi_rs_dump_generic_reg[];
+extern struct acpi_rsdump_info acpi_rs_dump_gpio[];
+extern struct acpi_rsdump_info acpi_rs_dump_fixed_dma[];
+extern struct acpi_rsdump_info acpi_rs_dump_common_serial_bus[];
+extern struct acpi_rsdump_info acpi_rs_dump_i2c_serial_bus[];
+extern struct acpi_rsdump_info acpi_rs_dump_spi_serial_bus[];
+extern struct acpi_rsdump_info acpi_rs_dump_uart_serial_bus[];
+#endif
+
+#endif				/* __ACRESRC_H__ */
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acstruct.h b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acstruct.h
new file mode 100644
index 00000000..e0af1cee
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acstruct.h
@@ -0,0 +1,228 @@
+/******************************************************************************
+ *
+ * Name: acstruct.h - Internal structs
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACSTRUCT_H__
+#define __ACSTRUCT_H__
+
+/* acpisrc:struct_defs -- for acpisrc conversion */
+
+/*****************************************************************************
+ *
+ * Tree walking typedefs and structs
+ *
+ ****************************************************************************/
+
+/*
+ * Walk state - current state of a parse tree walk.  Used for both a leisurely
+ * stroll through the tree (for whatever reason), and for control method
+ * execution.
+ */
+#define ACPI_NEXT_OP_DOWNWARD       1
+#define ACPI_NEXT_OP_UPWARD         2
+
+/*
+ * Groups of definitions for walk_type used for different implementations of
+ * walkers (never simultaneously) - flags for interpreter:
+ */
+#define ACPI_WALK_NON_METHOD        0
+#define ACPI_WALK_METHOD            0x01
+#define ACPI_WALK_METHOD_RESTART    0x02
+
+/* Flags for i_aSL compiler only */
+
+#define ACPI_WALK_CONST_REQUIRED    0x10
+#define ACPI_WALK_CONST_OPTIONAL    0x20
+
+struct acpi_walk_state {
+	struct acpi_walk_state *next;	/* Next walk_state in list */
+	u8 descriptor_type;	/* To differentiate various internal objs */
+	u8 walk_type;
+	u16 opcode;		/* Current AML opcode */
+	u8 next_op_info;	/* Info about next_op */
+	u8 num_operands;	/* Stack pointer for Operands[] array */
+	u8 operand_index;	/* Index into operand stack, to be used by acpi_ds_obj_stack_push */
+	acpi_owner_id owner_id;	/* Owner of objects created during the walk */
+	u8 last_predicate;	/* Result of last predicate */
+	u8 current_result;
+	u8 return_used;
+	u8 scope_depth;
+	u8 pass_number;		/* Parse pass during table load */
+	u8 result_size;		/* Total elements for the result stack */
+	u8 result_count;	/* Current number of occupied elements of result stack */
+	u32 aml_offset;
+	u32 arg_types;
+	u32 method_breakpoint;	/* For single stepping */
+	u32 user_breakpoint;	/* User AML breakpoint */
+	u32 parse_flags;
+
+	struct acpi_parse_state parser_state;	/* Current state of parser */
+	u32 prev_arg_types;
+	u32 arg_count;		/* push for fixed or var args */
+
+	struct acpi_namespace_node arguments[ACPI_METHOD_NUM_ARGS];	/* Control method arguments */
+	struct acpi_namespace_node local_variables[ACPI_METHOD_NUM_LOCALS];	/* Control method locals */
+	union acpi_operand_object *operands[ACPI_OBJ_NUM_OPERANDS + 1];	/* Operands passed to the interpreter (+1 for NULL terminator) */
+	union acpi_operand_object **params;
+
+	u8 *aml_last_while;
+	union acpi_operand_object **caller_return_desc;
+	union acpi_generic_state *control_state;	/* List of control states (nested IFs) */
+	struct acpi_namespace_node *deferred_node;	/* Used when executing deferred opcodes */
+	union acpi_operand_object *implicit_return_obj;
+	struct acpi_namespace_node *method_call_node;	/* Called method Node */
+	union acpi_parse_object *method_call_op;	/* method_call Op if running a method */
+	union acpi_operand_object *method_desc;	/* Method descriptor if running a method */
+	struct acpi_namespace_node *method_node;	/* Method node if running a method. */
+	union acpi_parse_object *op;	/* Current parser op */
+	const struct acpi_opcode_info *op_info;	/* Info on current opcode */
+	union acpi_parse_object *origin;	/* Start of walk [Obsolete] */
+	union acpi_operand_object *result_obj;
+	union acpi_generic_state *results;	/* Stack of accumulated results */
+	union acpi_operand_object *return_desc;	/* Return object, if any */
+	union acpi_generic_state *scope_info;	/* Stack of nested scopes */
+	union acpi_parse_object *prev_op;	/* Last op that was processed */
+	union acpi_parse_object *next_op;	/* next op to be processed */
+	struct acpi_thread_state *thread;
+	acpi_parse_downwards descending_callback;
+	acpi_parse_upwards ascending_callback;
+};
+
+/* Info used by acpi_ns_initialize_objects and acpi_ds_initialize_objects */
+
+struct acpi_init_walk_info {
+	u32 table_index;
+	u32 object_count;
+	u32 method_count;
+	u32 device_count;
+	u32 op_region_count;
+	u32 field_count;
+	u32 buffer_count;
+	u32 package_count;
+	u32 op_region_init;
+	u32 field_init;
+	u32 buffer_init;
+	u32 package_init;
+	acpi_owner_id owner_id;
+};
+
+struct acpi_get_devices_info {
+	acpi_walk_callback user_function;
+	void *context;
+	char *hid;
+};
+
+union acpi_aml_operands {
+	union acpi_operand_object *operands[7];
+
+	struct {
+		struct acpi_object_integer *type;
+		struct acpi_object_integer *code;
+		struct acpi_object_integer *argument;
+
+	} fatal;
+
+	struct {
+		union acpi_operand_object *source;
+		struct acpi_object_integer *index;
+		union acpi_operand_object *target;
+
+	} index;
+
+	struct {
+		union acpi_operand_object *source;
+		struct acpi_object_integer *index;
+		struct acpi_object_integer *length;
+		union acpi_operand_object *target;
+
+	} mid;
+};
+
+/*
+ * Structure used to pass object evaluation parameters.
+ * Purpose is to reduce CPU stack use.
+ */
+struct acpi_evaluate_info {
+	struct acpi_namespace_node *prefix_node;
+	char *pathname;
+	union acpi_operand_object *obj_desc;
+	union acpi_operand_object **parameters;
+	struct acpi_namespace_node *resolved_node;
+	union acpi_operand_object *return_object;
+	u8 param_count;
+	u8 pass_number;
+	u8 return_object_type;
+	u8 flags;
+};
+
+/* Values for Flags above */
+
+#define ACPI_IGNORE_RETURN_VALUE        1
+
+/* Info used by acpi_ns_initialize_devices */
+
+struct acpi_device_walk_info {
+	struct acpi_table_desc *table_desc;
+	struct acpi_evaluate_info *evaluate_info;
+	u32 device_count;
+	u32 num_STA;
+	u32 num_INI;
+};
+
+/* TBD: [Restructure] Merge with struct above */
+
+struct acpi_walk_info {
+	u32 debug_level;
+	u32 count;
+	acpi_owner_id owner_id;
+	u8 display_type;
+};
+
+/* Display Types */
+
+#define ACPI_DISPLAY_SUMMARY        (u8) 0
+#define ACPI_DISPLAY_OBJECTS        (u8) 1
+#define ACPI_DISPLAY_MASK           (u8) 1
+
+#define ACPI_DISPLAY_SHORT          (u8) 2
+
+#endif
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/actables.h b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/actables.h
new file mode 100644
index 00000000..e22d29d3
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/actables.h
@@ -0,0 +1,120 @@
+/******************************************************************************
+ *
+ * Name: actables.h - ACPI table management
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACTABLES_H__
+#define __ACTABLES_H__
+
+acpi_status acpi_allocate_root_table(u32 initial_table_count);
+
+/*
+ * tbfadt - FADT parse/convert/validate
+ */
+void acpi_tb_parse_fadt(u32 table_index);
+
+void acpi_tb_create_local_fadt(struct acpi_table_header *table, u32 length);
+
+/*
+ * tbfind - find ACPI table
+ */
+acpi_status
+acpi_tb_find_table(char *signature,
+		   char *oem_id, char *oem_table_id, u32 *table_index);
+
+/*
+ * tbinstal - Table removal and deletion
+ */
+acpi_status acpi_tb_resize_root_table_list(void);
+
+acpi_status acpi_tb_verify_table(struct acpi_table_desc *table_desc);
+
+acpi_status
+acpi_tb_add_table(struct acpi_table_desc *table_desc, u32 *table_index);
+
+acpi_status
+acpi_tb_store_table(acpi_physical_address address,
+		    struct acpi_table_header *table,
+		    u32 length, u8 flags, u32 *table_index);
+
+void acpi_tb_delete_table(struct acpi_table_desc *table_desc);
+
+void acpi_tb_terminate(void);
+
+acpi_status acpi_tb_delete_namespace_by_owner(u32 table_index);
+
+acpi_status acpi_tb_allocate_owner_id(u32 table_index);
+
+acpi_status acpi_tb_release_owner_id(u32 table_index);
+
+acpi_status acpi_tb_get_owner_id(u32 table_index, acpi_owner_id * owner_id);
+
+u8 acpi_tb_is_table_loaded(u32 table_index);
+
+void acpi_tb_set_table_loaded_flag(u32 table_index, u8 is_loaded);
+
+/*
+ * tbutils - table manager utilities
+ */
+acpi_status acpi_tb_initialize_facs(void);
+
+u8 acpi_tb_tables_loaded(void);
+
+void
+acpi_tb_print_table_header(acpi_physical_address address,
+			   struct acpi_table_header *header);
+
+u8 acpi_tb_checksum(u8 *buffer, u32 length);
+
+acpi_status
+acpi_tb_verify_checksum(struct acpi_table_header *table, u32 length);
+
+void acpi_tb_check_dsdt_header(void);
+
+struct acpi_table_header *acpi_tb_copy_dsdt(u32 table_index);
+
+void
+acpi_tb_install_table(acpi_physical_address address,
+		      char *signature, u32 table_index);
+
+acpi_status acpi_tb_parse_root_table(acpi_physical_address rsdp_address);
+
+#endif				/* __ACTABLES_H__ */
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acutils.h b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acutils.h
new file mode 100644
index 00000000..2ae299b7
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acutils.h
@@ -0,0 +1,642 @@
+/******************************************************************************
+ *
+ * Name: acutils.h -- prototypes for the common (subsystem-wide) procedures
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef _ACUTILS_H
+#define _ACUTILS_H
+
+extern const u8 acpi_gbl_resource_aml_sizes[];
+extern const u8 acpi_gbl_resource_aml_serial_bus_sizes[];
+
+/* Strings used by the disassembler and debugger resource dump routines */
+
+#if defined(ACPI_DISASSEMBLER) || defined (ACPI_DEBUGGER)
+
+extern const char *acpi_gbl_bm_decode[];
+extern const char *acpi_gbl_config_decode[];
+extern const char *acpi_gbl_consume_decode[];
+extern const char *acpi_gbl_dec_decode[];
+extern const char *acpi_gbl_he_decode[];
+extern const char *acpi_gbl_io_decode[];
+extern const char *acpi_gbl_ll_decode[];
+extern const char *acpi_gbl_max_decode[];
+extern const char *acpi_gbl_mem_decode[];
+extern const char *acpi_gbl_min_decode[];
+extern const char *acpi_gbl_mtp_decode[];
+extern const char *acpi_gbl_rng_decode[];
+extern const char *acpi_gbl_rw_decode[];
+extern const char *acpi_gbl_shr_decode[];
+extern const char *acpi_gbl_siz_decode[];
+extern const char *acpi_gbl_trs_decode[];
+extern const char *acpi_gbl_ttp_decode[];
+extern const char *acpi_gbl_typ_decode[];
+extern const char *acpi_gbl_ppc_decode[];
+extern const char *acpi_gbl_ior_decode[];
+extern const char *acpi_gbl_dts_decode[];
+extern const char *acpi_gbl_ct_decode[];
+extern const char *acpi_gbl_sbt_decode[];
+extern const char *acpi_gbl_am_decode[];
+extern const char *acpi_gbl_sm_decode[];
+extern const char *acpi_gbl_wm_decode[];
+extern const char *acpi_gbl_cph_decode[];
+extern const char *acpi_gbl_cpo_decode[];
+extern const char *acpi_gbl_dp_decode[];
+extern const char *acpi_gbl_ed_decode[];
+extern const char *acpi_gbl_bpb_decode[];
+extern const char *acpi_gbl_sb_decode[];
+extern const char *acpi_gbl_fc_decode[];
+extern const char *acpi_gbl_pt_decode[];
+#endif
+
+/* Types for Resource descriptor entries */
+
+#define ACPI_INVALID_RESOURCE           0
+#define ACPI_FIXED_LENGTH               1
+#define ACPI_VARIABLE_LENGTH            2
+#define ACPI_SMALL_VARIABLE_LENGTH      3
+
+typedef
+acpi_status(*acpi_walk_aml_callback) (u8 *aml,
+				      u32 length,
+				      u32 offset,
+				      u8 resource_index, void *context);
+
+typedef
+acpi_status(*acpi_pkg_callback) (u8 object_type,
+				 union acpi_operand_object *source_object,
+				 union acpi_generic_state * state,
+				 void *context);
+
+struct acpi_pkg_info {
+	u8 *free_space;
+	acpi_size length;
+	u32 object_space;
+	u32 num_packages;
+};
+
+#define REF_INCREMENT       (u16) 0
+#define REF_DECREMENT       (u16) 1
+#define REF_FORCE_DELETE    (u16) 2
+
+/* acpi_ut_dump_buffer */
+
+#define DB_BYTE_DISPLAY     1
+#define DB_WORD_DISPLAY     2
+#define DB_DWORD_DISPLAY    4
+#define DB_QWORD_DISPLAY    8
+
+/*
+ * utglobal - Global data structures and procedures
+ */
+acpi_status acpi_ut_init_globals(void);
+
+#if defined(ACPI_DEBUG_OUTPUT) || defined(ACPI_DEBUGGER)
+
+char *acpi_ut_get_mutex_name(u32 mutex_id);
+
+const char *acpi_ut_get_notify_name(u32 notify_value);
+
+#endif
+
+char *acpi_ut_get_type_name(acpi_object_type type);
+
+char *acpi_ut_get_node_name(void *object);
+
+char *acpi_ut_get_descriptor_name(void *object);
+
+const char *acpi_ut_get_reference_name(union acpi_operand_object *object);
+
+char *acpi_ut_get_object_type_name(union acpi_operand_object *obj_desc);
+
+char *acpi_ut_get_region_name(u8 space_id);
+
+char *acpi_ut_get_event_name(u32 event_id);
+
+char acpi_ut_hex_to_ascii_char(u64 integer, u32 position);
+
+u8 acpi_ut_valid_object_type(acpi_object_type type);
+
+/*
+ * utinit - miscellaneous initialization and shutdown
+ */
+acpi_status acpi_ut_hardware_initialize(void);
+
+void acpi_ut_subsystem_shutdown(void);
+
+/*
+ * utclib - Local implementations of C library functions
+ */
+#ifndef ACPI_USE_SYSTEM_CLIBRARY
+
+acpi_size acpi_ut_strlen(const char *string);
+
+char *acpi_ut_strcpy(char *dst_string, const char *src_string);
+
+char *acpi_ut_strncpy(char *dst_string,
+		      const char *src_string, acpi_size count);
+
+int acpi_ut_memcmp(const char *buffer1, const char *buffer2, acpi_size count);
+
+int acpi_ut_strncmp(const char *string1, const char *string2, acpi_size count);
+
+int acpi_ut_strcmp(const char *string1, const char *string2);
+
+char *acpi_ut_strcat(char *dst_string, const char *src_string);
+
+char *acpi_ut_strncat(char *dst_string,
+		      const char *src_string, acpi_size count);
+
+u32 acpi_ut_strtoul(const char *string, char **terminator, u32 base);
+
+char *acpi_ut_strstr(char *string1, char *string2);
+
+void *acpi_ut_memcpy(void *dest, const void *src, acpi_size count);
+
+void *acpi_ut_memset(void *dest, u8 value, acpi_size count);
+
+int acpi_ut_to_upper(int c);
+
+int acpi_ut_to_lower(int c);
+
+extern const u8 _acpi_ctype[];
+
+#define _ACPI_XA     0x00	/* extra alphabetic - not supported */
+#define _ACPI_XS     0x40	/* extra space */
+#define _ACPI_BB     0x00	/* BEL, BS, etc. - not supported */
+#define _ACPI_CN     0x20	/* CR, FF, HT, NL, VT */
+#define _ACPI_DI     0x04	/* '0'-'9' */
+#define _ACPI_LO     0x02	/* 'a'-'z' */
+#define _ACPI_PU     0x10	/* punctuation */
+#define _ACPI_SP     0x08	/* space */
+#define _ACPI_UP     0x01	/* 'A'-'Z' */
+#define _ACPI_XD     0x80	/* '0'-'9', 'A'-'F', 'a'-'f' */
+
+#define ACPI_IS_DIGIT(c)  (_acpi_ctype[(unsigned char)(c)] & (_ACPI_DI))
+#define ACPI_IS_SPACE(c)  (_acpi_ctype[(unsigned char)(c)] & (_ACPI_SP))
+#define ACPI_IS_XDIGIT(c) (_acpi_ctype[(unsigned char)(c)] & (_ACPI_XD))
+#define ACPI_IS_UPPER(c)  (_acpi_ctype[(unsigned char)(c)] & (_ACPI_UP))
+#define ACPI_IS_LOWER(c)  (_acpi_ctype[(unsigned char)(c)] & (_ACPI_LO))
+#define ACPI_IS_PRINT(c)  (_acpi_ctype[(unsigned char)(c)] & (_ACPI_LO | _ACPI_UP | _ACPI_DI | _ACPI_SP | _ACPI_PU))
+#define ACPI_IS_ALPHA(c)  (_acpi_ctype[(unsigned char)(c)] & (_ACPI_LO | _ACPI_UP))
+
+#endif				/* !ACPI_USE_SYSTEM_CLIBRARY */
+
+#define ACPI_IS_ASCII(c)  ((c) < 0x80)
+
+/*
+ * utcopy - Object construction and conversion interfaces
+ */
+acpi_status
+acpi_ut_build_simple_object(union acpi_operand_object *obj,
+			    union acpi_object *user_obj,
+			    u8 *data_space, u32 *buffer_space_used);
+
+acpi_status
+acpi_ut_build_package_object(union acpi_operand_object *obj,
+			     u8 *buffer, u32 *space_used);
+
+acpi_status
+acpi_ut_copy_iobject_to_eobject(union acpi_operand_object *obj,
+				struct acpi_buffer *ret_buffer);
+
+acpi_status
+acpi_ut_copy_eobject_to_iobject(union acpi_object *obj,
+				union acpi_operand_object **internal_obj);
+
+acpi_status
+acpi_ut_copy_isimple_to_isimple(union acpi_operand_object *source_obj,
+				union acpi_operand_object *dest_obj);
+
+acpi_status
+acpi_ut_copy_iobject_to_iobject(union acpi_operand_object *source_desc,
+				union acpi_operand_object **dest_desc,
+				struct acpi_walk_state *walk_state);
+
+/*
+ * utcreate - Object creation
+ */
+acpi_status
+acpi_ut_update_object_reference(union acpi_operand_object *object, u16 action);
+
+/*
+ * utdebug - Debug interfaces
+ */
+void acpi_ut_init_stack_ptr_trace(void);
+
+void acpi_ut_track_stack_ptr(void);
+
+void
+acpi_ut_trace(u32 line_number,
+	      const char *function_name,
+	      const char *module_name, u32 component_id);
+
+void
+acpi_ut_trace_ptr(u32 line_number,
+		  const char *function_name,
+		  const char *module_name, u32 component_id, void *pointer);
+
+void
+acpi_ut_trace_u32(u32 line_number,
+		  const char *function_name,
+		  const char *module_name, u32 component_id, u32 integer);
+
+void
+acpi_ut_trace_str(u32 line_number,
+		  const char *function_name,
+		  const char *module_name, u32 component_id, char *string);
+
+void
+acpi_ut_exit(u32 line_number,
+	     const char *function_name,
+	     const char *module_name, u32 component_id);
+
+void
+acpi_ut_status_exit(u32 line_number,
+		    const char *function_name,
+		    const char *module_name,
+		    u32 component_id, acpi_status status);
+
+void
+acpi_ut_value_exit(u32 line_number,
+		   const char *function_name,
+		   const char *module_name, u32 component_id, u64 value);
+
+void
+acpi_ut_ptr_exit(u32 line_number,
+		 const char *function_name,
+		 const char *module_name, u32 component_id, u8 *ptr);
+
+void acpi_ut_dump_buffer(u8 *buffer, u32 count, u32 display, u32 component_id);
+
+void acpi_ut_dump_buffer2(u8 *buffer, u32 count, u32 display);
+
+void acpi_ut_report_error(char *module_name, u32 line_number);
+
+void acpi_ut_report_info(char *module_name, u32 line_number);
+
+void acpi_ut_report_warning(char *module_name, u32 line_number);
+
+/*
+ * utdelete - Object deletion and reference counts
+ */
+void acpi_ut_add_reference(union acpi_operand_object *object);
+
+void acpi_ut_remove_reference(union acpi_operand_object *object);
+
+void acpi_ut_delete_internal_package_object(union acpi_operand_object *object);
+
+void acpi_ut_delete_internal_simple_object(union acpi_operand_object *object);
+
+void acpi_ut_delete_internal_object_list(union acpi_operand_object **obj_list);
+
+/*
+ * uteval - object evaluation
+ */
+acpi_status
+acpi_ut_evaluate_object(struct acpi_namespace_node *prefix_node,
+			char *path,
+			u32 expected_return_btypes,
+			union acpi_operand_object **return_desc);
+
+acpi_status
+acpi_ut_evaluate_numeric_object(char *object_name,
+				struct acpi_namespace_node *device_node,
+				u64 *value);
+
+acpi_status
+acpi_ut_execute_STA(struct acpi_namespace_node *device_node, u32 *status_flags);
+
+acpi_status
+acpi_ut_execute_power_methods(struct acpi_namespace_node *device_node,
+			      const char **method_names,
+			      u8 method_count, u8 *out_values);
+
+/*
+ * utids - device ID support
+ */
+acpi_status
+acpi_ut_execute_HID(struct acpi_namespace_node *device_node,
+		    struct acpi_device_id **return_id);
+
+acpi_status
+acpi_ut_execute_UID(struct acpi_namespace_node *device_node,
+		    struct acpi_device_id **return_id);
+
+acpi_status
+acpi_ut_execute_CID(struct acpi_namespace_node *device_node,
+		    struct acpi_device_id_list **return_cid_list);
+
+/*
+ * utlock - reader/writer locks
+ */
+acpi_status acpi_ut_create_rw_lock(struct acpi_rw_lock *lock);
+
+void acpi_ut_delete_rw_lock(struct acpi_rw_lock *lock);
+
+acpi_status acpi_ut_acquire_read_lock(struct acpi_rw_lock *lock);
+
+acpi_status acpi_ut_release_read_lock(struct acpi_rw_lock *lock);
+
+acpi_status acpi_ut_acquire_write_lock(struct acpi_rw_lock *lock);
+
+void acpi_ut_release_write_lock(struct acpi_rw_lock *lock);
+
+/*
+ * utobject - internal object create/delete/cache routines
+ */
+union acpi_operand_object *acpi_ut_create_internal_object_dbg(const char
+							      *module_name,
+							      u32 line_number,
+							      u32 component_id,
+							      acpi_object_type
+							      type);
+
+void *acpi_ut_allocate_object_desc_dbg(const char *module_name,
+				       u32 line_number, u32 component_id);
+
+#define acpi_ut_create_internal_object(t) acpi_ut_create_internal_object_dbg (_acpi_module_name,__LINE__,_COMPONENT,t)
+#define acpi_ut_allocate_object_desc()  acpi_ut_allocate_object_desc_dbg (_acpi_module_name,__LINE__,_COMPONENT)
+
+void acpi_ut_delete_object_desc(union acpi_operand_object *object);
+
+u8 acpi_ut_valid_internal_object(void *object);
+
+union acpi_operand_object *acpi_ut_create_package_object(u32 count);
+
+union acpi_operand_object *acpi_ut_create_integer_object(u64 value);
+
+union acpi_operand_object *acpi_ut_create_buffer_object(acpi_size buffer_size);
+
+union acpi_operand_object *acpi_ut_create_string_object(acpi_size string_size);
+
+acpi_status
+acpi_ut_get_object_size(union acpi_operand_object *obj, acpi_size * obj_length);
+
+/*
+ * utosi - Support for the _OSI predefined control method
+ */
+acpi_status acpi_ut_initialize_interfaces(void);
+
+void acpi_ut_interface_terminate(void);
+
+acpi_status acpi_ut_install_interface(acpi_string interface_name);
+
+acpi_status acpi_ut_remove_interface(acpi_string interface_name);
+
+struct acpi_interface_info *acpi_ut_get_interface(acpi_string interface_name);
+
+acpi_status acpi_ut_osi_implementation(struct acpi_walk_state *walk_state);
+
+/*
+ * utstate - Generic state creation/cache routines
+ */
+void
+acpi_ut_push_generic_state(union acpi_generic_state **list_head,
+			   union acpi_generic_state *state);
+
+union acpi_generic_state *acpi_ut_pop_generic_state(union acpi_generic_state
+						    **list_head);
+
+union acpi_generic_state *acpi_ut_create_generic_state(void);
+
+struct acpi_thread_state *acpi_ut_create_thread_state(void);
+
+union acpi_generic_state *acpi_ut_create_update_state(union acpi_operand_object
+						      *object, u16 action);
+
+union acpi_generic_state *acpi_ut_create_pkg_state(void *internal_object,
+						   void *external_object,
+						   u16 index);
+
+acpi_status
+acpi_ut_create_update_state_and_push(union acpi_operand_object *object,
+				     u16 action,
+				     union acpi_generic_state **state_list);
+
+acpi_status
+acpi_ut_create_pkg_state_and_push(void *internal_object,
+				  void *external_object,
+				  u16 index,
+				  union acpi_generic_state **state_list);
+
+union acpi_generic_state *acpi_ut_create_control_state(void);
+
+void acpi_ut_delete_generic_state(union acpi_generic_state *state);
+
+/*
+ * utmath
+ */
+acpi_status
+acpi_ut_divide(u64 in_dividend,
+	       u64 in_divisor, u64 *out_quotient, u64 *out_remainder);
+
+acpi_status
+acpi_ut_short_divide(u64 in_dividend,
+		     u32 divisor, u64 *out_quotient, u32 *out_remainder);
+
+/*
+ * utmisc
+ */
+const char *acpi_ut_validate_exception(acpi_status status);
+
+u8 acpi_ut_is_pci_root_bridge(char *id);
+
+u8 acpi_ut_is_aml_table(struct acpi_table_header *table);
+
+acpi_status acpi_ut_allocate_owner_id(acpi_owner_id * owner_id);
+
+void acpi_ut_release_owner_id(acpi_owner_id * owner_id);
+
+acpi_status
+acpi_ut_walk_package_tree(union acpi_operand_object *source_object,
+			  void *target_object,
+			  acpi_pkg_callback walk_callback, void *context);
+
+void acpi_ut_strupr(char *src_string);
+
+void acpi_ut_strlwr(char *src_string);
+
+int acpi_ut_stricmp(char *string1, char *string2);
+
+void acpi_ut_print_string(char *string, u8 max_length);
+
+u8 acpi_ut_valid_acpi_name(u32 name);
+
+void acpi_ut_repair_name(char *name);
+
+u8 acpi_ut_valid_acpi_char(char character, u32 position);
+
+acpi_status acpi_ut_strtoul64(char *string, u32 base, u64 *ret_integer);
+
+/* Values for Base above (16=Hex, 10=Decimal) */
+
+#define ACPI_ANY_BASE        0
+
+u32 acpi_ut_dword_byte_swap(u32 value);
+
+void acpi_ut_set_integer_width(u8 revision);
+
+#ifdef ACPI_DEBUG_OUTPUT
+void
+acpi_ut_display_init_pathname(u8 type,
+			      struct acpi_namespace_node *obj_handle,
+			      char *path);
+#endif
+
+/*
+ * utresrc
+ */
+acpi_status
+acpi_ut_walk_aml_resources(u8 *aml,
+			   acpi_size aml_length,
+			   acpi_walk_aml_callback user_function, void *context);
+
+acpi_status acpi_ut_validate_resource(void *aml, u8 *return_index);
+
+u32 acpi_ut_get_descriptor_length(void *aml);
+
+u16 acpi_ut_get_resource_length(void *aml);
+
+u8 acpi_ut_get_resource_header_length(void *aml);
+
+u8 acpi_ut_get_resource_type(void *aml);
+
+acpi_status
+acpi_ut_get_resource_end_tag(union acpi_operand_object *obj_desc, u8 **end_tag);
+
+/*
+ * utmutex - mutex support
+ */
+acpi_status acpi_ut_mutex_initialize(void);
+
+void acpi_ut_mutex_terminate(void);
+
+acpi_status acpi_ut_acquire_mutex(acpi_mutex_handle mutex_id);
+
+acpi_status acpi_ut_release_mutex(acpi_mutex_handle mutex_id);
+
+/*
+ * utalloc - memory allocation and object caching
+ */
+acpi_status acpi_ut_create_caches(void);
+
+acpi_status acpi_ut_delete_caches(void);
+
+acpi_status acpi_ut_validate_buffer(struct acpi_buffer *buffer);
+
+acpi_status
+acpi_ut_initialize_buffer(struct acpi_buffer *buffer,
+			  acpi_size required_length);
+
+void *acpi_ut_allocate(acpi_size size,
+		       u32 component, const char *module, u32 line);
+
+void *acpi_ut_allocate_zeroed(acpi_size size,
+			      u32 component, const char *module, u32 line);
+
+#ifdef ACPI_DBG_TRACK_ALLOCATIONS
+void *acpi_ut_allocate_and_track(acpi_size size,
+				 u32 component, const char *module, u32 line);
+
+void *acpi_ut_allocate_zeroed_and_track(acpi_size size,
+					u32 component,
+					const char *module, u32 line);
+
+void
+acpi_ut_free_and_track(void *address,
+		       u32 component, const char *module, u32 line);
+
+void acpi_ut_dump_allocation_info(void);
+
+void acpi_ut_dump_allocations(u32 component, const char *module);
+
+acpi_status
+acpi_ut_create_list(char *list_name,
+		    u16 object_size, struct acpi_memory_list **return_cache);
+
+#endif				/* ACPI_DBG_TRACK_ALLOCATIONS */
+
+/*
+ * utaddress - address range check
+ */
+acpi_status
+acpi_ut_add_address_range(acpi_adr_space_type space_id,
+			  acpi_physical_address address,
+			  u32 length, struct acpi_namespace_node *region_node);
+
+void
+acpi_ut_remove_address_range(acpi_adr_space_type space_id,
+			     struct acpi_namespace_node *region_node);
+
+u32
+acpi_ut_check_address_range(acpi_adr_space_type space_id,
+			    acpi_physical_address address, u32 length, u8 warn);
+
+void acpi_ut_delete_address_lists(void);
+
+/*
+ * utxferror - various error/warning output functions
+ */
+void ACPI_INTERNAL_VAR_XFACE
+acpi_ut_predefined_warning(const char *module_name,
+			   u32 line_number,
+			   char *pathname,
+			   u8 node_flags, const char *format, ...);
+
+void ACPI_INTERNAL_VAR_XFACE
+acpi_ut_predefined_info(const char *module_name,
+			u32 line_number,
+			char *pathname, u8 node_flags, const char *format, ...);
+
+void
+acpi_ut_namespace_error(const char *module_name,
+			u32 line_number,
+			const char *internal_name, acpi_status lookup_status);
+
+void
+acpi_ut_method_error(const char *module_name,
+		     u32 line_number,
+		     const char *message,
+		     struct acpi_namespace_node *node,
+		     const char *path, acpi_status lookup_status);
+
+#endif				/* _ACUTILS_H */
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/amlcode.h b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/amlcode.h
new file mode 100644
index 00000000..905280fe
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/amlcode.h
@@ -0,0 +1,487 @@
+/******************************************************************************
+ *
+ * Name: amlcode.h - Definitions for AML, as included in "definition blocks"
+ *                   Declarations and definitions contained herein are derived
+ *                   directly from the ACPI specification.
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __AMLCODE_H__
+#define __AMLCODE_H__
+
+/* primary opcodes */
+
+#define AML_NULL_CHAR               (u16) 0x00
+
+#define AML_ZERO_OP                 (u16) 0x00
+#define AML_ONE_OP                  (u16) 0x01
+#define AML_UNASSIGNED              (u16) 0x02
+#define AML_ALIAS_OP                (u16) 0x06
+#define AML_NAME_OP                 (u16) 0x08
+#define AML_BYTE_OP                 (u16) 0x0a
+#define AML_WORD_OP                 (u16) 0x0b
+#define AML_DWORD_OP                (u16) 0x0c
+#define AML_STRING_OP               (u16) 0x0d
+#define AML_QWORD_OP                (u16) 0x0e	/* ACPI 2.0 */
+#define AML_SCOPE_OP                (u16) 0x10
+#define AML_BUFFER_OP               (u16) 0x11
+#define AML_PACKAGE_OP              (u16) 0x12
+#define AML_VAR_PACKAGE_OP          (u16) 0x13	/* ACPI 2.0 */
+#define AML_METHOD_OP               (u16) 0x14
+#define AML_DUAL_NAME_PREFIX        (u16) 0x2e
+#define AML_MULTI_NAME_PREFIX_OP    (u16) 0x2f
+#define AML_NAME_CHAR_SUBSEQ        (u16) 0x30
+#define AML_NAME_CHAR_FIRST         (u16) 0x41
+#define AML_EXTENDED_OP_PREFIX      (u16) 0x5b
+#define AML_ROOT_PREFIX             (u16) 0x5c
+#define AML_PARENT_PREFIX           (u16) 0x5e
+#define AML_LOCAL_OP                (u16) 0x60
+#define AML_LOCAL0                  (u16) 0x60
+#define AML_LOCAL1                  (u16) 0x61
+#define AML_LOCAL2                  (u16) 0x62
+#define AML_LOCAL3                  (u16) 0x63
+#define AML_LOCAL4                  (u16) 0x64
+#define AML_LOCAL5                  (u16) 0x65
+#define AML_LOCAL6                  (u16) 0x66
+#define AML_LOCAL7                  (u16) 0x67
+#define AML_ARG_OP                  (u16) 0x68
+#define AML_ARG0                    (u16) 0x68
+#define AML_ARG1                    (u16) 0x69
+#define AML_ARG2                    (u16) 0x6a
+#define AML_ARG3                    (u16) 0x6b
+#define AML_ARG4                    (u16) 0x6c
+#define AML_ARG5                    (u16) 0x6d
+#define AML_ARG6                    (u16) 0x6e
+#define AML_STORE_OP                (u16) 0x70
+#define AML_REF_OF_OP               (u16) 0x71
+#define AML_ADD_OP                  (u16) 0x72
+#define AML_CONCAT_OP               (u16) 0x73
+#define AML_SUBTRACT_OP             (u16) 0x74
+#define AML_INCREMENT_OP            (u16) 0x75
+#define AML_DECREMENT_OP            (u16) 0x76
+#define AML_MULTIPLY_OP             (u16) 0x77
+#define AML_DIVIDE_OP               (u16) 0x78
+#define AML_SHIFT_LEFT_OP           (u16) 0x79
+#define AML_SHIFT_RIGHT_OP          (u16) 0x7a
+#define AML_BIT_AND_OP              (u16) 0x7b
+#define AML_BIT_NAND_OP             (u16) 0x7c
+#define AML_BIT_OR_OP               (u16) 0x7d
+#define AML_BIT_NOR_OP              (u16) 0x7e
+#define AML_BIT_XOR_OP              (u16) 0x7f
+#define AML_BIT_NOT_OP              (u16) 0x80
+#define AML_FIND_SET_LEFT_BIT_OP    (u16) 0x81
+#define AML_FIND_SET_RIGHT_BIT_OP   (u16) 0x82
+#define AML_DEREF_OF_OP             (u16) 0x83
+#define AML_CONCAT_RES_OP           (u16) 0x84	/* ACPI 2.0 */
+#define AML_MOD_OP                  (u16) 0x85	/* ACPI 2.0 */
+#define AML_NOTIFY_OP               (u16) 0x86
+#define AML_SIZE_OF_OP              (u16) 0x87
+#define AML_INDEX_OP                (u16) 0x88
+#define AML_MATCH_OP                (u16) 0x89
+#define AML_CREATE_DWORD_FIELD_OP   (u16) 0x8a
+#define AML_CREATE_WORD_FIELD_OP    (u16) 0x8b
+#define AML_CREATE_BYTE_FIELD_OP    (u16) 0x8c
+#define AML_CREATE_BIT_FIELD_OP     (u16) 0x8d
+#define AML_TYPE_OP                 (u16) 0x8e
+#define AML_CREATE_QWORD_FIELD_OP   (u16) 0x8f	/* ACPI 2.0 */
+#define AML_LAND_OP                 (u16) 0x90
+#define AML_LOR_OP                  (u16) 0x91
+#define AML_LNOT_OP                 (u16) 0x92
+#define AML_LEQUAL_OP               (u16) 0x93
+#define AML_LGREATER_OP             (u16) 0x94
+#define AML_LLESS_OP                (u16) 0x95
+#define AML_TO_BUFFER_OP            (u16) 0x96	/* ACPI 2.0 */
+#define AML_TO_DECSTRING_OP         (u16) 0x97	/* ACPI 2.0 */
+#define AML_TO_HEXSTRING_OP         (u16) 0x98	/* ACPI 2.0 */
+#define AML_TO_INTEGER_OP           (u16) 0x99	/* ACPI 2.0 */
+#define AML_TO_STRING_OP            (u16) 0x9c	/* ACPI 2.0 */
+#define AML_COPY_OP                 (u16) 0x9d	/* ACPI 2.0 */
+#define AML_MID_OP                  (u16) 0x9e	/* ACPI 2.0 */
+#define AML_CONTINUE_OP             (u16) 0x9f	/* ACPI 2.0 */
+#define AML_IF_OP                   (u16) 0xa0
+#define AML_ELSE_OP                 (u16) 0xa1
+#define AML_WHILE_OP                (u16) 0xa2
+#define AML_NOOP_OP                 (u16) 0xa3
+#define AML_RETURN_OP               (u16) 0xa4
+#define AML_BREAK_OP                (u16) 0xa5
+#define AML_BREAK_POINT_OP          (u16) 0xcc
+#define AML_ONES_OP                 (u16) 0xff
+
+/* prefixed opcodes */
+
+#define AML_EXTENDED_OPCODE         (u16) 0x5b00	/* prefix for 2-byte opcodes */
+
+#define AML_MUTEX_OP                (u16) 0x5b01
+#define AML_EVENT_OP                (u16) 0x5b02
+#define AML_SHIFT_RIGHT_BIT_OP      (u16) 0x5b10
+#define AML_SHIFT_LEFT_BIT_OP       (u16) 0x5b11
+#define AML_COND_REF_OF_OP          (u16) 0x5b12
+#define AML_CREATE_FIELD_OP         (u16) 0x5b13
+#define AML_LOAD_TABLE_OP           (u16) 0x5b1f	/* ACPI 2.0 */
+#define AML_LOAD_OP                 (u16) 0x5b20
+#define AML_STALL_OP                (u16) 0x5b21
+#define AML_SLEEP_OP                (u16) 0x5b22
+#define AML_ACQUIRE_OP              (u16) 0x5b23
+#define AML_SIGNAL_OP               (u16) 0x5b24
+#define AML_WAIT_OP                 (u16) 0x5b25
+#define AML_RESET_OP                (u16) 0x5b26
+#define AML_RELEASE_OP              (u16) 0x5b27
+#define AML_FROM_BCD_OP             (u16) 0x5b28
+#define AML_TO_BCD_OP               (u16) 0x5b29
+#define AML_UNLOAD_OP               (u16) 0x5b2a
+#define AML_REVISION_OP             (u16) 0x5b30
+#define AML_DEBUG_OP                (u16) 0x5b31
+#define AML_FATAL_OP                (u16) 0x5b32
+#define AML_TIMER_OP                (u16) 0x5b33	/* ACPI 3.0 */
+#define AML_REGION_OP               (u16) 0x5b80
+#define AML_FIELD_OP                (u16) 0x5b81
+#define AML_DEVICE_OP               (u16) 0x5b82
+#define AML_PROCESSOR_OP            (u16) 0x5b83
+#define AML_POWER_RES_OP            (u16) 0x5b84
+#define AML_THERMAL_ZONE_OP         (u16) 0x5b85
+#define AML_INDEX_FIELD_OP          (u16) 0x5b86
+#define AML_BANK_FIELD_OP           (u16) 0x5b87
+#define AML_DATA_REGION_OP          (u16) 0x5b88	/* ACPI 2.0 */
+
+/*
+ * Combination opcodes (actually two one-byte opcodes)
+ * Used by the disassembler and i_aSL compiler
+ */
+#define AML_LGREATEREQUAL_OP        (u16) 0x9295
+#define AML_LLESSEQUAL_OP           (u16) 0x9294
+#define AML_LNOTEQUAL_OP            (u16) 0x9293
+
+/*
+ * Opcodes for "Field" operators
+ */
+#define AML_FIELD_OFFSET_OP         (u8) 0x00
+#define AML_FIELD_ACCESS_OP         (u8) 0x01
+#define AML_FIELD_CONNECTION_OP     (u8) 0x02	/* ACPI 5.0 */
+#define AML_FIELD_EXT_ACCESS_OP     (u8) 0x03	/* ACPI 5.0 */
+
+/*
+ * Internal opcodes
+ * Use only "Unknown" AML opcodes, don't attempt to use
+ * any valid ACPI ASCII values (A-Z, 0-9, '-')
+ */
+#define AML_INT_NAMEPATH_OP         (u16) 0x002d
+#define AML_INT_NAMEDFIELD_OP       (u16) 0x0030
+#define AML_INT_RESERVEDFIELD_OP    (u16) 0x0031
+#define AML_INT_ACCESSFIELD_OP      (u16) 0x0032
+#define AML_INT_BYTELIST_OP         (u16) 0x0033
+#define AML_INT_STATICSTRING_OP     (u16) 0x0034
+#define AML_INT_METHODCALL_OP       (u16) 0x0035
+#define AML_INT_RETURN_VALUE_OP     (u16) 0x0036
+#define AML_INT_EVAL_SUBTREE_OP     (u16) 0x0037
+#define AML_INT_CONNECTION_OP       (u16) 0x0038
+#define AML_INT_EXTACCESSFIELD_OP   (u16) 0x0039
+
+#define ARG_NONE                    0x0
+
+/*
+ * Argument types for the AML Parser
+ * Each field in the arg_types u32 is 5 bits, allowing for a maximum of 6 arguments.
+ * There can be up to 31 unique argument types
+ * Zero is reserved as end-of-list indicator
+ */
+#define ARGP_BYTEDATA               0x01
+#define ARGP_BYTELIST               0x02
+#define ARGP_CHARLIST               0x03
+#define ARGP_DATAOBJ                0x04
+#define ARGP_DATAOBJLIST            0x05
+#define ARGP_DWORDDATA              0x06
+#define ARGP_FIELDLIST              0x07
+#define ARGP_NAME                   0x08
+#define ARGP_NAMESTRING             0x09
+#define ARGP_OBJLIST                0x0A
+#define ARGP_PKGLENGTH              0x0B
+#define ARGP_SUPERNAME              0x0C
+#define ARGP_TARGET                 0x0D
+#define ARGP_TERMARG                0x0E
+#define ARGP_TERMLIST               0x0F
+#define ARGP_WORDDATA               0x10
+#define ARGP_QWORDDATA              0x11
+#define ARGP_SIMPLENAME             0x12
+
+/*
+ * Resolved argument types for the AML Interpreter
+ * Each field in the arg_types u32 is 5 bits, allowing for a maximum of 6 arguments.
+ * There can be up to 31 unique argument types (0 is end-of-arg-list indicator)
+ *
+ * Note1: These values are completely independent from the ACPI_TYPEs
+ *        i.e., ARGI_INTEGER != ACPI_TYPE_INTEGER
+ *
+ * Note2: If and when 5 bits becomes insufficient, it would probably be best
+ * to convert to a 6-byte array of argument types, allowing 8 bits per argument.
+ */
+
+/* Single, simple types */
+
+#define ARGI_ANYTYPE                0x01	/* Don't care */
+#define ARGI_PACKAGE                0x02
+#define ARGI_EVENT                  0x03
+#define ARGI_MUTEX                  0x04
+#define ARGI_DDBHANDLE              0x05
+
+/* Interchangeable types (via implicit conversion) */
+
+#define ARGI_INTEGER                0x06
+#define ARGI_STRING                 0x07
+#define ARGI_BUFFER                 0x08
+#define ARGI_BUFFER_OR_STRING       0x09	/* Used by MID op only */
+#define ARGI_COMPUTEDATA            0x0A	/* Buffer, String, or Integer */
+
+/* Reference objects */
+
+#define ARGI_INTEGER_REF            0x0B
+#define ARGI_OBJECT_REF             0x0C
+#define ARGI_DEVICE_REF             0x0D
+#define ARGI_REFERENCE              0x0E
+#define ARGI_TARGETREF              0x0F	/* Target, subject to implicit conversion */
+#define ARGI_FIXED_TARGET           0x10	/* Target, no implicit conversion */
+#define ARGI_SIMPLE_TARGET          0x11	/* Name, Local, Arg -- no implicit conversion */
+
+/* Multiple/complex types */
+
+#define ARGI_DATAOBJECT             0x12	/* Buffer, String, package or reference to a Node - Used only by size_of operator */
+#define ARGI_COMPLEXOBJ             0x13	/* Buffer, String, or package (Used by INDEX op only) */
+#define ARGI_REF_OR_STRING          0x14	/* Reference or String (Used by DEREFOF op only) */
+#define ARGI_REGION_OR_BUFFER       0x15	/* Used by LOAD op only */
+#define ARGI_DATAREFOBJ             0x16
+
+/* Note: types above can expand to 0x1F maximum */
+
+#define ARGI_INVALID_OPCODE         0xFFFFFFFF
+
+/*
+ * hash offsets
+ */
+#define AML_EXTOP_HASH_OFFSET       22
+#define AML_LNOT_HASH_OFFSET        19
+
+/*
+ * opcode groups and types
+ */
+#define OPGRP_NAMED                 0x01
+#define OPGRP_FIELD                 0x02
+#define OPGRP_BYTELIST              0x04
+
+/*
+ * Opcode information
+ */
+
+/* Opcode flags */
+
+#define AML_LOGICAL                 0x0001
+#define AML_LOGICAL_NUMERIC         0x0002
+#define AML_MATH                    0x0004
+#define AML_CREATE                  0x0008
+#define AML_FIELD                   0x0010
+#define AML_DEFER                   0x0020
+#define AML_NAMED                   0x0040
+#define AML_NSNODE                  0x0080
+#define AML_NSOPCODE                0x0100
+#define AML_NSOBJECT                0x0200
+#define AML_HAS_RETVAL              0x0400
+#define AML_HAS_TARGET              0x0800
+#define AML_HAS_ARGS                0x1000
+#define AML_CONSTANT                0x2000
+#define AML_NO_OPERAND_RESOLVE      0x4000
+
+/* Convenient flag groupings */
+
+#define AML_FLAGS_EXEC_0A_0T_1R                                     AML_HAS_RETVAL
+#define AML_FLAGS_EXEC_1A_0T_0R     AML_HAS_ARGS	/* Monadic1  */
+#define AML_FLAGS_EXEC_1A_0T_1R     AML_HAS_ARGS |                  AML_HAS_RETVAL	/* Monadic2  */
+#define AML_FLAGS_EXEC_1A_1T_0R     AML_HAS_ARGS | AML_HAS_TARGET
+#define AML_FLAGS_EXEC_1A_1T_1R     AML_HAS_ARGS | AML_HAS_TARGET | AML_HAS_RETVAL	/* monadic2_r */
+#define AML_FLAGS_EXEC_2A_0T_0R     AML_HAS_ARGS	/* Dyadic1   */
+#define AML_FLAGS_EXEC_2A_0T_1R     AML_HAS_ARGS |                  AML_HAS_RETVAL	/* Dyadic2   */
+#define AML_FLAGS_EXEC_2A_1T_1R     AML_HAS_ARGS | AML_HAS_TARGET | AML_HAS_RETVAL	/* dyadic2_r  */
+#define AML_FLAGS_EXEC_2A_2T_1R     AML_HAS_ARGS | AML_HAS_TARGET | AML_HAS_RETVAL
+#define AML_FLAGS_EXEC_3A_0T_0R     AML_HAS_ARGS
+#define AML_FLAGS_EXEC_3A_1T_1R     AML_HAS_ARGS | AML_HAS_TARGET | AML_HAS_RETVAL
+#define AML_FLAGS_EXEC_6A_0T_1R     AML_HAS_ARGS |                  AML_HAS_RETVAL
+
+/*
+ * The opcode Type is used in a dispatch table, do not change
+ * without updating the table.
+ */
+#define AML_TYPE_EXEC_0A_0T_1R      0x00
+#define AML_TYPE_EXEC_1A_0T_0R      0x01	/* Monadic1  */
+#define AML_TYPE_EXEC_1A_0T_1R      0x02	/* Monadic2  */
+#define AML_TYPE_EXEC_1A_1T_0R      0x03
+#define AML_TYPE_EXEC_1A_1T_1R      0x04	/* monadic2_r */
+#define AML_TYPE_EXEC_2A_0T_0R      0x05	/* Dyadic1   */
+#define AML_TYPE_EXEC_2A_0T_1R      0x06	/* Dyadic2   */
+#define AML_TYPE_EXEC_2A_1T_1R      0x07	/* dyadic2_r  */
+#define AML_TYPE_EXEC_2A_2T_1R      0x08
+#define AML_TYPE_EXEC_3A_0T_0R      0x09
+#define AML_TYPE_EXEC_3A_1T_1R      0x0A
+#define AML_TYPE_EXEC_6A_0T_1R      0x0B
+/* End of types used in dispatch table */
+
+#define AML_TYPE_LITERAL            0x0B
+#define AML_TYPE_CONSTANT           0x0C
+#define AML_TYPE_METHOD_ARGUMENT    0x0D
+#define AML_TYPE_LOCAL_VARIABLE     0x0E
+#define AML_TYPE_DATA_TERM          0x0F
+
+/* Generic for an op that returns a value */
+
+#define AML_TYPE_METHOD_CALL        0x10
+
+/* Misc */
+
+#define AML_TYPE_CREATE_FIELD       0x11
+#define AML_TYPE_CREATE_OBJECT      0x12
+#define AML_TYPE_CONTROL            0x13
+#define AML_TYPE_NAMED_NO_OBJ       0x14
+#define AML_TYPE_NAMED_FIELD        0x15
+#define AML_TYPE_NAMED_SIMPLE       0x16
+#define AML_TYPE_NAMED_COMPLEX      0x17
+#define AML_TYPE_RETURN             0x18
+
+#define AML_TYPE_UNDEFINED          0x19
+#define AML_TYPE_BOGUS              0x1A
+
+/* AML Package Length encodings */
+
+#define ACPI_AML_PACKAGE_TYPE1      0x40
+#define ACPI_AML_PACKAGE_TYPE2      0x4000
+#define ACPI_AML_PACKAGE_TYPE3      0x400000
+#define ACPI_AML_PACKAGE_TYPE4      0x40000000
+
+/*
+ * Opcode classes
+ */
+#define AML_CLASS_EXECUTE           0x00
+#define AML_CLASS_CREATE            0x01
+#define AML_CLASS_ARGUMENT          0x02
+#define AML_CLASS_NAMED_OBJECT      0x03
+#define AML_CLASS_CONTROL           0x04
+#define AML_CLASS_ASCII             0x05
+#define AML_CLASS_PREFIX            0x06
+#define AML_CLASS_INTERNAL          0x07
+#define AML_CLASS_RETURN_VALUE      0x08
+#define AML_CLASS_METHOD_CALL       0x09
+#define AML_CLASS_UNKNOWN           0x0A
+
+/* Comparison operation codes for match_op operator */
+
+typedef enum {
+	MATCH_MTR = 0,
+	MATCH_MEQ = 1,
+	MATCH_MLE = 2,
+	MATCH_MLT = 3,
+	MATCH_MGE = 4,
+	MATCH_MGT = 5
+} AML_MATCH_OPERATOR;
+
+#define MAX_MATCH_OPERATOR          5
+
+/*
+ * field_flags
+ *
+ * This byte is extracted from the AML and includes three separate
+ * pieces of information about the field:
+ * 1) The field access type
+ * 2) The field update rule
+ * 3) The lock rule for the field
+ *
+ * Bits 00 - 03 : access_type (any_acc, byte_acc, etc.)
+ *      04      : lock_rule (1 == Lock)
+ *      05 - 06 : update_rule
+ */
+#define AML_FIELD_ACCESS_TYPE_MASK  0x0F
+#define AML_FIELD_LOCK_RULE_MASK    0x10
+#define AML_FIELD_UPDATE_RULE_MASK  0x60
+
+/* 1) Field Access Types */
+
+typedef enum {
+	AML_FIELD_ACCESS_ANY = 0x00,
+	AML_FIELD_ACCESS_BYTE = 0x01,
+	AML_FIELD_ACCESS_WORD = 0x02,
+	AML_FIELD_ACCESS_DWORD = 0x03,
+	AML_FIELD_ACCESS_QWORD = 0x04,	/* ACPI 2.0 */
+	AML_FIELD_ACCESS_BUFFER = 0x05	/* ACPI 2.0 */
+} AML_ACCESS_TYPE;
+
+/* 2) Field Lock Rules */
+
+typedef enum {
+	AML_FIELD_LOCK_NEVER = 0x00,
+	AML_FIELD_LOCK_ALWAYS = 0x10
+} AML_LOCK_RULE;
+
+/* 3) Field Update Rules */
+
+typedef enum {
+	AML_FIELD_UPDATE_PRESERVE = 0x00,
+	AML_FIELD_UPDATE_WRITE_AS_ONES = 0x20,
+	AML_FIELD_UPDATE_WRITE_AS_ZEROS = 0x40
+} AML_UPDATE_RULE;
+
+/*
+ * Field Access Attributes.
+ * This byte is extracted from the AML via the
+ * access_as keyword
+ */
+typedef enum {
+	AML_FIELD_ATTRIB_QUICK = 0x02,
+	AML_FIELD_ATTRIB_SEND_RCV = 0x04,
+	AML_FIELD_ATTRIB_BYTE = 0x06,
+	AML_FIELD_ATTRIB_WORD = 0x08,
+	AML_FIELD_ATTRIB_BLOCK = 0x0A,
+	AML_FIELD_ATTRIB_MULTIBYTE = 0x0B,
+	AML_FIELD_ATTRIB_WORD_CALL = 0x0C,
+	AML_FIELD_ATTRIB_BLOCK_CALL = 0x0D,
+	AML_FIELD_ATTRIB_RAW_BYTES = 0x0E,
+	AML_FIELD_ATTRIB_RAW_PROCESS = 0x0F
+} AML_ACCESS_ATTRIBUTE;
+
+/* Bit fields in the AML method_flags byte */
+
+#define AML_METHOD_ARG_COUNT        0x07
+#define AML_METHOD_SERIALIZED       0x08
+#define AML_METHOD_SYNC_LEVEL       0xF0
+
+#endif				/* __AMLCODE_H__ */
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/amlresrc.h b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/amlresrc.h
new file mode 100644
index 00000000..7f618a53
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/amlresrc.h
@@ -0,0 +1,453 @@
+
+/******************************************************************************
+ *
+ * Module Name: amlresrc.h - AML resource descriptors
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+/* acpisrc:struct_defs -- for acpisrc conversion */
+
+#ifndef __AMLRESRC_H
+#define __AMLRESRC_H
+
+/*
+ * Resource descriptor tags, as defined in the ACPI specification.
+ * Used to symbolically reference fields within a descriptor.
+ */
+#define ACPI_RESTAG_ADDRESS                     "_ADR"
+#define ACPI_RESTAG_ALIGNMENT                   "_ALN"
+#define ACPI_RESTAG_ADDRESSSPACE                "_ASI"
+#define ACPI_RESTAG_ACCESSSIZE                  "_ASZ"
+#define ACPI_RESTAG_TYPESPECIFICATTRIBUTES      "_ATT"
+#define ACPI_RESTAG_BASEADDRESS                 "_BAS"
+#define ACPI_RESTAG_BUSMASTER                   "_BM_"	/* Master(1), Slave(0) */
+#define ACPI_RESTAG_DEBOUNCETIME                "_DBT"
+#define ACPI_RESTAG_DECODE                      "_DEC"
+#define ACPI_RESTAG_DEVICEPOLARITY              "_DPL"
+#define ACPI_RESTAG_DMA                         "_DMA"
+#define ACPI_RESTAG_DMATYPE                     "_TYP"	/* Compatible(0), A(1), B(2), F(3) */
+#define ACPI_RESTAG_DRIVESTRENGTH               "_DRS"
+#define ACPI_RESTAG_ENDIANNESS                  "_END"
+#define ACPI_RESTAG_FLOWCONTROL                 "_FLC"
+#define ACPI_RESTAG_GRANULARITY                 "_GRA"
+#define ACPI_RESTAG_INTERRUPT                   "_INT"
+#define ACPI_RESTAG_INTERRUPTLEVEL              "_LL_"	/* active_lo(1), active_hi(0) */
+#define ACPI_RESTAG_INTERRUPTSHARE              "_SHR"	/* Shareable(1), no_share(0) */
+#define ACPI_RESTAG_INTERRUPTTYPE               "_HE_"	/* Edge(1), Level(0) */
+#define ACPI_RESTAG_IORESTRICTION               "_IOR"
+#define ACPI_RESTAG_LENGTH                      "_LEN"
+#define ACPI_RESTAG_LINE                        "_LIN"
+#define ACPI_RESTAG_MEMATTRIBUTES               "_MTP"	/* Memory(0), Reserved(1), ACPI(2), NVS(3) */
+#define ACPI_RESTAG_MEMTYPE                     "_MEM"	/* non_cache(0), Cacheable(1) Cache+combine(2), Cache+prefetch(3) */
+#define ACPI_RESTAG_MAXADDR                     "_MAX"
+#define ACPI_RESTAG_MINADDR                     "_MIN"
+#define ACPI_RESTAG_MAXTYPE                     "_MAF"
+#define ACPI_RESTAG_MINTYPE                     "_MIF"
+#define ACPI_RESTAG_MODE                        "_MOD"
+#define ACPI_RESTAG_PARITY                      "_PAR"
+#define ACPI_RESTAG_PHASE                       "_PHA"
+#define ACPI_RESTAG_PIN                         "_PIN"
+#define ACPI_RESTAG_PINCONFIG                   "_PPI"
+#define ACPI_RESTAG_POLARITY                    "_POL"
+#define ACPI_RESTAG_REGISTERBITOFFSET           "_RBO"
+#define ACPI_RESTAG_REGISTERBITWIDTH            "_RBW"
+#define ACPI_RESTAG_RANGETYPE                   "_RNG"
+#define ACPI_RESTAG_READWRITETYPE               "_RW_"	/* read_only(0), Writeable (1) */
+#define ACPI_RESTAG_LENGTH_RX                   "_RXL"
+#define ACPI_RESTAG_LENGTH_TX                   "_TXL"
+#define ACPI_RESTAG_SLAVEMODE                   "_SLV"
+#define ACPI_RESTAG_SPEED                       "_SPE"
+#define ACPI_RESTAG_STOPBITS                    "_STB"
+#define ACPI_RESTAG_TRANSLATION                 "_TRA"
+#define ACPI_RESTAG_TRANSTYPE                   "_TRS"	/* Sparse(1), Dense(0) */
+#define ACPI_RESTAG_TYPE                        "_TTP"	/* Translation(1), Static (0) */
+#define ACPI_RESTAG_XFERTYPE                    "_SIZ"	/* 8(0), 8_and16(1), 16(2) */
+#define ACPI_RESTAG_VENDORDATA                  "_VEN"
+
+/* Default sizes for "small" resource descriptors */
+
+#define ASL_RDESC_IRQ_SIZE                      0x02
+#define ASL_RDESC_DMA_SIZE                      0x02
+#define ASL_RDESC_ST_DEPEND_SIZE                0x00
+#define ASL_RDESC_END_DEPEND_SIZE               0x00
+#define ASL_RDESC_IO_SIZE                       0x07
+#define ASL_RDESC_FIXED_IO_SIZE                 0x03
+#define ASL_RDESC_FIXED_DMA_SIZE                0x05
+#define ASL_RDESC_END_TAG_SIZE                  0x01
+
+struct asl_resource_node {
+	u32 buffer_length;
+	void *buffer;
+	struct asl_resource_node *next;
+};
+
+/* Macros used to generate AML resource length fields */
+
+#define ACPI_AML_SIZE_LARGE(r)      (sizeof (r) - sizeof (struct aml_resource_large_header))
+#define ACPI_AML_SIZE_SMALL(r)      (sizeof (r) - sizeof (struct aml_resource_small_header))
+
+/*
+ * Resource descriptors defined in the ACPI specification.
+ *
+ * Packing/alignment must be BYTE because these descriptors
+ * are used to overlay the raw AML byte stream.
+ */
+#pragma pack(1)
+
+/*
+ * SMALL descriptors
+ */
+#define AML_RESOURCE_SMALL_HEADER_COMMON \
+	u8                              descriptor_type;
+
+struct aml_resource_small_header {
+AML_RESOURCE_SMALL_HEADER_COMMON};
+
+struct aml_resource_irq {
+	AML_RESOURCE_SMALL_HEADER_COMMON u16 irq_mask;
+	u8 flags;
+};
+
+struct aml_resource_irq_noflags {
+	AML_RESOURCE_SMALL_HEADER_COMMON u16 irq_mask;
+};
+
+struct aml_resource_dma {
+	AML_RESOURCE_SMALL_HEADER_COMMON u8 dma_channel_mask;
+	u8 flags;
+};
+
+struct aml_resource_start_dependent {
+	AML_RESOURCE_SMALL_HEADER_COMMON u8 flags;
+};
+
+struct aml_resource_start_dependent_noprio {
+AML_RESOURCE_SMALL_HEADER_COMMON};
+
+struct aml_resource_end_dependent {
+AML_RESOURCE_SMALL_HEADER_COMMON};
+
+struct aml_resource_io {
+	AML_RESOURCE_SMALL_HEADER_COMMON u8 flags;
+	u16 minimum;
+	u16 maximum;
+	u8 alignment;
+	u8 address_length;
+};
+
+struct aml_resource_fixed_io {
+	AML_RESOURCE_SMALL_HEADER_COMMON u16 address;
+	u8 address_length;
+};
+
+struct aml_resource_vendor_small {
+AML_RESOURCE_SMALL_HEADER_COMMON};
+
+struct aml_resource_end_tag {
+	AML_RESOURCE_SMALL_HEADER_COMMON u8 checksum;
+};
+
+struct aml_resource_fixed_dma {
+	AML_RESOURCE_SMALL_HEADER_COMMON u16 request_lines;
+	u16 channels;
+	u8 width;
+};
+
+/*
+ * LARGE descriptors
+ */
+#define AML_RESOURCE_LARGE_HEADER_COMMON \
+	u8                              descriptor_type;\
+	u16                             resource_length;
+
+struct aml_resource_large_header {
+AML_RESOURCE_LARGE_HEADER_COMMON};
+
+/* General Flags for address space resource descriptors */
+
+#define ACPI_RESOURCE_FLAG_DEC      2
+#define ACPI_RESOURCE_FLAG_MIF      4
+#define ACPI_RESOURCE_FLAG_MAF      8
+
+struct aml_resource_memory24 {
+	AML_RESOURCE_LARGE_HEADER_COMMON u8 flags;
+	u16 minimum;
+	u16 maximum;
+	u16 alignment;
+	u16 address_length;
+};
+
+struct aml_resource_vendor_large {
+AML_RESOURCE_LARGE_HEADER_COMMON};
+
+struct aml_resource_memory32 {
+	AML_RESOURCE_LARGE_HEADER_COMMON u8 flags;
+	u32 minimum;
+	u32 maximum;
+	u32 alignment;
+	u32 address_length;
+};
+
+struct aml_resource_fixed_memory32 {
+	AML_RESOURCE_LARGE_HEADER_COMMON u8 flags;
+	u32 address;
+	u32 address_length;
+};
+
+#define AML_RESOURCE_ADDRESS_COMMON \
+	u8                              resource_type; \
+	u8                              flags; \
+	u8                              specific_flags;
+
+struct aml_resource_address {
+AML_RESOURCE_LARGE_HEADER_COMMON AML_RESOURCE_ADDRESS_COMMON};
+
+struct aml_resource_extended_address64 {
+	AML_RESOURCE_LARGE_HEADER_COMMON
+	    AML_RESOURCE_ADDRESS_COMMON u8 revision_iD;
+	u8 reserved;
+	u64 granularity;
+	u64 minimum;
+	u64 maximum;
+	u64 translation_offset;
+	u64 address_length;
+	u64 type_specific;
+};
+
+#define AML_RESOURCE_EXTENDED_ADDRESS_REVISION          1	/* ACPI 3.0 */
+
+struct aml_resource_address64 {
+	AML_RESOURCE_LARGE_HEADER_COMMON
+	    AML_RESOURCE_ADDRESS_COMMON u64 granularity;
+	u64 minimum;
+	u64 maximum;
+	u64 translation_offset;
+	u64 address_length;
+};
+
+struct aml_resource_address32 {
+	AML_RESOURCE_LARGE_HEADER_COMMON
+	    AML_RESOURCE_ADDRESS_COMMON u32 granularity;
+	u32 minimum;
+	u32 maximum;
+	u32 translation_offset;
+	u32 address_length;
+};
+
+struct aml_resource_address16 {
+	AML_RESOURCE_LARGE_HEADER_COMMON
+	    AML_RESOURCE_ADDRESS_COMMON u16 granularity;
+	u16 minimum;
+	u16 maximum;
+	u16 translation_offset;
+	u16 address_length;
+};
+
+struct aml_resource_extended_irq {
+	AML_RESOURCE_LARGE_HEADER_COMMON u8 flags;
+	u8 interrupt_count;
+	u32 interrupts[1];
+	/* res_source_index, res_source optional fields follow */
+};
+
+struct aml_resource_generic_register {
+	AML_RESOURCE_LARGE_HEADER_COMMON u8 address_space_id;
+	u8 bit_width;
+	u8 bit_offset;
+	u8 access_size;		/* ACPI 3.0, was previously Reserved */
+	u64 address;
+};
+
+/* Common descriptor for gpio_int and gpio_io (ACPI 5.0) */
+
+struct aml_resource_gpio {
+	AML_RESOURCE_LARGE_HEADER_COMMON u8 revision_id;
+	u8 connection_type;
+	u16 flags;
+	u16 int_flags;
+	u8 pin_config;
+	u16 drive_strength;
+	u16 debounce_timeout;
+	u16 pin_table_offset;
+	u8 res_source_index;
+	u16 res_source_offset;
+	u16 vendor_offset;
+	u16 vendor_length;
+	/*
+	 * Optional fields follow immediately:
+	 * 1) PIN list (Words)
+	 * 2) Resource Source String
+	 * 3) Vendor Data bytes
+	 */
+};
+
+#define AML_RESOURCE_GPIO_REVISION              1	/* ACPI 5.0 */
+
+/* Values for connection_type above */
+
+#define AML_RESOURCE_GPIO_TYPE_INT              0
+#define AML_RESOURCE_GPIO_TYPE_IO               1
+#define AML_RESOURCE_MAX_GPIOTYPE               1
+
+/* Common preamble for all serial descriptors (ACPI 5.0) */
+
+#define AML_RESOURCE_SERIAL_COMMON \
+	u8                              revision_id; \
+	u8                              res_source_index; \
+	u8                              type; \
+	u8                              flags; \
+	u16                             type_specific_flags; \
+	u8                              type_revision_id; \
+	u16                             type_data_length; \
+
+/* Values for the type field above */
+
+#define AML_RESOURCE_I2C_SERIALBUSTYPE          1
+#define AML_RESOURCE_SPI_SERIALBUSTYPE          2
+#define AML_RESOURCE_UART_SERIALBUSTYPE         3
+#define AML_RESOURCE_MAX_SERIALBUSTYPE          3
+#define AML_RESOURCE_VENDOR_SERIALBUSTYPE       192	/* Vendor defined is 0xC0-0xFF (NOT SUPPORTED) */
+
+struct aml_resource_common_serialbus {
+AML_RESOURCE_LARGE_HEADER_COMMON AML_RESOURCE_SERIAL_COMMON};
+
+struct aml_resource_i2c_serialbus {
+	AML_RESOURCE_LARGE_HEADER_COMMON
+	    AML_RESOURCE_SERIAL_COMMON u32 connection_speed;
+	u16 slave_address;
+	/*
+	 * Optional fields follow immediately:
+	 * 1) Vendor Data bytes
+	 * 2) Resource Source String
+	 */
+};
+
+#define AML_RESOURCE_I2C_REVISION               1	/* ACPI 5.0 */
+#define AML_RESOURCE_I2C_TYPE_REVISION          1	/* ACPI 5.0 */
+#define AML_RESOURCE_I2C_MIN_DATA_LEN           6
+
+struct aml_resource_spi_serialbus {
+	AML_RESOURCE_LARGE_HEADER_COMMON
+	    AML_RESOURCE_SERIAL_COMMON u32 connection_speed;
+	u8 data_bit_length;
+	u8 clock_phase;
+	u8 clock_polarity;
+	u16 device_selection;
+	/*
+	 * Optional fields follow immediately:
+	 * 1) Vendor Data bytes
+	 * 2) Resource Source String
+	 */
+};
+
+#define AML_RESOURCE_SPI_REVISION               1	/* ACPI 5.0 */
+#define AML_RESOURCE_SPI_TYPE_REVISION          1	/* ACPI 5.0 */
+#define AML_RESOURCE_SPI_MIN_DATA_LEN           9
+
+struct aml_resource_uart_serialbus {
+	AML_RESOURCE_LARGE_HEADER_COMMON
+	    AML_RESOURCE_SERIAL_COMMON u32 default_baud_rate;
+	u16 rx_fifo_size;
+	u16 tx_fifo_size;
+	u8 parity;
+	u8 lines_enabled;
+	/*
+	 * Optional fields follow immediately:
+	 * 1) Vendor Data bytes
+	 * 2) Resource Source String
+	 */
+};
+
+#define AML_RESOURCE_UART_REVISION              1	/* ACPI 5.0 */
+#define AML_RESOURCE_UART_TYPE_REVISION         1	/* ACPI 5.0 */
+#define AML_RESOURCE_UART_MIN_DATA_LEN          10
+
+/* restore default alignment */
+
+#pragma pack()
+
+/* Union of all resource descriptors, so we can allocate the worst case */
+
+union aml_resource {
+	/* Descriptor headers */
+
+	u8 descriptor_type;
+	struct aml_resource_small_header small_header;
+	struct aml_resource_large_header large_header;
+
+	/* Small resource descriptors */
+
+	struct aml_resource_irq irq;
+	struct aml_resource_dma dma;
+	struct aml_resource_start_dependent start_dpf;
+	struct aml_resource_end_dependent end_dpf;
+	struct aml_resource_io io;
+	struct aml_resource_fixed_io fixed_io;
+	struct aml_resource_fixed_dma fixed_dma;
+	struct aml_resource_vendor_small vendor_small;
+	struct aml_resource_end_tag end_tag;
+
+	/* Large resource descriptors */
+
+	struct aml_resource_memory24 memory24;
+	struct aml_resource_generic_register generic_reg;
+	struct aml_resource_vendor_large vendor_large;
+	struct aml_resource_memory32 memory32;
+	struct aml_resource_fixed_memory32 fixed_memory32;
+	struct aml_resource_address16 address16;
+	struct aml_resource_address32 address32;
+	struct aml_resource_address64 address64;
+	struct aml_resource_extended_address64 ext_address64;
+	struct aml_resource_extended_irq extended_irq;
+	struct aml_resource_gpio gpio;
+	struct aml_resource_i2c_serialbus i2c_serial_bus;
+	struct aml_resource_spi_serialbus spi_serial_bus;
+	struct aml_resource_uart_serialbus uart_serial_bus;
+	struct aml_resource_common_serialbus common_serial_bus;
+
+	/* Utility overlays */
+
+	struct aml_resource_address address;
+	u32 dword_item;
+	u16 word_item;
+	u8 byte_item;
+};
+
+#endif
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/dsargs.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/dsargs.c
new file mode 100644
index 00000000..1277e61d
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/dsargs.c
@@ -0,0 +1,398 @@
+/******************************************************************************
+ *
+ * Module Name: dsargs - Support for execution of dynamic arguments for static
+ *                       objects (regions, fields, buffer fields, etc.)
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acparser.h"
+#include "amlcode.h"
+#include "acdispat.h"
+#include "acnamesp.h"
+
+#define _COMPONENT          ACPI_DISPATCHER
+ACPI_MODULE_NAME("dsargs")
+
+/* Local prototypes */
+static acpi_status
+acpi_ds_execute_arguments(struct acpi_namespace_node *node,
+			  struct acpi_namespace_node *scope_node,
+			  u32 aml_length, u8 *aml_start);
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_execute_arguments
+ *
+ * PARAMETERS:  Node                - Object NS node
+ *              scope_node          - Parent NS node
+ *              aml_length          - Length of executable AML
+ *              aml_start           - Pointer to the AML
+ *
+ * RETURN:      Status.
+ *
+ * DESCRIPTION: Late (deferred) execution of region or field arguments
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ds_execute_arguments(struct acpi_namespace_node *node,
+			  struct acpi_namespace_node *scope_node,
+			  u32 aml_length, u8 *aml_start)
+{
+	acpi_status status;
+	union acpi_parse_object *op;
+	struct acpi_walk_state *walk_state;
+
+	ACPI_FUNCTION_TRACE(ds_execute_arguments);
+
+	/* Allocate a new parser op to be the root of the parsed tree */
+
+	op = acpi_ps_alloc_op(AML_INT_EVAL_SUBTREE_OP);
+	if (!op) {
+		return_ACPI_STATUS(AE_NO_MEMORY);
+	}
+
+	/* Save the Node for use in acpi_ps_parse_aml */
+
+	op->common.node = scope_node;
+
+	/* Create and initialize a new parser state */
+
+	walk_state = acpi_ds_create_walk_state(0, NULL, NULL, NULL);
+	if (!walk_state) {
+		status = AE_NO_MEMORY;
+		goto cleanup;
+	}
+
+	status = acpi_ds_init_aml_walk(walk_state, op, NULL, aml_start,
+				       aml_length, NULL, ACPI_IMODE_LOAD_PASS1);
+	if (ACPI_FAILURE(status)) {
+		acpi_ds_delete_walk_state(walk_state);
+		goto cleanup;
+	}
+
+	/* Mark this parse as a deferred opcode */
+
+	walk_state->parse_flags = ACPI_PARSE_DEFERRED_OP;
+	walk_state->deferred_node = node;
+
+	/* Pass1: Parse the entire declaration */
+
+	status = acpi_ps_parse_aml(walk_state);
+	if (ACPI_FAILURE(status)) {
+		goto cleanup;
+	}
+
+	/* Get and init the Op created above */
+
+	op->common.node = node;
+	acpi_ps_delete_parse_tree(op);
+
+	/* Evaluate the deferred arguments */
+
+	op = acpi_ps_alloc_op(AML_INT_EVAL_SUBTREE_OP);
+	if (!op) {
+		return_ACPI_STATUS(AE_NO_MEMORY);
+	}
+
+	op->common.node = scope_node;
+
+	/* Create and initialize a new parser state */
+
+	walk_state = acpi_ds_create_walk_state(0, NULL, NULL, NULL);
+	if (!walk_state) {
+		status = AE_NO_MEMORY;
+		goto cleanup;
+	}
+
+	/* Execute the opcode and arguments */
+
+	status = acpi_ds_init_aml_walk(walk_state, op, NULL, aml_start,
+				       aml_length, NULL, ACPI_IMODE_EXECUTE);
+	if (ACPI_FAILURE(status)) {
+		acpi_ds_delete_walk_state(walk_state);
+		goto cleanup;
+	}
+
+	/* Mark this execution as a deferred opcode */
+
+	walk_state->deferred_node = node;
+	status = acpi_ps_parse_aml(walk_state);
+
+      cleanup:
+	acpi_ps_delete_parse_tree(op);
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_get_buffer_field_arguments
+ *
+ * PARAMETERS:  obj_desc        - A valid buffer_field object
+ *
+ * RETURN:      Status.
+ *
+ * DESCRIPTION: Get buffer_field Buffer and Index. This implements the late
+ *              evaluation of these field attributes.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ds_get_buffer_field_arguments(union acpi_operand_object *obj_desc)
+{
+	union acpi_operand_object *extra_desc;
+	struct acpi_namespace_node *node;
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE_PTR(ds_get_buffer_field_arguments, obj_desc);
+
+	if (obj_desc->common.flags & AOPOBJ_DATA_VALID) {
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	/* Get the AML pointer (method object) and buffer_field node */
+
+	extra_desc = acpi_ns_get_secondary_object(obj_desc);
+	node = obj_desc->buffer_field.node;
+
+	ACPI_DEBUG_EXEC(acpi_ut_display_init_pathname(ACPI_TYPE_BUFFER_FIELD,
+						      node, NULL));
+
+	ACPI_DEBUG_PRINT((ACPI_DB_EXEC, "[%4.4s] BufferField Arg Init\n",
+			  acpi_ut_get_node_name(node)));
+
+	/* Execute the AML code for the term_arg arguments */
+
+	status = acpi_ds_execute_arguments(node, node->parent,
+					   extra_desc->extra.aml_length,
+					   extra_desc->extra.aml_start);
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_get_bank_field_arguments
+ *
+ * PARAMETERS:  obj_desc        - A valid bank_field object
+ *
+ * RETURN:      Status.
+ *
+ * DESCRIPTION: Get bank_field bank_value. This implements the late
+ *              evaluation of these field attributes.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ds_get_bank_field_arguments(union acpi_operand_object *obj_desc)
+{
+	union acpi_operand_object *extra_desc;
+	struct acpi_namespace_node *node;
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE_PTR(ds_get_bank_field_arguments, obj_desc);
+
+	if (obj_desc->common.flags & AOPOBJ_DATA_VALID) {
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	/* Get the AML pointer (method object) and bank_field node */
+
+	extra_desc = acpi_ns_get_secondary_object(obj_desc);
+	node = obj_desc->bank_field.node;
+
+	ACPI_DEBUG_EXEC(acpi_ut_display_init_pathname
+			(ACPI_TYPE_LOCAL_BANK_FIELD, node, NULL));
+
+	ACPI_DEBUG_PRINT((ACPI_DB_EXEC, "[%4.4s] BankField Arg Init\n",
+			  acpi_ut_get_node_name(node)));
+
+	/* Execute the AML code for the term_arg arguments */
+
+	status = acpi_ds_execute_arguments(node, node->parent,
+					   extra_desc->extra.aml_length,
+					   extra_desc->extra.aml_start);
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_get_buffer_arguments
+ *
+ * PARAMETERS:  obj_desc        - A valid Buffer object
+ *
+ * RETURN:      Status.
+ *
+ * DESCRIPTION: Get Buffer length and initializer byte list. This implements
+ *              the late evaluation of these attributes.
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ds_get_buffer_arguments(union acpi_operand_object *obj_desc)
+{
+	struct acpi_namespace_node *node;
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE_PTR(ds_get_buffer_arguments, obj_desc);
+
+	if (obj_desc->common.flags & AOPOBJ_DATA_VALID) {
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	/* Get the Buffer node */
+
+	node = obj_desc->buffer.node;
+	if (!node) {
+		ACPI_ERROR((AE_INFO,
+			    "No pointer back to namespace node in buffer object %p",
+			    obj_desc));
+		return_ACPI_STATUS(AE_AML_INTERNAL);
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_EXEC, "Buffer Arg Init\n"));
+
+	/* Execute the AML code for the term_arg arguments */
+
+	status = acpi_ds_execute_arguments(node, node,
+					   obj_desc->buffer.aml_length,
+					   obj_desc->buffer.aml_start);
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_get_package_arguments
+ *
+ * PARAMETERS:  obj_desc        - A valid Package object
+ *
+ * RETURN:      Status.
+ *
+ * DESCRIPTION: Get Package length and initializer byte list. This implements
+ *              the late evaluation of these attributes.
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ds_get_package_arguments(union acpi_operand_object *obj_desc)
+{
+	struct acpi_namespace_node *node;
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE_PTR(ds_get_package_arguments, obj_desc);
+
+	if (obj_desc->common.flags & AOPOBJ_DATA_VALID) {
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	/* Get the Package node */
+
+	node = obj_desc->package.node;
+	if (!node) {
+		ACPI_ERROR((AE_INFO,
+			    "No pointer back to namespace node in package %p",
+			    obj_desc));
+		return_ACPI_STATUS(AE_AML_INTERNAL);
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_EXEC, "Package Arg Init\n"));
+
+	/* Execute the AML code for the term_arg arguments */
+
+	status = acpi_ds_execute_arguments(node, node,
+					   obj_desc->package.aml_length,
+					   obj_desc->package.aml_start);
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_get_region_arguments
+ *
+ * PARAMETERS:  obj_desc        - A valid region object
+ *
+ * RETURN:      Status.
+ *
+ * DESCRIPTION: Get region address and length. This implements the late
+ *              evaluation of these region attributes.
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ds_get_region_arguments(union acpi_operand_object *obj_desc)
+{
+	struct acpi_namespace_node *node;
+	acpi_status status;
+	union acpi_operand_object *extra_desc;
+
+	ACPI_FUNCTION_TRACE_PTR(ds_get_region_arguments, obj_desc);
+
+	if (obj_desc->region.flags & AOPOBJ_DATA_VALID) {
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	extra_desc = acpi_ns_get_secondary_object(obj_desc);
+	if (!extra_desc) {
+		return_ACPI_STATUS(AE_NOT_EXIST);
+	}
+
+	/* Get the Region node */
+
+	node = obj_desc->region.node;
+
+	ACPI_DEBUG_EXEC(acpi_ut_display_init_pathname
+			(ACPI_TYPE_REGION, node, NULL));
+
+	ACPI_DEBUG_PRINT((ACPI_DB_EXEC, "[%4.4s] OpRegion Arg Init at AML %p\n",
+			  acpi_ut_get_node_name(node),
+			  extra_desc->extra.aml_start));
+
+	/* Execute the argument AML */
+
+	status = acpi_ds_execute_arguments(node, extra_desc->extra.scope_node,
+					   extra_desc->extra.aml_length,
+					   extra_desc->extra.aml_start);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	status = acpi_ut_add_address_range(obj_desc->region.space_id,
+					   obj_desc->region.address,
+					   obj_desc->region.length, node);
+	return_ACPI_STATUS(status);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/dscontrol.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/dscontrol.c
new file mode 100644
index 00000000..effe4ca1
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/dscontrol.c
@@ -0,0 +1,410 @@
+/******************************************************************************
+ *
+ * Module Name: dscontrol - Support for execution control opcodes -
+ *                          if/else/while/return
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "amlcode.h"
+#include "acdispat.h"
+#include "acinterp.h"
+
+#define _COMPONENT          ACPI_DISPATCHER
+ACPI_MODULE_NAME("dscontrol")
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_exec_begin_control_op
+ *
+ * PARAMETERS:  walk_list       - The list that owns the walk stack
+ *              Op              - The control Op
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Handles all control ops encountered during control method
+ *              execution.
+ *
+ ******************************************************************************/
+acpi_status
+acpi_ds_exec_begin_control_op(struct acpi_walk_state *walk_state,
+			      union acpi_parse_object *op)
+{
+	acpi_status status = AE_OK;
+	union acpi_generic_state *control_state;
+
+	ACPI_FUNCTION_NAME(ds_exec_begin_control_op);
+
+	ACPI_DEBUG_PRINT((ACPI_DB_DISPATCH, "Op=%p Opcode=%2.2X State=%p\n",
+			  op, op->common.aml_opcode, walk_state));
+
+	switch (op->common.aml_opcode) {
+	case AML_WHILE_OP:
+
+		/*
+		 * If this is an additional iteration of a while loop, continue.
+		 * There is no need to allocate a new control state.
+		 */
+		if (walk_state->control_state) {
+			if (walk_state->control_state->control.
+			    aml_predicate_start ==
+			    (walk_state->parser_state.aml - 1)) {
+
+				/* Reset the state to start-of-loop */
+
+				walk_state->control_state->common.state =
+				    ACPI_CONTROL_CONDITIONAL_EXECUTING;
+				break;
+			}
+		}
+
+		/*lint -fallthrough */
+
+	case AML_IF_OP:
+
+		/*
+		 * IF/WHILE: Create a new control state to manage these
+		 * constructs. We need to manage these as a stack, in order
+		 * to handle nesting.
+		 */
+		control_state = acpi_ut_create_control_state();
+		if (!control_state) {
+			status = AE_NO_MEMORY;
+			break;
+		}
+		/*
+		 * Save a pointer to the predicate for multiple executions
+		 * of a loop
+		 */
+		control_state->control.aml_predicate_start =
+		    walk_state->parser_state.aml - 1;
+		control_state->control.package_end =
+		    walk_state->parser_state.pkg_end;
+		control_state->control.opcode = op->common.aml_opcode;
+
+		/* Push the control state on this walk's control stack */
+
+		acpi_ut_push_generic_state(&walk_state->control_state,
+					   control_state);
+		break;
+
+	case AML_ELSE_OP:
+
+		/* Predicate is in the state object */
+		/* If predicate is true, the IF was executed, ignore ELSE part */
+
+		if (walk_state->last_predicate) {
+			status = AE_CTRL_TRUE;
+		}
+
+		break;
+
+	case AML_RETURN_OP:
+
+		break;
+
+	default:
+		break;
+	}
+
+	return (status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_exec_end_control_op
+ *
+ * PARAMETERS:  walk_list       - The list that owns the walk stack
+ *              Op              - The control Op
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Handles all control ops encountered during control method
+ *              execution.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ds_exec_end_control_op(struct acpi_walk_state * walk_state,
+			    union acpi_parse_object * op)
+{
+	acpi_status status = AE_OK;
+	union acpi_generic_state *control_state;
+
+	ACPI_FUNCTION_NAME(ds_exec_end_control_op);
+
+	switch (op->common.aml_opcode) {
+	case AML_IF_OP:
+
+		ACPI_DEBUG_PRINT((ACPI_DB_DISPATCH, "[IF_OP] Op=%p\n", op));
+
+		/*
+		 * Save the result of the predicate in case there is an
+		 * ELSE to come
+		 */
+		walk_state->last_predicate =
+		    (u8)walk_state->control_state->common.value;
+
+		/*
+		 * Pop the control state that was created at the start
+		 * of the IF and free it
+		 */
+		control_state =
+		    acpi_ut_pop_generic_state(&walk_state->control_state);
+		acpi_ut_delete_generic_state(control_state);
+		break;
+
+	case AML_ELSE_OP:
+
+		break;
+
+	case AML_WHILE_OP:
+
+		ACPI_DEBUG_PRINT((ACPI_DB_DISPATCH, "[WHILE_OP] Op=%p\n", op));
+
+		control_state = walk_state->control_state;
+		if (control_state->common.value) {
+
+			/* Predicate was true, the body of the loop was just executed */
+
+			/*
+			 * This loop counter mechanism allows the interpreter to escape
+			 * possibly infinite loops. This can occur in poorly written AML
+			 * when the hardware does not respond within a while loop and the
+			 * loop does not implement a timeout.
+			 */
+			control_state->control.loop_count++;
+			if (control_state->control.loop_count >
+			    ACPI_MAX_LOOP_ITERATIONS) {
+				status = AE_AML_INFINITE_LOOP;
+				break;
+			}
+
+			/*
+			 * Go back and evaluate the predicate and maybe execute the loop
+			 * another time
+			 */
+			status = AE_CTRL_PENDING;
+			walk_state->aml_last_while =
+			    control_state->control.aml_predicate_start;
+			break;
+		}
+
+		/* Predicate was false, terminate this while loop */
+
+		ACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,
+				  "[WHILE_OP] termination! Op=%p\n", op));
+
+		/* Pop this control state and free it */
+
+		control_state =
+		    acpi_ut_pop_generic_state(&walk_state->control_state);
+		acpi_ut_delete_generic_state(control_state);
+		break;
+
+	case AML_RETURN_OP:
+
+		ACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,
+				  "[RETURN_OP] Op=%p Arg=%p\n", op,
+				  op->common.value.arg));
+
+		/*
+		 * One optional operand -- the return value
+		 * It can be either an immediate operand or a result that
+		 * has been bubbled up the tree
+		 */
+		if (op->common.value.arg) {
+
+			/* Since we have a real Return(), delete any implicit return */
+
+			acpi_ds_clear_implicit_return(walk_state);
+
+			/* Return statement has an immediate operand */
+
+			status =
+			    acpi_ds_create_operands(walk_state,
+						    op->common.value.arg);
+			if (ACPI_FAILURE(status)) {
+				return (status);
+			}
+
+			/*
+			 * If value being returned is a Reference (such as
+			 * an arg or local), resolve it now because it may
+			 * cease to exist at the end of the method.
+			 */
+			status =
+			    acpi_ex_resolve_to_value(&walk_state->operands[0],
+						     walk_state);
+			if (ACPI_FAILURE(status)) {
+				return (status);
+			}
+
+			/*
+			 * Get the return value and save as the last result
+			 * value.  This is the only place where walk_state->return_desc
+			 * is set to anything other than zero!
+			 */
+			walk_state->return_desc = walk_state->operands[0];
+		} else if (walk_state->result_count) {
+
+			/* Since we have a real Return(), delete any implicit return */
+
+			acpi_ds_clear_implicit_return(walk_state);
+
+			/*
+			 * The return value has come from a previous calculation.
+			 *
+			 * If value being returned is a Reference (such as
+			 * an arg or local), resolve it now because it may
+			 * cease to exist at the end of the method.
+			 *
+			 * Allow references created by the Index operator to return
+			 * unchanged.
+			 */
+			if ((ACPI_GET_DESCRIPTOR_TYPE
+			     (walk_state->results->results.obj_desc[0]) ==
+			     ACPI_DESC_TYPE_OPERAND)
+			    && ((walk_state->results->results.obj_desc[0])->
+				common.type == ACPI_TYPE_LOCAL_REFERENCE)
+			    && ((walk_state->results->results.obj_desc[0])->
+				reference.class != ACPI_REFCLASS_INDEX)) {
+				status =
+				    acpi_ex_resolve_to_value(&walk_state->
+							     results->results.
+							     obj_desc[0],
+							     walk_state);
+				if (ACPI_FAILURE(status)) {
+					return (status);
+				}
+			}
+
+			walk_state->return_desc =
+			    walk_state->results->results.obj_desc[0];
+		} else {
+			/* No return operand */
+
+			if (walk_state->num_operands) {
+				acpi_ut_remove_reference(walk_state->
+							 operands[0]);
+			}
+
+			walk_state->operands[0] = NULL;
+			walk_state->num_operands = 0;
+			walk_state->return_desc = NULL;
+		}
+
+		ACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,
+				  "Completed RETURN_OP State=%p, RetVal=%p\n",
+				  walk_state, walk_state->return_desc));
+
+		/* End the control method execution right now */
+
+		status = AE_CTRL_TERMINATE;
+		break;
+
+	case AML_NOOP_OP:
+
+		/* Just do nothing! */
+		break;
+
+	case AML_BREAK_POINT_OP:
+
+		/*
+		 * Set the single-step flag. This will cause the debugger (if present)
+		 * to break to the console within the AML debugger at the start of the
+		 * next AML instruction.
+		 */
+		ACPI_DEBUGGER_EXEC(acpi_gbl_cm_single_step = TRUE);
+		ACPI_DEBUGGER_EXEC(acpi_os_printf
+				   ("**break** Executed AML BreakPoint opcode\n"));
+
+		/* Call to the OSL in case OS wants a piece of the action */
+
+		status = acpi_os_signal(ACPI_SIGNAL_BREAKPOINT,
+					"Executed AML Breakpoint opcode");
+		break;
+
+	case AML_BREAK_OP:
+	case AML_CONTINUE_OP:	/* ACPI 2.0 */
+
+		/* Pop and delete control states until we find a while */
+
+		while (walk_state->control_state &&
+		       (walk_state->control_state->control.opcode !=
+			AML_WHILE_OP)) {
+			control_state =
+			    acpi_ut_pop_generic_state(&walk_state->
+						      control_state);
+			acpi_ut_delete_generic_state(control_state);
+		}
+
+		/* No while found? */
+
+		if (!walk_state->control_state) {
+			return (AE_AML_NO_WHILE);
+		}
+
+		/* Was: walk_state->aml_last_while = walk_state->control_state->Control.aml_predicate_start; */
+
+		walk_state->aml_last_while =
+		    walk_state->control_state->control.package_end;
+
+		/* Return status depending on opcode */
+
+		if (op->common.aml_opcode == AML_BREAK_OP) {
+			status = AE_CTRL_BREAK;
+		} else {
+			status = AE_CTRL_CONTINUE;
+		}
+		break;
+
+	default:
+
+		ACPI_ERROR((AE_INFO, "Unknown control opcode=0x%X Op=%p",
+			    op->common.aml_opcode, op));
+
+		status = AE_AML_BAD_OPCODE;
+		break;
+	}
+
+	return (status);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/dsfield.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/dsfield.c
new file mode 100644
index 00000000..99f65f60
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/dsfield.c
@@ -0,0 +1,707 @@
+/******************************************************************************
+ *
+ * Module Name: dsfield - Dispatcher field routines
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "amlcode.h"
+#include "acdispat.h"
+#include "acinterp.h"
+#include "acnamesp.h"
+#include "acparser.h"
+
+#define _COMPONENT          ACPI_DISPATCHER
+ACPI_MODULE_NAME("dsfield")
+
+/* Local prototypes */
+static acpi_status
+acpi_ds_get_field_names(struct acpi_create_field_info *info,
+			struct acpi_walk_state *walk_state,
+			union acpi_parse_object *arg);
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_create_buffer_field
+ *
+ * PARAMETERS:  Op                  - Current parse op (create_xXField)
+ *              walk_state          - Current state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Execute the create_field operators:
+ *              create_bit_field_op,
+ *              create_byte_field_op,
+ *              create_word_field_op,
+ *              create_dword_field_op,
+ *              create_qword_field_op,
+ *              create_field_op     (all of which define a field in a buffer)
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ds_create_buffer_field(union acpi_parse_object *op,
+			    struct acpi_walk_state *walk_state)
+{
+	union acpi_parse_object *arg;
+	struct acpi_namespace_node *node;
+	acpi_status status;
+	union acpi_operand_object *obj_desc;
+	union acpi_operand_object *second_desc = NULL;
+	u32 flags;
+
+	ACPI_FUNCTION_TRACE(ds_create_buffer_field);
+
+	/*
+	 * Get the name_string argument (name of the new buffer_field)
+	 */
+	if (op->common.aml_opcode == AML_CREATE_FIELD_OP) {
+
+		/* For create_field, name is the 4th argument */
+
+		arg = acpi_ps_get_arg(op, 3);
+	} else {
+		/* For all other create_xXXField operators, name is the 3rd argument */
+
+		arg = acpi_ps_get_arg(op, 2);
+	}
+
+	if (!arg) {
+		return_ACPI_STATUS(AE_AML_NO_OPERAND);
+	}
+
+	if (walk_state->deferred_node) {
+		node = walk_state->deferred_node;
+		status = AE_OK;
+	} else {
+		/* Execute flag should always be set when this function is entered */
+
+		if (!(walk_state->parse_flags & ACPI_PARSE_EXECUTE)) {
+			return_ACPI_STATUS(AE_AML_INTERNAL);
+		}
+
+		/* Creating new namespace node, should not already exist */
+
+		flags = ACPI_NS_NO_UPSEARCH | ACPI_NS_DONT_OPEN_SCOPE |
+		    ACPI_NS_ERROR_IF_FOUND;
+
+		/*
+		 * Mark node temporary if we are executing a normal control
+		 * method. (Don't mark if this is a module-level code method)
+		 */
+		if (walk_state->method_node &&
+		    !(walk_state->parse_flags & ACPI_PARSE_MODULE_LEVEL)) {
+			flags |= ACPI_NS_TEMPORARY;
+		}
+
+		/* Enter the name_string into the namespace */
+
+		status =
+		    acpi_ns_lookup(walk_state->scope_info,
+				   arg->common.value.string, ACPI_TYPE_ANY,
+				   ACPI_IMODE_LOAD_PASS1, flags, walk_state,
+				   &node);
+		if (ACPI_FAILURE(status)) {
+			ACPI_ERROR_NAMESPACE(arg->common.value.string, status);
+			return_ACPI_STATUS(status);
+		}
+	}
+
+	/*
+	 * We could put the returned object (Node) on the object stack for later,
+	 * but for now, we will put it in the "op" object that the parser uses,
+	 * so we can get it again at the end of this scope.
+	 */
+	op->common.node = node;
+
+	/*
+	 * If there is no object attached to the node, this node was just created
+	 * and we need to create the field object. Otherwise, this was a lookup
+	 * of an existing node and we don't want to create the field object again.
+	 */
+	obj_desc = acpi_ns_get_attached_object(node);
+	if (obj_desc) {
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	/*
+	 * The Field definition is not fully parsed at this time.
+	 * (We must save the address of the AML for the buffer and index operands)
+	 */
+
+	/* Create the buffer field object */
+
+	obj_desc = acpi_ut_create_internal_object(ACPI_TYPE_BUFFER_FIELD);
+	if (!obj_desc) {
+		status = AE_NO_MEMORY;
+		goto cleanup;
+	}
+
+	/*
+	 * Remember location in AML stream of the field unit opcode and operands --
+	 * since the buffer and index operands must be evaluated.
+	 */
+	second_desc = obj_desc->common.next_object;
+	second_desc->extra.aml_start = op->named.data;
+	second_desc->extra.aml_length = op->named.length;
+	obj_desc->buffer_field.node = node;
+
+	/* Attach constructed field descriptors to parent node */
+
+	status = acpi_ns_attach_object(node, obj_desc, ACPI_TYPE_BUFFER_FIELD);
+	if (ACPI_FAILURE(status)) {
+		goto cleanup;
+	}
+
+      cleanup:
+
+	/* Remove local reference to the object */
+
+	acpi_ut_remove_reference(obj_desc);
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_get_field_names
+ *
+ * PARAMETERS:  Info            - create_field info structure
+ *  `           walk_state      - Current method state
+ *              Arg             - First parser arg for the field name list
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Process all named fields in a field declaration.  Names are
+ *              entered into the namespace.
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ds_get_field_names(struct acpi_create_field_info *info,
+			struct acpi_walk_state *walk_state,
+			union acpi_parse_object *arg)
+{
+	acpi_status status;
+	u64 position;
+	union acpi_parse_object *child;
+
+	ACPI_FUNCTION_TRACE_PTR(ds_get_field_names, info);
+
+	/* First field starts at bit zero */
+
+	info->field_bit_position = 0;
+
+	/* Process all elements in the field list (of parse nodes) */
+
+	while (arg) {
+		/*
+		 * Four types of field elements are handled:
+		 * 1) Name - Enters a new named field into the namespace
+		 * 2) Offset - specifies a bit offset
+		 * 3) access_as - changes the access mode/attributes
+		 * 4) Connection - Associate a resource template with the field
+		 */
+		switch (arg->common.aml_opcode) {
+		case AML_INT_RESERVEDFIELD_OP:
+
+			position = (u64)info->field_bit_position
+			    + (u64)arg->common.value.size;
+
+			if (position > ACPI_UINT32_MAX) {
+				ACPI_ERROR((AE_INFO,
+					    "Bit offset within field too large (> 0xFFFFFFFF)"));
+				return_ACPI_STATUS(AE_SUPPORT);
+			}
+
+			info->field_bit_position = (u32)position;
+			break;
+
+		case AML_INT_ACCESSFIELD_OP:
+		case AML_INT_EXTACCESSFIELD_OP:
+			/*
+			 * Get new access_type, access_attribute, and access_length fields
+			 * -- to be used for all field units that follow, until the
+			 * end-of-field or another access_as keyword is encountered.
+			 * NOTE. These three bytes are encoded in the integer value
+			 * of the parseop for convenience.
+			 *
+			 * In field_flags, preserve the flag bits other than the
+			 * ACCESS_TYPE bits.
+			 */
+
+			/* access_type (byte_acc, word_acc, etc.) */
+
+			info->field_flags = (u8)
+			    ((info->
+			      field_flags & ~(AML_FIELD_ACCESS_TYPE_MASK)) |
+			     ((u8)((u32)(arg->common.value.integer & 0x07))));
+
+			/* access_attribute (attrib_quick, attrib_byte, etc.) */
+
+			info->attribute =
+			    (u8)((arg->common.value.integer >> 8) & 0xFF);
+
+			/* access_length (for serial/buffer protocols) */
+
+			info->access_length =
+			    (u8)((arg->common.value.integer >> 16) & 0xFF);
+			break;
+
+		case AML_INT_CONNECTION_OP:
+			/*
+			 * Clear any previous connection. New connection is used for all
+			 * fields that follow, similar to access_as
+			 */
+			info->resource_buffer = NULL;
+			info->connection_node = NULL;
+
+			/*
+			 * A Connection() is either an actual resource descriptor (buffer)
+			 * or a named reference to a resource template
+			 */
+			child = arg->common.value.arg;
+			if (child->common.aml_opcode == AML_INT_BYTELIST_OP) {
+				info->resource_buffer = child->named.data;
+				info->resource_length =
+				    (u16)child->named.value.integer;
+			} else {
+				/* Lookup the Connection() namepath, it should already exist */
+
+				status = acpi_ns_lookup(walk_state->scope_info,
+							child->common.value.
+							name, ACPI_TYPE_ANY,
+							ACPI_IMODE_EXECUTE,
+							ACPI_NS_DONT_OPEN_SCOPE,
+							walk_state,
+							&info->connection_node);
+				if (ACPI_FAILURE(status)) {
+					ACPI_ERROR_NAMESPACE(child->common.
+							     value.name,
+							     status);
+					return_ACPI_STATUS(status);
+				}
+			}
+			break;
+
+		case AML_INT_NAMEDFIELD_OP:
+
+			/* Lookup the name, it should already exist */
+
+			status = acpi_ns_lookup(walk_state->scope_info,
+						(char *)&arg->named.name,
+						info->field_type,
+						ACPI_IMODE_EXECUTE,
+						ACPI_NS_DONT_OPEN_SCOPE,
+						walk_state, &info->field_node);
+			if (ACPI_FAILURE(status)) {
+				ACPI_ERROR_NAMESPACE((char *)&arg->named.name,
+						     status);
+				return_ACPI_STATUS(status);
+			} else {
+				arg->common.node = info->field_node;
+				info->field_bit_length = arg->common.value.size;
+
+				/*
+				 * If there is no object attached to the node, this node was
+				 * just created and we need to create the field object.
+				 * Otherwise, this was a lookup of an existing node and we
+				 * don't want to create the field object again.
+				 */
+				if (!acpi_ns_get_attached_object
+				    (info->field_node)) {
+					status = acpi_ex_prep_field_value(info);
+					if (ACPI_FAILURE(status)) {
+						return_ACPI_STATUS(status);
+					}
+				}
+			}
+
+			/* Keep track of bit position for the next field */
+
+			position = (u64)info->field_bit_position
+			    + (u64)arg->common.value.size;
+
+			if (position > ACPI_UINT32_MAX) {
+				ACPI_ERROR((AE_INFO,
+					    "Field [%4.4s] bit offset too large (> 0xFFFFFFFF)",
+					    ACPI_CAST_PTR(char,
+							  &info->field_node->
+							  name)));
+				return_ACPI_STATUS(AE_SUPPORT);
+			}
+
+			info->field_bit_position += info->field_bit_length;
+			break;
+
+		default:
+
+			ACPI_ERROR((AE_INFO,
+				    "Invalid opcode in field list: 0x%X",
+				    arg->common.aml_opcode));
+			return_ACPI_STATUS(AE_AML_BAD_OPCODE);
+		}
+
+		arg = arg->common.next;
+	}
+
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_create_field
+ *
+ * PARAMETERS:  Op              - Op containing the Field definition and args
+ *              region_node     - Object for the containing Operation Region
+ *  `           walk_state      - Current method state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Create a new field in the specified operation region
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ds_create_field(union acpi_parse_object *op,
+		     struct acpi_namespace_node *region_node,
+		     struct acpi_walk_state *walk_state)
+{
+	acpi_status status;
+	union acpi_parse_object *arg;
+	struct acpi_create_field_info info;
+
+	ACPI_FUNCTION_TRACE_PTR(ds_create_field, op);
+
+	/* First arg is the name of the parent op_region (must already exist) */
+
+	arg = op->common.value.arg;
+	if (!region_node) {
+		status =
+		    acpi_ns_lookup(walk_state->scope_info,
+				   arg->common.value.name, ACPI_TYPE_REGION,
+				   ACPI_IMODE_EXECUTE, ACPI_NS_SEARCH_PARENT,
+				   walk_state, &region_node);
+		if (ACPI_FAILURE(status)) {
+			ACPI_ERROR_NAMESPACE(arg->common.value.name, status);
+			return_ACPI_STATUS(status);
+		}
+	}
+
+	ACPI_MEMSET(&info, 0, sizeof(struct acpi_create_field_info));
+
+	/* Second arg is the field flags */
+
+	arg = arg->common.next;
+	info.field_flags = (u8)arg->common.value.integer;
+	info.attribute = 0;
+
+	/* Each remaining arg is a Named Field */
+
+	info.field_type = ACPI_TYPE_LOCAL_REGION_FIELD;
+	info.region_node = region_node;
+
+	status = acpi_ds_get_field_names(&info, walk_state, arg->common.next);
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_init_field_objects
+ *
+ * PARAMETERS:  Op              - Op containing the Field definition and args
+ *  `           walk_state      - Current method state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: For each "Field Unit" name in the argument list that is
+ *              part of the field declaration, enter the name into the
+ *              namespace.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ds_init_field_objects(union acpi_parse_object *op,
+			   struct acpi_walk_state *walk_state)
+{
+	acpi_status status;
+	union acpi_parse_object *arg = NULL;
+	struct acpi_namespace_node *node;
+	u8 type = 0;
+	u32 flags;
+
+	ACPI_FUNCTION_TRACE_PTR(ds_init_field_objects, op);
+
+	/* Execute flag should always be set when this function is entered */
+
+	if (!(walk_state->parse_flags & ACPI_PARSE_EXECUTE)) {
+		if (walk_state->parse_flags & ACPI_PARSE_DEFERRED_OP) {
+
+			/* bank_field Op is deferred, just return OK */
+
+			return_ACPI_STATUS(AE_OK);
+		}
+
+		return_ACPI_STATUS(AE_AML_INTERNAL);
+	}
+
+	/*
+	 * Get the field_list argument for this opcode. This is the start of the
+	 * list of field elements.
+	 */
+	switch (walk_state->opcode) {
+	case AML_FIELD_OP:
+		arg = acpi_ps_get_arg(op, 2);
+		type = ACPI_TYPE_LOCAL_REGION_FIELD;
+		break;
+
+	case AML_BANK_FIELD_OP:
+		arg = acpi_ps_get_arg(op, 4);
+		type = ACPI_TYPE_LOCAL_BANK_FIELD;
+		break;
+
+	case AML_INDEX_FIELD_OP:
+		arg = acpi_ps_get_arg(op, 3);
+		type = ACPI_TYPE_LOCAL_INDEX_FIELD;
+		break;
+
+	default:
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	/* Creating new namespace node(s), should not already exist */
+
+	flags = ACPI_NS_NO_UPSEARCH | ACPI_NS_DONT_OPEN_SCOPE |
+	    ACPI_NS_ERROR_IF_FOUND;
+
+	/*
+	 * Mark node(s) temporary if we are executing a normal control
+	 * method. (Don't mark if this is a module-level code method)
+	 */
+	if (walk_state->method_node &&
+	    !(walk_state->parse_flags & ACPI_PARSE_MODULE_LEVEL)) {
+		flags |= ACPI_NS_TEMPORARY;
+	}
+
+	/*
+	 * Walk the list of entries in the field_list
+	 * Note: field_list can be of zero length. In this case, Arg will be NULL.
+	 */
+	while (arg) {
+		/*
+		 * Ignore OFFSET/ACCESSAS/CONNECTION terms here; we are only interested
+		 * in the field names in order to enter them into the namespace.
+		 */
+		if (arg->common.aml_opcode == AML_INT_NAMEDFIELD_OP) {
+			status = acpi_ns_lookup(walk_state->scope_info,
+						(char *)&arg->named.name, type,
+						ACPI_IMODE_LOAD_PASS1, flags,
+						walk_state, &node);
+			if (ACPI_FAILURE(status)) {
+				ACPI_ERROR_NAMESPACE((char *)&arg->named.name,
+						     status);
+				if (status != AE_ALREADY_EXISTS) {
+					return_ACPI_STATUS(status);
+				}
+
+				/* Name already exists, just ignore this error */
+
+				status = AE_OK;
+			}
+
+			arg->common.node = node;
+		}
+
+		/* Get the next field element in the list */
+
+		arg = arg->common.next;
+	}
+
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_create_bank_field
+ *
+ * PARAMETERS:  Op              - Op containing the Field definition and args
+ *              region_node     - Object for the containing Operation Region
+ *              walk_state      - Current method state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Create a new bank field in the specified operation region
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ds_create_bank_field(union acpi_parse_object *op,
+			  struct acpi_namespace_node *region_node,
+			  struct acpi_walk_state *walk_state)
+{
+	acpi_status status;
+	union acpi_parse_object *arg;
+	struct acpi_create_field_info info;
+
+	ACPI_FUNCTION_TRACE_PTR(ds_create_bank_field, op);
+
+	/* First arg is the name of the parent op_region (must already exist) */
+
+	arg = op->common.value.arg;
+	if (!region_node) {
+		status =
+		    acpi_ns_lookup(walk_state->scope_info,
+				   arg->common.value.name, ACPI_TYPE_REGION,
+				   ACPI_IMODE_EXECUTE, ACPI_NS_SEARCH_PARENT,
+				   walk_state, &region_node);
+		if (ACPI_FAILURE(status)) {
+			ACPI_ERROR_NAMESPACE(arg->common.value.name, status);
+			return_ACPI_STATUS(status);
+		}
+	}
+
+	/* Second arg is the Bank Register (Field) (must already exist) */
+
+	arg = arg->common.next;
+	status =
+	    acpi_ns_lookup(walk_state->scope_info, arg->common.value.string,
+			   ACPI_TYPE_ANY, ACPI_IMODE_EXECUTE,
+			   ACPI_NS_SEARCH_PARENT, walk_state,
+			   &info.register_node);
+	if (ACPI_FAILURE(status)) {
+		ACPI_ERROR_NAMESPACE(arg->common.value.string, status);
+		return_ACPI_STATUS(status);
+	}
+
+	/*
+	 * Third arg is the bank_value
+	 * This arg is a term_arg, not a constant
+	 * It will be evaluated later, by acpi_ds_eval_bank_field_operands
+	 */
+	arg = arg->common.next;
+
+	/* Fourth arg is the field flags */
+
+	arg = arg->common.next;
+	info.field_flags = (u8)arg->common.value.integer;
+
+	/* Each remaining arg is a Named Field */
+
+	info.field_type = ACPI_TYPE_LOCAL_BANK_FIELD;
+	info.region_node = region_node;
+
+	/*
+	 * Use Info.data_register_node to store bank_field Op
+	 * It's safe because data_register_node will never be used when create bank field
+	 * We store aml_start and aml_length in the bank_field Op for late evaluation
+	 * Used in acpi_ex_prep_field_value(Info)
+	 *
+	 * TBD: Or, should we add a field in struct acpi_create_field_info, like "void *ParentOp"?
+	 */
+	info.data_register_node = (struct acpi_namespace_node *)op;
+
+	status = acpi_ds_get_field_names(&info, walk_state, arg->common.next);
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_create_index_field
+ *
+ * PARAMETERS:  Op              - Op containing the Field definition and args
+ *              region_node     - Object for the containing Operation Region
+ *  `           walk_state      - Current method state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Create a new index field in the specified operation region
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ds_create_index_field(union acpi_parse_object *op,
+			   struct acpi_namespace_node *region_node,
+			   struct acpi_walk_state *walk_state)
+{
+	acpi_status status;
+	union acpi_parse_object *arg;
+	struct acpi_create_field_info info;
+
+	ACPI_FUNCTION_TRACE_PTR(ds_create_index_field, op);
+
+	/* First arg is the name of the Index register (must already exist) */
+
+	arg = op->common.value.arg;
+	status =
+	    acpi_ns_lookup(walk_state->scope_info, arg->common.value.string,
+			   ACPI_TYPE_ANY, ACPI_IMODE_EXECUTE,
+			   ACPI_NS_SEARCH_PARENT, walk_state,
+			   &info.register_node);
+	if (ACPI_FAILURE(status)) {
+		ACPI_ERROR_NAMESPACE(arg->common.value.string, status);
+		return_ACPI_STATUS(status);
+	}
+
+	/* Second arg is the data register (must already exist) */
+
+	arg = arg->common.next;
+	status =
+	    acpi_ns_lookup(walk_state->scope_info, arg->common.value.string,
+			   ACPI_TYPE_ANY, ACPI_IMODE_EXECUTE,
+			   ACPI_NS_SEARCH_PARENT, walk_state,
+			   &info.data_register_node);
+	if (ACPI_FAILURE(status)) {
+		ACPI_ERROR_NAMESPACE(arg->common.value.string, status);
+		return_ACPI_STATUS(status);
+	}
+
+	/* Next arg is the field flags */
+
+	arg = arg->common.next;
+	info.field_flags = (u8)arg->common.value.integer;
+
+	/* Each remaining arg is a Named Field */
+
+	info.field_type = ACPI_TYPE_LOCAL_INDEX_FIELD;
+	info.region_node = region_node;
+
+	status = acpi_ds_get_field_names(&info, walk_state, arg->common.next);
+	return_ACPI_STATUS(status);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/dsinit.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/dsinit.c
new file mode 100644
index 00000000..9e5ac7f7
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/dsinit.c
@@ -0,0 +1,217 @@
+/******************************************************************************
+ *
+ * Module Name: dsinit - Object initialization namespace walk
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acdispat.h"
+#include "acnamesp.h"
+#include "actables.h"
+
+#define _COMPONENT          ACPI_DISPATCHER
+ACPI_MODULE_NAME("dsinit")
+
+/* Local prototypes */
+static acpi_status
+acpi_ds_init_one_object(acpi_handle obj_handle,
+			u32 level, void *context, void **return_value);
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_init_one_object
+ *
+ * PARAMETERS:  obj_handle      - Node for the object
+ *              Level           - Current nesting level
+ *              Context         - Points to a init info struct
+ *              return_value    - Not used
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Callback from acpi_walk_namespace. Invoked for every object
+ *              within the namespace.
+ *
+ *              Currently, the only objects that require initialization are:
+ *              1) Methods
+ *              2) Operation Regions
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ds_init_one_object(acpi_handle obj_handle,
+			u32 level, void *context, void **return_value)
+{
+	struct acpi_init_walk_info *info =
+	    (struct acpi_init_walk_info *)context;
+	struct acpi_namespace_node *node =
+	    (struct acpi_namespace_node *)obj_handle;
+	acpi_object_type type;
+	acpi_status status;
+
+	ACPI_FUNCTION_ENTRY();
+
+	/*
+	 * We are only interested in NS nodes owned by the table that
+	 * was just loaded
+	 */
+	if (node->owner_id != info->owner_id) {
+		return (AE_OK);
+	}
+
+	info->object_count++;
+
+	/* And even then, we are only interested in a few object types */
+
+	type = acpi_ns_get_type(obj_handle);
+
+	switch (type) {
+	case ACPI_TYPE_REGION:
+
+		status = acpi_ds_initialize_region(obj_handle);
+		if (ACPI_FAILURE(status)) {
+			ACPI_EXCEPTION((AE_INFO, status,
+					"During Region initialization %p [%4.4s]",
+					obj_handle,
+					acpi_ut_get_node_name(obj_handle)));
+		}
+
+		info->op_region_count++;
+		break;
+
+	case ACPI_TYPE_METHOD:
+
+		info->method_count++;
+		break;
+
+	case ACPI_TYPE_DEVICE:
+
+		info->device_count++;
+		break;
+
+	default:
+		break;
+	}
+
+	/*
+	 * We ignore errors from above, and always return OK, since
+	 * we don't want to abort the walk on a single error.
+	 */
+	return (AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_initialize_objects
+ *
+ * PARAMETERS:  table_desc      - Descriptor for parent ACPI table
+ *              start_node      - Root of subtree to be initialized.
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Walk the namespace starting at "StartNode" and perform any
+ *              necessary initialization on the objects found therein
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ds_initialize_objects(u32 table_index,
+			   struct acpi_namespace_node * start_node)
+{
+	acpi_status status;
+	struct acpi_init_walk_info info;
+	struct acpi_table_header *table;
+	acpi_owner_id owner_id;
+
+	ACPI_FUNCTION_TRACE(ds_initialize_objects);
+
+	status = acpi_tb_get_owner_id(table_index, &owner_id);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,
+			  "**** Starting initialization of namespace objects ****\n"));
+	ACPI_DEBUG_PRINT_RAW((ACPI_DB_INIT, "Parsing all Control Methods:"));
+
+	/* Set all init info to zero */
+
+	ACPI_MEMSET(&info, 0, sizeof(struct acpi_init_walk_info));
+
+	info.owner_id = owner_id;
+	info.table_index = table_index;
+
+	/* Walk entire namespace from the supplied root */
+
+	status = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/*
+	 * We don't use acpi_walk_namespace since we do not want to acquire
+	 * the namespace reader lock.
+	 */
+	status =
+	    acpi_ns_walk_namespace(ACPI_TYPE_ANY, start_node, ACPI_UINT32_MAX,
+				   ACPI_NS_WALK_UNLOCK, acpi_ds_init_one_object,
+				   NULL, &info, NULL);
+	if (ACPI_FAILURE(status)) {
+		ACPI_EXCEPTION((AE_INFO, status, "During WalkNamespace"));
+	}
+	(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);
+
+	status = acpi_get_table_by_index(table_index, &table);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	ACPI_DEBUG_PRINT_RAW((ACPI_DB_INIT,
+			      "\nTable [%4.4s](id %4.4X) - %u Objects with %u Devices %u Methods %u Regions\n",
+			      table->signature, owner_id, info.object_count,
+			      info.device_count, info.method_count,
+			      info.op_region_count));
+
+	ACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,
+			  "%u Methods, %u Regions\n", info.method_count,
+			  info.op_region_count));
+
+	return_ACPI_STATUS(AE_OK);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/dsmethod.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/dsmethod.c
new file mode 100644
index 00000000..fe06041f
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/dsmethod.c
@@ -0,0 +1,681 @@
+/******************************************************************************
+ *
+ * Module Name: dsmethod - Parser/Interpreter interface - control method parsing
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acdispat.h"
+#include "acinterp.h"
+#include "acnamesp.h"
+#include "acdisasm.h"
+
+#define _COMPONENT          ACPI_DISPATCHER
+ACPI_MODULE_NAME("dsmethod")
+
+/* Local prototypes */
+static acpi_status
+acpi_ds_create_method_mutex(union acpi_operand_object *method_desc);
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_method_error
+ *
+ * PARAMETERS:  Status          - Execution status
+ *              walk_state      - Current state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Called on method error. Invoke the global exception handler if
+ *              present, dump the method data if the disassembler is configured
+ *
+ *              Note: Allows the exception handler to change the status code
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ds_method_error(acpi_status status, struct acpi_walk_state *walk_state)
+{
+	ACPI_FUNCTION_ENTRY();
+
+	/* Ignore AE_OK and control exception codes */
+
+	if (ACPI_SUCCESS(status) || (status & AE_CODE_CONTROL)) {
+		return (status);
+	}
+
+	/* Invoke the global exception handler */
+
+	if (acpi_gbl_exception_handler) {
+
+		/* Exit the interpreter, allow handler to execute methods */
+
+		acpi_ex_exit_interpreter();
+
+		/*
+		 * Handler can map the exception code to anything it wants, including
+		 * AE_OK, in which case the executing method will not be aborted.
+		 */
+		status = acpi_gbl_exception_handler(status,
+						    walk_state->method_node ?
+						    walk_state->method_node->
+						    name.integer : 0,
+						    walk_state->opcode,
+						    walk_state->aml_offset,
+						    NULL);
+		acpi_ex_enter_interpreter();
+	}
+
+	acpi_ds_clear_implicit_return(walk_state);
+
+#ifdef ACPI_DISASSEMBLER
+	if (ACPI_FAILURE(status)) {
+
+		/* Display method locals/args if disassembler is present */
+
+		acpi_dm_dump_method_info(status, walk_state, walk_state->op);
+	}
+#endif
+
+	return (status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_create_method_mutex
+ *
+ * PARAMETERS:  obj_desc            - The method object
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Create a mutex object for a serialized control method
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ds_create_method_mutex(union acpi_operand_object *method_desc)
+{
+	union acpi_operand_object *mutex_desc;
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(ds_create_method_mutex);
+
+	/* Create the new mutex object */
+
+	mutex_desc = acpi_ut_create_internal_object(ACPI_TYPE_MUTEX);
+	if (!mutex_desc) {
+		return_ACPI_STATUS(AE_NO_MEMORY);
+	}
+
+	/* Create the actual OS Mutex */
+
+	status = acpi_os_create_mutex(&mutex_desc->mutex.os_mutex);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	mutex_desc->mutex.sync_level = method_desc->method.sync_level;
+	method_desc->method.mutex = mutex_desc;
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_begin_method_execution
+ *
+ * PARAMETERS:  method_node         - Node of the method
+ *              obj_desc            - The method object
+ *              walk_state          - current state, NULL if not yet executing
+ *                                    a method.
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Prepare a method for execution.  Parses the method if necessary,
+ *              increments the thread count, and waits at the method semaphore
+ *              for clearance to execute.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ds_begin_method_execution(struct acpi_namespace_node *method_node,
+			       union acpi_operand_object *obj_desc,
+			       struct acpi_walk_state *walk_state)
+{
+	acpi_status status = AE_OK;
+
+	ACPI_FUNCTION_TRACE_PTR(ds_begin_method_execution, method_node);
+
+	if (!method_node) {
+		return_ACPI_STATUS(AE_NULL_ENTRY);
+	}
+
+	/* Prevent wraparound of thread count */
+
+	if (obj_desc->method.thread_count == ACPI_UINT8_MAX) {
+		ACPI_ERROR((AE_INFO,
+			    "Method reached maximum reentrancy limit (255)"));
+		return_ACPI_STATUS(AE_AML_METHOD_LIMIT);
+	}
+
+	/*
+	 * If this method is serialized, we need to acquire the method mutex.
+	 */
+	if (obj_desc->method.info_flags & ACPI_METHOD_SERIALIZED) {
+		/*
+		 * Create a mutex for the method if it is defined to be Serialized
+		 * and a mutex has not already been created. We defer the mutex creation
+		 * until a method is actually executed, to minimize the object count
+		 */
+		if (!obj_desc->method.mutex) {
+			status = acpi_ds_create_method_mutex(obj_desc);
+			if (ACPI_FAILURE(status)) {
+				return_ACPI_STATUS(status);
+			}
+		}
+
+		/*
+		 * The current_sync_level (per-thread) must be less than or equal to
+		 * the sync level of the method. This mechanism provides some
+		 * deadlock prevention
+		 *
+		 * Top-level method invocation has no walk state at this point
+		 */
+		if (walk_state &&
+		    (walk_state->thread->current_sync_level >
+		     obj_desc->method.mutex->mutex.sync_level)) {
+			ACPI_ERROR((AE_INFO,
+				    "Cannot acquire Mutex for method [%4.4s], current SyncLevel is too large (%u)",
+				    acpi_ut_get_node_name(method_node),
+				    walk_state->thread->current_sync_level));
+
+			return_ACPI_STATUS(AE_AML_MUTEX_ORDER);
+		}
+
+		/*
+		 * Obtain the method mutex if necessary. Do not acquire mutex for a
+		 * recursive call.
+		 */
+		if (!walk_state ||
+		    !obj_desc->method.mutex->mutex.thread_id ||
+		    (walk_state->thread->thread_id !=
+		     obj_desc->method.mutex->mutex.thread_id)) {
+			/*
+			 * Acquire the method mutex. This releases the interpreter if we
+			 * block (and reacquires it before it returns)
+			 */
+			status =
+			    acpi_ex_system_wait_mutex(obj_desc->method.mutex->
+						      mutex.os_mutex,
+						      ACPI_WAIT_FOREVER);
+			if (ACPI_FAILURE(status)) {
+				return_ACPI_STATUS(status);
+			}
+
+			/* Update the mutex and walk info and save the original sync_level */
+
+			if (walk_state) {
+				obj_desc->method.mutex->mutex.
+				    original_sync_level =
+				    walk_state->thread->current_sync_level;
+
+				obj_desc->method.mutex->mutex.thread_id =
+				    walk_state->thread->thread_id;
+				walk_state->thread->current_sync_level =
+				    obj_desc->method.sync_level;
+			} else {
+				obj_desc->method.mutex->mutex.
+				    original_sync_level =
+				    obj_desc->method.mutex->mutex.sync_level;
+			}
+		}
+
+		/* Always increase acquisition depth */
+
+		obj_desc->method.mutex->mutex.acquisition_depth++;
+	}
+
+	/*
+	 * Allocate an Owner ID for this method, only if this is the first thread
+	 * to begin concurrent execution. We only need one owner_id, even if the
+	 * method is invoked recursively.
+	 */
+	if (!obj_desc->method.owner_id) {
+		status = acpi_ut_allocate_owner_id(&obj_desc->method.owner_id);
+		if (ACPI_FAILURE(status)) {
+			goto cleanup;
+		}
+	}
+
+	/*
+	 * Increment the method parse tree thread count since it has been
+	 * reentered one more time (even if it is the same thread)
+	 */
+	obj_desc->method.thread_count++;
+	acpi_method_count++;
+	return_ACPI_STATUS(status);
+
+      cleanup:
+	/* On error, must release the method mutex (if present) */
+
+	if (obj_desc->method.mutex) {
+		acpi_os_release_mutex(obj_desc->method.mutex->mutex.os_mutex);
+	}
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_call_control_method
+ *
+ * PARAMETERS:  Thread              - Info for this thread
+ *              this_walk_state     - Current walk state
+ *              Op                  - Current Op to be walked
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Transfer execution to a called control method
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ds_call_control_method(struct acpi_thread_state *thread,
+			    struct acpi_walk_state *this_walk_state,
+			    union acpi_parse_object *op)
+{
+	acpi_status status;
+	struct acpi_namespace_node *method_node;
+	struct acpi_walk_state *next_walk_state = NULL;
+	union acpi_operand_object *obj_desc;
+	struct acpi_evaluate_info *info;
+	u32 i;
+
+	ACPI_FUNCTION_TRACE_PTR(ds_call_control_method, this_walk_state);
+
+	ACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,
+			  "Calling method %p, currentstate=%p\n",
+			  this_walk_state->prev_op, this_walk_state));
+
+	/*
+	 * Get the namespace entry for the control method we are about to call
+	 */
+	method_node = this_walk_state->method_call_node;
+	if (!method_node) {
+		return_ACPI_STATUS(AE_NULL_ENTRY);
+	}
+
+	obj_desc = acpi_ns_get_attached_object(method_node);
+	if (!obj_desc) {
+		return_ACPI_STATUS(AE_NULL_OBJECT);
+	}
+
+	/* Init for new method, possibly wait on method mutex */
+
+	status = acpi_ds_begin_method_execution(method_node, obj_desc,
+						this_walk_state);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/* Begin method parse/execution. Create a new walk state */
+
+	next_walk_state = acpi_ds_create_walk_state(obj_desc->method.owner_id,
+						    NULL, obj_desc, thread);
+	if (!next_walk_state) {
+		status = AE_NO_MEMORY;
+		goto cleanup;
+	}
+
+	/*
+	 * The resolved arguments were put on the previous walk state's operand
+	 * stack. Operands on the previous walk state stack always
+	 * start at index 0. Also, null terminate the list of arguments
+	 */
+	this_walk_state->operands[this_walk_state->num_operands] = NULL;
+
+	/*
+	 * Allocate and initialize the evaluation information block
+	 * TBD: this is somewhat inefficient, should change interface to
+	 * ds_init_aml_walk. For now, keeps this struct off the CPU stack
+	 */
+	info = ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_evaluate_info));
+	if (!info) {
+		return_ACPI_STATUS(AE_NO_MEMORY);
+	}
+
+	info->parameters = &this_walk_state->operands[0];
+
+	status = acpi_ds_init_aml_walk(next_walk_state, NULL, method_node,
+				       obj_desc->method.aml_start,
+				       obj_desc->method.aml_length, info,
+				       ACPI_IMODE_EXECUTE);
+
+	ACPI_FREE(info);
+	if (ACPI_FAILURE(status)) {
+		goto cleanup;
+	}
+
+	/*
+	 * Delete the operands on the previous walkstate operand stack
+	 * (they were copied to new objects)
+	 */
+	for (i = 0; i < obj_desc->method.param_count; i++) {
+		acpi_ut_remove_reference(this_walk_state->operands[i]);
+		this_walk_state->operands[i] = NULL;
+	}
+
+	/* Clear the operand stack */
+
+	this_walk_state->num_operands = 0;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,
+			  "**** Begin nested execution of [%4.4s] **** WalkState=%p\n",
+			  method_node->name.ascii, next_walk_state));
+
+	/* Invoke an internal method if necessary */
+
+	if (obj_desc->method.info_flags & ACPI_METHOD_INTERNAL_ONLY) {
+		status =
+		    obj_desc->method.dispatch.implementation(next_walk_state);
+		if (status == AE_OK) {
+			status = AE_CTRL_TERMINATE;
+		}
+	}
+
+	return_ACPI_STATUS(status);
+
+      cleanup:
+
+	/* On error, we must terminate the method properly */
+
+	acpi_ds_terminate_control_method(obj_desc, next_walk_state);
+	if (next_walk_state) {
+		acpi_ds_delete_walk_state(next_walk_state);
+	}
+
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_restart_control_method
+ *
+ * PARAMETERS:  walk_state          - State for preempted method (caller)
+ *              return_desc         - Return value from the called method
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Restart a method that was preempted by another (nested) method
+ *              invocation.  Handle the return value (if any) from the callee.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ds_restart_control_method(struct acpi_walk_state *walk_state,
+			       union acpi_operand_object *return_desc)
+{
+	acpi_status status;
+	int same_as_implicit_return;
+
+	ACPI_FUNCTION_TRACE_PTR(ds_restart_control_method, walk_state);
+
+	ACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,
+			  "****Restart [%4.4s] Op %p ReturnValueFromCallee %p\n",
+			  acpi_ut_get_node_name(walk_state->method_node),
+			  walk_state->method_call_op, return_desc));
+
+	ACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,
+			  "    ReturnFromThisMethodUsed?=%X ResStack %p Walk %p\n",
+			  walk_state->return_used,
+			  walk_state->results, walk_state));
+
+	/* Did the called method return a value? */
+
+	if (return_desc) {
+
+		/* Is the implicit return object the same as the return desc? */
+
+		same_as_implicit_return =
+		    (walk_state->implicit_return_obj == return_desc);
+
+		/* Are we actually going to use the return value? */
+
+		if (walk_state->return_used) {
+
+			/* Save the return value from the previous method */
+
+			status = acpi_ds_result_push(return_desc, walk_state);
+			if (ACPI_FAILURE(status)) {
+				acpi_ut_remove_reference(return_desc);
+				return_ACPI_STATUS(status);
+			}
+
+			/*
+			 * Save as THIS method's return value in case it is returned
+			 * immediately to yet another method
+			 */
+			walk_state->return_desc = return_desc;
+		}
+
+		/*
+		 * The following code is the optional support for the so-called
+		 * "implicit return". Some AML code assumes that the last value of the
+		 * method is "implicitly" returned to the caller, in the absence of an
+		 * explicit return value.
+		 *
+		 * Just save the last result of the method as the return value.
+		 *
+		 * NOTE: this is optional because the ASL language does not actually
+		 * support this behavior.
+		 */
+		else if (!acpi_ds_do_implicit_return
+			 (return_desc, walk_state, FALSE)
+			 || same_as_implicit_return) {
+			/*
+			 * Delete the return value if it will not be used by the
+			 * calling method or remove one reference if the explicit return
+			 * is the same as the implicit return value.
+			 */
+			acpi_ut_remove_reference(return_desc);
+		}
+	}
+
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_terminate_control_method
+ *
+ * PARAMETERS:  method_desc         - Method object
+ *              walk_state          - State associated with the method
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Terminate a control method.  Delete everything that the method
+ *              created, delete all locals and arguments, and delete the parse
+ *              tree if requested.
+ *
+ * MUTEX:       Interpreter is locked
+ *
+ ******************************************************************************/
+
+void
+acpi_ds_terminate_control_method(union acpi_operand_object *method_desc,
+				 struct acpi_walk_state *walk_state)
+{
+
+	ACPI_FUNCTION_TRACE_PTR(ds_terminate_control_method, walk_state);
+
+	/* method_desc is required, walk_state is optional */
+
+	if (!method_desc) {
+		return_VOID;
+	}
+
+	if (walk_state) {
+
+		/* Delete all arguments and locals */
+
+		acpi_ds_method_data_delete_all(walk_state);
+
+		/*
+		 * If method is serialized, release the mutex and restore the
+		 * current sync level for this thread
+		 */
+		if (method_desc->method.mutex) {
+
+			/* Acquisition Depth handles recursive calls */
+
+			method_desc->method.mutex->mutex.acquisition_depth--;
+			if (!method_desc->method.mutex->mutex.acquisition_depth) {
+				walk_state->thread->current_sync_level =
+				    method_desc->method.mutex->mutex.
+				    original_sync_level;
+
+				acpi_os_release_mutex(method_desc->method.
+						      mutex->mutex.os_mutex);
+				method_desc->method.mutex->mutex.thread_id = 0;
+			}
+		}
+
+		/*
+		 * Delete any namespace objects created anywhere within the
+		 * namespace by the execution of this method. Unless:
+		 * 1) This method is a module-level executable code method, in which
+		 *    case we want make the objects permanent.
+		 * 2) There are other threads executing the method, in which case we
+		 *    will wait until the last thread has completed.
+		 */
+		if (!(method_desc->method.info_flags & ACPI_METHOD_MODULE_LEVEL)
+		    && (method_desc->method.thread_count == 1)) {
+
+			/* Delete any direct children of (created by) this method */
+
+			acpi_ns_delete_namespace_subtree(walk_state->
+							 method_node);
+
+			/*
+			 * Delete any objects that were created by this method
+			 * elsewhere in the namespace (if any were created).
+			 * Use of the ACPI_METHOD_MODIFIED_NAMESPACE optimizes the
+			 * deletion such that we don't have to perform an entire
+			 * namespace walk for every control method execution.
+			 */
+			if (method_desc->method.
+			    info_flags & ACPI_METHOD_MODIFIED_NAMESPACE) {
+				acpi_ns_delete_namespace_by_owner(method_desc->
+								  method.
+								  owner_id);
+				method_desc->method.info_flags &=
+				    ~ACPI_METHOD_MODIFIED_NAMESPACE;
+			}
+		}
+	}
+
+	/* Decrement the thread count on the method */
+
+	if (method_desc->method.thread_count) {
+		method_desc->method.thread_count--;
+	} else {
+		ACPI_ERROR((AE_INFO, "Invalid zero thread count in method"));
+	}
+
+	/* Are there any other threads currently executing this method? */
+
+	if (method_desc->method.thread_count) {
+		/*
+		 * Additional threads. Do not release the owner_id in this case,
+		 * we immediately reuse it for the next thread executing this method
+		 */
+		ACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,
+				  "*** Completed execution of one thread, %u threads remaining\n",
+				  method_desc->method.thread_count));
+	} else {
+		/* This is the only executing thread for this method */
+
+		/*
+		 * Support to dynamically change a method from not_serialized to
+		 * Serialized if it appears that the method is incorrectly written and
+		 * does not support multiple thread execution. The best example of this
+		 * is if such a method creates namespace objects and blocks. A second
+		 * thread will fail with an AE_ALREADY_EXISTS exception.
+		 *
+		 * This code is here because we must wait until the last thread exits
+		 * before marking the method as serialized.
+		 */
+		if (method_desc->method.
+		    info_flags & ACPI_METHOD_SERIALIZED_PENDING) {
+			if (walk_state) {
+				ACPI_INFO((AE_INFO,
+					   "Marking method %4.4s as Serialized because of AE_ALREADY_EXISTS error",
+					   walk_state->method_node->name.
+					   ascii));
+			}
+
+			/*
+			 * Method tried to create an object twice and was marked as
+			 * "pending serialized". The probable cause is that the method
+			 * cannot handle reentrancy.
+			 *
+			 * The method was created as not_serialized, but it tried to create
+			 * a named object and then blocked, causing the second thread
+			 * entrance to begin and then fail. Workaround this problem by
+			 * marking the method permanently as Serialized when the last
+			 * thread exits here.
+			 */
+			method_desc->method.info_flags &=
+			    ~ACPI_METHOD_SERIALIZED_PENDING;
+			method_desc->method.info_flags |=
+			    ACPI_METHOD_SERIALIZED;
+			method_desc->method.sync_level = 0;
+		}
+
+		/* No more threads, we can free the owner_id */
+
+		if (!
+		    (method_desc->method.
+		     info_flags & ACPI_METHOD_MODULE_LEVEL)) {
+			acpi_ut_release_owner_id(&method_desc->method.owner_id);
+		}
+	}
+
+	return_VOID;
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/dsmthdat.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/dsmthdat.c
new file mode 100644
index 00000000..d2c3cfd6
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/dsmthdat.c
@@ -0,0 +1,714 @@
+/*******************************************************************************
+ *
+ * Module Name: dsmthdat - control method arguments and local variables
+ *
+ ******************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acdispat.h"
+#include "acnamesp.h"
+#include "acinterp.h"
+
+#define _COMPONENT          ACPI_DISPATCHER
+ACPI_MODULE_NAME("dsmthdat")
+
+/* Local prototypes */
+static void
+acpi_ds_method_data_delete_value(u8 type,
+				 u32 index, struct acpi_walk_state *walk_state);
+
+static acpi_status
+acpi_ds_method_data_set_value(u8 type,
+			      u32 index,
+			      union acpi_operand_object *object,
+			      struct acpi_walk_state *walk_state);
+
+#ifdef ACPI_OBSOLETE_FUNCTIONS
+acpi_object_type
+acpi_ds_method_data_get_type(u16 opcode,
+			     u32 index, struct acpi_walk_state *walk_state);
+#endif
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_method_data_init
+ *
+ * PARAMETERS:  walk_state          - Current walk state object
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Initialize the data structures that hold the method's arguments
+ *              and locals.  The data struct is an array of namespace nodes for
+ *              each - this allows ref_of and de_ref_of to work properly for these
+ *              special data types.
+ *
+ * NOTES:       walk_state fields are initialized to zero by the
+ *              ACPI_ALLOCATE_ZEROED().
+ *
+ *              A pseudo-Namespace Node is assigned to each argument and local
+ *              so that ref_of() can return a pointer to the Node.
+ *
+ ******************************************************************************/
+
+void acpi_ds_method_data_init(struct acpi_walk_state *walk_state)
+{
+	u32 i;
+
+	ACPI_FUNCTION_TRACE(ds_method_data_init);
+
+	/* Init the method arguments */
+
+	for (i = 0; i < ACPI_METHOD_NUM_ARGS; i++) {
+		ACPI_MOVE_32_TO_32(&walk_state->arguments[i].name,
+				   NAMEOF_ARG_NTE);
+		walk_state->arguments[i].name.integer |= (i << 24);
+		walk_state->arguments[i].descriptor_type = ACPI_DESC_TYPE_NAMED;
+		walk_state->arguments[i].type = ACPI_TYPE_ANY;
+		walk_state->arguments[i].flags = ANOBJ_METHOD_ARG;
+	}
+
+	/* Init the method locals */
+
+	for (i = 0; i < ACPI_METHOD_NUM_LOCALS; i++) {
+		ACPI_MOVE_32_TO_32(&walk_state->local_variables[i].name,
+				   NAMEOF_LOCAL_NTE);
+
+		walk_state->local_variables[i].name.integer |= (i << 24);
+		walk_state->local_variables[i].descriptor_type =
+		    ACPI_DESC_TYPE_NAMED;
+		walk_state->local_variables[i].type = ACPI_TYPE_ANY;
+		walk_state->local_variables[i].flags = ANOBJ_METHOD_LOCAL;
+	}
+
+	return_VOID;
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_method_data_delete_all
+ *
+ * PARAMETERS:  walk_state          - Current walk state object
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Delete method locals and arguments.  Arguments are only
+ *              deleted if this method was called from another method.
+ *
+ ******************************************************************************/
+
+void acpi_ds_method_data_delete_all(struct acpi_walk_state *walk_state)
+{
+	u32 index;
+
+	ACPI_FUNCTION_TRACE(ds_method_data_delete_all);
+
+	/* Detach the locals */
+
+	for (index = 0; index < ACPI_METHOD_NUM_LOCALS; index++) {
+		if (walk_state->local_variables[index].object) {
+			ACPI_DEBUG_PRINT((ACPI_DB_EXEC, "Deleting Local%u=%p\n",
+					  index,
+					  walk_state->local_variables[index].
+					  object));
+
+			/* Detach object (if present) and remove a reference */
+
+			acpi_ns_detach_object(&walk_state->
+					      local_variables[index]);
+		}
+	}
+
+	/* Detach the arguments */
+
+	for (index = 0; index < ACPI_METHOD_NUM_ARGS; index++) {
+		if (walk_state->arguments[index].object) {
+			ACPI_DEBUG_PRINT((ACPI_DB_EXEC, "Deleting Arg%u=%p\n",
+					  index,
+					  walk_state->arguments[index].object));
+
+			/* Detach object (if present) and remove a reference */
+
+			acpi_ns_detach_object(&walk_state->arguments[index]);
+		}
+	}
+
+	return_VOID;
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_method_data_init_args
+ *
+ * PARAMETERS:  *Params         - Pointer to a parameter list for the method
+ *              max_param_count - The arg count for this method
+ *              walk_state      - Current walk state object
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Initialize arguments for a method.  The parameter list is a list
+ *              of ACPI operand objects, either null terminated or whose length
+ *              is defined by max_param_count.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ds_method_data_init_args(union acpi_operand_object **params,
+			      u32 max_param_count,
+			      struct acpi_walk_state *walk_state)
+{
+	acpi_status status;
+	u32 index = 0;
+
+	ACPI_FUNCTION_TRACE_PTR(ds_method_data_init_args, params);
+
+	if (!params) {
+		ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
+				  "No param list passed to method\n"));
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	/* Copy passed parameters into the new method stack frame */
+
+	while ((index < ACPI_METHOD_NUM_ARGS) &&
+	       (index < max_param_count) && params[index]) {
+		/*
+		 * A valid parameter.
+		 * Store the argument in the method/walk descriptor.
+		 * Do not copy the arg in order to implement call by reference
+		 */
+		status = acpi_ds_method_data_set_value(ACPI_REFCLASS_ARG, index,
+						       params[index],
+						       walk_state);
+		if (ACPI_FAILURE(status)) {
+			return_ACPI_STATUS(status);
+		}
+
+		index++;
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_EXEC, "%u args passed to method\n", index));
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_method_data_get_node
+ *
+ * PARAMETERS:  Type                - Either ACPI_REFCLASS_LOCAL or
+ *                                    ACPI_REFCLASS_ARG
+ *              Index               - Which Local or Arg whose type to get
+ *              walk_state          - Current walk state object
+ *              Node                - Where the node is returned.
+ *
+ * RETURN:      Status and node
+ *
+ * DESCRIPTION: Get the Node associated with a local or arg.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ds_method_data_get_node(u8 type,
+			     u32 index,
+			     struct acpi_walk_state *walk_state,
+			     struct acpi_namespace_node **node)
+{
+	ACPI_FUNCTION_TRACE(ds_method_data_get_node);
+
+	/*
+	 * Method Locals and Arguments are supported
+	 */
+	switch (type) {
+	case ACPI_REFCLASS_LOCAL:
+
+		if (index > ACPI_METHOD_MAX_LOCAL) {
+			ACPI_ERROR((AE_INFO,
+				    "Local index %u is invalid (max %u)",
+				    index, ACPI_METHOD_MAX_LOCAL));
+			return_ACPI_STATUS(AE_AML_INVALID_INDEX);
+		}
+
+		/* Return a pointer to the pseudo-node */
+
+		*node = &walk_state->local_variables[index];
+		break;
+
+	case ACPI_REFCLASS_ARG:
+
+		if (index > ACPI_METHOD_MAX_ARG) {
+			ACPI_ERROR((AE_INFO,
+				    "Arg index %u is invalid (max %u)",
+				    index, ACPI_METHOD_MAX_ARG));
+			return_ACPI_STATUS(AE_AML_INVALID_INDEX);
+		}
+
+		/* Return a pointer to the pseudo-node */
+
+		*node = &walk_state->arguments[index];
+		break;
+
+	default:
+		ACPI_ERROR((AE_INFO, "Type %u is invalid", type));
+		return_ACPI_STATUS(AE_TYPE);
+	}
+
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_method_data_set_value
+ *
+ * PARAMETERS:  Type                - Either ACPI_REFCLASS_LOCAL or
+ *                                    ACPI_REFCLASS_ARG
+ *              Index               - Which Local or Arg to get
+ *              Object              - Object to be inserted into the stack entry
+ *              walk_state          - Current walk state object
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Insert an object onto the method stack at entry Opcode:Index.
+ *              Note: There is no "implicit conversion" for locals.
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ds_method_data_set_value(u8 type,
+			      u32 index,
+			      union acpi_operand_object *object,
+			      struct acpi_walk_state *walk_state)
+{
+	acpi_status status;
+	struct acpi_namespace_node *node;
+
+	ACPI_FUNCTION_TRACE(ds_method_data_set_value);
+
+	ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
+			  "NewObj %p Type %2.2X, Refs=%u [%s]\n", object,
+			  type, object->common.reference_count,
+			  acpi_ut_get_type_name(object->common.type)));
+
+	/* Get the namespace node for the arg/local */
+
+	status = acpi_ds_method_data_get_node(type, index, walk_state, &node);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/*
+	 * Increment ref count so object can't be deleted while installed.
+	 * NOTE: We do not copy the object in order to preserve the call by
+	 * reference semantics of ACPI Control Method invocation.
+	 * (See ACPI Specification 2.0_c)
+	 */
+	acpi_ut_add_reference(object);
+
+	/* Install the object */
+
+	node->object = object;
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_method_data_get_value
+ *
+ * PARAMETERS:  Type                - Either ACPI_REFCLASS_LOCAL or
+ *                                    ACPI_REFCLASS_ARG
+ *              Index               - Which local_var or argument to get
+ *              walk_state          - Current walk state object
+ *              dest_desc           - Where Arg or Local value is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Retrieve value of selected Arg or Local for this method
+ *              Used only in acpi_ex_resolve_to_value().
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ds_method_data_get_value(u8 type,
+			      u32 index,
+			      struct acpi_walk_state *walk_state,
+			      union acpi_operand_object **dest_desc)
+{
+	acpi_status status;
+	struct acpi_namespace_node *node;
+	union acpi_operand_object *object;
+
+	ACPI_FUNCTION_TRACE(ds_method_data_get_value);
+
+	/* Validate the object descriptor */
+
+	if (!dest_desc) {
+		ACPI_ERROR((AE_INFO, "Null object descriptor pointer"));
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	/* Get the namespace node for the arg/local */
+
+	status = acpi_ds_method_data_get_node(type, index, walk_state, &node);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/* Get the object from the node */
+
+	object = node->object;
+
+	/* Examine the returned object, it must be valid. */
+
+	if (!object) {
+		/*
+		 * Index points to uninitialized object.
+		 * This means that either 1) The expected argument was
+		 * not passed to the method, or 2) A local variable
+		 * was referenced by the method (via the ASL)
+		 * before it was initialized.  Either case is an error.
+		 */
+
+		/* If slack enabled, init the local_x/arg_x to an Integer of value zero */
+
+		if (acpi_gbl_enable_interpreter_slack) {
+			object = acpi_ut_create_integer_object((u64)0);
+			if (!object) {
+				return_ACPI_STATUS(AE_NO_MEMORY);
+			}
+
+			node->object = object;
+		}
+
+		/* Otherwise, return the error */
+
+		else
+			switch (type) {
+			case ACPI_REFCLASS_ARG:
+
+				ACPI_ERROR((AE_INFO,
+					    "Uninitialized Arg[%u] at node %p",
+					    index, node));
+
+				return_ACPI_STATUS(AE_AML_UNINITIALIZED_ARG);
+
+			case ACPI_REFCLASS_LOCAL:
+
+				/*
+				 * No error message for this case, will be trapped again later to
+				 * detect and ignore cases of Store(local_x,local_x)
+				 */
+				return_ACPI_STATUS(AE_AML_UNINITIALIZED_LOCAL);
+
+			default:
+
+				ACPI_ERROR((AE_INFO,
+					    "Not a Arg/Local opcode: 0x%X",
+					    type));
+				return_ACPI_STATUS(AE_AML_INTERNAL);
+			}
+	}
+
+	/*
+	 * The Index points to an initialized and valid object.
+	 * Return an additional reference to the object
+	 */
+	*dest_desc = object;
+	acpi_ut_add_reference(object);
+
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_method_data_delete_value
+ *
+ * PARAMETERS:  Type                - Either ACPI_REFCLASS_LOCAL or
+ *                                    ACPI_REFCLASS_ARG
+ *              Index               - Which local_var or argument to delete
+ *              walk_state          - Current walk state object
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Delete the entry at Opcode:Index.  Inserts
+ *              a null into the stack slot after the object is deleted.
+ *
+ ******************************************************************************/
+
+static void
+acpi_ds_method_data_delete_value(u8 type,
+				 u32 index, struct acpi_walk_state *walk_state)
+{
+	acpi_status status;
+	struct acpi_namespace_node *node;
+	union acpi_operand_object *object;
+
+	ACPI_FUNCTION_TRACE(ds_method_data_delete_value);
+
+	/* Get the namespace node for the arg/local */
+
+	status = acpi_ds_method_data_get_node(type, index, walk_state, &node);
+	if (ACPI_FAILURE(status)) {
+		return_VOID;
+	}
+
+	/* Get the associated object */
+
+	object = acpi_ns_get_attached_object(node);
+
+	/*
+	 * Undefine the Arg or Local by setting its descriptor
+	 * pointer to NULL. Locals/Args can contain both
+	 * ACPI_OPERAND_OBJECTS and ACPI_NAMESPACE_NODEs
+	 */
+	node->object = NULL;
+
+	if ((object) &&
+	    (ACPI_GET_DESCRIPTOR_TYPE(object) == ACPI_DESC_TYPE_OPERAND)) {
+		/*
+		 * There is a valid object.
+		 * Decrement the reference count by one to balance the
+		 * increment when the object was stored.
+		 */
+		acpi_ut_remove_reference(object);
+	}
+
+	return_VOID;
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_store_object_to_local
+ *
+ * PARAMETERS:  Type                - Either ACPI_REFCLASS_LOCAL or
+ *                                    ACPI_REFCLASS_ARG
+ *              Index               - Which Local or Arg to set
+ *              obj_desc            - Value to be stored
+ *              walk_state          - Current walk state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Store a value in an Arg or Local.  The obj_desc is installed
+ *              as the new value for the Arg or Local and the reference count
+ *              for obj_desc is incremented.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ds_store_object_to_local(u8 type,
+			      u32 index,
+			      union acpi_operand_object *obj_desc,
+			      struct acpi_walk_state *walk_state)
+{
+	acpi_status status;
+	struct acpi_namespace_node *node;
+	union acpi_operand_object *current_obj_desc;
+	union acpi_operand_object *new_obj_desc;
+
+	ACPI_FUNCTION_TRACE(ds_store_object_to_local);
+	ACPI_DEBUG_PRINT((ACPI_DB_EXEC, "Type=%2.2X Index=%u Obj=%p\n",
+			  type, index, obj_desc));
+
+	/* Parameter validation */
+
+	if (!obj_desc) {
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	/* Get the namespace node for the arg/local */
+
+	status = acpi_ds_method_data_get_node(type, index, walk_state, &node);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	current_obj_desc = acpi_ns_get_attached_object(node);
+	if (current_obj_desc == obj_desc) {
+		ACPI_DEBUG_PRINT((ACPI_DB_EXEC, "Obj=%p already installed!\n",
+				  obj_desc));
+		return_ACPI_STATUS(status);
+	}
+
+	/*
+	 * If the reference count on the object is more than one, we must
+	 * take a copy of the object before we store.  A reference count
+	 * of exactly 1 means that the object was just created during the
+	 * evaluation of an expression, and we can safely use it since it
+	 * is not used anywhere else.
+	 */
+	new_obj_desc = obj_desc;
+	if (obj_desc->common.reference_count > 1) {
+		status =
+		    acpi_ut_copy_iobject_to_iobject(obj_desc, &new_obj_desc,
+						    walk_state);
+		if (ACPI_FAILURE(status)) {
+			return_ACPI_STATUS(status);
+		}
+	}
+
+	/*
+	 * If there is an object already in this slot, we either
+	 * have to delete it, or if this is an argument and there
+	 * is an object reference stored there, we have to do
+	 * an indirect store!
+	 */
+	if (current_obj_desc) {
+		/*
+		 * Check for an indirect store if an argument
+		 * contains an object reference (stored as an Node).
+		 * We don't allow this automatic dereferencing for
+		 * locals, since a store to a local should overwrite
+		 * anything there, including an object reference.
+		 *
+		 * If both Arg0 and Local0 contain ref_of (Local4):
+		 *
+		 * Store (1, Arg0)             - Causes indirect store to local4
+		 * Store (1, Local0)           - Stores 1 in local0, overwriting
+		 *                                  the reference to local4
+		 * Store (1, de_refof (Local0)) - Causes indirect store to local4
+		 *
+		 * Weird, but true.
+		 */
+		if (type == ACPI_REFCLASS_ARG) {
+			/*
+			 * If we have a valid reference object that came from ref_of(),
+			 * do the indirect store
+			 */
+			if ((ACPI_GET_DESCRIPTOR_TYPE(current_obj_desc) ==
+			     ACPI_DESC_TYPE_OPERAND)
+			    && (current_obj_desc->common.type ==
+				ACPI_TYPE_LOCAL_REFERENCE)
+			    && (current_obj_desc->reference.class ==
+				ACPI_REFCLASS_REFOF)) {
+				ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
+						  "Arg (%p) is an ObjRef(Node), storing in node %p\n",
+						  new_obj_desc,
+						  current_obj_desc));
+
+				/*
+				 * Store this object to the Node (perform the indirect store)
+				 * NOTE: No implicit conversion is performed, as per the ACPI
+				 * specification rules on storing to Locals/Args.
+				 */
+				status =
+				    acpi_ex_store_object_to_node(new_obj_desc,
+								 current_obj_desc->
+								 reference.
+								 object,
+								 walk_state,
+								 ACPI_NO_IMPLICIT_CONVERSION);
+
+				/* Remove local reference if we copied the object above */
+
+				if (new_obj_desc != obj_desc) {
+					acpi_ut_remove_reference(new_obj_desc);
+				}
+				return_ACPI_STATUS(status);
+			}
+		}
+
+		/* Delete the existing object before storing the new one */
+
+		acpi_ds_method_data_delete_value(type, index, walk_state);
+	}
+
+	/*
+	 * Install the Obj descriptor (*new_obj_desc) into
+	 * the descriptor for the Arg or Local.
+	 * (increments the object reference count by one)
+	 */
+	status =
+	    acpi_ds_method_data_set_value(type, index, new_obj_desc,
+					  walk_state);
+
+	/* Remove local reference if we copied the object above */
+
+	if (new_obj_desc != obj_desc) {
+		acpi_ut_remove_reference(new_obj_desc);
+	}
+
+	return_ACPI_STATUS(status);
+}
+
+#ifdef ACPI_OBSOLETE_FUNCTIONS
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_method_data_get_type
+ *
+ * PARAMETERS:  Opcode              - Either AML_LOCAL_OP or AML_ARG_OP
+ *              Index               - Which Local or Arg whose type to get
+ *              walk_state          - Current walk state object
+ *
+ * RETURN:      Data type of current value of the selected Arg or Local
+ *
+ * DESCRIPTION: Get the type of the object stored in the Local or Arg
+ *
+ ******************************************************************************/
+
+acpi_object_type
+acpi_ds_method_data_get_type(u16 opcode,
+			     u32 index, struct acpi_walk_state *walk_state)
+{
+	acpi_status status;
+	struct acpi_namespace_node *node;
+	union acpi_operand_object *object;
+
+	ACPI_FUNCTION_TRACE(ds_method_data_get_type);
+
+	/* Get the namespace node for the arg/local */
+
+	status = acpi_ds_method_data_get_node(opcode, index, walk_state, &node);
+	if (ACPI_FAILURE(status)) {
+		return_VALUE((ACPI_TYPE_NOT_FOUND));
+	}
+
+	/* Get the object */
+
+	object = acpi_ns_get_attached_object(node);
+	if (!object) {
+
+		/* Uninitialized local/arg, return TYPE_ANY */
+
+		return_VALUE(ACPI_TYPE_ANY);
+	}
+
+	/* Get the object type */
+
+	return_VALUE(object->type);
+}
+#endif
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/dsobject.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/dsobject.c
new file mode 100644
index 00000000..067060b3
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/dsobject.c
@@ -0,0 +1,841 @@
+/******************************************************************************
+ *
+ * Module Name: dsobject - Dispatcher object management routines
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acparser.h"
+#include "amlcode.h"
+#include "acdispat.h"
+#include "acnamesp.h"
+#include "acinterp.h"
+
+#define _COMPONENT          ACPI_DISPATCHER
+ACPI_MODULE_NAME("dsobject")
+
+/* Local prototypes */
+static acpi_status
+acpi_ds_build_internal_object(struct acpi_walk_state *walk_state,
+			      union acpi_parse_object *op,
+			      union acpi_operand_object **obj_desc_ptr);
+
+#ifndef ACPI_NO_METHOD_EXECUTION
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_build_internal_object
+ *
+ * PARAMETERS:  walk_state      - Current walk state
+ *              Op              - Parser object to be translated
+ *              obj_desc_ptr    - Where the ACPI internal object is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Translate a parser Op object to the equivalent namespace object
+ *              Simple objects are any objects other than a package object!
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ds_build_internal_object(struct acpi_walk_state *walk_state,
+			      union acpi_parse_object *op,
+			      union acpi_operand_object **obj_desc_ptr)
+{
+	union acpi_operand_object *obj_desc;
+	acpi_status status;
+	acpi_object_type type;
+
+	ACPI_FUNCTION_TRACE(ds_build_internal_object);
+
+	*obj_desc_ptr = NULL;
+	if (op->common.aml_opcode == AML_INT_NAMEPATH_OP) {
+		/*
+		 * This is a named object reference. If this name was
+		 * previously looked up in the namespace, it was stored in this op.
+		 * Otherwise, go ahead and look it up now
+		 */
+		if (!op->common.node) {
+			status = acpi_ns_lookup(walk_state->scope_info,
+						op->common.value.string,
+						ACPI_TYPE_ANY,
+						ACPI_IMODE_EXECUTE,
+						ACPI_NS_SEARCH_PARENT |
+						ACPI_NS_DONT_OPEN_SCOPE, NULL,
+						ACPI_CAST_INDIRECT_PTR(struct
+								       acpi_namespace_node,
+								       &(op->
+									 common.
+									 node)));
+			if (ACPI_FAILURE(status)) {
+
+				/* Check if we are resolving a named reference within a package */
+
+				if ((status == AE_NOT_FOUND)
+				    && (acpi_gbl_enable_interpreter_slack)
+				    &&
+				    ((op->common.parent->common.aml_opcode ==
+				      AML_PACKAGE_OP)
+				     || (op->common.parent->common.aml_opcode ==
+					 AML_VAR_PACKAGE_OP))) {
+					/*
+					 * We didn't find the target and we are populating elements
+					 * of a package - ignore if slack enabled. Some ASL code
+					 * contains dangling invalid references in packages and
+					 * expects that no exception will be issued. Leave the
+					 * element as a null element. It cannot be used, but it
+					 * can be overwritten by subsequent ASL code - this is
+					 * typically the case.
+					 */
+					ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+							  "Ignoring unresolved reference in package [%4.4s]\n",
+							  walk_state->
+							  scope_info->scope.
+							  node->name.ascii));
+
+					return_ACPI_STATUS(AE_OK);
+				} else {
+					ACPI_ERROR_NAMESPACE(op->common.value.
+							     string, status);
+				}
+
+				return_ACPI_STATUS(status);
+			}
+		}
+
+		/* Special object resolution for elements of a package */
+
+		if ((op->common.parent->common.aml_opcode == AML_PACKAGE_OP) ||
+		    (op->common.parent->common.aml_opcode ==
+		     AML_VAR_PACKAGE_OP)) {
+			/*
+			 * Attempt to resolve the node to a value before we insert it into
+			 * the package. If this is a reference to a common data type,
+			 * resolve it immediately. According to the ACPI spec, package
+			 * elements can only be "data objects" or method references.
+			 * Attempt to resolve to an Integer, Buffer, String or Package.
+			 * If cannot, return the named reference (for things like Devices,
+			 * Methods, etc.) Buffer Fields and Fields will resolve to simple
+			 * objects (int/buf/str/pkg).
+			 *
+			 * NOTE: References to things like Devices, Methods, Mutexes, etc.
+			 * will remain as named references. This behavior is not described
+			 * in the ACPI spec, but it appears to be an oversight.
+			 */
+			obj_desc =
+			    ACPI_CAST_PTR(union acpi_operand_object,
+					  op->common.node);
+
+			status =
+			    acpi_ex_resolve_node_to_value(ACPI_CAST_INDIRECT_PTR
+							  (struct
+							   acpi_namespace_node,
+							   &obj_desc),
+							  walk_state);
+			if (ACPI_FAILURE(status)) {
+				return_ACPI_STATUS(status);
+			}
+
+			/*
+			 * Special handling for Alias objects. We need to setup the type
+			 * and the Op->Common.Node to point to the Alias target. Note,
+			 * Alias has at most one level of indirection internally.
+			 */
+			type = op->common.node->type;
+			if (type == ACPI_TYPE_LOCAL_ALIAS) {
+				type = obj_desc->common.type;
+				op->common.node =
+				    ACPI_CAST_PTR(struct acpi_namespace_node,
+						  op->common.node->object);
+			}
+
+			switch (type) {
+				/*
+				 * For these types, we need the actual node, not the subobject.
+				 * However, the subobject did not get an extra reference count above.
+				 *
+				 * TBD: should ex_resolve_node_to_value be changed to fix this?
+				 */
+			case ACPI_TYPE_DEVICE:
+			case ACPI_TYPE_THERMAL:
+
+				acpi_ut_add_reference(op->common.node->object);
+
+				/*lint -fallthrough */
+				/*
+				 * For these types, we need the actual node, not the subobject.
+				 * The subobject got an extra reference count in ex_resolve_node_to_value.
+				 */
+			case ACPI_TYPE_MUTEX:
+			case ACPI_TYPE_METHOD:
+			case ACPI_TYPE_POWER:
+			case ACPI_TYPE_PROCESSOR:
+			case ACPI_TYPE_EVENT:
+			case ACPI_TYPE_REGION:
+
+				/* We will create a reference object for these types below */
+				break;
+
+			default:
+				/*
+				 * All other types - the node was resolved to an actual
+				 * object, we are done.
+				 */
+				goto exit;
+			}
+		}
+	}
+
+	/* Create and init a new internal ACPI object */
+
+	obj_desc = acpi_ut_create_internal_object((acpi_ps_get_opcode_info
+						   (op->common.aml_opcode))->
+						  object_type);
+	if (!obj_desc) {
+		return_ACPI_STATUS(AE_NO_MEMORY);
+	}
+
+	status =
+	    acpi_ds_init_object_from_op(walk_state, op, op->common.aml_opcode,
+					&obj_desc);
+	if (ACPI_FAILURE(status)) {
+		acpi_ut_remove_reference(obj_desc);
+		return_ACPI_STATUS(status);
+	}
+
+      exit:
+	*obj_desc_ptr = obj_desc;
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_build_internal_buffer_obj
+ *
+ * PARAMETERS:  walk_state      - Current walk state
+ *              Op              - Parser object to be translated
+ *              buffer_length   - Length of the buffer
+ *              obj_desc_ptr    - Where the ACPI internal object is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Translate a parser Op package object to the equivalent
+ *              namespace object
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ds_build_internal_buffer_obj(struct acpi_walk_state *walk_state,
+				  union acpi_parse_object *op,
+				  u32 buffer_length,
+				  union acpi_operand_object **obj_desc_ptr)
+{
+	union acpi_parse_object *arg;
+	union acpi_operand_object *obj_desc;
+	union acpi_parse_object *byte_list;
+	u32 byte_list_length = 0;
+
+	ACPI_FUNCTION_TRACE(ds_build_internal_buffer_obj);
+
+	/*
+	 * If we are evaluating a Named buffer object "Name (xxxx, Buffer)".
+	 * The buffer object already exists (from the NS node), otherwise it must
+	 * be created.
+	 */
+	obj_desc = *obj_desc_ptr;
+	if (!obj_desc) {
+
+		/* Create a new buffer object */
+
+		obj_desc = acpi_ut_create_internal_object(ACPI_TYPE_BUFFER);
+		*obj_desc_ptr = obj_desc;
+		if (!obj_desc) {
+			return_ACPI_STATUS(AE_NO_MEMORY);
+		}
+	}
+
+	/*
+	 * Second arg is the buffer data (optional) byte_list can be either
+	 * individual bytes or a string initializer.  In either case, a
+	 * byte_list appears in the AML.
+	 */
+	arg = op->common.value.arg;	/* skip first arg */
+
+	byte_list = arg->named.next;
+	if (byte_list) {
+		if (byte_list->common.aml_opcode != AML_INT_BYTELIST_OP) {
+			ACPI_ERROR((AE_INFO,
+				    "Expecting bytelist, found AML opcode 0x%X in op %p",
+				    byte_list->common.aml_opcode, byte_list));
+
+			acpi_ut_remove_reference(obj_desc);
+			return (AE_TYPE);
+		}
+
+		byte_list_length = (u32)byte_list->common.value.integer;
+	}
+
+	/*
+	 * The buffer length (number of bytes) will be the larger of:
+	 * 1) The specified buffer length and
+	 * 2) The length of the initializer byte list
+	 */
+	obj_desc->buffer.length = buffer_length;
+	if (byte_list_length > buffer_length) {
+		obj_desc->buffer.length = byte_list_length;
+	}
+
+	/* Allocate the buffer */
+
+	if (obj_desc->buffer.length == 0) {
+		obj_desc->buffer.pointer = NULL;
+		ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
+				  "Buffer defined with zero length in AML, creating\n"));
+	} else {
+		obj_desc->buffer.pointer =
+		    ACPI_ALLOCATE_ZEROED(obj_desc->buffer.length);
+		if (!obj_desc->buffer.pointer) {
+			acpi_ut_delete_object_desc(obj_desc);
+			return_ACPI_STATUS(AE_NO_MEMORY);
+		}
+
+		/* Initialize buffer from the byte_list (if present) */
+
+		if (byte_list) {
+			ACPI_MEMCPY(obj_desc->buffer.pointer,
+				    byte_list->named.data, byte_list_length);
+		}
+	}
+
+	obj_desc->buffer.flags |= AOPOBJ_DATA_VALID;
+	op->common.node = ACPI_CAST_PTR(struct acpi_namespace_node, obj_desc);
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_build_internal_package_obj
+ *
+ * PARAMETERS:  walk_state      - Current walk state
+ *              Op              - Parser object to be translated
+ *              element_count   - Number of elements in the package - this is
+ *                                the num_elements argument to Package()
+ *              obj_desc_ptr    - Where the ACPI internal object is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Translate a parser Op package object to the equivalent
+ *              namespace object
+ *
+ * NOTE: The number of elements in the package will be always be the num_elements
+ * count, regardless of the number of elements in the package list. If
+ * num_elements is smaller, only that many package list elements are used.
+ * if num_elements is larger, the Package object is padded out with
+ * objects of type Uninitialized (as per ACPI spec.)
+ *
+ * Even though the ASL compilers do not allow num_elements to be smaller
+ * than the Package list length (for the fixed length package opcode), some
+ * BIOS code modifies the AML on the fly to adjust the num_elements, and
+ * this code compensates for that. This also provides compatibility with
+ * other AML interpreters.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ds_build_internal_package_obj(struct acpi_walk_state *walk_state,
+				   union acpi_parse_object *op,
+				   u32 element_count,
+				   union acpi_operand_object **obj_desc_ptr)
+{
+	union acpi_parse_object *arg;
+	union acpi_parse_object *parent;
+	union acpi_operand_object *obj_desc = NULL;
+	acpi_status status = AE_OK;
+	u32 i;
+	u16 index;
+	u16 reference_count;
+
+	ACPI_FUNCTION_TRACE(ds_build_internal_package_obj);
+
+	/* Find the parent of a possibly nested package */
+
+	parent = op->common.parent;
+	while ((parent->common.aml_opcode == AML_PACKAGE_OP) ||
+	       (parent->common.aml_opcode == AML_VAR_PACKAGE_OP)) {
+		parent = parent->common.parent;
+	}
+
+	/*
+	 * If we are evaluating a Named package object "Name (xxxx, Package)",
+	 * the package object already exists, otherwise it must be created.
+	 */
+	obj_desc = *obj_desc_ptr;
+	if (!obj_desc) {
+		obj_desc = acpi_ut_create_internal_object(ACPI_TYPE_PACKAGE);
+		*obj_desc_ptr = obj_desc;
+		if (!obj_desc) {
+			return_ACPI_STATUS(AE_NO_MEMORY);
+		}
+
+		obj_desc->package.node = parent->common.node;
+	}
+
+	/*
+	 * Allocate the element array (array of pointers to the individual
+	 * objects) based on the num_elements parameter. Add an extra pointer slot
+	 * so that the list is always null terminated.
+	 */
+	obj_desc->package.elements = ACPI_ALLOCATE_ZEROED(((acpi_size)
+							   element_count +
+							   1) * sizeof(void *));
+
+	if (!obj_desc->package.elements) {
+		acpi_ut_delete_object_desc(obj_desc);
+		return_ACPI_STATUS(AE_NO_MEMORY);
+	}
+
+	obj_desc->package.count = element_count;
+
+	/*
+	 * Initialize the elements of the package, up to the num_elements count.
+	 * Package is automatically padded with uninitialized (NULL) elements
+	 * if num_elements is greater than the package list length. Likewise,
+	 * Package is truncated if num_elements is less than the list length.
+	 */
+	arg = op->common.value.arg;
+	arg = arg->common.next;
+	for (i = 0; arg && (i < element_count); i++) {
+		if (arg->common.aml_opcode == AML_INT_RETURN_VALUE_OP) {
+			if (arg->common.node->type == ACPI_TYPE_METHOD) {
+				/*
+				 * A method reference "looks" to the parser to be a method
+				 * invocation, so we special case it here
+				 */
+				arg->common.aml_opcode = AML_INT_NAMEPATH_OP;
+				status =
+				    acpi_ds_build_internal_object(walk_state,
+								  arg,
+								  &obj_desc->
+								  package.
+								  elements[i]);
+			} else {
+				/* This package element is already built, just get it */
+
+				obj_desc->package.elements[i] =
+				    ACPI_CAST_PTR(union acpi_operand_object,
+						  arg->common.node);
+			}
+		} else {
+			status = acpi_ds_build_internal_object(walk_state, arg,
+							       &obj_desc->
+							       package.
+							       elements[i]);
+		}
+
+		if (*obj_desc_ptr) {
+
+			/* Existing package, get existing reference count */
+
+			reference_count =
+			    (*obj_desc_ptr)->common.reference_count;
+			if (reference_count > 1) {
+
+				/* Make new element ref count match original ref count */
+
+				for (index = 0; index < (reference_count - 1);
+				     index++) {
+					acpi_ut_add_reference((obj_desc->
+							       package.
+							       elements[i]));
+				}
+			}
+		}
+
+		arg = arg->common.next;
+	}
+
+	/* Check for match between num_elements and actual length of package_list */
+
+	if (arg) {
+		/*
+		 * num_elements was exhausted, but there are remaining elements in the
+		 * package_list. Truncate the package to num_elements.
+		 *
+		 * Note: technically, this is an error, from ACPI spec: "It is an error
+		 * for NumElements to be less than the number of elements in the
+		 * PackageList". However, we just print a message and
+		 * no exception is returned. This provides Windows compatibility. Some
+		 * BIOSs will alter the num_elements on the fly, creating this type
+		 * of ill-formed package object.
+		 */
+		while (arg) {
+			/*
+			 * We must delete any package elements that were created earlier
+			 * and are not going to be used because of the package truncation.
+			 */
+			if (arg->common.node) {
+				acpi_ut_remove_reference(ACPI_CAST_PTR
+							 (union
+							  acpi_operand_object,
+							  arg->common.node));
+				arg->common.node = NULL;
+			}
+
+			/* Find out how many elements there really are */
+
+			i++;
+			arg = arg->common.next;
+		}
+
+		ACPI_INFO((AE_INFO,
+			   "Actual Package length (%u) is larger than NumElements field (%u), truncated\n",
+			   i, element_count));
+	} else if (i < element_count) {
+		/*
+		 * Arg list (elements) was exhausted, but we did not reach num_elements count.
+		 * Note: this is not an error, the package is padded out with NULLs.
+		 */
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+				  "Package List length (%u) smaller than NumElements count (%u), padded with null elements\n",
+				  i, element_count));
+	}
+
+	obj_desc->package.flags |= AOPOBJ_DATA_VALID;
+	op->common.node = ACPI_CAST_PTR(struct acpi_namespace_node, obj_desc);
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_create_node
+ *
+ * PARAMETERS:  walk_state      - Current walk state
+ *              Node            - NS Node to be initialized
+ *              Op              - Parser object to be translated
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Create the object to be associated with a namespace node
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ds_create_node(struct acpi_walk_state *walk_state,
+		    struct acpi_namespace_node *node,
+		    union acpi_parse_object *op)
+{
+	acpi_status status;
+	union acpi_operand_object *obj_desc;
+
+	ACPI_FUNCTION_TRACE_PTR(ds_create_node, op);
+
+	/*
+	 * Because of the execution pass through the non-control-method
+	 * parts of the table, we can arrive here twice.  Only init
+	 * the named object node the first time through
+	 */
+	if (acpi_ns_get_attached_object(node)) {
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	if (!op->common.value.arg) {
+
+		/* No arguments, there is nothing to do */
+
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	/* Build an internal object for the argument(s) */
+
+	status = acpi_ds_build_internal_object(walk_state, op->common.value.arg,
+					       &obj_desc);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/* Re-type the object according to its argument */
+
+	node->type = obj_desc->common.type;
+
+	/* Attach obj to node */
+
+	status = acpi_ns_attach_object(node, obj_desc, node->type);
+
+	/* Remove local reference to the object */
+
+	acpi_ut_remove_reference(obj_desc);
+	return_ACPI_STATUS(status);
+}
+
+#endif				/* ACPI_NO_METHOD_EXECUTION */
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_init_object_from_op
+ *
+ * PARAMETERS:  walk_state      - Current walk state
+ *              Op              - Parser op used to init the internal object
+ *              Opcode          - AML opcode associated with the object
+ *              ret_obj_desc    - Namespace object to be initialized
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Initialize a namespace object from a parser Op and its
+ *              associated arguments.  The namespace object is a more compact
+ *              representation of the Op and its arguments.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ds_init_object_from_op(struct acpi_walk_state *walk_state,
+			    union acpi_parse_object *op,
+			    u16 opcode,
+			    union acpi_operand_object **ret_obj_desc)
+{
+	const struct acpi_opcode_info *op_info;
+	union acpi_operand_object *obj_desc;
+	acpi_status status = AE_OK;
+
+	ACPI_FUNCTION_TRACE(ds_init_object_from_op);
+
+	obj_desc = *ret_obj_desc;
+	op_info = acpi_ps_get_opcode_info(opcode);
+	if (op_info->class == AML_CLASS_UNKNOWN) {
+
+		/* Unknown opcode */
+
+		return_ACPI_STATUS(AE_TYPE);
+	}
+
+	/* Perform per-object initialization */
+
+	switch (obj_desc->common.type) {
+	case ACPI_TYPE_BUFFER:
+
+		/*
+		 * Defer evaluation of Buffer term_arg operand
+		 */
+		obj_desc->buffer.node =
+		    ACPI_CAST_PTR(struct acpi_namespace_node,
+				  walk_state->operands[0]);
+		obj_desc->buffer.aml_start = op->named.data;
+		obj_desc->buffer.aml_length = op->named.length;
+		break;
+
+	case ACPI_TYPE_PACKAGE:
+
+		/*
+		 * Defer evaluation of Package term_arg operand
+		 */
+		obj_desc->package.node =
+		    ACPI_CAST_PTR(struct acpi_namespace_node,
+				  walk_state->operands[0]);
+		obj_desc->package.aml_start = op->named.data;
+		obj_desc->package.aml_length = op->named.length;
+		break;
+
+	case ACPI_TYPE_INTEGER:
+
+		switch (op_info->type) {
+		case AML_TYPE_CONSTANT:
+			/*
+			 * Resolve AML Constants here - AND ONLY HERE!
+			 * All constants are integers.
+			 * We mark the integer with a flag that indicates that it started
+			 * life as a constant -- so that stores to constants will perform
+			 * as expected (noop). zero_op is used as a placeholder for optional
+			 * target operands.
+			 */
+			obj_desc->common.flags = AOPOBJ_AML_CONSTANT;
+
+			switch (opcode) {
+			case AML_ZERO_OP:
+
+				obj_desc->integer.value = 0;
+				break;
+
+			case AML_ONE_OP:
+
+				obj_desc->integer.value = 1;
+				break;
+
+			case AML_ONES_OP:
+
+				obj_desc->integer.value = ACPI_UINT64_MAX;
+
+				/* Truncate value if we are executing from a 32-bit ACPI table */
+
+#ifndef ACPI_NO_METHOD_EXECUTION
+				acpi_ex_truncate_for32bit_table(obj_desc);
+#endif
+				break;
+
+			case AML_REVISION_OP:
+
+				obj_desc->integer.value = ACPI_CA_VERSION;
+				break;
+
+			default:
+
+				ACPI_ERROR((AE_INFO,
+					    "Unknown constant opcode 0x%X",
+					    opcode));
+				status = AE_AML_OPERAND_TYPE;
+				break;
+			}
+			break;
+
+		case AML_TYPE_LITERAL:
+
+			obj_desc->integer.value = op->common.value.integer;
+#ifndef ACPI_NO_METHOD_EXECUTION
+			acpi_ex_truncate_for32bit_table(obj_desc);
+#endif
+			break;
+
+		default:
+			ACPI_ERROR((AE_INFO, "Unknown Integer type 0x%X",
+				    op_info->type));
+			status = AE_AML_OPERAND_TYPE;
+			break;
+		}
+		break;
+
+	case ACPI_TYPE_STRING:
+
+		obj_desc->string.pointer = op->common.value.string;
+		obj_desc->string.length =
+		    (u32)ACPI_STRLEN(op->common.value.string);
+
+		/*
+		 * The string is contained in the ACPI table, don't ever try
+		 * to delete it
+		 */
+		obj_desc->common.flags |= AOPOBJ_STATIC_POINTER;
+		break;
+
+	case ACPI_TYPE_METHOD:
+		break;
+
+	case ACPI_TYPE_LOCAL_REFERENCE:
+
+		switch (op_info->type) {
+		case AML_TYPE_LOCAL_VARIABLE:
+
+			/* Local ID (0-7) is (AML opcode - base AML_LOCAL_OP) */
+
+			obj_desc->reference.value =
+			    ((u32)opcode) - AML_LOCAL_OP;
+			obj_desc->reference.class = ACPI_REFCLASS_LOCAL;
+
+#ifndef ACPI_NO_METHOD_EXECUTION
+			status =
+			    acpi_ds_method_data_get_node(ACPI_REFCLASS_LOCAL,
+							 obj_desc->reference.
+							 value, walk_state,
+							 ACPI_CAST_INDIRECT_PTR
+							 (struct
+							  acpi_namespace_node,
+							  &obj_desc->reference.
+							  object));
+#endif
+			break;
+
+		case AML_TYPE_METHOD_ARGUMENT:
+
+			/* Arg ID (0-6) is (AML opcode - base AML_ARG_OP) */
+
+			obj_desc->reference.value = ((u32)opcode) - AML_ARG_OP;
+			obj_desc->reference.class = ACPI_REFCLASS_ARG;
+
+#ifndef ACPI_NO_METHOD_EXECUTION
+			status = acpi_ds_method_data_get_node(ACPI_REFCLASS_ARG,
+							      obj_desc->
+							      reference.value,
+							      walk_state,
+							      ACPI_CAST_INDIRECT_PTR
+							      (struct
+							       acpi_namespace_node,
+							       &obj_desc->
+							       reference.
+							       object));
+#endif
+			break;
+
+		default:	/* Object name or Debug object */
+
+			switch (op->common.aml_opcode) {
+			case AML_INT_NAMEPATH_OP:
+
+				/* Node was saved in Op */
+
+				obj_desc->reference.node = op->common.node;
+				obj_desc->reference.object =
+				    op->common.node->object;
+				obj_desc->reference.class = ACPI_REFCLASS_NAME;
+				break;
+
+			case AML_DEBUG_OP:
+
+				obj_desc->reference.class = ACPI_REFCLASS_DEBUG;
+				break;
+
+			default:
+
+				ACPI_ERROR((AE_INFO,
+					    "Unimplemented reference type for AML opcode: 0x%4.4X",
+					    opcode));
+				return_ACPI_STATUS(AE_AML_OPERAND_TYPE);
+			}
+			break;
+		}
+		break;
+
+	default:
+
+		ACPI_ERROR((AE_INFO, "Unimplemented data type: 0x%X",
+			    obj_desc->common.type));
+
+		status = AE_AML_OPERAND_TYPE;
+		break;
+	}
+
+	return_ACPI_STATUS(status);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/dsopcode.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/dsopcode.c
new file mode 100644
index 00000000..68d84ecc
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/dsopcode.c
@@ -0,0 +1,757 @@
+/******************************************************************************
+ *
+ * Module Name: dsopcode - Dispatcher suport for regions and fields
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acparser.h"
+#include "amlcode.h"
+#include "acdispat.h"
+#include "acinterp.h"
+#include "acnamesp.h"
+#include "acevents.h"
+#include "actables.h"
+
+#define _COMPONENT          ACPI_DISPATCHER
+ACPI_MODULE_NAME("dsopcode")
+
+/* Local prototypes */
+static acpi_status
+acpi_ds_init_buffer_field(u16 aml_opcode,
+			  union acpi_operand_object *obj_desc,
+			  union acpi_operand_object *buffer_desc,
+			  union acpi_operand_object *offset_desc,
+			  union acpi_operand_object *length_desc,
+			  union acpi_operand_object *result_desc);
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_initialize_region
+ *
+ * PARAMETERS:  obj_handle      - Region namespace node
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Front end to ev_initialize_region
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ds_initialize_region(acpi_handle obj_handle)
+{
+	union acpi_operand_object *obj_desc;
+	acpi_status status;
+
+	obj_desc = acpi_ns_get_attached_object(obj_handle);
+
+	/* Namespace is NOT locked */
+
+	status = acpi_ev_initialize_region(obj_desc, FALSE);
+	return (status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_init_buffer_field
+ *
+ * PARAMETERS:  aml_opcode      - create_xxx_field
+ *              obj_desc        - buffer_field object
+ *              buffer_desc     - Host Buffer
+ *              offset_desc     - Offset into buffer
+ *              length_desc     - Length of field (CREATE_FIELD_OP only)
+ *              result_desc     - Where to store the result
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Perform actual initialization of a buffer field
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ds_init_buffer_field(u16 aml_opcode,
+			  union acpi_operand_object *obj_desc,
+			  union acpi_operand_object *buffer_desc,
+			  union acpi_operand_object *offset_desc,
+			  union acpi_operand_object *length_desc,
+			  union acpi_operand_object *result_desc)
+{
+	u32 offset;
+	u32 bit_offset;
+	u32 bit_count;
+	u8 field_flags;
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE_PTR(ds_init_buffer_field, obj_desc);
+
+	/* Host object must be a Buffer */
+
+	if (buffer_desc->common.type != ACPI_TYPE_BUFFER) {
+		ACPI_ERROR((AE_INFO,
+			    "Target of Create Field is not a Buffer object - %s",
+			    acpi_ut_get_object_type_name(buffer_desc)));
+
+		status = AE_AML_OPERAND_TYPE;
+		goto cleanup;
+	}
+
+	/*
+	 * The last parameter to all of these opcodes (result_desc) started
+	 * out as a name_string, and should therefore now be a NS node
+	 * after resolution in acpi_ex_resolve_operands().
+	 */
+	if (ACPI_GET_DESCRIPTOR_TYPE(result_desc) != ACPI_DESC_TYPE_NAMED) {
+		ACPI_ERROR((AE_INFO,
+			    "(%s) destination not a NS Node [%s]",
+			    acpi_ps_get_opcode_name(aml_opcode),
+			    acpi_ut_get_descriptor_name(result_desc)));
+
+		status = AE_AML_OPERAND_TYPE;
+		goto cleanup;
+	}
+
+	offset = (u32)offset_desc->integer.value;
+
+	/*
+	 * Setup the Bit offsets and counts, according to the opcode
+	 */
+	switch (aml_opcode) {
+	case AML_CREATE_FIELD_OP:
+
+		/* Offset is in bits, count is in bits */
+
+		field_flags = AML_FIELD_ACCESS_BYTE;
+		bit_offset = offset;
+		bit_count = (u32)length_desc->integer.value;
+
+		/* Must have a valid (>0) bit count */
+
+		if (bit_count == 0) {
+			ACPI_ERROR((AE_INFO,
+				    "Attempt to CreateField of length zero"));
+			status = AE_AML_OPERAND_VALUE;
+			goto cleanup;
+		}
+		break;
+
+	case AML_CREATE_BIT_FIELD_OP:
+
+		/* Offset is in bits, Field is one bit */
+
+		bit_offset = offset;
+		bit_count = 1;
+		field_flags = AML_FIELD_ACCESS_BYTE;
+		break;
+
+	case AML_CREATE_BYTE_FIELD_OP:
+
+		/* Offset is in bytes, field is one byte */
+
+		bit_offset = 8 * offset;
+		bit_count = 8;
+		field_flags = AML_FIELD_ACCESS_BYTE;
+		break;
+
+	case AML_CREATE_WORD_FIELD_OP:
+
+		/* Offset is in bytes, field is one word */
+
+		bit_offset = 8 * offset;
+		bit_count = 16;
+		field_flags = AML_FIELD_ACCESS_WORD;
+		break;
+
+	case AML_CREATE_DWORD_FIELD_OP:
+
+		/* Offset is in bytes, field is one dword */
+
+		bit_offset = 8 * offset;
+		bit_count = 32;
+		field_flags = AML_FIELD_ACCESS_DWORD;
+		break;
+
+	case AML_CREATE_QWORD_FIELD_OP:
+
+		/* Offset is in bytes, field is one qword */
+
+		bit_offset = 8 * offset;
+		bit_count = 64;
+		field_flags = AML_FIELD_ACCESS_QWORD;
+		break;
+
+	default:
+
+		ACPI_ERROR((AE_INFO,
+			    "Unknown field creation opcode 0x%02X",
+			    aml_opcode));
+		status = AE_AML_BAD_OPCODE;
+		goto cleanup;
+	}
+
+	/* Entire field must fit within the current length of the buffer */
+
+	if ((bit_offset + bit_count) > (8 * (u32)buffer_desc->buffer.length)) {
+		ACPI_ERROR((AE_INFO,
+			    "Field [%4.4s] at %u exceeds Buffer [%4.4s] size %u (bits)",
+			    acpi_ut_get_node_name(result_desc),
+			    bit_offset + bit_count,
+			    acpi_ut_get_node_name(buffer_desc->buffer.node),
+			    8 * (u32)buffer_desc->buffer.length));
+		status = AE_AML_BUFFER_LIMIT;
+		goto cleanup;
+	}
+
+	/*
+	 * Initialize areas of the field object that are common to all fields
+	 * For field_flags, use LOCK_RULE = 0 (NO_LOCK),
+	 * UPDATE_RULE = 0 (UPDATE_PRESERVE)
+	 */
+	status = acpi_ex_prep_common_field_object(obj_desc, field_flags, 0,
+						  bit_offset, bit_count);
+	if (ACPI_FAILURE(status)) {
+		goto cleanup;
+	}
+
+	obj_desc->buffer_field.buffer_obj = buffer_desc;
+
+	/* Reference count for buffer_desc inherits obj_desc count */
+
+	buffer_desc->common.reference_count = (u16)
+	    (buffer_desc->common.reference_count +
+	     obj_desc->common.reference_count);
+
+      cleanup:
+
+	/* Always delete the operands */
+
+	acpi_ut_remove_reference(offset_desc);
+	acpi_ut_remove_reference(buffer_desc);
+
+	if (aml_opcode == AML_CREATE_FIELD_OP) {
+		acpi_ut_remove_reference(length_desc);
+	}
+
+	/* On failure, delete the result descriptor */
+
+	if (ACPI_FAILURE(status)) {
+		acpi_ut_remove_reference(result_desc);	/* Result descriptor */
+	} else {
+		/* Now the address and length are valid for this buffer_field */
+
+		obj_desc->buffer_field.flags |= AOPOBJ_DATA_VALID;
+	}
+
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_eval_buffer_field_operands
+ *
+ * PARAMETERS:  walk_state      - Current walk
+ *              Op              - A valid buffer_field Op object
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Get buffer_field Buffer and Index
+ *              Called from acpi_ds_exec_end_op during buffer_field parse tree walk
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ds_eval_buffer_field_operands(struct acpi_walk_state *walk_state,
+				   union acpi_parse_object *op)
+{
+	acpi_status status;
+	union acpi_operand_object *obj_desc;
+	struct acpi_namespace_node *node;
+	union acpi_parse_object *next_op;
+
+	ACPI_FUNCTION_TRACE_PTR(ds_eval_buffer_field_operands, op);
+
+	/*
+	 * This is where we evaluate the address and length fields of the
+	 * create_xxx_field declaration
+	 */
+	node = op->common.node;
+
+	/* next_op points to the op that holds the Buffer */
+
+	next_op = op->common.value.arg;
+
+	/* Evaluate/create the address and length operands */
+
+	status = acpi_ds_create_operands(walk_state, next_op);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	obj_desc = acpi_ns_get_attached_object(node);
+	if (!obj_desc) {
+		return_ACPI_STATUS(AE_NOT_EXIST);
+	}
+
+	/* Resolve the operands */
+
+	status = acpi_ex_resolve_operands(op->common.aml_opcode,
+					  ACPI_WALK_OPERANDS, walk_state);
+	if (ACPI_FAILURE(status)) {
+		ACPI_ERROR((AE_INFO, "(%s) bad operand(s), status 0x%X",
+			    acpi_ps_get_opcode_name(op->common.aml_opcode),
+			    status));
+
+		return_ACPI_STATUS(status);
+	}
+
+	/* Initialize the Buffer Field */
+
+	if (op->common.aml_opcode == AML_CREATE_FIELD_OP) {
+
+		/* NOTE: Slightly different operands for this opcode */
+
+		status =
+		    acpi_ds_init_buffer_field(op->common.aml_opcode, obj_desc,
+					      walk_state->operands[0],
+					      walk_state->operands[1],
+					      walk_state->operands[2],
+					      walk_state->operands[3]);
+	} else {
+		/* All other, create_xxx_field opcodes */
+
+		status =
+		    acpi_ds_init_buffer_field(op->common.aml_opcode, obj_desc,
+					      walk_state->operands[0],
+					      walk_state->operands[1], NULL,
+					      walk_state->operands[2]);
+	}
+
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_eval_region_operands
+ *
+ * PARAMETERS:  walk_state      - Current walk
+ *              Op              - A valid region Op object
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Get region address and length
+ *              Called from acpi_ds_exec_end_op during op_region parse tree walk
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ds_eval_region_operands(struct acpi_walk_state *walk_state,
+			     union acpi_parse_object *op)
+{
+	acpi_status status;
+	union acpi_operand_object *obj_desc;
+	union acpi_operand_object *operand_desc;
+	struct acpi_namespace_node *node;
+	union acpi_parse_object *next_op;
+
+	ACPI_FUNCTION_TRACE_PTR(ds_eval_region_operands, op);
+
+	/*
+	 * This is where we evaluate the address and length fields of the
+	 * op_region declaration
+	 */
+	node = op->common.node;
+
+	/* next_op points to the op that holds the space_iD */
+
+	next_op = op->common.value.arg;
+
+	/* next_op points to address op */
+
+	next_op = next_op->common.next;
+
+	/* Evaluate/create the address and length operands */
+
+	status = acpi_ds_create_operands(walk_state, next_op);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/* Resolve the length and address operands to numbers */
+
+	status = acpi_ex_resolve_operands(op->common.aml_opcode,
+					  ACPI_WALK_OPERANDS, walk_state);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	obj_desc = acpi_ns_get_attached_object(node);
+	if (!obj_desc) {
+		return_ACPI_STATUS(AE_NOT_EXIST);
+	}
+
+	/*
+	 * Get the length operand and save it
+	 * (at Top of stack)
+	 */
+	operand_desc = walk_state->operands[walk_state->num_operands - 1];
+
+	obj_desc->region.length = (u32)operand_desc->integer.value;
+	acpi_ut_remove_reference(operand_desc);
+
+	/*
+	 * Get the address and save it
+	 * (at top of stack - 1)
+	 */
+	operand_desc = walk_state->operands[walk_state->num_operands - 2];
+
+	obj_desc->region.address = (acpi_physical_address)
+	    operand_desc->integer.value;
+	acpi_ut_remove_reference(operand_desc);
+
+	ACPI_DEBUG_PRINT((ACPI_DB_EXEC, "RgnObj %p Addr %8.8X%8.8X Len %X\n",
+			  obj_desc,
+			  ACPI_FORMAT_NATIVE_UINT(obj_desc->region.address),
+			  obj_desc->region.length));
+
+	/* Now the address and length are valid for this opregion */
+
+	obj_desc->region.flags |= AOPOBJ_DATA_VALID;
+
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_eval_table_region_operands
+ *
+ * PARAMETERS:  walk_state      - Current walk
+ *              Op              - A valid region Op object
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Get region address and length.
+ *              Called from acpi_ds_exec_end_op during data_table_region parse
+ *              tree walk.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ds_eval_table_region_operands(struct acpi_walk_state *walk_state,
+				   union acpi_parse_object *op)
+{
+	acpi_status status;
+	union acpi_operand_object *obj_desc;
+	union acpi_operand_object **operand;
+	struct acpi_namespace_node *node;
+	union acpi_parse_object *next_op;
+	u32 table_index;
+	struct acpi_table_header *table;
+
+	ACPI_FUNCTION_TRACE_PTR(ds_eval_table_region_operands, op);
+
+	/*
+	 * This is where we evaluate the signature_string and oem_iDString
+	 * and oem_table_iDString of the data_table_region declaration
+	 */
+	node = op->common.node;
+
+	/* next_op points to signature_string op */
+
+	next_op = op->common.value.arg;
+
+	/*
+	 * Evaluate/create the signature_string and oem_iDString
+	 * and oem_table_iDString operands
+	 */
+	status = acpi_ds_create_operands(walk_state, next_op);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/*
+	 * Resolve the signature_string and oem_iDString
+	 * and oem_table_iDString operands
+	 */
+	status = acpi_ex_resolve_operands(op->common.aml_opcode,
+					  ACPI_WALK_OPERANDS, walk_state);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	operand = &walk_state->operands[0];
+
+	/* Find the ACPI table */
+
+	status = acpi_tb_find_table(operand[0]->string.pointer,
+				    operand[1]->string.pointer,
+				    operand[2]->string.pointer, &table_index);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	acpi_ut_remove_reference(operand[0]);
+	acpi_ut_remove_reference(operand[1]);
+	acpi_ut_remove_reference(operand[2]);
+
+	status = acpi_get_table_by_index(table_index, &table);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	obj_desc = acpi_ns_get_attached_object(node);
+	if (!obj_desc) {
+		return_ACPI_STATUS(AE_NOT_EXIST);
+	}
+
+	obj_desc->region.address =
+	    (acpi_physical_address) ACPI_TO_INTEGER(table);
+	obj_desc->region.length = table->length;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_EXEC, "RgnObj %p Addr %8.8X%8.8X Len %X\n",
+			  obj_desc,
+			  ACPI_FORMAT_NATIVE_UINT(obj_desc->region.address),
+			  obj_desc->region.length));
+
+	/* Now the address and length are valid for this opregion */
+
+	obj_desc->region.flags |= AOPOBJ_DATA_VALID;
+
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_eval_data_object_operands
+ *
+ * PARAMETERS:  walk_state      - Current walk
+ *              Op              - A valid data_object Op object
+ *              obj_desc        - data_object
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Get the operands and complete the following data object types:
+ *              Buffer, Package.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ds_eval_data_object_operands(struct acpi_walk_state *walk_state,
+				  union acpi_parse_object *op,
+				  union acpi_operand_object *obj_desc)
+{
+	acpi_status status;
+	union acpi_operand_object *arg_desc;
+	u32 length;
+
+	ACPI_FUNCTION_TRACE(ds_eval_data_object_operands);
+
+	/* The first operand (for all of these data objects) is the length */
+
+	/*
+	 * Set proper index into operand stack for acpi_ds_obj_stack_push
+	 * invoked inside acpi_ds_create_operand.
+	 */
+	walk_state->operand_index = walk_state->num_operands;
+
+	status = acpi_ds_create_operand(walk_state, op->common.value.arg, 1);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	status = acpi_ex_resolve_operands(walk_state->opcode,
+					  &(walk_state->
+					    operands[walk_state->num_operands -
+						     1]), walk_state);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/* Extract length operand */
+
+	arg_desc = walk_state->operands[walk_state->num_operands - 1];
+	length = (u32)arg_desc->integer.value;
+
+	/* Cleanup for length operand */
+
+	status = acpi_ds_obj_stack_pop(1, walk_state);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	acpi_ut_remove_reference(arg_desc);
+
+	/*
+	 * Create the actual data object
+	 */
+	switch (op->common.aml_opcode) {
+	case AML_BUFFER_OP:
+
+		status =
+		    acpi_ds_build_internal_buffer_obj(walk_state, op, length,
+						      &obj_desc);
+		break;
+
+	case AML_PACKAGE_OP:
+	case AML_VAR_PACKAGE_OP:
+
+		status =
+		    acpi_ds_build_internal_package_obj(walk_state, op, length,
+						       &obj_desc);
+		break;
+
+	default:
+		return_ACPI_STATUS(AE_AML_BAD_OPCODE);
+	}
+
+	if (ACPI_SUCCESS(status)) {
+		/*
+		 * Return the object in the walk_state, unless the parent is a package -
+		 * in this case, the return object will be stored in the parse tree
+		 * for the package.
+		 */
+		if ((!op->common.parent) ||
+		    ((op->common.parent->common.aml_opcode != AML_PACKAGE_OP) &&
+		     (op->common.parent->common.aml_opcode !=
+		      AML_VAR_PACKAGE_OP)
+		     && (op->common.parent->common.aml_opcode !=
+			 AML_NAME_OP))) {
+			walk_state->result_obj = obj_desc;
+		}
+	}
+
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_eval_bank_field_operands
+ *
+ * PARAMETERS:  walk_state      - Current walk
+ *              Op              - A valid bank_field Op object
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Get bank_field bank_value
+ *              Called from acpi_ds_exec_end_op during bank_field parse tree walk
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ds_eval_bank_field_operands(struct acpi_walk_state *walk_state,
+				 union acpi_parse_object *op)
+{
+	acpi_status status;
+	union acpi_operand_object *obj_desc;
+	union acpi_operand_object *operand_desc;
+	struct acpi_namespace_node *node;
+	union acpi_parse_object *next_op;
+	union acpi_parse_object *arg;
+
+	ACPI_FUNCTION_TRACE_PTR(ds_eval_bank_field_operands, op);
+
+	/*
+	 * This is where we evaluate the bank_value field of the
+	 * bank_field declaration
+	 */
+
+	/* next_op points to the op that holds the Region */
+
+	next_op = op->common.value.arg;
+
+	/* next_op points to the op that holds the Bank Register */
+
+	next_op = next_op->common.next;
+
+	/* next_op points to the op that holds the Bank Value */
+
+	next_op = next_op->common.next;
+
+	/*
+	 * Set proper index into operand stack for acpi_ds_obj_stack_push
+	 * invoked inside acpi_ds_create_operand.
+	 *
+	 * We use walk_state->Operands[0] to store the evaluated bank_value
+	 */
+	walk_state->operand_index = 0;
+
+	status = acpi_ds_create_operand(walk_state, next_op, 0);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	status = acpi_ex_resolve_to_value(&walk_state->operands[0], walk_state);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	ACPI_DUMP_OPERANDS(ACPI_WALK_OPERANDS,
+			   acpi_ps_get_opcode_name(op->common.aml_opcode), 1);
+	/*
+	 * Get the bank_value operand and save it
+	 * (at Top of stack)
+	 */
+	operand_desc = walk_state->operands[0];
+
+	/* Arg points to the start Bank Field */
+
+	arg = acpi_ps_get_arg(op, 4);
+	while (arg) {
+
+		/* Ignore OFFSET and ACCESSAS terms here */
+
+		if (arg->common.aml_opcode == AML_INT_NAMEDFIELD_OP) {
+			node = arg->common.node;
+
+			obj_desc = acpi_ns_get_attached_object(node);
+			if (!obj_desc) {
+				return_ACPI_STATUS(AE_NOT_EXIST);
+			}
+
+			obj_desc->bank_field.value =
+			    (u32)operand_desc->integer.value;
+		}
+
+		/* Move to next field in the list */
+
+		arg = arg->common.next;
+	}
+
+	acpi_ut_remove_reference(operand_desc);
+	return_ACPI_STATUS(status);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/dsutils.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/dsutils.c
new file mode 100644
index 00000000..ff1e7555
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/dsutils.c
@@ -0,0 +1,870 @@
+/*******************************************************************************
+ *
+ * Module Name: dsutils - Dispatcher utilities
+ *
+ ******************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acparser.h"
+#include "amlcode.h"
+#include "acdispat.h"
+#include "acinterp.h"
+#include "acnamesp.h"
+#include "acdebug.h"
+
+#define _COMPONENT          ACPI_DISPATCHER
+ACPI_MODULE_NAME("dsutils")
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_clear_implicit_return
+ *
+ * PARAMETERS:  walk_state          - Current State
+ *
+ * RETURN:      None.
+ *
+ * DESCRIPTION: Clear and remove a reference on an implicit return value.  Used
+ *              to delete "stale" return values (if enabled, the return value
+ *              from every operator is saved at least momentarily, in case the
+ *              parent method exits.)
+ *
+ ******************************************************************************/
+void acpi_ds_clear_implicit_return(struct acpi_walk_state *walk_state)
+{
+	ACPI_FUNCTION_NAME(ds_clear_implicit_return);
+
+	/*
+	 * Slack must be enabled for this feature
+	 */
+	if (!acpi_gbl_enable_interpreter_slack) {
+		return;
+	}
+
+	if (walk_state->implicit_return_obj) {
+		/*
+		 * Delete any "stale" implicit return. However, in
+		 * complex statements, the implicit return value can be
+		 * bubbled up several levels.
+		 */
+		ACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,
+				  "Removing reference on stale implicit return obj %p\n",
+				  walk_state->implicit_return_obj));
+
+		acpi_ut_remove_reference(walk_state->implicit_return_obj);
+		walk_state->implicit_return_obj = NULL;
+	}
+}
+
+#ifndef ACPI_NO_METHOD_EXECUTION
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_do_implicit_return
+ *
+ * PARAMETERS:  return_desc         - The return value
+ *              walk_state          - Current State
+ *              add_reference       - True if a reference should be added to the
+ *                                    return object
+ *
+ * RETURN:      TRUE if implicit return enabled, FALSE otherwise
+ *
+ * DESCRIPTION: Implements the optional "implicit return".  We save the result
+ *              of every ASL operator and control method invocation in case the
+ *              parent method exit.  Before storing a new return value, we
+ *              delete the previous return value.
+ *
+ ******************************************************************************/
+
+u8
+acpi_ds_do_implicit_return(union acpi_operand_object *return_desc,
+			   struct acpi_walk_state *walk_state, u8 add_reference)
+{
+	ACPI_FUNCTION_NAME(ds_do_implicit_return);
+
+	/*
+	 * Slack must be enabled for this feature, and we must
+	 * have a valid return object
+	 */
+	if ((!acpi_gbl_enable_interpreter_slack) || (!return_desc)) {
+		return (FALSE);
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,
+			  "Result %p will be implicitly returned; Prev=%p\n",
+			  return_desc, walk_state->implicit_return_obj));
+
+	/*
+	 * Delete any "stale" implicit return value first. However, in
+	 * complex statements, the implicit return value can be
+	 * bubbled up several levels, so we don't clear the value if it
+	 * is the same as the return_desc.
+	 */
+	if (walk_state->implicit_return_obj) {
+		if (walk_state->implicit_return_obj == return_desc) {
+			return (TRUE);
+		}
+		acpi_ds_clear_implicit_return(walk_state);
+	}
+
+	/* Save the implicit return value, add a reference if requested */
+
+	walk_state->implicit_return_obj = return_desc;
+	if (add_reference) {
+		acpi_ut_add_reference(return_desc);
+	}
+
+	return (TRUE);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_is_result_used
+ *
+ * PARAMETERS:  Op                  - Current Op
+ *              walk_state          - Current State
+ *
+ * RETURN:      TRUE if result is used, FALSE otherwise
+ *
+ * DESCRIPTION: Check if a result object will be used by the parent
+ *
+ ******************************************************************************/
+
+u8
+acpi_ds_is_result_used(union acpi_parse_object *op,
+		       struct acpi_walk_state *walk_state)
+{
+	const struct acpi_opcode_info *parent_info;
+
+	ACPI_FUNCTION_TRACE_PTR(ds_is_result_used, op);
+
+	/* Must have both an Op and a Result Object */
+
+	if (!op) {
+		ACPI_ERROR((AE_INFO, "Null Op"));
+		return_UINT8(TRUE);
+	}
+
+	/*
+	 * We know that this operator is not a
+	 * Return() operator (would not come here.) The following code is the
+	 * optional support for a so-called "implicit return". Some AML code
+	 * assumes that the last value of the method is "implicitly" returned
+	 * to the caller. Just save the last result as the return value.
+	 * NOTE: this is optional because the ASL language does not actually
+	 * support this behavior.
+	 */
+	(void)acpi_ds_do_implicit_return(walk_state->result_obj, walk_state,
+					 TRUE);
+
+	/*
+	 * Now determine if the parent will use the result
+	 *
+	 * If there is no parent, or the parent is a scope_op, we are executing
+	 * at the method level. An executing method typically has no parent,
+	 * since each method is parsed separately.  A method invoked externally
+	 * via execute_control_method has a scope_op as the parent.
+	 */
+	if ((!op->common.parent) ||
+	    (op->common.parent->common.aml_opcode == AML_SCOPE_OP)) {
+
+		/* No parent, the return value cannot possibly be used */
+
+		ACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,
+				  "At Method level, result of [%s] not used\n",
+				  acpi_ps_get_opcode_name(op->common.
+							  aml_opcode)));
+		return_UINT8(FALSE);
+	}
+
+	/* Get info on the parent. The root_op is AML_SCOPE */
+
+	parent_info =
+	    acpi_ps_get_opcode_info(op->common.parent->common.aml_opcode);
+	if (parent_info->class == AML_CLASS_UNKNOWN) {
+		ACPI_ERROR((AE_INFO, "Unknown parent opcode Op=%p", op));
+		return_UINT8(FALSE);
+	}
+
+	/*
+	 * Decide what to do with the result based on the parent.  If
+	 * the parent opcode will not use the result, delete the object.
+	 * Otherwise leave it as is, it will be deleted when it is used
+	 * as an operand later.
+	 */
+	switch (parent_info->class) {
+	case AML_CLASS_CONTROL:
+
+		switch (op->common.parent->common.aml_opcode) {
+		case AML_RETURN_OP:
+
+			/* Never delete the return value associated with a return opcode */
+
+			goto result_used;
+
+		case AML_IF_OP:
+		case AML_WHILE_OP:
+
+			/*
+			 * If we are executing the predicate AND this is the predicate op,
+			 * we will use the return value
+			 */
+			if ((walk_state->control_state->common.state ==
+			     ACPI_CONTROL_PREDICATE_EXECUTING)
+			    && (walk_state->control_state->control.
+				predicate_op == op)) {
+				goto result_used;
+			}
+			break;
+
+		default:
+			/* Ignore other control opcodes */
+			break;
+		}
+
+		/* The general control opcode returns no result */
+
+		goto result_not_used;
+
+	case AML_CLASS_CREATE:
+
+		/*
+		 * These opcodes allow term_arg(s) as operands and therefore
+		 * the operands can be method calls.  The result is used.
+		 */
+		goto result_used;
+
+	case AML_CLASS_NAMED_OBJECT:
+
+		if ((op->common.parent->common.aml_opcode == AML_REGION_OP) ||
+		    (op->common.parent->common.aml_opcode == AML_DATA_REGION_OP)
+		    || (op->common.parent->common.aml_opcode == AML_PACKAGE_OP)
+		    || (op->common.parent->common.aml_opcode ==
+			AML_VAR_PACKAGE_OP)
+		    || (op->common.parent->common.aml_opcode == AML_BUFFER_OP)
+		    || (op->common.parent->common.aml_opcode ==
+			AML_INT_EVAL_SUBTREE_OP)
+		    || (op->common.parent->common.aml_opcode ==
+			AML_BANK_FIELD_OP)) {
+			/*
+			 * These opcodes allow term_arg(s) as operands and therefore
+			 * the operands can be method calls.  The result is used.
+			 */
+			goto result_used;
+		}
+
+		goto result_not_used;
+
+	default:
+
+		/*
+		 * In all other cases. the parent will actually use the return
+		 * object, so keep it.
+		 */
+		goto result_used;
+	}
+
+      result_used:
+	ACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,
+			  "Result of [%s] used by Parent [%s] Op=%p\n",
+			  acpi_ps_get_opcode_name(op->common.aml_opcode),
+			  acpi_ps_get_opcode_name(op->common.parent->common.
+						  aml_opcode), op));
+
+	return_UINT8(TRUE);
+
+      result_not_used:
+	ACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,
+			  "Result of [%s] not used by Parent [%s] Op=%p\n",
+			  acpi_ps_get_opcode_name(op->common.aml_opcode),
+			  acpi_ps_get_opcode_name(op->common.parent->common.
+						  aml_opcode), op));
+
+	return_UINT8(FALSE);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_delete_result_if_not_used
+ *
+ * PARAMETERS:  Op              - Current parse Op
+ *              result_obj      - Result of the operation
+ *              walk_state      - Current state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Used after interpretation of an opcode.  If there is an internal
+ *              result descriptor, check if the parent opcode will actually use
+ *              this result.  If not, delete the result now so that it will
+ *              not become orphaned.
+ *
+ ******************************************************************************/
+
+void
+acpi_ds_delete_result_if_not_used(union acpi_parse_object *op,
+				  union acpi_operand_object *result_obj,
+				  struct acpi_walk_state *walk_state)
+{
+	union acpi_operand_object *obj_desc;
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE_PTR(ds_delete_result_if_not_used, result_obj);
+
+	if (!op) {
+		ACPI_ERROR((AE_INFO, "Null Op"));
+		return_VOID;
+	}
+
+	if (!result_obj) {
+		return_VOID;
+	}
+
+	if (!acpi_ds_is_result_used(op, walk_state)) {
+
+		/* Must pop the result stack (obj_desc should be equal to result_obj) */
+
+		status = acpi_ds_result_pop(&obj_desc, walk_state);
+		if (ACPI_SUCCESS(status)) {
+			acpi_ut_remove_reference(result_obj);
+		}
+	}
+
+	return_VOID;
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_resolve_operands
+ *
+ * PARAMETERS:  walk_state          - Current walk state with operands on stack
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Resolve all operands to their values.  Used to prepare
+ *              arguments to a control method invocation (a call from one
+ *              method to another.)
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ds_resolve_operands(struct acpi_walk_state *walk_state)
+{
+	u32 i;
+	acpi_status status = AE_OK;
+
+	ACPI_FUNCTION_TRACE_PTR(ds_resolve_operands, walk_state);
+
+	/*
+	 * Attempt to resolve each of the valid operands
+	 * Method arguments are passed by reference, not by value.  This means
+	 * that the actual objects are passed, not copies of the objects.
+	 */
+	for (i = 0; i < walk_state->num_operands; i++) {
+		status =
+		    acpi_ex_resolve_to_value(&walk_state->operands[i],
+					     walk_state);
+		if (ACPI_FAILURE(status)) {
+			break;
+		}
+	}
+
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_clear_operands
+ *
+ * PARAMETERS:  walk_state          - Current walk state with operands on stack
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Clear all operands on the current walk state operand stack.
+ *
+ ******************************************************************************/
+
+void acpi_ds_clear_operands(struct acpi_walk_state *walk_state)
+{
+	u32 i;
+
+	ACPI_FUNCTION_TRACE_PTR(ds_clear_operands, walk_state);
+
+	/* Remove a reference on each operand on the stack */
+
+	for (i = 0; i < walk_state->num_operands; i++) {
+		/*
+		 * Remove a reference to all operands, including both
+		 * "Arguments" and "Targets".
+		 */
+		acpi_ut_remove_reference(walk_state->operands[i]);
+		walk_state->operands[i] = NULL;
+	}
+
+	walk_state->num_operands = 0;
+	return_VOID;
+}
+#endif
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_create_operand
+ *
+ * PARAMETERS:  walk_state      - Current walk state
+ *              Arg             - Parse object for the argument
+ *              arg_index       - Which argument (zero based)
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Translate a parse tree object that is an argument to an AML
+ *              opcode to the equivalent interpreter object.  This may include
+ *              looking up a name or entering a new name into the internal
+ *              namespace.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ds_create_operand(struct acpi_walk_state *walk_state,
+		       union acpi_parse_object *arg, u32 arg_index)
+{
+	acpi_status status = AE_OK;
+	char *name_string;
+	u32 name_length;
+	union acpi_operand_object *obj_desc;
+	union acpi_parse_object *parent_op;
+	u16 opcode;
+	acpi_interpreter_mode interpreter_mode;
+	const struct acpi_opcode_info *op_info;
+
+	ACPI_FUNCTION_TRACE_PTR(ds_create_operand, arg);
+
+	/* A valid name must be looked up in the namespace */
+
+	if ((arg->common.aml_opcode == AML_INT_NAMEPATH_OP) &&
+	    (arg->common.value.string) &&
+	    !(arg->common.flags & ACPI_PARSEOP_IN_STACK)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_DISPATCH, "Getting a name: Arg=%p\n",
+				  arg));
+
+		/* Get the entire name string from the AML stream */
+
+		status =
+		    acpi_ex_get_name_string(ACPI_TYPE_ANY,
+					    arg->common.value.buffer,
+					    &name_string, &name_length);
+
+		if (ACPI_FAILURE(status)) {
+			return_ACPI_STATUS(status);
+		}
+
+		/* All prefixes have been handled, and the name is in name_string */
+
+		/*
+		 * Special handling for buffer_field declarations. This is a deferred
+		 * opcode that unfortunately defines the field name as the last
+		 * parameter instead of the first.  We get here when we are performing
+		 * the deferred execution, so the actual name of the field is already
+		 * in the namespace.  We don't want to attempt to look it up again
+		 * because we may be executing in a different scope than where the
+		 * actual opcode exists.
+		 */
+		if ((walk_state->deferred_node) &&
+		    (walk_state->deferred_node->type == ACPI_TYPE_BUFFER_FIELD)
+		    && (arg_index ==
+			(u32)((walk_state->opcode ==
+			       AML_CREATE_FIELD_OP) ? 3 : 2))) {
+			obj_desc =
+			    ACPI_CAST_PTR(union acpi_operand_object,
+					  walk_state->deferred_node);
+			status = AE_OK;
+		} else {	/* All other opcodes */
+
+			/*
+			 * Differentiate between a namespace "create" operation
+			 * versus a "lookup" operation (IMODE_LOAD_PASS2 vs.
+			 * IMODE_EXECUTE) in order to support the creation of
+			 * namespace objects during the execution of control methods.
+			 */
+			parent_op = arg->common.parent;
+			op_info =
+			    acpi_ps_get_opcode_info(parent_op->common.
+						    aml_opcode);
+			if ((op_info->flags & AML_NSNODE)
+			    && (parent_op->common.aml_opcode !=
+				AML_INT_METHODCALL_OP)
+			    && (parent_op->common.aml_opcode != AML_REGION_OP)
+			    && (parent_op->common.aml_opcode !=
+				AML_INT_NAMEPATH_OP)) {
+
+				/* Enter name into namespace if not found */
+
+				interpreter_mode = ACPI_IMODE_LOAD_PASS2;
+			} else {
+				/* Return a failure if name not found */
+
+				interpreter_mode = ACPI_IMODE_EXECUTE;
+			}
+
+			status =
+			    acpi_ns_lookup(walk_state->scope_info, name_string,
+					   ACPI_TYPE_ANY, interpreter_mode,
+					   ACPI_NS_SEARCH_PARENT |
+					   ACPI_NS_DONT_OPEN_SCOPE, walk_state,
+					   ACPI_CAST_INDIRECT_PTR(struct
+								  acpi_namespace_node,
+								  &obj_desc));
+			/*
+			 * The only case where we pass through (ignore) a NOT_FOUND
+			 * error is for the cond_ref_of opcode.
+			 */
+			if (status == AE_NOT_FOUND) {
+				if (parent_op->common.aml_opcode ==
+				    AML_COND_REF_OF_OP) {
+					/*
+					 * For the Conditional Reference op, it's OK if
+					 * the name is not found;  We just need a way to
+					 * indicate this to the interpreter, set the
+					 * object to the root
+					 */
+					obj_desc =
+					    ACPI_CAST_PTR(union
+							  acpi_operand_object,
+							  acpi_gbl_root_node);
+					status = AE_OK;
+				} else {
+					/*
+					 * We just plain didn't find it -- which is a
+					 * very serious error at this point
+					 */
+					status = AE_AML_NAME_NOT_FOUND;
+				}
+			}
+
+			if (ACPI_FAILURE(status)) {
+				ACPI_ERROR_NAMESPACE(name_string, status);
+			}
+		}
+
+		/* Free the namestring created above */
+
+		ACPI_FREE(name_string);
+
+		/* Check status from the lookup */
+
+		if (ACPI_FAILURE(status)) {
+			return_ACPI_STATUS(status);
+		}
+
+		/* Put the resulting object onto the current object stack */
+
+		status = acpi_ds_obj_stack_push(obj_desc, walk_state);
+		if (ACPI_FAILURE(status)) {
+			return_ACPI_STATUS(status);
+		}
+		ACPI_DEBUGGER_EXEC(acpi_db_display_argument_object
+				   (obj_desc, walk_state));
+	} else {
+		/* Check for null name case */
+
+		if ((arg->common.aml_opcode == AML_INT_NAMEPATH_OP) &&
+		    !(arg->common.flags & ACPI_PARSEOP_IN_STACK)) {
+			/*
+			 * If the name is null, this means that this is an
+			 * optional result parameter that was not specified
+			 * in the original ASL.  Create a Zero Constant for a
+			 * placeholder.  (Store to a constant is a Noop.)
+			 */
+			opcode = AML_ZERO_OP;	/* Has no arguments! */
+
+			ACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,
+					  "Null namepath: Arg=%p\n", arg));
+		} else {
+			opcode = arg->common.aml_opcode;
+		}
+
+		/* Get the object type of the argument */
+
+		op_info = acpi_ps_get_opcode_info(opcode);
+		if (op_info->object_type == ACPI_TYPE_INVALID) {
+			return_ACPI_STATUS(AE_NOT_IMPLEMENTED);
+		}
+
+		if ((op_info->flags & AML_HAS_RETVAL)
+		    || (arg->common.flags & ACPI_PARSEOP_IN_STACK)) {
+			ACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,
+					  "Argument previously created, already stacked\n"));
+
+			ACPI_DEBUGGER_EXEC(acpi_db_display_argument_object
+					   (walk_state->
+					    operands[walk_state->num_operands -
+						     1], walk_state));
+
+			/*
+			 * Use value that was already previously returned
+			 * by the evaluation of this argument
+			 */
+			status = acpi_ds_result_pop(&obj_desc, walk_state);
+			if (ACPI_FAILURE(status)) {
+				/*
+				 * Only error is underflow, and this indicates
+				 * a missing or null operand!
+				 */
+				ACPI_EXCEPTION((AE_INFO, status,
+						"Missing or null operand"));
+				return_ACPI_STATUS(status);
+			}
+		} else {
+			/* Create an ACPI_INTERNAL_OBJECT for the argument */
+
+			obj_desc =
+			    acpi_ut_create_internal_object(op_info->
+							   object_type);
+			if (!obj_desc) {
+				return_ACPI_STATUS(AE_NO_MEMORY);
+			}
+
+			/* Initialize the new object */
+
+			status =
+			    acpi_ds_init_object_from_op(walk_state, arg, opcode,
+							&obj_desc);
+			if (ACPI_FAILURE(status)) {
+				acpi_ut_delete_object_desc(obj_desc);
+				return_ACPI_STATUS(status);
+			}
+		}
+
+		/* Put the operand object on the object stack */
+
+		status = acpi_ds_obj_stack_push(obj_desc, walk_state);
+		if (ACPI_FAILURE(status)) {
+			return_ACPI_STATUS(status);
+		}
+
+		ACPI_DEBUGGER_EXEC(acpi_db_display_argument_object
+				   (obj_desc, walk_state));
+	}
+
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_create_operands
+ *
+ * PARAMETERS:  walk_state          - Current state
+ *              first_arg           - First argument of a parser argument tree
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Convert an operator's arguments from a parse tree format to
+ *              namespace objects and place those argument object on the object
+ *              stack in preparation for evaluation by the interpreter.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ds_create_operands(struct acpi_walk_state *walk_state,
+			union acpi_parse_object *first_arg)
+{
+	acpi_status status = AE_OK;
+	union acpi_parse_object *arg;
+	union acpi_parse_object *arguments[ACPI_OBJ_NUM_OPERANDS];
+	u32 arg_count = 0;
+	u32 index = walk_state->num_operands;
+	u32 i;
+
+	ACPI_FUNCTION_TRACE_PTR(ds_create_operands, first_arg);
+
+	/* Get all arguments in the list */
+
+	arg = first_arg;
+	while (arg) {
+		if (index >= ACPI_OBJ_NUM_OPERANDS) {
+			return_ACPI_STATUS(AE_BAD_DATA);
+		}
+
+		arguments[index] = arg;
+		walk_state->operands[index] = NULL;
+
+		/* Move on to next argument, if any */
+
+		arg = arg->common.next;
+		arg_count++;
+		index++;
+	}
+
+	index--;
+
+	/* It is the appropriate order to get objects from the Result stack */
+
+	for (i = 0; i < arg_count; i++) {
+		arg = arguments[index];
+
+		/* Force the filling of the operand stack in inverse order */
+
+		walk_state->operand_index = (u8)index;
+
+		status = acpi_ds_create_operand(walk_state, arg, index);
+		if (ACPI_FAILURE(status)) {
+			goto cleanup;
+		}
+
+		index--;
+
+		ACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,
+				  "Arg #%u (%p) done, Arg1=%p\n", index, arg,
+				  first_arg));
+	}
+
+	return_ACPI_STATUS(status);
+
+      cleanup:
+	/*
+	 * We must undo everything done above; meaning that we must
+	 * pop everything off of the operand stack and delete those
+	 * objects
+	 */
+	acpi_ds_obj_stack_pop_and_delete(arg_count, walk_state);
+
+	ACPI_EXCEPTION((AE_INFO, status, "While creating Arg %u", index));
+	return_ACPI_STATUS(status);
+}
+
+/*****************************************************************************
+ *
+ * FUNCTION:    acpi_ds_evaluate_name_path
+ *
+ * PARAMETERS:  walk_state      - Current state of the parse tree walk,
+ *                                the opcode of current operation should be
+ *                                AML_INT_NAMEPATH_OP
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Translate the -name_path- parse tree object to the equivalent
+ *              interpreter object, convert it to value, if needed, duplicate
+ *              it, if needed, and push it onto the current result stack.
+ *
+ ****************************************************************************/
+
+acpi_status acpi_ds_evaluate_name_path(struct acpi_walk_state *walk_state)
+{
+	acpi_status status = AE_OK;
+	union acpi_parse_object *op = walk_state->op;
+	union acpi_operand_object **operand = &walk_state->operands[0];
+	union acpi_operand_object *new_obj_desc;
+	u8 type;
+
+	ACPI_FUNCTION_TRACE_PTR(ds_evaluate_name_path, walk_state);
+
+	if (!op->common.parent) {
+
+		/* This happens after certain exception processing */
+
+		goto exit;
+	}
+
+	if ((op->common.parent->common.aml_opcode == AML_PACKAGE_OP) ||
+	    (op->common.parent->common.aml_opcode == AML_VAR_PACKAGE_OP) ||
+	    (op->common.parent->common.aml_opcode == AML_REF_OF_OP)) {
+
+		/* TBD: Should we specify this feature as a bit of op_info->Flags of these opcodes? */
+
+		goto exit;
+	}
+
+	status = acpi_ds_create_operand(walk_state, op, 0);
+	if (ACPI_FAILURE(status)) {
+		goto exit;
+	}
+
+	if (op->common.flags & ACPI_PARSEOP_TARGET) {
+		new_obj_desc = *operand;
+		goto push_result;
+	}
+
+	type = (*operand)->common.type;
+
+	status = acpi_ex_resolve_to_value(operand, walk_state);
+	if (ACPI_FAILURE(status)) {
+		goto exit;
+	}
+
+	if (type == ACPI_TYPE_INTEGER) {
+
+		/* It was incremented by acpi_ex_resolve_to_value */
+
+		acpi_ut_remove_reference(*operand);
+
+		status =
+		    acpi_ut_copy_iobject_to_iobject(*operand, &new_obj_desc,
+						    walk_state);
+		if (ACPI_FAILURE(status)) {
+			goto exit;
+		}
+	} else {
+		/*
+		 * The object either was anew created or is
+		 * a Namespace node - don't decrement it.
+		 */
+		new_obj_desc = *operand;
+	}
+
+	/* Cleanup for name-path operand */
+
+	status = acpi_ds_obj_stack_pop(1, walk_state);
+	if (ACPI_FAILURE(status)) {
+		walk_state->result_obj = new_obj_desc;
+		goto exit;
+	}
+
+      push_result:
+
+	walk_state->result_obj = new_obj_desc;
+
+	status = acpi_ds_result_push(walk_state->result_obj, walk_state);
+	if (ACPI_SUCCESS(status)) {
+
+		/* Force to take it from stack */
+
+		op->common.flags |= ACPI_PARSEOP_IN_STACK;
+	}
+
+      exit:
+
+	return_ACPI_STATUS(status);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/dswexec.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/dswexec.c
new file mode 100644
index 00000000..fa44609a
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/dswexec.c
@@ -0,0 +1,760 @@
+/******************************************************************************
+ *
+ * Module Name: dswexec - Dispatcher method execution callbacks;
+ *                        dispatch to interpreter.
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acparser.h"
+#include "amlcode.h"
+#include "acdispat.h"
+#include "acinterp.h"
+#include "acnamesp.h"
+#include "acdebug.h"
+
+#define _COMPONENT          ACPI_DISPATCHER
+ACPI_MODULE_NAME("dswexec")
+
+/*
+ * Dispatch table for opcode classes
+ */
+static acpi_execute_op acpi_gbl_op_type_dispatch[] = {
+	acpi_ex_opcode_0A_0T_1R,
+	acpi_ex_opcode_1A_0T_0R,
+	acpi_ex_opcode_1A_0T_1R,
+	acpi_ex_opcode_1A_1T_0R,
+	acpi_ex_opcode_1A_1T_1R,
+	acpi_ex_opcode_2A_0T_0R,
+	acpi_ex_opcode_2A_0T_1R,
+	acpi_ex_opcode_2A_1T_1R,
+	acpi_ex_opcode_2A_2T_1R,
+	acpi_ex_opcode_3A_0T_0R,
+	acpi_ex_opcode_3A_1T_1R,
+	acpi_ex_opcode_6A_0T_1R
+};
+
+/*****************************************************************************
+ *
+ * FUNCTION:    acpi_ds_get_predicate_value
+ *
+ * PARAMETERS:  walk_state      - Current state of the parse tree walk
+ *              result_obj      - if non-zero, pop result from result stack
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Get the result of a predicate evaluation
+ *
+ ****************************************************************************/
+
+acpi_status
+acpi_ds_get_predicate_value(struct acpi_walk_state *walk_state,
+			    union acpi_operand_object *result_obj)
+{
+	acpi_status status = AE_OK;
+	union acpi_operand_object *obj_desc;
+	union acpi_operand_object *local_obj_desc = NULL;
+
+	ACPI_FUNCTION_TRACE_PTR(ds_get_predicate_value, walk_state);
+
+	walk_state->control_state->common.state = 0;
+
+	if (result_obj) {
+		status = acpi_ds_result_pop(&obj_desc, walk_state);
+		if (ACPI_FAILURE(status)) {
+			ACPI_EXCEPTION((AE_INFO, status,
+					"Could not get result from predicate evaluation"));
+
+			return_ACPI_STATUS(status);
+		}
+	} else {
+		status = acpi_ds_create_operand(walk_state, walk_state->op, 0);
+		if (ACPI_FAILURE(status)) {
+			return_ACPI_STATUS(status);
+		}
+
+		status =
+		    acpi_ex_resolve_to_value(&walk_state->operands[0],
+					     walk_state);
+		if (ACPI_FAILURE(status)) {
+			return_ACPI_STATUS(status);
+		}
+
+		obj_desc = walk_state->operands[0];
+	}
+
+	if (!obj_desc) {
+		ACPI_ERROR((AE_INFO,
+			    "No predicate ObjDesc=%p State=%p",
+			    obj_desc, walk_state));
+
+		return_ACPI_STATUS(AE_AML_NO_OPERAND);
+	}
+
+	/*
+	 * Result of predicate evaluation must be an Integer
+	 * object. Implicitly convert the argument if necessary.
+	 */
+	status = acpi_ex_convert_to_integer(obj_desc, &local_obj_desc, 16);
+	if (ACPI_FAILURE(status)) {
+		goto cleanup;
+	}
+
+	if (local_obj_desc->common.type != ACPI_TYPE_INTEGER) {
+		ACPI_ERROR((AE_INFO,
+			    "Bad predicate (not an integer) ObjDesc=%p State=%p Type=0x%X",
+			    obj_desc, walk_state, obj_desc->common.type));
+
+		status = AE_AML_OPERAND_TYPE;
+		goto cleanup;
+	}
+
+	/* Truncate the predicate to 32-bits if necessary */
+
+	acpi_ex_truncate_for32bit_table(local_obj_desc);
+
+	/*
+	 * Save the result of the predicate evaluation on
+	 * the control stack
+	 */
+	if (local_obj_desc->integer.value) {
+		walk_state->control_state->common.value = TRUE;
+	} else {
+		/*
+		 * Predicate is FALSE, we will just toss the
+		 * rest of the package
+		 */
+		walk_state->control_state->common.value = FALSE;
+		status = AE_CTRL_FALSE;
+	}
+
+	/* Predicate can be used for an implicit return value */
+
+	(void)acpi_ds_do_implicit_return(local_obj_desc, walk_state, TRUE);
+
+      cleanup:
+
+	ACPI_DEBUG_PRINT((ACPI_DB_EXEC, "Completed a predicate eval=%X Op=%p\n",
+			  walk_state->control_state->common.value,
+			  walk_state->op));
+
+	/* Break to debugger to display result */
+
+	ACPI_DEBUGGER_EXEC(acpi_db_display_result_object
+			   (local_obj_desc, walk_state));
+
+	/*
+	 * Delete the predicate result object (we know that
+	 * we don't need it anymore)
+	 */
+	if (local_obj_desc != obj_desc) {
+		acpi_ut_remove_reference(local_obj_desc);
+	}
+	acpi_ut_remove_reference(obj_desc);
+
+	walk_state->control_state->common.state = ACPI_CONTROL_NORMAL;
+	return_ACPI_STATUS(status);
+}
+
+/*****************************************************************************
+ *
+ * FUNCTION:    acpi_ds_exec_begin_op
+ *
+ * PARAMETERS:  walk_state      - Current state of the parse tree walk
+ *              out_op          - Where to return op if a new one is created
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Descending callback used during the execution of control
+ *              methods.  This is where most operators and operands are
+ *              dispatched to the interpreter.
+ *
+ ****************************************************************************/
+
+acpi_status
+acpi_ds_exec_begin_op(struct acpi_walk_state *walk_state,
+		      union acpi_parse_object **out_op)
+{
+	union acpi_parse_object *op;
+	acpi_status status = AE_OK;
+	u32 opcode_class;
+
+	ACPI_FUNCTION_TRACE_PTR(ds_exec_begin_op, walk_state);
+
+	op = walk_state->op;
+	if (!op) {
+		status = acpi_ds_load2_begin_op(walk_state, out_op);
+		if (ACPI_FAILURE(status)) {
+			goto error_exit;
+		}
+
+		op = *out_op;
+		walk_state->op = op;
+		walk_state->opcode = op->common.aml_opcode;
+		walk_state->op_info =
+		    acpi_ps_get_opcode_info(op->common.aml_opcode);
+
+		if (acpi_ns_opens_scope(walk_state->op_info->object_type)) {
+			ACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,
+					  "(%s) Popping scope for Op %p\n",
+					  acpi_ut_get_type_name(walk_state->
+								op_info->
+								object_type),
+					  op));
+
+			status = acpi_ds_scope_stack_pop(walk_state);
+			if (ACPI_FAILURE(status)) {
+				goto error_exit;
+			}
+		}
+	}
+
+	if (op == walk_state->origin) {
+		if (out_op) {
+			*out_op = op;
+		}
+
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	/*
+	 * If the previous opcode was a conditional, this opcode
+	 * must be the beginning of the associated predicate.
+	 * Save this knowledge in the current scope descriptor
+	 */
+	if ((walk_state->control_state) &&
+	    (walk_state->control_state->common.state ==
+	     ACPI_CONTROL_CONDITIONAL_EXECUTING)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
+				  "Exec predicate Op=%p State=%p\n", op,
+				  walk_state));
+
+		walk_state->control_state->common.state =
+		    ACPI_CONTROL_PREDICATE_EXECUTING;
+
+		/* Save start of predicate */
+
+		walk_state->control_state->control.predicate_op = op;
+	}
+
+	opcode_class = walk_state->op_info->class;
+
+	/* We want to send namepaths to the load code */
+
+	if (op->common.aml_opcode == AML_INT_NAMEPATH_OP) {
+		opcode_class = AML_CLASS_NAMED_OBJECT;
+	}
+
+	/*
+	 * Handle the opcode based upon the opcode type
+	 */
+	switch (opcode_class) {
+	case AML_CLASS_CONTROL:
+
+		status = acpi_ds_exec_begin_control_op(walk_state, op);
+		break;
+
+	case AML_CLASS_NAMED_OBJECT:
+
+		if (walk_state->walk_type & ACPI_WALK_METHOD) {
+			/*
+			 * Found a named object declaration during method execution;
+			 * we must enter this object into the namespace.  The created
+			 * object is temporary and will be deleted upon completion of
+			 * the execution of this method.
+			 *
+			 * Note 10/2010: Except for the Scope() op. This opcode does
+			 * not actually create a new object, it refers to an existing
+			 * object. However, for Scope(), we want to indeed open a
+			 * new scope.
+			 */
+			if (op->common.aml_opcode != AML_SCOPE_OP) {
+				status =
+				    acpi_ds_load2_begin_op(walk_state, NULL);
+			} else {
+				status =
+				    acpi_ds_scope_stack_push(op->named.node,
+							     op->named.node->
+							     type, walk_state);
+				if (ACPI_FAILURE(status)) {
+					return_ACPI_STATUS(status);
+				}
+			}
+		}
+		break;
+
+	case AML_CLASS_EXECUTE:
+	case AML_CLASS_CREATE:
+
+		break;
+
+	default:
+		break;
+	}
+
+	/* Nothing to do here during method execution */
+
+	return_ACPI_STATUS(status);
+
+      error_exit:
+	status = acpi_ds_method_error(status, walk_state);
+	return_ACPI_STATUS(status);
+}
+
+/*****************************************************************************
+ *
+ * FUNCTION:    acpi_ds_exec_end_op
+ *
+ * PARAMETERS:  walk_state      - Current state of the parse tree walk
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Ascending callback used during the execution of control
+ *              methods.  The only thing we really need to do here is to
+ *              notice the beginning of IF, ELSE, and WHILE blocks.
+ *
+ ****************************************************************************/
+
+acpi_status acpi_ds_exec_end_op(struct acpi_walk_state *walk_state)
+{
+	union acpi_parse_object *op;
+	acpi_status status = AE_OK;
+	u32 op_type;
+	u32 op_class;
+	union acpi_parse_object *next_op;
+	union acpi_parse_object *first_arg;
+
+	ACPI_FUNCTION_TRACE_PTR(ds_exec_end_op, walk_state);
+
+	op = walk_state->op;
+	op_type = walk_state->op_info->type;
+	op_class = walk_state->op_info->class;
+
+	if (op_class == AML_CLASS_UNKNOWN) {
+		ACPI_ERROR((AE_INFO, "Unknown opcode 0x%X",
+			    op->common.aml_opcode));
+		return_ACPI_STATUS(AE_NOT_IMPLEMENTED);
+	}
+
+	first_arg = op->common.value.arg;
+
+	/* Init the walk state */
+
+	walk_state->num_operands = 0;
+	walk_state->operand_index = 0;
+	walk_state->return_desc = NULL;
+	walk_state->result_obj = NULL;
+
+	/* Call debugger for single step support (DEBUG build only) */
+
+	ACPI_DEBUGGER_EXEC(status =
+			   acpi_db_single_step(walk_state, op, op_class));
+	ACPI_DEBUGGER_EXEC(if (ACPI_FAILURE(status)) {
+			   return_ACPI_STATUS(status);}
+	) ;
+
+	/* Decode the Opcode Class */
+
+	switch (op_class) {
+	case AML_CLASS_ARGUMENT:	/* Constants, literals, etc. */
+
+		if (walk_state->opcode == AML_INT_NAMEPATH_OP) {
+			status = acpi_ds_evaluate_name_path(walk_state);
+			if (ACPI_FAILURE(status)) {
+				goto cleanup;
+			}
+		}
+		break;
+
+	case AML_CLASS_EXECUTE:	/* Most operators with arguments */
+
+		/* Build resolved operand stack */
+
+		status = acpi_ds_create_operands(walk_state, first_arg);
+		if (ACPI_FAILURE(status)) {
+			goto cleanup;
+		}
+
+		/*
+		 * All opcodes require operand resolution, with the only exceptions
+		 * being the object_type and size_of operators.
+		 */
+		if (!(walk_state->op_info->flags & AML_NO_OPERAND_RESOLVE)) {
+
+			/* Resolve all operands */
+
+			status = acpi_ex_resolve_operands(walk_state->opcode,
+							  &(walk_state->
+							    operands
+							    [walk_state->
+							     num_operands - 1]),
+							  walk_state);
+		}
+
+		if (ACPI_SUCCESS(status)) {
+			/*
+			 * Dispatch the request to the appropriate interpreter handler
+			 * routine.  There is one routine per opcode "type" based upon the
+			 * number of opcode arguments and return type.
+			 */
+			status =
+			    acpi_gbl_op_type_dispatch[op_type] (walk_state);
+		} else {
+			/*
+			 * Treat constructs of the form "Store(LocalX,LocalX)" as noops when the
+			 * Local is uninitialized.
+			 */
+			if ((status == AE_AML_UNINITIALIZED_LOCAL) &&
+			    (walk_state->opcode == AML_STORE_OP) &&
+			    (walk_state->operands[0]->common.type ==
+			     ACPI_TYPE_LOCAL_REFERENCE)
+			    && (walk_state->operands[1]->common.type ==
+				ACPI_TYPE_LOCAL_REFERENCE)
+			    && (walk_state->operands[0]->reference.class ==
+				walk_state->operands[1]->reference.class)
+			    && (walk_state->operands[0]->reference.value ==
+				walk_state->operands[1]->reference.value)) {
+				status = AE_OK;
+			} else {
+				ACPI_EXCEPTION((AE_INFO, status,
+						"While resolving operands for [%s]",
+						acpi_ps_get_opcode_name
+						(walk_state->opcode)));
+			}
+		}
+
+		/* Always delete the argument objects and clear the operand stack */
+
+		acpi_ds_clear_operands(walk_state);
+
+		/*
+		 * If a result object was returned from above, push it on the
+		 * current result stack
+		 */
+		if (ACPI_SUCCESS(status) && walk_state->result_obj) {
+			status =
+			    acpi_ds_result_push(walk_state->result_obj,
+						walk_state);
+		}
+		break;
+
+	default:
+
+		switch (op_type) {
+		case AML_TYPE_CONTROL:	/* Type 1 opcode, IF/ELSE/WHILE/NOOP */
+
+			/* 1 Operand, 0 external_result, 0 internal_result */
+
+			status = acpi_ds_exec_end_control_op(walk_state, op);
+
+			break;
+
+		case AML_TYPE_METHOD_CALL:
+
+			/*
+			 * If the method is referenced from within a package
+			 * declaration, it is not a invocation of the method, just
+			 * a reference to it.
+			 */
+			if ((op->asl.parent) &&
+			    ((op->asl.parent->asl.aml_opcode == AML_PACKAGE_OP)
+			     || (op->asl.parent->asl.aml_opcode ==
+				 AML_VAR_PACKAGE_OP))) {
+				ACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,
+						  "Method Reference in a Package, Op=%p\n",
+						  op));
+
+				op->common.node =
+				    (struct acpi_namespace_node *)op->asl.value.
+				    arg->asl.node;
+				acpi_ut_add_reference(op->asl.value.arg->asl.
+						      node->object);
+				return_ACPI_STATUS(AE_OK);
+			}
+
+			ACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,
+					  "Method invocation, Op=%p\n", op));
+
+			/*
+			 * (AML_METHODCALL) Op->Asl.Value.Arg->Asl.Node contains
+			 * the method Node pointer
+			 */
+			/* next_op points to the op that holds the method name */
+
+			next_op = first_arg;
+
+			/* next_op points to first argument op */
+
+			next_op = next_op->common.next;
+
+			/*
+			 * Get the method's arguments and put them on the operand stack
+			 */
+			status = acpi_ds_create_operands(walk_state, next_op);
+			if (ACPI_FAILURE(status)) {
+				break;
+			}
+
+			/*
+			 * Since the operands will be passed to another control method,
+			 * we must resolve all local references here (Local variables,
+			 * arguments to *this* method, etc.)
+			 */
+			status = acpi_ds_resolve_operands(walk_state);
+			if (ACPI_FAILURE(status)) {
+
+				/* On error, clear all resolved operands */
+
+				acpi_ds_clear_operands(walk_state);
+				break;
+			}
+
+			/*
+			 * Tell the walk loop to preempt this running method and
+			 * execute the new method
+			 */
+			status = AE_CTRL_TRANSFER;
+
+			/*
+			 * Return now; we don't want to disturb anything,
+			 * especially the operand count!
+			 */
+			return_ACPI_STATUS(status);
+
+		case AML_TYPE_CREATE_FIELD:
+
+			ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
+					  "Executing CreateField Buffer/Index Op=%p\n",
+					  op));
+
+			status = acpi_ds_load2_end_op(walk_state);
+			if (ACPI_FAILURE(status)) {
+				break;
+			}
+
+			status =
+			    acpi_ds_eval_buffer_field_operands(walk_state, op);
+			break;
+
+		case AML_TYPE_CREATE_OBJECT:
+
+			ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
+					  "Executing CreateObject (Buffer/Package) Op=%p\n",
+					  op));
+
+			switch (op->common.parent->common.aml_opcode) {
+			case AML_NAME_OP:
+
+				/*
+				 * Put the Node on the object stack (Contains the ACPI Name
+				 * of this object)
+				 */
+				walk_state->operands[0] =
+				    (void *)op->common.parent->common.node;
+				walk_state->num_operands = 1;
+
+				status = acpi_ds_create_node(walk_state,
+							     op->common.parent->
+							     common.node,
+							     op->common.parent);
+				if (ACPI_FAILURE(status)) {
+					break;
+				}
+
+				/* Fall through */
+				/*lint -fallthrough */
+
+			case AML_INT_EVAL_SUBTREE_OP:
+
+				status =
+				    acpi_ds_eval_data_object_operands
+				    (walk_state, op,
+				     acpi_ns_get_attached_object(op->common.
+								 parent->common.
+								 node));
+				break;
+
+			default:
+
+				status =
+				    acpi_ds_eval_data_object_operands
+				    (walk_state, op, NULL);
+				break;
+			}
+
+			/*
+			 * If a result object was returned from above, push it on the
+			 * current result stack
+			 */
+			if (walk_state->result_obj) {
+				status =
+				    acpi_ds_result_push(walk_state->result_obj,
+							walk_state);
+			}
+			break;
+
+		case AML_TYPE_NAMED_FIELD:
+		case AML_TYPE_NAMED_COMPLEX:
+		case AML_TYPE_NAMED_SIMPLE:
+		case AML_TYPE_NAMED_NO_OBJ:
+
+			status = acpi_ds_load2_end_op(walk_state);
+			if (ACPI_FAILURE(status)) {
+				break;
+			}
+
+			if (op->common.aml_opcode == AML_REGION_OP) {
+				ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
+						  "Executing OpRegion Address/Length Op=%p\n",
+						  op));
+
+				status =
+				    acpi_ds_eval_region_operands(walk_state,
+								 op);
+				if (ACPI_FAILURE(status)) {
+					break;
+				}
+			} else if (op->common.aml_opcode == AML_DATA_REGION_OP) {
+				ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
+						  "Executing DataTableRegion Strings Op=%p\n",
+						  op));
+
+				status =
+				    acpi_ds_eval_table_region_operands
+				    (walk_state, op);
+				if (ACPI_FAILURE(status)) {
+					break;
+				}
+			} else if (op->common.aml_opcode == AML_BANK_FIELD_OP) {
+				ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
+						  "Executing BankField Op=%p\n",
+						  op));
+
+				status =
+				    acpi_ds_eval_bank_field_operands(walk_state,
+								     op);
+				if (ACPI_FAILURE(status)) {
+					break;
+				}
+			}
+			break;
+
+		case AML_TYPE_UNDEFINED:
+
+			ACPI_ERROR((AE_INFO,
+				    "Undefined opcode type Op=%p", op));
+			return_ACPI_STATUS(AE_NOT_IMPLEMENTED);
+
+		case AML_TYPE_BOGUS:
+
+			ACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,
+					  "Internal opcode=%X type Op=%p\n",
+					  walk_state->opcode, op));
+			break;
+
+		default:
+
+			ACPI_ERROR((AE_INFO,
+				    "Unimplemented opcode, class=0x%X type=0x%X Opcode=-0x%X Op=%p",
+				    op_class, op_type, op->common.aml_opcode,
+				    op));
+
+			status = AE_NOT_IMPLEMENTED;
+			break;
+		}
+	}
+
+	/*
+	 * ACPI 2.0 support for 64-bit integers: Truncate numeric
+	 * result value if we are executing from a 32-bit ACPI table
+	 */
+	acpi_ex_truncate_for32bit_table(walk_state->result_obj);
+
+	/*
+	 * Check if we just completed the evaluation of a
+	 * conditional predicate
+	 */
+	if ((ACPI_SUCCESS(status)) &&
+	    (walk_state->control_state) &&
+	    (walk_state->control_state->common.state ==
+	     ACPI_CONTROL_PREDICATE_EXECUTING) &&
+	    (walk_state->control_state->control.predicate_op == op)) {
+		status =
+		    acpi_ds_get_predicate_value(walk_state,
+						walk_state->result_obj);
+		walk_state->result_obj = NULL;
+	}
+
+      cleanup:
+
+	if (walk_state->result_obj) {
+
+		/* Break to debugger to display result */
+
+		ACPI_DEBUGGER_EXEC(acpi_db_display_result_object
+				   (walk_state->result_obj, walk_state));
+
+		/*
+		 * Delete the result op if and only if:
+		 * Parent will not use the result -- such as any
+		 * non-nested type2 op in a method (parent will be method)
+		 */
+		acpi_ds_delete_result_if_not_used(op, walk_state->result_obj,
+						  walk_state);
+	}
+#ifdef _UNDER_DEVELOPMENT
+
+	if (walk_state->parser_state.aml == walk_state->parser_state.aml_end) {
+		acpi_db_method_end(walk_state);
+	}
+#endif
+
+	/* Invoke exception handler on error */
+
+	if (ACPI_FAILURE(status)) {
+		status = acpi_ds_method_error(status, walk_state);
+	}
+
+	/* Always clear the object stack */
+
+	walk_state->num_operands = 0;
+	return_ACPI_STATUS(status);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/dswload.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/dswload.c
new file mode 100644
index 00000000..be3bda5a
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/dswload.c
@@ -0,0 +1,539 @@
+/******************************************************************************
+ *
+ * Module Name: dswload - Dispatcher first pass namespace load callbacks
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acparser.h"
+#include "amlcode.h"
+#include "acdispat.h"
+#include "acinterp.h"
+#include "acnamesp.h"
+
+#ifdef ACPI_ASL_COMPILER
+#include "acdisasm.h"
+#endif
+
+#define _COMPONENT          ACPI_DISPATCHER
+ACPI_MODULE_NAME("dswload")
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_init_callbacks
+ *
+ * PARAMETERS:  walk_state      - Current state of the parse tree walk
+ *              pass_number     - 1, 2, or 3
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Init walk state callbacks
+ *
+ ******************************************************************************/
+acpi_status
+acpi_ds_init_callbacks(struct acpi_walk_state *walk_state, u32 pass_number)
+{
+
+	switch (pass_number) {
+	case 1:
+		walk_state->parse_flags = ACPI_PARSE_LOAD_PASS1 |
+		    ACPI_PARSE_DELETE_TREE;
+		walk_state->descending_callback = acpi_ds_load1_begin_op;
+		walk_state->ascending_callback = acpi_ds_load1_end_op;
+		break;
+
+	case 2:
+		walk_state->parse_flags = ACPI_PARSE_LOAD_PASS1 |
+		    ACPI_PARSE_DELETE_TREE;
+		walk_state->descending_callback = acpi_ds_load2_begin_op;
+		walk_state->ascending_callback = acpi_ds_load2_end_op;
+		break;
+
+	case 3:
+#ifndef ACPI_NO_METHOD_EXECUTION
+		walk_state->parse_flags |= ACPI_PARSE_EXECUTE |
+		    ACPI_PARSE_DELETE_TREE;
+		walk_state->descending_callback = acpi_ds_exec_begin_op;
+		walk_state->ascending_callback = acpi_ds_exec_end_op;
+#endif
+		break;
+
+	default:
+		return (AE_BAD_PARAMETER);
+	}
+
+	return (AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_load1_begin_op
+ *
+ * PARAMETERS:  walk_state      - Current state of the parse tree walk
+ *              out_op          - Where to return op if a new one is created
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Descending callback used during the loading of ACPI tables.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ds_load1_begin_op(struct acpi_walk_state * walk_state,
+		       union acpi_parse_object ** out_op)
+{
+	union acpi_parse_object *op;
+	struct acpi_namespace_node *node;
+	acpi_status status;
+	acpi_object_type object_type;
+	char *path;
+	u32 flags;
+
+	ACPI_FUNCTION_TRACE(ds_load1_begin_op);
+
+	op = walk_state->op;
+	ACPI_DEBUG_PRINT((ACPI_DB_DISPATCH, "Op=%p State=%p\n", op,
+			  walk_state));
+
+	/* We are only interested in opcodes that have an associated name */
+
+	if (op) {
+		if (!(walk_state->op_info->flags & AML_NAMED)) {
+			*out_op = op;
+			return_ACPI_STATUS(AE_OK);
+		}
+
+		/* Check if this object has already been installed in the namespace */
+
+		if (op->common.node) {
+			*out_op = op;
+			return_ACPI_STATUS(AE_OK);
+		}
+	}
+
+	path = acpi_ps_get_next_namestring(&walk_state->parser_state);
+
+	/* Map the raw opcode into an internal object type */
+
+	object_type = walk_state->op_info->object_type;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,
+			  "State=%p Op=%p [%s]\n", walk_state, op,
+			  acpi_ut_get_type_name(object_type)));
+
+	switch (walk_state->opcode) {
+	case AML_SCOPE_OP:
+
+		/*
+		 * The target name of the Scope() operator must exist at this point so
+		 * that we can actually open the scope to enter new names underneath it.
+		 * Allow search-to-root for single namesegs.
+		 */
+		status =
+		    acpi_ns_lookup(walk_state->scope_info, path, object_type,
+				   ACPI_IMODE_EXECUTE, ACPI_NS_SEARCH_PARENT,
+				   walk_state, &(node));
+#ifdef ACPI_ASL_COMPILER
+		if (status == AE_NOT_FOUND) {
+			/*
+			 * Table disassembly:
+			 * Target of Scope() not found. Generate an External for it, and
+			 * insert the name into the namespace.
+			 */
+			acpi_dm_add_to_external_list(op, path, ACPI_TYPE_DEVICE,
+						     0);
+			status =
+			    acpi_ns_lookup(walk_state->scope_info, path,
+					   object_type, ACPI_IMODE_LOAD_PASS1,
+					   ACPI_NS_SEARCH_PARENT, walk_state,
+					   &node);
+		}
+#endif
+		if (ACPI_FAILURE(status)) {
+			ACPI_ERROR_NAMESPACE(path, status);
+			return_ACPI_STATUS(status);
+		}
+
+		/*
+		 * Check to make sure that the target is
+		 * one of the opcodes that actually opens a scope
+		 */
+		switch (node->type) {
+		case ACPI_TYPE_ANY:
+		case ACPI_TYPE_LOCAL_SCOPE:	/* Scope  */
+		case ACPI_TYPE_DEVICE:
+		case ACPI_TYPE_POWER:
+		case ACPI_TYPE_PROCESSOR:
+		case ACPI_TYPE_THERMAL:
+
+			/* These are acceptable types */
+			break;
+
+		case ACPI_TYPE_INTEGER:
+		case ACPI_TYPE_STRING:
+		case ACPI_TYPE_BUFFER:
+
+			/*
+			 * These types we will allow, but we will change the type.
+			 * This enables some existing code of the form:
+			 *
+			 *  Name (DEB, 0)
+			 *  Scope (DEB) { ... }
+			 *
+			 * Note: silently change the type here. On the second pass,
+			 * we will report a warning
+			 */
+			ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+					  "Type override - [%4.4s] had invalid type (%s) "
+					  "for Scope operator, changed to type ANY\n",
+					  acpi_ut_get_node_name(node),
+					  acpi_ut_get_type_name(node->type)));
+
+			node->type = ACPI_TYPE_ANY;
+			walk_state->scope_info->common.value = ACPI_TYPE_ANY;
+			break;
+
+		default:
+
+			/* All other types are an error */
+
+			ACPI_ERROR((AE_INFO,
+				    "Invalid type (%s) for target of "
+				    "Scope operator [%4.4s] (Cannot override)",
+				    acpi_ut_get_type_name(node->type),
+				    acpi_ut_get_node_name(node)));
+
+			return_ACPI_STATUS(AE_AML_OPERAND_TYPE);
+		}
+		break;
+
+	default:
+		/*
+		 * For all other named opcodes, we will enter the name into
+		 * the namespace.
+		 *
+		 * Setup the search flags.
+		 * Since we are entering a name into the namespace, we do not want to
+		 * enable the search-to-root upsearch.
+		 *
+		 * There are only two conditions where it is acceptable that the name
+		 * already exists:
+		 *    1) the Scope() operator can reopen a scoping object that was
+		 *       previously defined (Scope, Method, Device, etc.)
+		 *    2) Whenever we are parsing a deferred opcode (op_region, Buffer,
+		 *       buffer_field, or Package), the name of the object is already
+		 *       in the namespace.
+		 */
+		if (walk_state->deferred_node) {
+
+			/* This name is already in the namespace, get the node */
+
+			node = walk_state->deferred_node;
+			status = AE_OK;
+			break;
+		}
+
+		/*
+		 * If we are executing a method, do not create any namespace objects
+		 * during the load phase, only during execution.
+		 */
+		if (walk_state->method_node) {
+			node = NULL;
+			status = AE_OK;
+			break;
+		}
+
+		flags = ACPI_NS_NO_UPSEARCH;
+		if ((walk_state->opcode != AML_SCOPE_OP) &&
+		    (!(walk_state->parse_flags & ACPI_PARSE_DEFERRED_OP))) {
+			flags |= ACPI_NS_ERROR_IF_FOUND;
+			ACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,
+					  "[%s] Cannot already exist\n",
+					  acpi_ut_get_type_name(object_type)));
+		} else {
+			ACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,
+					  "[%s] Both Find or Create allowed\n",
+					  acpi_ut_get_type_name(object_type)));
+		}
+
+		/*
+		 * Enter the named type into the internal namespace. We enter the name
+		 * as we go downward in the parse tree. Any necessary subobjects that
+		 * involve arguments to the opcode must be created as we go back up the
+		 * parse tree later.
+		 */
+		status =
+		    acpi_ns_lookup(walk_state->scope_info, path, object_type,
+				   ACPI_IMODE_LOAD_PASS1, flags, walk_state,
+				   &node);
+		if (ACPI_FAILURE(status)) {
+			if (status == AE_ALREADY_EXISTS) {
+
+				/* The name already exists in this scope */
+
+				if (node->flags & ANOBJ_IS_EXTERNAL) {
+					/*
+					 * Allow one create on an object or segment that was
+					 * previously declared External
+					 */
+					node->flags &= ~ANOBJ_IS_EXTERNAL;
+					node->type = (u8)object_type;
+
+					/* Just retyped a node, probably will need to open a scope */
+
+					if (acpi_ns_opens_scope(object_type)) {
+						status =
+						    acpi_ds_scope_stack_push
+						    (node, object_type,
+						     walk_state);
+						if (ACPI_FAILURE(status)) {
+							return_ACPI_STATUS
+							    (status);
+						}
+					}
+
+					status = AE_OK;
+				}
+			}
+
+			if (ACPI_FAILURE(status)) {
+				ACPI_ERROR_NAMESPACE(path, status);
+				return_ACPI_STATUS(status);
+			}
+		}
+		break;
+	}
+
+	/* Common exit */
+
+	if (!op) {
+
+		/* Create a new op */
+
+		op = acpi_ps_alloc_op(walk_state->opcode);
+		if (!op) {
+			return_ACPI_STATUS(AE_NO_MEMORY);
+		}
+	}
+
+	/* Initialize the op */
+
+#if (defined (ACPI_NO_METHOD_EXECUTION) || defined (ACPI_CONSTANT_EVAL_ONLY))
+	op->named.path = ACPI_CAST_PTR(u8, path);
+#endif
+
+	if (node) {
+		/*
+		 * Put the Node in the "op" object that the parser uses, so we
+		 * can get it again quickly when this scope is closed
+		 */
+		op->common.node = node;
+		op->named.name = node->name.integer;
+	}
+
+	acpi_ps_append_arg(acpi_ps_get_parent_scope(&walk_state->parser_state),
+			   op);
+	*out_op = op;
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_load1_end_op
+ *
+ * PARAMETERS:  walk_state      - Current state of the parse tree walk
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Ascending callback used during the loading of the namespace,
+ *              both control methods and everything else.
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ds_load1_end_op(struct acpi_walk_state *walk_state)
+{
+	union acpi_parse_object *op;
+	acpi_object_type object_type;
+	acpi_status status = AE_OK;
+
+	ACPI_FUNCTION_TRACE(ds_load1_end_op);
+
+	op = walk_state->op;
+	ACPI_DEBUG_PRINT((ACPI_DB_DISPATCH, "Op=%p State=%p\n", op,
+			  walk_state));
+
+	/* We are only interested in opcodes that have an associated name */
+
+	if (!(walk_state->op_info->flags & (AML_NAMED | AML_FIELD))) {
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	/* Get the object type to determine if we should pop the scope */
+
+	object_type = walk_state->op_info->object_type;
+
+#ifndef ACPI_NO_METHOD_EXECUTION
+	if (walk_state->op_info->flags & AML_FIELD) {
+		/*
+		 * If we are executing a method, do not create any namespace objects
+		 * during the load phase, only during execution.
+		 */
+		if (!walk_state->method_node) {
+			if (walk_state->opcode == AML_FIELD_OP ||
+			    walk_state->opcode == AML_BANK_FIELD_OP ||
+			    walk_state->opcode == AML_INDEX_FIELD_OP) {
+				status =
+				    acpi_ds_init_field_objects(op, walk_state);
+			}
+		}
+		return_ACPI_STATUS(status);
+	}
+
+	/*
+	 * If we are executing a method, do not create any namespace objects
+	 * during the load phase, only during execution.
+	 */
+	if (!walk_state->method_node) {
+		if (op->common.aml_opcode == AML_REGION_OP) {
+			status =
+			    acpi_ex_create_region(op->named.data,
+						  op->named.length,
+						  (acpi_adr_space_type) ((op->
+									  common.
+									  value.
+									  arg)->
+									 common.
+									 value.
+									 integer),
+						  walk_state);
+			if (ACPI_FAILURE(status)) {
+				return_ACPI_STATUS(status);
+			}
+		} else if (op->common.aml_opcode == AML_DATA_REGION_OP) {
+			status =
+			    acpi_ex_create_region(op->named.data,
+						  op->named.length,
+						  ACPI_ADR_SPACE_DATA_TABLE,
+						  walk_state);
+			if (ACPI_FAILURE(status)) {
+				return_ACPI_STATUS(status);
+			}
+		}
+	}
+#endif
+
+	if (op->common.aml_opcode == AML_NAME_OP) {
+
+		/* For Name opcode, get the object type from the argument */
+
+		if (op->common.value.arg) {
+			object_type = (acpi_ps_get_opcode_info((op->common.
+								value.arg)->
+							       common.
+							       aml_opcode))->
+			    object_type;
+
+			/* Set node type if we have a namespace node */
+
+			if (op->common.node) {
+				op->common.node->type = (u8)object_type;
+			}
+		}
+	}
+
+	/*
+	 * If we are executing a method, do not create any namespace objects
+	 * during the load phase, only during execution.
+	 */
+	if (!walk_state->method_node) {
+		if (op->common.aml_opcode == AML_METHOD_OP) {
+			/*
+			 * method_op pkg_length name_string method_flags term_list
+			 *
+			 * Note: We must create the method node/object pair as soon as we
+			 * see the method declaration. This allows later pass1 parsing
+			 * of invocations of the method (need to know the number of
+			 * arguments.)
+			 */
+			ACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,
+					  "LOADING-Method: State=%p Op=%p NamedObj=%p\n",
+					  walk_state, op, op->named.node));
+
+			if (!acpi_ns_get_attached_object(op->named.node)) {
+				walk_state->operands[0] =
+				    ACPI_CAST_PTR(void, op->named.node);
+				walk_state->num_operands = 1;
+
+				status =
+				    acpi_ds_create_operands(walk_state,
+							    op->common.value.
+							    arg);
+				if (ACPI_SUCCESS(status)) {
+					status =
+					    acpi_ex_create_method(op->named.
+								  data,
+								  op->named.
+								  length,
+								  walk_state);
+				}
+
+				walk_state->operands[0] = NULL;
+				walk_state->num_operands = 0;
+
+				if (ACPI_FAILURE(status)) {
+					return_ACPI_STATUS(status);
+				}
+			}
+		}
+	}
+
+	/* Pop the scope stack (only if loading a table) */
+
+	if (!walk_state->method_node && acpi_ns_opens_scope(object_type)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,
+				  "(%s): Popping scope for Op %p\n",
+				  acpi_ut_get_type_name(object_type), op));
+
+		status = acpi_ds_scope_stack_pop(walk_state);
+	}
+
+	return_ACPI_STATUS(status);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/dswload2.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/dswload2.c
new file mode 100644
index 00000000..ae714772
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/dswload2.c
@@ -0,0 +1,720 @@
+/******************************************************************************
+ *
+ * Module Name: dswload2 - Dispatcher second pass namespace load callbacks
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acparser.h"
+#include "amlcode.h"
+#include "acdispat.h"
+#include "acinterp.h"
+#include "acnamesp.h"
+#include "acevents.h"
+
+#define _COMPONENT          ACPI_DISPATCHER
+ACPI_MODULE_NAME("dswload2")
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_load2_begin_op
+ *
+ * PARAMETERS:  walk_state      - Current state of the parse tree walk
+ *              out_op          - Wher to return op if a new one is created
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Descending callback used during the loading of ACPI tables.
+ *
+ ******************************************************************************/
+acpi_status
+acpi_ds_load2_begin_op(struct acpi_walk_state *walk_state,
+		       union acpi_parse_object **out_op)
+{
+	union acpi_parse_object *op;
+	struct acpi_namespace_node *node;
+	acpi_status status;
+	acpi_object_type object_type;
+	char *buffer_ptr;
+	u32 flags;
+
+	ACPI_FUNCTION_TRACE(ds_load2_begin_op);
+
+	op = walk_state->op;
+	ACPI_DEBUG_PRINT((ACPI_DB_DISPATCH, "Op=%p State=%p\n", op,
+			  walk_state));
+
+	if (op) {
+		if ((walk_state->control_state) &&
+		    (walk_state->control_state->common.state ==
+		     ACPI_CONTROL_CONDITIONAL_EXECUTING)) {
+
+			/* We are executing a while loop outside of a method */
+
+			status = acpi_ds_exec_begin_op(walk_state, out_op);
+			return_ACPI_STATUS(status);
+		}
+
+		/* We only care about Namespace opcodes here */
+
+		if ((!(walk_state->op_info->flags & AML_NSOPCODE) &&
+		     (walk_state->opcode != AML_INT_NAMEPATH_OP)) ||
+		    (!(walk_state->op_info->flags & AML_NAMED))) {
+			return_ACPI_STATUS(AE_OK);
+		}
+
+		/* Get the name we are going to enter or lookup in the namespace */
+
+		if (walk_state->opcode == AML_INT_NAMEPATH_OP) {
+
+			/* For Namepath op, get the path string */
+
+			buffer_ptr = op->common.value.string;
+			if (!buffer_ptr) {
+
+				/* No name, just exit */
+
+				return_ACPI_STATUS(AE_OK);
+			}
+		} else {
+			/* Get name from the op */
+
+			buffer_ptr = ACPI_CAST_PTR(char, &op->named.name);
+		}
+	} else {
+		/* Get the namestring from the raw AML */
+
+		buffer_ptr =
+		    acpi_ps_get_next_namestring(&walk_state->parser_state);
+	}
+
+	/* Map the opcode into an internal object type */
+
+	object_type = walk_state->op_info->object_type;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,
+			  "State=%p Op=%p Type=%X\n", walk_state, op,
+			  object_type));
+
+	switch (walk_state->opcode) {
+	case AML_FIELD_OP:
+	case AML_BANK_FIELD_OP:
+	case AML_INDEX_FIELD_OP:
+
+		node = NULL;
+		status = AE_OK;
+		break;
+
+	case AML_INT_NAMEPATH_OP:
+		/*
+		 * The name_path is an object reference to an existing object.
+		 * Don't enter the name into the namespace, but look it up
+		 * for use later.
+		 */
+		status =
+		    acpi_ns_lookup(walk_state->scope_info, buffer_ptr,
+				   object_type, ACPI_IMODE_EXECUTE,
+				   ACPI_NS_SEARCH_PARENT, walk_state, &(node));
+		break;
+
+	case AML_SCOPE_OP:
+
+		/* Special case for Scope(\) -> refers to the Root node */
+
+		if (op && (op->named.node == acpi_gbl_root_node)) {
+			node = op->named.node;
+
+			status =
+			    acpi_ds_scope_stack_push(node, object_type,
+						     walk_state);
+			if (ACPI_FAILURE(status)) {
+				return_ACPI_STATUS(status);
+			}
+		} else {
+			/*
+			 * The Path is an object reference to an existing object.
+			 * Don't enter the name into the namespace, but look it up
+			 * for use later.
+			 */
+			status =
+			    acpi_ns_lookup(walk_state->scope_info, buffer_ptr,
+					   object_type, ACPI_IMODE_EXECUTE,
+					   ACPI_NS_SEARCH_PARENT, walk_state,
+					   &(node));
+			if (ACPI_FAILURE(status)) {
+#ifdef ACPI_ASL_COMPILER
+				if (status == AE_NOT_FOUND) {
+					status = AE_OK;
+				} else {
+					ACPI_ERROR_NAMESPACE(buffer_ptr,
+							     status);
+				}
+#else
+				ACPI_ERROR_NAMESPACE(buffer_ptr, status);
+#endif
+				return_ACPI_STATUS(status);
+			}
+		}
+
+		/*
+		 * We must check to make sure that the target is
+		 * one of the opcodes that actually opens a scope
+		 */
+		switch (node->type) {
+		case ACPI_TYPE_ANY:
+		case ACPI_TYPE_LOCAL_SCOPE:	/* Scope */
+		case ACPI_TYPE_DEVICE:
+		case ACPI_TYPE_POWER:
+		case ACPI_TYPE_PROCESSOR:
+		case ACPI_TYPE_THERMAL:
+
+			/* These are acceptable types */
+			break;
+
+		case ACPI_TYPE_INTEGER:
+		case ACPI_TYPE_STRING:
+		case ACPI_TYPE_BUFFER:
+
+			/*
+			 * These types we will allow, but we will change the type.
+			 * This enables some existing code of the form:
+			 *
+			 *  Name (DEB, 0)
+			 *  Scope (DEB) { ... }
+			 */
+			ACPI_WARNING((AE_INFO,
+				      "Type override - [%4.4s] had invalid type (%s) "
+				      "for Scope operator, changed to type ANY\n",
+				      acpi_ut_get_node_name(node),
+				      acpi_ut_get_type_name(node->type)));
+
+			node->type = ACPI_TYPE_ANY;
+			walk_state->scope_info->common.value = ACPI_TYPE_ANY;
+			break;
+
+		default:
+
+			/* All other types are an error */
+
+			ACPI_ERROR((AE_INFO,
+				    "Invalid type (%s) for target of "
+				    "Scope operator [%4.4s] (Cannot override)",
+				    acpi_ut_get_type_name(node->type),
+				    acpi_ut_get_node_name(node)));
+
+			return (AE_AML_OPERAND_TYPE);
+		}
+		break;
+
+	default:
+
+		/* All other opcodes */
+
+		if (op && op->common.node) {
+
+			/* This op/node was previously entered into the namespace */
+
+			node = op->common.node;
+
+			if (acpi_ns_opens_scope(object_type)) {
+				status =
+				    acpi_ds_scope_stack_push(node, object_type,
+							     walk_state);
+				if (ACPI_FAILURE(status)) {
+					return_ACPI_STATUS(status);
+				}
+			}
+
+			return_ACPI_STATUS(AE_OK);
+		}
+
+		/*
+		 * Enter the named type into the internal namespace. We enter the name
+		 * as we go downward in the parse tree. Any necessary subobjects that
+		 * involve arguments to the opcode must be created as we go back up the
+		 * parse tree later.
+		 *
+		 * Note: Name may already exist if we are executing a deferred opcode.
+		 */
+		if (walk_state->deferred_node) {
+
+			/* This name is already in the namespace, get the node */
+
+			node = walk_state->deferred_node;
+			status = AE_OK;
+			break;
+		}
+
+		flags = ACPI_NS_NO_UPSEARCH;
+		if (walk_state->pass_number == ACPI_IMODE_EXECUTE) {
+
+			/* Execution mode, node cannot already exist, node is temporary */
+
+			flags |= ACPI_NS_ERROR_IF_FOUND;
+
+			if (!
+			    (walk_state->
+			     parse_flags & ACPI_PARSE_MODULE_LEVEL)) {
+				flags |= ACPI_NS_TEMPORARY;
+			}
+		}
+
+		/* Add new entry or lookup existing entry */
+
+		status =
+		    acpi_ns_lookup(walk_state->scope_info, buffer_ptr,
+				   object_type, ACPI_IMODE_LOAD_PASS2, flags,
+				   walk_state, &node);
+
+		if (ACPI_SUCCESS(status) && (flags & ACPI_NS_TEMPORARY)) {
+			ACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,
+					  "***New Node [%4.4s] %p is temporary\n",
+					  acpi_ut_get_node_name(node), node));
+		}
+		break;
+	}
+
+	if (ACPI_FAILURE(status)) {
+		ACPI_ERROR_NAMESPACE(buffer_ptr, status);
+		return_ACPI_STATUS(status);
+	}
+
+	if (!op) {
+
+		/* Create a new op */
+
+		op = acpi_ps_alloc_op(walk_state->opcode);
+		if (!op) {
+			return_ACPI_STATUS(AE_NO_MEMORY);
+		}
+
+		/* Initialize the new op */
+
+		if (node) {
+			op->named.name = node->name.integer;
+		}
+		*out_op = op;
+	}
+
+	/*
+	 * Put the Node in the "op" object that the parser uses, so we
+	 * can get it again quickly when this scope is closed
+	 */
+	op->common.node = node;
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_load2_end_op
+ *
+ * PARAMETERS:  walk_state      - Current state of the parse tree walk
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Ascending callback used during the loading of the namespace,
+ *              both control methods and everything else.
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ds_load2_end_op(struct acpi_walk_state *walk_state)
+{
+	union acpi_parse_object *op;
+	acpi_status status = AE_OK;
+	acpi_object_type object_type;
+	struct acpi_namespace_node *node;
+	union acpi_parse_object *arg;
+	struct acpi_namespace_node *new_node;
+#ifndef ACPI_NO_METHOD_EXECUTION
+	u32 i;
+	u8 region_space;
+#endif
+
+	ACPI_FUNCTION_TRACE(ds_load2_end_op);
+
+	op = walk_state->op;
+	ACPI_DEBUG_PRINT((ACPI_DB_DISPATCH, "Opcode [%s] Op %p State %p\n",
+			  walk_state->op_info->name, op, walk_state));
+
+	/* Check if opcode had an associated namespace object */
+
+	if (!(walk_state->op_info->flags & AML_NSOBJECT)) {
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	if (op->common.aml_opcode == AML_SCOPE_OP) {
+		ACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,
+				  "Ending scope Op=%p State=%p\n", op,
+				  walk_state));
+	}
+
+	object_type = walk_state->op_info->object_type;
+
+	/*
+	 * Get the Node/name from the earlier lookup
+	 * (It was saved in the *op structure)
+	 */
+	node = op->common.node;
+
+	/*
+	 * Put the Node on the object stack (Contains the ACPI Name of
+	 * this object)
+	 */
+	walk_state->operands[0] = (void *)node;
+	walk_state->num_operands = 1;
+
+	/* Pop the scope stack */
+
+	if (acpi_ns_opens_scope(object_type) &&
+	    (op->common.aml_opcode != AML_INT_METHODCALL_OP)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,
+				  "(%s) Popping scope for Op %p\n",
+				  acpi_ut_get_type_name(object_type), op));
+
+		status = acpi_ds_scope_stack_pop(walk_state);
+		if (ACPI_FAILURE(status)) {
+			goto cleanup;
+		}
+	}
+
+	/*
+	 * Named operations are as follows:
+	 *
+	 * AML_ALIAS
+	 * AML_BANKFIELD
+	 * AML_CREATEBITFIELD
+	 * AML_CREATEBYTEFIELD
+	 * AML_CREATEDWORDFIELD
+	 * AML_CREATEFIELD
+	 * AML_CREATEQWORDFIELD
+	 * AML_CREATEWORDFIELD
+	 * AML_DATA_REGION
+	 * AML_DEVICE
+	 * AML_EVENT
+	 * AML_FIELD
+	 * AML_INDEXFIELD
+	 * AML_METHOD
+	 * AML_METHODCALL
+	 * AML_MUTEX
+	 * AML_NAME
+	 * AML_NAMEDFIELD
+	 * AML_OPREGION
+	 * AML_POWERRES
+	 * AML_PROCESSOR
+	 * AML_SCOPE
+	 * AML_THERMALZONE
+	 */
+
+	ACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,
+			  "Create-Load [%s] State=%p Op=%p NamedObj=%p\n",
+			  acpi_ps_get_opcode_name(op->common.aml_opcode),
+			  walk_state, op, node));
+
+	/* Decode the opcode */
+
+	arg = op->common.value.arg;
+
+	switch (walk_state->op_info->type) {
+#ifndef ACPI_NO_METHOD_EXECUTION
+
+	case AML_TYPE_CREATE_FIELD:
+		/*
+		 * Create the field object, but the field buffer and index must
+		 * be evaluated later during the execution phase
+		 */
+		status = acpi_ds_create_buffer_field(op, walk_state);
+		break;
+
+	case AML_TYPE_NAMED_FIELD:
+		/*
+		 * If we are executing a method, initialize the field
+		 */
+		if (walk_state->method_node) {
+			status = acpi_ds_init_field_objects(op, walk_state);
+		}
+
+		switch (op->common.aml_opcode) {
+		case AML_INDEX_FIELD_OP:
+
+			status =
+			    acpi_ds_create_index_field(op,
+						       (acpi_handle) arg->
+						       common.node, walk_state);
+			break;
+
+		case AML_BANK_FIELD_OP:
+
+			status =
+			    acpi_ds_create_bank_field(op, arg->common.node,
+						      walk_state);
+			break;
+
+		case AML_FIELD_OP:
+
+			status =
+			    acpi_ds_create_field(op, arg->common.node,
+						 walk_state);
+			break;
+
+		default:
+			/* All NAMED_FIELD opcodes must be handled above */
+			break;
+		}
+		break;
+
+	case AML_TYPE_NAMED_SIMPLE:
+
+		status = acpi_ds_create_operands(walk_state, arg);
+		if (ACPI_FAILURE(status)) {
+			goto cleanup;
+		}
+
+		switch (op->common.aml_opcode) {
+		case AML_PROCESSOR_OP:
+
+			status = acpi_ex_create_processor(walk_state);
+			break;
+
+		case AML_POWER_RES_OP:
+
+			status = acpi_ex_create_power_resource(walk_state);
+			break;
+
+		case AML_MUTEX_OP:
+
+			status = acpi_ex_create_mutex(walk_state);
+			break;
+
+		case AML_EVENT_OP:
+
+			status = acpi_ex_create_event(walk_state);
+			break;
+
+		case AML_ALIAS_OP:
+
+			status = acpi_ex_create_alias(walk_state);
+			break;
+
+		default:
+			/* Unknown opcode */
+
+			status = AE_OK;
+			goto cleanup;
+		}
+
+		/* Delete operands */
+
+		for (i = 1; i < walk_state->num_operands; i++) {
+			acpi_ut_remove_reference(walk_state->operands[i]);
+			walk_state->operands[i] = NULL;
+		}
+
+		break;
+#endif				/* ACPI_NO_METHOD_EXECUTION */
+
+	case AML_TYPE_NAMED_COMPLEX:
+
+		switch (op->common.aml_opcode) {
+#ifndef ACPI_NO_METHOD_EXECUTION
+		case AML_REGION_OP:
+		case AML_DATA_REGION_OP:
+
+			if (op->common.aml_opcode == AML_REGION_OP) {
+				region_space = (acpi_adr_space_type)
+				    ((op->common.value.arg)->common.value.
+				     integer);
+			} else {
+				region_space = ACPI_ADR_SPACE_DATA_TABLE;
+			}
+
+			/*
+			 * The op_region is not fully parsed at this time. The only valid
+			 * argument is the space_id. (We must save the address of the
+			 * AML of the address and length operands)
+			 *
+			 * If we have a valid region, initialize it. The namespace is
+			 * unlocked at this point.
+			 *
+			 * Need to unlock interpreter if it is locked (if we are running
+			 * a control method), in order to allow _REG methods to be run
+			 * during acpi_ev_initialize_region.
+			 */
+			if (walk_state->method_node) {
+				/*
+				 * Executing a method: initialize the region and unlock
+				 * the interpreter
+				 */
+				status =
+				    acpi_ex_create_region(op->named.data,
+							  op->named.length,
+							  region_space,
+							  walk_state);
+				if (ACPI_FAILURE(status)) {
+					return (status);
+				}
+
+				acpi_ex_exit_interpreter();
+			}
+
+			status =
+			    acpi_ev_initialize_region
+			    (acpi_ns_get_attached_object(node), FALSE);
+			if (walk_state->method_node) {
+				acpi_ex_enter_interpreter();
+			}
+
+			if (ACPI_FAILURE(status)) {
+				/*
+				 *  If AE_NOT_EXIST is returned, it is not fatal
+				 *  because many regions get created before a handler
+				 *  is installed for said region.
+				 */
+				if (AE_NOT_EXIST == status) {
+					status = AE_OK;
+				}
+			}
+			break;
+
+		case AML_NAME_OP:
+
+			status = acpi_ds_create_node(walk_state, node, op);
+			break;
+
+		case AML_METHOD_OP:
+			/*
+			 * method_op pkg_length name_string method_flags term_list
+			 *
+			 * Note: We must create the method node/object pair as soon as we
+			 * see the method declaration. This allows later pass1 parsing
+			 * of invocations of the method (need to know the number of
+			 * arguments.)
+			 */
+			ACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,
+					  "LOADING-Method: State=%p Op=%p NamedObj=%p\n",
+					  walk_state, op, op->named.node));
+
+			if (!acpi_ns_get_attached_object(op->named.node)) {
+				walk_state->operands[0] =
+				    ACPI_CAST_PTR(void, op->named.node);
+				walk_state->num_operands = 1;
+
+				status =
+				    acpi_ds_create_operands(walk_state,
+							    op->common.value.
+							    arg);
+				if (ACPI_SUCCESS(status)) {
+					status =
+					    acpi_ex_create_method(op->named.
+								  data,
+								  op->named.
+								  length,
+								  walk_state);
+				}
+				walk_state->operands[0] = NULL;
+				walk_state->num_operands = 0;
+
+				if (ACPI_FAILURE(status)) {
+					return_ACPI_STATUS(status);
+				}
+			}
+			break;
+
+#endif				/* ACPI_NO_METHOD_EXECUTION */
+
+		default:
+			/* All NAMED_COMPLEX opcodes must be handled above */
+			break;
+		}
+		break;
+
+	case AML_CLASS_INTERNAL:
+
+		/* case AML_INT_NAMEPATH_OP: */
+		break;
+
+	case AML_CLASS_METHOD_CALL:
+
+		ACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,
+				  "RESOLVING-MethodCall: State=%p Op=%p NamedObj=%p\n",
+				  walk_state, op, node));
+
+		/*
+		 * Lookup the method name and save the Node
+		 */
+		status =
+		    acpi_ns_lookup(walk_state->scope_info,
+				   arg->common.value.string, ACPI_TYPE_ANY,
+				   ACPI_IMODE_LOAD_PASS2,
+				   ACPI_NS_SEARCH_PARENT |
+				   ACPI_NS_DONT_OPEN_SCOPE, walk_state,
+				   &(new_node));
+		if (ACPI_SUCCESS(status)) {
+			/*
+			 * Make sure that what we found is indeed a method
+			 * We didn't search for a method on purpose, to see if the name
+			 * would resolve
+			 */
+			if (new_node->type != ACPI_TYPE_METHOD) {
+				status = AE_AML_OPERAND_TYPE;
+			}
+
+			/* We could put the returned object (Node) on the object stack for
+			 * later, but for now, we will put it in the "op" object that the
+			 * parser uses, so we can get it again at the end of this scope
+			 */
+			op->common.node = new_node;
+		} else {
+			ACPI_ERROR_NAMESPACE(arg->common.value.string, status);
+		}
+		break;
+
+	default:
+		break;
+	}
+
+      cleanup:
+
+	/* Remove the Node pushed at the very beginning */
+
+	walk_state->operands[0] = NULL;
+	walk_state->num_operands = 0;
+	return_ACPI_STATUS(status);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/dswscope.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/dswscope.c
new file mode 100644
index 00000000..4b2540cf
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/dswscope.c
@@ -0,0 +1,214 @@
+/******************************************************************************
+ *
+ * Module Name: dswscope - Scope stack manipulation
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acdispat.h"
+
+#define _COMPONENT          ACPI_DISPATCHER
+ACPI_MODULE_NAME("dswscope")
+
+/****************************************************************************
+ *
+ * FUNCTION:    acpi_ds_scope_stack_clear
+ *
+ * PARAMETERS:  walk_state      - Current state
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Pop (and free) everything on the scope stack except the
+ *              root scope object (which remains at the stack top.)
+ *
+ ***************************************************************************/
+void acpi_ds_scope_stack_clear(struct acpi_walk_state *walk_state)
+{
+	union acpi_generic_state *scope_info;
+
+	ACPI_FUNCTION_NAME(ds_scope_stack_clear);
+
+	while (walk_state->scope_info) {
+
+		/* Pop a scope off the stack */
+
+		scope_info = walk_state->scope_info;
+		walk_state->scope_info = scope_info->scope.next;
+
+		ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
+				  "Popped object type (%s)\n",
+				  acpi_ut_get_type_name(scope_info->common.
+							value)));
+		acpi_ut_delete_generic_state(scope_info);
+	}
+}
+
+/****************************************************************************
+ *
+ * FUNCTION:    acpi_ds_scope_stack_push
+ *
+ * PARAMETERS:  Node            - Name to be made current
+ *              Type            - Type of frame being pushed
+ *              walk_state      - Current state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Push the current scope on the scope stack, and make the
+ *              passed Node current.
+ *
+ ***************************************************************************/
+
+acpi_status
+acpi_ds_scope_stack_push(struct acpi_namespace_node *node,
+			 acpi_object_type type,
+			 struct acpi_walk_state *walk_state)
+{
+	union acpi_generic_state *scope_info;
+	union acpi_generic_state *old_scope_info;
+
+	ACPI_FUNCTION_TRACE(ds_scope_stack_push);
+
+	if (!node) {
+
+		/* Invalid scope   */
+
+		ACPI_ERROR((AE_INFO, "Null scope parameter"));
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	/* Make sure object type is valid */
+
+	if (!acpi_ut_valid_object_type(type)) {
+		ACPI_WARNING((AE_INFO, "Invalid object type: 0x%X", type));
+	}
+
+	/* Allocate a new scope object */
+
+	scope_info = acpi_ut_create_generic_state();
+	if (!scope_info) {
+		return_ACPI_STATUS(AE_NO_MEMORY);
+	}
+
+	/* Init new scope object */
+
+	scope_info->common.descriptor_type = ACPI_DESC_TYPE_STATE_WSCOPE;
+	scope_info->scope.node = node;
+	scope_info->common.value = (u16)type;
+
+	walk_state->scope_depth++;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
+			  "[%.2d] Pushed scope ",
+			  (u32)walk_state->scope_depth));
+
+	old_scope_info = walk_state->scope_info;
+	if (old_scope_info) {
+		ACPI_DEBUG_PRINT_RAW((ACPI_DB_EXEC,
+				      "[%4.4s] (%s)",
+				      acpi_ut_get_node_name(old_scope_info->
+							    scope.node),
+				      acpi_ut_get_type_name(old_scope_info->
+							    common.value)));
+	} else {
+		ACPI_DEBUG_PRINT_RAW((ACPI_DB_EXEC, "[\\___] (%s)", "ROOT"));
+	}
+
+	ACPI_DEBUG_PRINT_RAW((ACPI_DB_EXEC,
+			      ", New scope -> [%4.4s] (%s)\n",
+			      acpi_ut_get_node_name(scope_info->scope.node),
+			      acpi_ut_get_type_name(scope_info->common.value)));
+
+	/* Push new scope object onto stack */
+
+	acpi_ut_push_generic_state(&walk_state->scope_info, scope_info);
+	return_ACPI_STATUS(AE_OK);
+}
+
+/****************************************************************************
+ *
+ * FUNCTION:    acpi_ds_scope_stack_pop
+ *
+ * PARAMETERS:  walk_state      - Current state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Pop the scope stack once.
+ *
+ ***************************************************************************/
+
+acpi_status acpi_ds_scope_stack_pop(struct acpi_walk_state *walk_state)
+{
+	union acpi_generic_state *scope_info;
+	union acpi_generic_state *new_scope_info;
+
+	ACPI_FUNCTION_TRACE(ds_scope_stack_pop);
+
+	/*
+	 * Pop scope info object off the stack.
+	 */
+	scope_info = acpi_ut_pop_generic_state(&walk_state->scope_info);
+	if (!scope_info) {
+		return_ACPI_STATUS(AE_STACK_UNDERFLOW);
+	}
+
+	walk_state->scope_depth--;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
+			  "[%.2d] Popped scope [%4.4s] (%s), New scope -> ",
+			  (u32)walk_state->scope_depth,
+			  acpi_ut_get_node_name(scope_info->scope.node),
+			  acpi_ut_get_type_name(scope_info->common.value)));
+
+	new_scope_info = walk_state->scope_info;
+	if (new_scope_info) {
+		ACPI_DEBUG_PRINT_RAW((ACPI_DB_EXEC,
+				      "[%4.4s] (%s)\n",
+				      acpi_ut_get_node_name(new_scope_info->
+							    scope.node),
+				      acpi_ut_get_type_name(new_scope_info->
+							    common.value)));
+	} else {
+		ACPI_DEBUG_PRINT_RAW((ACPI_DB_EXEC, "[\\___] (ROOT)\n"));
+	}
+
+	acpi_ut_delete_generic_state(scope_info);
+	return_ACPI_STATUS(AE_OK);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/dswstate.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/dswstate.c
new file mode 100644
index 00000000..de73bbe2
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/dswstate.c
@@ -0,0 +1,758 @@
+/******************************************************************************
+ *
+ * Module Name: dswstate - Dispatcher parse tree walk management routines
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acparser.h"
+#include "acdispat.h"
+#include "acnamesp.h"
+
+#define _COMPONENT          ACPI_DISPATCHER
+ACPI_MODULE_NAME("dswstate")
+
+/* Local prototypes */
+static acpi_status
+acpi_ds_result_stack_push(struct acpi_walk_state *walk_state);
+
+static acpi_status acpi_ds_result_stack_pop(struct acpi_walk_state *walk_state);
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_result_pop
+ *
+ * PARAMETERS:  Object              - Where to return the popped object
+ *              walk_state          - Current Walk state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Pop an object off the top of this walk's result stack
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ds_result_pop(union acpi_operand_object **object,
+		   struct acpi_walk_state *walk_state)
+{
+	u32 index;
+	union acpi_generic_state *state;
+	acpi_status status;
+
+	ACPI_FUNCTION_NAME(ds_result_pop);
+
+	state = walk_state->results;
+
+	/* Incorrect state of result stack */
+
+	if (state && !walk_state->result_count) {
+		ACPI_ERROR((AE_INFO, "No results on result stack"));
+		return (AE_AML_INTERNAL);
+	}
+
+	if (!state && walk_state->result_count) {
+		ACPI_ERROR((AE_INFO, "No result state for result stack"));
+		return (AE_AML_INTERNAL);
+	}
+
+	/* Empty result stack */
+
+	if (!state) {
+		ACPI_ERROR((AE_INFO, "Result stack is empty! State=%p",
+			    walk_state));
+		return (AE_AML_NO_RETURN_VALUE);
+	}
+
+	/* Return object of the top element and clean that top element result stack */
+
+	walk_state->result_count--;
+	index = (u32)walk_state->result_count % ACPI_RESULTS_FRAME_OBJ_NUM;
+
+	*object = state->results.obj_desc[index];
+	if (!*object) {
+		ACPI_ERROR((AE_INFO,
+			    "No result objects on result stack, State=%p",
+			    walk_state));
+		return (AE_AML_NO_RETURN_VALUE);
+	}
+
+	state->results.obj_desc[index] = NULL;
+	if (index == 0) {
+		status = acpi_ds_result_stack_pop(walk_state);
+		if (ACPI_FAILURE(status)) {
+			return (status);
+		}
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
+			  "Obj=%p [%s] Index=%X State=%p Num=%X\n", *object,
+			  acpi_ut_get_object_type_name(*object),
+			  index, walk_state, walk_state->result_count));
+
+	return (AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_result_push
+ *
+ * PARAMETERS:  Object              - Where to return the popped object
+ *              walk_state          - Current Walk state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Push an object onto the current result stack
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ds_result_push(union acpi_operand_object *object,
+		    struct acpi_walk_state * walk_state)
+{
+	union acpi_generic_state *state;
+	acpi_status status;
+	u32 index;
+
+	ACPI_FUNCTION_NAME(ds_result_push);
+
+	if (walk_state->result_count > walk_state->result_size) {
+		ACPI_ERROR((AE_INFO, "Result stack is full"));
+		return (AE_AML_INTERNAL);
+	} else if (walk_state->result_count == walk_state->result_size) {
+
+		/* Extend the result stack */
+
+		status = acpi_ds_result_stack_push(walk_state);
+		if (ACPI_FAILURE(status)) {
+			ACPI_ERROR((AE_INFO,
+				    "Failed to extend the result stack"));
+			return (status);
+		}
+	}
+
+	if (!(walk_state->result_count < walk_state->result_size)) {
+		ACPI_ERROR((AE_INFO, "No free elements in result stack"));
+		return (AE_AML_INTERNAL);
+	}
+
+	state = walk_state->results;
+	if (!state) {
+		ACPI_ERROR((AE_INFO, "No result stack frame during push"));
+		return (AE_AML_INTERNAL);
+	}
+
+	if (!object) {
+		ACPI_ERROR((AE_INFO,
+			    "Null Object! Obj=%p State=%p Num=%u",
+			    object, walk_state, walk_state->result_count));
+		return (AE_BAD_PARAMETER);
+	}
+
+	/* Assign the address of object to the top free element of result stack */
+
+	index = (u32)walk_state->result_count % ACPI_RESULTS_FRAME_OBJ_NUM;
+	state->results.obj_desc[index] = object;
+	walk_state->result_count++;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_EXEC, "Obj=%p [%s] State=%p Num=%X Cur=%X\n",
+			  object,
+			  acpi_ut_get_object_type_name((union
+							acpi_operand_object *)
+						       object), walk_state,
+			  walk_state->result_count,
+			  walk_state->current_result));
+
+	return (AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_result_stack_push
+ *
+ * PARAMETERS:  walk_state          - Current Walk state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Push an object onto the walk_state result stack
+ *
+ ******************************************************************************/
+
+static acpi_status acpi_ds_result_stack_push(struct acpi_walk_state *walk_state)
+{
+	union acpi_generic_state *state;
+
+	ACPI_FUNCTION_NAME(ds_result_stack_push);
+
+	/* Check for stack overflow */
+
+	if (((u32)walk_state->result_size + ACPI_RESULTS_FRAME_OBJ_NUM) >
+	    ACPI_RESULTS_OBJ_NUM_MAX) {
+		ACPI_ERROR((AE_INFO, "Result stack overflow: State=%p Num=%u",
+			    walk_state, walk_state->result_size));
+		return (AE_STACK_OVERFLOW);
+	}
+
+	state = acpi_ut_create_generic_state();
+	if (!state) {
+		return (AE_NO_MEMORY);
+	}
+
+	state->common.descriptor_type = ACPI_DESC_TYPE_STATE_RESULT;
+	acpi_ut_push_generic_state(&walk_state->results, state);
+
+	/* Increase the length of the result stack by the length of frame */
+
+	walk_state->result_size += ACPI_RESULTS_FRAME_OBJ_NUM;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_EXEC, "Results=%p State=%p\n",
+			  state, walk_state));
+
+	return (AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_result_stack_pop
+ *
+ * PARAMETERS:  walk_state          - Current Walk state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Pop an object off of the walk_state result stack
+ *
+ ******************************************************************************/
+
+static acpi_status acpi_ds_result_stack_pop(struct acpi_walk_state *walk_state)
+{
+	union acpi_generic_state *state;
+
+	ACPI_FUNCTION_NAME(ds_result_stack_pop);
+
+	/* Check for stack underflow */
+
+	if (walk_state->results == NULL) {
+		ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
+				  "Result stack underflow - State=%p\n",
+				  walk_state));
+		return (AE_AML_NO_OPERAND);
+	}
+
+	if (walk_state->result_size < ACPI_RESULTS_FRAME_OBJ_NUM) {
+		ACPI_ERROR((AE_INFO, "Insufficient result stack size"));
+		return (AE_AML_INTERNAL);
+	}
+
+	state = acpi_ut_pop_generic_state(&walk_state->results);
+	acpi_ut_delete_generic_state(state);
+
+	/* Decrease the length of result stack by the length of frame */
+
+	walk_state->result_size -= ACPI_RESULTS_FRAME_OBJ_NUM;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
+			  "Result=%p RemainingResults=%X State=%p\n",
+			  state, walk_state->result_count, walk_state));
+
+	return (AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_obj_stack_push
+ *
+ * PARAMETERS:  Object              - Object to push
+ *              walk_state          - Current Walk state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Push an object onto this walk's object/operand stack
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ds_obj_stack_push(void *object, struct acpi_walk_state * walk_state)
+{
+	ACPI_FUNCTION_NAME(ds_obj_stack_push);
+
+	/* Check for stack overflow */
+
+	if (walk_state->num_operands >= ACPI_OBJ_NUM_OPERANDS) {
+		ACPI_ERROR((AE_INFO,
+			    "Object stack overflow! Obj=%p State=%p #Ops=%u",
+			    object, walk_state, walk_state->num_operands));
+		return (AE_STACK_OVERFLOW);
+	}
+
+	/* Put the object onto the stack */
+
+	walk_state->operands[walk_state->operand_index] = object;
+	walk_state->num_operands++;
+
+	/* For the usual order of filling the operand stack */
+
+	walk_state->operand_index++;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_EXEC, "Obj=%p [%s] State=%p #Ops=%X\n",
+			  object,
+			  acpi_ut_get_object_type_name((union
+							acpi_operand_object *)
+						       object), walk_state,
+			  walk_state->num_operands));
+
+	return (AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_obj_stack_pop
+ *
+ * PARAMETERS:  pop_count           - Number of objects/entries to pop
+ *              walk_state          - Current Walk state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Pop this walk's object stack.  Objects on the stack are NOT
+ *              deleted by this routine.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ds_obj_stack_pop(u32 pop_count, struct acpi_walk_state * walk_state)
+{
+	u32 i;
+
+	ACPI_FUNCTION_NAME(ds_obj_stack_pop);
+
+	for (i = 0; i < pop_count; i++) {
+
+		/* Check for stack underflow */
+
+		if (walk_state->num_operands == 0) {
+			ACPI_ERROR((AE_INFO,
+				    "Object stack underflow! Count=%X State=%p #Ops=%u",
+				    pop_count, walk_state,
+				    walk_state->num_operands));
+			return (AE_STACK_UNDERFLOW);
+		}
+
+		/* Just set the stack entry to null */
+
+		walk_state->num_operands--;
+		walk_state->operands[walk_state->num_operands] = NULL;
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_EXEC, "Count=%X State=%p #Ops=%u\n",
+			  pop_count, walk_state, walk_state->num_operands));
+
+	return (AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_obj_stack_pop_and_delete
+ *
+ * PARAMETERS:  pop_count           - Number of objects/entries to pop
+ *              walk_state          - Current Walk state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Pop this walk's object stack and delete each object that is
+ *              popped off.
+ *
+ ******************************************************************************/
+
+void
+acpi_ds_obj_stack_pop_and_delete(u32 pop_count,
+				 struct acpi_walk_state *walk_state)
+{
+	s32 i;
+	union acpi_operand_object *obj_desc;
+
+	ACPI_FUNCTION_NAME(ds_obj_stack_pop_and_delete);
+
+	if (pop_count == 0) {
+		return;
+	}
+
+	for (i = (s32) pop_count - 1; i >= 0; i--) {
+		if (walk_state->num_operands == 0) {
+			return;
+		}
+
+		/* Pop the stack and delete an object if present in this stack entry */
+
+		walk_state->num_operands--;
+		obj_desc = walk_state->operands[i];
+		if (obj_desc) {
+			acpi_ut_remove_reference(walk_state->operands[i]);
+			walk_state->operands[i] = NULL;
+		}
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_EXEC, "Count=%X State=%p #Ops=%X\n",
+			  pop_count, walk_state, walk_state->num_operands));
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_get_current_walk_state
+ *
+ * PARAMETERS:  Thread          - Get current active state for this Thread
+ *
+ * RETURN:      Pointer to the current walk state
+ *
+ * DESCRIPTION: Get the walk state that is at the head of the list (the "current"
+ *              walk state.)
+ *
+ ******************************************************************************/
+
+struct acpi_walk_state *acpi_ds_get_current_walk_state(struct acpi_thread_state
+						       *thread)
+{
+	ACPI_FUNCTION_NAME(ds_get_current_walk_state);
+
+	if (!thread) {
+		return (NULL);
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_PARSE, "Current WalkState %p\n",
+			  thread->walk_state_list));
+
+	return (thread->walk_state_list);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_push_walk_state
+ *
+ * PARAMETERS:  walk_state      - State to push
+ *              Thread          - Thread state object
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Place the Thread state at the head of the state list
+ *
+ ******************************************************************************/
+
+void
+acpi_ds_push_walk_state(struct acpi_walk_state *walk_state,
+			struct acpi_thread_state *thread)
+{
+	ACPI_FUNCTION_TRACE(ds_push_walk_state);
+
+	walk_state->next = thread->walk_state_list;
+	thread->walk_state_list = walk_state;
+
+	return_VOID;
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_pop_walk_state
+ *
+ * PARAMETERS:  Thread      - Current thread state
+ *
+ * RETURN:      A walk_state object popped from the thread's stack
+ *
+ * DESCRIPTION: Remove and return the walkstate object that is at the head of
+ *              the walk stack for the given walk list.  NULL indicates that
+ *              the list is empty.
+ *
+ ******************************************************************************/
+
+struct acpi_walk_state *acpi_ds_pop_walk_state(struct acpi_thread_state *thread)
+{
+	struct acpi_walk_state *walk_state;
+
+	ACPI_FUNCTION_TRACE(ds_pop_walk_state);
+
+	walk_state = thread->walk_state_list;
+
+	if (walk_state) {
+
+		/* Next walk state becomes the current walk state */
+
+		thread->walk_state_list = walk_state->next;
+
+		/*
+		 * Don't clear the NEXT field, this serves as an indicator
+		 * that there is a parent WALK STATE
+		 * Do Not: walk_state->Next = NULL;
+		 */
+	}
+
+	return_PTR(walk_state);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_create_walk_state
+ *
+ * PARAMETERS:  owner_id        - ID for object creation
+ *              Origin          - Starting point for this walk
+ *              method_desc     - Method object
+ *              Thread          - Current thread state
+ *
+ * RETURN:      Pointer to the new walk state.
+ *
+ * DESCRIPTION: Allocate and initialize a new walk state.  The current walk
+ *              state is set to this new state.
+ *
+ ******************************************************************************/
+
+struct acpi_walk_state *acpi_ds_create_walk_state(acpi_owner_id owner_id,
+						  union acpi_parse_object
+						  *origin,
+						  union acpi_operand_object
+						  *method_desc,
+						  struct acpi_thread_state
+						  *thread)
+{
+	struct acpi_walk_state *walk_state;
+
+	ACPI_FUNCTION_TRACE(ds_create_walk_state);
+
+	walk_state = ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_walk_state));
+	if (!walk_state) {
+		return_PTR(NULL);
+	}
+
+	walk_state->descriptor_type = ACPI_DESC_TYPE_WALK;
+	walk_state->method_desc = method_desc;
+	walk_state->owner_id = owner_id;
+	walk_state->origin = origin;
+	walk_state->thread = thread;
+
+	walk_state->parser_state.start_op = origin;
+
+	/* Init the method args/local */
+
+#if (!defined (ACPI_NO_METHOD_EXECUTION) && !defined (ACPI_CONSTANT_EVAL_ONLY))
+	acpi_ds_method_data_init(walk_state);
+#endif
+
+	/* Put the new state at the head of the walk list */
+
+	if (thread) {
+		acpi_ds_push_walk_state(walk_state, thread);
+	}
+
+	return_PTR(walk_state);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_init_aml_walk
+ *
+ * PARAMETERS:  walk_state      - New state to be initialized
+ *              Op              - Current parse op
+ *              method_node     - Control method NS node, if any
+ *              aml_start       - Start of AML
+ *              aml_length      - Length of AML
+ *              Info            - Method info block (params, etc.)
+ *              pass_number     - 1, 2, or 3
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Initialize a walk state for a pass 1 or 2 parse tree walk
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ds_init_aml_walk(struct acpi_walk_state *walk_state,
+		      union acpi_parse_object *op,
+		      struct acpi_namespace_node *method_node,
+		      u8 *aml_start,
+		      u32 aml_length,
+		      struct acpi_evaluate_info *info, u8 pass_number)
+{
+	acpi_status status;
+	struct acpi_parse_state *parser_state = &walk_state->parser_state;
+	union acpi_parse_object *extra_op;
+
+	ACPI_FUNCTION_TRACE(ds_init_aml_walk);
+
+	walk_state->parser_state.aml =
+	    walk_state->parser_state.aml_start = aml_start;
+	walk_state->parser_state.aml_end =
+	    walk_state->parser_state.pkg_end = aml_start + aml_length;
+
+	/* The next_op of the next_walk will be the beginning of the method */
+
+	walk_state->next_op = NULL;
+	walk_state->pass_number = pass_number;
+
+	if (info) {
+		walk_state->params = info->parameters;
+		walk_state->caller_return_desc = &info->return_object;
+	}
+
+	status = acpi_ps_init_scope(&walk_state->parser_state, op);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	if (method_node) {
+		walk_state->parser_state.start_node = method_node;
+		walk_state->walk_type = ACPI_WALK_METHOD;
+		walk_state->method_node = method_node;
+		walk_state->method_desc =
+		    acpi_ns_get_attached_object(method_node);
+
+		/* Push start scope on scope stack and make it current  */
+
+		status =
+		    acpi_ds_scope_stack_push(method_node, ACPI_TYPE_METHOD,
+					     walk_state);
+		if (ACPI_FAILURE(status)) {
+			return_ACPI_STATUS(status);
+		}
+
+		/* Init the method arguments */
+
+		status = acpi_ds_method_data_init_args(walk_state->params,
+						       ACPI_METHOD_NUM_ARGS,
+						       walk_state);
+		if (ACPI_FAILURE(status)) {
+			return_ACPI_STATUS(status);
+		}
+	} else {
+		/*
+		 * Setup the current scope.
+		 * Find a Named Op that has a namespace node associated with it.
+		 * search upwards from this Op.  Current scope is the first
+		 * Op with a namespace node.
+		 */
+		extra_op = parser_state->start_op;
+		while (extra_op && !extra_op->common.node) {
+			extra_op = extra_op->common.parent;
+		}
+
+		if (!extra_op) {
+			parser_state->start_node = NULL;
+		} else {
+			parser_state->start_node = extra_op->common.node;
+		}
+
+		if (parser_state->start_node) {
+
+			/* Push start scope on scope stack and make it current  */
+
+			status =
+			    acpi_ds_scope_stack_push(parser_state->start_node,
+						     parser_state->start_node->
+						     type, walk_state);
+			if (ACPI_FAILURE(status)) {
+				return_ACPI_STATUS(status);
+			}
+		}
+	}
+
+	status = acpi_ds_init_callbacks(walk_state, pass_number);
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_delete_walk_state
+ *
+ * PARAMETERS:  walk_state      - State to delete
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Delete a walk state including all internal data structures
+ *
+ ******************************************************************************/
+
+void acpi_ds_delete_walk_state(struct acpi_walk_state *walk_state)
+{
+	union acpi_generic_state *state;
+
+	ACPI_FUNCTION_TRACE_PTR(ds_delete_walk_state, walk_state);
+
+	if (!walk_state) {
+		return;
+	}
+
+	if (walk_state->descriptor_type != ACPI_DESC_TYPE_WALK) {
+		ACPI_ERROR((AE_INFO, "%p is not a valid walk state",
+			    walk_state));
+		return;
+	}
+
+	/* There should not be any open scopes */
+
+	if (walk_state->parser_state.scope) {
+		ACPI_ERROR((AE_INFO, "%p walk still has a scope list",
+			    walk_state));
+		acpi_ps_cleanup_scope(&walk_state->parser_state);
+	}
+
+	/* Always must free any linked control states */
+
+	while (walk_state->control_state) {
+		state = walk_state->control_state;
+		walk_state->control_state = state->common.next;
+
+		acpi_ut_delete_generic_state(state);
+	}
+
+	/* Always must free any linked parse states */
+
+	while (walk_state->scope_info) {
+		state = walk_state->scope_info;
+		walk_state->scope_info = state->common.next;
+
+		acpi_ut_delete_generic_state(state);
+	}
+
+	/* Always must free any stacked result states */
+
+	while (walk_state->results) {
+		state = walk_state->results;
+		walk_state->results = state->common.next;
+
+		acpi_ut_delete_generic_state(state);
+	}
+
+	ACPI_FREE(walk_state);
+	return_VOID;
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/evevent.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/evevent.c
new file mode 100644
index 00000000..6729ebe2
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/evevent.c
@@ -0,0 +1,293 @@
+/******************************************************************************
+ *
+ * Module Name: evevent - Fixed Event handling and dispatch
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acevents.h"
+
+#define _COMPONENT          ACPI_EVENTS
+ACPI_MODULE_NAME("evevent")
+
+/* Local prototypes */
+static acpi_status acpi_ev_fixed_event_initialize(void);
+
+static u32 acpi_ev_fixed_event_dispatch(u32 event);
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_initialize_events
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Initialize global data structures for ACPI events (Fixed, GPE)
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ev_initialize_events(void)
+{
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(ev_initialize_events);
+
+	/* If Hardware Reduced flag is set, there are no fixed events */
+
+	if (acpi_gbl_reduced_hardware) {
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	/*
+	 * Initialize the Fixed and General Purpose Events. This is done prior to
+	 * enabling SCIs to prevent interrupts from occurring before the handlers
+	 * are installed.
+	 */
+	status = acpi_ev_fixed_event_initialize();
+	if (ACPI_FAILURE(status)) {
+		ACPI_EXCEPTION((AE_INFO, status,
+				"Unable to initialize fixed events"));
+		return_ACPI_STATUS(status);
+	}
+
+	status = acpi_ev_gpe_initialize();
+	if (ACPI_FAILURE(status)) {
+		ACPI_EXCEPTION((AE_INFO, status,
+				"Unable to initialize general purpose events"));
+		return_ACPI_STATUS(status);
+	}
+
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_install_xrupt_handlers
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Install interrupt handlers for the SCI and Global Lock
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ev_install_xrupt_handlers(void)
+{
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(ev_install_xrupt_handlers);
+
+	/* If Hardware Reduced flag is set, there is no ACPI h/w */
+
+	if (acpi_gbl_reduced_hardware) {
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	/* Install the SCI handler */
+
+	status = acpi_ev_install_sci_handler();
+	if (ACPI_FAILURE(status)) {
+		ACPI_EXCEPTION((AE_INFO, status,
+				"Unable to install System Control Interrupt handler"));
+		return_ACPI_STATUS(status);
+	}
+
+	/* Install the handler for the Global Lock */
+
+	status = acpi_ev_init_global_lock_handler();
+	if (ACPI_FAILURE(status)) {
+		ACPI_EXCEPTION((AE_INFO, status,
+				"Unable to initialize Global Lock handler"));
+		return_ACPI_STATUS(status);
+	}
+
+	acpi_gbl_events_initialized = TRUE;
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_fixed_event_initialize
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Install the fixed event handlers and disable all fixed events.
+ *
+ ******************************************************************************/
+
+static acpi_status acpi_ev_fixed_event_initialize(void)
+{
+	u32 i;
+	acpi_status status;
+
+	/*
+	 * Initialize the structure that keeps track of fixed event handlers and
+	 * enable the fixed events.
+	 */
+	for (i = 0; i < ACPI_NUM_FIXED_EVENTS; i++) {
+		acpi_gbl_fixed_event_handlers[i].handler = NULL;
+		acpi_gbl_fixed_event_handlers[i].context = NULL;
+
+		/* Disable the fixed event */
+
+		if (acpi_gbl_fixed_event_info[i].enable_register_id != 0xFF) {
+			status =
+			    acpi_write_bit_register(acpi_gbl_fixed_event_info
+						    [i].enable_register_id,
+						    ACPI_DISABLE_EVENT);
+			if (ACPI_FAILURE(status)) {
+				return (status);
+			}
+		}
+	}
+
+	return (AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_fixed_event_detect
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      INTERRUPT_HANDLED or INTERRUPT_NOT_HANDLED
+ *
+ * DESCRIPTION: Checks the PM status register for active fixed events
+ *
+ ******************************************************************************/
+
+u32 acpi_ev_fixed_event_detect(void)
+{
+	u32 int_status = ACPI_INTERRUPT_NOT_HANDLED;
+	u32 fixed_status;
+	u32 fixed_enable;
+	u32 i;
+
+	ACPI_FUNCTION_NAME(ev_fixed_event_detect);
+
+	/*
+	 * Read the fixed feature status and enable registers, as all the cases
+	 * depend on their values. Ignore errors here.
+	 */
+	(void)acpi_hw_register_read(ACPI_REGISTER_PM1_STATUS, &fixed_status);
+	(void)acpi_hw_register_read(ACPI_REGISTER_PM1_ENABLE, &fixed_enable);
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INTERRUPTS,
+			  "Fixed Event Block: Enable %08X Status %08X\n",
+			  fixed_enable, fixed_status));
+
+	/*
+	 * Check for all possible Fixed Events and dispatch those that are active
+	 */
+	for (i = 0; i < ACPI_NUM_FIXED_EVENTS; i++) {
+
+		/* Both the status and enable bits must be on for this event */
+
+		if ((fixed_status & acpi_gbl_fixed_event_info[i].
+		     status_bit_mask)
+		    && (fixed_enable & acpi_gbl_fixed_event_info[i].
+			enable_bit_mask)) {
+			/*
+			 * Found an active (signalled) event. Invoke global event
+			 * handler if present.
+			 */
+			acpi_fixed_event_count[i]++;
+			if (acpi_gbl_global_event_handler) {
+				acpi_gbl_global_event_handler
+				    (ACPI_EVENT_TYPE_FIXED, NULL, i,
+				     acpi_gbl_global_event_handler_context);
+			}
+
+			int_status |= acpi_ev_fixed_event_dispatch(i);
+		}
+	}
+
+	return (int_status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_fixed_event_dispatch
+ *
+ * PARAMETERS:  Event               - Event type
+ *
+ * RETURN:      INTERRUPT_HANDLED or INTERRUPT_NOT_HANDLED
+ *
+ * DESCRIPTION: Clears the status bit for the requested event, calls the
+ *              handler that previously registered for the event.
+ *
+ ******************************************************************************/
+
+static u32 acpi_ev_fixed_event_dispatch(u32 event)
+{
+
+	ACPI_FUNCTION_ENTRY();
+
+	/* Clear the status bit */
+
+	(void)acpi_write_bit_register(acpi_gbl_fixed_event_info[event].
+				      status_register_id, ACPI_CLEAR_STATUS);
+
+	/*
+	 * Make sure we've got a handler. If not, report an error. The event is
+	 * disabled to prevent further interrupts.
+	 */
+	if (NULL == acpi_gbl_fixed_event_handlers[event].handler) {
+		(void)acpi_write_bit_register(acpi_gbl_fixed_event_info[event].
+					      enable_register_id,
+					      ACPI_DISABLE_EVENT);
+
+		ACPI_ERROR((AE_INFO,
+			    "No installed handler for fixed event [0x%08X]",
+			    event));
+
+		return (ACPI_INTERRUPT_NOT_HANDLED);
+	}
+
+	/* Invoke the Fixed Event handler */
+
+	return ((acpi_gbl_fixed_event_handlers[event].
+		 handler) (acpi_gbl_fixed_event_handlers[event].context));
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/evglock.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/evglock.c
new file mode 100644
index 00000000..5e5683cb
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/evglock.c
@@ -0,0 +1,341 @@
+/******************************************************************************
+ *
+ * Module Name: evglock - Global Lock support
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acevents.h"
+#include "acinterp.h"
+
+#define _COMPONENT          ACPI_EVENTS
+ACPI_MODULE_NAME("evglock")
+
+/* Local prototypes */
+static u32 acpi_ev_global_lock_handler(void *context);
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_init_global_lock_handler
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Install a handler for the global lock release event
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ev_init_global_lock_handler(void)
+{
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(ev_init_global_lock_handler);
+
+	/* If Hardware Reduced flag is set, there is no global lock */
+
+	if (acpi_gbl_reduced_hardware) {
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	/* Attempt installation of the global lock handler */
+
+	status = acpi_install_fixed_event_handler(ACPI_EVENT_GLOBAL,
+						  acpi_ev_global_lock_handler,
+						  NULL);
+
+	/*
+	 * If the global lock does not exist on this platform, the attempt to
+	 * enable GBL_STATUS will fail (the GBL_ENABLE bit will not stick).
+	 * Map to AE_OK, but mark global lock as not present. Any attempt to
+	 * actually use the global lock will be flagged with an error.
+	 */
+	acpi_gbl_global_lock_present = FALSE;
+	if (status == AE_NO_HARDWARE_RESPONSE) {
+		ACPI_ERROR((AE_INFO,
+			    "No response from Global Lock hardware, disabling lock"));
+
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	status = acpi_os_create_lock(&acpi_gbl_global_lock_pending_lock);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	acpi_gbl_global_lock_pending = FALSE;
+	acpi_gbl_global_lock_present = TRUE;
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_remove_global_lock_handler
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Remove the handler for the Global Lock
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ev_remove_global_lock_handler(void)
+{
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(ev_remove_global_lock_handler);
+
+	acpi_gbl_global_lock_present = FALSE;
+	status = acpi_remove_fixed_event_handler(ACPI_EVENT_GLOBAL,
+						 acpi_ev_global_lock_handler);
+
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_global_lock_handler
+ *
+ * PARAMETERS:  Context         - From thread interface, not used
+ *
+ * RETURN:      ACPI_INTERRUPT_HANDLED
+ *
+ * DESCRIPTION: Invoked directly from the SCI handler when a global lock
+ *              release interrupt occurs. If there is actually a pending
+ *              request for the lock, signal the waiting thread.
+ *
+ ******************************************************************************/
+
+static u32 acpi_ev_global_lock_handler(void *context)
+{
+	acpi_status status;
+	acpi_cpu_flags flags;
+
+	flags = acpi_os_acquire_lock(acpi_gbl_global_lock_pending_lock);
+
+	/*
+	 * If a request for the global lock is not actually pending,
+	 * we are done. This handles "spurious" global lock interrupts
+	 * which are possible (and have been seen) with bad BIOSs.
+	 */
+	if (!acpi_gbl_global_lock_pending) {
+		goto cleanup_and_exit;
+	}
+
+	/*
+	 * Send a unit to the global lock semaphore. The actual acquisition
+	 * of the global lock will be performed by the waiting thread.
+	 */
+	status = acpi_os_signal_semaphore(acpi_gbl_global_lock_semaphore, 1);
+	if (ACPI_FAILURE(status)) {
+		ACPI_ERROR((AE_INFO, "Could not signal Global Lock semaphore"));
+	}
+
+	acpi_gbl_global_lock_pending = FALSE;
+
+      cleanup_and_exit:
+
+	acpi_os_release_lock(acpi_gbl_global_lock_pending_lock, flags);
+	return (ACPI_INTERRUPT_HANDLED);
+}
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_acquire_global_lock
+ *
+ * PARAMETERS:  Timeout         - Max time to wait for the lock, in millisec.
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Attempt to gain ownership of the Global Lock.
+ *
+ * MUTEX:       Interpreter must be locked
+ *
+ * Note: The original implementation allowed multiple threads to "acquire" the
+ * Global Lock, and the OS would hold the lock until the last thread had
+ * released it. However, this could potentially starve the BIOS out of the
+ * lock, especially in the case where there is a tight handshake between the
+ * Embedded Controller driver and the BIOS. Therefore, this implementation
+ * allows only one thread to acquire the HW Global Lock at a time, and makes
+ * the global lock appear as a standard mutex on the OS side.
+ *
+ *****************************************************************************/
+
+acpi_status acpi_ev_acquire_global_lock(u16 timeout)
+{
+	acpi_cpu_flags flags;
+	acpi_status status;
+	u8 acquired = FALSE;
+
+	ACPI_FUNCTION_TRACE(ev_acquire_global_lock);
+
+	/*
+	 * Only one thread can acquire the GL at a time, the global_lock_mutex
+	 * enforces this. This interface releases the interpreter if we must wait.
+	 */
+	status =
+	    acpi_ex_system_wait_mutex(acpi_gbl_global_lock_mutex->mutex.
+				      os_mutex, timeout);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/*
+	 * Update the global lock handle and check for wraparound. The handle is
+	 * only used for the external global lock interfaces, but it is updated
+	 * here to properly handle the case where a single thread may acquire the
+	 * lock via both the AML and the acpi_acquire_global_lock interfaces. The
+	 * handle is therefore updated on the first acquire from a given thread
+	 * regardless of where the acquisition request originated.
+	 */
+	acpi_gbl_global_lock_handle++;
+	if (acpi_gbl_global_lock_handle == 0) {
+		acpi_gbl_global_lock_handle = 1;
+	}
+
+	/*
+	 * Make sure that a global lock actually exists. If not, just
+	 * treat the lock as a standard mutex.
+	 */
+	if (!acpi_gbl_global_lock_present) {
+		acpi_gbl_global_lock_acquired = TRUE;
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	flags = acpi_os_acquire_lock(acpi_gbl_global_lock_pending_lock);
+
+	do {
+
+		/* Attempt to acquire the actual hardware lock */
+
+		ACPI_ACQUIRE_GLOBAL_LOCK(acpi_gbl_FACS, acquired);
+		if (acquired) {
+			acpi_gbl_global_lock_acquired = TRUE;
+			ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
+					  "Acquired hardware Global Lock\n"));
+			break;
+		}
+
+		/*
+		 * Did not get the lock. The pending bit was set above, and
+		 * we must now wait until we receive the global lock
+		 * released interrupt.
+		 */
+		acpi_gbl_global_lock_pending = TRUE;
+		acpi_os_release_lock(acpi_gbl_global_lock_pending_lock, flags);
+
+		ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
+				  "Waiting for hardware Global Lock\n"));
+
+		/*
+		 * Wait for handshake with the global lock interrupt handler.
+		 * This interface releases the interpreter if we must wait.
+		 */
+		status =
+		    acpi_ex_system_wait_semaphore
+		    (acpi_gbl_global_lock_semaphore, ACPI_WAIT_FOREVER);
+
+		flags = acpi_os_acquire_lock(acpi_gbl_global_lock_pending_lock);
+
+	} while (ACPI_SUCCESS(status));
+
+	acpi_gbl_global_lock_pending = FALSE;
+	acpi_os_release_lock(acpi_gbl_global_lock_pending_lock, flags);
+
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_release_global_lock
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Releases ownership of the Global Lock.
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ev_release_global_lock(void)
+{
+	u8 pending = FALSE;
+	acpi_status status = AE_OK;
+
+	ACPI_FUNCTION_TRACE(ev_release_global_lock);
+
+	/* Lock must be already acquired */
+
+	if (!acpi_gbl_global_lock_acquired) {
+		ACPI_WARNING((AE_INFO,
+			      "Cannot release the ACPI Global Lock, it has not been acquired"));
+		return_ACPI_STATUS(AE_NOT_ACQUIRED);
+	}
+
+	if (acpi_gbl_global_lock_present) {
+
+		/* Allow any thread to release the lock */
+
+		ACPI_RELEASE_GLOBAL_LOCK(acpi_gbl_FACS, pending);
+
+		/*
+		 * If the pending bit was set, we must write GBL_RLS to the control
+		 * register
+		 */
+		if (pending) {
+			status =
+			    acpi_write_bit_register
+			    (ACPI_BITREG_GLOBAL_LOCK_RELEASE,
+			     ACPI_ENABLE_EVENT);
+		}
+
+		ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
+				  "Released hardware Global Lock\n"));
+	}
+
+	acpi_gbl_global_lock_acquired = FALSE;
+
+	/* Release the local GL mutex */
+
+	acpi_os_release_mutex(acpi_gbl_global_lock_mutex->mutex.os_mutex);
+	return_ACPI_STATUS(status);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/evgpe.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/evgpe.c
new file mode 100644
index 00000000..f9cb3c89
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/evgpe.c
@@ -0,0 +1,757 @@
+/******************************************************************************
+ *
+ * Module Name: evgpe - General Purpose Event handling and dispatch
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acevents.h"
+#include "acnamesp.h"
+
+#define _COMPONENT          ACPI_EVENTS
+ACPI_MODULE_NAME("evgpe")
+
+/* Local prototypes */
+static void ACPI_SYSTEM_XFACE acpi_ev_asynch_execute_gpe_method(void *context);
+
+static void ACPI_SYSTEM_XFACE acpi_ev_asynch_enable_gpe(void *context);
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_update_gpe_enable_mask
+ *
+ * PARAMETERS:  gpe_event_info          - GPE to update
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Updates GPE register enable mask based upon whether there are
+ *              runtime references to this GPE
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ev_update_gpe_enable_mask(struct acpi_gpe_event_info *gpe_event_info)
+{
+	struct acpi_gpe_register_info *gpe_register_info;
+	u32 register_bit;
+
+	ACPI_FUNCTION_TRACE(ev_update_gpe_enable_mask);
+
+	gpe_register_info = gpe_event_info->register_info;
+	if (!gpe_register_info) {
+		return_ACPI_STATUS(AE_NOT_EXIST);
+	}
+
+	register_bit =
+	    acpi_hw_get_gpe_register_bit(gpe_event_info, gpe_register_info);
+
+	/* Clear the run bit up front */
+
+	ACPI_CLEAR_BIT(gpe_register_info->enable_for_run, register_bit);
+
+	/* Set the mask bit only if there are references to this GPE */
+
+	if (gpe_event_info->runtime_count) {
+		ACPI_SET_BIT(gpe_register_info->enable_for_run,
+			     (u8)register_bit);
+	}
+
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_enable_gpe
+ *
+ * PARAMETERS:  gpe_event_info          - GPE to enable
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Clear a GPE of stale events and enable it.
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ev_enable_gpe(struct acpi_gpe_event_info *gpe_event_info)
+{
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(ev_enable_gpe);
+
+	/*
+	 * We will only allow a GPE to be enabled if it has either an associated
+	 * method (_Lxx/_Exx) or a handler, or is using the implicit notify
+	 * feature. Otherwise, the GPE will be immediately disabled by
+	 * acpi_ev_gpe_dispatch the first time it fires.
+	 */
+	if ((gpe_event_info->flags & ACPI_GPE_DISPATCH_MASK) ==
+	    ACPI_GPE_DISPATCH_NONE) {
+		return_ACPI_STATUS(AE_NO_HANDLER);
+	}
+
+	/* Clear the GPE (of stale events) */
+
+	status = acpi_hw_clear_gpe(gpe_event_info);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/* Enable the requested GPE */
+
+	status = acpi_hw_low_set_gpe(gpe_event_info, ACPI_GPE_ENABLE);
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_add_gpe_reference
+ *
+ * PARAMETERS:  gpe_event_info          - Add a reference to this GPE
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Add a reference to a GPE. On the first reference, the GPE is
+ *              hardware-enabled.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ev_add_gpe_reference(struct acpi_gpe_event_info *gpe_event_info)
+{
+	acpi_status status = AE_OK;
+
+	ACPI_FUNCTION_TRACE(ev_add_gpe_reference);
+
+	if (gpe_event_info->runtime_count == ACPI_UINT8_MAX) {
+		return_ACPI_STATUS(AE_LIMIT);
+	}
+
+	gpe_event_info->runtime_count++;
+	if (gpe_event_info->runtime_count == 1) {
+
+		/* Enable on first reference */
+
+		status = acpi_ev_update_gpe_enable_mask(gpe_event_info);
+		if (ACPI_SUCCESS(status)) {
+			status = acpi_ev_enable_gpe(gpe_event_info);
+		}
+
+		if (ACPI_FAILURE(status)) {
+			gpe_event_info->runtime_count--;
+		}
+	}
+
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_remove_gpe_reference
+ *
+ * PARAMETERS:  gpe_event_info          - Remove a reference to this GPE
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Remove a reference to a GPE. When the last reference is
+ *              removed, the GPE is hardware-disabled.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ev_remove_gpe_reference(struct acpi_gpe_event_info *gpe_event_info)
+{
+	acpi_status status = AE_OK;
+
+	ACPI_FUNCTION_TRACE(ev_remove_gpe_reference);
+
+	if (!gpe_event_info->runtime_count) {
+		return_ACPI_STATUS(AE_LIMIT);
+	}
+
+	gpe_event_info->runtime_count--;
+	if (!gpe_event_info->runtime_count) {
+
+		/* Disable on last reference */
+
+		status = acpi_ev_update_gpe_enable_mask(gpe_event_info);
+		if (ACPI_SUCCESS(status)) {
+			status =
+			    acpi_hw_low_set_gpe(gpe_event_info,
+						ACPI_GPE_DISABLE);
+		}
+
+		if (ACPI_FAILURE(status)) {
+			gpe_event_info->runtime_count++;
+		}
+	}
+
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_low_get_gpe_info
+ *
+ * PARAMETERS:  gpe_number          - Raw GPE number
+ *              gpe_block           - A GPE info block
+ *
+ * RETURN:      A GPE event_info struct. NULL if not a valid GPE (The gpe_number
+ *              is not within the specified GPE block)
+ *
+ * DESCRIPTION: Returns the event_info struct associated with this GPE. This is
+ *              the low-level implementation of ev_get_gpe_event_info.
+ *
+ ******************************************************************************/
+
+struct acpi_gpe_event_info *acpi_ev_low_get_gpe_info(u32 gpe_number,
+						     struct acpi_gpe_block_info
+						     *gpe_block)
+{
+	u32 gpe_index;
+
+	/*
+	 * Validate that the gpe_number is within the specified gpe_block.
+	 * (Two steps)
+	 */
+	if (!gpe_block || (gpe_number < gpe_block->block_base_number)) {
+		return (NULL);
+	}
+
+	gpe_index = gpe_number - gpe_block->block_base_number;
+	if (gpe_index >= gpe_block->gpe_count) {
+		return (NULL);
+	}
+
+	return (&gpe_block->event_info[gpe_index]);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_get_gpe_event_info
+ *
+ * PARAMETERS:  gpe_device          - Device node. NULL for GPE0/GPE1
+ *              gpe_number          - Raw GPE number
+ *
+ * RETURN:      A GPE event_info struct. NULL if not a valid GPE
+ *
+ * DESCRIPTION: Returns the event_info struct associated with this GPE.
+ *              Validates the gpe_block and the gpe_number
+ *
+ *              Should be called only when the GPE lists are semaphore locked
+ *              and not subject to change.
+ *
+ ******************************************************************************/
+
+struct acpi_gpe_event_info *acpi_ev_get_gpe_event_info(acpi_handle gpe_device,
+						       u32 gpe_number)
+{
+	union acpi_operand_object *obj_desc;
+	struct acpi_gpe_event_info *gpe_info;
+	u32 i;
+
+	ACPI_FUNCTION_ENTRY();
+
+	/* A NULL gpe_device means use the FADT-defined GPE block(s) */
+
+	if (!gpe_device) {
+
+		/* Examine GPE Block 0 and 1 (These blocks are permanent) */
+
+		for (i = 0; i < ACPI_MAX_GPE_BLOCKS; i++) {
+			gpe_info = acpi_ev_low_get_gpe_info(gpe_number,
+							    acpi_gbl_gpe_fadt_blocks
+							    [i]);
+			if (gpe_info) {
+				return (gpe_info);
+			}
+		}
+
+		/* The gpe_number was not in the range of either FADT GPE block */
+
+		return (NULL);
+	}
+
+	/* A Non-NULL gpe_device means this is a GPE Block Device */
+
+	obj_desc =
+	    acpi_ns_get_attached_object((struct acpi_namespace_node *)
+					gpe_device);
+	if (!obj_desc || !obj_desc->device.gpe_block) {
+		return (NULL);
+	}
+
+	return (acpi_ev_low_get_gpe_info
+		(gpe_number, obj_desc->device.gpe_block));
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_gpe_detect
+ *
+ * PARAMETERS:  gpe_xrupt_list      - Interrupt block for this interrupt.
+ *                                    Can have multiple GPE blocks attached.
+ *
+ * RETURN:      INTERRUPT_HANDLED or INTERRUPT_NOT_HANDLED
+ *
+ * DESCRIPTION: Detect if any GP events have occurred. This function is
+ *              executed at interrupt level.
+ *
+ ******************************************************************************/
+
+u32 acpi_ev_gpe_detect(struct acpi_gpe_xrupt_info *gpe_xrupt_list)
+{
+	acpi_status status;
+	struct acpi_gpe_block_info *gpe_block;
+	struct acpi_gpe_register_info *gpe_register_info;
+	u32 int_status = ACPI_INTERRUPT_NOT_HANDLED;
+	u8 enabled_status_byte;
+	u32 status_reg;
+	u32 enable_reg;
+	acpi_cpu_flags flags;
+	u32 i;
+	u32 j;
+
+	ACPI_FUNCTION_NAME(ev_gpe_detect);
+
+	/* Check for the case where there are no GPEs */
+
+	if (!gpe_xrupt_list) {
+		return (int_status);
+	}
+
+	/*
+	 * We need to obtain the GPE lock for both the data structs and registers
+	 * Note: Not necessary to obtain the hardware lock, since the GPE
+	 * registers are owned by the gpe_lock.
+	 */
+	flags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);
+
+	/* Examine all GPE blocks attached to this interrupt level */
+
+	gpe_block = gpe_xrupt_list->gpe_block_list_head;
+	while (gpe_block) {
+		/*
+		 * Read all of the 8-bit GPE status and enable registers in this GPE
+		 * block, saving all of them. Find all currently active GP events.
+		 */
+		for (i = 0; i < gpe_block->register_count; i++) {
+
+			/* Get the next status/enable pair */
+
+			gpe_register_info = &gpe_block->register_info[i];
+
+			/*
+			 * Optimization: If there are no GPEs enabled within this
+			 * register, we can safely ignore the entire register.
+			 */
+			if (!(gpe_register_info->enable_for_run |
+			      gpe_register_info->enable_for_wake)) {
+				continue;
+			}
+
+			/* Read the Status Register */
+
+			status =
+			    acpi_hw_read(&status_reg,
+					 &gpe_register_info->status_address);
+			if (ACPI_FAILURE(status)) {
+				goto unlock_and_exit;
+			}
+
+			/* Read the Enable Register */
+
+			status =
+			    acpi_hw_read(&enable_reg,
+					 &gpe_register_info->enable_address);
+			if (ACPI_FAILURE(status)) {
+				goto unlock_and_exit;
+			}
+
+			ACPI_DEBUG_PRINT((ACPI_DB_INTERRUPTS,
+					  "Read GPE Register at GPE%02X: Status=%02X, Enable=%02X\n",
+					  gpe_register_info->base_gpe_number,
+					  status_reg, enable_reg));
+
+			/* Check if there is anything active at all in this register */
+
+			enabled_status_byte = (u8)(status_reg & enable_reg);
+			if (!enabled_status_byte) {
+
+				/* No active GPEs in this register, move on */
+
+				continue;
+			}
+
+			/* Now look at the individual GPEs in this byte register */
+
+			for (j = 0; j < ACPI_GPE_REGISTER_WIDTH; j++) {
+
+				/* Examine one GPE bit */
+
+				if (enabled_status_byte & (1 << j)) {
+					/*
+					 * Found an active GPE. Dispatch the event to a handler
+					 * or method.
+					 */
+					int_status |=
+					    acpi_ev_gpe_dispatch(gpe_block->
+								 node,
+								 &gpe_block->
+								 event_info[((acpi_size) i * ACPI_GPE_REGISTER_WIDTH) + j], j + gpe_register_info->base_gpe_number);
+				}
+			}
+		}
+
+		gpe_block = gpe_block->next;
+	}
+
+      unlock_and_exit:
+
+	acpi_os_release_lock(acpi_gbl_gpe_lock, flags);
+	return (int_status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_asynch_execute_gpe_method
+ *
+ * PARAMETERS:  Context (gpe_event_info) - Info for this GPE
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Perform the actual execution of a GPE control method. This
+ *              function is called from an invocation of acpi_os_execute and
+ *              therefore does NOT execute at interrupt level - so that
+ *              the control method itself is not executed in the context of
+ *              an interrupt handler.
+ *
+ ******************************************************************************/
+
+static void ACPI_SYSTEM_XFACE acpi_ev_asynch_execute_gpe_method(void *context)
+{
+	struct acpi_gpe_event_info *gpe_event_info = context;
+	acpi_status status;
+	struct acpi_gpe_event_info *local_gpe_event_info;
+	struct acpi_evaluate_info *info;
+
+	ACPI_FUNCTION_TRACE(ev_asynch_execute_gpe_method);
+
+	/* Allocate a local GPE block */
+
+	local_gpe_event_info =
+	    ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_gpe_event_info));
+	if (!local_gpe_event_info) {
+		ACPI_EXCEPTION((AE_INFO, AE_NO_MEMORY, "while handling a GPE"));
+		return_VOID;
+	}
+
+	status = acpi_ut_acquire_mutex(ACPI_MTX_EVENTS);
+	if (ACPI_FAILURE(status)) {
+		return_VOID;
+	}
+
+	/* Must revalidate the gpe_number/gpe_block */
+
+	if (!acpi_ev_valid_gpe_event(gpe_event_info)) {
+		status = acpi_ut_release_mutex(ACPI_MTX_EVENTS);
+		return_VOID;
+	}
+
+	/*
+	 * Take a snapshot of the GPE info for this level - we copy the info to
+	 * prevent a race condition with remove_handler/remove_block.
+	 */
+	ACPI_MEMCPY(local_gpe_event_info, gpe_event_info,
+		    sizeof(struct acpi_gpe_event_info));
+
+	status = acpi_ut_release_mutex(ACPI_MTX_EVENTS);
+	if (ACPI_FAILURE(status)) {
+		return_VOID;
+	}
+
+	/* Do the correct dispatch - normal method or implicit notify */
+
+	switch (local_gpe_event_info->flags & ACPI_GPE_DISPATCH_MASK) {
+	case ACPI_GPE_DISPATCH_NOTIFY:
+
+		/*
+		 * Implicit notify.
+		 * Dispatch a DEVICE_WAKE notify to the appropriate handler.
+		 * NOTE: the request is queued for execution after this method
+		 * completes. The notify handlers are NOT invoked synchronously
+		 * from this thread -- because handlers may in turn run other
+		 * control methods.
+		 */
+		status =
+		    acpi_ev_queue_notify_request(local_gpe_event_info->dispatch.
+						 device_node,
+						 ACPI_NOTIFY_DEVICE_WAKE);
+		break;
+
+	case ACPI_GPE_DISPATCH_METHOD:
+
+		/* Allocate the evaluation information block */
+
+		info = ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_evaluate_info));
+		if (!info) {
+			status = AE_NO_MEMORY;
+		} else {
+			/*
+			 * Invoke the GPE Method (_Lxx, _Exx) i.e., evaluate the
+			 * _Lxx/_Exx control method that corresponds to this GPE
+			 */
+			info->prefix_node =
+			    local_gpe_event_info->dispatch.method_node;
+			info->flags = ACPI_IGNORE_RETURN_VALUE;
+
+			status = acpi_ns_evaluate(info);
+			ACPI_FREE(info);
+		}
+
+		if (ACPI_FAILURE(status)) {
+			ACPI_EXCEPTION((AE_INFO, status,
+					"while evaluating GPE method [%4.4s]",
+					acpi_ut_get_node_name
+					(local_gpe_event_info->dispatch.
+					 method_node)));
+		}
+
+		break;
+
+	default:
+		return_VOID;	/* Should never happen */
+	}
+
+	/* Defer enabling of GPE until all notify handlers are done */
+
+	status = acpi_os_execute(OSL_NOTIFY_HANDLER,
+				 acpi_ev_asynch_enable_gpe,
+				 local_gpe_event_info);
+	if (ACPI_FAILURE(status)) {
+		ACPI_FREE(local_gpe_event_info);
+	}
+	return_VOID;
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_asynch_enable_gpe
+ *
+ * PARAMETERS:  Context (gpe_event_info) - Info for this GPE
+ *              Callback from acpi_os_execute
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Asynchronous clear/enable for GPE. This allows the GPE to
+ *              complete (i.e., finish execution of Notify)
+ *
+ ******************************************************************************/
+
+static void ACPI_SYSTEM_XFACE acpi_ev_asynch_enable_gpe(void *context)
+{
+	struct acpi_gpe_event_info *gpe_event_info = context;
+
+	(void)acpi_ev_finish_gpe(gpe_event_info);
+
+	ACPI_FREE(gpe_event_info);
+	return;
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_finish_gpe
+ *
+ * PARAMETERS:  gpe_event_info      - Info for this GPE
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Clear/Enable a GPE. Common code that is used after execution
+ *              of a GPE method or a synchronous or asynchronous GPE handler.
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ev_finish_gpe(struct acpi_gpe_event_info * gpe_event_info)
+{
+	acpi_status status;
+
+	if ((gpe_event_info->flags & ACPI_GPE_XRUPT_TYPE_MASK) ==
+	    ACPI_GPE_LEVEL_TRIGGERED) {
+		/*
+		 * GPE is level-triggered, we clear the GPE status bit after
+		 * handling the event.
+		 */
+		status = acpi_hw_clear_gpe(gpe_event_info);
+		if (ACPI_FAILURE(status)) {
+			return (status);
+		}
+	}
+
+	/*
+	 * Enable this GPE, conditionally. This means that the GPE will
+	 * only be physically enabled if the enable_for_run bit is set
+	 * in the event_info.
+	 */
+	(void)acpi_hw_low_set_gpe(gpe_event_info, ACPI_GPE_CONDITIONAL_ENABLE);
+	return (AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_gpe_dispatch
+ *
+ * PARAMETERS:  gpe_device          - Device node. NULL for GPE0/GPE1
+ *              gpe_event_info      - Info for this GPE
+ *              gpe_number          - Number relative to the parent GPE block
+ *
+ * RETURN:      INTERRUPT_HANDLED or INTERRUPT_NOT_HANDLED
+ *
+ * DESCRIPTION: Dispatch a General Purpose Event to either a function (e.g. EC)
+ *              or method (e.g. _Lxx/_Exx) handler.
+ *
+ *              This function executes at interrupt level.
+ *
+ ******************************************************************************/
+
+u32
+acpi_ev_gpe_dispatch(struct acpi_namespace_node *gpe_device,
+		     struct acpi_gpe_event_info *gpe_event_info, u32 gpe_number)
+{
+	acpi_status status;
+	u32 return_value;
+
+	ACPI_FUNCTION_TRACE(ev_gpe_dispatch);
+
+	/* Invoke global event handler if present */
+
+	acpi_gpe_count++;
+	if (acpi_gbl_global_event_handler) {
+		acpi_gbl_global_event_handler(ACPI_EVENT_TYPE_GPE, gpe_device,
+					      gpe_number,
+					      acpi_gbl_global_event_handler_context);
+	}
+
+	/*
+	 * If edge-triggered, clear the GPE status bit now. Note that
+	 * level-triggered events are cleared after the GPE is serviced.
+	 */
+	if ((gpe_event_info->flags & ACPI_GPE_XRUPT_TYPE_MASK) ==
+	    ACPI_GPE_EDGE_TRIGGERED) {
+		status = acpi_hw_clear_gpe(gpe_event_info);
+		if (ACPI_FAILURE(status)) {
+			ACPI_EXCEPTION((AE_INFO, status,
+					"Unable to clear GPE%02X", gpe_number));
+			return_UINT32(ACPI_INTERRUPT_NOT_HANDLED);
+		}
+	}
+
+	/*
+	 * Always disable the GPE so that it does not keep firing before
+	 * any asynchronous activity completes (either from the execution
+	 * of a GPE method or an asynchronous GPE handler.)
+	 *
+	 * If there is no handler or method to run, just disable the
+	 * GPE and leave it disabled permanently to prevent further such
+	 * pointless events from firing.
+	 */
+	status = acpi_hw_low_set_gpe(gpe_event_info, ACPI_GPE_DISABLE);
+	if (ACPI_FAILURE(status)) {
+		ACPI_EXCEPTION((AE_INFO, status,
+				"Unable to disable GPE%02X", gpe_number));
+		return_UINT32(ACPI_INTERRUPT_NOT_HANDLED);
+	}
+
+	/*
+	 * Dispatch the GPE to either an installed handler or the control
+	 * method associated with this GPE (_Lxx or _Exx). If a handler
+	 * exists, we invoke it and do not attempt to run the method.
+	 * If there is neither a handler nor a method, leave the GPE
+	 * disabled.
+	 */
+	switch (gpe_event_info->flags & ACPI_GPE_DISPATCH_MASK) {
+	case ACPI_GPE_DISPATCH_HANDLER:
+
+		/* Invoke the installed handler (at interrupt level) */
+
+		return_value =
+		    gpe_event_info->dispatch.handler->address(gpe_device,
+							      gpe_number,
+							      gpe_event_info->
+							      dispatch.handler->
+							      context);
+
+		/* If requested, clear (if level-triggered) and reenable the GPE */
+
+		if (return_value & ACPI_REENABLE_GPE) {
+			(void)acpi_ev_finish_gpe(gpe_event_info);
+		}
+		break;
+
+	case ACPI_GPE_DISPATCH_METHOD:
+	case ACPI_GPE_DISPATCH_NOTIFY:
+
+		/*
+		 * Execute the method associated with the GPE
+		 * NOTE: Level-triggered GPEs are cleared after the method completes.
+		 */
+		status = acpi_os_execute(OSL_GPE_HANDLER,
+					 acpi_ev_asynch_execute_gpe_method,
+					 gpe_event_info);
+		if (ACPI_FAILURE(status)) {
+			ACPI_EXCEPTION((AE_INFO, status,
+					"Unable to queue handler for GPE%02X - event disabled",
+					gpe_number));
+		}
+		break;
+
+	default:
+
+		/*
+		 * No handler or method to run!
+		 * 03/2010: This case should no longer be possible. We will not allow
+		 * a GPE to be enabled if it has no handler or method.
+		 */
+		ACPI_ERROR((AE_INFO,
+			    "No handler or method for GPE%02X, disabling event",
+			    gpe_number));
+		break;
+	}
+
+	return_UINT32(ACPI_INTERRUPT_HANDLED);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/evgpeblk.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/evgpeblk.c
new file mode 100644
index 00000000..4e0281b4
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/evgpeblk.c
@@ -0,0 +1,506 @@
+/******************************************************************************
+ *
+ * Module Name: evgpeblk - GPE block creation and initialization.
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acevents.h"
+#include "acnamesp.h"
+
+#define _COMPONENT          ACPI_EVENTS
+ACPI_MODULE_NAME("evgpeblk")
+
+/* Local prototypes */
+static acpi_status
+acpi_ev_install_gpe_block(struct acpi_gpe_block_info *gpe_block,
+			  u32 interrupt_number);
+
+static acpi_status
+acpi_ev_create_gpe_info_blocks(struct acpi_gpe_block_info *gpe_block);
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_install_gpe_block
+ *
+ * PARAMETERS:  gpe_block               - New GPE block
+ *              interrupt_number        - Xrupt to be associated with this
+ *                                        GPE block
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Install new GPE block with mutex support
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ev_install_gpe_block(struct acpi_gpe_block_info *gpe_block,
+			  u32 interrupt_number)
+{
+	struct acpi_gpe_block_info *next_gpe_block;
+	struct acpi_gpe_xrupt_info *gpe_xrupt_block;
+	acpi_status status;
+	acpi_cpu_flags flags;
+
+	ACPI_FUNCTION_TRACE(ev_install_gpe_block);
+
+	status = acpi_ut_acquire_mutex(ACPI_MTX_EVENTS);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	gpe_xrupt_block = acpi_ev_get_gpe_xrupt_block(interrupt_number);
+	if (!gpe_xrupt_block) {
+		status = AE_NO_MEMORY;
+		goto unlock_and_exit;
+	}
+
+	/* Install the new block at the end of the list with lock */
+
+	flags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);
+	if (gpe_xrupt_block->gpe_block_list_head) {
+		next_gpe_block = gpe_xrupt_block->gpe_block_list_head;
+		while (next_gpe_block->next) {
+			next_gpe_block = next_gpe_block->next;
+		}
+
+		next_gpe_block->next = gpe_block;
+		gpe_block->previous = next_gpe_block;
+	} else {
+		gpe_xrupt_block->gpe_block_list_head = gpe_block;
+	}
+
+	gpe_block->xrupt_block = gpe_xrupt_block;
+	acpi_os_release_lock(acpi_gbl_gpe_lock, flags);
+
+      unlock_and_exit:
+	status = acpi_ut_release_mutex(ACPI_MTX_EVENTS);
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_delete_gpe_block
+ *
+ * PARAMETERS:  gpe_block           - Existing GPE block
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Remove a GPE block
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ev_delete_gpe_block(struct acpi_gpe_block_info *gpe_block)
+{
+	acpi_status status;
+	acpi_cpu_flags flags;
+
+	ACPI_FUNCTION_TRACE(ev_install_gpe_block);
+
+	status = acpi_ut_acquire_mutex(ACPI_MTX_EVENTS);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/* Disable all GPEs in this block */
+
+	status =
+	    acpi_hw_disable_gpe_block(gpe_block->xrupt_block, gpe_block, NULL);
+
+	if (!gpe_block->previous && !gpe_block->next) {
+
+		/* This is the last gpe_block on this interrupt */
+
+		status = acpi_ev_delete_gpe_xrupt(gpe_block->xrupt_block);
+		if (ACPI_FAILURE(status)) {
+			goto unlock_and_exit;
+		}
+	} else {
+		/* Remove the block on this interrupt with lock */
+
+		flags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);
+		if (gpe_block->previous) {
+			gpe_block->previous->next = gpe_block->next;
+		} else {
+			gpe_block->xrupt_block->gpe_block_list_head =
+			    gpe_block->next;
+		}
+
+		if (gpe_block->next) {
+			gpe_block->next->previous = gpe_block->previous;
+		}
+		acpi_os_release_lock(acpi_gbl_gpe_lock, flags);
+	}
+
+	acpi_current_gpe_count -= gpe_block->gpe_count;
+
+	/* Free the gpe_block */
+
+	ACPI_FREE(gpe_block->register_info);
+	ACPI_FREE(gpe_block->event_info);
+	ACPI_FREE(gpe_block);
+
+      unlock_and_exit:
+	status = acpi_ut_release_mutex(ACPI_MTX_EVENTS);
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_create_gpe_info_blocks
+ *
+ * PARAMETERS:  gpe_block   - New GPE block
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Create the register_info and event_info blocks for this GPE block
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ev_create_gpe_info_blocks(struct acpi_gpe_block_info *gpe_block)
+{
+	struct acpi_gpe_register_info *gpe_register_info = NULL;
+	struct acpi_gpe_event_info *gpe_event_info = NULL;
+	struct acpi_gpe_event_info *this_event;
+	struct acpi_gpe_register_info *this_register;
+	u32 i;
+	u32 j;
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(ev_create_gpe_info_blocks);
+
+	/* Allocate the GPE register information block */
+
+	gpe_register_info = ACPI_ALLOCATE_ZEROED((acpi_size) gpe_block->
+						 register_count *
+						 sizeof(struct
+							acpi_gpe_register_info));
+	if (!gpe_register_info) {
+		ACPI_ERROR((AE_INFO,
+			    "Could not allocate the GpeRegisterInfo table"));
+		return_ACPI_STATUS(AE_NO_MEMORY);
+	}
+
+	/*
+	 * Allocate the GPE event_info block. There are eight distinct GPEs
+	 * per register. Initialization to zeros is sufficient.
+	 */
+	gpe_event_info = ACPI_ALLOCATE_ZEROED((acpi_size) gpe_block->gpe_count *
+					      sizeof(struct
+						     acpi_gpe_event_info));
+	if (!gpe_event_info) {
+		ACPI_ERROR((AE_INFO,
+			    "Could not allocate the GpeEventInfo table"));
+		status = AE_NO_MEMORY;
+		goto error_exit;
+	}
+
+	/* Save the new Info arrays in the GPE block */
+
+	gpe_block->register_info = gpe_register_info;
+	gpe_block->event_info = gpe_event_info;
+
+	/*
+	 * Initialize the GPE Register and Event structures. A goal of these
+	 * tables is to hide the fact that there are two separate GPE register
+	 * sets in a given GPE hardware block, the status registers occupy the
+	 * first half, and the enable registers occupy the second half.
+	 */
+	this_register = gpe_register_info;
+	this_event = gpe_event_info;
+
+	for (i = 0; i < gpe_block->register_count; i++) {
+
+		/* Init the register_info for this GPE register (8 GPEs) */
+
+		this_register->base_gpe_number =
+		    (u8)(gpe_block->block_base_number +
+			 (i * ACPI_GPE_REGISTER_WIDTH));
+
+		this_register->status_address.address =
+		    gpe_block->block_address.address + i;
+
+		this_register->enable_address.address =
+		    gpe_block->block_address.address + i +
+		    gpe_block->register_count;
+
+		this_register->status_address.space_id =
+		    gpe_block->block_address.space_id;
+		this_register->enable_address.space_id =
+		    gpe_block->block_address.space_id;
+		this_register->status_address.bit_width =
+		    ACPI_GPE_REGISTER_WIDTH;
+		this_register->enable_address.bit_width =
+		    ACPI_GPE_REGISTER_WIDTH;
+		this_register->status_address.bit_offset = 0;
+		this_register->enable_address.bit_offset = 0;
+
+		/* Init the event_info for each GPE within this register */
+
+		for (j = 0; j < ACPI_GPE_REGISTER_WIDTH; j++) {
+			this_event->gpe_number =
+			    (u8)(this_register->base_gpe_number + j);
+			this_event->register_info = this_register;
+			this_event++;
+		}
+
+		/* Disable all GPEs within this register */
+
+		status = acpi_hw_write(0x00, &this_register->enable_address);
+		if (ACPI_FAILURE(status)) {
+			goto error_exit;
+		}
+
+		/* Clear any pending GPE events within this register */
+
+		status = acpi_hw_write(0xFF, &this_register->status_address);
+		if (ACPI_FAILURE(status)) {
+			goto error_exit;
+		}
+
+		this_register++;
+	}
+
+	return_ACPI_STATUS(AE_OK);
+
+      error_exit:
+	if (gpe_register_info) {
+		ACPI_FREE(gpe_register_info);
+	}
+	if (gpe_event_info) {
+		ACPI_FREE(gpe_event_info);
+	}
+
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_create_gpe_block
+ *
+ * PARAMETERS:  gpe_device          - Handle to the parent GPE block
+ *              gpe_block_address   - Address and space_iD
+ *              register_count      - Number of GPE register pairs in the block
+ *              gpe_block_base_number - Starting GPE number for the block
+ *              interrupt_number    - H/W interrupt for the block
+ *              return_gpe_block    - Where the new block descriptor is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Create and Install a block of GPE registers. All GPEs within
+ *              the block are disabled at exit.
+ *              Note: Assumes namespace is locked.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ev_create_gpe_block(struct acpi_namespace_node *gpe_device,
+			 struct acpi_generic_address *gpe_block_address,
+			 u32 register_count,
+			 u8 gpe_block_base_number,
+			 u32 interrupt_number,
+			 struct acpi_gpe_block_info **return_gpe_block)
+{
+	acpi_status status;
+	struct acpi_gpe_block_info *gpe_block;
+	struct acpi_gpe_walk_info walk_info;
+
+	ACPI_FUNCTION_TRACE(ev_create_gpe_block);
+
+	if (!register_count) {
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	/* Allocate a new GPE block */
+
+	gpe_block = ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_gpe_block_info));
+	if (!gpe_block) {
+		return_ACPI_STATUS(AE_NO_MEMORY);
+	}
+
+	/* Initialize the new GPE block */
+
+	gpe_block->node = gpe_device;
+	gpe_block->gpe_count = (u16)(register_count * ACPI_GPE_REGISTER_WIDTH);
+	gpe_block->initialized = FALSE;
+	gpe_block->register_count = register_count;
+	gpe_block->block_base_number = gpe_block_base_number;
+
+	ACPI_MEMCPY(&gpe_block->block_address, gpe_block_address,
+		    sizeof(struct acpi_generic_address));
+
+	/*
+	 * Create the register_info and event_info sub-structures
+	 * Note: disables and clears all GPEs in the block
+	 */
+	status = acpi_ev_create_gpe_info_blocks(gpe_block);
+	if (ACPI_FAILURE(status)) {
+		ACPI_FREE(gpe_block);
+		return_ACPI_STATUS(status);
+	}
+
+	/* Install the new block in the global lists */
+
+	status = acpi_ev_install_gpe_block(gpe_block, interrupt_number);
+	if (ACPI_FAILURE(status)) {
+		ACPI_FREE(gpe_block);
+		return_ACPI_STATUS(status);
+	}
+
+	acpi_gbl_all_gpes_initialized = FALSE;
+
+	/* Find all GPE methods (_Lxx or_Exx) for this block */
+
+	walk_info.gpe_block = gpe_block;
+	walk_info.gpe_device = gpe_device;
+	walk_info.execute_by_owner_id = FALSE;
+
+	status = acpi_ns_walk_namespace(ACPI_TYPE_METHOD, gpe_device,
+					ACPI_UINT32_MAX, ACPI_NS_WALK_NO_UNLOCK,
+					acpi_ev_match_gpe_method, NULL,
+					&walk_info, NULL);
+
+	/* Return the new block */
+
+	if (return_gpe_block) {
+		(*return_gpe_block) = gpe_block;
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INIT,
+			  "GPE %02X to %02X [%4.4s] %u regs on int 0x%X\n",
+			  (u32)gpe_block->block_base_number,
+			  (u32)(gpe_block->block_base_number +
+				(gpe_block->gpe_count - 1)),
+			  gpe_device->name.ascii, gpe_block->register_count,
+			  interrupt_number));
+
+	/* Update global count of currently available GPEs */
+
+	acpi_current_gpe_count += gpe_block->gpe_count;
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_initialize_gpe_block
+ *
+ * PARAMETERS:  acpi_gpe_callback
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Initialize and enable a GPE block. Enable GPEs that have
+ *              associated methods.
+ *              Note: Assumes namespace is locked.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ev_initialize_gpe_block(struct acpi_gpe_xrupt_info *gpe_xrupt_info,
+			     struct acpi_gpe_block_info *gpe_block,
+			     void *ignored)
+{
+	acpi_status status;
+	struct acpi_gpe_event_info *gpe_event_info;
+	u32 gpe_enabled_count;
+	u32 gpe_index;
+	u32 i;
+	u32 j;
+
+	ACPI_FUNCTION_TRACE(ev_initialize_gpe_block);
+
+	/*
+	 * Ignore a null GPE block (e.g., if no GPE block 1 exists), and
+	 * any GPE blocks that have been initialized already.
+	 */
+	if (!gpe_block || gpe_block->initialized) {
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	/*
+	 * Enable all GPEs that have a corresponding method and have the
+	 * ACPI_GPE_CAN_WAKE flag unset. Any other GPEs within this block
+	 * must be enabled via the acpi_enable_gpe() interface.
+	 */
+	gpe_enabled_count = 0;
+
+	for (i = 0; i < gpe_block->register_count; i++) {
+		for (j = 0; j < ACPI_GPE_REGISTER_WIDTH; j++) {
+
+			/* Get the info block for this particular GPE */
+
+			gpe_index = (i * ACPI_GPE_REGISTER_WIDTH) + j;
+			gpe_event_info = &gpe_block->event_info[gpe_index];
+
+			/*
+			 * Ignore GPEs that have no corresponding _Lxx/_Exx method
+			 * and GPEs that are used to wake the system
+			 */
+			if (((gpe_event_info->flags & ACPI_GPE_DISPATCH_MASK) ==
+			     ACPI_GPE_DISPATCH_NONE)
+			    || ((gpe_event_info->flags & ACPI_GPE_DISPATCH_MASK)
+				== ACPI_GPE_DISPATCH_HANDLER)
+			    || (gpe_event_info->flags & ACPI_GPE_CAN_WAKE)) {
+				continue;
+			}
+
+			status = acpi_ev_add_gpe_reference(gpe_event_info);
+			if (ACPI_FAILURE(status)) {
+				ACPI_EXCEPTION((AE_INFO, status,
+						"Could not enable GPE 0x%02X",
+						gpe_index +
+						gpe_block->block_base_number));
+				continue;
+			}
+
+			gpe_enabled_count++;
+		}
+	}
+
+	if (gpe_enabled_count) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INIT,
+				  "Enabled %u GPEs in this block\n",
+				  gpe_enabled_count));
+	}
+
+	gpe_block->initialized = TRUE;
+	return_ACPI_STATUS(AE_OK);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/evgpeinit.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/evgpeinit.c
new file mode 100644
index 00000000..b698cc58
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/evgpeinit.c
@@ -0,0 +1,438 @@
+/******************************************************************************
+ *
+ * Module Name: evgpeinit - System GPE initialization and update
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acevents.h"
+#include "acnamesp.h"
+
+#define _COMPONENT          ACPI_EVENTS
+ACPI_MODULE_NAME("evgpeinit")
+
+/*
+ * Note: History of _PRW support in ACPICA
+ *
+ * Originally (2000 - 2010), the GPE initialization code performed a walk of
+ * the entire namespace to execute the _PRW methods and detect all GPEs
+ * capable of waking the system.
+ *
+ * As of 10/2010, the _PRW method execution has been removed since it is
+ * actually unnecessary. The host OS must in fact execute all _PRW methods
+ * in order to identify the device/power-resource dependencies. We now put
+ * the onus on the host OS to identify the wake GPEs as part of this process
+ * and to inform ACPICA of these GPEs via the acpi_setup_gpe_for_wake interface. This
+ * not only reduces the complexity of the ACPICA initialization code, but in
+ * some cases (on systems with very large namespaces) it should reduce the
+ * kernel boot time as well.
+ */
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_gpe_initialize
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Initialize the GPE data structures and the FADT GPE 0/1 blocks
+ *
+ ******************************************************************************/
+acpi_status acpi_ev_gpe_initialize(void)
+{
+	u32 register_count0 = 0;
+	u32 register_count1 = 0;
+	u32 gpe_number_max = 0;
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(ev_gpe_initialize);
+
+	status = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/*
+	 * Initialize the GPE Block(s) defined in the FADT
+	 *
+	 * Why the GPE register block lengths are divided by 2:  From the ACPI
+	 * Spec, section "General-Purpose Event Registers", we have:
+	 *
+	 * "Each register block contains two registers of equal length
+	 *  GPEx_STS and GPEx_EN (where x is 0 or 1). The length of the
+	 *  GPE0_STS and GPE0_EN registers is equal to half the GPE0_LEN
+	 *  The length of the GPE1_STS and GPE1_EN registers is equal to
+	 *  half the GPE1_LEN. If a generic register block is not supported
+	 *  then its respective block pointer and block length values in the
+	 *  FADT table contain zeros. The GPE0_LEN and GPE1_LEN do not need
+	 *  to be the same size."
+	 */
+
+	/*
+	 * Determine the maximum GPE number for this machine.
+	 *
+	 * Note: both GPE0 and GPE1 are optional, and either can exist without
+	 * the other.
+	 *
+	 * If EITHER the register length OR the block address are zero, then that
+	 * particular block is not supported.
+	 */
+	if (acpi_gbl_FADT.gpe0_block_length &&
+	    acpi_gbl_FADT.xgpe0_block.address) {
+
+		/* GPE block 0 exists (has both length and address > 0) */
+
+		register_count0 = (u16)(acpi_gbl_FADT.gpe0_block_length / 2);
+
+		gpe_number_max =
+		    (register_count0 * ACPI_GPE_REGISTER_WIDTH) - 1;
+
+		/* Install GPE Block 0 */
+
+		status = acpi_ev_create_gpe_block(acpi_gbl_fadt_gpe_device,
+						  &acpi_gbl_FADT.xgpe0_block,
+						  register_count0, 0,
+						  acpi_gbl_FADT.sci_interrupt,
+						  &acpi_gbl_gpe_fadt_blocks[0]);
+
+		if (ACPI_FAILURE(status)) {
+			ACPI_EXCEPTION((AE_INFO, status,
+					"Could not create GPE Block 0"));
+		}
+	}
+
+	if (acpi_gbl_FADT.gpe1_block_length &&
+	    acpi_gbl_FADT.xgpe1_block.address) {
+
+		/* GPE block 1 exists (has both length and address > 0) */
+
+		register_count1 = (u16)(acpi_gbl_FADT.gpe1_block_length / 2);
+
+		/* Check for GPE0/GPE1 overlap (if both banks exist) */
+
+		if ((register_count0) &&
+		    (gpe_number_max >= acpi_gbl_FADT.gpe1_base)) {
+			ACPI_ERROR((AE_INFO,
+				    "GPE0 block (GPE 0 to %u) overlaps the GPE1 block "
+				    "(GPE %u to %u) - Ignoring GPE1",
+				    gpe_number_max, acpi_gbl_FADT.gpe1_base,
+				    acpi_gbl_FADT.gpe1_base +
+				    ((register_count1 *
+				      ACPI_GPE_REGISTER_WIDTH) - 1)));
+
+			/* Ignore GPE1 block by setting the register count to zero */
+
+			register_count1 = 0;
+		} else {
+			/* Install GPE Block 1 */
+
+			status =
+			    acpi_ev_create_gpe_block(acpi_gbl_fadt_gpe_device,
+						     &acpi_gbl_FADT.xgpe1_block,
+						     register_count1,
+						     acpi_gbl_FADT.gpe1_base,
+						     acpi_gbl_FADT.
+						     sci_interrupt,
+						     &acpi_gbl_gpe_fadt_blocks
+						     [1]);
+
+			if (ACPI_FAILURE(status)) {
+				ACPI_EXCEPTION((AE_INFO, status,
+						"Could not create GPE Block 1"));
+			}
+
+			/*
+			 * GPE0 and GPE1 do not have to be contiguous in the GPE number
+			 * space. However, GPE0 always starts at GPE number zero.
+			 */
+			gpe_number_max = acpi_gbl_FADT.gpe1_base +
+			    ((register_count1 * ACPI_GPE_REGISTER_WIDTH) - 1);
+		}
+	}
+
+	/* Exit if there are no GPE registers */
+
+	if ((register_count0 + register_count1) == 0) {
+
+		/* GPEs are not required by ACPI, this is OK */
+
+		ACPI_DEBUG_PRINT((ACPI_DB_INIT,
+				  "There are no GPE blocks defined in the FADT\n"));
+		status = AE_OK;
+		goto cleanup;
+	}
+
+	/* Check for Max GPE number out-of-range */
+
+	if (gpe_number_max > ACPI_GPE_MAX) {
+		ACPI_ERROR((AE_INFO,
+			    "Maximum GPE number from FADT is too large: 0x%X",
+			    gpe_number_max));
+		status = AE_BAD_VALUE;
+		goto cleanup;
+	}
+
+      cleanup:
+	(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_update_gpes
+ *
+ * PARAMETERS:  table_owner_id      - ID of the newly-loaded ACPI table
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Check for new GPE methods (_Lxx/_Exx) made available as a
+ *              result of a Load() or load_table() operation. If new GPE
+ *              methods have been installed, register the new methods.
+ *
+ ******************************************************************************/
+
+void acpi_ev_update_gpes(acpi_owner_id table_owner_id)
+{
+	struct acpi_gpe_xrupt_info *gpe_xrupt_info;
+	struct acpi_gpe_block_info *gpe_block;
+	struct acpi_gpe_walk_info walk_info;
+	acpi_status status = AE_OK;
+
+	/*
+	 * Find any _Lxx/_Exx GPE methods that have just been loaded.
+	 *
+	 * Any GPEs that correspond to new _Lxx/_Exx methods are immediately
+	 * enabled.
+	 *
+	 * Examine the namespace underneath each gpe_device within the
+	 * gpe_block lists.
+	 */
+	status = acpi_ut_acquire_mutex(ACPI_MTX_EVENTS);
+	if (ACPI_FAILURE(status)) {
+		return;
+	}
+
+	walk_info.count = 0;
+	walk_info.owner_id = table_owner_id;
+	walk_info.execute_by_owner_id = TRUE;
+
+	/* Walk the interrupt level descriptor list */
+
+	gpe_xrupt_info = acpi_gbl_gpe_xrupt_list_head;
+	while (gpe_xrupt_info) {
+
+		/* Walk all Gpe Blocks attached to this interrupt level */
+
+		gpe_block = gpe_xrupt_info->gpe_block_list_head;
+		while (gpe_block) {
+			walk_info.gpe_block = gpe_block;
+			walk_info.gpe_device = gpe_block->node;
+
+			status = acpi_ns_walk_namespace(ACPI_TYPE_METHOD,
+							walk_info.gpe_device,
+							ACPI_UINT32_MAX,
+							ACPI_NS_WALK_NO_UNLOCK,
+							acpi_ev_match_gpe_method,
+							NULL, &walk_info, NULL);
+			if (ACPI_FAILURE(status)) {
+				ACPI_EXCEPTION((AE_INFO, status,
+						"While decoding _Lxx/_Exx methods"));
+			}
+
+			gpe_block = gpe_block->next;
+		}
+
+		gpe_xrupt_info = gpe_xrupt_info->next;
+	}
+
+	if (walk_info.count) {
+		ACPI_INFO((AE_INFO, "Enabled %u new GPEs", walk_info.count));
+	}
+
+	(void)acpi_ut_release_mutex(ACPI_MTX_EVENTS);
+	return;
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_match_gpe_method
+ *
+ * PARAMETERS:  Callback from walk_namespace
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Called from acpi_walk_namespace. Expects each object to be a
+ *              control method under the _GPE portion of the namespace.
+ *              Extract the name and GPE type from the object, saving this
+ *              information for quick lookup during GPE dispatch. Allows a
+ *              per-owner_id evaluation if execute_by_owner_id is TRUE in the
+ *              walk_info parameter block.
+ *
+ *              The name of each GPE control method is of the form:
+ *              "_Lxx" or "_Exx", where:
+ *                  L      - means that the GPE is level triggered
+ *                  E      - means that the GPE is edge triggered
+ *                  xx     - is the GPE number [in HEX]
+ *
+ * If walk_info->execute_by_owner_id is TRUE, we only execute examine GPE methods
+ * with that owner.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ev_match_gpe_method(acpi_handle obj_handle,
+			 u32 level, void *context, void **return_value)
+{
+	struct acpi_namespace_node *method_node =
+	    ACPI_CAST_PTR(struct acpi_namespace_node, obj_handle);
+	struct acpi_gpe_walk_info *walk_info =
+	    ACPI_CAST_PTR(struct acpi_gpe_walk_info, context);
+	struct acpi_gpe_event_info *gpe_event_info;
+	u32 gpe_number;
+	char name[ACPI_NAME_SIZE + 1];
+	u8 type;
+
+	ACPI_FUNCTION_TRACE(ev_match_gpe_method);
+
+	/* Check if requested owner_id matches this owner_id */
+
+	if ((walk_info->execute_by_owner_id) &&
+	    (method_node->owner_id != walk_info->owner_id)) {
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	/*
+	 * Match and decode the _Lxx and _Exx GPE method names
+	 *
+	 * 1) Extract the method name and null terminate it
+	 */
+	ACPI_MOVE_32_TO_32(name, &method_node->name.integer);
+	name[ACPI_NAME_SIZE] = 0;
+
+	/* 2) Name must begin with an underscore */
+
+	if (name[0] != '_') {
+		return_ACPI_STATUS(AE_OK);	/* Ignore this method */
+	}
+
+	/*
+	 * 3) Edge/Level determination is based on the 2nd character
+	 *    of the method name
+	 */
+	switch (name[1]) {
+	case 'L':
+		type = ACPI_GPE_LEVEL_TRIGGERED;
+		break;
+
+	case 'E':
+		type = ACPI_GPE_EDGE_TRIGGERED;
+		break;
+
+	default:
+		/* Unknown method type, just ignore it */
+
+		ACPI_DEBUG_PRINT((ACPI_DB_LOAD,
+				  "Ignoring unknown GPE method type: %s "
+				  "(name not of form _Lxx or _Exx)", name));
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	/* 4) The last two characters of the name are the hex GPE Number */
+
+	gpe_number = ACPI_STRTOUL(&name[2], NULL, 16);
+	if (gpe_number == ACPI_UINT32_MAX) {
+
+		/* Conversion failed; invalid method, just ignore it */
+
+		ACPI_DEBUG_PRINT((ACPI_DB_LOAD,
+				  "Could not extract GPE number from name: %s "
+				  "(name is not of form _Lxx or _Exx)", name));
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	/* Ensure that we have a valid GPE number for this GPE block */
+
+	gpe_event_info =
+	    acpi_ev_low_get_gpe_info(gpe_number, walk_info->gpe_block);
+	if (!gpe_event_info) {
+		/*
+		 * This gpe_number is not valid for this GPE block, just ignore it.
+		 * However, it may be valid for a different GPE block, since GPE0
+		 * and GPE1 methods both appear under \_GPE.
+		 */
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	if ((gpe_event_info->flags & ACPI_GPE_DISPATCH_MASK) ==
+	    ACPI_GPE_DISPATCH_HANDLER) {
+
+		/* If there is already a handler, ignore this GPE method */
+
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	if ((gpe_event_info->flags & ACPI_GPE_DISPATCH_MASK) ==
+	    ACPI_GPE_DISPATCH_METHOD) {
+		/*
+		 * If there is already a method, ignore this method. But check
+		 * for a type mismatch (if both the _Lxx AND _Exx exist)
+		 */
+		if (type != (gpe_event_info->flags & ACPI_GPE_XRUPT_TYPE_MASK)) {
+			ACPI_ERROR((AE_INFO,
+				    "For GPE 0x%.2X, found both _L%2.2X and _E%2.2X methods",
+				    gpe_number, gpe_number, gpe_number));
+		}
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	/*
+	 * Add the GPE information from above to the gpe_event_info block for
+	 * use during dispatch of this GPE.
+	 */
+	gpe_event_info->flags &= ~(ACPI_GPE_DISPATCH_MASK);
+	gpe_event_info->flags |= (u8)(type | ACPI_GPE_DISPATCH_METHOD);
+	gpe_event_info->dispatch.method_node = method_node;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_LOAD,
+			  "Registered GPE method %s as GPE number 0x%.2X\n",
+			  name, gpe_number));
+	return_ACPI_STATUS(AE_OK);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/evgpeutil.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/evgpeutil.c
new file mode 100644
index 00000000..4b1e6b57
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/evgpeutil.c
@@ -0,0 +1,376 @@
+/******************************************************************************
+ *
+ * Module Name: evgpeutil - GPE utilities
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acevents.h"
+
+#define _COMPONENT          ACPI_EVENTS
+ACPI_MODULE_NAME("evgpeutil")
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_walk_gpe_list
+ *
+ * PARAMETERS:  gpe_walk_callback   - Routine called for each GPE block
+ *              Context             - Value passed to callback
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Walk the GPE lists.
+ *
+ ******************************************************************************/
+acpi_status
+acpi_ev_walk_gpe_list(acpi_gpe_callback gpe_walk_callback, void *context)
+{
+	struct acpi_gpe_block_info *gpe_block;
+	struct acpi_gpe_xrupt_info *gpe_xrupt_info;
+	acpi_status status = AE_OK;
+	acpi_cpu_flags flags;
+
+	ACPI_FUNCTION_TRACE(ev_walk_gpe_list);
+
+	flags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);
+
+	/* Walk the interrupt level descriptor list */
+
+	gpe_xrupt_info = acpi_gbl_gpe_xrupt_list_head;
+	while (gpe_xrupt_info) {
+
+		/* Walk all Gpe Blocks attached to this interrupt level */
+
+		gpe_block = gpe_xrupt_info->gpe_block_list_head;
+		while (gpe_block) {
+
+			/* One callback per GPE block */
+
+			status =
+			    gpe_walk_callback(gpe_xrupt_info, gpe_block,
+					      context);
+			if (ACPI_FAILURE(status)) {
+				if (status == AE_CTRL_END) {	/* Callback abort */
+					status = AE_OK;
+				}
+				goto unlock_and_exit;
+			}
+
+			gpe_block = gpe_block->next;
+		}
+
+		gpe_xrupt_info = gpe_xrupt_info->next;
+	}
+
+      unlock_and_exit:
+	acpi_os_release_lock(acpi_gbl_gpe_lock, flags);
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_valid_gpe_event
+ *
+ * PARAMETERS:  gpe_event_info              - Info for this GPE
+ *
+ * RETURN:      TRUE if the gpe_event is valid
+ *
+ * DESCRIPTION: Validate a GPE event. DO NOT CALL FROM INTERRUPT LEVEL.
+ *              Should be called only when the GPE lists are semaphore locked
+ *              and not subject to change.
+ *
+ ******************************************************************************/
+
+u8 acpi_ev_valid_gpe_event(struct acpi_gpe_event_info *gpe_event_info)
+{
+	struct acpi_gpe_xrupt_info *gpe_xrupt_block;
+	struct acpi_gpe_block_info *gpe_block;
+
+	ACPI_FUNCTION_ENTRY();
+
+	/* No need for spin lock since we are not changing any list elements */
+
+	/* Walk the GPE interrupt levels */
+
+	gpe_xrupt_block = acpi_gbl_gpe_xrupt_list_head;
+	while (gpe_xrupt_block) {
+		gpe_block = gpe_xrupt_block->gpe_block_list_head;
+
+		/* Walk the GPE blocks on this interrupt level */
+
+		while (gpe_block) {
+			if ((&gpe_block->event_info[0] <= gpe_event_info) &&
+			    (&gpe_block->event_info[gpe_block->gpe_count] >
+			     gpe_event_info)) {
+				return (TRUE);
+			}
+
+			gpe_block = gpe_block->next;
+		}
+
+		gpe_xrupt_block = gpe_xrupt_block->next;
+	}
+
+	return (FALSE);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_get_gpe_device
+ *
+ * PARAMETERS:  GPE_WALK_CALLBACK
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Matches the input GPE index (0-current_gpe_count) with a GPE
+ *              block device. NULL if the GPE is one of the FADT-defined GPEs.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ev_get_gpe_device(struct acpi_gpe_xrupt_info * gpe_xrupt_info,
+		       struct acpi_gpe_block_info * gpe_block, void *context)
+{
+	struct acpi_gpe_device_info *info = context;
+
+	/* Increment Index by the number of GPEs in this block */
+
+	info->next_block_base_index += gpe_block->gpe_count;
+
+	if (info->index < info->next_block_base_index) {
+		/*
+		 * The GPE index is within this block, get the node. Leave the node
+		 * NULL for the FADT-defined GPEs
+		 */
+		if ((gpe_block->node)->type == ACPI_TYPE_DEVICE) {
+			info->gpe_device = gpe_block->node;
+		}
+
+		info->status = AE_OK;
+		return (AE_CTRL_END);
+	}
+
+	return (AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_get_gpe_xrupt_block
+ *
+ * PARAMETERS:  interrupt_number     - Interrupt for a GPE block
+ *
+ * RETURN:      A GPE interrupt block
+ *
+ * DESCRIPTION: Get or Create a GPE interrupt block. There is one interrupt
+ *              block per unique interrupt level used for GPEs. Should be
+ *              called only when the GPE lists are semaphore locked and not
+ *              subject to change.
+ *
+ ******************************************************************************/
+
+struct acpi_gpe_xrupt_info *acpi_ev_get_gpe_xrupt_block(u32 interrupt_number)
+{
+	struct acpi_gpe_xrupt_info *next_gpe_xrupt;
+	struct acpi_gpe_xrupt_info *gpe_xrupt;
+	acpi_status status;
+	acpi_cpu_flags flags;
+
+	ACPI_FUNCTION_TRACE(ev_get_gpe_xrupt_block);
+
+	/* No need for lock since we are not changing any list elements here */
+
+	next_gpe_xrupt = acpi_gbl_gpe_xrupt_list_head;
+	while (next_gpe_xrupt) {
+		if (next_gpe_xrupt->interrupt_number == interrupt_number) {
+			return_PTR(next_gpe_xrupt);
+		}
+
+		next_gpe_xrupt = next_gpe_xrupt->next;
+	}
+
+	/* Not found, must allocate a new xrupt descriptor */
+
+	gpe_xrupt = ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_gpe_xrupt_info));
+	if (!gpe_xrupt) {
+		return_PTR(NULL);
+	}
+
+	gpe_xrupt->interrupt_number = interrupt_number;
+
+	/* Install new interrupt descriptor with spin lock */
+
+	flags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);
+	if (acpi_gbl_gpe_xrupt_list_head) {
+		next_gpe_xrupt = acpi_gbl_gpe_xrupt_list_head;
+		while (next_gpe_xrupt->next) {
+			next_gpe_xrupt = next_gpe_xrupt->next;
+		}
+
+		next_gpe_xrupt->next = gpe_xrupt;
+		gpe_xrupt->previous = next_gpe_xrupt;
+	} else {
+		acpi_gbl_gpe_xrupt_list_head = gpe_xrupt;
+	}
+	acpi_os_release_lock(acpi_gbl_gpe_lock, flags);
+
+	/* Install new interrupt handler if not SCI_INT */
+
+	if (interrupt_number != acpi_gbl_FADT.sci_interrupt) {
+		status = acpi_os_install_interrupt_handler(interrupt_number,
+							   acpi_ev_gpe_xrupt_handler,
+							   gpe_xrupt);
+		if (ACPI_FAILURE(status)) {
+			ACPI_ERROR((AE_INFO,
+				    "Could not install GPE interrupt handler at level 0x%X",
+				    interrupt_number));
+			return_PTR(NULL);
+		}
+	}
+
+	return_PTR(gpe_xrupt);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_delete_gpe_xrupt
+ *
+ * PARAMETERS:  gpe_xrupt       - A GPE interrupt info block
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Remove and free a gpe_xrupt block. Remove an associated
+ *              interrupt handler if not the SCI interrupt.
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ev_delete_gpe_xrupt(struct acpi_gpe_xrupt_info *gpe_xrupt)
+{
+	acpi_status status;
+	acpi_cpu_flags flags;
+
+	ACPI_FUNCTION_TRACE(ev_delete_gpe_xrupt);
+
+	/* We never want to remove the SCI interrupt handler */
+
+	if (gpe_xrupt->interrupt_number == acpi_gbl_FADT.sci_interrupt) {
+		gpe_xrupt->gpe_block_list_head = NULL;
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	/* Disable this interrupt */
+
+	status =
+	    acpi_os_remove_interrupt_handler(gpe_xrupt->interrupt_number,
+					     acpi_ev_gpe_xrupt_handler);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/* Unlink the interrupt block with lock */
+
+	flags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);
+	if (gpe_xrupt->previous) {
+		gpe_xrupt->previous->next = gpe_xrupt->next;
+	} else {
+		/* No previous, update list head */
+
+		acpi_gbl_gpe_xrupt_list_head = gpe_xrupt->next;
+	}
+
+	if (gpe_xrupt->next) {
+		gpe_xrupt->next->previous = gpe_xrupt->previous;
+	}
+	acpi_os_release_lock(acpi_gbl_gpe_lock, flags);
+
+	/* Free the block */
+
+	ACPI_FREE(gpe_xrupt);
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_delete_gpe_handlers
+ *
+ * PARAMETERS:  gpe_xrupt_info      - GPE Interrupt info
+ *              gpe_block           - Gpe Block info
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Delete all Handler objects found in the GPE data structs.
+ *              Used only prior to termination.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ev_delete_gpe_handlers(struct acpi_gpe_xrupt_info *gpe_xrupt_info,
+			    struct acpi_gpe_block_info *gpe_block,
+			    void *context)
+{
+	struct acpi_gpe_event_info *gpe_event_info;
+	u32 i;
+	u32 j;
+
+	ACPI_FUNCTION_TRACE(ev_delete_gpe_handlers);
+
+	/* Examine each GPE Register within the block */
+
+	for (i = 0; i < gpe_block->register_count; i++) {
+
+		/* Now look at the individual GPEs in this byte register */
+
+		for (j = 0; j < ACPI_GPE_REGISTER_WIDTH; j++) {
+			gpe_event_info = &gpe_block->event_info[((acpi_size) i *
+								 ACPI_GPE_REGISTER_WIDTH)
+								+ j];
+
+			if ((gpe_event_info->flags & ACPI_GPE_DISPATCH_MASK) ==
+			    ACPI_GPE_DISPATCH_HANDLER) {
+				ACPI_FREE(gpe_event_info->dispatch.handler);
+				gpe_event_info->dispatch.handler = NULL;
+				gpe_event_info->flags &=
+				    ~ACPI_GPE_DISPATCH_MASK;
+			}
+		}
+	}
+
+	return_ACPI_STATUS(AE_OK);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/evmisc.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/evmisc.c
new file mode 100644
index 00000000..1fc3bed2
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/evmisc.c
@@ -0,0 +1,334 @@
+/******************************************************************************
+ *
+ * Module Name: evmisc - Miscellaneous event manager support functions
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acevents.h"
+#include "acnamesp.h"
+
+#define _COMPONENT          ACPI_EVENTS
+ACPI_MODULE_NAME("evmisc")
+
+/* Local prototypes */
+static void ACPI_SYSTEM_XFACE acpi_ev_notify_dispatch(void *context);
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_is_notify_object
+ *
+ * PARAMETERS:  Node            - Node to check
+ *
+ * RETURN:      TRUE if notifies allowed on this object
+ *
+ * DESCRIPTION: Check type of node for a object that supports notifies.
+ *
+ *              TBD: This could be replaced by a flag bit in the node.
+ *
+ ******************************************************************************/
+
+u8 acpi_ev_is_notify_object(struct acpi_namespace_node *node)
+{
+	switch (node->type) {
+	case ACPI_TYPE_DEVICE:
+	case ACPI_TYPE_PROCESSOR:
+	case ACPI_TYPE_THERMAL:
+		/*
+		 * These are the ONLY objects that can receive ACPI notifications
+		 */
+		return (TRUE);
+
+	default:
+		return (FALSE);
+	}
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_queue_notify_request
+ *
+ * PARAMETERS:  Node            - NS node for the notified object
+ *              notify_value    - Value from the Notify() request
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Dispatch a device notification event to a previously
+ *              installed handler.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ev_queue_notify_request(struct acpi_namespace_node * node,
+			     u32 notify_value)
+{
+	union acpi_operand_object *obj_desc;
+	union acpi_operand_object *handler_obj = NULL;
+	union acpi_generic_state *notify_info;
+	acpi_status status = AE_OK;
+
+	ACPI_FUNCTION_NAME(ev_queue_notify_request);
+
+	/*
+	 * For value 3 (Ejection Request), some device method may need to be run.
+	 * For value 2 (Device Wake) if _PRW exists, the _PS0 method may need
+	 *   to be run.
+	 * For value 0x80 (Status Change) on the power button or sleep button,
+	 *   initiate soft-off or sleep operation?
+	 */
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+			  "Dispatching Notify on [%4.4s] Node %p Value 0x%2.2X (%s)\n",
+			  acpi_ut_get_node_name(node), node, notify_value,
+			  acpi_ut_get_notify_name(notify_value)));
+
+	/* Get the notify object attached to the NS Node */
+
+	obj_desc = acpi_ns_get_attached_object(node);
+	if (obj_desc) {
+
+		/* We have the notify object, Get the right handler */
+
+		switch (node->type) {
+
+			/* Notify allowed only on these types */
+
+		case ACPI_TYPE_DEVICE:
+		case ACPI_TYPE_THERMAL:
+		case ACPI_TYPE_PROCESSOR:
+
+			if (notify_value <= ACPI_MAX_SYS_NOTIFY) {
+				handler_obj =
+				    obj_desc->common_notify.system_notify;
+			} else {
+				handler_obj =
+				    obj_desc->common_notify.device_notify;
+			}
+			break;
+
+		default:
+
+			/* All other types are not supported */
+
+			return (AE_TYPE);
+		}
+	}
+
+	/*
+	 * If there is any handler to run, schedule the dispatcher.
+	 * Check for:
+	 * 1) Global system notify handler
+	 * 2) Global device notify handler
+	 * 3) Per-device notify handler
+	 */
+	if ((acpi_gbl_system_notify.handler &&
+	     (notify_value <= ACPI_MAX_SYS_NOTIFY)) ||
+	    (acpi_gbl_device_notify.handler &&
+	     (notify_value > ACPI_MAX_SYS_NOTIFY)) || handler_obj) {
+		notify_info = acpi_ut_create_generic_state();
+		if (!notify_info) {
+			return (AE_NO_MEMORY);
+		}
+
+		if (!handler_obj) {
+			ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+					  "Executing system notify handler for Notify (%4.4s, %X) "
+					  "node %p\n",
+					  acpi_ut_get_node_name(node),
+					  notify_value, node));
+		}
+
+		notify_info->common.descriptor_type =
+		    ACPI_DESC_TYPE_STATE_NOTIFY;
+		notify_info->notify.node = node;
+		notify_info->notify.value = (u16)notify_value;
+		notify_info->notify.handler_obj = handler_obj;
+
+		status =
+		    acpi_os_execute(OSL_NOTIFY_HANDLER, acpi_ev_notify_dispatch,
+				    notify_info);
+		if (ACPI_FAILURE(status)) {
+			acpi_ut_delete_generic_state(notify_info);
+		}
+	} else {
+		/* There is no notify handler (per-device or system) for this device */
+
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+				  "No notify handler for Notify (%4.4s, %X) node %p\n",
+				  acpi_ut_get_node_name(node), notify_value,
+				  node));
+	}
+
+	return (status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_notify_dispatch
+ *
+ * PARAMETERS:  Context         - To be passed to the notify handler
+ *
+ * RETURN:      None.
+ *
+ * DESCRIPTION: Dispatch a device notification event to a previously
+ *              installed handler.
+ *
+ ******************************************************************************/
+
+static void ACPI_SYSTEM_XFACE acpi_ev_notify_dispatch(void *context)
+{
+	union acpi_generic_state *notify_info =
+	    (union acpi_generic_state *)context;
+	acpi_notify_handler global_handler = NULL;
+	void *global_context = NULL;
+	union acpi_operand_object *handler_obj;
+
+	ACPI_FUNCTION_ENTRY();
+
+	/*
+	 * We will invoke a global notify handler if installed. This is done
+	 * _before_ we invoke the per-device handler attached to the device.
+	 */
+	if (notify_info->notify.value <= ACPI_MAX_SYS_NOTIFY) {
+
+		/* Global system notification handler */
+
+		if (acpi_gbl_system_notify.handler) {
+			global_handler = acpi_gbl_system_notify.handler;
+			global_context = acpi_gbl_system_notify.context;
+		}
+	} else {
+		/* Global driver notification handler */
+
+		if (acpi_gbl_device_notify.handler) {
+			global_handler = acpi_gbl_device_notify.handler;
+			global_context = acpi_gbl_device_notify.context;
+		}
+	}
+
+	/* Invoke the system handler first, if present */
+
+	if (global_handler) {
+		global_handler(notify_info->notify.node,
+			       notify_info->notify.value, global_context);
+	}
+
+	/* Now invoke the per-device handler, if present */
+
+	handler_obj = notify_info->notify.handler_obj;
+	if (handler_obj) {
+		handler_obj->notify.handler(notify_info->notify.node,
+					    notify_info->notify.value,
+					    handler_obj->notify.context);
+	}
+
+	/* All done with the info object */
+
+	acpi_ut_delete_generic_state(notify_info);
+}
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_terminate
+ *
+ * PARAMETERS:  none
+ *
+ * RETURN:      none
+ *
+ * DESCRIPTION: Disable events and free memory allocated for table storage.
+ *
+ ******************************************************************************/
+
+void acpi_ev_terminate(void)
+{
+	u32 i;
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(ev_terminate);
+
+	if (acpi_gbl_events_initialized) {
+		/*
+		 * Disable all event-related functionality. In all cases, on error,
+		 * print a message but obviously we don't abort.
+		 */
+
+		/* Disable all fixed events */
+
+		for (i = 0; i < ACPI_NUM_FIXED_EVENTS; i++) {
+			status = acpi_disable_event(i, 0);
+			if (ACPI_FAILURE(status)) {
+				ACPI_ERROR((AE_INFO,
+					    "Could not disable fixed event %u",
+					    (u32)i));
+			}
+		}
+
+		/* Disable all GPEs in all GPE blocks */
+
+		status = acpi_ev_walk_gpe_list(acpi_hw_disable_gpe_block, NULL);
+
+		/* Remove SCI handler */
+
+		status = acpi_ev_remove_sci_handler();
+		if (ACPI_FAILURE(status)) {
+			ACPI_ERROR((AE_INFO, "Could not remove SCI handler"));
+		}
+
+		status = acpi_ev_remove_global_lock_handler();
+		if (ACPI_FAILURE(status)) {
+			ACPI_ERROR((AE_INFO,
+				    "Could not remove Global Lock handler"));
+		}
+	}
+
+	/* Deallocate all handler objects installed within GPE info structs */
+
+	status = acpi_ev_walk_gpe_list(acpi_ev_delete_gpe_handlers, NULL);
+
+	/* Return to original mode if necessary */
+
+	if (acpi_gbl_original_mode == ACPI_SYS_MODE_LEGACY) {
+		status = acpi_disable();
+		if (ACPI_FAILURE(status)) {
+			ACPI_WARNING((AE_INFO, "AcpiDisable failed"));
+		}
+	}
+	return_VOID;
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/evregion.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/evregion.c
new file mode 100644
index 00000000..f65aaf97
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/evregion.c
@@ -0,0 +1,1265 @@
+/******************************************************************************
+ *
+ * Module Name: evregion - ACPI address_space (op_region) handler dispatch
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acevents.h"
+#include "acnamesp.h"
+#include "acinterp.h"
+
+#define _COMPONENT          ACPI_EVENTS
+ACPI_MODULE_NAME("evregion")
+
+/* Local prototypes */
+static u8
+acpi_ev_has_default_handler(struct acpi_namespace_node *node,
+			    acpi_adr_space_type space_id);
+
+static void acpi_ev_orphan_ec_reg_method(void);
+
+static acpi_status
+acpi_ev_reg_run(acpi_handle obj_handle,
+		u32 level, void *context, void **return_value);
+
+static acpi_status
+acpi_ev_install_handler(acpi_handle obj_handle,
+			u32 level, void *context, void **return_value);
+
+/* These are the address spaces that will get default handlers */
+
+#define ACPI_NUM_DEFAULT_SPACES     4
+
+static u8 acpi_gbl_default_address_spaces[ACPI_NUM_DEFAULT_SPACES] = {
+	ACPI_ADR_SPACE_SYSTEM_MEMORY,
+	ACPI_ADR_SPACE_SYSTEM_IO,
+	ACPI_ADR_SPACE_PCI_CONFIG,
+	ACPI_ADR_SPACE_DATA_TABLE
+};
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_install_region_handlers
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Installs the core subsystem default address space handlers.
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ev_install_region_handlers(void)
+{
+	acpi_status status;
+	u32 i;
+
+	ACPI_FUNCTION_TRACE(ev_install_region_handlers);
+
+	status = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/*
+	 * All address spaces (PCI Config, EC, SMBus) are scope dependent and
+	 * registration must occur for a specific device.
+	 *
+	 * In the case of the system memory and IO address spaces there is
+	 * currently no device associated with the address space. For these we
+	 * use the root.
+	 *
+	 * We install the default PCI config space handler at the root so that
+	 * this space is immediately available even though the we have not
+	 * enumerated all the PCI Root Buses yet. This is to conform to the ACPI
+	 * specification which states that the PCI config space must be always
+	 * available -- even though we are nowhere near ready to find the PCI root
+	 * buses at this point.
+	 *
+	 * NOTE: We ignore AE_ALREADY_EXISTS because this means that a handler
+	 * has already been installed (via acpi_install_address_space_handler).
+	 * Similar for AE_SAME_HANDLER.
+	 */
+	for (i = 0; i < ACPI_NUM_DEFAULT_SPACES; i++) {
+		status = acpi_ev_install_space_handler(acpi_gbl_root_node,
+						       acpi_gbl_default_address_spaces
+						       [i],
+						       ACPI_DEFAULT_HANDLER,
+						       NULL, NULL);
+		switch (status) {
+		case AE_OK:
+		case AE_SAME_HANDLER:
+		case AE_ALREADY_EXISTS:
+
+			/* These exceptions are all OK */
+
+			status = AE_OK;
+			break;
+
+		default:
+
+			goto unlock_and_exit;
+		}
+	}
+
+      unlock_and_exit:
+	(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_has_default_handler
+ *
+ * PARAMETERS:  Node                - Namespace node for the device
+ *              space_id            - The address space ID
+ *
+ * RETURN:      TRUE if default handler is installed, FALSE otherwise
+ *
+ * DESCRIPTION: Check if the default handler is installed for the requested
+ *              space ID.
+ *
+ ******************************************************************************/
+
+static u8
+acpi_ev_has_default_handler(struct acpi_namespace_node *node,
+			    acpi_adr_space_type space_id)
+{
+	union acpi_operand_object *obj_desc;
+	union acpi_operand_object *handler_obj;
+
+	/* Must have an existing internal object */
+
+	obj_desc = acpi_ns_get_attached_object(node);
+	if (obj_desc) {
+		handler_obj = obj_desc->device.handler;
+
+		/* Walk the linked list of handlers for this object */
+
+		while (handler_obj) {
+			if (handler_obj->address_space.space_id == space_id) {
+				if (handler_obj->address_space.handler_flags &
+				    ACPI_ADDR_HANDLER_DEFAULT_INSTALLED) {
+					return (TRUE);
+				}
+			}
+
+			handler_obj = handler_obj->address_space.next;
+		}
+	}
+
+	return (FALSE);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_initialize_op_regions
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Execute _REG methods for all Operation Regions that have
+ *              an installed default region handler.
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ev_initialize_op_regions(void)
+{
+	acpi_status status;
+	u32 i;
+
+	ACPI_FUNCTION_TRACE(ev_initialize_op_regions);
+
+	status = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/* Run the _REG methods for op_regions in each default address space */
+
+	for (i = 0; i < ACPI_NUM_DEFAULT_SPACES; i++) {
+		/*
+		 * Make sure the installed handler is the DEFAULT handler. If not the
+		 * default, the _REG methods will have already been run (when the
+		 * handler was installed)
+		 */
+		if (acpi_ev_has_default_handler(acpi_gbl_root_node,
+						acpi_gbl_default_address_spaces
+						[i])) {
+			status =
+			    acpi_ev_execute_reg_methods(acpi_gbl_root_node,
+							acpi_gbl_default_address_spaces
+							[i]);
+		}
+	}
+
+	acpi_gbl_reg_methods_executed = TRUE;
+
+	(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_execute_reg_method
+ *
+ * PARAMETERS:  region_obj          - Region object
+ *              Function            - Passed to _REG: On (1) or Off (0)
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Execute _REG method for a region
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ev_execute_reg_method(union acpi_operand_object *region_obj, u32 function)
+{
+	struct acpi_evaluate_info *info;
+	union acpi_operand_object *args[3];
+	union acpi_operand_object *region_obj2;
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(ev_execute_reg_method);
+
+	region_obj2 = acpi_ns_get_secondary_object(region_obj);
+	if (!region_obj2) {
+		return_ACPI_STATUS(AE_NOT_EXIST);
+	}
+
+	if (region_obj2->extra.method_REG == NULL) {
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	/* Allocate and initialize the evaluation information block */
+
+	info = ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_evaluate_info));
+	if (!info) {
+		return_ACPI_STATUS(AE_NO_MEMORY);
+	}
+
+	info->prefix_node = region_obj2->extra.method_REG;
+	info->pathname = NULL;
+	info->parameters = args;
+	info->flags = ACPI_IGNORE_RETURN_VALUE;
+
+	/*
+	 * The _REG method has two arguments:
+	 *
+	 * Arg0 - Integer:
+	 *  Operation region space ID Same value as region_obj->Region.space_id
+	 *
+	 * Arg1 - Integer:
+	 *  connection status 1 for connecting the handler, 0 for disconnecting
+	 *  the handler (Passed as a parameter)
+	 */
+	args[0] =
+	    acpi_ut_create_integer_object((u64)region_obj->region.space_id);
+	if (!args[0]) {
+		status = AE_NO_MEMORY;
+		goto cleanup1;
+	}
+
+	args[1] = acpi_ut_create_integer_object((u64)function);
+	if (!args[1]) {
+		status = AE_NO_MEMORY;
+		goto cleanup2;
+	}
+
+	args[2] = NULL;		/* Terminate list */
+
+	/* Execute the method, no return value */
+
+	ACPI_DEBUG_EXEC(acpi_ut_display_init_pathname
+			(ACPI_TYPE_METHOD, info->prefix_node, NULL));
+
+	status = acpi_ns_evaluate(info);
+	acpi_ut_remove_reference(args[1]);
+
+      cleanup2:
+	acpi_ut_remove_reference(args[0]);
+
+      cleanup1:
+	ACPI_FREE(info);
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_address_space_dispatch
+ *
+ * PARAMETERS:  region_obj          - Internal region object
+ *              field_obj           - Corresponding field. Can be NULL.
+ *              Function            - Read or Write operation
+ *              region_offset       - Where in the region to read or write
+ *              bit_width           - Field width in bits (8, 16, 32, or 64)
+ *              Value               - Pointer to in or out value, must be
+ *                                    a full 64-bit integer
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Dispatch an address space or operation region access to
+ *              a previously installed handler.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ev_address_space_dispatch(union acpi_operand_object *region_obj,
+			       union acpi_operand_object *field_obj,
+			       u32 function,
+			       u32 region_offset, u32 bit_width, u64 *value)
+{
+	acpi_status status;
+	acpi_adr_space_handler handler;
+	acpi_adr_space_setup region_setup;
+	union acpi_operand_object *handler_desc;
+	union acpi_operand_object *region_obj2;
+	void *region_context = NULL;
+	struct acpi_connection_info *context;
+
+	ACPI_FUNCTION_TRACE(ev_address_space_dispatch);
+
+	region_obj2 = acpi_ns_get_secondary_object(region_obj);
+	if (!region_obj2) {
+		return_ACPI_STATUS(AE_NOT_EXIST);
+	}
+
+	/* Ensure that there is a handler associated with this region */
+
+	handler_desc = region_obj->region.handler;
+	if (!handler_desc) {
+		ACPI_ERROR((AE_INFO,
+			    "No handler for Region [%4.4s] (%p) [%s]",
+			    acpi_ut_get_node_name(region_obj->region.node),
+			    region_obj,
+			    acpi_ut_get_region_name(region_obj->region.
+						    space_id)));
+
+		return_ACPI_STATUS(AE_NOT_EXIST);
+	}
+
+	context = handler_desc->address_space.context;
+
+	/*
+	 * It may be the case that the region has never been initialized.
+	 * Some types of regions require special init code
+	 */
+	if (!(region_obj->region.flags & AOPOBJ_SETUP_COMPLETE)) {
+
+		/* This region has not been initialized yet, do it */
+
+		region_setup = handler_desc->address_space.setup;
+		if (!region_setup) {
+
+			/* No initialization routine, exit with error */
+
+			ACPI_ERROR((AE_INFO,
+				    "No init routine for region(%p) [%s]",
+				    region_obj,
+				    acpi_ut_get_region_name(region_obj->region.
+							    space_id)));
+			return_ACPI_STATUS(AE_NOT_EXIST);
+		}
+
+		/*
+		 * We must exit the interpreter because the region setup will
+		 * potentially execute control methods (for example, the _REG method
+		 * for this region)
+		 */
+		acpi_ex_exit_interpreter();
+
+		status = region_setup(region_obj, ACPI_REGION_ACTIVATE,
+				      context, &region_context);
+
+		/* Re-enter the interpreter */
+
+		acpi_ex_enter_interpreter();
+
+		/* Check for failure of the Region Setup */
+
+		if (ACPI_FAILURE(status)) {
+			ACPI_EXCEPTION((AE_INFO, status,
+					"During region initialization: [%s]",
+					acpi_ut_get_region_name(region_obj->
+								region.
+								space_id)));
+			return_ACPI_STATUS(status);
+		}
+
+		/* Region initialization may have been completed by region_setup */
+
+		if (!(region_obj->region.flags & AOPOBJ_SETUP_COMPLETE)) {
+			region_obj->region.flags |= AOPOBJ_SETUP_COMPLETE;
+
+			if (region_obj2->extra.region_context) {
+
+				/* The handler for this region was already installed */
+
+				ACPI_FREE(region_context);
+			} else {
+				/*
+				 * Save the returned context for use in all accesses to
+				 * this particular region
+				 */
+				region_obj2->extra.region_context =
+				    region_context;
+			}
+		}
+	}
+
+	/* We have everything we need, we can invoke the address space handler */
+
+	handler = handler_desc->address_space.handler;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_OPREGION,
+			  "Handler %p (@%p) Address %8.8X%8.8X [%s]\n",
+			  &region_obj->region.handler->address_space, handler,
+			  ACPI_FORMAT_NATIVE_UINT(region_obj->region.address +
+						  region_offset),
+			  acpi_ut_get_region_name(region_obj->region.
+						  space_id)));
+
+	/*
+	 * Special handling for generic_serial_bus and general_purpose_io:
+	 * There are three extra parameters that must be passed to the
+	 * handler via the context:
+	 *   1) Connection buffer, a resource template from Connection() op.
+	 *   2) Length of the above buffer.
+	 *   3) Actual access length from the access_as() op.
+	 */
+	if (((region_obj->region.space_id == ACPI_ADR_SPACE_GSBUS) ||
+	     (region_obj->region.space_id == ACPI_ADR_SPACE_GPIO)) &&
+	    context && field_obj) {
+
+		/* Get the Connection (resource_template) buffer */
+
+		context->connection = field_obj->field.resource_buffer;
+		context->length = field_obj->field.resource_length;
+		context->access_length = field_obj->field.access_length;
+	}
+
+	if (!(handler_desc->address_space.handler_flags &
+	      ACPI_ADDR_HANDLER_DEFAULT_INSTALLED)) {
+		/*
+		 * For handlers other than the default (supplied) handlers, we must
+		 * exit the interpreter because the handler *might* block -- we don't
+		 * know what it will do, so we can't hold the lock on the intepreter.
+		 */
+		acpi_ex_exit_interpreter();
+	}
+
+	/* Call the handler */
+
+	status = handler(function,
+			 (region_obj->region.address + region_offset),
+			 bit_width, value, context,
+			 region_obj2->extra.region_context);
+
+	if (ACPI_FAILURE(status)) {
+		ACPI_EXCEPTION((AE_INFO, status, "Returned by Handler for [%s]",
+				acpi_ut_get_region_name(region_obj->region.
+							space_id)));
+	}
+
+	if (!(handler_desc->address_space.handler_flags &
+	      ACPI_ADDR_HANDLER_DEFAULT_INSTALLED)) {
+		/*
+		 * We just returned from a non-default handler, we must re-enter the
+		 * interpreter
+		 */
+		acpi_ex_enter_interpreter();
+	}
+
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_detach_region
+ *
+ * PARAMETERS:  region_obj          - Region Object
+ *              acpi_ns_is_locked   - Namespace Region Already Locked?
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Break the association between the handler and the region
+ *              this is a two way association.
+ *
+ ******************************************************************************/
+
+void
+acpi_ev_detach_region(union acpi_operand_object *region_obj,
+		      u8 acpi_ns_is_locked)
+{
+	union acpi_operand_object *handler_obj;
+	union acpi_operand_object *obj_desc;
+	union acpi_operand_object **last_obj_ptr;
+	acpi_adr_space_setup region_setup;
+	void **region_context;
+	union acpi_operand_object *region_obj2;
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(ev_detach_region);
+
+	region_obj2 = acpi_ns_get_secondary_object(region_obj);
+	if (!region_obj2) {
+		return_VOID;
+	}
+	region_context = &region_obj2->extra.region_context;
+
+	/* Get the address handler from the region object */
+
+	handler_obj = region_obj->region.handler;
+	if (!handler_obj) {
+
+		/* This region has no handler, all done */
+
+		return_VOID;
+	}
+
+	/* Find this region in the handler's list */
+
+	obj_desc = handler_obj->address_space.region_list;
+	last_obj_ptr = &handler_obj->address_space.region_list;
+
+	while (obj_desc) {
+
+		/* Is this the correct Region? */
+
+		if (obj_desc == region_obj) {
+			ACPI_DEBUG_PRINT((ACPI_DB_OPREGION,
+					  "Removing Region %p from address handler %p\n",
+					  region_obj, handler_obj));
+
+			/* This is it, remove it from the handler's list */
+
+			*last_obj_ptr = obj_desc->region.next;
+			obj_desc->region.next = NULL;	/* Must clear field */
+
+			if (acpi_ns_is_locked) {
+				status =
+				    acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);
+				if (ACPI_FAILURE(status)) {
+					return_VOID;
+				}
+			}
+
+			/* Now stop region accesses by executing the _REG method */
+
+			status =
+			    acpi_ev_execute_reg_method(region_obj,
+						       ACPI_REG_DISCONNECT);
+			if (ACPI_FAILURE(status)) {
+				ACPI_EXCEPTION((AE_INFO, status,
+						"from region _REG, [%s]",
+						acpi_ut_get_region_name
+						(region_obj->region.space_id)));
+			}
+
+			if (acpi_ns_is_locked) {
+				status =
+				    acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);
+				if (ACPI_FAILURE(status)) {
+					return_VOID;
+				}
+			}
+
+			/*
+			 * If the region has been activated, call the setup handler with
+			 * the deactivate notification
+			 */
+			if (region_obj->region.flags & AOPOBJ_SETUP_COMPLETE) {
+				region_setup = handler_obj->address_space.setup;
+				status =
+				    region_setup(region_obj,
+						 ACPI_REGION_DEACTIVATE,
+						 handler_obj->address_space.
+						 context, region_context);
+
+				/* Init routine may fail, Just ignore errors */
+
+				if (ACPI_FAILURE(status)) {
+					ACPI_EXCEPTION((AE_INFO, status,
+							"from region handler - deactivate, [%s]",
+							acpi_ut_get_region_name
+							(region_obj->region.
+							 space_id)));
+				}
+
+				region_obj->region.flags &=
+				    ~(AOPOBJ_SETUP_COMPLETE);
+			}
+
+			/*
+			 * Remove handler reference in the region
+			 *
+			 * NOTE: this doesn't mean that the region goes away, the region
+			 * is just inaccessible as indicated to the _REG method
+			 *
+			 * If the region is on the handler's list, this must be the
+			 * region's handler
+			 */
+			region_obj->region.handler = NULL;
+			acpi_ut_remove_reference(handler_obj);
+
+			return_VOID;
+		}
+
+		/* Walk the linked list of handlers */
+
+		last_obj_ptr = &obj_desc->region.next;
+		obj_desc = obj_desc->region.next;
+	}
+
+	/* If we get here, the region was not in the handler's region list */
+
+	ACPI_DEBUG_PRINT((ACPI_DB_OPREGION,
+			  "Cannot remove region %p from address handler %p\n",
+			  region_obj, handler_obj));
+
+	return_VOID;
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_attach_region
+ *
+ * PARAMETERS:  handler_obj         - Handler Object
+ *              region_obj          - Region Object
+ *              acpi_ns_is_locked   - Namespace Region Already Locked?
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Create the association between the handler and the region
+ *              this is a two way association.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ev_attach_region(union acpi_operand_object *handler_obj,
+		      union acpi_operand_object *region_obj,
+		      u8 acpi_ns_is_locked)
+{
+
+	ACPI_FUNCTION_TRACE(ev_attach_region);
+
+	ACPI_DEBUG_PRINT((ACPI_DB_OPREGION,
+			  "Adding Region [%4.4s] %p to address handler %p [%s]\n",
+			  acpi_ut_get_node_name(region_obj->region.node),
+			  region_obj, handler_obj,
+			  acpi_ut_get_region_name(region_obj->region.
+						  space_id)));
+
+	/* Link this region to the front of the handler's list */
+
+	region_obj->region.next = handler_obj->address_space.region_list;
+	handler_obj->address_space.region_list = region_obj;
+
+	/* Install the region's handler */
+
+	if (region_obj->region.handler) {
+		return_ACPI_STATUS(AE_ALREADY_EXISTS);
+	}
+
+	region_obj->region.handler = handler_obj;
+	acpi_ut_add_reference(handler_obj);
+
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_install_handler
+ *
+ * PARAMETERS:  walk_namespace callback
+ *
+ * DESCRIPTION: This routine installs an address handler into objects that are
+ *              of type Region or Device.
+ *
+ *              If the Object is a Device, and the device has a handler of
+ *              the same type then the search is terminated in that branch.
+ *
+ *              This is because the existing handler is closer in proximity
+ *              to any more regions than the one we are trying to install.
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ev_install_handler(acpi_handle obj_handle,
+			u32 level, void *context, void **return_value)
+{
+	union acpi_operand_object *handler_obj;
+	union acpi_operand_object *next_handler_obj;
+	union acpi_operand_object *obj_desc;
+	struct acpi_namespace_node *node;
+	acpi_status status;
+
+	ACPI_FUNCTION_NAME(ev_install_handler);
+
+	handler_obj = (union acpi_operand_object *)context;
+
+	/* Parameter validation */
+
+	if (!handler_obj) {
+		return (AE_OK);
+	}
+
+	/* Convert and validate the device handle */
+
+	node = acpi_ns_validate_handle(obj_handle);
+	if (!node) {
+		return (AE_BAD_PARAMETER);
+	}
+
+	/*
+	 * We only care about regions and objects that are allowed to have
+	 * address space handlers
+	 */
+	if ((node->type != ACPI_TYPE_DEVICE) &&
+	    (node->type != ACPI_TYPE_REGION) && (node != acpi_gbl_root_node)) {
+		return (AE_OK);
+	}
+
+	/* Check for an existing internal object */
+
+	obj_desc = acpi_ns_get_attached_object(node);
+	if (!obj_desc) {
+
+		/* No object, just exit */
+
+		return (AE_OK);
+	}
+
+	/* Devices are handled different than regions */
+
+	if (obj_desc->common.type == ACPI_TYPE_DEVICE) {
+
+		/* Check if this Device already has a handler for this address space */
+
+		next_handler_obj = obj_desc->device.handler;
+		while (next_handler_obj) {
+
+			/* Found a handler, is it for the same address space? */
+
+			if (next_handler_obj->address_space.space_id ==
+			    handler_obj->address_space.space_id) {
+				ACPI_DEBUG_PRINT((ACPI_DB_OPREGION,
+						  "Found handler for region [%s] in device %p(%p) "
+						  "handler %p\n",
+						  acpi_ut_get_region_name
+						  (handler_obj->address_space.
+						   space_id), obj_desc,
+						  next_handler_obj,
+						  handler_obj));
+
+				/*
+				 * Since the object we found it on was a device, then it
+				 * means that someone has already installed a handler for
+				 * the branch of the namespace from this device on. Just
+				 * bail out telling the walk routine to not traverse this
+				 * branch. This preserves the scoping rule for handlers.
+				 */
+				return (AE_CTRL_DEPTH);
+			}
+
+			/* Walk the linked list of handlers attached to this device */
+
+			next_handler_obj = next_handler_obj->address_space.next;
+		}
+
+		/*
+		 * As long as the device didn't have a handler for this space we
+		 * don't care about it. We just ignore it and proceed.
+		 */
+		return (AE_OK);
+	}
+
+	/* Object is a Region */
+
+	if (obj_desc->region.space_id != handler_obj->address_space.space_id) {
+
+		/* This region is for a different address space, just ignore it */
+
+		return (AE_OK);
+	}
+
+	/*
+	 * Now we have a region and it is for the handler's address space type.
+	 *
+	 * First disconnect region for any previous handler (if any)
+	 */
+	acpi_ev_detach_region(obj_desc, FALSE);
+
+	/* Connect the region to the new handler */
+
+	status = acpi_ev_attach_region(handler_obj, obj_desc, FALSE);
+	return (status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_install_space_handler
+ *
+ * PARAMETERS:  Node            - Namespace node for the device
+ *              space_id        - The address space ID
+ *              Handler         - Address of the handler
+ *              Setup           - Address of the setup function
+ *              Context         - Value passed to the handler on each access
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Install a handler for all op_regions of a given space_id.
+ *              Assumes namespace is locked
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ev_install_space_handler(struct acpi_namespace_node * node,
+			      acpi_adr_space_type space_id,
+			      acpi_adr_space_handler handler,
+			      acpi_adr_space_setup setup, void *context)
+{
+	union acpi_operand_object *obj_desc;
+	union acpi_operand_object *handler_obj;
+	acpi_status status;
+	acpi_object_type type;
+	u8 flags = 0;
+
+	ACPI_FUNCTION_TRACE(ev_install_space_handler);
+
+	/*
+	 * This registration is valid for only the types below and the root. This
+	 * is where the default handlers get placed.
+	 */
+	if ((node->type != ACPI_TYPE_DEVICE) &&
+	    (node->type != ACPI_TYPE_PROCESSOR) &&
+	    (node->type != ACPI_TYPE_THERMAL) && (node != acpi_gbl_root_node)) {
+		status = AE_BAD_PARAMETER;
+		goto unlock_and_exit;
+	}
+
+	if (handler == ACPI_DEFAULT_HANDLER) {
+		flags = ACPI_ADDR_HANDLER_DEFAULT_INSTALLED;
+
+		switch (space_id) {
+		case ACPI_ADR_SPACE_SYSTEM_MEMORY:
+			handler = acpi_ex_system_memory_space_handler;
+			setup = acpi_ev_system_memory_region_setup;
+			break;
+
+		case ACPI_ADR_SPACE_SYSTEM_IO:
+			handler = acpi_ex_system_io_space_handler;
+			setup = acpi_ev_io_space_region_setup;
+			break;
+
+		case ACPI_ADR_SPACE_PCI_CONFIG:
+			handler = acpi_ex_pci_config_space_handler;
+			setup = acpi_ev_pci_config_region_setup;
+			break;
+
+		case ACPI_ADR_SPACE_CMOS:
+			handler = acpi_ex_cmos_space_handler;
+			setup = acpi_ev_cmos_region_setup;
+			break;
+
+		case ACPI_ADR_SPACE_PCI_BAR_TARGET:
+			handler = acpi_ex_pci_bar_space_handler;
+			setup = acpi_ev_pci_bar_region_setup;
+			break;
+
+		case ACPI_ADR_SPACE_DATA_TABLE:
+			handler = acpi_ex_data_table_space_handler;
+			setup = NULL;
+			break;
+
+		default:
+			status = AE_BAD_PARAMETER;
+			goto unlock_and_exit;
+		}
+	}
+
+	/* If the caller hasn't specified a setup routine, use the default */
+
+	if (!setup) {
+		setup = acpi_ev_default_region_setup;
+	}
+
+	/* Check for an existing internal object */
+
+	obj_desc = acpi_ns_get_attached_object(node);
+	if (obj_desc) {
+		/*
+		 * The attached device object already exists. Make sure the handler
+		 * is not already installed.
+		 */
+		handler_obj = obj_desc->device.handler;
+
+		/* Walk the handler list for this device */
+
+		while (handler_obj) {
+
+			/* Same space_id indicates a handler already installed */
+
+			if (handler_obj->address_space.space_id == space_id) {
+				if (handler_obj->address_space.handler ==
+				    handler) {
+					/*
+					 * It is (relatively) OK to attempt to install the SAME
+					 * handler twice. This can easily happen with the
+					 * PCI_Config space.
+					 */
+					status = AE_SAME_HANDLER;
+					goto unlock_and_exit;
+				} else {
+					/* A handler is already installed */
+
+					status = AE_ALREADY_EXISTS;
+				}
+				goto unlock_and_exit;
+			}
+
+			/* Walk the linked list of handlers */
+
+			handler_obj = handler_obj->address_space.next;
+		}
+	} else {
+		ACPI_DEBUG_PRINT((ACPI_DB_OPREGION,
+				  "Creating object on Device %p while installing handler\n",
+				  node));
+
+		/* obj_desc does not exist, create one */
+
+		if (node->type == ACPI_TYPE_ANY) {
+			type = ACPI_TYPE_DEVICE;
+		} else {
+			type = node->type;
+		}
+
+		obj_desc = acpi_ut_create_internal_object(type);
+		if (!obj_desc) {
+			status = AE_NO_MEMORY;
+			goto unlock_and_exit;
+		}
+
+		/* Init new descriptor */
+
+		obj_desc->common.type = (u8)type;
+
+		/* Attach the new object to the Node */
+
+		status = acpi_ns_attach_object(node, obj_desc, type);
+
+		/* Remove local reference to the object */
+
+		acpi_ut_remove_reference(obj_desc);
+
+		if (ACPI_FAILURE(status)) {
+			goto unlock_and_exit;
+		}
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_OPREGION,
+			  "Installing address handler for region %s(%X) on Device %4.4s %p(%p)\n",
+			  acpi_ut_get_region_name(space_id), space_id,
+			  acpi_ut_get_node_name(node), node, obj_desc));
+
+	/*
+	 * Install the handler
+	 *
+	 * At this point there is no existing handler. Just allocate the object
+	 * for the handler and link it into the list.
+	 */
+	handler_obj =
+	    acpi_ut_create_internal_object(ACPI_TYPE_LOCAL_ADDRESS_HANDLER);
+	if (!handler_obj) {
+		status = AE_NO_MEMORY;
+		goto unlock_and_exit;
+	}
+
+	/* Init handler obj */
+
+	handler_obj->address_space.space_id = (u8)space_id;
+	handler_obj->address_space.handler_flags = flags;
+	handler_obj->address_space.region_list = NULL;
+	handler_obj->address_space.node = node;
+	handler_obj->address_space.handler = handler;
+	handler_obj->address_space.context = context;
+	handler_obj->address_space.setup = setup;
+
+	/* Install at head of Device.address_space list */
+
+	handler_obj->address_space.next = obj_desc->device.handler;
+
+	/*
+	 * The Device object is the first reference on the handler_obj.
+	 * Each region that uses the handler adds a reference.
+	 */
+	obj_desc->device.handler = handler_obj;
+
+	/*
+	 * Walk the namespace finding all of the regions this
+	 * handler will manage.
+	 *
+	 * Start at the device and search the branch toward
+	 * the leaf nodes until either the leaf is encountered or
+	 * a device is detected that has an address handler of the
+	 * same type.
+	 *
+	 * In either case, back up and search down the remainder
+	 * of the branch
+	 */
+	status = acpi_ns_walk_namespace(ACPI_TYPE_ANY, node, ACPI_UINT32_MAX,
+					ACPI_NS_WALK_UNLOCK,
+					acpi_ev_install_handler, NULL,
+					handler_obj, NULL);
+
+      unlock_and_exit:
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_execute_reg_methods
+ *
+ * PARAMETERS:  Node            - Namespace node for the device
+ *              space_id        - The address space ID
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Run all _REG methods for the input Space ID;
+ *              Note: assumes namespace is locked, or system init time.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ev_execute_reg_methods(struct acpi_namespace_node *node,
+			    acpi_adr_space_type space_id)
+{
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(ev_execute_reg_methods);
+
+	/*
+	 * Run all _REG methods for all Operation Regions for this space ID. This
+	 * is a separate walk in order to handle any interdependencies between
+	 * regions and _REG methods. (i.e. handlers must be installed for all
+	 * regions of this Space ID before we can run any _REG methods)
+	 */
+	status = acpi_ns_walk_namespace(ACPI_TYPE_ANY, node, ACPI_UINT32_MAX,
+					ACPI_NS_WALK_UNLOCK, acpi_ev_reg_run,
+					NULL, &space_id, NULL);
+
+	/* Special case for EC: handle "orphan" _REG methods with no region */
+
+	if (space_id == ACPI_ADR_SPACE_EC) {
+		acpi_ev_orphan_ec_reg_method();
+	}
+
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_reg_run
+ *
+ * PARAMETERS:  walk_namespace callback
+ *
+ * DESCRIPTION: Run _REG method for region objects of the requested space_iD
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ev_reg_run(acpi_handle obj_handle,
+		u32 level, void *context, void **return_value)
+{
+	union acpi_operand_object *obj_desc;
+	struct acpi_namespace_node *node;
+	acpi_adr_space_type space_id;
+	acpi_status status;
+
+	space_id = *ACPI_CAST_PTR(acpi_adr_space_type, context);
+
+	/* Convert and validate the device handle */
+
+	node = acpi_ns_validate_handle(obj_handle);
+	if (!node) {
+		return (AE_BAD_PARAMETER);
+	}
+
+	/*
+	 * We only care about regions.and objects that are allowed to have address
+	 * space handlers
+	 */
+	if ((node->type != ACPI_TYPE_REGION) && (node != acpi_gbl_root_node)) {
+		return (AE_OK);
+	}
+
+	/* Check for an existing internal object */
+
+	obj_desc = acpi_ns_get_attached_object(node);
+	if (!obj_desc) {
+
+		/* No object, just exit */
+
+		return (AE_OK);
+	}
+
+	/* Object is a Region */
+
+	if (obj_desc->region.space_id != space_id) {
+
+		/* This region is for a different address space, just ignore it */
+
+		return (AE_OK);
+	}
+
+	status = acpi_ev_execute_reg_method(obj_desc, ACPI_REG_CONNECT);
+	return (status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_orphan_ec_reg_method
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Execute an "orphan" _REG method that appears under the EC
+ *              device. This is a _REG method that has no corresponding region
+ *              within the EC device scope. The orphan _REG method appears to
+ *              have been enabled by the description of the ECDT in the ACPI
+ *              specification: "The availability of the region space can be
+ *              detected by providing a _REG method object underneath the
+ *              Embedded Controller device."
+ *
+ *              To quickly access the EC device, we use the EC_ID that appears
+ *              within the ECDT. Otherwise, we would need to perform a time-
+ *              consuming namespace walk, executing _HID methods to find the
+ *              EC device.
+ *
+ ******************************************************************************/
+
+static void acpi_ev_orphan_ec_reg_method(void)
+{
+	struct acpi_table_ecdt *table;
+	acpi_status status;
+	struct acpi_object_list args;
+	union acpi_object objects[2];
+	struct acpi_namespace_node *ec_device_node;
+	struct acpi_namespace_node *reg_method;
+	struct acpi_namespace_node *next_node;
+
+	ACPI_FUNCTION_TRACE(ev_orphan_ec_reg_method);
+
+	/* Get the ECDT (if present in system) */
+
+	status = acpi_get_table(ACPI_SIG_ECDT, 0,
+				ACPI_CAST_INDIRECT_PTR(struct acpi_table_header,
+						       &table));
+	if (ACPI_FAILURE(status)) {
+		return_VOID;
+	}
+
+	/* We need a valid EC_ID string */
+
+	if (!(*table->id)) {
+		return_VOID;
+	}
+
+	/* Namespace is currently locked, must release */
+
+	(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);
+
+	/* Get a handle to the EC device referenced in the ECDT */
+
+	status = acpi_get_handle(NULL,
+				 ACPI_CAST_PTR(char, table->id),
+				 ACPI_CAST_PTR(acpi_handle, &ec_device_node));
+	if (ACPI_FAILURE(status)) {
+		goto exit;
+	}
+
+	/* Get a handle to a _REG method immediately under the EC device */
+
+	status = acpi_get_handle(ec_device_node,
+				 METHOD_NAME__REG, ACPI_CAST_PTR(acpi_handle,
+								 &reg_method));
+	if (ACPI_FAILURE(status)) {
+		goto exit;
+	}
+
+	/*
+	 * Execute the _REG method only if there is no Operation Region in
+	 * this scope with the Embedded Controller space ID. Otherwise, it
+	 * will already have been executed. Note, this allows for Regions
+	 * with other space IDs to be present; but the code below will then
+	 * execute the _REG method with the EC space ID argument.
+	 */
+	next_node = acpi_ns_get_next_node(ec_device_node, NULL);
+	while (next_node) {
+		if ((next_node->type == ACPI_TYPE_REGION) &&
+		    (next_node->object) &&
+		    (next_node->object->region.space_id == ACPI_ADR_SPACE_EC)) {
+			goto exit;	/* Do not execute _REG */
+		}
+		next_node = acpi_ns_get_next_node(ec_device_node, next_node);
+	}
+
+	/* Evaluate the _REG(EC,Connect) method */
+
+	args.count = 2;
+	args.pointer = objects;
+	objects[0].type = ACPI_TYPE_INTEGER;
+	objects[0].integer.value = ACPI_ADR_SPACE_EC;
+	objects[1].type = ACPI_TYPE_INTEGER;
+	objects[1].integer.value = ACPI_REG_CONNECT;
+
+	status = acpi_evaluate_object(reg_method, NULL, &args, NULL);
+
+      exit:
+	/* We ignore all errors from above, don't care */
+
+	status = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);
+	return_VOID;
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/evrgnini.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/evrgnini.c
new file mode 100644
index 00000000..e735a0c2
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/evrgnini.c
@@ -0,0 +1,673 @@
+/******************************************************************************
+ *
+ * Module Name: evrgnini- ACPI address_space (op_region) init
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acevents.h"
+#include "acnamesp.h"
+
+#define _COMPONENT          ACPI_EVENTS
+ACPI_MODULE_NAME("evrgnini")
+
+/* Local prototypes */
+static u8 acpi_ev_is_pci_root_bridge(struct acpi_namespace_node *node);
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_system_memory_region_setup
+ *
+ * PARAMETERS:  Handle              - Region we are interested in
+ *              Function            - Start or stop
+ *              handler_context     - Address space handler context
+ *              region_context      - Region specific context
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Setup a system_memory operation region
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ev_system_memory_region_setup(acpi_handle handle,
+				   u32 function,
+				   void *handler_context, void **region_context)
+{
+	union acpi_operand_object *region_desc =
+	    (union acpi_operand_object *)handle;
+	struct acpi_mem_space_context *local_region_context;
+
+	ACPI_FUNCTION_TRACE(ev_system_memory_region_setup);
+
+	if (function == ACPI_REGION_DEACTIVATE) {
+		if (*region_context) {
+			local_region_context =
+			    (struct acpi_mem_space_context *)*region_context;
+
+			/* Delete a cached mapping if present */
+
+			if (local_region_context->mapped_length) {
+				acpi_os_unmap_memory(local_region_context->
+						     mapped_logical_address,
+						     local_region_context->
+						     mapped_length);
+			}
+			ACPI_FREE(local_region_context);
+			*region_context = NULL;
+		}
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	/* Create a new context */
+
+	local_region_context =
+	    ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_mem_space_context));
+	if (!(local_region_context)) {
+		return_ACPI_STATUS(AE_NO_MEMORY);
+	}
+
+	/* Save the region length and address for use in the handler */
+
+	local_region_context->length = region_desc->region.length;
+	local_region_context->address = region_desc->region.address;
+
+	*region_context = local_region_context;
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_io_space_region_setup
+ *
+ * PARAMETERS:  Handle              - Region we are interested in
+ *              Function            - Start or stop
+ *              handler_context     - Address space handler context
+ *              region_context      - Region specific context
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Setup a IO operation region
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ev_io_space_region_setup(acpi_handle handle,
+			      u32 function,
+			      void *handler_context, void **region_context)
+{
+	ACPI_FUNCTION_TRACE(ev_io_space_region_setup);
+
+	if (function == ACPI_REGION_DEACTIVATE) {
+		*region_context = NULL;
+	} else {
+		*region_context = handler_context;
+	}
+
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_pci_config_region_setup
+ *
+ * PARAMETERS:  Handle              - Region we are interested in
+ *              Function            - Start or stop
+ *              handler_context     - Address space handler context
+ *              region_context      - Region specific context
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Setup a PCI_Config operation region
+ *
+ * MUTEX:       Assumes namespace is not locked
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ev_pci_config_region_setup(acpi_handle handle,
+				u32 function,
+				void *handler_context, void **region_context)
+{
+	acpi_status status = AE_OK;
+	u64 pci_value;
+	struct acpi_pci_id *pci_id = *region_context;
+	union acpi_operand_object *handler_obj;
+	struct acpi_namespace_node *parent_node;
+	struct acpi_namespace_node *pci_root_node;
+	struct acpi_namespace_node *pci_device_node;
+	union acpi_operand_object *region_obj =
+	    (union acpi_operand_object *)handle;
+
+	ACPI_FUNCTION_TRACE(ev_pci_config_region_setup);
+
+	handler_obj = region_obj->region.handler;
+	if (!handler_obj) {
+		/*
+		 * No installed handler. This shouldn't happen because the dispatch
+		 * routine checks before we get here, but we check again just in case.
+		 */
+		ACPI_DEBUG_PRINT((ACPI_DB_OPREGION,
+				  "Attempting to init a region %p, with no handler\n",
+				  region_obj));
+		return_ACPI_STATUS(AE_NOT_EXIST);
+	}
+
+	*region_context = NULL;
+	if (function == ACPI_REGION_DEACTIVATE) {
+		if (pci_id) {
+			ACPI_FREE(pci_id);
+		}
+		return_ACPI_STATUS(status);
+	}
+
+	parent_node = region_obj->region.node->parent;
+
+	/*
+	 * Get the _SEG and _BBN values from the device upon which the handler
+	 * is installed.
+	 *
+	 * We need to get the _SEG and _BBN objects relative to the PCI BUS device.
+	 * This is the device the handler has been registered to handle.
+	 */
+
+	/*
+	 * If the address_space.Node is still pointing to the root, we need
+	 * to scan upward for a PCI Root bridge and re-associate the op_region
+	 * handlers with that device.
+	 */
+	if (handler_obj->address_space.node == acpi_gbl_root_node) {
+
+		/* Start search from the parent object */
+
+		pci_root_node = parent_node;
+		while (pci_root_node != acpi_gbl_root_node) {
+
+			/* Get the _HID/_CID in order to detect a root_bridge */
+
+			if (acpi_ev_is_pci_root_bridge(pci_root_node)) {
+
+				/* Install a handler for this PCI root bridge */
+
+				status = acpi_install_address_space_handler((acpi_handle) pci_root_node, ACPI_ADR_SPACE_PCI_CONFIG, ACPI_DEFAULT_HANDLER, NULL, NULL);
+				if (ACPI_FAILURE(status)) {
+					if (status == AE_SAME_HANDLER) {
+						/*
+						 * It is OK if the handler is already installed on the
+						 * root bridge. Still need to return a context object
+						 * for the new PCI_Config operation region, however.
+						 */
+						status = AE_OK;
+					} else {
+						ACPI_EXCEPTION((AE_INFO, status,
+								"Could not install PciConfig handler "
+								"for Root Bridge %4.4s",
+								acpi_ut_get_node_name
+								(pci_root_node)));
+					}
+				}
+				break;
+			}
+
+			pci_root_node = pci_root_node->parent;
+		}
+
+		/* PCI root bridge not found, use namespace root node */
+	} else {
+		pci_root_node = handler_obj->address_space.node;
+	}
+
+	/*
+	 * If this region is now initialized, we are done.
+	 * (install_address_space_handler could have initialized it)
+	 */
+	if (region_obj->region.flags & AOPOBJ_SETUP_COMPLETE) {
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	/* Region is still not initialized. Create a new context */
+
+	pci_id = ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_pci_id));
+	if (!pci_id) {
+		return_ACPI_STATUS(AE_NO_MEMORY);
+	}
+
+	/*
+	 * For PCI_Config space access, we need the segment, bus, device and
+	 * function numbers. Acquire them here.
+	 *
+	 * Find the parent device object. (This allows the operation region to be
+	 * within a subscope under the device, such as a control method.)
+	 */
+	pci_device_node = region_obj->region.node;
+	while (pci_device_node && (pci_device_node->type != ACPI_TYPE_DEVICE)) {
+		pci_device_node = pci_device_node->parent;
+	}
+
+	if (!pci_device_node) {
+		ACPI_FREE(pci_id);
+		return_ACPI_STATUS(AE_AML_OPERAND_TYPE);
+	}
+
+	/*
+	 * Get the PCI device and function numbers from the _ADR object
+	 * contained in the parent's scope.
+	 */
+	status = acpi_ut_evaluate_numeric_object(METHOD_NAME__ADR,
+						 pci_device_node, &pci_value);
+
+	/*
+	 * The default is zero, and since the allocation above zeroed the data,
+	 * just do nothing on failure.
+	 */
+	if (ACPI_SUCCESS(status)) {
+		pci_id->device = ACPI_HIWORD(ACPI_LODWORD(pci_value));
+		pci_id->function = ACPI_LOWORD(ACPI_LODWORD(pci_value));
+	}
+
+	/* The PCI segment number comes from the _SEG method */
+
+	status = acpi_ut_evaluate_numeric_object(METHOD_NAME__SEG,
+						 pci_root_node, &pci_value);
+	if (ACPI_SUCCESS(status)) {
+		pci_id->segment = ACPI_LOWORD(pci_value);
+	}
+
+	/* The PCI bus number comes from the _BBN method */
+
+	status = acpi_ut_evaluate_numeric_object(METHOD_NAME__BBN,
+						 pci_root_node, &pci_value);
+	if (ACPI_SUCCESS(status)) {
+		pci_id->bus = ACPI_LOWORD(pci_value);
+	}
+
+	/* Complete/update the PCI ID for this device */
+
+	status =
+	    acpi_hw_derive_pci_id(pci_id, pci_root_node,
+				  region_obj->region.node);
+	if (ACPI_FAILURE(status)) {
+		ACPI_FREE(pci_id);
+		return_ACPI_STATUS(status);
+	}
+
+	*region_context = pci_id;
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_is_pci_root_bridge
+ *
+ * PARAMETERS:  Node            - Device node being examined
+ *
+ * RETURN:      TRUE if device is a PCI/PCI-Express Root Bridge
+ *
+ * DESCRIPTION: Determine if the input device represents a PCI Root Bridge by
+ *              examining the _HID and _CID for the device.
+ *
+ ******************************************************************************/
+
+static u8 acpi_ev_is_pci_root_bridge(struct acpi_namespace_node *node)
+{
+	acpi_status status;
+	struct acpi_device_id *hid;
+	struct acpi_device_id_list *cid;
+	u32 i;
+	u8 match;
+
+	/* Get the _HID and check for a PCI Root Bridge */
+
+	status = acpi_ut_execute_HID(node, &hid);
+	if (ACPI_FAILURE(status)) {
+		return (FALSE);
+	}
+
+	match = acpi_ut_is_pci_root_bridge(hid->string);
+	ACPI_FREE(hid);
+
+	if (match) {
+		return (TRUE);
+	}
+
+	/* The _HID did not match. Get the _CID and check for a PCI Root Bridge */
+
+	status = acpi_ut_execute_CID(node, &cid);
+	if (ACPI_FAILURE(status)) {
+		return (FALSE);
+	}
+
+	/* Check all _CIDs in the returned list */
+
+	for (i = 0; i < cid->count; i++) {
+		if (acpi_ut_is_pci_root_bridge(cid->ids[i].string)) {
+			ACPI_FREE(cid);
+			return (TRUE);
+		}
+	}
+
+	ACPI_FREE(cid);
+	return (FALSE);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_pci_bar_region_setup
+ *
+ * PARAMETERS:  Handle              - Region we are interested in
+ *              Function            - Start or stop
+ *              handler_context     - Address space handler context
+ *              region_context      - Region specific context
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Setup a pci_bAR operation region
+ *
+ * MUTEX:       Assumes namespace is not locked
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ev_pci_bar_region_setup(acpi_handle handle,
+			     u32 function,
+			     void *handler_context, void **region_context)
+{
+	ACPI_FUNCTION_TRACE(ev_pci_bar_region_setup);
+
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_cmos_region_setup
+ *
+ * PARAMETERS:  Handle              - Region we are interested in
+ *              Function            - Start or stop
+ *              handler_context     - Address space handler context
+ *              region_context      - Region specific context
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Setup a CMOS operation region
+ *
+ * MUTEX:       Assumes namespace is not locked
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ev_cmos_region_setup(acpi_handle handle,
+			  u32 function,
+			  void *handler_context, void **region_context)
+{
+	ACPI_FUNCTION_TRACE(ev_cmos_region_setup);
+
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_default_region_setup
+ *
+ * PARAMETERS:  Handle              - Region we are interested in
+ *              Function            - Start or stop
+ *              handler_context     - Address space handler context
+ *              region_context      - Region specific context
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Default region initialization
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ev_default_region_setup(acpi_handle handle,
+			     u32 function,
+			     void *handler_context, void **region_context)
+{
+	ACPI_FUNCTION_TRACE(ev_default_region_setup);
+
+	if (function == ACPI_REGION_DEACTIVATE) {
+		*region_context = NULL;
+	} else {
+		*region_context = handler_context;
+	}
+
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_initialize_region
+ *
+ * PARAMETERS:  region_obj      - Region we are initializing
+ *              acpi_ns_locked  - Is namespace locked?
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Initializes the region, finds any _REG methods and saves them
+ *              for execution at a later time
+ *
+ *              Get the appropriate address space handler for a newly
+ *              created region.
+ *
+ *              This also performs address space specific initialization. For
+ *              example, PCI regions must have an _ADR object that contains
+ *              a PCI address in the scope of the definition. This address is
+ *              required to perform an access to PCI config space.
+ *
+ * MUTEX:       Interpreter should be unlocked, because we may run the _REG
+ *              method for this region.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ev_initialize_region(union acpi_operand_object *region_obj,
+			  u8 acpi_ns_locked)
+{
+	union acpi_operand_object *handler_obj;
+	union acpi_operand_object *obj_desc;
+	acpi_adr_space_type space_id;
+	struct acpi_namespace_node *node;
+	acpi_status status;
+	struct acpi_namespace_node *method_node;
+	acpi_name *reg_name_ptr = (acpi_name *) METHOD_NAME__REG;
+	union acpi_operand_object *region_obj2;
+
+	ACPI_FUNCTION_TRACE_U32(ev_initialize_region, acpi_ns_locked);
+
+	if (!region_obj) {
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	if (region_obj->common.flags & AOPOBJ_OBJECT_INITIALIZED) {
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	region_obj2 = acpi_ns_get_secondary_object(region_obj);
+	if (!region_obj2) {
+		return_ACPI_STATUS(AE_NOT_EXIST);
+	}
+
+	node = region_obj->region.node->parent;
+	space_id = region_obj->region.space_id;
+
+	/* Setup defaults */
+
+	region_obj->region.handler = NULL;
+	region_obj2->extra.method_REG = NULL;
+	region_obj->common.flags &= ~(AOPOBJ_SETUP_COMPLETE);
+	region_obj->common.flags |= AOPOBJ_OBJECT_INITIALIZED;
+
+	/* Find any "_REG" method associated with this region definition */
+
+	status =
+	    acpi_ns_search_one_scope(*reg_name_ptr, node, ACPI_TYPE_METHOD,
+				     &method_node);
+	if (ACPI_SUCCESS(status)) {
+		/*
+		 * The _REG method is optional and there can be only one per region
+		 * definition. This will be executed when the handler is attached
+		 * or removed
+		 */
+		region_obj2->extra.method_REG = method_node;
+	}
+
+	/*
+	 * The following loop depends upon the root Node having no parent
+	 * ie: acpi_gbl_root_node->parent_entry being set to NULL
+	 */
+	while (node) {
+
+		/* Check to see if a handler exists */
+
+		handler_obj = NULL;
+		obj_desc = acpi_ns_get_attached_object(node);
+		if (obj_desc) {
+
+			/* Can only be a handler if the object exists */
+
+			switch (node->type) {
+			case ACPI_TYPE_DEVICE:
+
+				handler_obj = obj_desc->device.handler;
+				break;
+
+			case ACPI_TYPE_PROCESSOR:
+
+				handler_obj = obj_desc->processor.handler;
+				break;
+
+			case ACPI_TYPE_THERMAL:
+
+				handler_obj = obj_desc->thermal_zone.handler;
+				break;
+
+			case ACPI_TYPE_METHOD:
+				/*
+				 * If we are executing module level code, the original
+				 * Node's object was replaced by this Method object and we
+				 * saved the handler in the method object.
+				 *
+				 * See acpi_ns_exec_module_code
+				 */
+				if (obj_desc->method.
+				    info_flags & ACPI_METHOD_MODULE_LEVEL) {
+					handler_obj =
+					    obj_desc->method.dispatch.handler;
+				}
+				break;
+
+			default:
+				/* Ignore other objects */
+				break;
+			}
+
+			while (handler_obj) {
+
+				/* Is this handler of the correct type? */
+
+				if (handler_obj->address_space.space_id ==
+				    space_id) {
+
+					/* Found correct handler */
+
+					ACPI_DEBUG_PRINT((ACPI_DB_OPREGION,
+							  "Found handler %p for region %p in obj %p\n",
+							  handler_obj,
+							  region_obj,
+							  obj_desc));
+
+					status =
+					    acpi_ev_attach_region(handler_obj,
+								  region_obj,
+								  acpi_ns_locked);
+
+					/*
+					 * Tell all users that this region is usable by
+					 * running the _REG method
+					 */
+					if (acpi_ns_locked) {
+						status =
+						    acpi_ut_release_mutex
+						    (ACPI_MTX_NAMESPACE);
+						if (ACPI_FAILURE(status)) {
+							return_ACPI_STATUS
+							    (status);
+						}
+					}
+
+					status =
+					    acpi_ev_execute_reg_method
+					    (region_obj, ACPI_REG_CONNECT);
+
+					if (acpi_ns_locked) {
+						status =
+						    acpi_ut_acquire_mutex
+						    (ACPI_MTX_NAMESPACE);
+						if (ACPI_FAILURE(status)) {
+							return_ACPI_STATUS
+							    (status);
+						}
+					}
+
+					return_ACPI_STATUS(AE_OK);
+				}
+
+				/* Try next handler in the list */
+
+				handler_obj = handler_obj->address_space.next;
+			}
+		}
+
+		/* This node does not have the handler we need; Pop up one level */
+
+		node = node->parent;
+	}
+
+	/* If we get here, there is no handler for this region */
+
+	ACPI_DEBUG_PRINT((ACPI_DB_OPREGION,
+			  "No handler for RegionType %s(%X) (RegionObj %p)\n",
+			  acpi_ut_get_region_name(space_id), space_id,
+			  region_obj));
+
+	return_ACPI_STATUS(AE_NOT_EXIST);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/evsci.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/evsci.c
new file mode 100644
index 00000000..408fd8dc
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/evsci.c
@@ -0,0 +1,184 @@
+/*******************************************************************************
+ *
+ * Module Name: evsci - System Control Interrupt configuration and
+ *                      legacy to ACPI mode state transition functions
+ *
+ ******************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acevents.h"
+
+#define _COMPONENT          ACPI_EVENTS
+ACPI_MODULE_NAME("evsci")
+
+/* Local prototypes */
+static u32 ACPI_SYSTEM_XFACE acpi_ev_sci_xrupt_handler(void *context);
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_sci_xrupt_handler
+ *
+ * PARAMETERS:  Context   - Calling Context
+ *
+ * RETURN:      Status code indicates whether interrupt was handled.
+ *
+ * DESCRIPTION: Interrupt handler that will figure out what function or
+ *              control method to call to deal with a SCI.
+ *
+ ******************************************************************************/
+
+static u32 ACPI_SYSTEM_XFACE acpi_ev_sci_xrupt_handler(void *context)
+{
+	struct acpi_gpe_xrupt_info *gpe_xrupt_list = context;
+	u32 interrupt_handled = ACPI_INTERRUPT_NOT_HANDLED;
+
+	ACPI_FUNCTION_TRACE(ev_sci_xrupt_handler);
+
+	/*
+	 * We are guaranteed by the ACPI CA initialization/shutdown code that
+	 * if this interrupt handler is installed, ACPI is enabled.
+	 */
+
+	/*
+	 * Fixed Events:
+	 * Check for and dispatch any Fixed Events that have occurred
+	 */
+	interrupt_handled |= acpi_ev_fixed_event_detect();
+
+	/*
+	 * General Purpose Events:
+	 * Check for and dispatch any GPEs that have occurred
+	 */
+	interrupt_handled |= acpi_ev_gpe_detect(gpe_xrupt_list);
+
+	acpi_sci_count++;
+	return_UINT32(interrupt_handled);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_gpe_xrupt_handler
+ *
+ * PARAMETERS:  Context   - Calling Context
+ *
+ * RETURN:      Status code indicates whether interrupt was handled.
+ *
+ * DESCRIPTION: Handler for GPE Block Device interrupts
+ *
+ ******************************************************************************/
+
+u32 ACPI_SYSTEM_XFACE acpi_ev_gpe_xrupt_handler(void *context)
+{
+	struct acpi_gpe_xrupt_info *gpe_xrupt_list = context;
+	u32 interrupt_handled = ACPI_INTERRUPT_NOT_HANDLED;
+
+	ACPI_FUNCTION_TRACE(ev_gpe_xrupt_handler);
+
+	/*
+	 * We are guaranteed by the ACPI CA initialization/shutdown code that
+	 * if this interrupt handler is installed, ACPI is enabled.
+	 */
+
+	/* GPEs: Check for and dispatch any GPEs that have occurred */
+
+	interrupt_handled |= acpi_ev_gpe_detect(gpe_xrupt_list);
+
+	return_UINT32(interrupt_handled);
+}
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_install_sci_handler
+ *
+ * PARAMETERS:  none
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Installs SCI handler.
+ *
+ ******************************************************************************/
+
+u32 acpi_ev_install_sci_handler(void)
+{
+	u32 status = AE_OK;
+
+	ACPI_FUNCTION_TRACE(ev_install_sci_handler);
+
+	status =
+	    acpi_os_install_interrupt_handler((u32)acpi_gbl_FADT.sci_interrupt,
+					      acpi_ev_sci_xrupt_handler,
+					      acpi_gbl_gpe_xrupt_list_head);
+	return_ACPI_STATUS(status);
+}
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_remove_sci_handler
+ *
+ * PARAMETERS:  none
+ *
+ * RETURN:      E_OK if handler uninstalled OK, E_ERROR if handler was not
+ *              installed to begin with
+ *
+ * DESCRIPTION: Remove the SCI interrupt handler. No further SCIs will be
+ *              taken.
+ *
+ * Note:  It doesn't seem important to disable all events or set the event
+ *        enable registers to their original values. The OS should disable
+ *        the SCI interrupt level when the handler is removed, so no more
+ *        events will come in.
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ev_remove_sci_handler(void)
+{
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(ev_remove_sci_handler);
+
+	/* Just let the OS remove the handler and disable the level */
+
+	status =
+	    acpi_os_remove_interrupt_handler((u32)acpi_gbl_FADT.sci_interrupt,
+					     acpi_ev_sci_xrupt_handler);
+
+	return_ACPI_STATUS(status);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/evxface.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/evxface.c
new file mode 100644
index 00000000..c04e34d2
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/evxface.c
@@ -0,0 +1,853 @@
+/******************************************************************************
+ *
+ * Module Name: evxface - External interfaces for ACPI events
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acnamesp.h"
+#include "acevents.h"
+#include "acinterp.h"
+
+#define _COMPONENT          ACPI_EVENTS
+ACPI_MODULE_NAME("evxface")
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_install_exception_handler
+ *
+ * PARAMETERS:  Handler         - Pointer to the handler function for the
+ *                                event
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Saves the pointer to the handler function
+ *
+ ******************************************************************************/
+acpi_status acpi_install_exception_handler(acpi_exception_handler handler)
+{
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(acpi_install_exception_handler);
+
+	status = acpi_ut_acquire_mutex(ACPI_MTX_EVENTS);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/* Don't allow two handlers. */
+
+	if (acpi_gbl_exception_handler) {
+		status = AE_ALREADY_EXISTS;
+		goto cleanup;
+	}
+
+	/* Install the handler */
+
+	acpi_gbl_exception_handler = handler;
+
+      cleanup:
+	(void)acpi_ut_release_mutex(ACPI_MTX_EVENTS);
+	return_ACPI_STATUS(status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_install_exception_handler)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_install_global_event_handler
+ *
+ * PARAMETERS:  Handler         - Pointer to the global event handler function
+ *              Context         - Value passed to the handler on each event
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Saves the pointer to the handler function. The global handler
+ *              is invoked upon each incoming GPE and Fixed Event. It is
+ *              invoked at interrupt level at the time of the event dispatch.
+ *              Can be used to update event counters, etc.
+ *
+ ******************************************************************************/
+acpi_status
+acpi_install_global_event_handler(acpi_gbl_event_handler handler, void *context)
+{
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(acpi_install_global_event_handler);
+
+	/* Parameter validation */
+
+	if (!handler) {
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	status = acpi_ut_acquire_mutex(ACPI_MTX_EVENTS);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/* Don't allow two handlers. */
+
+	if (acpi_gbl_global_event_handler) {
+		status = AE_ALREADY_EXISTS;
+		goto cleanup;
+	}
+
+	acpi_gbl_global_event_handler = handler;
+	acpi_gbl_global_event_handler_context = context;
+
+      cleanup:
+	(void)acpi_ut_release_mutex(ACPI_MTX_EVENTS);
+	return_ACPI_STATUS(status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_install_global_event_handler)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_install_fixed_event_handler
+ *
+ * PARAMETERS:  Event           - Event type to enable.
+ *              Handler         - Pointer to the handler function for the
+ *                                event
+ *              Context         - Value passed to the handler on each GPE
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Saves the pointer to the handler function and then enables the
+ *              event.
+ *
+ ******************************************************************************/
+acpi_status
+acpi_install_fixed_event_handler(u32 event,
+				 acpi_event_handler handler, void *context)
+{
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(acpi_install_fixed_event_handler);
+
+	/* Parameter validation */
+
+	if (event > ACPI_EVENT_MAX) {
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	status = acpi_ut_acquire_mutex(ACPI_MTX_EVENTS);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/* Don't allow two handlers. */
+
+	if (NULL != acpi_gbl_fixed_event_handlers[event].handler) {
+		status = AE_ALREADY_EXISTS;
+		goto cleanup;
+	}
+
+	/* Install the handler before enabling the event */
+
+	acpi_gbl_fixed_event_handlers[event].handler = handler;
+	acpi_gbl_fixed_event_handlers[event].context = context;
+
+	status = acpi_enable_event(event, 0);
+	if (ACPI_FAILURE(status)) {
+		ACPI_WARNING((AE_INFO, "Could not enable fixed event 0x%X",
+			      event));
+
+		/* Remove the handler */
+
+		acpi_gbl_fixed_event_handlers[event].handler = NULL;
+		acpi_gbl_fixed_event_handlers[event].context = NULL;
+	} else {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+				  "Enabled fixed event %X, Handler=%p\n", event,
+				  handler));
+	}
+
+      cleanup:
+	(void)acpi_ut_release_mutex(ACPI_MTX_EVENTS);
+	return_ACPI_STATUS(status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_install_fixed_event_handler)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_remove_fixed_event_handler
+ *
+ * PARAMETERS:  Event           - Event type to disable.
+ *              Handler         - Address of the handler
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Disables the event and unregisters the event handler.
+ *
+ ******************************************************************************/
+acpi_status
+acpi_remove_fixed_event_handler(u32 event, acpi_event_handler handler)
+{
+	acpi_status status = AE_OK;
+
+	ACPI_FUNCTION_TRACE(acpi_remove_fixed_event_handler);
+
+	/* Parameter validation */
+
+	if (event > ACPI_EVENT_MAX) {
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	status = acpi_ut_acquire_mutex(ACPI_MTX_EVENTS);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/* Disable the event before removing the handler */
+
+	status = acpi_disable_event(event, 0);
+
+	/* Always Remove the handler */
+
+	acpi_gbl_fixed_event_handlers[event].handler = NULL;
+	acpi_gbl_fixed_event_handlers[event].context = NULL;
+
+	if (ACPI_FAILURE(status)) {
+		ACPI_WARNING((AE_INFO,
+			      "Could not write to fixed event enable register 0x%X",
+			      event));
+	} else {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Disabled fixed event %X\n",
+				  event));
+	}
+
+	(void)acpi_ut_release_mutex(ACPI_MTX_EVENTS);
+	return_ACPI_STATUS(status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_remove_fixed_event_handler)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_install_notify_handler
+ *
+ * PARAMETERS:  Device          - The device for which notifies will be handled
+ *              handler_type    - The type of handler:
+ *                                  ACPI_SYSTEM_NOTIFY: system_handler (00-7f)
+ *                                  ACPI_DEVICE_NOTIFY: driver_handler (80-ff)
+ *                                  ACPI_ALL_NOTIFY:  both system and device
+ *              Handler         - Address of the handler
+ *              Context         - Value passed to the handler on each GPE
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Install a handler for notifies on an ACPI device
+ *
+ ******************************************************************************/
+acpi_status
+acpi_install_notify_handler(acpi_handle device,
+			    u32 handler_type,
+			    acpi_notify_handler handler, void *context)
+{
+	union acpi_operand_object *obj_desc;
+	union acpi_operand_object *notify_obj;
+	struct acpi_namespace_node *node;
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(acpi_install_notify_handler);
+
+	/* Parameter validation */
+
+	if ((!device) ||
+	    (!handler) || (handler_type > ACPI_MAX_NOTIFY_HANDLER_TYPE)) {
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	status = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/* Convert and validate the device handle */
+
+	node = acpi_ns_validate_handle(device);
+	if (!node) {
+		status = AE_BAD_PARAMETER;
+		goto unlock_and_exit;
+	}
+
+	/*
+	 * Root Object:
+	 * Registering a notify handler on the root object indicates that the
+	 * caller wishes to receive notifications for all objects. Note that
+	 * only one <external> global handler can be regsitered (per notify type).
+	 */
+	if (device == ACPI_ROOT_OBJECT) {
+
+		/* Make sure the handler is not already installed */
+
+		if (((handler_type & ACPI_SYSTEM_NOTIFY) &&
+		     acpi_gbl_system_notify.handler) ||
+		    ((handler_type & ACPI_DEVICE_NOTIFY) &&
+		     acpi_gbl_device_notify.handler)) {
+			status = AE_ALREADY_EXISTS;
+			goto unlock_and_exit;
+		}
+
+		if (handler_type & ACPI_SYSTEM_NOTIFY) {
+			acpi_gbl_system_notify.node = node;
+			acpi_gbl_system_notify.handler = handler;
+			acpi_gbl_system_notify.context = context;
+		}
+
+		if (handler_type & ACPI_DEVICE_NOTIFY) {
+			acpi_gbl_device_notify.node = node;
+			acpi_gbl_device_notify.handler = handler;
+			acpi_gbl_device_notify.context = context;
+		}
+
+		/* Global notify handler installed */
+	}
+
+	/*
+	 * All Other Objects:
+	 * Caller will only receive notifications specific to the target object.
+	 * Note that only certain object types can receive notifications.
+	 */
+	else {
+		/* Notifies allowed on this object? */
+
+		if (!acpi_ev_is_notify_object(node)) {
+			status = AE_TYPE;
+			goto unlock_and_exit;
+		}
+
+		/* Check for an existing internal object */
+
+		obj_desc = acpi_ns_get_attached_object(node);
+		if (obj_desc) {
+
+			/* Object exists - make sure there's no handler */
+
+			if (((handler_type & ACPI_SYSTEM_NOTIFY) &&
+			     obj_desc->common_notify.system_notify) ||
+			    ((handler_type & ACPI_DEVICE_NOTIFY) &&
+			     obj_desc->common_notify.device_notify)) {
+				status = AE_ALREADY_EXISTS;
+				goto unlock_and_exit;
+			}
+		} else {
+			/* Create a new object */
+
+			obj_desc = acpi_ut_create_internal_object(node->type);
+			if (!obj_desc) {
+				status = AE_NO_MEMORY;
+				goto unlock_and_exit;
+			}
+
+			/* Attach new object to the Node */
+
+			status =
+			    acpi_ns_attach_object(device, obj_desc, node->type);
+
+			/* Remove local reference to the object */
+
+			acpi_ut_remove_reference(obj_desc);
+			if (ACPI_FAILURE(status)) {
+				goto unlock_and_exit;
+			}
+		}
+
+		/* Install the handler */
+
+		notify_obj =
+		    acpi_ut_create_internal_object(ACPI_TYPE_LOCAL_NOTIFY);
+		if (!notify_obj) {
+			status = AE_NO_MEMORY;
+			goto unlock_and_exit;
+		}
+
+		notify_obj->notify.node = node;
+		notify_obj->notify.handler = handler;
+		notify_obj->notify.context = context;
+
+		if (handler_type & ACPI_SYSTEM_NOTIFY) {
+			obj_desc->common_notify.system_notify = notify_obj;
+		}
+
+		if (handler_type & ACPI_DEVICE_NOTIFY) {
+			obj_desc->common_notify.device_notify = notify_obj;
+		}
+
+		if (handler_type == ACPI_ALL_NOTIFY) {
+
+			/* Extra ref if installed in both */
+
+			acpi_ut_add_reference(notify_obj);
+		}
+	}
+
+      unlock_and_exit:
+	(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);
+	return_ACPI_STATUS(status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_install_notify_handler)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_remove_notify_handler
+ *
+ * PARAMETERS:  Device          - The device for which notifies will be handled
+ *              handler_type    - The type of handler:
+ *                                  ACPI_SYSTEM_NOTIFY: system_handler (00-7f)
+ *                                  ACPI_DEVICE_NOTIFY: driver_handler (80-ff)
+ *                                  ACPI_ALL_NOTIFY:  both system and device
+ *              Handler         - Address of the handler
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Remove a handler for notifies on an ACPI device
+ *
+ ******************************************************************************/
+acpi_status
+acpi_remove_notify_handler(acpi_handle device,
+			   u32 handler_type, acpi_notify_handler handler)
+{
+	union acpi_operand_object *notify_obj;
+	union acpi_operand_object *obj_desc;
+	struct acpi_namespace_node *node;
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(acpi_remove_notify_handler);
+
+	/* Parameter validation */
+
+	if ((!device) ||
+	    (!handler) || (handler_type > ACPI_MAX_NOTIFY_HANDLER_TYPE)) {
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	status = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/* Convert and validate the device handle */
+
+	node = acpi_ns_validate_handle(device);
+	if (!node) {
+		status = AE_BAD_PARAMETER;
+		goto unlock_and_exit;
+	}
+
+	/* Root Object */
+
+	if (device == ACPI_ROOT_OBJECT) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+				  "Removing notify handler for namespace root object\n"));
+
+		if (((handler_type & ACPI_SYSTEM_NOTIFY) &&
+		     !acpi_gbl_system_notify.handler) ||
+		    ((handler_type & ACPI_DEVICE_NOTIFY) &&
+		     !acpi_gbl_device_notify.handler)) {
+			status = AE_NOT_EXIST;
+			goto unlock_and_exit;
+		}
+
+		if (handler_type & ACPI_SYSTEM_NOTIFY) {
+			acpi_gbl_system_notify.node = NULL;
+			acpi_gbl_system_notify.handler = NULL;
+			acpi_gbl_system_notify.context = NULL;
+		}
+
+		if (handler_type & ACPI_DEVICE_NOTIFY) {
+			acpi_gbl_device_notify.node = NULL;
+			acpi_gbl_device_notify.handler = NULL;
+			acpi_gbl_device_notify.context = NULL;
+		}
+	}
+
+	/* All Other Objects */
+
+	else {
+		/* Notifies allowed on this object? */
+
+		if (!acpi_ev_is_notify_object(node)) {
+			status = AE_TYPE;
+			goto unlock_and_exit;
+		}
+
+		/* Check for an existing internal object */
+
+		obj_desc = acpi_ns_get_attached_object(node);
+		if (!obj_desc) {
+			status = AE_NOT_EXIST;
+			goto unlock_and_exit;
+		}
+
+		/* Object exists - make sure there's an existing handler */
+
+		if (handler_type & ACPI_SYSTEM_NOTIFY) {
+			notify_obj = obj_desc->common_notify.system_notify;
+			if (!notify_obj) {
+				status = AE_NOT_EXIST;
+				goto unlock_and_exit;
+			}
+
+			if (notify_obj->notify.handler != handler) {
+				status = AE_BAD_PARAMETER;
+				goto unlock_and_exit;
+			}
+
+			/* Remove the handler */
+
+			obj_desc->common_notify.system_notify = NULL;
+			acpi_ut_remove_reference(notify_obj);
+		}
+
+		if (handler_type & ACPI_DEVICE_NOTIFY) {
+			notify_obj = obj_desc->common_notify.device_notify;
+			if (!notify_obj) {
+				status = AE_NOT_EXIST;
+				goto unlock_and_exit;
+			}
+
+			if (notify_obj->notify.handler != handler) {
+				status = AE_BAD_PARAMETER;
+				goto unlock_and_exit;
+			}
+
+			/* Remove the handler */
+
+			obj_desc->common_notify.device_notify = NULL;
+			acpi_ut_remove_reference(notify_obj);
+		}
+	}
+
+      unlock_and_exit:
+	(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);
+	return_ACPI_STATUS(status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_remove_notify_handler)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_install_gpe_handler
+ *
+ * PARAMETERS:  gpe_device      - Namespace node for the GPE (NULL for FADT
+ *                                defined GPEs)
+ *              gpe_number      - The GPE number within the GPE block
+ *              Type            - Whether this GPE should be treated as an
+ *                                edge- or level-triggered interrupt.
+ *              Address         - Address of the handler
+ *              Context         - Value passed to the handler on each GPE
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Install a handler for a General Purpose Event.
+ *
+ ******************************************************************************/
+acpi_status
+acpi_install_gpe_handler(acpi_handle gpe_device,
+			 u32 gpe_number,
+			 u32 type, acpi_gpe_handler address, void *context)
+{
+	struct acpi_gpe_event_info *gpe_event_info;
+	struct acpi_gpe_handler_info *handler;
+	acpi_status status;
+	acpi_cpu_flags flags;
+
+	ACPI_FUNCTION_TRACE(acpi_install_gpe_handler);
+
+	/* Parameter validation */
+
+	if ((!address) || (type & ~ACPI_GPE_XRUPT_TYPE_MASK)) {
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	status = acpi_ut_acquire_mutex(ACPI_MTX_EVENTS);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/* Allocate and init handler object (before lock) */
+
+	handler = ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_gpe_handler_info));
+	if (!handler) {
+		status = AE_NO_MEMORY;
+		goto unlock_and_exit;
+	}
+
+	flags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);
+
+	/* Ensure that we have a valid GPE number */
+
+	gpe_event_info = acpi_ev_get_gpe_event_info(gpe_device, gpe_number);
+	if (!gpe_event_info) {
+		status = AE_BAD_PARAMETER;
+		goto free_and_exit;
+	}
+
+	/* Make sure that there isn't a handler there already */
+
+	if ((gpe_event_info->flags & ACPI_GPE_DISPATCH_MASK) ==
+	    ACPI_GPE_DISPATCH_HANDLER) {
+		status = AE_ALREADY_EXISTS;
+		goto free_and_exit;
+	}
+
+	handler->address = address;
+	handler->context = context;
+	handler->method_node = gpe_event_info->dispatch.method_node;
+	handler->original_flags = (u8)(gpe_event_info->flags &
+				       (ACPI_GPE_XRUPT_TYPE_MASK |
+					ACPI_GPE_DISPATCH_MASK));
+
+	/*
+	 * If the GPE is associated with a method, it may have been enabled
+	 * automatically during initialization, in which case it has to be
+	 * disabled now to avoid spurious execution of the handler.
+	 */
+	if (((handler->original_flags & ACPI_GPE_DISPATCH_METHOD) ||
+	     (handler->original_flags & ACPI_GPE_DISPATCH_NOTIFY)) &&
+	    gpe_event_info->runtime_count) {
+		handler->originally_enabled = TRUE;
+		(void)acpi_ev_remove_gpe_reference(gpe_event_info);
+
+		/* Sanity check of original type against new type */
+
+		if (type !=
+		    (u32)(gpe_event_info->flags & ACPI_GPE_XRUPT_TYPE_MASK)) {
+			ACPI_WARNING((AE_INFO,
+				      "GPE type mismatch (level/edge)"));
+		}
+	}
+
+	/* Install the handler */
+
+	gpe_event_info->dispatch.handler = handler;
+
+	/* Setup up dispatch flags to indicate handler (vs. method/notify) */
+
+	gpe_event_info->flags &=
+	    ~(ACPI_GPE_XRUPT_TYPE_MASK | ACPI_GPE_DISPATCH_MASK);
+	gpe_event_info->flags |= (u8)(type | ACPI_GPE_DISPATCH_HANDLER);
+
+	acpi_os_release_lock(acpi_gbl_gpe_lock, flags);
+
+      unlock_and_exit:
+	(void)acpi_ut_release_mutex(ACPI_MTX_EVENTS);
+	return_ACPI_STATUS(status);
+
+      free_and_exit:
+	acpi_os_release_lock(acpi_gbl_gpe_lock, flags);
+	ACPI_FREE(handler);
+	goto unlock_and_exit;
+}
+
+ACPI_EXPORT_SYMBOL(acpi_install_gpe_handler)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_remove_gpe_handler
+ *
+ * PARAMETERS:  gpe_device      - Namespace node for the GPE (NULL for FADT
+ *                                defined GPEs)
+ *              gpe_number      - The event to remove a handler
+ *              Address         - Address of the handler
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Remove a handler for a General Purpose acpi_event.
+ *
+ ******************************************************************************/
+acpi_status
+acpi_remove_gpe_handler(acpi_handle gpe_device,
+			u32 gpe_number, acpi_gpe_handler address)
+{
+	struct acpi_gpe_event_info *gpe_event_info;
+	struct acpi_gpe_handler_info *handler;
+	acpi_status status;
+	acpi_cpu_flags flags;
+
+	ACPI_FUNCTION_TRACE(acpi_remove_gpe_handler);
+
+	/* Parameter validation */
+
+	if (!address) {
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	status = acpi_ut_acquire_mutex(ACPI_MTX_EVENTS);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	flags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);
+
+	/* Ensure that we have a valid GPE number */
+
+	gpe_event_info = acpi_ev_get_gpe_event_info(gpe_device, gpe_number);
+	if (!gpe_event_info) {
+		status = AE_BAD_PARAMETER;
+		goto unlock_and_exit;
+	}
+
+	/* Make sure that a handler is indeed installed */
+
+	if ((gpe_event_info->flags & ACPI_GPE_DISPATCH_MASK) !=
+	    ACPI_GPE_DISPATCH_HANDLER) {
+		status = AE_NOT_EXIST;
+		goto unlock_and_exit;
+	}
+
+	/* Make sure that the installed handler is the same */
+
+	if (gpe_event_info->dispatch.handler->address != address) {
+		status = AE_BAD_PARAMETER;
+		goto unlock_and_exit;
+	}
+
+	/* Remove the handler */
+
+	handler = gpe_event_info->dispatch.handler;
+
+	/* Restore Method node (if any), set dispatch flags */
+
+	gpe_event_info->dispatch.method_node = handler->method_node;
+	gpe_event_info->flags &=
+	    ~(ACPI_GPE_XRUPT_TYPE_MASK | ACPI_GPE_DISPATCH_MASK);
+	gpe_event_info->flags |= handler->original_flags;
+
+	/*
+	 * If the GPE was previously associated with a method and it was
+	 * enabled, it should be enabled at this point to restore the
+	 * post-initialization configuration.
+	 */
+	if ((handler->original_flags & ACPI_GPE_DISPATCH_METHOD) &&
+	    handler->originally_enabled) {
+		(void)acpi_ev_add_gpe_reference(gpe_event_info);
+	}
+
+	/* Now we can free the handler object */
+
+	ACPI_FREE(handler);
+
+      unlock_and_exit:
+	acpi_os_release_lock(acpi_gbl_gpe_lock, flags);
+	(void)acpi_ut_release_mutex(ACPI_MTX_EVENTS);
+	return_ACPI_STATUS(status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_remove_gpe_handler)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_acquire_global_lock
+ *
+ * PARAMETERS:  Timeout         - How long the caller is willing to wait
+ *              Handle          - Where the handle to the lock is returned
+ *                                (if acquired)
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Acquire the ACPI Global Lock
+ *
+ * Note: Allows callers with the same thread ID to acquire the global lock
+ * multiple times. In other words, externally, the behavior of the global lock
+ * is identical to an AML mutex. On the first acquire, a new handle is
+ * returned. On any subsequent calls to acquire by the same thread, the same
+ * handle is returned.
+ *
+ ******************************************************************************/
+acpi_status acpi_acquire_global_lock(u16 timeout, u32 *handle)
+{
+	acpi_status status;
+
+	if (!handle) {
+		return (AE_BAD_PARAMETER);
+	}
+
+	/* Must lock interpreter to prevent race conditions */
+
+	acpi_ex_enter_interpreter();
+
+	status = acpi_ex_acquire_mutex_object(timeout,
+					      acpi_gbl_global_lock_mutex,
+					      acpi_os_get_thread_id());
+
+	if (ACPI_SUCCESS(status)) {
+
+		/* Return the global lock handle (updated in acpi_ev_acquire_global_lock) */
+
+		*handle = acpi_gbl_global_lock_handle;
+	}
+
+	acpi_ex_exit_interpreter();
+	return (status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_acquire_global_lock)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_release_global_lock
+ *
+ * PARAMETERS:  Handle      - Returned from acpi_acquire_global_lock
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Release the ACPI Global Lock. The handle must be valid.
+ *
+ ******************************************************************************/
+acpi_status acpi_release_global_lock(u32 handle)
+{
+	acpi_status status;
+
+	if (!handle || (handle != acpi_gbl_global_lock_handle)) {
+		return (AE_NOT_ACQUIRED);
+	}
+
+	status = acpi_ex_release_mutex_object(acpi_gbl_global_lock_mutex);
+	return (status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_release_global_lock)
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/evxfevnt.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/evxfevnt.c
new file mode 100644
index 00000000..b0b9fd03
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/evxfevnt.c
@@ -0,0 +1,323 @@
+/******************************************************************************
+ *
+ * Module Name: evxfevnt - External Interfaces, ACPI event disable/enable
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "actables.h"
+
+#define _COMPONENT          ACPI_EVENTS
+ACPI_MODULE_NAME("evxfevnt")
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_enable
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Transfers the system into ACPI mode.
+ *
+ ******************************************************************************/
+acpi_status acpi_enable(void)
+{
+	acpi_status status = AE_OK;
+
+	ACPI_FUNCTION_TRACE(acpi_enable);
+
+	/* ACPI tables must be present */
+
+	if (!acpi_tb_tables_loaded()) {
+		return_ACPI_STATUS(AE_NO_ACPI_TABLES);
+	}
+
+	/* Check current mode */
+
+	if (acpi_hw_get_mode() == ACPI_SYS_MODE_ACPI) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INIT,
+				  "System is already in ACPI mode\n"));
+	} else {
+		/* Transition to ACPI mode */
+
+		status = acpi_hw_set_mode(ACPI_SYS_MODE_ACPI);
+		if (ACPI_FAILURE(status)) {
+			ACPI_ERROR((AE_INFO,
+				    "Could not transition to ACPI mode"));
+			return_ACPI_STATUS(status);
+		}
+
+		ACPI_DEBUG_PRINT((ACPI_DB_INIT,
+				  "Transition to ACPI mode successful\n"));
+	}
+
+	return_ACPI_STATUS(status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_enable)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_disable
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Transfers the system into LEGACY (non-ACPI) mode.
+ *
+ ******************************************************************************/
+acpi_status acpi_disable(void)
+{
+	acpi_status status = AE_OK;
+
+	ACPI_FUNCTION_TRACE(acpi_disable);
+
+	if (acpi_hw_get_mode() == ACPI_SYS_MODE_LEGACY) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INIT,
+				  "System is already in legacy (non-ACPI) mode\n"));
+	} else {
+		/* Transition to LEGACY mode */
+
+		status = acpi_hw_set_mode(ACPI_SYS_MODE_LEGACY);
+
+		if (ACPI_FAILURE(status)) {
+			ACPI_ERROR((AE_INFO,
+				    "Could not exit ACPI mode to legacy mode"));
+			return_ACPI_STATUS(status);
+		}
+
+		ACPI_DEBUG_PRINT((ACPI_DB_INIT, "ACPI mode disabled\n"));
+	}
+
+	return_ACPI_STATUS(status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_disable)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_enable_event
+ *
+ * PARAMETERS:  Event           - The fixed eventto be enabled
+ *              Flags           - Reserved
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Enable an ACPI event (fixed)
+ *
+ ******************************************************************************/
+acpi_status acpi_enable_event(u32 event, u32 flags)
+{
+	acpi_status status = AE_OK;
+	u32 value;
+
+	ACPI_FUNCTION_TRACE(acpi_enable_event);
+
+	/* Decode the Fixed Event */
+
+	if (event > ACPI_EVENT_MAX) {
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	/*
+	 * Enable the requested fixed event (by writing a one to the enable
+	 * register bit)
+	 */
+	status =
+	    acpi_write_bit_register(acpi_gbl_fixed_event_info[event].
+				    enable_register_id, ACPI_ENABLE_EVENT);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/* Make sure that the hardware responded */
+
+	status =
+	    acpi_read_bit_register(acpi_gbl_fixed_event_info[event].
+				   enable_register_id, &value);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	if (value != 1) {
+		ACPI_ERROR((AE_INFO,
+			    "Could not enable %s event",
+			    acpi_ut_get_event_name(event)));
+		return_ACPI_STATUS(AE_NO_HARDWARE_RESPONSE);
+	}
+
+	return_ACPI_STATUS(status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_enable_event)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_disable_event
+ *
+ * PARAMETERS:  Event           - The fixed event to be disabled
+ *              Flags           - Reserved
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Disable an ACPI event (fixed)
+ *
+ ******************************************************************************/
+acpi_status acpi_disable_event(u32 event, u32 flags)
+{
+	acpi_status status = AE_OK;
+	u32 value;
+
+	ACPI_FUNCTION_TRACE(acpi_disable_event);
+
+	/* Decode the Fixed Event */
+
+	if (event > ACPI_EVENT_MAX) {
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	/*
+	 * Disable the requested fixed event (by writing a zero to the enable
+	 * register bit)
+	 */
+	status =
+	    acpi_write_bit_register(acpi_gbl_fixed_event_info[event].
+				    enable_register_id, ACPI_DISABLE_EVENT);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	status =
+	    acpi_read_bit_register(acpi_gbl_fixed_event_info[event].
+				   enable_register_id, &value);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	if (value != 0) {
+		ACPI_ERROR((AE_INFO,
+			    "Could not disable %s events",
+			    acpi_ut_get_event_name(event)));
+		return_ACPI_STATUS(AE_NO_HARDWARE_RESPONSE);
+	}
+
+	return_ACPI_STATUS(status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_disable_event)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_clear_event
+ *
+ * PARAMETERS:  Event           - The fixed event to be cleared
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Clear an ACPI event (fixed)
+ *
+ ******************************************************************************/
+acpi_status acpi_clear_event(u32 event)
+{
+	acpi_status status = AE_OK;
+
+	ACPI_FUNCTION_TRACE(acpi_clear_event);
+
+	/* Decode the Fixed Event */
+
+	if (event > ACPI_EVENT_MAX) {
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	/*
+	 * Clear the requested fixed event (By writing a one to the status
+	 * register bit)
+	 */
+	status =
+	    acpi_write_bit_register(acpi_gbl_fixed_event_info[event].
+				    status_register_id, ACPI_CLEAR_STATUS);
+
+	return_ACPI_STATUS(status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_clear_event)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_get_event_status
+ *
+ * PARAMETERS:  Event           - The fixed event
+ *              event_status    - Where the current status of the event will
+ *                                be returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Obtains and returns the current status of the event
+ *
+ ******************************************************************************/
+acpi_status acpi_get_event_status(u32 event, acpi_event_status *event_status)
+{
+	acpi_status status = AE_OK;
+
+	ACPI_FUNCTION_TRACE(acpi_get_event_status);
+
+	if (!event_status) {
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	/* Decode the Fixed Event */
+
+	if (event > ACPI_EVENT_MAX) {
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	/* Get the status of the requested fixed event */
+
+	status =
+	    acpi_read_bit_register(acpi_gbl_fixed_event_info[event].
+				   status_register_id, event_status);
+
+	return_ACPI_STATUS(status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_get_event_status)
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/evxfgpe.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/evxfgpe.c
new file mode 100644
index 00000000..b68a18d5
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/evxfgpe.c
@@ -0,0 +1,770 @@
+/******************************************************************************
+ *
+ * Module Name: evxfgpe - External Interfaces for General Purpose Events (GPEs)
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acevents.h"
+#include "acnamesp.h"
+
+#define _COMPONENT          ACPI_EVENTS
+ACPI_MODULE_NAME("evxfgpe")
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_update_all_gpes
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Complete GPE initialization and enable all GPEs that have
+ *              associated _Lxx or _Exx methods and are not pointed to by any
+ *              device _PRW methods (this indicates that these GPEs are
+ *              generally intended for system or device wakeup. Such GPEs
+ *              have to be enabled directly when the devices whose _PRW
+ *              methods point to them are set up for wakeup signaling.)
+ *
+ * NOTE: Should be called after any GPEs are added to the system. Primarily,
+ * after the system _PRW methods have been run, but also after a GPE Block
+ * Device has been added or if any new GPE methods have been added via a
+ * dynamic table load.
+ *
+ ******************************************************************************/
+acpi_status acpi_update_all_gpes(void)
+{
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(acpi_update_gpes);
+
+	status = acpi_ut_acquire_mutex(ACPI_MTX_EVENTS);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	if (acpi_gbl_all_gpes_initialized) {
+		goto unlock_and_exit;
+	}
+
+	status = acpi_ev_walk_gpe_list(acpi_ev_initialize_gpe_block, NULL);
+	if (ACPI_SUCCESS(status)) {
+		acpi_gbl_all_gpes_initialized = TRUE;
+	}
+
+      unlock_and_exit:
+	(void)acpi_ut_release_mutex(ACPI_MTX_EVENTS);
+	return_ACPI_STATUS(status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_update_all_gpes)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_enable_gpe
+ *
+ * PARAMETERS:  gpe_device          - Parent GPE Device. NULL for GPE0/GPE1
+ *              gpe_number          - GPE level within the GPE block
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Add a reference to a GPE. On the first reference, the GPE is
+ *              hardware-enabled.
+ *
+ ******************************************************************************/
+acpi_status acpi_enable_gpe(acpi_handle gpe_device, u32 gpe_number)
+{
+	acpi_status status = AE_BAD_PARAMETER;
+	struct acpi_gpe_event_info *gpe_event_info;
+	acpi_cpu_flags flags;
+
+	ACPI_FUNCTION_TRACE(acpi_enable_gpe);
+
+	flags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);
+
+	/* Ensure that we have a valid GPE number */
+
+	gpe_event_info = acpi_ev_get_gpe_event_info(gpe_device, gpe_number);
+	if (gpe_event_info) {
+		status = acpi_ev_add_gpe_reference(gpe_event_info);
+	}
+
+	acpi_os_release_lock(acpi_gbl_gpe_lock, flags);
+	return_ACPI_STATUS(status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_enable_gpe)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_disable_gpe
+ *
+ * PARAMETERS:  gpe_device          - Parent GPE Device. NULL for GPE0/GPE1
+ *              gpe_number          - GPE level within the GPE block
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Remove a reference to a GPE. When the last reference is
+ *              removed, only then is the GPE disabled (for runtime GPEs), or
+ *              the GPE mask bit disabled (for wake GPEs)
+ *
+ ******************************************************************************/
+acpi_status acpi_disable_gpe(acpi_handle gpe_device, u32 gpe_number)
+{
+	acpi_status status = AE_BAD_PARAMETER;
+	struct acpi_gpe_event_info *gpe_event_info;
+	acpi_cpu_flags flags;
+
+	ACPI_FUNCTION_TRACE(acpi_disable_gpe);
+
+	flags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);
+
+	/* Ensure that we have a valid GPE number */
+
+	gpe_event_info = acpi_ev_get_gpe_event_info(gpe_device, gpe_number);
+	if (gpe_event_info) {
+		status = acpi_ev_remove_gpe_reference(gpe_event_info);
+	}
+
+	acpi_os_release_lock(acpi_gbl_gpe_lock, flags);
+	return_ACPI_STATUS(status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_disable_gpe)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_set_gpe
+ *
+ * PARAMETERS:  gpe_device          - Parent GPE Device. NULL for GPE0/GPE1
+ *              gpe_number          - GPE level within the GPE block
+ *              Action              - ACPI_GPE_ENABLE or ACPI_GPE_DISABLE
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Enable or disable an individual GPE. This function bypasses
+ *              the reference count mechanism used in the acpi_enable_gpe and
+ *              acpi_disable_gpe interfaces -- and should be used with care.
+ *
+ * Note: Typically used to disable a runtime GPE for short period of time,
+ * then re-enable it, without disturbing the existing reference counts. This
+ * is useful, for example, in the Embedded Controller (EC) driver.
+ *
+ ******************************************************************************/
+acpi_status acpi_set_gpe(acpi_handle gpe_device, u32 gpe_number, u8 action)
+{
+	struct acpi_gpe_event_info *gpe_event_info;
+	acpi_status status;
+	acpi_cpu_flags flags;
+
+	ACPI_FUNCTION_TRACE(acpi_set_gpe);
+
+	flags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);
+
+	/* Ensure that we have a valid GPE number */
+
+	gpe_event_info = acpi_ev_get_gpe_event_info(gpe_device, gpe_number);
+	if (!gpe_event_info) {
+		status = AE_BAD_PARAMETER;
+		goto unlock_and_exit;
+	}
+
+	/* Perform the action */
+
+	switch (action) {
+	case ACPI_GPE_ENABLE:
+		status = acpi_ev_enable_gpe(gpe_event_info);
+		break;
+
+	case ACPI_GPE_DISABLE:
+		status = acpi_hw_low_set_gpe(gpe_event_info, ACPI_GPE_DISABLE);
+		break;
+
+	default:
+		status = AE_BAD_PARAMETER;
+		break;
+	}
+
+      unlock_and_exit:
+	acpi_os_release_lock(acpi_gbl_gpe_lock, flags);
+	return_ACPI_STATUS(status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_set_gpe)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_setup_gpe_for_wake
+ *
+ * PARAMETERS:  wake_device         - Device associated with the GPE (via _PRW)
+ *              gpe_device          - Parent GPE Device. NULL for GPE0/GPE1
+ *              gpe_number          - GPE level within the GPE block
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Mark a GPE as having the ability to wake the system. This
+ *              interface is intended to be used as the host executes the
+ *              _PRW methods (Power Resources for Wake) in the system tables.
+ *              Each _PRW appears under a Device Object (The wake_device), and
+ *              contains the info for the wake GPE associated with the
+ *              wake_device.
+ *
+ ******************************************************************************/
+acpi_status
+acpi_setup_gpe_for_wake(acpi_handle wake_device,
+			acpi_handle gpe_device, u32 gpe_number)
+{
+	acpi_status status = AE_BAD_PARAMETER;
+	struct acpi_gpe_event_info *gpe_event_info;
+	struct acpi_namespace_node *device_node;
+	acpi_cpu_flags flags;
+
+	ACPI_FUNCTION_TRACE(acpi_setup_gpe_for_wake);
+
+	/* Parameter Validation */
+
+	if (!wake_device) {
+		/*
+		 * By forcing wake_device to be valid, we automatically enable the
+		 * implicit notify feature on all hosts.
+		 */
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	/* Handle root object case */
+
+	if (wake_device == ACPI_ROOT_OBJECT) {
+		device_node = acpi_gbl_root_node;
+	} else {
+		device_node =
+		    ACPI_CAST_PTR(struct acpi_namespace_node, wake_device);
+	}
+
+	/* Validate wake_device is of type Device */
+
+	if (device_node->type != ACPI_TYPE_DEVICE) {
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	flags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);
+
+	/* Ensure that we have a valid GPE number */
+
+	gpe_event_info = acpi_ev_get_gpe_event_info(gpe_device, gpe_number);
+	if (gpe_event_info) {
+		/*
+		 * If there is no method or handler for this GPE, then the
+		 * wake_device will be notified whenever this GPE fires (aka
+		 * "implicit notify") Note: The GPE is assumed to be
+		 * level-triggered (for windows compatibility).
+		 */
+		if ((gpe_event_info->flags & ACPI_GPE_DISPATCH_MASK) ==
+		    ACPI_GPE_DISPATCH_NONE) {
+			gpe_event_info->flags =
+			    (ACPI_GPE_DISPATCH_NOTIFY |
+			     ACPI_GPE_LEVEL_TRIGGERED);
+			gpe_event_info->dispatch.device_node = device_node;
+		}
+
+		gpe_event_info->flags |= ACPI_GPE_CAN_WAKE;
+		status = AE_OK;
+	}
+
+	acpi_os_release_lock(acpi_gbl_gpe_lock, flags);
+	return_ACPI_STATUS(status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_setup_gpe_for_wake)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_set_gpe_wake_mask
+ *
+ * PARAMETERS:  gpe_device          - Parent GPE Device. NULL for GPE0/GPE1
+ *              gpe_number          - GPE level within the GPE block
+ *              Action              - Enable or Disable
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Set or clear the GPE's wakeup enable mask bit. The GPE must
+ *              already be marked as a WAKE GPE.
+ *
+ ******************************************************************************/
+acpi_status
+acpi_set_gpe_wake_mask(acpi_handle gpe_device, u32 gpe_number, u8 action)
+{
+	acpi_status status = AE_OK;
+	struct acpi_gpe_event_info *gpe_event_info;
+	struct acpi_gpe_register_info *gpe_register_info;
+	acpi_cpu_flags flags;
+	u32 register_bit;
+
+	ACPI_FUNCTION_TRACE(acpi_set_gpe_wake_mask);
+
+	flags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);
+
+	/*
+	 * Ensure that we have a valid GPE number and that this GPE is in
+	 * fact a wake GPE
+	 */
+	gpe_event_info = acpi_ev_get_gpe_event_info(gpe_device, gpe_number);
+	if (!gpe_event_info) {
+		status = AE_BAD_PARAMETER;
+		goto unlock_and_exit;
+	}
+
+	if (!(gpe_event_info->flags & ACPI_GPE_CAN_WAKE)) {
+		status = AE_TYPE;
+		goto unlock_and_exit;
+	}
+
+	gpe_register_info = gpe_event_info->register_info;
+	if (!gpe_register_info) {
+		status = AE_NOT_EXIST;
+		goto unlock_and_exit;
+	}
+
+	register_bit =
+	    acpi_hw_get_gpe_register_bit(gpe_event_info, gpe_register_info);
+
+	/* Perform the action */
+
+	switch (action) {
+	case ACPI_GPE_ENABLE:
+		ACPI_SET_BIT(gpe_register_info->enable_for_wake,
+			     (u8)register_bit);
+		break;
+
+	case ACPI_GPE_DISABLE:
+		ACPI_CLEAR_BIT(gpe_register_info->enable_for_wake,
+			       (u8)register_bit);
+		break;
+
+	default:
+		ACPI_ERROR((AE_INFO, "%u, Invalid action", action));
+		status = AE_BAD_PARAMETER;
+		break;
+	}
+
+      unlock_and_exit:
+	acpi_os_release_lock(acpi_gbl_gpe_lock, flags);
+	return_ACPI_STATUS(status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_set_gpe_wake_mask)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_clear_gpe
+ *
+ * PARAMETERS:  gpe_device          - Parent GPE Device. NULL for GPE0/GPE1
+ *              gpe_number          - GPE level within the GPE block
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Clear an ACPI event (general purpose)
+ *
+ ******************************************************************************/
+acpi_status acpi_clear_gpe(acpi_handle gpe_device, u32 gpe_number)
+{
+	acpi_status status = AE_OK;
+	struct acpi_gpe_event_info *gpe_event_info;
+	acpi_cpu_flags flags;
+
+	ACPI_FUNCTION_TRACE(acpi_clear_gpe);
+
+	flags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);
+
+	/* Ensure that we have a valid GPE number */
+
+	gpe_event_info = acpi_ev_get_gpe_event_info(gpe_device, gpe_number);
+	if (!gpe_event_info) {
+		status = AE_BAD_PARAMETER;
+		goto unlock_and_exit;
+	}
+
+	status = acpi_hw_clear_gpe(gpe_event_info);
+
+      unlock_and_exit:
+	acpi_os_release_lock(acpi_gbl_gpe_lock, flags);
+	return_ACPI_STATUS(status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_clear_gpe)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_get_gpe_status
+ *
+ * PARAMETERS:  gpe_device          - Parent GPE Device. NULL for GPE0/GPE1
+ *              gpe_number          - GPE level within the GPE block
+ *              event_status        - Where the current status of the event
+ *                                    will be returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Get the current status of a GPE (signalled/not_signalled)
+ *
+ ******************************************************************************/
+acpi_status
+acpi_get_gpe_status(acpi_handle gpe_device,
+		    u32 gpe_number, acpi_event_status *event_status)
+{
+	acpi_status status = AE_OK;
+	struct acpi_gpe_event_info *gpe_event_info;
+	acpi_cpu_flags flags;
+
+	ACPI_FUNCTION_TRACE(acpi_get_gpe_status);
+
+	flags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);
+
+	/* Ensure that we have a valid GPE number */
+
+	gpe_event_info = acpi_ev_get_gpe_event_info(gpe_device, gpe_number);
+	if (!gpe_event_info) {
+		status = AE_BAD_PARAMETER;
+		goto unlock_and_exit;
+	}
+
+	/* Obtain status on the requested GPE number */
+
+	status = acpi_hw_get_gpe_status(gpe_event_info, event_status);
+
+      unlock_and_exit:
+	acpi_os_release_lock(acpi_gbl_gpe_lock, flags);
+	return_ACPI_STATUS(status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_get_gpe_status)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_finish_gpe
+ *
+ * PARAMETERS:  gpe_device          - Namespace node for the GPE Block
+ *                                    (NULL for FADT defined GPEs)
+ *              gpe_number          - GPE level within the GPE block
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Clear and conditionally reenable a GPE. This completes the GPE
+ *              processing. Intended for use by asynchronous host-installed
+ *              GPE handlers. The GPE is only reenabled if the enable_for_run bit
+ *              is set in the GPE info.
+ *
+ ******************************************************************************/
+acpi_status acpi_finish_gpe(acpi_handle gpe_device, u32 gpe_number)
+{
+	struct acpi_gpe_event_info *gpe_event_info;
+	acpi_status status;
+	acpi_cpu_flags flags;
+
+	ACPI_FUNCTION_TRACE(acpi_finish_gpe);
+
+	flags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);
+
+	/* Ensure that we have a valid GPE number */
+
+	gpe_event_info = acpi_ev_get_gpe_event_info(gpe_device, gpe_number);
+	if (!gpe_event_info) {
+		status = AE_BAD_PARAMETER;
+		goto unlock_and_exit;
+	}
+
+	status = acpi_ev_finish_gpe(gpe_event_info);
+
+      unlock_and_exit:
+	acpi_os_release_lock(acpi_gbl_gpe_lock, flags);
+	return_ACPI_STATUS(status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_finish_gpe)
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_disable_all_gpes
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Disable and clear all GPEs in all GPE blocks
+ *
+ ******************************************************************************/
+acpi_status acpi_disable_all_gpes(void)
+{
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(acpi_disable_all_gpes);
+
+	status = acpi_ut_acquire_mutex(ACPI_MTX_EVENTS);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	status = acpi_hw_disable_all_gpes();
+	(void)acpi_ut_release_mutex(ACPI_MTX_EVENTS);
+
+	return_ACPI_STATUS(status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_disable_all_gpes)
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_enable_all_runtime_gpes
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Enable all "runtime" GPEs, in all GPE blocks
+ *
+ ******************************************************************************/
+acpi_status acpi_enable_all_runtime_gpes(void)
+{
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(acpi_enable_all_runtime_gpes);
+
+	status = acpi_ut_acquire_mutex(ACPI_MTX_EVENTS);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	status = acpi_hw_enable_all_runtime_gpes();
+	(void)acpi_ut_release_mutex(ACPI_MTX_EVENTS);
+
+	return_ACPI_STATUS(status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_enable_all_runtime_gpes)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_install_gpe_block
+ *
+ * PARAMETERS:  gpe_device          - Handle to the parent GPE Block Device
+ *              gpe_block_address   - Address and space_iD
+ *              register_count      - Number of GPE register pairs in the block
+ *              interrupt_number    - H/W interrupt for the block
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Create and Install a block of GPE registers. The GPEs are not
+ *              enabled here.
+ *
+ ******************************************************************************/
+acpi_status
+acpi_install_gpe_block(acpi_handle gpe_device,
+		       struct acpi_generic_address *gpe_block_address,
+		       u32 register_count, u32 interrupt_number)
+{
+	acpi_status status;
+	union acpi_operand_object *obj_desc;
+	struct acpi_namespace_node *node;
+	struct acpi_gpe_block_info *gpe_block;
+
+	ACPI_FUNCTION_TRACE(acpi_install_gpe_block);
+
+	if ((!gpe_device) || (!gpe_block_address) || (!register_count)) {
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	status = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);
+	if (ACPI_FAILURE(status)) {
+		return (status);
+	}
+
+	node = acpi_ns_validate_handle(gpe_device);
+	if (!node) {
+		status = AE_BAD_PARAMETER;
+		goto unlock_and_exit;
+	}
+
+	/*
+	 * For user-installed GPE Block Devices, the gpe_block_base_number
+	 * is always zero
+	 */
+	status =
+	    acpi_ev_create_gpe_block(node, gpe_block_address, register_count, 0,
+				     interrupt_number, &gpe_block);
+	if (ACPI_FAILURE(status)) {
+		goto unlock_and_exit;
+	}
+
+	/* Install block in the device_object attached to the node */
+
+	obj_desc = acpi_ns_get_attached_object(node);
+	if (!obj_desc) {
+		/*
+		 * No object, create a new one (Device nodes do not always have
+		 * an attached object)
+		 */
+		obj_desc = acpi_ut_create_internal_object(ACPI_TYPE_DEVICE);
+		if (!obj_desc) {
+			status = AE_NO_MEMORY;
+			goto unlock_and_exit;
+		}
+
+		status =
+		    acpi_ns_attach_object(node, obj_desc, ACPI_TYPE_DEVICE);
+
+		/* Remove local reference to the object */
+
+		acpi_ut_remove_reference(obj_desc);
+		if (ACPI_FAILURE(status)) {
+			goto unlock_and_exit;
+		}
+	}
+
+	/* Now install the GPE block in the device_object */
+
+	obj_desc->device.gpe_block = gpe_block;
+
+      unlock_and_exit:
+	(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);
+	return_ACPI_STATUS(status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_install_gpe_block)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_remove_gpe_block
+ *
+ * PARAMETERS:  gpe_device          - Handle to the parent GPE Block Device
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Remove a previously installed block of GPE registers
+ *
+ ******************************************************************************/
+acpi_status acpi_remove_gpe_block(acpi_handle gpe_device)
+{
+	union acpi_operand_object *obj_desc;
+	acpi_status status;
+	struct acpi_namespace_node *node;
+
+	ACPI_FUNCTION_TRACE(acpi_remove_gpe_block);
+
+	if (!gpe_device) {
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	status = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);
+	if (ACPI_FAILURE(status)) {
+		return (status);
+	}
+
+	node = acpi_ns_validate_handle(gpe_device);
+	if (!node) {
+		status = AE_BAD_PARAMETER;
+		goto unlock_and_exit;
+	}
+
+	/* Get the device_object attached to the node */
+
+	obj_desc = acpi_ns_get_attached_object(node);
+	if (!obj_desc || !obj_desc->device.gpe_block) {
+		return_ACPI_STATUS(AE_NULL_OBJECT);
+	}
+
+	/* Delete the GPE block (but not the device_object) */
+
+	status = acpi_ev_delete_gpe_block(obj_desc->device.gpe_block);
+	if (ACPI_SUCCESS(status)) {
+		obj_desc->device.gpe_block = NULL;
+	}
+
+      unlock_and_exit:
+	(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);
+	return_ACPI_STATUS(status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_remove_gpe_block)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_get_gpe_device
+ *
+ * PARAMETERS:  Index               - System GPE index (0-current_gpe_count)
+ *              gpe_device          - Where the parent GPE Device is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Obtain the GPE device associated with the input index. A NULL
+ *              gpe device indicates that the gpe number is contained in one of
+ *              the FADT-defined gpe blocks. Otherwise, the GPE block device.
+ *
+ ******************************************************************************/
+acpi_status acpi_get_gpe_device(u32 index, acpi_handle * gpe_device)
+{
+	struct acpi_gpe_device_info info;
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(acpi_get_gpe_device);
+
+	if (!gpe_device) {
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	if (index >= acpi_current_gpe_count) {
+		return_ACPI_STATUS(AE_NOT_EXIST);
+	}
+
+	/* Setup and walk the GPE list */
+
+	info.index = index;
+	info.status = AE_NOT_EXIST;
+	info.gpe_device = NULL;
+	info.next_block_base_index = 0;
+
+	status = acpi_ev_walk_gpe_list(acpi_ev_get_gpe_device, &info);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	*gpe_device = ACPI_CAST_PTR(acpi_handle, info.gpe_device);
+	return_ACPI_STATUS(info.status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_get_gpe_device)
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/evxfregn.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/evxfregn.c
new file mode 100644
index 00000000..f19c1868
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/evxfregn.c
@@ -0,0 +1,292 @@
+/******************************************************************************
+ *
+ * Module Name: evxfregn - External Interfaces, ACPI Operation Regions and
+ *                         Address Spaces.
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acnamesp.h"
+#include "acevents.h"
+
+#define _COMPONENT          ACPI_EVENTS
+ACPI_MODULE_NAME("evxfregn")
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_install_address_space_handler
+ *
+ * PARAMETERS:  Device          - Handle for the device
+ *              space_id        - The address space ID
+ *              Handler         - Address of the handler
+ *              Setup           - Address of the setup function
+ *              Context         - Value passed to the handler on each access
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Install a handler for all op_regions of a given space_id.
+ *
+ * NOTE: This function should only be called after acpi_enable_subsystem has
+ * been called. This is because any _REG methods associated with the Space ID
+ * are executed here, and these methods can only be safely executed after
+ * the default handlers have been installed and the hardware has been
+ * initialized (via acpi_enable_subsystem.)
+ *
+ ******************************************************************************/
+acpi_status
+acpi_install_address_space_handler(acpi_handle device,
+				   acpi_adr_space_type space_id,
+				   acpi_adr_space_handler handler,
+				   acpi_adr_space_setup setup, void *context)
+{
+	struct acpi_namespace_node *node;
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(acpi_install_address_space_handler);
+
+	/* Parameter validation */
+
+	if (!device) {
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	status = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/* Convert and validate the device handle */
+
+	node = acpi_ns_validate_handle(device);
+	if (!node) {
+		status = AE_BAD_PARAMETER;
+		goto unlock_and_exit;
+	}
+
+	/* Install the handler for all Regions for this Space ID */
+
+	status =
+	    acpi_ev_install_space_handler(node, space_id, handler, setup,
+					  context);
+	if (ACPI_FAILURE(status)) {
+		goto unlock_and_exit;
+	}
+
+	/*
+	 * For the default space_iDs, (the IDs for which there are default region handlers
+	 * installed) Only execute the _REG methods if the global initialization _REG
+	 * methods have already been run (via acpi_initialize_objects). In other words,
+	 * we will defer the execution of the _REG methods for these space_iDs until
+	 * execution of acpi_initialize_objects. This is done because we need the handlers
+	 * for the default spaces (mem/io/pci/table) to be installed before we can run
+	 * any control methods (or _REG methods). There is known BIOS code that depends
+	 * on this.
+	 *
+	 * For all other space_iDs, we can safely execute the _REG methods immediately.
+	 * This means that for IDs like embedded_controller, this function should be called
+	 * only after acpi_enable_subsystem has been called.
+	 */
+	switch (space_id) {
+	case ACPI_ADR_SPACE_SYSTEM_MEMORY:
+	case ACPI_ADR_SPACE_SYSTEM_IO:
+	case ACPI_ADR_SPACE_PCI_CONFIG:
+	case ACPI_ADR_SPACE_DATA_TABLE:
+
+		if (!acpi_gbl_reg_methods_executed) {
+
+			/* We will defer execution of the _REG methods for this space */
+			goto unlock_and_exit;
+		}
+		break;
+
+	default:
+		break;
+	}
+
+	/* Run all _REG methods for this address space */
+
+	status = acpi_ev_execute_reg_methods(node, space_id);
+
+      unlock_and_exit:
+	(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);
+	return_ACPI_STATUS(status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_install_address_space_handler)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_remove_address_space_handler
+ *
+ * PARAMETERS:  Device          - Handle for the device
+ *              space_id        - The address space ID
+ *              Handler         - Address of the handler
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Remove a previously installed handler.
+ *
+ ******************************************************************************/
+acpi_status
+acpi_remove_address_space_handler(acpi_handle device,
+				  acpi_adr_space_type space_id,
+				  acpi_adr_space_handler handler)
+{
+	union acpi_operand_object *obj_desc;
+	union acpi_operand_object *handler_obj;
+	union acpi_operand_object *region_obj;
+	union acpi_operand_object **last_obj_ptr;
+	struct acpi_namespace_node *node;
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(acpi_remove_address_space_handler);
+
+	/* Parameter validation */
+
+	if (!device) {
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	status = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/* Convert and validate the device handle */
+
+	node = acpi_ns_validate_handle(device);
+	if (!node ||
+	    ((node->type != ACPI_TYPE_DEVICE) &&
+	     (node->type != ACPI_TYPE_PROCESSOR) &&
+	     (node->type != ACPI_TYPE_THERMAL) &&
+	     (node != acpi_gbl_root_node))) {
+		status = AE_BAD_PARAMETER;
+		goto unlock_and_exit;
+	}
+
+	/* Make sure the internal object exists */
+
+	obj_desc = acpi_ns_get_attached_object(node);
+	if (!obj_desc) {
+		status = AE_NOT_EXIST;
+		goto unlock_and_exit;
+	}
+
+	/* Find the address handler the user requested */
+
+	handler_obj = obj_desc->device.handler;
+	last_obj_ptr = &obj_desc->device.handler;
+	while (handler_obj) {
+
+		/* We have a handler, see if user requested this one */
+
+		if (handler_obj->address_space.space_id == space_id) {
+
+			/* Handler must be the same as the installed handler */
+
+			if (handler_obj->address_space.handler != handler) {
+				status = AE_BAD_PARAMETER;
+				goto unlock_and_exit;
+			}
+
+			/* Matched space_id, first dereference this in the Regions */
+
+			ACPI_DEBUG_PRINT((ACPI_DB_OPREGION,
+					  "Removing address handler %p(%p) for region %s "
+					  "on Device %p(%p)\n",
+					  handler_obj, handler,
+					  acpi_ut_get_region_name(space_id),
+					  node, obj_desc));
+
+			region_obj = handler_obj->address_space.region_list;
+
+			/* Walk the handler's region list */
+
+			while (region_obj) {
+				/*
+				 * First disassociate the handler from the region.
+				 *
+				 * NOTE: this doesn't mean that the region goes away
+				 * The region is just inaccessible as indicated to
+				 * the _REG method
+				 */
+				acpi_ev_detach_region(region_obj, TRUE);
+
+				/*
+				 * Walk the list: Just grab the head because the
+				 * detach_region removed the previous head.
+				 */
+				region_obj =
+				    handler_obj->address_space.region_list;
+
+			}
+
+			/* Remove this Handler object from the list */
+
+			*last_obj_ptr = handler_obj->address_space.next;
+
+			/* Now we can delete the handler object */
+
+			acpi_ut_remove_reference(handler_obj);
+			goto unlock_and_exit;
+		}
+
+		/* Walk the linked list of handlers */
+
+		last_obj_ptr = &handler_obj->address_space.next;
+		handler_obj = handler_obj->address_space.next;
+	}
+
+	/* The handler does not exist */
+
+	ACPI_DEBUG_PRINT((ACPI_DB_OPREGION,
+			  "Unable to remove address handler %p for %s(%X), DevNode %p, obj %p\n",
+			  handler, acpi_ut_get_region_name(space_id), space_id,
+			  node, obj_desc));
+
+	status = AE_NOT_EXIST;
+
+      unlock_and_exit:
+	(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);
+	return_ACPI_STATUS(status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_remove_address_space_handler)
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exconfig.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exconfig.c
new file mode 100644
index 00000000..a03f1868
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exconfig.c
@@ -0,0 +1,630 @@
+/******************************************************************************
+ *
+ * Module Name: exconfig - Namespace reconfiguration (Load/Unload opcodes)
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acinterp.h"
+#include "acnamesp.h"
+#include "actables.h"
+#include "acdispat.h"
+#include "acevents.h"
+
+#define _COMPONENT          ACPI_EXECUTER
+ACPI_MODULE_NAME("exconfig")
+
+/* Local prototypes */
+static acpi_status
+acpi_ex_add_table(u32 table_index,
+		  struct acpi_namespace_node *parent_node,
+		  union acpi_operand_object **ddb_handle);
+
+static acpi_status
+acpi_ex_region_read(union acpi_operand_object *obj_desc,
+		    u32 length, u8 *buffer);
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_add_table
+ *
+ * PARAMETERS:  Table               - Pointer to raw table
+ *              parent_node         - Where to load the table (scope)
+ *              ddb_handle          - Where to return the table handle.
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Common function to Install and Load an ACPI table with a
+ *              returned table handle.
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ex_add_table(u32 table_index,
+		  struct acpi_namespace_node *parent_node,
+		  union acpi_operand_object **ddb_handle)
+{
+	union acpi_operand_object *obj_desc;
+	acpi_status status;
+	acpi_owner_id owner_id;
+
+	ACPI_FUNCTION_TRACE(ex_add_table);
+
+	/* Create an object to be the table handle */
+
+	obj_desc = acpi_ut_create_internal_object(ACPI_TYPE_LOCAL_REFERENCE);
+	if (!obj_desc) {
+		return_ACPI_STATUS(AE_NO_MEMORY);
+	}
+
+	/* Init the table handle */
+
+	obj_desc->common.flags |= AOPOBJ_DATA_VALID;
+	obj_desc->reference.class = ACPI_REFCLASS_TABLE;
+	*ddb_handle = obj_desc;
+
+	/* Install the new table into the local data structures */
+
+	obj_desc->reference.value = table_index;
+
+	/* Add the table to the namespace */
+
+	status = acpi_ns_load_table(table_index, parent_node);
+	if (ACPI_FAILURE(status)) {
+		acpi_ut_remove_reference(obj_desc);
+		*ddb_handle = NULL;
+		return_ACPI_STATUS(status);
+	}
+
+	/* Execute any module-level code that was found in the table */
+
+	acpi_ex_exit_interpreter();
+	acpi_ns_exec_module_code_list();
+	acpi_ex_enter_interpreter();
+
+	/*
+	 * Update GPEs for any new _Lxx/_Exx methods. Ignore errors. The host is
+	 * responsible for discovering any new wake GPEs by running _PRW methods
+	 * that may have been loaded by this table.
+	 */
+	status = acpi_tb_get_owner_id(table_index, &owner_id);
+	if (ACPI_SUCCESS(status)) {
+		acpi_ev_update_gpes(owner_id);
+	}
+
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_load_table_op
+ *
+ * PARAMETERS:  walk_state          - Current state with operands
+ *              return_desc         - Where to store the return object
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Load an ACPI table from the RSDT/XSDT
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ex_load_table_op(struct acpi_walk_state *walk_state,
+		      union acpi_operand_object **return_desc)
+{
+	acpi_status status;
+	union acpi_operand_object **operand = &walk_state->operands[0];
+	struct acpi_namespace_node *parent_node;
+	struct acpi_namespace_node *start_node;
+	struct acpi_namespace_node *parameter_node = NULL;
+	union acpi_operand_object *ddb_handle;
+	struct acpi_table_header *table;
+	u32 table_index;
+
+	ACPI_FUNCTION_TRACE(ex_load_table_op);
+
+	/* Validate lengths for the signature_string, OEMIDString, OEMtable_iD */
+
+	if ((operand[0]->string.length > ACPI_NAME_SIZE) ||
+	    (operand[1]->string.length > ACPI_OEM_ID_SIZE) ||
+	    (operand[2]->string.length > ACPI_OEM_TABLE_ID_SIZE)) {
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	/* Find the ACPI table in the RSDT/XSDT */
+
+	status = acpi_tb_find_table(operand[0]->string.pointer,
+				    operand[1]->string.pointer,
+				    operand[2]->string.pointer, &table_index);
+	if (ACPI_FAILURE(status)) {
+		if (status != AE_NOT_FOUND) {
+			return_ACPI_STATUS(status);
+		}
+
+		/* Table not found, return an Integer=0 and AE_OK */
+
+		ddb_handle = acpi_ut_create_integer_object((u64)0);
+		if (!ddb_handle) {
+			return_ACPI_STATUS(AE_NO_MEMORY);
+		}
+
+		*return_desc = ddb_handle;
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	/* Default nodes */
+
+	start_node = walk_state->scope_info->scope.node;
+	parent_node = acpi_gbl_root_node;
+
+	/* root_path (optional parameter) */
+
+	if (operand[3]->string.length > 0) {
+		/*
+		 * Find the node referenced by the root_path_string. This is the
+		 * location within the namespace where the table will be loaded.
+		 */
+		status =
+		    acpi_ns_get_node(start_node, operand[3]->string.pointer,
+				     ACPI_NS_SEARCH_PARENT, &parent_node);
+		if (ACPI_FAILURE(status)) {
+			return_ACPI_STATUS(status);
+		}
+	}
+
+	/* parameter_path (optional parameter) */
+
+	if (operand[4]->string.length > 0) {
+		if ((operand[4]->string.pointer[0] != '\\') &&
+		    (operand[4]->string.pointer[0] != '^')) {
+			/*
+			 * Path is not absolute, so it will be relative to the node
+			 * referenced by the root_path_string (or the NS root if omitted)
+			 */
+			start_node = parent_node;
+		}
+
+		/* Find the node referenced by the parameter_path_string */
+
+		status =
+		    acpi_ns_get_node(start_node, operand[4]->string.pointer,
+				     ACPI_NS_SEARCH_PARENT, &parameter_node);
+		if (ACPI_FAILURE(status)) {
+			return_ACPI_STATUS(status);
+		}
+	}
+
+	/* Load the table into the namespace */
+
+	status = acpi_ex_add_table(table_index, parent_node, &ddb_handle);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/* Parameter Data (optional) */
+
+	if (parameter_node) {
+
+		/* Store the parameter data into the optional parameter object */
+
+		status = acpi_ex_store(operand[5],
+				       ACPI_CAST_PTR(union acpi_operand_object,
+						     parameter_node),
+				       walk_state);
+		if (ACPI_FAILURE(status)) {
+			(void)acpi_ex_unload_table(ddb_handle);
+
+			acpi_ut_remove_reference(ddb_handle);
+			return_ACPI_STATUS(status);
+		}
+	}
+
+	status = acpi_get_table_by_index(table_index, &table);
+	if (ACPI_SUCCESS(status)) {
+		ACPI_INFO((AE_INFO, "Dynamic OEM Table Load:"));
+		acpi_tb_print_table_header(0, table);
+	}
+
+	/* Invoke table handler if present */
+
+	if (acpi_gbl_table_handler) {
+		(void)acpi_gbl_table_handler(ACPI_TABLE_EVENT_LOAD, table,
+					     acpi_gbl_table_handler_context);
+	}
+
+	*return_desc = ddb_handle;
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_region_read
+ *
+ * PARAMETERS:  obj_desc        - Region descriptor
+ *              Length          - Number of bytes to read
+ *              Buffer          - Pointer to where to put the data
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Read data from an operation region. The read starts from the
+ *              beginning of the region.
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ex_region_read(union acpi_operand_object *obj_desc, u32 length, u8 *buffer)
+{
+	acpi_status status;
+	u64 value;
+	u32 region_offset = 0;
+	u32 i;
+
+	/* Bytewise reads */
+
+	for (i = 0; i < length; i++) {
+		status =
+		    acpi_ev_address_space_dispatch(obj_desc, NULL, ACPI_READ,
+						   region_offset, 8, &value);
+		if (ACPI_FAILURE(status)) {
+			return (status);
+		}
+
+		*buffer = (u8)value;
+		buffer++;
+		region_offset++;
+	}
+
+	return (AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_load_op
+ *
+ * PARAMETERS:  obj_desc        - Region or Buffer/Field where the table will be
+ *                                obtained
+ *              Target          - Where a handle to the table will be stored
+ *              walk_state      - Current state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Load an ACPI table from a field or operation region
+ *
+ * NOTE: Region Fields (Field, bank_field, index_fields) are resolved to buffer
+ *       objects before this code is reached.
+ *
+ *       If source is an operation region, it must refer to system_memory, as
+ *       per the ACPI specification.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ex_load_op(union acpi_operand_object *obj_desc,
+		union acpi_operand_object *target,
+		struct acpi_walk_state * walk_state)
+{
+	union acpi_operand_object *ddb_handle;
+	struct acpi_table_header *table;
+	struct acpi_table_desc table_desc;
+	u32 table_index;
+	acpi_status status;
+	u32 length;
+
+	ACPI_FUNCTION_TRACE(ex_load_op);
+
+	ACPI_MEMSET(&table_desc, 0, sizeof(struct acpi_table_desc));
+
+	/* Source Object can be either an op_region or a Buffer/Field */
+
+	switch (obj_desc->common.type) {
+	case ACPI_TYPE_REGION:
+
+		ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
+				  "Load table from Region %p\n", obj_desc));
+
+		/* Region must be system_memory (from ACPI spec) */
+
+		if (obj_desc->region.space_id != ACPI_ADR_SPACE_SYSTEM_MEMORY) {
+			return_ACPI_STATUS(AE_AML_OPERAND_TYPE);
+		}
+
+		/*
+		 * If the Region Address and Length have not been previously evaluated,
+		 * evaluate them now and save the results.
+		 */
+		if (!(obj_desc->common.flags & AOPOBJ_DATA_VALID)) {
+			status = acpi_ds_get_region_arguments(obj_desc);
+			if (ACPI_FAILURE(status)) {
+				return_ACPI_STATUS(status);
+			}
+		}
+
+		/* Get the table header first so we can get the table length */
+
+		table = ACPI_ALLOCATE(sizeof(struct acpi_table_header));
+		if (!table) {
+			return_ACPI_STATUS(AE_NO_MEMORY);
+		}
+
+		status =
+		    acpi_ex_region_read(obj_desc,
+					sizeof(struct acpi_table_header),
+					ACPI_CAST_PTR(u8, table));
+		length = table->length;
+		ACPI_FREE(table);
+
+		if (ACPI_FAILURE(status)) {
+			return_ACPI_STATUS(status);
+		}
+
+		/* Must have at least an ACPI table header */
+
+		if (length < sizeof(struct acpi_table_header)) {
+			return_ACPI_STATUS(AE_INVALID_TABLE_LENGTH);
+		}
+
+		/*
+		 * The original implementation simply mapped the table, with no copy.
+		 * However, the memory region is not guaranteed to remain stable and
+		 * we must copy the table to a local buffer. For example, the memory
+		 * region is corrupted after suspend on some machines. Dynamically
+		 * loaded tables are usually small, so this overhead is minimal.
+		 *
+		 * The latest implementation (5/2009) does not use a mapping at all.
+		 * We use the low-level operation region interface to read the table
+		 * instead of the obvious optimization of using a direct mapping.
+		 * This maintains a consistent use of operation regions across the
+		 * entire subsystem. This is important if additional processing must
+		 * be performed in the (possibly user-installed) operation region
+		 * handler. For example, acpi_exec and ASLTS depend on this.
+		 */
+
+		/* Allocate a buffer for the table */
+
+		table_desc.pointer = ACPI_ALLOCATE(length);
+		if (!table_desc.pointer) {
+			return_ACPI_STATUS(AE_NO_MEMORY);
+		}
+
+		/* Read the entire table */
+
+		status = acpi_ex_region_read(obj_desc, length,
+					     ACPI_CAST_PTR(u8,
+							   table_desc.pointer));
+		if (ACPI_FAILURE(status)) {
+			ACPI_FREE(table_desc.pointer);
+			return_ACPI_STATUS(status);
+		}
+
+		table_desc.address = obj_desc->region.address;
+		break;
+
+	case ACPI_TYPE_BUFFER:	/* Buffer or resolved region_field */
+
+		ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
+				  "Load table from Buffer or Field %p\n",
+				  obj_desc));
+
+		/* Must have at least an ACPI table header */
+
+		if (obj_desc->buffer.length < sizeof(struct acpi_table_header)) {
+			return_ACPI_STATUS(AE_INVALID_TABLE_LENGTH);
+		}
+
+		/* Get the actual table length from the table header */
+
+		table =
+		    ACPI_CAST_PTR(struct acpi_table_header,
+				  obj_desc->buffer.pointer);
+		length = table->length;
+
+		/* Table cannot extend beyond the buffer */
+
+		if (length > obj_desc->buffer.length) {
+			return_ACPI_STATUS(AE_AML_BUFFER_LIMIT);
+		}
+		if (length < sizeof(struct acpi_table_header)) {
+			return_ACPI_STATUS(AE_INVALID_TABLE_LENGTH);
+		}
+
+		/*
+		 * Copy the table from the buffer because the buffer could be modified
+		 * or even deleted in the future
+		 */
+		table_desc.pointer = ACPI_ALLOCATE(length);
+		if (!table_desc.pointer) {
+			return_ACPI_STATUS(AE_NO_MEMORY);
+		}
+
+		ACPI_MEMCPY(table_desc.pointer, table, length);
+		table_desc.address = ACPI_TO_INTEGER(table_desc.pointer);
+		break;
+
+	default:
+		return_ACPI_STATUS(AE_AML_OPERAND_TYPE);
+	}
+
+	/* Validate table checksum (will not get validated in tb_add_table) */
+
+	status = acpi_tb_verify_checksum(table_desc.pointer, length);
+	if (ACPI_FAILURE(status)) {
+		ACPI_FREE(table_desc.pointer);
+		return_ACPI_STATUS(status);
+	}
+
+	/* Complete the table descriptor */
+
+	table_desc.length = length;
+	table_desc.flags = ACPI_TABLE_ORIGIN_ALLOCATED;
+
+	/* Install the new table into the local data structures */
+
+	status = acpi_tb_add_table(&table_desc, &table_index);
+	if (ACPI_FAILURE(status)) {
+
+		/* Delete allocated table buffer */
+
+		acpi_tb_delete_table(&table_desc);
+		return_ACPI_STATUS(status);
+	}
+
+	/*
+	 * Add the table to the namespace.
+	 *
+	 * Note: Load the table objects relative to the root of the namespace.
+	 * This appears to go against the ACPI specification, but we do it for
+	 * compatibility with other ACPI implementations.
+	 */
+	status =
+	    acpi_ex_add_table(table_index, acpi_gbl_root_node, &ddb_handle);
+	if (ACPI_FAILURE(status)) {
+
+		/* On error, table_ptr was deallocated above */
+
+		return_ACPI_STATUS(status);
+	}
+
+	/* Store the ddb_handle into the Target operand */
+
+	status = acpi_ex_store(ddb_handle, target, walk_state);
+	if (ACPI_FAILURE(status)) {
+		(void)acpi_ex_unload_table(ddb_handle);
+
+		/* table_ptr was deallocated above */
+
+		acpi_ut_remove_reference(ddb_handle);
+		return_ACPI_STATUS(status);
+	}
+
+	ACPI_INFO((AE_INFO, "Dynamic OEM Table Load:"));
+	acpi_tb_print_table_header(0, table_desc.pointer);
+
+	/* Remove the reference by added by acpi_ex_store above */
+
+	acpi_ut_remove_reference(ddb_handle);
+
+	/* Invoke table handler if present */
+
+	if (acpi_gbl_table_handler) {
+		(void)acpi_gbl_table_handler(ACPI_TABLE_EVENT_LOAD,
+					     table_desc.pointer,
+					     acpi_gbl_table_handler_context);
+	}
+
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_unload_table
+ *
+ * PARAMETERS:  ddb_handle          - Handle to a previously loaded table
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Unload an ACPI table
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ex_unload_table(union acpi_operand_object *ddb_handle)
+{
+	acpi_status status = AE_OK;
+	union acpi_operand_object *table_desc = ddb_handle;
+	u32 table_index;
+	struct acpi_table_header *table;
+
+	ACPI_FUNCTION_TRACE(ex_unload_table);
+
+	/*
+	 * Validate the handle
+	 * Although the handle is partially validated in acpi_ex_reconfiguration()
+	 * when it calls acpi_ex_resolve_operands(), the handle is more completely
+	 * validated here.
+	 *
+	 * Handle must be a valid operand object of type reference. Also, the
+	 * ddb_handle must still be marked valid (table has not been previously
+	 * unloaded)
+	 */
+	if ((!ddb_handle) ||
+	    (ACPI_GET_DESCRIPTOR_TYPE(ddb_handle) != ACPI_DESC_TYPE_OPERAND) ||
+	    (ddb_handle->common.type != ACPI_TYPE_LOCAL_REFERENCE) ||
+	    (!(ddb_handle->common.flags & AOPOBJ_DATA_VALID))) {
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	/* Get the table index from the ddb_handle */
+
+	table_index = table_desc->reference.value;
+
+	/* Ensure the table is still loaded */
+
+	if (!acpi_tb_is_table_loaded(table_index)) {
+		return_ACPI_STATUS(AE_NOT_EXIST);
+	}
+
+	/* Invoke table handler if present */
+
+	if (acpi_gbl_table_handler) {
+		status = acpi_get_table_by_index(table_index, &table);
+		if (ACPI_SUCCESS(status)) {
+			(void)acpi_gbl_table_handler(ACPI_TABLE_EVENT_UNLOAD,
+						     table,
+						     acpi_gbl_table_handler_context);
+		}
+	}
+
+	/* Delete the portion of the namespace owned by this table */
+
+	status = acpi_tb_delete_namespace_by_owner(table_index);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	(void)acpi_tb_release_owner_id(table_index);
+	acpi_tb_set_table_loaded_flag(table_index, FALSE);
+
+	/*
+	 * Invalidate the handle. We do this because the handle may be stored
+	 * in a named object and may not be actually deleted until much later.
+	 */
+	ddb_handle->common.flags &= ~AOPOBJ_DATA_VALID;
+	return_ACPI_STATUS(AE_OK);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exconvrt.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exconvrt.c
new file mode 100644
index 00000000..71802eab
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exconvrt.c
@@ -0,0 +1,687 @@
+/******************************************************************************
+ *
+ * Module Name: exconvrt - Object conversion routines
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acinterp.h"
+#include "amlcode.h"
+
+#define _COMPONENT          ACPI_EXECUTER
+ACPI_MODULE_NAME("exconvrt")
+
+/* Local prototypes */
+static u32
+acpi_ex_convert_to_ascii(u64 integer, u16 base, u8 *string, u8 max_length);
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_convert_to_integer
+ *
+ * PARAMETERS:  obj_desc        - Object to be converted. Must be an
+ *                                Integer, Buffer, or String
+ *              result_desc     - Where the new Integer object is returned
+ *              Flags           - Used for string conversion
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Convert an ACPI Object to an integer.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ex_convert_to_integer(union acpi_operand_object *obj_desc,
+			   union acpi_operand_object **result_desc, u32 flags)
+{
+	union acpi_operand_object *return_desc;
+	u8 *pointer;
+	u64 result;
+	u32 i;
+	u32 count;
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE_PTR(ex_convert_to_integer, obj_desc);
+
+	switch (obj_desc->common.type) {
+	case ACPI_TYPE_INTEGER:
+
+		/* No conversion necessary */
+
+		*result_desc = obj_desc;
+		return_ACPI_STATUS(AE_OK);
+
+	case ACPI_TYPE_BUFFER:
+	case ACPI_TYPE_STRING:
+
+		/* Note: Takes advantage of common buffer/string fields */
+
+		pointer = obj_desc->buffer.pointer;
+		count = obj_desc->buffer.length;
+		break;
+
+	default:
+		return_ACPI_STATUS(AE_TYPE);
+	}
+
+	/*
+	 * Convert the buffer/string to an integer. Note that both buffers and
+	 * strings are treated as raw data - we don't convert ascii to hex for
+	 * strings.
+	 *
+	 * There are two terminating conditions for the loop:
+	 * 1) The size of an integer has been reached, or
+	 * 2) The end of the buffer or string has been reached
+	 */
+	result = 0;
+
+	/* String conversion is different than Buffer conversion */
+
+	switch (obj_desc->common.type) {
+	case ACPI_TYPE_STRING:
+
+		/*
+		 * Convert string to an integer - for most cases, the string must be
+		 * hexadecimal as per the ACPI specification. The only exception (as
+		 * of ACPI 3.0) is that the to_integer() operator allows both decimal
+		 * and hexadecimal strings (hex prefixed with "0x").
+		 */
+		status = acpi_ut_strtoul64((char *)pointer, flags, &result);
+		if (ACPI_FAILURE(status)) {
+			return_ACPI_STATUS(status);
+		}
+		break;
+
+	case ACPI_TYPE_BUFFER:
+
+		/* Check for zero-length buffer */
+
+		if (!count) {
+			return_ACPI_STATUS(AE_AML_BUFFER_LIMIT);
+		}
+
+		/* Transfer no more than an integer's worth of data */
+
+		if (count > acpi_gbl_integer_byte_width) {
+			count = acpi_gbl_integer_byte_width;
+		}
+
+		/*
+		 * Convert buffer to an integer - we simply grab enough raw data
+		 * from the buffer to fill an integer
+		 */
+		for (i = 0; i < count; i++) {
+			/*
+			 * Get next byte and shift it into the Result.
+			 * Little endian is used, meaning that the first byte of the buffer
+			 * is the LSB of the integer
+			 */
+			result |= (((u64)pointer[i]) << (i * 8));
+		}
+		break;
+
+	default:
+
+		/* No other types can get here */
+		break;
+	}
+
+	/* Create a new integer */
+
+	return_desc = acpi_ut_create_integer_object(result);
+	if (!return_desc) {
+		return_ACPI_STATUS(AE_NO_MEMORY);
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_EXEC, "Converted value: %8.8X%8.8X\n",
+			  ACPI_FORMAT_UINT64(result)));
+
+	/* Save the Result */
+
+	acpi_ex_truncate_for32bit_table(return_desc);
+	*result_desc = return_desc;
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_convert_to_buffer
+ *
+ * PARAMETERS:  obj_desc        - Object to be converted. Must be an
+ *                                Integer, Buffer, or String
+ *              result_desc     - Where the new buffer object is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Convert an ACPI Object to a Buffer
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ex_convert_to_buffer(union acpi_operand_object *obj_desc,
+			  union acpi_operand_object **result_desc)
+{
+	union acpi_operand_object *return_desc;
+	u8 *new_buf;
+
+	ACPI_FUNCTION_TRACE_PTR(ex_convert_to_buffer, obj_desc);
+
+	switch (obj_desc->common.type) {
+	case ACPI_TYPE_BUFFER:
+
+		/* No conversion necessary */
+
+		*result_desc = obj_desc;
+		return_ACPI_STATUS(AE_OK);
+
+	case ACPI_TYPE_INTEGER:
+
+		/*
+		 * Create a new Buffer object.
+		 * Need enough space for one integer
+		 */
+		return_desc =
+		    acpi_ut_create_buffer_object(acpi_gbl_integer_byte_width);
+		if (!return_desc) {
+			return_ACPI_STATUS(AE_NO_MEMORY);
+		}
+
+		/* Copy the integer to the buffer, LSB first */
+
+		new_buf = return_desc->buffer.pointer;
+		ACPI_MEMCPY(new_buf,
+			    &obj_desc->integer.value,
+			    acpi_gbl_integer_byte_width);
+		break;
+
+	case ACPI_TYPE_STRING:
+
+		/*
+		 * Create a new Buffer object
+		 * Size will be the string length
+		 *
+		 * NOTE: Add one to the string length to include the null terminator.
+		 * The ACPI spec is unclear on this subject, but there is existing
+		 * ASL/AML code that depends on the null being transferred to the new
+		 * buffer.
+		 */
+		return_desc = acpi_ut_create_buffer_object((acpi_size)
+							   obj_desc->string.
+							   length + 1);
+		if (!return_desc) {
+			return_ACPI_STATUS(AE_NO_MEMORY);
+		}
+
+		/* Copy the string to the buffer */
+
+		new_buf = return_desc->buffer.pointer;
+		ACPI_STRNCPY((char *)new_buf, (char *)obj_desc->string.pointer,
+			     obj_desc->string.length);
+		break;
+
+	default:
+		return_ACPI_STATUS(AE_TYPE);
+	}
+
+	/* Mark buffer initialized */
+
+	return_desc->common.flags |= AOPOBJ_DATA_VALID;
+	*result_desc = return_desc;
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_convert_to_ascii
+ *
+ * PARAMETERS:  Integer         - Value to be converted
+ *              Base            - ACPI_STRING_DECIMAL or ACPI_STRING_HEX
+ *              String          - Where the string is returned
+ *              data_width      - Size of data item to be converted, in bytes
+ *
+ * RETURN:      Actual string length
+ *
+ * DESCRIPTION: Convert an ACPI Integer to a hex or decimal string
+ *
+ ******************************************************************************/
+
+static u32
+acpi_ex_convert_to_ascii(u64 integer, u16 base, u8 *string, u8 data_width)
+{
+	u64 digit;
+	u32 i;
+	u32 j;
+	u32 k = 0;
+	u32 hex_length;
+	u32 decimal_length;
+	u32 remainder;
+	u8 supress_zeros;
+
+	ACPI_FUNCTION_ENTRY();
+
+	switch (base) {
+	case 10:
+
+		/* Setup max length for the decimal number */
+
+		switch (data_width) {
+		case 1:
+			decimal_length = ACPI_MAX8_DECIMAL_DIGITS;
+			break;
+
+		case 4:
+			decimal_length = ACPI_MAX32_DECIMAL_DIGITS;
+			break;
+
+		case 8:
+		default:
+			decimal_length = ACPI_MAX64_DECIMAL_DIGITS;
+			break;
+		}
+
+		supress_zeros = TRUE;	/* No leading zeros */
+		remainder = 0;
+
+		for (i = decimal_length; i > 0; i--) {
+
+			/* Divide by nth factor of 10 */
+
+			digit = integer;
+			for (j = 0; j < i; j++) {
+				(void)acpi_ut_short_divide(digit, 10, &digit,
+							   &remainder);
+			}
+
+			/* Handle leading zeros */
+
+			if (remainder != 0) {
+				supress_zeros = FALSE;
+			}
+
+			if (!supress_zeros) {
+				string[k] = (u8)(ACPI_ASCII_ZERO + remainder);
+				k++;
+			}
+		}
+		break;
+
+	case 16:
+
+		/* hex_length: 2 ascii hex chars per data byte */
+
+		hex_length = ACPI_MUL_2(data_width);
+		for (i = 0, j = (hex_length - 1); i < hex_length; i++, j--) {
+
+			/* Get one hex digit, most significant digits first */
+
+			string[k] =
+			    (u8)acpi_ut_hex_to_ascii_char(integer,
+							  ACPI_MUL_4(j));
+			k++;
+		}
+		break;
+
+	default:
+		return (0);
+	}
+
+	/*
+	 * Since leading zeros are suppressed, we must check for the case where
+	 * the integer equals 0
+	 *
+	 * Finally, null terminate the string and return the length
+	 */
+	if (!k) {
+		string[0] = ACPI_ASCII_ZERO;
+		k = 1;
+	}
+
+	string[k] = 0;
+	return ((u32)k);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_convert_to_string
+ *
+ * PARAMETERS:  obj_desc        - Object to be converted. Must be an
+ *                                Integer, Buffer, or String
+ *              result_desc     - Where the string object is returned
+ *              Type            - String flags (base and conversion type)
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Convert an ACPI Object to a string
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ex_convert_to_string(union acpi_operand_object *obj_desc,
+			  union acpi_operand_object **result_desc, u32 type)
+{
+	union acpi_operand_object *return_desc;
+	u8 *new_buf;
+	u32 i;
+	u32 string_length = 0;
+	u16 base = 16;
+	u8 separator = ',';
+
+	ACPI_FUNCTION_TRACE_PTR(ex_convert_to_string, obj_desc);
+
+	switch (obj_desc->common.type) {
+	case ACPI_TYPE_STRING:
+
+		/* No conversion necessary */
+
+		*result_desc = obj_desc;
+		return_ACPI_STATUS(AE_OK);
+
+	case ACPI_TYPE_INTEGER:
+
+		switch (type) {
+		case ACPI_EXPLICIT_CONVERT_DECIMAL:
+
+			/* Make room for maximum decimal number */
+
+			string_length = ACPI_MAX_DECIMAL_DIGITS;
+			base = 10;
+			break;
+
+		default:
+
+			/* Two hex string characters for each integer byte */
+
+			string_length = ACPI_MUL_2(acpi_gbl_integer_byte_width);
+			break;
+		}
+
+		/*
+		 * Create a new String
+		 * Need enough space for one ASCII integer (plus null terminator)
+		 */
+		return_desc =
+		    acpi_ut_create_string_object((acpi_size) string_length);
+		if (!return_desc) {
+			return_ACPI_STATUS(AE_NO_MEMORY);
+		}
+
+		new_buf = return_desc->buffer.pointer;
+
+		/* Convert integer to string */
+
+		string_length =
+		    acpi_ex_convert_to_ascii(obj_desc->integer.value, base,
+					     new_buf,
+					     acpi_gbl_integer_byte_width);
+
+		/* Null terminate at the correct place */
+
+		return_desc->string.length = string_length;
+		new_buf[string_length] = 0;
+		break;
+
+	case ACPI_TYPE_BUFFER:
+
+		/* Setup string length, base, and separator */
+
+		switch (type) {
+		case ACPI_EXPLICIT_CONVERT_DECIMAL:	/* Used by to_decimal_string */
+			/*
+			 * From ACPI: "If Data is a buffer, it is converted to a string of
+			 * decimal values separated by commas."
+			 */
+			base = 10;
+
+			/*
+			 * Calculate the final string length. Individual string values
+			 * are variable length (include separator for each)
+			 */
+			for (i = 0; i < obj_desc->buffer.length; i++) {
+				if (obj_desc->buffer.pointer[i] >= 100) {
+					string_length += 4;
+				} else if (obj_desc->buffer.pointer[i] >= 10) {
+					string_length += 3;
+				} else {
+					string_length += 2;
+				}
+			}
+			break;
+
+		case ACPI_IMPLICIT_CONVERT_HEX:
+			/*
+			 * From the ACPI spec:
+			 *"The entire contents of the buffer are converted to a string of
+			 * two-character hexadecimal numbers, each separated by a space."
+			 */
+			separator = ' ';
+			string_length = (obj_desc->buffer.length * 3);
+			break;
+
+		case ACPI_EXPLICIT_CONVERT_HEX:	/* Used by to_hex_string */
+			/*
+			 * From ACPI: "If Data is a buffer, it is converted to a string of
+			 * hexadecimal values separated by commas."
+			 */
+			string_length = (obj_desc->buffer.length * 3);
+			break;
+
+		default:
+			return_ACPI_STATUS(AE_BAD_PARAMETER);
+		}
+
+		/*
+		 * Create a new string object and string buffer
+		 * (-1 because of extra separator included in string_length from above)
+		 * Allow creation of zero-length strings from zero-length buffers.
+		 */
+		if (string_length) {
+			string_length--;
+		}
+
+		return_desc =
+		    acpi_ut_create_string_object((acpi_size) string_length);
+		if (!return_desc) {
+			return_ACPI_STATUS(AE_NO_MEMORY);
+		}
+
+		new_buf = return_desc->buffer.pointer;
+
+		/*
+		 * Convert buffer bytes to hex or decimal values
+		 * (separated by commas or spaces)
+		 */
+		for (i = 0; i < obj_desc->buffer.length; i++) {
+			new_buf += acpi_ex_convert_to_ascii((u64)obj_desc->
+							    buffer.pointer[i],
+							    base, new_buf, 1);
+			*new_buf++ = separator;	/* each separated by a comma or space */
+		}
+
+		/*
+		 * Null terminate the string
+		 * (overwrites final comma/space from above)
+		 */
+		if (obj_desc->buffer.length) {
+			new_buf--;
+		}
+		*new_buf = 0;
+		break;
+
+	default:
+		return_ACPI_STATUS(AE_TYPE);
+	}
+
+	*result_desc = return_desc;
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_convert_to_target_type
+ *
+ * PARAMETERS:  destination_type    - Current type of the destination
+ *              source_desc         - Source object to be converted.
+ *              result_desc         - Where the converted object is returned
+ *              walk_state          - Current method state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Implements "implicit conversion" rules for storing an object.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ex_convert_to_target_type(acpi_object_type destination_type,
+			       union acpi_operand_object *source_desc,
+			       union acpi_operand_object **result_desc,
+			       struct acpi_walk_state *walk_state)
+{
+	acpi_status status = AE_OK;
+
+	ACPI_FUNCTION_TRACE(ex_convert_to_target_type);
+
+	/* Default behavior */
+
+	*result_desc = source_desc;
+
+	/*
+	 * If required by the target,
+	 * perform implicit conversion on the source before we store it.
+	 */
+	switch (GET_CURRENT_ARG_TYPE(walk_state->op_info->runtime_args)) {
+	case ARGI_SIMPLE_TARGET:
+	case ARGI_FIXED_TARGET:
+	case ARGI_INTEGER_REF:	/* Handles Increment, Decrement cases */
+
+		switch (destination_type) {
+		case ACPI_TYPE_LOCAL_REGION_FIELD:
+			/*
+			 * Named field can always handle conversions
+			 */
+			break;
+
+		default:
+			/* No conversion allowed for these types */
+
+			if (destination_type != source_desc->common.type) {
+				ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+						  "Explicit operator, will store (%s) over existing type (%s)\n",
+						  acpi_ut_get_object_type_name
+						  (source_desc),
+						  acpi_ut_get_type_name
+						  (destination_type)));
+				status = AE_TYPE;
+			}
+		}
+		break;
+
+	case ARGI_TARGETREF:
+
+		switch (destination_type) {
+		case ACPI_TYPE_INTEGER:
+		case ACPI_TYPE_BUFFER_FIELD:
+		case ACPI_TYPE_LOCAL_BANK_FIELD:
+		case ACPI_TYPE_LOCAL_INDEX_FIELD:
+			/*
+			 * These types require an Integer operand. We can convert
+			 * a Buffer or a String to an Integer if necessary.
+			 */
+			status =
+			    acpi_ex_convert_to_integer(source_desc, result_desc,
+						       16);
+			break;
+
+		case ACPI_TYPE_STRING:
+			/*
+			 * The operand must be a String. We can convert an
+			 * Integer or Buffer if necessary
+			 */
+			status =
+			    acpi_ex_convert_to_string(source_desc, result_desc,
+						      ACPI_IMPLICIT_CONVERT_HEX);
+			break;
+
+		case ACPI_TYPE_BUFFER:
+			/*
+			 * The operand must be a Buffer. We can convert an
+			 * Integer or String if necessary
+			 */
+			status =
+			    acpi_ex_convert_to_buffer(source_desc, result_desc);
+			break;
+
+		default:
+			ACPI_ERROR((AE_INFO,
+				    "Bad destination type during conversion: 0x%X",
+				    destination_type));
+			status = AE_AML_INTERNAL;
+			break;
+		}
+		break;
+
+	case ARGI_REFERENCE:
+		/*
+		 * create_xxxx_field cases - we are storing the field object into the name
+		 */
+		break;
+
+	default:
+		ACPI_ERROR((AE_INFO,
+			    "Unknown Target type ID 0x%X AmlOpcode 0x%X DestType %s",
+			    GET_CURRENT_ARG_TYPE(walk_state->op_info->
+						 runtime_args),
+			    walk_state->opcode,
+			    acpi_ut_get_type_name(destination_type)));
+		status = AE_AML_INTERNAL;
+	}
+
+	/*
+	 * Source-to-Target conversion semantics:
+	 *
+	 * If conversion to the target type cannot be performed, then simply
+	 * overwrite the target with the new object and type.
+	 */
+	if (status == AE_TYPE) {
+		status = AE_OK;
+	}
+
+	return_ACPI_STATUS(status);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/excreate.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/excreate.c
new file mode 100644
index 00000000..c057702d
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/excreate.c
@@ -0,0 +1,531 @@
+/******************************************************************************
+ *
+ * Module Name: excreate - Named object creation
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acinterp.h"
+#include "amlcode.h"
+#include "acnamesp.h"
+
+#define _COMPONENT          ACPI_EXECUTER
+ACPI_MODULE_NAME("excreate")
+
+#ifndef ACPI_NO_METHOD_EXECUTION
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_create_alias
+ *
+ * PARAMETERS:  walk_state           - Current state, contains operands
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Create a new named alias
+ *
+ ******************************************************************************/
+acpi_status acpi_ex_create_alias(struct acpi_walk_state *walk_state)
+{
+	struct acpi_namespace_node *target_node;
+	struct acpi_namespace_node *alias_node;
+	acpi_status status = AE_OK;
+
+	ACPI_FUNCTION_TRACE(ex_create_alias);
+
+	/* Get the source/alias operands (both namespace nodes) */
+
+	alias_node = (struct acpi_namespace_node *)walk_state->operands[0];
+	target_node = (struct acpi_namespace_node *)walk_state->operands[1];
+
+	if ((target_node->type == ACPI_TYPE_LOCAL_ALIAS) ||
+	    (target_node->type == ACPI_TYPE_LOCAL_METHOD_ALIAS)) {
+		/*
+		 * Dereference an existing alias so that we don't create a chain
+		 * of aliases.  With this code, we guarantee that an alias is
+		 * always exactly one level of indirection away from the
+		 * actual aliased name.
+		 */
+		target_node =
+		    ACPI_CAST_PTR(struct acpi_namespace_node,
+				  target_node->object);
+	}
+
+	/*
+	 * For objects that can never change (i.e., the NS node will
+	 * permanently point to the same object), we can simply attach
+	 * the object to the new NS node.  For other objects (such as
+	 * Integers, buffers, etc.), we have to point the Alias node
+	 * to the original Node.
+	 */
+	switch (target_node->type) {
+
+		/* For these types, the sub-object can change dynamically via a Store */
+
+	case ACPI_TYPE_INTEGER:
+	case ACPI_TYPE_STRING:
+	case ACPI_TYPE_BUFFER:
+	case ACPI_TYPE_PACKAGE:
+	case ACPI_TYPE_BUFFER_FIELD:
+
+		/*
+		 * These types open a new scope, so we need the NS node in order to access
+		 * any children.
+		 */
+	case ACPI_TYPE_DEVICE:
+	case ACPI_TYPE_POWER:
+	case ACPI_TYPE_PROCESSOR:
+	case ACPI_TYPE_THERMAL:
+	case ACPI_TYPE_LOCAL_SCOPE:
+
+		/*
+		 * The new alias has the type ALIAS and points to the original
+		 * NS node, not the object itself.
+		 */
+		alias_node->type = ACPI_TYPE_LOCAL_ALIAS;
+		alias_node->object =
+		    ACPI_CAST_PTR(union acpi_operand_object, target_node);
+		break;
+
+	case ACPI_TYPE_METHOD:
+
+		/*
+		 * Control method aliases need to be differentiated
+		 */
+		alias_node->type = ACPI_TYPE_LOCAL_METHOD_ALIAS;
+		alias_node->object =
+		    ACPI_CAST_PTR(union acpi_operand_object, target_node);
+		break;
+
+	default:
+
+		/* Attach the original source object to the new Alias Node */
+
+		/*
+		 * The new alias assumes the type of the target, and it points
+		 * to the same object.  The reference count of the object has an
+		 * additional reference to prevent deletion out from under either the
+		 * target node or the alias Node
+		 */
+		status = acpi_ns_attach_object(alias_node,
+					       acpi_ns_get_attached_object
+					       (target_node),
+					       target_node->type);
+		break;
+	}
+
+	/* Since both operands are Nodes, we don't need to delete them */
+
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_create_event
+ *
+ * PARAMETERS:  walk_state          - Current state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Create a new event object
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ex_create_event(struct acpi_walk_state *walk_state)
+{
+	acpi_status status;
+	union acpi_operand_object *obj_desc;
+
+	ACPI_FUNCTION_TRACE(ex_create_event);
+
+	obj_desc = acpi_ut_create_internal_object(ACPI_TYPE_EVENT);
+	if (!obj_desc) {
+		status = AE_NO_MEMORY;
+		goto cleanup;
+	}
+
+	/*
+	 * Create the actual OS semaphore, with zero initial units -- meaning
+	 * that the event is created in an unsignalled state
+	 */
+	status = acpi_os_create_semaphore(ACPI_NO_UNIT_LIMIT, 0,
+					  &obj_desc->event.os_semaphore);
+	if (ACPI_FAILURE(status)) {
+		goto cleanup;
+	}
+
+	/* Attach object to the Node */
+
+	status =
+	    acpi_ns_attach_object((struct acpi_namespace_node *)walk_state->
+				  operands[0], obj_desc, ACPI_TYPE_EVENT);
+
+      cleanup:
+	/*
+	 * Remove local reference to the object (on error, will cause deletion
+	 * of both object and semaphore if present.)
+	 */
+	acpi_ut_remove_reference(obj_desc);
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_create_mutex
+ *
+ * PARAMETERS:  walk_state          - Current state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Create a new mutex object
+ *
+ *              Mutex (Name[0], sync_level[1])
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ex_create_mutex(struct acpi_walk_state *walk_state)
+{
+	acpi_status status = AE_OK;
+	union acpi_operand_object *obj_desc;
+
+	ACPI_FUNCTION_TRACE_PTR(ex_create_mutex, ACPI_WALK_OPERANDS);
+
+	/* Create the new mutex object */
+
+	obj_desc = acpi_ut_create_internal_object(ACPI_TYPE_MUTEX);
+	if (!obj_desc) {
+		status = AE_NO_MEMORY;
+		goto cleanup;
+	}
+
+	/* Create the actual OS Mutex */
+
+	status = acpi_os_create_mutex(&obj_desc->mutex.os_mutex);
+	if (ACPI_FAILURE(status)) {
+		goto cleanup;
+	}
+
+	/* Init object and attach to NS node */
+
+	obj_desc->mutex.sync_level = (u8)walk_state->operands[1]->integer.value;
+	obj_desc->mutex.node =
+	    (struct acpi_namespace_node *)walk_state->operands[0];
+
+	status =
+	    acpi_ns_attach_object(obj_desc->mutex.node, obj_desc,
+				  ACPI_TYPE_MUTEX);
+
+      cleanup:
+	/*
+	 * Remove local reference to the object (on error, will cause deletion
+	 * of both object and semaphore if present.)
+	 */
+	acpi_ut_remove_reference(obj_desc);
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_create_region
+ *
+ * PARAMETERS:  aml_start           - Pointer to the region declaration AML
+ *              aml_length          - Max length of the declaration AML
+ *              space_id            - Address space ID for the region
+ *              walk_state          - Current state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Create a new operation region object
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ex_create_region(u8 *aml_start,
+		      u32 aml_length,
+		      u8 space_id, struct acpi_walk_state *walk_state)
+{
+	acpi_status status;
+	union acpi_operand_object *obj_desc;
+	struct acpi_namespace_node *node;
+	union acpi_operand_object *region_obj2;
+
+	ACPI_FUNCTION_TRACE(ex_create_region);
+
+	/* Get the Namespace Node */
+
+	node = walk_state->op->common.node;
+
+	/*
+	 * If the region object is already attached to this node,
+	 * just return
+	 */
+	if (acpi_ns_get_attached_object(node)) {
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	/*
+	 * Space ID must be one of the predefined IDs, or in the user-defined
+	 * range
+	 */
+	if (!acpi_is_valid_space_id(space_id)) {
+		/*
+		 * Print an error message, but continue. We don't want to abort
+		 * a table load for this exception. Instead, if the region is
+		 * actually used at runtime, abort the executing method.
+		 */
+		ACPI_ERROR((AE_INFO,
+			    "Invalid/unknown Address Space ID: 0x%2.2X",
+			    space_id));
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_LOAD, "Region Type - %s (0x%X)\n",
+			  acpi_ut_get_region_name(space_id), space_id));
+
+	/* Create the region descriptor */
+
+	obj_desc = acpi_ut_create_internal_object(ACPI_TYPE_REGION);
+	if (!obj_desc) {
+		status = AE_NO_MEMORY;
+		goto cleanup;
+	}
+
+	/*
+	 * Remember location in AML stream of address & length
+	 * operands since they need to be evaluated at run time.
+	 */
+	region_obj2 = obj_desc->common.next_object;
+	region_obj2->extra.aml_start = aml_start;
+	region_obj2->extra.aml_length = aml_length;
+	if (walk_state->scope_info) {
+		region_obj2->extra.scope_node =
+		    walk_state->scope_info->scope.node;
+	} else {
+		region_obj2->extra.scope_node = node;
+	}
+
+	/* Init the region from the operands */
+
+	obj_desc->region.space_id = space_id;
+	obj_desc->region.address = 0;
+	obj_desc->region.length = 0;
+	obj_desc->region.node = node;
+
+	/* Install the new region object in the parent Node */
+
+	status = acpi_ns_attach_object(node, obj_desc, ACPI_TYPE_REGION);
+
+      cleanup:
+
+	/* Remove local reference to the object */
+
+	acpi_ut_remove_reference(obj_desc);
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_create_processor
+ *
+ * PARAMETERS:  walk_state          - Current state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Create a new processor object and populate the fields
+ *
+ *              Processor (Name[0], cpu_iD[1], pblock_addr[2], pblock_length[3])
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ex_create_processor(struct acpi_walk_state *walk_state)
+{
+	union acpi_operand_object **operand = &walk_state->operands[0];
+	union acpi_operand_object *obj_desc;
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE_PTR(ex_create_processor, walk_state);
+
+	/* Create the processor object */
+
+	obj_desc = acpi_ut_create_internal_object(ACPI_TYPE_PROCESSOR);
+	if (!obj_desc) {
+		return_ACPI_STATUS(AE_NO_MEMORY);
+	}
+
+	/* Initialize the processor object from the operands */
+
+	obj_desc->processor.proc_id = (u8)operand[1]->integer.value;
+	obj_desc->processor.length = (u8)operand[3]->integer.value;
+	obj_desc->processor.address =
+	    (acpi_io_address) operand[2]->integer.value;
+
+	/* Install the processor object in the parent Node */
+
+	status = acpi_ns_attach_object((struct acpi_namespace_node *)operand[0],
+				       obj_desc, ACPI_TYPE_PROCESSOR);
+
+	/* Remove local reference to the object */
+
+	acpi_ut_remove_reference(obj_desc);
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_create_power_resource
+ *
+ * PARAMETERS:  walk_state          - Current state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Create a new power_resource object and populate the fields
+ *
+ *              power_resource (Name[0], system_level[1], resource_order[2])
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ex_create_power_resource(struct acpi_walk_state *walk_state)
+{
+	union acpi_operand_object **operand = &walk_state->operands[0];
+	acpi_status status;
+	union acpi_operand_object *obj_desc;
+
+	ACPI_FUNCTION_TRACE_PTR(ex_create_power_resource, walk_state);
+
+	/* Create the power resource object */
+
+	obj_desc = acpi_ut_create_internal_object(ACPI_TYPE_POWER);
+	if (!obj_desc) {
+		return_ACPI_STATUS(AE_NO_MEMORY);
+	}
+
+	/* Initialize the power object from the operands */
+
+	obj_desc->power_resource.system_level = (u8)operand[1]->integer.value;
+	obj_desc->power_resource.resource_order =
+	    (u16)operand[2]->integer.value;
+
+	/* Install the  power resource object in the parent Node */
+
+	status = acpi_ns_attach_object((struct acpi_namespace_node *)operand[0],
+				       obj_desc, ACPI_TYPE_POWER);
+
+	/* Remove local reference to the object */
+
+	acpi_ut_remove_reference(obj_desc);
+	return_ACPI_STATUS(status);
+}
+#endif
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_create_method
+ *
+ * PARAMETERS:  aml_start       - First byte of the method's AML
+ *              aml_length      - AML byte count for this method
+ *              walk_state      - Current state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Create a new method object
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ex_create_method(u8 *aml_start,
+		      u32 aml_length, struct acpi_walk_state *walk_state)
+{
+	union acpi_operand_object **operand = &walk_state->operands[0];
+	union acpi_operand_object *obj_desc;
+	acpi_status status;
+	u8 method_flags;
+
+	ACPI_FUNCTION_TRACE_PTR(ex_create_method, walk_state);
+
+	/* Create a new method object */
+
+	obj_desc = acpi_ut_create_internal_object(ACPI_TYPE_METHOD);
+	if (!obj_desc) {
+		status = AE_NO_MEMORY;
+		goto exit;
+	}
+
+	/* Save the method's AML pointer and length  */
+
+	obj_desc->method.aml_start = aml_start;
+	obj_desc->method.aml_length = aml_length;
+
+	/*
+	 * Disassemble the method flags. Split off the arg_count, Serialized
+	 * flag, and sync_level for efficiency.
+	 */
+	method_flags = (u8)operand[1]->integer.value;
+	obj_desc->method.param_count =
+	    (u8)(method_flags & AML_METHOD_ARG_COUNT);
+
+	/*
+	 * Get the sync_level. If method is serialized, a mutex will be
+	 * created for this method when it is parsed.
+	 */
+	if (method_flags & AML_METHOD_SERIALIZED) {
+		obj_desc->method.info_flags = ACPI_METHOD_SERIALIZED;
+
+		/*
+		 * ACPI 1.0: sync_level = 0
+		 * ACPI 2.0: sync_level = sync_level in method declaration
+		 */
+		obj_desc->method.sync_level = (u8)
+		    ((method_flags & AML_METHOD_SYNC_LEVEL) >> 4);
+	}
+
+	/* Attach the new object to the method Node */
+
+	status = acpi_ns_attach_object((struct acpi_namespace_node *)operand[0],
+				       obj_desc, ACPI_TYPE_METHOD);
+
+	/* Remove local reference to the object */
+
+	acpi_ut_remove_reference(obj_desc);
+
+      exit:
+	/* Remove a reference to the operand */
+
+	acpi_ut_remove_reference(operand[1]);
+	return_ACPI_STATUS(status);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exdebug.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exdebug.c
new file mode 100644
index 00000000..e211e9c1
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exdebug.c
@@ -0,0 +1,261 @@
+/******************************************************************************
+ *
+ * Module Name: exdebug - Support for stores to the AML Debug Object
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acinterp.h"
+
+#define _COMPONENT          ACPI_EXECUTER
+ACPI_MODULE_NAME("exdebug")
+
+#ifndef ACPI_NO_ERROR_MESSAGES
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_do_debug_object
+ *
+ * PARAMETERS:  source_desc         - Object to be output to "Debug Object"
+ *              Level               - Indentation level (used for packages)
+ *              Index               - Current package element, zero if not pkg
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Handles stores to the AML Debug Object. For example:
+ *              Store(INT1, Debug)
+ *
+ * This function is not compiled if ACPI_NO_ERROR_MESSAGES is set.
+ *
+ * This function is only enabled if acpi_gbl_enable_aml_debug_object is set, or
+ * if ACPI_LV_DEBUG_OBJECT is set in the acpi_dbg_level. Thus, in the normal
+ * operational case, stores to the debug object are ignored but can be easily
+ * enabled if necessary.
+ *
+ ******************************************************************************/
+void
+acpi_ex_do_debug_object(union acpi_operand_object *source_desc,
+			u32 level, u32 index)
+{
+	u32 i;
+
+	ACPI_FUNCTION_TRACE_PTR(ex_do_debug_object, source_desc);
+
+	/* Output must be enabled via the debug_object global or the dbg_level */
+
+	if (!acpi_gbl_enable_aml_debug_object &&
+	    !(acpi_dbg_level & ACPI_LV_DEBUG_OBJECT)) {
+		return_VOID;
+	}
+
+	/*
+	 * Print line header as long as we are not in the middle of an
+	 * object display
+	 */
+	if (!((level > 0) && index == 0)) {
+		acpi_os_printf("[ACPI Debug] %*s", level, " ");
+	}
+
+	/* Display the index for package output only */
+
+	if (index > 0) {
+		acpi_os_printf("(%.2u) ", index - 1);
+	}
+
+	if (!source_desc) {
+		acpi_os_printf("[Null Object]\n");
+		return_VOID;
+	}
+
+	if (ACPI_GET_DESCRIPTOR_TYPE(source_desc) == ACPI_DESC_TYPE_OPERAND) {
+		acpi_os_printf("%s ",
+			       acpi_ut_get_object_type_name(source_desc));
+
+		if (!acpi_ut_valid_internal_object(source_desc)) {
+			acpi_os_printf("%p, Invalid Internal Object!\n",
+				       source_desc);
+			return_VOID;
+		}
+	} else if (ACPI_GET_DESCRIPTOR_TYPE(source_desc) ==
+		   ACPI_DESC_TYPE_NAMED) {
+		acpi_os_printf("%s: %p\n",
+			       acpi_ut_get_type_name(((struct
+						       acpi_namespace_node *)
+						      source_desc)->type),
+			       source_desc);
+		return_VOID;
+	} else {
+		return_VOID;
+	}
+
+	/* source_desc is of type ACPI_DESC_TYPE_OPERAND */
+
+	switch (source_desc->common.type) {
+	case ACPI_TYPE_INTEGER:
+
+		/* Output correct integer width */
+
+		if (acpi_gbl_integer_byte_width == 4) {
+			acpi_os_printf("0x%8.8X\n",
+				       (u32)source_desc->integer.value);
+		} else {
+			acpi_os_printf("0x%8.8X%8.8X\n",
+				       ACPI_FORMAT_UINT64(source_desc->integer.
+							  value));
+		}
+		break;
+
+	case ACPI_TYPE_BUFFER:
+
+		acpi_os_printf("[0x%.2X]\n", (u32)source_desc->buffer.length);
+		acpi_ut_dump_buffer2(source_desc->buffer.pointer,
+				     (source_desc->buffer.length < 256) ?
+				     source_desc->buffer.length : 256,
+				     DB_BYTE_DISPLAY);
+		break;
+
+	case ACPI_TYPE_STRING:
+
+		acpi_os_printf("[0x%.2X] \"%s\"\n",
+			       source_desc->string.length,
+			       source_desc->string.pointer);
+		break;
+
+	case ACPI_TYPE_PACKAGE:
+
+		acpi_os_printf("[Contains 0x%.2X Elements]\n",
+			       source_desc->package.count);
+
+		/* Output the entire contents of the package */
+
+		for (i = 0; i < source_desc->package.count; i++) {
+			acpi_ex_do_debug_object(source_desc->package.
+						elements[i], level + 4, i + 1);
+		}
+		break;
+
+	case ACPI_TYPE_LOCAL_REFERENCE:
+
+		acpi_os_printf("[%s] ",
+			       acpi_ut_get_reference_name(source_desc));
+
+		/* Decode the reference */
+
+		switch (source_desc->reference.class) {
+		case ACPI_REFCLASS_INDEX:
+
+			acpi_os_printf("0x%X\n", source_desc->reference.value);
+			break;
+
+		case ACPI_REFCLASS_TABLE:
+
+			/* Case for ddb_handle */
+
+			acpi_os_printf("Table Index 0x%X\n",
+				       source_desc->reference.value);
+			return;
+
+		default:
+			break;
+		}
+
+		acpi_os_printf(" ");
+
+		/* Check for valid node first, then valid object */
+
+		if (source_desc->reference.node) {
+			if (ACPI_GET_DESCRIPTOR_TYPE
+			    (source_desc->reference.node) !=
+			    ACPI_DESC_TYPE_NAMED) {
+				acpi_os_printf
+				    (" %p - Not a valid namespace node\n",
+				     source_desc->reference.node);
+			} else {
+				acpi_os_printf("Node %p [%4.4s] ",
+					       source_desc->reference.node,
+					       (source_desc->reference.node)->
+					       name.ascii);
+
+				switch ((source_desc->reference.node)->type) {
+
+					/* These types have no attached object */
+
+				case ACPI_TYPE_DEVICE:
+					acpi_os_printf("Device\n");
+					break;
+
+				case ACPI_TYPE_THERMAL:
+					acpi_os_printf("Thermal Zone\n");
+					break;
+
+				default:
+					acpi_ex_do_debug_object((source_desc->
+								 reference.
+								 node)->object,
+								level + 4, 0);
+					break;
+				}
+			}
+		} else if (source_desc->reference.object) {
+			if (ACPI_GET_DESCRIPTOR_TYPE
+			    (source_desc->reference.object) ==
+			    ACPI_DESC_TYPE_NAMED) {
+				acpi_ex_do_debug_object(((struct
+							  acpi_namespace_node *)
+							 source_desc->reference.
+							 object)->object,
+							level + 4, 0);
+			} else {
+				acpi_ex_do_debug_object(source_desc->reference.
+							object, level + 4, 0);
+			}
+		}
+		break;
+
+	default:
+
+		acpi_os_printf("%p\n", source_desc);
+		break;
+	}
+
+	ACPI_DEBUG_PRINT_RAW((ACPI_DB_EXEC, "\n"));
+	return_VOID;
+}
+#endif
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exdump.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exdump.c
new file mode 100644
index 00000000..9284e105
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exdump.c
@@ -0,0 +1,1039 @@
+/******************************************************************************
+ *
+ * Module Name: exdump - Interpreter debug output routines
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acinterp.h"
+#include "amlcode.h"
+#include "acnamesp.h"
+
+#define _COMPONENT          ACPI_EXECUTER
+ACPI_MODULE_NAME("exdump")
+
+/*
+ * The following routines are used for debug output only
+ */
+#if defined(ACPI_DEBUG_OUTPUT) || defined(ACPI_DEBUGGER)
+/* Local prototypes */
+static void acpi_ex_out_string(char *title, char *value);
+
+static void acpi_ex_out_pointer(char *title, void *value);
+
+static void
+acpi_ex_dump_object(union acpi_operand_object *obj_desc,
+		    struct acpi_exdump_info *info);
+
+static void acpi_ex_dump_reference_obj(union acpi_operand_object *obj_desc);
+
+static void
+acpi_ex_dump_package_obj(union acpi_operand_object *obj_desc,
+			 u32 level, u32 index);
+
+/*******************************************************************************
+ *
+ * Object Descriptor info tables
+ *
+ * Note: The first table entry must be an INIT opcode and must contain
+ * the table length (number of table entries)
+ *
+ ******************************************************************************/
+
+static struct acpi_exdump_info acpi_ex_dump_integer[2] = {
+	{ACPI_EXD_INIT, ACPI_EXD_TABLE_SIZE(acpi_ex_dump_integer), NULL},
+	{ACPI_EXD_UINT64, ACPI_EXD_OFFSET(integer.value), "Value"}
+};
+
+static struct acpi_exdump_info acpi_ex_dump_string[4] = {
+	{ACPI_EXD_INIT, ACPI_EXD_TABLE_SIZE(acpi_ex_dump_string), NULL},
+	{ACPI_EXD_UINT32, ACPI_EXD_OFFSET(string.length), "Length"},
+	{ACPI_EXD_POINTER, ACPI_EXD_OFFSET(string.pointer), "Pointer"},
+	{ACPI_EXD_STRING, 0, NULL}
+};
+
+static struct acpi_exdump_info acpi_ex_dump_buffer[5] = {
+	{ACPI_EXD_INIT, ACPI_EXD_TABLE_SIZE(acpi_ex_dump_buffer), NULL},
+	{ACPI_EXD_UINT32, ACPI_EXD_OFFSET(buffer.length), "Length"},
+	{ACPI_EXD_POINTER, ACPI_EXD_OFFSET(buffer.pointer), "Pointer"},
+	{ACPI_EXD_POINTER, ACPI_EXD_OFFSET(buffer.node), "Parent Node"},
+	{ACPI_EXD_BUFFER, 0, NULL}
+};
+
+static struct acpi_exdump_info acpi_ex_dump_package[5] = {
+	{ACPI_EXD_INIT, ACPI_EXD_TABLE_SIZE(acpi_ex_dump_package), NULL},
+	{ACPI_EXD_UINT8, ACPI_EXD_OFFSET(package.flags), "Flags"},
+	{ACPI_EXD_UINT32, ACPI_EXD_OFFSET(package.count), "Elements"},
+	{ACPI_EXD_POINTER, ACPI_EXD_OFFSET(package.elements), "Element List"},
+	{ACPI_EXD_PACKAGE, 0, NULL}
+};
+
+static struct acpi_exdump_info acpi_ex_dump_device[4] = {
+	{ACPI_EXD_INIT, ACPI_EXD_TABLE_SIZE(acpi_ex_dump_device), NULL},
+	{ACPI_EXD_POINTER, ACPI_EXD_OFFSET(device.handler), "Handler"},
+	{ACPI_EXD_POINTER, ACPI_EXD_OFFSET(device.system_notify),
+	 "System Notify"},
+	{ACPI_EXD_POINTER, ACPI_EXD_OFFSET(device.device_notify),
+	 "Device Notify"}
+};
+
+static struct acpi_exdump_info acpi_ex_dump_event[2] = {
+	{ACPI_EXD_INIT, ACPI_EXD_TABLE_SIZE(acpi_ex_dump_event), NULL},
+	{ACPI_EXD_POINTER, ACPI_EXD_OFFSET(event.os_semaphore), "OsSemaphore"}
+};
+
+static struct acpi_exdump_info acpi_ex_dump_method[9] = {
+	{ACPI_EXD_INIT, ACPI_EXD_TABLE_SIZE(acpi_ex_dump_method), NULL},
+	{ACPI_EXD_UINT8, ACPI_EXD_OFFSET(method.info_flags), "Info Flags"},
+	{ACPI_EXD_UINT8, ACPI_EXD_OFFSET(method.param_count),
+	 "Parameter Count"},
+	{ACPI_EXD_UINT8, ACPI_EXD_OFFSET(method.sync_level), "Sync Level"},
+	{ACPI_EXD_POINTER, ACPI_EXD_OFFSET(method.mutex), "Mutex"},
+	{ACPI_EXD_UINT8, ACPI_EXD_OFFSET(method.owner_id), "Owner Id"},
+	{ACPI_EXD_UINT8, ACPI_EXD_OFFSET(method.thread_count), "Thread Count"},
+	{ACPI_EXD_UINT32, ACPI_EXD_OFFSET(method.aml_length), "Aml Length"},
+	{ACPI_EXD_POINTER, ACPI_EXD_OFFSET(method.aml_start), "Aml Start"}
+};
+
+static struct acpi_exdump_info acpi_ex_dump_mutex[5] = {
+	{ACPI_EXD_INIT, ACPI_EXD_TABLE_SIZE(acpi_ex_dump_mutex), NULL},
+	{ACPI_EXD_UINT8, ACPI_EXD_OFFSET(mutex.sync_level), "Sync Level"},
+	{ACPI_EXD_POINTER, ACPI_EXD_OFFSET(mutex.owner_thread), "Owner Thread"},
+	{ACPI_EXD_UINT16, ACPI_EXD_OFFSET(mutex.acquisition_depth),
+	 "Acquire Depth"},
+	{ACPI_EXD_POINTER, ACPI_EXD_OFFSET(mutex.os_mutex), "OsMutex"}
+};
+
+static struct acpi_exdump_info acpi_ex_dump_region[7] = {
+	{ACPI_EXD_INIT, ACPI_EXD_TABLE_SIZE(acpi_ex_dump_region), NULL},
+	{ACPI_EXD_UINT8, ACPI_EXD_OFFSET(region.space_id), "Space Id"},
+	{ACPI_EXD_UINT8, ACPI_EXD_OFFSET(region.flags), "Flags"},
+	{ACPI_EXD_ADDRESS, ACPI_EXD_OFFSET(region.address), "Address"},
+	{ACPI_EXD_UINT32, ACPI_EXD_OFFSET(region.length), "Length"},
+	{ACPI_EXD_POINTER, ACPI_EXD_OFFSET(region.handler), "Handler"},
+	{ACPI_EXD_POINTER, ACPI_EXD_OFFSET(region.next), "Next"}
+};
+
+static struct acpi_exdump_info acpi_ex_dump_power[5] = {
+	{ACPI_EXD_INIT, ACPI_EXD_TABLE_SIZE(acpi_ex_dump_power), NULL},
+	{ACPI_EXD_UINT32, ACPI_EXD_OFFSET(power_resource.system_level),
+	 "System Level"},
+	{ACPI_EXD_UINT32, ACPI_EXD_OFFSET(power_resource.resource_order),
+	 "Resource Order"},
+	{ACPI_EXD_POINTER, ACPI_EXD_OFFSET(power_resource.system_notify),
+	 "System Notify"},
+	{ACPI_EXD_POINTER, ACPI_EXD_OFFSET(power_resource.device_notify),
+	 "Device Notify"}
+};
+
+static struct acpi_exdump_info acpi_ex_dump_processor[7] = {
+	{ACPI_EXD_INIT, ACPI_EXD_TABLE_SIZE(acpi_ex_dump_processor), NULL},
+	{ACPI_EXD_UINT8, ACPI_EXD_OFFSET(processor.proc_id), "Processor ID"},
+	{ACPI_EXD_UINT8, ACPI_EXD_OFFSET(processor.length), "Length"},
+	{ACPI_EXD_ADDRESS, ACPI_EXD_OFFSET(processor.address), "Address"},
+	{ACPI_EXD_POINTER, ACPI_EXD_OFFSET(processor.system_notify),
+	 "System Notify"},
+	{ACPI_EXD_POINTER, ACPI_EXD_OFFSET(processor.device_notify),
+	 "Device Notify"},
+	{ACPI_EXD_POINTER, ACPI_EXD_OFFSET(processor.handler), "Handler"}
+};
+
+static struct acpi_exdump_info acpi_ex_dump_thermal[4] = {
+	{ACPI_EXD_INIT, ACPI_EXD_TABLE_SIZE(acpi_ex_dump_thermal), NULL},
+	{ACPI_EXD_POINTER, ACPI_EXD_OFFSET(thermal_zone.system_notify),
+	 "System Notify"},
+	{ACPI_EXD_POINTER, ACPI_EXD_OFFSET(thermal_zone.device_notify),
+	 "Device Notify"},
+	{ACPI_EXD_POINTER, ACPI_EXD_OFFSET(thermal_zone.handler), "Handler"}
+};
+
+static struct acpi_exdump_info acpi_ex_dump_buffer_field[3] = {
+	{ACPI_EXD_INIT, ACPI_EXD_TABLE_SIZE(acpi_ex_dump_buffer_field), NULL},
+	{ACPI_EXD_FIELD, 0, NULL},
+	{ACPI_EXD_POINTER, ACPI_EXD_OFFSET(buffer_field.buffer_obj),
+	 "Buffer Object"}
+};
+
+static struct acpi_exdump_info acpi_ex_dump_region_field[5] = {
+	{ACPI_EXD_INIT, ACPI_EXD_TABLE_SIZE(acpi_ex_dump_region_field), NULL},
+	{ACPI_EXD_FIELD, 0, NULL},
+	{ACPI_EXD_UINT8, ACPI_EXD_OFFSET(field.access_length), "AccessLength"},
+	{ACPI_EXD_POINTER, ACPI_EXD_OFFSET(field.region_obj), "Region Object"},
+	{ACPI_EXD_POINTER, ACPI_EXD_OFFSET(field.resource_buffer),
+	 "ResourceBuffer"}
+};
+
+static struct acpi_exdump_info acpi_ex_dump_bank_field[5] = {
+	{ACPI_EXD_INIT, ACPI_EXD_TABLE_SIZE(acpi_ex_dump_bank_field), NULL},
+	{ACPI_EXD_FIELD, 0, NULL},
+	{ACPI_EXD_UINT32, ACPI_EXD_OFFSET(bank_field.value), "Value"},
+	{ACPI_EXD_POINTER, ACPI_EXD_OFFSET(bank_field.region_obj),
+	 "Region Object"},
+	{ACPI_EXD_POINTER, ACPI_EXD_OFFSET(bank_field.bank_obj), "Bank Object"}
+};
+
+static struct acpi_exdump_info acpi_ex_dump_index_field[5] = {
+	{ACPI_EXD_INIT, ACPI_EXD_TABLE_SIZE(acpi_ex_dump_bank_field), NULL},
+	{ACPI_EXD_FIELD, 0, NULL},
+	{ACPI_EXD_UINT32, ACPI_EXD_OFFSET(index_field.value), "Value"},
+	{ACPI_EXD_POINTER, ACPI_EXD_OFFSET(index_field.index_obj),
+	 "Index Object"},
+	{ACPI_EXD_POINTER, ACPI_EXD_OFFSET(index_field.data_obj), "Data Object"}
+};
+
+static struct acpi_exdump_info acpi_ex_dump_reference[8] = {
+	{ACPI_EXD_INIT, ACPI_EXD_TABLE_SIZE(acpi_ex_dump_reference), NULL},
+	{ACPI_EXD_UINT8, ACPI_EXD_OFFSET(reference.class), "Class"},
+	{ACPI_EXD_UINT8, ACPI_EXD_OFFSET(reference.target_type), "Target Type"},
+	{ACPI_EXD_UINT32, ACPI_EXD_OFFSET(reference.value), "Value"},
+	{ACPI_EXD_POINTER, ACPI_EXD_OFFSET(reference.object), "Object Desc"},
+	{ACPI_EXD_POINTER, ACPI_EXD_OFFSET(reference.node), "Node"},
+	{ACPI_EXD_POINTER, ACPI_EXD_OFFSET(reference.where), "Where"},
+	{ACPI_EXD_REFERENCE, 0, NULL}
+};
+
+static struct acpi_exdump_info acpi_ex_dump_address_handler[6] = {
+	{ACPI_EXD_INIT, ACPI_EXD_TABLE_SIZE(acpi_ex_dump_address_handler),
+	 NULL},
+	{ACPI_EXD_UINT8, ACPI_EXD_OFFSET(address_space.space_id), "Space Id"},
+	{ACPI_EXD_POINTER, ACPI_EXD_OFFSET(address_space.next), "Next"},
+	{ACPI_EXD_POINTER, ACPI_EXD_OFFSET(address_space.region_list),
+	 "Region List"},
+	{ACPI_EXD_POINTER, ACPI_EXD_OFFSET(address_space.node), "Node"},
+	{ACPI_EXD_POINTER, ACPI_EXD_OFFSET(address_space.context), "Context"}
+};
+
+static struct acpi_exdump_info acpi_ex_dump_notify[3] = {
+	{ACPI_EXD_INIT, ACPI_EXD_TABLE_SIZE(acpi_ex_dump_notify), NULL},
+	{ACPI_EXD_POINTER, ACPI_EXD_OFFSET(notify.node), "Node"},
+	{ACPI_EXD_POINTER, ACPI_EXD_OFFSET(notify.context), "Context"}
+};
+
+/* Miscellaneous tables */
+
+static struct acpi_exdump_info acpi_ex_dump_common[4] = {
+	{ACPI_EXD_INIT, ACPI_EXD_TABLE_SIZE(acpi_ex_dump_common), NULL},
+	{ACPI_EXD_TYPE, 0, NULL},
+	{ACPI_EXD_UINT16, ACPI_EXD_OFFSET(common.reference_count),
+	 "Reference Count"},
+	{ACPI_EXD_UINT8, ACPI_EXD_OFFSET(common.flags), "Flags"}
+};
+
+static struct acpi_exdump_info acpi_ex_dump_field_common[7] = {
+	{ACPI_EXD_INIT, ACPI_EXD_TABLE_SIZE(acpi_ex_dump_field_common), NULL},
+	{ACPI_EXD_UINT8, ACPI_EXD_OFFSET(common_field.field_flags),
+	 "Field Flags"},
+	{ACPI_EXD_UINT8, ACPI_EXD_OFFSET(common_field.access_byte_width),
+	 "Access Byte Width"},
+	{ACPI_EXD_UINT32, ACPI_EXD_OFFSET(common_field.bit_length),
+	 "Bit Length"},
+	{ACPI_EXD_UINT8, ACPI_EXD_OFFSET(common_field.start_field_bit_offset),
+	 "Field Bit Offset"},
+	{ACPI_EXD_UINT32, ACPI_EXD_OFFSET(common_field.base_byte_offset),
+	 "Base Byte Offset"},
+	{ACPI_EXD_POINTER, ACPI_EXD_OFFSET(common_field.node), "Parent Node"}
+};
+
+static struct acpi_exdump_info acpi_ex_dump_node[5] = {
+	{ACPI_EXD_INIT, ACPI_EXD_TABLE_SIZE(acpi_ex_dump_node), NULL},
+	{ACPI_EXD_UINT8, ACPI_EXD_NSOFFSET(flags), "Flags"},
+	{ACPI_EXD_UINT8, ACPI_EXD_NSOFFSET(owner_id), "Owner Id"},
+	{ACPI_EXD_POINTER, ACPI_EXD_NSOFFSET(child), "Child List"},
+	{ACPI_EXD_POINTER, ACPI_EXD_NSOFFSET(peer), "Next Peer"}
+};
+
+/* Dispatch table, indexed by object type */
+
+static struct acpi_exdump_info *acpi_ex_dump_info[] = {
+	NULL,
+	acpi_ex_dump_integer,
+	acpi_ex_dump_string,
+	acpi_ex_dump_buffer,
+	acpi_ex_dump_package,
+	NULL,
+	acpi_ex_dump_device,
+	acpi_ex_dump_event,
+	acpi_ex_dump_method,
+	acpi_ex_dump_mutex,
+	acpi_ex_dump_region,
+	acpi_ex_dump_power,
+	acpi_ex_dump_processor,
+	acpi_ex_dump_thermal,
+	acpi_ex_dump_buffer_field,
+	NULL,
+	NULL,
+	acpi_ex_dump_region_field,
+	acpi_ex_dump_bank_field,
+	acpi_ex_dump_index_field,
+	acpi_ex_dump_reference,
+	NULL,
+	NULL,
+	acpi_ex_dump_notify,
+	acpi_ex_dump_address_handler,
+	NULL,
+	NULL,
+	NULL
+};
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_dump_object
+ *
+ * PARAMETERS:  obj_desc            - Descriptor to dump
+ *              Info                - Info table corresponding to this object
+ *                                    type
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Walk the info table for this object
+ *
+ ******************************************************************************/
+
+static void
+acpi_ex_dump_object(union acpi_operand_object *obj_desc,
+		    struct acpi_exdump_info *info)
+{
+	u8 *target;
+	char *name;
+	u8 count;
+
+	if (!info) {
+		acpi_os_printf
+		    ("ExDumpObject: Display not implemented for object type %s\n",
+		     acpi_ut_get_object_type_name(obj_desc));
+		return;
+	}
+
+	/* First table entry must contain the table length (# of table entries) */
+
+	count = info->offset;
+
+	while (count) {
+		target = ACPI_ADD_PTR(u8, obj_desc, info->offset);
+		name = info->name;
+
+		switch (info->opcode) {
+		case ACPI_EXD_INIT:
+			break;
+
+		case ACPI_EXD_TYPE:
+
+			acpi_ex_out_string("Type",
+					   acpi_ut_get_object_type_name
+					   (obj_desc));
+			break;
+
+		case ACPI_EXD_UINT8:
+
+			acpi_os_printf("%20s : %2.2X\n", name, *target);
+			break;
+
+		case ACPI_EXD_UINT16:
+
+			acpi_os_printf("%20s : %4.4X\n", name,
+				       ACPI_GET16(target));
+			break;
+
+		case ACPI_EXD_UINT32:
+
+			acpi_os_printf("%20s : %8.8X\n", name,
+				       ACPI_GET32(target));
+			break;
+
+		case ACPI_EXD_UINT64:
+
+			acpi_os_printf("%20s : %8.8X%8.8X\n", "Value",
+				       ACPI_FORMAT_UINT64(ACPI_GET64(target)));
+			break;
+
+		case ACPI_EXD_POINTER:
+		case ACPI_EXD_ADDRESS:
+
+			acpi_ex_out_pointer(name,
+					    *ACPI_CAST_PTR(void *, target));
+			break;
+
+		case ACPI_EXD_STRING:
+
+			acpi_ut_print_string(obj_desc->string.pointer,
+					     ACPI_UINT8_MAX);
+			acpi_os_printf("\n");
+			break;
+
+		case ACPI_EXD_BUFFER:
+
+			ACPI_DUMP_BUFFER(obj_desc->buffer.pointer,
+					 obj_desc->buffer.length);
+			break;
+
+		case ACPI_EXD_PACKAGE:
+
+			/* Dump the package contents */
+
+			acpi_os_printf("\nPackage Contents:\n");
+			acpi_ex_dump_package_obj(obj_desc, 0, 0);
+			break;
+
+		case ACPI_EXD_FIELD:
+
+			acpi_ex_dump_object(obj_desc,
+					    acpi_ex_dump_field_common);
+			break;
+
+		case ACPI_EXD_REFERENCE:
+
+			acpi_ex_out_string("Class Name",
+					   ACPI_CAST_PTR(char,
+							 acpi_ut_get_reference_name
+							 (obj_desc)));
+			acpi_ex_dump_reference_obj(obj_desc);
+			break;
+
+		default:
+
+			acpi_os_printf("**** Invalid table opcode [%X] ****\n",
+				       info->opcode);
+			return;
+		}
+
+		info++;
+		count--;
+	}
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_dump_operand
+ *
+ * PARAMETERS:  *obj_desc       - Pointer to entry to be dumped
+ *              Depth           - Current nesting depth
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Dump an operand object
+ *
+ ******************************************************************************/
+
+void acpi_ex_dump_operand(union acpi_operand_object *obj_desc, u32 depth)
+{
+	u32 length;
+	u32 index;
+
+	ACPI_FUNCTION_NAME(ex_dump_operand)
+
+	    if (!
+		((ACPI_LV_EXEC & acpi_dbg_level)
+		 && (_COMPONENT & acpi_dbg_layer))) {
+		return;
+	}
+
+	if (!obj_desc) {
+
+		/* This could be a null element of a package */
+
+		ACPI_DEBUG_PRINT((ACPI_DB_EXEC, "Null Object Descriptor\n"));
+		return;
+	}
+
+	if (ACPI_GET_DESCRIPTOR_TYPE(obj_desc) == ACPI_DESC_TYPE_NAMED) {
+		ACPI_DEBUG_PRINT((ACPI_DB_EXEC, "%p Namespace Node: ",
+				  obj_desc));
+		ACPI_DUMP_ENTRY(obj_desc, ACPI_LV_EXEC);
+		return;
+	}
+
+	if (ACPI_GET_DESCRIPTOR_TYPE(obj_desc) != ACPI_DESC_TYPE_OPERAND) {
+		ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
+				  "%p is not a node or operand object: [%s]\n",
+				  obj_desc,
+				  acpi_ut_get_descriptor_name(obj_desc)));
+		ACPI_DUMP_BUFFER(obj_desc, sizeof(union acpi_operand_object));
+		return;
+	}
+
+	/* obj_desc is a valid object */
+
+	if (depth > 0) {
+		ACPI_DEBUG_PRINT((ACPI_DB_EXEC, "%*s[%u] %p ",
+				  depth, " ", depth, obj_desc));
+	} else {
+		ACPI_DEBUG_PRINT((ACPI_DB_EXEC, "%p ", obj_desc));
+	}
+
+	/* Decode object type */
+
+	switch (obj_desc->common.type) {
+	case ACPI_TYPE_LOCAL_REFERENCE:
+
+		acpi_os_printf("Reference: [%s] ",
+			       acpi_ut_get_reference_name(obj_desc));
+
+		switch (obj_desc->reference.class) {
+		case ACPI_REFCLASS_DEBUG:
+
+			acpi_os_printf("\n");
+			break;
+
+		case ACPI_REFCLASS_INDEX:
+
+			acpi_os_printf("%p\n", obj_desc->reference.object);
+			break;
+
+		case ACPI_REFCLASS_TABLE:
+
+			acpi_os_printf("Table Index %X\n",
+				       obj_desc->reference.value);
+			break;
+
+		case ACPI_REFCLASS_REFOF:
+
+			acpi_os_printf("%p [%s]\n", obj_desc->reference.object,
+				       acpi_ut_get_type_name(((union
+							       acpi_operand_object
+							       *)
+							      obj_desc->
+							      reference.
+							      object)->common.
+							     type));
+			break;
+
+		case ACPI_REFCLASS_NAME:
+
+			acpi_os_printf("- [%4.4s]\n",
+				       obj_desc->reference.node->name.ascii);
+			break;
+
+		case ACPI_REFCLASS_ARG:
+		case ACPI_REFCLASS_LOCAL:
+
+			acpi_os_printf("%X\n", obj_desc->reference.value);
+			break;
+
+		default:	/* Unknown reference class */
+
+			acpi_os_printf("%2.2X\n", obj_desc->reference.class);
+			break;
+		}
+		break;
+
+	case ACPI_TYPE_BUFFER:
+
+		acpi_os_printf("Buffer length %.2X @ %p\n",
+			       obj_desc->buffer.length,
+			       obj_desc->buffer.pointer);
+
+		/* Debug only -- dump the buffer contents */
+
+		if (obj_desc->buffer.pointer) {
+			length = obj_desc->buffer.length;
+			if (length > 128) {
+				length = 128;
+			}
+
+			acpi_os_printf
+			    ("Buffer Contents: (displaying length 0x%.2X)\n",
+			     length);
+			ACPI_DUMP_BUFFER(obj_desc->buffer.pointer, length);
+		}
+		break;
+
+	case ACPI_TYPE_INTEGER:
+
+		acpi_os_printf("Integer %8.8X%8.8X\n",
+			       ACPI_FORMAT_UINT64(obj_desc->integer.value));
+		break;
+
+	case ACPI_TYPE_PACKAGE:
+
+		acpi_os_printf("Package [Len %X] ElementArray %p\n",
+			       obj_desc->package.count,
+			       obj_desc->package.elements);
+
+		/*
+		 * If elements exist, package element pointer is valid,
+		 * and debug_level exceeds 1, dump package's elements.
+		 */
+		if (obj_desc->package.count &&
+		    obj_desc->package.elements && acpi_dbg_level > 1) {
+			for (index = 0; index < obj_desc->package.count;
+			     index++) {
+				acpi_ex_dump_operand(obj_desc->package.
+						     elements[index],
+						     depth + 1);
+			}
+		}
+		break;
+
+	case ACPI_TYPE_REGION:
+
+		acpi_os_printf("Region %s (%X)",
+			       acpi_ut_get_region_name(obj_desc->region.
+						       space_id),
+			       obj_desc->region.space_id);
+
+		/*
+		 * If the address and length have not been evaluated,
+		 * don't print them.
+		 */
+		if (!(obj_desc->region.flags & AOPOBJ_DATA_VALID)) {
+			acpi_os_printf("\n");
+		} else {
+			acpi_os_printf(" base %8.8X%8.8X Length %X\n",
+				       ACPI_FORMAT_NATIVE_UINT(obj_desc->region.
+							       address),
+				       obj_desc->region.length);
+		}
+		break;
+
+	case ACPI_TYPE_STRING:
+
+		acpi_os_printf("String length %X @ %p ",
+			       obj_desc->string.length,
+			       obj_desc->string.pointer);
+
+		acpi_ut_print_string(obj_desc->string.pointer, ACPI_UINT8_MAX);
+		acpi_os_printf("\n");
+		break;
+
+	case ACPI_TYPE_LOCAL_BANK_FIELD:
+
+		acpi_os_printf("BankField\n");
+		break;
+
+	case ACPI_TYPE_LOCAL_REGION_FIELD:
+
+		acpi_os_printf
+		    ("RegionField: Bits=%X AccWidth=%X Lock=%X Update=%X at "
+		     "byte=%X bit=%X of below:\n", obj_desc->field.bit_length,
+		     obj_desc->field.access_byte_width,
+		     obj_desc->field.field_flags & AML_FIELD_LOCK_RULE_MASK,
+		     obj_desc->field.field_flags & AML_FIELD_UPDATE_RULE_MASK,
+		     obj_desc->field.base_byte_offset,
+		     obj_desc->field.start_field_bit_offset);
+
+		acpi_ex_dump_operand(obj_desc->field.region_obj, depth + 1);
+		break;
+
+	case ACPI_TYPE_LOCAL_INDEX_FIELD:
+
+		acpi_os_printf("IndexField\n");
+		break;
+
+	case ACPI_TYPE_BUFFER_FIELD:
+
+		acpi_os_printf("BufferField: %X bits at byte %X bit %X of\n",
+			       obj_desc->buffer_field.bit_length,
+			       obj_desc->buffer_field.base_byte_offset,
+			       obj_desc->buffer_field.start_field_bit_offset);
+
+		if (!obj_desc->buffer_field.buffer_obj) {
+			ACPI_DEBUG_PRINT((ACPI_DB_EXEC, "*NULL*\n"));
+		} else if ((obj_desc->buffer_field.buffer_obj)->common.type !=
+			   ACPI_TYPE_BUFFER) {
+			acpi_os_printf("*not a Buffer*\n");
+		} else {
+			acpi_ex_dump_operand(obj_desc->buffer_field.buffer_obj,
+					     depth + 1);
+		}
+		break;
+
+	case ACPI_TYPE_EVENT:
+
+		acpi_os_printf("Event\n");
+		break;
+
+	case ACPI_TYPE_METHOD:
+
+		acpi_os_printf("Method(%X) @ %p:%X\n",
+			       obj_desc->method.param_count,
+			       obj_desc->method.aml_start,
+			       obj_desc->method.aml_length);
+		break;
+
+	case ACPI_TYPE_MUTEX:
+
+		acpi_os_printf("Mutex\n");
+		break;
+
+	case ACPI_TYPE_DEVICE:
+
+		acpi_os_printf("Device\n");
+		break;
+
+	case ACPI_TYPE_POWER:
+
+		acpi_os_printf("Power\n");
+		break;
+
+	case ACPI_TYPE_PROCESSOR:
+
+		acpi_os_printf("Processor\n");
+		break;
+
+	case ACPI_TYPE_THERMAL:
+
+		acpi_os_printf("Thermal\n");
+		break;
+
+	default:
+		/* Unknown Type */
+
+		acpi_os_printf("Unknown Type %X\n", obj_desc->common.type);
+		break;
+	}
+
+	return;
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_dump_operands
+ *
+ * PARAMETERS:  Operands            - A list of Operand objects
+ *              opcode_name         - AML opcode name
+ *              num_operands        - Operand count for this opcode
+ *
+ * DESCRIPTION: Dump the operands associated with the opcode
+ *
+ ******************************************************************************/
+
+void
+acpi_ex_dump_operands(union acpi_operand_object **operands,
+		      const char *opcode_name, u32 num_operands)
+{
+	ACPI_FUNCTION_NAME(ex_dump_operands);
+
+	if (!opcode_name) {
+		opcode_name = "UNKNOWN";
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
+			  "**** Start operand dump for opcode [%s], %u operands\n",
+			  opcode_name, num_operands));
+
+	if (num_operands == 0) {
+		num_operands = 1;
+	}
+
+	/* Dump the individual operands */
+
+	while (num_operands) {
+		acpi_ex_dump_operand(*operands, 0);
+		operands++;
+		num_operands--;
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
+			  "**** End operand dump for [%s]\n", opcode_name));
+	return;
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_out* functions
+ *
+ * PARAMETERS:  Title               - Descriptive text
+ *              Value               - Value to be displayed
+ *
+ * DESCRIPTION: Object dump output formatting functions.  These functions
+ *              reduce the number of format strings required and keeps them
+ *              all in one place for easy modification.
+ *
+ ******************************************************************************/
+
+static void acpi_ex_out_string(char *title, char *value)
+{
+	acpi_os_printf("%20s : %s\n", title, value);
+}
+
+static void acpi_ex_out_pointer(char *title, void *value)
+{
+	acpi_os_printf("%20s : %p\n", title, value);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_dump_namespace_node
+ *
+ * PARAMETERS:  Node                - Descriptor to dump
+ *              Flags               - Force display if TRUE
+ *
+ * DESCRIPTION: Dumps the members of the given.Node
+ *
+ ******************************************************************************/
+
+void acpi_ex_dump_namespace_node(struct acpi_namespace_node *node, u32 flags)
+{
+
+	ACPI_FUNCTION_ENTRY();
+
+	if (!flags) {
+		if (!
+		    ((ACPI_LV_OBJECTS & acpi_dbg_level)
+		     && (_COMPONENT & acpi_dbg_layer))) {
+			return;
+		}
+	}
+
+	acpi_os_printf("%20s : %4.4s\n", "Name", acpi_ut_get_node_name(node));
+	acpi_ex_out_string("Type", acpi_ut_get_type_name(node->type));
+	acpi_ex_out_pointer("Attached Object",
+			    acpi_ns_get_attached_object(node));
+	acpi_ex_out_pointer("Parent", node->parent);
+
+	acpi_ex_dump_object(ACPI_CAST_PTR(union acpi_operand_object, node),
+			    acpi_ex_dump_node);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_dump_reference_obj
+ *
+ * PARAMETERS:  Object              - Descriptor to dump
+ *
+ * DESCRIPTION: Dumps a reference object
+ *
+ ******************************************************************************/
+
+static void acpi_ex_dump_reference_obj(union acpi_operand_object *obj_desc)
+{
+	struct acpi_buffer ret_buf;
+	acpi_status status;
+
+	ret_buf.length = ACPI_ALLOCATE_LOCAL_BUFFER;
+
+	if (obj_desc->reference.class == ACPI_REFCLASS_NAME) {
+		acpi_os_printf(" %p ", obj_desc->reference.node);
+
+		status =
+		    acpi_ns_handle_to_pathname(obj_desc->reference.node,
+					       &ret_buf);
+		if (ACPI_FAILURE(status)) {
+			acpi_os_printf(" Could not convert name to pathname\n");
+		} else {
+			acpi_os_printf("%s\n", (char *)ret_buf.pointer);
+			ACPI_FREE(ret_buf.pointer);
+		}
+	} else if (obj_desc->reference.object) {
+		if (ACPI_GET_DESCRIPTOR_TYPE(obj_desc) ==
+		    ACPI_DESC_TYPE_OPERAND) {
+			acpi_os_printf(" Target: %p",
+				       obj_desc->reference.object);
+			if (obj_desc->reference.class == ACPI_REFCLASS_TABLE) {
+				acpi_os_printf(" Table Index: %X\n",
+					       obj_desc->reference.value);
+			} else {
+				acpi_os_printf(" Target: %p [%s]\n",
+					       obj_desc->reference.object,
+					       acpi_ut_get_type_name(((union
+								       acpi_operand_object
+								       *)
+								      obj_desc->
+								      reference.
+								      object)->
+								     common.
+								     type));
+			}
+		} else {
+			acpi_os_printf(" Target: %p\n",
+				       obj_desc->reference.object);
+		}
+	}
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_dump_package_obj
+ *
+ * PARAMETERS:  obj_desc            - Descriptor to dump
+ *              Level               - Indentation Level
+ *              Index               - Package index for this object
+ *
+ * DESCRIPTION: Dumps the elements of the package
+ *
+ ******************************************************************************/
+
+static void
+acpi_ex_dump_package_obj(union acpi_operand_object *obj_desc,
+			 u32 level, u32 index)
+{
+	u32 i;
+
+	/* Indentation and index output */
+
+	if (level > 0) {
+		for (i = 0; i < level; i++) {
+			acpi_os_printf(" ");
+		}
+
+		acpi_os_printf("[%.2d] ", index);
+	}
+
+	acpi_os_printf("%p ", obj_desc);
+
+	/* Null package elements are allowed */
+
+	if (!obj_desc) {
+		acpi_os_printf("[Null Object]\n");
+		return;
+	}
+
+	/* Packages may only contain a few object types */
+
+	switch (obj_desc->common.type) {
+	case ACPI_TYPE_INTEGER:
+
+		acpi_os_printf("[Integer] = %8.8X%8.8X\n",
+			       ACPI_FORMAT_UINT64(obj_desc->integer.value));
+		break;
+
+	case ACPI_TYPE_STRING:
+
+		acpi_os_printf("[String] Value: ");
+		for (i = 0; i < obj_desc->string.length; i++) {
+			acpi_os_printf("%c", obj_desc->string.pointer[i]);
+		}
+		acpi_os_printf("\n");
+		break;
+
+	case ACPI_TYPE_BUFFER:
+
+		acpi_os_printf("[Buffer] Length %.2X = ",
+			       obj_desc->buffer.length);
+		if (obj_desc->buffer.length) {
+			acpi_ut_dump_buffer(ACPI_CAST_PTR
+					    (u8, obj_desc->buffer.pointer),
+					    obj_desc->buffer.length,
+					    DB_DWORD_DISPLAY, _COMPONENT);
+		} else {
+			acpi_os_printf("\n");
+		}
+		break;
+
+	case ACPI_TYPE_PACKAGE:
+
+		acpi_os_printf("[Package] Contains %u Elements:\n",
+			       obj_desc->package.count);
+
+		for (i = 0; i < obj_desc->package.count; i++) {
+			acpi_ex_dump_package_obj(obj_desc->package.elements[i],
+						 level + 1, i);
+		}
+		break;
+
+	case ACPI_TYPE_LOCAL_REFERENCE:
+
+		acpi_os_printf("[Object Reference] Type [%s] %2.2X",
+			       acpi_ut_get_reference_name(obj_desc),
+			       obj_desc->reference.class);
+		acpi_ex_dump_reference_obj(obj_desc);
+		break;
+
+	default:
+
+		acpi_os_printf("[Unknown Type] %X\n", obj_desc->common.type);
+		break;
+	}
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_dump_object_descriptor
+ *
+ * PARAMETERS:  obj_desc            - Descriptor to dump
+ *              Flags               - Force display if TRUE
+ *
+ * DESCRIPTION: Dumps the members of the object descriptor given.
+ *
+ ******************************************************************************/
+
+void
+acpi_ex_dump_object_descriptor(union acpi_operand_object *obj_desc, u32 flags)
+{
+	ACPI_FUNCTION_TRACE(ex_dump_object_descriptor);
+
+	if (!obj_desc) {
+		return_VOID;
+	}
+
+	if (!flags) {
+		if (!
+		    ((ACPI_LV_OBJECTS & acpi_dbg_level)
+		     && (_COMPONENT & acpi_dbg_layer))) {
+			return_VOID;
+		}
+	}
+
+	if (ACPI_GET_DESCRIPTOR_TYPE(obj_desc) == ACPI_DESC_TYPE_NAMED) {
+		acpi_ex_dump_namespace_node((struct acpi_namespace_node *)
+					    obj_desc, flags);
+
+		acpi_os_printf("\nAttached Object (%p):\n",
+			       ((struct acpi_namespace_node *)obj_desc)->
+			       object);
+
+		acpi_ex_dump_object_descriptor(((struct acpi_namespace_node *)
+						obj_desc)->object, flags);
+		return_VOID;
+	}
+
+	if (ACPI_GET_DESCRIPTOR_TYPE(obj_desc) != ACPI_DESC_TYPE_OPERAND) {
+		acpi_os_printf
+		    ("ExDumpObjectDescriptor: %p is not an ACPI operand object: [%s]\n",
+		     obj_desc, acpi_ut_get_descriptor_name(obj_desc));
+		return_VOID;
+	}
+
+	if (obj_desc->common.type > ACPI_TYPE_NS_NODE_MAX) {
+		return_VOID;
+	}
+
+	/* Common Fields */
+
+	acpi_ex_dump_object(obj_desc, acpi_ex_dump_common);
+
+	/* Object-specific fields */
+
+	acpi_ex_dump_object(obj_desc, acpi_ex_dump_info[obj_desc->common.type]);
+	return_VOID;
+}
+
+#endif
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exfield.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exfield.c
new file mode 100644
index 00000000..198a3271
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exfield.c
@@ -0,0 +1,377 @@
+/******************************************************************************
+ *
+ * Module Name: exfield - ACPI AML (p-code) execution - field manipulation
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acdispat.h"
+#include "acinterp.h"
+
+#define _COMPONENT          ACPI_EXECUTER
+ACPI_MODULE_NAME("exfield")
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_read_data_from_field
+ *
+ * PARAMETERS:  walk_state          - Current execution state
+ *              obj_desc            - The named field
+ *              ret_buffer_desc     - Where the return data object is stored
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Read from a named field.  Returns either an Integer or a
+ *              Buffer, depending on the size of the field.
+ *
+ ******************************************************************************/
+acpi_status
+acpi_ex_read_data_from_field(struct acpi_walk_state *walk_state,
+			     union acpi_operand_object *obj_desc,
+			     union acpi_operand_object **ret_buffer_desc)
+{
+	acpi_status status;
+	union acpi_operand_object *buffer_desc;
+	acpi_size length;
+	void *buffer;
+	u32 function;
+
+	ACPI_FUNCTION_TRACE_PTR(ex_read_data_from_field, obj_desc);
+
+	/* Parameter validation */
+
+	if (!obj_desc) {
+		return_ACPI_STATUS(AE_AML_NO_OPERAND);
+	}
+	if (!ret_buffer_desc) {
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	if (obj_desc->common.type == ACPI_TYPE_BUFFER_FIELD) {
+		/*
+		 * If the buffer_field arguments have not been previously evaluated,
+		 * evaluate them now and save the results.
+		 */
+		if (!(obj_desc->common.flags & AOPOBJ_DATA_VALID)) {
+			status = acpi_ds_get_buffer_field_arguments(obj_desc);
+			if (ACPI_FAILURE(status)) {
+				return_ACPI_STATUS(status);
+			}
+		}
+	} else if ((obj_desc->common.type == ACPI_TYPE_LOCAL_REGION_FIELD) &&
+		   (obj_desc->field.region_obj->region.space_id ==
+		    ACPI_ADR_SPACE_SMBUS
+		    || obj_desc->field.region_obj->region.space_id ==
+		    ACPI_ADR_SPACE_GSBUS
+		    || obj_desc->field.region_obj->region.space_id ==
+		    ACPI_ADR_SPACE_IPMI)) {
+		/*
+		 * This is an SMBus, GSBus or IPMI read. We must create a buffer to hold
+		 * the data and then directly access the region handler.
+		 *
+		 * Note: SMBus and GSBus protocol value is passed in upper 16-bits of Function
+		 */
+		if (obj_desc->field.region_obj->region.space_id ==
+		    ACPI_ADR_SPACE_SMBUS) {
+			length = ACPI_SMBUS_BUFFER_SIZE;
+			function =
+			    ACPI_READ | (obj_desc->field.attribute << 16);
+		} else if (obj_desc->field.region_obj->region.space_id ==
+			   ACPI_ADR_SPACE_GSBUS) {
+			length = ACPI_GSBUS_BUFFER_SIZE;
+			function =
+			    ACPI_READ | (obj_desc->field.attribute << 16);
+		} else {	/* IPMI */
+
+			length = ACPI_IPMI_BUFFER_SIZE;
+			function = ACPI_READ;
+		}
+
+		buffer_desc = acpi_ut_create_buffer_object(length);
+		if (!buffer_desc) {
+			return_ACPI_STATUS(AE_NO_MEMORY);
+		}
+
+		/* Lock entire transaction if requested */
+
+		acpi_ex_acquire_global_lock(obj_desc->common_field.field_flags);
+
+		/* Call the region handler for the read */
+
+		status = acpi_ex_access_region(obj_desc, 0,
+					       ACPI_CAST_PTR(u64,
+							     buffer_desc->
+							     buffer.pointer),
+					       function);
+		acpi_ex_release_global_lock(obj_desc->common_field.field_flags);
+		goto exit;
+	}
+
+	/*
+	 * Allocate a buffer for the contents of the field.
+	 *
+	 * If the field is larger than the current integer width, create
+	 * a BUFFER to hold it.  Otherwise, use an INTEGER.  This allows
+	 * the use of arithmetic operators on the returned value if the
+	 * field size is equal or smaller than an Integer.
+	 *
+	 * Note: Field.length is in bits.
+	 */
+	length =
+	    (acpi_size) ACPI_ROUND_BITS_UP_TO_BYTES(obj_desc->field.bit_length);
+	if (length > acpi_gbl_integer_byte_width) {
+
+		/* Field is too large for an Integer, create a Buffer instead */
+
+		buffer_desc = acpi_ut_create_buffer_object(length);
+		if (!buffer_desc) {
+			return_ACPI_STATUS(AE_NO_MEMORY);
+		}
+		buffer = buffer_desc->buffer.pointer;
+	} else {
+		/* Field will fit within an Integer (normal case) */
+
+		buffer_desc = acpi_ut_create_integer_object((u64)0);
+		if (!buffer_desc) {
+			return_ACPI_STATUS(AE_NO_MEMORY);
+		}
+
+		length = acpi_gbl_integer_byte_width;
+		buffer = &buffer_desc->integer.value;
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_BFIELD,
+			  "FieldRead [TO]:   Obj %p, Type %X, Buf %p, ByteLen %X\n",
+			  obj_desc, obj_desc->common.type, buffer,
+			  (u32)length));
+	ACPI_DEBUG_PRINT((ACPI_DB_BFIELD,
+			  "FieldRead [FROM]: BitLen %X, BitOff %X, ByteOff %X\n",
+			  obj_desc->common_field.bit_length,
+			  obj_desc->common_field.start_field_bit_offset,
+			  obj_desc->common_field.base_byte_offset));
+
+	/* Lock entire transaction if requested */
+
+	acpi_ex_acquire_global_lock(obj_desc->common_field.field_flags);
+
+	/* Read from the field */
+
+	status = acpi_ex_extract_from_field(obj_desc, buffer, (u32)length);
+	acpi_ex_release_global_lock(obj_desc->common_field.field_flags);
+
+      exit:
+	if (ACPI_FAILURE(status)) {
+		acpi_ut_remove_reference(buffer_desc);
+	} else {
+		*ret_buffer_desc = buffer_desc;
+	}
+
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_write_data_to_field
+ *
+ * PARAMETERS:  source_desc         - Contains data to write
+ *              obj_desc            - The named field
+ *              result_desc         - Where the return value is returned, if any
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Write to a named field
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ex_write_data_to_field(union acpi_operand_object *source_desc,
+			    union acpi_operand_object *obj_desc,
+			    union acpi_operand_object **result_desc)
+{
+	acpi_status status;
+	u32 length;
+	void *buffer;
+	union acpi_operand_object *buffer_desc;
+	u32 function;
+
+	ACPI_FUNCTION_TRACE_PTR(ex_write_data_to_field, obj_desc);
+
+	/* Parameter validation */
+
+	if (!source_desc || !obj_desc) {
+		return_ACPI_STATUS(AE_AML_NO_OPERAND);
+	}
+
+	if (obj_desc->common.type == ACPI_TYPE_BUFFER_FIELD) {
+		/*
+		 * If the buffer_field arguments have not been previously evaluated,
+		 * evaluate them now and save the results.
+		 */
+		if (!(obj_desc->common.flags & AOPOBJ_DATA_VALID)) {
+			status = acpi_ds_get_buffer_field_arguments(obj_desc);
+			if (ACPI_FAILURE(status)) {
+				return_ACPI_STATUS(status);
+			}
+		}
+	} else if ((obj_desc->common.type == ACPI_TYPE_LOCAL_REGION_FIELD) &&
+		   (obj_desc->field.region_obj->region.space_id ==
+		    ACPI_ADR_SPACE_SMBUS
+		    || obj_desc->field.region_obj->region.space_id ==
+		    ACPI_ADR_SPACE_GSBUS
+		    || obj_desc->field.region_obj->region.space_id ==
+		    ACPI_ADR_SPACE_IPMI)) {
+		/*
+		 * This is an SMBus, GSBus or IPMI write. We will bypass the entire field
+		 * mechanism and handoff the buffer directly to the handler. For
+		 * these address spaces, the buffer is bi-directional; on a write,
+		 * return data is returned in the same buffer.
+		 *
+		 * Source must be a buffer of sufficient size:
+		 * ACPI_SMBUS_BUFFER_SIZE, ACPI_GSBUS_BUFFER_SIZE, or ACPI_IPMI_BUFFER_SIZE.
+		 *
+		 * Note: SMBus and GSBus protocol type is passed in upper 16-bits of Function
+		 */
+		if (source_desc->common.type != ACPI_TYPE_BUFFER) {
+			ACPI_ERROR((AE_INFO,
+				    "SMBus/IPMI/GenericSerialBus write requires Buffer, found type %s",
+				    acpi_ut_get_object_type_name(source_desc)));
+
+			return_ACPI_STATUS(AE_AML_OPERAND_TYPE);
+		}
+
+		if (obj_desc->field.region_obj->region.space_id ==
+		    ACPI_ADR_SPACE_SMBUS) {
+			length = ACPI_SMBUS_BUFFER_SIZE;
+			function =
+			    ACPI_WRITE | (obj_desc->field.attribute << 16);
+		} else if (obj_desc->field.region_obj->region.space_id ==
+			   ACPI_ADR_SPACE_GSBUS) {
+			length = ACPI_GSBUS_BUFFER_SIZE;
+			function =
+			    ACPI_WRITE | (obj_desc->field.attribute << 16);
+		} else {	/* IPMI */
+
+			length = ACPI_IPMI_BUFFER_SIZE;
+			function = ACPI_WRITE;
+		}
+
+		if (source_desc->buffer.length < length) {
+			ACPI_ERROR((AE_INFO,
+				    "SMBus/IPMI/GenericSerialBus write requires Buffer of length %u, found length %u",
+				    length, source_desc->buffer.length));
+
+			return_ACPI_STATUS(AE_AML_BUFFER_LIMIT);
+		}
+
+		/* Create the bi-directional buffer */
+
+		buffer_desc = acpi_ut_create_buffer_object(length);
+		if (!buffer_desc) {
+			return_ACPI_STATUS(AE_NO_MEMORY);
+		}
+
+		buffer = buffer_desc->buffer.pointer;
+		ACPI_MEMCPY(buffer, source_desc->buffer.pointer, length);
+
+		/* Lock entire transaction if requested */
+
+		acpi_ex_acquire_global_lock(obj_desc->common_field.field_flags);
+
+		/*
+		 * Perform the write (returns status and perhaps data in the
+		 * same buffer)
+		 */
+		status = acpi_ex_access_region(obj_desc, 0,
+					       (u64 *)buffer, function);
+		acpi_ex_release_global_lock(obj_desc->common_field.field_flags);
+
+		*result_desc = buffer_desc;
+		return_ACPI_STATUS(status);
+	}
+
+	/* Get a pointer to the data to be written */
+
+	switch (source_desc->common.type) {
+	case ACPI_TYPE_INTEGER:
+		buffer = &source_desc->integer.value;
+		length = sizeof(source_desc->integer.value);
+		break;
+
+	case ACPI_TYPE_BUFFER:
+		buffer = source_desc->buffer.pointer;
+		length = source_desc->buffer.length;
+		break;
+
+	case ACPI_TYPE_STRING:
+		buffer = source_desc->string.pointer;
+		length = source_desc->string.length;
+		break;
+
+	default:
+		return_ACPI_STATUS(AE_AML_OPERAND_TYPE);
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_BFIELD,
+			  "FieldWrite [FROM]: Obj %p (%s:%X), Buf %p, ByteLen %X\n",
+			  source_desc,
+			  acpi_ut_get_type_name(source_desc->common.type),
+			  source_desc->common.type, buffer, length));
+
+	ACPI_DEBUG_PRINT((ACPI_DB_BFIELD,
+			  "FieldWrite [TO]:   Obj %p (%s:%X), BitLen %X, BitOff %X, ByteOff %X\n",
+			  obj_desc,
+			  acpi_ut_get_type_name(obj_desc->common.type),
+			  obj_desc->common.type,
+			  obj_desc->common_field.bit_length,
+			  obj_desc->common_field.start_field_bit_offset,
+			  obj_desc->common_field.base_byte_offset));
+
+	/* Lock entire transaction if requested */
+
+	acpi_ex_acquire_global_lock(obj_desc->common_field.field_flags);
+
+	/* Write to the field */
+
+	status = acpi_ex_insert_into_field(obj_desc, buffer, length);
+	acpi_ex_release_global_lock(obj_desc->common_field.field_flags);
+
+	return_ACPI_STATUS(status);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exfldio.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exfldio.c
new file mode 100644
index 00000000..29dd8171
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exfldio.c
@@ -0,0 +1,997 @@
+/******************************************************************************
+ *
+ * Module Name: exfldio - Aml Field I/O
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acinterp.h"
+#include "amlcode.h"
+#include "acevents.h"
+#include "acdispat.h"
+
+#define _COMPONENT          ACPI_EXECUTER
+ACPI_MODULE_NAME("exfldio")
+
+/* Local prototypes */
+static acpi_status
+acpi_ex_field_datum_io(union acpi_operand_object *obj_desc,
+		       u32 field_datum_byte_offset, u64 *value, u32 read_write);
+
+static u8
+acpi_ex_register_overflow(union acpi_operand_object *obj_desc, u64 value);
+
+static acpi_status
+acpi_ex_setup_region(union acpi_operand_object *obj_desc,
+		     u32 field_datum_byte_offset);
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_setup_region
+ *
+ * PARAMETERS:  obj_desc                - Field to be read or written
+ *              field_datum_byte_offset - Byte offset of this datum within the
+ *                                        parent field
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Common processing for acpi_ex_extract_from_field and
+ *              acpi_ex_insert_into_field. Initialize the Region if necessary and
+ *              validate the request.
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ex_setup_region(union acpi_operand_object *obj_desc,
+		     u32 field_datum_byte_offset)
+{
+	acpi_status status = AE_OK;
+	union acpi_operand_object *rgn_desc;
+	u8 space_id;
+
+	ACPI_FUNCTION_TRACE_U32(ex_setup_region, field_datum_byte_offset);
+
+	rgn_desc = obj_desc->common_field.region_obj;
+
+	/* We must have a valid region */
+
+	if (rgn_desc->common.type != ACPI_TYPE_REGION) {
+		ACPI_ERROR((AE_INFO, "Needed Region, found type 0x%X (%s)",
+			    rgn_desc->common.type,
+			    acpi_ut_get_object_type_name(rgn_desc)));
+
+		return_ACPI_STATUS(AE_AML_OPERAND_TYPE);
+	}
+
+	space_id = rgn_desc->region.space_id;
+
+	/* Validate the Space ID */
+
+	if (!acpi_is_valid_space_id(space_id)) {
+		ACPI_ERROR((AE_INFO,
+			    "Invalid/unknown Address Space ID: 0x%2.2X",
+			    space_id));
+		return_ACPI_STATUS(AE_AML_INVALID_SPACE_ID);
+	}
+
+	/*
+	 * If the Region Address and Length have not been previously evaluated,
+	 * evaluate them now and save the results.
+	 */
+	if (!(rgn_desc->common.flags & AOPOBJ_DATA_VALID)) {
+		status = acpi_ds_get_region_arguments(rgn_desc);
+		if (ACPI_FAILURE(status)) {
+			return_ACPI_STATUS(status);
+		}
+	}
+
+	/*
+	 * Exit now for SMBus, GSBus or IPMI address space, it has a non-linear
+	 * address space and the request cannot be directly validated
+	 */
+	if (space_id == ACPI_ADR_SPACE_SMBUS ||
+	    space_id == ACPI_ADR_SPACE_GSBUS ||
+	    space_id == ACPI_ADR_SPACE_IPMI) {
+
+		/* SMBus or IPMI has a non-linear address space */
+
+		return_ACPI_STATUS(AE_OK);
+	}
+#ifdef ACPI_UNDER_DEVELOPMENT
+	/*
+	 * If the Field access is any_acc, we can now compute the optimal
+	 * access (because we know know the length of the parent region)
+	 */
+	if (!(obj_desc->common.flags & AOPOBJ_DATA_VALID)) {
+		if (ACPI_FAILURE(status)) {
+			return_ACPI_STATUS(status);
+		}
+	}
+#endif
+
+	/*
+	 * Validate the request.  The entire request from the byte offset for a
+	 * length of one field datum (access width) must fit within the region.
+	 * (Region length is specified in bytes)
+	 */
+	if (rgn_desc->region.length <
+	    (obj_desc->common_field.base_byte_offset + field_datum_byte_offset +
+	     obj_desc->common_field.access_byte_width)) {
+		if (acpi_gbl_enable_interpreter_slack) {
+			/*
+			 * Slack mode only:  We will go ahead and allow access to this
+			 * field if it is within the region length rounded up to the next
+			 * access width boundary. acpi_size cast for 64-bit compile.
+			 */
+			if (ACPI_ROUND_UP(rgn_desc->region.length,
+					  obj_desc->common_field.
+					  access_byte_width) >=
+			    ((acpi_size) obj_desc->common_field.
+			     base_byte_offset +
+			     obj_desc->common_field.access_byte_width +
+			     field_datum_byte_offset)) {
+				return_ACPI_STATUS(AE_OK);
+			}
+		}
+
+		if (rgn_desc->region.length <
+		    obj_desc->common_field.access_byte_width) {
+			/*
+			 * This is the case where the access_type (acc_word, etc.) is wider
+			 * than the region itself.  For example, a region of length one
+			 * byte, and a field with Dword access specified.
+			 */
+			ACPI_ERROR((AE_INFO,
+				    "Field [%4.4s] access width (%u bytes) too large for region [%4.4s] (length %u)",
+				    acpi_ut_get_node_name(obj_desc->
+							  common_field.node),
+				    obj_desc->common_field.access_byte_width,
+				    acpi_ut_get_node_name(rgn_desc->region.
+							  node),
+				    rgn_desc->region.length));
+		}
+
+		/*
+		 * Offset rounded up to next multiple of field width
+		 * exceeds region length, indicate an error
+		 */
+		ACPI_ERROR((AE_INFO,
+			    "Field [%4.4s] Base+Offset+Width %u+%u+%u is beyond end of region [%4.4s] (length %u)",
+			    acpi_ut_get_node_name(obj_desc->common_field.node),
+			    obj_desc->common_field.base_byte_offset,
+			    field_datum_byte_offset,
+			    obj_desc->common_field.access_byte_width,
+			    acpi_ut_get_node_name(rgn_desc->region.node),
+			    rgn_desc->region.length));
+
+		return_ACPI_STATUS(AE_AML_REGION_LIMIT);
+	}
+
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_access_region
+ *
+ * PARAMETERS:  obj_desc                - Field to be read
+ *              field_datum_byte_offset - Byte offset of this datum within the
+ *                                        parent field
+ *              Value                   - Where to store value (must at least
+ *                                        64 bits)
+ *              Function                - Read or Write flag plus other region-
+ *                                        dependent flags
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Read or Write a single field datum to an Operation Region.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ex_access_region(union acpi_operand_object *obj_desc,
+		      u32 field_datum_byte_offset, u64 *value, u32 function)
+{
+	acpi_status status;
+	union acpi_operand_object *rgn_desc;
+	u32 region_offset;
+
+	ACPI_FUNCTION_TRACE(ex_access_region);
+
+	/*
+	 * Ensure that the region operands are fully evaluated and verify
+	 * the validity of the request
+	 */
+	status = acpi_ex_setup_region(obj_desc, field_datum_byte_offset);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/*
+	 * The physical address of this field datum is:
+	 *
+	 * 1) The base of the region, plus
+	 * 2) The base offset of the field, plus
+	 * 3) The current offset into the field
+	 */
+	rgn_desc = obj_desc->common_field.region_obj;
+	region_offset =
+	    obj_desc->common_field.base_byte_offset + field_datum_byte_offset;
+
+	if ((function & ACPI_IO_MASK) == ACPI_READ) {
+		ACPI_DEBUG_PRINT((ACPI_DB_BFIELD, "[READ]"));
+	} else {
+		ACPI_DEBUG_PRINT((ACPI_DB_BFIELD, "[WRITE]"));
+	}
+
+	ACPI_DEBUG_PRINT_RAW((ACPI_DB_BFIELD,
+			      " Region [%s:%X], Width %X, ByteBase %X, Offset %X at %p\n",
+			      acpi_ut_get_region_name(rgn_desc->region.
+						      space_id),
+			      rgn_desc->region.space_id,
+			      obj_desc->common_field.access_byte_width,
+			      obj_desc->common_field.base_byte_offset,
+			      field_datum_byte_offset, ACPI_CAST_PTR(void,
+								     (rgn_desc->
+								      region.
+								      address +
+								      region_offset))));
+
+	/* Invoke the appropriate address_space/op_region handler */
+
+	status = acpi_ev_address_space_dispatch(rgn_desc, obj_desc,
+						function, region_offset,
+						ACPI_MUL_8(obj_desc->
+							   common_field.
+							   access_byte_width),
+						value);
+
+	if (ACPI_FAILURE(status)) {
+		if (status == AE_NOT_IMPLEMENTED) {
+			ACPI_ERROR((AE_INFO,
+				    "Region %s (ID=%u) not implemented",
+				    acpi_ut_get_region_name(rgn_desc->region.
+							    space_id),
+				    rgn_desc->region.space_id));
+		} else if (status == AE_NOT_EXIST) {
+			ACPI_ERROR((AE_INFO,
+				    "Region %s (ID=%u) has no handler",
+				    acpi_ut_get_region_name(rgn_desc->region.
+							    space_id),
+				    rgn_desc->region.space_id));
+		}
+	}
+
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_register_overflow
+ *
+ * PARAMETERS:  obj_desc                - Register(Field) to be written
+ *              Value                   - Value to be stored
+ *
+ * RETURN:      TRUE if value overflows the field, FALSE otherwise
+ *
+ * DESCRIPTION: Check if a value is out of range of the field being written.
+ *              Used to check if the values written to Index and Bank registers
+ *              are out of range.  Normally, the value is simply truncated
+ *              to fit the field, but this case is most likely a serious
+ *              coding error in the ASL.
+ *
+ ******************************************************************************/
+
+static u8
+acpi_ex_register_overflow(union acpi_operand_object *obj_desc, u64 value)
+{
+	ACPI_FUNCTION_NAME(ex_register_overflow);
+
+	if (obj_desc->common_field.bit_length >= ACPI_INTEGER_BIT_SIZE) {
+		/*
+		 * The field is large enough to hold the maximum integer, so we can
+		 * never overflow it.
+		 */
+		return (FALSE);
+	}
+
+	if (value >= ((u64)1 << obj_desc->common_field.bit_length)) {
+		/*
+		 * The Value is larger than the maximum value that can fit into
+		 * the register.
+		 */
+		ACPI_ERROR((AE_INFO,
+			    "Index value 0x%8.8X%8.8X overflows field width 0x%X",
+			    ACPI_FORMAT_UINT64(value),
+			    obj_desc->common_field.bit_length));
+
+		return (TRUE);
+	}
+
+	/* The Value will fit into the field with no truncation */
+
+	return (FALSE);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_field_datum_io
+ *
+ * PARAMETERS:  obj_desc                - Field to be read
+ *              field_datum_byte_offset - Byte offset of this datum within the
+ *                                        parent field
+ *              Value                   - Where to store value (must be 64 bits)
+ *              read_write              - Read or Write flag
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Read or Write a single datum of a field.  The field_type is
+ *              demultiplexed here to handle the different types of fields
+ *              (buffer_field, region_field, index_field, bank_field)
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ex_field_datum_io(union acpi_operand_object *obj_desc,
+		       u32 field_datum_byte_offset, u64 *value, u32 read_write)
+{
+	acpi_status status;
+	u64 local_value;
+
+	ACPI_FUNCTION_TRACE_U32(ex_field_datum_io, field_datum_byte_offset);
+
+	if (read_write == ACPI_READ) {
+		if (!value) {
+			local_value = 0;
+
+			/* To support reads without saving return value */
+			value = &local_value;
+		}
+
+		/* Clear the entire return buffer first, [Very Important!] */
+
+		*value = 0;
+	}
+
+	/*
+	 * The four types of fields are:
+	 *
+	 * buffer_field - Read/write from/to a Buffer
+	 * region_field - Read/write from/to a Operation Region.
+	 * bank_field  - Write to a Bank Register, then read/write from/to an
+	 *               operation_region
+	 * index_field - Write to an Index Register, then read/write from/to a
+	 *               Data Register
+	 */
+	switch (obj_desc->common.type) {
+	case ACPI_TYPE_BUFFER_FIELD:
+		/*
+		 * If the buffer_field arguments have not been previously evaluated,
+		 * evaluate them now and save the results.
+		 */
+		if (!(obj_desc->common.flags & AOPOBJ_DATA_VALID)) {
+			status = acpi_ds_get_buffer_field_arguments(obj_desc);
+			if (ACPI_FAILURE(status)) {
+				return_ACPI_STATUS(status);
+			}
+		}
+
+		if (read_write == ACPI_READ) {
+			/*
+			 * Copy the data from the source buffer.
+			 * Length is the field width in bytes.
+			 */
+			ACPI_MEMCPY(value,
+				    (obj_desc->buffer_field.buffer_obj)->buffer.
+				    pointer +
+				    obj_desc->buffer_field.base_byte_offset +
+				    field_datum_byte_offset,
+				    obj_desc->common_field.access_byte_width);
+		} else {
+			/*
+			 * Copy the data to the target buffer.
+			 * Length is the field width in bytes.
+			 */
+			ACPI_MEMCPY((obj_desc->buffer_field.buffer_obj)->buffer.
+				    pointer +
+				    obj_desc->buffer_field.base_byte_offset +
+				    field_datum_byte_offset, value,
+				    obj_desc->common_field.access_byte_width);
+		}
+
+		status = AE_OK;
+		break;
+
+	case ACPI_TYPE_LOCAL_BANK_FIELD:
+
+		/*
+		 * Ensure that the bank_value is not beyond the capacity of
+		 * the register
+		 */
+		if (acpi_ex_register_overflow(obj_desc->bank_field.bank_obj,
+					      (u64)obj_desc->bank_field.
+					      value)) {
+			return_ACPI_STATUS(AE_AML_REGISTER_LIMIT);
+		}
+
+		/*
+		 * For bank_fields, we must write the bank_value to the bank_register
+		 * (itself a region_field) before we can access the data.
+		 */
+		status =
+		    acpi_ex_insert_into_field(obj_desc->bank_field.bank_obj,
+					      &obj_desc->bank_field.value,
+					      sizeof(obj_desc->bank_field.
+						     value));
+		if (ACPI_FAILURE(status)) {
+			return_ACPI_STATUS(status);
+		}
+
+		/*
+		 * Now that the Bank has been selected, fall through to the
+		 * region_field case and write the datum to the Operation Region
+		 */
+
+		/*lint -fallthrough */
+
+	case ACPI_TYPE_LOCAL_REGION_FIELD:
+		/*
+		 * For simple region_fields, we just directly access the owning
+		 * Operation Region.
+		 */
+		status =
+		    acpi_ex_access_region(obj_desc, field_datum_byte_offset,
+					  value, read_write);
+		break;
+
+	case ACPI_TYPE_LOCAL_INDEX_FIELD:
+
+		/*
+		 * Ensure that the index_value is not beyond the capacity of
+		 * the register
+		 */
+		if (acpi_ex_register_overflow(obj_desc->index_field.index_obj,
+					      (u64)obj_desc->index_field.
+					      value)) {
+			return_ACPI_STATUS(AE_AML_REGISTER_LIMIT);
+		}
+
+		/* Write the index value to the index_register (itself a region_field) */
+
+		field_datum_byte_offset += obj_desc->index_field.value;
+
+		ACPI_DEBUG_PRINT((ACPI_DB_BFIELD,
+				  "Write to Index Register: Value %8.8X\n",
+				  field_datum_byte_offset));
+
+		status =
+		    acpi_ex_insert_into_field(obj_desc->index_field.index_obj,
+					      &field_datum_byte_offset,
+					      sizeof(field_datum_byte_offset));
+		if (ACPI_FAILURE(status)) {
+			return_ACPI_STATUS(status);
+		}
+
+		if (read_write == ACPI_READ) {
+
+			/* Read the datum from the data_register */
+
+			ACPI_DEBUG_PRINT((ACPI_DB_BFIELD,
+					  "Read from Data Register\n"));
+
+			status =
+			    acpi_ex_extract_from_field(obj_desc->index_field.
+						       data_obj, value,
+						       sizeof(u64));
+		} else {
+			/* Write the datum to the data_register */
+
+			ACPI_DEBUG_PRINT((ACPI_DB_BFIELD,
+					  "Write to Data Register: Value %8.8X%8.8X\n",
+					  ACPI_FORMAT_UINT64(*value)));
+
+			status =
+			    acpi_ex_insert_into_field(obj_desc->index_field.
+						      data_obj, value,
+						      sizeof(u64));
+		}
+		break;
+
+	default:
+
+		ACPI_ERROR((AE_INFO, "Wrong object type in field I/O %u",
+			    obj_desc->common.type));
+		status = AE_AML_INTERNAL;
+		break;
+	}
+
+	if (ACPI_SUCCESS(status)) {
+		if (read_write == ACPI_READ) {
+			ACPI_DEBUG_PRINT((ACPI_DB_BFIELD,
+					  "Value Read %8.8X%8.8X, Width %u\n",
+					  ACPI_FORMAT_UINT64(*value),
+					  obj_desc->common_field.
+					  access_byte_width));
+		} else {
+			ACPI_DEBUG_PRINT((ACPI_DB_BFIELD,
+					  "Value Written %8.8X%8.8X, Width %u\n",
+					  ACPI_FORMAT_UINT64(*value),
+					  obj_desc->common_field.
+					  access_byte_width));
+		}
+	}
+
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_write_with_update_rule
+ *
+ * PARAMETERS:  obj_desc                - Field to be written
+ *              Mask                    - bitmask within field datum
+ *              field_value             - Value to write
+ *              field_datum_byte_offset - Offset of datum within field
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Apply the field update rule to a field write
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ex_write_with_update_rule(union acpi_operand_object *obj_desc,
+			       u64 mask,
+			       u64 field_value, u32 field_datum_byte_offset)
+{
+	acpi_status status = AE_OK;
+	u64 merged_value;
+	u64 current_value;
+
+	ACPI_FUNCTION_TRACE_U32(ex_write_with_update_rule, mask);
+
+	/* Start with the new bits  */
+
+	merged_value = field_value;
+
+	/* If the mask is all ones, we don't need to worry about the update rule */
+
+	if (mask != ACPI_UINT64_MAX) {
+
+		/* Decode the update rule */
+
+		switch (obj_desc->common_field.
+			field_flags & AML_FIELD_UPDATE_RULE_MASK) {
+		case AML_FIELD_UPDATE_PRESERVE:
+			/*
+			 * Check if update rule needs to be applied (not if mask is all
+			 * ones)  The left shift drops the bits we want to ignore.
+			 */
+			if ((~mask << (ACPI_MUL_8(sizeof(mask)) -
+				       ACPI_MUL_8(obj_desc->common_field.
+						  access_byte_width))) != 0) {
+				/*
+				 * Read the current contents of the byte/word/dword containing
+				 * the field, and merge with the new field value.
+				 */
+				status =
+				    acpi_ex_field_datum_io(obj_desc,
+							   field_datum_byte_offset,
+							   &current_value,
+							   ACPI_READ);
+				if (ACPI_FAILURE(status)) {
+					return_ACPI_STATUS(status);
+				}
+
+				merged_value |= (current_value & ~mask);
+			}
+			break;
+
+		case AML_FIELD_UPDATE_WRITE_AS_ONES:
+
+			/* Set positions outside the field to all ones */
+
+			merged_value |= ~mask;
+			break;
+
+		case AML_FIELD_UPDATE_WRITE_AS_ZEROS:
+
+			/* Set positions outside the field to all zeros */
+
+			merged_value &= mask;
+			break;
+
+		default:
+
+			ACPI_ERROR((AE_INFO,
+				    "Unknown UpdateRule value: 0x%X",
+				    (obj_desc->common_field.
+				     field_flags &
+				     AML_FIELD_UPDATE_RULE_MASK)));
+			return_ACPI_STATUS(AE_AML_OPERAND_VALUE);
+		}
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_BFIELD,
+			  "Mask %8.8X%8.8X, DatumOffset %X, Width %X, Value %8.8X%8.8X, MergedValue %8.8X%8.8X\n",
+			  ACPI_FORMAT_UINT64(mask),
+			  field_datum_byte_offset,
+			  obj_desc->common_field.access_byte_width,
+			  ACPI_FORMAT_UINT64(field_value),
+			  ACPI_FORMAT_UINT64(merged_value)));
+
+	/* Write the merged value */
+
+	status = acpi_ex_field_datum_io(obj_desc, field_datum_byte_offset,
+					&merged_value, ACPI_WRITE);
+
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_extract_from_field
+ *
+ * PARAMETERS:  obj_desc            - Field to be read
+ *              Buffer              - Where to store the field data
+ *              buffer_length       - Length of Buffer
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Retrieve the current value of the given field
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ex_extract_from_field(union acpi_operand_object *obj_desc,
+			   void *buffer, u32 buffer_length)
+{
+	acpi_status status;
+	u64 raw_datum;
+	u64 merged_datum;
+	u32 field_offset = 0;
+	u32 buffer_offset = 0;
+	u32 buffer_tail_bits;
+	u32 datum_count;
+	u32 field_datum_count;
+	u32 access_bit_width;
+	u32 i;
+
+	ACPI_FUNCTION_TRACE(ex_extract_from_field);
+
+	/* Validate target buffer and clear it */
+
+	if (buffer_length <
+	    ACPI_ROUND_BITS_UP_TO_BYTES(obj_desc->common_field.bit_length)) {
+		ACPI_ERROR((AE_INFO,
+			    "Field size %u (bits) is too large for buffer (%u)",
+			    obj_desc->common_field.bit_length, buffer_length));
+
+		return_ACPI_STATUS(AE_BUFFER_OVERFLOW);
+	}
+
+	ACPI_MEMSET(buffer, 0, buffer_length);
+	access_bit_width = ACPI_MUL_8(obj_desc->common_field.access_byte_width);
+
+	/* Handle the simple case here */
+
+	if ((obj_desc->common_field.start_field_bit_offset == 0) &&
+	    (obj_desc->common_field.bit_length == access_bit_width)) {
+		status = acpi_ex_field_datum_io(obj_desc, 0, buffer, ACPI_READ);
+		return_ACPI_STATUS(status);
+	}
+
+/* TBD: Move to common setup code */
+
+	/* Field algorithm is limited to sizeof(u64), truncate if needed */
+
+	if (obj_desc->common_field.access_byte_width > sizeof(u64)) {
+		obj_desc->common_field.access_byte_width = sizeof(u64);
+		access_bit_width = sizeof(u64) * 8;
+	}
+
+	/* Compute the number of datums (access width data items) */
+
+	datum_count =
+	    ACPI_ROUND_UP_TO(obj_desc->common_field.bit_length,
+			     access_bit_width);
+
+	field_datum_count = ACPI_ROUND_UP_TO(obj_desc->common_field.bit_length +
+					     obj_desc->common_field.
+					     start_field_bit_offset,
+					     access_bit_width);
+
+	/* Priming read from the field */
+
+	status =
+	    acpi_ex_field_datum_io(obj_desc, field_offset, &raw_datum,
+				   ACPI_READ);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+	merged_datum =
+	    raw_datum >> obj_desc->common_field.start_field_bit_offset;
+
+	/* Read the rest of the field */
+
+	for (i = 1; i < field_datum_count; i++) {
+
+		/* Get next input datum from the field */
+
+		field_offset += obj_desc->common_field.access_byte_width;
+		status = acpi_ex_field_datum_io(obj_desc, field_offset,
+						&raw_datum, ACPI_READ);
+		if (ACPI_FAILURE(status)) {
+			return_ACPI_STATUS(status);
+		}
+
+		/*
+		 * Merge with previous datum if necessary.
+		 *
+		 * Note: Before the shift, check if the shift value will be larger than
+		 * the integer size. If so, there is no need to perform the operation.
+		 * This avoids the differences in behavior between different compilers
+		 * concerning shift values larger than the target data width.
+		 */
+		if (access_bit_width -
+		    obj_desc->common_field.start_field_bit_offset <
+		    ACPI_INTEGER_BIT_SIZE) {
+			merged_datum |=
+			    raw_datum << (access_bit_width -
+					  obj_desc->common_field.
+					  start_field_bit_offset);
+		}
+
+		if (i == datum_count) {
+			break;
+		}
+
+		/* Write merged datum to target buffer */
+
+		ACPI_MEMCPY(((char *)buffer) + buffer_offset, &merged_datum,
+			    ACPI_MIN(obj_desc->common_field.access_byte_width,
+				     buffer_length - buffer_offset));
+
+		buffer_offset += obj_desc->common_field.access_byte_width;
+		merged_datum =
+		    raw_datum >> obj_desc->common_field.start_field_bit_offset;
+	}
+
+	/* Mask off any extra bits in the last datum */
+
+	buffer_tail_bits = obj_desc->common_field.bit_length % access_bit_width;
+	if (buffer_tail_bits) {
+		merged_datum &= ACPI_MASK_BITS_ABOVE(buffer_tail_bits);
+	}
+
+	/* Write the last datum to the buffer */
+
+	ACPI_MEMCPY(((char *)buffer) + buffer_offset, &merged_datum,
+		    ACPI_MIN(obj_desc->common_field.access_byte_width,
+			     buffer_length - buffer_offset));
+
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_insert_into_field
+ *
+ * PARAMETERS:  obj_desc            - Field to be written
+ *              Buffer              - Data to be written
+ *              buffer_length       - Length of Buffer
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Store the Buffer contents into the given field
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ex_insert_into_field(union acpi_operand_object *obj_desc,
+			  void *buffer, u32 buffer_length)
+{
+	void *new_buffer;
+	acpi_status status;
+	u64 mask;
+	u64 width_mask;
+	u64 merged_datum;
+	u64 raw_datum = 0;
+	u32 field_offset = 0;
+	u32 buffer_offset = 0;
+	u32 buffer_tail_bits;
+	u32 datum_count;
+	u32 field_datum_count;
+	u32 access_bit_width;
+	u32 required_length;
+	u32 i;
+
+	ACPI_FUNCTION_TRACE(ex_insert_into_field);
+
+	/* Validate input buffer */
+
+	new_buffer = NULL;
+	required_length =
+	    ACPI_ROUND_BITS_UP_TO_BYTES(obj_desc->common_field.bit_length);
+	/*
+	 * We must have a buffer that is at least as long as the field
+	 * we are writing to.  This is because individual fields are
+	 * indivisible and partial writes are not supported -- as per
+	 * the ACPI specification.
+	 */
+	if (buffer_length < required_length) {
+
+		/* We need to create a new buffer */
+
+		new_buffer = ACPI_ALLOCATE_ZEROED(required_length);
+		if (!new_buffer) {
+			return_ACPI_STATUS(AE_NO_MEMORY);
+		}
+
+		/*
+		 * Copy the original data to the new buffer, starting
+		 * at Byte zero.  All unused (upper) bytes of the
+		 * buffer will be 0.
+		 */
+		ACPI_MEMCPY((char *)new_buffer, (char *)buffer, buffer_length);
+		buffer = new_buffer;
+		buffer_length = required_length;
+	}
+
+/* TBD: Move to common setup code */
+
+	/* Algo is limited to sizeof(u64), so cut the access_byte_width */
+	if (obj_desc->common_field.access_byte_width > sizeof(u64)) {
+		obj_desc->common_field.access_byte_width = sizeof(u64);
+	}
+
+	access_bit_width = ACPI_MUL_8(obj_desc->common_field.access_byte_width);
+
+	/*
+	 * Create the bitmasks used for bit insertion.
+	 * Note: This if/else is used to bypass compiler differences with the
+	 * shift operator
+	 */
+	if (access_bit_width == ACPI_INTEGER_BIT_SIZE) {
+		width_mask = ACPI_UINT64_MAX;
+	} else {
+		width_mask = ACPI_MASK_BITS_ABOVE(access_bit_width);
+	}
+
+	mask = width_mask &
+	    ACPI_MASK_BITS_BELOW(obj_desc->common_field.start_field_bit_offset);
+
+	/* Compute the number of datums (access width data items) */
+
+	datum_count = ACPI_ROUND_UP_TO(obj_desc->common_field.bit_length,
+				       access_bit_width);
+
+	field_datum_count = ACPI_ROUND_UP_TO(obj_desc->common_field.bit_length +
+					     obj_desc->common_field.
+					     start_field_bit_offset,
+					     access_bit_width);
+
+	/* Get initial Datum from the input buffer */
+
+	ACPI_MEMCPY(&raw_datum, buffer,
+		    ACPI_MIN(obj_desc->common_field.access_byte_width,
+			     buffer_length - buffer_offset));
+
+	merged_datum =
+	    raw_datum << obj_desc->common_field.start_field_bit_offset;
+
+	/* Write the entire field */
+
+	for (i = 1; i < field_datum_count; i++) {
+
+		/* Write merged datum to the target field */
+
+		merged_datum &= mask;
+		status = acpi_ex_write_with_update_rule(obj_desc, mask,
+							merged_datum,
+							field_offset);
+		if (ACPI_FAILURE(status)) {
+			goto exit;
+		}
+
+		field_offset += obj_desc->common_field.access_byte_width;
+
+		/*
+		 * Start new output datum by merging with previous input datum
+		 * if necessary.
+		 *
+		 * Note: Before the shift, check if the shift value will be larger than
+		 * the integer size. If so, there is no need to perform the operation.
+		 * This avoids the differences in behavior between different compilers
+		 * concerning shift values larger than the target data width.
+		 */
+		if ((access_bit_width -
+		     obj_desc->common_field.start_field_bit_offset) <
+		    ACPI_INTEGER_BIT_SIZE) {
+			merged_datum =
+			    raw_datum >> (access_bit_width -
+					  obj_desc->common_field.
+					  start_field_bit_offset);
+		} else {
+			merged_datum = 0;
+		}
+
+		mask = width_mask;
+
+		if (i == datum_count) {
+			break;
+		}
+
+		/* Get the next input datum from the buffer */
+
+		buffer_offset += obj_desc->common_field.access_byte_width;
+		ACPI_MEMCPY(&raw_datum, ((char *)buffer) + buffer_offset,
+			    ACPI_MIN(obj_desc->common_field.access_byte_width,
+				     buffer_length - buffer_offset));
+
+		merged_datum |=
+		    raw_datum << obj_desc->common_field.start_field_bit_offset;
+	}
+
+	/* Mask off any extra bits in the last datum */
+
+	buffer_tail_bits = (obj_desc->common_field.bit_length +
+			    obj_desc->common_field.start_field_bit_offset) %
+	    access_bit_width;
+	if (buffer_tail_bits) {
+		mask &= ACPI_MASK_BITS_ABOVE(buffer_tail_bits);
+	}
+
+	/* Write the last datum to the field */
+
+	merged_datum &= mask;
+	status = acpi_ex_write_with_update_rule(obj_desc,
+						mask, merged_datum,
+						field_offset);
+
+      exit:
+	/* Free temporary buffer if we used one */
+
+	if (new_buffer) {
+		ACPI_FREE(new_buffer);
+	}
+	return_ACPI_STATUS(status);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exmisc.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exmisc.c
new file mode 100644
index 00000000..c0539f39
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exmisc.c
@@ -0,0 +1,724 @@
+
+/******************************************************************************
+ *
+ * Module Name: exmisc - ACPI AML (p-code) execution - specific opcodes
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acinterp.h"
+#include "amlcode.h"
+#include "amlresrc.h"
+
+#define _COMPONENT          ACPI_EXECUTER
+ACPI_MODULE_NAME("exmisc")
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_get_object_reference
+ *
+ * PARAMETERS:  obj_desc            - Create a reference to this object
+ *              return_desc         - Where to store the reference
+ *              walk_state          - Current state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Obtain and return a "reference" to the target object
+ *              Common code for the ref_of_op and the cond_ref_of_op.
+ *
+ ******************************************************************************/
+acpi_status
+acpi_ex_get_object_reference(union acpi_operand_object *obj_desc,
+			     union acpi_operand_object **return_desc,
+			     struct acpi_walk_state * walk_state)
+{
+	union acpi_operand_object *reference_obj;
+	union acpi_operand_object *referenced_obj;
+
+	ACPI_FUNCTION_TRACE_PTR(ex_get_object_reference, obj_desc);
+
+	*return_desc = NULL;
+
+	switch (ACPI_GET_DESCRIPTOR_TYPE(obj_desc)) {
+	case ACPI_DESC_TYPE_OPERAND:
+
+		if (obj_desc->common.type != ACPI_TYPE_LOCAL_REFERENCE) {
+			return_ACPI_STATUS(AE_AML_OPERAND_TYPE);
+		}
+
+		/*
+		 * Must be a reference to a Local or Arg
+		 */
+		switch (obj_desc->reference.class) {
+		case ACPI_REFCLASS_LOCAL:
+		case ACPI_REFCLASS_ARG:
+		case ACPI_REFCLASS_DEBUG:
+
+			/* The referenced object is the pseudo-node for the local/arg */
+
+			referenced_obj = obj_desc->reference.object;
+			break;
+
+		default:
+
+			ACPI_ERROR((AE_INFO, "Unknown Reference Class 0x%2.2X",
+				    obj_desc->reference.class));
+			return_ACPI_STATUS(AE_AML_INTERNAL);
+		}
+		break;
+
+	case ACPI_DESC_TYPE_NAMED:
+
+		/*
+		 * A named reference that has already been resolved to a Node
+		 */
+		referenced_obj = obj_desc;
+		break;
+
+	default:
+
+		ACPI_ERROR((AE_INFO, "Invalid descriptor type 0x%X",
+			    ACPI_GET_DESCRIPTOR_TYPE(obj_desc)));
+		return_ACPI_STATUS(AE_TYPE);
+	}
+
+	/* Create a new reference object */
+
+	reference_obj =
+	    acpi_ut_create_internal_object(ACPI_TYPE_LOCAL_REFERENCE);
+	if (!reference_obj) {
+		return_ACPI_STATUS(AE_NO_MEMORY);
+	}
+
+	reference_obj->reference.class = ACPI_REFCLASS_REFOF;
+	reference_obj->reference.object = referenced_obj;
+	*return_desc = reference_obj;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
+			  "Object %p Type [%s], returning Reference %p\n",
+			  obj_desc, acpi_ut_get_object_type_name(obj_desc),
+			  *return_desc));
+
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_concat_template
+ *
+ * PARAMETERS:  Operand0            - First source object
+ *              Operand1            - Second source object
+ *              actual_return_desc  - Where to place the return object
+ *              walk_state          - Current walk state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Concatenate two resource templates
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ex_concat_template(union acpi_operand_object *operand0,
+			union acpi_operand_object *operand1,
+			union acpi_operand_object **actual_return_desc,
+			struct acpi_walk_state *walk_state)
+{
+	acpi_status status;
+	union acpi_operand_object *return_desc;
+	u8 *new_buf;
+	u8 *end_tag;
+	acpi_size length0;
+	acpi_size length1;
+	acpi_size new_length;
+
+	ACPI_FUNCTION_TRACE(ex_concat_template);
+
+	/*
+	 * Find the end_tag descriptor in each resource template.
+	 * Note1: returned pointers point TO the end_tag, not past it.
+	 * Note2: zero-length buffers are allowed; treated like one end_tag
+	 */
+
+	/* Get the length of the first resource template */
+
+	status = acpi_ut_get_resource_end_tag(operand0, &end_tag);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	length0 = ACPI_PTR_DIFF(end_tag, operand0->buffer.pointer);
+
+	/* Get the length of the second resource template */
+
+	status = acpi_ut_get_resource_end_tag(operand1, &end_tag);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	length1 = ACPI_PTR_DIFF(end_tag, operand1->buffer.pointer);
+
+	/* Combine both lengths, minimum size will be 2 for end_tag */
+
+	new_length = length0 + length1 + sizeof(struct aml_resource_end_tag);
+
+	/* Create a new buffer object for the result (with one end_tag) */
+
+	return_desc = acpi_ut_create_buffer_object(new_length);
+	if (!return_desc) {
+		return_ACPI_STATUS(AE_NO_MEMORY);
+	}
+
+	/*
+	 * Copy the templates to the new buffer, 0 first, then 1 follows. One
+	 * end_tag descriptor is copied from Operand1.
+	 */
+	new_buf = return_desc->buffer.pointer;
+	ACPI_MEMCPY(new_buf, operand0->buffer.pointer, length0);
+	ACPI_MEMCPY(new_buf + length0, operand1->buffer.pointer, length1);
+
+	/* Insert end_tag and set the checksum to zero, means "ignore checksum" */
+
+	new_buf[new_length - 1] = 0;
+	new_buf[new_length - 2] = ACPI_RESOURCE_NAME_END_TAG | 1;
+
+	/* Return the completed resource template */
+
+	*actual_return_desc = return_desc;
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_do_concatenate
+ *
+ * PARAMETERS:  Operand0            - First source object
+ *              Operand1            - Second source object
+ *              actual_return_desc  - Where to place the return object
+ *              walk_state          - Current walk state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Concatenate two objects OF THE SAME TYPE.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ex_do_concatenate(union acpi_operand_object *operand0,
+		       union acpi_operand_object *operand1,
+		       union acpi_operand_object **actual_return_desc,
+		       struct acpi_walk_state *walk_state)
+{
+	union acpi_operand_object *local_operand1 = operand1;
+	union acpi_operand_object *return_desc;
+	char *new_buf;
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(ex_do_concatenate);
+
+	/*
+	 * Convert the second operand if necessary.  The first operand
+	 * determines the type of the second operand, (See the Data Types
+	 * section of the ACPI specification.)  Both object types are
+	 * guaranteed to be either Integer/String/Buffer by the operand
+	 * resolution mechanism.
+	 */
+	switch (operand0->common.type) {
+	case ACPI_TYPE_INTEGER:
+		status =
+		    acpi_ex_convert_to_integer(operand1, &local_operand1, 16);
+		break;
+
+	case ACPI_TYPE_STRING:
+		status = acpi_ex_convert_to_string(operand1, &local_operand1,
+						   ACPI_IMPLICIT_CONVERT_HEX);
+		break;
+
+	case ACPI_TYPE_BUFFER:
+		status = acpi_ex_convert_to_buffer(operand1, &local_operand1);
+		break;
+
+	default:
+		ACPI_ERROR((AE_INFO, "Invalid object type: 0x%X",
+			    operand0->common.type));
+		status = AE_AML_INTERNAL;
+	}
+
+	if (ACPI_FAILURE(status)) {
+		goto cleanup;
+	}
+
+	/*
+	 * Both operands are now known to be the same object type
+	 * (Both are Integer, String, or Buffer), and we can now perform the
+	 * concatenation.
+	 */
+
+	/*
+	 * There are three cases to handle:
+	 *
+	 * 1) Two Integers concatenated to produce a new Buffer
+	 * 2) Two Strings concatenated to produce a new String
+	 * 3) Two Buffers concatenated to produce a new Buffer
+	 */
+	switch (operand0->common.type) {
+	case ACPI_TYPE_INTEGER:
+
+		/* Result of two Integers is a Buffer */
+		/* Need enough buffer space for two integers */
+
+		return_desc = acpi_ut_create_buffer_object((acpi_size)
+							   ACPI_MUL_2
+							   (acpi_gbl_integer_byte_width));
+		if (!return_desc) {
+			status = AE_NO_MEMORY;
+			goto cleanup;
+		}
+
+		new_buf = (char *)return_desc->buffer.pointer;
+
+		/* Copy the first integer, LSB first */
+
+		ACPI_MEMCPY(new_buf, &operand0->integer.value,
+			    acpi_gbl_integer_byte_width);
+
+		/* Copy the second integer (LSB first) after the first */
+
+		ACPI_MEMCPY(new_buf + acpi_gbl_integer_byte_width,
+			    &local_operand1->integer.value,
+			    acpi_gbl_integer_byte_width);
+		break;
+
+	case ACPI_TYPE_STRING:
+
+		/* Result of two Strings is a String */
+
+		return_desc = acpi_ut_create_string_object(((acpi_size)
+							    operand0->string.
+							    length +
+							    local_operand1->
+							    string.length));
+		if (!return_desc) {
+			status = AE_NO_MEMORY;
+			goto cleanup;
+		}
+
+		new_buf = return_desc->string.pointer;
+
+		/* Concatenate the strings */
+
+		ACPI_STRCPY(new_buf, operand0->string.pointer);
+		ACPI_STRCPY(new_buf + operand0->string.length,
+			    local_operand1->string.pointer);
+		break;
+
+	case ACPI_TYPE_BUFFER:
+
+		/* Result of two Buffers is a Buffer */
+
+		return_desc = acpi_ut_create_buffer_object(((acpi_size)
+							    operand0->buffer.
+							    length +
+							    local_operand1->
+							    buffer.length));
+		if (!return_desc) {
+			status = AE_NO_MEMORY;
+			goto cleanup;
+		}
+
+		new_buf = (char *)return_desc->buffer.pointer;
+
+		/* Concatenate the buffers */
+
+		ACPI_MEMCPY(new_buf, operand0->buffer.pointer,
+			    operand0->buffer.length);
+		ACPI_MEMCPY(new_buf + operand0->buffer.length,
+			    local_operand1->buffer.pointer,
+			    local_operand1->buffer.length);
+		break;
+
+	default:
+
+		/* Invalid object type, should not happen here */
+
+		ACPI_ERROR((AE_INFO, "Invalid object type: 0x%X",
+			    operand0->common.type));
+		status = AE_AML_INTERNAL;
+		goto cleanup;
+	}
+
+	*actual_return_desc = return_desc;
+
+      cleanup:
+	if (local_operand1 != operand1) {
+		acpi_ut_remove_reference(local_operand1);
+	}
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_do_math_op
+ *
+ * PARAMETERS:  Opcode              - AML opcode
+ *              Integer0            - Integer operand #0
+ *              Integer1            - Integer operand #1
+ *
+ * RETURN:      Integer result of the operation
+ *
+ * DESCRIPTION: Execute a math AML opcode. The purpose of having all of the
+ *              math functions here is to prevent a lot of pointer dereferencing
+ *              to obtain the operands.
+ *
+ ******************************************************************************/
+
+u64 acpi_ex_do_math_op(u16 opcode, u64 integer0, u64 integer1)
+{
+
+	ACPI_FUNCTION_ENTRY();
+
+	switch (opcode) {
+	case AML_ADD_OP:	/* Add (Integer0, Integer1, Result) */
+
+		return (integer0 + integer1);
+
+	case AML_BIT_AND_OP:	/* And (Integer0, Integer1, Result) */
+
+		return (integer0 & integer1);
+
+	case AML_BIT_NAND_OP:	/* NAnd (Integer0, Integer1, Result) */
+
+		return (~(integer0 & integer1));
+
+	case AML_BIT_OR_OP:	/* Or (Integer0, Integer1, Result) */
+
+		return (integer0 | integer1);
+
+	case AML_BIT_NOR_OP:	/* NOr (Integer0, Integer1, Result) */
+
+		return (~(integer0 | integer1));
+
+	case AML_BIT_XOR_OP:	/* XOr (Integer0, Integer1, Result) */
+
+		return (integer0 ^ integer1);
+
+	case AML_MULTIPLY_OP:	/* Multiply (Integer0, Integer1, Result) */
+
+		return (integer0 * integer1);
+
+	case AML_SHIFT_LEFT_OP:	/* shift_left (Operand, shift_count, Result) */
+
+		/*
+		 * We need to check if the shiftcount is larger than the integer bit
+		 * width since the behavior of this is not well-defined in the C language.
+		 */
+		if (integer1 >= acpi_gbl_integer_bit_width) {
+			return (0);
+		}
+		return (integer0 << integer1);
+
+	case AML_SHIFT_RIGHT_OP:	/* shift_right (Operand, shift_count, Result) */
+
+		/*
+		 * We need to check if the shiftcount is larger than the integer bit
+		 * width since the behavior of this is not well-defined in the C language.
+		 */
+		if (integer1 >= acpi_gbl_integer_bit_width) {
+			return (0);
+		}
+		return (integer0 >> integer1);
+
+	case AML_SUBTRACT_OP:	/* Subtract (Integer0, Integer1, Result) */
+
+		return (integer0 - integer1);
+
+	default:
+
+		return (0);
+	}
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_do_logical_numeric_op
+ *
+ * PARAMETERS:  Opcode              - AML opcode
+ *              Integer0            - Integer operand #0
+ *              Integer1            - Integer operand #1
+ *              logical_result      - TRUE/FALSE result of the operation
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Execute a logical "Numeric" AML opcode. For these Numeric
+ *              operators (LAnd and LOr), both operands must be integers.
+ *
+ *              Note: cleanest machine code seems to be produced by the code
+ *              below, rather than using statements of the form:
+ *                  Result = (Integer0 && Integer1);
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ex_do_logical_numeric_op(u16 opcode,
+			      u64 integer0, u64 integer1, u8 *logical_result)
+{
+	acpi_status status = AE_OK;
+	u8 local_result = FALSE;
+
+	ACPI_FUNCTION_TRACE(ex_do_logical_numeric_op);
+
+	switch (opcode) {
+	case AML_LAND_OP:	/* LAnd (Integer0, Integer1) */
+
+		if (integer0 && integer1) {
+			local_result = TRUE;
+		}
+		break;
+
+	case AML_LOR_OP:	/* LOr (Integer0, Integer1) */
+
+		if (integer0 || integer1) {
+			local_result = TRUE;
+		}
+		break;
+
+	default:
+		status = AE_AML_INTERNAL;
+		break;
+	}
+
+	/* Return the logical result and status */
+
+	*logical_result = local_result;
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_do_logical_op
+ *
+ * PARAMETERS:  Opcode              - AML opcode
+ *              Operand0            - operand #0
+ *              Operand1            - operand #1
+ *              logical_result      - TRUE/FALSE result of the operation
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Execute a logical AML opcode. The purpose of having all of the
+ *              functions here is to prevent a lot of pointer dereferencing
+ *              to obtain the operands and to simplify the generation of the
+ *              logical value. For the Numeric operators (LAnd and LOr), both
+ *              operands must be integers. For the other logical operators,
+ *              operands can be any combination of Integer/String/Buffer. The
+ *              first operand determines the type to which the second operand
+ *              will be converted.
+ *
+ *              Note: cleanest machine code seems to be produced by the code
+ *              below, rather than using statements of the form:
+ *                  Result = (Operand0 == Operand1);
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ex_do_logical_op(u16 opcode,
+		      union acpi_operand_object *operand0,
+		      union acpi_operand_object *operand1, u8 *logical_result)
+{
+	union acpi_operand_object *local_operand1 = operand1;
+	u64 integer0;
+	u64 integer1;
+	u32 length0;
+	u32 length1;
+	acpi_status status = AE_OK;
+	u8 local_result = FALSE;
+	int compare;
+
+	ACPI_FUNCTION_TRACE(ex_do_logical_op);
+
+	/*
+	 * Convert the second operand if necessary.  The first operand
+	 * determines the type of the second operand, (See the Data Types
+	 * section of the ACPI 3.0+ specification.)  Both object types are
+	 * guaranteed to be either Integer/String/Buffer by the operand
+	 * resolution mechanism.
+	 */
+	switch (operand0->common.type) {
+	case ACPI_TYPE_INTEGER:
+		status =
+		    acpi_ex_convert_to_integer(operand1, &local_operand1, 16);
+		break;
+
+	case ACPI_TYPE_STRING:
+		status = acpi_ex_convert_to_string(operand1, &local_operand1,
+						   ACPI_IMPLICIT_CONVERT_HEX);
+		break;
+
+	case ACPI_TYPE_BUFFER:
+		status = acpi_ex_convert_to_buffer(operand1, &local_operand1);
+		break;
+
+	default:
+		status = AE_AML_INTERNAL;
+		break;
+	}
+
+	if (ACPI_FAILURE(status)) {
+		goto cleanup;
+	}
+
+	/*
+	 * Two cases: 1) Both Integers, 2) Both Strings or Buffers
+	 */
+	if (operand0->common.type == ACPI_TYPE_INTEGER) {
+		/*
+		 * 1) Both operands are of type integer
+		 *    Note: local_operand1 may have changed above
+		 */
+		integer0 = operand0->integer.value;
+		integer1 = local_operand1->integer.value;
+
+		switch (opcode) {
+		case AML_LEQUAL_OP:	/* LEqual (Operand0, Operand1) */
+
+			if (integer0 == integer1) {
+				local_result = TRUE;
+			}
+			break;
+
+		case AML_LGREATER_OP:	/* LGreater (Operand0, Operand1) */
+
+			if (integer0 > integer1) {
+				local_result = TRUE;
+			}
+			break;
+
+		case AML_LLESS_OP:	/* LLess (Operand0, Operand1) */
+
+			if (integer0 < integer1) {
+				local_result = TRUE;
+			}
+			break;
+
+		default:
+			status = AE_AML_INTERNAL;
+			break;
+		}
+	} else {
+		/*
+		 * 2) Both operands are Strings or both are Buffers
+		 *    Note: Code below takes advantage of common Buffer/String
+		 *          object fields. local_operand1 may have changed above. Use
+		 *          memcmp to handle nulls in buffers.
+		 */
+		length0 = operand0->buffer.length;
+		length1 = local_operand1->buffer.length;
+
+		/* Lexicographic compare: compare the data bytes */
+
+		compare = ACPI_MEMCMP(operand0->buffer.pointer,
+				      local_operand1->buffer.pointer,
+				      (length0 > length1) ? length1 : length0);
+
+		switch (opcode) {
+		case AML_LEQUAL_OP:	/* LEqual (Operand0, Operand1) */
+
+			/* Length and all bytes must be equal */
+
+			if ((length0 == length1) && (compare == 0)) {
+
+				/* Length and all bytes match ==> TRUE */
+
+				local_result = TRUE;
+			}
+			break;
+
+		case AML_LGREATER_OP:	/* LGreater (Operand0, Operand1) */
+
+			if (compare > 0) {
+				local_result = TRUE;
+				goto cleanup;	/* TRUE */
+			}
+			if (compare < 0) {
+				goto cleanup;	/* FALSE */
+			}
+
+			/* Bytes match (to shortest length), compare lengths */
+
+			if (length0 > length1) {
+				local_result = TRUE;
+			}
+			break;
+
+		case AML_LLESS_OP:	/* LLess (Operand0, Operand1) */
+
+			if (compare > 0) {
+				goto cleanup;	/* FALSE */
+			}
+			if (compare < 0) {
+				local_result = TRUE;
+				goto cleanup;	/* TRUE */
+			}
+
+			/* Bytes match (to shortest length), compare lengths */
+
+			if (length0 < length1) {
+				local_result = TRUE;
+			}
+			break;
+
+		default:
+			status = AE_AML_INTERNAL;
+			break;
+		}
+	}
+
+      cleanup:
+
+	/* New object was created if implicit conversion performed - delete */
+
+	if (local_operand1 != operand1) {
+		acpi_ut_remove_reference(local_operand1);
+	}
+
+	/* Return the logical result and status */
+
+	*logical_result = local_result;
+	return_ACPI_STATUS(status);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exmutex.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exmutex.c
new file mode 100644
index 00000000..98e49df5
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exmutex.c
@@ -0,0 +1,499 @@
+
+/******************************************************************************
+ *
+ * Module Name: exmutex - ASL Mutex Acquire/Release functions
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acinterp.h"
+#include "acevents.h"
+
+#define _COMPONENT          ACPI_EXECUTER
+ACPI_MODULE_NAME("exmutex")
+
+/* Local prototypes */
+static void
+acpi_ex_link_mutex(union acpi_operand_object *obj_desc,
+		   struct acpi_thread_state *thread);
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_unlink_mutex
+ *
+ * PARAMETERS:  obj_desc            - The mutex to be unlinked
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Remove a mutex from the "AcquiredMutex" list
+ *
+ ******************************************************************************/
+
+void acpi_ex_unlink_mutex(union acpi_operand_object *obj_desc)
+{
+	struct acpi_thread_state *thread = obj_desc->mutex.owner_thread;
+
+	if (!thread) {
+		return;
+	}
+
+	/* Doubly linked list */
+
+	if (obj_desc->mutex.next) {
+		(obj_desc->mutex.next)->mutex.prev = obj_desc->mutex.prev;
+	}
+
+	if (obj_desc->mutex.prev) {
+		(obj_desc->mutex.prev)->mutex.next = obj_desc->mutex.next;
+
+		/*
+		 * Migrate the previous sync level associated with this mutex to
+		 * the previous mutex on the list so that it may be preserved.
+		 * This handles the case where several mutexes have been acquired
+		 * at the same level, but are not released in opposite order.
+		 */
+		(obj_desc->mutex.prev)->mutex.original_sync_level =
+		    obj_desc->mutex.original_sync_level;
+	} else {
+		thread->acquired_mutex_list = obj_desc->mutex.next;
+	}
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_link_mutex
+ *
+ * PARAMETERS:  obj_desc            - The mutex to be linked
+ *              Thread              - Current executing thread object
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Add a mutex to the "AcquiredMutex" list for this walk
+ *
+ ******************************************************************************/
+
+static void
+acpi_ex_link_mutex(union acpi_operand_object *obj_desc,
+		   struct acpi_thread_state *thread)
+{
+	union acpi_operand_object *list_head;
+
+	list_head = thread->acquired_mutex_list;
+
+	/* This object will be the first object in the list */
+
+	obj_desc->mutex.prev = NULL;
+	obj_desc->mutex.next = list_head;
+
+	/* Update old first object to point back to this object */
+
+	if (list_head) {
+		list_head->mutex.prev = obj_desc;
+	}
+
+	/* Update list head */
+
+	thread->acquired_mutex_list = obj_desc;
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_acquire_mutex_object
+ *
+ * PARAMETERS:  Timeout             - Timeout in milliseconds
+ *              obj_desc            - Mutex object
+ *              thread_id           - Current thread state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Acquire an AML mutex, low-level interface. Provides a common
+ *              path that supports multiple acquires by the same thread.
+ *
+ * MUTEX:       Interpreter must be locked
+ *
+ * NOTE: This interface is called from three places:
+ * 1) From acpi_ex_acquire_mutex, via an AML Acquire() operator
+ * 2) From acpi_ex_acquire_global_lock when an AML Field access requires the
+ *    global lock
+ * 3) From the external interface, acpi_acquire_global_lock
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ex_acquire_mutex_object(u16 timeout,
+			     union acpi_operand_object *obj_desc,
+			     acpi_thread_id thread_id)
+{
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE_PTR(ex_acquire_mutex_object, obj_desc);
+
+	if (!obj_desc) {
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	/* Support for multiple acquires by the owning thread */
+
+	if (obj_desc->mutex.thread_id == thread_id) {
+		/*
+		 * The mutex is already owned by this thread, just increment the
+		 * acquisition depth
+		 */
+		obj_desc->mutex.acquisition_depth++;
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	/* Acquire the mutex, wait if necessary. Special case for Global Lock */
+
+	if (obj_desc == acpi_gbl_global_lock_mutex) {
+		status = acpi_ev_acquire_global_lock(timeout);
+	} else {
+		status = acpi_ex_system_wait_mutex(obj_desc->mutex.os_mutex,
+						   timeout);
+	}
+
+	if (ACPI_FAILURE(status)) {
+
+		/* Includes failure from a timeout on time_desc */
+
+		return_ACPI_STATUS(status);
+	}
+
+	/* Acquired the mutex: update mutex object */
+
+	obj_desc->mutex.thread_id = thread_id;
+	obj_desc->mutex.acquisition_depth = 1;
+	obj_desc->mutex.original_sync_level = 0;
+	obj_desc->mutex.owner_thread = NULL;	/* Used only for AML Acquire() */
+
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_acquire_mutex
+ *
+ * PARAMETERS:  time_desc           - Timeout integer
+ *              obj_desc            - Mutex object
+ *              walk_state          - Current method execution state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Acquire an AML mutex
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ex_acquire_mutex(union acpi_operand_object *time_desc,
+		      union acpi_operand_object *obj_desc,
+		      struct acpi_walk_state *walk_state)
+{
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE_PTR(ex_acquire_mutex, obj_desc);
+
+	if (!obj_desc) {
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	/* Must have a valid thread state struct */
+
+	if (!walk_state->thread) {
+		ACPI_ERROR((AE_INFO,
+			    "Cannot acquire Mutex [%4.4s], null thread info",
+			    acpi_ut_get_node_name(obj_desc->mutex.node)));
+		return_ACPI_STATUS(AE_AML_INTERNAL);
+	}
+
+	/*
+	 * Current sync level must be less than or equal to the sync level of the
+	 * mutex. This mechanism provides some deadlock prevention
+	 */
+	if (walk_state->thread->current_sync_level > obj_desc->mutex.sync_level) {
+		ACPI_ERROR((AE_INFO,
+			    "Cannot acquire Mutex [%4.4s], current SyncLevel is too large (%u)",
+			    acpi_ut_get_node_name(obj_desc->mutex.node),
+			    walk_state->thread->current_sync_level));
+		return_ACPI_STATUS(AE_AML_MUTEX_ORDER);
+	}
+
+	status = acpi_ex_acquire_mutex_object((u16)time_desc->integer.value,
+					      obj_desc,
+					      walk_state->thread->thread_id);
+	if (ACPI_SUCCESS(status) && obj_desc->mutex.acquisition_depth == 1) {
+
+		/* Save Thread object, original/current sync levels */
+
+		obj_desc->mutex.owner_thread = walk_state->thread;
+		obj_desc->mutex.original_sync_level =
+		    walk_state->thread->current_sync_level;
+		walk_state->thread->current_sync_level =
+		    obj_desc->mutex.sync_level;
+
+		/* Link the mutex to the current thread for force-unlock at method exit */
+
+		acpi_ex_link_mutex(obj_desc, walk_state->thread);
+	}
+
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_release_mutex_object
+ *
+ * PARAMETERS:  obj_desc            - The object descriptor for this op
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Release a previously acquired Mutex, low level interface.
+ *              Provides a common path that supports multiple releases (after
+ *              previous multiple acquires) by the same thread.
+ *
+ * MUTEX:       Interpreter must be locked
+ *
+ * NOTE: This interface is called from three places:
+ * 1) From acpi_ex_release_mutex, via an AML Acquire() operator
+ * 2) From acpi_ex_release_global_lock when an AML Field access requires the
+ *    global lock
+ * 3) From the external interface, acpi_release_global_lock
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ex_release_mutex_object(union acpi_operand_object *obj_desc)
+{
+	acpi_status status = AE_OK;
+
+	ACPI_FUNCTION_TRACE(ex_release_mutex_object);
+
+	if (obj_desc->mutex.acquisition_depth == 0) {
+		return (AE_NOT_ACQUIRED);
+	}
+
+	/* Match multiple Acquires with multiple Releases */
+
+	obj_desc->mutex.acquisition_depth--;
+	if (obj_desc->mutex.acquisition_depth != 0) {
+
+		/* Just decrement the depth and return */
+
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	if (obj_desc->mutex.owner_thread) {
+
+		/* Unlink the mutex from the owner's list */
+
+		acpi_ex_unlink_mutex(obj_desc);
+		obj_desc->mutex.owner_thread = NULL;
+	}
+
+	/* Release the mutex, special case for Global Lock */
+
+	if (obj_desc == acpi_gbl_global_lock_mutex) {
+		status = acpi_ev_release_global_lock();
+	} else {
+		acpi_os_release_mutex(obj_desc->mutex.os_mutex);
+	}
+
+	/* Clear mutex info */
+
+	obj_desc->mutex.thread_id = 0;
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_release_mutex
+ *
+ * PARAMETERS:  obj_desc            - The object descriptor for this op
+ *              walk_state          - Current method execution state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Release a previously acquired Mutex.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ex_release_mutex(union acpi_operand_object *obj_desc,
+		      struct acpi_walk_state *walk_state)
+{
+	acpi_status status = AE_OK;
+	u8 previous_sync_level;
+	struct acpi_thread_state *owner_thread;
+
+	ACPI_FUNCTION_TRACE(ex_release_mutex);
+
+	if (!obj_desc) {
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	owner_thread = obj_desc->mutex.owner_thread;
+
+	/* The mutex must have been previously acquired in order to release it */
+
+	if (!owner_thread) {
+		ACPI_ERROR((AE_INFO,
+			    "Cannot release Mutex [%4.4s], not acquired",
+			    acpi_ut_get_node_name(obj_desc->mutex.node)));
+		return_ACPI_STATUS(AE_AML_MUTEX_NOT_ACQUIRED);
+	}
+
+	/* Must have a valid thread ID */
+
+	if (!walk_state->thread) {
+		ACPI_ERROR((AE_INFO,
+			    "Cannot release Mutex [%4.4s], null thread info",
+			    acpi_ut_get_node_name(obj_desc->mutex.node)));
+		return_ACPI_STATUS(AE_AML_INTERNAL);
+	}
+
+	/*
+	 * The Mutex is owned, but this thread must be the owner.
+	 * Special case for Global Lock, any thread can release
+	 */
+	if ((owner_thread->thread_id != walk_state->thread->thread_id) &&
+	    (obj_desc != acpi_gbl_global_lock_mutex)) {
+		ACPI_ERROR((AE_INFO,
+			    "Thread %u cannot release Mutex [%4.4s] acquired by thread %u",
+			    (u32)walk_state->thread->thread_id,
+			    acpi_ut_get_node_name(obj_desc->mutex.node),
+			    (u32)owner_thread->thread_id));
+		return_ACPI_STATUS(AE_AML_NOT_OWNER);
+	}
+
+	/*
+	 * The sync level of the mutex must be equal to the current sync level. In
+	 * other words, the current level means that at least one mutex at that
+	 * level is currently being held. Attempting to release a mutex of a
+	 * different level can only mean that the mutex ordering rule is being
+	 * violated. This behavior is clarified in ACPI 4.0 specification.
+	 */
+	if (obj_desc->mutex.sync_level != owner_thread->current_sync_level) {
+		ACPI_ERROR((AE_INFO,
+			    "Cannot release Mutex [%4.4s], SyncLevel mismatch: mutex %u current %u",
+			    acpi_ut_get_node_name(obj_desc->mutex.node),
+			    obj_desc->mutex.sync_level,
+			    walk_state->thread->current_sync_level));
+		return_ACPI_STATUS(AE_AML_MUTEX_ORDER);
+	}
+
+	/*
+	 * Get the previous sync_level from the head of the acquired mutex list.
+	 * This handles the case where several mutexes at the same level have been
+	 * acquired, but are not released in reverse order.
+	 */
+	previous_sync_level =
+	    owner_thread->acquired_mutex_list->mutex.original_sync_level;
+
+	status = acpi_ex_release_mutex_object(obj_desc);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	if (obj_desc->mutex.acquisition_depth == 0) {
+
+		/* Restore the previous sync_level */
+
+		owner_thread->current_sync_level = previous_sync_level;
+	}
+
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_release_all_mutexes
+ *
+ * PARAMETERS:  Thread              - Current executing thread object
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Release all mutexes held by this thread
+ *
+ * NOTE: This function is called as the thread is exiting the interpreter.
+ * Mutexes are not released when an individual control method is exited, but
+ * only when the parent thread actually exits the interpreter. This allows one
+ * method to acquire a mutex, and a different method to release it, as long as
+ * this is performed underneath a single parent control method.
+ *
+ ******************************************************************************/
+
+void acpi_ex_release_all_mutexes(struct acpi_thread_state *thread)
+{
+	union acpi_operand_object *next = thread->acquired_mutex_list;
+	union acpi_operand_object *obj_desc;
+
+	ACPI_FUNCTION_ENTRY();
+
+	/* Traverse the list of owned mutexes, releasing each one */
+
+	while (next) {
+		obj_desc = next;
+		next = obj_desc->mutex.next;
+
+		obj_desc->mutex.prev = NULL;
+		obj_desc->mutex.next = NULL;
+		obj_desc->mutex.acquisition_depth = 0;
+
+		/* Release the mutex, special case for Global Lock */
+
+		if (obj_desc == acpi_gbl_global_lock_mutex) {
+
+			/* Ignore errors */
+
+			(void)acpi_ev_release_global_lock();
+		} else {
+			acpi_os_release_mutex(obj_desc->mutex.os_mutex);
+		}
+
+		/* Mark mutex unowned */
+
+		obj_desc->mutex.owner_thread = NULL;
+		obj_desc->mutex.thread_id = 0;
+
+		/* Update Thread sync_level (Last mutex is the important one) */
+
+		thread->current_sync_level =
+		    obj_desc->mutex.original_sync_level;
+	}
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exnames.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exnames.c
new file mode 100644
index 00000000..a0353009
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exnames.c
@@ -0,0 +1,436 @@
+
+/******************************************************************************
+ *
+ * Module Name: exnames - interpreter/scanner name load/execute
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acinterp.h"
+#include "amlcode.h"
+
+#define _COMPONENT          ACPI_EXECUTER
+ACPI_MODULE_NAME("exnames")
+
+/* Local prototypes */
+static char *acpi_ex_allocate_name_string(u32 prefix_count, u32 num_name_segs);
+
+static acpi_status acpi_ex_name_segment(u8 **in_aml_address, char *name_string);
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_allocate_name_string
+ *
+ * PARAMETERS:  prefix_count        - Count of parent levels. Special cases:
+ *                                    (-1)==root,  0==none
+ *              num_name_segs       - count of 4-character name segments
+ *
+ * RETURN:      A pointer to the allocated string segment.  This segment must
+ *              be deleted by the caller.
+ *
+ * DESCRIPTION: Allocate a buffer for a name string. Ensure allocated name
+ *              string is long enough, and set up prefix if any.
+ *
+ ******************************************************************************/
+
+static char *acpi_ex_allocate_name_string(u32 prefix_count, u32 num_name_segs)
+{
+	char *temp_ptr;
+	char *name_string;
+	u32 size_needed;
+
+	ACPI_FUNCTION_TRACE(ex_allocate_name_string);
+
+	/*
+	 * Allow room for all \ and ^ prefixes, all segments and a multi_name_prefix.
+	 * Also, one byte for the null terminator.
+	 * This may actually be somewhat longer than needed.
+	 */
+	if (prefix_count == ACPI_UINT32_MAX) {
+
+		/* Special case for root */
+
+		size_needed = 1 + (ACPI_NAME_SIZE * num_name_segs) + 2 + 1;
+	} else {
+		size_needed =
+		    prefix_count + (ACPI_NAME_SIZE * num_name_segs) + 2 + 1;
+	}
+
+	/*
+	 * Allocate a buffer for the name.
+	 * This buffer must be deleted by the caller!
+	 */
+	name_string = ACPI_ALLOCATE(size_needed);
+	if (!name_string) {
+		ACPI_ERROR((AE_INFO,
+			    "Could not allocate size %u", size_needed));
+		return_PTR(NULL);
+	}
+
+	temp_ptr = name_string;
+
+	/* Set up Root or Parent prefixes if needed */
+
+	if (prefix_count == ACPI_UINT32_MAX) {
+		*temp_ptr++ = AML_ROOT_PREFIX;
+	} else {
+		while (prefix_count--) {
+			*temp_ptr++ = AML_PARENT_PREFIX;
+		}
+	}
+
+	/* Set up Dual or Multi prefixes if needed */
+
+	if (num_name_segs > 2) {
+
+		/* Set up multi prefixes   */
+
+		*temp_ptr++ = AML_MULTI_NAME_PREFIX_OP;
+		*temp_ptr++ = (char)num_name_segs;
+	} else if (2 == num_name_segs) {
+
+		/* Set up dual prefixes */
+
+		*temp_ptr++ = AML_DUAL_NAME_PREFIX;
+	}
+
+	/*
+	 * Terminate string following prefixes. acpi_ex_name_segment() will
+	 * append the segment(s)
+	 */
+	*temp_ptr = 0;
+
+	return_PTR(name_string);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_name_segment
+ *
+ * PARAMETERS:  in_aml_address  - Pointer to the name in the AML code
+ *              name_string     - Where to return the name. The name is appended
+ *                                to any existing string to form a namepath
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Extract an ACPI name (4 bytes) from the AML byte stream
+ *
+ ******************************************************************************/
+
+static acpi_status acpi_ex_name_segment(u8 **in_aml_address, char *name_string)
+{
+	char *aml_address = (void *)*in_aml_address;
+	acpi_status status = AE_OK;
+	u32 index;
+	char char_buf[5];
+
+	ACPI_FUNCTION_TRACE(ex_name_segment);
+
+	/*
+	 * If first character is a digit, then we know that we aren't looking at a
+	 * valid name segment
+	 */
+	char_buf[0] = *aml_address;
+
+	if ('0' <= char_buf[0] && char_buf[0] <= '9') {
+		ACPI_ERROR((AE_INFO, "Invalid leading digit: %c", char_buf[0]));
+		return_ACPI_STATUS(AE_CTRL_PENDING);
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_LOAD, "Bytes from stream:\n"));
+
+	for (index = 0;
+	     (index < ACPI_NAME_SIZE)
+	     && (acpi_ut_valid_acpi_char(*aml_address, 0)); index++) {
+		char_buf[index] = *aml_address++;
+		ACPI_DEBUG_PRINT((ACPI_DB_LOAD, "%c\n", char_buf[index]));
+	}
+
+	/* Valid name segment  */
+
+	if (index == 4) {
+
+		/* Found 4 valid characters */
+
+		char_buf[4] = '\0';
+
+		if (name_string) {
+			ACPI_STRCAT(name_string, char_buf);
+			ACPI_DEBUG_PRINT((ACPI_DB_NAMES,
+					  "Appended to - %s\n", name_string));
+		} else {
+			ACPI_DEBUG_PRINT((ACPI_DB_NAMES,
+					  "No Name string - %s\n", char_buf));
+		}
+	} else if (index == 0) {
+		/*
+		 * First character was not a valid name character,
+		 * so we are looking at something other than a name.
+		 */
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+				  "Leading character is not alpha: %02Xh (not a name)\n",
+				  char_buf[0]));
+		status = AE_CTRL_PENDING;
+	} else {
+		/*
+		 * Segment started with one or more valid characters, but fewer than
+		 * the required 4
+		 */
+		status = AE_AML_BAD_NAME;
+		ACPI_ERROR((AE_INFO,
+			    "Bad character 0x%02x in name, at %p",
+			    *aml_address, aml_address));
+	}
+
+	*in_aml_address = ACPI_CAST_PTR(u8, aml_address);
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_get_name_string
+ *
+ * PARAMETERS:  data_type           - Object type to be associated with this
+ *                                    name
+ *              in_aml_address      - Pointer to the namestring in the AML code
+ *              out_name_string     - Where the namestring is returned
+ *              out_name_length     - Length of the returned string
+ *
+ * RETURN:      Status, namestring and length
+ *
+ * DESCRIPTION: Extract a full namepath from the AML byte stream,
+ *              including any prefixes.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ex_get_name_string(acpi_object_type data_type,
+			u8 *in_aml_address,
+			char **out_name_string, u32 *out_name_length)
+{
+	acpi_status status = AE_OK;
+	u8 *aml_address = in_aml_address;
+	char *name_string = NULL;
+	u32 num_segments;
+	u32 prefix_count = 0;
+	u8 has_prefix = FALSE;
+
+	ACPI_FUNCTION_TRACE_PTR(ex_get_name_string, aml_address);
+
+	if (ACPI_TYPE_LOCAL_REGION_FIELD == data_type ||
+	    ACPI_TYPE_LOCAL_BANK_FIELD == data_type ||
+	    ACPI_TYPE_LOCAL_INDEX_FIELD == data_type) {
+
+		/* Disallow prefixes for types associated with field_unit names */
+
+		name_string = acpi_ex_allocate_name_string(0, 1);
+		if (!name_string) {
+			status = AE_NO_MEMORY;
+		} else {
+			status =
+			    acpi_ex_name_segment(&aml_address, name_string);
+		}
+	} else {
+		/*
+		 * data_type is not a field name.
+		 * Examine first character of name for root or parent prefix operators
+		 */
+		switch (*aml_address) {
+		case AML_ROOT_PREFIX:
+
+			ACPI_DEBUG_PRINT((ACPI_DB_LOAD,
+					  "RootPrefix(\\) at %p\n",
+					  aml_address));
+
+			/*
+			 * Remember that we have a root_prefix --
+			 * see comment in acpi_ex_allocate_name_string()
+			 */
+			aml_address++;
+			prefix_count = ACPI_UINT32_MAX;
+			has_prefix = TRUE;
+			break;
+
+		case AML_PARENT_PREFIX:
+
+			/* Increment past possibly multiple parent prefixes */
+
+			do {
+				ACPI_DEBUG_PRINT((ACPI_DB_LOAD,
+						  "ParentPrefix (^) at %p\n",
+						  aml_address));
+
+				aml_address++;
+				prefix_count++;
+
+			} while (*aml_address == AML_PARENT_PREFIX);
+
+			has_prefix = TRUE;
+			break;
+
+		default:
+
+			/* Not a prefix character */
+
+			break;
+		}
+
+		/* Examine first character of name for name segment prefix operator */
+
+		switch (*aml_address) {
+		case AML_DUAL_NAME_PREFIX:
+
+			ACPI_DEBUG_PRINT((ACPI_DB_LOAD,
+					  "DualNamePrefix at %p\n",
+					  aml_address));
+
+			aml_address++;
+			name_string =
+			    acpi_ex_allocate_name_string(prefix_count, 2);
+			if (!name_string) {
+				status = AE_NO_MEMORY;
+				break;
+			}
+
+			/* Indicate that we processed a prefix */
+
+			has_prefix = TRUE;
+
+			status =
+			    acpi_ex_name_segment(&aml_address, name_string);
+			if (ACPI_SUCCESS(status)) {
+				status =
+				    acpi_ex_name_segment(&aml_address,
+							 name_string);
+			}
+			break;
+
+		case AML_MULTI_NAME_PREFIX_OP:
+
+			ACPI_DEBUG_PRINT((ACPI_DB_LOAD,
+					  "MultiNamePrefix at %p\n",
+					  aml_address));
+
+			/* Fetch count of segments remaining in name path */
+
+			aml_address++;
+			num_segments = *aml_address;
+
+			name_string =
+			    acpi_ex_allocate_name_string(prefix_count,
+							 num_segments);
+			if (!name_string) {
+				status = AE_NO_MEMORY;
+				break;
+			}
+
+			/* Indicate that we processed a prefix */
+
+			aml_address++;
+			has_prefix = TRUE;
+
+			while (num_segments &&
+			       (status =
+				acpi_ex_name_segment(&aml_address,
+						     name_string)) == AE_OK) {
+				num_segments--;
+			}
+
+			break;
+
+		case 0:
+
+			/* null_name valid as of 8-12-98 ASL/AML Grammar Update */
+
+			if (prefix_count == ACPI_UINT32_MAX) {
+				ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
+						  "NameSeg is \"\\\" followed by NULL\n"));
+			}
+
+			/* Consume the NULL byte */
+
+			aml_address++;
+			name_string =
+			    acpi_ex_allocate_name_string(prefix_count, 0);
+			if (!name_string) {
+				status = AE_NO_MEMORY;
+				break;
+			}
+
+			break;
+
+		default:
+
+			/* Name segment string */
+
+			name_string =
+			    acpi_ex_allocate_name_string(prefix_count, 1);
+			if (!name_string) {
+				status = AE_NO_MEMORY;
+				break;
+			}
+
+			status =
+			    acpi_ex_name_segment(&aml_address, name_string);
+			break;
+		}
+	}
+
+	if (AE_CTRL_PENDING == status && has_prefix) {
+
+		/* Ran out of segments after processing a prefix */
+
+		ACPI_ERROR((AE_INFO, "Malformed Name at %p", name_string));
+		status = AE_AML_BAD_NAME;
+	}
+
+	if (ACPI_FAILURE(status)) {
+		if (name_string) {
+			ACPI_FREE(name_string);
+		}
+		return_ACPI_STATUS(status);
+	}
+
+	*out_name_string = name_string;
+	*out_name_length = (u32)(aml_address - in_aml_address);
+
+	return_ACPI_STATUS(status);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exoparg1.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exoparg1.c
new file mode 100644
index 00000000..fe650189
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exoparg1.c
@@ -0,0 +1,1037 @@
+
+/******************************************************************************
+ *
+ * Module Name: exoparg1 - AML execution - opcodes with 1 argument
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acparser.h"
+#include "acdispat.h"
+#include "acinterp.h"
+#include "amlcode.h"
+#include "acnamesp.h"
+
+#define _COMPONENT          ACPI_EXECUTER
+ACPI_MODULE_NAME("exoparg1")
+
+/*!
+ * Naming convention for AML interpreter execution routines.
+ *
+ * The routines that begin execution of AML opcodes are named with a common
+ * convention based upon the number of arguments, the number of target operands,
+ * and whether or not a value is returned:
+ *
+ *      AcpiExOpcode_xA_yT_zR
+ *
+ * Where:
+ *
+ * xA - ARGUMENTS:    The number of arguments (input operands) that are
+ *                    required for this opcode type (0 through 6 args).
+ * yT - TARGETS:      The number of targets (output operands) that are required
+ *                    for this opcode type (0, 1, or 2 targets).
+ * zR - RETURN VALUE: Indicates whether this opcode type returns a value
+ *                    as the function return (0 or 1).
+ *
+ * The AcpiExOpcode* functions are called via the Dispatcher component with
+ * fully resolved operands.
+!*/
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_opcode_0A_0T_1R
+ *
+ * PARAMETERS:  walk_state          - Current state (contains AML opcode)
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Execute operator with no operands, one return value
+ *
+ ******************************************************************************/
+acpi_status acpi_ex_opcode_0A_0T_1R(struct acpi_walk_state *walk_state)
+{
+	acpi_status status = AE_OK;
+	union acpi_operand_object *return_desc = NULL;
+
+	ACPI_FUNCTION_TRACE_STR(ex_opcode_0A_0T_1R,
+				acpi_ps_get_opcode_name(walk_state->opcode));
+
+	/* Examine the AML opcode */
+
+	switch (walk_state->opcode) {
+	case AML_TIMER_OP:	/*  Timer () */
+
+		/* Create a return object of type Integer */
+
+		return_desc =
+		    acpi_ut_create_integer_object(acpi_os_get_timer());
+		if (!return_desc) {
+			status = AE_NO_MEMORY;
+			goto cleanup;
+		}
+		break;
+
+	default:		/*  Unknown opcode  */
+
+		ACPI_ERROR((AE_INFO, "Unknown AML opcode 0x%X",
+			    walk_state->opcode));
+		status = AE_AML_BAD_OPCODE;
+		break;
+	}
+
+      cleanup:
+
+	/* Delete return object on error */
+
+	if ((ACPI_FAILURE(status)) || walk_state->result_obj) {
+		acpi_ut_remove_reference(return_desc);
+		walk_state->result_obj = NULL;
+	} else {
+		/* Save the return value */
+
+		walk_state->result_obj = return_desc;
+	}
+
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_opcode_1A_0T_0R
+ *
+ * PARAMETERS:  walk_state          - Current state (contains AML opcode)
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Execute Type 1 monadic operator with numeric operand on
+ *              object stack
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ex_opcode_1A_0T_0R(struct acpi_walk_state *walk_state)
+{
+	union acpi_operand_object **operand = &walk_state->operands[0];
+	acpi_status status = AE_OK;
+
+	ACPI_FUNCTION_TRACE_STR(ex_opcode_1A_0T_0R,
+				acpi_ps_get_opcode_name(walk_state->opcode));
+
+	/* Examine the AML opcode */
+
+	switch (walk_state->opcode) {
+	case AML_RELEASE_OP:	/*  Release (mutex_object) */
+
+		status = acpi_ex_release_mutex(operand[0], walk_state);
+		break;
+
+	case AML_RESET_OP:	/*  Reset (event_object) */
+
+		status = acpi_ex_system_reset_event(operand[0]);
+		break;
+
+	case AML_SIGNAL_OP:	/*  Signal (event_object) */
+
+		status = acpi_ex_system_signal_event(operand[0]);
+		break;
+
+	case AML_SLEEP_OP:	/*  Sleep (msec_time) */
+
+		status = acpi_ex_system_do_sleep(operand[0]->integer.value);
+		break;
+
+	case AML_STALL_OP:	/*  Stall (usec_time) */
+
+		status =
+		    acpi_ex_system_do_stall((u32)operand[0]->integer.value);
+		break;
+
+	case AML_UNLOAD_OP:	/*  Unload (Handle) */
+
+		status = acpi_ex_unload_table(operand[0]);
+		break;
+
+	default:		/*  Unknown opcode  */
+
+		ACPI_ERROR((AE_INFO, "Unknown AML opcode 0x%X",
+			    walk_state->opcode));
+		status = AE_AML_BAD_OPCODE;
+		break;
+	}
+
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_opcode_1A_1T_0R
+ *
+ * PARAMETERS:  walk_state          - Current state (contains AML opcode)
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Execute opcode with one argument, one target, and no
+ *              return value.
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ex_opcode_1A_1T_0R(struct acpi_walk_state *walk_state)
+{
+	acpi_status status = AE_OK;
+	union acpi_operand_object **operand = &walk_state->operands[0];
+
+	ACPI_FUNCTION_TRACE_STR(ex_opcode_1A_1T_0R,
+				acpi_ps_get_opcode_name(walk_state->opcode));
+
+	/* Examine the AML opcode */
+
+	switch (walk_state->opcode) {
+	case AML_LOAD_OP:
+
+		status = acpi_ex_load_op(operand[0], operand[1], walk_state);
+		break;
+
+	default:		/* Unknown opcode */
+
+		ACPI_ERROR((AE_INFO, "Unknown AML opcode 0x%X",
+			    walk_state->opcode));
+		status = AE_AML_BAD_OPCODE;
+		goto cleanup;
+	}
+
+      cleanup:
+
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_opcode_1A_1T_1R
+ *
+ * PARAMETERS:  walk_state          - Current state (contains AML opcode)
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Execute opcode with one argument, one target, and a
+ *              return value.
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ex_opcode_1A_1T_1R(struct acpi_walk_state *walk_state)
+{
+	acpi_status status = AE_OK;
+	union acpi_operand_object **operand = &walk_state->operands[0];
+	union acpi_operand_object *return_desc = NULL;
+	union acpi_operand_object *return_desc2 = NULL;
+	u32 temp32;
+	u32 i;
+	u64 power_of_ten;
+	u64 digit;
+
+	ACPI_FUNCTION_TRACE_STR(ex_opcode_1A_1T_1R,
+				acpi_ps_get_opcode_name(walk_state->opcode));
+
+	/* Examine the AML opcode */
+
+	switch (walk_state->opcode) {
+	case AML_BIT_NOT_OP:
+	case AML_FIND_SET_LEFT_BIT_OP:
+	case AML_FIND_SET_RIGHT_BIT_OP:
+	case AML_FROM_BCD_OP:
+	case AML_TO_BCD_OP:
+	case AML_COND_REF_OF_OP:
+
+		/* Create a return object of type Integer for these opcodes */
+
+		return_desc = acpi_ut_create_internal_object(ACPI_TYPE_INTEGER);
+		if (!return_desc) {
+			status = AE_NO_MEMORY;
+			goto cleanup;
+		}
+
+		switch (walk_state->opcode) {
+		case AML_BIT_NOT_OP:	/* Not (Operand, Result)  */
+
+			return_desc->integer.value = ~operand[0]->integer.value;
+			break;
+
+		case AML_FIND_SET_LEFT_BIT_OP:	/* find_set_left_bit (Operand, Result) */
+
+			return_desc->integer.value = operand[0]->integer.value;
+
+			/*
+			 * Acpi specification describes Integer type as a little
+			 * endian unsigned value, so this boundary condition is valid.
+			 */
+			for (temp32 = 0; return_desc->integer.value &&
+			     temp32 < ACPI_INTEGER_BIT_SIZE; ++temp32) {
+				return_desc->integer.value >>= 1;
+			}
+
+			return_desc->integer.value = temp32;
+			break;
+
+		case AML_FIND_SET_RIGHT_BIT_OP:	/* find_set_right_bit (Operand, Result) */
+
+			return_desc->integer.value = operand[0]->integer.value;
+
+			/*
+			 * The Acpi specification describes Integer type as a little
+			 * endian unsigned value, so this boundary condition is valid.
+			 */
+			for (temp32 = 0; return_desc->integer.value &&
+			     temp32 < ACPI_INTEGER_BIT_SIZE; ++temp32) {
+				return_desc->integer.value <<= 1;
+			}
+
+			/* Since the bit position is one-based, subtract from 33 (65) */
+
+			return_desc->integer.value =
+			    temp32 ==
+			    0 ? 0 : (ACPI_INTEGER_BIT_SIZE + 1) - temp32;
+			break;
+
+		case AML_FROM_BCD_OP:	/* from_bcd (BCDValue, Result) */
+
+			/*
+			 * The 64-bit ACPI integer can hold 16 4-bit BCD characters
+			 * (if table is 32-bit, integer can hold 8 BCD characters)
+			 * Convert each 4-bit BCD value
+			 */
+			power_of_ten = 1;
+			return_desc->integer.value = 0;
+			digit = operand[0]->integer.value;
+
+			/* Convert each BCD digit (each is one nybble wide) */
+
+			for (i = 0;
+			     (i < acpi_gbl_integer_nybble_width) && (digit > 0);
+			     i++) {
+
+				/* Get the least significant 4-bit BCD digit */
+
+				temp32 = ((u32)digit) & 0xF;
+
+				/* Check the range of the digit */
+
+				if (temp32 > 9) {
+					ACPI_ERROR((AE_INFO,
+						    "BCD digit too large (not decimal): 0x%X",
+						    temp32));
+
+					status = AE_AML_NUMERIC_OVERFLOW;
+					goto cleanup;
+				}
+
+				/* Sum the digit into the result with the current power of 10 */
+
+				return_desc->integer.value +=
+				    (((u64)temp32) * power_of_ten);
+
+				/* Shift to next BCD digit */
+
+				digit >>= 4;
+
+				/* Next power of 10 */
+
+				power_of_ten *= 10;
+			}
+			break;
+
+		case AML_TO_BCD_OP:	/* to_bcd (Operand, Result) */
+
+			return_desc->integer.value = 0;
+			digit = operand[0]->integer.value;
+
+			/* Each BCD digit is one nybble wide */
+
+			for (i = 0;
+			     (i < acpi_gbl_integer_nybble_width) && (digit > 0);
+			     i++) {
+				(void)acpi_ut_short_divide(digit, 10, &digit,
+							   &temp32);
+
+				/*
+				 * Insert the BCD digit that resides in the
+				 * remainder from above
+				 */
+				return_desc->integer.value |=
+				    (((u64)temp32) << ACPI_MUL_4(i));
+			}
+
+			/* Overflow if there is any data left in Digit */
+
+			if (digit > 0) {
+				ACPI_ERROR((AE_INFO,
+					    "Integer too large to convert to BCD: 0x%8.8X%8.8X",
+					    ACPI_FORMAT_UINT64(operand[0]->
+							       integer.value)));
+				status = AE_AML_NUMERIC_OVERFLOW;
+				goto cleanup;
+			}
+			break;
+
+		case AML_COND_REF_OF_OP:	/* cond_ref_of (source_object, Result) */
+
+			/*
+			 * This op is a little strange because the internal return value is
+			 * different than the return value stored in the result descriptor
+			 * (There are really two return values)
+			 */
+			if ((struct acpi_namespace_node *)operand[0] ==
+			    acpi_gbl_root_node) {
+				/*
+				 * This means that the object does not exist in the namespace,
+				 * return FALSE
+				 */
+				return_desc->integer.value = 0;
+				goto cleanup;
+			}
+
+			/* Get the object reference, store it, and remove our reference */
+
+			status = acpi_ex_get_object_reference(operand[0],
+							      &return_desc2,
+							      walk_state);
+			if (ACPI_FAILURE(status)) {
+				goto cleanup;
+			}
+
+			status =
+			    acpi_ex_store(return_desc2, operand[1], walk_state);
+			acpi_ut_remove_reference(return_desc2);
+
+			/* The object exists in the namespace, return TRUE */
+
+			return_desc->integer.value = ACPI_UINT64_MAX;
+			goto cleanup;
+
+		default:
+			/* No other opcodes get here */
+			break;
+		}
+		break;
+
+	case AML_STORE_OP:	/* Store (Source, Target) */
+
+		/*
+		 * A store operand is typically a number, string, buffer or lvalue
+		 * Be careful about deleting the source object,
+		 * since the object itself may have been stored.
+		 */
+		status = acpi_ex_store(operand[0], operand[1], walk_state);
+		if (ACPI_FAILURE(status)) {
+			return_ACPI_STATUS(status);
+		}
+
+		/* It is possible that the Store already produced a return object */
+
+		if (!walk_state->result_obj) {
+			/*
+			 * Normally, we would remove a reference on the Operand[0]
+			 * parameter; But since it is being used as the internal return
+			 * object (meaning we would normally increment it), the two
+			 * cancel out, and we simply don't do anything.
+			 */
+			walk_state->result_obj = operand[0];
+			walk_state->operands[0] = NULL;	/* Prevent deletion */
+		}
+		return_ACPI_STATUS(status);
+
+		/*
+		 * ACPI 2.0 Opcodes
+		 */
+	case AML_COPY_OP:	/* Copy (Source, Target) */
+
+		status =
+		    acpi_ut_copy_iobject_to_iobject(operand[0], &return_desc,
+						    walk_state);
+		break;
+
+	case AML_TO_DECSTRING_OP:	/* to_decimal_string (Data, Result) */
+
+		status = acpi_ex_convert_to_string(operand[0], &return_desc,
+						   ACPI_EXPLICIT_CONVERT_DECIMAL);
+		if (return_desc == operand[0]) {
+
+			/* No conversion performed, add ref to handle return value */
+			acpi_ut_add_reference(return_desc);
+		}
+		break;
+
+	case AML_TO_HEXSTRING_OP:	/* to_hex_string (Data, Result) */
+
+		status = acpi_ex_convert_to_string(operand[0], &return_desc,
+						   ACPI_EXPLICIT_CONVERT_HEX);
+		if (return_desc == operand[0]) {
+
+			/* No conversion performed, add ref to handle return value */
+			acpi_ut_add_reference(return_desc);
+		}
+		break;
+
+	case AML_TO_BUFFER_OP:	/* to_buffer (Data, Result) */
+
+		status = acpi_ex_convert_to_buffer(operand[0], &return_desc);
+		if (return_desc == operand[0]) {
+
+			/* No conversion performed, add ref to handle return value */
+			acpi_ut_add_reference(return_desc);
+		}
+		break;
+
+	case AML_TO_INTEGER_OP:	/* to_integer (Data, Result) */
+
+		status = acpi_ex_convert_to_integer(operand[0], &return_desc,
+						    ACPI_ANY_BASE);
+		if (return_desc == operand[0]) {
+
+			/* No conversion performed, add ref to handle return value */
+			acpi_ut_add_reference(return_desc);
+		}
+		break;
+
+	case AML_SHIFT_LEFT_BIT_OP:	/* shift_left_bit (Source, bit_num) */
+	case AML_SHIFT_RIGHT_BIT_OP:	/* shift_right_bit (Source, bit_num) */
+
+		/* These are two obsolete opcodes */
+
+		ACPI_ERROR((AE_INFO,
+			    "%s is obsolete and not implemented",
+			    acpi_ps_get_opcode_name(walk_state->opcode)));
+		status = AE_SUPPORT;
+		goto cleanup;
+
+	default:		/* Unknown opcode */
+
+		ACPI_ERROR((AE_INFO, "Unknown AML opcode 0x%X",
+			    walk_state->opcode));
+		status = AE_AML_BAD_OPCODE;
+		goto cleanup;
+	}
+
+	if (ACPI_SUCCESS(status)) {
+
+		/* Store the return value computed above into the target object */
+
+		status = acpi_ex_store(return_desc, operand[1], walk_state);
+	}
+
+      cleanup:
+
+	/* Delete return object on error */
+
+	if (ACPI_FAILURE(status)) {
+		acpi_ut_remove_reference(return_desc);
+	}
+
+	/* Save return object on success */
+
+	else if (!walk_state->result_obj) {
+		walk_state->result_obj = return_desc;
+	}
+
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_opcode_1A_0T_1R
+ *
+ * PARAMETERS:  walk_state          - Current state (contains AML opcode)
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Execute opcode with one argument, no target, and a return value
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ex_opcode_1A_0T_1R(struct acpi_walk_state *walk_state)
+{
+	union acpi_operand_object **operand = &walk_state->operands[0];
+	union acpi_operand_object *temp_desc;
+	union acpi_operand_object *return_desc = NULL;
+	acpi_status status = AE_OK;
+	u32 type;
+	u64 value;
+
+	ACPI_FUNCTION_TRACE_STR(ex_opcode_1A_0T_1R,
+				acpi_ps_get_opcode_name(walk_state->opcode));
+
+	/* Examine the AML opcode */
+
+	switch (walk_state->opcode) {
+	case AML_LNOT_OP:	/* LNot (Operand) */
+
+		return_desc = acpi_ut_create_integer_object((u64)0);
+		if (!return_desc) {
+			status = AE_NO_MEMORY;
+			goto cleanup;
+		}
+
+		/*
+		 * Set result to ONES (TRUE) if Value == 0.  Note:
+		 * return_desc->Integer.Value is initially == 0 (FALSE) from above.
+		 */
+		if (!operand[0]->integer.value) {
+			return_desc->integer.value = ACPI_UINT64_MAX;
+		}
+		break;
+
+	case AML_DECREMENT_OP:	/* Decrement (Operand)  */
+	case AML_INCREMENT_OP:	/* Increment (Operand)  */
+
+		/*
+		 * Create a new integer.  Can't just get the base integer and
+		 * increment it because it may be an Arg or Field.
+		 */
+		return_desc = acpi_ut_create_internal_object(ACPI_TYPE_INTEGER);
+		if (!return_desc) {
+			status = AE_NO_MEMORY;
+			goto cleanup;
+		}
+
+		/*
+		 * Since we are expecting a Reference operand, it can be either a
+		 * NS Node or an internal object.
+		 */
+		temp_desc = operand[0];
+		if (ACPI_GET_DESCRIPTOR_TYPE(temp_desc) ==
+		    ACPI_DESC_TYPE_OPERAND) {
+
+			/* Internal reference object - prevent deletion */
+
+			acpi_ut_add_reference(temp_desc);
+		}
+
+		/*
+		 * Convert the Reference operand to an Integer (This removes a
+		 * reference on the Operand[0] object)
+		 *
+		 * NOTE:  We use LNOT_OP here in order to force resolution of the
+		 * reference operand to an actual integer.
+		 */
+		status =
+		    acpi_ex_resolve_operands(AML_LNOT_OP, &temp_desc,
+					     walk_state);
+		if (ACPI_FAILURE(status)) {
+			ACPI_EXCEPTION((AE_INFO, status,
+					"While resolving operands for [%s]",
+					acpi_ps_get_opcode_name(walk_state->
+								opcode)));
+
+			goto cleanup;
+		}
+
+		/*
+		 * temp_desc is now guaranteed to be an Integer object --
+		 * Perform the actual increment or decrement
+		 */
+		if (walk_state->opcode == AML_INCREMENT_OP) {
+			return_desc->integer.value =
+			    temp_desc->integer.value + 1;
+		} else {
+			return_desc->integer.value =
+			    temp_desc->integer.value - 1;
+		}
+
+		/* Finished with this Integer object */
+
+		acpi_ut_remove_reference(temp_desc);
+
+		/*
+		 * Store the result back (indirectly) through the original
+		 * Reference object
+		 */
+		status = acpi_ex_store(return_desc, operand[0], walk_state);
+		break;
+
+	case AML_TYPE_OP:	/* object_type (source_object) */
+
+		/*
+		 * Note: The operand is not resolved at this point because we want to
+		 * get the associated object, not its value.  For example, we don't
+		 * want to resolve a field_unit to its value, we want the actual
+		 * field_unit object.
+		 */
+
+		/* Get the type of the base object */
+
+		status =
+		    acpi_ex_resolve_multiple(walk_state, operand[0], &type,
+					     NULL);
+		if (ACPI_FAILURE(status)) {
+			goto cleanup;
+		}
+
+		/* Allocate a descriptor to hold the type. */
+
+		return_desc = acpi_ut_create_integer_object((u64)type);
+		if (!return_desc) {
+			status = AE_NO_MEMORY;
+			goto cleanup;
+		}
+		break;
+
+	case AML_SIZE_OF_OP:	/* size_of (source_object) */
+
+		/*
+		 * Note: The operand is not resolved at this point because we want to
+		 * get the associated object, not its value.
+		 */
+
+		/* Get the base object */
+
+		status = acpi_ex_resolve_multiple(walk_state,
+						  operand[0], &type,
+						  &temp_desc);
+		if (ACPI_FAILURE(status)) {
+			goto cleanup;
+		}
+
+		/*
+		 * The type of the base object must be integer, buffer, string, or
+		 * package.  All others are not supported.
+		 *
+		 * NOTE: Integer is not specifically supported by the ACPI spec,
+		 * but is supported implicitly via implicit operand conversion.
+		 * rather than bother with conversion, we just use the byte width
+		 * global (4 or 8 bytes).
+		 */
+		switch (type) {
+		case ACPI_TYPE_INTEGER:
+			value = acpi_gbl_integer_byte_width;
+			break;
+
+		case ACPI_TYPE_STRING:
+			value = temp_desc->string.length;
+			break;
+
+		case ACPI_TYPE_BUFFER:
+
+			/* Buffer arguments may not be evaluated at this point */
+
+			status = acpi_ds_get_buffer_arguments(temp_desc);
+			value = temp_desc->buffer.length;
+			break;
+
+		case ACPI_TYPE_PACKAGE:
+
+			/* Package arguments may not be evaluated at this point */
+
+			status = acpi_ds_get_package_arguments(temp_desc);
+			value = temp_desc->package.count;
+			break;
+
+		default:
+			ACPI_ERROR((AE_INFO,
+				    "Operand must be Buffer/Integer/String/Package - found type %s",
+				    acpi_ut_get_type_name(type)));
+			status = AE_AML_OPERAND_TYPE;
+			goto cleanup;
+		}
+
+		if (ACPI_FAILURE(status)) {
+			goto cleanup;
+		}
+
+		/*
+		 * Now that we have the size of the object, create a result
+		 * object to hold the value
+		 */
+		return_desc = acpi_ut_create_integer_object(value);
+		if (!return_desc) {
+			status = AE_NO_MEMORY;
+			goto cleanup;
+		}
+		break;
+
+	case AML_REF_OF_OP:	/* ref_of (source_object) */
+
+		status =
+		    acpi_ex_get_object_reference(operand[0], &return_desc,
+						 walk_state);
+		if (ACPI_FAILURE(status)) {
+			goto cleanup;
+		}
+		break;
+
+	case AML_DEREF_OF_OP:	/* deref_of (obj_reference | String) */
+
+		/* Check for a method local or argument, or standalone String */
+
+		if (ACPI_GET_DESCRIPTOR_TYPE(operand[0]) ==
+		    ACPI_DESC_TYPE_NAMED) {
+			temp_desc =
+			    acpi_ns_get_attached_object((struct
+							 acpi_namespace_node *)
+							operand[0]);
+			if (temp_desc
+			    && ((temp_desc->common.type == ACPI_TYPE_STRING)
+				|| (temp_desc->common.type ==
+				    ACPI_TYPE_LOCAL_REFERENCE))) {
+				operand[0] = temp_desc;
+				acpi_ut_add_reference(temp_desc);
+			} else {
+				status = AE_AML_OPERAND_TYPE;
+				goto cleanup;
+			}
+		} else {
+			switch ((operand[0])->common.type) {
+			case ACPI_TYPE_LOCAL_REFERENCE:
+				/*
+				 * This is a deref_of (local_x | arg_x)
+				 *
+				 * Must resolve/dereference the local/arg reference first
+				 */
+				switch (operand[0]->reference.class) {
+				case ACPI_REFCLASS_LOCAL:
+				case ACPI_REFCLASS_ARG:
+
+					/* Set Operand[0] to the value of the local/arg */
+
+					status =
+					    acpi_ds_method_data_get_value
+					    (operand[0]->reference.class,
+					     operand[0]->reference.value,
+					     walk_state, &temp_desc);
+					if (ACPI_FAILURE(status)) {
+						goto cleanup;
+					}
+
+					/*
+					 * Delete our reference to the input object and
+					 * point to the object just retrieved
+					 */
+					acpi_ut_remove_reference(operand[0]);
+					operand[0] = temp_desc;
+					break;
+
+				case ACPI_REFCLASS_REFOF:
+
+					/* Get the object to which the reference refers */
+
+					temp_desc =
+					    operand[0]->reference.object;
+					acpi_ut_remove_reference(operand[0]);
+					operand[0] = temp_desc;
+					break;
+
+				default:
+
+					/* Must be an Index op - handled below */
+					break;
+				}
+				break;
+
+			case ACPI_TYPE_STRING:
+				break;
+
+			default:
+				status = AE_AML_OPERAND_TYPE;
+				goto cleanup;
+			}
+		}
+
+		if (ACPI_GET_DESCRIPTOR_TYPE(operand[0]) !=
+		    ACPI_DESC_TYPE_NAMED) {
+			if ((operand[0])->common.type == ACPI_TYPE_STRING) {
+				/*
+				 * This is a deref_of (String). The string is a reference
+				 * to a named ACPI object.
+				 *
+				 * 1) Find the owning Node
+				 * 2) Dereference the node to an actual object. Could be a
+				 *    Field, so we need to resolve the node to a value.
+				 */
+				status =
+				    acpi_ns_get_node(walk_state->scope_info->
+						     scope.node,
+						     operand[0]->string.pointer,
+						     ACPI_NS_SEARCH_PARENT,
+						     ACPI_CAST_INDIRECT_PTR
+						     (struct
+						      acpi_namespace_node,
+						      &return_desc));
+				if (ACPI_FAILURE(status)) {
+					goto cleanup;
+				}
+
+				status =
+				    acpi_ex_resolve_node_to_value
+				    (ACPI_CAST_INDIRECT_PTR
+				     (struct acpi_namespace_node, &return_desc),
+				     walk_state);
+				goto cleanup;
+			}
+		}
+
+		/* Operand[0] may have changed from the code above */
+
+		if (ACPI_GET_DESCRIPTOR_TYPE(operand[0]) ==
+		    ACPI_DESC_TYPE_NAMED) {
+			/*
+			 * This is a deref_of (object_reference)
+			 * Get the actual object from the Node (This is the dereference).
+			 * This case may only happen when a local_x or arg_x is
+			 * dereferenced above.
+			 */
+			return_desc = acpi_ns_get_attached_object((struct
+								   acpi_namespace_node
+								   *)
+								  operand[0]);
+			acpi_ut_add_reference(return_desc);
+		} else {
+			/*
+			 * This must be a reference object produced by either the
+			 * Index() or ref_of() operator
+			 */
+			switch (operand[0]->reference.class) {
+			case ACPI_REFCLASS_INDEX:
+
+				/*
+				 * The target type for the Index operator must be
+				 * either a Buffer or a Package
+				 */
+				switch (operand[0]->reference.target_type) {
+				case ACPI_TYPE_BUFFER_FIELD:
+
+					temp_desc =
+					    operand[0]->reference.object;
+
+					/*
+					 * Create a new object that contains one element of the
+					 * buffer -- the element pointed to by the index.
+					 *
+					 * NOTE: index into a buffer is NOT a pointer to a
+					 * sub-buffer of the main buffer, it is only a pointer to a
+					 * single element (byte) of the buffer!
+					 *
+					 * Since we are returning the value of the buffer at the
+					 * indexed location, we don't need to add an additional
+					 * reference to the buffer itself.
+					 */
+					return_desc =
+					    acpi_ut_create_integer_object((u64)
+									  temp_desc->buffer.pointer[operand[0]->reference.value]);
+					if (!return_desc) {
+						status = AE_NO_MEMORY;
+						goto cleanup;
+					}
+					break;
+
+				case ACPI_TYPE_PACKAGE:
+
+					/*
+					 * Return the referenced element of the package.  We must
+					 * add another reference to the referenced object, however.
+					 */
+					return_desc =
+					    *(operand[0]->reference.where);
+					if (return_desc) {
+						acpi_ut_add_reference
+						    (return_desc);
+					}
+					break;
+
+				default:
+
+					ACPI_ERROR((AE_INFO,
+						    "Unknown Index TargetType 0x%X in reference object %p",
+						    operand[0]->reference.
+						    target_type, operand[0]));
+					status = AE_AML_OPERAND_TYPE;
+					goto cleanup;
+				}
+				break;
+
+			case ACPI_REFCLASS_REFOF:
+
+				return_desc = operand[0]->reference.object;
+
+				if (ACPI_GET_DESCRIPTOR_TYPE(return_desc) ==
+				    ACPI_DESC_TYPE_NAMED) {
+					return_desc =
+					    acpi_ns_get_attached_object((struct
+									 acpi_namespace_node
+									 *)
+									return_desc);
+				}
+
+				/* Add another reference to the object! */
+
+				acpi_ut_add_reference(return_desc);
+				break;
+
+			default:
+				ACPI_ERROR((AE_INFO,
+					    "Unknown class in reference(%p) - 0x%2.2X",
+					    operand[0],
+					    operand[0]->reference.class));
+
+				status = AE_TYPE;
+				goto cleanup;
+			}
+		}
+		break;
+
+	default:
+
+		ACPI_ERROR((AE_INFO, "Unknown AML opcode 0x%X",
+			    walk_state->opcode));
+		status = AE_AML_BAD_OPCODE;
+		goto cleanup;
+	}
+
+      cleanup:
+
+	/* Delete return object on error */
+
+	if (ACPI_FAILURE(status)) {
+		acpi_ut_remove_reference(return_desc);
+	}
+
+	/* Save return object on success */
+
+	else {
+		walk_state->result_obj = return_desc;
+	}
+
+	return_ACPI_STATUS(status);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exoparg2.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exoparg2.c
new file mode 100644
index 00000000..a88af847
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exoparg2.c
@@ -0,0 +1,578 @@
+/******************************************************************************
+ *
+ * Module Name: exoparg2 - AML execution - opcodes with 2 arguments
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acparser.h"
+#include "acinterp.h"
+#include "acevents.h"
+#include "amlcode.h"
+
+#define _COMPONENT          ACPI_EXECUTER
+ACPI_MODULE_NAME("exoparg2")
+
+/*!
+ * Naming convention for AML interpreter execution routines.
+ *
+ * The routines that begin execution of AML opcodes are named with a common
+ * convention based upon the number of arguments, the number of target operands,
+ * and whether or not a value is returned:
+ *
+ *      AcpiExOpcode_xA_yT_zR
+ *
+ * Where:
+ *
+ * xA - ARGUMENTS:    The number of arguments (input operands) that are
+ *                    required for this opcode type (1 through 6 args).
+ * yT - TARGETS:      The number of targets (output operands) that are required
+ *                    for this opcode type (0, 1, or 2 targets).
+ * zR - RETURN VALUE: Indicates whether this opcode type returns a value
+ *                    as the function return (0 or 1).
+ *
+ * The AcpiExOpcode* functions are called via the Dispatcher component with
+ * fully resolved operands.
+!*/
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_opcode_2A_0T_0R
+ *
+ * PARAMETERS:  walk_state          - Current walk state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Execute opcode with two arguments, no target, and no return
+ *              value.
+ *
+ * ALLOCATION:  Deletes both operands
+ *
+ ******************************************************************************/
+acpi_status acpi_ex_opcode_2A_0T_0R(struct acpi_walk_state * walk_state)
+{
+	union acpi_operand_object **operand = &walk_state->operands[0];
+	struct acpi_namespace_node *node;
+	u32 value;
+	acpi_status status = AE_OK;
+
+	ACPI_FUNCTION_TRACE_STR(ex_opcode_2A_0T_0R,
+				acpi_ps_get_opcode_name(walk_state->opcode));
+
+	/* Examine the opcode */
+
+	switch (walk_state->opcode) {
+	case AML_NOTIFY_OP:	/* Notify (notify_object, notify_value) */
+
+		/* The first operand is a namespace node */
+
+		node = (struct acpi_namespace_node *)operand[0];
+
+		/* Second value is the notify value */
+
+		value = (u32)operand[1]->integer.value;
+
+		/* Are notifies allowed on this object? */
+
+		if (!acpi_ev_is_notify_object(node)) {
+			ACPI_ERROR((AE_INFO,
+				    "Unexpected notify object type [%s]",
+				    acpi_ut_get_type_name(node->type)));
+
+			status = AE_AML_OPERAND_TYPE;
+			break;
+		}
+
+		/*
+		 * Dispatch the notify to the appropriate handler
+		 * NOTE: the request is queued for execution after this method
+		 * completes.  The notify handlers are NOT invoked synchronously
+		 * from this thread -- because handlers may in turn run other
+		 * control methods.
+		 */
+		status = acpi_ev_queue_notify_request(node, value);
+		break;
+
+	default:
+
+		ACPI_ERROR((AE_INFO, "Unknown AML opcode 0x%X",
+			    walk_state->opcode));
+		status = AE_AML_BAD_OPCODE;
+	}
+
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_opcode_2A_2T_1R
+ *
+ * PARAMETERS:  walk_state          - Current walk state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Execute a dyadic operator (2 operands) with 2 output targets
+ *              and one implicit return value.
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ex_opcode_2A_2T_1R(struct acpi_walk_state *walk_state)
+{
+	union acpi_operand_object **operand = &walk_state->operands[0];
+	union acpi_operand_object *return_desc1 = NULL;
+	union acpi_operand_object *return_desc2 = NULL;
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE_STR(ex_opcode_2A_2T_1R,
+				acpi_ps_get_opcode_name(walk_state->opcode));
+
+	/* Execute the opcode */
+
+	switch (walk_state->opcode) {
+	case AML_DIVIDE_OP:
+
+		/* Divide (Dividend, Divisor, remainder_result quotient_result) */
+
+		return_desc1 =
+		    acpi_ut_create_internal_object(ACPI_TYPE_INTEGER);
+		if (!return_desc1) {
+			status = AE_NO_MEMORY;
+			goto cleanup;
+		}
+
+		return_desc2 =
+		    acpi_ut_create_internal_object(ACPI_TYPE_INTEGER);
+		if (!return_desc2) {
+			status = AE_NO_MEMORY;
+			goto cleanup;
+		}
+
+		/* Quotient to return_desc1, remainder to return_desc2 */
+
+		status = acpi_ut_divide(operand[0]->integer.value,
+					operand[1]->integer.value,
+					&return_desc1->integer.value,
+					&return_desc2->integer.value);
+		if (ACPI_FAILURE(status)) {
+			goto cleanup;
+		}
+		break;
+
+	default:
+
+		ACPI_ERROR((AE_INFO, "Unknown AML opcode 0x%X",
+			    walk_state->opcode));
+		status = AE_AML_BAD_OPCODE;
+		goto cleanup;
+	}
+
+	/* Store the results to the target reference operands */
+
+	status = acpi_ex_store(return_desc2, operand[2], walk_state);
+	if (ACPI_FAILURE(status)) {
+		goto cleanup;
+	}
+
+	status = acpi_ex_store(return_desc1, operand[3], walk_state);
+	if (ACPI_FAILURE(status)) {
+		goto cleanup;
+	}
+
+      cleanup:
+	/*
+	 * Since the remainder is not returned indirectly, remove a reference to
+	 * it. Only the quotient is returned indirectly.
+	 */
+	acpi_ut_remove_reference(return_desc2);
+
+	if (ACPI_FAILURE(status)) {
+
+		/* Delete the return object */
+
+		acpi_ut_remove_reference(return_desc1);
+	}
+
+	/* Save return object (the remainder) on success */
+
+	else {
+		walk_state->result_obj = return_desc1;
+	}
+
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_opcode_2A_1T_1R
+ *
+ * PARAMETERS:  walk_state          - Current walk state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Execute opcode with two arguments, one target, and a return
+ *              value.
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ex_opcode_2A_1T_1R(struct acpi_walk_state *walk_state)
+{
+	union acpi_operand_object **operand = &walk_state->operands[0];
+	union acpi_operand_object *return_desc = NULL;
+	u64 index;
+	acpi_status status = AE_OK;
+	acpi_size length;
+
+	ACPI_FUNCTION_TRACE_STR(ex_opcode_2A_1T_1R,
+				acpi_ps_get_opcode_name(walk_state->opcode));
+
+	/* Execute the opcode */
+
+	if (walk_state->op_info->flags & AML_MATH) {
+
+		/* All simple math opcodes (add, etc.) */
+
+		return_desc = acpi_ut_create_internal_object(ACPI_TYPE_INTEGER);
+		if (!return_desc) {
+			status = AE_NO_MEMORY;
+			goto cleanup;
+		}
+
+		return_desc->integer.value =
+		    acpi_ex_do_math_op(walk_state->opcode,
+				       operand[0]->integer.value,
+				       operand[1]->integer.value);
+		goto store_result_to_target;
+	}
+
+	switch (walk_state->opcode) {
+	case AML_MOD_OP:	/* Mod (Dividend, Divisor, remainder_result (ACPI 2.0) */
+
+		return_desc = acpi_ut_create_internal_object(ACPI_TYPE_INTEGER);
+		if (!return_desc) {
+			status = AE_NO_MEMORY;
+			goto cleanup;
+		}
+
+		/* return_desc will contain the remainder */
+
+		status = acpi_ut_divide(operand[0]->integer.value,
+					operand[1]->integer.value,
+					NULL, &return_desc->integer.value);
+		break;
+
+	case AML_CONCAT_OP:	/* Concatenate (Data1, Data2, Result) */
+
+		status = acpi_ex_do_concatenate(operand[0], operand[1],
+						&return_desc, walk_state);
+		break;
+
+	case AML_TO_STRING_OP:	/* to_string (Buffer, Length, Result) (ACPI 2.0) */
+
+		/*
+		 * Input object is guaranteed to be a buffer at this point (it may have
+		 * been converted.)  Copy the raw buffer data to a new object of
+		 * type String.
+		 */
+
+		/*
+		 * Get the length of the new string. It is the smallest of:
+		 * 1) Length of the input buffer
+		 * 2) Max length as specified in the to_string operator
+		 * 3) Length of input buffer up to a zero byte (null terminator)
+		 *
+		 * NOTE: A length of zero is ok, and will create a zero-length, null
+		 *       terminated string.
+		 */
+		length = 0;
+		while ((length < operand[0]->buffer.length) &&
+		       (length < operand[1]->integer.value) &&
+		       (operand[0]->buffer.pointer[length])) {
+			length++;
+		}
+
+		/* Allocate a new string object */
+
+		return_desc = acpi_ut_create_string_object(length);
+		if (!return_desc) {
+			status = AE_NO_MEMORY;
+			goto cleanup;
+		}
+
+		/*
+		 * Copy the raw buffer data with no transform.
+		 * (NULL terminated already)
+		 */
+		ACPI_MEMCPY(return_desc->string.pointer,
+			    operand[0]->buffer.pointer, length);
+		break;
+
+	case AML_CONCAT_RES_OP:
+
+		/* concatenate_res_template (Buffer, Buffer, Result) (ACPI 2.0) */
+
+		status = acpi_ex_concat_template(operand[0], operand[1],
+						 &return_desc, walk_state);
+		break;
+
+	case AML_INDEX_OP:	/* Index (Source Index Result) */
+
+		/* Create the internal return object */
+
+		return_desc =
+		    acpi_ut_create_internal_object(ACPI_TYPE_LOCAL_REFERENCE);
+		if (!return_desc) {
+			status = AE_NO_MEMORY;
+			goto cleanup;
+		}
+
+		/* Initialize the Index reference object */
+
+		index = operand[1]->integer.value;
+		return_desc->reference.value = (u32)index;
+		return_desc->reference.class = ACPI_REFCLASS_INDEX;
+
+		/*
+		 * At this point, the Source operand is a String, Buffer, or Package.
+		 * Verify that the index is within range.
+		 */
+		switch ((operand[0])->common.type) {
+		case ACPI_TYPE_STRING:
+
+			if (index >= operand[0]->string.length) {
+				status = AE_AML_STRING_LIMIT;
+			}
+
+			return_desc->reference.target_type =
+			    ACPI_TYPE_BUFFER_FIELD;
+			break;
+
+		case ACPI_TYPE_BUFFER:
+
+			if (index >= operand[0]->buffer.length) {
+				status = AE_AML_BUFFER_LIMIT;
+			}
+
+			return_desc->reference.target_type =
+			    ACPI_TYPE_BUFFER_FIELD;
+			break;
+
+		case ACPI_TYPE_PACKAGE:
+
+			if (index >= operand[0]->package.count) {
+				status = AE_AML_PACKAGE_LIMIT;
+			}
+
+			return_desc->reference.target_type = ACPI_TYPE_PACKAGE;
+			return_desc->reference.where =
+			    &operand[0]->package.elements[index];
+			break;
+
+		default:
+
+			status = AE_AML_INTERNAL;
+			goto cleanup;
+		}
+
+		/* Failure means that the Index was beyond the end of the object */
+
+		if (ACPI_FAILURE(status)) {
+			ACPI_EXCEPTION((AE_INFO, status,
+					"Index (0x%8.8X%8.8X) is beyond end of object",
+					ACPI_FORMAT_UINT64(index)));
+			goto cleanup;
+		}
+
+		/*
+		 * Save the target object and add a reference to it for the life
+		 * of the index
+		 */
+		return_desc->reference.object = operand[0];
+		acpi_ut_add_reference(operand[0]);
+
+		/* Store the reference to the Target */
+
+		status = acpi_ex_store(return_desc, operand[2], walk_state);
+
+		/* Return the reference */
+
+		walk_state->result_obj = return_desc;
+		goto cleanup;
+
+	default:
+
+		ACPI_ERROR((AE_INFO, "Unknown AML opcode 0x%X",
+			    walk_state->opcode));
+		status = AE_AML_BAD_OPCODE;
+		break;
+	}
+
+      store_result_to_target:
+
+	if (ACPI_SUCCESS(status)) {
+		/*
+		 * Store the result of the operation (which is now in return_desc) into
+		 * the Target descriptor.
+		 */
+		status = acpi_ex_store(return_desc, operand[2], walk_state);
+		if (ACPI_FAILURE(status)) {
+			goto cleanup;
+		}
+
+		if (!walk_state->result_obj) {
+			walk_state->result_obj = return_desc;
+		}
+	}
+
+      cleanup:
+
+	/* Delete return object on error */
+
+	if (ACPI_FAILURE(status)) {
+		acpi_ut_remove_reference(return_desc);
+		walk_state->result_obj = NULL;
+	}
+
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_opcode_2A_0T_1R
+ *
+ * PARAMETERS:  walk_state          - Current walk state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Execute opcode with 2 arguments, no target, and a return value
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ex_opcode_2A_0T_1R(struct acpi_walk_state *walk_state)
+{
+	union acpi_operand_object **operand = &walk_state->operands[0];
+	union acpi_operand_object *return_desc = NULL;
+	acpi_status status = AE_OK;
+	u8 logical_result = FALSE;
+
+	ACPI_FUNCTION_TRACE_STR(ex_opcode_2A_0T_1R,
+				acpi_ps_get_opcode_name(walk_state->opcode));
+
+	/* Create the internal return object */
+
+	return_desc = acpi_ut_create_internal_object(ACPI_TYPE_INTEGER);
+	if (!return_desc) {
+		status = AE_NO_MEMORY;
+		goto cleanup;
+	}
+
+	/* Execute the Opcode */
+
+	if (walk_state->op_info->flags & AML_LOGICAL_NUMERIC) {
+
+		/* logical_op (Operand0, Operand1) */
+
+		status = acpi_ex_do_logical_numeric_op(walk_state->opcode,
+						       operand[0]->integer.
+						       value,
+						       operand[1]->integer.
+						       value, &logical_result);
+		goto store_logical_result;
+	} else if (walk_state->op_info->flags & AML_LOGICAL) {
+
+		/* logical_op (Operand0, Operand1) */
+
+		status = acpi_ex_do_logical_op(walk_state->opcode, operand[0],
+					       operand[1], &logical_result);
+		goto store_logical_result;
+	}
+
+	switch (walk_state->opcode) {
+	case AML_ACQUIRE_OP:	/* Acquire (mutex_object, Timeout) */
+
+		status =
+		    acpi_ex_acquire_mutex(operand[1], operand[0], walk_state);
+		if (status == AE_TIME) {
+			logical_result = TRUE;	/* TRUE = Acquire timed out */
+			status = AE_OK;
+		}
+		break;
+
+	case AML_WAIT_OP:	/* Wait (event_object, Timeout) */
+
+		status = acpi_ex_system_wait_event(operand[1], operand[0]);
+		if (status == AE_TIME) {
+			logical_result = TRUE;	/* TRUE, Wait timed out */
+			status = AE_OK;
+		}
+		break;
+
+	default:
+
+		ACPI_ERROR((AE_INFO, "Unknown AML opcode 0x%X",
+			    walk_state->opcode));
+		status = AE_AML_BAD_OPCODE;
+		goto cleanup;
+	}
+
+      store_logical_result:
+	/*
+	 * Set return value to according to logical_result. logical TRUE (all ones)
+	 * Default is FALSE (zero)
+	 */
+	if (logical_result) {
+		return_desc->integer.value = ACPI_UINT64_MAX;
+	}
+
+      cleanup:
+
+	/* Delete return object on error */
+
+	if (ACPI_FAILURE(status)) {
+		acpi_ut_remove_reference(return_desc);
+	}
+
+	/* Save return object on success */
+
+	else {
+		walk_state->result_obj = return_desc;
+	}
+
+	return_ACPI_STATUS(status);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exoparg3.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exoparg3.c
new file mode 100644
index 00000000..c12e704d
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exoparg3.c
@@ -0,0 +1,272 @@
+
+/******************************************************************************
+ *
+ * Module Name: exoparg3 - AML execution - opcodes with 3 arguments
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acinterp.h"
+#include "acparser.h"
+#include "amlcode.h"
+
+#define _COMPONENT          ACPI_EXECUTER
+ACPI_MODULE_NAME("exoparg3")
+
+/*!
+ * Naming convention for AML interpreter execution routines.
+ *
+ * The routines that begin execution of AML opcodes are named with a common
+ * convention based upon the number of arguments, the number of target operands,
+ * and whether or not a value is returned:
+ *
+ *      AcpiExOpcode_xA_yT_zR
+ *
+ * Where:
+ *
+ * xA - ARGUMENTS:    The number of arguments (input operands) that are
+ *                    required for this opcode type (1 through 6 args).
+ * yT - TARGETS:      The number of targets (output operands) that are required
+ *                    for this opcode type (0, 1, or 2 targets).
+ * zR - RETURN VALUE: Indicates whether this opcode type returns a value
+ *                    as the function return (0 or 1).
+ *
+ * The AcpiExOpcode* functions are called via the Dispatcher component with
+ * fully resolved operands.
+!*/
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_opcode_3A_0T_0R
+ *
+ * PARAMETERS:  walk_state          - Current walk state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Execute Triadic operator (3 operands)
+ *
+ ******************************************************************************/
+acpi_status acpi_ex_opcode_3A_0T_0R(struct acpi_walk_state *walk_state)
+{
+	union acpi_operand_object **operand = &walk_state->operands[0];
+	struct acpi_signal_fatal_info *fatal;
+	acpi_status status = AE_OK;
+
+	ACPI_FUNCTION_TRACE_STR(ex_opcode_3A_0T_0R,
+				acpi_ps_get_opcode_name(walk_state->opcode));
+
+	switch (walk_state->opcode) {
+	case AML_FATAL_OP:	/* Fatal (fatal_type fatal_code fatal_arg) */
+
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+				  "FatalOp: Type %X Code %X Arg %X <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n",
+				  (u32)operand[0]->integer.value,
+				  (u32)operand[1]->integer.value,
+				  (u32)operand[2]->integer.value));
+
+		fatal = ACPI_ALLOCATE(sizeof(struct acpi_signal_fatal_info));
+		if (fatal) {
+			fatal->type = (u32)operand[0]->integer.value;
+			fatal->code = (u32)operand[1]->integer.value;
+			fatal->argument = (u32)operand[2]->integer.value;
+		}
+
+		/* Always signal the OS! */
+
+		status = acpi_os_signal(ACPI_SIGNAL_FATAL, fatal);
+
+		/* Might return while OS is shutting down, just continue */
+
+		ACPI_FREE(fatal);
+		break;
+
+	default:
+
+		ACPI_ERROR((AE_INFO, "Unknown AML opcode 0x%X",
+			    walk_state->opcode));
+		status = AE_AML_BAD_OPCODE;
+		goto cleanup;
+	}
+
+      cleanup:
+
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_opcode_3A_1T_1R
+ *
+ * PARAMETERS:  walk_state          - Current walk state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Execute Triadic operator (3 operands)
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ex_opcode_3A_1T_1R(struct acpi_walk_state *walk_state)
+{
+	union acpi_operand_object **operand = &walk_state->operands[0];
+	union acpi_operand_object *return_desc = NULL;
+	char *buffer = NULL;
+	acpi_status status = AE_OK;
+	u64 index;
+	acpi_size length;
+
+	ACPI_FUNCTION_TRACE_STR(ex_opcode_3A_1T_1R,
+				acpi_ps_get_opcode_name(walk_state->opcode));
+
+	switch (walk_state->opcode) {
+	case AML_MID_OP:	/* Mid (Source[0], Index[1], Length[2], Result[3]) */
+
+		/*
+		 * Create the return object.  The Source operand is guaranteed to be
+		 * either a String or a Buffer, so just use its type.
+		 */
+		return_desc = acpi_ut_create_internal_object((operand[0])->
+							     common.type);
+		if (!return_desc) {
+			status = AE_NO_MEMORY;
+			goto cleanup;
+		}
+
+		/* Get the Integer values from the objects */
+
+		index = operand[1]->integer.value;
+		length = (acpi_size) operand[2]->integer.value;
+
+		/*
+		 * If the index is beyond the length of the String/Buffer, or if the
+		 * requested length is zero, return a zero-length String/Buffer
+		 */
+		if (index >= operand[0]->string.length) {
+			length = 0;
+		}
+
+		/* Truncate request if larger than the actual String/Buffer */
+
+		else if ((index + length) > operand[0]->string.length) {
+			length = (acpi_size) operand[0]->string.length -
+			    (acpi_size) index;
+		}
+
+		/* Strings always have a sub-pointer, not so for buffers */
+
+		switch ((operand[0])->common.type) {
+		case ACPI_TYPE_STRING:
+
+			/* Always allocate a new buffer for the String */
+
+			buffer = ACPI_ALLOCATE_ZEROED((acpi_size) length + 1);
+			if (!buffer) {
+				status = AE_NO_MEMORY;
+				goto cleanup;
+			}
+			break;
+
+		case ACPI_TYPE_BUFFER:
+
+			/* If the requested length is zero, don't allocate a buffer */
+
+			if (length > 0) {
+
+				/* Allocate a new buffer for the Buffer */
+
+				buffer = ACPI_ALLOCATE_ZEROED(length);
+				if (!buffer) {
+					status = AE_NO_MEMORY;
+					goto cleanup;
+				}
+			}
+			break;
+
+		default:	/* Should not happen */
+
+			status = AE_AML_OPERAND_TYPE;
+			goto cleanup;
+		}
+
+		if (buffer) {
+
+			/* We have a buffer, copy the portion requested */
+
+			ACPI_MEMCPY(buffer, operand[0]->string.pointer + index,
+				    length);
+		}
+
+		/* Set the length of the new String/Buffer */
+
+		return_desc->string.pointer = buffer;
+		return_desc->string.length = (u32)length;
+
+		/* Mark buffer initialized */
+
+		return_desc->buffer.flags |= AOPOBJ_DATA_VALID;
+		break;
+
+	default:
+
+		ACPI_ERROR((AE_INFO, "Unknown AML opcode 0x%X",
+			    walk_state->opcode));
+		status = AE_AML_BAD_OPCODE;
+		goto cleanup;
+	}
+
+	/* Store the result in the target */
+
+	status = acpi_ex_store(return_desc, operand[3], walk_state);
+
+      cleanup:
+
+	/* Delete return object on error */
+
+	if (ACPI_FAILURE(status) || walk_state->result_obj) {
+		acpi_ut_remove_reference(return_desc);
+		walk_state->result_obj = NULL;
+	}
+
+	/* Set the return object and exit */
+
+	else {
+		walk_state->result_obj = return_desc;
+	}
+	return_ACPI_STATUS(status);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exoparg6.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exoparg6.c
new file mode 100644
index 00000000..69463536
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exoparg6.c
@@ -0,0 +1,338 @@
+
+/******************************************************************************
+ *
+ * Module Name: exoparg6 - AML execution - opcodes with 6 arguments
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acinterp.h"
+#include "acparser.h"
+#include "amlcode.h"
+
+#define _COMPONENT          ACPI_EXECUTER
+ACPI_MODULE_NAME("exoparg6")
+
+/*!
+ * Naming convention for AML interpreter execution routines.
+ *
+ * The routines that begin execution of AML opcodes are named with a common
+ * convention based upon the number of arguments, the number of target operands,
+ * and whether or not a value is returned:
+ *
+ *      AcpiExOpcode_xA_yT_zR
+ *
+ * Where:
+ *
+ * xA - ARGUMENTS:    The number of arguments (input operands) that are
+ *                    required for this opcode type (1 through 6 args).
+ * yT - TARGETS:      The number of targets (output operands) that are required
+ *                    for this opcode type (0, 1, or 2 targets).
+ * zR - RETURN VALUE: Indicates whether this opcode type returns a value
+ *                    as the function return (0 or 1).
+ *
+ * The AcpiExOpcode* functions are called via the Dispatcher component with
+ * fully resolved operands.
+!*/
+/* Local prototypes */
+static u8
+acpi_ex_do_match(u32 match_op,
+		 union acpi_operand_object *package_obj,
+		 union acpi_operand_object *match_obj);
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_do_match
+ *
+ * PARAMETERS:  match_op        - The AML match operand
+ *              package_obj     - Object from the target package
+ *              match_obj       - Object to be matched
+ *
+ * RETURN:      TRUE if the match is successful, FALSE otherwise
+ *
+ * DESCRIPTION: Implements the low-level match for the ASL Match operator.
+ *              Package elements will be implicitly converted to the type of
+ *              the match object (Integer/Buffer/String).
+ *
+ ******************************************************************************/
+
+static u8
+acpi_ex_do_match(u32 match_op,
+		 union acpi_operand_object *package_obj,
+		 union acpi_operand_object *match_obj)
+{
+	u8 logical_result = TRUE;
+	acpi_status status;
+
+	/*
+	 * Note: Since the package_obj/match_obj ordering is opposite to that of
+	 * the standard logical operators, we have to reverse them when we call
+	 * do_logical_op in order to make the implicit conversion rules work
+	 * correctly. However, this means we have to flip the entire equation
+	 * also. A bit ugly perhaps, but overall, better than fussing the
+	 * parameters around at runtime, over and over again.
+	 *
+	 * Below, P[i] refers to the package element, M refers to the Match object.
+	 */
+	switch (match_op) {
+	case MATCH_MTR:
+
+		/* Always true */
+
+		break;
+
+	case MATCH_MEQ:
+
+		/*
+		 * True if equal: (P[i] == M)
+		 * Change to:     (M == P[i])
+		 */
+		status =
+		    acpi_ex_do_logical_op(AML_LEQUAL_OP, match_obj, package_obj,
+					  &logical_result);
+		if (ACPI_FAILURE(status)) {
+			return (FALSE);
+		}
+		break;
+
+	case MATCH_MLE:
+
+		/*
+		 * True if less than or equal: (P[i] <= M) (P[i] not_greater than M)
+		 * Change to:                  (M >= P[i]) (M not_less than P[i])
+		 */
+		status =
+		    acpi_ex_do_logical_op(AML_LLESS_OP, match_obj, package_obj,
+					  &logical_result);
+		if (ACPI_FAILURE(status)) {
+			return (FALSE);
+		}
+		logical_result = (u8)!logical_result;
+		break;
+
+	case MATCH_MLT:
+
+		/*
+		 * True if less than: (P[i] < M)
+		 * Change to:         (M > P[i])
+		 */
+		status =
+		    acpi_ex_do_logical_op(AML_LGREATER_OP, match_obj,
+					  package_obj, &logical_result);
+		if (ACPI_FAILURE(status)) {
+			return (FALSE);
+		}
+		break;
+
+	case MATCH_MGE:
+
+		/*
+		 * True if greater than or equal: (P[i] >= M) (P[i] not_less than M)
+		 * Change to:                     (M <= P[i]) (M not_greater than P[i])
+		 */
+		status =
+		    acpi_ex_do_logical_op(AML_LGREATER_OP, match_obj,
+					  package_obj, &logical_result);
+		if (ACPI_FAILURE(status)) {
+			return (FALSE);
+		}
+		logical_result = (u8)!logical_result;
+		break;
+
+	case MATCH_MGT:
+
+		/*
+		 * True if greater than: (P[i] > M)
+		 * Change to:            (M < P[i])
+		 */
+		status =
+		    acpi_ex_do_logical_op(AML_LLESS_OP, match_obj, package_obj,
+					  &logical_result);
+		if (ACPI_FAILURE(status)) {
+			return (FALSE);
+		}
+		break;
+
+	default:
+
+		/* Undefined */
+
+		return (FALSE);
+	}
+
+	return logical_result;
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_opcode_6A_0T_1R
+ *
+ * PARAMETERS:  walk_state          - Current walk state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Execute opcode with 6 arguments, no target, and a return value
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ex_opcode_6A_0T_1R(struct acpi_walk_state * walk_state)
+{
+	union acpi_operand_object **operand = &walk_state->operands[0];
+	union acpi_operand_object *return_desc = NULL;
+	acpi_status status = AE_OK;
+	u64 index;
+	union acpi_operand_object *this_element;
+
+	ACPI_FUNCTION_TRACE_STR(ex_opcode_6A_0T_1R,
+				acpi_ps_get_opcode_name(walk_state->opcode));
+
+	switch (walk_state->opcode) {
+	case AML_MATCH_OP:
+		/*
+		 * Match (search_pkg[0], match_op1[1], match_obj1[2],
+		 *                      match_op2[3], match_obj2[4], start_index[5])
+		 */
+
+		/* Validate both Match Term Operators (MTR, MEQ, etc.) */
+
+		if ((operand[1]->integer.value > MAX_MATCH_OPERATOR) ||
+		    (operand[3]->integer.value > MAX_MATCH_OPERATOR)) {
+			ACPI_ERROR((AE_INFO, "Match operator out of range"));
+			status = AE_AML_OPERAND_VALUE;
+			goto cleanup;
+		}
+
+		/* Get the package start_index, validate against the package length */
+
+		index = operand[5]->integer.value;
+		if (index >= operand[0]->package.count) {
+			ACPI_ERROR((AE_INFO,
+				    "Index (0x%8.8X%8.8X) beyond package end (0x%X)",
+				    ACPI_FORMAT_UINT64(index),
+				    operand[0]->package.count));
+			status = AE_AML_PACKAGE_LIMIT;
+			goto cleanup;
+		}
+
+		/* Create an integer for the return value */
+		/* Default return value is ACPI_UINT64_MAX if no match found */
+
+		return_desc = acpi_ut_create_integer_object(ACPI_UINT64_MAX);
+		if (!return_desc) {
+			status = AE_NO_MEMORY;
+			goto cleanup;
+
+		}
+
+		/*
+		 * Examine each element until a match is found. Both match conditions
+		 * must be satisfied for a match to occur. Within the loop,
+		 * "continue" signifies that the current element does not match
+		 * and the next should be examined.
+		 *
+		 * Upon finding a match, the loop will terminate via "break" at
+		 * the bottom.  If it terminates "normally", match_value will be
+		 * ACPI_UINT64_MAX (Ones) (its initial value) indicating that no
+		 * match was found.
+		 */
+		for (; index < operand[0]->package.count; index++) {
+
+			/* Get the current package element */
+
+			this_element = operand[0]->package.elements[index];
+
+			/* Treat any uninitialized (NULL) elements as non-matching */
+
+			if (!this_element) {
+				continue;
+			}
+
+			/*
+			 * Both match conditions must be satisfied. Execution of a continue
+			 * (proceed to next iteration of enclosing for loop) signifies a
+			 * non-match.
+			 */
+			if (!acpi_ex_do_match((u32)operand[1]->integer.value,
+					      this_element, operand[2])) {
+				continue;
+			}
+
+			if (!acpi_ex_do_match((u32)operand[3]->integer.value,
+					      this_element, operand[4])) {
+				continue;
+			}
+
+			/* Match found: Index is the return value */
+
+			return_desc->integer.value = index;
+			break;
+		}
+		break;
+
+	case AML_LOAD_TABLE_OP:
+
+		status = acpi_ex_load_table_op(walk_state, &return_desc);
+		break;
+
+	default:
+
+		ACPI_ERROR((AE_INFO, "Unknown AML opcode 0x%X",
+			    walk_state->opcode));
+		status = AE_AML_BAD_OPCODE;
+		goto cleanup;
+	}
+
+      cleanup:
+
+	/* Delete return object on error */
+
+	if (ACPI_FAILURE(status)) {
+		acpi_ut_remove_reference(return_desc);
+	}
+
+	/* Save return object on success */
+
+	else {
+		walk_state->result_obj = return_desc;
+	}
+
+	return_ACPI_STATUS(status);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exprep.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exprep.c
new file mode 100644
index 00000000..bc5d4a56
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exprep.c
@@ -0,0 +1,623 @@
+
+/******************************************************************************
+ *
+ * Module Name: exprep - ACPI AML (p-code) execution - field prep utilities
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acinterp.h"
+#include "amlcode.h"
+#include "acnamesp.h"
+#include "acdispat.h"
+
+#define _COMPONENT          ACPI_EXECUTER
+ACPI_MODULE_NAME("exprep")
+
+/* Local prototypes */
+static u32
+acpi_ex_decode_field_access(union acpi_operand_object *obj_desc,
+			    u8 field_flags, u32 *return_byte_alignment);
+
+#ifdef ACPI_UNDER_DEVELOPMENT
+
+static u32
+acpi_ex_generate_access(u32 field_bit_offset,
+			u32 field_bit_length, u32 region_length);
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_generate_access
+ *
+ * PARAMETERS:  field_bit_offset    - Start of field within parent region/buffer
+ *              field_bit_length    - Length of field in bits
+ *              region_length       - Length of parent in bytes
+ *
+ * RETURN:      Field granularity (8, 16, 32 or 64) and
+ *              byte_alignment (1, 2, 3, or 4)
+ *
+ * DESCRIPTION: Generate an optimal access width for fields defined with the
+ *              any_acc keyword.
+ *
+ * NOTE: Need to have the region_length in order to check for boundary
+ *       conditions (end-of-region).  However, the region_length is a deferred
+ *       operation.  Therefore, to complete this implementation, the generation
+ *       of this access width must be deferred until the region length has
+ *       been evaluated.
+ *
+ ******************************************************************************/
+
+static u32
+acpi_ex_generate_access(u32 field_bit_offset,
+			u32 field_bit_length, u32 region_length)
+{
+	u32 field_byte_length;
+	u32 field_byte_offset;
+	u32 field_byte_end_offset;
+	u32 access_byte_width;
+	u32 field_start_offset;
+	u32 field_end_offset;
+	u32 minimum_access_width = 0xFFFFFFFF;
+	u32 minimum_accesses = 0xFFFFFFFF;
+	u32 accesses;
+
+	ACPI_FUNCTION_TRACE(ex_generate_access);
+
+	/* Round Field start offset and length to "minimal" byte boundaries */
+
+	field_byte_offset = ACPI_DIV_8(ACPI_ROUND_DOWN(field_bit_offset, 8));
+	field_byte_end_offset = ACPI_DIV_8(ACPI_ROUND_UP(field_bit_length +
+							 field_bit_offset, 8));
+	field_byte_length = field_byte_end_offset - field_byte_offset;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_BFIELD,
+			  "Bit length %u, Bit offset %u\n",
+			  field_bit_length, field_bit_offset));
+
+	ACPI_DEBUG_PRINT((ACPI_DB_BFIELD,
+			  "Byte Length %u, Byte Offset %u, End Offset %u\n",
+			  field_byte_length, field_byte_offset,
+			  field_byte_end_offset));
+
+	/*
+	 * Iterative search for the maximum access width that is both aligned
+	 * and does not go beyond the end of the region
+	 *
+	 * Start at byte_acc and work upwards to qword_acc max. (1,2,4,8 bytes)
+	 */
+	for (access_byte_width = 1; access_byte_width <= 8;
+	     access_byte_width <<= 1) {
+		/*
+		 * 1) Round end offset up to next access boundary and make sure that
+		 *    this does not go beyond the end of the parent region.
+		 * 2) When the Access width is greater than the field_byte_length, we
+		 *    are done. (This does not optimize for the perfectly aligned
+		 *    case yet).
+		 */
+		if (ACPI_ROUND_UP(field_byte_end_offset, access_byte_width) <=
+		    region_length) {
+			field_start_offset =
+			    ACPI_ROUND_DOWN(field_byte_offset,
+					    access_byte_width) /
+			    access_byte_width;
+
+			field_end_offset =
+			    ACPI_ROUND_UP((field_byte_length +
+					   field_byte_offset),
+					  access_byte_width) /
+			    access_byte_width;
+
+			accesses = field_end_offset - field_start_offset;
+
+			ACPI_DEBUG_PRINT((ACPI_DB_BFIELD,
+					  "AccessWidth %u end is within region\n",
+					  access_byte_width));
+
+			ACPI_DEBUG_PRINT((ACPI_DB_BFIELD,
+					  "Field Start %u, Field End %u -- requires %u accesses\n",
+					  field_start_offset, field_end_offset,
+					  accesses));
+
+			/* Single access is optimal */
+
+			if (accesses <= 1) {
+				ACPI_DEBUG_PRINT((ACPI_DB_BFIELD,
+						  "Entire field can be accessed with one operation of size %u\n",
+						  access_byte_width));
+				return_VALUE(access_byte_width);
+			}
+
+			/*
+			 * Fits in the region, but requires more than one read/write.
+			 * try the next wider access on next iteration
+			 */
+			if (accesses < minimum_accesses) {
+				minimum_accesses = accesses;
+				minimum_access_width = access_byte_width;
+			}
+		} else {
+			ACPI_DEBUG_PRINT((ACPI_DB_BFIELD,
+					  "AccessWidth %u end is NOT within region\n",
+					  access_byte_width));
+			if (access_byte_width == 1) {
+				ACPI_DEBUG_PRINT((ACPI_DB_BFIELD,
+						  "Field goes beyond end-of-region!\n"));
+
+				/* Field does not fit in the region at all */
+
+				return_VALUE(0);
+			}
+
+			/*
+			 * This width goes beyond the end-of-region, back off to
+			 * previous access
+			 */
+			ACPI_DEBUG_PRINT((ACPI_DB_BFIELD,
+					  "Backing off to previous optimal access width of %u\n",
+					  minimum_access_width));
+			return_VALUE(minimum_access_width);
+		}
+	}
+
+	/*
+	 * Could not read/write field with one operation,
+	 * just use max access width
+	 */
+	ACPI_DEBUG_PRINT((ACPI_DB_BFIELD,
+			  "Cannot access field in one operation, using width 8\n"));
+	return_VALUE(8);
+}
+#endif				/* ACPI_UNDER_DEVELOPMENT */
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_decode_field_access
+ *
+ * PARAMETERS:  obj_desc            - Field object
+ *              field_flags         - Encoded fieldflags (contains access bits)
+ *              return_byte_alignment - Where the byte alignment is returned
+ *
+ * RETURN:      Field granularity (8, 16, 32 or 64) and
+ *              byte_alignment (1, 2, 3, or 4)
+ *
+ * DESCRIPTION: Decode the access_type bits of a field definition.
+ *
+ ******************************************************************************/
+
+static u32
+acpi_ex_decode_field_access(union acpi_operand_object *obj_desc,
+			    u8 field_flags, u32 *return_byte_alignment)
+{
+	u32 access;
+	u32 byte_alignment;
+	u32 bit_length;
+
+	ACPI_FUNCTION_TRACE(ex_decode_field_access);
+
+	access = (field_flags & AML_FIELD_ACCESS_TYPE_MASK);
+
+	switch (access) {
+	case AML_FIELD_ACCESS_ANY:
+
+#ifdef ACPI_UNDER_DEVELOPMENT
+		byte_alignment =
+		    acpi_ex_generate_access(obj_desc->common_field.
+					    start_field_bit_offset,
+					    obj_desc->common_field.bit_length,
+					    0xFFFFFFFF
+					    /* Temp until we pass region_length as parameter */
+					    );
+		bit_length = byte_alignment * 8;
+#endif
+
+		byte_alignment = 1;
+		bit_length = 8;
+		break;
+
+	case AML_FIELD_ACCESS_BYTE:
+	case AML_FIELD_ACCESS_BUFFER:	/* ACPI 2.0 (SMBus Buffer) */
+		byte_alignment = 1;
+		bit_length = 8;
+		break;
+
+	case AML_FIELD_ACCESS_WORD:
+		byte_alignment = 2;
+		bit_length = 16;
+		break;
+
+	case AML_FIELD_ACCESS_DWORD:
+		byte_alignment = 4;
+		bit_length = 32;
+		break;
+
+	case AML_FIELD_ACCESS_QWORD:	/* ACPI 2.0 */
+		byte_alignment = 8;
+		bit_length = 64;
+		break;
+
+	default:
+		/* Invalid field access type */
+
+		ACPI_ERROR((AE_INFO, "Unknown field access type 0x%X", access));
+		return_UINT32(0);
+	}
+
+	if (obj_desc->common.type == ACPI_TYPE_BUFFER_FIELD) {
+		/*
+		 * buffer_field access can be on any byte boundary, so the
+		 * byte_alignment is always 1 byte -- regardless of any byte_alignment
+		 * implied by the field access type.
+		 */
+		byte_alignment = 1;
+	}
+
+	*return_byte_alignment = byte_alignment;
+	return_UINT32(bit_length);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_prep_common_field_object
+ *
+ * PARAMETERS:  obj_desc            - The field object
+ *              field_flags         - Access, lock_rule, and update_rule.
+ *                                    The format of a field_flag is described
+ *                                    in the ACPI specification
+ *              field_attribute     - Special attributes (not used)
+ *              field_bit_position  - Field start position
+ *              field_bit_length    - Field length in number of bits
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Initialize the areas of the field object that are common
+ *              to the various types of fields.  Note: This is very "sensitive"
+ *              code because we are solving the general case for field
+ *              alignment.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ex_prep_common_field_object(union acpi_operand_object *obj_desc,
+				 u8 field_flags,
+				 u8 field_attribute,
+				 u32 field_bit_position, u32 field_bit_length)
+{
+	u32 access_bit_width;
+	u32 byte_alignment;
+	u32 nearest_byte_address;
+
+	ACPI_FUNCTION_TRACE(ex_prep_common_field_object);
+
+	/*
+	 * Note: the structure being initialized is the
+	 * ACPI_COMMON_FIELD_INFO;  No structure fields outside of the common
+	 * area are initialized by this procedure.
+	 */
+	obj_desc->common_field.field_flags = field_flags;
+	obj_desc->common_field.attribute = field_attribute;
+	obj_desc->common_field.bit_length = field_bit_length;
+
+	/*
+	 * Decode the access type so we can compute offsets.  The access type gives
+	 * two pieces of information - the width of each field access and the
+	 * necessary byte_alignment (address granularity) of the access.
+	 *
+	 * For any_acc, the access_bit_width is the largest width that is both
+	 * necessary and possible in an attempt to access the whole field in one
+	 * I/O operation.  However, for any_acc, the byte_alignment is always one
+	 * byte.
+	 *
+	 * For all Buffer Fields, the byte_alignment is always one byte.
+	 *
+	 * For all other access types (Byte, Word, Dword, Qword), the Bitwidth is
+	 * the same (equivalent) as the byte_alignment.
+	 */
+	access_bit_width = acpi_ex_decode_field_access(obj_desc, field_flags,
+						       &byte_alignment);
+	if (!access_bit_width) {
+		return_ACPI_STATUS(AE_AML_OPERAND_VALUE);
+	}
+
+	/* Setup width (access granularity) fields (values are: 1, 2, 4, 8) */
+
+	obj_desc->common_field.access_byte_width = (u8)
+	    ACPI_DIV_8(access_bit_width);
+
+	/*
+	 * base_byte_offset is the address of the start of the field within the
+	 * region.  It is the byte address of the first *datum* (field-width data
+	 * unit) of the field. (i.e., the first datum that contains at least the
+	 * first *bit* of the field.)
+	 *
+	 * Note: byte_alignment is always either equal to the access_bit_width or 8
+	 * (Byte access), and it defines the addressing granularity of the parent
+	 * region or buffer.
+	 */
+	nearest_byte_address =
+	    ACPI_ROUND_BITS_DOWN_TO_BYTES(field_bit_position);
+	obj_desc->common_field.base_byte_offset = (u32)
+	    ACPI_ROUND_DOWN(nearest_byte_address, byte_alignment);
+
+	/*
+	 * start_field_bit_offset is the offset of the first bit of the field within
+	 * a field datum.
+	 */
+	obj_desc->common_field.start_field_bit_offset = (u8)
+	    (field_bit_position -
+	     ACPI_MUL_8(obj_desc->common_field.base_byte_offset));
+
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_prep_field_value
+ *
+ * PARAMETERS:  Info    - Contains all field creation info
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Construct an union acpi_operand_object of type def_field and
+ *              connect it to the parent Node.
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ex_prep_field_value(struct acpi_create_field_info *info)
+{
+	union acpi_operand_object *obj_desc;
+	union acpi_operand_object *second_desc = NULL;
+	acpi_status status;
+	u32 access_byte_width;
+	u32 type;
+
+	ACPI_FUNCTION_TRACE(ex_prep_field_value);
+
+	/* Parameter validation */
+
+	if (info->field_type != ACPI_TYPE_LOCAL_INDEX_FIELD) {
+		if (!info->region_node) {
+			ACPI_ERROR((AE_INFO, "Null RegionNode"));
+			return_ACPI_STATUS(AE_AML_NO_OPERAND);
+		}
+
+		type = acpi_ns_get_type(info->region_node);
+		if (type != ACPI_TYPE_REGION) {
+			ACPI_ERROR((AE_INFO,
+				    "Needed Region, found type 0x%X (%s)", type,
+				    acpi_ut_get_type_name(type)));
+
+			return_ACPI_STATUS(AE_AML_OPERAND_TYPE);
+		}
+	}
+
+	/* Allocate a new field object */
+
+	obj_desc = acpi_ut_create_internal_object(info->field_type);
+	if (!obj_desc) {
+		return_ACPI_STATUS(AE_NO_MEMORY);
+	}
+
+	/* Initialize areas of the object that are common to all fields */
+
+	obj_desc->common_field.node = info->field_node;
+	status = acpi_ex_prep_common_field_object(obj_desc,
+						  info->field_flags,
+						  info->attribute,
+						  info->field_bit_position,
+						  info->field_bit_length);
+	if (ACPI_FAILURE(status)) {
+		acpi_ut_delete_object_desc(obj_desc);
+		return_ACPI_STATUS(status);
+	}
+
+	/* Initialize areas of the object that are specific to the field type */
+
+	switch (info->field_type) {
+	case ACPI_TYPE_LOCAL_REGION_FIELD:
+
+		obj_desc->field.region_obj =
+		    acpi_ns_get_attached_object(info->region_node);
+
+		/* Fields specific to generic_serial_bus fields */
+
+		obj_desc->field.access_length = info->access_length;
+
+		if (info->connection_node) {
+			second_desc = info->connection_node->object;
+			if (!(second_desc->common.flags & AOPOBJ_DATA_VALID)) {
+				status =
+				    acpi_ds_get_buffer_arguments(second_desc);
+				if (ACPI_FAILURE(status)) {
+					acpi_ut_delete_object_desc(obj_desc);
+					return_ACPI_STATUS(status);
+				}
+			}
+
+			obj_desc->field.resource_buffer =
+			    second_desc->buffer.pointer;
+			obj_desc->field.resource_length =
+			    (u16)second_desc->buffer.length;
+		} else if (info->resource_buffer) {
+			obj_desc->field.resource_buffer = info->resource_buffer;
+			obj_desc->field.resource_length = info->resource_length;
+		}
+
+		/* Allow full data read from EC address space */
+
+		if ((obj_desc->field.region_obj->region.space_id ==
+		     ACPI_ADR_SPACE_EC)
+		    && (obj_desc->common_field.bit_length > 8)) {
+			access_byte_width =
+			    ACPI_ROUND_BITS_UP_TO_BYTES(obj_desc->common_field.
+							bit_length);
+
+			/* Maximum byte width supported is 255 */
+
+			if (access_byte_width < 256) {
+				obj_desc->common_field.access_byte_width =
+				    (u8)access_byte_width;
+			}
+		}
+
+		/* An additional reference for the container */
+
+		acpi_ut_add_reference(obj_desc->field.region_obj);
+
+		ACPI_DEBUG_PRINT((ACPI_DB_BFIELD,
+				  "RegionField: BitOff %X, Off %X, Gran %X, Region %p\n",
+				  obj_desc->field.start_field_bit_offset,
+				  obj_desc->field.base_byte_offset,
+				  obj_desc->field.access_byte_width,
+				  obj_desc->field.region_obj));
+		break;
+
+	case ACPI_TYPE_LOCAL_BANK_FIELD:
+
+		obj_desc->bank_field.value = info->bank_value;
+		obj_desc->bank_field.region_obj =
+		    acpi_ns_get_attached_object(info->region_node);
+		obj_desc->bank_field.bank_obj =
+		    acpi_ns_get_attached_object(info->register_node);
+
+		/* An additional reference for the attached objects */
+
+		acpi_ut_add_reference(obj_desc->bank_field.region_obj);
+		acpi_ut_add_reference(obj_desc->bank_field.bank_obj);
+
+		ACPI_DEBUG_PRINT((ACPI_DB_BFIELD,
+				  "Bank Field: BitOff %X, Off %X, Gran %X, Region %p, BankReg %p\n",
+				  obj_desc->bank_field.start_field_bit_offset,
+				  obj_desc->bank_field.base_byte_offset,
+				  obj_desc->field.access_byte_width,
+				  obj_desc->bank_field.region_obj,
+				  obj_desc->bank_field.bank_obj));
+
+		/*
+		 * Remember location in AML stream of the field unit
+		 * opcode and operands -- since the bank_value
+		 * operands must be evaluated.
+		 */
+		second_desc = obj_desc->common.next_object;
+		second_desc->extra.aml_start =
+		    ACPI_CAST_PTR(union acpi_parse_object,
+				  info->data_register_node)->named.data;
+		second_desc->extra.aml_length =
+		    ACPI_CAST_PTR(union acpi_parse_object,
+				  info->data_register_node)->named.length;
+
+		break;
+
+	case ACPI_TYPE_LOCAL_INDEX_FIELD:
+
+		/* Get the Index and Data registers */
+
+		obj_desc->index_field.index_obj =
+		    acpi_ns_get_attached_object(info->register_node);
+		obj_desc->index_field.data_obj =
+		    acpi_ns_get_attached_object(info->data_register_node);
+
+		if (!obj_desc->index_field.data_obj
+		    || !obj_desc->index_field.index_obj) {
+			ACPI_ERROR((AE_INFO,
+				    "Null Index Object during field prep"));
+			acpi_ut_delete_object_desc(obj_desc);
+			return_ACPI_STATUS(AE_AML_INTERNAL);
+		}
+
+		/* An additional reference for the attached objects */
+
+		acpi_ut_add_reference(obj_desc->index_field.data_obj);
+		acpi_ut_add_reference(obj_desc->index_field.index_obj);
+
+		/*
+		 * April 2006: Changed to match MS behavior
+		 *
+		 * The value written to the Index register is the byte offset of the
+		 * target field in units of the granularity of the index_field
+		 *
+		 * Previously, the value was calculated as an index in terms of the
+		 * width of the Data register, as below:
+		 *
+		 *      obj_desc->index_field.Value = (u32)
+		 *          (Info->field_bit_position / ACPI_MUL_8 (
+		 *              obj_desc->Field.access_byte_width));
+		 *
+		 * February 2006: Tried value as a byte offset:
+		 *      obj_desc->index_field.Value = (u32)
+		 *          ACPI_DIV_8 (Info->field_bit_position);
+		 */
+		obj_desc->index_field.value =
+		    (u32)ACPI_ROUND_DOWN(ACPI_DIV_8(info->field_bit_position),
+					 obj_desc->index_field.
+					 access_byte_width);
+
+		ACPI_DEBUG_PRINT((ACPI_DB_BFIELD,
+				  "IndexField: BitOff %X, Off %X, Value %X, Gran %X, Index %p, Data %p\n",
+				  obj_desc->index_field.start_field_bit_offset,
+				  obj_desc->index_field.base_byte_offset,
+				  obj_desc->index_field.value,
+				  obj_desc->field.access_byte_width,
+				  obj_desc->index_field.index_obj,
+				  obj_desc->index_field.data_obj));
+		break;
+
+	default:
+		/* No other types should get here */
+		break;
+	}
+
+	/*
+	 * Store the constructed descriptor (obj_desc) into the parent Node,
+	 * preserving the current type of that named_obj.
+	 */
+	status = acpi_ns_attach_object(info->field_node, obj_desc,
+				       acpi_ns_get_type(info->field_node));
+
+	ACPI_DEBUG_PRINT((ACPI_DB_BFIELD,
+			  "Set NamedObj %p [%4.4s], ObjDesc %p\n",
+			  info->field_node,
+			  acpi_ut_get_node_name(info->field_node), obj_desc));
+
+	/* Remove local reference to the object */
+
+	acpi_ut_remove_reference(obj_desc);
+	return_ACPI_STATUS(status);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exregion.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exregion.c
new file mode 100644
index 00000000..f7376126
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exregion.c
@@ -0,0 +1,520 @@
+
+/******************************************************************************
+ *
+ * Module Name: exregion - ACPI default op_region (address space) handlers
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acinterp.h"
+
+#define _COMPONENT          ACPI_EXECUTER
+ACPI_MODULE_NAME("exregion")
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_system_memory_space_handler
+ *
+ * PARAMETERS:  Function            - Read or Write operation
+ *              Address             - Where in the space to read or write
+ *              bit_width           - Field width in bits (8, 16, or 32)
+ *              Value               - Pointer to in or out value
+ *              handler_context     - Pointer to Handler's context
+ *              region_context      - Pointer to context specific to the
+ *                                    accessed region
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Handler for the System Memory address space (Op Region)
+ *
+ ******************************************************************************/
+acpi_status
+acpi_ex_system_memory_space_handler(u32 function,
+				    acpi_physical_address address,
+				    u32 bit_width,
+				    u64 *value,
+				    void *handler_context, void *region_context)
+{
+	acpi_status status = AE_OK;
+	void *logical_addr_ptr = NULL;
+	struct acpi_mem_space_context *mem_info = region_context;
+	u32 length;
+	acpi_size map_length;
+	acpi_size page_boundary_map_length;
+#ifdef ACPI_MISALIGNMENT_NOT_SUPPORTED
+	u32 remainder;
+#endif
+
+	ACPI_FUNCTION_TRACE(ex_system_memory_space_handler);
+
+	/* Validate and translate the bit width */
+
+	switch (bit_width) {
+	case 8:
+		length = 1;
+		break;
+
+	case 16:
+		length = 2;
+		break;
+
+	case 32:
+		length = 4;
+		break;
+
+	case 64:
+		length = 8;
+		break;
+
+	default:
+		ACPI_ERROR((AE_INFO, "Invalid SystemMemory width %u",
+			    bit_width));
+		return_ACPI_STATUS(AE_AML_OPERAND_VALUE);
+	}
+
+#ifdef ACPI_MISALIGNMENT_NOT_SUPPORTED
+	/*
+	 * Hardware does not support non-aligned data transfers, we must verify
+	 * the request.
+	 */
+	(void)acpi_ut_short_divide((u64)address, length, NULL, &remainder);
+	if (remainder != 0) {
+		return_ACPI_STATUS(AE_AML_ALIGNMENT);
+	}
+#endif
+
+	/*
+	 * Does the request fit into the cached memory mapping?
+	 * Is 1) Address below the current mapping? OR
+	 *    2) Address beyond the current mapping?
+	 */
+	if ((address < mem_info->mapped_physical_address) ||
+	    (((u64)address + length) > ((u64)
+					mem_info->mapped_physical_address +
+					mem_info->mapped_length))) {
+		/*
+		 * The request cannot be resolved by the current memory mapping;
+		 * Delete the existing mapping and create a new one.
+		 */
+		if (mem_info->mapped_length) {
+
+			/* Valid mapping, delete it */
+
+			acpi_os_unmap_memory(mem_info->mapped_logical_address,
+					     mem_info->mapped_length);
+		}
+
+		/*
+		 * October 2009: Attempt to map from the requested address to the
+		 * end of the region. However, we will never map more than one
+		 * page, nor will we cross a page boundary.
+		 */
+		map_length = (acpi_size)
+		    ((mem_info->address + mem_info->length) - address);
+
+		/*
+		 * If mapping the entire remaining portion of the region will cross
+		 * a page boundary, just map up to the page boundary, do not cross.
+		 * On some systems, crossing a page boundary while mapping regions
+		 * can cause warnings if the pages have different attributes
+		 * due to resource management.
+		 *
+		 * This has the added benefit of constraining a single mapping to
+		 * one page, which is similar to the original code that used a 4k
+		 * maximum window.
+		 */
+		page_boundary_map_length =
+		    ACPI_ROUND_UP(address, ACPI_DEFAULT_PAGE_SIZE) - address;
+		if (page_boundary_map_length == 0) {
+			page_boundary_map_length = ACPI_DEFAULT_PAGE_SIZE;
+		}
+
+		if (map_length > page_boundary_map_length) {
+			map_length = page_boundary_map_length;
+		}
+
+		/* Create a new mapping starting at the address given */
+
+		mem_info->mapped_logical_address = acpi_os_map_memory((acpi_physical_address) address, map_length);
+		if (!mem_info->mapped_logical_address) {
+			ACPI_ERROR((AE_INFO,
+				    "Could not map memory at 0x%8.8X%8.8X, size %u",
+				    ACPI_FORMAT_NATIVE_UINT(address),
+				    (u32)map_length));
+			mem_info->mapped_length = 0;
+			return_ACPI_STATUS(AE_NO_MEMORY);
+		}
+
+		/* Save the physical address and mapping size */
+
+		mem_info->mapped_physical_address = address;
+		mem_info->mapped_length = map_length;
+	}
+
+	/*
+	 * Generate a logical pointer corresponding to the address we want to
+	 * access
+	 */
+	logical_addr_ptr = mem_info->mapped_logical_address +
+	    ((u64)address - (u64)mem_info->mapped_physical_address);
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+			  "System-Memory (width %u) R/W %u Address=%8.8X%8.8X\n",
+			  bit_width, function,
+			  ACPI_FORMAT_NATIVE_UINT(address)));
+
+	/*
+	 * Perform the memory read or write
+	 *
+	 * Note: For machines that do not support non-aligned transfers, the target
+	 * address was checked for alignment above.  We do not attempt to break the
+	 * transfer up into smaller (byte-size) chunks because the AML specifically
+	 * asked for a transfer width that the hardware may require.
+	 */
+	switch (function) {
+	case ACPI_READ:
+
+		*value = 0;
+		switch (bit_width) {
+		case 8:
+			*value = (u64)ACPI_GET8(logical_addr_ptr);
+			break;
+
+		case 16:
+			*value = (u64)ACPI_GET16(logical_addr_ptr);
+			break;
+
+		case 32:
+			*value = (u64)ACPI_GET32(logical_addr_ptr);
+			break;
+
+		case 64:
+			*value = (u64)ACPI_GET64(logical_addr_ptr);
+			break;
+
+		default:
+			/* bit_width was already validated */
+			break;
+		}
+		break;
+
+	case ACPI_WRITE:
+
+		switch (bit_width) {
+		case 8:
+			ACPI_SET8(logical_addr_ptr) = (u8)*value;
+			break;
+
+		case 16:
+			ACPI_SET16(logical_addr_ptr) = (u16)*value;
+			break;
+
+		case 32:
+			ACPI_SET32(logical_addr_ptr) = (u32)*value;
+			break;
+
+		case 64:
+			ACPI_SET64(logical_addr_ptr) = (u64)*value;
+			break;
+
+		default:
+			/* bit_width was already validated */
+			break;
+		}
+		break;
+
+	default:
+		status = AE_BAD_PARAMETER;
+		break;
+	}
+
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_system_io_space_handler
+ *
+ * PARAMETERS:  Function            - Read or Write operation
+ *              Address             - Where in the space to read or write
+ *              bit_width           - Field width in bits (8, 16, or 32)
+ *              Value               - Pointer to in or out value
+ *              handler_context     - Pointer to Handler's context
+ *              region_context      - Pointer to context specific to the
+ *                                    accessed region
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Handler for the System IO address space (Op Region)
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ex_system_io_space_handler(u32 function,
+				acpi_physical_address address,
+				u32 bit_width,
+				u64 *value,
+				void *handler_context, void *region_context)
+{
+	acpi_status status = AE_OK;
+	u32 value32;
+
+	ACPI_FUNCTION_TRACE(ex_system_io_space_handler);
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+			  "System-IO (width %u) R/W %u Address=%8.8X%8.8X\n",
+			  bit_width, function,
+			  ACPI_FORMAT_NATIVE_UINT(address)));
+
+	/* Decode the function parameter */
+
+	switch (function) {
+	case ACPI_READ:
+
+		status = acpi_hw_read_port((acpi_io_address) address,
+					   &value32, bit_width);
+		*value = value32;
+		break;
+
+	case ACPI_WRITE:
+
+		status = acpi_hw_write_port((acpi_io_address) address,
+					    (u32)*value, bit_width);
+		break;
+
+	default:
+		status = AE_BAD_PARAMETER;
+		break;
+	}
+
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_pci_config_space_handler
+ *
+ * PARAMETERS:  Function            - Read or Write operation
+ *              Address             - Where in the space to read or write
+ *              bit_width           - Field width in bits (8, 16, or 32)
+ *              Value               - Pointer to in or out value
+ *              handler_context     - Pointer to Handler's context
+ *              region_context      - Pointer to context specific to the
+ *                                    accessed region
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Handler for the PCI Config address space (Op Region)
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ex_pci_config_space_handler(u32 function,
+				 acpi_physical_address address,
+				 u32 bit_width,
+				 u64 *value,
+				 void *handler_context, void *region_context)
+{
+	acpi_status status = AE_OK;
+	struct acpi_pci_id *pci_id;
+	u16 pci_register;
+
+	ACPI_FUNCTION_TRACE(ex_pci_config_space_handler);
+
+	/*
+	 *  The arguments to acpi_os(Read|Write)pci_configuration are:
+	 *
+	 *  pci_segment is the PCI bus segment range 0-31
+	 *  pci_bus     is the PCI bus number range 0-255
+	 *  pci_device  is the PCI device number range 0-31
+	 *  pci_function is the PCI device function number
+	 *  pci_register is the Config space register range 0-255 bytes
+	 *
+	 *  Value - input value for write, output address for read
+	 *
+	 */
+	pci_id = (struct acpi_pci_id *)region_context;
+	pci_register = (u16)(u32)address;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+			  "Pci-Config %u (%u) Seg(%04x) Bus(%04x) Dev(%04x) Func(%04x) Reg(%04x)\n",
+			  function, bit_width, pci_id->segment, pci_id->bus,
+			  pci_id->device, pci_id->function, pci_register));
+
+	switch (function) {
+	case ACPI_READ:
+
+		*value = 0;
+		status = acpi_os_read_pci_configuration(pci_id, pci_register,
+							value, bit_width);
+		break;
+
+	case ACPI_WRITE:
+
+		status = acpi_os_write_pci_configuration(pci_id, pci_register,
+							 *value, bit_width);
+		break;
+
+	default:
+
+		status = AE_BAD_PARAMETER;
+		break;
+	}
+
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_cmos_space_handler
+ *
+ * PARAMETERS:  Function            - Read or Write operation
+ *              Address             - Where in the space to read or write
+ *              bit_width           - Field width in bits (8, 16, or 32)
+ *              Value               - Pointer to in or out value
+ *              handler_context     - Pointer to Handler's context
+ *              region_context      - Pointer to context specific to the
+ *                                    accessed region
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Handler for the CMOS address space (Op Region)
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ex_cmos_space_handler(u32 function,
+			   acpi_physical_address address,
+			   u32 bit_width,
+			   u64 *value,
+			   void *handler_context, void *region_context)
+{
+	acpi_status status = AE_OK;
+
+	ACPI_FUNCTION_TRACE(ex_cmos_space_handler);
+
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_pci_bar_space_handler
+ *
+ * PARAMETERS:  Function            - Read or Write operation
+ *              Address             - Where in the space to read or write
+ *              bit_width           - Field width in bits (8, 16, or 32)
+ *              Value               - Pointer to in or out value
+ *              handler_context     - Pointer to Handler's context
+ *              region_context      - Pointer to context specific to the
+ *                                    accessed region
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Handler for the PCI bar_target address space (Op Region)
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ex_pci_bar_space_handler(u32 function,
+			      acpi_physical_address address,
+			      u32 bit_width,
+			      u64 *value,
+			      void *handler_context, void *region_context)
+{
+	acpi_status status = AE_OK;
+
+	ACPI_FUNCTION_TRACE(ex_pci_bar_space_handler);
+
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_data_table_space_handler
+ *
+ * PARAMETERS:  Function            - Read or Write operation
+ *              Address             - Where in the space to read or write
+ *              bit_width           - Field width in bits (8, 16, or 32)
+ *              Value               - Pointer to in or out value
+ *              handler_context     - Pointer to Handler's context
+ *              region_context      - Pointer to context specific to the
+ *                                    accessed region
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Handler for the Data Table address space (Op Region)
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ex_data_table_space_handler(u32 function,
+				 acpi_physical_address address,
+				 u32 bit_width,
+				 u64 *value,
+				 void *handler_context, void *region_context)
+{
+	ACPI_FUNCTION_TRACE(ex_data_table_space_handler);
+
+	/*
+	 * Perform the memory read or write. The bit_width was already
+	 * validated.
+	 */
+	switch (function) {
+	case ACPI_READ:
+
+		ACPI_MEMCPY(ACPI_CAST_PTR(char, value),
+			    ACPI_PHYSADDR_TO_PTR(address),
+			    ACPI_DIV_8(bit_width));
+		break;
+
+	case ACPI_WRITE:
+
+		ACPI_MEMCPY(ACPI_PHYSADDR_TO_PTR(address),
+			    ACPI_CAST_PTR(char, value), ACPI_DIV_8(bit_width));
+		break;
+
+	default:
+
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	return_ACPI_STATUS(AE_OK);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exresnte.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exresnte.c
new file mode 100644
index 00000000..610f2698
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exresnte.c
@@ -0,0 +1,278 @@
+
+/******************************************************************************
+ *
+ * Module Name: exresnte - AML Interpreter object resolution
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acdispat.h"
+#include "acinterp.h"
+#include "acnamesp.h"
+
+#define _COMPONENT          ACPI_EXECUTER
+ACPI_MODULE_NAME("exresnte")
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_resolve_node_to_value
+ *
+ * PARAMETERS:  object_ptr      - Pointer to a location that contains
+ *                                a pointer to a NS node, and will receive a
+ *                                pointer to the resolved object.
+ *              walk_state      - Current state.  Valid only if executing AML
+ *                                code.  NULL if simply resolving an object
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Resolve a Namespace node to a valued object
+ *
+ * Note: for some of the data types, the pointer attached to the Node
+ * can be either a pointer to an actual internal object or a pointer into the
+ * AML stream itself.  These types are currently:
+ *
+ *      ACPI_TYPE_INTEGER
+ *      ACPI_TYPE_STRING
+ *      ACPI_TYPE_BUFFER
+ *      ACPI_TYPE_MUTEX
+ *      ACPI_TYPE_PACKAGE
+ *
+ ******************************************************************************/
+acpi_status
+acpi_ex_resolve_node_to_value(struct acpi_namespace_node ** object_ptr,
+			      struct acpi_walk_state * walk_state)
+{
+	acpi_status status = AE_OK;
+	union acpi_operand_object *source_desc;
+	union acpi_operand_object *obj_desc = NULL;
+	struct acpi_namespace_node *node;
+	acpi_object_type entry_type;
+
+	ACPI_FUNCTION_TRACE(ex_resolve_node_to_value);
+
+	/*
+	 * The stack pointer points to a struct acpi_namespace_node (Node).  Get the
+	 * object that is attached to the Node.
+	 */
+	node = *object_ptr;
+	source_desc = acpi_ns_get_attached_object(node);
+	entry_type = acpi_ns_get_type((acpi_handle) node);
+
+	ACPI_DEBUG_PRINT((ACPI_DB_EXEC, "Entry=%p SourceDesc=%p [%s]\n",
+			  node, source_desc,
+			  acpi_ut_get_type_name(entry_type)));
+
+	if ((entry_type == ACPI_TYPE_LOCAL_ALIAS) ||
+	    (entry_type == ACPI_TYPE_LOCAL_METHOD_ALIAS)) {
+
+		/* There is always exactly one level of indirection */
+
+		node = ACPI_CAST_PTR(struct acpi_namespace_node, node->object);
+		source_desc = acpi_ns_get_attached_object(node);
+		entry_type = acpi_ns_get_type((acpi_handle) node);
+		*object_ptr = node;
+	}
+
+	/*
+	 * Several object types require no further processing:
+	 * 1) Device/Thermal objects don't have a "real" subobject, return the Node
+	 * 2) Method locals and arguments have a pseudo-Node
+	 * 3) 10/2007: Added method type to assist with Package construction.
+	 */
+	if ((entry_type == ACPI_TYPE_DEVICE) ||
+	    (entry_type == ACPI_TYPE_THERMAL) ||
+	    (entry_type == ACPI_TYPE_METHOD) ||
+	    (node->flags & (ANOBJ_METHOD_ARG | ANOBJ_METHOD_LOCAL))) {
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	if (!source_desc) {
+		ACPI_ERROR((AE_INFO, "No object attached to node %p", node));
+		return_ACPI_STATUS(AE_AML_NO_OPERAND);
+	}
+
+	/*
+	 * Action is based on the type of the Node, which indicates the type
+	 * of the attached object or pointer
+	 */
+	switch (entry_type) {
+	case ACPI_TYPE_PACKAGE:
+
+		if (source_desc->common.type != ACPI_TYPE_PACKAGE) {
+			ACPI_ERROR((AE_INFO, "Object not a Package, type %s",
+				    acpi_ut_get_object_type_name(source_desc)));
+			return_ACPI_STATUS(AE_AML_OPERAND_TYPE);
+		}
+
+		status = acpi_ds_get_package_arguments(source_desc);
+		if (ACPI_SUCCESS(status)) {
+
+			/* Return an additional reference to the object */
+
+			obj_desc = source_desc;
+			acpi_ut_add_reference(obj_desc);
+		}
+		break;
+
+	case ACPI_TYPE_BUFFER:
+
+		if (source_desc->common.type != ACPI_TYPE_BUFFER) {
+			ACPI_ERROR((AE_INFO, "Object not a Buffer, type %s",
+				    acpi_ut_get_object_type_name(source_desc)));
+			return_ACPI_STATUS(AE_AML_OPERAND_TYPE);
+		}
+
+		status = acpi_ds_get_buffer_arguments(source_desc);
+		if (ACPI_SUCCESS(status)) {
+
+			/* Return an additional reference to the object */
+
+			obj_desc = source_desc;
+			acpi_ut_add_reference(obj_desc);
+		}
+		break;
+
+	case ACPI_TYPE_STRING:
+
+		if (source_desc->common.type != ACPI_TYPE_STRING) {
+			ACPI_ERROR((AE_INFO, "Object not a String, type %s",
+				    acpi_ut_get_object_type_name(source_desc)));
+			return_ACPI_STATUS(AE_AML_OPERAND_TYPE);
+		}
+
+		/* Return an additional reference to the object */
+
+		obj_desc = source_desc;
+		acpi_ut_add_reference(obj_desc);
+		break;
+
+	case ACPI_TYPE_INTEGER:
+
+		if (source_desc->common.type != ACPI_TYPE_INTEGER) {
+			ACPI_ERROR((AE_INFO, "Object not a Integer, type %s",
+				    acpi_ut_get_object_type_name(source_desc)));
+			return_ACPI_STATUS(AE_AML_OPERAND_TYPE);
+		}
+
+		/* Return an additional reference to the object */
+
+		obj_desc = source_desc;
+		acpi_ut_add_reference(obj_desc);
+		break;
+
+	case ACPI_TYPE_BUFFER_FIELD:
+	case ACPI_TYPE_LOCAL_REGION_FIELD:
+	case ACPI_TYPE_LOCAL_BANK_FIELD:
+	case ACPI_TYPE_LOCAL_INDEX_FIELD:
+
+		ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
+				  "FieldRead Node=%p SourceDesc=%p Type=%X\n",
+				  node, source_desc, entry_type));
+
+		status =
+		    acpi_ex_read_data_from_field(walk_state, source_desc,
+						 &obj_desc);
+		break;
+
+		/* For these objects, just return the object attached to the Node */
+
+	case ACPI_TYPE_MUTEX:
+	case ACPI_TYPE_POWER:
+	case ACPI_TYPE_PROCESSOR:
+	case ACPI_TYPE_EVENT:
+	case ACPI_TYPE_REGION:
+
+		/* Return an additional reference to the object */
+
+		obj_desc = source_desc;
+		acpi_ut_add_reference(obj_desc);
+		break;
+
+		/* TYPE_ANY is untyped, and thus there is no object associated with it */
+
+	case ACPI_TYPE_ANY:
+
+		ACPI_ERROR((AE_INFO,
+			    "Untyped entry %p, no attached object!", node));
+
+		return_ACPI_STATUS(AE_AML_OPERAND_TYPE);	/* Cannot be AE_TYPE */
+
+	case ACPI_TYPE_LOCAL_REFERENCE:
+
+		switch (source_desc->reference.class) {
+		case ACPI_REFCLASS_TABLE:	/* This is a ddb_handle */
+		case ACPI_REFCLASS_REFOF:
+		case ACPI_REFCLASS_INDEX:
+
+			/* Return an additional reference to the object */
+
+			obj_desc = source_desc;
+			acpi_ut_add_reference(obj_desc);
+			break;
+
+		default:
+			/* No named references are allowed here */
+
+			ACPI_ERROR((AE_INFO,
+				    "Unsupported Reference type 0x%X",
+				    source_desc->reference.class));
+
+			return_ACPI_STATUS(AE_AML_OPERAND_TYPE);
+		}
+		break;
+
+	default:
+
+		/* Default case is for unknown types */
+
+		ACPI_ERROR((AE_INFO,
+			    "Node %p - Unknown object type 0x%X",
+			    node, entry_type));
+
+		return_ACPI_STATUS(AE_AML_OPERAND_TYPE);
+
+	}			/* switch (entry_type) */
+
+	/* Return the object descriptor */
+
+	*object_ptr = (void *)obj_desc;
+	return_ACPI_STATUS(status);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exresolv.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exresolv.c
new file mode 100644
index 00000000..1539d863
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exresolv.c
@@ -0,0 +1,551 @@
+
+/******************************************************************************
+ *
+ * Module Name: exresolv - AML Interpreter object resolution
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "amlcode.h"
+#include "acdispat.h"
+#include "acinterp.h"
+#include "acnamesp.h"
+
+#define _COMPONENT          ACPI_EXECUTER
+ACPI_MODULE_NAME("exresolv")
+
+/* Local prototypes */
+static acpi_status
+acpi_ex_resolve_object_to_value(union acpi_operand_object **stack_ptr,
+				struct acpi_walk_state *walk_state);
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_resolve_to_value
+ *
+ * PARAMETERS:  **stack_ptr         - Points to entry on obj_stack, which can
+ *                                    be either an (union acpi_operand_object *)
+ *                                    or an acpi_handle.
+ *              walk_state          - Current method state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Convert Reference objects to values
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ex_resolve_to_value(union acpi_operand_object **stack_ptr,
+			 struct acpi_walk_state *walk_state)
+{
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE_PTR(ex_resolve_to_value, stack_ptr);
+
+	if (!stack_ptr || !*stack_ptr) {
+		ACPI_ERROR((AE_INFO, "Internal - null pointer"));
+		return_ACPI_STATUS(AE_AML_NO_OPERAND);
+	}
+
+	/*
+	 * The entity pointed to by the stack_ptr can be either
+	 * 1) A valid union acpi_operand_object, or
+	 * 2) A struct acpi_namespace_node (named_obj)
+	 */
+	if (ACPI_GET_DESCRIPTOR_TYPE(*stack_ptr) == ACPI_DESC_TYPE_OPERAND) {
+		status = acpi_ex_resolve_object_to_value(stack_ptr, walk_state);
+		if (ACPI_FAILURE(status)) {
+			return_ACPI_STATUS(status);
+		}
+
+		if (!*stack_ptr) {
+			ACPI_ERROR((AE_INFO, "Internal - null pointer"));
+			return_ACPI_STATUS(AE_AML_NO_OPERAND);
+		}
+	}
+
+	/*
+	 * Object on the stack may have changed if acpi_ex_resolve_object_to_value()
+	 * was called (i.e., we can't use an _else_ here.)
+	 */
+	if (ACPI_GET_DESCRIPTOR_TYPE(*stack_ptr) == ACPI_DESC_TYPE_NAMED) {
+		status =
+		    acpi_ex_resolve_node_to_value(ACPI_CAST_INDIRECT_PTR
+						  (struct acpi_namespace_node,
+						   stack_ptr), walk_state);
+		if (ACPI_FAILURE(status)) {
+			return_ACPI_STATUS(status);
+		}
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_EXEC, "Resolved object %p\n", *stack_ptr));
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_resolve_object_to_value
+ *
+ * PARAMETERS:  stack_ptr       - Pointer to an internal object
+ *              walk_state      - Current method state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Retrieve the value from an internal object. The Reference type
+ *              uses the associated AML opcode to determine the value.
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ex_resolve_object_to_value(union acpi_operand_object **stack_ptr,
+				struct acpi_walk_state *walk_state)
+{
+	acpi_status status = AE_OK;
+	union acpi_operand_object *stack_desc;
+	union acpi_operand_object *obj_desc = NULL;
+	u8 ref_type;
+
+	ACPI_FUNCTION_TRACE(ex_resolve_object_to_value);
+
+	stack_desc = *stack_ptr;
+
+	/* This is an union acpi_operand_object    */
+
+	switch (stack_desc->common.type) {
+	case ACPI_TYPE_LOCAL_REFERENCE:
+
+		ref_type = stack_desc->reference.class;
+
+		switch (ref_type) {
+		case ACPI_REFCLASS_LOCAL:
+		case ACPI_REFCLASS_ARG:
+
+			/*
+			 * Get the local from the method's state info
+			 * Note: this increments the local's object reference count
+			 */
+			status = acpi_ds_method_data_get_value(ref_type,
+							       stack_desc->
+							       reference.value,
+							       walk_state,
+							       &obj_desc);
+			if (ACPI_FAILURE(status)) {
+				return_ACPI_STATUS(status);
+			}
+
+			ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
+					  "[Arg/Local %X] ValueObj is %p\n",
+					  stack_desc->reference.value,
+					  obj_desc));
+
+			/*
+			 * Now we can delete the original Reference Object and
+			 * replace it with the resolved value
+			 */
+			acpi_ut_remove_reference(stack_desc);
+			*stack_ptr = obj_desc;
+			break;
+
+		case ACPI_REFCLASS_INDEX:
+
+			switch (stack_desc->reference.target_type) {
+			case ACPI_TYPE_BUFFER_FIELD:
+
+				/* Just return - do not dereference */
+				break;
+
+			case ACPI_TYPE_PACKAGE:
+
+				/* If method call or copy_object - do not dereference */
+
+				if ((walk_state->opcode ==
+				     AML_INT_METHODCALL_OP)
+				    || (walk_state->opcode == AML_COPY_OP)) {
+					break;
+				}
+
+				/* Otherwise, dereference the package_index to a package element */
+
+				obj_desc = *stack_desc->reference.where;
+				if (obj_desc) {
+					/*
+					 * Valid object descriptor, copy pointer to return value
+					 * (i.e., dereference the package index)
+					 * Delete the ref object, increment the returned object
+					 */
+					acpi_ut_remove_reference(stack_desc);
+					acpi_ut_add_reference(obj_desc);
+					*stack_ptr = obj_desc;
+				} else {
+					/*
+					 * A NULL object descriptor means an uninitialized element of
+					 * the package, can't dereference it
+					 */
+					ACPI_ERROR((AE_INFO,
+						    "Attempt to dereference an Index to NULL package element Idx=%p",
+						    stack_desc));
+					status = AE_AML_UNINITIALIZED_ELEMENT;
+				}
+				break;
+
+			default:
+
+				/* Invalid reference object */
+
+				ACPI_ERROR((AE_INFO,
+					    "Unknown TargetType 0x%X in Index/Reference object %p",
+					    stack_desc->reference.target_type,
+					    stack_desc));
+				status = AE_AML_INTERNAL;
+				break;
+			}
+			break;
+
+		case ACPI_REFCLASS_REFOF:
+		case ACPI_REFCLASS_DEBUG:
+		case ACPI_REFCLASS_TABLE:
+
+			/* Just leave the object as-is, do not dereference */
+
+			break;
+
+		case ACPI_REFCLASS_NAME:	/* Reference to a named object */
+
+			/* Dereference the name */
+
+			if ((stack_desc->reference.node->type ==
+			     ACPI_TYPE_DEVICE)
+			    || (stack_desc->reference.node->type ==
+				ACPI_TYPE_THERMAL)) {
+
+				/* These node types do not have 'real' subobjects */
+
+				*stack_ptr = (void *)stack_desc->reference.node;
+			} else {
+				/* Get the object pointed to by the namespace node */
+
+				*stack_ptr =
+				    (stack_desc->reference.node)->object;
+				acpi_ut_add_reference(*stack_ptr);
+			}
+
+			acpi_ut_remove_reference(stack_desc);
+			break;
+
+		default:
+
+			ACPI_ERROR((AE_INFO,
+				    "Unknown Reference type 0x%X in %p",
+				    ref_type, stack_desc));
+			status = AE_AML_INTERNAL;
+			break;
+		}
+		break;
+
+	case ACPI_TYPE_BUFFER:
+
+		status = acpi_ds_get_buffer_arguments(stack_desc);
+		break;
+
+	case ACPI_TYPE_PACKAGE:
+
+		status = acpi_ds_get_package_arguments(stack_desc);
+		break;
+
+	case ACPI_TYPE_BUFFER_FIELD:
+	case ACPI_TYPE_LOCAL_REGION_FIELD:
+	case ACPI_TYPE_LOCAL_BANK_FIELD:
+	case ACPI_TYPE_LOCAL_INDEX_FIELD:
+
+		ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
+				  "FieldRead SourceDesc=%p Type=%X\n",
+				  stack_desc, stack_desc->common.type));
+
+		status =
+		    acpi_ex_read_data_from_field(walk_state, stack_desc,
+						 &obj_desc);
+
+		/* Remove a reference to the original operand, then override */
+
+		acpi_ut_remove_reference(*stack_ptr);
+		*stack_ptr = (void *)obj_desc;
+		break;
+
+	default:
+		break;
+	}
+
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_resolve_multiple
+ *
+ * PARAMETERS:  walk_state          - Current state (contains AML opcode)
+ *              Operand             - Starting point for resolution
+ *              return_type         - Where the object type is returned
+ *              return_desc         - Where the resolved object is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Return the base object and type.  Traverse a reference list if
+ *              necessary to get to the base object.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ex_resolve_multiple(struct acpi_walk_state *walk_state,
+			 union acpi_operand_object *operand,
+			 acpi_object_type * return_type,
+			 union acpi_operand_object **return_desc)
+{
+	union acpi_operand_object *obj_desc = (void *)operand;
+	struct acpi_namespace_node *node;
+	acpi_object_type type;
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(acpi_ex_resolve_multiple);
+
+	/* Operand can be either a namespace node or an operand descriptor */
+
+	switch (ACPI_GET_DESCRIPTOR_TYPE(obj_desc)) {
+	case ACPI_DESC_TYPE_OPERAND:
+		type = obj_desc->common.type;
+		break;
+
+	case ACPI_DESC_TYPE_NAMED:
+		type = ((struct acpi_namespace_node *)obj_desc)->type;
+		obj_desc =
+		    acpi_ns_get_attached_object((struct acpi_namespace_node *)
+						obj_desc);
+
+		/* If we had an Alias node, use the attached object for type info */
+
+		if (type == ACPI_TYPE_LOCAL_ALIAS) {
+			type = ((struct acpi_namespace_node *)obj_desc)->type;
+			obj_desc =
+			    acpi_ns_get_attached_object((struct
+							 acpi_namespace_node *)
+							obj_desc);
+		}
+		break;
+
+	default:
+		return_ACPI_STATUS(AE_AML_OPERAND_TYPE);
+	}
+
+	/* If type is anything other than a reference, we are done */
+
+	if (type != ACPI_TYPE_LOCAL_REFERENCE) {
+		goto exit;
+	}
+
+	/*
+	 * For reference objects created via the ref_of, Index, or Load/load_table
+	 * operators, we need to get to the base object (as per the ACPI
+	 * specification of the object_type and size_of operators). This means
+	 * traversing the list of possibly many nested references.
+	 */
+	while (obj_desc->common.type == ACPI_TYPE_LOCAL_REFERENCE) {
+		switch (obj_desc->reference.class) {
+		case ACPI_REFCLASS_REFOF:
+		case ACPI_REFCLASS_NAME:
+
+			/* Dereference the reference pointer */
+
+			if (obj_desc->reference.class == ACPI_REFCLASS_REFOF) {
+				node = obj_desc->reference.object;
+			} else {	/* AML_INT_NAMEPATH_OP */
+
+				node = obj_desc->reference.node;
+			}
+
+			/* All "References" point to a NS node */
+
+			if (ACPI_GET_DESCRIPTOR_TYPE(node) !=
+			    ACPI_DESC_TYPE_NAMED) {
+				ACPI_ERROR((AE_INFO,
+					    "Not a namespace node %p [%s]",
+					    node,
+					    acpi_ut_get_descriptor_name(node)));
+				return_ACPI_STATUS(AE_AML_INTERNAL);
+			}
+
+			/* Get the attached object */
+
+			obj_desc = acpi_ns_get_attached_object(node);
+			if (!obj_desc) {
+
+				/* No object, use the NS node type */
+
+				type = acpi_ns_get_type(node);
+				goto exit;
+			}
+
+			/* Check for circular references */
+
+			if (obj_desc == operand) {
+				return_ACPI_STATUS(AE_AML_CIRCULAR_REFERENCE);
+			}
+			break;
+
+		case ACPI_REFCLASS_INDEX:
+
+			/* Get the type of this reference (index into another object) */
+
+			type = obj_desc->reference.target_type;
+			if (type != ACPI_TYPE_PACKAGE) {
+				goto exit;
+			}
+
+			/*
+			 * The main object is a package, we want to get the type
+			 * of the individual package element that is referenced by
+			 * the index.
+			 *
+			 * This could of course in turn be another reference object.
+			 */
+			obj_desc = *(obj_desc->reference.where);
+			if (!obj_desc) {
+
+				/* NULL package elements are allowed */
+
+				type = 0;	/* Uninitialized */
+				goto exit;
+			}
+			break;
+
+		case ACPI_REFCLASS_TABLE:
+
+			type = ACPI_TYPE_DDB_HANDLE;
+			goto exit;
+
+		case ACPI_REFCLASS_LOCAL:
+		case ACPI_REFCLASS_ARG:
+
+			if (return_desc) {
+				status =
+				    acpi_ds_method_data_get_value(obj_desc->
+								  reference.
+								  class,
+								  obj_desc->
+								  reference.
+								  value,
+								  walk_state,
+								  &obj_desc);
+				if (ACPI_FAILURE(status)) {
+					return_ACPI_STATUS(status);
+				}
+				acpi_ut_remove_reference(obj_desc);
+			} else {
+				status =
+				    acpi_ds_method_data_get_node(obj_desc->
+								 reference.
+								 class,
+								 obj_desc->
+								 reference.
+								 value,
+								 walk_state,
+								 &node);
+				if (ACPI_FAILURE(status)) {
+					return_ACPI_STATUS(status);
+				}
+
+				obj_desc = acpi_ns_get_attached_object(node);
+				if (!obj_desc) {
+					type = ACPI_TYPE_ANY;
+					goto exit;
+				}
+			}
+			break;
+
+		case ACPI_REFCLASS_DEBUG:
+
+			/* The Debug Object is of type "DebugObject" */
+
+			type = ACPI_TYPE_DEBUG_OBJECT;
+			goto exit;
+
+		default:
+
+			ACPI_ERROR((AE_INFO,
+				    "Unknown Reference Class 0x%2.2X",
+				    obj_desc->reference.class));
+			return_ACPI_STATUS(AE_AML_INTERNAL);
+		}
+	}
+
+	/*
+	 * Now we are guaranteed to have an object that has not been created
+	 * via the ref_of or Index operators.
+	 */
+	type = obj_desc->common.type;
+
+      exit:
+	/* Convert internal types to external types */
+
+	switch (type) {
+	case ACPI_TYPE_LOCAL_REGION_FIELD:
+	case ACPI_TYPE_LOCAL_BANK_FIELD:
+	case ACPI_TYPE_LOCAL_INDEX_FIELD:
+
+		type = ACPI_TYPE_FIELD_UNIT;
+		break;
+
+	case ACPI_TYPE_LOCAL_SCOPE:
+
+		/* Per ACPI Specification, Scope is untyped */
+
+		type = ACPI_TYPE_ANY;
+		break;
+
+	default:
+		/* No change to Type required */
+		break;
+	}
+
+	*return_type = type;
+	if (return_desc) {
+		*return_desc = obj_desc;
+	}
+	return_ACPI_STATUS(AE_OK);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exresop.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exresop.c
new file mode 100644
index 00000000..5acdd863
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exresop.c
@@ -0,0 +1,701 @@
+
+/******************************************************************************
+ *
+ * Module Name: exresop - AML Interpreter operand/object resolution
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "amlcode.h"
+#include "acparser.h"
+#include "acinterp.h"
+#include "acnamesp.h"
+
+#define _COMPONENT          ACPI_EXECUTER
+ACPI_MODULE_NAME("exresop")
+
+/* Local prototypes */
+static acpi_status
+acpi_ex_check_object_type(acpi_object_type type_needed,
+			  acpi_object_type this_type, void *object);
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_check_object_type
+ *
+ * PARAMETERS:  type_needed         Object type needed
+ *              this_type           Actual object type
+ *              Object              Object pointer
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Check required type against actual type
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ex_check_object_type(acpi_object_type type_needed,
+			  acpi_object_type this_type, void *object)
+{
+	ACPI_FUNCTION_ENTRY();
+
+	if (type_needed == ACPI_TYPE_ANY) {
+
+		/* All types OK, so we don't perform any typechecks */
+
+		return (AE_OK);
+	}
+
+	if (type_needed == ACPI_TYPE_LOCAL_REFERENCE) {
+		/*
+		 * Allow the AML "Constant" opcodes (Zero, One, etc.) to be reference
+		 * objects and thus allow them to be targets.  (As per the ACPI
+		 * specification, a store to a constant is a noop.)
+		 */
+		if ((this_type == ACPI_TYPE_INTEGER) &&
+		    (((union acpi_operand_object *)object)->common.
+		     flags & AOPOBJ_AML_CONSTANT)) {
+			return (AE_OK);
+		}
+	}
+
+	if (type_needed != this_type) {
+		ACPI_ERROR((AE_INFO,
+			    "Needed type [%s], found [%s] %p",
+			    acpi_ut_get_type_name(type_needed),
+			    acpi_ut_get_type_name(this_type), object));
+
+		return (AE_AML_OPERAND_TYPE);
+	}
+
+	return (AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_resolve_operands
+ *
+ * PARAMETERS:  Opcode              - Opcode being interpreted
+ *              stack_ptr           - Pointer to the operand stack to be
+ *                                    resolved
+ *              walk_state          - Current state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Convert multiple input operands to the types required by the
+ *              target operator.
+ *
+ *      Each 5-bit group in arg_types represents one required
+ *      operand and indicates the required Type. The corresponding operand
+ *      will be converted to the required type if possible, otherwise we
+ *      abort with an exception.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ex_resolve_operands(u16 opcode,
+			 union acpi_operand_object **stack_ptr,
+			 struct acpi_walk_state * walk_state)
+{
+	union acpi_operand_object *obj_desc;
+	acpi_status status = AE_OK;
+	u8 object_type;
+	u32 arg_types;
+	const struct acpi_opcode_info *op_info;
+	u32 this_arg_type;
+	acpi_object_type type_needed;
+	u16 target_op = 0;
+
+	ACPI_FUNCTION_TRACE_U32(ex_resolve_operands, opcode);
+
+	op_info = acpi_ps_get_opcode_info(opcode);
+	if (op_info->class == AML_CLASS_UNKNOWN) {
+		return_ACPI_STATUS(AE_AML_BAD_OPCODE);
+	}
+
+	arg_types = op_info->runtime_args;
+	if (arg_types == ARGI_INVALID_OPCODE) {
+		ACPI_ERROR((AE_INFO, "Unknown AML opcode 0x%X", opcode));
+
+		return_ACPI_STATUS(AE_AML_INTERNAL);
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
+			  "Opcode %X [%s] RequiredOperandTypes=%8.8X\n",
+			  opcode, op_info->name, arg_types));
+
+	/*
+	 * Normal exit is with (arg_types == 0) at end of argument list.
+	 * Function will return an exception from within the loop upon
+	 * finding an entry which is not (or cannot be converted
+	 * to) the required type; if stack underflows; or upon
+	 * finding a NULL stack entry (which should not happen).
+	 */
+	while (GET_CURRENT_ARG_TYPE(arg_types)) {
+		if (!stack_ptr || !*stack_ptr) {
+			ACPI_ERROR((AE_INFO, "Null stack entry at %p",
+				    stack_ptr));
+
+			return_ACPI_STATUS(AE_AML_INTERNAL);
+		}
+
+		/* Extract useful items */
+
+		obj_desc = *stack_ptr;
+
+		/* Decode the descriptor type */
+
+		switch (ACPI_GET_DESCRIPTOR_TYPE(obj_desc)) {
+		case ACPI_DESC_TYPE_NAMED:
+
+			/* Namespace Node */
+
+			object_type =
+			    ((struct acpi_namespace_node *)obj_desc)->type;
+
+			/*
+			 * Resolve an alias object. The construction of these objects
+			 * guarantees that there is only one level of alias indirection;
+			 * thus, the attached object is always the aliased namespace node
+			 */
+			if (object_type == ACPI_TYPE_LOCAL_ALIAS) {
+				obj_desc =
+				    acpi_ns_get_attached_object((struct
+								 acpi_namespace_node
+								 *)obj_desc);
+				*stack_ptr = obj_desc;
+				object_type =
+				    ((struct acpi_namespace_node *)obj_desc)->
+				    type;
+			}
+			break;
+
+		case ACPI_DESC_TYPE_OPERAND:
+
+			/* ACPI internal object */
+
+			object_type = obj_desc->common.type;
+
+			/* Check for bad acpi_object_type */
+
+			if (!acpi_ut_valid_object_type(object_type)) {
+				ACPI_ERROR((AE_INFO,
+					    "Bad operand object type [0x%X]",
+					    object_type));
+
+				return_ACPI_STATUS(AE_AML_OPERAND_TYPE);
+			}
+
+			if (object_type == (u8)ACPI_TYPE_LOCAL_REFERENCE) {
+
+				/* Validate the Reference */
+
+				switch (obj_desc->reference.class) {
+				case ACPI_REFCLASS_DEBUG:
+
+					target_op = AML_DEBUG_OP;
+
+					/*lint -fallthrough */
+
+				case ACPI_REFCLASS_ARG:
+				case ACPI_REFCLASS_LOCAL:
+				case ACPI_REFCLASS_INDEX:
+				case ACPI_REFCLASS_REFOF:
+				case ACPI_REFCLASS_TABLE:	/* ddb_handle from LOAD_OP or LOAD_TABLE_OP */
+				case ACPI_REFCLASS_NAME:	/* Reference to a named object */
+
+					ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
+							  "Operand is a Reference, Class [%s] %2.2X\n",
+							  acpi_ut_get_reference_name
+							  (obj_desc),
+							  obj_desc->reference.
+							  class));
+					break;
+
+				default:
+
+					ACPI_ERROR((AE_INFO,
+						    "Unknown Reference Class 0x%2.2X in %p",
+						    obj_desc->reference.class,
+						    obj_desc));
+
+					return_ACPI_STATUS(AE_AML_OPERAND_TYPE);
+				}
+			}
+			break;
+
+		default:
+
+			/* Invalid descriptor */
+
+			ACPI_ERROR((AE_INFO, "Invalid descriptor %p [%s]",
+				    obj_desc,
+				    acpi_ut_get_descriptor_name(obj_desc)));
+
+			return_ACPI_STATUS(AE_AML_OPERAND_TYPE);
+		}
+
+		/* Get one argument type, point to the next */
+
+		this_arg_type = GET_CURRENT_ARG_TYPE(arg_types);
+		INCREMENT_ARG_LIST(arg_types);
+
+		/*
+		 * Handle cases where the object does not need to be
+		 * resolved to a value
+		 */
+		switch (this_arg_type) {
+		case ARGI_REF_OR_STRING:	/* Can be a String or Reference */
+
+			if ((ACPI_GET_DESCRIPTOR_TYPE(obj_desc) ==
+			     ACPI_DESC_TYPE_OPERAND)
+			    && (obj_desc->common.type == ACPI_TYPE_STRING)) {
+				/*
+				 * String found - the string references a named object and
+				 * must be resolved to a node
+				 */
+				goto next_operand;
+			}
+
+			/*
+			 * Else not a string - fall through to the normal Reference
+			 * case below
+			 */
+			/*lint -fallthrough */
+
+		case ARGI_REFERENCE:	/* References: */
+		case ARGI_INTEGER_REF:
+		case ARGI_OBJECT_REF:
+		case ARGI_DEVICE_REF:
+		case ARGI_TARGETREF:	/* Allows implicit conversion rules before store */
+		case ARGI_FIXED_TARGET:	/* No implicit conversion before store to target */
+		case ARGI_SIMPLE_TARGET:	/* Name, Local, or Arg - no implicit conversion  */
+
+			/*
+			 * Need an operand of type ACPI_TYPE_LOCAL_REFERENCE
+			 * A Namespace Node is OK as-is
+			 */
+			if (ACPI_GET_DESCRIPTOR_TYPE(obj_desc) ==
+			    ACPI_DESC_TYPE_NAMED) {
+				goto next_operand;
+			}
+
+			status =
+			    acpi_ex_check_object_type(ACPI_TYPE_LOCAL_REFERENCE,
+						      object_type, obj_desc);
+			if (ACPI_FAILURE(status)) {
+				return_ACPI_STATUS(status);
+			}
+			goto next_operand;
+
+		case ARGI_DATAREFOBJ:	/* Store operator only */
+
+			/*
+			 * We don't want to resolve index_op reference objects during
+			 * a store because this would be an implicit de_ref_of operation.
+			 * Instead, we just want to store the reference object.
+			 * -- All others must be resolved below.
+			 */
+			if ((opcode == AML_STORE_OP) &&
+			    ((*stack_ptr)->common.type ==
+			     ACPI_TYPE_LOCAL_REFERENCE)
+			    && ((*stack_ptr)->reference.class ==
+				ACPI_REFCLASS_INDEX)) {
+				goto next_operand;
+			}
+			break;
+
+		default:
+			/* All cases covered above */
+			break;
+		}
+
+		/*
+		 * Resolve this object to a value
+		 */
+		status = acpi_ex_resolve_to_value(stack_ptr, walk_state);
+		if (ACPI_FAILURE(status)) {
+			return_ACPI_STATUS(status);
+		}
+
+		/* Get the resolved object */
+
+		obj_desc = *stack_ptr;
+
+		/*
+		 * Check the resulting object (value) type
+		 */
+		switch (this_arg_type) {
+			/*
+			 * For the simple cases, only one type of resolved object
+			 * is allowed
+			 */
+		case ARGI_MUTEX:
+
+			/* Need an operand of type ACPI_TYPE_MUTEX */
+
+			type_needed = ACPI_TYPE_MUTEX;
+			break;
+
+		case ARGI_EVENT:
+
+			/* Need an operand of type ACPI_TYPE_EVENT */
+
+			type_needed = ACPI_TYPE_EVENT;
+			break;
+
+		case ARGI_PACKAGE:	/* Package */
+
+			/* Need an operand of type ACPI_TYPE_PACKAGE */
+
+			type_needed = ACPI_TYPE_PACKAGE;
+			break;
+
+		case ARGI_ANYTYPE:
+
+			/* Any operand type will do */
+
+			type_needed = ACPI_TYPE_ANY;
+			break;
+
+		case ARGI_DDBHANDLE:
+
+			/* Need an operand of type ACPI_TYPE_DDB_HANDLE */
+
+			type_needed = ACPI_TYPE_LOCAL_REFERENCE;
+			break;
+
+			/*
+			 * The more complex cases allow multiple resolved object types
+			 */
+		case ARGI_INTEGER:
+
+			/*
+			 * Need an operand of type ACPI_TYPE_INTEGER,
+			 * But we can implicitly convert from a STRING or BUFFER
+			 * Aka - "Implicit Source Operand Conversion"
+			 */
+			status =
+			    acpi_ex_convert_to_integer(obj_desc, stack_ptr, 16);
+			if (ACPI_FAILURE(status)) {
+				if (status == AE_TYPE) {
+					ACPI_ERROR((AE_INFO,
+						    "Needed [Integer/String/Buffer], found [%s] %p",
+						    acpi_ut_get_object_type_name
+						    (obj_desc), obj_desc));
+
+					return_ACPI_STATUS(AE_AML_OPERAND_TYPE);
+				}
+
+				return_ACPI_STATUS(status);
+			}
+
+			if (obj_desc != *stack_ptr) {
+				acpi_ut_remove_reference(obj_desc);
+			}
+			goto next_operand;
+
+		case ARGI_BUFFER:
+
+			/*
+			 * Need an operand of type ACPI_TYPE_BUFFER,
+			 * But we can implicitly convert from a STRING or INTEGER
+			 * Aka - "Implicit Source Operand Conversion"
+			 */
+			status = acpi_ex_convert_to_buffer(obj_desc, stack_ptr);
+			if (ACPI_FAILURE(status)) {
+				if (status == AE_TYPE) {
+					ACPI_ERROR((AE_INFO,
+						    "Needed [Integer/String/Buffer], found [%s] %p",
+						    acpi_ut_get_object_type_name
+						    (obj_desc), obj_desc));
+
+					return_ACPI_STATUS(AE_AML_OPERAND_TYPE);
+				}
+
+				return_ACPI_STATUS(status);
+			}
+
+			if (obj_desc != *stack_ptr) {
+				acpi_ut_remove_reference(obj_desc);
+			}
+			goto next_operand;
+
+		case ARGI_STRING:
+
+			/*
+			 * Need an operand of type ACPI_TYPE_STRING,
+			 * But we can implicitly convert from a BUFFER or INTEGER
+			 * Aka - "Implicit Source Operand Conversion"
+			 */
+			status = acpi_ex_convert_to_string(obj_desc, stack_ptr,
+							   ACPI_IMPLICIT_CONVERT_HEX);
+			if (ACPI_FAILURE(status)) {
+				if (status == AE_TYPE) {
+					ACPI_ERROR((AE_INFO,
+						    "Needed [Integer/String/Buffer], found [%s] %p",
+						    acpi_ut_get_object_type_name
+						    (obj_desc), obj_desc));
+
+					return_ACPI_STATUS(AE_AML_OPERAND_TYPE);
+				}
+
+				return_ACPI_STATUS(status);
+			}
+
+			if (obj_desc != *stack_ptr) {
+				acpi_ut_remove_reference(obj_desc);
+			}
+			goto next_operand;
+
+		case ARGI_COMPUTEDATA:
+
+			/* Need an operand of type INTEGER, STRING or BUFFER */
+
+			switch (obj_desc->common.type) {
+			case ACPI_TYPE_INTEGER:
+			case ACPI_TYPE_STRING:
+			case ACPI_TYPE_BUFFER:
+
+				/* Valid operand */
+				break;
+
+			default:
+				ACPI_ERROR((AE_INFO,
+					    "Needed [Integer/String/Buffer], found [%s] %p",
+					    acpi_ut_get_object_type_name
+					    (obj_desc), obj_desc));
+
+				return_ACPI_STATUS(AE_AML_OPERAND_TYPE);
+			}
+			goto next_operand;
+
+		case ARGI_BUFFER_OR_STRING:
+
+			/* Need an operand of type STRING or BUFFER */
+
+			switch (obj_desc->common.type) {
+			case ACPI_TYPE_STRING:
+			case ACPI_TYPE_BUFFER:
+
+				/* Valid operand */
+				break;
+
+			case ACPI_TYPE_INTEGER:
+
+				/* Highest priority conversion is to type Buffer */
+
+				status =
+				    acpi_ex_convert_to_buffer(obj_desc,
+							      stack_ptr);
+				if (ACPI_FAILURE(status)) {
+					return_ACPI_STATUS(status);
+				}
+
+				if (obj_desc != *stack_ptr) {
+					acpi_ut_remove_reference(obj_desc);
+				}
+				break;
+
+			default:
+				ACPI_ERROR((AE_INFO,
+					    "Needed [Integer/String/Buffer], found [%s] %p",
+					    acpi_ut_get_object_type_name
+					    (obj_desc), obj_desc));
+
+				return_ACPI_STATUS(AE_AML_OPERAND_TYPE);
+			}
+			goto next_operand;
+
+		case ARGI_DATAOBJECT:
+			/*
+			 * ARGI_DATAOBJECT is only used by the size_of operator.
+			 * Need a buffer, string, package, or ref_of reference.
+			 *
+			 * The only reference allowed here is a direct reference to
+			 * a namespace node.
+			 */
+			switch (obj_desc->common.type) {
+			case ACPI_TYPE_PACKAGE:
+			case ACPI_TYPE_STRING:
+			case ACPI_TYPE_BUFFER:
+			case ACPI_TYPE_LOCAL_REFERENCE:
+
+				/* Valid operand */
+				break;
+
+			default:
+				ACPI_ERROR((AE_INFO,
+					    "Needed [Buffer/String/Package/Reference], found [%s] %p",
+					    acpi_ut_get_object_type_name
+					    (obj_desc), obj_desc));
+
+				return_ACPI_STATUS(AE_AML_OPERAND_TYPE);
+			}
+			goto next_operand;
+
+		case ARGI_COMPLEXOBJ:
+
+			/* Need a buffer or package or (ACPI 2.0) String */
+
+			switch (obj_desc->common.type) {
+			case ACPI_TYPE_PACKAGE:
+			case ACPI_TYPE_STRING:
+			case ACPI_TYPE_BUFFER:
+
+				/* Valid operand */
+				break;
+
+			default:
+				ACPI_ERROR((AE_INFO,
+					    "Needed [Buffer/String/Package], found [%s] %p",
+					    acpi_ut_get_object_type_name
+					    (obj_desc), obj_desc));
+
+				return_ACPI_STATUS(AE_AML_OPERAND_TYPE);
+			}
+			goto next_operand;
+
+		case ARGI_REGION_OR_BUFFER:	/* Used by Load() only */
+
+			/* Need an operand of type REGION or a BUFFER (which could be a resolved region field) */
+
+			switch (obj_desc->common.type) {
+			case ACPI_TYPE_BUFFER:
+			case ACPI_TYPE_REGION:
+
+				/* Valid operand */
+				break;
+
+			default:
+				ACPI_ERROR((AE_INFO,
+					    "Needed [Region/Buffer], found [%s] %p",
+					    acpi_ut_get_object_type_name
+					    (obj_desc), obj_desc));
+
+				return_ACPI_STATUS(AE_AML_OPERAND_TYPE);
+			}
+			goto next_operand;
+
+		case ARGI_DATAREFOBJ:
+
+			/* Used by the Store() operator only */
+
+			switch (obj_desc->common.type) {
+			case ACPI_TYPE_INTEGER:
+			case ACPI_TYPE_PACKAGE:
+			case ACPI_TYPE_STRING:
+			case ACPI_TYPE_BUFFER:
+			case ACPI_TYPE_BUFFER_FIELD:
+			case ACPI_TYPE_LOCAL_REFERENCE:
+			case ACPI_TYPE_LOCAL_REGION_FIELD:
+			case ACPI_TYPE_LOCAL_BANK_FIELD:
+			case ACPI_TYPE_LOCAL_INDEX_FIELD:
+			case ACPI_TYPE_DDB_HANDLE:
+
+				/* Valid operand */
+				break;
+
+			default:
+
+				if (acpi_gbl_enable_interpreter_slack) {
+					/*
+					 * Enable original behavior of Store(), allowing any and all
+					 * objects as the source operand.  The ACPI spec does not
+					 * allow this, however.
+					 */
+					break;
+				}
+
+				if (target_op == AML_DEBUG_OP) {
+
+					/* Allow store of any object to the Debug object */
+
+					break;
+				}
+
+				ACPI_ERROR((AE_INFO,
+					    "Needed Integer/Buffer/String/Package/Ref/Ddb], found [%s] %p",
+					    acpi_ut_get_object_type_name
+					    (obj_desc), obj_desc));
+
+				return_ACPI_STATUS(AE_AML_OPERAND_TYPE);
+			}
+			goto next_operand;
+
+		default:
+
+			/* Unknown type */
+
+			ACPI_ERROR((AE_INFO,
+				    "Internal - Unknown ARGI (required operand) type 0x%X",
+				    this_arg_type));
+
+			return_ACPI_STATUS(AE_BAD_PARAMETER);
+		}
+
+		/*
+		 * Make sure that the original object was resolved to the
+		 * required object type (Simple cases only).
+		 */
+		status = acpi_ex_check_object_type(type_needed,
+						   (*stack_ptr)->common.type,
+						   *stack_ptr);
+		if (ACPI_FAILURE(status)) {
+			return_ACPI_STATUS(status);
+		}
+
+	      next_operand:
+		/*
+		 * If more operands needed, decrement stack_ptr to point
+		 * to next operand on stack
+		 */
+		if (GET_CURRENT_ARG_TYPE(arg_types)) {
+			stack_ptr--;
+		}
+	}
+
+	ACPI_DUMP_OPERANDS(walk_state->operands,
+			   acpi_ps_get_opcode_name(opcode),
+			   walk_state->num_operands);
+
+	return_ACPI_STATUS(status);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exstore.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exstore.c
new file mode 100644
index 00000000..c1afb60b
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exstore.c
@@ -0,0 +1,502 @@
+/******************************************************************************
+ *
+ * Module Name: exstore - AML Interpreter object store support
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acdispat.h"
+#include "acinterp.h"
+#include "amlcode.h"
+#include "acnamesp.h"
+
+#define _COMPONENT          ACPI_EXECUTER
+ACPI_MODULE_NAME("exstore")
+
+/* Local prototypes */
+static acpi_status
+acpi_ex_store_object_to_index(union acpi_operand_object *val_desc,
+			      union acpi_operand_object *dest_desc,
+			      struct acpi_walk_state *walk_state);
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_store
+ *
+ * PARAMETERS:  *source_desc        - Value to be stored
+ *              *dest_desc          - Where to store it.  Must be an NS node
+ *                                    or an union acpi_operand_object of type
+ *                                    Reference;
+ *              walk_state          - Current walk state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Store the value described by source_desc into the location
+ *              described by dest_desc. Called by various interpreter
+ *              functions to store the result of an operation into
+ *              the destination operand -- not just simply the actual "Store"
+ *              ASL operator.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ex_store(union acpi_operand_object *source_desc,
+	      union acpi_operand_object *dest_desc,
+	      struct acpi_walk_state *walk_state)
+{
+	acpi_status status = AE_OK;
+	union acpi_operand_object *ref_desc = dest_desc;
+
+	ACPI_FUNCTION_TRACE_PTR(ex_store, dest_desc);
+
+	/* Validate parameters */
+
+	if (!source_desc || !dest_desc) {
+		ACPI_ERROR((AE_INFO, "Null parameter"));
+		return_ACPI_STATUS(AE_AML_NO_OPERAND);
+	}
+
+	/* dest_desc can be either a namespace node or an ACPI object */
+
+	if (ACPI_GET_DESCRIPTOR_TYPE(dest_desc) == ACPI_DESC_TYPE_NAMED) {
+		/*
+		 * Dest is a namespace node,
+		 * Storing an object into a Named node.
+		 */
+		status = acpi_ex_store_object_to_node(source_desc,
+						      (struct
+						       acpi_namespace_node *)
+						      dest_desc, walk_state,
+						      ACPI_IMPLICIT_CONVERSION);
+
+		return_ACPI_STATUS(status);
+	}
+
+	/* Destination object must be a Reference or a Constant object */
+
+	switch (dest_desc->common.type) {
+	case ACPI_TYPE_LOCAL_REFERENCE:
+		break;
+
+	case ACPI_TYPE_INTEGER:
+
+		/* Allow stores to Constants -- a Noop as per ACPI spec */
+
+		if (dest_desc->common.flags & AOPOBJ_AML_CONSTANT) {
+			return_ACPI_STATUS(AE_OK);
+		}
+
+		/*lint -fallthrough */
+
+	default:
+
+		/* Destination is not a Reference object */
+
+		ACPI_ERROR((AE_INFO,
+			    "Target is not a Reference or Constant object - %s [%p]",
+			    acpi_ut_get_object_type_name(dest_desc),
+			    dest_desc));
+
+		return_ACPI_STATUS(AE_AML_OPERAND_TYPE);
+	}
+
+	/*
+	 * Examine the Reference class. These cases are handled:
+	 *
+	 * 1) Store to Name (Change the object associated with a name)
+	 * 2) Store to an indexed area of a Buffer or Package
+	 * 3) Store to a Method Local or Arg
+	 * 4) Store to the debug object
+	 */
+	switch (ref_desc->reference.class) {
+	case ACPI_REFCLASS_REFOF:
+
+		/* Storing an object into a Name "container" */
+
+		status = acpi_ex_store_object_to_node(source_desc,
+						      ref_desc->reference.
+						      object, walk_state,
+						      ACPI_IMPLICIT_CONVERSION);
+		break;
+
+	case ACPI_REFCLASS_INDEX:
+
+		/* Storing to an Index (pointer into a packager or buffer) */
+
+		status =
+		    acpi_ex_store_object_to_index(source_desc, ref_desc,
+						  walk_state);
+		break;
+
+	case ACPI_REFCLASS_LOCAL:
+	case ACPI_REFCLASS_ARG:
+
+		/* Store to a method local/arg  */
+
+		status =
+		    acpi_ds_store_object_to_local(ref_desc->reference.class,
+						  ref_desc->reference.value,
+						  source_desc, walk_state);
+		break;
+
+	case ACPI_REFCLASS_DEBUG:
+
+		/*
+		 * Storing to the Debug object causes the value stored to be
+		 * displayed and otherwise has no effect -- see ACPI Specification
+		 */
+		ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
+				  "**** Write to Debug Object: Object %p %s ****:\n\n",
+				  source_desc,
+				  acpi_ut_get_object_type_name(source_desc)));
+
+		ACPI_DEBUG_OBJECT(source_desc, 0, 0);
+		break;
+
+	default:
+
+		ACPI_ERROR((AE_INFO, "Unknown Reference Class 0x%2.2X",
+			    ref_desc->reference.class));
+		ACPI_DUMP_ENTRY(ref_desc, ACPI_LV_INFO);
+
+		status = AE_AML_INTERNAL;
+		break;
+	}
+
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_store_object_to_index
+ *
+ * PARAMETERS:  *source_desc            - Value to be stored
+ *              *dest_desc              - Named object to receive the value
+ *              walk_state              - Current walk state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Store the object to indexed Buffer or Package element
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ex_store_object_to_index(union acpi_operand_object *source_desc,
+			      union acpi_operand_object *index_desc,
+			      struct acpi_walk_state *walk_state)
+{
+	acpi_status status = AE_OK;
+	union acpi_operand_object *obj_desc;
+	union acpi_operand_object *new_desc;
+	u8 value = 0;
+	u32 i;
+
+	ACPI_FUNCTION_TRACE(ex_store_object_to_index);
+
+	/*
+	 * Destination must be a reference pointer, and
+	 * must point to either a buffer or a package
+	 */
+	switch (index_desc->reference.target_type) {
+	case ACPI_TYPE_PACKAGE:
+		/*
+		 * Storing to a package element. Copy the object and replace
+		 * any existing object with the new object. No implicit
+		 * conversion is performed.
+		 *
+		 * The object at *(index_desc->Reference.Where) is the
+		 * element within the package that is to be modified.
+		 * The parent package object is at index_desc->Reference.Object
+		 */
+		obj_desc = *(index_desc->reference.where);
+
+		if (source_desc->common.type == ACPI_TYPE_LOCAL_REFERENCE &&
+		    source_desc->reference.class == ACPI_REFCLASS_TABLE) {
+
+			/* This is a DDBHandle, just add a reference to it */
+
+			acpi_ut_add_reference(source_desc);
+			new_desc = source_desc;
+		} else {
+			/* Normal object, copy it */
+
+			status =
+			    acpi_ut_copy_iobject_to_iobject(source_desc,
+							    &new_desc,
+							    walk_state);
+			if (ACPI_FAILURE(status)) {
+				return_ACPI_STATUS(status);
+			}
+		}
+
+		if (obj_desc) {
+
+			/* Decrement reference count by the ref count of the parent package */
+
+			for (i = 0; i < ((union acpi_operand_object *)
+					 index_desc->reference.object)->common.
+			     reference_count; i++) {
+				acpi_ut_remove_reference(obj_desc);
+			}
+		}
+
+		*(index_desc->reference.where) = new_desc;
+
+		/* Increment ref count by the ref count of the parent package-1 */
+
+		for (i = 1; i < ((union acpi_operand_object *)
+				 index_desc->reference.object)->common.
+		     reference_count; i++) {
+			acpi_ut_add_reference(new_desc);
+		}
+
+		break;
+
+	case ACPI_TYPE_BUFFER_FIELD:
+
+		/*
+		 * Store into a Buffer or String (not actually a real buffer_field)
+		 * at a location defined by an Index.
+		 *
+		 * The first 8-bit element of the source object is written to the
+		 * 8-bit Buffer location defined by the Index destination object,
+		 * according to the ACPI 2.0 specification.
+		 */
+
+		/*
+		 * Make sure the target is a Buffer or String. An error should
+		 * not happen here, since the reference_object was constructed
+		 * by the INDEX_OP code.
+		 */
+		obj_desc = index_desc->reference.object;
+		if ((obj_desc->common.type != ACPI_TYPE_BUFFER) &&
+		    (obj_desc->common.type != ACPI_TYPE_STRING)) {
+			return_ACPI_STATUS(AE_AML_OPERAND_TYPE);
+		}
+
+		/*
+		 * The assignment of the individual elements will be slightly
+		 * different for each source type.
+		 */
+		switch (source_desc->common.type) {
+		case ACPI_TYPE_INTEGER:
+
+			/* Use the least-significant byte of the integer */
+
+			value = (u8)(source_desc->integer.value);
+			break;
+
+		case ACPI_TYPE_BUFFER:
+		case ACPI_TYPE_STRING:
+
+			/* Note: Takes advantage of common string/buffer fields */
+
+			value = source_desc->buffer.pointer[0];
+			break;
+
+		default:
+
+			/* All other types are invalid */
+
+			ACPI_ERROR((AE_INFO,
+				    "Source must be Integer/Buffer/String type, not %s",
+				    acpi_ut_get_object_type_name(source_desc)));
+			return_ACPI_STATUS(AE_AML_OPERAND_TYPE);
+		}
+
+		/* Store the source value into the target buffer byte */
+
+		obj_desc->buffer.pointer[index_desc->reference.value] = value;
+		break;
+
+	default:
+		ACPI_ERROR((AE_INFO, "Target is not a Package or BufferField"));
+		status = AE_AML_OPERAND_TYPE;
+		break;
+	}
+
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_store_object_to_node
+ *
+ * PARAMETERS:  source_desc             - Value to be stored
+ *              Node                    - Named object to receive the value
+ *              walk_state              - Current walk state
+ *              implicit_conversion     - Perform implicit conversion (yes/no)
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Store the object to the named object.
+ *
+ *              The Assignment of an object to a named object is handled here
+ *              The value passed in will replace the current value (if any)
+ *              with the input value.
+ *
+ *              When storing into an object the data is converted to the
+ *              target object type then stored in the object.  This means
+ *              that the target object type (for an initialized target) will
+ *              not be changed by a store operation.
+ *
+ *              Assumes parameters are already validated.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ex_store_object_to_node(union acpi_operand_object *source_desc,
+			     struct acpi_namespace_node *node,
+			     struct acpi_walk_state *walk_state,
+			     u8 implicit_conversion)
+{
+	acpi_status status = AE_OK;
+	union acpi_operand_object *target_desc;
+	union acpi_operand_object *new_desc;
+	acpi_object_type target_type;
+
+	ACPI_FUNCTION_TRACE_PTR(ex_store_object_to_node, source_desc);
+
+	/* Get current type of the node, and object attached to Node */
+
+	target_type = acpi_ns_get_type(node);
+	target_desc = acpi_ns_get_attached_object(node);
+
+	ACPI_DEBUG_PRINT((ACPI_DB_EXEC, "Storing %p(%s) into node %p(%s)\n",
+			  source_desc,
+			  acpi_ut_get_object_type_name(source_desc), node,
+			  acpi_ut_get_type_name(target_type)));
+
+	/*
+	 * Resolve the source object to an actual value
+	 * (If it is a reference object)
+	 */
+	status = acpi_ex_resolve_object(&source_desc, target_type, walk_state);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/* If no implicit conversion, drop into the default case below */
+
+	if ((!implicit_conversion) ||
+	    ((walk_state->opcode == AML_COPY_OP) &&
+	     (target_type != ACPI_TYPE_LOCAL_REGION_FIELD) &&
+	     (target_type != ACPI_TYPE_LOCAL_BANK_FIELD) &&
+	     (target_type != ACPI_TYPE_LOCAL_INDEX_FIELD))) {
+		/*
+		 * Force execution of default (no implicit conversion). Note:
+		 * copy_object does not perform an implicit conversion, as per the ACPI
+		 * spec -- except in case of region/bank/index fields -- because these
+		 * objects must retain their original type permanently.
+		 */
+		target_type = ACPI_TYPE_ANY;
+	}
+
+	/* Do the actual store operation */
+
+	switch (target_type) {
+	case ACPI_TYPE_BUFFER_FIELD:
+	case ACPI_TYPE_LOCAL_REGION_FIELD:
+	case ACPI_TYPE_LOCAL_BANK_FIELD:
+	case ACPI_TYPE_LOCAL_INDEX_FIELD:
+
+		/* For fields, copy the source data to the target field. */
+
+		status = acpi_ex_write_data_to_field(source_desc, target_desc,
+						     &walk_state->result_obj);
+		break;
+
+	case ACPI_TYPE_INTEGER:
+	case ACPI_TYPE_STRING:
+	case ACPI_TYPE_BUFFER:
+
+		/*
+		 * These target types are all of type Integer/String/Buffer, and
+		 * therefore support implicit conversion before the store.
+		 *
+		 * Copy and/or convert the source object to a new target object
+		 */
+		status =
+		    acpi_ex_store_object_to_object(source_desc, target_desc,
+						   &new_desc, walk_state);
+		if (ACPI_FAILURE(status)) {
+			return_ACPI_STATUS(status);
+		}
+
+		if (new_desc != target_desc) {
+			/*
+			 * Store the new new_desc as the new value of the Name, and set
+			 * the Name's type to that of the value being stored in it.
+			 * source_desc reference count is incremented by attach_object.
+			 *
+			 * Note: This may change the type of the node if an explicit store
+			 * has been performed such that the node/object type has been
+			 * changed.
+			 */
+			status =
+			    acpi_ns_attach_object(node, new_desc,
+						  new_desc->common.type);
+
+			ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
+					  "Store %s into %s via Convert/Attach\n",
+					  acpi_ut_get_object_type_name
+					  (source_desc),
+					  acpi_ut_get_object_type_name
+					  (new_desc)));
+		}
+		break;
+
+	default:
+
+		ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
+				  "Storing %s (%p) directly into node (%p) with no implicit conversion\n",
+				  acpi_ut_get_object_type_name(source_desc),
+				  source_desc, node));
+
+		/* No conversions for all other types.  Just attach the source object */
+
+		status = acpi_ns_attach_object(node, source_desc,
+					       source_desc->common.type);
+		break;
+	}
+
+	return_ACPI_STATUS(status);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exstoren.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exstoren.c
new file mode 100644
index 00000000..b35bed52
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exstoren.c
@@ -0,0 +1,299 @@
+
+/******************************************************************************
+ *
+ * Module Name: exstoren - AML Interpreter object store support,
+ *                        Store to Node (namespace object)
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acinterp.h"
+#include "amlcode.h"
+
+#define _COMPONENT          ACPI_EXECUTER
+ACPI_MODULE_NAME("exstoren")
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_resolve_object
+ *
+ * PARAMETERS:  source_desc_ptr     - Pointer to the source object
+ *              target_type         - Current type of the target
+ *              walk_state          - Current walk state
+ *
+ * RETURN:      Status, resolved object in source_desc_ptr.
+ *
+ * DESCRIPTION: Resolve an object.  If the object is a reference, dereference
+ *              it and return the actual object in the source_desc_ptr.
+ *
+ ******************************************************************************/
+acpi_status
+acpi_ex_resolve_object(union acpi_operand_object **source_desc_ptr,
+		       acpi_object_type target_type,
+		       struct acpi_walk_state *walk_state)
+{
+	union acpi_operand_object *source_desc = *source_desc_ptr;
+	acpi_status status = AE_OK;
+
+	ACPI_FUNCTION_TRACE(ex_resolve_object);
+
+	/* Ensure we have a Target that can be stored to */
+
+	switch (target_type) {
+	case ACPI_TYPE_BUFFER_FIELD:
+	case ACPI_TYPE_LOCAL_REGION_FIELD:
+	case ACPI_TYPE_LOCAL_BANK_FIELD:
+	case ACPI_TYPE_LOCAL_INDEX_FIELD:
+		/*
+		 * These cases all require only Integers or values that
+		 * can be converted to Integers (Strings or Buffers)
+		 */
+
+	case ACPI_TYPE_INTEGER:
+	case ACPI_TYPE_STRING:
+	case ACPI_TYPE_BUFFER:
+
+		/*
+		 * Stores into a Field/Region or into a Integer/Buffer/String
+		 * are all essentially the same.  This case handles the
+		 * "interchangeable" types Integer, String, and Buffer.
+		 */
+		if (source_desc->common.type == ACPI_TYPE_LOCAL_REFERENCE) {
+
+			/* Resolve a reference object first */
+
+			status =
+			    acpi_ex_resolve_to_value(source_desc_ptr,
+						     walk_state);
+			if (ACPI_FAILURE(status)) {
+				break;
+			}
+		}
+
+		/* For copy_object, no further validation necessary */
+
+		if (walk_state->opcode == AML_COPY_OP) {
+			break;
+		}
+
+		/* Must have a Integer, Buffer, or String */
+
+		if ((source_desc->common.type != ACPI_TYPE_INTEGER) &&
+		    (source_desc->common.type != ACPI_TYPE_BUFFER) &&
+		    (source_desc->common.type != ACPI_TYPE_STRING) &&
+		    !((source_desc->common.type == ACPI_TYPE_LOCAL_REFERENCE) &&
+		      (source_desc->reference.class == ACPI_REFCLASS_TABLE))) {
+
+			/* Conversion successful but still not a valid type */
+
+			ACPI_ERROR((AE_INFO,
+				    "Cannot assign type %s to %s (must be type Int/Str/Buf)",
+				    acpi_ut_get_object_type_name(source_desc),
+				    acpi_ut_get_type_name(target_type)));
+			status = AE_AML_OPERAND_TYPE;
+		}
+		break;
+
+	case ACPI_TYPE_LOCAL_ALIAS:
+	case ACPI_TYPE_LOCAL_METHOD_ALIAS:
+
+		/*
+		 * All aliases should have been resolved earlier, during the
+		 * operand resolution phase.
+		 */
+		ACPI_ERROR((AE_INFO, "Store into an unresolved Alias object"));
+		status = AE_AML_INTERNAL;
+		break;
+
+	case ACPI_TYPE_PACKAGE:
+	default:
+
+		/*
+		 * All other types than Alias and the various Fields come here,
+		 * including the untyped case - ACPI_TYPE_ANY.
+		 */
+		break;
+	}
+
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_store_object_to_object
+ *
+ * PARAMETERS:  source_desc         - Object to store
+ *              dest_desc           - Object to receive a copy of the source
+ *              new_desc            - New object if dest_desc is obsoleted
+ *              walk_state          - Current walk state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: "Store" an object to another object.  This may include
+ *              converting the source type to the target type (implicit
+ *              conversion), and a copy of the value of the source to
+ *              the target.
+ *
+ *              The Assignment of an object to another (not named) object
+ *              is handled here.
+ *              The Source passed in will replace the current value (if any)
+ *              with the input value.
+ *
+ *              When storing into an object the data is converted to the
+ *              target object type then stored in the object.  This means
+ *              that the target object type (for an initialized target) will
+ *              not be changed by a store operation.
+ *
+ *              This module allows destination types of Number, String,
+ *              Buffer, and Package.
+ *
+ *              Assumes parameters are already validated.  NOTE: source_desc
+ *              resolution (from a reference object) must be performed by
+ *              the caller if necessary.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ex_store_object_to_object(union acpi_operand_object *source_desc,
+			       union acpi_operand_object *dest_desc,
+			       union acpi_operand_object **new_desc,
+			       struct acpi_walk_state *walk_state)
+{
+	union acpi_operand_object *actual_src_desc;
+	acpi_status status = AE_OK;
+
+	ACPI_FUNCTION_TRACE_PTR(ex_store_object_to_object, source_desc);
+
+	actual_src_desc = source_desc;
+	if (!dest_desc) {
+		/*
+		 * There is no destination object (An uninitialized node or
+		 * package element), so we can simply copy the source object
+		 * creating a new destination object
+		 */
+		status =
+		    acpi_ut_copy_iobject_to_iobject(actual_src_desc, new_desc,
+						    walk_state);
+		return_ACPI_STATUS(status);
+	}
+
+	if (source_desc->common.type != dest_desc->common.type) {
+		/*
+		 * The source type does not match the type of the destination.
+		 * Perform the "implicit conversion" of the source to the current type
+		 * of the target as per the ACPI specification.
+		 *
+		 * If no conversion performed, actual_src_desc = source_desc.
+		 * Otherwise, actual_src_desc is a temporary object to hold the
+		 * converted object.
+		 */
+		status = acpi_ex_convert_to_target_type(dest_desc->common.type,
+							source_desc,
+							&actual_src_desc,
+							walk_state);
+		if (ACPI_FAILURE(status)) {
+			return_ACPI_STATUS(status);
+		}
+
+		if (source_desc == actual_src_desc) {
+			/*
+			 * No conversion was performed. Return the source_desc as the
+			 * new object.
+			 */
+			*new_desc = source_desc;
+			return_ACPI_STATUS(AE_OK);
+		}
+	}
+
+	/*
+	 * We now have two objects of identical types, and we can perform a
+	 * copy of the *value* of the source object.
+	 */
+	switch (dest_desc->common.type) {
+	case ACPI_TYPE_INTEGER:
+
+		dest_desc->integer.value = actual_src_desc->integer.value;
+
+		/* Truncate value if we are executing from a 32-bit ACPI table */
+
+		acpi_ex_truncate_for32bit_table(dest_desc);
+		break;
+
+	case ACPI_TYPE_STRING:
+
+		status =
+		    acpi_ex_store_string_to_string(actual_src_desc, dest_desc);
+		break;
+
+	case ACPI_TYPE_BUFFER:
+
+		status =
+		    acpi_ex_store_buffer_to_buffer(actual_src_desc, dest_desc);
+		break;
+
+	case ACPI_TYPE_PACKAGE:
+
+		status =
+		    acpi_ut_copy_iobject_to_iobject(actual_src_desc, &dest_desc,
+						    walk_state);
+		break;
+
+	default:
+		/*
+		 * All other types come here.
+		 */
+		ACPI_WARNING((AE_INFO, "Store into type %s not implemented",
+			      acpi_ut_get_object_type_name(dest_desc)));
+
+		status = AE_NOT_IMPLEMENTED;
+		break;
+	}
+
+	if (actual_src_desc != source_desc) {
+
+		/* Delete the intermediate (temporary) source object */
+
+		acpi_ut_remove_reference(actual_src_desc);
+	}
+
+	*new_desc = dest_desc;
+	return_ACPI_STATUS(status);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exstorob.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exstorob.c
new file mode 100644
index 00000000..65a45d83
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exstorob.c
@@ -0,0 +1,221 @@
+
+/******************************************************************************
+ *
+ * Module Name: exstorob - AML Interpreter object store support, store to object
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acinterp.h"
+
+#define _COMPONENT          ACPI_EXECUTER
+ACPI_MODULE_NAME("exstorob")
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_store_buffer_to_buffer
+ *
+ * PARAMETERS:  source_desc         - Source object to copy
+ *              target_desc         - Destination object of the copy
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Copy a buffer object to another buffer object.
+ *
+ ******************************************************************************/
+acpi_status
+acpi_ex_store_buffer_to_buffer(union acpi_operand_object *source_desc,
+			       union acpi_operand_object *target_desc)
+{
+	u32 length;
+	u8 *buffer;
+
+	ACPI_FUNCTION_TRACE_PTR(ex_store_buffer_to_buffer, source_desc);
+
+	/* If Source and Target are the same, just return */
+
+	if (source_desc == target_desc) {
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	/* We know that source_desc is a buffer by now */
+
+	buffer = ACPI_CAST_PTR(u8, source_desc->buffer.pointer);
+	length = source_desc->buffer.length;
+
+	/*
+	 * If target is a buffer of length zero or is a static buffer,
+	 * allocate a new buffer of the proper length
+	 */
+	if ((target_desc->buffer.length == 0) ||
+	    (target_desc->common.flags & AOPOBJ_STATIC_POINTER)) {
+		target_desc->buffer.pointer = ACPI_ALLOCATE(length);
+		if (!target_desc->buffer.pointer) {
+			return_ACPI_STATUS(AE_NO_MEMORY);
+		}
+
+		target_desc->buffer.length = length;
+	}
+
+	/* Copy source buffer to target buffer */
+
+	if (length <= target_desc->buffer.length) {
+
+		/* Clear existing buffer and copy in the new one */
+
+		ACPI_MEMSET(target_desc->buffer.pointer, 0,
+			    target_desc->buffer.length);
+		ACPI_MEMCPY(target_desc->buffer.pointer, buffer, length);
+
+#ifdef ACPI_OBSOLETE_BEHAVIOR
+		/*
+		 * NOTE: ACPI versions up to 3.0 specified that the buffer must be
+		 * truncated if the string is smaller than the buffer.  However, "other"
+		 * implementations of ACPI never did this and thus became the defacto
+		 * standard. ACPI 3.0_a changes this behavior such that the buffer
+		 * is no longer truncated.
+		 */
+
+		/*
+		 * OBSOLETE BEHAVIOR:
+		 * If the original source was a string, we must truncate the buffer,
+		 * according to the ACPI spec.  Integer-to-Buffer and Buffer-to-Buffer
+		 * copy must not truncate the original buffer.
+		 */
+		if (original_src_type == ACPI_TYPE_STRING) {
+
+			/* Set the new length of the target */
+
+			target_desc->buffer.length = length;
+		}
+#endif
+	} else {
+		/* Truncate the source, copy only what will fit */
+
+		ACPI_MEMCPY(target_desc->buffer.pointer, buffer,
+			    target_desc->buffer.length);
+
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+				  "Truncating source buffer from %X to %X\n",
+				  length, target_desc->buffer.length));
+	}
+
+	/* Copy flags */
+
+	target_desc->buffer.flags = source_desc->buffer.flags;
+	target_desc->common.flags &= ~AOPOBJ_STATIC_POINTER;
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_store_string_to_string
+ *
+ * PARAMETERS:  source_desc         - Source object to copy
+ *              target_desc         - Destination object of the copy
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Copy a String object to another String object
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ex_store_string_to_string(union acpi_operand_object *source_desc,
+			       union acpi_operand_object *target_desc)
+{
+	u32 length;
+	u8 *buffer;
+
+	ACPI_FUNCTION_TRACE_PTR(ex_store_string_to_string, source_desc);
+
+	/* If Source and Target are the same, just return */
+
+	if (source_desc == target_desc) {
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	/* We know that source_desc is a string by now */
+
+	buffer = ACPI_CAST_PTR(u8, source_desc->string.pointer);
+	length = source_desc->string.length;
+
+	/*
+	 * Replace existing string value if it will fit and the string
+	 * pointer is not a static pointer (part of an ACPI table)
+	 */
+	if ((length < target_desc->string.length) &&
+	    (!(target_desc->common.flags & AOPOBJ_STATIC_POINTER))) {
+		/*
+		 * String will fit in existing non-static buffer.
+		 * Clear old string and copy in the new one
+		 */
+		ACPI_MEMSET(target_desc->string.pointer, 0,
+			    (acpi_size) target_desc->string.length + 1);
+		ACPI_MEMCPY(target_desc->string.pointer, buffer, length);
+	} else {
+		/*
+		 * Free the current buffer, then allocate a new buffer
+		 * large enough to hold the value
+		 */
+		if (target_desc->string.pointer &&
+		    (!(target_desc->common.flags & AOPOBJ_STATIC_POINTER))) {
+
+			/* Only free if not a pointer into the DSDT */
+
+			ACPI_FREE(target_desc->string.pointer);
+		}
+
+		target_desc->string.pointer = ACPI_ALLOCATE_ZEROED((acpi_size)
+								   length + 1);
+		if (!target_desc->string.pointer) {
+			return_ACPI_STATUS(AE_NO_MEMORY);
+		}
+
+		target_desc->common.flags &= ~AOPOBJ_STATIC_POINTER;
+		ACPI_MEMCPY(target_desc->string.pointer, buffer, length);
+	}
+
+	/* Set the new target length */
+
+	target_desc->string.length = length;
+	return_ACPI_STATUS(AE_OK);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exsystem.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exsystem.c
new file mode 100644
index 00000000..fb4dc8f4
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exsystem.c
@@ -0,0 +1,311 @@
+
+/******************************************************************************
+ *
+ * Module Name: exsystem - Interface to OS services
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acinterp.h"
+
+#define _COMPONENT          ACPI_EXECUTER
+ACPI_MODULE_NAME("exsystem")
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_system_wait_semaphore
+ *
+ * PARAMETERS:  Semaphore       - Semaphore to wait on
+ *              Timeout         - Max time to wait
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Implements a semaphore wait with a check to see if the
+ *              semaphore is available immediately.  If it is not, the
+ *              interpreter is released before waiting.
+ *
+ ******************************************************************************/
+acpi_status acpi_ex_system_wait_semaphore(acpi_semaphore semaphore, u16 timeout)
+{
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(ex_system_wait_semaphore);
+
+	status = acpi_os_wait_semaphore(semaphore, 1, ACPI_DO_NOT_WAIT);
+	if (ACPI_SUCCESS(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	if (status == AE_TIME) {
+
+		/* We must wait, so unlock the interpreter */
+
+		acpi_ex_relinquish_interpreter();
+
+		status = acpi_os_wait_semaphore(semaphore, 1, timeout);
+
+		ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
+				  "*** Thread awake after blocking, %s\n",
+				  acpi_format_exception(status)));
+
+		/* Reacquire the interpreter */
+
+		acpi_ex_reacquire_interpreter();
+	}
+
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_system_wait_mutex
+ *
+ * PARAMETERS:  Mutex           - Mutex to wait on
+ *              Timeout         - Max time to wait
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Implements a mutex wait with a check to see if the
+ *              mutex is available immediately.  If it is not, the
+ *              interpreter is released before waiting.
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ex_system_wait_mutex(acpi_mutex mutex, u16 timeout)
+{
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(ex_system_wait_mutex);
+
+	status = acpi_os_acquire_mutex(mutex, ACPI_DO_NOT_WAIT);
+	if (ACPI_SUCCESS(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	if (status == AE_TIME) {
+
+		/* We must wait, so unlock the interpreter */
+
+		acpi_ex_relinquish_interpreter();
+
+		status = acpi_os_acquire_mutex(mutex, timeout);
+
+		ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
+				  "*** Thread awake after blocking, %s\n",
+				  acpi_format_exception(status)));
+
+		/* Reacquire the interpreter */
+
+		acpi_ex_reacquire_interpreter();
+	}
+
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_system_do_stall
+ *
+ * PARAMETERS:  how_long        - The amount of time to stall,
+ *                                in microseconds
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Suspend running thread for specified amount of time.
+ *              Note: ACPI specification requires that Stall() does not
+ *              relinquish the processor, and delays longer than 100 usec
+ *              should use Sleep() instead.  We allow stalls up to 255 usec
+ *              for compatibility with other interpreters and existing BIOSs.
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ex_system_do_stall(u32 how_long)
+{
+	acpi_status status = AE_OK;
+
+	ACPI_FUNCTION_ENTRY();
+
+	if (how_long > 255) {	/* 255 microseconds */
+		/*
+		 * Longer than 255 usec, this is an error
+		 *
+		 * (ACPI specifies 100 usec as max, but this gives some slack in
+		 * order to support existing BIOSs)
+		 */
+		ACPI_ERROR((AE_INFO, "Time parameter is too large (%u)",
+			    how_long));
+		status = AE_AML_OPERAND_VALUE;
+	} else {
+		acpi_os_stall(how_long);
+	}
+
+	return (status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_system_do_sleep
+ *
+ * PARAMETERS:  how_long        - The amount of time to sleep,
+ *                                in milliseconds
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Sleep the running thread for specified amount of time.
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ex_system_do_sleep(u64 how_long)
+{
+	ACPI_FUNCTION_ENTRY();
+
+	/* Since this thread will sleep, we must release the interpreter */
+
+	acpi_ex_relinquish_interpreter();
+
+	/*
+	 * For compatibility with other ACPI implementations and to prevent
+	 * accidental deep sleeps, limit the sleep time to something reasonable.
+	 */
+	if (how_long > ACPI_MAX_SLEEP) {
+		how_long = ACPI_MAX_SLEEP;
+	}
+
+	acpi_os_sleep(how_long);
+
+	/* And now we must get the interpreter again */
+
+	acpi_ex_reacquire_interpreter();
+	return (AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_system_signal_event
+ *
+ * PARAMETERS:  obj_desc        - The object descriptor for this op
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Provides an access point to perform synchronization operations
+ *              within the AML.
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ex_system_signal_event(union acpi_operand_object *obj_desc)
+{
+	acpi_status status = AE_OK;
+
+	ACPI_FUNCTION_TRACE(ex_system_signal_event);
+
+	if (obj_desc) {
+		status =
+		    acpi_os_signal_semaphore(obj_desc->event.os_semaphore, 1);
+	}
+
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_system_wait_event
+ *
+ * PARAMETERS:  time_desc       - The 'time to delay' object descriptor
+ *              obj_desc        - The object descriptor for this op
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Provides an access point to perform synchronization operations
+ *              within the AML.  This operation is a request to wait for an
+ *              event.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ex_system_wait_event(union acpi_operand_object *time_desc,
+			  union acpi_operand_object *obj_desc)
+{
+	acpi_status status = AE_OK;
+
+	ACPI_FUNCTION_TRACE(ex_system_wait_event);
+
+	if (obj_desc) {
+		status =
+		    acpi_ex_system_wait_semaphore(obj_desc->event.os_semaphore,
+						  (u16)time_desc->integer.
+						  value);
+	}
+
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_system_reset_event
+ *
+ * PARAMETERS:  obj_desc        - The object descriptor for this op
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Reset an event to a known state.
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ex_system_reset_event(union acpi_operand_object *obj_desc)
+{
+	acpi_status status = AE_OK;
+	acpi_semaphore temp_semaphore;
+
+	ACPI_FUNCTION_ENTRY();
+
+	/*
+	 * We are going to simply delete the existing semaphore and
+	 * create a new one!
+	 */
+	status =
+	    acpi_os_create_semaphore(ACPI_NO_UNIT_LIMIT, 0, &temp_semaphore);
+	if (ACPI_SUCCESS(status)) {
+		(void)acpi_os_delete_semaphore(obj_desc->event.os_semaphore);
+		obj_desc->event.os_semaphore = temp_semaphore;
+	}
+
+	return (status);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exutils.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exutils.c
new file mode 100644
index 00000000..dacfbf4e
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/exutils.c
@@ -0,0 +1,463 @@
+
+/******************************************************************************
+ *
+ * Module Name: exutils - interpreter/scanner utilities
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+/*
+ * DEFINE_AML_GLOBALS is tested in amlcode.h
+ * to determine whether certain global names should be "defined" or only
+ * "declared" in the current compilation.  This enhances maintainability
+ * by enabling a single header file to embody all knowledge of the names
+ * in question.
+ *
+ * Exactly one module of any executable should #define DEFINE_GLOBALS
+ * before #including the header files which use this convention.  The
+ * names in question will be defined and initialized in that module,
+ * and declared as extern in all other modules which #include those
+ * header files.
+ */
+
+#define DEFINE_AML_GLOBALS
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acinterp.h"
+#include "amlcode.h"
+
+#define _COMPONENT          ACPI_EXECUTER
+ACPI_MODULE_NAME("exutils")
+
+/* Local prototypes */
+static u32 acpi_ex_digits_needed(u64 value, u32 base);
+
+#ifndef ACPI_NO_METHOD_EXECUTION
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_enter_interpreter
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Enter the interpreter execution region. Failure to enter
+ *              the interpreter region is a fatal system error. Used in
+ *              conjunction with exit_interpreter.
+ *
+ ******************************************************************************/
+
+void acpi_ex_enter_interpreter(void)
+{
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(ex_enter_interpreter);
+
+	status = acpi_ut_acquire_mutex(ACPI_MTX_INTERPRETER);
+	if (ACPI_FAILURE(status)) {
+		ACPI_ERROR((AE_INFO,
+			    "Could not acquire AML Interpreter mutex"));
+	}
+
+	return_VOID;
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_reacquire_interpreter
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Reacquire the interpreter execution region from within the
+ *              interpreter code. Failure to enter the interpreter region is a
+ *              fatal system error. Used in  conjuction with
+ *              relinquish_interpreter
+ *
+ ******************************************************************************/
+
+void acpi_ex_reacquire_interpreter(void)
+{
+	ACPI_FUNCTION_TRACE(ex_reacquire_interpreter);
+
+	/*
+	 * If the global serialized flag is set, do not release the interpreter,
+	 * since it was not actually released by acpi_ex_relinquish_interpreter.
+	 * This forces the interpreter to be single threaded.
+	 */
+	if (!acpi_gbl_all_methods_serialized) {
+		acpi_ex_enter_interpreter();
+	}
+
+	return_VOID;
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_exit_interpreter
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Exit the interpreter execution region. This is the top level
+ *              routine used to exit the interpreter when all processing has
+ *              been completed.
+ *
+ ******************************************************************************/
+
+void acpi_ex_exit_interpreter(void)
+{
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(ex_exit_interpreter);
+
+	status = acpi_ut_release_mutex(ACPI_MTX_INTERPRETER);
+	if (ACPI_FAILURE(status)) {
+		ACPI_ERROR((AE_INFO,
+			    "Could not release AML Interpreter mutex"));
+	}
+
+	return_VOID;
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_relinquish_interpreter
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Exit the interpreter execution region, from within the
+ *              interpreter - before attempting an operation that will possibly
+ *              block the running thread.
+ *
+ * Cases where the interpreter is unlocked internally
+ *      1) Method to be blocked on a Sleep() AML opcode
+ *      2) Method to be blocked on an Acquire() AML opcode
+ *      3) Method to be blocked on a Wait() AML opcode
+ *      4) Method to be blocked to acquire the global lock
+ *      5) Method to be blocked waiting to execute a serialized control method
+ *          that is currently executing
+ *      6) About to invoke a user-installed opregion handler
+ *
+ ******************************************************************************/
+
+void acpi_ex_relinquish_interpreter(void)
+{
+	ACPI_FUNCTION_TRACE(ex_relinquish_interpreter);
+
+	/*
+	 * If the global serialized flag is set, do not release the interpreter.
+	 * This forces the interpreter to be single threaded.
+	 */
+	if (!acpi_gbl_all_methods_serialized) {
+		acpi_ex_exit_interpreter();
+	}
+
+	return_VOID;
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_truncate_for32bit_table
+ *
+ * PARAMETERS:  obj_desc        - Object to be truncated
+ *
+ * RETURN:      none
+ *
+ * DESCRIPTION: Truncate an ACPI Integer to 32 bits if the execution mode is
+ *              32-bit, as determined by the revision of the DSDT.
+ *
+ ******************************************************************************/
+
+void acpi_ex_truncate_for32bit_table(union acpi_operand_object *obj_desc)
+{
+
+	ACPI_FUNCTION_ENTRY();
+
+	/*
+	 * Object must be a valid number and we must be executing
+	 * a control method. NS node could be there for AML_INT_NAMEPATH_OP.
+	 */
+	if ((!obj_desc) ||
+	    (ACPI_GET_DESCRIPTOR_TYPE(obj_desc) != ACPI_DESC_TYPE_OPERAND) ||
+	    (obj_desc->common.type != ACPI_TYPE_INTEGER)) {
+		return;
+	}
+
+	if (acpi_gbl_integer_byte_width == 4) {
+		/*
+		 * We are running a method that exists in a 32-bit ACPI table.
+		 * Truncate the value to 32 bits by zeroing out the upper 32-bit field
+		 */
+		obj_desc->integer.value &= (u64)ACPI_UINT32_MAX;
+	}
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_acquire_global_lock
+ *
+ * PARAMETERS:  field_flags           - Flags with Lock rule:
+ *                                      always_lock or never_lock
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Obtain the ACPI hardware Global Lock, only if the field
+ *              flags specifiy that it is to be obtained before field access.
+ *
+ ******************************************************************************/
+
+void acpi_ex_acquire_global_lock(u32 field_flags)
+{
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(ex_acquire_global_lock);
+
+	/* Only use the lock if the always_lock bit is set */
+
+	if (!(field_flags & AML_FIELD_LOCK_RULE_MASK)) {
+		return_VOID;
+	}
+
+	/* Attempt to get the global lock, wait forever */
+
+	status = acpi_ex_acquire_mutex_object(ACPI_WAIT_FOREVER,
+					      acpi_gbl_global_lock_mutex,
+					      acpi_os_get_thread_id());
+
+	if (ACPI_FAILURE(status)) {
+		ACPI_EXCEPTION((AE_INFO, status,
+				"Could not acquire Global Lock"));
+	}
+
+	return_VOID;
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_release_global_lock
+ *
+ * PARAMETERS:  field_flags           - Flags with Lock rule:
+ *                                      always_lock or never_lock
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Release the ACPI hardware Global Lock
+ *
+ ******************************************************************************/
+
+void acpi_ex_release_global_lock(u32 field_flags)
+{
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(ex_release_global_lock);
+
+	/* Only use the lock if the always_lock bit is set */
+
+	if (!(field_flags & AML_FIELD_LOCK_RULE_MASK)) {
+		return_VOID;
+	}
+
+	/* Release the global lock */
+
+	status = acpi_ex_release_mutex_object(acpi_gbl_global_lock_mutex);
+	if (ACPI_FAILURE(status)) {
+
+		/* Report the error, but there isn't much else we can do */
+
+		ACPI_EXCEPTION((AE_INFO, status,
+				"Could not release Global Lock"));
+	}
+
+	return_VOID;
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_digits_needed
+ *
+ * PARAMETERS:  Value           - Value to be represented
+ *              Base            - Base of representation
+ *
+ * RETURN:      The number of digits.
+ *
+ * DESCRIPTION: Calculate the number of digits needed to represent the Value
+ *              in the given Base (Radix)
+ *
+ ******************************************************************************/
+
+static u32 acpi_ex_digits_needed(u64 value, u32 base)
+{
+	u32 num_digits;
+	u64 current_value;
+
+	ACPI_FUNCTION_TRACE(ex_digits_needed);
+
+	/* u64 is unsigned, so we don't worry about a '-' prefix */
+
+	if (value == 0) {
+		return_UINT32(1);
+	}
+
+	current_value = value;
+	num_digits = 0;
+
+	/* Count the digits in the requested base */
+
+	while (current_value) {
+		(void)acpi_ut_short_divide(current_value, base, &current_value,
+					   NULL);
+		num_digits++;
+	}
+
+	return_UINT32(num_digits);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_eisa_id_to_string
+ *
+ * PARAMETERS:  compressed_id   - EISAID to be converted
+ *              out_string      - Where to put the converted string (8 bytes)
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Convert a numeric EISAID to string representation. Return
+ *              buffer must be large enough to hold the string. The string
+ *              returned is always exactly of length ACPI_EISAID_STRING_SIZE
+ *              (includes null terminator). The EISAID is always 32 bits.
+ *
+ ******************************************************************************/
+
+void acpi_ex_eisa_id_to_string(char *out_string, u64 compressed_id)
+{
+	u32 swapped_id;
+
+	ACPI_FUNCTION_ENTRY();
+
+	/* The EISAID should be a 32-bit integer */
+
+	if (compressed_id > ACPI_UINT32_MAX) {
+		ACPI_WARNING((AE_INFO,
+			      "Expected EISAID is larger than 32 bits: 0x%8.8X%8.8X, truncating",
+			      ACPI_FORMAT_UINT64(compressed_id)));
+	}
+
+	/* Swap ID to big-endian to get contiguous bits */
+
+	swapped_id = acpi_ut_dword_byte_swap((u32)compressed_id);
+
+	/* First 3 bytes are uppercase letters. Next 4 bytes are hexadecimal */
+
+	out_string[0] =
+	    (char)(0x40 + (((unsigned long)swapped_id >> 26) & 0x1F));
+	out_string[1] = (char)(0x40 + ((swapped_id >> 21) & 0x1F));
+	out_string[2] = (char)(0x40 + ((swapped_id >> 16) & 0x1F));
+	out_string[3] = acpi_ut_hex_to_ascii_char((u64)swapped_id, 12);
+	out_string[4] = acpi_ut_hex_to_ascii_char((u64)swapped_id, 8);
+	out_string[5] = acpi_ut_hex_to_ascii_char((u64)swapped_id, 4);
+	out_string[6] = acpi_ut_hex_to_ascii_char((u64)swapped_id, 0);
+	out_string[7] = 0;
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_integer_to_string
+ *
+ * PARAMETERS:  out_string      - Where to put the converted string. At least
+ *                                21 bytes are needed to hold the largest
+ *                                possible 64-bit integer.
+ *              Value           - Value to be converted
+ *
+ * RETURN:      None, string
+ *
+ * DESCRIPTION: Convert a 64-bit integer to decimal string representation.
+ *              Assumes string buffer is large enough to hold the string. The
+ *              largest string is (ACPI_MAX64_DECIMAL_DIGITS + 1).
+ *
+ ******************************************************************************/
+
+void acpi_ex_integer_to_string(char *out_string, u64 value)
+{
+	u32 count;
+	u32 digits_needed;
+	u32 remainder;
+
+	ACPI_FUNCTION_ENTRY();
+
+	digits_needed = acpi_ex_digits_needed(value, 10);
+	out_string[digits_needed] = 0;
+
+	for (count = digits_needed; count > 0; count--) {
+		(void)acpi_ut_short_divide(value, 10, &value, &remainder);
+		out_string[count - 1] = (char)('0' + remainder);
+	}
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_is_valid_space_id
+ *
+ * PARAMETERS:  space_id            - ID to be validated
+ *
+ * RETURN:      TRUE if valid/supported ID.
+ *
+ * DESCRIPTION: Validate an operation region space_iD.
+ *
+ ******************************************************************************/
+
+u8 acpi_is_valid_space_id(u8 space_id)
+{
+
+	if ((space_id >= ACPI_NUM_PREDEFINED_REGIONS) &&
+	    (space_id < ACPI_USER_REGION_BEGIN) &&
+	    (space_id != ACPI_ADR_SPACE_DATA_TABLE) &&
+	    (space_id != ACPI_ADR_SPACE_FIXED_HARDWARE)) {
+		return (FALSE);
+	}
+
+	return (TRUE);
+}
+
+#endif
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/hwacpi.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/hwacpi.c
new file mode 100644
index 00000000..38fcb1a6
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/hwacpi.c
@@ -0,0 +1,185 @@
+
+/******************************************************************************
+ *
+ * Module Name: hwacpi - ACPI Hardware Initialization/Mode Interface
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+
+#define _COMPONENT          ACPI_HARDWARE
+ACPI_MODULE_NAME("hwacpi")
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_hw_set_mode
+ *
+ * PARAMETERS:  Mode            - SYS_MODE_ACPI or SYS_MODE_LEGACY
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Transitions the system into the requested mode.
+ *
+ ******************************************************************************/
+acpi_status acpi_hw_set_mode(u32 mode)
+{
+
+	acpi_status status;
+	u32 retry;
+
+	ACPI_FUNCTION_TRACE(hw_set_mode);
+
+	/*
+	 * ACPI 2.0 clarified that if SMI_CMD in FADT is zero,
+	 * system does not support mode transition.
+	 */
+	if (!acpi_gbl_FADT.smi_command) {
+		ACPI_ERROR((AE_INFO,
+			    "No SMI_CMD in FADT, mode transition failed"));
+		return_ACPI_STATUS(AE_NO_HARDWARE_RESPONSE);
+	}
+
+	/*
+	 * ACPI 2.0 clarified the meaning of ACPI_ENABLE and ACPI_DISABLE
+	 * in FADT: If it is zero, enabling or disabling is not supported.
+	 * As old systems may have used zero for mode transition,
+	 * we make sure both the numbers are zero to determine these
+	 * transitions are not supported.
+	 */
+	if (!acpi_gbl_FADT.acpi_enable && !acpi_gbl_FADT.acpi_disable) {
+		ACPI_ERROR((AE_INFO,
+			    "No ACPI mode transition supported in this system "
+			    "(enable/disable both zero)"));
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	switch (mode) {
+	case ACPI_SYS_MODE_ACPI:
+
+		/* BIOS should have disabled ALL fixed and GP events */
+
+		status = acpi_hw_write_port(acpi_gbl_FADT.smi_command,
+					    (u32)acpi_gbl_FADT.acpi_enable, 8);
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+				  "Attempting to enable ACPI mode\n"));
+		break;
+
+	case ACPI_SYS_MODE_LEGACY:
+
+		/*
+		 * BIOS should clear all fixed status bits and restore fixed event
+		 * enable bits to default
+		 */
+		status = acpi_hw_write_port(acpi_gbl_FADT.smi_command,
+					    (u32)acpi_gbl_FADT.acpi_disable, 8);
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+				  "Attempting to enable Legacy (non-ACPI) mode\n"));
+		break;
+
+	default:
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	if (ACPI_FAILURE(status)) {
+		ACPI_EXCEPTION((AE_INFO, status,
+				"Could not write ACPI mode change"));
+		return_ACPI_STATUS(status);
+	}
+
+	/*
+	 * Some hardware takes a LONG time to switch modes. Give them 3 sec to
+	 * do so, but allow faster systems to proceed more quickly.
+	 */
+	retry = 3000;
+	while (retry) {
+		if (acpi_hw_get_mode() == mode) {
+			ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+					  "Mode %X successfully enabled\n",
+					  mode));
+			return_ACPI_STATUS(AE_OK);
+		}
+		acpi_os_stall(1000);
+		retry--;
+	}
+
+	ACPI_ERROR((AE_INFO, "Hardware did not change modes"));
+	return_ACPI_STATUS(AE_NO_HARDWARE_RESPONSE);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_hw_get_mode
+ *
+ * PARAMETERS:  none
+ *
+ * RETURN:      SYS_MODE_ACPI or SYS_MODE_LEGACY
+ *
+ * DESCRIPTION: Return current operating state of system.  Determined by
+ *              querying the SCI_EN bit.
+ *
+ ******************************************************************************/
+
+u32 acpi_hw_get_mode(void)
+{
+	acpi_status status;
+	u32 value;
+
+	ACPI_FUNCTION_TRACE(hw_get_mode);
+
+	/*
+	 * ACPI 2.0 clarified that if SMI_CMD in FADT is zero,
+	 * system does not support mode transition.
+	 */
+	if (!acpi_gbl_FADT.smi_command) {
+		return_UINT32(ACPI_SYS_MODE_ACPI);
+	}
+
+	status = acpi_read_bit_register(ACPI_BITREG_SCI_ENABLE, &value);
+	if (ACPI_FAILURE(status)) {
+		return_UINT32(ACPI_SYS_MODE_LEGACY);
+	}
+
+	if (value) {
+		return_UINT32(ACPI_SYS_MODE_ACPI);
+	} else {
+		return_UINT32(ACPI_SYS_MODE_LEGACY);
+	}
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/hwgpe.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/hwgpe.c
new file mode 100644
index 00000000..b4685492
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/hwgpe.c
@@ -0,0 +1,485 @@
+
+/******************************************************************************
+ *
+ * Module Name: hwgpe - Low level GPE enable/disable/clear functions
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acevents.h"
+
+#define _COMPONENT          ACPI_HARDWARE
+ACPI_MODULE_NAME("hwgpe")
+
+/* Local prototypes */
+static acpi_status
+acpi_hw_enable_wakeup_gpe_block(struct acpi_gpe_xrupt_info *gpe_xrupt_info,
+				struct acpi_gpe_block_info *gpe_block,
+				void *context);
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_hw_get_gpe_register_bit
+ *
+ * PARAMETERS:  gpe_event_info      - Info block for the GPE
+ *              gpe_register_info   - Info block for the GPE register
+ *
+ * RETURN:      Register mask with a one in the GPE bit position
+ *
+ * DESCRIPTION: Compute the register mask for this GPE. One bit is set in the
+ *              correct position for the input GPE.
+ *
+ ******************************************************************************/
+
+u32
+acpi_hw_get_gpe_register_bit(struct acpi_gpe_event_info *gpe_event_info,
+			     struct acpi_gpe_register_info *gpe_register_info)
+{
+
+	return ((u32)1 <<
+		(gpe_event_info->gpe_number -
+		 gpe_register_info->base_gpe_number));
+}
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_hw_low_set_gpe
+ *
+ * PARAMETERS:  gpe_event_info      - Info block for the GPE to be disabled
+ *              Action              - Enable or disable
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Enable or disable a single GPE in the parent enable register.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_hw_low_set_gpe(struct acpi_gpe_event_info *gpe_event_info, u32 action)
+{
+	struct acpi_gpe_register_info *gpe_register_info;
+	acpi_status status;
+	u32 enable_mask;
+	u32 register_bit;
+
+	ACPI_FUNCTION_ENTRY();
+
+	/* Get the info block for the entire GPE register */
+
+	gpe_register_info = gpe_event_info->register_info;
+	if (!gpe_register_info) {
+		return (AE_NOT_EXIST);
+	}
+
+	/* Get current value of the enable register that contains this GPE */
+
+	status = acpi_hw_read(&enable_mask, &gpe_register_info->enable_address);
+	if (ACPI_FAILURE(status)) {
+		return (status);
+	}
+
+	/* Set or clear just the bit that corresponds to this GPE */
+
+	register_bit =
+	    acpi_hw_get_gpe_register_bit(gpe_event_info, gpe_register_info);
+	switch (action) {
+	case ACPI_GPE_CONDITIONAL_ENABLE:
+
+		/* Only enable if the enable_for_run bit is set */
+
+		if (!(register_bit & gpe_register_info->enable_for_run)) {
+			return (AE_BAD_PARAMETER);
+		}
+
+		/*lint -fallthrough */
+
+	case ACPI_GPE_ENABLE:
+		ACPI_SET_BIT(enable_mask, register_bit);
+		break;
+
+	case ACPI_GPE_DISABLE:
+		ACPI_CLEAR_BIT(enable_mask, register_bit);
+		break;
+
+	default:
+		ACPI_ERROR((AE_INFO, "Invalid GPE Action, %u\n", action));
+		return (AE_BAD_PARAMETER);
+	}
+
+	/* Write the updated enable mask */
+
+	status = acpi_hw_write(enable_mask, &gpe_register_info->enable_address);
+	return (status);
+}
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_hw_clear_gpe
+ *
+ * PARAMETERS:  gpe_event_info      - Info block for the GPE to be cleared
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Clear the status bit for a single GPE.
+ *
+ ******************************************************************************/
+
+acpi_status acpi_hw_clear_gpe(struct acpi_gpe_event_info * gpe_event_info)
+{
+	struct acpi_gpe_register_info *gpe_register_info;
+	acpi_status status;
+	u32 register_bit;
+
+	ACPI_FUNCTION_ENTRY();
+
+	/* Get the info block for the entire GPE register */
+
+	gpe_register_info = gpe_event_info->register_info;
+	if (!gpe_register_info) {
+		return (AE_NOT_EXIST);
+	}
+
+	/*
+	 * Write a one to the appropriate bit in the status register to
+	 * clear this GPE.
+	 */
+	register_bit =
+	    acpi_hw_get_gpe_register_bit(gpe_event_info, gpe_register_info);
+
+	status = acpi_hw_write(register_bit,
+			       &gpe_register_info->status_address);
+
+	return (status);
+}
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_hw_get_gpe_status
+ *
+ * PARAMETERS:  gpe_event_info      - Info block for the GPE to queried
+ *              event_status        - Where the GPE status is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Return the status of a single GPE.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_hw_get_gpe_status(struct acpi_gpe_event_info * gpe_event_info,
+		       acpi_event_status *event_status)
+{
+	u32 in_byte;
+	u32 register_bit;
+	struct acpi_gpe_register_info *gpe_register_info;
+	acpi_event_status local_event_status = 0;
+	acpi_status status;
+
+	ACPI_FUNCTION_ENTRY();
+
+	if (!event_status) {
+		return (AE_BAD_PARAMETER);
+	}
+
+	/* Get the info block for the entire GPE register */
+
+	gpe_register_info = gpe_event_info->register_info;
+
+	/* Get the register bitmask for this GPE */
+
+	register_bit =
+	    acpi_hw_get_gpe_register_bit(gpe_event_info, gpe_register_info);
+
+	/* GPE currently enabled? (enabled for runtime?) */
+
+	if (register_bit & gpe_register_info->enable_for_run) {
+		local_event_status |= ACPI_EVENT_FLAG_ENABLED;
+	}
+
+	/* GPE enabled for wake? */
+
+	if (register_bit & gpe_register_info->enable_for_wake) {
+		local_event_status |= ACPI_EVENT_FLAG_WAKE_ENABLED;
+	}
+
+	/* GPE currently active (status bit == 1)? */
+
+	status = acpi_hw_read(&in_byte, &gpe_register_info->status_address);
+	if (ACPI_FAILURE(status)) {
+		return (status);
+	}
+
+	if (register_bit & in_byte) {
+		local_event_status |= ACPI_EVENT_FLAG_SET;
+	}
+
+	/* Set return value */
+
+	(*event_status) = local_event_status;
+	return (AE_OK);
+}
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_hw_disable_gpe_block
+ *
+ * PARAMETERS:  gpe_xrupt_info      - GPE Interrupt info
+ *              gpe_block           - Gpe Block info
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Disable all GPEs within a single GPE block
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_hw_disable_gpe_block(struct acpi_gpe_xrupt_info * gpe_xrupt_info,
+			  struct acpi_gpe_block_info * gpe_block, void *context)
+{
+	u32 i;
+	acpi_status status;
+
+	/* Examine each GPE Register within the block */
+
+	for (i = 0; i < gpe_block->register_count; i++) {
+
+		/* Disable all GPEs in this register */
+
+		status =
+		    acpi_hw_write(0x00,
+				  &gpe_block->register_info[i].enable_address);
+		if (ACPI_FAILURE(status)) {
+			return (status);
+		}
+	}
+
+	return (AE_OK);
+}
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_hw_clear_gpe_block
+ *
+ * PARAMETERS:  gpe_xrupt_info      - GPE Interrupt info
+ *              gpe_block           - Gpe Block info
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Clear status bits for all GPEs within a single GPE block
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_hw_clear_gpe_block(struct acpi_gpe_xrupt_info * gpe_xrupt_info,
+			struct acpi_gpe_block_info * gpe_block, void *context)
+{
+	u32 i;
+	acpi_status status;
+
+	/* Examine each GPE Register within the block */
+
+	for (i = 0; i < gpe_block->register_count; i++) {
+
+		/* Clear status on all GPEs in this register */
+
+		status =
+		    acpi_hw_write(0xFF,
+				  &gpe_block->register_info[i].status_address);
+		if (ACPI_FAILURE(status)) {
+			return (status);
+		}
+	}
+
+	return (AE_OK);
+}
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_hw_enable_runtime_gpe_block
+ *
+ * PARAMETERS:  gpe_xrupt_info      - GPE Interrupt info
+ *              gpe_block           - Gpe Block info
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Enable all "runtime" GPEs within a single GPE block. Includes
+ *              combination wake/run GPEs.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_hw_enable_runtime_gpe_block(struct acpi_gpe_xrupt_info * gpe_xrupt_info,
+				 struct acpi_gpe_block_info * gpe_block,
+				 void *context)
+{
+	u32 i;
+	acpi_status status;
+
+	/* NOTE: assumes that all GPEs are currently disabled */
+
+	/* Examine each GPE Register within the block */
+
+	for (i = 0; i < gpe_block->register_count; i++) {
+		if (!gpe_block->register_info[i].enable_for_run) {
+			continue;
+		}
+
+		/* Enable all "runtime" GPEs in this register */
+
+		status =
+		    acpi_hw_write(gpe_block->register_info[i].enable_for_run,
+				  &gpe_block->register_info[i].enable_address);
+		if (ACPI_FAILURE(status)) {
+			return (status);
+		}
+	}
+
+	return (AE_OK);
+}
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_hw_enable_wakeup_gpe_block
+ *
+ * PARAMETERS:  gpe_xrupt_info      - GPE Interrupt info
+ *              gpe_block           - Gpe Block info
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Enable all "wake" GPEs within a single GPE block. Includes
+ *              combination wake/run GPEs.
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_hw_enable_wakeup_gpe_block(struct acpi_gpe_xrupt_info *gpe_xrupt_info,
+				struct acpi_gpe_block_info *gpe_block,
+				void *context)
+{
+	u32 i;
+	acpi_status status;
+
+	/* Examine each GPE Register within the block */
+
+	for (i = 0; i < gpe_block->register_count; i++) {
+		if (!gpe_block->register_info[i].enable_for_wake) {
+			continue;
+		}
+
+		/* Enable all "wake" GPEs in this register */
+
+		status =
+		    acpi_hw_write(gpe_block->register_info[i].enable_for_wake,
+				  &gpe_block->register_info[i].enable_address);
+		if (ACPI_FAILURE(status)) {
+			return (status);
+		}
+	}
+
+	return (AE_OK);
+}
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_hw_disable_all_gpes
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Disable and clear all GPEs in all GPE blocks
+ *
+ ******************************************************************************/
+
+acpi_status acpi_hw_disable_all_gpes(void)
+{
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(hw_disable_all_gpes);
+
+	status = acpi_ev_walk_gpe_list(acpi_hw_disable_gpe_block, NULL);
+	status = acpi_ev_walk_gpe_list(acpi_hw_clear_gpe_block, NULL);
+	return_ACPI_STATUS(status);
+}
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_hw_enable_all_runtime_gpes
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Enable all "runtime" GPEs, in all GPE blocks
+ *
+ ******************************************************************************/
+
+acpi_status acpi_hw_enable_all_runtime_gpes(void)
+{
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(hw_enable_all_runtime_gpes);
+
+	status = acpi_ev_walk_gpe_list(acpi_hw_enable_runtime_gpe_block, NULL);
+	return_ACPI_STATUS(status);
+}
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_hw_enable_all_wakeup_gpes
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Enable all "wakeup" GPEs, in all GPE blocks
+ *
+ ******************************************************************************/
+
+acpi_status acpi_hw_enable_all_wakeup_gpes(void)
+{
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(hw_enable_all_wakeup_gpes);
+
+	status = acpi_ev_walk_gpe_list(acpi_hw_enable_wakeup_gpe_block, NULL);
+	return_ACPI_STATUS(status);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/hwpci.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/hwpci.c
new file mode 100644
index 00000000..1455ddcd
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/hwpci.c
@@ -0,0 +1,412 @@
+/*******************************************************************************
+ *
+ * Module Name: hwpci - Obtain PCI bus, device, and function numbers
+ *
+ ******************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+
+#define _COMPONENT          ACPI_NAMESPACE
+ACPI_MODULE_NAME("hwpci")
+
+/* PCI configuration space values */
+#define PCI_CFG_HEADER_TYPE_REG             0x0E
+#define PCI_CFG_PRIMARY_BUS_NUMBER_REG      0x18
+#define PCI_CFG_SECONDARY_BUS_NUMBER_REG    0x19
+/* PCI header values */
+#define PCI_HEADER_TYPE_MASK                0x7F
+#define PCI_TYPE_BRIDGE                     0x01
+#define PCI_TYPE_CARDBUS_BRIDGE             0x02
+typedef struct acpi_pci_device {
+	acpi_handle device;
+	struct acpi_pci_device *next;
+
+} acpi_pci_device;
+
+/* Local prototypes */
+
+static acpi_status
+acpi_hw_build_pci_list(acpi_handle root_pci_device,
+		       acpi_handle pci_region,
+		       struct acpi_pci_device **return_list_head);
+
+static acpi_status
+acpi_hw_process_pci_list(struct acpi_pci_id *pci_id,
+			 struct acpi_pci_device *list_head);
+
+static void acpi_hw_delete_pci_list(struct acpi_pci_device *list_head);
+
+static acpi_status
+acpi_hw_get_pci_device_info(struct acpi_pci_id *pci_id,
+			    acpi_handle pci_device,
+			    u16 *bus_number, u8 *is_bridge);
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_hw_derive_pci_id
+ *
+ * PARAMETERS:  pci_id              - Initial values for the PCI ID. May be
+ *                                    modified by this function.
+ *              root_pci_device     - A handle to a PCI device object. This
+ *                                    object must be a PCI Root Bridge having a
+ *                                    _HID value of either PNP0A03 or PNP0A08
+ *              pci_region          - A handle to a PCI configuration space
+ *                                    Operation Region being initialized
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: This function derives a full PCI ID for a PCI device,
+ *              consisting of a Segment number, Bus number, Device number,
+ *              and function code.
+ *
+ *              The PCI hardware dynamically configures PCI bus numbers
+ *              depending on the bus topology discovered during system
+ *              initialization. This function is invoked during configuration
+ *              of a PCI_Config Operation Region in order to (possibly) update
+ *              the Bus/Device/Function numbers in the pci_id with the actual
+ *              values as determined by the hardware and operating system
+ *              configuration.
+ *
+ *              The pci_id parameter is initially populated during the Operation
+ *              Region initialization. This function is then called, and is
+ *              will make any necessary modifications to the Bus, Device, or
+ *              Function number PCI ID subfields as appropriate for the
+ *              current hardware and OS configuration.
+ *
+ * NOTE:        Created 08/2010. Replaces the previous OSL acpi_os_derive_pci_id
+ *              interface since this feature is OS-independent. This module
+ *              specifically avoids any use of recursion by building a local
+ *              temporary device list.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_hw_derive_pci_id(struct acpi_pci_id *pci_id,
+		      acpi_handle root_pci_device, acpi_handle pci_region)
+{
+	acpi_status status;
+	struct acpi_pci_device *list_head = NULL;
+
+	ACPI_FUNCTION_TRACE(hw_derive_pci_id);
+
+	if (!pci_id) {
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	/* Build a list of PCI devices, from pci_region up to root_pci_device */
+
+	status =
+	    acpi_hw_build_pci_list(root_pci_device, pci_region, &list_head);
+	if (ACPI_SUCCESS(status)) {
+
+		/* Walk the list, updating the PCI device/function/bus numbers */
+
+		status = acpi_hw_process_pci_list(pci_id, list_head);
+	}
+
+	/* Always delete the list */
+
+	acpi_hw_delete_pci_list(list_head);
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_hw_build_pci_list
+ *
+ * PARAMETERS:  root_pci_device     - A handle to a PCI device object. This
+ *                                    object is guaranteed to be a PCI Root
+ *                                    Bridge having a _HID value of either
+ *                                    PNP0A03 or PNP0A08
+ *              pci_region          - A handle to the PCI configuration space
+ *                                    Operation Region
+ *              return_list_head    - Where the PCI device list is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Builds a list of devices from the input PCI region up to the
+ *              Root PCI device for this namespace subtree.
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_hw_build_pci_list(acpi_handle root_pci_device,
+		       acpi_handle pci_region,
+		       struct acpi_pci_device **return_list_head)
+{
+	acpi_handle current_device;
+	acpi_handle parent_device;
+	acpi_status status;
+	struct acpi_pci_device *list_element;
+	struct acpi_pci_device *list_head = NULL;
+
+	/*
+	 * Ascend namespace branch until the root_pci_device is reached, building
+	 * a list of device nodes. Loop will exit when either the PCI device is
+	 * found, or the root of the namespace is reached.
+	 */
+	current_device = pci_region;
+	while (1) {
+		status = acpi_get_parent(current_device, &parent_device);
+		if (ACPI_FAILURE(status)) {
+			return (status);
+		}
+
+		/* Finished when we reach the PCI root device (PNP0A03 or PNP0A08) */
+
+		if (parent_device == root_pci_device) {
+			*return_list_head = list_head;
+			return (AE_OK);
+		}
+
+		list_element = ACPI_ALLOCATE(sizeof(struct acpi_pci_device));
+		if (!list_element) {
+			return (AE_NO_MEMORY);
+		}
+
+		/* Put new element at the head of the list */
+
+		list_element->next = list_head;
+		list_element->device = parent_device;
+		list_head = list_element;
+
+		current_device = parent_device;
+	}
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_hw_process_pci_list
+ *
+ * PARAMETERS:  pci_id              - Initial values for the PCI ID. May be
+ *                                    modified by this function.
+ *              list_head           - Device list created by
+ *                                    acpi_hw_build_pci_list
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Walk downward through the PCI device list, getting the device
+ *              info for each, via the PCI configuration space and updating
+ *              the PCI ID as necessary. Deletes the list during traversal.
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_hw_process_pci_list(struct acpi_pci_id *pci_id,
+			 struct acpi_pci_device *list_head)
+{
+	acpi_status status = AE_OK;
+	struct acpi_pci_device *info;
+	u16 bus_number;
+	u8 is_bridge = TRUE;
+
+	ACPI_FUNCTION_NAME(hw_process_pci_list);
+
+	ACPI_DEBUG_PRINT((ACPI_DB_OPREGION,
+			  "Input PciId:  Seg %4.4X Bus %4.4X Dev %4.4X Func %4.4X\n",
+			  pci_id->segment, pci_id->bus, pci_id->device,
+			  pci_id->function));
+
+	bus_number = pci_id->bus;
+
+	/*
+	 * Descend down the namespace tree, collecting PCI device, function,
+	 * and bus numbers. bus_number is only important for PCI bridges.
+	 * Algorithm: As we descend the tree, use the last valid PCI device,
+	 * function, and bus numbers that are discovered, and assign them
+	 * to the PCI ID for the target device.
+	 */
+	info = list_head;
+	while (info) {
+		status = acpi_hw_get_pci_device_info(pci_id, info->device,
+						     &bus_number, &is_bridge);
+		if (ACPI_FAILURE(status)) {
+			return_ACPI_STATUS(status);
+		}
+
+		info = info->next;
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_OPREGION,
+			  "Output PciId: Seg %4.4X Bus %4.4X Dev %4.4X Func %4.4X "
+			  "Status %X BusNumber %X IsBridge %X\n",
+			  pci_id->segment, pci_id->bus, pci_id->device,
+			  pci_id->function, status, bus_number, is_bridge));
+
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_hw_delete_pci_list
+ *
+ * PARAMETERS:  list_head           - Device list created by
+ *                                    acpi_hw_build_pci_list
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Free the entire PCI list.
+ *
+ ******************************************************************************/
+
+static void acpi_hw_delete_pci_list(struct acpi_pci_device *list_head)
+{
+	struct acpi_pci_device *next;
+	struct acpi_pci_device *previous;
+
+	next = list_head;
+	while (next) {
+		previous = next;
+		next = previous->next;
+		ACPI_FREE(previous);
+	}
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_hw_get_pci_device_info
+ *
+ * PARAMETERS:  pci_id              - Initial values for the PCI ID. May be
+ *                                    modified by this function.
+ *              pci_device          - Handle for the PCI device object
+ *              bus_number          - Where a PCI bridge bus number is returned
+ *              is_bridge           - Return value, indicates if this PCI
+ *                                    device is a PCI bridge
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Get the device info for a single PCI device object. Get the
+ *              _ADR (contains PCI device and function numbers), and for PCI
+ *              bridge devices, get the bus number from PCI configuration
+ *              space.
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_hw_get_pci_device_info(struct acpi_pci_id *pci_id,
+			    acpi_handle pci_device,
+			    u16 *bus_number, u8 *is_bridge)
+{
+	acpi_status status;
+	acpi_object_type object_type;
+	u64 return_value;
+	u64 pci_value;
+
+	/* We only care about objects of type Device */
+
+	status = acpi_get_type(pci_device, &object_type);
+	if (ACPI_FAILURE(status)) {
+		return (status);
+	}
+
+	if (object_type != ACPI_TYPE_DEVICE) {
+		return (AE_OK);
+	}
+
+	/* We need an _ADR. Ignore device if not present */
+
+	status = acpi_ut_evaluate_numeric_object(METHOD_NAME__ADR,
+						 pci_device, &return_value);
+	if (ACPI_FAILURE(status)) {
+		return (AE_OK);
+	}
+
+	/*
+	 * From _ADR, get the PCI Device and Function and
+	 * update the PCI ID.
+	 */
+	pci_id->device = ACPI_HIWORD(ACPI_LODWORD(return_value));
+	pci_id->function = ACPI_LOWORD(ACPI_LODWORD(return_value));
+
+	/*
+	 * If the previous device was a bridge, use the previous
+	 * device bus number
+	 */
+	if (*is_bridge) {
+		pci_id->bus = *bus_number;
+	}
+
+	/*
+	 * Get the bus numbers from PCI Config space:
+	 *
+	 * First, get the PCI header_type
+	 */
+	*is_bridge = FALSE;
+	status = acpi_os_read_pci_configuration(pci_id,
+						PCI_CFG_HEADER_TYPE_REG,
+						&pci_value, 8);
+	if (ACPI_FAILURE(status)) {
+		return (status);
+	}
+
+	/* We only care about bridges (1=pci_bridge, 2=card_bus_bridge) */
+
+	pci_value &= PCI_HEADER_TYPE_MASK;
+
+	if ((pci_value != PCI_TYPE_BRIDGE) &&
+	    (pci_value != PCI_TYPE_CARDBUS_BRIDGE)) {
+		return (AE_OK);
+	}
+
+	/* Bridge: Get the Primary bus_number */
+
+	status = acpi_os_read_pci_configuration(pci_id,
+						PCI_CFG_PRIMARY_BUS_NUMBER_REG,
+						&pci_value, 8);
+	if (ACPI_FAILURE(status)) {
+		return (status);
+	}
+
+	*is_bridge = TRUE;
+	pci_id->bus = (u16)pci_value;
+
+	/* Bridge: Get the Secondary bus_number */
+
+	status = acpi_os_read_pci_configuration(pci_id,
+						PCI_CFG_SECONDARY_BUS_NUMBER_REG,
+						&pci_value, 8);
+	if (ACPI_FAILURE(status)) {
+		return (status);
+	}
+
+	*bus_number = (u16)pci_value;
+	return (AE_OK);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/hwregs.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/hwregs.c
new file mode 100644
index 00000000..b5a9c486
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/hwregs.c
@@ -0,0 +1,658 @@
+
+/*******************************************************************************
+ *
+ * Module Name: hwregs - Read/write access functions for the various ACPI
+ *                       control and status registers.
+ *
+ ******************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acevents.h"
+
+#define _COMPONENT          ACPI_HARDWARE
+ACPI_MODULE_NAME("hwregs")
+
+/* Local Prototypes */
+static acpi_status
+acpi_hw_read_multiple(u32 *value,
+		      struct acpi_generic_address *register_a,
+		      struct acpi_generic_address *register_b);
+
+static acpi_status
+acpi_hw_write_multiple(u32 value,
+		       struct acpi_generic_address *register_a,
+		       struct acpi_generic_address *register_b);
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_hw_validate_register
+ *
+ * PARAMETERS:  Reg                 - GAS register structure
+ *              max_bit_width       - Max bit_width supported (32 or 64)
+ *              Address             - Pointer to where the gas->address
+ *                                    is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Validate the contents of a GAS register. Checks the GAS
+ *              pointer, Address, space_id, bit_width, and bit_offset.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_hw_validate_register(struct acpi_generic_address *reg,
+			  u8 max_bit_width, u64 *address)
+{
+
+	/* Must have a valid pointer to a GAS structure */
+
+	if (!reg) {
+		return (AE_BAD_PARAMETER);
+	}
+
+	/*
+	 * Copy the target address. This handles possible alignment issues.
+	 * Address must not be null. A null address also indicates an optional
+	 * ACPI register that is not supported, so no error message.
+	 */
+	ACPI_MOVE_64_TO_64(address, &reg->address);
+	if (!(*address)) {
+		return (AE_BAD_ADDRESS);
+	}
+
+	/* Validate the space_iD */
+
+	if ((reg->space_id != ACPI_ADR_SPACE_SYSTEM_MEMORY) &&
+	    (reg->space_id != ACPI_ADR_SPACE_SYSTEM_IO)) {
+		ACPI_ERROR((AE_INFO,
+			    "Unsupported address space: 0x%X", reg->space_id));
+		return (AE_SUPPORT);
+	}
+
+	/* Validate the bit_width */
+
+	if ((reg->bit_width != 8) &&
+	    (reg->bit_width != 16) &&
+	    (reg->bit_width != 32) && (reg->bit_width != max_bit_width)) {
+		ACPI_ERROR((AE_INFO,
+			    "Unsupported register bit width: 0x%X",
+			    reg->bit_width));
+		return (AE_SUPPORT);
+	}
+
+	/* Validate the bit_offset. Just a warning for now. */
+
+	if (reg->bit_offset != 0) {
+		ACPI_WARNING((AE_INFO,
+			      "Unsupported register bit offset: 0x%X",
+			      reg->bit_offset));
+	}
+
+	return (AE_OK);
+}
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_hw_read
+ *
+ * PARAMETERS:  Value               - Where the value is returned
+ *              Reg                 - GAS register structure
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Read from either memory or IO space. This is a 32-bit max
+ *              version of acpi_read, used internally since the overhead of
+ *              64-bit values is not needed.
+ *
+ * LIMITATIONS: <These limitations also apply to acpi_hw_write>
+ *      bit_width must be exactly 8, 16, or 32.
+ *      space_iD must be system_memory or system_iO.
+ *      bit_offset and access_width are currently ignored, as there has
+ *          not been a need to implement these.
+ *
+ ******************************************************************************/
+
+acpi_status acpi_hw_read(u32 *value, struct acpi_generic_address * reg)
+{
+	u64 address;
+	acpi_status status;
+
+	ACPI_FUNCTION_NAME(hw_read);
+
+	/* Validate contents of the GAS register */
+
+	status = acpi_hw_validate_register(reg, 32, &address);
+	if (ACPI_FAILURE(status)) {
+		return (status);
+	}
+
+	/* Initialize entire 32-bit return value to zero */
+
+	*value = 0;
+
+	/*
+	 * Two address spaces supported: Memory or IO. PCI_Config is
+	 * not supported here because the GAS structure is insufficient
+	 */
+	if (reg->space_id == ACPI_ADR_SPACE_SYSTEM_MEMORY) {
+		status = acpi_os_read_memory((acpi_physical_address)
+					     address, value, reg->bit_width);
+	} else {		/* ACPI_ADR_SPACE_SYSTEM_IO, validated earlier */
+
+		status = acpi_hw_read_port((acpi_io_address)
+					   address, value, reg->bit_width);
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_IO,
+			  "Read:  %8.8X width %2d from %8.8X%8.8X (%s)\n",
+			  *value, reg->bit_width, ACPI_FORMAT_UINT64(address),
+			  acpi_ut_get_region_name(reg->space_id)));
+
+	return (status);
+}
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_hw_write
+ *
+ * PARAMETERS:  Value               - Value to be written
+ *              Reg                 - GAS register structure
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Write to either memory or IO space. This is a 32-bit max
+ *              version of acpi_write, used internally since the overhead of
+ *              64-bit values is not needed.
+ *
+ ******************************************************************************/
+
+acpi_status acpi_hw_write(u32 value, struct acpi_generic_address * reg)
+{
+	u64 address;
+	acpi_status status;
+
+	ACPI_FUNCTION_NAME(hw_write);
+
+	/* Validate contents of the GAS register */
+
+	status = acpi_hw_validate_register(reg, 32, &address);
+	if (ACPI_FAILURE(status)) {
+		return (status);
+	}
+
+	/*
+	 * Two address spaces supported: Memory or IO. PCI_Config is
+	 * not supported here because the GAS structure is insufficient
+	 */
+	if (reg->space_id == ACPI_ADR_SPACE_SYSTEM_MEMORY) {
+		status = acpi_os_write_memory((acpi_physical_address)
+					      address, value, reg->bit_width);
+	} else {		/* ACPI_ADR_SPACE_SYSTEM_IO, validated earlier */
+
+		status = acpi_hw_write_port((acpi_io_address)
+					    address, value, reg->bit_width);
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_IO,
+			  "Wrote: %8.8X width %2d   to %8.8X%8.8X (%s)\n",
+			  value, reg->bit_width, ACPI_FORMAT_UINT64(address),
+			  acpi_ut_get_region_name(reg->space_id)));
+
+	return (status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_hw_clear_acpi_status
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Clears all fixed and general purpose status bits
+ *
+ ******************************************************************************/
+
+acpi_status acpi_hw_clear_acpi_status(void)
+{
+	acpi_status status;
+	acpi_cpu_flags lock_flags = 0;
+
+	ACPI_FUNCTION_TRACE(hw_clear_acpi_status);
+
+	ACPI_DEBUG_PRINT((ACPI_DB_IO, "About to write %04X to %8.8X%8.8X\n",
+			  ACPI_BITMASK_ALL_FIXED_STATUS,
+			  ACPI_FORMAT_UINT64(acpi_gbl_xpm1a_status.address)));
+
+	lock_flags = acpi_os_acquire_lock(acpi_gbl_hardware_lock);
+
+	/* Clear the fixed events in PM1 A/B */
+
+	status = acpi_hw_register_write(ACPI_REGISTER_PM1_STATUS,
+					ACPI_BITMASK_ALL_FIXED_STATUS);
+	if (ACPI_FAILURE(status)) {
+		goto unlock_and_exit;
+	}
+
+	/* Clear the GPE Bits in all GPE registers in all GPE blocks */
+
+	status = acpi_ev_walk_gpe_list(acpi_hw_clear_gpe_block, NULL);
+
+      unlock_and_exit:
+	acpi_os_release_lock(acpi_gbl_hardware_lock, lock_flags);
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_hw_get_register_bit_mask
+ *
+ * PARAMETERS:  register_id         - Index of ACPI Register to access
+ *
+ * RETURN:      The bitmask to be used when accessing the register
+ *
+ * DESCRIPTION: Map register_id into a register bitmask.
+ *
+ ******************************************************************************/
+
+struct acpi_bit_register_info *acpi_hw_get_bit_register_info(u32 register_id)
+{
+	ACPI_FUNCTION_ENTRY();
+
+	if (register_id > ACPI_BITREG_MAX) {
+		ACPI_ERROR((AE_INFO, "Invalid BitRegister ID: 0x%X",
+			    register_id));
+		return (NULL);
+	}
+
+	return (&acpi_gbl_bit_register_info[register_id]);
+}
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_hw_write_pm1_control
+ *
+ * PARAMETERS:  pm1a_control        - Value to be written to PM1A control
+ *              pm1b_control        - Value to be written to PM1B control
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Write the PM1 A/B control registers. These registers are
+ *              different than than the PM1 A/B status and enable registers
+ *              in that different values can be written to the A/B registers.
+ *              Most notably, the SLP_TYP bits can be different, as per the
+ *              values returned from the _Sx predefined methods.
+ *
+ ******************************************************************************/
+
+acpi_status acpi_hw_write_pm1_control(u32 pm1a_control, u32 pm1b_control)
+{
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(hw_write_pm1_control);
+
+	status =
+	    acpi_hw_write(pm1a_control, &acpi_gbl_FADT.xpm1a_control_block);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	if (acpi_gbl_FADT.xpm1b_control_block.address) {
+		status =
+		    acpi_hw_write(pm1b_control,
+				  &acpi_gbl_FADT.xpm1b_control_block);
+	}
+	return_ACPI_STATUS(status);
+}
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_hw_register_read
+ *
+ * PARAMETERS:  register_id         - ACPI Register ID
+ *              return_value        - Where the register value is returned
+ *
+ * RETURN:      Status and the value read.
+ *
+ * DESCRIPTION: Read from the specified ACPI register
+ *
+ ******************************************************************************/
+
+acpi_status acpi_hw_register_read(u32 register_id, u32 *return_value)
+{
+	u32 value = 0;
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(hw_register_read);
+
+	switch (register_id) {
+	case ACPI_REGISTER_PM1_STATUS:	/* PM1 A/B: 16-bit access each */
+
+		status = acpi_hw_read_multiple(&value,
+					       &acpi_gbl_xpm1a_status,
+					       &acpi_gbl_xpm1b_status);
+		break;
+
+	case ACPI_REGISTER_PM1_ENABLE:	/* PM1 A/B: 16-bit access each */
+
+		status = acpi_hw_read_multiple(&value,
+					       &acpi_gbl_xpm1a_enable,
+					       &acpi_gbl_xpm1b_enable);
+		break;
+
+	case ACPI_REGISTER_PM1_CONTROL:	/* PM1 A/B: 16-bit access each */
+
+		status = acpi_hw_read_multiple(&value,
+					       &acpi_gbl_FADT.
+					       xpm1a_control_block,
+					       &acpi_gbl_FADT.
+					       xpm1b_control_block);
+
+		/*
+		 * Zero the write-only bits. From the ACPI specification, "Hardware
+		 * Write-Only Bits": "Upon reads to registers with write-only bits,
+		 * software masks out all write-only bits."
+		 */
+		value &= ~ACPI_PM1_CONTROL_WRITEONLY_BITS;
+		break;
+
+	case ACPI_REGISTER_PM2_CONTROL:	/* 8-bit access */
+
+		status =
+		    acpi_hw_read(&value, &acpi_gbl_FADT.xpm2_control_block);
+		break;
+
+	case ACPI_REGISTER_PM_TIMER:	/* 32-bit access */
+
+		status = acpi_hw_read(&value, &acpi_gbl_FADT.xpm_timer_block);
+		break;
+
+	case ACPI_REGISTER_SMI_COMMAND_BLOCK:	/* 8-bit access */
+
+		status =
+		    acpi_hw_read_port(acpi_gbl_FADT.smi_command, &value, 8);
+		break;
+
+	default:
+		ACPI_ERROR((AE_INFO, "Unknown Register ID: 0x%X", register_id));
+		status = AE_BAD_PARAMETER;
+		break;
+	}
+
+	if (ACPI_SUCCESS(status)) {
+		*return_value = value;
+	}
+
+	return_ACPI_STATUS(status);
+}
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_hw_register_write
+ *
+ * PARAMETERS:  register_id         - ACPI Register ID
+ *              Value               - The value to write
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Write to the specified ACPI register
+ *
+ * NOTE: In accordance with the ACPI specification, this function automatically
+ * preserves the value of the following bits, meaning that these bits cannot be
+ * changed via this interface:
+ *
+ * PM1_CONTROL[0] = SCI_EN
+ * PM1_CONTROL[9]
+ * PM1_STATUS[11]
+ *
+ * ACPI References:
+ * 1) Hardware Ignored Bits: When software writes to a register with ignored
+ *      bit fields, it preserves the ignored bit fields
+ * 2) SCI_EN: OSPM always preserves this bit position
+ *
+ ******************************************************************************/
+
+acpi_status acpi_hw_register_write(u32 register_id, u32 value)
+{
+	acpi_status status;
+	u32 read_value;
+
+	ACPI_FUNCTION_TRACE(hw_register_write);
+
+	switch (register_id) {
+	case ACPI_REGISTER_PM1_STATUS:	/* PM1 A/B: 16-bit access each */
+		/*
+		 * Handle the "ignored" bit in PM1 Status. According to the ACPI
+		 * specification, ignored bits are to be preserved when writing.
+		 * Normally, this would mean a read/modify/write sequence. However,
+		 * preserving a bit in the status register is different. Writing a
+		 * one clears the status, and writing a zero preserves the status.
+		 * Therefore, we must always write zero to the ignored bit.
+		 *
+		 * This behavior is clarified in the ACPI 4.0 specification.
+		 */
+		value &= ~ACPI_PM1_STATUS_PRESERVED_BITS;
+
+		status = acpi_hw_write_multiple(value,
+						&acpi_gbl_xpm1a_status,
+						&acpi_gbl_xpm1b_status);
+		break;
+
+	case ACPI_REGISTER_PM1_ENABLE:	/* PM1 A/B: 16-bit access each */
+
+		status = acpi_hw_write_multiple(value,
+						&acpi_gbl_xpm1a_enable,
+						&acpi_gbl_xpm1b_enable);
+		break;
+
+	case ACPI_REGISTER_PM1_CONTROL:	/* PM1 A/B: 16-bit access each */
+
+		/*
+		 * Perform a read first to preserve certain bits (per ACPI spec)
+		 * Note: This includes SCI_EN, we never want to change this bit
+		 */
+		status = acpi_hw_read_multiple(&read_value,
+					       &acpi_gbl_FADT.
+					       xpm1a_control_block,
+					       &acpi_gbl_FADT.
+					       xpm1b_control_block);
+		if (ACPI_FAILURE(status)) {
+			goto exit;
+		}
+
+		/* Insert the bits to be preserved */
+
+		ACPI_INSERT_BITS(value, ACPI_PM1_CONTROL_PRESERVED_BITS,
+				 read_value);
+
+		/* Now we can write the data */
+
+		status = acpi_hw_write_multiple(value,
+						&acpi_gbl_FADT.
+						xpm1a_control_block,
+						&acpi_gbl_FADT.
+						xpm1b_control_block);
+		break;
+
+	case ACPI_REGISTER_PM2_CONTROL:	/* 8-bit access */
+
+		/*
+		 * For control registers, all reserved bits must be preserved,
+		 * as per the ACPI spec.
+		 */
+		status =
+		    acpi_hw_read(&read_value,
+				 &acpi_gbl_FADT.xpm2_control_block);
+		if (ACPI_FAILURE(status)) {
+			goto exit;
+		}
+
+		/* Insert the bits to be preserved */
+
+		ACPI_INSERT_BITS(value, ACPI_PM2_CONTROL_PRESERVED_BITS,
+				 read_value);
+
+		status =
+		    acpi_hw_write(value, &acpi_gbl_FADT.xpm2_control_block);
+		break;
+
+	case ACPI_REGISTER_PM_TIMER:	/* 32-bit access */
+
+		status = acpi_hw_write(value, &acpi_gbl_FADT.xpm_timer_block);
+		break;
+
+	case ACPI_REGISTER_SMI_COMMAND_BLOCK:	/* 8-bit access */
+
+		/* SMI_CMD is currently always in IO space */
+
+		status =
+		    acpi_hw_write_port(acpi_gbl_FADT.smi_command, value, 8);
+		break;
+
+	default:
+		ACPI_ERROR((AE_INFO, "Unknown Register ID: 0x%X", register_id));
+		status = AE_BAD_PARAMETER;
+		break;
+	}
+
+      exit:
+	return_ACPI_STATUS(status);
+}
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_hw_read_multiple
+ *
+ * PARAMETERS:  Value               - Where the register value is returned
+ *              register_a           - First ACPI register (required)
+ *              register_b           - Second ACPI register (optional)
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Read from the specified two-part ACPI register (such as PM1 A/B)
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_hw_read_multiple(u32 *value,
+		      struct acpi_generic_address *register_a,
+		      struct acpi_generic_address *register_b)
+{
+	u32 value_a = 0;
+	u32 value_b = 0;
+	acpi_status status;
+
+	/* The first register is always required */
+
+	status = acpi_hw_read(&value_a, register_a);
+	if (ACPI_FAILURE(status)) {
+		return (status);
+	}
+
+	/* Second register is optional */
+
+	if (register_b->address) {
+		status = acpi_hw_read(&value_b, register_b);
+		if (ACPI_FAILURE(status)) {
+			return (status);
+		}
+	}
+
+	/*
+	 * OR the two return values together. No shifting or masking is necessary,
+	 * because of how the PM1 registers are defined in the ACPI specification:
+	 *
+	 * "Although the bits can be split between the two register blocks (each
+	 * register block has a unique pointer within the FADT), the bit positions
+	 * are maintained. The register block with unimplemented bits (that is,
+	 * those implemented in the other register block) always returns zeros,
+	 * and writes have no side effects"
+	 */
+	*value = (value_a | value_b);
+	return (AE_OK);
+}
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_hw_write_multiple
+ *
+ * PARAMETERS:  Value               - The value to write
+ *              register_a           - First ACPI register (required)
+ *              register_b           - Second ACPI register (optional)
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Write to the specified two-part ACPI register (such as PM1 A/B)
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_hw_write_multiple(u32 value,
+		       struct acpi_generic_address *register_a,
+		       struct acpi_generic_address *register_b)
+{
+	acpi_status status;
+
+	/* The first register is always required */
+
+	status = acpi_hw_write(value, register_a);
+	if (ACPI_FAILURE(status)) {
+		return (status);
+	}
+
+	/*
+	 * Second register is optional
+	 *
+	 * No bit shifting or clearing is necessary, because of how the PM1
+	 * registers are defined in the ACPI specification:
+	 *
+	 * "Although the bits can be split between the two register blocks (each
+	 * register block has a unique pointer within the FADT), the bit positions
+	 * are maintained. The register block with unimplemented bits (that is,
+	 * those implemented in the other register block) always returns zeros,
+	 * and writes have no side effects"
+	 */
+	if (register_b->address) {
+		status = acpi_hw_write(value, register_b);
+	}
+
+	return (status);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/hwsleep.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/hwsleep.c
new file mode 100644
index 00000000..aa54425b
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/hwsleep.c
@@ -0,0 +1,586 @@
+
+/******************************************************************************
+ *
+ * Name: hwsleep.c - ACPI Hardware Sleep/Wake Interface
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+
+#define _COMPONENT          ACPI_HARDWARE
+ACPI_MODULE_NAME("hwsleep")
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_set_firmware_waking_vector
+ *
+ * PARAMETERS:  physical_address    - 32-bit physical address of ACPI real mode
+ *                                    entry point.
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Sets the 32-bit firmware_waking_vector field of the FACS
+ *
+ ******************************************************************************/
+acpi_status acpi_set_firmware_waking_vector(u32 physical_address)
+{
+	ACPI_FUNCTION_TRACE(acpi_set_firmware_waking_vector);
+
+	/* Set the 32-bit vector */
+
+	acpi_gbl_FACS->firmware_waking_vector = physical_address;
+
+	/* Clear the 64-bit vector if it exists */
+
+	if ((acpi_gbl_FACS->length > 32) && (acpi_gbl_FACS->version >= 1)) {
+		acpi_gbl_FACS->xfirmware_waking_vector = 0;
+	}
+
+	return_ACPI_STATUS(AE_OK);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_set_firmware_waking_vector)
+
+#if ACPI_MACHINE_WIDTH == 64
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_set_firmware_waking_vector64
+ *
+ * PARAMETERS:  physical_address    - 64-bit physical address of ACPI protected
+ *                                    mode entry point.
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Sets the 64-bit X_firmware_waking_vector field of the FACS, if
+ *              it exists in the table. This function is intended for use with
+ *              64-bit host operating systems.
+ *
+ ******************************************************************************/
+acpi_status acpi_set_firmware_waking_vector64(u64 physical_address)
+{
+	ACPI_FUNCTION_TRACE(acpi_set_firmware_waking_vector64);
+
+	/* Determine if the 64-bit vector actually exists */
+
+	if ((acpi_gbl_FACS->length <= 32) || (acpi_gbl_FACS->version < 1)) {
+		return_ACPI_STATUS(AE_NOT_EXIST);
+	}
+
+	/* Clear 32-bit vector, set the 64-bit X_ vector */
+
+	acpi_gbl_FACS->firmware_waking_vector = 0;
+	acpi_gbl_FACS->xfirmware_waking_vector = physical_address;
+	return_ACPI_STATUS(AE_OK);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_set_firmware_waking_vector64)
+#endif
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_enter_sleep_state_prep
+ *
+ * PARAMETERS:  sleep_state         - Which sleep state to enter
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Prepare to enter a system sleep state (see ACPI 2.0 spec p 231)
+ *              This function must execute with interrupts enabled.
+ *              We break sleeping into 2 stages so that OSPM can handle
+ *              various OS-specific tasks between the two steps.
+ *
+ ******************************************************************************/
+acpi_status acpi_enter_sleep_state_prep(u8 sleep_state)
+{
+	acpi_status status;
+	struct acpi_object_list arg_list;
+	union acpi_object arg;
+
+	ACPI_FUNCTION_TRACE(acpi_enter_sleep_state_prep);
+
+	/* _PSW methods could be run here to enable wake-on keyboard, LAN, etc. */
+
+	status = acpi_get_sleep_type_data(sleep_state,
+					  &acpi_gbl_sleep_type_a,
+					  &acpi_gbl_sleep_type_b);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/* Execute the _PTS method (Prepare To Sleep) */
+
+	arg_list.count = 1;
+	arg_list.pointer = &arg;
+	arg.type = ACPI_TYPE_INTEGER;
+	arg.integer.value = sleep_state;
+
+	status = acpi_evaluate_object(NULL, METHOD_NAME__PTS, &arg_list, NULL);
+	if (ACPI_FAILURE(status) && status != AE_NOT_FOUND) {
+		return_ACPI_STATUS(status);
+	}
+
+	/* Setup the argument to the _SST method (System STatus) */
+
+	switch (sleep_state) {
+	case ACPI_STATE_S0:
+		arg.integer.value = ACPI_SST_WORKING;
+		break;
+
+	case ACPI_STATE_S1:
+	case ACPI_STATE_S2:
+	case ACPI_STATE_S3:
+		arg.integer.value = ACPI_SST_SLEEPING;
+		break;
+
+	case ACPI_STATE_S4:
+		arg.integer.value = ACPI_SST_SLEEP_CONTEXT;
+		break;
+
+	default:
+		arg.integer.value = ACPI_SST_INDICATOR_OFF;	/* Default is off */
+		break;
+	}
+
+	/*
+	 * Set the system indicators to show the desired sleep state.
+	 * _SST is an optional method (return no error if not found)
+	 */
+	status = acpi_evaluate_object(NULL, METHOD_NAME__SST, &arg_list, NULL);
+	if (ACPI_FAILURE(status) && status != AE_NOT_FOUND) {
+		ACPI_EXCEPTION((AE_INFO, status,
+				"While executing method _SST"));
+	}
+
+	return_ACPI_STATUS(AE_OK);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_enter_sleep_state_prep)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_enter_sleep_state
+ *
+ * PARAMETERS:  sleep_state         - Which sleep state to enter
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Enter a system sleep state
+ *              THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED
+ *
+ ******************************************************************************/
+acpi_status acpi_enter_sleep_state(u8 sleep_state)
+{
+	u32 pm1a_control;
+	u32 pm1b_control;
+	struct acpi_bit_register_info *sleep_type_reg_info;
+	struct acpi_bit_register_info *sleep_enable_reg_info;
+	u32 in_value;
+	struct acpi_object_list arg_list;
+	union acpi_object arg;
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(acpi_enter_sleep_state);
+
+	if ((acpi_gbl_sleep_type_a > ACPI_SLEEP_TYPE_MAX) ||
+	    (acpi_gbl_sleep_type_b > ACPI_SLEEP_TYPE_MAX)) {
+		ACPI_ERROR((AE_INFO, "Sleep values out of range: A=0x%X B=0x%X",
+			    acpi_gbl_sleep_type_a, acpi_gbl_sleep_type_b));
+		return_ACPI_STATUS(AE_AML_OPERAND_VALUE);
+	}
+
+	sleep_type_reg_info =
+	    acpi_hw_get_bit_register_info(ACPI_BITREG_SLEEP_TYPE);
+	sleep_enable_reg_info =
+	    acpi_hw_get_bit_register_info(ACPI_BITREG_SLEEP_ENABLE);
+
+	/* Clear wake status */
+
+	status =
+	    acpi_write_bit_register(ACPI_BITREG_WAKE_STATUS, ACPI_CLEAR_STATUS);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/* Clear all fixed and general purpose status bits */
+
+	status = acpi_hw_clear_acpi_status();
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	if (sleep_state != ACPI_STATE_S5) {
+		/*
+		 * Disable BM arbitration. This feature is contained within an
+		 * optional register (PM2 Control), so ignore a BAD_ADDRESS
+		 * exception.
+		 */
+		status = acpi_write_bit_register(ACPI_BITREG_ARB_DISABLE, 1);
+		if (ACPI_FAILURE(status) && (status != AE_BAD_ADDRESS)) {
+			return_ACPI_STATUS(status);
+		}
+	}
+
+	/*
+	 * 1) Disable/Clear all GPEs
+	 * 2) Enable all wakeup GPEs
+	 */
+	status = acpi_hw_disable_all_gpes();
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+	acpi_gbl_system_awake_and_running = FALSE;
+
+	status = acpi_hw_enable_all_wakeup_gpes();
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/* Execute the _GTS method (Going To Sleep) */
+
+	arg_list.count = 1;
+	arg_list.pointer = &arg;
+	arg.type = ACPI_TYPE_INTEGER;
+	arg.integer.value = sleep_state;
+
+	status = acpi_evaluate_object(NULL, METHOD_NAME__GTS, &arg_list, NULL);
+	if (ACPI_FAILURE(status) && status != AE_NOT_FOUND) {
+		return_ACPI_STATUS(status);
+	}
+
+	/* Get current value of PM1A control */
+
+	status = acpi_hw_register_read(ACPI_REGISTER_PM1_CONTROL,
+				       &pm1a_control);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+	ACPI_DEBUG_PRINT((ACPI_DB_INIT,
+			  "Entering sleep state [S%u]\n", sleep_state));
+
+	/* Clear the SLP_EN and SLP_TYP fields */
+
+	pm1a_control &= ~(sleep_type_reg_info->access_bit_mask |
+			  sleep_enable_reg_info->access_bit_mask);
+	pm1b_control = pm1a_control;
+
+	/* Insert the SLP_TYP bits */
+
+	pm1a_control |=
+	    (acpi_gbl_sleep_type_a << sleep_type_reg_info->bit_position);
+	pm1b_control |=
+	    (acpi_gbl_sleep_type_b << sleep_type_reg_info->bit_position);
+
+	/*
+	 * We split the writes of SLP_TYP and SLP_EN to workaround
+	 * poorly implemented hardware.
+	 */
+
+	/* Write #1: write the SLP_TYP data to the PM1 Control registers */
+
+	status = acpi_hw_write_pm1_control(pm1a_control, pm1b_control);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/* Insert the sleep enable (SLP_EN) bit */
+
+	pm1a_control |= sleep_enable_reg_info->access_bit_mask;
+	pm1b_control |= sleep_enable_reg_info->access_bit_mask;
+
+	/* Flush caches, as per ACPI specification */
+
+	ACPI_FLUSH_CPU_CACHE();
+
+	/* Write #2: Write both SLP_TYP + SLP_EN */
+
+	status = acpi_hw_write_pm1_control(pm1a_control, pm1b_control);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	if (sleep_state > ACPI_STATE_S3) {
+		/*
+		 * We wanted to sleep > S3, but it didn't happen (by virtue of the
+		 * fact that we are still executing!)
+		 *
+		 * Wait ten seconds, then try again. This is to get S4/S5 to work on
+		 * all machines.
+		 *
+		 * We wait so long to allow chipsets that poll this reg very slowly
+		 * to still read the right value. Ideally, this block would go
+		 * away entirely.
+		 */
+		acpi_os_stall(10000000);
+
+		status = acpi_hw_register_write(ACPI_REGISTER_PM1_CONTROL,
+						sleep_enable_reg_info->
+						access_bit_mask);
+		if (ACPI_FAILURE(status)) {
+			return_ACPI_STATUS(status);
+		}
+	}
+
+	/* Wait until we enter sleep state */
+
+	do {
+		status =
+		    acpi_read_bit_register(ACPI_BITREG_WAKE_STATUS, &in_value);
+		if (ACPI_FAILURE(status)) {
+			return_ACPI_STATUS(status);
+		}
+
+		/* Spin until we wake */
+
+	} while (!in_value);
+
+	return_ACPI_STATUS(AE_OK);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_enter_sleep_state)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_enter_sleep_state_s4bios
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Perform a S4 bios request.
+ *              THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED
+ *
+ ******************************************************************************/
+acpi_status acpi_enter_sleep_state_s4bios(void)
+{
+	u32 in_value;
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(acpi_enter_sleep_state_s4bios);
+
+	/* Clear the wake status bit (PM1) */
+
+	status =
+	    acpi_write_bit_register(ACPI_BITREG_WAKE_STATUS, ACPI_CLEAR_STATUS);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	status = acpi_hw_clear_acpi_status();
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/*
+	 * 1) Disable/Clear all GPEs
+	 * 2) Enable all wakeup GPEs
+	 */
+	status = acpi_hw_disable_all_gpes();
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+	acpi_gbl_system_awake_and_running = FALSE;
+
+	status = acpi_hw_enable_all_wakeup_gpes();
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	ACPI_FLUSH_CPU_CACHE();
+
+	status = acpi_hw_write_port(acpi_gbl_FADT.smi_command,
+				    (u32)acpi_gbl_FADT.S4bios_request, 8);
+
+	do {
+		acpi_os_stall(1000);
+		status =
+		    acpi_read_bit_register(ACPI_BITREG_WAKE_STATUS, &in_value);
+		if (ACPI_FAILURE(status)) {
+			return_ACPI_STATUS(status);
+		}
+	} while (!in_value);
+
+	return_ACPI_STATUS(AE_OK);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_enter_sleep_state_s4bios)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_leave_sleep_state
+ *
+ * PARAMETERS:  sleep_state         - Which sleep state we just exited
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Perform OS-independent ACPI cleanup after a sleep
+ *              Called with interrupts ENABLED.
+ *
+ ******************************************************************************/
+acpi_status acpi_leave_sleep_state(u8 sleep_state)
+{
+	struct acpi_object_list arg_list;
+	union acpi_object arg;
+	acpi_status status;
+	struct acpi_bit_register_info *sleep_type_reg_info;
+	struct acpi_bit_register_info *sleep_enable_reg_info;
+	u32 pm1a_control;
+	u32 pm1b_control;
+
+	ACPI_FUNCTION_TRACE(acpi_leave_sleep_state);
+
+	/*
+	 * Set SLP_TYPE and SLP_EN to state S0.
+	 * This is unclear from the ACPI Spec, but it is required
+	 * by some machines.
+	 */
+	status = acpi_get_sleep_type_data(ACPI_STATE_S0,
+					  &acpi_gbl_sleep_type_a,
+					  &acpi_gbl_sleep_type_b);
+	if (ACPI_SUCCESS(status)) {
+		sleep_type_reg_info =
+		    acpi_hw_get_bit_register_info(ACPI_BITREG_SLEEP_TYPE);
+		sleep_enable_reg_info =
+		    acpi_hw_get_bit_register_info(ACPI_BITREG_SLEEP_ENABLE);
+
+		/* Get current value of PM1A control */
+
+		status = acpi_hw_register_read(ACPI_REGISTER_PM1_CONTROL,
+					       &pm1a_control);
+		if (ACPI_SUCCESS(status)) {
+
+			/* Clear the SLP_EN and SLP_TYP fields */
+
+			pm1a_control &= ~(sleep_type_reg_info->access_bit_mask |
+					  sleep_enable_reg_info->
+					  access_bit_mask);
+			pm1b_control = pm1a_control;
+
+			/* Insert the SLP_TYP bits */
+
+			pm1a_control |= (acpi_gbl_sleep_type_a <<
+					 sleep_type_reg_info->bit_position);
+			pm1b_control |= (acpi_gbl_sleep_type_b <<
+					 sleep_type_reg_info->bit_position);
+
+			/* Write the control registers and ignore any errors */
+
+			(void)acpi_hw_write_pm1_control(pm1a_control,
+							pm1b_control);
+		}
+	}
+
+	/* Ensure enter_sleep_state_prep -> enter_sleep_state ordering */
+
+	acpi_gbl_sleep_type_a = ACPI_SLEEP_TYPE_INVALID;
+
+	/* Setup parameter object */
+
+	arg_list.count = 1;
+	arg_list.pointer = &arg;
+	arg.type = ACPI_TYPE_INTEGER;
+
+	/* Ignore any errors from these methods */
+
+	arg.integer.value = ACPI_SST_WAKING;
+	status = acpi_evaluate_object(NULL, METHOD_NAME__SST, &arg_list, NULL);
+	if (ACPI_FAILURE(status) && status != AE_NOT_FOUND) {
+		ACPI_EXCEPTION((AE_INFO, status, "During Method _SST"));
+	}
+
+	arg.integer.value = sleep_state;
+	status = acpi_evaluate_object(NULL, METHOD_NAME__BFS, &arg_list, NULL);
+	if (ACPI_FAILURE(status) && status != AE_NOT_FOUND) {
+		ACPI_EXCEPTION((AE_INFO, status, "During Method _BFS"));
+	}
+
+	status = acpi_evaluate_object(NULL, METHOD_NAME__WAK, &arg_list, NULL);
+	if (ACPI_FAILURE(status) && status != AE_NOT_FOUND) {
+		ACPI_EXCEPTION((AE_INFO, status, "During Method _WAK"));
+	}
+	/* TBD: _WAK "sometimes" returns stuff - do we want to look at it? */
+
+	/*
+	 * Restore the GPEs:
+	 * 1) Disable/Clear all GPEs
+	 * 2) Enable all runtime GPEs
+	 */
+	status = acpi_hw_disable_all_gpes();
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+	acpi_gbl_system_awake_and_running = TRUE;
+
+	status = acpi_hw_enable_all_runtime_gpes();
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/* Enable power button */
+
+	(void)
+	    acpi_write_bit_register(acpi_gbl_fixed_event_info
+				    [ACPI_EVENT_POWER_BUTTON].
+				    enable_register_id, ACPI_ENABLE_EVENT);
+
+	(void)
+	    acpi_write_bit_register(acpi_gbl_fixed_event_info
+				    [ACPI_EVENT_POWER_BUTTON].
+				    status_register_id, ACPI_CLEAR_STATUS);
+
+	/*
+	 * Enable BM arbitration. This feature is contained within an
+	 * optional register (PM2 Control), so ignore a BAD_ADDRESS
+	 * exception.
+	 */
+	status = acpi_write_bit_register(ACPI_BITREG_ARB_DISABLE, 0);
+	if (ACPI_FAILURE(status) && (status != AE_BAD_ADDRESS)) {
+		return_ACPI_STATUS(status);
+	}
+
+	arg.integer.value = ACPI_SST_WORKING;
+	status = acpi_evaluate_object(NULL, METHOD_NAME__SST, &arg_list, NULL);
+	if (ACPI_FAILURE(status) && status != AE_NOT_FOUND) {
+		ACPI_EXCEPTION((AE_INFO, status, "During Method _SST"));
+	}
+
+	return_ACPI_STATUS(status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_leave_sleep_state)
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/hwtimer.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/hwtimer.c
new file mode 100644
index 00000000..08d87d7f
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/hwtimer.c
@@ -0,0 +1,187 @@
+
+/******************************************************************************
+ *
+ * Name: hwtimer.c - ACPI Power Management Timer Interface
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+
+#define _COMPONENT          ACPI_HARDWARE
+ACPI_MODULE_NAME("hwtimer")
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_get_timer_resolution
+ *
+ * PARAMETERS:  Resolution          - Where the resolution is returned
+ *
+ * RETURN:      Status and timer resolution
+ *
+ * DESCRIPTION: Obtains resolution of the ACPI PM Timer (24 or 32 bits).
+ *
+ ******************************************************************************/
+acpi_status acpi_get_timer_resolution(u32 *resolution)
+{
+	ACPI_FUNCTION_TRACE(acpi_get_timer_resolution);
+
+	if (!resolution) {
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	if ((acpi_gbl_FADT.flags & ACPI_FADT_32BIT_TIMER) == 0) {
+		*resolution = 24;
+	} else {
+		*resolution = 32;
+	}
+
+	return_ACPI_STATUS(AE_OK);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_get_timer_resolution)
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_get_timer
+ *
+ * PARAMETERS:  Ticks               - Where the timer value is returned
+ *
+ * RETURN:      Status and current timer value (ticks)
+ *
+ * DESCRIPTION: Obtains current value of ACPI PM Timer (in ticks).
+ *
+ ******************************************************************************/
+acpi_status acpi_get_timer(u32 *ticks)
+{
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(acpi_get_timer);
+
+	if (!ticks) {
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	status = acpi_hw_read(ticks, &acpi_gbl_FADT.xpm_timer_block);
+
+	return_ACPI_STATUS(status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_get_timer)
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_get_timer_duration
+ *
+ * PARAMETERS:  start_ticks         - Starting timestamp
+ *              end_ticks           - End timestamp
+ *              time_elapsed        - Where the elapsed time is returned
+ *
+ * RETURN:      Status and time_elapsed
+ *
+ * DESCRIPTION: Computes the time elapsed (in microseconds) between two
+ *              PM Timer time stamps, taking into account the possibility of
+ *              rollovers, the timer resolution, and timer frequency.
+ *
+ *              The PM Timer's clock ticks at roughly 3.6 times per
+ *              _microsecond_, and its clock continues through Cx state
+ *              transitions (unlike many CPU timestamp counters) -- making it
+ *              a versatile and accurate timer.
+ *
+ *              Note that this function accommodates only a single timer
+ *              rollover.  Thus for 24-bit timers, this function should only
+ *              be used for calculating durations less than ~4.6 seconds
+ *              (~20 minutes for 32-bit timers) -- calculations below:
+ *
+ *              2**24 Ticks / 3,600,000 Ticks/Sec = 4.66 sec
+ *              2**32 Ticks / 3,600,000 Ticks/Sec = 1193 sec or 19.88 minutes
+ *
+ ******************************************************************************/
+acpi_status
+acpi_get_timer_duration(u32 start_ticks, u32 end_ticks, u32 *time_elapsed)
+{
+	acpi_status status;
+	u32 delta_ticks;
+	u64 quotient;
+
+	ACPI_FUNCTION_TRACE(acpi_get_timer_duration);
+
+	if (!time_elapsed) {
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	/*
+	 * Compute Tick Delta:
+	 * Handle (max one) timer rollovers on 24-bit versus 32-bit timers.
+	 */
+	if (start_ticks < end_ticks) {
+		delta_ticks = end_ticks - start_ticks;
+	} else if (start_ticks > end_ticks) {
+		if ((acpi_gbl_FADT.flags & ACPI_FADT_32BIT_TIMER) == 0) {
+
+			/* 24-bit Timer */
+
+			delta_ticks =
+			    (((0x00FFFFFF - start_ticks) +
+			      end_ticks) & 0x00FFFFFF);
+		} else {
+			/* 32-bit Timer */
+
+			delta_ticks = (0xFFFFFFFF - start_ticks) + end_ticks;
+		}
+	} else {		/* start_ticks == end_ticks */
+
+		*time_elapsed = 0;
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	/*
+	 * Compute Duration (Requires a 64-bit multiply and divide):
+	 *
+	 * time_elapsed = (delta_ticks * 1000000) / PM_TIMER_FREQUENCY;
+	 */
+	status = acpi_ut_short_divide(((u64)delta_ticks) * 1000000,
+				      PM_TIMER_FREQUENCY, &quotient, NULL);
+
+	*time_elapsed = (u32)quotient;
+	return_ACPI_STATUS(status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_get_timer_duration)
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/hwvalid.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/hwvalid.c
new file mode 100644
index 00000000..bcd9b0d8
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/hwvalid.c
@@ -0,0 +1,329 @@
+
+/******************************************************************************
+ *
+ * Module Name: hwvalid - I/O request validation
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+
+#define _COMPONENT          ACPI_HARDWARE
+ACPI_MODULE_NAME("hwvalid")
+
+/* Local prototypes */
+static acpi_status
+acpi_hw_validate_io_request(acpi_io_address address, u32 bit_width);
+
+/*
+ * Protected I/O ports. Some ports are always illegal, and some are
+ * conditionally illegal. This table must remain ordered by port address.
+ *
+ * The table is used to implement the Microsoft port access rules that
+ * first appeared in Windows XP. Some ports are always illegal, and some
+ * ports are only illegal if the BIOS calls _OSI with a win_xP string or
+ * later (meaning that the BIOS itelf is post-XP.)
+ *
+ * This provides ACPICA with the desired port protections and
+ * Microsoft compatibility.
+ *
+ * Description of port entries:
+ *  DMA:   DMA controller
+ *  PIC0:  Programmable Interrupt Controller (8259_a)
+ *  PIT1:  System Timer 1
+ *  PIT2:  System Timer 2 failsafe
+ *  RTC:   Real-time clock
+ *  CMOS:  Extended CMOS
+ *  DMA1:  DMA 1 page registers
+ *  DMA1L: DMA 1 Ch 0 low page
+ *  DMA2:  DMA 2 page registers
+ *  DMA2L: DMA 2 low page refresh
+ *  ARBC:  Arbitration control
+ *  SETUP: Reserved system board setup
+ *  POS:   POS channel select
+ *  PIC1:  Cascaded PIC
+ *  IDMA:  ISA DMA
+ *  ELCR:  PIC edge/level registers
+ *  PCI:   PCI configuration space
+ */
+static const struct acpi_port_info acpi_protected_ports[] = {
+	{"DMA", 0x0000, 0x000F, ACPI_OSI_WIN_XP},
+	{"PIC0", 0x0020, 0x0021, ACPI_ALWAYS_ILLEGAL},
+	{"PIT1", 0x0040, 0x0043, ACPI_OSI_WIN_XP},
+	{"PIT2", 0x0048, 0x004B, ACPI_OSI_WIN_XP},
+	{"RTC", 0x0070, 0x0071, ACPI_OSI_WIN_XP},
+	{"CMOS", 0x0074, 0x0076, ACPI_OSI_WIN_XP},
+	{"DMA1", 0x0081, 0x0083, ACPI_OSI_WIN_XP},
+	{"DMA1L", 0x0087, 0x0087, ACPI_OSI_WIN_XP},
+	{"DMA2", 0x0089, 0x008B, ACPI_OSI_WIN_XP},
+	{"DMA2L", 0x008F, 0x008F, ACPI_OSI_WIN_XP},
+	{"ARBC", 0x0090, 0x0091, ACPI_OSI_WIN_XP},
+	{"SETUP", 0x0093, 0x0094, ACPI_OSI_WIN_XP},
+	{"POS", 0x0096, 0x0097, ACPI_OSI_WIN_XP},
+	{"PIC1", 0x00A0, 0x00A1, ACPI_ALWAYS_ILLEGAL},
+	{"IDMA", 0x00C0, 0x00DF, ACPI_OSI_WIN_XP},
+	{"ELCR", 0x04D0, 0x04D1, ACPI_ALWAYS_ILLEGAL},
+	{"PCI", 0x0CF8, 0x0CFF, ACPI_OSI_WIN_XP}
+};
+
+#define ACPI_PORT_INFO_ENTRIES  ACPI_ARRAY_LENGTH (acpi_protected_ports)
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_hw_validate_io_request
+ *
+ * PARAMETERS:  Address             Address of I/O port/register
+ *              bit_width           Number of bits (8,16,32)
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Validates an I/O request (address/length). Certain ports are
+ *              always illegal and some ports are only illegal depending on
+ *              the requests the BIOS AML code makes to the predefined
+ *              _OSI method.
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_hw_validate_io_request(acpi_io_address address, u32 bit_width)
+{
+	u32 i;
+	u32 byte_width;
+	acpi_io_address last_address;
+	const struct acpi_port_info *port_info;
+
+	ACPI_FUNCTION_TRACE(hw_validate_io_request);
+
+	/* Supported widths are 8/16/32 */
+
+	if ((bit_width != 8) && (bit_width != 16) && (bit_width != 32)) {
+		ACPI_ERROR((AE_INFO,
+			    "Bad BitWidth parameter: %8.8X", bit_width));
+		return (AE_BAD_PARAMETER);
+	}
+
+	port_info = acpi_protected_ports;
+	byte_width = ACPI_DIV_8(bit_width);
+	last_address = address + byte_width - 1;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_IO, "Address %p LastAddress %p Length %X",
+			  ACPI_CAST_PTR(void, address), ACPI_CAST_PTR(void,
+								      last_address),
+			  byte_width));
+
+	/* Maximum 16-bit address in I/O space */
+
+	if (last_address > ACPI_UINT16_MAX) {
+		ACPI_ERROR((AE_INFO,
+			    "Illegal I/O port address/length above 64K: %p/0x%X",
+			    ACPI_CAST_PTR(void, address), byte_width));
+		return_ACPI_STATUS(AE_LIMIT);
+	}
+
+	/* Exit if requested address is not within the protected port table */
+
+	if (address > acpi_protected_ports[ACPI_PORT_INFO_ENTRIES - 1].end) {
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	/* Check request against the list of protected I/O ports */
+
+	for (i = 0; i < ACPI_PORT_INFO_ENTRIES; i++, port_info++) {
+		/*
+		 * Check if the requested address range will write to a reserved
+		 * port. Four cases to consider:
+		 *
+		 * 1) Address range is contained completely in the port address range
+		 * 2) Address range overlaps port range at the port range start
+		 * 3) Address range overlaps port range at the port range end
+		 * 4) Address range completely encompasses the port range
+		 */
+		if ((address <= port_info->end)
+		    && (last_address >= port_info->start)) {
+
+			/* Port illegality may depend on the _OSI calls made by the BIOS */
+
+			if (acpi_gbl_osi_data >= port_info->osi_dependency) {
+				ACPI_DEBUG_PRINT((ACPI_DB_IO,
+						  "Denied AML access to port 0x%p/%X (%s 0x%.4X-0x%.4X)",
+						  ACPI_CAST_PTR(void, address),
+						  byte_width, port_info->name,
+						  port_info->start,
+						  port_info->end));
+
+				return_ACPI_STATUS(AE_AML_ILLEGAL_ADDRESS);
+			}
+		}
+
+		/* Finished if address range ends before the end of this port */
+
+		if (last_address <= port_info->end) {
+			break;
+		}
+	}
+
+	return_ACPI_STATUS(AE_OK);
+}
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_hw_read_port
+ *
+ * PARAMETERS:  Address             Address of I/O port/register to read
+ *              Value               Where value is placed
+ *              Width               Number of bits
+ *
+ * RETURN:      Status and value read from port
+ *
+ * DESCRIPTION: Read data from an I/O port or register. This is a front-end
+ *              to acpi_os_read_port that performs validation on both the port
+ *              address and the length.
+ *
+ *****************************************************************************/
+
+acpi_status acpi_hw_read_port(acpi_io_address address, u32 *value, u32 width)
+{
+	acpi_status status;
+	u32 one_byte;
+	u32 i;
+
+	/* Truncate address to 16 bits if requested */
+
+	if (acpi_gbl_truncate_io_addresses) {
+		address &= ACPI_UINT16_MAX;
+	}
+
+	/* Validate the entire request and perform the I/O */
+
+	status = acpi_hw_validate_io_request(address, width);
+	if (ACPI_SUCCESS(status)) {
+		status = acpi_os_read_port(address, value, width);
+		return (status);
+	}
+
+	if (status != AE_AML_ILLEGAL_ADDRESS) {
+		return (status);
+	}
+
+	/*
+	 * There has been a protection violation within the request. Fall
+	 * back to byte granularity port I/O and ignore the failing bytes.
+	 * This provides Windows compatibility.
+	 */
+	for (i = 0, *value = 0; i < width; i += 8) {
+
+		/* Validate and read one byte */
+
+		if (acpi_hw_validate_io_request(address, 8) == AE_OK) {
+			status = acpi_os_read_port(address, &one_byte, 8);
+			if (ACPI_FAILURE(status)) {
+				return (status);
+			}
+
+			*value |= (one_byte << i);
+		}
+
+		address++;
+	}
+
+	return (AE_OK);
+}
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_hw_write_port
+ *
+ * PARAMETERS:  Address             Address of I/O port/register to write
+ *              Value               Value to write
+ *              Width               Number of bits
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Write data to an I/O port or register. This is a front-end
+ *              to acpi_os_write_port that performs validation on both the port
+ *              address and the length.
+ *
+ *****************************************************************************/
+
+acpi_status acpi_hw_write_port(acpi_io_address address, u32 value, u32 width)
+{
+	acpi_status status;
+	u32 i;
+
+	/* Truncate address to 16 bits if requested */
+
+	if (acpi_gbl_truncate_io_addresses) {
+		address &= ACPI_UINT16_MAX;
+	}
+
+	/* Validate the entire request and perform the I/O */
+
+	status = acpi_hw_validate_io_request(address, width);
+	if (ACPI_SUCCESS(status)) {
+		status = acpi_os_write_port(address, value, width);
+		return (status);
+	}
+
+	if (status != AE_AML_ILLEGAL_ADDRESS) {
+		return (status);
+	}
+
+	/*
+	 * There has been a protection violation within the request. Fall
+	 * back to byte granularity port I/O and ignore the failing bytes.
+	 * This provides Windows compatibility.
+	 */
+	for (i = 0; i < width; i += 8) {
+
+		/* Validate and write one byte */
+
+		if (acpi_hw_validate_io_request(address, 8) == AE_OK) {
+			status =
+			    acpi_os_write_port(address, (value >> i) & 0xFF, 8);
+			if (ACPI_FAILURE(status)) {
+				return (status);
+			}
+		}
+
+		address++;
+	}
+
+	return (AE_OK);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/hwxface.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/hwxface.c
new file mode 100644
index 00000000..dea1931a
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/hwxface.c
@@ -0,0 +1,573 @@
+
+/******************************************************************************
+ *
+ * Module Name: hwxface - Public ACPICA hardware interfaces
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acnamesp.h"
+
+#define _COMPONENT          ACPI_HARDWARE
+ACPI_MODULE_NAME("hwxface")
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_reset
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Set reset register in memory or IO space. Note: Does not
+ *              support reset register in PCI config space, this must be
+ *              handled separately.
+ *
+ ******************************************************************************/
+acpi_status acpi_reset(void)
+{
+	struct acpi_generic_address *reset_reg;
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(acpi_reset);
+
+	reset_reg = &acpi_gbl_FADT.reset_register;
+
+	/* Check if the reset register is supported */
+
+	if (!(acpi_gbl_FADT.flags & ACPI_FADT_RESET_REGISTER) ||
+	    !reset_reg->address) {
+		return_ACPI_STATUS(AE_NOT_EXIST);
+	}
+
+	if (reset_reg->space_id == ACPI_ADR_SPACE_SYSTEM_IO) {
+		/*
+		 * For I/O space, write directly to the OSL. This bypasses the port
+		 * validation mechanism, which may block a valid write to the reset
+		 * register.
+		 */
+		status =
+		    acpi_os_write_port((acpi_io_address) reset_reg->address,
+				       acpi_gbl_FADT.reset_value,
+				       reset_reg->bit_width);
+	} else {
+		/* Write the reset value to the reset register */
+
+		status = acpi_hw_write(acpi_gbl_FADT.reset_value, reset_reg);
+	}
+
+	return_ACPI_STATUS(status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_reset)
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_read
+ *
+ * PARAMETERS:  Value               - Where the value is returned
+ *              Reg                 - GAS register structure
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Read from either memory or IO space.
+ *
+ * LIMITATIONS: <These limitations also apply to acpi_write>
+ *      bit_width must be exactly 8, 16, 32, or 64.
+ *      space_iD must be system_memory or system_iO.
+ *      bit_offset and access_width are currently ignored, as there has
+ *          not been a need to implement these.
+ *
+ ******************************************************************************/
+acpi_status acpi_read(u64 *return_value, struct acpi_generic_address *reg)
+{
+	u32 value;
+	u32 width;
+	u64 address;
+	acpi_status status;
+
+	ACPI_FUNCTION_NAME(acpi_read);
+
+	if (!return_value) {
+		return (AE_BAD_PARAMETER);
+	}
+
+	/* Validate contents of the GAS register. Allow 64-bit transfers */
+
+	status = acpi_hw_validate_register(reg, 64, &address);
+	if (ACPI_FAILURE(status)) {
+		return (status);
+	}
+
+	width = reg->bit_width;
+	if (width == 64) {
+		width = 32;	/* Break into two 32-bit transfers */
+	}
+
+	/* Initialize entire 64-bit return value to zero */
+
+	*return_value = 0;
+	value = 0;
+
+	/*
+	 * Two address spaces supported: Memory or IO. PCI_Config is
+	 * not supported here because the GAS structure is insufficient
+	 */
+	if (reg->space_id == ACPI_ADR_SPACE_SYSTEM_MEMORY) {
+		status = acpi_os_read_memory((acpi_physical_address)
+					     address, &value, width);
+		if (ACPI_FAILURE(status)) {
+			return (status);
+		}
+		*return_value = value;
+
+		if (reg->bit_width == 64) {
+
+			/* Read the top 32 bits */
+
+			status = acpi_os_read_memory((acpi_physical_address)
+						     (address + 4), &value, 32);
+			if (ACPI_FAILURE(status)) {
+				return (status);
+			}
+			*return_value |= ((u64)value << 32);
+		}
+	} else {		/* ACPI_ADR_SPACE_SYSTEM_IO, validated earlier */
+
+		status = acpi_hw_read_port((acpi_io_address)
+					   address, &value, width);
+		if (ACPI_FAILURE(status)) {
+			return (status);
+		}
+		*return_value = value;
+
+		if (reg->bit_width == 64) {
+
+			/* Read the top 32 bits */
+
+			status = acpi_hw_read_port((acpi_io_address)
+						   (address + 4), &value, 32);
+			if (ACPI_FAILURE(status)) {
+				return (status);
+			}
+			*return_value |= ((u64)value << 32);
+		}
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_IO,
+			  "Read:  %8.8X%8.8X width %2d from %8.8X%8.8X (%s)\n",
+			  ACPI_FORMAT_UINT64(*return_value), reg->bit_width,
+			  ACPI_FORMAT_UINT64(address),
+			  acpi_ut_get_region_name(reg->space_id)));
+
+	return (status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_read)
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_write
+ *
+ * PARAMETERS:  Value               - Value to be written
+ *              Reg                 - GAS register structure
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Write to either memory or IO space.
+ *
+ ******************************************************************************/
+acpi_status acpi_write(u64 value, struct acpi_generic_address * reg)
+{
+	u32 width;
+	u64 address;
+	acpi_status status;
+
+	ACPI_FUNCTION_NAME(acpi_write);
+
+	/* Validate contents of the GAS register. Allow 64-bit transfers */
+
+	status = acpi_hw_validate_register(reg, 64, &address);
+	if (ACPI_FAILURE(status)) {
+		return (status);
+	}
+
+	width = reg->bit_width;
+	if (width == 64) {
+		width = 32;	/* Break into two 32-bit transfers */
+	}
+
+	/*
+	 * Two address spaces supported: Memory or IO. PCI_Config is
+	 * not supported here because the GAS structure is insufficient
+	 */
+	if (reg->space_id == ACPI_ADR_SPACE_SYSTEM_MEMORY) {
+		status = acpi_os_write_memory((acpi_physical_address)
+					      address, ACPI_LODWORD(value),
+					      width);
+		if (ACPI_FAILURE(status)) {
+			return (status);
+		}
+
+		if (reg->bit_width == 64) {
+			status = acpi_os_write_memory((acpi_physical_address)
+						      (address + 4),
+						      ACPI_HIDWORD(value), 32);
+			if (ACPI_FAILURE(status)) {
+				return (status);
+			}
+		}
+	} else {		/* ACPI_ADR_SPACE_SYSTEM_IO, validated earlier */
+
+		status = acpi_hw_write_port((acpi_io_address)
+					    address, ACPI_LODWORD(value),
+					    width);
+		if (ACPI_FAILURE(status)) {
+			return (status);
+		}
+
+		if (reg->bit_width == 64) {
+			status = acpi_hw_write_port((acpi_io_address)
+						    (address + 4),
+						    ACPI_HIDWORD(value), 32);
+			if (ACPI_FAILURE(status)) {
+				return (status);
+			}
+		}
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_IO,
+			  "Wrote: %8.8X%8.8X width %2d   to %8.8X%8.8X (%s)\n",
+			  ACPI_FORMAT_UINT64(value), reg->bit_width,
+			  ACPI_FORMAT_UINT64(address),
+			  acpi_ut_get_region_name(reg->space_id)));
+
+	return (status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_write)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_read_bit_register
+ *
+ * PARAMETERS:  register_id     - ID of ACPI Bit Register to access
+ *              return_value    - Value that was read from the register,
+ *                                normalized to bit position zero.
+ *
+ * RETURN:      Status and the value read from the specified Register. Value
+ *              returned is normalized to bit0 (is shifted all the way right)
+ *
+ * DESCRIPTION: ACPI bit_register read function. Does not acquire the HW lock.
+ *
+ * SUPPORTS:    Bit fields in PM1 Status, PM1 Enable, PM1 Control, and
+ *              PM2 Control.
+ *
+ * Note: The hardware lock is not required when reading the ACPI bit registers
+ *       since almost all of them are single bit and it does not matter that
+ *       the parent hardware register can be split across two physical
+ *       registers. The only multi-bit field is SLP_TYP in the PM1 control
+ *       register, but this field does not cross an 8-bit boundary (nor does
+ *       it make much sense to actually read this field.)
+ *
+ ******************************************************************************/
+acpi_status acpi_read_bit_register(u32 register_id, u32 *return_value)
+{
+	struct acpi_bit_register_info *bit_reg_info;
+	u32 register_value;
+	u32 value;
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE_U32(acpi_read_bit_register, register_id);
+
+	/* Get the info structure corresponding to the requested ACPI Register */
+
+	bit_reg_info = acpi_hw_get_bit_register_info(register_id);
+	if (!bit_reg_info) {
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	/* Read the entire parent register */
+
+	status = acpi_hw_register_read(bit_reg_info->parent_register,
+				       &register_value);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/* Normalize the value that was read, mask off other bits */
+
+	value = ((register_value & bit_reg_info->access_bit_mask)
+		 >> bit_reg_info->bit_position);
+
+	ACPI_DEBUG_PRINT((ACPI_DB_IO,
+			  "BitReg %X, ParentReg %X, Actual %8.8X, ReturnValue %8.8X\n",
+			  register_id, bit_reg_info->parent_register,
+			  register_value, value));
+
+	*return_value = value;
+	return_ACPI_STATUS(AE_OK);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_read_bit_register)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_write_bit_register
+ *
+ * PARAMETERS:  register_id     - ID of ACPI Bit Register to access
+ *              Value           - Value to write to the register, in bit
+ *                                position zero. The bit is automaticallly
+ *                                shifted to the correct position.
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: ACPI Bit Register write function. Acquires the hardware lock
+ *              since most operations require a read/modify/write sequence.
+ *
+ * SUPPORTS:    Bit fields in PM1 Status, PM1 Enable, PM1 Control, and
+ *              PM2 Control.
+ *
+ * Note that at this level, the fact that there may be actually two
+ * hardware registers (A and B - and B may not exist) is abstracted.
+ *
+ ******************************************************************************/
+acpi_status acpi_write_bit_register(u32 register_id, u32 value)
+{
+	struct acpi_bit_register_info *bit_reg_info;
+	acpi_cpu_flags lock_flags;
+	u32 register_value;
+	acpi_status status = AE_OK;
+
+	ACPI_FUNCTION_TRACE_U32(acpi_write_bit_register, register_id);
+
+	/* Get the info structure corresponding to the requested ACPI Register */
+
+	bit_reg_info = acpi_hw_get_bit_register_info(register_id);
+	if (!bit_reg_info) {
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	lock_flags = acpi_os_acquire_lock(acpi_gbl_hardware_lock);
+
+	/*
+	 * At this point, we know that the parent register is one of the
+	 * following: PM1 Status, PM1 Enable, PM1 Control, or PM2 Control
+	 */
+	if (bit_reg_info->parent_register != ACPI_REGISTER_PM1_STATUS) {
+		/*
+		 * 1) Case for PM1 Enable, PM1 Control, and PM2 Control
+		 *
+		 * Perform a register read to preserve the bits that we are not
+		 * interested in
+		 */
+		status = acpi_hw_register_read(bit_reg_info->parent_register,
+					       &register_value);
+		if (ACPI_FAILURE(status)) {
+			goto unlock_and_exit;
+		}
+
+		/*
+		 * Insert the input bit into the value that was just read
+		 * and write the register
+		 */
+		ACPI_REGISTER_INSERT_VALUE(register_value,
+					   bit_reg_info->bit_position,
+					   bit_reg_info->access_bit_mask,
+					   value);
+
+		status = acpi_hw_register_write(bit_reg_info->parent_register,
+						register_value);
+	} else {
+		/*
+		 * 2) Case for PM1 Status
+		 *
+		 * The Status register is different from the rest. Clear an event
+		 * by writing 1, writing 0 has no effect. So, the only relevant
+		 * information is the single bit we're interested in, all others
+		 * should be written as 0 so they will be left unchanged.
+		 */
+		register_value = ACPI_REGISTER_PREPARE_BITS(value,
+							    bit_reg_info->
+							    bit_position,
+							    bit_reg_info->
+							    access_bit_mask);
+
+		/* No need to write the register if value is all zeros */
+
+		if (register_value) {
+			status =
+			    acpi_hw_register_write(ACPI_REGISTER_PM1_STATUS,
+						   register_value);
+		}
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_IO,
+			  "BitReg %X, ParentReg %X, Value %8.8X, Actual %8.8X\n",
+			  register_id, bit_reg_info->parent_register, value,
+			  register_value));
+
+      unlock_and_exit:
+
+	acpi_os_release_lock(acpi_gbl_hardware_lock, lock_flags);
+	return_ACPI_STATUS(status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_write_bit_register)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_get_sleep_type_data
+ *
+ * PARAMETERS:  sleep_state         - Numeric sleep state
+ *              *sleep_type_a        - Where SLP_TYPa is returned
+ *              *sleep_type_b        - Where SLP_TYPb is returned
+ *
+ * RETURN:      Status - ACPI status
+ *
+ * DESCRIPTION: Obtain the SLP_TYPa and SLP_TYPb values for the requested sleep
+ *              state.
+ *
+ ******************************************************************************/
+acpi_status
+acpi_get_sleep_type_data(u8 sleep_state, u8 *sleep_type_a, u8 *sleep_type_b)
+{
+	acpi_status status = AE_OK;
+	struct acpi_evaluate_info *info;
+
+	ACPI_FUNCTION_TRACE(acpi_get_sleep_type_data);
+
+	/* Validate parameters */
+
+	if ((sleep_state > ACPI_S_STATES_MAX) || !sleep_type_a || !sleep_type_b) {
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	/* Allocate the evaluation information block */
+
+	info = ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_evaluate_info));
+	if (!info) {
+		return_ACPI_STATUS(AE_NO_MEMORY);
+	}
+
+	info->pathname =
+	    ACPI_CAST_PTR(char, acpi_gbl_sleep_state_names[sleep_state]);
+
+	/* Evaluate the namespace object containing the values for this state */
+
+	status = acpi_ns_evaluate(info);
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
+				  "%s while evaluating SleepState [%s]\n",
+				  acpi_format_exception(status),
+				  info->pathname));
+
+		goto cleanup;
+	}
+
+	/* Must have a return object */
+
+	if (!info->return_object) {
+		ACPI_ERROR((AE_INFO, "No Sleep State object returned from [%s]",
+			    info->pathname));
+		status = AE_NOT_EXIST;
+	}
+
+	/* It must be of type Package */
+
+	else if (info->return_object->common.type != ACPI_TYPE_PACKAGE) {
+		ACPI_ERROR((AE_INFO,
+			    "Sleep State return object is not a Package"));
+		status = AE_AML_OPERAND_TYPE;
+	}
+
+	/*
+	 * The package must have at least two elements. NOTE (March 2005): This
+	 * goes against the current ACPI spec which defines this object as a
+	 * package with one encoded DWORD element. However, existing practice
+	 * by BIOS vendors seems to be to have 2 or more elements, at least
+	 * one per sleep type (A/B).
+	 */
+	else if (info->return_object->package.count < 2) {
+		ACPI_ERROR((AE_INFO,
+			    "Sleep State return package does not have at least two elements"));
+		status = AE_AML_NO_OPERAND;
+	}
+
+	/* The first two elements must both be of type Integer */
+
+	else if (((info->return_object->package.elements[0])->common.type
+		  != ACPI_TYPE_INTEGER) ||
+		 ((info->return_object->package.elements[1])->common.type
+		  != ACPI_TYPE_INTEGER)) {
+		ACPI_ERROR((AE_INFO,
+			    "Sleep State return package elements are not both Integers "
+			    "(%s, %s)",
+			    acpi_ut_get_object_type_name(info->return_object->
+							 package.elements[0]),
+			    acpi_ut_get_object_type_name(info->return_object->
+							 package.elements[1])));
+		status = AE_AML_OPERAND_TYPE;
+	} else {
+		/* Valid _Sx_ package size, type, and value */
+
+		*sleep_type_a = (u8)
+		    (info->return_object->package.elements[0])->integer.value;
+		*sleep_type_b = (u8)
+		    (info->return_object->package.elements[1])->integer.value;
+	}
+
+	if (ACPI_FAILURE(status)) {
+		ACPI_EXCEPTION((AE_INFO, status,
+				"While evaluating SleepState [%s], bad Sleep object %p type %s",
+				info->pathname, info->return_object,
+				acpi_ut_get_object_type_name(info->
+							     return_object)));
+	}
+
+	acpi_ut_remove_reference(info->return_object);
+
+      cleanup:
+	ACPI_FREE(info);
+	return_ACPI_STATUS(status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_get_sleep_type_data)
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nsaccess.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nsaccess.c
new file mode 100644
index 00000000..eaecbb4a
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nsaccess.c
@@ -0,0 +1,670 @@
+/*******************************************************************************
+ *
+ * Module Name: nsaccess - Top-level functions for accessing ACPI namespace
+ *
+ ******************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "amlcode.h"
+#include "acnamesp.h"
+#include "acdispat.h"
+
+#define _COMPONENT          ACPI_NAMESPACE
+ACPI_MODULE_NAME("nsaccess")
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_root_initialize
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Allocate and initialize the default root named objects
+ *
+ * MUTEX:       Locks namespace for entire execution
+ *
+ ******************************************************************************/
+acpi_status acpi_ns_root_initialize(void)
+{
+	acpi_status status;
+	const struct acpi_predefined_names *init_val = NULL;
+	struct acpi_namespace_node *new_node;
+	union acpi_operand_object *obj_desc;
+	acpi_string val = NULL;
+
+	ACPI_FUNCTION_TRACE(ns_root_initialize);
+
+	status = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/*
+	 * The global root ptr is initially NULL, so a non-NULL value indicates
+	 * that acpi_ns_root_initialize() has already been called; just return.
+	 */
+	if (acpi_gbl_root_node) {
+		status = AE_OK;
+		goto unlock_and_exit;
+	}
+
+	/*
+	 * Tell the rest of the subsystem that the root is initialized
+	 * (This is OK because the namespace is locked)
+	 */
+	acpi_gbl_root_node = &acpi_gbl_root_node_struct;
+
+	/* Enter the pre-defined names in the name table */
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+			  "Entering predefined entries into namespace\n"));
+
+	for (init_val = acpi_gbl_pre_defined_names; init_val->name; init_val++) {
+
+		/* _OSI is optional for now, will be permanent later */
+
+		if (!ACPI_STRCMP(init_val->name, "_OSI")
+		    && !acpi_gbl_create_osi_method) {
+			continue;
+		}
+
+		status = acpi_ns_lookup(NULL, init_val->name, init_val->type,
+					ACPI_IMODE_LOAD_PASS2,
+					ACPI_NS_NO_UPSEARCH, NULL, &new_node);
+
+		if (ACPI_FAILURE(status) || (!new_node)) {	/* Must be on same line for code converter */
+			ACPI_EXCEPTION((AE_INFO, status,
+					"Could not create predefined name %s",
+					init_val->name));
+		}
+
+		/*
+		 * Name entered successfully. If entry in pre_defined_names[] specifies
+		 * an initial value, create the initial value.
+		 */
+		if (init_val->val) {
+			status = acpi_os_predefined_override(init_val, &val);
+			if (ACPI_FAILURE(status)) {
+				ACPI_ERROR((AE_INFO,
+					    "Could not override predefined %s",
+					    init_val->name));
+			}
+
+			if (!val) {
+				val = init_val->val;
+			}
+
+			/*
+			 * Entry requests an initial value, allocate a
+			 * descriptor for it.
+			 */
+			obj_desc =
+			    acpi_ut_create_internal_object(init_val->type);
+			if (!obj_desc) {
+				status = AE_NO_MEMORY;
+				goto unlock_and_exit;
+			}
+
+			/*
+			 * Convert value string from table entry to
+			 * internal representation. Only types actually
+			 * used for initial values are implemented here.
+			 */
+			switch (init_val->type) {
+			case ACPI_TYPE_METHOD:
+				obj_desc->method.param_count =
+				    (u8)ACPI_TO_INTEGER(val);
+				obj_desc->common.flags |= AOPOBJ_DATA_VALID;
+
+#if defined (ACPI_ASL_COMPILER)
+
+				/* Save the parameter count for the i_aSL compiler */
+
+				new_node->value = obj_desc->method.param_count;
+#else
+				/* Mark this as a very SPECIAL method */
+
+				obj_desc->method.info_flags =
+				    ACPI_METHOD_INTERNAL_ONLY;
+				obj_desc->method.dispatch.implementation =
+				    acpi_ut_osi_implementation;
+#endif
+				break;
+
+			case ACPI_TYPE_INTEGER:
+
+				obj_desc->integer.value = ACPI_TO_INTEGER(val);
+				break;
+
+			case ACPI_TYPE_STRING:
+
+				/* Build an object around the static string */
+
+				obj_desc->string.length = (u32)ACPI_STRLEN(val);
+				obj_desc->string.pointer = val;
+				obj_desc->common.flags |= AOPOBJ_STATIC_POINTER;
+				break;
+
+			case ACPI_TYPE_MUTEX:
+
+				obj_desc->mutex.node = new_node;
+				obj_desc->mutex.sync_level =
+				    (u8)(ACPI_TO_INTEGER(val) - 1);
+
+				/* Create a mutex */
+
+				status =
+				    acpi_os_create_mutex(&obj_desc->mutex.
+							 os_mutex);
+				if (ACPI_FAILURE(status)) {
+					acpi_ut_remove_reference(obj_desc);
+					goto unlock_and_exit;
+				}
+
+				/* Special case for ACPI Global Lock */
+
+				if (ACPI_STRCMP(init_val->name, "_GL_") == 0) {
+					acpi_gbl_global_lock_mutex = obj_desc;
+
+					/* Create additional counting semaphore for global lock */
+
+					status =
+					    acpi_os_create_semaphore(1, 0,
+								     &acpi_gbl_global_lock_semaphore);
+					if (ACPI_FAILURE(status)) {
+						acpi_ut_remove_reference
+						    (obj_desc);
+						goto unlock_and_exit;
+					}
+				}
+				break;
+
+			default:
+
+				ACPI_ERROR((AE_INFO,
+					    "Unsupported initial type value 0x%X",
+					    init_val->type));
+				acpi_ut_remove_reference(obj_desc);
+				obj_desc = NULL;
+				continue;
+			}
+
+			/* Store pointer to value descriptor in the Node */
+
+			status = acpi_ns_attach_object(new_node, obj_desc,
+						       obj_desc->common.type);
+
+			/* Remove local reference to the object */
+
+			acpi_ut_remove_reference(obj_desc);
+		}
+	}
+
+      unlock_and_exit:
+	(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);
+
+	/* Save a handle to "_GPE", it is always present */
+
+	if (ACPI_SUCCESS(status)) {
+		status = acpi_ns_get_node(NULL, "\\_GPE", ACPI_NS_NO_UPSEARCH,
+					  &acpi_gbl_fadt_gpe_device);
+	}
+
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_lookup
+ *
+ * PARAMETERS:  scope_info      - Current scope info block
+ *              Pathname        - Search pathname, in internal format
+ *                                (as represented in the AML stream)
+ *              Type            - Type associated with name
+ *              interpreter_mode - IMODE_LOAD_PASS2 => add name if not found
+ *              Flags           - Flags describing the search restrictions
+ *              walk_state      - Current state of the walk
+ *              return_node     - Where the Node is placed (if found
+ *                                or created successfully)
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Find or enter the passed name in the name space.
+ *              Log an error if name not found in Exec mode.
+ *
+ * MUTEX:       Assumes namespace is locked.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ns_lookup(union acpi_generic_state *scope_info,
+	       char *pathname,
+	       acpi_object_type type,
+	       acpi_interpreter_mode interpreter_mode,
+	       u32 flags,
+	       struct acpi_walk_state *walk_state,
+	       struct acpi_namespace_node **return_node)
+{
+	acpi_status status;
+	char *path = pathname;
+	struct acpi_namespace_node *prefix_node;
+	struct acpi_namespace_node *current_node = NULL;
+	struct acpi_namespace_node *this_node = NULL;
+	u32 num_segments;
+	u32 num_carats;
+	acpi_name simple_name;
+	acpi_object_type type_to_check_for;
+	acpi_object_type this_search_type;
+	u32 search_parent_flag = ACPI_NS_SEARCH_PARENT;
+	u32 local_flags;
+
+	ACPI_FUNCTION_TRACE(ns_lookup);
+
+	if (!return_node) {
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	local_flags = flags & ~(ACPI_NS_ERROR_IF_FOUND | ACPI_NS_SEARCH_PARENT);
+	*return_node = ACPI_ENTRY_NOT_FOUND;
+	acpi_gbl_ns_lookup_count++;
+
+	if (!acpi_gbl_root_node) {
+		return_ACPI_STATUS(AE_NO_NAMESPACE);
+	}
+
+	/* Get the prefix scope. A null scope means use the root scope */
+
+	if ((!scope_info) || (!scope_info->scope.node)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_NAMES,
+				  "Null scope prefix, using root node (%p)\n",
+				  acpi_gbl_root_node));
+
+		prefix_node = acpi_gbl_root_node;
+	} else {
+		prefix_node = scope_info->scope.node;
+		if (ACPI_GET_DESCRIPTOR_TYPE(prefix_node) !=
+		    ACPI_DESC_TYPE_NAMED) {
+			ACPI_ERROR((AE_INFO, "%p is not a namespace node [%s]",
+				    prefix_node,
+				    acpi_ut_get_descriptor_name(prefix_node)));
+			return_ACPI_STATUS(AE_AML_INTERNAL);
+		}
+
+		if (!(flags & ACPI_NS_PREFIX_IS_SCOPE)) {
+			/*
+			 * This node might not be a actual "scope" node (such as a
+			 * Device/Method, etc.)  It could be a Package or other object
+			 * node. Backup up the tree to find the containing scope node.
+			 */
+			while (!acpi_ns_opens_scope(prefix_node->type) &&
+			       prefix_node->type != ACPI_TYPE_ANY) {
+				prefix_node = prefix_node->parent;
+			}
+		}
+	}
+
+	/* Save type. TBD: may be no longer necessary */
+
+	type_to_check_for = type;
+
+	/*
+	 * Begin examination of the actual pathname
+	 */
+	if (!pathname) {
+
+		/* A Null name_path is allowed and refers to the root */
+
+		num_segments = 0;
+		this_node = acpi_gbl_root_node;
+		path = "";
+
+		ACPI_DEBUG_PRINT((ACPI_DB_NAMES,
+				  "Null Pathname (Zero segments), Flags=%X\n",
+				  flags));
+	} else {
+		/*
+		 * Name pointer is valid (and must be in internal name format)
+		 *
+		 * Check for scope prefixes:
+		 *
+		 * As represented in the AML stream, a namepath consists of an
+		 * optional scope prefix followed by a name segment part.
+		 *
+		 * If present, the scope prefix is either a Root Prefix (in
+		 * which case the name is fully qualified), or one or more
+		 * Parent Prefixes (in which case the name's scope is relative
+		 * to the current scope).
+		 */
+		if (*path == (u8)AML_ROOT_PREFIX) {
+
+			/* Pathname is fully qualified, start from the root */
+
+			this_node = acpi_gbl_root_node;
+			search_parent_flag = ACPI_NS_NO_UPSEARCH;
+
+			/* Point to name segment part */
+
+			path++;
+
+			ACPI_DEBUG_PRINT((ACPI_DB_NAMES,
+					  "Path is absolute from root [%p]\n",
+					  this_node));
+		} else {
+			/* Pathname is relative to current scope, start there */
+
+			ACPI_DEBUG_PRINT((ACPI_DB_NAMES,
+					  "Searching relative to prefix scope [%4.4s] (%p)\n",
+					  acpi_ut_get_node_name(prefix_node),
+					  prefix_node));
+
+			/*
+			 * Handle multiple Parent Prefixes (carat) by just getting
+			 * the parent node for each prefix instance.
+			 */
+			this_node = prefix_node;
+			num_carats = 0;
+			while (*path == (u8)AML_PARENT_PREFIX) {
+
+				/* Name is fully qualified, no search rules apply */
+
+				search_parent_flag = ACPI_NS_NO_UPSEARCH;
+
+				/*
+				 * Point past this prefix to the name segment
+				 * part or the next Parent Prefix
+				 */
+				path++;
+
+				/* Backup to the parent node */
+
+				num_carats++;
+				this_node = this_node->parent;
+				if (!this_node) {
+
+					/* Current scope has no parent scope */
+
+					ACPI_ERROR((AE_INFO,
+						    "ACPI path has too many parent prefixes (^) "
+						    "- reached beyond root node"));
+					return_ACPI_STATUS(AE_NOT_FOUND);
+				}
+			}
+
+			if (search_parent_flag == ACPI_NS_NO_UPSEARCH) {
+				ACPI_DEBUG_PRINT((ACPI_DB_NAMES,
+						  "Search scope is [%4.4s], path has %u carat(s)\n",
+						  acpi_ut_get_node_name
+						  (this_node), num_carats));
+			}
+		}
+
+		/*
+		 * Determine the number of ACPI name segments in this pathname.
+		 *
+		 * The segment part consists of either:
+		 *  - A Null name segment (0)
+		 *  - A dual_name_prefix followed by two 4-byte name segments
+		 *  - A multi_name_prefix followed by a byte indicating the
+		 *      number of segments and the segments themselves.
+		 *  - A single 4-byte name segment
+		 *
+		 * Examine the name prefix opcode, if any, to determine the number of
+		 * segments.
+		 */
+		switch (*path) {
+		case 0:
+			/*
+			 * Null name after a root or parent prefixes. We already
+			 * have the correct target node and there are no name segments.
+			 */
+			num_segments = 0;
+			type = this_node->type;
+
+			ACPI_DEBUG_PRINT((ACPI_DB_NAMES,
+					  "Prefix-only Pathname (Zero name segments), Flags=%X\n",
+					  flags));
+			break;
+
+		case AML_DUAL_NAME_PREFIX:
+
+			/* More than one name_seg, search rules do not apply */
+
+			search_parent_flag = ACPI_NS_NO_UPSEARCH;
+
+			/* Two segments, point to first name segment */
+
+			num_segments = 2;
+			path++;
+
+			ACPI_DEBUG_PRINT((ACPI_DB_NAMES,
+					  "Dual Pathname (2 segments, Flags=%X)\n",
+					  flags));
+			break;
+
+		case AML_MULTI_NAME_PREFIX_OP:
+
+			/* More than one name_seg, search rules do not apply */
+
+			search_parent_flag = ACPI_NS_NO_UPSEARCH;
+
+			/* Extract segment count, point to first name segment */
+
+			path++;
+			num_segments = (u32)(u8)*path;
+			path++;
+
+			ACPI_DEBUG_PRINT((ACPI_DB_NAMES,
+					  "Multi Pathname (%u Segments, Flags=%X)\n",
+					  num_segments, flags));
+			break;
+
+		default:
+			/*
+			 * Not a Null name, no Dual or Multi prefix, hence there is
+			 * only one name segment and Pathname is already pointing to it.
+			 */
+			num_segments = 1;
+
+			ACPI_DEBUG_PRINT((ACPI_DB_NAMES,
+					  "Simple Pathname (1 segment, Flags=%X)\n",
+					  flags));
+			break;
+		}
+
+		ACPI_DEBUG_EXEC(acpi_ns_print_pathname(num_segments, path));
+	}
+
+	/*
+	 * Search namespace for each segment of the name. Loop through and
+	 * verify (or add to the namespace) each name segment.
+	 *
+	 * The object type is significant only at the last name
+	 * segment. (We don't care about the types along the path, only
+	 * the type of the final target object.)
+	 */
+	this_search_type = ACPI_TYPE_ANY;
+	current_node = this_node;
+	while (num_segments && current_node) {
+		num_segments--;
+		if (!num_segments) {
+
+			/* This is the last segment, enable typechecking */
+
+			this_search_type = type;
+
+			/*
+			 * Only allow automatic parent search (search rules) if the caller
+			 * requested it AND we have a single, non-fully-qualified name_seg
+			 */
+			if ((search_parent_flag != ACPI_NS_NO_UPSEARCH) &&
+			    (flags & ACPI_NS_SEARCH_PARENT)) {
+				local_flags |= ACPI_NS_SEARCH_PARENT;
+			}
+
+			/* Set error flag according to caller */
+
+			if (flags & ACPI_NS_ERROR_IF_FOUND) {
+				local_flags |= ACPI_NS_ERROR_IF_FOUND;
+			}
+		}
+
+		/* Extract one ACPI name from the front of the pathname */
+
+		ACPI_MOVE_32_TO_32(&simple_name, path);
+
+		/* Try to find the single (4 character) ACPI name */
+
+		status =
+		    acpi_ns_search_and_enter(simple_name, walk_state,
+					     current_node, interpreter_mode,
+					     this_search_type, local_flags,
+					     &this_node);
+		if (ACPI_FAILURE(status)) {
+			if (status == AE_NOT_FOUND) {
+
+				/* Name not found in ACPI namespace */
+
+				ACPI_DEBUG_PRINT((ACPI_DB_NAMES,
+						  "Name [%4.4s] not found in scope [%4.4s] %p\n",
+						  (char *)&simple_name,
+						  (char *)&current_node->name,
+						  current_node));
+			}
+
+			*return_node = this_node;
+			return_ACPI_STATUS(status);
+		}
+
+		/* More segments to follow? */
+
+		if (num_segments > 0) {
+			/*
+			 * If we have an alias to an object that opens a scope (such as a
+			 * device or processor), we need to dereference the alias here so
+			 * that we can access any children of the original node (via the
+			 * remaining segments).
+			 */
+			if (this_node->type == ACPI_TYPE_LOCAL_ALIAS) {
+				if (!this_node->object) {
+					return_ACPI_STATUS(AE_NOT_EXIST);
+				}
+
+				if (acpi_ns_opens_scope
+				    (((struct acpi_namespace_node *)
+				      this_node->object)->type)) {
+					this_node =
+					    (struct acpi_namespace_node *)
+					    this_node->object;
+				}
+			}
+		}
+
+		/* Special handling for the last segment (num_segments == 0) */
+
+		else {
+			/*
+			 * Sanity typecheck of the target object:
+			 *
+			 * If 1) This is the last segment (num_segments == 0)
+			 *    2) And we are looking for a specific type
+			 *       (Not checking for TYPE_ANY)
+			 *    3) Which is not an alias
+			 *    4) Which is not a local type (TYPE_SCOPE)
+			 *    5) And the type of target object is known (not TYPE_ANY)
+			 *    6) And target object does not match what we are looking for
+			 *
+			 * Then we have a type mismatch. Just warn and ignore it.
+			 */
+			if ((type_to_check_for != ACPI_TYPE_ANY) &&
+			    (type_to_check_for != ACPI_TYPE_LOCAL_ALIAS) &&
+			    (type_to_check_for != ACPI_TYPE_LOCAL_METHOD_ALIAS)
+			    && (type_to_check_for != ACPI_TYPE_LOCAL_SCOPE)
+			    && (this_node->type != ACPI_TYPE_ANY)
+			    && (this_node->type != type_to_check_for)) {
+
+				/* Complain about a type mismatch */
+
+				ACPI_WARNING((AE_INFO,
+					      "NsLookup: Type mismatch on %4.4s (%s), searching for (%s)",
+					      ACPI_CAST_PTR(char, &simple_name),
+					      acpi_ut_get_type_name(this_node->
+								    type),
+					      acpi_ut_get_type_name
+					      (type_to_check_for)));
+			}
+
+			/*
+			 * If this is the last name segment and we are not looking for a
+			 * specific type, but the type of found object is known, use that
+			 * type to (later) see if it opens a scope.
+			 */
+			if (type == ACPI_TYPE_ANY) {
+				type = this_node->type;
+			}
+		}
+
+		/* Point to next name segment and make this node current */
+
+		path += ACPI_NAME_SIZE;
+		current_node = this_node;
+	}
+
+	/* Always check if we need to open a new scope */
+
+	if (!(flags & ACPI_NS_DONT_OPEN_SCOPE) && (walk_state)) {
+		/*
+		 * If entry is a type which opens a scope, push the new scope on the
+		 * scope stack.
+		 */
+		if (acpi_ns_opens_scope(type)) {
+			status =
+			    acpi_ds_scope_stack_push(this_node, type,
+						     walk_state);
+			if (ACPI_FAILURE(status)) {
+				return_ACPI_STATUS(status);
+			}
+		}
+	}
+
+	*return_node = this_node;
+	return_ACPI_STATUS(AE_OK);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nsalloc.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nsalloc.c
new file mode 100644
index 00000000..c5b00ade
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nsalloc.c
@@ -0,0 +1,516 @@
+/*******************************************************************************
+ *
+ * Module Name: nsalloc - Namespace allocation and deletion utilities
+ *
+ ******************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acnamesp.h"
+
+#define _COMPONENT          ACPI_NAMESPACE
+ACPI_MODULE_NAME("nsalloc")
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_create_node
+ *
+ * PARAMETERS:  Name            - Name of the new node (4 char ACPI name)
+ *
+ * RETURN:      New namespace node (Null on failure)
+ *
+ * DESCRIPTION: Create a namespace node
+ *
+ ******************************************************************************/
+struct acpi_namespace_node *acpi_ns_create_node(u32 name)
+{
+	struct acpi_namespace_node *node;
+#ifdef ACPI_DBG_TRACK_ALLOCATIONS
+	u32 temp;
+#endif
+
+	ACPI_FUNCTION_TRACE(ns_create_node);
+
+	node = acpi_os_acquire_object(acpi_gbl_namespace_cache);
+	if (!node) {
+		return_PTR(NULL);
+	}
+
+	ACPI_MEM_TRACKING(acpi_gbl_ns_node_list->total_allocated++);
+
+#ifdef ACPI_DBG_TRACK_ALLOCATIONS
+	temp = acpi_gbl_ns_node_list->total_allocated -
+	    acpi_gbl_ns_node_list->total_freed;
+	if (temp > acpi_gbl_ns_node_list->max_occupied) {
+		acpi_gbl_ns_node_list->max_occupied = temp;
+	}
+#endif
+
+	node->name.integer = name;
+	ACPI_SET_DESCRIPTOR_TYPE(node, ACPI_DESC_TYPE_NAMED);
+	return_PTR(node);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_delete_node
+ *
+ * PARAMETERS:  Node            - Node to be deleted
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Delete a namespace node. All node deletions must come through
+ *              here. Detaches any attached objects, including any attached
+ *              data. If a handler is associated with attached data, it is
+ *              invoked before the node is deleted.
+ *
+ ******************************************************************************/
+
+void acpi_ns_delete_node(struct acpi_namespace_node *node)
+{
+	union acpi_operand_object *obj_desc;
+
+	ACPI_FUNCTION_NAME(ns_delete_node);
+
+	/* Detach an object if there is one */
+
+	acpi_ns_detach_object(node);
+
+	/*
+	 * Delete an attached data object if present (an object that was created
+	 * and attached via acpi_attach_data). Note: After any normal object is
+	 * detached above, the only possible remaining object is a data object.
+	 */
+	obj_desc = node->object;
+	if (obj_desc && (obj_desc->common.type == ACPI_TYPE_LOCAL_DATA)) {
+
+		/* Invoke the attached data deletion handler if present */
+
+		if (obj_desc->data.handler) {
+			obj_desc->data.handler(node, obj_desc->data.pointer);
+		}
+
+		acpi_ut_remove_reference(obj_desc);
+	}
+
+	/* Now we can delete the node */
+
+	(void)acpi_os_release_object(acpi_gbl_namespace_cache, node);
+
+	ACPI_MEM_TRACKING(acpi_gbl_ns_node_list->total_freed++);
+	ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS, "Node %p, Remaining %X\n",
+			  node, acpi_gbl_current_node_count));
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_remove_node
+ *
+ * PARAMETERS:  Node            - Node to be removed/deleted
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Remove (unlink) and delete a namespace node
+ *
+ ******************************************************************************/
+
+void acpi_ns_remove_node(struct acpi_namespace_node *node)
+{
+	struct acpi_namespace_node *parent_node;
+	struct acpi_namespace_node *prev_node;
+	struct acpi_namespace_node *next_node;
+
+	ACPI_FUNCTION_TRACE_PTR(ns_remove_node, node);
+
+	parent_node = node->parent;
+
+	prev_node = NULL;
+	next_node = parent_node->child;
+
+	/* Find the node that is the previous peer in the parent's child list */
+
+	while (next_node != node) {
+		prev_node = next_node;
+		next_node = next_node->peer;
+	}
+
+	if (prev_node) {
+
+		/* Node is not first child, unlink it */
+
+		prev_node->peer = node->peer;
+	} else {
+		/*
+		 * Node is first child (has no previous peer).
+		 * Link peer list to parent
+		 */
+		parent_node->child = node->peer;
+	}
+
+	/* Delete the node and any attached objects */
+
+	acpi_ns_delete_node(node);
+	return_VOID;
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_install_node
+ *
+ * PARAMETERS:  walk_state      - Current state of the walk
+ *              parent_node     - The parent of the new Node
+ *              Node            - The new Node to install
+ *              Type            - ACPI object type of the new Node
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Initialize a new namespace node and install it amongst
+ *              its peers.
+ *
+ *              Note: Current namespace lookup is linear search. This appears
+ *              to be sufficient as namespace searches consume only a small
+ *              fraction of the execution time of the ACPI subsystem.
+ *
+ ******************************************************************************/
+
+void acpi_ns_install_node(struct acpi_walk_state *walk_state, struct acpi_namespace_node *parent_node,	/* Parent */
+			  struct acpi_namespace_node *node,	/* New Child */
+			  acpi_object_type type)
+{
+	acpi_owner_id owner_id = 0;
+	struct acpi_namespace_node *child_node;
+
+	ACPI_FUNCTION_TRACE(ns_install_node);
+
+	if (walk_state) {
+		/*
+		 * Get the owner ID from the Walk state. The owner ID is used to
+		 * track table deletion and deletion of objects created by methods.
+		 */
+		owner_id = walk_state->owner_id;
+
+		if ((walk_state->method_desc) &&
+		    (parent_node != walk_state->method_node)) {
+			/*
+			 * A method is creating a new node that is not a child of the
+			 * method (it is non-local). Mark the executing method as having
+			 * modified the namespace. This is used for cleanup when the
+			 * method exits.
+			 */
+			walk_state->method_desc->method.info_flags |=
+			    ACPI_METHOD_MODIFIED_NAMESPACE;
+		}
+	}
+
+	/* Link the new entry into the parent and existing children */
+
+	node->peer = NULL;
+	node->parent = parent_node;
+	child_node = parent_node->child;
+
+	if (!child_node) {
+		parent_node->child = node;
+	} else {
+		/* Add node to the end of the peer list */
+
+		while (child_node->peer) {
+			child_node = child_node->peer;
+		}
+
+		child_node->peer = node;
+	}
+
+	/* Init the new entry */
+
+	node->owner_id = owner_id;
+	node->type = (u8)type;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_NAMES,
+			  "%4.4s (%s) [Node %p Owner %X] added to %4.4s (%s) [Node %p]\n",
+			  acpi_ut_get_node_name(node),
+			  acpi_ut_get_type_name(node->type), node, owner_id,
+			  acpi_ut_get_node_name(parent_node),
+			  acpi_ut_get_type_name(parent_node->type),
+			  parent_node));
+
+	return_VOID;
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_delete_children
+ *
+ * PARAMETERS:  parent_node     - Delete this objects children
+ *
+ * RETURN:      None.
+ *
+ * DESCRIPTION: Delete all children of the parent object. In other words,
+ *              deletes a "scope".
+ *
+ ******************************************************************************/
+
+void acpi_ns_delete_children(struct acpi_namespace_node *parent_node)
+{
+	struct acpi_namespace_node *next_node;
+	struct acpi_namespace_node *node_to_delete;
+
+	ACPI_FUNCTION_TRACE_PTR(ns_delete_children, parent_node);
+
+	if (!parent_node) {
+		return_VOID;
+	}
+
+	/* Deallocate all children at this level */
+
+	next_node = parent_node->child;
+	while (next_node) {
+
+		/* Grandchildren should have all been deleted already */
+
+		if (next_node->child) {
+			ACPI_ERROR((AE_INFO, "Found a grandchild! P=%p C=%p",
+				    parent_node, next_node));
+		}
+
+		/*
+		 * Delete this child node and move on to the next child in the list.
+		 * No need to unlink the node since we are deleting the entire branch.
+		 */
+		node_to_delete = next_node;
+		next_node = next_node->peer;
+		acpi_ns_delete_node(node_to_delete);
+	};
+
+	/* Clear the parent's child pointer */
+
+	parent_node->child = NULL;
+	return_VOID;
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_delete_namespace_subtree
+ *
+ * PARAMETERS:  parent_node     - Root of the subtree to be deleted
+ *
+ * RETURN:      None.
+ *
+ * DESCRIPTION: Delete a subtree of the namespace.  This includes all objects
+ *              stored within the subtree.
+ *
+ ******************************************************************************/
+
+void acpi_ns_delete_namespace_subtree(struct acpi_namespace_node *parent_node)
+{
+	struct acpi_namespace_node *child_node = NULL;
+	u32 level = 1;
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(ns_delete_namespace_subtree);
+
+	if (!parent_node) {
+		return_VOID;
+	}
+
+	/* Lock namespace for possible update */
+
+	status = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);
+	if (ACPI_FAILURE(status)) {
+		return_VOID;
+	}
+
+	/*
+	 * Traverse the tree of objects until we bubble back up
+	 * to where we started.
+	 */
+	while (level > 0) {
+
+		/* Get the next node in this scope (NULL if none) */
+
+		child_node = acpi_ns_get_next_node(parent_node, child_node);
+		if (child_node) {
+
+			/* Found a child node - detach any attached object */
+
+			acpi_ns_detach_object(child_node);
+
+			/* Check if this node has any children */
+
+			if (child_node->child) {
+				/*
+				 * There is at least one child of this node,
+				 * visit the node
+				 */
+				level++;
+				parent_node = child_node;
+				child_node = NULL;
+			}
+		} else {
+			/*
+			 * No more children of this parent node.
+			 * Move up to the grandparent.
+			 */
+			level--;
+
+			/*
+			 * Now delete all of the children of this parent
+			 * all at the same time.
+			 */
+			acpi_ns_delete_children(parent_node);
+
+			/* New "last child" is this parent node */
+
+			child_node = parent_node;
+
+			/* Move up the tree to the grandparent */
+
+			parent_node = parent_node->parent;
+		}
+	}
+
+	(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);
+	return_VOID;
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_delete_namespace_by_owner
+ *
+ * PARAMETERS:  owner_id    - All nodes with this owner will be deleted
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Delete entries within the namespace that are owned by a
+ *              specific ID.  Used to delete entire ACPI tables.  All
+ *              reference counts are updated.
+ *
+ * MUTEX:       Locks namespace during deletion walk.
+ *
+ ******************************************************************************/
+
+void acpi_ns_delete_namespace_by_owner(acpi_owner_id owner_id)
+{
+	struct acpi_namespace_node *child_node;
+	struct acpi_namespace_node *deletion_node;
+	struct acpi_namespace_node *parent_node;
+	u32 level;
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE_U32(ns_delete_namespace_by_owner, owner_id);
+
+	if (owner_id == 0) {
+		return_VOID;
+	}
+
+	/* Lock namespace for possible update */
+
+	status = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);
+	if (ACPI_FAILURE(status)) {
+		return_VOID;
+	}
+
+	deletion_node = NULL;
+	parent_node = acpi_gbl_root_node;
+	child_node = NULL;
+	level = 1;
+
+	/*
+	 * Traverse the tree of nodes until we bubble back up
+	 * to where we started.
+	 */
+	while (level > 0) {
+		/*
+		 * Get the next child of this parent node. When child_node is NULL,
+		 * the first child of the parent is returned
+		 */
+		child_node = acpi_ns_get_next_node(parent_node, child_node);
+
+		if (deletion_node) {
+			acpi_ns_delete_children(deletion_node);
+			acpi_ns_remove_node(deletion_node);
+			deletion_node = NULL;
+		}
+
+		if (child_node) {
+			if (child_node->owner_id == owner_id) {
+
+				/* Found a matching child node - detach any attached object */
+
+				acpi_ns_detach_object(child_node);
+			}
+
+			/* Check if this node has any children */
+
+			if (child_node->child) {
+				/*
+				 * There is at least one child of this node,
+				 * visit the node
+				 */
+				level++;
+				parent_node = child_node;
+				child_node = NULL;
+			} else if (child_node->owner_id == owner_id) {
+				deletion_node = child_node;
+			}
+		} else {
+			/*
+			 * No more children of this parent node.
+			 * Move up to the grandparent.
+			 */
+			level--;
+			if (level != 0) {
+				if (parent_node->owner_id == owner_id) {
+					deletion_node = parent_node;
+				}
+			}
+
+			/* New "last child" is this parent node */
+
+			child_node = parent_node;
+
+			/* Move up the tree to the grandparent */
+
+			parent_node = parent_node->parent;
+		}
+	}
+
+	(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);
+	return_VOID;
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nsdump.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nsdump.c
new file mode 100644
index 00000000..72b829ae
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nsdump.c
@@ -0,0 +1,718 @@
+/******************************************************************************
+ *
+ * Module Name: nsdump - table dumping routines for debug
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acnamesp.h"
+
+#define _COMPONENT          ACPI_NAMESPACE
+ACPI_MODULE_NAME("nsdump")
+
+/* Local prototypes */
+#ifdef ACPI_OBSOLETE_FUNCTIONS
+void acpi_ns_dump_root_devices(void);
+
+static acpi_status
+acpi_ns_dump_one_device(acpi_handle obj_handle,
+			u32 level, void *context, void **return_value);
+#endif
+
+#if defined(ACPI_DEBUG_OUTPUT) || defined(ACPI_DEBUGGER)
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_print_pathname
+ *
+ * PARAMETERS:  num_segments        - Number of ACPI name segments
+ *              Pathname            - The compressed (internal) path
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Print an object's full namespace pathname
+ *
+ ******************************************************************************/
+
+void acpi_ns_print_pathname(u32 num_segments, char *pathname)
+{
+	u32 i;
+
+	ACPI_FUNCTION_NAME(ns_print_pathname);
+
+	if (!(acpi_dbg_level & ACPI_LV_NAMES)
+	    || !(acpi_dbg_layer & ACPI_NAMESPACE)) {
+		return;
+	}
+
+	/* Print the entire name */
+
+	ACPI_DEBUG_PRINT((ACPI_DB_NAMES, "["));
+
+	while (num_segments) {
+		for (i = 0; i < 4; i++) {
+			ACPI_IS_PRINT(pathname[i]) ?
+			    acpi_os_printf("%c", pathname[i]) :
+			    acpi_os_printf("?");
+		}
+
+		pathname += ACPI_NAME_SIZE;
+		num_segments--;
+		if (num_segments) {
+			acpi_os_printf(".");
+		}
+	}
+
+	acpi_os_printf("]\n");
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_dump_pathname
+ *
+ * PARAMETERS:  Handle              - Object
+ *              Msg                 - Prefix message
+ *              Level               - Desired debug level
+ *              Component           - Caller's component ID
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Print an object's full namespace pathname
+ *              Manages allocation/freeing of a pathname buffer
+ *
+ ******************************************************************************/
+
+void
+acpi_ns_dump_pathname(acpi_handle handle, char *msg, u32 level, u32 component)
+{
+
+	ACPI_FUNCTION_TRACE(ns_dump_pathname);
+
+	/* Do this only if the requested debug level and component are enabled */
+
+	if (!(acpi_dbg_level & level) || !(acpi_dbg_layer & component)) {
+		return_VOID;
+	}
+
+	/* Convert handle to a full pathname and print it (with supplied message) */
+
+	acpi_ns_print_node_pathname(handle, msg);
+	acpi_os_printf("\n");
+	return_VOID;
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_dump_one_object
+ *
+ * PARAMETERS:  obj_handle          - Node to be dumped
+ *              Level               - Nesting level of the handle
+ *              Context             - Passed into walk_namespace
+ *              return_value        - Not used
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Dump a single Node
+ *              This procedure is a user_function called by acpi_ns_walk_namespace.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ns_dump_one_object(acpi_handle obj_handle,
+			u32 level, void *context, void **return_value)
+{
+	struct acpi_walk_info *info = (struct acpi_walk_info *)context;
+	struct acpi_namespace_node *this_node;
+	union acpi_operand_object *obj_desc = NULL;
+	acpi_object_type obj_type;
+	acpi_object_type type;
+	u32 bytes_to_dump;
+	u32 dbg_level;
+	u32 i;
+
+	ACPI_FUNCTION_NAME(ns_dump_one_object);
+
+	/* Is output enabled? */
+
+	if (!(acpi_dbg_level & info->debug_level)) {
+		return (AE_OK);
+	}
+
+	if (!obj_handle) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Null object handle\n"));
+		return (AE_OK);
+	}
+
+	this_node = acpi_ns_validate_handle(obj_handle);
+	if (!this_node) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Invalid object handle %p\n",
+				  obj_handle));
+		return (AE_OK);
+	}
+
+	type = this_node->type;
+
+	/* Check if the owner matches */
+
+	if ((info->owner_id != ACPI_OWNER_ID_MAX) &&
+	    (info->owner_id != this_node->owner_id)) {
+		return (AE_OK);
+	}
+
+	if (!(info->display_type & ACPI_DISPLAY_SHORT)) {
+
+		/* Indent the object according to the level */
+
+		acpi_os_printf("%2d%*s", (u32)level - 1, (int)level * 2, " ");
+
+		/* Check the node type and name */
+
+		if (type > ACPI_TYPE_LOCAL_MAX) {
+			ACPI_WARNING((AE_INFO,
+				      "Invalid ACPI Object Type 0x%08X", type));
+		}
+
+		acpi_os_printf("%4.4s", acpi_ut_get_node_name(this_node));
+	}
+
+	/* Now we can print out the pertinent information */
+
+	acpi_os_printf(" %-12s %p %2.2X ",
+		       acpi_ut_get_type_name(type), this_node,
+		       this_node->owner_id);
+
+	dbg_level = acpi_dbg_level;
+	acpi_dbg_level = 0;
+	obj_desc = acpi_ns_get_attached_object(this_node);
+	acpi_dbg_level = dbg_level;
+
+	/* Temp nodes are those nodes created by a control method */
+
+	if (this_node->flags & ANOBJ_TEMPORARY) {
+		acpi_os_printf("(T) ");
+	}
+
+	switch (info->display_type & ACPI_DISPLAY_MASK) {
+	case ACPI_DISPLAY_SUMMARY:
+
+		if (!obj_desc) {
+
+			/* No attached object, we are done */
+
+			acpi_os_printf("\n");
+			return (AE_OK);
+		}
+
+		switch (type) {
+		case ACPI_TYPE_PROCESSOR:
+
+			acpi_os_printf("ID %X Len %.4X Addr %p\n",
+				       obj_desc->processor.proc_id,
+				       obj_desc->processor.length,
+				       ACPI_CAST_PTR(void,
+						     obj_desc->processor.
+						     address));
+			break;
+
+		case ACPI_TYPE_DEVICE:
+
+			acpi_os_printf("Notify Object: %p\n", obj_desc);
+			break;
+
+		case ACPI_TYPE_METHOD:
+
+			acpi_os_printf("Args %X Len %.4X Aml %p\n",
+				       (u32)obj_desc->method.param_count,
+				       obj_desc->method.aml_length,
+				       obj_desc->method.aml_start);
+			break;
+
+		case ACPI_TYPE_INTEGER:
+
+			acpi_os_printf("= %8.8X%8.8X\n",
+				       ACPI_FORMAT_UINT64(obj_desc->integer.
+							  value));
+			break;
+
+		case ACPI_TYPE_PACKAGE:
+
+			if (obj_desc->common.flags & AOPOBJ_DATA_VALID) {
+				acpi_os_printf("Elements %.2X\n",
+					       obj_desc->package.count);
+			} else {
+				acpi_os_printf("[Length not yet evaluated]\n");
+			}
+			break;
+
+		case ACPI_TYPE_BUFFER:
+
+			if (obj_desc->common.flags & AOPOBJ_DATA_VALID) {
+				acpi_os_printf("Len %.2X",
+					       obj_desc->buffer.length);
+
+				/* Dump some of the buffer */
+
+				if (obj_desc->buffer.length > 0) {
+					acpi_os_printf(" =");
+					for (i = 0;
+					     (i < obj_desc->buffer.length
+					      && i < 12); i++) {
+						acpi_os_printf(" %.2hX",
+							       obj_desc->buffer.
+							       pointer[i]);
+					}
+				}
+				acpi_os_printf("\n");
+			} else {
+				acpi_os_printf("[Length not yet evaluated]\n");
+			}
+			break;
+
+		case ACPI_TYPE_STRING:
+
+			acpi_os_printf("Len %.2X ", obj_desc->string.length);
+			acpi_ut_print_string(obj_desc->string.pointer, 32);
+			acpi_os_printf("\n");
+			break;
+
+		case ACPI_TYPE_REGION:
+
+			acpi_os_printf("[%s]",
+				       acpi_ut_get_region_name(obj_desc->region.
+							       space_id));
+			if (obj_desc->region.flags & AOPOBJ_DATA_VALID) {
+				acpi_os_printf(" Addr %8.8X%8.8X Len %.4X\n",
+					       ACPI_FORMAT_NATIVE_UINT
+					       (obj_desc->region.address),
+					       obj_desc->region.length);
+			} else {
+				acpi_os_printf
+				    (" [Address/Length not yet evaluated]\n");
+			}
+			break;
+
+		case ACPI_TYPE_LOCAL_REFERENCE:
+
+			acpi_os_printf("[%s]\n",
+				       acpi_ut_get_reference_name(obj_desc));
+			break;
+
+		case ACPI_TYPE_BUFFER_FIELD:
+
+			if (obj_desc->buffer_field.buffer_obj &&
+			    obj_desc->buffer_field.buffer_obj->buffer.node) {
+				acpi_os_printf("Buf [%4.4s]",
+					       acpi_ut_get_node_name(obj_desc->
+								     buffer_field.
+								     buffer_obj->
+								     buffer.
+								     node));
+			}
+			break;
+
+		case ACPI_TYPE_LOCAL_REGION_FIELD:
+
+			acpi_os_printf("Rgn [%4.4s]",
+				       acpi_ut_get_node_name(obj_desc->
+							     common_field.
+							     region_obj->region.
+							     node));
+			break;
+
+		case ACPI_TYPE_LOCAL_BANK_FIELD:
+
+			acpi_os_printf("Rgn [%4.4s] Bnk [%4.4s]",
+				       acpi_ut_get_node_name(obj_desc->
+							     common_field.
+							     region_obj->region.
+							     node),
+				       acpi_ut_get_node_name(obj_desc->
+							     bank_field.
+							     bank_obj->
+							     common_field.
+							     node));
+			break;
+
+		case ACPI_TYPE_LOCAL_INDEX_FIELD:
+
+			acpi_os_printf("Idx [%4.4s] Dat [%4.4s]",
+				       acpi_ut_get_node_name(obj_desc->
+							     index_field.
+							     index_obj->
+							     common_field.node),
+				       acpi_ut_get_node_name(obj_desc->
+							     index_field.
+							     data_obj->
+							     common_field.
+							     node));
+			break;
+
+		case ACPI_TYPE_LOCAL_ALIAS:
+		case ACPI_TYPE_LOCAL_METHOD_ALIAS:
+
+			acpi_os_printf("Target %4.4s (%p)\n",
+				       acpi_ut_get_node_name(obj_desc),
+				       obj_desc);
+			break;
+
+		default:
+
+			acpi_os_printf("Object %p\n", obj_desc);
+			break;
+		}
+
+		/* Common field handling */
+
+		switch (type) {
+		case ACPI_TYPE_BUFFER_FIELD:
+		case ACPI_TYPE_LOCAL_REGION_FIELD:
+		case ACPI_TYPE_LOCAL_BANK_FIELD:
+		case ACPI_TYPE_LOCAL_INDEX_FIELD:
+
+			acpi_os_printf(" Off %.3X Len %.2X Acc %.2hd\n",
+				       (obj_desc->common_field.
+					base_byte_offset * 8)
+				       +
+				       obj_desc->common_field.
+				       start_field_bit_offset,
+				       obj_desc->common_field.bit_length,
+				       obj_desc->common_field.
+				       access_byte_width);
+			break;
+
+		default:
+			break;
+		}
+		break;
+
+	case ACPI_DISPLAY_OBJECTS:
+
+		acpi_os_printf("O:%p", obj_desc);
+		if (!obj_desc) {
+
+			/* No attached object, we are done */
+
+			acpi_os_printf("\n");
+			return (AE_OK);
+		}
+
+		acpi_os_printf("(R%u)", obj_desc->common.reference_count);
+
+		switch (type) {
+		case ACPI_TYPE_METHOD:
+
+			/* Name is a Method and its AML offset/length are set */
+
+			acpi_os_printf(" M:%p-%X\n", obj_desc->method.aml_start,
+				       obj_desc->method.aml_length);
+			break;
+
+		case ACPI_TYPE_INTEGER:
+
+			acpi_os_printf(" I:%8.8X8.8%X\n",
+				       ACPI_FORMAT_UINT64(obj_desc->integer.
+							  value));
+			break;
+
+		case ACPI_TYPE_STRING:
+
+			acpi_os_printf(" S:%p-%X\n", obj_desc->string.pointer,
+				       obj_desc->string.length);
+			break;
+
+		case ACPI_TYPE_BUFFER:
+
+			acpi_os_printf(" B:%p-%X\n", obj_desc->buffer.pointer,
+				       obj_desc->buffer.length);
+			break;
+
+		default:
+
+			acpi_os_printf("\n");
+			break;
+		}
+		break;
+
+	default:
+		acpi_os_printf("\n");
+		break;
+	}
+
+	/* If debug turned off, done */
+
+	if (!(acpi_dbg_level & ACPI_LV_VALUES)) {
+		return (AE_OK);
+	}
+
+	/* If there is an attached object, display it */
+
+	dbg_level = acpi_dbg_level;
+	acpi_dbg_level = 0;
+	obj_desc = acpi_ns_get_attached_object(this_node);
+	acpi_dbg_level = dbg_level;
+
+	/* Dump attached objects */
+
+	while (obj_desc) {
+		obj_type = ACPI_TYPE_INVALID;
+		acpi_os_printf("Attached Object %p: ", obj_desc);
+
+		/* Decode the type of attached object and dump the contents */
+
+		switch (ACPI_GET_DESCRIPTOR_TYPE(obj_desc)) {
+		case ACPI_DESC_TYPE_NAMED:
+
+			acpi_os_printf("(Ptr to Node)\n");
+			bytes_to_dump = sizeof(struct acpi_namespace_node);
+			ACPI_DUMP_BUFFER(obj_desc, bytes_to_dump);
+			break;
+
+		case ACPI_DESC_TYPE_OPERAND:
+
+			obj_type = obj_desc->common.type;
+
+			if (obj_type > ACPI_TYPE_LOCAL_MAX) {
+				acpi_os_printf
+				    ("(Pointer to ACPI Object type %.2X [UNKNOWN])\n",
+				     obj_type);
+				bytes_to_dump = 32;
+			} else {
+				acpi_os_printf
+				    ("(Pointer to ACPI Object type %.2X [%s])\n",
+				     obj_type, acpi_ut_get_type_name(obj_type));
+				bytes_to_dump =
+				    sizeof(union acpi_operand_object);
+			}
+
+			ACPI_DUMP_BUFFER(obj_desc, bytes_to_dump);
+			break;
+
+		default:
+
+			break;
+		}
+
+		/* If value is NOT an internal object, we are done */
+
+		if (ACPI_GET_DESCRIPTOR_TYPE(obj_desc) !=
+		    ACPI_DESC_TYPE_OPERAND) {
+			goto cleanup;
+		}
+
+		/* Valid object, get the pointer to next level, if any */
+
+		switch (obj_type) {
+		case ACPI_TYPE_BUFFER:
+		case ACPI_TYPE_STRING:
+			/*
+			 * NOTE: takes advantage of common fields between string/buffer
+			 */
+			bytes_to_dump = obj_desc->string.length;
+			obj_desc = (void *)obj_desc->string.pointer;
+			acpi_os_printf("(Buffer/String pointer %p length %X)\n",
+				       obj_desc, bytes_to_dump);
+			ACPI_DUMP_BUFFER(obj_desc, bytes_to_dump);
+			goto cleanup;
+
+		case ACPI_TYPE_BUFFER_FIELD:
+			obj_desc =
+			    (union acpi_operand_object *)obj_desc->buffer_field.
+			    buffer_obj;
+			break;
+
+		case ACPI_TYPE_PACKAGE:
+			obj_desc = (void *)obj_desc->package.elements;
+			break;
+
+		case ACPI_TYPE_METHOD:
+			obj_desc = (void *)obj_desc->method.aml_start;
+			break;
+
+		case ACPI_TYPE_LOCAL_REGION_FIELD:
+			obj_desc = (void *)obj_desc->field.region_obj;
+			break;
+
+		case ACPI_TYPE_LOCAL_BANK_FIELD:
+			obj_desc = (void *)obj_desc->bank_field.region_obj;
+			break;
+
+		case ACPI_TYPE_LOCAL_INDEX_FIELD:
+			obj_desc = (void *)obj_desc->index_field.index_obj;
+			break;
+
+		default:
+			goto cleanup;
+		}
+
+		obj_type = ACPI_TYPE_INVALID;	/* Terminate loop after next pass */
+	}
+
+      cleanup:
+	acpi_os_printf("\n");
+	return (AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_dump_objects
+ *
+ * PARAMETERS:  Type                - Object type to be dumped
+ *              display_type        - 0 or ACPI_DISPLAY_SUMMARY
+ *              max_depth           - Maximum depth of dump. Use ACPI_UINT32_MAX
+ *                                    for an effectively unlimited depth.
+ *              owner_id            - Dump only objects owned by this ID. Use
+ *                                    ACPI_UINT32_MAX to match all owners.
+ *              start_handle        - Where in namespace to start/end search
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Dump typed objects within the loaded namespace. Uses
+ *              acpi_ns_walk_namespace in conjunction with acpi_ns_dump_one_object.
+ *
+ ******************************************************************************/
+
+void
+acpi_ns_dump_objects(acpi_object_type type,
+		     u8 display_type,
+		     u32 max_depth,
+		     acpi_owner_id owner_id, acpi_handle start_handle)
+{
+	struct acpi_walk_info info;
+	acpi_status status;
+
+	ACPI_FUNCTION_ENTRY();
+
+	/*
+	 * Just lock the entire namespace for the duration of the dump.
+	 * We don't want any changes to the namespace during this time,
+	 * especially the temporary nodes since we are going to display
+	 * them also.
+	 */
+	status = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);
+	if (ACPI_FAILURE(status)) {
+		acpi_os_printf("Could not acquire namespace mutex\n");
+		return;
+	}
+
+	info.debug_level = ACPI_LV_TABLES;
+	info.owner_id = owner_id;
+	info.display_type = display_type;
+
+	(void)acpi_ns_walk_namespace(type, start_handle, max_depth,
+				     ACPI_NS_WALK_NO_UNLOCK |
+				     ACPI_NS_WALK_TEMP_NODES,
+				     acpi_ns_dump_one_object, NULL,
+				     (void *)&info, NULL);
+
+	(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_dump_entry
+ *
+ * PARAMETERS:  Handle              - Node to be dumped
+ *              debug_level         - Output level
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Dump a single Node
+ *
+ ******************************************************************************/
+
+void acpi_ns_dump_entry(acpi_handle handle, u32 debug_level)
+{
+	struct acpi_walk_info info;
+
+	ACPI_FUNCTION_ENTRY();
+
+	info.debug_level = debug_level;
+	info.owner_id = ACPI_OWNER_ID_MAX;
+	info.display_type = ACPI_DISPLAY_SUMMARY;
+
+	(void)acpi_ns_dump_one_object(handle, 1, &info, NULL);
+}
+
+#ifdef ACPI_ASL_COMPILER
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_dump_tables
+ *
+ * PARAMETERS:  search_base         - Root of subtree to be dumped, or
+ *                                    NS_ALL to dump the entire namespace
+ *              max_depth           - Maximum depth of dump.  Use INT_MAX
+ *                                    for an effectively unlimited depth.
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Dump the name space, or a portion of it.
+ *
+ ******************************************************************************/
+
+void acpi_ns_dump_tables(acpi_handle search_base, u32 max_depth)
+{
+	acpi_handle search_handle = search_base;
+
+	ACPI_FUNCTION_TRACE(ns_dump_tables);
+
+	if (!acpi_gbl_root_node) {
+		/*
+		 * If the name space has not been initialized,
+		 * there is nothing to dump.
+		 */
+		ACPI_DEBUG_PRINT((ACPI_DB_TABLES,
+				  "namespace not initialized!\n"));
+		return_VOID;
+	}
+
+	if (ACPI_NS_ALL == search_base) {
+
+		/* Entire namespace */
+
+		search_handle = acpi_gbl_root_node;
+		ACPI_DEBUG_PRINT((ACPI_DB_TABLES, "\\\n"));
+	}
+
+	acpi_ns_dump_objects(ACPI_TYPE_ANY, ACPI_DISPLAY_OBJECTS, max_depth,
+			     ACPI_OWNER_ID_MAX, search_handle);
+	return_VOID;
+}
+#endif
+#endif
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nsdumpdv.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nsdumpdv.c
new file mode 100644
index 00000000..a106c5cc
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nsdumpdv.c
@@ -0,0 +1,141 @@
+/******************************************************************************
+ *
+ * Module Name: nsdump - table dumping routines for debug
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+
+/* TBD: This entire module is apparently obsolete and should be removed */
+
+#define _COMPONENT          ACPI_NAMESPACE
+ACPI_MODULE_NAME("nsdumpdv")
+#ifdef ACPI_OBSOLETE_FUNCTIONS
+#if defined(ACPI_DEBUG_OUTPUT) || defined(ACPI_DEBUGGER)
+#include "acnamesp.h"
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_dump_one_device
+ *
+ * PARAMETERS:  Handle              - Node to be dumped
+ *              Level               - Nesting level of the handle
+ *              Context             - Passed into walk_namespace
+ *              return_value        - Not used
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Dump a single Node that represents a device
+ *              This procedure is a user_function called by acpi_ns_walk_namespace.
+ *
+ ******************************************************************************/
+static acpi_status
+acpi_ns_dump_one_device(acpi_handle obj_handle,
+			u32 level, void *context, void **return_value)
+{
+	struct acpi_buffer buffer;
+	struct acpi_device_info *info;
+	acpi_status status;
+	u32 i;
+
+	ACPI_FUNCTION_NAME(ns_dump_one_device);
+
+	status =
+	    acpi_ns_dump_one_object(obj_handle, level, context, return_value);
+
+	buffer.length = ACPI_ALLOCATE_LOCAL_BUFFER;
+	status = acpi_get_object_info(obj_handle, &buffer);
+	if (ACPI_SUCCESS(status)) {
+		info = buffer.pointer;
+		for (i = 0; i < level; i++) {
+			ACPI_DEBUG_PRINT_RAW((ACPI_DB_TABLES, " "));
+		}
+
+		ACPI_DEBUG_PRINT_RAW((ACPI_DB_TABLES,
+				      "    HID: %s, ADR: %8.8X%8.8X, Status: %X\n",
+				      info->hardware_id.value,
+				      ACPI_FORMAT_UINT64(info->address),
+				      info->current_status));
+		ACPI_FREE(info);
+	}
+
+	return (status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_dump_root_devices
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Dump all objects of type "device"
+ *
+ ******************************************************************************/
+
+void acpi_ns_dump_root_devices(void)
+{
+	acpi_handle sys_bus_handle;
+	acpi_status status;
+
+	ACPI_FUNCTION_NAME(ns_dump_root_devices);
+
+	/* Only dump the table if tracing is enabled */
+
+	if (!(ACPI_LV_TABLES & acpi_dbg_level)) {
+		return;
+	}
+
+	status = acpi_get_handle(NULL, ACPI_NS_SYSTEM_BUS, &sys_bus_handle);
+	if (ACPI_FAILURE(status)) {
+		return;
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_TABLES,
+			  "Display of all devices in the namespace:\n"));
+
+	status = acpi_ns_walk_namespace(ACPI_TYPE_DEVICE, sys_bus_handle,
+					ACPI_UINT32_MAX, ACPI_NS_WALK_NO_UNLOCK,
+					acpi_ns_dump_one_device, NULL, NULL,
+					NULL);
+}
+
+#endif
+#endif
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nseval.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nseval.c
new file mode 100644
index 00000000..8185b50f
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nseval.c
@@ -0,0 +1,452 @@
+/*******************************************************************************
+ *
+ * Module Name: nseval - Object evaluation, includes control method execution
+ *
+ ******************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acparser.h"
+#include "acinterp.h"
+#include "acnamesp.h"
+
+#define _COMPONENT          ACPI_NAMESPACE
+ACPI_MODULE_NAME("nseval")
+
+/* Local prototypes */
+static void
+acpi_ns_exec_module_code(union acpi_operand_object *method_obj,
+			 struct acpi_evaluate_info *info);
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_evaluate
+ *
+ * PARAMETERS:  Info            - Evaluation info block, contains:
+ *                  prefix_node     - Prefix or Method/Object Node to execute
+ *                  Pathname        - Name of method to execute, If NULL, the
+ *                                    Node is the object to execute
+ *                  Parameters      - List of parameters to pass to the method,
+ *                                    terminated by NULL. Params itself may be
+ *                                    NULL if no parameters are being passed.
+ *                  return_object   - Where to put method's return value (if
+ *                                    any). If NULL, no value is returned.
+ *                  parameter_type  - Type of Parameter list
+ *                  return_object   - Where to put method's return value (if
+ *                                    any). If NULL, no value is returned.
+ *                  Flags           - ACPI_IGNORE_RETURN_VALUE to delete return
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Execute a control method or return the current value of an
+ *              ACPI namespace object.
+ *
+ * MUTEX:       Locks interpreter
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ns_evaluate(struct acpi_evaluate_info *info)
+{
+	acpi_status status;
+	struct acpi_namespace_node *node;
+
+	ACPI_FUNCTION_TRACE(ns_evaluate);
+
+	if (!info) {
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	/* Initialize the return value to an invalid object */
+
+	info->return_object = NULL;
+	info->param_count = 0;
+
+	/*
+	 * Get the actual namespace node for the target object. Handles these cases:
+	 *
+	 * 1) Null node, Pathname (absolute path)
+	 * 2) Node, Pathname (path relative to Node)
+	 * 3) Node, Null Pathname
+	 */
+	status = acpi_ns_get_node(info->prefix_node, info->pathname,
+				  ACPI_NS_NO_UPSEARCH, &info->resolved_node);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/*
+	 * For a method alias, we must grab the actual method node so that proper
+	 * scoping context will be established before execution.
+	 */
+	if (acpi_ns_get_type(info->resolved_node) ==
+	    ACPI_TYPE_LOCAL_METHOD_ALIAS) {
+		info->resolved_node =
+		    ACPI_CAST_PTR(struct acpi_namespace_node,
+				  info->resolved_node->object);
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_NAMES, "%s [%p] Value %p\n", info->pathname,
+			  info->resolved_node,
+			  acpi_ns_get_attached_object(info->resolved_node)));
+
+	node = info->resolved_node;
+
+	/*
+	 * Two major cases here:
+	 *
+	 * 1) The object is a control method -- execute it
+	 * 2) The object is not a method -- just return it's current value
+	 */
+	if (acpi_ns_get_type(info->resolved_node) == ACPI_TYPE_METHOD) {
+		/*
+		 * 1) Object is a control method - execute it
+		 */
+
+		/* Verify that there is a method object associated with this node */
+
+		info->obj_desc =
+		    acpi_ns_get_attached_object(info->resolved_node);
+		if (!info->obj_desc) {
+			ACPI_ERROR((AE_INFO,
+				    "Control method has no attached sub-object"));
+			return_ACPI_STATUS(AE_NULL_OBJECT);
+		}
+
+		/* Count the number of arguments being passed to the method */
+
+		if (info->parameters) {
+			while (info->parameters[info->param_count]) {
+				if (info->param_count > ACPI_METHOD_MAX_ARG) {
+					return_ACPI_STATUS(AE_LIMIT);
+				}
+				info->param_count++;
+			}
+		}
+
+		ACPI_DUMP_PATHNAME(info->resolved_node, "ACPI: Execute Method",
+				   ACPI_LV_INFO, _COMPONENT);
+
+		ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
+				  "Method at AML address %p Length %X\n",
+				  info->obj_desc->method.aml_start + 1,
+				  info->obj_desc->method.aml_length - 1));
+
+		/*
+		 * Any namespace deletion must acquire both the namespace and
+		 * interpreter locks to ensure that no thread is using the portion of
+		 * the namespace that is being deleted.
+		 *
+		 * Execute the method via the interpreter. The interpreter is locked
+		 * here before calling into the AML parser
+		 */
+		acpi_ex_enter_interpreter();
+		status = acpi_ps_execute_method(info);
+		acpi_ex_exit_interpreter();
+	} else {
+		/*
+		 * 2) Object is not a method, return its current value
+		 *
+		 * Disallow certain object types. For these, "evaluation" is undefined.
+		 */
+		switch (info->resolved_node->type) {
+		case ACPI_TYPE_DEVICE:
+		case ACPI_TYPE_EVENT:
+		case ACPI_TYPE_MUTEX:
+		case ACPI_TYPE_REGION:
+		case ACPI_TYPE_THERMAL:
+		case ACPI_TYPE_LOCAL_SCOPE:
+
+			ACPI_ERROR((AE_INFO,
+				    "[%4.4s] Evaluation of object type [%s] is not supported",
+				    info->resolved_node->name.ascii,
+				    acpi_ut_get_type_name(info->resolved_node->
+							  type)));
+
+			return_ACPI_STATUS(AE_TYPE);
+
+		default:
+			break;
+		}
+
+		/*
+		 * Objects require additional resolution steps (e.g., the Node may be
+		 * a field that must be read, etc.) -- we can't just grab the object
+		 * out of the node.
+		 *
+		 * Use resolve_node_to_value() to get the associated value.
+		 *
+		 * NOTE: we can get away with passing in NULL for a walk state because
+		 * resolved_node is guaranteed to not be a reference to either a method
+		 * local or a method argument (because this interface is never called
+		 * from a running method.)
+		 *
+		 * Even though we do not directly invoke the interpreter for object
+		 * resolution, we must lock it because we could access an opregion.
+		 * The opregion access code assumes that the interpreter is locked.
+		 */
+		acpi_ex_enter_interpreter();
+
+		/* Function has a strange interface */
+
+		status =
+		    acpi_ex_resolve_node_to_value(&info->resolved_node, NULL);
+		acpi_ex_exit_interpreter();
+
+		/*
+		 * If acpi_ex_resolve_node_to_value() succeeded, the return value was placed
+		 * in resolved_node.
+		 */
+		if (ACPI_SUCCESS(status)) {
+			status = AE_CTRL_RETURN_VALUE;
+			info->return_object =
+			    ACPI_CAST_PTR(union acpi_operand_object,
+					  info->resolved_node);
+
+			ACPI_DEBUG_PRINT((ACPI_DB_NAMES,
+					  "Returning object %p [%s]\n",
+					  info->return_object,
+					  acpi_ut_get_object_type_name(info->
+								       return_object)));
+		}
+	}
+
+	/*
+	 * Check input argument count against the ASL-defined count for a method.
+	 * Also check predefined names: argument count and return value against
+	 * the ACPI specification. Some incorrect return value types are repaired.
+	 */
+	(void)acpi_ns_check_predefined_names(node, info->param_count,
+					     status, &info->return_object);
+
+	/* Check if there is a return value that must be dealt with */
+
+	if (status == AE_CTRL_RETURN_VALUE) {
+
+		/* If caller does not want the return value, delete it */
+
+		if (info->flags & ACPI_IGNORE_RETURN_VALUE) {
+			acpi_ut_remove_reference(info->return_object);
+			info->return_object = NULL;
+		}
+
+		/* Map AE_CTRL_RETURN_VALUE to AE_OK, we are done with it */
+
+		status = AE_OK;
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_NAMES,
+			  "*** Completed evaluation of object %s ***\n",
+			  info->pathname));
+
+	/*
+	 * Namespace was unlocked by the handling acpi_ns* function, so we
+	 * just return
+	 */
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_exec_module_code_list
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None. Exceptions during method execution are ignored, since
+ *              we cannot abort a table load.
+ *
+ * DESCRIPTION: Execute all elements of the global module-level code list.
+ *              Each element is executed as a single control method.
+ *
+ ******************************************************************************/
+
+void acpi_ns_exec_module_code_list(void)
+{
+	union acpi_operand_object *prev;
+	union acpi_operand_object *next;
+	struct acpi_evaluate_info *info;
+	u32 method_count = 0;
+
+	ACPI_FUNCTION_TRACE(ns_exec_module_code_list);
+
+	/* Exit now if the list is empty */
+
+	next = acpi_gbl_module_code_list;
+	if (!next) {
+		return_VOID;
+	}
+
+	/* Allocate the evaluation information block */
+
+	info = ACPI_ALLOCATE(sizeof(struct acpi_evaluate_info));
+	if (!info) {
+		return_VOID;
+	}
+
+	/* Walk the list, executing each "method" */
+
+	while (next) {
+		prev = next;
+		next = next->method.mutex;
+
+		/* Clear the link field and execute the method */
+
+		prev->method.mutex = NULL;
+		acpi_ns_exec_module_code(prev, info);
+		method_count++;
+
+		/* Delete the (temporary) method object */
+
+		acpi_ut_remove_reference(prev);
+	}
+
+	ACPI_INFO((AE_INFO,
+		   "Executed %u blocks of module-level executable AML code",
+		   method_count));
+
+	ACPI_FREE(info);
+	acpi_gbl_module_code_list = NULL;
+	return_VOID;
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_exec_module_code
+ *
+ * PARAMETERS:  method_obj          - Object container for the module-level code
+ *              Info                - Info block for method evaluation
+ *
+ * RETURN:      None. Exceptions during method execution are ignored, since
+ *              we cannot abort a table load.
+ *
+ * DESCRIPTION: Execute a control method containing a block of module-level
+ *              executable AML code. The control method is temporarily
+ *              installed to the root node, then evaluated.
+ *
+ ******************************************************************************/
+
+static void
+acpi_ns_exec_module_code(union acpi_operand_object *method_obj,
+			 struct acpi_evaluate_info *info)
+{
+	union acpi_operand_object *parent_obj;
+	struct acpi_namespace_node *parent_node;
+	acpi_object_type type;
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(ns_exec_module_code);
+
+	/*
+	 * Get the parent node. We cheat by using the next_object field
+	 * of the method object descriptor.
+	 */
+	parent_node = ACPI_CAST_PTR(struct acpi_namespace_node,
+				    method_obj->method.next_object);
+	type = acpi_ns_get_type(parent_node);
+
+	/*
+	 * Get the region handler and save it in the method object. We may need
+	 * this if an operation region declaration causes a _REG method to be run.
+	 *
+	 * We can't do this in acpi_ps_link_module_code because
+	 * acpi_gbl_root_node->Object is NULL at PASS1.
+	 */
+	if ((type == ACPI_TYPE_DEVICE) && parent_node->object) {
+		method_obj->method.dispatch.handler =
+		    parent_node->object->device.handler;
+	}
+
+	/* Must clear next_object (acpi_ns_attach_object needs the field) */
+
+	method_obj->method.next_object = NULL;
+
+	/* Initialize the evaluation information block */
+
+	ACPI_MEMSET(info, 0, sizeof(struct acpi_evaluate_info));
+	info->prefix_node = parent_node;
+
+	/*
+	 * Get the currently attached parent object. Add a reference, because the
+	 * ref count will be decreased when the method object is installed to
+	 * the parent node.
+	 */
+	parent_obj = acpi_ns_get_attached_object(parent_node);
+	if (parent_obj) {
+		acpi_ut_add_reference(parent_obj);
+	}
+
+	/* Install the method (module-level code) in the parent node */
+
+	status = acpi_ns_attach_object(parent_node, method_obj,
+				       ACPI_TYPE_METHOD);
+	if (ACPI_FAILURE(status)) {
+		goto exit;
+	}
+
+	/* Execute the parent node as a control method */
+
+	status = acpi_ns_evaluate(info);
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INIT, "Executed module-level code at %p\n",
+			  method_obj->method.aml_start));
+
+	/* Delete a possible implicit return value (in slack mode) */
+
+	if (info->return_object) {
+		acpi_ut_remove_reference(info->return_object);
+	}
+
+	/* Detach the temporary method object */
+
+	acpi_ns_detach_object(parent_node);
+
+	/* Restore the original parent object */
+
+	if (parent_obj) {
+		status = acpi_ns_attach_object(parent_node, parent_obj, type);
+	} else {
+		parent_node->type = (u8)type;
+	}
+
+      exit:
+	if (parent_obj) {
+		acpi_ut_remove_reference(parent_obj);
+	}
+	return_VOID;
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nsinit.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nsinit.c
new file mode 100644
index 00000000..f6363ce1
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nsinit.c
@@ -0,0 +1,611 @@
+/******************************************************************************
+ *
+ * Module Name: nsinit - namespace initialization
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acnamesp.h"
+#include "acdispat.h"
+#include "acinterp.h"
+
+#define _COMPONENT          ACPI_NAMESPACE
+ACPI_MODULE_NAME("nsinit")
+
+/* Local prototypes */
+static acpi_status
+acpi_ns_init_one_object(acpi_handle obj_handle,
+			u32 level, void *context, void **return_value);
+
+static acpi_status
+acpi_ns_init_one_device(acpi_handle obj_handle,
+			u32 nesting_level, void *context, void **return_value);
+
+static acpi_status
+acpi_ns_find_ini_methods(acpi_handle obj_handle,
+			 u32 nesting_level, void *context, void **return_value);
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_initialize_objects
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Walk the entire namespace and perform any necessary
+ *              initialization on the objects found therein
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ns_initialize_objects(void)
+{
+	acpi_status status;
+	struct acpi_init_walk_info info;
+
+	ACPI_FUNCTION_TRACE(ns_initialize_objects);
+
+	ACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,
+			  "**** Starting initialization of namespace objects ****\n"));
+	ACPI_DEBUG_PRINT_RAW((ACPI_DB_INIT,
+			      "Completing Region/Field/Buffer/Package initialization:"));
+
+	/* Set all init info to zero */
+
+	ACPI_MEMSET(&info, 0, sizeof(struct acpi_init_walk_info));
+
+	/* Walk entire namespace from the supplied root */
+
+	status = acpi_walk_namespace(ACPI_TYPE_ANY, ACPI_ROOT_OBJECT,
+				     ACPI_UINT32_MAX, acpi_ns_init_one_object,
+				     NULL, &info, NULL);
+	if (ACPI_FAILURE(status)) {
+		ACPI_EXCEPTION((AE_INFO, status, "During WalkNamespace"));
+	}
+
+	ACPI_DEBUG_PRINT_RAW((ACPI_DB_INIT,
+			      "\nInitialized %u/%u Regions %u/%u Fields %u/%u "
+			      "Buffers %u/%u Packages (%u nodes)\n",
+			      info.op_region_init, info.op_region_count,
+			      info.field_init, info.field_count,
+			      info.buffer_init, info.buffer_count,
+			      info.package_init, info.package_count,
+			      info.object_count));
+
+	ACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,
+			  "%u Control Methods found\n", info.method_count));
+	ACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,
+			  "%u Op Regions found\n", info.op_region_count));
+
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_initialize_devices
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      acpi_status
+ *
+ * DESCRIPTION: Walk the entire namespace and initialize all ACPI devices.
+ *              This means running _INI on all present devices.
+ *
+ *              Note: We install PCI config space handler on region access,
+ *              not here.
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ns_initialize_devices(void)
+{
+	acpi_status status;
+	struct acpi_device_walk_info info;
+
+	ACPI_FUNCTION_TRACE(ns_initialize_devices);
+
+	/* Init counters */
+
+	info.device_count = 0;
+	info.num_STA = 0;
+	info.num_INI = 0;
+
+	ACPI_DEBUG_PRINT_RAW((ACPI_DB_INIT,
+			      "Initializing Device/Processor/Thermal objects "
+			      "by executing _INI methods:"));
+
+	/* Tree analysis: find all subtrees that contain _INI methods */
+
+	status = acpi_ns_walk_namespace(ACPI_TYPE_ANY, ACPI_ROOT_OBJECT,
+					ACPI_UINT32_MAX, FALSE,
+					acpi_ns_find_ini_methods, NULL, &info,
+					NULL);
+	if (ACPI_FAILURE(status)) {
+		goto error_exit;
+	}
+
+	/* Allocate the evaluation information block */
+
+	info.evaluate_info =
+	    ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_evaluate_info));
+	if (!info.evaluate_info) {
+		status = AE_NO_MEMORY;
+		goto error_exit;
+	}
+
+	/*
+	 * Execute the "global" _INI method that may appear at the root. This
+	 * support is provided for Windows compatibility (Vista+) and is not
+	 * part of the ACPI specification.
+	 */
+	info.evaluate_info->prefix_node = acpi_gbl_root_node;
+	info.evaluate_info->pathname = METHOD_NAME__INI;
+	info.evaluate_info->parameters = NULL;
+	info.evaluate_info->flags = ACPI_IGNORE_RETURN_VALUE;
+
+	status = acpi_ns_evaluate(info.evaluate_info);
+	if (ACPI_SUCCESS(status)) {
+		info.num_INI++;
+	}
+
+	/* Walk namespace to execute all _INIs on present devices */
+
+	status = acpi_ns_walk_namespace(ACPI_TYPE_ANY, ACPI_ROOT_OBJECT,
+					ACPI_UINT32_MAX, FALSE,
+					acpi_ns_init_one_device, NULL, &info,
+					NULL);
+
+	/*
+	 * Any _OSI requests should be completed by now. If the BIOS has
+	 * requested any Windows OSI strings, we will always truncate
+	 * I/O addresses to 16 bits -- for Windows compatibility.
+	 */
+	if (acpi_gbl_osi_data >= ACPI_OSI_WIN_2000) {
+		acpi_gbl_truncate_io_addresses = TRUE;
+	}
+
+	ACPI_FREE(info.evaluate_info);
+	if (ACPI_FAILURE(status)) {
+		goto error_exit;
+	}
+
+	ACPI_DEBUG_PRINT_RAW((ACPI_DB_INIT,
+			      "\nExecuted %u _INI methods requiring %u _STA executions "
+			      "(examined %u objects)\n",
+			      info.num_INI, info.num_STA, info.device_count));
+
+	return_ACPI_STATUS(status);
+
+      error_exit:
+	ACPI_EXCEPTION((AE_INFO, status, "During device initialization"));
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_init_one_object
+ *
+ * PARAMETERS:  obj_handle      - Node
+ *              Level           - Current nesting level
+ *              Context         - Points to a init info struct
+ *              return_value    - Not used
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Callback from acpi_walk_namespace. Invoked for every object
+ *              within the  namespace.
+ *
+ *              Currently, the only objects that require initialization are:
+ *              1) Methods
+ *              2) Op Regions
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ns_init_one_object(acpi_handle obj_handle,
+			u32 level, void *context, void **return_value)
+{
+	acpi_object_type type;
+	acpi_status status = AE_OK;
+	struct acpi_init_walk_info *info =
+	    (struct acpi_init_walk_info *)context;
+	struct acpi_namespace_node *node =
+	    (struct acpi_namespace_node *)obj_handle;
+	union acpi_operand_object *obj_desc;
+
+	ACPI_FUNCTION_NAME(ns_init_one_object);
+
+	info->object_count++;
+
+	/* And even then, we are only interested in a few object types */
+
+	type = acpi_ns_get_type(obj_handle);
+	obj_desc = acpi_ns_get_attached_object(node);
+	if (!obj_desc) {
+		return (AE_OK);
+	}
+
+	/* Increment counters for object types we are looking for */
+
+	switch (type) {
+	case ACPI_TYPE_REGION:
+		info->op_region_count++;
+		break;
+
+	case ACPI_TYPE_BUFFER_FIELD:
+		info->field_count++;
+		break;
+
+	case ACPI_TYPE_LOCAL_BANK_FIELD:
+		info->field_count++;
+		break;
+
+	case ACPI_TYPE_BUFFER:
+		info->buffer_count++;
+		break;
+
+	case ACPI_TYPE_PACKAGE:
+		info->package_count++;
+		break;
+
+	default:
+
+		/* No init required, just exit now */
+		return (AE_OK);
+	}
+
+	/* If the object is already initialized, nothing else to do */
+
+	if (obj_desc->common.flags & AOPOBJ_DATA_VALID) {
+		return (AE_OK);
+	}
+
+	/* Must lock the interpreter before executing AML code */
+
+	acpi_ex_enter_interpreter();
+
+	/*
+	 * Each of these types can contain executable AML code within the
+	 * declaration.
+	 */
+	switch (type) {
+	case ACPI_TYPE_REGION:
+
+		info->op_region_init++;
+		status = acpi_ds_get_region_arguments(obj_desc);
+		break;
+
+	case ACPI_TYPE_BUFFER_FIELD:
+
+		info->field_init++;
+		status = acpi_ds_get_buffer_field_arguments(obj_desc);
+		break;
+
+	case ACPI_TYPE_LOCAL_BANK_FIELD:
+
+		info->field_init++;
+		status = acpi_ds_get_bank_field_arguments(obj_desc);
+		break;
+
+	case ACPI_TYPE_BUFFER:
+
+		info->buffer_init++;
+		status = acpi_ds_get_buffer_arguments(obj_desc);
+		break;
+
+	case ACPI_TYPE_PACKAGE:
+
+		info->package_init++;
+		status = acpi_ds_get_package_arguments(obj_desc);
+		break;
+
+	default:
+		/* No other types can get here */
+		break;
+	}
+
+	if (ACPI_FAILURE(status)) {
+		ACPI_EXCEPTION((AE_INFO, status,
+				"Could not execute arguments for [%4.4s] (%s)",
+				acpi_ut_get_node_name(node),
+				acpi_ut_get_type_name(type)));
+	}
+
+	/*
+	 * Print a dot for each object unless we are going to print the entire
+	 * pathname
+	 */
+	if (!(acpi_dbg_level & ACPI_LV_INIT_NAMES)) {
+		ACPI_DEBUG_PRINT_RAW((ACPI_DB_INIT, "."));
+	}
+
+	/*
+	 * We ignore errors from above, and always return OK, since we don't want
+	 * to abort the walk on any single error.
+	 */
+	acpi_ex_exit_interpreter();
+	return (AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_find_ini_methods
+ *
+ * PARAMETERS:  acpi_walk_callback
+ *
+ * RETURN:      acpi_status
+ *
+ * DESCRIPTION: Called during namespace walk. Finds objects named _INI under
+ *              device/processor/thermal objects, and marks the entire subtree
+ *              with a SUBTREE_HAS_INI flag. This flag is used during the
+ *              subsequent device initialization walk to avoid entire subtrees
+ *              that do not contain an _INI.
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ns_find_ini_methods(acpi_handle obj_handle,
+			 u32 nesting_level, void *context, void **return_value)
+{
+	struct acpi_device_walk_info *info =
+	    ACPI_CAST_PTR(struct acpi_device_walk_info, context);
+	struct acpi_namespace_node *node;
+	struct acpi_namespace_node *parent_node;
+
+	/* Keep count of device/processor/thermal objects */
+
+	node = ACPI_CAST_PTR(struct acpi_namespace_node, obj_handle);
+	if ((node->type == ACPI_TYPE_DEVICE) ||
+	    (node->type == ACPI_TYPE_PROCESSOR) ||
+	    (node->type == ACPI_TYPE_THERMAL)) {
+		info->device_count++;
+		return (AE_OK);
+	}
+
+	/* We are only looking for methods named _INI */
+
+	if (!ACPI_COMPARE_NAME(node->name.ascii, METHOD_NAME__INI)) {
+		return (AE_OK);
+	}
+
+	/*
+	 * The only _INI methods that we care about are those that are
+	 * present under Device, Processor, and Thermal objects.
+	 */
+	parent_node = node->parent;
+	switch (parent_node->type) {
+	case ACPI_TYPE_DEVICE:
+	case ACPI_TYPE_PROCESSOR:
+	case ACPI_TYPE_THERMAL:
+
+		/* Mark parent and bubble up the INI present flag to the root */
+
+		while (parent_node) {
+			parent_node->flags |= ANOBJ_SUBTREE_HAS_INI;
+			parent_node = parent_node->parent;
+		}
+		break;
+
+	default:
+		break;
+	}
+
+	return (AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_init_one_device
+ *
+ * PARAMETERS:  acpi_walk_callback
+ *
+ * RETURN:      acpi_status
+ *
+ * DESCRIPTION: This is called once per device soon after ACPI is enabled
+ *              to initialize each device. It determines if the device is
+ *              present, and if so, calls _INI.
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ns_init_one_device(acpi_handle obj_handle,
+			u32 nesting_level, void *context, void **return_value)
+{
+	struct acpi_device_walk_info *walk_info =
+	    ACPI_CAST_PTR(struct acpi_device_walk_info, context);
+	struct acpi_evaluate_info *info = walk_info->evaluate_info;
+	u32 flags;
+	acpi_status status;
+	struct acpi_namespace_node *device_node;
+
+	ACPI_FUNCTION_TRACE(ns_init_one_device);
+
+	/* We are interested in Devices, Processors and thermal_zones only */
+
+	device_node = ACPI_CAST_PTR(struct acpi_namespace_node, obj_handle);
+	if ((device_node->type != ACPI_TYPE_DEVICE) &&
+	    (device_node->type != ACPI_TYPE_PROCESSOR) &&
+	    (device_node->type != ACPI_TYPE_THERMAL)) {
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	/*
+	 * Because of an earlier namespace analysis, all subtrees that contain an
+	 * _INI method are tagged.
+	 *
+	 * If this device subtree does not contain any _INI methods, we
+	 * can exit now and stop traversing this entire subtree.
+	 */
+	if (!(device_node->flags & ANOBJ_SUBTREE_HAS_INI)) {
+		return_ACPI_STATUS(AE_CTRL_DEPTH);
+	}
+
+	/*
+	 * Run _STA to determine if this device is present and functioning. We
+	 * must know this information for two important reasons (from ACPI spec):
+	 *
+	 * 1) We can only run _INI if the device is present.
+	 * 2) We must abort the device tree walk on this subtree if the device is
+	 *    not present and is not functional (we will not examine the children)
+	 *
+	 * The _STA method is not required to be present under the device, we
+	 * assume the device is present if _STA does not exist.
+	 */
+	ACPI_DEBUG_EXEC(acpi_ut_display_init_pathname
+			(ACPI_TYPE_METHOD, device_node, METHOD_NAME__STA));
+
+	status = acpi_ut_execute_STA(device_node, &flags);
+	if (ACPI_FAILURE(status)) {
+
+		/* Ignore error and move on to next device */
+
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	/*
+	 * Flags == -1 means that _STA was not found. In this case, we assume that
+	 * the device is both present and functional.
+	 *
+	 * From the ACPI spec, description of _STA:
+	 *
+	 * "If a device object (including the processor object) does not have an
+	 * _STA object, then OSPM assumes that all of the above bits are set (in
+	 * other words, the device is present, ..., and functioning)"
+	 */
+	if (flags != ACPI_UINT32_MAX) {
+		walk_info->num_STA++;
+	}
+
+	/*
+	 * Examine the PRESENT and FUNCTIONING status bits
+	 *
+	 * Note: ACPI spec does not seem to specify behavior for the present but
+	 * not functioning case, so we assume functioning if present.
+	 */
+	if (!(flags & ACPI_STA_DEVICE_PRESENT)) {
+
+		/* Device is not present, we must examine the Functioning bit */
+
+		if (flags & ACPI_STA_DEVICE_FUNCTIONING) {
+			/*
+			 * Device is not present but is "functioning". In this case,
+			 * we will not run _INI, but we continue to examine the children
+			 * of this device.
+			 *
+			 * From the ACPI spec, description of _STA: (Note - no mention
+			 * of whether to run _INI or not on the device in question)
+			 *
+			 * "_STA may return bit 0 clear (not present) with bit 3 set
+			 * (device is functional). This case is used to indicate a valid
+			 * device for which no device driver should be loaded (for example,
+			 * a bridge device.) Children of this device may be present and
+			 * valid. OSPM should continue enumeration below a device whose
+			 * _STA returns this bit combination"
+			 */
+			return_ACPI_STATUS(AE_OK);
+		} else {
+			/*
+			 * Device is not present and is not functioning. We must abort the
+			 * walk of this subtree immediately -- don't look at the children
+			 * of such a device.
+			 *
+			 * From the ACPI spec, description of _INI:
+			 *
+			 * "If the _STA method indicates that the device is not present,
+			 * OSPM will not run the _INI and will not examine the children
+			 * of the device for _INI methods"
+			 */
+			return_ACPI_STATUS(AE_CTRL_DEPTH);
+		}
+	}
+
+	/*
+	 * The device is present or is assumed present if no _STA exists.
+	 * Run the _INI if it exists (not required to exist)
+	 *
+	 * Note: We know there is an _INI within this subtree, but it may not be
+	 * under this particular device, it may be lower in the branch.
+	 */
+	ACPI_DEBUG_EXEC(acpi_ut_display_init_pathname
+			(ACPI_TYPE_METHOD, device_node, METHOD_NAME__INI));
+
+	info->prefix_node = device_node;
+	info->pathname = METHOD_NAME__INI;
+	info->parameters = NULL;
+	info->flags = ACPI_IGNORE_RETURN_VALUE;
+
+	status = acpi_ns_evaluate(info);
+	if (ACPI_SUCCESS(status)) {
+		walk_info->num_INI++;
+
+		if ((acpi_dbg_level <= ACPI_LV_ALL_EXCEPTIONS) &&
+		    (!(acpi_dbg_level & ACPI_LV_INFO))) {
+			ACPI_DEBUG_PRINT_RAW((ACPI_DB_INIT, "."));
+		}
+	}
+#ifdef ACPI_DEBUG_OUTPUT
+	else if (status != AE_NOT_FOUND) {
+
+		/* Ignore error and move on to next device */
+
+		char *scope_name =
+		    acpi_ns_get_external_pathname(info->resolved_node);
+
+		ACPI_EXCEPTION((AE_INFO, status, "during %s._INI execution",
+				scope_name));
+		ACPI_FREE(scope_name);
+	}
+#endif
+
+	/* Ignore errors from above */
+
+	status = AE_OK;
+
+	/*
+	 * The _INI method has been run if present; call the Global Initialization
+	 * Handler for this device.
+	 */
+	if (acpi_gbl_init_handler) {
+		status =
+		    acpi_gbl_init_handler(device_node, ACPI_INIT_DEVICE_INI);
+	}
+
+	return_ACPI_STATUS(status);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nsload.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nsload.c
new file mode 100644
index 00000000..5cbf15ff
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nsload.c
@@ -0,0 +1,314 @@
+/******************************************************************************
+ *
+ * Module Name: nsload - namespace loading/expanding/contracting procedures
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acnamesp.h"
+#include "acdispat.h"
+#include "actables.h"
+
+#define _COMPONENT          ACPI_NAMESPACE
+ACPI_MODULE_NAME("nsload")
+
+/* Local prototypes */
+#ifdef ACPI_FUTURE_IMPLEMENTATION
+acpi_status acpi_ns_unload_namespace(acpi_handle handle);
+
+static acpi_status acpi_ns_delete_subtree(acpi_handle start_handle);
+#endif
+
+#ifndef ACPI_NO_METHOD_EXECUTION
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_load_table
+ *
+ * PARAMETERS:  table_index     - Index for table to be loaded
+ *              Node            - Owning NS node
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Load one ACPI table into the namespace
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ns_load_table(u32 table_index, struct acpi_namespace_node *node)
+{
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(ns_load_table);
+
+	/*
+	 * Parse the table and load the namespace with all named
+	 * objects found within.  Control methods are NOT parsed
+	 * at this time.  In fact, the control methods cannot be
+	 * parsed until the entire namespace is loaded, because
+	 * if a control method makes a forward reference (call)
+	 * to another control method, we can't continue parsing
+	 * because we don't know how many arguments to parse next!
+	 */
+	status = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/* If table already loaded into namespace, just return */
+
+	if (acpi_tb_is_table_loaded(table_index)) {
+		status = AE_ALREADY_EXISTS;
+		goto unlock;
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+			  "**** Loading table into namespace ****\n"));
+
+	status = acpi_tb_allocate_owner_id(table_index);
+	if (ACPI_FAILURE(status)) {
+		goto unlock;
+	}
+
+	status = acpi_ns_parse_table(table_index, node);
+	if (ACPI_SUCCESS(status)) {
+		acpi_tb_set_table_loaded_flag(table_index, TRUE);
+	} else {
+		(void)acpi_tb_release_owner_id(table_index);
+	}
+
+      unlock:
+	(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);
+
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/*
+	 * Now we can parse the control methods.  We always parse
+	 * them here for a sanity check, and if configured for
+	 * just-in-time parsing, we delete the control method
+	 * parse trees.
+	 */
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+			  "**** Begin Table Method Parsing and Object Initialization\n"));
+
+	status = acpi_ds_initialize_objects(table_index, node);
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+			  "**** Completed Table Method Parsing and Object Initialization\n"));
+
+	return_ACPI_STATUS(status);
+}
+
+#ifdef ACPI_OBSOLETE_FUNCTIONS
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_load_namespace
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Load the name space from what ever is pointed to by DSDT.
+ *              (DSDT points to either the BIOS or a buffer.)
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ns_load_namespace(void)
+{
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(acpi_load_name_space);
+
+	/* There must be at least a DSDT installed */
+
+	if (acpi_gbl_DSDT == NULL) {
+		ACPI_ERROR((AE_INFO, "DSDT is not in memory"));
+		return_ACPI_STATUS(AE_NO_ACPI_TABLES);
+	}
+
+	/*
+	 * Load the namespace.  The DSDT is required,
+	 * but the SSDT and PSDT tables are optional.
+	 */
+	status = acpi_ns_load_table_by_type(ACPI_TABLE_ID_DSDT);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/* Ignore exceptions from these */
+
+	(void)acpi_ns_load_table_by_type(ACPI_TABLE_ID_SSDT);
+	(void)acpi_ns_load_table_by_type(ACPI_TABLE_ID_PSDT);
+
+	ACPI_DEBUG_PRINT_RAW((ACPI_DB_INIT,
+			      "ACPI Namespace successfully loaded at root %p\n",
+			      acpi_gbl_root_node));
+
+	return_ACPI_STATUS(status);
+}
+#endif
+
+#ifdef ACPI_FUTURE_IMPLEMENTATION
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_delete_subtree
+ *
+ * PARAMETERS:  start_handle        - Handle in namespace where search begins
+ *
+ * RETURNS      Status
+ *
+ * DESCRIPTION: Walks the namespace starting at the given handle and deletes
+ *              all objects, entries, and scopes in the entire subtree.
+ *
+ *              Namespace/Interpreter should be locked or the subsystem should
+ *              be in shutdown before this routine is called.
+ *
+ ******************************************************************************/
+
+static acpi_status acpi_ns_delete_subtree(acpi_handle start_handle)
+{
+	acpi_status status;
+	acpi_handle child_handle;
+	acpi_handle parent_handle;
+	acpi_handle next_child_handle;
+	acpi_handle dummy;
+	u32 level;
+
+	ACPI_FUNCTION_TRACE(ns_delete_subtree);
+
+	parent_handle = start_handle;
+	child_handle = NULL;
+	level = 1;
+
+	/*
+	 * Traverse the tree of objects until we bubble back up
+	 * to where we started.
+	 */
+	while (level > 0) {
+
+		/* Attempt to get the next object in this scope */
+
+		status = acpi_get_next_object(ACPI_TYPE_ANY, parent_handle,
+					      child_handle, &next_child_handle);
+
+		child_handle = next_child_handle;
+
+		/* Did we get a new object? */
+
+		if (ACPI_SUCCESS(status)) {
+
+			/* Check if this object has any children */
+
+			if (ACPI_SUCCESS
+			    (acpi_get_next_object
+			     (ACPI_TYPE_ANY, child_handle, NULL, &dummy))) {
+				/*
+				 * There is at least one child of this object,
+				 * visit the object
+				 */
+				level++;
+				parent_handle = child_handle;
+				child_handle = NULL;
+			}
+		} else {
+			/*
+			 * No more children in this object, go back up to
+			 * the object's parent
+			 */
+			level--;
+
+			/* Delete all children now */
+
+			acpi_ns_delete_children(child_handle);
+
+			child_handle = parent_handle;
+			status = acpi_get_parent(parent_handle, &parent_handle);
+			if (ACPI_FAILURE(status)) {
+				return_ACPI_STATUS(status);
+			}
+		}
+	}
+
+	/* Now delete the starting object, and we are done */
+
+	acpi_ns_remove_node(child_handle);
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ *  FUNCTION:       acpi_ns_unload_name_space
+ *
+ *  PARAMETERS:     Handle          - Root of namespace subtree to be deleted
+ *
+ *  RETURN:         Status
+ *
+ *  DESCRIPTION:    Shrinks the namespace, typically in response to an undocking
+ *                  event.  Deletes an entire subtree starting from (and
+ *                  including) the given handle.
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ns_unload_namespace(acpi_handle handle)
+{
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(ns_unload_name_space);
+
+	/* Parameter validation */
+
+	if (!acpi_gbl_root_node) {
+		return_ACPI_STATUS(AE_NO_NAMESPACE);
+	}
+
+	if (!handle) {
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	/* This function does the real work */
+
+	status = acpi_ns_delete_subtree(handle);
+
+	return_ACPI_STATUS(status);
+}
+#endif
+#endif
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nsnames.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nsnames.c
new file mode 100644
index 00000000..d260e6b5
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nsnames.c
@@ -0,0 +1,266 @@
+/*******************************************************************************
+ *
+ * Module Name: nsnames - Name manipulation and search
+ *
+ ******************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "amlcode.h"
+#include "acnamesp.h"
+
+#define _COMPONENT          ACPI_NAMESPACE
+ACPI_MODULE_NAME("nsnames")
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_build_external_path
+ *
+ * PARAMETERS:  Node            - NS node whose pathname is needed
+ *              Size            - Size of the pathname
+ *              *name_buffer    - Where to return the pathname
+ *
+ * RETURN:      Status
+ *              Places the pathname into the name_buffer, in external format
+ *              (name segments separated by path separators)
+ *
+ * DESCRIPTION: Generate a full pathaname
+ *
+ ******************************************************************************/
+acpi_status
+acpi_ns_build_external_path(struct acpi_namespace_node *node,
+			    acpi_size size, char *name_buffer)
+{
+	acpi_size index;
+	struct acpi_namespace_node *parent_node;
+
+	ACPI_FUNCTION_ENTRY();
+
+	/* Special case for root */
+
+	index = size - 1;
+	if (index < ACPI_NAME_SIZE) {
+		name_buffer[0] = AML_ROOT_PREFIX;
+		name_buffer[1] = 0;
+		return (AE_OK);
+	}
+
+	/* Store terminator byte, then build name backwards */
+
+	parent_node = node;
+	name_buffer[index] = 0;
+
+	while ((index > ACPI_NAME_SIZE) && (parent_node != acpi_gbl_root_node)) {
+		index -= ACPI_NAME_SIZE;
+
+		/* Put the name into the buffer */
+
+		ACPI_MOVE_32_TO_32((name_buffer + index), &parent_node->name);
+		parent_node = parent_node->parent;
+
+		/* Prefix name with the path separator */
+
+		index--;
+		name_buffer[index] = ACPI_PATH_SEPARATOR;
+	}
+
+	/* Overwrite final separator with the root prefix character */
+
+	name_buffer[index] = AML_ROOT_PREFIX;
+
+	if (index != 0) {
+		ACPI_ERROR((AE_INFO,
+			    "Could not construct external pathname; index=%u, size=%u, Path=%s",
+			    (u32)index, (u32)size, &name_buffer[size]));
+
+		return (AE_BAD_PARAMETER);
+	}
+
+	return (AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_get_external_pathname
+ *
+ * PARAMETERS:  Node            - Namespace node whose pathname is needed
+ *
+ * RETURN:      Pointer to storage containing the fully qualified name of
+ *              the node, In external format (name segments separated by path
+ *              separators.)
+ *
+ * DESCRIPTION: Used to obtain the full pathname to a namespace node, usually
+ *              for error and debug statements.
+ *
+ ******************************************************************************/
+
+char *acpi_ns_get_external_pathname(struct acpi_namespace_node *node)
+{
+	acpi_status status;
+	char *name_buffer;
+	acpi_size size;
+
+	ACPI_FUNCTION_TRACE_PTR(ns_get_external_pathname, node);
+
+	/* Calculate required buffer size based on depth below root */
+
+	size = acpi_ns_get_pathname_length(node);
+	if (!size) {
+		return_PTR(NULL);
+	}
+
+	/* Allocate a buffer to be returned to caller */
+
+	name_buffer = ACPI_ALLOCATE_ZEROED(size);
+	if (!name_buffer) {
+		ACPI_ERROR((AE_INFO, "Could not allocate %u bytes", (u32)size));
+		return_PTR(NULL);
+	}
+
+	/* Build the path in the allocated buffer */
+
+	status = acpi_ns_build_external_path(node, size, name_buffer);
+	if (ACPI_FAILURE(status)) {
+		ACPI_FREE(name_buffer);
+		return_PTR(NULL);
+	}
+
+	return_PTR(name_buffer);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_get_pathname_length
+ *
+ * PARAMETERS:  Node        - Namespace node
+ *
+ * RETURN:      Length of path, including prefix
+ *
+ * DESCRIPTION: Get the length of the pathname string for this node
+ *
+ ******************************************************************************/
+
+acpi_size acpi_ns_get_pathname_length(struct acpi_namespace_node *node)
+{
+	acpi_size size;
+	struct acpi_namespace_node *next_node;
+
+	ACPI_FUNCTION_ENTRY();
+
+	/*
+	 * Compute length of pathname as 5 * number of name segments.
+	 * Go back up the parent tree to the root
+	 */
+	size = 0;
+	next_node = node;
+
+	while (next_node && (next_node != acpi_gbl_root_node)) {
+		if (ACPI_GET_DESCRIPTOR_TYPE(next_node) != ACPI_DESC_TYPE_NAMED) {
+			ACPI_ERROR((AE_INFO,
+				    "Invalid Namespace Node (%p) while traversing namespace",
+				    next_node));
+			return 0;
+		}
+		size += ACPI_PATH_SEGMENT_LENGTH;
+		next_node = next_node->parent;
+	}
+
+	if (!size) {
+		size = 1;	/* Root node case */
+	}
+
+	return (size + 1);	/* +1 for null string terminator */
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_handle_to_pathname
+ *
+ * PARAMETERS:  target_handle           - Handle of named object whose name is
+ *                                        to be found
+ *              Buffer                  - Where the pathname is returned
+ *
+ * RETURN:      Status, Buffer is filled with pathname if status is AE_OK
+ *
+ * DESCRIPTION: Build and return a full namespace pathname
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ns_handle_to_pathname(acpi_handle target_handle,
+			   struct acpi_buffer * buffer)
+{
+	acpi_status status;
+	struct acpi_namespace_node *node;
+	acpi_size required_size;
+
+	ACPI_FUNCTION_TRACE_PTR(ns_handle_to_pathname, target_handle);
+
+	node = acpi_ns_validate_handle(target_handle);
+	if (!node) {
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	/* Determine size required for the caller buffer */
+
+	required_size = acpi_ns_get_pathname_length(node);
+	if (!required_size) {
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	/* Validate/Allocate/Clear caller buffer */
+
+	status = acpi_ut_initialize_buffer(buffer, required_size);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/* Build the path in the caller buffer */
+
+	status =
+	    acpi_ns_build_external_path(node, required_size, buffer->pointer);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_EXEC, "%s [%X]\n",
+			  (char *)buffer->pointer, (u32)required_size));
+	return_ACPI_STATUS(AE_OK);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nsobject.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nsobject.c
new file mode 100644
index 00000000..065de9d9
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nsobject.c
@@ -0,0 +1,448 @@
+/*******************************************************************************
+ *
+ * Module Name: nsobject - Utilities for objects attached to namespace
+ *                         table entries
+ *
+ ******************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acnamesp.h"
+
+#define _COMPONENT          ACPI_NAMESPACE
+ACPI_MODULE_NAME("nsobject")
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_attach_object
+ *
+ * PARAMETERS:  Node                - Parent Node
+ *              Object              - Object to be attached
+ *              Type                - Type of object, or ACPI_TYPE_ANY if not
+ *                                    known
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Record the given object as the value associated with the
+ *              name whose acpi_handle is passed.  If Object is NULL
+ *              and Type is ACPI_TYPE_ANY, set the name as having no value.
+ *              Note: Future may require that the Node->Flags field be passed
+ *              as a parameter.
+ *
+ * MUTEX:       Assumes namespace is locked
+ *
+ ******************************************************************************/
+acpi_status
+acpi_ns_attach_object(struct acpi_namespace_node *node,
+		      union acpi_operand_object *object, acpi_object_type type)
+{
+	union acpi_operand_object *obj_desc;
+	union acpi_operand_object *last_obj_desc;
+	acpi_object_type object_type = ACPI_TYPE_ANY;
+
+	ACPI_FUNCTION_TRACE(ns_attach_object);
+
+	/*
+	 * Parameter validation
+	 */
+	if (!node) {
+
+		/* Invalid handle */
+
+		ACPI_ERROR((AE_INFO, "Null NamedObj handle"));
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	if (!object && (ACPI_TYPE_ANY != type)) {
+
+		/* Null object */
+
+		ACPI_ERROR((AE_INFO,
+			    "Null object, but type not ACPI_TYPE_ANY"));
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	if (ACPI_GET_DESCRIPTOR_TYPE(node) != ACPI_DESC_TYPE_NAMED) {
+
+		/* Not a name handle */
+
+		ACPI_ERROR((AE_INFO, "Invalid handle %p [%s]",
+			    node, acpi_ut_get_descriptor_name(node)));
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	/* Check if this object is already attached */
+
+	if (node->object == object) {
+		ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
+				  "Obj %p already installed in NameObj %p\n",
+				  object, node));
+
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	/* If null object, we will just install it */
+
+	if (!object) {
+		obj_desc = NULL;
+		object_type = ACPI_TYPE_ANY;
+	}
+
+	/*
+	 * If the source object is a namespace Node with an attached object,
+	 * we will use that (attached) object
+	 */
+	else if ((ACPI_GET_DESCRIPTOR_TYPE(object) == ACPI_DESC_TYPE_NAMED) &&
+		 ((struct acpi_namespace_node *)object)->object) {
+		/*
+		 * Value passed is a name handle and that name has a
+		 * non-null value.  Use that name's value and type.
+		 */
+		obj_desc = ((struct acpi_namespace_node *)object)->object;
+		object_type = ((struct acpi_namespace_node *)object)->type;
+	}
+
+	/*
+	 * Otherwise, we will use the parameter object, but we must type
+	 * it first
+	 */
+	else {
+		obj_desc = (union acpi_operand_object *)object;
+
+		/* Use the given type */
+
+		object_type = type;
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_EXEC, "Installing %p into Node %p [%4.4s]\n",
+			  obj_desc, node, acpi_ut_get_node_name(node)));
+
+	/* Detach an existing attached object if present */
+
+	if (node->object) {
+		acpi_ns_detach_object(node);
+	}
+
+	if (obj_desc) {
+		/*
+		 * Must increment the new value's reference count
+		 * (if it is an internal object)
+		 */
+		acpi_ut_add_reference(obj_desc);
+
+		/*
+		 * Handle objects with multiple descriptors - walk
+		 * to the end of the descriptor list
+		 */
+		last_obj_desc = obj_desc;
+		while (last_obj_desc->common.next_object) {
+			last_obj_desc = last_obj_desc->common.next_object;
+		}
+
+		/* Install the object at the front of the object list */
+
+		last_obj_desc->common.next_object = node->object;
+	}
+
+	node->type = (u8)object_type;
+	node->object = obj_desc;
+
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_detach_object
+ *
+ * PARAMETERS:  Node           - A Namespace node whose object will be detached
+ *
+ * RETURN:      None.
+ *
+ * DESCRIPTION: Detach/delete an object associated with a namespace node.
+ *              if the object is an allocated object, it is freed.
+ *              Otherwise, the field is simply cleared.
+ *
+ ******************************************************************************/
+
+void acpi_ns_detach_object(struct acpi_namespace_node *node)
+{
+	union acpi_operand_object *obj_desc;
+
+	ACPI_FUNCTION_TRACE(ns_detach_object);
+
+	obj_desc = node->object;
+
+	if (!obj_desc || (obj_desc->common.type == ACPI_TYPE_LOCAL_DATA)) {
+		return_VOID;
+	}
+
+	if (node->flags & ANOBJ_ALLOCATED_BUFFER) {
+
+		/* Free the dynamic aml buffer */
+
+		if (obj_desc->common.type == ACPI_TYPE_METHOD) {
+			ACPI_FREE(obj_desc->method.aml_start);
+		}
+	}
+
+	/* Clear the entry in all cases */
+
+	node->object = NULL;
+	if (ACPI_GET_DESCRIPTOR_TYPE(obj_desc) == ACPI_DESC_TYPE_OPERAND) {
+		node->object = obj_desc->common.next_object;
+		if (node->object &&
+		    ((node->object)->common.type != ACPI_TYPE_LOCAL_DATA)) {
+			node->object = node->object->common.next_object;
+		}
+	}
+
+	/* Reset the node type to untyped */
+
+	node->type = ACPI_TYPE_ANY;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_NAMES, "Node %p [%4.4s] Object %p\n",
+			  node, acpi_ut_get_node_name(node), obj_desc));
+
+	/* Remove one reference on the object (and all subobjects) */
+
+	acpi_ut_remove_reference(obj_desc);
+	return_VOID;
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_get_attached_object
+ *
+ * PARAMETERS:  Node             - Namespace node
+ *
+ * RETURN:      Current value of the object field from the Node whose
+ *              handle is passed
+ *
+ * DESCRIPTION: Obtain the object attached to a namespace node.
+ *
+ ******************************************************************************/
+
+union acpi_operand_object *acpi_ns_get_attached_object(struct
+						       acpi_namespace_node
+						       *node)
+{
+	ACPI_FUNCTION_TRACE_PTR(ns_get_attached_object, node);
+
+	if (!node) {
+		ACPI_WARNING((AE_INFO, "Null Node ptr"));
+		return_PTR(NULL);
+	}
+
+	if (!node->object ||
+	    ((ACPI_GET_DESCRIPTOR_TYPE(node->object) != ACPI_DESC_TYPE_OPERAND)
+	     && (ACPI_GET_DESCRIPTOR_TYPE(node->object) !=
+		 ACPI_DESC_TYPE_NAMED))
+	    || ((node->object)->common.type == ACPI_TYPE_LOCAL_DATA)) {
+		return_PTR(NULL);
+	}
+
+	return_PTR(node->object);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_get_secondary_object
+ *
+ * PARAMETERS:  Node             - Namespace node
+ *
+ * RETURN:      Current value of the object field from the Node whose
+ *              handle is passed.
+ *
+ * DESCRIPTION: Obtain a secondary object associated with a namespace node.
+ *
+ ******************************************************************************/
+
+union acpi_operand_object *acpi_ns_get_secondary_object(union
+							acpi_operand_object
+							*obj_desc)
+{
+	ACPI_FUNCTION_TRACE_PTR(ns_get_secondary_object, obj_desc);
+
+	if ((!obj_desc) ||
+	    (obj_desc->common.type == ACPI_TYPE_LOCAL_DATA) ||
+	    (!obj_desc->common.next_object) ||
+	    ((obj_desc->common.next_object)->common.type ==
+	     ACPI_TYPE_LOCAL_DATA)) {
+		return_PTR(NULL);
+	}
+
+	return_PTR(obj_desc->common.next_object);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_attach_data
+ *
+ * PARAMETERS:  Node            - Namespace node
+ *              Handler         - Handler to be associated with the data
+ *              Data            - Data to be attached
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Low-level attach data.  Create and attach a Data object.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ns_attach_data(struct acpi_namespace_node *node,
+		    acpi_object_handler handler, void *data)
+{
+	union acpi_operand_object *prev_obj_desc;
+	union acpi_operand_object *obj_desc;
+	union acpi_operand_object *data_desc;
+
+	/* We only allow one attachment per handler */
+
+	prev_obj_desc = NULL;
+	obj_desc = node->object;
+	while (obj_desc) {
+		if ((obj_desc->common.type == ACPI_TYPE_LOCAL_DATA) &&
+		    (obj_desc->data.handler == handler)) {
+			return (AE_ALREADY_EXISTS);
+		}
+
+		prev_obj_desc = obj_desc;
+		obj_desc = obj_desc->common.next_object;
+	}
+
+	/* Create an internal object for the data */
+
+	data_desc = acpi_ut_create_internal_object(ACPI_TYPE_LOCAL_DATA);
+	if (!data_desc) {
+		return (AE_NO_MEMORY);
+	}
+
+	data_desc->data.handler = handler;
+	data_desc->data.pointer = data;
+
+	/* Install the data object */
+
+	if (prev_obj_desc) {
+		prev_obj_desc->common.next_object = data_desc;
+	} else {
+		node->object = data_desc;
+	}
+
+	return (AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_detach_data
+ *
+ * PARAMETERS:  Node            - Namespace node
+ *              Handler         - Handler associated with the data
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Low-level detach data.  Delete the data node, but the caller
+ *              is responsible for the actual data.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ns_detach_data(struct acpi_namespace_node * node,
+		    acpi_object_handler handler)
+{
+	union acpi_operand_object *obj_desc;
+	union acpi_operand_object *prev_obj_desc;
+
+	prev_obj_desc = NULL;
+	obj_desc = node->object;
+	while (obj_desc) {
+		if ((obj_desc->common.type == ACPI_TYPE_LOCAL_DATA) &&
+		    (obj_desc->data.handler == handler)) {
+			if (prev_obj_desc) {
+				prev_obj_desc->common.next_object =
+				    obj_desc->common.next_object;
+			} else {
+				node->object = obj_desc->common.next_object;
+			}
+
+			acpi_ut_remove_reference(obj_desc);
+			return (AE_OK);
+		}
+
+		prev_obj_desc = obj_desc;
+		obj_desc = obj_desc->common.next_object;
+	}
+
+	return (AE_NOT_FOUND);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_get_attached_data
+ *
+ * PARAMETERS:  Node            - Namespace node
+ *              Handler         - Handler associated with the data
+ *              Data            - Where the data is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Low level interface to obtain data previously associated with
+ *              a namespace node.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ns_get_attached_data(struct acpi_namespace_node * node,
+			  acpi_object_handler handler, void **data)
+{
+	union acpi_operand_object *obj_desc;
+
+	obj_desc = node->object;
+	while (obj_desc) {
+		if ((obj_desc->common.type == ACPI_TYPE_LOCAL_DATA) &&
+		    (obj_desc->data.handler == handler)) {
+			*data = obj_desc->data.pointer;
+			return (AE_OK);
+		}
+
+		obj_desc = obj_desc->common.next_object;
+	}
+
+	return (AE_NOT_FOUND);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nsparse.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nsparse.c
new file mode 100644
index 00000000..229fffbe
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nsparse.c
@@ -0,0 +1,202 @@
+/******************************************************************************
+ *
+ * Module Name: nsparse - namespace interface to AML parser
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acnamesp.h"
+#include "acparser.h"
+#include "acdispat.h"
+#include "actables.h"
+
+#define _COMPONENT          ACPI_NAMESPACE
+ACPI_MODULE_NAME("nsparse")
+
+/*******************************************************************************
+ *
+ * FUNCTION:    ns_one_complete_parse
+ *
+ * PARAMETERS:  pass_number             - 1 or 2
+ *              table_desc              - The table to be parsed.
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Perform one complete parse of an ACPI/AML table.
+ *
+ ******************************************************************************/
+acpi_status
+acpi_ns_one_complete_parse(u32 pass_number,
+			   u32 table_index,
+			   struct acpi_namespace_node *start_node)
+{
+	union acpi_parse_object *parse_root;
+	acpi_status status;
+	u32 aml_length;
+	u8 *aml_start;
+	struct acpi_walk_state *walk_state;
+	struct acpi_table_header *table;
+	acpi_owner_id owner_id;
+
+	ACPI_FUNCTION_TRACE(ns_one_complete_parse);
+
+	status = acpi_tb_get_owner_id(table_index, &owner_id);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/* Create and init a Root Node */
+
+	parse_root = acpi_ps_create_scope_op();
+	if (!parse_root) {
+		return_ACPI_STATUS(AE_NO_MEMORY);
+	}
+
+	/* Create and initialize a new walk state */
+
+	walk_state = acpi_ds_create_walk_state(owner_id, NULL, NULL, NULL);
+	if (!walk_state) {
+		acpi_ps_free_op(parse_root);
+		return_ACPI_STATUS(AE_NO_MEMORY);
+	}
+
+	status = acpi_get_table_by_index(table_index, &table);
+	if (ACPI_FAILURE(status)) {
+		acpi_ds_delete_walk_state(walk_state);
+		acpi_ps_free_op(parse_root);
+		return_ACPI_STATUS(status);
+	}
+
+	/* Table must consist of at least a complete header */
+
+	if (table->length < sizeof(struct acpi_table_header)) {
+		status = AE_BAD_HEADER;
+	} else {
+		aml_start = (u8 *)table + sizeof(struct acpi_table_header);
+		aml_length = table->length - sizeof(struct acpi_table_header);
+		status = acpi_ds_init_aml_walk(walk_state, parse_root, NULL,
+					       aml_start, aml_length, NULL,
+					       (u8)pass_number);
+	}
+
+	if (ACPI_FAILURE(status)) {
+		acpi_ds_delete_walk_state(walk_state);
+		goto cleanup;
+	}
+
+	/* start_node is the default location to load the table */
+
+	if (start_node && start_node != acpi_gbl_root_node) {
+		status =
+		    acpi_ds_scope_stack_push(start_node, ACPI_TYPE_METHOD,
+					     walk_state);
+		if (ACPI_FAILURE(status)) {
+			acpi_ds_delete_walk_state(walk_state);
+			goto cleanup;
+		}
+	}
+
+	/* Parse the AML */
+
+	ACPI_DEBUG_PRINT((ACPI_DB_PARSE, "*PARSE* pass %u parse\n",
+			  pass_number));
+	status = acpi_ps_parse_aml(walk_state);
+
+      cleanup:
+	acpi_ps_delete_parse_tree(parse_root);
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_parse_table
+ *
+ * PARAMETERS:  table_desc      - An ACPI table descriptor for table to parse
+ *              start_node      - Where to enter the table into the namespace
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Parse AML within an ACPI table and return a tree of ops
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ns_parse_table(u32 table_index, struct acpi_namespace_node *start_node)
+{
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(ns_parse_table);
+
+	/*
+	 * AML Parse, pass 1
+	 *
+	 * In this pass, we load most of the namespace.  Control methods
+	 * are not parsed until later.  A parse tree is not created.  Instead,
+	 * each Parser Op subtree is deleted when it is finished.  This saves
+	 * a great deal of memory, and allows a small cache of parse objects
+	 * to service the entire parse.  The second pass of the parse then
+	 * performs another complete parse of the AML.
+	 */
+	ACPI_DEBUG_PRINT((ACPI_DB_PARSE, "**** Start pass 1\n"));
+	status = acpi_ns_one_complete_parse(ACPI_IMODE_LOAD_PASS1,
+					    table_index, start_node);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/*
+	 * AML Parse, pass 2
+	 *
+	 * In this pass, we resolve forward references and other things
+	 * that could not be completed during the first pass.
+	 * Another complete parse of the AML is performed, but the
+	 * overhead of this is compensated for by the fact that the
+	 * parse objects are all cached.
+	 */
+	ACPI_DEBUG_PRINT((ACPI_DB_PARSE, "**** Start pass 2\n"));
+	status = acpi_ns_one_complete_parse(ACPI_IMODE_LOAD_PASS2,
+					    table_index, start_node);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	return_ACPI_STATUS(status);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nspredef.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nspredef.c
new file mode 100644
index 00000000..a6018100
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nspredef.c
@@ -0,0 +1,1172 @@
+/******************************************************************************
+ *
+ * Module Name: nspredef - Validation of ACPI predefined methods and objects
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#define ACPI_CREATE_PREDEFINED_TABLE
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acnamesp.h"
+#include "acpredef.h"
+
+#define _COMPONENT          ACPI_NAMESPACE
+ACPI_MODULE_NAME("nspredef")
+
+/*******************************************************************************
+ *
+ * This module validates predefined ACPI objects that appear in the namespace,
+ * at the time they are evaluated (via acpi_evaluate_object). The purpose of this
+ * validation is to detect problems with BIOS-exposed predefined ACPI objects
+ * before the results are returned to the ACPI-related drivers.
+ *
+ * There are several areas that are validated:
+ *
+ *  1) The number of input arguments as defined by the method/object in the
+ *      ASL is validated against the ACPI specification.
+ *  2) The type of the return object (if any) is validated against the ACPI
+ *      specification.
+ *  3) For returned package objects, the count of package elements is
+ *      validated, as well as the type of each package element. Nested
+ *      packages are supported.
+ *
+ * For any problems found, a warning message is issued.
+ *
+ ******************************************************************************/
+/* Local prototypes */
+static acpi_status
+acpi_ns_check_package(struct acpi_predefined_data *data,
+		      union acpi_operand_object **return_object_ptr);
+
+static acpi_status
+acpi_ns_check_package_list(struct acpi_predefined_data *data,
+			   const union acpi_predefined_info *package,
+			   union acpi_operand_object **elements, u32 count);
+
+static acpi_status
+acpi_ns_check_package_elements(struct acpi_predefined_data *data,
+			       union acpi_operand_object **elements,
+			       u8 type1,
+			       u32 count1,
+			       u8 type2, u32 count2, u32 start_index);
+
+static acpi_status
+acpi_ns_check_object_type(struct acpi_predefined_data *data,
+			  union acpi_operand_object **return_object_ptr,
+			  u32 expected_btypes, u32 package_index);
+
+static acpi_status
+acpi_ns_check_reference(struct acpi_predefined_data *data,
+			union acpi_operand_object *return_object);
+
+static void acpi_ns_get_expected_types(char *buffer, u32 expected_btypes);
+
+/*
+ * Names for the types that can be returned by the predefined objects.
+ * Used for warning messages. Must be in the same order as the ACPI_RTYPEs
+ */
+static const char *acpi_rtype_names[] = {
+	"/Integer",
+	"/String",
+	"/Buffer",
+	"/Package",
+	"/Reference",
+};
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_check_predefined_names
+ *
+ * PARAMETERS:  Node            - Namespace node for the method/object
+ *              user_param_count - Number of parameters actually passed
+ *              return_status   - Status from the object evaluation
+ *              return_object_ptr - Pointer to the object returned from the
+ *                                evaluation of a method or object
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Check an ACPI name for a match in the predefined name list.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ns_check_predefined_names(struct acpi_namespace_node *node,
+			       u32 user_param_count,
+			       acpi_status return_status,
+			       union acpi_operand_object **return_object_ptr)
+{
+	union acpi_operand_object *return_object = *return_object_ptr;
+	acpi_status status = AE_OK;
+	const union acpi_predefined_info *predefined;
+	char *pathname;
+	struct acpi_predefined_data *data;
+
+	/* Match the name for this method/object against the predefined list */
+
+	predefined = acpi_ns_check_for_predefined_name(node);
+
+	/* Get the full pathname to the object, for use in warning messages */
+
+	pathname = acpi_ns_get_external_pathname(node);
+	if (!pathname) {
+		return (AE_OK);	/* Could not get pathname, ignore */
+	}
+
+	/*
+	 * Check that the parameter count for this method matches the ASL
+	 * definition. For predefined names, ensure that both the caller and
+	 * the method itself are in accordance with the ACPI specification.
+	 */
+	acpi_ns_check_parameter_count(pathname, node, user_param_count,
+				      predefined);
+
+	/* If not a predefined name, we cannot validate the return object */
+
+	if (!predefined) {
+		goto cleanup;
+	}
+
+	/*
+	 * If the method failed or did not actually return an object, we cannot
+	 * validate the return object
+	 */
+	if ((return_status != AE_OK) && (return_status != AE_CTRL_RETURN_VALUE)) {
+		goto cleanup;
+	}
+
+	/*
+	 * If there is no return value, check if we require a return value for
+	 * this predefined name. Either one return value is expected, or none,
+	 * for both methods and other objects.
+	 *
+	 * Exit now if there is no return object. Warning if one was expected.
+	 */
+	if (!return_object) {
+		if ((predefined->info.expected_btypes) &&
+		    (!(predefined->info.expected_btypes & ACPI_RTYPE_NONE))) {
+			ACPI_WARN_PREDEFINED((AE_INFO, pathname,
+					      ACPI_WARN_ALWAYS,
+					      "Missing expected return value"));
+
+			status = AE_AML_NO_RETURN_VALUE;
+		}
+		goto cleanup;
+	}
+
+	/*
+	 * Return value validation and possible repair.
+	 *
+	 * 1) Don't perform return value validation/repair if this feature
+	 * has been disabled via a global option.
+	 *
+	 * 2) We have a return value, but if one wasn't expected, just exit,
+	 * this is not a problem. For example, if the "Implicit Return"
+	 * feature is enabled, methods will always return a value.
+	 *
+	 * 3) If the return value can be of any type, then we cannot perform
+	 * any validation, just exit.
+	 */
+	if (acpi_gbl_disable_auto_repair ||
+	    (!predefined->info.expected_btypes) ||
+	    (predefined->info.expected_btypes == ACPI_RTYPE_ALL)) {
+		goto cleanup;
+	}
+
+	/* Create the parameter data block for object validation */
+
+	data = ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_predefined_data));
+	if (!data) {
+		goto cleanup;
+	}
+	data->predefined = predefined;
+	data->node = node;
+	data->node_flags = node->flags;
+	data->pathname = pathname;
+
+	/*
+	 * Check that the type of the main return object is what is expected
+	 * for this predefined name
+	 */
+	status = acpi_ns_check_object_type(data, return_object_ptr,
+					   predefined->info.expected_btypes,
+					   ACPI_NOT_PACKAGE_ELEMENT);
+	if (ACPI_FAILURE(status)) {
+		goto exit;
+	}
+
+	/*
+	 * For returned Package objects, check the type of all sub-objects.
+	 * Note: Package may have been newly created by call above.
+	 */
+	if ((*return_object_ptr)->common.type == ACPI_TYPE_PACKAGE) {
+		data->parent_package = *return_object_ptr;
+		status = acpi_ns_check_package(data, return_object_ptr);
+		if (ACPI_FAILURE(status)) {
+			goto exit;
+		}
+	}
+
+	/*
+	 * The return object was OK, or it was successfully repaired above.
+	 * Now make some additional checks such as verifying that package
+	 * objects are sorted correctly (if required) or buffer objects have
+	 * the correct data width (bytes vs. dwords). These repairs are
+	 * performed on a per-name basis, i.e., the code is specific to
+	 * particular predefined names.
+	 */
+	status = acpi_ns_complex_repairs(data, node, status, return_object_ptr);
+
+      exit:
+	/*
+	 * If the object validation failed or if we successfully repaired one
+	 * or more objects, mark the parent node to suppress further warning
+	 * messages during the next evaluation of the same method/object.
+	 */
+	if (ACPI_FAILURE(status) || (data->flags & ACPI_OBJECT_REPAIRED)) {
+		node->flags |= ANOBJ_EVALUATED;
+	}
+	ACPI_FREE(data);
+
+      cleanup:
+	ACPI_FREE(pathname);
+	return (status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_check_parameter_count
+ *
+ * PARAMETERS:  Pathname        - Full pathname to the node (for error msgs)
+ *              Node            - Namespace node for the method/object
+ *              user_param_count - Number of args passed in by the caller
+ *              Predefined      - Pointer to entry in predefined name table
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Check that the declared (in ASL/AML) parameter count for a
+ *              predefined name is what is expected (i.e., what is defined in
+ *              the ACPI specification for this predefined name.)
+ *
+ ******************************************************************************/
+
+void
+acpi_ns_check_parameter_count(char *pathname,
+			      struct acpi_namespace_node *node,
+			      u32 user_param_count,
+			      const union acpi_predefined_info *predefined)
+{
+	u32 param_count;
+	u32 required_params_current;
+	u32 required_params_old;
+
+	/* Methods have 0-7 parameters. All other types have zero. */
+
+	param_count = 0;
+	if (node->type == ACPI_TYPE_METHOD) {
+		param_count = node->object->method.param_count;
+	}
+
+	if (!predefined) {
+		/*
+		 * Check the parameter count for non-predefined methods/objects.
+		 *
+		 * Warning if too few or too many arguments have been passed by the
+		 * caller. An incorrect number of arguments may not cause the method
+		 * to fail. However, the method will fail if there are too few
+		 * arguments and the method attempts to use one of the missing ones.
+		 */
+		if (user_param_count < param_count) {
+			ACPI_WARN_PREDEFINED((AE_INFO, pathname,
+					      ACPI_WARN_ALWAYS,
+					      "Insufficient arguments - needs %u, found %u",
+					      param_count, user_param_count));
+		} else if (user_param_count > param_count) {
+			ACPI_WARN_PREDEFINED((AE_INFO, pathname,
+					      ACPI_WARN_ALWAYS,
+					      "Excess arguments - needs %u, found %u",
+					      param_count, user_param_count));
+		}
+		return;
+	}
+
+	/*
+	 * Validate the user-supplied parameter count.
+	 * Allow two different legal argument counts (_SCP, etc.)
+	 */
+	required_params_current = predefined->info.param_count & 0x0F;
+	required_params_old = predefined->info.param_count >> 4;
+
+	if (user_param_count != ACPI_UINT32_MAX) {
+		if ((user_param_count != required_params_current) &&
+		    (user_param_count != required_params_old)) {
+			ACPI_WARN_PREDEFINED((AE_INFO, pathname,
+					      ACPI_WARN_ALWAYS,
+					      "Parameter count mismatch - "
+					      "caller passed %u, ACPI requires %u",
+					      user_param_count,
+					      required_params_current));
+		}
+	}
+
+	/*
+	 * Check that the ASL-defined parameter count is what is expected for
+	 * this predefined name (parameter count as defined by the ACPI
+	 * specification)
+	 */
+	if ((param_count != required_params_current) &&
+	    (param_count != required_params_old)) {
+		ACPI_WARN_PREDEFINED((AE_INFO, pathname, node->flags,
+				      "Parameter count mismatch - ASL declared %u, ACPI requires %u",
+				      param_count, required_params_current));
+	}
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_check_for_predefined_name
+ *
+ * PARAMETERS:  Node            - Namespace node for the method/object
+ *
+ * RETURN:      Pointer to entry in predefined table. NULL indicates not found.
+ *
+ * DESCRIPTION: Check an object name against the predefined object list.
+ *
+ ******************************************************************************/
+
+const union acpi_predefined_info *acpi_ns_check_for_predefined_name(struct
+								    acpi_namespace_node
+								    *node)
+{
+	const union acpi_predefined_info *this_name;
+
+	/* Quick check for a predefined name, first character must be underscore */
+
+	if (node->name.ascii[0] != '_') {
+		return (NULL);
+	}
+
+	/* Search info table for a predefined method/object name */
+
+	this_name = predefined_names;
+	while (this_name->info.name[0]) {
+		if (ACPI_COMPARE_NAME(node->name.ascii, this_name->info.name)) {
+			return (this_name);
+		}
+
+		/*
+		 * Skip next entry in the table if this name returns a Package
+		 * (next entry contains the package info)
+		 */
+		if (this_name->info.expected_btypes & ACPI_RTYPE_PACKAGE) {
+			this_name++;
+		}
+
+		this_name++;
+	}
+
+	return (NULL);		/* Not found */
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_check_package
+ *
+ * PARAMETERS:  Data            - Pointer to validation data structure
+ *              return_object_ptr - Pointer to the object returned from the
+ *                                evaluation of a method or object
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Check a returned package object for the correct count and
+ *              correct type of all sub-objects.
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ns_check_package(struct acpi_predefined_data *data,
+		      union acpi_operand_object **return_object_ptr)
+{
+	union acpi_operand_object *return_object = *return_object_ptr;
+	const union acpi_predefined_info *package;
+	union acpi_operand_object **elements;
+	acpi_status status = AE_OK;
+	u32 expected_count;
+	u32 count;
+	u32 i;
+
+	ACPI_FUNCTION_NAME(ns_check_package);
+
+	/* The package info for this name is in the next table entry */
+
+	package = data->predefined + 1;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_NAMES,
+			  "%s Validating return Package of Type %X, Count %X\n",
+			  data->pathname, package->ret_info.type,
+			  return_object->package.count));
+
+	/*
+	 * For variable-length Packages, we can safely remove all embedded
+	 * and trailing NULL package elements
+	 */
+	acpi_ns_remove_null_elements(data, package->ret_info.type,
+				     return_object);
+
+	/* Extract package count and elements array */
+
+	elements = return_object->package.elements;
+	count = return_object->package.count;
+
+	/* The package must have at least one element, else invalid */
+
+	if (!count) {
+		ACPI_WARN_PREDEFINED((AE_INFO, data->pathname, data->node_flags,
+				      "Return Package has no elements (empty)"));
+
+		return (AE_AML_OPERAND_VALUE);
+	}
+
+	/*
+	 * Decode the type of the expected package contents
+	 *
+	 * PTYPE1 packages contain no subpackages
+	 * PTYPE2 packages contain sub-packages
+	 */
+	switch (package->ret_info.type) {
+	case ACPI_PTYPE1_FIXED:
+
+		/*
+		 * The package count is fixed and there are no sub-packages
+		 *
+		 * If package is too small, exit.
+		 * If package is larger than expected, issue warning but continue
+		 */
+		expected_count =
+		    package->ret_info.count1 + package->ret_info.count2;
+		if (count < expected_count) {
+			goto package_too_small;
+		} else if (count > expected_count) {
+			ACPI_DEBUG_PRINT((ACPI_DB_REPAIR,
+					  "%s: Return Package is larger than needed - "
+					  "found %u, expected %u\n",
+					  data->pathname, count,
+					  expected_count));
+		}
+
+		/* Validate all elements of the returned package */
+
+		status = acpi_ns_check_package_elements(data, elements,
+							package->ret_info.
+							object_type1,
+							package->ret_info.
+							count1,
+							package->ret_info.
+							object_type2,
+							package->ret_info.
+							count2, 0);
+		break;
+
+	case ACPI_PTYPE1_VAR:
+
+		/*
+		 * The package count is variable, there are no sub-packages, and all
+		 * elements must be of the same type
+		 */
+		for (i = 0; i < count; i++) {
+			status = acpi_ns_check_object_type(data, elements,
+							   package->ret_info.
+							   object_type1, i);
+			if (ACPI_FAILURE(status)) {
+				return (status);
+			}
+			elements++;
+		}
+		break;
+
+	case ACPI_PTYPE1_OPTION:
+
+		/*
+		 * The package count is variable, there are no sub-packages. There are
+		 * a fixed number of required elements, and a variable number of
+		 * optional elements.
+		 *
+		 * Check if package is at least as large as the minimum required
+		 */
+		expected_count = package->ret_info3.count;
+		if (count < expected_count) {
+			goto package_too_small;
+		}
+
+		/* Variable number of sub-objects */
+
+		for (i = 0; i < count; i++) {
+			if (i < package->ret_info3.count) {
+
+				/* These are the required package elements (0, 1, or 2) */
+
+				status =
+				    acpi_ns_check_object_type(data, elements,
+							      package->
+							      ret_info3.
+							      object_type[i],
+							      i);
+				if (ACPI_FAILURE(status)) {
+					return (status);
+				}
+			} else {
+				/* These are the optional package elements */
+
+				status =
+				    acpi_ns_check_object_type(data, elements,
+							      package->
+							      ret_info3.
+							      tail_object_type,
+							      i);
+				if (ACPI_FAILURE(status)) {
+					return (status);
+				}
+			}
+			elements++;
+		}
+		break;
+
+	case ACPI_PTYPE2_REV_FIXED:
+
+		/* First element is the (Integer) revision */
+
+		status = acpi_ns_check_object_type(data, elements,
+						   ACPI_RTYPE_INTEGER, 0);
+		if (ACPI_FAILURE(status)) {
+			return (status);
+		}
+
+		elements++;
+		count--;
+
+		/* Examine the sub-packages */
+
+		status =
+		    acpi_ns_check_package_list(data, package, elements, count);
+		break;
+
+	case ACPI_PTYPE2_PKG_COUNT:
+
+		/* First element is the (Integer) count of sub-packages to follow */
+
+		status = acpi_ns_check_object_type(data, elements,
+						   ACPI_RTYPE_INTEGER, 0);
+		if (ACPI_FAILURE(status)) {
+			return (status);
+		}
+
+		/*
+		 * Count cannot be larger than the parent package length, but allow it
+		 * to be smaller. The >= accounts for the Integer above.
+		 */
+		expected_count = (u32)(*elements)->integer.value;
+		if (expected_count >= count) {
+			goto package_too_small;
+		}
+
+		count = expected_count;
+		elements++;
+
+		/* Examine the sub-packages */
+
+		status =
+		    acpi_ns_check_package_list(data, package, elements, count);
+		break;
+
+	case ACPI_PTYPE2:
+	case ACPI_PTYPE2_FIXED:
+	case ACPI_PTYPE2_MIN:
+	case ACPI_PTYPE2_COUNT:
+	case ACPI_PTYPE2_FIX_VAR:
+
+		/*
+		 * These types all return a single Package that consists of a
+		 * variable number of sub-Packages.
+		 *
+		 * First, ensure that the first element is a sub-Package. If not,
+		 * the BIOS may have incorrectly returned the object as a single
+		 * package instead of a Package of Packages (a common error if
+		 * there is only one entry). We may be able to repair this by
+		 * wrapping the returned Package with a new outer Package.
+		 */
+		if (*elements
+		    && ((*elements)->common.type != ACPI_TYPE_PACKAGE)) {
+
+			/* Create the new outer package and populate it */
+
+			status =
+			    acpi_ns_repair_package_list(data,
+							return_object_ptr);
+			if (ACPI_FAILURE(status)) {
+				return (status);
+			}
+
+			/* Update locals to point to the new package (of 1 element) */
+
+			return_object = *return_object_ptr;
+			elements = return_object->package.elements;
+			count = 1;
+		}
+
+		/* Examine the sub-packages */
+
+		status =
+		    acpi_ns_check_package_list(data, package, elements, count);
+		break;
+
+	default:
+
+		/* Should not get here if predefined info table is correct */
+
+		ACPI_WARN_PREDEFINED((AE_INFO, data->pathname, data->node_flags,
+				      "Invalid internal return type in table entry: %X",
+				      package->ret_info.type));
+
+		return (AE_AML_INTERNAL);
+	}
+
+	return (status);
+
+      package_too_small:
+
+	/* Error exit for the case with an incorrect package count */
+
+	ACPI_WARN_PREDEFINED((AE_INFO, data->pathname, data->node_flags,
+			      "Return Package is too small - found %u elements, expected %u",
+			      count, expected_count));
+
+	return (AE_AML_OPERAND_VALUE);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_check_package_list
+ *
+ * PARAMETERS:  Data            - Pointer to validation data structure
+ *              Package         - Pointer to package-specific info for method
+ *              Elements        - Element list of parent package. All elements
+ *                                of this list should be of type Package.
+ *              Count           - Count of subpackages
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Examine a list of subpackages
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ns_check_package_list(struct acpi_predefined_data *data,
+			   const union acpi_predefined_info *package,
+			   union acpi_operand_object **elements, u32 count)
+{
+	union acpi_operand_object *sub_package;
+	union acpi_operand_object **sub_elements;
+	acpi_status status;
+	u32 expected_count;
+	u32 i;
+	u32 j;
+
+	/*
+	 * Validate each sub-Package in the parent Package
+	 *
+	 * NOTE: assumes list of sub-packages contains no NULL elements.
+	 * Any NULL elements should have been removed by earlier call
+	 * to acpi_ns_remove_null_elements.
+	 */
+	for (i = 0; i < count; i++) {
+		sub_package = *elements;
+		sub_elements = sub_package->package.elements;
+		data->parent_package = sub_package;
+
+		/* Each sub-object must be of type Package */
+
+		status = acpi_ns_check_object_type(data, &sub_package,
+						   ACPI_RTYPE_PACKAGE, i);
+		if (ACPI_FAILURE(status)) {
+			return (status);
+		}
+
+		/* Examine the different types of expected sub-packages */
+
+		data->parent_package = sub_package;
+		switch (package->ret_info.type) {
+		case ACPI_PTYPE2:
+		case ACPI_PTYPE2_PKG_COUNT:
+		case ACPI_PTYPE2_REV_FIXED:
+
+			/* Each subpackage has a fixed number of elements */
+
+			expected_count =
+			    package->ret_info.count1 + package->ret_info.count2;
+			if (sub_package->package.count < expected_count) {
+				goto package_too_small;
+			}
+
+			status =
+			    acpi_ns_check_package_elements(data, sub_elements,
+							   package->ret_info.
+							   object_type1,
+							   package->ret_info.
+							   count1,
+							   package->ret_info.
+							   object_type2,
+							   package->ret_info.
+							   count2, 0);
+			if (ACPI_FAILURE(status)) {
+				return (status);
+			}
+			break;
+
+		case ACPI_PTYPE2_FIX_VAR:
+			/*
+			 * Each subpackage has a fixed number of elements and an
+			 * optional element
+			 */
+			expected_count =
+			    package->ret_info.count1 + package->ret_info.count2;
+			if (sub_package->package.count < expected_count) {
+				goto package_too_small;
+			}
+
+			status =
+			    acpi_ns_check_package_elements(data, sub_elements,
+							   package->ret_info.
+							   object_type1,
+							   package->ret_info.
+							   count1,
+							   package->ret_info.
+							   object_type2,
+							   sub_package->package.
+							   count -
+							   package->ret_info.
+							   count1, 0);
+			if (ACPI_FAILURE(status)) {
+				return (status);
+			}
+			break;
+
+		case ACPI_PTYPE2_FIXED:
+
+			/* Each sub-package has a fixed length */
+
+			expected_count = package->ret_info2.count;
+			if (sub_package->package.count < expected_count) {
+				goto package_too_small;
+			}
+
+			/* Check the type of each sub-package element */
+
+			for (j = 0; j < expected_count; j++) {
+				status =
+				    acpi_ns_check_object_type(data,
+							      &sub_elements[j],
+							      package->
+							      ret_info2.
+							      object_type[j],
+							      j);
+				if (ACPI_FAILURE(status)) {
+					return (status);
+				}
+			}
+			break;
+
+		case ACPI_PTYPE2_MIN:
+
+			/* Each sub-package has a variable but minimum length */
+
+			expected_count = package->ret_info.count1;
+			if (sub_package->package.count < expected_count) {
+				goto package_too_small;
+			}
+
+			/* Check the type of each sub-package element */
+
+			status =
+			    acpi_ns_check_package_elements(data, sub_elements,
+							   package->ret_info.
+							   object_type1,
+							   sub_package->package.
+							   count, 0, 0, 0);
+			if (ACPI_FAILURE(status)) {
+				return (status);
+			}
+			break;
+
+		case ACPI_PTYPE2_COUNT:
+
+			/*
+			 * First element is the (Integer) count of elements, including
+			 * the count field (the ACPI name is num_elements)
+			 */
+			status = acpi_ns_check_object_type(data, sub_elements,
+							   ACPI_RTYPE_INTEGER,
+							   0);
+			if (ACPI_FAILURE(status)) {
+				return (status);
+			}
+
+			/*
+			 * Make sure package is large enough for the Count and is
+			 * is as large as the minimum size
+			 */
+			expected_count = (u32)(*sub_elements)->integer.value;
+			if (sub_package->package.count < expected_count) {
+				goto package_too_small;
+			}
+			if (sub_package->package.count <
+			    package->ret_info.count1) {
+				expected_count = package->ret_info.count1;
+				goto package_too_small;
+			}
+			if (expected_count == 0) {
+				/*
+				 * Either the num_entries element was originally zero or it was
+				 * a NULL element and repaired to an Integer of value zero.
+				 * In either case, repair it by setting num_entries to be the
+				 * actual size of the subpackage.
+				 */
+				expected_count = sub_package->package.count;
+				(*sub_elements)->integer.value = expected_count;
+			}
+
+			/* Check the type of each sub-package element */
+
+			status =
+			    acpi_ns_check_package_elements(data,
+							   (sub_elements + 1),
+							   package->ret_info.
+							   object_type1,
+							   (expected_count - 1),
+							   0, 0, 1);
+			if (ACPI_FAILURE(status)) {
+				return (status);
+			}
+			break;
+
+		default:	/* Should not get here, type was validated by caller */
+
+			return (AE_AML_INTERNAL);
+		}
+
+		elements++;
+	}
+
+	return (AE_OK);
+
+      package_too_small:
+
+	/* The sub-package count was smaller than required */
+
+	ACPI_WARN_PREDEFINED((AE_INFO, data->pathname, data->node_flags,
+			      "Return Sub-Package[%u] is too small - found %u elements, expected %u",
+			      i, sub_package->package.count, expected_count));
+
+	return (AE_AML_OPERAND_VALUE);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_check_package_elements
+ *
+ * PARAMETERS:  Data            - Pointer to validation data structure
+ *              Elements        - Pointer to the package elements array
+ *              Type1           - Object type for first group
+ *              Count1          - Count for first group
+ *              Type2           - Object type for second group
+ *              Count2          - Count for second group
+ *              start_index     - Start of the first group of elements
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Check that all elements of a package are of the correct object
+ *              type. Supports up to two groups of different object types.
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ns_check_package_elements(struct acpi_predefined_data *data,
+			       union acpi_operand_object **elements,
+			       u8 type1,
+			       u32 count1,
+			       u8 type2, u32 count2, u32 start_index)
+{
+	union acpi_operand_object **this_element = elements;
+	acpi_status status;
+	u32 i;
+
+	/*
+	 * Up to two groups of package elements are supported by the data
+	 * structure. All elements in each group must be of the same type.
+	 * The second group can have a count of zero.
+	 */
+	for (i = 0; i < count1; i++) {
+		status = acpi_ns_check_object_type(data, this_element,
+						   type1, i + start_index);
+		if (ACPI_FAILURE(status)) {
+			return (status);
+		}
+		this_element++;
+	}
+
+	for (i = 0; i < count2; i++) {
+		status = acpi_ns_check_object_type(data, this_element,
+						   type2,
+						   (i + count1 + start_index));
+		if (ACPI_FAILURE(status)) {
+			return (status);
+		}
+		this_element++;
+	}
+
+	return (AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_check_object_type
+ *
+ * PARAMETERS:  Data            - Pointer to validation data structure
+ *              return_object_ptr - Pointer to the object returned from the
+ *                                evaluation of a method or object
+ *              expected_btypes - Bitmap of expected return type(s)
+ *              package_index   - Index of object within parent package (if
+ *                                applicable - ACPI_NOT_PACKAGE_ELEMENT
+ *                                otherwise)
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Check the type of the return object against the expected object
+ *              type(s). Use of Btype allows multiple expected object types.
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ns_check_object_type(struct acpi_predefined_data *data,
+			  union acpi_operand_object **return_object_ptr,
+			  u32 expected_btypes, u32 package_index)
+{
+	union acpi_operand_object *return_object = *return_object_ptr;
+	acpi_status status = AE_OK;
+	u32 return_btype;
+	char type_buffer[48];	/* Room for 5 types */
+
+	/*
+	 * If we get a NULL return_object here, it is a NULL package element.
+	 * Since all extraneous NULL package elements were removed earlier by a
+	 * call to acpi_ns_remove_null_elements, this is an unexpected NULL element.
+	 * We will attempt to repair it.
+	 */
+	if (!return_object) {
+		status = acpi_ns_repair_null_element(data, expected_btypes,
+						     package_index,
+						     return_object_ptr);
+		if (ACPI_SUCCESS(status)) {
+			return (AE_OK);	/* Repair was successful */
+		}
+		goto type_error_exit;
+	}
+
+	/* A Namespace node should not get here, but make sure */
+
+	if (ACPI_GET_DESCRIPTOR_TYPE(return_object) == ACPI_DESC_TYPE_NAMED) {
+		ACPI_WARN_PREDEFINED((AE_INFO, data->pathname, data->node_flags,
+				      "Invalid return type - Found a Namespace node [%4.4s] type %s",
+				      return_object->node.name.ascii,
+				      acpi_ut_get_type_name(return_object->node.
+							    type)));
+		return (AE_AML_OPERAND_TYPE);
+	}
+
+	/*
+	 * Convert the object type (ACPI_TYPE_xxx) to a bitmapped object type.
+	 * The bitmapped type allows multiple possible return types.
+	 *
+	 * Note, the cases below must handle all of the possible types returned
+	 * from all of the predefined names (including elements of returned
+	 * packages)
+	 */
+	switch (return_object->common.type) {
+	case ACPI_TYPE_INTEGER:
+		return_btype = ACPI_RTYPE_INTEGER;
+		break;
+
+	case ACPI_TYPE_BUFFER:
+		return_btype = ACPI_RTYPE_BUFFER;
+		break;
+
+	case ACPI_TYPE_STRING:
+		return_btype = ACPI_RTYPE_STRING;
+		break;
+
+	case ACPI_TYPE_PACKAGE:
+		return_btype = ACPI_RTYPE_PACKAGE;
+		break;
+
+	case ACPI_TYPE_LOCAL_REFERENCE:
+		return_btype = ACPI_RTYPE_REFERENCE;
+		break;
+
+	default:
+		/* Not one of the supported objects, must be incorrect */
+
+		goto type_error_exit;
+	}
+
+	/* Is the object one of the expected types? */
+
+	if (return_btype & expected_btypes) {
+
+		/* For reference objects, check that the reference type is correct */
+
+		if (return_object->common.type == ACPI_TYPE_LOCAL_REFERENCE) {
+			status = acpi_ns_check_reference(data, return_object);
+		}
+
+		return (status);
+	}
+
+	/* Type mismatch -- attempt repair of the returned object */
+
+	status = acpi_ns_repair_object(data, expected_btypes,
+				       package_index, return_object_ptr);
+	if (ACPI_SUCCESS(status)) {
+		return (AE_OK);	/* Repair was successful */
+	}
+
+      type_error_exit:
+
+	/* Create a string with all expected types for this predefined object */
+
+	acpi_ns_get_expected_types(type_buffer, expected_btypes);
+
+	if (package_index == ACPI_NOT_PACKAGE_ELEMENT) {
+		ACPI_WARN_PREDEFINED((AE_INFO, data->pathname, data->node_flags,
+				      "Return type mismatch - found %s, expected %s",
+				      acpi_ut_get_object_type_name
+				      (return_object), type_buffer));
+	} else {
+		ACPI_WARN_PREDEFINED((AE_INFO, data->pathname, data->node_flags,
+				      "Return Package type mismatch at index %u - "
+				      "found %s, expected %s", package_index,
+				      acpi_ut_get_object_type_name
+				      (return_object), type_buffer));
+	}
+
+	return (AE_AML_OPERAND_TYPE);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_check_reference
+ *
+ * PARAMETERS:  Data            - Pointer to validation data structure
+ *              return_object   - Object returned from the evaluation of a
+ *                                method or object
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Check a returned reference object for the correct reference
+ *              type. The only reference type that can be returned from a
+ *              predefined method is a named reference. All others are invalid.
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ns_check_reference(struct acpi_predefined_data *data,
+			union acpi_operand_object *return_object)
+{
+
+	/*
+	 * Check the reference object for the correct reference type (opcode).
+	 * The only type of reference that can be converted to an union acpi_object is
+	 * a reference to a named object (reference class: NAME)
+	 */
+	if (return_object->reference.class == ACPI_REFCLASS_NAME) {
+		return (AE_OK);
+	}
+
+	ACPI_WARN_PREDEFINED((AE_INFO, data->pathname, data->node_flags,
+			      "Return type mismatch - unexpected reference object type [%s] %2.2X",
+			      acpi_ut_get_reference_name(return_object),
+			      return_object->reference.class));
+
+	return (AE_AML_OPERAND_TYPE);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_get_expected_types
+ *
+ * PARAMETERS:  Buffer          - Pointer to where the string is returned
+ *              expected_btypes - Bitmap of expected return type(s)
+ *
+ * RETURN:      Buffer is populated with type names.
+ *
+ * DESCRIPTION: Translate the expected types bitmap into a string of ascii
+ *              names of expected types, for use in warning messages.
+ *
+ ******************************************************************************/
+
+static void acpi_ns_get_expected_types(char *buffer, u32 expected_btypes)
+{
+	u32 this_rtype;
+	u32 i;
+	u32 j;
+
+	j = 1;
+	buffer[0] = 0;
+	this_rtype = ACPI_RTYPE_INTEGER;
+
+	for (i = 0; i < ACPI_NUM_RTYPES; i++) {
+
+		/* If one of the expected types, concatenate the name of this type */
+
+		if (expected_btypes & this_rtype) {
+			ACPI_STRCAT(buffer, &acpi_rtype_names[i][j]);
+			j = 0;	/* Use name separator from now on */
+		}
+		this_rtype <<= 1;	/* Next Rtype */
+	}
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nsrepair.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nsrepair.c
new file mode 100644
index 00000000..83964dd0
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nsrepair.c
@@ -0,0 +1,730 @@
+/******************************************************************************
+ *
+ * Module Name: nsrepair - Repair for objects returned by predefined methods
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acnamesp.h"
+#include "acinterp.h"
+#include "acpredef.h"
+
+#define _COMPONENT          ACPI_NAMESPACE
+ACPI_MODULE_NAME("nsrepair")
+
+/*******************************************************************************
+ *
+ * This module attempts to repair or convert objects returned by the
+ * predefined methods to an object type that is expected, as per the ACPI
+ * specification. The need for this code is dictated by the many machines that
+ * return incorrect types for the standard predefined methods. Performing these
+ * conversions here, in one place, eliminates the need for individual ACPI
+ * device drivers to do the same. Note: Most of these conversions are different
+ * than the internal object conversion routines used for implicit object
+ * conversion.
+ *
+ * The following conversions can be performed as necessary:
+ *
+ * Integer -> String
+ * Integer -> Buffer
+ * String  -> Integer
+ * String  -> Buffer
+ * Buffer  -> Integer
+ * Buffer  -> String
+ * Buffer  -> Package of Integers
+ * Package -> Package of one Package
+ *
+ * Additional possible repairs:
+ *
+ * Required package elements that are NULL replaced by Integer/String/Buffer
+ * Incorrect standalone package wrapped with required outer package
+ *
+ ******************************************************************************/
+/* Local prototypes */
+static acpi_status
+acpi_ns_convert_to_integer(union acpi_operand_object *original_object,
+			   union acpi_operand_object **return_object);
+
+static acpi_status
+acpi_ns_convert_to_string(union acpi_operand_object *original_object,
+			  union acpi_operand_object **return_object);
+
+static acpi_status
+acpi_ns_convert_to_buffer(union acpi_operand_object *original_object,
+			  union acpi_operand_object **return_object);
+
+static acpi_status
+acpi_ns_convert_to_package(union acpi_operand_object *original_object,
+			   union acpi_operand_object **return_object);
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_repair_object
+ *
+ * PARAMETERS:  Data                - Pointer to validation data structure
+ *              expected_btypes     - Object types expected
+ *              package_index       - Index of object within parent package (if
+ *                                    applicable - ACPI_NOT_PACKAGE_ELEMENT
+ *                                    otherwise)
+ *              return_object_ptr   - Pointer to the object returned from the
+ *                                    evaluation of a method or object
+ *
+ * RETURN:      Status. AE_OK if repair was successful.
+ *
+ * DESCRIPTION: Attempt to repair/convert a return object of a type that was
+ *              not expected.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ns_repair_object(struct acpi_predefined_data *data,
+		      u32 expected_btypes,
+		      u32 package_index,
+		      union acpi_operand_object **return_object_ptr)
+{
+	union acpi_operand_object *return_object = *return_object_ptr;
+	union acpi_operand_object *new_object;
+	acpi_status status;
+
+	ACPI_FUNCTION_NAME(ns_repair_object);
+
+	/*
+	 * At this point, we know that the type of the returned object was not
+	 * one of the expected types for this predefined name. Attempt to
+	 * repair the object by converting it to one of the expected object
+	 * types for this predefined name.
+	 */
+	if (expected_btypes & ACPI_RTYPE_INTEGER) {
+		status = acpi_ns_convert_to_integer(return_object, &new_object);
+		if (ACPI_SUCCESS(status)) {
+			goto object_repaired;
+		}
+	}
+	if (expected_btypes & ACPI_RTYPE_STRING) {
+		status = acpi_ns_convert_to_string(return_object, &new_object);
+		if (ACPI_SUCCESS(status)) {
+			goto object_repaired;
+		}
+	}
+	if (expected_btypes & ACPI_RTYPE_BUFFER) {
+		status = acpi_ns_convert_to_buffer(return_object, &new_object);
+		if (ACPI_SUCCESS(status)) {
+			goto object_repaired;
+		}
+	}
+	if (expected_btypes & ACPI_RTYPE_PACKAGE) {
+		status = acpi_ns_convert_to_package(return_object, &new_object);
+		if (ACPI_SUCCESS(status)) {
+			goto object_repaired;
+		}
+	}
+
+	/* We cannot repair this object */
+
+	return (AE_AML_OPERAND_TYPE);
+
+      object_repaired:
+
+	/* Object was successfully repaired */
+
+	/*
+	 * If the original object is a package element, we need to:
+	 * 1. Set the reference count of the new object to match the
+	 *    reference count of the old object.
+	 * 2. Decrement the reference count of the original object.
+	 */
+	if (package_index != ACPI_NOT_PACKAGE_ELEMENT) {
+		new_object->common.reference_count =
+		    return_object->common.reference_count;
+
+		if (return_object->common.reference_count > 1) {
+			return_object->common.reference_count--;
+		}
+
+		ACPI_DEBUG_PRINT((ACPI_DB_REPAIR,
+				  "%s: Converted %s to expected %s at index %u\n",
+				  data->pathname,
+				  acpi_ut_get_object_type_name(return_object),
+				  acpi_ut_get_object_type_name(new_object),
+				  package_index));
+	} else {
+		ACPI_DEBUG_PRINT((ACPI_DB_REPAIR,
+				  "%s: Converted %s to expected %s\n",
+				  data->pathname,
+				  acpi_ut_get_object_type_name(return_object),
+				  acpi_ut_get_object_type_name(new_object)));
+	}
+
+	/* Delete old object, install the new return object */
+
+	acpi_ut_remove_reference(return_object);
+	*return_object_ptr = new_object;
+	data->flags |= ACPI_OBJECT_REPAIRED;
+	return (AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_convert_to_integer
+ *
+ * PARAMETERS:  original_object     - Object to be converted
+ *              return_object       - Where the new converted object is returned
+ *
+ * RETURN:      Status. AE_OK if conversion was successful.
+ *
+ * DESCRIPTION: Attempt to convert a String/Buffer object to an Integer.
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ns_convert_to_integer(union acpi_operand_object *original_object,
+			   union acpi_operand_object **return_object)
+{
+	union acpi_operand_object *new_object;
+	acpi_status status;
+	u64 value = 0;
+	u32 i;
+
+	switch (original_object->common.type) {
+	case ACPI_TYPE_STRING:
+
+		/* String-to-Integer conversion */
+
+		status = acpi_ut_strtoul64(original_object->string.pointer,
+					   ACPI_ANY_BASE, &value);
+		if (ACPI_FAILURE(status)) {
+			return (status);
+		}
+		break;
+
+	case ACPI_TYPE_BUFFER:
+
+		/* Buffer-to-Integer conversion. Max buffer size is 64 bits. */
+
+		if (original_object->buffer.length > 8) {
+			return (AE_AML_OPERAND_TYPE);
+		}
+
+		/* Extract each buffer byte to create the integer */
+
+		for (i = 0; i < original_object->buffer.length; i++) {
+			value |=
+			    ((u64)original_object->buffer.
+			     pointer[i] << (i * 8));
+		}
+		break;
+
+	default:
+		return (AE_AML_OPERAND_TYPE);
+	}
+
+	new_object = acpi_ut_create_integer_object(value);
+	if (!new_object) {
+		return (AE_NO_MEMORY);
+	}
+
+	*return_object = new_object;
+	return (AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_convert_to_string
+ *
+ * PARAMETERS:  original_object     - Object to be converted
+ *              return_object       - Where the new converted object is returned
+ *
+ * RETURN:      Status. AE_OK if conversion was successful.
+ *
+ * DESCRIPTION: Attempt to convert a Integer/Buffer object to a String.
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ns_convert_to_string(union acpi_operand_object *original_object,
+			  union acpi_operand_object **return_object)
+{
+	union acpi_operand_object *new_object;
+	acpi_size length;
+	acpi_status status;
+
+	switch (original_object->common.type) {
+	case ACPI_TYPE_INTEGER:
+		/*
+		 * Integer-to-String conversion. Commonly, convert
+		 * an integer of value 0 to a NULL string. The last element of
+		 * _BIF and _BIX packages occasionally need this fix.
+		 */
+		if (original_object->integer.value == 0) {
+
+			/* Allocate a new NULL string object */
+
+			new_object = acpi_ut_create_string_object(0);
+			if (!new_object) {
+				return (AE_NO_MEMORY);
+			}
+		} else {
+			status =
+			    acpi_ex_convert_to_string(original_object,
+						      &new_object,
+						      ACPI_IMPLICIT_CONVERT_HEX);
+			if (ACPI_FAILURE(status)) {
+				return (status);
+			}
+		}
+		break;
+
+	case ACPI_TYPE_BUFFER:
+		/*
+		 * Buffer-to-String conversion. Use a to_string
+		 * conversion, no transform performed on the buffer data. The best
+		 * example of this is the _BIF method, where the string data from
+		 * the battery is often (incorrectly) returned as buffer object(s).
+		 */
+		length = 0;
+		while ((length < original_object->buffer.length) &&
+		       (original_object->buffer.pointer[length])) {
+			length++;
+		}
+
+		/* Allocate a new string object */
+
+		new_object = acpi_ut_create_string_object(length);
+		if (!new_object) {
+			return (AE_NO_MEMORY);
+		}
+
+		/*
+		 * Copy the raw buffer data with no transform. String is already NULL
+		 * terminated at Length+1.
+		 */
+		ACPI_MEMCPY(new_object->string.pointer,
+			    original_object->buffer.pointer, length);
+		break;
+
+	default:
+		return (AE_AML_OPERAND_TYPE);
+	}
+
+	*return_object = new_object;
+	return (AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_convert_to_buffer
+ *
+ * PARAMETERS:  original_object     - Object to be converted
+ *              return_object       - Where the new converted object is returned
+ *
+ * RETURN:      Status. AE_OK if conversion was successful.
+ *
+ * DESCRIPTION: Attempt to convert a Integer/String/Package object to a Buffer.
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ns_convert_to_buffer(union acpi_operand_object *original_object,
+			  union acpi_operand_object **return_object)
+{
+	union acpi_operand_object *new_object;
+	acpi_status status;
+	union acpi_operand_object **elements;
+	u32 *dword_buffer;
+	u32 count;
+	u32 i;
+
+	switch (original_object->common.type) {
+	case ACPI_TYPE_INTEGER:
+		/*
+		 * Integer-to-Buffer conversion.
+		 * Convert the Integer to a packed-byte buffer. _MAT and other
+		 * objects need this sometimes, if a read has been performed on a
+		 * Field object that is less than or equal to the global integer
+		 * size (32 or 64 bits).
+		 */
+		status =
+		    acpi_ex_convert_to_buffer(original_object, &new_object);
+		if (ACPI_FAILURE(status)) {
+			return (status);
+		}
+		break;
+
+	case ACPI_TYPE_STRING:
+
+		/* String-to-Buffer conversion. Simple data copy */
+
+		new_object =
+		    acpi_ut_create_buffer_object(original_object->string.
+						 length);
+		if (!new_object) {
+			return (AE_NO_MEMORY);
+		}
+
+		ACPI_MEMCPY(new_object->buffer.pointer,
+			    original_object->string.pointer,
+			    original_object->string.length);
+		break;
+
+	case ACPI_TYPE_PACKAGE:
+		/*
+		 * This case is often seen for predefined names that must return a
+		 * Buffer object with multiple DWORD integers within. For example,
+		 * _FDE and _GTM. The Package can be converted to a Buffer.
+		 */
+
+		/* All elements of the Package must be integers */
+
+		elements = original_object->package.elements;
+		count = original_object->package.count;
+
+		for (i = 0; i < count; i++) {
+			if ((!*elements) ||
+			    ((*elements)->common.type != ACPI_TYPE_INTEGER)) {
+				return (AE_AML_OPERAND_TYPE);
+			}
+			elements++;
+		}
+
+		/* Create the new buffer object to replace the Package */
+
+		new_object = acpi_ut_create_buffer_object(ACPI_MUL_4(count));
+		if (!new_object) {
+			return (AE_NO_MEMORY);
+		}
+
+		/* Copy the package elements (integers) to the buffer as DWORDs */
+
+		elements = original_object->package.elements;
+		dword_buffer = ACPI_CAST_PTR(u32, new_object->buffer.pointer);
+
+		for (i = 0; i < count; i++) {
+			*dword_buffer = (u32)(*elements)->integer.value;
+			dword_buffer++;
+			elements++;
+		}
+		break;
+
+	default:
+		return (AE_AML_OPERAND_TYPE);
+	}
+
+	*return_object = new_object;
+	return (AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_convert_to_package
+ *
+ * PARAMETERS:  original_object     - Object to be converted
+ *              return_object       - Where the new converted object is returned
+ *
+ * RETURN:      Status. AE_OK if conversion was successful.
+ *
+ * DESCRIPTION: Attempt to convert a Buffer object to a Package. Each byte of
+ *              the buffer is converted to a single integer package element.
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ns_convert_to_package(union acpi_operand_object *original_object,
+			   union acpi_operand_object **return_object)
+{
+	union acpi_operand_object *new_object;
+	union acpi_operand_object **elements;
+	u32 length;
+	u8 *buffer;
+
+	switch (original_object->common.type) {
+	case ACPI_TYPE_BUFFER:
+
+		/* Buffer-to-Package conversion */
+
+		length = original_object->buffer.length;
+		new_object = acpi_ut_create_package_object(length);
+		if (!new_object) {
+			return (AE_NO_MEMORY);
+		}
+
+		/* Convert each buffer byte to an integer package element */
+
+		elements = new_object->package.elements;
+		buffer = original_object->buffer.pointer;
+
+		while (length--) {
+			*elements = acpi_ut_create_integer_object((u64)*buffer);
+			if (!*elements) {
+				acpi_ut_remove_reference(new_object);
+				return (AE_NO_MEMORY);
+			}
+			elements++;
+			buffer++;
+		}
+		break;
+
+	default:
+		return (AE_AML_OPERAND_TYPE);
+	}
+
+	*return_object = new_object;
+	return (AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_repair_null_element
+ *
+ * PARAMETERS:  Data                - Pointer to validation data structure
+ *              expected_btypes     - Object types expected
+ *              package_index       - Index of object within parent package (if
+ *                                    applicable - ACPI_NOT_PACKAGE_ELEMENT
+ *                                    otherwise)
+ *              return_object_ptr   - Pointer to the object returned from the
+ *                                    evaluation of a method or object
+ *
+ * RETURN:      Status. AE_OK if repair was successful.
+ *
+ * DESCRIPTION: Attempt to repair a NULL element of a returned Package object.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ns_repair_null_element(struct acpi_predefined_data *data,
+			    u32 expected_btypes,
+			    u32 package_index,
+			    union acpi_operand_object **return_object_ptr)
+{
+	union acpi_operand_object *return_object = *return_object_ptr;
+	union acpi_operand_object *new_object;
+
+	ACPI_FUNCTION_NAME(ns_repair_null_element);
+
+	/* No repair needed if return object is non-NULL */
+
+	if (return_object) {
+		return (AE_OK);
+	}
+
+	/*
+	 * Attempt to repair a NULL element of a Package object. This applies to
+	 * predefined names that return a fixed-length package and each element
+	 * is required. It does not apply to variable-length packages where NULL
+	 * elements are allowed, especially at the end of the package.
+	 */
+	if (expected_btypes & ACPI_RTYPE_INTEGER) {
+
+		/* Need an Integer - create a zero-value integer */
+
+		new_object = acpi_ut_create_integer_object((u64)0);
+	} else if (expected_btypes & ACPI_RTYPE_STRING) {
+
+		/* Need a String - create a NULL string */
+
+		new_object = acpi_ut_create_string_object(0);
+	} else if (expected_btypes & ACPI_RTYPE_BUFFER) {
+
+		/* Need a Buffer - create a zero-length buffer */
+
+		new_object = acpi_ut_create_buffer_object(0);
+	} else {
+		/* Error for all other expected types */
+
+		return (AE_AML_OPERAND_TYPE);
+	}
+
+	if (!new_object) {
+		return (AE_NO_MEMORY);
+	}
+
+	/* Set the reference count according to the parent Package object */
+
+	new_object->common.reference_count =
+	    data->parent_package->common.reference_count;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_REPAIR,
+			  "%s: Converted NULL package element to expected %s at index %u\n",
+			  data->pathname,
+			  acpi_ut_get_object_type_name(new_object),
+			  package_index));
+
+	*return_object_ptr = new_object;
+	data->flags |= ACPI_OBJECT_REPAIRED;
+	return (AE_OK);
+}
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_remove_null_elements
+ *
+ * PARAMETERS:  Data                - Pointer to validation data structure
+ *              package_type        - An acpi_return_package_types value
+ *              obj_desc            - A Package object
+ *
+ * RETURN:      None.
+ *
+ * DESCRIPTION: Remove all NULL package elements from packages that contain
+ *              a variable number of sub-packages. For these types of
+ *              packages, NULL elements can be safely removed.
+ *
+ *****************************************************************************/
+
+void
+acpi_ns_remove_null_elements(struct acpi_predefined_data *data,
+			     u8 package_type,
+			     union acpi_operand_object *obj_desc)
+{
+	union acpi_operand_object **source;
+	union acpi_operand_object **dest;
+	u32 count;
+	u32 new_count;
+	u32 i;
+
+	ACPI_FUNCTION_NAME(ns_remove_null_elements);
+
+	/*
+	 * We can safely remove all NULL elements from these package types:
+	 * PTYPE1_VAR packages contain a variable number of simple data types.
+	 * PTYPE2 packages contain a variable number of sub-packages.
+	 */
+	switch (package_type) {
+	case ACPI_PTYPE1_VAR:
+	case ACPI_PTYPE2:
+	case ACPI_PTYPE2_COUNT:
+	case ACPI_PTYPE2_PKG_COUNT:
+	case ACPI_PTYPE2_FIXED:
+	case ACPI_PTYPE2_MIN:
+	case ACPI_PTYPE2_REV_FIXED:
+	case ACPI_PTYPE2_FIX_VAR:
+		break;
+
+	default:
+	case ACPI_PTYPE1_FIXED:
+	case ACPI_PTYPE1_OPTION:
+		return;
+	}
+
+	count = obj_desc->package.count;
+	new_count = count;
+
+	source = obj_desc->package.elements;
+	dest = source;
+
+	/* Examine all elements of the package object, remove nulls */
+
+	for (i = 0; i < count; i++) {
+		if (!*source) {
+			new_count--;
+		} else {
+			*dest = *source;
+			dest++;
+		}
+		source++;
+	}
+
+	/* Update parent package if any null elements were removed */
+
+	if (new_count < count) {
+		ACPI_DEBUG_PRINT((ACPI_DB_REPAIR,
+				  "%s: Found and removed %u NULL elements\n",
+				  data->pathname, (count - new_count)));
+
+		/* NULL terminate list and update the package count */
+
+		*dest = NULL;
+		obj_desc->package.count = new_count;
+	}
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_repair_package_list
+ *
+ * PARAMETERS:  Data                - Pointer to validation data structure
+ *              obj_desc_ptr        - Pointer to the object to repair. The new
+ *                                    package object is returned here,
+ *                                    overwriting the old object.
+ *
+ * RETURN:      Status, new object in *obj_desc_ptr
+ *
+ * DESCRIPTION: Repair a common problem with objects that are defined to return
+ *              a variable-length Package of Packages. If the variable-length
+ *              is one, some BIOS code mistakenly simply declares a single
+ *              Package instead of a Package with one sub-Package. This
+ *              function attempts to repair this error by wrapping a Package
+ *              object around the original Package, creating the correct
+ *              Package with one sub-Package.
+ *
+ *              Names that can be repaired in this manner include:
+ *              _ALR, _CSD, _HPX, _MLS, _PRT, _PSS, _TRT, TSS
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ns_repair_package_list(struct acpi_predefined_data *data,
+			    union acpi_operand_object **obj_desc_ptr)
+{
+	union acpi_operand_object *pkg_obj_desc;
+
+	ACPI_FUNCTION_NAME(ns_repair_package_list);
+
+	/*
+	 * Create the new outer package and populate it. The new package will
+	 * have a single element, the lone subpackage.
+	 */
+	pkg_obj_desc = acpi_ut_create_package_object(1);
+	if (!pkg_obj_desc) {
+		return (AE_NO_MEMORY);
+	}
+
+	pkg_obj_desc->package.elements[0] = *obj_desc_ptr;
+
+	/* Return the new object in the object pointer */
+
+	*obj_desc_ptr = pkg_obj_desc;
+	data->flags |= ACPI_OBJECT_REPAIRED;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_REPAIR,
+			  "%s: Repaired incorrectly formed Package\n",
+			  data->pathname));
+
+	return (AE_OK);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nsrepair2.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nsrepair2.c
new file mode 100644
index 00000000..8ca655c6
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nsrepair2.c
@@ -0,0 +1,754 @@
+/******************************************************************************
+ *
+ * Module Name: nsrepair2 - Repair for objects returned by specific
+ *                          predefined methods
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acnamesp.h"
+
+#define _COMPONENT          ACPI_NAMESPACE
+ACPI_MODULE_NAME("nsrepair2")
+
+/*
+ * Information structure and handler for ACPI predefined names that can
+ * be repaired on a per-name basis.
+ */
+typedef
+acpi_status(*acpi_repair_function) (struct acpi_predefined_data *data,
+				    union acpi_operand_object
+				    **return_object_ptr);
+
+typedef struct acpi_repair_info {
+	char name[ACPI_NAME_SIZE];
+	acpi_repair_function repair_function;
+
+} acpi_repair_info;
+
+/* Local prototypes */
+
+static const struct acpi_repair_info *acpi_ns_match_repairable_name(struct
+								    acpi_namespace_node
+								    *node);
+
+static acpi_status
+acpi_ns_repair_ALR(struct acpi_predefined_data *data,
+		   union acpi_operand_object **return_object_ptr);
+
+static acpi_status
+acpi_ns_repair_CID(struct acpi_predefined_data *data,
+		   union acpi_operand_object **return_object_ptr);
+
+static acpi_status
+acpi_ns_repair_FDE(struct acpi_predefined_data *data,
+		   union acpi_operand_object **return_object_ptr);
+
+static acpi_status
+acpi_ns_repair_HID(struct acpi_predefined_data *data,
+		   union acpi_operand_object **return_object_ptr);
+
+static acpi_status
+acpi_ns_repair_PSS(struct acpi_predefined_data *data,
+		   union acpi_operand_object **return_object_ptr);
+
+static acpi_status
+acpi_ns_repair_TSS(struct acpi_predefined_data *data,
+		   union acpi_operand_object **return_object_ptr);
+
+static acpi_status
+acpi_ns_check_sorted_list(struct acpi_predefined_data *data,
+			  union acpi_operand_object *return_object,
+			  u32 expected_count,
+			  u32 sort_index,
+			  u8 sort_direction, char *sort_key_name);
+
+static void
+acpi_ns_sort_list(union acpi_operand_object **elements,
+		  u32 count, u32 index, u8 sort_direction);
+
+/* Values for sort_direction above */
+
+#define ACPI_SORT_ASCENDING     0
+#define ACPI_SORT_DESCENDING    1
+
+/*
+ * This table contains the names of the predefined methods for which we can
+ * perform more complex repairs.
+ *
+ * As necessary:
+ *
+ * _ALR: Sort the list ascending by ambient_illuminance
+ * _CID: Strings: uppercase all, remove any leading asterisk
+ * _FDE: Convert Buffer of BYTEs to a Buffer of DWORDs
+ * _GTM: Convert Buffer of BYTEs to a Buffer of DWORDs
+ * _HID: Strings: uppercase all, remove any leading asterisk
+ * _PSS: Sort the list descending by Power
+ * _TSS: Sort the list descending by Power
+ *
+ * Names that must be packages, but cannot be sorted:
+ *
+ * _BCL: Values are tied to the Package index where they appear, and cannot
+ * be moved or sorted. These index values are used for _BQC and _BCM.
+ * However, we can fix the case where a buffer is returned, by converting
+ * it to a Package of integers.
+ */
+static const struct acpi_repair_info acpi_ns_repairable_names[] = {
+	{"_ALR", acpi_ns_repair_ALR},
+	{"_CID", acpi_ns_repair_CID},
+	{"_FDE", acpi_ns_repair_FDE},
+	{"_GTM", acpi_ns_repair_FDE},	/* _GTM has same repair as _FDE */
+	{"_HID", acpi_ns_repair_HID},
+	{"_PSS", acpi_ns_repair_PSS},
+	{"_TSS", acpi_ns_repair_TSS},
+	{{0, 0, 0, 0}, NULL}	/* Table terminator */
+};
+
+#define ACPI_FDE_FIELD_COUNT        5
+#define ACPI_FDE_BYTE_BUFFER_SIZE   5
+#define ACPI_FDE_DWORD_BUFFER_SIZE  (ACPI_FDE_FIELD_COUNT * sizeof (u32))
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_complex_repairs
+ *
+ * PARAMETERS:  Data                - Pointer to validation data structure
+ *              Node                - Namespace node for the method/object
+ *              validate_status     - Original status of earlier validation
+ *              return_object_ptr   - Pointer to the object returned from the
+ *                                    evaluation of a method or object
+ *
+ * RETURN:      Status. AE_OK if repair was successful. If name is not
+ *              matched, validate_status is returned.
+ *
+ * DESCRIPTION: Attempt to repair/convert a return object of a type that was
+ *              not expected.
+ *
+ *****************************************************************************/
+
+acpi_status
+acpi_ns_complex_repairs(struct acpi_predefined_data *data,
+			struct acpi_namespace_node *node,
+			acpi_status validate_status,
+			union acpi_operand_object **return_object_ptr)
+{
+	const struct acpi_repair_info *predefined;
+	acpi_status status;
+
+	/* Check if this name is in the list of repairable names */
+
+	predefined = acpi_ns_match_repairable_name(node);
+	if (!predefined) {
+		return (validate_status);
+	}
+
+	status = predefined->repair_function(data, return_object_ptr);
+	return (status);
+}
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_match_repairable_name
+ *
+ * PARAMETERS:  Node                - Namespace node for the method/object
+ *
+ * RETURN:      Pointer to entry in repair table. NULL indicates not found.
+ *
+ * DESCRIPTION: Check an object name against the repairable object list.
+ *
+ *****************************************************************************/
+
+static const struct acpi_repair_info *acpi_ns_match_repairable_name(struct
+								    acpi_namespace_node
+								    *node)
+{
+	const struct acpi_repair_info *this_name;
+
+	/* Search info table for a repairable predefined method/object name */
+
+	this_name = acpi_ns_repairable_names;
+	while (this_name->repair_function) {
+		if (ACPI_COMPARE_NAME(node->name.ascii, this_name->name)) {
+			return (this_name);
+		}
+		this_name++;
+	}
+
+	return (NULL);		/* Not found */
+}
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_repair_ALR
+ *
+ * PARAMETERS:  Data                - Pointer to validation data structure
+ *              return_object_ptr   - Pointer to the object returned from the
+ *                                    evaluation of a method or object
+ *
+ * RETURN:      Status. AE_OK if object is OK or was repaired successfully
+ *
+ * DESCRIPTION: Repair for the _ALR object. If necessary, sort the object list
+ *              ascending by the ambient illuminance values.
+ *
+ *****************************************************************************/
+
+static acpi_status
+acpi_ns_repair_ALR(struct acpi_predefined_data *data,
+		   union acpi_operand_object **return_object_ptr)
+{
+	union acpi_operand_object *return_object = *return_object_ptr;
+	acpi_status status;
+
+	status = acpi_ns_check_sorted_list(data, return_object, 2, 1,
+					   ACPI_SORT_ASCENDING,
+					   "AmbientIlluminance");
+
+	return (status);
+}
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_repair_FDE
+ *
+ * PARAMETERS:  Data                - Pointer to validation data structure
+ *              return_object_ptr   - Pointer to the object returned from the
+ *                                    evaluation of a method or object
+ *
+ * RETURN:      Status. AE_OK if object is OK or was repaired successfully
+ *
+ * DESCRIPTION: Repair for the _FDE and _GTM objects. The expected return
+ *              value is a Buffer of 5 DWORDs. This function repairs a common
+ *              problem where the return value is a Buffer of BYTEs, not
+ *              DWORDs.
+ *
+ *****************************************************************************/
+
+static acpi_status
+acpi_ns_repair_FDE(struct acpi_predefined_data *data,
+		   union acpi_operand_object **return_object_ptr)
+{
+	union acpi_operand_object *return_object = *return_object_ptr;
+	union acpi_operand_object *buffer_object;
+	u8 *byte_buffer;
+	u32 *dword_buffer;
+	u32 i;
+
+	ACPI_FUNCTION_NAME(ns_repair_FDE);
+
+	switch (return_object->common.type) {
+	case ACPI_TYPE_BUFFER:
+
+		/* This is the expected type. Length should be (at least) 5 DWORDs */
+
+		if (return_object->buffer.length >= ACPI_FDE_DWORD_BUFFER_SIZE) {
+			return (AE_OK);
+		}
+
+		/* We can only repair if we have exactly 5 BYTEs */
+
+		if (return_object->buffer.length != ACPI_FDE_BYTE_BUFFER_SIZE) {
+			ACPI_WARN_PREDEFINED((AE_INFO, data->pathname,
+					      data->node_flags,
+					      "Incorrect return buffer length %u, expected %u",
+					      return_object->buffer.length,
+					      ACPI_FDE_DWORD_BUFFER_SIZE));
+
+			return (AE_AML_OPERAND_TYPE);
+		}
+
+		/* Create the new (larger) buffer object */
+
+		buffer_object =
+		    acpi_ut_create_buffer_object(ACPI_FDE_DWORD_BUFFER_SIZE);
+		if (!buffer_object) {
+			return (AE_NO_MEMORY);
+		}
+
+		/* Expand each byte to a DWORD */
+
+		byte_buffer = return_object->buffer.pointer;
+		dword_buffer =
+		    ACPI_CAST_PTR(u32, buffer_object->buffer.pointer);
+
+		for (i = 0; i < ACPI_FDE_FIELD_COUNT; i++) {
+			*dword_buffer = (u32)*byte_buffer;
+			dword_buffer++;
+			byte_buffer++;
+		}
+
+		ACPI_DEBUG_PRINT((ACPI_DB_REPAIR,
+				  "%s Expanded Byte Buffer to expected DWord Buffer\n",
+				  data->pathname));
+		break;
+
+	default:
+		return (AE_AML_OPERAND_TYPE);
+	}
+
+	/* Delete the original return object, return the new buffer object */
+
+	acpi_ut_remove_reference(return_object);
+	*return_object_ptr = buffer_object;
+
+	data->flags |= ACPI_OBJECT_REPAIRED;
+	return (AE_OK);
+}
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_repair_CID
+ *
+ * PARAMETERS:  Data                - Pointer to validation data structure
+ *              return_object_ptr   - Pointer to the object returned from the
+ *                                    evaluation of a method or object
+ *
+ * RETURN:      Status. AE_OK if object is OK or was repaired successfully
+ *
+ * DESCRIPTION: Repair for the _CID object. If a string, ensure that all
+ *              letters are uppercase and that there is no leading asterisk.
+ *              If a Package, ensure same for all string elements.
+ *
+ *****************************************************************************/
+
+static acpi_status
+acpi_ns_repair_CID(struct acpi_predefined_data *data,
+		   union acpi_operand_object **return_object_ptr)
+{
+	acpi_status status;
+	union acpi_operand_object *return_object = *return_object_ptr;
+	union acpi_operand_object **element_ptr;
+	union acpi_operand_object *original_element;
+	u16 original_ref_count;
+	u32 i;
+
+	/* Check for _CID as a simple string */
+
+	if (return_object->common.type == ACPI_TYPE_STRING) {
+		status = acpi_ns_repair_HID(data, return_object_ptr);
+		return (status);
+	}
+
+	/* Exit if not a Package */
+
+	if (return_object->common.type != ACPI_TYPE_PACKAGE) {
+		return (AE_OK);
+	}
+
+	/* Examine each element of the _CID package */
+
+	element_ptr = return_object->package.elements;
+	for (i = 0; i < return_object->package.count; i++) {
+		original_element = *element_ptr;
+		original_ref_count = original_element->common.reference_count;
+
+		status = acpi_ns_repair_HID(data, element_ptr);
+		if (ACPI_FAILURE(status)) {
+			return (status);
+		}
+
+		/* Take care with reference counts */
+
+		if (original_element != *element_ptr) {
+
+			/* Element was replaced */
+
+			(*element_ptr)->common.reference_count =
+			    original_ref_count;
+
+			acpi_ut_remove_reference(original_element);
+		}
+
+		element_ptr++;
+	}
+
+	return (AE_OK);
+}
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_repair_HID
+ *
+ * PARAMETERS:  Data                - Pointer to validation data structure
+ *              return_object_ptr   - Pointer to the object returned from the
+ *                                    evaluation of a method or object
+ *
+ * RETURN:      Status. AE_OK if object is OK or was repaired successfully
+ *
+ * DESCRIPTION: Repair for the _HID object. If a string, ensure that all
+ *              letters are uppercase and that there is no leading asterisk.
+ *
+ *****************************************************************************/
+
+static acpi_status
+acpi_ns_repair_HID(struct acpi_predefined_data *data,
+		   union acpi_operand_object **return_object_ptr)
+{
+	union acpi_operand_object *return_object = *return_object_ptr;
+	union acpi_operand_object *new_string;
+	char *source;
+	char *dest;
+
+	ACPI_FUNCTION_NAME(ns_repair_HID);
+
+	/* We only care about string _HID objects (not integers) */
+
+	if (return_object->common.type != ACPI_TYPE_STRING) {
+		return (AE_OK);
+	}
+
+	if (return_object->string.length == 0) {
+		ACPI_WARN_PREDEFINED((AE_INFO, data->pathname, data->node_flags,
+				      "Invalid zero-length _HID or _CID string"));
+
+		/* Return AE_OK anyway, let driver handle it */
+
+		data->flags |= ACPI_OBJECT_REPAIRED;
+		return (AE_OK);
+	}
+
+	/* It is simplest to always create a new string object */
+
+	new_string = acpi_ut_create_string_object(return_object->string.length);
+	if (!new_string) {
+		return (AE_NO_MEMORY);
+	}
+
+	/*
+	 * Remove a leading asterisk if present. For some unknown reason, there
+	 * are many machines in the field that contains IDs like this.
+	 *
+	 * Examples: "*PNP0C03", "*ACPI0003"
+	 */
+	source = return_object->string.pointer;
+	if (*source == '*') {
+		source++;
+		new_string->string.length--;
+
+		ACPI_DEBUG_PRINT((ACPI_DB_REPAIR,
+				  "%s: Removed invalid leading asterisk\n",
+				  data->pathname));
+	}
+
+	/*
+	 * Copy and uppercase the string. From the ACPI 5.0 specification:
+	 *
+	 * A valid PNP ID must be of the form "AAA####" where A is an uppercase
+	 * letter and # is a hex digit. A valid ACPI ID must be of the form
+	 * "NNNN####" where N is an uppercase letter or decimal digit, and
+	 * # is a hex digit.
+	 */
+	for (dest = new_string->string.pointer; *source; dest++, source++) {
+		*dest = (char)ACPI_TOUPPER(*source);
+	}
+
+	acpi_ut_remove_reference(return_object);
+	*return_object_ptr = new_string;
+	return (AE_OK);
+}
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_repair_TSS
+ *
+ * PARAMETERS:  Data                - Pointer to validation data structure
+ *              return_object_ptr   - Pointer to the object returned from the
+ *                                    evaluation of a method or object
+ *
+ * RETURN:      Status. AE_OK if object is OK or was repaired successfully
+ *
+ * DESCRIPTION: Repair for the _TSS object. If necessary, sort the object list
+ *              descending by the power dissipation values.
+ *
+ *****************************************************************************/
+
+static acpi_status
+acpi_ns_repair_TSS(struct acpi_predefined_data *data,
+		   union acpi_operand_object **return_object_ptr)
+{
+	union acpi_operand_object *return_object = *return_object_ptr;
+	acpi_status status;
+	struct acpi_namespace_node *node;
+
+	/*
+	 * We can only sort the _TSS return package if there is no _PSS in the
+	 * same scope. This is because if _PSS is present, the ACPI specification
+	 * dictates that the _TSS Power Dissipation field is to be ignored, and
+	 * therefore some BIOSs leave garbage values in the _TSS Power field(s).
+	 * In this case, it is best to just return the _TSS package as-is.
+	 * (May, 2011)
+	 */
+	status =
+	    acpi_ns_get_node(data->node, "^_PSS", ACPI_NS_NO_UPSEARCH, &node);
+	if (ACPI_SUCCESS(status)) {
+		return (AE_OK);
+	}
+
+	status = acpi_ns_check_sorted_list(data, return_object, 5, 1,
+					   ACPI_SORT_DESCENDING,
+					   "PowerDissipation");
+
+	return (status);
+}
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_repair_PSS
+ *
+ * PARAMETERS:  Data                - Pointer to validation data structure
+ *              return_object_ptr   - Pointer to the object returned from the
+ *                                    evaluation of a method or object
+ *
+ * RETURN:      Status. AE_OK if object is OK or was repaired successfully
+ *
+ * DESCRIPTION: Repair for the _PSS object. If necessary, sort the object list
+ *              by the CPU frequencies. Check that the power dissipation values
+ *              are all proportional to CPU frequency (i.e., sorting by
+ *              frequency should be the same as sorting by power.)
+ *
+ *****************************************************************************/
+
+static acpi_status
+acpi_ns_repair_PSS(struct acpi_predefined_data *data,
+		   union acpi_operand_object **return_object_ptr)
+{
+	union acpi_operand_object *return_object = *return_object_ptr;
+	union acpi_operand_object **outer_elements;
+	u32 outer_element_count;
+	union acpi_operand_object **elements;
+	union acpi_operand_object *obj_desc;
+	u32 previous_value;
+	acpi_status status;
+	u32 i;
+
+	/*
+	 * Entries (sub-packages) in the _PSS Package must be sorted by power
+	 * dissipation, in descending order. If it appears that the list is
+	 * incorrectly sorted, sort it. We sort by cpu_frequency, since this
+	 * should be proportional to the power.
+	 */
+	status = acpi_ns_check_sorted_list(data, return_object, 6, 0,
+					   ACPI_SORT_DESCENDING,
+					   "CpuFrequency");
+	if (ACPI_FAILURE(status)) {
+		return (status);
+	}
+
+	/*
+	 * We now know the list is correctly sorted by CPU frequency. Check if
+	 * the power dissipation values are proportional.
+	 */
+	previous_value = ACPI_UINT32_MAX;
+	outer_elements = return_object->package.elements;
+	outer_element_count = return_object->package.count;
+
+	for (i = 0; i < outer_element_count; i++) {
+		elements = (*outer_elements)->package.elements;
+		obj_desc = elements[1];	/* Index1 = power_dissipation */
+
+		if ((u32)obj_desc->integer.value > previous_value) {
+			ACPI_WARN_PREDEFINED((AE_INFO, data->pathname,
+					      data->node_flags,
+					      "SubPackage[%u,%u] - suspicious power dissipation values",
+					      i - 1, i));
+		}
+
+		previous_value = (u32)obj_desc->integer.value;
+		outer_elements++;
+	}
+
+	return (AE_OK);
+}
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_check_sorted_list
+ *
+ * PARAMETERS:  Data                - Pointer to validation data structure
+ *              return_object       - Pointer to the top-level returned object
+ *              expected_count      - Minimum length of each sub-package
+ *              sort_index          - Sub-package entry to sort on
+ *              sort_direction      - Ascending or descending
+ *              sort_key_name       - Name of the sort_index field
+ *
+ * RETURN:      Status. AE_OK if the list is valid and is sorted correctly or
+ *              has been repaired by sorting the list.
+ *
+ * DESCRIPTION: Check if the package list is valid and sorted correctly by the
+ *              sort_index. If not, then sort the list.
+ *
+ *****************************************************************************/
+
+static acpi_status
+acpi_ns_check_sorted_list(struct acpi_predefined_data *data,
+			  union acpi_operand_object *return_object,
+			  u32 expected_count,
+			  u32 sort_index,
+			  u8 sort_direction, char *sort_key_name)
+{
+	u32 outer_element_count;
+	union acpi_operand_object **outer_elements;
+	union acpi_operand_object **elements;
+	union acpi_operand_object *obj_desc;
+	u32 i;
+	u32 previous_value;
+
+	ACPI_FUNCTION_NAME(ns_check_sorted_list);
+
+	/* The top-level object must be a package */
+
+	if (return_object->common.type != ACPI_TYPE_PACKAGE) {
+		return (AE_AML_OPERAND_TYPE);
+	}
+
+	/*
+	 * NOTE: assumes list of sub-packages contains no NULL elements.
+	 * Any NULL elements should have been removed by earlier call
+	 * to acpi_ns_remove_null_elements.
+	 */
+	outer_elements = return_object->package.elements;
+	outer_element_count = return_object->package.count;
+	if (!outer_element_count) {
+		return (AE_AML_PACKAGE_LIMIT);
+	}
+
+	previous_value = 0;
+	if (sort_direction == ACPI_SORT_DESCENDING) {
+		previous_value = ACPI_UINT32_MAX;
+	}
+
+	/* Examine each subpackage */
+
+	for (i = 0; i < outer_element_count; i++) {
+
+		/* Each element of the top-level package must also be a package */
+
+		if ((*outer_elements)->common.type != ACPI_TYPE_PACKAGE) {
+			return (AE_AML_OPERAND_TYPE);
+		}
+
+		/* Each sub-package must have the minimum length */
+
+		if ((*outer_elements)->package.count < expected_count) {
+			return (AE_AML_PACKAGE_LIMIT);
+		}
+
+		elements = (*outer_elements)->package.elements;
+		obj_desc = elements[sort_index];
+
+		if (obj_desc->common.type != ACPI_TYPE_INTEGER) {
+			return (AE_AML_OPERAND_TYPE);
+		}
+
+		/*
+		 * The list must be sorted in the specified order. If we detect a
+		 * discrepancy, sort the entire list.
+		 */
+		if (((sort_direction == ACPI_SORT_ASCENDING) &&
+		     (obj_desc->integer.value < previous_value)) ||
+		    ((sort_direction == ACPI_SORT_DESCENDING) &&
+		     (obj_desc->integer.value > previous_value))) {
+			acpi_ns_sort_list(return_object->package.elements,
+					  outer_element_count, sort_index,
+					  sort_direction);
+
+			data->flags |= ACPI_OBJECT_REPAIRED;
+
+			ACPI_DEBUG_PRINT((ACPI_DB_REPAIR,
+					  "%s: Repaired unsorted list - now sorted by %s\n",
+					  data->pathname, sort_key_name));
+			return (AE_OK);
+		}
+
+		previous_value = (u32)obj_desc->integer.value;
+		outer_elements++;
+	}
+
+	return (AE_OK);
+}
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_sort_list
+ *
+ * PARAMETERS:  Elements            - Package object element list
+ *              Count               - Element count for above
+ *              Index               - Sort by which package element
+ *              sort_direction      - Ascending or Descending sort
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Sort the objects that are in a package element list.
+ *
+ * NOTE: Assumes that all NULL elements have been removed from the package,
+ *       and that all elements have been verified to be of type Integer.
+ *
+ *****************************************************************************/
+
+static void
+acpi_ns_sort_list(union acpi_operand_object **elements,
+		  u32 count, u32 index, u8 sort_direction)
+{
+	union acpi_operand_object *obj_desc1;
+	union acpi_operand_object *obj_desc2;
+	union acpi_operand_object *temp_obj;
+	u32 i;
+	u32 j;
+
+	/* Simple bubble sort */
+
+	for (i = 1; i < count; i++) {
+		for (j = (count - 1); j >= i; j--) {
+			obj_desc1 = elements[j - 1]->package.elements[index];
+			obj_desc2 = elements[j]->package.elements[index];
+
+			if (((sort_direction == ACPI_SORT_ASCENDING) &&
+			     (obj_desc1->integer.value >
+			      obj_desc2->integer.value))
+			    || ((sort_direction == ACPI_SORT_DESCENDING)
+				&& (obj_desc1->integer.value <
+				    obj_desc2->integer.value))) {
+				temp_obj = elements[j - 1];
+				elements[j - 1] = elements[j];
+				elements[j] = temp_obj;
+			}
+		}
+	}
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nssearch.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nssearch.c
new file mode 100644
index 00000000..6d3cb990
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nssearch.c
@@ -0,0 +1,399 @@
+/*******************************************************************************
+ *
+ * Module Name: nssearch - Namespace search
+ *
+ ******************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acnamesp.h"
+
+#ifdef ACPI_ASL_COMPILER
+#include "amlcode.h"
+#endif
+
+#define _COMPONENT          ACPI_NAMESPACE
+ACPI_MODULE_NAME("nssearch")
+
+/* Local prototypes */
+static acpi_status
+acpi_ns_search_parent_tree(u32 target_name,
+			   struct acpi_namespace_node *node,
+			   acpi_object_type type,
+			   struct acpi_namespace_node **return_node);
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_search_one_scope
+ *
+ * PARAMETERS:  target_name     - Ascii ACPI name to search for
+ *              parent_node     - Starting node where search will begin
+ *              Type            - Object type to match
+ *              return_node     - Where the matched Named obj is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Search a single level of the namespace. Performs a
+ *              simple search of the specified level, and does not add
+ *              entries or search parents.
+ *
+ *
+ *      Named object lists are built (and subsequently dumped) in the
+ *      order in which the names are encountered during the namespace load;
+ *
+ *      All namespace searching is linear in this implementation, but
+ *      could be easily modified to support any improved search
+ *      algorithm. However, the linear search was chosen for simplicity
+ *      and because the trees are small and the other interpreter
+ *      execution overhead is relatively high.
+ *
+ *      Note: CPU execution analysis has shown that the AML interpreter spends
+ *      a very small percentage of its time searching the namespace. Therefore,
+ *      the linear search seems to be sufficient, as there would seem to be
+ *      little value in improving the search.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ns_search_one_scope(u32 target_name,
+			 struct acpi_namespace_node *parent_node,
+			 acpi_object_type type,
+			 struct acpi_namespace_node **return_node)
+{
+	struct acpi_namespace_node *node;
+
+	ACPI_FUNCTION_TRACE(ns_search_one_scope);
+
+#ifdef ACPI_DEBUG_OUTPUT
+	if (ACPI_LV_NAMES & acpi_dbg_level) {
+		char *scope_name;
+
+		scope_name = acpi_ns_get_external_pathname(parent_node);
+		if (scope_name) {
+			ACPI_DEBUG_PRINT((ACPI_DB_NAMES,
+					  "Searching %s (%p) For [%4.4s] (%s)\n",
+					  scope_name, parent_node,
+					  ACPI_CAST_PTR(char, &target_name),
+					  acpi_ut_get_type_name(type)));
+
+			ACPI_FREE(scope_name);
+		}
+	}
+#endif
+
+	/*
+	 * Search for name at this namespace level, which is to say that we
+	 * must search for the name among the children of this object
+	 */
+	node = parent_node->child;
+	while (node) {
+
+		/* Check for match against the name */
+
+		if (node->name.integer == target_name) {
+
+			/* Resolve a control method alias if any */
+
+			if (acpi_ns_get_type(node) ==
+			    ACPI_TYPE_LOCAL_METHOD_ALIAS) {
+				node =
+				    ACPI_CAST_PTR(struct acpi_namespace_node,
+						  node->object);
+			}
+
+			/* Found matching entry */
+
+			ACPI_DEBUG_PRINT((ACPI_DB_NAMES,
+					  "Name [%4.4s] (%s) %p found in scope [%4.4s] %p\n",
+					  ACPI_CAST_PTR(char, &target_name),
+					  acpi_ut_get_type_name(node->type),
+					  node,
+					  acpi_ut_get_node_name(parent_node),
+					  parent_node));
+
+			*return_node = node;
+			return_ACPI_STATUS(AE_OK);
+		}
+
+		/* Didn't match name, move on to the next peer object */
+
+		node = node->peer;
+	}
+
+	/* Searched entire namespace level, not found */
+
+	ACPI_DEBUG_PRINT((ACPI_DB_NAMES,
+			  "Name [%4.4s] (%s) not found in search in scope [%4.4s] "
+			  "%p first child %p\n",
+			  ACPI_CAST_PTR(char, &target_name),
+			  acpi_ut_get_type_name(type),
+			  acpi_ut_get_node_name(parent_node), parent_node,
+			  parent_node->child));
+
+	return_ACPI_STATUS(AE_NOT_FOUND);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_search_parent_tree
+ *
+ * PARAMETERS:  target_name     - Ascii ACPI name to search for
+ *              Node            - Starting node where search will begin
+ *              Type            - Object type to match
+ *              return_node     - Where the matched Node is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Called when a name has not been found in the current namespace
+ *              level. Before adding it or giving up, ACPI scope rules require
+ *              searching enclosing scopes in cases identified by acpi_ns_local().
+ *
+ *              "A name is located by finding the matching name in the current
+ *              name space, and then in the parent name space. If the parent
+ *              name space does not contain the name, the search continues
+ *              recursively until either the name is found or the name space
+ *              does not have a parent (the root of the name space). This
+ *              indicates that the name is not found" (From ACPI Specification,
+ *              section 5.3)
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ns_search_parent_tree(u32 target_name,
+			   struct acpi_namespace_node *node,
+			   acpi_object_type type,
+			   struct acpi_namespace_node **return_node)
+{
+	acpi_status status;
+	struct acpi_namespace_node *parent_node;
+
+	ACPI_FUNCTION_TRACE(ns_search_parent_tree);
+
+	parent_node = node->parent;
+
+	/*
+	 * If there is no parent (i.e., we are at the root) or type is "local",
+	 * we won't be searching the parent tree.
+	 */
+	if (!parent_node) {
+		ACPI_DEBUG_PRINT((ACPI_DB_NAMES, "[%4.4s] has no parent\n",
+				  ACPI_CAST_PTR(char, &target_name)));
+		return_ACPI_STATUS(AE_NOT_FOUND);
+	}
+
+	if (acpi_ns_local(type)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_NAMES,
+				  "[%4.4s] type [%s] must be local to this scope (no parent search)\n",
+				  ACPI_CAST_PTR(char, &target_name),
+				  acpi_ut_get_type_name(type)));
+		return_ACPI_STATUS(AE_NOT_FOUND);
+	}
+
+	/* Search the parent tree */
+
+	ACPI_DEBUG_PRINT((ACPI_DB_NAMES,
+			  "Searching parent [%4.4s] for [%4.4s]\n",
+			  acpi_ut_get_node_name(parent_node),
+			  ACPI_CAST_PTR(char, &target_name)));
+
+	/* Search parents until target is found or we have backed up to the root */
+
+	while (parent_node) {
+		/*
+		 * Search parent scope. Use TYPE_ANY because we don't care about the
+		 * object type at this point, we only care about the existence of
+		 * the actual name we are searching for. Typechecking comes later.
+		 */
+		status =
+		    acpi_ns_search_one_scope(target_name, parent_node,
+					     ACPI_TYPE_ANY, return_node);
+		if (ACPI_SUCCESS(status)) {
+			return_ACPI_STATUS(status);
+		}
+
+		/* Not found here, go up another level (until we reach the root) */
+
+		parent_node = parent_node->parent;
+	}
+
+	/* Not found in parent tree */
+
+	return_ACPI_STATUS(AE_NOT_FOUND);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_search_and_enter
+ *
+ * PARAMETERS:  target_name         - Ascii ACPI name to search for (4 chars)
+ *              walk_state          - Current state of the walk
+ *              Node                - Starting node where search will begin
+ *              interpreter_mode    - Add names only in ACPI_MODE_LOAD_PASS_x.
+ *                                    Otherwise,search only.
+ *              Type                - Object type to match
+ *              Flags               - Flags describing the search restrictions
+ *              return_node         - Where the Node is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Search for a name segment in a single namespace level,
+ *              optionally adding it if it is not found. If the passed
+ *              Type is not Any and the type previously stored in the
+ *              entry was Any (i.e. unknown), update the stored type.
+ *
+ *              In ACPI_IMODE_EXECUTE, search only.
+ *              In other modes, search and add if not found.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ns_search_and_enter(u32 target_name,
+			 struct acpi_walk_state *walk_state,
+			 struct acpi_namespace_node *node,
+			 acpi_interpreter_mode interpreter_mode,
+			 acpi_object_type type,
+			 u32 flags, struct acpi_namespace_node **return_node)
+{
+	acpi_status status;
+	struct acpi_namespace_node *new_node;
+
+	ACPI_FUNCTION_TRACE(ns_search_and_enter);
+
+	/* Parameter validation */
+
+	if (!node || !target_name || !return_node) {
+		ACPI_ERROR((AE_INFO,
+			    "Null parameter: Node %p Name 0x%X ReturnNode %p",
+			    node, target_name, return_node));
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	/*
+	 * Name must consist of valid ACPI characters. We will repair the name if
+	 * necessary because we don't want to abort because of this, but we want
+	 * all namespace names to be printable. A warning message is appropriate.
+	 *
+	 * This issue came up because there are in fact machines that exhibit
+	 * this problem, and we want to be able to enable ACPI support for them,
+	 * even though there are a few bad names.
+	 */
+	acpi_ut_repair_name(ACPI_CAST_PTR(char, &target_name));
+
+	/* Try to find the name in the namespace level specified by the caller */
+
+	*return_node = ACPI_ENTRY_NOT_FOUND;
+	status = acpi_ns_search_one_scope(target_name, node, type, return_node);
+	if (status != AE_NOT_FOUND) {
+		/*
+		 * If we found it AND the request specifies that a find is an error,
+		 * return the error
+		 */
+		if ((status == AE_OK) && (flags & ACPI_NS_ERROR_IF_FOUND)) {
+			status = AE_ALREADY_EXISTS;
+		}
+#ifdef ACPI_ASL_COMPILER
+		if (*return_node && (*return_node)->type == ACPI_TYPE_ANY) {
+			(*return_node)->flags |= ANOBJ_IS_EXTERNAL;
+		}
+#endif
+
+		/* Either found it or there was an error: finished either way */
+
+		return_ACPI_STATUS(status);
+	}
+
+	/*
+	 * The name was not found. If we are NOT performing the first pass
+	 * (name entry) of loading the namespace, search the parent tree (all the
+	 * way to the root if necessary.) We don't want to perform the parent
+	 * search when the namespace is actually being loaded. We want to perform
+	 * the search when namespace references are being resolved (load pass 2)
+	 * and during the execution phase.
+	 */
+	if ((interpreter_mode != ACPI_IMODE_LOAD_PASS1) &&
+	    (flags & ACPI_NS_SEARCH_PARENT)) {
+		/*
+		 * Not found at this level - search parent tree according to the
+		 * ACPI specification
+		 */
+		status =
+		    acpi_ns_search_parent_tree(target_name, node, type,
+					       return_node);
+		if (ACPI_SUCCESS(status)) {
+			return_ACPI_STATUS(status);
+		}
+	}
+
+	/* In execute mode, just search, never add names. Exit now */
+
+	if (interpreter_mode == ACPI_IMODE_EXECUTE) {
+		ACPI_DEBUG_PRINT((ACPI_DB_NAMES,
+				  "%4.4s Not found in %p [Not adding]\n",
+				  ACPI_CAST_PTR(char, &target_name), node));
+
+		return_ACPI_STATUS(AE_NOT_FOUND);
+	}
+
+	/* Create the new named object */
+
+	new_node = acpi_ns_create_node(target_name);
+	if (!new_node) {
+		return_ACPI_STATUS(AE_NO_MEMORY);
+	}
+#ifdef ACPI_ASL_COMPILER
+
+	/* Node is an object defined by an External() statement */
+
+	if (flags & ACPI_NS_EXTERNAL ||
+	    (walk_state && walk_state->opcode == AML_SCOPE_OP)) {
+		new_node->flags |= ANOBJ_IS_EXTERNAL;
+	}
+#endif
+
+	if (flags & ACPI_NS_TEMPORARY) {
+		new_node->flags |= ANOBJ_TEMPORARY;
+	}
+
+	/* Install the new object into the parent's list of children */
+
+	acpi_ns_install_node(walk_state, node, new_node, type);
+	*return_node = new_node;
+	return_ACPI_STATUS(AE_OK);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nsutils.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nsutils.c
new file mode 100644
index 00000000..914358c4
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nsutils.c
@@ -0,0 +1,750 @@
+/******************************************************************************
+ *
+ * Module Name: nsutils - Utilities for accessing ACPI namespace, accessing
+ *                        parents and siblings and Scope manipulation
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acnamesp.h"
+#include "amlcode.h"
+
+#define _COMPONENT          ACPI_NAMESPACE
+ACPI_MODULE_NAME("nsutils")
+
+/* Local prototypes */
+static u8 acpi_ns_valid_path_separator(char sep);
+
+#ifdef ACPI_OBSOLETE_FUNCTIONS
+acpi_name acpi_ns_find_parent_name(struct acpi_namespace_node *node_to_search);
+#endif
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_print_node_pathname
+ *
+ * PARAMETERS:  Node            - Object
+ *              Message         - Prefix message
+ *
+ * DESCRIPTION: Print an object's full namespace pathname
+ *              Manages allocation/freeing of a pathname buffer
+ *
+ ******************************************************************************/
+
+void
+acpi_ns_print_node_pathname(struct acpi_namespace_node *node,
+			    const char *message)
+{
+	struct acpi_buffer buffer;
+	acpi_status status;
+
+	if (!node) {
+		acpi_os_printf("[NULL NAME]");
+		return;
+	}
+
+	/* Convert handle to full pathname and print it (with supplied message) */
+
+	buffer.length = ACPI_ALLOCATE_LOCAL_BUFFER;
+
+	status = acpi_ns_handle_to_pathname(node, &buffer);
+	if (ACPI_SUCCESS(status)) {
+		if (message) {
+			acpi_os_printf("%s ", message);
+		}
+
+		acpi_os_printf("[%s] (Node %p)", (char *)buffer.pointer, node);
+		ACPI_FREE(buffer.pointer);
+	}
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_valid_root_prefix
+ *
+ * PARAMETERS:  Prefix          - Character to be checked
+ *
+ * RETURN:      TRUE if a valid prefix
+ *
+ * DESCRIPTION: Check if a character is a valid ACPI Root prefix
+ *
+ ******************************************************************************/
+
+u8 acpi_ns_valid_root_prefix(char prefix)
+{
+
+	return ((u8)(prefix == '\\'));
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_valid_path_separator
+ *
+ * PARAMETERS:  Sep         - Character to be checked
+ *
+ * RETURN:      TRUE if a valid path separator
+ *
+ * DESCRIPTION: Check if a character is a valid ACPI path separator
+ *
+ ******************************************************************************/
+
+static u8 acpi_ns_valid_path_separator(char sep)
+{
+
+	return ((u8)(sep == '.'));
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_get_type
+ *
+ * PARAMETERS:  Node        - Parent Node to be examined
+ *
+ * RETURN:      Type field from Node whose handle is passed
+ *
+ * DESCRIPTION: Return the type of a Namespace node
+ *
+ ******************************************************************************/
+
+acpi_object_type acpi_ns_get_type(struct acpi_namespace_node *node)
+{
+	ACPI_FUNCTION_TRACE(ns_get_type);
+
+	if (!node) {
+		ACPI_WARNING((AE_INFO, "Null Node parameter"));
+		return_UINT32(ACPI_TYPE_ANY);
+	}
+
+	return_UINT32((acpi_object_type) node->type);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_local
+ *
+ * PARAMETERS:  Type        - A namespace object type
+ *
+ * RETURN:      LOCAL if names must be found locally in objects of the
+ *              passed type, 0 if enclosing scopes should be searched
+ *
+ * DESCRIPTION: Returns scope rule for the given object type.
+ *
+ ******************************************************************************/
+
+u32 acpi_ns_local(acpi_object_type type)
+{
+	ACPI_FUNCTION_TRACE(ns_local);
+
+	if (!acpi_ut_valid_object_type(type)) {
+
+		/* Type code out of range  */
+
+		ACPI_WARNING((AE_INFO, "Invalid Object Type 0x%X", type));
+		return_UINT32(ACPI_NS_NORMAL);
+	}
+
+	return_UINT32((u32)acpi_gbl_ns_properties[type] & ACPI_NS_LOCAL);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_get_internal_name_length
+ *
+ * PARAMETERS:  Info            - Info struct initialized with the
+ *                                external name pointer.
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Calculate the length of the internal (AML) namestring
+ *              corresponding to the external (ASL) namestring.
+ *
+ ******************************************************************************/
+
+void acpi_ns_get_internal_name_length(struct acpi_namestring_info *info)
+{
+	const char *next_external_char;
+	u32 i;
+
+	ACPI_FUNCTION_ENTRY();
+
+	next_external_char = info->external_name;
+	info->num_carats = 0;
+	info->num_segments = 0;
+	info->fully_qualified = FALSE;
+
+	/*
+	 * For the internal name, the required length is 4 bytes per segment, plus
+	 * 1 each for root_prefix, multi_name_prefix_op, segment count, trailing null
+	 * (which is not really needed, but no there's harm in putting it there)
+	 *
+	 * strlen() + 1 covers the first name_seg, which has no path separator
+	 */
+	if (acpi_ns_valid_root_prefix(*next_external_char)) {
+		info->fully_qualified = TRUE;
+		next_external_char++;
+
+		/* Skip redundant root_prefix, like \\_SB.PCI0.SBRG.EC0 */
+
+		while (acpi_ns_valid_root_prefix(*next_external_char)) {
+			next_external_char++;
+		}
+	} else {
+		/* Handle Carat prefixes */
+
+		while (*next_external_char == '^') {
+			info->num_carats++;
+			next_external_char++;
+		}
+	}
+
+	/*
+	 * Determine the number of ACPI name "segments" by counting the number of
+	 * path separators within the string. Start with one segment since the
+	 * segment count is [(# separators) + 1], and zero separators is ok.
+	 */
+	if (*next_external_char) {
+		info->num_segments = 1;
+		for (i = 0; next_external_char[i]; i++) {
+			if (acpi_ns_valid_path_separator(next_external_char[i])) {
+				info->num_segments++;
+			}
+		}
+	}
+
+	info->length = (ACPI_NAME_SIZE * info->num_segments) +
+	    4 + info->num_carats;
+
+	info->next_external_char = next_external_char;
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_build_internal_name
+ *
+ * PARAMETERS:  Info            - Info struct fully initialized
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Construct the internal (AML) namestring
+ *              corresponding to the external (ASL) namestring.
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ns_build_internal_name(struct acpi_namestring_info *info)
+{
+	u32 num_segments = info->num_segments;
+	char *internal_name = info->internal_name;
+	const char *external_name = info->next_external_char;
+	char *result = NULL;
+	u32 i;
+
+	ACPI_FUNCTION_TRACE(ns_build_internal_name);
+
+	/* Setup the correct prefixes, counts, and pointers */
+
+	if (info->fully_qualified) {
+		internal_name[0] = '\\';
+
+		if (num_segments <= 1) {
+			result = &internal_name[1];
+		} else if (num_segments == 2) {
+			internal_name[1] = AML_DUAL_NAME_PREFIX;
+			result = &internal_name[2];
+		} else {
+			internal_name[1] = AML_MULTI_NAME_PREFIX_OP;
+			internal_name[2] = (char)num_segments;
+			result = &internal_name[3];
+		}
+	} else {
+		/*
+		 * Not fully qualified.
+		 * Handle Carats first, then append the name segments
+		 */
+		i = 0;
+		if (info->num_carats) {
+			for (i = 0; i < info->num_carats; i++) {
+				internal_name[i] = '^';
+			}
+		}
+
+		if (num_segments <= 1) {
+			result = &internal_name[i];
+		} else if (num_segments == 2) {
+			internal_name[i] = AML_DUAL_NAME_PREFIX;
+			result = &internal_name[(acpi_size) i + 1];
+		} else {
+			internal_name[i] = AML_MULTI_NAME_PREFIX_OP;
+			internal_name[(acpi_size) i + 1] = (char)num_segments;
+			result = &internal_name[(acpi_size) i + 2];
+		}
+	}
+
+	/* Build the name (minus path separators) */
+
+	for (; num_segments; num_segments--) {
+		for (i = 0; i < ACPI_NAME_SIZE; i++) {
+			if (acpi_ns_valid_path_separator(*external_name) ||
+			    (*external_name == 0)) {
+
+				/* Pad the segment with underscore(s) if segment is short */
+
+				result[i] = '_';
+			} else {
+				/* Convert the character to uppercase and save it */
+
+				result[i] =
+				    (char)ACPI_TOUPPER((int)*external_name);
+				external_name++;
+			}
+		}
+
+		/* Now we must have a path separator, or the pathname is bad */
+
+		if (!acpi_ns_valid_path_separator(*external_name) &&
+		    (*external_name != 0)) {
+			return_ACPI_STATUS(AE_BAD_PARAMETER);
+		}
+
+		/* Move on the next segment */
+
+		external_name++;
+		result += ACPI_NAME_SIZE;
+	}
+
+	/* Terminate the string */
+
+	*result = 0;
+
+	if (info->fully_qualified) {
+		ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
+				  "Returning [%p] (abs) \"\\%s\"\n",
+				  internal_name, internal_name));
+	} else {
+		ACPI_DEBUG_PRINT((ACPI_DB_EXEC, "Returning [%p] (rel) \"%s\"\n",
+				  internal_name, internal_name));
+	}
+
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_internalize_name
+ *
+ * PARAMETERS:  *external_name          - External representation of name
+ *              **Converted Name        - Where to return the resulting
+ *                                        internal represention of the name
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Convert an external representation (e.g. "\_PR_.CPU0")
+ *              to internal form (e.g. 5c 2f 02 5f 50 52 5f 43 50 55 30)
+ *
+ *******************************************************************************/
+
+acpi_status
+acpi_ns_internalize_name(const char *external_name, char **converted_name)
+{
+	char *internal_name;
+	struct acpi_namestring_info info;
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(ns_internalize_name);
+
+	if ((!external_name) || (*external_name == 0) || (!converted_name)) {
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	/* Get the length of the new internal name */
+
+	info.external_name = external_name;
+	acpi_ns_get_internal_name_length(&info);
+
+	/* We need a segment to store the internal  name */
+
+	internal_name = ACPI_ALLOCATE_ZEROED(info.length);
+	if (!internal_name) {
+		return_ACPI_STATUS(AE_NO_MEMORY);
+	}
+
+	/* Build the name */
+
+	info.internal_name = internal_name;
+	status = acpi_ns_build_internal_name(&info);
+	if (ACPI_FAILURE(status)) {
+		ACPI_FREE(internal_name);
+		return_ACPI_STATUS(status);
+	}
+
+	*converted_name = internal_name;
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_externalize_name
+ *
+ * PARAMETERS:  internal_name_length - Lenth of the internal name below
+ *              internal_name       - Internal representation of name
+ *              converted_name_length - Where the length is returned
+ *              converted_name      - Where the resulting external name
+ *                                    is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Convert internal name (e.g. 5c 2f 02 5f 50 52 5f 43 50 55 30)
+ *              to its external (printable) form (e.g. "\_PR_.CPU0")
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ns_externalize_name(u32 internal_name_length,
+			 const char *internal_name,
+			 u32 *converted_name_length, char **converted_name)
+{
+	u32 names_index = 0;
+	u32 num_segments = 0;
+	u32 required_length;
+	u32 prefix_length = 0;
+	u32 i = 0;
+	u32 j = 0;
+
+	ACPI_FUNCTION_TRACE(ns_externalize_name);
+
+	if (!internal_name_length || !internal_name || !converted_name) {
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	/* Check for a prefix (one '\' | one or more '^') */
+
+	switch (internal_name[0]) {
+	case '\\':
+		prefix_length = 1;
+		break;
+
+	case '^':
+		for (i = 0; i < internal_name_length; i++) {
+			if (internal_name[i] == '^') {
+				prefix_length = i + 1;
+			} else {
+				break;
+			}
+		}
+
+		if (i == internal_name_length) {
+			prefix_length = i;
+		}
+
+		break;
+
+	default:
+		break;
+	}
+
+	/*
+	 * Check for object names. Note that there could be 0-255 of these
+	 * 4-byte elements.
+	 */
+	if (prefix_length < internal_name_length) {
+		switch (internal_name[prefix_length]) {
+		case AML_MULTI_NAME_PREFIX_OP:
+
+			/* <count> 4-byte names */
+
+			names_index = prefix_length + 2;
+			num_segments = (u8)
+			    internal_name[(acpi_size) prefix_length + 1];
+			break;
+
+		case AML_DUAL_NAME_PREFIX:
+
+			/* Two 4-byte names */
+
+			names_index = prefix_length + 1;
+			num_segments = 2;
+			break;
+
+		case 0:
+
+			/* null_name */
+
+			names_index = 0;
+			num_segments = 0;
+			break;
+
+		default:
+
+			/* one 4-byte name */
+
+			names_index = prefix_length;
+			num_segments = 1;
+			break;
+		}
+	}
+
+	/*
+	 * Calculate the length of converted_name, which equals the length
+	 * of the prefix, length of all object names, length of any required
+	 * punctuation ('.') between object names, plus the NULL terminator.
+	 */
+	required_length = prefix_length + (4 * num_segments) +
+	    ((num_segments > 0) ? (num_segments - 1) : 0) + 1;
+
+	/*
+	 * Check to see if we're still in bounds.  If not, there's a problem
+	 * with internal_name (invalid format).
+	 */
+	if (required_length > internal_name_length) {
+		ACPI_ERROR((AE_INFO, "Invalid internal name"));
+		return_ACPI_STATUS(AE_BAD_PATHNAME);
+	}
+
+	/* Build the converted_name */
+
+	*converted_name = ACPI_ALLOCATE_ZEROED(required_length);
+	if (!(*converted_name)) {
+		return_ACPI_STATUS(AE_NO_MEMORY);
+	}
+
+	j = 0;
+
+	for (i = 0; i < prefix_length; i++) {
+		(*converted_name)[j++] = internal_name[i];
+	}
+
+	if (num_segments > 0) {
+		for (i = 0; i < num_segments; i++) {
+			if (i > 0) {
+				(*converted_name)[j++] = '.';
+			}
+
+			(*converted_name)[j++] = internal_name[names_index++];
+			(*converted_name)[j++] = internal_name[names_index++];
+			(*converted_name)[j++] = internal_name[names_index++];
+			(*converted_name)[j++] = internal_name[names_index++];
+		}
+	}
+
+	if (converted_name_length) {
+		*converted_name_length = (u32)required_length;
+	}
+
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_validate_handle
+ *
+ * PARAMETERS:  Handle          - Handle to be validated and typecast to a
+ *                                namespace node.
+ *
+ * RETURN:      A pointer to a namespace node
+ *
+ * DESCRIPTION: Convert a namespace handle to a namespace node. Handles special
+ *              cases for the root node.
+ *
+ * NOTE: Real integer handles would allow for more verification
+ *       and keep all pointers within this subsystem - however this introduces
+ *       more overhead and has not been necessary to this point. Drivers
+ *       holding handles are typically notified before a node becomes invalid
+ *       due to a table unload.
+ *
+ ******************************************************************************/
+
+struct acpi_namespace_node *acpi_ns_validate_handle(acpi_handle handle)
+{
+
+	ACPI_FUNCTION_ENTRY();
+
+	/* Parameter validation */
+
+	if ((!handle) || (handle == ACPI_ROOT_OBJECT)) {
+		return (acpi_gbl_root_node);
+	}
+
+	/* We can at least attempt to verify the handle */
+
+	if (ACPI_GET_DESCRIPTOR_TYPE(handle) != ACPI_DESC_TYPE_NAMED) {
+		return (NULL);
+	}
+
+	return (ACPI_CAST_PTR(struct acpi_namespace_node, handle));
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_terminate
+ *
+ * PARAMETERS:  none
+ *
+ * RETURN:      none
+ *
+ * DESCRIPTION: free memory allocated for namespace and ACPI table storage.
+ *
+ ******************************************************************************/
+
+void acpi_ns_terminate(void)
+{
+	union acpi_operand_object *obj_desc;
+
+	ACPI_FUNCTION_TRACE(ns_terminate);
+
+	/*
+	 * 1) Free the entire namespace -- all nodes and objects
+	 *
+	 * Delete all object descriptors attached to namepsace nodes
+	 */
+	acpi_ns_delete_namespace_subtree(acpi_gbl_root_node);
+
+	/* Detach any objects attached to the root */
+
+	obj_desc = acpi_ns_get_attached_object(acpi_gbl_root_node);
+	if (obj_desc) {
+		acpi_ns_detach_object(acpi_gbl_root_node);
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Namespace freed\n"));
+	return_VOID;
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_opens_scope
+ *
+ * PARAMETERS:  Type        - A valid namespace type
+ *
+ * RETURN:      NEWSCOPE if the passed type "opens a name scope" according
+ *              to the ACPI specification, else 0
+ *
+ ******************************************************************************/
+
+u32 acpi_ns_opens_scope(acpi_object_type type)
+{
+	ACPI_FUNCTION_TRACE_STR(ns_opens_scope, acpi_ut_get_type_name(type));
+
+	if (!acpi_ut_valid_object_type(type)) {
+
+		/* type code out of range  */
+
+		ACPI_WARNING((AE_INFO, "Invalid Object Type 0x%X", type));
+		return_UINT32(ACPI_NS_NORMAL);
+	}
+
+	return_UINT32(((u32)acpi_gbl_ns_properties[type]) & ACPI_NS_NEWSCOPE);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_get_node
+ *
+ * PARAMETERS:  *Pathname   - Name to be found, in external (ASL) format. The
+ *                            \ (backslash) and ^ (carat) prefixes, and the
+ *                            . (period) to separate segments are supported.
+ *              prefix_node  - Root of subtree to be searched, or NS_ALL for the
+ *                            root of the name space.  If Name is fully
+ *                            qualified (first s8 is '\'), the passed value
+ *                            of Scope will not be accessed.
+ *              Flags       - Used to indicate whether to perform upsearch or
+ *                            not.
+ *              return_node - Where the Node is returned
+ *
+ * DESCRIPTION: Look up a name relative to a given scope and return the
+ *              corresponding Node.  NOTE: Scope can be null.
+ *
+ * MUTEX:       Locks namespace
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ns_get_node(struct acpi_namespace_node *prefix_node,
+		 const char *pathname,
+		 u32 flags, struct acpi_namespace_node **return_node)
+{
+	union acpi_generic_state scope_info;
+	acpi_status status;
+	char *internal_path;
+
+	ACPI_FUNCTION_TRACE_PTR(ns_get_node, ACPI_CAST_PTR(char, pathname));
+
+	if (!pathname) {
+		*return_node = prefix_node;
+		if (!prefix_node) {
+			*return_node = acpi_gbl_root_node;
+		}
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	/* Convert path to internal representation */
+
+	status = acpi_ns_internalize_name(pathname, &internal_path);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/* Must lock namespace during lookup */
+
+	status = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);
+	if (ACPI_FAILURE(status)) {
+		goto cleanup;
+	}
+
+	/* Setup lookup scope (search starting point) */
+
+	scope_info.scope.node = prefix_node;
+
+	/* Lookup the name in the namespace */
+
+	status = acpi_ns_lookup(&scope_info, internal_path, ACPI_TYPE_ANY,
+				ACPI_IMODE_EXECUTE,
+				(flags | ACPI_NS_DONT_OPEN_SCOPE), NULL,
+				return_node);
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_EXEC, "%s, %s\n",
+				  pathname, acpi_format_exception(status)));
+	}
+
+	(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);
+
+      cleanup:
+	ACPI_FREE(internal_path);
+	return_ACPI_STATUS(status);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nswalk.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nswalk.c
new file mode 100644
index 00000000..fb711fb7
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nswalk.c
@@ -0,0 +1,357 @@
+/******************************************************************************
+ *
+ * Module Name: nswalk - Functions for walking the ACPI namespace
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acnamesp.h"
+
+#define _COMPONENT          ACPI_NAMESPACE
+ACPI_MODULE_NAME("nswalk")
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_get_next_node
+ *
+ * PARAMETERS:  parent_node         - Parent node whose children we are
+ *                                    getting
+ *              child_node          - Previous child that was found.
+ *                                    The NEXT child will be returned
+ *
+ * RETURN:      struct acpi_namespace_node - Pointer to the NEXT child or NULL if
+ *                                    none is found.
+ *
+ * DESCRIPTION: Return the next peer node within the namespace.  If Handle
+ *              is valid, Scope is ignored.  Otherwise, the first node
+ *              within Scope is returned.
+ *
+ ******************************************************************************/
+struct acpi_namespace_node *acpi_ns_get_next_node(struct acpi_namespace_node
+						  *parent_node,
+						  struct acpi_namespace_node
+						  *child_node)
+{
+	ACPI_FUNCTION_ENTRY();
+
+	if (!child_node) {
+
+		/* It's really the parent's _scope_ that we want */
+
+		return (parent_node->child);
+	}
+
+	/* Otherwise just return the next peer */
+
+	return (child_node->peer);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_get_next_node_typed
+ *
+ * PARAMETERS:  Type                - Type of node to be searched for
+ *              parent_node         - Parent node whose children we are
+ *                                    getting
+ *              child_node          - Previous child that was found.
+ *                                    The NEXT child will be returned
+ *
+ * RETURN:      struct acpi_namespace_node - Pointer to the NEXT child or NULL if
+ *                                    none is found.
+ *
+ * DESCRIPTION: Return the next peer node within the namespace.  If Handle
+ *              is valid, Scope is ignored.  Otherwise, the first node
+ *              within Scope is returned.
+ *
+ ******************************************************************************/
+
+struct acpi_namespace_node *acpi_ns_get_next_node_typed(acpi_object_type type,
+							struct
+							acpi_namespace_node
+							*parent_node,
+							struct
+							acpi_namespace_node
+							*child_node)
+{
+	struct acpi_namespace_node *next_node = NULL;
+
+	ACPI_FUNCTION_ENTRY();
+
+	next_node = acpi_ns_get_next_node(parent_node, child_node);
+
+	/* If any type is OK, we are done */
+
+	if (type == ACPI_TYPE_ANY) {
+
+		/* next_node is NULL if we are at the end-of-list */
+
+		return (next_node);
+	}
+
+	/* Must search for the node -- but within this scope only */
+
+	while (next_node) {
+
+		/* If type matches, we are done */
+
+		if (next_node->type == type) {
+			return (next_node);
+		}
+
+		/* Otherwise, move on to the next peer node */
+
+		next_node = next_node->peer;
+	}
+
+	/* Not found */
+
+	return (NULL);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_walk_namespace
+ *
+ * PARAMETERS:  Type                - acpi_object_type to search for
+ *              start_node          - Handle in namespace where search begins
+ *              max_depth           - Depth to which search is to reach
+ *              Flags               - Whether to unlock the NS before invoking
+ *                                    the callback routine
+ *              pre_order_visit     - Called during tree pre-order visit
+ *                                    when an object of "Type" is found
+ *              post_order_visit    - Called during tree post-order visit
+ *                                    when an object of "Type" is found
+ *              Context             - Passed to user function(s) above
+ *              return_value        - from the user_function if terminated
+ *                                    early. Otherwise, returns NULL.
+ * RETURNS:     Status
+ *
+ * DESCRIPTION: Performs a modified depth-first walk of the namespace tree,
+ *              starting (and ending) at the node specified by start_handle.
+ *              The callback function is called whenever a node that matches
+ *              the type parameter is found. If the callback function returns
+ *              a non-zero value, the search is terminated immediately and
+ *              this value is returned to the caller.
+ *
+ *              The point of this procedure is to provide a generic namespace
+ *              walk routine that can be called from multiple places to
+ *              provide multiple services; the callback function(s) can be
+ *              tailored to each task, whether it is a print function,
+ *              a compare function, etc.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ns_walk_namespace(acpi_object_type type,
+		       acpi_handle start_node,
+		       u32 max_depth,
+		       u32 flags,
+		       acpi_walk_callback pre_order_visit,
+		       acpi_walk_callback post_order_visit,
+		       void *context, void **return_value)
+{
+	acpi_status status;
+	acpi_status mutex_status;
+	struct acpi_namespace_node *child_node;
+	struct acpi_namespace_node *parent_node;
+	acpi_object_type child_type;
+	u32 level;
+	u8 node_previously_visited = FALSE;
+
+	ACPI_FUNCTION_TRACE(ns_walk_namespace);
+
+	/* Special case for the namespace Root Node */
+
+	if (start_node == ACPI_ROOT_OBJECT) {
+		start_node = acpi_gbl_root_node;
+	}
+
+	/* Null child means "get first node" */
+
+	parent_node = start_node;
+	child_node = acpi_ns_get_next_node(parent_node, NULL);
+	child_type = ACPI_TYPE_ANY;
+	level = 1;
+
+	/*
+	 * Traverse the tree of nodes until we bubble back up to where we
+	 * started. When Level is zero, the loop is done because we have
+	 * bubbled up to (and passed) the original parent handle (start_entry)
+	 */
+	while (level > 0 && child_node) {
+		status = AE_OK;
+
+		/* Found next child, get the type if we are not searching for ANY */
+
+		if (type != ACPI_TYPE_ANY) {
+			child_type = child_node->type;
+		}
+
+		/*
+		 * Ignore all temporary namespace nodes (created during control
+		 * method execution) unless told otherwise. These temporary nodes
+		 * can cause a race condition because they can be deleted during
+		 * the execution of the user function (if the namespace is
+		 * unlocked before invocation of the user function.) Only the
+		 * debugger namespace dump will examine the temporary nodes.
+		 */
+		if ((child_node->flags & ANOBJ_TEMPORARY) &&
+		    !(flags & ACPI_NS_WALK_TEMP_NODES)) {
+			status = AE_CTRL_DEPTH;
+		}
+
+		/* Type must match requested type */
+
+		else if (child_type == type) {
+			/*
+			 * Found a matching node, invoke the user callback function.
+			 * Unlock the namespace if flag is set.
+			 */
+			if (flags & ACPI_NS_WALK_UNLOCK) {
+				mutex_status =
+				    acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);
+				if (ACPI_FAILURE(mutex_status)) {
+					return_ACPI_STATUS(mutex_status);
+				}
+			}
+
+			/*
+			 * Invoke the user function, either pre-order or post-order
+			 * or both.
+			 */
+			if (!node_previously_visited) {
+				if (pre_order_visit) {
+					status =
+					    pre_order_visit(child_node, level,
+							    context,
+							    return_value);
+				}
+			} else {
+				if (post_order_visit) {
+					status =
+					    post_order_visit(child_node, level,
+							     context,
+							     return_value);
+				}
+			}
+
+			if (flags & ACPI_NS_WALK_UNLOCK) {
+				mutex_status =
+				    acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);
+				if (ACPI_FAILURE(mutex_status)) {
+					return_ACPI_STATUS(mutex_status);
+				}
+			}
+
+			switch (status) {
+			case AE_OK:
+			case AE_CTRL_DEPTH:
+
+				/* Just keep going */
+				break;
+
+			case AE_CTRL_TERMINATE:
+
+				/* Exit now, with OK status */
+
+				return_ACPI_STATUS(AE_OK);
+
+			default:
+
+				/* All others are valid exceptions */
+
+				return_ACPI_STATUS(status);
+			}
+		}
+
+		/*
+		 * Depth first search: Attempt to go down another level in the
+		 * namespace if we are allowed to.  Don't go any further if we have
+		 * reached the caller specified maximum depth or if the user
+		 * function has specified that the maximum depth has been reached.
+		 */
+		if (!node_previously_visited &&
+		    (level < max_depth) && (status != AE_CTRL_DEPTH)) {
+			if (child_node->child) {
+
+				/* There is at least one child of this node, visit it */
+
+				level++;
+				parent_node = child_node;
+				child_node =
+				    acpi_ns_get_next_node(parent_node, NULL);
+				continue;
+			}
+		}
+
+		/* No more children, re-visit this node */
+
+		if (!node_previously_visited) {
+			node_previously_visited = TRUE;
+			continue;
+		}
+
+		/* No more children, visit peers */
+
+		child_node = acpi_ns_get_next_node(parent_node, child_node);
+		if (child_node) {
+			node_previously_visited = FALSE;
+		}
+
+		/* No peers, re-visit parent */
+
+		else {
+			/*
+			 * No more children of this node (acpi_ns_get_next_node failed), go
+			 * back upwards in the namespace tree to the node's parent.
+			 */
+			level--;
+			child_node = parent_node;
+			parent_node = parent_node->parent;
+
+			node_previously_visited = TRUE;
+		}
+	}
+
+	/* Complete walk, not terminated by user function */
+
+	return_ACPI_STATUS(AE_OK);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nsxfeval.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nsxfeval.c
new file mode 100644
index 00000000..dd3ed06d
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nsxfeval.c
@@ -0,0 +1,857 @@
+/*******************************************************************************
+ *
+ * Module Name: nsxfeval - Public interfaces to the ACPI subsystem
+ *                         ACPI Object evaluation interfaces
+ *
+ ******************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acnamesp.h"
+#include "acinterp.h"
+
+#define _COMPONENT          ACPI_NAMESPACE
+ACPI_MODULE_NAME("nsxfeval")
+
+/* Local prototypes */
+static void acpi_ns_resolve_references(struct acpi_evaluate_info *info);
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_evaluate_object_typed
+ *
+ * PARAMETERS:  Handle              - Object handle (optional)
+ *              Pathname            - Object pathname (optional)
+ *              external_params     - List of parameters to pass to method,
+ *                                    terminated by NULL.  May be NULL
+ *                                    if no parameters are being passed.
+ *              return_buffer       - Where to put method's return value (if
+ *                                    any).  If NULL, no value is returned.
+ *              return_type         - Expected type of return object
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Find and evaluate the given object, passing the given
+ *              parameters if necessary.  One of "Handle" or "Pathname" must
+ *              be valid (non-null)
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_evaluate_object_typed(acpi_handle handle,
+			   acpi_string pathname,
+			   struct acpi_object_list *external_params,
+			   struct acpi_buffer *return_buffer,
+			   acpi_object_type return_type)
+{
+	acpi_status status;
+	u8 must_free = FALSE;
+
+	ACPI_FUNCTION_TRACE(acpi_evaluate_object_typed);
+
+	/* Return buffer must be valid */
+
+	if (!return_buffer) {
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	if (return_buffer->length == ACPI_ALLOCATE_BUFFER) {
+		must_free = TRUE;
+	}
+
+	/* Evaluate the object */
+
+	status =
+	    acpi_evaluate_object(handle, pathname, external_params,
+				 return_buffer);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/* Type ANY means "don't care" */
+
+	if (return_type == ACPI_TYPE_ANY) {
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	if (return_buffer->length == 0) {
+
+		/* Error because caller specifically asked for a return value */
+
+		ACPI_ERROR((AE_INFO, "No return value"));
+		return_ACPI_STATUS(AE_NULL_OBJECT);
+	}
+
+	/* Examine the object type returned from evaluate_object */
+
+	if (((union acpi_object *)return_buffer->pointer)->type == return_type) {
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	/* Return object type does not match requested type */
+
+	ACPI_ERROR((AE_INFO,
+		    "Incorrect return type [%s] requested [%s]",
+		    acpi_ut_get_type_name(((union acpi_object *)return_buffer->
+					   pointer)->type),
+		    acpi_ut_get_type_name(return_type)));
+
+	if (must_free) {
+
+		/* Caller used ACPI_ALLOCATE_BUFFER, free the return buffer */
+
+		acpi_os_free(return_buffer->pointer);
+		return_buffer->pointer = NULL;
+	}
+
+	return_buffer->length = 0;
+	return_ACPI_STATUS(AE_TYPE);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_evaluate_object_typed)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_evaluate_object
+ *
+ * PARAMETERS:  Handle              - Object handle (optional)
+ *              Pathname            - Object pathname (optional)
+ *              external_params     - List of parameters to pass to method,
+ *                                    terminated by NULL.  May be NULL
+ *                                    if no parameters are being passed.
+ *              return_buffer       - Where to put method's return value (if
+ *                                    any).  If NULL, no value is returned.
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Find and evaluate the given object, passing the given
+ *              parameters if necessary.  One of "Handle" or "Pathname" must
+ *              be valid (non-null)
+ *
+ ******************************************************************************/
+acpi_status
+acpi_evaluate_object(acpi_handle handle,
+		     acpi_string pathname,
+		     struct acpi_object_list *external_params,
+		     struct acpi_buffer *return_buffer)
+{
+	acpi_status status;
+	struct acpi_evaluate_info *info;
+	acpi_size buffer_space_needed;
+	u32 i;
+
+	ACPI_FUNCTION_TRACE(acpi_evaluate_object);
+
+	/* Allocate and initialize the evaluation information block */
+
+	info = ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_evaluate_info));
+	if (!info) {
+		return_ACPI_STATUS(AE_NO_MEMORY);
+	}
+
+	info->pathname = pathname;
+
+	/* Convert and validate the device handle */
+
+	info->prefix_node = acpi_ns_validate_handle(handle);
+	if (!info->prefix_node) {
+		status = AE_BAD_PARAMETER;
+		goto cleanup;
+	}
+
+	/*
+	 * If there are parameters to be passed to a control method, the external
+	 * objects must all be converted to internal objects
+	 */
+	if (external_params && external_params->count) {
+		/*
+		 * Allocate a new parameter block for the internal objects
+		 * Add 1 to count to allow for null terminated internal list
+		 */
+		info->parameters = ACPI_ALLOCATE_ZEROED(((acpi_size)
+							 external_params->
+							 count +
+							 1) * sizeof(void *));
+		if (!info->parameters) {
+			status = AE_NO_MEMORY;
+			goto cleanup;
+		}
+
+		/* Convert each external object in the list to an internal object */
+
+		for (i = 0; i < external_params->count; i++) {
+			status =
+			    acpi_ut_copy_eobject_to_iobject(&external_params->
+							    pointer[i],
+							    &info->
+							    parameters[i]);
+			if (ACPI_FAILURE(status)) {
+				goto cleanup;
+			}
+		}
+		info->parameters[external_params->count] = NULL;
+	}
+
+	/*
+	 * Three major cases:
+	 * 1) Fully qualified pathname
+	 * 2) No handle, not fully qualified pathname (error)
+	 * 3) Valid handle
+	 */
+	if ((pathname) && (acpi_ns_valid_root_prefix(pathname[0]))) {
+
+		/* The path is fully qualified, just evaluate by name */
+
+		info->prefix_node = NULL;
+		status = acpi_ns_evaluate(info);
+	} else if (!handle) {
+		/*
+		 * A handle is optional iff a fully qualified pathname is specified.
+		 * Since we've already handled fully qualified names above, this is
+		 * an error
+		 */
+		if (!pathname) {
+			ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+					  "Both Handle and Pathname are NULL"));
+		} else {
+			ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+					  "Null Handle with relative pathname [%s]",
+					  pathname));
+		}
+
+		status = AE_BAD_PARAMETER;
+	} else {
+		/* We have a namespace a node and a possible relative path */
+
+		status = acpi_ns_evaluate(info);
+	}
+
+	/*
+	 * If we are expecting a return value, and all went well above,
+	 * copy the return value to an external object.
+	 */
+	if (return_buffer) {
+		if (!info->return_object) {
+			return_buffer->length = 0;
+		} else {
+			if (ACPI_GET_DESCRIPTOR_TYPE(info->return_object) ==
+			    ACPI_DESC_TYPE_NAMED) {
+				/*
+				 * If we received a NS Node as a return object, this means that
+				 * the object we are evaluating has nothing interesting to
+				 * return (such as a mutex, etc.)  We return an error because
+				 * these types are essentially unsupported by this interface.
+				 * We don't check up front because this makes it easier to add
+				 * support for various types at a later date if necessary.
+				 */
+				status = AE_TYPE;
+				info->return_object = NULL;	/* No need to delete a NS Node */
+				return_buffer->length = 0;
+			}
+
+			if (ACPI_SUCCESS(status)) {
+
+				/* Dereference Index and ref_of references */
+
+				acpi_ns_resolve_references(info);
+
+				/* Get the size of the returned object */
+
+				status =
+				    acpi_ut_get_object_size(info->return_object,
+							    &buffer_space_needed);
+				if (ACPI_SUCCESS(status)) {
+
+					/* Validate/Allocate/Clear caller buffer */
+
+					status =
+					    acpi_ut_initialize_buffer
+					    (return_buffer,
+					     buffer_space_needed);
+					if (ACPI_FAILURE(status)) {
+						/*
+						 * Caller's buffer is too small or a new one can't
+						 * be allocated
+						 */
+						ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+								  "Needed buffer size %X, %s\n",
+								  (u32)
+								  buffer_space_needed,
+								  acpi_format_exception
+								  (status)));
+					} else {
+						/* We have enough space for the object, build it */
+
+						status =
+						    acpi_ut_copy_iobject_to_eobject
+						    (info->return_object,
+						     return_buffer);
+					}
+				}
+			}
+		}
+	}
+
+	if (info->return_object) {
+		/*
+		 * Delete the internal return object. NOTE: Interpreter must be
+		 * locked to avoid race condition.
+		 */
+		acpi_ex_enter_interpreter();
+
+		/* Remove one reference on the return object (should delete it) */
+
+		acpi_ut_remove_reference(info->return_object);
+		acpi_ex_exit_interpreter();
+	}
+
+      cleanup:
+
+	/* Free the input parameter list (if we created one) */
+
+	if (info->parameters) {
+
+		/* Free the allocated parameter block */
+
+		acpi_ut_delete_internal_object_list(info->parameters);
+	}
+
+	ACPI_FREE(info);
+	return_ACPI_STATUS(status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_evaluate_object)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_resolve_references
+ *
+ * PARAMETERS:  Info                    - Evaluation info block
+ *
+ * RETURN:      Info->return_object is replaced with the dereferenced object
+ *
+ * DESCRIPTION: Dereference certain reference objects. Called before an
+ *              internal return object is converted to an external union acpi_object.
+ *
+ * Performs an automatic dereference of Index and ref_of reference objects.
+ * These reference objects are not supported by the union acpi_object, so this is a
+ * last resort effort to return something useful. Also, provides compatibility
+ * with other ACPI implementations.
+ *
+ * NOTE: does not handle references within returned package objects or nested
+ * references, but this support could be added later if found to be necessary.
+ *
+ ******************************************************************************/
+static void acpi_ns_resolve_references(struct acpi_evaluate_info *info)
+{
+	union acpi_operand_object *obj_desc = NULL;
+	struct acpi_namespace_node *node;
+
+	/* We are interested in reference objects only */
+
+	if ((info->return_object)->common.type != ACPI_TYPE_LOCAL_REFERENCE) {
+		return;
+	}
+
+	/*
+	 * Two types of references are supported - those created by Index and
+	 * ref_of operators. A name reference (AML_NAMEPATH_OP) can be converted
+	 * to an union acpi_object, so it is not dereferenced here. A ddb_handle
+	 * (AML_LOAD_OP) cannot be dereferenced, nor can it be converted to
+	 * an union acpi_object.
+	 */
+	switch (info->return_object->reference.class) {
+	case ACPI_REFCLASS_INDEX:
+
+		obj_desc = *(info->return_object->reference.where);
+		break;
+
+	case ACPI_REFCLASS_REFOF:
+
+		node = info->return_object->reference.object;
+		if (node) {
+			obj_desc = node->object;
+		}
+		break;
+
+	default:
+		return;
+	}
+
+	/* Replace the existing reference object */
+
+	if (obj_desc) {
+		acpi_ut_add_reference(obj_desc);
+		acpi_ut_remove_reference(info->return_object);
+		info->return_object = obj_desc;
+	}
+
+	return;
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_walk_namespace
+ *
+ * PARAMETERS:  Type                - acpi_object_type to search for
+ *              start_object        - Handle in namespace where search begins
+ *              max_depth           - Depth to which search is to reach
+ *              pre_order_visit     - Called during tree pre-order visit
+ *                                    when an object of "Type" is found
+ *              post_order_visit    - Called during tree post-order visit
+ *                                    when an object of "Type" is found
+ *              Context             - Passed to user function(s) above
+ *              return_value        - Location where return value of
+ *                                    user_function is put if terminated early
+ *
+ * RETURNS      Return value from the user_function if terminated early.
+ *              Otherwise, returns NULL.
+ *
+ * DESCRIPTION: Performs a modified depth-first walk of the namespace tree,
+ *              starting (and ending) at the object specified by start_handle.
+ *              The callback function is called whenever an object that matches
+ *              the type parameter is found. If the callback function returns
+ *              a non-zero value, the search is terminated immediately and this
+ *              value is returned to the caller.
+ *
+ *              The point of this procedure is to provide a generic namespace
+ *              walk routine that can be called from multiple places to
+ *              provide multiple services; the callback function(s) can be
+ *              tailored to each task, whether it is a print function,
+ *              a compare function, etc.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_walk_namespace(acpi_object_type type,
+		    acpi_handle start_object,
+		    u32 max_depth,
+		    acpi_walk_callback pre_order_visit,
+		    acpi_walk_callback post_order_visit,
+		    void *context, void **return_value)
+{
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(acpi_walk_namespace);
+
+	/* Parameter validation */
+
+	if ((type > ACPI_TYPE_LOCAL_MAX) ||
+	    (!max_depth) || (!pre_order_visit && !post_order_visit)) {
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	/*
+	 * Need to acquire the namespace reader lock to prevent interference
+	 * with any concurrent table unloads (which causes the deletion of
+	 * namespace objects). We cannot allow the deletion of a namespace node
+	 * while the user function is using it. The exception to this are the
+	 * nodes created and deleted during control method execution -- these
+	 * nodes are marked as temporary nodes and are ignored by the namespace
+	 * walk. Thus, control methods can be executed while holding the
+	 * namespace deletion lock (and the user function can execute control
+	 * methods.)
+	 */
+	status = acpi_ut_acquire_read_lock(&acpi_gbl_namespace_rw_lock);
+	if (ACPI_FAILURE(status)) {
+		return (status);
+	}
+
+	/*
+	 * Lock the namespace around the walk. The namespace will be
+	 * unlocked/locked around each call to the user function - since the user
+	 * function must be allowed to make ACPICA calls itself (for example, it
+	 * will typically execute control methods during device enumeration.)
+	 */
+	status = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);
+	if (ACPI_FAILURE(status)) {
+		goto unlock_and_exit;
+	}
+
+	status = acpi_ns_walk_namespace(type, start_object, max_depth,
+					ACPI_NS_WALK_UNLOCK, pre_order_visit,
+					post_order_visit, context,
+					return_value);
+
+	(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);
+
+      unlock_and_exit:
+	(void)acpi_ut_release_read_lock(&acpi_gbl_namespace_rw_lock);
+	return_ACPI_STATUS(status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_walk_namespace)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_get_device_callback
+ *
+ * PARAMETERS:  Callback from acpi_get_device
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Takes callbacks from walk_namespace and filters out all non-
+ *              present devices, or if they specified a HID, it filters based
+ *              on that.
+ *
+ ******************************************************************************/
+static acpi_status
+acpi_ns_get_device_callback(acpi_handle obj_handle,
+			    u32 nesting_level,
+			    void *context, void **return_value)
+{
+	struct acpi_get_devices_info *info = context;
+	acpi_status status;
+	struct acpi_namespace_node *node;
+	u32 flags;
+	struct acpi_device_id *hid;
+	struct acpi_device_id_list *cid;
+	u32 i;
+	u8 found;
+	int no_match;
+
+	status = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);
+	if (ACPI_FAILURE(status)) {
+		return (status);
+	}
+
+	node = acpi_ns_validate_handle(obj_handle);
+	status = acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);
+	if (ACPI_FAILURE(status)) {
+		return (status);
+	}
+
+	if (!node) {
+		return (AE_BAD_PARAMETER);
+	}
+
+	/*
+	 * First, filter based on the device HID and CID.
+	 *
+	 * 01/2010: For this case where a specific HID is requested, we don't
+	 * want to run _STA until we have an actual HID match. Thus, we will
+	 * not unnecessarily execute _STA on devices for which the caller
+	 * doesn't care about. Previously, _STA was executed unconditionally
+	 * on all devices found here.
+	 *
+	 * A side-effect of this change is that now we will continue to search
+	 * for a matching HID even under device trees where the parent device
+	 * would have returned a _STA that indicates it is not present or
+	 * not functioning (thus aborting the search on that branch).
+	 */
+	if (info->hid != NULL) {
+		status = acpi_ut_execute_HID(node, &hid);
+		if (status == AE_NOT_FOUND) {
+			return (AE_OK);
+		} else if (ACPI_FAILURE(status)) {
+			return (AE_CTRL_DEPTH);
+		}
+
+		no_match = ACPI_STRCMP(hid->string, info->hid);
+		ACPI_FREE(hid);
+
+		if (no_match) {
+			/*
+			 * HID does not match, attempt match within the
+			 * list of Compatible IDs (CIDs)
+			 */
+			status = acpi_ut_execute_CID(node, &cid);
+			if (status == AE_NOT_FOUND) {
+				return (AE_OK);
+			} else if (ACPI_FAILURE(status)) {
+				return (AE_CTRL_DEPTH);
+			}
+
+			/* Walk the CID list */
+
+			found = FALSE;
+			for (i = 0; i < cid->count; i++) {
+				if (ACPI_STRCMP(cid->ids[i].string, info->hid)
+				    == 0) {
+
+					/* Found a matching CID */
+
+					found = TRUE;
+					break;
+				}
+			}
+
+			ACPI_FREE(cid);
+			if (!found) {
+				return (AE_OK);
+			}
+		}
+	}
+
+	/* Run _STA to determine if device is present */
+
+	status = acpi_ut_execute_STA(node, &flags);
+	if (ACPI_FAILURE(status)) {
+		return (AE_CTRL_DEPTH);
+	}
+
+	if (!(flags & ACPI_STA_DEVICE_PRESENT) &&
+	    !(flags & ACPI_STA_DEVICE_FUNCTIONING)) {
+		/*
+		 * Don't examine the children of the device only when the
+		 * device is neither present nor functional. See ACPI spec,
+		 * description of _STA for more information.
+		 */
+		return (AE_CTRL_DEPTH);
+	}
+
+	/* We have a valid device, invoke the user function */
+
+	status = info->user_function(obj_handle, nesting_level, info->context,
+				     return_value);
+	return (status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_get_devices
+ *
+ * PARAMETERS:  HID                 - HID to search for. Can be NULL.
+ *              user_function       - Called when a matching object is found
+ *              Context             - Passed to user function
+ *              return_value        - Location where return value of
+ *                                    user_function is put if terminated early
+ *
+ * RETURNS      Return value from the user_function if terminated early.
+ *              Otherwise, returns NULL.
+ *
+ * DESCRIPTION: Performs a modified depth-first walk of the namespace tree,
+ *              starting (and ending) at the object specified by start_handle.
+ *              The user_function is called whenever an object of type
+ *              Device is found.  If the user function returns
+ *              a non-zero value, the search is terminated immediately and this
+ *              value is returned to the caller.
+ *
+ *              This is a wrapper for walk_namespace, but the callback performs
+ *              additional filtering. Please see acpi_ns_get_device_callback.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_get_devices(char *HID,
+		 acpi_walk_callback user_function,
+		 void *context, void **return_value)
+{
+	acpi_status status;
+	struct acpi_get_devices_info info;
+
+	ACPI_FUNCTION_TRACE(acpi_get_devices);
+
+	/* Parameter validation */
+
+	if (!user_function) {
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	/*
+	 * We're going to call their callback from OUR callback, so we need
+	 * to know what it is, and their context parameter.
+	 */
+	info.hid = HID;
+	info.context = context;
+	info.user_function = user_function;
+
+	/*
+	 * Lock the namespace around the walk.
+	 * The namespace will be unlocked/locked around each call
+	 * to the user function - since this function
+	 * must be allowed to make Acpi calls itself.
+	 */
+	status = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	status = acpi_ns_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT,
+					ACPI_UINT32_MAX, ACPI_NS_WALK_UNLOCK,
+					acpi_ns_get_device_callback, NULL,
+					&info, return_value);
+
+	(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);
+	return_ACPI_STATUS(status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_get_devices)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_attach_data
+ *
+ * PARAMETERS:  obj_handle          - Namespace node
+ *              Handler             - Handler for this attachment
+ *              Data                - Pointer to data to be attached
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Attach arbitrary data and handler to a namespace node.
+ *
+ ******************************************************************************/
+acpi_status
+acpi_attach_data(acpi_handle obj_handle,
+		 acpi_object_handler handler, void *data)
+{
+	struct acpi_namespace_node *node;
+	acpi_status status;
+
+	/* Parameter validation */
+
+	if (!obj_handle || !handler || !data) {
+		return (AE_BAD_PARAMETER);
+	}
+
+	status = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);
+	if (ACPI_FAILURE(status)) {
+		return (status);
+	}
+
+	/* Convert and validate the handle */
+
+	node = acpi_ns_validate_handle(obj_handle);
+	if (!node) {
+		status = AE_BAD_PARAMETER;
+		goto unlock_and_exit;
+	}
+
+	status = acpi_ns_attach_data(node, handler, data);
+
+      unlock_and_exit:
+	(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);
+	return (status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_attach_data)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_detach_data
+ *
+ * PARAMETERS:  obj_handle          - Namespace node handle
+ *              Handler             - Handler used in call to acpi_attach_data
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Remove data that was previously attached to a node.
+ *
+ ******************************************************************************/
+acpi_status
+acpi_detach_data(acpi_handle obj_handle, acpi_object_handler handler)
+{
+	struct acpi_namespace_node *node;
+	acpi_status status;
+
+	/* Parameter validation */
+
+	if (!obj_handle || !handler) {
+		return (AE_BAD_PARAMETER);
+	}
+
+	status = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);
+	if (ACPI_FAILURE(status)) {
+		return (status);
+	}
+
+	/* Convert and validate the handle */
+
+	node = acpi_ns_validate_handle(obj_handle);
+	if (!node) {
+		status = AE_BAD_PARAMETER;
+		goto unlock_and_exit;
+	}
+
+	status = acpi_ns_detach_data(node, handler);
+
+      unlock_and_exit:
+	(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);
+	return (status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_detach_data)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_get_data
+ *
+ * PARAMETERS:  obj_handle          - Namespace node
+ *              Handler             - Handler used in call to attach_data
+ *              Data                - Where the data is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Retrieve data that was previously attached to a namespace node.
+ *
+ ******************************************************************************/
+acpi_status
+acpi_get_data(acpi_handle obj_handle, acpi_object_handler handler, void **data)
+{
+	struct acpi_namespace_node *node;
+	acpi_status status;
+
+	/* Parameter validation */
+
+	if (!obj_handle || !handler || !data) {
+		return (AE_BAD_PARAMETER);
+	}
+
+	status = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);
+	if (ACPI_FAILURE(status)) {
+		return (status);
+	}
+
+	/* Convert and validate the handle */
+
+	node = acpi_ns_validate_handle(obj_handle);
+	if (!node) {
+		status = AE_BAD_PARAMETER;
+		goto unlock_and_exit;
+	}
+
+	status = acpi_ns_get_attached_data(node, handler, data);
+
+      unlock_and_exit:
+	(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);
+	return (status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_get_data)
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nsxfname.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nsxfname.c
new file mode 100644
index 00000000..32b9bafc
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nsxfname.c
@@ -0,0 +1,637 @@
+/******************************************************************************
+ *
+ * Module Name: nsxfname - Public interfaces to the ACPI subsystem
+ *                         ACPI Namespace oriented interfaces
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acnamesp.h"
+#include "acparser.h"
+#include "amlcode.h"
+
+#define _COMPONENT          ACPI_NAMESPACE
+ACPI_MODULE_NAME("nsxfname")
+
+/* Local prototypes */
+static char *acpi_ns_copy_device_id(struct acpi_device_id *dest,
+				    struct acpi_device_id *source,
+				    char *string_area);
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_get_handle
+ *
+ * PARAMETERS:  Parent          - Object to search under (search scope).
+ *              Pathname        - Pointer to an asciiz string containing the
+ *                                name
+ *              ret_handle      - Where the return handle is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: This routine will search for a caller specified name in the
+ *              name space.  The caller can restrict the search region by
+ *              specifying a non NULL parent.  The parent value is itself a
+ *              namespace handle.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_get_handle(acpi_handle parent,
+		acpi_string pathname, acpi_handle * ret_handle)
+{
+	acpi_status status;
+	struct acpi_namespace_node *node = NULL;
+	struct acpi_namespace_node *prefix_node = NULL;
+
+	ACPI_FUNCTION_ENTRY();
+
+	/* Parameter Validation */
+
+	if (!ret_handle || !pathname) {
+		return (AE_BAD_PARAMETER);
+	}
+
+	/* Convert a parent handle to a prefix node */
+
+	if (parent) {
+		prefix_node = acpi_ns_validate_handle(parent);
+		if (!prefix_node) {
+			return (AE_BAD_PARAMETER);
+		}
+	}
+
+	/*
+	 * Valid cases are:
+	 * 1) Fully qualified pathname
+	 * 2) Parent + Relative pathname
+	 *
+	 * Error for <null Parent + relative path>
+	 */
+	if (acpi_ns_valid_root_prefix(pathname[0])) {
+
+		/* Pathname is fully qualified (starts with '\') */
+
+		/* Special case for root-only, since we can't search for it */
+
+		if (!ACPI_STRCMP(pathname, ACPI_NS_ROOT_PATH)) {
+			*ret_handle =
+			    ACPI_CAST_PTR(acpi_handle, acpi_gbl_root_node);
+			return (AE_OK);
+		}
+	} else if (!prefix_node) {
+
+		/* Relative path with null prefix is disallowed */
+
+		return (AE_BAD_PARAMETER);
+	}
+
+	/* Find the Node and convert to a handle */
+
+	status =
+	    acpi_ns_get_node(prefix_node, pathname, ACPI_NS_NO_UPSEARCH, &node);
+	if (ACPI_SUCCESS(status)) {
+		*ret_handle = ACPI_CAST_PTR(acpi_handle, node);
+	}
+
+	return (status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_get_handle)
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_get_name
+ *
+ * PARAMETERS:  Handle          - Handle to be converted to a pathname
+ *              name_type       - Full pathname or single segment
+ *              Buffer          - Buffer for returned path
+ *
+ * RETURN:      Pointer to a string containing the fully qualified Name.
+ *
+ * DESCRIPTION: This routine returns the fully qualified name associated with
+ *              the Handle parameter.  This and the acpi_pathname_to_handle are
+ *              complementary functions.
+ *
+ ******************************************************************************/
+acpi_status
+acpi_get_name(acpi_handle handle, u32 name_type, struct acpi_buffer * buffer)
+{
+	acpi_status status;
+	struct acpi_namespace_node *node;
+
+	/* Parameter validation */
+
+	if (name_type > ACPI_NAME_TYPE_MAX) {
+		return (AE_BAD_PARAMETER);
+	}
+
+	status = acpi_ut_validate_buffer(buffer);
+	if (ACPI_FAILURE(status)) {
+		return (status);
+	}
+
+	if (name_type == ACPI_FULL_PATHNAME) {
+
+		/* Get the full pathname (From the namespace root) */
+
+		status = acpi_ns_handle_to_pathname(handle, buffer);
+		return (status);
+	}
+
+	/*
+	 * Wants the single segment ACPI name.
+	 * Validate handle and convert to a namespace Node
+	 */
+	status = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);
+	if (ACPI_FAILURE(status)) {
+		return (status);
+	}
+
+	node = acpi_ns_validate_handle(handle);
+	if (!node) {
+		status = AE_BAD_PARAMETER;
+		goto unlock_and_exit;
+	}
+
+	/* Validate/Allocate/Clear caller buffer */
+
+	status = acpi_ut_initialize_buffer(buffer, ACPI_PATH_SEGMENT_LENGTH);
+	if (ACPI_FAILURE(status)) {
+		goto unlock_and_exit;
+	}
+
+	/* Just copy the ACPI name from the Node and zero terminate it */
+
+	ACPI_STRNCPY(buffer->pointer, acpi_ut_get_node_name(node),
+		     ACPI_NAME_SIZE);
+	((char *)buffer->pointer)[ACPI_NAME_SIZE] = 0;
+	status = AE_OK;
+
+      unlock_and_exit:
+
+	(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);
+	return (status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_get_name)
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_copy_device_id
+ *
+ * PARAMETERS:  Dest                - Pointer to the destination DEVICE_ID
+ *              Source              - Pointer to the source DEVICE_ID
+ *              string_area         - Pointer to where to copy the dest string
+ *
+ * RETURN:      Pointer to the next string area
+ *
+ * DESCRIPTION: Copy a single DEVICE_ID, including the string data.
+ *
+ ******************************************************************************/
+static char *acpi_ns_copy_device_id(struct acpi_device_id *dest,
+				    struct acpi_device_id *source,
+				    char *string_area)
+{
+	/* Create the destination DEVICE_ID */
+
+	dest->string = string_area;
+	dest->length = source->length;
+
+	/* Copy actual string and return a pointer to the next string area */
+
+	ACPI_MEMCPY(string_area, source->string, source->length);
+	return (string_area + source->length);
+}
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_get_object_info
+ *
+ * PARAMETERS:  Handle              - Object Handle
+ *              return_buffer       - Where the info is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Returns information about an object as gleaned from the
+ *              namespace node and possibly by running several standard
+ *              control methods (Such as in the case of a device.)
+ *
+ * For Device and Processor objects, run the Device _HID, _UID, _CID, _STA,
+ * _ADR, _sx_w, and _sx_d methods.
+ *
+ * Note: Allocates the return buffer, must be freed by the caller.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_get_object_info(acpi_handle handle,
+		     struct acpi_device_info ** return_buffer)
+{
+	struct acpi_namespace_node *node;
+	struct acpi_device_info *info;
+	struct acpi_device_id_list *cid_list = NULL;
+	struct acpi_device_id *hid = NULL;
+	struct acpi_device_id *uid = NULL;
+	char *next_id_string;
+	acpi_object_type type;
+	acpi_name name;
+	u8 param_count = 0;
+	u8 valid = 0;
+	u32 info_size;
+	u32 i;
+	acpi_status status;
+
+	/* Parameter validation */
+
+	if (!handle || !return_buffer) {
+		return (AE_BAD_PARAMETER);
+	}
+
+	status = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);
+	if (ACPI_FAILURE(status)) {
+		goto cleanup;
+	}
+
+	node = acpi_ns_validate_handle(handle);
+	if (!node) {
+		(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);
+		return (AE_BAD_PARAMETER);
+	}
+
+	/* Get the namespace node data while the namespace is locked */
+
+	info_size = sizeof(struct acpi_device_info);
+	type = node->type;
+	name = node->name.integer;
+
+	if (node->type == ACPI_TYPE_METHOD) {
+		param_count = node->object->method.param_count;
+	}
+
+	status = acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);
+	if (ACPI_FAILURE(status)) {
+		return (status);
+	}
+
+	if ((type == ACPI_TYPE_DEVICE) || (type == ACPI_TYPE_PROCESSOR)) {
+		/*
+		 * Get extra info for ACPI Device/Processor objects only:
+		 * Run the Device _HID, _UID, and _CID methods.
+		 *
+		 * Note: none of these methods are required, so they may or may
+		 * not be present for this device. The Info->Valid bitfield is used
+		 * to indicate which methods were found and run successfully.
+		 */
+
+		/* Execute the Device._HID method */
+
+		status = acpi_ut_execute_HID(node, &hid);
+		if (ACPI_SUCCESS(status)) {
+			info_size += hid->length;
+			valid |= ACPI_VALID_HID;
+		}
+
+		/* Execute the Device._UID method */
+
+		status = acpi_ut_execute_UID(node, &uid);
+		if (ACPI_SUCCESS(status)) {
+			info_size += uid->length;
+			valid |= ACPI_VALID_UID;
+		}
+
+		/* Execute the Device._CID method */
+
+		status = acpi_ut_execute_CID(node, &cid_list);
+		if (ACPI_SUCCESS(status)) {
+
+			/* Add size of CID strings and CID pointer array */
+
+			info_size +=
+			    (cid_list->list_size -
+			     sizeof(struct acpi_device_id_list));
+			valid |= ACPI_VALID_CID;
+		}
+	}
+
+	/*
+	 * Now that we have the variable-length data, we can allocate the
+	 * return buffer
+	 */
+	info = ACPI_ALLOCATE_ZEROED(info_size);
+	if (!info) {
+		status = AE_NO_MEMORY;
+		goto cleanup;
+	}
+
+	/* Get the fixed-length data */
+
+	if ((type == ACPI_TYPE_DEVICE) || (type == ACPI_TYPE_PROCESSOR)) {
+		/*
+		 * Get extra info for ACPI Device/Processor objects only:
+		 * Run the _STA, _ADR and, sx_w, and _sx_d methods.
+		 *
+		 * Note: none of these methods are required, so they may or may
+		 * not be present for this device. The Info->Valid bitfield is used
+		 * to indicate which methods were found and run successfully.
+		 */
+
+		/* Execute the Device._STA method */
+
+		status = acpi_ut_execute_STA(node, &info->current_status);
+		if (ACPI_SUCCESS(status)) {
+			valid |= ACPI_VALID_STA;
+		}
+
+		/* Execute the Device._ADR method */
+
+		status = acpi_ut_evaluate_numeric_object(METHOD_NAME__ADR, node,
+							 &info->address);
+		if (ACPI_SUCCESS(status)) {
+			valid |= ACPI_VALID_ADR;
+		}
+
+		/* Execute the Device._sx_w methods */
+
+		status = acpi_ut_execute_power_methods(node,
+						       acpi_gbl_lowest_dstate_names,
+						       ACPI_NUM_sx_w_METHODS,
+						       info->lowest_dstates);
+		if (ACPI_SUCCESS(status)) {
+			valid |= ACPI_VALID_SXWS;
+		}
+
+		/* Execute the Device._sx_d methods */
+
+		status = acpi_ut_execute_power_methods(node,
+						       acpi_gbl_highest_dstate_names,
+						       ACPI_NUM_sx_d_METHODS,
+						       info->highest_dstates);
+		if (ACPI_SUCCESS(status)) {
+			valid |= ACPI_VALID_SXDS;
+		}
+	}
+
+	/*
+	 * Create a pointer to the string area of the return buffer.
+	 * Point to the end of the base struct acpi_device_info structure.
+	 */
+	next_id_string = ACPI_CAST_PTR(char, info->compatible_id_list.ids);
+	if (cid_list) {
+
+		/* Point past the CID DEVICE_ID array */
+
+		next_id_string +=
+		    ((acpi_size) cid_list->count *
+		     sizeof(struct acpi_device_id));
+	}
+
+	/*
+	 * Copy the HID, UID, and CIDs to the return buffer. The variable-length
+	 * strings are copied to the reserved area at the end of the buffer.
+	 *
+	 * For HID and CID, check if the ID is a PCI Root Bridge.
+	 */
+	if (hid) {
+		next_id_string = acpi_ns_copy_device_id(&info->hardware_id,
+							hid, next_id_string);
+
+		if (acpi_ut_is_pci_root_bridge(hid->string)) {
+			info->flags |= ACPI_PCI_ROOT_BRIDGE;
+		}
+	}
+
+	if (uid) {
+		next_id_string = acpi_ns_copy_device_id(&info->unique_id,
+							uid, next_id_string);
+	}
+
+	if (cid_list) {
+		info->compatible_id_list.count = cid_list->count;
+		info->compatible_id_list.list_size = cid_list->list_size;
+
+		/* Copy each CID */
+
+		for (i = 0; i < cid_list->count; i++) {
+			next_id_string =
+			    acpi_ns_copy_device_id(&info->compatible_id_list.
+						   ids[i], &cid_list->ids[i],
+						   next_id_string);
+
+			if (acpi_ut_is_pci_root_bridge(cid_list->ids[i].string)) {
+				info->flags |= ACPI_PCI_ROOT_BRIDGE;
+			}
+		}
+	}
+
+	/* Copy the fixed-length data */
+
+	info->info_size = info_size;
+	info->type = type;
+	info->name = name;
+	info->param_count = param_count;
+	info->valid = valid;
+
+	*return_buffer = info;
+	status = AE_OK;
+
+      cleanup:
+	if (hid) {
+		ACPI_FREE(hid);
+	}
+	if (uid) {
+		ACPI_FREE(uid);
+	}
+	if (cid_list) {
+		ACPI_FREE(cid_list);
+	}
+	return (status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_get_object_info)
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_install_method
+ *
+ * PARAMETERS:  Buffer         - An ACPI table containing one control method
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Install a control method into the namespace. If the method
+ *              name already exists in the namespace, it is overwritten. The
+ *              input buffer must contain a valid DSDT or SSDT containing a
+ *              single control method.
+ *
+ ******************************************************************************/
+acpi_status acpi_install_method(u8 *buffer)
+{
+	struct acpi_table_header *table =
+	    ACPI_CAST_PTR(struct acpi_table_header, buffer);
+	u8 *aml_buffer;
+	u8 *aml_start;
+	char *path;
+	struct acpi_namespace_node *node;
+	union acpi_operand_object *method_obj;
+	struct acpi_parse_state parser_state;
+	u32 aml_length;
+	u16 opcode;
+	u8 method_flags;
+	acpi_status status;
+
+	/* Parameter validation */
+
+	if (!buffer) {
+		return (AE_BAD_PARAMETER);
+	}
+
+	/* Table must be a DSDT or SSDT */
+
+	if (!ACPI_COMPARE_NAME(table->signature, ACPI_SIG_DSDT) &&
+	    !ACPI_COMPARE_NAME(table->signature, ACPI_SIG_SSDT)) {
+		return (AE_BAD_HEADER);
+	}
+
+	/* First AML opcode in the table must be a control method */
+
+	parser_state.aml = buffer + sizeof(struct acpi_table_header);
+	opcode = acpi_ps_peek_opcode(&parser_state);
+	if (opcode != AML_METHOD_OP) {
+		return (AE_BAD_PARAMETER);
+	}
+
+	/* Extract method information from the raw AML */
+
+	parser_state.aml += acpi_ps_get_opcode_size(opcode);
+	parser_state.pkg_end = acpi_ps_get_next_package_end(&parser_state);
+	path = acpi_ps_get_next_namestring(&parser_state);
+	method_flags = *parser_state.aml++;
+	aml_start = parser_state.aml;
+	aml_length = ACPI_PTR_DIFF(parser_state.pkg_end, aml_start);
+
+	/*
+	 * Allocate resources up-front. We don't want to have to delete a new
+	 * node from the namespace if we cannot allocate memory.
+	 */
+	aml_buffer = ACPI_ALLOCATE(aml_length);
+	if (!aml_buffer) {
+		return (AE_NO_MEMORY);
+	}
+
+	method_obj = acpi_ut_create_internal_object(ACPI_TYPE_METHOD);
+	if (!method_obj) {
+		ACPI_FREE(aml_buffer);
+		return (AE_NO_MEMORY);
+	}
+
+	/* Lock namespace for acpi_ns_lookup, we may be creating a new node */
+
+	status = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);
+	if (ACPI_FAILURE(status)) {
+		goto error_exit;
+	}
+
+	/* The lookup either returns an existing node or creates a new one */
+
+	status =
+	    acpi_ns_lookup(NULL, path, ACPI_TYPE_METHOD, ACPI_IMODE_LOAD_PASS1,
+			   ACPI_NS_DONT_OPEN_SCOPE | ACPI_NS_ERROR_IF_FOUND,
+			   NULL, &node);
+
+	(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);
+
+	if (ACPI_FAILURE(status)) {	/* ns_lookup */
+		if (status != AE_ALREADY_EXISTS) {
+			goto error_exit;
+		}
+
+		/* Node existed previously, make sure it is a method node */
+
+		if (node->type != ACPI_TYPE_METHOD) {
+			status = AE_TYPE;
+			goto error_exit;
+		}
+	}
+
+	/* Copy the method AML to the local buffer */
+
+	ACPI_MEMCPY(aml_buffer, aml_start, aml_length);
+
+	/* Initialize the method object with the new method's information */
+
+	method_obj->method.aml_start = aml_buffer;
+	method_obj->method.aml_length = aml_length;
+
+	method_obj->method.param_count = (u8)
+	    (method_flags & AML_METHOD_ARG_COUNT);
+
+	if (method_flags & AML_METHOD_SERIALIZED) {
+		method_obj->method.info_flags = ACPI_METHOD_SERIALIZED;
+
+		method_obj->method.sync_level = (u8)
+		    ((method_flags & AML_METHOD_SYNC_LEVEL) >> 4);
+	}
+
+	/*
+	 * Now that it is complete, we can attach the new method object to
+	 * the method Node (detaches/deletes any existing object)
+	 */
+	status = acpi_ns_attach_object(node, method_obj, ACPI_TYPE_METHOD);
+
+	/*
+	 * Flag indicates AML buffer is dynamic, must be deleted later.
+	 * Must be set only after attach above.
+	 */
+	node->flags |= ANOBJ_ALLOCATED_BUFFER;
+
+	/* Remove local reference to the method object */
+
+	acpi_ut_remove_reference(method_obj);
+	return (status);
+
+      error_exit:
+
+	ACPI_FREE(aml_buffer);
+	ACPI_FREE(method_obj);
+	return (status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_install_method)
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nsxfobj.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nsxfobj.c
new file mode 100644
index 00000000..7f808e7d
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/nsxfobj.c
@@ -0,0 +1,244 @@
+/*******************************************************************************
+ *
+ * Module Name: nsxfobj - Public interfaces to the ACPI subsystem
+ *                         ACPI Object oriented interfaces
+ *
+ ******************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acnamesp.h"
+
+#define _COMPONENT          ACPI_NAMESPACE
+ACPI_MODULE_NAME("nsxfobj")
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_get_type
+ *
+ * PARAMETERS:  Handle          - Handle of object whose type is desired
+ *              ret_type        - Where the type will be placed
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: This routine returns the type associatd with a particular handle
+ *
+ ******************************************************************************/
+acpi_status acpi_get_type(acpi_handle handle, acpi_object_type * ret_type)
+{
+	struct acpi_namespace_node *node;
+	acpi_status status;
+
+	/* Parameter Validation */
+
+	if (!ret_type) {
+		return (AE_BAD_PARAMETER);
+	}
+
+	/*
+	 * Special case for the predefined Root Node
+	 * (return type ANY)
+	 */
+	if (handle == ACPI_ROOT_OBJECT) {
+		*ret_type = ACPI_TYPE_ANY;
+		return (AE_OK);
+	}
+
+	status = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);
+	if (ACPI_FAILURE(status)) {
+		return (status);
+	}
+
+	/* Convert and validate the handle */
+
+	node = acpi_ns_validate_handle(handle);
+	if (!node) {
+		(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);
+		return (AE_BAD_PARAMETER);
+	}
+
+	*ret_type = node->type;
+
+	status = acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);
+	return (status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_get_type)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_get_parent
+ *
+ * PARAMETERS:  Handle          - Handle of object whose parent is desired
+ *              ret_handle      - Where the parent handle will be placed
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Returns a handle to the parent of the object represented by
+ *              Handle.
+ *
+ ******************************************************************************/
+acpi_status acpi_get_parent(acpi_handle handle, acpi_handle * ret_handle)
+{
+	struct acpi_namespace_node *node;
+	struct acpi_namespace_node *parent_node;
+	acpi_status status;
+
+	if (!ret_handle) {
+		return (AE_BAD_PARAMETER);
+	}
+
+	/* Special case for the predefined Root Node (no parent) */
+
+	if (handle == ACPI_ROOT_OBJECT) {
+		return (AE_NULL_ENTRY);
+	}
+
+	status = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);
+	if (ACPI_FAILURE(status)) {
+		return (status);
+	}
+
+	/* Convert and validate the handle */
+
+	node = acpi_ns_validate_handle(handle);
+	if (!node) {
+		status = AE_BAD_PARAMETER;
+		goto unlock_and_exit;
+	}
+
+	/* Get the parent entry */
+
+	parent_node = node->parent;
+	*ret_handle = ACPI_CAST_PTR(acpi_handle, parent_node);
+
+	/* Return exception if parent is null */
+
+	if (!parent_node) {
+		status = AE_NULL_ENTRY;
+	}
+
+      unlock_and_exit:
+
+	(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);
+	return (status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_get_parent)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_get_next_object
+ *
+ * PARAMETERS:  Type            - Type of object to be searched for
+ *              Parent          - Parent object whose children we are getting
+ *              last_child      - Previous child that was found.
+ *                                The NEXT child will be returned
+ *              ret_handle      - Where handle to the next object is placed
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Return the next peer object within the namespace.  If Handle is
+ *              valid, Scope is ignored.  Otherwise, the first object within
+ *              Scope is returned.
+ *
+ ******************************************************************************/
+acpi_status
+acpi_get_next_object(acpi_object_type type,
+		     acpi_handle parent,
+		     acpi_handle child, acpi_handle * ret_handle)
+{
+	acpi_status status;
+	struct acpi_namespace_node *node;
+	struct acpi_namespace_node *parent_node = NULL;
+	struct acpi_namespace_node *child_node = NULL;
+
+	/* Parameter validation */
+
+	if (type > ACPI_TYPE_EXTERNAL_MAX) {
+		return (AE_BAD_PARAMETER);
+	}
+
+	status = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);
+	if (ACPI_FAILURE(status)) {
+		return (status);
+	}
+
+	/* If null handle, use the parent */
+
+	if (!child) {
+
+		/* Start search at the beginning of the specified scope */
+
+		parent_node = acpi_ns_validate_handle(parent);
+		if (!parent_node) {
+			status = AE_BAD_PARAMETER;
+			goto unlock_and_exit;
+		}
+	} else {
+		/* Non-null handle, ignore the parent */
+		/* Convert and validate the handle */
+
+		child_node = acpi_ns_validate_handle(child);
+		if (!child_node) {
+			status = AE_BAD_PARAMETER;
+			goto unlock_and_exit;
+		}
+	}
+
+	/* Internal function does the real work */
+
+	node = acpi_ns_get_next_node_typed(type, parent_node, child_node);
+	if (!node) {
+		status = AE_NOT_FOUND;
+		goto unlock_and_exit;
+	}
+
+	if (ret_handle) {
+		*ret_handle = ACPI_CAST_PTR(acpi_handle, node);
+	}
+
+      unlock_and_exit:
+
+	(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);
+	return (status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_get_next_object)
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/psargs.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/psargs.c
new file mode 100644
index 00000000..57fa5dce
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/psargs.c
@@ -0,0 +1,867 @@
+/******************************************************************************
+ *
+ * Module Name: psargs - Parse AML opcode arguments
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acparser.h"
+#include "amlcode.h"
+#include "acnamesp.h"
+#include "acdispat.h"
+
+#define _COMPONENT          ACPI_PARSER
+ACPI_MODULE_NAME("psargs")
+
+/* Local prototypes */
+static u32
+acpi_ps_get_next_package_length(struct acpi_parse_state *parser_state);
+
+static union acpi_parse_object *acpi_ps_get_next_field(struct acpi_parse_state
+						       *parser_state);
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ps_get_next_package_length
+ *
+ * PARAMETERS:  parser_state        - Current parser state object
+ *
+ * RETURN:      Decoded package length. On completion, the AML pointer points
+ *              past the length byte or bytes.
+ *
+ * DESCRIPTION: Decode and return a package length field.
+ *              Note: Largest package length is 28 bits, from ACPI specification
+ *
+ ******************************************************************************/
+
+static u32
+acpi_ps_get_next_package_length(struct acpi_parse_state *parser_state)
+{
+	u8 *aml = parser_state->aml;
+	u32 package_length = 0;
+	u32 byte_count;
+	u8 byte_zero_mask = 0x3F;	/* Default [0:5] */
+
+	ACPI_FUNCTION_TRACE(ps_get_next_package_length);
+
+	/*
+	 * Byte 0 bits [6:7] contain the number of additional bytes
+	 * used to encode the package length, either 0,1,2, or 3
+	 */
+	byte_count = (aml[0] >> 6);
+	parser_state->aml += ((acpi_size) byte_count + 1);
+
+	/* Get bytes 3, 2, 1 as needed */
+
+	while (byte_count) {
+		/*
+		 * Final bit positions for the package length bytes:
+		 *      Byte3->[20:27]
+		 *      Byte2->[12:19]
+		 *      Byte1->[04:11]
+		 *      Byte0->[00:03]
+		 */
+		package_length |= (aml[byte_count] << ((byte_count << 3) - 4));
+
+		byte_zero_mask = 0x0F;	/* Use bits [0:3] of byte 0 */
+		byte_count--;
+	}
+
+	/* Byte 0 is a special case, either bits [0:3] or [0:5] are used */
+
+	package_length |= (aml[0] & byte_zero_mask);
+	return_UINT32(package_length);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ps_get_next_package_end
+ *
+ * PARAMETERS:  parser_state        - Current parser state object
+ *
+ * RETURN:      Pointer to end-of-package +1
+ *
+ * DESCRIPTION: Get next package length and return a pointer past the end of
+ *              the package.  Consumes the package length field
+ *
+ ******************************************************************************/
+
+u8 *acpi_ps_get_next_package_end(struct acpi_parse_state *parser_state)
+{
+	u8 *start = parser_state->aml;
+	u32 package_length;
+
+	ACPI_FUNCTION_TRACE(ps_get_next_package_end);
+
+	/* Function below updates parser_state->Aml */
+
+	package_length = acpi_ps_get_next_package_length(parser_state);
+
+	return_PTR(start + package_length);	/* end of package */
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ps_get_next_namestring
+ *
+ * PARAMETERS:  parser_state        - Current parser state object
+ *
+ * RETURN:      Pointer to the start of the name string (pointer points into
+ *              the AML.
+ *
+ * DESCRIPTION: Get next raw namestring within the AML stream.  Handles all name
+ *              prefix characters.  Set parser state to point past the string.
+ *              (Name is consumed from the AML.)
+ *
+ ******************************************************************************/
+
+char *acpi_ps_get_next_namestring(struct acpi_parse_state *parser_state)
+{
+	u8 *start = parser_state->aml;
+	u8 *end = parser_state->aml;
+
+	ACPI_FUNCTION_TRACE(ps_get_next_namestring);
+
+	/* Point past any namestring prefix characters (backslash or carat) */
+
+	while (acpi_ps_is_prefix_char(*end)) {
+		end++;
+	}
+
+	/* Decode the path prefix character */
+
+	switch (*end) {
+	case 0:
+
+		/* null_name */
+
+		if (end == start) {
+			start = NULL;
+		}
+		end++;
+		break;
+
+	case AML_DUAL_NAME_PREFIX:
+
+		/* Two name segments */
+
+		end += 1 + (2 * ACPI_NAME_SIZE);
+		break;
+
+	case AML_MULTI_NAME_PREFIX_OP:
+
+		/* Multiple name segments, 4 chars each, count in next byte */
+
+		end += 2 + (*(end + 1) * ACPI_NAME_SIZE);
+		break;
+
+	default:
+
+		/* Single name segment */
+
+		end += ACPI_NAME_SIZE;
+		break;
+	}
+
+	parser_state->aml = end;
+	return_PTR((char *)start);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ps_get_next_namepath
+ *
+ * PARAMETERS:  parser_state        - Current parser state object
+ *              Arg                 - Where the namepath will be stored
+ *              arg_count           - If the namepath points to a control method
+ *                                    the method's argument is returned here.
+ *              possible_method_call - Whether the namepath can possibly be the
+ *                                    start of a method call
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Get next name (if method call, return # of required args).
+ *              Names are looked up in the internal namespace to determine
+ *              if the name represents a control method.  If a method
+ *              is found, the number of arguments to the method is returned.
+ *              This information is critical for parsing to continue correctly.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ps_get_next_namepath(struct acpi_walk_state *walk_state,
+			  struct acpi_parse_state *parser_state,
+			  union acpi_parse_object *arg, u8 possible_method_call)
+{
+	acpi_status status;
+	char *path;
+	union acpi_parse_object *name_op;
+	union acpi_operand_object *method_desc;
+	struct acpi_namespace_node *node;
+	u8 *start = parser_state->aml;
+
+	ACPI_FUNCTION_TRACE(ps_get_next_namepath);
+
+	path = acpi_ps_get_next_namestring(parser_state);
+	acpi_ps_init_op(arg, AML_INT_NAMEPATH_OP);
+
+	/* Null path case is allowed, just exit */
+
+	if (!path) {
+		arg->common.value.name = path;
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	/*
+	 * Lookup the name in the internal namespace, starting with the current
+	 * scope. We don't want to add anything new to the namespace here,
+	 * however, so we use MODE_EXECUTE.
+	 * Allow searching of the parent tree, but don't open a new scope -
+	 * we just want to lookup the object (must be mode EXECUTE to perform
+	 * the upsearch)
+	 */
+	status = acpi_ns_lookup(walk_state->scope_info, path,
+				ACPI_TYPE_ANY, ACPI_IMODE_EXECUTE,
+				ACPI_NS_SEARCH_PARENT | ACPI_NS_DONT_OPEN_SCOPE,
+				NULL, &node);
+
+	/*
+	 * If this name is a control method invocation, we must
+	 * setup the method call
+	 */
+	if (ACPI_SUCCESS(status) &&
+	    possible_method_call && (node->type == ACPI_TYPE_METHOD)) {
+		if (walk_state->opcode == AML_UNLOAD_OP) {
+			/*
+			 * acpi_ps_get_next_namestring has increased the AML pointer,
+			 * so we need to restore the saved AML pointer for method call.
+			 */
+			walk_state->parser_state.aml = start;
+			walk_state->arg_count = 1;
+			acpi_ps_init_op(arg, AML_INT_METHODCALL_OP);
+			return_ACPI_STATUS(AE_OK);
+		}
+
+		/* This name is actually a control method invocation */
+
+		method_desc = acpi_ns_get_attached_object(node);
+		ACPI_DEBUG_PRINT((ACPI_DB_PARSE,
+				  "Control Method - %p Desc %p Path=%p\n", node,
+				  method_desc, path));
+
+		name_op = acpi_ps_alloc_op(AML_INT_NAMEPATH_OP);
+		if (!name_op) {
+			return_ACPI_STATUS(AE_NO_MEMORY);
+		}
+
+		/* Change Arg into a METHOD CALL and attach name to it */
+
+		acpi_ps_init_op(arg, AML_INT_METHODCALL_OP);
+		name_op->common.value.name = path;
+
+		/* Point METHODCALL/NAME to the METHOD Node */
+
+		name_op->common.node = node;
+		acpi_ps_append_arg(arg, name_op);
+
+		if (!method_desc) {
+			ACPI_ERROR((AE_INFO,
+				    "Control Method %p has no attached object",
+				    node));
+			return_ACPI_STATUS(AE_AML_INTERNAL);
+		}
+
+		ACPI_DEBUG_PRINT((ACPI_DB_PARSE,
+				  "Control Method - %p Args %X\n",
+				  node, method_desc->method.param_count));
+
+		/* Get the number of arguments to expect */
+
+		walk_state->arg_count = method_desc->method.param_count;
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	/*
+	 * Special handling if the name was not found during the lookup -
+	 * some not_found cases are allowed
+	 */
+	if (status == AE_NOT_FOUND) {
+
+		/* 1) not_found is ok during load pass 1/2 (allow forward references) */
+
+		if ((walk_state->parse_flags & ACPI_PARSE_MODE_MASK) !=
+		    ACPI_PARSE_EXECUTE) {
+			status = AE_OK;
+		}
+
+		/* 2) not_found during a cond_ref_of(x) is ok by definition */
+
+		else if (walk_state->op->common.aml_opcode ==
+			 AML_COND_REF_OF_OP) {
+			status = AE_OK;
+		}
+
+		/*
+		 * 3) not_found while building a Package is ok at this point, we
+		 * may flag as an error later if slack mode is not enabled.
+		 * (Some ASL code depends on allowing this behavior)
+		 */
+		else if ((arg->common.parent) &&
+			 ((arg->common.parent->common.aml_opcode ==
+			   AML_PACKAGE_OP)
+			  || (arg->common.parent->common.aml_opcode ==
+			      AML_VAR_PACKAGE_OP))) {
+			status = AE_OK;
+		}
+	}
+
+	/* Final exception check (may have been changed from code above) */
+
+	if (ACPI_FAILURE(status)) {
+		ACPI_ERROR_NAMESPACE(path, status);
+
+		if ((walk_state->parse_flags & ACPI_PARSE_MODE_MASK) ==
+		    ACPI_PARSE_EXECUTE) {
+
+			/* Report a control method execution error */
+
+			status = acpi_ds_method_error(status, walk_state);
+		}
+	}
+
+	/* Save the namepath */
+
+	arg->common.value.name = path;
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ps_get_next_simple_arg
+ *
+ * PARAMETERS:  parser_state        - Current parser state object
+ *              arg_type            - The argument type (AML_*_ARG)
+ *              Arg                 - Where the argument is returned
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Get the next simple argument (constant, string, or namestring)
+ *
+ ******************************************************************************/
+
+void
+acpi_ps_get_next_simple_arg(struct acpi_parse_state *parser_state,
+			    u32 arg_type, union acpi_parse_object *arg)
+{
+	u32 length;
+	u16 opcode;
+	u8 *aml = parser_state->aml;
+
+	ACPI_FUNCTION_TRACE_U32(ps_get_next_simple_arg, arg_type);
+
+	switch (arg_type) {
+	case ARGP_BYTEDATA:
+
+		/* Get 1 byte from the AML stream */
+
+		opcode = AML_BYTE_OP;
+		arg->common.value.integer = (u64)*aml;
+		length = 1;
+		break;
+
+	case ARGP_WORDDATA:
+
+		/* Get 2 bytes from the AML stream */
+
+		opcode = AML_WORD_OP;
+		ACPI_MOVE_16_TO_64(&arg->common.value.integer, aml);
+		length = 2;
+		break;
+
+	case ARGP_DWORDDATA:
+
+		/* Get 4 bytes from the AML stream */
+
+		opcode = AML_DWORD_OP;
+		ACPI_MOVE_32_TO_64(&arg->common.value.integer, aml);
+		length = 4;
+		break;
+
+	case ARGP_QWORDDATA:
+
+		/* Get 8 bytes from the AML stream */
+
+		opcode = AML_QWORD_OP;
+		ACPI_MOVE_64_TO_64(&arg->common.value.integer, aml);
+		length = 8;
+		break;
+
+	case ARGP_CHARLIST:
+
+		/* Get a pointer to the string, point past the string */
+
+		opcode = AML_STRING_OP;
+		arg->common.value.string = ACPI_CAST_PTR(char, aml);
+
+		/* Find the null terminator */
+
+		length = 0;
+		while (aml[length]) {
+			length++;
+		}
+		length++;
+		break;
+
+	case ARGP_NAME:
+	case ARGP_NAMESTRING:
+
+		acpi_ps_init_op(arg, AML_INT_NAMEPATH_OP);
+		arg->common.value.name =
+		    acpi_ps_get_next_namestring(parser_state);
+		return_VOID;
+
+	default:
+
+		ACPI_ERROR((AE_INFO, "Invalid ArgType 0x%X", arg_type));
+		return_VOID;
+	}
+
+	acpi_ps_init_op(arg, opcode);
+	parser_state->aml += length;
+	return_VOID;
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ps_get_next_field
+ *
+ * PARAMETERS:  parser_state        - Current parser state object
+ *
+ * RETURN:      A newly allocated FIELD op
+ *
+ * DESCRIPTION: Get next field (named_field, reserved_field, or access_field)
+ *
+ ******************************************************************************/
+
+static union acpi_parse_object *acpi_ps_get_next_field(struct acpi_parse_state
+						       *parser_state)
+{
+	u32 aml_offset;
+	union acpi_parse_object *field;
+	union acpi_parse_object *arg = NULL;
+	u16 opcode;
+	u32 name;
+	u8 access_type;
+	u8 access_attribute;
+	u8 access_length;
+	u32 pkg_length;
+	u8 *pkg_end;
+	u32 buffer_length;
+
+	ACPI_FUNCTION_TRACE(ps_get_next_field);
+
+	aml_offset =
+	    (u32)ACPI_PTR_DIFF(parser_state->aml, parser_state->aml_start);
+
+	/* Determine field type */
+
+	switch (ACPI_GET8(parser_state->aml)) {
+	case AML_FIELD_OFFSET_OP:
+
+		opcode = AML_INT_RESERVEDFIELD_OP;
+		parser_state->aml++;
+		break;
+
+	case AML_FIELD_ACCESS_OP:
+
+		opcode = AML_INT_ACCESSFIELD_OP;
+		parser_state->aml++;
+		break;
+
+	case AML_FIELD_CONNECTION_OP:
+
+		opcode = AML_INT_CONNECTION_OP;
+		parser_state->aml++;
+		break;
+
+	case AML_FIELD_EXT_ACCESS_OP:
+
+		opcode = AML_INT_EXTACCESSFIELD_OP;
+		parser_state->aml++;
+		break;
+
+	default:
+
+		opcode = AML_INT_NAMEDFIELD_OP;
+		break;
+	}
+
+	/* Allocate a new field op */
+
+	field = acpi_ps_alloc_op(opcode);
+	if (!field) {
+		return_PTR(NULL);
+	}
+
+	field->common.aml_offset = aml_offset;
+
+	/* Decode the field type */
+
+	switch (opcode) {
+	case AML_INT_NAMEDFIELD_OP:
+
+		/* Get the 4-character name */
+
+		ACPI_MOVE_32_TO_32(&name, parser_state->aml);
+		acpi_ps_set_name(field, name);
+		parser_state->aml += ACPI_NAME_SIZE;
+
+		/* Get the length which is encoded as a package length */
+
+		field->common.value.size =
+		    acpi_ps_get_next_package_length(parser_state);
+		break;
+
+	case AML_INT_RESERVEDFIELD_OP:
+
+		/* Get the length which is encoded as a package length */
+
+		field->common.value.size =
+		    acpi_ps_get_next_package_length(parser_state);
+		break;
+
+	case AML_INT_ACCESSFIELD_OP:
+	case AML_INT_EXTACCESSFIELD_OP:
+
+		/*
+		 * Get access_type and access_attrib and merge into the field Op
+		 * access_type is first operand, access_attribute is second. stuff
+		 * these bytes into the node integer value for convenience.
+		 */
+
+		/* Get the two bytes (Type/Attribute) */
+
+		access_type = ACPI_GET8(parser_state->aml);
+		parser_state->aml++;
+		access_attribute = ACPI_GET8(parser_state->aml);
+		parser_state->aml++;
+
+		field->common.value.integer = (u8)access_type;
+		field->common.value.integer |= (u16)(access_attribute << 8);
+
+		/* This opcode has a third byte, access_length */
+
+		if (opcode == AML_INT_EXTACCESSFIELD_OP) {
+			access_length = ACPI_GET8(parser_state->aml);
+			parser_state->aml++;
+
+			field->common.value.integer |=
+			    (u32)(access_length << 16);
+		}
+		break;
+
+	case AML_INT_CONNECTION_OP:
+
+		/*
+		 * Argument for Connection operator can be either a Buffer
+		 * (resource descriptor), or a name_string.
+		 */
+		if (ACPI_GET8(parser_state->aml) == AML_BUFFER_OP) {
+			parser_state->aml++;
+
+			pkg_end = parser_state->aml;
+			pkg_length =
+			    acpi_ps_get_next_package_length(parser_state);
+			pkg_end += pkg_length;
+
+			if (parser_state->aml < pkg_end) {
+
+				/* Non-empty list */
+
+				arg = acpi_ps_alloc_op(AML_INT_BYTELIST_OP);
+				if (!arg) {
+					return_PTR(NULL);
+				}
+
+				/* Get the actual buffer length argument */
+
+				opcode = ACPI_GET8(parser_state->aml);
+				parser_state->aml++;
+
+				switch (opcode) {
+				case AML_BYTE_OP:	/* AML_BYTEDATA_ARG */
+					buffer_length =
+					    ACPI_GET8(parser_state->aml);
+					parser_state->aml += 1;
+					break;
+
+				case AML_WORD_OP:	/* AML_WORDDATA_ARG */
+					buffer_length =
+					    ACPI_GET16(parser_state->aml);
+					parser_state->aml += 2;
+					break;
+
+				case AML_DWORD_OP:	/* AML_DWORDATA_ARG */
+					buffer_length =
+					    ACPI_GET32(parser_state->aml);
+					parser_state->aml += 4;
+					break;
+
+				default:
+					buffer_length = 0;
+					break;
+				}
+
+				/* Fill in bytelist data */
+
+				arg->named.value.size = buffer_length;
+				arg->named.data = parser_state->aml;
+			}
+
+			/* Skip to End of byte data */
+
+			parser_state->aml = pkg_end;
+		} else {
+			arg = acpi_ps_alloc_op(AML_INT_NAMEPATH_OP);
+			if (!arg) {
+				return_PTR(NULL);
+			}
+
+			/* Get the Namestring argument */
+
+			arg->common.value.name =
+			    acpi_ps_get_next_namestring(parser_state);
+		}
+
+		/* Link the buffer/namestring to parent (CONNECTION_OP) */
+
+		acpi_ps_append_arg(field, arg);
+		break;
+
+	default:
+
+		/* Opcode was set in previous switch */
+		break;
+	}
+
+	return_PTR(field);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ps_get_next_arg
+ *
+ * PARAMETERS:  walk_state          - Current state
+ *              parser_state        - Current parser state object
+ *              arg_type            - The argument type (AML_*_ARG)
+ *              return_arg          - Where the next arg is returned
+ *
+ * RETURN:      Status, and an op object containing the next argument.
+ *
+ * DESCRIPTION: Get next argument (including complex list arguments that require
+ *              pushing the parser stack)
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ps_get_next_arg(struct acpi_walk_state *walk_state,
+		     struct acpi_parse_state *parser_state,
+		     u32 arg_type, union acpi_parse_object **return_arg)
+{
+	union acpi_parse_object *arg = NULL;
+	union acpi_parse_object *prev = NULL;
+	union acpi_parse_object *field;
+	u32 subop;
+	acpi_status status = AE_OK;
+
+	ACPI_FUNCTION_TRACE_PTR(ps_get_next_arg, parser_state);
+
+	switch (arg_type) {
+	case ARGP_BYTEDATA:
+	case ARGP_WORDDATA:
+	case ARGP_DWORDDATA:
+	case ARGP_CHARLIST:
+	case ARGP_NAME:
+	case ARGP_NAMESTRING:
+
+		/* Constants, strings, and namestrings are all the same size */
+
+		arg = acpi_ps_alloc_op(AML_BYTE_OP);
+		if (!arg) {
+			return_ACPI_STATUS(AE_NO_MEMORY);
+		}
+		acpi_ps_get_next_simple_arg(parser_state, arg_type, arg);
+		break;
+
+	case ARGP_PKGLENGTH:
+
+		/* Package length, nothing returned */
+
+		parser_state->pkg_end =
+		    acpi_ps_get_next_package_end(parser_state);
+		break;
+
+	case ARGP_FIELDLIST:
+
+		if (parser_state->aml < parser_state->pkg_end) {
+
+			/* Non-empty list */
+
+			while (parser_state->aml < parser_state->pkg_end) {
+				field = acpi_ps_get_next_field(parser_state);
+				if (!field) {
+					return_ACPI_STATUS(AE_NO_MEMORY);
+				}
+
+				if (prev) {
+					prev->common.next = field;
+				} else {
+					arg = field;
+				}
+				prev = field;
+			}
+
+			/* Skip to End of byte data */
+
+			parser_state->aml = parser_state->pkg_end;
+		}
+		break;
+
+	case ARGP_BYTELIST:
+
+		if (parser_state->aml < parser_state->pkg_end) {
+
+			/* Non-empty list */
+
+			arg = acpi_ps_alloc_op(AML_INT_BYTELIST_OP);
+			if (!arg) {
+				return_ACPI_STATUS(AE_NO_MEMORY);
+			}
+
+			/* Fill in bytelist data */
+
+			arg->common.value.size = (u32)
+			    ACPI_PTR_DIFF(parser_state->pkg_end,
+					  parser_state->aml);
+			arg->named.data = parser_state->aml;
+
+			/* Skip to End of byte data */
+
+			parser_state->aml = parser_state->pkg_end;
+		}
+		break;
+
+	case ARGP_TARGET:
+	case ARGP_SUPERNAME:
+	case ARGP_SIMPLENAME:
+
+		subop = acpi_ps_peek_opcode(parser_state);
+		if (subop == 0 ||
+		    acpi_ps_is_leading_char(subop) ||
+		    acpi_ps_is_prefix_char(subop)) {
+
+			/* null_name or name_string */
+
+			arg = acpi_ps_alloc_op(AML_INT_NAMEPATH_OP);
+			if (!arg) {
+				return_ACPI_STATUS(AE_NO_MEMORY);
+			}
+
+			/* To support super_name arg of Unload */
+
+			if (walk_state->opcode == AML_UNLOAD_OP) {
+				status =
+				    acpi_ps_get_next_namepath(walk_state,
+							      parser_state, arg,
+							      1);
+
+				/*
+				 * If the super_name arg of Unload is a method call,
+				 * we have restored the AML pointer, just free this Arg
+				 */
+				if (arg->common.aml_opcode ==
+				    AML_INT_METHODCALL_OP) {
+					acpi_ps_free_op(arg);
+					arg = NULL;
+				}
+			} else {
+				status =
+				    acpi_ps_get_next_namepath(walk_state,
+							      parser_state, arg,
+							      0);
+			}
+		} else {
+			/* Single complex argument, nothing returned */
+
+			walk_state->arg_count = 1;
+		}
+		break;
+
+	case ARGP_DATAOBJ:
+	case ARGP_TERMARG:
+
+		/* Single complex argument, nothing returned */
+
+		walk_state->arg_count = 1;
+		break;
+
+	case ARGP_DATAOBJLIST:
+	case ARGP_TERMLIST:
+	case ARGP_OBJLIST:
+
+		if (parser_state->aml < parser_state->pkg_end) {
+
+			/* Non-empty list of variable arguments, nothing returned */
+
+			walk_state->arg_count = ACPI_VAR_ARGS;
+		}
+		break;
+
+	default:
+
+		ACPI_ERROR((AE_INFO, "Invalid ArgType: 0x%X", arg_type));
+		status = AE_AML_OPERAND_TYPE;
+		break;
+	}
+
+	*return_arg = arg;
+	return_ACPI_STATUS(status);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/psloop.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/psloop.c
new file mode 100644
index 00000000..4b96f143
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/psloop.c
@@ -0,0 +1,1215 @@
+/******************************************************************************
+ *
+ * Module Name: psloop - Main AML parse loop
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+/*
+ * Parse the AML and build an operation tree as most interpreters, (such as
+ * Perl) do. Parsing is done by hand rather than with a YACC generated parser
+ * to tightly constrain stack and dynamic memory usage. Parsing is kept
+ * flexible and the code fairly compact by parsing based on a list of AML
+ * opcode templates in aml_op_info[].
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acparser.h"
+#include "acdispat.h"
+#include "amlcode.h"
+
+#define _COMPONENT          ACPI_PARSER
+ACPI_MODULE_NAME("psloop")
+
+static u32 acpi_gbl_depth = 0;
+
+/* Local prototypes */
+
+static acpi_status acpi_ps_get_aml_opcode(struct acpi_walk_state *walk_state);
+
+static acpi_status
+acpi_ps_build_named_op(struct acpi_walk_state *walk_state,
+		       u8 *aml_op_start,
+		       union acpi_parse_object *unnamed_op,
+		       union acpi_parse_object **op);
+
+static acpi_status
+acpi_ps_create_op(struct acpi_walk_state *walk_state,
+		  u8 *aml_op_start, union acpi_parse_object **new_op);
+
+static acpi_status
+acpi_ps_get_arguments(struct acpi_walk_state *walk_state,
+		      u8 *aml_op_start, union acpi_parse_object *op);
+
+static acpi_status
+acpi_ps_complete_op(struct acpi_walk_state *walk_state,
+		    union acpi_parse_object **op, acpi_status status);
+
+static acpi_status
+acpi_ps_complete_final_op(struct acpi_walk_state *walk_state,
+			  union acpi_parse_object *op, acpi_status status);
+
+static void
+acpi_ps_link_module_code(union acpi_parse_object *parent_op,
+			 u8 *aml_start, u32 aml_length, acpi_owner_id owner_id);
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ps_get_aml_opcode
+ *
+ * PARAMETERS:  walk_state          - Current state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Extract the next AML opcode from the input stream.
+ *
+ ******************************************************************************/
+
+static acpi_status acpi_ps_get_aml_opcode(struct acpi_walk_state *walk_state)
+{
+
+	ACPI_FUNCTION_TRACE_PTR(ps_get_aml_opcode, walk_state);
+
+	walk_state->aml_offset =
+	    (u32)ACPI_PTR_DIFF(walk_state->parser_state.aml,
+			       walk_state->parser_state.aml_start);
+	walk_state->opcode = acpi_ps_peek_opcode(&(walk_state->parser_state));
+
+	/*
+	 * First cut to determine what we have found:
+	 * 1) A valid AML opcode
+	 * 2) A name string
+	 * 3) An unknown/invalid opcode
+	 */
+	walk_state->op_info = acpi_ps_get_opcode_info(walk_state->opcode);
+
+	switch (walk_state->op_info->class) {
+	case AML_CLASS_ASCII:
+	case AML_CLASS_PREFIX:
+		/*
+		 * Starts with a valid prefix or ASCII char, this is a name
+		 * string. Convert the bare name string to a namepath.
+		 */
+		walk_state->opcode = AML_INT_NAMEPATH_OP;
+		walk_state->arg_types = ARGP_NAMESTRING;
+		break;
+
+	case AML_CLASS_UNKNOWN:
+
+		/* The opcode is unrecognized. Just skip unknown opcodes */
+
+		ACPI_ERROR((AE_INFO,
+			    "Found unknown opcode 0x%X at AML address %p offset 0x%X, ignoring",
+			    walk_state->opcode, walk_state->parser_state.aml,
+			    walk_state->aml_offset));
+
+		ACPI_DUMP_BUFFER(walk_state->parser_state.aml, 128);
+
+		/* Assume one-byte bad opcode */
+
+		walk_state->parser_state.aml++;
+		return_ACPI_STATUS(AE_CTRL_PARSE_CONTINUE);
+
+	default:
+
+		/* Found opcode info, this is a normal opcode */
+
+		walk_state->parser_state.aml +=
+		    acpi_ps_get_opcode_size(walk_state->opcode);
+		walk_state->arg_types = walk_state->op_info->parse_args;
+		break;
+	}
+
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ps_build_named_op
+ *
+ * PARAMETERS:  walk_state          - Current state
+ *              aml_op_start        - Begin of named Op in AML
+ *              unnamed_op          - Early Op (not a named Op)
+ *              Op                  - Returned Op
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Parse a named Op
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ps_build_named_op(struct acpi_walk_state *walk_state,
+		       u8 *aml_op_start,
+		       union acpi_parse_object *unnamed_op,
+		       union acpi_parse_object **op)
+{
+	acpi_status status = AE_OK;
+	union acpi_parse_object *arg = NULL;
+
+	ACPI_FUNCTION_TRACE_PTR(ps_build_named_op, walk_state);
+
+	unnamed_op->common.value.arg = NULL;
+	unnamed_op->common.arg_list_length = 0;
+	unnamed_op->common.aml_opcode = walk_state->opcode;
+
+	/*
+	 * Get and append arguments until we find the node that contains
+	 * the name (the type ARGP_NAME).
+	 */
+	while (GET_CURRENT_ARG_TYPE(walk_state->arg_types) &&
+	       (GET_CURRENT_ARG_TYPE(walk_state->arg_types) != ARGP_NAME)) {
+		status =
+		    acpi_ps_get_next_arg(walk_state,
+					 &(walk_state->parser_state),
+					 GET_CURRENT_ARG_TYPE(walk_state->
+							      arg_types), &arg);
+		if (ACPI_FAILURE(status)) {
+			return_ACPI_STATUS(status);
+		}
+
+		acpi_ps_append_arg(unnamed_op, arg);
+		INCREMENT_ARG_LIST(walk_state->arg_types);
+	}
+
+	/*
+	 * Make sure that we found a NAME and didn't run out of arguments
+	 */
+	if (!GET_CURRENT_ARG_TYPE(walk_state->arg_types)) {
+		return_ACPI_STATUS(AE_AML_NO_OPERAND);
+	}
+
+	/* We know that this arg is a name, move to next arg */
+
+	INCREMENT_ARG_LIST(walk_state->arg_types);
+
+	/*
+	 * Find the object. This will either insert the object into
+	 * the namespace or simply look it up
+	 */
+	walk_state->op = NULL;
+
+	status = walk_state->descending_callback(walk_state, op);
+	if (ACPI_FAILURE(status)) {
+		ACPI_EXCEPTION((AE_INFO, status, "During name lookup/catalog"));
+		return_ACPI_STATUS(status);
+	}
+
+	if (!*op) {
+		return_ACPI_STATUS(AE_CTRL_PARSE_CONTINUE);
+	}
+
+	status = acpi_ps_next_parse_state(walk_state, *op, status);
+	if (ACPI_FAILURE(status)) {
+		if (status == AE_CTRL_PENDING) {
+			return_ACPI_STATUS(AE_CTRL_PARSE_PENDING);
+		}
+		return_ACPI_STATUS(status);
+	}
+
+	acpi_ps_append_arg(*op, unnamed_op->common.value.arg);
+	acpi_gbl_depth++;
+
+	if ((*op)->common.aml_opcode == AML_REGION_OP ||
+	    (*op)->common.aml_opcode == AML_DATA_REGION_OP) {
+		/*
+		 * Defer final parsing of an operation_region body, because we don't
+		 * have enough info in the first pass to parse it correctly (i.e.,
+		 * there may be method calls within the term_arg elements of the body.)
+		 *
+		 * However, we must continue parsing because the opregion is not a
+		 * standalone package -- we don't know where the end is at this point.
+		 *
+		 * (Length is unknown until parse of the body complete)
+		 */
+		(*op)->named.data = aml_op_start;
+		(*op)->named.length = 0;
+	}
+
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ps_create_op
+ *
+ * PARAMETERS:  walk_state          - Current state
+ *              aml_op_start        - Op start in AML
+ *              new_op              - Returned Op
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Get Op from AML
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ps_create_op(struct acpi_walk_state *walk_state,
+		  u8 *aml_op_start, union acpi_parse_object **new_op)
+{
+	acpi_status status = AE_OK;
+	union acpi_parse_object *op;
+	union acpi_parse_object *named_op = NULL;
+	union acpi_parse_object *parent_scope;
+	u8 argument_count;
+	const struct acpi_opcode_info *op_info;
+
+	ACPI_FUNCTION_TRACE_PTR(ps_create_op, walk_state);
+
+	status = acpi_ps_get_aml_opcode(walk_state);
+	if (status == AE_CTRL_PARSE_CONTINUE) {
+		return_ACPI_STATUS(AE_CTRL_PARSE_CONTINUE);
+	}
+
+	/* Create Op structure and append to parent's argument list */
+
+	walk_state->op_info = acpi_ps_get_opcode_info(walk_state->opcode);
+	op = acpi_ps_alloc_op(walk_state->opcode);
+	if (!op) {
+		return_ACPI_STATUS(AE_NO_MEMORY);
+	}
+
+	if (walk_state->op_info->flags & AML_NAMED) {
+		status =
+		    acpi_ps_build_named_op(walk_state, aml_op_start, op,
+					   &named_op);
+		acpi_ps_free_op(op);
+		if (ACPI_FAILURE(status)) {
+			return_ACPI_STATUS(status);
+		}
+
+		*new_op = named_op;
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	/* Not a named opcode, just allocate Op and append to parent */
+
+	if (walk_state->op_info->flags & AML_CREATE) {
+		/*
+		 * Backup to beginning of create_xXXfield declaration
+		 * body_length is unknown until we parse the body
+		 */
+		op->named.data = aml_op_start;
+		op->named.length = 0;
+	}
+
+	if (walk_state->opcode == AML_BANK_FIELD_OP) {
+		/*
+		 * Backup to beginning of bank_field declaration
+		 * body_length is unknown until we parse the body
+		 */
+		op->named.data = aml_op_start;
+		op->named.length = 0;
+	}
+
+	parent_scope = acpi_ps_get_parent_scope(&(walk_state->parser_state));
+	acpi_ps_append_arg(parent_scope, op);
+
+	if (parent_scope) {
+		op_info =
+		    acpi_ps_get_opcode_info(parent_scope->common.aml_opcode);
+		if (op_info->flags & AML_HAS_TARGET) {
+			argument_count =
+			    acpi_ps_get_argument_count(op_info->type);
+			if (parent_scope->common.arg_list_length >
+			    argument_count) {
+				op->common.flags |= ACPI_PARSEOP_TARGET;
+			}
+		} else if (parent_scope->common.aml_opcode == AML_INCREMENT_OP) {
+			op->common.flags |= ACPI_PARSEOP_TARGET;
+		}
+	}
+
+	if (walk_state->descending_callback != NULL) {
+		/*
+		 * Find the object. This will either insert the object into
+		 * the namespace or simply look it up
+		 */
+		walk_state->op = *new_op = op;
+
+		status = walk_state->descending_callback(walk_state, &op);
+		status = acpi_ps_next_parse_state(walk_state, op, status);
+		if (status == AE_CTRL_PENDING) {
+			status = AE_CTRL_PARSE_PENDING;
+		}
+	}
+
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ps_get_arguments
+ *
+ * PARAMETERS:  walk_state          - Current state
+ *              aml_op_start        - Op start in AML
+ *              Op                  - Current Op
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Get arguments for passed Op.
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ps_get_arguments(struct acpi_walk_state *walk_state,
+		      u8 *aml_op_start, union acpi_parse_object *op)
+{
+	acpi_status status = AE_OK;
+	union acpi_parse_object *arg = NULL;
+	const struct acpi_opcode_info *op_info;
+
+	ACPI_FUNCTION_TRACE_PTR(ps_get_arguments, walk_state);
+
+	switch (op->common.aml_opcode) {
+	case AML_BYTE_OP:	/* AML_BYTEDATA_ARG */
+	case AML_WORD_OP:	/* AML_WORDDATA_ARG */
+	case AML_DWORD_OP:	/* AML_DWORDATA_ARG */
+	case AML_QWORD_OP:	/* AML_QWORDATA_ARG */
+	case AML_STRING_OP:	/* AML_ASCIICHARLIST_ARG */
+
+		/* Fill in constant or string argument directly */
+
+		acpi_ps_get_next_simple_arg(&(walk_state->parser_state),
+					    GET_CURRENT_ARG_TYPE(walk_state->
+								 arg_types),
+					    op);
+		break;
+
+	case AML_INT_NAMEPATH_OP:	/* AML_NAMESTRING_ARG */
+
+		status =
+		    acpi_ps_get_next_namepath(walk_state,
+					      &(walk_state->parser_state), op,
+					      1);
+		if (ACPI_FAILURE(status)) {
+			return_ACPI_STATUS(status);
+		}
+
+		walk_state->arg_types = 0;
+		break;
+
+	default:
+		/*
+		 * Op is not a constant or string, append each argument to the Op
+		 */
+		while (GET_CURRENT_ARG_TYPE(walk_state->arg_types)
+		       && !walk_state->arg_count) {
+			walk_state->aml_offset =
+			    (u32)ACPI_PTR_DIFF(walk_state->parser_state.aml,
+					       walk_state->parser_state.
+					       aml_start);
+
+			status =
+			    acpi_ps_get_next_arg(walk_state,
+						 &(walk_state->parser_state),
+						 GET_CURRENT_ARG_TYPE
+						 (walk_state->arg_types), &arg);
+			if (ACPI_FAILURE(status)) {
+				return_ACPI_STATUS(status);
+			}
+
+			if (arg) {
+				arg->common.aml_offset = walk_state->aml_offset;
+				acpi_ps_append_arg(op, arg);
+			}
+
+			INCREMENT_ARG_LIST(walk_state->arg_types);
+		}
+
+		/*
+		 * Handle executable code at "module-level". This refers to
+		 * executable opcodes that appear outside of any control method.
+		 */
+		if ((walk_state->pass_number <= ACPI_IMODE_LOAD_PASS2) &&
+		    ((walk_state->parse_flags & ACPI_PARSE_DISASSEMBLE) == 0)) {
+			/*
+			 * We want to skip If/Else/While constructs during Pass1 because we
+			 * want to actually conditionally execute the code during Pass2.
+			 *
+			 * Except for disassembly, where we always want to walk the
+			 * If/Else/While packages
+			 */
+			switch (op->common.aml_opcode) {
+			case AML_IF_OP:
+			case AML_ELSE_OP:
+			case AML_WHILE_OP:
+
+				/*
+				 * Currently supported module-level opcodes are:
+				 * IF/ELSE/WHILE. These appear to be the most common,
+				 * and easiest to support since they open an AML
+				 * package.
+				 */
+				if (walk_state->pass_number ==
+				    ACPI_IMODE_LOAD_PASS1) {
+					acpi_ps_link_module_code(op->common.
+								 parent,
+								 aml_op_start,
+								 (u32)
+								 (walk_state->
+								  parser_state.
+								  pkg_end -
+								  aml_op_start),
+								 walk_state->
+								 owner_id);
+				}
+
+				ACPI_DEBUG_PRINT((ACPI_DB_PARSE,
+						  "Pass1: Skipping an If/Else/While body\n"));
+
+				/* Skip body of if/else/while in pass 1 */
+
+				walk_state->parser_state.aml =
+				    walk_state->parser_state.pkg_end;
+				walk_state->arg_count = 0;
+				break;
+
+			default:
+				/*
+				 * Check for an unsupported executable opcode at module
+				 * level. We must be in PASS1, the parent must be a SCOPE,
+				 * The opcode class must be EXECUTE, and the opcode must
+				 * not be an argument to another opcode.
+				 */
+				if ((walk_state->pass_number ==
+				     ACPI_IMODE_LOAD_PASS1)
+				    && (op->common.parent->common.aml_opcode ==
+					AML_SCOPE_OP)) {
+					op_info =
+					    acpi_ps_get_opcode_info(op->common.
+								    aml_opcode);
+					if ((op_info->class ==
+					     AML_CLASS_EXECUTE) && (!arg)) {
+						ACPI_WARNING((AE_INFO,
+							      "Detected an unsupported executable opcode "
+							      "at module-level: [0x%.4X] at table offset 0x%.4X",
+							      op->common.
+							      aml_opcode,
+							      (u32)
+							      (ACPI_PTR_DIFF
+							       (aml_op_start,
+								walk_state->
+								parser_state.
+								aml_start) +
+							       sizeof(struct
+								      acpi_table_header))));
+					}
+				}
+				break;
+			}
+		}
+
+		/* Special processing for certain opcodes */
+
+		switch (op->common.aml_opcode) {
+		case AML_METHOD_OP:
+			/*
+			 * Skip parsing of control method because we don't have enough
+			 * info in the first pass to parse it correctly.
+			 *
+			 * Save the length and address of the body
+			 */
+			op->named.data = walk_state->parser_state.aml;
+			op->named.length = (u32)
+			    (walk_state->parser_state.pkg_end -
+			     walk_state->parser_state.aml);
+
+			/* Skip body of method */
+
+			walk_state->parser_state.aml =
+			    walk_state->parser_state.pkg_end;
+			walk_state->arg_count = 0;
+			break;
+
+		case AML_BUFFER_OP:
+		case AML_PACKAGE_OP:
+		case AML_VAR_PACKAGE_OP:
+
+			if ((op->common.parent) &&
+			    (op->common.parent->common.aml_opcode ==
+			     AML_NAME_OP)
+			    && (walk_state->pass_number <=
+				ACPI_IMODE_LOAD_PASS2)) {
+				/*
+				 * Skip parsing of Buffers and Packages because we don't have
+				 * enough info in the first pass to parse them correctly.
+				 */
+				op->named.data = aml_op_start;
+				op->named.length = (u32)
+				    (walk_state->parser_state.pkg_end -
+				     aml_op_start);
+
+				/* Skip body */
+
+				walk_state->parser_state.aml =
+				    walk_state->parser_state.pkg_end;
+				walk_state->arg_count = 0;
+			}
+			break;
+
+		case AML_WHILE_OP:
+
+			if (walk_state->control_state) {
+				walk_state->control_state->control.package_end =
+				    walk_state->parser_state.pkg_end;
+			}
+			break;
+
+		default:
+
+			/* No action for all other opcodes */
+			break;
+		}
+
+		break;
+	}
+
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ps_link_module_code
+ *
+ * PARAMETERS:  parent_op           - Parent parser op
+ *              aml_start           - Pointer to the AML
+ *              aml_length          - Length of executable AML
+ *              owner_id            - owner_id of module level code
+ *
+ * RETURN:      None.
+ *
+ * DESCRIPTION: Wrap the module-level code with a method object and link the
+ *              object to the global list. Note, the mutex field of the method
+ *              object is used to link multiple module-level code objects.
+ *
+ ******************************************************************************/
+
+static void
+acpi_ps_link_module_code(union acpi_parse_object *parent_op,
+			 u8 *aml_start, u32 aml_length, acpi_owner_id owner_id)
+{
+	union acpi_operand_object *prev;
+	union acpi_operand_object *next;
+	union acpi_operand_object *method_obj;
+	struct acpi_namespace_node *parent_node;
+
+	/* Get the tail of the list */
+
+	prev = next = acpi_gbl_module_code_list;
+	while (next) {
+		prev = next;
+		next = next->method.mutex;
+	}
+
+	/*
+	 * Insert the module level code into the list. Merge it if it is
+	 * adjacent to the previous element.
+	 */
+	if (!prev ||
+	    ((prev->method.aml_start + prev->method.aml_length) != aml_start)) {
+
+		/* Create, initialize, and link a new temporary method object */
+
+		method_obj = acpi_ut_create_internal_object(ACPI_TYPE_METHOD);
+		if (!method_obj) {
+			return;
+		}
+
+		if (parent_op->common.node) {
+			parent_node = parent_op->common.node;
+		} else {
+			parent_node = acpi_gbl_root_node;
+		}
+
+		method_obj->method.aml_start = aml_start;
+		method_obj->method.aml_length = aml_length;
+		method_obj->method.owner_id = owner_id;
+		method_obj->method.info_flags |= ACPI_METHOD_MODULE_LEVEL;
+
+		/*
+		 * Save the parent node in next_object. This is cheating, but we
+		 * don't want to expand the method object.
+		 */
+		method_obj->method.next_object =
+		    ACPI_CAST_PTR(union acpi_operand_object, parent_node);
+
+		if (!prev) {
+			acpi_gbl_module_code_list = method_obj;
+		} else {
+			prev->method.mutex = method_obj;
+		}
+	} else {
+		prev->method.aml_length += aml_length;
+	}
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ps_complete_op
+ *
+ * PARAMETERS:  walk_state          - Current state
+ *              Op                  - Returned Op
+ *              Status              - Parse status before complete Op
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Complete Op
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ps_complete_op(struct acpi_walk_state *walk_state,
+		    union acpi_parse_object **op, acpi_status status)
+{
+	acpi_status status2;
+
+	ACPI_FUNCTION_TRACE_PTR(ps_complete_op, walk_state);
+
+	/*
+	 * Finished one argument of the containing scope
+	 */
+	walk_state->parser_state.scope->parse_scope.arg_count--;
+
+	/* Close this Op (will result in parse subtree deletion) */
+
+	status2 = acpi_ps_complete_this_op(walk_state, *op);
+	if (ACPI_FAILURE(status2)) {
+		return_ACPI_STATUS(status2);
+	}
+
+	*op = NULL;
+
+	switch (status) {
+	case AE_OK:
+		break;
+
+	case AE_CTRL_TRANSFER:
+
+		/* We are about to transfer to a called method */
+
+		walk_state->prev_op = NULL;
+		walk_state->prev_arg_types = walk_state->arg_types;
+		return_ACPI_STATUS(status);
+
+	case AE_CTRL_END:
+
+		acpi_ps_pop_scope(&(walk_state->parser_state), op,
+				  &walk_state->arg_types,
+				  &walk_state->arg_count);
+
+		if (*op) {
+			walk_state->op = *op;
+			walk_state->op_info =
+			    acpi_ps_get_opcode_info((*op)->common.aml_opcode);
+			walk_state->opcode = (*op)->common.aml_opcode;
+
+			status = walk_state->ascending_callback(walk_state);
+			status =
+			    acpi_ps_next_parse_state(walk_state, *op, status);
+
+			status2 = acpi_ps_complete_this_op(walk_state, *op);
+			if (ACPI_FAILURE(status2)) {
+				return_ACPI_STATUS(status2);
+			}
+		}
+
+		status = AE_OK;
+		break;
+
+	case AE_CTRL_BREAK:
+	case AE_CTRL_CONTINUE:
+
+		/* Pop off scopes until we find the While */
+
+		while (!(*op) || ((*op)->common.aml_opcode != AML_WHILE_OP)) {
+			acpi_ps_pop_scope(&(walk_state->parser_state), op,
+					  &walk_state->arg_types,
+					  &walk_state->arg_count);
+		}
+
+		/* Close this iteration of the While loop */
+
+		walk_state->op = *op;
+		walk_state->op_info =
+		    acpi_ps_get_opcode_info((*op)->common.aml_opcode);
+		walk_state->opcode = (*op)->common.aml_opcode;
+
+		status = walk_state->ascending_callback(walk_state);
+		status = acpi_ps_next_parse_state(walk_state, *op, status);
+
+		status2 = acpi_ps_complete_this_op(walk_state, *op);
+		if (ACPI_FAILURE(status2)) {
+			return_ACPI_STATUS(status2);
+		}
+
+		status = AE_OK;
+		break;
+
+	case AE_CTRL_TERMINATE:
+
+		/* Clean up */
+		do {
+			if (*op) {
+				status2 =
+				    acpi_ps_complete_this_op(walk_state, *op);
+				if (ACPI_FAILURE(status2)) {
+					return_ACPI_STATUS(status2);
+				}
+
+				acpi_ut_delete_generic_state
+				    (acpi_ut_pop_generic_state
+				     (&walk_state->control_state));
+			}
+
+			acpi_ps_pop_scope(&(walk_state->parser_state), op,
+					  &walk_state->arg_types,
+					  &walk_state->arg_count);
+
+		} while (*op);
+
+		return_ACPI_STATUS(AE_OK);
+
+	default:		/* All other non-AE_OK status */
+
+		do {
+			if (*op) {
+				status2 =
+				    acpi_ps_complete_this_op(walk_state, *op);
+				if (ACPI_FAILURE(status2)) {
+					return_ACPI_STATUS(status2);
+				}
+			}
+
+			acpi_ps_pop_scope(&(walk_state->parser_state), op,
+					  &walk_state->arg_types,
+					  &walk_state->arg_count);
+
+		} while (*op);
+
+#if 0
+		/*
+		 * TBD: Cleanup parse ops on error
+		 */
+		if (*op == NULL) {
+			acpi_ps_pop_scope(parser_state, op,
+					  &walk_state->arg_types,
+					  &walk_state->arg_count);
+		}
+#endif
+		walk_state->prev_op = NULL;
+		walk_state->prev_arg_types = walk_state->arg_types;
+		return_ACPI_STATUS(status);
+	}
+
+	/* This scope complete? */
+
+	if (acpi_ps_has_completed_scope(&(walk_state->parser_state))) {
+		acpi_ps_pop_scope(&(walk_state->parser_state), op,
+				  &walk_state->arg_types,
+				  &walk_state->arg_count);
+		ACPI_DEBUG_PRINT((ACPI_DB_PARSE, "Popped scope, Op=%p\n", *op));
+	} else {
+		*op = NULL;
+	}
+
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ps_complete_final_op
+ *
+ * PARAMETERS:  walk_state          - Current state
+ *              Op                  - Current Op
+ *              Status              - Current parse status before complete last
+ *                                    Op
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Complete last Op.
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ps_complete_final_op(struct acpi_walk_state *walk_state,
+			  union acpi_parse_object *op, acpi_status status)
+{
+	acpi_status status2;
+
+	ACPI_FUNCTION_TRACE_PTR(ps_complete_final_op, walk_state);
+
+	/*
+	 * Complete the last Op (if not completed), and clear the scope stack.
+	 * It is easily possible to end an AML "package" with an unbounded number
+	 * of open scopes (such as when several ASL blocks are closed with
+	 * sequential closing braces). We want to terminate each one cleanly.
+	 */
+	ACPI_DEBUG_PRINT((ACPI_DB_PARSE, "AML package complete at Op %p\n",
+			  op));
+	do {
+		if (op) {
+			if (walk_state->ascending_callback != NULL) {
+				walk_state->op = op;
+				walk_state->op_info =
+				    acpi_ps_get_opcode_info(op->common.
+							    aml_opcode);
+				walk_state->opcode = op->common.aml_opcode;
+
+				status =
+				    walk_state->ascending_callback(walk_state);
+				status =
+				    acpi_ps_next_parse_state(walk_state, op,
+							     status);
+				if (status == AE_CTRL_PENDING) {
+					status =
+					    acpi_ps_complete_op(walk_state, &op,
+								AE_OK);
+					if (ACPI_FAILURE(status)) {
+						return_ACPI_STATUS(status);
+					}
+				}
+
+				if (status == AE_CTRL_TERMINATE) {
+					status = AE_OK;
+
+					/* Clean up */
+					do {
+						if (op) {
+							status2 =
+							    acpi_ps_complete_this_op
+							    (walk_state, op);
+							if (ACPI_FAILURE
+							    (status2)) {
+								return_ACPI_STATUS
+								    (status2);
+							}
+						}
+
+						acpi_ps_pop_scope(&
+								  (walk_state->
+								   parser_state),
+								  &op,
+								  &walk_state->
+								  arg_types,
+								  &walk_state->
+								  arg_count);
+
+					} while (op);
+
+					return_ACPI_STATUS(status);
+				}
+
+				else if (ACPI_FAILURE(status)) {
+
+					/* First error is most important */
+
+					(void)
+					    acpi_ps_complete_this_op(walk_state,
+								     op);
+					return_ACPI_STATUS(status);
+				}
+			}
+
+			status2 = acpi_ps_complete_this_op(walk_state, op);
+			if (ACPI_FAILURE(status2)) {
+				return_ACPI_STATUS(status2);
+			}
+		}
+
+		acpi_ps_pop_scope(&(walk_state->parser_state), &op,
+				  &walk_state->arg_types,
+				  &walk_state->arg_count);
+
+	} while (op);
+
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ps_parse_loop
+ *
+ * PARAMETERS:  walk_state          - Current state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Parse AML (pointed to by the current parser state) and return
+ *              a tree of ops.
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ps_parse_loop(struct acpi_walk_state *walk_state)
+{
+	acpi_status status = AE_OK;
+	union acpi_parse_object *op = NULL;	/* current op */
+	struct acpi_parse_state *parser_state;
+	u8 *aml_op_start = NULL;
+
+	ACPI_FUNCTION_TRACE_PTR(ps_parse_loop, walk_state);
+
+	if (walk_state->descending_callback == NULL) {
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	parser_state = &walk_state->parser_state;
+	walk_state->arg_types = 0;
+
+#if (!defined (ACPI_NO_METHOD_EXECUTION) && !defined (ACPI_CONSTANT_EVAL_ONLY))
+
+	if (walk_state->walk_type & ACPI_WALK_METHOD_RESTART) {
+
+		/* We are restarting a preempted control method */
+
+		if (acpi_ps_has_completed_scope(parser_state)) {
+			/*
+			 * We must check if a predicate to an IF or WHILE statement
+			 * was just completed
+			 */
+			if ((parser_state->scope->parse_scope.op) &&
+			    ((parser_state->scope->parse_scope.op->common.
+			      aml_opcode == AML_IF_OP)
+			     || (parser_state->scope->parse_scope.op->common.
+				 aml_opcode == AML_WHILE_OP))
+			    && (walk_state->control_state)
+			    && (walk_state->control_state->common.state ==
+				ACPI_CONTROL_PREDICATE_EXECUTING)) {
+				/*
+				 * A predicate was just completed, get the value of the
+				 * predicate and branch based on that value
+				 */
+				walk_state->op = NULL;
+				status =
+				    acpi_ds_get_predicate_value(walk_state,
+								ACPI_TO_POINTER
+								(TRUE));
+				if (ACPI_FAILURE(status)
+				    && ((status & AE_CODE_MASK) !=
+					AE_CODE_CONTROL)) {
+					if (status == AE_AML_NO_RETURN_VALUE) {
+						ACPI_EXCEPTION((AE_INFO, status,
+								"Invoked method did not return a value"));
+					}
+
+					ACPI_EXCEPTION((AE_INFO, status,
+							"GetPredicate Failed"));
+					return_ACPI_STATUS(status);
+				}
+
+				status =
+				    acpi_ps_next_parse_state(walk_state, op,
+							     status);
+			}
+
+			acpi_ps_pop_scope(parser_state, &op,
+					  &walk_state->arg_types,
+					  &walk_state->arg_count);
+			ACPI_DEBUG_PRINT((ACPI_DB_PARSE,
+					  "Popped scope, Op=%p\n", op));
+		} else if (walk_state->prev_op) {
+
+			/* We were in the middle of an op */
+
+			op = walk_state->prev_op;
+			walk_state->arg_types = walk_state->prev_arg_types;
+		}
+	}
+#endif
+
+	/* Iterative parsing loop, while there is more AML to process: */
+
+	while ((parser_state->aml < parser_state->aml_end) || (op)) {
+		aml_op_start = parser_state->aml;
+		if (!op) {
+			status =
+			    acpi_ps_create_op(walk_state, aml_op_start, &op);
+			if (ACPI_FAILURE(status)) {
+				if (status == AE_CTRL_PARSE_CONTINUE) {
+					continue;
+				}
+
+				if (status == AE_CTRL_PARSE_PENDING) {
+					status = AE_OK;
+				}
+
+				status =
+				    acpi_ps_complete_op(walk_state, &op,
+							status);
+				if (ACPI_FAILURE(status)) {
+					return_ACPI_STATUS(status);
+				}
+
+				continue;
+			}
+
+			op->common.aml_offset = walk_state->aml_offset;
+
+			if (walk_state->op_info) {
+				ACPI_DEBUG_PRINT((ACPI_DB_PARSE,
+						  "Opcode %4.4X [%s] Op %p Aml %p AmlOffset %5.5X\n",
+						  (u32)op->common.aml_opcode,
+						  walk_state->op_info->name, op,
+						  parser_state->aml,
+						  op->common.aml_offset));
+			}
+		}
+
+		/*
+		 * Start arg_count at zero because we don't know if there are
+		 * any args yet
+		 */
+		walk_state->arg_count = 0;
+
+		/* Are there any arguments that must be processed? */
+
+		if (walk_state->arg_types) {
+
+			/* Get arguments */
+
+			status =
+			    acpi_ps_get_arguments(walk_state, aml_op_start, op);
+			if (ACPI_FAILURE(status)) {
+				status =
+				    acpi_ps_complete_op(walk_state, &op,
+							status);
+				if (ACPI_FAILURE(status)) {
+					return_ACPI_STATUS(status);
+				}
+
+				continue;
+			}
+		}
+
+		/* Check for arguments that need to be processed */
+
+		if (walk_state->arg_count) {
+			/*
+			 * There are arguments (complex ones), push Op and
+			 * prepare for argument
+			 */
+			status = acpi_ps_push_scope(parser_state, op,
+						    walk_state->arg_types,
+						    walk_state->arg_count);
+			if (ACPI_FAILURE(status)) {
+				status =
+				    acpi_ps_complete_op(walk_state, &op,
+							status);
+				if (ACPI_FAILURE(status)) {
+					return_ACPI_STATUS(status);
+				}
+
+				continue;
+			}
+
+			op = NULL;
+			continue;
+		}
+
+		/*
+		 * All arguments have been processed -- Op is complete,
+		 * prepare for next
+		 */
+		walk_state->op_info =
+		    acpi_ps_get_opcode_info(op->common.aml_opcode);
+		if (walk_state->op_info->flags & AML_NAMED) {
+			if (acpi_gbl_depth) {
+				acpi_gbl_depth--;
+			}
+
+			if (op->common.aml_opcode == AML_REGION_OP ||
+			    op->common.aml_opcode == AML_DATA_REGION_OP) {
+				/*
+				 * Skip parsing of control method or opregion body,
+				 * because we don't have enough info in the first pass
+				 * to parse them correctly.
+				 *
+				 * Completed parsing an op_region declaration, we now
+				 * know the length.
+				 */
+				op->named.length =
+				    (u32)(parser_state->aml - op->named.data);
+			}
+		}
+
+		if (walk_state->op_info->flags & AML_CREATE) {
+			/*
+			 * Backup to beginning of create_xXXfield declaration (1 for
+			 * Opcode)
+			 *
+			 * body_length is unknown until we parse the body
+			 */
+			op->named.length =
+			    (u32)(parser_state->aml - op->named.data);
+		}
+
+		if (op->common.aml_opcode == AML_BANK_FIELD_OP) {
+			/*
+			 * Backup to beginning of bank_field declaration
+			 *
+			 * body_length is unknown until we parse the body
+			 */
+			op->named.length =
+			    (u32)(parser_state->aml - op->named.data);
+		}
+
+		/* This op complete, notify the dispatcher */
+
+		if (walk_state->ascending_callback != NULL) {
+			walk_state->op = op;
+			walk_state->opcode = op->common.aml_opcode;
+
+			status = walk_state->ascending_callback(walk_state);
+			status =
+			    acpi_ps_next_parse_state(walk_state, op, status);
+			if (status == AE_CTRL_PENDING) {
+				status = AE_OK;
+			}
+		}
+
+		status = acpi_ps_complete_op(walk_state, &op, status);
+		if (ACPI_FAILURE(status)) {
+			return_ACPI_STATUS(status);
+		}
+
+	}			/* while parser_state->Aml */
+
+	status = acpi_ps_complete_final_op(walk_state, op, status);
+	return_ACPI_STATUS(status);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/psopcode.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/psopcode.c
new file mode 100644
index 00000000..f639305c
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/psopcode.c
@@ -0,0 +1,824 @@
+/******************************************************************************
+ *
+ * Module Name: psopcode - Parser/Interpreter opcode information table
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acparser.h"
+#include "acopcode.h"
+#include "amlcode.h"
+
+#define _COMPONENT          ACPI_PARSER
+ACPI_MODULE_NAME("psopcode")
+
+static const u8 acpi_gbl_argument_count[] =
+    { 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 6 };
+
+/*******************************************************************************
+ *
+ * NAME:        acpi_gbl_aml_op_info
+ *
+ * DESCRIPTION: Opcode table. Each entry contains <opcode, type, name, operands>
+ *              The name is a simple ascii string, the operand specifier is an
+ *              ascii string with one letter per operand.  The letter specifies
+ *              the operand type.
+ *
+ ******************************************************************************/
+
+/*
+ * Summary of opcode types/flags
+ *
+
+ Opcodes that have associated namespace objects (AML_NSOBJECT flag)
+
+	AML_SCOPE_OP
+	AML_DEVICE_OP
+	AML_THERMAL_ZONE_OP
+	AML_METHOD_OP
+	AML_POWER_RES_OP
+	AML_PROCESSOR_OP
+	AML_FIELD_OP
+	AML_INDEX_FIELD_OP
+	AML_BANK_FIELD_OP
+	AML_NAME_OP
+	AML_ALIAS_OP
+	AML_MUTEX_OP
+	AML_EVENT_OP
+	AML_REGION_OP
+	AML_CREATE_FIELD_OP
+	AML_CREATE_BIT_FIELD_OP
+	AML_CREATE_BYTE_FIELD_OP
+	AML_CREATE_WORD_FIELD_OP
+	AML_CREATE_DWORD_FIELD_OP
+	AML_CREATE_QWORD_FIELD_OP
+	AML_INT_NAMEDFIELD_OP
+	AML_INT_METHODCALL_OP
+	AML_INT_NAMEPATH_OP
+
+  Opcodes that are "namespace" opcodes (AML_NSOPCODE flag)
+
+	AML_SCOPE_OP
+	AML_DEVICE_OP
+	AML_THERMAL_ZONE_OP
+	AML_METHOD_OP
+	AML_POWER_RES_OP
+	AML_PROCESSOR_OP
+	AML_FIELD_OP
+	AML_INDEX_FIELD_OP
+	AML_BANK_FIELD_OP
+	AML_NAME_OP
+	AML_ALIAS_OP
+	AML_MUTEX_OP
+	AML_EVENT_OP
+	AML_REGION_OP
+	AML_INT_NAMEDFIELD_OP
+
+  Opcodes that have an associated namespace node (AML_NSNODE flag)
+
+	AML_SCOPE_OP
+	AML_DEVICE_OP
+	AML_THERMAL_ZONE_OP
+	AML_METHOD_OP
+	AML_POWER_RES_OP
+	AML_PROCESSOR_OP
+	AML_NAME_OP
+	AML_ALIAS_OP
+	AML_MUTEX_OP
+	AML_EVENT_OP
+	AML_REGION_OP
+	AML_CREATE_FIELD_OP
+	AML_CREATE_BIT_FIELD_OP
+	AML_CREATE_BYTE_FIELD_OP
+	AML_CREATE_WORD_FIELD_OP
+	AML_CREATE_DWORD_FIELD_OP
+	AML_CREATE_QWORD_FIELD_OP
+	AML_INT_NAMEDFIELD_OP
+	AML_INT_METHODCALL_OP
+	AML_INT_NAMEPATH_OP
+
+  Opcodes that define named ACPI objects (AML_NAMED flag)
+
+	AML_SCOPE_OP
+	AML_DEVICE_OP
+	AML_THERMAL_ZONE_OP
+	AML_METHOD_OP
+	AML_POWER_RES_OP
+	AML_PROCESSOR_OP
+	AML_NAME_OP
+	AML_ALIAS_OP
+	AML_MUTEX_OP
+	AML_EVENT_OP
+	AML_REGION_OP
+	AML_INT_NAMEDFIELD_OP
+
+  Opcodes that contain executable AML as part of the definition that
+  must be deferred until needed
+
+	AML_METHOD_OP
+	AML_VAR_PACKAGE_OP
+	AML_CREATE_FIELD_OP
+	AML_CREATE_BIT_FIELD_OP
+	AML_CREATE_BYTE_FIELD_OP
+	AML_CREATE_WORD_FIELD_OP
+	AML_CREATE_DWORD_FIELD_OP
+	AML_CREATE_QWORD_FIELD_OP
+	AML_REGION_OP
+	AML_BUFFER_OP
+
+  Field opcodes
+
+	AML_CREATE_FIELD_OP
+	AML_FIELD_OP
+	AML_INDEX_FIELD_OP
+	AML_BANK_FIELD_OP
+
+  Field "Create" opcodes
+
+	AML_CREATE_FIELD_OP
+	AML_CREATE_BIT_FIELD_OP
+	AML_CREATE_BYTE_FIELD_OP
+	AML_CREATE_WORD_FIELD_OP
+	AML_CREATE_DWORD_FIELD_OP
+	AML_CREATE_QWORD_FIELD_OP
+
+ ******************************************************************************/
+
+/*
+ * Master Opcode information table.  A summary of everything we know about each
+ * opcode, all in one place.
+ */
+const struct acpi_opcode_info acpi_gbl_aml_op_info[AML_NUM_OPCODES] = {
+/*! [Begin] no source code translation */
+/* Index           Name                 Parser Args               Interpreter Args                ObjectType                    Class                      Type                  Flags */
+
+/* 00 */ ACPI_OP("Zero", ARGP_ZERO_OP, ARGI_ZERO_OP, ACPI_TYPE_INTEGER,
+			 AML_CLASS_ARGUMENT, AML_TYPE_CONSTANT, AML_CONSTANT),
+/* 01 */ ACPI_OP("One", ARGP_ONE_OP, ARGI_ONE_OP, ACPI_TYPE_INTEGER,
+			 AML_CLASS_ARGUMENT, AML_TYPE_CONSTANT, AML_CONSTANT),
+/* 02 */ ACPI_OP("Alias", ARGP_ALIAS_OP, ARGI_ALIAS_OP,
+			 ACPI_TYPE_LOCAL_ALIAS, AML_CLASS_NAMED_OBJECT,
+			 AML_TYPE_NAMED_SIMPLE,
+			 AML_HAS_ARGS | AML_NSOBJECT | AML_NSOPCODE |
+			 AML_NSNODE | AML_NAMED),
+/* 03 */ ACPI_OP("Name", ARGP_NAME_OP, ARGI_NAME_OP, ACPI_TYPE_ANY,
+			 AML_CLASS_NAMED_OBJECT, AML_TYPE_NAMED_COMPLEX,
+			 AML_HAS_ARGS | AML_NSOBJECT | AML_NSOPCODE |
+			 AML_NSNODE | AML_NAMED),
+/* 04 */ ACPI_OP("ByteConst", ARGP_BYTE_OP, ARGI_BYTE_OP,
+			 ACPI_TYPE_INTEGER, AML_CLASS_ARGUMENT,
+			 AML_TYPE_LITERAL, AML_CONSTANT),
+/* 05 */ ACPI_OP("WordConst", ARGP_WORD_OP, ARGI_WORD_OP,
+			 ACPI_TYPE_INTEGER, AML_CLASS_ARGUMENT,
+			 AML_TYPE_LITERAL, AML_CONSTANT),
+/* 06 */ ACPI_OP("DwordConst", ARGP_DWORD_OP, ARGI_DWORD_OP,
+			 ACPI_TYPE_INTEGER, AML_CLASS_ARGUMENT,
+			 AML_TYPE_LITERAL, AML_CONSTANT),
+/* 07 */ ACPI_OP("String", ARGP_STRING_OP, ARGI_STRING_OP,
+			 ACPI_TYPE_STRING, AML_CLASS_ARGUMENT,
+			 AML_TYPE_LITERAL, AML_CONSTANT),
+/* 08 */ ACPI_OP("Scope", ARGP_SCOPE_OP, ARGI_SCOPE_OP,
+			 ACPI_TYPE_LOCAL_SCOPE, AML_CLASS_NAMED_OBJECT,
+			 AML_TYPE_NAMED_NO_OBJ,
+			 AML_HAS_ARGS | AML_NSOBJECT | AML_NSOPCODE |
+			 AML_NSNODE | AML_NAMED),
+/* 09 */ ACPI_OP("Buffer", ARGP_BUFFER_OP, ARGI_BUFFER_OP,
+			 ACPI_TYPE_BUFFER, AML_CLASS_CREATE,
+			 AML_TYPE_CREATE_OBJECT,
+			 AML_HAS_ARGS | AML_DEFER | AML_CONSTANT),
+/* 0A */ ACPI_OP("Package", ARGP_PACKAGE_OP, ARGI_PACKAGE_OP,
+			 ACPI_TYPE_PACKAGE, AML_CLASS_CREATE,
+			 AML_TYPE_CREATE_OBJECT,
+			 AML_HAS_ARGS | AML_DEFER | AML_CONSTANT),
+/* 0B */ ACPI_OP("Method", ARGP_METHOD_OP, ARGI_METHOD_OP,
+			 ACPI_TYPE_METHOD, AML_CLASS_NAMED_OBJECT,
+			 AML_TYPE_NAMED_COMPLEX,
+			 AML_HAS_ARGS | AML_NSOBJECT | AML_NSOPCODE |
+			 AML_NSNODE | AML_NAMED | AML_DEFER),
+/* 0C */ ACPI_OP("Local0", ARGP_LOCAL0, ARGI_LOCAL0,
+			 ACPI_TYPE_LOCAL_REFERENCE, AML_CLASS_ARGUMENT,
+			 AML_TYPE_LOCAL_VARIABLE, 0),
+/* 0D */ ACPI_OP("Local1", ARGP_LOCAL1, ARGI_LOCAL1,
+			 ACPI_TYPE_LOCAL_REFERENCE, AML_CLASS_ARGUMENT,
+			 AML_TYPE_LOCAL_VARIABLE, 0),
+/* 0E */ ACPI_OP("Local2", ARGP_LOCAL2, ARGI_LOCAL2,
+			 ACPI_TYPE_LOCAL_REFERENCE, AML_CLASS_ARGUMENT,
+			 AML_TYPE_LOCAL_VARIABLE, 0),
+/* 0F */ ACPI_OP("Local3", ARGP_LOCAL3, ARGI_LOCAL3,
+			 ACPI_TYPE_LOCAL_REFERENCE, AML_CLASS_ARGUMENT,
+			 AML_TYPE_LOCAL_VARIABLE, 0),
+/* 10 */ ACPI_OP("Local4", ARGP_LOCAL4, ARGI_LOCAL4,
+			 ACPI_TYPE_LOCAL_REFERENCE, AML_CLASS_ARGUMENT,
+			 AML_TYPE_LOCAL_VARIABLE, 0),
+/* 11 */ ACPI_OP("Local5", ARGP_LOCAL5, ARGI_LOCAL5,
+			 ACPI_TYPE_LOCAL_REFERENCE, AML_CLASS_ARGUMENT,
+			 AML_TYPE_LOCAL_VARIABLE, 0),
+/* 12 */ ACPI_OP("Local6", ARGP_LOCAL6, ARGI_LOCAL6,
+			 ACPI_TYPE_LOCAL_REFERENCE, AML_CLASS_ARGUMENT,
+			 AML_TYPE_LOCAL_VARIABLE, 0),
+/* 13 */ ACPI_OP("Local7", ARGP_LOCAL7, ARGI_LOCAL7,
+			 ACPI_TYPE_LOCAL_REFERENCE, AML_CLASS_ARGUMENT,
+			 AML_TYPE_LOCAL_VARIABLE, 0),
+/* 14 */ ACPI_OP("Arg0", ARGP_ARG0, ARGI_ARG0,
+			 ACPI_TYPE_LOCAL_REFERENCE, AML_CLASS_ARGUMENT,
+			 AML_TYPE_METHOD_ARGUMENT, 0),
+/* 15 */ ACPI_OP("Arg1", ARGP_ARG1, ARGI_ARG1,
+			 ACPI_TYPE_LOCAL_REFERENCE, AML_CLASS_ARGUMENT,
+			 AML_TYPE_METHOD_ARGUMENT, 0),
+/* 16 */ ACPI_OP("Arg2", ARGP_ARG2, ARGI_ARG2,
+			 ACPI_TYPE_LOCAL_REFERENCE, AML_CLASS_ARGUMENT,
+			 AML_TYPE_METHOD_ARGUMENT, 0),
+/* 17 */ ACPI_OP("Arg3", ARGP_ARG3, ARGI_ARG3,
+			 ACPI_TYPE_LOCAL_REFERENCE, AML_CLASS_ARGUMENT,
+			 AML_TYPE_METHOD_ARGUMENT, 0),
+/* 18 */ ACPI_OP("Arg4", ARGP_ARG4, ARGI_ARG4,
+			 ACPI_TYPE_LOCAL_REFERENCE, AML_CLASS_ARGUMENT,
+			 AML_TYPE_METHOD_ARGUMENT, 0),
+/* 19 */ ACPI_OP("Arg5", ARGP_ARG5, ARGI_ARG5,
+			 ACPI_TYPE_LOCAL_REFERENCE, AML_CLASS_ARGUMENT,
+			 AML_TYPE_METHOD_ARGUMENT, 0),
+/* 1A */ ACPI_OP("Arg6", ARGP_ARG6, ARGI_ARG6,
+			 ACPI_TYPE_LOCAL_REFERENCE, AML_CLASS_ARGUMENT,
+			 AML_TYPE_METHOD_ARGUMENT, 0),
+/* 1B */ ACPI_OP("Store", ARGP_STORE_OP, ARGI_STORE_OP, ACPI_TYPE_ANY,
+			 AML_CLASS_EXECUTE, AML_TYPE_EXEC_1A_1T_1R,
+			 AML_FLAGS_EXEC_1A_1T_1R),
+/* 1C */ ACPI_OP("RefOf", ARGP_REF_OF_OP, ARGI_REF_OF_OP, ACPI_TYPE_ANY,
+			 AML_CLASS_EXECUTE, AML_TYPE_EXEC_1A_0T_1R,
+			 AML_FLAGS_EXEC_1A_0T_1R),
+/* 1D */ ACPI_OP("Add", ARGP_ADD_OP, ARGI_ADD_OP, ACPI_TYPE_ANY,
+			 AML_CLASS_EXECUTE, AML_TYPE_EXEC_2A_1T_1R,
+			 AML_FLAGS_EXEC_2A_1T_1R | AML_MATH | AML_CONSTANT),
+/* 1E */ ACPI_OP("Concatenate", ARGP_CONCAT_OP, ARGI_CONCAT_OP,
+			 ACPI_TYPE_ANY, AML_CLASS_EXECUTE,
+			 AML_TYPE_EXEC_2A_1T_1R,
+			 AML_FLAGS_EXEC_2A_1T_1R | AML_CONSTANT),
+/* 1F */ ACPI_OP("Subtract", ARGP_SUBTRACT_OP, ARGI_SUBTRACT_OP,
+			 ACPI_TYPE_ANY, AML_CLASS_EXECUTE,
+			 AML_TYPE_EXEC_2A_1T_1R,
+			 AML_FLAGS_EXEC_2A_1T_1R | AML_MATH | AML_CONSTANT),
+/* 20 */ ACPI_OP("Increment", ARGP_INCREMENT_OP, ARGI_INCREMENT_OP,
+			 ACPI_TYPE_ANY, AML_CLASS_EXECUTE,
+			 AML_TYPE_EXEC_1A_0T_1R,
+			 AML_FLAGS_EXEC_1A_0T_1R | AML_CONSTANT),
+/* 21 */ ACPI_OP("Decrement", ARGP_DECREMENT_OP, ARGI_DECREMENT_OP,
+			 ACPI_TYPE_ANY, AML_CLASS_EXECUTE,
+			 AML_TYPE_EXEC_1A_0T_1R,
+			 AML_FLAGS_EXEC_1A_0T_1R | AML_CONSTANT),
+/* 22 */ ACPI_OP("Multiply", ARGP_MULTIPLY_OP, ARGI_MULTIPLY_OP,
+			 ACPI_TYPE_ANY, AML_CLASS_EXECUTE,
+			 AML_TYPE_EXEC_2A_1T_1R,
+			 AML_FLAGS_EXEC_2A_1T_1R | AML_MATH | AML_CONSTANT),
+/* 23 */ ACPI_OP("Divide", ARGP_DIVIDE_OP, ARGI_DIVIDE_OP,
+			 ACPI_TYPE_ANY, AML_CLASS_EXECUTE,
+			 AML_TYPE_EXEC_2A_2T_1R,
+			 AML_FLAGS_EXEC_2A_2T_1R | AML_CONSTANT),
+/* 24 */ ACPI_OP("ShiftLeft", ARGP_SHIFT_LEFT_OP, ARGI_SHIFT_LEFT_OP,
+			 ACPI_TYPE_ANY, AML_CLASS_EXECUTE,
+			 AML_TYPE_EXEC_2A_1T_1R,
+			 AML_FLAGS_EXEC_2A_1T_1R | AML_MATH | AML_CONSTANT),
+/* 25 */ ACPI_OP("ShiftRight", ARGP_SHIFT_RIGHT_OP, ARGI_SHIFT_RIGHT_OP,
+			 ACPI_TYPE_ANY, AML_CLASS_EXECUTE,
+			 AML_TYPE_EXEC_2A_1T_1R,
+			 AML_FLAGS_EXEC_2A_1T_1R | AML_MATH | AML_CONSTANT),
+/* 26 */ ACPI_OP("And", ARGP_BIT_AND_OP, ARGI_BIT_AND_OP, ACPI_TYPE_ANY,
+			 AML_CLASS_EXECUTE, AML_TYPE_EXEC_2A_1T_1R,
+			 AML_FLAGS_EXEC_2A_1T_1R | AML_MATH | AML_CONSTANT),
+/* 27 */ ACPI_OP("NAnd", ARGP_BIT_NAND_OP, ARGI_BIT_NAND_OP,
+			 ACPI_TYPE_ANY, AML_CLASS_EXECUTE,
+			 AML_TYPE_EXEC_2A_1T_1R,
+			 AML_FLAGS_EXEC_2A_1T_1R | AML_MATH | AML_CONSTANT),
+/* 28 */ ACPI_OP("Or", ARGP_BIT_OR_OP, ARGI_BIT_OR_OP, ACPI_TYPE_ANY,
+			 AML_CLASS_EXECUTE, AML_TYPE_EXEC_2A_1T_1R,
+			 AML_FLAGS_EXEC_2A_1T_1R | AML_MATH | AML_CONSTANT),
+/* 29 */ ACPI_OP("NOr", ARGP_BIT_NOR_OP, ARGI_BIT_NOR_OP, ACPI_TYPE_ANY,
+			 AML_CLASS_EXECUTE, AML_TYPE_EXEC_2A_1T_1R,
+			 AML_FLAGS_EXEC_2A_1T_1R | AML_MATH | AML_CONSTANT),
+/* 2A */ ACPI_OP("XOr", ARGP_BIT_XOR_OP, ARGI_BIT_XOR_OP, ACPI_TYPE_ANY,
+			 AML_CLASS_EXECUTE, AML_TYPE_EXEC_2A_1T_1R,
+			 AML_FLAGS_EXEC_2A_1T_1R | AML_MATH | AML_CONSTANT),
+/* 2B */ ACPI_OP("Not", ARGP_BIT_NOT_OP, ARGI_BIT_NOT_OP, ACPI_TYPE_ANY,
+			 AML_CLASS_EXECUTE, AML_TYPE_EXEC_1A_1T_1R,
+			 AML_FLAGS_EXEC_1A_1T_1R | AML_CONSTANT),
+/* 2C */ ACPI_OP("FindSetLeftBit", ARGP_FIND_SET_LEFT_BIT_OP,
+			 ARGI_FIND_SET_LEFT_BIT_OP, ACPI_TYPE_ANY,
+			 AML_CLASS_EXECUTE, AML_TYPE_EXEC_1A_1T_1R,
+			 AML_FLAGS_EXEC_1A_1T_1R | AML_CONSTANT),
+/* 2D */ ACPI_OP("FindSetRightBit", ARGP_FIND_SET_RIGHT_BIT_OP,
+			 ARGI_FIND_SET_RIGHT_BIT_OP, ACPI_TYPE_ANY,
+			 AML_CLASS_EXECUTE, AML_TYPE_EXEC_1A_1T_1R,
+			 AML_FLAGS_EXEC_1A_1T_1R | AML_CONSTANT),
+/* 2E */ ACPI_OP("DerefOf", ARGP_DEREF_OF_OP, ARGI_DEREF_OF_OP,
+			 ACPI_TYPE_ANY, AML_CLASS_EXECUTE,
+			 AML_TYPE_EXEC_1A_0T_1R, AML_FLAGS_EXEC_1A_0T_1R),
+/* 2F */ ACPI_OP("Notify", ARGP_NOTIFY_OP, ARGI_NOTIFY_OP,
+			 ACPI_TYPE_ANY, AML_CLASS_EXECUTE,
+			 AML_TYPE_EXEC_2A_0T_0R, AML_FLAGS_EXEC_2A_0T_0R),
+/* 30 */ ACPI_OP("SizeOf", ARGP_SIZE_OF_OP, ARGI_SIZE_OF_OP,
+			 ACPI_TYPE_ANY, AML_CLASS_EXECUTE,
+			 AML_TYPE_EXEC_1A_0T_1R,
+			 AML_FLAGS_EXEC_1A_0T_1R | AML_NO_OPERAND_RESOLVE),
+/* 31 */ ACPI_OP("Index", ARGP_INDEX_OP, ARGI_INDEX_OP, ACPI_TYPE_ANY,
+			 AML_CLASS_EXECUTE, AML_TYPE_EXEC_2A_1T_1R,
+			 AML_FLAGS_EXEC_2A_1T_1R),
+/* 32 */ ACPI_OP("Match", ARGP_MATCH_OP, ARGI_MATCH_OP, ACPI_TYPE_ANY,
+			 AML_CLASS_EXECUTE, AML_TYPE_EXEC_6A_0T_1R,
+			 AML_FLAGS_EXEC_6A_0T_1R | AML_CONSTANT),
+/* 33 */ ACPI_OP("CreateDWordField", ARGP_CREATE_DWORD_FIELD_OP,
+			 ARGI_CREATE_DWORD_FIELD_OP,
+			 ACPI_TYPE_BUFFER_FIELD, AML_CLASS_CREATE,
+			 AML_TYPE_CREATE_FIELD,
+			 AML_HAS_ARGS | AML_NSOBJECT | AML_NSNODE |
+			 AML_DEFER | AML_CREATE),
+/* 34 */ ACPI_OP("CreateWordField", ARGP_CREATE_WORD_FIELD_OP,
+			 ARGI_CREATE_WORD_FIELD_OP,
+			 ACPI_TYPE_BUFFER_FIELD, AML_CLASS_CREATE,
+			 AML_TYPE_CREATE_FIELD,
+			 AML_HAS_ARGS | AML_NSOBJECT | AML_NSNODE |
+			 AML_DEFER | AML_CREATE),
+/* 35 */ ACPI_OP("CreateByteField", ARGP_CREATE_BYTE_FIELD_OP,
+			 ARGI_CREATE_BYTE_FIELD_OP,
+			 ACPI_TYPE_BUFFER_FIELD, AML_CLASS_CREATE,
+			 AML_TYPE_CREATE_FIELD,
+			 AML_HAS_ARGS | AML_NSOBJECT | AML_NSNODE |
+			 AML_DEFER | AML_CREATE),
+/* 36 */ ACPI_OP("CreateBitField", ARGP_CREATE_BIT_FIELD_OP,
+			 ARGI_CREATE_BIT_FIELD_OP,
+			 ACPI_TYPE_BUFFER_FIELD, AML_CLASS_CREATE,
+			 AML_TYPE_CREATE_FIELD,
+			 AML_HAS_ARGS | AML_NSOBJECT | AML_NSNODE |
+			 AML_DEFER | AML_CREATE),
+/* 37 */ ACPI_OP("ObjectType", ARGP_TYPE_OP, ARGI_TYPE_OP,
+			 ACPI_TYPE_ANY, AML_CLASS_EXECUTE,
+			 AML_TYPE_EXEC_1A_0T_1R,
+			 AML_FLAGS_EXEC_1A_0T_1R | AML_NO_OPERAND_RESOLVE),
+/* 38 */ ACPI_OP("LAnd", ARGP_LAND_OP, ARGI_LAND_OP, ACPI_TYPE_ANY,
+			 AML_CLASS_EXECUTE, AML_TYPE_EXEC_2A_0T_1R,
+			 AML_FLAGS_EXEC_2A_0T_1R | AML_LOGICAL_NUMERIC |
+			 AML_CONSTANT),
+/* 39 */ ACPI_OP("LOr", ARGP_LOR_OP, ARGI_LOR_OP, ACPI_TYPE_ANY,
+			 AML_CLASS_EXECUTE, AML_TYPE_EXEC_2A_0T_1R,
+			 AML_FLAGS_EXEC_2A_0T_1R | AML_LOGICAL_NUMERIC |
+			 AML_CONSTANT),
+/* 3A */ ACPI_OP("LNot", ARGP_LNOT_OP, ARGI_LNOT_OP, ACPI_TYPE_ANY,
+			 AML_CLASS_EXECUTE, AML_TYPE_EXEC_1A_0T_1R,
+			 AML_FLAGS_EXEC_1A_0T_1R | AML_CONSTANT),
+/* 3B */ ACPI_OP("LEqual", ARGP_LEQUAL_OP, ARGI_LEQUAL_OP,
+			 ACPI_TYPE_ANY, AML_CLASS_EXECUTE,
+			 AML_TYPE_EXEC_2A_0T_1R,
+			 AML_FLAGS_EXEC_2A_0T_1R | AML_LOGICAL | AML_CONSTANT),
+/* 3C */ ACPI_OP("LGreater", ARGP_LGREATER_OP, ARGI_LGREATER_OP,
+			 ACPI_TYPE_ANY, AML_CLASS_EXECUTE,
+			 AML_TYPE_EXEC_2A_0T_1R,
+			 AML_FLAGS_EXEC_2A_0T_1R | AML_LOGICAL | AML_CONSTANT),
+/* 3D */ ACPI_OP("LLess", ARGP_LLESS_OP, ARGI_LLESS_OP, ACPI_TYPE_ANY,
+			 AML_CLASS_EXECUTE, AML_TYPE_EXEC_2A_0T_1R,
+			 AML_FLAGS_EXEC_2A_0T_1R | AML_LOGICAL | AML_CONSTANT),
+/* 3E */ ACPI_OP("If", ARGP_IF_OP, ARGI_IF_OP, ACPI_TYPE_ANY,
+			 AML_CLASS_CONTROL, AML_TYPE_CONTROL, AML_HAS_ARGS),
+/* 3F */ ACPI_OP("Else", ARGP_ELSE_OP, ARGI_ELSE_OP, ACPI_TYPE_ANY,
+			 AML_CLASS_CONTROL, AML_TYPE_CONTROL, AML_HAS_ARGS),
+/* 40 */ ACPI_OP("While", ARGP_WHILE_OP, ARGI_WHILE_OP, ACPI_TYPE_ANY,
+			 AML_CLASS_CONTROL, AML_TYPE_CONTROL, AML_HAS_ARGS),
+/* 41 */ ACPI_OP("Noop", ARGP_NOOP_OP, ARGI_NOOP_OP, ACPI_TYPE_ANY,
+			 AML_CLASS_CONTROL, AML_TYPE_CONTROL, 0),
+/* 42 */ ACPI_OP("Return", ARGP_RETURN_OP, ARGI_RETURN_OP,
+			 ACPI_TYPE_ANY, AML_CLASS_CONTROL,
+			 AML_TYPE_CONTROL, AML_HAS_ARGS),
+/* 43 */ ACPI_OP("Break", ARGP_BREAK_OP, ARGI_BREAK_OP, ACPI_TYPE_ANY,
+			 AML_CLASS_CONTROL, AML_TYPE_CONTROL, 0),
+/* 44 */ ACPI_OP("BreakPoint", ARGP_BREAK_POINT_OP, ARGI_BREAK_POINT_OP,
+			 ACPI_TYPE_ANY, AML_CLASS_CONTROL, AML_TYPE_CONTROL, 0),
+/* 45 */ ACPI_OP("Ones", ARGP_ONES_OP, ARGI_ONES_OP, ACPI_TYPE_INTEGER,
+			 AML_CLASS_ARGUMENT, AML_TYPE_CONSTANT, AML_CONSTANT),
+
+/* Prefixed opcodes (Two-byte opcodes with a prefix op) */
+
+/* 46 */ ACPI_OP("Mutex", ARGP_MUTEX_OP, ARGI_MUTEX_OP, ACPI_TYPE_MUTEX,
+			 AML_CLASS_NAMED_OBJECT, AML_TYPE_NAMED_SIMPLE,
+			 AML_HAS_ARGS | AML_NSOBJECT | AML_NSOPCODE |
+			 AML_NSNODE | AML_NAMED),
+/* 47 */ ACPI_OP("Event", ARGP_EVENT_OP, ARGI_EVENT_OP, ACPI_TYPE_EVENT,
+			 AML_CLASS_NAMED_OBJECT, AML_TYPE_NAMED_SIMPLE,
+			 AML_NSOBJECT | AML_NSOPCODE | AML_NSNODE | AML_NAMED),
+/* 48 */ ACPI_OP("CondRefOf", ARGP_COND_REF_OF_OP, ARGI_COND_REF_OF_OP,
+			 ACPI_TYPE_ANY, AML_CLASS_EXECUTE,
+			 AML_TYPE_EXEC_1A_1T_1R, AML_FLAGS_EXEC_1A_1T_1R),
+/* 49 */ ACPI_OP("CreateField", ARGP_CREATE_FIELD_OP,
+			 ARGI_CREATE_FIELD_OP, ACPI_TYPE_BUFFER_FIELD,
+			 AML_CLASS_CREATE, AML_TYPE_CREATE_FIELD,
+			 AML_HAS_ARGS | AML_NSOBJECT | AML_NSNODE |
+			 AML_DEFER | AML_FIELD | AML_CREATE),
+/* 4A */ ACPI_OP("Load", ARGP_LOAD_OP, ARGI_LOAD_OP, ACPI_TYPE_ANY,
+			 AML_CLASS_EXECUTE, AML_TYPE_EXEC_1A_1T_0R,
+			 AML_FLAGS_EXEC_1A_1T_0R),
+/* 4B */ ACPI_OP("Stall", ARGP_STALL_OP, ARGI_STALL_OP, ACPI_TYPE_ANY,
+			 AML_CLASS_EXECUTE, AML_TYPE_EXEC_1A_0T_0R,
+			 AML_FLAGS_EXEC_1A_0T_0R),
+/* 4C */ ACPI_OP("Sleep", ARGP_SLEEP_OP, ARGI_SLEEP_OP, ACPI_TYPE_ANY,
+			 AML_CLASS_EXECUTE, AML_TYPE_EXEC_1A_0T_0R,
+			 AML_FLAGS_EXEC_1A_0T_0R),
+/* 4D */ ACPI_OP("Acquire", ARGP_ACQUIRE_OP, ARGI_ACQUIRE_OP,
+			 ACPI_TYPE_ANY, AML_CLASS_EXECUTE,
+			 AML_TYPE_EXEC_2A_0T_1R, AML_FLAGS_EXEC_2A_0T_1R),
+/* 4E */ ACPI_OP("Signal", ARGP_SIGNAL_OP, ARGI_SIGNAL_OP,
+			 ACPI_TYPE_ANY, AML_CLASS_EXECUTE,
+			 AML_TYPE_EXEC_1A_0T_0R, AML_FLAGS_EXEC_1A_0T_0R),
+/* 4F */ ACPI_OP("Wait", ARGP_WAIT_OP, ARGI_WAIT_OP, ACPI_TYPE_ANY,
+			 AML_CLASS_EXECUTE, AML_TYPE_EXEC_2A_0T_1R,
+			 AML_FLAGS_EXEC_2A_0T_1R),
+/* 50 */ ACPI_OP("Reset", ARGP_RESET_OP, ARGI_RESET_OP, ACPI_TYPE_ANY,
+			 AML_CLASS_EXECUTE, AML_TYPE_EXEC_1A_0T_0R,
+			 AML_FLAGS_EXEC_1A_0T_0R),
+/* 51 */ ACPI_OP("Release", ARGP_RELEASE_OP, ARGI_RELEASE_OP,
+			 ACPI_TYPE_ANY, AML_CLASS_EXECUTE,
+			 AML_TYPE_EXEC_1A_0T_0R, AML_FLAGS_EXEC_1A_0T_0R),
+/* 52 */ ACPI_OP("FromBCD", ARGP_FROM_BCD_OP, ARGI_FROM_BCD_OP,
+			 ACPI_TYPE_ANY, AML_CLASS_EXECUTE,
+			 AML_TYPE_EXEC_1A_1T_1R,
+			 AML_FLAGS_EXEC_1A_1T_1R | AML_CONSTANT),
+/* 53 */ ACPI_OP("ToBCD", ARGP_TO_BCD_OP, ARGI_TO_BCD_OP, ACPI_TYPE_ANY,
+			 AML_CLASS_EXECUTE, AML_TYPE_EXEC_1A_1T_1R,
+			 AML_FLAGS_EXEC_1A_1T_1R | AML_CONSTANT),
+/* 54 */ ACPI_OP("Unload", ARGP_UNLOAD_OP, ARGI_UNLOAD_OP,
+			 ACPI_TYPE_ANY, AML_CLASS_EXECUTE,
+			 AML_TYPE_EXEC_1A_0T_0R, AML_FLAGS_EXEC_1A_0T_0R),
+/* 55 */ ACPI_OP("Revision", ARGP_REVISION_OP, ARGI_REVISION_OP,
+			 ACPI_TYPE_INTEGER, AML_CLASS_ARGUMENT,
+			 AML_TYPE_CONSTANT, 0),
+/* 56 */ ACPI_OP("Debug", ARGP_DEBUG_OP, ARGI_DEBUG_OP,
+			 ACPI_TYPE_LOCAL_REFERENCE, AML_CLASS_ARGUMENT,
+			 AML_TYPE_CONSTANT, 0),
+/* 57 */ ACPI_OP("Fatal", ARGP_FATAL_OP, ARGI_FATAL_OP, ACPI_TYPE_ANY,
+			 AML_CLASS_EXECUTE, AML_TYPE_EXEC_3A_0T_0R,
+			 AML_FLAGS_EXEC_3A_0T_0R),
+/* 58 */ ACPI_OP("OperationRegion", ARGP_REGION_OP, ARGI_REGION_OP,
+			 ACPI_TYPE_REGION, AML_CLASS_NAMED_OBJECT,
+			 AML_TYPE_NAMED_COMPLEX,
+			 AML_HAS_ARGS | AML_NSOBJECT | AML_NSOPCODE |
+			 AML_NSNODE | AML_NAMED | AML_DEFER),
+/* 59 */ ACPI_OP("Field", ARGP_FIELD_OP, ARGI_FIELD_OP, ACPI_TYPE_ANY,
+			 AML_CLASS_NAMED_OBJECT, AML_TYPE_NAMED_FIELD,
+			 AML_HAS_ARGS | AML_NSOBJECT | AML_NSOPCODE |
+			 AML_FIELD),
+/* 5A */ ACPI_OP("Device", ARGP_DEVICE_OP, ARGI_DEVICE_OP,
+			 ACPI_TYPE_DEVICE, AML_CLASS_NAMED_OBJECT,
+			 AML_TYPE_NAMED_NO_OBJ,
+			 AML_HAS_ARGS | AML_NSOBJECT | AML_NSOPCODE |
+			 AML_NSNODE | AML_NAMED),
+/* 5B */ ACPI_OP("Processor", ARGP_PROCESSOR_OP, ARGI_PROCESSOR_OP,
+			 ACPI_TYPE_PROCESSOR, AML_CLASS_NAMED_OBJECT,
+			 AML_TYPE_NAMED_SIMPLE,
+			 AML_HAS_ARGS | AML_NSOBJECT | AML_NSOPCODE |
+			 AML_NSNODE | AML_NAMED),
+/* 5C */ ACPI_OP("PowerResource", ARGP_POWER_RES_OP, ARGI_POWER_RES_OP,
+			 ACPI_TYPE_POWER, AML_CLASS_NAMED_OBJECT,
+			 AML_TYPE_NAMED_SIMPLE,
+			 AML_HAS_ARGS | AML_NSOBJECT | AML_NSOPCODE |
+			 AML_NSNODE | AML_NAMED),
+/* 5D */ ACPI_OP("ThermalZone", ARGP_THERMAL_ZONE_OP,
+			 ARGI_THERMAL_ZONE_OP, ACPI_TYPE_THERMAL,
+			 AML_CLASS_NAMED_OBJECT, AML_TYPE_NAMED_NO_OBJ,
+			 AML_HAS_ARGS | AML_NSOBJECT | AML_NSOPCODE |
+			 AML_NSNODE | AML_NAMED),
+/* 5E */ ACPI_OP("IndexField", ARGP_INDEX_FIELD_OP, ARGI_INDEX_FIELD_OP,
+			 ACPI_TYPE_ANY, AML_CLASS_NAMED_OBJECT,
+			 AML_TYPE_NAMED_FIELD,
+			 AML_HAS_ARGS | AML_NSOBJECT | AML_NSOPCODE |
+			 AML_FIELD),
+/* 5F */ ACPI_OP("BankField", ARGP_BANK_FIELD_OP, ARGI_BANK_FIELD_OP,
+			 ACPI_TYPE_LOCAL_BANK_FIELD,
+			 AML_CLASS_NAMED_OBJECT, AML_TYPE_NAMED_FIELD,
+			 AML_HAS_ARGS | AML_NSOBJECT | AML_NSOPCODE |
+			 AML_FIELD | AML_DEFER),
+
+/* Internal opcodes that map to invalid AML opcodes */
+
+/* 60 */ ACPI_OP("LNotEqual", ARGP_LNOTEQUAL_OP, ARGI_LNOTEQUAL_OP,
+			 ACPI_TYPE_ANY, AML_CLASS_INTERNAL,
+			 AML_TYPE_BOGUS, AML_HAS_ARGS | AML_CONSTANT),
+/* 61 */ ACPI_OP("LLessEqual", ARGP_LLESSEQUAL_OP, ARGI_LLESSEQUAL_OP,
+			 ACPI_TYPE_ANY, AML_CLASS_INTERNAL,
+			 AML_TYPE_BOGUS, AML_HAS_ARGS | AML_CONSTANT),
+/* 62 */ ACPI_OP("LGreaterEqual", ARGP_LGREATEREQUAL_OP,
+			 ARGI_LGREATEREQUAL_OP, ACPI_TYPE_ANY,
+			 AML_CLASS_INTERNAL, AML_TYPE_BOGUS,
+			 AML_HAS_ARGS | AML_CONSTANT),
+/* 63 */ ACPI_OP("-NamePath-", ARGP_NAMEPATH_OP, ARGI_NAMEPATH_OP,
+			 ACPI_TYPE_LOCAL_REFERENCE, AML_CLASS_ARGUMENT,
+			 AML_TYPE_LITERAL, AML_NSOBJECT | AML_NSNODE),
+/* 64 */ ACPI_OP("-MethodCall-", ARGP_METHODCALL_OP, ARGI_METHODCALL_OP,
+			 ACPI_TYPE_METHOD, AML_CLASS_METHOD_CALL,
+			 AML_TYPE_METHOD_CALL,
+			 AML_HAS_ARGS | AML_NSOBJECT | AML_NSNODE),
+/* 65 */ ACPI_OP("-ByteList-", ARGP_BYTELIST_OP, ARGI_BYTELIST_OP,
+			 ACPI_TYPE_ANY, AML_CLASS_ARGUMENT,
+			 AML_TYPE_LITERAL, 0),
+/* 66 */ ACPI_OP("-ReservedField-", ARGP_RESERVEDFIELD_OP,
+			 ARGI_RESERVEDFIELD_OP, ACPI_TYPE_ANY,
+			 AML_CLASS_INTERNAL, AML_TYPE_BOGUS, 0),
+/* 67 */ ACPI_OP("-NamedField-", ARGP_NAMEDFIELD_OP, ARGI_NAMEDFIELD_OP,
+			 ACPI_TYPE_ANY, AML_CLASS_INTERNAL,
+			 AML_TYPE_BOGUS,
+			 AML_NSOBJECT | AML_NSOPCODE | AML_NSNODE | AML_NAMED),
+/* 68 */ ACPI_OP("-AccessField-", ARGP_ACCESSFIELD_OP,
+			 ARGI_ACCESSFIELD_OP, ACPI_TYPE_ANY,
+			 AML_CLASS_INTERNAL, AML_TYPE_BOGUS, 0),
+/* 69 */ ACPI_OP("-StaticString", ARGP_STATICSTRING_OP,
+			 ARGI_STATICSTRING_OP, ACPI_TYPE_ANY,
+			 AML_CLASS_INTERNAL, AML_TYPE_BOGUS, 0),
+/* 6A */ ACPI_OP("-Return Value-", ARG_NONE, ARG_NONE, ACPI_TYPE_ANY,
+			 AML_CLASS_RETURN_VALUE, AML_TYPE_RETURN,
+			 AML_HAS_ARGS | AML_HAS_RETVAL),
+/* 6B */ ACPI_OP("-UNKNOWN_OP-", ARG_NONE, ARG_NONE, ACPI_TYPE_INVALID,
+			 AML_CLASS_UNKNOWN, AML_TYPE_BOGUS, AML_HAS_ARGS),
+/* 6C */ ACPI_OP("-ASCII_ONLY-", ARG_NONE, ARG_NONE, ACPI_TYPE_ANY,
+			 AML_CLASS_ASCII, AML_TYPE_BOGUS, AML_HAS_ARGS),
+/* 6D */ ACPI_OP("-PREFIX_ONLY-", ARG_NONE, ARG_NONE, ACPI_TYPE_ANY,
+			 AML_CLASS_PREFIX, AML_TYPE_BOGUS, AML_HAS_ARGS),
+
+/* ACPI 2.0 opcodes */
+
+/* 6E */ ACPI_OP("QwordConst", ARGP_QWORD_OP, ARGI_QWORD_OP,
+			 ACPI_TYPE_INTEGER, AML_CLASS_ARGUMENT,
+			 AML_TYPE_LITERAL, AML_CONSTANT),
+	/* 6F */ ACPI_OP("Package", /* Var */ ARGP_VAR_PACKAGE_OP,
+			 ARGI_VAR_PACKAGE_OP, ACPI_TYPE_PACKAGE,
+			 AML_CLASS_CREATE, AML_TYPE_CREATE_OBJECT,
+			 AML_HAS_ARGS | AML_DEFER),
+/* 70 */ ACPI_OP("ConcatenateResTemplate", ARGP_CONCAT_RES_OP,
+			 ARGI_CONCAT_RES_OP, ACPI_TYPE_ANY,
+			 AML_CLASS_EXECUTE, AML_TYPE_EXEC_2A_1T_1R,
+			 AML_FLAGS_EXEC_2A_1T_1R | AML_CONSTANT),
+/* 71 */ ACPI_OP("Mod", ARGP_MOD_OP, ARGI_MOD_OP, ACPI_TYPE_ANY,
+			 AML_CLASS_EXECUTE, AML_TYPE_EXEC_2A_1T_1R,
+			 AML_FLAGS_EXEC_2A_1T_1R | AML_CONSTANT),
+/* 72 */ ACPI_OP("CreateQWordField", ARGP_CREATE_QWORD_FIELD_OP,
+			 ARGI_CREATE_QWORD_FIELD_OP,
+			 ACPI_TYPE_BUFFER_FIELD, AML_CLASS_CREATE,
+			 AML_TYPE_CREATE_FIELD,
+			 AML_HAS_ARGS | AML_NSOBJECT | AML_NSNODE |
+			 AML_DEFER | AML_CREATE),
+/* 73 */ ACPI_OP("ToBuffer", ARGP_TO_BUFFER_OP, ARGI_TO_BUFFER_OP,
+			 ACPI_TYPE_ANY, AML_CLASS_EXECUTE,
+			 AML_TYPE_EXEC_1A_1T_1R,
+			 AML_FLAGS_EXEC_1A_1T_1R | AML_CONSTANT),
+/* 74 */ ACPI_OP("ToDecimalString", ARGP_TO_DEC_STR_OP,
+			 ARGI_TO_DEC_STR_OP, ACPI_TYPE_ANY,
+			 AML_CLASS_EXECUTE, AML_TYPE_EXEC_1A_1T_1R,
+			 AML_FLAGS_EXEC_1A_1T_1R | AML_CONSTANT),
+/* 75 */ ACPI_OP("ToHexString", ARGP_TO_HEX_STR_OP, ARGI_TO_HEX_STR_OP,
+			 ACPI_TYPE_ANY, AML_CLASS_EXECUTE,
+			 AML_TYPE_EXEC_1A_1T_1R,
+			 AML_FLAGS_EXEC_1A_1T_1R | AML_CONSTANT),
+/* 76 */ ACPI_OP("ToInteger", ARGP_TO_INTEGER_OP, ARGI_TO_INTEGER_OP,
+			 ACPI_TYPE_ANY, AML_CLASS_EXECUTE,
+			 AML_TYPE_EXEC_1A_1T_1R,
+			 AML_FLAGS_EXEC_1A_1T_1R | AML_CONSTANT),
+/* 77 */ ACPI_OP("ToString", ARGP_TO_STRING_OP, ARGI_TO_STRING_OP,
+			 ACPI_TYPE_ANY, AML_CLASS_EXECUTE,
+			 AML_TYPE_EXEC_2A_1T_1R,
+			 AML_FLAGS_EXEC_2A_1T_1R | AML_CONSTANT),
+/* 78 */ ACPI_OP("CopyObject", ARGP_COPY_OP, ARGI_COPY_OP,
+			 ACPI_TYPE_ANY, AML_CLASS_EXECUTE,
+			 AML_TYPE_EXEC_1A_1T_1R, AML_FLAGS_EXEC_1A_1T_1R),
+/* 79 */ ACPI_OP("Mid", ARGP_MID_OP, ARGI_MID_OP, ACPI_TYPE_ANY,
+			 AML_CLASS_EXECUTE, AML_TYPE_EXEC_3A_1T_1R,
+			 AML_FLAGS_EXEC_3A_1T_1R | AML_CONSTANT),
+/* 7A */ ACPI_OP("Continue", ARGP_CONTINUE_OP, ARGI_CONTINUE_OP,
+			 ACPI_TYPE_ANY, AML_CLASS_CONTROL, AML_TYPE_CONTROL, 0),
+/* 7B */ ACPI_OP("LoadTable", ARGP_LOAD_TABLE_OP, ARGI_LOAD_TABLE_OP,
+			 ACPI_TYPE_ANY, AML_CLASS_EXECUTE,
+			 AML_TYPE_EXEC_6A_0T_1R, AML_FLAGS_EXEC_6A_0T_1R),
+/* 7C */ ACPI_OP("DataTableRegion", ARGP_DATA_REGION_OP,
+			 ARGI_DATA_REGION_OP, ACPI_TYPE_REGION,
+			 AML_CLASS_NAMED_OBJECT, AML_TYPE_NAMED_COMPLEX,
+			 AML_HAS_ARGS | AML_NSOBJECT | AML_NSOPCODE |
+			 AML_NSNODE | AML_NAMED | AML_DEFER),
+/* 7D */ ACPI_OP("[EvalSubTree]", ARGP_SCOPE_OP, ARGI_SCOPE_OP,
+			 ACPI_TYPE_ANY, AML_CLASS_NAMED_OBJECT,
+			 AML_TYPE_NAMED_NO_OBJ,
+			 AML_HAS_ARGS | AML_NSOBJECT | AML_NSOPCODE |
+			 AML_NSNODE),
+
+/* ACPI 3.0 opcodes */
+
+/* 7E */ ACPI_OP("Timer", ARGP_TIMER_OP, ARGI_TIMER_OP, ACPI_TYPE_ANY,
+			 AML_CLASS_EXECUTE, AML_TYPE_EXEC_0A_0T_1R,
+			 AML_FLAGS_EXEC_0A_0T_1R),
+
+/* ACPI 5.0 opcodes */
+
+/* 7F */ ACPI_OP("-ConnectField-", ARGP_CONNECTFIELD_OP,
+			 ARGI_CONNECTFIELD_OP, ACPI_TYPE_ANY,
+			 AML_CLASS_INTERNAL, AML_TYPE_BOGUS, AML_HAS_ARGS),
+/* 80 */ ACPI_OP("-ExtAccessField-", ARGP_CONNECTFIELD_OP,
+			 ARGI_CONNECTFIELD_OP, ACPI_TYPE_ANY,
+			 AML_CLASS_INTERNAL, AML_TYPE_BOGUS, 0)
+
+/*! [End] no source code translation !*/
+};
+
+/*
+ * This table is directly indexed by the opcodes, and returns an
+ * index into the table above
+ */
+static const u8 acpi_gbl_short_op_index[256] = {
+/*              0     1     2     3     4     5     6     7  */
+/*              8     9     A     B     C     D     E     F  */
+/* 0x00 */ 0x00, 0x01, _UNK, _UNK, _UNK, _UNK, 0x02, _UNK,
+/* 0x08 */ 0x03, _UNK, 0x04, 0x05, 0x06, 0x07, 0x6E, _UNK,
+/* 0x10 */ 0x08, 0x09, 0x0a, 0x6F, 0x0b, _UNK, _UNK, _UNK,
+/* 0x18 */ _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
+/* 0x20 */ _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
+/* 0x28 */ _UNK, _UNK, _UNK, _UNK, _UNK, 0x63, _PFX, _PFX,
+/* 0x30 */ 0x67, 0x66, 0x68, 0x65, 0x69, 0x64, 0x6A, 0x7D,
+/* 0x38 */ 0x7F, 0x80, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
+/* 0x40 */ _UNK, _ASC, _ASC, _ASC, _ASC, _ASC, _ASC, _ASC,
+/* 0x48 */ _ASC, _ASC, _ASC, _ASC, _ASC, _ASC, _ASC, _ASC,
+/* 0x50 */ _ASC, _ASC, _ASC, _ASC, _ASC, _ASC, _ASC, _ASC,
+/* 0x58 */ _ASC, _ASC, _ASC, _UNK, _PFX, _UNK, _PFX, _ASC,
+/* 0x60 */ 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13,
+/* 0x68 */ 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, _UNK,
+/* 0x70 */ 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22,
+/* 0x78 */ 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a,
+/* 0x80 */ 0x2b, 0x2c, 0x2d, 0x2e, 0x70, 0x71, 0x2f, 0x30,
+/* 0x88 */ 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x72,
+/* 0x90 */ 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x73, 0x74,
+/* 0x98 */ 0x75, 0x76, _UNK, _UNK, 0x77, 0x78, 0x79, 0x7A,
+/* 0xA0 */ 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x60, 0x61,
+/* 0xA8 */ 0x62, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
+/* 0xB0 */ _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
+/* 0xB8 */ _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
+/* 0xC0 */ _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
+/* 0xC8 */ _UNK, _UNK, _UNK, _UNK, 0x44, _UNK, _UNK, _UNK,
+/* 0xD0 */ _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
+/* 0xD8 */ _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
+/* 0xE0 */ _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
+/* 0xE8 */ _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
+/* 0xF0 */ _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
+/* 0xF8 */ _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, 0x45,
+};
+
+/*
+ * This table is indexed by the second opcode of the extended opcode
+ * pair.  It returns an index into the opcode table (acpi_gbl_aml_op_info)
+ */
+static const u8 acpi_gbl_long_op_index[NUM_EXTENDED_OPCODE] = {
+/*              0     1     2     3     4     5     6     7  */
+/*              8     9     A     B     C     D     E     F  */
+/* 0x00 */ _UNK, 0x46, 0x47, _UNK, _UNK, _UNK, _UNK, _UNK,
+/* 0x08 */ _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
+/* 0x10 */ _UNK, _UNK, 0x48, 0x49, _UNK, _UNK, _UNK, _UNK,
+/* 0x18 */ _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, 0x7B,
+/* 0x20 */ 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51,
+/* 0x28 */ 0x52, 0x53, 0x54, _UNK, _UNK, _UNK, _UNK, _UNK,
+/* 0x30 */ 0x55, 0x56, 0x57, 0x7e, _UNK, _UNK, _UNK, _UNK,
+/* 0x38 */ _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
+/* 0x40 */ _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
+/* 0x48 */ _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
+/* 0x50 */ _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
+/* 0x58 */ _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
+/* 0x60 */ _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
+/* 0x68 */ _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
+/* 0x70 */ _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
+/* 0x78 */ _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
+/* 0x80 */ 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
+/* 0x88 */ 0x7C,
+};
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ps_get_opcode_info
+ *
+ * PARAMETERS:  Opcode              - The AML opcode
+ *
+ * RETURN:      A pointer to the info about the opcode.
+ *
+ * DESCRIPTION: Find AML opcode description based on the opcode.
+ *              NOTE: This procedure must ALWAYS return a valid pointer!
+ *
+ ******************************************************************************/
+
+const struct acpi_opcode_info *acpi_ps_get_opcode_info(u16 opcode)
+{
+	ACPI_FUNCTION_NAME(ps_get_opcode_info);
+
+	/*
+	 * Detect normal 8-bit opcode or extended 16-bit opcode
+	 */
+	if (!(opcode & 0xFF00)) {
+
+		/* Simple (8-bit) opcode: 0-255, can't index beyond table  */
+
+		return (&acpi_gbl_aml_op_info
+			[acpi_gbl_short_op_index[(u8)opcode]]);
+	}
+
+	if (((opcode & 0xFF00) == AML_EXTENDED_OPCODE) &&
+	    (((u8)opcode) <= MAX_EXTENDED_OPCODE)) {
+
+		/* Valid extended (16-bit) opcode */
+
+		return (&acpi_gbl_aml_op_info
+			[acpi_gbl_long_op_index[(u8)opcode]]);
+	}
+
+	/* Unknown AML opcode */
+
+	ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
+			  "Unknown AML opcode [%4.4X]\n", opcode));
+
+	return (&acpi_gbl_aml_op_info[_UNK]);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ps_get_opcode_name
+ *
+ * PARAMETERS:  Opcode              - The AML opcode
+ *
+ * RETURN:      A pointer to the name of the opcode (ASCII String)
+ *              Note: Never returns NULL.
+ *
+ * DESCRIPTION: Translate an opcode into a human-readable string
+ *
+ ******************************************************************************/
+
+char *acpi_ps_get_opcode_name(u16 opcode)
+{
+#if defined(ACPI_DISASSEMBLER) || defined (ACPI_DEBUG_OUTPUT)
+
+	const struct acpi_opcode_info *op;
+
+	op = acpi_ps_get_opcode_info(opcode);
+
+	/* Always guaranteed to return a valid pointer */
+
+	return (op->name);
+
+#else
+	return ("OpcodeName unavailable");
+
+#endif
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ps_get_argument_count
+ *
+ * PARAMETERS:  op_type             - Type associated with the AML opcode
+ *
+ * RETURN:      Argument count
+ *
+ * DESCRIPTION: Obtain the number of expected arguments for an AML opcode
+ *
+ ******************************************************************************/
+
+u8 acpi_ps_get_argument_count(u32 op_type)
+{
+
+	if (op_type <= AML_TYPE_EXEC_6A_0T_1R) {
+		return (acpi_gbl_argument_count[op_type]);
+	}
+
+	return (0);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/psparse.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/psparse.c
new file mode 100644
index 00000000..18c127c5
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/psparse.c
@@ -0,0 +1,689 @@
+/******************************************************************************
+ *
+ * Module Name: psparse - Parser top level AML parse routines
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+/*
+ * Parse the AML and build an operation tree as most interpreters,
+ * like Perl, do.  Parsing is done by hand rather than with a YACC
+ * generated parser to tightly constrain stack and dynamic memory
+ * usage.  At the same time, parsing is kept flexible and the code
+ * fairly compact by parsing based on a list of AML opcode
+ * templates in aml_op_info[]
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acparser.h"
+#include "acdispat.h"
+#include "amlcode.h"
+#include "acinterp.h"
+
+#define _COMPONENT          ACPI_PARSER
+ACPI_MODULE_NAME("psparse")
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ps_get_opcode_size
+ *
+ * PARAMETERS:  Opcode          - An AML opcode
+ *
+ * RETURN:      Size of the opcode, in bytes (1 or 2)
+ *
+ * DESCRIPTION: Get the size of the current opcode.
+ *
+ ******************************************************************************/
+u32 acpi_ps_get_opcode_size(u32 opcode)
+{
+
+	/* Extended (2-byte) opcode if > 255 */
+
+	if (opcode > 0x00FF) {
+		return (2);
+	}
+
+	/* Otherwise, just a single byte opcode */
+
+	return (1);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ps_peek_opcode
+ *
+ * PARAMETERS:  parser_state        - A parser state object
+ *
+ * RETURN:      Next AML opcode
+ *
+ * DESCRIPTION: Get next AML opcode (without incrementing AML pointer)
+ *
+ ******************************************************************************/
+
+u16 acpi_ps_peek_opcode(struct acpi_parse_state *parser_state)
+{
+	u8 *aml;
+	u16 opcode;
+
+	aml = parser_state->aml;
+	opcode = (u16)ACPI_GET8(aml);
+
+	if (opcode == AML_EXTENDED_OP_PREFIX) {
+
+		/* Extended opcode, get the second opcode byte */
+
+		aml++;
+		opcode = (u16)((opcode << 8) | ACPI_GET8(aml));
+	}
+
+	return (opcode);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ps_complete_this_op
+ *
+ * PARAMETERS:  walk_state      - Current State
+ *              Op              - Op to complete
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Perform any cleanup at the completion of an Op.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ps_complete_this_op(struct acpi_walk_state * walk_state,
+			 union acpi_parse_object * op)
+{
+	union acpi_parse_object *prev;
+	union acpi_parse_object *next;
+	const struct acpi_opcode_info *parent_info;
+	union acpi_parse_object *replacement_op = NULL;
+	acpi_status status = AE_OK;
+
+	ACPI_FUNCTION_TRACE_PTR(ps_complete_this_op, op);
+
+	/* Check for null Op, can happen if AML code is corrupt */
+
+	if (!op) {
+		return_ACPI_STATUS(AE_OK);	/* OK for now */
+	}
+
+	/* Delete this op and the subtree below it if asked to */
+
+	if (((walk_state->parse_flags & ACPI_PARSE_TREE_MASK) !=
+	     ACPI_PARSE_DELETE_TREE)
+	    || (walk_state->op_info->class == AML_CLASS_ARGUMENT)) {
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	/* Make sure that we only delete this subtree */
+
+	if (op->common.parent) {
+		prev = op->common.parent->common.value.arg;
+		if (!prev) {
+
+			/* Nothing more to do */
+
+			goto cleanup;
+		}
+
+		/*
+		 * Check if we need to replace the operator and its subtree
+		 * with a return value op (placeholder op)
+		 */
+		parent_info =
+		    acpi_ps_get_opcode_info(op->common.parent->common.
+					    aml_opcode);
+
+		switch (parent_info->class) {
+		case AML_CLASS_CONTROL:
+			break;
+
+		case AML_CLASS_CREATE:
+
+			/*
+			 * These opcodes contain term_arg operands. The current
+			 * op must be replaced by a placeholder return op
+			 */
+			replacement_op =
+			    acpi_ps_alloc_op(AML_INT_RETURN_VALUE_OP);
+			if (!replacement_op) {
+				status = AE_NO_MEMORY;
+			}
+			break;
+
+		case AML_CLASS_NAMED_OBJECT:
+
+			/*
+			 * These opcodes contain term_arg operands. The current
+			 * op must be replaced by a placeholder return op
+			 */
+			if ((op->common.parent->common.aml_opcode ==
+			     AML_REGION_OP)
+			    || (op->common.parent->common.aml_opcode ==
+				AML_DATA_REGION_OP)
+			    || (op->common.parent->common.aml_opcode ==
+				AML_BUFFER_OP)
+			    || (op->common.parent->common.aml_opcode ==
+				AML_PACKAGE_OP)
+			    || (op->common.parent->common.aml_opcode ==
+				AML_BANK_FIELD_OP)
+			    || (op->common.parent->common.aml_opcode ==
+				AML_VAR_PACKAGE_OP)) {
+				replacement_op =
+				    acpi_ps_alloc_op(AML_INT_RETURN_VALUE_OP);
+				if (!replacement_op) {
+					status = AE_NO_MEMORY;
+				}
+			} else
+			    if ((op->common.parent->common.aml_opcode ==
+				 AML_NAME_OP)
+				&& (walk_state->pass_number <=
+				    ACPI_IMODE_LOAD_PASS2)) {
+				if ((op->common.aml_opcode == AML_BUFFER_OP)
+				    || (op->common.aml_opcode == AML_PACKAGE_OP)
+				    || (op->common.aml_opcode ==
+					AML_VAR_PACKAGE_OP)) {
+					replacement_op =
+					    acpi_ps_alloc_op(op->common.
+							     aml_opcode);
+					if (!replacement_op) {
+						status = AE_NO_MEMORY;
+					} else {
+						replacement_op->named.data =
+						    op->named.data;
+						replacement_op->named.length =
+						    op->named.length;
+					}
+				}
+			}
+			break;
+
+		default:
+
+			replacement_op =
+			    acpi_ps_alloc_op(AML_INT_RETURN_VALUE_OP);
+			if (!replacement_op) {
+				status = AE_NO_MEMORY;
+			}
+		}
+
+		/* We must unlink this op from the parent tree */
+
+		if (prev == op) {
+
+			/* This op is the first in the list */
+
+			if (replacement_op) {
+				replacement_op->common.parent =
+				    op->common.parent;
+				replacement_op->common.value.arg = NULL;
+				replacement_op->common.node = op->common.node;
+				op->common.parent->common.value.arg =
+				    replacement_op;
+				replacement_op->common.next = op->common.next;
+			} else {
+				op->common.parent->common.value.arg =
+				    op->common.next;
+			}
+		}
+
+		/* Search the parent list */
+
+		else
+			while (prev) {
+
+				/* Traverse all siblings in the parent's argument list */
+
+				next = prev->common.next;
+				if (next == op) {
+					if (replacement_op) {
+						replacement_op->common.parent =
+						    op->common.parent;
+						replacement_op->common.value.
+						    arg = NULL;
+						replacement_op->common.node =
+						    op->common.node;
+						prev->common.next =
+						    replacement_op;
+						replacement_op->common.next =
+						    op->common.next;
+						next = NULL;
+					} else {
+						prev->common.next =
+						    op->common.next;
+						next = NULL;
+					}
+				}
+				prev = next;
+			}
+	}
+
+      cleanup:
+
+	/* Now we can actually delete the subtree rooted at Op */
+
+	acpi_ps_delete_parse_tree(op);
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ps_next_parse_state
+ *
+ * PARAMETERS:  walk_state          - Current state
+ *              Op                  - Current parse op
+ *              callback_status     - Status from previous operation
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Update the parser state based upon the return exception from
+ *              the parser callback.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ps_next_parse_state(struct acpi_walk_state *walk_state,
+			 union acpi_parse_object *op,
+			 acpi_status callback_status)
+{
+	struct acpi_parse_state *parser_state = &walk_state->parser_state;
+	acpi_status status = AE_CTRL_PENDING;
+
+	ACPI_FUNCTION_TRACE_PTR(ps_next_parse_state, op);
+
+	switch (callback_status) {
+	case AE_CTRL_TERMINATE:
+		/*
+		 * A control method was terminated via a RETURN statement.
+		 * The walk of this method is complete.
+		 */
+		parser_state->aml = parser_state->aml_end;
+		status = AE_CTRL_TERMINATE;
+		break;
+
+	case AE_CTRL_BREAK:
+
+		parser_state->aml = walk_state->aml_last_while;
+		walk_state->control_state->common.value = FALSE;
+		status = AE_CTRL_BREAK;
+		break;
+
+	case AE_CTRL_CONTINUE:
+
+		parser_state->aml = walk_state->aml_last_while;
+		status = AE_CTRL_CONTINUE;
+		break;
+
+	case AE_CTRL_PENDING:
+
+		parser_state->aml = walk_state->aml_last_while;
+		break;
+
+#if 0
+	case AE_CTRL_SKIP:
+
+		parser_state->aml = parser_state->scope->parse_scope.pkg_end;
+		status = AE_OK;
+		break;
+#endif
+
+	case AE_CTRL_TRUE:
+		/*
+		 * Predicate of an IF was true, and we are at the matching ELSE.
+		 * Just close out this package
+		 */
+		parser_state->aml = acpi_ps_get_next_package_end(parser_state);
+		status = AE_CTRL_PENDING;
+		break;
+
+	case AE_CTRL_FALSE:
+		/*
+		 * Either an IF/WHILE Predicate was false or we encountered a BREAK
+		 * opcode.  In both cases, we do not execute the rest of the
+		 * package;  We simply close out the parent (finishing the walk of
+		 * this branch of the tree) and continue execution at the parent
+		 * level.
+		 */
+		parser_state->aml = parser_state->scope->parse_scope.pkg_end;
+
+		/* In the case of a BREAK, just force a predicate (if any) to FALSE */
+
+		walk_state->control_state->common.value = FALSE;
+		status = AE_CTRL_END;
+		break;
+
+	case AE_CTRL_TRANSFER:
+
+		/* A method call (invocation) -- transfer control */
+
+		status = AE_CTRL_TRANSFER;
+		walk_state->prev_op = op;
+		walk_state->method_call_op = op;
+		walk_state->method_call_node =
+		    (op->common.value.arg)->common.node;
+
+		/* Will return value (if any) be used by the caller? */
+
+		walk_state->return_used =
+		    acpi_ds_is_result_used(op, walk_state);
+		break;
+
+	default:
+
+		status = callback_status;
+		if ((callback_status & AE_CODE_MASK) == AE_CODE_CONTROL) {
+			status = AE_OK;
+		}
+		break;
+	}
+
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ps_parse_aml
+ *
+ * PARAMETERS:  walk_state      - Current state
+ *
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Parse raw AML and return a tree of ops
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ps_parse_aml(struct acpi_walk_state *walk_state)
+{
+	acpi_status status;
+	struct acpi_thread_state *thread;
+	struct acpi_thread_state *prev_walk_list = acpi_gbl_current_walk_list;
+	struct acpi_walk_state *previous_walk_state;
+
+	ACPI_FUNCTION_TRACE(ps_parse_aml);
+
+	ACPI_DEBUG_PRINT((ACPI_DB_PARSE,
+			  "Entered with WalkState=%p Aml=%p size=%X\n",
+			  walk_state, walk_state->parser_state.aml,
+			  walk_state->parser_state.aml_size));
+
+	if (!walk_state->parser_state.aml) {
+		return_ACPI_STATUS(AE_NULL_OBJECT);
+	}
+
+	/* Create and initialize a new thread state */
+
+	thread = acpi_ut_create_thread_state();
+	if (!thread) {
+		if (walk_state->method_desc) {
+
+			/* Executing a control method - additional cleanup */
+
+			acpi_ds_terminate_control_method(walk_state->
+							 method_desc,
+							 walk_state);
+		}
+
+		acpi_ds_delete_walk_state(walk_state);
+		return_ACPI_STATUS(AE_NO_MEMORY);
+	}
+
+	walk_state->thread = thread;
+
+	/*
+	 * If executing a method, the starting sync_level is this method's
+	 * sync_level
+	 */
+	if (walk_state->method_desc) {
+		walk_state->thread->current_sync_level =
+		    walk_state->method_desc->method.sync_level;
+	}
+
+	acpi_ds_push_walk_state(walk_state, thread);
+
+	/*
+	 * This global allows the AML debugger to get a handle to the currently
+	 * executing control method.
+	 */
+	acpi_gbl_current_walk_list = thread;
+
+	/*
+	 * Execute the walk loop as long as there is a valid Walk State.  This
+	 * handles nested control method invocations without recursion.
+	 */
+	ACPI_DEBUG_PRINT((ACPI_DB_PARSE, "State=%p\n", walk_state));
+
+	status = AE_OK;
+	while (walk_state) {
+		if (ACPI_SUCCESS(status)) {
+			/*
+			 * The parse_loop executes AML until the method terminates
+			 * or calls another method.
+			 */
+			status = acpi_ps_parse_loop(walk_state);
+		}
+
+		ACPI_DEBUG_PRINT((ACPI_DB_PARSE,
+				  "Completed one call to walk loop, %s State=%p\n",
+				  acpi_format_exception(status), walk_state));
+
+		if (status == AE_CTRL_TRANSFER) {
+			/*
+			 * A method call was detected.
+			 * Transfer control to the called control method
+			 */
+			status =
+			    acpi_ds_call_control_method(thread, walk_state,
+							NULL);
+			if (ACPI_FAILURE(status)) {
+				status =
+				    acpi_ds_method_error(status, walk_state);
+			}
+
+			/*
+			 * If the transfer to the new method method call worked, a new walk
+			 * state was created -- get it
+			 */
+			walk_state = acpi_ds_get_current_walk_state(thread);
+			continue;
+		} else if (status == AE_CTRL_TERMINATE) {
+			status = AE_OK;
+		} else if ((status != AE_OK) && (walk_state->method_desc)) {
+
+			/* Either the method parse or actual execution failed */
+
+			ACPI_ERROR_METHOD("Method parse/execution failed",
+					  walk_state->method_node, NULL,
+					  status);
+
+			/* Check for possible multi-thread reentrancy problem */
+
+			if ((status == AE_ALREADY_EXISTS) &&
+			    (!(walk_state->method_desc->method.
+			       info_flags & ACPI_METHOD_SERIALIZED))) {
+				/*
+				 * Method is not serialized and tried to create an object
+				 * twice. The probable cause is that the method cannot
+				 * handle reentrancy. Mark as "pending serialized" now, and
+				 * then mark "serialized" when the last thread exits.
+				 */
+				walk_state->method_desc->method.info_flags |=
+				    ACPI_METHOD_SERIALIZED_PENDING;
+			}
+		}
+
+		/* We are done with this walk, move on to the parent if any */
+
+		walk_state = acpi_ds_pop_walk_state(thread);
+
+		/* Reset the current scope to the beginning of scope stack */
+
+		acpi_ds_scope_stack_clear(walk_state);
+
+		/*
+		 * If we just returned from the execution of a control method or if we
+		 * encountered an error during the method parse phase, there's lots of
+		 * cleanup to do
+		 */
+		if (((walk_state->parse_flags & ACPI_PARSE_MODE_MASK) ==
+		     ACPI_PARSE_EXECUTE) || (ACPI_FAILURE(status))) {
+			acpi_ds_terminate_control_method(walk_state->
+							 method_desc,
+							 walk_state);
+		}
+
+		/* Delete this walk state and all linked control states */
+
+		acpi_ps_cleanup_scope(&walk_state->parser_state);
+		previous_walk_state = walk_state;
+
+		ACPI_DEBUG_PRINT((ACPI_DB_PARSE,
+				  "ReturnValue=%p, ImplicitValue=%p State=%p\n",
+				  walk_state->return_desc,
+				  walk_state->implicit_return_obj, walk_state));
+
+		/* Check if we have restarted a preempted walk */
+
+		walk_state = acpi_ds_get_current_walk_state(thread);
+		if (walk_state) {
+			if (ACPI_SUCCESS(status)) {
+				/*
+				 * There is another walk state, restart it.
+				 * If the method return value is not used by the parent,
+				 * The object is deleted
+				 */
+				if (!previous_walk_state->return_desc) {
+					/*
+					 * In slack mode execution, if there is no return value
+					 * we should implicitly return zero (0) as a default value.
+					 */
+					if (acpi_gbl_enable_interpreter_slack &&
+					    !previous_walk_state->
+					    implicit_return_obj) {
+						previous_walk_state->
+						    implicit_return_obj =
+						    acpi_ut_create_integer_object
+						    ((u64)0);
+						if (!previous_walk_state->
+						    implicit_return_obj) {
+							return_ACPI_STATUS
+							    (AE_NO_MEMORY);
+						}
+					}
+
+					/* Restart the calling control method */
+
+					status =
+					    acpi_ds_restart_control_method
+					    (walk_state,
+					     previous_walk_state->
+					     implicit_return_obj);
+				} else {
+					/*
+					 * We have a valid return value, delete any implicit
+					 * return value.
+					 */
+					acpi_ds_clear_implicit_return
+					    (previous_walk_state);
+
+					status =
+					    acpi_ds_restart_control_method
+					    (walk_state,
+					     previous_walk_state->return_desc);
+				}
+				if (ACPI_SUCCESS(status)) {
+					walk_state->walk_type |=
+					    ACPI_WALK_METHOD_RESTART;
+				}
+			} else {
+				/* On error, delete any return object or implicit return */
+
+				acpi_ut_remove_reference(previous_walk_state->
+							 return_desc);
+				acpi_ds_clear_implicit_return
+				    (previous_walk_state);
+			}
+		}
+
+		/*
+		 * Just completed a 1st-level method, save the final internal return
+		 * value (if any)
+		 */
+		else if (previous_walk_state->caller_return_desc) {
+			if (previous_walk_state->implicit_return_obj) {
+				*(previous_walk_state->caller_return_desc) =
+				    previous_walk_state->implicit_return_obj;
+			} else {
+				/* NULL if no return value */
+
+				*(previous_walk_state->caller_return_desc) =
+				    previous_walk_state->return_desc;
+			}
+		} else {
+			if (previous_walk_state->return_desc) {
+
+				/* Caller doesn't want it, must delete it */
+
+				acpi_ut_remove_reference(previous_walk_state->
+							 return_desc);
+			}
+			if (previous_walk_state->implicit_return_obj) {
+
+				/* Caller doesn't want it, must delete it */
+
+				acpi_ut_remove_reference(previous_walk_state->
+							 implicit_return_obj);
+			}
+		}
+
+		acpi_ds_delete_walk_state(previous_walk_state);
+	}
+
+	/* Normal exit */
+
+	acpi_ex_release_all_mutexes(thread);
+	acpi_ut_delete_generic_state(ACPI_CAST_PTR
+				     (union acpi_generic_state, thread));
+	acpi_gbl_current_walk_list = prev_walk_list;
+	return_ACPI_STATUS(status);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/psscope.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/psscope.c
new file mode 100644
index 00000000..8a509855
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/psscope.c
@@ -0,0 +1,265 @@
+/******************************************************************************
+ *
+ * Module Name: psscope - Parser scope stack management routines
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acparser.h"
+
+#define _COMPONENT          ACPI_PARSER
+ACPI_MODULE_NAME("psscope")
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ps_get_parent_scope
+ *
+ * PARAMETERS:  parser_state        - Current parser state object
+ *
+ * RETURN:      Pointer to an Op object
+ *
+ * DESCRIPTION: Get parent of current op being parsed
+ *
+ ******************************************************************************/
+union acpi_parse_object *acpi_ps_get_parent_scope(struct acpi_parse_state
+						  *parser_state)
+{
+
+	return (parser_state->scope->parse_scope.op);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ps_has_completed_scope
+ *
+ * PARAMETERS:  parser_state        - Current parser state object
+ *
+ * RETURN:      Boolean, TRUE = scope completed.
+ *
+ * DESCRIPTION: Is parsing of current argument complete?  Determined by
+ *              1) AML pointer is at or beyond the end of the scope
+ *              2) The scope argument count has reached zero.
+ *
+ ******************************************************************************/
+
+u8 acpi_ps_has_completed_scope(struct acpi_parse_state *parser_state)
+{
+
+	return ((u8)
+		((parser_state->aml >= parser_state->scope->parse_scope.arg_end
+		  || !parser_state->scope->parse_scope.arg_count)));
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ps_init_scope
+ *
+ * PARAMETERS:  parser_state        - Current parser state object
+ *              Root                - the Root Node of this new scope
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Allocate and init a new scope object
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ps_init_scope(struct acpi_parse_state *parser_state,
+		   union acpi_parse_object *root_op)
+{
+	union acpi_generic_state *scope;
+
+	ACPI_FUNCTION_TRACE_PTR(ps_init_scope, root_op);
+
+	scope = acpi_ut_create_generic_state();
+	if (!scope) {
+		return_ACPI_STATUS(AE_NO_MEMORY);
+	}
+
+	scope->common.descriptor_type = ACPI_DESC_TYPE_STATE_RPSCOPE;
+	scope->parse_scope.op = root_op;
+	scope->parse_scope.arg_count = ACPI_VAR_ARGS;
+	scope->parse_scope.arg_end = parser_state->aml_end;
+	scope->parse_scope.pkg_end = parser_state->aml_end;
+
+	parser_state->scope = scope;
+	parser_state->start_op = root_op;
+
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ps_push_scope
+ *
+ * PARAMETERS:  parser_state        - Current parser state object
+ *              Op                  - Current op to be pushed
+ *              remaining_args      - List of args remaining
+ *              arg_count           - Fixed or variable number of args
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Push current op to begin parsing its argument
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ps_push_scope(struct acpi_parse_state *parser_state,
+		   union acpi_parse_object *op,
+		   u32 remaining_args, u32 arg_count)
+{
+	union acpi_generic_state *scope;
+
+	ACPI_FUNCTION_TRACE_PTR(ps_push_scope, op);
+
+	scope = acpi_ut_create_generic_state();
+	if (!scope) {
+		return_ACPI_STATUS(AE_NO_MEMORY);
+	}
+
+	scope->common.descriptor_type = ACPI_DESC_TYPE_STATE_PSCOPE;
+	scope->parse_scope.op = op;
+	scope->parse_scope.arg_list = remaining_args;
+	scope->parse_scope.arg_count = arg_count;
+	scope->parse_scope.pkg_end = parser_state->pkg_end;
+
+	/* Push onto scope stack */
+
+	acpi_ut_push_generic_state(&parser_state->scope, scope);
+
+	if (arg_count == ACPI_VAR_ARGS) {
+
+		/* Multiple arguments */
+
+		scope->parse_scope.arg_end = parser_state->pkg_end;
+	} else {
+		/* Single argument */
+
+		scope->parse_scope.arg_end = ACPI_TO_POINTER(ACPI_MAX_PTR);
+	}
+
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ps_pop_scope
+ *
+ * PARAMETERS:  parser_state        - Current parser state object
+ *              Op                  - Where the popped op is returned
+ *              arg_list            - Where the popped "next argument" is
+ *                                    returned
+ *              arg_count           - Count of objects in arg_list
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Return to parsing a previous op
+ *
+ ******************************************************************************/
+
+void
+acpi_ps_pop_scope(struct acpi_parse_state *parser_state,
+		  union acpi_parse_object **op, u32 *arg_list, u32 *arg_count)
+{
+	union acpi_generic_state *scope = parser_state->scope;
+
+	ACPI_FUNCTION_TRACE(ps_pop_scope);
+
+	/* Only pop the scope if there is in fact a next scope */
+
+	if (scope->common.next) {
+		scope = acpi_ut_pop_generic_state(&parser_state->scope);
+
+		/* Return to parsing previous op */
+
+		*op = scope->parse_scope.op;
+		*arg_list = scope->parse_scope.arg_list;
+		*arg_count = scope->parse_scope.arg_count;
+		parser_state->pkg_end = scope->parse_scope.pkg_end;
+
+		/* All done with this scope state structure */
+
+		acpi_ut_delete_generic_state(scope);
+	} else {
+		/* Empty parse stack, prepare to fetch next opcode */
+
+		*op = NULL;
+		*arg_list = 0;
+		*arg_count = 0;
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_PARSE,
+			  "Popped Op %p Args %X\n", *op, *arg_count));
+	return_VOID;
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ps_cleanup_scope
+ *
+ * PARAMETERS:  parser_state        - Current parser state object
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Destroy available list, remaining stack levels, and return
+ *              root scope
+ *
+ ******************************************************************************/
+
+void acpi_ps_cleanup_scope(struct acpi_parse_state *parser_state)
+{
+	union acpi_generic_state *scope;
+
+	ACPI_FUNCTION_TRACE_PTR(ps_cleanup_scope, parser_state);
+
+	if (!parser_state) {
+		return_VOID;
+	}
+
+	/* Delete anything on the scope stack */
+
+	while (parser_state->scope) {
+		scope = acpi_ut_pop_generic_state(&parser_state->scope);
+		acpi_ut_delete_generic_state(scope);
+	}
+
+	return_VOID;
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/pstree.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/pstree.c
new file mode 100644
index 00000000..d165c431
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/pstree.c
@@ -0,0 +1,316 @@
+/******************************************************************************
+ *
+ * Module Name: pstree - Parser op tree manipulation/traversal/search
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acparser.h"
+#include "amlcode.h"
+
+#define _COMPONENT          ACPI_PARSER
+ACPI_MODULE_NAME("pstree")
+
+/* Local prototypes */
+#ifdef ACPI_OBSOLETE_FUNCTIONS
+union acpi_parse_object *acpi_ps_get_child(union acpi_parse_object *op);
+#endif
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ps_get_arg
+ *
+ * PARAMETERS:  Op              - Get an argument for this op
+ *              Argn            - Nth argument to get
+ *
+ * RETURN:      The argument (as an Op object). NULL if argument does not exist
+ *
+ * DESCRIPTION: Get the specified op's argument.
+ *
+ ******************************************************************************/
+
+union acpi_parse_object *acpi_ps_get_arg(union acpi_parse_object *op, u32 argn)
+{
+	union acpi_parse_object *arg = NULL;
+	const struct acpi_opcode_info *op_info;
+
+	ACPI_FUNCTION_ENTRY();
+
+/*
+	if (Op->Common.aml_opcode == AML_INT_CONNECTION_OP)
+	{
+		return (Op->Common.Value.Arg);
+	}
+*/
+	/* Get the info structure for this opcode */
+
+	op_info = acpi_ps_get_opcode_info(op->common.aml_opcode);
+	if (op_info->class == AML_CLASS_UNKNOWN) {
+
+		/* Invalid opcode or ASCII character */
+
+		return (NULL);
+	}
+
+	/* Check if this opcode requires argument sub-objects */
+
+	if (!(op_info->flags & AML_HAS_ARGS)) {
+
+		/* Has no linked argument objects */
+
+		return (NULL);
+	}
+
+	/* Get the requested argument object */
+
+	arg = op->common.value.arg;
+	while (arg && argn) {
+		argn--;
+		arg = arg->common.next;
+	}
+
+	return (arg);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ps_append_arg
+ *
+ * PARAMETERS:  Op              - Append an argument to this Op.
+ *              Arg             - Argument Op to append
+ *
+ * RETURN:      None.
+ *
+ * DESCRIPTION: Append an argument to an op's argument list (a NULL arg is OK)
+ *
+ ******************************************************************************/
+
+void
+acpi_ps_append_arg(union acpi_parse_object *op, union acpi_parse_object *arg)
+{
+	union acpi_parse_object *prev_arg;
+	const struct acpi_opcode_info *op_info;
+
+	ACPI_FUNCTION_ENTRY();
+
+	if (!op) {
+		return;
+	}
+
+	/* Get the info structure for this opcode */
+
+	op_info = acpi_ps_get_opcode_info(op->common.aml_opcode);
+	if (op_info->class == AML_CLASS_UNKNOWN) {
+
+		/* Invalid opcode */
+
+		ACPI_ERROR((AE_INFO, "Invalid AML Opcode: 0x%2.2X",
+			    op->common.aml_opcode));
+		return;
+	}
+
+	/* Check if this opcode requires argument sub-objects */
+
+	if (!(op_info->flags & AML_HAS_ARGS)) {
+
+		/* Has no linked argument objects */
+
+		return;
+	}
+
+	/* Append the argument to the linked argument list */
+
+	if (op->common.value.arg) {
+
+		/* Append to existing argument list */
+
+		prev_arg = op->common.value.arg;
+		while (prev_arg->common.next) {
+			prev_arg = prev_arg->common.next;
+		}
+		prev_arg->common.next = arg;
+	} else {
+		/* No argument list, this will be the first argument */
+
+		op->common.value.arg = arg;
+	}
+
+	/* Set the parent in this arg and any args linked after it */
+
+	while (arg) {
+		arg->common.parent = op;
+		arg = arg->common.next;
+
+		op->common.arg_list_length++;
+	}
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ps_get_depth_next
+ *
+ * PARAMETERS:  Origin          - Root of subtree to search
+ *              Op              - Last (previous) Op that was found
+ *
+ * RETURN:      Next Op found in the search.
+ *
+ * DESCRIPTION: Get next op in tree (walking the tree in depth-first order)
+ *              Return NULL when reaching "origin" or when walking up from root
+ *
+ ******************************************************************************/
+
+union acpi_parse_object *acpi_ps_get_depth_next(union acpi_parse_object *origin,
+						union acpi_parse_object *op)
+{
+	union acpi_parse_object *next = NULL;
+	union acpi_parse_object *parent;
+	union acpi_parse_object *arg;
+
+	ACPI_FUNCTION_ENTRY();
+
+	if (!op) {
+		return (NULL);
+	}
+
+	/* Look for an argument or child */
+
+	next = acpi_ps_get_arg(op, 0);
+	if (next) {
+		return (next);
+	}
+
+	/* Look for a sibling */
+
+	next = op->common.next;
+	if (next) {
+		return (next);
+	}
+
+	/* Look for a sibling of parent */
+
+	parent = op->common.parent;
+
+	while (parent) {
+		arg = acpi_ps_get_arg(parent, 0);
+		while (arg && (arg != origin) && (arg != op)) {
+			arg = arg->common.next;
+		}
+
+		if (arg == origin) {
+
+			/* Reached parent of origin, end search */
+
+			return (NULL);
+		}
+
+		if (parent->common.next) {
+
+			/* Found sibling of parent */
+
+			return (parent->common.next);
+		}
+
+		op = parent;
+		parent = parent->common.parent;
+	}
+
+	return (next);
+}
+
+#ifdef ACPI_OBSOLETE_FUNCTIONS
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ps_get_child
+ *
+ * PARAMETERS:  Op              - Get the child of this Op
+ *
+ * RETURN:      Child Op, Null if none is found.
+ *
+ * DESCRIPTION: Get op's children or NULL if none
+ *
+ ******************************************************************************/
+
+union acpi_parse_object *acpi_ps_get_child(union acpi_parse_object *op)
+{
+	union acpi_parse_object *child = NULL;
+
+	ACPI_FUNCTION_ENTRY();
+
+	switch (op->common.aml_opcode) {
+	case AML_SCOPE_OP:
+	case AML_ELSE_OP:
+	case AML_DEVICE_OP:
+	case AML_THERMAL_ZONE_OP:
+	case AML_INT_METHODCALL_OP:
+
+		child = acpi_ps_get_arg(op, 0);
+		break;
+
+	case AML_BUFFER_OP:
+	case AML_PACKAGE_OP:
+	case AML_METHOD_OP:
+	case AML_IF_OP:
+	case AML_WHILE_OP:
+	case AML_FIELD_OP:
+
+		child = acpi_ps_get_arg(op, 1);
+		break;
+
+	case AML_POWER_RES_OP:
+	case AML_INDEX_FIELD_OP:
+
+		child = acpi_ps_get_arg(op, 2);
+		break;
+
+	case AML_PROCESSOR_OP:
+	case AML_BANK_FIELD_OP:
+
+		child = acpi_ps_get_arg(op, 3);
+		break;
+
+	default:
+		/* All others have no children */
+		break;
+	}
+
+	return (child);
+}
+#endif
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/psutils.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/psutils.c
new file mode 100644
index 00000000..2b7507c9
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/psutils.c
@@ -0,0 +1,242 @@
+/******************************************************************************
+ *
+ * Module Name: psutils - Parser miscellaneous utilities (Parser only)
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acparser.h"
+#include "amlcode.h"
+
+#define _COMPONENT          ACPI_PARSER
+ACPI_MODULE_NAME("psutils")
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ps_create_scope_op
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      A new Scope object, null on failure
+ *
+ * DESCRIPTION: Create a Scope and associated namepath op with the root name
+ *
+ ******************************************************************************/
+union acpi_parse_object *acpi_ps_create_scope_op(void)
+{
+	union acpi_parse_object *scope_op;
+
+	scope_op = acpi_ps_alloc_op(AML_SCOPE_OP);
+	if (!scope_op) {
+		return (NULL);
+	}
+
+	scope_op->named.name = ACPI_ROOT_NAME;
+	return (scope_op);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ps_init_op
+ *
+ * PARAMETERS:  Op              - A newly allocated Op object
+ *              Opcode          - Opcode to store in the Op
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Initialize a parse (Op) object
+ *
+ ******************************************************************************/
+
+void acpi_ps_init_op(union acpi_parse_object *op, u16 opcode)
+{
+	ACPI_FUNCTION_ENTRY();
+
+	op->common.descriptor_type = ACPI_DESC_TYPE_PARSER;
+	op->common.aml_opcode = opcode;
+
+	ACPI_DISASM_ONLY_MEMBERS(ACPI_STRNCPY(op->common.aml_op_name,
+					      (acpi_ps_get_opcode_info
+					       (opcode))->name,
+					      sizeof(op->common.aml_op_name)));
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ps_alloc_op
+ *
+ * PARAMETERS:  Opcode          - Opcode that will be stored in the new Op
+ *
+ * RETURN:      Pointer to the new Op, null on failure
+ *
+ * DESCRIPTION: Allocate an acpi_op, choose op type (and thus size) based on
+ *              opcode.  A cache of opcodes is available for the pure
+ *              GENERIC_OP, since this is by far the most commonly used.
+ *
+ ******************************************************************************/
+
+union acpi_parse_object *acpi_ps_alloc_op(u16 opcode)
+{
+	union acpi_parse_object *op;
+	const struct acpi_opcode_info *op_info;
+	u8 flags = ACPI_PARSEOP_GENERIC;
+
+	ACPI_FUNCTION_ENTRY();
+
+	op_info = acpi_ps_get_opcode_info(opcode);
+
+	/* Determine type of parse_op required */
+
+	if (op_info->flags & AML_DEFER) {
+		flags = ACPI_PARSEOP_DEFERRED;
+	} else if (op_info->flags & AML_NAMED) {
+		flags = ACPI_PARSEOP_NAMED;
+	} else if (opcode == AML_INT_BYTELIST_OP) {
+		flags = ACPI_PARSEOP_BYTELIST;
+	}
+
+	/* Allocate the minimum required size object */
+
+	if (flags == ACPI_PARSEOP_GENERIC) {
+
+		/* The generic op (default) is by far the most common (16 to 1) */
+
+		op = acpi_os_acquire_object(acpi_gbl_ps_node_cache);
+	} else {
+		/* Extended parseop */
+
+		op = acpi_os_acquire_object(acpi_gbl_ps_node_ext_cache);
+	}
+
+	/* Initialize the Op */
+
+	if (op) {
+		acpi_ps_init_op(op, opcode);
+		op->common.flags = flags;
+	}
+
+	return (op);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ps_free_op
+ *
+ * PARAMETERS:  Op              - Op to be freed
+ *
+ * RETURN:      None.
+ *
+ * DESCRIPTION: Free an Op object.  Either put it on the GENERIC_OP cache list
+ *              or actually free it.
+ *
+ ******************************************************************************/
+
+void acpi_ps_free_op(union acpi_parse_object *op)
+{
+	ACPI_FUNCTION_NAME(ps_free_op);
+
+	if (op->common.aml_opcode == AML_INT_RETURN_VALUE_OP) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS, "Free retval op: %p\n",
+				  op));
+	}
+
+	if (op->common.flags & ACPI_PARSEOP_GENERIC) {
+		(void)acpi_os_release_object(acpi_gbl_ps_node_cache, op);
+	} else {
+		(void)acpi_os_release_object(acpi_gbl_ps_node_ext_cache, op);
+	}
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    Utility functions
+ *
+ * DESCRIPTION: Low level character and object functions
+ *
+ ******************************************************************************/
+
+/*
+ * Is "c" a namestring lead character?
+ */
+u8 acpi_ps_is_leading_char(u32 c)
+{
+	return ((u8)(c == '_' || (c >= 'A' && c <= 'Z')));
+}
+
+/*
+ * Is "c" a namestring prefix character?
+ */
+u8 acpi_ps_is_prefix_char(u32 c)
+{
+	return ((u8)(c == '\\' || c == '^'));
+}
+
+/*
+ * Get op's name (4-byte name segment) or 0 if unnamed
+ */
+u32 acpi_ps_get_name(union acpi_parse_object *op)
+{
+
+	/* The "generic" object has no name associated with it */
+
+	if (op->common.flags & ACPI_PARSEOP_GENERIC) {
+		return (0);
+	}
+
+	/* Only the "Extended" parse objects have a name */
+
+	return (op->named.name);
+}
+
+/*
+ * Set op's name
+ */
+void acpi_ps_set_name(union acpi_parse_object *op, u32 name)
+{
+
+	/* The "generic" object has no name associated with it */
+
+	if (op->common.flags & ACPI_PARSEOP_GENERIC) {
+		return;
+	}
+
+	op->named.name = name;
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/pswalk.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/pswalk.c
new file mode 100644
index 00000000..ab96cf47
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/pswalk.c
@@ -0,0 +1,110 @@
+/******************************************************************************
+ *
+ * Module Name: pswalk - Parser routines to walk parsed op tree(s)
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acparser.h"
+
+#define _COMPONENT          ACPI_PARSER
+ACPI_MODULE_NAME("pswalk")
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ps_delete_parse_tree
+ *
+ * PARAMETERS:  subtree_root        - Root of tree (or subtree) to delete
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Delete a portion of or an entire parse tree.
+ *
+ ******************************************************************************/
+void acpi_ps_delete_parse_tree(union acpi_parse_object *subtree_root)
+{
+	union acpi_parse_object *op = subtree_root;
+	union acpi_parse_object *next = NULL;
+	union acpi_parse_object *parent = NULL;
+
+	ACPI_FUNCTION_TRACE_PTR(ps_delete_parse_tree, subtree_root);
+
+	/* Visit all nodes in the subtree */
+
+	while (op) {
+
+		/* Check if we are not ascending */
+
+		if (op != parent) {
+
+			/* Look for an argument or child of the current op */
+
+			next = acpi_ps_get_arg(op, 0);
+			if (next) {
+
+				/* Still going downward in tree (Op is not completed yet) */
+
+				op = next;
+				continue;
+			}
+		}
+
+		/* No more children, this Op is complete. */
+
+		next = op->common.next;
+		parent = op->common.parent;
+
+		acpi_ps_free_op(op);
+
+		/* If we are back to the starting point, the walk is complete. */
+
+		if (op == subtree_root) {
+			return_VOID;
+		}
+		if (next) {
+			op = next;
+		} else {
+			op = parent;
+		}
+	}
+
+	return_VOID;
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/psxface.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/psxface.c
new file mode 100644
index 00000000..76c58891
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/psxface.c
@@ -0,0 +1,392 @@
+/******************************************************************************
+ *
+ * Module Name: psxface - Parser external interfaces
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acparser.h"
+#include "acdispat.h"
+#include "acinterp.h"
+#include "actables.h"
+
+#define _COMPONENT          ACPI_PARSER
+ACPI_MODULE_NAME("psxface")
+
+/* Local Prototypes */
+static void acpi_ps_start_trace(struct acpi_evaluate_info *info);
+
+static void acpi_ps_stop_trace(struct acpi_evaluate_info *info);
+
+static void
+acpi_ps_update_parameter_list(struct acpi_evaluate_info *info, u16 action);
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_debug_trace
+ *
+ * PARAMETERS:  method_name     - Valid ACPI name string
+ *              debug_level     - Optional level mask. 0 to use default
+ *              debug_layer     - Optional layer mask. 0 to use default
+ *              Flags           - bit 1: one shot(1) or persistent(0)
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: External interface to enable debug tracing during control
+ *              method execution
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_debug_trace(char *name, u32 debug_level, u32 debug_layer, u32 flags)
+{
+	acpi_status status;
+
+	status = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);
+	if (ACPI_FAILURE(status)) {
+		return (status);
+	}
+
+	/* TBDs: Validate name, allow full path or just nameseg */
+
+	acpi_gbl_trace_method_name = *ACPI_CAST_PTR(u32, name);
+	acpi_gbl_trace_flags = flags;
+
+	if (debug_level) {
+		acpi_gbl_trace_dbg_level = debug_level;
+	}
+	if (debug_layer) {
+		acpi_gbl_trace_dbg_layer = debug_layer;
+	}
+
+	(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);
+	return (AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ps_start_trace
+ *
+ * PARAMETERS:  Info        - Method info struct
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Start control method execution trace
+ *
+ ******************************************************************************/
+
+static void acpi_ps_start_trace(struct acpi_evaluate_info *info)
+{
+	acpi_status status;
+
+	ACPI_FUNCTION_ENTRY();
+
+	status = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);
+	if (ACPI_FAILURE(status)) {
+		return;
+	}
+
+	if ((!acpi_gbl_trace_method_name) ||
+	    (acpi_gbl_trace_method_name != info->resolved_node->name.integer)) {
+		goto exit;
+	}
+
+	acpi_gbl_original_dbg_level = acpi_dbg_level;
+	acpi_gbl_original_dbg_layer = acpi_dbg_layer;
+
+	acpi_dbg_level = 0x00FFFFFF;
+	acpi_dbg_layer = ACPI_UINT32_MAX;
+
+	if (acpi_gbl_trace_dbg_level) {
+		acpi_dbg_level = acpi_gbl_trace_dbg_level;
+	}
+	if (acpi_gbl_trace_dbg_layer) {
+		acpi_dbg_layer = acpi_gbl_trace_dbg_layer;
+	}
+
+      exit:
+	(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ps_stop_trace
+ *
+ * PARAMETERS:  Info        - Method info struct
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Stop control method execution trace
+ *
+ ******************************************************************************/
+
+static void acpi_ps_stop_trace(struct acpi_evaluate_info *info)
+{
+	acpi_status status;
+
+	ACPI_FUNCTION_ENTRY();
+
+	status = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);
+	if (ACPI_FAILURE(status)) {
+		return;
+	}
+
+	if ((!acpi_gbl_trace_method_name) ||
+	    (acpi_gbl_trace_method_name != info->resolved_node->name.integer)) {
+		goto exit;
+	}
+
+	/* Disable further tracing if type is one-shot */
+
+	if (acpi_gbl_trace_flags & 1) {
+		acpi_gbl_trace_method_name = 0;
+		acpi_gbl_trace_dbg_level = 0;
+		acpi_gbl_trace_dbg_layer = 0;
+	}
+
+	acpi_dbg_level = acpi_gbl_original_dbg_level;
+	acpi_dbg_layer = acpi_gbl_original_dbg_layer;
+
+      exit:
+	(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ps_execute_method
+ *
+ * PARAMETERS:  Info            - Method info block, contains:
+ *                  Node            - Method Node to execute
+ *                  obj_desc        - Method object
+ *                  Parameters      - List of parameters to pass to the method,
+ *                                    terminated by NULL. Params itself may be
+ *                                    NULL if no parameters are being passed.
+ *                  return_object   - Where to put method's return value (if
+ *                                    any). If NULL, no value is returned.
+ *                  parameter_type  - Type of Parameter list
+ *                  return_object   - Where to put method's return value (if
+ *                                    any). If NULL, no value is returned.
+ *                  pass_number     - Parse or execute pass
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Execute a control method
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ps_execute_method(struct acpi_evaluate_info *info)
+{
+	acpi_status status;
+	union acpi_parse_object *op;
+	struct acpi_walk_state *walk_state;
+
+	ACPI_FUNCTION_TRACE(ps_execute_method);
+
+	/* Quick validation of DSDT header */
+
+	acpi_tb_check_dsdt_header();
+
+	/* Validate the Info and method Node */
+
+	if (!info || !info->resolved_node) {
+		return_ACPI_STATUS(AE_NULL_ENTRY);
+	}
+
+	/* Init for new method, wait on concurrency semaphore */
+
+	status =
+	    acpi_ds_begin_method_execution(info->resolved_node, info->obj_desc,
+					   NULL);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/*
+	 * The caller "owns" the parameters, so give each one an extra reference
+	 */
+	acpi_ps_update_parameter_list(info, REF_INCREMENT);
+
+	/* Begin tracing if requested */
+
+	acpi_ps_start_trace(info);
+
+	/*
+	 * Execute the method. Performs parse simultaneously
+	 */
+	ACPI_DEBUG_PRINT((ACPI_DB_PARSE,
+			  "**** Begin Method Parse/Execute [%4.4s] **** Node=%p Obj=%p\n",
+			  info->resolved_node->name.ascii, info->resolved_node,
+			  info->obj_desc));
+
+	/* Create and init a Root Node */
+
+	op = acpi_ps_create_scope_op();
+	if (!op) {
+		status = AE_NO_MEMORY;
+		goto cleanup;
+	}
+
+	/* Create and initialize a new walk state */
+
+	info->pass_number = ACPI_IMODE_EXECUTE;
+	walk_state =
+	    acpi_ds_create_walk_state(info->obj_desc->method.owner_id, NULL,
+				      NULL, NULL);
+	if (!walk_state) {
+		status = AE_NO_MEMORY;
+		goto cleanup;
+	}
+
+	status = acpi_ds_init_aml_walk(walk_state, op, info->resolved_node,
+				       info->obj_desc->method.aml_start,
+				       info->obj_desc->method.aml_length, info,
+				       info->pass_number);
+	if (ACPI_FAILURE(status)) {
+		acpi_ds_delete_walk_state(walk_state);
+		goto cleanup;
+	}
+
+	if (info->obj_desc->method.info_flags & ACPI_METHOD_MODULE_LEVEL) {
+		walk_state->parse_flags |= ACPI_PARSE_MODULE_LEVEL;
+	}
+
+	/* Invoke an internal method if necessary */
+
+	if (info->obj_desc->method.info_flags & ACPI_METHOD_INTERNAL_ONLY) {
+		status =
+		    info->obj_desc->method.dispatch.implementation(walk_state);
+		info->return_object = walk_state->return_desc;
+
+		/* Cleanup states */
+
+		acpi_ds_scope_stack_clear(walk_state);
+		acpi_ps_cleanup_scope(&walk_state->parser_state);
+		acpi_ds_terminate_control_method(walk_state->method_desc,
+						 walk_state);
+		acpi_ds_delete_walk_state(walk_state);
+		goto cleanup;
+	}
+
+	/*
+	 * Start method evaluation with an implicit return of zero. This is done
+	 * for Windows compatibility.
+	 */
+	if (acpi_gbl_enable_interpreter_slack) {
+		walk_state->implicit_return_obj =
+		    acpi_ut_create_integer_object((u64)0);
+		if (!walk_state->implicit_return_obj) {
+			status = AE_NO_MEMORY;
+			acpi_ds_delete_walk_state(walk_state);
+			goto cleanup;
+		}
+	}
+
+	/* Parse the AML */
+
+	status = acpi_ps_parse_aml(walk_state);
+
+	/* walk_state was deleted by parse_aml */
+
+      cleanup:
+	acpi_ps_delete_parse_tree(op);
+
+	/* End optional tracing */
+
+	acpi_ps_stop_trace(info);
+
+	/* Take away the extra reference that we gave the parameters above */
+
+	acpi_ps_update_parameter_list(info, REF_DECREMENT);
+
+	/* Exit now if error above */
+
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/*
+	 * If the method has returned an object, signal this to the caller with
+	 * a control exception code
+	 */
+	if (info->return_object) {
+		ACPI_DEBUG_PRINT((ACPI_DB_PARSE, "Method returned ObjDesc=%p\n",
+				  info->return_object));
+		ACPI_DUMP_STACK_ENTRY(info->return_object);
+
+		status = AE_CTRL_RETURN_VALUE;
+	}
+
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ps_update_parameter_list
+ *
+ * PARAMETERS:  Info            - See struct acpi_evaluate_info
+ *                                (Used: parameter_type and Parameters)
+ *              Action          - Add or Remove reference
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Update reference count on all method parameter objects
+ *
+ ******************************************************************************/
+
+static void
+acpi_ps_update_parameter_list(struct acpi_evaluate_info *info, u16 action)
+{
+	u32 i;
+
+	if (info->parameters) {
+
+		/* Update reference count for each parameter */
+
+		for (i = 0; info->parameters[i]; i++) {
+
+			/* Ignore errors, just do them all */
+
+			(void)acpi_ut_update_object_reference(info->
+							      parameters[i],
+							      action);
+		}
+	}
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/rsaddr.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/rsaddr.c
new file mode 100644
index 00000000..a0305652
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/rsaddr.c
@@ -0,0 +1,381 @@
+/*******************************************************************************
+ *
+ * Module Name: rsaddr - Address resource descriptors (16/32/64)
+ *
+ ******************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acresrc.h"
+
+#define _COMPONENT          ACPI_RESOURCES
+ACPI_MODULE_NAME("rsaddr")
+
+/*******************************************************************************
+ *
+ * acpi_rs_convert_address16 - All WORD (16-bit) address resources
+ *
+ ******************************************************************************/
+struct acpi_rsconvert_info acpi_rs_convert_address16[5] = {
+	{ACPI_RSC_INITGET, ACPI_RESOURCE_TYPE_ADDRESS16,
+	 ACPI_RS_SIZE(struct acpi_resource_address16),
+	 ACPI_RSC_TABLE_SIZE(acpi_rs_convert_address16)},
+
+	{ACPI_RSC_INITSET, ACPI_RESOURCE_NAME_ADDRESS16,
+	 sizeof(struct aml_resource_address16),
+	 0},
+
+	/* Resource Type, General Flags, and Type-Specific Flags */
+
+	{ACPI_RSC_ADDRESS, 0, 0, 0},
+
+	/*
+	 * These fields are contiguous in both the source and destination:
+	 * Address Granularity
+	 * Address Range Minimum
+	 * Address Range Maximum
+	 * Address Translation Offset
+	 * Address Length
+	 */
+	{ACPI_RSC_MOVE16, ACPI_RS_OFFSET(data.address16.granularity),
+	 AML_OFFSET(address16.granularity),
+	 5},
+
+	/* Optional resource_source (Index and String) */
+
+	{ACPI_RSC_SOURCE, ACPI_RS_OFFSET(data.address16.resource_source),
+	 0,
+	 sizeof(struct aml_resource_address16)}
+};
+
+/*******************************************************************************
+ *
+ * acpi_rs_convert_address32 - All DWORD (32-bit) address resources
+ *
+ ******************************************************************************/
+
+struct acpi_rsconvert_info acpi_rs_convert_address32[5] = {
+	{ACPI_RSC_INITGET, ACPI_RESOURCE_TYPE_ADDRESS32,
+	 ACPI_RS_SIZE(struct acpi_resource_address32),
+	 ACPI_RSC_TABLE_SIZE(acpi_rs_convert_address32)},
+
+	{ACPI_RSC_INITSET, ACPI_RESOURCE_NAME_ADDRESS32,
+	 sizeof(struct aml_resource_address32),
+	 0},
+
+	/* Resource Type, General Flags, and Type-Specific Flags */
+
+	{ACPI_RSC_ADDRESS, 0, 0, 0},
+
+	/*
+	 * These fields are contiguous in both the source and destination:
+	 * Address Granularity
+	 * Address Range Minimum
+	 * Address Range Maximum
+	 * Address Translation Offset
+	 * Address Length
+	 */
+	{ACPI_RSC_MOVE32, ACPI_RS_OFFSET(data.address32.granularity),
+	 AML_OFFSET(address32.granularity),
+	 5},
+
+	/* Optional resource_source (Index and String) */
+
+	{ACPI_RSC_SOURCE, ACPI_RS_OFFSET(data.address32.resource_source),
+	 0,
+	 sizeof(struct aml_resource_address32)}
+};
+
+/*******************************************************************************
+ *
+ * acpi_rs_convert_address64 - All QWORD (64-bit) address resources
+ *
+ ******************************************************************************/
+
+struct acpi_rsconvert_info acpi_rs_convert_address64[5] = {
+	{ACPI_RSC_INITGET, ACPI_RESOURCE_TYPE_ADDRESS64,
+	 ACPI_RS_SIZE(struct acpi_resource_address64),
+	 ACPI_RSC_TABLE_SIZE(acpi_rs_convert_address64)},
+
+	{ACPI_RSC_INITSET, ACPI_RESOURCE_NAME_ADDRESS64,
+	 sizeof(struct aml_resource_address64),
+	 0},
+
+	/* Resource Type, General Flags, and Type-Specific Flags */
+
+	{ACPI_RSC_ADDRESS, 0, 0, 0},
+
+	/*
+	 * These fields are contiguous in both the source and destination:
+	 * Address Granularity
+	 * Address Range Minimum
+	 * Address Range Maximum
+	 * Address Translation Offset
+	 * Address Length
+	 */
+	{ACPI_RSC_MOVE64, ACPI_RS_OFFSET(data.address64.granularity),
+	 AML_OFFSET(address64.granularity),
+	 5},
+
+	/* Optional resource_source (Index and String) */
+
+	{ACPI_RSC_SOURCE, ACPI_RS_OFFSET(data.address64.resource_source),
+	 0,
+	 sizeof(struct aml_resource_address64)}
+};
+
+/*******************************************************************************
+ *
+ * acpi_rs_convert_ext_address64 - All Extended (64-bit) address resources
+ *
+ ******************************************************************************/
+
+struct acpi_rsconvert_info acpi_rs_convert_ext_address64[5] = {
+	{ACPI_RSC_INITGET, ACPI_RESOURCE_TYPE_EXTENDED_ADDRESS64,
+	 ACPI_RS_SIZE(struct acpi_resource_extended_address64),
+	 ACPI_RSC_TABLE_SIZE(acpi_rs_convert_ext_address64)},
+
+	{ACPI_RSC_INITSET, ACPI_RESOURCE_NAME_EXTENDED_ADDRESS64,
+	 sizeof(struct aml_resource_extended_address64),
+	 0},
+
+	/* Resource Type, General Flags, and Type-Specific Flags */
+
+	{ACPI_RSC_ADDRESS, 0, 0, 0},
+
+	/* Revision ID */
+
+	{ACPI_RSC_MOVE8, ACPI_RS_OFFSET(data.ext_address64.revision_iD),
+	 AML_OFFSET(ext_address64.revision_iD),
+	 1},
+	/*
+	 * These fields are contiguous in both the source and destination:
+	 * Address Granularity
+	 * Address Range Minimum
+	 * Address Range Maximum
+	 * Address Translation Offset
+	 * Address Length
+	 * Type-Specific Attribute
+	 */
+	{ACPI_RSC_MOVE64, ACPI_RS_OFFSET(data.ext_address64.granularity),
+	 AML_OFFSET(ext_address64.granularity),
+	 6}
+};
+
+/*******************************************************************************
+ *
+ * acpi_rs_convert_general_flags - Flags common to all address descriptors
+ *
+ ******************************************************************************/
+
+static struct acpi_rsconvert_info acpi_rs_convert_general_flags[6] = {
+	{ACPI_RSC_FLAGINIT, 0, AML_OFFSET(address.flags),
+	 ACPI_RSC_TABLE_SIZE(acpi_rs_convert_general_flags)},
+
+	/* Resource Type (Memory, Io, bus_number, etc.) */
+
+	{ACPI_RSC_MOVE8, ACPI_RS_OFFSET(data.address.resource_type),
+	 AML_OFFSET(address.resource_type),
+	 1},
+
+	/* General Flags - Consume, Decode, min_fixed, max_fixed */
+
+	{ACPI_RSC_1BITFLAG, ACPI_RS_OFFSET(data.address.producer_consumer),
+	 AML_OFFSET(address.flags),
+	 0},
+
+	{ACPI_RSC_1BITFLAG, ACPI_RS_OFFSET(data.address.decode),
+	 AML_OFFSET(address.flags),
+	 1},
+
+	{ACPI_RSC_1BITFLAG, ACPI_RS_OFFSET(data.address.min_address_fixed),
+	 AML_OFFSET(address.flags),
+	 2},
+
+	{ACPI_RSC_1BITFLAG, ACPI_RS_OFFSET(data.address.max_address_fixed),
+	 AML_OFFSET(address.flags),
+	 3}
+};
+
+/*******************************************************************************
+ *
+ * acpi_rs_convert_mem_flags - Flags common to Memory address descriptors
+ *
+ ******************************************************************************/
+
+static struct acpi_rsconvert_info acpi_rs_convert_mem_flags[5] = {
+	{ACPI_RSC_FLAGINIT, 0, AML_OFFSET(address.specific_flags),
+	 ACPI_RSC_TABLE_SIZE(acpi_rs_convert_mem_flags)},
+
+	/* Memory-specific flags */
+
+	{ACPI_RSC_1BITFLAG, ACPI_RS_OFFSET(data.address.info.mem.write_protect),
+	 AML_OFFSET(address.specific_flags),
+	 0},
+
+	{ACPI_RSC_2BITFLAG, ACPI_RS_OFFSET(data.address.info.mem.caching),
+	 AML_OFFSET(address.specific_flags),
+	 1},
+
+	{ACPI_RSC_2BITFLAG, ACPI_RS_OFFSET(data.address.info.mem.range_type),
+	 AML_OFFSET(address.specific_flags),
+	 3},
+
+	{ACPI_RSC_1BITFLAG, ACPI_RS_OFFSET(data.address.info.mem.translation),
+	 AML_OFFSET(address.specific_flags),
+	 5}
+};
+
+/*******************************************************************************
+ *
+ * acpi_rs_convert_io_flags - Flags common to I/O address descriptors
+ *
+ ******************************************************************************/
+
+static struct acpi_rsconvert_info acpi_rs_convert_io_flags[4] = {
+	{ACPI_RSC_FLAGINIT, 0, AML_OFFSET(address.specific_flags),
+	 ACPI_RSC_TABLE_SIZE(acpi_rs_convert_io_flags)},
+
+	/* I/O-specific flags */
+
+	{ACPI_RSC_2BITFLAG, ACPI_RS_OFFSET(data.address.info.io.range_type),
+	 AML_OFFSET(address.specific_flags),
+	 0},
+
+	{ACPI_RSC_1BITFLAG, ACPI_RS_OFFSET(data.address.info.io.translation),
+	 AML_OFFSET(address.specific_flags),
+	 4},
+
+	{ACPI_RSC_1BITFLAG,
+	 ACPI_RS_OFFSET(data.address.info.io.translation_type),
+	 AML_OFFSET(address.specific_flags),
+	 5}
+};
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_rs_get_address_common
+ *
+ * PARAMETERS:  Resource            - Pointer to the internal resource struct
+ *              Aml                 - Pointer to the AML resource descriptor
+ *
+ * RETURN:      TRUE if the resource_type field is OK, FALSE otherwise
+ *
+ * DESCRIPTION: Convert common flag fields from a raw AML resource descriptor
+ *              to an internal resource descriptor
+ *
+ ******************************************************************************/
+
+u8
+acpi_rs_get_address_common(struct acpi_resource *resource,
+			   union aml_resource *aml)
+{
+	ACPI_FUNCTION_ENTRY();
+
+	/* Validate the Resource Type */
+
+	if ((aml->address.resource_type > 2)
+	    && (aml->address.resource_type < 0xC0)) {
+		return (FALSE);
+	}
+
+	/* Get the Resource Type and General Flags */
+
+	(void)acpi_rs_convert_aml_to_resource(resource, aml,
+					      acpi_rs_convert_general_flags);
+
+	/* Get the Type-Specific Flags (Memory and I/O descriptors only) */
+
+	if (resource->data.address.resource_type == ACPI_MEMORY_RANGE) {
+		(void)acpi_rs_convert_aml_to_resource(resource, aml,
+						      acpi_rs_convert_mem_flags);
+	} else if (resource->data.address.resource_type == ACPI_IO_RANGE) {
+		(void)acpi_rs_convert_aml_to_resource(resource, aml,
+						      acpi_rs_convert_io_flags);
+	} else {
+		/* Generic resource type, just grab the type_specific byte */
+
+		resource->data.address.info.type_specific =
+		    aml->address.specific_flags;
+	}
+
+	return (TRUE);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_rs_set_address_common
+ *
+ * PARAMETERS:  Aml                 - Pointer to the AML resource descriptor
+ *              Resource            - Pointer to the internal resource struct
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Convert common flag fields from a resource descriptor to an
+ *              AML descriptor
+ *
+ ******************************************************************************/
+
+void
+acpi_rs_set_address_common(union aml_resource *aml,
+			   struct acpi_resource *resource)
+{
+	ACPI_FUNCTION_ENTRY();
+
+	/* Set the Resource Type and General Flags */
+
+	(void)acpi_rs_convert_resource_to_aml(resource, aml,
+					      acpi_rs_convert_general_flags);
+
+	/* Set the Type-Specific Flags (Memory and I/O descriptors only) */
+
+	if (resource->data.address.resource_type == ACPI_MEMORY_RANGE) {
+		(void)acpi_rs_convert_resource_to_aml(resource, aml,
+						      acpi_rs_convert_mem_flags);
+	} else if (resource->data.address.resource_type == ACPI_IO_RANGE) {
+		(void)acpi_rs_convert_resource_to_aml(resource, aml,
+						      acpi_rs_convert_io_flags);
+	} else {
+		/* Generic resource type, just copy the type_specific byte */
+
+		aml->address.specific_flags =
+		    resource->data.address.info.type_specific;
+	}
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/rscalc.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/rscalc.c
new file mode 100644
index 00000000..700b890b
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/rscalc.c
@@ -0,0 +1,693 @@
+/*******************************************************************************
+ *
+ * Module Name: rscalc - Calculate stream and list lengths
+ *
+ ******************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acresrc.h"
+#include "acnamesp.h"
+
+#define _COMPONENT          ACPI_RESOURCES
+ACPI_MODULE_NAME("rscalc")
+
+/* Local prototypes */
+static u8 acpi_rs_count_set_bits(u16 bit_field);
+
+static acpi_rs_length
+acpi_rs_struct_option_length(struct acpi_resource_source *resource_source);
+
+static u32
+acpi_rs_stream_option_length(u32 resource_length, u32 minimum_total_length);
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_rs_count_set_bits
+ *
+ * PARAMETERS:  bit_field       - Field in which to count bits
+ *
+ * RETURN:      Number of bits set within the field
+ *
+ * DESCRIPTION: Count the number of bits set in a resource field. Used for
+ *              (Short descriptor) interrupt and DMA lists.
+ *
+ ******************************************************************************/
+
+static u8 acpi_rs_count_set_bits(u16 bit_field)
+{
+	u8 bits_set;
+
+	ACPI_FUNCTION_ENTRY();
+
+	for (bits_set = 0; bit_field; bits_set++) {
+
+		/* Zero the least significant bit that is set */
+
+		bit_field &= (u16)(bit_field - 1);
+	}
+
+	return (bits_set);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_rs_struct_option_length
+ *
+ * PARAMETERS:  resource_source     - Pointer to optional descriptor field
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Common code to handle optional resource_source_index and
+ *              resource_source fields in some Large descriptors. Used during
+ *              list-to-stream conversion
+ *
+ ******************************************************************************/
+
+static acpi_rs_length
+acpi_rs_struct_option_length(struct acpi_resource_source *resource_source)
+{
+	ACPI_FUNCTION_ENTRY();
+
+	/*
+	 * If the resource_source string is valid, return the size of the string
+	 * (string_length includes the NULL terminator) plus the size of the
+	 * resource_source_index (1).
+	 */
+	if (resource_source->string_ptr) {
+		return ((acpi_rs_length) (resource_source->string_length + 1));
+	}
+
+	return (0);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_rs_stream_option_length
+ *
+ * PARAMETERS:  resource_length     - Length from the resource header
+ *              minimum_total_length - Minimum length of this resource, before
+ *                                    any optional fields. Includes header size
+ *
+ * RETURN:      Length of optional string (0 if no string present)
+ *
+ * DESCRIPTION: Common code to handle optional resource_source_index and
+ *              resource_source fields in some Large descriptors. Used during
+ *              stream-to-list conversion
+ *
+ ******************************************************************************/
+
+static u32
+acpi_rs_stream_option_length(u32 resource_length,
+			     u32 minimum_aml_resource_length)
+{
+	u32 string_length = 0;
+
+	ACPI_FUNCTION_ENTRY();
+
+	/*
+	 * The resource_source_index and resource_source are optional elements of some
+	 * Large-type resource descriptors.
+	 */
+
+	/*
+	 * If the length of the actual resource descriptor is greater than the ACPI
+	 * spec-defined minimum length, it means that a resource_source_index exists
+	 * and is followed by a (required) null terminated string. The string length
+	 * (including the null terminator) is the resource length minus the minimum
+	 * length, minus one byte for the resource_source_index itself.
+	 */
+	if (resource_length > minimum_aml_resource_length) {
+
+		/* Compute the length of the optional string */
+
+		string_length =
+		    resource_length - minimum_aml_resource_length - 1;
+	}
+
+	/*
+	 * Round the length up to a multiple of the native word in order to
+	 * guarantee that the entire resource descriptor is native word aligned
+	 */
+	return ((u32)ACPI_ROUND_UP_TO_NATIVE_WORD(string_length));
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_rs_get_aml_length
+ *
+ * PARAMETERS:  Resource            - Pointer to the resource linked list
+ *              size_needed         - Where the required size is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Takes a linked list of internal resource descriptors and
+ *              calculates the size buffer needed to hold the corresponding
+ *              external resource byte stream.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_rs_get_aml_length(struct acpi_resource *resource, acpi_size * size_needed)
+{
+	acpi_size aml_size_needed = 0;
+	acpi_rs_length total_size;
+
+	ACPI_FUNCTION_TRACE(rs_get_aml_length);
+
+	/* Traverse entire list of internal resource descriptors */
+
+	while (resource) {
+
+		/* Validate the descriptor type */
+
+		if (resource->type > ACPI_RESOURCE_TYPE_MAX) {
+			return_ACPI_STATUS(AE_AML_INVALID_RESOURCE_TYPE);
+		}
+
+		/* Get the base size of the (external stream) resource descriptor */
+
+		total_size = acpi_gbl_aml_resource_sizes[resource->type];
+
+		/*
+		 * Augment the base size for descriptors with optional and/or
+		 * variable-length fields
+		 */
+		switch (resource->type) {
+		case ACPI_RESOURCE_TYPE_IRQ:
+
+			/* Length can be 3 or 2 */
+
+			if (resource->data.irq.descriptor_length == 2) {
+				total_size--;
+			}
+			break;
+
+		case ACPI_RESOURCE_TYPE_START_DEPENDENT:
+
+			/* Length can be 1 or 0 */
+
+			if (resource->data.irq.descriptor_length == 0) {
+				total_size--;
+			}
+			break;
+
+		case ACPI_RESOURCE_TYPE_VENDOR:
+			/*
+			 * Vendor Defined Resource:
+			 * For a Vendor Specific resource, if the Length is between 1 and 7
+			 * it will be created as a Small Resource data type, otherwise it
+			 * is a Large Resource data type.
+			 */
+			if (resource->data.vendor.byte_length > 7) {
+
+				/* Base size of a Large resource descriptor */
+
+				total_size =
+				    sizeof(struct aml_resource_large_header);
+			}
+
+			/* Add the size of the vendor-specific data */
+
+			total_size = (acpi_rs_length)
+			    (total_size + resource->data.vendor.byte_length);
+			break;
+
+		case ACPI_RESOURCE_TYPE_END_TAG:
+			/*
+			 * End Tag:
+			 * We are done -- return the accumulated total size.
+			 */
+			*size_needed = aml_size_needed + total_size;
+
+			/* Normal exit */
+
+			return_ACPI_STATUS(AE_OK);
+
+		case ACPI_RESOURCE_TYPE_ADDRESS16:
+			/*
+			 * 16-Bit Address Resource:
+			 * Add the size of the optional resource_source info
+			 */
+			total_size = (acpi_rs_length)
+			    (total_size +
+			     acpi_rs_struct_option_length(&resource->data.
+							  address16.
+							  resource_source));
+			break;
+
+		case ACPI_RESOURCE_TYPE_ADDRESS32:
+			/*
+			 * 32-Bit Address Resource:
+			 * Add the size of the optional resource_source info
+			 */
+			total_size = (acpi_rs_length)
+			    (total_size +
+			     acpi_rs_struct_option_length(&resource->data.
+							  address32.
+							  resource_source));
+			break;
+
+		case ACPI_RESOURCE_TYPE_ADDRESS64:
+			/*
+			 * 64-Bit Address Resource:
+			 * Add the size of the optional resource_source info
+			 */
+			total_size = (acpi_rs_length)
+			    (total_size +
+			     acpi_rs_struct_option_length(&resource->data.
+							  address64.
+							  resource_source));
+			break;
+
+		case ACPI_RESOURCE_TYPE_EXTENDED_IRQ:
+			/*
+			 * Extended IRQ Resource:
+			 * Add the size of each additional optional interrupt beyond the
+			 * required 1 (4 bytes for each u32 interrupt number)
+			 */
+			total_size = (acpi_rs_length)
+			    (total_size +
+			     ((resource->data.extended_irq.interrupt_count -
+			       1) * 4) +
+			     /* Add the size of the optional resource_source info */
+			     acpi_rs_struct_option_length(&resource->data.
+							  extended_irq.
+							  resource_source));
+			break;
+
+		case ACPI_RESOURCE_TYPE_GPIO:
+
+			total_size =
+			    (acpi_rs_length) (total_size +
+					      (resource->data.gpio.
+					       pin_table_length * 2) +
+					      resource->data.gpio.
+					      resource_source.string_length +
+					      resource->data.gpio.
+					      vendor_length);
+
+			break;
+
+		case ACPI_RESOURCE_TYPE_SERIAL_BUS:
+
+			total_size =
+			    acpi_gbl_aml_resource_serial_bus_sizes[resource->
+								   data.
+								   common_serial_bus.
+								   type];
+
+			total_size = (acpi_rs_length) (total_size +
+						       resource->data.
+						       i2c_serial_bus.
+						       resource_source.
+						       string_length +
+						       resource->data.
+						       i2c_serial_bus.
+						       vendor_length);
+
+			break;
+
+		default:
+			break;
+		}
+
+		/* Update the total */
+
+		aml_size_needed += total_size;
+
+		/* Point to the next object */
+
+		resource =
+		    ACPI_ADD_PTR(struct acpi_resource, resource,
+				 resource->length);
+	}
+
+	/* Did not find an end_tag resource descriptor */
+
+	return_ACPI_STATUS(AE_AML_NO_RESOURCE_END_TAG);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_rs_get_list_length
+ *
+ * PARAMETERS:  aml_buffer          - Pointer to the resource byte stream
+ *              aml_buffer_length   - Size of aml_buffer
+ *              size_needed         - Where the size needed is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Takes an external resource byte stream and calculates the size
+ *              buffer needed to hold the corresponding internal resource
+ *              descriptor linked list.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_rs_get_list_length(u8 *aml_buffer,
+			u32 aml_buffer_length, acpi_size * size_needed)
+{
+	acpi_status status;
+	u8 *end_aml;
+	u8 *buffer;
+	u32 buffer_size;
+	u16 temp16;
+	u16 resource_length;
+	u32 extra_struct_bytes;
+	u8 resource_index;
+	u8 minimum_aml_resource_length;
+	union aml_resource *aml_resource;
+
+	ACPI_FUNCTION_TRACE(rs_get_list_length);
+
+	*size_needed = ACPI_RS_SIZE_MIN;	/* Minimum size is one end_tag */
+	end_aml = aml_buffer + aml_buffer_length;
+
+	/* Walk the list of AML resource descriptors */
+
+	while (aml_buffer < end_aml) {
+
+		/* Validate the Resource Type and Resource Length */
+
+		status = acpi_ut_validate_resource(aml_buffer, &resource_index);
+		if (ACPI_FAILURE(status)) {
+			/*
+			 * Exit on failure. Cannot continue because the descriptor length
+			 * may be bogus also.
+			 */
+			return_ACPI_STATUS(status);
+		}
+
+		aml_resource = (void *)aml_buffer;
+
+		/* Get the resource length and base (minimum) AML size */
+
+		resource_length = acpi_ut_get_resource_length(aml_buffer);
+		minimum_aml_resource_length =
+		    acpi_gbl_resource_aml_sizes[resource_index];
+
+		/*
+		 * Augment the size for descriptors with optional
+		 * and/or variable length fields
+		 */
+		extra_struct_bytes = 0;
+		buffer =
+		    aml_buffer + acpi_ut_get_resource_header_length(aml_buffer);
+
+		switch (acpi_ut_get_resource_type(aml_buffer)) {
+		case ACPI_RESOURCE_NAME_IRQ:
+			/*
+			 * IRQ Resource:
+			 * Get the number of bits set in the 16-bit IRQ mask
+			 */
+			ACPI_MOVE_16_TO_16(&temp16, buffer);
+			extra_struct_bytes = acpi_rs_count_set_bits(temp16);
+			break;
+
+		case ACPI_RESOURCE_NAME_DMA:
+			/*
+			 * DMA Resource:
+			 * Get the number of bits set in the 8-bit DMA mask
+			 */
+			extra_struct_bytes = acpi_rs_count_set_bits(*buffer);
+			break;
+
+		case ACPI_RESOURCE_NAME_VENDOR_SMALL:
+		case ACPI_RESOURCE_NAME_VENDOR_LARGE:
+			/*
+			 * Vendor Resource:
+			 * Get the number of vendor data bytes
+			 */
+			extra_struct_bytes = resource_length;
+			break;
+
+		case ACPI_RESOURCE_NAME_END_TAG:
+			/*
+			 * End Tag: This is the normal exit
+			 */
+			return_ACPI_STATUS(AE_OK);
+
+		case ACPI_RESOURCE_NAME_ADDRESS32:
+		case ACPI_RESOURCE_NAME_ADDRESS16:
+		case ACPI_RESOURCE_NAME_ADDRESS64:
+			/*
+			 * Address Resource:
+			 * Add the size of the optional resource_source
+			 */
+			extra_struct_bytes =
+			    acpi_rs_stream_option_length(resource_length,
+							 minimum_aml_resource_length);
+			break;
+
+		case ACPI_RESOURCE_NAME_EXTENDED_IRQ:
+			/*
+			 * Extended IRQ Resource:
+			 * Using the interrupt_table_length, add 4 bytes for each additional
+			 * interrupt. Note: at least one interrupt is required and is
+			 * included in the minimum descriptor size (reason for the -1)
+			 */
+			extra_struct_bytes = (buffer[1] - 1) * sizeof(u32);
+
+			/* Add the size of the optional resource_source */
+
+			extra_struct_bytes +=
+			    acpi_rs_stream_option_length(resource_length -
+							 extra_struct_bytes,
+							 minimum_aml_resource_length);
+			break;
+
+		case ACPI_RESOURCE_NAME_GPIO:
+
+			/* Vendor data is optional */
+
+			if (aml_resource->gpio.vendor_length) {
+				extra_struct_bytes +=
+				    aml_resource->gpio.vendor_offset -
+				    aml_resource->gpio.pin_table_offset +
+				    aml_resource->gpio.vendor_length;
+			} else {
+				extra_struct_bytes +=
+				    aml_resource->large_header.resource_length +
+				    sizeof(struct aml_resource_large_header) -
+				    aml_resource->gpio.pin_table_offset;
+			}
+			break;
+
+		case ACPI_RESOURCE_NAME_SERIAL_BUS:
+
+			minimum_aml_resource_length =
+			    acpi_gbl_resource_aml_serial_bus_sizes
+			    [aml_resource->common_serial_bus.type];
+			extra_struct_bytes +=
+			    aml_resource->common_serial_bus.resource_length -
+			    minimum_aml_resource_length;
+			break;
+
+		default:
+			break;
+		}
+
+		/*
+		 * Update the required buffer size for the internal descriptor structs
+		 *
+		 * Important: Round the size up for the appropriate alignment. This
+		 * is a requirement on IA64.
+		 */
+		if (acpi_ut_get_resource_type(aml_buffer) ==
+		    ACPI_RESOURCE_NAME_SERIAL_BUS) {
+			buffer_size =
+			    acpi_gbl_resource_struct_serial_bus_sizes
+			    [aml_resource->common_serial_bus.type] +
+			    extra_struct_bytes;
+		} else {
+			buffer_size =
+			    acpi_gbl_resource_struct_sizes[resource_index] +
+			    extra_struct_bytes;
+		}
+		buffer_size = (u32)ACPI_ROUND_UP_TO_NATIVE_WORD(buffer_size);
+
+		*size_needed += buffer_size;
+
+		ACPI_DEBUG_PRINT((ACPI_DB_RESOURCES,
+				  "Type %.2X, AmlLength %.2X InternalLength %.2X\n",
+				  acpi_ut_get_resource_type(aml_buffer),
+				  acpi_ut_get_descriptor_length(aml_buffer),
+				  buffer_size));
+
+		/*
+		 * Point to the next resource within the AML stream using the length
+		 * contained in the resource descriptor header
+		 */
+		aml_buffer += acpi_ut_get_descriptor_length(aml_buffer);
+	}
+
+	/* Did not find an end_tag resource descriptor */
+
+	return_ACPI_STATUS(AE_AML_NO_RESOURCE_END_TAG);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_rs_get_pci_routing_table_length
+ *
+ * PARAMETERS:  package_object          - Pointer to the package object
+ *              buffer_size_needed      - u32 pointer of the size buffer
+ *                                        needed to properly return the
+ *                                        parsed data
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Given a package representing a PCI routing table, this
+ *              calculates the size of the corresponding linked list of
+ *              descriptions.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_rs_get_pci_routing_table_length(union acpi_operand_object *package_object,
+				     acpi_size * buffer_size_needed)
+{
+	u32 number_of_elements;
+	acpi_size temp_size_needed = 0;
+	union acpi_operand_object **top_object_list;
+	u32 index;
+	union acpi_operand_object *package_element;
+	union acpi_operand_object **sub_object_list;
+	u8 name_found;
+	u32 table_index;
+
+	ACPI_FUNCTION_TRACE(rs_get_pci_routing_table_length);
+
+	number_of_elements = package_object->package.count;
+
+	/*
+	 * Calculate the size of the return buffer.
+	 * The base size is the number of elements * the sizes of the
+	 * structures.  Additional space for the strings is added below.
+	 * The minus one is to subtract the size of the u8 Source[1]
+	 * member because it is added below.
+	 *
+	 * But each PRT_ENTRY structure has a pointer to a string and
+	 * the size of that string must be found.
+	 */
+	top_object_list = package_object->package.elements;
+
+	for (index = 0; index < number_of_elements; index++) {
+
+		/* Dereference the sub-package */
+
+		package_element = *top_object_list;
+
+		/* We must have a valid Package object */
+
+		if (!package_element ||
+		    (package_element->common.type != ACPI_TYPE_PACKAGE)) {
+			return_ACPI_STATUS(AE_AML_OPERAND_TYPE);
+		}
+
+		/*
+		 * The sub_object_list will now point to an array of the
+		 * four IRQ elements: Address, Pin, Source and source_index
+		 */
+		sub_object_list = package_element->package.elements;
+
+		/* Scan the irq_table_elements for the Source Name String */
+
+		name_found = FALSE;
+
+		for (table_index = 0; table_index < 4 && !name_found;
+		     table_index++) {
+			if (*sub_object_list &&	/* Null object allowed */
+			    ((ACPI_TYPE_STRING ==
+			      (*sub_object_list)->common.type) ||
+			     ((ACPI_TYPE_LOCAL_REFERENCE ==
+			       (*sub_object_list)->common.type) &&
+			      ((*sub_object_list)->reference.class ==
+			       ACPI_REFCLASS_NAME)))) {
+				name_found = TRUE;
+			} else {
+				/* Look at the next element */
+
+				sub_object_list++;
+			}
+		}
+
+		temp_size_needed += (sizeof(struct acpi_pci_routing_table) - 4);
+
+		/* Was a String type found? */
+
+		if (name_found) {
+			if ((*sub_object_list)->common.type == ACPI_TYPE_STRING) {
+				/*
+				 * The length String.Length field does not include the
+				 * terminating NULL, add 1
+				 */
+				temp_size_needed += ((acpi_size)
+						     (*sub_object_list)->string.
+						     length + 1);
+			} else {
+				temp_size_needed += acpi_ns_get_pathname_length((*sub_object_list)->reference.node);
+			}
+		} else {
+			/*
+			 * If no name was found, then this is a NULL, which is
+			 * translated as a u32 zero.
+			 */
+			temp_size_needed += sizeof(u32);
+		}
+
+		/* Round up the size since each element must be aligned */
+
+		temp_size_needed = ACPI_ROUND_UP_TO_64BIT(temp_size_needed);
+
+		/* Point to the next union acpi_operand_object */
+
+		top_object_list++;
+	}
+
+	/*
+	 * Add an extra element to the end of the list, essentially a
+	 * NULL terminator
+	 */
+	*buffer_size_needed =
+	    temp_size_needed + sizeof(struct acpi_pci_routing_table);
+	return_ACPI_STATUS(AE_OK);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/rscreate.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/rscreate.c
new file mode 100644
index 00000000..f2c6fc68
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/rscreate.c
@@ -0,0 +1,507 @@
+/*******************************************************************************
+ *
+ * Module Name: rscreate - Create resource lists/tables
+ *
+ ******************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acresrc.h"
+#include "acnamesp.h"
+
+#define _COMPONENT          ACPI_RESOURCES
+ACPI_MODULE_NAME("rscreate")
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_buffer_to_resource
+ *
+ * PARAMETERS:  aml_buffer          - Pointer to the resource byte stream
+ *              aml_buffer_length   - Length of the aml_buffer
+ *              resource_ptr        - Where the converted resource is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Convert a raw AML buffer to a resource list
+ *
+ ******************************************************************************/
+acpi_status
+acpi_buffer_to_resource(u8 *aml_buffer,
+			u16 aml_buffer_length,
+			struct acpi_resource **resource_ptr)
+{
+	acpi_status status;
+	acpi_size list_size_needed;
+	void *resource;
+	void *current_resource_ptr;
+
+	/*
+	 * Note: we allow AE_AML_NO_RESOURCE_END_TAG, since an end tag
+	 * is not required here.
+	 */
+
+	/* Get the required length for the converted resource */
+
+	status = acpi_rs_get_list_length(aml_buffer, aml_buffer_length,
+					 &list_size_needed);
+	if (status == AE_AML_NO_RESOURCE_END_TAG) {
+		status = AE_OK;
+	}
+	if (ACPI_FAILURE(status)) {
+		return (status);
+	}
+
+	/* Allocate a buffer for the converted resource */
+
+	resource = ACPI_ALLOCATE_ZEROED(list_size_needed);
+	current_resource_ptr = resource;
+	if (!resource) {
+		return (AE_NO_MEMORY);
+	}
+
+	/* Perform the AML-to-Resource conversion */
+
+	status = acpi_ut_walk_aml_resources(aml_buffer, aml_buffer_length,
+					    acpi_rs_convert_aml_to_resources,
+					    &current_resource_ptr);
+	if (status == AE_AML_NO_RESOURCE_END_TAG) {
+		status = AE_OK;
+	}
+	if (ACPI_FAILURE(status)) {
+		ACPI_FREE(resource);
+	} else {
+		*resource_ptr = resource;
+	}
+
+	return (status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_rs_create_resource_list
+ *
+ * PARAMETERS:  aml_buffer          - Pointer to the resource byte stream
+ *              output_buffer       - Pointer to the user's buffer
+ *
+ * RETURN:      Status: AE_OK if okay, else a valid acpi_status code
+ *              If output_buffer is not large enough, output_buffer_length
+ *              indicates how large output_buffer should be, else it
+ *              indicates how may u8 elements of output_buffer are valid.
+ *
+ * DESCRIPTION: Takes the byte stream returned from a _CRS, _PRS control method
+ *              execution and parses the stream to create a linked list
+ *              of device resources.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_rs_create_resource_list(union acpi_operand_object *aml_buffer,
+			     struct acpi_buffer * output_buffer)
+{
+
+	acpi_status status;
+	u8 *aml_start;
+	acpi_size list_size_needed = 0;
+	u32 aml_buffer_length;
+	void *resource;
+
+	ACPI_FUNCTION_TRACE(rs_create_resource_list);
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "AmlBuffer = %p\n", aml_buffer));
+
+	/* Params already validated, so we don't re-validate here */
+
+	aml_buffer_length = aml_buffer->buffer.length;
+	aml_start = aml_buffer->buffer.pointer;
+
+	/*
+	 * Pass the aml_buffer into a module that can calculate
+	 * the buffer size needed for the linked list
+	 */
+	status = acpi_rs_get_list_length(aml_start, aml_buffer_length,
+					 &list_size_needed);
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Status=%X ListSizeNeeded=%X\n",
+			  status, (u32)list_size_needed));
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/* Validate/Allocate/Clear caller buffer */
+
+	status = acpi_ut_initialize_buffer(output_buffer, list_size_needed);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/* Do the conversion */
+
+	resource = output_buffer->pointer;
+	status = acpi_ut_walk_aml_resources(aml_start, aml_buffer_length,
+					    acpi_rs_convert_aml_to_resources,
+					    &resource);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "OutputBuffer %p Length %X\n",
+			  output_buffer->pointer, (u32)output_buffer->length));
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_rs_create_pci_routing_table
+ *
+ * PARAMETERS:  package_object          - Pointer to an union acpi_operand_object
+ *                                        package
+ *              output_buffer           - Pointer to the user's buffer
+ *
+ * RETURN:      Status  AE_OK if okay, else a valid acpi_status code.
+ *              If the output_buffer is too small, the error will be
+ *              AE_BUFFER_OVERFLOW and output_buffer->Length will point
+ *              to the size buffer needed.
+ *
+ * DESCRIPTION: Takes the union acpi_operand_object    package and creates a
+ *              linked list of PCI interrupt descriptions
+ *
+ * NOTE: It is the caller's responsibility to ensure that the start of the
+ * output buffer is aligned properly (if necessary).
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_rs_create_pci_routing_table(union acpi_operand_object *package_object,
+				 struct acpi_buffer *output_buffer)
+{
+	u8 *buffer;
+	union acpi_operand_object **top_object_list;
+	union acpi_operand_object **sub_object_list;
+	union acpi_operand_object *obj_desc;
+	acpi_size buffer_size_needed = 0;
+	u32 number_of_elements;
+	u32 index;
+	struct acpi_pci_routing_table *user_prt;
+	struct acpi_namespace_node *node;
+	acpi_status status;
+	struct acpi_buffer path_buffer;
+
+	ACPI_FUNCTION_TRACE(rs_create_pci_routing_table);
+
+	/* Params already validated, so we don't re-validate here */
+
+	/* Get the required buffer length */
+
+	status = acpi_rs_get_pci_routing_table_length(package_object,
+						      &buffer_size_needed);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "BufferSizeNeeded = %X\n",
+			  (u32)buffer_size_needed));
+
+	/* Validate/Allocate/Clear caller buffer */
+
+	status = acpi_ut_initialize_buffer(output_buffer, buffer_size_needed);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/*
+	 * Loop through the ACPI_INTERNAL_OBJECTS - Each object should be a
+	 * package that in turn contains an u64 Address, a u8 Pin,
+	 * a Name, and a u8 source_index.
+	 */
+	top_object_list = package_object->package.elements;
+	number_of_elements = package_object->package.count;
+	buffer = output_buffer->pointer;
+	user_prt = ACPI_CAST_PTR(struct acpi_pci_routing_table, buffer);
+
+	for (index = 0; index < number_of_elements; index++) {
+		/*
+		 * Point user_prt past this current structure
+		 *
+		 * NOTE: On the first iteration, user_prt->Length will
+		 * be zero because we cleared the return buffer earlier
+		 */
+		buffer += user_prt->length;
+		user_prt = ACPI_CAST_PTR(struct acpi_pci_routing_table, buffer);
+
+		/*
+		 * Fill in the Length field with the information we have at this point.
+		 * The minus four is to subtract the size of the u8 Source[4] member
+		 * because it is added below.
+		 */
+		user_prt->length = (sizeof(struct acpi_pci_routing_table) - 4);
+
+		/* Each element of the top-level package must also be a package */
+
+		if ((*top_object_list)->common.type != ACPI_TYPE_PACKAGE) {
+			ACPI_ERROR((AE_INFO,
+				    "(PRT[%u]) Need sub-package, found %s",
+				    index,
+				    acpi_ut_get_object_type_name
+				    (*top_object_list)));
+			return_ACPI_STATUS(AE_AML_OPERAND_TYPE);
+		}
+
+		/* Each sub-package must be of length 4 */
+
+		if ((*top_object_list)->package.count != 4) {
+			ACPI_ERROR((AE_INFO,
+				    "(PRT[%u]) Need package of length 4, found length %u",
+				    index, (*top_object_list)->package.count));
+			return_ACPI_STATUS(AE_AML_PACKAGE_LIMIT);
+		}
+
+		/*
+		 * Dereference the sub-package.
+		 * The sub_object_list will now point to an array of the four IRQ
+		 * elements: [Address, Pin, Source, source_index]
+		 */
+		sub_object_list = (*top_object_list)->package.elements;
+
+		/* 1) First subobject: Dereference the PRT.Address */
+
+		obj_desc = sub_object_list[0];
+		if (obj_desc->common.type != ACPI_TYPE_INTEGER) {
+			ACPI_ERROR((AE_INFO,
+				    "(PRT[%u].Address) Need Integer, found %s",
+				    index,
+				    acpi_ut_get_object_type_name(obj_desc)));
+			return_ACPI_STATUS(AE_BAD_DATA);
+		}
+
+		user_prt->address = obj_desc->integer.value;
+
+		/* 2) Second subobject: Dereference the PRT.Pin */
+
+		obj_desc = sub_object_list[1];
+		if (obj_desc->common.type != ACPI_TYPE_INTEGER) {
+			ACPI_ERROR((AE_INFO,
+				    "(PRT[%u].Pin) Need Integer, found %s",
+				    index,
+				    acpi_ut_get_object_type_name(obj_desc)));
+			return_ACPI_STATUS(AE_BAD_DATA);
+		}
+
+		user_prt->pin = (u32)obj_desc->integer.value;
+
+		/*
+		 * If the BIOS has erroneously reversed the _PRT source_name (index 2)
+		 * and the source_index (index 3), fix it. _PRT is important enough to
+		 * workaround this BIOS error. This also provides compatibility with
+		 * other ACPI implementations.
+		 */
+		obj_desc = sub_object_list[3];
+		if (!obj_desc || (obj_desc->common.type != ACPI_TYPE_INTEGER)) {
+			sub_object_list[3] = sub_object_list[2];
+			sub_object_list[2] = obj_desc;
+
+			ACPI_WARNING((AE_INFO,
+				      "(PRT[%X].Source) SourceName and SourceIndex are reversed, fixed",
+				      index));
+		}
+
+		/*
+		 * 3) Third subobject: Dereference the PRT.source_name
+		 * The name may be unresolved (slack mode), so allow a null object
+		 */
+		obj_desc = sub_object_list[2];
+		if (obj_desc) {
+			switch (obj_desc->common.type) {
+			case ACPI_TYPE_LOCAL_REFERENCE:
+
+				if (obj_desc->reference.class !=
+				    ACPI_REFCLASS_NAME) {
+					ACPI_ERROR((AE_INFO,
+						    "(PRT[%u].Source) Need name, found Reference Class 0x%X",
+						    index,
+						    obj_desc->reference.class));
+					return_ACPI_STATUS(AE_BAD_DATA);
+				}
+
+				node = obj_desc->reference.node;
+
+				/* Use *remaining* length of the buffer as max for pathname */
+
+				path_buffer.length = output_buffer->length -
+				    (u32)((u8 *)user_prt->source -
+					  (u8 *)output_buffer->pointer);
+				path_buffer.pointer = user_prt->source;
+
+				status =
+				    acpi_ns_handle_to_pathname((acpi_handle)
+							       node,
+							       &path_buffer);
+
+				/* +1 to include null terminator */
+
+				user_prt->length +=
+				    (u32)ACPI_STRLEN(user_prt->source) + 1;
+				break;
+
+			case ACPI_TYPE_STRING:
+
+				ACPI_STRCPY(user_prt->source,
+					    obj_desc->string.pointer);
+
+				/*
+				 * Add to the Length field the length of the string
+				 * (add 1 for terminator)
+				 */
+				user_prt->length += obj_desc->string.length + 1;
+				break;
+
+			case ACPI_TYPE_INTEGER:
+				/*
+				 * If this is a number, then the Source Name is NULL, since the
+				 * entire buffer was zeroed out, we can leave this alone.
+				 *
+				 * Add to the Length field the length of the u32 NULL
+				 */
+				user_prt->length += sizeof(u32);
+				break;
+
+			default:
+
+				ACPI_ERROR((AE_INFO,
+					    "(PRT[%u].Source) Need Ref/String/Integer, found %s",
+					    index,
+					    acpi_ut_get_object_type_name
+					    (obj_desc)));
+				return_ACPI_STATUS(AE_BAD_DATA);
+			}
+		}
+
+		/* Now align the current length */
+
+		user_prt->length =
+		    (u32)ACPI_ROUND_UP_TO_64BIT(user_prt->length);
+
+		/* 4) Fourth subobject: Dereference the PRT.source_index */
+
+		obj_desc = sub_object_list[3];
+		if (obj_desc->common.type != ACPI_TYPE_INTEGER) {
+			ACPI_ERROR((AE_INFO,
+				    "(PRT[%u].SourceIndex) Need Integer, found %s",
+				    index,
+				    acpi_ut_get_object_type_name(obj_desc)));
+			return_ACPI_STATUS(AE_BAD_DATA);
+		}
+
+		user_prt->source_index = (u32)obj_desc->integer.value;
+
+		/* Point to the next union acpi_operand_object in the top level package */
+
+		top_object_list++;
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "OutputBuffer %p Length %X\n",
+			  output_buffer->pointer, (u32)output_buffer->length));
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_rs_create_aml_resources
+ *
+ * PARAMETERS:  linked_list_buffer      - Pointer to the resource linked list
+ *              output_buffer           - Pointer to the user's buffer
+ *
+ * RETURN:      Status  AE_OK if okay, else a valid acpi_status code.
+ *              If the output_buffer is too small, the error will be
+ *              AE_BUFFER_OVERFLOW and output_buffer->Length will point
+ *              to the size buffer needed.
+ *
+ * DESCRIPTION: Takes the linked list of device resources and
+ *              creates a bytestream to be used as input for the
+ *              _SRS control method.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_rs_create_aml_resources(struct acpi_resource *linked_list_buffer,
+			     struct acpi_buffer *output_buffer)
+{
+	acpi_status status;
+	acpi_size aml_size_needed = 0;
+
+	ACPI_FUNCTION_TRACE(rs_create_aml_resources);
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "LinkedListBuffer = %p\n",
+			  linked_list_buffer));
+
+	/*
+	 * Params already validated, so we don't re-validate here
+	 *
+	 * Pass the linked_list_buffer into a module that calculates
+	 * the buffer size needed for the byte stream.
+	 */
+	status = acpi_rs_get_aml_length(linked_list_buffer, &aml_size_needed);
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "AmlSizeNeeded=%X, %s\n",
+			  (u32)aml_size_needed, acpi_format_exception(status)));
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/* Validate/Allocate/Clear caller buffer */
+
+	status = acpi_ut_initialize_buffer(output_buffer, aml_size_needed);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/* Do the conversion */
+
+	status =
+	    acpi_rs_convert_resources_to_aml(linked_list_buffer,
+					     aml_size_needed,
+					     output_buffer->pointer);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "OutputBuffer %p Length %X\n",
+			  output_buffer->pointer, (u32)output_buffer->length));
+	return_ACPI_STATUS(AE_OK);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/rsdump.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/rsdump.c
new file mode 100644
index 00000000..8117d9a7
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/rsdump.c
@@ -0,0 +1,949 @@
+/*******************************************************************************
+ *
+ * Module Name: rsdump - Functions to display the resource structures.
+ *
+ ******************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acresrc.h"
+
+#define _COMPONENT          ACPI_RESOURCES
+ACPI_MODULE_NAME("rsdump")
+
+#if defined(ACPI_DEBUG_OUTPUT) || defined(ACPI_DEBUGGER)
+/* Local prototypes */
+static void acpi_rs_out_string(char *title, char *value);
+
+static void acpi_rs_out_integer8(char *title, u8 value);
+
+static void acpi_rs_out_integer16(char *title, u16 value);
+
+static void acpi_rs_out_integer32(char *title, u32 value);
+
+static void acpi_rs_out_integer64(char *title, u64 value);
+
+static void acpi_rs_out_title(char *title);
+
+static void acpi_rs_dump_byte_list(u16 length, u8 *data);
+
+static void acpi_rs_dump_word_list(u16 length, u16 *data);
+
+static void acpi_rs_dump_dword_list(u8 length, u32 *data);
+
+static void acpi_rs_dump_short_byte_list(u8 length, u8 *data);
+
+static void
+acpi_rs_dump_resource_source(struct acpi_resource_source *resource_source);
+
+static void acpi_rs_dump_address_common(union acpi_resource_data *resource);
+
+static void
+acpi_rs_dump_descriptor(void *resource, struct acpi_rsdump_info *table);
+
+#define ACPI_RSD_OFFSET(f)          (u8) ACPI_OFFSET (union acpi_resource_data,f)
+#define ACPI_PRT_OFFSET(f)          (u8) ACPI_OFFSET (struct acpi_pci_routing_table,f)
+#define ACPI_RSD_TABLE_SIZE(name)   (sizeof(name) / sizeof (struct acpi_rsdump_info))
+
+/*******************************************************************************
+ *
+ * Resource Descriptor info tables
+ *
+ * Note: The first table entry must be a Title or Literal and must contain
+ * the table length (number of table entries)
+ *
+ ******************************************************************************/
+
+struct acpi_rsdump_info acpi_rs_dump_irq[7] = {
+	{ACPI_RSD_TITLE, ACPI_RSD_TABLE_SIZE(acpi_rs_dump_irq), "IRQ", NULL},
+	{ACPI_RSD_UINT8, ACPI_RSD_OFFSET(irq.descriptor_length),
+	 "Descriptor Length", NULL},
+	{ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET(irq.triggering), "Triggering",
+	 acpi_gbl_he_decode},
+	{ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET(irq.polarity), "Polarity",
+	 acpi_gbl_ll_decode},
+	{ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET(irq.sharable), "Sharing",
+	 acpi_gbl_shr_decode},
+	{ACPI_RSD_UINT8, ACPI_RSD_OFFSET(irq.interrupt_count),
+	 "Interrupt Count", NULL},
+	{ACPI_RSD_SHORTLIST, ACPI_RSD_OFFSET(irq.interrupts[0]),
+	 "Interrupt List", NULL}
+};
+
+struct acpi_rsdump_info acpi_rs_dump_dma[6] = {
+	{ACPI_RSD_TITLE, ACPI_RSD_TABLE_SIZE(acpi_rs_dump_dma), "DMA", NULL},
+	{ACPI_RSD_2BITFLAG, ACPI_RSD_OFFSET(dma.type), "Speed",
+	 acpi_gbl_typ_decode},
+	{ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET(dma.bus_master), "Mastering",
+	 acpi_gbl_bm_decode},
+	{ACPI_RSD_2BITFLAG, ACPI_RSD_OFFSET(dma.transfer), "Transfer Type",
+	 acpi_gbl_siz_decode},
+	{ACPI_RSD_UINT8, ACPI_RSD_OFFSET(dma.channel_count), "Channel Count",
+	 NULL},
+	{ACPI_RSD_SHORTLIST, ACPI_RSD_OFFSET(dma.channels[0]), "Channel List",
+	 NULL}
+};
+
+struct acpi_rsdump_info acpi_rs_dump_start_dpf[4] = {
+	{ACPI_RSD_TITLE, ACPI_RSD_TABLE_SIZE(acpi_rs_dump_start_dpf),
+	 "Start-Dependent-Functions", NULL},
+	{ACPI_RSD_UINT8, ACPI_RSD_OFFSET(start_dpf.descriptor_length),
+	 "Descriptor Length", NULL},
+	{ACPI_RSD_2BITFLAG, ACPI_RSD_OFFSET(start_dpf.compatibility_priority),
+	 "Compatibility Priority", acpi_gbl_config_decode},
+	{ACPI_RSD_2BITFLAG, ACPI_RSD_OFFSET(start_dpf.performance_robustness),
+	 "Performance/Robustness", acpi_gbl_config_decode}
+};
+
+struct acpi_rsdump_info acpi_rs_dump_end_dpf[1] = {
+	{ACPI_RSD_TITLE, ACPI_RSD_TABLE_SIZE(acpi_rs_dump_end_dpf),
+	 "End-Dependent-Functions", NULL}
+};
+
+struct acpi_rsdump_info acpi_rs_dump_io[6] = {
+	{ACPI_RSD_TITLE, ACPI_RSD_TABLE_SIZE(acpi_rs_dump_io), "I/O", NULL},
+	{ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET(io.io_decode), "Address Decoding",
+	 acpi_gbl_io_decode},
+	{ACPI_RSD_UINT16, ACPI_RSD_OFFSET(io.minimum), "Address Minimum", NULL},
+	{ACPI_RSD_UINT16, ACPI_RSD_OFFSET(io.maximum), "Address Maximum", NULL},
+	{ACPI_RSD_UINT8, ACPI_RSD_OFFSET(io.alignment), "Alignment", NULL},
+	{ACPI_RSD_UINT8, ACPI_RSD_OFFSET(io.address_length), "Address Length",
+	 NULL}
+};
+
+struct acpi_rsdump_info acpi_rs_dump_fixed_io[3] = {
+	{ACPI_RSD_TITLE, ACPI_RSD_TABLE_SIZE(acpi_rs_dump_fixed_io),
+	 "Fixed I/O", NULL},
+	{ACPI_RSD_UINT16, ACPI_RSD_OFFSET(fixed_io.address), "Address", NULL},
+	{ACPI_RSD_UINT8, ACPI_RSD_OFFSET(fixed_io.address_length),
+	 "Address Length", NULL}
+};
+
+struct acpi_rsdump_info acpi_rs_dump_vendor[3] = {
+	{ACPI_RSD_TITLE, ACPI_RSD_TABLE_SIZE(acpi_rs_dump_vendor),
+	 "Vendor Specific", NULL},
+	{ACPI_RSD_UINT16, ACPI_RSD_OFFSET(vendor.byte_length), "Length", NULL},
+	{ACPI_RSD_LONGLIST, ACPI_RSD_OFFSET(vendor.byte_data[0]), "Vendor Data",
+	 NULL}
+};
+
+struct acpi_rsdump_info acpi_rs_dump_end_tag[1] = {
+	{ACPI_RSD_TITLE, ACPI_RSD_TABLE_SIZE(acpi_rs_dump_end_tag), "EndTag",
+	 NULL}
+};
+
+struct acpi_rsdump_info acpi_rs_dump_memory24[6] = {
+	{ACPI_RSD_TITLE, ACPI_RSD_TABLE_SIZE(acpi_rs_dump_memory24),
+	 "24-Bit Memory Range", NULL},
+	{ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET(memory24.write_protect),
+	 "Write Protect", acpi_gbl_rw_decode},
+	{ACPI_RSD_UINT16, ACPI_RSD_OFFSET(memory24.minimum), "Address Minimum",
+	 NULL},
+	{ACPI_RSD_UINT16, ACPI_RSD_OFFSET(memory24.maximum), "Address Maximum",
+	 NULL},
+	{ACPI_RSD_UINT16, ACPI_RSD_OFFSET(memory24.alignment), "Alignment",
+	 NULL},
+	{ACPI_RSD_UINT16, ACPI_RSD_OFFSET(memory24.address_length),
+	 "Address Length", NULL}
+};
+
+struct acpi_rsdump_info acpi_rs_dump_memory32[6] = {
+	{ACPI_RSD_TITLE, ACPI_RSD_TABLE_SIZE(acpi_rs_dump_memory32),
+	 "32-Bit Memory Range", NULL},
+	{ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET(memory32.write_protect),
+	 "Write Protect", acpi_gbl_rw_decode},
+	{ACPI_RSD_UINT32, ACPI_RSD_OFFSET(memory32.minimum), "Address Minimum",
+	 NULL},
+	{ACPI_RSD_UINT32, ACPI_RSD_OFFSET(memory32.maximum), "Address Maximum",
+	 NULL},
+	{ACPI_RSD_UINT32, ACPI_RSD_OFFSET(memory32.alignment), "Alignment",
+	 NULL},
+	{ACPI_RSD_UINT32, ACPI_RSD_OFFSET(memory32.address_length),
+	 "Address Length", NULL}
+};
+
+struct acpi_rsdump_info acpi_rs_dump_fixed_memory32[4] = {
+	{ACPI_RSD_TITLE, ACPI_RSD_TABLE_SIZE(acpi_rs_dump_fixed_memory32),
+	 "32-Bit Fixed Memory Range", NULL},
+	{ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET(fixed_memory32.write_protect),
+	 "Write Protect", acpi_gbl_rw_decode},
+	{ACPI_RSD_UINT32, ACPI_RSD_OFFSET(fixed_memory32.address), "Address",
+	 NULL},
+	{ACPI_RSD_UINT32, ACPI_RSD_OFFSET(fixed_memory32.address_length),
+	 "Address Length", NULL}
+};
+
+struct acpi_rsdump_info acpi_rs_dump_address16[8] = {
+	{ACPI_RSD_TITLE, ACPI_RSD_TABLE_SIZE(acpi_rs_dump_address16),
+	 "16-Bit WORD Address Space", NULL},
+	{ACPI_RSD_ADDRESS, 0, NULL, NULL},
+	{ACPI_RSD_UINT16, ACPI_RSD_OFFSET(address16.granularity), "Granularity",
+	 NULL},
+	{ACPI_RSD_UINT16, ACPI_RSD_OFFSET(address16.minimum), "Address Minimum",
+	 NULL},
+	{ACPI_RSD_UINT16, ACPI_RSD_OFFSET(address16.maximum), "Address Maximum",
+	 NULL},
+	{ACPI_RSD_UINT16, ACPI_RSD_OFFSET(address16.translation_offset),
+	 "Translation Offset", NULL},
+	{ACPI_RSD_UINT16, ACPI_RSD_OFFSET(address16.address_length),
+	 "Address Length", NULL},
+	{ACPI_RSD_SOURCE, ACPI_RSD_OFFSET(address16.resource_source), NULL, NULL}
+};
+
+struct acpi_rsdump_info acpi_rs_dump_address32[8] = {
+	{ACPI_RSD_TITLE, ACPI_RSD_TABLE_SIZE(acpi_rs_dump_address32),
+	 "32-Bit DWORD Address Space", NULL},
+	{ACPI_RSD_ADDRESS, 0, NULL, NULL},
+	{ACPI_RSD_UINT32, ACPI_RSD_OFFSET(address32.granularity), "Granularity",
+	 NULL},
+	{ACPI_RSD_UINT32, ACPI_RSD_OFFSET(address32.minimum), "Address Minimum",
+	 NULL},
+	{ACPI_RSD_UINT32, ACPI_RSD_OFFSET(address32.maximum), "Address Maximum",
+	 NULL},
+	{ACPI_RSD_UINT32, ACPI_RSD_OFFSET(address32.translation_offset),
+	 "Translation Offset", NULL},
+	{ACPI_RSD_UINT32, ACPI_RSD_OFFSET(address32.address_length),
+	 "Address Length", NULL},
+	{ACPI_RSD_SOURCE, ACPI_RSD_OFFSET(address32.resource_source), NULL, NULL}
+};
+
+struct acpi_rsdump_info acpi_rs_dump_address64[8] = {
+	{ACPI_RSD_TITLE, ACPI_RSD_TABLE_SIZE(acpi_rs_dump_address64),
+	 "64-Bit QWORD Address Space", NULL},
+	{ACPI_RSD_ADDRESS, 0, NULL, NULL},
+	{ACPI_RSD_UINT64, ACPI_RSD_OFFSET(address64.granularity), "Granularity",
+	 NULL},
+	{ACPI_RSD_UINT64, ACPI_RSD_OFFSET(address64.minimum), "Address Minimum",
+	 NULL},
+	{ACPI_RSD_UINT64, ACPI_RSD_OFFSET(address64.maximum), "Address Maximum",
+	 NULL},
+	{ACPI_RSD_UINT64, ACPI_RSD_OFFSET(address64.translation_offset),
+	 "Translation Offset", NULL},
+	{ACPI_RSD_UINT64, ACPI_RSD_OFFSET(address64.address_length),
+	 "Address Length", NULL},
+	{ACPI_RSD_SOURCE, ACPI_RSD_OFFSET(address64.resource_source), NULL, NULL}
+};
+
+struct acpi_rsdump_info acpi_rs_dump_ext_address64[8] = {
+	{ACPI_RSD_TITLE, ACPI_RSD_TABLE_SIZE(acpi_rs_dump_ext_address64),
+	 "64-Bit Extended Address Space", NULL},
+	{ACPI_RSD_ADDRESS, 0, NULL, NULL},
+	{ACPI_RSD_UINT64, ACPI_RSD_OFFSET(ext_address64.granularity),
+	 "Granularity", NULL},
+	{ACPI_RSD_UINT64, ACPI_RSD_OFFSET(ext_address64.minimum),
+	 "Address Minimum", NULL},
+	{ACPI_RSD_UINT64, ACPI_RSD_OFFSET(ext_address64.maximum),
+	 "Address Maximum", NULL},
+	{ACPI_RSD_UINT64, ACPI_RSD_OFFSET(ext_address64.translation_offset),
+	 "Translation Offset", NULL},
+	{ACPI_RSD_UINT64, ACPI_RSD_OFFSET(ext_address64.address_length),
+	 "Address Length", NULL},
+	{ACPI_RSD_UINT64, ACPI_RSD_OFFSET(ext_address64.type_specific),
+	 "Type-Specific Attribute", NULL}
+};
+
+struct acpi_rsdump_info acpi_rs_dump_ext_irq[8] = {
+	{ACPI_RSD_TITLE, ACPI_RSD_TABLE_SIZE(acpi_rs_dump_ext_irq),
+	 "Extended IRQ", NULL},
+	{ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET(extended_irq.producer_consumer),
+	 "Type", acpi_gbl_consume_decode},
+	{ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET(extended_irq.triggering),
+	 "Triggering", acpi_gbl_he_decode},
+	{ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET(extended_irq.polarity), "Polarity",
+	 acpi_gbl_ll_decode},
+	{ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET(extended_irq.sharable), "Sharing",
+	 acpi_gbl_shr_decode},
+	{ACPI_RSD_SOURCE, ACPI_RSD_OFFSET(extended_irq.resource_source), NULL,
+	 NULL},
+	{ACPI_RSD_UINT8, ACPI_RSD_OFFSET(extended_irq.interrupt_count),
+	 "Interrupt Count", NULL},
+	{ACPI_RSD_DWORDLIST, ACPI_RSD_OFFSET(extended_irq.interrupts[0]),
+	 "Interrupt List", NULL}
+};
+
+struct acpi_rsdump_info acpi_rs_dump_generic_reg[6] = {
+	{ACPI_RSD_TITLE, ACPI_RSD_TABLE_SIZE(acpi_rs_dump_generic_reg),
+	 "Generic Register", NULL},
+	{ACPI_RSD_UINT8, ACPI_RSD_OFFSET(generic_reg.space_id), "Space ID",
+	 NULL},
+	{ACPI_RSD_UINT8, ACPI_RSD_OFFSET(generic_reg.bit_width), "Bit Width",
+	 NULL},
+	{ACPI_RSD_UINT8, ACPI_RSD_OFFSET(generic_reg.bit_offset), "Bit Offset",
+	 NULL},
+	{ACPI_RSD_UINT8, ACPI_RSD_OFFSET(generic_reg.access_size),
+	 "Access Size", NULL},
+	{ACPI_RSD_UINT64, ACPI_RSD_OFFSET(generic_reg.address), "Address", NULL}
+};
+
+struct acpi_rsdump_info acpi_rs_dump_gpio[16] = {
+	{ACPI_RSD_TITLE, ACPI_RSD_TABLE_SIZE(acpi_rs_dump_gpio), "GPIO", NULL},
+	{ACPI_RSD_UINT8, ACPI_RSD_OFFSET(gpio.revision_id), "RevisionId", NULL},
+	{ACPI_RSD_UINT8, ACPI_RSD_OFFSET(gpio.connection_type),
+	 "ConnectionType", acpi_gbl_ct_decode},
+	{ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET(gpio.producer_consumer),
+	 "ProducerConsumer", acpi_gbl_consume_decode},
+	{ACPI_RSD_UINT8, ACPI_RSD_OFFSET(gpio.pin_config), "PinConfig",
+	 acpi_gbl_ppc_decode},
+	{ACPI_RSD_2BITFLAG, ACPI_RSD_OFFSET(gpio.sharable), "Sharable",
+	 acpi_gbl_shr_decode},
+	{ACPI_RSD_2BITFLAG, ACPI_RSD_OFFSET(gpio.io_restriction),
+	 "IoRestriction", acpi_gbl_ior_decode},
+	{ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET(gpio.triggering), "Triggering",
+	 acpi_gbl_he_decode},
+	{ACPI_RSD_2BITFLAG, ACPI_RSD_OFFSET(gpio.polarity), "Polarity",
+	 acpi_gbl_ll_decode},
+	{ACPI_RSD_UINT16, ACPI_RSD_OFFSET(gpio.drive_strength), "DriveStrength",
+	 NULL},
+	{ACPI_RSD_UINT16, ACPI_RSD_OFFSET(gpio.debounce_timeout),
+	 "DebounceTimeout", NULL},
+	{ACPI_RSD_SOURCE, ACPI_RSD_OFFSET(gpio.resource_source),
+	 "ResourceSource", NULL},
+	{ACPI_RSD_UINT16, ACPI_RSD_OFFSET(gpio.pin_table_length),
+	 "PinTableLength", NULL},
+	{ACPI_RSD_WORDLIST, ACPI_RSD_OFFSET(gpio.pin_table), "PinTable", NULL},
+	{ACPI_RSD_UINT16, ACPI_RSD_OFFSET(gpio.vendor_length), "VendorLength",
+	 NULL},
+	{ACPI_RSD_SHORTLISTX, ACPI_RSD_OFFSET(gpio.vendor_data), "VendorData",
+	 NULL},
+};
+
+struct acpi_rsdump_info acpi_rs_dump_fixed_dma[4] = {
+	{ACPI_RSD_TITLE, ACPI_RSD_TABLE_SIZE(acpi_rs_dump_fixed_dma),
+	 "FixedDma", NULL},
+	{ACPI_RSD_UINT16, ACPI_RSD_OFFSET(fixed_dma.request_lines),
+	 "RequestLines", NULL},
+	{ACPI_RSD_UINT16, ACPI_RSD_OFFSET(fixed_dma.channels), "Channels",
+	 NULL},
+	{ACPI_RSD_UINT8, ACPI_RSD_OFFSET(fixed_dma.width), "TransferWidth",
+	 acpi_gbl_dts_decode},
+};
+
+#define ACPI_RS_DUMP_COMMON_SERIAL_BUS \
+	{ACPI_RSD_UINT8,    ACPI_RSD_OFFSET (common_serial_bus.revision_id),    "RevisionId",               NULL}, \
+	{ACPI_RSD_UINT8,    ACPI_RSD_OFFSET (common_serial_bus.type),           "Type",                     acpi_gbl_sbt_decode}, \
+	{ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET (common_serial_bus.producer_consumer), "ProducerConsumer",      acpi_gbl_consume_decode}, \
+	{ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET (common_serial_bus.slave_mode),     "SlaveMode",                acpi_gbl_sm_decode}, \
+	{ACPI_RSD_UINT8,    ACPI_RSD_OFFSET (common_serial_bus.type_revision_id), "TypeRevisionId",         NULL}, \
+	{ACPI_RSD_UINT16,   ACPI_RSD_OFFSET (common_serial_bus.type_data_length), "TypeDataLength",         NULL}, \
+	{ACPI_RSD_SOURCE,   ACPI_RSD_OFFSET (common_serial_bus.resource_source), "ResourceSource",          NULL}, \
+	{ACPI_RSD_UINT16,   ACPI_RSD_OFFSET (common_serial_bus.vendor_length),  "VendorLength",             NULL}, \
+	{ACPI_RSD_SHORTLISTX,ACPI_RSD_OFFSET (common_serial_bus.vendor_data),   "VendorData",               NULL},
+
+struct acpi_rsdump_info acpi_rs_dump_common_serial_bus[10] = {
+	{ACPI_RSD_TITLE, ACPI_RSD_TABLE_SIZE(acpi_rs_dump_common_serial_bus),
+	 "Common Serial Bus", NULL},
+	ACPI_RS_DUMP_COMMON_SERIAL_BUS
+};
+
+struct acpi_rsdump_info acpi_rs_dump_i2c_serial_bus[13] = {
+	{ACPI_RSD_TITLE, ACPI_RSD_TABLE_SIZE(acpi_rs_dump_i2c_serial_bus),
+	 "I2C Serial Bus", NULL},
+	ACPI_RS_DUMP_COMMON_SERIAL_BUS {ACPI_RSD_1BITFLAG,
+					ACPI_RSD_OFFSET(i2c_serial_bus.
+							access_mode),
+					"AccessMode", acpi_gbl_am_decode},
+	{ACPI_RSD_UINT32, ACPI_RSD_OFFSET(i2c_serial_bus.connection_speed),
+	 "ConnectionSpeed", NULL},
+	{ACPI_RSD_UINT16, ACPI_RSD_OFFSET(i2c_serial_bus.slave_address),
+	 "SlaveAddress", NULL},
+};
+
+struct acpi_rsdump_info acpi_rs_dump_spi_serial_bus[17] = {
+	{ACPI_RSD_TITLE, ACPI_RSD_TABLE_SIZE(acpi_rs_dump_spi_serial_bus),
+	 "Spi Serial Bus", NULL},
+	ACPI_RS_DUMP_COMMON_SERIAL_BUS {ACPI_RSD_1BITFLAG,
+					ACPI_RSD_OFFSET(spi_serial_bus.
+							wire_mode), "WireMode",
+					acpi_gbl_wm_decode},
+	{ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET(spi_serial_bus.device_polarity),
+	 "DevicePolarity", acpi_gbl_dp_decode},
+	{ACPI_RSD_UINT8, ACPI_RSD_OFFSET(spi_serial_bus.data_bit_length),
+	 "DataBitLength", NULL},
+	{ACPI_RSD_UINT8, ACPI_RSD_OFFSET(spi_serial_bus.clock_phase),
+	 "ClockPhase", acpi_gbl_cph_decode},
+	{ACPI_RSD_UINT8, ACPI_RSD_OFFSET(spi_serial_bus.clock_polarity),
+	 "ClockPolarity", acpi_gbl_cpo_decode},
+	{ACPI_RSD_UINT16, ACPI_RSD_OFFSET(spi_serial_bus.device_selection),
+	 "DeviceSelection", NULL},
+	{ACPI_RSD_UINT32, ACPI_RSD_OFFSET(spi_serial_bus.connection_speed),
+	 "ConnectionSpeed", NULL},
+};
+
+struct acpi_rsdump_info acpi_rs_dump_uart_serial_bus[19] = {
+	{ACPI_RSD_TITLE, ACPI_RSD_TABLE_SIZE(acpi_rs_dump_uart_serial_bus),
+	 "Uart Serial Bus", NULL},
+	ACPI_RS_DUMP_COMMON_SERIAL_BUS {ACPI_RSD_2BITFLAG,
+					ACPI_RSD_OFFSET(uart_serial_bus.
+							flow_control),
+					"FlowControl", acpi_gbl_fc_decode},
+	{ACPI_RSD_2BITFLAG, ACPI_RSD_OFFSET(uart_serial_bus.stop_bits),
+	 "StopBits", acpi_gbl_sb_decode},
+	{ACPI_RSD_3BITFLAG, ACPI_RSD_OFFSET(uart_serial_bus.data_bits),
+	 "DataBits", acpi_gbl_bpb_decode},
+	{ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET(uart_serial_bus.endian), "Endian",
+	 acpi_gbl_ed_decode},
+	{ACPI_RSD_UINT8, ACPI_RSD_OFFSET(uart_serial_bus.parity), "Parity",
+	 acpi_gbl_pt_decode},
+	{ACPI_RSD_UINT8, ACPI_RSD_OFFSET(uart_serial_bus.lines_enabled),
+	 "LinesEnabled", NULL},
+	{ACPI_RSD_UINT16, ACPI_RSD_OFFSET(uart_serial_bus.rx_fifo_size),
+	 "RxFifoSize", NULL},
+	{ACPI_RSD_UINT16, ACPI_RSD_OFFSET(uart_serial_bus.tx_fifo_size),
+	 "TxFifoSize", NULL},
+	{ACPI_RSD_UINT32, ACPI_RSD_OFFSET(uart_serial_bus.default_baud_rate),
+	 "ConnectionSpeed", NULL},
+};
+
+/*
+ * Tables used for common address descriptor flag fields
+ */
+static struct acpi_rsdump_info acpi_rs_dump_general_flags[5] = {
+	{ACPI_RSD_TITLE, ACPI_RSD_TABLE_SIZE(acpi_rs_dump_general_flags), NULL,
+	 NULL},
+	{ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET(address.producer_consumer),
+	 "Consumer/Producer", acpi_gbl_consume_decode},
+	{ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET(address.decode), "Address Decode",
+	 acpi_gbl_dec_decode},
+	{ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET(address.min_address_fixed),
+	 "Min Relocatability", acpi_gbl_min_decode},
+	{ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET(address.max_address_fixed),
+	 "Max Relocatability", acpi_gbl_max_decode}
+};
+
+static struct acpi_rsdump_info acpi_rs_dump_memory_flags[5] = {
+	{ACPI_RSD_LITERAL, ACPI_RSD_TABLE_SIZE(acpi_rs_dump_memory_flags),
+	 "Resource Type", (void *)"Memory Range"},
+	{ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET(address.info.mem.write_protect),
+	 "Write Protect", acpi_gbl_rw_decode},
+	{ACPI_RSD_2BITFLAG, ACPI_RSD_OFFSET(address.info.mem.caching),
+	 "Caching", acpi_gbl_mem_decode},
+	{ACPI_RSD_2BITFLAG, ACPI_RSD_OFFSET(address.info.mem.range_type),
+	 "Range Type", acpi_gbl_mtp_decode},
+	{ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET(address.info.mem.translation),
+	 "Translation", acpi_gbl_ttp_decode}
+};
+
+static struct acpi_rsdump_info acpi_rs_dump_io_flags[4] = {
+	{ACPI_RSD_LITERAL, ACPI_RSD_TABLE_SIZE(acpi_rs_dump_io_flags),
+	 "Resource Type", (void *)"I/O Range"},
+	{ACPI_RSD_2BITFLAG, ACPI_RSD_OFFSET(address.info.io.range_type),
+	 "Range Type", acpi_gbl_rng_decode},
+	{ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET(address.info.io.translation),
+	 "Translation", acpi_gbl_ttp_decode},
+	{ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET(address.info.io.translation_type),
+	 "Translation Type", acpi_gbl_trs_decode}
+};
+
+/*
+ * Table used to dump _PRT contents
+ */
+static struct acpi_rsdump_info acpi_rs_dump_prt[5] = {
+	{ACPI_RSD_TITLE, ACPI_RSD_TABLE_SIZE(acpi_rs_dump_prt), NULL, NULL},
+	{ACPI_RSD_UINT64, ACPI_PRT_OFFSET(address), "Address", NULL},
+	{ACPI_RSD_UINT32, ACPI_PRT_OFFSET(pin), "Pin", NULL},
+	{ACPI_RSD_STRING, ACPI_PRT_OFFSET(source[0]), "Source", NULL},
+	{ACPI_RSD_UINT32, ACPI_PRT_OFFSET(source_index), "Source Index", NULL}
+};
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_rs_dump_descriptor
+ *
+ * PARAMETERS:  Resource
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION:
+ *
+ ******************************************************************************/
+
+static void
+acpi_rs_dump_descriptor(void *resource, struct acpi_rsdump_info *table)
+{
+	u8 *target = NULL;
+	u8 *previous_target;
+	char *name;
+	u8 count;
+
+	/* First table entry must contain the table length (# of table entries) */
+
+	count = table->offset;
+
+	while (count) {
+		previous_target = target;
+		target = ACPI_ADD_PTR(u8, resource, table->offset);
+		name = table->name;
+
+		switch (table->opcode) {
+		case ACPI_RSD_TITLE:
+			/*
+			 * Optional resource title
+			 */
+			if (table->name) {
+				acpi_os_printf("%s Resource\n", name);
+			}
+			break;
+
+			/* Strings */
+
+		case ACPI_RSD_LITERAL:
+			acpi_rs_out_string(name,
+					   ACPI_CAST_PTR(char, table->pointer));
+			break;
+
+		case ACPI_RSD_STRING:
+			acpi_rs_out_string(name, ACPI_CAST_PTR(char, target));
+			break;
+
+			/* Data items, 8/16/32/64 bit */
+
+		case ACPI_RSD_UINT8:
+			if (table->pointer) {
+				acpi_rs_out_string(name, ACPI_CAST_PTR(char,
+								       table->
+								       pointer
+								       [*target]));
+			} else {
+				acpi_rs_out_integer8(name, ACPI_GET8(target));
+			}
+			break;
+
+		case ACPI_RSD_UINT16:
+			acpi_rs_out_integer16(name, ACPI_GET16(target));
+			break;
+
+		case ACPI_RSD_UINT32:
+			acpi_rs_out_integer32(name, ACPI_GET32(target));
+			break;
+
+		case ACPI_RSD_UINT64:
+			acpi_rs_out_integer64(name, ACPI_GET64(target));
+			break;
+
+			/* Flags: 1-bit and 2-bit flags supported */
+
+		case ACPI_RSD_1BITFLAG:
+			acpi_rs_out_string(name, ACPI_CAST_PTR(char,
+							       table->
+							       pointer[*target &
+								       0x01]));
+			break;
+
+		case ACPI_RSD_2BITFLAG:
+			acpi_rs_out_string(name, ACPI_CAST_PTR(char,
+							       table->
+							       pointer[*target &
+								       0x03]));
+			break;
+
+		case ACPI_RSD_3BITFLAG:
+			acpi_rs_out_string(name, ACPI_CAST_PTR(char,
+							       table->
+							       pointer[*target &
+								       0x07]));
+			break;
+
+		case ACPI_RSD_SHORTLIST:
+			/*
+			 * Short byte list (single line output) for DMA and IRQ resources
+			 * Note: The list length is obtained from the previous table entry
+			 */
+			if (previous_target) {
+				acpi_rs_out_title(name);
+				acpi_rs_dump_short_byte_list(*previous_target,
+							     target);
+			}
+			break;
+
+		case ACPI_RSD_SHORTLISTX:
+			/*
+			 * Short byte list (single line output) for GPIO vendor data
+			 * Note: The list length is obtained from the previous table entry
+			 */
+			if (previous_target) {
+				acpi_rs_out_title(name);
+				acpi_rs_dump_short_byte_list(*previous_target,
+							     *
+							     (ACPI_CAST_INDIRECT_PTR
+							      (u8, target)));
+			}
+			break;
+
+		case ACPI_RSD_LONGLIST:
+			/*
+			 * Long byte list for Vendor resource data
+			 * Note: The list length is obtained from the previous table entry
+			 */
+			if (previous_target) {
+				acpi_rs_dump_byte_list(ACPI_GET16
+						       (previous_target),
+						       target);
+			}
+			break;
+
+		case ACPI_RSD_DWORDLIST:
+			/*
+			 * Dword list for Extended Interrupt resources
+			 * Note: The list length is obtained from the previous table entry
+			 */
+			if (previous_target) {
+				acpi_rs_dump_dword_list(*previous_target,
+							ACPI_CAST_PTR(u32,
+								      target));
+			}
+			break;
+
+		case ACPI_RSD_WORDLIST:
+			/*
+			 * Word list for GPIO Pin Table
+			 * Note: The list length is obtained from the previous table entry
+			 */
+			if (previous_target) {
+				acpi_rs_dump_word_list(*previous_target,
+						       *(ACPI_CAST_INDIRECT_PTR
+							 (u16, target)));
+			}
+			break;
+
+		case ACPI_RSD_ADDRESS:
+			/*
+			 * Common flags for all Address resources
+			 */
+			acpi_rs_dump_address_common(ACPI_CAST_PTR
+						    (union acpi_resource_data,
+						     target));
+			break;
+
+		case ACPI_RSD_SOURCE:
+			/*
+			 * Optional resource_source for Address resources
+			 */
+			acpi_rs_dump_resource_source(ACPI_CAST_PTR
+						     (struct
+						      acpi_resource_source,
+						      target));
+			break;
+
+		default:
+			acpi_os_printf("**** Invalid table opcode [%X] ****\n",
+				       table->opcode);
+			return;
+		}
+
+		table++;
+		count--;
+	}
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_rs_dump_resource_source
+ *
+ * PARAMETERS:  resource_source     - Pointer to a Resource Source struct
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Common routine for dumping the optional resource_source and the
+ *              corresponding resource_source_index.
+ *
+ ******************************************************************************/
+
+static void
+acpi_rs_dump_resource_source(struct acpi_resource_source *resource_source)
+{
+	ACPI_FUNCTION_ENTRY();
+
+	if (resource_source->index == 0xFF) {
+		return;
+	}
+
+	acpi_rs_out_integer8("Resource Source Index", resource_source->index);
+
+	acpi_rs_out_string("Resource Source",
+			   resource_source->string_ptr ?
+			   resource_source->string_ptr : "[Not Specified]");
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_rs_dump_address_common
+ *
+ * PARAMETERS:  Resource        - Pointer to an internal resource descriptor
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Dump the fields that are common to all Address resource
+ *              descriptors
+ *
+ ******************************************************************************/
+
+static void acpi_rs_dump_address_common(union acpi_resource_data *resource)
+{
+	ACPI_FUNCTION_ENTRY();
+
+	/* Decode the type-specific flags */
+
+	switch (resource->address.resource_type) {
+	case ACPI_MEMORY_RANGE:
+
+		acpi_rs_dump_descriptor(resource, acpi_rs_dump_memory_flags);
+		break;
+
+	case ACPI_IO_RANGE:
+
+		acpi_rs_dump_descriptor(resource, acpi_rs_dump_io_flags);
+		break;
+
+	case ACPI_BUS_NUMBER_RANGE:
+
+		acpi_rs_out_string("Resource Type", "Bus Number Range");
+		break;
+
+	default:
+
+		acpi_rs_out_integer8("Resource Type",
+				     (u8)resource->address.resource_type);
+		break;
+	}
+
+	/* Decode the general flags */
+
+	acpi_rs_dump_descriptor(resource, acpi_rs_dump_general_flags);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_rs_dump_resource_list
+ *
+ * PARAMETERS:  resource_list       - Pointer to a resource descriptor list
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Dispatches the structure to the correct dump routine.
+ *
+ ******************************************************************************/
+
+void acpi_rs_dump_resource_list(struct acpi_resource *resource_list)
+{
+	u32 count = 0;
+	u32 type;
+
+	ACPI_FUNCTION_ENTRY();
+
+	if (!(acpi_dbg_level & ACPI_LV_RESOURCES)
+	    || !(_COMPONENT & acpi_dbg_layer)) {
+		return;
+	}
+
+	/* Walk list and dump all resource descriptors (END_TAG terminates) */
+
+	do {
+		acpi_os_printf("\n[%02X] ", count);
+		count++;
+
+		/* Validate Type before dispatch */
+
+		type = resource_list->type;
+		if (type > ACPI_RESOURCE_TYPE_MAX) {
+			acpi_os_printf
+			    ("Invalid descriptor type (%X) in resource list\n",
+			     resource_list->type);
+			return;
+		}
+
+		/* Dump the resource descriptor */
+
+		if (type == ACPI_RESOURCE_TYPE_SERIAL_BUS) {
+			acpi_rs_dump_descriptor(&resource_list->data,
+						acpi_gbl_dump_serial_bus_dispatch
+						[resource_list->data.
+						 common_serial_bus.type]);
+		} else {
+			acpi_rs_dump_descriptor(&resource_list->data,
+						acpi_gbl_dump_resource_dispatch
+						[type]);
+		}
+
+		/* Point to the next resource structure */
+
+		resource_list = ACPI_NEXT_RESOURCE(resource_list);
+
+		/* Exit when END_TAG descriptor is reached */
+
+	} while (type != ACPI_RESOURCE_TYPE_END_TAG);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_rs_dump_irq_list
+ *
+ * PARAMETERS:  route_table     - Pointer to the routing table to dump.
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Print IRQ routing table
+ *
+ ******************************************************************************/
+
+void acpi_rs_dump_irq_list(u8 *route_table)
+{
+	struct acpi_pci_routing_table *prt_element;
+	u8 count;
+
+	ACPI_FUNCTION_ENTRY();
+
+	if (!(acpi_dbg_level & ACPI_LV_RESOURCES)
+	    || !(_COMPONENT & acpi_dbg_layer)) {
+		return;
+	}
+
+	prt_element = ACPI_CAST_PTR(struct acpi_pci_routing_table, route_table);
+
+	/* Dump all table elements, Exit on zero length element */
+
+	for (count = 0; prt_element->length; count++) {
+		acpi_os_printf("\n[%02X] PCI IRQ Routing Table Package\n",
+			       count);
+		acpi_rs_dump_descriptor(prt_element, acpi_rs_dump_prt);
+
+		prt_element = ACPI_ADD_PTR(struct acpi_pci_routing_table,
+					   prt_element, prt_element->length);
+	}
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_rs_out*
+ *
+ * PARAMETERS:  Title       - Name of the resource field
+ *              Value       - Value of the resource field
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Miscellaneous helper functions to consistently format the
+ *              output of the resource dump routines
+ *
+ ******************************************************************************/
+
+static void acpi_rs_out_string(char *title, char *value)
+{
+	acpi_os_printf("%27s : %s", title, value);
+	if (!*value) {
+		acpi_os_printf("[NULL NAMESTRING]");
+	}
+	acpi_os_printf("\n");
+}
+
+static void acpi_rs_out_integer8(char *title, u8 value)
+{
+	acpi_os_printf("%27s : %2.2X\n", title, value);
+}
+
+static void acpi_rs_out_integer16(char *title, u16 value)
+{
+	acpi_os_printf("%27s : %4.4X\n", title, value);
+}
+
+static void acpi_rs_out_integer32(char *title, u32 value)
+{
+	acpi_os_printf("%27s : %8.8X\n", title, value);
+}
+
+static void acpi_rs_out_integer64(char *title, u64 value)
+{
+	acpi_os_printf("%27s : %8.8X%8.8X\n", title, ACPI_FORMAT_UINT64(value));
+}
+
+static void acpi_rs_out_title(char *title)
+{
+	acpi_os_printf("%27s : ", title);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_rs_dump*List
+ *
+ * PARAMETERS:  Length      - Number of elements in the list
+ *              Data        - Start of the list
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Miscellaneous functions to dump lists of raw data
+ *
+ ******************************************************************************/
+
+static void acpi_rs_dump_byte_list(u16 length, u8 *data)
+{
+	u8 i;
+
+	for (i = 0; i < length; i++) {
+		acpi_os_printf("%25s%2.2X : %2.2X\n", "Byte", i, data[i]);
+	}
+}
+
+static void acpi_rs_dump_short_byte_list(u8 length, u8 *data)
+{
+	u8 i;
+
+	for (i = 0; i < length; i++) {
+		acpi_os_printf("%X ", data[i]);
+	}
+	acpi_os_printf("\n");
+}
+
+static void acpi_rs_dump_dword_list(u8 length, u32 *data)
+{
+	u8 i;
+
+	for (i = 0; i < length; i++) {
+		acpi_os_printf("%25s%2.2X : %8.8X\n", "Dword", i, data[i]);
+	}
+}
+
+static void acpi_rs_dump_word_list(u16 length, u16 *data)
+{
+	u16 i;
+
+	for (i = 0; i < length; i++) {
+		acpi_os_printf("%25s%2.2X : %4.4X\n", "Word", i, data[i]);
+	}
+}
+
+#endif
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/rsinfo.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/rsinfo.c
new file mode 100644
index 00000000..fe3adca3
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/rsinfo.c
@@ -0,0 +1,248 @@
+/*******************************************************************************
+ *
+ * Module Name: rsinfo - Dispatch and Info tables
+ *
+ ******************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acresrc.h"
+
+#define _COMPONENT          ACPI_RESOURCES
+ACPI_MODULE_NAME("rsinfo")
+
+/*
+ * Resource dispatch and information tables. Any new resource types (either
+ * Large or Small) must be reflected in each of these tables, so they are here
+ * in one place.
+ *
+ * The tables for Large descriptors are indexed by bits 6:0 of the AML
+ * descriptor type byte. The tables for Small descriptors are indexed by
+ * bits 6:3 of the descriptor byte. The tables for internal resource
+ * descriptors are indexed by the acpi_resource_type field.
+ */
+/* Dispatch table for resource-to-AML (Set Resource) conversion functions */
+struct acpi_rsconvert_info *acpi_gbl_set_resource_dispatch[] = {
+	acpi_rs_set_irq,	/* 0x00, ACPI_RESOURCE_TYPE_IRQ */
+	acpi_rs_convert_dma,	/* 0x01, ACPI_RESOURCE_TYPE_DMA */
+	acpi_rs_set_start_dpf,	/* 0x02, ACPI_RESOURCE_TYPE_START_DEPENDENT */
+	acpi_rs_convert_end_dpf,	/* 0x03, ACPI_RESOURCE_TYPE_END_DEPENDENT */
+	acpi_rs_convert_io,	/* 0x04, ACPI_RESOURCE_TYPE_IO */
+	acpi_rs_convert_fixed_io,	/* 0x05, ACPI_RESOURCE_TYPE_FIXED_IO */
+	acpi_rs_set_vendor,	/* 0x06, ACPI_RESOURCE_TYPE_VENDOR */
+	acpi_rs_convert_end_tag,	/* 0x07, ACPI_RESOURCE_TYPE_END_TAG */
+	acpi_rs_convert_memory24,	/* 0x08, ACPI_RESOURCE_TYPE_MEMORY24 */
+	acpi_rs_convert_memory32,	/* 0x09, ACPI_RESOURCE_TYPE_MEMORY32 */
+	acpi_rs_convert_fixed_memory32,	/* 0x0A, ACPI_RESOURCE_TYPE_FIXED_MEMORY32 */
+	acpi_rs_convert_address16,	/* 0x0B, ACPI_RESOURCE_TYPE_ADDRESS16 */
+	acpi_rs_convert_address32,	/* 0x0C, ACPI_RESOURCE_TYPE_ADDRESS32 */
+	acpi_rs_convert_address64,	/* 0x0D, ACPI_RESOURCE_TYPE_ADDRESS64 */
+	acpi_rs_convert_ext_address64,	/* 0x0E, ACPI_RESOURCE_TYPE_EXTENDED_ADDRESS64 */
+	acpi_rs_convert_ext_irq,	/* 0x0F, ACPI_RESOURCE_TYPE_EXTENDED_IRQ */
+	acpi_rs_convert_generic_reg,	/* 0x10, ACPI_RESOURCE_TYPE_GENERIC_REGISTER */
+	acpi_rs_convert_gpio,	/* 0x11, ACPI_RESOURCE_TYPE_GPIO */
+	acpi_rs_convert_fixed_dma,	/* 0x12, ACPI_RESOURCE_TYPE_FIXED_DMA */
+	NULL,			/* 0x13, ACPI_RESOURCE_TYPE_SERIAL_BUS - Use subtype table below */
+};
+
+/* Dispatch tables for AML-to-resource (Get Resource) conversion functions */
+
+struct acpi_rsconvert_info *acpi_gbl_get_resource_dispatch[] = {
+	/* Small descriptors */
+
+	NULL,			/* 0x00, Reserved */
+	NULL,			/* 0x01, Reserved */
+	NULL,			/* 0x02, Reserved */
+	NULL,			/* 0x03, Reserved */
+	acpi_rs_get_irq,	/* 0x04, ACPI_RESOURCE_NAME_IRQ */
+	acpi_rs_convert_dma,	/* 0x05, ACPI_RESOURCE_NAME_DMA */
+	acpi_rs_get_start_dpf,	/* 0x06, ACPI_RESOURCE_NAME_START_DEPENDENT */
+	acpi_rs_convert_end_dpf,	/* 0x07, ACPI_RESOURCE_NAME_END_DEPENDENT */
+	acpi_rs_convert_io,	/* 0x08, ACPI_RESOURCE_NAME_IO */
+	acpi_rs_convert_fixed_io,	/* 0x09, ACPI_RESOURCE_NAME_FIXED_IO */
+	acpi_rs_convert_fixed_dma,	/* 0x0A, ACPI_RESOURCE_NAME_FIXED_DMA */
+	NULL,			/* 0x0B, Reserved */
+	NULL,			/* 0x0C, Reserved */
+	NULL,			/* 0x0D, Reserved */
+	acpi_rs_get_vendor_small,	/* 0x0E, ACPI_RESOURCE_NAME_VENDOR_SMALL */
+	acpi_rs_convert_end_tag,	/* 0x0F, ACPI_RESOURCE_NAME_END_TAG */
+
+	/* Large descriptors */
+
+	NULL,			/* 0x00, Reserved */
+	acpi_rs_convert_memory24,	/* 0x01, ACPI_RESOURCE_NAME_MEMORY24 */
+	acpi_rs_convert_generic_reg,	/* 0x02, ACPI_RESOURCE_NAME_GENERIC_REGISTER */
+	NULL,			/* 0x03, Reserved */
+	acpi_rs_get_vendor_large,	/* 0x04, ACPI_RESOURCE_NAME_VENDOR_LARGE */
+	acpi_rs_convert_memory32,	/* 0x05, ACPI_RESOURCE_NAME_MEMORY32 */
+	acpi_rs_convert_fixed_memory32,	/* 0x06, ACPI_RESOURCE_NAME_FIXED_MEMORY32 */
+	acpi_rs_convert_address32,	/* 0x07, ACPI_RESOURCE_NAME_ADDRESS32 */
+	acpi_rs_convert_address16,	/* 0x08, ACPI_RESOURCE_NAME_ADDRESS16 */
+	acpi_rs_convert_ext_irq,	/* 0x09, ACPI_RESOURCE_NAME_EXTENDED_IRQ */
+	acpi_rs_convert_address64,	/* 0x0A, ACPI_RESOURCE_NAME_ADDRESS64 */
+	acpi_rs_convert_ext_address64,	/* 0x0B, ACPI_RESOURCE_NAME_EXTENDED_ADDRESS64 */
+	acpi_rs_convert_gpio,	/* 0x0C, ACPI_RESOURCE_NAME_GPIO */
+	NULL,			/* 0x0D, Reserved */
+	NULL,			/* 0x0E, ACPI_RESOURCE_NAME_SERIAL_BUS - Use subtype table below */
+};
+
+/* Subtype table for serial_bus -- I2C, SPI, and UART */
+
+struct acpi_rsconvert_info *acpi_gbl_convert_resource_serial_bus_dispatch[] = {
+	NULL,
+	acpi_rs_convert_i2c_serial_bus,
+	acpi_rs_convert_spi_serial_bus,
+	acpi_rs_convert_uart_serial_bus,
+};
+
+#if defined(ACPI_DEBUG_OUTPUT) || defined(ACPI_DEBUGGER)
+
+/* Dispatch table for resource dump functions */
+
+struct acpi_rsdump_info *acpi_gbl_dump_resource_dispatch[] = {
+	acpi_rs_dump_irq,	/* ACPI_RESOURCE_TYPE_IRQ */
+	acpi_rs_dump_dma,	/* ACPI_RESOURCE_TYPE_DMA */
+	acpi_rs_dump_start_dpf,	/* ACPI_RESOURCE_TYPE_START_DEPENDENT */
+	acpi_rs_dump_end_dpf,	/* ACPI_RESOURCE_TYPE_END_DEPENDENT */
+	acpi_rs_dump_io,	/* ACPI_RESOURCE_TYPE_IO */
+	acpi_rs_dump_fixed_io,	/* ACPI_RESOURCE_TYPE_FIXED_IO */
+	acpi_rs_dump_vendor,	/* ACPI_RESOURCE_TYPE_VENDOR */
+	acpi_rs_dump_end_tag,	/* ACPI_RESOURCE_TYPE_END_TAG */
+	acpi_rs_dump_memory24,	/* ACPI_RESOURCE_TYPE_MEMORY24 */
+	acpi_rs_dump_memory32,	/* ACPI_RESOURCE_TYPE_MEMORY32 */
+	acpi_rs_dump_fixed_memory32,	/* ACPI_RESOURCE_TYPE_FIXED_MEMORY32 */
+	acpi_rs_dump_address16,	/* ACPI_RESOURCE_TYPE_ADDRESS16 */
+	acpi_rs_dump_address32,	/* ACPI_RESOURCE_TYPE_ADDRESS32 */
+	acpi_rs_dump_address64,	/* ACPI_RESOURCE_TYPE_ADDRESS64 */
+	acpi_rs_dump_ext_address64,	/* ACPI_RESOURCE_TYPE_EXTENDED_ADDRESS64 */
+	acpi_rs_dump_ext_irq,	/* ACPI_RESOURCE_TYPE_EXTENDED_IRQ */
+	acpi_rs_dump_generic_reg,	/* ACPI_RESOURCE_TYPE_GENERIC_REGISTER */
+	acpi_rs_dump_gpio,	/* ACPI_RESOURCE_TYPE_GPIO */
+	acpi_rs_dump_fixed_dma,	/* ACPI_RESOURCE_TYPE_FIXED_DMA */
+	NULL,			/* ACPI_RESOURCE_TYPE_SERIAL_BUS */
+};
+
+struct acpi_rsdump_info *acpi_gbl_dump_serial_bus_dispatch[] = {
+	NULL,
+	acpi_rs_dump_i2c_serial_bus,	/* AML_RESOURCE_I2C_BUS_TYPE */
+	acpi_rs_dump_spi_serial_bus,	/* AML_RESOURCE_SPI_BUS_TYPE */
+	acpi_rs_dump_uart_serial_bus,	/* AML_RESOURCE_UART_BUS_TYPE */
+};
+#endif
+
+/*
+ * Base sizes for external AML resource descriptors, indexed by internal type.
+ * Includes size of the descriptor header (1 byte for small descriptors,
+ * 3 bytes for large descriptors)
+ */
+const u8 acpi_gbl_aml_resource_sizes[] = {
+	sizeof(struct aml_resource_irq),	/* ACPI_RESOURCE_TYPE_IRQ (optional Byte 3 always created) */
+	sizeof(struct aml_resource_dma),	/* ACPI_RESOURCE_TYPE_DMA */
+	sizeof(struct aml_resource_start_dependent),	/* ACPI_RESOURCE_TYPE_START_DEPENDENT (optional Byte 1 always created) */
+	sizeof(struct aml_resource_end_dependent),	/* ACPI_RESOURCE_TYPE_END_DEPENDENT */
+	sizeof(struct aml_resource_io),	/* ACPI_RESOURCE_TYPE_IO */
+	sizeof(struct aml_resource_fixed_io),	/* ACPI_RESOURCE_TYPE_FIXED_IO */
+	sizeof(struct aml_resource_vendor_small),	/* ACPI_RESOURCE_TYPE_VENDOR */
+	sizeof(struct aml_resource_end_tag),	/* ACPI_RESOURCE_TYPE_END_TAG */
+	sizeof(struct aml_resource_memory24),	/* ACPI_RESOURCE_TYPE_MEMORY24 */
+	sizeof(struct aml_resource_memory32),	/* ACPI_RESOURCE_TYPE_MEMORY32 */
+	sizeof(struct aml_resource_fixed_memory32),	/* ACPI_RESOURCE_TYPE_FIXED_MEMORY32 */
+	sizeof(struct aml_resource_address16),	/* ACPI_RESOURCE_TYPE_ADDRESS16 */
+	sizeof(struct aml_resource_address32),	/* ACPI_RESOURCE_TYPE_ADDRESS32 */
+	sizeof(struct aml_resource_address64),	/* ACPI_RESOURCE_TYPE_ADDRESS64 */
+	sizeof(struct aml_resource_extended_address64),	/*ACPI_RESOURCE_TYPE_EXTENDED_ADDRESS64 */
+	sizeof(struct aml_resource_extended_irq),	/* ACPI_RESOURCE_TYPE_EXTENDED_IRQ */
+	sizeof(struct aml_resource_generic_register),	/* ACPI_RESOURCE_TYPE_GENERIC_REGISTER */
+	sizeof(struct aml_resource_gpio),	/* ACPI_RESOURCE_TYPE_GPIO */
+	sizeof(struct aml_resource_fixed_dma),	/* ACPI_RESOURCE_TYPE_FIXED_DMA */
+	sizeof(struct aml_resource_common_serialbus),	/* ACPI_RESOURCE_TYPE_SERIAL_BUS */
+};
+
+const u8 acpi_gbl_resource_struct_sizes[] = {
+	/* Small descriptors */
+
+	0,
+	0,
+	0,
+	0,
+	ACPI_RS_SIZE(struct acpi_resource_irq),
+	ACPI_RS_SIZE(struct acpi_resource_dma),
+	ACPI_RS_SIZE(struct acpi_resource_start_dependent),
+	ACPI_RS_SIZE_MIN,
+	ACPI_RS_SIZE(struct acpi_resource_io),
+	ACPI_RS_SIZE(struct acpi_resource_fixed_io),
+	ACPI_RS_SIZE(struct acpi_resource_fixed_dma),
+	0,
+	0,
+	0,
+	ACPI_RS_SIZE(struct acpi_resource_vendor),
+	ACPI_RS_SIZE_MIN,
+
+	/* Large descriptors */
+
+	0,
+	ACPI_RS_SIZE(struct acpi_resource_memory24),
+	ACPI_RS_SIZE(struct acpi_resource_generic_register),
+	0,
+	ACPI_RS_SIZE(struct acpi_resource_vendor),
+	ACPI_RS_SIZE(struct acpi_resource_memory32),
+	ACPI_RS_SIZE(struct acpi_resource_fixed_memory32),
+	ACPI_RS_SIZE(struct acpi_resource_address32),
+	ACPI_RS_SIZE(struct acpi_resource_address16),
+	ACPI_RS_SIZE(struct acpi_resource_extended_irq),
+	ACPI_RS_SIZE(struct acpi_resource_address64),
+	ACPI_RS_SIZE(struct acpi_resource_extended_address64),
+	ACPI_RS_SIZE(struct acpi_resource_gpio),
+	ACPI_RS_SIZE(struct acpi_resource_common_serialbus)
+};
+
+const u8 acpi_gbl_aml_resource_serial_bus_sizes[] = {
+	0,
+	sizeof(struct aml_resource_i2c_serialbus),
+	sizeof(struct aml_resource_spi_serialbus),
+	sizeof(struct aml_resource_uart_serialbus),
+};
+
+const u8 acpi_gbl_resource_struct_serial_bus_sizes[] = {
+	0,
+	ACPI_RS_SIZE(struct acpi_resource_i2c_serialbus),
+	ACPI_RS_SIZE(struct acpi_resource_spi_serialbus),
+	ACPI_RS_SIZE(struct acpi_resource_uart_serialbus),
+};
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/rsio.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/rsio.c
new file mode 100644
index 00000000..f6a08105
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/rsio.c
@@ -0,0 +1,290 @@
+/*******************************************************************************
+ *
+ * Module Name: rsio - IO and DMA resource descriptors
+ *
+ ******************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acresrc.h"
+
+#define _COMPONENT          ACPI_RESOURCES
+ACPI_MODULE_NAME("rsio")
+
+/*******************************************************************************
+ *
+ * acpi_rs_convert_io
+ *
+ ******************************************************************************/
+struct acpi_rsconvert_info acpi_rs_convert_io[5] = {
+	{ACPI_RSC_INITGET, ACPI_RESOURCE_TYPE_IO,
+	 ACPI_RS_SIZE(struct acpi_resource_io),
+	 ACPI_RSC_TABLE_SIZE(acpi_rs_convert_io)},
+
+	{ACPI_RSC_INITSET, ACPI_RESOURCE_NAME_IO,
+	 sizeof(struct aml_resource_io),
+	 0},
+
+	/* Decode flag */
+
+	{ACPI_RSC_1BITFLAG, ACPI_RS_OFFSET(data.io.io_decode),
+	 AML_OFFSET(io.flags),
+	 0},
+	/*
+	 * These fields are contiguous in both the source and destination:
+	 * Address Alignment
+	 * Length
+	 * Minimum Base Address
+	 * Maximum Base Address
+	 */
+	{ACPI_RSC_MOVE8, ACPI_RS_OFFSET(data.io.alignment),
+	 AML_OFFSET(io.alignment),
+	 2},
+
+	{ACPI_RSC_MOVE16, ACPI_RS_OFFSET(data.io.minimum),
+	 AML_OFFSET(io.minimum),
+	 2}
+};
+
+/*******************************************************************************
+ *
+ * acpi_rs_convert_fixed_io
+ *
+ ******************************************************************************/
+
+struct acpi_rsconvert_info acpi_rs_convert_fixed_io[4] = {
+	{ACPI_RSC_INITGET, ACPI_RESOURCE_TYPE_FIXED_IO,
+	 ACPI_RS_SIZE(struct acpi_resource_fixed_io),
+	 ACPI_RSC_TABLE_SIZE(acpi_rs_convert_fixed_io)},
+
+	{ACPI_RSC_INITSET, ACPI_RESOURCE_NAME_FIXED_IO,
+	 sizeof(struct aml_resource_fixed_io),
+	 0},
+	/*
+	 * These fields are contiguous in both the source and destination:
+	 * Base Address
+	 * Length
+	 */
+	{ACPI_RSC_MOVE8, ACPI_RS_OFFSET(data.fixed_io.address_length),
+	 AML_OFFSET(fixed_io.address_length),
+	 1},
+
+	{ACPI_RSC_MOVE16, ACPI_RS_OFFSET(data.fixed_io.address),
+	 AML_OFFSET(fixed_io.address),
+	 1}
+};
+
+/*******************************************************************************
+ *
+ * acpi_rs_convert_generic_reg
+ *
+ ******************************************************************************/
+
+struct acpi_rsconvert_info acpi_rs_convert_generic_reg[4] = {
+	{ACPI_RSC_INITGET, ACPI_RESOURCE_TYPE_GENERIC_REGISTER,
+	 ACPI_RS_SIZE(struct acpi_resource_generic_register),
+	 ACPI_RSC_TABLE_SIZE(acpi_rs_convert_generic_reg)},
+
+	{ACPI_RSC_INITSET, ACPI_RESOURCE_NAME_GENERIC_REGISTER,
+	 sizeof(struct aml_resource_generic_register),
+	 0},
+	/*
+	 * These fields are contiguous in both the source and destination:
+	 * Address Space ID
+	 * Register Bit Width
+	 * Register Bit Offset
+	 * Access Size
+	 */
+	{ACPI_RSC_MOVE8, ACPI_RS_OFFSET(data.generic_reg.space_id),
+	 AML_OFFSET(generic_reg.address_space_id),
+	 4},
+
+	/* Get the Register Address */
+
+	{ACPI_RSC_MOVE64, ACPI_RS_OFFSET(data.generic_reg.address),
+	 AML_OFFSET(generic_reg.address),
+	 1}
+};
+
+/*******************************************************************************
+ *
+ * acpi_rs_convert_end_dpf
+ *
+ ******************************************************************************/
+
+struct acpi_rsconvert_info acpi_rs_convert_end_dpf[2] = {
+	{ACPI_RSC_INITGET, ACPI_RESOURCE_TYPE_END_DEPENDENT,
+	 ACPI_RS_SIZE_MIN,
+	 ACPI_RSC_TABLE_SIZE(acpi_rs_convert_end_dpf)},
+
+	{ACPI_RSC_INITSET, ACPI_RESOURCE_NAME_END_DEPENDENT,
+	 sizeof(struct aml_resource_end_dependent),
+	 0}
+};
+
+/*******************************************************************************
+ *
+ * acpi_rs_convert_end_tag
+ *
+ ******************************************************************************/
+
+struct acpi_rsconvert_info acpi_rs_convert_end_tag[2] = {
+	{ACPI_RSC_INITGET, ACPI_RESOURCE_TYPE_END_TAG,
+	 ACPI_RS_SIZE_MIN,
+	 ACPI_RSC_TABLE_SIZE(acpi_rs_convert_end_tag)},
+
+	/*
+	 * Note: The checksum field is set to zero, meaning that the resource
+	 * data is treated as if the checksum operation succeeded.
+	 * (ACPI Spec 1.0b Section 6.4.2.8)
+	 */
+	{ACPI_RSC_INITSET, ACPI_RESOURCE_NAME_END_TAG,
+	 sizeof(struct aml_resource_end_tag),
+	 0}
+};
+
+/*******************************************************************************
+ *
+ * acpi_rs_get_start_dpf
+ *
+ ******************************************************************************/
+
+struct acpi_rsconvert_info acpi_rs_get_start_dpf[6] = {
+	{ACPI_RSC_INITGET, ACPI_RESOURCE_TYPE_START_DEPENDENT,
+	 ACPI_RS_SIZE(struct acpi_resource_start_dependent),
+	 ACPI_RSC_TABLE_SIZE(acpi_rs_get_start_dpf)},
+
+	/* Defaults for Compatibility and Performance priorities */
+
+	{ACPI_RSC_SET8, ACPI_RS_OFFSET(data.start_dpf.compatibility_priority),
+	 ACPI_ACCEPTABLE_CONFIGURATION,
+	 2},
+
+	/* Get the descriptor length (0 or 1 for Start Dpf descriptor) */
+
+	{ACPI_RSC_1BITFLAG, ACPI_RS_OFFSET(data.start_dpf.descriptor_length),
+	 AML_OFFSET(start_dpf.descriptor_type),
+	 0},
+
+	/* All done if there is no flag byte present in the descriptor */
+
+	{ACPI_RSC_EXIT_NE, ACPI_RSC_COMPARE_AML_LENGTH, 0, 1},
+
+	/* Flag byte is present, get the flags */
+
+	{ACPI_RSC_2BITFLAG,
+	 ACPI_RS_OFFSET(data.start_dpf.compatibility_priority),
+	 AML_OFFSET(start_dpf.flags),
+	 0},
+
+	{ACPI_RSC_2BITFLAG,
+	 ACPI_RS_OFFSET(data.start_dpf.performance_robustness),
+	 AML_OFFSET(start_dpf.flags),
+	 2}
+};
+
+/*******************************************************************************
+ *
+ * acpi_rs_set_start_dpf
+ *
+ ******************************************************************************/
+
+struct acpi_rsconvert_info acpi_rs_set_start_dpf[10] = {
+	/* Start with a default descriptor of length 1 */
+
+	{ACPI_RSC_INITSET, ACPI_RESOURCE_NAME_START_DEPENDENT,
+	 sizeof(struct aml_resource_start_dependent),
+	 ACPI_RSC_TABLE_SIZE(acpi_rs_set_start_dpf)},
+
+	/* Set the default flag values */
+
+	{ACPI_RSC_2BITFLAG,
+	 ACPI_RS_OFFSET(data.start_dpf.compatibility_priority),
+	 AML_OFFSET(start_dpf.flags),
+	 0},
+
+	{ACPI_RSC_2BITFLAG,
+	 ACPI_RS_OFFSET(data.start_dpf.performance_robustness),
+	 AML_OFFSET(start_dpf.flags),
+	 2},
+	/*
+	 * All done if the output descriptor length is required to be 1
+	 * (i.e., optimization to 0 bytes cannot be attempted)
+	 */
+	{ACPI_RSC_EXIT_EQ, ACPI_RSC_COMPARE_VALUE,
+	 ACPI_RS_OFFSET(data.start_dpf.descriptor_length),
+	 1},
+
+	/* Set length to 0 bytes (no flags byte) */
+
+	{ACPI_RSC_LENGTH, 0, 0,
+	 sizeof(struct aml_resource_start_dependent_noprio)},
+
+	/*
+	 * All done if the output descriptor length is required to be 0.
+	 *
+	 * TBD: Perhaps we should check for error if input flags are not
+	 * compatible with a 0-byte descriptor.
+	 */
+	{ACPI_RSC_EXIT_EQ, ACPI_RSC_COMPARE_VALUE,
+	 ACPI_RS_OFFSET(data.start_dpf.descriptor_length),
+	 0},
+
+	/* Reset length to 1 byte (descriptor with flags byte) */
+
+	{ACPI_RSC_LENGTH, 0, 0, sizeof(struct aml_resource_start_dependent)},
+
+	/*
+	 * All done if flags byte is necessary -- if either priority value
+	 * is not ACPI_ACCEPTABLE_CONFIGURATION
+	 */
+	{ACPI_RSC_EXIT_NE, ACPI_RSC_COMPARE_VALUE,
+	 ACPI_RS_OFFSET(data.start_dpf.compatibility_priority),
+	 ACPI_ACCEPTABLE_CONFIGURATION},
+
+	{ACPI_RSC_EXIT_NE, ACPI_RSC_COMPARE_VALUE,
+	 ACPI_RS_OFFSET(data.start_dpf.performance_robustness),
+	 ACPI_ACCEPTABLE_CONFIGURATION},
+
+	/* Flag byte is not necessary */
+
+	{ACPI_RSC_LENGTH, 0, 0,
+	 sizeof(struct aml_resource_start_dependent_noprio)}
+};
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/rsirq.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/rsirq.c
new file mode 100644
index 00000000..a718eca8
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/rsirq.c
@@ -0,0 +1,295 @@
+/*******************************************************************************
+ *
+ * Module Name: rsirq - IRQ resource descriptors
+ *
+ ******************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acresrc.h"
+
+#define _COMPONENT          ACPI_RESOURCES
+ACPI_MODULE_NAME("rsirq")
+
+/*******************************************************************************
+ *
+ * acpi_rs_get_irq
+ *
+ ******************************************************************************/
+struct acpi_rsconvert_info acpi_rs_get_irq[8] = {
+	{ACPI_RSC_INITGET, ACPI_RESOURCE_TYPE_IRQ,
+	 ACPI_RS_SIZE(struct acpi_resource_irq),
+	 ACPI_RSC_TABLE_SIZE(acpi_rs_get_irq)},
+
+	/* Get the IRQ mask (bytes 1:2) */
+
+	{ACPI_RSC_BITMASK16, ACPI_RS_OFFSET(data.irq.interrupts[0]),
+	 AML_OFFSET(irq.irq_mask),
+	 ACPI_RS_OFFSET(data.irq.interrupt_count)},
+
+	/* Set default flags (others are zero) */
+
+	{ACPI_RSC_SET8, ACPI_RS_OFFSET(data.irq.triggering),
+	 ACPI_EDGE_SENSITIVE,
+	 1},
+
+	/* Get the descriptor length (2 or 3 for IRQ descriptor) */
+
+	{ACPI_RSC_2BITFLAG, ACPI_RS_OFFSET(data.irq.descriptor_length),
+	 AML_OFFSET(irq.descriptor_type),
+	 0},
+
+	/* All done if no flag byte present in descriptor */
+
+	{ACPI_RSC_EXIT_NE, ACPI_RSC_COMPARE_AML_LENGTH, 0, 3},
+
+	/* Get flags: Triggering[0], Polarity[3], Sharing[4] */
+
+	{ACPI_RSC_1BITFLAG, ACPI_RS_OFFSET(data.irq.triggering),
+	 AML_OFFSET(irq.flags),
+	 0},
+
+	{ACPI_RSC_1BITFLAG, ACPI_RS_OFFSET(data.irq.polarity),
+	 AML_OFFSET(irq.flags),
+	 3},
+
+	{ACPI_RSC_1BITFLAG, ACPI_RS_OFFSET(data.irq.sharable),
+	 AML_OFFSET(irq.flags),
+	 4}
+};
+
+/*******************************************************************************
+ *
+ * acpi_rs_set_irq
+ *
+ ******************************************************************************/
+
+struct acpi_rsconvert_info acpi_rs_set_irq[13] = {
+	/* Start with a default descriptor of length 3 */
+
+	{ACPI_RSC_INITSET, ACPI_RESOURCE_NAME_IRQ,
+	 sizeof(struct aml_resource_irq),
+	 ACPI_RSC_TABLE_SIZE(acpi_rs_set_irq)},
+
+	/* Convert interrupt list to 16-bit IRQ bitmask */
+
+	{ACPI_RSC_BITMASK16, ACPI_RS_OFFSET(data.irq.interrupts[0]),
+	 AML_OFFSET(irq.irq_mask),
+	 ACPI_RS_OFFSET(data.irq.interrupt_count)},
+
+	/* Set the flags byte */
+
+	{ACPI_RSC_1BITFLAG, ACPI_RS_OFFSET(data.irq.triggering),
+	 AML_OFFSET(irq.flags),
+	 0},
+
+	{ACPI_RSC_1BITFLAG, ACPI_RS_OFFSET(data.irq.polarity),
+	 AML_OFFSET(irq.flags),
+	 3},
+
+	{ACPI_RSC_1BITFLAG, ACPI_RS_OFFSET(data.irq.sharable),
+	 AML_OFFSET(irq.flags),
+	 4},
+
+	/*
+	 * All done if the output descriptor length is required to be 3
+	 * (i.e., optimization to 2 bytes cannot be attempted)
+	 */
+	{ACPI_RSC_EXIT_EQ, ACPI_RSC_COMPARE_VALUE,
+	 ACPI_RS_OFFSET(data.irq.descriptor_length),
+	 3},
+
+	/* Set length to 2 bytes (no flags byte) */
+
+	{ACPI_RSC_LENGTH, 0, 0, sizeof(struct aml_resource_irq_noflags)},
+
+	/*
+	 * All done if the output descriptor length is required to be 2.
+	 *
+	 * TBD: Perhaps we should check for error if input flags are not
+	 * compatible with a 2-byte descriptor.
+	 */
+	{ACPI_RSC_EXIT_EQ, ACPI_RSC_COMPARE_VALUE,
+	 ACPI_RS_OFFSET(data.irq.descriptor_length),
+	 2},
+
+	/* Reset length to 3 bytes (descriptor with flags byte) */
+
+	{ACPI_RSC_LENGTH, 0, 0, sizeof(struct aml_resource_irq)},
+
+	/*
+	 * Check if the flags byte is necessary. Not needed if the flags are:
+	 * ACPI_EDGE_SENSITIVE, ACPI_ACTIVE_HIGH, ACPI_EXCLUSIVE
+	 */
+	{ACPI_RSC_EXIT_NE, ACPI_RSC_COMPARE_VALUE,
+	 ACPI_RS_OFFSET(data.irq.triggering),
+	 ACPI_EDGE_SENSITIVE},
+
+	{ACPI_RSC_EXIT_NE, ACPI_RSC_COMPARE_VALUE,
+	 ACPI_RS_OFFSET(data.irq.polarity),
+	 ACPI_ACTIVE_HIGH},
+
+	{ACPI_RSC_EXIT_NE, ACPI_RSC_COMPARE_VALUE,
+	 ACPI_RS_OFFSET(data.irq.sharable),
+	 ACPI_EXCLUSIVE},
+
+	/* We can optimize to a 2-byte irq_no_flags() descriptor */
+
+	{ACPI_RSC_LENGTH, 0, 0, sizeof(struct aml_resource_irq_noflags)}
+};
+
+/*******************************************************************************
+ *
+ * acpi_rs_convert_ext_irq
+ *
+ ******************************************************************************/
+
+struct acpi_rsconvert_info acpi_rs_convert_ext_irq[9] = {
+	{ACPI_RSC_INITGET, ACPI_RESOURCE_TYPE_EXTENDED_IRQ,
+	 ACPI_RS_SIZE(struct acpi_resource_extended_irq),
+	 ACPI_RSC_TABLE_SIZE(acpi_rs_convert_ext_irq)},
+
+	{ACPI_RSC_INITSET, ACPI_RESOURCE_NAME_EXTENDED_IRQ,
+	 sizeof(struct aml_resource_extended_irq),
+	 0},
+
+	/* Flag bits */
+
+	{ACPI_RSC_1BITFLAG, ACPI_RS_OFFSET(data.extended_irq.producer_consumer),
+	 AML_OFFSET(extended_irq.flags),
+	 0},
+
+	{ACPI_RSC_1BITFLAG, ACPI_RS_OFFSET(data.extended_irq.triggering),
+	 AML_OFFSET(extended_irq.flags),
+	 1},
+
+	{ACPI_RSC_1BITFLAG, ACPI_RS_OFFSET(data.extended_irq.polarity),
+	 AML_OFFSET(extended_irq.flags),
+	 2},
+
+	{ACPI_RSC_1BITFLAG, ACPI_RS_OFFSET(data.extended_irq.sharable),
+	 AML_OFFSET(extended_irq.flags),
+	 3},
+
+	/* IRQ Table length (Byte4) */
+
+	{ACPI_RSC_COUNT, ACPI_RS_OFFSET(data.extended_irq.interrupt_count),
+	 AML_OFFSET(extended_irq.interrupt_count),
+	 sizeof(u32)},
+
+	/* Copy every IRQ in the table, each is 32 bits */
+
+	{ACPI_RSC_MOVE32, ACPI_RS_OFFSET(data.extended_irq.interrupts[0]),
+	 AML_OFFSET(extended_irq.interrupts[0]),
+	 0},
+
+	/* Optional resource_source (Index and String) */
+
+	{ACPI_RSC_SOURCEX, ACPI_RS_OFFSET(data.extended_irq.resource_source),
+	 ACPI_RS_OFFSET(data.extended_irq.interrupts[0]),
+	 sizeof(struct aml_resource_extended_irq)}
+};
+
+/*******************************************************************************
+ *
+ * acpi_rs_convert_dma
+ *
+ ******************************************************************************/
+
+struct acpi_rsconvert_info acpi_rs_convert_dma[6] = {
+	{ACPI_RSC_INITGET, ACPI_RESOURCE_TYPE_DMA,
+	 ACPI_RS_SIZE(struct acpi_resource_dma),
+	 ACPI_RSC_TABLE_SIZE(acpi_rs_convert_dma)},
+
+	{ACPI_RSC_INITSET, ACPI_RESOURCE_NAME_DMA,
+	 sizeof(struct aml_resource_dma),
+	 0},
+
+	/* Flags: transfer preference, bus mastering, channel speed */
+
+	{ACPI_RSC_2BITFLAG, ACPI_RS_OFFSET(data.dma.transfer),
+	 AML_OFFSET(dma.flags),
+	 0},
+
+	{ACPI_RSC_1BITFLAG, ACPI_RS_OFFSET(data.dma.bus_master),
+	 AML_OFFSET(dma.flags),
+	 2},
+
+	{ACPI_RSC_2BITFLAG, ACPI_RS_OFFSET(data.dma.type),
+	 AML_OFFSET(dma.flags),
+	 5},
+
+	/* DMA channel mask bits */
+
+	{ACPI_RSC_BITMASK, ACPI_RS_OFFSET(data.dma.channels[0]),
+	 AML_OFFSET(dma.dma_channel_mask),
+	 ACPI_RS_OFFSET(data.dma.channel_count)}
+};
+
+/*******************************************************************************
+ *
+ * acpi_rs_convert_fixed_dma
+ *
+ ******************************************************************************/
+
+struct acpi_rsconvert_info acpi_rs_convert_fixed_dma[4] = {
+	{ACPI_RSC_INITGET, ACPI_RESOURCE_TYPE_FIXED_DMA,
+	 ACPI_RS_SIZE(struct acpi_resource_fixed_dma),
+	 ACPI_RSC_TABLE_SIZE(acpi_rs_convert_fixed_dma)},
+
+	{ACPI_RSC_INITSET, ACPI_RESOURCE_NAME_FIXED_DMA,
+	 sizeof(struct aml_resource_fixed_dma),
+	 0},
+
+	/*
+	 * These fields are contiguous in both the source and destination:
+	 * request_lines
+	 * Channels
+	 */
+
+	{ACPI_RSC_MOVE16, ACPI_RS_OFFSET(data.fixed_dma.request_lines),
+	 AML_OFFSET(fixed_dma.request_lines),
+	 2},
+
+	{ACPI_RSC_MOVE8, ACPI_RS_OFFSET(data.fixed_dma.width),
+	 AML_OFFSET(fixed_dma.width),
+	 1},
+
+};
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/rslist.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/rslist.c
new file mode 100644
index 00000000..e5521faf
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/rslist.c
@@ -0,0 +1,250 @@
+/*******************************************************************************
+ *
+ * Module Name: rslist - Linked list utilities
+ *
+ ******************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acresrc.h"
+
+#define _COMPONENT          ACPI_RESOURCES
+ACPI_MODULE_NAME("rslist")
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_rs_convert_aml_to_resources
+ *
+ * PARAMETERS:  acpi_walk_aml_callback
+ *              resource_ptr            - Pointer to the buffer that will
+ *                                        contain the output structures
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Convert an AML resource to an internal representation of the
+ *              resource that is aligned and easier to access.
+ *
+ ******************************************************************************/
+acpi_status
+acpi_rs_convert_aml_to_resources(u8 *aml,
+				 u32 length,
+				 u32 offset, u8 resource_index, void *context)
+{
+	struct acpi_resource **resource_ptr =
+	    ACPI_CAST_INDIRECT_PTR(struct acpi_resource, context);
+	struct acpi_resource *resource;
+	union aml_resource *aml_resource;
+	struct acpi_rsconvert_info *conversion_table;
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(rs_convert_aml_to_resources);
+
+	/*
+	 * Check that the input buffer and all subsequent pointers into it
+	 * are aligned on a native word boundary. Most important on IA64
+	 */
+	resource = *resource_ptr;
+	if (ACPI_IS_MISALIGNED(resource)) {
+		ACPI_WARNING((AE_INFO,
+			      "Misaligned resource pointer %p", resource));
+	}
+
+	/* Get the appropriate conversion info table */
+
+	aml_resource = ACPI_CAST_PTR(union aml_resource, aml);
+	if (acpi_ut_get_resource_type(aml) == ACPI_RESOURCE_NAME_SERIAL_BUS) {
+		if (aml_resource->common_serial_bus.type >
+		    AML_RESOURCE_MAX_SERIALBUSTYPE) {
+			conversion_table = NULL;
+		} else {
+			/* This is an I2C, SPI, or UART serial_bus descriptor */
+
+			conversion_table =
+			    acpi_gbl_convert_resource_serial_bus_dispatch
+			    [aml_resource->common_serial_bus.type];
+		}
+	} else {
+		conversion_table =
+		    acpi_gbl_get_resource_dispatch[resource_index];
+	}
+
+	if (!conversion_table) {
+		ACPI_ERROR((AE_INFO,
+			    "Invalid/unsupported resource descriptor: Type 0x%2.2X",
+			    resource_index));
+		return (AE_AML_INVALID_RESOURCE_TYPE);
+	}
+
+	/* Convert the AML byte stream resource to a local resource struct */
+
+	status =
+	    acpi_rs_convert_aml_to_resource(resource, aml_resource,
+					    conversion_table);
+	if (ACPI_FAILURE(status)) {
+		ACPI_EXCEPTION((AE_INFO, status,
+				"Could not convert AML resource (Type 0x%X)",
+				*aml));
+		return_ACPI_STATUS(status);
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_RESOURCES,
+			  "Type %.2X, AmlLength %.2X InternalLength %.2X\n",
+			  acpi_ut_get_resource_type(aml), length,
+			  resource->length));
+
+	/* Point to the next structure in the output buffer */
+
+	*resource_ptr = ACPI_NEXT_RESOURCE(resource);
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_rs_convert_resources_to_aml
+ *
+ * PARAMETERS:  Resource            - Pointer to the resource linked list
+ *              aml_size_needed     - Calculated size of the byte stream
+ *                                    needed from calling acpi_rs_get_aml_length()
+ *                                    The size of the output_buffer is
+ *                                    guaranteed to be >= aml_size_needed
+ *              output_buffer       - Pointer to the buffer that will
+ *                                    contain the byte stream
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Takes the resource linked list and parses it, creating a
+ *              byte stream of resources in the caller's output buffer
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_rs_convert_resources_to_aml(struct acpi_resource *resource,
+				 acpi_size aml_size_needed, u8 *output_buffer)
+{
+	u8 *aml = output_buffer;
+	u8 *end_aml = output_buffer + aml_size_needed;
+	struct acpi_rsconvert_info *conversion_table;
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(rs_convert_resources_to_aml);
+
+	/* Walk the resource descriptor list, convert each descriptor */
+
+	while (aml < end_aml) {
+
+		/* Validate the (internal) Resource Type */
+
+		if (resource->type > ACPI_RESOURCE_TYPE_MAX) {
+			ACPI_ERROR((AE_INFO,
+				    "Invalid descriptor type (0x%X) in resource list",
+				    resource->type));
+			return_ACPI_STATUS(AE_BAD_DATA);
+		}
+
+		/* Perform the conversion */
+
+		if (resource->type == ACPI_RESOURCE_TYPE_SERIAL_BUS) {
+			if (resource->data.common_serial_bus.type >
+			    AML_RESOURCE_MAX_SERIALBUSTYPE) {
+				conversion_table = NULL;
+			} else {
+				/* This is an I2C, SPI, or UART serial_bus descriptor */
+
+				conversion_table =
+				    acpi_gbl_convert_resource_serial_bus_dispatch
+				    [resource->data.common_serial_bus.type];
+			}
+		} else {
+			conversion_table =
+			    acpi_gbl_set_resource_dispatch[resource->type];
+		}
+
+		if (!conversion_table) {
+			ACPI_ERROR((AE_INFO,
+				    "Invalid/unsupported resource descriptor: Type 0x%2.2X",
+				    resource->type));
+			return (AE_AML_INVALID_RESOURCE_TYPE);
+		}
+
+		status = acpi_rs_convert_resource_to_aml(resource,
+							 ACPI_CAST_PTR(union
+								       aml_resource,
+								       aml),
+							 conversion_table);
+		if (ACPI_FAILURE(status)) {
+			ACPI_EXCEPTION((AE_INFO, status,
+					"Could not convert resource (type 0x%X) to AML",
+					resource->type));
+			return_ACPI_STATUS(status);
+		}
+
+		/* Perform final sanity check on the new AML resource descriptor */
+
+		status =
+		    acpi_ut_validate_resource(ACPI_CAST_PTR
+					      (union aml_resource, aml), NULL);
+		if (ACPI_FAILURE(status)) {
+			return_ACPI_STATUS(status);
+		}
+
+		/* Check for end-of-list, normal exit */
+
+		if (resource->type == ACPI_RESOURCE_TYPE_END_TAG) {
+
+			/* An End Tag indicates the end of the input Resource Template */
+
+			return_ACPI_STATUS(AE_OK);
+		}
+
+		/*
+		 * Extract the total length of the new descriptor and set the
+		 * Aml to point to the next (output) resource descriptor
+		 */
+		aml += acpi_ut_get_descriptor_length(aml);
+
+		/* Point to the next input resource descriptor */
+
+		resource = ACPI_NEXT_RESOURCE(resource);
+	}
+
+	/* Completed buffer, but did not find an end_tag resource descriptor */
+
+	return_ACPI_STATUS(AE_AML_NO_RESOURCE_END_TAG);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/rsmemory.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/rsmemory.c
new file mode 100644
index 00000000..d446103a
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/rsmemory.c
@@ -0,0 +1,234 @@
+/*******************************************************************************
+ *
+ * Module Name: rsmem24 - Memory resource descriptors
+ *
+ ******************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acresrc.h"
+
+#define _COMPONENT          ACPI_RESOURCES
+ACPI_MODULE_NAME("rsmemory")
+
+/*******************************************************************************
+ *
+ * acpi_rs_convert_memory24
+ *
+ ******************************************************************************/
+struct acpi_rsconvert_info acpi_rs_convert_memory24[4] = {
+	{ACPI_RSC_INITGET, ACPI_RESOURCE_TYPE_MEMORY24,
+	 ACPI_RS_SIZE(struct acpi_resource_memory24),
+	 ACPI_RSC_TABLE_SIZE(acpi_rs_convert_memory24)},
+
+	{ACPI_RSC_INITSET, ACPI_RESOURCE_NAME_MEMORY24,
+	 sizeof(struct aml_resource_memory24),
+	 0},
+
+	/* Read/Write bit */
+
+	{ACPI_RSC_1BITFLAG, ACPI_RS_OFFSET(data.memory24.write_protect),
+	 AML_OFFSET(memory24.flags),
+	 0},
+	/*
+	 * These fields are contiguous in both the source and destination:
+	 * Minimum Base Address
+	 * Maximum Base Address
+	 * Address Base Alignment
+	 * Range Length
+	 */
+	{ACPI_RSC_MOVE16, ACPI_RS_OFFSET(data.memory24.minimum),
+	 AML_OFFSET(memory24.minimum),
+	 4}
+};
+
+/*******************************************************************************
+ *
+ * acpi_rs_convert_memory32
+ *
+ ******************************************************************************/
+
+struct acpi_rsconvert_info acpi_rs_convert_memory32[4] = {
+	{ACPI_RSC_INITGET, ACPI_RESOURCE_TYPE_MEMORY32,
+	 ACPI_RS_SIZE(struct acpi_resource_memory32),
+	 ACPI_RSC_TABLE_SIZE(acpi_rs_convert_memory32)},
+
+	{ACPI_RSC_INITSET, ACPI_RESOURCE_NAME_MEMORY32,
+	 sizeof(struct aml_resource_memory32),
+	 0},
+
+	/* Read/Write bit */
+
+	{ACPI_RSC_1BITFLAG, ACPI_RS_OFFSET(data.memory32.write_protect),
+	 AML_OFFSET(memory32.flags),
+	 0},
+	/*
+	 * These fields are contiguous in both the source and destination:
+	 * Minimum Base Address
+	 * Maximum Base Address
+	 * Address Base Alignment
+	 * Range Length
+	 */
+	{ACPI_RSC_MOVE32, ACPI_RS_OFFSET(data.memory32.minimum),
+	 AML_OFFSET(memory32.minimum),
+	 4}
+};
+
+/*******************************************************************************
+ *
+ * acpi_rs_convert_fixed_memory32
+ *
+ ******************************************************************************/
+
+struct acpi_rsconvert_info acpi_rs_convert_fixed_memory32[4] = {
+	{ACPI_RSC_INITGET, ACPI_RESOURCE_TYPE_FIXED_MEMORY32,
+	 ACPI_RS_SIZE(struct acpi_resource_fixed_memory32),
+	 ACPI_RSC_TABLE_SIZE(acpi_rs_convert_fixed_memory32)},
+
+	{ACPI_RSC_INITSET, ACPI_RESOURCE_NAME_FIXED_MEMORY32,
+	 sizeof(struct aml_resource_fixed_memory32),
+	 0},
+
+	/* Read/Write bit */
+
+	{ACPI_RSC_1BITFLAG, ACPI_RS_OFFSET(data.fixed_memory32.write_protect),
+	 AML_OFFSET(fixed_memory32.flags),
+	 0},
+	/*
+	 * These fields are contiguous in both the source and destination:
+	 * Base Address
+	 * Range Length
+	 */
+	{ACPI_RSC_MOVE32, ACPI_RS_OFFSET(data.fixed_memory32.address),
+	 AML_OFFSET(fixed_memory32.address),
+	 2}
+};
+
+/*******************************************************************************
+ *
+ * acpi_rs_get_vendor_small
+ *
+ ******************************************************************************/
+
+struct acpi_rsconvert_info acpi_rs_get_vendor_small[3] = {
+	{ACPI_RSC_INITGET, ACPI_RESOURCE_TYPE_VENDOR,
+	 ACPI_RS_SIZE(struct acpi_resource_vendor),
+	 ACPI_RSC_TABLE_SIZE(acpi_rs_get_vendor_small)},
+
+	/* Length of the vendor data (byte count) */
+
+	{ACPI_RSC_COUNT16, ACPI_RS_OFFSET(data.vendor.byte_length),
+	 0,
+	 sizeof(u8)},
+
+	/* Vendor data */
+
+	{ACPI_RSC_MOVE8, ACPI_RS_OFFSET(data.vendor.byte_data[0]),
+	 sizeof(struct aml_resource_small_header),
+	 0}
+};
+
+/*******************************************************************************
+ *
+ * acpi_rs_get_vendor_large
+ *
+ ******************************************************************************/
+
+struct acpi_rsconvert_info acpi_rs_get_vendor_large[3] = {
+	{ACPI_RSC_INITGET, ACPI_RESOURCE_TYPE_VENDOR,
+	 ACPI_RS_SIZE(struct acpi_resource_vendor),
+	 ACPI_RSC_TABLE_SIZE(acpi_rs_get_vendor_large)},
+
+	/* Length of the vendor data (byte count) */
+
+	{ACPI_RSC_COUNT16, ACPI_RS_OFFSET(data.vendor.byte_length),
+	 0,
+	 sizeof(u8)},
+
+	/* Vendor data */
+
+	{ACPI_RSC_MOVE8, ACPI_RS_OFFSET(data.vendor.byte_data[0]),
+	 sizeof(struct aml_resource_large_header),
+	 0}
+};
+
+/*******************************************************************************
+ *
+ * acpi_rs_set_vendor
+ *
+ ******************************************************************************/
+
+struct acpi_rsconvert_info acpi_rs_set_vendor[7] = {
+	/* Default is a small vendor descriptor */
+
+	{ACPI_RSC_INITSET, ACPI_RESOURCE_NAME_VENDOR_SMALL,
+	 sizeof(struct aml_resource_small_header),
+	 ACPI_RSC_TABLE_SIZE(acpi_rs_set_vendor)},
+
+	/* Get the length and copy the data */
+
+	{ACPI_RSC_COUNT16, ACPI_RS_OFFSET(data.vendor.byte_length),
+	 0,
+	 0},
+
+	{ACPI_RSC_MOVE8, ACPI_RS_OFFSET(data.vendor.byte_data[0]),
+	 sizeof(struct aml_resource_small_header),
+	 0},
+
+	/*
+	 * All done if the Vendor byte length is 7 or less, meaning that it will
+	 * fit within a small descriptor
+	 */
+	{ACPI_RSC_EXIT_LE, 0, 0, 7},
+
+	/* Must create a large vendor descriptor */
+
+	{ACPI_RSC_INITSET, ACPI_RESOURCE_NAME_VENDOR_LARGE,
+	 sizeof(struct aml_resource_large_header),
+	 0},
+
+	{ACPI_RSC_COUNT16, ACPI_RS_OFFSET(data.vendor.byte_length),
+	 0,
+	 0},
+
+	{ACPI_RSC_MOVE8, ACPI_RS_OFFSET(data.vendor.byte_data[0]),
+	 sizeof(struct aml_resource_large_header),
+	 0}
+};
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/rsmisc.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/rsmisc.c
new file mode 100644
index 00000000..3c324bcc
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/rsmisc.c
@@ -0,0 +1,820 @@
+/*******************************************************************************
+ *
+ * Module Name: rsmisc - Miscellaneous resource descriptors
+ *
+ ******************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acresrc.h"
+
+#define _COMPONENT          ACPI_RESOURCES
+ACPI_MODULE_NAME("rsmisc")
+
+#define INIT_RESOURCE_TYPE(i)       i->resource_offset
+#define INIT_RESOURCE_LENGTH(i)     i->aml_offset
+#define INIT_TABLE_LENGTH(i)        i->value
+#define COMPARE_OPCODE(i)           i->resource_offset
+#define COMPARE_TARGET(i)           i->aml_offset
+#define COMPARE_VALUE(i)            i->value
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_rs_convert_aml_to_resource
+ *
+ * PARAMETERS:  Resource            - Pointer to the resource descriptor
+ *              Aml                 - Where the AML descriptor is returned
+ *              Info                - Pointer to appropriate conversion table
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Convert an external AML resource descriptor to the corresponding
+ *              internal resource descriptor
+ *
+ ******************************************************************************/
+acpi_status
+acpi_rs_convert_aml_to_resource(struct acpi_resource *resource,
+				union aml_resource *aml,
+				struct acpi_rsconvert_info *info)
+{
+	acpi_rs_length aml_resource_length;
+	void *source;
+	void *destination;
+	char *target;
+	u8 count;
+	u8 flags_mode = FALSE;
+	u16 item_count = 0;
+	u16 temp16 = 0;
+
+	ACPI_FUNCTION_TRACE(rs_convert_aml_to_resource);
+
+	if (!info) {
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	if (((acpi_size) resource) & 0x3) {
+
+		/* Each internal resource struct is expected to be 32-bit aligned */
+
+		ACPI_WARNING((AE_INFO,
+			      "Misaligned resource pointer (get): %p Type 0x%2.2X Length %u",
+			      resource, resource->type, resource->length));
+	}
+
+	/* Extract the resource Length field (does not include header length) */
+
+	aml_resource_length = acpi_ut_get_resource_length(aml);
+
+	/*
+	 * First table entry must be ACPI_RSC_INITxxx and must contain the
+	 * table length (# of table entries)
+	 */
+	count = INIT_TABLE_LENGTH(info);
+	while (count) {
+		/*
+		 * Source is the external AML byte stream buffer,
+		 * destination is the internal resource descriptor
+		 */
+		source = ACPI_ADD_PTR(void, aml, info->aml_offset);
+		destination =
+		    ACPI_ADD_PTR(void, resource, info->resource_offset);
+
+		switch (info->opcode) {
+		case ACPI_RSC_INITGET:
+			/*
+			 * Get the resource type and the initial (minimum) length
+			 */
+			ACPI_MEMSET(resource, 0, INIT_RESOURCE_LENGTH(info));
+			resource->type = INIT_RESOURCE_TYPE(info);
+			resource->length = INIT_RESOURCE_LENGTH(info);
+			break;
+
+		case ACPI_RSC_INITSET:
+			break;
+
+		case ACPI_RSC_FLAGINIT:
+
+			flags_mode = TRUE;
+			break;
+
+		case ACPI_RSC_1BITFLAG:
+			/*
+			 * Mask and shift the flag bit
+			 */
+			ACPI_SET8(destination) = (u8)
+			    ((ACPI_GET8(source) >> info->value) & 0x01);
+			break;
+
+		case ACPI_RSC_2BITFLAG:
+			/*
+			 * Mask and shift the flag bits
+			 */
+			ACPI_SET8(destination) = (u8)
+			    ((ACPI_GET8(source) >> info->value) & 0x03);
+			break;
+
+		case ACPI_RSC_3BITFLAG:
+			/*
+			 * Mask and shift the flag bits
+			 */
+			ACPI_SET8(destination) = (u8)
+			    ((ACPI_GET8(source) >> info->value) & 0x07);
+			break;
+
+		case ACPI_RSC_COUNT:
+
+			item_count = ACPI_GET8(source);
+			ACPI_SET8(destination) = (u8)item_count;
+
+			resource->length = resource->length +
+			    (info->value * (item_count - 1));
+			break;
+
+		case ACPI_RSC_COUNT16:
+
+			item_count = aml_resource_length;
+			ACPI_SET16(destination) = item_count;
+
+			resource->length = resource->length +
+			    (info->value * (item_count - 1));
+			break;
+
+		case ACPI_RSC_COUNT_GPIO_PIN:
+
+			target = ACPI_ADD_PTR(void, aml, info->value);
+			item_count = ACPI_GET16(target) - ACPI_GET16(source);
+
+			resource->length = resource->length + item_count;
+			item_count = item_count / 2;
+			ACPI_SET16(destination) = item_count;
+			break;
+
+		case ACPI_RSC_COUNT_GPIO_VEN:
+
+			item_count = ACPI_GET8(source);
+			ACPI_SET8(destination) = (u8)item_count;
+
+			resource->length = resource->length +
+			    (info->value * item_count);
+			break;
+
+		case ACPI_RSC_COUNT_GPIO_RES:
+
+			/*
+			 * Vendor data is optional (length/offset may both be zero)
+			 * Examine vendor data length field first
+			 */
+			target = ACPI_ADD_PTR(void, aml, (info->value + 2));
+			if (ACPI_GET16(target)) {
+
+				/* Use vendor offset to get resource source length */
+
+				target = ACPI_ADD_PTR(void, aml, info->value);
+				item_count =
+				    ACPI_GET16(target) - ACPI_GET16(source);
+			} else {
+				/* No vendor data to worry about */
+
+				item_count = aml->large_header.resource_length +
+				    sizeof(struct aml_resource_large_header) -
+				    ACPI_GET16(source);
+			}
+
+			resource->length = resource->length + item_count;
+			ACPI_SET16(destination) = item_count;
+			break;
+
+		case ACPI_RSC_COUNT_SERIAL_VEN:
+
+			item_count = ACPI_GET16(source) - info->value;
+
+			resource->length = resource->length + item_count;
+			ACPI_SET16(destination) = item_count;
+			break;
+
+		case ACPI_RSC_COUNT_SERIAL_RES:
+
+			item_count = (aml_resource_length +
+				      sizeof(struct aml_resource_large_header))
+			    - ACPI_GET16(source) - info->value;
+
+			resource->length = resource->length + item_count;
+			ACPI_SET16(destination) = item_count;
+			break;
+
+		case ACPI_RSC_LENGTH:
+
+			resource->length = resource->length + info->value;
+			break;
+
+		case ACPI_RSC_MOVE8:
+		case ACPI_RSC_MOVE16:
+		case ACPI_RSC_MOVE32:
+		case ACPI_RSC_MOVE64:
+			/*
+			 * Raw data move. Use the Info value field unless item_count has
+			 * been previously initialized via a COUNT opcode
+			 */
+			if (info->value) {
+				item_count = info->value;
+			}
+			acpi_rs_move_data(destination, source, item_count,
+					  info->opcode);
+			break;
+
+		case ACPI_RSC_MOVE_GPIO_PIN:
+
+			/* Generate and set the PIN data pointer */
+
+			target = (char *)ACPI_ADD_PTR(void, resource,
+						      (resource->length -
+						       item_count * 2));
+			*(u16 **)destination = ACPI_CAST_PTR(u16, target);
+
+			/* Copy the PIN data */
+
+			source = ACPI_ADD_PTR(void, aml, ACPI_GET16(source));
+			acpi_rs_move_data(target, source, item_count,
+					  info->opcode);
+			break;
+
+		case ACPI_RSC_MOVE_GPIO_RES:
+
+			/* Generate and set the resource_source string pointer */
+
+			target = (char *)ACPI_ADD_PTR(void, resource,
+						      (resource->length -
+						       item_count));
+			*(u8 **)destination = ACPI_CAST_PTR(u8, target);
+
+			/* Copy the resource_source string */
+
+			source = ACPI_ADD_PTR(void, aml, ACPI_GET16(source));
+			acpi_rs_move_data(target, source, item_count,
+					  info->opcode);
+			break;
+
+		case ACPI_RSC_MOVE_SERIAL_VEN:
+
+			/* Generate and set the Vendor Data pointer */
+
+			target = (char *)ACPI_ADD_PTR(void, resource,
+						      (resource->length -
+						       item_count));
+			*(u8 **)destination = ACPI_CAST_PTR(u8, target);
+
+			/* Copy the Vendor Data */
+
+			source = ACPI_ADD_PTR(void, aml, info->value);
+			acpi_rs_move_data(target, source, item_count,
+					  info->opcode);
+			break;
+
+		case ACPI_RSC_MOVE_SERIAL_RES:
+
+			/* Generate and set the resource_source string pointer */
+
+			target = (char *)ACPI_ADD_PTR(void, resource,
+						      (resource->length -
+						       item_count));
+			*(u8 **)destination = ACPI_CAST_PTR(u8, target);
+
+			/* Copy the resource_source string */
+
+			source =
+			    ACPI_ADD_PTR(void, aml,
+					 (ACPI_GET16(source) + info->value));
+			acpi_rs_move_data(target, source, item_count,
+					  info->opcode);
+			break;
+
+		case ACPI_RSC_SET8:
+
+			ACPI_MEMSET(destination, info->aml_offset, info->value);
+			break;
+
+		case ACPI_RSC_DATA8:
+
+			target = ACPI_ADD_PTR(char, resource, info->value);
+			ACPI_MEMCPY(destination, source, ACPI_GET16(target));
+			break;
+
+		case ACPI_RSC_ADDRESS:
+			/*
+			 * Common handler for address descriptor flags
+			 */
+			if (!acpi_rs_get_address_common(resource, aml)) {
+				return_ACPI_STATUS
+				    (AE_AML_INVALID_RESOURCE_TYPE);
+			}
+			break;
+
+		case ACPI_RSC_SOURCE:
+			/*
+			 * Optional resource_source (Index and String)
+			 */
+			resource->length +=
+			    acpi_rs_get_resource_source(aml_resource_length,
+							info->value,
+							destination, aml, NULL);
+			break;
+
+		case ACPI_RSC_SOURCEX:
+			/*
+			 * Optional resource_source (Index and String). This is the more
+			 * complicated case used by the Interrupt() macro
+			 */
+			target = ACPI_ADD_PTR(char, resource,
+					      info->aml_offset +
+					      (item_count * 4));
+
+			resource->length +=
+			    acpi_rs_get_resource_source(aml_resource_length,
+							(acpi_rs_length)
+							(((item_count -
+							   1) * sizeof(u32)) +
+							 info->value),
+							destination, aml,
+							target);
+			break;
+
+		case ACPI_RSC_BITMASK:
+			/*
+			 * 8-bit encoded bitmask (DMA macro)
+			 */
+			item_count =
+			    acpi_rs_decode_bitmask(ACPI_GET8(source),
+						   destination);
+			if (item_count) {
+				resource->length += (item_count - 1);
+			}
+
+			target = ACPI_ADD_PTR(char, resource, info->value);
+			ACPI_SET8(target) = (u8)item_count;
+			break;
+
+		case ACPI_RSC_BITMASK16:
+			/*
+			 * 16-bit encoded bitmask (IRQ macro)
+			 */
+			ACPI_MOVE_16_TO_16(&temp16, source);
+
+			item_count =
+			    acpi_rs_decode_bitmask(temp16, destination);
+			if (item_count) {
+				resource->length += (item_count - 1);
+			}
+
+			target = ACPI_ADD_PTR(char, resource, info->value);
+			ACPI_SET8(target) = (u8)item_count;
+			break;
+
+		case ACPI_RSC_EXIT_NE:
+			/*
+			 * Control - Exit conversion if not equal
+			 */
+			switch (info->resource_offset) {
+			case ACPI_RSC_COMPARE_AML_LENGTH:
+				if (aml_resource_length != info->value) {
+					goto exit;
+				}
+				break;
+
+			case ACPI_RSC_COMPARE_VALUE:
+				if (ACPI_GET8(source) != info->value) {
+					goto exit;
+				}
+				break;
+
+			default:
+
+				ACPI_ERROR((AE_INFO,
+					    "Invalid conversion sub-opcode"));
+				return_ACPI_STATUS(AE_BAD_PARAMETER);
+			}
+			break;
+
+		default:
+
+			ACPI_ERROR((AE_INFO, "Invalid conversion opcode"));
+			return_ACPI_STATUS(AE_BAD_PARAMETER);
+		}
+
+		count--;
+		info++;
+	}
+
+      exit:
+	if (!flags_mode) {
+
+		/* Round the resource struct length up to the next boundary (32 or 64) */
+
+		resource->length =
+		    (u32)ACPI_ROUND_UP_TO_NATIVE_WORD(resource->length);
+	}
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_rs_convert_resource_to_aml
+ *
+ * PARAMETERS:  Resource            - Pointer to the resource descriptor
+ *              Aml                 - Where the AML descriptor is returned
+ *              Info                - Pointer to appropriate conversion table
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Convert an internal resource descriptor to the corresponding
+ *              external AML resource descriptor.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_rs_convert_resource_to_aml(struct acpi_resource *resource,
+				union aml_resource *aml,
+				struct acpi_rsconvert_info *info)
+{
+	void *source = NULL;
+	void *destination;
+	char *target;
+	acpi_rsdesc_size aml_length = 0;
+	u8 count;
+	u16 temp16 = 0;
+	u16 item_count = 0;
+
+	ACPI_FUNCTION_TRACE(rs_convert_resource_to_aml);
+
+	if (!info) {
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	/*
+	 * First table entry must be ACPI_RSC_INITxxx and must contain the
+	 * table length (# of table entries)
+	 */
+	count = INIT_TABLE_LENGTH(info);
+
+	while (count) {
+		/*
+		 * Source is the internal resource descriptor,
+		 * destination is the external AML byte stream buffer
+		 */
+		source = ACPI_ADD_PTR(void, resource, info->resource_offset);
+		destination = ACPI_ADD_PTR(void, aml, info->aml_offset);
+
+		switch (info->opcode) {
+		case ACPI_RSC_INITSET:
+
+			ACPI_MEMSET(aml, 0, INIT_RESOURCE_LENGTH(info));
+			aml_length = INIT_RESOURCE_LENGTH(info);
+			acpi_rs_set_resource_header(INIT_RESOURCE_TYPE(info),
+						    aml_length, aml);
+			break;
+
+		case ACPI_RSC_INITGET:
+			break;
+
+		case ACPI_RSC_FLAGINIT:
+			/*
+			 * Clear the flag byte
+			 */
+			ACPI_SET8(destination) = 0;
+			break;
+
+		case ACPI_RSC_1BITFLAG:
+			/*
+			 * Mask and shift the flag bit
+			 */
+			ACPI_SET8(destination) |= (u8)
+			    ((ACPI_GET8(source) & 0x01) << info->value);
+			break;
+
+		case ACPI_RSC_2BITFLAG:
+			/*
+			 * Mask and shift the flag bits
+			 */
+			ACPI_SET8(destination) |= (u8)
+			    ((ACPI_GET8(source) & 0x03) << info->value);
+			break;
+
+		case ACPI_RSC_3BITFLAG:
+			/*
+			 * Mask and shift the flag bits
+			 */
+			ACPI_SET8(destination) |= (u8)
+			    ((ACPI_GET8(source) & 0x07) << info->value);
+			break;
+
+		case ACPI_RSC_COUNT:
+
+			item_count = ACPI_GET8(source);
+			ACPI_SET8(destination) = (u8)item_count;
+
+			aml_length =
+			    (u16)(aml_length +
+				  (info->value * (item_count - 1)));
+			break;
+
+		case ACPI_RSC_COUNT16:
+
+			item_count = ACPI_GET16(source);
+			aml_length = (u16)(aml_length + item_count);
+			acpi_rs_set_resource_length(aml_length, aml);
+			break;
+
+		case ACPI_RSC_COUNT_GPIO_PIN:
+
+			item_count = ACPI_GET16(source);
+			ACPI_SET16(destination) = (u16)aml_length;
+
+			aml_length = (u16)(aml_length + item_count * 2);
+			target = ACPI_ADD_PTR(void, aml, info->value);
+			ACPI_SET16(target) = (u16)aml_length;
+			acpi_rs_set_resource_length(aml_length, aml);
+			break;
+
+		case ACPI_RSC_COUNT_GPIO_VEN:
+
+			item_count = ACPI_GET16(source);
+			ACPI_SET16(destination) = (u16)item_count;
+
+			aml_length =
+			    (u16)(aml_length + (info->value * item_count));
+			acpi_rs_set_resource_length(aml_length, aml);
+			break;
+
+		case ACPI_RSC_COUNT_GPIO_RES:
+
+			/* Set resource source string length */
+
+			item_count = ACPI_GET16(source);
+			ACPI_SET16(destination) = (u16)aml_length;
+
+			/* Compute offset for the Vendor Data */
+
+			aml_length = (u16)(aml_length + item_count);
+			target = ACPI_ADD_PTR(void, aml, info->value);
+
+			/* Set vendor offset only if there is vendor data */
+
+			if (resource->data.gpio.vendor_length) {
+				ACPI_SET16(target) = (u16)aml_length;
+			}
+
+			acpi_rs_set_resource_length(aml_length, aml);
+			break;
+
+		case ACPI_RSC_COUNT_SERIAL_VEN:
+
+			item_count = ACPI_GET16(source);
+			ACPI_SET16(destination) = item_count + info->value;
+			aml_length = (u16)(aml_length + item_count);
+			acpi_rs_set_resource_length(aml_length, aml);
+			break;
+
+		case ACPI_RSC_COUNT_SERIAL_RES:
+
+			item_count = ACPI_GET16(source);
+			aml_length = (u16)(aml_length + item_count);
+			acpi_rs_set_resource_length(aml_length, aml);
+			break;
+
+		case ACPI_RSC_LENGTH:
+
+			acpi_rs_set_resource_length(info->value, aml);
+			break;
+
+		case ACPI_RSC_MOVE8:
+		case ACPI_RSC_MOVE16:
+		case ACPI_RSC_MOVE32:
+		case ACPI_RSC_MOVE64:
+
+			if (info->value) {
+				item_count = info->value;
+			}
+			acpi_rs_move_data(destination, source, item_count,
+					  info->opcode);
+			break;
+
+		case ACPI_RSC_MOVE_GPIO_PIN:
+
+			destination = (char *)ACPI_ADD_PTR(void, aml,
+							   ACPI_GET16
+							   (destination));
+			source = *(u16 **)source;
+			acpi_rs_move_data(destination, source, item_count,
+					  info->opcode);
+			break;
+
+		case ACPI_RSC_MOVE_GPIO_RES:
+
+			/* Used for both resource_source string and vendor_data */
+
+			destination = (char *)ACPI_ADD_PTR(void, aml,
+							   ACPI_GET16
+							   (destination));
+			source = *(u8 **)source;
+			acpi_rs_move_data(destination, source, item_count,
+					  info->opcode);
+			break;
+
+		case ACPI_RSC_MOVE_SERIAL_VEN:
+
+			destination = (char *)ACPI_ADD_PTR(void, aml,
+							   (aml_length -
+							    item_count));
+			source = *(u8 **)source;
+			acpi_rs_move_data(destination, source, item_count,
+					  info->opcode);
+			break;
+
+		case ACPI_RSC_MOVE_SERIAL_RES:
+
+			destination = (char *)ACPI_ADD_PTR(void, aml,
+							   (aml_length -
+							    item_count));
+			source = *(u8 **)source;
+			acpi_rs_move_data(destination, source, item_count,
+					  info->opcode);
+			break;
+
+		case ACPI_RSC_ADDRESS:
+
+			/* Set the Resource Type, General Flags, and Type-Specific Flags */
+
+			acpi_rs_set_address_common(aml, resource);
+			break;
+
+		case ACPI_RSC_SOURCEX:
+			/*
+			 * Optional resource_source (Index and String)
+			 */
+			aml_length =
+			    acpi_rs_set_resource_source(aml,
+							(acpi_rs_length)
+							aml_length, source);
+			acpi_rs_set_resource_length(aml_length, aml);
+			break;
+
+		case ACPI_RSC_SOURCE:
+			/*
+			 * Optional resource_source (Index and String). This is the more
+			 * complicated case used by the Interrupt() macro
+			 */
+			aml_length =
+			    acpi_rs_set_resource_source(aml, info->value,
+							source);
+			acpi_rs_set_resource_length(aml_length, aml);
+			break;
+
+		case ACPI_RSC_BITMASK:
+			/*
+			 * 8-bit encoded bitmask (DMA macro)
+			 */
+			ACPI_SET8(destination) = (u8)
+			    acpi_rs_encode_bitmask(source,
+						   *ACPI_ADD_PTR(u8, resource,
+								 info->value));
+			break;
+
+		case ACPI_RSC_BITMASK16:
+			/*
+			 * 16-bit encoded bitmask (IRQ macro)
+			 */
+			temp16 = acpi_rs_encode_bitmask(source,
+							*ACPI_ADD_PTR(u8,
+								      resource,
+								      info->
+								      value));
+			ACPI_MOVE_16_TO_16(destination, &temp16);
+			break;
+
+		case ACPI_RSC_EXIT_LE:
+			/*
+			 * Control - Exit conversion if less than or equal
+			 */
+			if (item_count <= info->value) {
+				goto exit;
+			}
+			break;
+
+		case ACPI_RSC_EXIT_NE:
+			/*
+			 * Control - Exit conversion if not equal
+			 */
+			switch (COMPARE_OPCODE(info)) {
+			case ACPI_RSC_COMPARE_VALUE:
+
+				if (*ACPI_ADD_PTR(u8, resource,
+						  COMPARE_TARGET(info)) !=
+				    COMPARE_VALUE(info)) {
+					goto exit;
+				}
+				break;
+
+			default:
+
+				ACPI_ERROR((AE_INFO,
+					    "Invalid conversion sub-opcode"));
+				return_ACPI_STATUS(AE_BAD_PARAMETER);
+			}
+			break;
+
+		case ACPI_RSC_EXIT_EQ:
+			/*
+			 * Control - Exit conversion if equal
+			 */
+			if (*ACPI_ADD_PTR(u8, resource,
+					  COMPARE_TARGET(info)) ==
+			    COMPARE_VALUE(info)) {
+				goto exit;
+			}
+			break;
+
+		default:
+
+			ACPI_ERROR((AE_INFO, "Invalid conversion opcode"));
+			return_ACPI_STATUS(AE_BAD_PARAMETER);
+		}
+
+		count--;
+		info++;
+	}
+
+      exit:
+	return_ACPI_STATUS(AE_OK);
+}
+
+#if 0
+/* Previous resource validations */
+
+if (aml->ext_address64.revision_iD != AML_RESOURCE_EXTENDED_ADDRESS_REVISION) {
+	return_ACPI_STATUS(AE_SUPPORT);
+}
+
+if (resource->data.start_dpf.performance_robustness >= 3) {
+	return_ACPI_STATUS(AE_AML_BAD_RESOURCE_VALUE);
+}
+
+if (((aml->irq.flags & 0x09) == 0x00) || ((aml->irq.flags & 0x09) == 0x09)) {
+	/*
+	 * Only [active_high, edge_sensitive] or [active_low, level_sensitive]
+	 * polarity/trigger interrupts are allowed (ACPI spec, section
+	 * "IRQ Format"), so 0x00 and 0x09 are illegal.
+	 */
+	ACPI_ERROR((AE_INFO,
+		    "Invalid interrupt polarity/trigger in resource list, 0x%X",
+		    aml->irq.flags));
+	return_ACPI_STATUS(AE_BAD_DATA);
+}
+
+resource->data.extended_irq.interrupt_count = temp8;
+if (temp8 < 1) {
+
+	/* Must have at least one IRQ */
+
+	return_ACPI_STATUS(AE_AML_BAD_RESOURCE_LENGTH);
+}
+
+if (resource->data.dma.transfer == 0x03) {
+	ACPI_ERROR((AE_INFO, "Invalid DMA.Transfer preference (3)"));
+	return_ACPI_STATUS(AE_BAD_DATA);
+}
+#endif
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/rsserial.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/rsserial.c
new file mode 100644
index 00000000..9aa5e689
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/rsserial.c
@@ -0,0 +1,441 @@
+/*******************************************************************************
+ *
+ * Module Name: rsserial - GPIO/serial_bus resource descriptors
+ *
+ ******************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acresrc.h"
+
+#define _COMPONENT          ACPI_RESOURCES
+ACPI_MODULE_NAME("rsserial")
+
+/*******************************************************************************
+ *
+ * acpi_rs_convert_gpio
+ *
+ ******************************************************************************/
+struct acpi_rsconvert_info acpi_rs_convert_gpio[17] = {
+	{ACPI_RSC_INITGET, ACPI_RESOURCE_TYPE_GPIO,
+	 ACPI_RS_SIZE(struct acpi_resource_gpio),
+	 ACPI_RSC_TABLE_SIZE(acpi_rs_convert_gpio)},
+
+	{ACPI_RSC_INITSET, ACPI_RESOURCE_NAME_GPIO,
+	 sizeof(struct aml_resource_gpio),
+	 0},
+
+	/*
+	 * These fields are contiguous in both the source and destination:
+	 * revision_id
+	 * connection_type
+	 */
+	{ACPI_RSC_MOVE8, ACPI_RS_OFFSET(data.gpio.revision_id),
+	 AML_OFFSET(gpio.revision_id),
+	 2},
+
+	{ACPI_RSC_1BITFLAG, ACPI_RS_OFFSET(data.gpio.producer_consumer),
+	 AML_OFFSET(gpio.flags),
+	 0},
+
+	{ACPI_RSC_2BITFLAG, ACPI_RS_OFFSET(data.gpio.sharable),
+	 AML_OFFSET(gpio.int_flags),
+	 3},
+
+	{ACPI_RSC_2BITFLAG, ACPI_RS_OFFSET(data.gpio.io_restriction),
+	 AML_OFFSET(gpio.int_flags),
+	 0},
+
+	{ACPI_RSC_1BITFLAG, ACPI_RS_OFFSET(data.gpio.triggering),
+	 AML_OFFSET(gpio.int_flags),
+	 0},
+
+	{ACPI_RSC_2BITFLAG, ACPI_RS_OFFSET(data.gpio.polarity),
+	 AML_OFFSET(gpio.int_flags),
+	 1},
+
+	{ACPI_RSC_MOVE8, ACPI_RS_OFFSET(data.gpio.pin_config),
+	 AML_OFFSET(gpio.pin_config),
+	 1},
+
+	/*
+	 * These fields are contiguous in both the source and destination:
+	 * drive_strength
+	 * debounce_timeout
+	 */
+	{ACPI_RSC_MOVE16, ACPI_RS_OFFSET(data.gpio.drive_strength),
+	 AML_OFFSET(gpio.drive_strength),
+	 2},
+
+	/* Pin Table */
+
+	{ACPI_RSC_COUNT_GPIO_PIN, ACPI_RS_OFFSET(data.gpio.pin_table_length),
+	 AML_OFFSET(gpio.pin_table_offset),
+	 AML_OFFSET(gpio.res_source_offset)},
+
+	{ACPI_RSC_MOVE_GPIO_PIN, ACPI_RS_OFFSET(data.gpio.pin_table),
+	 AML_OFFSET(gpio.pin_table_offset),
+	 0},
+
+	/* Resource Source */
+
+	{ACPI_RSC_MOVE8, ACPI_RS_OFFSET(data.gpio.resource_source.index),
+	 AML_OFFSET(gpio.res_source_index),
+	 1},
+
+	{ACPI_RSC_COUNT_GPIO_RES,
+	 ACPI_RS_OFFSET(data.gpio.resource_source.string_length),
+	 AML_OFFSET(gpio.res_source_offset),
+	 AML_OFFSET(gpio.vendor_offset)},
+
+	{ACPI_RSC_MOVE_GPIO_RES,
+	 ACPI_RS_OFFSET(data.gpio.resource_source.string_ptr),
+	 AML_OFFSET(gpio.res_source_offset),
+	 0},
+
+	/* Vendor Data */
+
+	{ACPI_RSC_COUNT_GPIO_VEN, ACPI_RS_OFFSET(data.gpio.vendor_length),
+	 AML_OFFSET(gpio.vendor_length),
+	 1},
+
+	{ACPI_RSC_MOVE_GPIO_RES, ACPI_RS_OFFSET(data.gpio.vendor_data),
+	 AML_OFFSET(gpio.vendor_offset),
+	 0},
+};
+
+/*******************************************************************************
+ *
+ * acpi_rs_convert_i2c_serial_bus
+ *
+ ******************************************************************************/
+
+struct acpi_rsconvert_info acpi_rs_convert_i2c_serial_bus[16] = {
+	{ACPI_RSC_INITGET, ACPI_RESOURCE_TYPE_SERIAL_BUS,
+	 ACPI_RS_SIZE(struct acpi_resource_i2c_serialbus),
+	 ACPI_RSC_TABLE_SIZE(acpi_rs_convert_i2c_serial_bus)},
+
+	{ACPI_RSC_INITSET, ACPI_RESOURCE_NAME_SERIAL_BUS,
+	 sizeof(struct aml_resource_i2c_serialbus),
+	 0},
+
+	{ACPI_RSC_MOVE8, ACPI_RS_OFFSET(data.common_serial_bus.revision_id),
+	 AML_OFFSET(common_serial_bus.revision_id),
+	 1},
+
+	{ACPI_RSC_MOVE8, ACPI_RS_OFFSET(data.common_serial_bus.type),
+	 AML_OFFSET(common_serial_bus.type),
+	 1},
+
+	{ACPI_RSC_1BITFLAG, ACPI_RS_OFFSET(data.common_serial_bus.slave_mode),
+	 AML_OFFSET(common_serial_bus.flags),
+	 0},
+
+	{ACPI_RSC_1BITFLAG,
+	 ACPI_RS_OFFSET(data.common_serial_bus.producer_consumer),
+	 AML_OFFSET(common_serial_bus.flags),
+	 1},
+
+	{ACPI_RSC_MOVE8,
+	 ACPI_RS_OFFSET(data.common_serial_bus.type_revision_id),
+	 AML_OFFSET(common_serial_bus.type_revision_id),
+	 1},
+
+	{ACPI_RSC_MOVE16,
+	 ACPI_RS_OFFSET(data.common_serial_bus.type_data_length),
+	 AML_OFFSET(common_serial_bus.type_data_length),
+	 1},
+
+	/* Vendor data */
+
+	{ACPI_RSC_COUNT_SERIAL_VEN,
+	 ACPI_RS_OFFSET(data.common_serial_bus.vendor_length),
+	 AML_OFFSET(common_serial_bus.type_data_length),
+	 AML_RESOURCE_I2C_MIN_DATA_LEN},
+
+	{ACPI_RSC_MOVE_SERIAL_VEN,
+	 ACPI_RS_OFFSET(data.common_serial_bus.vendor_data),
+	 0,
+	 sizeof(struct aml_resource_i2c_serialbus)},
+
+	/* Resource Source */
+
+	{ACPI_RSC_MOVE8,
+	 ACPI_RS_OFFSET(data.common_serial_bus.resource_source.index),
+	 AML_OFFSET(common_serial_bus.res_source_index),
+	 1},
+
+	{ACPI_RSC_COUNT_SERIAL_RES,
+	 ACPI_RS_OFFSET(data.common_serial_bus.resource_source.string_length),
+	 AML_OFFSET(common_serial_bus.type_data_length),
+	 sizeof(struct aml_resource_common_serialbus)},
+
+	{ACPI_RSC_MOVE_SERIAL_RES,
+	 ACPI_RS_OFFSET(data.common_serial_bus.resource_source.string_ptr),
+	 AML_OFFSET(common_serial_bus.type_data_length),
+	 sizeof(struct aml_resource_common_serialbus)},
+
+	/* I2C bus type specific */
+
+	{ACPI_RSC_1BITFLAG, ACPI_RS_OFFSET(data.i2c_serial_bus.access_mode),
+	 AML_OFFSET(i2c_serial_bus.type_specific_flags),
+	 0},
+
+	{ACPI_RSC_MOVE32, ACPI_RS_OFFSET(data.i2c_serial_bus.connection_speed),
+	 AML_OFFSET(i2c_serial_bus.connection_speed),
+	 1},
+
+	{ACPI_RSC_MOVE16, ACPI_RS_OFFSET(data.i2c_serial_bus.slave_address),
+	 AML_OFFSET(i2c_serial_bus.slave_address),
+	 1},
+};
+
+/*******************************************************************************
+ *
+ * acpi_rs_convert_spi_serial_bus
+ *
+ ******************************************************************************/
+
+struct acpi_rsconvert_info acpi_rs_convert_spi_serial_bus[20] = {
+	{ACPI_RSC_INITGET, ACPI_RESOURCE_TYPE_SERIAL_BUS,
+	 ACPI_RS_SIZE(struct acpi_resource_spi_serialbus),
+	 ACPI_RSC_TABLE_SIZE(acpi_rs_convert_spi_serial_bus)},
+
+	{ACPI_RSC_INITSET, ACPI_RESOURCE_NAME_SERIAL_BUS,
+	 sizeof(struct aml_resource_spi_serialbus),
+	 0},
+
+	{ACPI_RSC_MOVE8, ACPI_RS_OFFSET(data.common_serial_bus.revision_id),
+	 AML_OFFSET(common_serial_bus.revision_id),
+	 1},
+
+	{ACPI_RSC_MOVE8, ACPI_RS_OFFSET(data.common_serial_bus.type),
+	 AML_OFFSET(common_serial_bus.type),
+	 1},
+
+	{ACPI_RSC_1BITFLAG, ACPI_RS_OFFSET(data.common_serial_bus.slave_mode),
+	 AML_OFFSET(common_serial_bus.flags),
+	 0},
+
+	{ACPI_RSC_1BITFLAG,
+	 ACPI_RS_OFFSET(data.common_serial_bus.producer_consumer),
+	 AML_OFFSET(common_serial_bus.flags),
+	 1},
+
+	{ACPI_RSC_MOVE8,
+	 ACPI_RS_OFFSET(data.common_serial_bus.type_revision_id),
+	 AML_OFFSET(common_serial_bus.type_revision_id),
+	 1},
+
+	{ACPI_RSC_MOVE16,
+	 ACPI_RS_OFFSET(data.common_serial_bus.type_data_length),
+	 AML_OFFSET(common_serial_bus.type_data_length),
+	 1},
+
+	/* Vendor data */
+
+	{ACPI_RSC_COUNT_SERIAL_VEN,
+	 ACPI_RS_OFFSET(data.common_serial_bus.vendor_length),
+	 AML_OFFSET(common_serial_bus.type_data_length),
+	 AML_RESOURCE_SPI_MIN_DATA_LEN},
+
+	{ACPI_RSC_MOVE_SERIAL_VEN,
+	 ACPI_RS_OFFSET(data.common_serial_bus.vendor_data),
+	 0,
+	 sizeof(struct aml_resource_spi_serialbus)},
+
+	/* Resource Source */
+
+	{ACPI_RSC_MOVE8,
+	 ACPI_RS_OFFSET(data.common_serial_bus.resource_source.index),
+	 AML_OFFSET(common_serial_bus.res_source_index),
+	 1},
+
+	{ACPI_RSC_COUNT_SERIAL_RES,
+	 ACPI_RS_OFFSET(data.common_serial_bus.resource_source.string_length),
+	 AML_OFFSET(common_serial_bus.type_data_length),
+	 sizeof(struct aml_resource_common_serialbus)},
+
+	{ACPI_RSC_MOVE_SERIAL_RES,
+	 ACPI_RS_OFFSET(data.common_serial_bus.resource_source.string_ptr),
+	 AML_OFFSET(common_serial_bus.type_data_length),
+	 sizeof(struct aml_resource_common_serialbus)},
+
+	/* Spi bus type specific  */
+
+	{ACPI_RSC_1BITFLAG, ACPI_RS_OFFSET(data.spi_serial_bus.wire_mode),
+	 AML_OFFSET(spi_serial_bus.type_specific_flags),
+	 0},
+
+	{ACPI_RSC_1BITFLAG, ACPI_RS_OFFSET(data.spi_serial_bus.device_polarity),
+	 AML_OFFSET(spi_serial_bus.type_specific_flags),
+	 1},
+
+	{ACPI_RSC_MOVE8, ACPI_RS_OFFSET(data.spi_serial_bus.data_bit_length),
+	 AML_OFFSET(spi_serial_bus.data_bit_length),
+	 1},
+
+	{ACPI_RSC_MOVE8, ACPI_RS_OFFSET(data.spi_serial_bus.clock_phase),
+	 AML_OFFSET(spi_serial_bus.clock_phase),
+	 1},
+
+	{ACPI_RSC_MOVE8, ACPI_RS_OFFSET(data.spi_serial_bus.clock_polarity),
+	 AML_OFFSET(spi_serial_bus.clock_polarity),
+	 1},
+
+	{ACPI_RSC_MOVE16, ACPI_RS_OFFSET(data.spi_serial_bus.device_selection),
+	 AML_OFFSET(spi_serial_bus.device_selection),
+	 1},
+
+	{ACPI_RSC_MOVE32, ACPI_RS_OFFSET(data.spi_serial_bus.connection_speed),
+	 AML_OFFSET(spi_serial_bus.connection_speed),
+	 1},
+};
+
+/*******************************************************************************
+ *
+ * acpi_rs_convert_uart_serial_bus
+ *
+ ******************************************************************************/
+
+struct acpi_rsconvert_info acpi_rs_convert_uart_serial_bus[22] = {
+	{ACPI_RSC_INITGET, ACPI_RESOURCE_TYPE_SERIAL_BUS,
+	 ACPI_RS_SIZE(struct acpi_resource_uart_serialbus),
+	 ACPI_RSC_TABLE_SIZE(acpi_rs_convert_uart_serial_bus)},
+
+	{ACPI_RSC_INITSET, ACPI_RESOURCE_NAME_SERIAL_BUS,
+	 sizeof(struct aml_resource_uart_serialbus),
+	 0},
+
+	{ACPI_RSC_MOVE8, ACPI_RS_OFFSET(data.common_serial_bus.revision_id),
+	 AML_OFFSET(common_serial_bus.revision_id),
+	 1},
+
+	{ACPI_RSC_MOVE8, ACPI_RS_OFFSET(data.common_serial_bus.type),
+	 AML_OFFSET(common_serial_bus.type),
+	 1},
+
+	{ACPI_RSC_1BITFLAG, ACPI_RS_OFFSET(data.common_serial_bus.slave_mode),
+	 AML_OFFSET(common_serial_bus.flags),
+	 0},
+
+	{ACPI_RSC_1BITFLAG,
+	 ACPI_RS_OFFSET(data.common_serial_bus.producer_consumer),
+	 AML_OFFSET(common_serial_bus.flags),
+	 1},
+
+	{ACPI_RSC_MOVE8,
+	 ACPI_RS_OFFSET(data.common_serial_bus.type_revision_id),
+	 AML_OFFSET(common_serial_bus.type_revision_id),
+	 1},
+
+	{ACPI_RSC_MOVE16,
+	 ACPI_RS_OFFSET(data.common_serial_bus.type_data_length),
+	 AML_OFFSET(common_serial_bus.type_data_length),
+	 1},
+
+	/* Vendor data */
+
+	{ACPI_RSC_COUNT_SERIAL_VEN,
+	 ACPI_RS_OFFSET(data.common_serial_bus.vendor_length),
+	 AML_OFFSET(common_serial_bus.type_data_length),
+	 AML_RESOURCE_UART_MIN_DATA_LEN},
+
+	{ACPI_RSC_MOVE_SERIAL_VEN,
+	 ACPI_RS_OFFSET(data.common_serial_bus.vendor_data),
+	 0,
+	 sizeof(struct aml_resource_uart_serialbus)},
+
+	/* Resource Source */
+
+	{ACPI_RSC_MOVE8,
+	 ACPI_RS_OFFSET(data.common_serial_bus.resource_source.index),
+	 AML_OFFSET(common_serial_bus.res_source_index),
+	 1},
+
+	{ACPI_RSC_COUNT_SERIAL_RES,
+	 ACPI_RS_OFFSET(data.common_serial_bus.resource_source.string_length),
+	 AML_OFFSET(common_serial_bus.type_data_length),
+	 sizeof(struct aml_resource_common_serialbus)},
+
+	{ACPI_RSC_MOVE_SERIAL_RES,
+	 ACPI_RS_OFFSET(data.common_serial_bus.resource_source.string_ptr),
+	 AML_OFFSET(common_serial_bus.type_data_length),
+	 sizeof(struct aml_resource_common_serialbus)},
+
+	/* Uart bus type specific  */
+
+	{ACPI_RSC_2BITFLAG, ACPI_RS_OFFSET(data.uart_serial_bus.flow_control),
+	 AML_OFFSET(uart_serial_bus.type_specific_flags),
+	 0},
+
+	{ACPI_RSC_2BITFLAG, ACPI_RS_OFFSET(data.uart_serial_bus.stop_bits),
+	 AML_OFFSET(uart_serial_bus.type_specific_flags),
+	 2},
+
+	{ACPI_RSC_3BITFLAG, ACPI_RS_OFFSET(data.uart_serial_bus.data_bits),
+	 AML_OFFSET(uart_serial_bus.type_specific_flags),
+	 4},
+
+	{ACPI_RSC_1BITFLAG, ACPI_RS_OFFSET(data.uart_serial_bus.endian),
+	 AML_OFFSET(uart_serial_bus.type_specific_flags),
+	 7},
+
+	{ACPI_RSC_MOVE8, ACPI_RS_OFFSET(data.uart_serial_bus.parity),
+	 AML_OFFSET(uart_serial_bus.parity),
+	 1},
+
+	{ACPI_RSC_MOVE8, ACPI_RS_OFFSET(data.uart_serial_bus.lines_enabled),
+	 AML_OFFSET(uart_serial_bus.lines_enabled),
+	 1},
+
+	{ACPI_RSC_MOVE16, ACPI_RS_OFFSET(data.uart_serial_bus.rx_fifo_size),
+	 AML_OFFSET(uart_serial_bus.rx_fifo_size),
+	 1},
+
+	{ACPI_RSC_MOVE16, ACPI_RS_OFFSET(data.uart_serial_bus.tx_fifo_size),
+	 AML_OFFSET(uart_serial_bus.tx_fifo_size),
+	 1},
+
+	{ACPI_RSC_MOVE32,
+	 ACPI_RS_OFFSET(data.uart_serial_bus.default_baud_rate),
+	 AML_OFFSET(uart_serial_bus.default_baud_rate),
+	 1},
+};
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/rsutils.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/rsutils.c
new file mode 100644
index 00000000..5b56035b
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/rsutils.c
@@ -0,0 +1,781 @@
+/*******************************************************************************
+ *
+ * Module Name: rsutils - Utilities for the resource manager
+ *
+ ******************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acnamesp.h"
+#include "acresrc.h"
+
+#define _COMPONENT          ACPI_RESOURCES
+ACPI_MODULE_NAME("rsutils")
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_rs_decode_bitmask
+ *
+ * PARAMETERS:  Mask            - Bitmask to decode
+ *              List            - Where the converted list is returned
+ *
+ * RETURN:      Count of bits set (length of list)
+ *
+ * DESCRIPTION: Convert a bit mask into a list of values
+ *
+ ******************************************************************************/
+u8 acpi_rs_decode_bitmask(u16 mask, u8 *list)
+{
+	u8 i;
+	u8 bit_count;
+
+	ACPI_FUNCTION_ENTRY();
+
+	/* Decode the mask bits */
+
+	for (i = 0, bit_count = 0; mask; i++) {
+		if (mask & 0x0001) {
+			list[bit_count] = i;
+			bit_count++;
+		}
+
+		mask >>= 1;
+	}
+
+	return (bit_count);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_rs_encode_bitmask
+ *
+ * PARAMETERS:  List            - List of values to encode
+ *              Count           - Length of list
+ *
+ * RETURN:      Encoded bitmask
+ *
+ * DESCRIPTION: Convert a list of values to an encoded bitmask
+ *
+ ******************************************************************************/
+
+u16 acpi_rs_encode_bitmask(u8 *list, u8 count)
+{
+	u32 i;
+	u16 mask;
+
+	ACPI_FUNCTION_ENTRY();
+
+	/* Encode the list into a single bitmask */
+
+	for (i = 0, mask = 0; i < count; i++) {
+		mask |= (0x1 << list[i]);
+	}
+
+	return (mask);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_rs_move_data
+ *
+ * PARAMETERS:  Destination         - Pointer to the destination descriptor
+ *              Source              - Pointer to the source descriptor
+ *              item_count          - How many items to move
+ *              move_type           - Byte width
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Move multiple data items from one descriptor to another. Handles
+ *              alignment issues and endian issues if necessary, as configured
+ *              via the ACPI_MOVE_* macros. (This is why a memcpy is not used)
+ *
+ ******************************************************************************/
+
+void
+acpi_rs_move_data(void *destination, void *source, u16 item_count, u8 move_type)
+{
+	u32 i;
+
+	ACPI_FUNCTION_ENTRY();
+
+	/* One move per item */
+
+	for (i = 0; i < item_count; i++) {
+		switch (move_type) {
+			/*
+			 * For the 8-bit case, we can perform the move all at once
+			 * since there are no alignment or endian issues
+			 */
+		case ACPI_RSC_MOVE8:
+		case ACPI_RSC_MOVE_GPIO_RES:
+		case ACPI_RSC_MOVE_SERIAL_VEN:
+		case ACPI_RSC_MOVE_SERIAL_RES:
+			ACPI_MEMCPY(destination, source, item_count);
+			return;
+
+			/*
+			 * 16-, 32-, and 64-bit cases must use the move macros that perform
+			 * endian conversion and/or accomodate hardware that cannot perform
+			 * misaligned memory transfers
+			 */
+		case ACPI_RSC_MOVE16:
+		case ACPI_RSC_MOVE_GPIO_PIN:
+			ACPI_MOVE_16_TO_16(&ACPI_CAST_PTR(u16, destination)[i],
+					   &ACPI_CAST_PTR(u16, source)[i]);
+			break;
+
+		case ACPI_RSC_MOVE32:
+			ACPI_MOVE_32_TO_32(&ACPI_CAST_PTR(u32, destination)[i],
+					   &ACPI_CAST_PTR(u32, source)[i]);
+			break;
+
+		case ACPI_RSC_MOVE64:
+			ACPI_MOVE_64_TO_64(&ACPI_CAST_PTR(u64, destination)[i],
+					   &ACPI_CAST_PTR(u64, source)[i]);
+			break;
+
+		default:
+			return;
+		}
+	}
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_rs_set_resource_length
+ *
+ * PARAMETERS:  total_length        - Length of the AML descriptor, including
+ *                                    the header and length fields.
+ *              Aml                 - Pointer to the raw AML descriptor
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Set the resource_length field of an AML
+ *              resource descriptor, both Large and Small descriptors are
+ *              supported automatically. Note: Descriptor Type field must
+ *              be valid.
+ *
+ ******************************************************************************/
+
+void
+acpi_rs_set_resource_length(acpi_rsdesc_size total_length,
+			    union aml_resource *aml)
+{
+	acpi_rs_length resource_length;
+
+	ACPI_FUNCTION_ENTRY();
+
+	/* Length is the total descriptor length minus the header length */
+
+	resource_length = (acpi_rs_length)
+	    (total_length - acpi_ut_get_resource_header_length(aml));
+
+	/* Length is stored differently for large and small descriptors */
+
+	if (aml->small_header.descriptor_type & ACPI_RESOURCE_NAME_LARGE) {
+
+		/* Large descriptor -- bytes 1-2 contain the 16-bit length */
+
+		ACPI_MOVE_16_TO_16(&aml->large_header.resource_length,
+				   &resource_length);
+	} else {
+		/* Small descriptor -- bits 2:0 of byte 0 contain the length */
+
+		aml->small_header.descriptor_type = (u8)
+
+		    /* Clear any existing length, preserving descriptor type bits */
+		    ((aml->small_header.
+		      descriptor_type & ~ACPI_RESOURCE_NAME_SMALL_LENGTH_MASK)
+
+		     | resource_length);
+	}
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_rs_set_resource_header
+ *
+ * PARAMETERS:  descriptor_type     - Byte to be inserted as the type
+ *              total_length        - Length of the AML descriptor, including
+ *                                    the header and length fields.
+ *              Aml                 - Pointer to the raw AML descriptor
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Set the descriptor_type and resource_length fields of an AML
+ *              resource descriptor, both Large and Small descriptors are
+ *              supported automatically
+ *
+ ******************************************************************************/
+
+void
+acpi_rs_set_resource_header(u8 descriptor_type,
+			    acpi_rsdesc_size total_length,
+			    union aml_resource *aml)
+{
+	ACPI_FUNCTION_ENTRY();
+
+	/* Set the Resource Type */
+
+	aml->small_header.descriptor_type = descriptor_type;
+
+	/* Set the Resource Length */
+
+	acpi_rs_set_resource_length(total_length, aml);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_rs_strcpy
+ *
+ * PARAMETERS:  Destination         - Pointer to the destination string
+ *              Source              - Pointer to the source string
+ *
+ * RETURN:      String length, including NULL terminator
+ *
+ * DESCRIPTION: Local string copy that returns the string length, saving a
+ *              strcpy followed by a strlen.
+ *
+ ******************************************************************************/
+
+static u16 acpi_rs_strcpy(char *destination, char *source)
+{
+	u16 i;
+
+	ACPI_FUNCTION_ENTRY();
+
+	for (i = 0; source[i]; i++) {
+		destination[i] = source[i];
+	}
+
+	destination[i] = 0;
+
+	/* Return string length including the NULL terminator */
+
+	return ((u16)(i + 1));
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_rs_get_resource_source
+ *
+ * PARAMETERS:  resource_length     - Length field of the descriptor
+ *              minimum_length      - Minimum length of the descriptor (minus
+ *                                    any optional fields)
+ *              resource_source     - Where the resource_source is returned
+ *              Aml                 - Pointer to the raw AML descriptor
+ *              string_ptr          - (optional) where to store the actual
+ *                                    resource_source string
+ *
+ * RETURN:      Length of the string plus NULL terminator, rounded up to native
+ *              word boundary
+ *
+ * DESCRIPTION: Copy the optional resource_source data from a raw AML descriptor
+ *              to an internal resource descriptor
+ *
+ ******************************************************************************/
+
+acpi_rs_length
+acpi_rs_get_resource_source(acpi_rs_length resource_length,
+			    acpi_rs_length minimum_length,
+			    struct acpi_resource_source *resource_source,
+			    union aml_resource *aml, char *string_ptr)
+{
+	acpi_rsdesc_size total_length;
+	u8 *aml_resource_source;
+
+	ACPI_FUNCTION_ENTRY();
+
+	total_length =
+	    resource_length + sizeof(struct aml_resource_large_header);
+	aml_resource_source = ACPI_ADD_PTR(u8, aml, minimum_length);
+
+	/*
+	 * resource_source is present if the length of the descriptor is longer than
+	 * the minimum length.
+	 *
+	 * Note: Some resource descriptors will have an additional null, so
+	 * we add 1 to the minimum length.
+	 */
+	if (total_length > (acpi_rsdesc_size) (minimum_length + 1)) {
+
+		/* Get the resource_source_index */
+
+		resource_source->index = aml_resource_source[0];
+
+		resource_source->string_ptr = string_ptr;
+		if (!string_ptr) {
+			/*
+			 * String destination pointer is not specified; Set the String
+			 * pointer to the end of the current resource_source structure.
+			 */
+			resource_source->string_ptr =
+			    ACPI_ADD_PTR(char, resource_source,
+					 sizeof(struct acpi_resource_source));
+		}
+
+		/*
+		 * In order for the Resource length to be a multiple of the native
+		 * word, calculate the length of the string (+1 for NULL terminator)
+		 * and expand to the next word multiple.
+		 *
+		 * Zero the entire area of the buffer.
+		 */
+		total_length =
+		    (u32)
+		    ACPI_STRLEN(ACPI_CAST_PTR(char, &aml_resource_source[1])) +
+		    1;
+		total_length = (u32)ACPI_ROUND_UP_TO_NATIVE_WORD(total_length);
+
+		ACPI_MEMSET(resource_source->string_ptr, 0, total_length);
+
+		/* Copy the resource_source string to the destination */
+
+		resource_source->string_length =
+		    acpi_rs_strcpy(resource_source->string_ptr,
+				   ACPI_CAST_PTR(char,
+						 &aml_resource_source[1]));
+
+		return ((acpi_rs_length) total_length);
+	}
+
+	/* resource_source is not present */
+
+	resource_source->index = 0;
+	resource_source->string_length = 0;
+	resource_source->string_ptr = NULL;
+	return (0);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_rs_set_resource_source
+ *
+ * PARAMETERS:  Aml                 - Pointer to the raw AML descriptor
+ *              minimum_length      - Minimum length of the descriptor (minus
+ *                                    any optional fields)
+ *              resource_source     - Internal resource_source
+
+ *
+ * RETURN:      Total length of the AML descriptor
+ *
+ * DESCRIPTION: Convert an optional resource_source from internal format to a
+ *              raw AML resource descriptor
+ *
+ ******************************************************************************/
+
+acpi_rsdesc_size
+acpi_rs_set_resource_source(union aml_resource * aml,
+			    acpi_rs_length minimum_length,
+			    struct acpi_resource_source * resource_source)
+{
+	u8 *aml_resource_source;
+	acpi_rsdesc_size descriptor_length;
+
+	ACPI_FUNCTION_ENTRY();
+
+	descriptor_length = minimum_length;
+
+	/* Non-zero string length indicates presence of a resource_source */
+
+	if (resource_source->string_length) {
+
+		/* Point to the end of the AML descriptor */
+
+		aml_resource_source = ACPI_ADD_PTR(u8, aml, minimum_length);
+
+		/* Copy the resource_source_index */
+
+		aml_resource_source[0] = (u8)resource_source->index;
+
+		/* Copy the resource_source string */
+
+		ACPI_STRCPY(ACPI_CAST_PTR(char, &aml_resource_source[1]),
+			    resource_source->string_ptr);
+
+		/*
+		 * Add the length of the string (+ 1 for null terminator) to the
+		 * final descriptor length
+		 */
+		descriptor_length +=
+		    ((acpi_rsdesc_size) resource_source->string_length + 1);
+	}
+
+	/* Return the new total length of the AML descriptor */
+
+	return (descriptor_length);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_rs_get_prt_method_data
+ *
+ * PARAMETERS:  Node            - Device node
+ *              ret_buffer      - Pointer to a buffer structure for the
+ *                                results
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: This function is called to get the _PRT value of an object
+ *              contained in an object specified by the handle passed in
+ *
+ *              If the function fails an appropriate status will be returned
+ *              and the contents of the callers buffer is undefined.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_rs_get_prt_method_data(struct acpi_namespace_node * node,
+			    struct acpi_buffer * ret_buffer)
+{
+	union acpi_operand_object *obj_desc;
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(rs_get_prt_method_data);
+
+	/* Parameters guaranteed valid by caller */
+
+	/* Execute the method, no parameters */
+
+	status = acpi_ut_evaluate_object(node, METHOD_NAME__PRT,
+					 ACPI_BTYPE_PACKAGE, &obj_desc);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/*
+	 * Create a resource linked list from the byte stream buffer that comes
+	 * back from the _CRS method execution.
+	 */
+	status = acpi_rs_create_pci_routing_table(obj_desc, ret_buffer);
+
+	/* On exit, we must delete the object returned by evaluate_object */
+
+	acpi_ut_remove_reference(obj_desc);
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_rs_get_crs_method_data
+ *
+ * PARAMETERS:  Node            - Device node
+ *              ret_buffer      - Pointer to a buffer structure for the
+ *                                results
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: This function is called to get the _CRS value of an object
+ *              contained in an object specified by the handle passed in
+ *
+ *              If the function fails an appropriate status will be returned
+ *              and the contents of the callers buffer is undefined.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_rs_get_crs_method_data(struct acpi_namespace_node *node,
+			    struct acpi_buffer *ret_buffer)
+{
+	union acpi_operand_object *obj_desc;
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(rs_get_crs_method_data);
+
+	/* Parameters guaranteed valid by caller */
+
+	/* Execute the method, no parameters */
+
+	status = acpi_ut_evaluate_object(node, METHOD_NAME__CRS,
+					 ACPI_BTYPE_BUFFER, &obj_desc);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/*
+	 * Make the call to create a resource linked list from the
+	 * byte stream buffer that comes back from the _CRS method
+	 * execution.
+	 */
+	status = acpi_rs_create_resource_list(obj_desc, ret_buffer);
+
+	/* On exit, we must delete the object returned by evaluate_object */
+
+	acpi_ut_remove_reference(obj_desc);
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_rs_get_prs_method_data
+ *
+ * PARAMETERS:  Node            - Device node
+ *              ret_buffer      - Pointer to a buffer structure for the
+ *                                results
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: This function is called to get the _PRS value of an object
+ *              contained in an object specified by the handle passed in
+ *
+ *              If the function fails an appropriate status will be returned
+ *              and the contents of the callers buffer is undefined.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_rs_get_prs_method_data(struct acpi_namespace_node *node,
+			    struct acpi_buffer *ret_buffer)
+{
+	union acpi_operand_object *obj_desc;
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(rs_get_prs_method_data);
+
+	/* Parameters guaranteed valid by caller */
+
+	/* Execute the method, no parameters */
+
+	status = acpi_ut_evaluate_object(node, METHOD_NAME__PRS,
+					 ACPI_BTYPE_BUFFER, &obj_desc);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/*
+	 * Make the call to create a resource linked list from the
+	 * byte stream buffer that comes back from the _CRS method
+	 * execution.
+	 */
+	status = acpi_rs_create_resource_list(obj_desc, ret_buffer);
+
+	/* On exit, we must delete the object returned by evaluate_object */
+
+	acpi_ut_remove_reference(obj_desc);
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_rs_get_aei_method_data
+ *
+ * PARAMETERS:  Node            - Device node
+ *              ret_buffer      - Pointer to a buffer structure for the
+ *                                results
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: This function is called to get the _AEI value of an object
+ *              contained in an object specified by the handle passed in
+ *
+ *              If the function fails an appropriate status will be returned
+ *              and the contents of the callers buffer is undefined.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_rs_get_aei_method_data(struct acpi_namespace_node *node,
+			    struct acpi_buffer *ret_buffer)
+{
+	union acpi_operand_object *obj_desc;
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(rs_get_aei_method_data);
+
+	/* Parameters guaranteed valid by caller */
+
+	/* Execute the method, no parameters */
+
+	status = acpi_ut_evaluate_object(node, METHOD_NAME__AEI,
+					 ACPI_BTYPE_BUFFER, &obj_desc);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/*
+	 * Make the call to create a resource linked list from the
+	 * byte stream buffer that comes back from the _CRS method
+	 * execution.
+	 */
+	status = acpi_rs_create_resource_list(obj_desc, ret_buffer);
+
+	/* On exit, we must delete the object returned by evaluate_object */
+
+	acpi_ut_remove_reference(obj_desc);
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_rs_get_method_data
+ *
+ * PARAMETERS:  Handle          - Handle to the containing object
+ *              Path            - Path to method, relative to Handle
+ *              ret_buffer      - Pointer to a buffer structure for the
+ *                                results
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: This function is called to get the _CRS or _PRS value of an
+ *              object contained in an object specified by the handle passed in
+ *
+ *              If the function fails an appropriate status will be returned
+ *              and the contents of the callers buffer is undefined.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_rs_get_method_data(acpi_handle handle,
+			char *path, struct acpi_buffer *ret_buffer)
+{
+	union acpi_operand_object *obj_desc;
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(rs_get_method_data);
+
+	/* Parameters guaranteed valid by caller */
+
+	/* Execute the method, no parameters */
+
+	status =
+	    acpi_ut_evaluate_object(handle, path, ACPI_BTYPE_BUFFER, &obj_desc);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/*
+	 * Make the call to create a resource linked list from the
+	 * byte stream buffer that comes back from the method
+	 * execution.
+	 */
+	status = acpi_rs_create_resource_list(obj_desc, ret_buffer);
+
+	/* On exit, we must delete the object returned by evaluate_object */
+
+	acpi_ut_remove_reference(obj_desc);
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_rs_set_srs_method_data
+ *
+ * PARAMETERS:  Node            - Device node
+ *              in_buffer       - Pointer to a buffer structure of the
+ *                                parameter
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: This function is called to set the _SRS of an object contained
+ *              in an object specified by the handle passed in
+ *
+ *              If the function fails an appropriate status will be returned
+ *              and the contents of the callers buffer is undefined.
+ *
+ * Note: Parameters guaranteed valid by caller
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_rs_set_srs_method_data(struct acpi_namespace_node *node,
+			    struct acpi_buffer *in_buffer)
+{
+	struct acpi_evaluate_info *info;
+	union acpi_operand_object *args[2];
+	acpi_status status;
+	struct acpi_buffer buffer;
+
+	ACPI_FUNCTION_TRACE(rs_set_srs_method_data);
+
+	/* Allocate and initialize the evaluation information block */
+
+	info = ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_evaluate_info));
+	if (!info) {
+		return_ACPI_STATUS(AE_NO_MEMORY);
+	}
+
+	info->prefix_node = node;
+	info->pathname = METHOD_NAME__SRS;
+	info->parameters = args;
+	info->flags = ACPI_IGNORE_RETURN_VALUE;
+
+	/*
+	 * The in_buffer parameter will point to a linked list of
+	 * resource parameters. It needs to be formatted into a
+	 * byte stream to be sent in as an input parameter to _SRS
+	 *
+	 * Convert the linked list into a byte stream
+	 */
+	buffer.length = ACPI_ALLOCATE_LOCAL_BUFFER;
+	status = acpi_rs_create_aml_resources(in_buffer->pointer, &buffer);
+	if (ACPI_FAILURE(status)) {
+		goto cleanup;
+	}
+
+	/* Create and initialize the method parameter object */
+
+	args[0] = acpi_ut_create_internal_object(ACPI_TYPE_BUFFER);
+	if (!args[0]) {
+		/*
+		 * Must free the buffer allocated above (otherwise it is freed
+		 * later)
+		 */
+		ACPI_FREE(buffer.pointer);
+		status = AE_NO_MEMORY;
+		goto cleanup;
+	}
+
+	args[0]->buffer.length = (u32)buffer.length;
+	args[0]->buffer.pointer = buffer.pointer;
+	args[0]->common.flags = AOPOBJ_DATA_VALID;
+	args[1] = NULL;
+
+	/* Execute the method, no return value is expected */
+
+	status = acpi_ns_evaluate(info);
+
+	/* Clean up and return the status from acpi_ns_evaluate */
+
+	acpi_ut_remove_reference(args[0]);
+
+      cleanup:
+	ACPI_FREE(info);
+	return_ACPI_STATUS(status);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/rsxface.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/rsxface.c
new file mode 100644
index 00000000..25041173
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/rsxface.c
@@ -0,0 +1,618 @@
+/*******************************************************************************
+ *
+ * Module Name: rsxface - Public interfaces to the resource manager
+ *
+ ******************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acresrc.h"
+#include "acnamesp.h"
+
+#define _COMPONENT          ACPI_RESOURCES
+ACPI_MODULE_NAME("rsxface")
+
+/* Local macros for 16,32-bit to 64-bit conversion */
+#define ACPI_COPY_FIELD(out, in, field)  ((out)->field = (in)->field)
+#define ACPI_COPY_ADDRESS(out, in)                      \
+	ACPI_COPY_FIELD(out, in, resource_type);             \
+	ACPI_COPY_FIELD(out, in, producer_consumer);         \
+	ACPI_COPY_FIELD(out, in, decode);                    \
+	ACPI_COPY_FIELD(out, in, min_address_fixed);         \
+	ACPI_COPY_FIELD(out, in, max_address_fixed);         \
+	ACPI_COPY_FIELD(out, in, info);                      \
+	ACPI_COPY_FIELD(out, in, granularity);               \
+	ACPI_COPY_FIELD(out, in, minimum);                   \
+	ACPI_COPY_FIELD(out, in, maximum);                   \
+	ACPI_COPY_FIELD(out, in, translation_offset);        \
+	ACPI_COPY_FIELD(out, in, address_length);            \
+	ACPI_COPY_FIELD(out, in, resource_source);
+/* Local prototypes */
+static acpi_status
+acpi_rs_match_vendor_resource(struct acpi_resource *resource, void *context);
+
+static acpi_status
+acpi_rs_validate_parameters(acpi_handle device_handle,
+			    struct acpi_buffer *buffer,
+			    struct acpi_namespace_node **return_node);
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_rs_validate_parameters
+ *
+ * PARAMETERS:  device_handle   - Handle to a device
+ *              Buffer          - Pointer to a data buffer
+ *              return_node     - Pointer to where the device node is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Common parameter validation for resource interfaces
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_rs_validate_parameters(acpi_handle device_handle,
+			    struct acpi_buffer *buffer,
+			    struct acpi_namespace_node **return_node)
+{
+	acpi_status status;
+	struct acpi_namespace_node *node;
+
+	ACPI_FUNCTION_TRACE(rs_validate_parameters);
+
+	/*
+	 * Must have a valid handle to an ACPI device
+	 */
+	if (!device_handle) {
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	node = acpi_ns_validate_handle(device_handle);
+	if (!node) {
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	if (node->type != ACPI_TYPE_DEVICE) {
+		return_ACPI_STATUS(AE_TYPE);
+	}
+
+	/*
+	 * Validate the user buffer object
+	 *
+	 * if there is a non-zero buffer length we also need a valid pointer in
+	 * the buffer. If it's a zero buffer length, we'll be returning the
+	 * needed buffer size (later), so keep going.
+	 */
+	status = acpi_ut_validate_buffer(buffer);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	*return_node = node;
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_get_irq_routing_table
+ *
+ * PARAMETERS:  device_handle   - Handle to the Bus device we are querying
+ *              ret_buffer      - Pointer to a buffer to receive the
+ *                                current resources for the device
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: This function is called to get the IRQ routing table for a
+ *              specific bus. The caller must first acquire a handle for the
+ *              desired bus. The routine table is placed in the buffer pointed
+ *              to by the ret_buffer variable parameter.
+ *
+ *              If the function fails an appropriate status will be returned
+ *              and the value of ret_buffer is undefined.
+ *
+ *              This function attempts to execute the _PRT method contained in
+ *              the object indicated by the passed device_handle.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_get_irq_routing_table(acpi_handle device_handle,
+			   struct acpi_buffer *ret_buffer)
+{
+	acpi_status status;
+	struct acpi_namespace_node *node;
+
+	ACPI_FUNCTION_TRACE(acpi_get_irq_routing_table);
+
+	/* Validate parameters then dispatch to internal routine */
+
+	status = acpi_rs_validate_parameters(device_handle, ret_buffer, &node);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	status = acpi_rs_get_prt_method_data(node, ret_buffer);
+	return_ACPI_STATUS(status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_get_irq_routing_table)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_get_current_resources
+ *
+ * PARAMETERS:  device_handle   - Handle to the device object for the
+ *                                device we are querying
+ *              ret_buffer      - Pointer to a buffer to receive the
+ *                                current resources for the device
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: This function is called to get the current resources for a
+ *              specific device. The caller must first acquire a handle for
+ *              the desired device. The resource data is placed in the buffer
+ *              pointed to by the ret_buffer variable parameter.
+ *
+ *              If the function fails an appropriate status will be returned
+ *              and the value of ret_buffer is undefined.
+ *
+ *              This function attempts to execute the _CRS method contained in
+ *              the object indicated by the passed device_handle.
+ *
+ ******************************************************************************/
+acpi_status
+acpi_get_current_resources(acpi_handle device_handle,
+			   struct acpi_buffer *ret_buffer)
+{
+	acpi_status status;
+	struct acpi_namespace_node *node;
+
+	ACPI_FUNCTION_TRACE(acpi_get_current_resources);
+
+	/* Validate parameters then dispatch to internal routine */
+
+	status = acpi_rs_validate_parameters(device_handle, ret_buffer, &node);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	status = acpi_rs_get_crs_method_data(node, ret_buffer);
+	return_ACPI_STATUS(status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_get_current_resources)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_get_possible_resources
+ *
+ * PARAMETERS:  device_handle   - Handle to the device object for the
+ *                                device we are querying
+ *              ret_buffer      - Pointer to a buffer to receive the
+ *                                resources for the device
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: This function is called to get a list of the possible resources
+ *              for a specific device. The caller must first acquire a handle
+ *              for the desired device. The resource data is placed in the
+ *              buffer pointed to by the ret_buffer variable.
+ *
+ *              If the function fails an appropriate status will be returned
+ *              and the value of ret_buffer is undefined.
+ *
+ ******************************************************************************/
+acpi_status
+acpi_get_possible_resources(acpi_handle device_handle,
+			    struct acpi_buffer *ret_buffer)
+{
+	acpi_status status;
+	struct acpi_namespace_node *node;
+
+	ACPI_FUNCTION_TRACE(acpi_get_possible_resources);
+
+	/* Validate parameters then dispatch to internal routine */
+
+	status = acpi_rs_validate_parameters(device_handle, ret_buffer, &node);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	status = acpi_rs_get_prs_method_data(node, ret_buffer);
+	return_ACPI_STATUS(status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_get_possible_resources)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_set_current_resources
+ *
+ * PARAMETERS:  device_handle   - Handle to the device object for the
+ *                                device we are setting resources
+ *              in_buffer       - Pointer to a buffer containing the
+ *                                resources to be set for the device
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: This function is called to set the current resources for a
+ *              specific device. The caller must first acquire a handle for
+ *              the desired device. The resource data is passed to the routine
+ *              the buffer pointed to by the in_buffer variable.
+ *
+ ******************************************************************************/
+acpi_status
+acpi_set_current_resources(acpi_handle device_handle,
+			   struct acpi_buffer *in_buffer)
+{
+	acpi_status status;
+	struct acpi_namespace_node *node;
+
+	ACPI_FUNCTION_TRACE(acpi_set_current_resources);
+
+	/* Validate the buffer, don't allow zero length */
+
+	if ((!in_buffer) || (!in_buffer->pointer) || (!in_buffer->length)) {
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	/* Validate parameters then dispatch to internal routine */
+
+	status = acpi_rs_validate_parameters(device_handle, in_buffer, &node);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	status = acpi_rs_set_srs_method_data(node, in_buffer);
+	return_ACPI_STATUS(status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_set_current_resources)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_get_event_resources
+ *
+ * PARAMETERS:  device_handle   - Handle to the device object for the
+ *                                device we are getting resources
+ *              in_buffer       - Pointer to a buffer containing the
+ *                                resources to be set for the device
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: This function is called to get the event resources for a
+ *              specific device. The caller must first acquire a handle for
+ *              the desired device. The resource data is passed to the routine
+ *              the buffer pointed to by the in_buffer variable. Uses the
+ *              _AEI method.
+ *
+ ******************************************************************************/
+acpi_status
+acpi_get_event_resources(acpi_handle device_handle,
+			 struct acpi_buffer *ret_buffer)
+{
+	acpi_status status;
+	struct acpi_namespace_node *node;
+
+	ACPI_FUNCTION_TRACE(acpi_get_event_resources);
+
+	/* Validate parameters then dispatch to internal routine */
+
+	status = acpi_rs_validate_parameters(device_handle, ret_buffer, &node);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	status = acpi_rs_get_aei_method_data(node, ret_buffer);
+	return_ACPI_STATUS(status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_get_event_resources)
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_resource_to_address64
+ *
+ * PARAMETERS:  Resource        - Pointer to a resource
+ *              Out             - Pointer to the users's return buffer
+ *                                (a struct acpi_resource_address64)
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: If the resource is an address16, address32, or address64,
+ *              copy it to the address64 return buffer. This saves the
+ *              caller from having to duplicate code for different-sized
+ *              addresses.
+ *
+ ******************************************************************************/
+acpi_status
+acpi_resource_to_address64(struct acpi_resource *resource,
+			   struct acpi_resource_address64 *out)
+{
+	struct acpi_resource_address16 *address16;
+	struct acpi_resource_address32 *address32;
+
+	if (!resource || !out) {
+		return (AE_BAD_PARAMETER);
+	}
+
+	/* Convert 16 or 32 address descriptor to 64 */
+
+	switch (resource->type) {
+	case ACPI_RESOURCE_TYPE_ADDRESS16:
+
+		address16 =
+		    ACPI_CAST_PTR(struct acpi_resource_address16,
+				  &resource->data);
+		ACPI_COPY_ADDRESS(out, address16);
+		break;
+
+	case ACPI_RESOURCE_TYPE_ADDRESS32:
+
+		address32 =
+		    ACPI_CAST_PTR(struct acpi_resource_address32,
+				  &resource->data);
+		ACPI_COPY_ADDRESS(out, address32);
+		break;
+
+	case ACPI_RESOURCE_TYPE_ADDRESS64:
+
+		/* Simple copy for 64 bit source */
+
+		ACPI_MEMCPY(out, &resource->data,
+			    sizeof(struct acpi_resource_address64));
+		break;
+
+	default:
+		return (AE_BAD_PARAMETER);
+	}
+
+	return (AE_OK);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_resource_to_address64)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_get_vendor_resource
+ *
+ * PARAMETERS:  device_handle   - Handle for the parent device object
+ *              Name            - Method name for the parent resource
+ *                                (METHOD_NAME__CRS or METHOD_NAME__PRS)
+ *              Uuid            - Pointer to the UUID to be matched.
+ *                                includes both subtype and 16-byte UUID
+ *              ret_buffer      - Where the vendor resource is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Walk a resource template for the specified evice to find a
+ *              vendor-defined resource that matches the supplied UUID and
+ *              UUID subtype. Returns a struct acpi_resource of type Vendor.
+ *
+ ******************************************************************************/
+acpi_status
+acpi_get_vendor_resource(acpi_handle device_handle,
+			 char *name,
+			 struct acpi_vendor_uuid * uuid,
+			 struct acpi_buffer * ret_buffer)
+{
+	struct acpi_vendor_walk_info info;
+	acpi_status status;
+
+	/* Other parameters are validated by acpi_walk_resources */
+
+	if (!uuid || !ret_buffer) {
+		return (AE_BAD_PARAMETER);
+	}
+
+	info.uuid = uuid;
+	info.buffer = ret_buffer;
+	info.status = AE_NOT_EXIST;
+
+	/* Walk the _CRS or _PRS resource list for this device */
+
+	status =
+	    acpi_walk_resources(device_handle, name,
+				acpi_rs_match_vendor_resource, &info);
+	if (ACPI_FAILURE(status)) {
+		return (status);
+	}
+
+	return (info.status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_get_vendor_resource)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_rs_match_vendor_resource
+ *
+ * PARAMETERS:  acpi_walk_resource_callback
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Match a vendor resource via the ACPI 3.0 UUID
+ *
+ ******************************************************************************/
+static acpi_status
+acpi_rs_match_vendor_resource(struct acpi_resource *resource, void *context)
+{
+	struct acpi_vendor_walk_info *info = context;
+	struct acpi_resource_vendor_typed *vendor;
+	struct acpi_buffer *buffer;
+	acpi_status status;
+
+	/* Ignore all descriptors except Vendor */
+
+	if (resource->type != ACPI_RESOURCE_TYPE_VENDOR) {
+		return (AE_OK);
+	}
+
+	vendor = &resource->data.vendor_typed;
+
+	/*
+	 * For a valid match, these conditions must hold:
+	 *
+	 * 1) Length of descriptor data must be at least as long as a UUID struct
+	 * 2) The UUID subtypes must match
+	 * 3) The UUID data must match
+	 */
+	if ((vendor->byte_length < (ACPI_UUID_LENGTH + 1)) ||
+	    (vendor->uuid_subtype != info->uuid->subtype) ||
+	    (ACPI_MEMCMP(vendor->uuid, info->uuid->data, ACPI_UUID_LENGTH))) {
+		return (AE_OK);
+	}
+
+	/* Validate/Allocate/Clear caller buffer */
+
+	buffer = info->buffer;
+	status = acpi_ut_initialize_buffer(buffer, resource->length);
+	if (ACPI_FAILURE(status)) {
+		return (status);
+	}
+
+	/* Found the correct resource, copy and return it */
+
+	ACPI_MEMCPY(buffer->pointer, resource, resource->length);
+	buffer->length = resource->length;
+
+	/* Found the desired descriptor, terminate resource walk */
+
+	info->status = AE_OK;
+	return (AE_CTRL_TERMINATE);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_walk_resources
+ *
+ * PARAMETERS:  device_handle   - Handle to the device object for the
+ *                                device we are querying
+ *              Name            - Method name of the resources we want.
+ *                                (METHOD_NAME__CRS, METHOD_NAME__PRS, or
+ *                                METHOD_NAME__AEI)
+ *              user_function   - Called for each resource
+ *              Context         - Passed to user_function
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Retrieves the current or possible resource list for the
+ *              specified device. The user_function is called once for
+ *              each resource in the list.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_walk_resources(acpi_handle device_handle,
+		    char *name,
+		    acpi_walk_resource_callback user_function, void *context)
+{
+	acpi_status status;
+	struct acpi_buffer buffer;
+	struct acpi_resource *resource;
+	struct acpi_resource *resource_end;
+
+	ACPI_FUNCTION_TRACE(acpi_walk_resources);
+
+	/* Parameter validation */
+
+	if (!device_handle || !user_function || !name ||
+	    (!ACPI_COMPARE_NAME(name, METHOD_NAME__CRS) &&
+	     !ACPI_COMPARE_NAME(name, METHOD_NAME__PRS) &&
+	     !ACPI_COMPARE_NAME(name, METHOD_NAME__AEI))) {
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	/* Get the _CRS/_PRS/_AEI resource list */
+
+	buffer.length = ACPI_ALLOCATE_LOCAL_BUFFER;
+	status = acpi_rs_get_method_data(device_handle, name, &buffer);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/* Buffer now contains the resource list */
+
+	resource = ACPI_CAST_PTR(struct acpi_resource, buffer.pointer);
+	resource_end =
+	    ACPI_ADD_PTR(struct acpi_resource, buffer.pointer, buffer.length);
+
+	/* Walk the resource list until the end_tag is found (or buffer end) */
+
+	while (resource < resource_end) {
+
+		/* Sanity check the resource */
+
+		if (resource->type > ACPI_RESOURCE_TYPE_MAX) {
+			status = AE_AML_INVALID_RESOURCE_TYPE;
+			break;
+		}
+
+		/* Invoke the user function, abort on any error returned */
+
+		status = user_function(resource, context);
+		if (ACPI_FAILURE(status)) {
+			if (status == AE_CTRL_TERMINATE) {
+
+				/* This is an OK termination by the user function */
+
+				status = AE_OK;
+			}
+			break;
+		}
+
+		/* end_tag indicates end-of-list */
+
+		if (resource->type == ACPI_RESOURCE_TYPE_END_TAG) {
+			break;
+		}
+
+		/* Get the next resource descriptor */
+
+		resource =
+		    ACPI_ADD_PTR(struct acpi_resource, resource,
+				 resource->length);
+	}
+
+	ACPI_FREE(buffer.pointer);
+	return_ACPI_STATUS(status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_walk_resources)
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/tbfadt.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/tbfadt.c
new file mode 100644
index 00000000..49227061
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/tbfadt.c
@@ -0,0 +1,666 @@
+/******************************************************************************
+ *
+ * Module Name: tbfadt   - FADT table utilities
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "actables.h"
+
+#define _COMPONENT          ACPI_TABLES
+ACPI_MODULE_NAME("tbfadt")
+
+/* Local prototypes */
+static ACPI_INLINE void
+acpi_tb_init_generic_address(struct acpi_generic_address *generic_address,
+			     u8 space_id, u8 byte_width, u64 address);
+
+static void acpi_tb_convert_fadt(void);
+
+static void acpi_tb_validate_fadt(void);
+
+static void acpi_tb_setup_fadt_registers(void);
+
+/* Table for conversion of FADT to common internal format and FADT validation */
+
+typedef struct acpi_fadt_info {
+	char *name;
+	u16 address64;
+	u16 address32;
+	u16 length;
+	u8 default_length;
+	u8 type;
+
+} acpi_fadt_info;
+
+#define ACPI_FADT_OPTIONAL          0
+#define ACPI_FADT_REQUIRED          1
+#define ACPI_FADT_SEPARATE_LENGTH   2
+
+static struct acpi_fadt_info fadt_info_table[] = {
+	{"Pm1aEventBlock",
+	 ACPI_FADT_OFFSET(xpm1a_event_block),
+	 ACPI_FADT_OFFSET(pm1a_event_block),
+	 ACPI_FADT_OFFSET(pm1_event_length),
+	 ACPI_PM1_REGISTER_WIDTH * 2,	/* Enable + Status register */
+	 ACPI_FADT_REQUIRED},
+
+	{"Pm1bEventBlock",
+	 ACPI_FADT_OFFSET(xpm1b_event_block),
+	 ACPI_FADT_OFFSET(pm1b_event_block),
+	 ACPI_FADT_OFFSET(pm1_event_length),
+	 ACPI_PM1_REGISTER_WIDTH * 2,	/* Enable + Status register */
+	 ACPI_FADT_OPTIONAL},
+
+	{"Pm1aControlBlock",
+	 ACPI_FADT_OFFSET(xpm1a_control_block),
+	 ACPI_FADT_OFFSET(pm1a_control_block),
+	 ACPI_FADT_OFFSET(pm1_control_length),
+	 ACPI_PM1_REGISTER_WIDTH,
+	 ACPI_FADT_REQUIRED},
+
+	{"Pm1bControlBlock",
+	 ACPI_FADT_OFFSET(xpm1b_control_block),
+	 ACPI_FADT_OFFSET(pm1b_control_block),
+	 ACPI_FADT_OFFSET(pm1_control_length),
+	 ACPI_PM1_REGISTER_WIDTH,
+	 ACPI_FADT_OPTIONAL},
+
+	{"Pm2ControlBlock",
+	 ACPI_FADT_OFFSET(xpm2_control_block),
+	 ACPI_FADT_OFFSET(pm2_control_block),
+	 ACPI_FADT_OFFSET(pm2_control_length),
+	 ACPI_PM2_REGISTER_WIDTH,
+	 ACPI_FADT_SEPARATE_LENGTH},
+
+	{"PmTimerBlock",
+	 ACPI_FADT_OFFSET(xpm_timer_block),
+	 ACPI_FADT_OFFSET(pm_timer_block),
+	 ACPI_FADT_OFFSET(pm_timer_length),
+	 ACPI_PM_TIMER_WIDTH,
+	 ACPI_FADT_REQUIRED},
+
+	{"Gpe0Block",
+	 ACPI_FADT_OFFSET(xgpe0_block),
+	 ACPI_FADT_OFFSET(gpe0_block),
+	 ACPI_FADT_OFFSET(gpe0_block_length),
+	 0,
+	 ACPI_FADT_SEPARATE_LENGTH},
+
+	{"Gpe1Block",
+	 ACPI_FADT_OFFSET(xgpe1_block),
+	 ACPI_FADT_OFFSET(gpe1_block),
+	 ACPI_FADT_OFFSET(gpe1_block_length),
+	 0,
+	 ACPI_FADT_SEPARATE_LENGTH}
+};
+
+#define ACPI_FADT_INFO_ENTRIES \
+			(sizeof (fadt_info_table) / sizeof (struct acpi_fadt_info))
+
+/* Table used to split Event Blocks into separate status/enable registers */
+
+typedef struct acpi_fadt_pm_info {
+	struct acpi_generic_address *target;
+	u16 source;
+	u8 register_num;
+
+} acpi_fadt_pm_info;
+
+static struct acpi_fadt_pm_info fadt_pm_info_table[] = {
+	{&acpi_gbl_xpm1a_status,
+	 ACPI_FADT_OFFSET(xpm1a_event_block),
+	 0},
+
+	{&acpi_gbl_xpm1a_enable,
+	 ACPI_FADT_OFFSET(xpm1a_event_block),
+	 1},
+
+	{&acpi_gbl_xpm1b_status,
+	 ACPI_FADT_OFFSET(xpm1b_event_block),
+	 0},
+
+	{&acpi_gbl_xpm1b_enable,
+	 ACPI_FADT_OFFSET(xpm1b_event_block),
+	 1}
+};
+
+#define ACPI_FADT_PM_INFO_ENTRIES \
+			(sizeof (fadt_pm_info_table) / sizeof (struct acpi_fadt_pm_info))
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_init_generic_address
+ *
+ * PARAMETERS:  generic_address     - GAS struct to be initialized
+ *              space_id            - ACPI Space ID for this register
+ *              byte_width          - Width of this register, in bytes
+ *              Address             - Address of the register
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Initialize a Generic Address Structure (GAS)
+ *              See the ACPI specification for a full description and
+ *              definition of this structure.
+ *
+ ******************************************************************************/
+
+static ACPI_INLINE void
+acpi_tb_init_generic_address(struct acpi_generic_address *generic_address,
+			     u8 space_id, u8 byte_width, u64 address)
+{
+
+	/*
+	 * The 64-bit Address field is non-aligned in the byte packed
+	 * GAS struct.
+	 */
+	ACPI_MOVE_64_TO_64(&generic_address->address, &address);
+
+	/* All other fields are byte-wide */
+
+	generic_address->space_id = space_id;
+	generic_address->bit_width = (u8)ACPI_MUL_8(byte_width);
+	generic_address->bit_offset = 0;
+	generic_address->access_width = 0;	/* Access width ANY */
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_parse_fadt
+ *
+ * PARAMETERS:  table_index         - Index for the FADT
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Initialize the FADT, DSDT and FACS tables
+ *              (FADT contains the addresses of the DSDT and FACS)
+ *
+ ******************************************************************************/
+
+void acpi_tb_parse_fadt(u32 table_index)
+{
+	u32 length;
+	struct acpi_table_header *table;
+
+	/*
+	 * The FADT has multiple versions with different lengths,
+	 * and it contains pointers to both the DSDT and FACS tables.
+	 *
+	 * Get a local copy of the FADT and convert it to a common format
+	 * Map entire FADT, assumed to be smaller than one page.
+	 */
+	length = acpi_gbl_root_table_list.tables[table_index].length;
+
+	table =
+	    acpi_os_map_memory(acpi_gbl_root_table_list.tables[table_index].
+			       address, length);
+	if (!table) {
+		return;
+	}
+
+	/*
+	 * Validate the FADT checksum before we copy the table. Ignore
+	 * checksum error as we want to try to get the DSDT and FACS.
+	 */
+	(void)acpi_tb_verify_checksum(table, length);
+
+	/* Create a local copy of the FADT in common ACPI 2.0+ format */
+
+	acpi_tb_create_local_fadt(table, length);
+
+	/* All done with the real FADT, unmap it */
+
+	acpi_os_unmap_memory(table, length);
+
+	/* Obtain the DSDT and FACS tables via their addresses within the FADT */
+
+	acpi_tb_install_table((acpi_physical_address) acpi_gbl_FADT.Xdsdt,
+			      ACPI_SIG_DSDT, ACPI_TABLE_INDEX_DSDT);
+
+	/* If Hardware Reduced flag is set, there is no FACS */
+
+	if (!acpi_gbl_reduced_hardware) {
+		acpi_tb_install_table((acpi_physical_address) acpi_gbl_FADT.
+				      Xfacs, ACPI_SIG_FACS,
+				      ACPI_TABLE_INDEX_FACS);
+	}
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_create_local_fadt
+ *
+ * PARAMETERS:  Table               - Pointer to BIOS FADT
+ *              Length              - Length of the table
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Get a local copy of the FADT and convert it to a common format.
+ *              Performs validation on some important FADT fields.
+ *
+ * NOTE:        We create a local copy of the FADT regardless of the version.
+ *
+ ******************************************************************************/
+
+void acpi_tb_create_local_fadt(struct acpi_table_header *table, u32 length)
+{
+
+	/*
+	 * Check if the FADT is larger than the largest table that we expect
+	 * (the ACPI 5.0 version). If so, truncate the table, and issue
+	 * a warning.
+	 */
+	if (length > sizeof(struct acpi_table_fadt)) {
+		ACPI_WARNING((AE_INFO,
+			      "FADT (revision %u) is longer than ACPI 5.0 version, "
+			      "truncating length %u to %u",
+			      table->revision, length,
+			      (u32)sizeof(struct acpi_table_fadt)));
+	}
+
+	/* Clear the entire local FADT */
+
+	ACPI_MEMSET(&acpi_gbl_FADT, 0, sizeof(struct acpi_table_fadt));
+
+	/* Copy the original FADT, up to sizeof (struct acpi_table_fadt) */
+
+	ACPI_MEMCPY(&acpi_gbl_FADT, table,
+		    ACPI_MIN(length, sizeof(struct acpi_table_fadt)));
+
+	/* Take a copy of the Hardware Reduced flag */
+
+	acpi_gbl_reduced_hardware = FALSE;
+	if (acpi_gbl_FADT.flags & ACPI_FADT_HW_REDUCED) {
+		acpi_gbl_reduced_hardware = TRUE;
+	}
+
+	/* Convert the local copy of the FADT to the common internal format */
+
+	acpi_tb_convert_fadt();
+
+	/* Validate FADT values now, before we make any changes */
+
+	acpi_tb_validate_fadt();
+
+	/* Initialize the global ACPI register structures */
+
+	acpi_tb_setup_fadt_registers();
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_convert_fadt
+ *
+ * PARAMETERS:  None, uses acpi_gbl_FADT
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Converts all versions of the FADT to a common internal format.
+ *              Expand 32-bit addresses to 64-bit as necessary.
+ *
+ * NOTE:        acpi_gbl_FADT must be of size (struct acpi_table_fadt),
+ *              and must contain a copy of the actual FADT.
+ *
+ * Notes on 64-bit register addresses:
+ *
+ * After this FADT conversion, later ACPICA code will only use the 64-bit "X"
+ * fields of the FADT for all ACPI register addresses.
+ *
+ * The 64-bit "X" fields are optional extensions to the original 32-bit FADT
+ * V1.0 fields. Even if they are present in the FADT, they are optional and
+ * are unused if the BIOS sets them to zero. Therefore, we must copy/expand
+ * 32-bit V1.0 fields if the corresponding X field is zero.
+ *
+ * For ACPI 1.0 FADTs, all 32-bit address fields are expanded to the
+ * corresponding "X" fields in the internal FADT.
+ *
+ * For ACPI 2.0+ FADTs, all valid (non-zero) 32-bit address fields are expanded
+ * to the corresponding 64-bit X fields. For compatibility with other ACPI
+ * implementations, we ignore the 64-bit field if the 32-bit field is valid,
+ * regardless of whether the host OS is 32-bit or 64-bit.
+ *
+ ******************************************************************************/
+
+static void acpi_tb_convert_fadt(void)
+{
+	struct acpi_generic_address *address64;
+	u32 address32;
+	u32 i;
+
+	/* Update the local FADT table header length */
+
+	acpi_gbl_FADT.header.length = sizeof(struct acpi_table_fadt);
+
+	/*
+	 * Expand the 32-bit FACS and DSDT addresses to 64-bit as necessary.
+	 * Later code will always use the X 64-bit field.
+	 */
+	if (!acpi_gbl_FADT.Xfacs) {
+		acpi_gbl_FADT.Xfacs = (u64)acpi_gbl_FADT.facs;
+	}
+	if (!acpi_gbl_FADT.Xdsdt) {
+		acpi_gbl_FADT.Xdsdt = (u64)acpi_gbl_FADT.dsdt;
+	}
+
+	/*
+	 * For ACPI 1.0 FADTs (revision 1 or 2), ensure that reserved fields which
+	 * should be zero are indeed zero. This will workaround BIOSs that
+	 * inadvertently place values in these fields.
+	 *
+	 * The ACPI 1.0 reserved fields that will be zeroed are the bytes located
+	 * at offset 45, 55, 95, and the word located at offset 109, 110.
+	 *
+	 * Note: The FADT revision value is unreliable. Only the length can be
+	 * trusted.
+	 */
+	if (acpi_gbl_FADT.header.length <= ACPI_FADT_V2_SIZE) {
+		acpi_gbl_FADT.preferred_profile = 0;
+		acpi_gbl_FADT.pstate_control = 0;
+		acpi_gbl_FADT.cst_control = 0;
+		acpi_gbl_FADT.boot_flags = 0;
+	}
+
+	/*
+	 * Expand the ACPI 1.0 32-bit addresses to the ACPI 2.0 64-bit "X"
+	 * generic address structures as necessary. Later code will always use
+	 * the 64-bit address structures.
+	 *
+	 * March 2009:
+	 * We now always use the 32-bit address if it is valid (non-null). This
+	 * is not in accordance with the ACPI specification which states that
+	 * the 64-bit address supersedes the 32-bit version, but we do this for
+	 * compatibility with other ACPI implementations. Most notably, in the
+	 * case where both the 32 and 64 versions are non-null, we use the 32-bit
+	 * version. This is the only address that is guaranteed to have been
+	 * tested by the BIOS manufacturer.
+	 */
+	for (i = 0; i < ACPI_FADT_INFO_ENTRIES; i++) {
+		address32 = *ACPI_ADD_PTR(u32,
+					  &acpi_gbl_FADT,
+					  fadt_info_table[i].address32);
+
+		address64 = ACPI_ADD_PTR(struct acpi_generic_address,
+					 &acpi_gbl_FADT,
+					 fadt_info_table[i].address64);
+
+		/*
+		 * If both 32- and 64-bit addresses are valid (non-zero),
+		 * they must match.
+		 */
+		if (address64->address && address32 &&
+		    (address64->address != (u64)address32)) {
+			ACPI_ERROR((AE_INFO,
+				    "32/64X address mismatch in %s: 0x%8.8X/0x%8.8X%8.8X, using 32",
+				    fadt_info_table[i].name, address32,
+				    ACPI_FORMAT_UINT64(address64->address)));
+		}
+
+		/* Always use 32-bit address if it is valid (non-null) */
+
+		if (address32) {
+			/*
+			 * Copy the 32-bit address to the 64-bit GAS structure. The
+			 * Space ID is always I/O for 32-bit legacy address fields
+			 */
+			acpi_tb_init_generic_address(address64,
+						     ACPI_ADR_SPACE_SYSTEM_IO,
+						     *ACPI_ADD_PTR(u8,
+								   &acpi_gbl_FADT,
+								   fadt_info_table
+								   [i].length),
+						     (u64)address32);
+		}
+	}
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_validate_fadt
+ *
+ * PARAMETERS:  Table           - Pointer to the FADT to be validated
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Validate various important fields within the FADT. If a problem
+ *              is found, issue a message, but no status is returned.
+ *              Used by both the table manager and the disassembler.
+ *
+ * Possible additional checks:
+ * (acpi_gbl_FADT.pm1_event_length >= 4)
+ * (acpi_gbl_FADT.pm1_control_length >= 2)
+ * (acpi_gbl_FADT.pm_timer_length >= 4)
+ * Gpe block lengths must be multiple of 2
+ *
+ ******************************************************************************/
+
+static void acpi_tb_validate_fadt(void)
+{
+	char *name;
+	struct acpi_generic_address *address64;
+	u8 length;
+	u32 i;
+
+	/*
+	 * Check for FACS and DSDT address mismatches. An address mismatch between
+	 * the 32-bit and 64-bit address fields (FIRMWARE_CTRL/X_FIRMWARE_CTRL and
+	 * DSDT/X_DSDT) would indicate the presence of two FACS or two DSDT tables.
+	 */
+	if (acpi_gbl_FADT.facs &&
+	    (acpi_gbl_FADT.Xfacs != (u64)acpi_gbl_FADT.facs)) {
+		ACPI_WARNING((AE_INFO,
+			      "32/64X FACS address mismatch in FADT - "
+			      "0x%8.8X/0x%8.8X%8.8X, using 32",
+			      acpi_gbl_FADT.facs,
+			      ACPI_FORMAT_UINT64(acpi_gbl_FADT.Xfacs)));
+
+		acpi_gbl_FADT.Xfacs = (u64)acpi_gbl_FADT.facs;
+	}
+
+	if (acpi_gbl_FADT.dsdt &&
+	    (acpi_gbl_FADT.Xdsdt != (u64)acpi_gbl_FADT.dsdt)) {
+		ACPI_WARNING((AE_INFO,
+			      "32/64X DSDT address mismatch in FADT - "
+			      "0x%8.8X/0x%8.8X%8.8X, using 32",
+			      acpi_gbl_FADT.dsdt,
+			      ACPI_FORMAT_UINT64(acpi_gbl_FADT.Xdsdt)));
+
+		acpi_gbl_FADT.Xdsdt = (u64)acpi_gbl_FADT.dsdt;
+	}
+
+	/* If Hardware Reduced flag is set, we are all done */
+
+	if (acpi_gbl_reduced_hardware) {
+		return;
+	}
+
+	/* Examine all of the 64-bit extended address fields (X fields) */
+
+	for (i = 0; i < ACPI_FADT_INFO_ENTRIES; i++) {
+		/*
+		 * Generate pointer to the 64-bit address, get the register
+		 * length (width) and the register name
+		 */
+		address64 = ACPI_ADD_PTR(struct acpi_generic_address,
+					 &acpi_gbl_FADT,
+					 fadt_info_table[i].address64);
+		length =
+		    *ACPI_ADD_PTR(u8, &acpi_gbl_FADT,
+				  fadt_info_table[i].length);
+		name = fadt_info_table[i].name;
+
+		/*
+		 * For each extended field, check for length mismatch between the
+		 * legacy length field and the corresponding 64-bit X length field.
+		 */
+		if (address64->address &&
+		    (address64->bit_width != ACPI_MUL_8(length))) {
+			ACPI_WARNING((AE_INFO,
+				      "32/64X length mismatch in %s: %u/%u",
+				      name, ACPI_MUL_8(length),
+				      address64->bit_width));
+		}
+
+		if (fadt_info_table[i].type & ACPI_FADT_REQUIRED) {
+			/*
+			 * Field is required (Pm1a_event, Pm1a_control, pm_timer).
+			 * Both the address and length must be non-zero.
+			 */
+			if (!address64->address || !length) {
+				ACPI_ERROR((AE_INFO,
+					    "Required field %s has zero address and/or length:"
+					    " 0x%8.8X%8.8X/0x%X",
+					    name,
+					    ACPI_FORMAT_UINT64(address64->
+							       address),
+					    length));
+			}
+		} else if (fadt_info_table[i].type & ACPI_FADT_SEPARATE_LENGTH) {
+			/*
+			 * Field is optional (PM2Control, GPE0, GPE1) AND has its own
+			 * length field. If present, both the address and length must
+			 * be valid.
+			 */
+			if ((address64->address && !length) ||
+			    (!address64->address && length)) {
+				ACPI_WARNING((AE_INFO,
+					      "Optional field %s has zero address or length: "
+					      "0x%8.8X%8.8X/0x%X",
+					      name,
+					      ACPI_FORMAT_UINT64(address64->
+								 address),
+					      length));
+			}
+		}
+	}
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_setup_fadt_registers
+ *
+ * PARAMETERS:  None, uses acpi_gbl_FADT.
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Initialize global ACPI PM1 register definitions. Optionally,
+ *              force FADT register definitions to their default lengths.
+ *
+ ******************************************************************************/
+
+static void acpi_tb_setup_fadt_registers(void)
+{
+	struct acpi_generic_address *target64;
+	struct acpi_generic_address *source64;
+	u8 pm1_register_byte_width;
+	u32 i;
+
+	/*
+	 * Optionally check all register lengths against the default values and
+	 * update them if they are incorrect.
+	 */
+	if (acpi_gbl_use_default_register_widths) {
+		for (i = 0; i < ACPI_FADT_INFO_ENTRIES; i++) {
+			target64 =
+			    ACPI_ADD_PTR(struct acpi_generic_address,
+					 &acpi_gbl_FADT,
+					 fadt_info_table[i].address64);
+
+			/*
+			 * If a valid register (Address != 0) and the (default_length > 0)
+			 * (Not a GPE register), then check the width against the default.
+			 */
+			if ((target64->address) &&
+			    (fadt_info_table[i].default_length > 0) &&
+			    (fadt_info_table[i].default_length !=
+			     target64->bit_width)) {
+				ACPI_WARNING((AE_INFO,
+					      "Invalid length for %s: %u, using default %u",
+					      fadt_info_table[i].name,
+					      target64->bit_width,
+					      fadt_info_table[i].
+					      default_length));
+
+				/* Incorrect size, set width to the default */
+
+				target64->bit_width =
+				    fadt_info_table[i].default_length;
+			}
+		}
+	}
+
+	/*
+	 * Get the length of the individual PM1 registers (enable and status).
+	 * Each register is defined to be (event block length / 2). Extra divide
+	 * by 8 converts bits to bytes.
+	 */
+	pm1_register_byte_width = (u8)
+	    ACPI_DIV_16(acpi_gbl_FADT.xpm1a_event_block.bit_width);
+
+	/*
+	 * Calculate separate GAS structs for the PM1x (A/B) Status and Enable
+	 * registers. These addresses do not appear (directly) in the FADT, so it
+	 * is useful to pre-calculate them from the PM1 Event Block definitions.
+	 *
+	 * The PM event blocks are split into two register blocks, first is the
+	 * PM Status Register block, followed immediately by the PM Enable
+	 * Register block. Each is of length (pm1_event_length/2)
+	 *
+	 * Note: The PM1A event block is required by the ACPI specification.
+	 * However, the PM1B event block is optional and is rarely, if ever,
+	 * used.
+	 */
+
+	for (i = 0; i < ACPI_FADT_PM_INFO_ENTRIES; i++) {
+		source64 =
+		    ACPI_ADD_PTR(struct acpi_generic_address, &acpi_gbl_FADT,
+				 fadt_pm_info_table[i].source);
+
+		if (source64->address) {
+			acpi_tb_init_generic_address(fadt_pm_info_table[i].
+						     target, source64->space_id,
+						     pm1_register_byte_width,
+						     source64->address +
+						     (fadt_pm_info_table[i].
+						      register_num *
+						      pm1_register_byte_width));
+		}
+	}
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/tbfind.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/tbfind.c
new file mode 100644
index 00000000..4903e36e
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/tbfind.c
@@ -0,0 +1,140 @@
+/******************************************************************************
+ *
+ * Module Name: tbfind   - find table
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "actables.h"
+
+#define _COMPONENT          ACPI_TABLES
+ACPI_MODULE_NAME("tbfind")
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_find_table
+ *
+ * PARAMETERS:  Signature           - String with ACPI table signature
+ *              oem_id              - String with the table OEM ID
+ *              oem_table_id        - String with the OEM Table ID
+ *              table_index         - Where the table index is returned
+ *
+ * RETURN:      Status and table index
+ *
+ * DESCRIPTION: Find an ACPI table (in the RSDT/XSDT) that matches the
+ *              Signature, OEM ID and OEM Table ID. Returns an index that can
+ *              be used to get the table header or entire table.
+ *
+ ******************************************************************************/
+acpi_status
+acpi_tb_find_table(char *signature,
+		   char *oem_id, char *oem_table_id, u32 *table_index)
+{
+	u32 i;
+	acpi_status status;
+	struct acpi_table_header header;
+
+	ACPI_FUNCTION_TRACE(tb_find_table);
+
+	/* Normalize the input strings */
+
+	ACPI_MEMSET(&header, 0, sizeof(struct acpi_table_header));
+	ACPI_STRNCPY(header.signature, signature, ACPI_NAME_SIZE);
+	ACPI_STRNCPY(header.oem_id, oem_id, ACPI_OEM_ID_SIZE);
+	ACPI_STRNCPY(header.oem_table_id, oem_table_id, ACPI_OEM_TABLE_ID_SIZE);
+
+	/* Search for the table */
+
+	for (i = 0; i < acpi_gbl_root_table_list.current_table_count; ++i) {
+		if (ACPI_MEMCMP(&(acpi_gbl_root_table_list.tables[i].signature),
+				header.signature, ACPI_NAME_SIZE)) {
+
+			/* Not the requested table */
+
+			continue;
+		}
+
+		/* Table with matching signature has been found */
+
+		if (!acpi_gbl_root_table_list.tables[i].pointer) {
+
+			/* Table is not currently mapped, map it */
+
+			status =
+			    acpi_tb_verify_table(&acpi_gbl_root_table_list.
+						 tables[i]);
+			if (ACPI_FAILURE(status)) {
+				return_ACPI_STATUS(status);
+			}
+
+			if (!acpi_gbl_root_table_list.tables[i].pointer) {
+				continue;
+			}
+		}
+
+		/* Check for table match on all IDs */
+
+		if (!ACPI_MEMCMP
+		    (acpi_gbl_root_table_list.tables[i].pointer->signature,
+		     header.signature, ACPI_NAME_SIZE) && (!oem_id[0]
+							   ||
+							   !ACPI_MEMCMP
+							   (acpi_gbl_root_table_list.
+							    tables[i].pointer->
+							    oem_id,
+							    header.oem_id,
+							    ACPI_OEM_ID_SIZE))
+		    && (!oem_table_id[0]
+			|| !ACPI_MEMCMP(acpi_gbl_root_table_list.tables[i].
+					pointer->oem_table_id,
+					header.oem_table_id,
+					ACPI_OEM_TABLE_ID_SIZE))) {
+			*table_index = i;
+
+			ACPI_DEBUG_PRINT((ACPI_DB_TABLES,
+					  "Found table [%4.4s]\n",
+					  header.signature));
+			return_ACPI_STATUS(AE_OK);
+		}
+	}
+
+	return_ACPI_STATUS(AE_NOT_FOUND);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/tbinstal.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/tbinstal.c
new file mode 100644
index 00000000..b2c506fb
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/tbinstal.c
@@ -0,0 +1,653 @@
+/******************************************************************************
+ *
+ * Module Name: tbinstal - ACPI table installation and removal
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acnamesp.h"
+#include "actables.h"
+
+#define _COMPONENT          ACPI_TABLES
+ACPI_MODULE_NAME("tbinstal")
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_verify_table
+ *
+ * PARAMETERS:  table_desc          - table
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: this function is called to verify and map table
+ *
+ *****************************************************************************/
+acpi_status acpi_tb_verify_table(struct acpi_table_desc *table_desc)
+{
+	acpi_status status = AE_OK;
+
+	ACPI_FUNCTION_TRACE(tb_verify_table);
+
+	/* Map the table if necessary */
+
+	if (!table_desc->pointer) {
+		if ((table_desc->flags & ACPI_TABLE_ORIGIN_MASK) ==
+		    ACPI_TABLE_ORIGIN_MAPPED) {
+			table_desc->pointer =
+			    acpi_os_map_memory(table_desc->address,
+					       table_desc->length);
+		}
+
+		if (!table_desc->pointer) {
+			return_ACPI_STATUS(AE_NO_MEMORY);
+		}
+	}
+
+	/* FACS is the odd table, has no standard ACPI header and no checksum */
+
+	if (!ACPI_COMPARE_NAME(&table_desc->signature, ACPI_SIG_FACS)) {
+
+		/* Always calculate checksum, ignore bad checksum if requested */
+
+		status =
+		    acpi_tb_verify_checksum(table_desc->pointer,
+					    table_desc->length);
+	}
+
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_add_table
+ *
+ * PARAMETERS:  table_desc          - Table descriptor
+ *              table_index         - Where the table index is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: This function is called to add an ACPI table. It is used to
+ *              dynamically load tables via the Load and load_table AML
+ *              operators.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_tb_add_table(struct acpi_table_desc *table_desc, u32 *table_index)
+{
+	u32 i;
+	acpi_status status = AE_OK;
+	struct acpi_table_header *override_table = NULL;
+
+	ACPI_FUNCTION_TRACE(tb_add_table);
+
+	if (!table_desc->pointer) {
+		status = acpi_tb_verify_table(table_desc);
+		if (ACPI_FAILURE(status) || !table_desc->pointer) {
+			return_ACPI_STATUS(status);
+		}
+	}
+
+	/*
+	 * Validate the incoming table signature.
+	 *
+	 * 1) Originally, we checked the table signature for "SSDT" or "PSDT".
+	 * 2) We added support for OEMx tables, signature "OEM".
+	 * 3) Valid tables were encountered with a null signature, so we just
+	 *    gave up on validating the signature, (05/2008).
+	 * 4) We encountered non-AML tables such as the MADT, which caused
+	 *    interpreter errors and kernel faults. So now, we once again allow
+	 *    only "SSDT", "OEMx", and now, also a null signature. (05/2011).
+	 */
+	if ((table_desc->pointer->signature[0] != 0x00) &&
+	    (!ACPI_COMPARE_NAME(table_desc->pointer->signature, ACPI_SIG_SSDT))
+	    && (ACPI_STRNCMP(table_desc->pointer->signature, "OEM", 3))) {
+		ACPI_ERROR((AE_INFO,
+			    "Table has invalid signature [%4.4s] (0x%8.8X), must be SSDT or OEMx",
+			    acpi_ut_valid_acpi_name(*(u32 *)table_desc->
+						    pointer->
+						    signature) ? table_desc->
+			    pointer->signature : "????",
+			    *(u32 *)table_desc->pointer->signature));
+
+		return_ACPI_STATUS(AE_BAD_SIGNATURE);
+	}
+
+	(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);
+
+	/* Check if table is already registered */
+
+	for (i = 0; i < acpi_gbl_root_table_list.current_table_count; ++i) {
+		if (!acpi_gbl_root_table_list.tables[i].pointer) {
+			status =
+			    acpi_tb_verify_table(&acpi_gbl_root_table_list.
+						 tables[i]);
+			if (ACPI_FAILURE(status)
+			    || !acpi_gbl_root_table_list.tables[i].pointer) {
+				continue;
+			}
+		}
+
+		/*
+		 * Check for a table match on the entire table length,
+		 * not just the header.
+		 */
+		if (table_desc->length !=
+		    acpi_gbl_root_table_list.tables[i].length) {
+			continue;
+		}
+
+		if (ACPI_MEMCMP(table_desc->pointer,
+				acpi_gbl_root_table_list.tables[i].pointer,
+				acpi_gbl_root_table_list.tables[i].length)) {
+			continue;
+		}
+
+		/*
+		 * Note: the current mechanism does not unregister a table if it is
+		 * dynamically unloaded. The related namespace entries are deleted,
+		 * but the table remains in the root table list.
+		 *
+		 * The assumption here is that the number of different tables that
+		 * will be loaded is actually small, and there is minimal overhead
+		 * in just keeping the table in case it is needed again.
+		 *
+		 * If this assumption changes in the future (perhaps on large
+		 * machines with many table load/unload operations), tables will
+		 * need to be unregistered when they are unloaded, and slots in the
+		 * root table list should be reused when empty.
+		 */
+
+		/*
+		 * Table is already registered.
+		 * We can delete the table that was passed as a parameter.
+		 */
+		acpi_tb_delete_table(table_desc);
+		*table_index = i;
+
+		if (acpi_gbl_root_table_list.tables[i].
+		    flags & ACPI_TABLE_IS_LOADED) {
+
+			/* Table is still loaded, this is an error */
+
+			status = AE_ALREADY_EXISTS;
+			goto release;
+		} else {
+			/* Table was unloaded, allow it to be reloaded */
+
+			table_desc->pointer =
+			    acpi_gbl_root_table_list.tables[i].pointer;
+			table_desc->address =
+			    acpi_gbl_root_table_list.tables[i].address;
+			status = AE_OK;
+			goto print_header;
+		}
+	}
+
+	/*
+	 * ACPI Table Override:
+	 * Allow the host to override dynamically loaded tables.
+	 */
+	status = acpi_os_table_override(table_desc->pointer, &override_table);
+	if (ACPI_SUCCESS(status) && override_table) {
+		ACPI_INFO((AE_INFO,
+			   "%4.4s @ 0x%p Table override, replaced with:",
+			   table_desc->pointer->signature,
+			   ACPI_CAST_PTR(void, table_desc->address)));
+
+		/* We can delete the table that was passed as a parameter */
+
+		acpi_tb_delete_table(table_desc);
+
+		/* Setup descriptor for the new table */
+
+		table_desc->address = ACPI_PTR_TO_PHYSADDR(override_table);
+		table_desc->pointer = override_table;
+		table_desc->length = override_table->length;
+		table_desc->flags = ACPI_TABLE_ORIGIN_OVERRIDE;
+	}
+
+	/* Add the table to the global root table list */
+
+	status = acpi_tb_store_table(table_desc->address, table_desc->pointer,
+				     table_desc->length, table_desc->flags,
+				     table_index);
+	if (ACPI_FAILURE(status)) {
+		goto release;
+	}
+
+      print_header:
+	acpi_tb_print_table_header(table_desc->address, table_desc->pointer);
+
+      release:
+	(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_resize_root_table_list
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Expand the size of global table array
+ *
+ ******************************************************************************/
+
+acpi_status acpi_tb_resize_root_table_list(void)
+{
+	struct acpi_table_desc *tables;
+
+	ACPI_FUNCTION_TRACE(tb_resize_root_table_list);
+
+	/* allow_resize flag is a parameter to acpi_initialize_tables */
+
+	if (!(acpi_gbl_root_table_list.flags & ACPI_ROOT_ALLOW_RESIZE)) {
+		ACPI_ERROR((AE_INFO,
+			    "Resize of Root Table Array is not allowed"));
+		return_ACPI_STATUS(AE_SUPPORT);
+	}
+
+	/* Increase the Table Array size */
+
+	tables = ACPI_ALLOCATE_ZEROED(((acpi_size) acpi_gbl_root_table_list.
+				       max_table_count +
+				       ACPI_ROOT_TABLE_SIZE_INCREMENT) *
+				      sizeof(struct acpi_table_desc));
+	if (!tables) {
+		ACPI_ERROR((AE_INFO,
+			    "Could not allocate new root table array"));
+		return_ACPI_STATUS(AE_NO_MEMORY);
+	}
+
+	/* Copy and free the previous table array */
+
+	if (acpi_gbl_root_table_list.tables) {
+		ACPI_MEMCPY(tables, acpi_gbl_root_table_list.tables,
+			    (acpi_size) acpi_gbl_root_table_list.
+			    max_table_count * sizeof(struct acpi_table_desc));
+
+		if (acpi_gbl_root_table_list.flags & ACPI_ROOT_ORIGIN_ALLOCATED) {
+			ACPI_FREE(acpi_gbl_root_table_list.tables);
+		}
+	}
+
+	acpi_gbl_root_table_list.tables = tables;
+	acpi_gbl_root_table_list.max_table_count +=
+	    ACPI_ROOT_TABLE_SIZE_INCREMENT;
+	acpi_gbl_root_table_list.flags |= (u8)ACPI_ROOT_ORIGIN_ALLOCATED;
+
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_store_table
+ *
+ * PARAMETERS:  Address             - Table address
+ *              Table               - Table header
+ *              Length              - Table length
+ *              Flags               - flags
+ *
+ * RETURN:      Status and table index.
+ *
+ * DESCRIPTION: Add an ACPI table to the global table list
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_tb_store_table(acpi_physical_address address,
+		    struct acpi_table_header *table,
+		    u32 length, u8 flags, u32 *table_index)
+{
+	acpi_status status;
+	struct acpi_table_desc *new_table;
+
+	/* Ensure that there is room for the table in the Root Table List */
+
+	if (acpi_gbl_root_table_list.current_table_count >=
+	    acpi_gbl_root_table_list.max_table_count) {
+		status = acpi_tb_resize_root_table_list();
+		if (ACPI_FAILURE(status)) {
+			return (status);
+		}
+	}
+
+	new_table =
+	    &acpi_gbl_root_table_list.tables[acpi_gbl_root_table_list.
+					     current_table_count];
+
+	/* Initialize added table */
+
+	new_table->address = address;
+	new_table->pointer = table;
+	new_table->length = length;
+	new_table->owner_id = 0;
+	new_table->flags = flags;
+
+	ACPI_MOVE_32_TO_32(&new_table->signature, table->signature);
+
+	*table_index = acpi_gbl_root_table_list.current_table_count;
+	acpi_gbl_root_table_list.current_table_count++;
+	return (AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_delete_table
+ *
+ * PARAMETERS:  table_index         - Table index
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Delete one internal ACPI table
+ *
+ ******************************************************************************/
+
+void acpi_tb_delete_table(struct acpi_table_desc *table_desc)
+{
+
+	/* Table must be mapped or allocated */
+
+	if (!table_desc->pointer) {
+		return;
+	}
+
+	switch (table_desc->flags & ACPI_TABLE_ORIGIN_MASK) {
+	case ACPI_TABLE_ORIGIN_MAPPED:
+		acpi_os_unmap_memory(table_desc->pointer, table_desc->length);
+		break;
+
+	case ACPI_TABLE_ORIGIN_ALLOCATED:
+		ACPI_FREE(table_desc->pointer);
+		break;
+
+	default:
+		break;
+	}
+
+	table_desc->pointer = NULL;
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_terminate
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Delete all internal ACPI tables
+ *
+ ******************************************************************************/
+
+void acpi_tb_terminate(void)
+{
+	u32 i;
+
+	ACPI_FUNCTION_TRACE(tb_terminate);
+
+	(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);
+
+	/* Delete the individual tables */
+
+	for (i = 0; i < acpi_gbl_root_table_list.current_table_count; i++) {
+		acpi_tb_delete_table(&acpi_gbl_root_table_list.tables[i]);
+	}
+
+	/*
+	 * Delete the root table array if allocated locally. Array cannot be
+	 * mapped, so we don't need to check for that flag.
+	 */
+	if (acpi_gbl_root_table_list.flags & ACPI_ROOT_ORIGIN_ALLOCATED) {
+		ACPI_FREE(acpi_gbl_root_table_list.tables);
+	}
+
+	acpi_gbl_root_table_list.tables = NULL;
+	acpi_gbl_root_table_list.flags = 0;
+	acpi_gbl_root_table_list.current_table_count = 0;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "ACPI Tables freed\n"));
+	(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_delete_namespace_by_owner
+ *
+ * PARAMETERS:  table_index         - Table index
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Delete all namespace objects created when this table was loaded.
+ *
+ ******************************************************************************/
+
+acpi_status acpi_tb_delete_namespace_by_owner(u32 table_index)
+{
+	acpi_owner_id owner_id;
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(tb_delete_namespace_by_owner);
+
+	status = acpi_ut_acquire_mutex(ACPI_MTX_TABLES);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	if (table_index >= acpi_gbl_root_table_list.current_table_count) {
+
+		/* The table index does not exist */
+
+		(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);
+		return_ACPI_STATUS(AE_NOT_EXIST);
+	}
+
+	/* Get the owner ID for this table, used to delete namespace nodes */
+
+	owner_id = acpi_gbl_root_table_list.tables[table_index].owner_id;
+	(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);
+
+	/*
+	 * Need to acquire the namespace writer lock to prevent interference
+	 * with any concurrent namespace walks. The interpreter must be
+	 * released during the deletion since the acquisition of the deletion
+	 * lock may block, and also since the execution of a namespace walk
+	 * must be allowed to use the interpreter.
+	 */
+	(void)acpi_ut_release_mutex(ACPI_MTX_INTERPRETER);
+	status = acpi_ut_acquire_write_lock(&acpi_gbl_namespace_rw_lock);
+
+	acpi_ns_delete_namespace_by_owner(owner_id);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	acpi_ut_release_write_lock(&acpi_gbl_namespace_rw_lock);
+
+	status = acpi_ut_acquire_mutex(ACPI_MTX_INTERPRETER);
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_allocate_owner_id
+ *
+ * PARAMETERS:  table_index         - Table index
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Allocates owner_id in table_desc
+ *
+ ******************************************************************************/
+
+acpi_status acpi_tb_allocate_owner_id(u32 table_index)
+{
+	acpi_status status = AE_BAD_PARAMETER;
+
+	ACPI_FUNCTION_TRACE(tb_allocate_owner_id);
+
+	(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);
+	if (table_index < acpi_gbl_root_table_list.current_table_count) {
+		status = acpi_ut_allocate_owner_id
+		    (&(acpi_gbl_root_table_list.tables[table_index].owner_id));
+	}
+
+	(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_release_owner_id
+ *
+ * PARAMETERS:  table_index         - Table index
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Releases owner_id in table_desc
+ *
+ ******************************************************************************/
+
+acpi_status acpi_tb_release_owner_id(u32 table_index)
+{
+	acpi_status status = AE_BAD_PARAMETER;
+
+	ACPI_FUNCTION_TRACE(tb_release_owner_id);
+
+	(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);
+	if (table_index < acpi_gbl_root_table_list.current_table_count) {
+		acpi_ut_release_owner_id(&
+					 (acpi_gbl_root_table_list.
+					  tables[table_index].owner_id));
+		status = AE_OK;
+	}
+
+	(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_get_owner_id
+ *
+ * PARAMETERS:  table_index         - Table index
+ *              owner_id            - Where the table owner_id is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: returns owner_id for the ACPI table
+ *
+ ******************************************************************************/
+
+acpi_status acpi_tb_get_owner_id(u32 table_index, acpi_owner_id * owner_id)
+{
+	acpi_status status = AE_BAD_PARAMETER;
+
+	ACPI_FUNCTION_TRACE(tb_get_owner_id);
+
+	(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);
+	if (table_index < acpi_gbl_root_table_list.current_table_count) {
+		*owner_id =
+		    acpi_gbl_root_table_list.tables[table_index].owner_id;
+		status = AE_OK;
+	}
+
+	(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_is_table_loaded
+ *
+ * PARAMETERS:  table_index         - Table index
+ *
+ * RETURN:      Table Loaded Flag
+ *
+ ******************************************************************************/
+
+u8 acpi_tb_is_table_loaded(u32 table_index)
+{
+	u8 is_loaded = FALSE;
+
+	(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);
+	if (table_index < acpi_gbl_root_table_list.current_table_count) {
+		is_loaded = (u8)
+		    (acpi_gbl_root_table_list.tables[table_index].flags &
+		     ACPI_TABLE_IS_LOADED);
+	}
+
+	(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);
+	return (is_loaded);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_set_table_loaded_flag
+ *
+ * PARAMETERS:  table_index         - Table index
+ *              is_loaded           - TRUE if table is loaded, FALSE otherwise
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Sets the table loaded flag to either TRUE or FALSE.
+ *
+ ******************************************************************************/
+
+void acpi_tb_set_table_loaded_flag(u32 table_index, u8 is_loaded)
+{
+
+	(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);
+	if (table_index < acpi_gbl_root_table_list.current_table_count) {
+		if (is_loaded) {
+			acpi_gbl_root_table_list.tables[table_index].flags |=
+			    ACPI_TABLE_IS_LOADED;
+		} else {
+			acpi_gbl_root_table_list.tables[table_index].flags &=
+			    ~ACPI_TABLE_IS_LOADED;
+		}
+	}
+
+	(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/tbutils.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/tbutils.c
new file mode 100644
index 00000000..c1f5c241
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/tbutils.c
@@ -0,0 +1,695 @@
+/******************************************************************************
+ *
+ * Module Name: tbutils   - table utilities
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "actables.h"
+
+#define _COMPONENT          ACPI_TABLES
+ACPI_MODULE_NAME("tbutils")
+
+/* Local prototypes */
+static void acpi_tb_fix_string(char *string, acpi_size length);
+
+static void
+acpi_tb_cleanup_table_header(struct acpi_table_header *out_header,
+			     struct acpi_table_header *header);
+
+static acpi_physical_address
+acpi_tb_get_root_table_entry(u8 *table_entry, u32 table_entry_size);
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_initialize_facs
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Create a permanent mapping for the FADT and save it in a global
+ *              for accessing the Global Lock and Firmware Waking Vector
+ *
+ ******************************************************************************/
+
+acpi_status acpi_tb_initialize_facs(void)
+{
+	acpi_status status;
+
+	/* If Hardware Reduced flag is set, there is no FACS */
+
+	if (acpi_gbl_reduced_hardware) {
+		acpi_gbl_FACS = NULL;
+		return (AE_OK);
+	}
+
+	status = acpi_get_table_by_index(ACPI_TABLE_INDEX_FACS,
+					 ACPI_CAST_INDIRECT_PTR(struct
+								acpi_table_header,
+								&acpi_gbl_FACS));
+	return (status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_tables_loaded
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      TRUE if required ACPI tables are loaded
+ *
+ * DESCRIPTION: Determine if the minimum required ACPI tables are present
+ *              (FADT, FACS, DSDT)
+ *
+ ******************************************************************************/
+
+u8 acpi_tb_tables_loaded(void)
+{
+
+	if (acpi_gbl_root_table_list.current_table_count >= 3) {
+		return (TRUE);
+	}
+
+	return (FALSE);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_fix_string
+ *
+ * PARAMETERS:  String              - String to be repaired
+ *              Length              - Maximum length
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Replace every non-printable or non-ascii byte in the string
+ *              with a question mark '?'.
+ *
+ ******************************************************************************/
+
+static void acpi_tb_fix_string(char *string, acpi_size length)
+{
+
+	while (length && *string) {
+		if (!ACPI_IS_PRINT(*string)) {
+			*string = '?';
+		}
+		string++;
+		length--;
+	}
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_cleanup_table_header
+ *
+ * PARAMETERS:  out_header          - Where the cleaned header is returned
+ *              Header              - Input ACPI table header
+ *
+ * RETURN:      Returns the cleaned header in out_header
+ *
+ * DESCRIPTION: Copy the table header and ensure that all "string" fields in
+ *              the header consist of printable characters.
+ *
+ ******************************************************************************/
+
+static void
+acpi_tb_cleanup_table_header(struct acpi_table_header *out_header,
+			     struct acpi_table_header *header)
+{
+
+	ACPI_MEMCPY(out_header, header, sizeof(struct acpi_table_header));
+
+	acpi_tb_fix_string(out_header->signature, ACPI_NAME_SIZE);
+	acpi_tb_fix_string(out_header->oem_id, ACPI_OEM_ID_SIZE);
+	acpi_tb_fix_string(out_header->oem_table_id, ACPI_OEM_TABLE_ID_SIZE);
+	acpi_tb_fix_string(out_header->asl_compiler_id, ACPI_NAME_SIZE);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_print_table_header
+ *
+ * PARAMETERS:  Address             - Table physical address
+ *              Header              - Table header
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Print an ACPI table header. Special cases for FACS and RSDP.
+ *
+ ******************************************************************************/
+
+void
+acpi_tb_print_table_header(acpi_physical_address address,
+			   struct acpi_table_header *header)
+{
+	struct acpi_table_header local_header;
+
+	/*
+	 * The reason that the Address is cast to a void pointer is so that we
+	 * can use %p which will work properly on both 32-bit and 64-bit hosts.
+	 */
+	if (ACPI_COMPARE_NAME(header->signature, ACPI_SIG_FACS)) {
+
+		/* FACS only has signature and length fields */
+
+		ACPI_INFO((AE_INFO, "%4.4s %p %05X",
+			   header->signature, ACPI_CAST_PTR(void, address),
+			   header->length));
+	} else if (ACPI_COMPARE_NAME(header->signature, ACPI_SIG_RSDP)) {
+
+		/* RSDP has no common fields */
+
+		ACPI_MEMCPY(local_header.oem_id,
+			    ACPI_CAST_PTR(struct acpi_table_rsdp,
+					  header)->oem_id, ACPI_OEM_ID_SIZE);
+		acpi_tb_fix_string(local_header.oem_id, ACPI_OEM_ID_SIZE);
+
+		ACPI_INFO((AE_INFO, "RSDP %p %05X (v%.2d %6.6s)",
+			   ACPI_CAST_PTR(void, address),
+			   (ACPI_CAST_PTR(struct acpi_table_rsdp, header)->
+			    revision >
+			    0) ? ACPI_CAST_PTR(struct acpi_table_rsdp,
+					       header)->length : 20,
+			   ACPI_CAST_PTR(struct acpi_table_rsdp,
+					 header)->revision,
+			   local_header.oem_id));
+	} else {
+		/* Standard ACPI table with full common header */
+
+		acpi_tb_cleanup_table_header(&local_header, header);
+
+		ACPI_INFO((AE_INFO,
+			   "%4.4s %p %05X (v%.2d %6.6s %8.8s %08X %4.4s %08X)",
+			   local_header.signature, ACPI_CAST_PTR(void, address),
+			   local_header.length, local_header.revision,
+			   local_header.oem_id, local_header.oem_table_id,
+			   local_header.oem_revision,
+			   local_header.asl_compiler_id,
+			   local_header.asl_compiler_revision));
+	}
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_validate_checksum
+ *
+ * PARAMETERS:  Table               - ACPI table to verify
+ *              Length              - Length of entire table
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Verifies that the table checksums to zero. Optionally returns
+ *              exception on bad checksum.
+ *
+ ******************************************************************************/
+
+acpi_status acpi_tb_verify_checksum(struct acpi_table_header *table, u32 length)
+{
+	u8 checksum;
+
+	/* Compute the checksum on the table */
+
+	checksum = acpi_tb_checksum(ACPI_CAST_PTR(u8, table), length);
+
+	/* Checksum ok? (should be zero) */
+
+	if (checksum) {
+		ACPI_WARNING((AE_INFO,
+			      "Incorrect checksum in table [%4.4s] - 0x%2.2X, should be 0x%2.2X",
+			      table->signature, table->checksum,
+			      (u8)(table->checksum - checksum)));
+
+#if (ACPI_CHECKSUM_ABORT)
+		return (AE_BAD_CHECKSUM);
+#endif
+	}
+
+	return (AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_checksum
+ *
+ * PARAMETERS:  Buffer          - Pointer to memory region to be checked
+ *              Length          - Length of this memory region
+ *
+ * RETURN:      Checksum (u8)
+ *
+ * DESCRIPTION: Calculates circular checksum of memory region.
+ *
+ ******************************************************************************/
+
+u8 acpi_tb_checksum(u8 *buffer, u32 length)
+{
+	u8 sum = 0;
+	u8 *end = buffer + length;
+
+	while (buffer < end) {
+		sum = (u8)(sum + *(buffer++));
+	}
+
+	return sum;
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_check_dsdt_header
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Quick compare to check validity of the DSDT. This will detect
+ *              if the DSDT has been replaced from outside the OS and/or if
+ *              the DSDT header has been corrupted.
+ *
+ ******************************************************************************/
+
+void acpi_tb_check_dsdt_header(void)
+{
+
+	/* Compare original length and checksum to current values */
+
+	if (acpi_gbl_original_dsdt_header.length != acpi_gbl_DSDT->length ||
+	    acpi_gbl_original_dsdt_header.checksum != acpi_gbl_DSDT->checksum) {
+		ACPI_ERROR((AE_INFO,
+			    "The DSDT has been corrupted or replaced - old, new headers below"));
+		acpi_tb_print_table_header(0, &acpi_gbl_original_dsdt_header);
+		acpi_tb_print_table_header(0, acpi_gbl_DSDT);
+
+		/* Disable further error messages */
+
+		acpi_gbl_original_dsdt_header.length = acpi_gbl_DSDT->length;
+		acpi_gbl_original_dsdt_header.checksum =
+		    acpi_gbl_DSDT->checksum;
+	}
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_copy_dsdt
+ *
+ * PARAMETERS:  table_desc          - Installed table to copy
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Implements a subsystem option to copy the DSDT to local memory.
+ *              Some very bad BIOSs are known to either corrupt the DSDT or
+ *              install a new, bad DSDT. This copy works around the problem.
+ *
+ ******************************************************************************/
+
+struct acpi_table_header *acpi_tb_copy_dsdt(u32 table_index)
+{
+	struct acpi_table_header *new_table;
+	struct acpi_table_desc *table_desc;
+
+	table_desc = &acpi_gbl_root_table_list.tables[table_index];
+
+	new_table = ACPI_ALLOCATE(table_desc->length);
+	if (!new_table) {
+		ACPI_ERROR((AE_INFO, "Could not copy DSDT of length 0x%X",
+			    table_desc->length));
+		return (NULL);
+	}
+
+	ACPI_MEMCPY(new_table, table_desc->pointer, table_desc->length);
+	acpi_tb_delete_table(table_desc);
+	table_desc->pointer = new_table;
+	table_desc->flags = ACPI_TABLE_ORIGIN_ALLOCATED;
+
+	ACPI_INFO((AE_INFO,
+		   "Forced DSDT copy: length 0x%05X copied locally, original unmapped",
+		   new_table->length));
+
+	return (new_table);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_install_table
+ *
+ * PARAMETERS:  Address                 - Physical address of DSDT or FACS
+ *              Signature               - Table signature, NULL if no need to
+ *                                        match
+ *              table_index             - Index into root table array
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Install an ACPI table into the global data structure. The
+ *              table override mechanism is implemented here to allow the host
+ *              OS to replace any table before it is installed in the root
+ *              table array.
+ *
+ ******************************************************************************/
+
+void
+acpi_tb_install_table(acpi_physical_address address,
+		      char *signature, u32 table_index)
+{
+	u8 flags;
+	acpi_status status;
+	struct acpi_table_header *table_to_install;
+	struct acpi_table_header *mapped_table;
+	struct acpi_table_header *override_table = NULL;
+
+	if (!address) {
+		ACPI_ERROR((AE_INFO,
+			    "Null physical address for ACPI table [%s]",
+			    signature));
+		return;
+	}
+
+	/* Map just the table header */
+
+	mapped_table =
+	    acpi_os_map_memory(address, sizeof(struct acpi_table_header));
+	if (!mapped_table) {
+		return;
+	}
+
+	/* If a particular signature is expected (DSDT/FACS), it must match */
+
+	if (signature && !ACPI_COMPARE_NAME(mapped_table->signature, signature)) {
+		ACPI_ERROR((AE_INFO,
+			    "Invalid signature 0x%X for ACPI table, expected [%s]",
+			    *ACPI_CAST_PTR(u32, mapped_table->signature),
+			    signature));
+		goto unmap_and_exit;
+	}
+
+	/*
+	 * ACPI Table Override:
+	 *
+	 * Before we install the table, let the host OS override it with a new
+	 * one if desired. Any table within the RSDT/XSDT can be replaced,
+	 * including the DSDT which is pointed to by the FADT.
+	 */
+	status = acpi_os_table_override(mapped_table, &override_table);
+	if (ACPI_SUCCESS(status) && override_table) {
+		ACPI_INFO((AE_INFO,
+			   "%4.4s @ 0x%p Table override, replaced with:",
+			   mapped_table->signature, ACPI_CAST_PTR(void,
+								  address)));
+
+		acpi_gbl_root_table_list.tables[table_index].pointer =
+		    override_table;
+		address = ACPI_PTR_TO_PHYSADDR(override_table);
+
+		table_to_install = override_table;
+		flags = ACPI_TABLE_ORIGIN_OVERRIDE;
+	} else {
+		table_to_install = mapped_table;
+		flags = ACPI_TABLE_ORIGIN_MAPPED;
+	}
+
+	/* Initialize the table entry */
+
+	acpi_gbl_root_table_list.tables[table_index].address = address;
+	acpi_gbl_root_table_list.tables[table_index].length =
+	    table_to_install->length;
+	acpi_gbl_root_table_list.tables[table_index].flags = flags;
+
+	ACPI_MOVE_32_TO_32(&
+			   (acpi_gbl_root_table_list.tables[table_index].
+			    signature), table_to_install->signature);
+
+	acpi_tb_print_table_header(address, table_to_install);
+
+	if (table_index == ACPI_TABLE_INDEX_DSDT) {
+
+		/* Global integer width is based upon revision of the DSDT */
+
+		acpi_ut_set_integer_width(table_to_install->revision);
+	}
+
+      unmap_and_exit:
+	acpi_os_unmap_memory(mapped_table, sizeof(struct acpi_table_header));
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_get_root_table_entry
+ *
+ * PARAMETERS:  table_entry         - Pointer to the RSDT/XSDT table entry
+ *              table_entry_size    - sizeof 32 or 64 (RSDT or XSDT)
+ *
+ * RETURN:      Physical address extracted from the root table
+ *
+ * DESCRIPTION: Get one root table entry. Handles 32-bit and 64-bit cases on
+ *              both 32-bit and 64-bit platforms
+ *
+ * NOTE:        acpi_physical_address is 32-bit on 32-bit platforms, 64-bit on
+ *              64-bit platforms.
+ *
+ ******************************************************************************/
+
+static acpi_physical_address
+acpi_tb_get_root_table_entry(u8 *table_entry, u32 table_entry_size)
+{
+	u64 address64;
+
+	/*
+	 * Get the table physical address (32-bit for RSDT, 64-bit for XSDT):
+	 * Note: Addresses are 32-bit aligned (not 64) in both RSDT and XSDT
+	 */
+	if (table_entry_size == sizeof(u32)) {
+		/*
+		 * 32-bit platform, RSDT: Return 32-bit table entry
+		 * 64-bit platform, RSDT: Expand 32-bit to 64-bit and return
+		 */
+		return ((acpi_physical_address)
+			(*ACPI_CAST_PTR(u32, table_entry)));
+	} else {
+		/*
+		 * 32-bit platform, XSDT: Truncate 64-bit to 32-bit and return
+		 * 64-bit platform, XSDT: Move (unaligned) 64-bit to local,
+		 *  return 64-bit
+		 */
+		ACPI_MOVE_64_TO_64(&address64, table_entry);
+
+#if ACPI_MACHINE_WIDTH == 32
+		if (address64 > ACPI_UINT32_MAX) {
+
+			/* Will truncate 64-bit address to 32 bits, issue warning */
+
+			ACPI_WARNING((AE_INFO,
+				      "64-bit Physical Address in XSDT is too large (0x%8.8X%8.8X),"
+				      " truncating",
+				      ACPI_FORMAT_UINT64(address64)));
+		}
+#endif
+		return ((acpi_physical_address) (address64));
+	}
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_parse_root_table
+ *
+ * PARAMETERS:  Rsdp                    - Pointer to the RSDP
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: This function is called to parse the Root System Description
+ *              Table (RSDT or XSDT)
+ *
+ * NOTE:        Tables are mapped (not copied) for efficiency. The FACS must
+ *              be mapped and cannot be copied because it contains the actual
+ *              memory location of the ACPI Global Lock.
+ *
+ ******************************************************************************/
+
+acpi_status acpi_tb_parse_root_table(acpi_physical_address rsdp_address)
+{
+	struct acpi_table_rsdp *rsdp;
+	u32 table_entry_size;
+	u32 i;
+	u32 table_count;
+	struct acpi_table_header *table;
+	acpi_physical_address address;
+	u32 length;
+	u8 *table_entry;
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(tb_parse_root_table);
+
+	/*
+	 * Map the entire RSDP and extract the address of the RSDT or XSDT
+	 */
+	rsdp = acpi_os_map_memory(rsdp_address, sizeof(struct acpi_table_rsdp));
+	if (!rsdp) {
+		return_ACPI_STATUS(AE_NO_MEMORY);
+	}
+
+	acpi_tb_print_table_header(rsdp_address,
+				   ACPI_CAST_PTR(struct acpi_table_header,
+						 rsdp));
+
+	/* Differentiate between RSDT and XSDT root tables */
+
+	if (rsdp->revision > 1 && rsdp->xsdt_physical_address) {
+		/*
+		 * Root table is an XSDT (64-bit physical addresses). We must use the
+		 * XSDT if the revision is > 1 and the XSDT pointer is present, as per
+		 * the ACPI specification.
+		 */
+		address = (acpi_physical_address) rsdp->xsdt_physical_address;
+		table_entry_size = sizeof(u64);
+	} else {
+		/* Root table is an RSDT (32-bit physical addresses) */
+
+		address = (acpi_physical_address) rsdp->rsdt_physical_address;
+		table_entry_size = sizeof(u32);
+	}
+
+	/*
+	 * It is not possible to map more than one entry in some environments,
+	 * so unmap the RSDP here before mapping other tables
+	 */
+	acpi_os_unmap_memory(rsdp, sizeof(struct acpi_table_rsdp));
+
+	/* Map the RSDT/XSDT table header to get the full table length */
+
+	table = acpi_os_map_memory(address, sizeof(struct acpi_table_header));
+	if (!table) {
+		return_ACPI_STATUS(AE_NO_MEMORY);
+	}
+
+	acpi_tb_print_table_header(address, table);
+
+	/* Get the length of the full table, verify length and map entire table */
+
+	length = table->length;
+	acpi_os_unmap_memory(table, sizeof(struct acpi_table_header));
+
+	if (length < sizeof(struct acpi_table_header)) {
+		ACPI_ERROR((AE_INFO, "Invalid length 0x%X in RSDT/XSDT",
+			    length));
+		return_ACPI_STATUS(AE_INVALID_TABLE_LENGTH);
+	}
+
+	table = acpi_os_map_memory(address, length);
+	if (!table) {
+		return_ACPI_STATUS(AE_NO_MEMORY);
+	}
+
+	/* Validate the root table checksum */
+
+	status = acpi_tb_verify_checksum(table, length);
+	if (ACPI_FAILURE(status)) {
+		acpi_os_unmap_memory(table, length);
+		return_ACPI_STATUS(status);
+	}
+
+	/* Calculate the number of tables described in the root table */
+
+	table_count = (u32)((table->length - sizeof(struct acpi_table_header)) /
+			    table_entry_size);
+
+	/*
+	 * First two entries in the table array are reserved for the DSDT
+	 * and FACS, which are not actually present in the RSDT/XSDT - they
+	 * come from the FADT
+	 */
+	table_entry =
+	    ACPI_CAST_PTR(u8, table) + sizeof(struct acpi_table_header);
+	acpi_gbl_root_table_list.current_table_count = 2;
+
+	/*
+	 * Initialize the root table array from the RSDT/XSDT
+	 */
+	for (i = 0; i < table_count; i++) {
+		if (acpi_gbl_root_table_list.current_table_count >=
+		    acpi_gbl_root_table_list.max_table_count) {
+
+			/* There is no more room in the root table array, attempt resize */
+
+			status = acpi_tb_resize_root_table_list();
+			if (ACPI_FAILURE(status)) {
+				ACPI_WARNING((AE_INFO,
+					      "Truncating %u table entries!",
+					      (unsigned)(table_count -
+							 (acpi_gbl_root_table_list.
+							  current_table_count -
+							  2))));
+				break;
+			}
+		}
+
+		/* Get the table physical address (32-bit for RSDT, 64-bit for XSDT) */
+
+		acpi_gbl_root_table_list.tables[acpi_gbl_root_table_list.
+						current_table_count].address =
+		    acpi_tb_get_root_table_entry(table_entry, table_entry_size);
+
+		table_entry += table_entry_size;
+		acpi_gbl_root_table_list.current_table_count++;
+	}
+
+	/*
+	 * It is not possible to map more than one entry in some environments,
+	 * so unmap the root table here before mapping other tables
+	 */
+	acpi_os_unmap_memory(table, length);
+
+	/*
+	 * Complete the initialization of the root table array by examining
+	 * the header of each table
+	 */
+	for (i = 2; i < acpi_gbl_root_table_list.current_table_count; i++) {
+		acpi_tb_install_table(acpi_gbl_root_table_list.tables[i].
+				      address, NULL, i);
+
+		/* Special case for FADT - get the DSDT and FACS */
+
+		if (ACPI_COMPARE_NAME
+		    (&acpi_gbl_root_table_list.tables[i].signature,
+		     ACPI_SIG_FADT)) {
+			acpi_tb_parse_fadt(i);
+		}
+	}
+
+	return_ACPI_STATUS(AE_OK);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/tbxface.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/tbxface.c
new file mode 100644
index 00000000..a6b247ae
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/tbxface.c
@@ -0,0 +1,637 @@
+/******************************************************************************
+ *
+ * Module Name: tbxface - Public interfaces to the ACPI subsystem
+ *                         ACPI table oriented interfaces
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acnamesp.h"
+#include "actables.h"
+
+#define _COMPONENT          ACPI_TABLES
+ACPI_MODULE_NAME("tbxface")
+
+/* Local prototypes */
+static acpi_status acpi_tb_load_namespace(void);
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_allocate_root_table
+ *
+ * PARAMETERS:  initial_table_count - Size of initial_table_array, in number of
+ *                                    struct acpi_table_desc structures
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Allocate a root table array. Used by i_aSL compiler and
+ *              acpi_initialize_tables.
+ *
+ ******************************************************************************/
+
+acpi_status acpi_allocate_root_table(u32 initial_table_count)
+{
+
+	acpi_gbl_root_table_list.max_table_count = initial_table_count;
+	acpi_gbl_root_table_list.flags = ACPI_ROOT_ALLOW_RESIZE;
+
+	return (acpi_tb_resize_root_table_list());
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_initialize_tables
+ *
+ * PARAMETERS:  initial_table_array - Pointer to an array of pre-allocated
+ *                                    struct acpi_table_desc structures. If NULL, the
+ *                                    array is dynamically allocated.
+ *              initial_table_count - Size of initial_table_array, in number of
+ *                                    struct acpi_table_desc structures
+ *              allow_realloc       - Flag to tell Table Manager if resize of
+ *                                    pre-allocated array is allowed. Ignored
+ *                                    if initial_table_array is NULL.
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Initialize the table manager, get the RSDP and RSDT/XSDT.
+ *
+ * NOTE:        Allows static allocation of the initial table array in order
+ *              to avoid the use of dynamic memory in confined environments
+ *              such as the kernel boot sequence where it may not be available.
+ *
+ *              If the host OS memory managers are initialized, use NULL for
+ *              initial_table_array, and the table will be dynamically allocated.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_initialize_tables(struct acpi_table_desc * initial_table_array,
+		       u32 initial_table_count, u8 allow_resize)
+{
+	acpi_physical_address rsdp_address;
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(acpi_initialize_tables);
+
+	/*
+	 * Set up the Root Table Array
+	 * Allocate the table array if requested
+	 */
+	if (!initial_table_array) {
+		status = acpi_allocate_root_table(initial_table_count);
+		if (ACPI_FAILURE(status)) {
+			return_ACPI_STATUS(status);
+		}
+	} else {
+		/* Root Table Array has been statically allocated by the host */
+
+		ACPI_MEMSET(initial_table_array, 0,
+			    (acpi_size) initial_table_count *
+			    sizeof(struct acpi_table_desc));
+
+		acpi_gbl_root_table_list.tables = initial_table_array;
+		acpi_gbl_root_table_list.max_table_count = initial_table_count;
+		acpi_gbl_root_table_list.flags = ACPI_ROOT_ORIGIN_UNKNOWN;
+		if (allow_resize) {
+			acpi_gbl_root_table_list.flags |=
+			    ACPI_ROOT_ALLOW_RESIZE;
+		}
+	}
+
+	/* Get the address of the RSDP */
+
+	rsdp_address = acpi_os_get_root_pointer();
+	if (!rsdp_address) {
+		return_ACPI_STATUS(AE_NOT_FOUND);
+	}
+
+	/*
+	 * Get the root table (RSDT or XSDT) and extract all entries to the local
+	 * Root Table Array. This array contains the information of the RSDT/XSDT
+	 * in a common, more useable format.
+	 */
+	status = acpi_tb_parse_root_table(rsdp_address);
+	return_ACPI_STATUS(status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_initialize_tables)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_reallocate_root_table
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Reallocate Root Table List into dynamic memory. Copies the
+ *              root list from the previously provided scratch area. Should
+ *              be called once dynamic memory allocation is available in the
+ *              kernel
+ *
+ ******************************************************************************/
+acpi_status acpi_reallocate_root_table(void)
+{
+	struct acpi_table_desc *tables;
+	acpi_size new_size;
+	acpi_size current_size;
+
+	ACPI_FUNCTION_TRACE(acpi_reallocate_root_table);
+
+	/*
+	 * Only reallocate the root table if the host provided a static buffer
+	 * for the table array in the call to acpi_initialize_tables.
+	 */
+	if (acpi_gbl_root_table_list.flags & ACPI_ROOT_ORIGIN_ALLOCATED) {
+		return_ACPI_STATUS(AE_SUPPORT);
+	}
+
+	/*
+	 * Get the current size of the root table and add the default
+	 * increment to create the new table size.
+	 */
+	current_size = (acpi_size)
+	    acpi_gbl_root_table_list.current_table_count *
+	    sizeof(struct acpi_table_desc);
+
+	new_size = current_size +
+	    (ACPI_ROOT_TABLE_SIZE_INCREMENT * sizeof(struct acpi_table_desc));
+
+	/* Create new array and copy the old array */
+
+	tables = ACPI_ALLOCATE_ZEROED(new_size);
+	if (!tables) {
+		return_ACPI_STATUS(AE_NO_MEMORY);
+	}
+
+	ACPI_MEMCPY(tables, acpi_gbl_root_table_list.tables, current_size);
+
+	/*
+	 * Update the root table descriptor. The new size will be the current
+	 * number of tables plus the increment, independent of the reserved
+	 * size of the original table list.
+	 */
+	acpi_gbl_root_table_list.tables = tables;
+	acpi_gbl_root_table_list.max_table_count =
+	    acpi_gbl_root_table_list.current_table_count +
+	    ACPI_ROOT_TABLE_SIZE_INCREMENT;
+	acpi_gbl_root_table_list.flags =
+	    ACPI_ROOT_ORIGIN_ALLOCATED | ACPI_ROOT_ALLOW_RESIZE;
+
+	return_ACPI_STATUS(AE_OK);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_reallocate_root_table)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_get_table_header
+ *
+ * PARAMETERS:  Signature           - ACPI signature of needed table
+ *              Instance            - Which instance (for SSDTs)
+ *              out_table_header    - The pointer to the table header to fill
+ *
+ * RETURN:      Status and pointer to mapped table header
+ *
+ * DESCRIPTION: Finds an ACPI table header.
+ *
+ * NOTE:        Caller is responsible in unmapping the header with
+ *              acpi_os_unmap_memory
+ *
+ ******************************************************************************/
+acpi_status
+acpi_get_table_header(char *signature,
+		      u32 instance, struct acpi_table_header *out_table_header)
+{
+	u32 i;
+	u32 j;
+	struct acpi_table_header *header;
+
+	/* Parameter validation */
+
+	if (!signature || !out_table_header) {
+		return (AE_BAD_PARAMETER);
+	}
+
+	/* Walk the root table list */
+
+	for (i = 0, j = 0; i < acpi_gbl_root_table_list.current_table_count;
+	     i++) {
+		if (!ACPI_COMPARE_NAME
+		    (&(acpi_gbl_root_table_list.tables[i].signature),
+		     signature)) {
+			continue;
+		}
+
+		if (++j < instance) {
+			continue;
+		}
+
+		if (!acpi_gbl_root_table_list.tables[i].pointer) {
+			if ((acpi_gbl_root_table_list.tables[i].flags &
+			     ACPI_TABLE_ORIGIN_MASK) ==
+			    ACPI_TABLE_ORIGIN_MAPPED) {
+				header =
+				    acpi_os_map_memory(acpi_gbl_root_table_list.
+						       tables[i].address,
+						       sizeof(struct
+							      acpi_table_header));
+				if (!header) {
+					return AE_NO_MEMORY;
+				}
+
+				ACPI_MEMCPY(out_table_header, header,
+					    sizeof(struct acpi_table_header));
+				acpi_os_unmap_memory(header,
+						     sizeof(struct
+							    acpi_table_header));
+			} else {
+				return AE_NOT_FOUND;
+			}
+		} else {
+			ACPI_MEMCPY(out_table_header,
+				    acpi_gbl_root_table_list.tables[i].pointer,
+				    sizeof(struct acpi_table_header));
+		}
+
+		return (AE_OK);
+	}
+
+	return (AE_NOT_FOUND);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_get_table_header)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_get_table
+ *
+ * PARAMETERS:  Signature           - ACPI signature of needed table
+ *              Instance            - Which instance (for SSDTs)
+ *              out_table           - Where the pointer to the table is returned
+ *
+ * RETURN:      Status and pointer to table
+ *
+ * DESCRIPTION: Finds and verifies an ACPI table.
+ *
+ ******************************************************************************/
+acpi_status
+acpi_get_table(char *signature,
+	       u32 instance, struct acpi_table_header ** out_table)
+{
+	u32 i;
+	u32 j;
+	acpi_status status;
+
+	/* Parameter validation */
+
+	if (!signature || !out_table) {
+		return (AE_BAD_PARAMETER);
+	}
+
+	/* Walk the root table list */
+
+	for (i = 0, j = 0; i < acpi_gbl_root_table_list.current_table_count;
+	     i++) {
+		if (!ACPI_COMPARE_NAME
+		    (&(acpi_gbl_root_table_list.tables[i].signature),
+		     signature)) {
+			continue;
+		}
+
+		if (++j < instance) {
+			continue;
+		}
+
+		status =
+		    acpi_tb_verify_table(&acpi_gbl_root_table_list.tables[i]);
+		if (ACPI_SUCCESS(status)) {
+			*out_table = acpi_gbl_root_table_list.tables[i].pointer;
+		}
+
+		return (status);
+	}
+
+	return (AE_NOT_FOUND);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_get_table)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_get_table_by_index
+ *
+ * PARAMETERS:  table_index         - Table index
+ *              Table               - Where the pointer to the table is returned
+ *
+ * RETURN:      Status and pointer to the table
+ *
+ * DESCRIPTION: Obtain a table by an index into the global table list.
+ *
+ ******************************************************************************/
+acpi_status
+acpi_get_table_by_index(u32 table_index, struct acpi_table_header ** table)
+{
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(acpi_get_table_by_index);
+
+	/* Parameter validation */
+
+	if (!table) {
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);
+
+	/* Validate index */
+
+	if (table_index >= acpi_gbl_root_table_list.current_table_count) {
+		(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	if (!acpi_gbl_root_table_list.tables[table_index].pointer) {
+
+		/* Table is not mapped, map it */
+
+		status =
+		    acpi_tb_verify_table(&acpi_gbl_root_table_list.
+					 tables[table_index]);
+		if (ACPI_FAILURE(status)) {
+			(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);
+			return_ACPI_STATUS(status);
+		}
+	}
+
+	*table = acpi_gbl_root_table_list.tables[table_index].pointer;
+	(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);
+	return_ACPI_STATUS(AE_OK);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_get_table_by_index)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_load_namespace
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Load the namespace from the DSDT and all SSDTs/PSDTs found in
+ *              the RSDT/XSDT.
+ *
+ ******************************************************************************/
+static acpi_status acpi_tb_load_namespace(void)
+{
+	acpi_status status;
+	u32 i;
+	struct acpi_table_header *new_dsdt;
+
+	ACPI_FUNCTION_TRACE(tb_load_namespace);
+
+	(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);
+
+	/*
+	 * Load the namespace. The DSDT is required, but any SSDT and
+	 * PSDT tables are optional. Verify the DSDT.
+	 */
+	if (!acpi_gbl_root_table_list.current_table_count ||
+	    !ACPI_COMPARE_NAME(&
+			       (acpi_gbl_root_table_list.
+				tables[ACPI_TABLE_INDEX_DSDT].signature),
+			       ACPI_SIG_DSDT)
+	    ||
+	    ACPI_FAILURE(acpi_tb_verify_table
+			 (&acpi_gbl_root_table_list.
+			  tables[ACPI_TABLE_INDEX_DSDT]))) {
+		status = AE_NO_ACPI_TABLES;
+		goto unlock_and_exit;
+	}
+
+	/*
+	 * Save the DSDT pointer for simple access. This is the mapped memory
+	 * address. We must take care here because the address of the .Tables
+	 * array can change dynamically as tables are loaded at run-time. Note:
+	 * .Pointer field is not validated until after call to acpi_tb_verify_table.
+	 */
+	acpi_gbl_DSDT =
+	    acpi_gbl_root_table_list.tables[ACPI_TABLE_INDEX_DSDT].pointer;
+
+	/*
+	 * Optionally copy the entire DSDT to local memory (instead of simply
+	 * mapping it.) There are some BIOSs that corrupt or replace the original
+	 * DSDT, creating the need for this option. Default is FALSE, do not copy
+	 * the DSDT.
+	 */
+	if (acpi_gbl_copy_dsdt_locally) {
+		new_dsdt = acpi_tb_copy_dsdt(ACPI_TABLE_INDEX_DSDT);
+		if (new_dsdt) {
+			acpi_gbl_DSDT = new_dsdt;
+		}
+	}
+
+	/*
+	 * Save the original DSDT header for detection of table corruption
+	 * and/or replacement of the DSDT from outside the OS.
+	 */
+	ACPI_MEMCPY(&acpi_gbl_original_dsdt_header, acpi_gbl_DSDT,
+		    sizeof(struct acpi_table_header));
+
+	(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);
+
+	/* Load and parse tables */
+
+	status = acpi_ns_load_table(ACPI_TABLE_INDEX_DSDT, acpi_gbl_root_node);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/* Load any SSDT or PSDT tables. Note: Loop leaves tables locked */
+
+	(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);
+	for (i = 0; i < acpi_gbl_root_table_list.current_table_count; ++i) {
+		if ((!ACPI_COMPARE_NAME
+		     (&(acpi_gbl_root_table_list.tables[i].signature),
+		      ACPI_SIG_SSDT)
+		     &&
+		     !ACPI_COMPARE_NAME(&
+					(acpi_gbl_root_table_list.tables[i].
+					 signature), ACPI_SIG_PSDT))
+		    ||
+		    ACPI_FAILURE(acpi_tb_verify_table
+				 (&acpi_gbl_root_table_list.tables[i]))) {
+			continue;
+		}
+
+		/* Ignore errors while loading tables, get as many as possible */
+
+		(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);
+		(void)acpi_ns_load_table(i, acpi_gbl_root_node);
+		(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INIT, "ACPI Tables successfully acquired\n"));
+
+      unlock_and_exit:
+	(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_load_tables
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Load the ACPI tables from the RSDT/XSDT
+ *
+ ******************************************************************************/
+
+acpi_status acpi_load_tables(void)
+{
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(acpi_load_tables);
+
+	/* Load the namespace from the tables */
+
+	status = acpi_tb_load_namespace();
+	if (ACPI_FAILURE(status)) {
+		ACPI_EXCEPTION((AE_INFO, status,
+				"While loading namespace from ACPI tables"));
+	}
+
+	return_ACPI_STATUS(status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_load_tables)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_install_table_handler
+ *
+ * PARAMETERS:  Handler         - Table event handler
+ *              Context         - Value passed to the handler on each event
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Install table event handler
+ *
+ ******************************************************************************/
+acpi_status
+acpi_install_table_handler(acpi_table_handler handler, void *context)
+{
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(acpi_install_table_handler);
+
+	if (!handler) {
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	status = acpi_ut_acquire_mutex(ACPI_MTX_EVENTS);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/* Don't allow more than one handler */
+
+	if (acpi_gbl_table_handler) {
+		status = AE_ALREADY_EXISTS;
+		goto cleanup;
+	}
+
+	/* Install the handler */
+
+	acpi_gbl_table_handler = handler;
+	acpi_gbl_table_handler_context = context;
+
+      cleanup:
+	(void)acpi_ut_release_mutex(ACPI_MTX_EVENTS);
+	return_ACPI_STATUS(status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_install_table_handler)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_remove_table_handler
+ *
+ * PARAMETERS:  Handler         - Table event handler that was installed
+ *                                previously.
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Remove table event handler
+ *
+ ******************************************************************************/
+acpi_status acpi_remove_table_handler(acpi_table_handler handler)
+{
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(acpi_remove_table_handler);
+
+	status = acpi_ut_acquire_mutex(ACPI_MTX_EVENTS);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/* Make sure that the installed handler is the same */
+
+	if (!handler || handler != acpi_gbl_table_handler) {
+		status = AE_BAD_PARAMETER;
+		goto cleanup;
+	}
+
+	/* Remove the handler */
+
+	acpi_gbl_table_handler = NULL;
+
+      cleanup:
+	(void)acpi_ut_release_mutex(ACPI_MTX_EVENTS);
+	return_ACPI_STATUS(status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_remove_table_handler)
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/tbxfroot.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/tbxfroot.c
new file mode 100644
index 00000000..f3fa1495
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/tbxfroot.c
@@ -0,0 +1,276 @@
+/******************************************************************************
+ *
+ * Module Name: tbxfroot - Find the root ACPI table (RSDT)
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "actables.h"
+
+#define _COMPONENT          ACPI_TABLES
+ACPI_MODULE_NAME("tbxfroot")
+
+/* Local prototypes */
+static u8 *acpi_tb_scan_memory_for_rsdp(u8 *start_address, u32 length);
+
+static acpi_status acpi_tb_validate_rsdp(struct acpi_table_rsdp *rsdp);
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_validate_rsdp
+ *
+ * PARAMETERS:  Rsdp                - Pointer to unvalidated RSDP
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Validate the RSDP (ptr)
+ *
+ ******************************************************************************/
+
+static acpi_status acpi_tb_validate_rsdp(struct acpi_table_rsdp *rsdp)
+{
+	ACPI_FUNCTION_ENTRY();
+
+	/*
+	 * The signature and checksum must both be correct
+	 *
+	 * Note: Sometimes there exists more than one RSDP in memory; the valid
+	 * RSDP has a valid checksum, all others have an invalid checksum.
+	 */
+	if (ACPI_STRNCMP((char *)rsdp, ACPI_SIG_RSDP,
+			 sizeof(ACPI_SIG_RSDP) - 1) != 0) {
+
+		/* Nope, BAD Signature */
+
+		return (AE_BAD_SIGNATURE);
+	}
+
+	/* Check the standard checksum */
+
+	if (acpi_tb_checksum((u8 *)rsdp, ACPI_RSDP_CHECKSUM_LENGTH) != 0) {
+		return (AE_BAD_CHECKSUM);
+	}
+
+	/* Check extended checksum if table version >= 2 */
+
+	if ((rsdp->revision >= 2) &&
+	    (acpi_tb_checksum((u8 *)rsdp, ACPI_RSDP_XCHECKSUM_LENGTH) != 0)) {
+		return (AE_BAD_CHECKSUM);
+	}
+
+	return (AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_find_root_pointer
+ *
+ * PARAMETERS:  table_address           - Where the table pointer is returned
+ *
+ * RETURN:      Status, RSDP physical address
+ *
+ * DESCRIPTION: Search lower 1_mbyte of memory for the root system descriptor
+ *              pointer structure.  If it is found, set *RSDP to point to it.
+ *
+ * NOTE1:       The RSDP must be either in the first 1_k of the Extended
+ *              BIOS Data Area or between E0000 and FFFFF (From ACPI Spec.)
+ *              Only a 32-bit physical address is necessary.
+ *
+ * NOTE2:       This function is always available, regardless of the
+ *              initialization state of the rest of ACPI.
+ *
+ ******************************************************************************/
+
+acpi_status acpi_find_root_pointer(acpi_size * table_address)
+{
+	u8 *table_ptr;
+	u8 *mem_rover;
+	u32 physical_address;
+
+	ACPI_FUNCTION_TRACE(acpi_find_root_pointer);
+
+	/* 1a) Get the location of the Extended BIOS Data Area (EBDA) */
+
+	table_ptr = acpi_os_map_memory((acpi_physical_address)
+				       ACPI_EBDA_PTR_LOCATION,
+				       ACPI_EBDA_PTR_LENGTH);
+	if (!table_ptr) {
+		ACPI_ERROR((AE_INFO,
+			    "Could not map memory at 0x%8.8X for length %u",
+			    ACPI_EBDA_PTR_LOCATION, ACPI_EBDA_PTR_LENGTH));
+
+		return_ACPI_STATUS(AE_NO_MEMORY);
+	}
+
+	ACPI_MOVE_16_TO_32(&physical_address, table_ptr);
+
+	/* Convert segment part to physical address */
+
+	physical_address <<= 4;
+	acpi_os_unmap_memory(table_ptr, ACPI_EBDA_PTR_LENGTH);
+
+	/* EBDA present? */
+
+	if (physical_address > 0x400) {
+		/*
+		 * 1b) Search EBDA paragraphs (EBDA is required to be a
+		 *     minimum of 1_k length)
+		 */
+		table_ptr = acpi_os_map_memory((acpi_physical_address)
+					       physical_address,
+					       ACPI_EBDA_WINDOW_SIZE);
+		if (!table_ptr) {
+			ACPI_ERROR((AE_INFO,
+				    "Could not map memory at 0x%8.8X for length %u",
+				    physical_address, ACPI_EBDA_WINDOW_SIZE));
+
+			return_ACPI_STATUS(AE_NO_MEMORY);
+		}
+
+		mem_rover =
+		    acpi_tb_scan_memory_for_rsdp(table_ptr,
+						 ACPI_EBDA_WINDOW_SIZE);
+		acpi_os_unmap_memory(table_ptr, ACPI_EBDA_WINDOW_SIZE);
+
+		if (mem_rover) {
+
+			/* Return the physical address */
+
+			physical_address +=
+			    (u32)ACPI_PTR_DIFF(mem_rover, table_ptr);
+
+			*table_address = physical_address;
+			return_ACPI_STATUS(AE_OK);
+		}
+	}
+
+	/*
+	 * 2) Search upper memory: 16-byte boundaries in E0000h-FFFFFh
+	 */
+	table_ptr = acpi_os_map_memory((acpi_physical_address)
+				       ACPI_HI_RSDP_WINDOW_BASE,
+				       ACPI_HI_RSDP_WINDOW_SIZE);
+
+	if (!table_ptr) {
+		ACPI_ERROR((AE_INFO,
+			    "Could not map memory at 0x%8.8X for length %u",
+			    ACPI_HI_RSDP_WINDOW_BASE,
+			    ACPI_HI_RSDP_WINDOW_SIZE));
+
+		return_ACPI_STATUS(AE_NO_MEMORY);
+	}
+
+	mem_rover =
+	    acpi_tb_scan_memory_for_rsdp(table_ptr, ACPI_HI_RSDP_WINDOW_SIZE);
+	acpi_os_unmap_memory(table_ptr, ACPI_HI_RSDP_WINDOW_SIZE);
+
+	if (mem_rover) {
+
+		/* Return the physical address */
+
+		physical_address = (u32)
+		    (ACPI_HI_RSDP_WINDOW_BASE +
+		     ACPI_PTR_DIFF(mem_rover, table_ptr));
+
+		*table_address = physical_address;
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	/* A valid RSDP was not found */
+
+	ACPI_ERROR((AE_INFO, "A valid RSDP was not found"));
+	return_ACPI_STATUS(AE_NOT_FOUND);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_find_root_pointer)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_scan_memory_for_rsdp
+ *
+ * PARAMETERS:  start_address       - Starting pointer for search
+ *              Length              - Maximum length to search
+ *
+ * RETURN:      Pointer to the RSDP if found, otherwise NULL.
+ *
+ * DESCRIPTION: Search a block of memory for the RSDP signature
+ *
+ ******************************************************************************/
+static u8 *acpi_tb_scan_memory_for_rsdp(u8 *start_address, u32 length)
+{
+	acpi_status status;
+	u8 *mem_rover;
+	u8 *end_address;
+
+	ACPI_FUNCTION_TRACE(tb_scan_memory_for_rsdp);
+
+	end_address = start_address + length;
+
+	/* Search from given start address for the requested length */
+
+	for (mem_rover = start_address; mem_rover < end_address;
+	     mem_rover += ACPI_RSDP_SCAN_STEP) {
+
+		/* The RSDP signature and checksum must both be correct */
+
+		status =
+		    acpi_tb_validate_rsdp(ACPI_CAST_PTR
+					  (struct acpi_table_rsdp, mem_rover));
+		if (ACPI_SUCCESS(status)) {
+
+			/* Sig and checksum valid, we have found a real RSDP */
+
+			ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+					  "RSDP located at physical address %p\n",
+					  mem_rover));
+			return_PTR(mem_rover);
+		}
+
+		/* No sig match or bad checksum, keep searching */
+	}
+
+	/* Searched entire block, no RSDP was found */
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+			  "Searched entire block from %p, valid RSDP was not found\n",
+			  start_address));
+	return_PTR(NULL);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utaddress.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utaddress.c
new file mode 100644
index 00000000..a78e8b3c
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utaddress.c
@@ -0,0 +1,294 @@
+/******************************************************************************
+ *
+ * Module Name: utaddress - op_region address range check
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acnamesp.h"
+
+#define _COMPONENT          ACPI_UTILITIES
+ACPI_MODULE_NAME("utaddress")
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_add_address_range
+ *
+ * PARAMETERS:  space_id            - Address space ID
+ *              Address             - op_region start address
+ *              Length              - op_region length
+ *              region_node         - op_region namespace node
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Add the Operation Region address range to the global list.
+ *              The only supported Space IDs are Memory and I/O. Called when
+ *              the op_region address/length operands are fully evaluated.
+ *
+ * MUTEX:       Locks the namespace
+ *
+ * NOTE: Because this interface is only called when an op_region argument
+ * list is evaluated, there cannot be any duplicate region_nodes.
+ * Duplicate Address/Length values are allowed, however, so that multiple
+ * address conflicts can be detected.
+ *
+ ******************************************************************************/
+acpi_status
+acpi_ut_add_address_range(acpi_adr_space_type space_id,
+			  acpi_physical_address address,
+			  u32 length, struct acpi_namespace_node *region_node)
+{
+	ACPI_ADDRESS_RANGE *range_info;
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(ut_add_address_range);
+
+	if ((space_id != ACPI_ADR_SPACE_SYSTEM_MEMORY) &&
+	    (space_id != ACPI_ADR_SPACE_SYSTEM_IO)) {
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	/* Allocate/init a new info block, add it to the appropriate list */
+
+	range_info = ACPI_ALLOCATE(sizeof(ACPI_ADDRESS_RANGE));
+	if (!range_info) {
+		return_ACPI_STATUS(AE_NO_MEMORY);
+	}
+
+	range_info->start_address = address;
+	range_info->end_address = (address + length - 1);
+	range_info->region_node = region_node;
+
+	status = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);
+	if (ACPI_FAILURE(status)) {
+		ACPI_FREE(range_info);
+		return_ACPI_STATUS(status);
+	}
+
+	range_info->next = acpi_gbl_address_range_list[space_id];
+	acpi_gbl_address_range_list[space_id] = range_info;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_NAMES,
+			  "\nAdded [%4.4s] address range: 0x%p-0x%p\n",
+			  acpi_ut_get_node_name(range_info->region_node),
+			  ACPI_CAST_PTR(void, address),
+			  ACPI_CAST_PTR(void, range_info->end_address)));
+
+	(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_remove_address_range
+ *
+ * PARAMETERS:  space_id            - Address space ID
+ *              region_node         - op_region namespace node
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Remove the Operation Region from the global list. The only
+ *              supported Space IDs are Memory and I/O. Called when an
+ *              op_region is deleted.
+ *
+ * MUTEX:       Assumes the namespace is locked
+ *
+ ******************************************************************************/
+
+void
+acpi_ut_remove_address_range(acpi_adr_space_type space_id,
+			     struct acpi_namespace_node *region_node)
+{
+	ACPI_ADDRESS_RANGE *range_info;
+	ACPI_ADDRESS_RANGE *prev;
+
+	ACPI_FUNCTION_TRACE(ut_remove_address_range);
+
+	if ((space_id != ACPI_ADR_SPACE_SYSTEM_MEMORY) &&
+	    (space_id != ACPI_ADR_SPACE_SYSTEM_IO)) {
+		return_VOID;
+	}
+
+	/* Get the appropriate list head and check the list */
+
+	range_info = prev = acpi_gbl_address_range_list[space_id];
+	while (range_info) {
+		if (range_info->region_node == region_node) {
+			if (range_info == prev) {	/* Found at list head */
+				acpi_gbl_address_range_list[space_id] =
+				    range_info->next;
+			} else {
+				prev->next = range_info->next;
+			}
+
+			ACPI_DEBUG_PRINT((ACPI_DB_NAMES,
+					  "\nRemoved [%4.4s] address range: 0x%p-0x%p\n",
+					  acpi_ut_get_node_name(range_info->
+								region_node),
+					  ACPI_CAST_PTR(void,
+							range_info->
+							start_address),
+					  ACPI_CAST_PTR(void,
+							range_info->
+							end_address)));
+
+			ACPI_FREE(range_info);
+			return_VOID;
+		}
+
+		prev = range_info;
+		range_info = range_info->next;
+	}
+
+	return_VOID;
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_check_address_range
+ *
+ * PARAMETERS:  space_id            - Address space ID
+ *              Address             - Start address
+ *              Length              - Length of address range
+ *              Warn                - TRUE if warning on overlap desired
+ *
+ * RETURN:      Count of the number of conflicts detected. Zero is always
+ *              returned for Space IDs other than Memory or I/O.
+ *
+ * DESCRIPTION: Check if the input address range overlaps any of the
+ *              ASL operation region address ranges. The only supported
+ *              Space IDs are Memory and I/O.
+ *
+ * MUTEX:       Assumes the namespace is locked.
+ *
+ ******************************************************************************/
+
+u32
+acpi_ut_check_address_range(acpi_adr_space_type space_id,
+			    acpi_physical_address address, u32 length, u8 warn)
+{
+	ACPI_ADDRESS_RANGE *range_info;
+	acpi_physical_address end_address;
+	char *pathname;
+	u32 overlap_count = 0;
+
+	ACPI_FUNCTION_TRACE(ut_check_address_range);
+
+	if ((space_id != ACPI_ADR_SPACE_SYSTEM_MEMORY) &&
+	    (space_id != ACPI_ADR_SPACE_SYSTEM_IO)) {
+		return_UINT32(0);
+	}
+
+	range_info = acpi_gbl_address_range_list[space_id];
+	end_address = address + length - 1;
+
+	/* Check entire list for all possible conflicts */
+
+	while (range_info) {
+		/*
+		 * Check if the requested Address/Length overlaps this address_range.
+		 * Four cases to consider:
+		 *
+		 * 1) Input address/length is contained completely in the address range
+		 * 2) Input address/length overlaps range at the range start
+		 * 3) Input address/length overlaps range at the range end
+		 * 4) Input address/length completely encompasses the range
+		 */
+		if ((address <= range_info->end_address) &&
+		    (end_address >= range_info->start_address)) {
+
+			/* Found an address range overlap */
+
+			overlap_count++;
+			if (warn) {	/* Optional warning message */
+				pathname =
+				    acpi_ns_get_external_pathname(range_info->
+								  region_node);
+
+				ACPI_WARNING((AE_INFO,
+					      "0x%p-0x%p %s conflicts with Region %s %d",
+					      ACPI_CAST_PTR(void, address),
+					      ACPI_CAST_PTR(void, end_address),
+					      acpi_ut_get_region_name(space_id),
+					      pathname, overlap_count));
+				ACPI_FREE(pathname);
+			}
+		}
+
+		range_info = range_info->next;
+	}
+
+	return_UINT32(overlap_count);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_delete_address_lists
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Delete all global address range lists (called during
+ *              subsystem shutdown).
+ *
+ ******************************************************************************/
+
+void acpi_ut_delete_address_lists(void)
+{
+	ACPI_ADDRESS_RANGE *next;
+	ACPI_ADDRESS_RANGE *range_info;
+	int i;
+
+	/* Delete all elements in all address range lists */
+
+	for (i = 0; i < ACPI_ADDRESS_RANGE_MAX; i++) {
+		next = acpi_gbl_address_range_list[i];
+
+		while (next) {
+			range_info = next;
+			next = range_info->next;
+			ACPI_FREE(range_info);
+		}
+
+		acpi_gbl_address_range_list[i] = NULL;
+	}
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utalloc.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utalloc.c
new file mode 100644
index 00000000..99da235d
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utalloc.c
@@ -0,0 +1,382 @@
+/******************************************************************************
+ *
+ * Module Name: utalloc - local memory allocation routines
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acdebug.h"
+
+#define _COMPONENT          ACPI_UTILITIES
+ACPI_MODULE_NAME("utalloc")
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_create_caches
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Create all local caches
+ *
+ ******************************************************************************/
+acpi_status acpi_ut_create_caches(void)
+{
+	acpi_status status;
+
+	/* Object Caches, for frequently used objects */
+
+	status =
+	    acpi_os_create_cache("Acpi-Namespace",
+				 sizeof(struct acpi_namespace_node),
+				 ACPI_MAX_NAMESPACE_CACHE_DEPTH,
+				 &acpi_gbl_namespace_cache);
+	if (ACPI_FAILURE(status)) {
+		return (status);
+	}
+
+	status =
+	    acpi_os_create_cache("Acpi-State", sizeof(union acpi_generic_state),
+				 ACPI_MAX_STATE_CACHE_DEPTH,
+				 &acpi_gbl_state_cache);
+	if (ACPI_FAILURE(status)) {
+		return (status);
+	}
+
+	status =
+	    acpi_os_create_cache("Acpi-Parse",
+				 sizeof(struct acpi_parse_obj_common),
+				 ACPI_MAX_PARSE_CACHE_DEPTH,
+				 &acpi_gbl_ps_node_cache);
+	if (ACPI_FAILURE(status)) {
+		return (status);
+	}
+
+	status =
+	    acpi_os_create_cache("Acpi-ParseExt",
+				 sizeof(struct acpi_parse_obj_named),
+				 ACPI_MAX_EXTPARSE_CACHE_DEPTH,
+				 &acpi_gbl_ps_node_ext_cache);
+	if (ACPI_FAILURE(status)) {
+		return (status);
+	}
+
+	status =
+	    acpi_os_create_cache("Acpi-Operand",
+				 sizeof(union acpi_operand_object),
+				 ACPI_MAX_OBJECT_CACHE_DEPTH,
+				 &acpi_gbl_operand_cache);
+	if (ACPI_FAILURE(status)) {
+		return (status);
+	}
+
+#ifdef ACPI_DBG_TRACK_ALLOCATIONS
+
+	/* Memory allocation lists */
+
+	status = acpi_ut_create_list("Acpi-Global", 0, &acpi_gbl_global_list);
+	if (ACPI_FAILURE(status)) {
+		return (status);
+	}
+
+	status =
+	    acpi_ut_create_list("Acpi-Namespace",
+				sizeof(struct acpi_namespace_node),
+				&acpi_gbl_ns_node_list);
+	if (ACPI_FAILURE(status)) {
+		return (status);
+	}
+#endif
+
+	return (AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_delete_caches
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Purge and delete all local caches
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ut_delete_caches(void)
+{
+#ifdef ACPI_DBG_TRACK_ALLOCATIONS
+	char buffer[7];
+
+	if (acpi_gbl_display_final_mem_stats) {
+		ACPI_STRCPY(buffer, "MEMORY");
+		(void)acpi_db_display_statistics(buffer);
+	}
+#endif
+
+	(void)acpi_os_delete_cache(acpi_gbl_namespace_cache);
+	acpi_gbl_namespace_cache = NULL;
+
+	(void)acpi_os_delete_cache(acpi_gbl_state_cache);
+	acpi_gbl_state_cache = NULL;
+
+	(void)acpi_os_delete_cache(acpi_gbl_operand_cache);
+	acpi_gbl_operand_cache = NULL;
+
+	(void)acpi_os_delete_cache(acpi_gbl_ps_node_cache);
+	acpi_gbl_ps_node_cache = NULL;
+
+	(void)acpi_os_delete_cache(acpi_gbl_ps_node_ext_cache);
+	acpi_gbl_ps_node_ext_cache = NULL;
+
+#ifdef ACPI_DBG_TRACK_ALLOCATIONS
+
+	/* Debug only - display leftover memory allocation, if any */
+
+	acpi_ut_dump_allocations(ACPI_UINT32_MAX, NULL);
+
+	/* Free memory lists */
+
+	acpi_os_free(acpi_gbl_global_list);
+	acpi_gbl_global_list = NULL;
+
+	acpi_os_free(acpi_gbl_ns_node_list);
+	acpi_gbl_ns_node_list = NULL;
+#endif
+
+	return (AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_validate_buffer
+ *
+ * PARAMETERS:  Buffer              - Buffer descriptor to be validated
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Perform parameter validation checks on an struct acpi_buffer
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ut_validate_buffer(struct acpi_buffer * buffer)
+{
+
+	/* Obviously, the structure pointer must be valid */
+
+	if (!buffer) {
+		return (AE_BAD_PARAMETER);
+	}
+
+	/* Special semantics for the length */
+
+	if ((buffer->length == ACPI_NO_BUFFER) ||
+	    (buffer->length == ACPI_ALLOCATE_BUFFER) ||
+	    (buffer->length == ACPI_ALLOCATE_LOCAL_BUFFER)) {
+		return (AE_OK);
+	}
+
+	/* Length is valid, the buffer pointer must be also */
+
+	if (!buffer->pointer) {
+		return (AE_BAD_PARAMETER);
+	}
+
+	return (AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_initialize_buffer
+ *
+ * PARAMETERS:  Buffer              - Buffer to be validated
+ *              required_length     - Length needed
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Validate that the buffer is of the required length or
+ *              allocate a new buffer. Returned buffer is always zeroed.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ut_initialize_buffer(struct acpi_buffer * buffer,
+			  acpi_size required_length)
+{
+	acpi_size input_buffer_length;
+
+	/* Parameter validation */
+
+	if (!buffer || !required_length) {
+		return (AE_BAD_PARAMETER);
+	}
+
+	/*
+	 * Buffer->Length is used as both an input and output parameter. Get the
+	 * input actual length and set the output required buffer length.
+	 */
+	input_buffer_length = buffer->length;
+	buffer->length = required_length;
+
+	/*
+	 * The input buffer length contains the actual buffer length, or the type
+	 * of buffer to be allocated by this routine.
+	 */
+	switch (input_buffer_length) {
+	case ACPI_NO_BUFFER:
+
+		/* Return the exception (and the required buffer length) */
+
+		return (AE_BUFFER_OVERFLOW);
+
+	case ACPI_ALLOCATE_BUFFER:
+
+		/* Allocate a new buffer */
+
+		buffer->pointer = acpi_os_allocate(required_length);
+		break;
+
+	case ACPI_ALLOCATE_LOCAL_BUFFER:
+
+		/* Allocate a new buffer with local interface to allow tracking */
+
+		buffer->pointer = ACPI_ALLOCATE(required_length);
+		break;
+
+	default:
+
+		/* Existing buffer: Validate the size of the buffer */
+
+		if (input_buffer_length < required_length) {
+			return (AE_BUFFER_OVERFLOW);
+		}
+		break;
+	}
+
+	/* Validate allocation from above or input buffer pointer */
+
+	if (!buffer->pointer) {
+		return (AE_NO_MEMORY);
+	}
+
+	/* Have a valid buffer, clear it */
+
+	ACPI_MEMSET(buffer->pointer, 0, required_length);
+	return (AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_allocate
+ *
+ * PARAMETERS:  Size                - Size of the allocation
+ *              Component           - Component type of caller
+ *              Module              - Source file name of caller
+ *              Line                - Line number of caller
+ *
+ * RETURN:      Address of the allocated memory on success, NULL on failure.
+ *
+ * DESCRIPTION: Subsystem equivalent of malloc.
+ *
+ ******************************************************************************/
+
+void *acpi_ut_allocate(acpi_size size,
+		       u32 component, const char *module, u32 line)
+{
+	void *allocation;
+
+	ACPI_FUNCTION_TRACE_U32(ut_allocate, size);
+
+	/* Check for an inadvertent size of zero bytes */
+
+	if (!size) {
+		ACPI_WARNING((module, line,
+			      "Attempt to allocate zero bytes, allocating 1 byte"));
+		size = 1;
+	}
+
+	allocation = acpi_os_allocate(size);
+	if (!allocation) {
+
+		/* Report allocation error */
+
+		ACPI_WARNING((module, line,
+			      "Could not allocate size %u", (u32)size));
+
+		return_PTR(NULL);
+	}
+
+	return_PTR(allocation);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_allocate_zeroed
+ *
+ * PARAMETERS:  Size                - Size of the allocation
+ *              Component           - Component type of caller
+ *              Module              - Source file name of caller
+ *              Line                - Line number of caller
+ *
+ * RETURN:      Address of the allocated memory on success, NULL on failure.
+ *
+ * DESCRIPTION: Subsystem equivalent of calloc. Allocate and zero memory.
+ *
+ ******************************************************************************/
+
+void *acpi_ut_allocate_zeroed(acpi_size size,
+			      u32 component, const char *module, u32 line)
+{
+	void *allocation;
+
+	ACPI_FUNCTION_ENTRY();
+
+	allocation = acpi_ut_allocate(size, component, module, line);
+	if (allocation) {
+
+		/* Clear the memory block */
+
+		ACPI_MEMSET(allocation, 0, size);
+	}
+
+	return (allocation);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utcache.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utcache.c
new file mode 100644
index 00000000..e11edcdd
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utcache.c
@@ -0,0 +1,323 @@
+/******************************************************************************
+ *
+ * Module Name: utcache - local cache allocation routines
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+
+#define _COMPONENT          ACPI_UTILITIES
+ACPI_MODULE_NAME("utcache")
+
+#ifdef ACPI_USE_LOCAL_CACHE
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_os_create_cache
+ *
+ * PARAMETERS:  cache_name      - Ascii name for the cache
+ *              object_size     - Size of each cached object
+ *              max_depth       - Maximum depth of the cache (in objects)
+ *              return_cache    - Where the new cache object is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Create a cache object
+ *
+ ******************************************************************************/
+acpi_status
+acpi_os_create_cache(char *cache_name,
+		     u16 object_size,
+		     u16 max_depth, struct acpi_memory_list **return_cache)
+{
+	struct acpi_memory_list *cache;
+
+	ACPI_FUNCTION_ENTRY();
+
+	if (!cache_name || !return_cache || (object_size < 16)) {
+		return (AE_BAD_PARAMETER);
+	}
+
+	/* Create the cache object */
+
+	cache = acpi_os_allocate(sizeof(struct acpi_memory_list));
+	if (!cache) {
+		return (AE_NO_MEMORY);
+	}
+
+	/* Populate the cache object and return it */
+
+	ACPI_MEMSET(cache, 0, sizeof(struct acpi_memory_list));
+	cache->link_offset = 8;
+	cache->list_name = cache_name;
+	cache->object_size = object_size;
+	cache->max_depth = max_depth;
+
+	*return_cache = cache;
+	return (AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_os_purge_cache
+ *
+ * PARAMETERS:  Cache           - Handle to cache object
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Free all objects within the requested cache.
+ *
+ ******************************************************************************/
+
+acpi_status acpi_os_purge_cache(struct acpi_memory_list * cache)
+{
+	char *next;
+	acpi_status status;
+
+	ACPI_FUNCTION_ENTRY();
+
+	if (!cache) {
+		return (AE_BAD_PARAMETER);
+	}
+
+	status = acpi_ut_acquire_mutex(ACPI_MTX_CACHES);
+	if (ACPI_FAILURE(status)) {
+		return (status);
+	}
+
+	/* Walk the list of objects in this cache */
+
+	while (cache->list_head) {
+
+		/* Delete and unlink one cached state object */
+
+		next = *(ACPI_CAST_INDIRECT_PTR(char,
+						&(((char *)cache->
+						   list_head)[cache->
+							      link_offset])));
+		ACPI_FREE(cache->list_head);
+
+		cache->list_head = next;
+		cache->current_depth--;
+	}
+
+	(void)acpi_ut_release_mutex(ACPI_MTX_CACHES);
+	return (AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_os_delete_cache
+ *
+ * PARAMETERS:  Cache           - Handle to cache object
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Free all objects within the requested cache and delete the
+ *              cache object.
+ *
+ ******************************************************************************/
+
+acpi_status acpi_os_delete_cache(struct acpi_memory_list * cache)
+{
+	acpi_status status;
+
+	ACPI_FUNCTION_ENTRY();
+
+	/* Purge all objects in the cache */
+
+	status = acpi_os_purge_cache(cache);
+	if (ACPI_FAILURE(status)) {
+		return (status);
+	}
+
+	/* Now we can delete the cache object */
+
+	acpi_os_free(cache);
+	return (AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_os_release_object
+ *
+ * PARAMETERS:  Cache       - Handle to cache object
+ *              Object      - The object to be released
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Release an object to the specified cache.  If cache is full,
+ *              the object is deleted.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_os_release_object(struct acpi_memory_list * cache, void *object)
+{
+	acpi_status status;
+
+	ACPI_FUNCTION_ENTRY();
+
+	if (!cache || !object) {
+		return (AE_BAD_PARAMETER);
+	}
+
+	/* If cache is full, just free this object */
+
+	if (cache->current_depth >= cache->max_depth) {
+		ACPI_FREE(object);
+		ACPI_MEM_TRACKING(cache->total_freed++);
+	}
+
+	/* Otherwise put this object back into the cache */
+
+	else {
+		status = acpi_ut_acquire_mutex(ACPI_MTX_CACHES);
+		if (ACPI_FAILURE(status)) {
+			return (status);
+		}
+
+		/* Mark the object as cached */
+
+		ACPI_MEMSET(object, 0xCA, cache->object_size);
+		ACPI_SET_DESCRIPTOR_TYPE(object, ACPI_DESC_TYPE_CACHED);
+
+		/* Put the object at the head of the cache list */
+
+		*(ACPI_CAST_INDIRECT_PTR(char,
+					 &(((char *)object)[cache->
+							    link_offset]))) =
+		    cache->list_head;
+		cache->list_head = object;
+		cache->current_depth++;
+
+		(void)acpi_ut_release_mutex(ACPI_MTX_CACHES);
+	}
+
+	return (AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_os_acquire_object
+ *
+ * PARAMETERS:  Cache           - Handle to cache object
+ *
+ * RETURN:      the acquired object.  NULL on error
+ *
+ * DESCRIPTION: Get an object from the specified cache.  If cache is empty,
+ *              the object is allocated.
+ *
+ ******************************************************************************/
+
+void *acpi_os_acquire_object(struct acpi_memory_list *cache)
+{
+	acpi_status status;
+	void *object;
+
+	ACPI_FUNCTION_NAME(os_acquire_object);
+
+	if (!cache) {
+		return (NULL);
+	}
+
+	status = acpi_ut_acquire_mutex(ACPI_MTX_CACHES);
+	if (ACPI_FAILURE(status)) {
+		return (NULL);
+	}
+
+	ACPI_MEM_TRACKING(cache->requests++);
+
+	/* Check the cache first */
+
+	if (cache->list_head) {
+
+		/* There is an object available, use it */
+
+		object = cache->list_head;
+		cache->list_head = *(ACPI_CAST_INDIRECT_PTR(char,
+							    &(((char *)
+							       object)[cache->
+								       link_offset])));
+
+		cache->current_depth--;
+
+		ACPI_MEM_TRACKING(cache->hits++);
+		ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
+				  "Object %p from %s cache\n", object,
+				  cache->list_name));
+
+		status = acpi_ut_release_mutex(ACPI_MTX_CACHES);
+		if (ACPI_FAILURE(status)) {
+			return (NULL);
+		}
+
+		/* Clear (zero) the previously used Object */
+
+		ACPI_MEMSET(object, 0, cache->object_size);
+	} else {
+		/* The cache is empty, create a new object */
+
+		ACPI_MEM_TRACKING(cache->total_allocated++);
+
+#ifdef ACPI_DBG_TRACK_ALLOCATIONS
+		if ((cache->total_allocated - cache->total_freed) >
+		    cache->max_occupied) {
+			cache->max_occupied =
+			    cache->total_allocated - cache->total_freed;
+		}
+#endif
+
+		/* Avoid deadlock with ACPI_ALLOCATE_ZEROED */
+
+		status = acpi_ut_release_mutex(ACPI_MTX_CACHES);
+		if (ACPI_FAILURE(status)) {
+			return (NULL);
+		}
+
+		object = ACPI_ALLOCATE_ZEROED(cache->object_size);
+		if (!object) {
+			return (NULL);
+		}
+	}
+
+	return (object);
+}
+#endif				/* ACPI_USE_LOCAL_CACHE */
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utclib.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utclib.c
new file mode 100644
index 00000000..908df835
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utclib.c
@@ -0,0 +1,748 @@
+/******************************************************************************
+ *
+ * Module Name: cmclib - Local implementation of C library functions
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+
+/*
+ * These implementations of standard C Library routines can optionally be
+ * used if a C library is not available.  In general, they are less efficient
+ * than an inline or assembly implementation
+ */
+
+#define _COMPONENT          ACPI_UTILITIES
+ACPI_MODULE_NAME("cmclib")
+
+#ifndef ACPI_USE_SYSTEM_CLIBRARY
+#define NEGATIVE    1
+#define POSITIVE    0
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_memcmp (memcmp)
+ *
+ * PARAMETERS:  Buffer1         - First Buffer
+ *              Buffer2         - Second Buffer
+ *              Count           - Maximum # of bytes to compare
+ *
+ * RETURN:      Index where Buffers mismatched, or 0 if Buffers matched
+ *
+ * DESCRIPTION: Compare two Buffers, with a maximum length
+ *
+ ******************************************************************************/
+int acpi_ut_memcmp(const char *buffer1, const char *buffer2, acpi_size count)
+{
+
+	return ((count == ACPI_SIZE_MAX) ? 0 : ((unsigned char)*buffer1 -
+						(unsigned char)*buffer2));
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_memcpy (memcpy)
+ *
+ * PARAMETERS:  Dest        - Target of the copy
+ *              Src         - Source buffer to copy
+ *              Count       - Number of bytes to copy
+ *
+ * RETURN:      Dest
+ *
+ * DESCRIPTION: Copy arbitrary bytes of memory
+ *
+ ******************************************************************************/
+
+void *acpi_ut_memcpy(void *dest, const void *src, acpi_size count)
+{
+	char *new = (char *)dest;
+	char *old = (char *)src;
+
+	while (count) {
+		*new = *old;
+		new++;
+		old++;
+		count--;
+	}
+
+	return (dest);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_memset (memset)
+ *
+ * PARAMETERS:  Dest        - Buffer to set
+ *              Value       - Value to set each byte of memory
+ *              Count       - Number of bytes to set
+ *
+ * RETURN:      Dest
+ *
+ * DESCRIPTION: Initialize a buffer to a known value.
+ *
+ ******************************************************************************/
+
+void *acpi_ut_memset(void *dest, u8 value, acpi_size count)
+{
+	char *new = (char *)dest;
+
+	while (count) {
+		*new = (char)value;
+		new++;
+		count--;
+	}
+
+	return (dest);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_strlen (strlen)
+ *
+ * PARAMETERS:  String              - Null terminated string
+ *
+ * RETURN:      Length
+ *
+ * DESCRIPTION: Returns the length of the input string
+ *
+ ******************************************************************************/
+
+acpi_size acpi_ut_strlen(const char *string)
+{
+	u32 length = 0;
+
+	/* Count the string until a null is encountered */
+
+	while (*string) {
+		length++;
+		string++;
+	}
+
+	return (length);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_strcpy (strcpy)
+ *
+ * PARAMETERS:  dst_string      - Target of the copy
+ *              src_string      - The source string to copy
+ *
+ * RETURN:      dst_string
+ *
+ * DESCRIPTION: Copy a null terminated string
+ *
+ ******************************************************************************/
+
+char *acpi_ut_strcpy(char *dst_string, const char *src_string)
+{
+	char *string = dst_string;
+
+	/* Move bytes brute force */
+
+	while (*src_string) {
+		*string = *src_string;
+
+		string++;
+		src_string++;
+	}
+
+	/* Null terminate */
+
+	*string = 0;
+	return (dst_string);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_strncpy (strncpy)
+ *
+ * PARAMETERS:  dst_string      - Target of the copy
+ *              src_string      - The source string to copy
+ *              Count           - Maximum # of bytes to copy
+ *
+ * RETURN:      dst_string
+ *
+ * DESCRIPTION: Copy a null terminated string, with a maximum length
+ *
+ ******************************************************************************/
+
+char *acpi_ut_strncpy(char *dst_string, const char *src_string, acpi_size count)
+{
+	char *string = dst_string;
+
+	/* Copy the string */
+
+	for (string = dst_string;
+	     count && (count--, (*string++ = *src_string++));) {;
+	}
+
+	/* Pad with nulls if necessary */
+
+	while (count--) {
+		*string = 0;
+		string++;
+	}
+
+	/* Return original pointer */
+
+	return (dst_string);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_strcmp (strcmp)
+ *
+ * PARAMETERS:  String1         - First string
+ *              String2         - Second string
+ *
+ * RETURN:      Index where strings mismatched, or 0 if strings matched
+ *
+ * DESCRIPTION: Compare two null terminated strings
+ *
+ ******************************************************************************/
+
+int acpi_ut_strcmp(const char *string1, const char *string2)
+{
+
+	for (; (*string1 == *string2); string2++) {
+		if (!*string1++) {
+			return (0);
+		}
+	}
+
+	return ((unsigned char)*string1 - (unsigned char)*string2);
+}
+
+#ifdef ACPI_FUTURE_IMPLEMENTATION
+/* Not used at this time */
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_strchr (strchr)
+ *
+ * PARAMETERS:  String          - Search string
+ *              ch              - character to search for
+ *
+ * RETURN:      Ptr to char or NULL if not found
+ *
+ * DESCRIPTION: Search a string for a character
+ *
+ ******************************************************************************/
+
+char *acpi_ut_strchr(const char *string, int ch)
+{
+
+	for (; (*string); string++) {
+		if ((*string) == (char)ch) {
+			return ((char *)string);
+		}
+	}
+
+	return (NULL);
+}
+#endif
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_strncmp (strncmp)
+ *
+ * PARAMETERS:  String1         - First string
+ *              String2         - Second string
+ *              Count           - Maximum # of bytes to compare
+ *
+ * RETURN:      Index where strings mismatched, or 0 if strings matched
+ *
+ * DESCRIPTION: Compare two null terminated strings, with a maximum length
+ *
+ ******************************************************************************/
+
+int acpi_ut_strncmp(const char *string1, const char *string2, acpi_size count)
+{
+
+	for (; count-- && (*string1 == *string2); string2++) {
+		if (!*string1++) {
+			return (0);
+		}
+	}
+
+	return ((count == ACPI_SIZE_MAX) ? 0 : ((unsigned char)*string1 -
+						(unsigned char)*string2));
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_strcat (Strcat)
+ *
+ * PARAMETERS:  dst_string      - Target of the copy
+ *              src_string      - The source string to copy
+ *
+ * RETURN:      dst_string
+ *
+ * DESCRIPTION: Append a null terminated string to a null terminated string
+ *
+ ******************************************************************************/
+
+char *acpi_ut_strcat(char *dst_string, const char *src_string)
+{
+	char *string;
+
+	/* Find end of the destination string */
+
+	for (string = dst_string; *string++;) {;
+	}
+
+	/* Concatenate the string */
+
+	for (--string; (*string++ = *src_string++);) {;
+	}
+
+	return (dst_string);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_strncat (strncat)
+ *
+ * PARAMETERS:  dst_string      - Target of the copy
+ *              src_string      - The source string to copy
+ *              Count           - Maximum # of bytes to copy
+ *
+ * RETURN:      dst_string
+ *
+ * DESCRIPTION: Append a null terminated string to a null terminated string,
+ *              with a maximum count.
+ *
+ ******************************************************************************/
+
+char *acpi_ut_strncat(char *dst_string, const char *src_string, acpi_size count)
+{
+	char *string;
+
+	if (count) {
+
+		/* Find end of the destination string */
+
+		for (string = dst_string; *string++;) {;
+		}
+
+		/* Concatenate the string */
+
+		for (--string; (*string++ = *src_string++) && --count;) {;
+		}
+
+		/* Null terminate if necessary */
+
+		if (!count) {
+			*string = 0;
+		}
+	}
+
+	return (dst_string);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_strstr (strstr)
+ *
+ * PARAMETERS:  String1         - Target string
+ *              String2         - Substring to search for
+ *
+ * RETURN:      Where substring match starts, Null if no match found
+ *
+ * DESCRIPTION: Checks if String2 occurs in String1. This is not really a
+ *              full implementation of strstr, only sufficient for command
+ *              matching
+ *
+ ******************************************************************************/
+
+char *acpi_ut_strstr(char *string1, char *string2)
+{
+	char *string;
+
+	if (acpi_ut_strlen(string2) > acpi_ut_strlen(string1)) {
+		return (NULL);
+	}
+
+	/* Walk entire string, comparing the letters */
+
+	for (string = string1; *string2;) {
+		if (*string2 != *string) {
+			return (NULL);
+		}
+
+		string2++;
+		string++;
+	}
+
+	return (string1);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_strtoul (strtoul)
+ *
+ * PARAMETERS:  String          - Null terminated string
+ *              Terminater      - Where a pointer to the terminating byte is
+ *                                returned
+ *              Base            - Radix of the string
+ *
+ * RETURN:      Converted value
+ *
+ * DESCRIPTION: Convert a string into a 32-bit unsigned value.
+ *              Note: use acpi_ut_strtoul64 for 64-bit integers.
+ *
+ ******************************************************************************/
+
+u32 acpi_ut_strtoul(const char *string, char **terminator, u32 base)
+{
+	u32 converted = 0;
+	u32 index;
+	u32 sign;
+	const char *string_start;
+	u32 return_value = 0;
+	acpi_status status = AE_OK;
+
+	/*
+	 * Save the value of the pointer to the buffer's first
+	 * character, save the current errno value, and then
+	 * skip over any white space in the buffer:
+	 */
+	string_start = string;
+	while (ACPI_IS_SPACE(*string) || *string == '\t') {
+		++string;
+	}
+
+	/*
+	 * The buffer may contain an optional plus or minus sign.
+	 * If it does, then skip over it but remember what is was:
+	 */
+	if (*string == '-') {
+		sign = NEGATIVE;
+		++string;
+	} else if (*string == '+') {
+		++string;
+		sign = POSITIVE;
+	} else {
+		sign = POSITIVE;
+	}
+
+	/*
+	 * If the input parameter Base is zero, then we need to
+	 * determine if it is octal, decimal, or hexadecimal:
+	 */
+	if (base == 0) {
+		if (*string == '0') {
+			if (acpi_ut_to_lower(*(++string)) == 'x') {
+				base = 16;
+				++string;
+			} else {
+				base = 8;
+			}
+		} else {
+			base = 10;
+		}
+	} else if (base < 2 || base > 36) {
+		/*
+		 * The specified Base parameter is not in the domain of
+		 * this function:
+		 */
+		goto done;
+	}
+
+	/*
+	 * For octal and hexadecimal bases, skip over the leading
+	 * 0 or 0x, if they are present.
+	 */
+	if (base == 8 && *string == '0') {
+		string++;
+	}
+
+	if (base == 16 &&
+	    *string == '0' && acpi_ut_to_lower(*(++string)) == 'x') {
+		string++;
+	}
+
+	/*
+	 * Main loop: convert the string to an unsigned long:
+	 */
+	while (*string) {
+		if (ACPI_IS_DIGIT(*string)) {
+			index = (u32)((u8)*string - '0');
+		} else {
+			index = (u32)acpi_ut_to_upper(*string);
+			if (ACPI_IS_UPPER(index)) {
+				index = index - 'A' + 10;
+			} else {
+				goto done;
+			}
+		}
+
+		if (index >= base) {
+			goto done;
+		}
+
+		/*
+		 * Check to see if value is out of range:
+		 */
+
+		if (return_value > ((ACPI_UINT32_MAX - (u32)index) / (u32)base)) {
+			status = AE_ERROR;
+			return_value = 0;	/* reset */
+		} else {
+			return_value *= base;
+			return_value += index;
+			converted = 1;
+		}
+
+		++string;
+	}
+
+      done:
+	/*
+	 * If appropriate, update the caller's pointer to the next
+	 * unconverted character in the buffer.
+	 */
+	if (terminator) {
+		if (converted == 0 && return_value == 0 && string != NULL) {
+			*terminator = (char *)string_start;
+		} else {
+			*terminator = (char *)string;
+		}
+	}
+
+	if (status == AE_ERROR) {
+		return_value = ACPI_UINT32_MAX;
+	}
+
+	/*
+	 * If a minus sign was present, then "the conversion is negated":
+	 */
+	if (sign == NEGATIVE) {
+		return_value = (ACPI_UINT32_MAX - return_value) + 1;
+	}
+
+	return (return_value);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_to_upper (TOUPPER)
+ *
+ * PARAMETERS:  c           - Character to convert
+ *
+ * RETURN:      Converted character as an int
+ *
+ * DESCRIPTION: Convert character to uppercase
+ *
+ ******************************************************************************/
+
+int acpi_ut_to_upper(int c)
+{
+
+	return (ACPI_IS_LOWER(c) ? ((c) - 0x20) : (c));
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_to_lower (TOLOWER)
+ *
+ * PARAMETERS:  c           - Character to convert
+ *
+ * RETURN:      Converted character as an int
+ *
+ * DESCRIPTION: Convert character to lowercase
+ *
+ ******************************************************************************/
+
+int acpi_ut_to_lower(int c)
+{
+
+	return (ACPI_IS_UPPER(c) ? ((c) + 0x20) : (c));
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    is* functions
+ *
+ * DESCRIPTION: is* functions use the ctype table below
+ *
+ ******************************************************************************/
+
+const u8 _acpi_ctype[257] = {
+	_ACPI_CN,		/* 0x0      0.     */
+	_ACPI_CN,		/* 0x1      1.     */
+	_ACPI_CN,		/* 0x2      2.     */
+	_ACPI_CN,		/* 0x3      3.     */
+	_ACPI_CN,		/* 0x4      4.     */
+	_ACPI_CN,		/* 0x5      5.     */
+	_ACPI_CN,		/* 0x6      6.     */
+	_ACPI_CN,		/* 0x7      7.     */
+	_ACPI_CN,		/* 0x8      8.     */
+	_ACPI_CN | _ACPI_SP,	/* 0x9      9.     */
+	_ACPI_CN | _ACPI_SP,	/* 0xA     10.     */
+	_ACPI_CN | _ACPI_SP,	/* 0xB     11.     */
+	_ACPI_CN | _ACPI_SP,	/* 0xC     12.     */
+	_ACPI_CN | _ACPI_SP,	/* 0xD     13.     */
+	_ACPI_CN,		/* 0xE     14.     */
+	_ACPI_CN,		/* 0xF     15.     */
+	_ACPI_CN,		/* 0x10    16.     */
+	_ACPI_CN,		/* 0x11    17.     */
+	_ACPI_CN,		/* 0x12    18.     */
+	_ACPI_CN,		/* 0x13    19.     */
+	_ACPI_CN,		/* 0x14    20.     */
+	_ACPI_CN,		/* 0x15    21.     */
+	_ACPI_CN,		/* 0x16    22.     */
+	_ACPI_CN,		/* 0x17    23.     */
+	_ACPI_CN,		/* 0x18    24.     */
+	_ACPI_CN,		/* 0x19    25.     */
+	_ACPI_CN,		/* 0x1A    26.     */
+	_ACPI_CN,		/* 0x1B    27.     */
+	_ACPI_CN,		/* 0x1C    28.     */
+	_ACPI_CN,		/* 0x1D    29.     */
+	_ACPI_CN,		/* 0x1E    30.     */
+	_ACPI_CN,		/* 0x1F    31.     */
+	_ACPI_XS | _ACPI_SP,	/* 0x20    32. ' ' */
+	_ACPI_PU,		/* 0x21    33. '!' */
+	_ACPI_PU,		/* 0x22    34. '"' */
+	_ACPI_PU,		/* 0x23    35. '#' */
+	_ACPI_PU,		/* 0x24    36. '$' */
+	_ACPI_PU,		/* 0x25    37. '%' */
+	_ACPI_PU,		/* 0x26    38. '&' */
+	_ACPI_PU,		/* 0x27    39. ''' */
+	_ACPI_PU,		/* 0x28    40. '(' */
+	_ACPI_PU,		/* 0x29    41. ')' */
+	_ACPI_PU,		/* 0x2A    42. '*' */
+	_ACPI_PU,		/* 0x2B    43. '+' */
+	_ACPI_PU,		/* 0x2C    44. ',' */
+	_ACPI_PU,		/* 0x2D    45. '-' */
+	_ACPI_PU,		/* 0x2E    46. '.' */
+	_ACPI_PU,		/* 0x2F    47. '/' */
+	_ACPI_XD | _ACPI_DI,	/* 0x30    48. '0' */
+	_ACPI_XD | _ACPI_DI,	/* 0x31    49. '1' */
+	_ACPI_XD | _ACPI_DI,	/* 0x32    50. '2' */
+	_ACPI_XD | _ACPI_DI,	/* 0x33    51. '3' */
+	_ACPI_XD | _ACPI_DI,	/* 0x34    52. '4' */
+	_ACPI_XD | _ACPI_DI,	/* 0x35    53. '5' */
+	_ACPI_XD | _ACPI_DI,	/* 0x36    54. '6' */
+	_ACPI_XD | _ACPI_DI,	/* 0x37    55. '7' */
+	_ACPI_XD | _ACPI_DI,	/* 0x38    56. '8' */
+	_ACPI_XD | _ACPI_DI,	/* 0x39    57. '9' */
+	_ACPI_PU,		/* 0x3A    58. ':' */
+	_ACPI_PU,		/* 0x3B    59. ';' */
+	_ACPI_PU,		/* 0x3C    60. '<' */
+	_ACPI_PU,		/* 0x3D    61. '=' */
+	_ACPI_PU,		/* 0x3E    62. '>' */
+	_ACPI_PU,		/* 0x3F    63. '?' */
+	_ACPI_PU,		/* 0x40    64. '@' */
+	_ACPI_XD | _ACPI_UP,	/* 0x41    65. 'A' */
+	_ACPI_XD | _ACPI_UP,	/* 0x42    66. 'B' */
+	_ACPI_XD | _ACPI_UP,	/* 0x43    67. 'C' */
+	_ACPI_XD | _ACPI_UP,	/* 0x44    68. 'D' */
+	_ACPI_XD | _ACPI_UP,	/* 0x45    69. 'E' */
+	_ACPI_XD | _ACPI_UP,	/* 0x46    70. 'F' */
+	_ACPI_UP,		/* 0x47    71. 'G' */
+	_ACPI_UP,		/* 0x48    72. 'H' */
+	_ACPI_UP,		/* 0x49    73. 'I' */
+	_ACPI_UP,		/* 0x4A    74. 'J' */
+	_ACPI_UP,		/* 0x4B    75. 'K' */
+	_ACPI_UP,		/* 0x4C    76. 'L' */
+	_ACPI_UP,		/* 0x4D    77. 'M' */
+	_ACPI_UP,		/* 0x4E    78. 'N' */
+	_ACPI_UP,		/* 0x4F    79. 'O' */
+	_ACPI_UP,		/* 0x50    80. 'P' */
+	_ACPI_UP,		/* 0x51    81. 'Q' */
+	_ACPI_UP,		/* 0x52    82. 'R' */
+	_ACPI_UP,		/* 0x53    83. 'S' */
+	_ACPI_UP,		/* 0x54    84. 'T' */
+	_ACPI_UP,		/* 0x55    85. 'U' */
+	_ACPI_UP,		/* 0x56    86. 'V' */
+	_ACPI_UP,		/* 0x57    87. 'W' */
+	_ACPI_UP,		/* 0x58    88. 'X' */
+	_ACPI_UP,		/* 0x59    89. 'Y' */
+	_ACPI_UP,		/* 0x5A    90. 'Z' */
+	_ACPI_PU,		/* 0x5B    91. '[' */
+	_ACPI_PU,		/* 0x5C    92. '\' */
+	_ACPI_PU,		/* 0x5D    93. ']' */
+	_ACPI_PU,		/* 0x5E    94. '^' */
+	_ACPI_PU,		/* 0x5F    95. '_' */
+	_ACPI_PU,		/* 0x60    96. '`' */
+	_ACPI_XD | _ACPI_LO,	/* 0x61    97. 'a' */
+	_ACPI_XD | _ACPI_LO,	/* 0x62    98. 'b' */
+	_ACPI_XD | _ACPI_LO,	/* 0x63    99. 'c' */
+	_ACPI_XD | _ACPI_LO,	/* 0x64   100. 'd' */
+	_ACPI_XD | _ACPI_LO,	/* 0x65   101. 'e' */
+	_ACPI_XD | _ACPI_LO,	/* 0x66   102. 'f' */
+	_ACPI_LO,		/* 0x67   103. 'g' */
+	_ACPI_LO,		/* 0x68   104. 'h' */
+	_ACPI_LO,		/* 0x69   105. 'i' */
+	_ACPI_LO,		/* 0x6A   106. 'j' */
+	_ACPI_LO,		/* 0x6B   107. 'k' */
+	_ACPI_LO,		/* 0x6C   108. 'l' */
+	_ACPI_LO,		/* 0x6D   109. 'm' */
+	_ACPI_LO,		/* 0x6E   110. 'n' */
+	_ACPI_LO,		/* 0x6F   111. 'o' */
+	_ACPI_LO,		/* 0x70   112. 'p' */
+	_ACPI_LO,		/* 0x71   113. 'q' */
+	_ACPI_LO,		/* 0x72   114. 'r' */
+	_ACPI_LO,		/* 0x73   115. 's' */
+	_ACPI_LO,		/* 0x74   116. 't' */
+	_ACPI_LO,		/* 0x75   117. 'u' */
+	_ACPI_LO,		/* 0x76   118. 'v' */
+	_ACPI_LO,		/* 0x77   119. 'w' */
+	_ACPI_LO,		/* 0x78   120. 'x' */
+	_ACPI_LO,		/* 0x79   121. 'y' */
+	_ACPI_LO,		/* 0x7A   122. 'z' */
+	_ACPI_PU,		/* 0x7B   123. '{' */
+	_ACPI_PU,		/* 0x7C   124. '|' */
+	_ACPI_PU,		/* 0x7D   125. '}' */
+	_ACPI_PU,		/* 0x7E   126. '~' */
+	_ACPI_CN,		/* 0x7F   127.     */
+
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 0x80 to 0x8F    */
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 0x90 to 0x9F    */
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 0xA0 to 0xAF    */
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 0xB0 to 0xBF    */
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 0xC0 to 0xCF    */
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 0xD0 to 0xDF    */
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 0xE0 to 0xEF    */
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0	/* 0xF0 to 0x100   */
+};
+
+#endif				/* ACPI_USE_SYSTEM_CLIBRARY */
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utcopy.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utcopy.c
new file mode 100644
index 00000000..5b7475a8
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utcopy.c
@@ -0,0 +1,1001 @@
+/******************************************************************************
+ *
+ * Module Name: utcopy - Internal to external object translation utilities
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acnamesp.h"
+
+#define _COMPONENT          ACPI_UTILITIES
+ACPI_MODULE_NAME("utcopy")
+
+/* Local prototypes */
+static acpi_status
+acpi_ut_copy_isimple_to_esimple(union acpi_operand_object *internal_object,
+				union acpi_object *external_object,
+				u8 *data_space, acpi_size * buffer_space_used);
+
+static acpi_status
+acpi_ut_copy_ielement_to_ielement(u8 object_type,
+				  union acpi_operand_object *source_object,
+				  union acpi_generic_state *state,
+				  void *context);
+
+static acpi_status
+acpi_ut_copy_ipackage_to_epackage(union acpi_operand_object *internal_object,
+				  u8 *buffer, acpi_size * space_used);
+
+static acpi_status
+acpi_ut_copy_esimple_to_isimple(union acpi_object *user_obj,
+				union acpi_operand_object **return_obj);
+
+static acpi_status
+acpi_ut_copy_epackage_to_ipackage(union acpi_object *external_object,
+				  union acpi_operand_object **internal_object);
+
+static acpi_status
+acpi_ut_copy_simple_object(union acpi_operand_object *source_desc,
+			   union acpi_operand_object *dest_desc);
+
+static acpi_status
+acpi_ut_copy_ielement_to_eelement(u8 object_type,
+				  union acpi_operand_object *source_object,
+				  union acpi_generic_state *state,
+				  void *context);
+
+static acpi_status
+acpi_ut_copy_ipackage_to_ipackage(union acpi_operand_object *source_obj,
+				  union acpi_operand_object *dest_obj,
+				  struct acpi_walk_state *walk_state);
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_copy_isimple_to_esimple
+ *
+ * PARAMETERS:  internal_object     - Source object to be copied
+ *              external_object     - Where to return the copied object
+ *              data_space          - Where object data is returned (such as
+ *                                    buffer and string data)
+ *              buffer_space_used   - Length of data_space that was used
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: This function is called to copy a simple internal object to
+ *              an external object.
+ *
+ *              The data_space buffer is assumed to have sufficient space for
+ *              the object.
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ut_copy_isimple_to_esimple(union acpi_operand_object *internal_object,
+				union acpi_object *external_object,
+				u8 *data_space, acpi_size * buffer_space_used)
+{
+	acpi_status status = AE_OK;
+
+	ACPI_FUNCTION_TRACE(ut_copy_isimple_to_esimple);
+
+	*buffer_space_used = 0;
+
+	/*
+	 * Check for NULL object case (could be an uninitialized
+	 * package element)
+	 */
+	if (!internal_object) {
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	/* Always clear the external object */
+
+	ACPI_MEMSET(external_object, 0, sizeof(union acpi_object));
+
+	/*
+	 * In general, the external object will be the same type as
+	 * the internal object
+	 */
+	external_object->type = internal_object->common.type;
+
+	/* However, only a limited number of external types are supported */
+
+	switch (internal_object->common.type) {
+	case ACPI_TYPE_STRING:
+
+		external_object->string.pointer = (char *)data_space;
+		external_object->string.length = internal_object->string.length;
+		*buffer_space_used = ACPI_ROUND_UP_TO_NATIVE_WORD((acpi_size)
+								  internal_object->
+								  string.
+								  length + 1);
+
+		ACPI_MEMCPY((void *)data_space,
+			    (void *)internal_object->string.pointer,
+			    (acpi_size) internal_object->string.length + 1);
+		break;
+
+	case ACPI_TYPE_BUFFER:
+
+		external_object->buffer.pointer = data_space;
+		external_object->buffer.length = internal_object->buffer.length;
+		*buffer_space_used =
+		    ACPI_ROUND_UP_TO_NATIVE_WORD(internal_object->string.
+						 length);
+
+		ACPI_MEMCPY((void *)data_space,
+			    (void *)internal_object->buffer.pointer,
+			    internal_object->buffer.length);
+		break;
+
+	case ACPI_TYPE_INTEGER:
+
+		external_object->integer.value = internal_object->integer.value;
+		break;
+
+	case ACPI_TYPE_LOCAL_REFERENCE:
+
+		/* This is an object reference. */
+
+		switch (internal_object->reference.class) {
+		case ACPI_REFCLASS_NAME:
+
+			/*
+			 * For namepath, return the object handle ("reference")
+			 * We are referring to the namespace node
+			 */
+			external_object->reference.handle =
+			    internal_object->reference.node;
+			external_object->reference.actual_type =
+			    acpi_ns_get_type(internal_object->reference.node);
+			break;
+
+		default:
+
+			/* All other reference types are unsupported */
+
+			return_ACPI_STATUS(AE_TYPE);
+		}
+		break;
+
+	case ACPI_TYPE_PROCESSOR:
+
+		external_object->processor.proc_id =
+		    internal_object->processor.proc_id;
+		external_object->processor.pblk_address =
+		    internal_object->processor.address;
+		external_object->processor.pblk_length =
+		    internal_object->processor.length;
+		break;
+
+	case ACPI_TYPE_POWER:
+
+		external_object->power_resource.system_level =
+		    internal_object->power_resource.system_level;
+
+		external_object->power_resource.resource_order =
+		    internal_object->power_resource.resource_order;
+		break;
+
+	default:
+		/*
+		 * There is no corresponding external object type
+		 */
+		ACPI_ERROR((AE_INFO,
+			    "Unsupported object type, cannot convert to external object: %s",
+			    acpi_ut_get_type_name(internal_object->common.
+						  type)));
+
+		return_ACPI_STATUS(AE_SUPPORT);
+	}
+
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_copy_ielement_to_eelement
+ *
+ * PARAMETERS:  acpi_pkg_callback
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Copy one package element to another package element
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ut_copy_ielement_to_eelement(u8 object_type,
+				  union acpi_operand_object *source_object,
+				  union acpi_generic_state *state,
+				  void *context)
+{
+	acpi_status status = AE_OK;
+	struct acpi_pkg_info *info = (struct acpi_pkg_info *)context;
+	acpi_size object_space;
+	u32 this_index;
+	union acpi_object *target_object;
+
+	ACPI_FUNCTION_ENTRY();
+
+	this_index = state->pkg.index;
+	target_object = (union acpi_object *)
+	    &((union acpi_object *)(state->pkg.dest_object))->package.
+	    elements[this_index];
+
+	switch (object_type) {
+	case ACPI_COPY_TYPE_SIMPLE:
+
+		/*
+		 * This is a simple or null object
+		 */
+		status = acpi_ut_copy_isimple_to_esimple(source_object,
+							 target_object,
+							 info->free_space,
+							 &object_space);
+		if (ACPI_FAILURE(status)) {
+			return (status);
+		}
+		break;
+
+	case ACPI_COPY_TYPE_PACKAGE:
+
+		/*
+		 * Build the package object
+		 */
+		target_object->type = ACPI_TYPE_PACKAGE;
+		target_object->package.count = source_object->package.count;
+		target_object->package.elements =
+		    ACPI_CAST_PTR(union acpi_object, info->free_space);
+
+		/*
+		 * Pass the new package object back to the package walk routine
+		 */
+		state->pkg.this_target_obj = target_object;
+
+		/*
+		 * Save space for the array of objects (Package elements)
+		 * update the buffer length counter
+		 */
+		object_space = ACPI_ROUND_UP_TO_NATIVE_WORD((acpi_size)
+							    target_object->
+							    package.count *
+							    sizeof(union
+								   acpi_object));
+		break;
+
+	default:
+		return (AE_BAD_PARAMETER);
+	}
+
+	info->free_space += object_space;
+	info->length += object_space;
+	return (status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_copy_ipackage_to_epackage
+ *
+ * PARAMETERS:  internal_object     - Pointer to the object we are returning
+ *              Buffer              - Where the object is returned
+ *              space_used          - Where the object length is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: This function is called to place a package object in a user
+ *              buffer. A package object by definition contains other objects.
+ *
+ *              The buffer is assumed to have sufficient space for the object.
+ *              The caller must have verified the buffer length needed using
+ *              the acpi_ut_get_object_size function before calling this function.
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ut_copy_ipackage_to_epackage(union acpi_operand_object *internal_object,
+				  u8 *buffer, acpi_size * space_used)
+{
+	union acpi_object *external_object;
+	acpi_status status;
+	struct acpi_pkg_info info;
+
+	ACPI_FUNCTION_TRACE(ut_copy_ipackage_to_epackage);
+
+	/*
+	 * First package at head of the buffer
+	 */
+	external_object = ACPI_CAST_PTR(union acpi_object, buffer);
+
+	/*
+	 * Free space begins right after the first package
+	 */
+	info.length = ACPI_ROUND_UP_TO_NATIVE_WORD(sizeof(union acpi_object));
+	info.free_space =
+	    buffer + ACPI_ROUND_UP_TO_NATIVE_WORD(sizeof(union acpi_object));
+	info.object_space = 0;
+	info.num_packages = 1;
+
+	external_object->type = internal_object->common.type;
+	external_object->package.count = internal_object->package.count;
+	external_object->package.elements = ACPI_CAST_PTR(union acpi_object,
+							  info.free_space);
+
+	/*
+	 * Leave room for an array of ACPI_OBJECTS in the buffer
+	 * and move the free space past it
+	 */
+	info.length += (acpi_size) external_object->package.count *
+	    ACPI_ROUND_UP_TO_NATIVE_WORD(sizeof(union acpi_object));
+	info.free_space += external_object->package.count *
+	    ACPI_ROUND_UP_TO_NATIVE_WORD(sizeof(union acpi_object));
+
+	status = acpi_ut_walk_package_tree(internal_object, external_object,
+					   acpi_ut_copy_ielement_to_eelement,
+					   &info);
+
+	*space_used = info.length;
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_copy_iobject_to_eobject
+ *
+ * PARAMETERS:  internal_object     - The internal object to be converted
+ *              ret_buffer          - Where the object is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: This function is called to build an API object to be returned
+ *              to the caller.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ut_copy_iobject_to_eobject(union acpi_operand_object *internal_object,
+				struct acpi_buffer *ret_buffer)
+{
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(ut_copy_iobject_to_eobject);
+
+	if (internal_object->common.type == ACPI_TYPE_PACKAGE) {
+		/*
+		 * Package object:  Copy all subobjects (including
+		 * nested packages)
+		 */
+		status = acpi_ut_copy_ipackage_to_epackage(internal_object,
+							   ret_buffer->pointer,
+							   &ret_buffer->length);
+	} else {
+		/*
+		 * Build a simple object (no nested objects)
+		 */
+		status = acpi_ut_copy_isimple_to_esimple(internal_object,
+							 ACPI_CAST_PTR(union
+								       acpi_object,
+								       ret_buffer->
+								       pointer),
+							 ACPI_ADD_PTR(u8,
+								      ret_buffer->
+								      pointer,
+								      ACPI_ROUND_UP_TO_NATIVE_WORD
+								      (sizeof
+								       (union
+									acpi_object))),
+							 &ret_buffer->length);
+		/*
+		 * build simple does not include the object size in the length
+		 * so we add it in here
+		 */
+		ret_buffer->length += sizeof(union acpi_object);
+	}
+
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_copy_esimple_to_isimple
+ *
+ * PARAMETERS:  external_object     - The external object to be converted
+ *              ret_internal_object - Where the internal object is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: This function copies an external object to an internal one.
+ *              NOTE: Pointers can be copied, we don't need to copy data.
+ *              (The pointers have to be valid in our address space no matter
+ *              what we do with them!)
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ut_copy_esimple_to_isimple(union acpi_object *external_object,
+				union acpi_operand_object **ret_internal_object)
+{
+	union acpi_operand_object *internal_object;
+
+	ACPI_FUNCTION_TRACE(ut_copy_esimple_to_isimple);
+
+	/*
+	 * Simple types supported are: String, Buffer, Integer
+	 */
+	switch (external_object->type) {
+	case ACPI_TYPE_STRING:
+	case ACPI_TYPE_BUFFER:
+	case ACPI_TYPE_INTEGER:
+	case ACPI_TYPE_LOCAL_REFERENCE:
+
+		internal_object = acpi_ut_create_internal_object((u8)
+								 external_object->
+								 type);
+		if (!internal_object) {
+			return_ACPI_STATUS(AE_NO_MEMORY);
+		}
+		break;
+
+	case ACPI_TYPE_ANY:	/* This is the case for a NULL object */
+
+		*ret_internal_object = NULL;
+		return_ACPI_STATUS(AE_OK);
+
+	default:
+		/* All other types are not supported */
+
+		ACPI_ERROR((AE_INFO,
+			    "Unsupported object type, cannot convert to internal object: %s",
+			    acpi_ut_get_type_name(external_object->type)));
+
+		return_ACPI_STATUS(AE_SUPPORT);
+	}
+
+	/* Must COPY string and buffer contents */
+
+	switch (external_object->type) {
+	case ACPI_TYPE_STRING:
+
+		internal_object->string.pointer =
+		    ACPI_ALLOCATE_ZEROED((acpi_size)
+					 external_object->string.length + 1);
+
+		if (!internal_object->string.pointer) {
+			goto error_exit;
+		}
+
+		ACPI_MEMCPY(internal_object->string.pointer,
+			    external_object->string.pointer,
+			    external_object->string.length);
+
+		internal_object->string.length = external_object->string.length;
+		break;
+
+	case ACPI_TYPE_BUFFER:
+
+		internal_object->buffer.pointer =
+		    ACPI_ALLOCATE_ZEROED(external_object->buffer.length);
+		if (!internal_object->buffer.pointer) {
+			goto error_exit;
+		}
+
+		ACPI_MEMCPY(internal_object->buffer.pointer,
+			    external_object->buffer.pointer,
+			    external_object->buffer.length);
+
+		internal_object->buffer.length = external_object->buffer.length;
+
+		/* Mark buffer data valid */
+
+		internal_object->buffer.flags |= AOPOBJ_DATA_VALID;
+		break;
+
+	case ACPI_TYPE_INTEGER:
+
+		internal_object->integer.value = external_object->integer.value;
+		break;
+
+	case ACPI_TYPE_LOCAL_REFERENCE:
+
+		/* TBD: should validate incoming handle */
+
+		internal_object->reference.class = ACPI_REFCLASS_NAME;
+		internal_object->reference.node =
+		    external_object->reference.handle;
+		break;
+
+	default:
+		/* Other types can't get here */
+		break;
+	}
+
+	*ret_internal_object = internal_object;
+	return_ACPI_STATUS(AE_OK);
+
+      error_exit:
+	acpi_ut_remove_reference(internal_object);
+	return_ACPI_STATUS(AE_NO_MEMORY);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_copy_epackage_to_ipackage
+ *
+ * PARAMETERS:  external_object     - The external object to be converted
+ *              internal_object     - Where the internal object is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Copy an external package object to an internal package.
+ *              Handles nested packages.
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ut_copy_epackage_to_ipackage(union acpi_object *external_object,
+				  union acpi_operand_object **internal_object)
+{
+	acpi_status status = AE_OK;
+	union acpi_operand_object *package_object;
+	union acpi_operand_object **package_elements;
+	u32 i;
+
+	ACPI_FUNCTION_TRACE(ut_copy_epackage_to_ipackage);
+
+	/* Create the package object */
+
+	package_object =
+	    acpi_ut_create_package_object(external_object->package.count);
+	if (!package_object) {
+		return_ACPI_STATUS(AE_NO_MEMORY);
+	}
+
+	package_elements = package_object->package.elements;
+
+	/*
+	 * Recursive implementation. Probably ok, since nested external packages
+	 * as parameters should be very rare.
+	 */
+	for (i = 0; i < external_object->package.count; i++) {
+		status =
+		    acpi_ut_copy_eobject_to_iobject(&external_object->package.
+						    elements[i],
+						    &package_elements[i]);
+		if (ACPI_FAILURE(status)) {
+
+			/* Truncate package and delete it */
+
+			package_object->package.count = i;
+			package_elements[i] = NULL;
+			acpi_ut_remove_reference(package_object);
+			return_ACPI_STATUS(status);
+		}
+	}
+
+	/* Mark package data valid */
+
+	package_object->package.flags |= AOPOBJ_DATA_VALID;
+
+	*internal_object = package_object;
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_copy_eobject_to_iobject
+ *
+ * PARAMETERS:  external_object     - The external object to be converted
+ *              internal_object     - Where the internal object is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Converts an external object to an internal object.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ut_copy_eobject_to_iobject(union acpi_object *external_object,
+				union acpi_operand_object **internal_object)
+{
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(ut_copy_eobject_to_iobject);
+
+	if (external_object->type == ACPI_TYPE_PACKAGE) {
+		status =
+		    acpi_ut_copy_epackage_to_ipackage(external_object,
+						      internal_object);
+	} else {
+		/*
+		 * Build a simple object (no nested objects)
+		 */
+		status =
+		    acpi_ut_copy_esimple_to_isimple(external_object,
+						    internal_object);
+	}
+
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_copy_simple_object
+ *
+ * PARAMETERS:  source_desc         - The internal object to be copied
+ *              dest_desc           - New target object
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Simple copy of one internal object to another. Reference count
+ *              of the destination object is preserved.
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ut_copy_simple_object(union acpi_operand_object *source_desc,
+			   union acpi_operand_object *dest_desc)
+{
+	u16 reference_count;
+	union acpi_operand_object *next_object;
+	acpi_status status;
+	acpi_size copy_size;
+
+	/* Save fields from destination that we don't want to overwrite */
+
+	reference_count = dest_desc->common.reference_count;
+	next_object = dest_desc->common.next_object;
+
+	/*
+	 * Copy the entire source object over the destination object.
+	 * Note: Source can be either an operand object or namespace node.
+	 */
+	copy_size = sizeof(union acpi_operand_object);
+	if (ACPI_GET_DESCRIPTOR_TYPE(source_desc) == ACPI_DESC_TYPE_NAMED) {
+		copy_size = sizeof(struct acpi_namespace_node);
+	}
+
+	ACPI_MEMCPY(ACPI_CAST_PTR(char, dest_desc),
+		    ACPI_CAST_PTR(char, source_desc), copy_size);
+
+	/* Restore the saved fields */
+
+	dest_desc->common.reference_count = reference_count;
+	dest_desc->common.next_object = next_object;
+
+	/* New object is not static, regardless of source */
+
+	dest_desc->common.flags &= ~AOPOBJ_STATIC_POINTER;
+
+	/* Handle the objects with extra data */
+
+	switch (dest_desc->common.type) {
+	case ACPI_TYPE_BUFFER:
+		/*
+		 * Allocate and copy the actual buffer if and only if:
+		 * 1) There is a valid buffer pointer
+		 * 2) The buffer has a length > 0
+		 */
+		if ((source_desc->buffer.pointer) &&
+		    (source_desc->buffer.length)) {
+			dest_desc->buffer.pointer =
+			    ACPI_ALLOCATE(source_desc->buffer.length);
+			if (!dest_desc->buffer.pointer) {
+				return (AE_NO_MEMORY);
+			}
+
+			/* Copy the actual buffer data */
+
+			ACPI_MEMCPY(dest_desc->buffer.pointer,
+				    source_desc->buffer.pointer,
+				    source_desc->buffer.length);
+		}
+		break;
+
+	case ACPI_TYPE_STRING:
+		/*
+		 * Allocate and copy the actual string if and only if:
+		 * 1) There is a valid string pointer
+		 * (Pointer to a NULL string is allowed)
+		 */
+		if (source_desc->string.pointer) {
+			dest_desc->string.pointer =
+			    ACPI_ALLOCATE((acpi_size) source_desc->string.
+					  length + 1);
+			if (!dest_desc->string.pointer) {
+				return (AE_NO_MEMORY);
+			}
+
+			/* Copy the actual string data */
+
+			ACPI_MEMCPY(dest_desc->string.pointer,
+				    source_desc->string.pointer,
+				    (acpi_size) source_desc->string.length + 1);
+		}
+		break;
+
+	case ACPI_TYPE_LOCAL_REFERENCE:
+		/*
+		 * We copied the reference object, so we now must add a reference
+		 * to the object pointed to by the reference
+		 *
+		 * DDBHandle reference (from Load/load_table) is a special reference,
+		 * it does not have a Reference.Object, so does not need to
+		 * increase the reference count
+		 */
+		if (source_desc->reference.class == ACPI_REFCLASS_TABLE) {
+			break;
+		}
+
+		acpi_ut_add_reference(source_desc->reference.object);
+		break;
+
+	case ACPI_TYPE_REGION:
+		/*
+		 * We copied the Region Handler, so we now must add a reference
+		 */
+		if (dest_desc->region.handler) {
+			acpi_ut_add_reference(dest_desc->region.handler);
+		}
+		break;
+
+		/*
+		 * For Mutex and Event objects, we cannot simply copy the underlying
+		 * OS object. We must create a new one.
+		 */
+	case ACPI_TYPE_MUTEX:
+
+		status = acpi_os_create_mutex(&dest_desc->mutex.os_mutex);
+		if (ACPI_FAILURE(status)) {
+			return (status);
+		}
+		break;
+
+	case ACPI_TYPE_EVENT:
+
+		status = acpi_os_create_semaphore(ACPI_NO_UNIT_LIMIT, 0,
+						  &dest_desc->event.
+						  os_semaphore);
+		if (ACPI_FAILURE(status)) {
+			return (status);
+		}
+		break;
+
+	default:
+		/* Nothing to do for other simple objects */
+		break;
+	}
+
+	return (AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_copy_ielement_to_ielement
+ *
+ * PARAMETERS:  acpi_pkg_callback
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Copy one package element to another package element
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ut_copy_ielement_to_ielement(u8 object_type,
+				  union acpi_operand_object *source_object,
+				  union acpi_generic_state *state,
+				  void *context)
+{
+	acpi_status status = AE_OK;
+	u32 this_index;
+	union acpi_operand_object **this_target_ptr;
+	union acpi_operand_object *target_object;
+
+	ACPI_FUNCTION_ENTRY();
+
+	this_index = state->pkg.index;
+	this_target_ptr = (union acpi_operand_object **)
+	    &state->pkg.dest_object->package.elements[this_index];
+
+	switch (object_type) {
+	case ACPI_COPY_TYPE_SIMPLE:
+
+		/* A null source object indicates a (legal) null package element */
+
+		if (source_object) {
+			/*
+			 * This is a simple object, just copy it
+			 */
+			target_object =
+			    acpi_ut_create_internal_object(source_object->
+							   common.type);
+			if (!target_object) {
+				return (AE_NO_MEMORY);
+			}
+
+			status =
+			    acpi_ut_copy_simple_object(source_object,
+						       target_object);
+			if (ACPI_FAILURE(status)) {
+				goto error_exit;
+			}
+
+			*this_target_ptr = target_object;
+		} else {
+			/* Pass through a null element */
+
+			*this_target_ptr = NULL;
+		}
+		break;
+
+	case ACPI_COPY_TYPE_PACKAGE:
+
+		/*
+		 * This object is a package - go down another nesting level
+		 * Create and build the package object
+		 */
+		target_object =
+		    acpi_ut_create_package_object(source_object->package.count);
+		if (!target_object) {
+			return (AE_NO_MEMORY);
+		}
+
+		target_object->common.flags = source_object->common.flags;
+
+		/* Pass the new package object back to the package walk routine */
+
+		state->pkg.this_target_obj = target_object;
+
+		/* Store the object pointer in the parent package object */
+
+		*this_target_ptr = target_object;
+		break;
+
+	default:
+		return (AE_BAD_PARAMETER);
+	}
+
+	return (status);
+
+      error_exit:
+	acpi_ut_remove_reference(target_object);
+	return (status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_copy_ipackage_to_ipackage
+ *
+ * PARAMETERS:  source_obj      - Pointer to the source package object
+ *              dest_obj        - Where the internal object is returned
+ *              walk_state      - Current Walk state descriptor
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: This function is called to copy an internal package object
+ *              into another internal package object.
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ut_copy_ipackage_to_ipackage(union acpi_operand_object *source_obj,
+				  union acpi_operand_object *dest_obj,
+				  struct acpi_walk_state *walk_state)
+{
+	acpi_status status = AE_OK;
+
+	ACPI_FUNCTION_TRACE(ut_copy_ipackage_to_ipackage);
+
+	dest_obj->common.type = source_obj->common.type;
+	dest_obj->common.flags = source_obj->common.flags;
+	dest_obj->package.count = source_obj->package.count;
+
+	/*
+	 * Create the object array and walk the source package tree
+	 */
+	dest_obj->package.elements = ACPI_ALLOCATE_ZEROED(((acpi_size)
+							   source_obj->package.
+							   count +
+							   1) * sizeof(void *));
+	if (!dest_obj->package.elements) {
+		ACPI_ERROR((AE_INFO, "Package allocation failure"));
+		return_ACPI_STATUS(AE_NO_MEMORY);
+	}
+
+	/*
+	 * Copy the package element-by-element by walking the package "tree".
+	 * This handles nested packages of arbitrary depth.
+	 */
+	status = acpi_ut_walk_package_tree(source_obj, dest_obj,
+					   acpi_ut_copy_ielement_to_ielement,
+					   walk_state);
+	if (ACPI_FAILURE(status)) {
+
+		/* On failure, delete the destination package object */
+
+		acpi_ut_remove_reference(dest_obj);
+	}
+
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_copy_iobject_to_iobject
+ *
+ * PARAMETERS:  source_desc         - The internal object to be copied
+ *              dest_desc           - Where the copied object is returned
+ *              walk_state          - Current walk state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Copy an internal object to a new internal object
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ut_copy_iobject_to_iobject(union acpi_operand_object *source_desc,
+				union acpi_operand_object **dest_desc,
+				struct acpi_walk_state *walk_state)
+{
+	acpi_status status = AE_OK;
+
+	ACPI_FUNCTION_TRACE(ut_copy_iobject_to_iobject);
+
+	/* Create the top level object */
+
+	*dest_desc = acpi_ut_create_internal_object(source_desc->common.type);
+	if (!*dest_desc) {
+		return_ACPI_STATUS(AE_NO_MEMORY);
+	}
+
+	/* Copy the object and possible subobjects */
+
+	if (source_desc->common.type == ACPI_TYPE_PACKAGE) {
+		status =
+		    acpi_ut_copy_ipackage_to_ipackage(source_desc, *dest_desc,
+						      walk_state);
+	} else {
+		status = acpi_ut_copy_simple_object(source_desc, *dest_desc);
+	}
+
+	return_ACPI_STATUS(status);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utdebug.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utdebug.c
new file mode 100644
index 00000000..d7dc6961
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utdebug.c
@@ -0,0 +1,650 @@
+/******************************************************************************
+ *
+ * Module Name: utdebug - Debug print routines
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+
+#define _COMPONENT          ACPI_UTILITIES
+ACPI_MODULE_NAME("utdebug")
+
+#ifdef ACPI_DEBUG_OUTPUT
+static acpi_thread_id acpi_gbl_prev_thread_id = (acpi_thread_id) 0xFFFFFFFF;
+static char *acpi_gbl_fn_entry_str = "----Entry";
+static char *acpi_gbl_fn_exit_str = "----Exit-";
+
+/* Local prototypes */
+
+static const char *acpi_ut_trim_function_name(const char *function_name);
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_init_stack_ptr_trace
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Save the current CPU stack pointer at subsystem startup
+ *
+ ******************************************************************************/
+
+void acpi_ut_init_stack_ptr_trace(void)
+{
+	acpi_size current_sp;
+
+	acpi_gbl_entry_stack_pointer = &current_sp;
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_track_stack_ptr
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Save the current CPU stack pointer
+ *
+ ******************************************************************************/
+
+void acpi_ut_track_stack_ptr(void)
+{
+	acpi_size current_sp;
+
+	if (&current_sp < acpi_gbl_lowest_stack_pointer) {
+		acpi_gbl_lowest_stack_pointer = &current_sp;
+	}
+
+	if (acpi_gbl_nesting_level > acpi_gbl_deepest_nesting) {
+		acpi_gbl_deepest_nesting = acpi_gbl_nesting_level;
+	}
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_trim_function_name
+ *
+ * PARAMETERS:  function_name       - Ascii string containing a procedure name
+ *
+ * RETURN:      Updated pointer to the function name
+ *
+ * DESCRIPTION: Remove the "Acpi" prefix from the function name, if present.
+ *              This allows compiler macros such as __FUNCTION__ to be used
+ *              with no change to the debug output.
+ *
+ ******************************************************************************/
+
+static const char *acpi_ut_trim_function_name(const char *function_name)
+{
+
+	/* All Function names are longer than 4 chars, check is safe */
+
+	if (*(ACPI_CAST_PTR(u32, function_name)) == ACPI_PREFIX_MIXED) {
+
+		/* This is the case where the original source has not been modified */
+
+		return (function_name + 4);
+	}
+
+	if (*(ACPI_CAST_PTR(u32, function_name)) == ACPI_PREFIX_LOWER) {
+
+		/* This is the case where the source has been 'linuxized' */
+
+		return (function_name + 5);
+	}
+
+	return (function_name);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_debug_print
+ *
+ * PARAMETERS:  requested_debug_level - Requested debug print level
+ *              line_number         - Caller's line number (for error output)
+ *              function_name       - Caller's procedure name
+ *              module_name         - Caller's module name
+ *              component_id        - Caller's component ID
+ *              Format              - Printf format field
+ *              ...                 - Optional printf arguments
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Print error message with prefix consisting of the module name,
+ *              line number, and component ID.
+ *
+ ******************************************************************************/
+
+void ACPI_INTERNAL_VAR_XFACE
+acpi_debug_print(u32 requested_debug_level,
+		 u32 line_number,
+		 const char *function_name,
+		 const char *module_name,
+		 u32 component_id, const char *format, ...)
+{
+	acpi_thread_id thread_id;
+	va_list args;
+
+	/*
+	 * Stay silent if the debug level or component ID is disabled
+	 */
+	if (!(requested_debug_level & acpi_dbg_level) ||
+	    !(component_id & acpi_dbg_layer)) {
+		return;
+	}
+
+	/*
+	 * Thread tracking and context switch notification
+	 */
+	thread_id = acpi_os_get_thread_id();
+	if (thread_id != acpi_gbl_prev_thread_id) {
+		if (ACPI_LV_THREADS & acpi_dbg_level) {
+			acpi_os_printf
+			    ("\n**** Context Switch from TID %u to TID %u ****\n\n",
+			     (u32)acpi_gbl_prev_thread_id, (u32)thread_id);
+		}
+
+		acpi_gbl_prev_thread_id = thread_id;
+	}
+
+	/*
+	 * Display the module name, current line number, thread ID (if requested),
+	 * current procedure nesting level, and the current procedure name
+	 */
+	acpi_os_printf("%8s-%04ld ", module_name, line_number);
+
+	if (ACPI_LV_THREADS & acpi_dbg_level) {
+		acpi_os_printf("[%u] ", (u32)thread_id);
+	}
+
+	acpi_os_printf("[%02ld] %-22.22s: ",
+		       acpi_gbl_nesting_level,
+		       acpi_ut_trim_function_name(function_name));
+
+	va_start(args, format);
+	acpi_os_vprintf(format, args);
+	va_end(args);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_debug_print)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_debug_print_raw
+ *
+ * PARAMETERS:  requested_debug_level - Requested debug print level
+ *              line_number         - Caller's line number
+ *              function_name       - Caller's procedure name
+ *              module_name         - Caller's module name
+ *              component_id        - Caller's component ID
+ *              Format              - Printf format field
+ *              ...                 - Optional printf arguments
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Print message with no headers.  Has same interface as
+ *              debug_print so that the same macros can be used.
+ *
+ ******************************************************************************/
+void ACPI_INTERNAL_VAR_XFACE
+acpi_debug_print_raw(u32 requested_debug_level,
+		     u32 line_number,
+		     const char *function_name,
+		     const char *module_name,
+		     u32 component_id, const char *format, ...)
+{
+	va_list args;
+
+	if (!(requested_debug_level & acpi_dbg_level) ||
+	    !(component_id & acpi_dbg_layer)) {
+		return;
+	}
+
+	va_start(args, format);
+	acpi_os_vprintf(format, args);
+	va_end(args);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_debug_print_raw)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_trace
+ *
+ * PARAMETERS:  line_number         - Caller's line number
+ *              function_name       - Caller's procedure name
+ *              module_name         - Caller's module name
+ *              component_id        - Caller's component ID
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Function entry trace.  Prints only if TRACE_FUNCTIONS bit is
+ *              set in debug_level
+ *
+ ******************************************************************************/
+void
+acpi_ut_trace(u32 line_number,
+	      const char *function_name,
+	      const char *module_name, u32 component_id)
+{
+
+	acpi_gbl_nesting_level++;
+	acpi_ut_track_stack_ptr();
+
+	acpi_debug_print(ACPI_LV_FUNCTIONS,
+			 line_number, function_name, module_name, component_id,
+			 "%s\n", acpi_gbl_fn_entry_str);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_ut_trace)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_trace_ptr
+ *
+ * PARAMETERS:  line_number         - Caller's line number
+ *              function_name       - Caller's procedure name
+ *              module_name         - Caller's module name
+ *              component_id        - Caller's component ID
+ *              Pointer             - Pointer to display
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Function entry trace.  Prints only if TRACE_FUNCTIONS bit is
+ *              set in debug_level
+ *
+ ******************************************************************************/
+void
+acpi_ut_trace_ptr(u32 line_number,
+		  const char *function_name,
+		  const char *module_name, u32 component_id, void *pointer)
+{
+	acpi_gbl_nesting_level++;
+	acpi_ut_track_stack_ptr();
+
+	acpi_debug_print(ACPI_LV_FUNCTIONS,
+			 line_number, function_name, module_name, component_id,
+			 "%s %p\n", acpi_gbl_fn_entry_str, pointer);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_trace_str
+ *
+ * PARAMETERS:  line_number         - Caller's line number
+ *              function_name       - Caller's procedure name
+ *              module_name         - Caller's module name
+ *              component_id        - Caller's component ID
+ *              String              - Additional string to display
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Function entry trace.  Prints only if TRACE_FUNCTIONS bit is
+ *              set in debug_level
+ *
+ ******************************************************************************/
+
+void
+acpi_ut_trace_str(u32 line_number,
+		  const char *function_name,
+		  const char *module_name, u32 component_id, char *string)
+{
+
+	acpi_gbl_nesting_level++;
+	acpi_ut_track_stack_ptr();
+
+	acpi_debug_print(ACPI_LV_FUNCTIONS,
+			 line_number, function_name, module_name, component_id,
+			 "%s %s\n", acpi_gbl_fn_entry_str, string);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_trace_u32
+ *
+ * PARAMETERS:  line_number         - Caller's line number
+ *              function_name       - Caller's procedure name
+ *              module_name         - Caller's module name
+ *              component_id        - Caller's component ID
+ *              Integer             - Integer to display
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Function entry trace.  Prints only if TRACE_FUNCTIONS bit is
+ *              set in debug_level
+ *
+ ******************************************************************************/
+
+void
+acpi_ut_trace_u32(u32 line_number,
+		  const char *function_name,
+		  const char *module_name, u32 component_id, u32 integer)
+{
+
+	acpi_gbl_nesting_level++;
+	acpi_ut_track_stack_ptr();
+
+	acpi_debug_print(ACPI_LV_FUNCTIONS,
+			 line_number, function_name, module_name, component_id,
+			 "%s %08X\n", acpi_gbl_fn_entry_str, integer);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_exit
+ *
+ * PARAMETERS:  line_number         - Caller's line number
+ *              function_name       - Caller's procedure name
+ *              module_name         - Caller's module name
+ *              component_id        - Caller's component ID
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Function exit trace.  Prints only if TRACE_FUNCTIONS bit is
+ *              set in debug_level
+ *
+ ******************************************************************************/
+
+void
+acpi_ut_exit(u32 line_number,
+	     const char *function_name,
+	     const char *module_name, u32 component_id)
+{
+
+	acpi_debug_print(ACPI_LV_FUNCTIONS,
+			 line_number, function_name, module_name, component_id,
+			 "%s\n", acpi_gbl_fn_exit_str);
+
+	acpi_gbl_nesting_level--;
+}
+
+ACPI_EXPORT_SYMBOL(acpi_ut_exit)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_status_exit
+ *
+ * PARAMETERS:  line_number         - Caller's line number
+ *              function_name       - Caller's procedure name
+ *              module_name         - Caller's module name
+ *              component_id        - Caller's component ID
+ *              Status              - Exit status code
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Function exit trace.  Prints only if TRACE_FUNCTIONS bit is
+ *              set in debug_level. Prints exit status also.
+ *
+ ******************************************************************************/
+void
+acpi_ut_status_exit(u32 line_number,
+		    const char *function_name,
+		    const char *module_name,
+		    u32 component_id, acpi_status status)
+{
+
+	if (ACPI_SUCCESS(status)) {
+		acpi_debug_print(ACPI_LV_FUNCTIONS,
+				 line_number, function_name, module_name,
+				 component_id, "%s %s\n", acpi_gbl_fn_exit_str,
+				 acpi_format_exception(status));
+	} else {
+		acpi_debug_print(ACPI_LV_FUNCTIONS,
+				 line_number, function_name, module_name,
+				 component_id, "%s ****Exception****: %s\n",
+				 acpi_gbl_fn_exit_str,
+				 acpi_format_exception(status));
+	}
+
+	acpi_gbl_nesting_level--;
+}
+
+ACPI_EXPORT_SYMBOL(acpi_ut_status_exit)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_value_exit
+ *
+ * PARAMETERS:  line_number         - Caller's line number
+ *              function_name       - Caller's procedure name
+ *              module_name         - Caller's module name
+ *              component_id        - Caller's component ID
+ *              Value               - Value to be printed with exit msg
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Function exit trace.  Prints only if TRACE_FUNCTIONS bit is
+ *              set in debug_level. Prints exit value also.
+ *
+ ******************************************************************************/
+void
+acpi_ut_value_exit(u32 line_number,
+		   const char *function_name,
+		   const char *module_name, u32 component_id, u64 value)
+{
+
+	acpi_debug_print(ACPI_LV_FUNCTIONS,
+			 line_number, function_name, module_name, component_id,
+			 "%s %8.8X%8.8X\n", acpi_gbl_fn_exit_str,
+			 ACPI_FORMAT_UINT64(value));
+
+	acpi_gbl_nesting_level--;
+}
+
+ACPI_EXPORT_SYMBOL(acpi_ut_value_exit)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_ptr_exit
+ *
+ * PARAMETERS:  line_number         - Caller's line number
+ *              function_name       - Caller's procedure name
+ *              module_name         - Caller's module name
+ *              component_id        - Caller's component ID
+ *              Ptr                 - Pointer to display
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Function exit trace.  Prints only if TRACE_FUNCTIONS bit is
+ *              set in debug_level. Prints exit value also.
+ *
+ ******************************************************************************/
+void
+acpi_ut_ptr_exit(u32 line_number,
+		 const char *function_name,
+		 const char *module_name, u32 component_id, u8 *ptr)
+{
+
+	acpi_debug_print(ACPI_LV_FUNCTIONS,
+			 line_number, function_name, module_name, component_id,
+			 "%s %p\n", acpi_gbl_fn_exit_str, ptr);
+
+	acpi_gbl_nesting_level--;
+}
+
+#endif
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_dump_buffer
+ *
+ * PARAMETERS:  Buffer              - Buffer to dump
+ *              Count               - Amount to dump, in bytes
+ *              Display             - BYTE, WORD, DWORD, or QWORD display
+ *              component_iD        - Caller's component ID
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Generic dump buffer in both hex and ascii.
+ *
+ ******************************************************************************/
+
+void acpi_ut_dump_buffer2(u8 *buffer, u32 count, u32 display)
+{
+	u32 i = 0;
+	u32 j;
+	u32 temp32;
+	u8 buf_char;
+
+	if (!buffer) {
+		acpi_os_printf("Null Buffer Pointer in DumpBuffer!\n");
+		return;
+	}
+
+	if ((count < 4) || (count & 0x01)) {
+		display = DB_BYTE_DISPLAY;
+	}
+
+	/* Nasty little dump buffer routine! */
+
+	while (i < count) {
+
+		/* Print current offset */
+
+		acpi_os_printf("%6.4X: ", i);
+
+		/* Print 16 hex chars */
+
+		for (j = 0; j < 16;) {
+			if (i + j >= count) {
+
+				/* Dump fill spaces */
+
+				acpi_os_printf("%*s", ((display * 2) + 1), " ");
+				j += display;
+				continue;
+			}
+
+			switch (display) {
+			case DB_BYTE_DISPLAY:
+			default:	/* Default is BYTE display */
+
+				acpi_os_printf("%02X ",
+					       buffer[(acpi_size) i + j]);
+				break;
+
+			case DB_WORD_DISPLAY:
+
+				ACPI_MOVE_16_TO_32(&temp32,
+						   &buffer[(acpi_size) i + j]);
+				acpi_os_printf("%04X ", temp32);
+				break;
+
+			case DB_DWORD_DISPLAY:
+
+				ACPI_MOVE_32_TO_32(&temp32,
+						   &buffer[(acpi_size) i + j]);
+				acpi_os_printf("%08X ", temp32);
+				break;
+
+			case DB_QWORD_DISPLAY:
+
+				ACPI_MOVE_32_TO_32(&temp32,
+						   &buffer[(acpi_size) i + j]);
+				acpi_os_printf("%08X", temp32);
+
+				ACPI_MOVE_32_TO_32(&temp32,
+						   &buffer[(acpi_size) i + j +
+							   4]);
+				acpi_os_printf("%08X ", temp32);
+				break;
+			}
+
+			j += display;
+		}
+
+		/*
+		 * Print the ASCII equivalent characters but watch out for the bad
+		 * unprintable ones (printable chars are 0x20 through 0x7E)
+		 */
+		acpi_os_printf(" ");
+		for (j = 0; j < 16; j++) {
+			if (i + j >= count) {
+				acpi_os_printf("\n");
+				return;
+			}
+
+			buf_char = buffer[(acpi_size) i + j];
+			if (ACPI_IS_PRINT(buf_char)) {
+				acpi_os_printf("%c", buf_char);
+			} else {
+				acpi_os_printf(".");
+			}
+		}
+
+		/* Done with that line. */
+
+		acpi_os_printf("\n");
+		i += 16;
+	}
+
+	return;
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_dump_buffer
+ *
+ * PARAMETERS:  Buffer              - Buffer to dump
+ *              Count               - Amount to dump, in bytes
+ *              Display             - BYTE, WORD, DWORD, or QWORD display
+ *              component_iD        - Caller's component ID
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Generic dump buffer in both hex and ascii.
+ *
+ ******************************************************************************/
+
+void acpi_ut_dump_buffer(u8 *buffer, u32 count, u32 display, u32 component_id)
+{
+
+	/* Only dump the buffer if tracing is enabled */
+
+	if (!((ACPI_LV_TABLES & acpi_dbg_level) &&
+	      (component_id & acpi_dbg_layer))) {
+		return;
+	}
+
+	acpi_ut_dump_buffer2(buffer, count, display);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utdecode.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utdecode.c
new file mode 100644
index 00000000..3704fec2
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utdecode.c
@@ -0,0 +1,551 @@
+/******************************************************************************
+ *
+ * Module Name: utdecode - Utility decoding routines (value-to-string)
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acnamesp.h"
+
+#define _COMPONENT          ACPI_UTILITIES
+ACPI_MODULE_NAME("utdecode")
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_format_exception
+ *
+ * PARAMETERS:  Status       - The acpi_status code to be formatted
+ *
+ * RETURN:      A string containing the exception text. A valid pointer is
+ *              always returned.
+ *
+ * DESCRIPTION: This function translates an ACPI exception into an ASCII string
+ *              It is here instead of utxface.c so it is always present.
+ *
+ ******************************************************************************/
+const char *acpi_format_exception(acpi_status status)
+{
+	const char *exception = NULL;
+
+	ACPI_FUNCTION_ENTRY();
+
+	exception = acpi_ut_validate_exception(status);
+	if (!exception) {
+
+		/* Exception code was not recognized */
+
+		ACPI_ERROR((AE_INFO,
+			    "Unknown exception code: 0x%8.8X", status));
+
+		exception = "UNKNOWN_STATUS_CODE";
+	}
+
+	return (ACPI_CAST_PTR(const char, exception));
+}
+
+ACPI_EXPORT_SYMBOL(acpi_format_exception)
+
+/*
+ * Properties of the ACPI Object Types, both internal and external.
+ * The table is indexed by values of acpi_object_type
+ */
+const u8 acpi_gbl_ns_properties[ACPI_NUM_NS_TYPES] = {
+	ACPI_NS_NORMAL,		/* 00 Any              */
+	ACPI_NS_NORMAL,		/* 01 Number           */
+	ACPI_NS_NORMAL,		/* 02 String           */
+	ACPI_NS_NORMAL,		/* 03 Buffer           */
+	ACPI_NS_NORMAL,		/* 04 Package          */
+	ACPI_NS_NORMAL,		/* 05 field_unit       */
+	ACPI_NS_NEWSCOPE,	/* 06 Device           */
+	ACPI_NS_NORMAL,		/* 07 Event            */
+	ACPI_NS_NEWSCOPE,	/* 08 Method           */
+	ACPI_NS_NORMAL,		/* 09 Mutex            */
+	ACPI_NS_NORMAL,		/* 10 Region           */
+	ACPI_NS_NEWSCOPE,	/* 11 Power            */
+	ACPI_NS_NEWSCOPE,	/* 12 Processor        */
+	ACPI_NS_NEWSCOPE,	/* 13 Thermal          */
+	ACPI_NS_NORMAL,		/* 14 buffer_field     */
+	ACPI_NS_NORMAL,		/* 15 ddb_handle       */
+	ACPI_NS_NORMAL,		/* 16 Debug Object     */
+	ACPI_NS_NORMAL,		/* 17 def_field        */
+	ACPI_NS_NORMAL,		/* 18 bank_field       */
+	ACPI_NS_NORMAL,		/* 19 index_field      */
+	ACPI_NS_NORMAL,		/* 20 Reference        */
+	ACPI_NS_NORMAL,		/* 21 Alias            */
+	ACPI_NS_NORMAL,		/* 22 method_alias     */
+	ACPI_NS_NORMAL,		/* 23 Notify           */
+	ACPI_NS_NORMAL,		/* 24 Address Handler  */
+	ACPI_NS_NEWSCOPE | ACPI_NS_LOCAL,	/* 25 Resource Desc    */
+	ACPI_NS_NEWSCOPE | ACPI_NS_LOCAL,	/* 26 Resource Field   */
+	ACPI_NS_NEWSCOPE,	/* 27 Scope            */
+	ACPI_NS_NORMAL,		/* 28 Extra            */
+	ACPI_NS_NORMAL,		/* 29 Data             */
+	ACPI_NS_NORMAL		/* 30 Invalid          */
+};
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_hex_to_ascii_char
+ *
+ * PARAMETERS:  Integer             - Contains the hex digit
+ *              Position            - bit position of the digit within the
+ *                                    integer (multiple of 4)
+ *
+ * RETURN:      The converted Ascii character
+ *
+ * DESCRIPTION: Convert a hex digit to an Ascii character
+ *
+ ******************************************************************************/
+
+/* Hex to ASCII conversion table */
+
+static const char acpi_gbl_hex_to_ascii[] = {
+	'0', '1', '2', '3', '4', '5', '6', '7',
+	'8', '9', 'A', 'B', 'C', 'D', 'E', 'F'
+};
+
+char acpi_ut_hex_to_ascii_char(u64 integer, u32 position)
+{
+
+	return (acpi_gbl_hex_to_ascii[(integer >> position) & 0xF]);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_get_region_name
+ *
+ * PARAMETERS:  Space ID            - ID for the region
+ *
+ * RETURN:      Decoded region space_id name
+ *
+ * DESCRIPTION: Translate a Space ID into a name string (Debug only)
+ *
+ ******************************************************************************/
+
+/* Region type decoding */
+
+const char *acpi_gbl_region_types[ACPI_NUM_PREDEFINED_REGIONS] = {
+	"SystemMemory",
+	"SystemIO",
+	"PCI_Config",
+	"EmbeddedControl",
+	"SMBus",
+	"SystemCMOS",
+	"PCIBARTarget",
+	"IPMI",
+	"GeneralPurposeIo",
+	"GenericSerialBus"
+};
+
+char *acpi_ut_get_region_name(u8 space_id)
+{
+
+	if (space_id >= ACPI_USER_REGION_BEGIN) {
+		return ("UserDefinedRegion");
+	} else if (space_id == ACPI_ADR_SPACE_DATA_TABLE) {
+		return ("DataTable");
+	} else if (space_id == ACPI_ADR_SPACE_FIXED_HARDWARE) {
+		return ("FunctionalFixedHW");
+	} else if (space_id >= ACPI_NUM_PREDEFINED_REGIONS) {
+		return ("InvalidSpaceId");
+	}
+
+	return (ACPI_CAST_PTR(char, acpi_gbl_region_types[space_id]));
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_get_event_name
+ *
+ * PARAMETERS:  event_id            - Fixed event ID
+ *
+ * RETURN:      Decoded event ID name
+ *
+ * DESCRIPTION: Translate a Event ID into a name string (Debug only)
+ *
+ ******************************************************************************/
+
+/* Event type decoding */
+
+static const char *acpi_gbl_event_types[ACPI_NUM_FIXED_EVENTS] = {
+	"PM_Timer",
+	"GlobalLock",
+	"PowerButton",
+	"SleepButton",
+	"RealTimeClock",
+};
+
+char *acpi_ut_get_event_name(u32 event_id)
+{
+
+	if (event_id > ACPI_EVENT_MAX) {
+		return ("InvalidEventID");
+	}
+
+	return (ACPI_CAST_PTR(char, acpi_gbl_event_types[event_id]));
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_get_type_name
+ *
+ * PARAMETERS:  Type                - An ACPI object type
+ *
+ * RETURN:      Decoded ACPI object type name
+ *
+ * DESCRIPTION: Translate a Type ID into a name string (Debug only)
+ *
+ ******************************************************************************/
+
+/*
+ * Elements of acpi_gbl_ns_type_names below must match
+ * one-to-one with values of acpi_object_type
+ *
+ * The type ACPI_TYPE_ANY (Untyped) is used as a "don't care" when searching;
+ * when stored in a table it really means that we have thus far seen no
+ * evidence to indicate what type is actually going to be stored for this entry.
+ */
+static const char acpi_gbl_bad_type[] = "UNDEFINED";
+
+/* Printable names of the ACPI object types */
+
+static const char *acpi_gbl_ns_type_names[] = {
+	/* 00 */ "Untyped",
+	/* 01 */ "Integer",
+	/* 02 */ "String",
+	/* 03 */ "Buffer",
+	/* 04 */ "Package",
+	/* 05 */ "FieldUnit",
+	/* 06 */ "Device",
+	/* 07 */ "Event",
+	/* 08 */ "Method",
+	/* 09 */ "Mutex",
+	/* 10 */ "Region",
+	/* 11 */ "Power",
+	/* 12 */ "Processor",
+	/* 13 */ "Thermal",
+	/* 14 */ "BufferField",
+	/* 15 */ "DdbHandle",
+	/* 16 */ "DebugObject",
+	/* 17 */ "RegionField",
+	/* 18 */ "BankField",
+	/* 19 */ "IndexField",
+	/* 20 */ "Reference",
+	/* 21 */ "Alias",
+	/* 22 */ "MethodAlias",
+	/* 23 */ "Notify",
+	/* 24 */ "AddrHandler",
+	/* 25 */ "ResourceDesc",
+	/* 26 */ "ResourceFld",
+	/* 27 */ "Scope",
+	/* 28 */ "Extra",
+	/* 29 */ "Data",
+	/* 30 */ "Invalid"
+};
+
+char *acpi_ut_get_type_name(acpi_object_type type)
+{
+
+	if (type > ACPI_TYPE_INVALID) {
+		return (ACPI_CAST_PTR(char, acpi_gbl_bad_type));
+	}
+
+	return (ACPI_CAST_PTR(char, acpi_gbl_ns_type_names[type]));
+}
+
+char *acpi_ut_get_object_type_name(union acpi_operand_object *obj_desc)
+{
+
+	if (!obj_desc) {
+		return ("[NULL Object Descriptor]");
+	}
+
+	return (acpi_ut_get_type_name(obj_desc->common.type));
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_get_node_name
+ *
+ * PARAMETERS:  Object               - A namespace node
+ *
+ * RETURN:      ASCII name of the node
+ *
+ * DESCRIPTION: Validate the node and return the node's ACPI name.
+ *
+ ******************************************************************************/
+
+char *acpi_ut_get_node_name(void *object)
+{
+	struct acpi_namespace_node *node = (struct acpi_namespace_node *)object;
+
+	/* Must return a string of exactly 4 characters == ACPI_NAME_SIZE */
+
+	if (!object) {
+		return ("NULL");
+	}
+
+	/* Check for Root node */
+
+	if ((object == ACPI_ROOT_OBJECT) || (object == acpi_gbl_root_node)) {
+		return ("\"\\\" ");
+	}
+
+	/* Descriptor must be a namespace node */
+
+	if (ACPI_GET_DESCRIPTOR_TYPE(node) != ACPI_DESC_TYPE_NAMED) {
+		return ("####");
+	}
+
+	/*
+	 * Ensure name is valid. The name was validated/repaired when the node
+	 * was created, but make sure it has not been corrupted.
+	 */
+	acpi_ut_repair_name(node->name.ascii);
+
+	/* Return the name */
+
+	return (node->name.ascii);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_get_descriptor_name
+ *
+ * PARAMETERS:  Object               - An ACPI object
+ *
+ * RETURN:      Decoded name of the descriptor type
+ *
+ * DESCRIPTION: Validate object and return the descriptor type
+ *
+ ******************************************************************************/
+
+/* Printable names of object descriptor types */
+
+static const char *acpi_gbl_desc_type_names[] = {
+	/* 00 */ "Not a Descriptor",
+	/* 01 */ "Cached",
+	/* 02 */ "State-Generic",
+	/* 03 */ "State-Update",
+	/* 04 */ "State-Package",
+	/* 05 */ "State-Control",
+	/* 06 */ "State-RootParseScope",
+	/* 07 */ "State-ParseScope",
+	/* 08 */ "State-WalkScope",
+	/* 09 */ "State-Result",
+	/* 10 */ "State-Notify",
+	/* 11 */ "State-Thread",
+	/* 12 */ "Walk",
+	/* 13 */ "Parser",
+	/* 14 */ "Operand",
+	/* 15 */ "Node"
+};
+
+char *acpi_ut_get_descriptor_name(void *object)
+{
+
+	if (!object) {
+		return ("NULL OBJECT");
+	}
+
+	if (ACPI_GET_DESCRIPTOR_TYPE(object) > ACPI_DESC_TYPE_MAX) {
+		return ("Not a Descriptor");
+	}
+
+	return (ACPI_CAST_PTR(char,
+			      acpi_gbl_desc_type_names[ACPI_GET_DESCRIPTOR_TYPE
+						       (object)]));
+
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_get_reference_name
+ *
+ * PARAMETERS:  Object               - An ACPI reference object
+ *
+ * RETURN:      Decoded name of the type of reference
+ *
+ * DESCRIPTION: Decode a reference object sub-type to a string.
+ *
+ ******************************************************************************/
+
+/* Printable names of reference object sub-types */
+
+static const char *acpi_gbl_ref_class_names[] = {
+	/* 00 */ "Local",
+	/* 01 */ "Argument",
+	/* 02 */ "RefOf",
+	/* 03 */ "Index",
+	/* 04 */ "DdbHandle",
+	/* 05 */ "Named Object",
+	/* 06 */ "Debug"
+};
+
+const char *acpi_ut_get_reference_name(union acpi_operand_object *object)
+{
+
+	if (!object) {
+		return ("NULL Object");
+	}
+
+	if (ACPI_GET_DESCRIPTOR_TYPE(object) != ACPI_DESC_TYPE_OPERAND) {
+		return ("Not an Operand object");
+	}
+
+	if (object->common.type != ACPI_TYPE_LOCAL_REFERENCE) {
+		return ("Not a Reference object");
+	}
+
+	if (object->reference.class > ACPI_REFCLASS_MAX) {
+		return ("Unknown Reference class");
+	}
+
+	return (acpi_gbl_ref_class_names[object->reference.class]);
+}
+
+#if defined(ACPI_DEBUG_OUTPUT) || defined(ACPI_DEBUGGER)
+/*
+ * Strings and procedures used for debug only
+ */
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_get_mutex_name
+ *
+ * PARAMETERS:  mutex_id        - The predefined ID for this mutex.
+ *
+ * RETURN:      Decoded name of the internal mutex
+ *
+ * DESCRIPTION: Translate a mutex ID into a name string (Debug only)
+ *
+ ******************************************************************************/
+
+/* Names for internal mutex objects, used for debug output */
+
+static char *acpi_gbl_mutex_names[ACPI_NUM_MUTEX] = {
+	"ACPI_MTX_Interpreter",
+	"ACPI_MTX_Namespace",
+	"ACPI_MTX_Tables",
+	"ACPI_MTX_Events",
+	"ACPI_MTX_Caches",
+	"ACPI_MTX_Memory",
+	"ACPI_MTX_CommandComplete",
+	"ACPI_MTX_CommandReady"
+};
+
+char *acpi_ut_get_mutex_name(u32 mutex_id)
+{
+
+	if (mutex_id > ACPI_MAX_MUTEX) {
+		return ("Invalid Mutex ID");
+	}
+
+	return (acpi_gbl_mutex_names[mutex_id]);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_get_notify_name
+ *
+ * PARAMETERS:  notify_value    - Value from the Notify() request
+ *
+ * RETURN:      Decoded name for the notify value
+ *
+ * DESCRIPTION: Translate a Notify Value to a notify namestring.
+ *
+ ******************************************************************************/
+
+/* Names for Notify() values, used for debug output */
+
+static const char *acpi_gbl_notify_value_names[] = {
+	"Bus Check",
+	"Device Check",
+	"Device Wake",
+	"Eject Request",
+	"Device Check Light",
+	"Frequency Mismatch",
+	"Bus Mode Mismatch",
+	"Power Fault",
+	"Capabilities Check",
+	"Device PLD Check",
+	"Reserved",
+	"System Locality Update"
+};
+
+const char *acpi_ut_get_notify_name(u32 notify_value)
+{
+
+	if (notify_value <= ACPI_NOTIFY_MAX) {
+		return (acpi_gbl_notify_value_names[notify_value]);
+	} else if (notify_value <= ACPI_MAX_SYS_NOTIFY) {
+		return ("Reserved");
+	} else {		/* Greater or equal to 0x80 */
+
+		return ("**Device Specific**");
+	}
+}
+#endif
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_valid_object_type
+ *
+ * PARAMETERS:  Type            - Object type to be validated
+ *
+ * RETURN:      TRUE if valid object type, FALSE otherwise
+ *
+ * DESCRIPTION: Validate an object type
+ *
+ ******************************************************************************/
+
+u8 acpi_ut_valid_object_type(acpi_object_type type)
+{
+
+	if (type > ACPI_TYPE_LOCAL_MAX) {
+
+		/* Note: Assumes all TYPEs are contiguous (external/local) */
+
+		return (FALSE);
+	}
+
+	return (TRUE);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utdelete.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utdelete.c
new file mode 100644
index 00000000..2a6c3e18
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utdelete.c
@@ -0,0 +1,707 @@
+/*******************************************************************************
+ *
+ * Module Name: utdelete - object deletion and reference count utilities
+ *
+ ******************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acinterp.h"
+#include "acnamesp.h"
+#include "acevents.h"
+
+#define _COMPONENT          ACPI_UTILITIES
+ACPI_MODULE_NAME("utdelete")
+
+/* Local prototypes */
+static void acpi_ut_delete_internal_obj(union acpi_operand_object *object);
+
+static void
+acpi_ut_update_ref_count(union acpi_operand_object *object, u32 action);
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_delete_internal_obj
+ *
+ * PARAMETERS:  Object         - Object to be deleted
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Low level object deletion, after reference counts have been
+ *              updated (All reference counts, including sub-objects!)
+ *
+ ******************************************************************************/
+
+static void acpi_ut_delete_internal_obj(union acpi_operand_object *object)
+{
+	void *obj_pointer = NULL;
+	union acpi_operand_object *handler_desc;
+	union acpi_operand_object *second_desc;
+	union acpi_operand_object *next_desc;
+	union acpi_operand_object **last_obj_ptr;
+
+	ACPI_FUNCTION_TRACE_PTR(ut_delete_internal_obj, object);
+
+	if (!object) {
+		return_VOID;
+	}
+
+	/*
+	 * Must delete or free any pointers within the object that are not
+	 * actual ACPI objects (for example, a raw buffer pointer).
+	 */
+	switch (object->common.type) {
+	case ACPI_TYPE_STRING:
+
+		ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,
+				  "**** String %p, ptr %p\n", object,
+				  object->string.pointer));
+
+		/* Free the actual string buffer */
+
+		if (!(object->common.flags & AOPOBJ_STATIC_POINTER)) {
+
+			/* But only if it is NOT a pointer into an ACPI table */
+
+			obj_pointer = object->string.pointer;
+		}
+		break;
+
+	case ACPI_TYPE_BUFFER:
+
+		ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,
+				  "**** Buffer %p, ptr %p\n", object,
+				  object->buffer.pointer));
+
+		/* Free the actual buffer */
+
+		if (!(object->common.flags & AOPOBJ_STATIC_POINTER)) {
+
+			/* But only if it is NOT a pointer into an ACPI table */
+
+			obj_pointer = object->buffer.pointer;
+		}
+		break;
+
+	case ACPI_TYPE_PACKAGE:
+
+		ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,
+				  " **** Package of count %X\n",
+				  object->package.count));
+
+		/*
+		 * Elements of the package are not handled here, they are deleted
+		 * separately
+		 */
+
+		/* Free the (variable length) element pointer array */
+
+		obj_pointer = object->package.elements;
+		break;
+
+		/*
+		 * These objects have a possible list of notify handlers.
+		 * Device object also may have a GPE block.
+		 */
+	case ACPI_TYPE_DEVICE:
+
+		if (object->device.gpe_block) {
+			(void)acpi_ev_delete_gpe_block(object->device.
+						       gpe_block);
+		}
+
+		/*lint -fallthrough */
+
+	case ACPI_TYPE_PROCESSOR:
+	case ACPI_TYPE_THERMAL:
+
+		/* Walk the notify handler list for this object */
+
+		handler_desc = object->common_notify.handler;
+		while (handler_desc) {
+			next_desc = handler_desc->address_space.next;
+			acpi_ut_remove_reference(handler_desc);
+			handler_desc = next_desc;
+		}
+		break;
+
+	case ACPI_TYPE_MUTEX:
+
+		ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,
+				  "***** Mutex %p, OS Mutex %p\n",
+				  object, object->mutex.os_mutex));
+
+		if (object == acpi_gbl_global_lock_mutex) {
+
+			/* Global Lock has extra semaphore */
+
+			(void)
+			    acpi_os_delete_semaphore
+			    (acpi_gbl_global_lock_semaphore);
+			acpi_gbl_global_lock_semaphore = NULL;
+
+			acpi_os_delete_mutex(object->mutex.os_mutex);
+			acpi_gbl_global_lock_mutex = NULL;
+		} else {
+			acpi_ex_unlink_mutex(object);
+			acpi_os_delete_mutex(object->mutex.os_mutex);
+		}
+		break;
+
+	case ACPI_TYPE_EVENT:
+
+		ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,
+				  "***** Event %p, OS Semaphore %p\n",
+				  object, object->event.os_semaphore));
+
+		(void)acpi_os_delete_semaphore(object->event.os_semaphore);
+		object->event.os_semaphore = NULL;
+		break;
+
+	case ACPI_TYPE_METHOD:
+
+		ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,
+				  "***** Method %p\n", object));
+
+		/* Delete the method mutex if it exists */
+
+		if (object->method.mutex) {
+			acpi_os_delete_mutex(object->method.mutex->mutex.
+					     os_mutex);
+			acpi_ut_delete_object_desc(object->method.mutex);
+			object->method.mutex = NULL;
+		}
+		break;
+
+	case ACPI_TYPE_REGION:
+
+		ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,
+				  "***** Region %p\n", object));
+
+		/*
+		 * Update address_range list. However, only permanent regions
+		 * are installed in this list. (Not created within a method)
+		 */
+		if (!(object->region.node->flags & ANOBJ_TEMPORARY)) {
+			acpi_ut_remove_address_range(object->region.space_id,
+						     object->region.node);
+		}
+
+		second_desc = acpi_ns_get_secondary_object(object);
+		if (second_desc) {
+			/*
+			 * Free the region_context if and only if the handler is one of the
+			 * default handlers -- and therefore, we created the context object
+			 * locally, it was not created by an external caller.
+			 */
+			handler_desc = object->region.handler;
+			if (handler_desc) {
+				next_desc =
+				    handler_desc->address_space.region_list;
+				last_obj_ptr =
+				    &handler_desc->address_space.region_list;
+
+				/* Remove the region object from the handler's list */
+
+				while (next_desc) {
+					if (next_desc == object) {
+						*last_obj_ptr =
+						    next_desc->region.next;
+						break;
+					}
+
+					/* Walk the linked list of handler */
+
+					last_obj_ptr = &next_desc->region.next;
+					next_desc = next_desc->region.next;
+				}
+
+				if (handler_desc->address_space.handler_flags &
+				    ACPI_ADDR_HANDLER_DEFAULT_INSTALLED) {
+
+					/* Deactivate region and free region context */
+
+					if (handler_desc->address_space.setup) {
+						(void)handler_desc->
+						    address_space.setup(object,
+									ACPI_REGION_DEACTIVATE,
+									handler_desc->
+									address_space.
+									context,
+									&second_desc->
+									extra.
+									region_context);
+					}
+				}
+
+				acpi_ut_remove_reference(handler_desc);
+			}
+
+			/* Now we can free the Extra object */
+
+			acpi_ut_delete_object_desc(second_desc);
+		}
+		break;
+
+	case ACPI_TYPE_BUFFER_FIELD:
+
+		ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,
+				  "***** Buffer Field %p\n", object));
+
+		second_desc = acpi_ns_get_secondary_object(object);
+		if (second_desc) {
+			acpi_ut_delete_object_desc(second_desc);
+		}
+		break;
+
+	case ACPI_TYPE_LOCAL_BANK_FIELD:
+
+		ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,
+				  "***** Bank Field %p\n", object));
+
+		second_desc = acpi_ns_get_secondary_object(object);
+		if (second_desc) {
+			acpi_ut_delete_object_desc(second_desc);
+		}
+		break;
+
+	default:
+		break;
+	}
+
+	/* Free any allocated memory (pointer within the object) found above */
+
+	if (obj_pointer) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,
+				  "Deleting Object Subptr %p\n", obj_pointer));
+		ACPI_FREE(obj_pointer);
+	}
+
+	/* Now the object can be safely deleted */
+
+	ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS, "Deleting Object %p [%s]\n",
+			  object, acpi_ut_get_object_type_name(object)));
+
+	acpi_ut_delete_object_desc(object);
+	return_VOID;
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_delete_internal_object_list
+ *
+ * PARAMETERS:  obj_list        - Pointer to the list to be deleted
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: This function deletes an internal object list, including both
+ *              simple objects and package objects
+ *
+ ******************************************************************************/
+
+void acpi_ut_delete_internal_object_list(union acpi_operand_object **obj_list)
+{
+	union acpi_operand_object **internal_obj;
+
+	ACPI_FUNCTION_TRACE(ut_delete_internal_object_list);
+
+	/* Walk the null-terminated internal list */
+
+	for (internal_obj = obj_list; *internal_obj; internal_obj++) {
+		acpi_ut_remove_reference(*internal_obj);
+	}
+
+	/* Free the combined parameter pointer list and object array */
+
+	ACPI_FREE(obj_list);
+	return_VOID;
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_update_ref_count
+ *
+ * PARAMETERS:  Object          - Object whose ref count is to be updated
+ *              Action          - What to do
+ *
+ * RETURN:      New ref count
+ *
+ * DESCRIPTION: Modify the ref count and return it.
+ *
+ ******************************************************************************/
+
+static void
+acpi_ut_update_ref_count(union acpi_operand_object *object, u32 action)
+{
+	u16 count;
+	u16 new_count;
+
+	ACPI_FUNCTION_NAME(ut_update_ref_count);
+
+	if (!object) {
+		return;
+	}
+
+	count = object->common.reference_count;
+	new_count = count;
+
+	/*
+	 * Perform the reference count action (increment, decrement, force delete)
+	 */
+	switch (action) {
+	case REF_INCREMENT:
+
+		new_count++;
+		object->common.reference_count = new_count;
+
+		ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,
+				  "Obj %p Refs=%X, [Incremented]\n",
+				  object, new_count));
+		break;
+
+	case REF_DECREMENT:
+
+		if (count < 1) {
+			ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,
+					  "Obj %p Refs=%X, can't decrement! (Set to 0)\n",
+					  object, new_count));
+
+			new_count = 0;
+		} else {
+			new_count--;
+
+			ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,
+					  "Obj %p Refs=%X, [Decremented]\n",
+					  object, new_count));
+		}
+
+		if (object->common.type == ACPI_TYPE_METHOD) {
+			ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,
+					  "Method Obj %p Refs=%X, [Decremented]\n",
+					  object, new_count));
+		}
+
+		object->common.reference_count = new_count;
+		if (new_count == 0) {
+			acpi_ut_delete_internal_obj(object);
+		}
+		break;
+
+	case REF_FORCE_DELETE:
+
+		ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,
+				  "Obj %p Refs=%X, Force delete! (Set to 0)\n",
+				  object, count));
+
+		new_count = 0;
+		object->common.reference_count = new_count;
+		acpi_ut_delete_internal_obj(object);
+		break;
+
+	default:
+
+		ACPI_ERROR((AE_INFO, "Unknown action (0x%X)", action));
+		break;
+	}
+
+	/*
+	 * Sanity check the reference count, for debug purposes only.
+	 * (A deleted object will have a huge reference count)
+	 */
+	if (count > ACPI_MAX_REFERENCE_COUNT) {
+		ACPI_WARNING((AE_INFO,
+			      "Large Reference Count (0x%X) in object %p",
+			      count, object));
+	}
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_update_object_reference
+ *
+ * PARAMETERS:  Object              - Increment ref count for this object
+ *                                    and all sub-objects
+ *              Action              - Either REF_INCREMENT or REF_DECREMENT or
+ *                                    REF_FORCE_DELETE
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Increment the object reference count
+ *
+ * Object references are incremented when:
+ * 1) An object is attached to a Node (namespace object)
+ * 2) An object is copied (all subobjects must be incremented)
+ *
+ * Object references are decremented when:
+ * 1) An object is detached from an Node
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ut_update_object_reference(union acpi_operand_object *object, u16 action)
+{
+	acpi_status status = AE_OK;
+	union acpi_generic_state *state_list = NULL;
+	union acpi_operand_object *next_object = NULL;
+	union acpi_generic_state *state;
+	u32 i;
+
+	ACPI_FUNCTION_TRACE_PTR(ut_update_object_reference, object);
+
+	while (object) {
+
+		/* Make sure that this isn't a namespace handle */
+
+		if (ACPI_GET_DESCRIPTOR_TYPE(object) == ACPI_DESC_TYPE_NAMED) {
+			ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,
+					  "Object %p is NS handle\n", object));
+			return_ACPI_STATUS(AE_OK);
+		}
+
+		/*
+		 * All sub-objects must have their reference count incremented also.
+		 * Different object types have different subobjects.
+		 */
+		switch (object->common.type) {
+		case ACPI_TYPE_DEVICE:
+		case ACPI_TYPE_PROCESSOR:
+		case ACPI_TYPE_POWER:
+		case ACPI_TYPE_THERMAL:
+
+			/* Update the notify objects for these types (if present) */
+
+			acpi_ut_update_ref_count(object->common_notify.
+						 system_notify, action);
+			acpi_ut_update_ref_count(object->common_notify.
+						 device_notify, action);
+			break;
+
+		case ACPI_TYPE_PACKAGE:
+			/*
+			 * We must update all the sub-objects of the package,
+			 * each of whom may have their own sub-objects.
+			 */
+			for (i = 0; i < object->package.count; i++) {
+				/*
+				 * Push each element onto the stack for later processing.
+				 * Note: There can be null elements within the package,
+				 * these are simply ignored
+				 */
+				status =
+				    acpi_ut_create_update_state_and_push
+				    (object->package.elements[i], action,
+				     &state_list);
+				if (ACPI_FAILURE(status)) {
+					goto error_exit;
+				}
+			}
+			break;
+
+		case ACPI_TYPE_BUFFER_FIELD:
+
+			next_object = object->buffer_field.buffer_obj;
+			break;
+
+		case ACPI_TYPE_LOCAL_REGION_FIELD:
+
+			next_object = object->field.region_obj;
+			break;
+
+		case ACPI_TYPE_LOCAL_BANK_FIELD:
+
+			next_object = object->bank_field.bank_obj;
+			status =
+			    acpi_ut_create_update_state_and_push(object->
+								 bank_field.
+								 region_obj,
+								 action,
+								 &state_list);
+			if (ACPI_FAILURE(status)) {
+				goto error_exit;
+			}
+			break;
+
+		case ACPI_TYPE_LOCAL_INDEX_FIELD:
+
+			next_object = object->index_field.index_obj;
+			status =
+			    acpi_ut_create_update_state_and_push(object->
+								 index_field.
+								 data_obj,
+								 action,
+								 &state_list);
+			if (ACPI_FAILURE(status)) {
+				goto error_exit;
+			}
+			break;
+
+		case ACPI_TYPE_LOCAL_REFERENCE:
+			/*
+			 * The target of an Index (a package, string, or buffer) or a named
+			 * reference must track changes to the ref count of the index or
+			 * target object.
+			 */
+			if ((object->reference.class == ACPI_REFCLASS_INDEX) ||
+			    (object->reference.class == ACPI_REFCLASS_NAME)) {
+				next_object = object->reference.object;
+			}
+			break;
+
+		case ACPI_TYPE_REGION:
+		default:
+			break;	/* No subobjects for all other types */
+		}
+
+		/*
+		 * Now we can update the count in the main object. This can only
+		 * happen after we update the sub-objects in case this causes the
+		 * main object to be deleted.
+		 */
+		acpi_ut_update_ref_count(object, action);
+		object = NULL;
+
+		/* Move on to the next object to be updated */
+
+		if (next_object) {
+			object = next_object;
+			next_object = NULL;
+		} else if (state_list) {
+			state = acpi_ut_pop_generic_state(&state_list);
+			object = state->update.object;
+			acpi_ut_delete_generic_state(state);
+		}
+	}
+
+	return_ACPI_STATUS(AE_OK);
+
+      error_exit:
+
+	ACPI_EXCEPTION((AE_INFO, status,
+			"Could not update object reference count"));
+
+	/* Free any stacked Update State objects */
+
+	while (state_list) {
+		state = acpi_ut_pop_generic_state(&state_list);
+		acpi_ut_delete_generic_state(state);
+	}
+
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_add_reference
+ *
+ * PARAMETERS:  Object          - Object whose reference count is to be
+ *                                incremented
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Add one reference to an ACPI object
+ *
+ ******************************************************************************/
+
+void acpi_ut_add_reference(union acpi_operand_object *object)
+{
+
+	ACPI_FUNCTION_TRACE_PTR(ut_add_reference, object);
+
+	/* Ensure that we have a valid object */
+
+	if (!acpi_ut_valid_internal_object(object)) {
+		return_VOID;
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,
+			  "Obj %p Current Refs=%X [To Be Incremented]\n",
+			  object, object->common.reference_count));
+
+	/* Increment the reference count */
+
+	(void)acpi_ut_update_object_reference(object, REF_INCREMENT);
+	return_VOID;
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_remove_reference
+ *
+ * PARAMETERS:  Object         - Object whose ref count will be decremented
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Decrement the reference count of an ACPI internal object
+ *
+ ******************************************************************************/
+
+void acpi_ut_remove_reference(union acpi_operand_object *object)
+{
+
+	ACPI_FUNCTION_TRACE_PTR(ut_remove_reference, object);
+
+	/*
+	 * Allow a NULL pointer to be passed in, just ignore it. This saves
+	 * each caller from having to check. Also, ignore NS nodes.
+	 *
+	 */
+	if (!object ||
+	    (ACPI_GET_DESCRIPTOR_TYPE(object) == ACPI_DESC_TYPE_NAMED)) {
+		return_VOID;
+	}
+
+	/* Ensure that we have a valid object */
+
+	if (!acpi_ut_valid_internal_object(object)) {
+		return_VOID;
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,
+			  "Obj %p Current Refs=%X [To Be Decremented]\n",
+			  object, object->common.reference_count));
+
+	/*
+	 * Decrement the reference count, and only actually delete the object
+	 * if the reference count becomes 0. (Must also decrement the ref count
+	 * of all subobjects!)
+	 */
+	(void)acpi_ut_update_object_reference(object, REF_DECREMENT);
+	return_VOID;
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/uteval.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/uteval.c
new file mode 100644
index 00000000..41051534
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/uteval.c
@@ -0,0 +1,337 @@
+/******************************************************************************
+ *
+ * Module Name: uteval - Object evaluation
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acnamesp.h"
+
+#define _COMPONENT          ACPI_UTILITIES
+ACPI_MODULE_NAME("uteval")
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_evaluate_object
+ *
+ * PARAMETERS:  prefix_node         - Starting node
+ *              Path                - Path to object from starting node
+ *              expected_return_types - Bitmap of allowed return types
+ *              return_desc         - Where a return value is stored
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Evaluates a namespace object and verifies the type of the
+ *              return object. Common code that simplifies accessing objects
+ *              that have required return objects of fixed types.
+ *
+ *              NOTE: Internal function, no parameter validation
+ *
+ ******************************************************************************/
+acpi_status
+acpi_ut_evaluate_object(struct acpi_namespace_node *prefix_node,
+			char *path,
+			u32 expected_return_btypes,
+			union acpi_operand_object **return_desc)
+{
+	struct acpi_evaluate_info *info;
+	acpi_status status;
+	u32 return_btype;
+
+	ACPI_FUNCTION_TRACE(ut_evaluate_object);
+
+	/* Allocate the evaluation information block */
+
+	info = ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_evaluate_info));
+	if (!info) {
+		return_ACPI_STATUS(AE_NO_MEMORY);
+	}
+
+	info->prefix_node = prefix_node;
+	info->pathname = path;
+
+	/* Evaluate the object/method */
+
+	status = acpi_ns_evaluate(info);
+	if (ACPI_FAILURE(status)) {
+		if (status == AE_NOT_FOUND) {
+			ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
+					  "[%4.4s.%s] was not found\n",
+					  acpi_ut_get_node_name(prefix_node),
+					  path));
+		} else {
+			ACPI_ERROR_METHOD("Method execution failed",
+					  prefix_node, path, status);
+		}
+
+		goto cleanup;
+	}
+
+	/* Did we get a return object? */
+
+	if (!info->return_object) {
+		if (expected_return_btypes) {
+			ACPI_ERROR_METHOD("No object was returned from",
+					  prefix_node, path, AE_NOT_EXIST);
+
+			status = AE_NOT_EXIST;
+		}
+
+		goto cleanup;
+	}
+
+	/* Map the return object type to the bitmapped type */
+
+	switch ((info->return_object)->common.type) {
+	case ACPI_TYPE_INTEGER:
+		return_btype = ACPI_BTYPE_INTEGER;
+		break;
+
+	case ACPI_TYPE_BUFFER:
+		return_btype = ACPI_BTYPE_BUFFER;
+		break;
+
+	case ACPI_TYPE_STRING:
+		return_btype = ACPI_BTYPE_STRING;
+		break;
+
+	case ACPI_TYPE_PACKAGE:
+		return_btype = ACPI_BTYPE_PACKAGE;
+		break;
+
+	default:
+		return_btype = 0;
+		break;
+	}
+
+	if ((acpi_gbl_enable_interpreter_slack) && (!expected_return_btypes)) {
+		/*
+		 * We received a return object, but one was not expected. This can
+		 * happen frequently if the "implicit return" feature is enabled.
+		 * Just delete the return object and return AE_OK.
+		 */
+		acpi_ut_remove_reference(info->return_object);
+		goto cleanup;
+	}
+
+	/* Is the return object one of the expected types? */
+
+	if (!(expected_return_btypes & return_btype)) {
+		ACPI_ERROR_METHOD("Return object type is incorrect",
+				  prefix_node, path, AE_TYPE);
+
+		ACPI_ERROR((AE_INFO,
+			    "Type returned from %s was incorrect: %s, expected Btypes: 0x%X",
+			    path,
+			    acpi_ut_get_object_type_name(info->return_object),
+			    expected_return_btypes));
+
+		/* On error exit, we must delete the return object */
+
+		acpi_ut_remove_reference(info->return_object);
+		status = AE_TYPE;
+		goto cleanup;
+	}
+
+	/* Object type is OK, return it */
+
+	*return_desc = info->return_object;
+
+      cleanup:
+	ACPI_FREE(info);
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_evaluate_numeric_object
+ *
+ * PARAMETERS:  object_name         - Object name to be evaluated
+ *              device_node         - Node for the device
+ *              Value               - Where the value is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Evaluates a numeric namespace object for a selected device
+ *              and stores result in *Value.
+ *
+ *              NOTE: Internal function, no parameter validation
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ut_evaluate_numeric_object(char *object_name,
+				struct acpi_namespace_node *device_node,
+				u64 *value)
+{
+	union acpi_operand_object *obj_desc;
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(ut_evaluate_numeric_object);
+
+	status = acpi_ut_evaluate_object(device_node, object_name,
+					 ACPI_BTYPE_INTEGER, &obj_desc);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/* Get the returned Integer */
+
+	*value = obj_desc->integer.value;
+
+	/* On exit, we must delete the return object */
+
+	acpi_ut_remove_reference(obj_desc);
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_execute_STA
+ *
+ * PARAMETERS:  device_node         - Node for the device
+ *              Flags               - Where the status flags are returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Executes _STA for selected device and stores results in
+ *              *Flags.
+ *
+ *              NOTE: Internal function, no parameter validation
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ut_execute_STA(struct acpi_namespace_node *device_node, u32 *flags)
+{
+	union acpi_operand_object *obj_desc;
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(ut_execute_STA);
+
+	status = acpi_ut_evaluate_object(device_node, METHOD_NAME__STA,
+					 ACPI_BTYPE_INTEGER, &obj_desc);
+	if (ACPI_FAILURE(status)) {
+		if (AE_NOT_FOUND == status) {
+			ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
+					  "_STA on %4.4s was not found, assuming device is present\n",
+					  acpi_ut_get_node_name(device_node)));
+
+			*flags = ACPI_UINT32_MAX;
+			status = AE_OK;
+		}
+
+		return_ACPI_STATUS(status);
+	}
+
+	/* Extract the status flags */
+
+	*flags = (u32)obj_desc->integer.value;
+
+	/* On exit, we must delete the return object */
+
+	acpi_ut_remove_reference(obj_desc);
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_execute_power_methods
+ *
+ * PARAMETERS:  device_node         - Node for the device
+ *              method_names        - Array of power method names
+ *              method_count        - Number of methods to execute
+ *              out_values          - Where the power method values are returned
+ *
+ * RETURN:      Status, out_values
+ *
+ * DESCRIPTION: Executes the specified power methods for the device and returns
+ *              the result(s).
+ *
+ *              NOTE: Internal function, no parameter validation
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ut_execute_power_methods(struct acpi_namespace_node *device_node,
+			      const char **method_names,
+			      u8 method_count, u8 *out_values)
+{
+	union acpi_operand_object *obj_desc;
+	acpi_status status;
+	acpi_status final_status = AE_NOT_FOUND;
+	u32 i;
+
+	ACPI_FUNCTION_TRACE(ut_execute_power_methods);
+
+	for (i = 0; i < method_count; i++) {
+		/*
+		 * Execute the power method (_sx_d or _sx_w). The only allowable
+		 * return type is an Integer.
+		 */
+		status = acpi_ut_evaluate_object(device_node,
+						 ACPI_CAST_PTR(char,
+							       method_names[i]),
+						 ACPI_BTYPE_INTEGER, &obj_desc);
+		if (ACPI_SUCCESS(status)) {
+			out_values[i] = (u8)obj_desc->integer.value;
+
+			/* Delete the return object */
+
+			acpi_ut_remove_reference(obj_desc);
+			final_status = AE_OK;	/* At least one value is valid */
+			continue;
+		}
+
+		out_values[i] = ACPI_UINT8_MAX;
+		if (status == AE_NOT_FOUND) {
+			continue;	/* Ignore if not found */
+		}
+
+		ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
+				  "Failed %s on Device %4.4s, %s\n",
+				  ACPI_CAST_PTR(char, method_names[i]),
+				  acpi_ut_get_node_name(device_node),
+				  acpi_format_exception(status)));
+	}
+
+	return_ACPI_STATUS(final_status);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utglobal.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utglobal.c
new file mode 100644
index 00000000..8815fb93
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utglobal.c
@@ -0,0 +1,388 @@
+/******************************************************************************
+ *
+ * Module Name: utglobal - Global variables for the ACPI subsystem
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#define DEFINE_ACPI_GLOBALS
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+
+#define _COMPONENT          ACPI_UTILITIES
+ACPI_MODULE_NAME("utglobal")
+
+/*******************************************************************************
+ *
+ * Static global variable initialization.
+ *
+ ******************************************************************************/
+/*
+ * We want the debug switches statically initialized so they
+ * are already set when the debugger is entered.
+ */
+/* Debug switch - level and trace mask */
+#ifdef ACPI_DEBUG_OUTPUT
+u32 acpi_dbg_level = ACPI_DEBUG_DEFAULT;
+#else
+u32 acpi_dbg_level = ACPI_NORMAL_DEFAULT;
+#endif
+
+/* Debug switch - layer (component) mask */
+
+u32 acpi_dbg_layer = ACPI_COMPONENT_DEFAULT;
+u32 acpi_gbl_nesting_level = 0;
+
+/* Debugger globals */
+
+u8 acpi_gbl_db_terminate_threads = FALSE;
+u8 acpi_gbl_abort_method = FALSE;
+u8 acpi_gbl_method_executing = FALSE;
+
+/* System flags */
+
+u32 acpi_gbl_startup_flags = 0;
+
+/* System starts uninitialized */
+
+u8 acpi_gbl_shutdown = TRUE;
+
+const char *acpi_gbl_sleep_state_names[ACPI_S_STATE_COUNT] = {
+	"\\_S0_",
+	"\\_S1_",
+	"\\_S2_",
+	"\\_S3_",
+	"\\_S4_",
+	"\\_S5_"
+};
+
+const char *acpi_gbl_lowest_dstate_names[ACPI_NUM_sx_w_METHODS] = {
+	"_S0W",
+	"_S1W",
+	"_S2W",
+	"_S3W",
+	"_S4W"
+};
+
+const char *acpi_gbl_highest_dstate_names[ACPI_NUM_sx_d_METHODS] = {
+	"_S1D",
+	"_S2D",
+	"_S3D",
+	"_S4D"
+};
+
+/*******************************************************************************
+ *
+ * Namespace globals
+ *
+ ******************************************************************************/
+
+/*
+ * Predefined ACPI Names (Built-in to the Interpreter)
+ *
+ * NOTES:
+ * 1) _SB_ is defined to be a device to allow \_SB_._INI to be run
+ *    during the initialization sequence.
+ * 2) _TZ_ is defined to be a thermal zone in order to allow ASL code to
+ *    perform a Notify() operation on it. 09/2010: Changed to type Device.
+ *    This still allows notifies, but does not confuse host code that
+ *    searches for valid thermal_zone objects.
+ */
+const struct acpi_predefined_names acpi_gbl_pre_defined_names[] = {
+	{"_GPE", ACPI_TYPE_LOCAL_SCOPE, NULL},
+	{"_PR_", ACPI_TYPE_LOCAL_SCOPE, NULL},
+	{"_SB_", ACPI_TYPE_DEVICE, NULL},
+	{"_SI_", ACPI_TYPE_LOCAL_SCOPE, NULL},
+	{"_TZ_", ACPI_TYPE_DEVICE, NULL},
+	{"_REV", ACPI_TYPE_INTEGER, (char *)ACPI_CA_SUPPORT_LEVEL},
+	{"_OS_", ACPI_TYPE_STRING, ACPI_OS_NAME},
+	{"_GL_", ACPI_TYPE_MUTEX, (char *)1},
+
+#if !defined (ACPI_NO_METHOD_EXECUTION) || defined (ACPI_CONSTANT_EVAL_ONLY)
+	{"_OSI", ACPI_TYPE_METHOD, (char *)1},
+#endif
+
+	/* Table terminator */
+
+	{NULL, ACPI_TYPE_ANY, NULL}
+};
+
+/******************************************************************************
+ *
+ * Event and Hardware globals
+ *
+ ******************************************************************************/
+
+struct acpi_bit_register_info acpi_gbl_bit_register_info[ACPI_NUM_BITREG] = {
+	/* Name                                     Parent Register             Register Bit Position                   Register Bit Mask       */
+
+	/* ACPI_BITREG_TIMER_STATUS         */ {ACPI_REGISTER_PM1_STATUS,
+						ACPI_BITPOSITION_TIMER_STATUS,
+						ACPI_BITMASK_TIMER_STATUS},
+	/* ACPI_BITREG_BUS_MASTER_STATUS    */ {ACPI_REGISTER_PM1_STATUS,
+						ACPI_BITPOSITION_BUS_MASTER_STATUS,
+						ACPI_BITMASK_BUS_MASTER_STATUS},
+	/* ACPI_BITREG_GLOBAL_LOCK_STATUS   */ {ACPI_REGISTER_PM1_STATUS,
+						ACPI_BITPOSITION_GLOBAL_LOCK_STATUS,
+						ACPI_BITMASK_GLOBAL_LOCK_STATUS},
+	/* ACPI_BITREG_POWER_BUTTON_STATUS  */ {ACPI_REGISTER_PM1_STATUS,
+						ACPI_BITPOSITION_POWER_BUTTON_STATUS,
+						ACPI_BITMASK_POWER_BUTTON_STATUS},
+	/* ACPI_BITREG_SLEEP_BUTTON_STATUS  */ {ACPI_REGISTER_PM1_STATUS,
+						ACPI_BITPOSITION_SLEEP_BUTTON_STATUS,
+						ACPI_BITMASK_SLEEP_BUTTON_STATUS},
+	/* ACPI_BITREG_RT_CLOCK_STATUS      */ {ACPI_REGISTER_PM1_STATUS,
+						ACPI_BITPOSITION_RT_CLOCK_STATUS,
+						ACPI_BITMASK_RT_CLOCK_STATUS},
+	/* ACPI_BITREG_WAKE_STATUS          */ {ACPI_REGISTER_PM1_STATUS,
+						ACPI_BITPOSITION_WAKE_STATUS,
+						ACPI_BITMASK_WAKE_STATUS},
+	/* ACPI_BITREG_PCIEXP_WAKE_STATUS   */ {ACPI_REGISTER_PM1_STATUS,
+						ACPI_BITPOSITION_PCIEXP_WAKE_STATUS,
+						ACPI_BITMASK_PCIEXP_WAKE_STATUS},
+
+	/* ACPI_BITREG_TIMER_ENABLE         */ {ACPI_REGISTER_PM1_ENABLE,
+						ACPI_BITPOSITION_TIMER_ENABLE,
+						ACPI_BITMASK_TIMER_ENABLE},
+	/* ACPI_BITREG_GLOBAL_LOCK_ENABLE   */ {ACPI_REGISTER_PM1_ENABLE,
+						ACPI_BITPOSITION_GLOBAL_LOCK_ENABLE,
+						ACPI_BITMASK_GLOBAL_LOCK_ENABLE},
+	/* ACPI_BITREG_POWER_BUTTON_ENABLE  */ {ACPI_REGISTER_PM1_ENABLE,
+						ACPI_BITPOSITION_POWER_BUTTON_ENABLE,
+						ACPI_BITMASK_POWER_BUTTON_ENABLE},
+	/* ACPI_BITREG_SLEEP_BUTTON_ENABLE  */ {ACPI_REGISTER_PM1_ENABLE,
+						ACPI_BITPOSITION_SLEEP_BUTTON_ENABLE,
+						ACPI_BITMASK_SLEEP_BUTTON_ENABLE},
+	/* ACPI_BITREG_RT_CLOCK_ENABLE      */ {ACPI_REGISTER_PM1_ENABLE,
+						ACPI_BITPOSITION_RT_CLOCK_ENABLE,
+						ACPI_BITMASK_RT_CLOCK_ENABLE},
+	/* ACPI_BITREG_PCIEXP_WAKE_DISABLE  */ {ACPI_REGISTER_PM1_ENABLE,
+						ACPI_BITPOSITION_PCIEXP_WAKE_DISABLE,
+						ACPI_BITMASK_PCIEXP_WAKE_DISABLE},
+
+	/* ACPI_BITREG_SCI_ENABLE           */ {ACPI_REGISTER_PM1_CONTROL,
+						ACPI_BITPOSITION_SCI_ENABLE,
+						ACPI_BITMASK_SCI_ENABLE},
+	/* ACPI_BITREG_BUS_MASTER_RLD       */ {ACPI_REGISTER_PM1_CONTROL,
+						ACPI_BITPOSITION_BUS_MASTER_RLD,
+						ACPI_BITMASK_BUS_MASTER_RLD},
+	/* ACPI_BITREG_GLOBAL_LOCK_RELEASE  */ {ACPI_REGISTER_PM1_CONTROL,
+						ACPI_BITPOSITION_GLOBAL_LOCK_RELEASE,
+						ACPI_BITMASK_GLOBAL_LOCK_RELEASE},
+	/* ACPI_BITREG_SLEEP_TYPE           */ {ACPI_REGISTER_PM1_CONTROL,
+						ACPI_BITPOSITION_SLEEP_TYPE,
+						ACPI_BITMASK_SLEEP_TYPE},
+	/* ACPI_BITREG_SLEEP_ENABLE         */ {ACPI_REGISTER_PM1_CONTROL,
+						ACPI_BITPOSITION_SLEEP_ENABLE,
+						ACPI_BITMASK_SLEEP_ENABLE},
+
+	/* ACPI_BITREG_ARB_DIS              */ {ACPI_REGISTER_PM2_CONTROL,
+						ACPI_BITPOSITION_ARB_DISABLE,
+						ACPI_BITMASK_ARB_DISABLE}
+};
+
+struct acpi_fixed_event_info acpi_gbl_fixed_event_info[ACPI_NUM_FIXED_EVENTS] = {
+	/* ACPI_EVENT_PMTIMER       */ {ACPI_BITREG_TIMER_STATUS,
+					ACPI_BITREG_TIMER_ENABLE,
+					ACPI_BITMASK_TIMER_STATUS,
+					ACPI_BITMASK_TIMER_ENABLE},
+	/* ACPI_EVENT_GLOBAL        */ {ACPI_BITREG_GLOBAL_LOCK_STATUS,
+					ACPI_BITREG_GLOBAL_LOCK_ENABLE,
+					ACPI_BITMASK_GLOBAL_LOCK_STATUS,
+					ACPI_BITMASK_GLOBAL_LOCK_ENABLE},
+	/* ACPI_EVENT_POWER_BUTTON  */ {ACPI_BITREG_POWER_BUTTON_STATUS,
+					ACPI_BITREG_POWER_BUTTON_ENABLE,
+					ACPI_BITMASK_POWER_BUTTON_STATUS,
+					ACPI_BITMASK_POWER_BUTTON_ENABLE},
+	/* ACPI_EVENT_SLEEP_BUTTON  */ {ACPI_BITREG_SLEEP_BUTTON_STATUS,
+					ACPI_BITREG_SLEEP_BUTTON_ENABLE,
+					ACPI_BITMASK_SLEEP_BUTTON_STATUS,
+					ACPI_BITMASK_SLEEP_BUTTON_ENABLE},
+	/* ACPI_EVENT_RTC           */ {ACPI_BITREG_RT_CLOCK_STATUS,
+					ACPI_BITREG_RT_CLOCK_ENABLE,
+					ACPI_BITMASK_RT_CLOCK_STATUS,
+					ACPI_BITMASK_RT_CLOCK_ENABLE},
+};
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_init_globals
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Init ACPICA globals.  All globals that require specific
+ *              initialization should be initialized here!
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ut_init_globals(void)
+{
+	acpi_status status;
+	u32 i;
+
+	ACPI_FUNCTION_TRACE(ut_init_globals);
+
+	/* Create all memory caches */
+
+	status = acpi_ut_create_caches();
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/* Address Range lists */
+
+	for (i = 0; i < ACPI_ADDRESS_RANGE_MAX; i++) {
+		acpi_gbl_address_range_list[i] = NULL;
+	}
+
+	/* Mutex locked flags */
+
+	for (i = 0; i < ACPI_NUM_MUTEX; i++) {
+		acpi_gbl_mutex_info[i].mutex = NULL;
+		acpi_gbl_mutex_info[i].thread_id = ACPI_MUTEX_NOT_ACQUIRED;
+		acpi_gbl_mutex_info[i].use_count = 0;
+	}
+
+	for (i = 0; i < ACPI_NUM_OWNERID_MASKS; i++) {
+		acpi_gbl_owner_id_mask[i] = 0;
+	}
+
+	/* Last owner_iD is never valid */
+
+	acpi_gbl_owner_id_mask[ACPI_NUM_OWNERID_MASKS - 1] = 0x80000000;
+
+	/* Event counters */
+
+	acpi_method_count = 0;
+	acpi_sci_count = 0;
+	acpi_gpe_count = 0;
+
+	for (i = 0; i < ACPI_NUM_FIXED_EVENTS; i++) {
+		acpi_fixed_event_count[i] = 0;
+	}
+
+	/* GPE support */
+
+	acpi_gbl_all_gpes_initialized = FALSE;
+	acpi_gbl_gpe_xrupt_list_head = NULL;
+	acpi_gbl_gpe_fadt_blocks[0] = NULL;
+	acpi_gbl_gpe_fadt_blocks[1] = NULL;
+	acpi_current_gpe_count = 0;
+
+	/* Global handlers */
+
+	acpi_gbl_system_notify.handler = NULL;
+	acpi_gbl_device_notify.handler = NULL;
+	acpi_gbl_exception_handler = NULL;
+	acpi_gbl_init_handler = NULL;
+	acpi_gbl_table_handler = NULL;
+	acpi_gbl_interface_handler = NULL;
+	acpi_gbl_global_event_handler = NULL;
+
+	/* Global Lock support */
+
+	acpi_gbl_global_lock_semaphore = NULL;
+	acpi_gbl_global_lock_mutex = NULL;
+	acpi_gbl_global_lock_acquired = FALSE;
+	acpi_gbl_global_lock_handle = 0;
+	acpi_gbl_global_lock_present = FALSE;
+
+	/* Miscellaneous variables */
+
+	acpi_gbl_DSDT = NULL;
+	acpi_gbl_cm_single_step = FALSE;
+	acpi_gbl_db_terminate_threads = FALSE;
+	acpi_gbl_shutdown = FALSE;
+	acpi_gbl_ns_lookup_count = 0;
+	acpi_gbl_ps_find_count = 0;
+	acpi_gbl_acpi_hardware_present = TRUE;
+	acpi_gbl_last_owner_id_index = 0;
+	acpi_gbl_next_owner_id_offset = 0;
+	acpi_gbl_trace_method_name = 0;
+	acpi_gbl_trace_dbg_level = 0;
+	acpi_gbl_trace_dbg_layer = 0;
+	acpi_gbl_debugger_configuration = DEBUGGER_THREADING;
+	acpi_gbl_db_output_flags = ACPI_DB_CONSOLE_OUTPUT;
+	acpi_gbl_osi_data = 0;
+	acpi_gbl_osi_mutex = NULL;
+	acpi_gbl_reg_methods_executed = FALSE;
+
+	/* Hardware oriented */
+
+	acpi_gbl_events_initialized = FALSE;
+	acpi_gbl_system_awake_and_running = TRUE;
+
+	/* Namespace */
+
+	acpi_gbl_module_code_list = NULL;
+	acpi_gbl_root_node = NULL;
+	acpi_gbl_root_node_struct.name.integer = ACPI_ROOT_NAME;
+	acpi_gbl_root_node_struct.descriptor_type = ACPI_DESC_TYPE_NAMED;
+	acpi_gbl_root_node_struct.type = ACPI_TYPE_DEVICE;
+	acpi_gbl_root_node_struct.parent = NULL;
+	acpi_gbl_root_node_struct.child = NULL;
+	acpi_gbl_root_node_struct.peer = NULL;
+	acpi_gbl_root_node_struct.object = NULL;
+
+#ifdef ACPI_DISASSEMBLER
+	acpi_gbl_external_list = NULL;
+#endif
+
+#ifdef ACPI_DEBUG_OUTPUT
+	acpi_gbl_lowest_stack_pointer = ACPI_CAST_PTR(acpi_size, ACPI_SIZE_MAX);
+#endif
+
+#ifdef ACPI_DBG_TRACK_ALLOCATIONS
+	acpi_gbl_display_final_mem_stats = FALSE;
+	acpi_gbl_disable_mem_tracking = FALSE;
+#endif
+
+	return_ACPI_STATUS(AE_OK);
+}
+
+/* Public globals */
+
+ACPI_EXPORT_SYMBOL(acpi_gbl_FADT)
+    ACPI_EXPORT_SYMBOL(acpi_dbg_level)
+    ACPI_EXPORT_SYMBOL(acpi_dbg_layer)
+    ACPI_EXPORT_SYMBOL(acpi_gpe_count)
+    ACPI_EXPORT_SYMBOL(acpi_current_gpe_count)
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utids.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utids.c
new file mode 100644
index 00000000..11a922c8
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utids.c
@@ -0,0 +1,345 @@
+/******************************************************************************
+ *
+ * Module Name: utids - support for device IDs - HID, UID, CID
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acinterp.h"
+
+#define _COMPONENT          ACPI_UTILITIES
+ACPI_MODULE_NAME("utids")
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_execute_HID
+ *
+ * PARAMETERS:  device_node         - Node for the device
+ *              return_id           - Where the string HID is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Executes the _HID control method that returns the hardware
+ *              ID of the device. The HID is either an 32-bit encoded EISAID
+ *              Integer or a String. A string is always returned. An EISAID
+ *              is converted to a string.
+ *
+ *              NOTE: Internal function, no parameter validation
+ *
+ ******************************************************************************/
+acpi_status
+acpi_ut_execute_HID(struct acpi_namespace_node *device_node,
+		    struct acpi_device_id **return_id)
+{
+	union acpi_operand_object *obj_desc;
+	struct acpi_device_id *hid;
+	u32 length;
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(ut_execute_HID);
+
+	status = acpi_ut_evaluate_object(device_node, METHOD_NAME__HID,
+					 ACPI_BTYPE_INTEGER | ACPI_BTYPE_STRING,
+					 &obj_desc);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/* Get the size of the String to be returned, includes null terminator */
+
+	if (obj_desc->common.type == ACPI_TYPE_INTEGER) {
+		length = ACPI_EISAID_STRING_SIZE;
+	} else {
+		length = obj_desc->string.length + 1;
+	}
+
+	/* Allocate a buffer for the HID */
+
+	hid =
+	    ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_device_id) +
+				 (acpi_size) length);
+	if (!hid) {
+		status = AE_NO_MEMORY;
+		goto cleanup;
+	}
+
+	/* Area for the string starts after DEVICE_ID struct */
+
+	hid->string = ACPI_ADD_PTR(char, hid, sizeof(struct acpi_device_id));
+
+	/* Convert EISAID to a string or simply copy existing string */
+
+	if (obj_desc->common.type == ACPI_TYPE_INTEGER) {
+		acpi_ex_eisa_id_to_string(hid->string, obj_desc->integer.value);
+	} else {
+		ACPI_STRCPY(hid->string, obj_desc->string.pointer);
+	}
+
+	hid->length = length;
+	*return_id = hid;
+
+      cleanup:
+
+	/* On exit, we must delete the return object */
+
+	acpi_ut_remove_reference(obj_desc);
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_execute_UID
+ *
+ * PARAMETERS:  device_node         - Node for the device
+ *              return_id           - Where the string UID is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Executes the _UID control method that returns the unique
+ *              ID of the device. The UID is either a 64-bit Integer (NOT an
+ *              EISAID) or a string. Always returns a string. A 64-bit integer
+ *              is converted to a decimal string.
+ *
+ *              NOTE: Internal function, no parameter validation
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ut_execute_UID(struct acpi_namespace_node *device_node,
+		    struct acpi_device_id **return_id)
+{
+	union acpi_operand_object *obj_desc;
+	struct acpi_device_id *uid;
+	u32 length;
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(ut_execute_UID);
+
+	status = acpi_ut_evaluate_object(device_node, METHOD_NAME__UID,
+					 ACPI_BTYPE_INTEGER | ACPI_BTYPE_STRING,
+					 &obj_desc);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/* Get the size of the String to be returned, includes null terminator */
+
+	if (obj_desc->common.type == ACPI_TYPE_INTEGER) {
+		length = ACPI_MAX64_DECIMAL_DIGITS + 1;
+	} else {
+		length = obj_desc->string.length + 1;
+	}
+
+	/* Allocate a buffer for the UID */
+
+	uid =
+	    ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_device_id) +
+				 (acpi_size) length);
+	if (!uid) {
+		status = AE_NO_MEMORY;
+		goto cleanup;
+	}
+
+	/* Area for the string starts after DEVICE_ID struct */
+
+	uid->string = ACPI_ADD_PTR(char, uid, sizeof(struct acpi_device_id));
+
+	/* Convert an Integer to string, or just copy an existing string */
+
+	if (obj_desc->common.type == ACPI_TYPE_INTEGER) {
+		acpi_ex_integer_to_string(uid->string, obj_desc->integer.value);
+	} else {
+		ACPI_STRCPY(uid->string, obj_desc->string.pointer);
+	}
+
+	uid->length = length;
+	*return_id = uid;
+
+      cleanup:
+
+	/* On exit, we must delete the return object */
+
+	acpi_ut_remove_reference(obj_desc);
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_execute_CID
+ *
+ * PARAMETERS:  device_node         - Node for the device
+ *              return_cid_list     - Where the CID list is returned
+ *
+ * RETURN:      Status, list of CID strings
+ *
+ * DESCRIPTION: Executes the _CID control method that returns one or more
+ *              compatible hardware IDs for the device.
+ *
+ *              NOTE: Internal function, no parameter validation
+ *
+ * A _CID method can return either a single compatible ID or a package of
+ * compatible IDs. Each compatible ID can be one of the following:
+ * 1) Integer (32 bit compressed EISA ID) or
+ * 2) String (PCI ID format, e.g. "PCI\VEN_vvvv&DEV_dddd&SUBSYS_ssssssss")
+ *
+ * The Integer CIDs are converted to string format by this function.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ut_execute_CID(struct acpi_namespace_node *device_node,
+		    struct acpi_device_id_list **return_cid_list)
+{
+	union acpi_operand_object **cid_objects;
+	union acpi_operand_object *obj_desc;
+	struct acpi_device_id_list *cid_list;
+	char *next_id_string;
+	u32 string_area_size;
+	u32 length;
+	u32 cid_list_size;
+	acpi_status status;
+	u32 count;
+	u32 i;
+
+	ACPI_FUNCTION_TRACE(ut_execute_CID);
+
+	/* Evaluate the _CID method for this device */
+
+	status = acpi_ut_evaluate_object(device_node, METHOD_NAME__CID,
+					 ACPI_BTYPE_INTEGER | ACPI_BTYPE_STRING
+					 | ACPI_BTYPE_PACKAGE, &obj_desc);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/*
+	 * Get the count and size of the returned _CIDs. _CID can return either
+	 * a Package of Integers/Strings or a single Integer or String.
+	 * Note: This section also validates that all CID elements are of the
+	 * correct type (Integer or String).
+	 */
+	if (obj_desc->common.type == ACPI_TYPE_PACKAGE) {
+		count = obj_desc->package.count;
+		cid_objects = obj_desc->package.elements;
+	} else {		/* Single Integer or String CID */
+
+		count = 1;
+		cid_objects = &obj_desc;
+	}
+
+	string_area_size = 0;
+	for (i = 0; i < count; i++) {
+
+		/* String lengths include null terminator */
+
+		switch (cid_objects[i]->common.type) {
+		case ACPI_TYPE_INTEGER:
+			string_area_size += ACPI_EISAID_STRING_SIZE;
+			break;
+
+		case ACPI_TYPE_STRING:
+			string_area_size += cid_objects[i]->string.length + 1;
+			break;
+
+		default:
+			status = AE_TYPE;
+			goto cleanup;
+		}
+	}
+
+	/*
+	 * Now that we know the length of the CIDs, allocate return buffer:
+	 * 1) Size of the base structure +
+	 * 2) Size of the CID DEVICE_ID array +
+	 * 3) Size of the actual CID strings
+	 */
+	cid_list_size = sizeof(struct acpi_device_id_list) +
+	    ((count - 1) * sizeof(struct acpi_device_id)) + string_area_size;
+
+	cid_list = ACPI_ALLOCATE_ZEROED(cid_list_size);
+	if (!cid_list) {
+		status = AE_NO_MEMORY;
+		goto cleanup;
+	}
+
+	/* Area for CID strings starts after the CID DEVICE_ID array */
+
+	next_id_string = ACPI_CAST_PTR(char, cid_list->ids) +
+	    ((acpi_size) count * sizeof(struct acpi_device_id));
+
+	/* Copy/convert the CIDs to the return buffer */
+
+	for (i = 0; i < count; i++) {
+		if (cid_objects[i]->common.type == ACPI_TYPE_INTEGER) {
+
+			/* Convert the Integer (EISAID) CID to a string */
+
+			acpi_ex_eisa_id_to_string(next_id_string,
+						  cid_objects[i]->integer.
+						  value);
+			length = ACPI_EISAID_STRING_SIZE;
+		} else {	/* ACPI_TYPE_STRING */
+
+			/* Copy the String CID from the returned object */
+
+			ACPI_STRCPY(next_id_string,
+				    cid_objects[i]->string.pointer);
+			length = cid_objects[i]->string.length + 1;
+		}
+
+		cid_list->ids[i].string = next_id_string;
+		cid_list->ids[i].length = length;
+		next_id_string += length;
+	}
+
+	/* Finish the CID list */
+
+	cid_list->count = count;
+	cid_list->list_size = cid_list_size;
+	*return_cid_list = cid_list;
+
+      cleanup:
+
+	/* On exit, we must delete the _CID return object */
+
+	acpi_ut_remove_reference(obj_desc);
+	return_ACPI_STATUS(status);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utinit.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utinit.c
new file mode 100644
index 00000000..8359c0c5
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utinit.c
@@ -0,0 +1,143 @@
+/******************************************************************************
+ *
+ * Module Name: utinit - Common ACPI subsystem initialization
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acnamesp.h"
+#include "acevents.h"
+#include "actables.h"
+
+#define _COMPONENT          ACPI_UTILITIES
+ACPI_MODULE_NAME("utinit")
+
+/* Local prototypes */
+static void acpi_ut_terminate(void);
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_terminate
+ *
+ * PARAMETERS:  none
+ *
+ * RETURN:      none
+ *
+ * DESCRIPTION: Free global memory
+ *
+ ******************************************************************************/
+
+static void acpi_ut_terminate(void)
+{
+	struct acpi_gpe_block_info *gpe_block;
+	struct acpi_gpe_block_info *next_gpe_block;
+	struct acpi_gpe_xrupt_info *gpe_xrupt_info;
+	struct acpi_gpe_xrupt_info *next_gpe_xrupt_info;
+
+	ACPI_FUNCTION_TRACE(ut_terminate);
+
+	/* Free global GPE blocks and related info structures */
+
+	gpe_xrupt_info = acpi_gbl_gpe_xrupt_list_head;
+	while (gpe_xrupt_info) {
+		gpe_block = gpe_xrupt_info->gpe_block_list_head;
+		while (gpe_block) {
+			next_gpe_block = gpe_block->next;
+			ACPI_FREE(gpe_block->event_info);
+			ACPI_FREE(gpe_block->register_info);
+			ACPI_FREE(gpe_block);
+
+			gpe_block = next_gpe_block;
+		}
+		next_gpe_xrupt_info = gpe_xrupt_info->next;
+		ACPI_FREE(gpe_xrupt_info);
+		gpe_xrupt_info = next_gpe_xrupt_info;
+	}
+
+	acpi_ut_delete_address_lists();
+	return_VOID;
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_subsystem_shutdown
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Shutdown the various components. Do not delete the mutex
+ *              objects here, because the AML debugger may be still running.
+ *
+ ******************************************************************************/
+
+void acpi_ut_subsystem_shutdown(void)
+{
+	ACPI_FUNCTION_TRACE(ut_subsystem_shutdown);
+
+#ifndef ACPI_ASL_COMPILER
+
+	/* Close the acpi_event Handling */
+
+	acpi_ev_terminate();
+
+	/* Delete any dynamic _OSI interfaces */
+
+	acpi_ut_interface_terminate();
+#endif
+
+	/* Close the Namespace */
+
+	acpi_ns_terminate();
+
+	/* Delete the ACPI tables */
+
+	acpi_tb_terminate();
+
+	/* Close the globals */
+
+	acpi_ut_terminate();
+
+	/* Purge the local caches */
+
+	(void)acpi_ut_delete_caches();
+	return_VOID;
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utlock.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utlock.c
new file mode 100644
index 00000000..075efc46
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utlock.c
@@ -0,0 +1,175 @@
+/******************************************************************************
+ *
+ * Module Name: utlock - Reader/Writer lock interfaces
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+
+#define _COMPONENT          ACPI_UTILITIES
+ACPI_MODULE_NAME("utlock")
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_create_rw_lock
+ *              acpi_ut_delete_rw_lock
+ *
+ * PARAMETERS:  Lock                - Pointer to a valid RW lock
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Reader/writer lock creation and deletion interfaces.
+ *
+ ******************************************************************************/
+acpi_status acpi_ut_create_rw_lock(struct acpi_rw_lock *lock)
+{
+	acpi_status status;
+
+	lock->num_readers = 0;
+	status = acpi_os_create_mutex(&lock->reader_mutex);
+	if (ACPI_FAILURE(status)) {
+		return (status);
+	}
+
+	status = acpi_os_create_mutex(&lock->writer_mutex);
+	return (status);
+}
+
+void acpi_ut_delete_rw_lock(struct acpi_rw_lock *lock)
+{
+
+	acpi_os_delete_mutex(lock->reader_mutex);
+	acpi_os_delete_mutex(lock->writer_mutex);
+
+	lock->num_readers = 0;
+	lock->reader_mutex = NULL;
+	lock->writer_mutex = NULL;
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_acquire_read_lock
+ *              acpi_ut_release_read_lock
+ *
+ * PARAMETERS:  Lock                - Pointer to a valid RW lock
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Reader interfaces for reader/writer locks. On acquisition,
+ *              only the first reader acquires the write mutex. On release,
+ *              only the last reader releases the write mutex. Although this
+ *              algorithm can in theory starve writers, this should not be a
+ *              problem with ACPICA since the subsystem is infrequently used
+ *              in comparison to (for example) an I/O system.
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ut_acquire_read_lock(struct acpi_rw_lock *lock)
+{
+	acpi_status status;
+
+	status = acpi_os_acquire_mutex(lock->reader_mutex, ACPI_WAIT_FOREVER);
+	if (ACPI_FAILURE(status)) {
+		return (status);
+	}
+
+	/* Acquire the write lock only for the first reader */
+
+	lock->num_readers++;
+	if (lock->num_readers == 1) {
+		status =
+		    acpi_os_acquire_mutex(lock->writer_mutex,
+					  ACPI_WAIT_FOREVER);
+	}
+
+	acpi_os_release_mutex(lock->reader_mutex);
+	return (status);
+}
+
+acpi_status acpi_ut_release_read_lock(struct acpi_rw_lock * lock)
+{
+	acpi_status status;
+
+	status = acpi_os_acquire_mutex(lock->reader_mutex, ACPI_WAIT_FOREVER);
+	if (ACPI_FAILURE(status)) {
+		return (status);
+	}
+
+	/* Release the write lock only for the very last reader */
+
+	lock->num_readers--;
+	if (lock->num_readers == 0) {
+		acpi_os_release_mutex(lock->writer_mutex);
+	}
+
+	acpi_os_release_mutex(lock->reader_mutex);
+	return (status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_acquire_write_lock
+ *              acpi_ut_release_write_lock
+ *
+ * PARAMETERS:  Lock                - Pointer to a valid RW lock
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Writer interfaces for reader/writer locks. Simply acquire or
+ *              release the writer mutex associated with the lock. Acquisition
+ *              of the lock is fully exclusive and will block all readers and
+ *              writers until it is released.
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ut_acquire_write_lock(struct acpi_rw_lock * lock)
+{
+	acpi_status status;
+
+	status = acpi_os_acquire_mutex(lock->writer_mutex, ACPI_WAIT_FOREVER);
+	return (status);
+}
+
+void acpi_ut_release_write_lock(struct acpi_rw_lock *lock)
+{
+
+	acpi_os_release_mutex(lock->writer_mutex);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utmath.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utmath.c
new file mode 100644
index 00000000..849280fe
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utmath.c
@@ -0,0 +1,324 @@
+/*******************************************************************************
+ *
+ * Module Name: utmath - Integer math support routines
+ *
+ ******************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+
+#define _COMPONENT          ACPI_UTILITIES
+ACPI_MODULE_NAME("utmath")
+
+/*
+ * Optional support for 64-bit double-precision integer divide. This code
+ * is configurable and is implemented in order to support 32-bit kernel
+ * environments where a 64-bit double-precision math library is not available.
+ *
+ * Support for a more normal 64-bit divide/modulo (with check for a divide-
+ * by-zero) appears after this optional section of code.
+ */
+#ifndef ACPI_USE_NATIVE_DIVIDE
+/* Structures used only for 64-bit divide */
+typedef struct uint64_struct {
+	u32 lo;
+	u32 hi;
+
+} uint64_struct;
+
+typedef union uint64_overlay {
+	u64 full;
+	struct uint64_struct part;
+
+} uint64_overlay;
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_short_divide
+ *
+ * PARAMETERS:  Dividend            - 64-bit dividend
+ *              Divisor             - 32-bit divisor
+ *              out_quotient        - Pointer to where the quotient is returned
+ *              out_remainder       - Pointer to where the remainder is returned
+ *
+ * RETURN:      Status (Checks for divide-by-zero)
+ *
+ * DESCRIPTION: Perform a short (maximum 64 bits divided by 32 bits)
+ *              divide and modulo.  The result is a 64-bit quotient and a
+ *              32-bit remainder.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ut_short_divide(u64 dividend,
+		     u32 divisor, u64 *out_quotient, u32 *out_remainder)
+{
+	union uint64_overlay dividend_ovl;
+	union uint64_overlay quotient;
+	u32 remainder32;
+
+	ACPI_FUNCTION_TRACE(ut_short_divide);
+
+	/* Always check for a zero divisor */
+
+	if (divisor == 0) {
+		ACPI_ERROR((AE_INFO, "Divide by zero"));
+		return_ACPI_STATUS(AE_AML_DIVIDE_BY_ZERO);
+	}
+
+	dividend_ovl.full = dividend;
+
+	/*
+	 * The quotient is 64 bits, the remainder is always 32 bits,
+	 * and is generated by the second divide.
+	 */
+	ACPI_DIV_64_BY_32(0, dividend_ovl.part.hi, divisor,
+			  quotient.part.hi, remainder32);
+	ACPI_DIV_64_BY_32(remainder32, dividend_ovl.part.lo, divisor,
+			  quotient.part.lo, remainder32);
+
+	/* Return only what was requested */
+
+	if (out_quotient) {
+		*out_quotient = quotient.full;
+	}
+	if (out_remainder) {
+		*out_remainder = remainder32;
+	}
+
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_divide
+ *
+ * PARAMETERS:  in_dividend         - Dividend
+ *              in_divisor          - Divisor
+ *              out_quotient        - Pointer to where the quotient is returned
+ *              out_remainder       - Pointer to where the remainder is returned
+ *
+ * RETURN:      Status (Checks for divide-by-zero)
+ *
+ * DESCRIPTION: Perform a divide and modulo.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ut_divide(u64 in_dividend,
+	       u64 in_divisor, u64 *out_quotient, u64 *out_remainder)
+{
+	union uint64_overlay dividend;
+	union uint64_overlay divisor;
+	union uint64_overlay quotient;
+	union uint64_overlay remainder;
+	union uint64_overlay normalized_dividend;
+	union uint64_overlay normalized_divisor;
+	u32 partial1;
+	union uint64_overlay partial2;
+	union uint64_overlay partial3;
+
+	ACPI_FUNCTION_TRACE(ut_divide);
+
+	/* Always check for a zero divisor */
+
+	if (in_divisor == 0) {
+		ACPI_ERROR((AE_INFO, "Divide by zero"));
+		return_ACPI_STATUS(AE_AML_DIVIDE_BY_ZERO);
+	}
+
+	divisor.full = in_divisor;
+	dividend.full = in_dividend;
+	if (divisor.part.hi == 0) {
+		/*
+		 * 1) Simplest case is where the divisor is 32 bits, we can
+		 * just do two divides
+		 */
+		remainder.part.hi = 0;
+
+		/*
+		 * The quotient is 64 bits, the remainder is always 32 bits,
+		 * and is generated by the second divide.
+		 */
+		ACPI_DIV_64_BY_32(0, dividend.part.hi, divisor.part.lo,
+				  quotient.part.hi, partial1);
+		ACPI_DIV_64_BY_32(partial1, dividend.part.lo, divisor.part.lo,
+				  quotient.part.lo, remainder.part.lo);
+	}
+
+	else {
+		/*
+		 * 2) The general case where the divisor is a full 64 bits
+		 * is more difficult
+		 */
+		quotient.part.hi = 0;
+		normalized_dividend = dividend;
+		normalized_divisor = divisor;
+
+		/* Normalize the operands (shift until the divisor is < 32 bits) */
+
+		do {
+			ACPI_SHIFT_RIGHT_64(normalized_divisor.part.hi,
+					    normalized_divisor.part.lo);
+			ACPI_SHIFT_RIGHT_64(normalized_dividend.part.hi,
+					    normalized_dividend.part.lo);
+
+		} while (normalized_divisor.part.hi != 0);
+
+		/* Partial divide */
+
+		ACPI_DIV_64_BY_32(normalized_dividend.part.hi,
+				  normalized_dividend.part.lo,
+				  normalized_divisor.part.lo,
+				  quotient.part.lo, partial1);
+
+		/*
+		 * The quotient is always 32 bits, and simply requires adjustment.
+		 * The 64-bit remainder must be generated.
+		 */
+		partial1 = quotient.part.lo * divisor.part.hi;
+		partial2.full = (u64)quotient.part.lo * divisor.part.lo;
+		partial3.full = (u64)partial2.part.hi + partial1;
+
+		remainder.part.hi = partial3.part.lo;
+		remainder.part.lo = partial2.part.lo;
+
+		if (partial3.part.hi == 0) {
+			if (partial3.part.lo >= dividend.part.hi) {
+				if (partial3.part.lo == dividend.part.hi) {
+					if (partial2.part.lo > dividend.part.lo) {
+						quotient.part.lo--;
+						remainder.full -= divisor.full;
+					}
+				} else {
+					quotient.part.lo--;
+					remainder.full -= divisor.full;
+				}
+			}
+
+			remainder.full = remainder.full - dividend.full;
+			remainder.part.hi = (u32)-((s32) remainder.part.hi);
+			remainder.part.lo = (u32)-((s32) remainder.part.lo);
+
+			if (remainder.part.lo) {
+				remainder.part.hi--;
+			}
+		}
+	}
+
+	/* Return only what was requested */
+
+	if (out_quotient) {
+		*out_quotient = quotient.full;
+	}
+	if (out_remainder) {
+		*out_remainder = remainder.full;
+	}
+
+	return_ACPI_STATUS(AE_OK);
+}
+
+#else
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_short_divide, acpi_ut_divide
+ *
+ * PARAMETERS:  See function headers above
+ *
+ * DESCRIPTION: Native versions of the ut_divide functions. Use these if either
+ *              1) The target is a 64-bit platform and therefore 64-bit
+ *                 integer math is supported directly by the machine.
+ *              2) The target is a 32-bit or 16-bit platform, and the
+ *                 double-precision integer math library is available to
+ *                 perform the divide.
+ *
+ ******************************************************************************/
+acpi_status
+acpi_ut_short_divide(u64 in_dividend,
+		     u32 divisor, u64 *out_quotient, u32 *out_remainder)
+{
+
+	ACPI_FUNCTION_TRACE(ut_short_divide);
+
+	/* Always check for a zero divisor */
+
+	if (divisor == 0) {
+		ACPI_ERROR((AE_INFO, "Divide by zero"));
+		return_ACPI_STATUS(AE_AML_DIVIDE_BY_ZERO);
+	}
+
+	/* Return only what was requested */
+
+	if (out_quotient) {
+		*out_quotient = in_dividend / divisor;
+	}
+	if (out_remainder) {
+		*out_remainder = (u32)(in_dividend % divisor);
+	}
+
+	return_ACPI_STATUS(AE_OK);
+}
+
+acpi_status
+acpi_ut_divide(u64 in_dividend,
+	       u64 in_divisor, u64 *out_quotient, u64 *out_remainder)
+{
+	ACPI_FUNCTION_TRACE(ut_divide);
+
+	/* Always check for a zero divisor */
+
+	if (in_divisor == 0) {
+		ACPI_ERROR((AE_INFO, "Divide by zero"));
+		return_ACPI_STATUS(AE_AML_DIVIDE_BY_ZERO);
+	}
+
+	/* Return only what was requested */
+
+	if (out_quotient) {
+		*out_quotient = in_dividend / in_divisor;
+	}
+	if (out_remainder) {
+		*out_remainder = in_dividend % in_divisor;
+	}
+
+	return_ACPI_STATUS(AE_OK);
+}
+
+#endif
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utmisc.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utmisc.c
new file mode 100644
index 00000000..31411186
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utmisc.c
@@ -0,0 +1,1134 @@
+/*******************************************************************************
+ *
+ * Module Name: utmisc - common utility procedures
+ *
+ ******************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acnamesp.h"
+
+#define _COMPONENT          ACPI_UTILITIES
+ACPI_MODULE_NAME("utmisc")
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_validate_exception
+ *
+ * PARAMETERS:  Status       - The acpi_status code to be formatted
+ *
+ * RETURN:      A string containing the exception text. NULL if exception is
+ *              not valid.
+ *
+ * DESCRIPTION: This function validates and translates an ACPI exception into
+ *              an ASCII string.
+ *
+ ******************************************************************************/
+const char *acpi_ut_validate_exception(acpi_status status)
+{
+	u32 sub_status;
+	const char *exception = NULL;
+
+	ACPI_FUNCTION_ENTRY();
+
+	/*
+	 * Status is composed of two parts, a "type" and an actual code
+	 */
+	sub_status = (status & ~AE_CODE_MASK);
+
+	switch (status & AE_CODE_MASK) {
+	case AE_CODE_ENVIRONMENTAL:
+
+		if (sub_status <= AE_CODE_ENV_MAX) {
+			exception = acpi_gbl_exception_names_env[sub_status];
+		}
+		break;
+
+	case AE_CODE_PROGRAMMER:
+
+		if (sub_status <= AE_CODE_PGM_MAX) {
+			exception = acpi_gbl_exception_names_pgm[sub_status];
+		}
+		break;
+
+	case AE_CODE_ACPI_TABLES:
+
+		if (sub_status <= AE_CODE_TBL_MAX) {
+			exception = acpi_gbl_exception_names_tbl[sub_status];
+		}
+		break;
+
+	case AE_CODE_AML:
+
+		if (sub_status <= AE_CODE_AML_MAX) {
+			exception = acpi_gbl_exception_names_aml[sub_status];
+		}
+		break;
+
+	case AE_CODE_CONTROL:
+
+		if (sub_status <= AE_CODE_CTRL_MAX) {
+			exception = acpi_gbl_exception_names_ctrl[sub_status];
+		}
+		break;
+
+	default:
+		break;
+	}
+
+	return (ACPI_CAST_PTR(const char, exception));
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_is_pci_root_bridge
+ *
+ * PARAMETERS:  Id              - The HID/CID in string format
+ *
+ * RETURN:      TRUE if the Id is a match for a PCI/PCI-Express Root Bridge
+ *
+ * DESCRIPTION: Determine if the input ID is a PCI Root Bridge ID.
+ *
+ ******************************************************************************/
+
+u8 acpi_ut_is_pci_root_bridge(char *id)
+{
+
+	/*
+	 * Check if this is a PCI root bridge.
+	 * ACPI 3.0+: check for a PCI Express root also.
+	 */
+	if (!(ACPI_STRCMP(id,
+			  PCI_ROOT_HID_STRING)) ||
+	    !(ACPI_STRCMP(id, PCI_EXPRESS_ROOT_HID_STRING))) {
+		return (TRUE);
+	}
+
+	return (FALSE);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_is_aml_table
+ *
+ * PARAMETERS:  Table               - An ACPI table
+ *
+ * RETURN:      TRUE if table contains executable AML; FALSE otherwise
+ *
+ * DESCRIPTION: Check ACPI Signature for a table that contains AML code.
+ *              Currently, these are DSDT,SSDT,PSDT. All other table types are
+ *              data tables that do not contain AML code.
+ *
+ ******************************************************************************/
+
+u8 acpi_ut_is_aml_table(struct acpi_table_header *table)
+{
+
+	/* These are the only tables that contain executable AML */
+
+	if (ACPI_COMPARE_NAME(table->signature, ACPI_SIG_DSDT) ||
+	    ACPI_COMPARE_NAME(table->signature, ACPI_SIG_PSDT) ||
+	    ACPI_COMPARE_NAME(table->signature, ACPI_SIG_SSDT)) {
+		return (TRUE);
+	}
+
+	return (FALSE);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_allocate_owner_id
+ *
+ * PARAMETERS:  owner_id        - Where the new owner ID is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Allocate a table or method owner ID. The owner ID is used to
+ *              track objects created by the table or method, to be deleted
+ *              when the method exits or the table is unloaded.
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ut_allocate_owner_id(acpi_owner_id * owner_id)
+{
+	u32 i;
+	u32 j;
+	u32 k;
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(ut_allocate_owner_id);
+
+	/* Guard against multiple allocations of ID to the same location */
+
+	if (*owner_id) {
+		ACPI_ERROR((AE_INFO, "Owner ID [0x%2.2X] already exists",
+			    *owner_id));
+		return_ACPI_STATUS(AE_ALREADY_EXISTS);
+	}
+
+	/* Mutex for the global ID mask */
+
+	status = acpi_ut_acquire_mutex(ACPI_MTX_CACHES);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/*
+	 * Find a free owner ID, cycle through all possible IDs on repeated
+	 * allocations. (ACPI_NUM_OWNERID_MASKS + 1) because first index may have
+	 * to be scanned twice.
+	 */
+	for (i = 0, j = acpi_gbl_last_owner_id_index;
+	     i < (ACPI_NUM_OWNERID_MASKS + 1); i++, j++) {
+		if (j >= ACPI_NUM_OWNERID_MASKS) {
+			j = 0;	/* Wraparound to start of mask array */
+		}
+
+		for (k = acpi_gbl_next_owner_id_offset; k < 32; k++) {
+			if (acpi_gbl_owner_id_mask[j] == ACPI_UINT32_MAX) {
+
+				/* There are no free IDs in this mask */
+
+				break;
+			}
+
+			if (!(acpi_gbl_owner_id_mask[j] & (1 << k))) {
+				/*
+				 * Found a free ID. The actual ID is the bit index plus one,
+				 * making zero an invalid Owner ID. Save this as the last ID
+				 * allocated and update the global ID mask.
+				 */
+				acpi_gbl_owner_id_mask[j] |= (1 << k);
+
+				acpi_gbl_last_owner_id_index = (u8)j;
+				acpi_gbl_next_owner_id_offset = (u8)(k + 1);
+
+				/*
+				 * Construct encoded ID from the index and bit position
+				 *
+				 * Note: Last [j].k (bit 255) is never used and is marked
+				 * permanently allocated (prevents +1 overflow)
+				 */
+				*owner_id =
+				    (acpi_owner_id) ((k + 1) + ACPI_MUL_32(j));
+
+				ACPI_DEBUG_PRINT((ACPI_DB_VALUES,
+						  "Allocated OwnerId: %2.2X\n",
+						  (unsigned int)*owner_id));
+				goto exit;
+			}
+		}
+
+		acpi_gbl_next_owner_id_offset = 0;
+	}
+
+	/*
+	 * All owner_ids have been allocated. This typically should
+	 * not happen since the IDs are reused after deallocation. The IDs are
+	 * allocated upon table load (one per table) and method execution, and
+	 * they are released when a table is unloaded or a method completes
+	 * execution.
+	 *
+	 * If this error happens, there may be very deep nesting of invoked control
+	 * methods, or there may be a bug where the IDs are not released.
+	 */
+	status = AE_OWNER_ID_LIMIT;
+	ACPI_ERROR((AE_INFO,
+		    "Could not allocate new OwnerId (255 max), AE_OWNER_ID_LIMIT"));
+
+      exit:
+	(void)acpi_ut_release_mutex(ACPI_MTX_CACHES);
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_release_owner_id
+ *
+ * PARAMETERS:  owner_id_ptr        - Pointer to a previously allocated owner_iD
+ *
+ * RETURN:      None. No error is returned because we are either exiting a
+ *              control method or unloading a table. Either way, we would
+ *              ignore any error anyway.
+ *
+ * DESCRIPTION: Release a table or method owner ID.  Valid IDs are 1 - 255
+ *
+ ******************************************************************************/
+
+void acpi_ut_release_owner_id(acpi_owner_id * owner_id_ptr)
+{
+	acpi_owner_id owner_id = *owner_id_ptr;
+	acpi_status status;
+	u32 index;
+	u32 bit;
+
+	ACPI_FUNCTION_TRACE_U32(ut_release_owner_id, owner_id);
+
+	/* Always clear the input owner_id (zero is an invalid ID) */
+
+	*owner_id_ptr = 0;
+
+	/* Zero is not a valid owner_iD */
+
+	if (owner_id == 0) {
+		ACPI_ERROR((AE_INFO, "Invalid OwnerId: 0x%2.2X", owner_id));
+		return_VOID;
+	}
+
+	/* Mutex for the global ID mask */
+
+	status = acpi_ut_acquire_mutex(ACPI_MTX_CACHES);
+	if (ACPI_FAILURE(status)) {
+		return_VOID;
+	}
+
+	/* Normalize the ID to zero */
+
+	owner_id--;
+
+	/* Decode ID to index/offset pair */
+
+	index = ACPI_DIV_32(owner_id);
+	bit = 1 << ACPI_MOD_32(owner_id);
+
+	/* Free the owner ID only if it is valid */
+
+	if (acpi_gbl_owner_id_mask[index] & bit) {
+		acpi_gbl_owner_id_mask[index] ^= bit;
+	} else {
+		ACPI_ERROR((AE_INFO,
+			    "Release of non-allocated OwnerId: 0x%2.2X",
+			    owner_id + 1));
+	}
+
+	(void)acpi_ut_release_mutex(ACPI_MTX_CACHES);
+	return_VOID;
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_strupr (strupr)
+ *
+ * PARAMETERS:  src_string      - The source string to convert
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Convert string to uppercase
+ *
+ * NOTE: This is not a POSIX function, so it appears here, not in utclib.c
+ *
+ ******************************************************************************/
+
+void acpi_ut_strupr(char *src_string)
+{
+	char *string;
+
+	ACPI_FUNCTION_ENTRY();
+
+	if (!src_string) {
+		return;
+	}
+
+	/* Walk entire string, uppercasing the letters */
+
+	for (string = src_string; *string; string++) {
+		*string = (char)ACPI_TOUPPER(*string);
+	}
+
+	return;
+}
+
+#ifdef ACPI_ASL_COMPILER
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_strlwr (strlwr)
+ *
+ * PARAMETERS:  src_string      - The source string to convert
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Convert string to lowercase
+ *
+ * NOTE: This is not a POSIX function, so it appears here, not in utclib.c
+ *
+ ******************************************************************************/
+
+void acpi_ut_strlwr(char *src_string)
+{
+	char *string;
+
+	ACPI_FUNCTION_ENTRY();
+
+	if (!src_string) {
+		return;
+	}
+
+	/* Walk entire string, lowercasing the letters */
+
+	for (string = src_string; *string; string++) {
+		*string = (char)ACPI_TOLOWER(*string);
+	}
+
+	return;
+}
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_stricmp
+ *
+ * PARAMETERS:  String1             - first string to compare
+ *              String2             - second string to compare
+ *
+ * RETURN:      int that signifies string relationship. Zero means strings
+ *              are equal.
+ *
+ * DESCRIPTION: Implementation of the non-ANSI stricmp function (compare
+ *              strings with no case sensitivity)
+ *
+ ******************************************************************************/
+
+int acpi_ut_stricmp(char *string1, char *string2)
+{
+	int c1;
+	int c2;
+
+	do {
+		c1 = tolower((int)*string1);
+		c2 = tolower((int)*string2);
+
+		string1++;
+		string2++;
+	}
+	while ((c1 == c2) && (c1));
+
+	return (c1 - c2);
+}
+#endif
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_print_string
+ *
+ * PARAMETERS:  String          - Null terminated ASCII string
+ *              max_length      - Maximum output length
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Dump an ASCII string with support for ACPI-defined escape
+ *              sequences.
+ *
+ ******************************************************************************/
+
+void acpi_ut_print_string(char *string, u8 max_length)
+{
+	u32 i;
+
+	if (!string) {
+		acpi_os_printf("<\"NULL STRING PTR\">");
+		return;
+	}
+
+	acpi_os_printf("\"");
+	for (i = 0; string[i] && (i < max_length); i++) {
+
+		/* Escape sequences */
+
+		switch (string[i]) {
+		case 0x07:
+			acpi_os_printf("\\a");	/* BELL */
+			break;
+
+		case 0x08:
+			acpi_os_printf("\\b");	/* BACKSPACE */
+			break;
+
+		case 0x0C:
+			acpi_os_printf("\\f");	/* FORMFEED */
+			break;
+
+		case 0x0A:
+			acpi_os_printf("\\n");	/* LINEFEED */
+			break;
+
+		case 0x0D:
+			acpi_os_printf("\\r");	/* CARRIAGE RETURN */
+			break;
+
+		case 0x09:
+			acpi_os_printf("\\t");	/* HORIZONTAL TAB */
+			break;
+
+		case 0x0B:
+			acpi_os_printf("\\v");	/* VERTICAL TAB */
+			break;
+
+		case '\'':	/* Single Quote */
+		case '\"':	/* Double Quote */
+		case '\\':	/* Backslash */
+			acpi_os_printf("\\%c", (int)string[i]);
+			break;
+
+		default:
+
+			/* Check for printable character or hex escape */
+
+			if (ACPI_IS_PRINT(string[i])) {
+				/* This is a normal character */
+
+				acpi_os_printf("%c", (int)string[i]);
+			} else {
+				/* All others will be Hex escapes */
+
+				acpi_os_printf("\\x%2.2X", (s32) string[i]);
+			}
+			break;
+		}
+	}
+	acpi_os_printf("\"");
+
+	if (i == max_length && string[i]) {
+		acpi_os_printf("...");
+	}
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_dword_byte_swap
+ *
+ * PARAMETERS:  Value           - Value to be converted
+ *
+ * RETURN:      u32 integer with bytes swapped
+ *
+ * DESCRIPTION: Convert a 32-bit value to big-endian (swap the bytes)
+ *
+ ******************************************************************************/
+
+u32 acpi_ut_dword_byte_swap(u32 value)
+{
+	union {
+		u32 value;
+		u8 bytes[4];
+	} out;
+	union {
+		u32 value;
+		u8 bytes[4];
+	} in;
+
+	ACPI_FUNCTION_ENTRY();
+
+	in.value = value;
+
+	out.bytes[0] = in.bytes[3];
+	out.bytes[1] = in.bytes[2];
+	out.bytes[2] = in.bytes[1];
+	out.bytes[3] = in.bytes[0];
+
+	return (out.value);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_set_integer_width
+ *
+ * PARAMETERS:  Revision            From DSDT header
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Set the global integer bit width based upon the revision
+ *              of the DSDT.  For Revision 1 and 0, Integers are 32 bits.
+ *              For Revision 2 and above, Integers are 64 bits.  Yes, this
+ *              makes a difference.
+ *
+ ******************************************************************************/
+
+void acpi_ut_set_integer_width(u8 revision)
+{
+
+	if (revision < 2) {
+
+		/* 32-bit case */
+
+		acpi_gbl_integer_bit_width = 32;
+		acpi_gbl_integer_nybble_width = 8;
+		acpi_gbl_integer_byte_width = 4;
+	} else {
+		/* 64-bit case (ACPI 2.0+) */
+
+		acpi_gbl_integer_bit_width = 64;
+		acpi_gbl_integer_nybble_width = 16;
+		acpi_gbl_integer_byte_width = 8;
+	}
+}
+
+#ifdef ACPI_DEBUG_OUTPUT
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_display_init_pathname
+ *
+ * PARAMETERS:  Type                - Object type of the node
+ *              obj_handle          - Handle whose pathname will be displayed
+ *              Path                - Additional path string to be appended.
+ *                                      (NULL if no extra path)
+ *
+ * RETURN:      acpi_status
+ *
+ * DESCRIPTION: Display full pathname of an object, DEBUG ONLY
+ *
+ ******************************************************************************/
+
+void
+acpi_ut_display_init_pathname(u8 type,
+			      struct acpi_namespace_node *obj_handle,
+			      char *path)
+{
+	acpi_status status;
+	struct acpi_buffer buffer;
+
+	ACPI_FUNCTION_ENTRY();
+
+	/* Only print the path if the appropriate debug level is enabled */
+
+	if (!(acpi_dbg_level & ACPI_LV_INIT_NAMES)) {
+		return;
+	}
+
+	/* Get the full pathname to the node */
+
+	buffer.length = ACPI_ALLOCATE_LOCAL_BUFFER;
+	status = acpi_ns_handle_to_pathname(obj_handle, &buffer);
+	if (ACPI_FAILURE(status)) {
+		return;
+	}
+
+	/* Print what we're doing */
+
+	switch (type) {
+	case ACPI_TYPE_METHOD:
+		acpi_os_printf("Executing  ");
+		break;
+
+	default:
+		acpi_os_printf("Initializing ");
+		break;
+	}
+
+	/* Print the object type and pathname */
+
+	acpi_os_printf("%-12s %s",
+		       acpi_ut_get_type_name(type), (char *)buffer.pointer);
+
+	/* Extra path is used to append names like _STA, _INI, etc. */
+
+	if (path) {
+		acpi_os_printf(".%s", path);
+	}
+	acpi_os_printf("\n");
+
+	ACPI_FREE(buffer.pointer);
+}
+#endif
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_valid_acpi_char
+ *
+ * PARAMETERS:  Char            - The character to be examined
+ *              Position        - Byte position (0-3)
+ *
+ * RETURN:      TRUE if the character is valid, FALSE otherwise
+ *
+ * DESCRIPTION: Check for a valid ACPI character. Must be one of:
+ *              1) Upper case alpha
+ *              2) numeric
+ *              3) underscore
+ *
+ *              We allow a '!' as the last character because of the ASF! table
+ *
+ ******************************************************************************/
+
+u8 acpi_ut_valid_acpi_char(char character, u32 position)
+{
+
+	if (!((character >= 'A' && character <= 'Z') ||
+	      (character >= '0' && character <= '9') || (character == '_'))) {
+
+		/* Allow a '!' in the last position */
+
+		if (character == '!' && position == 3) {
+			return (TRUE);
+		}
+
+		return (FALSE);
+	}
+
+	return (TRUE);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_valid_acpi_name
+ *
+ * PARAMETERS:  Name            - The name to be examined
+ *
+ * RETURN:      TRUE if the name is valid, FALSE otherwise
+ *
+ * DESCRIPTION: Check for a valid ACPI name.  Each character must be one of:
+ *              1) Upper case alpha
+ *              2) numeric
+ *              3) underscore
+ *
+ ******************************************************************************/
+
+u8 acpi_ut_valid_acpi_name(u32 name)
+{
+	u32 i;
+
+	ACPI_FUNCTION_ENTRY();
+
+	for (i = 0; i < ACPI_NAME_SIZE; i++) {
+		if (!acpi_ut_valid_acpi_char
+		    ((ACPI_CAST_PTR(char, &name))[i], i)) {
+			return (FALSE);
+		}
+	}
+
+	return (TRUE);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_repair_name
+ *
+ * PARAMETERS:  Name            - The ACPI name to be repaired
+ *
+ * RETURN:      Repaired version of the name
+ *
+ * DESCRIPTION: Repair an ACPI name: Change invalid characters to '*' and
+ *              return the new name. NOTE: the Name parameter must reside in
+ *              read/write memory, cannot be a const.
+ *
+ * An ACPI Name must consist of valid ACPI characters. We will repair the name
+ * if necessary because we don't want to abort because of this, but we want
+ * all namespace names to be printable. A warning message is appropriate.
+ *
+ * This issue came up because there are in fact machines that exhibit
+ * this problem, and we want to be able to enable ACPI support for them,
+ * even though there are a few bad names.
+ *
+ ******************************************************************************/
+
+void acpi_ut_repair_name(char *name)
+{
+	u32 i;
+	u8 found_bad_char = FALSE;
+
+	ACPI_FUNCTION_NAME(ut_repair_name);
+
+	/* Check each character in the name */
+
+	for (i = 0; i < ACPI_NAME_SIZE; i++) {
+		if (acpi_ut_valid_acpi_char(name[i], i)) {
+			continue;
+		}
+
+		/*
+		 * Replace a bad character with something printable, yet technically
+		 * still invalid. This prevents any collisions with existing "good"
+		 * names in the namespace.
+		 */
+		name[i] = '*';
+		found_bad_char = TRUE;
+	}
+
+	if (found_bad_char) {
+
+		/* Report warning only if in strict mode or debug mode */
+
+		if (!acpi_gbl_enable_interpreter_slack) {
+			ACPI_WARNING((AE_INFO,
+				      "Found bad character(s) in name, repaired: [%4.4s]\n",
+				      name));
+		} else {
+			ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+					  "Found bad character(s) in name, repaired: [%4.4s]\n",
+					  name));
+		}
+	}
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_strtoul64
+ *
+ * PARAMETERS:  String          - Null terminated string
+ *              Base            - Radix of the string: 16 or ACPI_ANY_BASE;
+ *                                ACPI_ANY_BASE means 'in behalf of to_integer'
+ *              ret_integer     - Where the converted integer is returned
+ *
+ * RETURN:      Status and Converted value
+ *
+ * DESCRIPTION: Convert a string into an unsigned value. Performs either a
+ *              32-bit or 64-bit conversion, depending on the current mode
+ *              of the interpreter.
+ *              NOTE: Does not support Octal strings, not needed.
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ut_strtoul64(char *string, u32 base, u64 *ret_integer)
+{
+	u32 this_digit = 0;
+	u64 return_value = 0;
+	u64 quotient;
+	u64 dividend;
+	u32 to_integer_op = (base == ACPI_ANY_BASE);
+	u32 mode32 = (acpi_gbl_integer_byte_width == 4);
+	u8 valid_digits = 0;
+	u8 sign_of0x = 0;
+	u8 term = 0;
+
+	ACPI_FUNCTION_TRACE_STR(ut_stroul64, string);
+
+	switch (base) {
+	case ACPI_ANY_BASE:
+	case 16:
+		break;
+
+	default:
+		/* Invalid Base */
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	if (!string) {
+		goto error_exit;
+	}
+
+	/* Skip over any white space in the buffer */
+
+	while ((*string) && (ACPI_IS_SPACE(*string) || *string == '\t')) {
+		string++;
+	}
+
+	if (to_integer_op) {
+		/*
+		 * Base equal to ACPI_ANY_BASE means 'to_integer operation case'.
+		 * We need to determine if it is decimal or hexadecimal.
+		 */
+		if ((*string == '0') && (ACPI_TOLOWER(*(string + 1)) == 'x')) {
+			sign_of0x = 1;
+			base = 16;
+
+			/* Skip over the leading '0x' */
+			string += 2;
+		} else {
+			base = 10;
+		}
+	}
+
+	/* Any string left? Check that '0x' is not followed by white space. */
+
+	if (!(*string) || ACPI_IS_SPACE(*string) || *string == '\t') {
+		if (to_integer_op) {
+			goto error_exit;
+		} else {
+			goto all_done;
+		}
+	}
+
+	/*
+	 * Perform a 32-bit or 64-bit conversion, depending upon the current
+	 * execution mode of the interpreter
+	 */
+	dividend = (mode32) ? ACPI_UINT32_MAX : ACPI_UINT64_MAX;
+
+	/* Main loop: convert the string to a 32- or 64-bit integer */
+
+	while (*string) {
+		if (ACPI_IS_DIGIT(*string)) {
+
+			/* Convert ASCII 0-9 to Decimal value */
+
+			this_digit = ((u8)*string) - '0';
+		} else if (base == 10) {
+
+			/* Digit is out of range; possible in to_integer case only */
+
+			term = 1;
+		} else {
+			this_digit = (u8)ACPI_TOUPPER(*string);
+			if (ACPI_IS_XDIGIT((char)this_digit)) {
+
+				/* Convert ASCII Hex char to value */
+
+				this_digit = this_digit - 'A' + 10;
+			} else {
+				term = 1;
+			}
+		}
+
+		if (term) {
+			if (to_integer_op) {
+				goto error_exit;
+			} else {
+				break;
+			}
+		} else if ((valid_digits == 0) && (this_digit == 0)
+			   && !sign_of0x) {
+
+			/* Skip zeros */
+			string++;
+			continue;
+		}
+
+		valid_digits++;
+
+		if (sign_of0x
+		    && ((valid_digits > 16)
+			|| ((valid_digits > 8) && mode32))) {
+			/*
+			 * This is to_integer operation case.
+			 * No any restrictions for string-to-integer conversion,
+			 * see ACPI spec.
+			 */
+			goto error_exit;
+		}
+
+		/* Divide the digit into the correct position */
+
+		(void)acpi_ut_short_divide((dividend - (u64)this_digit),
+					   base, &quotient, NULL);
+
+		if (return_value > quotient) {
+			if (to_integer_op) {
+				goto error_exit;
+			} else {
+				break;
+			}
+		}
+
+		return_value *= base;
+		return_value += this_digit;
+		string++;
+	}
+
+	/* All done, normal exit */
+
+      all_done:
+
+	ACPI_DEBUG_PRINT((ACPI_DB_EXEC, "Converted value: %8.8X%8.8X\n",
+			  ACPI_FORMAT_UINT64(return_value)));
+
+	*ret_integer = return_value;
+	return_ACPI_STATUS(AE_OK);
+
+      error_exit:
+	/* Base was set/validated above */
+
+	if (base == 10) {
+		return_ACPI_STATUS(AE_BAD_DECIMAL_CONSTANT);
+	} else {
+		return_ACPI_STATUS(AE_BAD_HEX_CONSTANT);
+	}
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_create_update_state_and_push
+ *
+ * PARAMETERS:  Object          - Object to be added to the new state
+ *              Action          - Increment/Decrement
+ *              state_list      - List the state will be added to
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Create a new state and push it
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ut_create_update_state_and_push(union acpi_operand_object *object,
+				     u16 action,
+				     union acpi_generic_state **state_list)
+{
+	union acpi_generic_state *state;
+
+	ACPI_FUNCTION_ENTRY();
+
+	/* Ignore null objects; these are expected */
+
+	if (!object) {
+		return (AE_OK);
+	}
+
+	state = acpi_ut_create_update_state(object, action);
+	if (!state) {
+		return (AE_NO_MEMORY);
+	}
+
+	acpi_ut_push_generic_state(state_list, state);
+	return (AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_walk_package_tree
+ *
+ * PARAMETERS:  source_object       - The package to walk
+ *              target_object       - Target object (if package is being copied)
+ *              walk_callback       - Called once for each package element
+ *              Context             - Passed to the callback function
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Walk through a package
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ut_walk_package_tree(union acpi_operand_object *source_object,
+			  void *target_object,
+			  acpi_pkg_callback walk_callback, void *context)
+{
+	acpi_status status = AE_OK;
+	union acpi_generic_state *state_list = NULL;
+	union acpi_generic_state *state;
+	u32 this_index;
+	union acpi_operand_object *this_source_obj;
+
+	ACPI_FUNCTION_TRACE(ut_walk_package_tree);
+
+	state = acpi_ut_create_pkg_state(source_object, target_object, 0);
+	if (!state) {
+		return_ACPI_STATUS(AE_NO_MEMORY);
+	}
+
+	while (state) {
+
+		/* Get one element of the package */
+
+		this_index = state->pkg.index;
+		this_source_obj = (union acpi_operand_object *)
+		    state->pkg.source_object->package.elements[this_index];
+
+		/*
+		 * Check for:
+		 * 1) An uninitialized package element.  It is completely
+		 *    legal to declare a package and leave it uninitialized
+		 * 2) Not an internal object - can be a namespace node instead
+		 * 3) Any type other than a package.  Packages are handled in else
+		 *    case below.
+		 */
+		if ((!this_source_obj) ||
+		    (ACPI_GET_DESCRIPTOR_TYPE(this_source_obj) !=
+		     ACPI_DESC_TYPE_OPERAND)
+		    || (this_source_obj->common.type != ACPI_TYPE_PACKAGE)) {
+			status =
+			    walk_callback(ACPI_COPY_TYPE_SIMPLE,
+					  this_source_obj, state, context);
+			if (ACPI_FAILURE(status)) {
+				return_ACPI_STATUS(status);
+			}
+
+			state->pkg.index++;
+			while (state->pkg.index >=
+			       state->pkg.source_object->package.count) {
+				/*
+				 * We've handled all of the objects at this level,  This means
+				 * that we have just completed a package.  That package may
+				 * have contained one or more packages itself.
+				 *
+				 * Delete this state and pop the previous state (package).
+				 */
+				acpi_ut_delete_generic_state(state);
+				state = acpi_ut_pop_generic_state(&state_list);
+
+				/* Finished when there are no more states */
+
+				if (!state) {
+					/*
+					 * We have handled all of the objects in the top level
+					 * package just add the length of the package objects
+					 * and exit
+					 */
+					return_ACPI_STATUS(AE_OK);
+				}
+
+				/*
+				 * Go back up a level and move the index past the just
+				 * completed package object.
+				 */
+				state->pkg.index++;
+			}
+		} else {
+			/* This is a subobject of type package */
+
+			status =
+			    walk_callback(ACPI_COPY_TYPE_PACKAGE,
+					  this_source_obj, state, context);
+			if (ACPI_FAILURE(status)) {
+				return_ACPI_STATUS(status);
+			}
+
+			/*
+			 * Push the current state and create a new one
+			 * The callback above returned a new target package object.
+			 */
+			acpi_ut_push_generic_state(&state_list, state);
+			state = acpi_ut_create_pkg_state(this_source_obj,
+							 state->pkg.
+							 this_target_obj, 0);
+			if (!state) {
+
+				/* Free any stacked Update State objects */
+
+				while (state_list) {
+					state =
+					    acpi_ut_pop_generic_state
+					    (&state_list);
+					acpi_ut_delete_generic_state(state);
+				}
+				return_ACPI_STATUS(AE_NO_MEMORY);
+			}
+		}
+	}
+
+	/* We should never get here */
+
+	return_ACPI_STATUS(AE_AML_INTERNAL);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utmutex.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utmutex.c
new file mode 100644
index 00000000..8e45c106
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utmutex.c
@@ -0,0 +1,351 @@
+/*******************************************************************************
+ *
+ * Module Name: utmutex - local mutex support
+ *
+ ******************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+
+#define _COMPONENT          ACPI_UTILITIES
+ACPI_MODULE_NAME("utmutex")
+
+/* Local prototypes */
+static acpi_status acpi_ut_create_mutex(acpi_mutex_handle mutex_id);
+
+static void acpi_ut_delete_mutex(acpi_mutex_handle mutex_id);
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_mutex_initialize
+ *
+ * PARAMETERS:  None.
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Create the system mutex objects. This includes mutexes,
+ *              spin locks, and reader/writer locks.
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ut_mutex_initialize(void)
+{
+	u32 i;
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(ut_mutex_initialize);
+
+	/* Create each of the predefined mutex objects */
+
+	for (i = 0; i < ACPI_NUM_MUTEX; i++) {
+		status = acpi_ut_create_mutex(i);
+		if (ACPI_FAILURE(status)) {
+			return_ACPI_STATUS(status);
+		}
+	}
+
+	/* Create the spinlocks for use at interrupt level */
+
+	status = acpi_os_create_lock(&acpi_gbl_gpe_lock);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	status = acpi_os_create_lock(&acpi_gbl_hardware_lock);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/* Mutex for _OSI support */
+	status = acpi_os_create_mutex(&acpi_gbl_osi_mutex);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/* Create the reader/writer lock for namespace access */
+
+	status = acpi_ut_create_rw_lock(&acpi_gbl_namespace_rw_lock);
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_mutex_terminate
+ *
+ * PARAMETERS:  None.
+ *
+ * RETURN:      None.
+ *
+ * DESCRIPTION: Delete all of the system mutex objects. This includes mutexes,
+ *              spin locks, and reader/writer locks.
+ *
+ ******************************************************************************/
+
+void acpi_ut_mutex_terminate(void)
+{
+	u32 i;
+
+	ACPI_FUNCTION_TRACE(ut_mutex_terminate);
+
+	/* Delete each predefined mutex object */
+
+	for (i = 0; i < ACPI_NUM_MUTEX; i++) {
+		acpi_ut_delete_mutex(i);
+	}
+
+	acpi_os_delete_mutex(acpi_gbl_osi_mutex);
+
+	/* Delete the spinlocks */
+
+	acpi_os_delete_lock(acpi_gbl_gpe_lock);
+	acpi_os_delete_lock(acpi_gbl_hardware_lock);
+
+	/* Delete the reader/writer lock */
+
+	acpi_ut_delete_rw_lock(&acpi_gbl_namespace_rw_lock);
+	return_VOID;
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_create_mutex
+ *
+ * PARAMETERS:  mutex_iD        - ID of the mutex to be created
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Create a mutex object.
+ *
+ ******************************************************************************/
+
+static acpi_status acpi_ut_create_mutex(acpi_mutex_handle mutex_id)
+{
+	acpi_status status = AE_OK;
+
+	ACPI_FUNCTION_TRACE_U32(ut_create_mutex, mutex_id);
+
+	if (!acpi_gbl_mutex_info[mutex_id].mutex) {
+		status =
+		    acpi_os_create_mutex(&acpi_gbl_mutex_info[mutex_id].mutex);
+		acpi_gbl_mutex_info[mutex_id].thread_id =
+		    ACPI_MUTEX_NOT_ACQUIRED;
+		acpi_gbl_mutex_info[mutex_id].use_count = 0;
+	}
+
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_delete_mutex
+ *
+ * PARAMETERS:  mutex_iD        - ID of the mutex to be deleted
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Delete a mutex object.
+ *
+ ******************************************************************************/
+
+static void acpi_ut_delete_mutex(acpi_mutex_handle mutex_id)
+{
+
+	ACPI_FUNCTION_TRACE_U32(ut_delete_mutex, mutex_id);
+
+	acpi_os_delete_mutex(acpi_gbl_mutex_info[mutex_id].mutex);
+
+	acpi_gbl_mutex_info[mutex_id].mutex = NULL;
+	acpi_gbl_mutex_info[mutex_id].thread_id = ACPI_MUTEX_NOT_ACQUIRED;
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_acquire_mutex
+ *
+ * PARAMETERS:  mutex_iD        - ID of the mutex to be acquired
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Acquire a mutex object.
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ut_acquire_mutex(acpi_mutex_handle mutex_id)
+{
+	acpi_status status;
+	acpi_thread_id this_thread_id;
+
+	ACPI_FUNCTION_NAME(ut_acquire_mutex);
+
+	if (mutex_id > ACPI_MAX_MUTEX) {
+		return (AE_BAD_PARAMETER);
+	}
+
+	this_thread_id = acpi_os_get_thread_id();
+
+#ifdef ACPI_MUTEX_DEBUG
+	{
+		u32 i;
+		/*
+		 * Mutex debug code, for internal debugging only.
+		 *
+		 * Deadlock prevention.  Check if this thread owns any mutexes of value
+		 * greater than or equal to this one.  If so, the thread has violated
+		 * the mutex ordering rule.  This indicates a coding error somewhere in
+		 * the ACPI subsystem code.
+		 */
+		for (i = mutex_id; i < ACPI_NUM_MUTEX; i++) {
+			if (acpi_gbl_mutex_info[i].thread_id == this_thread_id) {
+				if (i == mutex_id) {
+					ACPI_ERROR((AE_INFO,
+						    "Mutex [%s] already acquired by this thread [%u]",
+						    acpi_ut_get_mutex_name
+						    (mutex_id),
+						    (u32)this_thread_id));
+
+					return (AE_ALREADY_ACQUIRED);
+				}
+
+				ACPI_ERROR((AE_INFO,
+					    "Invalid acquire order: Thread %u owns [%s], wants [%s]",
+					    (u32)this_thread_id,
+					    acpi_ut_get_mutex_name(i),
+					    acpi_ut_get_mutex_name(mutex_id)));
+
+				return (AE_ACQUIRE_DEADLOCK);
+			}
+		}
+	}
+#endif
+
+	ACPI_DEBUG_PRINT((ACPI_DB_MUTEX,
+			  "Thread %u attempting to acquire Mutex [%s]\n",
+			  (u32)this_thread_id,
+			  acpi_ut_get_mutex_name(mutex_id)));
+
+	status = acpi_os_acquire_mutex(acpi_gbl_mutex_info[mutex_id].mutex,
+				       ACPI_WAIT_FOREVER);
+	if (ACPI_SUCCESS(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_MUTEX,
+				  "Thread %u acquired Mutex [%s]\n",
+				  (u32)this_thread_id,
+				  acpi_ut_get_mutex_name(mutex_id)));
+
+		acpi_gbl_mutex_info[mutex_id].use_count++;
+		acpi_gbl_mutex_info[mutex_id].thread_id = this_thread_id;
+	} else {
+		ACPI_EXCEPTION((AE_INFO, status,
+				"Thread %u could not acquire Mutex [0x%X]",
+				(u32)this_thread_id, mutex_id));
+	}
+
+	return (status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_release_mutex
+ *
+ * PARAMETERS:  mutex_iD        - ID of the mutex to be released
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Release a mutex object.
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ut_release_mutex(acpi_mutex_handle mutex_id)
+{
+	ACPI_FUNCTION_NAME(ut_release_mutex);
+
+	ACPI_DEBUG_PRINT((ACPI_DB_MUTEX, "Thread %u releasing Mutex [%s]\n",
+			  (u32)acpi_os_get_thread_id(),
+			  acpi_ut_get_mutex_name(mutex_id)));
+
+	if (mutex_id > ACPI_MAX_MUTEX) {
+		return (AE_BAD_PARAMETER);
+	}
+
+	/*
+	 * Mutex must be acquired in order to release it!
+	 */
+	if (acpi_gbl_mutex_info[mutex_id].thread_id == ACPI_MUTEX_NOT_ACQUIRED) {
+		ACPI_ERROR((AE_INFO,
+			    "Mutex [0x%X] is not acquired, cannot release",
+			    mutex_id));
+
+		return (AE_NOT_ACQUIRED);
+	}
+#ifdef ACPI_MUTEX_DEBUG
+	{
+		u32 i;
+		/*
+		 * Mutex debug code, for internal debugging only.
+		 *
+		 * Deadlock prevention.  Check if this thread owns any mutexes of value
+		 * greater than this one.  If so, the thread has violated the mutex
+		 * ordering rule.  This indicates a coding error somewhere in
+		 * the ACPI subsystem code.
+		 */
+		for (i = mutex_id; i < ACPI_NUM_MUTEX; i++) {
+			if (acpi_gbl_mutex_info[i].thread_id ==
+			    acpi_os_get_thread_id()) {
+				if (i == mutex_id) {
+					continue;
+				}
+
+				ACPI_ERROR((AE_INFO,
+					    "Invalid release order: owns [%s], releasing [%s]",
+					    acpi_ut_get_mutex_name(i),
+					    acpi_ut_get_mutex_name(mutex_id)));
+
+				return (AE_RELEASE_DEADLOCK);
+			}
+		}
+	}
+#endif
+
+	/* Mark unlocked FIRST */
+
+	acpi_gbl_mutex_info[mutex_id].thread_id = ACPI_MUTEX_NOT_ACQUIRED;
+
+	acpi_os_release_mutex(acpi_gbl_mutex_info[mutex_id].mutex);
+	return (AE_OK);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utobject.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utobject.c
new file mode 100644
index 00000000..dad18ace
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utobject.c
@@ -0,0 +1,707 @@
+/******************************************************************************
+ *
+ * Module Name: utobject - ACPI object create/delete/size/cache routines
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acnamesp.h"
+
+#define _COMPONENT          ACPI_UTILITIES
+ACPI_MODULE_NAME("utobject")
+
+/* Local prototypes */
+static acpi_status
+acpi_ut_get_simple_object_size(union acpi_operand_object *obj,
+			       acpi_size * obj_length);
+
+static acpi_status
+acpi_ut_get_package_object_size(union acpi_operand_object *obj,
+				acpi_size * obj_length);
+
+static acpi_status
+acpi_ut_get_element_length(u8 object_type,
+			   union acpi_operand_object *source_object,
+			   union acpi_generic_state *state, void *context);
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_create_internal_object_dbg
+ *
+ * PARAMETERS:  module_name         - Source file name of caller
+ *              line_number         - Line number of caller
+ *              component_id        - Component type of caller
+ *              Type                - ACPI Type of the new object
+ *
+ * RETURN:      A new internal object, null on failure
+ *
+ * DESCRIPTION: Create and initialize a new internal object.
+ *
+ * NOTE:        We always allocate the worst-case object descriptor because
+ *              these objects are cached, and we want them to be
+ *              one-size-satisifies-any-request.  This in itself may not be
+ *              the most memory efficient, but the efficiency of the object
+ *              cache should more than make up for this!
+ *
+ ******************************************************************************/
+
+union acpi_operand_object *acpi_ut_create_internal_object_dbg(const char
+							      *module_name,
+							      u32 line_number,
+							      u32 component_id,
+							      acpi_object_type
+							      type)
+{
+	union acpi_operand_object *object;
+	union acpi_operand_object *second_object;
+
+	ACPI_FUNCTION_TRACE_STR(ut_create_internal_object_dbg,
+				acpi_ut_get_type_name(type));
+
+	/* Allocate the raw object descriptor */
+
+	object =
+	    acpi_ut_allocate_object_desc_dbg(module_name, line_number,
+					     component_id);
+	if (!object) {
+		return_PTR(NULL);
+	}
+
+	switch (type) {
+	case ACPI_TYPE_REGION:
+	case ACPI_TYPE_BUFFER_FIELD:
+	case ACPI_TYPE_LOCAL_BANK_FIELD:
+
+		/* These types require a secondary object */
+
+		second_object = acpi_ut_allocate_object_desc_dbg(module_name,
+								 line_number,
+								 component_id);
+		if (!second_object) {
+			acpi_ut_delete_object_desc(object);
+			return_PTR(NULL);
+		}
+
+		second_object->common.type = ACPI_TYPE_LOCAL_EXTRA;
+		second_object->common.reference_count = 1;
+
+		/* Link the second object to the first */
+
+		object->common.next_object = second_object;
+		break;
+
+	default:
+		/* All others have no secondary object */
+		break;
+	}
+
+	/* Save the object type in the object descriptor */
+
+	object->common.type = (u8)type;
+
+	/* Init the reference count */
+
+	object->common.reference_count = 1;
+
+	/* Any per-type initialization should go here */
+
+	return_PTR(object);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_create_package_object
+ *
+ * PARAMETERS:  Count               - Number of package elements
+ *
+ * RETURN:      Pointer to a new Package object, null on failure
+ *
+ * DESCRIPTION: Create a fully initialized package object
+ *
+ ******************************************************************************/
+
+union acpi_operand_object *acpi_ut_create_package_object(u32 count)
+{
+	union acpi_operand_object *package_desc;
+	union acpi_operand_object **package_elements;
+
+	ACPI_FUNCTION_TRACE_U32(ut_create_package_object, count);
+
+	/* Create a new Package object */
+
+	package_desc = acpi_ut_create_internal_object(ACPI_TYPE_PACKAGE);
+	if (!package_desc) {
+		return_PTR(NULL);
+	}
+
+	/*
+	 * Create the element array. Count+1 allows the array to be null
+	 * terminated.
+	 */
+	package_elements = ACPI_ALLOCATE_ZEROED(((acpi_size) count +
+						 1) * sizeof(void *));
+	if (!package_elements) {
+		ACPI_FREE(package_desc);
+		return_PTR(NULL);
+	}
+
+	package_desc->package.count = count;
+	package_desc->package.elements = package_elements;
+	return_PTR(package_desc);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_create_integer_object
+ *
+ * PARAMETERS:  initial_value       - Initial value for the integer
+ *
+ * RETURN:      Pointer to a new Integer object, null on failure
+ *
+ * DESCRIPTION: Create an initialized integer object
+ *
+ ******************************************************************************/
+
+union acpi_operand_object *acpi_ut_create_integer_object(u64 initial_value)
+{
+	union acpi_operand_object *integer_desc;
+
+	ACPI_FUNCTION_TRACE(ut_create_integer_object);
+
+	/* Create and initialize a new integer object */
+
+	integer_desc = acpi_ut_create_internal_object(ACPI_TYPE_INTEGER);
+	if (!integer_desc) {
+		return_PTR(NULL);
+	}
+
+	integer_desc->integer.value = initial_value;
+	return_PTR(integer_desc);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_create_buffer_object
+ *
+ * PARAMETERS:  buffer_size            - Size of buffer to be created
+ *
+ * RETURN:      Pointer to a new Buffer object, null on failure
+ *
+ * DESCRIPTION: Create a fully initialized buffer object
+ *
+ ******************************************************************************/
+
+union acpi_operand_object *acpi_ut_create_buffer_object(acpi_size buffer_size)
+{
+	union acpi_operand_object *buffer_desc;
+	u8 *buffer = NULL;
+
+	ACPI_FUNCTION_TRACE_U32(ut_create_buffer_object, buffer_size);
+
+	/* Create a new Buffer object */
+
+	buffer_desc = acpi_ut_create_internal_object(ACPI_TYPE_BUFFER);
+	if (!buffer_desc) {
+		return_PTR(NULL);
+	}
+
+	/* Create an actual buffer only if size > 0 */
+
+	if (buffer_size > 0) {
+
+		/* Allocate the actual buffer */
+
+		buffer = ACPI_ALLOCATE_ZEROED(buffer_size);
+		if (!buffer) {
+			ACPI_ERROR((AE_INFO, "Could not allocate size %u",
+				    (u32)buffer_size));
+			acpi_ut_remove_reference(buffer_desc);
+			return_PTR(NULL);
+		}
+	}
+
+	/* Complete buffer object initialization */
+
+	buffer_desc->buffer.flags |= AOPOBJ_DATA_VALID;
+	buffer_desc->buffer.pointer = buffer;
+	buffer_desc->buffer.length = (u32)buffer_size;
+
+	/* Return the new buffer descriptor */
+
+	return_PTR(buffer_desc);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_create_string_object
+ *
+ * PARAMETERS:  string_size         - Size of string to be created. Does not
+ *                                    include NULL terminator, this is added
+ *                                    automatically.
+ *
+ * RETURN:      Pointer to a new String object
+ *
+ * DESCRIPTION: Create a fully initialized string object
+ *
+ ******************************************************************************/
+
+union acpi_operand_object *acpi_ut_create_string_object(acpi_size string_size)
+{
+	union acpi_operand_object *string_desc;
+	char *string;
+
+	ACPI_FUNCTION_TRACE_U32(ut_create_string_object, string_size);
+
+	/* Create a new String object */
+
+	string_desc = acpi_ut_create_internal_object(ACPI_TYPE_STRING);
+	if (!string_desc) {
+		return_PTR(NULL);
+	}
+
+	/*
+	 * Allocate the actual string buffer -- (Size + 1) for NULL terminator.
+	 * NOTE: Zero-length strings are NULL terminated
+	 */
+	string = ACPI_ALLOCATE_ZEROED(string_size + 1);
+	if (!string) {
+		ACPI_ERROR((AE_INFO, "Could not allocate size %u",
+			    (u32)string_size));
+		acpi_ut_remove_reference(string_desc);
+		return_PTR(NULL);
+	}
+
+	/* Complete string object initialization */
+
+	string_desc->string.pointer = string;
+	string_desc->string.length = (u32)string_size;
+
+	/* Return the new string descriptor */
+
+	return_PTR(string_desc);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_valid_internal_object
+ *
+ * PARAMETERS:  Object              - Object to be validated
+ *
+ * RETURN:      TRUE if object is valid, FALSE otherwise
+ *
+ * DESCRIPTION: Validate a pointer to be an union acpi_operand_object
+ *
+ ******************************************************************************/
+
+u8 acpi_ut_valid_internal_object(void *object)
+{
+
+	ACPI_FUNCTION_NAME(ut_valid_internal_object);
+
+	/* Check for a null pointer */
+
+	if (!object) {
+		ACPI_DEBUG_PRINT((ACPI_DB_EXEC, "**** Null Object Ptr\n"));
+		return (FALSE);
+	}
+
+	/* Check the descriptor type field */
+
+	switch (ACPI_GET_DESCRIPTOR_TYPE(object)) {
+	case ACPI_DESC_TYPE_OPERAND:
+
+		/* The object appears to be a valid union acpi_operand_object    */
+
+		return (TRUE);
+
+	default:
+		ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
+				  "%p is not not an ACPI operand obj [%s]\n",
+				  object, acpi_ut_get_descriptor_name(object)));
+		break;
+	}
+
+	return (FALSE);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_allocate_object_desc_dbg
+ *
+ * PARAMETERS:  module_name         - Caller's module name (for error output)
+ *              line_number         - Caller's line number (for error output)
+ *              component_id        - Caller's component ID (for error output)
+ *
+ * RETURN:      Pointer to newly allocated object descriptor.  Null on error
+ *
+ * DESCRIPTION: Allocate a new object descriptor.  Gracefully handle
+ *              error conditions.
+ *
+ ******************************************************************************/
+
+void *acpi_ut_allocate_object_desc_dbg(const char *module_name,
+				       u32 line_number, u32 component_id)
+{
+	union acpi_operand_object *object;
+
+	ACPI_FUNCTION_TRACE(ut_allocate_object_desc_dbg);
+
+	object = acpi_os_acquire_object(acpi_gbl_operand_cache);
+	if (!object) {
+		ACPI_ERROR((module_name, line_number,
+			    "Could not allocate an object descriptor"));
+
+		return_PTR(NULL);
+	}
+
+	/* Mark the descriptor type */
+
+	ACPI_SET_DESCRIPTOR_TYPE(object, ACPI_DESC_TYPE_OPERAND);
+
+	ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS, "%p Size %X\n",
+			  object, (u32)sizeof(union acpi_operand_object)));
+
+	return_PTR(object);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_delete_object_desc
+ *
+ * PARAMETERS:  Object          - An Acpi internal object to be deleted
+ *
+ * RETURN:      None.
+ *
+ * DESCRIPTION: Free an ACPI object descriptor or add it to the object cache
+ *
+ ******************************************************************************/
+
+void acpi_ut_delete_object_desc(union acpi_operand_object *object)
+{
+	ACPI_FUNCTION_TRACE_PTR(ut_delete_object_desc, object);
+
+	/* Object must be an union acpi_operand_object    */
+
+	if (ACPI_GET_DESCRIPTOR_TYPE(object) != ACPI_DESC_TYPE_OPERAND) {
+		ACPI_ERROR((AE_INFO,
+			    "%p is not an ACPI Operand object [%s]", object,
+			    acpi_ut_get_descriptor_name(object)));
+		return_VOID;
+	}
+
+	(void)acpi_os_release_object(acpi_gbl_operand_cache, object);
+	return_VOID;
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_get_simple_object_size
+ *
+ * PARAMETERS:  internal_object    - An ACPI operand object
+ *              obj_length         - Where the length is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: This function is called to determine the space required to
+ *              contain a simple object for return to an external user.
+ *
+ *              The length includes the object structure plus any additional
+ *              needed space.
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ut_get_simple_object_size(union acpi_operand_object *internal_object,
+			       acpi_size * obj_length)
+{
+	acpi_size length;
+	acpi_size size;
+	acpi_status status = AE_OK;
+
+	ACPI_FUNCTION_TRACE_PTR(ut_get_simple_object_size, internal_object);
+
+	/* Start with the length of the (external) Acpi object */
+
+	length = sizeof(union acpi_object);
+
+	/* A NULL object is allowed, can be a legal uninitialized package element */
+
+	if (!internal_object) {
+		/*
+		 * Object is NULL, just return the length of union acpi_object
+		 * (A NULL union acpi_object is an object of all zeroes.)
+		 */
+		*obj_length = ACPI_ROUND_UP_TO_NATIVE_WORD(length);
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	/* A Namespace Node should never appear here */
+
+	if (ACPI_GET_DESCRIPTOR_TYPE(internal_object) == ACPI_DESC_TYPE_NAMED) {
+
+		/* A namespace node should never get here */
+
+		return_ACPI_STATUS(AE_AML_INTERNAL);
+	}
+
+	/*
+	 * The final length depends on the object type
+	 * Strings and Buffers are packed right up against the parent object and
+	 * must be accessed bytewise or there may be alignment problems on
+	 * certain processors
+	 */
+	switch (internal_object->common.type) {
+	case ACPI_TYPE_STRING:
+
+		length += (acpi_size) internal_object->string.length + 1;
+		break;
+
+	case ACPI_TYPE_BUFFER:
+
+		length += (acpi_size) internal_object->buffer.length;
+		break;
+
+	case ACPI_TYPE_INTEGER:
+	case ACPI_TYPE_PROCESSOR:
+	case ACPI_TYPE_POWER:
+
+		/* No extra data for these types */
+
+		break;
+
+	case ACPI_TYPE_LOCAL_REFERENCE:
+
+		switch (internal_object->reference.class) {
+		case ACPI_REFCLASS_NAME:
+
+			/*
+			 * Get the actual length of the full pathname to this object.
+			 * The reference will be converted to the pathname to the object
+			 */
+			size =
+			    acpi_ns_get_pathname_length(internal_object->
+							reference.node);
+			if (!size) {
+				return_ACPI_STATUS(AE_BAD_PARAMETER);
+			}
+
+			length += ACPI_ROUND_UP_TO_NATIVE_WORD(size);
+			break;
+
+		default:
+
+			/*
+			 * No other reference opcodes are supported.
+			 * Notably, Locals and Args are not supported, but this may be
+			 * required eventually.
+			 */
+			ACPI_ERROR((AE_INFO,
+				    "Cannot convert to external object - "
+				    "unsupported Reference Class [%s] 0x%X in object %p",
+				    acpi_ut_get_reference_name(internal_object),
+				    internal_object->reference.class,
+				    internal_object));
+			status = AE_TYPE;
+			break;
+		}
+		break;
+
+	default:
+
+		ACPI_ERROR((AE_INFO, "Cannot convert to external object - "
+			    "unsupported type [%s] 0x%X in object %p",
+			    acpi_ut_get_object_type_name(internal_object),
+			    internal_object->common.type, internal_object));
+		status = AE_TYPE;
+		break;
+	}
+
+	/*
+	 * Account for the space required by the object rounded up to the next
+	 * multiple of the machine word size.  This keeps each object aligned
+	 * on a machine word boundary. (preventing alignment faults on some
+	 * machines.)
+	 */
+	*obj_length = ACPI_ROUND_UP_TO_NATIVE_WORD(length);
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_get_element_length
+ *
+ * PARAMETERS:  acpi_pkg_callback
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Get the length of one package element.
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ut_get_element_length(u8 object_type,
+			   union acpi_operand_object *source_object,
+			   union acpi_generic_state *state, void *context)
+{
+	acpi_status status = AE_OK;
+	struct acpi_pkg_info *info = (struct acpi_pkg_info *)context;
+	acpi_size object_space;
+
+	switch (object_type) {
+	case ACPI_COPY_TYPE_SIMPLE:
+
+		/*
+		 * Simple object - just get the size (Null object/entry is handled
+		 * here also) and sum it into the running package length
+		 */
+		status =
+		    acpi_ut_get_simple_object_size(source_object,
+						   &object_space);
+		if (ACPI_FAILURE(status)) {
+			return (status);
+		}
+
+		info->length += object_space;
+		break;
+
+	case ACPI_COPY_TYPE_PACKAGE:
+
+		/* Package object - nothing much to do here, let the walk handle it */
+
+		info->num_packages++;
+		state->pkg.this_target_obj = NULL;
+		break;
+
+	default:
+
+		/* No other types allowed */
+
+		return (AE_BAD_PARAMETER);
+	}
+
+	return (status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_get_package_object_size
+ *
+ * PARAMETERS:  internal_object     - An ACPI internal object
+ *              obj_length          - Where the length is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: This function is called to determine the space required to
+ *              contain a package object for return to an external user.
+ *
+ *              This is moderately complex since a package contains other
+ *              objects including packages.
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ut_get_package_object_size(union acpi_operand_object *internal_object,
+				acpi_size * obj_length)
+{
+	acpi_status status;
+	struct acpi_pkg_info info;
+
+	ACPI_FUNCTION_TRACE_PTR(ut_get_package_object_size, internal_object);
+
+	info.length = 0;
+	info.object_space = 0;
+	info.num_packages = 1;
+
+	status = acpi_ut_walk_package_tree(internal_object, NULL,
+					   acpi_ut_get_element_length, &info);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/*
+	 * We have handled all of the objects in all levels of the package.
+	 * just add the length of the package objects themselves.
+	 * Round up to the next machine word.
+	 */
+	info.length += ACPI_ROUND_UP_TO_NATIVE_WORD(sizeof(union acpi_object)) *
+	    (acpi_size) info.num_packages;
+
+	/* Return the total package length */
+
+	*obj_length = info.length;
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_get_object_size
+ *
+ * PARAMETERS:  internal_object     - An ACPI internal object
+ *              obj_length          - Where the length will be returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: This function is called to determine the space required to
+ *              contain an object for return to an API user.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ut_get_object_size(union acpi_operand_object *internal_object,
+			acpi_size * obj_length)
+{
+	acpi_status status;
+
+	ACPI_FUNCTION_ENTRY();
+
+	if ((ACPI_GET_DESCRIPTOR_TYPE(internal_object) ==
+	     ACPI_DESC_TYPE_OPERAND)
+	    && (internal_object->common.type == ACPI_TYPE_PACKAGE)) {
+		status =
+		    acpi_ut_get_package_object_size(internal_object,
+						    obj_length);
+	} else {
+		status =
+		    acpi_ut_get_simple_object_size(internal_object, obj_length);
+	}
+
+	return (status);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utosi.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utosi.c
new file mode 100644
index 00000000..2360cf70
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utosi.c
@@ -0,0 +1,380 @@
+/******************************************************************************
+ *
+ * Module Name: utosi - Support for the _OSI predefined control method
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+
+#define _COMPONENT          ACPI_UTILITIES
+ACPI_MODULE_NAME("utosi")
+
+/*
+ * Strings supported by the _OSI predefined control method (which is
+ * implemented internally within this module.)
+ *
+ * March 2009: Removed "Linux" as this host no longer wants to respond true
+ * for this string. Basically, the only safe OS strings are windows-related
+ * and in many or most cases represent the only test path within the
+ * BIOS-provided ASL code.
+ *
+ * The last element of each entry is used to track the newest version of
+ * Windows that the BIOS has requested.
+ */
+static struct acpi_interface_info acpi_default_supported_interfaces[] = {
+	/* Operating System Vendor Strings */
+
+	{"Windows 2000", NULL, 0, ACPI_OSI_WIN_2000},	/* Windows 2000 */
+	{"Windows 2001", NULL, 0, ACPI_OSI_WIN_XP},	/* Windows XP */
+	{"Windows 2001 SP1", NULL, 0, ACPI_OSI_WIN_XP_SP1},	/* Windows XP SP1 */
+	{"Windows 2001.1", NULL, 0, ACPI_OSI_WINSRV_2003},	/* Windows Server 2003 */
+	{"Windows 2001 SP2", NULL, 0, ACPI_OSI_WIN_XP_SP2},	/* Windows XP SP2 */
+	{"Windows 2001.1 SP1", NULL, 0, ACPI_OSI_WINSRV_2003_SP1},	/* Windows Server 2003 SP1 - Added 03/2006 */
+	{"Windows 2006", NULL, 0, ACPI_OSI_WIN_VISTA},	/* Windows Vista - Added 03/2006 */
+	{"Windows 2006.1", NULL, 0, ACPI_OSI_WINSRV_2008},	/* Windows Server 2008 - Added 09/2009 */
+	{"Windows 2006 SP1", NULL, 0, ACPI_OSI_WIN_VISTA_SP1},	/* Windows Vista SP1 - Added 09/2009 */
+	{"Windows 2006 SP2", NULL, 0, ACPI_OSI_WIN_VISTA_SP2},	/* Windows Vista SP2 - Added 09/2010 */
+	{"Windows 2009", NULL, 0, ACPI_OSI_WIN_7},	/* Windows 7 and Server 2008 R2 - Added 09/2009 */
+
+	/* Feature Group Strings */
+
+	{"Extended Address Space Descriptor", NULL, 0, 0}
+
+	/*
+	 * All "optional" feature group strings (features that are implemented
+	 * by the host) should be dynamically added by the host via
+	 * acpi_install_interface and should not be manually added here.
+	 *
+	 * Examples of optional feature group strings:
+	 *
+	 * "Module Device"
+	 * "Processor Device"
+	 * "3.0 Thermal Model"
+	 * "3.0 _SCP Extensions"
+	 * "Processor Aggregator Device"
+	 */
+};
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_initialize_interfaces
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Initialize the global _OSI supported interfaces list
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ut_initialize_interfaces(void)
+{
+	u32 i;
+
+	(void)acpi_os_acquire_mutex(acpi_gbl_osi_mutex, ACPI_WAIT_FOREVER);
+	acpi_gbl_supported_interfaces = acpi_default_supported_interfaces;
+
+	/* Link the static list of supported interfaces */
+
+	for (i = 0;
+	     i < (ACPI_ARRAY_LENGTH(acpi_default_supported_interfaces) - 1);
+	     i++) {
+		acpi_default_supported_interfaces[i].next =
+		    &acpi_default_supported_interfaces[(acpi_size) i + 1];
+	}
+
+	acpi_os_release_mutex(acpi_gbl_osi_mutex);
+	return (AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_interface_terminate
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Delete all interfaces in the global list. Sets
+ *              acpi_gbl_supported_interfaces to NULL.
+ *
+ ******************************************************************************/
+
+void acpi_ut_interface_terminate(void)
+{
+	struct acpi_interface_info *next_interface;
+
+	(void)acpi_os_acquire_mutex(acpi_gbl_osi_mutex, ACPI_WAIT_FOREVER);
+	next_interface = acpi_gbl_supported_interfaces;
+
+	while (next_interface) {
+		acpi_gbl_supported_interfaces = next_interface->next;
+
+		/* Only interfaces added at runtime can be freed */
+
+		if (next_interface->flags & ACPI_OSI_DYNAMIC) {
+			ACPI_FREE(next_interface->name);
+			ACPI_FREE(next_interface);
+		}
+
+		next_interface = acpi_gbl_supported_interfaces;
+	}
+
+	acpi_os_release_mutex(acpi_gbl_osi_mutex);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_install_interface
+ *
+ * PARAMETERS:  interface_name      - The interface to install
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Install the interface into the global interface list.
+ *              Caller MUST hold acpi_gbl_osi_mutex
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ut_install_interface(acpi_string interface_name)
+{
+	struct acpi_interface_info *interface_info;
+
+	/* Allocate info block and space for the name string */
+
+	interface_info =
+	    ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_interface_info));
+	if (!interface_info) {
+		return (AE_NO_MEMORY);
+	}
+
+	interface_info->name =
+	    ACPI_ALLOCATE_ZEROED(ACPI_STRLEN(interface_name) + 1);
+	if (!interface_info->name) {
+		ACPI_FREE(interface_info);
+		return (AE_NO_MEMORY);
+	}
+
+	/* Initialize new info and insert at the head of the global list */
+
+	ACPI_STRCPY(interface_info->name, interface_name);
+	interface_info->flags = ACPI_OSI_DYNAMIC;
+	interface_info->next = acpi_gbl_supported_interfaces;
+
+	acpi_gbl_supported_interfaces = interface_info;
+	return (AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_remove_interface
+ *
+ * PARAMETERS:  interface_name      - The interface to remove
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Remove the interface from the global interface list.
+ *              Caller MUST hold acpi_gbl_osi_mutex
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ut_remove_interface(acpi_string interface_name)
+{
+	struct acpi_interface_info *previous_interface;
+	struct acpi_interface_info *next_interface;
+
+	previous_interface = next_interface = acpi_gbl_supported_interfaces;
+	while (next_interface) {
+		if (!ACPI_STRCMP(interface_name, next_interface->name)) {
+
+			/* Found: name is in either the static list or was added at runtime */
+
+			if (next_interface->flags & ACPI_OSI_DYNAMIC) {
+
+				/* Interface was added dynamically, remove and free it */
+
+				if (previous_interface == next_interface) {
+					acpi_gbl_supported_interfaces =
+					    next_interface->next;
+				} else {
+					previous_interface->next =
+					    next_interface->next;
+				}
+
+				ACPI_FREE(next_interface->name);
+				ACPI_FREE(next_interface);
+			} else {
+				/*
+				 * Interface is in static list. If marked invalid, then it
+				 * does not actually exist. Else, mark it invalid.
+				 */
+				if (next_interface->flags & ACPI_OSI_INVALID) {
+					return (AE_NOT_EXIST);
+				}
+
+				next_interface->flags |= ACPI_OSI_INVALID;
+			}
+
+			return (AE_OK);
+		}
+
+		previous_interface = next_interface;
+		next_interface = next_interface->next;
+	}
+
+	/* Interface was not found */
+
+	return (AE_NOT_EXIST);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_get_interface
+ *
+ * PARAMETERS:  interface_name      - The interface to find
+ *
+ * RETURN:      struct acpi_interface_info if found. NULL if not found.
+ *
+ * DESCRIPTION: Search for the specified interface name in the global list.
+ *              Caller MUST hold acpi_gbl_osi_mutex
+ *
+ ******************************************************************************/
+
+struct acpi_interface_info *acpi_ut_get_interface(acpi_string interface_name)
+{
+	struct acpi_interface_info *next_interface;
+
+	next_interface = acpi_gbl_supported_interfaces;
+	while (next_interface) {
+		if (!ACPI_STRCMP(interface_name, next_interface->name)) {
+			return (next_interface);
+		}
+
+		next_interface = next_interface->next;
+	}
+
+	return (NULL);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_osi_implementation
+ *
+ * PARAMETERS:  walk_state          - Current walk state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Implementation of the _OSI predefined control method. When
+ *              an invocation of _OSI is encountered in the system AML,
+ *              control is transferred to this function.
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ut_osi_implementation(struct acpi_walk_state * walk_state)
+{
+	union acpi_operand_object *string_desc;
+	union acpi_operand_object *return_desc;
+	struct acpi_interface_info *interface_info;
+	acpi_interface_handler interface_handler;
+	u32 return_value;
+
+	ACPI_FUNCTION_TRACE(ut_osi_implementation);
+
+	/* Validate the string input argument (from the AML caller) */
+
+	string_desc = walk_state->arguments[0].object;
+	if (!string_desc || (string_desc->common.type != ACPI_TYPE_STRING)) {
+		return_ACPI_STATUS(AE_TYPE);
+	}
+
+	/* Create a return object */
+
+	return_desc = acpi_ut_create_internal_object(ACPI_TYPE_INTEGER);
+	if (!return_desc) {
+		return_ACPI_STATUS(AE_NO_MEMORY);
+	}
+
+	/* Default return value is 0, NOT SUPPORTED */
+
+	return_value = 0;
+	(void)acpi_os_acquire_mutex(acpi_gbl_osi_mutex, ACPI_WAIT_FOREVER);
+
+	/* Lookup the interface in the global _OSI list */
+
+	interface_info = acpi_ut_get_interface(string_desc->string.pointer);
+	if (interface_info && !(interface_info->flags & ACPI_OSI_INVALID)) {
+		/*
+		 * The interface is supported.
+		 * Update the osi_data if necessary. We keep track of the latest
+		 * version of Windows that has been requested by the BIOS.
+		 */
+		if (interface_info->value > acpi_gbl_osi_data) {
+			acpi_gbl_osi_data = interface_info->value;
+		}
+
+		return_value = ACPI_UINT32_MAX;
+	}
+
+	acpi_os_release_mutex(acpi_gbl_osi_mutex);
+
+	/*
+	 * Invoke an optional _OSI interface handler. The host OS may wish
+	 * to do some interface-specific handling. For example, warn about
+	 * certain interfaces or override the true/false support value.
+	 */
+	interface_handler = acpi_gbl_interface_handler;
+	if (interface_handler) {
+		return_value =
+		    interface_handler(string_desc->string.pointer,
+				      return_value);
+	}
+
+	ACPI_DEBUG_PRINT_RAW((ACPI_DB_INFO,
+			      "ACPI: BIOS _OSI(\"%s\") is %ssupported\n",
+			      string_desc->string.pointer,
+			      return_value == 0 ? "not " : ""));
+
+	/* Complete the return object */
+
+	return_desc->integer.value = return_value;
+	walk_state->return_desc = return_desc;
+	return_ACPI_STATUS(AE_OK);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utresrc.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utresrc.c
new file mode 100644
index 00000000..ead459e9
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utresrc.c
@@ -0,0 +1,824 @@
+/*******************************************************************************
+ *
+ * Module Name: utresrc - Resource managment utilities
+ *
+ ******************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acresrc.h"
+
+#define _COMPONENT          ACPI_UTILITIES
+ACPI_MODULE_NAME("utresrc")
+
+#if defined(ACPI_DISASSEMBLER) || defined (ACPI_DEBUGGER)
+/*
+ * Strings used to decode resource descriptors.
+ * Used by both the disasssembler and the debugger resource dump routines
+ */
+const char *acpi_gbl_bm_decode[] = {
+	"NotBusMaster",
+	"BusMaster"
+};
+
+const char *acpi_gbl_config_decode[] = {
+	"0 - Good Configuration",
+	"1 - Acceptable Configuration",
+	"2 - Suboptimal Configuration",
+	"3 - ***Invalid Configuration***",
+};
+
+const char *acpi_gbl_consume_decode[] = {
+	"ResourceProducer",
+	"ResourceConsumer"
+};
+
+const char *acpi_gbl_dec_decode[] = {
+	"PosDecode",
+	"SubDecode"
+};
+
+const char *acpi_gbl_he_decode[] = {
+	"Level",
+	"Edge"
+};
+
+const char *acpi_gbl_io_decode[] = {
+	"Decode10",
+	"Decode16"
+};
+
+const char *acpi_gbl_ll_decode[] = {
+	"ActiveHigh",
+	"ActiveLow"
+};
+
+const char *acpi_gbl_max_decode[] = {
+	"MaxNotFixed",
+	"MaxFixed"
+};
+
+const char *acpi_gbl_mem_decode[] = {
+	"NonCacheable",
+	"Cacheable",
+	"WriteCombining",
+	"Prefetchable"
+};
+
+const char *acpi_gbl_min_decode[] = {
+	"MinNotFixed",
+	"MinFixed"
+};
+
+const char *acpi_gbl_mtp_decode[] = {
+	"AddressRangeMemory",
+	"AddressRangeReserved",
+	"AddressRangeACPI",
+	"AddressRangeNVS"
+};
+
+const char *acpi_gbl_rng_decode[] = {
+	"InvalidRanges",
+	"NonISAOnlyRanges",
+	"ISAOnlyRanges",
+	"EntireRange"
+};
+
+const char *acpi_gbl_rw_decode[] = {
+	"ReadOnly",
+	"ReadWrite"
+};
+
+const char *acpi_gbl_shr_decode[] = {
+	"Exclusive",
+	"Shared"
+};
+
+const char *acpi_gbl_siz_decode[] = {
+	"Transfer8",
+	"Transfer8_16",
+	"Transfer16",
+	"InvalidSize"
+};
+
+const char *acpi_gbl_trs_decode[] = {
+	"DenseTranslation",
+	"SparseTranslation"
+};
+
+const char *acpi_gbl_ttp_decode[] = {
+	"TypeStatic",
+	"TypeTranslation"
+};
+
+const char *acpi_gbl_typ_decode[] = {
+	"Compatibility",
+	"TypeA",
+	"TypeB",
+	"TypeF"
+};
+
+const char *acpi_gbl_ppc_decode[] = {
+	"PullDefault",
+	"PullUp",
+	"PullDown",
+	"PullNone"
+};
+
+const char *acpi_gbl_ior_decode[] = {
+	"IoRestrictionNone",
+	"IoRestrictionInputOnly",
+	"IoRestrictionOutputOnly",
+	"IoRestrictionNoneAndPreserve"
+};
+
+const char *acpi_gbl_dts_decode[] = {
+	"Width8bit",
+	"Width16bit",
+	"Width32bit",
+	"Width64bit",
+	"Width128bit",
+	"Width256bit",
+};
+
+/* GPIO connection type */
+
+const char *acpi_gbl_ct_decode[] = {
+	"Interrupt",
+	"I/O"
+};
+
+/* Serial bus type */
+
+const char *acpi_gbl_sbt_decode[] = {
+	"/* UNKNOWN serial bus type */",
+	"I2C",
+	"SPI",
+	"UART"
+};
+
+/* I2C serial bus access mode */
+
+const char *acpi_gbl_am_decode[] = {
+	"AddressingMode7Bit",
+	"AddressingMode10Bit"
+};
+
+/* I2C serial bus slave mode */
+
+const char *acpi_gbl_sm_decode[] = {
+	"ControllerInitiated",
+	"DeviceInitiated"
+};
+
+/* SPI serial bus wire mode */
+
+const char *acpi_gbl_wm_decode[] = {
+	"FourWireMode",
+	"ThreeWireMode"
+};
+
+/* SPI serial clock phase */
+
+const char *acpi_gbl_cph_decode[] = {
+	"ClockPhaseFirst",
+	"ClockPhaseSecond"
+};
+
+/* SPI serial bus clock polarity */
+
+const char *acpi_gbl_cpo_decode[] = {
+	"ClockPolarityLow",
+	"ClockPolarityHigh"
+};
+
+/* SPI serial bus device polarity */
+
+const char *acpi_gbl_dp_decode[] = {
+	"PolarityLow",
+	"PolarityHigh"
+};
+
+/* UART serial bus endian */
+
+const char *acpi_gbl_ed_decode[] = {
+	"LittleEndian",
+	"BigEndian"
+};
+
+/* UART serial bus bits per byte */
+
+const char *acpi_gbl_bpb_decode[] = {
+	"DataBitsFive",
+	"DataBitsSix",
+	"DataBitsSeven",
+	"DataBitsEight",
+	"DataBitsNine",
+	"/* UNKNOWN Bits per byte */",
+	"/* UNKNOWN Bits per byte */",
+	"/* UNKNOWN Bits per byte */"
+};
+
+/* UART serial bus stop bits */
+
+const char *acpi_gbl_sb_decode[] = {
+	"StopBitsNone",
+	"StopBitsOne",
+	"StopBitsOnePlusHalf",
+	"StopBitsTwo"
+};
+
+/* UART serial bus flow control */
+
+const char *acpi_gbl_fc_decode[] = {
+	"FlowControlNone",
+	"FlowControlHardware",
+	"FlowControlXON",
+	"/* UNKNOWN flow control keyword */"
+};
+
+/* UART serial bus parity type */
+
+const char *acpi_gbl_pt_decode[] = {
+	"ParityTypeNone",
+	"ParityTypeEven",
+	"ParityTypeOdd",
+	"ParityTypeMark",
+	"ParityTypeSpace",
+	"/* UNKNOWN parity keyword */",
+	"/* UNKNOWN parity keyword */",
+	"/* UNKNOWN parity keyword */"
+};
+
+#endif
+
+/*
+ * Base sizes of the raw AML resource descriptors, indexed by resource type.
+ * Zero indicates a reserved (and therefore invalid) resource type.
+ */
+const u8 acpi_gbl_resource_aml_sizes[] = {
+	/* Small descriptors */
+
+	0,
+	0,
+	0,
+	0,
+	ACPI_AML_SIZE_SMALL(struct aml_resource_irq),
+	ACPI_AML_SIZE_SMALL(struct aml_resource_dma),
+	ACPI_AML_SIZE_SMALL(struct aml_resource_start_dependent),
+	ACPI_AML_SIZE_SMALL(struct aml_resource_end_dependent),
+	ACPI_AML_SIZE_SMALL(struct aml_resource_io),
+	ACPI_AML_SIZE_SMALL(struct aml_resource_fixed_io),
+	ACPI_AML_SIZE_SMALL(struct aml_resource_fixed_dma),
+	0,
+	0,
+	0,
+	ACPI_AML_SIZE_SMALL(struct aml_resource_vendor_small),
+	ACPI_AML_SIZE_SMALL(struct aml_resource_end_tag),
+
+	/* Large descriptors */
+
+	0,
+	ACPI_AML_SIZE_LARGE(struct aml_resource_memory24),
+	ACPI_AML_SIZE_LARGE(struct aml_resource_generic_register),
+	0,
+	ACPI_AML_SIZE_LARGE(struct aml_resource_vendor_large),
+	ACPI_AML_SIZE_LARGE(struct aml_resource_memory32),
+	ACPI_AML_SIZE_LARGE(struct aml_resource_fixed_memory32),
+	ACPI_AML_SIZE_LARGE(struct aml_resource_address32),
+	ACPI_AML_SIZE_LARGE(struct aml_resource_address16),
+	ACPI_AML_SIZE_LARGE(struct aml_resource_extended_irq),
+	ACPI_AML_SIZE_LARGE(struct aml_resource_address64),
+	ACPI_AML_SIZE_LARGE(struct aml_resource_extended_address64),
+	ACPI_AML_SIZE_LARGE(struct aml_resource_gpio),
+	0,
+	ACPI_AML_SIZE_LARGE(struct aml_resource_common_serialbus),
+};
+
+const u8 acpi_gbl_resource_aml_serial_bus_sizes[] = {
+	0,
+	ACPI_AML_SIZE_LARGE(struct aml_resource_i2c_serialbus),
+	ACPI_AML_SIZE_LARGE(struct aml_resource_spi_serialbus),
+	ACPI_AML_SIZE_LARGE(struct aml_resource_uart_serialbus),
+};
+
+/*
+ * Resource types, used to validate the resource length field.
+ * The length of fixed-length types must match exactly, variable
+ * lengths must meet the minimum required length, etc.
+ * Zero indicates a reserved (and therefore invalid) resource type.
+ */
+static const u8 acpi_gbl_resource_types[] = {
+	/* Small descriptors */
+
+	0,
+	0,
+	0,
+	0,
+	ACPI_SMALL_VARIABLE_LENGTH,	/* 04 IRQ */
+	ACPI_FIXED_LENGTH,	/* 05 DMA */
+	ACPI_SMALL_VARIABLE_LENGTH,	/* 06 start_dependent_functions */
+	ACPI_FIXED_LENGTH,	/* 07 end_dependent_functions */
+	ACPI_FIXED_LENGTH,	/* 08 IO */
+	ACPI_FIXED_LENGTH,	/* 09 fixed_iO */
+	ACPI_FIXED_LENGTH,	/* 0_a fixed_dMA */
+	0,
+	0,
+	0,
+	ACPI_VARIABLE_LENGTH,	/* 0_e vendor_short */
+	ACPI_FIXED_LENGTH,	/* 0_f end_tag */
+
+	/* Large descriptors */
+
+	0,
+	ACPI_FIXED_LENGTH,	/* 01 Memory24 */
+	ACPI_FIXED_LENGTH,	/* 02 generic_register */
+	0,
+	ACPI_VARIABLE_LENGTH,	/* 04 vendor_long */
+	ACPI_FIXED_LENGTH,	/* 05 Memory32 */
+	ACPI_FIXED_LENGTH,	/* 06 memory32_fixed */
+	ACPI_VARIABLE_LENGTH,	/* 07 Dword* address */
+	ACPI_VARIABLE_LENGTH,	/* 08 Word* address */
+	ACPI_VARIABLE_LENGTH,	/* 09 extended_iRQ */
+	ACPI_VARIABLE_LENGTH,	/* 0_a Qword* address */
+	ACPI_FIXED_LENGTH,	/* 0_b Extended* address */
+	ACPI_VARIABLE_LENGTH,	/* 0_c Gpio* */
+	0,
+	ACPI_VARIABLE_LENGTH	/* 0_e *serial_bus */
+};
+
+/*
+ * For the i_aSL compiler/disassembler, we don't want any error messages
+ * because the disassembler uses the resource validation code to determine
+ * if Buffer objects are actually Resource Templates.
+ */
+#ifdef ACPI_ASL_COMPILER
+#define ACPI_RESOURCE_ERROR(plist)
+#else
+#define ACPI_RESOURCE_ERROR(plist)  ACPI_ERROR(plist)
+#endif
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_walk_aml_resources
+ *
+ * PARAMETERS:  Aml             - Pointer to the raw AML resource template
+ *              aml_length      - Length of the entire template
+ *              user_function   - Called once for each descriptor found. If
+ *                                NULL, a pointer to the end_tag is returned
+ *              Context         - Passed to user_function
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Walk a raw AML resource list(buffer). User function called
+ *              once for each resource found.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ut_walk_aml_resources(u8 *aml,
+			   acpi_size aml_length,
+			   acpi_walk_aml_callback user_function, void *context)
+{
+	acpi_status status;
+	u8 *end_aml;
+	u8 resource_index;
+	u32 length;
+	u32 offset = 0;
+	u8 end_tag[2] = { 0x79, 0x00 };
+
+	ACPI_FUNCTION_TRACE(ut_walk_aml_resources);
+
+	/* The absolute minimum resource template is one end_tag descriptor */
+
+	if (aml_length < sizeof(struct aml_resource_end_tag)) {
+		return_ACPI_STATUS(AE_AML_NO_RESOURCE_END_TAG);
+	}
+
+	/* Point to the end of the resource template buffer */
+
+	end_aml = aml + aml_length;
+
+	/* Walk the byte list, abort on any invalid descriptor type or length */
+
+	while (aml < end_aml) {
+
+		/* Validate the Resource Type and Resource Length */
+
+		status = acpi_ut_validate_resource(aml, &resource_index);
+		if (ACPI_FAILURE(status)) {
+			/*
+			 * Exit on failure. Cannot continue because the descriptor length
+			 * may be bogus also.
+			 */
+			return_ACPI_STATUS(status);
+		}
+
+		/* Get the length of this descriptor */
+
+		length = acpi_ut_get_descriptor_length(aml);
+
+		/* Invoke the user function */
+
+		if (user_function) {
+			status =
+			    user_function(aml, length, offset, resource_index,
+					  context);
+			if (ACPI_FAILURE(status)) {
+				return_ACPI_STATUS(status);
+			}
+		}
+
+		/* An end_tag descriptor terminates this resource template */
+
+		if (acpi_ut_get_resource_type(aml) ==
+		    ACPI_RESOURCE_NAME_END_TAG) {
+			/*
+			 * There must be at least one more byte in the buffer for
+			 * the 2nd byte of the end_tag
+			 */
+			if ((aml + 1) >= end_aml) {
+				return_ACPI_STATUS(AE_AML_NO_RESOURCE_END_TAG);
+			}
+
+			/* Return the pointer to the end_tag if requested */
+
+			if (!user_function) {
+				*(void **)context = aml;
+			}
+
+			/* Normal exit */
+
+			return_ACPI_STATUS(AE_OK);
+		}
+
+		aml += length;
+		offset += length;
+	}
+
+	/* Did not find an end_tag descriptor */
+
+	if (user_function) {
+
+		/* Insert an end_tag anyway. acpi_rs_get_list_length always leaves room */
+
+		(void)acpi_ut_validate_resource(end_tag, &resource_index);
+		status =
+		    user_function(end_tag, 2, offset, resource_index, context);
+		if (ACPI_FAILURE(status)) {
+			return_ACPI_STATUS(status);
+		}
+	}
+
+	return_ACPI_STATUS(AE_AML_NO_RESOURCE_END_TAG);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_validate_resource
+ *
+ * PARAMETERS:  Aml             - Pointer to the raw AML resource descriptor
+ *              return_index    - Where the resource index is returned. NULL
+ *                                if the index is not required.
+ *
+ * RETURN:      Status, and optionally the Index into the global resource tables
+ *
+ * DESCRIPTION: Validate an AML resource descriptor by checking the Resource
+ *              Type and Resource Length. Returns an index into the global
+ *              resource information/dispatch tables for later use.
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ut_validate_resource(void *aml, u8 *return_index)
+{
+	union aml_resource *aml_resource;
+	u8 resource_type;
+	u8 resource_index;
+	acpi_rs_length resource_length;
+	acpi_rs_length minimum_resource_length;
+
+	ACPI_FUNCTION_ENTRY();
+
+	/*
+	 * 1) Validate the resource_type field (Byte 0)
+	 */
+	resource_type = ACPI_GET8(aml);
+
+	/*
+	 * Byte 0 contains the descriptor name (Resource Type)
+	 * Examine the large/small bit in the resource header
+	 */
+	if (resource_type & ACPI_RESOURCE_NAME_LARGE) {
+
+		/* Verify the large resource type (name) against the max */
+
+		if (resource_type > ACPI_RESOURCE_NAME_LARGE_MAX) {
+			goto invalid_resource;
+		}
+
+		/*
+		 * Large Resource Type -- bits 6:0 contain the name
+		 * Translate range 0x80-0x8B to index range 0x10-0x1B
+		 */
+		resource_index = (u8)(resource_type - 0x70);
+	} else {
+		/*
+		 * Small Resource Type -- bits 6:3 contain the name
+		 * Shift range to index range 0x00-0x0F
+		 */
+		resource_index = (u8)
+		    ((resource_type & ACPI_RESOURCE_NAME_SMALL_MASK) >> 3);
+	}
+
+	/*
+	 * Check validity of the resource type, via acpi_gbl_resource_types. Zero
+	 * indicates an invalid resource.
+	 */
+	if (!acpi_gbl_resource_types[resource_index]) {
+		goto invalid_resource;
+	}
+
+	/*
+	 * Validate the resource_length field. This ensures that the length
+	 * is at least reasonable, and guarantees that it is non-zero.
+	 */
+	resource_length = acpi_ut_get_resource_length(aml);
+	minimum_resource_length = acpi_gbl_resource_aml_sizes[resource_index];
+
+	/* Validate based upon the type of resource - fixed length or variable */
+
+	switch (acpi_gbl_resource_types[resource_index]) {
+	case ACPI_FIXED_LENGTH:
+
+		/* Fixed length resource, length must match exactly */
+
+		if (resource_length != minimum_resource_length) {
+			goto bad_resource_length;
+		}
+		break;
+
+	case ACPI_VARIABLE_LENGTH:
+
+		/* Variable length resource, length must be at least the minimum */
+
+		if (resource_length < minimum_resource_length) {
+			goto bad_resource_length;
+		}
+		break;
+
+	case ACPI_SMALL_VARIABLE_LENGTH:
+
+		/* Small variable length resource, length can be (Min) or (Min-1) */
+
+		if ((resource_length > minimum_resource_length) ||
+		    (resource_length < (minimum_resource_length - 1))) {
+			goto bad_resource_length;
+		}
+		break;
+
+	default:
+
+		/* Shouldn't happen (because of validation earlier), but be sure */
+
+		goto invalid_resource;
+	}
+
+	aml_resource = ACPI_CAST_PTR(union aml_resource, aml);
+	if (resource_type == ACPI_RESOURCE_NAME_SERIAL_BUS) {
+
+		/* Validate the bus_type field */
+
+		if ((aml_resource->common_serial_bus.type == 0) ||
+		    (aml_resource->common_serial_bus.type >
+		     AML_RESOURCE_MAX_SERIALBUSTYPE)) {
+			ACPI_RESOURCE_ERROR((AE_INFO,
+					     "Invalid/unsupported SerialBus resource descriptor: BusType 0x%2.2X",
+					     aml_resource->common_serial_bus.
+					     type));
+			return (AE_AML_INVALID_RESOURCE_TYPE);
+		}
+	}
+
+	/* Optionally return the resource table index */
+
+	if (return_index) {
+		*return_index = resource_index;
+	}
+
+	return (AE_OK);
+
+      invalid_resource:
+
+	ACPI_RESOURCE_ERROR((AE_INFO,
+			     "Invalid/unsupported resource descriptor: Type 0x%2.2X",
+			     resource_type));
+	return (AE_AML_INVALID_RESOURCE_TYPE);
+
+      bad_resource_length:
+
+	ACPI_RESOURCE_ERROR((AE_INFO,
+			     "Invalid resource descriptor length: Type "
+			     "0x%2.2X, Length 0x%4.4X, MinLength 0x%4.4X",
+			     resource_type, resource_length,
+			     minimum_resource_length));
+	return (AE_AML_BAD_RESOURCE_LENGTH);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_get_resource_type
+ *
+ * PARAMETERS:  Aml             - Pointer to the raw AML resource descriptor
+ *
+ * RETURN:      The Resource Type with no extraneous bits (except the
+ *              Large/Small descriptor bit -- this is left alone)
+ *
+ * DESCRIPTION: Extract the Resource Type/Name from the first byte of
+ *              a resource descriptor.
+ *
+ ******************************************************************************/
+
+u8 acpi_ut_get_resource_type(void *aml)
+{
+	ACPI_FUNCTION_ENTRY();
+
+	/*
+	 * Byte 0 contains the descriptor name (Resource Type)
+	 * Examine the large/small bit in the resource header
+	 */
+	if (ACPI_GET8(aml) & ACPI_RESOURCE_NAME_LARGE) {
+
+		/* Large Resource Type -- bits 6:0 contain the name */
+
+		return (ACPI_GET8(aml));
+	} else {
+		/* Small Resource Type -- bits 6:3 contain the name */
+
+		return ((u8)(ACPI_GET8(aml) & ACPI_RESOURCE_NAME_SMALL_MASK));
+	}
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_get_resource_length
+ *
+ * PARAMETERS:  Aml             - Pointer to the raw AML resource descriptor
+ *
+ * RETURN:      Byte Length
+ *
+ * DESCRIPTION: Get the "Resource Length" of a raw AML descriptor. By
+ *              definition, this does not include the size of the descriptor
+ *              header or the length field itself.
+ *
+ ******************************************************************************/
+
+u16 acpi_ut_get_resource_length(void *aml)
+{
+	acpi_rs_length resource_length;
+
+	ACPI_FUNCTION_ENTRY();
+
+	/*
+	 * Byte 0 contains the descriptor name (Resource Type)
+	 * Examine the large/small bit in the resource header
+	 */
+	if (ACPI_GET8(aml) & ACPI_RESOURCE_NAME_LARGE) {
+
+		/* Large Resource type -- bytes 1-2 contain the 16-bit length */
+
+		ACPI_MOVE_16_TO_16(&resource_length, ACPI_ADD_PTR(u8, aml, 1));
+
+	} else {
+		/* Small Resource type -- bits 2:0 of byte 0 contain the length */
+
+		resource_length = (u16)(ACPI_GET8(aml) &
+					ACPI_RESOURCE_NAME_SMALL_LENGTH_MASK);
+	}
+
+	return (resource_length);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_get_resource_header_length
+ *
+ * PARAMETERS:  Aml             - Pointer to the raw AML resource descriptor
+ *
+ * RETURN:      Length of the AML header (depends on large/small descriptor)
+ *
+ * DESCRIPTION: Get the length of the header for this resource.
+ *
+ ******************************************************************************/
+
+u8 acpi_ut_get_resource_header_length(void *aml)
+{
+	ACPI_FUNCTION_ENTRY();
+
+	/* Examine the large/small bit in the resource header */
+
+	if (ACPI_GET8(aml) & ACPI_RESOURCE_NAME_LARGE) {
+		return (sizeof(struct aml_resource_large_header));
+	} else {
+		return (sizeof(struct aml_resource_small_header));
+	}
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_get_descriptor_length
+ *
+ * PARAMETERS:  Aml             - Pointer to the raw AML resource descriptor
+ *
+ * RETURN:      Byte length
+ *
+ * DESCRIPTION: Get the total byte length of a raw AML descriptor, including the
+ *              length of the descriptor header and the length field itself.
+ *              Used to walk descriptor lists.
+ *
+ ******************************************************************************/
+
+u32 acpi_ut_get_descriptor_length(void *aml)
+{
+	ACPI_FUNCTION_ENTRY();
+
+	/*
+	 * Get the Resource Length (does not include header length) and add
+	 * the header length (depends on if this is a small or large resource)
+	 */
+	return (acpi_ut_get_resource_length(aml) +
+		acpi_ut_get_resource_header_length(aml));
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_get_resource_end_tag
+ *
+ * PARAMETERS:  obj_desc        - The resource template buffer object
+ *              end_tag         - Where the pointer to the end_tag is returned
+ *
+ * RETURN:      Status, pointer to the end tag
+ *
+ * DESCRIPTION: Find the end_tag resource descriptor in an AML resource template
+ *              Note: allows a buffer length of zero.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ut_get_resource_end_tag(union acpi_operand_object *obj_desc, u8 **end_tag)
+{
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(ut_get_resource_end_tag);
+
+	/* Allow a buffer length of zero */
+
+	if (!obj_desc->buffer.length) {
+		*end_tag = obj_desc->buffer.pointer;
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	/* Validate the template and get a pointer to the end_tag */
+
+	status = acpi_ut_walk_aml_resources(obj_desc->buffer.pointer,
+					    obj_desc->buffer.length, NULL,
+					    end_tag);
+
+	return_ACPI_STATUS(status);
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utstate.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utstate.c
new file mode 100644
index 00000000..89da142c
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utstate.c
@@ -0,0 +1,346 @@
+/*******************************************************************************
+ *
+ * Module Name: utstate - state object support procedures
+ *
+ ******************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+
+#define _COMPONENT          ACPI_UTILITIES
+ACPI_MODULE_NAME("utstate")
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_create_pkg_state_and_push
+ *
+ * PARAMETERS:  Object          - Object to be added to the new state
+ *              Action          - Increment/Decrement
+ *              state_list      - List the state will be added to
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Create a new state and push it
+ *
+ ******************************************************************************/
+acpi_status
+acpi_ut_create_pkg_state_and_push(void *internal_object,
+				  void *external_object,
+				  u16 index,
+				  union acpi_generic_state **state_list)
+{
+	union acpi_generic_state *state;
+
+	ACPI_FUNCTION_ENTRY();
+
+	state =
+	    acpi_ut_create_pkg_state(internal_object, external_object, index);
+	if (!state) {
+		return (AE_NO_MEMORY);
+	}
+
+	acpi_ut_push_generic_state(state_list, state);
+	return (AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_push_generic_state
+ *
+ * PARAMETERS:  list_head           - Head of the state stack
+ *              State               - State object to push
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Push a state object onto a state stack
+ *
+ ******************************************************************************/
+
+void
+acpi_ut_push_generic_state(union acpi_generic_state **list_head,
+			   union acpi_generic_state *state)
+{
+	ACPI_FUNCTION_TRACE(ut_push_generic_state);
+
+	/* Push the state object onto the front of the list (stack) */
+
+	state->common.next = *list_head;
+	*list_head = state;
+
+	return_VOID;
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_pop_generic_state
+ *
+ * PARAMETERS:  list_head           - Head of the state stack
+ *
+ * RETURN:      The popped state object
+ *
+ * DESCRIPTION: Pop a state object from a state stack
+ *
+ ******************************************************************************/
+
+union acpi_generic_state *acpi_ut_pop_generic_state(union acpi_generic_state
+						    **list_head)
+{
+	union acpi_generic_state *state;
+
+	ACPI_FUNCTION_TRACE(ut_pop_generic_state);
+
+	/* Remove the state object at the head of the list (stack) */
+
+	state = *list_head;
+	if (state) {
+
+		/* Update the list head */
+
+		*list_head = state->common.next;
+	}
+
+	return_PTR(state);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_create_generic_state
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      The new state object. NULL on failure.
+ *
+ * DESCRIPTION: Create a generic state object.  Attempt to obtain one from
+ *              the global state cache;  If none available, create a new one.
+ *
+ ******************************************************************************/
+
+union acpi_generic_state *acpi_ut_create_generic_state(void)
+{
+	union acpi_generic_state *state;
+
+	ACPI_FUNCTION_ENTRY();
+
+	state = acpi_os_acquire_object(acpi_gbl_state_cache);
+	if (state) {
+
+		/* Initialize */
+		state->common.descriptor_type = ACPI_DESC_TYPE_STATE;
+	}
+
+	return (state);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_create_thread_state
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      New Thread State. NULL on failure
+ *
+ * DESCRIPTION: Create a "Thread State" - a flavor of the generic state used
+ *              to track per-thread info during method execution
+ *
+ ******************************************************************************/
+
+struct acpi_thread_state *acpi_ut_create_thread_state(void)
+{
+	union acpi_generic_state *state;
+
+	ACPI_FUNCTION_TRACE(ut_create_thread_state);
+
+	/* Create the generic state object */
+
+	state = acpi_ut_create_generic_state();
+	if (!state) {
+		return_PTR(NULL);
+	}
+
+	/* Init fields specific to the update struct */
+
+	state->common.descriptor_type = ACPI_DESC_TYPE_STATE_THREAD;
+	state->thread.thread_id = acpi_os_get_thread_id();
+
+	/* Check for invalid thread ID - zero is very bad, it will break things */
+
+	if (!state->thread.thread_id) {
+		ACPI_ERROR((AE_INFO, "Invalid zero ID from AcpiOsGetThreadId"));
+		state->thread.thread_id = (acpi_thread_id) 1;
+	}
+
+	return_PTR((struct acpi_thread_state *)state);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_create_update_state
+ *
+ * PARAMETERS:  Object          - Initial Object to be installed in the state
+ *              Action          - Update action to be performed
+ *
+ * RETURN:      New state object, null on failure
+ *
+ * DESCRIPTION: Create an "Update State" - a flavor of the generic state used
+ *              to update reference counts and delete complex objects such
+ *              as packages.
+ *
+ ******************************************************************************/
+
+union acpi_generic_state *acpi_ut_create_update_state(union acpi_operand_object
+						      *object, u16 action)
+{
+	union acpi_generic_state *state;
+
+	ACPI_FUNCTION_TRACE_PTR(ut_create_update_state, object);
+
+	/* Create the generic state object */
+
+	state = acpi_ut_create_generic_state();
+	if (!state) {
+		return_PTR(NULL);
+	}
+
+	/* Init fields specific to the update struct */
+
+	state->common.descriptor_type = ACPI_DESC_TYPE_STATE_UPDATE;
+	state->update.object = object;
+	state->update.value = action;
+
+	return_PTR(state);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_create_pkg_state
+ *
+ * PARAMETERS:  Object          - Initial Object to be installed in the state
+ *              Action          - Update action to be performed
+ *
+ * RETURN:      New state object, null on failure
+ *
+ * DESCRIPTION: Create a "Package State"
+ *
+ ******************************************************************************/
+
+union acpi_generic_state *acpi_ut_create_pkg_state(void *internal_object,
+						   void *external_object,
+						   u16 index)
+{
+	union acpi_generic_state *state;
+
+	ACPI_FUNCTION_TRACE_PTR(ut_create_pkg_state, internal_object);
+
+	/* Create the generic state object */
+
+	state = acpi_ut_create_generic_state();
+	if (!state) {
+		return_PTR(NULL);
+	}
+
+	/* Init fields specific to the update struct */
+
+	state->common.descriptor_type = ACPI_DESC_TYPE_STATE_PACKAGE;
+	state->pkg.source_object = (union acpi_operand_object *)internal_object;
+	state->pkg.dest_object = external_object;
+	state->pkg.index = index;
+	state->pkg.num_packages = 1;
+
+	return_PTR(state);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_create_control_state
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      New state object, null on failure
+ *
+ * DESCRIPTION: Create a "Control State" - a flavor of the generic state used
+ *              to support nested IF/WHILE constructs in the AML.
+ *
+ ******************************************************************************/
+
+union acpi_generic_state *acpi_ut_create_control_state(void)
+{
+	union acpi_generic_state *state;
+
+	ACPI_FUNCTION_TRACE(ut_create_control_state);
+
+	/* Create the generic state object */
+
+	state = acpi_ut_create_generic_state();
+	if (!state) {
+		return_PTR(NULL);
+	}
+
+	/* Init fields specific to the control struct */
+
+	state->common.descriptor_type = ACPI_DESC_TYPE_STATE_CONTROL;
+	state->common.state = ACPI_CONTROL_CONDITIONAL_EXECUTING;
+
+	return_PTR(state);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_delete_generic_state
+ *
+ * PARAMETERS:  State               - The state object to be deleted
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Release a state object to the state cache. NULL state objects
+ *              are ignored.
+ *
+ ******************************************************************************/
+
+void acpi_ut_delete_generic_state(union acpi_generic_state *state)
+{
+	ACPI_FUNCTION_TRACE(ut_delete_generic_state);
+
+	/* Ignore null state */
+
+	if (state) {
+		(void)acpi_os_release_object(acpi_gbl_state_cache, state);
+	}
+	return_VOID;
+}
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/uttrack.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/uttrack.c
new file mode 100644
index 00000000..34bd68b6
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/uttrack.c
@@ -0,0 +1,648 @@
+/******************************************************************************
+ *
+ * Module Name: uttrack - Memory allocation tracking routines (debug only)
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+/*
+ * These procedures are used for tracking memory leaks in the subsystem, and
+ * they get compiled out when the ACPI_DBG_TRACK_ALLOCATIONS is not set.
+ *
+ * Each memory allocation is tracked via a doubly linked list.  Each
+ * element contains the caller's component, module name, function name, and
+ * line number.  acpi_ut_allocate and acpi_ut_allocate_zeroed call
+ * acpi_ut_track_allocation to add an element to the list; deletion
+ * occurs in the body of acpi_ut_free.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+
+#ifdef ACPI_DBG_TRACK_ALLOCATIONS
+
+#define _COMPONENT          ACPI_UTILITIES
+ACPI_MODULE_NAME("uttrack")
+
+/* Local prototypes */
+static struct acpi_debug_mem_block *acpi_ut_find_allocation(void *allocation);
+
+static acpi_status
+acpi_ut_track_allocation(struct acpi_debug_mem_block *address,
+			 acpi_size size,
+			 u8 alloc_type,
+			 u32 component, const char *module, u32 line);
+
+static acpi_status
+acpi_ut_remove_allocation(struct acpi_debug_mem_block *address,
+			  u32 component, const char *module, u32 line);
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_create_list
+ *
+ * PARAMETERS:  cache_name      - Ascii name for the cache
+ *              object_size     - Size of each cached object
+ *              return_cache    - Where the new cache object is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Create a local memory list for tracking purposed
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ut_create_list(char *list_name,
+		    u16 object_size, struct acpi_memory_list **return_cache)
+{
+	struct acpi_memory_list *cache;
+
+	cache = acpi_os_allocate(sizeof(struct acpi_memory_list));
+	if (!cache) {
+		return (AE_NO_MEMORY);
+	}
+
+	ACPI_MEMSET(cache, 0, sizeof(struct acpi_memory_list));
+
+	cache->list_name = list_name;
+	cache->object_size = object_size;
+
+	*return_cache = cache;
+	return (AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_allocate_and_track
+ *
+ * PARAMETERS:  Size                - Size of the allocation
+ *              Component           - Component type of caller
+ *              Module              - Source file name of caller
+ *              Line                - Line number of caller
+ *
+ * RETURN:      Address of the allocated memory on success, NULL on failure.
+ *
+ * DESCRIPTION: The subsystem's equivalent of malloc.
+ *
+ ******************************************************************************/
+
+void *acpi_ut_allocate_and_track(acpi_size size,
+				 u32 component, const char *module, u32 line)
+{
+	struct acpi_debug_mem_block *allocation;
+	acpi_status status;
+
+	allocation =
+	    acpi_ut_allocate(size + sizeof(struct acpi_debug_mem_header),
+			     component, module, line);
+	if (!allocation) {
+		return (NULL);
+	}
+
+	status = acpi_ut_track_allocation(allocation, size,
+					  ACPI_MEM_MALLOC, component, module,
+					  line);
+	if (ACPI_FAILURE(status)) {
+		acpi_os_free(allocation);
+		return (NULL);
+	}
+
+	acpi_gbl_global_list->total_allocated++;
+	acpi_gbl_global_list->total_size += (u32)size;
+	acpi_gbl_global_list->current_total_size += (u32)size;
+	if (acpi_gbl_global_list->current_total_size >
+	    acpi_gbl_global_list->max_occupied) {
+		acpi_gbl_global_list->max_occupied =
+		    acpi_gbl_global_list->current_total_size;
+	}
+
+	return ((void *)&allocation->user_space);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_allocate_zeroed_and_track
+ *
+ * PARAMETERS:  Size                - Size of the allocation
+ *              Component           - Component type of caller
+ *              Module              - Source file name of caller
+ *              Line                - Line number of caller
+ *
+ * RETURN:      Address of the allocated memory on success, NULL on failure.
+ *
+ * DESCRIPTION: Subsystem equivalent of calloc.
+ *
+ ******************************************************************************/
+
+void *acpi_ut_allocate_zeroed_and_track(acpi_size size,
+					u32 component,
+					const char *module, u32 line)
+{
+	struct acpi_debug_mem_block *allocation;
+	acpi_status status;
+
+	allocation =
+	    acpi_ut_allocate_zeroed(size + sizeof(struct acpi_debug_mem_header),
+				    component, module, line);
+	if (!allocation) {
+
+		/* Report allocation error */
+
+		ACPI_ERROR((module, line,
+			    "Could not allocate size %u", (u32)size));
+		return (NULL);
+	}
+
+	status = acpi_ut_track_allocation(allocation, size,
+					  ACPI_MEM_CALLOC, component, module,
+					  line);
+	if (ACPI_FAILURE(status)) {
+		acpi_os_free(allocation);
+		return (NULL);
+	}
+
+	acpi_gbl_global_list->total_allocated++;
+	acpi_gbl_global_list->total_size += (u32)size;
+	acpi_gbl_global_list->current_total_size += (u32)size;
+	if (acpi_gbl_global_list->current_total_size >
+	    acpi_gbl_global_list->max_occupied) {
+		acpi_gbl_global_list->max_occupied =
+		    acpi_gbl_global_list->current_total_size;
+	}
+
+	return ((void *)&allocation->user_space);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_free_and_track
+ *
+ * PARAMETERS:  Allocation          - Address of the memory to deallocate
+ *              Component           - Component type of caller
+ *              Module              - Source file name of caller
+ *              Line                - Line number of caller
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Frees the memory at Allocation
+ *
+ ******************************************************************************/
+
+void
+acpi_ut_free_and_track(void *allocation,
+		       u32 component, const char *module, u32 line)
+{
+	struct acpi_debug_mem_block *debug_block;
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE_PTR(ut_free, allocation);
+
+	if (NULL == allocation) {
+		ACPI_ERROR((module, line, "Attempt to delete a NULL address"));
+
+		return_VOID;
+	}
+
+	debug_block = ACPI_CAST_PTR(struct acpi_debug_mem_block,
+				    (((char *)allocation) -
+				     sizeof(struct acpi_debug_mem_header)));
+
+	acpi_gbl_global_list->total_freed++;
+	acpi_gbl_global_list->current_total_size -= debug_block->size;
+
+	status = acpi_ut_remove_allocation(debug_block,
+					   component, module, line);
+	if (ACPI_FAILURE(status)) {
+		ACPI_EXCEPTION((AE_INFO, status, "Could not free memory"));
+	}
+
+	acpi_os_free(debug_block);
+	ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS, "%p freed\n", allocation));
+	return_VOID;
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_find_allocation
+ *
+ * PARAMETERS:  Allocation              - Address of allocated memory
+ *
+ * RETURN:      A list element if found; NULL otherwise.
+ *
+ * DESCRIPTION: Searches for an element in the global allocation tracking list.
+ *
+ ******************************************************************************/
+
+static struct acpi_debug_mem_block *acpi_ut_find_allocation(void *allocation)
+{
+	struct acpi_debug_mem_block *element;
+
+	ACPI_FUNCTION_ENTRY();
+
+	element = acpi_gbl_global_list->list_head;
+
+	/* Search for the address. */
+
+	while (element) {
+		if (element == allocation) {
+			return (element);
+		}
+
+		element = element->next;
+	}
+
+	return (NULL);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_track_allocation
+ *
+ * PARAMETERS:  Allocation          - Address of allocated memory
+ *              Size                - Size of the allocation
+ *              alloc_type          - MEM_MALLOC or MEM_CALLOC
+ *              Component           - Component type of caller
+ *              Module              - Source file name of caller
+ *              Line                - Line number of caller
+ *
+ * RETURN:      None.
+ *
+ * DESCRIPTION: Inserts an element into the global allocation tracking list.
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ut_track_allocation(struct acpi_debug_mem_block *allocation,
+			 acpi_size size,
+			 u8 alloc_type,
+			 u32 component, const char *module, u32 line)
+{
+	struct acpi_memory_list *mem_list;
+	struct acpi_debug_mem_block *element;
+	acpi_status status = AE_OK;
+
+	ACPI_FUNCTION_TRACE_PTR(ut_track_allocation, allocation);
+
+	if (acpi_gbl_disable_mem_tracking) {
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	mem_list = acpi_gbl_global_list;
+	status = acpi_ut_acquire_mutex(ACPI_MTX_MEMORY);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/*
+	 * Search list for this address to make sure it is not already on the list.
+	 * This will catch several kinds of problems.
+	 */
+	element = acpi_ut_find_allocation(allocation);
+	if (element) {
+		ACPI_ERROR((AE_INFO,
+			    "UtTrackAllocation: Allocation already present in list! (%p)",
+			    allocation));
+
+		ACPI_ERROR((AE_INFO, "Element %p Address %p",
+			    element, allocation));
+
+		goto unlock_and_exit;
+	}
+
+	/* Fill in the instance data. */
+
+	allocation->size = (u32)size;
+	allocation->alloc_type = alloc_type;
+	allocation->component = component;
+	allocation->line = line;
+
+	ACPI_STRNCPY(allocation->module, module, ACPI_MAX_MODULE_NAME);
+	allocation->module[ACPI_MAX_MODULE_NAME - 1] = 0;
+
+	/* Insert at list head */
+
+	if (mem_list->list_head) {
+		((struct acpi_debug_mem_block *)(mem_list->list_head))->
+		    previous = allocation;
+	}
+
+	allocation->next = mem_list->list_head;
+	allocation->previous = NULL;
+
+	mem_list->list_head = allocation;
+
+      unlock_and_exit:
+	status = acpi_ut_release_mutex(ACPI_MTX_MEMORY);
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_remove_allocation
+ *
+ * PARAMETERS:  Allocation          - Address of allocated memory
+ *              Component           - Component type of caller
+ *              Module              - Source file name of caller
+ *              Line                - Line number of caller
+ *
+ * RETURN:
+ *
+ * DESCRIPTION: Deletes an element from the global allocation tracking list.
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ut_remove_allocation(struct acpi_debug_mem_block *allocation,
+			  u32 component, const char *module, u32 line)
+{
+	struct acpi_memory_list *mem_list;
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(ut_remove_allocation);
+
+	if (acpi_gbl_disable_mem_tracking) {
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	mem_list = acpi_gbl_global_list;
+	if (NULL == mem_list->list_head) {
+
+		/* No allocations! */
+
+		ACPI_ERROR((module, line,
+			    "Empty allocation list, nothing to free!"));
+
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	status = acpi_ut_acquire_mutex(ACPI_MTX_MEMORY);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/* Unlink */
+
+	if (allocation->previous) {
+		(allocation->previous)->next = allocation->next;
+	} else {
+		mem_list->list_head = allocation->next;
+	}
+
+	if (allocation->next) {
+		(allocation->next)->previous = allocation->previous;
+	}
+
+	/* Mark the segment as deleted */
+
+	ACPI_MEMSET(&allocation->user_space, 0xEA, allocation->size);
+
+	ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS, "Freeing size 0%X\n",
+			  allocation->size));
+
+	status = acpi_ut_release_mutex(ACPI_MTX_MEMORY);
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_dump_allocation_info
+ *
+ * PARAMETERS:
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Print some info about the outstanding allocations.
+ *
+ ******************************************************************************/
+
+void acpi_ut_dump_allocation_info(void)
+{
+/*
+	struct acpi_memory_list         *mem_list;
+*/
+
+	ACPI_FUNCTION_TRACE(ut_dump_allocation_info);
+
+/*
+	ACPI_DEBUG_PRINT (TRACE_ALLOCATIONS | TRACE_TABLES,
+			  ("%30s: %4d (%3d Kb)\n", "Current allocations",
+			  mem_list->current_count,
+			  ROUND_UP_TO_1K (mem_list->current_size)));
+
+	ACPI_DEBUG_PRINT (TRACE_ALLOCATIONS | TRACE_TABLES,
+			  ("%30s: %4d (%3d Kb)\n", "Max concurrent allocations",
+			  mem_list->max_concurrent_count,
+			  ROUND_UP_TO_1K (mem_list->max_concurrent_size)));
+
+	ACPI_DEBUG_PRINT (TRACE_ALLOCATIONS | TRACE_TABLES,
+			  ("%30s: %4d (%3d Kb)\n", "Total (all) internal objects",
+			  running_object_count,
+			  ROUND_UP_TO_1K (running_object_size)));
+
+	ACPI_DEBUG_PRINT (TRACE_ALLOCATIONS | TRACE_TABLES,
+			  ("%30s: %4d (%3d Kb)\n", "Total (all) allocations",
+			  running_alloc_count,
+			  ROUND_UP_TO_1K (running_alloc_size)));
+
+	ACPI_DEBUG_PRINT (TRACE_ALLOCATIONS | TRACE_TABLES,
+			  ("%30s: %4d (%3d Kb)\n", "Current Nodes",
+			  acpi_gbl_current_node_count,
+			  ROUND_UP_TO_1K (acpi_gbl_current_node_size)));
+
+	ACPI_DEBUG_PRINT (TRACE_ALLOCATIONS | TRACE_TABLES,
+			  ("%30s: %4d (%3d Kb)\n", "Max Nodes",
+			  acpi_gbl_max_concurrent_node_count,
+			  ROUND_UP_TO_1K ((acpi_gbl_max_concurrent_node_count *
+					 sizeof (struct acpi_namespace_node)))));
+*/
+	return_VOID;
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_dump_allocations
+ *
+ * PARAMETERS:  Component           - Component(s) to dump info for.
+ *              Module              - Module to dump info for.  NULL means all.
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Print a list of all outstanding allocations.
+ *
+ ******************************************************************************/
+
+void acpi_ut_dump_allocations(u32 component, const char *module)
+{
+	struct acpi_debug_mem_block *element;
+	union acpi_descriptor *descriptor;
+	u32 num_outstanding = 0;
+	u8 descriptor_type;
+
+	ACPI_FUNCTION_TRACE(ut_dump_allocations);
+
+	if (acpi_gbl_disable_mem_tracking) {
+		return;
+	}
+
+	/*
+	 * Walk the allocation list.
+	 */
+	if (ACPI_FAILURE(acpi_ut_acquire_mutex(ACPI_MTX_MEMORY))) {
+		return;
+	}
+
+	element = acpi_gbl_global_list->list_head;
+	while (element) {
+		if ((element->component & component) &&
+		    ((module == NULL)
+		     || (0 == ACPI_STRCMP(module, element->module)))) {
+			descriptor =
+			    ACPI_CAST_PTR(union acpi_descriptor,
+					  &element->user_space);
+
+			if (element->size <
+			    sizeof(struct acpi_common_descriptor)) {
+				acpi_os_printf("%p Length 0x%04X %9.9s-%u "
+					       "[Not a Descriptor - too small]\n",
+					       descriptor, element->size,
+					       element->module, element->line);
+			} else {
+				/* Ignore allocated objects that are in a cache */
+
+				if (ACPI_GET_DESCRIPTOR_TYPE(descriptor) !=
+				    ACPI_DESC_TYPE_CACHED) {
+					acpi_os_printf
+					    ("%p Length 0x%04X %9.9s-%u [%s] ",
+					     descriptor, element->size,
+					     element->module, element->line,
+					     acpi_ut_get_descriptor_name
+					     (descriptor));
+
+					/* Validate the descriptor type using Type field and length */
+
+					descriptor_type = 0;	/* Not a valid descriptor type */
+
+					switch (ACPI_GET_DESCRIPTOR_TYPE
+						(descriptor)) {
+					case ACPI_DESC_TYPE_OPERAND:
+						if (element->size ==
+						    sizeof
+						    (ACPI_DESC_TYPE_OPERAND)) {
+							descriptor_type =
+							    ACPI_DESC_TYPE_OPERAND;
+						}
+						break;
+
+					case ACPI_DESC_TYPE_PARSER:
+						if (element->size ==
+						    sizeof
+						    (ACPI_DESC_TYPE_PARSER)) {
+							descriptor_type =
+							    ACPI_DESC_TYPE_PARSER;
+						}
+						break;
+
+					case ACPI_DESC_TYPE_NAMED:
+						if (element->size ==
+						    sizeof
+						    (ACPI_DESC_TYPE_NAMED)) {
+							descriptor_type =
+							    ACPI_DESC_TYPE_NAMED;
+						}
+						break;
+
+					default:
+						break;
+					}
+
+					/* Display additional info for the major descriptor types */
+
+					switch (descriptor_type) {
+					case ACPI_DESC_TYPE_OPERAND:
+						acpi_os_printf
+						    ("%12.12s RefCount 0x%04X\n",
+						     acpi_ut_get_type_name
+						     (descriptor->object.common.
+						      type),
+						     descriptor->object.common.
+						     reference_count);
+						break;
+
+					case ACPI_DESC_TYPE_PARSER:
+						acpi_os_printf
+						    ("AmlOpcode 0x%04hX\n",
+						     descriptor->op.asl.
+						     aml_opcode);
+						break;
+
+					case ACPI_DESC_TYPE_NAMED:
+						acpi_os_printf("%4.4s\n",
+							       acpi_ut_get_node_name
+							       (&descriptor->
+								node));
+						break;
+
+					default:
+						acpi_os_printf("\n");
+						break;
+					}
+				}
+			}
+
+			num_outstanding++;
+		}
+
+		element = element->next;
+	}
+
+	(void)acpi_ut_release_mutex(ACPI_MTX_MEMORY);
+
+	/* Print summary */
+
+	if (!num_outstanding) {
+		ACPI_INFO((AE_INFO, "No outstanding allocations"));
+	} else {
+		ACPI_ERROR((AE_INFO, "%u(0x%X) Outstanding allocations",
+			    num_outstanding, num_outstanding));
+	}
+
+	return_VOID;
+}
+
+#endif				/* ACPI_DBG_TRACK_ALLOCATIONS */
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utxface.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utxface.c
new file mode 100644
index 00000000..6c725d5f
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utxface.c
@@ -0,0 +1,720 @@
+/******************************************************************************
+ *
+ * Module Name: utxface - External interfaces for "global" ACPI functions
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acevents.h"
+#include "acnamesp.h"
+#include "acdebug.h"
+#include "actables.h"
+#include "acinterp.h"
+
+#define _COMPONENT          ACPI_UTILITIES
+ACPI_MODULE_NAME("utxface")
+
+#ifndef ACPI_ASL_COMPILER
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_initialize_subsystem
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Initializes all global variables.  This is the first function
+ *              called, so any early initialization belongs here.
+ *
+ ******************************************************************************/
+acpi_status acpi_initialize_subsystem(void)
+{
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(acpi_initialize_subsystem);
+
+	acpi_gbl_startup_flags = ACPI_SUBSYSTEM_INITIALIZE;
+	ACPI_DEBUG_EXEC(acpi_ut_init_stack_ptr_trace());
+
+	/* Initialize the OS-Dependent layer */
+
+	status = acpi_os_initialize();
+	if (ACPI_FAILURE(status)) {
+		ACPI_EXCEPTION((AE_INFO, status, "During OSL initialization"));
+		return_ACPI_STATUS(status);
+	}
+
+	/* Initialize all globals used by the subsystem */
+
+	status = acpi_ut_init_globals();
+	if (ACPI_FAILURE(status)) {
+		ACPI_EXCEPTION((AE_INFO, status,
+				"During initialization of globals"));
+		return_ACPI_STATUS(status);
+	}
+
+	/* Create the default mutex objects */
+
+	status = acpi_ut_mutex_initialize();
+	if (ACPI_FAILURE(status)) {
+		ACPI_EXCEPTION((AE_INFO, status,
+				"During Global Mutex creation"));
+		return_ACPI_STATUS(status);
+	}
+
+	/*
+	 * Initialize the namespace manager and
+	 * the root of the namespace tree
+	 */
+	status = acpi_ns_root_initialize();
+	if (ACPI_FAILURE(status)) {
+		ACPI_EXCEPTION((AE_INFO, status,
+				"During Namespace initialization"));
+		return_ACPI_STATUS(status);
+	}
+
+	/* Initialize the global OSI interfaces list with the static names */
+
+	status = acpi_ut_initialize_interfaces();
+	if (ACPI_FAILURE(status)) {
+		ACPI_EXCEPTION((AE_INFO, status,
+				"During OSI interfaces initialization"));
+		return_ACPI_STATUS(status);
+	}
+
+	/* If configured, initialize the AML debugger */
+
+	ACPI_DEBUGGER_EXEC(status = acpi_db_initialize());
+	return_ACPI_STATUS(status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_initialize_subsystem)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_enable_subsystem
+ *
+ * PARAMETERS:  Flags           - Init/enable Options
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Completes the subsystem initialization including hardware.
+ *              Puts system into ACPI mode if it isn't already.
+ *
+ ******************************************************************************/
+acpi_status acpi_enable_subsystem(u32 flags)
+{
+	acpi_status status = AE_OK;
+
+	ACPI_FUNCTION_TRACE(acpi_enable_subsystem);
+
+	/* Enable ACPI mode */
+
+	if (!(flags & ACPI_NO_ACPI_ENABLE)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
+				  "[Init] Going into ACPI mode\n"));
+
+		acpi_gbl_original_mode = acpi_hw_get_mode();
+
+		status = acpi_enable();
+		if (ACPI_FAILURE(status)) {
+			ACPI_WARNING((AE_INFO, "AcpiEnable failed"));
+			return_ACPI_STATUS(status);
+		}
+	}
+
+	/*
+	 * Obtain a permanent mapping for the FACS. This is required for the
+	 * Global Lock and the Firmware Waking Vector
+	 */
+	status = acpi_tb_initialize_facs();
+	if (ACPI_FAILURE(status)) {
+		ACPI_WARNING((AE_INFO, "Could not map the FACS table"));
+		return_ACPI_STATUS(status);
+	}
+
+	/*
+	 * Install the default op_region handlers. These are installed unless
+	 * other handlers have already been installed via the
+	 * install_address_space_handler interface.
+	 */
+	if (!(flags & ACPI_NO_ADDRESS_SPACE_INIT)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
+				  "[Init] Installing default address space handlers\n"));
+
+		status = acpi_ev_install_region_handlers();
+		if (ACPI_FAILURE(status)) {
+			return_ACPI_STATUS(status);
+		}
+	}
+
+	/*
+	 * Initialize ACPI Event handling (Fixed and General Purpose)
+	 *
+	 * Note1: We must have the hardware and events initialized before we can
+	 * execute any control methods safely. Any control method can require
+	 * ACPI hardware support, so the hardware must be fully initialized before
+	 * any method execution!
+	 *
+	 * Note2: Fixed events are initialized and enabled here. GPEs are
+	 * initialized, but cannot be enabled until after the hardware is
+	 * completely initialized (SCI and global_lock activated) and the various
+	 * initialization control methods are run (_REG, _STA, _INI) on the
+	 * entire namespace.
+	 */
+	if (!(flags & ACPI_NO_EVENT_INIT)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
+				  "[Init] Initializing ACPI events\n"));
+
+		status = acpi_ev_initialize_events();
+		if (ACPI_FAILURE(status)) {
+			return_ACPI_STATUS(status);
+		}
+	}
+
+	/*
+	 * Install the SCI handler and Global Lock handler. This completes the
+	 * hardware initialization.
+	 */
+	if (!(flags & ACPI_NO_HANDLER_INIT)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
+				  "[Init] Installing SCI/GL handlers\n"));
+
+		status = acpi_ev_install_xrupt_handlers();
+		if (ACPI_FAILURE(status)) {
+			return_ACPI_STATUS(status);
+		}
+	}
+
+	return_ACPI_STATUS(status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_enable_subsystem)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_initialize_objects
+ *
+ * PARAMETERS:  Flags           - Init/enable Options
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Completes namespace initialization by initializing device
+ *              objects and executing AML code for Regions, buffers, etc.
+ *
+ ******************************************************************************/
+acpi_status acpi_initialize_objects(u32 flags)
+{
+	acpi_status status = AE_OK;
+
+	ACPI_FUNCTION_TRACE(acpi_initialize_objects);
+
+	/*
+	 * Run all _REG methods
+	 *
+	 * Note: Any objects accessed by the _REG methods will be automatically
+	 * initialized, even if they contain executable AML (see the call to
+	 * acpi_ns_initialize_objects below).
+	 */
+	if (!(flags & ACPI_NO_ADDRESS_SPACE_INIT)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
+				  "[Init] Executing _REG OpRegion methods\n"));
+
+		status = acpi_ev_initialize_op_regions();
+		if (ACPI_FAILURE(status)) {
+			return_ACPI_STATUS(status);
+		}
+	}
+
+	/*
+	 * Execute any module-level code that was detected during the table load
+	 * phase. Although illegal since ACPI 2.0, there are many machines that
+	 * contain this type of code. Each block of detected executable AML code
+	 * outside of any control method is wrapped with a temporary control
+	 * method object and placed on a global list. The methods on this list
+	 * are executed below.
+	 */
+	acpi_ns_exec_module_code_list();
+
+	/*
+	 * Initialize the objects that remain uninitialized. This runs the
+	 * executable AML that may be part of the declaration of these objects:
+	 * operation_regions, buffer_fields, Buffers, and Packages.
+	 */
+	if (!(flags & ACPI_NO_OBJECT_INIT)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
+				  "[Init] Completing Initialization of ACPI Objects\n"));
+
+		status = acpi_ns_initialize_objects();
+		if (ACPI_FAILURE(status)) {
+			return_ACPI_STATUS(status);
+		}
+	}
+
+	/*
+	 * Initialize all device objects in the namespace. This runs the device
+	 * _STA and _INI methods.
+	 */
+	if (!(flags & ACPI_NO_DEVICE_INIT)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
+				  "[Init] Initializing ACPI Devices\n"));
+
+		status = acpi_ns_initialize_devices();
+		if (ACPI_FAILURE(status)) {
+			return_ACPI_STATUS(status);
+		}
+	}
+
+	/*
+	 * Empty the caches (delete the cached objects) on the assumption that
+	 * the table load filled them up more than they will be at runtime --
+	 * thus wasting non-paged memory.
+	 */
+	status = acpi_purge_cached_objects();
+
+	acpi_gbl_startup_flags |= ACPI_INITIALIZED_OK;
+	return_ACPI_STATUS(status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_initialize_objects)
+
+#endif
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_terminate
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Shutdown the ACPICA subsystem and release all resources.
+ *
+ ******************************************************************************/
+acpi_status acpi_terminate(void)
+{
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(acpi_terminate);
+
+	/* Just exit if subsystem is already shutdown */
+
+	if (acpi_gbl_shutdown) {
+		ACPI_ERROR((AE_INFO, "ACPI Subsystem is already terminated"));
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	/* Subsystem appears active, go ahead and shut it down */
+
+	acpi_gbl_shutdown = TRUE;
+	acpi_gbl_startup_flags = 0;
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Shutting down ACPI Subsystem\n"));
+
+	/* Terminate the AML Debugger if present */
+
+	ACPI_DEBUGGER_EXEC(acpi_gbl_db_terminate_threads = TRUE);
+
+	/* Shutdown and free all resources */
+
+	acpi_ut_subsystem_shutdown();
+
+	/* Free the mutex objects */
+
+	acpi_ut_mutex_terminate();
+
+#ifdef ACPI_DEBUGGER
+
+	/* Shut down the debugger */
+
+	acpi_db_terminate();
+#endif
+
+	/* Now we can shutdown the OS-dependent layer */
+
+	status = acpi_os_terminate();
+	return_ACPI_STATUS(status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_terminate)
+
+#ifndef ACPI_ASL_COMPILER
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_subsystem_status
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status of the ACPI subsystem
+ *
+ * DESCRIPTION: Other drivers that use the ACPI subsystem should call this
+ *              before making any other calls, to ensure the subsystem
+ *              initialized successfully.
+ *
+ ******************************************************************************/
+acpi_status acpi_subsystem_status(void)
+{
+
+	if (acpi_gbl_startup_flags & ACPI_INITIALIZED_OK) {
+		return (AE_OK);
+	} else {
+		return (AE_ERROR);
+	}
+}
+
+ACPI_EXPORT_SYMBOL(acpi_subsystem_status)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_get_system_info
+ *
+ * PARAMETERS:  out_buffer      - A buffer to receive the resources for the
+ *                                device
+ *
+ * RETURN:      Status          - the status of the call
+ *
+ * DESCRIPTION: This function is called to get information about the current
+ *              state of the ACPI subsystem.  It will return system information
+ *              in the out_buffer.
+ *
+ *              If the function fails an appropriate status will be returned
+ *              and the value of out_buffer is undefined.
+ *
+ ******************************************************************************/
+acpi_status acpi_get_system_info(struct acpi_buffer * out_buffer)
+{
+	struct acpi_system_info *info_ptr;
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE(acpi_get_system_info);
+
+	/* Parameter validation */
+
+	status = acpi_ut_validate_buffer(out_buffer);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/* Validate/Allocate/Clear caller buffer */
+
+	status =
+	    acpi_ut_initialize_buffer(out_buffer,
+				      sizeof(struct acpi_system_info));
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/*
+	 * Populate the return buffer
+	 */
+	info_ptr = (struct acpi_system_info *)out_buffer->pointer;
+
+	info_ptr->acpi_ca_version = ACPI_CA_VERSION;
+
+	/* System flags (ACPI capabilities) */
+
+	info_ptr->flags = ACPI_SYS_MODE_ACPI;
+
+	/* Timer resolution - 24 or 32 bits  */
+
+	if (acpi_gbl_FADT.flags & ACPI_FADT_32BIT_TIMER) {
+		info_ptr->timer_resolution = 24;
+	} else {
+		info_ptr->timer_resolution = 32;
+	}
+
+	/* Clear the reserved fields */
+
+	info_ptr->reserved1 = 0;
+	info_ptr->reserved2 = 0;
+
+	/* Current debug levels */
+
+	info_ptr->debug_layer = acpi_dbg_layer;
+	info_ptr->debug_level = acpi_dbg_level;
+
+	return_ACPI_STATUS(AE_OK);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_get_system_info)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_get_statistics
+ *
+ * PARAMETERS:  Stats           - Where the statistics are returned
+ *
+ * RETURN:      Status          - the status of the call
+ *
+ * DESCRIPTION: Get the contents of the various system counters
+ *
+ ******************************************************************************/
+acpi_status acpi_get_statistics(struct acpi_statistics *stats)
+{
+	ACPI_FUNCTION_TRACE(acpi_get_statistics);
+
+	/* Parameter validation */
+
+	if (!stats) {
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	/* Various interrupt-based event counters */
+
+	stats->sci_count = acpi_sci_count;
+	stats->gpe_count = acpi_gpe_count;
+
+	ACPI_MEMCPY(stats->fixed_event_count, acpi_fixed_event_count,
+		    sizeof(acpi_fixed_event_count));
+
+	/* Other counters */
+
+	stats->method_count = acpi_method_count;
+
+	return_ACPI_STATUS(AE_OK);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_get_statistics)
+
+/*****************************************************************************
+ *
+ * FUNCTION:    acpi_install_initialization_handler
+ *
+ * PARAMETERS:  Handler             - Callback procedure
+ *              Function            - Not (currently) used, see below
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Install an initialization handler
+ *
+ * TBD: When a second function is added, must save the Function also.
+ *
+ ****************************************************************************/
+acpi_status
+acpi_install_initialization_handler(acpi_init_handler handler, u32 function)
+{
+
+	if (!handler) {
+		return (AE_BAD_PARAMETER);
+	}
+
+	if (acpi_gbl_init_handler) {
+		return (AE_ALREADY_EXISTS);
+	}
+
+	acpi_gbl_init_handler = handler;
+	return AE_OK;
+}
+
+ACPI_EXPORT_SYMBOL(acpi_install_initialization_handler)
+
+/*****************************************************************************
+ *
+ * FUNCTION:    acpi_purge_cached_objects
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Empty all caches (delete the cached objects)
+ *
+ ****************************************************************************/
+acpi_status acpi_purge_cached_objects(void)
+{
+	ACPI_FUNCTION_TRACE(acpi_purge_cached_objects);
+
+	(void)acpi_os_purge_cache(acpi_gbl_state_cache);
+	(void)acpi_os_purge_cache(acpi_gbl_operand_cache);
+	(void)acpi_os_purge_cache(acpi_gbl_ps_node_cache);
+	(void)acpi_os_purge_cache(acpi_gbl_ps_node_ext_cache);
+	return_ACPI_STATUS(AE_OK);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_purge_cached_objects)
+
+/*****************************************************************************
+ *
+ * FUNCTION:    acpi_install_interface
+ *
+ * PARAMETERS:  interface_name      - The interface to install
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Install an _OSI interface to the global list
+ *
+ ****************************************************************************/
+acpi_status acpi_install_interface(acpi_string interface_name)
+{
+	acpi_status status;
+	struct acpi_interface_info *interface_info;
+
+	/* Parameter validation */
+
+	if (!interface_name || (ACPI_STRLEN(interface_name) == 0)) {
+		return (AE_BAD_PARAMETER);
+	}
+
+	(void)acpi_os_acquire_mutex(acpi_gbl_osi_mutex, ACPI_WAIT_FOREVER);
+
+	/* Check if the interface name is already in the global list */
+
+	interface_info = acpi_ut_get_interface(interface_name);
+	if (interface_info) {
+		/*
+		 * The interface already exists in the list. This is OK if the
+		 * interface has been marked invalid -- just clear the bit.
+		 */
+		if (interface_info->flags & ACPI_OSI_INVALID) {
+			interface_info->flags &= ~ACPI_OSI_INVALID;
+			status = AE_OK;
+		} else {
+			status = AE_ALREADY_EXISTS;
+		}
+	} else {
+		/* New interface name, install into the global list */
+
+		status = acpi_ut_install_interface(interface_name);
+	}
+
+	acpi_os_release_mutex(acpi_gbl_osi_mutex);
+	return (status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_install_interface)
+
+/*****************************************************************************
+ *
+ * FUNCTION:    acpi_remove_interface
+ *
+ * PARAMETERS:  interface_name      - The interface to remove
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Remove an _OSI interface from the global list
+ *
+ ****************************************************************************/
+acpi_status acpi_remove_interface(acpi_string interface_name)
+{
+	acpi_status status;
+
+	/* Parameter validation */
+
+	if (!interface_name || (ACPI_STRLEN(interface_name) == 0)) {
+		return (AE_BAD_PARAMETER);
+	}
+
+	(void)acpi_os_acquire_mutex(acpi_gbl_osi_mutex, ACPI_WAIT_FOREVER);
+
+	status = acpi_ut_remove_interface(interface_name);
+
+	acpi_os_release_mutex(acpi_gbl_osi_mutex);
+	return (status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_remove_interface)
+
+/*****************************************************************************
+ *
+ * FUNCTION:    acpi_install_interface_handler
+ *
+ * PARAMETERS:  Handler             - The _OSI interface handler to install
+ *                                    NULL means "remove existing handler"
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Install a handler for the predefined _OSI ACPI method.
+ *              invoked during execution of the internal implementation of
+ *              _OSI. A NULL handler simply removes any existing handler.
+ *
+ ****************************************************************************/
+acpi_status acpi_install_interface_handler(acpi_interface_handler handler)
+{
+	acpi_status status = AE_OK;
+
+	(void)acpi_os_acquire_mutex(acpi_gbl_osi_mutex, ACPI_WAIT_FOREVER);
+
+	if (handler && acpi_gbl_interface_handler) {
+		status = AE_ALREADY_EXISTS;
+	} else {
+		acpi_gbl_interface_handler = handler;
+	}
+
+	acpi_os_release_mutex(acpi_gbl_osi_mutex);
+	return (status);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_install_interface_handler)
+
+/*****************************************************************************
+ *
+ * FUNCTION:    acpi_check_address_range
+ *
+ * PARAMETERS:  space_id            - Address space ID
+ *              Address             - Start address
+ *              Length              - Length
+ *              Warn                - TRUE if warning on overlap desired
+ *
+ * RETURN:      Count of the number of conflicts detected.
+ *
+ * DESCRIPTION: Check if the input address range overlaps any of the
+ *              ASL operation region address ranges.
+ *
+ ****************************************************************************/
+u32
+acpi_check_address_range(acpi_adr_space_type space_id,
+			 acpi_physical_address address,
+			 acpi_size length, u8 warn)
+{
+	u32 overlaps;
+	acpi_status status;
+
+	status = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);
+	if (ACPI_FAILURE(status)) {
+		return (0);
+	}
+
+	overlaps = acpi_ut_check_address_range(space_id, address,
+					       (u32)length, warn);
+
+	(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);
+	return (overlaps);
+}
+
+ACPI_EXPORT_SYMBOL(acpi_check_address_range)
+#endif				/* !ACPI_ASL_COMPILER */
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utxferror.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utxferror.c
new file mode 100644
index 00000000..2a9b51af
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utxferror.c
@@ -0,0 +1,415 @@
+/*******************************************************************************
+ *
+ * Module Name: utxferror - Various error/warning output functions
+ *
+ ******************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acnamesp.h"
+
+#define _COMPONENT          ACPI_UTILITIES
+ACPI_MODULE_NAME("utxferror")
+
+/*
+ * This module is used for the in-kernel ACPICA as well as the ACPICA
+ * tools/applications.
+ *
+ * For the i_aSL compiler case, the output is redirected to stderr so that
+ * any of the various ACPI errors and warnings do not appear in the output
+ * files, for either the compiler or disassembler portions of the tool.
+ */
+#ifdef ACPI_ASL_COMPILER
+#include <stdio.h>
+extern FILE *acpi_gbl_output_file;
+
+#define ACPI_MSG_REDIRECT_BEGIN \
+	FILE                            *output_file = acpi_gbl_output_file; \
+	acpi_os_redirect_output (stderr);
+
+#define ACPI_MSG_REDIRECT_END \
+	acpi_os_redirect_output (output_file);
+
+#else
+/*
+ * non-i_aSL case - no redirection, nothing to do
+ */
+#define ACPI_MSG_REDIRECT_BEGIN
+#define ACPI_MSG_REDIRECT_END
+#endif
+/*
+ * Common message prefixes
+ */
+#define ACPI_MSG_ERROR          "ACPI Error: "
+#define ACPI_MSG_EXCEPTION      "ACPI Exception: "
+#define ACPI_MSG_WARNING        "ACPI Warning: "
+#define ACPI_MSG_INFO           "ACPI: "
+/*
+ * Common message suffix
+ */
+#define ACPI_MSG_SUFFIX \
+	acpi_os_printf (" (%8.8X/%s-%u)\n", ACPI_CA_VERSION, module_name, line_number)
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_error
+ *
+ * PARAMETERS:  module_name         - Caller's module name (for error output)
+ *              line_number         - Caller's line number (for error output)
+ *              Format              - Printf format string + additional args
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Print "ACPI Error" message with module/line/version info
+ *
+ ******************************************************************************/
+void ACPI_INTERNAL_VAR_XFACE
+acpi_error(const char *module_name, u32 line_number, const char *format, ...)
+{
+	va_list arg_list;
+
+	ACPI_MSG_REDIRECT_BEGIN;
+	acpi_os_printf(ACPI_MSG_ERROR);
+
+	va_start(arg_list, format);
+	acpi_os_vprintf(format, arg_list);
+	ACPI_MSG_SUFFIX;
+	va_end(arg_list);
+
+	ACPI_MSG_REDIRECT_END;
+}
+
+ACPI_EXPORT_SYMBOL(acpi_error)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_exception
+ *
+ * PARAMETERS:  module_name         - Caller's module name (for error output)
+ *              line_number         - Caller's line number (for error output)
+ *              Status              - Status to be formatted
+ *              Format              - Printf format string + additional args
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Print "ACPI Exception" message with module/line/version info
+ *              and decoded acpi_status.
+ *
+ ******************************************************************************/
+void ACPI_INTERNAL_VAR_XFACE
+acpi_exception(const char *module_name,
+	       u32 line_number, acpi_status status, const char *format, ...)
+{
+	va_list arg_list;
+
+	ACPI_MSG_REDIRECT_BEGIN;
+	acpi_os_printf(ACPI_MSG_EXCEPTION "%s, ",
+		       acpi_format_exception(status));
+
+	va_start(arg_list, format);
+	acpi_os_vprintf(format, arg_list);
+	ACPI_MSG_SUFFIX;
+	va_end(arg_list);
+
+	ACPI_MSG_REDIRECT_END;
+}
+
+ACPI_EXPORT_SYMBOL(acpi_exception)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_warning
+ *
+ * PARAMETERS:  module_name         - Caller's module name (for error output)
+ *              line_number         - Caller's line number (for error output)
+ *              Format              - Printf format string + additional args
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Print "ACPI Warning" message with module/line/version info
+ *
+ ******************************************************************************/
+void ACPI_INTERNAL_VAR_XFACE
+acpi_warning(const char *module_name, u32 line_number, const char *format, ...)
+{
+	va_list arg_list;
+
+	ACPI_MSG_REDIRECT_BEGIN;
+	acpi_os_printf(ACPI_MSG_WARNING);
+
+	va_start(arg_list, format);
+	acpi_os_vprintf(format, arg_list);
+	ACPI_MSG_SUFFIX;
+	va_end(arg_list);
+
+	ACPI_MSG_REDIRECT_END;
+}
+
+ACPI_EXPORT_SYMBOL(acpi_warning)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_info
+ *
+ * PARAMETERS:  module_name         - Caller's module name (for error output)
+ *              line_number         - Caller's line number (for error output)
+ *              Format              - Printf format string + additional args
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Print generic "ACPI:" information message. There is no
+ *              module/line/version info in order to keep the message simple.
+ *
+ * TBD: module_name and line_number args are not needed, should be removed.
+ *
+ ******************************************************************************/
+void ACPI_INTERNAL_VAR_XFACE
+acpi_info(const char *module_name, u32 line_number, const char *format, ...)
+{
+	va_list arg_list;
+
+	ACPI_MSG_REDIRECT_BEGIN;
+	acpi_os_printf(ACPI_MSG_INFO);
+
+	va_start(arg_list, format);
+	acpi_os_vprintf(format, arg_list);
+	acpi_os_printf("\n");
+	va_end(arg_list);
+
+	ACPI_MSG_REDIRECT_END;
+}
+
+ACPI_EXPORT_SYMBOL(acpi_info)
+
+/*
+ * The remainder of this module contains internal error functions that may
+ * be configured out.
+ */
+#if !defined (ACPI_NO_ERROR_MESSAGES) && !defined (ACPI_BIN_APP)
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_predefined_warning
+ *
+ * PARAMETERS:  module_name     - Caller's module name (for error output)
+ *              line_number     - Caller's line number (for error output)
+ *              Pathname        - Full pathname to the node
+ *              node_flags      - From Namespace node for the method/object
+ *              Format          - Printf format string + additional args
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Warnings for the predefined validation module. Messages are
+ *              only emitted the first time a problem with a particular
+ *              method/object is detected. This prevents a flood of error
+ *              messages for methods that are repeatedly evaluated.
+ *
+ ******************************************************************************/
+void ACPI_INTERNAL_VAR_XFACE
+acpi_ut_predefined_warning(const char *module_name,
+			   u32 line_number,
+			   char *pathname,
+			   u8 node_flags, const char *format, ...)
+{
+	va_list arg_list;
+
+	/*
+	 * Warning messages for this method/object will be disabled after the
+	 * first time a validation fails or an object is successfully repaired.
+	 */
+	if (node_flags & ANOBJ_EVALUATED) {
+		return;
+	}
+
+	acpi_os_printf(ACPI_MSG_WARNING "For %s: ", pathname);
+
+	va_start(arg_list, format);
+	acpi_os_vprintf(format, arg_list);
+	ACPI_MSG_SUFFIX;
+	va_end(arg_list);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_predefined_info
+ *
+ * PARAMETERS:  module_name     - Caller's module name (for error output)
+ *              line_number     - Caller's line number (for error output)
+ *              Pathname        - Full pathname to the node
+ *              node_flags      - From Namespace node for the method/object
+ *              Format          - Printf format string + additional args
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Info messages for the predefined validation module. Messages
+ *              are only emitted the first time a problem with a particular
+ *              method/object is detected. This prevents a flood of
+ *              messages for methods that are repeatedly evaluated.
+ *
+ ******************************************************************************/
+
+void ACPI_INTERNAL_VAR_XFACE
+acpi_ut_predefined_info(const char *module_name,
+			u32 line_number,
+			char *pathname, u8 node_flags, const char *format, ...)
+{
+	va_list arg_list;
+
+	/*
+	 * Warning messages for this method/object will be disabled after the
+	 * first time a validation fails or an object is successfully repaired.
+	 */
+	if (node_flags & ANOBJ_EVALUATED) {
+		return;
+	}
+
+	acpi_os_printf(ACPI_MSG_INFO "For %s: ", pathname);
+
+	va_start(arg_list, format);
+	acpi_os_vprintf(format, arg_list);
+	ACPI_MSG_SUFFIX;
+	va_end(arg_list);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_namespace_error
+ *
+ * PARAMETERS:  module_name         - Caller's module name (for error output)
+ *              line_number         - Caller's line number (for error output)
+ *              internal_name       - Name or path of the namespace node
+ *              lookup_status       - Exception code from NS lookup
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Print error message with the full pathname for the NS node.
+ *
+ ******************************************************************************/
+
+void
+acpi_ut_namespace_error(const char *module_name,
+			u32 line_number,
+			const char *internal_name, acpi_status lookup_status)
+{
+	acpi_status status;
+	u32 bad_name;
+	char *name = NULL;
+
+	ACPI_MSG_REDIRECT_BEGIN;
+	acpi_os_printf(ACPI_MSG_ERROR);
+
+	if (lookup_status == AE_BAD_CHARACTER) {
+
+		/* There is a non-ascii character in the name */
+
+		ACPI_MOVE_32_TO_32(&bad_name,
+				   ACPI_CAST_PTR(u32, internal_name));
+		acpi_os_printf("[0x%4.4X] (NON-ASCII)", bad_name);
+	} else {
+		/* Convert path to external format */
+
+		status = acpi_ns_externalize_name(ACPI_UINT32_MAX,
+						  internal_name, NULL, &name);
+
+		/* Print target name */
+
+		if (ACPI_SUCCESS(status)) {
+			acpi_os_printf("[%s]", name);
+		} else {
+			acpi_os_printf("[COULD NOT EXTERNALIZE NAME]");
+		}
+
+		if (name) {
+			ACPI_FREE(name);
+		}
+	}
+
+	acpi_os_printf(" Namespace lookup failure, %s",
+		       acpi_format_exception(lookup_status));
+
+	ACPI_MSG_SUFFIX;
+	ACPI_MSG_REDIRECT_END;
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_method_error
+ *
+ * PARAMETERS:  module_name         - Caller's module name (for error output)
+ *              line_number         - Caller's line number (for error output)
+ *              Message             - Error message to use on failure
+ *              prefix_node         - Prefix relative to the path
+ *              Path                - Path to the node (optional)
+ *              method_status       - Execution status
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Print error message with the full pathname for the method.
+ *
+ ******************************************************************************/
+
+void
+acpi_ut_method_error(const char *module_name,
+		     u32 line_number,
+		     const char *message,
+		     struct acpi_namespace_node *prefix_node,
+		     const char *path, acpi_status method_status)
+{
+	acpi_status status;
+	struct acpi_namespace_node *node = prefix_node;
+
+	ACPI_MSG_REDIRECT_BEGIN;
+	acpi_os_printf(ACPI_MSG_ERROR);
+
+	if (path) {
+		status =
+		    acpi_ns_get_node(prefix_node, path, ACPI_NS_NO_UPSEARCH,
+				     &node);
+		if (ACPI_FAILURE(status)) {
+			acpi_os_printf("[Could not get node by pathname]");
+		}
+	}
+
+	acpi_ns_print_node_pathname(node, message);
+	acpi_os_printf(", %s", acpi_format_exception(method_status));
+
+	ACPI_MSG_SUFFIX;
+	ACPI_MSG_REDIRECT_END;
+}
+
+#endif				/* ACPI_NO_ERROR_MESSAGES */
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utxfmutex.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utxfmutex.c
new file mode 100644
index 00000000..1427d191
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utxfmutex.c
@@ -0,0 +1,187 @@
+/*******************************************************************************
+ *
+ * Module Name: utxfmutex - external AML mutex access functions
+ *
+ ******************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+#include "acnamesp.h"
+
+#define _COMPONENT          ACPI_UTILITIES
+ACPI_MODULE_NAME("utxfmutex")
+
+/* Local prototypes */
+static acpi_status
+acpi_ut_get_mutex_object(acpi_handle handle,
+			 acpi_string pathname,
+			 union acpi_operand_object **ret_obj);
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_get_mutex_object
+ *
+ * PARAMETERS:  Handle              - Mutex or prefix handle (optional)
+ *              Pathname            - Mutex pathname (optional)
+ *              ret_obj             - Where the mutex object is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Get an AML mutex object. The mutex node is pointed to by
+ *              Handle:Pathname. Either Handle or Pathname can be NULL, but
+ *              not both.
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ut_get_mutex_object(acpi_handle handle,
+			 acpi_string pathname,
+			 union acpi_operand_object **ret_obj)
+{
+	struct acpi_namespace_node *mutex_node;
+	union acpi_operand_object *mutex_obj;
+	acpi_status status;
+
+	/* Parameter validation */
+
+	if (!ret_obj || (!handle && !pathname)) {
+		return (AE_BAD_PARAMETER);
+	}
+
+	/* Get a the namespace node for the mutex */
+
+	mutex_node = handle;
+	if (pathname != NULL) {
+		status = acpi_get_handle(handle, pathname,
+					 ACPI_CAST_PTR(acpi_handle,
+						       &mutex_node));
+		if (ACPI_FAILURE(status)) {
+			return (status);
+		}
+	}
+
+	/* Ensure that we actually have a Mutex object */
+
+	if (!mutex_node || (mutex_node->type != ACPI_TYPE_MUTEX)) {
+		return (AE_TYPE);
+	}
+
+	/* Get the low-level mutex object */
+
+	mutex_obj = acpi_ns_get_attached_object(mutex_node);
+	if (!mutex_obj) {
+		return (AE_NULL_OBJECT);
+	}
+
+	*ret_obj = mutex_obj;
+	return (AE_OK);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_acquire_mutex
+ *
+ * PARAMETERS:  Handle              - Mutex or prefix handle (optional)
+ *              Pathname            - Mutex pathname (optional)
+ *              Timeout             - Max time to wait for the lock (millisec)
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Acquire an AML mutex. This is a device driver interface to
+ *              AML mutex objects, and allows for transaction locking between
+ *              drivers and AML code. The mutex node is pointed to by
+ *              Handle:Pathname. Either Handle or Pathname can be NULL, but
+ *              not both.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_acquire_mutex(acpi_handle handle, acpi_string pathname, u16 timeout)
+{
+	acpi_status status;
+	union acpi_operand_object *mutex_obj;
+
+	/* Get the low-level mutex associated with Handle:Pathname */
+
+	status = acpi_ut_get_mutex_object(handle, pathname, &mutex_obj);
+	if (ACPI_FAILURE(status)) {
+		return (status);
+	}
+
+	/* Acquire the OS mutex */
+
+	status = acpi_os_acquire_mutex(mutex_obj->mutex.os_mutex, timeout);
+	return (status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_release_mutex
+ *
+ * PARAMETERS:  Handle              - Mutex or prefix handle (optional)
+ *              Pathname            - Mutex pathname (optional)
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Release an AML mutex. This is a device driver interface to
+ *              AML mutex objects, and allows for transaction locking between
+ *              drivers and AML code. The mutex node is pointed to by
+ *              Handle:Pathname. Either Handle or Pathname can be NULL, but
+ *              not both.
+ *
+ ******************************************************************************/
+
+acpi_status acpi_release_mutex(acpi_handle handle, acpi_string pathname)
+{
+	acpi_status status;
+	union acpi_operand_object *mutex_obj;
+
+	/* Get the low-level mutex associated with Handle:Pathname */
+
+	status = acpi_ut_get_mutex_object(handle, pathname, &mutex_obj);
+	if (ACPI_FAILURE(status)) {
+		return (status);
+	}
+
+	/* Release the OS mutex */
+
+	acpi_os_release_mutex(mutex_obj->mutex.os_mutex);
+	return (AE_OK);
+}
diff --git a/com32/acpioff/acpica_linuxized/include/acpi/acapps.h b/com32/acpioff/acpica_linuxized/include/acpi/acapps.h
new file mode 100644
index 00000000..b9801d20
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/include/acpi/acapps.h
@@ -0,0 +1,161 @@
+/******************************************************************************
+ *
+ * Module Name: acapps - common include for ACPI applications/tools
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef _ACAPPS
+#define _ACAPPS
+
+/* Common info for tool signons */
+
+#define ACPICA_NAME                 "Intel ACPI Component Architecture"
+#define ACPICA_COPYRIGHT            "Copyright (c) 2000 - 2012 Intel Corporation"
+
+#if ACPI_MACHINE_WIDTH == 64
+#define ACPI_WIDTH          "-64"
+
+#elif ACPI_MACHINE_WIDTH == 32
+#define ACPI_WIDTH          "-32"
+
+#else
+#error unknown ACPI_MACHINE_WIDTH
+#define ACPI_WIDTH          "-??"
+
+#endif
+
+/* Macros for signons and file headers */
+
+#define ACPI_COMMON_SIGNON(utility_name) \
+	"\n%s\n%s version %8.8X%s [%s]\n%s\n\n", \
+	ACPICA_NAME, \
+	utility_name, ((u32) ACPI_CA_VERSION), ACPI_WIDTH, __DATE__, \
+	ACPICA_COPYRIGHT
+
+#define ACPI_COMMON_HEADER(utility_name, prefix) \
+	"%s%s\n%s%s version %8.8X%s [%s]\n%s%s\n%s\n", \
+	prefix, ACPICA_NAME, \
+	prefix, utility_name, ((u32) ACPI_CA_VERSION), ACPI_WIDTH, __DATE__, \
+	prefix, ACPICA_COPYRIGHT, \
+	prefix
+
+/* Macros for usage messages */
+
+#define ACPI_USAGE_HEADER(usage) \
+	printf ("Usage: %s\nOptions:\n", usage);
+
+#define ACPI_OPTION(name, description) \
+	printf ("  %-18s%s\n", name, description);
+
+#define FILE_SUFFIX_DISASSEMBLY     "dsl"
+#define ACPI_TABLE_FILE_SUFFIX      ".dat"
+
+/*
+ * getopt
+ */
+int acpi_getopt(int argc, char **argv, char *opts);
+
+extern int acpi_gbl_optind;
+extern int acpi_gbl_opterr;
+extern char *acpi_gbl_optarg;
+
+/*
+ * adisasm
+ */
+acpi_status
+ad_aml_disassemble(u8 out_to_file,
+		   char *filename,
+		   char *prefix, char **out_filename, u8 get_all_tables);
+
+void ad_print_statistics(void);
+
+acpi_status ad_find_dsdt(u8 **dsdt_ptr, u32 *dsdt_length);
+
+void ad_dump_tables(void);
+
+acpi_status ad_get_local_tables(char *filename, u8 get_all_tables);
+
+acpi_status
+ad_parse_table(struct acpi_table_header *table,
+	       acpi_owner_id * owner_id, u8 load_table, u8 external);
+
+acpi_status ad_display_tables(char *filename, struct acpi_table_header *table);
+
+acpi_status ad_display_statistics(void);
+
+/*
+ * adwalk
+ */
+void
+acpi_dm_cross_reference_namespace(union acpi_parse_object *parse_tree_root,
+				  struct acpi_namespace_node *namespace_root,
+				  acpi_owner_id owner_id);
+
+void acpi_dm_dump_tree(union acpi_parse_object *origin);
+
+void acpi_dm_find_orphan_methods(union acpi_parse_object *origin);
+
+void
+acpi_dm_finish_namespace_load(union acpi_parse_object *parse_tree_root,
+			      struct acpi_namespace_node *namespace_root,
+			      acpi_owner_id owner_id);
+
+void
+acpi_dm_convert_resource_indexes(union acpi_parse_object *parse_tree_root,
+				 struct acpi_namespace_node *namespace_root);
+
+/*
+ * adfile
+ */
+acpi_status ad_initialize(void);
+
+char *fl_generate_filename(char *input_filename, char *suffix);
+
+acpi_status
+fl_split_input_pathname(char *input_path,
+			char **out_directory_path, char **out_filename);
+
+char *ad_generate_filename(char *prefix, char *table_id);
+
+void
+ad_write_table(struct acpi_table_header *table,
+	       u32 length, char *table_name, char *oem_table_id);
+
+#endif				/* _ACAPPS */
diff --git a/com32/acpioff/acpica_linuxized/include/acpi/acdisasm.h b/com32/acpioff/acpica_linuxized/include/acpi/acdisasm.h
new file mode 100644
index 00000000..fe00749e
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/include/acpi/acdisasm.h
@@ -0,0 +1,620 @@
+/******************************************************************************
+ *
+ * Name: acdisasm.h - AML disassembler
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACDISASM_H__
+#define __ACDISASM_H__
+
+#include "amlresrc.h"
+
+#define BLOCK_NONE              0
+#define BLOCK_PAREN             1
+#define BLOCK_BRACE             2
+#define BLOCK_COMMA_LIST        4
+#define ACPI_DEFAULT_RESNAME    *(u32 *) "__RD"
+
+/*
+ * Raw table data header. Used by disassembler and data table compiler.
+ * Do not change.
+ */
+#define ACPI_RAW_TABLE_DATA_HEADER      "Raw Table Data"
+
+typedef const struct acpi_dmtable_info {
+	u8 opcode;
+	u16 offset;
+	char *name;
+	u8 flags;
+
+} acpi_dmtable_info;
+
+#define DT_LENGTH                       0x01	/* Field is a subtable length */
+#define DT_FLAG                         0x02	/* Field is a flag value */
+#define DT_NON_ZERO                     0x04	/* Field must be non-zero */
+
+/* TBD: Not used at this time */
+
+#define DT_OPTIONAL                     0x08
+#define DT_COUNT                        0x10
+
+/*
+ * Values for Opcode above.
+ * Note: 0-7 must not change, they are used as a flag shift value. Other
+ * than those, new values can be added wherever appropriate.
+ */
+typedef enum {
+	/* Simple Data Types */
+
+	ACPI_DMT_FLAG0 = 0,
+	ACPI_DMT_FLAG1 = 1,
+	ACPI_DMT_FLAG2 = 2,
+	ACPI_DMT_FLAG3 = 3,
+	ACPI_DMT_FLAG4 = 4,
+	ACPI_DMT_FLAG5 = 5,
+	ACPI_DMT_FLAG6 = 6,
+	ACPI_DMT_FLAG7 = 7,
+	ACPI_DMT_FLAGS0,
+	ACPI_DMT_FLAGS1,
+	ACPI_DMT_FLAGS2,
+	ACPI_DMT_FLAGS4,
+	ACPI_DMT_UINT8,
+	ACPI_DMT_UINT16,
+	ACPI_DMT_UINT24,
+	ACPI_DMT_UINT32,
+	ACPI_DMT_UINT40,
+	ACPI_DMT_UINT48,
+	ACPI_DMT_UINT56,
+	ACPI_DMT_UINT64,
+	ACPI_DMT_BUF7,
+	ACPI_DMT_BUF16,
+	ACPI_DMT_BUF128,
+	ACPI_DMT_SIG,
+	ACPI_DMT_STRING,
+	ACPI_DMT_NAME4,
+	ACPI_DMT_NAME6,
+	ACPI_DMT_NAME8,
+
+	/* Types that are decoded to strings and miscellaneous */
+
+	ACPI_DMT_ACCWIDTH,
+	ACPI_DMT_CHKSUM,
+	ACPI_DMT_GAS,
+	ACPI_DMT_SPACEID,
+	ACPI_DMT_UNICODE,
+	ACPI_DMT_UUID,
+
+	/* Types used only for the Data Table Compiler */
+
+	ACPI_DMT_BUFFER,
+	ACPI_DMT_DEVICE_PATH,
+	ACPI_DMT_LABEL,
+	ACPI_DMT_PCI_PATH,
+
+	/* Types that are specific to particular ACPI tables */
+
+	ACPI_DMT_ASF,
+	ACPI_DMT_DMAR,
+	ACPI_DMT_EINJACT,
+	ACPI_DMT_EINJINST,
+	ACPI_DMT_ERSTACT,
+	ACPI_DMT_ERSTINST,
+	ACPI_DMT_FADTPM,
+	ACPI_DMT_HEST,
+	ACPI_DMT_HESTNTFY,
+	ACPI_DMT_HESTNTYP,
+	ACPI_DMT_IVRS,
+	ACPI_DMT_MADT,
+	ACPI_DMT_PMTT,
+	ACPI_DMT_SLIC,
+	ACPI_DMT_SRAT,
+
+	/* Special opcodes */
+
+	ACPI_DMT_EXTRA_TEXT,
+	ACPI_DMT_EXIT
+} ACPI_ENTRY_TYPES;
+
+typedef
+void (*acpi_dmtable_handler) (struct acpi_table_header * table);
+
+typedef acpi_status(*acpi_cmtable_handler) (void **pfield_list);
+
+struct acpi_dmtable_data {
+	char *signature;
+	struct acpi_dmtable_info *table_info;
+	acpi_dmtable_handler table_handler;
+	acpi_cmtable_handler cm_table_handler;
+	const unsigned char *template;
+	char *name;
+};
+
+struct acpi_op_walk_info {
+	u32 level;
+	u32 last_level;
+	u32 count;
+	u32 bit_offset;
+	u32 flags;
+	struct acpi_walk_state *walk_state;
+};
+
+/*
+ * TBD - another copy of this is in asltypes.h, fix
+ */
+#ifndef ASL_WALK_CALLBACK_DEFINED
+typedef
+acpi_status(*asl_walk_callback) (union acpi_parse_object * op,
+				 u32 level, void *context);
+#define ASL_WALK_CALLBACK_DEFINED
+#endif
+
+typedef
+void (*acpi_resource_handler) (union aml_resource * resource,
+			       u32 length, u32 level);
+
+struct acpi_resource_tag {
+	u32 bit_index;
+	char *tag;
+};
+
+/* Strings used for decoding flags to ASL keywords */
+
+extern const char *acpi_gbl_word_decode[];
+extern const char *acpi_gbl_irq_decode[];
+extern const char *acpi_gbl_lock_rule[];
+extern const char *acpi_gbl_access_types[];
+extern const char *acpi_gbl_update_rules[];
+extern const char *acpi_gbl_match_ops[];
+
+extern struct acpi_dmtable_info acpi_dm_table_info_asf0[];
+extern struct acpi_dmtable_info acpi_dm_table_info_asf1[];
+extern struct acpi_dmtable_info acpi_dm_table_info_asf1a[];
+extern struct acpi_dmtable_info acpi_dm_table_info_asf2[];
+extern struct acpi_dmtable_info acpi_dm_table_info_asf2a[];
+extern struct acpi_dmtable_info acpi_dm_table_info_asf3[];
+extern struct acpi_dmtable_info acpi_dm_table_info_asf4[];
+extern struct acpi_dmtable_info acpi_dm_table_info_asf_hdr[];
+extern struct acpi_dmtable_info acpi_dm_table_info_boot[];
+extern struct acpi_dmtable_info acpi_dm_table_info_bert[];
+extern struct acpi_dmtable_info acpi_dm_table_info_bgrt[];
+extern struct acpi_dmtable_info acpi_dm_table_info_cpep[];
+extern struct acpi_dmtable_info acpi_dm_table_info_cpep0[];
+extern struct acpi_dmtable_info acpi_dm_table_info_dbgp[];
+extern struct acpi_dmtable_info acpi_dm_table_info_dmar[];
+extern struct acpi_dmtable_info acpi_dm_table_info_dmar_hdr[];
+extern struct acpi_dmtable_info acpi_dm_table_info_dmar_scope[];
+extern struct acpi_dmtable_info acpi_dm_table_info_dmar0[];
+extern struct acpi_dmtable_info acpi_dm_table_info_dmar1[];
+extern struct acpi_dmtable_info acpi_dm_table_info_dmar2[];
+extern struct acpi_dmtable_info acpi_dm_table_info_dmar3[];
+extern struct acpi_dmtable_info acpi_dm_table_info_drtm[];
+extern struct acpi_dmtable_info acpi_dm_table_info_ecdt[];
+extern struct acpi_dmtable_info acpi_dm_table_info_einj[];
+extern struct acpi_dmtable_info acpi_dm_table_info_einj0[];
+extern struct acpi_dmtable_info acpi_dm_table_info_erst[];
+extern struct acpi_dmtable_info acpi_dm_table_info_erst0[];
+extern struct acpi_dmtable_info acpi_dm_table_info_facs[];
+extern struct acpi_dmtable_info acpi_dm_table_info_fadt1[];
+extern struct acpi_dmtable_info acpi_dm_table_info_fadt2[];
+extern struct acpi_dmtable_info acpi_dm_table_info_fadt3[];
+extern struct acpi_dmtable_info acpi_dm_table_info_fadt5[];
+extern struct acpi_dmtable_info acpi_dm_table_info_fpdt[];
+extern struct acpi_dmtable_info acpi_dm_table_info_fpdt_hdr[];
+extern struct acpi_dmtable_info acpi_dm_table_info_fpdt0[];
+extern struct acpi_dmtable_info acpi_dm_table_info_fpdt1[];
+extern struct acpi_dmtable_info acpi_dm_table_info_gas[];
+extern struct acpi_dmtable_info acpi_dm_table_info_gtdt[];
+extern struct acpi_dmtable_info acpi_dm_table_info_header[];
+extern struct acpi_dmtable_info acpi_dm_table_info_hest[];
+extern struct acpi_dmtable_info acpi_dm_table_info_hest0[];
+extern struct acpi_dmtable_info acpi_dm_table_info_hest1[];
+extern struct acpi_dmtable_info acpi_dm_table_info_hest2[];
+extern struct acpi_dmtable_info acpi_dm_table_info_hest6[];
+extern struct acpi_dmtable_info acpi_dm_table_info_hest7[];
+extern struct acpi_dmtable_info acpi_dm_table_info_hest8[];
+extern struct acpi_dmtable_info acpi_dm_table_info_hest9[];
+extern struct acpi_dmtable_info acpi_dm_table_info_hest_notify[];
+extern struct acpi_dmtable_info acpi_dm_table_info_hest_bank[];
+extern struct acpi_dmtable_info acpi_dm_table_info_hpet[];
+extern struct acpi_dmtable_info acpi_dm_table_info_ivrs[];
+extern struct acpi_dmtable_info acpi_dm_table_info_ivrs0[];
+extern struct acpi_dmtable_info acpi_dm_table_info_ivrs1[];
+extern struct acpi_dmtable_info acpi_dm_table_info_ivrs4[];
+extern struct acpi_dmtable_info acpi_dm_table_info_ivrs8a[];
+extern struct acpi_dmtable_info acpi_dm_table_info_ivrs8b[];
+extern struct acpi_dmtable_info acpi_dm_table_info_ivrs8c[];
+extern struct acpi_dmtable_info acpi_dm_table_info_ivrs_hdr[];
+extern struct acpi_dmtable_info acpi_dm_table_info_madt[];
+extern struct acpi_dmtable_info acpi_dm_table_info_madt0[];
+extern struct acpi_dmtable_info acpi_dm_table_info_madt1[];
+extern struct acpi_dmtable_info acpi_dm_table_info_madt2[];
+extern struct acpi_dmtable_info acpi_dm_table_info_madt3[];
+extern struct acpi_dmtable_info acpi_dm_table_info_madt4[];
+extern struct acpi_dmtable_info acpi_dm_table_info_madt5[];
+extern struct acpi_dmtable_info acpi_dm_table_info_madt6[];
+extern struct acpi_dmtable_info acpi_dm_table_info_madt7[];
+extern struct acpi_dmtable_info acpi_dm_table_info_madt8[];
+extern struct acpi_dmtable_info acpi_dm_table_info_madt9[];
+extern struct acpi_dmtable_info acpi_dm_table_info_madt10[];
+extern struct acpi_dmtable_info acpi_dm_table_info_madt11[];
+extern struct acpi_dmtable_info acpi_dm_table_info_madt12[];
+extern struct acpi_dmtable_info acpi_dm_table_info_madt_hdr[];
+extern struct acpi_dmtable_info acpi_dm_table_info_mcfg[];
+extern struct acpi_dmtable_info acpi_dm_table_info_mcfg0[];
+extern struct acpi_dmtable_info acpi_dm_table_info_mchi[];
+extern struct acpi_dmtable_info acpi_dm_table_info_mpst[];
+extern struct acpi_dmtable_info acpi_dm_table_info_mpst0[];
+extern struct acpi_dmtable_info acpi_dm_table_info_mpst0_a[];
+extern struct acpi_dmtable_info acpi_dm_table_info_mpst0_b[];
+extern struct acpi_dmtable_info acpi_dm_table_info_mpst1[];
+extern struct acpi_dmtable_info acpi_dm_table_info_mpst2[];
+extern struct acpi_dmtable_info acpi_dm_table_info_msct[];
+extern struct acpi_dmtable_info acpi_dm_table_info_msct0[];
+extern struct acpi_dmtable_info acpi_dm_table_info_pmtt[];
+extern struct acpi_dmtable_info acpi_dm_table_info_pmtt0[];
+extern struct acpi_dmtable_info acpi_dm_table_info_pmtt1[];
+extern struct acpi_dmtable_info acpi_dm_table_info_pmtt1a[];
+extern struct acpi_dmtable_info acpi_dm_table_info_pmtt2[];
+extern struct acpi_dmtable_info acpi_dm_table_info_pmtt_hdr[];
+extern struct acpi_dmtable_info acpi_dm_table_info_pcct[];
+extern struct acpi_dmtable_info acpi_dm_table_info_pcct0[];
+extern struct acpi_dmtable_info acpi_dm_table_info_rsdp1[];
+extern struct acpi_dmtable_info acpi_dm_table_info_rsdp2[];
+extern struct acpi_dmtable_info acpi_dm_table_info_s3pt[];
+extern struct acpi_dmtable_info acpi_dm_table_info_s3pt_hdr[];
+extern struct acpi_dmtable_info acpi_dm_table_info_s3pt0[];
+extern struct acpi_dmtable_info acpi_dm_table_info_s3pt1[];
+extern struct acpi_dmtable_info acpi_dm_table_info_sbst[];
+extern struct acpi_dmtable_info acpi_dm_table_info_slic_hdr[];
+extern struct acpi_dmtable_info acpi_dm_table_info_slic0[];
+extern struct acpi_dmtable_info acpi_dm_table_info_slic1[];
+extern struct acpi_dmtable_info acpi_dm_table_info_slit[];
+extern struct acpi_dmtable_info acpi_dm_table_info_spcr[];
+extern struct acpi_dmtable_info acpi_dm_table_info_spmi[];
+extern struct acpi_dmtable_info acpi_dm_table_info_srat[];
+extern struct acpi_dmtable_info acpi_dm_table_info_srat_hdr[];
+extern struct acpi_dmtable_info acpi_dm_table_info_srat0[];
+extern struct acpi_dmtable_info acpi_dm_table_info_srat1[];
+extern struct acpi_dmtable_info acpi_dm_table_info_srat2[];
+extern struct acpi_dmtable_info acpi_dm_table_info_tcpa[];
+extern struct acpi_dmtable_info acpi_dm_table_info_uefi[];
+extern struct acpi_dmtable_info acpi_dm_table_info_waet[];
+extern struct acpi_dmtable_info acpi_dm_table_info_wdat[];
+extern struct acpi_dmtable_info acpi_dm_table_info_wdat0[];
+extern struct acpi_dmtable_info acpi_dm_table_info_wddt[];
+extern struct acpi_dmtable_info acpi_dm_table_info_wdrt[];
+
+extern struct acpi_dmtable_info acpi_dm_table_info_generic[][2];
+
+/*
+ * dmtable
+ */
+extern struct acpi_dmtable_data acpi_dm_table_data[];
+
+u8 acpi_dm_generate_checksum(void *table, u32 length, u8 original_checksum);
+
+struct acpi_dmtable_data *acpi_dm_get_table_data(char *signature);
+
+void acpi_dm_dump_data_table(struct acpi_table_header *table);
+
+acpi_status
+acpi_dm_dump_table(u32 table_length,
+		   u32 table_offset,
+		   void *table,
+		   u32 sub_table_length, struct acpi_dmtable_info *info);
+
+void acpi_dm_line_header(u32 offset, u32 byte_length, char *name);
+
+void acpi_dm_line_header2(u32 offset, u32 byte_length, char *name, u32 value);
+
+/*
+ * dmtbdump
+ */
+void acpi_dm_dump_asf(struct acpi_table_header *table);
+
+void acpi_dm_dump_cpep(struct acpi_table_header *table);
+
+void acpi_dm_dump_dmar(struct acpi_table_header *table);
+
+void acpi_dm_dump_einj(struct acpi_table_header *table);
+
+void acpi_dm_dump_erst(struct acpi_table_header *table);
+
+void acpi_dm_dump_fadt(struct acpi_table_header *table);
+
+void acpi_dm_dump_fpdt(struct acpi_table_header *table);
+
+void acpi_dm_dump_hest(struct acpi_table_header *table);
+
+void acpi_dm_dump_ivrs(struct acpi_table_header *table);
+
+void acpi_dm_dump_madt(struct acpi_table_header *table);
+
+void acpi_dm_dump_mcfg(struct acpi_table_header *table);
+
+void acpi_dm_dump_mpst(struct acpi_table_header *table);
+
+void acpi_dm_dump_msct(struct acpi_table_header *table);
+
+void acpi_dm_dump_pcct(struct acpi_table_header *table);
+
+void acpi_dm_dump_pmtt(struct acpi_table_header *table);
+
+u32 acpi_dm_dump_rsdp(struct acpi_table_header *table);
+
+void acpi_dm_dump_rsdt(struct acpi_table_header *table);
+
+u32 acpi_dm_dump_s3pt(struct acpi_table_header *table);
+
+void acpi_dm_dump_slic(struct acpi_table_header *table);
+
+void acpi_dm_dump_slit(struct acpi_table_header *table);
+
+void acpi_dm_dump_srat(struct acpi_table_header *table);
+
+void acpi_dm_dump_wdat(struct acpi_table_header *table);
+
+void acpi_dm_dump_xsdt(struct acpi_table_header *table);
+
+/*
+ * dmwalk
+ */
+void
+acpi_dm_disassemble(struct acpi_walk_state *walk_state,
+		    union acpi_parse_object *origin, u32 num_opcodes);
+
+void
+acpi_dm_walk_parse_tree(union acpi_parse_object *op,
+			asl_walk_callback descending_callback,
+			asl_walk_callback ascending_callback, void *context);
+
+/*
+ * dmopcode
+ */
+void
+acpi_dm_disassemble_one_op(struct acpi_walk_state *walk_state,
+			   struct acpi_op_walk_info *info,
+			   union acpi_parse_object *op);
+
+void acpi_dm_decode_internal_object(union acpi_operand_object *obj_desc);
+
+u32 acpi_dm_list_type(union acpi_parse_object *op);
+
+void acpi_dm_method_flags(union acpi_parse_object *op);
+
+void acpi_dm_field_flags(union acpi_parse_object *op);
+
+void acpi_dm_address_space(u8 space_id);
+
+void acpi_dm_region_flags(union acpi_parse_object *op);
+
+void acpi_dm_match_op(union acpi_parse_object *op);
+
+/*
+ * dmnames
+ */
+u32 acpi_dm_dump_name(u32 name);
+
+acpi_status
+acpi_ps_display_object_pathname(struct acpi_walk_state *walk_state,
+				union acpi_parse_object *op);
+
+void acpi_dm_namestring(char *name);
+
+/*
+ * dmobject
+ */
+void
+acpi_dm_display_internal_object(union acpi_operand_object *obj_desc,
+				struct acpi_walk_state *walk_state);
+
+void acpi_dm_display_arguments(struct acpi_walk_state *walk_state);
+
+void acpi_dm_display_locals(struct acpi_walk_state *walk_state);
+
+void
+acpi_dm_dump_method_info(acpi_status status,
+			 struct acpi_walk_state *walk_state,
+			 union acpi_parse_object *op);
+
+/*
+ * dmbuffer
+ */
+void acpi_dm_disasm_byte_list(u32 level, u8 *byte_data, u32 byte_count);
+
+void
+acpi_dm_byte_list(struct acpi_op_walk_info *info, union acpi_parse_object *op);
+
+void acpi_dm_is_eisa_id(union acpi_parse_object *op);
+
+void acpi_dm_eisa_id(u32 encoded_id);
+
+u8 acpi_dm_is_unicode_buffer(union acpi_parse_object *op);
+
+u8 acpi_dm_is_string_buffer(union acpi_parse_object *op);
+
+/*
+ * dmextern
+ */
+
+acpi_status acpi_dm_add_to_external_file_list(char *path_list);
+
+void acpi_dm_clear_external_file_list(void);
+
+void
+acpi_dm_add_to_external_list(union acpi_parse_object *op,
+			     char *path, u8 type, u32 value);
+
+void acpi_dm_add_externals_to_namespace(void);
+
+u32 acpi_dm_get_external_method_count(void);
+
+void acpi_dm_clear_external_list(void);
+
+void acpi_dm_emit_externals(void);
+
+/*
+ * dmresrc
+ */
+void acpi_dm_dump_integer8(u8 value, char *name);
+
+void acpi_dm_dump_integer16(u16 value, char *name);
+
+void acpi_dm_dump_integer32(u32 value, char *name);
+
+void acpi_dm_dump_integer64(u64 value, char *name);
+
+void
+acpi_dm_resource_template(struct acpi_op_walk_info *info,
+			  union acpi_parse_object *op,
+			  u8 *byte_data, u32 byte_count);
+
+acpi_status acpi_dm_is_resource_template(union acpi_parse_object *op);
+
+void acpi_dm_bit_list(u16 mask);
+
+void acpi_dm_descriptor_name(void);
+
+/*
+ * dmresrcl
+ */
+void
+acpi_dm_word_descriptor(union aml_resource *resource, u32 length, u32 level);
+
+void
+acpi_dm_dword_descriptor(union aml_resource *resource, u32 length, u32 level);
+
+void
+acpi_dm_extended_descriptor(union aml_resource *resource,
+			    u32 length, u32 level);
+
+void
+acpi_dm_qword_descriptor(union aml_resource *resource, u32 length, u32 level);
+
+void
+acpi_dm_memory24_descriptor(union aml_resource *resource,
+			    u32 length, u32 level);
+
+void
+acpi_dm_memory32_descriptor(union aml_resource *resource,
+			    u32 length, u32 level);
+
+void
+acpi_dm_fixed_memory32_descriptor(union aml_resource *resource,
+				  u32 length, u32 level);
+
+void
+acpi_dm_generic_register_descriptor(union aml_resource *resource,
+				    u32 length, u32 level);
+
+void
+acpi_dm_interrupt_descriptor(union aml_resource *resource,
+			     u32 length, u32 level);
+
+void
+acpi_dm_vendor_large_descriptor(union aml_resource *resource,
+				u32 length, u32 level);
+
+void
+acpi_dm_gpio_descriptor(union aml_resource *resource, u32 length, u32 level);
+
+void
+acpi_dm_serial_bus_descriptor(union aml_resource *resource,
+			      u32 length, u32 level);
+
+void acpi_dm_vendor_common(char *name, u8 *byte_data, u32 length, u32 level);
+
+/*
+ * dmresrcs
+ */
+void
+acpi_dm_irq_descriptor(union aml_resource *resource, u32 length, u32 level);
+
+void
+acpi_dm_dma_descriptor(union aml_resource *resource, u32 length, u32 level);
+
+void
+acpi_dm_fixed_dma_descriptor(union aml_resource *resource,
+			     u32 length, u32 level);
+
+void acpi_dm_io_descriptor(union aml_resource *resource, u32 length, u32 level);
+
+void
+acpi_dm_fixed_io_descriptor(union aml_resource *resource,
+			    u32 length, u32 level);
+
+void
+acpi_dm_start_dependent_descriptor(union aml_resource *resource,
+				   u32 length, u32 level);
+
+void
+acpi_dm_end_dependent_descriptor(union aml_resource *resource,
+				 u32 length, u32 level);
+
+void
+acpi_dm_vendor_small_descriptor(union aml_resource *resource,
+				u32 length, u32 level);
+
+/*
+ * dmutils
+ */
+void acpi_dm_decode_attribute(u8 attribute);
+
+void acpi_dm_indent(u32 level);
+
+u8 acpi_dm_comma_if_list_member(union acpi_parse_object *op);
+
+void acpi_dm_comma_if_field_member(union acpi_parse_object *op);
+
+/*
+ * dmrestag
+ */
+void acpi_dm_find_resources(union acpi_parse_object *root);
+
+void
+acpi_dm_check_resource_reference(union acpi_parse_object *op,
+				 struct acpi_walk_state *walk_state);
+
+/*
+ * acdisasm
+ */
+void ad_disassembler_header(char *filename);
+
+#endif				/* __ACDISASM_H__ */
diff --git a/com32/acpioff/acpica_linuxized/include/acpi/acexcep.h b/com32/acpioff/acpica_linuxized/include/acpi/acexcep.h
new file mode 100644
index 00000000..7943a928
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/include/acpi/acexcep.h
@@ -0,0 +1,297 @@
+/******************************************************************************
+ *
+ * Name: acexcep.h - Exception codes returned by the ACPI subsystem
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACEXCEP_H__
+#define __ACEXCEP_H__
+
+/*
+ * Exceptions returned by external ACPI interfaces
+ */
+#define AE_CODE_ENVIRONMENTAL           0x0000
+#define AE_CODE_PROGRAMMER              0x1000
+#define AE_CODE_ACPI_TABLES             0x2000
+#define AE_CODE_AML                     0x3000
+#define AE_CODE_CONTROL                 0x4000
+#define AE_CODE_MASK                    0xF000
+
+#define ACPI_SUCCESS(a)                 (!(a))
+#define ACPI_FAILURE(a)                 (a)
+
+#define AE_OK                           (acpi_status) 0x0000
+
+/*
+ * Environmental exceptions
+ */
+#define AE_ERROR                        (acpi_status) (0x0001 | AE_CODE_ENVIRONMENTAL)
+#define AE_NO_ACPI_TABLES               (acpi_status) (0x0002 | AE_CODE_ENVIRONMENTAL)
+#define AE_NO_NAMESPACE                 (acpi_status) (0x0003 | AE_CODE_ENVIRONMENTAL)
+#define AE_NO_MEMORY                    (acpi_status) (0x0004 | AE_CODE_ENVIRONMENTAL)
+#define AE_NOT_FOUND                    (acpi_status) (0x0005 | AE_CODE_ENVIRONMENTAL)
+#define AE_NOT_EXIST                    (acpi_status) (0x0006 | AE_CODE_ENVIRONMENTAL)
+#define AE_ALREADY_EXISTS               (acpi_status) (0x0007 | AE_CODE_ENVIRONMENTAL)
+#define AE_TYPE                         (acpi_status) (0x0008 | AE_CODE_ENVIRONMENTAL)
+#define AE_NULL_OBJECT                  (acpi_status) (0x0009 | AE_CODE_ENVIRONMENTAL)
+#define AE_NULL_ENTRY                   (acpi_status) (0x000A | AE_CODE_ENVIRONMENTAL)
+#define AE_BUFFER_OVERFLOW              (acpi_status) (0x000B | AE_CODE_ENVIRONMENTAL)
+#define AE_STACK_OVERFLOW               (acpi_status) (0x000C | AE_CODE_ENVIRONMENTAL)
+#define AE_STACK_UNDERFLOW              (acpi_status) (0x000D | AE_CODE_ENVIRONMENTAL)
+#define AE_NOT_IMPLEMENTED              (acpi_status) (0x000E | AE_CODE_ENVIRONMENTAL)
+#define AE_SUPPORT                      (acpi_status) (0x000F | AE_CODE_ENVIRONMENTAL)
+#define AE_LIMIT                        (acpi_status) (0x0010 | AE_CODE_ENVIRONMENTAL)
+#define AE_TIME                         (acpi_status) (0x0011 | AE_CODE_ENVIRONMENTAL)
+#define AE_ACQUIRE_DEADLOCK             (acpi_status) (0x0012 | AE_CODE_ENVIRONMENTAL)
+#define AE_RELEASE_DEADLOCK             (acpi_status) (0x0013 | AE_CODE_ENVIRONMENTAL)
+#define AE_NOT_ACQUIRED                 (acpi_status) (0x0014 | AE_CODE_ENVIRONMENTAL)
+#define AE_ALREADY_ACQUIRED             (acpi_status) (0x0015 | AE_CODE_ENVIRONMENTAL)
+#define AE_NO_HARDWARE_RESPONSE         (acpi_status) (0x0016 | AE_CODE_ENVIRONMENTAL)
+#define AE_NO_GLOBAL_LOCK               (acpi_status) (0x0017 | AE_CODE_ENVIRONMENTAL)
+#define AE_ABORT_METHOD                 (acpi_status) (0x0018 | AE_CODE_ENVIRONMENTAL)
+#define AE_SAME_HANDLER                 (acpi_status) (0x0019 | AE_CODE_ENVIRONMENTAL)
+#define AE_NO_HANDLER                   (acpi_status) (0x001A | AE_CODE_ENVIRONMENTAL)
+#define AE_OWNER_ID_LIMIT               (acpi_status) (0x001B | AE_CODE_ENVIRONMENTAL)
+
+#define AE_CODE_ENV_MAX                 0x001B
+
+/*
+ * Programmer exceptions
+ */
+#define AE_BAD_PARAMETER                (acpi_status) (0x0001 | AE_CODE_PROGRAMMER)
+#define AE_BAD_CHARACTER                (acpi_status) (0x0002 | AE_CODE_PROGRAMMER)
+#define AE_BAD_PATHNAME                 (acpi_status) (0x0003 | AE_CODE_PROGRAMMER)
+#define AE_BAD_DATA                     (acpi_status) (0x0004 | AE_CODE_PROGRAMMER)
+#define AE_BAD_HEX_CONSTANT             (acpi_status) (0x0005 | AE_CODE_PROGRAMMER)
+#define AE_BAD_OCTAL_CONSTANT           (acpi_status) (0x0006 | AE_CODE_PROGRAMMER)
+#define AE_BAD_DECIMAL_CONSTANT         (acpi_status) (0x0007 | AE_CODE_PROGRAMMER)
+#define AE_MISSING_ARGUMENTS            (acpi_status) (0x0008 | AE_CODE_PROGRAMMER)
+#define AE_BAD_ADDRESS                  (acpi_status) (0x0009 | AE_CODE_PROGRAMMER)
+
+#define AE_CODE_PGM_MAX                 0x0009
+
+/*
+ * Acpi table exceptions
+ */
+#define AE_BAD_SIGNATURE                (acpi_status) (0x0001 | AE_CODE_ACPI_TABLES)
+#define AE_BAD_HEADER                   (acpi_status) (0x0002 | AE_CODE_ACPI_TABLES)
+#define AE_BAD_CHECKSUM                 (acpi_status) (0x0003 | AE_CODE_ACPI_TABLES)
+#define AE_BAD_VALUE                    (acpi_status) (0x0004 | AE_CODE_ACPI_TABLES)
+#define AE_INVALID_TABLE_LENGTH         (acpi_status) (0x0005 | AE_CODE_ACPI_TABLES)
+
+#define AE_CODE_TBL_MAX                 0x0005
+
+/*
+ * AML exceptions.  These are caused by problems with
+ * the actual AML byte stream
+ */
+#define AE_AML_BAD_OPCODE               (acpi_status) (0x0001 | AE_CODE_AML)
+#define AE_AML_NO_OPERAND               (acpi_status) (0x0002 | AE_CODE_AML)
+#define AE_AML_OPERAND_TYPE             (acpi_status) (0x0003 | AE_CODE_AML)
+#define AE_AML_OPERAND_VALUE            (acpi_status) (0x0004 | AE_CODE_AML)
+#define AE_AML_UNINITIALIZED_LOCAL      (acpi_status) (0x0005 | AE_CODE_AML)
+#define AE_AML_UNINITIALIZED_ARG        (acpi_status) (0x0006 | AE_CODE_AML)
+#define AE_AML_UNINITIALIZED_ELEMENT    (acpi_status) (0x0007 | AE_CODE_AML)
+#define AE_AML_NUMERIC_OVERFLOW         (acpi_status) (0x0008 | AE_CODE_AML)
+#define AE_AML_REGION_LIMIT             (acpi_status) (0x0009 | AE_CODE_AML)
+#define AE_AML_BUFFER_LIMIT             (acpi_status) (0x000A | AE_CODE_AML)
+#define AE_AML_PACKAGE_LIMIT            (acpi_status) (0x000B | AE_CODE_AML)
+#define AE_AML_DIVIDE_BY_ZERO           (acpi_status) (0x000C | AE_CODE_AML)
+#define AE_AML_BAD_NAME                 (acpi_status) (0x000D | AE_CODE_AML)
+#define AE_AML_NAME_NOT_FOUND           (acpi_status) (0x000E | AE_CODE_AML)
+#define AE_AML_INTERNAL                 (acpi_status) (0x000F | AE_CODE_AML)
+#define AE_AML_INVALID_SPACE_ID         (acpi_status) (0x0010 | AE_CODE_AML)
+#define AE_AML_STRING_LIMIT             (acpi_status) (0x0011 | AE_CODE_AML)
+#define AE_AML_NO_RETURN_VALUE          (acpi_status) (0x0012 | AE_CODE_AML)
+#define AE_AML_METHOD_LIMIT             (acpi_status) (0x0013 | AE_CODE_AML)
+#define AE_AML_NOT_OWNER                (acpi_status) (0x0014 | AE_CODE_AML)
+#define AE_AML_MUTEX_ORDER              (acpi_status) (0x0015 | AE_CODE_AML)
+#define AE_AML_MUTEX_NOT_ACQUIRED       (acpi_status) (0x0016 | AE_CODE_AML)
+#define AE_AML_INVALID_RESOURCE_TYPE    (acpi_status) (0x0017 | AE_CODE_AML)
+#define AE_AML_INVALID_INDEX            (acpi_status) (0x0018 | AE_CODE_AML)
+#define AE_AML_REGISTER_LIMIT           (acpi_status) (0x0019 | AE_CODE_AML)
+#define AE_AML_NO_WHILE                 (acpi_status) (0x001A | AE_CODE_AML)
+#define AE_AML_ALIGNMENT                (acpi_status) (0x001B | AE_CODE_AML)
+#define AE_AML_NO_RESOURCE_END_TAG      (acpi_status) (0x001C | AE_CODE_AML)
+#define AE_AML_BAD_RESOURCE_VALUE       (acpi_status) (0x001D | AE_CODE_AML)
+#define AE_AML_CIRCULAR_REFERENCE       (acpi_status) (0x001E | AE_CODE_AML)
+#define AE_AML_BAD_RESOURCE_LENGTH      (acpi_status) (0x001F | AE_CODE_AML)
+#define AE_AML_ILLEGAL_ADDRESS          (acpi_status) (0x0020 | AE_CODE_AML)
+#define AE_AML_INFINITE_LOOP            (acpi_status) (0x0021 | AE_CODE_AML)
+
+#define AE_CODE_AML_MAX                 0x0021
+
+/*
+ * Internal exceptions used for control
+ */
+#define AE_CTRL_RETURN_VALUE            (acpi_status) (0x0001 | AE_CODE_CONTROL)
+#define AE_CTRL_PENDING                 (acpi_status) (0x0002 | AE_CODE_CONTROL)
+#define AE_CTRL_TERMINATE               (acpi_status) (0x0003 | AE_CODE_CONTROL)
+#define AE_CTRL_TRUE                    (acpi_status) (0x0004 | AE_CODE_CONTROL)
+#define AE_CTRL_FALSE                   (acpi_status) (0x0005 | AE_CODE_CONTROL)
+#define AE_CTRL_DEPTH                   (acpi_status) (0x0006 | AE_CODE_CONTROL)
+#define AE_CTRL_END                     (acpi_status) (0x0007 | AE_CODE_CONTROL)
+#define AE_CTRL_TRANSFER                (acpi_status) (0x0008 | AE_CODE_CONTROL)
+#define AE_CTRL_BREAK                   (acpi_status) (0x0009 | AE_CODE_CONTROL)
+#define AE_CTRL_CONTINUE                (acpi_status) (0x000A | AE_CODE_CONTROL)
+#define AE_CTRL_SKIP                    (acpi_status) (0x000B | AE_CODE_CONTROL)
+#define AE_CTRL_PARSE_CONTINUE          (acpi_status) (0x000C | AE_CODE_CONTROL)
+#define AE_CTRL_PARSE_PENDING           (acpi_status) (0x000D | AE_CODE_CONTROL)
+
+#define AE_CODE_CTRL_MAX                0x000D
+
+/* Exception strings for acpi_format_exception */
+
+#ifdef DEFINE_ACPI_GLOBALS
+
+/*
+ * String versions of the exception codes above
+ * These strings must match the corresponding defines exactly
+ */
+char const *acpi_gbl_exception_names_env[] = {
+	"AE_OK",
+	"AE_ERROR",
+	"AE_NO_ACPI_TABLES",
+	"AE_NO_NAMESPACE",
+	"AE_NO_MEMORY",
+	"AE_NOT_FOUND",
+	"AE_NOT_EXIST",
+	"AE_ALREADY_EXISTS",
+	"AE_TYPE",
+	"AE_NULL_OBJECT",
+	"AE_NULL_ENTRY",
+	"AE_BUFFER_OVERFLOW",
+	"AE_STACK_OVERFLOW",
+	"AE_STACK_UNDERFLOW",
+	"AE_NOT_IMPLEMENTED",
+	"AE_SUPPORT",
+	"AE_LIMIT",
+	"AE_TIME",
+	"AE_ACQUIRE_DEADLOCK",
+	"AE_RELEASE_DEADLOCK",
+	"AE_NOT_ACQUIRED",
+	"AE_ALREADY_ACQUIRED",
+	"AE_NO_HARDWARE_RESPONSE",
+	"AE_NO_GLOBAL_LOCK",
+	"AE_ABORT_METHOD",
+	"AE_SAME_HANDLER",
+	"AE_NO_HANDLER",
+	"AE_OWNER_ID_LIMIT"
+};
+
+char const *acpi_gbl_exception_names_pgm[] = {
+	NULL,
+	"AE_BAD_PARAMETER",
+	"AE_BAD_CHARACTER",
+	"AE_BAD_PATHNAME",
+	"AE_BAD_DATA",
+	"AE_BAD_HEX_CONSTANT",
+	"AE_BAD_OCTAL_CONSTANT",
+	"AE_BAD_DECIMAL_CONSTANT",
+	"AE_MISSING_ARGUMENTS",
+	"AE_BAD_ADDRESS"
+};
+
+char const *acpi_gbl_exception_names_tbl[] = {
+	NULL,
+	"AE_BAD_SIGNATURE",
+	"AE_BAD_HEADER",
+	"AE_BAD_CHECKSUM",
+	"AE_BAD_VALUE",
+	"AE_INVALID_TABLE_LENGTH"
+};
+
+char const *acpi_gbl_exception_names_aml[] = {
+	NULL,
+	"AE_AML_BAD_OPCODE",
+	"AE_AML_NO_OPERAND",
+	"AE_AML_OPERAND_TYPE",
+	"AE_AML_OPERAND_VALUE",
+	"AE_AML_UNINITIALIZED_LOCAL",
+	"AE_AML_UNINITIALIZED_ARG",
+	"AE_AML_UNINITIALIZED_ELEMENT",
+	"AE_AML_NUMERIC_OVERFLOW",
+	"AE_AML_REGION_LIMIT",
+	"AE_AML_BUFFER_LIMIT",
+	"AE_AML_PACKAGE_LIMIT",
+	"AE_AML_DIVIDE_BY_ZERO",
+	"AE_AML_BAD_NAME",
+	"AE_AML_NAME_NOT_FOUND",
+	"AE_AML_INTERNAL",
+	"AE_AML_INVALID_SPACE_ID",
+	"AE_AML_STRING_LIMIT",
+	"AE_AML_NO_RETURN_VALUE",
+	"AE_AML_METHOD_LIMIT",
+	"AE_AML_NOT_OWNER",
+	"AE_AML_MUTEX_ORDER",
+	"AE_AML_MUTEX_NOT_ACQUIRED",
+	"AE_AML_INVALID_RESOURCE_TYPE",
+	"AE_AML_INVALID_INDEX",
+	"AE_AML_REGISTER_LIMIT",
+	"AE_AML_NO_WHILE",
+	"AE_AML_ALIGNMENT",
+	"AE_AML_NO_RESOURCE_END_TAG",
+	"AE_AML_BAD_RESOURCE_VALUE",
+	"AE_AML_CIRCULAR_REFERENCE",
+	"AE_AML_BAD_RESOURCE_LENGTH",
+	"AE_AML_ILLEGAL_ADDRESS",
+	"AE_AML_INFINITE_LOOP"
+};
+
+char const *acpi_gbl_exception_names_ctrl[] = {
+	NULL,
+	"AE_CTRL_RETURN_VALUE",
+	"AE_CTRL_PENDING",
+	"AE_CTRL_TERMINATE",
+	"AE_CTRL_TRUE",
+	"AE_CTRL_FALSE",
+	"AE_CTRL_DEPTH",
+	"AE_CTRL_END",
+	"AE_CTRL_TRANSFER",
+	"AE_CTRL_BREAK",
+	"AE_CTRL_CONTINUE",
+	"AE_CTRL_SKIP",
+	"AE_CTRL_PARSE_CONTINUE",
+	"AE_CTRL_PARSE_PENDING"
+};
+
+#endif				/* ACPI GLOBALS */
+
+#endif				/* __ACEXCEP_H__ */
diff --git a/com32/acpioff/acpica_linuxized/include/acpi/acnames.h b/com32/acpioff/acpica_linuxized/include/acpi/acnames.h
new file mode 100644
index 00000000..7dc0ec22
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/include/acpi/acnames.h
@@ -0,0 +1,84 @@
+/******************************************************************************
+ *
+ * Name: acnames.h - Global names and strings
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACNAMES_H__
+#define __ACNAMES_H__
+
+/* Method names - these methods can appear anywhere in the namespace */
+
+#define METHOD_NAME__HID        "_HID"
+#define METHOD_NAME__CID        "_CID"
+#define METHOD_NAME__UID        "_UID"
+#define METHOD_NAME__ADR        "_ADR"
+#define METHOD_NAME__INI        "_INI"
+#define METHOD_NAME__STA        "_STA"
+#define METHOD_NAME__REG        "_REG"
+#define METHOD_NAME__SEG        "_SEG"
+#define METHOD_NAME__BBN        "_BBN"
+#define METHOD_NAME__PRT        "_PRT"
+#define METHOD_NAME__CRS        "_CRS"
+#define METHOD_NAME__PRS        "_PRS"
+#define METHOD_NAME__AEI        "_AEI"
+#define METHOD_NAME__PRW        "_PRW"
+#define METHOD_NAME__SRS        "_SRS"
+
+/* Method names - these methods must appear at the namespace root */
+
+#define METHOD_NAME__BFS        "\\_BFS"
+#define METHOD_NAME__GTS        "\\_GTS"
+#define METHOD_NAME__PTS        "\\_PTS"
+#define METHOD_NAME__SST        "\\_SI._SST"
+#define METHOD_NAME__WAK        "\\_WAK"
+
+/* Definitions of the predefined namespace names  */
+
+#define ACPI_UNKNOWN_NAME       (u32) 0x3F3F3F3F	/* Unknown name is "????" */
+#define ACPI_ROOT_NAME          (u32) 0x5F5F5F5C	/* Root name is    "\___" */
+
+#define ACPI_PREFIX_MIXED       (u32) 0x69706341	/* "Acpi" */
+#define ACPI_PREFIX_LOWER       (u32) 0x69706361	/* "acpi" */
+
+#define ACPI_NS_ROOT_PATH       "\\"
+#define ACPI_NS_SYSTEM_BUS      "_SB_"
+
+#endif				/* __ACNAMES_H__  */
diff --git a/com32/acpioff/acpica_linuxized/include/acpi/acoutput.h b/com32/acpioff/acpica_linuxized/include/acpi/acoutput.h
new file mode 100644
index 00000000..66f76b76
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/include/acpi/acoutput.h
@@ -0,0 +1,283 @@
+/******************************************************************************
+ *
+ * Name: acoutput.h -- debug output
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACOUTPUT_H__
+#define __ACOUTPUT_H__
+
+/*
+ * Debug levels and component IDs. These are used to control the
+ * granularity of the output of the ACPI_DEBUG_PRINT macro -- on a
+ * per-component basis and a per-exception-type basis.
+ */
+
+/* Component IDs are used in the global "DebugLayer" */
+
+#define ACPI_UTILITIES              0x00000001
+#define ACPI_HARDWARE               0x00000002
+#define ACPI_EVENTS                 0x00000004
+#define ACPI_TABLES                 0x00000008
+#define ACPI_NAMESPACE              0x00000010
+#define ACPI_PARSER                 0x00000020
+#define ACPI_DISPATCHER             0x00000040
+#define ACPI_EXECUTER               0x00000080
+#define ACPI_RESOURCES              0x00000100
+#define ACPI_CA_DEBUGGER            0x00000200
+#define ACPI_OS_SERVICES            0x00000400
+#define ACPI_CA_DISASSEMBLER        0x00000800
+
+/* Component IDs for ACPI tools and utilities */
+
+#define ACPI_COMPILER               0x00001000
+#define ACPI_TOOLS                  0x00002000
+#define ACPI_EXAMPLE                0x00004000
+#define ACPI_DRIVER                 0x00008000
+#define DT_COMPILER                 0x00010000
+
+#define ACPI_ALL_COMPONENTS         0x0001FFFF
+#define ACPI_COMPONENT_DEFAULT      (ACPI_ALL_COMPONENTS)
+
+/* Component IDs reserved for ACPI drivers */
+
+#define ACPI_ALL_DRIVERS            0xFFFF0000
+
+/*
+ * Raw debug output levels, do not use these in the ACPI_DEBUG_PRINT macros
+ */
+#define ACPI_LV_INIT                0x00000001
+#define ACPI_LV_DEBUG_OBJECT        0x00000002
+#define ACPI_LV_INFO                0x00000004
+#define ACPI_LV_REPAIR              0x00000008
+#define ACPI_LV_ALL_EXCEPTIONS      0x0000000F
+
+/* Trace verbosity level 1 [Standard Trace Level] */
+
+#define ACPI_LV_INIT_NAMES          0x00000020
+#define ACPI_LV_PARSE               0x00000040
+#define ACPI_LV_LOAD                0x00000080
+#define ACPI_LV_DISPATCH            0x00000100
+#define ACPI_LV_EXEC                0x00000200
+#define ACPI_LV_NAMES               0x00000400
+#define ACPI_LV_OPREGION            0x00000800
+#define ACPI_LV_BFIELD              0x00001000
+#define ACPI_LV_TABLES              0x00002000
+#define ACPI_LV_VALUES              0x00004000
+#define ACPI_LV_OBJECTS             0x00008000
+#define ACPI_LV_RESOURCES           0x00010000
+#define ACPI_LV_USER_REQUESTS       0x00020000
+#define ACPI_LV_PACKAGE             0x00040000
+#define ACPI_LV_VERBOSITY1          0x0007FF40 | ACPI_LV_ALL_EXCEPTIONS
+
+/* Trace verbosity level 2 [Function tracing and memory allocation] */
+
+#define ACPI_LV_ALLOCATIONS         0x00100000
+#define ACPI_LV_FUNCTIONS           0x00200000
+#define ACPI_LV_OPTIMIZATIONS       0x00400000
+#define ACPI_LV_VERBOSITY2          0x00700000 | ACPI_LV_VERBOSITY1
+#define ACPI_LV_ALL                 ACPI_LV_VERBOSITY2
+
+/* Trace verbosity level 3 [Threading, I/O, and Interrupts] */
+
+#define ACPI_LV_MUTEX               0x01000000
+#define ACPI_LV_THREADS             0x02000000
+#define ACPI_LV_IO                  0x04000000
+#define ACPI_LV_INTERRUPTS          0x08000000
+#define ACPI_LV_VERBOSITY3          0x0F000000 | ACPI_LV_VERBOSITY2
+
+/* Exceptionally verbose output -- also used in the global "DebugLevel"  */
+
+#define ACPI_LV_AML_DISASSEMBLE     0x10000000
+#define ACPI_LV_VERBOSE_INFO        0x20000000
+#define ACPI_LV_FULL_TABLES         0x40000000
+#define ACPI_LV_EVENTS              0x80000000
+#define ACPI_LV_VERBOSE             0xF0000000
+
+/*
+ * Debug level macros that are used in the DEBUG_PRINT macros
+ */
+#define ACPI_DEBUG_LEVEL(dl)        (u32) dl,ACPI_DEBUG_PARAMETERS
+
+/*
+ * Exception level -- used in the global "DebugLevel"
+ *
+ * Note: For errors, use the ACPI_ERROR or ACPI_EXCEPTION interfaces.
+ * For warnings, use ACPI_WARNING.
+ */
+#define ACPI_DB_INIT                ACPI_DEBUG_LEVEL (ACPI_LV_INIT)
+#define ACPI_DB_DEBUG_OBJECT        ACPI_DEBUG_LEVEL (ACPI_LV_DEBUG_OBJECT)
+#define ACPI_DB_INFO                ACPI_DEBUG_LEVEL (ACPI_LV_INFO)
+#define ACPI_DB_REPAIR              ACPI_DEBUG_LEVEL (ACPI_LV_REPAIR)
+#define ACPI_DB_ALL_EXCEPTIONS      ACPI_DEBUG_LEVEL (ACPI_LV_ALL_EXCEPTIONS)
+
+/* Trace level -- also used in the global "DebugLevel" */
+
+#define ACPI_DB_INIT_NAMES          ACPI_DEBUG_LEVEL (ACPI_LV_INIT_NAMES)
+#define ACPI_DB_THREADS             ACPI_DEBUG_LEVEL (ACPI_LV_THREADS)
+#define ACPI_DB_PARSE               ACPI_DEBUG_LEVEL (ACPI_LV_PARSE)
+#define ACPI_DB_DISPATCH            ACPI_DEBUG_LEVEL (ACPI_LV_DISPATCH)
+#define ACPI_DB_LOAD                ACPI_DEBUG_LEVEL (ACPI_LV_LOAD)
+#define ACPI_DB_EXEC                ACPI_DEBUG_LEVEL (ACPI_LV_EXEC)
+#define ACPI_DB_NAMES               ACPI_DEBUG_LEVEL (ACPI_LV_NAMES)
+#define ACPI_DB_OPREGION            ACPI_DEBUG_LEVEL (ACPI_LV_OPREGION)
+#define ACPI_DB_BFIELD              ACPI_DEBUG_LEVEL (ACPI_LV_BFIELD)
+#define ACPI_DB_TABLES              ACPI_DEBUG_LEVEL (ACPI_LV_TABLES)
+#define ACPI_DB_FUNCTIONS           ACPI_DEBUG_LEVEL (ACPI_LV_FUNCTIONS)
+#define ACPI_DB_OPTIMIZATIONS       ACPI_DEBUG_LEVEL (ACPI_LV_OPTIMIZATIONS)
+#define ACPI_DB_VALUES              ACPI_DEBUG_LEVEL (ACPI_LV_VALUES)
+#define ACPI_DB_OBJECTS             ACPI_DEBUG_LEVEL (ACPI_LV_OBJECTS)
+#define ACPI_DB_ALLOCATIONS         ACPI_DEBUG_LEVEL (ACPI_LV_ALLOCATIONS)
+#define ACPI_DB_RESOURCES           ACPI_DEBUG_LEVEL (ACPI_LV_RESOURCES)
+#define ACPI_DB_IO                  ACPI_DEBUG_LEVEL (ACPI_LV_IO)
+#define ACPI_DB_INTERRUPTS          ACPI_DEBUG_LEVEL (ACPI_LV_INTERRUPTS)
+#define ACPI_DB_USER_REQUESTS       ACPI_DEBUG_LEVEL (ACPI_LV_USER_REQUESTS)
+#define ACPI_DB_PACKAGE             ACPI_DEBUG_LEVEL (ACPI_LV_PACKAGE)
+#define ACPI_DB_MUTEX               ACPI_DEBUG_LEVEL (ACPI_LV_MUTEX)
+#define ACPI_DB_EVENTS              ACPI_DEBUG_LEVEL (ACPI_LV_EVENTS)
+
+#define ACPI_DB_ALL                 ACPI_DEBUG_LEVEL (ACPI_LV_ALL)
+
+/* Defaults for debug_level, debug and normal */
+
+#define ACPI_DEBUG_DEFAULT          (ACPI_LV_INIT | ACPI_LV_DEBUG_OBJECT | ACPI_LV_REPAIR)
+#define ACPI_NORMAL_DEFAULT         (ACPI_LV_INIT | ACPI_LV_DEBUG_OBJECT | ACPI_LV_REPAIR)
+#define ACPI_DEBUG_ALL              (ACPI_LV_AML_DISASSEMBLE | ACPI_LV_ALL_EXCEPTIONS | ACPI_LV_ALL)
+
+#if defined (ACPI_DEBUG_OUTPUT) || !defined (ACPI_NO_ERROR_MESSAGES)
+/*
+ * The module name is used primarily for error and debug messages.
+ * The __FILE__ macro is not very useful for this, because it
+ * usually includes the entire pathname to the module making the
+ * debug output difficult to read.
+ */
+#define ACPI_MODULE_NAME(name)          static const char ACPI_UNUSED_VAR _acpi_module_name[] = name;
+#else
+/*
+ * For the no-debug and no-error-msg cases, we must at least define
+ * a null module name.
+ */
+#define ACPI_MODULE_NAME(name)
+#define _acpi_module_name ""
+#endif
+
+/*
+ * Ascii error messages can be configured out
+ */
+#ifndef ACPI_NO_ERROR_MESSAGES
+#define AE_INFO                         _acpi_module_name, __LINE__
+
+/*
+ * Error reporting. Callers module and line number are inserted by AE_INFO,
+ * the plist contains a set of parens to allow variable-length lists.
+ * These macros are used for both the debug and non-debug versions of the code.
+ */
+#define ACPI_INFO(plist)                acpi_info plist
+#define ACPI_WARNING(plist)             acpi_warning plist
+#define ACPI_EXCEPTION(plist)           acpi_exception plist
+#define ACPI_ERROR(plist)               acpi_error plist
+#define ACPI_DEBUG_OBJECT(obj,l,i)      acpi_ex_do_debug_object(obj,l,i)
+
+#else
+
+/* No error messages */
+
+#define ACPI_INFO(plist)
+#define ACPI_WARNING(plist)
+#define ACPI_EXCEPTION(plist)
+#define ACPI_ERROR(plist)
+#define ACPI_DEBUG_OBJECT(obj,l,i)
+
+#endif				/* ACPI_NO_ERROR_MESSAGES */
+
+/*
+ * Debug macros that are conditionally compiled
+ */
+#ifdef ACPI_DEBUG_OUTPUT
+
+/*
+ * If ACPI_GET_FUNCTION_NAME was not defined in the compiler-dependent header,
+ * define it now. This is the case where there the compiler does not support
+ * a __FUNCTION__ macro or equivalent.
+ */
+#ifndef ACPI_GET_FUNCTION_NAME
+#define ACPI_GET_FUNCTION_NAME          _acpi_function_name
+
+/*
+ * The Name parameter should be the procedure name as a quoted string.
+ * The function name is also used by the function exit macros below.
+ * Note: (const char) is used to be compatible with the debug interfaces
+ * and macros such as __FUNCTION__.
+ */
+#define ACPI_FUNCTION_NAME(name)        static const char _acpi_function_name[] = #name;
+
+#else
+/* Compiler supports __FUNCTION__ (or equivalent) -- Ignore this macro */
+
+#define ACPI_FUNCTION_NAME(name)
+#endif				/* ACPI_GET_FUNCTION_NAME */
+
+/*
+ * Common parameters used for debug output functions:
+ * line number, function name, module(file) name, component ID
+ */
+#define ACPI_DEBUG_PARAMETERS           __LINE__, ACPI_GET_FUNCTION_NAME, _acpi_module_name, _COMPONENT
+
+/*
+ * Master debug print macros
+ * Print message if and only if:
+ *    1) Debug print for the current component is enabled
+ *    2) Debug error level or trace level for the print statement is enabled
+ */
+#define ACPI_DEBUG_PRINT(plist)         acpi_debug_print plist
+#define ACPI_DEBUG_PRINT_RAW(plist)     acpi_debug_print_raw plist
+
+#else
+/*
+ * This is the non-debug case -- make everything go away,
+ * leaving no executable debug code!
+ */
+#define ACPI_FUNCTION_NAME(a)
+#define ACPI_DEBUG_PRINT(pl)
+#define ACPI_DEBUG_PRINT_RAW(pl)
+
+#endif				/* ACPI_DEBUG_OUTPUT */
+
+#endif				/* __ACOUTPUT_H__ */
diff --git a/com32/acpioff/acpica_linuxized/include/acpi/acpi.h b/com32/acpioff/acpica_linuxized/include/acpi/acpi.h
new file mode 100644
index 00000000..c433d5e2
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/include/acpi/acpi.h
@@ -0,0 +1,66 @@
+/******************************************************************************
+ *
+ * Name: acpi.h - Master public include file used to interface to ACPICA
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACPI_H__
+#define __ACPI_H__
+
+/*
+ * Public include files for use by code that will interface to ACPICA.
+ *
+ * Information includes the ACPICA data types, names, exceptions, and
+ * external interface prototypes. Also included are the definitions for
+ * all ACPI tables (FADT, MADT, etc.)
+ *
+ * Note: The order of these include files is important.
+ */
+#include "platform/acenv.h"	/* Environment-specific items */
+#include "acnames.h"		/* Common ACPI names and strings */
+#include "actypes.h"		/* ACPICA data types and structures */
+#include "acexcep.h"		/* ACPICA exceptions */
+#include "actbl.h"		/* ACPI table definitions */
+#include "acoutput.h"		/* Error output and Debug macros */
+#include "acrestyp.h"		/* Resource Descriptor structs */
+#include "acpiosxf.h"		/* OSL interfaces (ACPICA-to-OS) */
+#include "acpixf.h"		/* ACPI core subsystem external interfaces */
+
+#endif				/* __ACPI_H__ */
diff --git a/com32/acpioff/acpica_linuxized/include/acpi/acpiosxf.h b/com32/acpioff/acpica_linuxized/include/acpi/acpiosxf.h
new file mode 100644
index 00000000..172b8b6b
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/include/acpi/acpiosxf.h
@@ -0,0 +1,265 @@
+
+/******************************************************************************
+ *
+ * Name: acpiosxf.h - All interfaces to the OS Services Layer (OSL).  These
+ *                    interfaces must be implemented by OSL to interface the
+ *                    ACPI components to the host operating system.
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACPIOSXF_H__
+#define __ACPIOSXF_H__
+
+#include "platform/acenv.h"
+#include "actypes.h"
+
+/* Types for acpi_os_execute */
+
+typedef enum {
+	OSL_GLOBAL_LOCK_HANDLER,
+	OSL_NOTIFY_HANDLER,
+	OSL_GPE_HANDLER,
+	OSL_DEBUGGER_THREAD,
+	OSL_EC_POLL_HANDLER,
+	OSL_EC_BURST_HANDLER
+} acpi_execute_type;
+
+#define ACPI_NO_UNIT_LIMIT          ((u32) -1)
+#define ACPI_MUTEX_SEM              1
+
+/* Functions for acpi_os_signal */
+
+#define ACPI_SIGNAL_FATAL           0
+#define ACPI_SIGNAL_BREAKPOINT      1
+
+struct acpi_signal_fatal_info {
+	u32 type;
+	u32 code;
+	u32 argument;
+};
+
+/*
+ * OSL Initialization and shutdown primitives
+ */
+acpi_status acpi_os_initialize(void);
+
+acpi_status acpi_os_terminate(void);
+
+/*
+ * ACPI Table interfaces
+ */
+acpi_physical_address acpi_os_get_root_pointer(void);
+
+acpi_status
+acpi_os_predefined_override(const struct acpi_predefined_names *init_val,
+			    acpi_string * new_val);
+
+acpi_status
+acpi_os_table_override(struct acpi_table_header *existing_table,
+		       struct acpi_table_header **new_table);
+
+/*
+ * Spinlock primitives
+ */
+acpi_status acpi_os_create_lock(acpi_spinlock * out_handle);
+
+void acpi_os_delete_lock(acpi_spinlock handle);
+
+acpi_cpu_flags acpi_os_acquire_lock(acpi_spinlock handle);
+
+void acpi_os_release_lock(acpi_spinlock handle, acpi_cpu_flags flags);
+
+/*
+ * Semaphore primitives
+ */
+acpi_status
+acpi_os_create_semaphore(u32 max_units,
+			 u32 initial_units, acpi_semaphore * out_handle);
+
+acpi_status acpi_os_delete_semaphore(acpi_semaphore handle);
+
+acpi_status
+acpi_os_wait_semaphore(acpi_semaphore handle, u32 units, u16 timeout);
+
+acpi_status acpi_os_signal_semaphore(acpi_semaphore handle, u32 units);
+
+/*
+ * Mutex primitives. May be configured to use semaphores instead via
+ * ACPI_MUTEX_TYPE (see platform/acenv.h)
+ */
+#if (ACPI_MUTEX_TYPE != ACPI_BINARY_SEMAPHORE)
+
+acpi_status acpi_os_create_mutex(acpi_mutex * out_handle);
+
+void acpi_os_delete_mutex(acpi_mutex handle);
+
+acpi_status acpi_os_acquire_mutex(acpi_mutex handle, u16 timeout);
+
+void acpi_os_release_mutex(acpi_mutex handle);
+#endif
+
+/*
+ * Memory allocation and mapping
+ */
+void *acpi_os_allocate(acpi_size size);
+
+void acpi_os_free(void *memory);
+
+void *acpi_os_map_memory(acpi_physical_address where, acpi_size length);
+
+void acpi_os_unmap_memory(void *logical_address, acpi_size size);
+
+acpi_status
+acpi_os_get_physical_address(void *logical_address,
+			     acpi_physical_address * physical_address);
+
+/*
+ * Memory/Object Cache
+ */
+acpi_status
+acpi_os_create_cache(char *cache_name,
+		     u16 object_size,
+		     u16 max_depth, acpi_cache_t ** return_cache);
+
+acpi_status acpi_os_delete_cache(acpi_cache_t * cache);
+
+acpi_status acpi_os_purge_cache(acpi_cache_t * cache);
+
+void *acpi_os_acquire_object(acpi_cache_t * cache);
+
+acpi_status acpi_os_release_object(acpi_cache_t * cache, void *object);
+
+/*
+ * Interrupt handlers
+ */
+acpi_status
+acpi_os_install_interrupt_handler(u32 interrupt_number,
+				  acpi_osd_handler service_routine,
+				  void *context);
+
+acpi_status
+acpi_os_remove_interrupt_handler(u32 interrupt_number,
+				 acpi_osd_handler service_routine);
+
+/*
+ * Threads and Scheduling
+ */
+acpi_thread_id acpi_os_get_thread_id(void);
+
+acpi_status
+acpi_os_execute(acpi_execute_type type,
+		acpi_osd_exec_callback function, void *context);
+
+void acpi_os_wait_events_complete(void *context);
+
+void acpi_os_sleep(u64 milliseconds);
+
+void acpi_os_stall(u32 microseconds);
+
+/*
+ * Platform and hardware-independent I/O interfaces
+ */
+acpi_status acpi_os_read_port(acpi_io_address address, u32 *value, u32 width);
+
+acpi_status acpi_os_write_port(acpi_io_address address, u32 value, u32 width);
+
+/*
+ * Platform and hardware-independent physical memory interfaces
+ */
+acpi_status
+acpi_os_read_memory(acpi_physical_address address, u32 *value, u32 width);
+
+acpi_status
+acpi_os_write_memory(acpi_physical_address address, u32 value, u32 width);
+
+/*
+ * Platform and hardware-independent PCI configuration space access
+ * Note: Can't use "Register" as a parameter, changed to "Reg" --
+ * certain compilers complain.
+ */
+acpi_status
+acpi_os_read_pci_configuration(struct acpi_pci_id *pci_id,
+			       u32 reg, u64 *value, u32 width);
+
+acpi_status
+acpi_os_write_pci_configuration(struct acpi_pci_id *pci_id,
+				u32 reg, u64 value, u32 width);
+
+/*
+ * Miscellaneous
+ */
+u8 acpi_os_readable(void *pointer, acpi_size length);
+
+u8 acpi_os_writable(void *pointer, acpi_size length);
+
+u64 acpi_os_get_timer(void);
+
+acpi_status acpi_os_signal(u32 function, void *info);
+
+/*
+ * Debug print routines
+ */
+void ACPI_INTERNAL_VAR_XFACE acpi_os_printf(const char *format, ...);
+
+void acpi_os_vprintf(const char *format, va_list args);
+
+void acpi_os_redirect_output(void *destination);
+
+/*
+ * Debug input
+ */
+acpi_status acpi_os_get_line(char *buffer, u32 buffer_length, u32 *bytes_read);
+
+/*
+ * Directory manipulation
+ */
+void *acpi_os_open_directory(char *pathname,
+			     char *wildcard_spec, char requested_file_type);
+
+/* requeste_file_type values */
+
+#define REQUEST_FILE_ONLY                   0
+#define REQUEST_DIR_ONLY                    1
+
+char *acpi_os_get_next_filename(void *dir_handle);
+
+void acpi_os_close_directory(void *dir_handle);
+
+#endif				/* __ACPIOSXF_H__ */
diff --git a/com32/acpioff/acpica_linuxized/include/acpi/acpixf.h b/com32/acpioff/acpica_linuxized/include/acpi/acpixf.h
new file mode 100644
index 00000000..59f92b7e
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/include/acpi/acpixf.h
@@ -0,0 +1,450 @@
+
+/******************************************************************************
+ *
+ * Name: acpixf.h - External interfaces to the ACPI subsystem
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACXFACE_H__
+#define __ACXFACE_H__
+
+/* Current ACPICA subsystem version in YYYYMMDD format */
+
+#define ACPI_CA_VERSION                 0x20120111
+
+#include "actypes.h"
+#include "actbl.h"
+
+/*
+ * Globals that are publically available
+ */
+extern u32 acpi_current_gpe_count;
+extern struct acpi_table_fadt acpi_gbl_FADT;
+extern u8 acpi_gbl_system_awake_and_running;
+extern u8 acpi_gbl_reduced_hardware;	/* ACPI 5.0 */
+
+/* Runtime configuration of debug print levels */
+
+extern u32 acpi_dbg_level;
+extern u32 acpi_dbg_layer;
+
+/* ACPICA runtime options */
+
+extern u8 acpi_gbl_enable_interpreter_slack;
+extern u8 acpi_gbl_all_methods_serialized;
+extern u8 acpi_gbl_create_osi_method;
+extern u8 acpi_gbl_use_default_register_widths;
+extern acpi_name acpi_gbl_trace_method_name;
+extern u32 acpi_gbl_trace_flags;
+extern u8 acpi_gbl_enable_aml_debug_object;
+extern u8 acpi_gbl_copy_dsdt_locally;
+extern u8 acpi_gbl_truncate_io_addresses;
+extern u8 acpi_gbl_disable_auto_repair;
+
+/*
+ * Initialization
+ */
+acpi_status
+acpi_initialize_tables(struct acpi_table_desc *initial_storage,
+		       u32 initial_table_count, u8 allow_resize);
+
+acpi_status acpi_initialize_subsystem(void);
+
+acpi_status acpi_enable_subsystem(u32 flags);
+
+acpi_status acpi_initialize_objects(u32 flags);
+
+acpi_status acpi_terminate(void);
+
+/*
+ * Miscellaneous global interfaces
+ */
+acpi_status acpi_enable(void);
+
+acpi_status acpi_disable(void);
+
+acpi_status acpi_subsystem_status(void);
+
+acpi_status acpi_get_system_info(struct acpi_buffer *ret_buffer);
+
+acpi_status acpi_get_statistics(struct acpi_statistics *stats);
+
+const char *acpi_format_exception(acpi_status exception);
+
+acpi_status acpi_purge_cached_objects(void);
+
+acpi_status acpi_install_interface(acpi_string interface_name);
+
+acpi_status acpi_remove_interface(acpi_string interface_name);
+
+u32
+acpi_check_address_range(acpi_adr_space_type space_id,
+			 acpi_physical_address address,
+			 acpi_size length, u8 warn);
+
+/*
+ * ACPI Memory management
+ */
+void *acpi_allocate(u32 size);
+
+void *acpi_callocate(u32 size);
+
+void acpi_free(void *address);
+
+/*
+ * ACPI table manipulation interfaces
+ */
+acpi_status acpi_reallocate_root_table(void);
+
+acpi_status acpi_find_root_pointer(acpi_size * rsdp_address);
+
+acpi_status acpi_load_tables(void);
+
+acpi_status
+acpi_get_table_header(acpi_string signature,
+		      u32 instance, struct acpi_table_header *out_table_header);
+
+acpi_status
+acpi_get_table(acpi_string signature,
+	       u32 instance, struct acpi_table_header **out_table);
+
+acpi_status
+acpi_get_table_by_index(u32 table_index, struct acpi_table_header **out_table);
+
+acpi_status
+acpi_install_table_handler(acpi_table_handler handler, void *context);
+
+acpi_status acpi_remove_table_handler(acpi_table_handler handler);
+
+/*
+ * Namespace and name interfaces
+ */
+acpi_status
+acpi_walk_namespace(acpi_object_type type,
+		    acpi_handle start_object,
+		    u32 max_depth,
+		    acpi_walk_callback pre_order_visit,
+		    acpi_walk_callback post_order_visit,
+		    void *context, void **return_value);
+
+acpi_status
+acpi_get_devices(char *HID,
+		 acpi_walk_callback user_function,
+		 void *context, void **return_value);
+
+acpi_status
+acpi_get_name(acpi_handle object,
+	      u32 name_type, struct acpi_buffer *ret_path_ptr);
+
+acpi_status
+acpi_get_handle(acpi_handle parent,
+		acpi_string pathname, acpi_handle * ret_handle);
+
+acpi_status
+acpi_attach_data(acpi_handle object, acpi_object_handler handler, void *data);
+
+acpi_status acpi_detach_data(acpi_handle object, acpi_object_handler handler);
+
+acpi_status
+acpi_get_data(acpi_handle object, acpi_object_handler handler, void **data);
+
+acpi_status
+acpi_debug_trace(char *name, u32 debug_level, u32 debug_layer, u32 flags);
+
+/*
+ * Object manipulation and enumeration
+ */
+acpi_status
+acpi_evaluate_object(acpi_handle object,
+		     acpi_string pathname,
+		     struct acpi_object_list *parameter_objects,
+		     struct acpi_buffer *return_object_buffer);
+
+acpi_status
+acpi_evaluate_object_typed(acpi_handle object,
+			   acpi_string pathname,
+			   struct acpi_object_list *external_params,
+			   struct acpi_buffer *return_buffer,
+			   acpi_object_type return_type);
+
+acpi_status
+acpi_get_object_info(acpi_handle object,
+		     struct acpi_device_info **return_buffer);
+
+acpi_status acpi_install_method(u8 *buffer);
+
+acpi_status
+acpi_get_next_object(acpi_object_type type,
+		     acpi_handle parent,
+		     acpi_handle child, acpi_handle * out_handle);
+
+acpi_status acpi_get_type(acpi_handle object, acpi_object_type * out_type);
+
+acpi_status acpi_get_parent(acpi_handle object, acpi_handle * out_handle);
+
+/*
+ * Handler interfaces
+ */
+acpi_status
+acpi_install_initialization_handler(acpi_init_handler handler, u32 function);
+
+acpi_status
+acpi_install_global_event_handler(acpi_gbl_event_handler handler,
+				  void *context);
+
+acpi_status
+acpi_install_fixed_event_handler(u32 acpi_event,
+				 acpi_event_handler handler, void *context);
+
+acpi_status
+acpi_remove_fixed_event_handler(u32 acpi_event, acpi_event_handler handler);
+
+acpi_status
+acpi_install_gpe_handler(acpi_handle gpe_device,
+			 u32 gpe_number,
+			 u32 type, acpi_gpe_handler address, void *context);
+
+acpi_status
+acpi_remove_gpe_handler(acpi_handle gpe_device,
+			u32 gpe_number, acpi_gpe_handler address);
+
+acpi_status
+acpi_install_notify_handler(acpi_handle device,
+			    u32 handler_type,
+			    acpi_notify_handler handler, void *context);
+
+acpi_status
+acpi_remove_notify_handler(acpi_handle device,
+			   u32 handler_type, acpi_notify_handler handler);
+
+acpi_status
+acpi_install_address_space_handler(acpi_handle device,
+				   acpi_adr_space_type space_id,
+				   acpi_adr_space_handler handler,
+				   acpi_adr_space_setup setup, void *context);
+
+acpi_status
+acpi_remove_address_space_handler(acpi_handle device,
+				  acpi_adr_space_type space_id,
+				  acpi_adr_space_handler handler);
+
+acpi_status acpi_install_exception_handler(acpi_exception_handler handler);
+
+acpi_status acpi_install_interface_handler(acpi_interface_handler handler);
+
+/*
+ * Global Lock interfaces
+ */
+acpi_status acpi_acquire_global_lock(u16 timeout, u32 *handle);
+
+acpi_status acpi_release_global_lock(u32 handle);
+
+/*
+ * Interfaces to AML mutex objects
+ */
+acpi_status
+acpi_acquire_mutex(acpi_handle handle, acpi_string pathname, u16 timeout);
+
+acpi_status acpi_release_mutex(acpi_handle handle, acpi_string pathname);
+
+/*
+ * Fixed Event interfaces
+ */
+acpi_status acpi_enable_event(u32 event, u32 flags);
+
+acpi_status acpi_disable_event(u32 event, u32 flags);
+
+acpi_status acpi_clear_event(u32 event);
+
+acpi_status acpi_get_event_status(u32 event, acpi_event_status *event_status);
+
+/*
+ * General Purpose Event (GPE) Interfaces
+ */
+acpi_status acpi_update_all_gpes(void);
+
+acpi_status acpi_enable_gpe(acpi_handle gpe_device, u32 gpe_number);
+
+acpi_status acpi_disable_gpe(acpi_handle gpe_device, u32 gpe_number);
+
+acpi_status acpi_clear_gpe(acpi_handle gpe_device, u32 gpe_number);
+
+acpi_status acpi_set_gpe(acpi_handle gpe_device, u32 gpe_number, u8 action);
+
+acpi_status acpi_finish_gpe(acpi_handle gpe_device, u32 gpe_number);
+
+acpi_status
+acpi_setup_gpe_for_wake(acpi_handle parent_device,
+			acpi_handle gpe_device, u32 gpe_number);
+
+acpi_status
+acpi_set_gpe_wake_mask(acpi_handle gpe_device, u32 gpe_number, u8 action);
+
+acpi_status
+acpi_get_gpe_status(acpi_handle gpe_device,
+		    u32 gpe_number, acpi_event_status *event_status);
+
+acpi_status acpi_disable_all_gpes(void);
+
+acpi_status acpi_enable_all_runtime_gpes(void);
+
+acpi_status acpi_get_gpe_device(u32 gpe_index, acpi_handle * gpe_device);
+
+acpi_status
+acpi_install_gpe_block(acpi_handle gpe_device,
+		       struct acpi_generic_address *gpe_block_address,
+		       u32 register_count, u32 interrupt_number);
+
+acpi_status acpi_remove_gpe_block(acpi_handle gpe_device);
+
+/*
+ * Resource interfaces
+ */
+typedef
+acpi_status(*acpi_walk_resource_callback) (struct acpi_resource * resource,
+					   void *context);
+
+acpi_status
+acpi_get_vendor_resource(acpi_handle device,
+			 char *name,
+			 struct acpi_vendor_uuid *uuid,
+			 struct acpi_buffer *ret_buffer);
+
+acpi_status
+acpi_get_current_resources(acpi_handle device, struct acpi_buffer *ret_buffer);
+
+acpi_status
+acpi_get_possible_resources(acpi_handle device, struct acpi_buffer *ret_buffer);
+
+acpi_status
+acpi_get_event_resources(acpi_handle device_handle,
+			 struct acpi_buffer *ret_buffer);
+
+acpi_status
+acpi_walk_resources(acpi_handle device,
+		    char *name,
+		    acpi_walk_resource_callback user_function, void *context);
+
+acpi_status
+acpi_set_current_resources(acpi_handle device, struct acpi_buffer *in_buffer);
+
+acpi_status
+acpi_get_irq_routing_table(acpi_handle device, struct acpi_buffer *ret_buffer);
+
+acpi_status
+acpi_resource_to_address64(struct acpi_resource *resource,
+			   struct acpi_resource_address64 *out);
+
+acpi_status
+acpi_buffer_to_resource(u8 *aml_buffer,
+			u16 aml_buffer_length,
+			struct acpi_resource **resource_ptr);
+
+/*
+ * Hardware (ACPI device) interfaces
+ */
+acpi_status acpi_reset(void);
+
+acpi_status acpi_read(u64 *value, struct acpi_generic_address *reg);
+
+acpi_status acpi_write(u64 value, struct acpi_generic_address *reg);
+
+acpi_status acpi_read_bit_register(u32 register_id, u32 *return_value);
+
+acpi_status acpi_write_bit_register(u32 register_id, u32 value);
+
+acpi_status
+acpi_get_sleep_type_data(u8 sleep_state, u8 *slp_typ_a, u8 *slp_typ_b);
+
+acpi_status acpi_enter_sleep_state_prep(u8 sleep_state);
+
+acpi_status acpi_enter_sleep_state(u8 sleep_state);
+
+acpi_status acpi_enter_sleep_state_s4bios(void);
+
+acpi_status acpi_leave_sleep_state(u8 sleep_state);
+acpi_status acpi_set_firmware_waking_vector(u32 physical_address);
+
+#if ACPI_MACHINE_WIDTH == 64
+acpi_status acpi_set_firmware_waking_vector64(u64 physical_address);
+#endif
+
+/*
+ * Error/Warning output
+ */
+void ACPI_INTERNAL_VAR_XFACE
+acpi_error(const char *module_name,
+	   u32 line_number, const char *format, ...) ACPI_PRINTF_LIKE(3);
+
+void ACPI_INTERNAL_VAR_XFACE
+acpi_exception(const char *module_name,
+	       u32 line_number,
+	       acpi_status status, const char *format, ...) ACPI_PRINTF_LIKE(4);
+
+void ACPI_INTERNAL_VAR_XFACE
+acpi_warning(const char *module_name,
+	     u32 line_number, const char *format, ...) ACPI_PRINTF_LIKE(3);
+
+void ACPI_INTERNAL_VAR_XFACE
+acpi_info(const char *module_name,
+	  u32 line_number, const char *format, ...) ACPI_PRINTF_LIKE(3);
+
+/*
+ * Debug output
+ */
+#ifdef ACPI_DEBUG_OUTPUT
+
+void ACPI_INTERNAL_VAR_XFACE
+acpi_debug_print(u32 requested_debug_level,
+		 u32 line_number,
+		 const char *function_name,
+		 const char *module_name,
+		 u32 component_id, const char *format, ...) ACPI_PRINTF_LIKE(6);
+
+void ACPI_INTERNAL_VAR_XFACE
+acpi_debug_print_raw(u32 requested_debug_level,
+		     u32 line_number,
+		     const char *function_name,
+		     const char *module_name,
+		     u32 component_id,
+		     const char *format, ...) ACPI_PRINTF_LIKE(6);
+#endif
+
+#endif				/* __ACXFACE_H__ */
diff --git a/com32/acpioff/acpica_linuxized/include/acpi/acrestyp.h b/com32/acpioff/acpica_linuxized/include/acpi/acrestyp.h
new file mode 100644
index 00000000..25040910
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/include/acpi/acrestyp.h
@@ -0,0 +1,604 @@
+/******************************************************************************
+ *
+ * Name: acrestyp.h - Defines, types, and structures for resource descriptors
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACRESTYP_H__
+#define __ACRESTYP_H__
+
+/*
+ * Definitions for Resource Attributes
+ */
+typedef u16 acpi_rs_length;	/* Resource Length field is fixed at 16 bits */
+typedef u32 acpi_rsdesc_size;	/* Max Resource Descriptor size is (Length+3) = (64_k-1)+3 */
+
+/*
+ * Memory Attributes
+ */
+#define ACPI_READ_ONLY_MEMORY           (u8) 0x00
+#define ACPI_READ_WRITE_MEMORY          (u8) 0x01
+
+#define ACPI_NON_CACHEABLE_MEMORY       (u8) 0x00
+#define ACPI_CACHABLE_MEMORY            (u8) 0x01
+#define ACPI_WRITE_COMBINING_MEMORY     (u8) 0x02
+#define ACPI_PREFETCHABLE_MEMORY        (u8) 0x03
+
+/*! [Begin] no source code translation */
+/*
+ * IO Attributes
+ * The ISA IO ranges are:     n000-n0FFh,  n400-n4FFh, n800-n8FFh, nC00-nCFFh.
+ * The non-ISA IO ranges are: n100-n3FFh,  n500-n7FFh, n900-nBFFh, nCD0-nFFFh.
+ */
+/*! [End] no source code translation !*/
+
+#define ACPI_NON_ISA_ONLY_RANGES        (u8) 0x01
+#define ACPI_ISA_ONLY_RANGES            (u8) 0x02
+#define ACPI_ENTIRE_RANGE               (ACPI_NON_ISA_ONLY_RANGES | ACPI_ISA_ONLY_RANGES)
+
+/* Type of translation - 1=Sparse, 0=Dense */
+
+#define ACPI_SPARSE_TRANSLATION         (u8) 0x01
+
+/*
+ * IO Port Descriptor Decode
+ */
+#define ACPI_DECODE_10                  (u8) 0x00	/* 10-bit IO address decode */
+#define ACPI_DECODE_16                  (u8) 0x01	/* 16-bit IO address decode */
+
+/*
+ * Interrupt attributes - used in multiple descriptors
+ */
+
+/* Triggering */
+
+#define ACPI_LEVEL_SENSITIVE            (u8) 0x00
+#define ACPI_EDGE_SENSITIVE             (u8) 0x01
+
+/* Polarity */
+
+#define ACPI_ACTIVE_HIGH                (u8) 0x00
+#define ACPI_ACTIVE_LOW                 (u8) 0x01
+#define ACPI_ACTIVE_BOTH                (u8) 0x02
+
+/* Sharing */
+
+#define ACPI_EXCLUSIVE                  (u8) 0x00
+#define ACPI_SHARED                     (u8) 0x01
+#define ACPI_EXCLUSIVE_AND_WAKE         (u8) 0x02
+#define ACPI_SHARED_AND_WAKE            (u8) 0x03
+
+/*
+ * DMA Attributes
+ */
+#define ACPI_COMPATIBILITY              (u8) 0x00
+#define ACPI_TYPE_A                     (u8) 0x01
+#define ACPI_TYPE_B                     (u8) 0x02
+#define ACPI_TYPE_F                     (u8) 0x03
+
+#define ACPI_NOT_BUS_MASTER             (u8) 0x00
+#define ACPI_BUS_MASTER                 (u8) 0x01
+
+#define ACPI_TRANSFER_8                 (u8) 0x00
+#define ACPI_TRANSFER_8_16              (u8) 0x01
+#define ACPI_TRANSFER_16                (u8) 0x02
+
+/*
+ * Start Dependent Functions Priority definitions
+ */
+#define ACPI_GOOD_CONFIGURATION         (u8) 0x00
+#define ACPI_ACCEPTABLE_CONFIGURATION   (u8) 0x01
+#define ACPI_SUB_OPTIMAL_CONFIGURATION  (u8) 0x02
+
+/*
+ * 16, 32 and 64-bit Address Descriptor resource types
+ */
+#define ACPI_MEMORY_RANGE               (u8) 0x00
+#define ACPI_IO_RANGE                   (u8) 0x01
+#define ACPI_BUS_NUMBER_RANGE           (u8) 0x02
+
+#define ACPI_ADDRESS_NOT_FIXED          (u8) 0x00
+#define ACPI_ADDRESS_FIXED              (u8) 0x01
+
+#define ACPI_POS_DECODE                 (u8) 0x00
+#define ACPI_SUB_DECODE                 (u8) 0x01
+
+/* Producer/Consumer */
+
+#define ACPI_PRODUCER                   (u8) 0x00
+#define ACPI_CONSUMER                   (u8) 0x01
+
+/*
+ * If possible, pack the following structures to byte alignment
+ */
+#ifndef ACPI_MISALIGNMENT_NOT_SUPPORTED
+#pragma pack(1)
+#endif
+
+/* UUID data structures for use in vendor-defined resource descriptors */
+
+struct acpi_uuid {
+	u8 data[ACPI_UUID_LENGTH];
+};
+
+struct acpi_vendor_uuid {
+	u8 subtype;
+	u8 data[ACPI_UUID_LENGTH];
+};
+
+/*
+ * Structures used to describe device resources
+ */
+struct acpi_resource_irq {
+	u8 descriptor_length;
+	u8 triggering;
+	u8 polarity;
+	u8 sharable;
+	u8 interrupt_count;
+	u8 interrupts[1];
+};
+
+struct acpi_resource_dma {
+	u8 type;
+	u8 bus_master;
+	u8 transfer;
+	u8 channel_count;
+	u8 channels[1];
+};
+
+struct acpi_resource_start_dependent {
+	u8 descriptor_length;
+	u8 compatibility_priority;
+	u8 performance_robustness;
+};
+
+/*
+ * The END_DEPENDENT_FUNCTIONS_RESOURCE struct is not
+ * needed because it has no fields
+ */
+
+struct acpi_resource_io {
+	u8 io_decode;
+	u8 alignment;
+	u8 address_length;
+	u16 minimum;
+	u16 maximum;
+};
+
+struct acpi_resource_fixed_io {
+	u16 address;
+	u8 address_length;
+};
+
+struct acpi_resource_fixed_dma {
+	u16 request_lines;
+	u16 channels;
+	u8 width;
+};
+
+/* Values for Width field above */
+
+#define ACPI_DMA_WIDTH8                         0
+#define ACPI_DMA_WIDTH16                        1
+#define ACPI_DMA_WIDTH32                        2
+#define ACPI_DMA_WIDTH64                        3
+#define ACPI_DMA_WIDTH128                       4
+#define ACPI_DMA_WIDTH256                       5
+
+struct acpi_resource_vendor {
+	u16 byte_length;
+	u8 byte_data[1];
+};
+
+/* Vendor resource with UUID info (introduced in ACPI 3.0) */
+
+struct acpi_resource_vendor_typed {
+	u16 byte_length;
+	u8 uuid_subtype;
+	u8 uuid[ACPI_UUID_LENGTH];
+	u8 byte_data[1];
+};
+
+struct acpi_resource_end_tag {
+	u8 checksum;
+};
+
+struct acpi_resource_memory24 {
+	u8 write_protect;
+	u16 minimum;
+	u16 maximum;
+	u16 alignment;
+	u16 address_length;
+};
+
+struct acpi_resource_memory32 {
+	u8 write_protect;
+	u32 minimum;
+	u32 maximum;
+	u32 alignment;
+	u32 address_length;
+};
+
+struct acpi_resource_fixed_memory32 {
+	u8 write_protect;
+	u32 address;
+	u32 address_length;
+};
+
+struct acpi_memory_attribute {
+	u8 write_protect;
+	u8 caching;
+	u8 range_type;
+	u8 translation;
+};
+
+struct acpi_io_attribute {
+	u8 range_type;
+	u8 translation;
+	u8 translation_type;
+	u8 reserved1;
+};
+
+union acpi_resource_attribute {
+	struct acpi_memory_attribute mem;
+	struct acpi_io_attribute io;
+
+	/* Used for the *word_space macros */
+
+	u8 type_specific;
+};
+
+struct acpi_resource_source {
+	u8 index;
+	u16 string_length;
+	char *string_ptr;
+};
+
+/* Fields common to all address descriptors, 16/32/64 bit */
+
+#define ACPI_RESOURCE_ADDRESS_COMMON \
+	u8                                      resource_type; \
+	u8                                      producer_consumer; \
+	u8                                      decode; \
+	u8                                      min_address_fixed; \
+	u8                                      max_address_fixed; \
+	union acpi_resource_attribute           info;
+
+struct acpi_resource_address {
+ACPI_RESOURCE_ADDRESS_COMMON};
+
+struct acpi_resource_address16 {
+	ACPI_RESOURCE_ADDRESS_COMMON u16 granularity;
+	u16 minimum;
+	u16 maximum;
+	u16 translation_offset;
+	u16 address_length;
+	struct acpi_resource_source resource_source;
+};
+
+struct acpi_resource_address32 {
+	ACPI_RESOURCE_ADDRESS_COMMON u32 granularity;
+	u32 minimum;
+	u32 maximum;
+	u32 translation_offset;
+	u32 address_length;
+	struct acpi_resource_source resource_source;
+};
+
+struct acpi_resource_address64 {
+	ACPI_RESOURCE_ADDRESS_COMMON u64 granularity;
+	u64 minimum;
+	u64 maximum;
+	u64 translation_offset;
+	u64 address_length;
+	struct acpi_resource_source resource_source;
+};
+
+struct acpi_resource_extended_address64 {
+	ACPI_RESOURCE_ADDRESS_COMMON u8 revision_iD;
+	u64 granularity;
+	u64 minimum;
+	u64 maximum;
+	u64 translation_offset;
+	u64 address_length;
+	u64 type_specific;
+};
+
+struct acpi_resource_extended_irq {
+	u8 producer_consumer;
+	u8 triggering;
+	u8 polarity;
+	u8 sharable;
+	u8 interrupt_count;
+	struct acpi_resource_source resource_source;
+	u32 interrupts[1];
+};
+
+struct acpi_resource_generic_register {
+	u8 space_id;
+	u8 bit_width;
+	u8 bit_offset;
+	u8 access_size;
+	u64 address;
+};
+
+struct acpi_resource_gpio {
+	u8 revision_id;
+	u8 connection_type;
+	u8 producer_consumer;	/* For values, see Producer/Consumer above */
+	u8 pin_config;
+	u8 sharable;		/* For values, see Interrupt Attributes above */
+	u8 io_restriction;
+	u8 triggering;		/* For values, see Interrupt Attributes above */
+	u8 polarity;		/* For values, see Interrupt Attributes above */
+	u16 drive_strength;
+	u16 debounce_timeout;
+	u16 pin_table_length;
+	u16 vendor_length;
+	struct acpi_resource_source resource_source;
+	u16 *pin_table;
+	u8 *vendor_data;
+};
+
+/* Values for GPIO connection_type field above */
+
+#define ACPI_RESOURCE_GPIO_TYPE_INT             0
+#define ACPI_RESOURCE_GPIO_TYPE_IO              1
+
+/* Values for pin_config field above */
+
+#define ACPI_PIN_CONFIG_DEFAULT                 0
+#define ACPI_PIN_CONFIG_PULLUP                  1
+#define ACPI_PIN_CONFIG_PULLDOWN                2
+#define ACPI_PIN_CONFIG_NOPULL                  3
+
+/* Values for io_restriction field above */
+
+#define ACPI_IO_RESTRICT_NONE                   0
+#define ACPI_IO_RESTRICT_INPUT                  1
+#define ACPI_IO_RESTRICT_OUTPUT                 2
+#define ACPI_IO_RESTRICT_NONE_PRESERVE          3
+
+/* Common structure for I2C, SPI, and UART serial descriptors */
+
+#define ACPI_RESOURCE_SERIAL_COMMON \
+	u8                                      revision_id; \
+	u8                                      type; \
+	u8                                      producer_consumer;   /* For values, see Producer/Consumer above */\
+	u8                                      slave_mode; \
+	u8                                      type_revision_id; \
+	u16                                     type_data_length; \
+	u16                                     vendor_length; \
+	struct acpi_resource_source             resource_source; \
+	u8                                      *vendor_data;
+
+struct acpi_resource_common_serialbus {
+ACPI_RESOURCE_SERIAL_COMMON};
+
+/* Values for the Type field above */
+
+#define ACPI_RESOURCE_SERIAL_TYPE_I2C           1
+#define ACPI_RESOURCE_SERIAL_TYPE_SPI           2
+#define ACPI_RESOURCE_SERIAL_TYPE_UART          3
+
+/* Values for slave_mode field above */
+
+#define ACPI_CONTROLLER_INITIATED               0
+#define ACPI_DEVICE_INITIATED                   1
+
+struct acpi_resource_i2c_serialbus {
+	ACPI_RESOURCE_SERIAL_COMMON u8 access_mode;
+	u16 slave_address;
+	u32 connection_speed;
+};
+
+/* Values for access_mode field above */
+
+#define ACPI_I2C_7BIT_MODE                      0
+#define ACPI_I2C_10BIT_MODE                     1
+
+struct acpi_resource_spi_serialbus {
+	ACPI_RESOURCE_SERIAL_COMMON u8 wire_mode;
+	u8 device_polarity;
+	u8 data_bit_length;
+	u8 clock_phase;
+	u8 clock_polarity;
+	u16 device_selection;
+	u32 connection_speed;
+};
+
+/* Values for wire_mode field above */
+
+#define ACPI_SPI_4WIRE_MODE                     0
+#define ACPI_SPI_3WIRE_MODE                     1
+
+/* Values for device_polarity field above */
+
+#define ACPI_SPI_ACTIVE_LOW                     0
+#define ACPI_SPI_ACTIVE_HIGH                    1
+
+/* Values for clock_phase field above */
+
+#define ACPI_SPI_FIRST_PHASE                    0
+#define ACPI_SPI_SECOND_PHASE                   1
+
+/* Values for clock_polarity field above */
+
+#define ACPI_SPI_START_LOW                      0
+#define ACPI_SPI_START_HIGH                     1
+
+struct acpi_resource_uart_serialbus {
+	ACPI_RESOURCE_SERIAL_COMMON u8 endian;
+	u8 data_bits;
+	u8 stop_bits;
+	u8 flow_control;
+	u8 parity;
+	u8 lines_enabled;
+	u16 rx_fifo_size;
+	u16 tx_fifo_size;
+	u32 default_baud_rate;
+};
+
+/* Values for Endian field above */
+
+#define ACPI_UART_LITTLE_ENDIAN                 0
+#define ACPI_UART_BIG_ENDIAN                    1
+
+/* Values for data_bits field above */
+
+#define ACPI_UART_5_DATA_BITS                   0
+#define ACPI_UART_6_DATA_BITS                   1
+#define ACPI_UART_7_DATA_BITS                   2
+#define ACPI_UART_8_DATA_BITS                   3
+#define ACPI_UART_9_DATA_BITS                   4
+
+/* Values for stop_bits field above */
+
+#define ACPI_UART_NO_STOP_BITS                  0
+#define ACPI_UART_1_STOP_BIT                    1
+#define ACPI_UART_1P5_STOP_BITS                 2
+#define ACPI_UART_2_STOP_BITS                   3
+
+/* Values for flow_control field above */
+
+#define ACPI_UART_FLOW_CONTROL_NONE             0
+#define ACPI_UART_FLOW_CONTROL_HW               1
+#define ACPI_UART_FLOW_CONTROL_XON_XOFF         2
+
+/* Values for Parity field above */
+
+#define ACPI_UART_PARITY_NONE                   0
+#define ACPI_UART_PARITY_EVEN                   1
+#define ACPI_UART_PARITY_ODD                    2
+#define ACPI_UART_PARITY_MARK                   3
+#define ACPI_UART_PARITY_SPACE                  4
+
+/* Values for lines_enabled bitfield above */
+
+#define ACPI_UART_CARRIER_DETECT                (1<<2)
+#define ACPI_UART_RING_INDICATOR                (1<<3)
+#define ACPI_UART_DATA_SET_READY                (1<<4)
+#define ACPI_UART_DATA_TERMINAL_READY           (1<<5)
+#define ACPI_UART_CLEAR_TO_SEND                 (1<<6)
+#define ACPI_UART_REQUEST_TO_SEND               (1<<7)
+
+/* ACPI_RESOURCE_TYPEs */
+
+#define ACPI_RESOURCE_TYPE_IRQ                  0
+#define ACPI_RESOURCE_TYPE_DMA                  1
+#define ACPI_RESOURCE_TYPE_START_DEPENDENT      2
+#define ACPI_RESOURCE_TYPE_END_DEPENDENT        3
+#define ACPI_RESOURCE_TYPE_IO                   4
+#define ACPI_RESOURCE_TYPE_FIXED_IO             5
+#define ACPI_RESOURCE_TYPE_VENDOR               6
+#define ACPI_RESOURCE_TYPE_END_TAG              7
+#define ACPI_RESOURCE_TYPE_MEMORY24             8
+#define ACPI_RESOURCE_TYPE_MEMORY32             9
+#define ACPI_RESOURCE_TYPE_FIXED_MEMORY32       10
+#define ACPI_RESOURCE_TYPE_ADDRESS16            11
+#define ACPI_RESOURCE_TYPE_ADDRESS32            12
+#define ACPI_RESOURCE_TYPE_ADDRESS64            13
+#define ACPI_RESOURCE_TYPE_EXTENDED_ADDRESS64   14	/* ACPI 3.0 */
+#define ACPI_RESOURCE_TYPE_EXTENDED_IRQ         15
+#define ACPI_RESOURCE_TYPE_GENERIC_REGISTER     16
+#define ACPI_RESOURCE_TYPE_GPIO                 17	/* ACPI 5.0 */
+#define ACPI_RESOURCE_TYPE_FIXED_DMA            18	/* ACPI 5.0 */
+#define ACPI_RESOURCE_TYPE_SERIAL_BUS           19	/* ACPI 5.0 */
+#define ACPI_RESOURCE_TYPE_MAX                  19
+
+/* Master union for resource descriptors */
+
+union acpi_resource_data {
+	struct acpi_resource_irq irq;
+	struct acpi_resource_dma dma;
+	struct acpi_resource_start_dependent start_dpf;
+	struct acpi_resource_io io;
+	struct acpi_resource_fixed_io fixed_io;
+	struct acpi_resource_fixed_dma fixed_dma;
+	struct acpi_resource_vendor vendor;
+	struct acpi_resource_vendor_typed vendor_typed;
+	struct acpi_resource_end_tag end_tag;
+	struct acpi_resource_memory24 memory24;
+	struct acpi_resource_memory32 memory32;
+	struct acpi_resource_fixed_memory32 fixed_memory32;
+	struct acpi_resource_address16 address16;
+	struct acpi_resource_address32 address32;
+	struct acpi_resource_address64 address64;
+	struct acpi_resource_extended_address64 ext_address64;
+	struct acpi_resource_extended_irq extended_irq;
+	struct acpi_resource_generic_register generic_reg;
+	struct acpi_resource_gpio gpio;
+	struct acpi_resource_i2c_serialbus i2c_serial_bus;
+	struct acpi_resource_spi_serialbus spi_serial_bus;
+	struct acpi_resource_uart_serialbus uart_serial_bus;
+	struct acpi_resource_common_serialbus common_serial_bus;
+
+	/* Common fields */
+
+	struct acpi_resource_address address;	/* Common 16/32/64 address fields */
+};
+
+/* Common resource header */
+
+struct acpi_resource {
+	u32 type;
+	u32 length;
+	union acpi_resource_data data;
+};
+
+/* restore default alignment */
+
+#pragma pack()
+
+#define ACPI_RS_SIZE_NO_DATA                8	/* Id + Length fields */
+#define ACPI_RS_SIZE_MIN                    (u32) ACPI_ROUND_UP_TO_NATIVE_WORD (12)
+#define ACPI_RS_SIZE(type)                  (u32) (ACPI_RS_SIZE_NO_DATA + sizeof (type))
+
+#define ACPI_NEXT_RESOURCE(res)             (struct acpi_resource *)((u8 *) res + res->length)
+
+struct acpi_pci_routing_table {
+	u32 length;
+	u32 pin;
+	u64 address;		/* here for 64-bit alignment */
+	u32 source_index;
+	char source[4];		/* pad to 64 bits so sizeof() works in all cases */
+};
+
+#endif				/* __ACRESTYP_H__ */
diff --git a/com32/acpioff/acpica_linuxized/include/acpi/actbl.h b/com32/acpioff/acpica_linuxized/include/acpi/actbl.h
new file mode 100644
index 00000000..496723aa
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/include/acpi/actbl.h
@@ -0,0 +1,389 @@
+/******************************************************************************
+ *
+ * Name: actbl.h - Basic ACPI Table Definitions
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACTBL_H__
+#define __ACTBL_H__
+
+/*******************************************************************************
+ *
+ * Fundamental ACPI tables
+ *
+ * This file contains definitions for the ACPI tables that are directly consumed
+ * by ACPICA. All other tables are consumed by the OS-dependent ACPI-related
+ * device drivers and other OS support code.
+ *
+ * The RSDP and FACS do not use the common ACPI table header. All other ACPI
+ * tables use the header.
+ *
+ ******************************************************************************/
+
+/*
+ * Values for description table header signatures for tables defined in this
+ * file. Useful because they make it more difficult to inadvertently type in
+ * the wrong signature.
+ */
+#define ACPI_SIG_DSDT           "DSDT"	/* Differentiated System Description Table */
+#define ACPI_SIG_FADT           "FACP"	/* Fixed ACPI Description Table */
+#define ACPI_SIG_FACS           "FACS"	/* Firmware ACPI Control Structure */
+#define ACPI_SIG_PSDT           "PSDT"	/* Persistent System Description Table */
+#define ACPI_SIG_RSDP           "RSD PTR "	/* Root System Description Pointer */
+#define ACPI_SIG_RSDT           "RSDT"	/* Root System Description Table */
+#define ACPI_SIG_XSDT           "XSDT"	/* Extended  System Description Table */
+#define ACPI_SIG_SSDT           "SSDT"	/* Secondary System Description Table */
+#define ACPI_RSDP_NAME          "RSDP"	/* Short name for RSDP, not signature */
+
+/*
+ * All tables and structures must be byte-packed to match the ACPI
+ * specification, since the tables are provided by the system BIOS
+ */
+#pragma pack(1)
+
+/*
+ * Note about bitfields: The u8 type is used for bitfields in ACPI tables.
+ * This is the only type that is even remotely portable. Anything else is not
+ * portable, so do not use any other bitfield types.
+ */
+
+/*******************************************************************************
+ *
+ * Master ACPI Table Header. This common header is used by all ACPI tables
+ * except the RSDP and FACS.
+ *
+ ******************************************************************************/
+
+struct acpi_table_header {
+	char signature[ACPI_NAME_SIZE];	/* ASCII table signature */
+	u32 length;		/* Length of table in bytes, including this header */
+	u8 revision;		/* ACPI Specification minor version # */
+	u8 checksum;		/* To make sum of entire table == 0 */
+	char oem_id[ACPI_OEM_ID_SIZE];	/* ASCII OEM identification */
+	char oem_table_id[ACPI_OEM_TABLE_ID_SIZE];	/* ASCII OEM table identification */
+	u32 oem_revision;	/* OEM revision number */
+	char asl_compiler_id[ACPI_NAME_SIZE];	/* ASCII ASL compiler vendor ID */
+	u32 asl_compiler_revision;	/* ASL compiler version */
+};
+
+/*******************************************************************************
+ *
+ * GAS - Generic Address Structure (ACPI 2.0+)
+ *
+ * Note: Since this structure is used in the ACPI tables, it is byte aligned.
+ * If misaliged access is not supported by the hardware, accesses to the
+ * 64-bit Address field must be performed with care.
+ *
+ ******************************************************************************/
+
+struct acpi_generic_address {
+	u8 space_id;		/* Address space where struct or register exists */
+	u8 bit_width;		/* Size in bits of given register */
+	u8 bit_offset;		/* Bit offset within the register */
+	u8 access_width;	/* Minimum Access size (ACPI 3.0) */
+	u64 address;		/* 64-bit address of struct or register */
+};
+
+/*******************************************************************************
+ *
+ * RSDP - Root System Description Pointer (Signature is "RSD PTR ")
+ *        Version 2
+ *
+ ******************************************************************************/
+
+struct acpi_table_rsdp {
+	char signature[8];	/* ACPI signature, contains "RSD PTR " */
+	u8 checksum;		/* ACPI 1.0 checksum */
+	char oem_id[ACPI_OEM_ID_SIZE];	/* OEM identification */
+	u8 revision;		/* Must be (0) for ACPI 1.0 or (2) for ACPI 2.0+ */
+	u32 rsdt_physical_address;	/* 32-bit physical address of the RSDT */
+	u32 length;		/* Table length in bytes, including header (ACPI 2.0+) */
+	u64 xsdt_physical_address;	/* 64-bit physical address of the XSDT (ACPI 2.0+) */
+	u8 extended_checksum;	/* Checksum of entire table (ACPI 2.0+) */
+	u8 reserved[3];		/* Reserved, must be zero */
+};
+
+/* Standalone struct for the ACPI 1.0 RSDP */
+
+struct acpi_rsdp_common {
+	char signature[8];
+	u8 checksum;
+	char oem_id[ACPI_OEM_ID_SIZE];
+	u8 revision;
+	u32 rsdt_physical_address;
+};
+
+/* Standalone struct for the extended part of the RSDP (ACPI 2.0+) */
+
+struct acpi_rsdp_extension {
+	u32 length;
+	u64 xsdt_physical_address;
+	u8 extended_checksum;
+	u8 reserved[3];
+};
+
+/*******************************************************************************
+ *
+ * RSDT/XSDT - Root System Description Tables
+ *             Version 1 (both)
+ *
+ ******************************************************************************/
+
+struct acpi_table_rsdt {
+	struct acpi_table_header header;	/* Common ACPI table header */
+	u32 table_offset_entry[1];	/* Array of pointers to ACPI tables */
+};
+
+struct acpi_table_xsdt {
+	struct acpi_table_header header;	/* Common ACPI table header */
+	u64 table_offset_entry[1];	/* Array of pointers to ACPI tables */
+};
+
+/*******************************************************************************
+ *
+ * FACS - Firmware ACPI Control Structure (FACS)
+ *
+ ******************************************************************************/
+
+struct acpi_table_facs {
+	char signature[4];	/* ASCII table signature */
+	u32 length;		/* Length of structure, in bytes */
+	u32 hardware_signature;	/* Hardware configuration signature */
+	u32 firmware_waking_vector;	/* 32-bit physical address of the Firmware Waking Vector */
+	u32 global_lock;	/* Global Lock for shared hardware resources */
+	u32 flags;
+	u64 xfirmware_waking_vector;	/* 64-bit version of the Firmware Waking Vector (ACPI 2.0+) */
+	u8 version;		/* Version of this table (ACPI 2.0+) */
+	u8 reserved[3];		/* Reserved, must be zero */
+	u32 ospm_flags;		/* Flags to be set by OSPM (ACPI 4.0) */
+	u8 reserved1[24];	/* Reserved, must be zero */
+};
+
+/* Masks for global_lock flag field above */
+
+#define ACPI_GLOCK_PENDING          (1)	/* 00: Pending global lock ownership */
+#define ACPI_GLOCK_OWNED            (1<<1)	/* 01: Global lock is owned */
+
+/* Masks for Flags field above  */
+
+#define ACPI_FACS_S4_BIOS_PRESENT   (1)	/* 00: S4BIOS support is present */
+#define ACPI_FACS_64BIT_WAKE        (1<<1)	/* 01: 64-bit wake vector supported (ACPI 4.0) */
+
+/* Masks for ospm_flags field above */
+
+#define ACPI_FACS_64BIT_ENVIRONMENT (1)	/* 00: 64-bit wake environment is required (ACPI 4.0) */
+
+/*******************************************************************************
+ *
+ * FADT - Fixed ACPI Description Table (Signature "FACP")
+ *        Version 4
+ *
+ ******************************************************************************/
+
+/* Fields common to all versions of the FADT */
+
+struct acpi_table_fadt {
+	struct acpi_table_header header;	/* Common ACPI table header */
+	u32 facs;		/* 32-bit physical address of FACS */
+	u32 dsdt;		/* 32-bit physical address of DSDT */
+	u8 model;		/* System Interrupt Model (ACPI 1.0) - not used in ACPI 2.0+ */
+	u8 preferred_profile;	/* Conveys preferred power management profile to OSPM. */
+	u16 sci_interrupt;	/* System vector of SCI interrupt */
+	u32 smi_command;	/* 32-bit Port address of SMI command port */
+	u8 acpi_enable;		/* Value to write to smi_cmd to enable ACPI */
+	u8 acpi_disable;	/* Value to write to smi_cmd to disable ACPI */
+	u8 S4bios_request;	/* Value to write to SMI CMD to enter S4BIOS state */
+	u8 pstate_control;	/* Processor performance state control */
+	u32 pm1a_event_block;	/* 32-bit Port address of Power Mgt 1a Event Reg Blk */
+	u32 pm1b_event_block;	/* 32-bit Port address of Power Mgt 1b Event Reg Blk */
+	u32 pm1a_control_block;	/* 32-bit Port address of Power Mgt 1a Control Reg Blk */
+	u32 pm1b_control_block;	/* 32-bit Port address of Power Mgt 1b Control Reg Blk */
+	u32 pm2_control_block;	/* 32-bit Port address of Power Mgt 2 Control Reg Blk */
+	u32 pm_timer_block;	/* 32-bit Port address of Power Mgt Timer Ctrl Reg Blk */
+	u32 gpe0_block;		/* 32-bit Port address of General Purpose Event 0 Reg Blk */
+	u32 gpe1_block;		/* 32-bit Port address of General Purpose Event 1 Reg Blk */
+	u8 pm1_event_length;	/* Byte Length of ports at pm1x_event_block */
+	u8 pm1_control_length;	/* Byte Length of ports at pm1x_control_block */
+	u8 pm2_control_length;	/* Byte Length of ports at pm2_control_block */
+	u8 pm_timer_length;	/* Byte Length of ports at pm_timer_block */
+	u8 gpe0_block_length;	/* Byte Length of ports at gpe0_block */
+	u8 gpe1_block_length;	/* Byte Length of ports at gpe1_block */
+	u8 gpe1_base;		/* Offset in GPE number space where GPE1 events start */
+	u8 cst_control;		/* Support for the _CST object and C States change notification */
+	u16 C2latency;		/* Worst case HW latency to enter/exit C2 state */
+	u16 C3latency;		/* Worst case HW latency to enter/exit C3 state */
+	u16 flush_size;		/* Processor's memory cache line width, in bytes */
+	u16 flush_stride;	/* Number of flush strides that need to be read */
+	u8 duty_offset;		/* Processor duty cycle index in processor's P_CNT reg */
+	u8 duty_width;		/* Processor duty cycle value bit width in P_CNT register */
+	u8 day_alarm;		/* Index to day-of-month alarm in RTC CMOS RAM */
+	u8 month_alarm;		/* Index to month-of-year alarm in RTC CMOS RAM */
+	u8 century;		/* Index to century in RTC CMOS RAM */
+	u16 boot_flags;		/* IA-PC Boot Architecture Flags (see below for individual flags) */
+	u8 reserved;		/* Reserved, must be zero */
+	u32 flags;		/* Miscellaneous flag bits (see below for individual flags) */
+	struct acpi_generic_address reset_register;	/* 64-bit address of the Reset register */
+	u8 reset_value;		/* Value to write to the reset_register port to reset the system */
+	u8 reserved4[3];	/* Reserved, must be zero */
+	u64 Xfacs;		/* 64-bit physical address of FACS */
+	u64 Xdsdt;		/* 64-bit physical address of DSDT */
+	struct acpi_generic_address xpm1a_event_block;	/* 64-bit Extended Power Mgt 1a Event Reg Blk address */
+	struct acpi_generic_address xpm1b_event_block;	/* 64-bit Extended Power Mgt 1b Event Reg Blk address */
+	struct acpi_generic_address xpm1a_control_block;	/* 64-bit Extended Power Mgt 1a Control Reg Blk address */
+	struct acpi_generic_address xpm1b_control_block;	/* 64-bit Extended Power Mgt 1b Control Reg Blk address */
+	struct acpi_generic_address xpm2_control_block;	/* 64-bit Extended Power Mgt 2 Control Reg Blk address */
+	struct acpi_generic_address xpm_timer_block;	/* 64-bit Extended Power Mgt Timer Ctrl Reg Blk address */
+	struct acpi_generic_address xgpe0_block;	/* 64-bit Extended General Purpose Event 0 Reg Blk address */
+	struct acpi_generic_address xgpe1_block;	/* 64-bit Extended General Purpose Event 1 Reg Blk address */
+	struct acpi_generic_address sleep_control;	/* 64-bit Sleep Control register */
+	struct acpi_generic_address sleep_status;	/* 64-bit Sleep Status register */
+};
+
+/* Masks for FADT Boot Architecture Flags (boot_flags) */
+
+#define ACPI_FADT_LEGACY_DEVICES    (1)	/* 00: [V2] System has LPC or ISA bus devices */
+#define ACPI_FADT_8042              (1<<1)	/* 01: [V3] System has an 8042 controller on port 60/64 */
+#define ACPI_FADT_NO_VGA            (1<<2)	/* 02: [V4] It is not safe to probe for VGA hardware */
+#define ACPI_FADT_NO_MSI            (1<<3)	/* 03: [V4] Message Signaled Interrupts (MSI) must not be enabled */
+#define ACPI_FADT_NO_ASPM           (1<<4)	/* 04: [V4] PCIe ASPM control must not be enabled */
+#define ACPI_FADT_NO_CMOS_RTC       (1<<5)	/* 05: [V5] No CMOS real-time clock present */
+
+/* Masks for FADT flags */
+
+#define ACPI_FADT_WBINVD            (1)	/* 00: [V1] The wbinvd instruction works properly */
+#define ACPI_FADT_WBINVD_FLUSH      (1<<1)	/* 01: [V1] wbinvd flushes but does not invalidate caches */
+#define ACPI_FADT_C1_SUPPORTED      (1<<2)	/* 02: [V1] All processors support C1 state */
+#define ACPI_FADT_C2_MP_SUPPORTED   (1<<3)	/* 03: [V1] C2 state works on MP system */
+#define ACPI_FADT_POWER_BUTTON      (1<<4)	/* 04: [V1] Power button is handled as a control method device */
+#define ACPI_FADT_SLEEP_BUTTON      (1<<5)	/* 05: [V1] Sleep button is handled as a control method device */
+#define ACPI_FADT_FIXED_RTC         (1<<6)	/* 06: [V1] RTC wakeup status not in fixed register space */
+#define ACPI_FADT_S4_RTC_WAKE       (1<<7)	/* 07: [V1] RTC alarm can wake system from S4 */
+#define ACPI_FADT_32BIT_TIMER       (1<<8)	/* 08: [V1] ACPI timer width is 32-bit (0=24-bit) */
+#define ACPI_FADT_DOCKING_SUPPORTED (1<<9)	/* 09: [V1] Docking supported */
+#define ACPI_FADT_RESET_REGISTER    (1<<10)	/* 10: [V2] System reset via the FADT RESET_REG supported */
+#define ACPI_FADT_SEALED_CASE       (1<<11)	/* 11: [V3] No internal expansion capabilities and case is sealed */
+#define ACPI_FADT_HEADLESS          (1<<12)	/* 12: [V3] No local video capabilities or local input devices */
+#define ACPI_FADT_SLEEP_TYPE        (1<<13)	/* 13: [V3] Must execute native instruction after writing  SLP_TYPx register */
+#define ACPI_FADT_PCI_EXPRESS_WAKE  (1<<14)	/* 14: [V4] System supports PCIEXP_WAKE (STS/EN) bits (ACPI 3.0) */
+#define ACPI_FADT_PLATFORM_CLOCK    (1<<15)	/* 15: [V4] OSPM should use platform-provided timer (ACPI 3.0) */
+#define ACPI_FADT_S4_RTC_VALID      (1<<16)	/* 16: [V4] Contents of RTC_STS valid after S4 wake (ACPI 3.0) */
+#define ACPI_FADT_REMOTE_POWER_ON   (1<<17)	/* 17: [V4] System is compatible with remote power on (ACPI 3.0) */
+#define ACPI_FADT_APIC_CLUSTER      (1<<18)	/* 18: [V4] All local APICs must use cluster model (ACPI 3.0) */
+#define ACPI_FADT_APIC_PHYSICAL     (1<<19)	/* 19: [V4] All local x_aPICs must use physical dest mode (ACPI 3.0) */
+#define ACPI_FADT_HW_REDUCED        (1<<20)	/* 20: [V5] ACPI hardware is not implemented (ACPI 5.0) */
+#define ACPI_FADT_LOW_POWER_S0      (1<<21)	/* 21: [V5] S0 power savings are equal or better than S3 (ACPI 5.0) */
+
+/* Values for preferred_profile (Prefered Power Management Profiles) */
+
+enum acpi_prefered_pm_profiles {
+	PM_UNSPECIFIED = 0,
+	PM_DESKTOP = 1,
+	PM_MOBILE = 2,
+	PM_WORKSTATION = 3,
+	PM_ENTERPRISE_SERVER = 4,
+	PM_SOHO_SERVER = 5,
+	PM_APPLIANCE_PC = 6,
+	PM_PERFORMANCE_SERVER = 7,
+	PM_TABLET = 8
+};
+
+/* Reset to default packing */
+
+#pragma pack()
+
+/*
+ * Internal table-related structures
+ */
+union acpi_name_union {
+	u32 integer;
+	char ascii[4];
+};
+
+/* Internal ACPI Table Descriptor. One per ACPI table. */
+
+struct acpi_table_desc {
+	acpi_physical_address address;
+	struct acpi_table_header *pointer;
+	u32 length;		/* Length fixed at 32 bits */
+	union acpi_name_union signature;
+	acpi_owner_id owner_id;
+	u8 flags;
+};
+
+/* Masks for Flags field above */
+
+#define ACPI_TABLE_ORIGIN_UNKNOWN       (0)
+#define ACPI_TABLE_ORIGIN_MAPPED        (1)
+#define ACPI_TABLE_ORIGIN_ALLOCATED     (2)
+#define ACPI_TABLE_ORIGIN_OVERRIDE      (4)
+#define ACPI_TABLE_ORIGIN_MASK          (7)
+#define ACPI_TABLE_IS_LOADED            (8)
+
+/*
+ * Get the remaining ACPI tables
+ */
+#include "actbl1.h"
+#include "actbl2.h"
+#include "actbl3.h"
+
+/* Macros used to generate offsets to specific table fields */
+
+#define ACPI_FADT_OFFSET(f)             (u16) ACPI_OFFSET (struct acpi_table_fadt, f)
+
+/*
+ * Sizes of the various flavors of FADT. We need to look closely
+ * at the FADT length because the version number essentially tells
+ * us nothing because of many BIOS bugs where the version does not
+ * match the expected length. In other words, the length of the
+ * FADT is the bottom line as to what the version really is.
+ *
+ * For reference, the values below are as follows:
+ *     FADT V1  size: 0x074
+ *     FADT V2  size: 0x084
+ *     FADT V3  size: 0x0F4
+ *     FADT V4  size: 0x0F4
+ *     FADT V5  size: 0x10C
+ */
+#define ACPI_FADT_V1_SIZE       (u32) (ACPI_FADT_OFFSET (flags) + 4)
+#define ACPI_FADT_V2_SIZE       (u32) (ACPI_FADT_OFFSET (reserved4[0]) + 3)
+#define ACPI_FADT_V3_SIZE       (u32) (ACPI_FADT_OFFSET (sleep_control))
+#define ACPI_FADT_V5_SIZE       (u32) (sizeof (struct acpi_table_fadt))
+
+#endif				/* __ACTBL_H__ */
diff --git a/com32/acpioff/acpica_linuxized/include/acpi/actbl1.h b/com32/acpioff/acpica_linuxized/include/acpi/actbl1.h
new file mode 100644
index 00000000..cf98669e
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/include/acpi/actbl1.h
@@ -0,0 +1,963 @@
+/******************************************************************************
+ *
+ * Name: actbl1.h - Additional ACPI table definitions
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACTBL1_H__
+#define __ACTBL1_H__
+
+/*******************************************************************************
+ *
+ * Additional ACPI Tables (1)
+ *
+ * These tables are not consumed directly by the ACPICA subsystem, but are
+ * included here to support device drivers and the AML disassembler.
+ *
+ * The tables in this file are fully defined within the ACPI specification.
+ *
+ ******************************************************************************/
+
+/*
+ * Values for description table header signatures for tables defined in this
+ * file. Useful because they make it more difficult to inadvertently type in
+ * the wrong signature.
+ */
+#define ACPI_SIG_BERT           "BERT"	/* Boot Error Record Table */
+#define ACPI_SIG_CPEP           "CPEP"	/* Corrected Platform Error Polling table */
+#define ACPI_SIG_ECDT           "ECDT"	/* Embedded Controller Boot Resources Table */
+#define ACPI_SIG_EINJ           "EINJ"	/* Error Injection table */
+#define ACPI_SIG_ERST           "ERST"	/* Error Record Serialization Table */
+#define ACPI_SIG_HEST           "HEST"	/* Hardware Error Source Table */
+#define ACPI_SIG_MADT           "APIC"	/* Multiple APIC Description Table */
+#define ACPI_SIG_MSCT           "MSCT"	/* Maximum System Characteristics Table */
+#define ACPI_SIG_SBST           "SBST"	/* Smart Battery Specification Table */
+#define ACPI_SIG_SLIT           "SLIT"	/* System Locality Distance Information Table */
+#define ACPI_SIG_SRAT           "SRAT"	/* System Resource Affinity Table */
+
+/*
+ * All tables must be byte-packed to match the ACPI specification, since
+ * the tables are provided by the system BIOS.
+ */
+#pragma pack(1)
+
+/*
+ * Note about bitfields: The u8 type is used for bitfields in ACPI tables.
+ * This is the only type that is even remotely portable. Anything else is not
+ * portable, so do not use any other bitfield types.
+ */
+
+/*******************************************************************************
+ *
+ * Common subtable headers
+ *
+ ******************************************************************************/
+
+/* Generic subtable header (used in MADT, SRAT, etc.) */
+
+struct acpi_subtable_header {
+	u8 type;
+	u8 length;
+};
+
+/* Subtable header for WHEA tables (EINJ, ERST, WDAT) */
+
+struct acpi_whea_header {
+	u8 action;
+	u8 instruction;
+	u8 flags;
+	u8 reserved;
+	struct acpi_generic_address register_region;
+	u64 value;		/* Value used with Read/Write register */
+	u64 mask;		/* Bitmask required for this register instruction */
+};
+
+/*******************************************************************************
+ *
+ * BERT - Boot Error Record Table (ACPI 4.0)
+ *        Version 1
+ *
+ ******************************************************************************/
+
+struct acpi_table_bert {
+	struct acpi_table_header header;	/* Common ACPI table header */
+	u32 region_length;	/* Length of the boot error region */
+	u64 address;		/* Physical addresss of the error region */
+};
+
+/* Boot Error Region (not a subtable, pointed to by Address field above) */
+
+struct acpi_bert_region {
+	u32 block_status;	/* Type of error information */
+	u32 raw_data_offset;	/* Offset to raw error data */
+	u32 raw_data_length;	/* Length of raw error data */
+	u32 data_length;	/* Length of generic error data */
+	u32 error_severity;	/* Severity code */
+};
+
+/* Values for block_status flags above */
+
+#define ACPI_BERT_UNCORRECTABLE             (1)
+#define ACPI_BERT_CORRECTABLE               (1<<1)
+#define ACPI_BERT_MULTIPLE_UNCORRECTABLE    (1<<2)
+#define ACPI_BERT_MULTIPLE_CORRECTABLE      (1<<3)
+#define ACPI_BERT_ERROR_ENTRY_COUNT         (0xFF<<4)	/* 8 bits, error count */
+
+/* Values for error_severity above */
+
+enum acpi_bert_error_severity {
+	ACPI_BERT_ERROR_CORRECTABLE = 0,
+	ACPI_BERT_ERROR_FATAL = 1,
+	ACPI_BERT_ERROR_CORRECTED = 2,
+	ACPI_BERT_ERROR_NONE = 3,
+	ACPI_BERT_ERROR_RESERVED = 4	/* 4 and greater are reserved */
+};
+
+/*
+ * Note: The generic error data that follows the error_severity field above
+ * uses the struct acpi_hest_generic_data defined under the HEST table below
+ */
+
+/*******************************************************************************
+ *
+ * CPEP - Corrected Platform Error Polling table (ACPI 4.0)
+ *        Version 1
+ *
+ ******************************************************************************/
+
+struct acpi_table_cpep {
+	struct acpi_table_header header;	/* Common ACPI table header */
+	u64 reserved;
+};
+
+/* Subtable */
+
+struct acpi_cpep_polling {
+	struct acpi_subtable_header header;
+	u8 id;			/* Processor ID */
+	u8 eid;			/* Processor EID */
+	u32 interval;		/* Polling interval (msec) */
+};
+
+/*******************************************************************************
+ *
+ * ECDT - Embedded Controller Boot Resources Table
+ *        Version 1
+ *
+ ******************************************************************************/
+
+struct acpi_table_ecdt {
+	struct acpi_table_header header;	/* Common ACPI table header */
+	struct acpi_generic_address control;	/* Address of EC command/status register */
+	struct acpi_generic_address data;	/* Address of EC data register */
+	u32 uid;		/* Unique ID - must be same as the EC _UID method */
+	u8 gpe;			/* The GPE for the EC */
+	u8 id[1];		/* Full namepath of the EC in the ACPI namespace */
+};
+
+/*******************************************************************************
+ *
+ * EINJ - Error Injection Table (ACPI 4.0)
+ *        Version 1
+ *
+ ******************************************************************************/
+
+struct acpi_table_einj {
+	struct acpi_table_header header;	/* Common ACPI table header */
+	u32 header_length;
+	u8 flags;
+	u8 reserved[3];
+	u32 entries;
+};
+
+/* EINJ Injection Instruction Entries (actions) */
+
+struct acpi_einj_entry {
+	struct acpi_whea_header whea_header;	/* Common header for WHEA tables */
+};
+
+/* Masks for Flags field above */
+
+#define ACPI_EINJ_PRESERVE          (1)
+
+/* Values for Action field above */
+
+enum acpi_einj_actions {
+	ACPI_EINJ_BEGIN_OPERATION = 0,
+	ACPI_EINJ_GET_TRIGGER_TABLE = 1,
+	ACPI_EINJ_SET_ERROR_TYPE = 2,
+	ACPI_EINJ_GET_ERROR_TYPE = 3,
+	ACPI_EINJ_END_OPERATION = 4,
+	ACPI_EINJ_EXECUTE_OPERATION = 5,
+	ACPI_EINJ_CHECK_BUSY_STATUS = 6,
+	ACPI_EINJ_GET_COMMAND_STATUS = 7,
+	ACPI_EINJ_SET_ERROR_TYPE_WITH_ADDRESS = 8,
+	ACPI_EINJ_ACTION_RESERVED = 9,	/* 9 and greater are reserved */
+	ACPI_EINJ_TRIGGER_ERROR = 0xFF	/* Except for this value */
+};
+
+/* Values for Instruction field above */
+
+enum acpi_einj_instructions {
+	ACPI_EINJ_READ_REGISTER = 0,
+	ACPI_EINJ_READ_REGISTER_VALUE = 1,
+	ACPI_EINJ_WRITE_REGISTER = 2,
+	ACPI_EINJ_WRITE_REGISTER_VALUE = 3,
+	ACPI_EINJ_NOOP = 4,
+	ACPI_EINJ_FLUSH_CACHELINE = 5,
+	ACPI_EINJ_INSTRUCTION_RESERVED = 6	/* 6 and greater are reserved */
+};
+
+struct acpi_einj_error_type_with_addr {
+	u32 error_type;
+	u32 vendor_struct_offset;
+	u32 flags;
+	u32 apic_id;
+	u64 address;
+	u64 range;
+	u32 pcie_id;
+};
+
+struct acpi_einj_vendor {
+	u32 length;
+	u32 pcie_id;
+	u16 vendor_id;
+	u16 device_id;
+	u8 revision_id;
+	u8 reserved[3];
+};
+
+/* EINJ Trigger Error Action Table */
+
+struct acpi_einj_trigger {
+	u32 header_size;
+	u32 revision;
+	u32 table_size;
+	u32 entry_count;
+};
+
+/* Command status return values */
+
+enum acpi_einj_command_status {
+	ACPI_EINJ_SUCCESS = 0,
+	ACPI_EINJ_FAILURE = 1,
+	ACPI_EINJ_INVALID_ACCESS = 2,
+	ACPI_EINJ_STATUS_RESERVED = 3	/* 3 and greater are reserved */
+};
+
+/* Error types returned from ACPI_EINJ_GET_ERROR_TYPE (bitfield) */
+
+#define ACPI_EINJ_PROCESSOR_CORRECTABLE     (1)
+#define ACPI_EINJ_PROCESSOR_UNCORRECTABLE   (1<<1)
+#define ACPI_EINJ_PROCESSOR_FATAL           (1<<2)
+#define ACPI_EINJ_MEMORY_CORRECTABLE        (1<<3)
+#define ACPI_EINJ_MEMORY_UNCORRECTABLE      (1<<4)
+#define ACPI_EINJ_MEMORY_FATAL              (1<<5)
+#define ACPI_EINJ_PCIX_CORRECTABLE          (1<<6)
+#define ACPI_EINJ_PCIX_UNCORRECTABLE        (1<<7)
+#define ACPI_EINJ_PCIX_FATAL                (1<<8)
+#define ACPI_EINJ_PLATFORM_CORRECTABLE      (1<<9)
+#define ACPI_EINJ_PLATFORM_UNCORRECTABLE    (1<<10)
+#define ACPI_EINJ_PLATFORM_FATAL            (1<<11)
+#define ACPI_EINJ_VENDOR_DEFINED            (1<<31)
+
+/*******************************************************************************
+ *
+ * ERST - Error Record Serialization Table (ACPI 4.0)
+ *        Version 1
+ *
+ ******************************************************************************/
+
+struct acpi_table_erst {
+	struct acpi_table_header header;	/* Common ACPI table header */
+	u32 header_length;
+	u32 reserved;
+	u32 entries;
+};
+
+/* ERST Serialization Entries (actions) */
+
+struct acpi_erst_entry {
+	struct acpi_whea_header whea_header;	/* Common header for WHEA tables */
+};
+
+/* Masks for Flags field above */
+
+#define ACPI_ERST_PRESERVE          (1)
+
+/* Values for Action field above */
+
+enum acpi_erst_actions {
+	ACPI_ERST_BEGIN_WRITE = 0,
+	ACPI_ERST_BEGIN_READ = 1,
+	ACPI_ERST_BEGIN_CLEAR = 2,
+	ACPI_ERST_END = 3,
+	ACPI_ERST_SET_RECORD_OFFSET = 4,
+	ACPI_ERST_EXECUTE_OPERATION = 5,
+	ACPI_ERST_CHECK_BUSY_STATUS = 6,
+	ACPI_ERST_GET_COMMAND_STATUS = 7,
+	ACPI_ERST_GET_RECORD_ID = 8,
+	ACPI_ERST_SET_RECORD_ID = 9,
+	ACPI_ERST_GET_RECORD_COUNT = 10,
+	ACPI_ERST_BEGIN_DUMMY_WRIITE = 11,
+	ACPI_ERST_NOT_USED = 12,
+	ACPI_ERST_GET_ERROR_RANGE = 13,
+	ACPI_ERST_GET_ERROR_LENGTH = 14,
+	ACPI_ERST_GET_ERROR_ATTRIBUTES = 15,
+	ACPI_ERST_ACTION_RESERVED = 16	/* 16 and greater are reserved */
+};
+
+/* Values for Instruction field above */
+
+enum acpi_erst_instructions {
+	ACPI_ERST_READ_REGISTER = 0,
+	ACPI_ERST_READ_REGISTER_VALUE = 1,
+	ACPI_ERST_WRITE_REGISTER = 2,
+	ACPI_ERST_WRITE_REGISTER_VALUE = 3,
+	ACPI_ERST_NOOP = 4,
+	ACPI_ERST_LOAD_VAR1 = 5,
+	ACPI_ERST_LOAD_VAR2 = 6,
+	ACPI_ERST_STORE_VAR1 = 7,
+	ACPI_ERST_ADD = 8,
+	ACPI_ERST_SUBTRACT = 9,
+	ACPI_ERST_ADD_VALUE = 10,
+	ACPI_ERST_SUBTRACT_VALUE = 11,
+	ACPI_ERST_STALL = 12,
+	ACPI_ERST_STALL_WHILE_TRUE = 13,
+	ACPI_ERST_SKIP_NEXT_IF_TRUE = 14,
+	ACPI_ERST_GOTO = 15,
+	ACPI_ERST_SET_SRC_ADDRESS_BASE = 16,
+	ACPI_ERST_SET_DST_ADDRESS_BASE = 17,
+	ACPI_ERST_MOVE_DATA = 18,
+	ACPI_ERST_INSTRUCTION_RESERVED = 19	/* 19 and greater are reserved */
+};
+
+/* Command status return values */
+
+enum acpi_erst_command_status {
+	ACPI_ERST_SUCESS = 0,
+	ACPI_ERST_NO_SPACE = 1,
+	ACPI_ERST_NOT_AVAILABLE = 2,
+	ACPI_ERST_FAILURE = 3,
+	ACPI_ERST_RECORD_EMPTY = 4,
+	ACPI_ERST_NOT_FOUND = 5,
+	ACPI_ERST_STATUS_RESERVED = 6	/* 6 and greater are reserved */
+};
+
+/* Error Record Serialization Information */
+
+struct acpi_erst_info {
+	u16 signature;		/* Should be "ER" */
+	u8 data[48];
+};
+
+/*******************************************************************************
+ *
+ * HEST - Hardware Error Source Table (ACPI 4.0)
+ *        Version 1
+ *
+ ******************************************************************************/
+
+struct acpi_table_hest {
+	struct acpi_table_header header;	/* Common ACPI table header */
+	u32 error_source_count;
+};
+
+/* HEST subtable header */
+
+struct acpi_hest_header {
+	u16 type;
+	u16 source_id;
+};
+
+/* Values for Type field above for subtables */
+
+enum acpi_hest_types {
+	ACPI_HEST_TYPE_IA32_CHECK = 0,
+	ACPI_HEST_TYPE_IA32_CORRECTED_CHECK = 1,
+	ACPI_HEST_TYPE_IA32_NMI = 2,
+	ACPI_HEST_TYPE_NOT_USED3 = 3,
+	ACPI_HEST_TYPE_NOT_USED4 = 4,
+	ACPI_HEST_TYPE_NOT_USED5 = 5,
+	ACPI_HEST_TYPE_AER_ROOT_PORT = 6,
+	ACPI_HEST_TYPE_AER_ENDPOINT = 7,
+	ACPI_HEST_TYPE_AER_BRIDGE = 8,
+	ACPI_HEST_TYPE_GENERIC_ERROR = 9,
+	ACPI_HEST_TYPE_RESERVED = 10	/* 10 and greater are reserved */
+};
+
+/*
+ * HEST substructures contained in subtables
+ */
+
+/*
+ * IA32 Error Bank(s) - Follows the struct acpi_hest_ia_machine_check and
+ * struct acpi_hest_ia_corrected structures.
+ */
+struct acpi_hest_ia_error_bank {
+	u8 bank_number;
+	u8 clear_status_on_init;
+	u8 status_format;
+	u8 reserved;
+	u32 control_register;
+	u64 control_data;
+	u32 status_register;
+	u32 address_register;
+	u32 misc_register;
+};
+
+/* Common HEST sub-structure for PCI/AER structures below (6,7,8) */
+
+struct acpi_hest_aer_common {
+	u16 reserved1;
+	u8 flags;
+	u8 enabled;
+	u32 records_to_preallocate;
+	u32 max_sections_per_record;
+	u32 bus;
+	u16 device;
+	u16 function;
+	u16 device_control;
+	u16 reserved2;
+	u32 uncorrectable_mask;
+	u32 uncorrectable_severity;
+	u32 correctable_mask;
+	u32 advanced_capabilities;
+};
+
+/* Masks for HEST Flags fields */
+
+#define ACPI_HEST_FIRMWARE_FIRST        (1)
+#define ACPI_HEST_GLOBAL                (1<<1)
+
+/* Hardware Error Notification */
+
+struct acpi_hest_notify {
+	u8 type;
+	u8 length;
+	u16 config_write_enable;
+	u32 poll_interval;
+	u32 vector;
+	u32 polling_threshold_value;
+	u32 polling_threshold_window;
+	u32 error_threshold_value;
+	u32 error_threshold_window;
+};
+
+/* Values for Notify Type field above */
+
+enum acpi_hest_notify_types {
+	ACPI_HEST_NOTIFY_POLLED = 0,
+	ACPI_HEST_NOTIFY_EXTERNAL = 1,
+	ACPI_HEST_NOTIFY_LOCAL = 2,
+	ACPI_HEST_NOTIFY_SCI = 3,
+	ACPI_HEST_NOTIFY_NMI = 4,
+	ACPI_HEST_NOTIFY_RESERVED = 5	/* 5 and greater are reserved */
+};
+
+/* Values for config_write_enable bitfield above */
+
+#define ACPI_HEST_TYPE                  (1)
+#define ACPI_HEST_POLL_INTERVAL         (1<<1)
+#define ACPI_HEST_POLL_THRESHOLD_VALUE  (1<<2)
+#define ACPI_HEST_POLL_THRESHOLD_WINDOW (1<<3)
+#define ACPI_HEST_ERR_THRESHOLD_VALUE   (1<<4)
+#define ACPI_HEST_ERR_THRESHOLD_WINDOW  (1<<5)
+
+/*
+ * HEST subtables
+ */
+
+/* 0: IA32 Machine Check Exception */
+
+struct acpi_hest_ia_machine_check {
+	struct acpi_hest_header header;
+	u16 reserved1;
+	u8 flags;
+	u8 enabled;
+	u32 records_to_preallocate;
+	u32 max_sections_per_record;
+	u64 global_capability_data;
+	u64 global_control_data;
+	u8 num_hardware_banks;
+	u8 reserved3[7];
+};
+
+/* 1: IA32 Corrected Machine Check */
+
+struct acpi_hest_ia_corrected {
+	struct acpi_hest_header header;
+	u16 reserved1;
+	u8 flags;
+	u8 enabled;
+	u32 records_to_preallocate;
+	u32 max_sections_per_record;
+	struct acpi_hest_notify notify;
+	u8 num_hardware_banks;
+	u8 reserved2[3];
+};
+
+/* 2: IA32 Non-Maskable Interrupt */
+
+struct acpi_hest_ia_nmi {
+	struct acpi_hest_header header;
+	u32 reserved;
+	u32 records_to_preallocate;
+	u32 max_sections_per_record;
+	u32 max_raw_data_length;
+};
+
+/* 3,4,5: Not used */
+
+/* 6: PCI Express Root Port AER */
+
+struct acpi_hest_aer_root {
+	struct acpi_hest_header header;
+	struct acpi_hest_aer_common aer;
+	u32 root_error_command;
+};
+
+/* 7: PCI Express AER (AER Endpoint) */
+
+struct acpi_hest_aer {
+	struct acpi_hest_header header;
+	struct acpi_hest_aer_common aer;
+};
+
+/* 8: PCI Express/PCI-X Bridge AER */
+
+struct acpi_hest_aer_bridge {
+	struct acpi_hest_header header;
+	struct acpi_hest_aer_common aer;
+	u32 uncorrectable_mask2;
+	u32 uncorrectable_severity2;
+	u32 advanced_capabilities2;
+};
+
+/* 9: Generic Hardware Error Source */
+
+struct acpi_hest_generic {
+	struct acpi_hest_header header;
+	u16 related_source_id;
+	u8 reserved;
+	u8 enabled;
+	u32 records_to_preallocate;
+	u32 max_sections_per_record;
+	u32 max_raw_data_length;
+	struct acpi_generic_address error_status_address;
+	struct acpi_hest_notify notify;
+	u32 error_block_length;
+};
+
+/* Generic Error Status block */
+
+struct acpi_hest_generic_status {
+	u32 block_status;
+	u32 raw_data_offset;
+	u32 raw_data_length;
+	u32 data_length;
+	u32 error_severity;
+};
+
+/* Values for block_status flags above */
+
+#define ACPI_HEST_UNCORRECTABLE             (1)
+#define ACPI_HEST_CORRECTABLE               (1<<1)
+#define ACPI_HEST_MULTIPLE_UNCORRECTABLE    (1<<2)
+#define ACPI_HEST_MULTIPLE_CORRECTABLE      (1<<3)
+#define ACPI_HEST_ERROR_ENTRY_COUNT         (0xFF<<4)	/* 8 bits, error count */
+
+/* Generic Error Data entry */
+
+struct acpi_hest_generic_data {
+	u8 section_type[16];
+	u32 error_severity;
+	u16 revision;
+	u8 validation_bits;
+	u8 flags;
+	u32 error_data_length;
+	u8 fru_id[16];
+	u8 fru_text[20];
+};
+
+/*******************************************************************************
+ *
+ * MADT - Multiple APIC Description Table
+ *        Version 3
+ *
+ ******************************************************************************/
+
+struct acpi_table_madt {
+	struct acpi_table_header header;	/* Common ACPI table header */
+	u32 address;		/* Physical address of local APIC */
+	u32 flags;
+};
+
+/* Masks for Flags field above */
+
+#define ACPI_MADT_PCAT_COMPAT       (1)	/* 00: System also has dual 8259s */
+
+/* Values for PCATCompat flag */
+
+#define ACPI_MADT_DUAL_PIC          0
+#define ACPI_MADT_MULTIPLE_APIC     1
+
+/* Values for MADT subtable type in struct acpi_subtable_header */
+
+enum acpi_madt_type {
+	ACPI_MADT_TYPE_LOCAL_APIC = 0,
+	ACPI_MADT_TYPE_IO_APIC = 1,
+	ACPI_MADT_TYPE_INTERRUPT_OVERRIDE = 2,
+	ACPI_MADT_TYPE_NMI_SOURCE = 3,
+	ACPI_MADT_TYPE_LOCAL_APIC_NMI = 4,
+	ACPI_MADT_TYPE_LOCAL_APIC_OVERRIDE = 5,
+	ACPI_MADT_TYPE_IO_SAPIC = 6,
+	ACPI_MADT_TYPE_LOCAL_SAPIC = 7,
+	ACPI_MADT_TYPE_INTERRUPT_SOURCE = 8,
+	ACPI_MADT_TYPE_LOCAL_X2APIC = 9,
+	ACPI_MADT_TYPE_LOCAL_X2APIC_NMI = 10,
+	ACPI_MADT_TYPE_GENERIC_INTERRUPT = 11,
+	ACPI_MADT_TYPE_GENERIC_DISTRIBUTOR = 12,
+	ACPI_MADT_TYPE_RESERVED = 13	/* 13 and greater are reserved */
+};
+
+/*
+ * MADT Sub-tables, correspond to Type in struct acpi_subtable_header
+ */
+
+/* 0: Processor Local APIC */
+
+struct acpi_madt_local_apic {
+	struct acpi_subtable_header header;
+	u8 processor_id;	/* ACPI processor id */
+	u8 id;			/* Processor's local APIC id */
+	u32 lapic_flags;
+};
+
+/* 1: IO APIC */
+
+struct acpi_madt_io_apic {
+	struct acpi_subtable_header header;
+	u8 id;			/* I/O APIC ID */
+	u8 reserved;		/* Reserved - must be zero */
+	u32 address;		/* APIC physical address */
+	u32 global_irq_base;	/* Global system interrupt where INTI lines start */
+};
+
+/* 2: Interrupt Override */
+
+struct acpi_madt_interrupt_override {
+	struct acpi_subtable_header header;
+	u8 bus;			/* 0 - ISA */
+	u8 source_irq;		/* Interrupt source (IRQ) */
+	u32 global_irq;		/* Global system interrupt */
+	u16 inti_flags;
+};
+
+/* 3: NMI Source */
+
+struct acpi_madt_nmi_source {
+	struct acpi_subtable_header header;
+	u16 inti_flags;
+	u32 global_irq;		/* Global system interrupt */
+};
+
+/* 4: Local APIC NMI */
+
+struct acpi_madt_local_apic_nmi {
+	struct acpi_subtable_header header;
+	u8 processor_id;	/* ACPI processor id */
+	u16 inti_flags;
+	u8 lint;		/* LINTn to which NMI is connected */
+};
+
+/* 5: Address Override */
+
+struct acpi_madt_local_apic_override {
+	struct acpi_subtable_header header;
+	u16 reserved;		/* Reserved, must be zero */
+	u64 address;		/* APIC physical address */
+};
+
+/* 6: I/O Sapic */
+
+struct acpi_madt_io_sapic {
+	struct acpi_subtable_header header;
+	u8 id;			/* I/O SAPIC ID */
+	u8 reserved;		/* Reserved, must be zero */
+	u32 global_irq_base;	/* Global interrupt for SAPIC start */
+	u64 address;		/* SAPIC physical address */
+};
+
+/* 7: Local Sapic */
+
+struct acpi_madt_local_sapic {
+	struct acpi_subtable_header header;
+	u8 processor_id;	/* ACPI processor id */
+	u8 id;			/* SAPIC ID */
+	u8 eid;			/* SAPIC EID */
+	u8 reserved[3];		/* Reserved, must be zero */
+	u32 lapic_flags;
+	u32 uid;		/* Numeric UID - ACPI 3.0 */
+	char uid_string[1];	/* String UID  - ACPI 3.0 */
+};
+
+/* 8: Platform Interrupt Source */
+
+struct acpi_madt_interrupt_source {
+	struct acpi_subtable_header header;
+	u16 inti_flags;
+	u8 type;		/* 1=PMI, 2=INIT, 3=corrected */
+	u8 id;			/* Processor ID */
+	u8 eid;			/* Processor EID */
+	u8 io_sapic_vector;	/* Vector value for PMI interrupts */
+	u32 global_irq;		/* Global system interrupt */
+	u32 flags;		/* Interrupt Source Flags */
+};
+
+/* Masks for Flags field above */
+
+#define ACPI_MADT_CPEI_OVERRIDE     (1)
+
+/* 9: Processor Local X2APIC (ACPI 4.0) */
+
+struct acpi_madt_local_x2apic {
+	struct acpi_subtable_header header;
+	u16 reserved;		/* Reserved - must be zero */
+	u32 local_apic_id;	/* Processor x2_aPIC ID */
+	u32 lapic_flags;
+	u32 uid;		/* ACPI processor UID */
+};
+
+/* 10: Local X2APIC NMI (ACPI 4.0) */
+
+struct acpi_madt_local_x2apic_nmi {
+	struct acpi_subtable_header header;
+	u16 inti_flags;
+	u32 uid;		/* ACPI processor UID */
+	u8 lint;		/* LINTn to which NMI is connected */
+	u8 reserved[3];		/* Reserved - must be zero */
+};
+
+/* 11: Generic Interrupt (ACPI 5.0) */
+
+struct acpi_madt_generic_interrupt {
+	struct acpi_subtable_header header;
+	u16 reserved;		/* Reserved - must be zero */
+	u32 gic_id;
+	u32 uid;
+	u32 flags;
+	u32 parking_version;
+	u32 performance_interrupt;
+	u64 parked_address;
+	u64 base_address;
+};
+
+/* 12: Generic Distributor (ACPI 5.0) */
+
+struct acpi_madt_generic_distributor {
+	struct acpi_subtable_header header;
+	u16 reserved;		/* Reserved - must be zero */
+	u32 gic_id;
+	u64 base_address;
+	u32 global_irq_base;
+	u32 reserved2;		/* Reserved - must be zero */
+};
+
+/*
+ * Common flags fields for MADT subtables
+ */
+
+/* MADT Local APIC flags (lapic_flags) and GIC flags */
+
+#define ACPI_MADT_ENABLED           (1)	/* 00: Processor is usable if set */
+
+/* MADT MPS INTI flags (inti_flags) */
+
+#define ACPI_MADT_POLARITY_MASK     (3)	/* 00-01: Polarity of APIC I/O input signals */
+#define ACPI_MADT_TRIGGER_MASK      (3<<2)	/* 02-03: Trigger mode of APIC input signals */
+
+/* Values for MPS INTI flags */
+
+#define ACPI_MADT_POLARITY_CONFORMS       0
+#define ACPI_MADT_POLARITY_ACTIVE_HIGH    1
+#define ACPI_MADT_POLARITY_RESERVED       2
+#define ACPI_MADT_POLARITY_ACTIVE_LOW     3
+
+#define ACPI_MADT_TRIGGER_CONFORMS        (0)
+#define ACPI_MADT_TRIGGER_EDGE            (1<<2)
+#define ACPI_MADT_TRIGGER_RESERVED        (2<<2)
+#define ACPI_MADT_TRIGGER_LEVEL           (3<<2)
+
+/*******************************************************************************
+ *
+ * MSCT - Maximum System Characteristics Table (ACPI 4.0)
+ *        Version 1
+ *
+ ******************************************************************************/
+
+struct acpi_table_msct {
+	struct acpi_table_header header;	/* Common ACPI table header */
+	u32 proximity_offset;	/* Location of proximity info struct(s) */
+	u32 max_proximity_domains;	/* Max number of proximity domains */
+	u32 max_clock_domains;	/* Max number of clock domains */
+	u64 max_address;	/* Max physical address in system */
+};
+
+/* Subtable - Maximum Proximity Domain Information. Version 1 */
+
+struct acpi_msct_proximity {
+	u8 revision;
+	u8 length;
+	u32 range_start;	/* Start of domain range */
+	u32 range_end;		/* End of domain range */
+	u32 processor_capacity;
+	u64 memory_capacity;	/* In bytes */
+};
+
+/*******************************************************************************
+ *
+ * SBST - Smart Battery Specification Table
+ *        Version 1
+ *
+ ******************************************************************************/
+
+struct acpi_table_sbst {
+	struct acpi_table_header header;	/* Common ACPI table header */
+	u32 warning_level;
+	u32 low_level;
+	u32 critical_level;
+};
+
+/*******************************************************************************
+ *
+ * SLIT - System Locality Distance Information Table
+ *        Version 1
+ *
+ ******************************************************************************/
+
+struct acpi_table_slit {
+	struct acpi_table_header header;	/* Common ACPI table header */
+	u64 locality_count;
+	u8 entry[1];		/* Real size = localities^2 */
+};
+
+/*******************************************************************************
+ *
+ * SRAT - System Resource Affinity Table
+ *        Version 3
+ *
+ ******************************************************************************/
+
+struct acpi_table_srat {
+	struct acpi_table_header header;	/* Common ACPI table header */
+	u32 table_revision;	/* Must be value '1' */
+	u64 reserved;		/* Reserved, must be zero */
+};
+
+/* Values for subtable type in struct acpi_subtable_header */
+
+enum acpi_srat_type {
+	ACPI_SRAT_TYPE_CPU_AFFINITY = 0,
+	ACPI_SRAT_TYPE_MEMORY_AFFINITY = 1,
+	ACPI_SRAT_TYPE_X2APIC_CPU_AFFINITY = 2,
+	ACPI_SRAT_TYPE_RESERVED = 3	/* 3 and greater are reserved */
+};
+
+/*
+ * SRAT Sub-tables, correspond to Type in struct acpi_subtable_header
+ */
+
+/* 0: Processor Local APIC/SAPIC Affinity */
+
+struct acpi_srat_cpu_affinity {
+	struct acpi_subtable_header header;
+	u8 proximity_domain_lo;
+	u8 apic_id;
+	u32 flags;
+	u8 local_sapic_eid;
+	u8 proximity_domain_hi[3];
+	u32 reserved;		/* Reserved, must be zero */
+};
+
+/* Flags */
+
+#define ACPI_SRAT_CPU_USE_AFFINITY  (1)	/* 00: Use affinity structure */
+
+/* 1: Memory Affinity */
+
+struct acpi_srat_mem_affinity {
+	struct acpi_subtable_header header;
+	u32 proximity_domain;
+	u16 reserved;		/* Reserved, must be zero */
+	u64 base_address;
+	u64 length;
+	u32 reserved1;
+	u32 flags;
+	u64 reserved2;		/* Reserved, must be zero */
+};
+
+/* Flags */
+
+#define ACPI_SRAT_MEM_ENABLED       (1)	/* 00: Use affinity structure */
+#define ACPI_SRAT_MEM_HOT_PLUGGABLE (1<<1)	/* 01: Memory region is hot pluggable */
+#define ACPI_SRAT_MEM_NON_VOLATILE  (1<<2)	/* 02: Memory region is non-volatile */
+
+/* 2: Processor Local X2_APIC Affinity (ACPI 4.0) */
+
+struct acpi_srat_x2apic_cpu_affinity {
+	struct acpi_subtable_header header;
+	u16 reserved;		/* Reserved, must be zero */
+	u32 proximity_domain;
+	u32 apic_id;
+	u32 flags;
+	u32 clock_domain;
+	u32 reserved2;
+};
+
+/* Flags for struct acpi_srat_cpu_affinity and struct acpi_srat_x2apic_cpu_affinity */
+
+#define ACPI_SRAT_CPU_ENABLED       (1)	/* 00: Use affinity structure */
+
+/* Reset to default packing */
+
+#pragma pack()
+
+#endif				/* __ACTBL1_H__ */
diff --git a/com32/acpioff/acpica_linuxized/include/acpi/actbl2.h b/com32/acpioff/acpica_linuxized/include/acpi/actbl2.h
new file mode 100644
index 00000000..7811564f
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/include/acpi/actbl2.h
@@ -0,0 +1,1048 @@
+/******************************************************************************
+ *
+ * Name: actbl2.h - ACPI Table Definitions (tables not in ACPI spec)
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACTBL2_H__
+#define __ACTBL2_H__
+
+/*******************************************************************************
+ *
+ * Additional ACPI Tables (2)
+ *
+ * These tables are not consumed directly by the ACPICA subsystem, but are
+ * included here to support device drivers and the AML disassembler.
+ *
+ * The tables in this file are defined by third-party specifications, and are
+ * not defined directly by the ACPI specification itself.
+ *
+ ******************************************************************************/
+
+/*
+ * Values for description table header signatures for tables defined in this
+ * file. Useful because they make it more difficult to inadvertently type in
+ * the wrong signature.
+ */
+#define ACPI_SIG_ASF            "ASF!"	/* Alert Standard Format table */
+#define ACPI_SIG_BOOT           "BOOT"	/* Simple Boot Flag Table */
+#define ACPI_SIG_DBGP           "DBGP"	/* Debug Port table */
+#define ACPI_SIG_DMAR           "DMAR"	/* DMA Remapping table */
+#define ACPI_SIG_HPET           "HPET"	/* High Precision Event Timer table */
+#define ACPI_SIG_IBFT           "IBFT"	/* i_sCSI Boot Firmware Table */
+#define ACPI_SIG_IVRS           "IVRS"	/* I/O Virtualization Reporting Structure */
+#define ACPI_SIG_MCFG           "MCFG"	/* PCI Memory Mapped Configuration table */
+#define ACPI_SIG_MCHI           "MCHI"	/* Management Controller Host Interface table */
+#define ACPI_SIG_SLIC           "SLIC"	/* Software Licensing Description Table */
+#define ACPI_SIG_SPCR           "SPCR"	/* Serial Port Console Redirection table */
+#define ACPI_SIG_SPMI           "SPMI"	/* Server Platform Management Interface table */
+#define ACPI_SIG_TCPA           "TCPA"	/* Trusted Computing Platform Alliance table */
+#define ACPI_SIG_UEFI           "UEFI"	/* Uefi Boot Optimization Table */
+#define ACPI_SIG_WAET           "WAET"	/* Windows ACPI Emulated devices Table */
+#define ACPI_SIG_WDAT           "WDAT"	/* Watchdog Action Table */
+#define ACPI_SIG_WDDT           "WDDT"	/* Watchdog Timer Description Table */
+#define ACPI_SIG_WDRT           "WDRT"	/* Watchdog Resource Table */
+
+#ifdef ACPI_UNDEFINED_TABLES
+/*
+ * These tables have been seen in the field, but no definition has been found
+ */
+#define ACPI_SIG_ATKG           "ATKG"
+#define ACPI_SIG_GSCI           "GSCI"	/* GMCH SCI table */
+#define ACPI_SIG_IEIT           "IEIT"
+#endif
+
+/*
+ * All tables must be byte-packed to match the ACPI specification, since
+ * the tables are provided by the system BIOS.
+ */
+#pragma pack(1)
+
+/*
+ * Note about bitfields: The u8 type is used for bitfields in ACPI tables.
+ * This is the only type that is even remotely portable. Anything else is not
+ * portable, so do not use any other bitfield types.
+ */
+
+/*******************************************************************************
+ *
+ * ASF - Alert Standard Format table (Signature "ASF!")
+ *       Revision 0x10
+ *
+ * Conforms to the Alert Standard Format Specification V2.0, 23 April 2003
+ *
+ ******************************************************************************/
+
+struct acpi_table_asf {
+	struct acpi_table_header header;	/* Common ACPI table header */
+};
+
+/* ASF subtable header */
+
+struct acpi_asf_header {
+	u8 type;
+	u8 reserved;
+	u16 length;
+};
+
+/* Values for Type field above */
+
+enum acpi_asf_type {
+	ACPI_ASF_TYPE_INFO = 0,
+	ACPI_ASF_TYPE_ALERT = 1,
+	ACPI_ASF_TYPE_CONTROL = 2,
+	ACPI_ASF_TYPE_BOOT = 3,
+	ACPI_ASF_TYPE_ADDRESS = 4,
+	ACPI_ASF_TYPE_RESERVED = 5
+};
+
+/*
+ * ASF subtables
+ */
+
+/* 0: ASF Information */
+
+struct acpi_asf_info {
+	struct acpi_asf_header header;
+	u8 min_reset_value;
+	u8 min_poll_interval;
+	u16 system_id;
+	u32 mfg_id;
+	u8 flags;
+	u8 reserved2[3];
+};
+
+/* Masks for Flags field above */
+
+#define ACPI_ASF_SMBUS_PROTOCOLS    (1)
+
+/* 1: ASF Alerts */
+
+struct acpi_asf_alert {
+	struct acpi_asf_header header;
+	u8 assert_mask;
+	u8 deassert_mask;
+	u8 alerts;
+	u8 data_length;
+};
+
+struct acpi_asf_alert_data {
+	u8 address;
+	u8 command;
+	u8 mask;
+	u8 value;
+	u8 sensor_type;
+	u8 type;
+	u8 offset;
+	u8 source_type;
+	u8 severity;
+	u8 sensor_number;
+	u8 entity;
+	u8 instance;
+};
+
+/* 2: ASF Remote Control */
+
+struct acpi_asf_remote {
+	struct acpi_asf_header header;
+	u8 controls;
+	u8 data_length;
+	u16 reserved2;
+};
+
+struct acpi_asf_control_data {
+	u8 function;
+	u8 address;
+	u8 command;
+	u8 value;
+};
+
+/* 3: ASF RMCP Boot Options */
+
+struct acpi_asf_rmcp {
+	struct acpi_asf_header header;
+	u8 capabilities[7];
+	u8 completion_code;
+	u32 enterprise_id;
+	u8 command;
+	u16 parameter;
+	u16 boot_options;
+	u16 oem_parameters;
+};
+
+/* 4: ASF Address */
+
+struct acpi_asf_address {
+	struct acpi_asf_header header;
+	u8 eprom_address;
+	u8 devices;
+};
+
+/*******************************************************************************
+ *
+ * BOOT - Simple Boot Flag Table
+ *        Version 1
+ *
+ * Conforms to the "Simple Boot Flag Specification", Version 2.1
+ *
+ ******************************************************************************/
+
+struct acpi_table_boot {
+	struct acpi_table_header header;	/* Common ACPI table header */
+	u8 cmos_index;		/* Index in CMOS RAM for the boot register */
+	u8 reserved[3];
+};
+
+/*******************************************************************************
+ *
+ * DBGP - Debug Port table
+ *        Version 1
+ *
+ * Conforms to the "Debug Port Specification", Version 1.00, 2/9/2000
+ *
+ ******************************************************************************/
+
+struct acpi_table_dbgp {
+	struct acpi_table_header header;	/* Common ACPI table header */
+	u8 type;		/* 0=full 16550, 1=subset of 16550 */
+	u8 reserved[3];
+	struct acpi_generic_address debug_port;
+};
+
+/*******************************************************************************
+ *
+ * DMAR - DMA Remapping table
+ *        Version 1
+ *
+ * Conforms to "Intel Virtualization Technology for Directed I/O",
+ * Version 1.2, Sept. 2008
+ *
+ ******************************************************************************/
+
+struct acpi_table_dmar {
+	struct acpi_table_header header;	/* Common ACPI table header */
+	u8 width;		/* Host Address Width */
+	u8 flags;
+	u8 reserved[10];
+};
+
+/* Masks for Flags field above */
+
+#define ACPI_DMAR_INTR_REMAP        (1)
+
+/* DMAR subtable header */
+
+struct acpi_dmar_header {
+	u16 type;
+	u16 length;
+};
+
+/* Values for subtable type in struct acpi_dmar_header */
+
+enum acpi_dmar_type {
+	ACPI_DMAR_TYPE_HARDWARE_UNIT = 0,
+	ACPI_DMAR_TYPE_RESERVED_MEMORY = 1,
+	ACPI_DMAR_TYPE_ATSR = 2,
+	ACPI_DMAR_HARDWARE_AFFINITY = 3,
+	ACPI_DMAR_TYPE_RESERVED = 4	/* 4 and greater are reserved */
+};
+
+/* DMAR Device Scope structure */
+
+struct acpi_dmar_device_scope {
+	u8 entry_type;
+	u8 length;
+	u16 reserved;
+	u8 enumeration_id;
+	u8 bus;
+};
+
+/* Values for entry_type in struct acpi_dmar_device_scope */
+
+enum acpi_dmar_scope_type {
+	ACPI_DMAR_SCOPE_TYPE_NOT_USED = 0,
+	ACPI_DMAR_SCOPE_TYPE_ENDPOINT = 1,
+	ACPI_DMAR_SCOPE_TYPE_BRIDGE = 2,
+	ACPI_DMAR_SCOPE_TYPE_IOAPIC = 3,
+	ACPI_DMAR_SCOPE_TYPE_HPET = 4,
+	ACPI_DMAR_SCOPE_TYPE_RESERVED = 5	/* 5 and greater are reserved */
+};
+
+struct acpi_dmar_pci_path {
+	u8 device;
+	u8 function;
+};
+
+/*
+ * DMAR Sub-tables, correspond to Type in struct acpi_dmar_header
+ */
+
+/* 0: Hardware Unit Definition */
+
+struct acpi_dmar_hardware_unit {
+	struct acpi_dmar_header header;
+	u8 flags;
+	u8 reserved;
+	u16 segment;
+	u64 address;		/* Register Base Address */
+};
+
+/* Masks for Flags field above */
+
+#define ACPI_DMAR_INCLUDE_ALL       (1)
+
+/* 1: Reserved Memory Defininition */
+
+struct acpi_dmar_reserved_memory {
+	struct acpi_dmar_header header;
+	u16 reserved;
+	u16 segment;
+	u64 base_address;	/* 4_k aligned base address */
+	u64 end_address;	/* 4_k aligned limit address */
+};
+
+/* Masks for Flags field above */
+
+#define ACPI_DMAR_ALLOW_ALL         (1)
+
+/* 2: Root Port ATS Capability Reporting Structure */
+
+struct acpi_dmar_atsr {
+	struct acpi_dmar_header header;
+	u8 flags;
+	u8 reserved;
+	u16 segment;
+};
+
+/* Masks for Flags field above */
+
+#define ACPI_DMAR_ALL_PORTS         (1)
+
+/* 3: Remapping Hardware Static Affinity Structure */
+
+struct acpi_dmar_rhsa {
+	struct acpi_dmar_header header;
+	u32 reserved;
+	u64 base_address;
+	u32 proximity_domain;
+};
+
+/*******************************************************************************
+ *
+ * HPET - High Precision Event Timer table
+ *        Version 1
+ *
+ * Conforms to "IA-PC HPET (High Precision Event Timers) Specification",
+ * Version 1.0a, October 2004
+ *
+ ******************************************************************************/
+
+struct acpi_table_hpet {
+	struct acpi_table_header header;	/* Common ACPI table header */
+	u32 id;			/* Hardware ID of event timer block */
+	struct acpi_generic_address address;	/* Address of event timer block */
+	u8 sequence;		/* HPET sequence number */
+	u16 minimum_tick;	/* Main counter min tick, periodic mode */
+	u8 flags;
+};
+
+/* Masks for Flags field above */
+
+#define ACPI_HPET_PAGE_PROTECT_MASK (3)
+
+/* Values for Page Protect flags */
+
+enum acpi_hpet_page_protect {
+	ACPI_HPET_NO_PAGE_PROTECT = 0,
+	ACPI_HPET_PAGE_PROTECT4 = 1,
+	ACPI_HPET_PAGE_PROTECT64 = 2
+};
+
+/*******************************************************************************
+ *
+ * IBFT - Boot Firmware Table
+ *        Version 1
+ *
+ * Conforms to "iSCSI Boot Firmware Table (iBFT) as Defined in ACPI 3.0b
+ * Specification", Version 1.01, March 1, 2007
+ *
+ * Note: It appears that this table is not intended to appear in the RSDT/XSDT.
+ * Therefore, it is not currently supported by the disassembler.
+ *
+ ******************************************************************************/
+
+struct acpi_table_ibft {
+	struct acpi_table_header header;	/* Common ACPI table header */
+	u8 reserved[12];
+};
+
+/* IBFT common subtable header */
+
+struct acpi_ibft_header {
+	u8 type;
+	u8 version;
+	u16 length;
+	u8 index;
+	u8 flags;
+};
+
+/* Values for Type field above */
+
+enum acpi_ibft_type {
+	ACPI_IBFT_TYPE_NOT_USED = 0,
+	ACPI_IBFT_TYPE_CONTROL = 1,
+	ACPI_IBFT_TYPE_INITIATOR = 2,
+	ACPI_IBFT_TYPE_NIC = 3,
+	ACPI_IBFT_TYPE_TARGET = 4,
+	ACPI_IBFT_TYPE_EXTENSIONS = 5,
+	ACPI_IBFT_TYPE_RESERVED = 6	/* 6 and greater are reserved */
+};
+
+/* IBFT subtables */
+
+struct acpi_ibft_control {
+	struct acpi_ibft_header header;
+	u16 extensions;
+	u16 initiator_offset;
+	u16 nic0_offset;
+	u16 target0_offset;
+	u16 nic1_offset;
+	u16 target1_offset;
+};
+
+struct acpi_ibft_initiator {
+	struct acpi_ibft_header header;
+	u8 sns_server[16];
+	u8 slp_server[16];
+	u8 primary_server[16];
+	u8 secondary_server[16];
+	u16 name_length;
+	u16 name_offset;
+};
+
+struct acpi_ibft_nic {
+	struct acpi_ibft_header header;
+	u8 ip_address[16];
+	u8 subnet_mask_prefix;
+	u8 origin;
+	u8 gateway[16];
+	u8 primary_dns[16];
+	u8 secondary_dns[16];
+	u8 dhcp[16];
+	u16 vlan;
+	u8 mac_address[6];
+	u16 pci_address;
+	u16 name_length;
+	u16 name_offset;
+};
+
+struct acpi_ibft_target {
+	struct acpi_ibft_header header;
+	u8 target_ip_address[16];
+	u16 target_ip_socket;
+	u8 target_boot_lun[8];
+	u8 chap_type;
+	u8 nic_association;
+	u16 target_name_length;
+	u16 target_name_offset;
+	u16 chap_name_length;
+	u16 chap_name_offset;
+	u16 chap_secret_length;
+	u16 chap_secret_offset;
+	u16 reverse_chap_name_length;
+	u16 reverse_chap_name_offset;
+	u16 reverse_chap_secret_length;
+	u16 reverse_chap_secret_offset;
+};
+
+/*******************************************************************************
+ *
+ * IVRS - I/O Virtualization Reporting Structure
+ *        Version 1
+ *
+ * Conforms to "AMD I/O Virtualization Technology (IOMMU) Specification",
+ * Revision 1.26, February 2009.
+ *
+ ******************************************************************************/
+
+struct acpi_table_ivrs {
+	struct acpi_table_header header;	/* Common ACPI table header */
+	u32 info;		/* Common virtualization info */
+	u64 reserved;
+};
+
+/* Values for Info field above */
+
+#define ACPI_IVRS_PHYSICAL_SIZE     0x00007F00	/* 7 bits, physical address size */
+#define ACPI_IVRS_VIRTUAL_SIZE      0x003F8000	/* 7 bits, virtual address size */
+#define ACPI_IVRS_ATS_RESERVED      0x00400000	/* ATS address translation range reserved */
+
+/* IVRS subtable header */
+
+struct acpi_ivrs_header {
+	u8 type;		/* Subtable type */
+	u8 flags;
+	u16 length;		/* Subtable length */
+	u16 device_id;		/* ID of IOMMU */
+};
+
+/* Values for subtable Type above */
+
+enum acpi_ivrs_type {
+	ACPI_IVRS_TYPE_HARDWARE = 0x10,
+	ACPI_IVRS_TYPE_MEMORY1 = 0x20,
+	ACPI_IVRS_TYPE_MEMORY2 = 0x21,
+	ACPI_IVRS_TYPE_MEMORY3 = 0x22
+};
+
+/* Masks for Flags field above for IVHD subtable */
+
+#define ACPI_IVHD_TT_ENABLE         (1)
+#define ACPI_IVHD_PASS_PW           (1<<1)
+#define ACPI_IVHD_RES_PASS_PW       (1<<2)
+#define ACPI_IVHD_ISOC              (1<<3)
+#define ACPI_IVHD_IOTLB             (1<<4)
+
+/* Masks for Flags field above for IVMD subtable */
+
+#define ACPI_IVMD_UNITY             (1)
+#define ACPI_IVMD_READ              (1<<1)
+#define ACPI_IVMD_WRITE             (1<<2)
+#define ACPI_IVMD_EXCLUSION_RANGE   (1<<3)
+
+/*
+ * IVRS subtables, correspond to Type in struct acpi_ivrs_header
+ */
+
+/* 0x10: I/O Virtualization Hardware Definition Block (IVHD) */
+
+struct acpi_ivrs_hardware {
+	struct acpi_ivrs_header header;
+	u16 capability_offset;	/* Offset for IOMMU control fields */
+	u64 base_address;	/* IOMMU control registers */
+	u16 pci_segment_group;
+	u16 info;		/* MSI number and unit ID */
+	u32 reserved;
+};
+
+/* Masks for Info field above */
+
+#define ACPI_IVHD_MSI_NUMBER_MASK   0x001F	/* 5 bits, MSI message number */
+#define ACPI_IVHD_UNIT_ID_MASK      0x1F00	/* 5 bits, unit_iD */
+
+/*
+ * Device Entries for IVHD subtable, appear after struct acpi_ivrs_hardware structure.
+ * Upper two bits of the Type field are the (encoded) length of the structure.
+ * Currently, only 4 and 8 byte entries are defined. 16 and 32 byte entries
+ * are reserved for future use but not defined.
+ */
+struct acpi_ivrs_de_header {
+	u8 type;
+	u16 id;
+	u8 data_setting;
+};
+
+/* Length of device entry is in the top two bits of Type field above */
+
+#define ACPI_IVHD_ENTRY_LENGTH      0xC0
+
+/* Values for device entry Type field above */
+
+enum acpi_ivrs_device_entry_type {
+	/* 4-byte device entries, all use struct acpi_ivrs_device4 */
+
+	ACPI_IVRS_TYPE_PAD4 = 0,
+	ACPI_IVRS_TYPE_ALL = 1,
+	ACPI_IVRS_TYPE_SELECT = 2,
+	ACPI_IVRS_TYPE_START = 3,
+	ACPI_IVRS_TYPE_END = 4,
+
+	/* 8-byte device entries */
+
+	ACPI_IVRS_TYPE_PAD8 = 64,
+	ACPI_IVRS_TYPE_NOT_USED = 65,
+	ACPI_IVRS_TYPE_ALIAS_SELECT = 66,	/* Uses struct acpi_ivrs_device8a */
+	ACPI_IVRS_TYPE_ALIAS_START = 67,	/* Uses struct acpi_ivrs_device8a */
+	ACPI_IVRS_TYPE_EXT_SELECT = 70,	/* Uses struct acpi_ivrs_device8b */
+	ACPI_IVRS_TYPE_EXT_START = 71,	/* Uses struct acpi_ivrs_device8b */
+	ACPI_IVRS_TYPE_SPECIAL = 72	/* Uses struct acpi_ivrs_device8c */
+};
+
+/* Values for Data field above */
+
+#define ACPI_IVHD_INIT_PASS         (1)
+#define ACPI_IVHD_EINT_PASS         (1<<1)
+#define ACPI_IVHD_NMI_PASS          (1<<2)
+#define ACPI_IVHD_SYSTEM_MGMT       (3<<4)
+#define ACPI_IVHD_LINT0_PASS        (1<<6)
+#define ACPI_IVHD_LINT1_PASS        (1<<7)
+
+/* Types 0-4: 4-byte device entry */
+
+struct acpi_ivrs_device4 {
+	struct acpi_ivrs_de_header header;
+};
+
+/* Types 66-67: 8-byte device entry */
+
+struct acpi_ivrs_device8a {
+	struct acpi_ivrs_de_header header;
+	u8 reserved1;
+	u16 used_id;
+	u8 reserved2;
+};
+
+/* Types 70-71: 8-byte device entry */
+
+struct acpi_ivrs_device8b {
+	struct acpi_ivrs_de_header header;
+	u32 extended_data;
+};
+
+/* Values for extended_data above */
+
+#define ACPI_IVHD_ATS_DISABLED      (1<<31)
+
+/* Type 72: 8-byte device entry */
+
+struct acpi_ivrs_device8c {
+	struct acpi_ivrs_de_header header;
+	u8 handle;
+	u16 used_id;
+	u8 variety;
+};
+
+/* Values for Variety field above */
+
+#define ACPI_IVHD_IOAPIC            1
+#define ACPI_IVHD_HPET              2
+
+/* 0x20, 0x21, 0x22: I/O Virtualization Memory Definition Block (IVMD) */
+
+struct acpi_ivrs_memory {
+	struct acpi_ivrs_header header;
+	u16 aux_data;
+	u64 reserved;
+	u64 start_address;
+	u64 memory_length;
+};
+
+/*******************************************************************************
+ *
+ * MCFG - PCI Memory Mapped Configuration table and sub-table
+ *        Version 1
+ *
+ * Conforms to "PCI Firmware Specification", Revision 3.0, June 20, 2005
+ *
+ ******************************************************************************/
+
+struct acpi_table_mcfg {
+	struct acpi_table_header header;	/* Common ACPI table header */
+	u8 reserved[8];
+};
+
+/* Subtable */
+
+struct acpi_mcfg_allocation {
+	u64 address;		/* Base address, processor-relative */
+	u16 pci_segment;	/* PCI segment group number */
+	u8 start_bus_number;	/* Starting PCI Bus number */
+	u8 end_bus_number;	/* Final PCI Bus number */
+	u32 reserved;
+};
+
+/*******************************************************************************
+ *
+ * MCHI - Management Controller Host Interface Table
+ *        Version 1
+ *
+ * Conforms to "Management Component Transport Protocol (MCTP) Host
+ * Interface Specification", Revision 1.0.0a, October 13, 2009
+ *
+ ******************************************************************************/
+
+struct acpi_table_mchi {
+	struct acpi_table_header header;	/* Common ACPI table header */
+	u8 interface_type;
+	u8 protocol;
+	u64 protocol_data;
+	u8 interrupt_type;
+	u8 gpe;
+	u8 pci_device_flag;
+	u32 global_interrupt;
+	struct acpi_generic_address control_register;
+	u8 pci_segment;
+	u8 pci_bus;
+	u8 pci_device;
+	u8 pci_function;
+};
+
+/*******************************************************************************
+ *
+ * SLIC - Software Licensing Description Table
+ *        Version 1
+ *
+ * Conforms to "OEM Activation 2.0 for Windows Vista Operating Systems",
+ * Copyright 2006
+ *
+ ******************************************************************************/
+
+/* Basic SLIC table is only the common ACPI header */
+
+struct acpi_table_slic {
+	struct acpi_table_header header;	/* Common ACPI table header */
+};
+
+/* Common SLIC subtable header */
+
+struct acpi_slic_header {
+	u32 type;
+	u32 length;
+};
+
+/* Values for Type field above */
+
+enum acpi_slic_type {
+	ACPI_SLIC_TYPE_PUBLIC_KEY = 0,
+	ACPI_SLIC_TYPE_WINDOWS_MARKER = 1,
+	ACPI_SLIC_TYPE_RESERVED = 2	/* 2 and greater are reserved */
+};
+
+/*
+ * SLIC Sub-tables, correspond to Type in struct acpi_slic_header
+ */
+
+/* 0: Public Key Structure */
+
+struct acpi_slic_key {
+	struct acpi_slic_header header;
+	u8 key_type;
+	u8 version;
+	u16 reserved;
+	u32 algorithm;
+	char magic[4];
+	u32 bit_length;
+	u32 exponent;
+	u8 modulus[128];
+};
+
+/* 1: Windows Marker Structure */
+
+struct acpi_slic_marker {
+	struct acpi_slic_header header;
+	u32 version;
+	char oem_id[ACPI_OEM_ID_SIZE];	/* ASCII OEM identification */
+	char oem_table_id[ACPI_OEM_TABLE_ID_SIZE];	/* ASCII OEM table identification */
+	char windows_flag[8];
+	u32 slic_version;
+	u8 reserved[16];
+	u8 signature[128];
+};
+
+/*******************************************************************************
+ *
+ * SPCR - Serial Port Console Redirection table
+ *        Version 1
+ *
+ * Conforms to "Serial Port Console Redirection Table",
+ * Version 1.00, January 11, 2002
+ *
+ ******************************************************************************/
+
+struct acpi_table_spcr {
+	struct acpi_table_header header;	/* Common ACPI table header */
+	u8 interface_type;	/* 0=full 16550, 1=subset of 16550 */
+	u8 reserved[3];
+	struct acpi_generic_address serial_port;
+	u8 interrupt_type;
+	u8 pc_interrupt;
+	u32 interrupt;
+	u8 baud_rate;
+	u8 parity;
+	u8 stop_bits;
+	u8 flow_control;
+	u8 terminal_type;
+	u8 reserved1;
+	u16 pci_device_id;
+	u16 pci_vendor_id;
+	u8 pci_bus;
+	u8 pci_device;
+	u8 pci_function;
+	u32 pci_flags;
+	u8 pci_segment;
+	u32 reserved2;
+};
+
+/* Masks for pci_flags field above */
+
+#define ACPI_SPCR_DO_NOT_DISABLE    (1)
+
+/*******************************************************************************
+ *
+ * SPMI - Server Platform Management Interface table
+ *        Version 5
+ *
+ * Conforms to "Intelligent Platform Management Interface Specification
+ * Second Generation v2.0", Document Revision 1.0, February 12, 2004 with
+ * June 12, 2009 markup.
+ *
+ ******************************************************************************/
+
+struct acpi_table_spmi {
+	struct acpi_table_header header;	/* Common ACPI table header */
+	u8 interface_type;
+	u8 reserved;		/* Must be 1 */
+	u16 spec_revision;	/* Version of IPMI */
+	u8 interrupt_type;
+	u8 gpe_number;		/* GPE assigned */
+	u8 reserved1;
+	u8 pci_device_flag;
+	u32 interrupt;
+	struct acpi_generic_address ipmi_register;
+	u8 pci_segment;
+	u8 pci_bus;
+	u8 pci_device;
+	u8 pci_function;
+	u8 reserved2;
+};
+
+/* Values for interface_type above */
+
+enum acpi_spmi_interface_types {
+	ACPI_SPMI_NOT_USED = 0,
+	ACPI_SPMI_KEYBOARD = 1,
+	ACPI_SPMI_SMI = 2,
+	ACPI_SPMI_BLOCK_TRANSFER = 3,
+	ACPI_SPMI_SMBUS = 4,
+	ACPI_SPMI_RESERVED = 5	/* 5 and above are reserved */
+};
+
+/*******************************************************************************
+ *
+ * TCPA - Trusted Computing Platform Alliance table
+ *        Version 1
+ *
+ * Conforms to "TCG PC Specific Implementation Specification",
+ * Version 1.1, August 18, 2003
+ *
+ ******************************************************************************/
+
+struct acpi_table_tcpa {
+	struct acpi_table_header header;	/* Common ACPI table header */
+	u16 reserved;
+	u32 max_log_length;	/* Maximum length for the event log area */
+	u64 log_address;	/* Address of the event log area */
+};
+
+/*******************************************************************************
+ *
+ * UEFI - UEFI Boot optimization Table
+ *        Version 1
+ *
+ * Conforms to "Unified Extensible Firmware Interface Specification",
+ * Version 2.3, May 8, 2009
+ *
+ ******************************************************************************/
+
+struct acpi_table_uefi {
+	struct acpi_table_header header;	/* Common ACPI table header */
+	u8 identifier[16];	/* UUID identifier */
+	u16 data_offset;	/* Offset of remaining data in table */
+};
+
+/*******************************************************************************
+ *
+ * WAET - Windows ACPI Emulated devices Table
+ *        Version 1
+ *
+ * Conforms to "Windows ACPI Emulated Devices Table", version 1.0, April 6, 2009
+ *
+ ******************************************************************************/
+
+struct acpi_table_waet {
+	struct acpi_table_header header;	/* Common ACPI table header */
+	u32 flags;
+};
+
+/* Masks for Flags field above */
+
+#define ACPI_WAET_RTC_NO_ACK        (1)	/* RTC requires no int acknowledge */
+#define ACPI_WAET_TIMER_ONE_READ    (1<<1)	/* PM timer requires only one read */
+
+/*******************************************************************************
+ *
+ * WDAT - Watchdog Action Table
+ *        Version 1
+ *
+ * Conforms to "Hardware Watchdog Timers Design Specification",
+ * Copyright 2006 Microsoft Corporation.
+ *
+ ******************************************************************************/
+
+struct acpi_table_wdat {
+	struct acpi_table_header header;	/* Common ACPI table header */
+	u32 header_length;	/* Watchdog Header Length */
+	u16 pci_segment;	/* PCI Segment number */
+	u8 pci_bus;		/* PCI Bus number */
+	u8 pci_device;		/* PCI Device number */
+	u8 pci_function;	/* PCI Function number */
+	u8 reserved[3];
+	u32 timer_period;	/* Period of one timer count (msec) */
+	u32 max_count;		/* Maximum counter value supported */
+	u32 min_count;		/* Minimum counter value */
+	u8 flags;
+	u8 reserved2[3];
+	u32 entries;		/* Number of watchdog entries that follow */
+};
+
+/* Masks for Flags field above */
+
+#define ACPI_WDAT_ENABLED           (1)
+#define ACPI_WDAT_STOPPED           0x80
+
+/* WDAT Instruction Entries (actions) */
+
+struct acpi_wdat_entry {
+	u8 action;
+	u8 instruction;
+	u16 reserved;
+	struct acpi_generic_address register_region;
+	u32 value;		/* Value used with Read/Write register */
+	u32 mask;		/* Bitmask required for this register instruction */
+};
+
+/* Values for Action field above */
+
+enum acpi_wdat_actions {
+	ACPI_WDAT_RESET = 1,
+	ACPI_WDAT_GET_CURRENT_COUNTDOWN = 4,
+	ACPI_WDAT_GET_COUNTDOWN = 5,
+	ACPI_WDAT_SET_COUNTDOWN = 6,
+	ACPI_WDAT_GET_RUNNING_STATE = 8,
+	ACPI_WDAT_SET_RUNNING_STATE = 9,
+	ACPI_WDAT_GET_STOPPED_STATE = 10,
+	ACPI_WDAT_SET_STOPPED_STATE = 11,
+	ACPI_WDAT_GET_REBOOT = 16,
+	ACPI_WDAT_SET_REBOOT = 17,
+	ACPI_WDAT_GET_SHUTDOWN = 18,
+	ACPI_WDAT_SET_SHUTDOWN = 19,
+	ACPI_WDAT_GET_STATUS = 32,
+	ACPI_WDAT_SET_STATUS = 33,
+	ACPI_WDAT_ACTION_RESERVED = 34	/* 34 and greater are reserved */
+};
+
+/* Values for Instruction field above */
+
+enum acpi_wdat_instructions {
+	ACPI_WDAT_READ_VALUE = 0,
+	ACPI_WDAT_READ_COUNTDOWN = 1,
+	ACPI_WDAT_WRITE_VALUE = 2,
+	ACPI_WDAT_WRITE_COUNTDOWN = 3,
+	ACPI_WDAT_INSTRUCTION_RESERVED = 4,	/* 4 and greater are reserved */
+	ACPI_WDAT_PRESERVE_REGISTER = 0x80	/* Except for this value */
+};
+
+/*******************************************************************************
+ *
+ * WDDT - Watchdog Descriptor Table
+ *        Version 1
+ *
+ * Conforms to "Using the Intel ICH Family Watchdog Timer (WDT)",
+ * Version 001, September 2002
+ *
+ ******************************************************************************/
+
+struct acpi_table_wddt {
+	struct acpi_table_header header;	/* Common ACPI table header */
+	u16 spec_version;
+	u16 table_version;
+	u16 pci_vendor_id;
+	struct acpi_generic_address address;
+	u16 max_count;		/* Maximum counter value supported */
+	u16 min_count;		/* Minimum counter value supported */
+	u16 period;
+	u16 status;
+	u16 capability;
+};
+
+/* Flags for Status field above */
+
+#define ACPI_WDDT_AVAILABLE     (1)
+#define ACPI_WDDT_ACTIVE        (1<<1)
+#define ACPI_WDDT_TCO_OS_OWNED  (1<<2)
+#define ACPI_WDDT_USER_RESET    (1<<11)
+#define ACPI_WDDT_WDT_RESET     (1<<12)
+#define ACPI_WDDT_POWER_FAIL    (1<<13)
+#define ACPI_WDDT_UNKNOWN_RESET (1<<14)
+
+/* Flags for Capability field above */
+
+#define ACPI_WDDT_AUTO_RESET    (1)
+#define ACPI_WDDT_ALERT_SUPPORT (1<<1)
+
+/*******************************************************************************
+ *
+ * WDRT - Watchdog Resource Table
+ *        Version 1
+ *
+ * Conforms to "Watchdog Timer Hardware Requirements for Windows Server 2003",
+ * Version 1.01, August 28, 2006
+ *
+ ******************************************************************************/
+
+struct acpi_table_wdrt {
+	struct acpi_table_header header;	/* Common ACPI table header */
+	struct acpi_generic_address control_register;
+	struct acpi_generic_address count_register;
+	u16 pci_device_id;
+	u16 pci_vendor_id;
+	u8 pci_bus;		/* PCI Bus number */
+	u8 pci_device;		/* PCI Device number */
+	u8 pci_function;	/* PCI Function number */
+	u8 pci_segment;		/* PCI Segment number */
+	u16 max_count;		/* Maximum counter value supported */
+	u8 units;
+};
+
+/* Reset to default packing */
+
+#pragma pack()
+
+#endif				/* __ACTBL2_H__ */
diff --git a/com32/acpioff/acpica_linuxized/include/acpi/actbl3.h b/com32/acpioff/acpica_linuxized/include/acpi/actbl3.h
new file mode 100644
index 00000000..f65a0ed8
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/include/acpi/actbl3.h
@@ -0,0 +1,552 @@
+/******************************************************************************
+ *
+ * Name: actbl3.h - ACPI Table Definitions
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACTBL3_H__
+#define __ACTBL3_H__
+
+/*******************************************************************************
+ *
+ * Additional ACPI Tables (3)
+ *
+ * These tables are not consumed directly by the ACPICA subsystem, but are
+ * included here to support device drivers and the AML disassembler.
+ *
+ * The tables in this file are fully defined within the ACPI specification.
+ *
+ ******************************************************************************/
+
+/*
+ * Values for description table header signatures for tables defined in this
+ * file. Useful because they make it more difficult to inadvertently type in
+ * the wrong signature.
+ */
+#define ACPI_SIG_BGRT           "BGRT"	/* Boot Graphics Resource Table */
+#define ACPI_SIG_DRTM           "DRTM"	/* Dynamic Root of Trust for Measurement table */
+#define ACPI_SIG_FPDT           "FPDT"	/* Firmware Performance Data Table */
+#define ACPI_SIG_GTDT           "GTDT"	/* Generic Timer Description Table */
+#define ACPI_SIG_MPST           "MPST"	/* Memory Power State Table */
+#define ACPI_SIG_PCCT           "PCCT"	/* Platform Communications Channel Table */
+#define ACPI_SIG_PMTT           "PMTT"	/* Platform Memory Topology Table */
+#define ACPI_SIG_RASF           "RASF"	/* RAS Feature table */
+
+#define ACPI_SIG_S3PT           "S3PT"	/* S3 Performance (sub)Table */
+#define ACPI_SIG_PCCS           "PCC"	/* PCC Shared Memory Region */
+
+/* Reserved table signatures */
+
+#define ACPI_SIG_CSRT           "CSRT"	/* Core System Resources Table */
+#define ACPI_SIG_DBG2           "DBG2"	/* Debug Port table 2 */
+#define ACPI_SIG_MATR           "MATR"	/* Memory Address Translation Table */
+#define ACPI_SIG_MSDM           "MSDM"	/* Microsoft Data Management Table */
+#define ACPI_SIG_WPBT           "WPBT"	/* Windows Platform Binary Table */
+
+/*
+ * All tables must be byte-packed to match the ACPI specification, since
+ * the tables are provided by the system BIOS.
+ */
+#pragma pack(1)
+
+/*
+ * Note about bitfields: The u8 type is used for bitfields in ACPI tables.
+ * This is the only type that is even remotely portable. Anything else is not
+ * portable, so do not use any other bitfield types.
+ */
+
+/*******************************************************************************
+ *
+ * BGRT - Boot Graphics Resource Table (ACPI 5.0)
+ *        Version 1
+ *
+ ******************************************************************************/
+
+struct acpi_table_bgrt {
+	struct acpi_table_header header;	/* Common ACPI table header */
+	u16 version;
+	u8 status;
+	u8 image_type;
+	u64 image_address;
+	u32 image_offset_x;
+	u32 image_offset_y;
+};
+
+/*******************************************************************************
+ *
+ * DRTM - Dynamic Root of Trust for Measurement table
+ *
+ ******************************************************************************/
+
+struct acpi_table_drtm {
+	struct acpi_table_header header;	/* Common ACPI table header */
+	u64 entry_base_address;
+	u64 entry_length;
+	u32 entry_address32;
+	u64 entry_address64;
+	u64 exit_address;
+	u64 log_area_address;
+	u32 log_area_length;
+	u64 arch_dependent_address;
+	u32 flags;
+};
+
+/* 1) Validated Tables List */
+
+struct acpi_drtm_vtl_list {
+	u32 validated_table_list_count;
+};
+
+/* 2) Resources List */
+
+struct acpi_drtm_resource_list {
+	u32 resource_list_count;
+};
+
+/* 3) Platform-specific Identifiers List */
+
+struct acpi_drtm_id_list {
+	u32 id_list_count;
+};
+
+/*******************************************************************************
+ *
+ * FPDT - Firmware Performance Data Table (ACPI 5.0)
+ *        Version 1
+ *
+ ******************************************************************************/
+
+struct acpi_table_fpdt {
+	struct acpi_table_header header;	/* Common ACPI table header */
+};
+
+/* FPDT subtable header */
+
+struct acpi_fpdt_header {
+	u16 type;
+	u8 length;
+	u8 revision;
+};
+
+/* Values for Type field above */
+
+enum acpi_fpdt_type {
+	ACPI_FPDT_TYPE_BOOT = 0,
+	ACPI_FPDT_TYPE_S3PERF = 1,
+};
+
+/*
+ * FPDT subtables
+ */
+
+/* 0: Firmware Basic Boot Performance Record */
+
+struct acpi_fpdt_boot {
+	struct acpi_fpdt_header header;
+	u8 reserved[4];
+	u64 reset_end;
+	u64 load_start;
+	u64 startup_start;
+	u64 exit_services_entry;
+	u64 exit_services_exit;
+};
+
+/* 1: S3 Performance Table Pointer Record */
+
+struct acpi_fpdt_s3pt_ptr {
+	struct acpi_fpdt_header header;
+	u8 reserved[4];
+	u64 address;
+};
+
+/*
+ * S3PT - S3 Performance Table. This table is pointed to by the
+ * FPDT S3 Pointer Record above.
+ */
+struct acpi_table_s3pt {
+	u8 signature[4];	/* "S3PT" */
+	u32 length;
+};
+
+/*
+ * S3PT Subtables
+ */
+struct acpi_s3pt_header {
+	u16 type;
+	u8 length;
+	u8 revision;
+};
+
+/* Values for Type field above */
+
+enum acpi_s3pt_type {
+	ACPI_S3PT_TYPE_RESUME = 0,
+	ACPI_S3PT_TYPE_SUSPEND = 1,
+};
+
+struct acpi_s3pt_resume {
+	struct acpi_s3pt_header header;
+	u32 resume_count;
+	u64 full_resume;
+	u64 average_resume;
+};
+
+struct acpi_s3pt_suspend {
+	struct acpi_s3pt_header header;
+	u64 suspend_start;
+	u64 suspend_end;
+};
+
+/*******************************************************************************
+ *
+ * GTDT - Generic Timer Description Table (ACPI 5.0)
+ *        Version 1
+ *
+ ******************************************************************************/
+
+struct acpi_table_gtdt {
+	struct acpi_table_header header;	/* Common ACPI table header */
+	u64 address;
+	u32 flags;
+	u32 secure_pl1_interrupt;
+	u32 secure_pl1_flags;
+	u32 non_secure_pl1_interrupt;
+	u32 non_secure_pl1_flags;
+	u32 virtual_timer_interrupt;
+	u32 virtual_timer_flags;
+	u32 non_secure_pl2_interrupt;
+	u32 non_secure_pl2_flags;
+};
+
+/* Values for Flags field above */
+
+#define ACPI_GTDT_MAPPED_BLOCK_PRESENT      1
+
+/* Values for all "TimerFlags" fields above */
+
+#define ACPI_GTDT_INTERRUPT_MODE            1
+#define ACPI_GTDT_INTERRUPT_POLARITY        2
+
+/*******************************************************************************
+ *
+ * MPST - Memory Power State Table (ACPI 5.0)
+ *        Version 1
+ *
+ ******************************************************************************/
+
+#define ACPI_MPST_CHANNEL_INFO \
+	u16                             reserved1; \
+	u8                              channel_id; \
+	u8                              reserved2; \
+	u16                             power_node_count;
+
+/* Main table */
+
+struct acpi_table_mpst {
+	struct acpi_table_header header;	/* Common ACPI table header */
+	 ACPI_MPST_CHANNEL_INFO	/* Platform Communication Channel */
+};
+
+/* Memory Platform Communication Channel Info */
+
+struct acpi_mpst_channel {
+	ACPI_MPST_CHANNEL_INFO	/* Platform Communication Channel */
+};
+
+/* Memory Power Node Structure */
+
+struct acpi_mpst_power_node {
+	u8 flags;
+	u8 reserved1;
+	u16 node_id;
+	u32 length;
+	u64 range_address;
+	u64 range_length;
+	u8 num_power_states;
+	u8 num_physical_components;
+	u16 reserved2;
+};
+
+/* Values for Flags field above */
+
+#define ACPI_MPST_ENABLED               1
+#define ACPI_MPST_POWER_MANAGED         2
+#define ACPI_MPST_HOT_PLUG_CAPABLE      4
+
+/* Memory Power State Structure (follows POWER_NODE above) */
+
+struct acpi_mpst_power_state {
+	u8 power_state;
+	u8 info_index;
+};
+
+/* Physical Component ID Structure (follows POWER_STATE above) */
+
+struct acpi_mpst_component {
+	u16 component_id;
+};
+
+/* Memory Power State Characteristics Structure (follows all POWER_NODEs) */
+
+struct acpi_mpst_data_hdr {
+	u16 characteristics_count;
+};
+
+struct acpi_mpst_power_data {
+	u8 revision;
+	u8 flags;
+	u16 reserved1;
+	u32 average_power;
+	u32 power_saving;
+	u64 exit_latency;
+	u64 reserved2;
+};
+
+/* Values for Flags field above */
+
+#define ACPI_MPST_PRESERVE              1
+#define ACPI_MPST_AUTOENTRY             2
+#define ACPI_MPST_AUTOEXIT              4
+
+/* Shared Memory Region (not part of an ACPI table) */
+
+struct acpi_mpst_shared {
+	u32 signature;
+	u16 pcc_command;
+	u16 pcc_status;
+	u16 command_register;
+	u16 status_register;
+	u16 power_state_id;
+	u16 power_node_id;
+	u64 energy_consumed;
+	u64 average_power;
+};
+
+/*******************************************************************************
+ *
+ * PCCT - Platform Communications Channel Table (ACPI 5.0)
+ *        Version 1
+ *
+ ******************************************************************************/
+
+struct acpi_table_pcct {
+	struct acpi_table_header header;	/* Common ACPI table header */
+	u32 flags;
+	u32 latency;
+	u32 reserved;
+};
+
+/* Values for Flags field above */
+
+#define ACPI_PCCT_DOORBELL              1
+
+/*
+ * PCCT subtables
+ */
+
+/* 0: Generic Communications Subspace */
+
+struct acpi_pcct_subspace {
+	struct acpi_subtable_header header;
+	u8 reserved[6];
+	u64 base_address;
+	u64 length;
+	struct acpi_generic_address doorbell_register;
+	u64 preserve_mask;
+	u64 write_mask;
+};
+
+/*
+ * PCC memory structures (not part of the ACPI table)
+ */
+
+/* Shared Memory Region */
+
+struct acpi_pcct_shared_memory {
+	u32 signature;
+	u16 command;
+	u16 status;
+};
+
+/*******************************************************************************
+ *
+ * PMTT - Platform Memory Topology Table (ACPI 5.0)
+ *        Version 1
+ *
+ ******************************************************************************/
+
+struct acpi_table_pmtt {
+	struct acpi_table_header header;	/* Common ACPI table header */
+	u32 reserved;
+};
+
+/* Common header for PMTT subtables that follow main table */
+
+struct acpi_pmtt_header {
+	u8 type;
+	u8 reserved1;
+	u16 length;
+	u16 flags;
+	u16 reserved2;
+};
+
+/* Values for Type field above */
+
+#define ACPI_PMTT_TYPE_SOCKET           0
+#define ACPI_PMTT_TYPE_CONTROLLER       1
+#define ACPI_PMTT_TYPE_DIMM             2
+#define ACPI_PMTT_TYPE_RESERVED         3	/* 0x03-0xFF are reserved */
+
+/* Values for Flags field above */
+
+#define ACPI_PMTT_TOP_LEVEL             0x0001
+#define ACPI_PMTT_PHYSICAL              0x0002
+#define ACPI_PMTT_MEMORY_TYPE           0x000C
+
+/*
+ * PMTT subtables, correspond to Type in struct acpi_pmtt_header
+ */
+
+/* 0: Socket Structure */
+
+struct acpi_pmtt_socket {
+	struct acpi_pmtt_header header;
+	u16 socket_id;
+	u16 reserved;
+};
+
+/* 1: Memory Controller subtable */
+
+struct acpi_pmtt_controller {
+	struct acpi_pmtt_header header;
+	u32 read_latency;
+	u32 write_latency;
+	u32 read_bandwidth;
+	u32 write_bandwidth;
+	u16 access_width;
+	u16 alignment;
+	u16 reserved;
+	u16 domain_count;
+};
+
+/* 1a: Proximity Domain substructure */
+
+struct acpi_pmtt_domain {
+	u32 proximity_domain;
+};
+
+/* 2: Physical Component Identifier (DIMM) */
+
+struct acpi_pmtt_physical_component {
+	struct acpi_pmtt_header header;
+	u16 component_id;
+	u16 reserved;
+	u32 memory_size;
+	u32 bios_handle;
+};
+
+/*******************************************************************************
+ *
+ * RASF - RAS Feature Table (ACPI 5.0)
+ *        Version 1
+ *
+ ******************************************************************************/
+
+struct acpi_table_rasf {
+	struct acpi_table_header header;	/* Common ACPI table header */
+	u8 channel_id[12];
+};
+
+/* RASF Platform Communication Channel Shared Memory Region */
+
+struct acpi_rasf_shared_memory {
+	u32 signature;
+	u16 command;
+	u16 status;
+	u64 requested_address;
+	u64 requested_length;
+	u64 actual_address;
+	u64 actual_length;
+	u16 flags;
+	u8 speed;
+};
+
+/* Masks for Flags and Speed fields above */
+
+#define ACPI_RASF_SCRUBBER_RUNNING      1
+#define ACPI_RASF_SPEED                 (7<<1)
+
+/* Channel Commands */
+
+enum acpi_rasf_commands {
+	ACPI_RASF_GET_RAS_CAPABILITIES = 1,
+	ACPI_RASF_GET_PATROL_PARAMETERS = 2,
+	ACPI_RASF_START_PATROL_SCRUBBER = 3,
+	ACPI_RASF_STOP_PATROL_SCRUBBER = 4
+};
+
+/* Channel Command flags */
+
+#define ACPI_RASF_GENERATE_SCI          (1<<15)
+
+/* Status values */
+
+enum acpi_rasf_status {
+	ACPI_RASF_SUCCESS = 0,
+	ACPI_RASF_NOT_VALID = 1,
+	ACPI_RASF_NOT_SUPPORTED = 2,
+	ACPI_RASF_BUSY = 3,
+	ACPI_RASF_FAILED = 4,
+	ACPI_RASF_ABORTED = 5,
+	ACPI_RASF_INVALID_DATA = 6
+};
+
+/* Status flags */
+
+#define ACPI_RASF_COMMAND_COMPLETE      (1)
+#define ACPI_RASF_SCI_DOORBELL          (1<<1)
+#define ACPI_RASF_ERROR                 (1<<2)
+#define ACPI_RASF_STATUS                (0x1F<<3)
+
+/* Reset to default packing */
+
+#pragma pack()
+
+#endif				/* __ACTBL3_H__ */
diff --git a/com32/acpioff/acpica_linuxized/include/acpi/actypes.h b/com32/acpioff/acpica_linuxized/include/acpi/actypes.h
new file mode 100644
index 00000000..1752c031
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/include/acpi/actypes.h
@@ -0,0 +1,1105 @@
+/******************************************************************************
+ *
+ * Name: actypes.h - Common data types for the entire ACPI subsystem
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACTYPES_H__
+#define __ACTYPES_H__
+
+/* acpisrc:struct_defs -- for acpisrc conversion */
+
+/*
+ * ACPI_MACHINE_WIDTH must be specified in an OS- or compiler-dependent header
+ * and must be either 32 or 64. 16-bit ACPICA is no longer supported, as of
+ * 12/2006.
+ */
+#ifndef ACPI_MACHINE_WIDTH
+#error ACPI_MACHINE_WIDTH not defined
+#endif
+
+/*! [Begin] no source code translation */
+
+/*
+ * Data type ranges
+ * Note: These macros are designed to be compiler independent as well as
+ * working around problems that some 32-bit compilers have with 64-bit
+ * constants.
+ */
+#define ACPI_UINT8_MAX                  (UINT8) (~((UINT8)  0))	/* 0xFF               */
+#define ACPI_UINT16_MAX                 (UINT16)(~((UINT16) 0))	/* 0xFFFF             */
+#define ACPI_UINT32_MAX                 (UINT32)(~((UINT32) 0))	/* 0xFFFFFFFF         */
+#define ACPI_UINT64_MAX                 (UINT64)(~((UINT64) 0))	/* 0xFFFFFFFFFFFFFFFF */
+#define ACPI_ASCII_MAX                  0x7F
+
+/*
+ * Architecture-specific ACPICA Subsystem Data Types
+ *
+ * The goal of these types is to provide source code portability across
+ * 16-bit, 32-bit, and 64-bit targets.
+ *
+ * 1) The following types are of fixed size for all targets (16/32/64):
+ *
+ * BOOLEAN      Logical boolean
+ *
+ * UINT8        8-bit  (1 byte) unsigned value
+ * UINT16       16-bit (2 byte) unsigned value
+ * UINT32       32-bit (4 byte) unsigned value
+ * UINT64       64-bit (8 byte) unsigned value
+ *
+ * INT16        16-bit (2 byte) signed value
+ * INT32        32-bit (4 byte) signed value
+ * INT64        64-bit (8 byte) signed value
+ *
+ * COMPILER_DEPENDENT_UINT64/INT64 - These types are defined in the
+ * compiler-dependent header(s) and were introduced because there is no common
+ * 64-bit integer type across the various compilation models, as shown in
+ * the table below.
+ *
+ * Datatype  LP64 ILP64 LLP64 ILP32 LP32 16bit
+ * char      8    8     8     8     8    8
+ * short     16   16    16    16    16   16
+ * _int32         32
+ * int       32   64    32    32    16   16
+ * long      64   64    32    32    32   32
+ * long long            64    64
+ * pointer   64   64    64    32    32   32
+ *
+ * Note: ILP64 and LP32 are currently not supported.
+ *
+ *
+ * 2) These types represent the native word size of the target mode of the
+ * processor, and may be 16-bit, 32-bit, or 64-bit as required. They are
+ * usually used for memory allocation, efficient loop counters, and array
+ * indexes. The types are similar to the size_t type in the C library and are
+ * required because there is no C type that consistently represents the native
+ * data width. ACPI_SIZE is needed because there is no guarantee that a
+ * kernel-level C library is present.
+ *
+ * ACPI_SIZE        16/32/64-bit unsigned value
+ * ACPI_NATIVE_INT  16/32/64-bit signed value
+ */
+
+/*******************************************************************************
+ *
+ * Common types for all compilers, all targets
+ *
+ ******************************************************************************/
+
+typedef unsigned char BOOLEAN;
+typedef unsigned char UINT8;
+typedef unsigned short UINT16;
+typedef COMPILER_DEPENDENT_UINT64 UINT64;
+typedef COMPILER_DEPENDENT_INT64 INT64;
+
+/*! [End] no source code translation !*/
+
+/*
+ * Value returned by acpi_os_get_thread_id. There is no standard "thread_id"
+ * across operating systems or even the various UNIX systems. Since ACPICA
+ * only needs the thread ID as a unique thread identifier, we use a u64
+ * as the only common data type - it will accommodate any type of pointer or
+ * any type of integer. It is up to the host-dependent OSL to cast the
+ * native thread ID type to a u64 (in acpi_os_get_thread_id).
+ */
+#define acpi_thread_id                  u64
+
+/*******************************************************************************
+ *
+ * Types specific to 64-bit targets
+ *
+ ******************************************************************************/
+
+#if ACPI_MACHINE_WIDTH == 64
+
+/*! [Begin] no source code translation (keep the typedefs as-is) */
+
+typedef unsigned int UINT32;
+typedef int INT32;
+
+/*! [End] no source code translation !*/
+
+typedef s64 acpi_native_int;
+typedef u64 acpi_size;
+typedef u64 acpi_io_address;
+typedef u64 acpi_physical_address;
+
+#define ACPI_MAX_PTR                    ACPI_UINT64_MAX
+#define ACPI_SIZE_MAX                   ACPI_UINT64_MAX
+#define ACPI_USE_NATIVE_DIVIDE	/* Has native 64-bit integer support */
+
+/*
+ * In the case of the Itanium Processor Family (IPF), the hardware does not
+ * support misaligned memory transfers. Set the MISALIGNMENT_NOT_SUPPORTED flag
+ * to indicate that special precautions must be taken to avoid alignment faults.
+ * (IA64 or ia64 is currently used by existing compilers to indicate IPF.)
+ *
+ * Note: Em64_t and other X86-64 processors support misaligned transfers,
+ * so there is no need to define this flag.
+ */
+#if defined (__IA64__) || defined (__ia64__)
+#define ACPI_MISALIGNMENT_NOT_SUPPORTED
+#endif
+
+/*******************************************************************************
+ *
+ * Types specific to 32-bit targets
+ *
+ ******************************************************************************/
+
+#elif ACPI_MACHINE_WIDTH == 32
+
+/*! [Begin] no source code translation (keep the typedefs as-is) */
+
+typedef unsigned int UINT32;
+typedef int INT32;
+
+/*! [End] no source code translation !*/
+
+typedef s32 acpi_native_int;
+typedef u32 acpi_size;
+typedef u32 acpi_io_address;
+typedef u32 acpi_physical_address;
+
+#define ACPI_MAX_PTR                    ACPI_UINT32_MAX
+#define ACPI_SIZE_MAX                   ACPI_UINT32_MAX
+
+#else
+
+/* ACPI_MACHINE_WIDTH must be either 64 or 32 */
+
+#error unknown ACPI_MACHINE_WIDTH
+#endif
+
+/*******************************************************************************
+ *
+ * OS-dependent types
+ *
+ * If the defaults below are not appropriate for the host system, they can
+ * be defined in the OS-specific header, and this will take precedence.
+ *
+ ******************************************************************************/
+
+/* Flags for acpi_os_acquire_lock/acpi_os_release_lock */
+
+#ifndef acpi_cpu_flags
+#define acpi_cpu_flags                  acpi_size
+#endif
+
+/* Object returned from acpi_os_create_cache */
+
+#ifndef acpi_cache_t
+#ifdef ACPI_USE_LOCAL_CACHE
+#define acpi_cache_t                    struct acpi_memory_list
+#else
+#define acpi_cache_t                    void *
+#endif
+#endif
+
+/*
+ * Synchronization objects - Mutexes, Semaphores, and spin_locks
+ */
+#if (ACPI_MUTEX_TYPE == ACPI_BINARY_SEMAPHORE)
+/*
+ * These macros are used if the host OS does not support a mutex object.
+ * Map the OSL Mutex interfaces to binary semaphores.
+ */
+#define acpi_mutex                      acpi_semaphore
+#define acpi_os_create_mutex(out_handle) acpi_os_create_semaphore (1, 1, out_handle)
+#define acpi_os_delete_mutex(handle)    (void) acpi_os_delete_semaphore (handle)
+#define acpi_os_acquire_mutex(handle,time) acpi_os_wait_semaphore (handle, 1, time)
+#define acpi_os_release_mutex(handle)   (void) acpi_os_signal_semaphore (handle, 1)
+#endif
+
+/* Configurable types for synchronization objects */
+
+#ifndef acpi_spinlock
+#define acpi_spinlock                   void *
+#endif
+
+#ifndef acpi_semaphore
+#define acpi_semaphore                  void *
+#endif
+
+#ifndef acpi_mutex
+#define acpi_mutex                      void *
+#endif
+
+/*******************************************************************************
+ *
+ * Compiler-dependent types
+ *
+ * If the defaults below are not appropriate for the host compiler, they can
+ * be defined in the compiler-specific header, and this will take precedence.
+ *
+ ******************************************************************************/
+
+/* Use C99 uintptr_t for pointer casting if available, "void *" otherwise */
+
+#ifndef acpi_uintptr_t
+#define acpi_uintptr_t                  void *
+#endif
+
+/*
+ * ACPI_PRINTF_LIKE is used to tag functions as "printf-like" because
+ * some compilers can catch printf format string problems
+ */
+#ifndef ACPI_PRINTF_LIKE
+#define ACPI_PRINTF_LIKE(c)
+#endif
+
+/*
+ * Some compilers complain about unused variables. Sometimes we don't want to
+ * use all the variables (for example, _acpi_module_name). This allows us
+ * to to tell the compiler in a per-variable manner that a variable
+ * is unused
+ */
+#ifndef ACPI_UNUSED_VAR
+#define ACPI_UNUSED_VAR
+#endif
+
+/*
+ * All ACPICA functions that are available to the rest of the kernel are
+ * tagged with this macro which can be defined as appropriate for the host.
+ */
+#ifndef ACPI_EXPORT_SYMBOL
+#define ACPI_EXPORT_SYMBOL(symbol)
+#endif
+
+/******************************************************************************
+ *
+ * ACPI Specification constants (Do not change unless the specification changes)
+ *
+ *****************************************************************************/
+
+/* Number of distinct FADT-based GPE register blocks (GPE0 and GPE1) */
+
+#define ACPI_MAX_GPE_BLOCKS             2
+
+/* Default ACPI register widths */
+
+#define ACPI_GPE_REGISTER_WIDTH         8
+#define ACPI_PM1_REGISTER_WIDTH         16
+#define ACPI_PM2_REGISTER_WIDTH         8
+#define ACPI_PM_TIMER_WIDTH             32
+
+/* Names within the namespace are 4 bytes long */
+
+#define ACPI_NAME_SIZE                  4
+#define ACPI_PATH_SEGMENT_LENGTH        5	/* 4 chars for name + 1 char for separator */
+#define ACPI_PATH_SEPARATOR             '.'
+
+/* Sizes for ACPI table headers */
+
+#define ACPI_OEM_ID_SIZE                6
+#define ACPI_OEM_TABLE_ID_SIZE          8
+
+/* ACPI/PNP hardware IDs */
+
+#define PCI_ROOT_HID_STRING             "PNP0A03"
+#define PCI_EXPRESS_ROOT_HID_STRING     "PNP0A08"
+
+/* PM Timer ticks per second (HZ) */
+
+#define PM_TIMER_FREQUENCY              3579545
+
+/*******************************************************************************
+ *
+ * Independent types
+ *
+ ******************************************************************************/
+
+/* Logical defines and NULL */
+
+#ifdef FALSE
+#undef FALSE
+#endif
+#define FALSE                           (1 == 0)
+
+#ifdef TRUE
+#undef TRUE
+#endif
+#define TRUE                            (1 == 1)
+
+#ifndef NULL
+#define NULL                            (void *) 0
+#endif
+
+/*
+ * Miscellaneous types
+ */
+typedef u32 acpi_status;	/* All ACPI Exceptions */
+typedef u32 acpi_name;		/* 4-byte ACPI name */
+typedef char *acpi_string;	/* Null terminated ASCII string */
+typedef void *acpi_handle;	/* Actually a ptr to a NS Node */
+
+/* Owner IDs are used to track namespace nodes for selective deletion */
+
+typedef u8 acpi_owner_id;
+#define ACPI_OWNER_ID_MAX               0xFF
+
+#define ACPI_INTEGER_BIT_SIZE           64
+#define ACPI_MAX_DECIMAL_DIGITS         20	/* 2^64 = 18,446,744,073,709,551,616 */
+#define ACPI_MAX64_DECIMAL_DIGITS       20
+#define ACPI_MAX32_DECIMAL_DIGITS       10
+#define ACPI_MAX16_DECIMAL_DIGITS        5
+#define ACPI_MAX8_DECIMAL_DIGITS         3
+
+/*
+ * Constants with special meanings
+ */
+#define ACPI_ROOT_OBJECT                ACPI_ADD_PTR (acpi_handle, NULL, ACPI_MAX_PTR)
+#define ACPI_WAIT_FOREVER               0xFFFF	/* u16, as per ACPI spec */
+#define ACPI_DO_NOT_WAIT                0
+
+/*
+ * Obsolete: Acpi integer width. In ACPI version 1 (1996), integers are 32 bits.
+ * In ACPI version 2 (2000) and later, integers are 64 bits. Note that this
+ * pertains to the ACPI integer type only, not to other integers used in the
+ * implementation of the ACPICA subsystem.
+ *
+ * 01/2010: This type is obsolete and has been removed from the entire ACPICA
+ * code base. It remains here for compatibility with device drivers that use
+ * the type. However, it will be removed in the future.
+ */
+typedef u64 acpi_integer;
+#define ACPI_INTEGER_MAX                ACPI_UINT64_MAX
+
+/*******************************************************************************
+ *
+ * Commonly used macros
+ *
+ ******************************************************************************/
+
+/* Data manipulation */
+
+#define ACPI_LOBYTE(integer)            ((u8)   (u16)(integer))
+#define ACPI_HIBYTE(integer)            ((u8) (((u16)(integer)) >> 8))
+#define ACPI_LOWORD(integer)            ((u16)  (u32)(integer))
+#define ACPI_HIWORD(integer)            ((u16)(((u32)(integer)) >> 16))
+#define ACPI_LODWORD(integer64)         ((u32)  (u64)(integer64))
+#define ACPI_HIDWORD(integer64)         ((u32)(((u64)(integer64)) >> 32))
+
+#define ACPI_SET_BIT(target,bit)        ((target) |= (bit))
+#define ACPI_CLEAR_BIT(target,bit)      ((target) &= ~(bit))
+#define ACPI_MIN(a,b)                   (((a)<(b))?(a):(b))
+#define ACPI_MAX(a,b)                   (((a)>(b))?(a):(b))
+
+/* Size calculation */
+
+#define ACPI_ARRAY_LENGTH(x)            (sizeof(x) / sizeof((x)[0]))
+
+/* Pointer manipulation */
+
+#define ACPI_CAST_PTR(t, p)             ((t *) (acpi_uintptr_t) (p))
+#define ACPI_CAST_INDIRECT_PTR(t, p)    ((t **) (acpi_uintptr_t) (p))
+#define ACPI_ADD_PTR(t, a, b)           ACPI_CAST_PTR (t, (ACPI_CAST_PTR (u8, (a)) + (acpi_size)(b)))
+#define ACPI_PTR_DIFF(a, b)             (acpi_size) (ACPI_CAST_PTR (u8, (a)) - ACPI_CAST_PTR (u8, (b)))
+
+/* Pointer/Integer type conversions */
+
+#define ACPI_TO_POINTER(i)              ACPI_ADD_PTR (void, (void *) NULL,(acpi_size) i)
+#define ACPI_TO_INTEGER(p)              ACPI_PTR_DIFF (p, (void *) NULL)
+#define ACPI_OFFSET(d, f)               (acpi_size) ACPI_PTR_DIFF (&(((d *)0)->f), (void *) NULL)
+#define ACPI_PHYSADDR_TO_PTR(i)         ACPI_TO_POINTER(i)
+#define ACPI_PTR_TO_PHYSADDR(i)         ACPI_TO_INTEGER(i)
+
+#ifndef ACPI_MISALIGNMENT_NOT_SUPPORTED
+#define ACPI_COMPARE_NAME(a,b)          (*ACPI_CAST_PTR (u32, (a)) == *ACPI_CAST_PTR (u32, (b)))
+#else
+#define ACPI_COMPARE_NAME(a,b)          (!ACPI_STRNCMP (ACPI_CAST_PTR (char, (a)), ACPI_CAST_PTR (char, (b)), ACPI_NAME_SIZE))
+#endif
+
+/*******************************************************************************
+ *
+ * Miscellaneous constants
+ *
+ ******************************************************************************/
+
+/*
+ * Initialization sequence
+ */
+#define ACPI_FULL_INITIALIZATION        0x00
+#define ACPI_NO_ADDRESS_SPACE_INIT      0x01
+#define ACPI_NO_HARDWARE_INIT           0x02
+#define ACPI_NO_EVENT_INIT              0x04
+#define ACPI_NO_HANDLER_INIT            0x08
+#define ACPI_NO_ACPI_ENABLE             0x10
+#define ACPI_NO_DEVICE_INIT             0x20
+#define ACPI_NO_OBJECT_INIT             0x40
+
+/*
+ * Initialization state
+ */
+#define ACPI_SUBSYSTEM_INITIALIZE       0x01
+#define ACPI_INITIALIZED_OK             0x02
+
+/*
+ * Power state values
+ */
+#define ACPI_STATE_UNKNOWN              (u8) 0xFF
+
+#define ACPI_STATE_S0                   (u8) 0
+#define ACPI_STATE_S1                   (u8) 1
+#define ACPI_STATE_S2                   (u8) 2
+#define ACPI_STATE_S3                   (u8) 3
+#define ACPI_STATE_S4                   (u8) 4
+#define ACPI_STATE_S5                   (u8) 5
+#define ACPI_S_STATES_MAX               ACPI_STATE_S5
+#define ACPI_S_STATE_COUNT              6
+
+#define ACPI_STATE_D0                   (u8) 0
+#define ACPI_STATE_D1                   (u8) 1
+#define ACPI_STATE_D2                   (u8) 2
+#define ACPI_STATE_D3                   (u8) 3
+#define ACPI_D_STATES_MAX               ACPI_STATE_D3
+#define ACPI_D_STATE_COUNT              4
+
+#define ACPI_STATE_C0                   (u8) 0
+#define ACPI_STATE_C1                   (u8) 1
+#define ACPI_STATE_C2                   (u8) 2
+#define ACPI_STATE_C3                   (u8) 3
+#define ACPI_C_STATES_MAX               ACPI_STATE_C3
+#define ACPI_C_STATE_COUNT              4
+
+/*
+ * Sleep type invalid value
+ */
+#define ACPI_SLEEP_TYPE_MAX             0x7
+#define ACPI_SLEEP_TYPE_INVALID         0xFF
+
+/*
+ * Standard notify values
+ */
+#define ACPI_NOTIFY_BUS_CHECK           (u8) 0x00
+#define ACPI_NOTIFY_DEVICE_CHECK        (u8) 0x01
+#define ACPI_NOTIFY_DEVICE_WAKE         (u8) 0x02
+#define ACPI_NOTIFY_EJECT_REQUEST       (u8) 0x03
+#define ACPI_NOTIFY_DEVICE_CHECK_LIGHT  (u8) 0x04
+#define ACPI_NOTIFY_FREQUENCY_MISMATCH  (u8) 0x05
+#define ACPI_NOTIFY_BUS_MODE_MISMATCH   (u8) 0x06
+#define ACPI_NOTIFY_POWER_FAULT         (u8) 0x07
+#define ACPI_NOTIFY_CAPABILITIES_CHECK  (u8) 0x08
+#define ACPI_NOTIFY_DEVICE_PLD_CHECK    (u8) 0x09
+#define ACPI_NOTIFY_RESERVED            (u8) 0x0A
+#define ACPI_NOTIFY_LOCALITY_UPDATE     (u8) 0x0B
+
+#define ACPI_NOTIFY_MAX                 0x0B
+
+/*
+ * Types associated with ACPI names and objects. The first group of
+ * values (up to ACPI_TYPE_EXTERNAL_MAX) correspond to the definition
+ * of the ACPI object_type() operator (See the ACPI Spec). Therefore,
+ * only add to the first group if the spec changes.
+ *
+ * NOTE: Types must be kept in sync with the global acpi_ns_properties
+ * and acpi_ns_type_names arrays.
+ */
+typedef u32 acpi_object_type;
+
+#define ACPI_TYPE_ANY                   0x00
+#define ACPI_TYPE_INTEGER               0x01	/* Byte/Word/Dword/Zero/One/Ones */
+#define ACPI_TYPE_STRING                0x02
+#define ACPI_TYPE_BUFFER                0x03
+#define ACPI_TYPE_PACKAGE               0x04	/* byte_const, multiple data_term/Constant/super_name */
+#define ACPI_TYPE_FIELD_UNIT            0x05
+#define ACPI_TYPE_DEVICE                0x06	/* Name, multiple Node */
+#define ACPI_TYPE_EVENT                 0x07
+#define ACPI_TYPE_METHOD                0x08	/* Name, byte_const, multiple Code */
+#define ACPI_TYPE_MUTEX                 0x09
+#define ACPI_TYPE_REGION                0x0A
+#define ACPI_TYPE_POWER                 0x0B	/* Name,byte_const,word_const,multi Node */
+#define ACPI_TYPE_PROCESSOR             0x0C	/* Name,byte_const,Dword_const,byte_const,multi nm_o */
+#define ACPI_TYPE_THERMAL               0x0D	/* Name, multiple Node */
+#define ACPI_TYPE_BUFFER_FIELD          0x0E
+#define ACPI_TYPE_DDB_HANDLE            0x0F
+#define ACPI_TYPE_DEBUG_OBJECT          0x10
+
+#define ACPI_TYPE_EXTERNAL_MAX          0x10
+
+/*
+ * These are object types that do not map directly to the ACPI
+ * object_type() operator. They are used for various internal purposes only.
+ * If new predefined ACPI_TYPEs are added (via the ACPI specification), these
+ * internal types must move upwards. (There is code that depends on these
+ * values being contiguous with the external types above.)
+ */
+#define ACPI_TYPE_LOCAL_REGION_FIELD    0x11
+#define ACPI_TYPE_LOCAL_BANK_FIELD      0x12
+#define ACPI_TYPE_LOCAL_INDEX_FIELD     0x13
+#define ACPI_TYPE_LOCAL_REFERENCE       0x14	/* Arg#, Local#, Name, Debug, ref_of, Index */
+#define ACPI_TYPE_LOCAL_ALIAS           0x15
+#define ACPI_TYPE_LOCAL_METHOD_ALIAS    0x16
+#define ACPI_TYPE_LOCAL_NOTIFY          0x17
+#define ACPI_TYPE_LOCAL_ADDRESS_HANDLER 0x18
+#define ACPI_TYPE_LOCAL_RESOURCE        0x19
+#define ACPI_TYPE_LOCAL_RESOURCE_FIELD  0x1A
+#define ACPI_TYPE_LOCAL_SCOPE           0x1B	/* 1 Name, multiple object_list Nodes */
+
+#define ACPI_TYPE_NS_NODE_MAX           0x1B	/* Last typecode used within a NS Node */
+
+/*
+ * These are special object types that never appear in
+ * a Namespace node, only in an union acpi_operand_object
+ */
+#define ACPI_TYPE_LOCAL_EXTRA           0x1C
+#define ACPI_TYPE_LOCAL_DATA            0x1D
+
+#define ACPI_TYPE_LOCAL_MAX             0x1D
+
+/* All types above here are invalid */
+
+#define ACPI_TYPE_INVALID               0x1E
+#define ACPI_TYPE_NOT_FOUND             0xFF
+
+#define ACPI_NUM_NS_TYPES               (ACPI_TYPE_INVALID + 1)
+
+/*
+ * All I/O
+ */
+#define ACPI_READ                       0
+#define ACPI_WRITE                      1
+#define ACPI_IO_MASK                    1
+
+/*
+ * Event Types: Fixed & General Purpose
+ */
+typedef u32 acpi_event_type;
+
+/*
+ * Fixed events
+ */
+#define ACPI_EVENT_PMTIMER              0
+#define ACPI_EVENT_GLOBAL               1
+#define ACPI_EVENT_POWER_BUTTON         2
+#define ACPI_EVENT_SLEEP_BUTTON         3
+#define ACPI_EVENT_RTC                  4
+#define ACPI_EVENT_MAX                  4
+#define ACPI_NUM_FIXED_EVENTS           ACPI_EVENT_MAX + 1
+
+/*
+ * Event Status - Per event
+ * -------------
+ * The encoding of acpi_event_status is illustrated below.
+ * Note that a set bit (1) indicates the property is TRUE
+ * (e.g. if bit 0 is set then the event is enabled).
+ * +-------------+-+-+-+
+ * |   Bits 31:3 |2|1|0|
+ * +-------------+-+-+-+
+ *          |     | | |
+ *          |     | | +- Enabled?
+ *          |     | +--- Enabled for wake?
+ *          |     +----- Set?
+ *          +----------- <Reserved>
+ */
+typedef u32 acpi_event_status;
+
+#define ACPI_EVENT_FLAG_DISABLED        (acpi_event_status) 0x00
+#define ACPI_EVENT_FLAG_ENABLED         (acpi_event_status) 0x01
+#define ACPI_EVENT_FLAG_WAKE_ENABLED    (acpi_event_status) 0x02
+#define ACPI_EVENT_FLAG_SET             (acpi_event_status) 0x04
+
+/*
+ * General Purpose Events (GPE)
+ */
+#define ACPI_GPE_INVALID                0xFF
+#define ACPI_GPE_MAX                    0xFF
+#define ACPI_NUM_GPE                    256
+
+/* Actions for acpi_set_gpe, acpi_gpe_wakeup, acpi_hw_low_set_gpe */
+
+#define ACPI_GPE_ENABLE                 0
+#define ACPI_GPE_DISABLE                1
+#define ACPI_GPE_CONDITIONAL_ENABLE     2
+
+/*
+ * GPE info flags - Per GPE
+ * +-------+-+-+---+
+ * |  7:4  |3|2|1:0|
+ * +-------+-+-+---+
+ *     |    | |  |
+ *     |    | |  +-- Type of dispatch:to method, handler, notify, or none
+ *     |    | +----- Interrupt type: edge or level triggered
+ *     |    +------- Is a Wake GPE
+ *     +------------ <Reserved>
+ */
+#define ACPI_GPE_DISPATCH_NONE          (u8) 0x00
+#define ACPI_GPE_DISPATCH_METHOD        (u8) 0x01
+#define ACPI_GPE_DISPATCH_HANDLER       (u8) 0x02
+#define ACPI_GPE_DISPATCH_NOTIFY        (u8) 0x03
+#define ACPI_GPE_DISPATCH_MASK          (u8) 0x03
+
+#define ACPI_GPE_LEVEL_TRIGGERED        (u8) 0x04
+#define ACPI_GPE_EDGE_TRIGGERED         (u8) 0x00
+#define ACPI_GPE_XRUPT_TYPE_MASK        (u8) 0x04
+
+#define ACPI_GPE_CAN_WAKE               (u8) 0x08
+
+/*
+ * Flags for GPE and Lock interfaces
+ */
+#define ACPI_NOT_ISR                    0x1
+#define ACPI_ISR                        0x0
+
+/* Notify types */
+
+#define ACPI_SYSTEM_NOTIFY              0x1
+#define ACPI_DEVICE_NOTIFY              0x2
+#define ACPI_ALL_NOTIFY                 (ACPI_SYSTEM_NOTIFY | ACPI_DEVICE_NOTIFY)
+#define ACPI_MAX_NOTIFY_HANDLER_TYPE    0x3
+
+#define ACPI_MAX_SYS_NOTIFY             0x7f
+
+/* Address Space (Operation Region) Types */
+
+typedef u8 acpi_adr_space_type;
+
+#define ACPI_ADR_SPACE_SYSTEM_MEMORY    (acpi_adr_space_type) 0
+#define ACPI_ADR_SPACE_SYSTEM_IO        (acpi_adr_space_type) 1
+#define ACPI_ADR_SPACE_PCI_CONFIG       (acpi_adr_space_type) 2
+#define ACPI_ADR_SPACE_EC               (acpi_adr_space_type) 3
+#define ACPI_ADR_SPACE_SMBUS            (acpi_adr_space_type) 4
+#define ACPI_ADR_SPACE_CMOS             (acpi_adr_space_type) 5
+#define ACPI_ADR_SPACE_PCI_BAR_TARGET   (acpi_adr_space_type) 6
+#define ACPI_ADR_SPACE_IPMI             (acpi_adr_space_type) 7
+#define ACPI_ADR_SPACE_GPIO             (acpi_adr_space_type) 8
+#define ACPI_ADR_SPACE_GSBUS            (acpi_adr_space_type) 9
+
+#define ACPI_NUM_PREDEFINED_REGIONS     10
+
+/*
+ * Special Address Spaces
+ *
+ * Note: A Data Table region is a special type of operation region
+ * that has its own AML opcode. However, internally, the AML
+ * interpreter simply creates an operation region with an an address
+ * space type of ACPI_ADR_SPACE_DATA_TABLE.
+ */
+#define ACPI_ADR_SPACE_DATA_TABLE       (acpi_adr_space_type) 0x7E	/* Internal to ACPICA only */
+#define ACPI_ADR_SPACE_FIXED_HARDWARE   (acpi_adr_space_type) 0x7F
+
+/* Values for _REG connection code */
+
+#define ACPI_REG_DISCONNECT             0
+#define ACPI_REG_CONNECT                1
+
+/*
+ * bit_register IDs
+ *
+ * These values are intended to be used by the hardware interfaces
+ * and are mapped to individual bitfields defined within the ACPI
+ * registers. See the acpi_gbl_bit_register_info global table in utglobal.c
+ * for this mapping.
+ */
+
+/* PM1 Status register */
+
+#define ACPI_BITREG_TIMER_STATUS                0x00
+#define ACPI_BITREG_BUS_MASTER_STATUS           0x01
+#define ACPI_BITREG_GLOBAL_LOCK_STATUS          0x02
+#define ACPI_BITREG_POWER_BUTTON_STATUS         0x03
+#define ACPI_BITREG_SLEEP_BUTTON_STATUS         0x04
+#define ACPI_BITREG_RT_CLOCK_STATUS             0x05
+#define ACPI_BITREG_WAKE_STATUS                 0x06
+#define ACPI_BITREG_PCIEXP_WAKE_STATUS          0x07
+
+/* PM1 Enable register */
+
+#define ACPI_BITREG_TIMER_ENABLE                0x08
+#define ACPI_BITREG_GLOBAL_LOCK_ENABLE          0x09
+#define ACPI_BITREG_POWER_BUTTON_ENABLE         0x0A
+#define ACPI_BITREG_SLEEP_BUTTON_ENABLE         0x0B
+#define ACPI_BITREG_RT_CLOCK_ENABLE             0x0C
+#define ACPI_BITREG_PCIEXP_WAKE_DISABLE         0x0D
+
+/* PM1 Control register */
+
+#define ACPI_BITREG_SCI_ENABLE                  0x0E
+#define ACPI_BITREG_BUS_MASTER_RLD              0x0F
+#define ACPI_BITREG_GLOBAL_LOCK_RELEASE         0x10
+#define ACPI_BITREG_SLEEP_TYPE                  0x11
+#define ACPI_BITREG_SLEEP_ENABLE                0x12
+
+/* PM2 Control register */
+
+#define ACPI_BITREG_ARB_DISABLE                 0x13
+
+#define ACPI_BITREG_MAX                         0x13
+#define ACPI_NUM_BITREG                         ACPI_BITREG_MAX + 1
+
+/* Status register values. A 1 clears a status bit. 0 = no effect */
+
+#define ACPI_CLEAR_STATUS                       1
+
+/* Enable and Control register values */
+
+#define ACPI_ENABLE_EVENT                       1
+#define ACPI_DISABLE_EVENT                      0
+
+/*
+ * External ACPI object definition
+ */
+
+/*
+ * Note: Type == ACPI_TYPE_ANY (0) is used to indicate a NULL package element
+ * or an unresolved named reference.
+ */
+union acpi_object {
+	acpi_object_type type;	/* See definition of acpi_ns_type for values */
+	struct {
+		acpi_object_type type;	/* ACPI_TYPE_INTEGER */
+		u64 value;	/* The actual number */
+	} integer;
+
+	struct {
+		acpi_object_type type;	/* ACPI_TYPE_STRING */
+		u32 length;	/* # of bytes in string, excluding trailing null */
+		char *pointer;	/* points to the string value */
+	} string;
+
+	struct {
+		acpi_object_type type;	/* ACPI_TYPE_BUFFER */
+		u32 length;	/* # of bytes in buffer */
+		u8 *pointer;	/* points to the buffer */
+	} buffer;
+
+	struct {
+		acpi_object_type type;	/* ACPI_TYPE_PACKAGE */
+		u32 count;	/* # of elements in package */
+		union acpi_object *elements;	/* Pointer to an array of ACPI_OBJECTs */
+	} package;
+
+	struct {
+		acpi_object_type type;	/* ACPI_TYPE_LOCAL_REFERENCE */
+		acpi_object_type actual_type;	/* Type associated with the Handle */
+		acpi_handle handle;	/* object reference */
+	} reference;
+
+	struct {
+		acpi_object_type type;	/* ACPI_TYPE_PROCESSOR */
+		u32 proc_id;
+		acpi_io_address pblk_address;
+		u32 pblk_length;
+	} processor;
+
+	struct {
+		acpi_object_type type;	/* ACPI_TYPE_POWER */
+		u32 system_level;
+		u32 resource_order;
+	} power_resource;
+};
+
+/*
+ * List of objects, used as a parameter list for control method evaluation
+ */
+struct acpi_object_list {
+	u32 count;
+	union acpi_object *pointer;
+};
+
+/*
+ * Miscellaneous common Data Structures used by the interfaces
+ */
+#define ACPI_NO_BUFFER              0
+#define ACPI_ALLOCATE_BUFFER        (acpi_size) (-1)
+#define ACPI_ALLOCATE_LOCAL_BUFFER  (acpi_size) (-2)
+
+struct acpi_buffer {
+	acpi_size length;	/* Length in bytes of the buffer */
+	void *pointer;		/* pointer to buffer */
+};
+
+/*
+ * name_type for acpi_get_name
+ */
+#define ACPI_FULL_PATHNAME              0
+#define ACPI_SINGLE_NAME                1
+#define ACPI_NAME_TYPE_MAX              1
+
+/*
+ * Predefined Namespace items
+ */
+struct acpi_predefined_names {
+	char *name;
+	u8 type;
+	char *val;
+};
+
+/*
+ * Structure and flags for acpi_get_system_info
+ */
+#define ACPI_SYS_MODE_UNKNOWN           0x0000
+#define ACPI_SYS_MODE_ACPI              0x0001
+#define ACPI_SYS_MODE_LEGACY            0x0002
+#define ACPI_SYS_MODES_MASK             0x0003
+
+/*
+ * System info returned by acpi_get_system_info()
+ */
+struct acpi_system_info {
+	u32 acpi_ca_version;
+	u32 flags;
+	u32 timer_resolution;
+	u32 reserved1;
+	u32 reserved2;
+	u32 debug_level;
+	u32 debug_layer;
+};
+
+/*
+ * System statistics returned by acpi_get_statistics()
+ */
+struct acpi_statistics {
+	u32 sci_count;
+	u32 gpe_count;
+	u32 fixed_event_count[ACPI_NUM_FIXED_EVENTS];
+	u32 method_count;
+};
+
+/* Table Event Types */
+
+#define ACPI_TABLE_EVENT_LOAD           0x0
+#define ACPI_TABLE_EVENT_UNLOAD         0x1
+#define ACPI_NUM_TABLE_EVENTS           2
+
+/*
+ * Types specific to the OS service interfaces
+ */
+typedef u32
+ (ACPI_SYSTEM_XFACE * acpi_osd_handler) (void *context);
+
+typedef void
+ (ACPI_SYSTEM_XFACE * acpi_osd_exec_callback) (void *context);
+
+/*
+ * Various handlers and callback procedures
+ */
+typedef
+void (*acpi_gbl_event_handler) (u32 event_type,
+				acpi_handle device,
+				u32 event_number, void *context);
+
+#define ACPI_EVENT_TYPE_GPE         0
+#define ACPI_EVENT_TYPE_FIXED       1
+
+typedef
+u32 (*acpi_event_handler) (void *context);
+
+typedef
+u32 (*acpi_gpe_handler) (acpi_handle gpe_device, u32 gpe_number, void *context);
+
+typedef
+void (*acpi_notify_handler) (acpi_handle device, u32 value, void *context);
+
+typedef
+void (*acpi_object_handler) (acpi_handle object, void *data);
+
+typedef acpi_status(*acpi_init_handler) (acpi_handle object, u32 function);
+
+#define ACPI_INIT_DEVICE_INI        1
+
+typedef
+acpi_status(*acpi_exception_handler) (acpi_status aml_status,
+				      acpi_name name,
+				      u16 opcode,
+				      u32 aml_offset, void *context);
+
+/* Table Event handler (Load, load_table, etc.) and types */
+
+typedef
+acpi_status(*acpi_table_handler) (u32 event, void *table, void *context);
+
+#define ACPI_TABLE_LOAD             0x0
+#define ACPI_TABLE_UNLOAD           0x1
+#define ACPI_NUM_TABLE_EVENTS       2
+
+/* Address Spaces (For Operation Regions) */
+
+typedef
+acpi_status(*acpi_adr_space_handler) (u32 function,
+				      acpi_physical_address address,
+				      u32 bit_width,
+				      u64 *value,
+				      void *handler_context,
+				      void *region_context);
+
+#define ACPI_DEFAULT_HANDLER            NULL
+
+/* Special Context data for generic_serial_bus/general_purpose_io (ACPI 5.0) */
+
+struct acpi_connection_info {
+	u8 *connection;
+	u16 length;
+	u8 access_length;
+};
+
+typedef
+acpi_status(*acpi_adr_space_setup) (acpi_handle region_handle,
+				    u32 function,
+				    void *handler_context,
+				    void **region_context);
+
+#define ACPI_REGION_ACTIVATE    0
+#define ACPI_REGION_DEACTIVATE  1
+
+typedef
+acpi_status(*acpi_walk_callback) (acpi_handle object,
+				  u32 nesting_level,
+				  void *context, void **return_value);
+
+typedef
+u32 (*acpi_interface_handler) (acpi_string interface_name, u32 supported);
+
+/* Interrupt handler return values */
+
+#define ACPI_INTERRUPT_NOT_HANDLED      0x00
+#define ACPI_INTERRUPT_HANDLED          0x01
+
+/* GPE handler return values */
+
+#define ACPI_REENABLE_GPE               0x80
+
+/* Length of 32-bit EISAID values when converted back to a string */
+
+#define ACPI_EISAID_STRING_SIZE         8	/* Includes null terminator */
+
+/* Length of UUID (string) values */
+
+#define ACPI_UUID_LENGTH                16
+
+/* Structures used for device/processor HID, UID, CID */
+
+struct acpi_device_id {
+	u32 length;		/* Length of string + null */
+	char *string;
+};
+
+struct acpi_device_id_list {
+	u32 count;		/* Number of IDs in Ids array */
+	u32 list_size;		/* Size of list, including ID strings */
+	struct acpi_device_id ids[1];	/* ID array */
+};
+
+/*
+ * Structure returned from acpi_get_object_info.
+ * Optimized for both 32- and 64-bit builds
+ */
+struct acpi_device_info {
+	u32 info_size;		/* Size of info, including ID strings */
+	u32 name;		/* ACPI object Name */
+	acpi_object_type type;	/* ACPI object Type */
+	u8 param_count;		/* If a method, required parameter count */
+	u8 valid;		/* Indicates which optional fields are valid */
+	u8 flags;		/* Miscellaneous info */
+	u8 highest_dstates[4];	/* _sx_d values: 0xFF indicates not valid */
+	u8 lowest_dstates[5];	/* _sx_w values: 0xFF indicates not valid */
+	u32 current_status;	/* _STA value */
+	u64 address;		/* _ADR value */
+	struct acpi_device_id hardware_id;	/* _HID value */
+	struct acpi_device_id unique_id;	/* _UID value */
+	struct acpi_device_id_list compatible_id_list;	/* _CID list <must be last> */
+};
+
+/* Values for Flags field above (acpi_get_object_info) */
+
+#define ACPI_PCI_ROOT_BRIDGE            0x01
+
+/* Flags for Valid field above (acpi_get_object_info) */
+
+#define ACPI_VALID_STA                  0x01
+#define ACPI_VALID_ADR                  0x02
+#define ACPI_VALID_HID                  0x04
+#define ACPI_VALID_UID                  0x08
+#define ACPI_VALID_CID                  0x10
+#define ACPI_VALID_SXDS                 0x20
+#define ACPI_VALID_SXWS                 0x40
+
+/* Flags for _STA method */
+
+#define ACPI_STA_DEVICE_PRESENT         0x01
+#define ACPI_STA_DEVICE_ENABLED         0x02
+#define ACPI_STA_DEVICE_UI              0x04
+#define ACPI_STA_DEVICE_FUNCTIONING     0x08
+#define ACPI_STA_DEVICE_OK              0x08	/* Synonym */
+#define ACPI_STA_BATTERY_PRESENT        0x10
+
+/* Context structs for address space handlers */
+
+struct acpi_pci_id {
+	u16 segment;
+	u16 bus;
+	u16 device;
+	u16 function;
+};
+
+struct acpi_mem_space_context {
+	u32 length;
+	acpi_physical_address address;
+	acpi_physical_address mapped_physical_address;
+	u8 *mapped_logical_address;
+	acpi_size mapped_length;
+};
+
+/*
+ * struct acpi_memory_list is used only if the ACPICA local cache is enabled
+ */
+struct acpi_memory_list {
+	char *list_name;
+	void *list_head;
+	u16 object_size;
+	u16 max_depth;
+	u16 current_depth;
+	u16 link_offset;
+
+#ifdef ACPI_DBG_TRACK_ALLOCATIONS
+
+	/* Statistics for debug memory tracking only */
+
+	u32 total_allocated;
+	u32 total_freed;
+	u32 max_occupied;
+	u32 total_size;
+	u32 current_total_size;
+	u32 requests;
+	u32 hits;
+#endif
+};
+
+#endif				/* __ACTYPES_H__ */
diff --git a/com32/acpioff/acpica_linuxized/include/acpi/platform/accygwin.h b/com32/acpioff/acpica_linuxized/include/acpi/platform/accygwin.h
new file mode 100644
index 00000000..e1fc67f0
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/include/acpi/platform/accygwin.h
@@ -0,0 +1,91 @@
+/******************************************************************************
+ *
+ * Name: accygwin.h - OS specific defines, etc. for cygwin environment
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACCYGWIN_H__
+#define __ACCYGWIN_H__
+
+/*
+ * ACPICA configuration
+ */
+#define ACPI_USE_SYSTEM_CLIBRARY
+#define ACPI_USE_DO_WHILE_0
+#define ACPI_FLUSH_CPU_CACHE()
+/*
+ * This is needed since sem_timedwait does not appear to work properly
+ * on cygwin (always hangs forever).
+ */
+#define ACPI_USE_ALTERNATE_TIMEOUT
+
+#include <stdarg.h>
+#include <string.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <unistd.h>
+
+#if defined(__ia64__) || defined(__x86_64__)
+#define ACPI_MACHINE_WIDTH          64
+#define COMPILER_DEPENDENT_INT64    long
+#define COMPILER_DEPENDENT_UINT64   unsigned long
+#else
+#define ACPI_MACHINE_WIDTH          32
+#define COMPILER_DEPENDENT_INT64    long long
+#define COMPILER_DEPENDENT_UINT64   unsigned long long
+#define ACPI_USE_NATIVE_DIVIDE
+#endif
+
+#ifndef __cdecl
+#define __cdecl
+#endif
+
+#define ACPI_ACQUIRE_GLOBAL_LOCK(Glptr, acq) if (Glptr) acq=1; else acq=0;
+#define ACPI_RELEASE_GLOBAL_LOCK(Glptr, pending) pending = 1
+
+/* On Cygwin, pthread_t is a pointer */
+
+#define ACPI_CAST_PTHREAD_T(pthread) ((acpi_thread_id) ACPI_TO_INTEGER (pthread))
+
+/* Cygwin uses GCC */
+
+#include "acgcc.h"
+
+#endif				/* __ACCYGWIN_H__ */
diff --git a/com32/acpioff/acpica_linuxized/include/acpi/platform/acefi.h b/com32/acpioff/acpica_linuxized/include/acpi/platform/acefi.h
new file mode 100644
index 00000000..48767db7
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/include/acpi/platform/acefi.h
@@ -0,0 +1,73 @@
+/******************************************************************************
+ *
+ * Name: acefi.h - OS specific defines, etc.
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACEFI_H__
+#define __ACEFI_H__
+
+#include <efi.h>
+#include <efistdarg.h>
+#include <efilib.h>
+
+/* _int64 works for both IA32 and IA64 */
+
+#define COMPILER_DEPENDENT_INT64   __int64
+#define COMPILER_DEPENDENT_UINT64  unsigned __int64
+
+/*
+ * Calling conventions:
+ *
+ * ACPI_SYSTEM_XFACE        - Interfaces to host OS (handlers, threads)
+ * ACPI_EXTERNAL_XFACE      - External ACPI interfaces
+ * ACPI_INTERNAL_XFACE      - Internal ACPI interfaces
+ * ACPI_INTERNAL_VAR_XFACE  - Internal variable-parameter list interfaces
+ */
+#define ACPI_SYSTEM_XFACE
+#define ACPI_EXTERNAL_XFACE
+#define ACPI_INTERNAL_XFACE
+#define ACPI_INTERNAL_VAR_XFACE
+
+/* warn C4142: redefinition of type */
+
+#pragma warning(disable:4142)
+
+#endif				/* __ACEFI_H__ */
diff --git a/com32/acpioff/acpica_linuxized/include/acpi/platform/acenv.h b/com32/acpioff/acpica_linuxized/include/acpi/platform/acenv.h
new file mode 100644
index 00000000..da593641
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/include/acpi/platform/acenv.h
@@ -0,0 +1,388 @@
+/******************************************************************************
+ *
+ * Name: acenv.h - Host and compiler configuration
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACENV_H__
+#define __ACENV_H__
+
+/*
+ * Environment configuration. The purpose of this file is to interface ACPICA
+ * to the local environment. This includes compiler-specific, OS-specific,
+ * and machine-specific configuration.
+ */
+
+/* Types for ACPI_MUTEX_TYPE */
+
+#define ACPI_BINARY_SEMAPHORE       0
+#define ACPI_OSL_MUTEX              1
+
+/* Types for DEBUGGER_THREADING */
+
+#define DEBUGGER_SINGLE_THREADED    0
+#define DEBUGGER_MULTI_THREADED     1
+
+/******************************************************************************
+ *
+ * Configuration for ACPI tools and utilities
+ *
+ *****************************************************************************/
+
+/* i_aSL configuration */
+
+#ifdef ACPI_ASL_COMPILER
+#define ACPI_APPLICATION
+#define ACPI_DISASSEMBLER
+#define ACPI_DEBUG_OUTPUT
+#define ACPI_CONSTANT_EVAL_ONLY
+#define ACPI_LARGE_NAMESPACE_NODE
+#define ACPI_DATA_TABLE_DISASSEMBLY
+#define ACPI_SINGLE_THREADED
+#endif
+
+/* acpi_exec configuration. Multithreaded with full AML debugger */
+
+#ifdef ACPI_EXEC_APP
+#define ACPI_APPLICATION
+#define ACPI_FULL_DEBUG
+#define ACPI_MUTEX_DEBUG
+#define ACPI_DBG_TRACK_ALLOCATIONS
+#endif
+
+/* acpi_names configuration. Single threaded with debugger output enabled. */
+
+#ifdef ACPI_NAMES_APP
+#define ACPI_DEBUGGER
+#define ACPI_APPLICATION
+#define ACPI_SINGLE_THREADED
+#endif
+
+/*
+ * acpi_bin/acpi_help/acpi_src configuration. All single threaded, with
+ * no debug output.
+ */
+#if (defined ACPI_BIN_APP)   || \
+	(defined ACPI_SRC_APP)   || \
+	(defined ACPI_XTRACT_APP)
+#define ACPI_APPLICATION
+#define ACPI_SINGLE_THREADED
+#endif
+
+#ifdef ACPI_HELP_APP
+#define ACPI_DEBUG_OUTPUT
+#define ACPI_APPLICATION
+#define ACPI_SINGLE_THREADED
+#endif
+
+/* Linkable ACPICA library */
+
+#ifdef ACPI_LIBRARY
+#define ACPI_USE_LOCAL_CACHE
+#endif
+
+/* Common for all ACPICA applications */
+
+#ifdef ACPI_APPLICATION
+#define ACPI_USE_SYSTEM_CLIBRARY
+#define ACPI_USE_LOCAL_CACHE
+#endif
+
+/* Common debug support */
+
+#ifdef ACPI_FULL_DEBUG
+#define ACPI_DEBUGGER
+#define ACPI_DEBUG_OUTPUT
+#define ACPI_DISASSEMBLER
+#endif
+
+/*! [Begin] no source code translation */
+
+/******************************************************************************
+ *
+ * Host configuration files. The compiler configuration files are included
+ * by the host files.
+ *
+ *****************************************************************************/
+
+#if defined(_LINUX) || defined(__linux__)
+#include "aclinux.h"
+
+#elif defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
+#include "acfreebsd.h"
+
+#elif defined(__NetBSD__)
+#include "acnetbsd.h"
+
+#elif defined(__sun)
+#include "acsolaris.h"
+
+#elif defined(MODESTO)
+#include "acmodesto.h"
+
+#elif defined(NETWARE)
+#include "acnetware.h"
+
+#elif defined(_CYGWIN)
+#include "accygwin.h"
+
+#elif defined(WIN32)
+#include "acwin.h"
+
+#elif defined(WIN64)
+#include "acwin64.h"
+
+#elif defined(_WRS_LIB_BUILD)
+#include "acvxworks.h"
+
+#elif defined(__OS2__)
+#include "acos2.h"
+
+#elif defined(_AED_EFI)
+#include "acefi.h"
+
+#else
+
+/* Unknown environment */
+
+#error Unknown target environment
+#endif
+
+/*! [End] no source code translation !*/
+
+/******************************************************************************
+ *
+ * Setup defaults for the required symbols that were not defined in one of
+ * the host/compiler files above.
+ *
+ *****************************************************************************/
+
+/* 64-bit data types */
+
+#ifndef COMPILER_DEPENDENT_INT64
+#define COMPILER_DEPENDENT_INT64   long long
+#endif
+
+#ifndef COMPILER_DEPENDENT_UINT64
+#define COMPILER_DEPENDENT_UINT64  unsigned long long
+#endif
+
+/* Type of mutex supported by host. Default is binary semaphores. */
+
+#ifndef ACPI_MUTEX_TYPE
+#define ACPI_MUTEX_TYPE             ACPI_BINARY_SEMAPHORE
+#endif
+
+/* Global Lock acquire/release */
+
+#ifndef ACPI_ACQUIRE_GLOBAL_LOCK
+#define ACPI_ACQUIRE_GLOBAL_LOCK(Glptr, acquired) acquired = 1
+#endif
+
+#ifndef ACPI_RELEASE_GLOBAL_LOCK
+#define ACPI_RELEASE_GLOBAL_LOCK(Glptr, pending) pending = 0
+#endif
+
+/* Flush CPU cache - used when going to sleep. Wbinvd or similar. */
+
+#ifndef ACPI_FLUSH_CPU_CACHE
+#define ACPI_FLUSH_CPU_CACHE()
+#endif
+
+/* "inline" keywords - configurable since inline is not standardized */
+
+#ifndef ACPI_INLINE
+#define ACPI_INLINE
+#endif
+
+/*
+ * Configurable calling conventions:
+ *
+ * ACPI_SYSTEM_XFACE        - Interfaces to host OS (handlers, threads)
+ * ACPI_EXTERNAL_XFACE      - External ACPI interfaces
+ * ACPI_INTERNAL_XFACE      - Internal ACPI interfaces
+ * ACPI_INTERNAL_VAR_XFACE  - Internal variable-parameter list interfaces
+ */
+#ifndef ACPI_SYSTEM_XFACE
+#define ACPI_SYSTEM_XFACE
+#endif
+
+#ifndef ACPI_EXTERNAL_XFACE
+#define ACPI_EXTERNAL_XFACE
+#endif
+
+#ifndef ACPI_INTERNAL_XFACE
+#define ACPI_INTERNAL_XFACE
+#endif
+
+#ifndef ACPI_INTERNAL_VAR_XFACE
+#define ACPI_INTERNAL_VAR_XFACE
+#endif
+
+/*
+ * Debugger threading model
+ * Use single threaded if the entire subsystem is contained in an application
+ * Use multiple threaded when the subsystem is running in the kernel.
+ *
+ * By default the model is single threaded if ACPI_APPLICATION is set,
+ * multi-threaded if ACPI_APPLICATION is not set.
+ */
+#ifndef DEBUGGER_THREADING
+#ifdef ACPI_APPLICATION
+#define DEBUGGER_THREADING          DEBUGGER_SINGLE_THREADED
+
+#else
+#define DEBUGGER_THREADING          DEBUGGER_MULTI_THREADED
+#endif
+#endif				/* !DEBUGGER_THREADING */
+
+/******************************************************************************
+ *
+ * C library configuration
+ *
+ *****************************************************************************/
+
+/*
+ * ACPI_USE_SYSTEM_CLIBRARY - Define this if linking to an actual C library.
+ *      Otherwise, local versions of string/memory functions will be used.
+ * ACPI_USE_STANDARD_HEADERS - Define this if linking to a C library and
+ *      the standard header files may be used.
+ *
+ * The ACPICA subsystem only uses low level C library functions that do not call
+ * operating system services and may therefore be inlined in the code.
+ *
+ * It may be necessary to tailor these include files to the target
+ * generation environment.
+ */
+#ifdef ACPI_USE_SYSTEM_CLIBRARY
+
+/* Use the standard C library headers. We want to keep these to a minimum */
+
+#ifdef ACPI_USE_STANDARD_HEADERS
+
+/* Use the standard headers from the standard locations */
+
+#include <stdarg.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+
+#endif				/* ACPI_USE_STANDARD_HEADERS */
+
+/* We will be linking to the standard Clib functions */
+
+#define ACPI_STRSTR(s1,s2)      strstr((s1), (s2))
+#define ACPI_STRCHR(s1,c)       strchr((s1), (c))
+#define ACPI_STRLEN(s)          (acpi_size) strlen((s))
+#define ACPI_STRCPY(d,s)        (void) strcpy((d), (s))
+#define ACPI_STRNCPY(d,s,n)     (void) strncpy((d), (s), (acpi_size)(n))
+#define ACPI_STRNCMP(d,s,n)     strncmp((d), (s), (acpi_size)(n))
+#define ACPI_STRCMP(d,s)        strcmp((d), (s))
+#define ACPI_STRCAT(d,s)        (void) strcat((d), (s))
+#define ACPI_STRNCAT(d,s,n)     strncat((d), (s), (acpi_size)(n))
+#define ACPI_STRTOUL(d,s,n)     strtoul((d), (s), (acpi_size)(n))
+#define ACPI_MEMCMP(s1,s2,n)    memcmp((const char *)(s1), (const char *)(s2), (acpi_size)(n))
+#define ACPI_MEMCPY(d,s,n)      (void) memcpy((d), (s), (acpi_size)(n))
+#define ACPI_MEMSET(d,s,n)      (void) memset((d), (s), (acpi_size)(n))
+#define ACPI_TOUPPER(i)         toupper((int) (i))
+#define ACPI_TOLOWER(i)         tolower((int) (i))
+#define ACPI_IS_XDIGIT(i)       isxdigit((int) (i))
+#define ACPI_IS_DIGIT(i)        isdigit((int) (i))
+#define ACPI_IS_SPACE(i)        isspace((int) (i))
+#define ACPI_IS_UPPER(i)        isupper((int) (i))
+#define ACPI_IS_PRINT(i)        isprint((int) (i))
+#define ACPI_IS_ALPHA(i)        isalpha((int) (i))
+
+#else
+
+/******************************************************************************
+ *
+ * Not using native C library, use local implementations
+ *
+ *****************************************************************************/
+
+/*
+ * Use local definitions of C library macros and functions. These function
+ * implementations may not be as efficient as an inline or assembly code
+ * implementation provided by a native C library, but they are functionally
+ * equivalent.
+ */
+#ifndef va_arg
+
+#ifndef _VALIST
+#define _VALIST
+typedef char *va_list;
+#endif				/* _VALIST */
+
+/* Storage alignment properties */
+
+#define  _AUPBND                (sizeof (acpi_native_int) - 1)
+#define  _ADNBND                (sizeof (acpi_native_int) - 1)
+
+/* Variable argument list macro definitions */
+
+#define _bnd(X, bnd)            (((sizeof (X)) + (bnd)) & (~(bnd)))
+#define va_arg(ap, T)           (*(T *)(((ap) += (_bnd (T, _AUPBND))) - (_bnd (T,_ADNBND))))
+#define va_end(ap)              (void) 0
+#define va_start(ap, A)         (void) ((ap) = (((char *) &(A)) + (_bnd (A,_AUPBND))))
+
+#endif				/* va_arg */
+
+/* Use the local (ACPICA) definitions of the clib functions */
+
+#define ACPI_STRSTR(s1,s2)      acpi_ut_strstr ((s1), (s2))
+#define ACPI_STRCHR(s1,c)       acpi_ut_strchr ((s1), (c))
+#define ACPI_STRLEN(s)          (acpi_size) acpi_ut_strlen ((s))
+#define ACPI_STRCPY(d,s)        (void) acpi_ut_strcpy ((d), (s))
+#define ACPI_STRNCPY(d,s,n)     (void) acpi_ut_strncpy ((d), (s), (acpi_size)(n))
+#define ACPI_STRNCMP(d,s,n)     acpi_ut_strncmp ((d), (s), (acpi_size)(n))
+#define ACPI_STRCMP(d,s)        acpi_ut_strcmp ((d), (s))
+#define ACPI_STRCAT(d,s)        (void) acpi_ut_strcat ((d), (s))
+#define ACPI_STRNCAT(d,s,n)     acpi_ut_strncat ((d), (s), (acpi_size)(n))
+#define ACPI_STRTOUL(d,s,n)     acpi_ut_strtoul ((d), (s), (acpi_size)(n))
+#define ACPI_MEMCMP(s1,s2,n)    acpi_ut_memcmp((const char *)(s1), (const char *)(s2), (acpi_size)(n))
+#define ACPI_MEMCPY(d,s,n)      (void) acpi_ut_memcpy ((d), (s), (acpi_size)(n))
+#define ACPI_MEMSET(d,v,n)      (void) acpi_ut_memset ((d), (v), (acpi_size)(n))
+#define ACPI_TOUPPER(c)         acpi_ut_to_upper ((int) (c))
+#define ACPI_TOLOWER(c)         acpi_ut_to_lower ((int) (c))
+
+#endif				/* ACPI_USE_SYSTEM_CLIBRARY */
+
+#endif				/* __ACENV_H__ */
diff --git a/com32/acpioff/acpica_linuxized/include/acpi/platform/acfreebsd.h b/com32/acpioff/acpica_linuxized/include/acpi/platform/acfreebsd.h
new file mode 100644
index 00000000..0434bb1b
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/include/acpi/platform/acfreebsd.h
@@ -0,0 +1,104 @@
+/******************************************************************************
+ *
+ * Name: acfreebsd.h - OS specific defines, etc.
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACFREEBSD_H__
+#define __ACFREEBSD_H__
+
+/* free_bSD uses GCC */
+
+#include "acgcc.h"
+#include <sys/types.h>
+#include <machine/acpica_machdep.h>
+
+#define acpi_uintptr_t              uintptr_t
+
+#define ACPI_USE_DO_WHILE_0
+#define ACPI_USE_LOCAL_CACHE
+#define ACPI_USE_SYSTEM_CLIBRARY
+
+#ifdef _KERNEL
+
+#include <sys/ctype.h>
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/libkern.h>
+#include <machine/stdarg.h>
+
+#include "opt_acpi.h"
+
+#define ACPI_MUTEX_TYPE     ACPI_OSL_MUTEX
+
+#ifdef ACPI_DEBUG
+#define ACPI_DEBUG_OUTPUT	/* for backward compatibility */
+#define ACPI_DISASSEMBLER
+#endif
+
+#ifdef ACPI_DEBUG_OUTPUT
+#include "opt_ddb.h"
+#ifdef DDB
+#define ACPI_DEBUGGER
+#endif				/* DDB */
+#endif				/* ACPI_DEBUG_OUTPUT */
+
+#ifdef DEBUGGER_THREADING
+#undef DEBUGGER_THREADING
+#endif				/* DEBUGGER_THREADING */
+
+#define DEBUGGER_THREADING  0	/* integrated with DDB */
+
+#else				/* _KERNEL */
+
+#if __STDC_HOSTED__
+#include <ctype.h>
+#endif
+
+#define ACPI_CAST_PTHREAD_T(pthread)    ((acpi_thread_id) ACPI_TO_INTEGER (pthread))
+
+#define ACPI_USE_STANDARD_HEADERS
+
+#define ACPI_FLUSH_CPU_CACHE()
+#define __cdecl
+
+#endif				/* _KERNEL */
+
+#endif				/* __ACFREEBSD_H__ */
diff --git a/com32/acpioff/acpica_linuxized/include/acpi/platform/acgcc.h b/com32/acpioff/acpica_linuxized/include/acpi/platform/acgcc.h
new file mode 100644
index 00000000..6ef5461c
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/include/acpi/platform/acgcc.h
@@ -0,0 +1,67 @@
+/******************************************************************************
+ *
+ * Name: acgcc.h - GCC specific defines, etc.
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACGCC_H__
+#define __ACGCC_H__
+
+#define ACPI_INLINE             __inline__
+
+/* Function name is used for debug output. Non-ANSI, compiler-dependent */
+
+#define ACPI_GET_FUNCTION_NAME          __FUNCTION__
+
+/*
+ * This macro is used to tag functions as "printf-like" because
+ * some compilers (like GCC) can catch printf format string problems.
+ */
+#define ACPI_PRINTF_LIKE(c) __attribute__ ((__format__ (__printf__, c, c+1)))
+
+/*
+ * Some compilers complain about unused variables. Sometimes we don't want to
+ * use all the variables (for example, _acpi_module_name). This allows us
+ * to to tell the compiler warning in a per-variable manner that a variable
+ * is unused.
+ */
+#define ACPI_UNUSED_VAR __attribute__ ((unused))
+
+#endif				/* __ACGCC_H__ */
diff --git a/com32/acpioff/acpica_linuxized/include/acpi/platform/acintel.h b/com32/acpioff/acpica_linuxized/include/acpi/platform/acintel.h
new file mode 100644
index 00000000..052269b6
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/include/acpi/platform/acintel.h
@@ -0,0 +1,81 @@
+/******************************************************************************
+ *
+ * Name: acintel.h - VC specific defines, etc.
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACINTEL_H__
+#define __ACINTEL_H__
+
+/* Configuration specific to Intel 64-bit C compiler */
+
+#define COMPILER_DEPENDENT_INT64    __int64
+#define COMPILER_DEPENDENT_UINT64   unsigned __int64
+#define ACPI_INLINE                 __inline
+
+/*
+ * Calling conventions:
+ *
+ * ACPI_SYSTEM_XFACE        - Interfaces to host OS (handlers, threads)
+ * ACPI_EXTERNAL_XFACE      - External ACPI interfaces
+ * ACPI_INTERNAL_XFACE      - Internal ACPI interfaces
+ * ACPI_INTERNAL_VAR_XFACE  - Internal variable-parameter list interfaces
+ */
+#define ACPI_SYSTEM_XFACE
+#define ACPI_EXTERNAL_XFACE
+#define ACPI_INTERNAL_XFACE
+#define ACPI_INTERNAL_VAR_XFACE
+
+/* remark 981 - operands evaluated in no particular order */
+#pragma warning(disable:981)
+
+/* warn C4100: unreferenced formal parameter */
+#pragma warning(disable:4100)
+
+/* warn C4127: conditional expression is constant */
+#pragma warning(disable:4127)
+
+/* warn C4706: assignment within conditional expression */
+#pragma warning(disable:4706)
+
+/* warn C4214: bit field types other than int */
+#pragma warning(disable:4214)
+
+#endif				/* __ACINTEL_H__ */
diff --git a/com32/acpioff/acpica_linuxized/include/acpi/platform/aclinux.h b/com32/acpioff/acpica_linuxized/include/acpi/platform/aclinux.h
new file mode 100644
index 00000000..dec90d0f
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/include/acpi/platform/aclinux.h
@@ -0,0 +1,159 @@
+/******************************************************************************
+ *
+ * Name: aclinux.h - OS specific defines, etc. for Linux
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACLINUX_H__
+#define __ACLINUX_H__
+
+/* Common (in-kernel/user-space) ACPICA configuration */
+
+#define ACPI_USE_SYSTEM_CLIBRARY
+#define ACPI_USE_DO_WHILE_0
+#define ACPI_MUTEX_TYPE             ACPI_BINARY_SEMAPHORE
+
+#ifdef __KERNEL__
+
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/ctype.h>
+#include <linux/sched.h>
+#include <asm/system.h>
+#include <asm/atomic.h>
+#include <asm/div64.h>
+#include <asm/acpi.h>
+#include <linux/slab.h>
+#include <linux/spinlock_types.h>
+#include <asm/current.h>
+
+/* Host-dependent types and defines for in-kernel ACPICA */
+
+#define ACPI_MACHINE_WIDTH          BITS_PER_LONG
+#define ACPI_EXPORT_SYMBOL(symbol)  EXPORT_SYMBOL(symbol);
+#define strtoul                     simple_strtoul
+
+#define acpi_cache_t                        struct kmem_cache
+#define acpi_spinlock                       spinlock_t *
+#define acpi_cpu_flags                      unsigned long
+
+#else				/* !__KERNEL__ */
+
+#include <stdarg.h>
+#include <string.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <unistd.h>
+
+/* Host-dependent types and defines for user-space ACPICA */
+
+#define ACPI_FLUSH_CPU_CACHE()
+
+#if defined(__ia64__) || defined(__x86_64__)
+#define ACPI_MACHINE_WIDTH          64
+#define COMPILER_DEPENDENT_INT64    long
+#define COMPILER_DEPENDENT_UINT64   unsigned long
+#define ACPI_CAST_PTHREAD_T(pthread) ((acpi_thread_id) (pthread))
+#else
+#define ACPI_MACHINE_WIDTH          32
+#define COMPILER_DEPENDENT_INT64    long long
+#define COMPILER_DEPENDENT_UINT64   unsigned long long
+#define ACPI_USE_NATIVE_DIVIDE
+#define ACPI_CAST_PTHREAD_T(pthread) ((acpi_thread_id) (u32) (void *) (pthread))
+#endif
+
+#ifndef __cdecl
+#define __cdecl
+#endif
+
+#endif				/* __KERNEL__ */
+
+/* Linux uses GCC */
+
+#include "acgcc.h"
+
+#ifdef __KERNEL__
+/*
+ * Overrides for in-kernel ACPICA
+ */
+static inline acpi_thread_id acpi_os_get_thread_id(void)
+{
+	return current;
+}
+
+/*
+ * The irqs_disabled() check is for resume from RAM.
+ * Interrupts are off during resume, just like they are for boot.
+ * However, boot has  (system_state != SYSTEM_RUNNING)
+ * to quiet __might_sleep() in kmalloc() and resume does not.
+ */
+#include <acpi/actypes.h>
+static inline void *acpi_os_allocate(acpi_size size)
+{
+	return kmalloc(size, irqs_disabled()? GFP_ATOMIC : GFP_KERNEL);
+}
+
+static inline void *acpi_os_allocate_zeroed(acpi_size size)
+{
+	return kzalloc(size, irqs_disabled()? GFP_ATOMIC : GFP_KERNEL);
+}
+
+static inline void *acpi_os_acquire_object(acpi_cache_t * cache)
+{
+	return kmem_cache_zalloc(cache,
+				 irqs_disabled()? GFP_ATOMIC : GFP_KERNEL);
+}
+
+#define ACPI_ALLOCATE(a)        acpi_os_allocate(a)
+#define ACPI_ALLOCATE_ZEROED(a) acpi_os_allocate_zeroed(a)
+#define ACPI_FREE(a)            kfree(a)
+
+/* Used within ACPICA to show where it is safe to preempt execution */
+
+#define ACPI_PREEMPTION_POINT() \
+	do { \
+		if (!irqs_disabled()) \
+			cond_resched(); \
+	} while (0)
+
+#endif				/* __KERNEL__ */
+
+#endif				/* __ACLINUX_H__ */
diff --git a/com32/acpioff/acpica_linuxized/include/acpi/platform/acmsvc.h b/com32/acpioff/acpica_linuxized/include/acpi/platform/acmsvc.h
new file mode 100644
index 00000000..0c49ef19
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/include/acpi/platform/acmsvc.h
@@ -0,0 +1,144 @@
+/******************************************************************************
+ *
+ * Name: acmsvc.h - VC specific defines, etc.
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACMSVC_H__
+#define __ACMSVC_H__
+
+/*
+ * Map low I/O functions for MS. This allows us to disable MS language
+ * extensions for maximum portability.
+ */
+#define open            _open
+#define read            _read
+#define write           _write
+#define close           _close
+#define stat            _stat
+#define fstat           _fstat
+#define mkdir           _mkdir
+#define strlwr          _strlwr
+#define O_RDONLY        _O_RDONLY
+#define O_BINARY        _O_BINARY
+#define O_CREAT         _O_CREAT
+#define O_WRONLY        _O_WRONLY
+#define O_TRUNC         _O_TRUNC
+#define S_IREAD         _S_IREAD
+#define S_IWRITE        _S_IWRITE
+#define S_IFDIR         _S_IFDIR
+
+/* Eliminate warnings for "old" (non-secure) versions of clib functions */
+
+#ifndef _CRT_SECURE_NO_WARNINGS
+#define _CRT_SECURE_NO_WARNINGS
+#endif
+
+/* Eliminate warnings for POSIX clib function names (open, write, etc.) */
+
+#ifndef _CRT_NONSTDC_NO_DEPRECATE
+#define _CRT_NONSTDC_NO_DEPRECATE
+#endif
+
+#define COMPILER_DEPENDENT_INT64    __int64
+#define COMPILER_DEPENDENT_UINT64   unsigned __int64
+#define ACPI_INLINE                 __inline
+
+/*
+ * Calling conventions:
+ *
+ * ACPI_SYSTEM_XFACE        - Interfaces to host OS (handlers, threads)
+ * ACPI_EXTERNAL_XFACE      - External ACPI interfaces
+ * ACPI_INTERNAL_XFACE      - Internal ACPI interfaces
+ * ACPI_INTERNAL_VAR_XFACE  - Internal variable-parameter list interfaces
+ */
+#define ACPI_SYSTEM_XFACE           __cdecl
+#define ACPI_EXTERNAL_XFACE
+#define ACPI_INTERNAL_XFACE
+#define ACPI_INTERNAL_VAR_XFACE     __cdecl
+
+#ifndef _LINT
+/*
+ * Math helper functions
+ */
+#define ACPI_DIV_64_BY_32(n_hi, n_lo, d32, q32, r32) \
+{                           \
+	__asm mov    edx, n_hi  \
+	__asm mov    eax, n_lo  \
+	__asm div    d32        \
+	__asm mov    q32, eax   \
+	__asm mov    r32, edx   \
+}
+
+#define ACPI_SHIFT_RIGHT_64(n_hi, n_lo) \
+{                           \
+	__asm shr    n_hi, 1    \
+	__asm rcr    n_lo, 1    \
+}
+#else
+
+/* Fake versions to make lint happy */
+
+#define ACPI_DIV_64_BY_32(n_hi, n_lo, d32, q32, r32) \
+{                           \
+	q32 = n_hi / d32;       \
+	r32 = n_lo / d32;       \
+}
+
+#define ACPI_SHIFT_RIGHT_64(n_hi, n_lo) \
+{                           \
+	n_hi >>= 1;    \
+	n_lo >>= 1;    \
+}
+#endif
+
+/* warn C4100: unreferenced formal parameter */
+#pragma warning(disable:4100)
+
+/* warn C4127: conditional expression is constant */
+#pragma warning(disable:4127)
+
+/* warn C4706: assignment within conditional expression */
+#pragma warning(disable:4706)
+
+/* warn C4131: uses old-style declarator (i_aSL compiler only) */
+#pragma warning(disable:4131)
+
+#endif				/* __ACMSVC_H__ */
diff --git a/com32/acpioff/acpica_linuxized/include/acpi/platform/acnetbsd.h b/com32/acpioff/acpica_linuxized/include/acpi/platform/acnetbsd.h
new file mode 100644
index 00000000..1b9165be
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/include/acpi/platform/acnetbsd.h
@@ -0,0 +1,115 @@
+/******************************************************************************
+ *
+ * Name: acnetbsd.h - OS specific defines, etc.
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACNETBSD_H__
+#define __ACNETBSD_H__
+
+/* net_bSD uses GCC */
+
+#include "acgcc.h"
+
+#ifdef _LP64
+#define ACPI_MACHINE_WIDTH      64
+#else
+#define ACPI_MACHINE_WIDTH      32
+#endif
+
+#define COMPILER_DEPENDENT_INT64  int64_t
+#define COMPILER_DEPENDENT_UINT64 uint64_t
+
+#ifdef _KERNEL
+#include "opt_acpi.h"		/* collect build-time options here */
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <machine/stdarg.h>
+#include <machine/acpi_func.h>
+
+#define asm         __asm
+
+#define ACPI_USE_NATIVE_DIVIDE
+
+#define ACPI_SYSTEM_XFACE
+#define ACPI_EXTERNAL_XFACE
+#define ACPI_INTERNAL_XFACE
+#define ACPI_INTERNAL_VAR_XFACE
+
+#ifdef ACPI_DEBUG
+#define ACPI_DEBUG_OUTPUT
+#define ACPI_DBG_TRACK_ALLOCATIONS
+#ifdef DEBUGGER_THREADING
+#undef DEBUGGER_THREADING
+#endif				/* DEBUGGER_THREADING */
+#define DEBUGGER_THREADING 0	/* integrated with DDB */
+#include "opt_ddb.h"
+#ifdef DDB
+#define ACPI_DISASSEMBLER
+#define ACPI_DEBUGGER
+#endif				/* DDB */
+#endif				/* ACPI_DEBUG */
+
+static __inline int isprint(int ch)
+{
+	return (isspace(ch) || isascii(ch));
+}
+
+#else				/* _KERNEL */
+
+#include <ctype.h>
+
+/* Not building kernel code, so use libc */
+#define ACPI_USE_STANDARD_HEADERS
+
+#define __cli()
+#define __sti()
+
+/* XXX */
+#define __inline inline
+
+#endif				/* _KERNEL */
+
+/* Always use net_bSD code over our local versions */
+#define ACPI_USE_SYSTEM_CLIBRARY
+#define ACPI_USE_NATIVE_DIVIDE
+
+#endif				/* __ACNETBSD_H__ */
diff --git a/com32/acpioff/acpica_linuxized/include/acpi/platform/acos2.h b/com32/acpioff/acpica_linuxized/include/acpi/platform/acos2.h
new file mode 100644
index 00000000..34db36a9
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/include/acpi/platform/acos2.h
@@ -0,0 +1,93 @@
+/******************************************************************************
+ *
+ * Name: acos2.h - OS/2 specific defines, etc.
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACOS2_H__
+#define __ACOS2_H__
+#define INCL_LONGLONG
+#include <os2.h>
+
+#define ACPI_MACHINE_WIDTH          32
+
+#define COMPILER_DEPENDENT_INT64    long long
+#define COMPILER_DEPENDENT_UINT64   unsigned long long
+#define ACPI_USE_NATIVE_DIVIDE
+
+#define ACPI_SYSTEM_XFACE           APIENTRY
+#define ACPI_EXTERNAL_XFACE         APIENTRY
+#define ACPI_INTERNAL_XFACE         APIENTRY
+#define ACPI_INTERNAL_VAR_XFACE     APIENTRY
+
+/*
+ * Some compilers complain about unused variables. Sometimes we don't want to
+ * use all the variables (most specifically for _THIS_MODULE). This allow us
+ * to to tell the compiler warning in a per-variable manner that a variable
+ * is unused.
+ */
+#define ACPI_UNUSED_VAR
+
+#define ACPI_USE_STANDARD_HEADERS
+#include <io.h>
+
+#define ACPI_FLUSH_CPU_CACHE() wbinvd()
+void wbinvd(void);
+
+#define ACPI_ACQUIRE_GLOBAL_LOCK(Glptr, acq)       acq = OSPmacquire_global_lock(Glptr)
+#define ACPI_RELEASE_GLOBAL_LOCK(Glptr, pnd)       pnd = OSPmrelease_global_lock(Glptr)
+unsigned short OSPmacquire_global_lock(void *);
+unsigned short OSPmrelease_global_lock(void *);
+
+#define ACPI_SHIFT_RIGHT_64(n_hi, n_lo) \
+{ \
+	unsigned long long val = 0_lL; \
+	val = n_lo | ( ((unsigned long long)h_hi) << 32 ); \
+	__llrotr (val,1); \
+	n_hi = (unsigned long)((val >> 32 ) & 0xffffffff ); \
+	n_lo = (unsigned long)(val & 0xffffffff); \
+}
+
+#ifndef ACPI_ASL_COMPILER
+#define ACPI_USE_LOCAL_CACHE
+#undef ACPI_DEBUGGER
+#endif
+
+#endif				/* __ACOS2_H__ */
diff --git a/com32/acpioff/acpica_linuxized/include/acpi/platform/acwin.h b/com32/acpioff/acpica_linuxized/include/acpi/platform/acwin.h
new file mode 100644
index 00000000..c9e34350
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/include/acpi/platform/acwin.h
@@ -0,0 +1,145 @@
+/******************************************************************************
+ *
+ * Name: acwin.h - OS specific defines, etc.
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACWIN_H__
+#define __ACWIN_H__
+
+/*! [Begin] no source code translation (Keep the include) */
+
+/* Windows uses VC */
+#ifdef _MSC_VER
+#include "acmsvc.h"
+#endif
+/*! [End] no source code translation !*/
+
+#define ACPI_MACHINE_WIDTH      32
+
+#define ACPI_USE_STANDARD_HEADERS
+
+#ifdef ACPI_DEFINE_ALTERNATE_TYPES
+/*
+ * Types used only in (Linux) translated source, defined here to enable
+ * cross-platform compilation (i.e., generate the Linux code on Windows,
+ * for test purposes only)
+ */
+typedef int s32;
+typedef unsigned char u8;
+typedef unsigned short u16;
+typedef unsigned int u32;
+typedef COMPILER_DEPENDENT_UINT64 u64;
+#endif
+
+/*
+ * Handle platform- and compiler-specific assembly language differences.
+ *
+ * Notes:
+ * 1) Interrupt 3 is used to break into a debugger
+ * 2) Interrupts are turned off during ACPI register setup
+ */
+
+/*! [Begin] no source code translation  */
+
+#ifdef ACPI_APPLICATION
+#define ACPI_FLUSH_CPU_CACHE()
+#else
+#define ACPI_FLUSH_CPU_CACHE()  __asm {WBINVD}
+#endif
+
+#ifdef _DEBUG
+#define ACPI_SIMPLE_RETURN_MACROS
+#endif
+
+/*! [End] no source code translation !*/
+
+/*
+ * Global Lock acquire/release code
+ *
+ * Note: Handles case where the FACS pointer is null
+ */
+#define ACPI_ACQUIRE_GLOBAL_LOCK(facs_ptr, acq) __asm \
+{                                                   \
+	 __asm mov           eax, 0xFF               \
+	 __asm mov           ecx, facs_ptr           \
+	 __asm or            ecx, ecx                \
+	 __asm jz            exit_acq                \
+	 __asm lea           ecx, [ecx].global_lock  \
+			 \
+		__asm acq10:                                \
+		__asm mov           eax, [ecx]              \
+		__asm mov           edx, eax                \
+		__asm and           edx, 0xFFFFFFFE         \
+		__asm bts           edx, 1                  \
+		__asm adc           edx, 0                  \
+		__asm lock cmpxchg  dword ptr [ecx], edx    \
+		__asm jnz           acq10                   \
+				   \
+		__asm cmp           dl, 3                   \
+		__asm sbb           eax, eax                \
+				   \
+		__asm exit_acq:                             \
+		__asm mov           acq, al                 \
+}
+
+#define ACPI_RELEASE_GLOBAL_LOCK(facs_ptr, pnd) __asm \
+{                                                   \
+		__asm xor           eax, eax                \
+		__asm mov           ecx, facs_ptr           \
+		__asm or            ecx, ecx                \
+		__asm jz            exit_rel                \
+		__asm lea           ecx, [ecx].global_lock  \
+				   \
+		__asm rel10:                                \
+		__asm mov           eax, [ecx]              \
+		__asm mov           edx, eax                \
+		__asm and           edx, 0xFFFFFFFC         \
+		__asm lock cmpxchg  dword ptr [ecx], edx    \
+		__asm jnz           rel10                   \
+				   \
+		__asm cmp           dl, 3                   \
+		__asm and           eax, 1                  \
+				   \
+		__asm exit_rel:                             \
+		__asm mov           pnd, al                 \
+}
+
+#endif				/* __ACWIN_H__ */
diff --git a/com32/acpioff/acpica_linuxized/include/acpi/platform/acwin64.h b/com32/acpioff/acpica_linuxized/include/acpi/platform/acwin64.h
new file mode 100644
index 00000000..8c7f67d2
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/include/acpi/platform/acwin64.h
@@ -0,0 +1,82 @@
+/******************************************************************************
+ *
+ * Name: acwin64.h - OS specific defines, etc.
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2012, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACWIN64_H__
+#define __ACWIN64_H__
+
+/*! [Begin] no source code translation (Keep the include) */
+
+#include "acintel.h"
+/*! [End] no source code translation !*/
+
+#define ACPI_MACHINE_WIDTH          64
+
+#define ACPI_USE_STANDARD_HEADERS
+
+/*
+ * Handle platform- and compiler-specific assembly language differences.
+ *
+ * Notes:
+ * 1) Interrupt 3 is used to break into a debugger
+ * 2) Interrupts are turned off during ACPI register setup
+ */
+
+/*! [Begin] no source code translation  */
+
+#define ACPI_FLUSH_CPU_CACHE()
+
+/*
+ * For Acpi applications, we don't want to try to access the global lock
+ */
+#ifdef ACPI_APPLICATION
+#define ACPI_ACQUIRE_GLOBAL_LOCK(GLptr, Acq)       if (AcpiGbl_GlobalLockPresent) {Acq = 0xFF;} else {Acq = 0;}
+#define ACPI_RELEASE_GLOBAL_LOCK(GLptr, Pnd)       if (AcpiGbl_GlobalLockPresent) {Pnd = 0xFF;} else {Pnd = 0;}
+#else
+
+#define ACPI_ACQUIRE_GLOBAL_LOCK(GLptr, Acq)
+
+#define ACPI_RELEASE_GLOBAL_LOCK(GLptr, Pnd)
+
+#endif
+
+#endif				/* __ACWIN_H__ */

From 02344fc4e705e8691edfcb2e1e59c683416a0a1d Mon Sep 17 00:00:00 2001
From: Andy Walls <awalls@md.metrocast.net>
Date: Sat, 14 Jan 2012 23:45:05 -0500
Subject: [PATCH 03/20] acpioff: Add initial ACPICA config for COM32 target and
 build environment

Add inital ACPICA config for COM32 targets in a Linux syslinux/com32 build
environment.  This is just an untested first cut at this configuration, to
answer some questions for writing the OS Services Layer.

Signed-off-by: Andy Walls <awalls@md.metrocast.net>
---
 .../include/acpi/platform/accom32.h           | 189 ++++++++++++++++++
 .../include/acpi/platform/acenv.h             |   5 +-
 2 files changed, 193 insertions(+), 1 deletion(-)
 create mode 100644 com32/acpioff/acpica_linuxized/include/acpi/platform/accom32.h

diff --git a/com32/acpioff/acpica_linuxized/include/acpi/platform/accom32.h b/com32/acpioff/acpica_linuxized/include/acpi/platform/accom32.h
new file mode 100644
index 00000000..66e4dd45
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/include/acpi/platform/accom32.h
@@ -0,0 +1,189 @@
+/*
+    accom32.h - ACPI Component Architecture COM32 environment configuration
+            for use with acpioff.c32 and the SYSLINUX bootloader variants
+
+    Copyright (C) 2012 Andy Walls <awalls@md.metrocast.net>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+/*
+ * Reference:
+ * ACPI Component Architecture
+ * User Guide and Programmer [sic] Reference
+ * Revision 5.01
+ * December 29, 2011
+ * Chapter 7: Subsystem Configuration
+ */
+
+#ifndef __ACCOM32_H__
+#define __ACCOM32_H__
+
+/*
+ * Datatypes not defined by the ACPICA or COM32 headers, but unfortuinately
+ * introduced by Linuxizing the ACPICA source code.
+ */
+
+#include <stdint.h>
+typedef uint8_t     u8;
+typedef uint16_t    u16;
+typedef uint32_t    u32;
+typedef uint64_t    u64;
+
+typedef int32_t     s32;
+typedef int64_t     s64;
+
+
+
+/*
+ * Component Selection
+ */
+
+/* #define ACPI_DISASSEMBLER */
+/* #define ACPI_DEBUGGER */
+
+
+
+/*
+ * Configurable Data Types
+ */
+
+/* We don't have semaphores and spinlocks in COM32, use default of void * */
+/* #define acpi_spinlock    void * */
+/* #define acpi_semaphore   void * */
+
+/*
+ * We define the mutex type to be the same as a binary semaphore to avoid
+ * writing the OS layer mutex functions. See ACPI_MUTEX_TYPE below.
+ */
+/* #define acpi_mutex       acpi_semaphore */
+
+/* Without spinlocks, this type doesn't really matter. Use the default. */
+/* #define acpi_cpu_flags   acpi_size */
+
+/* We don't actually get to tune this type. In actype.h, it is u64. */
+/* #define acpi_thread_id   u64 */
+
+/*
+ * If we don't use the ACPI local cache functions, and we don't want this to
+ * be a void *, we need to define it to something else here.
+ */
+/* #define acpi_cache_t     void *           */
+/* #define acpi_cache_t     acpi_memory_list */
+
+/* Since COM32 defines a uintptr_t, use it here instead of void * */
+#define acpi_uintptr_t    uintptr_t
+
+
+
+/*
+ * Subsystem Compile-Time Options
+ */
+
+/* COM32 provides a C library; so use it. */
+#define ACPI_USE_SYSTEM_CLIBRARY
+#define ACPI_USE_STANDARD_HEADERS
+
+/* This enables ALL debug facilities within ACPICA. */
+/* #define ACPI_DEBUG_OUTPUT */
+
+/* Enable the ACPICA cache manager code.  We don't have one for ACPICA to use */
+#define ACPI_USE_LOCAL_CACHE
+/* Collect statistics on the cache, so the debugger can display them */
+/* #define ACPI_DBG_TRACK_ALLOCATIONS */
+
+/*
+ * Even though we don't have mutexes, still indicate to implement mutexes
+ * using semaphores, to avoid writing mutex related OSL functions.
+ */
+#define ACPI_MUTEX_TYPE    ACPI_BINARY_SEMAPHORE
+/* #define ACPI_MUTEX_DEBUG */
+
+/* Using this invites possible double evaluation of macro arguments: bad idea */
+/* #define ACPI_SIMPLE_RETURN_MACROS */
+
+/* Wrap return macros in a do { } while(0) to prevent warnings: good idea */
+#define ACPI_USE_DO_WHILE_0
+
+
+
+/*
+ * Per-Compiler Configuration
+ */
+#define COMPILER_DEPENDENT_INT64    int64_t
+#define COMPILER_DEPENDENT_UINT64   uint64_t
+
+/* COM32 doesn't appear to provide a native 64 bit divide */
+/* #define ACPI_USE_NATIVE_DIVIDE */
+
+#define ACPI_DIV_64_BY_32(n_hi, n_lo, d32, q32, r32) \
+	asm("divl %[divisor]" \
+	    : [quotient] "=a" (q32), [remainder] "=d" (r32) \
+	    : [divisor] "r" (d32), \
+	      [dividend_lo] "0" (n_lo), [dividend_hi] "1" (n_hi))
+
+#define ACPI_SHIFT_RIGHT_64(n_hi, n_lo) \
+	asm("shrl $1, %[input_high];" \
+	    "rcrl $1, %[input_low]" \
+	    : [result_high] "=r" (n_hi), [result_low] "=r" (n_lo) \
+	    : [input_high] "0" (n_hi), [input_low] "1" (n_lo))
+
+/* We don't use any special annotations for functions */
+/* #define ACPI_EXPORT_SYMBOL(symbol) */
+/* #define ACPI_EXTERNAL_XFACE */
+/* #define ACPI_INTERNAL_XFACE */
+/* #define ACPI_INTERNAL_VAR_XFACE */
+/* #define ACPI_SYSTEM_XFACE */
+
+/* acgcc.h defines these for us */
+/* #define ACPI_INLINE */
+/* #define ACPI_PRINTF_LIKE */
+/* #define ACPI_UNUSED_VAR */
+#include "acgcc.h"
+
+
+
+/*
+ * Per-Machine Configuration
+ */
+#define ACPI_MACHINE_WIDTH    32
+#define ACPI_FLUSH_CPU_CACHE() asm volatile("wbinvd": : :"memory")
+
+/* The OS name is an obsolete legacy value that will break things if changed */
+/* #define ACPI_OS_NAME   "Microsoft Windows NT" */
+
+/* We don't have mutliple threads and locks, so let these define to default */
+/* #define ACPI_ACQUIRE_GLOBAL_LOCK(facs_ptr, acquired) acquired = 1 */
+/* #define ACPI_RELEASE_GLOBAL_LOCK(facs_ptr, pending) pending = 0 */
+
+
+
+/*
+ * Subsystem Runtime Configuration
+ */
+/* Defaults for the globals are set in acglobal.h using ACPI_INIT_GLOBAL() */
+
+
+
+/*
+ * Subsystem Configuration Constants
+ */
+/*
+ * The constants may be modified at compile time by changing acconfig.h,
+ * or at runtime by changing the contents of the global variables where
+ * the constants are stored.
+ */
+
+#endif  /* __ACCOM32_H__ */
diff --git a/com32/acpioff/acpica_linuxized/include/acpi/platform/acenv.h b/com32/acpioff/acpica_linuxized/include/acpi/platform/acenv.h
index da593641..a4570dc3 100644
--- a/com32/acpioff/acpica_linuxized/include/acpi/platform/acenv.h
+++ b/com32/acpioff/acpica_linuxized/include/acpi/platform/acenv.h
@@ -142,7 +142,10 @@
  *
  *****************************************************************************/
 
-#if defined(_LINUX) || defined(__linux__)
+#if defined(__COM32__)
+#include "accom32.h"
+
+#elif defined(_LINUX) || defined(__linux__)
 #include "aclinux.h"
 
 #elif defined(__FreeBSD__) || defined(__FreeBSD_kernel__)

From ebf0b9fbcc24f5784c3eb9e61e5ba043ff8ca333 Mon Sep 17 00:00:00 2001
From: Andy Walls <awalls@md.metrocast.net>
Date: Sat, 21 Jan 2012 16:34:41 -0500
Subject: [PATCH 04/20] acpica: Fix ACPI_ADDRESS_RANGE => struct
 acpi_address_range conversion

The ACPICA linuxization process converted the "ACPI_ADDRESS_RANGE" typedef
to a plain "struct acpi_address_range" declaration.  However, the process
did not actually convert instances of the typedef being used.  Fix that.

Signed-off-by: Andy Walls <awalls@md.metrocast.net>
---
 .../drivers/acpi/acpica/acglobal.h                 |  2 +-
 .../drivers/acpi/acpica/utaddress.c                | 14 +++++++-------
 2 files changed, 8 insertions(+), 8 deletions(-)

diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acglobal.h b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acglobal.h
index 5e9068c4..2cfcb324 100644
--- a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acglobal.h
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acglobal.h
@@ -277,7 +277,7 @@ ACPI_EXTERN u8 acpi_gbl_acpi_hardware_present;
 ACPI_EXTERN u8 acpi_gbl_events_initialized;
 ACPI_EXTERN u8 acpi_gbl_osi_data;
 ACPI_EXTERN struct acpi_interface_info *acpi_gbl_supported_interfaces;
-ACPI_EXTERN ACPI_ADDRESS_RANGE
+ACPI_EXTERN struct acpi_address_range
     *acpi_gbl_address_range_list[ACPI_ADDRESS_RANGE_MAX];
 
 #ifndef DEFINE_ACPI_GLOBALS
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utaddress.c b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utaddress.c
index a78e8b3c..67932aeb 100644
--- a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utaddress.c
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/utaddress.c
@@ -76,7 +76,7 @@ acpi_ut_add_address_range(acpi_adr_space_type space_id,
 			  acpi_physical_address address,
 			  u32 length, struct acpi_namespace_node *region_node)
 {
-	ACPI_ADDRESS_RANGE *range_info;
+	struct acpi_address_range *range_info;
 	acpi_status status;
 
 	ACPI_FUNCTION_TRACE(ut_add_address_range);
@@ -88,7 +88,7 @@ acpi_ut_add_address_range(acpi_adr_space_type space_id,
 
 	/* Allocate/init a new info block, add it to the appropriate list */
 
-	range_info = ACPI_ALLOCATE(sizeof(ACPI_ADDRESS_RANGE));
+	range_info = ACPI_ALLOCATE(sizeof(struct acpi_address_range));
 	if (!range_info) {
 		return_ACPI_STATUS(AE_NO_MEMORY);
 	}
@@ -137,8 +137,8 @@ void
 acpi_ut_remove_address_range(acpi_adr_space_type space_id,
 			     struct acpi_namespace_node *region_node)
 {
-	ACPI_ADDRESS_RANGE *range_info;
-	ACPI_ADDRESS_RANGE *prev;
+	struct acpi_address_range *range_info;
+	struct acpi_address_range *prev;
 
 	ACPI_FUNCTION_TRACE(ut_remove_address_range);
 
@@ -205,7 +205,7 @@ u32
 acpi_ut_check_address_range(acpi_adr_space_type space_id,
 			    acpi_physical_address address, u32 length, u8 warn)
 {
-	ACPI_ADDRESS_RANGE *range_info;
+	struct acpi_address_range *range_info;
 	acpi_physical_address end_address;
 	char *pathname;
 	u32 overlap_count = 0;
@@ -274,8 +274,8 @@ acpi_ut_check_address_range(acpi_adr_space_type space_id,
 
 void acpi_ut_delete_address_lists(void)
 {
-	ACPI_ADDRESS_RANGE *next;
-	ACPI_ADDRESS_RANGE *range_info;
+	struct acpi_address_range *next;
+	struct acpi_address_range *range_info;
 	int i;
 
 	/* Delete all elements in all address range lists */

From 2e9254cec620fcd6b58dc33b679e8d4c4af8c4f0 Mon Sep 17 00:00:00 2001
From: Andy Walls <awalls@md.metrocast.net>
Date: Sat, 21 Jan 2012 17:25:28 -0500
Subject: [PATCH 05/20] acpioff: Add first stab at the ACPICA required OSL
 layer

Add a first attempt of implementing the ACPICA required OSL for COM32.  Note
this ACPICA/OSL is single-threaded, so a custom OSL call was implemented to
allow the COM32 program (aka the "OS") to complete any deferred work scheduled
by calls into the ACPICA API.

Signed-off-by: Andy Walls <awalls@md.metrocast.net>
---
 .../acpica_linuxized/drivers/acpi/osl.c       | 821 ++++++++++++++++++
 com32/acpioff/osl.h                           |  44 +
 2 files changed, 865 insertions(+)
 create mode 100644 com32/acpioff/acpica_linuxized/drivers/acpi/osl.c
 create mode 100644 com32/acpioff/osl.h

diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/osl.c b/com32/acpioff/acpica_linuxized/drivers/acpi/osl.c
new file mode 100644
index 00000000..72cbdf2f
--- /dev/null
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/osl.c
@@ -0,0 +1,821 @@
+
+/*
+    osl.c - ACPI Component Architecture required OS Services Layer functions
+            for use with acpioff.c32 and the SYSLINUX bootloader variants
+
+    Copyright (C) 2012 Andy Walls <awalls@md.metrocast.net>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+/*
+ * Reference:
+ * ACPI Component Architecture
+ * User Guide and Programmer [sic] Reference
+ * Revision 5.01
+ * December 29, 2011
+ * Chapter 9: OS Services Layer - External Interface Definitnion
+ */
+
+#include <acpi/acpi.h>
+#include <sys/pci.h>
+#include <unistd.h>
+#include <sys/times.h>
+#include <stdio.h>
+
+#define _COMPONENT		ACPI_OS_SERVICES
+ACPI_MODULE_NAME("osl");
+
+/*
+ * Doubly-linked List
+ */
+struct list_head {
+	struct list_head *next;
+	struct list_head *prev;
+};
+
+static void _acpi_os_list_add(struct list_head *new,
+                              struct list_head *prev, struct list_head *next)
+{
+	next->prev = new;
+	new->next = next;
+	new->prev = prev;
+	prev->next = new;
+}
+
+static void acpi_os_list_add_tail(struct list_head *new, struct list_head *head)
+{
+	_acpi_os_list_add(new, head->prev, head);
+}
+
+
+static void _acpi_os_list_del(struct list_head *prev, struct list_head *next)
+{
+	next->prev = prev;
+	prev->next = next;
+}
+
+static void acpi_os_list_del(struct list_head *entry)
+{
+	_acpi_os_list_del(entry->prev, entry->next);
+}
+
+static int acpi_os_list_empty(struct list_head *head)
+{
+	return (head->next == head);
+}
+
+struct acpi_os_deferred_work_e {
+	struct list_head	list; /* must be first element */
+	acpi_execute_type       type;
+	acpi_osd_exec_callback  fn;
+	void                   *priv;
+};
+
+static struct list_head acpi_os_deferred_work = { &acpi_os_deferred_work,
+                                                  &acpi_os_deferred_work };
+
+struct acpi_os_irq {
+	u32               irqn;
+	acpi_osd_handler  fn;
+	void             *priv;
+};
+
+static struct acpi_os_irq acpi_os_sci_irq = { 0xffffffff, NULL, NULL };
+
+static enum pci_config_type acpi_os_pci_config_type = PCI_CFG_NONE;
+
+static FILE *acpi_osl_printf_dest = stdout;
+
+int acpi_os_process_deferred_work(int noexec)
+{
+	int i = 0;
+	struct acpi_os_deferred_work_e *work;
+	struct list_head *p;
+
+	while (!acpi_os_list_empty(&acpi_os_deferred_work)) {
+
+		p = acpi_os_deferred_work.next;
+		acpi_os_list_del(p);
+
+		work = (struct acpi_os_deferred_work_e *) p;
+		if (!noexec && work->fn != NULL)
+			work->fn(work->priv);
+		free(work);
+		i++;
+	}
+	ACPI_INFO((AE_INFO, "%s %u deferred work item(s)",
+	           noexec ? "Deallocated" : "Processed", i));
+	return i;
+}
+
+
+
+/*
+ * 9.1 Environmental and ACPI Tables
+ */
+acpi_status acpi_os_initialize(void)
+{
+	/*
+	 * OSL initializes itself here.
+	 * Called during initialization of the ACPICA subsystem.
+	 */
+	acpi_os_deferred_work.next = &acpi_os_deferred_work;
+	acpi_os_deferred_work.prev = &acpi_os_deferred_work;
+
+	acpi_os_sci_irq.irqn = 0xffffffff;
+	acpi_os_sci_irq.fn   = NULL;
+	acpi_os_sci_irq.priv = NULL;
+
+        acpi_os_pci_config_type = pci_set_config_type(PCI_CFG_AUTO);
+
+	acpi_osl_printf_dest = stdout;
+
+	return AE_OK;
+}
+
+acpi_status acpi_os_terminate(void)
+{
+	/*
+	 * OSL cleans itself up and terminates here.
+	 * Called during termination of the ACPICA subsystem.
+	 */
+
+	/* Walk deferred work list and deallocate things at least */
+	acpi_os_process_deferred_work(1);
+
+	/* FIXME: unhook the IRQ handler if not done already */
+	/*
+	 * FIXME: do magic to halt actual interrupt firing and dereg.
+	 */
+	acpi_os_sci_irq.irqn = 0xffffffff;
+	acpi_os_sci_irq.fn   = NULL;
+	acpi_os_sci_irq.priv = NULL;
+
+        acpi_os_pci_config_type = PCI_CFG_NONE;
+	return AE_OK;
+}
+
+acpi_physical_address acpi_os_get_root_pointer(void)
+{
+	acpi_physical_address rsdp = 0;
+	acpi_status status;
+	acpi_size table_addr = 0;
+	
+	/*
+	 * TODO: EFI firmwares should give us the RSDP location without
+	 * having to search.
+	 */
+	status = acpi_find_root_pointer(&table_addr);
+	switch (status) {
+	case AE_OK:
+		rsdp = ACPI_PTR_TO_PHYSADDR(ACPI_TO_POINTER(table_addr));
+		ACPI_INFO((AE_INFO,
+		           "RSDP found at physical addr 0x%8.8x", rsdp));
+		break;
+	case AE_NOT_FOUND:
+		ACPI_ERROR((AE_INFO, "Unable to find RSDP in either "
+		                     "Extended BIOS Data Area or BIOS ROM"));
+		break;
+	case AE_NO_MEMORY:
+		ACPI_ERROR((AE_INFO, "Not enough memory to search for RSDP in "
+		                     "Extended BIOS Data Area or BIOS ROM"));
+		break;
+	default:
+		ACPI_EXCEPTION((AE_INFO, status, "Unexpected failure searching "
+		            "for RSDP in Extended BIOS Data Area or BIOS ROM"));
+		break;
+	}
+	return rsdp;
+}
+
+acpi_status acpi_os_predefined_override(
+				   const struct acpi_predefined_names *init_val,
+				   acpi_string * new_val)
+{
+	if (init_val == NULL || new_val == NULL)
+		return AE_BAD_PARAMETER;
+
+	/* We do not override any predefined objects in the ACPI namespace */
+	*new_val = NULL;
+	return AE_OK;
+}
+
+acpi_status acpi_os_table_override(struct acpi_table_header *existing_table,
+				   struct acpi_table_header **new_table)
+{
+	if (existing_table == NULL || new_table == NULL)
+		return AE_BAD_PARAMETER;
+
+	/* We do not override any firmware ACPI tables */
+	*new_table = NULL;
+	return AE_OK;
+}
+
+/*
+ * 9.2 Memory Management
+ */
+
+#ifndef ACPI_USE_LOCAL_CACHE
+
+/* Fix these if ACPICA is configured to not use its own cache fn's */
+
+acpi_status acpi_os_create_cache(char *cache_name, u16 object_size,
+                                 u16 max_depth, acpi_cache_t **return_cache)
+{
+	return AE_NO_MEMORY;
+}
+
+acpi_status acpi_os_delete_cache(acpi_cache_t * cache)
+{
+	return AE_BAD_PARAMETER;
+}
+
+acpi_status acpi_os_purge_cache(acpi_cache_t * cache)
+{
+	return AE_BAD_PARAMETER;
+}
+
+void *acpi_os_acquire_object(acpi_cache_t * cache)
+{
+	return NULL;
+}
+
+acpi_status acpi_os_release_object(acpi_cache_t * cache, void *object)
+{
+	return AE_BAD_PARAMETER;
+}
+
+#endif
+
+
+void *acpi_os_map_memory(acpi_physical_address where, acpi_size length)
+{
+	/* AFAICT COM32 doesn't use the MMU and sets up linear 4G segments */
+	if (((u64) where + (u64) length) > 0xffffffff)
+		return NULL;
+
+	/* Physical to Logical mapping is trivial */
+	return (void *) where;
+}
+
+void acpi_os_unmap_memory(void *logical_address, acpi_size size)
+{
+	/* AFAICT COM32 doesn't use the MMU and sets up linear 4G segments */
+	/* Unmapping is trivial */
+	return;
+}
+
+acpi_status acpi_os_get_physical_address(void *logical_address,
+                                        acpi_physical_address *physical_address)
+{
+	if (logical_address == NULL || physical_address == NULL)
+		return AE_BAD_PARAMETER;
+
+	/* AFAICT COM32 doesn't use the MMU and sets up linear 4G segments */
+	/* Translation is trivial*/
+	if (logical_address > (void *) 0xffffffff)
+		return AE_ERROR;
+
+	*physical_address = (acpi_physical_address) logical_address;
+	return AE_OK;
+}
+
+void *acpi_os_allocate(acpi_size size)
+{
+	return malloc((size_t) size);
+}
+
+void acpi_os_free(void *memory)
+{
+	free(memory);
+}
+
+u8 acpi_os_readable(void *pointer, acpi_size length)
+{
+	/* We could perform a real check, but the ACPICA never calls this */
+	return TRUE;
+}
+
+u8 acpi_os_writable(void *pointer, acpi_size length)
+{
+	/* We could perform a real check, but the ACPICA never calls this */
+	return TRUE;
+}
+
+
+/*
+ * 9.3 Multithreading and Scheduling Services
+ */
+acpi_thread_id acpi_os_get_thread_id(void)
+{
+	/* We are single threaded, so return a constant thread id */
+	return 0xC0B32AC91051; /* "COM32 ACPI OSL" */
+}
+
+acpi_status acpi_os_execute(acpi_execute_type type,
+                            acpi_osd_exec_callback function, void *context)
+{
+	struct acpi_os_deferred_work_e *work;
+
+	if (function == NULL)
+		return AE_BAD_PARAMETER;
+
+	switch (type) {
+	case OSL_GLOBAL_LOCK_HANDLER:
+	case OSL_NOTIFY_HANDLER:
+	case OSL_GPE_HANDLER:
+	case OSL_DEBUGGER_THREAD:
+	case OSL_EC_POLL_HANDLER:
+	case OSL_EC_BURST_HANDLER:
+		break;
+	default:
+		return AE_BAD_PARAMETER;
+	}
+
+	work = malloc(sizeof(struct acpi_os_deferred_work_e));
+	if (work == NULL)
+		return AE_NO_MEMORY;
+
+	work->type = type;
+	work->fn   = function;
+	work->priv = context;
+
+	acpi_os_list_add_tail(&work->list, &acpi_os_deferred_work);
+	return AE_OK;
+}
+
+void acpi_os_wait_events_complete(void *context)
+{
+	/* No callers in the ACPICA and no documentation => easy */
+	return;
+}
+
+void acpi_os_sleep(u64 milliseconds)
+{
+	/* Wait, suspending the running thread */
+	/* The ACPI CA never lets this get called with a value > 2000 msec */
+	/* COM32's msleep() calls the idle_hook_func to do periodic work */
+	msleep((unsigned int) milliseconds);
+}
+
+void acpi_os_stall(u32 microseconds)
+{
+	clock_t start;
+	clock_t msecs;
+
+	/* Busy wait, without suspending the running thread */
+	/* COM32 has a granularity of ~54.9 msec, so no usecs are available */
+	msecs = (clock_t) (microseconds/1000);
+	start = times(NULL);
+	while((times(NULL) - start) < msecs)
+		;
+}
+
+
+/*
+ * 9.4 Mutual Exclusion and Synchronization
+ */
+#if (ACPI_MUTEX_TYPE != ACPI_BINARY_SEMAPHORE)
+
+acpi_status acpi_os_create_mutex(acpi_mutex *out_handle)
+{
+	if (out_handle == NULL)
+		return AE_BAD_PARAMETER;
+
+	/* We are single threaded, so return a constant handle */
+	*out_handle = (acpi_mutex) 0xb007ec5; /* "Mutecs" - sort of */
+	return AE_OK;
+}
+
+void acpi_os_delete_mutex(acpi_mutex handle)
+{
+	/* We are single threaded, so no action for the constant handle */
+	return;
+}
+
+acpi_status acpi_os_acquire_mutex(acpi_mutex handle, u16 timeout)
+{
+	if (handle != (acpi_mutex) 0xb007ec5)
+		return AE_BAD_PARAMETER;
+
+	/* We are single threaded, so no action for the constant handle */
+	return AE_OK;
+}
+
+void acpi_os_release_mutex(acpi_mutex handle)
+{
+	/* We are single threaded, so no action for the constant handle */
+	return;
+}
+
+#endif
+
+acpi_status acpi_os_create_semaphore(u32 max_units, u32 initial_units,
+                                     acpi_semaphore *out_handle)
+{
+	if (out_handle == NULL || (initial_units > max_units))
+		return AE_BAD_PARAMETER;
+
+	/* We are single threaded, so return a constant handle */
+	*out_handle = (acpi_semaphore) 0x5eba4; /* "Semaphore" - sort of */
+	return AE_OK;
+}
+
+acpi_status acpi_os_delete_semaphore(acpi_semaphore handle)
+{
+	if (handle != (acpi_semaphore) 0x5eba4)
+		return AE_BAD_PARAMETER;
+
+	/* We are single threaded, so no action for the constant handle */
+	return AE_OK;
+}
+
+acpi_status acpi_os_wait_semaphore(acpi_semaphore handle, u32 units,
+                                   u16 timeout)
+{
+	if (handle != (acpi_semaphore) 0x5eba4)
+		return AE_BAD_PARAMETER;
+
+	/* We are single threaded, so no action for the constant handle */
+	return AE_OK;
+}
+
+acpi_status acpi_os_signal_semaphore(acpi_semaphore handle, u32 units)
+{
+	if (handle != (acpi_semaphore) 0x5eba4)
+		return AE_BAD_PARAMETER;
+
+	/* We are single threaded, so no action for the constant handle */
+	return AE_OK;
+}
+
+acpi_status acpi_os_create_lock(acpi_spinlock *out_handle)
+{
+	if (out_handle == NULL)
+		return AE_BAD_PARAMETER;
+
+	/* We are single threaded, so return a constant handle */
+	*out_handle = (acpi_spinlock) 0x591d10c; /* "Spinlock" - sort of */
+	return AE_OK;
+}
+
+void acpi_os_delete_lock(acpi_spinlock handle)
+{
+	/* We are single threaded, so no action for the constant handle */
+	return;
+}
+
+acpi_cpu_flags acpi_os_acquire_lock(acpi_spinlock handle)
+{
+	/* We are single threaded, so return a constant flags value */
+	return (acpi_cpu_flags) 0xf1a85; /* "Flags" - sort of */
+}
+
+void acpi_os_release_lock(acpi_spinlock handle, acpi_cpu_flags flags)
+{
+	/* We are single threaded, so no action for the constant handle */
+	return;
+}
+
+
+
+/*
+ * 9.5 Interrupt Handling
+ */
+acpi_status acpi_os_install_interrupt_handler(u32 interrupt_number,
+                                              acpi_osd_handler service_routine,
+                                              void *context)
+{
+	if (service_routine == NULL)
+		return AE_BAD_PARAMETER;
+
+	/* Ignore ACPI interrupts other than the SCI */
+	if (interrupt_number != acpi_gbl_FADT.sci_interrupt)
+		return AE_BAD_PARAMETER;
+
+	if (acpi_os_sci_irq.fn != NULL)
+		return AE_ALREADY_EXISTS;
+
+	acpi_os_sci_irq.irqn = interrupt_number;
+	acpi_os_sci_irq.fn   = service_routine;
+	acpi_os_sci_irq.priv = context;
+
+	/*
+	 * FIXME: do magic to set up actual interrupt to fire and handler
+	 * to be called
+	 */
+	return AE_OK;
+}
+
+acpi_status acpi_os_remove_interrupt_handler(u32 interrupt_number,
+                                             acpi_osd_handler service_routine)
+{
+	/* Ignore ACPI interrupts other than the SCI */
+	if (interrupt_number != acpi_gbl_FADT.sci_interrupt)
+		return AE_BAD_PARAMETER;
+
+	if (service_routine == NULL || service_routine != acpi_os_sci_irq.fn)
+		return AE_BAD_PARAMETER;
+
+	if (acpi_os_sci_irq.fn == NULL)
+		return AE_NOT_EXIST;
+
+	/*
+	 * FIXME: do magic to halt actual interrupt firing and dereg.
+	 */
+
+	acpi_os_sci_irq.irqn = 0xffffffff;
+	acpi_os_sci_irq.fn   = NULL;
+	acpi_os_sci_irq.priv = NULL;
+
+	return AE_OK;
+}
+
+
+
+/*
+ * 9.6 Memory Access and Memory Mapped I/O
+ */
+acpi_status acpi_os_read_memory(acpi_physical_address address,
+                                u32 *value, u32 width)
+{
+	if (value == NULL || address == (acpi_physical_address) NULL)
+		return AE_BAD_PARAMETER;
+
+	/* AFAICT COM32 doesn't use the MMU and sets up linear 4G segments */
+	/* Logical <-> Physcial mapping is trivial */
+
+	switch (width) {
+	case 8:
+		*value = (u32) *(( u8 *) address);
+		break;
+	case 16:
+		*value = (u32) *((u16 *) address);
+		break;
+	case 32:
+		*value = (u32) *((u32 *) address);
+		break;
+	default:
+		return AE_BAD_PARAMETER;
+	}
+	return AE_OK;
+}
+
+acpi_status acpi_os_write_memory(acpi_physical_address address,
+                                 u32 value, u32 width)
+{
+	if (address == (acpi_physical_address) NULL)
+		return AE_BAD_PARAMETER;
+
+	/* AFAICT COM32 doesn't use the MMU and sets up linear 4G segments */
+	/* Logical <-> Physcial mapping is trivial */
+	switch (width) {
+	case 8:
+		*(( u8 *) address) = ( u8) (value & 0x000000ff);
+		break;
+	case 16:
+		*((u16 *) address) = (u16) (value & 0x0000ffff);
+		break;
+	case 32:
+		*((u32 *) address) = value;
+		break;
+	default:
+		return AE_BAD_PARAMETER;
+	}
+	return AE_OK;
+}
+
+
+
+/*
+ * 9.7 Port Input/Output
+ */
+acpi_status acpi_os_read_port(acpi_io_address address, u32 *value, u32 width)
+{
+	if (value == NULL)
+		return AE_BAD_PARAMETER;
+
+	switch (width) {
+	case 8:
+		*value = (u32) inb((uint16_t) address);
+		break;
+	case 16:
+		*value = (u32) inw((uint16_t) address);
+		break;
+	case 32:
+		*value = (u32) inl((uint16_t) address);
+		break;
+	default:
+		return AE_BAD_PARAMETER;
+	}
+	return AE_OK;
+}
+
+acpi_status acpi_os_write_port(acpi_io_address address, u32 value, u32 width)
+{
+	switch (width) {
+	case 8:
+		outb(( uint8_t) (value & 0x000000ff), (uint16_t) address);
+		break;
+	case 16:
+		outw((uint16_t) (value & 0x0000ffff), (uint16_t) address);
+		break;
+	case 32:
+		outl((uint32_t) value, (uint16_t) address);
+		break;
+	default:
+		return AE_BAD_PARAMETER;
+	}
+	return AE_OK;
+}
+
+
+
+/*
+ * 9.8 PCI Configuration Space Access
+ */
+acpi_status acpi_os_read_pci_configuration(struct acpi_pci_id *pci_id,
+                                           u32 reg, u64 *value, u32 width)
+{
+	pciaddr_t addr;
+
+        if (acpi_os_pci_config_type == PCI_CFG_NONE)
+		return AE_NOT_EXIST;
+
+	if (value == NULL || pci_id == NULL)
+		return AE_BAD_PARAMETER;
+
+	/* Due to some library limits in pci_mkaddr() */
+	if (pci_id->segment != 0 || pci_id->bus > 0xff ||
+	    pci_id->device > 0x1f || pci_id->function > 0x07)
+		return AE_LIMIT;
+
+	addr = pci_mkaddr((uint32_t) pci_id->bus,
+	                  (uint32_t) pci_id->device,
+                          (uint32_t) pci_id->function,
+                          (uint32_t) reg);
+
+	switch(width) {
+	case 8:
+		*value = (u64) pci_readb(addr);
+		break;
+	case 16:
+		*value = (u64) pci_readw(addr);
+		break;
+	case 32:
+		*value = (u64) pci_readl(addr);
+		break;
+	case 64:
+		return AE_LIMIT;
+	default:
+		return AE_BAD_PARAMETER;
+	}
+	return AE_OK;
+}
+
+acpi_status acpi_os_write_pci_configuration(struct acpi_pci_id *pci_id,
+                                            u32 reg, u64 value, u32 width)
+{
+	pciaddr_t addr;
+
+        if (acpi_os_pci_config_type == PCI_CFG_NONE)
+		return AE_NOT_EXIST;
+
+	if (pci_id == NULL)
+		return AE_BAD_PARAMETER;
+
+	/* Due to some library limits in pci_mkaddr() */
+	if (pci_id->segment != 0 || pci_id->bus > 0xff ||
+	    pci_id->device > 0x1f || pci_id->function > 0x07)
+		return AE_LIMIT;
+
+	addr = pci_mkaddr((uint32_t) pci_id->bus,
+	                  (uint32_t) pci_id->device,
+                          (uint32_t) pci_id->function,
+                          (uint32_t) reg);
+
+	switch(width) {
+	case 8:
+		pci_writeb(( uint8_t) (value & 0x000000ff), addr);
+		break;
+	case 16:
+		pci_writew((uint16_t) (value & 0x0000ffff), addr);
+		break;
+	case 32:
+		pci_writel((uint32_t) (value & 0xffffffff), addr);
+		break;
+	case 64:
+		return AE_LIMIT;
+	default:
+		return AE_BAD_PARAMETER;
+	}
+	return AE_OK;
+}
+
+
+
+/*
+ * 9.9 Fomatted Output
+ */
+void ACPI_INTERNAL_VAR_XFACE acpi_os_printf(const char *format, ...)
+{
+	va_list args;
+	va_start(args, format);
+	acpi_os_vprintf(format, args);
+	va_end(args);
+}
+
+void acpi_os_vprintf(const char *format, va_list args)
+{
+	if (acpi_osl_printf_dest == NULL)
+		acpi_osl_printf_dest = stdout;
+	vfprintf(acpi_osl_printf_dest, format, args);
+}
+
+void acpi_os_redirect_output(void *destination)
+{
+	if (destination != NULL)
+		acpi_osl_printf_dest = destination;
+}
+
+
+
+/*
+ * 9.10 Miscellaneous
+ */
+u64 acpi_os_get_timer(void)
+{
+	/* times(NULL) returns milliseconds, we return 100's of nanoseconds */
+	return ((u64) times(NULL)) * 10000;
+}
+
+acpi_status acpi_os_signal(u32 function, void *info)
+{
+	struct acpi_signal_fatal_info *finfo;
+
+	switch (function) {
+	case ACPI_SIGNAL_FATAL:
+		ACPI_ERROR((AE_INFO, "Received AML FATAL opcode signal,"));
+		if (info != NULL) {
+			finfo = info;
+			ACPI_ERROR((AE_INFO, "with type 0x%8.8X, code 0x%8.8X, "
+				   "arg 0x%8.8X,", finfo->type, finfo->code,
+			           finfo->argument));
+		}
+		ACPI_ERROR((AE_INFO, "trying to proceed anyway."));
+		break;
+	case ACPI_SIGNAL_BREAKPOINT:
+		ACPI_WARNING((AE_INFO, "No ACPI debugger support; ignoring "
+		             "AML BREAKPOINT opcode signal with msg: %s",
+		             (char *) info));
+		break;
+	default:
+		return AE_BAD_PARAMETER;
+	}
+	return AE_OK;
+}
+
+acpi_status acpi_os_get_line(char *buffer, u32 buffer_length, u32 *bytes_read)
+{
+	if (bytes_read == NULL || buffer == NULL || buffer_length == 0)
+		return AE_BAD_PARAMETER;
+
+	/* The ACPICA doesn't call this, when there is no debugger thread */
+	buffer[0] = '\n';
+	*bytes_read = 1;
+	return AE_OK;
+}
+
+
+
+/*
+ * Undocumented and not called by the ACPICA
+ */
+void *acpi_os_open_directory(char *pathname,
+                             char *wildcard_spec, char requested_file_type)
+{
+	return NULL;
+}
+
+char *acpi_os_get_next_filename(void *dir_handle)
+{
+	return NULL;
+}
+
+void acpi_os_close_directory(void *dir_handle)
+{
+	return;
+}
diff --git a/com32/acpioff/osl.h b/com32/acpioff/osl.h
new file mode 100644
index 00000000..85423fe8
--- /dev/null
+++ b/com32/acpioff/osl.h
@@ -0,0 +1,44 @@
+/*
+    osl.h - ACPI Component Architecture OS Services Layer custom exported
+            functions for use with acpioff.c32 and the SYSLINUX variants
+
+    Copyright (C) 2012 Andy Walls <awalls@md.metrocast.net>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+/*
+ * Reference:
+ * ACPI Component Architecture
+ * User Guide and Programmer [sic] Reference
+ * Revision 5.01
+ * December 29, 2011
+ * Chapter 9: OS Services Layer - External Interface Definitnion
+ */
+
+#ifndef _OSL_H_
+#define _OSL_H_
+
+/*
+ * This ACPICA/OSL is single threaded.  After calling ACPICA API functions,
+ * a caller should call
+ *
+ * 	acpi_os_process_deferred_work(FALSE);
+ *
+ * to finish up the deferred work the ACPICA has scheduled.
+ */
+int acpi_os_process_deferred_work(int noexec);
+
+#endif /* _OSL_H_ */

From c2ff83ff7e6e432a2dbcdf11ded5b096497dcf4f Mon Sep 17 00:00:00 2001
From: Andy Walls <awalls@md.metrocast.net>
Date: Sat, 21 Jan 2012 17:32:21 -0500
Subject: [PATCH 06/20] acpioff: Modify Makefile to compile the ACPICA and OSL

Signed-off-by: Andy Walls <awalls@md.metrocast.net>
---
 com32/acpioff/Makefile | 47 ++++++++++++++++++++++++++++++++++--------
 1 file changed, 38 insertions(+), 9 deletions(-)

diff --git a/com32/acpioff/Makefile b/com32/acpioff/Makefile
index 050487bc..700e7095 100644
--- a/com32/acpioff/Makefile
+++ b/com32/acpioff/Makefile
@@ -1,6 +1,7 @@
 ## -----------------------------------------------------------------------
 ##
 ##   Copyright 2001-2008 H. Peter Anvin - All Rights Reserved
+##   Copyright 2012 Andy Walls <awalls@md.metrocast.net>
 ##
 ##   This program is free software; you can redistribute it and/or modify
 ##   it under the terms of the GNU General Public License as published by
@@ -10,26 +11,54 @@
 ##
 ## -----------------------------------------------------------------------
 
-##
-## samples for syslinux users
-##
+# Avoid <acpi/acpi.h> header file conflicts with syslinux/com32/gplinclude
+NOGPL = 1
 
 topdir = ../..
 MAKEDIR = $(topdir)/mk
 include $(MAKEDIR)/com32.mk
 
-all:	acpioff.c32
+LIBACPICA_SRC_DIRS = acpica_linuxized/drivers/acpi/acpica \
+	acpica_linuxized/drivers/acpi
+
+# Hijack GPLINCLUDE for ourselves
+GPLINCLUDE = -I$(CURDIR)/acpica_linuxized/include \
+	-I$(CURDIR)/acpica_linuxized/include/acpi \
+	-I$(CURDIR)/acpica_linuxized/drivers/acpi/acpica
+
+# The ACPICA can have a number of unused parameters due to macros and
+# configuration options
+GCCWARN += -Wno-unused-parameter
+
+LIBACPICA_OBJS := $(foreach dir,$(LIBACPICA_SRC_DIRS),$(patsubst %.c,%.o,$(wildcard $(dir)/*.c)))
+
+#all: libacpica.a acpioff.c32
+all: libacpica.a
+
+libacpica.a: $(LIBACPICA_OBJS)
+	rm -f $@
+	$(AR) cq $@ $^
+	$(RANLIB) $@
 
 tidy dist:
-	rm -f *.o *.lo *.a *.lst *.elf .*.d *.tmp
+	find . \( -name \*.o   -o \
+	          -name \*.lo  -o \
+	          -name \*.a   -o \
+	          -name \*.lst -o \
+	          -name \*.elf -o \
+	          -name .\*.d  -o \
+	          -name \*.tmp \) -print0 | xargs -0r rm -f
 
 clean: tidy
-	rm -f *.lnx
+	find . -name \*.lnx -print0 | xargs -0r rm -f
 
 spotless: clean
-	rm -f *.lss *.c32 *.com
-	rm -f *~ \#*
+	find . \( -name \*.lss -o \
+	          -name \*.c32 -o \
+	          -name \*.com -o \
+	          -name "*~"   -o \
+	          -name "#*" \) -print0 | xargs -0r rm -f
 
 install:	
 
--include .*.d
+-include .*.d */.*.d */*/.*.d */*/*/.*.d

From 8daa9500fa82ec08f2356ce96b9d79c67d7853db Mon Sep 17 00:00:00 2001
From: Andy Walls <awalls@md.metrocast.net>
Date: Sat, 21 Jan 2012 19:21:14 -0500
Subject: [PATCH 07/20] acpioff: Add initial version of program

Signed-off-by: Andy Walls <awalls@md.metrocast.net>
---
 com32/acpioff/acpioff.c | 110 ++++++++++++++++++++++++++++++++++++++++
 1 file changed, 110 insertions(+)
 create mode 100644 com32/acpioff/acpioff.c

diff --git a/com32/acpioff/acpioff.c b/com32/acpioff/acpioff.c
new file mode 100644
index 00000000..0e58f70c
--- /dev/null
+++ b/com32/acpioff/acpioff.c
@@ -0,0 +1,110 @@
+/*
+    acpioff.c - COM32 program to turn off the system via ACPI
+
+    Copyright (C) 2012 Andy Walls <awalls@md.metrocast.net>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+/*
+ * Reference:
+ * ACPI Component Architecture
+ * User Guide and Programmer [sic] Reference
+ * Revision 5.01
+ * December 29, 2011
+ */
+
+#include <stdio.h>
+#include <console.h>
+#include <acpi/acpi.h>
+#include "osl.h"
+
+int main(int argc, char *argv[])
+{
+	acpi_status status;
+
+	openconsole(&dev_stdcon_r, &dev_stdcon_w);
+
+	status = acpi_initialize_subsystem();
+	acpi_os_process_deferred_work(FALSE);
+	if (ACPI_FAILURE(status))
+	{
+		printf("acpioff: acpi_initialize_subsystem() failed: %s\n",
+		       acpi_format_exception(status));
+		acpi_terminate();
+		return status;
+	}
+
+	status = acpi_initialize_tables(NULL, 16, FALSE);
+	acpi_os_process_deferred_work(FALSE);
+	if (ACPI_FAILURE(status))
+	{
+		printf("acpioff: acpi_initialize_tables() failed: %s\n",
+		       acpi_format_exception(status));
+		acpi_terminate();
+		return status;
+	}
+
+	/*
+	 * Our OSL can't easily handle the SCI interrupt, without major
+	 * changes to SYSLINUX
+	 *
+	 * status =
+	 *       acpi_enable_subsystem(ACPI_NO_EVENT_INIT|ACPI_NO_HANDLER_INIT);
+	 */
+	status = acpi_enable_subsystem(ACPI_FULL_INITIALIZATION);
+	acpi_os_process_deferred_work(FALSE);
+	if (ACPI_FAILURE(status))
+	{
+		printf("acpioff: acpi_enable_subsystem() failed: %s\n",
+		       acpi_format_exception(status));
+		acpi_terminate();
+		return status;
+	}
+
+	status = acpi_initialize_objects(ACPI_FULL_INITIALIZATION);
+	acpi_os_process_deferred_work(FALSE);
+	if (ACPI_FAILURE(status))
+	{
+		printf("acpioff: acpi_initialize_objects() failed: %s\n",
+		       acpi_format_exception(status));
+		acpi_terminate();
+		return status;
+	}
+
+	status = acpi_enter_sleep_state_prep(ACPI_STATE_S5); /* S5: poweroff */
+	acpi_os_process_deferred_work(FALSE);
+	if (ACPI_FAILURE(status))
+	{
+		printf("acpioff: acpi_enter_sleep_state_prep() failed: %s\n",
+		       acpi_format_exception(status));
+		acpi_terminate();
+		return status;
+	}
+
+	status = acpi_enter_sleep_state(ACPI_STATE_S5); /* S5: poweroff */
+	/* We should return from the above, if we power off */
+	acpi_os_process_deferred_work(FALSE);
+	if (ACPI_FAILURE(status))
+	{
+		printf("acpioff: acpi_enter_sleep_state() failed: %s\n",
+		       acpi_format_exception(status));
+		acpi_terminate();
+		return status;
+	}
+
+	acpi_terminate();
+	return 0;
+}

From 38d93897ff425ef75bb097232ee0d103db8abf5b Mon Sep 17 00:00:00 2001
From: Andy Walls <awalls@md.metrocast.net>
Date: Sat, 21 Jan 2012 19:22:53 -0500
Subject: [PATCH 08/20] acpioff: First version of Makefile to build both
 library and executable

This is the first real, working version of the Makefile

Signed-off-by: Andy Walls <awalls@md.metrocast.net>
---
 com32/acpioff/Makefile | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/com32/acpioff/Makefile b/com32/acpioff/Makefile
index 700e7095..d1f08c84 100644
--- a/com32/acpioff/Makefile
+++ b/com32/acpioff/Makefile
@@ -14,6 +14,8 @@
 # Avoid <acpi/acpi.h> header file conflicts with syslinux/com32/gplinclude
 NOGPL = 1
 
+LIBS += $(CURDIR)/libacpica.a
+
 topdir = ../..
 MAKEDIR = $(topdir)/mk
 include $(MAKEDIR)/com32.mk
@@ -21,8 +23,7 @@ include $(MAKEDIR)/com32.mk
 LIBACPICA_SRC_DIRS = acpica_linuxized/drivers/acpi/acpica \
 	acpica_linuxized/drivers/acpi
 
-# Hijack GPLINCLUDE for ourselves
-GPLINCLUDE = -I$(CURDIR)/acpica_linuxized/include \
+CFLAGS += -I$(CURDIR)/acpica_linuxized/include \
 	-I$(CURDIR)/acpica_linuxized/include/acpi \
 	-I$(CURDIR)/acpica_linuxized/drivers/acpi/acpica
 
@@ -32,8 +33,7 @@ GCCWARN += -Wno-unused-parameter
 
 LIBACPICA_OBJS := $(foreach dir,$(LIBACPICA_SRC_DIRS),$(patsubst %.c,%.o,$(wildcard $(dir)/*.c)))
 
-#all: libacpica.a acpioff.c32
-all: libacpica.a
+all: libacpica.a acpioff.c32
 
 libacpica.a: $(LIBACPICA_OBJS)
 	rm -f $@

From 6ff3e1839cf9554ad9e6258d09683c187ba3f0e9 Mon Sep 17 00:00:00 2001
From: Andy Walls <awalls@md.metrocast.net>
Date: Mon, 20 Feb 2012 00:57:29 -0500
Subject: [PATCH 09/20] acpioff: Allow the ACPICA to be built to emit verbose
 debugging

Modify a header file in the ACPICA and our Makefile to allow the
ACPICA to be built so it can emit verbose debugging and tracing.

This makes the library much larger if enabled, but may be useful for
trying to make acpioff work with quirky ACPI BIOSes.

Signed-off-by: Andy Walls <awalls@md.metrocast.net>
---
 com32/acpioff/Makefile                                     | 7 +++++++
 .../acpioff/acpica_linuxized/drivers/acpi/acpica/acutils.h | 2 +-
 2 files changed, 8 insertions(+), 1 deletion(-)

diff --git a/com32/acpioff/Makefile b/com32/acpioff/Makefile
index d1f08c84..8dee2053 100644
--- a/com32/acpioff/Makefile
+++ b/com32/acpioff/Makefile
@@ -31,6 +31,13 @@ CFLAGS += -I$(CURDIR)/acpica_linuxized/include \
 # configuration options
 GCCWARN += -Wno-unused-parameter
 
+# Uncomment to have the ACPICA spew debugging output
+#CFLAGS += -DACPI_DEBUG_OUTPUT
+
+# Uncomment when ACPI_DEBUG_OUTPUT is defined for debug output, as the ACPICA
+# debug output code generates many warnings
+#GCCWARN += -Wno-error
+
 LIBACPICA_OBJS := $(foreach dir,$(LIBACPICA_SRC_DIRS),$(patsubst %.c,%.o,$(wildcard $(dir)/*.c)))
 
 all: libacpica.a acpioff.c32
diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acutils.h b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acutils.h
index 2ae299b7..dd3121d9 100644
--- a/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acutils.h
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/acpica/acutils.h
@@ -49,7 +49,7 @@ extern const u8 acpi_gbl_resource_aml_serial_bus_sizes[];
 
 /* Strings used by the disassembler and debugger resource dump routines */
 
-#if defined(ACPI_DISASSEMBLER) || defined (ACPI_DEBUGGER)
+#if defined(ACPI_DISASSEMBLER) || defined (ACPI_DEBUGGER) || defined (ACPI_DEBUG_OUTPUT)
 
 extern const char *acpi_gbl_bm_decode[];
 extern const char *acpi_gbl_config_decode[];

From 1fdbd650d5eac55101fbaa30c86e914f00b582de Mon Sep 17 00:00:00 2001
From: Andy Walls <awalls@md.metrocast.net>
Date: Mon, 20 Feb 2012 01:03:00 -0500
Subject: [PATCH 10/20] acpioff: First version that fully works with
 Qemu/SeaBIOS

This is the first working version of acpioff; tested against
Qemu/SeaBIOS using PXELINUX.

Also added a text dump of ACPI namespace tree upon failure to
shutdown, or with a commandline argument.

Signed-off-by: Andy Walls <awalls@md.metrocast.net>
---
 com32/acpioff/acpioff.c | 66 ++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 65 insertions(+), 1 deletion(-)

diff --git a/com32/acpioff/acpioff.c b/com32/acpioff/acpioff.c
index 0e58f70c..d096db8c 100644
--- a/com32/acpioff/acpioff.c
+++ b/com32/acpioff/acpioff.c
@@ -27,16 +27,60 @@
  */
 
 #include <stdio.h>
+#include <stdlib.h>
 #include <console.h>
 #include <acpi/acpi.h>
 #include "osl.h"
 
+acpi_status dump_tree_cb(acpi_handle obj, u32 depth, void *context, void **ret)
+{
+	/*
+	 * This callback is called when a node is first traversed,
+	 * before traversing its children.
+	 */
+	acpi_status status;
+	struct acpi_buffer b;
+
+	b.length = ACPI_ALLOCATE_BUFFER;
+	b.pointer = NULL; 
+	status = acpi_get_name(obj, ACPI_FULL_PATHNAME, &b);
+	acpi_os_process_deferred_work(FALSE);
+
+	if (ACPI_FAILURE(status)) {
+		printf("acpioff: dump_tree_cb(): acpi_get_name() failed: %s\n",
+		       acpi_format_exception(status));
+	} else {
+		printf("    %s\n", (char *)(b.pointer));
+	}
+
+	if (b.pointer != NULL)
+		acpi_os_free(b.pointer);
+
+	return AE_OK;
+}
+
+void dump_acpi_tree(void)
+{
+	printf("ACPI namespace tree dump:\n");
+	acpi_walk_namespace(ACPI_TYPE_ANY, ACPI_ROOT_OBJECT, 0xffffffff,
+			    dump_tree_cb, NULL, NULL, (void **) NULL);
+	acpi_os_process_deferred_work(FALSE);
+}
+
 int main(int argc, char *argv[])
 {
 	acpi_status status;
+	int dont_shutdown = 0;
 
 	openconsole(&dev_stdcon_r, &dev_stdcon_w);
 
+	if (argc > 1)
+		acpi_dbg_level = strtoul(argv[1], NULL, 0);
+	if (argc > 2)
+		acpi_dbg_layer = strtoul(argv[2], NULL, 0);
+	if (argc > 3)
+		dont_shutdown = 1;
+
 	status = acpi_initialize_subsystem();
 	acpi_os_process_deferred_work(FALSE);
 	if (ACPI_FAILURE(status))
@@ -57,9 +101,19 @@ int main(int argc, char *argv[])
 		return status;
 	}
 
+	status = acpi_load_tables();
+	acpi_os_process_deferred_work(FALSE);
+	if (ACPI_FAILURE(status))
+	{
+		printf("acpioff: acpi_load_tables() failed: %s\n",
+		       acpi_format_exception(status));
+		acpi_terminate();
+		return status;
+	}
+
 	/*
 	 * Our OSL can't easily handle the SCI interrupt, without major
-	 * changes to SYSLINUX
+	 * changes to SYSLINUX.  Maybe we shouldn't try to init events:
 	 *
 	 * status =
 	 *       acpi_enable_subsystem(ACPI_NO_EVENT_INIT|ACPI_NO_HANDLER_INIT);
@@ -84,12 +138,20 @@ int main(int argc, char *argv[])
 		return status;
 	}
 
+	if (dont_shutdown)
+	{
+		dump_acpi_tree();
+		acpi_terminate();
+		return 0;
+	}
+
 	status = acpi_enter_sleep_state_prep(ACPI_STATE_S5); /* S5: poweroff */
 	acpi_os_process_deferred_work(FALSE);
 	if (ACPI_FAILURE(status))
 	{
 		printf("acpioff: acpi_enter_sleep_state_prep() failed: %s\n",
 		       acpi_format_exception(status));
+		dump_acpi_tree();
 		acpi_terminate();
 		return status;
 	}
@@ -101,10 +163,12 @@ int main(int argc, char *argv[])
 	{
 		printf("acpioff: acpi_enter_sleep_state() failed: %s\n",
 		       acpi_format_exception(status));
+		dump_acpi_tree();
 		acpi_terminate();
 		return status;
 	}
 
+	dump_acpi_tree();
 	acpi_terminate();
 	return 0;
 }

From 8f5eb8caf5cba7cb874ffe6e38643e647651104e Mon Sep 17 00:00:00 2001
From: Andy Walls <awalls@md.metrocast.net>
Date: Mon, 20 Feb 2012 01:09:28 -0500
Subject: [PATCH 11/20] acpioff: Get rid of noisy status message from ACPICA
 OSL

When I coded the COM32 OSL for the ACPICA, I added a printf()
message that is displayed on every attempt to process deferred work from
the ACPICA.  That was a mistake.  Get rid of the noisy message.

Signed-off-by: Andy Walls <awalls@md.metrocast.net>
---
 com32/acpioff/acpica_linuxized/drivers/acpi/osl.c | 2 --
 1 file changed, 2 deletions(-)

diff --git a/com32/acpioff/acpica_linuxized/drivers/acpi/osl.c b/com32/acpioff/acpica_linuxized/drivers/acpi/osl.c
index 72cbdf2f..2d5f903c 100644
--- a/com32/acpioff/acpica_linuxized/drivers/acpi/osl.c
+++ b/com32/acpioff/acpica_linuxized/drivers/acpi/osl.c
@@ -116,8 +116,6 @@ int acpi_os_process_deferred_work(int noexec)
 		free(work);
 		i++;
 	}
-	ACPI_INFO((AE_INFO, "%s %u deferred work item(s)",
-	           noexec ? "Deallocated" : "Processed", i));
 	return i;
 }
 

From 5d80b8235b1852507304bb022d3c9426c69af88d Mon Sep 17 00:00:00 2001
From: Andy Walls <awalls@md.metrocast.net>
Date: Mon, 20 Feb 2012 01:13:16 -0500
Subject: [PATCH 12/20] com32: Add building acpioff to the COM32 Makefile

Signed-off-by: Andy Walls <awalls@md.metrocast.net>
---
 com32/Makefile | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/com32/Makefile b/com32/Makefile
index da632a17..88abeba2 100644
--- a/com32/Makefile
+++ b/com32/Makefile
@@ -3,7 +3,7 @@ SUBDIRS = tools lib libutil gpllib libup

 ifneq ($(FWCLASS),EFI)
 # These tools are no applicable to EFI, or need serious porting
-SUBDIRS += hdt gfxboot sysdump chain
+SUBDIRS += hdt gfxboot sysdump chain acpioff
 endif

 .PHONY: subdirs $(SUBDIRS)

From 6eaee17e39335d5d7a41da2dd563b2eb2417f778 Mon Sep 17 00:00:00 2001
From: Andy Walls <awalls@md.metrocast.net>
Date: Mon, 20 Feb 2012 01:20:11 -0500
Subject: [PATCH 13/20] acpioff: Add copyright and update text of README of
 ACPICA code pedigree

Signed-off-by: Andy Walls <awalls@md.metrocast.net>
---
 com32/acpioff/acpica_linuxized/README | 24 ++++++++++++++++++++++++
 1 file changed, 24 insertions(+)

diff --git a/com32/acpioff/acpica_linuxized/README b/com32/acpioff/acpica_linuxized/README
index 10cbc51e..3a61708c 100644
--- a/com32/acpioff/acpica_linuxized/README
+++ b/com32/acpioff/acpica_linuxized/README
@@ -1,3 +1,26 @@
+
+/*
+    README - Description of how this ACPI Component Architecture code 
+             for use with acpioff.c32 and the SYSLINUX bootloader variants
+             was derived
+
+    Copyright (C) 2012 Andy Walls <awalls@md.metrocast.net>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
 Initially created from the ACPICA Git repository on 14 Jan 2012
 using the following steps:
 
@@ -8,3 +31,4 @@ using the following steps:
 	$ ./linuxize.sh ~/foo/acpica/
 	$ mv new.linux ~/foo/syslinux/com32/acpioff/acpica_linuxized
 
+Then the needed platform files were added, and a few problem files modified.

From 749194179a43955490eb885c0617df40d5566947 Mon Sep 17 00:00:00 2001
From: Andy Walls <awalls@md.metrocast.net>
Date: Sat, 3 Mar 2012 07:27:11 -0500
Subject: [PATCH 14/20] acpioff: Move ACPI tree dump on error to not obscure
 error message

Signed-off-by: Andy Walls <awalls@md.metrocast.net>
---
 com32/acpioff/acpioff.c | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/com32/acpioff/acpioff.c b/com32/acpioff/acpioff.c
index d096db8c..bc267b5f 100644
--- a/com32/acpioff/acpioff.c
+++ b/com32/acpioff/acpioff.c
@@ -149,21 +149,21 @@ int main(int argc, char *argv[])
 	acpi_os_process_deferred_work(FALSE);
 	if (ACPI_FAILURE(status))
 	{
+		dump_acpi_tree();
 		printf("acpioff: acpi_enter_sleep_state_prep() failed: %s\n",
 		       acpi_format_exception(status));
-		dump_acpi_tree();
 		acpi_terminate();
 		return status;
 	}
 
 	status = acpi_enter_sleep_state(ACPI_STATE_S5); /* S5: poweroff */
-	/* We should return from the above, if we power off */
+	/* We should not return from the above, if we power off */
 	acpi_os_process_deferred_work(FALSE);
 	if (ACPI_FAILURE(status))
 	{
+		dump_acpi_tree();
 		printf("acpioff: acpi_enter_sleep_state() failed: %s\n",
 		       acpi_format_exception(status));
-		dump_acpi_tree();
 		acpi_terminate();
 		return status;
 	}

From ab88b7f28c54fd5233cd10b04184bd1ddf71e81d Mon Sep 17 00:00:00 2001
From: Andy Walls <awalls@md.metrocast.net>
Date: Sun, 18 Mar 2012 12:33:16 -0400
Subject: [PATCH 15/20] acpioff: Force a human to reboot system, if turning off
 power fails

Once the hardare has been put in ACPI mode, one must assume that it can
never reliably be reverted back to the start-up state.  This can be a
source of problems for any ACPI-aware OS or COM32 module loaded after
acpioff, if acpioff fails to turn off power.  Force a human to reboot the
system, before any other image can be subsequently loaded and run.

Thanks go to H. Peter Anvin and Gene Cumm for pointing this out.

Signed-off-by: Andy Walls <awalls@md.metrocast.net>
---
 com32/acpioff/acpioff.c | 33 ++++++++++++++++-----------------
 1 file changed, 16 insertions(+), 17 deletions(-)

diff --git a/com32/acpioff/acpioff.c b/com32/acpioff/acpioff.c
index bc267b5f..2db0b448 100644
--- a/com32/acpioff/acpioff.c
+++ b/com32/acpioff/acpioff.c
@@ -29,6 +29,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <console.h>
+#include <sys/cpu.h>
 #include <acpi/acpi.h>
 #include "osl.h"
 
@@ -87,8 +88,7 @@ int main(int argc, char *argv[])
 	{
 		printf("acpioff: acpi_initialize_subsystem() failed: %s\n",
 		       acpi_format_exception(status));
-		acpi_terminate();
-		return status;
+		goto err;
 	}
 
 	status = acpi_initialize_tables(NULL, 16, FALSE);
@@ -97,8 +97,7 @@ int main(int argc, char *argv[])
 	{
 		printf("acpioff: acpi_initialize_tables() failed: %s\n",
 		       acpi_format_exception(status));
-		acpi_terminate();
-		return status;
+		goto err;
 	}
 
 	status = acpi_load_tables();
@@ -107,8 +106,7 @@ int main(int argc, char *argv[])
 	{
 		printf("acpioff: acpi_load_tables() failed: %s\n",
 		       acpi_format_exception(status));
-		acpi_terminate();
-		return status;
+		goto err;
 	}
 
 	/*
@@ -124,8 +122,7 @@ int main(int argc, char *argv[])
 	{
 		printf("acpioff: acpi_enable_subsystem() failed: %s\n",
 		       acpi_format_exception(status));
-		acpi_terminate();
-		return status;
+		goto err;
 	}
 
 	status = acpi_initialize_objects(ACPI_FULL_INITIALIZATION);
@@ -134,15 +131,13 @@ int main(int argc, char *argv[])
 	{
 		printf("acpioff: acpi_initialize_objects() failed: %s\n",
 		       acpi_format_exception(status));
-		acpi_terminate();
-		return status;
+		goto err;
 	}
 
 	if (dont_shutdown)
 	{
 		dump_acpi_tree();
-		acpi_terminate();
-		return 0;
+		goto err;
 	}
 
 	status = acpi_enter_sleep_state_prep(ACPI_STATE_S5); /* S5: poweroff */
@@ -152,8 +147,7 @@ int main(int argc, char *argv[])
 		dump_acpi_tree();
 		printf("acpioff: acpi_enter_sleep_state_prep() failed: %s\n",
 		       acpi_format_exception(status));
-		acpi_terminate();
-		return status;
+		goto err;
 	}
 
 	status = acpi_enter_sleep_state(ACPI_STATE_S5); /* S5: poweroff */
@@ -164,11 +158,16 @@ int main(int argc, char *argv[])
 		dump_acpi_tree();
 		printf("acpioff: acpi_enter_sleep_state() failed: %s\n",
 		       acpi_format_exception(status));
-		acpi_terminate();
-		return status;
+		goto err;
 	}
 
 	dump_acpi_tree();
+err:
 	acpi_terminate();
-	return 0;
+	printf("acpioff: failed to shut system off. Reboot required.\n");
+
+	while (1)
+		hlt();
+
+	return -1;
 }

From 2ddabb1ed77454a36071200abb5f430ae01038d4 Mon Sep 17 00:00:00 2001
From: Andy Walls <andy@silverblocksystems.net>
Date: Sun, 12 Apr 2020 11:45:12 -0400
Subject: [PATCH 16/20] acpioff: Fix acpioff.32 libacpica.a build order

---
 com32/acpioff/Makefile | 7 +++++--
 1 file changed, 5 insertions(+), 2 deletions(-)

diff --git a/com32/acpioff/Makefile b/com32/acpioff/Makefile
index 8dee2053..9587914e 100644
--- a/com32/acpioff/Makefile
+++ b/com32/acpioff/Makefile
@@ -40,9 +40,12 @@ GCCWARN += -Wno-unused-parameter
 
 LIBACPICA_OBJS := $(foreach dir,$(LIBACPICA_SRC_DIRS),$(patsubst %.c,%.o,$(wildcard $(dir)/*.c)))
 
-all: libacpica.a acpioff.c32
+all: acpioff.c32
 
-libacpica.a: $(LIBACPICA_OBJS)
+acpioff.elf: acpioff.o $(LIBS) $(C_LIBS) $(COM32LD)
+	$(LD) $(LDFLAGS) -o $@ $(filter-out $(COM32LD),$^)
+
+$(CURDIR)/libacpica.a: $(LIBACPICA_OBJS)
 	rm -f $@
 	$(AR) cq $@ $^
 	$(RANLIB) $@

From 86e4870d92b0a34292b1de94065129618826d9e2 Mon Sep 17 00:00:00 2001
From: Andy Walls <andy@silverblocksystems.net>
Date: Sun, 12 Apr 2020 12:12:42 -0400
Subject: [PATCH 17/20] lzo: Fix some assetions that used non-constants for
 array defintions

---
 lzo/src/miniacc.h | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/lzo/src/miniacc.h b/lzo/src/miniacc.h
index 315a20b2..2f65828f 100644
--- a/lzo/src/miniacc.h
+++ b/lzo/src/miniacc.h
@@ -4412,12 +4412,12 @@ ACCLIB_EXTERN(int, acc_spawnve) (int mode, const char* fn, const char* const * a
 #if defined(__MSDOS__) && defined(__TURBOC__) && (__TURBOC__ < 0x0150)
 #elif 1 && (ACC_CC_SUNPROC) && !defined(ACCCHK_CFG_PEDANTIC)
 #else
-    ACCCHK_ASSERT((1   << (8*SIZEOF_INT-1)) < 0)
+    ACCCHK_ASSERT((int)(1u   << (8*SIZEOF_INT-1)) < 0)
 #endif
     ACCCHK_ASSERT((1u  << (8*SIZEOF_INT-1)) > 0)
 #if 1 && (ACC_CC_SUNPROC) && !defined(ACCCHK_CFG_PEDANTIC)
 #else
-    ACCCHK_ASSERT((1l  << (8*SIZEOF_LONG-1)) < 0)
+    ACCCHK_ASSERT((long)(1ul  << (8*SIZEOF_LONG-1)) < 0)
 #endif
     ACCCHK_ASSERT((1ul << (8*SIZEOF_LONG-1)) > 0)
 #if defined(acc_int16e_t)
@@ -4646,7 +4646,7 @@ ACCLIB_EXTERN(int, acc_spawnve) (int mode, const char* fn, const char* const * a
 #elif 1 && (ACC_CC_LCC || ACC_CC_LCCWIN32) && !defined(ACCCHK_CFG_PEDANTIC)
 #elif 1 && (ACC_CC_SUNPROC) && !defined(ACCCHK_CFG_PEDANTIC)
 #elif !defined(ACC_BROKEN_INTEGRAL_PROMOTION) && (SIZEOF_INT > 1)
-    ACCCHK_ASSERT( (((unsigned char)128) << (int)(8*sizeof(int)-8)) < 0)
+    ACCCHK_ASSERT( (int)((unsigned int)((unsigned char)128) << (int)(8*sizeof(int)-8)) < 0)
 #endif
 #if (ACC_CC_BORLANDC && (__BORLANDC__ >= 0x0530) && (__BORLANDC__ < 0x0560))
 #  pragma option pop

