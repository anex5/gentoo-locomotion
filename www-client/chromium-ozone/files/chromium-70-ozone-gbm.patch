diff --git a/ui/ozone/common/linux/gbm_wrapper.cc b/ui/ozone/common/linux/gbm_wrapper.cc
index d05fe02..5cf83ee
--- a/ui/ozone/common/linux/gbm_wrapper.cc
+++ b/ui/ozone/common/linux/gbm_wrapper.cc
@@ -4,9 +4,12 @@
 
 #include "ui/ozone/common/linux/gbm_wrapper.h"
 
+#include <fcntl.h>
 #include <gbm.h>
+#include <xf86drm.h>
 
 #include "base/posix/eintr_wrapper.h"
+#include "third_party/skia/include/core/SkSurface.h"
 #include "ui/gfx/buffer_format_util.h"
 #include "ui/ozone/common/linux/drm_util_linux.h"
 #include "ui/ozone/common/linux/gbm_buffer.h"
@@ -14,6 +17,91 @@
 
 namespace gbm_wrapper {
 
+namespace {
+
+// Temporary defines while we migrate to GBM_BO_IMPORT_FD_MODIFIER.
+#define GBM_BO_IMPORT_FD_PLANAR_5504 0x5504
+#define GBM_BO_IMPORT_FD_PLANAR_5505 0x5505
+
+// Minigbm and system linux gbm have some differences. There is no clear way how
+// to distinguish linux gbm (Mesa, basically) and minigbm, which can be both
+// third_party and minigbm. Thus, use GBM_BO_IMPORT_FD_PLANAR define to
+// identify, which gbm is used.
+#if defined(GBM_BO_IMPORT_FD_PLANAR)
+// There are some methods, which require knowing whether minigbm is used or not.
+#ifndef USING_MINIGBM
+#define USING_MINIGBM
+#endif  // USING_MINIGBM
+// Minigbm and system linux gbm have alike gbm_bo_import* structures, but some
+// of the data variables have different type.
+using gbm_bo_import_fd_data_with_modifier = struct gbm_import_fd_planar_data;
+#else
+using gbm_bo_import_fd_data_with_modifier = struct gbm_import_fd_modifier_data;
+#endif
+
+void InitializeImportData(uint32_t format,
+                          const gfx::Size& size,
+                          const std::vector<base::ScopedFD>& fds,
+                          const std::vector<gfx::NativePixmapPlane>& planes,
+                          gbm_bo_import_fd_data_with_modifier* fd_data) {
+  fd_data->width = size.width();
+  fd_data->height = size.height();
+  fd_data->format = format;
+
+  DCHECK_LE(planes.size(), 3u);
+  for (size_t i = 0; i < planes.size(); ++i) {
+    fd_data->fds[i] = fds[i < fds.size() ? i : 0].get();
+    fd_data->strides[i] = planes[i].stride;
+    fd_data->offsets[i] = planes[i].offset;
+#if defined(USING_MINIGBM)
+    fd_data->format_modifiers[i] = planes[i].modifier;
+#else
+    fd_data->modifier = planes[i].modifier;
+#endif
+  }
+}
+
+int GetPlaneFdForBo(gbm_bo* bo, size_t plane) {
+#if defined(USING_MINIGBM)
+  DCHECK(plane < gbm_bo_get_plane_count(bo));
+#else
+  const int plane_count = gbm_bo_get_plane_count(bo);
+  DCHECK(plane_count > 0 && plane < static_cast<size_t>(plane_count));
+#endif
+
+  // System linux gbm (or Mesa gbm) does not provide fds per plane basis. Thus,
+  // get plane handle and use drm ioctl to get a prime fd out of it avoid having
+  // two different branches for minigbm and Mesa gbm here.
+  gbm_device* gbm_dev = gbm_bo_get_device(bo);
+  int dev_fd = gbm_device_get_fd(gbm_dev);
+  if (dev_fd <= 0) {
+    LOG(ERROR) << "Unable to get device fd";
+    return -1;
+  }
+
+  const uint32_t plane_handle = gbm_bo_get_handle_for_plane(bo, plane).u32;
+  int fd = -1;
+  int ret;
+  // Use DRM_RDWR to allow the fd to be mappable in another process.
+  ret = drmPrimeHandleToFD(dev_fd, plane_handle, DRM_CLOEXEC | DRM_RDWR, &fd);
+
+  // Older DRM implementations blocked DRM_RDWR, but gave a read/write mapping
+  // anyways
+  if (ret)
+    ret = drmPrimeHandleToFD(dev_fd, plane_handle, DRM_CLOEXEC, &fd);
+
+  return ret ? ret : fd;
+}
+
+size_t GetSizeOfPlane(gbm_bo* bo, size_t plane) {
+  // System linux gbm (or Mesa gbm) does not provide plane size. Thus, calculate
+  // it by ourselves and avoid having two different branches for minigbm and
+  // Mesa gbm here.
+  return gbm_bo_get_height(bo) * gbm_bo_get_stride_for_plane(bo, plane);
+}
+
+}  // namespace
+
 class Buffer final : public ui::GbmBuffer {
  public:
   Buffer(struct gbm_bo* bo,
@@ -31,7 +119,10 @@ class Buffer final : public ui::GbmBuffer {
         size_(size),
         planes_(std::move(planes)) {}
 
-  ~Buffer() override { gbm_bo_destroy(bo_); }
+  ~Buffer() override {
+    DCHECK(!mmap_data_);
+    gbm_bo_destroy(bo_);
+  }
 
   uint32_t GetFormat() const override { return format_; }
   uint64_t GetFormatModifier() const override { return format_modifier_; }
@@ -72,7 +163,7 @@ class Buffer final : public ui::GbmBuffer {
   }
   uint32_t GetPlaneHandle(size_t plane) const override {
     DCHECK_LT(plane, planes_.size());
-    return gbm_bo_get_plane_handle(bo_, plane).u32;
+    return gbm_bo_get_handle_for_plane(bo_, plane).u32;
   }
   uint32_t GetHandle() const override { return gbm_bo_get_handle(bo_).u32; }
   gfx::NativePixmapHandle ExportHandle() const override {
@@ -97,8 +188,29 @@ class Buffer final : public ui::GbmBuffer {
     return handle;
   }
 
+  sk_sp<SkSurface> GetSurface() override {
+    DCHECK(!mmap_data_);
+    uint32_t stride;
+    void* addr;
+    addr = gbm_bo_map(bo_, 0, 0, gbm_bo_get_width(bo_), gbm_bo_get_height(bo_),
+                      GBM_BO_TRANSFER_READ_WRITE, &stride, &mmap_data_
+#if defined(USING_MINIGBM)
+                      ,
+                      0
+#endif
+                      );
+
+    if (!addr)
+      return nullptr;
+    SkImageInfo info =
+        SkImageInfo::MakeN32Premul(size_.width(), size_.height());
+    return SkSurface::MakeRasterDirectReleaseProc(info, addr, stride,
+                                                  &Buffer::UnmapGbmBo, this);
+  }
+
  private:
   gbm_bo* bo_ = nullptr;
+  void* mmap_data_ = nullptr;
 
   uint32_t format_ = 0;
   uint64_t format_modifier_ = 0;
@@ -110,6 +222,12 @@ class Buffer final : public ui::GbmBuffer {
 
   std::vector<gfx::NativePixmapPlane> planes_;
 
+  static void UnmapGbmBo(void* pixels, void* context) {
+    Buffer* buffer = static_cast<Buffer*>(context);
+    gbm_bo_unmap(buffer->bo_, buffer->mmap_data_);
+    buffer->mmap_data_ = nullptr;
+  }
+
   DISALLOW_COPY_AND_ASSIGN(Buffer);
 };
 
@@ -121,11 +239,18 @@ std::unique_ptr<Buffer> CreateBufferForBO(struct gbm_bo* bo,
   std::vector<base::ScopedFD> fds;
   std::vector<gfx::NativePixmapPlane> planes;
 
-  const uint64_t modifier = gbm_bo_get_format_modifier(bo);
-  for (size_t i = 0; i < gbm_bo_get_num_planes(bo); ++i) {
+  const uint64_t modifier = gbm_bo_get_modifier(bo);
+  const int plane_count = gbm_bo_get_plane_count(bo);
+  // The Mesa's gbm implementation explicitly checks whether plane count <= and
+  // returns 1 if the condition is true. Nevertheless, use a DCHECK here to make
+  // sure the condition is not broken there.
+  DCHECK(plane_count > 0);
+  // Ensure there are no differences in integer signs by casting any possible
+  // values to size_t.
+  for (size_t i = 0; i < static_cast<size_t>(plane_count); ++i) {
     // The fd returned by gbm_bo_get_fd is not ref-counted and need to be
     // kept open for the lifetime of the buffer.
-    base::ScopedFD fd(gbm_bo_get_plane_fd(bo, i));
+    base::ScopedFD fd(GetPlaneFdForBo(bo, i));
 
     // TODO(dcastagna): support multiple fds.
     // crbug.com/642410
@@ -138,9 +263,9 @@ std::unique_ptr<Buffer> CreateBufferForBO(struct gbm_bo* bo,
       fds.emplace_back(std::move(fd));
     }
 
-    planes.emplace_back(gbm_bo_get_plane_stride(bo, i),
-                        gbm_bo_get_plane_offset(bo, i),
-                        gbm_bo_get_plane_size(bo, i), modifier);
+    planes.emplace_back(gbm_bo_get_stride_for_plane(bo, i),
+                        gbm_bo_get_offset(bo, i), GetSizeOfPlane(bo, i),
+                        modifier);
   }
   return std::make_unique<Buffer>(bo, format, flags, modifier, std::move(fds),
                                   size, std::move(planes));
@@ -187,35 +312,32 @@ class Device final : public ui::GbmDevice {
     DCHECK_EQ(planes[0].offset, 0);
 
     // Try to use scanout if supported.
-    int gbm_flags = GBM_BO_USE_SCANOUT | GBM_BO_USE_TEXTURING;
+    int gbm_flags = GBM_BO_USE_SCANOUT;
+#if defined(USING_MINIGBM)
+    gbm_flags |= GBM_BO_USE_TEXTURING;
+#endif
     if (!gbm_device_is_format_supported(device_, format, gbm_flags))
       gbm_flags &= ~GBM_BO_USE_SCANOUT;
 
     struct gbm_bo* bo = nullptr;
-    if (!gbm_device_is_format_supported(device_, format, gbm_flags)) {
-      LOG(ERROR) << "gbm format not supported: " << format;
-      return nullptr;
-    }
-
-    struct gbm_import_fd_planar_data fd_data;
-    fd_data.width = size.width();
-    fd_data.height = size.height();
-    fd_data.format = format;
-
-    DCHECK_LE(planes.size(), 3u);
-    for (size_t i = 0; i < planes.size(); ++i) {
-      fd_data.fds[i] = fds[i < fds.size() ? i : 0].get();
-      fd_data.strides[i] = planes[i].stride;
-      fd_data.offsets[i] = planes[i].offset;
-      fd_data.format_modifiers[i] = planes[i].modifier;
-    }
-
-    // The fd passed to gbm_bo_import is not ref-counted and need to be
-    // kept open for the lifetime of the buffer.
-    bo = gbm_bo_import(device_, GBM_BO_IMPORT_FD_PLANAR, &fd_data, gbm_flags);
-    if (!bo) {
-      LOG(ERROR) << "nullptr returned from gbm_bo_import";
-      return nullptr;
+    if (gbm_device_is_format_supported(device_, format, gbm_flags)) {
+      gbm_bo_import_fd_data_with_modifier fd_data;
+      InitializeImportData(format, size, fds, planes, &fd_data);
+
+      // The fd passed to gbm_bo_import is not ref-counted and need to be
+      // kept open for the lifetime of the buffer.
+      //
+      // See the comment regarding the GBM_BO_IMPORT_FD_PLANAR_550X above.
+      bo = gbm_bo_import(device_, GBM_BO_IMPORT_FD_PLANAR_5505, &fd_data,
+                         gbm_flags);
+      if (!bo) {
+        bo = gbm_bo_import(device_, GBM_BO_IMPORT_FD_PLANAR_5504, &fd_data,
+                           gbm_flags);
+        if (!bo) {
+          LOG(ERROR) << "nullptr returned from gbm_bo_import";
+          return nullptr;
+        }
+      }
     }
 
     return std::make_unique<Buffer>(bo, format, gbm_flags, planes[0].modifier,
diff --git a/ui/ozone/common/linux/gbm_buffer.h b/ui/ozone/common/linux/gbm_buffer.h
index 12c13bb..c6e0dac
--- a/ui/ozone/common/linux/gbm_buffer.h
+++ b/ui/ozone/common/linux/gbm_buffer.h
@@ -7,10 +7,13 @@
 
 #include <inttypes.h>
 
+#include "third_party/skia/include/core/SkRefCnt.h"
 #include "ui/gfx/buffer_types.h"
 #include "ui/gfx/geometry/size.h"
 #include "ui/gfx/native_pixmap_handle.h"
 
+class SkSurface;
+
 namespace ui {
 
 class GbmBuffer {
@@ -34,6 +37,7 @@ class GbmBuffer {
   virtual size_t GetPlaneSize(size_t plane) const = 0;
   virtual uint32_t GetHandle() const = 0;
   virtual gfx::NativePixmapHandle ExportHandle() const = 0;
+  virtual sk_sp<SkSurface> GetSurface() = 0;
 };
 
 }  // namespace ui
