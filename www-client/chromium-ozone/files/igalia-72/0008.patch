--- a/ui/aura/BUILD.gn	2019-02-14 01:14:41.000000000 +0300
+++ b/ui/aura/BUILD.gn	2019-02-20 20:48:23.432000000 +0300
@@ -184,6 +184,7 @@
     "//services/ws/public/mojom",
     "//skia",
     "//ui/base",
+    "//ui/base/clipboard",
     "//ui/base/ime",
     "//ui/display",
     "//ui/events",
@@ -418,6 +419,7 @@
     "//testing/gtest",
     "//ui/aura_extra",
     "//ui/base:test_support",
+    "//ui/base/clipboard:clipboard_types",
     "//ui/compositor:test_support",
     "//ui/compositor_extra",
     "//ui/display:test_support",
--- a/ui/aura/mus/os_exchange_data_provider_mus.cc	2019-02-14 01:14:41.000000000 +0300
+++ b/ui/aura/mus/os_exchange_data_provider_mus.cc	2019-02-20 20:48:23.444000000 +0300
@@ -15,6 +15,8 @@
 #include "base/strings/string_util.h"
 #include "base/strings/utf_string_conversions.h"
 #include "net/base/filename_util.h"
+#include "ui/base/clipboard/clipboard_constants.h"
+#include "ui/base/clipboard/clipboard_format_type.h"
 #include "ui/base/dragdrop/file_info.h"
 #include "ui/base/mojo/clipboard.mojom.h"
 #include "url/gurl.h"
@@ -87,8 +89,7 @@
   if (HasString())
     return;
 
-  mime_data_[ui::Clipboard::kMimeTypeText] =
-      FromString(base::UTF16ToUTF8(data));
+  mime_data_[ui::kMimeTypeText] = FromString(base::UTF16ToUTF8(data));
 }
 
 void OSExchangeDataProviderMus::SetURL(const GURL& url,
@@ -98,10 +99,10 @@
   AddString16ToVector(spec, &data);
   AddString16ToVector(base::ASCIIToUTF16("\n"), &data);
   AddString16ToVector(title, &data);
-  mime_data_[ui::Clipboard::kMimeTypeMozillaURL] = std::move(data);
+  mime_data_[ui::kMimeTypeMozillaURL] = std::move(data);
 
-  if (!base::ContainsKey(mime_data_, ui::Clipboard::kMimeTypeText))
-    mime_data_[ui::Clipboard::kMimeTypeText] = FromString(url.spec());
+  if (!base::ContainsKey(mime_data_, ui::kMimeTypeText))
+    mime_data_[ui::kMimeTypeText] = FromString(url.spec());
 }
 
 void OSExchangeDataProviderMus::SetFilename(const base::FilePath& path) {
@@ -120,11 +121,11 @@
   }
 
   std::string joined_data = base::JoinString(paths, "\n");
-  mime_data_[ui::Clipboard::kMimeTypeURIList] = FromString(joined_data);
+  mime_data_[ui::kMimeTypeURIList] = FromString(joined_data);
 }
 
 void OSExchangeDataProviderMus::SetPickledData(
-    const ui::Clipboard::FormatType& format,
+    const ui::ClipboardFormatType& format,
     const base::Pickle& pickle) {
   const unsigned char* bytes =
       reinterpret_cast<const unsigned char*>(pickle.data());
@@ -134,7 +135,7 @@
 }
 
 bool OSExchangeDataProviderMus::GetString(base::string16* data) const {
-  auto it = mime_data_.find(ui::Clipboard::kMimeTypeText);
+  auto it = mime_data_.find(ui::kMimeTypeText);
   if (it != mime_data_.end())
     *data = base::UTF8ToUTF16(ToString(it->second));
   return it != mime_data_.end();
@@ -144,7 +145,7 @@
     ui::OSExchangeData::FilenameToURLPolicy policy,
     GURL* url,
     base::string16* title) const {
-  auto it = mime_data_.find(ui::Clipboard::kMimeTypeMozillaURL);
+  auto it = mime_data_.find(ui::kMimeTypeMozillaURL);
   if (it == mime_data_.end()) {
     title->clear();
     return GetPlainTextURL(url) ||
@@ -177,7 +178,7 @@
 
 bool OSExchangeDataProviderMus::GetFilenames(
     std::vector<ui::FileInfo>* file_names) const {
-  auto it = mime_data_.find(ui::Clipboard::kMimeTypeURIList);
+  auto it = mime_data_.find(ui::kMimeTypeURIList);
   if (it == mime_data_.end())
     return false;
 
@@ -193,7 +194,7 @@
 }
 
 bool OSExchangeDataProviderMus::GetPickledData(
-    const ui::Clipboard::FormatType& format,
+    const ui::ClipboardFormatType& format,
     base::Pickle* data) const {
   auto it = mime_data_.find(format.Serialize());
   if (it == mime_data_.end())
@@ -207,15 +208,15 @@
 }
 
 bool OSExchangeDataProviderMus::HasString() const {
-  return base::ContainsKey(mime_data_, ui::Clipboard::kMimeTypeText);
+  return base::ContainsKey(mime_data_, ui::kMimeTypeText);
 }
 
 bool OSExchangeDataProviderMus::HasURL(
     ui::OSExchangeData::FilenameToURLPolicy policy) const {
-  if (base::ContainsKey(mime_data_, ui::Clipboard::kMimeTypeMozillaURL))
+  if (base::ContainsKey(mime_data_, ui::kMimeTypeMozillaURL))
     return true;
 
-  auto it = mime_data_.find(ui::Clipboard::kMimeTypeURIList);
+  auto it = mime_data_.find(ui::kMimeTypeURIList);
   if (it == mime_data_.end())
     return false;
 
@@ -230,7 +231,7 @@
 }
 
 bool OSExchangeDataProviderMus::HasFile() const {
-  auto it = mime_data_.find(ui::Clipboard::kMimeTypeURIList);
+  auto it = mime_data_.find(ui::kMimeTypeURIList);
   if (it == mime_data_.end())
     return false;
 
@@ -245,7 +246,7 @@
 }
 
 bool OSExchangeDataProviderMus::HasCustomFormat(
-    const ui::Clipboard::FormatType& format) const {
+    const ui::ClipboardFormatType& format) const {
   return base::ContainsKey(mime_data_, format.Serialize());
 }
 
@@ -281,12 +282,12 @@
   bytes.push_back(0xFF);
   bytes.push_back(0xFE);
   AddString16ToVector(html, &bytes);
-  mime_data_[ui::Clipboard::kMimeTypeHTML] = bytes;
+  mime_data_[ui::kMimeTypeHTML] = bytes;
 }
 
 bool OSExchangeDataProviderMus::GetHtml(base::string16* html,
                                         GURL* base_url) const {
-  auto it = mime_data_.find(ui::Clipboard::kMimeTypeHTML);
+  auto it = mime_data_.find(ui::kMimeTypeHTML);
   if (it == mime_data_.end())
     return false;
 
@@ -313,7 +314,7 @@
 }
 
 bool OSExchangeDataProviderMus::HasHtml() const {
-  return base::ContainsKey(mime_data_, ui::Clipboard::kMimeTypeHTML);
+  return base::ContainsKey(mime_data_, ui::kMimeTypeHTML);
 }
 #endif
 
--- a/ui/aura/mus/os_exchange_data_provider_mus.h	2019-02-14 01:14:41.000000000 +0300
+++ b/ui/aura/mus/os_exchange_data_provider_mus.h	2019-02-20 20:48:23.444000000 +0300
@@ -46,7 +46,7 @@
   void SetURL(const GURL& url, const base::string16& title) override;
   void SetFilename(const base::FilePath& path) override;
   void SetFilenames(const std::vector<ui::FileInfo>& file_names) override;
-  void SetPickledData(const ui::Clipboard::FormatType& format,
+  void SetPickledData(const ui::ClipboardFormatType& format,
                       const base::Pickle& data) override;
 
   bool GetString(base::string16* data) const override;
@@ -55,13 +55,13 @@
                       base::string16* title) const override;
   bool GetFilename(base::FilePath* path) const override;
   bool GetFilenames(std::vector<ui::FileInfo>* file_names) const override;
-  bool GetPickledData(const ui::Clipboard::FormatType& format,
+  bool GetPickledData(const ui::ClipboardFormatType& format,
                       base::Pickle* data) const override;
 
   bool HasString() const override;
   bool HasURL(ui::OSExchangeData::FilenameToURLPolicy policy) const override;
   bool HasFile() const override;
-  bool HasCustomFormat(const ui::Clipboard::FormatType& format) const override;
+  bool HasCustomFormat(const ui::ClipboardFormatType& format) const override;
 
 // Provider doesn't have a consistent interface between operating systems;
 // this wasn't seen as a problem when there was a single Provider subclass
--- a/ui/aura/mus/os_exchange_data_provider_mus_unittest.cc	2019-02-14 01:14:41.000000000 +0300
+++ b/ui/aura/mus/os_exchange_data_provider_mus_unittest.cc	2019-02-20 20:48:23.444000000 +0300
@@ -14,12 +14,12 @@
 #include "net/base/filename_util.h"
 #include "testing/gtest/include/gtest/gtest.h"
 #include "testing/platform_test.h"
+#include "ui/base/clipboard/clipboard_format_type.h"
 #include "ui/base/dragdrop/os_exchange_data.h"
 #include "ui/base/dragdrop/os_exchange_data_provider_factory.h"
 #include "ui/events/platform/platform_event_source.h"
 #include "url/gurl.h"
 
-using ui::Clipboard;
 using ui::OSExchangeData;
 
 namespace aura {
@@ -171,8 +171,8 @@
 }
 
 TEST_F(OSExchangeDataProviderMusTest, TestPickledData) {
-  const Clipboard::FormatType kTestFormat =
-      Clipboard::GetFormatType("application/vnd.chromium.test");
+  const ui::ClipboardFormatType kTestFormat =
+      ui::ClipboardFormatType::GetType("application/vnd.chromium.test");
 
   base::Pickle saved_pickle;
   saved_pickle.WriteInt(1);
--- a/ui/base/BUILD.gn	2019-02-14 01:14:41.000000000 +0300
+++ b/ui/base/BUILD.gn	2019-02-20 20:48:23.464000000 +0300
@@ -79,18 +79,6 @@
     "accelerators/platform_accelerator_cocoa.mm",
     "class_property.cc",
     "class_property.h",
-    "clipboard/clipboard_android.cc",
-    "clipboard/clipboard_android.h",
-    "clipboard/clipboard_mac.h",
-    "clipboard/clipboard_mac.mm",
-    "clipboard/clipboard_types.h",
-    "clipboard/clipboard_util_mac.h",
-    "clipboard/clipboard_util_mac.mm",
-    "clipboard/clipboard_util_win.cc",
-    "clipboard/clipboard_util_win.h",
-    "clipboard/clipboard_win.cc",
-    "clipboard/clipboard_win.h",
-    "clipboard/custom_data_helper_mac.mm",
     "cocoa/accessibility_focus_overrider.h",
     "cocoa/accessibility_focus_overrider.mm",
     "cocoa/animation_utils.h",
@@ -324,16 +312,6 @@
       "accelerators/accelerator_manager.h",
       "base_window.cc",
       "base_window.h",
-      "clipboard/clipboard.cc",
-      "clipboard/clipboard.h",
-      "clipboard/clipboard_constants.cc",
-      "clipboard/clipboard_monitor.cc",
-      "clipboard/clipboard_monitor.h",
-      "clipboard/clipboard_observer.h",
-      "clipboard/custom_data_helper.cc",
-      "clipboard/custom_data_helper.h",
-      "clipboard/scoped_clipboard_writer.cc",
-      "clipboard/scoped_clipboard_writer.h",
       "cocoa/bubble_closer.h",
       "cocoa/bubble_closer.mm",
       "cursor/cursor_util.cc",
@@ -422,6 +400,7 @@
     "//net",
     "//third_party/icu",
     "//third_party/zlib:zlib",
+    "//ui/base/clipboard:clipboard_types",
     "//ui/display",
     "//ui/events",
     "//ui/events/devices",
@@ -534,6 +513,10 @@
     ]
   }
 
+  if (is_mac || is_win) {
+    deps += [ "//ui/base/clipboard" ]
+  }
+
   libs = []
   if (is_win) {
     sources += [
@@ -632,20 +615,6 @@
   }
 
   if (use_aura) {
-    # Aura clipboard.
-    if (use_x11 && is_desktop_linux) {
-      sources += [
-        "clipboard/clipboard_aurax11.cc",
-        "clipboard/clipboard_aurax11.h",
-      ]
-    } else if (!is_win) {
-      # This file is used for all non-X11, non-Windows aura Builds.
-      sources += [
-        "clipboard/clipboard_aura.cc",
-        "clipboard/clipboard_aura.h",
-      ]
-    }
-
     # Cursor
     sources += [
       "cursor/cursors_aura.cc",
@@ -692,8 +661,6 @@
       "test/scoped_fake_nswindow_fullscreen.mm",
       "test/scoped_preferred_scroller_style_mac.h",
       "test/scoped_preferred_scroller_style_mac.mm",
-      "test/test_clipboard.cc",
-      "test/test_clipboard.h",
       "test/view_tree_validator.h",
       "test/view_tree_validator.mm",
       "test/windowed_nsnotification_observer.h",
@@ -792,8 +759,6 @@
 test("ui_base_unittests") {
   sources = [
     "class_property_unittest.cc",
-    "clipboard/clipboard_mac_unittest.mm",
-    "clipboard/clipboard_util_mac_unittest.mm",
     "l10n/l10n_util_mac_unittest.mm",
     "l10n/l10n_util_unittest.cc",
     "l10n/time_format_unittest.cc",
@@ -815,7 +780,6 @@
   if (!is_ios) {
     sources += [
       "test/scoped_fake_nswindow_fullscreen_unittest.mm",
-      "test/test_clipboard_unittest.cc",
       "test/view_tree_validator_unittest.mm",
     ]
   }
@@ -843,7 +807,6 @@
       "accelerators/menu_label_accelerator_util_linux_unittest.cc",
       "accelerators/menu_label_accelerator_util_unittest.cc",
       "accelerators/platform_accelerator_cocoa_unittest.mm",
-      "clipboard/custom_data_helper_unittest.cc",
       "cocoa/base_view_unittest.mm",
       "cocoa/bubble_closer_unittest.mm",
       "cocoa/cocoa_base_utils_unittest.mm",
@@ -906,6 +869,8 @@
     "//ui/base",
     "//ui/base:test_support",
     "//ui/base:ui_data_pack",
+    "//ui/base/clipboard:clipboard_test",
+    "//ui/base/clipboard:clipboard_types",
     "//ui/display",
     "//ui/events:events_base",
     "//ui/events:test_support",
--- a/ui/base/clipboard/clipboard_android.cc	2019-02-14 01:14:41.000000000 +0300
+++ b/ui/base/clipboard/clipboard_android.cc	2019-02-20 20:48:23.468000000 +0300
@@ -18,6 +18,7 @@
 #include "base/time/time.h"
 #include "jni/Clipboard_jni.h"
 #include "third_party/skia/include/core/SkBitmap.h"
+#include "ui/base/clipboard/clipboard_constants.h"
 #include "ui/gfx/geometry/size.h"
 
 // TODO:(andrewhayden) Support additional formats in Android: Bitmap, URI, HTML,
@@ -42,15 +43,6 @@
 
 namespace {
 
-// Various formats we support.
-const char kURLFormat[] = "url";
-const char kPlainTextFormat[] = "text";
-const char kHTMLFormat[] = "html";
-const char kRTFFormat[] = "rtf";
-const char kBitmapFormat[] = "bitmap";
-const char kWebKitSmartPasteFormat[] = "webkit_smart";
-const char kBookmarkFormat[] = "bookmark";
-
 class ClipboardMap {
  public:
   ClipboardMap();
@@ -144,22 +136,24 @@
 void ClipboardMap::CommitToAndroidClipboard() {
   JNIEnv* env = AttachCurrentThread();
   base::AutoLock lock(lock_);
-  if (base::ContainsKey(map_, kHTMLFormat)) {
+  if (base::ContainsKey(map_, ClipboardFormatType::GetHtmlType().ToString())) {
     // Android's API for storing HTML content on the clipboard requires a plain-
     // text representation to be available as well.
-    if (!base::ContainsKey(map_, kPlainTextFormat))
+    if (!base::ContainsKey(map_,
+                           ClipboardFormatType::GetPlainTextType().ToString()))
       return;
 
-    ScopedJavaLocalRef<jstring> html =
-        ConvertUTF8ToJavaString(env, map_[kHTMLFormat]);
-    ScopedJavaLocalRef<jstring> text =
-        ConvertUTF8ToJavaString(env, map_[kPlainTextFormat]);
+    ScopedJavaLocalRef<jstring> html = ConvertUTF8ToJavaString(
+        env, map_[ClipboardFormatType::GetHtmlType().ToString()]);
+    ScopedJavaLocalRef<jstring> text = ConvertUTF8ToJavaString(
+        env, map_[ClipboardFormatType::GetPlainTextType().ToString()]);
 
     DCHECK(html.obj() && text.obj());
     Java_Clipboard_setHTMLText(env, clipboard_manager_, html, text);
-  } else if (base::ContainsKey(map_, kPlainTextFormat)) {
-    ScopedJavaLocalRef<jstring> str =
-        ConvertUTF8ToJavaString(env, map_[kPlainTextFormat]);
+  } else if (base::ContainsKey(
+                 map_, ClipboardFormatType::GetPlainTextType().ToString())) {
+    ScopedJavaLocalRef<jstring> str = ConvertUTF8ToJavaString(
+        env, map_[ClipboardFormatType::GetPlainTextType().ToString()]);
     DCHECK(str.obj());
     Java_Clipboard_setText(env, clipboard_manager_, str);
   } else {
@@ -224,104 +218,17 @@
   ScopedJavaLocalRef<jstring> jhtml =
       Java_Clipboard_getHTMLText(env, clipboard_manager_);
 
-  JNI_Clipboard_AddMapEntry(env, &map_, kPlainTextFormat, jtext);
-  JNI_Clipboard_AddMapEntry(env, &map_, kHTMLFormat, jhtml);
+  JNI_Clipboard_AddMapEntry(
+      env, &map_, ClipboardFormatType::GetPlainTextType().ToString().c_str(),
+      jtext);
+  JNI_Clipboard_AddMapEntry(
+      env, &map_, ClipboardFormatType::GetHtmlType().ToString().c_str(), jhtml);
 
   map_state_ = MapState::kUpToDate;
 }
 
 }  // namespace
 
-// Clipboard::FormatType implementation.
-Clipboard::FormatType::FormatType() {
-}
-
-Clipboard::FormatType::FormatType(const std::string& native_format)
-    : data_(native_format) {
-}
-
-Clipboard::FormatType::~FormatType() {
-}
-
-std::string Clipboard::FormatType::Serialize() const {
-  return data_;
-}
-
-// static
-Clipboard::FormatType Clipboard::FormatType::Deserialize(
-    const std::string& serialization) {
-  return FormatType(serialization);
-}
-
-bool Clipboard::FormatType::operator<(const FormatType& other) const {
-  return data_ < other.data_;
-}
-
-bool Clipboard::FormatType::Equals(const FormatType& other) const {
-  return data_ == other.data_;
-}
-
-// Various predefined FormatTypes.
-// static
-Clipboard::FormatType Clipboard::GetFormatType(
-    const std::string& format_string) {
-  return FormatType::Deserialize(format_string);
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetUrlWFormatType() {
-  static base::NoDestructor<FormatType> type(kURLFormat);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetPlainTextFormatType() {
-  static base::NoDestructor<FormatType> type(kPlainTextFormat);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetPlainTextWFormatType() {
-  static base::NoDestructor<FormatType> type(kPlainTextFormat);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetWebKitSmartPasteFormatType() {
-  static base::NoDestructor<FormatType> type(kWebKitSmartPasteFormat);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetHtmlFormatType() {
-  static base::NoDestructor<FormatType> type(kHTMLFormat);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetRtfFormatType() {
-  static base::NoDestructor<FormatType> type(kRTFFormat);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetBitmapFormatType() {
-  static base::NoDestructor<FormatType> type(kBitmapFormat);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetWebCustomDataFormatType() {
-  static base::NoDestructor<FormatType> type(kMimeTypeWebCustomData);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetPepperCustomDataFormatType() {
-  static base::NoDestructor<FormatType> type(kMimeTypePepperCustomData);
-  return *type;
-}
-
 // Clipboard factory method.
 // static
 Clipboard* Clipboard::Create() {
@@ -360,7 +267,7 @@
   return g_map.Get().GetSequenceNumber();
 }
 
-bool ClipboardAndroid::IsFormatAvailable(const Clipboard::FormatType& format,
+bool ClipboardAndroid::IsFormatAvailable(const ClipboardFormatType& format,
                                          ClipboardType type) const {
   DCHECK(CalledOnValidThread());
   DCHECK_EQ(type, CLIPBOARD_TYPE_COPY_PASTE);
@@ -388,16 +295,16 @@
 
   // would be nice to ask the ClipboardMap to enumerate the types it supports,
   // rather than hardcode the list here.
-  if (IsFormatAvailable(Clipboard::GetPlainTextFormatType(), type))
+  if (IsFormatAvailable(ClipboardFormatType::GetPlainTextType(), type))
     types->push_back(base::UTF8ToUTF16(kMimeTypeText));
-  if (IsFormatAvailable(Clipboard::GetHtmlFormatType(), type))
+  if (IsFormatAvailable(ClipboardFormatType::GetHtmlType(), type))
     types->push_back(base::UTF8ToUTF16(kMimeTypeHTML));
 
   // these formats aren't supported by the ClipboardMap currently, but might
   // be one day?
-  if (IsFormatAvailable(Clipboard::GetRtfFormatType(), type))
+  if (IsFormatAvailable(ClipboardFormatType::GetRtfType(), type))
     types->push_back(base::UTF8ToUTF16(kMimeTypeRTF));
-  if (IsFormatAvailable(Clipboard::GetBitmapFormatType(), type))
+  if (IsFormatAvailable(ClipboardFormatType::GetBitmapType(), type))
     types->push_back(base::UTF8ToUTF16(kMimeTypePNG));
   *contains_filenames = false;
 }
@@ -415,7 +322,7 @@
                                      std::string* result) const {
   DCHECK(CalledOnValidThread());
   DCHECK_EQ(type, CLIPBOARD_TYPE_COPY_PASTE);
-  *result = g_map.Get().Get(kPlainTextFormat);
+  *result = g_map.Get().Get(ClipboardFormatType::GetPlainTextType().ToString());
 }
 
 // Note: |src_url| isn't really used. It is only implemented in Windows
@@ -429,7 +336,8 @@
   if (src_url)
     src_url->clear();
 
-  std::string input = g_map.Get().Get(kHTMLFormat);
+  std::string input =
+      g_map.Get().Get(ClipboardFormatType::GetHtmlType().ToString());
   *markup = base::UTF8ToUTF16(input);
 
   *fragment_start = 0;
@@ -444,7 +352,8 @@
 SkBitmap ClipboardAndroid::ReadImage(ClipboardType type) const {
   DCHECK(CalledOnValidThread());
   DCHECK_EQ(type, CLIPBOARD_TYPE_COPY_PASTE);
-  std::string input = g_map.Get().Get(kBitmapFormat);
+  std::string input =
+      g_map.Get().Get(ClipboardFormatType::GetBitmapType().ToString());
 
   SkBitmap bmp;
   if (!input.empty()) {
@@ -474,7 +383,7 @@
   NOTIMPLEMENTED();
 }
 
-void ClipboardAndroid::ReadData(const Clipboard::FormatType& format,
+void ClipboardAndroid::ReadData(const ClipboardFormatType& format,
                                 std::string* result) const {
   DCHECK(CalledOnValidThread());
   *result = g_map.Get().Get(format.ToString());
@@ -504,14 +413,16 @@
 }
 
 void ClipboardAndroid::WriteText(const char* text_data, size_t text_len) {
-  g_map.Get().Set(kPlainTextFormat, std::string(text_data, text_len));
+  g_map.Get().Set(ClipboardFormatType::GetPlainTextType().ToString(),
+                  std::string(text_data, text_len));
 }
 
 void ClipboardAndroid::WriteHTML(const char* markup_data,
                                  size_t markup_len,
                                  const char* url_data,
                                  size_t url_len) {
-  g_map.Get().Set(kHTMLFormat, std::string(markup_data, markup_len));
+  g_map.Get().Set(ClipboardFormatType::GetHtmlType().ToString(),
+                  std::string(markup_data, markup_len));
 }
 
 void ClipboardAndroid::WriteRTF(const char* rtf_data, size_t data_len) {
@@ -524,13 +435,15 @@
                                      size_t title_len,
                                      const char* url_data,
                                      size_t url_len) {
-  g_map.Get().Set(kBookmarkFormat, std::string(url_data, url_len));
+  g_map.Get().Set(ClipboardFormatType::GetBookmarkType().ToString(),
+                  std::string(url_data, url_len));
 }
 
 // Write an extra flavor that signifies WebKit was the last to modify the
 // pasteboard. This flavor has no data.
 void ClipboardAndroid::WriteWebSmartPaste() {
-  g_map.Get().Set(kWebKitSmartPasteFormat, std::string());
+  g_map.Get().Set(ClipboardFormatType::GetWebKitSmartPasteType().ToString(),
+                  std::string());
 }
 
 // Note: we implement this to pass all unit tests but it is currently unclear
@@ -541,10 +454,10 @@
   std::string packed(reinterpret_cast<const char*>(&size), sizeof(size));
   packed += std::string(static_cast<const char*>(bitmap.getPixels()),
                         bitmap.computeByteSize());
-  g_map.Get().Set(kBitmapFormat, packed);
+  g_map.Get().Set(ClipboardFormatType::GetBitmapType().ToString(), packed);
 }
 
-void ClipboardAndroid::WriteData(const Clipboard::FormatType& format,
+void ClipboardAndroid::WriteData(const ClipboardFormatType& format,
                                  const char* data_data,
                                  size_t data_len) {
   g_map.Get().Set(format.ToString(), std::string(data_data, data_len));
--- a/ui/base/clipboard/clipboard_android.h	2019-02-14 01:14:41.000000000 +0300
+++ b/ui/base/clipboard/clipboard_android.h	2019-02-20 20:48:23.468000000 +0300
@@ -13,6 +13,7 @@
 
 #include "base/android/scoped_java_ref.h"
 #include "base/callback_forward.h"
+#include "base/component_export.h"
 #include "base/macros.h"
 #include "base/time/time.h"
 
@@ -30,11 +31,12 @@
                             const base::android::JavaParamRef<jobject>& obj);
 
   // Sets the callback called whenever the clipboard is modified.
-  UI_BASE_EXPORT void SetModifiedCallback(ModifiedCallback cb);
+  COMPONENT_EXPORT(BASE_CLIPBOARD)
+  void SetModifiedCallback(ModifiedCallback cb);
 
   // Sets the last modified time without calling the above callback.
-  UI_BASE_EXPORT void SetLastModifiedTimeWithoutRunningCallback(
-      base::Time time);
+  COMPONENT_EXPORT(BASE_CLIPBOARD)
+  void SetLastModifiedTimeWithoutRunningCallback(base::Time time);
 
  private:
   friend class Clipboard;
@@ -45,7 +47,7 @@
   // Clipboard overrides:
   void OnPreShutdown() override;
   uint64_t GetSequenceNumber(ClipboardType type) const override;
-  bool IsFormatAvailable(const FormatType& format,
+  bool IsFormatAvailable(const ClipboardFormatType& format,
                          ClipboardType type) const override;
   void Clear(ClipboardType type) override;
   void ReadAvailableTypes(ClipboardType type,
@@ -64,7 +66,8 @@
                       const base::string16& type,
                       base::string16* result) const override;
   void ReadBookmark(base::string16* title, std::string* url) const override;
-  void ReadData(const FormatType& format, std::string* result) const override;
+  void ReadData(const ClipboardFormatType& format,
+                std::string* result) const override;
   base::Time GetLastModifiedTime() const override;
   void ClearLastModifiedTime() override;
   void WriteObjects(ClipboardType type, const ObjectMap& objects) override;
@@ -80,7 +83,7 @@
                      size_t url_len) override;
   void WriteWebSmartPaste() override;
   void WriteBitmap(const SkBitmap& bitmap) override;
-  void WriteData(const FormatType& format,
+  void WriteData(const ClipboardFormatType& format,
                  const char* data_data,
                  size_t data_len) override;
 
--- a/ui/base/clipboard/clipboard_aura.cc	2019-02-14 01:14:41.000000000 +0300
+++ b/ui/base/clipboard/clipboard_aura.cc	2019-02-20 20:48:23.468000000 +0300
@@ -19,6 +19,8 @@
 #include "base/strings/utf_string_conversions.h"
 #include "skia/ext/skia_utils_base.h"
 #include "third_party/skia/include/core/SkBitmap.h"
+#include "ui/base/clipboard/clipboard_constants.h"
+#include "ui/base/clipboard/clipboard_format_type.h"
 #include "ui/base/clipboard/clipboard_monitor.h"
 #include "ui/base/clipboard/custom_data_helper.h"
 #include "ui/gfx/geometry/size.h"
@@ -27,8 +29,6 @@
 
 namespace {
 
-const char kMimeTypeFilename[] = "chromium/filename";
-const char kMimeTypeBitmap[] = "image/bmp";
 const size_t kMaxClipboardSize = 1;
 
 // Clipboard data format used by AuraClipboard.
@@ -404,117 +404,6 @@
 
 ClipboardData* ClipboardDataBuilder::current_data_ = nullptr;
 
-// Clipboard::FormatType implementation.
-Clipboard::FormatType::FormatType() {
-}
-
-Clipboard::FormatType::FormatType(const std::string& native_format)
-    : data_(native_format) {
-}
-
-Clipboard::FormatType::~FormatType() {
-}
-
-std::string Clipboard::FormatType::Serialize() const {
-  return data_;
-}
-
-// static
-Clipboard::FormatType Clipboard::FormatType::Deserialize(
-    const std::string& serialization) {
-  return FormatType(serialization);
-}
-
-bool Clipboard::FormatType::operator<(const FormatType& other) const {
-  return data_ < other.data_;
-}
-
-bool Clipboard::FormatType::Equals(const FormatType& other) const {
-  return data_ == other.data_;
-}
-
-// Various predefined FormatTypes.
-// static
-Clipboard::FormatType Clipboard::GetFormatType(
-    const std::string& format_string) {
-  return FormatType::Deserialize(format_string);
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetUrlFormatType() {
-  static base::NoDestructor<FormatType> type(kMimeTypeURIList);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetUrlWFormatType() {
-  return GetUrlFormatType();
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetMozUrlFormatType() {
-  static base::NoDestructor<FormatType> type(kMimeTypeMozillaURL);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetPlainTextFormatType() {
-  static base::NoDestructor<FormatType> type(kMimeTypeText);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetPlainTextWFormatType() {
-  return GetPlainTextFormatType();
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetFilenameFormatType() {
-  static base::NoDestructor<FormatType> type(kMimeTypeFilename);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetFilenameWFormatType() {
-  return Clipboard::GetFilenameFormatType();
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetHtmlFormatType() {
-  static base::NoDestructor<FormatType> type(kMimeTypeHTML);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetRtfFormatType() {
-  static base::NoDestructor<FormatType> type(kMimeTypeRTF);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetBitmapFormatType() {
-  static base::NoDestructor<FormatType> type(kMimeTypeBitmap);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetWebKitSmartPasteFormatType() {
-  static base::NoDestructor<FormatType> type(kMimeTypeWebkitSmartPaste);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetWebCustomDataFormatType() {
-  static base::NoDestructor<FormatType> type(kMimeTypeWebCustomData);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetPepperCustomDataFormatType() {
-  static base::NoDestructor<FormatType> type(kMimeTypePepperCustomData);
-  return *type;
-}
-
 // Clipboard factory method.
 Clipboard* Clipboard::Create() {
   return new ClipboardAura;
@@ -537,20 +426,20 @@
   return clipboard_internal_->sequence_number();
 }
 
-bool ClipboardAura::IsFormatAvailable(const FormatType& format,
+bool ClipboardAura::IsFormatAvailable(const ClipboardFormatType& format,
                                       ClipboardType type) const {
   DCHECK(CalledOnValidThread());
   DCHECK(IsSupportedClipboardType(type));
-  if (GetPlainTextFormatType().Equals(format) ||
-      GetUrlFormatType().Equals(format))
+  if (ClipboardFormatType::GetPlainTextType().Equals(format) ||
+      ClipboardFormatType::GetUrlType().Equals(format))
     return clipboard_internal_->IsFormatAvailable(TEXT);
-  if (GetHtmlFormatType().Equals(format))
+  if (ClipboardFormatType::GetHtmlType().Equals(format))
     return clipboard_internal_->IsFormatAvailable(HTML);
-  if (GetRtfFormatType().Equals(format))
+  if (ClipboardFormatType::GetRtfType().Equals(format))
     return clipboard_internal_->IsFormatAvailable(RTF);
-  if (GetBitmapFormatType().Equals(format))
+  if (ClipboardFormatType::GetBitmapType().Equals(format))
     return clipboard_internal_->IsFormatAvailable(BITMAP);
-  if (GetWebKitSmartPasteFormatType().Equals(format))
+  if (ClipboardFormatType::GetWebKitSmartPasteType().Equals(format))
     return clipboard_internal_->IsFormatAvailable(WEB);
   const ClipboardData* data = clipboard_internal_->GetData();
   return data && data->custom_data_format() == format.ToString();
@@ -573,13 +462,16 @@
 
   types->clear();
   *contains_filenames = false;
-  if (IsFormatAvailable(GetPlainTextFormatType(), type))
-    types->push_back(base::UTF8ToUTF16(GetPlainTextFormatType().ToString()));
-  if (IsFormatAvailable(GetHtmlFormatType(), type))
-    types->push_back(base::UTF8ToUTF16(GetHtmlFormatType().ToString()));
-  if (IsFormatAvailable(GetRtfFormatType(), type))
-    types->push_back(base::UTF8ToUTF16(GetRtfFormatType().ToString()));
-  if (IsFormatAvailable(GetBitmapFormatType(), type))
+  if (IsFormatAvailable(ClipboardFormatType::GetPlainTextType(), type))
+    types->push_back(
+        base::UTF8ToUTF16(ClipboardFormatType::GetPlainTextType().ToString()));
+  if (IsFormatAvailable(ClipboardFormatType::GetHtmlType(), type))
+    types->push_back(
+        base::UTF8ToUTF16(ClipboardFormatType::GetHtmlType().ToString()));
+  if (IsFormatAvailable(ClipboardFormatType::GetRtfType(), type))
+    types->push_back(
+        base::UTF8ToUTF16(ClipboardFormatType::GetRtfType().ToString()));
+  if (IsFormatAvailable(ClipboardFormatType::GetBitmapType(), type))
     types->push_back(base::UTF8ToUTF16(kMimeTypePNG));
 
   if (clipboard_internal_->IsFormatAvailable(CUSTOM) &&
@@ -633,7 +525,7 @@
   clipboard_internal_->ReadBookmark(title, url);
 }
 
-void ClipboardAura::ReadData(const FormatType& format,
+void ClipboardAura::ReadData(const ClipboardFormatType& format,
                              std::string* result) const {
   DCHECK(CalledOnValidThread());
   clipboard_internal_->ReadData(format.ToString(), result);
@@ -677,7 +569,7 @@
   ClipboardDataBuilder::WriteBitmap(bitmap);
 }
 
-void ClipboardAura::WriteData(const FormatType& format,
+void ClipboardAura::WriteData(const ClipboardFormatType& format,
                               const char* data_data,
                               size_t data_len) {
   ClipboardDataBuilder::WriteData(format.ToString(), data_data, data_len);
--- a/ui/base/clipboard/clipboard_aura.h	2019-02-14 01:14:41.000000000 +0300
+++ b/ui/base/clipboard/clipboard_aura.h	2019-02-20 20:48:23.468000000 +0300
@@ -24,7 +24,7 @@
   // Clipboard overrides:
   void OnPreShutdown() override;
   uint64_t GetSequenceNumber(ClipboardType type) const override;
-  bool IsFormatAvailable(const FormatType& format,
+  bool IsFormatAvailable(const ClipboardFormatType& format,
                          ClipboardType type) const override;
   void Clear(ClipboardType type) override;
   void ReadAvailableTypes(ClipboardType type,
@@ -43,7 +43,8 @@
                       const base::string16& type,
                       base::string16* result) const override;
   void ReadBookmark(base::string16* title, std::string* url) const override;
-  void ReadData(const FormatType& format, std::string* result) const override;
+  void ReadData(const ClipboardFormatType& format,
+                std::string* result) const override;
   void WriteObjects(ClipboardType type, const ObjectMap& objects) override;
   void WriteText(const char* text_data, size_t text_len) override;
   void WriteHTML(const char* markup_data,
@@ -57,7 +58,7 @@
                      size_t url_len) override;
   void WriteWebSmartPaste() override;
   void WriteBitmap(const SkBitmap& bitmap) override;
-  void WriteData(const FormatType& format,
+  void WriteData(const ClipboardFormatType& format,
                  const char* data_data,
                  size_t data_len) override;
 
--- a/ui/base/clipboard/clipboard_aurax11.cc	2019-02-14 01:14:41.000000000 +0300
+++ b/ui/base/clipboard/clipboard_aurax11.cc	2019-02-20 20:48:23.468000000 +0300
@@ -21,6 +21,7 @@
 #include "base/stl_util.h"
 #include "base/strings/utf_string_conversions.h"
 #include "third_party/skia/include/core/SkBitmap.h"
+#include "ui/base/clipboard/clipboard_constants.h"
 #include "ui/base/clipboard/clipboard_monitor.h"
 #include "ui/base/clipboard/custom_data_helper.h"
 #include "ui/base/x/selection_owner.h"
@@ -42,7 +43,6 @@
 
 const char kClipboard[] = "CLIPBOARD";
 const char kClipboardManager[] = "CLIPBOARD_MANAGER";
-const char kMimeTypeFilename[] = "chromium/filename";
 
 ///////////////////////////////////////////////////////////////////////////////
 
@@ -135,7 +135,7 @@
   const AtomVector& target_list() { return target_list_; }
 
   bool ContainsText() const;
-  bool ContainsFormat(const Clipboard::FormatType& format_type) const;
+  bool ContainsFormat(const ClipboardFormatType& format_type) const;
   bool ContainsAtom(::Atom atom) const;
 
  private:
@@ -155,8 +155,7 @@
   return false;
 }
 
-bool TargetList::ContainsFormat(
-    const Clipboard::FormatType& format_type) const {
+bool TargetList::ContainsFormat(const ClipboardFormatType& format_type) const {
   ::Atom atom = gfx::GetAtom(format_type.ToString().c_str());
   return ContainsAtom(atom);
 }
@@ -169,41 +168,6 @@
 }  // namespace
 
 ///////////////////////////////////////////////////////////////////////////////
-
-// I would love for the FormatType to really be a wrapper around an X11 ::Atom,
-// but there are a few problems. Chromeos unit tests spawn a new X11 server for
-// each test, so Atom numeric values don't persist across tests. We could still
-// maybe deal with that if we didn't have static accessor methods everywhere.
-
-Clipboard::FormatType::FormatType() {
-}
-
-Clipboard::FormatType::FormatType(const std::string& native_format)
-    : data_(native_format) {
-}
-
-Clipboard::FormatType::~FormatType() {
-}
-
-std::string Clipboard::FormatType::Serialize() const {
-  return data_;
-}
-
-// static
-Clipboard::FormatType Clipboard::FormatType::Deserialize(
-    const std::string& serialization) {
-  return FormatType(serialization);
-}
-
-bool Clipboard::FormatType::operator<(const FormatType& other) const {
-  return data_ < other.data_;
-}
-
-bool Clipboard::FormatType::Equals(const FormatType& other) const {
-  return data_ == other.data_;
-}
-
-///////////////////////////////////////////////////////////////////////////////
 // ClipboardAuraX11::AuraX11Details
 
 // Private implementation of our X11 integration. Keeps X11 headers out of the
@@ -259,7 +223,7 @@
   std::vector< ::Atom> GetTextAtoms() const;
 
   // Returns a vector with a |format| converted to an X11 atom.
-  std::vector< ::Atom> GetAtomsForFormat(const Clipboard::FormatType& format);
+  std::vector<::Atom> GetAtomsForFormat(const ClipboardFormatType& format);
 
   // Clears a certain clipboard type, whether we own it or not.
   void Clear(ClipboardType type);
@@ -448,7 +412,7 @@
 }
 
 std::vector<::Atom> ClipboardAuraX11::AuraX11Details::GetAtomsForFormat(
-    const Clipboard::FormatType& format) {
+    const ClipboardFormatType& format) {
   std::vector< ::Atom> atoms;
   atoms.push_back(gfx::GetAtom(format.ToString().c_str()));
   return atoms;
@@ -541,89 +505,6 @@
 }
 
 ///////////////////////////////////////////////////////////////////////////////
-// Various predefined FormatTypes.
-// static
-Clipboard::FormatType Clipboard::GetFormatType(
-    const std::string& format_string) {
-  return FormatType::Deserialize(format_string);
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetUrlFormatType() {
-  static base::NoDestructor<FormatType> type(kMimeTypeURIList);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetUrlWFormatType() {
-  return GetUrlFormatType();
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetMozUrlFormatType() {
-  static base::NoDestructor<FormatType> type(kMimeTypeMozillaURL);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetPlainTextFormatType() {
-  static base::NoDestructor<FormatType> type(kMimeTypeText);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetPlainTextWFormatType() {
-  return GetPlainTextFormatType();
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetFilenameFormatType() {
-  static base::NoDestructor<FormatType> type(kMimeTypeFilename);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetFilenameWFormatType() {
-  return Clipboard::GetFilenameFormatType();
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetHtmlFormatType() {
-  static base::NoDestructor<FormatType> type(kMimeTypeHTML);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetRtfFormatType() {
-  static base::NoDestructor<FormatType> type(kMimeTypeRTF);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetBitmapFormatType() {
-  static base::NoDestructor<FormatType> type(kMimeTypePNG);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetWebKitSmartPasteFormatType() {
-  static base::NoDestructor<FormatType> type(kMimeTypeWebkitSmartPaste);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetWebCustomDataFormatType() {
-  static base::NoDestructor<FormatType> type(kMimeTypeWebCustomData);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetPepperCustomDataFormatType() {
-  static base::NoDestructor<FormatType> type(kMimeTypePepperCustomData);
-  return *type;
-}
-
-///////////////////////////////////////////////////////////////////////////////
 // Clipboard factory method.
 Clipboard* Clipboard::Create() {
   return new ClipboardAuraX11;
@@ -653,14 +534,14 @@
     return SelectionChangeObserver::GetInstance()->primary_sequence_number();
 }
 
-bool ClipboardAuraX11::IsFormatAvailable(const FormatType& format,
+bool ClipboardAuraX11::IsFormatAvailable(const ClipboardFormatType& format,
                                          ClipboardType type) const {
   DCHECK(CalledOnValidThread());
   DCHECK(IsSupportedClipboardType(type));
 
   TargetList target_list = aurax11_details_->WaitAndGetTargetsList(type);
-  if (format.Equals(GetPlainTextFormatType()) ||
-      format.Equals(GetUrlFormatType())) {
+  if (format.Equals(ClipboardFormatType::GetPlainTextType()) ||
+      format.Equals(ClipboardFormatType::GetUrlType())) {
     return target_list.ContainsText();
   }
   return target_list.ContainsFormat(format);
@@ -687,16 +568,17 @@
 
   if (target_list.ContainsText())
     types->push_back(base::UTF8ToUTF16(kMimeTypeText));
-  if (target_list.ContainsFormat(GetHtmlFormatType()))
+  if (target_list.ContainsFormat(ClipboardFormatType::GetHtmlType()))
     types->push_back(base::UTF8ToUTF16(kMimeTypeHTML));
-  if (target_list.ContainsFormat(GetRtfFormatType()))
+  if (target_list.ContainsFormat(ClipboardFormatType::GetRtfType()))
     types->push_back(base::UTF8ToUTF16(kMimeTypeRTF));
-  if (target_list.ContainsFormat(GetBitmapFormatType()))
+  if (target_list.ContainsFormat(ClipboardFormatType::GetBitmapType()))
     types->push_back(base::UTF8ToUTF16(kMimeTypePNG));
   *contains_filenames = false;
 
   SelectionData data(aurax11_details_->RequestAndWaitForTypes(
-      type, aurax11_details_->GetAtomsForFormat(GetWebCustomDataFormatType())));
+      type, aurax11_details_->GetAtomsForFormat(
+                ClipboardFormatType::GetWebCustomDataType())));
   if (data.IsValid())
     ReadCustomDataTypes(data.GetData(), data.GetSize(), types);
 }
@@ -738,7 +620,8 @@
   *fragment_end = 0;
 
   SelectionData data(aurax11_details_->RequestAndWaitForTypes(
-      type, aurax11_details_->GetAtomsForFormat(GetHtmlFormatType())));
+      type,
+      aurax11_details_->GetAtomsForFormat(ClipboardFormatType::GetHtmlType())));
   if (data.IsValid()) {
     *markup = data.GetHtml();
 
@@ -752,7 +635,8 @@
   DCHECK(CalledOnValidThread());
 
   SelectionData data(aurax11_details_->RequestAndWaitForTypes(
-      type, aurax11_details_->GetAtomsForFormat(GetRtfFormatType())));
+      type,
+      aurax11_details_->GetAtomsForFormat(ClipboardFormatType::GetRtfType())));
   if (data.IsValid())
     data.AssignTo(result);
 }
@@ -761,7 +645,8 @@
   DCHECK(CalledOnValidThread());
 
   SelectionData data(aurax11_details_->RequestAndWaitForTypes(
-      type, aurax11_details_->GetAtomsForFormat(GetBitmapFormatType())));
+      type, aurax11_details_->GetAtomsForFormat(
+                ClipboardFormatType::GetBitmapType())));
   if (data.IsValid()) {
     SkBitmap bitmap;
     if (gfx::PNGCodec::Decode(data.GetData(), data.GetSize(), &bitmap))
@@ -777,8 +662,8 @@
   DCHECK(CalledOnValidThread());
 
   SelectionData data(aurax11_details_->RequestAndWaitForTypes(
-      clipboard_type,
-      aurax11_details_->GetAtomsForFormat(GetWebCustomDataFormatType())));
+      clipboard_type, aurax11_details_->GetAtomsForFormat(
+                          ClipboardFormatType::GetWebCustomDataType())));
   if (data.IsValid())
     ReadCustomDataForType(data.GetData(), data.GetSize(), type, result);
 }
@@ -790,7 +675,7 @@
   NOTIMPLEMENTED();
 }
 
-void ClipboardAuraX11::ReadData(const FormatType& format,
+void ClipboardAuraX11::ReadData(const ClipboardFormatType& format,
                                 std::string* result) const {
   DCHECK(CalledOnValidThread());
 
@@ -854,7 +739,7 @@
 }
 
 void ClipboardAuraX11::WriteRTF(const char* rtf_data, size_t data_len) {
-  WriteData(GetRtfFormatType(), rtf_data, data_len);
+  WriteData(ClipboardFormatType::GetRtfType(), rtf_data, data_len);
 }
 
 void ClipboardAuraX11::WriteBookmark(const char* title_data,
@@ -895,12 +780,12 @@
   }
 }
 
-void ClipboardAuraX11::WriteData(const FormatType& format,
+void ClipboardAuraX11::WriteData(const ClipboardFormatType& format,
                                  const char* data_data,
                                  size_t data_len) {
   // We assume that certain mapping types are only written by trusted code.
   // Therefore we must upkeep their integrity.
-  if (format.Equals(GetBitmapFormatType()))
+  if (format.Equals(ClipboardFormatType::GetBitmapType()))
     return;
 
   std::vector<unsigned char> bytes(data_data, data_data + data_len);
--- a/ui/base/clipboard/clipboard_aurax11.h	2019-02-14 01:14:41.000000000 +0300
+++ b/ui/base/clipboard/clipboard_aurax11.h	2019-02-20 20:48:23.468000000 +0300
@@ -25,7 +25,7 @@
   // Clipboard overrides:
   void OnPreShutdown() override;
   uint64_t GetSequenceNumber(ClipboardType type) const override;
-  bool IsFormatAvailable(const FormatType& format,
+  bool IsFormatAvailable(const ClipboardFormatType& format,
                          ClipboardType type) const override;
   void Clear(ClipboardType type) override;
   void ReadAvailableTypes(ClipboardType type,
@@ -44,7 +44,8 @@
                       const base::string16& type,
                       base::string16* result) const override;
   void ReadBookmark(base::string16* title, std::string* url) const override;
-  void ReadData(const FormatType& format, std::string* result) const override;
+  void ReadData(const ClipboardFormatType& format,
+                std::string* result) const override;
   void WriteObjects(ClipboardType type, const ObjectMap& objects) override;
   void WriteText(const char* text_data, size_t text_len) override;
   void WriteHTML(const char* markup_data,
@@ -58,7 +59,7 @@
                      size_t url_len) override;
   void WriteWebSmartPaste() override;
   void WriteBitmap(const SkBitmap& bitmap) override;
-  void WriteData(const FormatType& format,
+  void WriteData(const ClipboardFormatType& format,
                  const char* data_data,
                  size_t data_len) override;
 
--- a/ui/base/clipboard/clipboard.cc	2019-02-14 01:14:41.000000000 +0300
+++ b/ui/base/clipboard/clipboard.cc	2019-02-20 20:48:23.468000000 +0300
@@ -156,11 +156,9 @@
     }
 
     case CBF_DATA:
-      WriteData(
-          FormatType::Deserialize(
+      WriteData(ClipboardFormatType::Deserialize(
               std::string(&(params[0].front()), params[0].size())),
-          &(params[1].front()),
-          params[1].size());
+                &(params[1].front()), params[1].size());
       break;
 
     default:
--- a/ui/base/clipboard/clipboard_constants.cc	2019-02-14 01:14:41.000000000 +0300
+++ b/ui/base/clipboard/clipboard_constants.cc	2019-02-20 20:48:23.468000000 +0300
@@ -2,21 +2,20 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "ui/base/clipboard/clipboard.h"
+#include "ui/base/clipboard/clipboard_constants.h"
 
 namespace ui {
 
-const char Clipboard::kMimeTypeText[] = "text/plain";
-const char Clipboard::kMimeTypeURIList[] = "text/uri-list";
-const char Clipboard::kMimeTypeMozillaURL[] = "text/x-moz-url";
-const char Clipboard::kMimeTypeDownloadURL[] = "downloadurl";
-const char Clipboard::kMimeTypeHTML[] = "text/html";
-const char Clipboard::kMimeTypeRTF[] = "text/rtf";
-const char Clipboard::kMimeTypePNG[] = "image/png";
+const char kMimeTypeText[] = "text/plain";
+const char kMimeTypeURIList[] = "text/uri-list";
+const char kMimeTypeMozillaURL[] = "text/x-moz-url";
+const char kMimeTypeDownloadURL[] = "downloadurl";
+const char kMimeTypeHTML[] = "text/html";
+const char kMimeTypeRTF[] = "text/rtf";
+const char kMimeTypePNG[] = "image/png";
 // TODO(dcheng): This name is temporary. See crbug.com/106449.
-const char Clipboard::kMimeTypeWebCustomData[] = "chromium/x-web-custom-data";
-const char Clipboard::kMimeTypeWebkitSmartPaste[] = "chromium/x-webkit-paste";
-const char Clipboard::kMimeTypePepperCustomData[] =
-    "chromium/x-pepper-custom-data";
+const char kMimeTypeWebCustomData[] = "chromium/x-web-custom-data";
+const char kMimeTypeWebkitSmartPaste[] = "chromium/x-webkit-paste";
+const char kMimeTypePepperCustomData[] = "chromium/x-pepper-custom-data";
 
 }  // namespace ui
--- a/ui/base/clipboard/clipboard.h	2019-02-14 01:14:41.000000000 +0300
+++ b/ui/base/clipboard/clipboard.h	2019-02-20 20:48:23.468000000 +0300
@@ -13,6 +13,7 @@
 #include <vector>
 
 #include "base/compiler_specific.h"
+#include "base/component_export.h"
 #include "base/containers/flat_map.h"
 #include "base/lazy_instance.h"
 #include "base/macros.h"
@@ -24,93 +25,17 @@
 #include "base/threading/thread_checker.h"
 #include "base/time/time.h"
 #include "build/build_config.h"
+#include "ui/base/clipboard/clipboard_format_type.h"
 #include "ui/base/clipboard/clipboard_types.h"
-#include "ui/base/ui_base_export.h"
-
-#if defined(OS_WIN)
-#include <objidl.h>
-#endif
 
 class SkBitmap;
 
-#ifdef __OBJC__
-@class NSString;
-#else
-class NSString;
-#endif
-
 namespace ui {
 class TestClipboard;
 class ScopedClipboardWriter;
 
-class UI_BASE_EXPORT Clipboard : public base::ThreadChecker {
+class COMPONENT_EXPORT(BASE_CLIPBOARD) Clipboard : public base::ThreadChecker {
  public:
-  // MIME type constants.
-  static const char kMimeTypeText[];
-  static const char kMimeTypeURIList[];
-  static const char kMimeTypeDownloadURL[];
-  static const char kMimeTypeMozillaURL[];
-  static const char kMimeTypeHTML[];
-  static const char kMimeTypeRTF[];
-  static const char kMimeTypePNG[];
-  static const char kMimeTypeWebCustomData[];
-  static const char kMimeTypeWebkitSmartPaste[];
-  static const char kMimeTypePepperCustomData[];
-
-  // Platform neutral holder for native data representation of a clipboard type.
-  struct UI_BASE_EXPORT FormatType {
-    FormatType();
-    ~FormatType();
-
-    // Serializes and deserializes a FormatType for use in IPC messages.
-    std::string Serialize() const;
-    static FormatType Deserialize(const std::string& serialization);
-
-    // FormatType can be used in a set on some platforms.
-    bool operator<(const FormatType& other) const;
-
-#if defined(OS_WIN)
-    const FORMATETC& ToFormatEtc() const { return data_; }
-#elif defined(USE_AURA) || defined(OS_ANDROID) || defined(OS_FUCHSIA)
-    const std::string& ToString() const { return data_; }
-#elif defined(OS_MACOSX)
-    NSString* ToNSString() const { return data_; }
-    // Custom copy and assignment constructor to handle NSString.
-    FormatType(const FormatType& other);
-    FormatType& operator=(const FormatType& other);
-#endif
-
-    bool Equals(const FormatType& other) const;
-
-   private:
-    friend class base::NoDestructor<FormatType>;
-    friend class Clipboard;
-
-    // Platform-specific glue used internally by the Clipboard class. Each
-    // plaform should define,at least one of each of the following:
-    // 1. A constructor that wraps that native clipboard format descriptor.
-    // 2. An accessor to retrieve the wrapped descriptor.
-    // 3. A data member to hold the wrapped descriptor.
-    //
-    // Note that in some cases, the accessor for the wrapped descriptor may be
-    // public, as these format types can be used by drag and drop code as well.
-#if defined(OS_WIN)
-    explicit FormatType(UINT native_format);
-    FormatType(UINT native_format, LONG index);
-    FORMATETC data_;
-#elif defined(USE_AURA) || defined(OS_ANDROID) || defined(OS_FUCHSIA)
-    explicit FormatType(const std::string& native_format);
-    std::string data_;
-#elif defined(OS_MACOSX)
-    explicit FormatType(NSString* native_format);
-    NSString* data_;
-#else
-#error No FormatType definition.
-#endif
-
-    // Copyable and assignable, since this is essentially an opaque value type.
-  };
-
   static bool IsSupportedClipboardType(int32_t type) {
     switch (type) {
       case CLIPBOARD_TYPE_COPY_PASTE:
@@ -166,7 +91,7 @@
   virtual uint64_t GetSequenceNumber(ClipboardType type) const = 0;
 
   // Tests whether the clipboard contains a certain format
-  virtual bool IsFormatAvailable(const FormatType& format,
+  virtual bool IsFormatAvailable(const ClipboardFormatType& format,
                                  ClipboardType type) const = 0;
 
   // Clear the clipboard data.
@@ -208,7 +133,7 @@
 
   // Reads raw data from the clipboard with the given format type. Stores result
   // as a byte vector.
-  virtual void ReadData(const FormatType& format,
+  virtual void ReadData(const ClipboardFormatType& format,
                         std::string* result) const = 0;
 
   // Returns an estimate of the time the clipboard was last updated.  If the
@@ -218,38 +143,6 @@
   // Resets the clipboard last modified time to Time::Time().
   virtual void ClearLastModifiedTime();
 
-  // Gets the FormatType corresponding to an arbitrary format string,
-  // registering it with the system if needed. Due to Windows/Linux
-  // limitiations, |format_string| must never be controlled by the user.
-  static FormatType GetFormatType(const std::string& format_string);
-
-  // Get format identifiers for various types.
-  static const FormatType& GetUrlFormatType();
-  static const FormatType& GetUrlWFormatType();
-  static const FormatType& GetMozUrlFormatType();
-  static const FormatType& GetPlainTextFormatType();
-  static const FormatType& GetPlainTextWFormatType();
-  static const FormatType& GetFilenameFormatType();
-  static const FormatType& GetFilenameWFormatType();
-  static const FormatType& GetWebKitSmartPasteFormatType();
-  // Win: MS HTML Format, Other: Generic HTML format
-  static const FormatType& GetHtmlFormatType();
-  static const FormatType& GetRtfFormatType();
-  static const FormatType& GetBitmapFormatType();
-  // TODO(raymes): Unify web custom data and pepper custom data:
-  // crbug.com/158399.
-  static const FormatType& GetWebCustomDataFormatType();
-  static const FormatType& GetPepperCustomDataFormatType();
-
-#if defined(OS_WIN)
-  // Firefox text/html
-  static const FormatType& GetTextHtmlFormatType();
-  static const FormatType& GetCFHDropFormatType();
-  static const FormatType& GetFileDescriptorFormatType();
-  static const FormatType& GetFileContentZeroFormatType();
-  static const FormatType& GetIDListFormatType();
-#endif
-
  protected:
   static Clipboard* Create();
 
@@ -258,10 +151,10 @@
 
   // ObjectType designates the type of data to be stored in the clipboard. This
   // designation is shared across all OSes. The system-specific designation
-  // is defined by FormatType. A single ObjectType might be represented by
-  // several system-specific FormatTypes. For example, on Linux the CBF_TEXT
-  // ObjectType maps to "text/plain", "STRING", and several other formats. On
-  // windows it maps to CF_UNICODETEXT.
+  // is defined by ClipboardFormatType. A single ObjectType might be represented
+  // by several system-specific ClipboardFormatTypes. For example, on Linux the
+  // CBF_TEXT ObjectType maps to "text/plain", "STRING", and several other
+  // formats. On windows it maps to CF_UNICODETEXT.
   //
   // The order below is the order in which data will be written to the
   // clipboard, so more specific types must be listed before less specific
@@ -326,7 +219,7 @@
 
   virtual void WriteBitmap(const SkBitmap& bitmap) = 0;
 
-  virtual void WriteData(const FormatType& format,
+  virtual void WriteData(const ClipboardFormatType& format,
                          const char* data_data,
                          size_t data_len) = 0;
 
--- a/ui/base/clipboard/clipboard_mac.h	2019-02-14 01:14:41.000000000 +0300
+++ b/ui/base/clipboard/clipboard_mac.h	2019-02-20 20:48:23.468000000 +0300
@@ -8,16 +8,16 @@
 #include <stddef.h>
 #include <stdint.h>
 
+#include "base/component_export.h"
 #include "base/gtest_prod_util.h"
 #include "base/macros.h"
 #include "ui/base/clipboard/clipboard.h"
-#include "ui/base/ui_base_export.h"
 
 @class NSPasteboard;
 
 namespace ui {
 
-class UI_BASE_EXPORT ClipboardMac : public Clipboard {
+class COMPONENT_EXPORT(BASE_CLIPBOARD) ClipboardMac : public Clipboard {
  private:
   FRIEND_TEST_ALL_PREFIXES(ClipboardMacTest, ReadImageRetina);
   FRIEND_TEST_ALL_PREFIXES(ClipboardMacTest, ReadImageNonRetina);
@@ -31,7 +31,7 @@
   // Clipboard overrides:
   void OnPreShutdown() override;
   uint64_t GetSequenceNumber(ClipboardType type) const override;
-  bool IsFormatAvailable(const FormatType& format,
+  bool IsFormatAvailable(const ClipboardFormatType& format,
                          ClipboardType type) const override;
   void Clear(ClipboardType type) override;
   void ReadAvailableTypes(ClipboardType type,
@@ -51,7 +51,8 @@
                       const base::string16& type,
                       base::string16* result) const override;
   void ReadBookmark(base::string16* title, std::string* url) const override;
-  void ReadData(const FormatType& format, std::string* result) const override;
+  void ReadData(const ClipboardFormatType& format,
+                std::string* result) const override;
   void WriteObjects(ClipboardType type, const ObjectMap& objects) override;
   void WriteText(const char* text_data, size_t text_len) override;
   void WriteHTML(const char* markup_data,
@@ -65,7 +66,7 @@
                      size_t url_len) override;
   void WriteWebSmartPaste() override;
   void WriteBitmap(const SkBitmap& bitmap) override;
-  void WriteData(const FormatType& format,
+  void WriteData(const ClipboardFormatType& format,
                  const char* data_data,
                  size_t data_len) override;
 
--- a/ui/base/clipboard/clipboard_mac.mm	2019-02-14 01:14:41.000000000 +0300
+++ b/ui/base/clipboard/clipboard_mac.mm	2019-02-20 20:48:23.468000000 +0300
@@ -11,6 +11,7 @@
 
 #include "base/files/file_path.h"
 #include "base/logging.h"
+#include "base/mac/foundation_util.h"
 #include "base/mac/mac_util.h"
 #include "base/mac/scoped_cftyperef.h"
 #include "base/mac/scoped_nsobject.h"
@@ -22,6 +23,7 @@
 #include "skia/ext/skia_utils_mac.h"
 #import "third_party/mozilla/NSPasteboard+Utils.h"
 #include "third_party/skia/include/core/SkBitmap.h"
+#include "ui/base/clipboard/clipboard_constants.h"
 #include "ui/base/clipboard/clipboard_util_mac.h"
 #include "ui/base/clipboard/custom_data_helper.h"
 #include "ui/gfx/canvas.h"
@@ -32,14 +34,6 @@
 
 namespace {
 
-// Tells us if WebKit was the last to write to the pasteboard. There's no
-// actual data associated with this type.
-NSString* const kWebSmartPastePboardType = @"NeXT smart paste pasteboard type";
-
-// Pepper custom data format type.
-NSString* const kPepperCustomDataPboardType =
-    @"org.chromium.pepper-custom-data";
-
 NSPasteboard* GetPasteboard() {
   // The pasteboard can always be nil, since there is a finite amount of storage
   // that must be shared between all pasteboards.
@@ -49,125 +43,6 @@
 
 }  // namespace
 
-// Clipboard::FormatType implementation.
-Clipboard::FormatType::FormatType() : data_(nil) {
-}
-
-Clipboard::FormatType::FormatType(NSString* native_format)
-    : data_([native_format retain]) {
-}
-
-Clipboard::FormatType::FormatType(const FormatType& other)
-    : data_([other.data_ retain]) {
-}
-
-Clipboard::FormatType& Clipboard::FormatType::operator=(
-    const FormatType& other) {
-  if (this != &other) {
-    [data_ release];
-    data_ = [other.data_ retain];
-  }
-  return *this;
-}
-
-bool Clipboard::FormatType::Equals(const FormatType& other) const {
-  return [data_ isEqualToString:other.data_];
-}
-
-Clipboard::FormatType::~FormatType() {
-  [data_ release];
-}
-
-std::string Clipboard::FormatType::Serialize() const {
-  return base::SysNSStringToUTF8(data_);
-}
-
-// static
-Clipboard::FormatType Clipboard::FormatType::Deserialize(
-    const std::string& serialization) {
-  return FormatType(base::SysUTF8ToNSString(serialization));
-}
-
-bool Clipboard::FormatType::operator<(const FormatType& other) const {
-  return [data_ compare:other.data_] == NSOrderedAscending;
-}
-
-// Various predefined FormatTypes.
-// static
-Clipboard::FormatType Clipboard::GetFormatType(
-    const std::string& format_string) {
-  return FormatType::Deserialize(format_string);
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetUrlFormatType() {
-  static base::NoDestructor<FormatType> type(NSURLPboardType);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetUrlWFormatType() {
-  return GetUrlFormatType();
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetPlainTextFormatType() {
-  static base::NoDestructor<FormatType> type(NSPasteboardTypeString);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetPlainTextWFormatType() {
-  return GetPlainTextFormatType();
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetFilenameFormatType() {
-  static base::NoDestructor<FormatType> type(NSFilenamesPboardType);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetFilenameWFormatType() {
-  return GetFilenameFormatType();
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetHtmlFormatType() {
-  static base::NoDestructor<FormatType> type(NSHTMLPboardType);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetRtfFormatType() {
-  static base::NoDestructor<FormatType> type(NSRTFPboardType);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetBitmapFormatType() {
-  static base::NoDestructor<FormatType> type(NSTIFFPboardType);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetWebKitSmartPasteFormatType() {
-  static base::NoDestructor<FormatType> type(kWebSmartPastePboardType);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetWebCustomDataFormatType() {
-  static base::NoDestructor<FormatType> type(kWebCustomDataPboardType);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetPepperCustomDataFormatType() {
-  static base::NoDestructor<FormatType> type(kPepperCustomDataPboardType);
-  return *type;
-}
-
 // Clipboard factory method.
 // static
 Clipboard* Clipboard::Create() {
@@ -193,7 +68,7 @@
   return [pb changeCount];
 }
 
-bool ClipboardMac::IsFormatAvailable(const FormatType& format,
+bool ClipboardMac::IsFormatAvailable(const ClipboardFormatType& format,
                                      ClipboardType type) const {
   DCHECK(CalledOnValidThread());
   DCHECK_EQ(type, CLIPBOARD_TYPE_COPY_PASTE);
@@ -223,11 +98,11 @@
                                       bool* contains_filenames) const {
   DCHECK(CalledOnValidThread());
   types->clear();
-  if (IsFormatAvailable(Clipboard::GetPlainTextFormatType(), type))
+  if (IsFormatAvailable(ClipboardFormatType::GetPlainTextType(), type))
     types->push_back(base::UTF8ToUTF16(kMimeTypeText));
-  if (IsFormatAvailable(Clipboard::GetHtmlFormatType(), type))
+  if (IsFormatAvailable(ClipboardFormatType::GetHtmlType(), type))
     types->push_back(base::UTF8ToUTF16(kMimeTypeHTML));
-  if (IsFormatAvailable(Clipboard::GetRtfFormatType(), type))
+  if (IsFormatAvailable(ClipboardFormatType::GetRtfType(), type))
     types->push_back(base::UTF8ToUTF16(kMimeTypeRTF));
 
   NSPasteboard* pb = GetPasteboard();
@@ -299,7 +174,7 @@
   DCHECK(CalledOnValidThread());
   DCHECK_EQ(type, CLIPBOARD_TYPE_COPY_PASTE);
 
-  return ReadData(GetRtfFormatType(), result);
+  return ReadData(ClipboardFormatType::GetRtfType(), result);
 }
 
 SkBitmap ClipboardMac::ReadImage(ClipboardType type, NSPasteboard* pb) const {
@@ -387,7 +262,7 @@
   }
 }
 
-void ClipboardMac::ReadData(const FormatType& format,
+void ClipboardMac::ReadData(const ClipboardFormatType& format,
                             std::string* result) const {
   DCHECK(CalledOnValidThread());
   NSPasteboard* pb = GetPasteboard();
@@ -433,7 +308,7 @@
 }
 
 void ClipboardMac::WriteRTF(const char* rtf_data, size_t data_len) {
-  WriteData(GetRtfFormatType(), rtf_data, data_len);
+  WriteData(ClipboardFormatType::GetRtfType(), rtf_data, data_len);
 }
 
 void ClipboardMac::WriteBookmark(const char* title_data,
@@ -475,7 +350,7 @@
   }
 }
 
-void ClipboardMac::WriteData(const FormatType& format,
+void ClipboardMac::WriteData(const ClipboardFormatType& format,
                              const char* data_data,
                              size_t data_len) {
   NSPasteboard* pb = GetPasteboard();
@@ -488,7 +363,8 @@
 // pasteboard. This flavor has no data.
 void ClipboardMac::WriteWebSmartPaste() {
   NSPasteboard* pb = GetPasteboard();
-  NSString* format = GetWebKitSmartPasteFormatType().ToNSString();
+  NSString* format =
+      ClipboardFormatType::GetWebKitSmartPasteType().ToNSString();
   [pb addTypes:@[ format ] owner:nil];
   [pb setData:nil forType:format];
 }
--- a/ui/base/clipboard/clipboard_monitor.h	2019-02-14 01:14:41.000000000 +0300
+++ b/ui/base/clipboard/clipboard_monitor.h	2019-02-20 20:48:23.468000000 +0300
@@ -5,11 +5,11 @@
 #ifndef UI_BASE_CLIPBOARD_CLIPBOARD_MONITOR_H_
 #define UI_BASE_CLIPBOARD_CLIPBOARD_MONITOR_H_
 
+#include "base/component_export.h"
 #include "base/macros.h"
 #include "base/no_destructor.h"
 #include "base/observer_list.h"
 #include "base/threading/thread_checker.h"
-#include "ui/base/ui_base_export.h"
 
 namespace ui {
 
@@ -17,7 +17,7 @@
 
 // A singleton instance to monitor and notify ClipboardObservers for clipboard
 // changes.
-class UI_BASE_EXPORT ClipboardMonitor {
+class COMPONENT_EXPORT(BASE_CLIPBOARD) ClipboardMonitor {
  public:
   static ClipboardMonitor* GetInstance();
 
--- a/ui/base/clipboard/clipboard_observer.h	2019-02-14 01:14:41.000000000 +0300
+++ b/ui/base/clipboard/clipboard_observer.h	2019-02-20 20:48:23.468000000 +0300
@@ -5,13 +5,13 @@
 #ifndef UI_BASE_CLIPBOARD_CLIPBOARD_OBSERVER_H_
 #define UI_BASE_CLIPBOARD_CLIPBOARD_OBSERVER_H_
 
+#include "base/component_export.h"
 #include "base/macros.h"
-#include "ui/base/ui_base_export.h"
 
 namespace ui {
 
 // Observer that receives the notifications of clipboard change events.
-class UI_BASE_EXPORT ClipboardObserver {
+class COMPONENT_EXPORT(BASE_CLIPBOARD) ClipboardObserver {
  public:
   // Called when clipboard data is changed.
   virtual void OnClipboardDataChanged() = 0;
--- a/ui/base/clipboard/clipboard_test_template.h	2019-02-14 01:14:41.000000000 +0300
+++ b/ui/base/clipboard/clipboard_test_template.h	2019-02-20 20:48:23.468000000 +0300
@@ -34,8 +34,9 @@
 #include "third_party/skia/include/core/SkScalar.h"
 #include "third_party/skia/include/core/SkUnPreMultiply.h"
 #include "ui/base/clipboard/clipboard.h"
+#include "ui/base/clipboard/clipboard_constants.h"
 #include "ui/base/clipboard/scoped_clipboard_writer.h"
-#include "ui/base/test/test_clipboard.h"
+#include "ui/base/clipboard/test/test_clipboard.h"
 #include "ui/gfx/geometry/size.h"
 #include "ui/gfx/half_float.h"
 
@@ -109,9 +110,9 @@
 
   EXPECT_TRUE(this->GetAvailableTypes(CLIPBOARD_TYPE_COPY_PASTE).empty());
   EXPECT_FALSE(this->clipboard().IsFormatAvailable(
-      Clipboard::GetPlainTextWFormatType(), CLIPBOARD_TYPE_COPY_PASTE));
+      ClipboardFormatType::GetPlainTextWType(), CLIPBOARD_TYPE_COPY_PASTE));
   EXPECT_FALSE(this->clipboard().IsFormatAvailable(
-      Clipboard::GetPlainTextFormatType(), CLIPBOARD_TYPE_COPY_PASTE));
+      ClipboardFormatType::GetPlainTextType(), CLIPBOARD_TYPE_COPY_PASTE));
 }
 
 TYPED_TEST(ClipboardTest, TextTest) {
@@ -124,11 +125,11 @@
   }
 
   EXPECT_THAT(this->GetAvailableTypes(CLIPBOARD_TYPE_COPY_PASTE),
-              Contains(ASCIIToUTF16(Clipboard::kMimeTypeText)));
+              Contains(ASCIIToUTF16(kMimeTypeText)));
   EXPECT_TRUE(this->clipboard().IsFormatAvailable(
-      Clipboard::GetPlainTextWFormatType(), CLIPBOARD_TYPE_COPY_PASTE));
+      ClipboardFormatType::GetPlainTextWType(), CLIPBOARD_TYPE_COPY_PASTE));
   EXPECT_TRUE(this->clipboard().IsFormatAvailable(
-      Clipboard::GetPlainTextFormatType(), CLIPBOARD_TYPE_COPY_PASTE));
+      ClipboardFormatType::GetPlainTextType(), CLIPBOARD_TYPE_COPY_PASTE));
   this->clipboard().ReadText(CLIPBOARD_TYPE_COPY_PASTE, &text_result);
 
   EXPECT_EQ(text, text_result);
@@ -148,9 +149,9 @@
   }
 
   EXPECT_THAT(this->GetAvailableTypes(CLIPBOARD_TYPE_COPY_PASTE),
-              Contains(ASCIIToUTF16(Clipboard::kMimeTypeHTML)));
+              Contains(ASCIIToUTF16(kMimeTypeHTML)));
   EXPECT_TRUE(this->clipboard().IsFormatAvailable(
-      Clipboard::GetHtmlFormatType(), CLIPBOARD_TYPE_COPY_PASTE));
+      ClipboardFormatType::GetHtmlType(), CLIPBOARD_TYPE_COPY_PASTE));
   uint32_t fragment_start;
   uint32_t fragment_end;
   this->clipboard().ReadHTML(CLIPBOARD_TYPE_COPY_PASTE, &markup_result,
@@ -177,16 +178,16 @@
   }
 
   EXPECT_THAT(this->GetAvailableTypes(CLIPBOARD_TYPE_COPY_PASTE),
-              Contains(ASCIIToUTF16(Clipboard::kMimeTypeRTF)));
-  EXPECT_TRUE(this->clipboard().IsFormatAvailable(Clipboard::GetRtfFormatType(),
-                                                  CLIPBOARD_TYPE_COPY_PASTE));
+              Contains(ASCIIToUTF16(kMimeTypeRTF)));
+  EXPECT_TRUE(this->clipboard().IsFormatAvailable(
+      ClipboardFormatType::GetRtfType(), CLIPBOARD_TYPE_COPY_PASTE));
   std::string result;
   this->clipboard().ReadRTF(CLIPBOARD_TYPE_COPY_PASTE, &result);
   EXPECT_EQ(rtf, result);
 }
 
-// TODO(dnicoara) Enable test once Ozone implements clipboard support:
-// crbug.com/361707
+// TODO(msisov, tonikitoo): Enable test once ClipboardOzone implements
+// selection support. https://crbug.com/911992
 #if defined(OS_LINUX) && !defined(OS_CHROMEOS) && !defined(USE_OZONE)
 TYPED_TEST(ClipboardTest, MultipleBufferTest) {
   base::string16 text(ASCIIToUTF16("Standard")), text_result;
@@ -204,19 +205,19 @@
   }
 
   EXPECT_THAT(this->GetAvailableTypes(CLIPBOARD_TYPE_COPY_PASTE),
-              Contains(ASCIIToUTF16(Clipboard::kMimeTypeText)));
+              Contains(ASCIIToUTF16(kMimeTypeText)));
   EXPECT_THAT(this->GetAvailableTypes(CLIPBOARD_TYPE_SELECTION),
-              Contains(ASCIIToUTF16(Clipboard::kMimeTypeHTML)));
+              Contains(ASCIIToUTF16(kMimeTypeHTML)));
 
   EXPECT_TRUE(this->clipboard().IsFormatAvailable(
-      Clipboard::GetPlainTextFormatType(), CLIPBOARD_TYPE_COPY_PASTE));
+      ClipboardFormatType::GetPlainTextType(), CLIPBOARD_TYPE_COPY_PASTE));
   EXPECT_FALSE(this->clipboard().IsFormatAvailable(
-      Clipboard::GetPlainTextFormatType(), CLIPBOARD_TYPE_SELECTION));
+      ClipboardFormatType::GetPlainTextType(), CLIPBOARD_TYPE_SELECTION));
 
   EXPECT_FALSE(this->clipboard().IsFormatAvailable(
-      Clipboard::GetHtmlFormatType(), CLIPBOARD_TYPE_COPY_PASTE));
+      ClipboardFormatType::GetHtmlType(), CLIPBOARD_TYPE_COPY_PASTE));
   EXPECT_TRUE(this->clipboard().IsFormatAvailable(
-      Clipboard::GetHtmlFormatType(), CLIPBOARD_TYPE_SELECTION));
+      ClipboardFormatType::GetHtmlType(), CLIPBOARD_TYPE_SELECTION));
 
   this->clipboard().ReadText(CLIPBOARD_TYPE_COPY_PASTE, &text_result);
   EXPECT_EQ(text, text_result);
@@ -245,9 +246,9 @@
   }
 
   EXPECT_THAT(this->GetAvailableTypes(CLIPBOARD_TYPE_COPY_PASTE),
-              Contains(ASCIIToUTF16(Clipboard::kMimeTypeHTML)));
+              Contains(ASCIIToUTF16(kMimeTypeHTML)));
   EXPECT_TRUE(this->clipboard().IsFormatAvailable(
-      Clipboard::GetHtmlFormatType(), CLIPBOARD_TYPE_COPY_PASTE));
+      ClipboardFormatType::GetHtmlType(), CLIPBOARD_TYPE_COPY_PASTE));
   uint32_t fragment_start;
   uint32_t fragment_end;
   this->clipboard().ReadHTML(CLIPBOARD_TYPE_COPY_PASTE, &markup_result,
@@ -275,9 +276,9 @@
   }
 
   EXPECT_THAT(this->GetAvailableTypes(CLIPBOARD_TYPE_COPY_PASTE),
-              Contains(ASCIIToUTF16(Clipboard::kMimeTypeHTML)));
+              Contains(ASCIIToUTF16(kMimeTypeHTML)));
   EXPECT_TRUE(this->clipboard().IsFormatAvailable(
-      Clipboard::GetHtmlFormatType(), CLIPBOARD_TYPE_COPY_PASTE));
+      ClipboardFormatType::GetHtmlType(), CLIPBOARD_TYPE_COPY_PASTE));
   uint32_t fragment_start;
   uint32_t fragment_end;
   this->clipboard().ReadHTML(CLIPBOARD_TYPE_COPY_PASTE, &markup_result,
@@ -302,7 +303,7 @@
   }
 
   EXPECT_TRUE(this->clipboard().IsFormatAvailable(
-      Clipboard::GetUrlWFormatType(), CLIPBOARD_TYPE_COPY_PASTE));
+      ClipboardFormatType::GetUrlWType(), CLIPBOARD_TYPE_COPY_PASTE));
   this->clipboard().ReadBookmark(&title_result, &url_result);
   EXPECT_EQ(title, title_result);
   EXPECT_EQ(url, url_result);
@@ -322,15 +323,15 @@
   }
 
   EXPECT_THAT(this->GetAvailableTypes(CLIPBOARD_TYPE_COPY_PASTE),
-              Contains(ASCIIToUTF16(Clipboard::kMimeTypeHTML)));
+              Contains(ASCIIToUTF16(kMimeTypeHTML)));
   EXPECT_THAT(this->GetAvailableTypes(CLIPBOARD_TYPE_COPY_PASTE),
-              Contains(ASCIIToUTF16(Clipboard::kMimeTypeText)));
+              Contains(ASCIIToUTF16(kMimeTypeText)));
   EXPECT_TRUE(this->clipboard().IsFormatAvailable(
-      Clipboard::GetHtmlFormatType(), CLIPBOARD_TYPE_COPY_PASTE));
+      ClipboardFormatType::GetHtmlType(), CLIPBOARD_TYPE_COPY_PASTE));
   EXPECT_TRUE(this->clipboard().IsFormatAvailable(
-      Clipboard::GetPlainTextWFormatType(), CLIPBOARD_TYPE_COPY_PASTE));
+      ClipboardFormatType::GetPlainTextWType(), CLIPBOARD_TYPE_COPY_PASTE));
   EXPECT_TRUE(this->clipboard().IsFormatAvailable(
-      Clipboard::GetPlainTextFormatType(), CLIPBOARD_TYPE_COPY_PASTE));
+      ClipboardFormatType::GetPlainTextType(), CLIPBOARD_TYPE_COPY_PASTE));
   uint32_t fragment_start;
   uint32_t fragment_end;
   this->clipboard().ReadHTML(CLIPBOARD_TYPE_COPY_PASTE, &markup_result,
@@ -358,11 +359,11 @@
   }
 
   EXPECT_THAT(this->GetAvailableTypes(CLIPBOARD_TYPE_COPY_PASTE),
-              Contains(ASCIIToUTF16(Clipboard::kMimeTypeText)));
+              Contains(ASCIIToUTF16(kMimeTypeText)));
   EXPECT_TRUE(this->clipboard().IsFormatAvailable(
-      Clipboard::GetPlainTextWFormatType(), CLIPBOARD_TYPE_COPY_PASTE));
+      ClipboardFormatType::GetPlainTextWType(), CLIPBOARD_TYPE_COPY_PASTE));
   EXPECT_TRUE(this->clipboard().IsFormatAvailable(
-      Clipboard::GetPlainTextFormatType(), CLIPBOARD_TYPE_COPY_PASTE));
+      ClipboardFormatType::GetPlainTextType(), CLIPBOARD_TYPE_COPY_PASTE));
   base::string16 text_result;
   this->clipboard().ReadText(CLIPBOARD_TYPE_COPY_PASTE, &text_result);
 
@@ -372,8 +373,10 @@
   this->clipboard().ReadAsciiText(CLIPBOARD_TYPE_COPY_PASTE, &ascii_text);
   EXPECT_EQ(UTF16ToUTF8(url), ascii_text);
 
+// TODO(tonikitoo, msisov): enable back for ClipboardOzone implements
+// selection support. https://crbug.com/911992
 #if defined(OS_POSIX) && !defined(OS_MACOSX) && !defined(OS_ANDROID) && \
-    !defined(OS_CHROMEOS)
+    !defined(OS_CHROMEOS) && !defined(USE_OZONE)
   ascii_text.clear();
   this->clipboard().ReadAsciiText(CLIPBOARD_TYPE_SELECTION, &ascii_text);
   EXPECT_EQ(UTF16ToUTF8(url), ascii_text);
@@ -399,7 +402,7 @@
     scw.WriteImage(bitmap);
   }
 
-  EXPECT_TRUE(clipboard->IsFormatAvailable(Clipboard::GetBitmapFormatType(),
+  EXPECT_TRUE(clipboard->IsFormatAvailable(ClipboardFormatType::GetBitmapType(),
                                            CLIPBOARD_TYPE_COPY_PASTE));
   const SkBitmap& image = clipboard->ReadImage(CLIPBOARD_TYPE_COPY_PASTE);
   ASSERT_EQ(image.info().colorType(), kN32_SkColorType);
@@ -517,8 +520,8 @@
 }  // namespace
 
 TYPED_TEST(ClipboardTest, DataTest) {
-  const ui::Clipboard::FormatType kFormat =
-      ui::Clipboard::GetFormatType("chromium/x-test-format");
+  const ui::ClipboardFormatType kFormat =
+      ui::ClipboardFormatType::GetType("chromium/x-test-format");
   std::string payload("test string");
   base::Pickle write_pickle;
   write_pickle.WriteString(payload);
@@ -542,14 +545,14 @@
 }
 
 TYPED_TEST(ClipboardTest, MultipleDataTest) {
-  const ui::Clipboard::FormatType kFormat1 =
-      ui::Clipboard::GetFormatType("chromium/x-test-format1");
+  const ui::ClipboardFormatType kFormat1 =
+      ui::ClipboardFormatType::GetType("chromium/x-test-format1");
   std::string payload1("test string1");
   base::Pickle write_pickle1;
   write_pickle1.WriteString(payload1);
 
-  const ui::Clipboard::FormatType kFormat2 =
-      ui::Clipboard::GetFormatType("chromium/x-test-format2");
+  const ui::ClipboardFormatType kFormat2 =
+      ui::ClipboardFormatType::GetType("chromium/x-test-format2");
   std::string payload2("test string2");
   base::Pickle write_pickle2;
   write_pickle2.WriteString(payload2);
@@ -613,7 +616,7 @@
   }
 
   EXPECT_TRUE(this->clipboard().IsFormatAvailable(
-      Clipboard::GetHtmlFormatType(), CLIPBOARD_TYPE_COPY_PASTE));
+      ClipboardFormatType::GetHtmlType(), CLIPBOARD_TYPE_COPY_PASTE));
   uint32_t fragment_start;
   uint32_t fragment_end;
   this->clipboard().ReadHTML(CLIPBOARD_TYPE_COPY_PASTE, &html_result,
@@ -631,7 +634,8 @@
   }
 
   EXPECT_TRUE(this->clipboard().IsFormatAvailable(
-      Clipboard::GetWebKitSmartPasteFormatType(), CLIPBOARD_TYPE_COPY_PASTE));
+      ClipboardFormatType::GetWebKitSmartPasteType(),
+      CLIPBOARD_TYPE_COPY_PASTE));
 }
 
 #if defined(OS_WIN)  // Windows only tests.
@@ -752,7 +756,7 @@
 
 TYPED_TEST(ClipboardTest, WritePickledData) {
   ScopedClipboardWriter scw(CLIPBOARD_TYPE_COPY_PASTE);
-  scw.WritePickledData(base::Pickle(), Clipboard::GetPlainTextFormatType());
+  scw.WritePickledData(base::Pickle(), ClipboardFormatType::GetPlainTextType());
 }
 
 TYPED_TEST(ClipboardTest, WriteImageEmptyParams) {
--- a/ui/base/clipboard/clipboard_util_mac.h	2019-02-14 01:14:41.000000000 +0300
+++ b/ui/base/clipboard/clipboard_util_mac.h	2019-02-20 20:48:23.472000000 +0300
@@ -7,18 +7,18 @@
 
 #import <AppKit/AppKit.h>
 
+#include "base/component_export.h"
 #include "base/mac/scoped_nsobject.h"
 #include "base/memory/ref_counted.h"
 #include "ui/base/clipboard/clipboard_types.h"
-#include "ui/base/ui_base_export.h"
 
 namespace ui {
 
 // A publicly-used UTI for the name of a URL. It really should be in a system
 // header but isn't.
-UI_BASE_EXPORT extern NSString* const kUTTypeURLName;
+COMPONENT_EXPORT(BASE_CLIPBOARD) extern NSString* const kUTTypeURLName;
 
-class UI_BASE_EXPORT UniquePasteboard
+class COMPONENT_EXPORT(BASE_CLIPBOARD) UniquePasteboard
     : public base::RefCounted<UniquePasteboard> {
  public:
   UniquePasteboard();
@@ -31,7 +31,7 @@
   base::scoped_nsobject<NSPasteboard> pasteboard_;
 };
 
-class UI_BASE_EXPORT ClipboardUtil {
+class COMPONENT_EXPORT(BASE_CLIPBOARD) ClipboardUtil {
  public:
   // Returns an NSPasteboardItem that represents the given |url|.
   // |url| must not be nil.
--- a/ui/base/clipboard/clipboard_util_win.cc	2019-02-14 01:14:41.000000000 +0300
+++ b/ui/base/clipboard/clipboard_util_win.cc	2019-02-20 20:48:23.472000000 +0300
@@ -17,7 +17,7 @@
 #include "base/win/scoped_hglobal.h"
 #include "base/win/shlwapi.h"
 #include "net/base/filename_util.h"
-#include "ui/base/clipboard/clipboard.h"
+#include "ui/base/clipboard/clipboard_format_type.h"
 #include "ui/base/clipboard/custom_data_helper.h"
 #include "url/gurl.h"
 
@@ -25,13 +25,13 @@
 
 namespace {
 
-bool HasData(IDataObject* data_object, const Clipboard::FormatType& format) {
+bool HasData(IDataObject* data_object, const ClipboardFormatType& format) {
   FORMATETC format_etc = format.ToFormatEtc();
   return SUCCEEDED(data_object->QueryGetData(&format_etc));
 }
 
 bool GetData(IDataObject* data_object,
-             const Clipboard::FormatType& format,
+             const ClipboardFormatType& format,
              STGMEDIUM* medium) {
   FORMATETC format_etc = format.ToFormatEtc();
   return SUCCEEDED(data_object->GetData(&format_etc, medium));
@@ -44,7 +44,7 @@
 
   bool success = false;
   STGMEDIUM medium;
-  if (!GetData(data_object, Clipboard::GetCFHDropFormatType(), &medium))
+  if (!GetData(data_object, ClipboardFormatType::GetCFHDropType(), &medium))
     return false;
 
   {
@@ -93,34 +93,34 @@
 
 bool ClipboardUtil::HasUrl(IDataObject* data_object, bool convert_filenames) {
   DCHECK(data_object);
-  return HasData(data_object, Clipboard::GetMozUrlFormatType()) ||
-         HasData(data_object, Clipboard::GetUrlWFormatType()) ||
-         HasData(data_object, Clipboard::GetUrlFormatType()) ||
+  return HasData(data_object, ClipboardFormatType::GetMozUrlType()) ||
+         HasData(data_object, ClipboardFormatType::GetUrlWType()) ||
+         HasData(data_object, ClipboardFormatType::GetUrlType()) ||
          (convert_filenames && HasFilenames(data_object));
 }
 
 bool ClipboardUtil::HasFilenames(IDataObject* data_object) {
   DCHECK(data_object);
-  return HasData(data_object, Clipboard::GetCFHDropFormatType()) ||
-         HasData(data_object, Clipboard::GetFilenameWFormatType()) ||
-         HasData(data_object, Clipboard::GetFilenameFormatType());
+  return HasData(data_object, ClipboardFormatType::GetCFHDropType()) ||
+         HasData(data_object, ClipboardFormatType::GetFilenameWType()) ||
+         HasData(data_object, ClipboardFormatType::GetFilenameType());
 }
 
 bool ClipboardUtil::HasFileContents(IDataObject* data_object) {
   DCHECK(data_object);
-  return HasData(data_object, Clipboard::GetFileContentZeroFormatType());
+  return HasData(data_object, ClipboardFormatType::GetFileContentZeroType());
 }
 
 bool ClipboardUtil::HasHtml(IDataObject* data_object) {
   DCHECK(data_object);
-  return HasData(data_object, Clipboard::GetHtmlFormatType()) ||
-         HasData(data_object, Clipboard::GetTextHtmlFormatType());
+  return HasData(data_object, ClipboardFormatType::GetHtmlType()) ||
+         HasData(data_object, ClipboardFormatType::GetTextHtmlType());
 }
 
 bool ClipboardUtil::HasPlainText(IDataObject* data_object) {
   DCHECK(data_object);
-  return HasData(data_object, Clipboard::GetPlainTextWFormatType()) ||
-         HasData(data_object, Clipboard::GetPlainTextFormatType());
+  return HasData(data_object, ClipboardFormatType::GetPlainTextWType()) ||
+         HasData(data_object, ClipboardFormatType::GetPlainTextType());
 }
 
 bool ClipboardUtil::GetUrl(IDataObject* data_object,
@@ -136,8 +136,8 @@
   if (GetUrlFromHDrop(data_object, url, title))
     return true;
 
-  if (GetData(data_object, Clipboard::GetMozUrlFormatType(), &store) ||
-      GetData(data_object, Clipboard::GetUrlWFormatType(), &store)) {
+  if (GetData(data_object, ClipboardFormatType::GetMozUrlType(), &store) ||
+      GetData(data_object, ClipboardFormatType::GetUrlWType(), &store)) {
     {
       // Mozilla URL format or unicode URL
       base::win::ScopedHGlobal<wchar_t*> data(store.hGlobal);
@@ -147,7 +147,7 @@
     return url->is_valid();
   }
 
-  if (GetData(data_object, Clipboard::GetUrlFormatType(), &store)) {
+  if (GetData(data_object, ClipboardFormatType::GetUrlType(), &store)) {
     {
       // URL using ascii
       base::win::ScopedHGlobal<char*> data(store.hGlobal);
@@ -176,7 +176,7 @@
     return false;
 
   STGMEDIUM medium;
-  if (GetData(data_object, Clipboard::GetCFHDropFormatType(), &medium)) {
+  if (GetData(data_object, ClipboardFormatType::GetCFHDropType(), &medium)) {
     {
       base::win::ScopedHGlobal<HDROP> hdrop(medium.hGlobal);
       if (!hdrop.get())
@@ -195,7 +195,7 @@
     return !filenames->empty();
   }
 
-  if (GetData(data_object, Clipboard::GetFilenameWFormatType(), &medium)) {
+  if (GetData(data_object, ClipboardFormatType::GetFilenameWType(), &medium)) {
     {
       // filename using unicode
       base::win::ScopedHGlobal<wchar_t*> data(medium.hGlobal);
@@ -206,7 +206,7 @@
     return true;
   }
 
-  if (GetData(data_object, Clipboard::GetFilenameFormatType(), &medium)) {
+  if (GetData(data_object, ClipboardFormatType::GetFilenameType(), &medium)) {
     {
       // filename using ascii
       base::win::ScopedHGlobal<char*> data(medium.hGlobal);
@@ -227,7 +227,7 @@
     return false;
 
   STGMEDIUM store;
-  if (GetData(data_object, Clipboard::GetPlainTextWFormatType(), &store)) {
+  if (GetData(data_object, ClipboardFormatType::GetPlainTextWType(), &store)) {
     {
       // Unicode text
       base::win::ScopedHGlobal<wchar_t*> data(store.hGlobal);
@@ -237,7 +237,7 @@
     return true;
   }
 
-  if (GetData(data_object, Clipboard::GetPlainTextFormatType(), &store)) {
+  if (GetData(data_object, ClipboardFormatType::GetPlainTextType(), &store)) {
     {
       // ascii text
       base::win::ScopedHGlobal<char*> data(store.hGlobal);
@@ -263,8 +263,8 @@
   DCHECK(data_object && html && base_url);
 
   STGMEDIUM store;
-  if (HasData(data_object, Clipboard::GetHtmlFormatType()) &&
-      GetData(data_object, Clipboard::GetHtmlFormatType(), &store)) {
+  if (HasData(data_object, ClipboardFormatType::GetHtmlType()) &&
+      GetData(data_object, ClipboardFormatType::GetHtmlType(), &store)) {
     {
       // MS CF html
       base::win::ScopedHGlobal<char*> data(store.hGlobal);
@@ -277,10 +277,10 @@
     return true;
   }
 
-  if (!HasData(data_object, Clipboard::GetTextHtmlFormatType()))
+  if (!HasData(data_object, ClipboardFormatType::GetTextHtmlType()))
     return false;
 
-  if (!GetData(data_object, Clipboard::GetTextHtmlFormatType(), &store))
+  if (!GetData(data_object, ClipboardFormatType::GetTextHtmlType(), &store))
     return false;
 
   {
@@ -295,15 +295,15 @@
 bool ClipboardUtil::GetFileContents(IDataObject* data_object,
     base::string16* filename, std::string* file_contents) {
   DCHECK(data_object && filename && file_contents);
-  if (!HasData(data_object, Clipboard::GetFileContentZeroFormatType()) &&
-      !HasData(data_object, Clipboard::GetFileDescriptorFormatType()))
+  if (!HasData(data_object, ClipboardFormatType::GetFileContentZeroType()) &&
+      !HasData(data_object, ClipboardFormatType::GetFileDescriptorType()))
     return false;
 
   STGMEDIUM content;
   // The call to GetData can be very slow depending on what is in
   // |data_object|.
-  if (GetData(
-          data_object, Clipboard::GetFileContentZeroFormatType(), &content)) {
+  if (GetData(data_object, ClipboardFormatType::GetFileContentZeroType(),
+              &content)) {
     if (TYMED_HGLOBAL == content.tymed) {
       base::win::ScopedHGlobal<char*> data(content.hGlobal);
       file_contents->assign(data.get(), data.Size());
@@ -312,8 +312,7 @@
   }
 
   STGMEDIUM description;
-  if (GetData(data_object,
-              Clipboard::GetFileDescriptorFormatType(),
+  if (GetData(data_object, ClipboardFormatType::GetFileDescriptorType(),
               &description)) {
     {
       base::win::ScopedHGlobal<FILEGROUPDESCRIPTOR*> fgd(description.hGlobal);
@@ -331,11 +330,12 @@
     std::unordered_map<base::string16, base::string16>* custom_data) {
   DCHECK(data_object && custom_data);
 
-  if (!HasData(data_object, Clipboard::GetWebCustomDataFormatType()))
+  if (!HasData(data_object, ClipboardFormatType::GetWebCustomDataType()))
     return false;
 
   STGMEDIUM store;
-  if (GetData(data_object, Clipboard::GetWebCustomDataFormatType(), &store)) {
+  if (GetData(data_object, ClipboardFormatType::GetWebCustomDataType(),
+              &store)) {
     {
       base::win::ScopedHGlobal<char*> data(store.hGlobal);
       ReadCustomDataIntoMap(data.get(), data.Size(), custom_data);
--- a/ui/base/clipboard/clipboard_util_win.h	2019-02-14 01:14:41.000000000 +0300
+++ b/ui/base/clipboard/clipboard_util_win.h	2019-02-20 20:48:23.472000000 +0300
@@ -13,14 +13,14 @@
 #include <unordered_map>
 #include <vector>
 
+#include "base/component_export.h"
 #include "base/strings/string16.h"
-#include "ui/base/ui_base_export.h"
 
 class GURL;
 
 namespace ui {
 
-class UI_BASE_EXPORT ClipboardUtil {
+class COMPONENT_EXPORT(BASE_CLIPBOARD) ClipboardUtil {
  public:
   /////////////////////////////////////////////////////////////////////////////
   // These methods check to see if |data_object| has the requested type.
--- a/ui/base/clipboard/clipboard_win.cc	2019-02-14 01:14:41.000000000 +0300
+++ b/ui/base/clipboard/clipboard_win.cc	2019-02-20 20:48:23.472000000 +0300
@@ -28,6 +28,7 @@
 #include "skia/ext/skia_utils_base.h"
 #include "skia/ext/skia_utils_win.h"
 #include "third_party/skia/include/core/SkBitmap.h"
+#include "ui/base/clipboard/clipboard_constants.h"
 #include "ui/base/clipboard/clipboard_util_win.h"
 #include "ui/base/clipboard/custom_data_helper.h"
 #include "ui/gfx/canvas.h"
@@ -220,201 +221,6 @@
 
 }  // namespace
 
-// Clipboard::FormatType implementation.
-Clipboard::FormatType::FormatType() : data_() {}
-
-Clipboard::FormatType::FormatType(UINT native_format) : data_() {
-  // There's no good way to actually initialize this in the constructor in
-  // C++03.
-  data_.cfFormat = static_cast<CLIPFORMAT>(native_format);
-  data_.dwAspect = DVASPECT_CONTENT;
-  data_.lindex = -1;
-  data_.tymed = TYMED_HGLOBAL;
-}
-
-Clipboard::FormatType::FormatType(UINT native_format, LONG index) : data_() {
-  // There's no good way to actually initialize this in the constructor in
-  // C++03.
-  data_.cfFormat = static_cast<CLIPFORMAT>(native_format);
-  data_.dwAspect = DVASPECT_CONTENT;
-  data_.lindex = index;
-  data_.tymed = TYMED_HGLOBAL;
-}
-
-Clipboard::FormatType::~FormatType() {
-}
-
-std::string Clipboard::FormatType::Serialize() const {
-  return base::IntToString(data_.cfFormat);
-}
-
-// static
-Clipboard::FormatType Clipboard::FormatType::Deserialize(
-    const std::string& serialization) {
-  int clipboard_format = -1;
-  if (!base::StringToInt(serialization, &clipboard_format)) {
-    NOTREACHED();
-    return FormatType();
-  }
-  return FormatType(clipboard_format);
-}
-
-bool Clipboard::FormatType::operator<(const FormatType& other) const {
-  return data_.cfFormat < other.data_.cfFormat;
-}
-
-bool Clipboard::FormatType::Equals(const FormatType& other) const {
-  return data_.cfFormat == other.data_.cfFormat;
-}
-
-// Various predefined FormatTypes.
-// static
-Clipboard::FormatType Clipboard::GetFormatType(
-    const std::string& format_string) {
-  return FormatType(
-      ::RegisterClipboardFormat(base::ASCIIToUTF16(format_string).c_str()));
-}
-
-// The following formats can be referenced by ClipboardUtilWin::GetPlainText.
-// For reasons (COM), they must be initialized in a thread-safe manner.
-// TODO(dcheng): We probably need to make static initialization of "known"
-// FormatTypes thread-safe on all platforms.
-#define CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(name, ...) \
-  struct FormatTypeArgumentForwarder : public FormatType { \
-    FormatTypeArgumentForwarder() : FormatType(__VA_ARGS__) { } \
-  }; \
-  static base::LazyInstance<FormatTypeArgumentForwarder>::Leaky name = \
-      LAZY_INSTANCE_INITIALIZER
-// static
-const Clipboard::FormatType& Clipboard::GetUrlFormatType() {
-  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(
-    type, ::RegisterClipboardFormat(CFSTR_INETURLA));
-  return type.Get();
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetUrlWFormatType() {
-  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(
-      type, ::RegisterClipboardFormat(CFSTR_INETURLW));
-  return type.Get();
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetMozUrlFormatType() {
-  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(
-      type, ::RegisterClipboardFormat(L"text/x-moz-url"));
-  return type.Get();
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetPlainTextFormatType() {
-  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(type, CF_TEXT);
-  return type.Get();
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetPlainTextWFormatType() {
-  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(type, CF_UNICODETEXT);
-  return type.Get();
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetFilenameFormatType() {
-  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(
-      type, ::RegisterClipboardFormat(CFSTR_FILENAMEA));
-  return type.Get();
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetFilenameWFormatType() {
-  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(
-      type, ::RegisterClipboardFormat(CFSTR_FILENAMEW));
-  return type.Get();
-}
-
-// MS HTML Format
-// static
-const Clipboard::FormatType& Clipboard::GetHtmlFormatType() {
-  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(
-      type, ::RegisterClipboardFormat(L"HTML Format"));
-  return type.Get();
-}
-
-// MS RTF Format
-// static
-const Clipboard::FormatType& Clipboard::GetRtfFormatType() {
-  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(
-      type, ::RegisterClipboardFormat(L"Rich Text Format"));
-  return type.Get();
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetBitmapFormatType() {
-  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(type, CF_BITMAP);
-  return type.Get();
-}
-
-// Firefox text/html
-// static
-const Clipboard::FormatType& Clipboard::GetTextHtmlFormatType() {
-  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(
-      type, ::RegisterClipboardFormat(L"text/html"));
-  return type.Get();
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetCFHDropFormatType() {
-  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(type, CF_HDROP);
-  return type.Get();
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetFileDescriptorFormatType() {
-  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(
-      type, ::RegisterClipboardFormat(CFSTR_FILEDESCRIPTOR));
-  return type.Get();
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetFileContentZeroFormatType() {
-  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(
-      type, ::RegisterClipboardFormat(CFSTR_FILECONTENTS), 0);
-  return type.Get();
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetIDListFormatType() {
-  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(
-      type, ::RegisterClipboardFormat(CFSTR_SHELLIDLIST));
-  return type.Get();
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetWebKitSmartPasteFormatType() {
-  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(
-      type,
-      ::RegisterClipboardFormat(L"WebKit Smart Paste Format"));
-  return type.Get();
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetWebCustomDataFormatType() {
-  // TODO(dcheng): This name is temporary. See http://crbug.com/106449.
-  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(
-      type,
-      ::RegisterClipboardFormat(L"Chromium Web Custom MIME Data Format"));
-  return type.Get();
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetPepperCustomDataFormatType() {
-  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(
-      type,
-      ::RegisterClipboardFormat(L"Chromium Pepper MIME Data Format"));
-  return type.Get();
-}
-#undef CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE
-
 // Clipboard factory method.
 // static
 Clipboard* Clipboard::Create() {
@@ -437,7 +243,7 @@
   return ::GetClipboardSequenceNumber();
 }
 
-bool ClipboardWin::IsFormatAvailable(const Clipboard::FormatType& format,
+bool ClipboardWin::IsFormatAvailable(const ClipboardFormatType& format,
                                      ClipboardType type) const {
   DCHECK_EQ(type, CLIPBOARD_TYPE_COPY_PASTE);
   return ::IsClipboardFormatAvailable(format.ToFormatEtc().cfFormat) != FALSE;
@@ -462,11 +268,13 @@
 
   types->clear();
   if (::IsClipboardFormatAvailable(
-          GetPlainTextFormatType().ToFormatEtc().cfFormat))
+          ClipboardFormatType::GetPlainTextType().ToFormatEtc().cfFormat))
     types->push_back(base::UTF8ToUTF16(kMimeTypeText));
-  if (::IsClipboardFormatAvailable(GetHtmlFormatType().ToFormatEtc().cfFormat))
+  if (::IsClipboardFormatAvailable(
+          ClipboardFormatType::GetHtmlType().ToFormatEtc().cfFormat))
     types->push_back(base::UTF8ToUTF16(kMimeTypeHTML));
-  if (::IsClipboardFormatAvailable(GetRtfFormatType().ToFormatEtc().cfFormat))
+  if (::IsClipboardFormatAvailable(
+          ClipboardFormatType::GetRtfType().ToFormatEtc().cfFormat))
     types->push_back(base::UTF8ToUTF16(kMimeTypeRTF));
   if (::IsClipboardFormatAvailable(CF_DIB))
     types->push_back(base::UTF8ToUTF16(kMimeTypePNG));
@@ -477,8 +285,8 @@
   if (!clipboard.Acquire(GetClipboardWindow()))
     return;
 
-  HANDLE hdata =
-      ::GetClipboardData(GetWebCustomDataFormatType().ToFormatEtc().cfFormat);
+  HANDLE hdata = ::GetClipboardData(
+      ClipboardFormatType::GetWebCustomDataType().ToFormatEtc().cfFormat);
   if (!hdata)
     return;
 
@@ -555,7 +363,8 @@
   if (!clipboard.Acquire(GetClipboardWindow()))
     return;
 
-  HANDLE data = ::GetClipboardData(GetHtmlFormatType().ToFormatEtc().cfFormat);
+  HANDLE data = ::GetClipboardData(
+      ClipboardFormatType::GetHtmlType().ToFormatEtc().cfFormat);
   if (!data)
     return;
 
@@ -594,7 +403,7 @@
 void ClipboardWin::ReadRTF(ClipboardType type, std::string* result) const {
   DCHECK_EQ(type, CLIPBOARD_TYPE_COPY_PASTE);
 
-  ReadData(GetRtfFormatType(), result);
+  ReadData(ClipboardFormatType::GetRtfType(), result);
   TrimAfterNull(result);
 }
 
@@ -690,8 +499,8 @@
   if (!clipboard.Acquire(GetClipboardWindow()))
     return;
 
-  HANDLE hdata =
-      ::GetClipboardData(GetWebCustomDataFormatType().ToFormatEtc().cfFormat);
+  HANDLE hdata = ::GetClipboardData(
+      ClipboardFormatType::GetWebCustomDataType().ToFormatEtc().cfFormat);
   if (!hdata)
     return;
 
@@ -711,7 +520,8 @@
   if (!clipboard.Acquire(GetClipboardWindow()))
     return;
 
-  HANDLE data = ::GetClipboardData(GetUrlWFormatType().ToFormatEtc().cfFormat);
+  HANDLE data = ::GetClipboardData(
+      ClipboardFormatType::GetUrlWType().ToFormatEtc().cfFormat);
   if (!data)
     return;
 
@@ -723,7 +533,7 @@
   ParseBookmarkClipboardFormat(bookmark, title, url);
 }
 
-void ClipboardWin::ReadData(const FormatType& format,
+void ClipboardWin::ReadData(const ClipboardFormatType& format,
                             std::string* result) const {
   if (!result) {
     NOTREACHED();
@@ -779,11 +589,12 @@
   std::string html_fragment = ClipboardUtil::HtmlToCFHtml(markup, url);
   HGLOBAL glob = CreateGlobalData(html_fragment);
 
-  WriteToClipboard(Clipboard::GetHtmlFormatType().ToFormatEtc().cfFormat, glob);
+  WriteToClipboard(ClipboardFormatType::GetHtmlType().ToFormatEtc().cfFormat,
+                   glob);
 }
 
 void ClipboardWin::WriteRTF(const char* rtf_data, size_t data_len) {
-  WriteData(GetRtfFormatType(), rtf_data, data_len);
+  WriteData(ClipboardFormatType::GetRtfType(), rtf_data, data_len);
 }
 
 void ClipboardWin::WriteBookmark(const char* title_data,
@@ -797,12 +608,14 @@
   base::string16 wide_bookmark = base::UTF8ToUTF16(bookmark);
   HGLOBAL glob = CreateGlobalData(wide_bookmark);
 
-  WriteToClipboard(GetUrlWFormatType().ToFormatEtc().cfFormat, glob);
+  WriteToClipboard(ClipboardFormatType::GetUrlWType().ToFormatEtc().cfFormat,
+                   glob);
 }
 
 void ClipboardWin::WriteWebSmartPaste() {
   DCHECK(clipboard_owner_->hwnd() != NULL);
-  ::SetClipboardData(GetWebKitSmartPasteFormatType().ToFormatEtc().cfFormat,
+  ::SetClipboardData(
+      ClipboardFormatType::GetWebKitSmartPasteType().ToFormatEtc().cfFormat,
                      NULL);
 }
 
@@ -849,7 +662,7 @@
   ::ReleaseDC(NULL, dc);
 }
 
-void ClipboardWin::WriteData(const FormatType& format,
+void ClipboardWin::WriteData(const ClipboardFormatType& format,
                              const char* data_data,
                              size_t data_len) {
   HGLOBAL hdata = ::GlobalAlloc(GMEM_MOVEABLE, data_len);
--- a/ui/base/clipboard/clipboard_win.h	2019-02-14 01:14:41.000000000 +0300
+++ b/ui/base/clipboard/clipboard_win.h	2019-02-20 20:48:23.472000000 +0300
@@ -35,7 +35,7 @@
   // Clipboard overrides:
   void OnPreShutdown() override;
   uint64_t GetSequenceNumber(ClipboardType type) const override;
-  bool IsFormatAvailable(const FormatType& format,
+  bool IsFormatAvailable(const ClipboardFormatType& format,
                          ClipboardType type) const override;
   void Clear(ClipboardType type) override;
   void ReadAvailableTypes(ClipboardType type,
@@ -54,7 +54,8 @@
                       const base::string16& type,
                       base::string16* result) const override;
   void ReadBookmark(base::string16* title, std::string* url) const override;
-  void ReadData(const FormatType& format, std::string* result) const override;
+  void ReadData(const ClipboardFormatType& format,
+                std::string* result) const override;
   void WriteObjects(ClipboardType type, const ObjectMap& objects) override;
   void WriteText(const char* text_data, size_t text_len) override;
   void WriteHTML(const char* markup_data,
@@ -68,7 +69,7 @@
                      size_t url_len) override;
   void WriteWebSmartPaste() override;
   void WriteBitmap(const SkBitmap& bitmap) override;
-  void WriteData(const FormatType& format,
+  void WriteData(const ClipboardFormatType& format,
                  const char* data_data,
                  size_t data_len) override;
 
--- a/ui/base/clipboard/custom_data_helper.h	2019-02-14 01:14:41.000000000 +0300
+++ b/ui/base/clipboard/custom_data_helper.h	2019-02-20 20:48:23.472000000 +0300
@@ -15,46 +15,39 @@
 #include <unordered_map>
 #include <vector>
 
+#include "base/component_export.h"
 #include "base/containers/flat_map.h"
 #include "base/strings/string16.h"
 #include "build/build_config.h"
-#include "ui/base/ui_base_export.h"
 
 namespace base {
 class Pickle;
 }
 
-#if defined(OS_MACOSX)
-#ifdef __OBJC__
-@class NSString;
-#else
-class NSString;
-#endif
-#endif  // defined(OS_MACOSX)
-
 namespace ui {
 
-#if defined(OS_MACOSX) && !defined(USE_AURA)
-UI_BASE_EXPORT extern NSString* const kWebCustomDataPboardType;
-#endif
-
-UI_BASE_EXPORT void ReadCustomDataTypes(const void* data,
+COMPONENT_EXPORT(BASE_CLIPBOARD)
+void ReadCustomDataTypes(const void* data,
                                         size_t data_length,
                                         std::vector<base::string16>* types);
-UI_BASE_EXPORT void ReadCustomDataForType(const void* data,
+COMPONENT_EXPORT(BASE_CLIPBOARD)
+void ReadCustomDataForType(const void* data,
                                           size_t data_length,
                                           const base::string16& type,
                                           base::string16* result);
-UI_BASE_EXPORT void ReadCustomDataIntoMap(
+COMPONENT_EXPORT(BASE_CLIPBOARD)
+void ReadCustomDataIntoMap(
     const void* data,
     size_t data_length,
     std::unordered_map<base::string16, base::string16>* result);
 
-UI_BASE_EXPORT void WriteCustomDataToPickle(
+COMPONENT_EXPORT(BASE_CLIPBOARD)
+void WriteCustomDataToPickle(
     const std::unordered_map<base::string16, base::string16>& data,
     base::Pickle* pickle);
 
-UI_BASE_EXPORT void WriteCustomDataToPickle(
+COMPONENT_EXPORT(BASE_CLIPBOARD)
+void WriteCustomDataToPickle(
     const base::flat_map<base::string16, base::string16>& data,
     base::Pickle* pickle);
 
--- a/ui/base/clipboard/DEPS	2019-02-14 01:14:41.000000000 +0300
+++ b/ui/base/clipboard/DEPS	2019-02-20 20:48:23.468000000 +0300
@@ -1,4 +1,7 @@
 include_rules = [
+  "-ui/ozone/*",
   "+jni",
   "+third_party/mozilla",
+  "+ui/ozone/public/ozone_platform.h",
+  "+ui/ozone/public/platform_clipboard.h",
 ]
--- a/ui/base/clipboard/scoped_clipboard_writer.cc	2019-02-14 01:14:41.000000000 +0300
+++ b/ui/base/clipboard/scoped_clipboard_writer.cc	2019-02-20 20:48:23.472000000 +0300
@@ -11,6 +11,7 @@
 #include "base/pickle.h"
 #include "base/strings/utf_string_conversions.h"
 #include "net/base/escape.h"
+#include "ui/base/clipboard/clipboard_format_type.h"
 #include "ui/gfx/geometry/size.h"
 
 namespace ui {
@@ -105,7 +106,7 @@
 
 void ScopedClipboardWriter::WritePickledData(
     const base::Pickle& pickle,
-    const Clipboard::FormatType& format) {
+    const ClipboardFormatType& format) {
   std::string format_string = format.Serialize();
   Clipboard::ObjectMapParam format_parameter(format_string.begin(),
                                              format_string.end());
--- a/ui/base/clipboard/scoped_clipboard_writer.h	2019-02-14 01:14:41.000000000 +0300
+++ b/ui/base/clipboard/scoped_clipboard_writer.h	2019-02-20 20:48:23.472000000 +0300
@@ -13,11 +13,11 @@
 
 #include <string>
 
+#include "base/component_export.h"
 #include "base/macros.h"
 #include "base/strings/string16.h"
 #include "third_party/skia/include/core/SkBitmap.h"
 #include "ui/base/clipboard/clipboard.h"
-#include "ui/base/ui_base_export.h"
 
 namespace base {
 class Pickle;
@@ -27,7 +27,7 @@
 
 // This class is a wrapper for |Clipboard| that handles packing data
 // into a Clipboard::ObjectMap.
-class UI_BASE_EXPORT ScopedClipboardWriter {
+class COMPONENT_EXPORT(BASE_CLIPBOARD) ScopedClipboardWriter {
  public:
   // Create an instance that is a simple wrapper around the clipboard of the
   // given type.
@@ -59,7 +59,7 @@
 
   // Adds arbitrary pickled data to clipboard.
   void WritePickledData(const base::Pickle& pickle,
-                        const Clipboard::FormatType& format);
+                        const ClipboardFormatType& format);
 
   // Adds custom data to clipboard.
   void WriteData(const std::string& type, const std::string& data);
--- a/ui/base/dragdrop/os_exchange_data.cc	2019-02-14 01:14:41.000000000 +0300
+++ b/ui/base/dragdrop/os_exchange_data.cc	2019-02-20 20:48:23.484000000 +0300
@@ -6,6 +6,7 @@
 
 #include "base/pickle.h"
 #include "build/build_config.h"
+#include "ui/base/clipboard/clipboard_format_type.h"
 #include "ui/base/dragdrop/os_exchange_data_provider_factory.h"
 #include "url/gurl.h"
 
@@ -56,7 +57,7 @@
   provider_->SetFilenames(filenames);
 }
 
-void OSExchangeData::SetPickledData(const Clipboard::FormatType& format,
+void OSExchangeData::SetPickledData(const ClipboardFormatType& format,
                                     const base::Pickle& data) {
   provider_->SetPickledData(format, data);
 }
@@ -79,7 +80,7 @@
   return provider_->GetFilenames(filenames);
 }
 
-bool OSExchangeData::GetPickledData(const Clipboard::FormatType& format,
+bool OSExchangeData::GetPickledData(const ClipboardFormatType& format,
                                     base::Pickle* data) const {
   return provider_->GetPickledData(format, data);
 }
@@ -96,14 +97,13 @@
   return provider_->HasFile();
 }
 
-bool OSExchangeData::HasCustomFormat(
-    const Clipboard::FormatType& format) const {
+bool OSExchangeData::HasCustomFormat(const ClipboardFormatType& format) const {
   return provider_->HasCustomFormat(format);
 }
 
 bool OSExchangeData::HasAnyFormat(
     int formats,
-    const std::set<Clipboard::FormatType>& format_types) const {
+    const std::set<ClipboardFormatType>& format_types) const {
   if ((formats & STRING) != 0 && HasString())
     return true;
   if ((formats & URL) != 0 && HasURL(CONVERT_FILENAMES))
--- a/ui/base/dragdrop/os_exchange_data.h	2019-02-14 01:14:41.000000000 +0300
+++ b/ui/base/dragdrop/os_exchange_data.h	2019-02-20 20:48:23.484000000 +0300
@@ -17,7 +17,6 @@
 
 #include "base/files/file_path.h"
 #include "base/macros.h"
-#include "ui/base/clipboard/clipboard.h"
 #include "ui/base/dragdrop/download_file_interface.h"
 #include "ui/base/ui_base_export.h"
 
@@ -34,6 +33,7 @@
 
 namespace ui {
 
+struct ClipboardFormatType;
 struct FileInfo;
 
 ///////////////////////////////////////////////////////////////////////////////
@@ -96,7 +96,7 @@
     virtual void SetURL(const GURL& url, const base::string16& title) = 0;
     virtual void SetFilename(const base::FilePath& path) = 0;
     virtual void SetFilenames(const std::vector<FileInfo>& file_names) = 0;
-    virtual void SetPickledData(const Clipboard::FormatType& format,
+    virtual void SetPickledData(const ClipboardFormatType& format,
                                 const base::Pickle& data) = 0;
 
     virtual bool GetString(base::string16* data) const = 0;
@@ -105,13 +105,13 @@
                                 base::string16* title) const = 0;
     virtual bool GetFilename(base::FilePath* path) const = 0;
     virtual bool GetFilenames(std::vector<FileInfo>* file_names) const = 0;
-    virtual bool GetPickledData(const Clipboard::FormatType& format,
+    virtual bool GetPickledData(const ClipboardFormatType& format,
                                 base::Pickle* data) const = 0;
 
     virtual bool HasString() const = 0;
     virtual bool HasURL(FilenameToURLPolicy policy) const = 0;
     virtual bool HasFile() const = 0;
-    virtual bool HasCustomFormat(const Clipboard::FormatType& format) const = 0;
+    virtual bool HasCustomFormat(const ClipboardFormatType& format) const = 0;
 
 #if defined(USE_X11) || defined(OS_WIN)
     virtual void SetFileContents(const base::FilePath& filename,
@@ -174,7 +174,7 @@
   void SetFilenames(
       const std::vector<FileInfo>& file_names);
   // Adds pickled data of the specified format.
-  void SetPickledData(const Clipboard::FormatType& format,
+  void SetPickledData(const ClipboardFormatType& format,
                       const base::Pickle& data);
 
   // These functions retrieve data of the specified type. If data exists, the
@@ -190,7 +190,7 @@
   // Return the path of a file, if available.
   bool GetFilename(base::FilePath* path) const;
   bool GetFilenames(std::vector<FileInfo>* file_names) const;
-  bool GetPickledData(const Clipboard::FormatType& format,
+  bool GetPickledData(const ClipboardFormatType& format,
                       base::Pickle* data) const;
 
   // Test whether or not data of certain types is present, without actually
@@ -198,12 +198,12 @@
   bool HasString() const;
   bool HasURL(FilenameToURLPolicy policy) const;
   bool HasFile() const;
-  bool HasCustomFormat(const Clipboard::FormatType& format) const;
+  bool HasCustomFormat(const ClipboardFormatType& format) const;
 
   // Returns true if this OSExchangeData has data in any of the formats in
   // |formats| or any custom format in |custom_formats|.
   bool HasAnyFormat(int formats,
-                    const std::set<Clipboard::FormatType>& types) const;
+                    const std::set<ClipboardFormatType>& types) const;
 
 #if defined(OS_WIN)
   // Adds the bytes of a file (CFSTR_FILECONTENTS and CFSTR_FILEDESCRIPTOR on
--- a/ui/base/dragdrop/os_exchange_data_provider_aura.cc	2019-02-14 01:14:41.000000000 +0300
+++ b/ui/base/dragdrop/os_exchange_data_provider_aura.cc	2019-02-20 20:48:23.484000000 +0300
@@ -8,8 +8,7 @@
 #include "base/memory/ptr_util.h"
 #include "base/strings/utf_string_conversions.h"
 #include "net/base/filename_util.h"
-#include "ui/base/clipboard/clipboard.h"
-#include "ui/base/clipboard/scoped_clipboard_writer.h"
+#include "ui/base/clipboard/clipboard_format_type.h"
 #include "ui/base/dragdrop/file_info.h"
 
 namespace ui {
@@ -75,7 +74,7 @@
 }
 
 void OSExchangeDataProviderAura::SetPickledData(
-    const Clipboard::FormatType& format,
+    const ClipboardFormatType& format,
     const base::Pickle& data) {
   pickle_data_[format] = data;
   formats_ |= OSExchangeData::PICKLED_DATA;
@@ -123,7 +122,7 @@
 }
 
 bool OSExchangeDataProviderAura::GetPickledData(
-    const Clipboard::FormatType& format,
+    const ClipboardFormatType& format,
     base::Pickle* data) const {
   PickleData::const_iterator i = pickle_data_.find(format);
   if (i == pickle_data_.end())
@@ -152,7 +151,7 @@
 }
 
 bool OSExchangeDataProviderAura::HasCustomFormat(
-    const Clipboard::FormatType& format) const {
+    const ClipboardFormatType& format) const {
   return pickle_data_.find(format) != pickle_data_.end();
 }
 
--- a/ui/base/dragdrop/os_exchange_data_provider_aura.h	2019-02-14 01:14:41.000000000 +0300
+++ b/ui/base/dragdrop/os_exchange_data_provider_aura.h	2019-02-20 20:48:23.484000000 +0300
@@ -17,7 +17,7 @@
 
 namespace ui {
 
-class Clipboard;
+struct ClipboardFormatType;
 
 // OSExchangeData::Provider implementation for aura on linux.
 class UI_BASE_EXPORT OSExchangeDataProviderAura
@@ -34,7 +34,7 @@
   void SetURL(const GURL& url, const base::string16& title) override;
   void SetFilename(const base::FilePath& path) override;
   void SetFilenames(const std::vector<FileInfo>& filenames) override;
-  void SetPickledData(const Clipboard::FormatType& format,
+  void SetPickledData(const ClipboardFormatType& format,
                       const base::Pickle& data) override;
   bool GetString(base::string16* data) const override;
   bool GetURLAndTitle(OSExchangeData::FilenameToURLPolicy policy,
@@ -42,13 +42,12 @@
                       base::string16* title) const override;
   bool GetFilename(base::FilePath* path) const override;
   bool GetFilenames(std::vector<FileInfo>* filenames) const override;
-  bool GetPickledData(const Clipboard::FormatType& format,
+  bool GetPickledData(const ClipboardFormatType& format,
                       base::Pickle* data) const override;
   bool HasString() const override;
   bool HasURL(OSExchangeData::FilenameToURLPolicy policy) const override;
   bool HasFile() const override;
-  bool HasCustomFormat(const Clipboard::FormatType& format) const
-      override;
+  bool HasCustomFormat(const ClipboardFormatType& format) const override;
 
   void SetHtml(const base::string16& html, const GURL& base_url) override;
   bool GetHtml(base::string16* html, GURL* base_url) const override;
@@ -59,7 +58,7 @@
   gfx::Vector2d GetDragImageOffset() const override;
 
  private:
-  typedef std::map<Clipboard::FormatType, base::Pickle> PickleData;
+  typedef std::map<ClipboardFormatType, base::Pickle> PickleData;
 
   // Returns true if |formats_| contains a file format and the file name can be
   // parsed as a URL.
--- a/ui/base/dragdrop/os_exchange_data_provider_aurax11.cc	2019-02-14 01:14:41.000000000 +0300
+++ b/ui/base/dragdrop/os_exchange_data_provider_aurax11.cc	2019-02-20 20:48:23.484000000 +0300
@@ -12,8 +12,8 @@
 #include "base/strings/string_util.h"
 #include "base/strings/utf_string_conversions.h"
 #include "net/base/filename_util.h"
-#include "ui/base/clipboard/clipboard.h"
-#include "ui/base/clipboard/scoped_clipboard_writer.h"
+#include "ui/base/clipboard/clipboard_constants.h"
+#include "ui/base/clipboard/clipboard_format_type.h"
 #include "ui/base/dragdrop/file_info.h"
 #include "ui/base/x/selection_utils.h"
 #include "ui/events/platform/platform_event_source.h"
@@ -117,7 +117,7 @@
   scoped_refptr<base::RefCountedMemory> mem(
       base::RefCountedString::TakeString(&utf8));
 
-  format_map_.Insert(gfx::GetAtom(Clipboard::kMimeTypeText), mem);
+  format_map_.Insert(gfx::GetAtom(kMimeTypeText), mem);
   format_map_.Insert(gfx::GetAtom(kText), mem);
   format_map_.Insert(gfx::GetAtom(kString), mem);
   format_map_.Insert(gfx::GetAtom(kUtf8String), mem);
@@ -138,7 +138,7 @@
     scoped_refptr<base::RefCountedMemory> mem(
         base::RefCountedBytes::TakeVector(&data));
 
-    format_map_.Insert(gfx::GetAtom(Clipboard::kMimeTypeMozillaURL), mem);
+    format_map_.Insert(gfx::GetAtom(kMimeTypeMozillaURL), mem);
 
     // Set a string fallback as well.
     SetString(spec);
@@ -182,11 +182,11 @@
   std::string joined_data = base::JoinString(paths, "\n");
   scoped_refptr<base::RefCountedMemory> mem(
       base::RefCountedString::TakeString(&joined_data));
-  format_map_.Insert(gfx::GetAtom(Clipboard::kMimeTypeURIList), mem);
+  format_map_.Insert(gfx::GetAtom(kMimeTypeURIList), mem);
 }
 
 void OSExchangeDataProviderAuraX11::SetPickledData(
-    const Clipboard::FormatType& format,
+    const ClipboardFormatType& format,
     const base::Pickle& pickle) {
   const unsigned char* data =
       reinterpret_cast<const unsigned char*>(pickle.data());
@@ -235,7 +235,7 @@
     // but that doesn't match the assumptions of the rest of the system which
     // expect single types.
 
-    if (data.GetType() == gfx::GetAtom(Clipboard::kMimeTypeMozillaURL)) {
+    if (data.GetType() == gfx::GetAtom(kMimeTypeMozillaURL)) {
       // Mozilla URLs are (UTF16: URL, newline, title).
       base::string16 unparsed;
       data.AssignTo(&unparsed);
@@ -252,7 +252,7 @@
         *url = GURL(tokens[0]);
         return true;
       }
-    } else if (data.GetType() == gfx::GetAtom(Clipboard::kMimeTypeURIList)) {
+    } else if (data.GetType() == gfx::GetAtom(kMimeTypeURIList)) {
       std::vector<std::string> tokens = ui::ParseURIList(data);
       for (const std::string& token : tokens) {
         GURL test_url(token);
@@ -302,7 +302,7 @@
 }
 
 bool OSExchangeDataProviderAuraX11::GetPickledData(
-    const Clipboard::FormatType& format,
+    const ClipboardFormatType& format,
     base::Pickle* pickle) const {
   std::vector< ::Atom> requested_types;
   requested_types.push_back(gfx::GetAtom(format.ToString().c_str()));
@@ -339,11 +339,10 @@
   // Windows does and stuffs all the data into one mime type.
   ui::SelectionData data(format_map_.GetFirstOf(requested_types));
   if (data.IsValid()) {
-    if (data.GetType() == gfx::GetAtom(Clipboard::kMimeTypeMozillaURL)) {
+    if (data.GetType() == gfx::GetAtom(kMimeTypeMozillaURL)) {
       // File managers shouldn't be using this type, so this is a URL.
       return true;
-    } else if (data.GetType() ==
-               gfx::GetAtom(ui::Clipboard::kMimeTypeURIList)) {
+    } else if (data.GetType() == gfx::GetAtom(ui::kMimeTypeURIList)) {
       std::vector<std::string> tokens = ui::ParseURIList(data);
       for (const std::string& token : tokens) {
         if (!GURL(token).SchemeIsFile() ||
@@ -384,7 +383,7 @@
 }
 
 bool OSExchangeDataProviderAuraX11::HasCustomFormat(
-    const Clipboard::FormatType& format) const {
+    const ClipboardFormatType& format) const {
   std::vector< ::Atom> url_atoms;
   url_atoms.push_back(gfx::GetAtom(format.ToString().c_str()));
   std::vector< ::Atom> requested_types;
@@ -398,7 +397,7 @@
     const std::string& file_contents) {
   DCHECK(!filename.empty());
   DCHECK(format_map_.end() ==
-         format_map_.find(gfx::GetAtom(Clipboard::kMimeTypeMozillaURL)));
+         format_map_.find(gfx::GetAtom(kMimeTypeMozillaURL)));
 
   file_contents_name_ = filename;
 
@@ -439,13 +438,13 @@
   scoped_refptr<base::RefCountedMemory> mem(
       base::RefCountedBytes::TakeVector(&bytes));
 
-  format_map_.Insert(gfx::GetAtom(Clipboard::kMimeTypeHTML), mem);
+  format_map_.Insert(gfx::GetAtom(kMimeTypeHTML), mem);
 }
 
 bool OSExchangeDataProviderAuraX11::GetHtml(base::string16* html,
                                             GURL* base_url) const {
   std::vector< ::Atom> url_atoms;
-  url_atoms.push_back(gfx::GetAtom(Clipboard::kMimeTypeHTML));
+  url_atoms.push_back(gfx::GetAtom(kMimeTypeHTML));
   std::vector< ::Atom> requested_types;
   GetAtomIntersection(url_atoms, GetTargets(), &requested_types);
 
@@ -461,7 +460,7 @@
 
 bool OSExchangeDataProviderAuraX11::HasHtml() const {
   std::vector< ::Atom> url_atoms;
-  url_atoms.push_back(gfx::GetAtom(Clipboard::kMimeTypeHTML));
+  url_atoms.push_back(gfx::GetAtom(kMimeTypeHTML));
   std::vector< ::Atom> requested_types;
   GetAtomIntersection(url_atoms, GetTargets(), &requested_types);
 
--- a/ui/base/dragdrop/os_exchange_data_provider_aurax11.h	2019-02-14 01:14:41.000000000 +0300
+++ b/ui/base/dragdrop/os_exchange_data_provider_aurax11.h	2019-02-20 20:48:23.484000000 +0300
@@ -23,7 +23,6 @@
 
 namespace ui {
 
-class Clipboard;
 class OSExchangeDataProviderAuraX11Test;
 
 // OSExchangeData::Provider implementation for aura on linux.
@@ -65,7 +64,7 @@
   void SetURL(const GURL& url, const base::string16& title) override;
   void SetFilename(const base::FilePath& path) override;
   void SetFilenames(const std::vector<FileInfo>& filenames) override;
-  void SetPickledData(const Clipboard::FormatType& format,
+  void SetPickledData(const ClipboardFormatType& format,
                       const base::Pickle& pickle) override;
   bool GetString(base::string16* data) const override;
   bool GetURLAndTitle(OSExchangeData::FilenameToURLPolicy policy,
@@ -73,12 +72,12 @@
                       base::string16* title) const override;
   bool GetFilename(base::FilePath* path) const override;
   bool GetFilenames(std::vector<FileInfo>* filenames) const override;
-  bool GetPickledData(const Clipboard::FormatType& format,
+  bool GetPickledData(const ClipboardFormatType& format,
                       base::Pickle* pickle) const override;
   bool HasString() const override;
   bool HasURL(OSExchangeData::FilenameToURLPolicy policy) const override;
   bool HasFile() const override;
-  bool HasCustomFormat(const Clipboard::FormatType& format) const override;
+  bool HasCustomFormat(const ClipboardFormatType& format) const override;
 
   void SetFileContents(const base::FilePath& filename,
                        const std::string& file_contents) override;
@@ -97,7 +96,7 @@
 
  private:
   friend class OSExchangeDataProviderAuraX11Test;
-  typedef std::map<Clipboard::FormatType, base::Pickle> PickleData;
+  typedef std::map<ClipboardFormatType, base::Pickle> PickleData;
 
   // Returns true if |formats_| contains a string format and the string can be
   // parsed as a URL.
--- a/ui/base/dragdrop/os_exchange_data_provider_aurax11_unittest.cc	2019-02-14 01:14:41.000000000 +0300
+++ b/ui/base/dragdrop/os_exchange_data_provider_aurax11_unittest.cc	2019-02-20 20:48:23.484000000 +0300
@@ -8,6 +8,7 @@
 #include "base/strings/utf_string_conversions.h"
 #include "base/test/scoped_task_environment.h"
 #include "testing/gtest/include/gtest/gtest.h"
+#include "ui/base/clipboard/clipboard_constants.h"
 #include "ui/base/dragdrop/file_info.h"
 #include "ui/events/platform/x11/x11_event_source_glib.h"
 #include "ui/gfx/x/x11_atom_cache.h"
@@ -32,8 +33,7 @@
     scoped_refptr<base::RefCountedMemory> mem(
         base::RefCountedString::TakeString(&contents_copy));
 
-    provider.format_map_.Insert(gfx::GetAtom(ui::Clipboard::kMimeTypeURIList),
-                                mem);
+    provider.format_map_.Insert(gfx::GetAtom(ui::kMimeTypeURIList), mem);
   }
 
  protected:
--- a/ui/base/dragdrop/os_exchange_data_provider_mac.h	2019-02-14 01:14:41.000000000 +0300
+++ b/ui/base/dragdrop/os_exchange_data_provider_mac.h	2019-02-20 20:48:23.484000000 +0300
@@ -35,7 +35,7 @@
   void SetURL(const GURL& url, const base::string16& title) override;
   void SetFilename(const base::FilePath& path) override;
   void SetFilenames(const std::vector<FileInfo>& filenames) override;
-  void SetPickledData(const Clipboard::FormatType& format,
+  void SetPickledData(const ClipboardFormatType& format,
                       const base::Pickle& data) override;
   bool GetString(base::string16* data) const override;
   bool GetURLAndTitle(OSExchangeData::FilenameToURLPolicy policy,
@@ -43,12 +43,12 @@
                       base::string16* title) const override;
   bool GetFilename(base::FilePath* path) const override;
   bool GetFilenames(std::vector<FileInfo>* filenames) const override;
-  bool GetPickledData(const Clipboard::FormatType& format,
+  bool GetPickledData(const ClipboardFormatType& format,
                       base::Pickle* data) const override;
   bool HasString() const override;
   bool HasURL(OSExchangeData::FilenameToURLPolicy policy) const override;
   bool HasFile() const override;
-  bool HasCustomFormat(const Clipboard::FormatType& format) const override;
+  bool HasCustomFormat(const ClipboardFormatType& format) const override;
   void SetDragImage(const gfx::ImageSkia& image,
                     const gfx::Vector2d& cursor_offset) override;
   gfx::ImageSkia GetDragImage() const override;
--- a/ui/base/dragdrop/os_exchange_data_provider_mac.mm	2019-02-14 01:14:41.000000000 +0300
+++ b/ui/base/dragdrop/os_exchange_data_provider_mac.mm	2019-02-20 20:48:23.488000000 +0300
@@ -12,6 +12,8 @@
 #include "base/strings/sys_string_conversions.h"
 #include "base/strings/utf_string_conversions.h"
 #import "third_party/mozilla/NSPasteboard+Utils.h"
+#include "ui/base/clipboard/clipboard_constants.h"
+#include "ui/base/clipboard/clipboard_format_type.h"
 #import "ui/base/clipboard/clipboard_util_mac.h"
 #include "ui/base/clipboard/custom_data_helper.h"
 #import "ui/base/dragdrop/cocoa_dnd_util.h"
@@ -78,7 +80,7 @@
 }
 
 void OSExchangeDataProviderMac::SetPickledData(
-    const Clipboard::FormatType& format,
+    const ClipboardFormatType& format,
     const base::Pickle& data) {
   NSData* ns_data = [NSData dataWithBytes:data.data() length:data.size()];
   [pasteboard_->get() setData:ns_data forType:format.ToNSString()];
@@ -160,7 +162,7 @@
 }
 
 bool OSExchangeDataProviderMac::GetPickledData(
-    const Clipboard::FormatType& format,
+    const ClipboardFormatType& format,
     base::Pickle* data) const {
   DCHECK(data);
   NSData* ns_data = [pasteboard_->get() dataForType:format.ToNSString()];
@@ -189,7 +191,7 @@
 }
 
 bool OSExchangeDataProviderMac::HasCustomFormat(
-    const Clipboard::FormatType& format) const {
+    const ClipboardFormatType& format) const {
   return [[pasteboard_->get() types] containsObject:format.ToNSString()];
 }
 
--- a/ui/base/dragdrop/os_exchange_data_provider_win.cc	2019-02-14 01:14:41.000000000 +0300
+++ b/ui/base/dragdrop/os_exchange_data_provider_win.cc	2019-02-20 20:48:23.488000000 +0300
@@ -26,7 +26,7 @@
 #include "net/base/filename_util.h"
 #include "skia/ext/skia_utils_win.h"
 #include "third_party/skia/include/core/SkBitmap.h"
-#include "ui/base/clipboard/clipboard.h"
+#include "ui/base/clipboard/clipboard_format_type.h"
 #include "ui/base/clipboard/clipboard_util_win.h"
 #include "ui/base/dragdrop/file_info.h"
 #include "ui/base/l10n/l10n_util.h"
@@ -38,9 +38,9 @@
 
 namespace ui {
 
-static const Clipboard::FormatType& GetRendererTaintFormatType() {
-  static base::NoDestructor<Clipboard::FormatType> format(
-      ui::Clipboard::GetFormatType("chromium/x-renderer-taint"));
+static const ClipboardFormatType& GetRendererTaintFormatType() {
+  static base::NoDestructor<ClipboardFormatType> format(
+      ui::ClipboardFormatType::GetType("chromium/x-renderer-taint"));
   return *format;
 }
 
@@ -306,12 +306,12 @@
 void OSExchangeDataProviderWin::SetString(const base::string16& data) {
   STGMEDIUM* storage = GetStorageForString(data);
   data_->contents_.push_back(std::make_unique<DataObjectImpl::StoredDataInfo>(
-      Clipboard::GetPlainTextWFormatType().ToFormatEtc(), storage));
+      ClipboardFormatType::GetPlainTextWType().ToFormatEtc(), storage));
 
   // Also add the UTF8-encoded version.
   storage = GetStorageForString(base::UTF16ToUTF8(data));
   data_->contents_.push_back(std::make_unique<DataObjectImpl::StoredDataInfo>(
-      Clipboard::GetPlainTextFormatType().ToFormatEtc(), storage));
+      ClipboardFormatType::GetPlainTextType().ToFormatEtc(), storage));
 }
 
 void OSExchangeDataProviderWin::SetURL(const GURL& url,
@@ -328,7 +328,7 @@
   x_moz_url_str += title;
   STGMEDIUM* storage = GetStorageForString(x_moz_url_str);
   data_->contents_.push_back(std::make_unique<DataObjectImpl::StoredDataInfo>(
-      Clipboard::GetMozUrlFormatType().ToFormatEtc(), storage));
+      ClipboardFormatType::GetMozUrlType().ToFormatEtc(), storage));
 
   // Add a .URL shortcut file for dragging to Explorer.
   base::string16 valid_file_name;
@@ -340,10 +340,10 @@
   // Add a UniformResourceLocator link for apps like IE and Word.
   storage = GetStorageForString(base::UTF8ToUTF16(url.spec()));
   data_->contents_.push_back(std::make_unique<DataObjectImpl::StoredDataInfo>(
-      Clipboard::GetUrlWFormatType().ToFormatEtc(), storage));
+      ClipboardFormatType::GetUrlWType().ToFormatEtc(), storage));
   storage = GetStorageForString(url.spec());
   data_->contents_.push_back(std::make_unique<DataObjectImpl::StoredDataInfo>(
-      Clipboard::GetUrlFormatType().ToFormatEtc(), storage));
+      ClipboardFormatType::GetUrlType().ToFormatEtc(), storage));
 
   // TODO(beng): add CF_HTML.
   // http://code.google.com/p/chromium/issues/detail?id=6767GetIDListStorageForFileName
@@ -360,7 +360,7 @@
   if (!storage)
     return;
   data_->contents_.push_back(std::make_unique<DataObjectImpl::StoredDataInfo>(
-      Clipboard::GetIDListFormatType().ToFormatEtc(), storage));
+      ClipboardFormatType::GetIDListType().ToFormatEtc(), storage));
 }
 
 void OSExchangeDataProviderWin::SetFilenames(
@@ -370,11 +370,11 @@
     return;
 
   data_->contents_.push_back(std::make_unique<DataObjectImpl::StoredDataInfo>(
-      Clipboard::GetCFHDropFormatType().ToFormatEtc(), storage));
+      ClipboardFormatType::GetCFHDropType().ToFormatEtc(), storage));
 }
 
 void OSExchangeDataProviderWin::SetPickledData(
-    const Clipboard::FormatType& format,
+    const ClipboardFormatType& format,
     const base::Pickle& data) {
   STGMEDIUM* storage = GetStorageForBytes(data.data(), data.size());
   data_->contents_.push_back(std::make_unique<DataObjectImpl::StoredDataInfo>(
@@ -387,12 +387,12 @@
   // Add CFSTR_FILEDESCRIPTOR
   STGMEDIUM* storage = GetStorageForFileDescriptor(filename);
   data_->contents_.push_back(std::make_unique<DataObjectImpl::StoredDataInfo>(
-      Clipboard::GetFileDescriptorFormatType().ToFormatEtc(), storage));
+      ClipboardFormatType::GetFileDescriptorType().ToFormatEtc(), storage));
 
   // Add CFSTR_FILECONTENTS
   storage = GetStorageForBytes(file_contents.data(), file_contents.length());
   data_->contents_.push_back(std::make_unique<DataObjectImpl::StoredDataInfo>(
-      Clipboard::GetFileContentZeroFormatType().ToFormatEtc(), storage));
+      ClipboardFormatType::GetFileContentZeroType().ToFormatEtc(), storage));
 }
 
 void OSExchangeDataProviderWin::SetHtml(const base::string16& html,
@@ -404,12 +404,12 @@
   std::string cf_html = ClipboardUtil::HtmlToCFHtml(utf8_html, url);
   STGMEDIUM* storage = GetStorageForBytes(cf_html.c_str(), cf_html.size());
   data_->contents_.push_back(std::make_unique<DataObjectImpl::StoredDataInfo>(
-      Clipboard::GetHtmlFormatType().ToFormatEtc(), storage));
+      ClipboardFormatType::GetHtmlType().ToFormatEtc(), storage));
 
   STGMEDIUM* storage_plain = GetStorageForBytes(utf8_html.c_str(),
                                                 utf8_html.size());
   data_->contents_.push_back(std::make_unique<DataObjectImpl::StoredDataInfo>(
-      Clipboard::GetTextHtmlFormatType().ToFormatEtc(), storage_plain));
+      ClipboardFormatType::GetTextHtmlType().ToFormatEtc(), storage_plain));
 }
 
 bool OSExchangeDataProviderWin::GetString(base::string16* data) const {
@@ -459,7 +459,7 @@
 }
 
 bool OSExchangeDataProviderWin::GetPickledData(
-    const Clipboard::FormatType& format,
+    const ClipboardFormatType& format,
     base::Pickle* data) const {
   DCHECK(data);
   bool success = false;
@@ -523,7 +523,7 @@
 }
 
 bool OSExchangeDataProviderWin::HasCustomFormat(
-    const Clipboard::FormatType& format) const {
+    const ClipboardFormatType& format) const {
   FORMATETC format_etc = format.ToFormatEtc();
   return (source_object_->QueryGetData(&format_etc) == S_OK);
 }
@@ -540,7 +540,7 @@
 
   // Add CF_HDROP.
   auto info = std::make_unique<DataObjectImpl::StoredDataInfo>(
-      Clipboard::GetCFHDropFormatType().ToFormatEtc(), storage);
+      ClipboardFormatType::GetCFHDropType().ToFormatEtc(), storage);
   info->downloader = download.downloader;
   data_->contents_.push_back(std::move(info));
 
--- a/ui/base/dragdrop/os_exchange_data_provider_win.h	2019-02-14 01:14:41.000000000 +0300
+++ b/ui/base/dragdrop/os_exchange_data_provider_win.h	2019-02-20 20:48:23.488000000 +0300
@@ -154,7 +154,7 @@
   void SetURL(const GURL& url, const base::string16& title) override;
   void SetFilename(const base::FilePath& path) override;
   void SetFilenames(const std::vector<FileInfo>& filenames) override;
-  void SetPickledData(const Clipboard::FormatType& format,
+  void SetPickledData(const ClipboardFormatType& format,
                       const base::Pickle& data) override;
   void SetFileContents(const base::FilePath& filename,
                        const std::string& file_contents) override;
@@ -166,7 +166,7 @@
                       base::string16* title) const override;
   bool GetFilename(base::FilePath* path) const override;
   bool GetFilenames(std::vector<FileInfo>* filenames) const override;
-  bool GetPickledData(const Clipboard::FormatType& format,
+  bool GetPickledData(const ClipboardFormatType& format,
                       base::Pickle* data) const override;
   bool GetFileContents(base::FilePath* filename,
                        std::string* file_contents) const override;
@@ -176,7 +176,7 @@
   bool HasFile() const override;
   bool HasFileContents() const override;
   bool HasHtml() const override;
-  bool HasCustomFormat(const Clipboard::FormatType& format) const override;
+  bool HasCustomFormat(const ClipboardFormatType& format) const override;
   void SetDownloadFileInfo(
       const OSExchangeData::DownloadFileInfo& download_info) override;
   void SetDragImage(const gfx::ImageSkia& image_skia,
--- a/ui/base/dragdrop/os_exchange_data_unittest.cc	2019-02-14 01:14:41.000000000 +0300
+++ b/ui/base/dragdrop/os_exchange_data_unittest.cc	2019-02-20 20:48:23.488000000 +0300
@@ -12,6 +12,7 @@
 #include "net/base/filename_util.h"
 #include "testing/gtest/include/gtest/gtest.h"
 #include "testing/platform_test.h"
+#include "ui/base/clipboard/clipboard_format_type.h"
 #include "ui/base/dragdrop/file_info.h"
 #include "ui/base/dragdrop/os_exchange_data.h"
 #include "ui/events/platform/platform_event_source.h"
@@ -142,8 +143,8 @@
 }
 
 TEST_F(OSExchangeDataTest, TestPickledData) {
-  const Clipboard::FormatType kTestFormat =
-      Clipboard::GetFormatType("application/vnd.chromium.test");
+  const ui::ClipboardFormatType kTestFormat =
+      ui::ClipboardFormatType::GetType("application/vnd.chromium.test");
 
   base::Pickle saved_pickle;
   saved_pickle.WriteInt(1);
--- a/ui/base/dragdrop/os_exchange_data_win_unittest.cc	2019-02-14 01:14:41.000000000 +0300
+++ b/ui/base/dragdrop/os_exchange_data_win_unittest.cc	2019-02-20 20:48:23.488000000 +0300
@@ -10,7 +10,7 @@
 #include "base/strings/utf_string_conversions.h"
 #include "base/win/scoped_hglobal.h"
 #include "testing/gtest/include/gtest/gtest.h"
-#include "ui/base/clipboard/clipboard.h"
+#include "ui/base/clipboard/clipboard_format_type.h"
 #include "ui/base/dragdrop/file_info.h"
 #include "ui/base/dragdrop/os_exchange_data_provider_win.h"
 #include "url/gurl.h"
@@ -322,7 +322,7 @@
   expected_cf_html += base::WideToUTF8(html);
   expected_cf_html.append("<!--EndFragment-->\r\n</body>\r\n</html>");
 
-  FORMATETC format = Clipboard::GetHtmlFormatType().ToFormatEtc();
+  FORMATETC format = ClipboardFormatType::GetHtmlType().ToFormatEtc();
   STGMEDIUM medium;
   IDataObject* data_object = OSExchangeDataProviderWin::GetIDataObject(data);
   EXPECT_EQ(S_OK, data_object->GetData(&format, &medium));
--- a/ui/base/ime/linux/fake_input_method_context_factory.cc	2019-02-14 01:14:41.000000000 +0300
+++ b/ui/base/ime/linux/fake_input_method_context_factory.cc	2019-02-20 20:48:23.504000000 +0300
@@ -8,7 +8,9 @@
 
 namespace ui {
 
-FakeInputMethodContextFactory::FakeInputMethodContextFactory() {}
+FakeInputMethodContextFactory::FakeInputMethodContextFactory() = default;
+
+FakeInputMethodContextFactory::~FakeInputMethodContextFactory() = default;
 
 std::unique_ptr<LinuxInputMethodContext>
 FakeInputMethodContextFactory::CreateInputMethodContext(
--- a/ui/base/ime/linux/fake_input_method_context_factory.h	2019-02-14 01:14:41.000000000 +0300
+++ b/ui/base/ime/linux/fake_input_method_context_factory.h	2019-02-20 20:48:23.504000000 +0300
@@ -7,6 +7,7 @@
 
 #include "base/macros.h"
 #include "ui/base/ime/linux/linux_input_method_context_factory.h"
+#include "ui/base/ime/linux/ui_base_ime_linux_export.h"
 
 namespace ui {
 
@@ -16,6 +17,7 @@
     : public LinuxInputMethodContextFactory {
  public:
   FakeInputMethodContextFactory();
+  ~FakeInputMethodContextFactory() override;
 
   // LinuxInputMethodContextFactory:
   std::unique_ptr<LinuxInputMethodContext> CreateInputMethodContext(
--- a/ui/base/mojo/BUILD.gn	2019-02-14 01:14:41.000000000 +0300
+++ b/ui/base/mojo/BUILD.gn	2019-02-20 20:48:23.516000000 +0300
@@ -32,5 +32,6 @@
     "//base",
     "//mojo/public/cpp/bindings",
     "//ui/base",
+    "//ui/base/clipboard",
   ]
 }
--- a/ui/base/mojo/clipboard_client.cc	2019-02-14 01:14:41.000000000 +0300
+++ b/ui/base/mojo/clipboard_client.cc	2019-02-20 20:48:23.516000000 +0300
@@ -30,7 +30,7 @@
   return sequence_number;
 }
 
-bool ClipboardClient::IsFormatAvailable(const FormatType& format,
+bool ClipboardClient::IsFormatAvailable(const ClipboardFormatType& format,
                                         ClipboardType type) const {
   mojo::SyncCallRestrictions::ScopedAllowSyncCall allow_sync_call;
   bool result = false;
@@ -96,7 +96,7 @@
   clipboard_->ReadBookmark(title, url);
 }
 
-void ClipboardClient::ReadData(const FormatType& format,
+void ClipboardClient::ReadData(const ClipboardFormatType& format,
                                std::string* result) const {
   mojo::SyncCallRestrictions::ScopedAllowSyncCall allow_sync_call;
   clipboard_->ReadData(format.Serialize(), result);
@@ -157,7 +157,7 @@
   clipboard_->WriteBitmap(out_bitmap);
 }
 
-void ClipboardClient::WriteData(const FormatType& format,
+void ClipboardClient::WriteData(const ClipboardFormatType& format,
                                 const char* data_data,
                                 size_t data_len) {
   mojo::SyncCallRestrictions::ScopedAllowSyncCall allow_sync_call;
--- a/ui/base/mojo/clipboard_client.h	2019-02-14 01:14:41.000000000 +0300
+++ b/ui/base/mojo/clipboard_client.h	2019-02-20 20:48:23.516000000 +0300
@@ -22,7 +22,7 @@
   // Clipboard overrides:
   void OnPreShutdown() override;
   uint64_t GetSequenceNumber(ClipboardType type) const override;
-  bool IsFormatAvailable(const FormatType& format,
+  bool IsFormatAvailable(const ClipboardFormatType& format,
                          ClipboardType type) const override;
   void Clear(ClipboardType type) override;
   void ReadAvailableTypes(ClipboardType type,
@@ -41,7 +41,8 @@
                       const base::string16& type,
                       base::string16* result) const override;
   void ReadBookmark(base::string16* title, std::string* url) const override;
-  void ReadData(const FormatType& format, std::string* result) const override;
+  void ReadData(const ClipboardFormatType& format,
+                std::string* result) const override;
   void WriteObjects(ClipboardType type, const ObjectMap& objects) override;
   void WriteText(const char* text_data, size_t text_len) override;
   void WriteHTML(const char* markup_data,
@@ -55,7 +56,7 @@
                      size_t url_len) override;
   void WriteWebSmartPaste() override;
   void WriteBitmap(const SkBitmap& bitmap) override;
-  void WriteData(const FormatType& format,
+  void WriteData(const ClipboardFormatType& format,
                  const char* data_data,
                  size_t data_len) override;
 
--- a/ui/base/mojo/clipboard_host.cc	2019-02-14 01:14:41.000000000 +0300
+++ b/ui/base/mojo/clipboard_host.cc	2019-02-20 20:48:23.516000000 +0300
@@ -33,7 +33,7 @@
 void ClipboardHost::IsFormatAvailable(const std::string& format,
                                       ClipboardType type,
                                       IsFormatAvailableCallback callback) {
-  auto format_type = Clipboard::FormatType::Deserialize(format);
+  auto format_type = ClipboardFormatType::Deserialize(format);
   bool result = clipboard_->IsFormatAvailable(format_type, type);
   std::move(callback).Run(result);
 }
@@ -52,11 +52,11 @@
 
 void ClipboardHost::ReadText(ClipboardType type, ReadTextCallback callback) {
   base::string16 result;
-  if (clipboard_->IsFormatAvailable(Clipboard::GetPlainTextWFormatType(),
+  if (clipboard_->IsFormatAvailable(ClipboardFormatType::GetPlainTextWType(),
                                     type)) {
     clipboard_->ReadText(type, &result);
-  } else if (clipboard_->IsFormatAvailable(Clipboard::GetPlainTextFormatType(),
-                                           type)) {
+  } else if (clipboard_->IsFormatAvailable(
+                 ClipboardFormatType::GetPlainTextType(), type)) {
     std::string ascii;
     clipboard_->ReadAsciiText(type, &ascii);
     result = base::ASCIIToUTF16(ascii);
@@ -111,7 +111,7 @@
 void ClipboardHost::ReadData(const std::string& format,
                              ReadDataCallback callback) {
   std::string result;
-  clipboard_->ReadData(Clipboard::FormatType::Deserialize(format), &result);
+  clipboard_->ReadData(ClipboardFormatType::Deserialize(format), &result);
   std::move(callback).Run(std::move(result));
 }
 
--- a/ui/base/x/selection_owner.h	2019-02-14 01:14:41.000000000 +0300
+++ b/ui/base/x/selection_owner.h	2019-02-20 20:48:23.536000000 +0300
@@ -22,9 +22,9 @@
 
 class XScopedEventSelector;
 
-extern const char kIncr[];
-extern const char kSaveTargets[];
-extern const char kTargets[];
+UI_BASE_EXPORT extern const char kIncr[];
+UI_BASE_EXPORT extern const char kSaveTargets[];
+UI_BASE_EXPORT extern const char kTargets[];
 
 // Owns a specific X11 selection on an X window.
 //
--- a/ui/base/x/selection_utils.cc	2019-02-14 01:14:41.000000000 +0300
+++ b/ui/base/x/selection_utils.cc	2019-02-20 20:48:23.536000000 +0300
@@ -14,7 +14,7 @@
 #include "base/strings/string_split.h"
 #include "base/strings/string_util.h"
 #include "base/strings/utf_string_conversions.h"
-#include "ui/base/clipboard/clipboard.h"
+#include "ui/base/clipboard/clipboard_constants.h"
 #include "ui/gfx/x/x11_atom_cache.h"
 
 namespace ui {
@@ -37,14 +37,14 @@
 
 std::vector<::Atom> GetURLAtomsFrom() {
   std::vector< ::Atom> atoms;
-  atoms.push_back(gfx::GetAtom(Clipboard::kMimeTypeURIList));
-  atoms.push_back(gfx::GetAtom(Clipboard::kMimeTypeMozillaURL));
+  atoms.push_back(gfx::GetAtom(kMimeTypeURIList));
+  atoms.push_back(gfx::GetAtom(kMimeTypeMozillaURL));
   return atoms;
 }
 
 std::vector<::Atom> GetURIListAtomsFrom() {
   std::vector< ::Atom> atoms;
-  atoms.push_back(gfx::GetAtom(Clipboard::kMimeTypeURIList));
+  atoms.push_back(gfx::GetAtom(kMimeTypeURIList));
   return atoms;
 }
 
@@ -198,7 +198,7 @@
 base::string16 SelectionData::GetHtml() const {
   base::string16 markup;
 
-  if (type_ == gfx::GetAtom(Clipboard::kMimeTypeHTML)) {
+  if (type_ == gfx::GetAtom(kMimeTypeHTML)) {
     const unsigned char* data = GetData();
     size_t size = GetSize();
 
--- a/ui/base/x/selection_utils.h	2019-02-14 01:14:41.000000000 +0300
+++ b/ui/base/x/selection_utils.h	2019-02-20 20:48:23.536000000 +0300
@@ -9,16 +9,15 @@
 #include <map>
 
 #include "base/memory/ref_counted_memory.h"
-#include "ui/base/clipboard/clipboard.h"
 #include "ui/base/ui_base_export.h"
 #include "ui/gfx/x/x11.h"
 
 namespace ui {
 class SelectionData;
 
-extern const char kString[];
-extern const char kText[];
-extern const char kUtf8String[];
+UI_BASE_EXPORT extern const char kString[];
+UI_BASE_EXPORT extern const char kText[];
+UI_BASE_EXPORT extern const char kUtf8String[];
 
 // Returns a list of all text atoms that we handle.
 UI_BASE_EXPORT std::vector<::Atom> GetTextAtomsFrom();
--- a/ui/display/manager/display_manager.cc	2019-02-14 01:14:41.000000000 +0300
+++ b/ui/display/manager/display_manager.cc	2019-02-20 20:48:23.724000000 +0300
@@ -2196,12 +2196,6 @@
   if (num_connected_displays_ <= 1)
     return;
 
-  // External displays mirrored because of forced tablet mode mirroring should
-  // not be considered candidates for restoring their mirrored state.
-  // https://crbug.com/919994.
-  if (layout_store_->forced_mirror_mode_for_tablet())
-    return;
-
   for (auto id : GetCurrentDisplayIdList()) {
     if (Display::IsInternalDisplayId(id))
       continue;
--- a/ui/login/display_manager.js	2019-02-14 01:14:42.000000000 +0300
+++ b/ui/login/display_manager.js	2019-02-20 20:48:24.024000000 +0300
@@ -75,8 +75,7 @@
   SAML_PASSWORD_CONFIRM: 5,
   PASSWORD_CHANGED: 6,
   ENROLLMENT: 7,
-  ERROR: 8,
-  SYNC_CONSENT: 9,
+  ERROR: 8
 };
 
 /* Possible UI states of the error screen. */
--- a/ui/message_center/views/notification_view_md.cc	2019-02-14 01:14:42.000000000 +0300
+++ b/ui/message_center/views/notification_view_md.cc	2019-02-20 20:48:24.036000000 +0300
@@ -1212,8 +1212,9 @@
     return;
 
   bool inline_settings_visible = !settings_row_->visible();
-  bool disable_notification =
-      settings_row_->visible() && block_all_button_->checked();
+
+  if (!inline_settings_visible && block_all_button_->checked())
+    MessageCenter::Get()->DisableNotification(notification_id());
 
   settings_row_->SetVisible(inline_settings_visible);
   content_row_->SetVisible(!inline_settings_visible);
@@ -1235,11 +1236,6 @@
 
   Layout();
   SchedulePaint();
-
-  // Call DisableNotification() at the end, because |this| can be deleted at any
-  // point after it's called.
-  if (disable_notification)
-    MessageCenter::Get()->DisableNotification(notification_id());
 }
 
 // TODO(yoshiki): Move this to the parent class (MessageView) and share the code
--- a/ui/message_center/views/notification_view_md.h	2019-02-14 01:14:42.000000000 +0300
+++ b/ui/message_center/views/notification_view_md.h	2019-02-20 20:48:24.036000000 +0300
@@ -224,8 +224,6 @@
   FRIEND_TEST_ALL_PREFIXES(NotificationViewMDTest, InlineSettings);
   FRIEND_TEST_ALL_PREFIXES(NotificationViewMDTest, UpdateViewsOrderingTest);
   FRIEND_TEST_ALL_PREFIXES(NotificationViewMDTest, TestDeleteOnToggleExpanded);
-  FRIEND_TEST_ALL_PREFIXES(NotificationViewMDTest,
-                           TestDeleteOnDisableNotification);
 
   friend class NotificationViewMDTest;
 
--- a/ui/message_center/views/notification_view_md_unittest.cc	2019-02-14 01:14:42.000000000 +0300
+++ b/ui/message_center/views/notification_view_md_unittest.cc	2019-02-20 20:48:24.036000000 +0300
@@ -4,8 +4,6 @@
 
 #include "ui/message_center/views/notification_view_md.h"
 
-#include <memory>
-
 #include "base/strings/string_util.h"
 #include "base/strings/utf_string_conversions.h"
 #include "build/build_config.h"
@@ -16,7 +14,6 @@
 #include "ui/events/test/event_generator.h"
 #include "ui/gfx/canvas.h"
 #include "ui/message_center/message_center.h"
-#include "ui/message_center/message_center_observer.h"
 #include "ui/message_center/public/cpp/message_center_constants.h"
 #include "ui/message_center/views/bounded_label.h"
 #include "ui/message_center/views/notification_control_buttons_view.h"
@@ -105,8 +102,7 @@
 class NotificationViewMDTest
     : public views::ViewsTestBase,
       public views::ViewObserver,
-      public message_center::MessageView::SlideObserver,
-      public message_center::MessageCenterObserver {
+      public message_center::MessageView::SlideObserver {
  public:
   NotificationViewMDTest();
   ~NotificationViewMDTest() override;
@@ -129,19 +125,11 @@
   // Overridden from message_center::MessageView::Observer:
   void OnSlideChanged(const std::string& notification_id) override {}
 
-  // Overridden from message_center::MessageCenterObserver:
-  void OnNotificationRemoved(const std::string& notification_id,
-                             bool by_user) override;
-
   void set_delete_on_preferred_size_changed(
       bool delete_on_preferred_size_changed) {
     delete_on_preferred_size_changed_ = delete_on_preferred_size_changed;
   }
 
-  void set_delete_on_notification_removed(bool delete_on_notification_removed) {
-    delete_on_notification_removed_ = delete_on_notification_removed;
-  }
-
  protected:
   const gfx::Image CreateTestImage(int width, int height) const;
   const SkBitmap CreateBitmap(int width, int height) const;
@@ -162,7 +150,6 @@
   views::View* GetCloseButton();
 
   bool delete_on_preferred_size_changed_ = false;
-  bool delete_on_notification_removed_ = false;
   std::set<std::string> removed_ids_;
   scoped_refptr<NotificationTestDelegate> delegate_;
   std::unique_ptr<NotificationViewMD> notification_view_;
@@ -201,15 +188,10 @@
 
   std::unique_ptr<Notification> notification = CreateSimpleNotification();
   UpdateNotificationViews(*notification);
-
-  MessageCenter::Get()->AddObserver(this);
 }
 
 void NotificationViewMDTest::TearDown() {
-  MessageCenter::Get()->RemoveObserver(this);
-
-  DCHECK(notification_view_ || delete_on_preferred_size_changed_ ||
-         delete_on_notification_removed_);
+  DCHECK(notification_view_ || delete_on_preferred_size_changed_);
   if (notification_view_) {
     notification_view_->SetInkDropMode(MessageView::InkDropMode::OFF);
     notification_view_->RemoveObserver(this);
@@ -231,16 +213,6 @@
   widget()->SetSize(notification_view()->GetPreferredSize());
 }
 
-void NotificationViewMDTest::OnNotificationRemoved(
-    const std::string& notification_id,
-    bool by_user) {
-  if (delete_on_notification_removed_) {
-    widget()->CloseNow();
-    notification_view_.reset();
-    return;
-  }
-}
-
 const gfx::Image NotificationViewMDTest::CreateTestImage(int width,
                                                          int height) const {
   return gfx::Image::CreateFrom1xBitmap(CreateBitmap(width, height));
@@ -1142,19 +1114,4 @@
                                      DummyEvent());
 }
 
-TEST_F(NotificationViewMDTest, TestDeleteOnDisableNotification) {
-  std::unique_ptr<Notification> notification = CreateSimpleNotification();
-  notification->set_type(NOTIFICATION_TYPE_SIMPLE);
-  UpdateNotificationViews(*notification);
-
-  notification_view()->OnSettingsButtonPressed(DummyEvent());
-  notification_view()->block_all_button_->NotifyClick(DummyEvent());
-
-  // After DisableNotification() is called, |notification_view| can be deleted.
-  // https://crbug.com/924922
-  set_delete_on_notification_removed(true);
-  notification_view()->ButtonPressed(notification_view()->settings_done_button_,
-                                     DummyEvent());
-}
-
 }  // namespace message_center
--- a/ui/ozone/BUILD.gn	2019-02-14 01:14:42.000000000 +0300
+++ b/ui/ozone/BUILD.gn	2019-02-20 20:48:24.040000000 +0300
@@ -72,7 +72,6 @@
 jumbo_component("ozone_base") {
   sources = [
     "ozone_base_export.h",
-    "public/clipboard_delegate.h",
     "public/cursor_factory_ozone.cc",
     "public/cursor_factory_ozone.h",
     "public/gl_ozone.h",
@@ -91,6 +90,7 @@
     "public/overlay_surface_candidate.h",
     "public/ozone_switches.cc",
     "public/ozone_switches.h",
+    "public/platform_clipboard.h",
     "public/platform_screen.h",
     "public/surface_factory_ozone.cc",
     "public/surface_factory_ozone.h",
--- a/ui/ozone/common/linux/BUILD.gn	2019-02-14 01:14:42.000000000 +0300
+++ b/ui/ozone/common/linux/BUILD.gn	2019-02-20 20:48:24.040000000 +0300
@@ -30,6 +30,7 @@
   deps = [
     ":drm",
     "//base:base",
+    "//build/config/linux/libdrm",
     "//third_party/minigbm",
     "//ui/gfx:buffer_types",
     "//ui/gfx:memory_buffer",
--- a/ui/ozone/common/linux/gbm_wrapper.cc	2019-02-14 01:14:42.000000000 +0300
+++ b/ui/ozone/common/linux/gbm_wrapper.cc	2019-02-20 20:48:24.044000000 +0300
@@ -4,7 +4,10 @@
 
 #include "ui/ozone/common/linux/gbm_wrapper.h"
 
+#include <drm_fourcc.h>
+#include <fcntl.h>
 #include <gbm.h>
+#include <xf86drm.h>
 
 #include "base/posix/eintr_wrapper.h"
 #include "third_party/skia/include/core/SkSurface.h"
@@ -21,6 +24,48 @@
 #define GBM_BO_IMPORT_FD_PLANAR_5504 0x5504
 #define GBM_BO_IMPORT_FD_PLANAR_5505 0x5505
 
+int GetPlaneFdForBo(gbm_bo* bo, size_t plane) {
+#if defined(MINIGBM)
+  return gbm_bo_get_plane_fd(bo, plane);
+#else
+  const int plane_count = gbm_bo_get_plane_count(bo);
+  DCHECK(plane_count > 0 && plane < static_cast<size_t>(plane_count));
+
+  // System linux gbm (or Mesa gbm) does not provide fds per plane basis. Thus,
+  // get plane handle and use drm ioctl to get a prime fd out of it avoid having
+  // two different branches for minigbm and Mesa gbm here.
+  gbm_device* gbm_dev = gbm_bo_get_device(bo);
+  int dev_fd = gbm_device_get_fd(gbm_dev);
+  DCHECK_GE(dev_fd, 0);
+
+  const uint32_t plane_handle = gbm_bo_get_handle_for_plane(bo, plane).u32;
+  int fd = -1;
+  int ret;
+  // Use DRM_RDWR to allow the fd to be mappable in another process.
+  ret = drmPrimeHandleToFD(dev_fd, plane_handle, DRM_CLOEXEC | DRM_RDWR, &fd);
+
+  // Older DRM implementations blocked DRM_RDWR, but gave a read/write mapping
+  // anyways
+  if (ret)
+    ret = drmPrimeHandleToFD(dev_fd, plane_handle, DRM_CLOEXEC, &fd);
+
+  return ret ? ret : fd;
+#endif
+}
+
+size_t GetSizeOfPlane(gbm_bo* bo, size_t plane) {
+#if defined(MINIGBM)
+  return gbm_bo_get_plane_size(bo, plane);
+#else
+  // System linux gbm (or Mesa gbm) does not provide plane size. Thus, calculate
+  // it by ourselves and avoid having two different branches for minigbm and
+  // Mesa gbm here.
+  //
+  // TODO(msisov): Handle subsampled formats
+  return gbm_bo_get_height(bo) * gbm_bo_get_stride_for_plane(bo, plane);
+#endif
+}
+
 }  // namespace
 
 class Buffer final : public ui::GbmBuffer {
@@ -84,7 +129,7 @@
   }
   uint32_t GetPlaneHandle(size_t plane) const override {
     DCHECK_LT(plane, planes_.size());
-    return gbm_bo_get_plane_handle(bo_, plane).u32;
+    return gbm_bo_get_handle_for_plane(bo_, plane).u32;
   }
   uint32_t GetHandle() const override { return gbm_bo_get_handle(bo_).u32; }
   gfx::NativePixmapHandle ExportHandle() const override {
@@ -113,8 +158,14 @@
     DCHECK(!mmap_data_);
     uint32_t stride;
     void* addr;
-    addr = gbm_bo_map(bo_, 0, 0, gbm_bo_get_width(bo_), gbm_bo_get_height(bo_),
+    addr =
+#if defined(MINIGBM)
+        gbm_bo_map(bo_, 0, 0, gbm_bo_get_width(bo_), gbm_bo_get_height(bo_),
                       GBM_BO_TRANSFER_READ_WRITE, &stride, &mmap_data_, 0);
+#else
+        gbm_bo_map(bo_, 0, 0, gbm_bo_get_width(bo_), gbm_bo_get_height(bo_),
+                   GBM_BO_TRANSFER_READ_WRITE, &stride, &mmap_data_);
+#endif
 
     if (!addr)
       return nullptr;
@@ -155,11 +206,18 @@
   std::vector<base::ScopedFD> fds;
   std::vector<gfx::NativePixmapPlane> planes;
 
-  const uint64_t modifier = gbm_bo_get_format_modifier(bo);
-  for (size_t i = 0; i < gbm_bo_get_num_planes(bo); ++i) {
+  const uint64_t modifier = gbm_bo_get_modifier(bo);
+  const int plane_count = gbm_bo_get_plane_count(bo);
+  // The Mesa's gbm implementation explicitly checks whether plane count <= and
+  // returns 1 if the condition is true. Nevertheless, use a DCHECK here to make
+  // sure the condition is not broken there.
+  DCHECK_GT(plane_count, 0);
+  // Ensure there are no differences in integer signs by casting any possible
+  // values to size_t.
+  for (size_t i = 0; i < static_cast<size_t>(plane_count); ++i) {
     // The fd returned by gbm_bo_get_fd is not ref-counted and need to be
     // kept open for the lifetime of the buffer.
-    base::ScopedFD fd(gbm_bo_get_plane_fd(bo, i));
+    base::ScopedFD fd(GetPlaneFdForBo(bo, i));
 
     // TODO(dcastagna): support multiple fds.
     // crbug.com/642410
@@ -172,9 +230,9 @@
       fds.emplace_back(std::move(fd));
     }
 
-    planes.emplace_back(gbm_bo_get_plane_stride(bo, i),
-                        gbm_bo_get_plane_offset(bo, i),
-                        gbm_bo_get_plane_size(bo, i), modifier);
+    planes.emplace_back(gbm_bo_get_stride_for_plane(bo, i),
+                        gbm_bo_get_offset(bo, i), GetSizeOfPlane(bo, i),
+                        modifier);
   }
   return std::make_unique<Buffer>(bo, format, flags, modifier, std::move(fds),
                                   size, std::move(planes));
@@ -221,7 +279,10 @@
     DCHECK_EQ(planes[0].offset, 0);
 
     // Try to use scanout if supported.
-    int gbm_flags = GBM_BO_USE_SCANOUT | GBM_BO_USE_TEXTURING;
+    int gbm_flags = GBM_BO_USE_SCANOUT;
+#if defined(MINIGBM)
+    gbm_flags |= GBM_BO_USE_TEXTURING;
+#endif
     if (!gbm_device_is_format_supported(device_, format, gbm_flags))
       gbm_flags &= ~GBM_BO_USE_SCANOUT;
 
@@ -231,17 +292,24 @@
       return nullptr;
     }
 
-    struct gbm_import_fd_planar_data fd_data;
+    struct gbm_import_fd_modifier_data fd_data;
     fd_data.width = size.width();
     fd_data.height = size.height();
     fd_data.format = format;
+    fd_data.modifier = DRM_FORMAT_MOD_NONE;
 
     DCHECK_LE(planes.size(), 3u);
     for (size_t i = 0; i < planes.size(); ++i) {
       fd_data.fds[i] = fds[i < fds.size() ? i : 0].get();
       fd_data.strides[i] = planes[i].stride;
       fd_data.offsets[i] = planes[i].offset;
-      fd_data.format_modifiers[i] = planes[i].modifier;
+      if (fd_data.modifier == DRM_FORMAT_MOD_NONE)
+        fd_data.modifier = planes[i].modifier;
+
+      if (fd_data.modifier != planes[i].modifier) {
+        LOG(ERROR) << "Format modifier must be the same for all the planes";
+        return nullptr;
+      }
     }
 
     // The fd passed to gbm_bo_import is not ref-counted and need to be
--- a/ui/ozone/platform/wayland/BUILD.gn	2019-02-14 01:14:42.000000000 +0300
+++ b/ui/ozone/platform/wayland/BUILD.gn	2019-02-20 20:48:24.068000000 +0300
@@ -29,6 +29,8 @@
     "wayland_connection_connector.h",
     "wayland_cursor.cc",
     "wayland_cursor.h",
+    "wayland_cursor_position.cc",
+    "wayland_cursor_position.h",
     "wayland_data_device.cc",
     "wayland_data_device.h",
     "wayland_data_device_manager.cc",
--- a/ui/ozone/platform/wayland/fake_server.cc	2019-02-14 01:14:42.000000000 +0300
+++ b/ui/ozone/platform/wayland/fake_server.cc	2019-02-20 20:48:24.068000000 +0300
@@ -1041,6 +1041,10 @@
   return global_ != nullptr;
 }
 
+void Global::DestroyGlobal() {
+  global_.reset();
+}
+
 // static
 void Global::Bind(wl_client* client,
                   void* data,
@@ -1083,19 +1087,22 @@
 MockDataDeviceManager::~MockDataDeviceManager() {}
 
 MockOutput::MockOutput()
-    : Global(&wl_output_interface, nullptr, kOutputVersion),
-      rect_(gfx::Rect(0, 0, 800, 600)) {}
+    : Global(&wl_output_interface, nullptr, kOutputVersion) {}
 
 MockOutput::~MockOutput() {}
 
 // Notify clients of the change for output position.
 void MockOutput::OnBind() {
+  if (rect_.IsEmpty())
+    return;
+
   const char* kUnknownMake = "unknown";
   const char* kUnknownModel = "unknown";
   wl_output_send_geometry(resource(), rect_.x(), rect_.y(), 0, 0, 0,
                           kUnknownMake, kUnknownModel, 0);
   wl_output_send_mode(resource(), WL_OUTPUT_MODE_CURRENT, rect_.width(),
                       rect_.height(), 0);
+  wl_output_send_done(resource());
 }
 
 MockSeat::MockSeat() : Global(&wl_seat_interface, &seat_impl, kSeatVersion) {}
@@ -1148,6 +1155,10 @@
   base::ScopedFD server_fd(fd[0]);
   base::ScopedFD client_fd(fd[1]);
 
+  // If client has not specified rect before, user standard ones.
+  if (output_.GetRect().IsEmpty())
+    output_.SetRect(gfx::Rect(0, 0, 800, 600));
+
   if (wl_display_init_shm(display_.get()) < 0)
     return false;
   if (!compositor_.Initialize(display_.get()))
--- a/ui/ozone/platform/wayland/fake_server.h	2019-02-14 01:14:42.000000000 +0300
+++ b/ui/ozone/platform/wayland/fake_server.h	2019-02-20 20:48:24.068000000 +0300
@@ -277,6 +277,11 @@
 
   // Create a global object.
   bool Initialize(wl_display* display);
+
+  // Can be used by clients to explicitly destroy global objects and send
+  // global_remove event.
+  void DestroyGlobal();
+
   // Called from Bind() to send additional information to clients.
   virtual void OnBind() {}
 
@@ -453,10 +458,13 @@
     return resource ? T::FromResource(resource) : nullptr;
   }
 
-  void CreateAndInitializeOutput() {
+  MockOutput* CreateAndInitializeOutput() {
     auto output = std::make_unique<MockOutput>();
     output->Initialize(display());
+
+    MockOutput* output_ptr = output.get();
     globals_.push_back(std::move(output));
+    return output_ptr;
   }
 
   MockDataDeviceManager* data_device_manager() { return &data_device_manager_; }
--- a/ui/ozone/platform/wayland/gpu/gbm_pixmap_wayland.cc	2019-02-14 01:14:42.000000000 +0300
+++ b/ui/ozone/platform/wayland/gpu/gbm_pixmap_wayland.cc	2019-02-20 20:48:24.068000000 +0300
@@ -162,7 +162,6 @@
   for (size_t i = 0; i < plane_count; ++i) {
     strides.push_back(GetDmaBufPitch(i));
     offsets.push_back(GetDmaBufOffset(i));
-    if (modifier != DRM_FORMAT_MOD_INVALID)
       modifiers.push_back(modifier);
   }
 
--- a/ui/ozone/platform/wayland/ozone_platform_wayland.cc	2019-02-14 01:14:42.000000000 +0300
+++ b/ui/ozone/platform/wayland/ozone_platform_wayland.cc	2019-02-20 20:48:24.068000000 +0300
@@ -115,7 +115,13 @@
     // The WaylandConnection and the WaylandOutputManager must be created before
     // PlatformScreen.
     DCHECK(connection_ && connection_->wayland_output_manager());
-    return connection_->wayland_output_manager()->CreateWaylandScreen();
+    return connection_->wayland_output_manager()->CreateWaylandScreen(
+        connection_.get());
+  }
+
+  PlatformClipboard* GetPlatformClipboard() override {
+    DCHECK(connection_);
+    return connection_->GetPlatformClipboard();
   }
 
   bool IsNativePixmapConfigSupported(gfx::BufferFormat format,
--- a/ui/ozone/platform/wayland/wayland_buffer_manager.cc	2019-02-14 01:14:42.000000000 +0300
+++ b/ui/ozone/platform/wayland/wayland_buffer_manager.cc	2019-02-20 20:48:24.068000000 +0300
@@ -105,9 +105,17 @@
 
   uint32_t fd = file.TakePlatformFile();
   for (size_t i = 0; i < planes_count; i++) {
+    uint32_t modifier_lo = 0;
+    uint32_t modifier_hi = 0;
+    if (modifiers[i] != DRM_FORMAT_MOD_INVALID) {
+      modifier_lo = modifiers[i] & UINT32_MAX;
+      modifier_hi = modifiers[i] >> 32;
+    } else {
+      DCHECK_EQ(planes_count, 1u) << "Invalid modifier may be passed only in "
+                                     "case of single plane format being used";
+    }
     zwp_linux_buffer_params_v1_add(params, fd, i /* plane id */, offsets[i],
-                                   strides[i], modifiers[i] >> 32,
-                                   modifiers[i] & UINT32_MAX);
+                                   strides[i], modifier_hi, modifier_lo);
   }
   zwp_linux_buffer_params_v1_add_listener(params, &params_listener, this);
   zwp_linux_buffer_params_v1_create(params, width, height, format, 0);
--- a/ui/ozone/platform/wayland/wayland_connection.cc	2019-02-14 01:14:42.000000000 +0300
+++ b/ui/ozone/platform/wayland/wayland_connection.cc	2019-02-20 20:48:24.068000000 +0300
@@ -35,6 +35,8 @@
 constexpr uint32_t kMaxWpPresentationVersion = 1;
 constexpr uint32_t kMaxTextInputManagerVersion = 1;
 
+constexpr uint32_t kMinWlOutputVersion = 2;
+
 std::unique_ptr<WaylandDataSource> CreateWaylandDataSource(
     WaylandDataDeviceManager* data_device_manager,
     WaylandConnection* connection) {
@@ -67,7 +69,7 @@
 
   wl_registry_add_listener(registry_.get(), &registry_listener, this);
   while (!wayland_output_manager_ ||
-         !wayland_output_manager_->IsPrimaryOutputReady()) {
+         !wayland_output_manager_->IsOutputReady()) {
     wl_display_roundtrip(display_.get());
   }
 
@@ -123,6 +125,20 @@
   return it == window_map_.end() ? nullptr : it->second;
 }
 
+WaylandWindow* WaylandConnection::GetWindowWithLargestBounds() {
+  WaylandWindow* window_with_largest_bounds = nullptr;
+  for (auto entry : window_map_) {
+    if (!window_with_largest_bounds) {
+      window_with_largest_bounds = entry.second;
+      continue;
+    }
+    WaylandWindow* window = entry.second;
+    if (window_with_largest_bounds->GetBounds() < window->GetBounds())
+      window_with_largest_bounds = window;
+  }
+  return window_with_largest_bounds;
+}
+
 WaylandWindow* WaylandConnection::GetCurrentFocusedWindow() {
   for (auto entry : window_map_) {
     WaylandWindow* window = entry.second;
@@ -203,13 +219,13 @@
   }
 }
 
-ClipboardDelegate* WaylandConnection::GetClipboardDelegate() {
+PlatformClipboard* WaylandConnection::GetPlatformClipboard() {
   return this;
 }
 
 void WaylandConnection::OfferClipboardData(
-    const ClipboardDelegate::DataMap& data_map,
-    ClipboardDelegate::OfferDataClosure callback) {
+    const PlatformClipboard::DataMap& data_map,
+    PlatformClipboard::OfferDataClosure callback) {
   if (!data_source_) {
     data_source_ = CreateWaylandDataSource(data_device_manager_.get(), this);
     data_source_->WriteToClipboard(data_map);
@@ -220,8 +236,8 @@
 
 void WaylandConnection::RequestClipboardData(
     const std::string& mime_type,
-    ClipboardDelegate::DataMap* data_map,
-    ClipboardDelegate::RequestDataClosure callback) {
+    PlatformClipboard::DataMap* data_map,
+    PlatformClipboard::RequestDataClosure callback) {
   read_clipboard_closure_ = std::move(callback);
 
   DCHECK(data_map);
@@ -233,6 +249,13 @@
   return !!data_source_;
 }
 
+void WaylandConnection::SetSequenceNumberUpdateCb(
+    PlatformClipboard::SequenceNumberUpdateCb cb) {
+  CHECK(update_sequence_cb_.is_null())
+      << " The callback can be installed only once.";
+  update_sequence_cb_ = std::move(cb);
+}
+
 ozone::mojom::WaylandConnectionPtr WaylandConnection::BindInterface() {
   // This mustn't be called twice or when the zwp_linux_dmabuf interface is not
   // available.
@@ -289,7 +312,7 @@
 }
 
 void WaylandConnection::GetAvailableMimeTypes(
-    ClipboardDelegate::GetMimeTypesClosure callback) {
+    PlatformClipboard::GetMimeTypesClosure callback) {
   std::move(callback).Run(data_device_->GetAvailableMimeTypes());
 }
 
@@ -314,6 +337,11 @@
   data_map_ = nullptr;
 }
 
+void WaylandConnection::UpdateClipboardSequenceNumber() {
+  if (!update_sequence_cb_.is_null())
+    update_sequence_cb_.Run();
+}
+
 void WaylandConnection::OnDispatcherListChanged() {
   StartProcessingEvents();
 }
@@ -418,7 +446,15 @@
     xdg_shell_use_unstable_version(connection->shell_.get(),
                                    XDG_SHELL_VERSION_CURRENT);
   } else if (base::EqualsCaseInsensitiveASCII(interface, "wl_output")) {
-    wl::Object<wl_output> output = wl::Bind<wl_output>(registry, name, 1);
+    if (version < kMinWlOutputVersion) {
+      LOG(ERROR)
+          << "Unable to bind to the unsupported wl_output object with version= "
+          << version << ". Minimum supported version is "
+          << kMinWlOutputVersion;
+      return;
+    }
+
+    wl::Object<wl_output> output = wl::Bind<wl_output>(registry, name, version);
     if (!output) {
       LOG(ERROR) << "Failed to bind to wl_output global";
       return;
@@ -497,9 +533,13 @@
           pointer, base::BindRepeating(&WaylandConnection::DispatchUiEvent,
                                        base::Unretained(connection)));
       connection->pointer_->set_connection(connection);
+
+      connection->wayland_cursor_position_ =
+          std::make_unique<WaylandCursorPosition>();
     }
   } else if (connection->pointer_) {
     connection->pointer_.reset();
+    connection->wayland_cursor_position_.reset();
   }
   if (capabilities & WL_SEAT_CAPABILITY_KEYBOARD) {
     if (!connection->keyboard_) {
--- a/ui/ozone/platform/wayland/wayland_connection.h	2019-02-14 01:14:42.000000000 +0300
+++ b/ui/ozone/platform/wayland/wayland_connection.h	2019-02-20 20:48:24.068000000 +0300
@@ -13,6 +13,7 @@
 #include "ui/events/platform/platform_event_source.h"
 #include "ui/gfx/buffer_types.h"
 #include "ui/gfx/native_widget_types.h"
+#include "ui/ozone/platform/wayland/wayland_cursor_position.h"
 #include "ui/ozone/platform/wayland/wayland_data_device.h"
 #include "ui/ozone/platform/wayland/wayland_data_device_manager.h"
 #include "ui/ozone/platform/wayland/wayland_data_source.h"
@@ -21,8 +22,8 @@
 #include "ui/ozone/platform/wayland/wayland_output.h"
 #include "ui/ozone/platform/wayland/wayland_pointer.h"
 #include "ui/ozone/platform/wayland/wayland_touch.h"
-#include "ui/ozone/public/clipboard_delegate.h"
 #include "ui/ozone/public/interfaces/wayland/wayland_connection.mojom.h"
+#include "ui/ozone/public/platform_clipboard.h"
 
 namespace ui {
 
@@ -30,8 +31,9 @@
 class WaylandOutputManager;
 class WaylandWindow;
 
+// TODO: factor out PlatformClipboard to a separate class.
 class WaylandConnection : public PlatformEventSource,
-                          public ClipboardDelegate,
+                          public PlatformClipboard,
                           public ozone::mojom::WaylandConnection,
                           public base::MessagePumpLibevent::FdWatcher {
  public:
@@ -82,6 +84,7 @@
   }
 
   WaylandWindow* GetWindow(gfx::AcceleratedWidget widget);
+  WaylandWindow* GetWindowWithLargestBounds();
   WaylandWindow* GetCurrentFocusedWindow();
   WaylandWindow* GetCurrentKeyboardFocusedWindow();
   void AddWindow(gfx::AcceleratedWidget widget, WaylandWindow* window);
@@ -104,23 +107,31 @@
     return wayland_output_manager_.get();
   }
 
+  // Returns the cursor position, which may be null.
+  WaylandCursorPosition* wayland_cursor_position() {
+    return wayland_cursor_position_.get();
+  }
+
   // Clipboard implementation.
-  ClipboardDelegate* GetClipboardDelegate();
+  PlatformClipboard* GetPlatformClipboard();
   void DataSourceCancelled();
   void SetClipboardData(const std::string& contents,
                         const std::string& mime_type);
+  void UpdateClipboardSequenceNumber();
 
-  // ClipboardDelegate.
+  // PlatformClipboard.
   void OfferClipboardData(
-      const ClipboardDelegate::DataMap& data_map,
-      ClipboardDelegate::OfferDataClosure callback) override;
+      const PlatformClipboard::DataMap& data_map,
+      PlatformClipboard::OfferDataClosure callback) override;
   void RequestClipboardData(
       const std::string& mime_type,
-      ClipboardDelegate::DataMap* data_map,
-      ClipboardDelegate::RequestDataClosure callback) override;
+      PlatformClipboard::DataMap* data_map,
+      PlatformClipboard::RequestDataClosure callback) override;
   void GetAvailableMimeTypes(
-      ClipboardDelegate::GetMimeTypesClosure callback) override;
+      PlatformClipboard::GetMimeTypesClosure callback) override;
   bool IsSelectionOwner() override;
+  void SetSequenceNumberUpdateCb(
+      PlatformClipboard::SequenceNumberUpdateCb cb) override;
 
   // Returns bound pointer to own mojo interface.
   ozone::mojom::WaylandConnectionPtr BindInterface();
@@ -210,6 +221,7 @@
   std::unique_ptr<WaylandOutputManager> wayland_output_manager_;
   std::unique_ptr<WaylandPointer> pointer_;
   std::unique_ptr<WaylandTouch> touch_;
+  std::unique_ptr<WaylandCursorPosition> wayland_cursor_position_;
 
   // Objects that are using when GPU runs in own process.
   std::unique_ptr<WaylandBufferManager> buffer_manager_;
@@ -222,7 +234,11 @@
 
   // Holds a temporary instance of the client's clipboard content
   // so that we can asynchronously write to it.
-  ClipboardDelegate::DataMap* data_map_ = nullptr;
+  PlatformClipboard::DataMap* data_map_ = nullptr;
+
+  // Notifies whenever clipboard sequence number is changed. Can be empty if not
+  // set.
+  PlatformClipboard::SequenceNumberUpdateCb update_sequence_cb_;
 
   // Stores the callback to be invoked upon data reading from clipboard.
   RequestDataClosure read_clipboard_closure_;
--- a/ui/ozone/platform/wayland/wayland_data_device.cc	2019-02-14 01:14:42.000000000 +0300
+++ b/ui/ozone/platform/wayland/wayland_data_device.cc	2019-02-20 20:48:24.068000000 +0300
@@ -224,6 +224,8 @@
                                     wl_data_offer* offer) {
   auto* self = static_cast<WaylandDataDevice*>(data);
 
+  self->connection_->UpdateClipboardSequenceNumber();
+
   DCHECK(!self->new_offer_);
   self->new_offer_.reset(new WaylandDataOffer(offer));
 }
--- a/ui/ozone/platform/wayland/wayland_data_device_unittest.cc	2019-02-14 01:14:42.000000000 +0300
+++ b/ui/ozone/platform/wayland/wayland_data_device_unittest.cc	2019-02-20 20:48:24.068000000 +0300
@@ -10,23 +10,23 @@
 #include "ui/events/base_event_utils.h"
 #include "ui/ozone/platform/wayland/fake_server.h"
 #include "ui/ozone/platform/wayland/wayland_test.h"
-#include "ui/ozone/public/clipboard_delegate.h"
+#include "ui/ozone/public/platform_clipboard.h"
 
 namespace ui {
 
 // This class mocks how a real clipboard/ozone client would
-// hook to ClipboardDelegate, with one difference: real clients
+// hook to PlatformClipboard, with one difference: real clients
 // have no access to the WaylandConnection instance like this
 // MockClipboardClient impl does. Instead, clients and ozone gets
 // plumbbed up by calling the appropriated Ozone API,
-// OzonePlatform::GetClipboardDelegate.
+// OzonePlatform::GetPlatformClipboard.
 class MockClipboardClient {
  public:
   MockClipboardClient(WaylandConnection* connection) {
     DCHECK(connection);
     // See comment above for reasoning to access the WaylandConnection
     // directly from here.
-    delegate_ = connection->GetClipboardDelegate();
+    delegate_ = connection->GetPlatformClipboard();
 
     DCHECK(delegate_);
   }
@@ -35,7 +35,7 @@
   // Fill the clipboard backing store with sample data.
   void SetData(const std::string& utf8_text,
                const std::string& mime_type,
-               ClipboardDelegate::OfferDataClosure callback) {
+               PlatformClipboard::OfferDataClosure callback) {
     // This mimics how Mus' ClipboardImpl writes data to the DataMap.
     std::vector<char> object_map(utf8_text.begin(), utf8_text.end());
     char* object_data = &object_map.front();
@@ -46,7 +46,7 @@
   }
 
   void ReadData(const std::string& mime_type,
-                ClipboardDelegate::RequestDataClosure callback) {
+                PlatformClipboard::RequestDataClosure callback) {
     delegate_->RequestClipboardData(mime_type, &data_types_,
                                     std::move(callback));
   }
@@ -54,8 +54,8 @@
   bool IsSelectionOwner() { return delegate_->IsSelectionOwner(); }
 
  private:
-  ClipboardDelegate* delegate_ = nullptr;
-  ClipboardDelegate::DataMap data_types_;
+  PlatformClipboard* delegate_ = nullptr;
+  PlatformClipboard::DataMap data_types_;
 
   DISALLOW_COPY_AND_ASSIGN(MockClipboardClient);
 };
--- a/ui/ozone/platform/wayland/wayland_data_source.cc	2019-02-14 01:14:42.000000000 +0300
+++ b/ui/ozone/platform/wayland/wayland_data_source.cc	2019-02-20 20:48:24.072000000 +0300
@@ -27,7 +27,7 @@
 WaylandDataSource::~WaylandDataSource() = default;
 
 void WaylandDataSource::WriteToClipboard(
-    const ClipboardDelegate::DataMap& data_map) {
+    const PlatformClipboard::DataMap& data_map) {
   for (const auto& data : data_map) {
     wl_data_source_offer(data_source_.get(), data.first.c_str());
     if (strcmp(data.first.c_str(), kTextMimeType) == 0)
@@ -40,7 +40,7 @@
 }
 
 void WaylandDataSource::UpdataDataMap(
-    const ClipboardDelegate::DataMap& data_map) {
+    const PlatformClipboard::DataMap& data_map) {
   data_map_ = data_map;
 }
 
--- a/ui/ozone/platform/wayland/wayland_data_source.h	2019-02-14 01:14:42.000000000 +0300
+++ b/ui/ozone/platform/wayland/wayland_data_source.h	2019-02-20 20:48:24.072000000 +0300
@@ -15,7 +15,7 @@
 #include "base/macros.h"
 #include "base/optional.h"
 #include "ui/ozone/platform/wayland/wayland_object.h"
-#include "ui/ozone/public/clipboard_delegate.h"
+#include "ui/ozone/public/platform_clipboard.h"
 
 namespace ui {
 
@@ -42,8 +42,8 @@
     connection_ = connection;
   }
 
-  void WriteToClipboard(const ClipboardDelegate::DataMap& data_map);
-  void UpdataDataMap(const ClipboardDelegate::DataMap& data_map);
+  void WriteToClipboard(const PlatformClipboard::DataMap& data_map);
+  void UpdataDataMap(const PlatformClipboard::DataMap& data_map);
   void Offer(const ui::OSExchangeData& data);
   void SetAction(int operation);
   void SetDragData(const DragDataMap& data_map);
@@ -71,7 +71,7 @@
   WaylandConnection* connection_ = nullptr;
   WaylandWindow* source_window_ = nullptr;
 
-  ClipboardDelegate::DataMap data_map_;
+  PlatformClipboard::DataMap data_map_;
   DragDataMap drag_data_map_;
   // Action selected by the compositor
   uint32_t dnd_action_;
--- a/ui/ozone/platform/wayland/wayland_object.h	2019-02-14 01:14:42.000000000 +0300
+++ b/ui/ozone/platform/wayland/wayland_object.h	2019-02-20 20:48:24.072000000 +0300
@@ -251,7 +251,7 @@
   Object() {}
   explicit Object(T* obj) : std::unique_ptr<T, Deleter>(obj) {}
 
-  uint32_t id() {
+  uint32_t id() const {
     return wl_proxy_get_id(
         reinterpret_cast<wl_proxy*>(std::unique_ptr<T, Deleter>::get()));
   }
--- a/ui/ozone/platform/wayland/wayland_output.cc	2019-02-14 01:14:42.000000000 +0300
+++ b/ui/ozone/platform/wayland/wayland_output.cc	2019-02-20 20:48:24.072000000 +0300
@@ -63,16 +63,15 @@
                                      int32_t height,
                                      int32_t refresh) {
   WaylandOutput* wayland_output = static_cast<WaylandOutput*>(data);
-  if (wayland_output && (flags & WL_OUTPUT_MODE_CURRENT)) {
-    wayland_output->rect_in_physical_pixels_.set_width(width);
-    wayland_output->rect_in_physical_pixels_.set_height(height);
-    wayland_output->TriggerDelegateNotification();
-  }
+  if (wayland_output && (flags & WL_OUTPUT_MODE_CURRENT))
+    wayland_output->rect_in_physical_pixels_.set_size(gfx::Size(width, height));
 }
 
 // static
 void WaylandOutput::OutputHandleDone(void* data, struct wl_output* wl_output) {
-  NOTIMPLEMENTED_LOG_ONCE();
+  WaylandOutput* wayland_output = static_cast<WaylandOutput*>(data);
+  if (wayland_output)
+    wayland_output->TriggerDelegateNotification();
 }
 
 // static
@@ -80,10 +79,8 @@
                                       struct wl_output* wl_output,
                                       int32_t factor) {
   WaylandOutput* wayland_output = static_cast<WaylandOutput*>(data);
-  if (wayland_output) {
+  if (wayland_output)
     wayland_output->device_scale_factor_ = factor;
-    wayland_output->TriggerDelegateNotification();
-  }
 }
 
 }  // namespace ui
--- a/ui/ozone/platform/wayland/wayland_output.h	2019-02-14 01:14:42.000000000 +0300
+++ b/ui/ozone/platform/wayland/wayland_output.h	2019-02-20 20:48:24.072000000 +0300
@@ -35,6 +35,7 @@
   void TriggerDelegateNotification() const;
 
   uint32_t output_id() const { return output_id_; }
+  bool has_output(wl_output* output) const { return output_.get() == output; }
 
   // Tells if the output has already received physical screen dimensions in the
   // global compositor space.
--- a/ui/ozone/platform/wayland/wayland_output_manager.cc	2019-02-14 01:14:42.000000000 +0300
+++ b/ui/ozone/platform/wayland/wayland_output_manager.cc	2019-02-20 20:48:24.072000000 +0300
@@ -13,13 +13,10 @@
 
 WaylandOutputManager::~WaylandOutputManager() = default;
 
-bool WaylandOutputManager::IsPrimaryOutputReady() const {
+bool WaylandOutputManager::IsOutputReady() const {
   if (output_list_.empty())
     return false;
-
-  // The very first output in the list is always treated as a primary output.
-  const auto& primary_output = output_list_.front();
-  return primary_output->is_ready();
+  return output_list_.front()->is_ready();
 }
 
 void WaylandOutputManager::AddWaylandOutput(const uint32_t output_id,
@@ -38,9 +35,9 @@
 
   OnWaylandOutputAdded(output_id);
 
-  // If WaylandScreen has already been created, the output can be initialized,
-  // which results in setting up a wl_listener and getting the geometry and the
-  // scaling factor from the Wayland Compositor.
+  // Even if WaylandScreen has not been created, the output still must be
+  // initialized, which results in setting up a wl_listener and getting the
+  // geometry and the scaling factor from the Wayland Compositor.
   wayland_output_ptr->Initialize(this);
 }
 
@@ -54,19 +51,13 @@
   if (output_it == output_list_.end())
     return;
 
-  bool was_primary_output = IsPrimaryOutput(output_id);
   output_list_.erase(output_it);
-
-  // If it was a primary output removed, make sure the second output, which
-  // became a primary one, announces that to observers.
-  if (was_primary_output && !output_list_.empty())
-    output_list_.front()->TriggerDelegateNotification();
-
   OnWaylandOutputRemoved(output_id);
 }
 
-std::unique_ptr<WaylandScreen> WaylandOutputManager::CreateWaylandScreen() {
-  auto wayland_screen = std::make_unique<WaylandScreen>();
+std::unique_ptr<WaylandScreen> WaylandOutputManager::CreateWaylandScreen(
+    WaylandConnection* connection) {
+  auto wayland_screen = std::make_unique<WaylandScreen>(connection);
   wayland_screen_ = wayland_screen->GetWeakPtr();
 
   // As long as |wl_output| sends geometry and other events asynchronously (that
@@ -87,9 +78,18 @@
   return wayland_screen;
 }
 
+uint32_t WaylandOutputManager::GetIdForOutput(wl_output* output) const {
+  auto output_it = std::find_if(
+      output_list_.begin(), output_list_.end(),
+      [output](const auto& item) { return item->has_output(output); });
+  // This is unlikely to happen, but better to be explicit here.
+  DCHECK(output_it != output_list_.end());
+  return output_it->get()->output_id();
+}
+
 void WaylandOutputManager::OnWaylandOutputAdded(uint32_t output_id) {
   if (wayland_screen_)
-    wayland_screen_->OnOutputAdded(output_id, IsPrimaryOutput(output_id));
+    wayland_screen_->OnOutputAdded(output_id);
 }
 
 void WaylandOutputManager::OnWaylandOutputRemoved(uint32_t output_id) {
@@ -97,21 +97,12 @@
     wayland_screen_->OnOutputRemoved(output_id);
 }
 
-bool WaylandOutputManager::IsPrimaryOutput(uint32_t output_id) const {
-  DCHECK(!output_list_.empty());
-  // The very first object in the |output_list_| is always treated as a primary
-  // output.
-  const auto& primary_output = output_list_.front();
-  return primary_output->output_id() == output_id;
-}
-
 void WaylandOutputManager::OnOutputHandleMetrics(uint32_t output_id,
                                                  const gfx::Rect& new_bounds,
                                                  int32_t scale_factor) {
-  if (wayland_screen_) {
-    wayland_screen_->OnOutputMetricsChanged(output_id, new_bounds, scale_factor,
-                                            IsPrimaryOutput(output_id));
-  }
+  if (wayland_screen_)
+    wayland_screen_->OnOutputMetricsChanged(output_id, new_bounds,
+                                            scale_factor);
 }
 
 }  // namespace ui
--- a/ui/ozone/platform/wayland/wayland_output_manager.h	2019-02-14 01:14:42.000000000 +0300
+++ b/ui/ozone/platform/wayland/wayland_output_manager.h	2019-02-20 20:48:24.072000000 +0300
@@ -19,6 +19,7 @@
 
 namespace ui {
 
+class WaylandConnection;
 class WaylandOutput;
 
 class WaylandOutputManager : public WaylandOutput::Delegate {
@@ -26,21 +27,23 @@
   WaylandOutputManager();
   ~WaylandOutputManager() override;
 
-  // The first output in the vector is always a primary output.
-  bool IsPrimaryOutputReady() const;
+  // Says if at least one output has already been announced by a Wayland
+  // compositor.
+  bool IsOutputReady() const;
 
   void AddWaylandOutput(const uint32_t output_id, wl_output* output);
   void RemoveWaylandOutput(const uint32_t output_id);
 
   // Creates a platform screen and feeds it with existing outputs.
-  std::unique_ptr<WaylandScreen> CreateWaylandScreen();
+  std::unique_ptr<WaylandScreen> CreateWaylandScreen(
+      WaylandConnection* connection);
+
+  uint32_t GetIdForOutput(wl_output* output) const;
 
  private:
   void OnWaylandOutputAdded(uint32_t output_id);
   void OnWaylandOutputRemoved(uint32_t output_id);
 
-  bool IsPrimaryOutput(uint32_t output_id) const;
-
   // WaylandOutput::Delegate:
   void OnOutputHandleMetrics(uint32_t output_id,
                              const gfx::Rect& new_bounds,
--- a/ui/ozone/platform/wayland/wayland_pointer.cc	2019-02-14 01:14:42.000000000 +0300
+++ b/ui/ozone/platform/wayland/wayland_pointer.cc	2019-02-20 20:48:24.072000000 +0300
@@ -80,6 +80,7 @@
   if (surface) {
     WaylandWindow* window = WaylandWindow::FromSurface(surface);
     window->set_pointer_focus(false);
+    window->set_has_implicit_grab(false);
     pointer->window_with_pointer_focus_ = nullptr;
   }
 }
--- a/ui/ozone/platform/wayland/wayland_screen.cc	2019-02-14 01:14:42.000000000 +0300
+++ b/ui/ozone/platform/wayland/wayland_screen.cc	2019-02-20 20:48:24.072000000 +0300
@@ -9,34 +9,75 @@
 #include "ui/display/display_observer.h"
 #include "ui/gfx/geometry/point.h"
 #include "ui/gfx/geometry/size.h"
+#include "ui/ozone/platform/wayland/wayland_connection.h"
+#include "ui/ozone/platform/wayland/wayland_cursor_position.h"
+#include "ui/ozone/platform/wayland/wayland_window.h"
 
 namespace ui {
 
-WaylandScreen::WaylandScreen() : weak_factory_(this) {}
+WaylandScreen::WaylandScreen(WaylandConnection* connection)
+    : connection_(connection), weak_factory_(this) {
+  DCHECK(connection_);
+}
 
 WaylandScreen::~WaylandScreen() = default;
 
-void WaylandScreen::OnOutputAdded(uint32_t output_id, bool is_primary) {
+void WaylandScreen::OnOutputAdded(uint32_t output_id) {
   display::Display new_display(output_id);
   display_list_.AddDisplay(std::move(new_display),
-                           is_primary
-                               ? display::DisplayList::Type::PRIMARY
-                               : display::DisplayList::Type::NOT_PRIMARY);
+                           display::DisplayList::Type::NOT_PRIMARY);
 }
 
 void WaylandScreen::OnOutputRemoved(uint32_t output_id) {
+  display::Display primary_display = GetPrimaryDisplay();
+  if (primary_display.id() == output_id) {
+    // First, set a new primary display as required by the |display_list_|. It's
+    // safe to set any of the displays to be a primary one. Once the output is
+    // completely removed, Wayland updates geometry of other displays. And a
+    // display, which became the one to be nearest to the origin will become a
+    // primary one.
+    for (const auto& display : display_list_.displays()) {
+      if (display.id() != output_id) {
+        display_list_.AddOrUpdateDisplay(display,
+                                         display::DisplayList::Type::PRIMARY);
+        break;
+      }
+    }
+  }
   display_list_.RemoveDisplay(output_id);
 }
 
 void WaylandScreen::OnOutputMetricsChanged(uint32_t output_id,
                                            const gfx::Rect& new_bounds,
-                                           float device_pixel_ratio,
-                                           bool is_primary) {
+                                           float device_pixel_ratio) {
   display::Display changed_display(output_id);
   changed_display.set_device_scale_factor(device_pixel_ratio);
   changed_display.set_bounds(new_bounds);
   changed_display.set_work_area(new_bounds);
 
+  bool is_primary = false;
+  display::Display display_nearest_origin =
+      GetDisplayNearestPoint(gfx::Point(0, 0));
+  // If bounds of the nearest to origin display are empty, it must have been the
+  // very first and the same display added before.
+  if (display_nearest_origin.bounds().IsEmpty()) {
+    DCHECK_EQ(display_nearest_origin.id(), changed_display.id());
+    is_primary = true;
+  } else if (changed_display.bounds().origin() <
+             display_nearest_origin.bounds().origin()) {
+    // If changed display is nearer to the origin than the previous display,
+    // that one must become a primary display.
+    is_primary = true;
+  } else if (changed_display.bounds().OffsetFromOrigin() ==
+             display_nearest_origin.bounds().OffsetFromOrigin()) {
+    // If changed display has the same origin as the nearest to origin display,
+    // |changed_display| must become a primary one or it has already been the
+    // primary one. If a user changed positions of two displays (the second at
+    // x,x was set to 0,0), the second change will modify geometry of the
+    // display, which used to be the one nearest to the origin.
+    is_primary = true;
+  }
+
   display_list_.UpdateDisplay(
       changed_display, is_primary ? display::DisplayList::Type::PRIMARY
                                   : display::DisplayList::Type::NOT_PRIMARY);
@@ -52,48 +93,86 @@
 
 display::Display WaylandScreen::GetPrimaryDisplay() const {
   auto iter = display_list_.GetPrimaryDisplayIterator();
-  if (iter == display_list_.displays().end())
-    return display::Display::GetDefaultDisplay();
+  DCHECK(iter != display_list_.displays().end());
   return *iter;
 }
 
 display::Display WaylandScreen::GetDisplayForAcceleratedWidget(
     gfx::AcceleratedWidget widget) const {
-  // TODO(msisov): implement wl_surface_listener::enter and
-  // wl_surface_listener::leave for a wl_surface to know what surface the window
-  // is located on.
-  //
-  // https://crbug.com/890271
-  NOTIMPLEMENTED_LOG_ONCE();
+  auto* wayland_window = connection_->GetWindow(widget);
+  DCHECK(wayland_window);
+
+  const std::set<uint32_t> entered_outputs_ids =
+      wayland_window->GetEnteredOutputsIds();
+  // Although spec says a surface receives enter/leave surface events on
+  // create/move/resize actions, this might be called right after a window is
+  // created, but it has not been configured by a Wayland compositor and it has
+  // not received enter surface events yet. Another case is when a user switches
+  // between displays in a single output mode - Wayland may not send enter
+  // events immediately, which can result in empty container of entered ids
+  // (check comments in WaylandWindow::RemoveEnteredOutputId). In this case,
+  // it's also safe to return the primary display.
+  if (entered_outputs_ids.empty())
+    return GetPrimaryDisplay();
+
+  DCHECK(!display_list_.displays().empty());
+
+  // A widget can be located on two or more displays. It would be better if the
+  // most in pixels occupied display was returned, but it's impossible to do in
+  // Wayland. Thus, return the one, which was the very first used.
+  for (const auto& display : display_list_.displays()) {
+    if (display.id() == *entered_outputs_ids.begin())
+      return display;
+  }
+
+  NOTREACHED();
   return GetPrimaryDisplay();
 }
 
 gfx::Point WaylandScreen::GetCursorScreenPoint() const {
-  NOTIMPLEMENTED_LOG_ONCE();
-  return gfx::Point();
+  // Wayland does not provide either location of surfaces in global space
+  // coordinate system or location of a pointer. Instead, only locations of
+  // mouse/touch events are known. Given that Chromium assumes top-level windows
+  // are located at origin, always provide a cursor point in regards to
+  // surfaces' location.
+  //
+  // If a pointer is located in any of the existing wayland windows, return the
+  // last known cursor position. Otherwise, return such a point, which is not
+  // contained by any of the windows.
+  auto* cursor_position = connection_->wayland_cursor_position();
+  if (connection_->GetCurrentFocusedWindow() && cursor_position)
+    return cursor_position->GetCursorSurfacePoint();
+
+  WaylandWindow* window = connection_->GetWindowWithLargestBounds();
+  DCHECK(window);
+  const gfx::Rect bounds = window->GetBounds();
+  return gfx::Point(bounds.width() + 10, bounds.height() + 10);
 }
 
 gfx::AcceleratedWidget WaylandScreen::GetAcceleratedWidgetAtScreenPoint(
     const gfx::Point& point) const {
-  // TODO(msisov): implement this once wl_surface_listener::enter and ::leave
-  // are used.
-  //
-  // https://crbug.com/890271
-  NOTIMPLEMENTED_LOG_ONCE();
+  // It is safe to check only for focused windows and test if they contain the
+  // point or not.
+  auto* window = connection_->GetCurrentFocusedWindow();
+  if (window && window->GetBounds().Contains(point))
+    return window->GetWidget();
   return gfx::kNullAcceleratedWidget;
 }
 
 display::Display WaylandScreen::GetDisplayNearestPoint(
     const gfx::Point& point) const {
-  NOTIMPLEMENTED_LOG_ONCE();
-  return GetPrimaryDisplay();
+  return *FindDisplayNearestPoint(display_list_.displays(), point);
 }
 
 display::Display WaylandScreen::GetDisplayMatching(
     const gfx::Rect& match_rect) const {
-  // TODO(msisov): https://crbug.com/890272
-  NOTIMPLEMENTED_LOG_ONCE();
-  return GetPrimaryDisplay();
+  if (match_rect.IsEmpty())
+    return GetDisplayNearestPoint(match_rect.origin());
+
+  const display::Display* display_matching =
+      display::FindDisplayWithBiggestIntersection(display_list_.displays(),
+                                                  match_rect);
+  return display_matching ? *display_matching : GetPrimaryDisplay();
 }
 
 void WaylandScreen::AddObserver(display::DisplayObserver* observer) {
--- a/ui/ozone/platform/wayland/wayland_screen.h	2019-02-14 01:14:42.000000000 +0300
+++ b/ui/ozone/platform/wayland/wayland_screen.h	2019-02-20 20:48:24.072000000 +0300
@@ -17,18 +17,19 @@
 
 namespace ui {
 
+class WaylandConnection;
+
 // A PlatformScreen implementation for Wayland.
 class WaylandScreen : public PlatformScreen {
  public:
-  WaylandScreen();
+  explicit WaylandScreen(WaylandConnection* connection);
   ~WaylandScreen() override;
 
-  void OnOutputAdded(uint32_t output_id, bool is_primary);
+  void OnOutputAdded(uint32_t output_id);
   void OnOutputRemoved(uint32_t output_id);
   void OnOutputMetricsChanged(uint32_t output_id,
                               const gfx::Rect& bounds,
-                              float device_pixel_ratio,
-                              bool is_primary);
+                              float device_pixel_ratio);
 
   base::WeakPtr<WaylandScreen> GetWeakPtr();
 
@@ -48,6 +49,8 @@
   void RemoveObserver(display::DisplayObserver* observer) override;
 
  private:
+  WaylandConnection* connection_ = nullptr;
+
   display::DisplayList display_list_;
 
   base::ObserverList<display::DisplayObserver> observers_;
--- a/ui/ozone/platform/wayland/wayland_screen_unittest.cc	2019-02-14 01:14:42.000000000 +0300
+++ b/ui/ozone/platform/wayland/wayland_screen_unittest.cc	2019-02-20 20:48:24.072000000 +0300
@@ -2,15 +2,20 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include <memory>
+
 #include <wayland-server.h>
 
 #include "testing/gtest/include/gtest/gtest.h"
 #include "ui/display/display_observer.h"
 #include "ui/ozone/platform/wayland/fake_server.h"
+#include "ui/ozone/platform/wayland/test/mock_surface.h"
+#include "ui/ozone/platform/wayland/test/test_pointer.h"
 #include "ui/ozone/platform/wayland/wayland_connection.h"
 #include "ui/ozone/platform/wayland/wayland_output_manager.h"
 #include "ui/ozone/platform/wayland/wayland_screen.h"
 #include "ui/ozone/platform/wayland/wayland_test.h"
+#include "ui/platform_window/platform_window_init_properties.h"
 
 namespace ui {
 
@@ -26,6 +31,7 @@
   ~TestDisplayObserver() override {}
 
   display::Display GetDisplay() { return std::move(display_); }
+  display::Display GetRemovedDisplay() { return std::move(removed_display_); }
   uint32_t GetAndClearChangedMetrics() {
     uint32_t changed_metrics = changed_metrics_;
     changed_metrics_ = 0;
@@ -38,7 +44,7 @@
   }
 
   void OnDisplayRemoved(const display::Display& old_display) override {
-    display_ = old_display;
+    removed_display_ = old_display;
   }
 
   void OnDisplayMetricsChanged(const display::Display& display,
@@ -50,6 +56,7 @@
  private:
   uint32_t changed_metrics_ = 0;
   display::Display display_;
+  display::Display removed_display_;
 
   DISALLOW_COPY_AND_ASSIGN(TestDisplayObserver);
 };
@@ -69,12 +76,49 @@
 
     output_manager_ = connection_->wayland_output_manager();
     ASSERT_TRUE(output_manager_);
+
+    EXPECT_TRUE(output_manager_->IsOutputReady());
+    platform_screen_ = output_manager_->CreateWaylandScreen(connection_.get());
   }
 
  protected:
-  wl::MockOutput* output_ = nullptr;
+  std::unique_ptr<WaylandWindow> CreateWaylandWindowWithProperties(
+      const gfx::Rect& bounds,
+      PlatformWindowType window_type,
+      gfx::AcceleratedWidget parent_widget,
+      MockPlatformWindowDelegate* delegate) {
+    auto window = std::make_unique<WaylandWindow>(delegate, connection_.get());
+    PlatformWindowInitProperties properties;
+    properties.bounds = bounds;
+    properties.type = window_type;
+    properties.parent_widget = parent_widget;
+    EXPECT_TRUE(window->Initialize(std::move(properties)));
+    return window;
+  }
+
+  void UpdateOutputGeometry(wl_resource* output_resource,
+                            const gfx::Rect& new_rect) {
+    wl_output_send_geometry(output_resource, new_rect.x(), new_rect.y(),
+                            0 /* physical_width */, 0 /* physical_height */,
+                            0 /* subpixel */, "unknown_make", "unknown_model",
+                            0 /* transform */);
+    wl_output_send_mode(output_resource, WL_OUTPUT_MODE_CURRENT,
+                        new_rect.width(), new_rect.height(), 0 /* refresh */);
+    wl_output_send_done(output_resource);
+  }
+
+  void ValidateTheDisplayForWidget(gfx::AcceleratedWidget widget,
+                                   int64_t expected_display_id) {
+    display::Display display_for_widget =
+        platform_screen_->GetDisplayForAcceleratedWidget(widget);
+    EXPECT_EQ(display_for_widget.id(), expected_display_id);
+  }
+
+  wl::TestOutput* output_ = nullptr;
   WaylandOutputManager* output_manager_ = nullptr;
 
+  std::unique_ptr<WaylandScreen> platform_screen_;
+
  private:
   DISALLOW_COPY_AND_ASSIGN(WaylandScreenTest);
 };
@@ -82,80 +126,95 @@
 // Tests whether a primary output has been initialized before PlatformScreen is
 // created.
 TEST_P(WaylandScreenTest, OutputBaseTest) {
-  EXPECT_TRUE(output_manager_->IsPrimaryOutputReady());
-
-  std::unique_ptr<WaylandScreen> platform_screen =
-      output_manager_->CreateWaylandScreen();
+  // IsPrimaryOutputReady and PlatformScreen creation is done in the
+  // initialization part of the tests.
 
   // Ensure there is only one display, which is the primary one.
-  auto& all_displays = platform_screen->GetAllDisplays();
+  auto& all_displays = platform_screen_->GetAllDisplays();
   EXPECT_EQ(all_displays.size(), kNumberOfDisplays);
 
   // Ensure the size property of the primary display.
-  EXPECT_EQ(platform_screen->GetPrimaryDisplay().bounds(),
+  EXPECT_EQ(platform_screen_->GetPrimaryDisplay().bounds(),
             gfx::Rect(0, 0, kOutputWidth, kOutputHeight));
 }
 
 TEST_P(WaylandScreenTest, MultipleOutputsAddedAndRemoved) {
-  EXPECT_TRUE(output_manager_->IsPrimaryOutputReady());
-  std::unique_ptr<WaylandScreen> platform_screen =
-      output_manager_->CreateWaylandScreen();
-
   TestDisplayObserver observer;
-  platform_screen->AddObserver(&observer);
+  platform_screen_->AddObserver(&observer);
+
+  const int64_t old_primary_display_id =
+      platform_screen_->GetPrimaryDisplay().id();
 
   // Add a second display.
-  server_.CreateAndInitializeOutput();
+  wl::TestOutput* output2 = server_.CreateAndInitializeOutput();
+
+  Sync();
+
+  // Update rect of that display.
+  gfx::Rect output1_rect = server_.output()->GetRect();
+  gfx::Rect output2_rect(output1_rect.width(), 0, 800, 600);
+  // The second display is located to the right of first display like
+  // | || |.
+  UpdateOutputGeometry(output2->resource(), output2_rect);
 
   Sync();
 
   // Ensure that second display is not a primary one and have a different id.
   int64_t added_display_id = observer.GetDisplay().id();
-  EXPECT_NE(platform_screen->GetPrimaryDisplay().id(), added_display_id);
+  EXPECT_NE(platform_screen_->GetPrimaryDisplay().id(), added_display_id);
 
-  // Remove the second output.
-  output_manager_->RemoveWaylandOutput(added_display_id);
+  output2->DestroyGlobal();
 
   Sync();
 
   // Ensure that removed display has correct id.
-  int64_t removed_display_id = observer.GetDisplay().id();
+  int64_t removed_display_id = observer.GetRemovedDisplay().id();
   EXPECT_EQ(added_display_id, removed_display_id);
 
   // Create another display again.
-  server_.CreateAndInitializeOutput();
+  output2 = server_.CreateAndInitializeOutput();
+
+  Sync();
+
+  // Updates rect again.
+  UpdateOutputGeometry(output2->resource(), output2_rect);
 
   Sync();
 
   // The newly added display is not a primary yet.
   added_display_id = observer.GetDisplay().id();
-  EXPECT_NE(platform_screen->GetPrimaryDisplay().id(), added_display_id);
+  EXPECT_NE(platform_screen_->GetPrimaryDisplay().id(), added_display_id);
+
+  // Now, rearrange displays so that second display becomes a primary one.
+  output1_rect = gfx::Rect(1024, 0, 1024, 768);
+  output2_rect = gfx::Rect(0, 0, 1024, 768);
+  UpdateOutputGeometry(server_.output()->resource(), output1_rect);
+  UpdateOutputGeometry(output2->resource(), output2_rect);
 
-  // Make sure the geometry changes are sent by syncing one more time again.
   Sync();
 
-  int64_t old_primary_display_id = platform_screen->GetPrimaryDisplay().id();
-  output_manager_->RemoveWaylandOutput(old_primary_display_id);
+  // Ensure that output2 is now the primary one.
+  EXPECT_EQ(platform_screen_->GetPrimaryDisplay().id(), added_display_id);
 
-  // Ensure that previously added display is now a primary one.
-  EXPECT_EQ(platform_screen->GetPrimaryDisplay().id(), added_display_id);
+  // Remove the primary display now.
+  output2->DestroyGlobal();
+
+  Sync();
+
+  // Ensure that output1 is a primary display now.
+  EXPECT_EQ(platform_screen_->GetPrimaryDisplay().id(), old_primary_display_id);
   // Ensure that the removed display was the one, which was a primary display.
-  EXPECT_EQ(observer.GetDisplay().id(), old_primary_display_id);
+  EXPECT_EQ(observer.GetRemovedDisplay().id(), added_display_id);
+
+  platform_screen_->RemoveObserver(&observer);
 }
 
 TEST_P(WaylandScreenTest, OutputPropertyChanges) {
-  std::unique_ptr<WaylandScreen> platform_screen =
-      output_manager_->CreateWaylandScreen();
   TestDisplayObserver observer;
-  platform_screen->AddObserver(&observer);
+  platform_screen_->AddObserver(&observer);
 
   const gfx::Rect new_rect(0, 0, 800, 600);
-  wl_output_send_geometry(output_->resource(), new_rect.x(), new_rect.y(),
-                          0 /* physical_width */, 0 /* physical_height */,
-                          0 /* subpixel */, "unkown_make", "unknown_model",
-                          0 /* transform */);
-  wl_output_send_mode(output_->resource(), WL_OUTPUT_MODE_CURRENT,
-                      new_rect.width(), new_rect.height(), 0 /* refresh */);
+  UpdateOutputGeometry(output_->resource(), new_rect);
 
   Sync();
 
@@ -167,6 +226,7 @@
 
   const float new_scale_value = 2.0f;
   wl_output_send_scale(output_->resource(), new_scale_value);
+  wl_output_send_done(output_->resource());
 
   Sync();
 
@@ -175,6 +235,350 @@
       display::DisplayObserver::DISPLAY_METRIC_DEVICE_SCALE_FACTOR;
   EXPECT_EQ(observer.GetAndClearChangedMetrics(), changed_values);
   EXPECT_EQ(observer.GetDisplay().device_scale_factor(), new_scale_value);
+
+  platform_screen_->RemoveObserver(&observer);
+}
+
+TEST_P(WaylandScreenTest, GetAcceleratedWidgetAtScreenPoint) {
+  // If there is no focused window (focus is set whenever a pointer enters any
+  // of the windows), there must be kNullAcceleratedWidget returned. There is no
+  // real way to determine what window is located on a certain screen point in
+  // Wayland.
+  gfx::AcceleratedWidget widget_at_screen_point =
+      platform_screen_->GetAcceleratedWidgetAtScreenPoint(gfx::Point(10, 10));
+  EXPECT_EQ(widget_at_screen_point, gfx::kNullAcceleratedWidget);
+
+  // Set a focus to the main window. Now, that focused window must be returned.
+  window_->set_pointer_focus(true);
+  widget_at_screen_point =
+      platform_screen_->GetAcceleratedWidgetAtScreenPoint(gfx::Point(10, 10));
+  EXPECT_EQ(widget_at_screen_point, window_->GetWidget());
+
+  // Getting a widget at a screen point outside its bounds, must result in a
+  // null widget.
+  const gfx::Rect window_bounds = window_->GetBounds();
+  widget_at_screen_point = platform_screen_->GetAcceleratedWidgetAtScreenPoint(
+      gfx::Point(window_bounds.width() + 1, window_bounds.height() + 1));
+  EXPECT_EQ(widget_at_screen_point, gfx::kNullAcceleratedWidget);
+
+  MockPlatformWindowDelegate delegate;
+  std::unique_ptr<WaylandWindow> menu_window =
+      CreateWaylandWindowWithProperties(
+          gfx::Rect(window_->GetBounds().width() - 10,
+                    window_->GetBounds().height() - 10, 100, 100),
+          PlatformWindowType::kPopup, window_->GetWidget(), &delegate);
+
+  Sync();
+
+  // Imagine the mouse enters a menu window, which is located on top of the main
+  // window, and gathers focus.
+  window_->set_pointer_focus(false);
+  menu_window->set_pointer_focus(true);
+  widget_at_screen_point =
+      platform_screen_->GetAcceleratedWidgetAtScreenPoint(gfx::Point(
+          menu_window->GetBounds().x() + 1, menu_window->GetBounds().y() + 1));
+  EXPECT_EQ(widget_at_screen_point, menu_window->GetWidget());
+
+  // Whenever a mouse pointer leaves the menu window, the accelerated widget
+  // of that focused window must be returned.
+  window_->set_pointer_focus(true);
+  menu_window->set_pointer_focus(false);
+  widget_at_screen_point =
+      platform_screen_->GetAcceleratedWidgetAtScreenPoint(gfx::Point(0, 0));
+  EXPECT_EQ(widget_at_screen_point, window_->GetWidget());
+
+  // Reset the focus to avoid crash on dtor as long as there is no real pointer
+  // object.
+  window_->set_pointer_focus(false);
+}
+
+TEST_P(WaylandScreenTest, GetDisplayMatching) {
+  TestDisplayObserver observer;
+  platform_screen_->AddObserver(&observer);
+
+  const display::Display primary_display =
+      platform_screen_->GetPrimaryDisplay();
+
+  wl::TestOutput* output2 = server_.CreateAndInitializeOutput();
+
+  Sync();
+
+  // Place it on the right side of the primary display.
+  const gfx::Rect output2_rect =
+      gfx::Rect(primary_display.bounds().width(), 0, 1024, 768);
+  UpdateOutputGeometry(output2->resource(), output2_rect);
+
+  Sync();
+
+  const display::Display second_display = observer.GetDisplay();
+  EXPECT_EQ(second_display.bounds(), output2_rect);
+
+  // We have two displays: display1(0:0,1024x768) and display2(1024:0,1024x768).
+  EXPECT_EQ(
+      primary_display.id(),
+      platform_screen_->GetDisplayMatching(gfx::Rect(0, 0, 100, 100)).id());
+  EXPECT_EQ(
+      second_display.id(),
+      platform_screen_->GetDisplayMatching(gfx::Rect(1024, 0, 10, 10)).id());
+
+  // More pixels on second display.
+  EXPECT_EQ(
+      second_display.id(),
+      platform_screen_->GetDisplayMatching(gfx::Rect(1020, 0, 10, 10)).id());
+
+  // More pixels on first display.
+  EXPECT_EQ(
+      primary_display.id(),
+      platform_screen_->GetDisplayMatching(gfx::Rect(1018, 0, 10, 10)).id());
+
+  // Half pixels on second and half on primary.
+  EXPECT_EQ(
+      primary_display.id(),
+      platform_screen_->GetDisplayMatching(gfx::Rect(1019, 0, 10, 10)).id());
+
+  // Place second display 700 pixels below along y axis (1024:700,1024x768)
+  UpdateOutputGeometry(
+      output2->resource(),
+      gfx::Rect(gfx::Point(output2_rect.x(), output2_rect.y() + 700),
+                output2_rect.size()));
+
+  Sync();
+
+  // The match rect is located outside the displays. Primary display must be
+  // returned.
+  EXPECT_EQ(
+      primary_display.id(),
+      platform_screen_->GetDisplayMatching(gfx::Rect(1024, 0, 10, 10)).id());
+
+  // At least some of the pixels are located on the display.
+  EXPECT_EQ(
+      primary_display.id(),
+      platform_screen_->GetDisplayMatching(gfx::Rect(1023, 0, 10, 10)).id());
+
+  // Most of pixels are located on second display.
+  EXPECT_EQ(
+      second_display.id(),
+      platform_screen_->GetDisplayMatching(gfx::Rect(1023, 695, 10, 10)).id());
+
+  // Empty rect results in primary display.
+  EXPECT_EQ(primary_display.id(),
+            platform_screen_->GetDisplayMatching(gfx::Rect(0, 0, 0, 0)).id());
+
+  platform_screen_->RemoveObserver(&observer);
+}
+
+TEST_P(WaylandScreenTest, GetDisplayForAcceleratedWidget) {
+  TestDisplayObserver observer;
+  platform_screen_->AddObserver(&observer);
+
+  const display::Display primary_display =
+      platform_screen_->GetPrimaryDisplay();
+
+  // Create an additional display.
+  wl::TestOutput* output2 = server_.CreateAndInitializeOutput();
+
+  Sync();
+
+  // Place it on the right side of the primary
+  // display.
+  const gfx::Rect output2_rect =
+      gfx::Rect(primary_display.bounds().width(), 0, 1024, 768);
+  UpdateOutputGeometry(output2->resource(), output2_rect);
+
+  Sync();
+
+  const display::Display secondary_display = observer.GetDisplay();
+  EXPECT_EQ(secondary_display.bounds(), output2_rect);
+
+  const gfx::AcceleratedWidget widget = window_->GetWidget();
+  // There must be a primary display used if the window has not received an
+  // enter event yet.
+  ValidateTheDisplayForWidget(widget, primary_display.id());
+
+  // Now, send enter event for the surface, which was created before.
+  wl::MockSurface* surface = server_.GetObject<wl::MockSurface>(widget);
+  ASSERT_TRUE(surface);
+  wl_surface_send_enter(surface->resource(), output_->resource());
+
+  Sync();
+
+  // The id of the entered display must correspond to the primary output.
+  ValidateTheDisplayForWidget(widget, primary_display.id());
+
+  Sync();
+
+  // Enter the second output now.
+  wl_surface_send_enter(surface->resource(), output2->resource());
+
+  Sync();
+
+  // The id of the entered display must still correspond to the primary output.
+  ValidateTheDisplayForWidget(widget, primary_display.id());
+
+  // Leave the first output.
+  wl_surface_send_leave(surface->resource(), output_->resource());
+
+  Sync();
+
+  // The id of the entered display must correspond to the second output.
+  ValidateTheDisplayForWidget(widget, secondary_display.id());
+
+  // Leaving the same output twice (check comment in
+  // WaylandWindow::RemoveEnteredOutputId), must be ok and nothing must change.
+  wl_surface_send_leave(surface->resource(), output_->resource());
+
+  Sync();
+
+  // The id of the entered display must correspond to the second output.
+  ValidateTheDisplayForWidget(widget, secondary_display.id());
+}
+
+TEST_P(WaylandScreenTest, GetCursorScreenPoint) {
+  MockPlatformWindowDelegate delegate;
+  std::unique_ptr<WaylandWindow> second_window =
+      CreateWaylandWindowWithProperties(gfx::Rect(0, 0, 1920, 1080),
+                                        PlatformWindowType::kWindow,
+                                        gfx::kNullAcceleratedWidget, &delegate);
+
+  auto* surface = server_.GetObject<wl::MockSurface>(window_->GetWidget());
+  ASSERT_TRUE(surface);
+
+  // Announce pointer capability so that WaylandPointer is created on the client
+  // side.
+  wl_seat_send_capabilities(server_.seat()->resource(),
+                            WL_SEAT_CAPABILITY_POINTER);
+
+  Sync();
+
+  wl::TestPointer* pointer = server_.seat()->pointer();
+  ASSERT_TRUE(pointer);
+
+  uint32_t serial = 0;
+  uint32_t time = 1002;
+  wl_pointer_send_enter(pointer->resource(), ++serial, surface->resource(), 0,
+                        0);
+  wl_pointer_send_motion(pointer->resource(), ++time, wl_fixed_from_int(10),
+                         wl_fixed_from_int(20));
+
+  Sync();
+
+  // WaylandScreen must return the last pointer location.
+  EXPECT_EQ(gfx::Point(10, 20), platform_screen_->GetCursorScreenPoint());
+
+  auto* second_surface =
+      server_.GetObject<wl::MockSurface>(second_window->GetWidget());
+  ASSERT_TRUE(second_surface);
+  // Now, leave the first surface and enter second one.
+  wl_pointer_send_leave(pointer->resource(), ++serial, surface->resource());
+  wl_pointer_send_enter(pointer->resource(), ++serial,
+                        second_surface->resource(), 0, 0);
+  wl_pointer_send_motion(pointer->resource(), ++time, wl_fixed_from_int(20),
+                         wl_fixed_from_int(10));
+
+  Sync();
+
+  // WaylandScreen must return the last pointer location.
+  EXPECT_EQ(gfx::Point(20, 10), platform_screen_->GetCursorScreenPoint());
+
+  // Clear pointer focus.
+  wl_pointer_send_leave(pointer->resource(), ++serial,
+                        second_surface->resource());
+
+  Sync();
+
+  // WaylandScreen must return a point, which is located outside of bounds of
+  // any window. Basically, it means that it takes the largest window and adds
+  // 10 pixels to its width and height, and returns the value.
+  const gfx::Rect second_window_bounds = second_window->GetBounds();
+  // A second window has largest bounds. Thus, these bounds must be taken as a
+  // ground for the point outside any of the surfaces.
+  ASSERT_TRUE(window_->GetBounds() < second_window_bounds);
+  EXPECT_EQ(gfx::Point(second_window_bounds.width() + 10,
+                       second_window_bounds.height() + 10),
+            platform_screen_->GetCursorScreenPoint());
+
+  // Create a menu window now and ensure cursor position is always sent in
+  // regards to that window bounds.
+  std::unique_ptr<WaylandWindow> menu_window =
+      CreateWaylandWindowWithProperties(
+          gfx::Rect(second_window_bounds.width() - 10,
+                    second_window_bounds.height() - 10, 10, 20),
+          PlatformWindowType::kPopup, second_window->GetWidget(), &delegate);
+
+  Sync();
+
+  auto* menu_surface =
+      server_.GetObject<wl::MockSurface>(menu_window->GetWidget());
+  ASSERT_TRUE(menu_surface);
+
+  wl_pointer_send_enter(pointer->resource(), ++serial, menu_surface->resource(),
+                        0, 0);
+  wl_pointer_send_motion(pointer->resource(), ++time, wl_fixed_from_int(2),
+                         wl_fixed_from_int(1));
+
+  Sync();
+
+  // The cursor screen point must be converted to the top-level window
+  // coordinates as long as Wayland doesn't provide global coordinates of
+  // surfaces and Chromium assumes those windows are always located at origin
+  // (0,0). For more information, check the comment in
+  // WaylandWindow::UpdateCursorPositionFromEvent.
+  EXPECT_EQ(gfx::Point(1912, 1071), platform_screen_->GetCursorScreenPoint());
+
+  // Leave the menu window and enter the top level window.
+  wl_pointer_send_leave(pointer->resource(), ++serial,
+                        menu_surface->resource());
+  wl_pointer_send_enter(pointer->resource(), ++serial,
+                        second_surface->resource(), 0, 0);
+  wl_pointer_send_motion(pointer->resource(), ++time, wl_fixed_from_int(1912),
+                         wl_fixed_from_int(1071));
+
+  Sync();
+
+  // WaylandWindow::UpdateCursorPositionFromEvent mustn't convert this point,
+  // because it has already been located on the top-level window.
+  EXPECT_EQ(gfx::Point(1912, 1071), platform_screen_->GetCursorScreenPoint());
+
+  wl_pointer_send_leave(pointer->resource(), ++serial,
+                        second_surface->resource());
+
+  // Now, create a nested menu window and make sure that the cursor screen point
+  // still has been correct. The location of the window is on the right side of
+  // the main menu window.
+  const gfx::Rect menu_window_bounds = menu_window->GetBounds();
+  std::unique_ptr<WaylandWindow> nested_menu_window =
+      CreateWaylandWindowWithProperties(
+          gfx::Rect(menu_window_bounds.x() + menu_window_bounds.width(),
+                    menu_window_bounds.y() + 2, 10, 20),
+          PlatformWindowType::kPopup, second_window->GetWidget(), &delegate);
+
+  Sync();
+
+  auto* nested_menu_surface =
+      server_.GetObject<wl::MockSurface>(nested_menu_window->GetWidget());
+  ASSERT_TRUE(nested_menu_surface);
+
+  wl_pointer_send_enter(pointer->resource(), ++serial,
+                        nested_menu_surface->resource(), 0, 0);
+  wl_pointer_send_motion(pointer->resource(), ++time, wl_fixed_from_int(2),
+                         wl_fixed_from_int(3));
+
+  Sync();
+
+  EXPECT_EQ(gfx::Point(1922, 1075), platform_screen_->GetCursorScreenPoint());
+
+  // Leave the nested surface and enter main menu surface. The cursor screen
+  // point still must be reported correctly.
+  wl_pointer_send_leave(pointer->resource(), ++serial,
+                        nested_menu_surface->resource());
+  wl_pointer_send_enter(pointer->resource(), ++serial, menu_surface->resource(),
+                        0, 0);
+  wl_pointer_send_motion(pointer->resource(), ++time, wl_fixed_from_int(2),
+                         wl_fixed_from_int(1));
+
+  Sync();
+
+  EXPECT_EQ(gfx::Point(1912, 1071), platform_screen_->GetCursorScreenPoint());
 }
 
 INSTANTIATE_TEST_CASE_P(XdgVersionV5Test,
--- a/ui/ozone/platform/wayland/wayland_window.cc	2019-02-14 01:14:42.000000000 +0300
+++ b/ui/ozone/platform/wayland/wayland_window.cc	2019-02-20 20:48:24.076000000 +0300
@@ -4,6 +4,8 @@
 
 #include "ui/ozone/platform/wayland/wayland_window.h"
 
+#include <memory>
+
 #include <wayland-client.h>
 
 #include "base/bind.h"
@@ -16,6 +18,8 @@
 #include "ui/events/ozone/events_ozone.h"
 #include "ui/gfx/geometry/point_f.h"
 #include "ui/ozone/platform/wayland/wayland_connection.h"
+#include "ui/ozone/platform/wayland/wayland_cursor_position.h"
+#include "ui/ozone/platform/wayland/wayland_output_manager.h"
 #include "ui/ozone/platform/wayland/wayland_pointer.h"
 #include "ui/ozone/platform/wayland/xdg_popup_wrapper_v5.h"
 #include "ui/ozone/platform/wayland/xdg_popup_wrapper_v6.h"
@@ -92,7 +96,7 @@
   }
 
   PlatformEventSource::GetInstance()->RemovePlatformEventDispatcher(this);
-  connection_->RemoveWindow(surface_.id());
+  connection_->RemoveWindow(GetWidget());
 
   if (parent_window_)
     parent_window_->set_child_window(nullptr);
@@ -111,7 +115,6 @@
   DCHECK(xdg_shell_objects_factory_);
 
   bounds_ = properties.bounds;
-  parent_window_ = GetParentWindow(properties.parent_widget);
 
   surface_.reset(wl_compositor_create_surface(connection_->compositor()));
   if (!surface_) {
@@ -119,11 +122,14 @@
     return false;
   }
   wl_surface_set_user_data(surface_.get(), this);
+  AddSurfaceListener();
 
   ui::PlatformWindowType ui_window_type = properties.type;
   switch (ui_window_type) {
     case ui::PlatformWindowType::kMenu:
     case ui::PlatformWindowType::kPopup:
+      parent_window_ = GetParentWindow(properties.parent_widget);
+
       // TODO(msisov, jkim): Handle notification windows, which are marked
       // as popup windows as well. Those are the windows that do not have
       // parents and pop up when the browser receives a notification.
@@ -140,13 +146,23 @@
 
   connection_->ScheduleFlush();
 
-  connection_->AddWindow(surface_.id(), this);
+  connection_->AddWindow(GetWidget(), this);
   PlatformEventSource::GetInstance()->AddPlatformEventDispatcher(this);
-  delegate_->OnAcceleratedWidgetAvailable(surface_.id());
+  delegate_->OnAcceleratedWidgetAvailable(GetWidget());
 
   return true;
 }
 
+gfx::AcceleratedWidget WaylandWindow::GetWidget() const {
+  if (!surface_)
+    return gfx::kNullAcceleratedWidget;
+  return surface_.id();
+}
+
+std::set<uint32_t> WaylandWindow::GetEnteredOutputsIds() const {
+  return entered_outputs_ids_;
+}
+
 void WaylandWindow::CreateXdgPopup() {
   if (bounds_.IsEmpty())
     return;
@@ -466,6 +482,12 @@
 
 uint32_t WaylandWindow::DispatchEvent(const PlatformEvent& native_event) {
   Event* event = static_cast<Event*>(native_event);
+
+  if (event->IsLocatedEvent()) {
+    auto copied_event = Event::Clone(*event);
+    UpdateCursorPositionFromEvent(std::move(copied_event));
+  }
+
   // If the window does not have a pointer focus, but received this event, it
   // means the window is a popup window with a child popup window. In this case,
   // the location of the event must be converted from the nested popup to the
@@ -637,4 +659,97 @@
   return static_cast<WmMoveResizeHandler*>(this);
 }
 
+void WaylandWindow::AddSurfaceListener() {
+  static struct wl_surface_listener surface_listener = {
+      &WaylandWindow::Enter,
+      &WaylandWindow::Leave,
+  };
+  wl_surface_add_listener(surface_.get(), &surface_listener, this);
+}
+
+void WaylandWindow::AddEnteredOutputId(struct wl_output* output) {
+  const uint32_t entered_output_id =
+      connection_->wayland_output_manager()->GetIdForOutput(output);
+  DCHECK_NE(entered_output_id, 0u);
+  auto entered_output_id_it = entered_outputs_ids_.insert(entered_output_id);
+  DCHECK(entered_output_id_it.second);
+}
+
+void WaylandWindow::RemoveEnteredOutputId(struct wl_output* output) {
+  const uint32_t left_output_id =
+      connection_->wayland_output_manager()->GetIdForOutput(output);
+  auto entered_output_id_it = entered_outputs_ids_.find(left_output_id);
+  // Workaround: when a user switches physical output between two displays,
+  // a window does not necessarily receive enter events immediately or until
+  // a user resizes/moves the window. It means that switching output between
+  // displays in a single output mode results in leave events, but the surface
+  // might not have received enter event before. Thus, remove the id of left
+  // output only if it was stored before.
+  if (entered_output_id_it != entered_outputs_ids_.end())
+    entered_outputs_ids_.erase(entered_output_id_it);
+}
+
+void WaylandWindow::UpdateCursorPositionFromEvent(
+    std::unique_ptr<Event> event) {
+  DCHECK(event->IsLocatedEvent());
+  auto* window = connection_->GetCurrentFocusedWindow();
+  // This is a tricky part. Initially, Wayland sends events to surfaces the
+  // events are targeted for. But, in order to fulfill Chromium's assumptions
+  // about event targets, some of the events are rerouted and their locations
+  // are converted.
+  //
+  // The event we got here is rerouted, but it hasn't had its location fixed
+  // yet. Passing an event with fixed location won't help as well - its location
+  // is converted in a different way: if mouse is moved outside a menu window
+  // to the left, the location of such event includes negative values.
+  //
+  // In contrast, this method must translate coordinates of all events
+  // in regards to top-level windows' coordinates as it's always located at
+  // origin (0,0) from Chromium point of view (remember that Wayland doesn't
+  // provide global coordinates to its clients). And it's totally fine to use it
+  // as the target. Thus, the location of the |event| is always converted using
+  // the top-level window's bounds as the target excluding cases, when the
+  // mouse/touch is over a top-level window.
+  if (parent_window_ && parent_window_ != window) {
+    const gfx::Rect target_bounds = parent_window_->GetBounds();
+    gfx::Rect own_bounds = GetBounds();
+    // This is a bit trickier, and concerns nested menu windows. Whenever an
+    // event is sent to the nested menu window, it's rerouted to a parent menu
+    // window. Thus, in order to correctly translate its location, we must
+    // choose correct values for the |own_bounds|. In this case, it must the
+    // nested menu window, because |this| is the parent of that window.
+    if (window == child_window_)
+      own_bounds = child_window_->GetBounds();
+    ConvertEventLocationToTargetWindowLocation(
+        target_bounds.origin(), own_bounds.origin(), event->AsLocatedEvent());
+  }
+  auto* cursor_position = connection_->wayland_cursor_position();
+  if (cursor_position) {
+    cursor_position->OnCursorPositionChanged(
+        event->AsLocatedEvent()->location());
+  }
+}
+
+// static
+void WaylandWindow::Enter(void* data,
+                          struct wl_surface* wl_surface,
+                          struct wl_output* output) {
+  auto* window = static_cast<WaylandWindow*>(data);
+  if (window) {
+    DCHECK(window->surface_.get() == wl_surface);
+    window->AddEnteredOutputId(output);
+  }
+}
+
+// static
+void WaylandWindow::Leave(void* data,
+                          struct wl_surface* wl_surface,
+                          struct wl_output* output) {
+  auto* window = static_cast<WaylandWindow*>(data);
+  if (window) {
+    DCHECK(window->surface_.get() == wl_surface);
+    window->RemoveEnteredOutputId(output);
+  }
+}
+
 }  // namespace ui
--- a/ui/ozone/platform/wayland/wayland_window.h	2019-02-14 01:14:42.000000000 +0300
+++ b/ui/ozone/platform/wayland/wayland_window.h	2019-02-20 20:48:24.076000000 +0300
@@ -5,6 +5,9 @@
 #ifndef UI_OZONE_PLATFORM_WAYLAND_WAYLAND_WINDOW_H_
 #define UI_OZONE_PLATFORM_WAYLAND_WAYLAND_WINDOW_H_
 
+#include <set>
+#include <vector>
+
 #include "base/callback.h"
 #include "base/memory/ref_counted.h"
 #include "ui/events/platform/platform_event_dispatcher.h"
@@ -52,6 +55,15 @@
   XDGSurfaceWrapper* xdg_surface() const { return xdg_surface_.get(); }
   XDGPopupWrapper* xdg_popup() const { return xdg_popup_.get(); }
 
+  gfx::AcceleratedWidget GetWidget() const;
+
+  // Returns the list of wl_outputs aka displays, which this window occupies.
+  // The window can be shown on one or more displays at the same time. An empty
+  // vector can also be returned if the window is not configured on the
+  // compositor side or it has been moved due to unplug action (check the
+  // comment in RemoveEnteredOutputId).
+  std::set<uint32_t> GetEnteredOutputsIds() const;
+
   // Apply the bounds specified in the most recent configure event. This should
   // be called after processing all pending events in the wayland connection.
   void ApplyPendingBounds();
@@ -152,6 +164,22 @@
 
   WmMoveResizeHandler* AsWmMoveResizeHandler();
 
+  // Install a surface listener and start getting wl_output enter/leave events.
+  void AddSurfaceListener();
+
+  void AddEnteredOutputId(struct wl_output* output);
+  void RemoveEnteredOutputId(struct wl_output* output);
+
+  void UpdateCursorPositionFromEvent(std::unique_ptr<Event> event);
+
+  // wl_surface_listener
+  static void Enter(void* data,
+                    struct wl_surface* wl_surface,
+                    struct wl_output* output);
+  static void Leave(void* data,
+                    struct wl_surface* wl_surface,
+                    struct wl_output* output);
+
   PlatformWindowDelegate* delegate_;
   WaylandConnection* connection_;
   WaylandWindow* parent_window_ = nullptr;
@@ -193,6 +221,9 @@
 
   bool is_tooltip_ = false;
 
+  // Stores the list of entered outputs that the window is currently in.
+  std::set<uint32_t> entered_outputs_ids_;
+
   DISALLOW_COPY_AND_ASSIGN(WaylandWindow);
 };
 
--- a/ui/ozone/public/ozone_platform.cc	2019-02-14 01:14:42.000000000 +0300
+++ b/ui/ozone/public/ozone_platform.cc	2019-02-20 20:48:24.084000000 +0300
@@ -122,6 +122,11 @@
   return nullptr;
 }
 
+PlatformClipboard* OzonePlatform::GetPlatformClipboard() {
+  // Platforms that support system clipboard must override this method.
+  return nullptr;
+}
+
 bool OzonePlatform::IsNativePixmapConfigSupported(
     gfx::BufferFormat format,
     gfx::BufferUsage usage) const {
--- a/ui/ozone/public/ozone_platform.h	2019-02-14 01:14:42.000000000 +0300
+++ b/ui/ozone/public/ozone_platform.h	2019-02-20 20:48:24.084000000 +0300
@@ -40,6 +40,7 @@
 class PlatformWindowDelegate;
 class SurfaceFactoryOzone;
 class SystemInputInjector;
+class PlatformClipboard;
 
 struct PlatformWindowInitProperties;
 
@@ -148,6 +149,7 @@
   virtual std::unique_ptr<display::NativeDisplayDelegate>
   CreateNativeDisplayDelegate() = 0;
   virtual std::unique_ptr<PlatformScreen> CreateScreen();
+  virtual PlatformClipboard* GetPlatformClipboard();
 
   // Returns true if the specified buffer format is supported.
   virtual bool IsNativePixmapConfigSupported(gfx::BufferFormat format,
--- a/ui/views/BUILD.gn	2019-02-14 01:14:42.000000000 +0300
+++ b/ui/views/BUILD.gn	2019-02-20 20:48:24.136000000 +0300
@@ -498,6 +498,7 @@
     "//skia",
     "//third_party/icu",
     "//ui/accessibility",
+    "//ui/base/clipboard",
     "//ui/display",
     "//ui/native_theme",
     "//ui/native_theme:native_theme_browser",
@@ -513,6 +514,7 @@
     "//components/vector_icons",
     "//ui/accessibility:ax_enums_mojo",
     "//ui/base",
+    "//ui/base/clipboard",
     "//ui/base/ime",
     "//ui/compositor",
     "//ui/display",
@@ -882,6 +884,7 @@
     "//testing/gtest",
     "//ui/base",
     "//ui/base:test_support",
+    "//ui/base/clipboard:clipboard_test_support",
     "//ui/base/ime",
     "//ui/compositor",
     "//ui/compositor:test_support",
@@ -1063,6 +1066,7 @@
     "//ui/accessibility",
     "//ui/base",
     "//ui/base:test_support",
+    "//ui/base/clipboard",
     "//ui/base/ime",
     "//ui/compositor:test_support",
     "//ui/events:dom_keycode_converter",
--- a/ui/views/cocoa/drag_drop_client_mac_unittest.mm	2019-02-14 01:14:42.000000000 +0300
+++ b/ui/views/cocoa/drag_drop_client_mac_unittest.mm	2019-02-20 20:48:24.152000000 +0300
@@ -130,7 +130,7 @@
   // View:
   bool GetDropFormats(
       int* formats,
-      std::set<ui::Clipboard::FormatType>* format_types) override {
+      std::set<ui::ClipboardFormatType>* format_types) override {
     *formats |= formats_;
     return true;
   }
--- a/ui/views/controls/menu/menu_controller.cc	2019-02-14 01:14:42.000000000 +0300
+++ b/ui/views/controls/menu/menu_controller.cc	2019-02-20 20:48:24.164000000 +0300
@@ -921,7 +921,7 @@
 bool MenuController::GetDropFormats(
     SubmenuView* source,
     int* formats,
-    std::set<ui::Clipboard::FormatType>* format_types) {
+    std::set<ui::ClipboardFormatType>* format_types) {
   return source->GetMenuItem()->GetDelegate()->GetDropFormats(
       source->GetMenuItem(), formats, format_types);
 }
--- a/ui/views/controls/menu/menu_controller.h	2019-02-14 01:14:42.000000000 +0300
+++ b/ui/views/controls/menu/menu_controller.h	2019-02-20 20:48:24.164000000 +0300
@@ -164,7 +164,7 @@
 
   bool GetDropFormats(SubmenuView* source,
                       int* formats,
-                      std::set<ui::Clipboard::FormatType>* format_types);
+                      std::set<ui::ClipboardFormatType>* format_types);
   bool AreDropTypesRequired(SubmenuView* source);
   bool CanDrop(SubmenuView* source, const ui::OSExchangeData& data);
   void OnDragEntered(SubmenuView* source, const ui::DropTargetEvent& event);
--- a/ui/views/controls/menu/menu_delegate.cc	2019-02-14 01:14:42.000000000 +0300
+++ b/ui/views/controls/menu/menu_delegate.cc	2019-02-20 20:48:24.164000000 +0300
@@ -81,7 +81,7 @@
 bool MenuDelegate::GetDropFormats(
     MenuItemView* menu,
     int* formats,
-    std::set<ui::Clipboard::FormatType>* format_types) {
+    std::set<ui::ClipboardFormatType>* format_types) {
   return false;
 }
 
--- a/ui/views/controls/menu/menu_delegate.h	2019-02-14 01:14:42.000000000 +0300
+++ b/ui/views/controls/menu/menu_delegate.h	2019-02-20 20:48:24.164000000 +0300
@@ -150,10 +150,9 @@
   virtual bool CanDrop(MenuItemView* menu, const OSExchangeData& data);
 
   // See view for a description of this method.
-  virtual bool GetDropFormats(
-      MenuItemView* menu,
+  virtual bool GetDropFormats(MenuItemView* menu,
       int* formats,
-      std::set<ui::Clipboard::FormatType>* format_types);
+                              std::set<ui::ClipboardFormatType>* format_types);
 
   // See view for a description of this method.
   virtual bool AreDropTypesRequired(MenuItemView* menu);
--- a/ui/views/controls/menu/submenu_view.cc	2019-02-14 01:14:42.000000000 +0300
+++ b/ui/views/controls/menu/submenu_view.cc	2019-02-20 20:48:24.168000000 +0300
@@ -241,7 +241,7 @@
 
 bool SubmenuView::GetDropFormats(
     int* formats,
-    std::set<ui::Clipboard::FormatType>* format_types) {
+    std::set<ui::ClipboardFormatType>* format_types) {
   DCHECK(GetMenuItem()->GetMenuController());
   return GetMenuItem()->GetMenuController()->GetDropFormats(this, formats,
                                                             format_types);
--- a/ui/views/controls/menu/submenu_view.h	2019-02-14 01:14:42.000000000 +0300
+++ b/ui/views/controls/menu/submenu_view.h	2019-02-20 20:48:24.168000000 +0300
@@ -78,9 +78,8 @@
   void PaintChildren(const PaintInfo& paint_info) override;
 
   // Drag and drop methods. These are forwarded to the MenuController.
-  bool GetDropFormats(
-      int* formats,
-      std::set<ui::Clipboard::FormatType>* format_types) override;
+  bool GetDropFormats(int* formats,
+                      std::set<ui::ClipboardFormatType>* format_types) override;
   bool AreDropTypesRequired() override;
   bool CanDrop(const OSExchangeData& data) override;
   void OnDragEntered(const ui::DropTargetEvent& event) override;
--- a/ui/views/controls/textfield/textfield.cc	2019-02-14 01:14:42.000000000 +0300
+++ b/ui/views/controls/textfield/textfield.cc	2019-02-20 20:48:24.180000000 +0300
@@ -914,7 +914,7 @@
 
 bool Textfield::GetDropFormats(
     int* formats,
-    std::set<ui::Clipboard::FormatType>* format_types) {
+    std::set<ui::ClipboardFormatType>* format_types) {
   if (!enabled() || read_only())
     return false;
   // TODO(msw): Can we support URL, FILENAME, etc.?
@@ -926,7 +926,7 @@
 
 bool Textfield::CanDrop(const OSExchangeData& data) {
   int formats;
-  std::set<ui::Clipboard::FormatType> format_types;
+  std::set<ui::ClipboardFormatType> format_types;
   GetDropFormats(&formats, &format_types);
   return enabled() && !read_only() && data.HasAnyFormat(formats, format_types);
 }
--- a/ui/views/controls/textfield/textfield_controller.h	2019-02-14 01:14:42.000000000 +0300
+++ b/ui/views/controls/textfield/textfield_controller.h	2019-02-20 20:48:24.180000000 +0300
@@ -8,6 +8,8 @@
 #include <set>
 
 #include "base/strings/string16.h"
+#include "ui/base/clipboard/clipboard_format_type.h"
+#include "ui/base/clipboard/clipboard_types.h"
 #include "ui/base/dragdrop/os_exchange_data.h"
 #include "ui/views/views_export.h"
 
@@ -76,7 +78,7 @@
   // Enables the controller to append to the accepted drop formats.
   virtual void AppendDropFormats(
       int* formats,
-      std::set<ui::Clipboard::FormatType>* format_types) {}
+      std::set<ui::ClipboardFormatType>* format_types) {}
 
   // Called when a drop of dragged data happens on the textfield. This method is
   // called before regular handling of the drop. If this returns a drag
--- a/ui/views/controls/textfield/textfield.h	2019-02-14 01:14:42.000000000 +0300
+++ b/ui/views/controls/textfield/textfield.h	2019-02-20 20:48:24.180000000 +0300
@@ -264,9 +264,8 @@
   bool CanHandleAccelerators() const override;
   void AboutToRequestFocusFromTabTraversal(bool reverse) override;
   bool SkipDefaultKeyEventProcessing(const ui::KeyEvent& event) override;
-  bool GetDropFormats(
-      int* formats,
-      std::set<ui::Clipboard::FormatType>* format_types) override;
+  bool GetDropFormats(int* formats,
+                      std::set<ui::ClipboardFormatType>* format_types) override;
   bool CanDrop(const ui::OSExchangeData& data) override;
   int OnDragUpdated(const ui::DropTargetEvent& event) override;
   void OnDragExited() override;
--- a/ui/views/controls/textfield/textfield_unittest.cc	2019-02-14 01:14:42.000000000 +0300
+++ b/ui/views/controls/textfield/textfield_unittest.cc	2019-02-20 20:48:24.184000000 +0300
@@ -1705,7 +1705,7 @@
   base::string16 string(ASCIIToUTF16("string "));
   data.SetString(string);
   int formats = 0;
-  std::set<ui::Clipboard::FormatType> format_types;
+  std::set<ui::ClipboardFormatType> format_types;
 
   // Ensure that disabled textfields do not accept drops.
   textfield_->SetEnabled(false);
@@ -1739,7 +1739,7 @@
   // Ensure that textfields do not accept non-OSExchangeData::STRING types.
   ui::OSExchangeData bad_data;
   bad_data.SetFilename(base::FilePath(FILE_PATH_LITERAL("x")));
-  ui::Clipboard::FormatType fmt = ui::Clipboard::GetBitmapFormatType();
+  ui::ClipboardFormatType fmt = ui::ClipboardFormatType::GetBitmapType();
   bad_data.SetPickledData(fmt, base::Pickle());
   bad_data.SetFileContents(base::FilePath(L"x"), "x");
   bad_data.SetHtml(base::string16(ASCIIToUTF16("x")), GURL("x.org"));
@@ -1803,7 +1803,7 @@
   ui::OSExchangeData data;
   int formats = 0;
   int operations = 0;
-  std::set<ui::Clipboard::FormatType> format_types;
+  std::set<ui::ClipboardFormatType> format_types;
 
   // Start dragging "ello".
   textfield_->SelectRange(gfx::Range(1, 5));
@@ -1854,7 +1854,7 @@
   ui::OSExchangeData data;
   int formats = 0;
   int operations = 0;
-  std::set<ui::Clipboard::FormatType> format_types;
+  std::set<ui::ClipboardFormatType> format_types;
 
   // Start dragging " worl".
   textfield_->SelectRange(gfx::Range(5, 10));
--- a/ui/views/mus/drag_interactive_uitest.cc	2019-02-14 01:14:42.000000000 +0300
+++ b/ui/views/mus/drag_interactive_uitest.cc	2019-02-20 20:48:24.204000000 +0300
@@ -60,7 +60,7 @@
   // views::View overrides:
   bool GetDropFormats(
       int* formats,
-      std::set<ui::Clipboard::FormatType>* format_types) override {
+      std::set<ui::ClipboardFormatType>* format_types) override {
     *formats = ui::OSExchangeData::STRING;
     return true;
   }
--- a/ui/views/test/scoped_views_test_helper.cc	2019-02-14 01:14:42.000000000 +0300
+++ b/ui/views/test/scoped_views_test_helper.cc	2019-02-20 20:48:24.224000000 +0300
@@ -8,8 +8,8 @@
 
 #include "base/memory/ptr_util.h"
 #include "ui/base/clipboard/clipboard.h"
+#include "ui/base/clipboard/test/test_clipboard.h"
 #include "ui/base/ime/input_method_initializer.h"
-#include "ui/base/test/test_clipboard.h"
 #include "ui/views/test/platform_test_helper.h"
 #include "ui/views/test/test_views_delegate.h"
 #include "ui/views/test/views_test_helper.h"
--- a/ui/views/view.cc	2019-02-14 01:14:42.000000000 +0300
+++ b/ui/views/view.cc	2019-02-20 20:48:24.232000000 +0300
@@ -1360,7 +1360,7 @@
 // Drag and drop ---------------------------------------------------------------
 
 bool View::GetDropFormats(int* formats,
-                          std::set<ui::Clipboard::FormatType>* format_types) {
+                          std::set<ui::ClipboardFormatType>* format_types) {
   return false;
 }
 
--- a/ui/views/view.h	2019-02-14 01:14:42.000000000 +0300
+++ b/ui/views/view.h	2019-02-20 20:48:24.232000000 +0300
@@ -23,6 +23,7 @@
 #include "ui/accessibility/ax_enums.mojom.h"
 #include "ui/base/accelerators/accelerator.h"
 #include "ui/base/class_property.h"
+#include "ui/base/clipboard/clipboard_format_type.h"
 #include "ui/base/dragdrop/drag_drop_types.h"
 #include "ui/base/dragdrop/drop_target_event.h"
 #include "ui/base/dragdrop/os_exchange_data.h"
@@ -1064,9 +1065,8 @@
   // |formats| is a bitmask of the formats defined bye OSExchangeData::Format.
   // The default implementation returns false, which means the view doesn't
   // support dropping.
-  virtual bool GetDropFormats(
-      int* formats,
-      std::set<ui::Clipboard::FormatType>* format_types);
+  virtual bool GetDropFormats(int* formats,
+                              std::set<ui::ClipboardFormatType>* format_types);
 
   // Override and return true if the data must be available before any drop
   // methods should be invoked. The default is false.
--- a/ui/views/widget/desktop_aura/desktop_drag_drop_client_aurax11.cc	2019-02-14 01:14:42.000000000 +0300
+++ b/ui/views/widget/desktop_aura/desktop_drag_drop_client_aurax11.cc	2019-02-20 20:48:24.236000000 +0300
@@ -17,7 +17,7 @@
 #include "ui/aura/client/drag_drop_delegate.h"
 #include "ui/aura/window.h"
 #include "ui/aura/window_tree_host.h"
-#include "ui/base/clipboard/clipboard.h"
+#include "ui/base/clipboard/clipboard_constants.h"
 #include "ui/base/dragdrop/drop_target_event.h"
 #include "ui/base/dragdrop/os_exchange_data.h"
 #include "ui/base/dragdrop/os_exchange_data_provider_aurax11.h"
@@ -774,7 +774,7 @@
     actions.push_back(gfx::GetAtom(kXdndActionDirectSave));
     ui::SetStringProperty(
         xwindow_, gfx::GetAtom(kXdndDirectSave0),
-        gfx::GetAtom(ui::Clipboard::kMimeTypeText),
+        gfx::GetAtom(ui::kMimeTypeText),
         source_provider_->file_contents_name().AsUTF8Unsafe());
   }
   ui::SetAtomArrayProperty(xwindow_, kXdndActionList, "ATOM", actions);
--- a/ui/views/widget/drop_helper.cc	2019-02-14 01:14:42.000000000 +0300
+++ b/ui/views/widget/drop_helper.cc	2019-02-20 20:48:24.244000000 +0300
@@ -102,7 +102,7 @@
   }
 #else
   int formats = 0;
-  std::set<ui::Clipboard::FormatType> format_types;
+  std::set<ui::ClipboardFormatType> format_types;
   while (view && view != target_view_) {
     if (view->enabled() &&
         view->GetDropFormats(&formats, &format_types) &&
--- a/ui/wm/core/accelerator_filter.cc	2019-02-14 01:14:42.000000000 +0300
+++ b/ui/wm/core/accelerator_filter.cc	2019-02-20 20:48:24.320000000 +0300
@@ -28,29 +28,16 @@
 AcceleratorFilter::~AcceleratorFilter() {
 }
 
-bool AcceleratorFilter::ShouldFilter(ui::KeyEvent* event) {
-  const ui::EventType type = event->type();
-  if (!event->target() ||
-      (type != ui::ET_KEY_PRESSED && type != ui::ET_KEY_RELEASED) ||
-      event->is_char() || !event->target() ||
-      // Key events with key code of VKEY_PROCESSKEY, usually created by virtual
-      // keyboard (like handwriting input), have no effect on accelerator and
-      // they may disturb the accelerator history. So filter them out. (see
-      // https://crbug.com/918317)
-      event->key_code() == ui::VKEY_PROCESSKEY) {
-    return true;
-  }
-
-  return false;
-}
-
 ////////////////////////////////////////////////////////////////////////////////
 // AcceleratorFilter, EventFilter implementation:
 
 void AcceleratorFilter::OnKeyEvent(ui::KeyEvent* event) {
+  const ui::EventType type = event->type();
   DCHECK(event->target());
-  if (ShouldFilter(event))
+  if ((type != ui::ET_KEY_PRESSED && type != ui::ET_KEY_RELEASED) ||
+      event->is_char() || !event->target()) {
     return;
+  }
 
   ui::Accelerator accelerator(*event);
   accelerator_history_->StoreCurrentAccelerator(accelerator);
--- a/ui/wm/core/accelerator_filter.h	2019-02-14 01:14:42.000000000 +0300
+++ b/ui/wm/core/accelerator_filter.h	2019-02-20 20:48:24.320000000 +0300
@@ -28,9 +28,6 @@
                     ui::AcceleratorHistory* accelerator_history);
   ~AcceleratorFilter() override;
 
-  // If the return value is true, |event| should be filtered out.
-  static bool ShouldFilter(ui::KeyEvent* event);
-
   // Overridden from ui::EventHandler:
   void OnKeyEvent(ui::KeyEvent* event) override;
   void OnMouseEvent(ui::MouseEvent* event) override;
--- a/ui/base/clipboard/BUILD.gn	1970-01-01 03:00:00.000000000 +0300
+++ b/ui/base/clipboard/BUILD.gn	2019-02-20 20:48:23.468000000 +0300
@@ -0,0 +1,177 @@
+# Copyright 2019 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+import("//build/config/jumbo.gni")
+import("//build/config/ui.gni")
+
+jumbo_component("clipboard_types") {
+  output_name = "ui_base_clipboard_types"
+  sources = [
+    "clipboard_constants.cc",
+    "clipboard_constants.h",
+    "clipboard_constants_mac.mm",
+    "clipboard_format_type_android.cc",
+    "clipboard_format_type_mac.mm",
+    "clipboard_format_type_win.cc",
+    "clipboard_types.h",
+  ]
+
+  if (!is_ios) {
+    if (use_aura) {
+      if ((use_x11 && is_desktop_linux) || !is_win) {
+        sources += [ "clipboard_format_type_aura.cc" ]
+      }
+    }
+
+    sources += [ "clipboard_format_type.h" ]
+  }
+
+  defines = [ "IS_BASE_CLIPBOARD_TYPES_IMPL" ]
+
+  deps = [
+    "//base",
+  ]
+
+  libs = []
+  if (is_mac) {
+    libs += [
+      "AppKit.framework",
+      "CoreFoundation.framework",
+    ]
+  }
+}
+
+jumbo_component("clipboard") {
+  output_name = "ui_base_clipboard"
+
+  sources = [
+    "clipboard.cc",
+    "clipboard.h",
+    "clipboard_android.cc",
+    "clipboard_android.h",
+    "clipboard_mac.h",
+    "clipboard_mac.mm",
+    "clipboard_monitor.cc",
+    "clipboard_monitor.h",
+    "clipboard_observer.h",
+    "clipboard_util_mac.h",
+    "clipboard_util_mac.mm",
+    "clipboard_util_win.cc",
+    "clipboard_util_win.h",
+    "clipboard_win.cc",
+    "clipboard_win.h",
+    "custom_data_helper.cc",
+    "custom_data_helper.h",
+    "scoped_clipboard_writer.cc",
+    "scoped_clipboard_writer.h",
+  ]
+
+  defines = [ "IS_BASE_CLIPBOARD_IMPL" ]
+
+  deps = [
+    "//base",
+    "//net",
+    "//skia",
+    "//ui/events/platform",
+    "//ui/gfx",
+    "//ui/gfx/geometry",
+  ]
+
+  public_deps = [
+    ":clipboard_types",
+  ]
+
+  if (use_aura) {
+    # Aura clipboard.
+    # Chromecast uses clipboard_aura now.
+    if (is_desktop_linux && !is_chromecast) {
+      if (use_ozone) {
+        sources += [
+          "clipboard_ozone.cc",
+          "clipboard_ozone.h",
+        ]
+      } else if (use_x11) {
+        sources += [
+          "clipboard_aurax11.cc",
+          "clipboard_aurax11.h",
+        ]
+        configs += [ "//build/config/linux:x11" ]
+        deps += [
+          "//ui/base",
+          "//ui/base/x",
+          "//ui/gfx/x",
+        ]
+      }
+    } else if (!is_win) {
+      # This file is used for all non-X11, non-Windows aura Builds.
+      sources += [
+        "clipboard_aura.cc",
+        "clipboard_aura.h",
+      ]
+    }
+  }
+
+  if (is_android) {
+    deps += [ "//ui/base:ui_base_jni_headers" ]
+  }
+
+  if (is_mac) {
+    deps += [ "//third_party/mozilla" ]
+    libs = [
+      "AppKit.framework",
+      "CoreFoundation.framework",
+    ]
+  }
+
+  if (use_ozone) {
+    deps += [ "//ui/ozone" ]
+  }
+}
+
+jumbo_source_set("clipboard_test_support") {
+  testonly = true
+
+  if (!is_ios) {
+    sources = [
+      "test/test_clipboard.cc",
+      "test/test_clipboard.h",
+    ]
+  }
+
+  public_deps = [
+    ":clipboard",
+    "//base",
+    "//skia",
+  ]
+}
+
+source_set("clipboard_test") {
+  testonly = true
+
+  output_name = "ui_base_clipboard_test"
+  sources = [
+    "clipboard_mac_unittest.mm",
+    "clipboard_util_mac_unittest.mm",
+  ]
+
+  if (!is_ios) {
+    sources += [
+      "custom_data_helper_unittest.cc",
+      "test/test_clipboard_unittest.cc",
+    ]
+  }
+
+  deps = [
+    ":clipboard_test_support",
+    "//base/test:test_support",
+    "//testing/gmock",
+    "//testing/gtest",
+    "//ui/events/platform",
+    "//ui/gfx:test_support",
+  ]
+
+  if (is_mac) {
+    deps += [ "//third_party/mozilla" ]
+  }
+}
--- a/ui/base/clipboard/clipboard_constants.h	1970-01-01 03:00:00.000000000 +0300
+++ b/ui/base/clipboard/clipboard_constants.h	2019-02-20 20:48:23.468000000 +0300
@@ -0,0 +1,45 @@
+// Copyright 2019 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_BASE_CLIPBOARD_CLIPBOARD_CONSTANTS_H_
+#define UI_BASE_CLIPBOARD_CLIPBOARD_CONSTANTS_H_
+
+#include <string>
+
+#include "base/component_export.h"
+#include "build/build_config.h"
+
+#if defined(OS_MACOSX)
+#ifdef __OBJC__
+@class NSString;
+#else
+class NSString;
+#endif
+#endif  // defined(OS_MACOSX)
+
+namespace ui {
+
+#if defined(OS_MACOSX) && !defined(USE_AURA)
+COMPONENT_EXPORT(BASE_CLIPBOARD_TYPES)
+extern NSString* const kWebCustomDataPboardType;
+#endif
+
+// MIME type constants.
+COMPONENT_EXPORT(BASE_CLIPBOARD_TYPES) extern const char kMimeTypeText[];
+COMPONENT_EXPORT(BASE_CLIPBOARD_TYPES) extern const char kMimeTypeURIList[];
+COMPONENT_EXPORT(BASE_CLIPBOARD_TYPES) extern const char kMimeTypeDownloadURL[];
+COMPONENT_EXPORT(BASE_CLIPBOARD_TYPES) extern const char kMimeTypeMozillaURL[];
+COMPONENT_EXPORT(BASE_CLIPBOARD_TYPES) extern const char kMimeTypeHTML[];
+COMPONENT_EXPORT(BASE_CLIPBOARD_TYPES) extern const char kMimeTypeRTF[];
+COMPONENT_EXPORT(BASE_CLIPBOARD_TYPES) extern const char kMimeTypePNG[];
+COMPONENT_EXPORT(BASE_CLIPBOARD_TYPES)
+extern const char kMimeTypeWebCustomData[];
+COMPONENT_EXPORT(BASE_CLIPBOARD_TYPES)
+extern const char kMimeTypeWebkitSmartPaste[];
+COMPONENT_EXPORT(BASE_CLIPBOARD_TYPES)
+extern const char kMimeTypePepperCustomData[];
+
+}  // namespace ui
+
+#endif  // UI_BASE_CLIPBOARD_CLIPBOARD_H_
--- a/ui/base/clipboard/clipboard_constants_mac.mm	1970-01-01 03:00:00.000000000 +0300
+++ b/ui/base/clipboard/clipboard_constants_mac.mm	2019-02-20 20:48:23.468000000 +0300
@@ -0,0 +1,16 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/base/clipboard/clipboard_constants.h"
+
+#import <Foundation/Foundation.h>
+
+namespace ui {
+
+// TODO(dcheng): This name is temporary. See crbug.com/106449.
+#if !defined(USE_AURA)
+NSString* const kWebCustomDataPboardType = @"org.chromium.web-custom-data";
+#endif
+
+}  // namespace ui
--- a/ui/base/clipboard/clipboard_format_type_android.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/ui/base/clipboard/clipboard_format_type_android.cc	2019-02-20 20:48:23.468000000 +0300
@@ -0,0 +1,119 @@
+// Copyright 2019 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/base/clipboard/clipboard_format_type.h"
+
+#include "ui/base/clipboard/clipboard_constants.h"
+
+namespace ui {
+
+namespace {
+
+// Various formats we support.
+const char kURLFormat[] = "url";
+const char kPlainTextFormat[] = "text";
+const char kHTMLFormat[] = "html";
+const char kRTFFormat[] = "rtf";
+const char kBitmapFormat[] = "bitmap";
+const char kWebKitSmartPasteFormat[] = "webkit_smart";
+const char kBookmarkFormat[] = "bookmark";
+
+}  // namespace
+
+// ClipboardFormatType implementation.
+ClipboardFormatType::ClipboardFormatType() {}
+
+ClipboardFormatType::ClipboardFormatType(const std::string& native_format)
+    : data_(native_format) {}
+
+ClipboardFormatType::~ClipboardFormatType() {}
+
+std::string ClipboardFormatType::Serialize() const {
+  return data_;
+}
+
+// static
+ClipboardFormatType ClipboardFormatType::Deserialize(
+    const std::string& serialization) {
+  return ClipboardFormatType(serialization);
+}
+
+bool ClipboardFormatType::operator<(const ClipboardFormatType& other) const {
+  return data_ < other.data_;
+}
+
+bool ClipboardFormatType::Equals(const ClipboardFormatType& other) const {
+  return data_ == other.data_;
+}
+
+// Various predefined ClipboardFormatTypes.
+
+// static
+ClipboardFormatType ClipboardFormatType::GetType(
+    const std::string& format_string) {
+  return ClipboardFormatType::Deserialize(format_string);
+}
+
+// static
+const ClipboardFormatType& ClipboardFormatType::GetUrlWType() {
+  static base::NoDestructor<ClipboardFormatType> type(kURLFormat);
+  return *type;
+}
+
+// static
+const ClipboardFormatType& ClipboardFormatType::GetPlainTextType() {
+  static base::NoDestructor<ClipboardFormatType> type(kPlainTextFormat);
+  return *type;
+}
+
+// static
+const ClipboardFormatType& ClipboardFormatType::GetPlainTextWType() {
+  static base::NoDestructor<ClipboardFormatType> type(kPlainTextFormat);
+  return *type;
+}
+
+// static
+const ClipboardFormatType& ClipboardFormatType::GetWebKitSmartPasteType() {
+  static base::NoDestructor<ClipboardFormatType> type(kWebKitSmartPasteFormat);
+  return *type;
+}
+
+// static
+const ClipboardFormatType& ClipboardFormatType::GetHtmlType() {
+  static base::NoDestructor<ClipboardFormatType> type(kHTMLFormat);
+  return *type;
+}
+
+// static
+const ClipboardFormatType& ClipboardFormatType::GetRtfType() {
+  static base::NoDestructor<ClipboardFormatType> type(kRTFFormat);
+  return *type;
+}
+
+// static
+const ClipboardFormatType& ClipboardFormatType::GetBitmapType() {
+  static base::NoDestructor<ClipboardFormatType> type(kBitmapFormat);
+  return *type;
+}
+
+// static
+const ClipboardFormatType& ClipboardFormatType::GetWebCustomDataType() {
+  static base::NoDestructor<ClipboardFormatType> type(kMimeTypeWebCustomData);
+  return *type;
+}
+
+// static
+const ClipboardFormatType& ClipboardFormatType::GetPepperCustomDataType() {
+  static base::NoDestructor<ClipboardFormatType> type(
+      kMimeTypePepperCustomData);
+  return *type;
+}
+
+// static
+const ClipboardFormatType& ClipboardFormatType::GetBookmarkType() {
+  static base::NoDestructor<ClipboardFormatType> type(kBookmarkFormat);
+  return *type;
+}
+
+}  // namespace ui
--- a/ui/base/clipboard/clipboard_format_type_aura.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/ui/base/clipboard/clipboard_format_type_aura.cc	2019-02-20 20:48:23.468000000 +0300
@@ -0,0 +1,130 @@
+// Copyright 2019 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/base/clipboard/clipboard_format_type.h"
+
+#include "ui/base/clipboard/clipboard_constants.h"
+
+namespace ui {
+
+namespace {
+constexpr char kMimeTypeFilename[] = "chromium/filename";
+}
+
+// I would love for the ClipboardFormatType to really be a wrapper around an X11
+// ::Atom, but there are a few problems. Chromeos unit tests spawn a new X11
+// server for each test, so Atom numeric values don't persist across tests. We
+// could still maybe deal with that if we didn't have static accessor methods
+// everywhere.
+ClipboardFormatType::ClipboardFormatType() = default;
+
+ClipboardFormatType::~ClipboardFormatType() = default;
+
+ClipboardFormatType::ClipboardFormatType(const std::string& native_format)
+    : data_(native_format) {}
+
+std::string ClipboardFormatType::Serialize() const {
+  return data_;
+}
+
+// static
+ClipboardFormatType ClipboardFormatType::Deserialize(
+    const std::string& serialization) {
+  return ClipboardFormatType(serialization);
+}
+
+bool ClipboardFormatType::operator<(const ClipboardFormatType& other) const {
+  return data_ < other.data_;
+}
+
+bool ClipboardFormatType::Equals(const ClipboardFormatType& other) const {
+  return data_ == other.data_;
+}
+
+// Various predefined ClipboardFormatTypes.
+
+// static
+ClipboardFormatType ClipboardFormatType::GetType(
+    const std::string& format_string) {
+  return ClipboardFormatType::Deserialize(format_string);
+}
+
+// static
+const ClipboardFormatType& ClipboardFormatType::GetUrlType() {
+  static base::NoDestructor<ClipboardFormatType> type(kMimeTypeURIList);
+  return *type;
+}
+
+// static
+const ClipboardFormatType& ClipboardFormatType::GetUrlWType() {
+  return ClipboardFormatType::GetUrlType();
+}
+
+// static
+const ClipboardFormatType& ClipboardFormatType::GetMozUrlType() {
+  static base::NoDestructor<ClipboardFormatType> type(kMimeTypeMozillaURL);
+  return *type;
+}
+
+// static
+const ClipboardFormatType& ClipboardFormatType::GetPlainTextType() {
+  static base::NoDestructor<ClipboardFormatType> type(kMimeTypeText);
+  return *type;
+}
+
+// static
+const ClipboardFormatType& ClipboardFormatType::GetPlainTextWType() {
+  return ClipboardFormatType::GetPlainTextType();
+}
+
+// static
+const ClipboardFormatType& ClipboardFormatType::GetFilenameType() {
+  static base::NoDestructor<ClipboardFormatType> type(kMimeTypeFilename);
+  return *type;
+}
+
+// static
+const ClipboardFormatType& ClipboardFormatType::GetFilenameWType() {
+  return ClipboardFormatType::GetFilenameType();
+}
+
+// static
+const ClipboardFormatType& ClipboardFormatType::GetHtmlType() {
+  static base::NoDestructor<ClipboardFormatType> type(kMimeTypeHTML);
+  return *type;
+}
+
+// static
+const ClipboardFormatType& ClipboardFormatType::GetRtfType() {
+  static base::NoDestructor<ClipboardFormatType> type(kMimeTypeRTF);
+  return *type;
+}
+
+// static
+const ClipboardFormatType& ClipboardFormatType::GetBitmapType() {
+  static base::NoDestructor<ClipboardFormatType> type(kMimeTypePNG);
+  return *type;
+}
+
+// static
+const ClipboardFormatType& ClipboardFormatType::GetWebKitSmartPasteType() {
+  static base::NoDestructor<ClipboardFormatType> type(
+      kMimeTypeWebkitSmartPaste);
+  return *type;
+}
+
+// static
+const ClipboardFormatType& ClipboardFormatType::GetWebCustomDataType() {
+  static base::NoDestructor<ClipboardFormatType> type(kMimeTypeWebCustomData);
+  return *type;
+}
+
+// static
+const ClipboardFormatType& ClipboardFormatType::GetPepperCustomDataType() {
+  static base::NoDestructor<ClipboardFormatType> type(
+      kMimeTypePepperCustomData);
+  return *type;
+}
+
+}  // namespace ui
--- a/ui/base/clipboard/clipboard_format_type.h	1970-01-01 03:00:00.000000000 +0300
+++ b/ui/base/clipboard/clipboard_format_type.h	2019-02-20 20:48:23.468000000 +0300
@@ -0,0 +1,118 @@
+// Copyright 2019 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_BASE_CLIPBOARD_CLIPBOARD_FORMAT_TYPE_H_
+#define UI_BASE_CLIPBOARD_CLIPBOARD_FORMAT_TYPE_H_
+
+#include <string>
+
+#include "base/component_export.h"
+#include "base/no_destructor.h"
+#include "build/build_config.h"
+
+#if defined(OS_WIN)
+#include <objidl.h>
+#endif
+
+#ifdef __OBJC__
+@class NSString;
+#else
+class NSString;
+#endif
+
+namespace ui {
+
+// Platform neutral holder for native data representation of a clipboard type.
+struct COMPONENT_EXPORT(BASE_CLIPBOARD_TYPES) ClipboardFormatType {
+  ClipboardFormatType();
+  ~ClipboardFormatType();
+
+  // Serializes and deserializes a ClipboardFormatType for use in IPC messages.
+  std::string Serialize() const;
+  static ClipboardFormatType Deserialize(const std::string& serialization);
+
+  // Gets the ClipboardFormatType corresponding to an arbitrary format string,
+  // registering it with the system if needed. Due to Windows/Linux
+  // limitations, |format_string| must never be controlled by the user.
+  static ClipboardFormatType GetType(const std::string& format_string);
+
+  // Get format identifiers for various types.
+  static const ClipboardFormatType& GetUrlType();
+  static const ClipboardFormatType& GetUrlWType();
+  static const ClipboardFormatType& GetMozUrlType();
+  static const ClipboardFormatType& GetPlainTextType();
+  static const ClipboardFormatType& GetPlainTextWType();
+  static const ClipboardFormatType& GetFilenameType();
+  static const ClipboardFormatType& GetFilenameWType();
+  static const ClipboardFormatType& GetWebKitSmartPasteType();
+  // Win: MS HTML Format, Other: Generic HTML format
+  static const ClipboardFormatType& GetHtmlType();
+  static const ClipboardFormatType& GetRtfType();
+  static const ClipboardFormatType& GetBitmapType();
+  // TODO(raymes): Unify web custom data and pepper custom data:
+  // crbug.com/158399.
+  static const ClipboardFormatType& GetWebCustomDataType();
+  static const ClipboardFormatType& GetPepperCustomDataType();
+
+#if defined(OS_WIN)
+  // Firefox text/html
+  static const ClipboardFormatType& GetTextHtmlType();
+  static const ClipboardFormatType& GetCFHDropType();
+  static const ClipboardFormatType& GetFileDescriptorType();
+  static const ClipboardFormatType& GetFileContentZeroType();
+  static const ClipboardFormatType& GetIDListType();
+#endif
+
+#if defined(OS_ANDROID)
+  static const ClipboardFormatType& GetBookmarkType();
+#endif
+
+  // ClipboardFormatType can be used in a set on some platforms.
+  bool operator<(const ClipboardFormatType& other) const;
+
+#if defined(OS_WIN)
+  const FORMATETC& ToFormatEtc() const { return data_; }
+#elif defined(USE_AURA) || defined(OS_ANDROID) || defined(OS_FUCHSIA)
+  const std::string& ToString() const { return data_; }
+#elif defined(OS_MACOSX)
+  NSString* ToNSString() const { return data_; }
+  // Custom copy and assignment constructor to handle NSString.
+  ClipboardFormatType(const ClipboardFormatType& other);
+  ClipboardFormatType& operator=(const ClipboardFormatType& other);
+#endif
+
+  bool Equals(const ClipboardFormatType& other) const;
+
+ private:
+  friend class base::NoDestructor<ClipboardFormatType>;
+  friend struct ClipboardFormatType;
+
+  // Platform-specific glue used internally by the ClipboardFormatType struct.
+  // Each platform should define,at least one of each of the following:
+  // 1. A constructor that wraps that native clipboard format descriptor.
+  // 2. An accessor to retrieve the wrapped descriptor.
+  // 3. A data member to hold the wrapped descriptor.
+  //
+  // Note that in some cases, the accessor for the wrapped descriptor may be
+  // public, as these format types can be used by drag and drop code as well.
+#if defined(OS_WIN)
+  explicit ClipboardFormatType(UINT native_format);
+  ClipboardFormatType(UINT native_format, LONG index);
+  FORMATETC data_;
+#elif defined(USE_AURA) || defined(OS_ANDROID) || defined(OS_FUCHSIA)
+  explicit ClipboardFormatType(const std::string& native_format);
+  std::string data_;
+#elif defined(OS_MACOSX)
+  explicit ClipboardFormatType(NSString* native_format);
+  NSString* data_;
+#else
+#error No ClipboardFormatType definition.
+#endif
+
+  // Copyable and assignable, since this is essentially an opaque value type.
+};
+
+}  // namespace ui
+
+#endif  // UI_BASE_CLIPBOARD_CLIPBOARD_FORMAT_TYPE_H_
--- a/ui/base/clipboard/clipboard_format_type_mac.mm	1970-01-01 03:00:00.000000000 +0300
+++ b/ui/base/clipboard/clipboard_format_type_mac.mm	2019-02-20 20:48:23.468000000 +0300
@@ -0,0 +1,144 @@
+// Copyright 2019 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/base/clipboard/clipboard_format_type.h"
+
+#import <Cocoa/Cocoa.h>
+
+#include "base/strings/sys_string_conversions.h"
+#include "ui/base/clipboard/clipboard_constants.h"
+
+namespace ui {
+
+namespace {
+
+// Tells us if WebKit was the last to write to the pasteboard. There's no
+// actual data associated with this type.
+NSString* const kWebSmartPastePboardType = @"NeXT smart paste pasteboard type";
+
+// Pepper custom data format type.
+NSString* const kPepperCustomDataPboardType =
+    @"org.chromium.pepper-custom-data";
+
+}  // namespace
+
+// ClipboardFormatType implementation.
+ClipboardFormatType::ClipboardFormatType() : data_(nil) {}
+
+ClipboardFormatType::ClipboardFormatType(NSString* native_format)
+    : data_([native_format retain]) {}
+
+ClipboardFormatType::ClipboardFormatType(const ClipboardFormatType& other)
+    : data_([other.data_ retain]) {}
+
+ClipboardFormatType& ClipboardFormatType::operator=(
+    const ClipboardFormatType& other) {
+  if (this != &other) {
+    [data_ release];
+    data_ = [other.data_ retain];
+  }
+  return *this;
+}
+
+bool ClipboardFormatType::Equals(const ClipboardFormatType& other) const {
+  return [data_ isEqualToString:other.data_];
+}
+
+ClipboardFormatType::~ClipboardFormatType() {
+  [data_ release];
+}
+
+std::string ClipboardFormatType::Serialize() const {
+  return base::SysNSStringToUTF8(data_);
+}
+
+// static
+ClipboardFormatType ClipboardFormatType::Deserialize(
+    const std::string& serialization) {
+  return ClipboardFormatType(base::SysUTF8ToNSString(serialization));
+}
+
+bool ClipboardFormatType::operator<(const ClipboardFormatType& other) const {
+  return [data_ compare:other.data_] == NSOrderedAscending;
+}
+
+// Various predefined ClipboardFormatTypes.
+
+// static
+ClipboardFormatType ClipboardFormatType::GetType(
+    const std::string& format_string) {
+  return ClipboardFormatType::Deserialize(format_string);
+}
+
+// static
+const ClipboardFormatType& ClipboardFormatType::GetUrlType() {
+  static base::NoDestructor<ClipboardFormatType> type(NSURLPboardType);
+  return *type;
+}
+
+// static
+const ClipboardFormatType& ClipboardFormatType::GetUrlWType() {
+  return ClipboardFormatType::GetUrlType();
+}
+
+// static
+const ClipboardFormatType& ClipboardFormatType::GetPlainTextType() {
+  static base::NoDestructor<ClipboardFormatType> type(NSPasteboardTypeString);
+  return *type;
+}
+
+// static
+const ClipboardFormatType& ClipboardFormatType::GetPlainTextWType() {
+  return ClipboardFormatType::GetPlainTextType();
+}
+
+// static
+const ClipboardFormatType& ClipboardFormatType::GetFilenameType() {
+  static base::NoDestructor<ClipboardFormatType> type(NSFilenamesPboardType);
+  return *type;
+}
+
+// static
+const ClipboardFormatType& ClipboardFormatType::GetFilenameWType() {
+  return ClipboardFormatType::GetFilenameType();
+}
+
+// static
+const ClipboardFormatType& ClipboardFormatType::GetHtmlType() {
+  static base::NoDestructor<ClipboardFormatType> type(NSHTMLPboardType);
+  return *type;
+}
+
+// static
+const ClipboardFormatType& ClipboardFormatType::GetRtfType() {
+  static base::NoDestructor<ClipboardFormatType> type(NSRTFPboardType);
+  return *type;
+}
+
+// static
+const ClipboardFormatType& ClipboardFormatType::GetBitmapType() {
+  static base::NoDestructor<ClipboardFormatType> type(NSTIFFPboardType);
+  return *type;
+}
+
+// static
+const ClipboardFormatType& ClipboardFormatType::GetWebKitSmartPasteType() {
+  static base::NoDestructor<ClipboardFormatType> type(kWebSmartPastePboardType);
+  return *type;
+}
+
+// static
+const ClipboardFormatType& ClipboardFormatType::GetWebCustomDataType() {
+  static base::NoDestructor<ClipboardFormatType> type(kWebCustomDataPboardType);
+  return *type;
+}
+
+// static
+const ClipboardFormatType& ClipboardFormatType::GetPepperCustomDataType() {
+  static base::NoDestructor<ClipboardFormatType> type(
+      kPepperCustomDataPboardType);
+  return *type;
+}
+
+}  // namespace ui
--- a/ui/base/clipboard/clipboard_format_type_win.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/ui/base/clipboard/clipboard_format_type_win.cc	2019-02-20 20:48:23.468000000 +0300
@@ -0,0 +1,214 @@
+// Copyright 2019 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/base/clipboard/clipboard_format_type.h"
+
+#include <shlobj.h>
+
+#include "base/lazy_instance.h"
+#include "base/logging.h"
+#include "base/strings/string_number_conversions.h"
+#include "base/strings/utf_string_conversions.h"
+
+namespace ui {
+
+// ClipboardFormatType implementation.
+ClipboardFormatType::ClipboardFormatType() : data_() {}
+
+ClipboardFormatType::ClipboardFormatType(UINT native_format) : data_() {
+  // There's no good way to actually initialize this in the constructor in
+  // C++03.
+  data_.cfFormat = static_cast<CLIPFORMAT>(native_format);
+  data_.dwAspect = DVASPECT_CONTENT;
+  data_.lindex = -1;
+  data_.tymed = TYMED_HGLOBAL;
+}
+
+ClipboardFormatType::ClipboardFormatType(UINT native_format, LONG index)
+    : data_() {
+  // There's no good way to actually initialize this in the constructor in
+  // C++03.
+  data_.cfFormat = static_cast<CLIPFORMAT>(native_format);
+  data_.dwAspect = DVASPECT_CONTENT;
+  data_.lindex = index;
+  data_.tymed = TYMED_HGLOBAL;
+}
+
+ClipboardFormatType::~ClipboardFormatType() {}
+
+std::string ClipboardFormatType::Serialize() const {
+  return base::IntToString(data_.cfFormat);
+}
+
+// static
+ClipboardFormatType ClipboardFormatType::Deserialize(
+    const std::string& serialization) {
+  int clipboard_format = -1;
+  if (!base::StringToInt(serialization, &clipboard_format)) {
+    NOTREACHED();
+    return ClipboardFormatType();
+  }
+  return ClipboardFormatType(clipboard_format);
+}
+
+bool ClipboardFormatType::operator<(const ClipboardFormatType& other) const {
+  return data_.cfFormat < other.data_.cfFormat;
+}
+
+bool ClipboardFormatType::Equals(const ClipboardFormatType& other) const {
+  return data_.cfFormat == other.data_.cfFormat;
+}
+
+// Various predefined ClipboardFormatTypes.
+
+// static
+ClipboardFormatType ClipboardFormatType::GetType(
+    const std::string& format_string) {
+  return ClipboardFormatType(
+      ::RegisterClipboardFormat(base::ASCIIToUTF16(format_string).c_str()));
+}
+
+// The following formats can be referenced by ClipboardUtilWin::GetPlainText.
+// For reasons (COM), they must be initialized in a thread-safe manner.
+// TODO(dcheng): We probably need to make static initialization of "known"
+// ClipboardFormatTypes thread-safe on all platforms.
+#define CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(name, ...)                        \
+  struct ClipboardFormatTypeArgumentForwarder : public ClipboardFormatType { \
+    ClipboardFormatTypeArgumentForwarder()                                   \
+        : ClipboardFormatType(__VA_ARGS__) {}                                \
+  };                                                                         \
+  static base::LazyInstance<ClipboardFormatTypeArgumentForwarder>::Leaky     \
+      name = LAZY_INSTANCE_INITIALIZER
+
+// static
+const ClipboardFormatType& ClipboardFormatType::GetUrlType() {
+  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(type,
+                                     ::RegisterClipboardFormat(CFSTR_INETURLA));
+  return type.Get();
+}
+
+// static
+const ClipboardFormatType& ClipboardFormatType::GetUrlWType() {
+  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(type,
+                                     ::RegisterClipboardFormat(CFSTR_INETURLW));
+  return type.Get();
+}
+
+// static
+const ClipboardFormatType& ClipboardFormatType::GetMozUrlType() {
+  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(
+      type, ::RegisterClipboardFormat(L"text/x-moz-url"));
+  return type.Get();
+}
+
+// static
+const ClipboardFormatType& ClipboardFormatType::GetPlainTextType() {
+  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(type, CF_TEXT);
+  return type.Get();
+}
+
+// static
+const ClipboardFormatType& ClipboardFormatType::GetPlainTextWType() {
+  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(type, CF_UNICODETEXT);
+  return type.Get();
+}
+
+// static
+const ClipboardFormatType& ClipboardFormatType::GetFilenameType() {
+  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(
+      type, ::RegisterClipboardFormat(CFSTR_FILENAMEA));
+  return type.Get();
+}
+
+// static
+const ClipboardFormatType& ClipboardFormatType::GetFilenameWType() {
+  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(
+      type, ::RegisterClipboardFormat(CFSTR_FILENAMEW));
+  return type.Get();
+}
+
+// MS HTML Format
+
+// static
+const ClipboardFormatType& ClipboardFormatType::GetHtmlType() {
+  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(type,
+                                     ::RegisterClipboardFormat(L"HTML Format"));
+  return type.Get();
+}
+
+// MS RTF Format
+
+// static
+const ClipboardFormatType& ClipboardFormatType::GetRtfType() {
+  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(
+      type, ::RegisterClipboardFormat(L"Rich Text Format"));
+  return type.Get();
+}
+
+// static
+const ClipboardFormatType& ClipboardFormatType::GetBitmapType() {
+  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(type, CF_BITMAP);
+  return type.Get();
+}
+
+// Firefox text/html
+
+// static
+const ClipboardFormatType& ClipboardFormatType::GetTextHtmlType() {
+  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(type,
+                                     ::RegisterClipboardFormat(L"text/html"));
+  return type.Get();
+}
+
+// static
+const ClipboardFormatType& ClipboardFormatType::GetCFHDropType() {
+  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(type, CF_HDROP);
+  return type.Get();
+}
+
+// static
+const ClipboardFormatType& ClipboardFormatType::GetFileDescriptorType() {
+  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(
+      type, ::RegisterClipboardFormat(CFSTR_FILEDESCRIPTOR));
+  return type.Get();
+}
+
+// static
+const ClipboardFormatType& ClipboardFormatType::GetFileContentZeroType() {
+  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(
+      type, ::RegisterClipboardFormat(CFSTR_FILECONTENTS), 0);
+  return type.Get();
+}
+
+// static
+const ClipboardFormatType& ClipboardFormatType::GetIDListType() {
+  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(
+      type, ::RegisterClipboardFormat(CFSTR_SHELLIDLIST));
+  return type.Get();
+}
+
+// static
+const ClipboardFormatType& ClipboardFormatType::GetWebKitSmartPasteType() {
+  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(
+      type, ::RegisterClipboardFormat(L"WebKit Smart Paste Format"));
+  return type.Get();
+}
+
+// static
+const ClipboardFormatType& ClipboardFormatType::GetWebCustomDataType() {
+  // TODO(dcheng): This name is temporary. See http://crbug.com/106449.
+  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(
+      type, ::RegisterClipboardFormat(L"Chromium Web Custom MIME Data Format"));
+  return type.Get();
+}
+
+// static
+const ClipboardFormatType& ClipboardFormatType::GetPepperCustomDataType() {
+  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(
+      type, ::RegisterClipboardFormat(L"Chromium Pepper MIME Data Format"));
+  return type.Get();
+}
+#undef CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE
+
+}  // namespace ui
--- a/ui/base/clipboard/clipboard_ozone.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/ui/base/clipboard/clipboard_ozone.cc	2019-02-20 20:48:23.468000000 +0300
@@ -0,0 +1,451 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/base/clipboard/clipboard_ozone.h"
+
+#include <limits>
+#include <utility>
+
+#include "base/bind.h"
+#include "base/containers/span.h"
+#include "base/macros.h"
+#include "base/memory/weak_ptr.h"
+#include "base/run_loop.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/timer/timer.h"
+#include "third_party/skia/include/core/SkBitmap.h"
+#include "ui/base/clipboard/clipboard_constants.h"
+#include "ui/base/clipboard/custom_data_helper.h"
+#include "ui/gfx/codec/png_codec.h"
+#include "ui/ozone/public/ozone_platform.h"
+#include "ui/ozone/public/platform_clipboard.h"
+
+namespace ui {
+
+namespace {
+
+// The amount of time to wait for a request to complete before aborting it.
+constexpr base::TimeDelta kRequestTimeoutMs =
+    base::TimeDelta::FromMilliseconds(10000);
+
+}  // namespace
+
+// A helper class, which uses a request pattern to asynchronously communicate
+// with the ozone::PlatformClipboard and fetch clipboard data with mimes
+// specified.
+class ClipboardOzone::AsyncClipboardOzone {
+ public:
+  explicit AsyncClipboardOzone(PlatformClipboard* platform_clipboard)
+      : platform_clipboard_(platform_clipboard), weak_factory_(this) {
+    // Set a callback to listen to requests to increase the clipboard sequence
+    // number.
+    auto update_sequence_cb =
+        base::BindRepeating(&AsyncClipboardOzone::UpdateClipboardSequenceNumber,
+                            weak_factory_.GetWeakPtr());
+    platform_clipboard_->SetSequenceNumberUpdateCb(
+        std::move(update_sequence_cb));
+  }
+
+  ~AsyncClipboardOzone() = default;
+
+  base::span<uint8_t> ReadClipboardDataAndWait(ClipboardType type,
+                                               const std::string& mime_type) {
+    // TODO(tonikitoo): add selection support.
+    if (type == ClipboardType::CLIPBOARD_TYPE_SELECTION)
+      return base::span<uint8_t>();
+
+    // We can use a fastpath if we are the owner of the selection.
+    if (platform_clipboard_->IsSelectionOwner()) {
+      auto it = offered_data_.find(mime_type);
+      if (it == offered_data_.end())
+        return base::span<uint8_t>();
+      return base::make_span(it->second.data(), it->second.size());
+    }
+
+    auto request = std::make_unique<Request>(RequestType::kRead);
+    request->requested_mime_type = mime_type;
+    ProcessRequestAndWaitForResult(request.get());
+
+    offered_data_ = std::move(request->data_map);
+    auto it = offered_data_.find(mime_type);
+    if (it == offered_data_.end())
+      return base::span<uint8_t>();
+    return base::make_span(it->second.data(), it->second.size());
+  }
+
+  std::vector<std::string> RequestMimeTypes() {
+    // We can use a fastpath if we are the owner of the selection.
+    if (platform_clipboard_->IsSelectionOwner()) {
+      std::vector<std::string> mime_types;
+      for (const auto& item : offered_data_)
+        mime_types.push_back(item.first);
+      return mime_types;
+    }
+
+    auto request = std::make_unique<Request>(RequestType::kGetMime);
+    ProcessRequestAndWaitForResult(request.get());
+    return std::move(request->mime_types);
+  }
+
+  void OfferData() {
+    auto request = std::make_unique<Request>(RequestType::kOffer);
+    request->data_map = offered_data_;
+    ProcessRequestAndWaitForResult(request.get());
+
+    UpdateClipboardSequenceNumber();
+  }
+
+  void InsertData(std::vector<uint8_t> data, const std::string& mime_type) {
+    DCHECK(offered_data_.find(mime_type) == offered_data_.end());
+    offered_data_[mime_type] = std::move(data);
+  }
+
+  void ClearOfferedData() { offered_data_.clear(); }
+
+  uint64_t GetSequenceNumber(ClipboardType type) {
+    if (type == ClipboardType::CLIPBOARD_TYPE_COPY_PASTE)
+      return clipboard_sequence_number_;
+    // TODO(tonikitoo): add sequence number for the selection clipboard type.
+    return 0;
+  }
+
+ private:
+  enum class RequestType {
+    kRead = 0,
+    kOffer = 1,
+    kGetMime = 2,
+  };
+
+  // A structure, which holds request data to process inquiries from
+  // the ClipboardOzone.
+  struct Request {
+    explicit Request(RequestType type) : current_type(type) {}
+    ~Request() = default;
+
+    // Describes the type of the request.
+    RequestType current_type;
+
+    // A closure that is used to signal the request is processed.
+    base::OnceClosure request_closure;
+
+    // Used for kRead and kOffer requests. It contains either data offered by
+    // Chromium to a system clipboard or a read data offered by the system
+    // clipboard.
+    PlatformClipboard::DataMap data_map;
+
+    // Identifies which mime type the client is interested to read from the
+    // system clipboard during kRead requests.
+    std::string requested_mime_type;
+
+    // A vector of mime types returned as a result to a kGetMime request to get
+    // available mime types.
+    std::vector<std::string> mime_types;
+  };
+
+  void ProcessRequestAndWaitForResult(Request* request) {
+    DCHECK(!abort_timer_.IsRunning());
+    DCHECK(!pending_request_);
+
+    // TODO(https://crbug.com/913422): the implementation is known to be
+    // dangerous, and may cause blocks in ui thkRead. But base::Clipboard was
+    // designed to have synchrous APIs rather than asynchronous ones that at
+    // least two system clipboards on X11 and Wayland provide.
+    base::RunLoop run_loop(base::RunLoop::Type::kNestableTasksAllowed);
+    request->request_closure = run_loop.QuitClosure();
+
+    pending_request_ = request;
+    switch (pending_request_->current_type) {
+      case (RequestType::kRead):
+        ProcessReadRequest(request);
+        break;
+      case (RequestType::kOffer):
+        ProcessOfferRequest(request);
+        break;
+      case (RequestType::kGetMime):
+        ProcessGetMimeRequest(request);
+        break;
+    }
+
+    if (!pending_request_)
+      return;
+
+    // Set a timeout timer after which the request will be aborted.
+    abort_timer_.Start(FROM_HERE, kRequestTimeoutMs, this,
+                       &AsyncClipboardOzone::AbortStaledRequest);
+    run_loop.Run();
+  }
+
+  void AbortStaledRequest() {
+    if (pending_request_)
+      std::move(pending_request_->request_closure).Run();
+  }
+
+  void ProcessReadRequest(Request* request) {
+    auto callback = base::BindOnce(&AsyncClipboardOzone::OnTextkRead,
+                                   weak_factory_.GetWeakPtr());
+    DCHECK(platform_clipboard_);
+    platform_clipboard_->RequestClipboardData(
+        request->requested_mime_type, &request->data_map, std::move(callback));
+  }
+
+  void ProcessOfferRequest(Request* request) {
+    auto callback = base::BindOnce(&AsyncClipboardOzone::OnkOfferDone,
+                                   weak_factory_.GetWeakPtr());
+    DCHECK(platform_clipboard_);
+    platform_clipboard_->OfferClipboardData(request->data_map,
+                                            std::move(callback));
+  }
+
+  void ProcessGetMimeRequest(Request* request) {
+    auto callback = base::BindOnce(&AsyncClipboardOzone::OnGotMimeTypes,
+                                   weak_factory_.GetWeakPtr());
+    DCHECK(platform_clipboard_);
+    platform_clipboard_->GetAvailableMimeTypes(std::move(callback));
+  }
+
+  void OnTextkRead(const base::Optional<std::vector<uint8_t>>& data) {
+    CompleteRequest();
+  }
+
+  void OnkOfferDone() { CompleteRequest(); }
+
+  void OnGotMimeTypes(const std::vector<std::string>& mime_types) {
+    pending_request_->mime_types = std::move(mime_types);
+    CompleteRequest();
+  }
+
+  void CompleteRequest() {
+    abort_timer_.Stop();
+    auto closure = std::move(pending_request_->request_closure);
+    pending_request_ = nullptr;
+    std::move(closure).Run();
+  }
+
+  void UpdateClipboardSequenceNumber() { ++clipboard_sequence_number_; }
+
+  // Cached clipboard data, which is pending to be written. Must be cleared on
+  // every new write to the |platform_clipboard_|.
+  PlatformClipboard::DataMap offered_data_;
+
+  // A current pending request being processed.
+  Request* pending_request_ = nullptr;
+
+  // Aborts |pending_request| after Request::timeout.
+  base::RepeatingTimer abort_timer_;
+
+  // Provides communication to a system clipboard under ozone level.
+  PlatformClipboard* platform_clipboard_ = nullptr;
+
+  uint64_t clipboard_sequence_number_ = 0;
+
+  base::WeakPtrFactory<AsyncClipboardOzone> weak_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(AsyncClipboardOzone);
+};
+
+// Clipboard factory method.
+Clipboard* Clipboard::Create() {
+  return new ClipboardOzone;
+}
+
+// ClipboardOzone implementation.
+ClipboardOzone::ClipboardOzone() {
+  async_clipboard_ozone_ =
+      std::make_unique<ClipboardOzone::AsyncClipboardOzone>(
+          OzonePlatform::GetInstance()->GetPlatformClipboard());
+}
+
+ClipboardOzone::~ClipboardOzone() = default;
+
+void ClipboardOzone::OnPreShutdown() {}
+
+uint64_t ClipboardOzone::GetSequenceNumber(ClipboardType type) const {
+  auto s = async_clipboard_ozone_->GetSequenceNumber(type);
+  LOG(ERROR) << "SEQUENCE " << s;
+  return s;
+}
+
+bool ClipboardOzone::IsFormatAvailable(const ClipboardFormatType& format,
+                                       ClipboardType type) const {
+  DCHECK(CalledOnValidThread());
+  // TODO(tonikitoo): add selection support.
+  if (type == ClipboardType::CLIPBOARD_TYPE_SELECTION)
+    return false;
+
+  auto available_types = async_clipboard_ozone_->RequestMimeTypes();
+  for (auto mime_type : available_types) {
+    if (format.ToString() == mime_type) {
+      return true;
+    }
+  }
+  return false;
+}
+
+void ClipboardOzone::Clear(ClipboardType type) {
+  async_clipboard_ozone_->ClearOfferedData();
+  async_clipboard_ozone_->OfferData();
+}
+
+void ClipboardOzone::ReadAvailableTypes(ClipboardType type,
+                                        std::vector<base::string16>* types,
+                                        bool* contains_filenames) const {
+  DCHECK(CalledOnValidThread());
+  types->clear();
+
+  // TODO(tonikitoo): add selection support.
+  if (type == ClipboardType::CLIPBOARD_TYPE_SELECTION)
+    return;
+
+  auto available_types = async_clipboard_ozone_->RequestMimeTypes();
+  for (auto mime_type : available_types)
+    types->push_back(base::UTF8ToUTF16(mime_type));
+}
+
+void ClipboardOzone::ReadText(ClipboardType type,
+                              base::string16* result) const {
+  DCHECK(CalledOnValidThread());
+
+  auto clipboard_data =
+      async_clipboard_ozone_->ReadClipboardDataAndWait(type, kMimeTypeText);
+  *result = base::UTF8ToUTF16(base::StringPiece(
+      reinterpret_cast<char*>(clipboard_data.data()), clipboard_data.size()));
+}
+
+void ClipboardOzone::ReadAsciiText(ClipboardType type,
+                                   std::string* result) const {
+  DCHECK(CalledOnValidThread());
+  auto clipboard_data =
+      async_clipboard_ozone_->ReadClipboardDataAndWait(type, kMimeTypeText);
+  result->assign(clipboard_data.begin(), clipboard_data.end());
+}
+
+void ClipboardOzone::ReadHTML(ClipboardType type,
+                              base::string16* markup,
+                              std::string* src_url,
+                              uint32_t* fragment_start,
+                              uint32_t* fragment_end) const {
+  DCHECK(CalledOnValidThread());
+  markup->clear();
+  if (src_url)
+    src_url->clear();
+  *fragment_start = 0;
+  *fragment_end = 0;
+
+  auto clipboard_data =
+      async_clipboard_ozone_->ReadClipboardDataAndWait(type, kMimeTypeHTML);
+  *markup = base::UTF8ToUTF16(base::StringPiece(
+      reinterpret_cast<char*>(clipboard_data.data()), clipboard_data.size()));
+  DCHECK(markup->length() <= std::numeric_limits<uint32_t>::max());
+  *fragment_end = static_cast<uint32_t>(markup->length());
+}
+
+void ClipboardOzone::ReadRTF(ClipboardType type, std::string* result) const {
+  DCHECK(CalledOnValidThread());
+  auto clipboard_data =
+      async_clipboard_ozone_->ReadClipboardDataAndWait(type, kMimeTypeRTF);
+  result->assign(clipboard_data.begin(), clipboard_data.end());
+}
+
+SkBitmap ClipboardOzone::ReadImage(ClipboardType type) const {
+  DCHECK(CalledOnValidThread());
+  auto clipboard_data =
+      async_clipboard_ozone_->ReadClipboardDataAndWait(type, kMimeTypePNG);
+  SkBitmap bitmap;
+  if (gfx::PNGCodec::Decode(clipboard_data.data(), clipboard_data.size(),
+                            &bitmap))
+    return SkBitmap(bitmap);
+  return SkBitmap();
+}
+
+void ClipboardOzone::ReadCustomData(ClipboardType clipboard_type,
+                                    const base::string16& type,
+                                    base::string16* result) const {
+  DCHECK(CalledOnValidThread());
+  auto custom_data = async_clipboard_ozone_->ReadClipboardDataAndWait(
+      clipboard_type, kMimeTypeWebCustomData);
+  ui::ReadCustomDataForType(custom_data.data(), custom_data.size(), type,
+                            result);
+}
+
+void ClipboardOzone::ReadBookmark(base::string16* title,
+                                  std::string* url) const {
+  DCHECK(CalledOnValidThread());
+  // TODO(msisov): This was left NOTIMPLEMENTED() in all the Linux platforms.
+  NOTIMPLEMENTED();
+}
+
+void ClipboardOzone::ReadData(const ClipboardFormatType& format,
+                              std::string* result) const {
+  DCHECK(CalledOnValidThread());
+  auto clipboard_data = async_clipboard_ozone_->ReadClipboardDataAndWait(
+      ClipboardType::CLIPBOARD_TYPE_COPY_PASTE, format.ToString());
+  result->assign(clipboard_data.begin(), clipboard_data.end());
+}
+
+void ClipboardOzone::WriteObjects(ClipboardType type,
+                                  const ObjectMap& objects) {
+  DCHECK(CalledOnValidThread());
+  if (type == ClipboardType::CLIPBOARD_TYPE_COPY_PASTE) {
+    async_clipboard_ozone_->ClearOfferedData();
+
+    for (const auto& object : objects)
+      DispatchObject(static_cast<ObjectType>(object.first), object.second);
+
+    async_clipboard_ozone_->OfferData();
+  }
+}
+
+void ClipboardOzone::WriteText(const char* text_data, size_t text_len) {
+  std::vector<uint8_t> data(text_data, text_data + text_len);
+  async_clipboard_ozone_->InsertData(std::move(data), kMimeTypeText);
+}
+
+void ClipboardOzone::WriteHTML(const char* markup_data,
+                               size_t markup_len,
+                               const char* url_data,
+                               size_t url_len) {
+  std::vector<uint8_t> data(markup_data, markup_data + markup_len);
+  async_clipboard_ozone_->InsertData(std::move(data), kMimeTypeHTML);
+}
+
+void ClipboardOzone::WriteRTF(const char* rtf_data, size_t data_len) {
+  std::vector<uint8_t> data(rtf_data, rtf_data + data_len);
+  async_clipboard_ozone_->InsertData(std::move(data), kMimeTypeRTF);
+}
+
+void ClipboardOzone::WriteBookmark(const char* title_data,
+                                   size_t title_len,
+                                   const char* url_data,
+                                   size_t url_len) {
+  // Writes a Mozilla url (UTF16: URL, newline, title)
+  base::string16 bookmark =
+      base::UTF8ToUTF16(base::StringPiece(url_data, url_len)) +
+      base::ASCIIToUTF16("\n") +
+      base::UTF8ToUTF16(base::StringPiece(title_data, title_len));
+
+  std::vector<uint8_t> data(
+      reinterpret_cast<const uint8_t*>(bookmark.data()),
+      reinterpret_cast<const uint8_t*>(bookmark.data() + bookmark.size()));
+  async_clipboard_ozone_->InsertData(std::move(data), kMimeTypeMozillaURL);
+}
+
+void ClipboardOzone::WriteWebSmartPaste() {
+  async_clipboard_ozone_->InsertData(std::vector<uint8_t>(),
+                                     kMimeTypeWebkitSmartPaste);
+}
+
+void ClipboardOzone::WriteBitmap(const SkBitmap& bitmap) {
+  std::vector<unsigned char> output;
+  if (gfx::PNGCodec::FastEncodeBGRASkBitmap(bitmap, false, &output))
+    async_clipboard_ozone_->InsertData(std::move(output), kMimeTypePNG);
+}
+
+void ClipboardOzone::WriteData(const ClipboardFormatType& format,
+                               const char* data_data,
+                               size_t data_len) {
+  std::vector<uint8_t> data(data_data, data_data + data_len);
+  async_clipboard_ozone_->InsertData(data, format.ToString());
+}
+
+}  // namespace ui
--- a/ui/base/clipboard/clipboard_ozone.h	1970-01-01 03:00:00.000000000 +0300
+++ b/ui/base/clipboard/clipboard_ozone.h	2019-02-20 20:48:23.468000000 +0300
@@ -0,0 +1,76 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_BASE_CLIPBOARD_CLIPBOARD_OZONE_H_
+#define UI_BASE_CLIPBOARD_CLIPBOARD_OZONE_H_
+
+#include <stddef.h>
+#include <stdint.h>
+#include <memory>
+#include <string>
+#include <vector>
+
+#include "base/macros.h"
+#include "ui/base/clipboard/clipboard.h"
+
+namespace ui {
+
+class ClipboardOzone : public Clipboard {
+ private:
+  friend class Clipboard;
+
+  ClipboardOzone();
+  ~ClipboardOzone() override;
+
+  // Clipboard overrides:
+  void OnPreShutdown() override;
+  uint64_t GetSequenceNumber(ClipboardType type) const override;
+  bool IsFormatAvailable(const ClipboardFormatType& format,
+                         ClipboardType type) const override;
+  void Clear(ClipboardType type) override;
+  void ReadAvailableTypes(ClipboardType type,
+                          std::vector<base::string16>* types,
+                          bool* contains_filenames) const override;
+  void ReadText(ClipboardType type, base::string16* result) const override;
+  void ReadAsciiText(ClipboardType type, std::string* result) const override;
+  void ReadHTML(ClipboardType type,
+                base::string16* markup,
+                std::string* src_url,
+                uint32_t* fragment_start,
+                uint32_t* fragment_end) const override;
+  void ReadRTF(ClipboardType type, std::string* result) const override;
+  SkBitmap ReadImage(ClipboardType type) const override;
+  void ReadCustomData(ClipboardType clipboard_type,
+                      const base::string16& type,
+                      base::string16* result) const override;
+  void ReadBookmark(base::string16* title, std::string* url) const override;
+  void ReadData(const ClipboardFormatType& format,
+                std::string* result) const override;
+  void WriteObjects(ClipboardType type, const ObjectMap& objects) override;
+  void WriteText(const char* text_data, size_t text_len) override;
+  void WriteHTML(const char* markup_data,
+                 size_t markup_len,
+                 const char* url_data,
+                 size_t url_len) override;
+  void WriteRTF(const char* rtf_data, size_t data_len) override;
+  void WriteBookmark(const char* title_data,
+                     size_t title_len,
+                     const char* url_data,
+                     size_t url_len) override;
+  void WriteWebSmartPaste() override;
+  void WriteBitmap(const SkBitmap& bitmap) override;
+  void WriteData(const ClipboardFormatType& format,
+                 const char* data_data,
+                 size_t data_len) override;
+
+  class AsyncClipboardOzone;
+
+  std::unique_ptr<AsyncClipboardOzone> async_clipboard_ozone_;
+
+  DISALLOW_COPY_AND_ASSIGN(ClipboardOzone);
+};
+
+}  // namespace ui
+
+#endif  // UI_BASE_CLIPBOARD_CLIPBOARD_OZONE_H_
diff -BbuN a/ui/base/clipboard/test/test_clipboard.cc b/ui/base/clipboard/test/test_clipboard.cc
--- a/ui/base/clipboard/test/test_clipboard.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/ui/base/clipboard/test/test_clipboard.cc	2019-02-20 20:48:23.472000000 +0300
@@ -0,0 +1,241 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/base/clipboard/test/test_clipboard.h"
+
+#include <stddef.h>
+#include "base/memory/ptr_util.h"
+#include "base/numerics/safe_conversions.h"
+#include "base/strings/utf_string_conversions.h"
+#include "skia/ext/skia_utils_base.h"
+#include "ui/base/clipboard/clipboard_constants.h"
+#include "ui/base/clipboard/clipboard_monitor.h"
+
+namespace ui {
+
+TestClipboard::TestClipboard()
+    : default_store_type_(CLIPBOARD_TYPE_COPY_PASTE) {}
+
+TestClipboard::~TestClipboard() {}
+
+Clipboard* TestClipboard::CreateForCurrentThread() {
+  base::AutoLock lock(Clipboard::clipboard_map_lock_.Get());
+  Clipboard* clipboard = new TestClipboard;
+  Clipboard::clipboard_map_.Get()[base::PlatformThread::CurrentId()] =
+      base::WrapUnique(clipboard);
+  return clipboard;
+}
+
+void TestClipboard::SetLastModifiedTime(const base::Time& time) {
+  last_modified_time_ = time;
+}
+
+void TestClipboard::OnPreShutdown() {}
+
+uint64_t TestClipboard::GetSequenceNumber(ClipboardType type) const {
+  return GetStore(type).sequence_number;
+}
+
+bool TestClipboard::IsFormatAvailable(const ClipboardFormatType& format,
+                                      ClipboardType type) const {
+  const DataStore& store = GetStore(type);
+  return store.data.find(format) != store.data.end();
+}
+
+void TestClipboard::Clear(ClipboardType type) {
+  GetStore(type).Clear();
+}
+
+void TestClipboard::ReadAvailableTypes(ClipboardType type,
+                                       std::vector<base::string16>* types,
+                                       bool* contains_filenames) const {
+  types->clear();
+
+  if (IsFormatAvailable(ClipboardFormatType::GetPlainTextType(), type))
+    types->push_back(base::UTF8ToUTF16(kMimeTypeText));
+  if (IsFormatAvailable(ClipboardFormatType::GetHtmlType(), type))
+    types->push_back(base::UTF8ToUTF16(kMimeTypeHTML));
+
+  if (IsFormatAvailable(ClipboardFormatType::GetRtfType(), type))
+    types->push_back(base::UTF8ToUTF16(kMimeTypeRTF));
+  if (IsFormatAvailable(ClipboardFormatType::GetBitmapType(), type))
+    types->push_back(base::UTF8ToUTF16(kMimeTypePNG));
+
+  *contains_filenames = false;
+}
+
+void TestClipboard::ReadText(ClipboardType type, base::string16* result) const {
+  std::string result8;
+  ReadAsciiText(type, &result8);
+  *result = base::UTF8ToUTF16(result8);
+}
+
+void TestClipboard::ReadAsciiText(ClipboardType type,
+                                  std::string* result) const {
+  result->clear();
+  const DataStore& store = GetStore(type);
+  auto it = store.data.find(ClipboardFormatType::GetPlainTextType());
+  if (it != store.data.end())
+    *result = it->second;
+}
+
+void TestClipboard::ReadHTML(ClipboardType type,
+                             base::string16* markup,
+                             std::string* src_url,
+                             uint32_t* fragment_start,
+                             uint32_t* fragment_end) const {
+  markup->clear();
+  src_url->clear();
+  const DataStore& store = GetStore(type);
+  auto it = store.data.find(ClipboardFormatType::GetHtmlType());
+  if (it != store.data.end())
+    *markup = base::UTF8ToUTF16(it->second);
+  *src_url = store.html_src_url;
+  *fragment_start = 0;
+  *fragment_end = base::checked_cast<uint32_t>(markup->size());
+}
+
+void TestClipboard::ReadRTF(ClipboardType type, std::string* result) const {
+  result->clear();
+  const DataStore& store = GetStore(type);
+  auto it = store.data.find(ClipboardFormatType::GetRtfType());
+  if (it != store.data.end())
+    *result = it->second;
+}
+
+SkBitmap TestClipboard::ReadImage(ClipboardType type) const {
+  return GetStore(type).image;
+}
+
+void TestClipboard::ReadCustomData(ClipboardType clipboard_type,
+                                   const base::string16& type,
+                                   base::string16* result) const {}
+
+void TestClipboard::ReadBookmark(base::string16* title,
+                                 std::string* url) const {
+  const DataStore& store = GetDefaultStore();
+  auto it = store.data.find(ClipboardFormatType::GetUrlWType());
+  if (it != store.data.end())
+    *url = it->second;
+  *title = base::UTF8ToUTF16(store.url_title);
+}
+
+void TestClipboard::ReadData(const ClipboardFormatType& format,
+                             std::string* result) const {
+  result->clear();
+  const DataStore& store = GetDefaultStore();
+  auto it = store.data.find(format);
+  if (it != store.data.end())
+    *result = it->second;
+}
+
+base::Time TestClipboard::GetLastModifiedTime() const {
+  return last_modified_time_;
+}
+
+void TestClipboard::ClearLastModifiedTime() {
+  last_modified_time_ = base::Time();
+}
+
+void TestClipboard::WriteObjects(ClipboardType type, const ObjectMap& objects) {
+  Clear(type);
+  default_store_type_ = type;
+  for (const auto& kv : objects)
+    DispatchObject(static_cast<ObjectType>(kv.first), kv.second);
+  default_store_type_ = CLIPBOARD_TYPE_COPY_PASTE;
+}
+
+void TestClipboard::WriteText(const char* text_data, size_t text_len) {
+  std::string text(text_data, text_len);
+  GetDefaultStore().data[ClipboardFormatType::GetPlainTextType()] = text;
+  // Create a dummy entry.
+  GetDefaultStore().data[ClipboardFormatType::GetPlainTextWType()];
+  if (IsSupportedClipboardType(CLIPBOARD_TYPE_SELECTION))
+    GetStore(CLIPBOARD_TYPE_SELECTION)
+        .data[ClipboardFormatType::GetPlainTextType()] = text;
+  ui::ClipboardMonitor::GetInstance()->NotifyClipboardDataChanged();
+}
+
+void TestClipboard::WriteHTML(const char* markup_data,
+                              size_t markup_len,
+                              const char* url_data,
+                              size_t url_len) {
+  base::string16 markup;
+  base::UTF8ToUTF16(markup_data, markup_len, &markup);
+  GetDefaultStore().data[ClipboardFormatType::GetHtmlType()] =
+      base::UTF16ToUTF8(markup);
+  GetDefaultStore().html_src_url = std::string(url_data, url_len);
+}
+
+void TestClipboard::WriteRTF(const char* rtf_data, size_t data_len) {
+  GetDefaultStore().data[ClipboardFormatType::GetRtfType()] =
+      std::string(rtf_data, data_len);
+}
+
+void TestClipboard::WriteBookmark(const char* title_data,
+                                  size_t title_len,
+                                  const char* url_data,
+                                  size_t url_len) {
+  GetDefaultStore().data[ClipboardFormatType::GetUrlWType()] =
+      std::string(url_data, url_len);
+  GetDefaultStore().url_title = std::string(title_data, title_len);
+}
+
+void TestClipboard::WriteWebSmartPaste() {
+  // Create a dummy entry.
+  GetDefaultStore().data[ClipboardFormatType::GetWebKitSmartPasteType()];
+}
+
+void TestClipboard::WriteBitmap(const SkBitmap& bitmap) {
+  // Create a dummy entry.
+  GetDefaultStore().data[ClipboardFormatType::GetBitmapType()];
+  SkBitmap& dst = GetDefaultStore().image;
+  // Either points bitmap at in_bitmap, or allocates and converts pixels.
+  if (!skia::SkBitmapToN32OpaqueOrPremul(bitmap, &dst)) {
+    NOTREACHED() << "Unable to convert bitmap for clipboard";
+    return;
+  }
+}
+
+void TestClipboard::WriteData(const ClipboardFormatType& format,
+                              const char* data_data,
+                              size_t data_len) {
+  GetDefaultStore().data[format] = std::string(data_data, data_len);
+}
+
+TestClipboard::DataStore::DataStore() : sequence_number(0) {}
+
+TestClipboard::DataStore::DataStore(const DataStore& other) = default;
+
+TestClipboard::DataStore::~DataStore() {}
+
+void TestClipboard::DataStore::Clear() {
+  data.clear();
+  url_title.clear();
+  html_src_url.clear();
+  image = SkBitmap();
+}
+
+const TestClipboard::DataStore& TestClipboard::GetStore(
+    ClipboardType type) const {
+  CHECK(IsSupportedClipboardType(type));
+  return stores_[type];
+}
+
+TestClipboard::DataStore& TestClipboard::GetStore(ClipboardType type) {
+  CHECK(IsSupportedClipboardType(type));
+  DataStore& store = stores_[type];
+  ++store.sequence_number;
+  return store;
+}
+
+const TestClipboard::DataStore& TestClipboard::GetDefaultStore() const {
+  return GetStore(default_store_type_);
+}
+
+TestClipboard::DataStore& TestClipboard::GetDefaultStore() {
+  return GetStore(default_store_type_);
+}
+
+}  // namespace ui
diff -BbuN a/ui/base/clipboard/test/test_clipboard.h b/ui/base/clipboard/test/test_clipboard.h
--- a/ui/base/clipboard/test/test_clipboard.h	1970-01-01 03:00:00.000000000 +0300
+++ b/ui/base/clipboard/test/test_clipboard.h	2019-02-20 20:48:23.472000000 +0300
@@ -0,0 +1,105 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_BASE_CLIPBOARD_TEST_TEST_CLIPBOARD_H_
+#define UI_BASE_CLIPBOARD_TEST_TEST_CLIPBOARD_H_
+
+#include <stddef.h>
+#include <stdint.h>
+
+#include <string>
+#include <vector>
+
+#include "base/containers/flat_map.h"
+#include "base/macros.h"
+#include "third_party/skia/include/core/SkBitmap.h"
+#include "ui/base/clipboard/clipboard.h"
+
+namespace ui {
+
+class TestClipboard : public Clipboard {
+ public:
+  TestClipboard();
+  ~TestClipboard() override;
+
+  // Creates and associates a TestClipboard with the current thread. When no
+  // longer needed, the returned clipboard must be freed by calling
+  // Clipboard::DestroyClipboardForCurrentThread() on the same thread.
+  static Clipboard* CreateForCurrentThread();
+
+  // Sets the time to be returned by GetLastModifiedTime();
+  void SetLastModifiedTime(const base::Time& time);
+
+  // Clipboard overrides.
+  void OnPreShutdown() override;
+  uint64_t GetSequenceNumber(ClipboardType type) const override;
+  bool IsFormatAvailable(const ClipboardFormatType& format,
+                         ClipboardType type) const override;
+  void Clear(ClipboardType type) override;
+  void ReadAvailableTypes(ClipboardType type,
+                          std::vector<base::string16>* types,
+                          bool* contains_filenames) const override;
+  void ReadText(ClipboardType type, base::string16* result) const override;
+  void ReadAsciiText(ClipboardType type, std::string* result) const override;
+  void ReadHTML(ClipboardType type,
+                base::string16* markup,
+                std::string* src_url,
+                uint32_t* fragment_start,
+                uint32_t* fragment_end) const override;
+  void ReadRTF(ClipboardType type, std::string* result) const override;
+  SkBitmap ReadImage(ClipboardType type) const override;
+  void ReadCustomData(ClipboardType clipboard_type,
+                      const base::string16& type,
+                      base::string16* result) const override;
+  void ReadBookmark(base::string16* title, std::string* url) const override;
+  void ReadData(const ClipboardFormatType& format,
+                std::string* result) const override;
+  base::Time GetLastModifiedTime() const override;
+  void ClearLastModifiedTime() override;
+  void WriteObjects(ClipboardType type, const ObjectMap& objects) override;
+  void WriteText(const char* text_data, size_t text_len) override;
+  void WriteHTML(const char* markup_data,
+                 size_t markup_len,
+                 const char* url_data,
+                 size_t url_len) override;
+  void WriteRTF(const char* rtf_data, size_t data_len) override;
+  void WriteBookmark(const char* title_data,
+                     size_t title_len,
+                     const char* url_data,
+                     size_t url_len) override;
+  void WriteWebSmartPaste() override;
+  void WriteBitmap(const SkBitmap& bitmap) override;
+  void WriteData(const ClipboardFormatType& format,
+                 const char* data_data,
+                 size_t data_len) override;
+
+ private:
+  struct DataStore {
+    DataStore();
+    DataStore(const DataStore& other);
+    ~DataStore();
+    void Clear();
+    uint64_t sequence_number;
+    base::flat_map<ClipboardFormatType, std::string> data;
+    std::string url_title;
+    std::string html_src_url;
+    SkBitmap image;
+  };
+
+  // The non-const versions increment the sequence number as a side effect.
+  const DataStore& GetStore(ClipboardType type) const;
+  const DataStore& GetDefaultStore() const;
+  DataStore& GetStore(ClipboardType type);
+  DataStore& GetDefaultStore();
+
+  ClipboardType default_store_type_;
+  mutable base::flat_map<ClipboardType, DataStore> stores_;
+  base::Time last_modified_time_;
+
+  DISALLOW_COPY_AND_ASSIGN(TestClipboard);
+};
+
+}  // namespace ui
+
+#endif  // UI_BASE_CLIPBOARD_TEST_TEST_CLIPBOARD_H_
diff -BbuN a/ui/base/clipboard/test/test_clipboard_unittest.cc b/ui/base/clipboard/test/test_clipboard_unittest.cc
--- a/ui/base/clipboard/test/test_clipboard_unittest.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/ui/base/clipboard/test/test_clipboard_unittest.cc	2019-02-20 20:48:23.472000000 +0300
@@ -0,0 +1,34 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/base/clipboard/test/test_clipboard.h"
+
+#include "testing/gtest/include/gtest/gtest.h"
+
+#if defined(USE_AURA)
+#include "ui/events/platform/platform_event_source.h"
+#endif
+
+namespace ui {
+
+struct TestClipboardTraits {
+#if defined(USE_AURA)
+  static std::unique_ptr<PlatformEventSource> GetEventSource() {
+    return nullptr;
+  }
+#endif
+
+  static Clipboard* Create() { return TestClipboard::CreateForCurrentThread(); }
+
+  static void Destroy(Clipboard* clipboard) {
+    ASSERT_EQ(Clipboard::GetForCurrentThread(), clipboard);
+    Clipboard::DestroyClipboardForCurrentThread();
+  }
+};
+
+typedef TestClipboardTraits TypesToTest;
+
+}  // namespace ui
+
+#include "ui/base/clipboard/clipboard_test_template.h"
--- a/ui/ozone/platform/wayland/wayland_cursor_position.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/ui/ozone/platform/wayland/wayland_cursor_position.cc	2019-02-20 20:48:24.068000000 +0300
@@ -0,0 +1,24 @@
+// Copyright 2019 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/ozone/platform/wayland/wayland_cursor_position.h"
+
+#include "ui/ozone/platform/wayland/wayland_connection.h"
+
+namespace ui {
+
+WaylandCursorPosition::WaylandCursorPosition() = default;
+
+WaylandCursorPosition::~WaylandCursorPosition() = default;
+
+void WaylandCursorPosition::OnCursorPositionChanged(
+    const gfx::Point& cursor_position) {
+  cursor_surface_point_ = cursor_position;
+}
+
+gfx::Point WaylandCursorPosition::GetCursorSurfacePoint() const {
+  return cursor_surface_point_;
+}
+
+}  // namespace ui
--- a/ui/ozone/platform/wayland/wayland_cursor_position.h	1970-01-01 03:00:00.000000000 +0300
+++ b/ui/ozone/platform/wayland/wayland_cursor_position.h	2019-02-20 20:48:24.068000000 +0300
@@ -0,0 +1,34 @@
+// Copyright 2019 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_OZONE_PLATFORM_WAYLAND_WAYLAND_CURSOR_POSITION_H_
+#define UI_OZONE_PLATFORM_WAYLAND_WAYLAND_CURSOR_POSITION_H_
+
+#include "base/macros.h"
+#include "ui/gfx/geometry/point.h"
+
+namespace ui {
+
+// Stores last known cursor pointer position in regards to top-level windows'
+// coordinates and returns it on request.
+class WaylandCursorPosition {
+ public:
+  WaylandCursorPosition();
+  ~WaylandCursorPosition();
+
+  void OnCursorPositionChanged(const gfx::Point& cursor_position);
+
+  // Returns last known cursor position in regards to top-level surface local
+  // coordinates. It is unknown what surface receives that cursor position.
+  gfx::Point GetCursorSurfacePoint() const;
+
+ private:
+  gfx::Point cursor_surface_point_;
+
+  DISALLOW_COPY_AND_ASSIGN(WaylandCursorPosition);
+};
+
+}  // namespace ui
+
+#endif  // UI_OZONE_PLATFORM_WAYLAND_WAYLAND_CURSOR_POSITION_H_
--- a/ui/ozone/public/platform_clipboard.h	1970-01-01 03:00:00.000000000 +0300
+++ b/ui/ozone/public/platform_clipboard.h	2019-02-20 20:48:24.084000000 +0300
@@ -0,0 +1,85 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_OZONE_PUBLIC_PLATFORM_CLIPBOARD_H_
+#define UI_OZONE_PUBLIC_PLATFORM_CLIPBOARD_H_
+
+#include <string>
+#include <unordered_map>
+#include <vector>
+
+#include "base/macros.h"
+#include "base/optional.h"
+#include "ui/ozone/ozone_base_export.h"
+
+namespace ui {
+
+// PlatformClipboard is an interface that allows Ozone backends to exchange
+// data with other applications on the host system. The most familiar use for
+// it is handling copy and paste operations.
+//
+class OZONE_BASE_EXPORT PlatformClipboard {
+ public:
+  // DataMap is a map from "mime type" to associated data, whereas
+  // the data can be organized differently for each mime type.
+  using Data = std::vector<uint8_t>;
+  using DataMap = std::unordered_map<std::string, Data>;
+
+  // SequenceNumberUpdateCb is a repeating callback, which can be used to tell
+  // a client of the PlatformClipboard to increment clipboard's sequence number
+  using SequenceNumberUpdateCb = base::RepeatingCallback<void()>;
+
+  // Offers a given clipboard data 'data_map' to the host system clipboard.
+  //
+  // It is common that host clipboard implementations simply get offered
+  // the set of mime types available for the data being shared. In such cases,
+  // the actual clipboard data is only 'transferred' to the consuming
+  // application asynchronously, upon an explicit request for data given a
+  // specific mime type. This is the case of Wayland compositors and MacOS
+  // (NSPasteboard), for example.
+  //
+  // The invoker assumes the Ozone implementation will not free |DataMap|
+  // before |OfferDataClosure| is called.
+  //
+  // OfferDataClosure should be invoked when the host clipboard implementation
+  // acknowledges that the "offer to clipboard" operation is performed.
+  using OfferDataClosure = base::OnceCallback<void()>;
+  virtual void OfferClipboardData(const DataMap& data_map,
+                                  OfferDataClosure callback) = 0;
+
+  // Reads data from host system clipboard given mime type. The data is
+  // stored in 'data_map'.
+  //
+  // RequestDataClosure is invoked to acknowledge that the requested clipboard
+  // data has been read and stored into 'data_map'.
+  using RequestDataClosure =
+      base::OnceCallback<void(const base::Optional<std::vector<uint8_t>>&)>;
+  virtual void RequestClipboardData(const std::string& mime_type,
+                                    DataMap* data_map,
+                                    RequestDataClosure callback) = 0;
+
+  // Gets the mime types of the data available for clipboard operations
+  // in the host system clipboard.
+  //
+  // GetMimeTypesClosure is invoked when the mime types available for clipboard
+  // operations are known.
+  using GetMimeTypesClosure =
+      base::OnceCallback<void(const std::vector<std::string>&)>;
+  virtual void GetAvailableMimeTypes(GetMimeTypesClosure callback) = 0;
+
+  // Returns true if the current application writing data to the host clipboard
+  // data is this one; false otherwise.
+  //
+  // It can be relevant to know this information in case the client wants to
+  // caches the clipboard data, and wants to know if it is possible to use
+  // the cached data in order to reply faster to read-clipboard operations.
+  virtual bool IsSelectionOwner() = 0;
+
+  // See comment above SequenceNumberUpdateCb. Can be called once.
+  virtual void SetSequenceNumberUpdateCb(SequenceNumberUpdateCb cb) = 0;
+};
+
+}  // namespace ui
+
+#endif  // UI_OZONE_PUBLIC_PLATFORM_CLIPBOARD_H_
