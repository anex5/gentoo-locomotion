--- a/ash/accelerators/accelerator_controller.cc	2019-05-01 01:22:25.000000000 +0300
+++ b/ash/accelerators/accelerator_controller.cc	2019-05-17 18:53:08.060000000 +0300
@@ -23,13 +23,13 @@
 #include "ash/focus_cycler.h"
 #include "ash/ime/ime_controller.h"
 #include "ash/ime/ime_switch_type.h"
-#include "ash/kiosk_next/kiosk_next_shell_controller.h"
 #include "ash/magnifier/docked_magnifier_controller.h"
 #include "ash/magnifier/magnification_controller.h"
 #include "ash/media/media_controller.h"
 #include "ash/metrics/user_metrics_recorder.h"
 #include "ash/multi_profile_uma.h"
 #include "ash/new_window_controller.h"
+#include "ash/public/cpp/app_list/app_list_constants.h"
 #include "ash/public/cpp/ash_features.h"
 #include "ash/public/cpp/notification_utils.h"
 #include "ash/public/interfaces/accessibility_controller.mojom.h"
@@ -510,8 +510,7 @@
   return true;
 }
 
-void HandleToggleAppList(const ui::Accelerator& accelerator,
-                         app_list::AppListShowSource show_source) {
+void HandleToggleAppList(const ui::Accelerator& accelerator) {
   if (accelerator.key_code() == ui::VKEY_LWIN)
     base::RecordAction(UserMetricsAction("Accel_Search_LWin"));
 
@@ -519,7 +518,7 @@
       display::Screen::GetScreen()
           ->GetDisplayNearestWindow(Shell::GetRootWindowForNewWindows())
           .id(),
-      show_source, accelerator.time_stamp());
+      app_list::kSearchKey, accelerator.time_stamp());
 }
 
 void HandleToggleFullscreen(const ui::Accelerator& accelerator) {
@@ -650,7 +649,8 @@
 }
 
 bool CanHandleStartVoiceInteraction() {
-  return chromeos::switches::IsAssistantEnabled();
+  return chromeos::switches::IsVoiceInteractionFlagsEnabled() ||
+         chromeos::switches::IsAssistantEnabled();
 }
 
 void HandleToggleVoiceInteraction(const ui::Accelerator& accelerator) {
@@ -711,7 +711,6 @@
     case mojom::AssistantAllowedState::DISALLOWED_BY_SUPERVISED_USER:
     case mojom::AssistantAllowedState::DISALLOWED_BY_CHILD_USER:
     case mojom::AssistantAllowedState::DISALLOWED_BY_INCOGNITO:
-    case mojom::AssistantAllowedState::DISALLOWED_BY_ACCOUNT_TYPE:
       // TODO(xiaohuic): show a specific toast.
       return;
     case mojom::AssistantAllowedState::ALLOWED:
@@ -726,7 +725,7 @@
 
 void HandleSuspend() {
   base::RecordAction(UserMetricsAction("Accel_Suspend"));
-  chromeos::PowerManagerClient::Get()->RequestSuspend();
+  chromeos::DBusThreadManager::Get()->GetPowerManagerClient()->RequestSuspend();
 }
 
 bool CanHandleCycleUser() {
@@ -807,6 +806,10 @@
       mojom::DictationToggleSource::kKeyboard);
 }
 
+bool CanHandleToggleDockedMagnifier() {
+  return features::IsDockedMagnifierEnabled();
+}
+
 bool CanHandleToggleOverview() {
   auto windows = Shell::Get()->mru_window_tracker()->BuildMruWindowList();
   // Do not toggle overview if there is a window being dragged.
@@ -851,6 +854,7 @@
 }
 
 void HandleToggleDockedMagnifier() {
+  DCHECK(features::IsDockedMagnifierEnabled());
   base::RecordAction(UserMetricsAction("Accel_Toggle_Docked_Magnifier"));
 
   DockedMagnifierController* docked_magnifier_controller =
@@ -989,7 +993,8 @@
 
 bool CanHandleActiveMagnifierZoom() {
   return Shell::Get()->magnification_controller()->IsEnabled() ||
-         Shell::Get()->docked_magnifier_controller()->GetEnabled();
+         (features::IsDockedMagnifierEnabled() &&
+          Shell::Get()->docked_magnifier_controller()->GetEnabled());
 }
 
 // Change the scale of the active magnifier.
@@ -999,7 +1004,8 @@
     return;
   }
 
-  if (Shell::Get()->docked_magnifier_controller()->GetEnabled()) {
+  if (features::IsDockedMagnifierEnabled() &&
+      Shell::Get()->docked_magnifier_controller()->GetEnabled()) {
     Shell::Get()->docked_magnifier_controller()->StepToNextScaleValue(
         delta_index);
   }
@@ -1177,10 +1183,6 @@
     actions_allowed_in_pinned_mode_.insert(
         kActionsAllowedInAppModeOrPinnedMode[i]);
   }
-  for (size_t i = 0; i < kActionsAllowedForKioskNextShellLength; i++) {
-    actions_allowed_for_kiosk_next_shell_.insert(
-        kActionsAllowedForKioskNextShell[i]);
-  }
   for (size_t i = 0; i < kActionsAllowedInPinnedModeLength; ++i)
     actions_allowed_in_pinned_mode_.insert(kActionsAllowedInPinnedMode[i]);
   for (size_t i = 0; i < kActionsNeedingWindowLength; ++i)
@@ -1266,6 +1268,7 @@
     case DEBUG_PRINT_LAYER_HIERARCHY:
     case DEBUG_PRINT_VIEW_HIERARCHY:
     case DEBUG_PRINT_WINDOW_HIERARCHY:
+    case DEBUG_SHOW_QUICK_LAUNCH:
     case DEBUG_SHOW_TOAST:
     case DEBUG_TOGGLE_DEVICE_SCALE_FACTOR:
     case DEBUG_TOGGLE_SHOW_DEBUG_BORDERS:
@@ -1314,7 +1317,6 @@
     case SWITCH_TO_NEXT_USER:
       return CanHandleCycleUser();
     case TOGGLE_APP_LIST:
-    case TOGGLE_APP_LIST_FULLSCREEN:
       return CanHandleToggleAppList(accelerator, previous_accelerator);
     case TOGGLE_CAPS_LOCK:
       return CanHandleToggleCapsLock(
@@ -1323,7 +1325,7 @@
     case TOGGLE_DICTATION:
       return CanHandleToggleDictation();
     case TOGGLE_DOCKED_MAGNIFIER:
-      return true;
+      return CanHandleToggleDockedMagnifier();
     case TOGGLE_FULLSCREEN_MAGNIFIER:
       return true;
     case TOGGLE_MESSAGE_CENTER_BUBBLE:
@@ -1434,6 +1436,7 @@
     case DEBUG_PRINT_LAYER_HIERARCHY:
     case DEBUG_PRINT_VIEW_HIERARCHY:
     case DEBUG_PRINT_WINDOW_HIERARCHY:
+    case DEBUG_SHOW_QUICK_LAUNCH:
     case DEBUG_SHOW_TOAST:
     case DEBUG_TOGGLE_DEVICE_SCALE_FACTOR:
       debug::PerformDebugActionIfEnabled(action);
@@ -1647,10 +1650,7 @@
       HandleTakeWindowScreenshot();
       break;
     case TOGGLE_APP_LIST:
-      HandleToggleAppList(accelerator, app_list::kSearchKey);
-      break;
-    case TOGGLE_APP_LIST_FULLSCREEN:
-      HandleToggleAppList(accelerator, app_list::kSearchKeyFullscreen);
+      HandleToggleAppList(accelerator);
       break;
     case TOGGLE_CAPS_LOCK:
       HandleToggleCapsLock();
@@ -1730,10 +1730,6 @@
 
 AcceleratorController::AcceleratorProcessingRestriction
 AcceleratorController::GetAcceleratorProcessingRestriction(int action) const {
-  if (Shell::Get()->kiosk_next_shell_controller()->IsEnabled() &&
-      actions_allowed_for_kiosk_next_shell_.count(action) == 0) {
-    return RESTRICTION_PREVENT_PROCESSING_AND_PROPAGATION;
-  }
   if (Shell::Get()->screen_pinning_controller()->IsPinned() &&
       actions_allowed_in_pinned_mode_.find(action) ==
           actions_allowed_in_pinned_mode_.end()) {
--- a/ash/accelerators/accelerator_controller.h	2019-05-01 01:22:25.000000000 +0300
+++ b/ash/accelerators/accelerator_controller.h	2019-05-17 18:53:08.060000000 +0300
@@ -17,7 +17,6 @@
 #include "ash/accelerators/exit_warning_handler.h"
 #include "ash/ash_export.h"
 #include "ash/public/interfaces/accelerator_controller.mojom.h"
-#include "ash/public/interfaces/volume.mojom.h"
 #include "base/compiler_specific.h"
 #include "base/gtest_prod_util.h"
 #include "base/macros.h"
@@ -237,8 +236,6 @@
   std::set<int> actions_allowed_in_app_mode_;
   // Actions allowed in pinned mode.
   std::set<int> actions_allowed_in_pinned_mode_;
-  // Actions allowed when Kiosk Next Shell is enabled.
-  std::set<int> actions_allowed_for_kiosk_next_shell_;
   // Actions disallowed if there are no windows.
   std::set<int> actions_needing_window_;
   // Actions that can be performed without closing the menu (if one is present).
--- a/ash/accelerators/accelerator_controller_unittest.cc	2019-05-01 01:22:25.000000000 +0300
+++ b/ash/accelerators/accelerator_controller_unittest.cc	2019-05-17 18:53:08.064000000 +0300
@@ -11,13 +11,13 @@
 #include "ash/accelerators/pre_target_accelerator_handler.h"
 #include "ash/accessibility/accessibility_controller.h"
 #include "ash/accessibility/test_accessibility_controller_client.h"
-#include "ash/app_list/app_list_metrics.h"
 #include "ash/app_list/test/app_list_test_helper.h"
 #include "ash/ime/ime_controller.h"
 #include "ash/ime/test_ime_controller_client.h"
 #include "ash/magnifier/docked_magnifier_controller.h"
 #include "ash/magnifier/magnification_controller.h"
 #include "ash/media/media_controller.h"
+#include "ash/public/cpp/ash_features.h"
 #include "ash/public/cpp/ash_switches.h"
 #include "ash/public/cpp/shell_window_ids.h"
 #include "ash/public/interfaces/ime_info.mojom.h"
@@ -41,17 +41,15 @@
 #include "base/optional.h"
 #include "base/run_loop.h"
 #include "base/stl_util.h"
-#include "base/test/metrics/histogram_tester.h"
 #include "base/test/metrics/user_action_tester.h"
+#include "base/test/scoped_feature_list.h"
 #include "media/base/media_switches.h"
 #include "services/media_session/public/cpp/test/test_media_controller.h"
-#include "services/media_session/public/mojom/media_session.mojom.h"
 #include "services/ws/public/mojom/window_tree_constants.mojom.h"
 #include "ui/aura/client/aura_constants.h"
 #include "ui/aura/test/test_window_delegate.h"
 #include "ui/aura/test/test_windows.h"
 #include "ui/aura/window.h"
-#include "ui/base/accelerators/media_keys_util.h"
 #include "ui/base/accelerators/test_accelerator_target.h"
 #include "ui/base/ime/chromeos/fake_ime_keyboard.h"
 #include "ui/base/ime/chromeos/ime_keyboard.h"
@@ -881,99 +879,6 @@
   GetAppListTestHelper()->CheckVisibility(true);
 }
 
-TEST_F(AcceleratorControllerTest, GlobalAcceleratorsToggleAppListFullscreen) {
-  base::HistogramTester histogram_tester;
-
-  int toggle_count_total = 0;
-  int toggle_count_regular = 0;
-  int toggle_count_fullscreen = 0;
-
-  // Shift+VKEY_BROWSER_SEARCH should toggle the AppList in fullscreen mode.
-  EXPECT_TRUE(ProcessInController(
-      ui::Accelerator(ui::VKEY_BROWSER_SEARCH, ui::EF_SHIFT_DOWN)));
-  base::RunLoop().RunUntilIdle();
-  GetAppListTestHelper()->CheckVisibility(true);
-  GetAppListTestHelper()->CheckState(
-      app_list::AppListViewState::FULLSCREEN_ALL_APPS);
-  histogram_tester.ExpectTotalCount(app_list::kAppListToggleMethodHistogram,
-                                    ++toggle_count_total);
-  histogram_tester.ExpectBucketCount(app_list::kAppListToggleMethodHistogram,
-                                     app_list::kSearchKeyFullscreen,
-                                     ++toggle_count_fullscreen);
-
-  EXPECT_TRUE(ProcessInController(
-      ui::Accelerator(ui::VKEY_BROWSER_SEARCH, ui::EF_SHIFT_DOWN)));
-  base::RunLoop().RunUntilIdle();
-  GetAppListTestHelper()->CheckVisibility(false);
-
-  // Shift+VKEY_BROWSER_SEARCH should transition from peeking to fullscreen
-  // mode.
-  EXPECT_TRUE(ProcessInController(
-      ui::Accelerator(ui::VKEY_BROWSER_SEARCH, ui::EF_NONE)));
-  base::RunLoop().RunUntilIdle();
-  GetAppListTestHelper()->CheckVisibility(true);
-  GetAppListTestHelper()->CheckState(app_list::AppListViewState::PEEKING);
-  histogram_tester.ExpectTotalCount(app_list::kAppListToggleMethodHistogram,
-                                    ++toggle_count_total);
-  histogram_tester.ExpectBucketCount(app_list::kAppListToggleMethodHistogram,
-                                     app_list::kSearchKey,
-                                     ++toggle_count_regular);
-
-  EXPECT_TRUE(ProcessInController(
-      ui::Accelerator(ui::VKEY_BROWSER_SEARCH, ui::EF_SHIFT_DOWN)));
-  base::RunLoop().RunUntilIdle();
-  GetAppListTestHelper()->CheckVisibility(true);
-  GetAppListTestHelper()->CheckState(
-      app_list::AppListViewState::FULLSCREEN_ALL_APPS);
-  histogram_tester.ExpectTotalCount(app_list::kAppListToggleMethodHistogram,
-                                    ++toggle_count_total);
-  histogram_tester.ExpectBucketCount(app_list::kAppListToggleMethodHistogram,
-                                     app_list::kSearchKeyFullscreen,
-                                     ++toggle_count_fullscreen);
-  // VKEY_BROWSER_SEARCH (no shift) should not return to peeking, but close the
-  // AppList.
-  EXPECT_TRUE(ProcessInController(
-      ui::Accelerator(ui::VKEY_BROWSER_SEARCH, ui::EF_NONE)));
-  base::RunLoop().RunUntilIdle();
-  GetAppListTestHelper()->CheckVisibility(false);
-
-  // Open AppList in peeking mode and type in the search box.
-  EXPECT_TRUE(ProcessInController(
-      ui::Accelerator(ui::VKEY_BROWSER_SEARCH, ui::EF_NONE)));
-  base::RunLoop().RunUntilIdle();
-  GetAppListTestHelper()->CheckVisibility(true);
-  GetAppListTestHelper()->CheckState(app_list::AppListViewState::PEEKING);
-  histogram_tester.ExpectTotalCount(app_list::kAppListToggleMethodHistogram,
-                                    ++toggle_count_total);
-  histogram_tester.ExpectBucketCount(app_list::kAppListToggleMethodHistogram,
-                                     app_list::kSearchKey,
-                                     ++toggle_count_regular);
-  ui::test::EventGenerator* generator = GetEventGenerator();
-  generator->PressKey(ui::VKEY_0, ui::EF_NONE);
-  generator->ReleaseKey(ui::VKEY_0, ui::EF_NONE);
-  base::RunLoop().RunUntilIdle();
-  GetAppListTestHelper()->CheckVisibility(true);
-  GetAppListTestHelper()->CheckState(app_list::AppListViewState::HALF);
-  // Shift+VKEY_BROWSER_SEARCH transitions to FULLSCREEN_SEARCH.
-  EXPECT_TRUE(ProcessInController(
-      ui::Accelerator(ui::VKEY_BROWSER_SEARCH, ui::EF_SHIFT_DOWN)));
-  base::RunLoop().RunUntilIdle();
-  GetAppListTestHelper()->CheckVisibility(true);
-  GetAppListTestHelper()->CheckState(
-      app_list::AppListViewState::FULLSCREEN_SEARCH);
-  histogram_tester.ExpectTotalCount(app_list::kAppListToggleMethodHistogram,
-                                    ++toggle_count_total);
-  histogram_tester.ExpectBucketCount(app_list::kAppListToggleMethodHistogram,
-                                     app_list::kSearchKeyFullscreen,
-                                     ++toggle_count_fullscreen);
-
-  // Shift+VKEY_BROWSER_SEARCH closes the AppList.
-  EXPECT_TRUE(ProcessInController(
-      ui::Accelerator(ui::VKEY_BROWSER_SEARCH, ui::EF_SHIFT_DOWN)));
-  base::RunLoop().RunUntilIdle();
-  GetAppListTestHelper()->CheckVisibility(false);
-}
-
 TEST_F(AcceleratorControllerTest, ImeGlobalAccelerators) {
   ASSERT_EQ(0u, Shell::Get()->ime_controller()->available_imes().size());
 
@@ -1564,6 +1469,14 @@
   MagnifiersAcceleratorsTester() = default;
   ~MagnifiersAcceleratorsTester() override = default;
 
+  // AcceleratorControllerTest:
+  void SetUp() override {
+    // Explicitly enable the Docked Magnifier feature for the tests.
+    scoped_feature_list_.InitAndEnableFeature(features::kDockedMagnifier);
+
+    AcceleratorControllerTest::SetUp();
+  }
+
   DockedMagnifierController* docked_magnifier_controller() const {
     return Shell::Get()->docked_magnifier_controller();
   }
@@ -1573,6 +1486,8 @@
   }
 
  private:
+  base::test::ScopedFeatureList scoped_feature_list_;
+
   DISALLOW_COPY_AND_ASSIGN(MagnifiersAcceleratorsTester);
 };
 
@@ -1664,8 +1579,7 @@
   // Runs the test with the media session service enabled.
   bool service_enabled;
 
-  // Runs the test with the supplied action enabled and will also send the media
-  // session info to the controller.
+  // Runs the test with the supplied action enabled.
   base::Optional<MediaSessionAction> with_action_enabled;
 
   // If true then we should expect the action will handle the media keys.
@@ -1706,13 +1620,10 @@
     media_controller->FlushForTesting();
   }
 
-  void MaybeEnableMediaSession(
-      media_session::mojom::MediaPlaybackState playback_state) {
+  void MaybeEnableAction() {
     if (!GetParam().with_action_enabled)
       return;
-
     SimulateActionsChanged(GetParam().with_action_enabled);
-    SimulatePlaybackState(playback_state);
   }
 
   void SimulateActionsChanged(base::Optional<MediaSessionAction> action) {
@@ -1735,36 +1646,16 @@
 
   bool eligible_action() const { return GetParam().eligible_action; }
 
-  void ExpectActionRecorded(ui::MediaHardwareKeyAction action) {
-    histogram_tester_.ExpectBucketCount(
-        ui::kMediaHardwareKeyActionHistogramName,
-        static_cast<base::HistogramBase::Sample>(action), 1);
-  }
-
  private:
-  void SimulatePlaybackState(
-      media_session::mojom::MediaPlaybackState playback_state) {
-    media_session::mojom::MediaSessionInfoPtr session_info(
-        media_session::mojom::MediaSessionInfo::New());
-
-    session_info->state =
-        media_session::mojom::MediaSessionInfo::SessionState::kActive;
-    session_info->playback_state = playback_state;
-
-    controller()->SimulateMediaSessionInfoChanged(std::move(session_info));
-    controller()->Flush();
-  }
-
   std::unique_ptr<TestMediaClient> client_;
   std::unique_ptr<media_session::test::TestMediaController> controller_;
 
-  base::HistogramTester histogram_tester_;
   base::test::ScopedFeatureList scoped_feature_list_;
 
   DISALLOW_COPY_AND_ASSIGN(MediaSessionAcceleratorTest);
 };
 
-INSTANTIATE_TEST_SUITE_P(
+INSTANTIATE_TEST_CASE_P(
     ,
     MediaSessionAcceleratorTest,
     testing::Values(
@@ -1830,7 +1721,7 @@
 }
 
 TEST_P(MediaSessionAcceleratorTest, MediaGlobalAccelerators_NextTrack) {
-  MaybeEnableMediaSession(media_session::mojom::MediaPlaybackState::kPaused);
+  MaybeEnableAction();
 
   EXPECT_EQ(0, client()->handle_media_next_track_count());
   EXPECT_EQ(0, controller()->next_track_count());
@@ -1845,64 +1736,28 @@
     EXPECT_EQ(1, client()->handle_media_next_track_count());
     EXPECT_EQ(0, controller()->next_track_count());
   }
-
-  ExpectActionRecorded(ui::MediaHardwareKeyAction::kNextTrack);
-}
-
-TEST_P(MediaSessionAcceleratorTest, MediaGlobalAccelerators_Play) {
-  MaybeEnableMediaSession(media_session::mojom::MediaPlaybackState::kPaused);
-
-  EXPECT_EQ(0, client()->handle_media_play_pause_count());
-  EXPECT_EQ(0, controller()->resume_count());
-
-  ProcessInController(ui::Accelerator(ui::VKEY_MEDIA_PLAY_PAUSE, ui::EF_NONE));
-  Shell::Get()->media_controller()->FlushForTesting();
-
-  if (service_enabled() && eligible_action()) {
-    EXPECT_EQ(0, client()->handle_media_play_pause_count());
-    EXPECT_EQ(1, controller()->resume_count());
-
-    // If media session handles the key then we should always know the playback
-    // state so we can record a more granular action.
-    ExpectActionRecorded(ui::MediaHardwareKeyAction::kPlay);
-  } else {
-    EXPECT_EQ(1, client()->handle_media_play_pause_count());
-    EXPECT_EQ(0, controller()->resume_count());
-
-    // If we pass through to the client we don't know whether the action will
-    // play or pause so we should record a generic "play/pause" action.
-    ExpectActionRecorded(ui::MediaHardwareKeyAction::kPlayPause);
-  }
 }
 
-TEST_P(MediaSessionAcceleratorTest, MediaGlobalAccelerators_Pause) {
-  MaybeEnableMediaSession(media_session::mojom::MediaPlaybackState::kPlaying);
+TEST_P(MediaSessionAcceleratorTest, MediaGlobalAccelerators_PlayPause) {
+  MaybeEnableAction();
 
   EXPECT_EQ(0, client()->handle_media_play_pause_count());
-  EXPECT_EQ(0, controller()->suspend_count());
+  EXPECT_EQ(0, controller()->toggle_suspend_resume_count());
 
   ProcessInController(ui::Accelerator(ui::VKEY_MEDIA_PLAY_PAUSE, ui::EF_NONE));
   Shell::Get()->media_controller()->FlushForTesting();
 
   if (service_enabled() && eligible_action()) {
     EXPECT_EQ(0, client()->handle_media_play_pause_count());
-    EXPECT_EQ(1, controller()->suspend_count());
-
-    // If media session handles the key then we should always know the playback
-    // state so we can record a more granular action.
-    ExpectActionRecorded(ui::MediaHardwareKeyAction::kPause);
+    EXPECT_EQ(1, controller()->toggle_suspend_resume_count());
   } else {
     EXPECT_EQ(1, client()->handle_media_play_pause_count());
-    EXPECT_EQ(0, controller()->suspend_count());
-
-    // If we pass through to the client we don't know whether the action will
-    // play or pause so we should record a generic "play/pause" action.
-    ExpectActionRecorded(ui::MediaHardwareKeyAction::kPlayPause);
+    EXPECT_EQ(0, controller()->toggle_suspend_resume_count());
   }
 }
 
 TEST_P(MediaSessionAcceleratorTest, MediaGlobalAccelerators_PrevTrack) {
-  MaybeEnableMediaSession(media_session::mojom::MediaPlaybackState::kPaused);
+  MaybeEnableAction();
 
   EXPECT_EQ(0, client()->handle_media_prev_track_count());
   EXPECT_EQ(0, controller()->previous_track_count());
@@ -1917,64 +1772,62 @@
     EXPECT_EQ(1, client()->handle_media_prev_track_count());
     EXPECT_EQ(0, controller()->previous_track_count());
   }
-
-  ExpectActionRecorded(ui::MediaHardwareKeyAction::kPreviousTrack);
 }
 
 TEST_P(MediaSessionAcceleratorTest,
        MediaGlobalAccelerators_UpdateAction_Disable) {
-  MaybeEnableMediaSession(media_session::mojom::MediaPlaybackState::kPaused);
+  MaybeEnableAction();
 
-  EXPECT_EQ(0, client()->handle_media_next_track_count());
-  EXPECT_EQ(0, controller()->next_track_count());
+  EXPECT_EQ(0, client()->handle_media_play_pause_count());
+  EXPECT_EQ(0, controller()->toggle_suspend_resume_count());
 
-  ProcessInController(ui::Accelerator(ui::VKEY_MEDIA_NEXT_TRACK, ui::EF_NONE));
+  ProcessInController(ui::Accelerator(ui::VKEY_MEDIA_PLAY_PAUSE, ui::EF_NONE));
   Shell::Get()->media_controller()->FlushForTesting();
 
   if (service_enabled() && eligible_action()) {
-    EXPECT_EQ(0, client()->handle_media_next_track_count());
-    EXPECT_EQ(1, controller()->next_track_count());
+    EXPECT_EQ(0, client()->handle_media_play_pause_count());
+    EXPECT_EQ(1, controller()->toggle_suspend_resume_count());
   } else {
-    EXPECT_EQ(1, client()->handle_media_next_track_count());
-    EXPECT_EQ(0, controller()->next_track_count());
+    EXPECT_EQ(1, client()->handle_media_play_pause_count());
+    EXPECT_EQ(0, controller()->toggle_suspend_resume_count());
   }
 
   SimulateActionsChanged(base::nullopt);
 
-  ProcessInController(ui::Accelerator(ui::VKEY_MEDIA_NEXT_TRACK, ui::EF_NONE));
+  ProcessInController(ui::Accelerator(ui::VKEY_MEDIA_PLAY_PAUSE, ui::EF_NONE));
   Shell::Get()->media_controller()->FlushForTesting();
 
   if (service_enabled() && eligible_action()) {
-    EXPECT_EQ(1, client()->handle_media_next_track_count());
-    EXPECT_EQ(1, controller()->next_track_count());
+    EXPECT_EQ(1, client()->handle_media_play_pause_count());
+    EXPECT_EQ(1, controller()->toggle_suspend_resume_count());
   } else {
-    EXPECT_EQ(2, client()->handle_media_next_track_count());
-    EXPECT_EQ(0, controller()->next_track_count());
+    EXPECT_EQ(2, client()->handle_media_play_pause_count());
+    EXPECT_EQ(0, controller()->toggle_suspend_resume_count());
   }
 }
 
 TEST_P(MediaSessionAcceleratorTest,
        MediaGlobalAccelerators_UpdateAction_Enable) {
-  EXPECT_EQ(0, client()->handle_media_next_track_count());
-  EXPECT_EQ(0, controller()->next_track_count());
+  EXPECT_EQ(0, client()->handle_media_play_pause_count());
+  EXPECT_EQ(0, controller()->toggle_suspend_resume_count());
 
-  ProcessInController(ui::Accelerator(ui::VKEY_MEDIA_NEXT_TRACK, ui::EF_NONE));
+  ProcessInController(ui::Accelerator(ui::VKEY_MEDIA_PLAY_PAUSE, ui::EF_NONE));
   Shell::Get()->media_controller()->FlushForTesting();
 
-  EXPECT_EQ(1, client()->handle_media_next_track_count());
-  EXPECT_EQ(0, controller()->next_track_count());
+  EXPECT_EQ(1, client()->handle_media_play_pause_count());
+  EXPECT_EQ(0, controller()->toggle_suspend_resume_count());
 
-  MaybeEnableMediaSession(media_session::mojom::MediaPlaybackState::kPaused);
+  MaybeEnableAction();
 
-  ProcessInController(ui::Accelerator(ui::VKEY_MEDIA_NEXT_TRACK, ui::EF_NONE));
+  ProcessInController(ui::Accelerator(ui::VKEY_MEDIA_PLAY_PAUSE, ui::EF_NONE));
   Shell::Get()->media_controller()->FlushForTesting();
 
   if (service_enabled() && eligible_action()) {
-    EXPECT_EQ(1, client()->handle_media_next_track_count());
-    EXPECT_EQ(1, controller()->next_track_count());
+    EXPECT_EQ(1, client()->handle_media_play_pause_count());
+    EXPECT_EQ(1, controller()->toggle_suspend_resume_count());
   } else {
-    EXPECT_EQ(2, client()->handle_media_next_track_count());
-    EXPECT_EQ(0, controller()->next_track_count());
+    EXPECT_EQ(2, client()->handle_media_play_pause_count());
+    EXPECT_EQ(0, controller()->toggle_suspend_resume_count());
   }
 }
 
--- a/ash/accelerators/accelerator_table.cc	2019-05-01 01:22:25.000000000 +0300
+++ b/ash/accelerators/accelerator_table.cc	2019-05-17 18:53:08.064000000 +0300
@@ -75,6 +75,7 @@
     {true, ui::VKEY_O, kDebugModifier, DEBUG_SHOW_TOAST},
     {true, ui::VKEY_P, ui::EF_COMMAND_DOWN | ui::EF_SHIFT_DOWN,
      DEBUG_TOGGLE_TOUCH_PAD},
+    {true, ui::VKEY_Q, kDebugModifier, DEBUG_SHOW_QUICK_LAUNCH},
     {true, ui::VKEY_T, ui::EF_COMMAND_DOWN | ui::EF_SHIFT_DOWN,
      DEBUG_TOGGLE_TOUCH_SCREEN},
     {true, ui::VKEY_T, kDebugModifier, DEBUG_TOGGLE_TABLET_MODE},
@@ -356,7 +357,6 @@
     TAKE_SCREENSHOT,
     TAKE_WINDOW_SCREENSHOT,
     TOGGLE_APP_LIST,
-    TOGGLE_APP_LIST_FULLSCREEN,
     TOGGLE_CAPS_LOCK,
     TOGGLE_DICTATION,
     TOGGLE_DOCKED_MAGNIFIER,
@@ -372,28 +372,4 @@
 const size_t kActionsKeepingMenuOpenLength =
     base::size(kActionsKeepingMenuOpen);
 
-const AcceleratorAction kActionsAllowedForKioskNextShell[] = {
-    BRIGHTNESS_DOWN,
-    BRIGHTNESS_UP,
-    KEYBOARD_BRIGHTNESS_DOWN,
-    KEYBOARD_BRIGHTNESS_UP,
-    MEDIA_NEXT_TRACK,
-    MEDIA_PLAY_PAUSE,
-    MEDIA_PREV_TRACK,
-    POWER_PRESSED,
-    POWER_RELEASED,
-    TOGGLE_CAPS_LOCK,
-    TOGGLE_DICTATION,
-    TOGGLE_DOCKED_MAGNIFIER,
-    TOGGLE_FULLSCREEN_MAGNIFIER,
-    TOGGLE_HIGH_CONTRAST,
-    TOGGLE_SPOKEN_FEEDBACK,
-    VOLUME_DOWN,
-    VOLUME_MUTE,
-    VOLUME_UP,
-};
-
-const size_t kActionsAllowedForKioskNextShellLength =
-    base::size(kActionsAllowedForKioskNextShell);
-
 }  // namespace ash
--- a/ash/accelerators/accelerator_table.h	2019-05-01 01:22:25.000000000 +0300
+++ b/ash/accelerators/accelerator_table.h	2019-05-17 18:53:08.064000000 +0300
@@ -155,10 +155,6 @@
 ASH_EXPORT extern const AcceleratorAction kActionsKeepingMenuOpen[];
 ASH_EXPORT extern const size_t kActionsKeepingMenuOpenLength;
 
-// Actions that can be performed when the Kiosk Next Shell is enabled.
-ASH_EXPORT extern const AcceleratorAction kActionsAllowedForKioskNextShell[];
-ASH_EXPORT extern const size_t kActionsAllowedForKioskNextShellLength;
-
 }  // namespace ash
 
 #endif  // ASH_ACCELERATORS_ACCELERATOR_TABLE_H_
--- a/ash/accelerators/accelerator_table_unittest.cc	2019-05-01 01:22:25.000000000 +0300
+++ b/ash/accelerators/accelerator_table_unittest.cc	2019-05-17 18:53:08.064000000 +0300
@@ -17,10 +17,10 @@
 namespace {
 
 // The number of non-Search-based accelerators.
-constexpr int kNonSearchAcceleratorsNum = 91;
+constexpr int kNonSearchAcceleratorsNum = 89;
 // The hash of non-Search-based accelerators. See HashAcceleratorData().
 constexpr char kNonSearchAcceleratorsHash[] =
-    "5b2317174d8863dc27000162f4ed2287";
+    "bb35892635c794d78a20ff5f8a051aab";
 
 struct Cmp {
   bool operator()(const AcceleratorData& lhs,
--- a/ash/accelerators/accelerator_unittest.cc	2019-05-01 01:22:25.000000000 +0300
+++ b/ash/accelerators/accelerator_unittest.cc	2019-05-17 18:53:08.064000000 +0300
@@ -1,207 +1,22 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
+// Copyright 2018 The Chromium Authors. All rights reserved.
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "ui/base/accelerators/accelerator.h"
 #include "ash/accelerators/accelerator_controller.h"
-
-#include "ash/app_list/test/app_list_test_helper.h"
 #include "ash/shell.h"
-#include "ash/shell_observer.h"
-#include "ash/system/network/network_observer.h"
-#include "ash/system/tray/system_tray_notifier.h"
 #include "ash/test/ash_test_base.h"
-#include "ash/test/ui_controls_factory_ash.h"
-#include "ash/test_screenshot_delegate.h"
-#include "ash/wm/overview/overview_controller.h"
-#include "ash/wm/overview/overview_observer.h"
-#include "ash/wm/window_state.h"
-#include "ash/wm/window_util.h"
-#include "base/run_loop.h"
-#include "base/test/metrics/user_action_tester.h"
-#include "chromeos/network/network_handler.h"
 #include "services/ws/public/mojom/window_tree_constants.mojom.h"
 #include "services/ws/test_window_tree_client.h"
 #include "ui/aura/window.h"
-#include "ui/base/accelerators/accelerator.h"
 #include "ui/base/accelerators/test_accelerator_target.h"
-#include "ui/base/test/ui_controls.h"
 #include "ui/events/event.h"
 #include "ui/events/test/event_generator.h"
 
 namespace ash {
+namespace accelerators {
 
-namespace {
-
-// A network observer to watch for the toggle wifi events.
-class TestNetworkObserver : public NetworkObserver {
- public:
-  TestNetworkObserver() = default;
-  ~TestNetworkObserver() override = default;
-
-  // ash::NetworkObserver:
-  void RequestToggleWifi() override {
-    wifi_enabled_status_ = !wifi_enabled_status_;
-  }
-
-  bool wifi_enabled_status() const { return wifi_enabled_status_; }
-
- private:
-  bool wifi_enabled_status_ = false;
-
-  DISALLOW_COPY_AND_ASSIGN(TestNetworkObserver);
-};
-
-}  // namespace
-
-////////////////////////////////////////////////////////////////////////////////
-
-// This is intended to test few samples from each category of accelerators to
-// make sure they work properly. The test is done as an interactive ui test
-// using ui_controls::Send*() functions.
-// This is to catch any future regressions (crbug.com/469235).
-class AcceleratorTest : public AshTestBase, public OverviewObserver {
- public:
-  AcceleratorTest() : is_in_overview_mode_(false) {}
-
-  void SetUp() override {
-    ui_controls::InstallUIControlsAura(test::CreateAshUIControls());
-
-    AshTestBase::SetUp();
-
-    Shell::Get()->overview_controller()->AddObserver(this);
-
-    chromeos::NetworkHandler::Initialize();
-  }
-
-  void TearDown() override {
-    chromeos::NetworkHandler::Shutdown();
-
-    Shell::Get()->overview_controller()->RemoveObserver(this);
-
-    AshTestBase::TearDown();
-
-    ui_controls::InstallUIControlsAura(nullptr);
-  }
-
-  // Sends a key press event and waits synchronously until it's completely
-  // processed.
-  void SendKeyPressSync(ui::KeyboardCode key,
-                        bool control,
-                        bool shift,
-                        bool alt) {
-    base::RunLoop loop;
-    ui_controls::SendKeyPressNotifyWhenDone(Shell::GetPrimaryRootWindow(), key,
-                                            control, shift, alt, false,
-                                            loop.QuitClosure());
-    loop.Run();
-  }
-
-  // OverviewObserver:
-  void OnOverviewModeStarting() override { is_in_overview_mode_ = true; }
-  void OnOverviewModeEnded() override { is_in_overview_mode_ = false; }
-
- protected:
-  bool is_in_overview_mode_;
-
- private:
-  DISALLOW_COPY_AND_ASSIGN(AcceleratorTest);
-};
-
-////////////////////////////////////////////////////////////////////////////////
-
-// Tests a sample of accelerators.
-TEST_F(AcceleratorTest, Basic) {
-  // Test TAKE_SCREENSHOT and TAKE_PARTIAL_SCREENSHOT.
-  TestScreenshotDelegate* screenshot_delegate = GetScreenshotDelegate();
-  screenshot_delegate->set_can_take_screenshot(true);
-  EXPECT_EQ(0, screenshot_delegate->handle_take_screenshot_count());
-  SendKeyPressSync(ui::VKEY_MEDIA_LAUNCH_APP1, true, false, false);
-  EXPECT_EQ(1, screenshot_delegate->handle_take_screenshot_count());
-  SendKeyPressSync(ui::VKEY_SNAPSHOT, false, false, false);
-  EXPECT_EQ(2, screenshot_delegate->handle_take_screenshot_count());
-  SendKeyPressSync(ui::VKEY_MEDIA_LAUNCH_APP1, true, true, false);
-  EXPECT_EQ(2, screenshot_delegate->handle_take_screenshot_count());
-  // Press ESC to go out of the partial screenshot mode.
-  SendKeyPressSync(ui::VKEY_ESCAPE, false, false, false);
-
-  // Test VOLUME_MUTE.
-  base::UserActionTester user_action_tester;
-  EXPECT_EQ(0, user_action_tester.GetActionCount("Accel_VolumeMute_F8"));
-  SendKeyPressSync(ui::VKEY_VOLUME_MUTE, false, false, false);
-  EXPECT_EQ(1, user_action_tester.GetActionCount("Accel_VolumeMute_F8"));
-  // Test VOLUME_DOWN.
-  EXPECT_EQ(0, user_action_tester.GetActionCount("Accel_VolumeDown_F9"));
-  SendKeyPressSync(ui::VKEY_VOLUME_DOWN, false, false, false);
-  EXPECT_EQ(1, user_action_tester.GetActionCount("Accel_VolumeDown_F9"));
-  // Test VOLUME_UP.
-  EXPECT_EQ(0, user_action_tester.GetActionCount("Accel_VolumeUp_F10"));
-  SendKeyPressSync(ui::VKEY_VOLUME_UP, false, false, false);
-  EXPECT_EQ(1, user_action_tester.GetActionCount("Accel_VolumeUp_F10"));
-
-  // Test TOGGLE_WIFI.
-  TestNetworkObserver network_observer;
-  Shell::Get()->system_tray_notifier()->AddNetworkObserver(&network_observer);
-
-  EXPECT_FALSE(network_observer.wifi_enabled_status());
-  SendKeyPressSync(ui::VKEY_WLAN, false, false, false);
-  EXPECT_TRUE(network_observer.wifi_enabled_status());
-  SendKeyPressSync(ui::VKEY_WLAN, false, false, false);
-  EXPECT_FALSE(network_observer.wifi_enabled_status());
-
-  Shell::Get()->system_tray_notifier()->RemoveNetworkObserver(
-      &network_observer);
-}
-
-// Tests a sample of the non-repeatable accelerators that need windows to be
-// enabled.
-TEST_F(AcceleratorTest, NonRepeatableNeedingWindowActions) {
-  // Create a bunch of windows to work with.
-  aura::Window* window_1 =
-      CreateTestWindowInShellWithBounds(gfx::Rect(0, 0, 100, 100));
-  aura::Window* window_2 =
-      CreateTestWindowInShellWithBounds(gfx::Rect(0, 0, 100, 100));
-  window_1->Show();
-  wm::ActivateWindow(window_1);
-  window_2->Show();
-  wm::ActivateWindow(window_2);
-
-  // Test TOGGLE_OVERVIEW.
-  EXPECT_FALSE(is_in_overview_mode_);
-  SendKeyPressSync(ui::VKEY_MEDIA_LAUNCH_APP1, false, false, false);
-  EXPECT_TRUE(is_in_overview_mode_);
-  SendKeyPressSync(ui::VKEY_MEDIA_LAUNCH_APP1, false, false, false);
-  EXPECT_FALSE(is_in_overview_mode_);
-
-  // Test CYCLE_FORWARD_MRU and CYCLE_BACKWARD_MRU.
-  wm::ActivateWindow(window_1);
-  EXPECT_TRUE(wm::IsActiveWindow(window_1));
-  EXPECT_FALSE(wm::IsActiveWindow(window_2));
-  SendKeyPressSync(ui::VKEY_TAB, false, false, true);  // CYCLE_FORWARD_MRU.
-  EXPECT_TRUE(wm::IsActiveWindow(window_2));
-  EXPECT_FALSE(wm::IsActiveWindow(window_1));
-  SendKeyPressSync(ui::VKEY_TAB, false, true, true);  // CYCLE_BACKWARD_MRU.
-  EXPECT_TRUE(wm::IsActiveWindow(window_1));
-  EXPECT_FALSE(wm::IsActiveWindow(window_2));
-
-  // Test TOGGLE_FULLSCREEN.
-  wm::WindowState* active_window_state = wm::GetActiveWindowState();
-  EXPECT_FALSE(active_window_state->IsFullscreen());
-  SendKeyPressSync(ui::VKEY_MEDIA_LAUNCH_APP2, false, false, false);
-  EXPECT_TRUE(active_window_state->IsFullscreen());
-  SendKeyPressSync(ui::VKEY_MEDIA_LAUNCH_APP2, false, false, false);
-  EXPECT_FALSE(active_window_state->IsFullscreen());
-}
-
-// Tests the app list accelerator.
-TEST_F(AcceleratorTest, ToggleAppList) {
-  GetAppListTestHelper()->CheckVisibility(false);
-  SendKeyPressSync(ui::VKEY_LWIN, false, false, false);
-  base::RunLoop().RunUntilIdle();
-  GetAppListTestHelper()->CheckVisibility(true);
-  SendKeyPressSync(ui::VKEY_LWIN, false, false, false);
-  base::RunLoop().RunUntilIdle();
-  GetAppListTestHelper()->CheckVisibility(false);
-}
+using AcceleratorTest = AshTestBase;
 
 // This is meant to exercise an end to end test of an accelerator that happens
 // *after* the remote client is given a chance to handle it.
@@ -230,4 +45,5 @@
   EXPECT_EQ(1, test_target.accelerator_count());
 }
 
+}  // namespace accelerators
 }  // namespace ash
--- a/ash/accelerators/ash_focus_manager_factory.cc	2019-05-01 01:22:25.000000000 +0300
+++ b/ash/accelerators/ash_focus_manager_factory.cc	2019-05-17 18:53:08.064000000 +0300
@@ -9,6 +9,7 @@
 #include "ash/accelerators/accelerator_controller.h"
 #include "ash/magnifier/docked_magnifier_controller.h"
 #include "ash/magnifier/magnification_controller.h"
+#include "ash/public/cpp/ash_features.h"
 #include "ash/shell.h"
 #include "ui/base/ime/text_input_client.h"
 #include "ui/views/focus/focus_manager.h"
@@ -59,7 +60,8 @@
 
   gfx::Point point_of_interest = bounds_in_screen.CenterPoint();
   const ui::InputMethod* input_method = focused_now->GetInputMethod();
-  const bool docked_magnifier_enabled = docked_magnifier->GetEnabled();
+  const bool docked_magnifier_enabled =
+      features::IsDockedMagnifierEnabled() && docked_magnifier->GetEnabled();
   if (input_method && input_method->GetTextInputClient() &&
       input_method->GetTextInputClient()->GetTextInputType() !=
           ui::TEXT_INPUT_TYPE_NONE) {
--- a/ash/accelerators/debug_commands.cc	2019-05-01 01:22:25.000000000 +0300
+++ b/ash/accelerators/debug_commands.cc	2019-05-17 18:53:08.064000000 +0300
@@ -5,6 +5,7 @@
 #include "ash/accelerators/debug_commands.h"
 
 #include "ash/accelerators/accelerator_commands.h"
+#include "ash/components/quick_launch/public/mojom/constants.mojom.h"
 #include "ash/public/cpp/ash_switches.h"
 #include "ash/root_window_controller.h"
 #include "ash/shell.h"
@@ -146,6 +147,12 @@
   }
 }
 
+void HandleShowQuickLaunch() {
+  // TODO(https://crbug.com/904148): This should not use |WarmService()|.
+  Shell::Get()->connector()->WarmService(service_manager::ServiceFilter::ByName(
+      quick_launch::mojom::kServiceName));
+}
+
 gfx::ImageSkia CreateWallpaperImage(SkColor fill, SkColor rect) {
   // TODO(oshima): Consider adding a command line option to control wallpaper
   // images for testing. The size is randomly picked.
@@ -177,19 +184,19 @@
     case 1:
       wallpaper_controller->ShowWallpaperImage(
           CreateWallpaperImage(SK_ColorRED, SK_ColorBLUE), info,
-          /*preview_mode=*/false, /*always_on_top=*/false);
+          false /*preview_mode=*/);
       break;
     case 2:
       info.layout = WALLPAPER_LAYOUT_CENTER;
       wallpaper_controller->ShowWallpaperImage(
           CreateWallpaperImage(SK_ColorBLUE, SK_ColorGREEN), info,
-          /*preview_mode=*/false, /*always_on_top=*/false);
+          false /*preview_mode=*/);
       break;
     case 3:
       info.layout = WALLPAPER_LAYOUT_CENTER_CROPPED;
       wallpaper_controller->ShowWallpaperImage(
           CreateWallpaperImage(SK_ColorGREEN, SK_ColorRED), info,
-          /*preview_mode=*/false, /*always_on_top=*/false);
+          false /*preview_mode=*/);
       break;
   }
 }
@@ -214,7 +221,7 @@
 }
 
 void HandleTriggerCrash() {
-  LOG(FATAL) << "Intentional crash via debug accelerator.";
+  CHECK(false) << "Intentional crash via debug accelerator.";
 }
 
 }  // namespace
@@ -252,6 +259,9 @@
     case DEBUG_PRINT_WINDOW_HIERARCHY:
       HandlePrintWindowHierarchy();
       break;
+    case DEBUG_SHOW_QUICK_LAUNCH:
+      HandleShowQuickLaunch();
+      break;
     case DEBUG_SHOW_TOAST:
       Shell::Get()->toast_manager()->Show(
           ToastData("id", base::ASCIIToUTF16("Toast"), 5000 /* duration_ms */,
--- a/ash/accelerators/key_hold_detector.cc	2019-05-01 01:22:25.000000000 +0300
+++ b/ash/accelerators/key_hold_detector.cc	2019-05-17 18:53:08.064000000 +0300
@@ -7,7 +7,6 @@
 #include <utility>
 
 #include "ash/shell.h"
-#include "base/bind.h"
 #include "base/threading/thread_task_runner_handle.h"
 #include "ui/aura/window_tracker.h"
 #include "ui/aura/window_tree_host.h"
@@ -37,7 +36,7 @@
 
   base::ThreadTaskRunnerHandle::Get()->PostTask(
       FROM_HERE,
-      base::BindOnce(&DispatchPressedEvent, pressed_event, std::move(tracker)));
+      base::Bind(&DispatchPressedEvent, pressed_event, base::Passed(&tracker)));
 }
 
 }  // namespace
--- a/ash/accelerometer/accelerometer_reader.cc	2019-05-01 01:22:25.000000000 +0300
+++ b/ash/accelerometer/accelerometer_reader.cc	2019-05-17 18:53:08.064000000 +0300
@@ -15,7 +15,6 @@
 #include "base/files/file_util.h"
 #include "base/location.h"
 #include "base/memory/singleton.h"
-#include "base/observer_list_threadsafe.h"
 #include "base/sequenced_task_runner.h"
 #include "base/single_thread_task_runner.h"
 #include "base/stl_util.h"
--- a/ash/accelerometer/accelerometer_reader.h	2019-05-01 01:22:25.000000000 +0300
+++ b/ash/accelerometer/accelerometer_reader.h	2019-05-17 18:53:08.064000000 +0300
@@ -9,6 +9,7 @@
 #include "ash/ash_export.h"
 #include "base/macros.h"
 #include "base/memory/ref_counted.h"
+#include "base/observer_list_threadsafe.h"
 
 namespace base {
 template <typename T>
--- a/ash/accessibility/accessibility_controller.cc	2019-05-01 01:22:25.000000000 +0300
+++ b/ash/accessibility/accessibility_controller.cc	2019-05-17 18:53:08.064000000 +0300
@@ -29,7 +29,6 @@
 #include "ash/system/power/power_status.h"
 #include "ash/system/power/scoped_backlights_forced_off.h"
 #include "ash/wm/tablet_mode/tablet_mode_controller.h"
-#include "base/bind.h"
 #include "base/command_line.h"
 #include "base/metrics/user_metrics.h"
 #include "base/strings/string16.h"
@@ -975,7 +974,7 @@
   int movement_threshold = active_user_prefs_->GetInteger(
       prefs::kAccessibilityAutoclickMovementThreshold);
 
-  Shell::Get()->autoclick_controller()->SetMovementThreshold(
+  Shell::Get()->autoclick_controller()->set_movement_threshold(
       movement_threshold);
 }
 
--- a/ash/accessibility/accessibility_controller_unittest.cc	2019-05-01 01:22:25.000000000 +0300
+++ b/ash/accessibility/accessibility_controller_unittest.cc	2019-05-17 18:53:08.068000000 +0300
@@ -10,15 +10,17 @@
 #include "ash/accessibility/test_accessibility_controller_client.h"
 #include "ash/magnifier/docked_magnifier_controller.h"
 #include "ash/public/cpp/ash_constants.h"
+#include "ash/public/cpp/ash_features.h"
 #include "ash/public/cpp/ash_pref_names.h"
 #include "ash/session/session_controller.h"
 #include "ash/shell.h"
 #include "ash/sticky_keys/sticky_keys_controller.h"
 #include "ash/test/ash_test_base.h"
-#include "base/bind.h"
 #include "base/macros.h"
 #include "base/strings/string16.h"
 #include "base/strings/utf_string_conversions.h"
+#include "base/test/scoped_feature_list.h"
+#include "chromeos/dbus/dbus_thread_manager.h"
 #include "chromeos/dbus/fake_power_manager_client.h"
 #include "components/prefs/pref_service.h"
 #include "ui/keyboard/keyboard_util.h"
@@ -42,7 +44,32 @@
   DISALLOW_COPY_AND_ASSIGN(TestAccessibilityObserver);
 };
 
-using AccessibilityControllerTest = AshTestBase;
+class AccessibilityControllerTest : public AshTestBase {
+ public:
+  AccessibilityControllerTest() = default;
+  ~AccessibilityControllerTest() override = default;
+
+  void SetUp() override {
+    auto power_manager_client =
+        std::make_unique<chromeos::FakePowerManagerClient>();
+    power_manager_client_ = power_manager_client.get();
+    chromeos::DBusThreadManager::GetSetterForTesting()->SetPowerManagerClient(
+        std::move(power_manager_client));
+
+    AshTestBase::SetUp();
+  }
+  void TearDown() override {
+    AshTestBase::TearDown();
+    chromeos::DBusThreadManager::Shutdown();
+  }
+
+ protected:
+  // Owned by chromeos::DBusThreadManager.
+  chromeos::FakePowerManagerClient* power_manager_client_ = nullptr;
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(AccessibilityControllerTest);
+};
 
 TEST_F(AccessibilityControllerTest, PrefsAreRegistered) {
   PrefService* prefs =
@@ -328,17 +355,15 @@
 }
 
 TEST_F(AccessibilityControllerTest, SetDarkenScreen) {
-  ASSERT_FALSE(
-      chromeos::FakePowerManagerClient::Get()->backlights_forced_off());
+  ASSERT_FALSE(power_manager_client_->backlights_forced_off());
 
   AccessibilityController* controller =
       Shell::Get()->accessibility_controller();
   controller->SetDarkenScreen(true);
-  EXPECT_TRUE(chromeos::FakePowerManagerClient::Get()->backlights_forced_off());
+  EXPECT_TRUE(power_manager_client_->backlights_forced_off());
 
   controller->SetDarkenScreen(false);
-  EXPECT_FALSE(
-      chromeos::FakePowerManagerClient::Get()->backlights_forced_off());
+  EXPECT_FALSE(power_manager_client_->backlights_forced_off());
 }
 
 TEST_F(AccessibilityControllerTest, ShowNotificationOnSpokenFeedback) {
@@ -448,6 +473,12 @@
   AccessibilityControllerSigninTest() = default;
   ~AccessibilityControllerSigninTest() = default;
 
+  // AshTestBase:
+  void SetUp() override {
+    scoped_feature_list_.InitAndEnableFeature(features::kDockedMagnifier);
+    NoSessionAshTestBase::SetUp();
+  }
+
   void SimulateLogin() {
     constexpr char kUserEmail[] = "user1@test.com";
     switch (GetParam()) {
@@ -466,12 +497,14 @@
   }
 
  private:
+  base::test::ScopedFeatureList scoped_feature_list_;
+
   DISALLOW_COPY_AND_ASSIGN(AccessibilityControllerSigninTest);
 };
 
 }  // namespace
 
-INSTANTIATE_TEST_SUITE_P(,
+INSTANTIATE_TEST_CASE_P(,
                          AccessibilityControllerSigninTest,
                          ::testing::Values(TestUserLoginType::kNewUser,
                                            TestUserLoginType::kGuest,
--- a/ash/accessibility/accessibility_focus_ring_controller.cc	2019-05-01 01:22:25.000000000 +0300
+++ b/ash/accessibility/accessibility_focus_ring_controller.cc	2019-05-17 18:53:08.068000000 +0300
@@ -66,14 +66,14 @@
     SkColor color,
     const std::string& caller_id) {
   AccessibilityFocusRingGroup* focus_ring_group =
-      GetFocusRingGroupForCallerId(caller_id, true /* Create if missing */);
+      GetFocusRingGroupForCallerId(caller_id, /* Create if missing */ true);
   focus_ring_group->SetColor(color, this);
 }
 
 void AccessibilityFocusRingController::ResetFocusRingColor(
     const std::string& caller_id) {
   AccessibilityFocusRingGroup* focus_ring_group =
-      GetFocusRingGroupForCallerId(caller_id, false /* Do not create */);
+      GetFocusRingGroupForCallerId(caller_id, /* Do not create */ false);
   if (!focus_ring_group)
     return;
   focus_ring_group->ResetColor(this);
@@ -84,7 +84,7 @@
     mojom::FocusRingBehavior focus_ring_behavior,
     const std::string& caller_id) {
   AccessibilityFocusRingGroup* focus_ring_group =
-      GetFocusRingGroupForCallerId(caller_id, true /* Create if missing */);
+      GetFocusRingGroupForCallerId(caller_id, /* Create if missing */ true);
   if (focus_ring_group->SetFocusRectsAndBehavior(rects, focus_ring_behavior,
                                                  this))
     OnLayerChange(focus_ring_group->focus_animation_info());
@@ -93,7 +93,7 @@
 void AccessibilityFocusRingController::HideFocusRing(
     const std::string& caller_id) {
   AccessibilityFocusRingGroup* focus_ring_group =
-      GetFocusRingGroupForCallerId(caller_id, false /* Do not create */);
+      GetFocusRingGroupForCallerId(caller_id, /* Do not create */ false);
   if (!focus_ring_group)
     return;
   focus_ring_group->ClearFocusRects(this);
@@ -114,23 +114,6 @@
   UpdateHighlightFromHighlightRects();
 }
 
-void AccessibilityFocusRingController::EnableDoubleFocusRing(
-    SkColor color,
-    const std::string& caller_id) {
-  AccessibilityFocusRingGroup* focus_ring_group =
-      GetFocusRingGroupForCallerId(caller_id, true /* Create if missing */);
-  focus_ring_group->EnableDoubleFocusRing(color, this);
-}
-
-void AccessibilityFocusRingController::DisableDoubleFocusRing(
-    const std::string& caller_id) {
-  AccessibilityFocusRingGroup* focus_ring_group =
-      GetFocusRingGroupForCallerId(caller_id, false /* Do not create */);
-  if (!focus_ring_group)
-    return;
-  focus_ring_group->DisableDoubleFocusRing(this);
-}
-
 void AccessibilityFocusRingController::UpdateHighlightFromHighlightRects() {
   if (!highlight_layer_)
     highlight_layer_ = std::make_unique<AccessibilityHighlightLayer>(this);
--- a/ash/accessibility/accessibility_focus_ring_controller.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/accessibility/accessibility_focus_ring_controller.h	2019-05-17 18:53:08.068000000 +0300
@@ -49,9 +49,6 @@
   void SetHighlights(const std::vector<gfx::Rect>& rects,
                      SkColor color) override;
   void HideHighlights() override;
-  void EnableDoubleFocusRing(SkColor color,
-                             const std::string& caller_id) override;
-  void DisableDoubleFocusRing(const std::string& caller_id) override;
 
   // Draw a ring around the mouse cursor. It fades out automatically.
   void SetCursorRing(const gfx::Point& location);
--- a/ash/accessibility/accessibility_focus_ring_group.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/accessibility/accessibility_focus_ring_group.cc	2019-05-17 18:53:08.068000000 +0300
@@ -52,7 +52,7 @@
       base::TimeDelta::FromMilliseconds(kFocusFadeOutTimeMilliseconds);
 }
 
-AccessibilityFocusRingGroup::~AccessibilityFocusRingGroup() {}
+AccessibilityFocusRingGroup::~AccessibilityFocusRingGroup(){};
 
 void AccessibilityFocusRingGroup::SetColor(
     SkColor color,
@@ -67,19 +67,6 @@
   UpdateFocusRingsFromFocusRects(delegate);
 }
 
-void AccessibilityFocusRingGroup::EnableDoubleFocusRing(
-    SkColor color,
-    AccessibilityLayerDelegate* delegate) {
-  focus_ring_secondary_color_ = color;
-  UpdateFocusRingsFromFocusRects(delegate);
-}
-
-void AccessibilityFocusRingGroup::DisableDoubleFocusRing(
-    AccessibilityLayerDelegate* delegate) {
-  focus_ring_secondary_color_.reset();
-  UpdateFocusRingsFromFocusRects(delegate);
-}
-
 void AccessibilityFocusRingGroup::UpdateFocusRingsFromFocusRects(
     AccessibilityLayerDelegate* delegate) {
   previous_focus_rings_.swap(focus_rings_);
@@ -109,15 +96,10 @@
   }
 
   for (size_t i = 0; i < focus_rings_.size(); ++i) {
-    if (focus_ring_color_)
+    if (focus_ring_color_) {
       focus_layers_[i]->SetColor(*(focus_ring_color_));
-    else
+    } else
       focus_layers_[i]->ResetColor();
-
-    if (focus_ring_secondary_color_)
-      focus_layers_[i]->EnableDoubleFocusRing(*(focus_ring_secondary_color_));
-    else
-      focus_layers_[i]->DisableDoubleFocusRing();
   }
 }
 
--- a/ash/accessibility/accessibility_focus_ring_group.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/accessibility/accessibility_focus_ring_group.h	2019-05-17 18:53:08.068000000 +0300
@@ -31,10 +31,6 @@
   void SetColor(SkColor color, AccessibilityLayerDelegate* delegate);
   void ResetColor(AccessibilityLayerDelegate* delegate);
 
-  void EnableDoubleFocusRing(SkColor secondary_color,
-                             AccessibilityLayerDelegate* delegate);
-  void DisableDoubleFocusRing(AccessibilityLayerDelegate* delegate);
-
   void UpdateFocusRingsFromFocusRects(AccessibilityLayerDelegate* delegate);
   bool CanAnimate() const;
   void AnimateFocusRings(base::TimeTicks timestamp);
@@ -81,7 +77,6 @@
 
   std::vector<gfx::Rect> focus_rects_;
   base::Optional<SkColor> focus_ring_color_;
-  base::Optional<SkColor> focus_ring_secondary_color_;
   std::vector<AccessibilityFocusRing> previous_focus_rings_;
   std::vector<std::unique_ptr<AccessibilityFocusRingLayer>> focus_layers_;
   std::vector<AccessibilityFocusRing> focus_rings_;
--- a/ash/accessibility/accessibility_focus_ring_layer.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/accessibility/accessibility_focus_ring_layer.cc	2019-05-17 18:53:08.068000000 +0300
@@ -10,6 +10,7 @@
 #include "third_party/skia/include/core/SkPath.h"
 #include "ui/aura/window.h"
 #include "ui/compositor/layer.h"
+#include "ui/compositor/paint_recorder.h"
 #include "ui/gfx/canvas.h"
 
 namespace ash {
@@ -19,8 +20,10 @@
 // The number of pixels in the color gradient that fades to transparent.
 const int kGradientWidth = 6;
 
-// The default color of the focus ring.
-const SkColor kDefaultFocusRingColor = SkColorSetARGB(255, 247, 152, 58);
+// The color of the focus ring. In the future this might be a parameter.
+const int kFocusRingColorRed = 247;
+const int kFocusRingColorGreen = 152;
+const int kFocusRingColorBlue = 58;
 
 int sign(int x) {
   return ((x > 0) ? 1 : (x == 0) ? 0 : -1);
@@ -103,15 +106,6 @@
   CreateOrUpdateLayer(root_window, "AccessibilityFocusRing", bounds);
 }
 
-void AccessibilityFocusRingLayer::EnableDoubleFocusRing(
-    SkColor secondary_color) {
-  secondary_color_ = secondary_color;
-}
-
-void AccessibilityFocusRingLayer::DisableDoubleFocusRing() {
-  secondary_color_.reset();
-}
-
 void AccessibilityFocusRingLayer::OnPaintLayer(
     const ui::PaintContext& context) {
   ui::PaintRecorder recorder(context, layer()->size());
@@ -121,33 +115,11 @@
   flags.setStyle(cc::PaintFlags::kStroke_Style);
   flags.setStrokeWidth(2);
 
-  if (secondary_color_)
-    DrawDoubleFocusRing(recorder, flags);
-  else
-    DrawFocusRing(recorder, flags);
-}
-
-void AccessibilityFocusRingLayer::DrawDoubleFocusRing(
-    ui::PaintRecorder& recorder,
-    cc::PaintFlags& flags) {
-  SkColor base_color =
-      has_custom_color() ? custom_color() : kDefaultFocusRingColor;
-
-  SkPath path;
-  gfx::Vector2d offset = layer()->bounds().OffsetFromOrigin();
-  flags.setColor(base_color);
-  path = MakePath(ring_, 0, offset);
-  recorder.canvas()->DrawPath(path, flags);
-
-  flags.setColor(*(secondary_color_));
-  path = MakePath(ring_, 2, offset);
-  recorder.canvas()->DrawPath(path, flags);
-}
-
-void AccessibilityFocusRingLayer::DrawFocusRing(ui::PaintRecorder& recorder,
-                                                cc::PaintFlags& flags) {
   SkColor base_color =
-      has_custom_color() ? custom_color() : kDefaultFocusRingColor;
+      has_custom_color()
+          ? custom_color()
+          : SkColorSetARGB(255, kFocusRingColorRed, kFocusRingColorGreen,
+                           kFocusRingColorBlue);
 
   SkPath path;
   gfx::Vector2d offset = layer()->bounds().OffsetFromOrigin();
--- a/ash/accessibility/accessibility_focus_ring_layer.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/accessibility/accessibility_focus_ring_layer.h	2019-05-17 18:53:08.068000000 +0300
@@ -9,7 +9,6 @@
 #include "ash/accessibility/focus_ring_layer.h"
 #include "ash/ash_export.h"
 #include "base/macros.h"
-#include "ui/compositor/paint_recorder.h"
 
 namespace ash {
 
@@ -24,20 +23,12 @@
   // Create the layer and update its bounds and position in the hierarchy.
   void Set(const AccessibilityFocusRing& ring);
 
-  void EnableDoubleFocusRing(SkColor secondary_color);
-  void DisableDoubleFocusRing();
-
  private:
   // ui::LayerDelegate overrides:
   void OnPaintLayer(const ui::PaintContext& context) override;
 
-  void DrawFocusRing(ui::PaintRecorder& recorder, cc::PaintFlags& flags);
-  void DrawDoubleFocusRing(ui::PaintRecorder& recorder, cc::PaintFlags& flags);
-
   // The outline of the current focus ring.
   AccessibilityFocusRing ring_;
-  // The secondary color, if there is a double focus ring.
-  base::Optional<SkColor> secondary_color_;
 
   DISALLOW_COPY_AND_ASSIGN(AccessibilityFocusRingLayer);
 };
--- a/ash/accessibility/accessibility_highlight_controller_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/accessibility/accessibility_highlight_controller_unittest.cc	2019-05-17 18:53:08.068000000 +0300
@@ -12,7 +12,6 @@
 #include "ash/accessibility/accessibility_focus_ring_controller.h"
 #include "ash/shell.h"
 #include "ash/test/ash_test_base.h"
-#include "base/bind.h"
 #include "base/command_line.h"
 #include "base/macros.h"
 #include "third_party/skia/include/core/SkBitmap.h"
--- a/ash/accessibility/accessibility_layer.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/accessibility/accessibility_layer.h	2019-05-17 18:53:08.068000000 +0300
@@ -32,7 +32,7 @@
   virtual void OnAnimationStep(base::TimeTicks timestamp) = 0;
 
  protected:
-  virtual ~AccessibilityLayerDelegate() {}
+  virtual ~AccessibilityLayerDelegate(){};
 };
 
 // AccessibilityLayer manages a global always-on-top layer used to
--- a/ash/accessibility/touch_exploration_controller.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/accessibility/touch_exploration_controller.cc	2019-05-17 18:53:08.072000000 +0300
@@ -4,14 +4,11 @@
 
 #include "ash/accessibility/touch_exploration_controller.h"
 
-#include <algorithm>
-#include <string>
 #include <utility>
 
 #include "ash/accessibility/touch_accessibility_enabler.h"
 #include "ash/public/cpp/shell_window_ids.h"
 #include "ash/wm/container_finder.h"
-#include "base/bind.h"
 #include "base/logging.h"
 #include "base/strings/string_number_conversions.h"
 #include "ui/accessibility/ax_enums.mojom.h"
@@ -85,9 +82,9 @@
   lift_activation_bounds_ = bounds;
 }
 
-ui::EventDispatchDetails TouchExplorationController::RewriteEvent(
+ui::EventRewriteStatus TouchExplorationController::RewriteEvent(
     const ui::Event& event,
-    const Continuation continuation) {
+    std::unique_ptr<ui::Event>* rewritten_event) {
   if (!event.IsTouchEvent()) {
     if (event.IsKeyEvent()) {
       const ui::KeyEvent& key_event = static_cast<const ui::KeyEvent&>(event);
@@ -96,7 +93,7 @@
               << ", Flags: " << key_event.flags()
               << ", Is char: " << key_event.is_char();
     }
-    return SendEvent(continuation, &event);
+    return ui::EVENT_REWRITE_CONTINUE;
   }
   const ui::TouchEvent& touch_event = static_cast<const ui::TouchEvent&>(event);
 
@@ -119,10 +116,10 @@
       (!exclude_bounds_.IsEmpty() && exclude_bounds_.Contains(location));
   if (exclude) {
     if (state_ == NO_FINGERS_DOWN)
-      return SendEvent(continuation, &event);
+      return ui::EVENT_REWRITE_CONTINUE;
     if (touch_event.type() == ui::ET_TOUCH_MOVED ||
         touch_event.type() == ui::ET_TOUCH_PRESSED) {
-      return DiscardEvent(continuation);
+      return ui::EVENT_REWRITE_DISCARD;
     }
     // Otherwise, continue handling events. Basically, we want to let
     // CANCELLED or RELEASE events through so this can get back to
@@ -162,17 +159,18 @@
       // event so that touch gestures that enable spoken feedback
       // don't accidentally trigger other behaviors on release.
       if (!seen_press_) {
-        ui::TouchEvent new_event(
+        std::unique_ptr<ui::TouchEvent> new_event(new ui::TouchEvent(
             ui::ET_TOUCH_CANCELLED, gfx::Point(), touch_event.time_stamp(),
-            touch_event.pointer_details());
-        new_event.set_location(location);
-        new_event.set_root_location(root_location);
-        new_event.set_flags(touch_event.flags());
-        return SendEventFinally(continuation, &new_event);
+            touch_event.pointer_details()));
+        new_event->set_location(location);
+        new_event->set_root_location(root_location);
+        new_event->set_flags(touch_event.flags());
+        *rewritten_event = std::move(new_event);
+        return ui::EVENT_REWRITE_REWRITTEN;
       }
 
       // Otherwise just pass it through.
-      return SendEvent(continuation, &event);
+      return ui::EVENT_REWRITE_CONTINUE;
     }
 
     current_touch_ids_.erase(it);
@@ -183,12 +181,12 @@
 
     // Can happen if touch exploration is enabled while fingers were down.
     if (it == current_touch_ids_.end())
-      return SendEvent(continuation, &event);
+      return ui::EVENT_REWRITE_CONTINUE;
 
     touch_locations_[*it] = gfx::PointF(location);
   } else {
     NOTREACHED() << "Unexpected event type received: " << event.GetName();
-    return SendEvent(continuation, &event);
+    return ui::EVENT_REWRITE_CONTINUE;
   }
   VLOG_EVENT(touch_event);
 
@@ -205,7 +203,7 @@
         VLOG(1) << "Reset to no fingers in Rewrite event because the touch  "
                    "release or cancel was on the edge of the screen.";
       }
-      return DiscardEvent(continuation);
+      return ui::EVENT_REWRITE_DISCARD;
     }
   }
 
@@ -228,84 +226,104 @@
     ProcessGestureEvents();
   }
 
+  ui::EventRewriteStatus status = ui::EVENT_REWRITE_CONTINUE;
   // The rest of the processing depends on what state we're in.
   switch (state_) {
     case NO_FINGERS_DOWN:
-      return InNoFingersDown(touch_event_dip, continuation);
+      status = InNoFingersDown(touch_event_dip, rewritten_event);
+      break;
     case SINGLE_TAP_PRESSED:
-      return InSingleTapPressed(touch_event_dip, continuation);
+      status = InSingleTapPressed(touch_event_dip, rewritten_event);
+      break;
     case SINGLE_TAP_RELEASED:
     case TOUCH_EXPLORE_RELEASED:
-      return InSingleTapOrTouchExploreReleased(touch_event_dip, continuation);
+      status =
+          InSingleTapOrTouchExploreReleased(touch_event_dip, rewritten_event);
+      break;
     case DOUBLE_TAP_PENDING:
-      return InDoubleTapPending(touch_event_dip, continuation);
+      status = InDoubleTapPending(touch_event_dip, rewritten_event);
+      break;
     case TOUCH_RELEASE_PENDING:
-      return InTouchReleasePending(touch_event_dip, continuation);
+      status = InTouchReleasePending(touch_event_dip, rewritten_event);
+      break;
     case TOUCH_EXPLORATION:
-      return InTouchExploration(touch_event_dip, continuation);
+      status = InTouchExploration(touch_event_dip, rewritten_event);
+      break;
     case GESTURE_IN_PROGRESS:
-      return InGestureInProgress(touch_event_dip, continuation);
+      status = InGestureInProgress(touch_event_dip, rewritten_event);
+      break;
     case TOUCH_EXPLORE_SECOND_PRESS:
-      return InTouchExploreSecondPress(touch_event_dip, continuation);
+      status = InTouchExploreSecondPress(touch_event_dip, rewritten_event);
+      break;
     case SLIDE_GESTURE:
-      return InSlideGesture(touch_event_dip, continuation);
+      status = InSlideGesture(touch_event_dip, rewritten_event);
+      break;
     case ONE_FINGER_PASSTHROUGH:
-      return InOneFingerPassthrough(touch_event_dip, continuation);
+      status = InOneFingerPassthrough(touch_event_dip, rewritten_event);
+      break;
     case WAIT_FOR_NO_FINGERS:
-      return InWaitForNoFingers(touch_event_dip, continuation);
+      status = InWaitForNoFingers(touch_event_dip, rewritten_event);
+      break;
     case TWO_FINGER_TAP:
-      return InTwoFingerTap(touch_event_dip, continuation);
+      status = InTwoFingerTap(touch_event_dip, rewritten_event);
+      break;
   }
+  if (status == ui::EVENT_REWRITE_REWRITTEN) {
+    DCHECK(rewritten_event->get());
+    SetTouchAccessibilityFlag(rewritten_event->get());
+  }
+  return status;
+}
+
+ui::EventRewriteStatus TouchExplorationController::NextDispatchEvent(
+    const ui::Event& last_event,
+    std::unique_ptr<ui::Event>* new_event) {
   NOTREACHED();
-  return SendEvent(continuation, &event);
+  return ui::EVENT_REWRITE_CONTINUE;
 }
 
-ui::EventDispatchDetails TouchExplorationController::InNoFingersDown(
+ui::EventRewriteStatus TouchExplorationController::InNoFingersDown(
     const ui::TouchEvent& event,
-    const Continuation continuation) {
+    std::unique_ptr<ui::Event>* rewritten_event) {
   const ui::EventType type = event.type();
   if (type != ui::ET_TOUCH_PRESSED) {
     NOTREACHED() << "Unexpected event type received: " << event.GetName();
-    return SendEvent(continuation, &event);
+    return ui::EVENT_REWRITE_CONTINUE;
   }
 
   initial_press_ = std::make_unique<ui::TouchEvent>(event);
-  initial_press_continuation_ = continuation;
   most_recent_press_timestamp_ = initial_press_->time_stamp();
   initial_presses_[event.pointer_details().id] = event.location();
   last_unused_finger_event_ = std::make_unique<ui::TouchEvent>(event);
-  last_unused_finger_continuation_ = continuation;
   StartTapTimer();
   SET_STATE(SINGLE_TAP_PRESSED);
-  return DiscardEvent(continuation);
+  return ui::EVENT_REWRITE_DISCARD;
 }
 
-ui::EventDispatchDetails TouchExplorationController::InSingleTapPressed(
+ui::EventRewriteStatus TouchExplorationController::InSingleTapPressed(
     const ui::TouchEvent& event,
-    const Continuation continuation) {
+    std::unique_ptr<ui::Event>* rewritten_event) {
   const ui::EventType type = event.type();
   if (type == ui::ET_TOUCH_PRESSED) {
     initial_presses_[event.pointer_details().id] = event.location();
     SET_STATE(TWO_FINGER_TAP);
-    return DiscardEvent(continuation);
-  }
-  if (type == ui::ET_TOUCH_RELEASED || type == ui::ET_TOUCH_CANCELLED) {
+    return ui::EVENT_REWRITE_DISCARD;
+  } else if (type == ui::ET_TOUCH_RELEASED || type == ui::ET_TOUCH_CANCELLED) {
     if (current_touch_ids_.size() == 0 &&
         event.pointer_details().id == initial_press_->pointer_details().id) {
-      MaybeSendSimulatedTapInLiftActivationBounds(event, continuation);
+      MaybeSendSimulatedTapInLiftActivationBounds(event);
       SET_STATE(SINGLE_TAP_RELEASED);
     } else if (current_touch_ids_.size() == 0) {
       SET_STATE(NO_FINGERS_DOWN);
     }
-    return DiscardEvent(continuation);
-  }
-  if (type == ui::ET_TOUCH_MOVED) {
+    return ui::EVENT_REWRITE_DISCARD;
+  } else if (type == ui::ET_TOUCH_MOVED) {
     float distance = (event.location() - initial_press_->location()).Length();
     // If the user does not move far enough from the original position, then the
     // resulting movement should not be considered to be a deliberate gesture or
     // touch exploration.
     if (distance <= gesture_detector_config_.touch_slop)
-      return DiscardEvent(continuation);
+      return ui::EVENT_REWRITE_DISCARD;
 
     float delta_time =
         (event.time_stamp() - most_recent_press_timestamp_).InSecondsF();
@@ -320,34 +338,34 @@
     int edge = FindEdgesWithinInset(event.location(), kMaxDistanceFromEdge);
     if (edge & RIGHT_EDGE && edge != BOTTOM_RIGHT_CORNER) {
       SET_STATE(SLIDE_GESTURE);
-      return InSlideGesture(event, continuation);
+      return InSlideGesture(event, rewritten_event);
     }
 
     // If the user moves fast enough from the initial touch location, start
     // gesture detection. Otherwise, jump to the touch exploration mode early.
     if (velocity > gesture_detector_config_.minimum_swipe_velocity) {
       SET_STATE(GESTURE_IN_PROGRESS);
-      return InGestureInProgress(event, continuation);
+      return InGestureInProgress(event, rewritten_event);
     }
     anchor_point_state_ = ANCHOR_POINT_FROM_TOUCH_EXPLORATION;
     EnterTouchToMouseMode();
     SET_STATE(TOUCH_EXPLORATION);
-    return InTouchExploration(event, continuation);
+    return InTouchExploration(event, rewritten_event);
   }
   NOTREACHED();
-  return SendEvent(continuation, &event);
+  return ui::EVENT_REWRITE_CONTINUE;
 }
 
-ui::EventDispatchDetails
+ui::EventRewriteStatus
 TouchExplorationController::InSingleTapOrTouchExploreReleased(
     const ui::TouchEvent& event,
-    const Continuation continuation) {
+    std::unique_ptr<ui::Event>* rewritten_event) {
   const ui::EventType type = event.type();
   // If there is more than one finger down, then discard to wait until no
   // fingers are down.
   if (current_touch_ids_.size() > 1) {
     SET_STATE(WAIT_FOR_NO_FINGERS);
-    return DiscardEvent(continuation);
+    return ui::EVENT_REWRITE_DISCARD;
   }
   if (type == ui::ET_TOUCH_PRESSED) {
     // If there is no anchor point for synthesized events because the
@@ -355,7 +373,7 @@
     // send a click, so discard.
     if (anchor_point_state_ == ANCHOR_POINT_NONE) {
       tap_timer_.Stop();
-      return DiscardEvent(continuation);
+      return ui::EVENT_REWRITE_DISCARD;
     }
     // This is the second tap in a double-tap (or double tap-hold).
     // We set the tap timer. If it fires before the user lifts their finger,
@@ -370,32 +388,29 @@
     // This will update as the finger moves before a possible passthrough, and
     // will determine the offset.
     last_unused_finger_event_.reset(new ui::TouchEvent(event));
-    last_unused_finger_continuation_ = continuation;
-    return DiscardEvent(continuation);
-  }
-  if (type == ui::ET_TOUCH_RELEASED &&
+    return ui::EVENT_REWRITE_DISCARD;
+  } else if (type == ui::ET_TOUCH_RELEASED &&
       anchor_point_state_ == ANCHOR_POINT_NONE) {
     // If the previous press was discarded, we need to also handle its
     // release.
     if (current_touch_ids_.size() == 0) {
       SET_STATE(NO_FINGERS_DOWN);
     }
-    return DiscardEvent(continuation);
+    return ui::EVENT_REWRITE_DISCARD;
+  } else if (type == ui::ET_TOUCH_MOVED) {
+    return ui::EVENT_REWRITE_DISCARD;
   }
-  if (type == ui::ET_TOUCH_MOVED)
-    return DiscardEvent(continuation);
   NOTREACHED();
-  return SendEvent(continuation, &event);
+  return ui::EVENT_REWRITE_CONTINUE;
 }
 
-ui::EventDispatchDetails TouchExplorationController::InDoubleTapPending(
+ui::EventRewriteStatus TouchExplorationController::InDoubleTapPending(
     const ui::TouchEvent& event,
-    const Continuation continuation) {
+    std::unique_ptr<ui::Event>* rewritten_event) {
   const ui::EventType type = event.type();
   if (type == ui::ET_TOUCH_PRESSED) {
-    return DiscardEvent(continuation);
-  }
-  if (type == ui::ET_TOUCH_MOVED) {
+    return ui::EVENT_REWRITE_DISCARD;
+  } else if (type == ui::ET_TOUCH_MOVED) {
     // If the user moves far enough from the initial touch location (outside
     // the "slop" region, jump to passthrough mode early.
     float delta = (event.location() - initial_press_->location()).Length();
@@ -403,78 +418,74 @@
       tap_timer_.Stop();
       OnTapTimerFired();
     }
-    return DiscardEvent(continuation);
+    return ui::EVENT_REWRITE_DISCARD;
   } else if (type == ui::ET_TOUCH_RELEASED || type == ui::ET_TOUCH_CANCELLED) {
     if (current_touch_ids_.size() != 0)
-      return DiscardEvent(continuation);
+      return ui::EVENT_REWRITE_DISCARD;
 
-    SendSimulatedClickOrTap(continuation);
+    SendSimulatedClickOrTap();
 
     SET_STATE(NO_FINGERS_DOWN);
-    return DiscardEvent(continuation);
+    return ui::EVENT_REWRITE_DISCARD;
   }
   NOTREACHED();
-  return SendEvent(continuation, &event);
+  return ui::EVENT_REWRITE_CONTINUE;
 }
 
-ui::EventDispatchDetails TouchExplorationController::InTouchReleasePending(
+ui::EventRewriteStatus TouchExplorationController::InTouchReleasePending(
     const ui::TouchEvent& event,
-    const Continuation continuation) {
+    std::unique_ptr<ui::Event>* rewritten_event) {
   const ui::EventType type = event.type();
   if (type == ui::ET_TOUCH_PRESSED || type == ui::ET_TOUCH_MOVED) {
-    return DiscardEvent(continuation);
+    return ui::EVENT_REWRITE_DISCARD;
   } else if (type == ui::ET_TOUCH_RELEASED || type == ui::ET_TOUCH_CANCELLED) {
     if (current_touch_ids_.size() != 0)
-      return DiscardEvent(continuation);
+      return ui::EVENT_REWRITE_DISCARD;
 
-    SendSimulatedClickOrTap(continuation);
+    SendSimulatedClickOrTap();
     SET_STATE(NO_FINGERS_DOWN);
-    return DiscardEvent(continuation);
+    return ui::EVENT_REWRITE_DISCARD;
   }
   NOTREACHED();
-  return SendEvent(continuation, &event);
+  return ui::EVENT_REWRITE_CONTINUE;
 }
 
-ui::EventDispatchDetails TouchExplorationController::InTouchExploration(
+ui::EventRewriteStatus TouchExplorationController::InTouchExploration(
     const ui::TouchEvent& event,
-    const Continuation continuation) {
+    std::unique_ptr<ui::Event>* rewritten_event) {
   const ui::EventType type = event.type();
   if (type == ui::ET_TOUCH_PRESSED) {
     // Enter split-tap mode.
     initial_press_ = std::make_unique<ui::TouchEvent>(event);
-    initial_press_continuation_ = continuation;
     tap_timer_.Stop();
     SET_STATE(TOUCH_EXPLORE_SECOND_PRESS);
-    return DiscardEvent(continuation);
+    return ui::EVENT_REWRITE_DISCARD;
   } else if (type == ui::ET_TOUCH_RELEASED || type == ui::ET_TOUCH_CANCELLED) {
     initial_press_ = std::make_unique<ui::TouchEvent>(event);
-    initial_press_continuation_ = continuation;
     StartTapTimer();
     most_recent_press_timestamp_ = event.time_stamp();
-    MaybeSendSimulatedTapInLiftActivationBounds(event, continuation);
+    MaybeSendSimulatedTapInLiftActivationBounds(event);
     SET_STATE(TOUCH_EXPLORE_RELEASED);
   } else if (type != ui::ET_TOUCH_MOVED) {
     NOTREACHED();
-    return SendEvent(continuation, &event);
+    return ui::EVENT_REWRITE_CONTINUE;
   }
 
   // Rewrite as a mouse-move event.
   // |event| locations are in DIP; see |RewriteEvent|. We need to dispatch
   // |screen coords.
   gfx::PointF location_f(ConvertDIPToPixels(event.location_f()));
-  std::unique_ptr<ui::Event> new_event = CreateMouseMoveEvent(
-      location_f, event.flags());
-  SetTouchAccessibilityFlag(new_event.get());
+  *rewritten_event = CreateMouseMoveEvent(location_f, event.flags());
   last_touch_exploration_ = std::make_unique<ui::TouchEvent>(event);
   if (anchor_point_state_ != ANCHOR_POINT_EXPLICITLY_SET)
     anchor_point_dip_ = last_touch_exploration_->location_f();
 
-  return SendEventFinally(continuation, new_event.get());
+  return ui::EVENT_REWRITE_REWRITTEN;
 }
 
-ui::EventDispatchDetails TouchExplorationController::InGestureInProgress(
+ui::EventRewriteStatus TouchExplorationController::InGestureInProgress(
     const ui::TouchEvent& event,
-    const Continuation continuation) {
+    std::unique_ptr<ui::Event>* rewritten_event) {
   // The events were sent to the gesture provider in RewriteEvent already.
   // If no gesture is registered before the tap timer times out, the state
   // will change to "wait for no fingers down" or "touch exploration" depending
@@ -482,57 +493,57 @@
   if (current_touch_ids_.size() == 0) {
     SET_STATE(NO_FINGERS_DOWN);
   }
-  return DiscardEvent(continuation);
+  return ui::EVENT_REWRITE_DISCARD;
 }
 
-ui::EventDispatchDetails TouchExplorationController::InOneFingerPassthrough(
+ui::EventRewriteStatus TouchExplorationController::InOneFingerPassthrough(
     const ui::TouchEvent& event,
-    const Continuation continuation) {
+    std::unique_ptr<ui::Event>* rewritten_event) {
   if (event.pointer_details().id != initial_press_->pointer_details().id) {
     if (current_touch_ids_.size() == 0) {
       SET_STATE(NO_FINGERS_DOWN);
     }
-    return DiscardEvent(continuation);
+    return ui::EVENT_REWRITE_DISCARD;
   }
   // |event| locations are in DIP; see |RewriteEvent|. We need to dispatch
   // screen coordinates.
   gfx::PointF location_f(
       ConvertDIPToPixels(event.location_f() - passthrough_offset_));
-  ui::TouchEvent new_event(
-      event.type(), gfx::Point(), event.time_stamp(), event.pointer_details(),
-      event.flags());
-  new_event.set_location_f(location_f);
-  new_event.set_root_location_f(location_f);
-  SetTouchAccessibilityFlag(&new_event);
+  std::unique_ptr<ui::TouchEvent> new_event(new ui::TouchEvent(
+      event.type(), gfx::Point(), event.time_stamp(), event.pointer_details()));
+  new_event->set_location_f(location_f);
+  new_event->set_root_location_f(location_f);
+  new_event->set_flags(event.flags());
+  *rewritten_event = std::move(new_event);
   if (current_touch_ids_.size() == 0) {
     SET_STATE(NO_FINGERS_DOWN);
   }
-  return SendEventFinally(continuation, &new_event);
+  return ui::EVENT_REWRITE_REWRITTEN;
 }
 
-ui::EventDispatchDetails TouchExplorationController::InTouchExploreSecondPress(
+ui::EventRewriteStatus TouchExplorationController::InTouchExploreSecondPress(
     const ui::TouchEvent& event,
-    const Continuation continuation) {
+    std::unique_ptr<ui::Event>* rewritten_event) {
   ui::EventType type = event.type();
   if (type == ui::ET_TOUCH_PRESSED) {
     // A third finger being pressed means that a split tap can no longer go
     // through. The user enters the wait state, Since there has already been
     // a press dispatched when split tap began, the touch needs to be
     // cancelled.
-    ui::TouchEvent new_event(
+    std::unique_ptr<ui::TouchEvent> new_event(new ui::TouchEvent(
         ui::ET_TOUCH_CANCELLED, gfx::Point(), event.time_stamp(),
-        initial_press_->pointer_details(), event.flags());
+        initial_press_->pointer_details()));
     // TODO(dmazzoni): fix for multiple displays. http://crbug.com/616793
     // |event| locations are in DIP; see |RewriteEvent|. We need to dispatch
     // screen coordinates.
     gfx::PointF location_f(ConvertDIPToPixels(anchor_point_dip_));
-    new_event.set_location_f(location_f);
-    new_event.set_root_location_f(location_f);
-    SetTouchAccessibilityFlag(&new_event);
+    new_event->set_location_f(location_f);
+    new_event->set_root_location_f(location_f);
+    new_event->set_flags(event.flags());
+    *rewritten_event = std::move(new_event);
     SET_STATE(WAIT_FOR_NO_FINGERS);
-    return SendEventFinally(continuation, &new_event);
-  }
-  if (type == ui::ET_TOUCH_MOVED) {
+    return ui::EVENT_REWRITE_REWRITTEN;
+  } else if (type == ui::ET_TOUCH_MOVED) {
     // If the fingers have moved too far from their original locations,
     // the user can no longer split tap.
     ui::TouchEvent* original_touch;
@@ -545,7 +556,7 @@
     } else {
       NOTREACHED();
       SET_STATE(WAIT_FOR_NO_FINGERS);
-      return DiscardEvent(continuation);
+      return ui::EVENT_REWRITE_DISCARD;
     }
     // Check the distance between the current finger location and the original
     // location. The slop for this is a bit more generous since keeping two
@@ -555,66 +566,62 @@
         GetSplitTapTouchSlop()) {
       SET_STATE(WAIT_FOR_NO_FINGERS);
     }
-    return DiscardEvent(continuation);
-  }
-  if (type == ui::ET_TOUCH_RELEASED || type == ui::ET_TOUCH_CANCELLED) {
+    return ui::EVENT_REWRITE_DISCARD;
+  } else if (type == ui::ET_TOUCH_RELEASED || type == ui::ET_TOUCH_CANCELLED) {
     // If the touch exploration finger is lifted, there is no option to return
     // to touch explore anymore. The remaining finger acts as a pending
     // tap or long tap for the last touch explore location.
     if (event.pointer_details().id ==
         last_touch_exploration_->pointer_details().id) {
       SET_STATE(TOUCH_RELEASE_PENDING);
-      return DiscardEvent(continuation);
+      return ui::EVENT_REWRITE_DISCARD;
     }
 
     // Continue to release the touch only if the touch explore finger is the
     // only finger remaining.
-    if (current_touch_ids_.size() != 1) {
-      return DiscardEvent(continuation);
-    }
+    if (current_touch_ids_.size() != 1)
+      return ui::EVENT_REWRITE_DISCARD;
 
-    SendSimulatedClickOrTap(continuation);
+    SendSimulatedClickOrTap();
 
     SET_STATE(TOUCH_EXPLORATION);
     EnterTouchToMouseMode();
-    return DiscardEvent(continuation);
+    return ui::EVENT_REWRITE_DISCARD;
   }
   NOTREACHED();
-  return SendEvent(continuation, &event);
+  return ui::EVENT_REWRITE_CONTINUE;
 }
 
-ui::EventDispatchDetails TouchExplorationController::InWaitForNoFingers(
+ui::EventRewriteStatus TouchExplorationController::InWaitForNoFingers(
     const ui::TouchEvent& event,
-    const Continuation continuation) {
+    std::unique_ptr<ui::Event>* rewritten_event) {
   if (current_touch_ids_.size() == 0)
     SET_STATE(NO_FINGERS_DOWN);
-  return DiscardEvent(continuation);
+  return ui::EVENT_REWRITE_DISCARD;
 }
 
 void TouchExplorationController::PlaySoundForTimer() {
   delegate_->PlayVolumeAdjustEarcon();
 }
 
-void TouchExplorationController::SendSimulatedClickOrTap(
-    const Continuation continuation) {
+void TouchExplorationController::SendSimulatedClickOrTap() {
   // If we got an anchor point from ChromeVox, send a double-tap gesture
   // and let ChromeVox handle the click.
   if (anchor_point_state_ == ANCHOR_POINT_EXPLICITLY_SET) {
     delegate_->HandleAccessibilityGesture(ax::mojom::Gesture::kClick);
     return;
   }
-  SendSimulatedTap(continuation);
+  SendSimulatedTap();
 }
 
-void TouchExplorationController::SendSimulatedTap(
-    const Continuation continuation) {
+void TouchExplorationController::SendSimulatedTap() {
   std::unique_ptr<ui::TouchEvent> touch_press;
   touch_press.reset(new ui::TouchEvent(ui::ET_TOUCH_PRESSED, gfx::Point(),
                                        Now(),
                                        initial_press_->pointer_details()));
   touch_press->set_location_f(anchor_point_dip_);
   touch_press->set_root_location_f(anchor_point_dip_);
-  DispatchEvent(touch_press.get(), continuation);
+  DispatchEvent(touch_press.get());
 
   std::unique_ptr<ui::TouchEvent> touch_release;
   touch_release.reset(new ui::TouchEvent(ui::ET_TOUCH_RELEASED, gfx::Point(),
@@ -622,25 +629,24 @@
                                          initial_press_->pointer_details()));
   touch_release->set_location_f(anchor_point_dip_);
   touch_release->set_root_location_f(anchor_point_dip_);
-  DispatchEvent(touch_release.get(), continuation);
+  DispatchEvent(touch_release.get());
 }
 
 void TouchExplorationController::MaybeSendSimulatedTapInLiftActivationBounds(
-    const ui::TouchEvent& event,
-    const Continuation continuation) {
+    const ui::TouchEvent& event) {
   gfx::Point location = event.location();
   gfx::Point anchor_location(anchor_point_dip_.x(), anchor_point_dip_.y());
   if (lift_activation_bounds_.Contains(anchor_location.x(),
                                        anchor_location.y()) &&
       lift_activation_bounds_.Contains(location)) {
     delegate_->PlayTouchTypeEarcon();
-    SendSimulatedTap(continuation);
+    SendSimulatedTap();
   }
 }
 
-ui::EventDispatchDetails TouchExplorationController::InSlideGesture(
+ui::EventRewriteStatus TouchExplorationController::InSlideGesture(
     const ui::TouchEvent& event,
-    const Continuation continuation) {
+    std::unique_ptr<ui::Event>* rewritten_event) {
   // The timer should not fire when sliding.
   tap_timer_.Stop();
 
@@ -652,7 +658,7 @@
     if (sound_timer_.IsRunning())
       sound_timer_.Stop();
     SET_STATE(WAIT_FOR_NO_FINGERS);
-    return DiscardEvent(continuation);
+    return ui::EVENT_REWRITE_DISCARD;
   }
 
   // There should not be more than one finger down.
@@ -665,7 +671,7 @@
     if (sound_timer_.IsRunning()) {
       sound_timer_.Stop();
     }
-    return DiscardEvent(continuation);
+    return ui::EVENT_REWRITE_DISCARD;
   }
 
   // This can occur if the user leaves the screen edge and then returns to it to
@@ -680,17 +686,17 @@
   if (current_touch_ids_.size() == 0) {
     SET_STATE(NO_FINGERS_DOWN);
   }
-  return DiscardEvent(continuation);
+  return ui::EVENT_REWRITE_DISCARD;
 }
 
-ui::EventDispatchDetails TouchExplorationController::InTwoFingerTap(
+ui::EventRewriteStatus TouchExplorationController::InTwoFingerTap(
     const ui::TouchEvent& event,
-    const Continuation continuation) {
+    std::unique_ptr<ui::Event>* rewritten_event) {
   ui::EventType type = event.type();
   if (type == ui::ET_TOUCH_PRESSED) {
     // This is now a three finger gesture.
     SET_STATE(GESTURE_IN_PROGRESS);
-    return DiscardEvent(continuation);
+    return ui::EVENT_REWRITE_DISCARD;
   }
 
   if (type == ui::ET_TOUCH_MOVED) {
@@ -702,19 +708,18 @@
     if (distance > gesture_detector_config_.touch_slop) {
       SET_STATE(GESTURE_IN_PROGRESS);
     }
-    return DiscardEvent(continuation);
+    return ui::EVENT_REWRITE_DISCARD;
   }
 
-  if (current_touch_ids_.size() != 0) {
-    return DiscardEvent(continuation);
-  }
+  if (current_touch_ids_.size() != 0)
+    return ui::EVENT_REWRITE_DISCARD;
 
   if (type == ui::ET_TOUCH_RELEASED) {
     delegate_->HandleAccessibilityGesture(ax::mojom::Gesture::kTap2);
     SET_STATE(NO_FINGERS_DOWN);
-    return DiscardEvent(continuation);
+    return ui::EVENT_REWRITE_DISCARD;
   }
-  return DiscardEvent(continuation);
+  return ui::EVENT_REWRITE_DISCARD;
 }
 
 base::TimeTicks TouchExplorationController::Now() {
@@ -747,7 +752,7 @@
                              last_unused_finger_event_->pointer_details()));
       passthrough_press->set_location_f(anchor_point_dip_);
       passthrough_press->set_root_location_f(anchor_point_dip_);
-      DispatchEvent(passthrough_press.get(), last_unused_finger_continuation_);
+      DispatchEvent(passthrough_press.get());
       return;
     }
     case SINGLE_TAP_PRESSED:
@@ -772,15 +777,13 @@
   EnterTouchToMouseMode();
   std::unique_ptr<ui::Event> mouse_move = CreateMouseMoveEvent(
       initial_press_->location_f(), initial_press_->flags());
-  DispatchEvent(mouse_move.get(), initial_press_continuation_);
+  DispatchEvent(mouse_move.get());
   last_touch_exploration_ = std::make_unique<ui::TouchEvent>(*initial_press_);
   anchor_point_dip_ = last_touch_exploration_->location_f();
   anchor_point_state_ = ANCHOR_POINT_FROM_TOUCH_EXPLORATION;
 }
 
-void TouchExplorationController::DispatchEvent(
-    ui::Event* event,
-    const Continuation continuation) {
+void TouchExplorationController::DispatchEvent(ui::Event* event) {
   SetTouchAccessibilityFlag(event);
   if (event->IsLocatedEvent()) {
     ui::LocatedEvent* located_event = event->AsLocatedEvent();
@@ -788,8 +791,8 @@
     located_event->set_location_f(screen_point);
     located_event->set_root_location_f(screen_point);
   }
-  if (SendEventFinally(continuation, event).dispatcher_destroyed)
-    VLOG(0) << "Undispatched event due to destroyed dispatcher.";
+  ignore_result(
+      root_window_->GetHost()->dispatcher()->OnEventFromSource(event));
 }
 
 // This is an override for a function that is only called for timer-based events
@@ -993,12 +996,11 @@
 
 void TouchExplorationController::DispatchKeyWithFlags(
     const ui::KeyboardCode key,
-    int flags,
-    const Continuation continuation) {
+    int flags) {
   ui::KeyEvent key_down(ui::ET_KEY_PRESSED, key, flags);
   ui::KeyEvent key_up(ui::ET_KEY_RELEASED, key, flags);
-  DispatchEvent(&key_down, continuation);
-  DispatchEvent(&key_up, continuation);
+  DispatchEvent(&key_down);
+  DispatchEvent(&key_up);
   if (VLOG_on_) {
     VLOG(1) << "\nKey down: key code : " << key_down.key_code()
             << ", flags: " << key_down.flags()
@@ -1009,10 +1011,9 @@
 
 base::Closure TouchExplorationController::BindKeyEventWithFlags(
     const ui::KeyboardCode key,
-    int flags,
-    const Continuation continuation) {
+    int flags) {
   return base::Bind(&TouchExplorationController::DispatchKeyWithFlags,
-                    base::Unretained(this), key, flags, continuation);
+                    base::Unretained(this), key, flags);
 }
 
 std::unique_ptr<ui::MouseEvent>
--- a/ash/accessibility/touch_exploration_controller.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/accessibility/touch_exploration_controller.h	2019-05-17 18:53:08.072000000 +0300
@@ -5,10 +5,6 @@
 #ifndef ASH_ACCESSIBILITY_TOUCH_EXPLORATION_CONTROLLER_H_
 #define ASH_ACCESSIBILITY_TOUCH_EXPLORATION_CONTROLLER_H_
 
-#include <map>
-#include <memory>
-#include <vector>
-
 #include "ash/ash_export.h"
 #include "base/macros.h"
 #include "base/memory/weak_ptr.h"
@@ -214,39 +210,50 @@
   friend class TouchExplorationControllerTestApi;
 
   // Overridden from ui::EventRewriter
-  ui::EventDispatchDetails RewriteEvent(
+  ui::EventRewriteStatus RewriteEvent(
       const ui::Event& event,
-      const Continuation continuation) override;
+      std::unique_ptr<ui::Event>* rewritten_event) override;
+  ui::EventRewriteStatus NextDispatchEvent(
+      const ui::Event& last_event,
+      std::unique_ptr<ui::Event>* new_event) override;
 
   // Event handlers based on the current state - see State, below.
-  ui::EventDispatchDetails InNoFingersDown(const ui::TouchEvent& event,
-                                           const Continuation continuation);
-  ui::EventDispatchDetails InSingleTapPressed(const ui::TouchEvent& event,
-                                              const Continuation continuation);
-  ui::EventDispatchDetails InSingleTapOrTouchExploreReleased(
-      const ui::TouchEvent& event,
-      const Continuation continuation);
-  ui::EventDispatchDetails InDoubleTapPending(const ui::TouchEvent& event,
-                                              const Continuation continuation);
-  ui::EventDispatchDetails InTouchReleasePending(
-      const ui::TouchEvent& event,
-      const Continuation continuation);
-  ui::EventDispatchDetails InTouchExploration(const ui::TouchEvent& event,
-                                              const Continuation continuation);
-  ui::EventDispatchDetails InOneFingerPassthrough(
-      const ui::TouchEvent& event,
-      const Continuation continuation);
-  ui::EventDispatchDetails InGestureInProgress(const ui::TouchEvent& event,
-                                               const Continuation continuation);
-  ui::EventDispatchDetails InTouchExploreSecondPress(
-      const ui::TouchEvent& event,
-      const Continuation continuation);
-  ui::EventDispatchDetails InWaitForNoFingers(const ui::TouchEvent& event,
-                                              const Continuation continuation);
-  ui::EventDispatchDetails InSlideGesture(const ui::TouchEvent& event,
-                                          const Continuation continuation);
-  ui::EventDispatchDetails InTwoFingerTap(const ui::TouchEvent& event,
-                                          const Continuation continuation);
+  ui::EventRewriteStatus InNoFingersDown(
+      const ui::TouchEvent& event,
+      std::unique_ptr<ui::Event>* rewritten_event);
+  ui::EventRewriteStatus InSingleTapPressed(
+      const ui::TouchEvent& event,
+      std::unique_ptr<ui::Event>* rewritten_event);
+  ui::EventRewriteStatus InSingleTapOrTouchExploreReleased(
+      const ui::TouchEvent& event,
+      std::unique_ptr<ui::Event>* rewritten_event);
+  ui::EventRewriteStatus InDoubleTapPending(
+      const ui::TouchEvent& event,
+      std::unique_ptr<ui::Event>* rewritten_event);
+  ui::EventRewriteStatus InTouchReleasePending(
+      const ui::TouchEvent& event,
+      std::unique_ptr<ui::Event>* rewritten_event);
+  ui::EventRewriteStatus InTouchExploration(
+      const ui::TouchEvent& event,
+      std::unique_ptr<ui::Event>* rewritten_event);
+  ui::EventRewriteStatus InOneFingerPassthrough(
+      const ui::TouchEvent& event,
+      std::unique_ptr<ui::Event>* rewritten_event);
+  ui::EventRewriteStatus InGestureInProgress(
+      const ui::TouchEvent& event,
+      std::unique_ptr<ui::Event>* rewritten_event);
+  ui::EventRewriteStatus InTouchExploreSecondPress(
+      const ui::TouchEvent& event,
+      std::unique_ptr<ui::Event>* rewritten_event);
+  ui::EventRewriteStatus InWaitForNoFingers(
+      const ui::TouchEvent& event,
+      std::unique_ptr<ui::Event>* rewritten_event);
+  ui::EventRewriteStatus InSlideGesture(
+      const ui::TouchEvent& event,
+      std::unique_ptr<ui::Event>* rewritten_event);
+  ui::EventRewriteStatus InTwoFingerTap(
+      const ui::TouchEvent& event,
+      std::unique_ptr<ui::Event>* rewritten_event);
 
   // Returns the current time of the tick clock.
   base::TimeTicks Now();
@@ -259,7 +266,7 @@
   void OnTapTimerFired();
 
   // Dispatch a new event outside of the event rewriting flow.
-  void DispatchEvent(ui::Event* event, const Continuation continuation);
+  void DispatchEvent(ui::Event* event);
 
   // Overridden from GestureProviderAuraClient.
   //
@@ -278,14 +285,10 @@
   void SideSlideControl(ui::GestureEvent* gesture);
 
   // Dispatches a single key with the given flags.
-  void DispatchKeyWithFlags(const ui::KeyboardCode key,
-                            int flags,
-                            const Continuation continuation);
+  void DispatchKeyWithFlags(const ui::KeyboardCode key, int flags);
 
   // Binds DispatchKeyWithFlags to a specific key and flags.
-  base::Closure BindKeyEventWithFlags(const ui::KeyboardCode key,
-                                      int flags,
-                                      const Continuation continuation);
+  base::Closure BindKeyEventWithFlags(const ui::KeyboardCode key, int flags);
 
   std::unique_ptr<ui::MouseEvent> CreateMouseMoveEvent(
       const gfx::PointF& location,
@@ -297,16 +300,15 @@
 
   // Sends a simulated click, if an anchor point was set explicitly. Otherwise,
   // sends a simulated tap at anchor point.
-  void SendSimulatedClickOrTap(const Continuation continuation);
+  void SendSimulatedClickOrTap();
 
   // Sends a simulated tap at anchor point.
-  void SendSimulatedTap(const Continuation continuation);
+  void SendSimulatedTap();
 
   // Sends a simulated tap, if the anchor point falls within lift activation
   // bounds.
-  void MaybeSendSimulatedTapInLiftActivationBounds(
-      const ui::TouchEvent& event,
-      const Continuation continuation);
+  void MaybeSendSimulatedTapInLiftActivationBounds(const ui::TouchEvent& event);
+
   // Some constants used in touch_exploration_controller:
 
   // Within this many dips of the screen edge, the release event generated will
@@ -463,7 +465,6 @@
 
   // A copy of the event from the initial touch press.
   std::unique_ptr<ui::TouchEvent> initial_press_;
-  Continuation initial_press_continuation_;
 
   // The timestamp of the most recent press event for the main touch id.
   // The difference between this and |initial_press_->time_stamp| is that
@@ -482,7 +483,6 @@
   // sending events through, but might in the future (e.g. before a finger
   // enters double-tap-hold passthrough, we need to update its location.)
   std::unique_ptr<ui::TouchEvent> last_unused_finger_event_;
-  Continuation last_unused_finger_continuation_;
 
   // The anchor point used as the location of a synthesized tap when the
   // user double-taps anywhere on the screen, and similarly the initial
--- a/ash/accessibility/touch_exploration_manager.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/accessibility/touch_exploration_manager.cc	2019-05-17 18:53:08.072000000 +0300
@@ -15,7 +15,6 @@
 #include "ash/root_window_controller.h"
 #include "ash/shell.h"
 #include "ash/wm/window_util.h"
-#include "base/bind.h"
 #include "base/command_line.h"
 #include "chromeos/audio/chromeos_sounds.h"
 #include "chromeos/audio/cras_audio_handler.h"
--- a/ash/app_list/app_list_controller_impl.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/app_list_controller_impl.cc	2019-05-17 18:53:08.072000000 +0300
@@ -9,29 +9,23 @@
 
 #include "ash/app_list/app_list_controller_observer.h"
 #include "ash/app_list/app_list_presenter_delegate_impl.h"
+#include "ash/app_list/home_launcher_gesture_handler.h"
 #include "ash/app_list/model/app_list_folder_item.h"
 #include "ash/app_list/model/app_list_item.h"
-#include "ash/app_list/model/app_list_view_state.h"
 #include "ash/app_list/views/app_list_main_view.h"
 #include "ash/app_list/views/app_list_view.h"
 #include "ash/app_list/views/contents_view.h"
 #include "ash/app_list/views/search_box_view.h"
 #include "ash/assistant/assistant_controller.h"
 #include "ash/assistant/assistant_ui_controller.h"
-#include "ash/assistant/model/assistant_ui_model.h"
-#include "ash/assistant/ui/assistant_view_delegate.h"
-#include "ash/assistant/util/assistant_util.h"
-#include "ash/assistant/util/deep_link_util.h"
-#include "ash/home_screen/home_launcher_gesture_handler.h"
-#include "ash/home_screen/home_screen_controller.h"
 #include "ash/public/cpp/app_list/app_list_features.h"
-#include "ash/public/cpp/app_list/app_list_metrics.h"
 #include "ash/public/cpp/shell_window_ids.h"
 #include "ash/session/session_controller.h"
 #include "ash/shelf/shelf.h"
 #include "ash/shell.h"
 #include "ash/voice_interaction/voice_interaction_controller.h"
 #include "ash/wallpaper/wallpaper_controller.h"
+#include "ash/wm/mru_window_tracker.h"
 #include "ash/wm/overview/overview_controller.h"
 #include "ash/wm/splitview/split_view_controller.h"
 #include "ash/wm/tablet_mode/tablet_mode_controller.h"
@@ -39,13 +33,10 @@
 #include "base/logging.h"
 #include "base/metrics/histogram_macros.h"
 #include "base/metrics/user_metrics.h"
-#include "base/strings/utf_string_conversions.h"
-#include "chromeos/constants/chromeos_switches.h"
 #include "extensions/common/constants.h"
 #include "ui/base/ui_base_features.h"
 #include "ui/display/manager/display_manager.h"
 #include "ui/display/screen.h"
-#include "ui/wm/public/activation_client.h"
 
 namespace ash {
 
@@ -57,39 +48,11 @@
       ->IsTabletModeWindowManagerEnabled();
 }
 
-// Close current Assistant UI.
-void CloseAssistantUi(AssistantExitPoint exit_point) {
-  if (app_list_features::IsEmbeddedAssistantUIEnabled())
-    Shell::Get()->assistant_controller()->ui_controller()->CloseUi(exit_point);
-}
-
-// Minimize all windows that aren't the app list in reverse order to preserve
-// the mru ordering.
-// Returns false if no window is minimized.
-bool MinimizeAllWindows() {
-  bool handled = false;
-  aura::Window* app_list_container =
-      Shell::Get()->GetPrimaryRootWindow()->GetChildById(
-          kShellWindowId_AppListTabletModeContainer);
-  aura::Window::Windows windows =
-      Shell::Get()->mru_window_tracker()->BuildWindowForCycleList();
-  std::reverse(windows.begin(), windows.end());
-  for (auto* window : windows) {
-    if (!app_list_container->Contains(window) &&
-        !wm::GetWindowState(window)->IsMinimized()) {
-      wm::GetWindowState(window)->Minimize();
-      handled = true;
-    }
-  }
-  return handled;
-}
-
 }  // namespace
 
 AppListControllerImpl::AppListControllerImpl()
-    : model_(std::make_unique<app_list::AppListModel>()),
-      presenter_(std::make_unique<AppListPresenterDelegateImpl>(this)) {
-  model_->AddObserver(this);
+    : presenter_(std::make_unique<AppListPresenterDelegateImpl>(this)) {
+  model_.AddObserver(this);
 
   SessionController* session_controller = Shell::Get()->session_controller();
   session_controller->AddObserver(this);
@@ -99,22 +62,30 @@
   // session state here to ensure that the app list is shown.
   OnSessionStateChanged(session_controller->GetSessionState());
 
-  Shell* shell = Shell::Get();
-  shell->tablet_mode_controller()->AddObserver(this);
-  shell->wallpaper_controller()->AddObserver(this);
-  shell->AddShellObserver(this);
-  shell->overview_controller()->AddObserver(this);
+  Shell::Get()->tablet_mode_controller()->AddObserver(this);
+  Shell::Get()->wallpaper_controller()->AddObserver(this);
+  Shell::Get()->AddShellObserver(this);
   keyboard::KeyboardController::Get()->AddObserver(this);
-  shell->voice_interaction_controller()->AddLocalObserver(this);
-  shell->window_tree_host_manager()->AddObserver(this);
-  shell->mru_window_tracker()->AddObserver(this);
-  if (app_list_features::IsEmbeddedAssistantUIEnabled())
-    shell->assistant_controller()->ui_controller()->AddModelObserver(this);
-  shell->home_screen_controller()->home_launcher_gesture_handler()->AddObserver(
-      this);
+
+  if (app_list_features::IsHomeLauncherGesturesEnabled()) {
+    home_launcher_gesture_handler_ =
+        std::make_unique<HomeLauncherGestureHandler>(this);
+  }
+
+  Shell::Get()->voice_interaction_controller()->AddLocalObserver(this);
+  Shell::Get()->window_tree_host_manager()->AddObserver(this);
 }
 
-AppListControllerImpl::~AppListControllerImpl() = default;
+AppListControllerImpl::~AppListControllerImpl() {
+  Shell::Get()->window_tree_host_manager()->RemoveObserver(this);
+  keyboard::KeyboardController::Get()->RemoveObserver(this);
+  Shell::Get()->RemoveShellObserver(this);
+  Shell::Get()->wallpaper_controller()->RemoveObserver(this);
+  Shell::Get()->tablet_mode_controller()->RemoveObserver(this);
+  Shell::Get()->session_controller()->RemoveObserver(this);
+  Shell::Get()->voice_interaction_controller()->RemoveLocalObserver(this);
+  model_.RemoveObserver(this);
+}
 
 void AppListControllerImpl::SetClient(mojom::AppListClientPtr client_ptr) {
   client_ = std::move(client_ptr);
@@ -126,7 +97,7 @@
 }
 
 app_list::AppListModel* AppListControllerImpl::GetModel() {
-  return model_.get();
+  return &model_;
 }
 
 app_list::SearchModel* AppListControllerImpl::GetSearchModel() {
@@ -136,7 +107,7 @@
 void AppListControllerImpl::AddItem(AppListItemMetadataPtr item_data) {
   const std::string folder_id = item_data->folder_id;
   if (folder_id.empty())
-    model_->AddItem(CreateAppListItem(std::move(item_data)));
+    model_.AddItem(CreateAppListItem(std::move(item_data)));
   else
     AddItemToFolder(std::move(item_data), folder_id);
 }
@@ -148,34 +119,34 @@
   // the item to add is not in the target folder yet, and sets its folder id
   // later. So we should clear the folder id here to avoid breaking checks.
   item_data->folder_id.clear();
-  model_->AddItemToFolder(CreateAppListItem(std::move(item_data)), folder_id);
+  model_.AddItemToFolder(CreateAppListItem(std::move(item_data)), folder_id);
 }
 
 void AppListControllerImpl::RemoveItem(const std::string& id) {
-  model_->DeleteItem(id);
+  model_.DeleteItem(id);
 }
 
 void AppListControllerImpl::RemoveUninstalledItem(const std::string& id) {
-  model_->DeleteUninstalledItem(id);
+  model_.DeleteUninstalledItem(id);
 }
 
 void AppListControllerImpl::MoveItemToFolder(const std::string& id,
                                              const std::string& folder_id) {
-  app_list::AppListItem* item = model_->FindItem(id);
-  model_->MoveItemToFolder(item, folder_id);
+  app_list::AppListItem* item = model_.FindItem(id);
+  model_.MoveItemToFolder(item, folder_id);
 }
 
 void AppListControllerImpl::SetStatus(ash::AppListModelStatus status) {
-  model_->SetStatus(status);
+  model_.SetStatus(status);
 }
 
 void AppListControllerImpl::SetState(ash::AppListState state) {
-  model_->SetState(state);
+  model_.SetState(state);
 }
 
 void AppListControllerImpl::HighlightItemInstalledFromUI(
     const std::string& id) {
-  model_->top_level_item_list()->HighlightItemInstalledFromUI(id);
+  model_.top_level_item_list()->HighlightItemInstalledFromUI(id);
 }
 
 void AppListControllerImpl::SetSearchEngineIsGoogle(bool is_google) {
@@ -212,7 +183,7 @@
 
 void AppListControllerImpl::SetItemMetadata(const std::string& id,
                                             AppListItemMetadataPtr data) {
-  app_list::AppListItem* item = model_->FindItem(id);
+  app_list::AppListItem* item = model_.FindItem(id);
   if (!item)
     return;
 
@@ -222,15 +193,15 @@
 
   // Update the item's position and name based on the metadata.
   if (!data->position.Equals(item->position()))
-    model_->SetItemPosition(item, data->position);
+    model_.SetItemPosition(item, data->position);
 
   if (data->short_name.empty()) {
     if (data->name != item->name()) {
-      model_->SetItemName(item, data->name);
+      model_.SetItemName(item, data->name);
     }
   } else {
     if (data->name != item->name() || data->short_name != item->short_name()) {
-      model_->SetItemNameAndShortName(item, data->name, data->short_name);
+      model_.SetItemNameAndShortName(item, data->name, data->short_name);
     }
   }
 
@@ -243,14 +214,14 @@
 
 void AppListControllerImpl::SetItemIcon(const std::string& id,
                                         const gfx::ImageSkia& icon) {
-  app_list::AppListItem* item = model_->FindItem(id);
+  app_list::AppListItem* item = model_.FindItem(id);
   if (item)
     item->SetIcon(icon);
 }
 
 void AppListControllerImpl::SetItemIsInstalling(const std::string& id,
                                                 bool is_installing) {
-  app_list::AppListItem* item = model_->FindItem(id);
+  app_list::AppListItem* item = model_.FindItem(id);
   if (item)
     item->SetIsInstalling(is_installing);
 }
@@ -258,21 +229,18 @@
 void AppListControllerImpl::SetItemPercentDownloaded(
     const std::string& id,
     int32_t percent_downloaded) {
-  app_list::AppListItem* item = model_->FindItem(id);
+  app_list::AppListItem* item = model_.FindItem(id);
   if (item)
     item->SetPercentDownloaded(percent_downloaded);
 }
 
 void AppListControllerImpl::SetModelData(
-    int profile_id,
     std::vector<AppListItemMetadataPtr> apps,
     bool is_search_engine_google) {
   // Clear old model data.
-  model_->DeleteAllItems();
+  model_.DeleteAllItems();
   search_model_.DeleteAllResults();
 
-  profile_id_ = profile_id;
-
   // Populate new models. First populate folders and then other items to avoid
   // automatically creating folder items in |AddItemToFolder|.
   for (auto& app : apps) {
@@ -321,8 +289,8 @@
 void AppListControllerImpl::GetIdToAppListIndexMap(
     GetIdToAppListIndexMapCallback callback) {
   base::flat_map<std::string, uint16_t> id_to_app_list_index;
-  for (size_t i = 0; i < model_->top_level_item_list()->item_count(); ++i)
-    id_to_app_list_index[model_->top_level_item_list()->item_at(i)->id()] = i;
+  for (size_t i = 0; i < model_.top_level_item_list()->item_count(); ++i)
+    id_to_app_list_index[model_.top_level_item_list()->item_at(i)->id()] = i;
   std::move(callback).Run(id_to_app_list_index);
 }
 
@@ -330,8 +298,7 @@
     const std::string& oem_folder_name,
     const syncer::StringOrdinal& preferred_oem_position,
     FindOrCreateOemFolderCallback callback) {
-  app_list::AppListFolderItem* oem_folder =
-      model_->FindFolderItem(kOemFolderId);
+  app_list::AppListFolderItem* oem_folder = model_.FindFolderItem(kOemFolderId);
   if (!oem_folder) {
     std::unique_ptr<app_list::AppListFolderItem> new_folder =
         std::make_unique<app_list::AppListFolderItem>(kOemFolderId);
@@ -341,10 +308,10 @@
     // Do not create a sync item for the OEM folder here, do it in
     // ResolveFolderPositions() when the item position is finalized.
     oem_folder = static_cast<app_list::AppListFolderItem*>(
-        model_->AddItem(std::move(new_folder)));
-    model_->SetItemPosition(oem_folder, oem_position);
+        model_.AddItem(std::move(new_folder)));
+    model_.SetItemPosition(oem_folder, oem_position);
   }
-  model_->SetItemName(oem_folder, oem_folder_name);
+  model_.SetItemName(oem_folder, oem_folder_name);
   std::move(callback).Run(oem_folder->CloneMetadata());
 }
 
@@ -358,7 +325,7 @@
     const syncer::StringOrdinal& oem_folder_pos =
         preferred_oem_position.IsValid() ? preferred_oem_position
                                          : GetOemFolderPos();
-    model_->SetItemPosition(ash_oem_folder, oem_folder_pos);
+    model_.SetItemPosition(ash_oem_folder, oem_folder_pos);
     metadata = ash_oem_folder->CloneMetadata();
   }
   std::move(callback).Run(std::move(metadata));
@@ -408,9 +375,9 @@
 
 void AppListControllerImpl::OnAppListItemAdded(app_list::AppListItem* item) {
   if (item->is_folder())
-    client_->OnFolderCreated(profile_id_, item->CloneMetadata());
+    client_->OnFolderCreated(item->CloneMetadata());
   else if (item->is_page_break())
-    client_->OnPageBreakItemAdded(profile_id_, item->id(), item->position());
+    client_->OnPageBreakItemAdded(item->id(), item->position());
 }
 
 void AppListControllerImpl::OnActiveUserPrefServiceChanged(
@@ -437,36 +404,15 @@
     return;
 
   if (item->is_folder())
-    client_->OnFolderDeleted(profile_id_, item->CloneMetadata());
+    client_->OnFolderDeleted(item->CloneMetadata());
 
   if (item->is_page_break())
-    client_->OnPageBreakItemDeleted(profile_id_, item->id());
+    client_->OnPageBreakItemDeleted(item->id());
 }
 
 void AppListControllerImpl::OnAppListItemUpdated(app_list::AppListItem* item) {
   if (client_)
-    client_->OnItemUpdated(profile_id_, item->CloneMetadata());
-}
-
-void AppListControllerImpl::OnAppListStateChanged(ash::AppListState new_state,
-                                                  ash::AppListState old_state) {
-  if (!app_list_features::IsEmbeddedAssistantUIEnabled())
-    return;
-
-  UpdateLauncherContainer();
-
-  if (new_state == ash::AppListState::kStateEmbeddedAssistant) {
-    // ShowUi will be no-op if the AssistantUiModel is already visible.
-    Shell::Get()->assistant_controller()->ui_controller()->ShowUi(
-        ash::AssistantEntryPoint::kUnspecified);
-    return;
-  }
-
-  if (old_state == ash::AppListState::kStateEmbeddedAssistant) {
-    // CloseUi will be no-op if the AssistantUiModel is already closed.
-    Shell::Get()->assistant_controller()->ui_controller()->CloseUi(
-        ash::AssistantExitPoint::kBackInLauncher);
-  }
+    client_->OnItemUpdated(item->CloneMetadata());
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -484,7 +430,8 @@
                                  app_list::AppListShowSource show_source,
                                  base::TimeTicks event_time_stamp) {
   UMA_HISTOGRAM_ENUMERATION(app_list::kAppListToggleMethodHistogram,
-                            show_source);
+                            show_source, app_list::kMaxAppListToggleMethod);
+
   if (!presenter_.GetTargetVisibility() && IsVisible()) {
     // The launcher is running close animation, so close it immediately before
     // reshow the launcher in tablet mode.
@@ -492,10 +439,6 @@
   }
 
   presenter_.Show(display_id, event_time_stamp);
-
-  // AppListControllerImpl::Show is called in ash at the first time of showing
-  // app list view. So check whether the expand arrow view should be visible.
-  UpdateExpandArrowVisibility();
 }
 
 void AppListControllerImpl::UpdateYPositionAndOpacity(
@@ -525,17 +468,15 @@
     int64_t display_id,
     app_list::AppListShowSource show_source,
     base::TimeTicks event_time_stamp) {
-  ash::ShelfAction action =
-      presenter_.ToggleAppList(display_id, show_source, event_time_stamp);
-  if (action == SHELF_ACTION_APP_LIST_SHOWN) {
+  if (!IsVisible()) {
     UMA_HISTOGRAM_ENUMERATION(app_list::kAppListToggleMethodHistogram,
-                              show_source);
+                              show_source, app_list::kMaxAppListToggleMethod);
   }
-  return action;
+  return presenter_.ToggleAppList(display_id, event_time_stamp);
 }
 
 app_list::AppListViewState AppListControllerImpl::GetAppListViewState() {
-  return model_->state_fullscreen();
+  return model_.state_fullscreen();
 }
 
 void AppListControllerImpl::OnWindowDragStarted() {
@@ -552,27 +493,6 @@
   bindings_.FlushForTesting();
 }
 
-// Stop observing at the beginning of ~Shell to avoid unnecessary work during
-// Shell shutdown.
-void AppListControllerImpl::OnShellDestroying() {
-  Shell* shell = Shell::Get();
-  shell->home_screen_controller()
-      ->home_launcher_gesture_handler()
-      ->RemoveObserver(this);
-  if (app_list_features::IsEmbeddedAssistantUIEnabled())
-    shell->assistant_controller()->ui_controller()->RemoveModelObserver(this);
-  shell->mru_window_tracker()->RemoveObserver(this);
-  shell->window_tree_host_manager()->RemoveObserver(this);
-  shell->voice_interaction_controller()->RemoveLocalObserver(this);
-  keyboard::KeyboardController::Get()->RemoveObserver(this);
-  shell->overview_controller()->RemoveObserver(this);
-  shell->RemoveShellObserver(this);
-  shell->wallpaper_controller()->RemoveObserver(this);
-  shell->tablet_mode_controller()->RemoveObserver(this);
-  shell->session_controller()->RemoveObserver(this);
-  model_->RemoveObserver(this);
-}
-
 void AppListControllerImpl::OnOverviewModeStarting() {
   if (!IsTabletMode()) {
     DismissAppList();
@@ -621,7 +541,6 @@
 
   // Show the app list if the tablet mode starts.
   ShowHomeLauncher();
-  UpdateLauncherContainer();
 }
 
 void AppListControllerImpl::OnTabletModeEnded() {
@@ -630,7 +549,6 @@
 
   // Dismiss the app list if the tablet mode ends.
   DismissAppList();
-  UpdateLauncherContainer();
 }
 
 void AppListControllerImpl::OnWallpaperColorsChanged() {
@@ -656,11 +574,6 @@
   UpdateHomeLauncherVisibility();
 }
 
-void AppListControllerImpl::OnVoiceInteractionStatusChanged(
-    mojom::VoiceInteractionState state) {
-  UpdateAssistantVisibility();
-}
-
 void AppListControllerImpl::OnVoiceInteractionSettingsEnabled(bool enabled) {
   UpdateAssistantVisibility();
 }
@@ -689,80 +602,6 @@
     ShowHomeLauncher();
 }
 
-void AppListControllerImpl::OnWindowUntracked(aura::Window* untracked_window) {
-  UpdateExpandArrowVisibility();
-}
-
-void AppListControllerImpl::OnUiVisibilityChanged(
-    AssistantVisibility new_visibility,
-    AssistantVisibility old_visibility,
-    base::Optional<AssistantEntryPoint> entry_point,
-    base::Optional<AssistantExitPoint> exit_point) {
-  switch (new_visibility) {
-    case AssistantVisibility::kVisible:
-      if (!IsVisible()) {
-        Show(GetDisplayIdToShowAppListOn(), app_list::kAssistantEntryPoint,
-             base::TimeTicks());
-      }
-
-      if (!IsShowingEmbeddedAssistantUI()) {
-        if (presenter_.GetView()->app_list_state() ==
-            app_list::AppListViewState::PEEKING) {
-          presenter_.GetView()->SetState(app_list::AppListViewState::HALF);
-        }
-        presenter_.ShowEmbeddedAssistantUI(true);
-      }
-      break;
-    case AssistantVisibility::kHidden:
-      NOTREACHED();
-      break;
-    case AssistantVisibility::kClosed:
-      if (!IsShowingEmbeddedAssistantUI())
-        break;
-
-      // Reset model state.
-      presenter_.ShowEmbeddedAssistantUI(false);
-      if (IsTabletMode()) {
-        presenter_.GetView()->app_list_main_view()->ResetForShow();
-        presenter_.GetView()->SetState(
-            app_list::AppListViewState::FULLSCREEN_ALL_APPS);
-      } else if (exit_point != AssistantExitPoint::kBackInLauncher) {
-        DismissAppList();
-      }
-      break;
-  }
-}
-
-void AppListControllerImpl::OnHomeLauncherAnimationComplete(
-    bool shown,
-    int64_t display_id) {
-  CloseAssistantUi(shown ? AssistantExitPoint::kLauncherOpen
-                         : AssistantExitPoint::kLauncherClose);
-}
-
-void AppListControllerImpl::UpdateYPositionAndOpacityForHomeLauncher(
-    int y_position_in_screen,
-    float opacity,
-    UpdateAnimationSettingsCallback callback) {
-  presenter_.UpdateYPositionAndOpacityForHomeLauncher(
-      y_position_in_screen, opacity, std::move(callback));
-}
-
-void AppListControllerImpl::UpdateAfterHomeLauncherShown() {
-  // Show or hide the expand arrow view.
-  UpdateExpandArrowVisibility();
-}
-
-base::Optional<base::TimeDelta>
-AppListControllerImpl::GetOptionalAnimationDuration() {
-  if (model_->state() == ash::AppListState::kStateEmbeddedAssistant) {
-    // If Assistant is shown, we don't want any delay in animation transitions
-    // since the launcher is already shown.
-    return base::TimeDelta::Min();
-  }
-  return base::nullopt;
-}
-
 void AppListControllerImpl::Back() {
   presenter_.GetView()->Back();
 }
@@ -774,12 +613,13 @@
   if (!IsTabletMode())
     return ToggleAppList(display_id, show_source, event_time_stamp);
 
-  bool handled =
-      Shell::Get()
-          ->home_screen_controller()
-          ->home_launcher_gesture_handler()
-          ->ShowHomeLauncher(
+  // Whether the this action is handled.
+  bool handled = false;
+
+  if (home_launcher_gesture_handler_) {
+    handled = home_launcher_gesture_handler_->ShowHomeLauncher(
               Shell::Get()->display_manager()->GetDisplayForId(display_id));
+  }
 
   if (!handled) {
     if (Shell::Get()->overview_controller()->IsSelecting()) {
@@ -796,8 +636,23 @@
     }
   }
 
-  if (!handled)
-    handled = MinimizeAllWindows();
+  if (!handled) {
+    // Minimize all windows that aren't the app list in reverse order to
+    // preserve the mru ordering.
+    aura::Window* app_list_container =
+        Shell::Get()->GetPrimaryRootWindow()->GetChildById(
+            kShellWindowId_AppListTabletModeContainer);
+    aura::Window::Windows windows =
+        Shell::Get()->mru_window_tracker()->BuildWindowForCycleList();
+    std::reverse(windows.begin(), windows.end());
+    for (auto* window : windows) {
+      if (!app_list_container->Contains(window) &&
+          !wm::GetWindowState(window)->IsMinimized()) {
+        wm::GetWindowState(window)->Minimize();
+        handled = true;
+      }
+    }
+  }
 
   // Perform the "back" action for the app list.
   if (!handled)
@@ -806,53 +661,10 @@
   return ash::SHELF_ACTION_APP_LIST_SHOWN;
 }
 
-bool AppListControllerImpl::IsShowingEmbeddedAssistantUI() const {
-  return presenter_.IsShowingEmbeddedAssistantUI();
-}
-
-void AppListControllerImpl::UpdateExpandArrowVisibility() {
-  bool should_show = false;
-
-  // Hide the expand arrow view when tablet mode is enabled and there is no
-  // activatable window.
-  if (IsTabletMode()) {
-    should_show = !ash::Shell::Get()
-                       ->mru_window_tracker()
-                       ->BuildWindowForCycleList()
-                       .empty();
-  } else {
-    should_show = true;
-  }
-
-  presenter_.SetExpandArrowViewVisibility(should_show);
-}
-
-app_list::AppListViewState AppListControllerImpl::CalculateStateAfterShelfDrag(
-    const ui::GestureEvent& gesture_in_screen,
-    float launcher_above_shelf_bottom_amount) const {
-  if (presenter_.GetView())
-    return presenter_.GetView()->CalculateStateAfterShelfDrag(
-        gesture_in_screen, launcher_above_shelf_bottom_amount);
-  return app_list::AppListViewState::CLOSED;
-}
-
-void AppListControllerImpl::SetAppListModelForTest(
-    std::unique_ptr<app_list::AppListModel> model) {
-  model_->RemoveObserver(this);
-  model_ = std::move(model);
-  model_->AddObserver(this);
-}
-
 ////////////////////////////////////////////////////////////////////////////////
 // Methods of |client_|:
 
 void AppListControllerImpl::StartAssistant() {
-  if (app_list_features::IsEmbeddedAssistantUIEnabled()) {
-    ash::Shell::Get()->assistant_controller()->ui_controller()->ShowUi(
-        ash::AssistantEntryPoint::kLauncherSearchBoxMic);
-    return;
-  }
-
   if (!IsTabletMode())
     DismissAppList();
 
@@ -869,12 +681,8 @@
   }
 }
 
-void AppListControllerImpl::OpenSearchResult(
-    const std::string& result_id,
-    int event_flags,
-    ash::mojom::AppListLaunchedFrom launched_from,
-    ash::mojom::AppListLaunchType launch_type,
-    int suggestion_index) {
+void AppListControllerImpl::OpenSearchResult(const std::string& result_id,
+                                             int event_flags) {
   app_list::SearchResult* result = search_model_.FindSearchResult(result_id);
   if (!result)
     return;
@@ -883,10 +691,9 @@
                             result->display_type(),
                             ash::SearchResultDisplayType::kLast);
 
-  // Suggestion chips are not represented to the user as search results, so do
-  // not record search result metrics for them.
-  if (launched_from !=
-      ash::mojom::AppListLaunchedFrom::kLaunchedFromSuggestionChip) {
+  // Record the search metric if the SearchResult is not a suggested app.
+  if (result->display_type() != ash::SearchResultDisplayType::kRecommendation) {
+    // Count AppList.Search here because it is composed of search + action.
     base::RecordAction(base::UserMetricsAction("AppList_OpenSearchResult"));
 
     UMA_HISTOGRAM_COUNTS_100(app_list::kSearchQueryLength,
@@ -898,38 +705,11 @@
     }
   }
 
-  if (presenter_.IsVisible() && result->is_omnibox_search() &&
-      IsAssistantAllowedAndEnabled() &&
-      app_list_features::IsEmbeddedAssistantUIEnabled()) {
-    // Record the assistant result. Other types of results are recorded in
-    // |client_| where there is richer data on SearchResultType.
-    DCHECK_EQ(ash::mojom::AppListLaunchedFrom::kLaunchedFromSearchBox,
-              launched_from)
-        << "Only log search results which are represented to the user as "
-           "search results (ie. search results in the search result page) not "
-           "chips.";
-    app_list::RecordSearchResultOpenTypeHistogram(
-        app_list::ASSISTANT_OMNIBOX_RESULT);
-    Shell::Get()->assistant_controller()->ui_controller()->ShowUi(
-        AssistantEntryPoint::kLauncherSearchResult);
-    Shell::Get()->assistant_controller()->OpenUrl(
-        ash::assistant::util::CreateAssistantQueryDeepLink(
-            base::UTF16ToUTF8(result->title())));
-  } else {
     if (client_)
-      client_->OpenSearchResult(result_id, event_flags, launched_from,
-                                launch_type, suggestion_index);
-  }
-
-  ResetHomeLauncherIfShown();
-}
+    client_->OpenSearchResult(result_id, event_flags);
 
-void AppListControllerImpl::LogResultLaunchHistogram(
-    app_list::SearchResultLaunchLocation launch_location,
-    int suggestion_index) {
-  app_list::RecordSearchLaunchIndexAndQueryLength(
-      launch_location, static_cast<int>(last_raw_query_.size()),
-      suggestion_index);
+  if (IsTabletMode() && presenter_.IsVisible())
+    presenter_.GetView()->CloseOpenedPage();
 }
 
 void AppListControllerImpl::InvokeSearchResultAction(
@@ -958,18 +738,11 @@
 }
 
 void AppListControllerImpl::ViewShown(int64_t display_id) {
-  if (app_list_features::IsEmbeddedAssistantUIEnabled() &&
-      GetAssistantViewDelegate()->GetUiModel()->ui_mode() !=
-          ash::AssistantUiMode::kLauncherEmbeddedUi) {
-    CloseAssistantUi(AssistantExitPoint::kLauncherOpen);
-  }
-  UpdateAssistantVisibility();
   if (client_)
     client_->ViewShown(display_id);
 }
 
 void AppListControllerImpl::ViewClosing() {
-  CloseAssistantUi(AssistantExitPoint::kLauncherClose);
   if (client_)
     client_->ViewClosing();
 }
@@ -989,23 +762,24 @@
 void AppListControllerImpl::ActivateItem(const std::string& id,
                                          int event_flags) {
   if (client_)
-    client_->ActivateItem(profile_id_, id, event_flags);
+    client_->ActivateItem(id, event_flags);
 
-  ResetHomeLauncherIfShown();
+  if (IsTabletMode() && presenter_.IsVisible())
+    presenter_.GetView()->CloseOpenedPage();
 }
 
 void AppListControllerImpl::GetContextMenuModel(
     const std::string& id,
     GetContextMenuModelCallback callback) {
   if (client_)
-    client_->GetContextMenuModel(profile_id_, id, std::move(callback));
+    client_->GetContextMenuModel(id, std::move(callback));
 }
 
 void AppListControllerImpl::ContextMenuItemSelected(const std::string& id,
                                                     int command_id,
                                                     int event_flags) {
   if (client_)
-    client_->ContextMenuItemSelected(profile_id_, id, command_id, event_flags);
+    client_->ContextMenuItemSelected(id, command_id, event_flags);
 }
 
 void AppListControllerImpl::ShowWallpaperContextMenu(
@@ -1017,18 +791,19 @@
 bool AppListControllerImpl::ProcessHomeLauncherGesture(
     ui::GestureEvent* event,
     const gfx::Point& screen_location) {
-  HomeLauncherGestureHandler* home_launcher_gesture_handler =
-      Shell::Get()->home_screen_controller()->home_launcher_gesture_handler();
+  if (!home_launcher_gesture_handler_)
+    return false;
+
   switch (event->type()) {
     case ui::ET_SCROLL_FLING_START:
     case ui::ET_GESTURE_SCROLL_BEGIN:
-      return home_launcher_gesture_handler->OnPressEvent(
+      return home_launcher_gesture_handler_->OnPressEvent(
           HomeLauncherGestureHandler::Mode::kSlideDownToHide, screen_location);
     case ui::ET_GESTURE_SCROLL_UPDATE:
-      return home_launcher_gesture_handler->OnScrollEvent(
+      return home_launcher_gesture_handler_->OnScrollEvent(
           screen_location, event->details().scroll_y());
     case ui::ET_GESTURE_END:
-      return home_launcher_gesture_handler->OnReleaseEvent(screen_location);
+      return home_launcher_gesture_handler_->OnReleaseEvent(screen_location);
     default:
       break;
   }
@@ -1046,10 +821,10 @@
     return false;
   }
 
-  HomeScreenController* home_screen_controller =
-      Shell::Get()->home_screen_controller();
-  return home_screen_controller &&
-         home_screen_controller->home_launcher_gesture_handler()->mode() !=
+  if (!home_launcher_gesture_handler_)
+    return true;
+
+  return home_launcher_gesture_handler_->mode() !=
              HomeLauncherGestureHandler::Mode::kSlideUpToShow;
 }
 
@@ -1059,32 +834,6 @@
     client_->GetNavigableContentsFactory(std::move(request));
 }
 
-ash::AssistantViewDelegate* AppListControllerImpl::GetAssistantViewDelegate() {
-  return Shell::Get()->assistant_controller()->view_delegate();
-}
-
-void AppListControllerImpl::OnSearchResultVisibilityChanged(
-    const std::string& id,
-    bool visibility) {
-  if (client_)
-    client_->OnSearchResultVisibilityChanged(id, visibility);
-}
-
-bool AppListControllerImpl::IsAssistantAllowedAndEnabled() const {
-  if (!chromeos::switches::IsAssistantEnabled())
-    return false;
-
-  if (!Shell::Get()->assistant_controller()->IsAssistantReady())
-    return false;
-
-  auto* controller = Shell::Get()->voice_interaction_controller();
-  return controller->settings_enabled().value_or(false) &&
-         controller->allowed_state() == mojom::AssistantAllowedState::ALLOWED &&
-         controller->voice_interaction_state().value_or(
-             mojom::VoiceInteractionState::NOT_READY) !=
-             mojom::VoiceInteractionState::NOT_READY;
-}
-
 void AppListControllerImpl::AddObserver(AppListControllerObserver* observer) {
   observers_.AddObserver(observer);
 }
@@ -1110,6 +859,20 @@
     client_->OnAppListTargetVisibilityChanged(visible);
 }
 
+void AppListControllerImpl::NotifyHomeLauncherTargetPositionChanged(
+    bool showing,
+    int64_t display_id) {
+  for (auto& observer : observers_)
+    observer.OnHomeLauncherTargetPositionChanged(showing, display_id);
+}
+
+void AppListControllerImpl::NotifyHomeLauncherAnimationComplete(
+    bool shown,
+    int64_t display_id) {
+  for (auto& observer : observers_)
+    observer.OnHomeLauncherAnimationComplete(shown, display_id);
+}
+
 ////////////////////////////////////////////////////////////////////////////////
 // Private used only:
 
@@ -1118,7 +881,7 @@
   // followed by a pre-installed app (e.g. Search), so the poosition should be
   // stable. TODO(stevenjb): consider explicitly setting the OEM folder location
   // along with the name in ServicesCustomizationDocument::SetOemFolderName().
-  app_list::AppListItemList* item_list = model_->top_level_item_list();
+  app_list::AppListItemList* item_list = model_.top_level_item_list();
   if (!item_list->item_count()) {
     LOG(ERROR) << "No top level item was found. "
                << "Placing OEM folder at the beginning.";
@@ -1169,7 +932,7 @@
 
 app_list::AppListFolderItem* AppListControllerImpl::FindFolderItem(
     const std::string& folder_id) {
-  return model_->FindFolderItem(folder_id);
+  return model_.FindFolderItem(folder_id);
 }
 
 void AppListControllerImpl::UpdateHomeLauncherVisibility() {
@@ -1184,8 +947,13 @@
 }
 
 void AppListControllerImpl::UpdateAssistantVisibility() {
+  if (!chromeos::switches::IsAssistantEnabled())
+    return;
+
+  auto* controller = Shell::Get()->voice_interaction_controller();
   GetSearchModel()->search_box()->SetShowAssistantButton(
-      IsAssistantAllowedAndEnabled());
+      controller->settings_enabled().value_or(false) &&
+      controller->allowed_state() == mojom::AssistantAllowedState::ALLOWED);
 }
 
 int64_t AppListControllerImpl::GetDisplayIdToShowAppListOn() {
@@ -1211,51 +979,4 @@
   Shelf::ForWindow(presenter_.GetWindow())->MaybeUpdateShelfBackground();
 }
 
-void AppListControllerImpl::ResetHomeLauncherIfShown() {
-  if (!IsTabletMode() || !presenter_.IsVisible())
-    return;
-
-  auto* const keyboard_controller = keyboard::KeyboardController::Get();
-  if (keyboard_controller->IsKeyboardVisible())
-    keyboard_controller->HideKeyboardByUser();
-  presenter_.GetView()->CloseOpenedPage();
-
-  // Refresh the suggestion chips with empty query.
-  StartSearch(base::string16());
-}
-
-void AppListControllerImpl::UpdateLauncherContainer() {
-  bool launcher_should_show_behind_apps =
-      IsTabletMode() &&
-      model_->state() != ash::AppListState::kStateEmbeddedAssistant;
-
-  aura::Window* window = presenter_.GetWindow();
-  if (!window)
-    return;
-
-  auto container_id = launcher_should_show_behind_apps
-                          ? ash::kShellWindowId_AppListTabletModeContainer
-                          : ash::kShellWindowId_AppListContainer;
-
-  aura::Window* root_window = window->GetRootWindow();
-  aura::Window* parent_window = root_window->GetChildById(container_id);
-  if (parent_window && !parent_window->Contains(window)) {
-    parent_window->AddChild(window);
-    bool is_showing_app_window = false;
-    for (auto* app_window :
-         Shell::Get()->mru_window_tracker()->BuildWindowForCycleList()) {
-      if (!parent_window->Contains(app_window) &&
-          !wm::GetWindowState(app_window)->IsMinimized()) {
-        is_showing_app_window = true;
-        break;
-      }
-    }
-    if (launcher_should_show_behind_apps && is_showing_app_window) {
-      // When move launcher back to behind apps, and there is app window
-      // showing, we release focus.
-      Shell::Get()->activation_client()->DeactivateWindow(window);
-    }
-  }
-}
-
 }  // namespace ash
--- a/ash/app_list/app_list_controller_impl.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/app_list_controller_impl.h	2019-05-17 18:53:08.072000000 +0300
@@ -9,7 +9,6 @@
 #include <string>
 #include <vector>
 
-#include "ash/app_list/app_list_metrics.h"
 #include "ash/app_list/app_list_view_delegate.h"
 #include "ash/app_list/model/app_list_model.h"
 #include "ash/app_list/model/app_list_model_observer.h"
@@ -17,10 +16,8 @@
 #include "ash/app_list/model/search/search_model.h"
 #include "ash/app_list/presenter/app_list_presenter_impl.h"
 #include "ash/ash_export.h"
-#include "ash/assistant/model/assistant_ui_model_observer.h"
 #include "ash/display/window_tree_host_manager.h"
-#include "ash/home_screen/home_launcher_gesture_handler_observer.h"
-#include "ash/home_screen/home_screen_delegate.h"
+#include "ash/public/cpp/app_list/app_list_constants.h"
 #include "ash/public/cpp/assistant/default_voice_interaction_observer.h"
 #include "ash/public/cpp/shelf_types.h"
 #include "ash/public/interfaces/app_list.mojom.h"
@@ -28,8 +25,6 @@
 #include "ash/session/session_observer.h"
 #include "ash/shell_observer.h"
 #include "ash/wallpaper/wallpaper_controller_observer.h"
-#include "ash/wm/mru_window_tracker.h"
-#include "ash/wm/overview/overview_observer.h"
 #include "ash/wm/tablet_mode/tablet_mode_observer.h"
 #include "base/observer_list.h"
 #include "components/sync/model/string_ordinal.h"
@@ -44,6 +39,7 @@
 namespace ash {
 
 class AppListControllerObserver;
+class HomeLauncherGestureHandler;
 
 // Ash's AppListController owns the AppListModel and implements interface
 // functions that allow Chrome to modify and observe the Shelf and AppListModel
@@ -54,16 +50,11 @@
       public app_list::AppListModelObserver,
       public app_list::AppListViewDelegate,
       public ash::ShellObserver,
-      public OverviewObserver,
       public TabletModeObserver,
       public keyboard::KeyboardControllerObserver,
       public WallpaperControllerObserver,
       public DefaultVoiceInteractionObserver,
-      public WindowTreeHostManager::Observer,
-      public ash::MruWindowTracker::Observer,
-      public AssistantUiModelObserver,
-      public HomeLauncherGestureHandlerObserver,
-      public HomeScreenDelegate {
+      public WindowTreeHostManager::Observer {
  public:
   using AppListItemMetadataPtr = mojom::AppListItemMetadataPtr;
   using SearchResultMetadataPtr = mojom::SearchResultMetadataPtr;
@@ -102,8 +93,7 @@
   void SetItemIsInstalling(const std::string& id, bool is_installing) override;
   void SetItemPercentDownloaded(const std::string& id,
                                 int32_t percent_downloaded) override;
-  void SetModelData(int profile_id,
-                    std::vector<AppListItemMetadataPtr> apps,
+  void SetModelData(std::vector<AppListItemMetadataPtr> apps,
                     bool is_search_engine_google) override;
 
   void SetSearchResultMetadata(SearchResultMetadataPtr metadata) override;
@@ -131,8 +121,6 @@
   void OnAppListItemAdded(app_list::AppListItem* item) override;
   void OnAppListItemWillBeDeleted(app_list::AppListItem* item) override;
   void OnAppListItemUpdated(app_list::AppListItem* item) override;
-  void OnAppListStateChanged(ash::AppListState new_state,
-                             ash::AppListState old_state) override;
 
   // SessionObserver:
   void OnActiveUserPrefServiceChanged(PrefService* pref_service) override;
@@ -151,6 +139,9 @@
                                  app_list::AppListShowSource show_source,
                                  base::TimeTicks event_time_stamp);
   app_list::AppListViewState GetAppListViewState();
+  HomeLauncherGestureHandler* home_launcher_gesture_handler() {
+    return home_launcher_gesture_handler_.get();
+  }
 
   // Called when a window starts/ends dragging. If we're in tablet mode and home
   // launcher is enabled, we should hide the home launcher during dragging a
@@ -163,14 +154,7 @@
   app_list::SearchModel* GetSearchModel() override;
   void StartAssistant() override;
   void StartSearch(const base::string16& raw_query) override;
-  void OpenSearchResult(const std::string& result_id,
-                        int event_flags,
-                        ash::mojom::AppListLaunchedFrom launched_from,
-                        ash::mojom::AppListLaunchType launch_type,
-                        int suggestion_index) override;
-  void LogResultLaunchHistogram(
-      app_list::SearchResultLaunchLocation launch_location,
-      int suggestion_index) override;
+  void OpenSearchResult(const std::string& result_id, int event_flags) override;
   void InvokeSearchResultAction(const std::string& result_id,
                                 int action_index,
                                 int event_flags) override;
@@ -200,10 +184,6 @@
   bool CanProcessEventsOnApplistViews() override;
   void GetNavigableContentsFactory(
       content::mojom::NavigableContentsFactoryRequest request) override;
-  ash::AssistantViewDelegate* GetAssistantViewDelegate() override;
-  void OnSearchResultVisibilityChanged(const std::string& id,
-                                       bool visibility) override;
-  bool IsAssistantAllowedAndEnabled() const override;
 
   void AddObserver(AppListControllerObserver* observer);
   void RemoveObserver(AppListControllerObserver* obsever);
@@ -212,12 +192,14 @@
   void NotifyAppListVisibilityChanged(bool visible, int64_t display_id);
   void NotifyAppListTargetVisibilityChanged(bool visible);
 
+  // HomeLauncher visibility announcements are for tablet mode AppList.
+  void NotifyHomeLauncherTargetPositionChanged(bool showing,
+                                               int64_t display_id);
+  void NotifyHomeLauncherAnimationComplete(bool shown, int64_t display_id);
+
   void FlushForTesting();
 
   // ShellObserver:
-  void OnShellDestroying() override;
-
-  // OverviewObserver:
   void OnOverviewModeStarting() override;
   void OnOverviewModeEnding(OverviewSession* overview_session) override;
   void OnOverviewModeEndingAnimationComplete(bool canceled) override;
@@ -235,8 +217,6 @@
   void OnWallpaperPreviewEnded() override;
 
   // mojom::VoiceInteractionObserver:
-  void OnVoiceInteractionStatusChanged(
-      mojom::VoiceInteractionState state) override;
   void OnVoiceInteractionSettingsEnabled(bool enabled) override;
   void OnAssistantFeatureAllowedChanged(
       mojom::AssistantAllowedState state) override;
@@ -244,27 +224,6 @@
   // WindowTreeHostManager::Observer:
   void OnDisplayConfigurationChanged() override;
 
-  // MruWindowTracker::Observer:
-  void OnWindowUntracked(aura::Window* untracked_window) override;
-
-  // AssistantUiModelObserver:
-  void OnUiVisibilityChanged(
-      AssistantVisibility new_visibility,
-      AssistantVisibility old_visibility,
-      base::Optional<AssistantEntryPoint> entry_point,
-      base::Optional<AssistantExitPoint> exit_point) override;
-
-  // HomeLauncherGestureHandlerObserver:
-  void OnHomeLauncherAnimationComplete(bool shown, int64_t display_id) override;
-
-  // HomeScreenDelegate:
-  void UpdateYPositionAndOpacityForHomeLauncher(
-      int y_position_in_screen,
-      float opacity,
-      UpdateAnimationSettingsCallback callback) override;
-  void UpdateAfterHomeLauncherShown() override;
-  base::Optional<base::TimeDelta> GetOptionalAnimationDuration() override;
-
   bool onscreen_keyboard_shown() const { return onscreen_keyboard_shown_; }
 
   // Performs the 'back' action for the active page.
@@ -280,16 +239,6 @@
       app_list::AppListShowSource show_source,
       base::TimeTicks event_time_stamp);
 
-  // Returns current visibility of the Assistant page.
-  bool IsShowingEmbeddedAssistantUI() const;
-
-  // Get updated app list view state after dragging from shelf.
-  app_list::AppListViewState CalculateStateAfterShelfDrag(
-      const ui::GestureEvent& gesture_in_screen,
-      float launcher_above_shelf_bottom_amount) const;
-
-  void SetAppListModelForTest(std::unique_ptr<app_list::AppListModel> model);
-
  private:
   syncer::StringOrdinal GetOemFolderPos();
   std::unique_ptr<app_list::AppListItem> CreateAppListItem(
@@ -303,24 +252,16 @@
   // Update the visibility of Assistant functionality.
   void UpdateAssistantVisibility();
 
-  // Updates the visibility of expand arrow view.
-  void UpdateExpandArrowVisibility();
-
   int64_t GetDisplayIdToShowAppListOn();
 
   // Shows the home launcher in tablet mode.
   void ShowHomeLauncher();
 
-  void ResetHomeLauncherIfShown();
-
-  // Updates which container the launcher window should be in.
-  void UpdateLauncherContainer();
-
   base::string16 last_raw_query_;
 
   mojom::AppListClientPtr client_;
 
-  std::unique_ptr<app_list::AppListModel> model_;
+  app_list::AppListModel model_;
   app_list::SearchModel search_model_;
 
   // |presenter_| should be put below |client_| and |model_| to prevent a crash
@@ -330,6 +271,10 @@
   // Bindings for the AppListController interface.
   mojo::BindingSet<mojom::AppListController> bindings_;
 
+  // Owned pointer to the object which handles gestures related to the home
+  // launcher.
+  std::unique_ptr<HomeLauncherGestureHandler> home_launcher_gesture_handler_;
+
   // Whether the on-screen keyboard is shown.
   bool onscreen_keyboard_shown_ = false;
 
@@ -345,11 +290,6 @@
   // Whether we're currently in a window dragging process.
   bool in_window_dragging_ = false;
 
-  // Used in mojo callings to specify the profile whose app list data is
-  // read/written by Ash side through IPC. Notice that in multi-profile mode,
-  // each profile has its own AppListModelUpdater to manipulate app list items.
-  int profile_id_ = kAppListInvalidProfileID;
-
   base::ObserverList<AppListControllerObserver> observers_;
 
   DISALLOW_COPY_AND_ASSIGN(AppListControllerImpl);
--- a/ash/app_list/app_list_controller_observer.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/app_list_controller_observer.h	2019-05-17 18:53:08.072000000 +0300
@@ -14,6 +14,13 @@
  public:
   // Called when the AppList is shown or dismissed.
   virtual void OnAppListVisibilityChanged(bool shown, int64_t display_id) {}
+  // Called when the HomeLauncher has started to be dragged, or a positional
+  // animation has begin.
+  virtual void OnHomeLauncherTargetPositionChanged(bool showing,
+                                                   int64_t display_id) {}
+  // Called when the HomeLauncher positional animation has completed.
+  virtual void OnHomeLauncherAnimationComplete(bool shown, int64_t display_id) {
+  }
 };
 
 }  // namespace ash
--- a/ash/app_list/app_list_export.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/app_list_export.h	2019-05-17 18:53:08.072000000 +0300
@@ -9,12 +9,21 @@
 // module can be exported to consumers.
 
 #if defined(COMPONENT_BUILD)
+#if defined(WIN32)
 
 #if defined(APP_LIST_IMPLEMENTATION)
+#define APP_LIST_EXPORT __declspec(dllexport)
+#else
+#define APP_LIST_EXPORT __declspec(dllimport)
+#endif  // defined(APP_LIST_IMPLEMENTATION)
+
+#else  // defined(WIN32)
+#if defined(APP_LIST_IMPLEMENTATION)
 #define APP_LIST_EXPORT __attribute__((visibility("default")))
 #else
 #define APP_LIST_EXPORT
 #endif
+#endif
 
 #else  // defined(COMPONENT_BUILD)
 #define APP_LIST_EXPORT
--- a/ash/app_list/app_list_metrics.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/app_list_metrics.cc	2019-05-17 18:53:08.072000000 +0300
@@ -4,8 +4,6 @@
 
 #include "ash/app_list/app_list_metrics.h"
 
-#include <algorithm>
-
 #include "ash/app_list/model/app_list_model.h"
 #include "ash/app_list/model/search/search_model.h"
 #include "ash/app_list/model/search/search_result.h"
@@ -29,16 +27,6 @@
   return smoothness;
 }
 
-// These constants affect logging, and  should not be changed without
-// deprecating the following UMA histograms:
-//  - Apps.AppListTileClickIndexAndQueryLength
-//  - Apps.AppListResultClickIndexAndQueryLength
-constexpr int kMaxLoggedQueryLength = 10;
-constexpr int kMaxLoggedSuggestionIndex = 6;
-constexpr int kMaxLoggedHistogramValue =
-    (kMaxLoggedSuggestionIndex + 1) * kMaxLoggedQueryLength +
-    kMaxLoggedSuggestionIndex;
-
 }  // namespace
 
 // The UMA histogram that logs smoothness of folder show/hide animation.
@@ -48,10 +36,6 @@
 // The UMA histogram that logs smoothness of pagination animation.
 constexpr char kPaginationTransitionAnimationSmoothness[] =
     "Apps.PaginationTransition.AnimationSmoothness";
-constexpr char kPaginationTransitionAnimationSmoothnessInTablet[] =
-    "Apps.PaginationTransition.AnimationSmoothness.TabletMode";
-constexpr char kPaginationTransitionAnimationSmoothnessInClamshell[] =
-    "Apps.PaginationTransition.AnimationSmoothness.ClamshellMode";
 
 // The UMA histogram that logs which state search results are opened from.
 constexpr char kAppListSearchResultOpenSourceHistogram[] =
@@ -87,19 +71,11 @@
 
 void RecordPaginationAnimationSmoothness(int actual_frames,
                                          int ideal_duration_ms,
-                                         float refresh_rate,
-                                         bool is_tablet_mode) {
+                                         float refresh_rate) {
   const int smoothness = CalculateAnimationSmoothness(
       actual_frames, ideal_duration_ms, refresh_rate);
   UMA_HISTOGRAM_PERCENTAGE(kPaginationTransitionAnimationSmoothness,
                            smoothness);
-  if (is_tablet_mode) {
-    UMA_HISTOGRAM_PERCENTAGE(kPaginationTransitionAnimationSmoothnessInTablet,
-                             smoothness);
-  } else {
-    UMA_HISTOGRAM_PERCENTAGE(
-        kPaginationTransitionAnimationSmoothnessInClamshell, smoothness);
-  }
 }
 
 APP_LIST_EXPORT void RecordSearchResultOpenSource(
@@ -124,29 +100,6 @@
       ApplistSearchResultOpenedSource::kMaxApplistSearchResultOpenedSource);
 }
 
-void RecordSearchLaunchIndexAndQueryLength(
-    SearchResultLaunchLocation launch_location,
-    int query_length,
-    int suggestion_index) {
-  if (suggestion_index < 0) {
-    LOG(ERROR) << "Received invalid suggestion index.";
-    return;
-  }
-
-  query_length = std::min(query_length, kMaxLoggedQueryLength);
-  suggestion_index = std::min(suggestion_index, kMaxLoggedSuggestionIndex);
-  const int logged_value =
-      (kMaxLoggedSuggestionIndex + 1) * query_length + suggestion_index;
-
-  if (launch_location == SearchResultLaunchLocation::kResultList) {
-    UMA_HISTOGRAM_EXACT_LINEAR(kAppListResultLaunchIndexAndQueryLength,
-                               logged_value, kMaxLoggedHistogramValue);
-  } else if (launch_location == SearchResultLaunchLocation::kTileList) {
-    UMA_HISTOGRAM_EXACT_LINEAR(kAppListTileLaunchIndexAndQueryLength,
-                               logged_value, kMaxLoggedHistogramValue);
-  }
-}
-
 void RecordZeroStateSearchResultUserActionHistogram(
     ZeroStateSearchResultUserActionType action) {
   UMA_HISTOGRAM_ENUMERATION(kAppListZeroStateSearchResultUserActionHistogram,
--- a/ash/app_list/app_list_metrics.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/app_list_metrics.h	2019-05-17 18:53:08.072000000 +0300
@@ -23,82 +23,6 @@
 constexpr char kAppListHideInputLatencyHistogram[] =
     "Apps.AppListHide.InputLatency";
 
-// The UMA histogram that logs usage of suggested and regular apps.
-constexpr char kAppListAppLaunched[] = "Apps.AppListAppLaunched";
-
-// The UMA histogram that logs usage of suggested and regular apps while the
-// fullscreen launcher is enabled.
-constexpr char kAppListAppLaunchedFullscreen[] =
-    "Apps.AppListAppLaunchedFullscreen";
-
-// The UMA histogram that logs different ways to move an app in app list's apps
-// grid.
-constexpr char kAppListAppMovingType[] = "Apps.AppListAppMovingType";
-
-// The UMA histogram that logs the creation time of the AppListView.
-constexpr char kAppListCreationTimeHistogram[] = "Apps.AppListCreationTime";
-
-// The UMA histogram that logs usage of state transitions in the new
-// app list UI.
-constexpr char kAppListStateTransitionSourceHistogram[] =
-    "Apps.AppListStateTransitionSource";
-
-// The UMA histogram that logs the source of vertical page switcher usage in the
-// app list.
-constexpr char kAppListPageSwitcherSourceHistogram[] =
-    "Apps.AppListPageSwitcherSource";
-
-// The UMA histogram that logs usage of the original and redesigned folders.
-constexpr char kAppListFolderOpenedHistogram[] = "Apps.AppListFolderOpened";
-
-// The UMA histogram that logs how the app list transitions from peeking to
-// fullscreen.
-constexpr char kAppListPeekingToFullscreenHistogram[] =
-    "Apps.AppListPeekingToFullscreenSource";
-
-// The UMA histogram that logs how the app list is shown.
-constexpr char kAppListToggleMethodHistogram[] = "Apps.AppListShowSource";
-
-// The UMA histogram that logs the index launched item in the results list and
-// the query length.
-constexpr char kAppListResultLaunchIndexAndQueryLength[] =
-    "Apps.AppListResultLaunchIndexAndQueryLength";
-
-// The UMA histogram that logs the index launched item in the app tile list and
-// the query length.
-constexpr char kAppListTileLaunchIndexAndQueryLength[] =
-    "Apps.AppListTileLaunchIndexAndQueryLength";
-
-// The UMA histogram that logs which page gets opened by the user.
-constexpr char kPageOpenedHistogram[] = "Apps.AppListPageOpened";
-
-// The UMA histogram that logs how many apps users have in folders.
-constexpr char kNumberOfAppsInFoldersHistogram[] =
-    "Apps.AppsInFolders.FullscreenAppListEnabled";
-
-// The UMA histogram that logs how many folders users have.
-constexpr char kNumberOfFoldersHistogram[] = "Apps.NumberOfFolders";
-
-// The UMA histogram that logs how many pages users have in top level apps grid.
-constexpr char kNumberOfPagesHistogram[] = "Apps.NumberOfPages";
-
-// The UMA histogram that logs how many pages with empty slots users have in top
-// level apps grid.
-constexpr char kNumberOfPagesNotFullHistogram[] = "Apps.NumberOfPagesNotFull";
-
-// The UMA histogram that logs the type of search result opened.
-constexpr char kSearchResultOpenDisplayTypeHistogram[] =
-    "Apps.AppListSearchResultOpenDisplayType";
-
-// The UMA histogram that logs how long the search query was when a result was
-// opened.
-constexpr char kSearchQueryLength[] = "Apps.AppListSearchQueryLength";
-
-// The UMA histogram that logs the Manhattan distance from the origin of the
-// search results to the selected result.
-constexpr char kSearchResultDistanceFromOrigin[] =
-    "Apps.AppListSearchResultDistanceFromOrigin";
-
 // These are used in histograms, do not remove/renumber entries. If you're
 // adding to this enum with the intention that it will be logged, update the
 // AppListZeroStateSearchResultUserActionType enum listing in
@@ -119,102 +43,13 @@
   kMaxValue = kRemovalCanceled,
 };
 
-// The different ways that the app list can transition from PEEKING to
-// FULLSCREEN_ALL_APPS. These values are written to logs.  New enum
-// values can be added, but existing enums must never be renumbered or deleted
-// and reused.
-enum AppListPeekingToFullscreenSource {
-  kSwipe = 0,
-  kExpandArrow = 1,
-  kMousepadScroll = 2,
-  kMousewheelScroll = 3,
-  kMaxPeekingToFullscreen = 4,
-};
-
-// The different ways the app list can be shown. These values are written to
-// logs.  New enum values can be added, but existing enums must never be
-// renumbered or deleted and reused.
-enum AppListShowSource {
-  kSearchKey = 0,
-  kShelfButton = 1,
-  kSwipeFromShelf = 2,
-  kTabletMode = 3,
-  kSearchKeyFullscreen = 4,
-  kShelfButtonFullscreen = 5,
-  kAssistantEntryPoint = 6,
-  kMaxValue = kAssistantEntryPoint,
-};
-
-// The two versions of folders. These values are written to logs.  New enum
-// values can be added, but existing enums must never be renumbered or deleted
-// and reused.
-enum AppListFolderOpened {
-  kOldFolders = 0,
-  kFullscreenAppListFolders = 1,
-  kMaxFolderOpened = 2,
-};
-
-// The valid AppListState transitions. These values are written to logs.  New
-// enum values can be added, but existing enums must never be renumbered or
-// deleted and reused. If adding a state transition, add it to the switch
-// statement in AppListView::GetAppListStateTransitionSource.
-enum AppListStateTransitionSource {
-  kFullscreenAllAppsToClosed = 0,
-  kFullscreenAllAppsToFullscreenSearch = 1,
-  kFullscreenAllAppsToPeeking = 2,
-  kFullscreenSearchToClosed = 3,
-  kFullscreenSearchToFullscreenAllApps = 4,
-  kHalfToClosed = 5,
-  KHalfToFullscreenSearch = 6,
-  kHalfToPeeking = 7,
-  kPeekingToClosed = 8,
-  kPeekingToFullscreenAllApps = 9,
-  kPeekingToHalf = 10,
-  kMaxAppListStateTransition = 11,
-};
-
-// The different ways to change pages in the app list's app grid. These values
-// are written to logs.  New enum values can be added, but existing enums must
-// never be renumbered or deleted and reused.
-enum AppListPageSwitcherSource {
-  kTouchPageIndicator = 0,
-  kClickPageIndicator = 1,
-  kSwipeAppGrid = 2,
-  kFlingAppGrid = 3,
-  kMouseWheelScroll = 4,
-  kMousePadScroll = 5,
-  kDragAppToBorder = 6,
-  kMaxAppListPageSwitcherSource = 7,
-};
-
-// The different ways to move an app in app list's apps grid. These values are
-// written to logs. New enum values can be added, but existing enums must never
-// be renumbered or deleted and reused.
-enum AppListAppMovingType {
-  kMoveIntoFolder = 0,
-  kMoveOutOfFolder = 1,
-  kMoveIntoAnotherFolder = 2,
-  kReorderInFolder = 3,
-  kReorderInTopLevel = 4,
-  kMaxAppListAppMovingType = 5,
-};
-
-// Different places a search result can be launched from. These values do not
-// persist to logs, so can be changed as-needed. However, changes should be
-// reflected in RecordSearchLaunchIndexAndQueryLength().
-enum SearchResultLaunchLocation {
-  kResultList = 0,
-  kTileList = 1,
-};
-
 void RecordFolderShowHideAnimationSmoothness(int actual_frames,
                                              int ideal_duration_ms,
                                              float refresh_rate);
 
 void RecordPaginationAnimationSmoothness(int actual_frames,
                                          int ideal_duration_ms,
-                                         float refresh_rate,
-                                         bool is_tablet_mode);
+                                         float refresh_rate);
 
 void RecordZeroStateSearchResultUserActionHistogram(
     ZeroStateSearchResultUserActionType action);
@@ -227,11 +62,6 @@
     const AppListModel* model,
     const SearchModel* search_model);
 
-APP_LIST_EXPORT void RecordSearchLaunchIndexAndQueryLength(
-    SearchResultLaunchLocation launch_location,
-    int query_length,
-    int suggestion_index);
-
 }  // namespace app_list
 
 #endif  // ASH_APP_LIST_APP_LIST_METRICS_H_
--- a/ash/app_list/app_list_presenter_delegate_impl.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/app_list_presenter_delegate_impl.cc	2019-05-17 18:53:08.072000000 +0300
@@ -6,10 +6,8 @@
 
 #include "ash/app_list/app_list_controller_impl.h"
 #include "ash/app_list/presenter/app_list_presenter_impl.h"
-#include "ash/app_list/views/app_list_main_view.h"
 #include "ash/app_list/views/app_list_view.h"
-#include "ash/app_list/views/contents_view.h"
-#include "ash/app_list/views/search_box_view.h"
+#include "ash/public/cpp/app_list/app_list_constants.h"
 #include "ash/public/cpp/app_list/app_list_switches.h"
 #include "ash/public/cpp/ash_switches.h"
 #include "ash/public/cpp/shelf_types.h"
@@ -247,21 +246,6 @@
     if (!shelf_window || !shelf_window->Contains(target))
       presenter_->Dismiss(event->time_stamp());
   }
-
-  if (IsTabletMode() && presenter_->IsShowingEmbeddedAssistantUI()) {
-    auto* contents_view =
-        presenter_->GetView()->app_list_main_view()->contents_view();
-    if (target == contents_view->GetWidget()->GetNativeWindow() &&
-        contents_view->bounds().Contains(event->location())) {
-      // Keep Assistant open if event happen inside.
-      return;
-    }
-
-    // Touching anywhere else closes Assistant.
-    view_->Back();
-    view_->search_box_view()->ClearSearch();
-    view_->search_box_view()->SetSearchBoxActive(false, ui::ET_UNKNOWN);
-  }
 }
 
 ////////////////////////////////////////////////////////////////////////////////
--- a/ash/app_list/app_list_presenter_delegate_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/app_list_presenter_delegate_unittest.cc	2019-05-17 18:53:08.072000000 +0300
@@ -44,7 +44,6 @@
 #include "ash/wm/window_state.h"
 #include "ash/wm/window_util.h"
 #include "ash/wm/workspace_controller_test_api.h"
-#include "base/bind_helpers.h"
 #include "base/command_line.h"
 #include "base/macros.h"
 #include "base/run_loop.h"
@@ -212,7 +211,7 @@
 
 // Instantiate the Boolean which is used to toggle mouse and touch events in
 // the parameterized tests.
-INSTANTIATE_TEST_SUITE_P(, AppListPresenterDelegateTest, testing::Bool());
+INSTANTIATE_TEST_CASE_P(, AppListPresenterDelegateTest, testing::Bool());
 
 TEST_F(PopulatedAppListTest, TappingAppsGridClosesVirtualKeyboard) {
   InitializeAppsGrid();
@@ -1279,7 +1278,7 @@
 
   // The opacity should be set on the color, not the layer. Setting opacity on
   // the layer will change the opacity of the blur effect, which is not desired.
-  const U8CPU clamshell_background_opacity = static_cast<U8CPU>(255 * 0.74);
+  const U8CPU clamshell_background_opacity = static_cast<U8CPU>(255 * 0.7);
   EXPECT_EQ(SkColorSetA(app_list::AppListView::kDefaultBackgroundColor,
                         clamshell_background_opacity),
             GetAppListView()->GetAppListBackgroundShieldColorForTest());
@@ -1805,7 +1804,7 @@
 
 // Instantiate the Boolean which is used to toggle mouse and touch events in
 // the parameterized tests.
-INSTANTIATE_TEST_SUITE_P(,
+INSTANTIATE_TEST_CASE_P(,
                          AppListPresenterDelegateVirtualKeyboardTest,
                          testing::Bool());
 
--- a/ash/app_list/app_list_util.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/app_list_util.cc	2019-05-17 18:53:08.076000000 +0300
@@ -4,51 +4,49 @@
 
 #include "ash/app_list/app_list_util.h"
 
+#include "ash/public/cpp/app_list/app_list_constants.h"
 #include "ui/views/controls/textfield/textfield.h"
 #include "ui/views/focus/focus_manager.h"
 
 namespace app_list {
 
-bool IsUnhandledUnmodifiedEvent(const ui::KeyEvent& event) {
+bool CanProcessLeftRightKeyTraversal(const ui::KeyEvent& event) {
   if (event.handled() || event.type() != ui::ET_KEY_PRESSED)
     return false;
 
+  if (event.key_code() != ui::VKEY_LEFT && event.key_code() != ui::VKEY_RIGHT)
+    return false;
+
   if (event.IsShiftDown() || event.IsControlDown() || event.IsAltDown())
     return false;
 
   return true;
 }
 
-bool IsUnhandledLeftRightKeyEvent(const ui::KeyEvent& event) {
-  if (!IsUnhandledUnmodifiedEvent(event))
+bool CanProcessUpDownKeyTraversal(const ui::KeyEvent& event) {
+  if (event.handled() || event.type() != ui::ET_KEY_PRESSED)
     return false;
 
-  return event.key_code() == ui::VKEY_LEFT ||
-         event.key_code() == ui::VKEY_RIGHT;
-}
-
-bool IsUnhandledUpDownKeyEvent(const ui::KeyEvent& event) {
-  if (!IsUnhandledUnmodifiedEvent(event))
+  if (event.key_code() != ui::VKEY_UP && event.key_code() != ui::VKEY_DOWN)
     return false;
 
-  return event.key_code() == ui::VKEY_UP || event.key_code() == ui::VKEY_DOWN;
-}
-
-bool IsUnhandledArrowKeyEvent(const ui::KeyEvent& event) {
-  if (!IsUnhandledUnmodifiedEvent(event))
+  if (event.IsShiftDown() || event.IsControlDown() || event.IsAltDown())
     return false;
 
-  return event.key_code() == ui::VKEY_DOWN ||
-         event.key_code() == ui::VKEY_RIGHT ||
-         event.key_code() == ui::VKEY_LEFT || event.key_code() == ui::VKEY_UP;
+  return true;
 }
 
-bool LeftRightKeyEventShouldExitText(views::Textfield* textfield,
+bool ProcessLeftRightKeyTraversalForTextfield(views::Textfield* textfield,
                                      const ui::KeyEvent& key_event) {
-  DCHECK(IsUnhandledLeftRightKeyEvent(key_event));
+  DCHECK(CanProcessLeftRightKeyTraversal(key_event));
 
-  if (textfield->text().empty())
+  const bool move_focus_reverse = base::i18n::IsRTL()
+                                      ? key_event.key_code() == ui::VKEY_RIGHT
+                                      : key_event.key_code() == ui::VKEY_LEFT;
+  if (textfield->text().empty()) {
+    textfield->GetFocusManager()->AdvanceFocus(move_focus_reverse);
     return true;
+  }
 
   if (textfield->HasSelection())
     return false;
@@ -74,20 +72,6 @@
     return false;
   }
 
-  return true;
-}
-
-bool ProcessLeftRightKeyTraversalForTextfield(views::Textfield* textfield,
-                                              const ui::KeyEvent& key_event) {
-  DCHECK(IsUnhandledLeftRightKeyEvent(key_event));
-
-  if (!LeftRightKeyEventShouldExitText(textfield, key_event))
-    return false;
-
-  const bool move_focus_reverse = base::i18n::IsRTL()
-                                      ? key_event.key_code() == ui::VKEY_RIGHT
-                                      : key_event.key_code() == ui::VKEY_LEFT;
-
   // Move focus outside the textfield.
   textfield->GetFocusManager()->AdvanceFocus(move_focus_reverse);
   return true;
--- a/ash/app_list/app_list_util.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/app_list_util.h	2019-05-17 18:53:08.076000000 +0300
@@ -14,26 +14,15 @@
 
 namespace app_list {
 
-// Returns true if the key event is an unhandled left or right arrow (unmodified
-// by ctrl, shift, or alt)
-APP_LIST_EXPORT bool IsUnhandledLeftRightKeyEvent(const ui::KeyEvent& event);
+// Returns true if the key event can be handled to do left or right focus
+// traversal.
+APP_LIST_EXPORT bool CanProcessLeftRightKeyTraversal(const ui::KeyEvent& event);
+
+// Returns true if the key event can be handled to do up or down focus
+// traversal.
+APP_LIST_EXPORT bool CanProcessUpDownKeyTraversal(const ui::KeyEvent& event);
 
-// Returns true if the key event is an unhandled up or down arrow (unmodified by
-// ctrl, shift, or alt)
-APP_LIST_EXPORT bool IsUnhandledUpDownKeyEvent(const ui::KeyEvent& event);
-
-// Returns true if the key event is an unhandled arrow key event of any type
-// (unmodified by ctrl, shift, or alt)
-APP_LIST_EXPORT bool IsUnhandledArrowKeyEvent(const ui::KeyEvent& event);
-
-// Returns true if the arrow key event should move focus away from the
-// |textfield|. This is usually when the insertion point would move away from
-// text.
-APP_LIST_EXPORT bool LeftRightKeyEventShouldExitText(
-    views::Textfield* textfield,
-    const ui::KeyEvent& key_event);
-
-// Processes left/right key traversal for the given |textfield|. Returns true
+// Processes left/right key traversal for the given Textfield. Returns true
 // if focus is moved.
 APP_LIST_EXPORT bool ProcessLeftRightKeyTraversalForTextfield(
     views::Textfield* textfield,
--- a/ash/app_list/app_list_view_delegate.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/app_list_view_delegate.h	2019-05-17 18:53:08.076000000 +0300
@@ -8,10 +8,7 @@
 #include <string>
 #include <vector>
 
-#include "ash/app_list/app_list_metrics.h"
-#include "ash/assistant/ui/assistant_view_delegate.h"
 #include "ash/public/cpp/ash_public_export.h"
-#include "ash/public/interfaces/app_list.mojom.h"
 #include "ash/public/interfaces/menu.mojom.h"
 #include "base/callback_forward.h"
 #include "base/strings/string16.h"
@@ -49,28 +46,9 @@
   // box by the user.
   virtual void StartSearch(const base::string16& raw_query) = 0;
 
-  // Invoked to open the search result and log a click. If the result is
-  // represented by a SuggestedChipView or is a zero state result,
-  // |suggested_index| is the index of the view in the list of suggestions.
-  // |launched_from| values must match the LaunchedFrom enum in
-  // chrome/browser/ui/app_list/app_launch_event_logger.proto. |launch_type| is
-  // either kAppSearchResult or kSearchResult and is used to determine which
-  // histograms to log to.
+  // Invoked to open the search result.
   virtual void OpenSearchResult(const std::string& result_id,
-                                int event_flags,
-                                ash::mojom::AppListLaunchedFrom launched_from,
-                                ash::mojom::AppListLaunchType launch_type,
-                                int suggestion_index) = 0;
-
-  // Called to log UMA metrics for the launch of an item either in the app tile
-  // list or the search result list. The |launch_location| argument determines
-  // which histogram to log to. |suggestion_index| represents the index of the
-  // launched item in its list view, not the overall position in the suggestion
-  // window. For instance, the first launcher result item is index 0, regardless
-  // of if there is an answer card above it.
-  virtual void LogResultLaunchHistogram(
-      app_list::SearchResultLaunchLocation launch_location,
-      int suggestion_index) = 0;
+                                int event_flags) = 0;
 
   // Called to invoke a custom action on a result with |result_id|.
   // |action_index| corresponds to the index of an icon in
@@ -151,17 +129,6 @@
   // the app list UI.
   virtual void GetNavigableContentsFactory(
       content::mojom::NavigableContentsFactoryRequest request) = 0;
-
-  // Returns the AssistantViewDelegate.
-  virtual ash::AssistantViewDelegate* GetAssistantViewDelegate() = 0;
-
-  // Called if a search result has its visibility updated and wants to
-  // be notified (i.e. its notify_visibility_change() returns true).
-  virtual void OnSearchResultVisibilityChanged(const std::string& id,
-                                               bool visibility) = 0;
-
-  // Returns if the Assistant feature is allowed and enabled.
-  virtual bool IsAssistantAllowedAndEnabled() const = 0;
 };
 
 }  // namespace app_list
--- a/ash/app_list/BUILD.gn	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/BUILD.gn	2019-05-17 18:53:08.072000000 +0300
@@ -40,14 +40,6 @@
     "views/apps_grid_view.cc",
     "views/apps_grid_view.h",
     "views/apps_grid_view_folder_delegate.h",
-    "views/assistant/assistant_main_stage.cc",
-    "views/assistant/assistant_main_stage.h",
-    "views/assistant/assistant_main_view.cc",
-    "views/assistant/assistant_main_view.h",
-    "views/assistant/assistant_page_view.cc",
-    "views/assistant/assistant_page_view.h",
-    "views/assistant/dialog_plate.cc",
-    "views/assistant/dialog_plate.h",
     "views/contents_view.cc",
     "views/contents_view.h",
     "views/expand_arrow_view.cc",
@@ -57,8 +49,6 @@
     "views/folder_header_view.cc",
     "views/folder_header_view.h",
     "views/folder_header_view_delegate.h",
-    "views/ghost_image_view.cc",
-    "views/ghost_image_view.h",
     "views/horizontal_page.cc",
     "views/horizontal_page.h",
     "views/horizontal_page_container.cc",
@@ -105,14 +95,9 @@
   deps = [
     "//ash/app_list/resources",
     "//ash/app_menu",
-    "//ash/assistant/model",
-    "//ash/assistant/ui",
     "//ash/assistant/ui:constants",
-    "//ash/assistant/util",
     "//ash/public/cpp/app_list/vector_icons",
     "//ash/public/cpp/vector_icons",
-    "//ash/resources/vector_icons",
-    "//ash/strings",
     "//base",
     "//base:i18n",
     "//base/third_party/dynamic_annotations",
@@ -229,7 +214,6 @@
     "//ash/public/cpp/app_list/vector_icons",
     "//base",
     "//base/test:test_support",
-    "//chromeos/constants",
     "//mojo/core/embedder",
     "//mojo/public/cpp/bindings",
     "//services/content/public/cpp",
--- a/ash/app_list/DEPS	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/DEPS	2019-05-17 18:53:08.072000000 +0300
@@ -1,10 +1,4 @@
 include_rules = [
-  "+ash/assistant/model",
-  "+ash/assistant/ui",
-  "+ash/assistant/util",
-  "+ash/resources/vector_icons",
-  "+ash/strings",
-  "+chromeos/constants",
   "+components/keyed_service/core",
   "+components/sync",
   "+mojo/public/cpp",
--- a/ash/app_list/model/app_list_folder_item.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/model/app_list_folder_item.cc	2019-05-17 18:53:08.076000000 +0300
@@ -47,14 +47,6 @@
   return item_list_->item_count();
 }
 
-bool AppListFolderItem::IsPersistent() const {
-  return GetMetadata()->is_persistent;
-}
-
-void AppListFolderItem::SetIsPersistent(bool is_persistent) {
-  metadata()->is_persistent = is_persistent;
-}
-
 bool AppListFolderItem::CompareForTest(const AppListItem* other) const {
   if (!AppListItem::CompareForTest(other))
     return false;
@@ -70,10 +62,6 @@
   return true;
 }
 
-bool AppListFolderItem::ShouldAutoRemove() const {
-  return ChildItemCount() <= (IsPersistent() ? 0u : 1u);
-}
-
 std::string AppListFolderItem::GenerateId() {
   return base::GenerateGUID();
 }
--- a/ash/app_list/model/app_list_folder_item.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/model/app_list_folder_item.h	2019-05-17 18:53:08.076000000 +0300
@@ -67,14 +67,6 @@
   size_t ChildItemCount() const override;
   bool CompareForTest(const AppListItem* other) const override;
 
-  // Persistent folders will be retained even if there is 1 app in them.
-  bool IsPersistent() const;
-  void SetIsPersistent(bool is_persistent);
-
-  // Returns true if this folder is a candidate for auto-removal (based on its
-  // type and the number of children it has).
-  bool ShouldAutoRemove() const;
-
   // Returns an id for a new folder.
   static std::string GenerateId();
 
--- a/ash/app_list/model/app_list_item.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/model/app_list_item.cc	2019-05-17 18:53:08.076000000 +0300
@@ -10,16 +10,14 @@
 namespace app_list {
 
 AppListItem::AppListItem(const std::string& id)
-    : metadata_(ash::mojom::AppListItemMetadata::New(
-          id,
-          std::string() /* name */,
-          std::string() /* short_name */,
-          std::string() /* folder_id */,
-          syncer::StringOrdinal() /* position */,
-          false /* is_folder */,
-          false /* is_persistent */,
-          gfx::ImageSkia() /* icon */,
-          false /* is_page_break */)),
+    : metadata_(ash::mojom::AppListItemMetadata::New(id,
+                                                     std::string(),
+                                                     std::string(),
+                                                     std::string(),
+                                                     syncer::StringOrdinal(),
+                                                     false,
+                                                     gfx::ImageSkia(),
+                                                     false)),
       is_installing_(false),
       percent_downloaded_(-1) {}
 
--- a/ash/app_list/model/app_list_item.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/model/app_list_item.h	2019-05-17 18:53:08.076000000 +0300
@@ -96,9 +96,6 @@
   bool is_page_break() const { return metadata_->is_page_break; }
 
  protected:
-  // Subclasses also have mutable access to the metadata ptr.
-  ash::mojom::AppListItemMetadata* metadata() { return metadata_.get(); }
-
   friend class ::FastShowPickler;
   friend class ash::AppListControllerImpl;
   friend class AppListItemList;
--- a/ash/app_list/model/app_list_model.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/model/app_list_model.cc	2019-05-17 18:53:08.076000000 +0300
@@ -40,13 +40,7 @@
 }
 
 void AppListModel::SetState(ash::AppListState state) {
-  if (state_ == state)
-    return;
-
-  auto old_state = state_;
   state_ = state;
-  for (auto& observer : observers_)
-    observer.OnAppListStateChanged(state_, old_state);
 }
 
 void AppListModel::SetStateFullscreen(AppListViewState state) {
@@ -280,12 +274,10 @@
   const std::string folder_id = item->folder_id();
   DeleteItem(id);
 
-  // crbug.com/368111: Deleting a child item may cause the parent folder to be
-  // auto-removed. Further, if an auto-removed folder has an item in it, that
-  // item needs to be reparented first.
+  // crbug.com/368111: Upon uninstall of 2nd-to-last folder item, reparent last
+  // item to top; this will remove the folder.
   AppListFolderItem* folder = FindFolderItem(folder_id);
-  if (folder && folder->ShouldAutoRemove() &&
-      folder->item_list()->item_count() == 1) {
+  if (folder && folder->ChildItemCount() == 1u) {
     AppListItem* last_item = folder->item_list()->item_at(0);
     MoveItemToFolderAt(last_item, "", folder->position());
   }
--- a/ash/app_list/model/app_list_model_export.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/model/app_list_model_export.h	2019-05-17 18:53:08.076000000 +0300
@@ -9,12 +9,21 @@
 // app_list_model module can be exported to consumers.
 
 #if defined(COMPONENT_BUILD)
+#if defined(WIN32)
 
 #if defined(APP_LIST_MODEL_IMPLEMENTATION)
+#define APP_LIST_MODEL_EXPORT __declspec(dllexport)
+#else
+#define APP_LIST_MODEL_EXPORT __declspec(dllimport)
+#endif  // defined(APP_LIST_MODEL_IMPLEMENTATION)
+
+#else  // defined(WIN32)
+#if defined(APP_LIST_MODEL_IMPLEMENTATION)
 #define APP_LIST_MODEL_EXPORT __attribute__((visibility("default")))
 #else
 #define APP_LIST_MODEL_EXPORT
 #endif
+#endif
 
 #else  // defined(COMPONENT_BUILD)
 #define APP_LIST_MODEL_EXPORT
--- a/ash/app_list/model/app_list_model_observer.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/model/app_list_model_observer.h	2019-05-17 18:53:08.076000000 +0300
@@ -31,10 +31,6 @@
   // Triggered after |item| has moved, changed folders, or changed properties.
   virtual void OnAppListItemUpdated(AppListItem* item) {}
 
-  // Triggered after AppListState has changed.
-  virtual void OnAppListStateChanged(ash::AppListState new_state,
-                                     ash::AppListState old_state) {}
-
   // Triggered when the custom launcher page enabled state is changed.
   virtual void OnCustomLauncherPageEnabledStateChanged(bool enabled) {}
 
--- a/ash/app_list/model/app_list_model_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/model/app_list_model_unittest.cc	2019-05-17 18:53:08.076000000 +0300
@@ -444,26 +444,6 @@
   EXPECT_EQ("Item 0", GetModelContents());
 }
 
-TEST_F(AppListModelFolderTest, UninstallPersistentFolderItem) {
-  AppListItem* item0 = model_.CreateAndAddItem("Item 0");
-  AppListItem* item1 = model_.CreateAndAddItem("Item 1");
-  AppListFolderItem* folder1 = static_cast<AppListFolderItem*>(
-      model_.AddItem(new AppListFolderItem("folder1")));
-  folder1->SetIsPersistent(true);
-  EXPECT_EQ("Item 0,Item 1,folder1", GetModelContents());
-
-  // Move all items to folder1.
-  model_.MoveItemToFolderAt(item0, folder1->id(), item0->position());
-  model_.MoveItemToFolderAt(item1, folder1->id(), item1->position());
-  EXPECT_EQ("Item 0,Item 1", GetItemListContents(folder1->item_list()));
-  EXPECT_EQ("folder1", GetModelContents());
-
-  // Delete Item from folder.
-  model_.DeleteUninstalledItem("Item 1");
-  ASSERT_EQ("folder1", GetModelContents());
-  EXPECT_EQ("Item 0", GetItemListContents(folder1->item_list()));
-}
-
 TEST_F(AppListModelFolderTest, UninstallSingleItemFolderItem) {
   AppListItem* item0 = model_.CreateAndAddItem("Item 0");
   AppListFolderItem* folder1 = static_cast<AppListFolderItem*>(
--- a/ash/app_list/model/folder_image.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/model/folder_image.cc	2019-05-17 18:53:08.076000000 +0300
@@ -10,6 +10,7 @@
 #include "ash/app_list/model/app_list_item.h"
 #include "ash/app_list/model/app_list_item_list.h"
 #include "ash/public/cpp/app_list/app_list_config.h"
+#include "ash/public/cpp/app_list/app_list_constants.h"
 #include "base/macros.h"
 #include "base/memory/ptr_util.h"
 #include "ui/base/l10n/l10n_util.h"
--- a/ash/app_list/model/search/search_model.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/model/search/search_model.cc	2019-05-17 18:53:08.076000000 +0300
@@ -8,8 +8,6 @@
 #include <string>
 #include <utility>
 
-#include "base/bind.h"
-
 namespace app_list {
 
 SearchModel::SearchModel()
@@ -31,27 +29,11 @@
     SearchResult::DisplayType display_type,
     const std::set<std::string>& excludes,
     size_t max_results) {
-  base::RepeatingCallback<bool(const SearchResult&)> filter_function =
-      base::BindRepeating(
-          [](const SearchResult::DisplayType& display_type,
-             const std::set<std::string>& excludes,
-             const SearchResult& r) -> bool {
-            return excludes.count(r.id()) == 0 &&
-                   display_type == r.display_type();
-          },
-          display_type, excludes);
-  return SearchModel::FilterSearchResultsByFunction(results, filter_function,
-                                                    max_results);
-}
-
-std::vector<SearchResult*> SearchModel::FilterSearchResultsByFunction(
-    SearchResults* results,
-    const base::RepeatingCallback<bool(const SearchResult&)>& result_filter,
-    size_t max_results) {
   std::vector<SearchResult*> matches;
   for (size_t i = 0; i < results->item_count(); ++i) {
     SearchResult* item = results->GetItemAt(i);
-    if (result_filter.Run(*item)) {
+    if (item->display_type() == display_type &&
+        excludes.count(item->id()) == 0) {
       matches.push_back(item);
       if (matches.size() == max_results)
         break;
--- a/ash/app_list/model/search/search_model.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/model/search/search_model.h	2019-05-17 18:53:08.076000000 +0300
@@ -13,7 +13,6 @@
 #include "ash/app_list/model/app_list_model_export.h"
 #include "ash/app_list/model/search/search_box_model.h"
 #include "ash/app_list/model/search/search_result.h"
-#include "base/callback.h"
 #include "ui/base/models/list_model.h"
 
 namespace app_list {
@@ -48,13 +47,6 @@
       const std::set<std::string>& excludes,
       size_t max_results);
 
-  // Filter the given |results| by those which |result_filter| returns true for.
-  // The returned list is truncated to |max_results|.
-  static std::vector<SearchResult*> FilterSearchResultsByFunction(
-      SearchResults* results,
-      const base::RepeatingCallback<bool(const SearchResult&)>& result_filter,
-      size_t max_results);
-
   SearchBoxModel* search_box() { return search_box_.get(); }
   SearchResults* results() { return results_.get(); }
 
--- a/ash/app_list/model/search/search_result.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/model/search/search_result.h	2019-05-17 18:53:08.080000000 +0300
@@ -121,14 +121,6 @@
   int percent_downloaded() const { return percent_downloaded_; }
   void SetPercentDownloaded(int percent_downloaded);
 
-  bool notify_visibility_change() const {
-    return metadata_->notify_visibility_change;
-  }
-
-  void set_notify_visibility_change(bool notify_visibility_change) {
-    metadata_->notify_visibility_change = notify_visibility_change;
-  }
-
   bool is_omnibox_search() const { return metadata_->is_omnibox_search; }
   void set_is_omnibox_search(bool is_omnibox_search) {
     metadata_->is_omnibox_search = is_omnibox_search;
@@ -149,9 +141,6 @@
   ash::mojom::SearchResultMetadataPtr TakeMetadata() {
     return std::move(metadata_);
   }
-  ash::mojom::SearchResultMetadataPtr CloneMetadata() const {
-    return metadata_->Clone();
-  }
 
  protected:
   void set_id(const std::string& id) { metadata_->id = id; }
--- a/ash/app_list/pagination_controller.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/pagination_controller.cc	2019-05-17 18:53:08.080000000 +0300
@@ -4,8 +4,8 @@
 
 #include "ash/app_list/pagination_controller.h"
 
-#include "ash/app_list/app_list_metrics.h"
 #include "ash/app_list/pagination_model.h"
+#include "ash/public/cpp/app_list/app_list_constants.h"
 #include "base/metrics/histogram_macros.h"
 #include "ui/events/event.h"
 #include "ui/gfx/geometry/rect.h"
--- a/ash/app_list/pagination_model.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/pagination_model.cc	2019-05-17 18:53:08.080000000 +0300
@@ -7,13 +7,11 @@
 #include <algorithm>
 
 #include "ash/app_list/pagination_model_observer.h"
+#include "ash/public/cpp/app_list/app_list_constants.h"
 #include "ui/gfx/animation/slide_animation.h"
 
 namespace app_list {
 
-// Dampening value for PaginationModel's SlideAnimation.
-constexpr int kPageTransitionDurationDampening = 3;
-
 PaginationModel::PaginationModel()
     : total_pages_(-1),
       selected_page_(-1),
@@ -118,8 +116,6 @@
 }
 
 void PaginationModel::StartScroll() {
-  NotifyScrollStarted();
-
   // Cancels current transition animation (if any).
   transition_animation_.reset();
 }
@@ -155,8 +151,6 @@
 }
 
 void PaginationModel::EndScroll(bool cancel) {
-  NotifyScrollEnded();
-
   if (!has_transition())
     return;
 
@@ -214,16 +208,6 @@
     observer.TransitionEnded();
 }
 
-void PaginationModel::NotifyScrollStarted() {
-  for (auto& observer : observers_)
-    observer.ScrollStarted();
-}
-
-void PaginationModel::NotifyScrollEnded() {
-  for (auto& observer : observers_)
-    observer.ScrollEnded();
-}
-
 int PaginationModel::CalculateTargetPage(int delta) const {
   DCHECK_GT(total_pages_, 0);
   const int target_page = SelectedTargetPage() + delta;
--- a/ash/app_list/pagination_model.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/pagination_model.h	2019-05-17 18:53:08.080000000 +0300
@@ -110,8 +110,6 @@
   void NotifyTransitionStarted();
   void NotifyTransitionChanged();
   void NotifyTransitionEnded();
-  void NotifyScrollStarted();
-  void NotifyScrollEnded();
 
   void clear_transition() { SetTransition(Transition(-1, 0)); }
 
--- a/ash/app_list/pagination_model_observer.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/pagination_model_observer.h	2019-05-17 18:53:08.080000000 +0300
@@ -26,12 +26,6 @@
   // Invoked when a transition ends.
   virtual void TransitionEnded() = 0;
 
-  // Invoked when a grid scroll starts.
-  virtual void ScrollStarted() {}
-
-  // Invoked when a grid scroll ends.
-  virtual void ScrollEnded() {}
-
  protected:
   virtual ~PaginationModelObserver() {}
 };
--- a/ash/app_list/pagination_model_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/pagination_model_unittest.cc	2019-05-17 18:53:08.080000000 +0300
@@ -58,7 +58,7 @@
   void AppendSelectedPage(int page) {
     if (selected_pages_.length())
       selected_pages_.append(std::string(" "));
-    selected_pages_.append(base::NumberToString(page));
+    selected_pages_.append(base::IntToString(page));
   }
 
   // PaginationModelObserver overrides:
--- a/ash/app_list/presenter/app_list_presenter_export.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/presenter/app_list_presenter_export.h	2019-05-17 18:53:08.080000000 +0300
@@ -9,12 +9,21 @@
 // app_list presenter module can be exported to consumers.
 
 #if defined(COMPONENT_BUILD)
+#if defined(WIN32)
 
 #if defined(APP_LIST_PRESENTER_IMPLEMENTATION)
+#define APP_LIST_PRESENTER_EXPORT __declspec(dllexport)
+#else
+#define APP_LIST_PRESENTER_EXPORT __declspec(dllimport)
+#endif  // defined(APP_LIST_PRESENTER_IMPLEMENTATION)
+
+#else  // defined(WIN32)
+#if defined(APP_LIST_PRESENTER_IMPLEMENTATION)
 #define APP_LIST_PRESENTER_EXPORT __attribute__((visibility("default")))
 #else
 #define APP_LIST_PRESENTER_EXPORT
 #endif
+#endif
 
 #else  // defined(COMPONENT_BUILD)
 #define APP_LIST_PRESENTER_EXPORT
--- a/ash/app_list/presenter/app_list_presenter_impl.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/presenter/app_list_presenter_impl.cc	2019-05-17 18:53:08.080000000 +0300
@@ -12,10 +12,9 @@
 #include "ash/app_list/views/app_list_main_view.h"
 #include "ash/app_list/views/app_list_view.h"
 #include "ash/app_list/views/contents_view.h"
+#include "ash/public/cpp/app_list/app_list_constants.h"
 #include "ash/public/cpp/app_list/app_list_features.h"
 #include "ash/public/cpp/app_list/app_list_switches.h"
-#include "base/bind.h"
-#include "base/bind_helpers.h"
 #include "base/metrics/histogram_macros.h"
 #include "base/metrics/user_metrics.h"
 #include "ui/aura/client/focus_client.h"
@@ -28,6 +27,7 @@
 #include "ui/display/types/display_constants.h"
 #include "ui/gfx/geometry/vector2d_conversions.h"
 #include "ui/gfx/presentation_feedback.h"
+#include "ui/keyboard/keyboard_controller.h"
 #include "ui/views/widget/widget.h"
 
 namespace app_list {
@@ -57,6 +57,19 @@
   settings->SetAnimationMetricsReporter(reporter);
 }
 
+class StateAnimationMetricsReporter : public ui::AnimationMetricsReporter {
+ public:
+  StateAnimationMetricsReporter() = default;
+  ~StateAnimationMetricsReporter() override = default;
+
+  void Report(int value) override {
+    UMA_HISTOGRAM_PERCENTAGE("Apps.StateTransition.AnimationSmoothness", value);
+  }
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(StateAnimationMetricsReporter);
+};
+
 // Callback from the compositor when it presented a valid frame. Used to
 // record UMA of input latency.
 void DidPresentCompositorFrame(base::TimeTicks event_time_stamp,
@@ -77,37 +90,11 @@
 
 }  // namespace
 
-class AppListPresenterImpl::OverviewAnimationMetricsReporter
-    : public ui::AnimationMetricsReporter {
- public:
-  OverviewAnimationMetricsReporter() = default;
-  ~OverviewAnimationMetricsReporter() override = default;
-
-  void Start(bool enter) {
-    enter_ = enter;
-  }
-
-  void Report(int value) override {
-    if (enter_) {
-      UMA_HISTOGRAM_PERCENTAGE(
-          "Apps.StateTransition.AnimationSmoothness.EnterOverview", value);
-    } else {
-      UMA_HISTOGRAM_PERCENTAGE(
-          "Apps.StateTransition.AnimationSmoothness.ExitOverview", value);
-    }
-  }
-
- private:
-  bool enter_ = false;
-
-  DISALLOW_COPY_AND_ASSIGN(OverviewAnimationMetricsReporter);
-};
-
 AppListPresenterImpl::AppListPresenterImpl(
     std::unique_ptr<AppListPresenterDelegate> delegate)
     : delegate_(std::move(delegate)),
-      overview_animation_metrics_reporter_(
-          std::make_unique<OverviewAnimationMetricsReporter>()) {
+      state_animation_metrics_reporter_(
+          std::make_unique<StateAnimationMetricsReporter>()) {
   DCHECK(delegate_);
   delegate_->SetPresenter(this);
 }
@@ -196,26 +183,12 @@
 
 ash::ShelfAction AppListPresenterImpl::ToggleAppList(
     int64_t display_id,
-    app_list::AppListShowSource show_source,
     base::TimeTicks event_time_stamp) {
-  bool request_fullscreen = show_source == kSearchKeyFullscreen ||
-                            show_source == kShelfButtonFullscreen;
   if (IsVisible()) {
-    if (request_fullscreen) {
-      if (view_->app_list_state() == AppListViewState::PEEKING) {
-        view_->SetState(AppListViewState::FULLSCREEN_ALL_APPS);
-        return ash::SHELF_ACTION_APP_LIST_SHOWN;
-      } else if (view_->app_list_state() == AppListViewState::HALF) {
-        view_->SetState(AppListViewState::FULLSCREEN_SEARCH);
-        return ash::SHELF_ACTION_APP_LIST_SHOWN;
-      }
-    }
     Dismiss(event_time_stamp);
     return ash::SHELF_ACTION_APP_LIST_DISMISSED;
   }
   Show(display_id, event_time_stamp);
-  if (request_fullscreen)
-    view_->SetState(AppListViewState::FULLSCREEN_ALL_APPS);
   return ash::SHELF_ACTION_APP_LIST_SHOWN;
 }
 
@@ -288,38 +261,14 @@
     UpdateYPositionAndOpacityForHomeLauncher(
         start ? 0 : kOverviewAnimationYOffset, start ? 1.f : 0.f,
         base::NullCallback());
-
-    overview_animation_metrics_reporter_->Start(start);
   }
   UpdateYPositionAndOpacityForHomeLauncher(
       start ? kOverviewAnimationYOffset : 0, start ? 0.f : 1.f,
       animate ? base::BindRepeating(&UpdateOverviewSettings,
-                                    overview_animation_metrics_reporter_.get())
+                                    state_animation_metrics_reporter_.get())
               : base::NullCallback());
 }
 
-void AppListPresenterImpl::ShowEmbeddedAssistantUI(bool show) {
-  if (view_)
-    view_->app_list_main_view()->contents_view()->ShowEmbeddedAssistantUI(show);
-}
-
-bool AppListPresenterImpl::IsShowingEmbeddedAssistantUI() const {
-  if (view_) {
-    return view_->app_list_main_view()
-        ->contents_view()
-        ->IsShowingEmbeddedAssistantUI();
-  }
-
-  return false;
-}
-
-void AppListPresenterImpl::SetExpandArrowViewVisibility(bool show) {
-  if (view_) {
-    view_->app_list_main_view()->contents_view()->SetExpandArrowViewVisibility(
-        show);
-  }
-}
-
 ////////////////////////////////////////////////////////////////////////////////
 // AppListPresenterImpl, private:
 
@@ -376,7 +325,7 @@
     ui::ScopedLayerAnimationSettings animation(layer->GetAnimator());
     animation.SetTransitionDuration(animation_duration);
     animation.SetAnimationMetricsReporter(
-        view_->GetStateTransitionMetricsReporter());
+        state_animation_metrics_reporter_.get());
     animation.AddObserver(this);
 
     layer->SetTransform(gfx::Transform());
@@ -427,6 +376,12 @@
         !switches::ShouldNotDismissOnBlur() && !delegate_->IsTabletMode()) {
       Dismiss(base::TimeTicks());
     }
+    if (applist_container->Contains(gained_focus) &&
+        keyboard::KeyboardController::HasInstance()) {
+      auto* const keyboard_controller = keyboard::KeyboardController::Get();
+      if (keyboard_controller->IsKeyboardVisible())
+        keyboard_controller->HideKeyboardImplicitlyBySystem();
+    }
   }
 }
 
--- a/ash/app_list/presenter/app_list_presenter_impl.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/presenter/app_list_presenter_impl.h	2019-05-17 18:53:08.080000000 +0300
@@ -9,7 +9,6 @@
 
 #include <memory>
 
-#include "ash/app_list/app_list_metrics.h"
 #include "ash/app_list/model/app_list_view_state.h"
 #include "ash/app_list/pagination_model_observer.h"
 #include "ash/app_list/presenter/app_list_presenter_delegate.h"
@@ -25,6 +24,10 @@
 #include "ui/gfx/geometry/rect.h"
 #include "ui/views/widget/widget_observer.h"
 
+namespace ui {
+class AnimationMetricsReporter;
+}
+
 namespace app_list {
 class AppListView;
 
@@ -53,7 +56,6 @@
 
   // Returns app list view if one exists, or NULL otherwise.
   AppListView* GetView() { return view_; }
-  const AppListView* GetView() const { return view_; }
 
   // Show the app list window on the display with the given id. If
   // |event_time_stamp| is not 0, it means |Show()| was triggered by one of the
@@ -73,7 +75,6 @@
   // |event_time_stamp| is not 0, it means |ToggleAppList()| was triggered by
   // one of the AppListShowSources: kSearchKey or kShelfButton.
   ash::ShelfAction ToggleAppList(int64_t display_id,
-                                 app_list::AppListShowSource show_source,
                                  base::TimeTicks event_time_stamp);
 
   // Returns current visibility of the app list.
@@ -104,19 +105,7 @@
   // Schedules animation for app list when overview mode starts or ends.
   void ScheduleOverviewModeAnimation(bool start, bool animate);
 
-  // Shows or hides the Assistant page.
-  // |show| is true to show and false to hide.
-  void ShowEmbeddedAssistantUI(bool show);
-
-  // Returns current visibility of the Assistant page.
-  bool IsShowingEmbeddedAssistantUI() const;
-
-  // Show/hide the expand arrow view button.
-  void SetExpandArrowViewVisibility(bool show);
-
  private:
-  class OverviewAnimationMetricsReporter;
-
   // Sets the app list view and attempts to show it.
   void SetView(AppListView* view);
 
@@ -176,9 +165,9 @@
   // Cached bounds of |view_| for snapping back animation after over-scroll.
   gfx::Rect view_bounds_;
 
-  // Metric reporter for entering/exiting overview.
-  const std::unique_ptr<OverviewAnimationMetricsReporter>
-      overview_animation_metrics_reporter_;
+  // Metric reporter for state change animations.
+  const std::unique_ptr<ui::AnimationMetricsReporter>
+      state_animation_metrics_reporter_;
 
   // The last target visibility change.
   bool last_target_visible_ = false;
--- a/ash/app_list/presenter/BUILD.gn	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/presenter/BUILD.gn	2019-05-17 18:53:08.080000000 +0300
@@ -25,6 +25,7 @@
     "//ui/aura",
     "//ui/compositor",
     "//ui/gfx/geometry",
+    "//ui/keyboard",
     "//ui/views",
 
     # Temporary dependency to fix compile flake in http://crbug.com/611898.
--- a/ash/app_list/PRESUBMIT.py	2019-05-17 17:45:36.480000000 +0300
+++ b/ash/app_list/PRESUBMIT.py	2019-05-17 18:53:08.072000000 +0300
@@ -4,7 +4,7 @@
 
 """Presubmit script for app_list.
 
-See http://dev.ch40m1um.qjz9zk/developers/how-tos/depottools/presubmit-scripts
+See http://dev.chromium.org/developers/how-tos/depottools/presubmit-scripts
 for more details about the presubmit API built into depot_tools.
 """
 
--- a/ash/app_list/test/app_list_test_helper.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/test/app_list_test_helper.h	2019-05-17 18:53:08.080000000 +0300
@@ -7,9 +7,9 @@
 
 #include <memory>
 
-#include "ash/app_list/app_list_metrics.h"
 #include "ash/app_list/model/app_list_view_state.h"
 #include "ash/app_list/test/test_app_list_client.h"
+#include "ash/public/cpp/app_list/app_list_constants.h"
 
 namespace app_list {
 class AppListView;
--- a/ash/app_list/test/app_list_test_model.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/test/app_list_test_model.cc	2019-05-17 18:53:08.080000000 +0300
@@ -10,6 +10,7 @@
 #include <utility>
 
 #include "ash/public/cpp/app_list/app_list_config.h"
+#include "ash/public/cpp/app_list/app_list_constants.h"
 #include "base/memory/ptr_util.h"
 #include "base/strings/stringprintf.h"
 #include "base/strings/utf_string_conversions.h"
--- a/ash/app_list/test/app_list_test_view_delegate.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/test/app_list_test_view_delegate.cc	2019-05-17 18:53:08.080000000 +0300
@@ -9,7 +9,6 @@
 #include <vector>
 
 #include "ash/app_list/model/app_list_model.h"
-#include "ash/public/cpp/app_list/app_list_features.h"
 #include "ash/public/cpp/app_list/app_list_switches.h"
 #include "ash/public/cpp/menu_utils.h"
 #include "base/callback.h"
@@ -35,20 +34,12 @@
   return search_model_.get();
 }
 
-void AppListTestViewDelegate::OpenSearchResult(
-    const std::string& result_id,
-    int event_flags,
-    ash::mojom::AppListLaunchedFrom launched_from,
-    ash::mojom::AppListLaunchType launch_type,
-    int suggestion_index) {
+void AppListTestViewDelegate::OpenSearchResult(const std::string& result_id,
+                                               int event_flags) {
   const SearchModel::SearchResults* results = search_model_->results();
   for (size_t i = 0; i < results->item_count(); ++i) {
     if (results->GetItemAt(i)->id() == result_id) {
       open_search_result_counts_[i]++;
-      if (app_list_features::IsEmbeddedAssistantUIEnabled() &&
-          results->GetItemAt(i)->is_omnibox_search()) {
-        ++open_assistant_ui_count_;
-      }
       break;
     }
   }
@@ -124,19 +115,6 @@
   std::move(callback).Run(ash::menu_utils::GetMojoMenuItemsFromModel(menu));
 }
 
-ash::AssistantViewDelegate*
-AppListTestViewDelegate::GetAssistantViewDelegate() {
-  return nullptr;
-}
-
-void AppListTestViewDelegate::OnSearchResultVisibilityChanged(
-    const std::string& id,
-    bool visibility) {}
-
-bool AppListTestViewDelegate::IsAssistantAllowedAndEnabled() const {
-  return false;
-}
-
 bool AppListTestViewDelegate::IsCommandIdChecked(int command_id) const {
   return true;
 }
--- a/ash/app_list/test/app_list_test_view_delegate.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/test/app_list_test_view_delegate.h	2019-05-17 18:53:08.080000000 +0300
@@ -35,7 +35,6 @@
 
   int dismiss_count() const { return dismiss_count_; }
   int open_search_result_count() const { return open_search_result_count_; }
-  int open_assistant_ui_count() const { return open_assistant_ui_count_; }
   std::map<size_t, int>& open_search_result_counts() {
     return open_search_result_counts_;
   }
@@ -59,14 +58,7 @@
   SearchModel* GetSearchModel() override;
   void StartAssistant() override {}
   void StartSearch(const base::string16& raw_query) override {}
-  void OpenSearchResult(const std::string& result_id,
-                        int event_flags,
-                        ash::mojom::AppListLaunchedFrom launched_from,
-                        ash::mojom::AppListLaunchType launch_type,
-                        int suggestion_index) override;
-  void LogResultLaunchHistogram(
-      app_list::SearchResultLaunchLocation launch_location,
-      int suggestion_index) override {}
+  void OpenSearchResult(const std::string& result_id, int event_flags) override;
   void InvokeSearchResultAction(const std::string& result_id,
                                 int action_index,
                                 int event_flags) override {}
@@ -95,10 +87,6 @@
   bool CanProcessEventsOnApplistViews() override;
   void GetNavigableContentsFactory(
       content::mojom::NavigableContentsFactoryRequest request) override;
-  ash::AssistantViewDelegate* GetAssistantViewDelegate() override;
-  void OnSearchResultVisibilityChanged(const std::string& id,
-                                       bool visibility) override;
-  bool IsAssistantAllowedAndEnabled() const override;
 
   // Do a bulk replacement of the items in the model.
   void ReplaceTestModel(int item_count);
@@ -114,7 +102,6 @@
 
   int dismiss_count_ = 0;
   int open_search_result_count_ = 0;
-  int open_assistant_ui_count_ = 0;
   int next_profile_app_count_ = 0;
   int show_wallpaper_context_menu_count_ = 0;
   std::map<size_t, int> open_search_result_counts_;
--- a/ash/app_list/test/run_all_unittests.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/test/run_all_unittests.cc	2019-05-17 18:53:08.080000000 +0300
@@ -15,7 +15,6 @@
 #include "testing/gtest/include/gtest/gtest.h"
 #include "ui/aura/env.h"
 #include "ui/base/resource/resource_bundle.h"
-#include "ui/base/ui_base_features.h"
 #include "ui/base/ui_base_paths.h"
 #include "ui/gl/test/gl_surface_test_support.h"
 
@@ -36,6 +35,7 @@
 
     base::TestSuite::Initialize();
     gl::GLSurfaceTestSupport::InitializeOneOff();
+    env_ = aura::Env::CreateInstance();
     ui::RegisterPathProvider();
 
     base::FilePath ui_test_pak_path;
@@ -44,9 +44,6 @@
 
     base::DiscardableMemoryAllocator::SetInstance(
         &discardable_memory_allocator_);
-    env_ = aura::Env::CreateInstance(features::IsSingleProcessMash()
-                                         ? aura::Env::Mode::MUS
-                                         : aura::Env::Mode::LOCAL);
   }
 
   void Shutdown() override {
--- a/ash/app_list/test/test_app_list_client.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/test/test_app_list_client.cc	2019-05-17 18:53:08.084000000 +0300
@@ -4,7 +4,7 @@
 
 #include "ash/app_list/test/test_app_list_client.h"
 
-#include <utility>
+#include "ash/shell.h"
 
 namespace ash {
 
@@ -18,17 +18,4 @@
   return ptr;
 }
 
-void TestAppListClient::GetSearchResultContextMenuModel(
-    const std::string& result_id,
-    GetContextMenuModelCallback callback) {
-  std::move(callback).Run({});
-}
-
-void TestAppListClient::GetContextMenuModel(
-    int profile_id,
-    const std::string& id,
-    GetContextMenuModelCallback callback) {
-  std::move(callback).Run({});
-}
-
 }  // namespace ash
--- a/ash/app_list/test/test_app_list_client.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/test/test_app_list_client.h	2019-05-17 18:53:08.084000000 +0300
@@ -25,47 +25,34 @@
   // ash::mojom::AppListClient:
   void StartSearch(const base::string16& trimmed_query) override {}
   void OpenSearchResult(const std::string& result_id,
-                        int event_flags,
-                        ash::mojom::AppListLaunchedFrom launched_from,
-                        ash::mojom::AppListLaunchType launch_type,
-                        int suggestion_index) override {}
+                        int event_flags) override {}
   void InvokeSearchResultAction(const std::string& result_id,
                                 int action_index,
                                 int event_flags) override {}
   void GetSearchResultContextMenuModel(
       const std::string& result_id,
-      GetContextMenuModelCallback callback) override;
+      GetContextMenuModelCallback callback) override {}
   void SearchResultContextMenuItemSelected(const std::string& result_id,
                                            int command_id,
                                            int event_flags) override {}
   void ViewClosing() override {}
   void ViewShown(int64_t display_id) override {}
-  void ActivateItem(int profile_id,
-                    const std::string& id,
-                    int event_flags) override {}
-  void GetContextMenuModel(int profile_id,
-                           const std::string& id,
-                           GetContextMenuModelCallback callback) override;
-  void ContextMenuItemSelected(int profile_id,
-                               const std::string& id,
+  void ActivateItem(const std::string& id, int event_flags) override {}
+  void GetContextMenuModel(const std::string& id,
+                           GetContextMenuModelCallback callback) override {}
+  void ContextMenuItemSelected(const std::string& id,
                                int command_id,
                                int event_flags) override {}
   void OnAppListTargetVisibilityChanged(bool visible) override {}
   void OnAppListVisibilityChanged(bool visible) override {}
-  void OnFolderCreated(int profile_id,
-                       mojom::AppListItemMetadataPtr item) override {}
-  void OnFolderDeleted(int profile_id,
-                       mojom::AppListItemMetadataPtr item) override {}
-  void OnItemUpdated(int profile_id,
-                     mojom::AppListItemMetadataPtr item) override {}
-  void OnPageBreakItemAdded(int profile_id,
-                            const std::string& id,
+  void OnFolderCreated(mojom::AppListItemMetadataPtr item) override {}
+  void OnFolderDeleted(mojom::AppListItemMetadataPtr item) override {}
+  void OnItemUpdated(mojom::AppListItemMetadataPtr item) override {}
+  void OnPageBreakItemAdded(const std::string& id,
                             const syncer::StringOrdinal& position) override {}
-  void OnPageBreakItemDeleted(int profile_id, const std::string& id) override {}
+  void OnPageBreakItemDeleted(const std::string& id) override {}
   void GetNavigableContentsFactory(
       content::mojom::NavigableContentsFactoryRequest request) override {}
-  void OnSearchResultVisibilityChanged(const std::string& id,
-                                       bool visibility) override {}
 
  private:
   mojo::Binding<mojom::AppListClient> binding_;
--- a/ash/app_list/views/app_list_folder_view.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/views/app_list_folder_view.cc	2019-05-17 18:53:08.084000000 +0300
@@ -23,6 +23,7 @@
 #include "ash/app_list/views/search_box_view.h"
 #include "ash/app_list/views/top_icon_animation_view.h"
 #include "ash/public/cpp/app_list/app_list_config.h"
+#include "ash/public/cpp/app_list/app_list_constants.h"
 #include "ash/public/cpp/app_list/app_list_features.h"
 #include "base/strings/utf_string_conversions.h"
 #include "ui/accessibility/ax_node_data.h"
@@ -35,7 +36,6 @@
 #include "ui/gfx/geometry/rect_conversions.h"
 #include "ui/keyboard/keyboard_controller.h"
 #include "ui/strings/grit/ui_strings.h"
-#include "ui/views/accessibility/view_accessibility.h"
 #include "ui/views/background.h"
 #include "ui/views/controls/label.h"
 #include "ui/views/controls/textfield/textfield.h"
@@ -87,8 +87,7 @@
                       : AppListConfig::instance().folder_bubble_color();
 
     SetTweenType(gfx::Tween::FAST_OUT_SLOW_IN);
-    SetSlideDuration(
-        AppListConfig::instance().folder_transition_in_duration_ms());
+    SetSlideDuration(kFolderTransitionInDurationMs);
 
     folder_view_->UpdateBackgroundMask(
         from_radius_,
@@ -158,8 +157,7 @@
                       : AppListConfig::instance().grid_title_color();
 
     SetTweenType(gfx::Tween::FAST_OUT_SLOW_IN);
-    SetSlideDuration(
-        AppListConfig::instance().folder_transition_in_duration_ms());
+    SetSlideDuration(kFolderTransitionInDurationMs);
   }
 
   ~FolderItemTitleAnimation() override = default;
@@ -320,9 +318,8 @@
   // to AppListFolderView.
   std::vector<gfx::Rect> GetFirstPageItemViewsBounds() {
     std::vector<gfx::Rect> items_bounds;
-    const size_t count =
-        std::min(AppListConfig::instance().max_folder_items_per_page(),
-                 folder_view_->folder_item()->ChildItemCount());
+    const size_t count = std::min(
+        kMaxFolderItemsPerPage, folder_view_->folder_item()->ChildItemCount());
     for (size_t i = 0; i < count; ++i) {
       const gfx::Rect rect =
           folder_view_->items_grid_view()->GetItemViewAt(i)->bounds();
@@ -383,8 +380,8 @@
     ui::ScopedLayerAnimationSettings animation(layer->GetAnimator());
     animation.SetTweenType(gfx::Tween::FAST_OUT_SLOW_IN);
     animation.AddObserver(this);
-    animation.SetTransitionDuration(base::TimeDelta::FromMilliseconds(
-        AppListConfig::instance().folder_transition_in_duration_ms()));
+    animation.SetTransitionDuration(
+        base::TimeDelta::FromMilliseconds(kFolderTransitionInDurationMs));
     layer->SetTransform(show_ ? gfx::Transform() : transform);
     layer->SetOpacity(show_ ? 1.0f : 0.0f);
 
@@ -487,6 +484,10 @@
 }
 
 void AppListFolderView::SetAppListFolderItem(AppListFolderItem* folder) {
+  accessible_name_ = ui::ResourceBundle::GetSharedInstance().GetLocalizedString(
+      IDS_APP_LIST_FOLDER_OPEN_FOLDER_ACCESSIBILE_NAME);
+  NotifyAccessibilityEvent(ax::mojom::Event::kAlert, true);
+
   folder_item_ = folder;
   items_grid_view_->SetItemList(folder_item_->item_list());
   folder_header_view_->SetFolderItem(folder_item_);
@@ -496,7 +497,6 @@
 
 void AppListFolderView::ScheduleShowHideAnimation(bool show,
                                                   bool hide_for_reparent) {
-  CreateOpenOrCloseFolderAccessibilityEvent(show);
   animation_start_frame_number_ =
       GetCompositorActivatedFrameCount(GetCompositor());
 
@@ -541,7 +541,7 @@
 
 bool AppListFolderView::OnKeyPressed(const ui::KeyEvent& event) {
   // Let the FocusManager handle Left/Right keys.
-  if (!IsUnhandledUpDownKeyEvent(event))
+  if (!CanProcessUpDownKeyTraversal(event))
     return false;
 
   if (folder_header_view_->HasTextFocus() && event.key_code() == ui::VKEY_UP) {
@@ -645,8 +645,7 @@
   if (end_frame_number > animation_start_frame_number_) {
     RecordFolderShowHideAnimationSmoothness(
         end_frame_number - animation_start_frame_number_,
-        AppListConfig::instance().folder_transition_in_duration_ms(),
-        compositor->refresh_rate());
+        kFolderTransitionInDurationMs, compositor->refresh_rate());
   }
 }
 
@@ -801,6 +800,10 @@
 }
 
 void AppListFolderView::CloseFolderPage() {
+  accessible_name_ = ui::ResourceBundle::GetSharedInstance().GetLocalizedString(
+      IDS_APP_LIST_FOLDER_CLOSE_FOLDER_ACCESSIBILE_NAME);
+  NotifyAccessibilityEvent(ax::mojom::Event::kAlert, true);
+
   GiveBackFocusToSearchBox();
   if (items_grid_view()->dragging())
     items_grid_view()->EndDrag(true);
@@ -818,6 +821,7 @@
 
 void AppListFolderView::GetAccessibleNodeData(ui::AXNodeData* node_data) {
   node_data->role = ax::mojom::Role::kGenericContainer;
+  node_data->SetName(accessible_name_);
 }
 
 void AppListFolderView::NavigateBack(AppListFolderItem* item,
@@ -826,11 +830,7 @@
 }
 
 void AppListFolderView::GiveBackFocusToSearchBox() {
-  // Avoid announcing search box focus since it is overlapped with closing
-  // folder alert.
-  auto* search_box = contents_view_->GetSearchBoxView()->search_box();
-  search_box->GetViewAccessibility().OverrideIsIgnored(true);
-  search_box->RequestFocus();
+  contents_view_->GetSearchBoxView()->search_box()->RequestFocus();
 }
 
 void AppListFolderView::SetItemName(AppListFolderItem* item,
@@ -842,14 +842,4 @@
   return GetWidget()->GetCompositor();
 }
 
-void AppListFolderView::CreateOpenOrCloseFolderAccessibilityEvent(bool open) {
-  auto* announcement_view =
-      contents_view_->app_list_view()->announcement_view();
-  announcement_view->GetViewAccessibility().OverrideName(
-      ui::ResourceBundle::GetSharedInstance().GetLocalizedString(
-          open ? IDS_APP_LIST_FOLDER_OPEN_FOLDER_ACCESSIBILE_NAME
-               : IDS_APP_LIST_FOLDER_CLOSE_FOLDER_ACCESSIBILE_NAME));
-  announcement_view->NotifyAccessibilityEvent(ax::mojom::Event::kAlert, true);
-}
-
 }  // namespace app_list
--- a/ash/app_list/views/app_list_folder_view.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/views/app_list_folder_view.h	2019-05-17 18:53:08.084000000 +0300
@@ -155,10 +155,6 @@
   // Returns nullptr if there isn't one associated with this widget.
   ui::Compositor* GetCompositor();
 
-  // Creates accessibility event for opening folder if |open| is true.
-  // Otherwise, creates the event for closing folder.
-  void CreateOpenOrCloseFolderAccessibilityEvent(bool open);
-
   // Views below are not owned by views hierarchy.
   AppsContainerView* container_view_;
   ContentsView* contents_view_;
@@ -186,6 +182,8 @@
 
   bool hide_for_reparent_;
 
+  base::string16 accessible_name_;
+
   std::unique_ptr<gfx::SlideAnimation> background_animation_;
   std::unique_ptr<gfx::SlideAnimation> folder_item_title_animation_;
   std::unique_ptr<Animation> top_icon_animation_;
--- a/ash/app_list/views/app_list_item_view.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/views/app_list_item_view.cc	2019-05-17 18:53:08.084000000 +0300
@@ -13,8 +13,8 @@
 #include "ash/app_list/model/app_list_item.h"
 #include "ash/app_list/views/apps_grid_view.h"
 #include "ash/public/cpp/app_list/app_list_config.h"
+#include "ash/public/cpp/app_list/app_list_constants.h"
 #include "ash/public/cpp/app_list/app_list_switches.h"
-#include "base/bind.h"
 #include "base/strings/utf_string_conversions.h"
 #include "build/build_config.h"
 #include "ui/base/l10n/l10n_util.h"
@@ -476,8 +476,7 @@
   apps_grid_view_->SetSelectedView(this);
 }
 
-void AppListItemView::ShowContextMenuForViewImpl(
-    views::View* source,
+void AppListItemView::ShowContextMenuForView(views::View* source,
     const gfx::Point& point,
     ui::MenuSourceType source_type) {
   if (context_menu_ && context_menu_->IsShowingMenu())
@@ -518,9 +517,8 @@
   if (apps_grid_view_->IsSelectedView(this)) {
     cc::PaintFlags flags;
     flags.setAntiAlias(true);
-    flags.setColor(apps_grid_view_->is_in_folder()
-                       ? kFolderGridSelectedColor
-                       : AppListConfig::instance().grid_selected_color());
+    flags.setColor(apps_grid_view_->is_in_folder() ? kFolderGridSelectedColor
+                                                   : kGridSelectedColor);
     flags.setStyle(cc::PaintFlags::kFill_Style);
     gfx::Rect selection_highlight_bounds = GetContentsBounds();
     AdaptBoundsForSelectionHighlight(&selection_highlight_bounds);
--- a/ash/app_list/views/app_list_item_view.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/views/app_list_item_view.h	2019-05-17 18:53:08.084000000 +0300
@@ -170,7 +170,7 @@
                                   std::vector<ash::mojom::MenuItemPtr> menu);
 
   // views::ContextMenuController overrides:
-  void ShowContextMenuForViewImpl(views::View* source,
+  void ShowContextMenuForView(views::View* source,
                                   const gfx::Point& point,
                                   ui::MenuSourceType source_type) override;
 
--- a/ash/app_list/views/app_list_main_view.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/views/app_list_main_view.cc	2019-05-17 18:53:08.084000000 +0300
@@ -20,6 +20,7 @@
 #include "ash/app_list/views/search_box_view.h"
 #include "ash/app_list/views/search_result_base_view.h"
 #include "ash/app_list/views/search_result_page_view.h"
+#include "ash/public/cpp/app_list/app_list_constants.h"
 #include "ash/public/cpp/app_list/app_list_features.h"
 #include "base/bind.h"
 #include "base/callback.h"
--- a/ash/app_list/views/app_list_main_view_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/views/app_list_main_view_unittest.cc	2019-05-17 18:53:08.084000000 +0300
@@ -16,7 +16,6 @@
 #include "ash/app_list/views/search_box_view.h"
 #include "ash/app_list/views/test/apps_grid_view_test_api.h"
 #include "ash/public/cpp/app_list/app_list_switches.h"
-#include "base/bind.h"
 #include "base/macros.h"
 #include "base/run_loop.h"
 #include "base/time/time.h"
--- a/ash/app_list/views/app_list_view.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/views/app_list_view.cc	2019-05-17 18:53:08.084000000 +0300
@@ -15,12 +15,11 @@
 #include "ash/app_list/views/apps_container_view.h"
 #include "ash/app_list/views/contents_view.h"
 #include "ash/app_list/views/search_box_view.h"
-#include "ash/assistant/ui/assistant_ui_constants.h"
 #include "ash/public/cpp/app_list/app_list_config.h"
+#include "ash/public/cpp/app_list/app_list_constants.h"
 #include "ash/public/cpp/app_list/app_list_features.h"
 #include "ash/public/cpp/shell_window_ids.h"
 #include "ash/public/cpp/wallpaper_types.h"
-#include "base/bind.h"
 #include "base/macros.h"
 #include "base/metrics/histogram_macros.h"
 #include "base/metrics/user_metrics.h"
@@ -37,7 +36,6 @@
 #include "ui/compositor/layer_animation_element.h"
 #include "ui/compositor/layer_animation_observer.h"
 #include "ui/compositor/layer_animation_sequence.h"
-#include "ui/compositor/scoped_animation_duration_scale_mode.h"
 #include "ui/compositor/scoped_layer_animation_settings.h"
 #include "ui/display/display.h"
 #include "ui/display/screen.h"
@@ -70,6 +68,10 @@
 // order to transition to the next state.
 constexpr int kAppListThresholdDenominator = 3;
 
+// The velocity the app list must be dragged in order to transition to the next
+// state, measured in DIPs/event.
+constexpr int kAppListDragVelocityThreshold = 6;
+
 // The scroll offset in order to transition from PEEKING to FULLSCREEN
 constexpr int kAppListMinScrollToSwitchStates = 20;
 
@@ -94,15 +96,7 @@
 constexpr float kAppListBlurQuality = 0.33f;
 
 // Set animation durations to 0 for testing.
-// TODO(oshima): Use ui::ScopedAnimationDurationScaleMode instead.
-bool short_animations_for_testing;
-
-// Histogram for the app list dragging. The suffix ClamshellMode is added
-// in case a similar UI is added to TabletMode in the future.
-constexpr char kAppListDragInClamshellHistogram[] =
-    "Apps.StateTransition.Drag.PresentationTime.ClamshellMode";
-constexpr char kAppListDragInClamshellMaxLatencyHistogram[] =
-    "Apps.StateTransition.Drag.PresentationTime.MaxLatency.ClamshellMode";
+static bool short_animations_for_testing;
 
 // This view forwards the focus to the search box widget by providing it as a
 // FocusTraversable when a focus search is provided.
@@ -148,7 +142,7 @@
       sk_opacity_value);
 }
 
-DEFINE_UI_CLASS_PROPERTY_KEY(bool, kExcludeWindowFromEventHandling, false)
+DEFINE_UI_CLASS_PROPERTY_KEY(bool, kExcludeWindowFromEventHandling, false);
 
 // This targeter prevents routing events to sub-windows, such as
 // RenderHostWindow in order to handle events in context of app list.
@@ -166,14 +160,6 @@
       if (event.type() != ui::ET_MOUSE_MOVED)
         return false;
     }
-
-    if (window->GetProperty(ash::assistant::ui::kOnlyAllowMouseClickEvents)) {
-      if (event.type() != ui::ET_MOUSE_PRESSED &&
-          event.type() != ui::ET_MOUSE_RELEASED) {
-        return false;
-      }
-    }
-
     return aura::WindowTargeter::SubtreeShouldBeExploredForEvent(window, event);
   }
 
@@ -181,72 +167,21 @@
   DISALLOW_COPY_AND_ASSIGN(AppListEventTargeter);
 };
 
-}  // namespace
-
-class AppListView::StateAnimationMetricsReporter
-    : public ui::AnimationMetricsReporter {
+class StateAnimationMetricsReporter : public ui::AnimationMetricsReporter {
  public:
   StateAnimationMetricsReporter() = default;
   ~StateAnimationMetricsReporter() override = default;
 
-  void SetTargetState(AppListViewState target_state) {
-    target_state_ = target_state;
-  }
-
-  void Start() {
-#if defined(DCHECK)
-    DCHECK(!started_);
-    started_ = ui::ScopedAnimationDurationScaleMode::duration_scale_mode() !=
-               ui::ScopedAnimationDurationScaleMode::ZERO_DURATION;
-#endif
-  }
-
   void Report(int value) override {
     UMA_HISTOGRAM_PERCENTAGE("Apps.StateTransition.AnimationSmoothness", value);
-    switch (*target_state_) {
-      case AppListViewState::CLOSED:
-        UMA_HISTOGRAM_PERCENTAGE(
-            "Apps.StateTransition.AnimationSmoothness.Close.ClamshellMode",
-            value);
-        break;
-      case AppListViewState::PEEKING:
-        UMA_HISTOGRAM_PERCENTAGE(
-            "Apps.StateTransition.AnimationSmoothness.Peeking.ClamshellMode",
-            value);
-        break;
-      case AppListViewState::HALF:
-        UMA_HISTOGRAM_PERCENTAGE(
-            "Apps.StateTransition.AnimationSmoothness.Half.ClamshellMode",
-            value);
-        break;
-      case AppListViewState::FULLSCREEN_ALL_APPS:
-        UMA_HISTOGRAM_PERCENTAGE(
-            "Apps.StateTransition.AnimationSmoothness.FullscreenAllApps."
-            "ClamshellMode",
-            value);
-        break;
-      case AppListViewState::FULLSCREEN_SEARCH:
-        UMA_HISTOGRAM_PERCENTAGE(
-            "Apps.StateTransition.AnimationSmoothness.FullscreenSearch."
-            "ClamshellMode",
-            value);
-        break;
-    }
-    target_state_.reset();
-#if defined(DCHECK)
-    started_ = false;
-#endif
   }
 
  private:
-#if defined(DCHECK)
-  bool started_ = false;
-#endif
-  base::Optional<AppListViewState> target_state_;
-
   DISALLOW_COPY_AND_ASSIGN(StateAnimationMetricsReporter);
 };
 
+}  // namespace
+
 // An animation observer to hide the view at the end of the animation.
 class HideViewAnimationObserver : public ui::ImplicitAnimationObserver {
  public:
@@ -308,9 +243,6 @@
   ~AppListBackgroundShieldView() override = default;
 
   void UpdateColor(SkColor color) {
-    if (color_ == color)
-      return;
-
     color_ = color;
     if (layer()->type() == ui::LAYER_SOLID_COLOR)
       layer()->SetColor(color);
@@ -319,9 +251,6 @@
   }
 
   void UpdateCornerRadius(int corner_radius) {
-    if (corner_radius_ == corner_radius)
-      return;
-
     corner_radius_ = corner_radius;
     if (!layer())
       SchedulePaint();
@@ -614,7 +543,7 @@
 
   app_list_main_view_->Init(0, search_box_view_);
 
-  announcement_view_ = new views::View();
+  announcement_view_ = new views::View;
   AddChildView(announcement_view_);
 }
 
@@ -724,17 +653,12 @@
     return;
   }
 
-  if (!search_box_view_->is_search_box_active() &&
-      model_->state() != ash::AppListState::kStateEmbeddedAssistant) {
+  if (!search_box_view_->is_search_box_active()) {
     if (!is_tablet_mode())
       Dismiss();
     return;
   }
 
-  // Reset the AppListState if the embedded Assistant UI is shown.
-  if (app_list_main_view()->contents_view()->IsShowingEmbeddedAssistantUI())
-    Back();
-
   search_box_view_->ClearSearch();
   search_box_view_->SetSearchBoxActive(false, ui::ET_UNKNOWN);
 }
@@ -745,6 +669,8 @@
   initial_drag_point_ = location;
   ConvertPointToScreen(this, &initial_drag_point_);
   initial_window_bounds_ = fullscreen_widget_->GetWindowBoundsInScreen();
+  if (app_list_state_ == AppListViewState::PEEKING)
+    drag_started_from_peeking_ = true;
 }
 
 void AppListView::UpdateDrag(const gfx::Point& location) {
@@ -766,7 +692,7 @@
   // Change the app list state based on where the drag ended. If fling velocity
   // was over the threshold, snap to the next state in the direction of the
   // fling.
-  if (std::abs(last_fling_velocity_) >= kDragVelocityThreshold) {
+  if (std::abs(last_fling_velocity_) >= kAppListDragVelocityThreshold) {
     // If the user releases drag with velocity over the threshold, snap to
     // the next state, ignoring the drag release position.
 
@@ -879,6 +805,7 @@
         break;
     }
   }
+  drag_started_from_peeking_ = false;
   UpdateChildViewsYPositionAndOpacity();
   initial_drag_point_ = gfx::Point();
 }
@@ -1213,6 +1140,15 @@
                ? AppListViewState::FULLSCREEN_SEARCH
                : AppListViewState::FULLSCREEN_ALL_APPS);
 
+  // Put app list window in corresponding container based on whether the
+  // tablet mode is enabled.
+  aura::Window* window = GetWidget()->GetNativeWindow();
+  aura::Window* root_window = window->GetRootWindow();
+  aura::Window* parent_window =
+      root_window->GetChildById(ash::kShellWindowId_AppListTabletModeContainer);
+  if (parent_window && !parent_window->Contains(window))
+    parent_window->AddChild(window);
+
   // Update background color opacity.
   SetBackgroundShieldColor();
 
@@ -1359,7 +1295,6 @@
   settings.SetTweenType(gfx::Tween::EASE_OUT);
   settings.SetPreemptionStrategy(
       ui::LayerAnimator::IMMEDIATELY_ANIMATE_TO_NEW_TARGET);
-  state_animation_metrics_reporter_->SetTargetState(target_state);
   settings.SetAnimationMetricsReporter(state_animation_metrics_reporter_.get());
   settings.AddObserver(transition_animation_observer_.get());
 
@@ -1372,7 +1307,6 @@
 }
 
 void AppListView::StartCloseAnimation(base::TimeDelta animation_duration) {
-  state_animation_metrics_reporter_->SetTargetState(AppListViewState::CLOSED);
   if (is_side_shelf_)
     return;
 
@@ -1452,9 +1386,6 @@
   }
 
   SetIsInDrag(true);
-
-  presentation_time_recorder_->RequestNext();
-
   background_opacity_in_drag_ = background_opacity;
   gfx::Rect new_widget_bounds = fullscreen_widget_->GetWindowBoundsInScreen();
   app_list_y_position_in_screen_ = std::min(
@@ -1486,25 +1417,12 @@
 }
 
 void AppListView::SetIsInDrag(bool is_in_drag) {
-  if (!is_in_drag)
-    presentation_time_recorder_.reset();
-
   if (app_list_state_ == AppListViewState::CLOSED)
     return;
 
   if (is_in_drag == is_in_drag_)
     return;
 
-  if (is_in_drag) {
-    DCHECK(!presentation_time_recorder_);
-    if (!is_tablet_mode_) {
-      presentation_time_recorder_ =
-          std::make_unique<ash::PresentationTimeHistogramRecorder>(
-              GetWidget()->GetCompositor(), kAppListDragInClamshellHistogram,
-              kAppListDragInClamshellMaxLatencyHistogram);
-    }
-  }
-
   is_in_drag_ = is_in_drag;
   GetAppsContainerView()->UpdateControlVisibility(app_list_state_, is_in_drag_);
 }
@@ -1552,54 +1470,6 @@
   return display_bounds.height() - display.work_area().y() + display_bounds.y();
 }
 
-AppListViewState AppListView::CalculateStateAfterShelfDrag(
-    const ui::GestureEvent& gesture_in_screen,
-    float launcher_above_shelf_bottom_amount) const {
-  AppListViewState app_list_state = AppListViewState::PEEKING;
-  if (gesture_in_screen.type() == ui::ET_SCROLL_FLING_START &&
-      fabs(gesture_in_screen.details().velocity_y()) > kDragVelocityThreshold) {
-    // If the scroll sequence terminates with a fling, show the fullscreen app
-    // list if the fling was fast enough and in the correct direction, otherwise
-    // close it.
-    app_list_state = gesture_in_screen.details().velocity_y() < 0
-                         ? AppListViewState::FULLSCREEN_ALL_APPS
-                         : AppListViewState::CLOSED;
-  } else {
-    // Snap the app list to corresponding state according to the snapping
-    // thresholds.
-    if (is_tablet_mode_) {
-      app_list_state =
-          launcher_above_shelf_bottom_amount > kDragSnapToFullscreenThreshold
-              ? AppListViewState::FULLSCREEN_ALL_APPS
-              : AppListViewState::CLOSED;
-    } else {
-      if (launcher_above_shelf_bottom_amount <= kDragSnapToClosedThreshold)
-        app_list_state = AppListViewState::CLOSED;
-      else if (launcher_above_shelf_bottom_amount <=
-               kDragSnapToPeekingThreshold)
-        app_list_state = AppListViewState::PEEKING;
-      else
-        app_list_state = AppListViewState::FULLSCREEN_ALL_APPS;
-    }
-  }
-
-  // Deal with the situation of dragging app list from shelf while typing in
-  // the search box.
-  if (app_list_state == AppListViewState::FULLSCREEN_ALL_APPS) {
-    ash::AppListState active_state =
-        app_list_main_view_->contents_view()->GetActiveState();
-    if (active_state == ash::AppListState::kStateSearchResults)
-      app_list_state = AppListViewState::FULLSCREEN_SEARCH;
-  }
-
-  return app_list_state;
-}
-
-ui::AnimationMetricsReporter* AppListView::GetStateTransitionMetricsReporter() {
-  state_animation_metrics_reporter_->Start();
-  return state_animation_metrics_reporter_.get();
-}
-
 void AppListView::UpdateChildViewsYPositionAndOpacity() {
   if (app_list_state_ == AppListViewState::CLOSED)
     return;
@@ -1617,25 +1487,23 @@
   if (event->handled())
     return;
 
-  // Allow text input inside the Assistant page.
-  if (app_list_main_view()->contents_view()->IsShowingEmbeddedAssistantUI())
-    return;
-
   views::Textfield* search_box = search_box_view_->search_box();
   const bool is_search_box_focused = search_box->HasFocus();
   const bool is_folder_header_view_focused = GetAppsContainerView()
                                                  ->app_list_folder_view()
                                                  ->folder_header_view()
                                                  ->HasTextFocus();
-
+  if (is_search_box_focused || is_folder_header_view_focused) {
   // Do not redirect the key event to the |search_box_| when focus is on a
   // text field.
-  if (is_search_box_focused || is_folder_header_view_focused)
     return;
+  }
 
-  // Do not redirect the arrow keys as they are are used for focus traversal.
-  if (IsUnhandledArrowKeyEvent(*event))
+  if (CanProcessLeftRightKeyTraversal(*event) ||
+      CanProcessUpDownKeyTraversal(*event)) {
+    // Do not redirect the arrow keys that are used to do focus traversal.
     return;
+  }
 
   // Redirect key event to |search_box_|.
   search_box->OnKeyEvent(event);
@@ -1644,11 +1512,11 @@
     search_box->RequestFocus();
     return;
   }
-
+  if (event->type() == ui::ET_KEY_PRESSED) {
   // Insert it into search box if the key event is a character. Released
   // key should not be handled to prevent inserting duplicate character.
-  if (event->type() == ui::ET_KEY_PRESSED)
     search_box->InsertChar(*event);
+  }
 }
 
 void AppListView::OnScreenKeyboardShown(bool shown) {
@@ -1664,8 +1532,7 @@
   } else {
     // If the keyboard is closing or a folder isn't being shown, reset
     // the app list's position
-    const int work_area_offset = GetDisplayNearestView().work_area().y();
-    OffsetYPositionOfAppList(shown ? work_area_offset : -work_area_offset);
+    OffsetYPositionOfAppList(0);
   }
 }
 
--- a/ash/app_list/views/app_list_view.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/views/app_list_view.h	2019-05-17 18:53:08.084000000 +0300
@@ -9,10 +9,9 @@
 #include <vector>
 
 #include "ash/app_list/app_list_export.h"
-#include "ash/app_list/app_list_metrics.h"
 #include "ash/app_list/app_list_view_delegate.h"
 #include "ash/app_list/model/app_list_view_state.h"
-#include "ash/public/cpp/presentation_time_recorder.h"
+#include "ash/public/cpp/app_list/app_list_constants.h"
 #include "base/callback.h"
 #include "base/macros.h"
 #include "build/build_config.h"
@@ -47,7 +46,7 @@
 namespace {
 // The background corner radius in peeking and fullscreen state.
 constexpr int kAppListBackgroundRadius = 28;
-}  // namespace
+}
 
 // AppListView is the top-level view and controller of app list UI. It creates
 // and hosts a AppsGridView and passes AppListModel to it for display.
@@ -75,31 +74,18 @@
   static constexpr float kAppListOpacity = 0.95;
 
   // The opacity of the app list background with blur.
-  static constexpr float kAppListOpacityWithBlur = 0.74;
+  static constexpr float kAppListOpacityWithBlur = 0.7;
 
   // The preferred blend alpha with wallpaper color for background.
   static constexpr int kAppListColorDarkenAlpha = 178;
 
   // The defualt color of the app list background.
-  static constexpr SkColor kDefaultBackgroundColor = gfx::kGoogleGrey900;
+  static constexpr SkColor kDefaultBackgroundColor = SK_ColorBLACK;
 
   // The duration the AppListView ignores scroll events which could transition
   // its state.
   static constexpr int kScrollIgnoreTimeMs = 500;
 
-  // The snapping threshold for dragging app list from shelf in tablet mode,
-  // measured in DIPs.
-  static constexpr int kDragSnapToFullscreenThreshold = 320;
-
-  // The snapping thresholds for dragging app list from shelf in laptop mode,
-  // measured in DIPs.
-  static constexpr int kDragSnapToClosedThreshold = 144;
-  static constexpr int kDragSnapToPeekingThreshold = 561;
-
-  // The velocity the app list must be dragged in order to transition to the
-  // next state, measured in DIPs/event.
-  static constexpr int kDragVelocityThreshold = 6;
-
   struct InitParams {
     gfx::NativeView parent = nullptr;
     int initial_apps_page = 0;
@@ -229,15 +215,6 @@
   // Returns the height of app list in fullscreen state.
   int GetFullscreenStateHeight() const;
 
-  // Calculates and returns the app list view state after dragging from shelf
-  // ends.
-  AppListViewState CalculateStateAfterShelfDrag(
-      const ui::GestureEvent& gesture_in_screen,
-      float launcher_above_shelf_bottom_amount) const;
-
-  // Returns a animation metrics reportre for state transition.
-  ui::AnimationMetricsReporter* GetStateTransitionMetricsReporter();
-
   views::Widget* get_fullscreen_widget_for_test() const {
     return fullscreen_widget_;
   }
@@ -252,8 +229,6 @@
 
   AppListMainView* app_list_main_view() const { return app_list_main_view_; }
 
-  views::View* announcement_view() const { return announcement_view_; }
-
   bool is_fullscreen() const {
     return app_list_state_ == AppListViewState::FULLSCREEN_ALL_APPS ||
            app_list_state_ == AppListViewState::FULLSCREEN_SEARCH;
@@ -265,6 +240,8 @@
 
   bool is_in_drag() const { return is_in_drag_; }
 
+  bool drag_started_from_peeking() const { return drag_started_from_peeking_; }
+
   void set_onscreen_keyboard_shown(bool onscreen_keyboard_shown) {
     onscreen_keyboard_shown_ = onscreen_keyboard_shown;
   }
@@ -284,8 +261,6 @@
   // view code is removed.
   class FullscreenWidgetObserver;
 
-  class StateAnimationMetricsReporter;
-
   void InitContents(int initial_apps_page);
 
   void InitChildWidgets();
@@ -434,21 +409,18 @@
   // For UMA and testing. If non-null, triggered when the app list is painted.
   base::Closure next_paint_callback_;
 
+  // True if the dragging started from PEEKING state.
+  bool drag_started_from_peeking_ = false;
+
   // Metric reporter for state change animations.
-  const std::unique_ptr<StateAnimationMetricsReporter>
+  const std::unique_ptr<ui::AnimationMetricsReporter>
       state_animation_metrics_reporter_;
 
   // Whether the on-screen keyboard is shown.
   bool onscreen_keyboard_shown_ = false;
 
-  // View used to announce:
-  // 1. state transition for peeking and fullscreen
-  // 2. folder opening and closing.
-  // 3. app dragging in AppsGridView.
-  views::View* announcement_view_ = nullptr;  // Owned by AppListView.
-
-  // Records the presentation time for app launcher dragging.
-  std::unique_ptr<ash::PresentationTimeRecorder> presentation_time_recorder_;
+  // View used to announce the state transition for peeking and fullscreen.
+  views::View* announcement_view_;  // Owned by AppListView.
 
   base::WeakPtrFactory<AppListView> weak_ptr_factory_;
 
--- a/ash/app_list/views/app_list_view_unittest.cc	2019-05-17 17:45:36.484000000 +0300
+++ b/ash/app_list/views/app_list_view_unittest.cc	2019-05-17 18:53:08.084000000 +0300
@@ -37,17 +37,14 @@
 #include "ash/app_list/views/suggestion_chip_view.h"
 #include "ash/app_list/views/test/apps_grid_view_test_api.h"
 #include "ash/public/cpp/app_list/app_list_config.h"
+#include "ash/public/cpp/app_list/app_list_constants.h"
 #include "ash/public/cpp/app_list/app_list_features.h"
-#include "ash/public/cpp/presentation_time_recorder.h"
 #include "base/macros.h"
 #include "base/run_loop.h"
-#include "base/strings/string_number_conversions.h"
 #include "base/strings/string_util.h"
 #include "base/strings/utf_string_conversions.h"
 #include "base/test/icu_test_util.h"
-#include "base/test/metrics/histogram_tester.h"
 #include "base/test/scoped_feature_list.h"
-#include "chromeos/constants/chromeos_switches.h"
 #include "services/content/public/cpp/test/fake_navigable_contents.h"
 #include "testing/gtest/include/gtest/gtest.h"
 #include "ui/base/models/simple_menu_model.h"
@@ -111,13 +108,9 @@
         base::i18n::SetICUDefaultLocale("he");
     }
     views::ViewsTestBase::SetUp();
-    ash::PresentationTimeRecorder::SetReportPresentationTimeImmediatelyForTest(
-        true);
   }
 
   void TearDown() override {
-    ash::PresentationTimeRecorder::SetReportPresentationTimeImmediatelyForTest(
-        false);
     view_->GetWidget()->Close();
     views::ViewsTestBase::TearDown();
     AppListView::SetShortAnimationForTesting(false);
@@ -341,9 +334,8 @@
             std::make_unique<TestSearchResult>();
         result->set_display_type(data.first);
         result->set_display_score(display_score);
-        result->set_title(base::ASCIIToUTF16("Test"));
         if (data.first == ash::SearchResultDisplayType::kCard) {
-          const GURL kFakeCardUrl = GURL("https://www.9oo91e.qjz9zk/coac?q=fake");
+          const GURL kFakeCardUrl = GURL("https://www.google.com/coac?q=fake");
           result->set_query_url(kFakeCardUrl);
         }
         results->Add(std::move(result));
@@ -354,49 +346,6 @@
     RunPendingMessages();
   }
 
-  // Add search results for test on embedded Assistant UI.
-  void SetUpSearchResultsForAssistantUI(int list_results_num,
-                                        int index_open_assistant_ui) {
-    SearchModel::SearchResults* results =
-        delegate_->GetSearchModel()->results();
-    results->DeleteAll();
-    double display_score = list_results_num;
-    for (int i = 0; i < list_results_num; ++i) {
-      // Set the display score of the results in decreasing order
-      // (so the earlier groups have higher display score, and therefore appear
-      // first).
-      display_score -= 1;
-      std::unique_ptr<TestSearchResult> result =
-          std::make_unique<TestSearchResult>();
-      result->set_display_type(ash::SearchResultDisplayType::kList);
-      result->set_display_score(display_score);
-      result->set_title(base::ASCIIToUTF16("Test" + base::NumberToString(i)));
-      result->set_result_id("Test" + base::NumberToString(i));
-      if (i == index_open_assistant_ui)
-        result->set_is_omnibox_search(true);
-
-      results->Add(std::move(result));
-    }
-
-    // Adding results will schedule Update().
-    RunPendingMessages();
-  }
-
-  void ClearSearchResults() {
-    delegate_->GetSearchModel()->results()->DeleteAll();
-  }
-
-  void AddSearchResultWithTitleAndScore(const base::StringPiece& title,
-                                        double score) {
-    std::unique_ptr<TestSearchResult> result =
-        std::make_unique<TestSearchResult>();
-    result->set_display_type(ash::SearchResultDisplayType::kList);
-    result->set_display_score(score);
-    result->set_title(ASCIIToUTF16(title));
-    delegate_->GetSearchModel()->results()->Add(std::move(result));
-    RunPendingMessages();
-  }
-
   int GetOpenFirstSearchResultCount() {
     std::map<size_t, int>& counts = delegate_->open_search_result_counts();
     if (counts.size() == 0)
@@ -408,10 +357,6 @@
     return delegate_->open_search_result_count();
   }
 
-  int GetTotalOpenAssistantUICount() {
-    return delegate_->open_assistant_ui_count();
-  }
-
   // Test focus traversal across all the views in |view_list|. The initial focus
   // is expected to be on the first view in |view_list|. The final focus is
   // expected to be on the last view in |view_list| after |view_list.size()-1|
@@ -427,8 +372,10 @@
   }
 
   // Test the behavior triggered by left and right key when focus is on the
-  // |textfield|. Does not insert text.
-  void TestLeftAndRightKeyTraversalOnTextfield(views::Textfield* textfield) {
+  // |textfield|. |text_rtl| indicates whether to type RTL or non-RTL text in
+  // the |textfield| during the test.
+  void TestLeftAndRightKeyOnTextfield(views::Textfield* textfield,
+                                      bool text_rtl) {
     EXPECT_TRUE(textfield->text().empty());
     EXPECT_EQ(textfield, focused_view());
 
@@ -452,14 +399,6 @@
 
     SimulateKeyPress(ui::VKEY_RIGHT, false);
     EXPECT_EQ(textfield, focused_view());
-  }
-
-  // Test the behavior triggered by left and right key when focus is on the
-  // |textfield|. This includes typing text into the field.
-  void TestLeftAndRightKeyOnTextfieldWithText(views::Textfield* textfield,
-                                              bool text_rtl) {
-    // Test initial traversal
-    TestLeftAndRightKeyTraversalOnTextfield(textfield);
 
     // Type something in textfield.
     base::string16 text =
@@ -469,11 +408,9 @@
                   "\xd8\xa7\xd8\xae\xd8\xaa\xd8\xa8\xd8\xa7\xd8\xb1")
             : base::UTF8ToUTF16("test");
     textfield->InsertText(text);
-    views::View* next_view = next_view =
-        view_->GetWidget()->GetFocusManager()->GetNextFocusableView(
+    next_view = view_->GetWidget()->GetFocusManager()->GetNextFocusableView(
             textfield, view_->GetWidget(), false, false);
-    views::View* prev_view = prev_view =
-        view_->GetWidget()->GetFocusManager()->GetNextFocusableView(
+    prev_view = view_->GetWidget()->GetFocusManager()->GetNextFocusableView(
             textfield, view_->GetWidget(), true, false);
     EXPECT_EQ(text.length(), textfield->GetCursorPosition());
     EXPECT_FALSE(textfield->HasSelection());
@@ -613,8 +550,6 @@
   DISALLOW_COPY_AND_ASSIGN(AppListViewFocusTest);
 };
 
-INSTANTIATE_TEST_SUITE_P(, AppListViewFocusTest, testing::Bool());
-
 }  // namespace
 
 // Tests that the initial focus is on search box.
@@ -684,8 +619,8 @@
                      ui::VKEY_LEFT, false);
 }
 
-// Tests focus traversal in HALF state with opened search box using |VKEY_TAB|.
-TEST_F(AppListViewFocusTest, TabFocusTraversalInHalfState) {
+// Tests the linear focus traversal in HALF state with opened search box.
+TEST_P(AppListViewFocusTest, LinearFocusTraversalInHalfState) {
   Show();
 
   // Type something in search box to transition to HALF state and populate
@@ -721,61 +656,21 @@
 
   // Test traversal triggered by shift+tab.
   TestFocusTraversal(backward_view_list, ui::VKEY_TAB, true);
-}
-
-// Tests focus traversal in HALF state with opened search box using |VKEY_LEFT|
-// and |VKEY_RIGHT|.
-TEST_P(AppListViewFocusTest, LeftRightFocusTraversalInHalfState) {
-  Show();
-
-  // Type something in search box to transition to HALF state and populate
-  // fake search results.
-  // Type something in textfield.
-  base::string16 text =
-      is_rtl_
-          // Arabic word of "test".
-          ? base::UTF8ToUTF16(
-                "\xd8\xa7\xd8\xae\xd8\xaa\xd8\xa8\xd8\xa7\xd8\xb1")
-          : base::UTF8ToUTF16("test");
-  search_box_view()->search_box()->InsertText(text);
-  EXPECT_EQ(app_list_view()->app_list_state(), AppListViewState::HALF);
-
-  constexpr int kTileResults = 6;
-  SetUpSearchResults(kTileResults, 0, false);
-
-  std::vector<views::View*> forward_view_list;
-  forward_view_list.push_back(search_box_view()->search_box());
-  const std::vector<SearchResultTileItemView*>& tile_views =
-      contents_view()
-          ->search_result_tile_item_list_view_for_test()
-          ->tile_views_for_test();
-  for (int i = 1; i < kTileResults; ++i)
-    forward_view_list.push_back(tile_views[i]);
-  forward_view_list.push_back(search_box_view()->search_box());
 
-  TestFocusTraversal(forward_view_list,
-                     is_rtl_ ? ui::VKEY_LEFT : ui::VKEY_RIGHT, false);
-
-  std::vector<views::View*> backward_view_list = forward_view_list;
-
-  // Backwards traversal won't skip any items, as the first view won't be
-  // highlighted.
-  backward_view_list.insert(backward_view_list.begin() + 1, tile_views[0]);
-
-  // The intuitive focus is where the highlight is, on the first result.
-  // Because of this, the 'x' is effectively behind us and should only be
-  // traversed in the backwards list. The view in front of us it the second
-  // result, so that is what we should jump to next.
-  backward_view_list.insert(backward_view_list.begin() + 1,
-                            search_box_view()->close_button());
-  std::reverse(backward_view_list.begin(), backward_view_list.end());
-
-  // The text in the box will be highlighted, the first press should deselect.
+  // Test traversal triggered by right. When the search box is focused, all
+  // text are selected. Hitting right key will move the cursor to the right end
+  // and unselect the text. Hitting right key again will move the focus to the
+  // next view. Left key is handled in similar way.
+  forward_view_list.insert(forward_view_list.begin(),
+                           search_box_view()->search_box());
   backward_view_list.insert(backward_view_list.begin(),
                             search_box_view()->search_box());
+  TestFocusTraversal(is_rtl_ ? backward_view_list : forward_view_list,
+                     ui::VKEY_RIGHT, false);
 
-  TestFocusTraversal(backward_view_list,
-                     is_rtl_ ? ui::VKEY_RIGHT : ui::VKEY_LEFT, false);
+  // Test traversal triggered by left.
+  TestFocusTraversal(is_rtl_ ? forward_view_list : backward_view_list,
+                     ui::VKEY_LEFT, false);
 }
 
 // Tests the linear focus traversal in FULLSCREEN_ALL_APPS state within folder.
@@ -891,10 +786,7 @@
       contents_view()
           ->search_result_tile_item_list_view_for_test()
           ->tile_views_for_test();
-  // We skip the first view when coming from the search box. This is because
-  // the first view is initially highlighted, and would already be activated
-  // upon pressing enter. Hence, we skip adding the tile view to the expected
-  // view list.
+  forward_view_list.push_back(tile_views[0]);
   forward_view_list.push_back(contents_view()
                                   ->search_result_answer_card_view_for_test()
                                   ->GetAnswerCardResultViewForTest());
@@ -936,7 +828,7 @@
   forward_view_list.push_back(search_box_view()->search_box());
   const views::ViewModelT<AppListItemView>* view_model =
       app_list_folder_view()->items_grid_view()->view_model();
-  for (size_t i = 0; i < AppListConfig::instance().max_folder_items_per_page();
+  for (size_t i = 0; i < kMaxFolderItemsPerPage;
        i += app_list_folder_view()->items_grid_view()->cols()) {
     forward_view_list.push_back(view_model->view_at(i));
   }
@@ -951,10 +843,9 @@
   backward_view_list.push_back(search_box_view()->search_box());
   backward_view_list.push_back(
       app_list_folder_view()->folder_header_view()->GetFolderNameViewForTest());
-  for (int i = AppListConfig::instance().max_folder_items_per_page() - 1;
-       i >= 0; i -= app_list_folder_view()->items_grid_view()->cols()) {
+  for (int i = kMaxFolderItemsPerPage - 1; i >= 0;
+       i -= app_list_folder_view()->items_grid_view()->cols())
     backward_view_list.push_back(view_model->view_at(i));
-  }
   backward_view_list.push_back(search_box_view()->search_box());
 
   // Test traversal triggered by up.
@@ -980,8 +871,7 @@
   forward_view_list.push_back(search_box_view()->search_box());
   const views::ViewModelT<AppListItemView>* view_model =
       app_list_folder_view()->items_grid_view()->view_model();
-  for (int i = AppListConfig::instance().max_folder_items_per_page();
-       i < view_model->view_size();
+  for (int i = kMaxFolderItemsPerPage; i < view_model->view_size();
        i += app_list_folder_view()->items_grid_view()->cols()) {
     forward_view_list.push_back(view_model->view_at(i));
   }
@@ -996,8 +886,7 @@
   backward_view_list.push_back(search_box_view()->search_box());
   backward_view_list.push_back(
       app_list_folder_view()->folder_header_view()->GetFolderNameViewForTest());
-  for (size_t i = view_model->view_size() - 1;
-       i >= AppListConfig::instance().max_folder_items_per_page();
+  for (size_t i = view_model->view_size() - 1; i >= kMaxFolderItemsPerPage;
        i -= app_list_folder_view()->items_grid_view()->cols()) {
     backward_view_list.push_back(view_model->view_at(i));
   }
@@ -1105,35 +994,6 @@
   EXPECT_FALSE(search_box_view()->search_box()->HasSelection());
 }
 
-// Tests that focus changes update the search box text.
-TEST_F(AppListViewFocusTest, SearchBoxTextUpdatesOnResultFocus) {
-  Show();
-  views::Textfield* search_box = search_box_view()->search_box();
-  search_box->InsertText(base::ASCIIToUTF16("TestText"));
-
-  // Set up test results with unique titles
-  ClearSearchResults();
-  AddSearchResultWithTitleAndScore("TestResult1", 3);
-  AddSearchResultWithTitleAndScore("TestResult2", 2);
-  AddSearchResultWithTitleAndScore("TestResult3", 1);
-
-  // Change focus to the first result
-  SimulateKeyPress(ui::VKEY_TAB, false);
-  SimulateKeyPress(ui::VKEY_TAB, false);
-
-  EXPECT_EQ(search_box->text(), base::UTF8ToUTF16("TestResult1"));
-
-  // Change focus to the next result
-  SimulateKeyPress(ui::VKEY_TAB, false);
-
-  EXPECT_EQ(search_box->text(), base::UTF8ToUTF16("TestResult2"));
-
-  // Change focus to the final result
-  SimulateKeyPress(ui::VKEY_TAB, false);
-
-  EXPECT_EQ(search_box->text(), base::UTF8ToUTF16("TestResult3"));
-}
-
 // Tests that the search box selects the whole query when focus moves to the
 // SearchBoxTextfield.
 TEST_F(AppListViewFocusTest, SearchBoxSelectionCoversWholeQueryOnFocus) {
@@ -1393,15 +1253,15 @@
   folder_name_view->RequestFocus();
 
   // Test folder name.
-  TestLeftAndRightKeyOnTextfieldWithText(folder_name_view, false);
-  TestLeftAndRightKeyOnTextfieldWithText(folder_name_view, true);
+  TestLeftAndRightKeyOnTextfield(folder_name_view, false);
+  TestLeftAndRightKeyOnTextfield(folder_name_view, true);
 
   // Set focus on the search box.
   search_box_view()->search_box()->RequestFocus();
 
-  // Test search box. Active traversal has been tested at this point. This will
-  // specifically test inactive traversal with no search results set up.
-  TestLeftAndRightKeyTraversalOnTextfield(search_box_view()->search_box());
+  // Test search box.
+  TestLeftAndRightKeyOnTextfield(search_box_view()->search_box(), false);
+  TestLeftAndRightKeyOnTextfield(search_box_view()->search_box(), true);
 }
 
 // Tests that the focus is reset onto the search box and the folder exits after
@@ -1475,32 +1335,21 @@
 }
 
 TEST_F(AppListViewTest, MouseWheelScrollTransitionsToFullscreen) {
-  base::HistogramTester histogram_tester;
-
   Initialize(0, false, false);
   delegate_->GetTestModel()->PopulateApps(kInitialItems);
   Show();
 
   view_->HandleScroll(gfx::Vector2d(0, -30), ui::ET_MOUSEWHEEL);
   EXPECT_EQ(AppListViewState::FULLSCREEN_ALL_APPS, view_->app_list_state());
-  // This should use animation instead of drag.
-  // TODO(oshima): Test AnimationSmoothness.
-  histogram_tester.ExpectTotalCount(
-      "Apps.StateTransition.Drag.PresentationTime.ClamshellMode", 0);
 }
 
 TEST_F(AppListViewTest, GestureScrollTransitionsToFullscreen) {
-  base::HistogramTester histogram_tester;
   Initialize(0, false, false);
   delegate_->GetTestModel()->PopulateApps(kInitialItems);
   Show();
 
   view_->HandleScroll(gfx::Vector2d(0, -30), ui::ET_SCROLL);
   EXPECT_EQ(AppListViewState::FULLSCREEN_ALL_APPS, view_->app_list_state());
-  // This should use animation instead of drag.
-  // TODO(oshima): Test AnimationSmoothness.
-  histogram_tester.ExpectTotalCount(
-      "Apps.StateTransition.Drag.PresentationTime.ClamshellMode", 0);
 }
 
 // Tests that typing text after opening transitions from peeking to half.
@@ -1793,14 +1642,11 @@
 
 // Tests that search box should not become a rectangle during drag.
 TEST_F(AppListViewTest, SearchBoxCornerRadiusDuringDragging) {
-  base::HistogramTester histogram_tester;
   Initialize(0, false, false);
   delegate_->GetTestModel()->PopulateApps(kInitialItems);
   Show();
   view_->SetState(AppListViewState::FULLSCREEN_ALL_APPS);
   EXPECT_EQ(AppListViewState::FULLSCREEN_ALL_APPS, view_->app_list_state());
-  histogram_tester.ExpectTotalCount(
-      "Apps.StateTransition.Drag.PresentationTime.ClamshellMode", 0);
 
   // Send SCROLL_START and SCROLL_UPDATE events, simulating dragging the
   // launcher.
@@ -1813,8 +1659,6 @@
       start.x(), start.y(), ui::EF_NONE, timestamp,
       ui::GestureEventDetails(ui::ET_GESTURE_SCROLL_BEGIN, 0, delta_y));
   view_->OnGestureEvent(&start_event);
-  histogram_tester.ExpectTotalCount(
-      "Apps.StateTransition.Drag.PresentationTime.ClamshellMode", 0);
 
   // Drag down the launcher.
   timestamp += base::TimeDelta::FromMilliseconds(25);
@@ -1837,10 +1681,6 @@
   EXPECT_EQ(search_box::kSearchBoxBorderCornerRadius,
             search_box_view()->GetSearchBoxBorderCornerRadiusForState(
                 ash::AppListState::kStateSearchResults));
-  histogram_tester.ExpectTotalCount(
-      "Apps.StateTransition.Drag.PresentationTime.ClamshellMode", 1);
-  histogram_tester.ExpectTotalCount(
-      "Apps.StateTransition.Drag.PresentationTime.MaxLatency.ClamshellMode", 0);
 
   // Ends to drag the launcher.
   EXPECT_TRUE(SetAppListState(ash::AppListState::kStateApps));
@@ -1857,10 +1697,6 @@
   EXPECT_EQ(search_box::kSearchBoxBorderCornerRadius,
             search_box_view()->GetSearchBoxBorderCornerRadiusForState(
                 ash::AppListState::kStateApps));
-  histogram_tester.ExpectTotalCount(
-      "Apps.StateTransition.Drag.PresentationTime.ClamshellMode", 1);
-  histogram_tester.ExpectTotalCount(
-      "Apps.StateTransition.Drag.PresentationTime.MaxLatency.ClamshellMode", 1);
 }
 
 // Tests displaying the app list and performs a standard set of checks on its
@@ -2163,128 +1999,5 @@
   EXPECT_EQ(0, apps_grid_view()->pagination_model()->selected_page());
 }
 
-// Tests selecting search result to show embedded Assistant UI.
-TEST_F(AppListViewFocusTest, ShowEmbeddedAssistantUI) {
-  scoped_feature_list_.InitWithFeatures(
-      {chromeos::switches::kAssistantFeature,
-       app_list_features::kEnableEmbeddedAssistantUI},
-      {});
-  Show();
-
-  // Initially the search box is inactive, hitting Enter to activate it.
-  EXPECT_FALSE(search_box_view()->is_search_box_active());
-  SimulateKeyPress(ui::VKEY_RETURN, false);
-  EXPECT_TRUE(search_box_view()->is_search_box_active());
-
-  // Type something in search box to transition to HALF state and populate
-  // fake list results. Then hit Enter key.
-  search_box_view()->search_box()->InsertText(base::UTF8ToUTF16("test"));
-  const int kListResults = 2;
-  const int kIndexOpenAssistantUi = 1;
-  SetUpSearchResultsForAssistantUI(kListResults, kIndexOpenAssistantUi);
-  SimulateKeyPress(ui::VKEY_RETURN, false);
-  EXPECT_EQ(1, GetOpenFirstSearchResultCount());
-  EXPECT_EQ(1, GetTotalOpenSearchResultCount());
-  EXPECT_EQ(0, GetTotalOpenAssistantUICount());
-
-  SearchResultListView* list_view =
-      contents_view()->search_result_list_view_for_test();
-  ui::KeyEvent key_event(ui::ET_KEY_PRESSED, ui::VKEY_RETURN, ui::EF_NONE);
-  list_view->GetResultViewAt(kIndexOpenAssistantUi)->OnKeyEvent(&key_event);
-  EXPECT_EQ(1, GetOpenFirstSearchResultCount());
-  EXPECT_EQ(2, GetTotalOpenSearchResultCount());
-  EXPECT_EQ(1, GetTotalOpenAssistantUICount());
-}
-
-// Tests that no answer card view when kEnableEmbeddedAssistantUI is enabled.
-TEST_F(AppListViewTest, NoAnswerCardWhenEmbeddedAssistantUIEnabled) {
-  base::test::ScopedFeatureList scoped_feature_list;
-  scoped_feature_list.InitWithFeatures(
-      {chromeos::switches::kAssistantFeature,
-       app_list_features::kEnableEmbeddedAssistantUI},
-      {});
-  ASSERT_TRUE(app_list_features::IsEmbeddedAssistantUIEnabled());
-
-  Initialize(0, false, false);
-  Show();
-
-  EXPECT_FALSE(contents_view()->search_result_answer_card_view_for_test());
-}
-
-// Tests that pressing escape when in embedded Assistant UI to search page view.
-TEST_F(AppListViewTest, EscapeKeyEmbeddedAssistantUIToSearch) {
-  base::test::ScopedFeatureList scoped_feature_list;
-  scoped_feature_list.InitWithFeatures(
-      {chromeos::switches::kAssistantFeature,
-       app_list_features::kEnableEmbeddedAssistantUI},
-      {});
-  ASSERT_TRUE(app_list_features::IsEmbeddedAssistantUIEnabled());
-
-  Initialize(0, false, false);
-  Show();
-
-  // Set search_box_view active.
-  ui::KeyEvent key_event(ui::ET_KEY_PRESSED, ui::VKEY_RETURN, ui::EF_NONE);
-  view_->GetWidget()->OnKeyEvent(&key_event);
-
-  contents_view()->ShowEmbeddedAssistantUI(true);
-  EXPECT_TRUE(contents_view()->IsShowingEmbeddedAssistantUI());
-
-  view_->AcceleratorPressed(ui::Accelerator(ui::VKEY_ESCAPE, ui::EF_NONE));
-  EXPECT_TRUE(contents_view()->IsShowingSearchResults());
-}
-
-// Tests that clicking empty region in AppListview when showing Assistant UI
-// should go back to peeking state.
-TEST_F(AppListViewTest, ClickOutsideEmbeddedAssistantUIToPeeking) {
-  base::test::ScopedFeatureList scoped_feature_list;
-  scoped_feature_list.InitWithFeatures(
-      {chromeos::switches::kAssistantFeature,
-       app_list_features::kEnableEmbeddedAssistantUI},
-      {});
-  ASSERT_TRUE(app_list_features::IsEmbeddedAssistantUIEnabled());
-
-  Initialize(0, false, false);
-  Show();
-
-  // Set search_box_view active.
-  ui::KeyEvent key_event(ui::ET_KEY_PRESSED, ui::VKEY_RETURN, ui::EF_NONE);
-  view_->GetWidget()->OnKeyEvent(&key_event);
-
-  contents_view()->ShowEmbeddedAssistantUI(true);
-  EXPECT_TRUE(contents_view()->IsShowingEmbeddedAssistantUI());
-
-  // Click on the same empty region, the AppList should be peeking state.
-  const gfx::Point empty_region = view_->GetBoundsInScreen().origin();
-  ui::MouseEvent mouse_click(ui::ET_MOUSE_PRESSED, empty_region, empty_region,
-                             base::TimeTicks(), 0, 0);
-  ui::Event::DispatcherApi mouse_click_dispatcher_api(
-      static_cast<ui::Event*>(&mouse_click));
-  mouse_click_dispatcher_api.set_target(view_);
-  view_->OnMouseEvent(&mouse_click);
-  EXPECT_EQ(AppListViewState::PEEKING, view_->app_list_state());
-}
-
-// Tests that expand arrow is not visible when showing embedded Assistant UI.
-TEST_F(AppListViewTest, ExpandArrowNotVisibleInEmbeddedAssistantUI) {
-  base::test::ScopedFeatureList scoped_feature_list;
-  scoped_feature_list.InitWithFeatures(
-      {chromeos::switches::kAssistantFeature,
-       app_list_features::kEnableEmbeddedAssistantUI},
-      {});
-  ASSERT_TRUE(app_list_features::IsEmbeddedAssistantUIEnabled());
-
-  Initialize(0, false, false);
-  Show();
-
-  // Set search_box_view active.
-  ui::KeyEvent key_event(ui::ET_KEY_PRESSED, ui::VKEY_RETURN, ui::EF_NONE);
-  view_->GetWidget()->OnKeyEvent(&key_event);
-
-  contents_view()->ShowEmbeddedAssistantUI(true);
-  EXPECT_TRUE(contents_view()->IsShowingEmbeddedAssistantUI());
-  EXPECT_TRUE(contents_view()->expand_arrow_view()->layer()->opacity() == 0.0f);
-}
-
 }  // namespace test
 }  // namespace app_list
--- a/ash/app_list/views/apps_container_view.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/views/apps_container_view.cc	2019-05-17 18:53:08.084000000 +0300
@@ -64,6 +64,7 @@
   suggestion_chip_container_view_ =
       new SuggestionChipContainerView(contents_view);
   AddChildView(suggestion_chip_container_view_);
+  UpdateSuggestionChips();
 
   apps_grid_view_ = new AppsGridView(contents_view_, nullptr);
   apps_grid_view_->SetLayout(AppListConfig::instance().preferred_cols(),
@@ -103,14 +104,9 @@
 
   SetShowState(SHOW_ACTIVE_FOLDER, false);
 
-  // Avoid announcing search box focus since it is overlapped with opening
-  // folder alert.
-  auto* search_box = contents_view_->GetSearchBoxView()->search_box();
-  search_box->GetViewAccessibility().OverrideIsIgnored(true);
-
   // Disable all the items behind the folder so that they will not be reached
   // during focus traversal.
-  search_box->RequestFocus();
+  contents_view_->GetSearchBoxView()->search_box()->RequestFocus();
   DisableFocusForShowingActiveFolder(true);
 }
 
@@ -179,11 +175,9 @@
   gfx::Rect switcher_bounds = page_switcher_->GetBoundsInScreen();
   float centerline_above_work_area =
       std::max<float>(screen_bottom - switcher_bounds.CenterPoint().y(), 0.f);
-  const float start_px = AppListConfig::instance().all_apps_opacity_start_px();
-  float opacity = std::min(
-      std::max(
-          (centerline_above_work_area - start_px) /
-              (AppListConfig::instance().all_apps_opacity_end_px() - start_px),
+  float opacity =
+      std::min(std::max((centerline_above_work_area - kAllAppsOpacityStartPx) /
+                            (kAllAppsOpacityEndPx - kAllAppsOpacityStartPx),
           0.f),
       1.0f);
   page_switcher_->layer()->SetOpacity(should_restore_opacity ? 1.0f : opacity);
@@ -419,14 +413,6 @@
   return search_box_bounds;
 }
 
-void AppsContainerView::UpdateSuggestionChips() {
-  suggestion_chip_container_view_->SetResults(
-      contents_view_->GetAppListMainView()
-          ->view_delegate()
-          ->GetSearchModel()
-          ->results());
-}
-
 void AppsContainerView::SetShowState(ShowState show_state,
                                      bool show_apps_with_animation) {
   if (show_state_ == show_state)
@@ -442,6 +428,7 @@
     case SHOW_APPS:
       folder_background_view_->SetVisible(false);
       apps_grid_view_->ResetForShowApps();
+      UpdateSuggestionChips();
       if (show_apps_with_animation)
         app_list_folder_view_->ScheduleShowHideAnimation(false, false);
       else
@@ -460,6 +447,14 @@
   }
 }
 
+void AppsContainerView::UpdateSuggestionChips() {
+  suggestion_chip_container_view_->SetResults(
+      contents_view_->GetAppListMainView()
+          ->view_delegate()
+          ->GetSearchModel()
+          ->results());
+}
+
 void AppsContainerView::DisableFocusForShowingActiveFolder(bool disabled) {
   suggestion_chip_container_view_->DisableFocusForShowingActiveFolder(disabled);
   apps_grid_view_->DisableFocusForShowingActiveFolder(disabled);
--- a/ash/app_list/views/apps_container_view.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/views/apps_container_view.h	2019-05-17 18:53:08.084000000 +0300
@@ -97,9 +97,6 @@
   }
   AppListFolderView* app_list_folder_view() { return app_list_folder_view_; }
 
-  // Updates suggestion chips from app list model.
-  void UpdateSuggestionChips();
-
  private:
   enum ShowState {
     SHOW_NONE,  // initial state
@@ -110,6 +107,9 @@
 
   void SetShowState(ShowState show_state, bool show_apps_with_animation);
 
+  // Updates suggestion chips from app list model.
+  void UpdateSuggestionChips();
+
   // Suggestion chips and apps grid view become unfocusable if |disabled| is
   // true. This is used to trap focus within the folder when it is opened.
   void DisableFocusForShowingActiveFolder(bool disabled);
--- a/ash/app_list/views/apps_grid_view.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/views/apps_grid_view.cc	2019-05-17 18:53:08.084000000 +0300
@@ -8,7 +8,6 @@
 #include <memory>
 #include <set>
 #include <string>
-#include <utility>
 #include <vector>
 
 #include "ash/app_list/app_list_metrics.h"
@@ -23,12 +22,12 @@
 #include "ash/app_list/views/app_list_main_view.h"
 #include "ash/app_list/views/apps_container_view.h"
 #include "ash/app_list/views/contents_view.h"
-#include "ash/app_list/views/ghost_image_view.h"
 #include "ash/app_list/views/pulsing_block_view.h"
 #include "ash/app_list/views/search_box_view.h"
 #include "ash/app_list/views/search_result_tile_item_view.h"
 #include "ash/app_list/views/top_icon_animation_view.h"
 #include "ash/public/cpp/app_list/app_list_config.h"
+#include "ash/public/cpp/app_list/app_list_constants.h"
 #include "ash/public/cpp/app_list/app_list_features.h"
 #include "ash/public/cpp/app_list/app_list_switches.h"
 #include "base/guid.h"
@@ -38,7 +37,6 @@
 #include "base/strings/string_number_conversions.h"
 #include "base/strings/utf_string_conversions.h"
 #include "build/build_config.h"
-#include "ui/accessibility/ax_node_data.h"
 #include "ui/aura/window.h"
 #include "ui/aura/window_event_dispatcher.h"
 #include "ui/base/l10n/l10n_util.h"
@@ -88,27 +86,6 @@
 // Maximum vertical and horizontal spacing between tiles.
 constexpr int kMaximumTileSpacing = 96;
 
-// Animation curve used for fading in the target page when opening or closing
-// a folder.
-constexpr gfx::Tween::Type kFolderFadeInTweenType = gfx::Tween::EASE_IN_2;
-
-// Animation curve used for fading out the target page when opening or closing
-// a folder.
-constexpr gfx::Tween::Type kFolderFadeOutTweenType =
-    gfx::Tween::FAST_OUT_LINEAR_IN;
-
-// Presentation time histogram for apps grid scroll by dragging.
-constexpr char kPageDragScrollInClamshellHistogram[] =
-    "Apps.PaginationTransition.DragScroll.PresentationTime.ClamshellMode";
-constexpr char kPageDragScrollInClamshellMaxLatencyHistogram[] =
-    "Apps.PaginationTransition.DragScroll.PresentationTime.MaxLatency."
-    "ClamshellMode";
-constexpr char kPageDragScrollInTabletHistogram[] =
-    "Apps.PaginationTransition.DragScroll.PresentationTime.TabletMode";
-constexpr char kPageDragScrollInTabletMaxLatencyHistogram[] =
-    "Apps.PaginationTransition.DragScroll.PresentationTime.MaxLatency."
-    "TabletMode";
-
 // Returns the size of a tile view excluding its padding.
 gfx::Size GetTileViewSize() {
   return gfx::Size(AppListConfig::instance().grid_tile_width(),
@@ -315,7 +292,9 @@
       bounds_animator_(this),
       page_flip_delay_in_ms_(kPageFlipDelayInMsFullscreen),
       pagination_animation_start_frame_number_(0),
-      view_structure_(this) {
+      view_structure_(this),
+      is_apps_grid_gap_feature_enabled_(
+          app_list_features::IsAppsGridGapFeatureEnabled()) {
   DCHECK(contents_view_);
   SetPaintToLayer(ui::LAYER_NOT_DRAWN);
   // Clip any icons that are outside the grid view's bounds. These icons would
@@ -325,9 +304,8 @@
   if (!folder_delegate)
     SetBorder(views::CreateEmptyBorder(gfx::Insets(kFadeoutZoneHeight, 0)));
 
-  pagination_model_.SetTransitionDurations(
-      AppListConfig::instance().page_transition_duration_ms(),
-      AppListConfig::instance().overscroll_page_transition_duration_ms());
+  pagination_model_.SetTransitionDurations(kPageTransitionDurationInMs,
+                                           kOverscrollPageTransitionDurationMs);
 
   pagination_model_.AddObserver(this);
 
@@ -502,10 +480,6 @@
     return;
 
   drag_view_ = view;
-
-  // Dragged view should have focus. This also fixed the issue
-  // https://crbug.com/834682.
-  drag_view_->RequestFocus();
   drag_view_init_index_ = GetIndexOfView(drag_view_);
   drag_view_offset_ = location;
   drag_start_page_ = pagination_model_.selected_page();
@@ -665,13 +639,10 @@
       UpdateDropTargetRegion();
       if (drop_target_region_ == ON_ITEM && DraggedItemCanEnterFolder() &&
           DropTargetIsValidFolder()) {
-        MaybeCreateFolderDroppingAccessibilityEvent();
         MoveItemToFolder(drag_view_, drop_target_);
         folder_item_view =
             GetViewDisplayedAtSlotOnCurrentPage(drop_target_.slot);
       } else if (IsValidReorderTargetIndex(drop_target_)) {
-        // Ensure reorder event has already been announced by the end of drag.
-        MaybeCreateReorderAccessibilityEvent();
         MoveItemInModel(drag_view_, drop_target_);
       }
     }
@@ -700,7 +671,7 @@
   ClearDragState();
   UpdatePaging();
   AnimateToIdealBounds();
-  if (!cancel && !folder_delegate_)
+  if (!cancel && IsAppsGridGapEnabled())
     view_structure_.SaveToMetadata();
 
   if (folder_item_view) {
@@ -719,9 +690,6 @@
     }
   }
 
-  // Hide the |current_ghost_view_| for item drag that started
-  // within |apps_grid_view_|.
-  BeginHideCurrentGhostImageView();
   StopPageFlipTimer();
 }
 
@@ -753,8 +721,7 @@
   animation.SetTweenType(show ? kFolderFadeInTweenType
                               : kFolderFadeOutTweenType);
   animation.SetTransitionDuration(base::TimeDelta::FromMilliseconds(
-      show ? AppListConfig::instance().folder_transition_in_duration_ms()
-           : AppListConfig::instance().folder_transition_out_duration_ms()));
+      show ? kFolderTransitionInDurationMs : kFolderTransitionOutDurationMs));
 
   layer()->SetOpacity(show ? 1.0f : 0.0f);
 }
@@ -779,10 +746,6 @@
                           false /* is_in_folder */);
   AddChildView(view);
   drag_view_ = view;
-
-  // Dragged view should have focus. This also fixed the issue
-  // https://crbug.com/834682.
-  drag_view_->RequestFocus();
   drag_view_->SetBoundsRect(drag_view_rect);
   drag_view_->SetDragUIState();  // Hide the title of the drag_view_.
 
@@ -793,7 +756,7 @@
 
   // Add drag_view_ to the end of the view_model_.
   view_model_.Add(drag_view_, view_model_.view_size());
-  if (!folder_delegate_)
+  if (IsAppsGridGapEnabled())
     view_structure_.Add(drag_view_, GetLastTargetIndex());
 
   drag_start_page_ = pagination_model_.selected_page();
@@ -825,9 +788,6 @@
 }
 
 void AppsGridView::ClearDragState() {
-  current_ghost_location_ = GridIndex();
-  last_folder_dropping_a11y_event_location_ = GridIndex();
-  last_reorder_a11y_event_location_ = GridIndex();
   drop_target_region_ = NO_TARGET;
   drag_pointer_ = NONE;
   drop_target_ = GridIndex();
@@ -894,14 +854,11 @@
   if (GetContentsBounds().IsEmpty())
     return;
 
-  if (presentation_time_recorder_)
-    presentation_time_recorder_->RequestNext();
-
   if (fadeout_layer_delegate_)
     fadeout_layer_delegate_->layer()->SetBounds(layer()->bounds());
 
   UpdateTilePadding();
-  CalculateIdealBoundsForFolder();
+  CalculateIdealBounds();
   for (int i = 0; i < view_model_.view_size(); ++i) {
     AppListItemView* view = GetItemViewAt(i);
     if (view != drag_view_)
@@ -939,7 +896,7 @@
 
 bool AppsGridView::OnKeyPressed(const ui::KeyEvent& event) {
   // Let the FocusManager handle Left/Right keys.
-  if (!IsUnhandledUpDownKeyEvent(event))
+  if (!CanProcessUpDownKeyTraversal(event))
     return false;
 
   return HandleVerticalFocusMovement(event.key_code() ==
@@ -960,13 +917,6 @@
     if (drag_view_ == details.child)
       EndDrag(true);
 
-    if (app_list_features::IsAppGridGhostEnabled()) {
-      if (current_ghost_view_ == details.child)
-        current_ghost_view_ = nullptr;
-      if (last_ghost_view_ == details.child)
-        last_ghost_view_ = nullptr;
-    }
-
     bounds_animator_.StopAnimatingView(details.child);
   }
 }
@@ -1031,7 +981,7 @@
     view_model_.Add(view, view_model_.view_size());
     AddChildView(view);
   }
-  if (!folder_delegate_)
+  if (IsAppsGridGapEnabled())
     view_structure_.LoadFromMetadata();
   UpdateColsAndRowsForFolder();
   UpdatePaging();
@@ -1045,13 +995,13 @@
 
 int AppsGridView::TilesPerPage(int page) const {
   if (folder_delegate_)
-    return AppListConfig::instance().max_folder_items_per_page();
+    return kMaxFolderItemsPerPage;
 
   return AppListConfig::instance().GetMaxNumOfItemsPerPage(page);
 }
 
 void AppsGridView::UpdatePaging() {
-  if (!folder_delegate_) {
+  if (IsAppsGridGapEnabled()) {
     pagination_model_.SetTotalPages(view_structure_.total_pages());
     return;
   }
@@ -1141,7 +1091,7 @@
   EnsureViewVisible(index);
   selected_view_ = new_selection;
   selected_view_->SchedulePaint();
-  selected_view_->NotifyAccessibilityEvent(ax::mojom::Event::kFocus, true);
+  selected_view_->NotifyAccessibilityEvent(ax::mojom::Event::kSelection, true);
 }
 
 GridIndex AppsGridView::GetIndexOfView(const AppListItemView* view) const {
@@ -1212,9 +1162,9 @@
   return gfx::Vector2d(x_offset, y_offset);
 }
 
-void AppsGridView::CalculateIdealBoundsForFolder() {
-  if (!folder_delegate_) {
-    CalculateIdealBounds();
+void AppsGridView::CalculateIdealBounds() {
+  if (IsAppsGridGapEnabled()) {
+    CalculateIdealBoundsWithGridGap();
     return;
   }
 
@@ -1249,7 +1199,7 @@
 void AppsGridView::AnimateToIdealBounds() {
   const gfx::Rect visible_bounds(GetVisibleBounds());
 
-  CalculateIdealBoundsForFolder();
+  CalculateIdealBounds();
   for (int i = 0; i < view_model_.view_size(); ++i) {
     AppListItemView* view = GetItemViewAt(i);
     if (view == drag_view_)
@@ -1377,9 +1327,7 @@
   // Items can only be dropped into non-folders (which have no children) or
   // folders that have fewer than the max allowed items.
   // The OEM folder does not allow drag/drop of other items into it.
-  const size_t kMaxItemCount =
-      AppListConfig::instance().max_folder_items_per_page() *
-      AppListConfig::instance().max_folder_pages();
+  const size_t kMaxItemCount = kMaxFolderItemsPerPage * kMaxFolderPages;
   if (target_item->ChildItemCount() >= kMaxItemCount ||
       IsOEMFolderItem(target_item)) {
     return false;
@@ -1490,9 +1438,7 @@
 
 void AppsGridView::OnReorderTimer() {
   reorder_placeholder_ = drop_target_;
-  MaybeCreateReorderAccessibilityEvent();
   AnimateToIdealBounds();
-  CreateGhostImageView();
 }
 
 void AppsGridView::OnFolderItemReparentTimer() {
@@ -1512,9 +1458,7 @@
 }
 
 void AppsGridView::OnFolderDroppingTimer() {
-  MaybeCreateFolderDroppingAccessibilityEvent();
   SetAsFolderDroppingTarget(drop_target_, true);
-  BeginHideCurrentGhostImageView();
 }
 
 void AppsGridView::UpdateDragStateInsideFolder(Pointer pointer,
@@ -1654,8 +1598,7 @@
 
   // Try to shape the apps grid into a square.
   int items_in_one_page =
-      std::min(AppListConfig::instance().max_folder_items_per_page(),
-               item_list_->item_count());
+      std::min(kMaxFolderItemsPerPage, item_list_->item_count());
   cols_ = std::sqrt(items_in_one_page - 1) + 1;
   rows_per_page_ = (items_in_one_page - 1) / cols_ + 1;
 }
@@ -1690,8 +1633,6 @@
     if (drop_target_region_ == ON_ITEM && DropTargetIsValidFolder() &&
         DraggedItemCanEnterFolder()) {
       cancel_reparent = !ReparentItemToAnotherFolder(drag_view_, drop_target_);
-      // Announce folder dropping event before end of drag of reparented item.
-      MaybeCreateFolderDroppingAccessibilityEvent();
       if (!cancel_reparent) {
         folder_item_view =
             GetViewDisplayedAtSlotOnCurrentPage(drop_target_.slot);
@@ -1699,9 +1640,6 @@
     } else if (drop_target_region_ != NO_TARGET &&
                IsValidReorderTargetIndex(drop_target_)) {
       ReparentItemForReorder(drag_view_, drop_target_);
-      // Announce accessibility event before the end of drag for reparented
-      // item.
-      MaybeCreateReorderAccessibilityEvent();
     } else {
       NOTREACHED();
     }
@@ -1718,7 +1656,7 @@
   }
   ClearDragState();
   AnimateToIdealBounds();
-  if (!folder_delegate_)
+  if (IsAppsGridGapEnabled())
     view_structure_.SaveToMetadata();
 
   if (cancel_reparent) {
@@ -1731,9 +1669,6 @@
                                  drag_source_bounds);
   }
 
-  // Hide the |current_ghost_view_| after completed drag from within
-  // folder to |apps_grid_view_|.
-  BeginHideCurrentGhostImageView();
   StopPageFlipTimer();
 }
 
@@ -1746,9 +1681,6 @@
 
   SetAsFolderDroppingTarget(drop_target_, false);
   ClearDragState();
-
-  // Hide |current_ghost_view_| in the hidden folder grid view.
-  BeginHideCurrentGhostImageView();
 }
 
 void AppsGridView::OnFolderItemRemoved() {
@@ -1780,12 +1712,9 @@
     views::View::ConvertRectToScreen(this, &view_bounds);
     centerline_above_work_area = std::max<float>(
         app_list_view->GetScreenBottom() - view_bounds.CenterPoint().y(), 0.f);
-    const float start_px =
-        AppListConfig::instance().all_apps_opacity_start_px();
     opacity = std::min(
-        std::max((centerline_above_work_area - start_px) /
-                     (AppListConfig::instance().all_apps_opacity_end_px() -
-                      start_px),
+        std::max((centerline_above_work_area - kAllAppsOpacityStartPx) /
+                     (kAllAppsOpacityEndPx - kAllAppsOpacityStartPx),
                  0.f),
         1.0f);
     opacity = should_restore_opacity ? 1.0f : opacity;
@@ -1815,17 +1744,14 @@
 
 AppListItemView* AppsGridView::GetCurrentPageFirstItemViewInFolder() {
   DCHECK(folder_delegate_);
-  int first_index = pagination_model_.selected_page() *
-                    AppListConfig::instance().max_folder_items_per_page();
+  int first_index = pagination_model_.selected_page() * kMaxFolderItemsPerPage;
   return view_model_.view_at(first_index);
 }
 
 AppListItemView* AppsGridView::GetCurrentPageLastItemViewInFolder() {
   DCHECK(folder_delegate_);
-  int last_index =
-      std::min((pagination_model_.selected_page() + 1) *
-                       AppListConfig::instance().max_folder_items_per_page() -
-                   1,
+  int last_index = std::min(
+      (pagination_model_.selected_page() + 1) * kMaxFolderItemsPerPage - 1,
                item_list_->item_count() - 1);
   return view_model_.view_at(last_index);
 }
@@ -1958,8 +1884,6 @@
   pagination_model_.SelectPage(page_flip_target_, true);
   UMA_HISTOGRAM_ENUMERATION(kAppListPageSwitcherSourceHistogram,
                             kDragAppToBorder, kMaxAppListPageSwitcherSource);
-
-  BeginHideCurrentGhostImageView();
 }
 
 void AppsGridView::MoveItemInModel(AppListItemView* item_view,
@@ -1974,7 +1898,7 @@
 
   // The same item index does not guarantee the same visual index, so move the
   // item visual index here.
-  if (!folder_delegate_)
+  if (IsAppsGridGapEnabled())
     view_structure_.Move(item_view, target);
 
   // Reorder the app list item views in accordance with |view_model_|.
@@ -2027,7 +1951,7 @@
           CreateViewForItemAtIndex(folder_item_index);
       target_folder_view->SetBoundsRect(target_view_bounds);
       view_model_.Add(target_folder_view, target_model_index);
-      if (!folder_delegate_)
+      if (IsAppsGridGapEnabled())
         view_structure_.Add(target_folder_view, target_index);
 
       // If drag view is in front of the position where it will be moved to, we
@@ -2045,7 +1969,7 @@
   // Fade out the drag_view_ and delete it when animation ends.
   int drag_model_index = view_model_.GetIndexOfView(drag_view_);
   view_model_.Remove(drag_model_index);
-  if (!folder_delegate_)
+  if (IsAppsGridGapEnabled())
     view_structure_.Remove(drag_view_);
   bounds_animator_.AnimateViewTo(drag_view_, drag_view_->bounds());
   bounds_animator_.SetAnimationDelegate(
@@ -2069,10 +1993,10 @@
   int target_model_index = GetTargetModelIndexForMove(item_view, target);
   int target_item_index = GetTargetItemIndexForMove(item_view, target);
 
-  // If the folder is a candidate for removal, the view needs to be updated
-  // accordingly.
+  // Remove the source folder view if there is only 1 item in it, since the
+  // source folder will be deleted after its only child item removed from it.
   GridIndex target_override = target;
-  if (source_folder->ShouldAutoRemove()) {
+  if (source_folder->ChildItemCount() == 1u) {
     const int deleted_folder_index =
         view_model_.GetIndexOfView(activated_folder_item_view_);
     const GridIndex deleted_folder_grid_index =
@@ -2089,7 +2013,8 @@
 
     // Adjust |target_override| if it is beyond the deleted folder grid index in
     // the same page.
-    if (!folder_delegate_ && target.page == deleted_folder_grid_index.page &&
+    if (IsAppsGridGapEnabled() &&
+        target.page == deleted_folder_grid_index.page &&
         target.slot > deleted_folder_grid_index.slot) {
       --target_override.slot;
     }
@@ -2104,7 +2029,7 @@
     target_position = item_list_->item_at(target_item_index)->position();
   model_->MoveItemToFolderAt(reparent_item, "", target_position);
   view_model_.Move(current_model_index, target_model_index);
-  if (!folder_delegate_)
+  if (IsAppsGridGapEnabled())
     view_structure_.Move(item_view, target_override);
   ReorderChildView(item_view, target_model_index);
 
@@ -2142,8 +2067,10 @@
   // Make change to data model.
   item_list_->RemoveObserver(this);
 
-  // Remove the source folder view if the folder is a candidate for removal.
-  if (source_folder->ShouldAutoRemove()) {
+  // Remove the source folder view if there is only 1 item in it, since the
+  // source folder will be deleted after its only child item merged into the
+  // target item.
+  if (source_folder->ChildItemCount() == 1u) {
     DeleteItemViewAtIndex(
         view_model_.GetIndexOfView(activated_folder_item_view()),
         false /* sanitize */);
@@ -2174,7 +2101,7 @@
           CreateViewForItemAtIndex(new_folder_index);
       new_folder_view->SetBoundsRect(target_rect);
       view_model_.Add(new_folder_view, target_model_index);
-      if (!folder_delegate_)
+      if (IsAppsGridGapEnabled())
         view_structure_.Add(new_folder_view, target_index);
       AddChildViewAt(new_folder_view, target_model_index);
     } else {
@@ -2189,7 +2116,7 @@
   // Fade out the drag_view_ and delete it when animation ends.
   int drag_model_index = view_model_.GetIndexOfView(drag_view_);
   view_model_.Remove(drag_model_index);
-  if (!folder_delegate_)
+  if (IsAppsGridGapEnabled())
     view_structure_.Remove(drag_view_);
   bounds_animator_.AnimateViewTo(drag_view_, drag_view_->bounds());
   bounds_animator_.SetAnimationDelegate(
@@ -2209,14 +2136,14 @@
     const std::string& source_folder_id) {
   AppListFolderItem* source_folder =
       static_cast<AppListFolderItem*>(item_list_->FindItem(source_folder_id));
-  if (!source_folder || (source_folder && !source_folder->ShouldAutoRemove()))
+  if (!source_folder || source_folder->ChildItemCount() != 1u)
     return;
 
   // Save the folder item view's bounds before deletion, which will be used as
   // last item view's bounds.
   gfx::Rect folder_rect = activated_folder_item_view()->bounds();
-  const GridIndex target_index = GetIndexOfView(activated_folder_item_view());
-  const int target_model_index =
+  GridIndex target_index = GetIndexOfView(activated_folder_item_view());
+  int target_model_index =
       view_model_.GetIndexOfView(activated_folder_item_view());
 
   // Delete view associated with the folder item to be removed.
@@ -2224,12 +2151,6 @@
       view_model_.GetIndexOfView(activated_folder_item_view()),
       false /* sanitize */);
 
-  // For single-app folders (which can exist for system-managed folders, see
-  // crbug.com/925052) there will not be a "last item" so we can ignore the
-  // rest.
-  if (!source_folder || source_folder->item_list()->item_count() != 1)
-    return;
-
   // Now make the data change to remove the folder item in model.
   AppListItem* last_item = source_folder->item_list()->item_at(0);
   model_->MoveItemToFolderAt(last_item, "", source_folder->position());
@@ -2244,7 +2165,7 @@
   AppListItemView* last_item_view = CreateViewForItemAtIndex(last_item_index);
   last_item_view->SetBoundsRect(folder_rect);
   view_model_.Add(last_item_view, target_model_index);
-  if (!folder_delegate_)
+  if (IsAppsGridGapEnabled())
     view_structure_.Add(last_item_view, target_index);
   AddChildViewAt(last_item_view, target_model_index);
 }
@@ -2263,7 +2184,7 @@
 void AppsGridView::DeleteItemViewAtIndex(int index, bool sanitize) {
   AppListItemView* item_view = GetItemViewAt(index);
   view_model_.Remove(index);
-  if (!folder_delegate_) {
+  if (IsAppsGridGapEnabled()) {
     view_structure_.Remove(item_view, sanitize /* clear_overflow */,
                            sanitize /* clear_empty_pages */);
   }
@@ -2308,12 +2229,6 @@
   if (strcmp(sender->GetClassName(), AppListItemView::kViewClassName))
     return;
 
-  if (contents_view_->GetAppsContainerView()
-          ->app_list_folder_view()
-          ->IsAnimationRunning()) {
-    return;
-  }
-
   // Always set the previous activated_folder_item_view_ to be visible. This
   // prevents a case where the item would remain hidden due the
   // |activated_folder_item_view_| changing during the animation. We only
@@ -2346,7 +2261,7 @@
     view->SetVisible(model_->state_fullscreen() != AppListViewState::PEEKING);
   }
 
-  if (!folder_delegate_)
+  if (IsAppsGridGapEnabled())
     view_structure_.LoadFromMetadata();
   UpdateColsAndRowsForFolder();
   UpdatePaging();
@@ -2361,7 +2276,7 @@
   if (!item->is_page_break())
     DeleteItemViewAtIndex(GetModelIndexOfItem(item), true /* sanitize */);
 
-  if (!folder_delegate_)
+  if (IsAppsGridGapEnabled())
     view_structure_.LoadFromMetadata();
   UpdateColsAndRowsForFolder();
   UpdatePaging();
@@ -2387,7 +2302,7 @@
     ReorderChildView(view_model_.view_at(to_model_index), to_model_index);
   }
 
-  if (!folder_delegate_)
+  if (IsAppsGridGapEnabled())
     view_structure_.LoadFromMetadata();
   UpdateColsAndRowsForFolder();
   UpdatePaging();
@@ -2415,9 +2330,6 @@
 }
 
 void AppsGridView::TransitionStarted() {
-  // Drag ends and animation starts.
-  presentation_time_recorder_.reset();
-
   CancelContextMenusOnCurrentPage();
   pagination_animation_start_frame_number_ =
       GetCompositorActivatedFrameCount(layer()->GetCompositor());
@@ -2446,31 +2358,10 @@
       !duration.is_zero()) {
     RecordPaginationAnimationSmoothness(
         end_frame_number - pagination_animation_start_frame_number_,
-        duration.InMilliseconds(), compositor->refresh_rate(), IsTabletMode());
-  }
-}
-
-void AppsGridView::ScrollStarted() {
-  DCHECK(!presentation_time_recorder_);
-
-  if (IsTabletMode()) {
-    presentation_time_recorder_ =
-        std::make_unique<ash::PresentationTimeHistogramRecorder>(
-            GetWidget()->GetCompositor(), kPageDragScrollInTabletHistogram,
-            kPageDragScrollInTabletMaxLatencyHistogram);
-  } else {
-    presentation_time_recorder_ =
-        std::make_unique<ash::PresentationTimeHistogramRecorder>(
-            GetWidget()->GetCompositor(), kPageDragScrollInClamshellHistogram,
-            kPageDragScrollInClamshellMaxLatencyHistogram);
+        duration.InMilliseconds(), compositor->refresh_rate());
   }
 }
 
-void AppsGridView::ScrollEnded() {
-  // Scroll can end without triggering state animation.
-  presentation_time_recorder_.reset();
-}
-
 void AppsGridView::OnAppListModelStatusChanged() {
   UpdatePulsingBlockViews();
   Layout();
@@ -2560,8 +2451,12 @@
   }
 }
 
+bool AppsGridView::IsAppsGridGapEnabled() const {
+  return !folder_delegate_ && is_apps_grid_gap_feature_enabled_;
+}
+
 GridIndex AppsGridView::GetIndexFromModelIndex(int model_index) const {
-  if (!folder_delegate_)
+  if (IsAppsGridGapEnabled())
     return view_structure_.GetIndexFromModelIndex(model_index);
 
   const int tiles_in_page0 = TilesPerPage(0);
@@ -2575,7 +2470,7 @@
 }
 
 int AppsGridView::GetModelIndexFromIndex(const GridIndex& index) const {
-  if (!folder_delegate_)
+  if (IsAppsGridGapEnabled())
     return view_structure_.GetModelIndexFromIndex(index);
 
   if (index.page == 0)
@@ -2585,7 +2480,7 @@
 }
 
 GridIndex AppsGridView::GetLastTargetIndex() const {
-  if (!folder_delegate_)
+  if (IsAppsGridGapEnabled())
     return view_structure_.GetLastTargetIndex();
 
   DCHECK_LT(0, view_model_.view_size());
@@ -2594,7 +2489,7 @@
 }
 
 GridIndex AppsGridView::GetLastTargetIndexOfPage(int page) const {
-  if (!folder_delegate_)
+  if (IsAppsGridGapEnabled())
     return view_structure_.GetLastTargetIndexOfPage(page);
 
   if (page == pagination_model_.total_pages() - 1)
@@ -2605,7 +2500,7 @@
 
 int AppsGridView::GetTargetModelIndexForMove(AppListItemView* moved_view,
                                              const GridIndex& index) const {
-  if (!folder_delegate_)
+  if (IsAppsGridGapEnabled())
     return view_structure_.GetTargetModelIndexForMove(moved_view, index);
 
   return GetModelIndexFromIndex(index);
@@ -2613,10 +2508,10 @@
 
 size_t AppsGridView::GetTargetItemIndexForMove(AppListItemView* moved_view,
                                                const GridIndex& index) const {
-  if (!folder_delegate_)
+  if (IsAppsGridGapEnabled())
     return view_structure_.GetTargetItemIndexForMove(moved_view, index);
 
-  // Model index is the same as item index for folder.
+  // Model index is the same as item index when apps grid gap is disabled.
   return GetModelIndexFromIndex(index);
 }
 
@@ -2627,7 +2522,7 @@
 }
 
 bool AppsGridView::IsValidReorderTargetIndex(const GridIndex& index) const {
-  if (!folder_delegate_)
+  if (IsAppsGridGapEnabled())
     return view_structure_.IsValidReorderTargetIndex(index);
 
   return IsValidIndex(index);
@@ -2640,12 +2535,12 @@
   // If the user wants to drag an app to the next new page and has not done so
   // during the dragging session, then it is the right target because a new page
   // will be created in OnPageFlipTimer().
-  return !folder_delegate_ && !extra_page_opened_ &&
+  return IsAppsGridGapEnabled() && !extra_page_opened_ &&
          pagination_model_.total_pages() == page;
 }
 
-void AppsGridView::CalculateIdealBounds() {
-  DCHECK(!folder_delegate_);
+void AppsGridView::CalculateIdealBoundsWithGridGap() {
+  DCHECK(IsAppsGridGapEnabled());
 
   // |view_structure_| should only be updated at the end of drag. So make a
   // copy of it and only change the copy for calculating the ideal bounds of
@@ -2697,18 +2592,6 @@
     pulsing_blocks_model_.set_ideal_bounds(i, tile_slot);
     ++pulsing_block_index.slot;
   }
-
-  // Ensure GhostImageView's transition during page change.
-  if (app_list_features::IsAppGridGhostEnabled()) {
-    if (current_ghost_view_) {
-      current_ghost_view_->SetTransitionOffset(
-          CalculateTransitionOffset(current_ghost_view_->page()));
-    }
-    if (last_ghost_view_) {
-      last_ghost_view_->SetTransitionOffset(
-          CalculateTransitionOffset(last_ghost_view_->page()));
-    }
-  }
 }
 
 int AppsGridView::GetModelIndexOfItem(const AppListItem* item) {
@@ -2721,7 +2604,7 @@
 }
 
 int AppsGridView::GetTargetModelIndexFromItemIndex(size_t item_index) {
-  if (folder_delegate_)
+  if (!IsAppsGridGapEnabled())
     return item_index;
 
   CHECK(item_index <= item_list_->item_count());
@@ -2740,7 +2623,7 @@
 
   // Calculate the number of pages that have empty slots.
   int page_count = 0;
-  if (!folder_delegate_) {
+  if (IsAppsGridGapEnabled()) {
     const auto& pages = view_structure_.pages();
     for (size_t i = 0; i < pages.size(); ++i) {
       if (static_cast<int>(pages[i].size()) < TilesPerPage(i))
@@ -2752,7 +2635,8 @@
       item_num -= TilesPerPage(i);
     }
 
-    // Only last page allows gaps if it is not full for folder.
+    // Only last page allows gaps if it is not full when apps grid gap is
+    // disabled.
     if (item_num != 0)
       page_count = 1;
   }
@@ -2784,7 +2668,7 @@
   if (page < 0 || page >= pagination_model_.total_pages())
     return 0;
 
-  if (!folder_delegate_)
+  if (IsAppsGridGapEnabled())
     return view_structure_.items_on_page(page);
 
   if (page < pagination_model_.total_pages() - 1)
@@ -2818,113 +2702,4 @@
   animation_view->TransformView();
 }
 
-void AppsGridView::MaybeCreateFolderDroppingAccessibilityEvent() {
-  if (drop_target_region_ != ON_ITEM || !DropTargetIsValidFolder() ||
-      IsFolderItem(drag_view_->item()) || folder_delegate_ ||
-      drop_target_ == last_folder_dropping_a11y_event_location_) {
-    return;
-  }
-
-  last_folder_dropping_a11y_event_location_ = drop_target_;
-  last_reorder_a11y_event_location_ = GridIndex();
-
-  AppListItemView* drop_view =
-      GetViewDisplayedAtSlotOnCurrentPage(drop_target_.slot);
-  DCHECK(drop_view);
-
-  // Set a11y name to announce possible move to folder or creation of folder.
-  auto* announcement_view =
-      contents_view_->app_list_view()->announcement_view();
-  announcement_view->GetViewAccessibility().OverrideName(
-      l10n_util::GetStringFUTF16(
-          IsFolderItem(drop_view->item())
-              ? IDS_APP_LIST_APP_DRAG_MOVE_TO_FOLDER_ACCESSIBILE_NAME
-              : IDS_APP_LIST_APP_DRAG_CREATE_FOLDER_ACCESSIBILE_NAME,
-          drag_view_->title()->text(), drop_view->title()->text()));
-  announcement_view->NotifyAccessibilityEvent(ax::mojom::Event::kAlert, true);
-}
-
-void AppsGridView::MaybeCreateReorderAccessibilityEvent() {
-  if (drop_target_region_ == ON_ITEM && !IsFolderItem(drag_view_->item()))
-    return;
-
-  // If app was dragged out of folder, no need to announce location for the
-  // now closed folder.
-  if (drag_out_of_folder_container_)
-    return;
-
-  // If drop_target is not set or was already reset, then return.
-  if (drop_target_ == GridIndex())
-    return;
-
-  // Don't create a11y event if |drop_target| has not changed.
-  if (last_reorder_a11y_event_location_ == drop_target_)
-    return;
-
-  last_folder_dropping_a11y_event_location_ = GridIndex();
-  last_reorder_a11y_event_location_ = drop_target_;
-
-  const int row_number =
-      ((drop_target_.slot - (drop_target_.slot % cols_)) / cols_) + 1;
-  const int col_number = (drop_target_.slot % cols_) + 1;
-
-  // Set accessible name to announce drop target location by row and column.
-  auto* announcement_view =
-      contents_view_->app_list_view()->announcement_view();
-  announcement_view->GetViewAccessibility().OverrideName(
-      l10n_util::GetStringFUTF16(
-          IDS_APP_LIST_APP_DRAG_LOCATION_ACCESSIBILE_NAME,
-          base::NumberToString16(drop_target_.page + 1),
-          base::NumberToString16(row_number),
-          base::NumberToString16(col_number)));
-  announcement_view->NotifyAccessibilityEvent(ax::mojom::Event::kAlert, true);
-}
-
-void AppsGridView::CreateGhostImageView() {
-  if (!app_list_features::IsAppGridGhostEnabled())
-    return;
-  if (!drag_view_)
-    return;
-
-  // OnReorderTimer() can trigger this function even when the
-  // |reorder_placeholder_| does not change, no need to set a new GhostImageView
-  // in this case.
-  if (reorder_placeholder_ == current_ghost_location_)
-    return;
-
-  // When the item is dragged outside the boundaries of the app grid, if the
-  // |reorder_placeholder_| moves to another page, then do not show a ghost.
-  if (pagination_model_.selected_page() != reorder_placeholder_.page) {
-    BeginHideCurrentGhostImageView();
-    return;
-  }
-
-  BeginHideCurrentGhostImageView();
-  current_ghost_location_ = reorder_placeholder_;
-
-  if (last_ghost_view_)
-    delete last_ghost_view_;
-
-  // Preserve |current_ghost_view_| while it fades out and instantiate a new
-  // GhostImageView that will fade in.
-  last_ghost_view_ = current_ghost_view_;
-
-  current_ghost_view_ = new GhostImageView(
-      drag_view_, IsFolderItem(drag_view_->item()) /* is_folder */,
-      folder_delegate_, GetExpectedTileBounds(reorder_placeholder_),
-      reorder_placeholder_.page);
-  AddChildView(current_ghost_view_);
-  current_ghost_view_->FadeIn();
-}
-
-void AppsGridView::BeginHideCurrentGhostImageView() {
-  if (!app_list_features::IsAppGridGhostEnabled())
-    return;
-
-  current_ghost_location_ = GridIndex();
-
-  if (current_ghost_view_)
-    current_ghost_view_->FadeOut();
-}
-
 }  // namespace app_list
--- a/ash/app_list/views/apps_grid_view.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/views/apps_grid_view.h	2019-05-17 18:53:08.088000000 +0300
@@ -49,7 +49,6 @@
 class ContentsView;
 class PaginationController;
 class PulsingBlockView;
-class GhostImageView;
 
 // Represents the index to an item view in the grid.
 struct GridIndex {
@@ -334,8 +333,7 @@
   // transition target page.
   const gfx::Vector2d CalculateTransitionOffset(int page_of_view) const;
 
-  // Calculates the item views' bounds for folder.
-  void CalculateIdealBoundsForFolder();
+  void CalculateIdealBounds();
   void AnimateToIdealBounds();
 
   // Invoked when the given |view|'s current bounds and target bounds are on
@@ -450,8 +448,6 @@
   void TransitionStarted() override;
   void TransitionChanged() override;
   void TransitionEnded() override;
-  void ScrollStarted() override;
-  void ScrollEnded() override;
 
   // Overridden from AppListModelObserver:
   void OnAppListModelStatusChanged() override;
@@ -527,6 +523,11 @@
   // Update number of columns and rows for apps within a folder.
   void UpdateColsAndRowsForFolder();
 
+  // Returns true if apps grid gap is enabled. If it is enabled, the user can
+  // drag an app to the next page without having to fill up the current
+  // page.
+  bool IsAppsGridGapEnabled() const;
+
   // Convert between the model index and the visual index. The model index
   // is the index of the item in AppListModel. The visual index is the Index
   // struct above with page/slot info of where to display the item.
@@ -560,8 +561,8 @@
   // Returns true if the page is the right target to flip to.
   bool IsValidPageFlipTarget(int page) const;
 
-  // Calculates the item views' bounds for non-folder.
-  void CalculateIdealBounds();
+  // Calculates the item views' bounds when apps grid gap is enabled.
+  void CalculateIdealBoundsWithGridGap();
 
   // Returns model index of the item view of the specified item.
   int GetModelIndexOfItem(const AppListItem* item);
@@ -593,20 +594,6 @@
                                     AppListItem* drag_item,
                                     const gfx::Rect& source_bounds);
 
-  // During an app drag, creates an a11y event to verbalize dropping onto a
-  // folder or creating a folder with two apps.
-  void MaybeCreateFolderDroppingAccessibilityEvent();
-
-  // During an app drag, creates an a11y event to verbalize drop target
-  // location.
-  void MaybeCreateReorderAccessibilityEvent();
-
-  // Creates a new GhostImageView at |reorder_placeholder_| and initializes
-  // |current_ghost_view_| and |last_ghost_view_|.
-  void CreateGhostImageView();
-
-  void BeginHideCurrentGhostImageView();
-
   AppListModel* model_ = nullptr;         // Owned by AppListView.
   AppListItemList* item_list_ = nullptr;  // Not owned.
 
@@ -713,33 +700,21 @@
   // The compositor frame number when animation starts.
   int pagination_animation_start_frame_number_;
 
-  // view structure used only for non-folder.
+  // view structure used when apps grid gap is enabled.
   PagedViewStructure view_structure_;
 
   // True if an extra page is opened after the user drags an app to the bottom
-  // of last page with intention to put it in a new page. This is only used for
-  // non-folder.
+  // of last page with intention to put it in a new page. This is only used when
+  // apps grid gap is enabled.
   bool extra_page_opened_ = false;
 
+  // True if the apps grid gap feature is enabled.
+  const bool is_apps_grid_gap_feature_enabled_;
+
   // Tile spacing between the tile views.
   int horizontal_tile_padding_ = 0;
   int vertical_tile_padding_ = 0;
 
-  // The drop location of the most recent reorder related accessibility event.
-  GridIndex last_reorder_a11y_event_location_;
-
-  // The location of the most recent foldering drag related accessibility event.
-  GridIndex last_folder_dropping_a11y_event_location_;
-
-  // The location when |current_ghost_view_| was shown.
-  GridIndex current_ghost_location_;
-
-  GhostImageView* current_ghost_view_ = nullptr;
-  GhostImageView* last_ghost_view_ = nullptr;
-
-  // Records the presentation time for apps grid dragging.
-  std::unique_ptr<ash::PresentationTimeRecorder> presentation_time_recorder_;
-
   DISALLOW_COPY_AND_ASSIGN(AppsGridView);
 };
 
--- a/ash/app_list/views/apps_grid_view_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/views/apps_grid_view_unittest.cc	2019-05-17 18:53:08.088000000 +0300
@@ -30,9 +30,9 @@
 #include "ash/app_list/views/suggestion_chip_container_view.h"
 #include "ash/app_list/views/test/apps_grid_view_test_api.h"
 #include "ash/public/cpp/app_list/app_list_config.h"
+#include "ash/public/cpp/app_list/app_list_constants.h"
 #include "ash/public/cpp/app_list/app_list_features.h"
 #include "ash/public/cpp/app_list/app_list_switches.h"
-#include "ash/public/cpp/presentation_time_recorder.h"
 #include "base/command_line.h"
 #include "base/compiler_specific.h"
 #include "base/macros.h"
@@ -48,7 +48,6 @@
 #include "ui/events/event_utils.h"
 #include "ui/keyboard/keyboard_controller.h"
 #include "ui/views/controls/label.h"
-#include "ui/views/controls/textfield/textfield.h"
 #include "ui/views/test/views_test_base.h"
 
 namespace app_list {
@@ -85,7 +84,7 @@
   void SelectedPageChanged(int old_selected, int new_selected) override {
     if (!selected_pages_.empty())
       selected_pages_ += ',';
-    selected_pages_ += base::NumberToString(new_selected);
+    selected_pages_ += base::IntToString(new_selected);
 
     if (wait_)
       ui_run_loop_->QuitWhenIdle();
@@ -142,24 +141,56 @@
   DISALLOW_COPY_AND_ASSIGN(TestSuggestedSearchResult);
 };
 
+struct TestParams {
+  bool is_rtl_enabled;
+  bool is_apps_grid_gap_enabled;
+};
+
+const TestParams kAppsGridViewTestParams[] = {
+    {false /* is_rtl_enabled */, false /* is_apps_grid_gap_enabled */},
+    {true, false},
+};
+
+const TestParams kAppsGridViewDragTestParams[] = {
+    {false /* is_rtl_enabled */, false /* is_apps_grid_gap_enabled */},
+    {true, false},
+    {false, true},
+    {true, true},
+};
+
+const TestParams kAppsGridGapTestParams[] = {
+    {false /* is_rtl_enabled */, true /* is_apps_grid_gap_enabled */},
+    {true, true},
+};
+
 }  // namespace
 
 class AppsGridViewTest : public views::ViewsTestBase,
-                         public testing::WithParamInterface<bool> {
+                         public testing::WithParamInterface<TestParams> {
  public:
   AppsGridViewTest() = default;
-  explicit AppsGridViewTest(bool create_as_tablet_mode)
-      : create_as_tablet_mode_(create_as_tablet_mode) {}
   ~AppsGridViewTest() override = default;
 
   // testing::Test overrides:
   void SetUp() override {
     AppListView::SetShortAnimationForTesting(true);
+    std::vector<base::Feature> enabled_features;
+    std::vector<base::Feature> disabled_features;
     if (testing::UnitTest::GetInstance()->current_test_info()->value_param()) {
-      is_rtl_ = GetParam();
+      is_rtl_ = GetParam().is_rtl_enabled;
       if (is_rtl_)
         base::i18n::SetICUDefaultLocale("he");
+
+      is_apps_grid_gap_enabled_ = GetParam().is_apps_grid_gap_enabled;
+    }
+    if (is_apps_grid_gap_enabled_) {
+      enabled_features.emplace_back(
+          app_list_features::kEnableAppsGridGapFeature);
+    } else {
+      disabled_features.emplace_back(
+          app_list_features::kEnableAppsGridGapFeature);
     }
+    scoped_feature_list_.InitWithFeatures(enabled_features, disabled_features);
     views::ViewsTestBase::SetUp();
     gfx::NativeView parent = GetContext();
     // Ensure that parent is big enough to show the full AppListView.
@@ -168,7 +199,6 @@
     app_list_view_ = new AppListView(delegate_.get());
     AppListView::InitParams params;
     params.parent = parent;
-    params.is_tablet_mode = create_as_tablet_mode_;
     app_list_view_->Initialize(params);
     contents_view_ = app_list_view_->app_list_main_view()->contents_view();
     apps_grid_view_ = contents_view_->GetAppsContainerView()->apps_grid_view();
@@ -189,12 +219,8 @@
     app_list_view_->Layout();
 
     test_api_ = std::make_unique<AppsGridViewTestApi>(apps_grid_view_);
-    ash::PresentationTimeRecorder::SetReportPresentationTimeImmediatelyForTest(
-        true);
   }
   void TearDown() override {
-    ash::PresentationTimeRecorder::SetReportPresentationTimeImmediatelyForTest(
-        false);
     app_list_view_->GetWidget()->Close();
     views::ViewsTestBase::TearDown();
     AppListView::SetShortAnimationForTesting(false);
@@ -293,7 +319,7 @@
   std::unique_ptr<AppsGridViewTestApi> test_api_;
   bool is_rtl_ = false;
   bool test_with_fullscreen_ = true;
-  bool create_as_tablet_mode_ = false;
+  bool is_apps_grid_gap_enabled_ = false;
 
  private:
   // Restores the locale to default when destructor is called.
@@ -302,10 +328,16 @@
   // Used by AppListFolderView::UpdatePreferredBounds.
   keyboard::KeyboardController keyboard_controller_;
 
+  base::test::ScopedFeatureList scoped_feature_list_;
+
   DISALLOW_COPY_AND_ASSIGN(AppsGridViewTest);
 };
 
-INSTANTIATE_TEST_SUITE_P(, AppsGridViewTest, testing::Bool());
+// Instantiate the Boolean which is used to toggle RTL in
+// the parameterized tests.
+INSTANTIATE_TEST_CASE_P(,
+                        AppsGridViewTest,
+                        testing::ValuesIn(kAppsGridViewTestParams));
 
 class TestAppsGridViewFolderDelegate : public AppsGridViewFolderDelegate {
  public:
@@ -453,8 +485,6 @@
 }
 
 TEST_P(AppsGridViewTest, ScrollSequenceHandledByAppListView) {
-  base::HistogramTester histogram_tester;
-
   model_->PopulateApps(GetTilesPerPage(0) + 1);
   EXPECT_EQ(2, GetPaginationModel()->total_pages());
 
@@ -468,9 +498,6 @@
       apps_grid_view_origin.x(), apps_grid_view_origin.y(), 0,
       base::TimeTicks(),
       ui::GestureEventDetails(ui::ET_GESTURE_SCROLL_UPDATE, 0, 10));
-  ui::GestureEvent scroll_end(apps_grid_view_origin.x(),
-                              apps_grid_view_origin.y(), 0, base::TimeTicks(),
-                              ui::GestureEventDetails(ui::ET_GESTURE_END));
 
   // Drag down on the app grid when on page 1, this should move the AppListView
   // and not move the AppsGridView.
@@ -480,8 +507,6 @@
   // Simulate redirecting the event to app list view through views hierarchy.
   app_list_view_->OnGestureEvent(&scroll_begin);
   EXPECT_TRUE(scroll_begin.handled());
-  histogram_tester.ExpectTotalCount(
-      "Apps.StateTransition.Drag.PresentationTime.ClamshellMode", 0);
 
   // The following scroll update events will be sent to the view that handled
   // the scroll begin event.
@@ -489,24 +514,10 @@
   EXPECT_TRUE(scroll_update.handled());
   ASSERT_TRUE(app_list_view_->is_in_drag());
   ASSERT_EQ(0, GetPaginationModel()->transition().progress);
-  histogram_tester.ExpectTotalCount(
-      "Apps.StateTransition.Drag.PresentationTime.ClamshellMode", 1);
-  histogram_tester.ExpectTotalCount(
-      "Apps.StateTransition.Drag.PresentationTime.MaxLatency.ClamshellMode", 0);
-
-  app_list_view_->OnGestureEvent(&scroll_end);
-  EXPECT_TRUE(scroll_end.handled());
-
-  histogram_tester.ExpectTotalCount(
-      "Apps.StateTransition.Drag.PresentationTime.ClamshellMode", 1);
-  histogram_tester.ExpectTotalCount(
-      "Apps.StateTransition.Drag.PresentationTime.MaxLatency.ClamshellMode", 1);
 }
 
 TEST_F(AppsGridViewTest,
        OnGestureEventScrollSequenceHandleByPaginationController) {
-  base::HistogramTester histogram_tester;
-
   model_->PopulateApps(GetTilesPerPage(0) + 1);
   EXPECT_EQ(2, GetPaginationModel()->total_pages());
 
@@ -520,42 +531,22 @@
       apps_grid_view_origin.x(), apps_grid_view_origin.y(), 0,
       base::TimeTicks(),
       ui::GestureEventDetails(ui::ET_GESTURE_SCROLL_UPDATE, 0, -10));
-  ui::GestureEvent scroll_end(
-      apps_grid_view_origin.x(), apps_grid_view_origin.y(), 0,
-      base::TimeTicks(), ui::GestureEventDetails(ui::ET_GESTURE_SCROLL_END));
 
   // Drag up on the app grid when on page 1, this should move the AppsGridView
   // but not the AppListView.
   apps_grid_view_->OnGestureEvent(&scroll_begin);
   EXPECT_TRUE(scroll_begin.handled());
-  histogram_tester.ExpectTotalCount(
-      "Apps.PaginationTransition.DragScroll.PresentationTime.ClamshellMode", 0);
-
   apps_grid_view_->OnGestureEvent(&scroll_update);
   EXPECT_TRUE(scroll_update.handled());
   ASSERT_FALSE(app_list_view_->is_in_drag());
   ASSERT_NE(0, GetPaginationModel()->transition().progress);
-  histogram_tester.ExpectTotalCount(
-      "Apps.PaginationTransition.DragScroll.PresentationTime.ClamshellMode", 1);
-  histogram_tester.ExpectTotalCount(
-      "Apps.PaginationTransition.DragScroll.PresentationTime.MaxLatency."
-      "ClamshellMode",
-      0);
-
-  apps_grid_view_->OnGestureEvent(&scroll_end);
-
-  histogram_tester.ExpectTotalCount(
-      "Apps.PaginationTransition.DragScroll.PresentationTime.MaxLatency."
-      "ClamshellMode",
-      1);
 }
 
 TEST_F(AppsGridViewTest, CloseFolderByClickingBackground) {
   AppsContainerView* apps_container_view =
       contents_view_->GetAppsContainerView();
 
-  const size_t kTotalItems =
-      AppListConfig::instance().max_folder_items_per_page();
+  const size_t kTotalItems = kMaxFolderItemsPerPage;
   model_->CreateAndPopulateFolderWithApps(kTotalItems);
   EXPECT_EQ(1u, model_->top_level_item_list()->item_count());
   EXPECT_EQ(AppListFolderItem::kItemType,
@@ -597,9 +588,7 @@
 }
 
 TEST_F(AppsGridViewTest, PageResetAfterOpenFolder) {
-  const size_t kTotalItems =
-      AppListConfig::instance().max_folder_pages() *
-      AppListConfig::instance().max_folder_items_per_page();
+  const size_t kTotalItems = kMaxFolderPages * kMaxFolderItemsPerPage;
   model_->CreateAndPopulateFolderWithApps(kTotalItems);
   EXPECT_EQ(1u, model_->top_level_item_list()->item_count());
   EXPECT_EQ(AppListFolderItem::kItemType,
@@ -665,8 +654,7 @@
 }
 
 TEST_P(AppsGridViewTest, ScrollDownShouldNotExitFolder) {
-  const size_t kTotalItems =
-      AppListConfig::instance().max_folder_items_per_page();
+  const size_t kTotalItems = kMaxFolderItemsPerPage;
   model_->CreateAndPopulateFolderWithApps(kTotalItems);
   EXPECT_EQ(1u, model_->top_level_item_list()->item_count());
   EXPECT_EQ(AppListFolderItem::kItemType,
@@ -723,7 +711,21 @@
   EXPECT_FALSE(apps_grid_view_->IsSelectedView(app));
 }
 
-TEST_P(AppsGridViewTest, MouseDragItemIntoFolder) {
+// Tests various dragging behaviors.
+class AppsGridViewDragTest : public AppsGridViewTest {
+ public:
+  AppsGridViewDragTest() = default;
+  ~AppsGridViewDragTest() override = default;
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(AppsGridViewDragTest);
+};
+
+INSTANTIATE_TEST_CASE_P(,
+                        AppsGridViewDragTest,
+                        testing::ValuesIn(kAppsGridViewDragTestParams));
+
+TEST_P(AppsGridViewDragTest, MouseDragItemIntoFolder) {
   size_t kTotalItems = 3;
   model_->PopulateApps(kTotalItems);
   EXPECT_EQ(model_->top_level_item_list()->item_count(), kTotalItems);
@@ -770,11 +772,9 @@
   test_api_->LayoutToIdealBounds();
 }
 
-TEST_P(AppsGridViewTest, MouseDragMaxItemsInFolder) {
+TEST_P(AppsGridViewDragTest, MouseDragMaxItemsInFolder) {
   // Create and add a folder with |kMaxFolderItemsFullscreen - 1| items.
-  const size_t kMaxItems =
-      AppListConfig::instance().max_folder_items_per_page() *
-      AppListConfig::instance().max_folder_pages();
+  const size_t kMaxItems = kMaxFolderItemsPerPage * kMaxFolderPages;
   const size_t kTotalItems = kMaxItems - 1;
   AppListFolderItem* folder_item =
       model_->CreateAndPopulateFolderWithApps(kTotalItems);
@@ -817,11 +817,9 @@
 
 // Check that moving items around doesn't allow a drop to happen into a full
 // folder.
-TEST_P(AppsGridViewTest, MouseDragMaxItemsInFolderWithMovement) {
+TEST_P(AppsGridViewDragTest, MouseDragMaxItemsInFolderWithMovement) {
   // Create and add a folder with |kMaxFolderItemsFullscreen| in it.
-  const size_t kMaxItems =
-      AppListConfig::instance().max_folder_items_per_page() *
-      AppListConfig::instance().max_folder_pages();
+  const size_t kMaxItems = kMaxFolderItemsPerPage * kMaxFolderPages;
   size_t kTotalItems = kMaxItems;
   model_->CreateAndPopulateFolderWithApps(kMaxItems);
   EXPECT_EQ(1u, model_->top_level_item_list()->item_count());
@@ -870,7 +868,7 @@
 }
 
 // Test reordering items via dragging.
-TEST_P(AppsGridViewTest, MouseDragItemReorder) {
+TEST_P(AppsGridViewDragTest, MouseDragItemReorder) {
   // The default layout is 5x4, populate 7 apps so that we have second row to
   // test dragging item to second row.
   model_->PopulateApps(7);
@@ -945,7 +943,7 @@
   TestAppListItemViewIndice();
 }
 
-TEST_P(AppsGridViewTest, MouseDragFolderReorder) {
+TEST_P(AppsGridViewDragTest, MouseDragFolderReorder) {
   size_t kTotalItems = 2;
   model_->CreateAndPopulateFolderWithApps(kTotalItems);
   model_->PopulateAppWithId(kTotalItems);
@@ -970,7 +968,7 @@
   TestAppListItemViewIndice();
 }
 
-TEST_P(AppsGridViewTest, MouseDragWithCancelDeleteAddItem) {
+TEST_P(AppsGridViewDragTest, MouseDragWithCancelDeleteAddItem) {
   size_t kTotalItems = 4;
   model_->PopulateApps(kTotalItems);
   EXPECT_EQ(model_->top_level_item_list()->item_count(), kTotalItems);
@@ -1003,7 +1001,7 @@
   test_api_->LayoutToIdealBounds();
 }
 
-TEST_P(AppsGridViewTest, MouseDragFlipPage) {
+TEST_P(AppsGridViewDragTest, MouseDragFlipPage) {
   apps_grid_view_->set_page_flip_delay_in_ms_for_testing(10);
   GetPaginationModel()->SetTransitionDurations(10, 10);
 
@@ -1028,10 +1026,15 @@
     page_flip_waiter.Wait();
   }
 
+  if (is_apps_grid_gap_enabled_) {
   // When apps grid gap is enabled, the user can drag an item to an extra page
   // created at the end.
   EXPECT_EQ("1,2,3", page_flip_waiter.selected_pages());
   EXPECT_EQ(3, GetPaginationModel()->selected_page());
+  } else {
+    EXPECT_EQ("1,2", page_flip_waiter.selected_pages());
+    EXPECT_EQ(2, GetPaginationModel()->selected_page());
+  }
 
   // Cancel drag and put the dragged view back to its ideal position so that
   // the next drag would pick it up.
@@ -1054,7 +1057,7 @@
   apps_grid_view_->EndDrag(true);
 }
 
-TEST_F(AppsGridViewTest, UpdateFolderBackgroundOnCancelDrag) {
+TEST_F(AppsGridViewDragTest, UpdateFolderBackgroundOnCancelDrag) {
   const int kTotalItems = 4;
   TestAppsGridViewFolderDelegate folder_delegate;
   apps_grid_view_->set_folder_delegate(&folder_delegate);
@@ -1072,87 +1075,6 @@
             model_->GetModelContent());
 }
 
-// Test focus change before and after dragging an item. (See
-// https://crbug.com/834682)
-TEST_F(AppsGridViewTest, FocusOfDraggedView) {
-  model_->PopulateApps(1);
-  contents_view_->GetAppsContainerView()->Layout();
-  auto* search_box = contents_view_->GetSearchBoxView()->search_box();
-  auto* item_view = apps_grid_view_->view_model()->view_at(0);
-  EXPECT_TRUE(search_box->HasFocus());
-  EXPECT_FALSE(item_view->HasFocus());
-
-  // Dragging the item towards its right.
-  const gfx::Point from = GetItemRectOnCurrentPageAt(0, 0).CenterPoint();
-  const gfx::Point to = GetItemRectOnCurrentPageAt(0, 1).CenterPoint();
-  SimulateDrag(AppsGridView::MOUSE, from, to);
-  EXPECT_FALSE(search_box->HasFocus());
-  EXPECT_TRUE(item_view->HasFocus());
-
-  apps_grid_view_->EndDrag(false);
-  EXPECT_FALSE(search_box->HasFocus());
-  EXPECT_TRUE(item_view->HasFocus());
-}
-
-class AppsGridViewTabletTest : public AppsGridViewTest {
- public:
-  AppsGridViewTabletTest() : AppsGridViewTest(/*is_in_tablet=*/true) {}
-  ~AppsGridViewTabletTest() override = default;
-
- private:
-  DISALLOW_COPY_AND_ASSIGN(AppsGridViewTabletTest);
-};
-
-TEST_P(AppsGridViewTabletTest, Basic) {
-  base::HistogramTester histogram_tester;
-
-  model_->PopulateApps(GetTilesPerPage(0) + 1);
-  EXPECT_EQ(2, GetPaginationModel()->total_pages());
-
-  gfx::Point apps_grid_view_origin =
-      apps_grid_view_->GetBoundsInScreen().origin();
-  ui::GestureEvent scroll_begin(
-      apps_grid_view_origin.x(), apps_grid_view_origin.y(), 0,
-      base::TimeTicks(),
-      ui::GestureEventDetails(ui::ET_GESTURE_SCROLL_BEGIN, 0, -1));
-  ui::GestureEvent scroll_update(
-      apps_grid_view_origin.x(), apps_grid_view_origin.y(), 0,
-      base::TimeTicks(),
-      ui::GestureEventDetails(ui::ET_GESTURE_SCROLL_UPDATE, 0, -10));
-  ui::GestureEvent scroll_end(
-      apps_grid_view_origin.x(), apps_grid_view_origin.y(), 0,
-      base::TimeTicks(), ui::GestureEventDetails(ui::ET_GESTURE_SCROLL_END));
-
-  // Drag up on the app grid when on page 1, this should move the AppsGridView
-  // but not the AppListView.
-  apps_grid_view_->OnGestureEvent(&scroll_begin);
-  EXPECT_TRUE(scroll_begin.handled());
-  histogram_tester.ExpectTotalCount(
-      "Apps.PaginationTransition.DragScroll.PresentationTime.TabletMode", 0);
-
-  apps_grid_view_->OnGestureEvent(&scroll_update);
-  EXPECT_TRUE(scroll_update.handled());
-  ASSERT_FALSE(app_list_view_->is_in_drag());
-  ASSERT_NE(0, GetPaginationModel()->transition().progress);
-  histogram_tester.ExpectTotalCount(
-      "Apps.PaginationTransition.DragScroll.PresentationTime.TabletMode", 1);
-  histogram_tester.ExpectTotalCount(
-      "Apps.PaginationTransition.DragScroll.PresentationTime.MaxLatency."
-      "TabletMode",
-      0);
-
-  apps_grid_view_->OnGestureEvent(&scroll_end);
-
-  histogram_tester.ExpectTotalCount(
-      "Apps.PaginationTransition.DragScroll.PresentationTime.TabletMode", 1);
-  histogram_tester.ExpectTotalCount(
-      "Apps.PaginationTransition.DragScroll.PresentationTime.MaxLatency."
-      "TabletMode",
-      1);
-}
-
-INSTANTIATE_TEST_SUITE_P(, AppsGridViewTabletTest, testing::Bool());
-
 // Test various dragging behaviors only allowed when apps grid gap (part of
 // home launcher feature) is enabled.
 class AppsGridGapTest : public AppsGridViewTest {
@@ -1162,6 +1084,8 @@
 
   // testing::Test overrides:
   void SetUp() override {
+    scoped_feature_list_.InitWithFeatures(
+        {app_list_features::kEnableAppsGridGapFeature}, {});
     AppsGridViewTest::SetUp();
     apps_grid_view_->set_page_flip_delay_in_ms_for_testing(10);
     GetPaginationModel()->SetTransitionDurations(10, 10);
@@ -1215,9 +1139,15 @@
   std::unique_ptr<PageFlipWaiter> page_flip_waiter_;
 
  private:
+  base::test::ScopedFeatureList scoped_feature_list_;
+
   DISALLOW_COPY_AND_ASSIGN(AppsGridGapTest);
 };
 
+INSTANTIATE_TEST_CASE_P(,
+                        AppsGridGapTest,
+                        testing::ValuesIn(kAppsGridGapTestParams));
+
 TEST_P(AppsGridGapTest, MoveAnItemToNewEmptyPage) {
   const int kApps = 2;
   model_->PopulateApps(kApps);
@@ -1403,7 +1333,7 @@
     EXPECT_EQ(view_model->view_at(i), test_api_->GetViewAtVisualIndex(
                                           i / GetTilesPerPage(0) /* page */,
                                           i % GetTilesPerPage(0) /* slot */));
-    EXPECT_EQ("Item " + base::NumberToString(i),
+    EXPECT_EQ("Item " + base::IntToString(i),
               view_model->view_at(i)->item()->id());
   }
 
@@ -1411,7 +1341,7 @@
   // two pages. It will only be added after user operations.
   std::string model_content = "Item 0";
   for (int i = 1; i < kApps; ++i)
-    model_content.append(",Item " + base::NumberToString(i));
+    model_content.append(",Item " + base::IntToString(i));
   EXPECT_EQ(model_content, model_->GetModelContent());
 
   // Drag the last item to the first item's left position in previous page.
@@ -1431,14 +1361,14 @@
     EXPECT_EQ(view_model->view_at(i), test_api_->GetViewAtVisualIndex(
                                           i / GetTilesPerPage(0) /* page */,
                                           i % GetTilesPerPage(0) /* slot */));
-    EXPECT_EQ("Item " + base::NumberToString((i + kApps - 1) % kApps),
+    EXPECT_EQ("Item " + base::IntToString((i + kApps - 1) % kApps),
               view_model->view_at(i)->item()->id());
   }
 
   // A "page break" item is added to split the pages.
-  model_content = "Item " + base::NumberToString(kApps - 1);
+  model_content = "Item " + base::IntToString(kApps - 1);
   for (int i = 1; i < kApps; ++i) {
-    model_content.append(",Item " + base::NumberToString(i - 1));
+    model_content.append(",Item " + base::IntToString(i - 1));
     if (i == GetTilesPerPage(0) - 1)
       model_content.append(",PageBreakItem");
   }
@@ -1458,15 +1388,15 @@
     EXPECT_EQ(view_model->view_at(i), test_api_->GetViewAtVisualIndex(
                                           i / GetTilesPerPage(0) /* page */,
                                           i % GetTilesPerPage(0) /* slot */));
-    EXPECT_EQ("Item " + base::NumberToString((i + kApps - 2) % kApps),
+    EXPECT_EQ("Item " + base::IntToString((i + kApps - 2) % kApps),
               view_model->view_at(i)->item()->id());
   }
 
   // A "page break" item still exists.
-  model_content = "Item " + base::NumberToString(kApps - 2) + ",Item " +
-                  base::NumberToString(kApps - 1);
+  model_content = "Item " + base::IntToString(kApps - 2) + ",Item " +
+                  base::IntToString(kApps - 1);
   for (int i = 2; i < kApps; ++i) {
-    model_content.append(",Item " + base::NumberToString(i - 2));
+    model_content.append(",Item " + base::IntToString(i - 2));
     if (i == GetTilesPerPage(0) - 1)
       model_content.append(",PageBreakItem");
   }
--- a/ash/app_list/views/contents_view.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/views/contents_view.cc	2019-05-17 18:53:08.088000000 +0300
@@ -13,7 +13,6 @@
 #include "ash/app_list/views/app_list_view.h"
 #include "ash/app_list/views/apps_container_view.h"
 #include "ash/app_list/views/apps_grid_view.h"
-#include "ash/app_list/views/assistant/assistant_page_view.h"
 #include "ash/app_list/views/expand_arrow_view.h"
 #include "ash/app_list/views/horizontal_page_container.h"
 #include "ash/app_list/views/search_box_view.h"
@@ -22,6 +21,7 @@
 #include "ash/app_list/views/search_result_page_view.h"
 #include "ash/app_list/views/search_result_tile_item_list_view.h"
 #include "ash/public/cpp/app_list/app_list_config.h"
+#include "ash/public/cpp/app_list/app_list_constants.h"
 #include "ash/public/cpp/app_list/app_list_features.h"
 #include "ash/public/cpp/app_list/app_list_switches.h"
 #include "base/logging.h"
@@ -58,9 +58,8 @@
 
 ContentsView::ContentsView(AppListView* app_list_view)
     : app_list_view_(app_list_view) {
-  pagination_model_.SetTransitionDurations(
-      AppListConfig::instance().page_transition_duration_ms(),
-      AppListConfig::instance().overscroll_page_transition_duration_ms());
+  pagination_model_.SetTransitionDurations(kPageTransitionDurationInMs,
+                                           kOverscrollPageTransitionDurationMs);
   pagination_model_.AddObserver(this);
 }
 
@@ -111,14 +110,6 @@
   AddLauncherPage(search_results_page_view_,
                   ash::AppListState::kStateSearchResults);
 
-  if (app_list_features::IsEmbeddedAssistantUIEnabled()) {
-    assistant_page_view_ =
-        new AssistantPageView(view_delegate->GetAssistantViewDelegate());
-    assistant_page_view_->SetVisible(false);
-    AddLauncherPage(assistant_page_view_,
-                    ash::AppListState::kStateEmbeddedAssistant);
-  }
-
   AddLauncherPage(horizontal_page_container_, ash::AppListState::kStateApps);
 
   int initial_page_index = GetPageIndexForState(ash::AppListState::kStateStart);
@@ -135,10 +126,6 @@
 
   pagination_model_.SelectPage(initial_page_index, false);
 
-  // Update suggestion chips after valid page is selected to prevent the update
-  // from being ignored.
-  GetAppsContainerView()->UpdateSuggestionChips();
-
   ActivePageChanged();
 }
 
@@ -168,10 +155,9 @@
   if (IsStateActive(state))
     return;
 
-  // The primary way to set the state to search or Assistant results should be
-  // via |ShowSearchResults| or |ShowEmbeddedAssistantUI|.
-  DCHECK(state != ash::AppListState::kStateSearchResults &&
-         state != ash::AppListState::kStateEmbeddedAssistant);
+  // The primary way to set the state to search results should be via
+  // |ShowSearchResults|
+  DCHECK(state != ash::AppListState::kStateSearchResults);
 
   SetActiveStateInternal(GetPageIndexForState(state), false, animate);
 }
@@ -219,12 +205,12 @@
 }
 
 void ContentsView::SetActiveStateInternal(int page_index,
-                                          bool show_search_or_assistant_results,
+                                          bool show_search_results,
                                           bool animate) {
   if (!GetPageView(page_index)->visible())
     return;
 
-  if (!show_search_or_assistant_results)
+  if (!show_search_results)
     page_before_search_ = page_index;
 
   app_list_pages_[GetActivePageIndex()]->OnWillBeHidden();
@@ -250,8 +236,6 @@
   GetAppListMainView()->model()->SetState(state);
 
   UpdateExpandArrowFocusBehavior(state);
-
-  UpdateSearchBoxVisibility(state);
 }
 
 void ContentsView::ShowSearchResults(bool show) {
@@ -270,32 +254,6 @@
   return IsStateActive(ash::AppListState::kStateSearchResults);
 }
 
-void ContentsView::ShowEmbeddedAssistantUI(bool show) {
-  const int assistant_page =
-      GetPageIndexForState(ash::AppListState::kStateEmbeddedAssistant);
-  DCHECK_GE(assistant_page, 0);
-
-  // Hide or Show results.
-  GetPageView(assistant_page)->SetVisible(show);
-  if (show)
-    GetPageView(assistant_page)->RequestFocus();
-
-  // Embedded Assistant UI can only be transitioned from/to
-  // |search_result_page_view_|.
-  const int search_results_page =
-      GetPageIndexForState(ash::AppListState::kStateSearchResults);
-  DCHECK_GE(search_results_page, 0);
-  GetPageView(search_results_page)->SetVisible(!show);
-  SetActiveStateInternal(show ? assistant_page : search_results_page,
-                         /*show_search_or_assistant_results=*/true,
-                         /*animate=*/false);
-  expand_arrow_view_->layer()->SetOpacity(0.0f);
-}
-
-bool ContentsView::IsShowingEmbeddedAssistantUI() const {
-  return IsStateActive(ash::AppListState::kStateEmbeddedAssistant);
-}
-
 void ContentsView::UpdatePageBounds() {
   // The bounds calculations will potentially be mid-transition (depending on
   // the state of the PaginationModel).
@@ -365,23 +324,26 @@
   gfx::Transform transform;
   transform.Scale(scale, scale);
   search_box->GetWidget()->GetNativeView()->SetTransform(transform);
-
-  for (auto& observer : search_box_observers_)
-    observer.OnSearchBoxBoundsUpdated();
 }
 
 void ContentsView::UpdateExpandArrowOpacity(double progress,
                                             ash::AppListState current_state,
                                             ash::AppListState target_state) {
-  if ((current_state == ash::AppListState::kStateSearchResults ||
-       current_state == ash::AppListState::kStateEmbeddedAssistant) &&
+  // Don't show |expand_arrow_view_| when the home launcher gestures are
+  // disabled in tablet mode.
+  if (app_list_view_->is_tablet_mode() &&
+      !app_list_features::IsHomeLauncherGesturesEnabled()) {
+    expand_arrow_view_->layer()->SetOpacity(0);
+    return;
+  }
+
+  if (current_state == ash::AppListState::kStateSearchResults &&
       (target_state == ash::AppListState::kStateStart ||
        target_state == ash::AppListState::kStateApps)) {
     // Fade in the expand arrow when search results page is opened.
     expand_arrow_view_->layer()->SetOpacity(
         gfx::Tween::FloatValueBetween(progress, 0, 1));
-  } else if ((target_state == ash::AppListState::kStateSearchResults ||
-              target_state == ash::AppListState::kStateEmbeddedAssistant) &&
+  } else if (target_state == ash::AppListState::kStateSearchResults &&
              (current_state == ash::AppListState::kStateStart ||
               current_state == ash::AppListState::kStateApps)) {
     // Fade out the expand arrow when search results page is closed.
@@ -403,21 +365,12 @@
                   : views::InkDropHostView::InkDropMode::OFF);
 
   // Allow ChromeVox to focus the expand arrow only when peeking launcher.
-  expand_arrow_view_->GetViewAccessibility().OverrideIsIgnored(!state_start);
+  expand_arrow_view_->GetViewAccessibility().OverrideIsIgnored(
+      state_start ? false : true);
   expand_arrow_view_->GetViewAccessibility().NotifyAccessibilityEvent(
       ax::mojom::Event::kTreeChanged);
 }
 
-void ContentsView::UpdateSearchBoxVisibility(ash::AppListState current_state) {
-  auto* search_box_widget = GetSearchBoxView()->GetWidget();
-  if (search_box_widget) {
-    // Hide search box widget in order to click on the embedded Assistant UI.
-    const bool show_search_box =
-        current_state != ash::AppListState::kStateEmbeddedAssistant;
-    show_search_box ? search_box_widget->Show() : search_box_widget->Hide();
-  }
-}
-
 PaginationModel* ContentsView::GetAppsPaginationModel() {
   return GetAppsContainerView()->apps_grid_view()->pagination_model();
 }
@@ -512,9 +464,7 @@
       GetSearchBoxView()->SetSearchBoxActive(false, ui::ET_UNKNOWN);
       ShowSearchResults(false);
       break;
-    case ash::AppListState::kStateEmbeddedAssistant:
-      ShowEmbeddedAssistantUI(false);
-      break;
+    case ash::AppListState::kStateCustomLauncherPageDeprecated:
     case ash::AppListState::kInvalidState:  // Falls through.
       NOTREACHED();
       break;
@@ -633,23 +583,6 @@
   return app_list_view_->app_list_main_view()->GetTransform().Scale2d().x();
 }
 
-void ContentsView::SetExpandArrowViewVisibility(bool show) {
-  if (expand_arrow_view_->visible() == show)
-    return;
-
-  expand_arrow_view_->SetVisible(show);
-}
-
-void ContentsView::AddSearchBoxUpdateObserver(
-    SearchBoxUpdateObserver* observer) {
-  search_box_observers_.AddObserver(observer);
-}
-
-void ContentsView::RemoveSearchBoxUpdateObserver(
-    SearchBoxUpdateObserver* observer) {
-  search_box_observers_.RemoveObserver(observer);
-}
-
 bool ContentsView::ShouldLayoutPage(AppListPage* page,
                                     ash::AppListState current_state,
                                     ash::AppListState target_state) const {
@@ -673,11 +606,6 @@
              target_state == ash::AppListState::kStateSearchResults));
   }
 
-  if (page == assistant_page_view_) {
-    return current_state == ash::AppListState::kStateEmbeddedAssistant ||
-           target_state == ash::AppListState::kStateEmbeddedAssistant;
-  }
-
   return false;
 }
 
--- a/ash/app_list/views/contents_view.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/views/contents_view.h	2019-05-17 18:53:08.088000000 +0300
@@ -17,8 +17,6 @@
 #include "ash/app_list/pagination_model_observer.h"
 #include "base/compiler_specific.h"
 #include "base/macros.h"
-#include "base/observer_list.h"
-#include "base/observer_list_types.h"
 #include "ui/views/view.h"
 #include "ui/views/view_model.h"
 
@@ -35,7 +33,6 @@
 class AppListMainView;
 class AppsContainerView;
 class AppsGridView;
-class AssistantPageView;
 class ExpandArrowView;
 class HorizontalPageContainer;
 class PaginationModel;
@@ -53,13 +50,6 @@
 class APP_LIST_EXPORT ContentsView : public views::View,
                                      public PaginationModelObserver {
  public:
-  // This class observes the search box Updates.
-  class SearchBoxUpdateObserver : public base::CheckedObserver {
-   public:
-    // Called when search box bounds is updated.
-    virtual void OnSearchBoxBoundsUpdated() = 0;
-  };
-
   explicit ContentsView(AppListView* app_list_view);
   ~ContentsView() override;
 
@@ -81,12 +71,6 @@
   void ShowSearchResults(bool show);
   bool IsShowingSearchResults() const;
 
-  // Shows/hides the Assistant page. Hiding the Assistant page will
-  // cause the app list to return to the page that was displayed before
-  // ShowSearchResults(true) was invoked.
-  void ShowEmbeddedAssistantUI(bool show);
-  bool IsShowingEmbeddedAssistantUI() const;
-
   void ShowFolderContent(AppListFolderItem* folder);
 
   // Sets the active launcher page and animates the pages into place.
@@ -187,18 +171,11 @@
   // is also applied to search box window.
   float GetAppListMainViewScale() const;
 
-  // Show/hide the expand arrow view button when contents view is in fullscreen
-  // and tablet mode is enabled.
-  void SetExpandArrowViewVisibility(bool show);
-
-  void AddSearchBoxUpdateObserver(SearchBoxUpdateObserver* observer);
-  void RemoveSearchBoxUpdateObserver(SearchBoxUpdateObserver* observer);
-
  private:
   // Sets the active launcher page, accounting for whether the change is for
   // search results.
   void SetActiveStateInternal(int page_index,
-                              bool show_search_or_assistant_results,
+                              bool show_search_results,
                               bool animate);
 
   // Invoked when active view is changed.
@@ -224,9 +201,6 @@
   // Updates the expand arrow's focus behavior based on the current state.
   void UpdateExpandArrowFocusBehavior(ash::AppListState current_state);
 
-  // Updates search box visibility based on the current state.
-  void UpdateSearchBoxVisibility(ash::AppListState current_state);
-
   // Adds |view| as a new page to the end of the list of launcher pages. The
   // view is inserted as a child of the ContentsView. There is no name
   // associated with the page. Returns the index of the new page.
@@ -255,7 +229,6 @@
   AppListModel* model_ = nullptr;
 
   // Sub-views of the ContentsView. All owned by the views hierarchy.
-  AssistantPageView* assistant_page_view_ = nullptr;
   HorizontalPageContainer* horizontal_page_container_ = nullptr;
   SearchResultPageView* search_results_page_view_ = nullptr;
   SearchResultAnswerCardView* search_result_answer_card_view_ = nullptr;
@@ -283,8 +256,6 @@
   // Manages the pagination for the launcher pages.
   PaginationModel pagination_model_;
 
-  base::ObserverList<SearchBoxUpdateObserver> search_box_observers_;
-
   DISALLOW_COPY_AND_ASSIGN(ContentsView);
 };
 
--- a/ash/app_list/views/expand_arrow_view.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/views/expand_arrow_view.cc	2019-05-17 18:53:08.088000000 +0300
@@ -11,6 +11,7 @@
 #include "ash/app_list/views/apps_container_view.h"
 #include "ash/app_list/views/contents_view.h"
 #include "ash/public/cpp/app_list/app_list_config.h"
+#include "ash/public/cpp/app_list/app_list_constants.h"
 #include "ash/public/cpp/app_list/vector_icons/vector_icons.h"
 #include "base/bind.h"
 #include "base/metrics/histogram_macros.h"
@@ -110,13 +111,9 @@
   animation_->SetSlideDuration(kCycleDurationInMs * 2 + kCycleIntervalInMs);
   ResetHintingAnimation();
   // When side shelf or tablet mode is enabled, the peeking launcher won't be
-  // shown, so the hint animation is unnecessary. Also, do not run the animation
-  // during test since we are not testing the animation and it might cause msan
-  // crash when spoken feedbacke is enabled (See https://crbug.com/926038).
-  if (!app_list_view_->is_side_shelf() && !app_list_view_->is_tablet_mode() &&
-      !AppListView::ShortAnimationsForTesting()) {
+  // shown, so the hint animation is unnecessary.
+  if (!app_list_view_->is_side_shelf() && !app_list_view_->is_tablet_mode())
     ScheduleHintingAnimation(true);
-  }
 }
 
 ExpandArrowView::~ExpandArrowView() = default;
--- a/ash/app_list/views/folder_header_view.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/views/folder_header_view.cc	2019-05-17 18:53:08.088000000 +0300
@@ -9,7 +9,7 @@
 #include "ash/app_list/app_list_util.h"
 #include "ash/app_list/model/app_list_folder_item.h"
 #include "ash/app_list/views/app_list_folder_view.h"
-#include "ash/public/cpp/app_list/app_list_config.h"
+#include "ash/public/cpp/app_list/app_list_constants.h"
 #include "ash/public/cpp/app_list/app_list_features.h"
 #include "ash/public/cpp/app_list/app_list_switches.h"
 #include "base/macros.h"
@@ -30,7 +30,6 @@
 
 constexpr int kMaxFolderNameWidth = 204;
 constexpr SkColor kFolderNameColor = SkColorSetARGB(138, 0, 0, 0);
-constexpr SkColor kFolderTitleHintTextColor = SkColorSetRGB(0xA0, 0xA0, 0xA0);
 
 }  // namespace
 
@@ -199,8 +198,7 @@
 base::string16 FolderHeaderView::GetElidedFolderName(
     const base::string16& folder_name) const {
   // Enforce the maximum folder name length.
-  base::string16 name =
-      folder_name.substr(0, AppListConfig::instance().max_folder_name_chars());
+  base::string16 name = folder_name.substr(0, kMaxFolderNameChars);
 
   // Get maximum text width for fitting into |folder_name_view_|.
   int text_width = GetMaxFolderNameWidth() -
@@ -243,8 +241,7 @@
 
   folder_item_->RemoveObserver(this);
   // Enforce the maximum folder name length in UI.
-  if (new_contents.length() >
-      AppListConfig::instance().max_folder_name_chars()) {
+  if (new_contents.length() > kMaxFolderNameChars) {
     folder_name_view_->SetText(previous_folder_name_.value());
     sender->SelectRange(gfx::Range(previous_cursor_position_.value(),
                                    previous_cursor_position_.value()));
@@ -268,7 +265,7 @@
     delegate_->NavigateBack(folder_item_, key_event);
     return true;
   }
-  if (!IsUnhandledLeftRightKeyEvent(key_event))
+  if (!CanProcessLeftRightKeyTraversal(key_event))
     return false;
   return ProcessLeftRightKeyTraversalForTextfield(folder_name_view_, key_event);
 }
--- a/ash/app_list/views/folder_header_view_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/views/folder_header_view_unittest.cc	2019-05-17 18:53:08.088000000 +0300
@@ -14,7 +14,7 @@
 #include "ash/app_list/model/app_list_model.h"
 #include "ash/app_list/test/app_list_test_model.h"
 #include "ash/app_list/views/folder_header_view_delegate.h"
-#include "ash/public/cpp/app_list/app_list_config.h"
+#include "ash/public/cpp/app_list/app_list_constants.h"
 #include "base/command_line.h"
 #include "base/compiler_specific.h"
 #include "base/macros.h"
@@ -67,7 +67,7 @@
     // Create a widget so that the FolderNameView can be focused.
     widget_ = std::make_unique<views::Widget>();
     views::Widget::InitParams params = views::ViewsTestBase::CreateParams(
-        views::Widget::InitParams::TYPE_WINDOW_FRAMELESS);
+        views::Widget::InitParams::TYPE_POPUP);
     params.ownership = views::Widget::InitParams::WIDGET_OWNS_NATIVE_WIDGET;
     params.bounds = gfx::Rect(0, 0, 650, 650);
     widget_->Init(params);
@@ -157,10 +157,8 @@
   // If folder name is set beyond the maximum char limit, it should revert to
   // the previous valid folder name.
   std::string max_len_name;
-  for (size_t i = 0; i < AppListConfig::instance().max_folder_name_chars();
-       ++i) {
+  for (size_t i = 0; i < kMaxFolderNameChars; ++i)
     max_len_name += "a";
-  }
   std::string too_long_name = max_len_name + "a";
   UpdatePreviousCursorPosition(0);
   UpdatePreviousFolderName(base::string16());
--- a/ash/app_list/views/horizontal_page_container.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/views/horizontal_page_container.cc	2019-05-17 18:53:08.088000000 +0300
@@ -10,7 +10,7 @@
 #include "ash/app_list/views/contents_view.h"
 #include "ash/app_list/views/search_box_view.h"
 #include "ash/app_list/views/search_result_page_view.h"
-#include "ash/public/cpp/app_list/app_list_config.h"
+#include "ash/public/cpp/app_list/app_list_constants.h"
 #include "base/strings/utf_string_conversions.h"
 #include "ui/chromeos/search_box/search_box_constants.h"
 #include "ui/views/controls/label.h"
@@ -20,9 +20,8 @@
 HorizontalPageContainer::HorizontalPageContainer(ContentsView* contents_view,
                                                  AppListModel* model)
     : contents_view_(contents_view) {
-  pagination_model_.SetTransitionDurations(
-      AppListConfig::instance().page_transition_duration_ms(),
-      AppListConfig::instance().overscroll_page_transition_duration_ms());
+  pagination_model_.SetTransitionDurations(kPageTransitionDurationInMs,
+                                           kOverscrollPageTransitionDurationMs);
   pagination_model_.AddObserver(this);
   pagination_controller_ = std::make_unique<PaginationController>(
       &pagination_model_, PaginationController::SCROLL_AXIS_HORIZONTAL);
--- a/ash/app_list/views/page_switcher.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/views/page_switcher.cc	2019-05-17 18:53:08.088000000 +0300
@@ -8,8 +8,8 @@
 #include <memory>
 #include <utility>
 
-#include "ash/app_list/app_list_metrics.h"
 #include "ash/app_list/pagination_model.h"
+#include "ash/public/cpp/app_list/app_list_constants.h"
 #include "base/i18n/number_formatting.h"
 #include "base/macros.h"
 #include "base/metrics/histogram_macros.h"
--- a/ash/app_list/views/remove_query_confirmation_dialog.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/views/remove_query_confirmation_dialog.cc	2019-05-17 18:53:08.088000000 +0300
@@ -4,7 +4,6 @@
 
 #include "ash/app_list/views/remove_query_confirmation_dialog.h"
 
-#include "ash/app_list/views/search_box_view.h"
 #include "ui/base/l10n/l10n_util.h"
 #include "ui/strings/grit/ui_strings.h"
 #include "ui/views/controls/label.h"
@@ -22,11 +21,9 @@
 
 RemoveQueryConfirmationDialog::RemoveQueryConfirmationDialog(
     RemovalConfirmationCallback confirm_callback,
-    int event_flags,
-    ContentsView* contents_view)
+    int event_flags)
     : confirm_callback_(std::move(confirm_callback)),
-      event_flags_(event_flags),
-      contents_view_(contents_view) {
+      event_flags_(event_flags) {
   const views::LayoutProvider* provider = views::LayoutProvider::Get();
   SetLayoutManager(std::make_unique<views::BoxLayout>(
       views::BoxLayout::kVertical,
@@ -39,18 +36,23 @@
   label->SetHorizontalAlignment(gfx::ALIGN_LEFT);
   label->SetAllowCharacterBreak(true);
   AddChildView(label);
-
-  contents_view_->AddSearchBoxUpdateObserver(this);
 }
 
-RemoveQueryConfirmationDialog::~RemoveQueryConfirmationDialog() {
-  contents_view_->RemoveSearchBoxUpdateObserver(this);
-}
+RemoveQueryConfirmationDialog::~RemoveQueryConfirmationDialog() {}
 
-void RemoveQueryConfirmationDialog::Show(gfx::NativeWindow parent) {
+void RemoveQueryConfirmationDialog::Show(gfx::NativeWindow parent,
+                                         const gfx::Rect& anchor_rect) {
   views::DialogDelegate::CreateDialogWidget(this, nullptr, parent);
-  UpdateBounds();
-  GetWidget()->Show();
+
+  views::Widget* widget = GetWidget();
+  DCHECK(widget);
+  gfx::Rect widget_rect = widget->GetWindowBoundsInScreen();
+  gfx::Point origin(anchor_rect.CenterPoint().x() - kDialogWidth / 2,
+                    anchor_rect.y() + kDialogYOffset);
+  widget_rect.set_origin(origin);
+  widget->SetBounds(widget_rect);
+
+  widget->Show();
 }
 
 base::string16 RemoveQueryConfirmationDialog::GetWindowTitle() const {
@@ -91,22 +93,4 @@
   return gfx::Size(default_width, GetHeightForWidth(default_width));
 }
 
-void RemoveQueryConfirmationDialog::OnSearchBoxBoundsUpdated() {
-  UpdateBounds();
-}
-
-void RemoveQueryConfirmationDialog::UpdateBounds() {
-  // Calculate confirmation dialog's origin in screen coordinates.
-  gfx::Rect anchor_rect =
-      contents_view_->GetSearchBoxView()->GetBoundsInScreen();
-  gfx::Point origin(anchor_rect.CenterPoint().x() - kDialogWidth / 2,
-                    anchor_rect.y() + kDialogYOffset);
-
-  views::Widget* widget = GetWidget();
-  DCHECK(widget);
-  gfx::Rect widget_rect = widget->GetWindowBoundsInScreen();
-  widget_rect.set_origin(origin);
-  widget->SetBounds(widget_rect);
-}
-
 }  // namespace app_list
--- a/ash/app_list/views/remove_query_confirmation_dialog.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/views/remove_query_confirmation_dialog.h	2019-05-17 18:53:08.088000000 +0300
@@ -5,7 +5,6 @@
 #ifndef ASH_APP_LIST_VIEWS_REMOVE_QUERY_CONFIRMATION_DIALOG_H_
 #define ASH_APP_LIST_VIEWS_REMOVE_QUERY_CONFIRMATION_DIALOG_H_
 
-#include "ash/app_list/views/contents_view.h"
 #include "base/callback.h"
 #include "ui/views/window/dialog_delegate.h"
 
@@ -13,9 +12,7 @@
 
 // RemoveQueryConfirmationDialog displays the confirmation dialog for removing
 // a recent query suggestion.
-class RemoveQueryConfirmationDialog
-    : public views::DialogDelegateView,
-      public ContentsView::SearchBoxUpdateObserver {
+class RemoveQueryConfirmationDialog : public views::DialogDelegateView {
  public:
   // Callback to notify user's confirmation for removing the zero state
   // suggestion query. Invoked with true if user confirms removing query
@@ -25,12 +22,11 @@
   using RemovalConfirmationCallback = base::OnceCallback<void(bool, int)>;
 
   RemoveQueryConfirmationDialog(RemovalConfirmationCallback callback,
-                                int event_flgas,
-                                ContentsView* contents_view);
+                                int event_flgas);
   ~RemoveQueryConfirmationDialog() override;
 
-  // Shows the dialog with |parent|.
-  void Show(gfx::NativeWindow parent);
+  // Shows the dialog with |parent| and |anchor_rect| in screen coordinates.
+  void Show(gfx::NativeWindow parent, const gfx::Rect& anchor_rect);
 
  private:
   // views::WidgetDelegate:
@@ -46,14 +42,8 @@
   // views::View:
   gfx::Size CalculatePreferredSize() const override;
 
-  // ContentsView::SearchBoxUpdateObserver
-  void OnSearchBoxBoundsUpdated() override;
-
-  void UpdateBounds();
-
   RemovalConfirmationCallback confirm_callback_;
   int event_flags_;
-  ContentsView* const contents_view_;  // Owned by the views hierarchy
 
   DISALLOW_COPY_AND_ASSIGN(RemoveQueryConfirmationDialog);
 };
--- a/ash/app_list/views/search_box_view.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/views/search_box_view.cc	2019-05-17 18:53:08.088000000 +0300
@@ -20,14 +20,13 @@
 #include "ash/app_list/views/search_result_base_view.h"
 #include "ash/app_list/views/search_result_page_view.h"
 #include "ash/public/cpp/app_list/app_list_config.h"
+#include "ash/public/cpp/app_list/app_list_constants.h"
 #include "ash/public/cpp/app_list/app_list_features.h"
 #include "ash/public/cpp/app_list/vector_icons/vector_icons.h"
 #include "ash/public/cpp/vector_icons/vector_icons.h"
 #include "ash/public/cpp/wallpaper_types.h"
-#include "base/bind.h"
 #include "base/macros.h"
 #include "base/metrics/histogram_macros.h"
-#include "base/metrics/user_metrics.h"
 #include "chromeos/constants/chromeos_switches.h"
 #include "ui/accessibility/ax_node_data.h"
 #include "ui/base/ime/composition_text.h"
@@ -204,10 +203,8 @@
                   gfx::CreateVectorIcon(views::kIcCloseIcon, kCloseIconSize,
                                         search_box_color()));
   close->SetVisible(false);
-  base::string16 close_button_label(
+  close->SetAccessibleName(
       l10n_util::GetStringUTF16(IDS_APP_LIST_CLEAR_SEARCHBOX));
-  close->SetAccessibleName(close_button_label);
-  close->SetTooltipText(close_button_label);
 }
 
 void SearchBoxView::SetupBackButton() {
@@ -247,28 +244,24 @@
 void SearchBoxView::OnKeyEvent(ui::KeyEvent* event) {
   app_list_view_->RedirectKeyEventToSearchBox(event);
 
-  if (!IsUnhandledUpDownKeyEvent(*event))
+  if (!CanProcessUpDownKeyTraversal(*event))
     return;
 
-  // Handles arrow key events from the search box while the search box is
-  // inactive. This covers both folder traversal and apps grid traversal. Search
-  // result traversal is handled in |HandleKeyEvent|
+  // If focus is in search box view, up key moves focus to the last element of
+  // contents view if new style launcher is not enabled while it moves focus to
+  // expand arrow if the feature is enabled. Down key moves focus to the first
+  // element of contents view.
   AppListPage* page =
       contents_view_->GetPageView(contents_view_->GetActivePageIndex());
   views::View* arrow_view = contents_view_->expand_arrow_view();
-  views::View* next_view = nullptr;
+  views::View* v = event->key_code() == ui::VKEY_UP
+                       ? (arrow_view && arrow_view->IsFocusable()
+                              ? arrow_view
+                              : page->GetLastFocusableView())
+                       : page->GetFirstFocusableView();
 
-  if (event->key_code() == ui::VKEY_UP) {
-    if (arrow_view && arrow_view->IsFocusable())
-      next_view = arrow_view;
-    else
-      next_view = page->GetLastFocusableView();
-  } else {
-    next_view = page->GetFirstFocusableView();
-  }
-
-  if (next_view)
-    next_view->RequestFocus();
+  if (v)
+    v->RequestFocus();
   event->SetHandled();
 }
 
@@ -327,8 +320,8 @@
 SkColor SearchBoxView::GetBackgroundColorForState(
     ash::AppListState state) const {
   if (state == ash::AppListState::kStateSearchResults)
-    return AppListConfig::instance().card_background_color();
-  return search_box::kSearchBoxBackgroundDefault;
+    return kCardBackgroundColor;
+  return background_color();
 }
 
 void SearchBoxView::UpdateOpacity() {
@@ -364,8 +357,6 @@
 }
 
 void SearchBoxView::ShowZeroStateSuggestions() {
-  base::RecordAction(
-      base::UserMetricsAction("AppList_ShowZeroStateSuggestions"));
   base::string16 empty_query;
   ContentsChanged(search_box(), empty_query);
 }
@@ -386,10 +377,12 @@
   // Current non-autocompleted text.
   const base::string16& user_typed_text =
       search_box()->text().substr(0, highlight_range_.start());
-  if (last_key_pressed_ == ui::VKEY_BACK ||
-      last_key_pressed_ == ui::VKEY_DELETE || !first_visible_result ||
+  if (last_key_pressed_ == ui::VKEY_BACK || last_key_pressed_ == ui::VKEY_UP ||
+      last_key_pressed_ == ui::VKEY_DOWN ||
+      last_key_pressed_ == ui::VKEY_LEFT ||
+      last_key_pressed_ == ui::VKEY_RIGHT || !first_visible_result ||
       user_typed_text.length() < kMinimumLengthToAutocomplete) {
-    // If the suggestion was rejected, no results exist, or current text
+    // Backspace or arrow keys were pressed, no results exist, or current text
     // is too short for a confident autocomplete suggestion.
     return;
   }
@@ -434,7 +427,7 @@
       gfx::CreateVectorIcon(views::kIcCloseIcon, kCloseIconSize,
                             search_box_color()));
   search_box()->set_placeholder_text_color(search_box_color());
-  UpdateBackgroundColor(search_box::kSearchBoxBackgroundDefault);
+  UpdateBackgroundColor(background_color());
   SchedulePaint();
 }
 
@@ -512,11 +505,6 @@
   search_box()->SetCompositionText(composition_text);
   search_box()->set_controller(this);
 
-  // The controller was null briefly, so it was unaware of a highlight change.
-  // As a result, we need to manually declare the range to allow for proper
-  // selection behavior.
-  search_box()->SelectRange(highlight_range_);
-
   // Send an event to alert ChromeVox that an autocomplete has occurred.
   // The |kValueChanged| type lets ChromeVox know that it should scan
   // |node_data| for "Value".
@@ -530,97 +518,48 @@
 
 bool SearchBoxView::HandleKeyEvent(views::Textfield* sender,
                                    const ui::KeyEvent& key_event) {
+  if (search_box()->HasFocus() && is_search_box_active() &&
+      !search_box()->text().empty() && ShouldProcessAutocomplete()) {
+    // If the search box has no text in it currently, autocomplete should not
+    // work.
+    last_key_pressed_ = key_event.key_code();
+    if (key_event.type() == ui::ET_KEY_PRESSED &&
+        key_event.key_code() != ui::VKEY_BACK) {
+      if (key_event.key_code() == ui::VKEY_TAB && HasAutocompleteText()) {
+        AcceptAutocompleteText();
+        return true;
+      } else if ((key_event.key_code() == ui::VKEY_UP ||
+                  key_event.key_code() == ui::VKEY_DOWN ||
+                  key_event.key_code() == ui::VKEY_LEFT ||
+                  key_event.key_code() == ui::VKEY_RIGHT) &&
+                 HasAutocompleteText()) {
+        ClearAutocompleteText();
+        return true;
+      }
+    }
+  }
   if (key_event.type() == ui::ET_KEY_PRESSED &&
       key_event.key_code() == ui::VKEY_RETURN) {
-    if (is_search_box_active()) {
+    if (!IsSearchBoxTrimmedQueryEmpty()) {
       // Hitting Enter when focus is on search box opens the first result.
       ui::KeyEvent event(key_event);
       views::View* first_result_view =
           contents_view_->search_results_page_view()->first_result_view();
       if (first_result_view)
         first_result_view->OnKeyEvent(&event);
-    } else {
-      SetSearchBoxActive(true, key_event.type());
-    }
     return true;
   }
 
-  // Events occurring over an inactive search box are handled elsewhere, with
-  // the exception of left/right arrow key events
   if (!is_search_box_active()) {
-    if (IsUnhandledLeftRightKeyEvent(key_event))
-      return ProcessLeftRightKeyTraversalForTextfield(search_box(), key_event);
-    else
-      return false;
+      SetSearchBoxActive(true, key_event.type());
+      return true;
   }
-
-  // Record the |last_key_pressed_| for autocomplete.
-  if (!search_box()->text().empty() && ShouldProcessAutocomplete())
-    last_key_pressed_ = key_event.key_code();
-
-  // Only arrow key events intended for traversal within search results should
-  // be handled from here.
-  if (!IsUnhandledArrowKeyEvent(key_event))
     return false;
-
-  SearchResultPageView* search_page =
-      contents_view_->search_results_page_view();
-
-  // Define forward/backward keys for traversal based on RTL settings
-  ui::KeyboardCode forward =
-      base::i18n::IsRTL() ? ui::VKEY_LEFT : ui::VKEY_RIGHT;
-  ui::KeyboardCode backward =
-      base::i18n::IsRTL() ? ui::VKEY_RIGHT : ui::VKEY_LEFT;
-
-  // Left/Right arrow keys are handled elsewhere, unless the first result is a
-  // tile, in which case right will be handled below.
-  // The focus traversal in the search box is based around the 'implicit focus'
-  // or whichever result is highlighted. As a result, we are trying to move
-  // the actual focus based on the position of this highlight.
-  // In addition to that, when there are tiles we want to allow a left/right
-  // traversal among the tiles. When there are no tiles, left/right should be
-  // handled in the ordinary way that a textfield would handle it.
-  if (key_event.key_code() == backward ||
-      (key_event.key_code() == forward && !search_page->IsFirstResultTile())) {
-    return ProcessLeftRightKeyTraversalForTextfield(search_box(), key_event);
   }
 
-  // Right arrow key should not be handled if the cursor is within text.
-  if (key_event.key_code() == forward &&
-      !LeftRightKeyEventShouldExitText(search_box(), key_event)) {
+  if (CanProcessLeftRightKeyTraversal(key_event))
+    return ProcessLeftRightKeyTraversalForTextfield(search_box(), key_event);
     return false;
-  }
-
-  views::View* result_view = nullptr;
-
-  // The up arrow will loop focus to the last result.
-  // The down and right arrows will be treated the same, moving focus along to
-  // the 'next' result. If a result is highlighted, we treat that result as
-  // though it already had focus.
-  if (key_event.key_code() == ui::VKEY_UP) {
-    result_view = search_page->GetLastFocusableView();
-  } else if (search_page->IsFirstResultHighlighted()) {
-    result_view = search_page->GetFirstFocusableView();
-
-    // Give the parent container a chance to handle the event. This lets the
-    // down arrow escape the tile result container.
-    if (!result_view->parent()->OnKeyPressed(key_event)) {
-      // If the parent container doesn't handle |key_event|, get the next
-      // focusable view.
-      result_view = result_view->GetFocusManager()->GetNextFocusableView(
-          result_view, result_view->GetWidget(), false, false);
-    } else {
-      // Return early if the parent container handled the event.
-      return true;
-    }
-  } else {
-    result_view = search_page->GetFirstFocusableView();
-  }
-
-  if (result_view)
-    result_view->RequestFocus();
-
-  return true;
 }
 
 bool SearchBoxView::HandleMouseEvent(views::Textfield* sender,
@@ -702,10 +641,8 @@
   views::ImageButton* assistant = assistant_button();
   assistant->SetImage(
       views::ImageButton::STATE_NORMAL,
-      gfx::CreateVectorIcon(app_list_features::IsEmbeddedAssistantUIEnabled()
-                                ? ash::kAssistantMicIcon
-                                : ash::kAssistantIcon,
-                            kAssistantIconSize, search_box_color()));
+      gfx::CreateVectorIcon(ash::kAssistantIcon, kAssistantIconSize,
+                            search_box_color()));
   assistant->SetAccessibleName(
       l10n_util::GetStringUTF16(IDS_APP_LIST_START_ASSISTANT));
 }
--- a/ash/app_list/views/search_box_view_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/views/search_box_view_unittest.cc	2019-05-17 18:53:08.088000000 +0300
@@ -469,7 +469,7 @@
   DISALLOW_COPY_AND_ASSIGN(SearchBoxViewAutocompleteTest);
 };
 
-INSTANTIATE_TEST_SUITE_P(,
+INSTANTIATE_TEST_CASE_P(,
                          SearchBoxViewAutocompleteTest,
                          ::testing::Values(ui::VKEY_LEFT,
                                            ui::VKEY_RIGHT,
@@ -614,6 +614,14 @@
       true);
 }
 
+// Tests that only the autocomplete suggestion text is deleted after pressing
+// up, down, left, right, or backspace.
+TEST_P(SearchBoxViewAutocompleteTest,
+       SearchBoxDeletesAutocompleteTextOnlyAfterUpDownLeftRightBackspace) {
+  TestKeyEvent(ui::KeyEvent(ui::ET_KEY_PRESSED, key_code(), ui::EF_NONE),
+               false);
+}
+
 // Tests that autocomplete is not handled if IME is using composition text.
 TEST_F(SearchBoxViewAutocompleteTest, SearchBoxAutocompletesNotHandledForIME) {
   // Add a search result with a non-empty title field.
--- a/ash/app_list/views/search_result_actions_view.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/views/search_result_actions_view.cc	2019-05-17 18:53:08.088000000 +0300
@@ -11,12 +11,10 @@
 
 #include "ash/app_list/views/search_result_actions_view_delegate.h"
 #include "ash/app_list/views/search_result_view.h"
-#include "ash/public/cpp/app_list/app_list_config.h"
 #include "ui/base/resource/resource_bundle.h"
 #include "ui/gfx/canvas.h"
 #include "ui/gfx/color_palette.h"
 #include "ui/gfx/geometry/insets.h"
-#include "ui/gfx/image/image_skia_operations.h"
 #include "ui/views/animation/flood_fill_ink_drop_ripple.h"
 #include "ui/views/animation/ink_drop_impl.h"
 #include "ui/views/animation/ink_drop_mask.h"
@@ -70,8 +68,6 @@
   // views::View overrides:
   void OnPaintBackground(gfx::Canvas* canvas) override;
 
-  void SetButtonImage(const gfx::ImageSkia& source, int icon_dimension);
-
   int GetInkDropRadius() const;
   const char* GetClassName() const override;
 
@@ -97,22 +93,15 @@
   SetPreferredSize({kImageButtonSizeDip, kImageButtonSizeDip});
   SetImageAlignment(HorizontalAlignment::ALIGN_CENTER,
                     VerticalAlignment::ALIGN_MIDDLE);
-
-  SetButtonImage(action.image,
-                 AppListConfig::instance().search_list_icon_dimension());
-
+  SetImage(views::ImageButton::STATE_NORMAL, &action.image);
   SetAccessibleName(action.tooltip_text);
 
-  SetTooltipText(action.tooltip_text);
-
   SetVisible(!visible_on_hover_);
 }
 
 void SearchResultImageButton::OnFocus() {
   parent_->ActionButtonStateChanged();
   SchedulePaint();
-  if (visible())
-    NotifyAccessibilityEvent(ax::mojom::Event::kFocus, true);
 }
 
 void SearchResultImageButton::OnBlur() {
@@ -203,14 +192,6 @@
   }
 }
 
-void SearchResultImageButton::SetButtonImage(const gfx::ImageSkia& source,
-                                             int icon_dimension) {
-  SetImage(views::ImageButton::STATE_NORMAL,
-           gfx::ImageSkiaOperations::CreateResizedImage(
-               source, skia::ImageOperations::RESIZE_BEST,
-               gfx::Size(icon_dimension, icon_dimension)));
-}
-
 int SearchResultImageButton::GetInkDropRadius() const {
   return width() / 2;
 }
--- a/ash/app_list/views/search_result_answer_card_view.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/views/search_result_answer_card_view.cc	2019-05-17 18:53:08.088000000 +0300
@@ -12,6 +12,7 @@
 #include "ash/app_list/app_list_view_delegate.h"
 #include "ash/app_list/views/app_list_view.h"
 #include "ash/app_list/views/search_result_base_view.h"
+#include "ash/public/cpp/app_list/app_list_constants.h"
 #include "base/bind.h"
 #include "base/metrics/histogram_macros.h"
 #include "base/metrics/user_metrics.h"
@@ -28,9 +29,9 @@
 #include "ui/accessibility/ax_node.h"
 #include "ui/accessibility/ax_node_data.h"
 #include "ui/aura/window.h"
-#include "ui/base/ui_base_features.h"
 #include "ui/gfx/canvas.h"
 #include "ui/views/background.h"
+#include "ui/views/layout/box_layout.h"
 #include "ui/views/layout/fill_layout.h"
 
 namespace app_list {
@@ -41,10 +42,6 @@
 constexpr char kSearchAnswerIssuedQuery[] = "SearchAnswer-IssuedQuery";
 constexpr char kSearchAnswerTitle[] = "SearchAnswer-Title";
 
-// Selection color for answer card (3% black).
-constexpr SkColor kAnswerCardSelectedColor =
-    SkColorSetARGB(0x08, 0x00, 0x00, 0x00);
-
 // Exclude the card native view from event handling.
 void ExcludeCardFromEventHandling(gfx::NativeView card_native_view) {
   // |card_native_view| could be null in tests.
@@ -110,7 +107,13 @@
                        AppListViewDelegate* view_delegate)
       : container_(container), view_delegate_(view_delegate) {
     SetFocusBehavior(FocusBehavior::ALWAYS);
-    SetLayoutManager(std::make_unique<views::FillLayout>());
+    // Center the card horizontally in the container. Padding is set on the
+    // server.
+    auto answer_container_layout =
+        std::make_unique<views::BoxLayout>(views::BoxLayout::kHorizontal);
+    answer_container_layout->set_main_axis_alignment(
+        views::BoxLayout::MAIN_AXIS_ALIGNMENT_START);
+    SetLayoutManager(std::move(answer_container_layout));
 
     view_delegate_->GetNavigableContentsFactory(
         mojo::MakeRequest(&contents_factory_));
@@ -122,8 +125,6 @@
     params->background_color = SK_ColorTRANSPARENT;
     contents_ = std::make_unique<content::NavigableContents>(
         contents_factory_.get(), std::move(params));
-    if (features::IsUsingWindowService())
-      contents_->ForceUseWindowService();
     contents_->AddObserver(this);
   }
 
@@ -193,6 +194,7 @@
 
   void OnFocus() override {
     ScrollRectToVisible(GetLocalBounds());
+    NotifyAccessibilityEvent(ax::mojom::Event::kSelection, true);
     SetBackgroundHighlighted(true);
   }
 
@@ -223,11 +225,7 @@
     if (result()) {
       RecordSearchResultOpenSource(result(), view_delegate_->GetModel(),
                                    view_delegate_->GetSearchModel());
-      view_delegate_->OpenSearchResult(
-          result()->id(), event.flags(),
-          ash::mojom::AppListLaunchedFrom::kLaunchedFromSearchBox,
-          ash::mojom::AppListLaunchType::kSearchResult,
-          -1 /* suggestion_index */);
+      view_delegate_->OpenSearchResult(result()->id(), event.flags());
     }
   }
 
@@ -321,15 +319,13 @@
 
 SearchResultAnswerCardView::SearchResultAnswerCardView(
     AppListViewDelegate* view_delegate)
-    : SearchResultContainerView(view_delegate),
-      search_answer_container_view_(
+    : search_answer_container_view_(
           new AnswerCardResultView(this, view_delegate)) {
   AddChildView(search_answer_container_view_);
-  AddObservedResultView(search_answer_container_view_);
   SetLayoutManager(std::make_unique<views::FillLayout>());
 }
 
-SearchResultAnswerCardView::~SearchResultAnswerCardView() = default;
+SearchResultAnswerCardView::~SearchResultAnswerCardView() {}
 
 const char* SearchResultAnswerCardView::GetClassName() const {
   return "SearchResultAnswerCardView";
--- a/ash/app_list/views/search_result_answer_card_view_unittest.cc	2019-05-17 17:45:36.484000000 +0300
+++ b/ash/app_list/views/search_result_answer_card_view_unittest.cc	2019-05-17 18:53:08.092000000 +0300
@@ -10,6 +10,7 @@
 #include "ash/app_list/test/app_list_test_view_delegate.h"
 #include "ash/app_list/test/test_search_result.h"
 #include "ash/app_list/views/search_result_view.h"
+#include "ash/public/cpp/app_list/app_list_constants.h"
 #include "base/macros.h"
 #include "base/strings/utf_string_conversions.h"
 #include "mojo/public/cpp/bindings/binding.h"
@@ -51,7 +52,7 @@
 
  protected:
   std::unique_ptr<TestSearchResult> CreateAnswerCardResult() {
-    const GURL kFakeQueryUrl = GURL("https://www.9oo91e.qjz9zk/coac?q=fake");
+    const GURL kFakeQueryUrl = GURL("https://www.google.com/coac?q=fake");
     auto result = std::make_unique<TestSearchResult>();
     result->set_display_type(ash::SearchResultDisplayType::kCard);
     result->set_title(base::UTF8ToUTF16(kResultTitle));
--- a/ash/app_list/views/search_result_base_view.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/views/search_result_base_view.cc	2019-05-17 18:53:08.092000000 +0300
@@ -7,9 +7,7 @@
 
 namespace app_list {
 
-SearchResultBaseView::SearchResultBaseView() : Button(this) {
-  SetInstallFocusRingOnFocus(false);
-}
+SearchResultBaseView::SearchResultBaseView() : Button(this) {}
 
 SearchResultBaseView::~SearchResultBaseView() = default;
 
--- a/ash/app_list/views/search_result_container_view.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/views/search_result_container_view.cc	2019-05-17 18:53:08.092000000 +0300
@@ -4,7 +4,6 @@
 
 #include "ash/app_list/views/search_result_container_view.h"
 
-#include "ash/app_list/views/search_result_base_view.h"
 #include "base/bind.h"
 #include "base/location.h"
 #include "base/single_thread_task_runner.h"
@@ -12,11 +11,7 @@
 
 namespace app_list {
 
-SearchResultContainerView::SearchResultContainerView(
-    AppListViewDelegate* view_delegate)
-    : view_delegate_(view_delegate) {
-  DCHECK(view_delegate);
-}
+SearchResultContainerView::SearchResultContainerView() = default;
 
 SearchResultContainerView::~SearchResultContainerView() {
   if (results_)
@@ -60,23 +55,6 @@
   return "SearchResultContainerView";
 }
 
-void SearchResultContainerView::OnViewFocused(View* observed_view) {
-  if (delegate_) {
-    delegate_->OnSearchResultContainerResultFocused(
-        static_cast<SearchResultBaseView*>(observed_view));
-  }
-}
-
-void SearchResultContainerView::AddObservedResultView(
-    SearchResultBaseView* result_view) {
-  result_view_observer_.Add(result_view);
-}
-
-void SearchResultContainerView::RemoveObservedResultView(
-    SearchResultBaseView* result_view) {
-  result_view_observer_.Remove(result_view);
-}
-
 void SearchResultContainerView::ListItemsAdded(size_t /*start*/,
                                                size_t /*count*/) {
   ScheduleUpdate();
@@ -101,16 +79,6 @@
   return nullptr;
 }
 
-void SearchResultContainerView::SetShown(bool shown) {
-  if (shown_ == shown) {
-    return;
-  }
-  shown_ = shown;
-  OnShownChanged();
-}
-
-void SearchResultContainerView::OnShownChanged() {}
-
 void SearchResultContainerView::ScheduleUpdate() {
   // When search results are added one by one, each addition generates an update
   // request. Consolidates those update requests into one Update call.
--- a/ash/app_list/views/search_result_container_view.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/views/search_result_container_view.h	2019-05-17 18:53:08.092000000 +0300
@@ -8,14 +8,11 @@
 #include <stddef.h>
 
 #include "ash/app_list/app_list_export.h"
-#include "ash/app_list/app_list_view_delegate.h"
 #include "ash/app_list/model/app_list_model.h"
 #include "ash/app_list/model/search/search_model.h"
 #include "base/macros.h"
 #include "base/memory/weak_ptr.h"
-#include "base/scoped_observer.h"
 #include "ui/views/view.h"
-#include "ui/views/view_observer.h"
 
 namespace app_list {
 
@@ -27,19 +24,13 @@
 // selected at a time; moving off the end of one container view selects the
 // first element of the next container view, and vice versa
 class APP_LIST_EXPORT SearchResultContainerView : public views::View,
-                                                  public views::ViewObserver,
                                                   public ui::ListModelObserver {
  public:
   class Delegate {
    public:
-    // Called whenever results in the container change, i.e. during |Update()|
     virtual void OnSearchResultContainerResultsChanged() = 0;
-
-    // Called whenever a result within the container gains focus.
-    virtual void OnSearchResultContainerResultFocused(
-        SearchResultBaseView* focused_result_view) = 0;
   };
-  explicit SearchResultContainerView(AppListViewDelegate* view_delegate);
+  SearchResultContainerView();
   ~SearchResultContainerView() override;
 
   void set_delegate(Delegate* delegate) { delegate_ = delegate; }
@@ -71,13 +62,6 @@
   // Overridden from views::View:
   const char* GetClassName() const override;
 
-  // Overridden from views::ViewObserver:
-  void OnViewFocused(View* observed_view) override;
-
-  // Functions to allow derivative classes to add/remove observed result views.
-  void AddObservedResultView(SearchResultBaseView* result_view);
-  void RemoveObservedResultView(SearchResultBaseView* result_view);
-
   // Overridden from ui::ListModelObserver:
   void ListItemsAdded(size_t start, size_t count) override;
   void ListItemsRemoved(size_t start, size_t count) override;
@@ -88,14 +72,6 @@
   // exist.
   virtual SearchResultBaseView* GetFirstResultView();
 
-  // Called from SearchResultPageView OnShown/OnHidden
-  void SetShown(bool shown);
-  bool shown() const { return shown_; }
-  // Called when SetShowing has changed a result.
-  virtual void OnShownChanged();
-
-  AppListViewDelegate* view_delegate() const { return view_delegate_; }
-
  private:
   // Schedules an Update call using |update_factory_|. Do nothing if there is a
   // pending call.
@@ -112,13 +88,6 @@
 
   SearchModel::SearchResults* results_ = nullptr;  // Owned by SearchModel.
 
-  // view delegate for notifications.
-  bool shown_ = false;
-  AppListViewDelegate* const view_delegate_;
-
-  ScopedObserver<SearchResultBaseView, ViewObserver> result_view_observer_{
-      this};
-
   // The factory that consolidates multiple Update calls into one.
   base::WeakPtrFactory<SearchResultContainerView> update_factory_{this};
 
--- a/ash/app_list/views/search_result_list_view.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/views/search_result_list_view.cc	2019-05-17 18:53:08.092000000 +0300
@@ -14,109 +14,25 @@
 #include "ash/app_list/views/app_list_main_view.h"
 #include "ash/app_list/views/search_box_view.h"
 #include "ash/app_list/views/search_result_view.h"
-#include "ash/public/cpp/app_list/app_list_config.h"
-#include "ash/public/cpp/app_list/app_list_features.h"
-#include "ash/public/cpp/app_list/vector_icons/vector_icons.h"
-#include "ash/public/cpp/vector_icons/vector_icons.h"
 #include "base/bind.h"
 #include "base/time/time.h"
 #include "ui/events/event.h"
 #include "ui/gfx/animation/linear_animation.h"
 #include "ui/gfx/geometry/insets.h"
-#include "ui/gfx/paint_vector_icon.h"
 #include "ui/views/background.h"
-#include "ui/views/controls/textfield/textfield.h"
 #include "ui/views/layout/box_layout.h"
 
-namespace app_list {
-
 namespace {
 
 constexpr int kMaxResults = 5;
 
-constexpr SkColor kListVerticalBarIconColor =
-    SkColorSetARGB(0xFF, 0xE8, 0xEA, 0xED);
-
-bool IsEmbeddedAssistantUiEnabled(AppListViewDelegate* view_delegate) {
-  if (!app_list_features::IsEmbeddedAssistantUIEnabled())
-    return false;
-
-  return view_delegate && view_delegate->IsAssistantAllowedAndEnabled();
-}
-
-// Get the vector icon to update previous Assistant item.
-const gfx::VectorIcon* GetPreviousVectorIcon(
-    int continuous_assistant_item_count) {
-  if (continuous_assistant_item_count == 2) {
-    return &kVerticalBarSingleIcon;
-  } else if (continuous_assistant_item_count > 2) {
-    return &kVerticalBarEndIcon;
-  }
-
-  NOTREACHED();
-  return nullptr;
-}
-
-// Get the vector icon to update current Assistant item.
-const gfx::VectorIcon* GetCurrentVectorIcon(
-    int continuous_assistant_item_count) {
-  if (continuous_assistant_item_count == 1) {
-    return &ash::kAssistantIcon;
-  } else if (continuous_assistant_item_count == 2) {
-    return &kVerticalBarStartIcon;
-  } else if (continuous_assistant_item_count > 2) {
-    return &kVerticalBarMiddleIcon;
-  }
-
-  NOTREACHED();
-  return nullptr;
-}
-
-// Calculate the display icons for Assistant items.
-// We have the following situations:
-// Number of consecutive Assistant items:
-// 1 item       -> Assistant icon.
-// 2 items      -> Assistant icon + single vertical bar icon.
-// 3 items      -> Assistant icon + start + end vertical bar icons.
-// n >= 4 items -> Assistant icon + start + middle (n - 3) + end vertical bar
-//                 icons.
-// This algo sets current result's vertical icon based on the
-// |continuous_assistant_item_count|, but also needs to update previous result's
-// vertical icon if current result is not an Assisttant item or previous result
-// is the last result.
-void CalculateDisplayIcons(
-    const std::vector<SearchResult*>& display_results,
-    std::vector<const gfx::VectorIcon*>* out_display_icons) {
-  const size_t display_size = display_results.size();
-  int continuous_assistant_item_count = 0;
-  // Index |i| goes beyond the last display result to update its icon.
-  for (size_t i = 0; i <= display_size; ++i) {
-    if (i < display_size && display_results[i]->is_omnibox_search()) {
-      ++continuous_assistant_item_count;
-    } else {
-      // Update previous result's icon.
-      if (continuous_assistant_item_count >= 2) {
-        (*out_display_icons)[i - 1] =
-            GetPreviousVectorIcon(continuous_assistant_item_count);
-      }
-
-      continuous_assistant_item_count = 0;
-    }
-
-    // Update current result's icon.
-    if (continuous_assistant_item_count > 0) {
-      (*out_display_icons)[i] =
-          GetCurrentVectorIcon(continuous_assistant_item_count);
-    }
-  }
-}
-
 }  // namespace
 
+namespace app_list {
+
 SearchResultListView::SearchResultListView(AppListMainView* main_view,
                                            AppListViewDelegate* view_delegate)
-    : SearchResultContainerView(view_delegate),
-      main_view_(main_view),
+    : main_view_(main_view),
       view_delegate_(view_delegate),
       results_container_(new views::View) {
   results_container_->SetLayoutManager(
@@ -125,9 +41,7 @@
   for (int i = 0; i < kMaxResults; ++i) {
     search_result_views_.emplace_back(
         new SearchResultView(this, view_delegate_));
-    search_result_views_.back()->set_index_in_search_result_list_view(i);
     results_container_->AddChildView(search_result_views_.back());
-    AddObservedResultView(search_result_views_.back());
   }
   AddChildView(results_container_);
 }
@@ -167,29 +81,11 @@
           results(), ash::SearchResultDisplayType::kList, /*excludes=*/{},
           results_container_->child_count());
 
-  const size_t display_size = display_results.size();
-  std::vector<const gfx::VectorIcon*> assistant_item_icons(display_size,
-                                                           nullptr);
-  if (IsEmbeddedAssistantUiEnabled(view_delegate_))
-    CalculateDisplayIcons(display_results, &assistant_item_icons);
-
   for (size_t i = 0; i < static_cast<size_t>(results_container_->child_count());
        ++i) {
     SearchResultView* result_view = GetResultViewAt(i);
-    result_view->set_is_last_result(i == display_size - 1);
+    result_view->set_is_last_result(i == display_results.size() - 1);
     if (i < display_results.size()) {
-      if (assistant_item_icons[i]) {
-        result_view->SetDisplayIcon(gfx::CreateVectorIcon(
-            *(assistant_item_icons[i]),
-            (assistant_item_icons[i] == &ash::kAssistantIcon)
-                ? AppListConfig::instance().search_list_icon_dimension()
-                : AppListConfig::instance()
-                      .search_list_icon_vertical_bar_dimension(),
-            kListVerticalBarIconColor));
-      } else {
-        // Reset |display_icon_|.
-        result_view->SetDisplayIcon(gfx::ImageSkia());
-      }
       result_view->SetResult(display_results[i]);
       result_view->SetVisible(true);
     } else {
@@ -225,14 +121,7 @@
   if (view_delegate_ && view->result()) {
     RecordSearchResultOpenSource(view->result(), view_delegate_->GetModel(),
                                  view_delegate_->GetSearchModel());
-    view_delegate_->LogResultLaunchHistogram(
-        SearchResultLaunchLocation::kResultList,
-        view->get_index_in_search_result_list_view());
-    view_delegate_->OpenSearchResult(
-        view->result()->id(), event_flags,
-        ash::mojom::AppListLaunchedFrom::kLaunchedFromSearchBox,
-        ash::mojom::AppListLaunchType::kSearchResult,
-        -1 /* suggestion_index */);
+    view_delegate_->OpenSearchResult(view->result()->id(), event_flags);
   }
 }
 
@@ -246,9 +135,6 @@
       view_delegate_->InvokeSearchResultAction(view->result()->id(),
                                                action_index, event_flags);
     } else if (action == ash::OmniBoxZeroStateAction::kAppendSuggestion) {
-      // Make sure ChromeVox will focus on the search box.
-      main_view_->search_box_view()->search_box()->NotifyAccessibilityEvent(
-          ax::mojom::Event::kSelection, true);
       main_view_->search_box_view()->UpdateQuery(view->result()->title());
     }
   }
@@ -259,39 +145,4 @@
     main_view_->OnResultInstalled(view->result());
 }
 
-bool SearchResultListView::HandleVerticalFocusMovement(SearchResultView* view,
-                                                       bool arrow_up) {
-  int view_index = -1;
-  for (int i = 0; i < num_results(); ++i) {
-    if (view == search_result_views_[i]) {
-      view_index = i;
-      break;
-    }
-  }
-
-  if (view_index == -1) {
-    // Not found in the result list.
-    NOTREACHED();
-    return false;
-  }
-
-  if (arrow_up) {  // VKEY_UP
-    if (view_index > 0) {
-      // Move to the previous result if the current one is not the first result.
-      search_result_views_[view_index - 1]->RequestFocus();
-      return true;
-    }
-  } else {  // VKEY_DOWN
-    // Move down to the next result if the currernt one is not the last result;
-    // otherwise, move focus to search box.
-    if (view_index == num_results() - 1)
-      main_view_->search_box_view()->search_box()->RequestFocus();
-    else
-      search_result_views_[view_index + 1]->RequestFocus();
-    return true;
-  }
-
-  return false;
-}
-
 }  // namespace app_list
--- a/ash/app_list/views/search_result_list_view.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/views/search_result_list_view.h	2019-05-17 18:53:08.092000000 +0300
@@ -41,9 +41,6 @@
 
   void OnSearchResultInstalled(SearchResultView* view);
 
-  // Handles vertical focus movement triggered by VKEY_UP/VKEY_DOWN.
-  bool HandleVerticalFocusMovement(SearchResultView* view, bool arrow_up);
-
   // Overridden from views::View:
   gfx::Size CalculatePreferredSize() const override;
   const char* GetClassName() const override;
--- a/ash/app_list/views/search_result_page_view.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/views/search_result_page_view.cc	2019-05-17 18:53:08.092000000 +0300
@@ -17,7 +17,7 @@
 #include "ash/app_list/views/search_result_base_view.h"
 #include "ash/app_list/views/search_result_list_view.h"
 #include "ash/app_list/views/search_result_tile_item_list_view.h"
-#include "ash/public/cpp/app_list/app_list_config.h"
+#include "ash/public/cpp/app_list/app_list_constants.h"
 #include "ui/chromeos/search_box/search_box_constants.h"
 #include "ui/gfx/canvas.h"
 #include "ui/gfx/color_palette.h"
@@ -168,8 +168,8 @@
   // background border corner radius. All child views' background should be
   // set transparent so that the rounded corner is not overwritten.
   SetBackground(std::make_unique<SearchResultPageBackground>(
-      AppListConfig::instance().card_background_color(),
-      search_box::kSearchBoxBorderCornerRadius, border()->GetInsets().top()));
+      kCardBackgroundColor, search_box::kSearchBoxBorderCornerRadius,
+      border()->GetInsets().top()));
   views::ScrollView* const scroller = new views::ScrollView;
   // Leaves a placeholder area for the search box and the separator below it.
   scroller->SetBorder(views::CreateEmptyBorder(
@@ -203,26 +203,9 @@
   result_container->set_delegate(this);
 }
 
-bool SearchResultPageView::IsFirstResultTile() const {
-  // In the event that the result does not exist, it is not a tile.
-  if (!first_result_view_ || !first_result_view_->result())
-    return false;
-
-  // |kRecommendation| result type refers to tiles in Zero State.
-  return first_result_view_->result()->display_type() ==
-             ash::SearchResultDisplayType::kTile ||
-         first_result_view_->result()->display_type() ==
-             ash::SearchResultDisplayType::kRecommendation;
-}
-
-bool SearchResultPageView::IsFirstResultHighlighted() const {
-  DCHECK(first_result_view_);
-  return first_result_view_->background_highlighted();
-}
-
 bool SearchResultPageView::OnKeyPressed(const ui::KeyEvent& event) {
   // Let the FocusManager handle Left/Right keys.
-  if (!IsUnhandledUpDownKeyEvent(event))
+  if (!CanProcessUpDownKeyTraversal(event))
     return false;
 
   views::View* next_focusable_view = nullptr;
@@ -334,34 +317,10 @@
   first_result_view_->SetBackgroundHighlighted(true);
 }
 
-void SearchResultPageView::OnSearchResultContainerResultFocused(
-    SearchResultBaseView* focused_result_view) {
-  views::Textfield* search_box =
-      AppListPage::contents_view()->GetSearchBoxView()->search_box();
-  if (focused_result_view->result()->result_type() ==
-          ash::SearchResultType::kOmnibox &&
-      !focused_result_view->result()->is_omnibox_search()) {
-    search_box->SetText(focused_result_view->result()->details());
-  } else {
-    search_box->SetText(focused_result_view->result()->title());
-  }
-}
-
 void SearchResultPageView::OnHidden() {
   // Hide the search results page when it is behind search box to avoid focus
   // being moved onto suggested apps when zero state is enabled.
-  AppListPage::OnHidden();
   SetVisible(false);
-  for (auto* container_view : result_container_views_) {
-    container_view->SetShown(false);
-  }
-}
-
-void SearchResultPageView::OnShown() {
-  AppListPage::OnShown();
-  for (auto* container_view : result_container_views_) {
-    container_view->SetShown(true);
-  }
 }
 
 gfx::Rect SearchResultPageView::GetPageBoundsForState(
--- a/ash/app_list/views/search_result_page_view.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/views/search_result_page_view.h	2019-05-17 18:53:08.092000000 +0300
@@ -34,9 +34,6 @@
     return result_container_views_;
   }
 
-  bool IsFirstResultTile() const;
-  bool IsFirstResultHighlighted() const;
-
   // Overridden from views::View:
   bool OnKeyPressed(const ui::KeyEvent& event) override;
   const char* GetClassName() const override;
@@ -44,8 +41,6 @@
 
   // AppListPage overrides:
   void OnHidden() override;
-  void OnShown() override;
-
   gfx::Rect GetPageBoundsForState(ash::AppListState state) const override;
   void OnAnimationUpdated(double progress,
                           ash::AppListState from_state,
@@ -56,8 +51,6 @@
 
   // Overridden from SearchResultContainerView::Delegate :
   void OnSearchResultContainerResultsChanged() override;
-  void OnSearchResultContainerResultFocused(
-      SearchResultBaseView* focused_result_view) override;
 
   views::View* contents_view() { return contents_view_; }
 
--- a/ash/app_list/views/search_result_page_view_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/views/search_result_page_view_unittest.cc	2019-05-17 18:53:08.092000000 +0300
@@ -120,7 +120,7 @@
 
 // Instantiate the Boolean which is used to toggle answer cards in
 // the parameterized tests.
-INSTANTIATE_TEST_SUITE_P(
+INSTANTIATE_TEST_CASE_P(
     ,
     SearchResultPageViewTest,
     ::testing::Values(AnswerCardState::ANSWER_CARD_OFF,
--- a/ash/app_list/views/search_result_suggestion_chip_view.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/views/search_result_suggestion_chip_view.cc	2019-05-17 18:53:08.092000000 +0300
@@ -9,8 +9,8 @@
 #include "ash/app_list/app_list_metrics.h"
 #include "ash/app_list/app_list_view_delegate.h"
 #include "ash/app_list/model/search/search_result.h"
+#include "ash/public/cpp/app_list/app_list_constants.h"
 #include "ash/public/cpp/app_list/internal_app_id_constants.h"
-#include "ash/public/interfaces/app_list.mojom.h"
 #include "base/metrics/histogram_functions.h"
 #include "base/metrics/histogram_macros.h"
 #include "base/metrics/user_metrics.h"
@@ -39,9 +39,6 @@
 SearchResultSuggestionChipView::SearchResultSuggestionChipView(
     AppListViewDelegate* view_delegate)
     : view_delegate_(view_delegate), weak_ptr_factory_(this) {
-  // Make it unfocusable to avoid violating accessibiliy rule since its child
-  // view |suggestion_chip_view_| is focusable.
-  SetFocusBehavior(FocusBehavior::NEVER);
   suggestion_chip_view_ = new SuggestionChipView(
       app_list::SuggestionChipView::Params(), /* listener */ this);
   AddChildView(suggestion_chip_view_);
@@ -71,11 +68,7 @@
   LogAppLaunch(index_in_suggestion_chip_container_);
   RecordSearchResultOpenSource(result(), view_delegate_->GetModel(),
                                view_delegate_->GetSearchModel());
-  view_delegate_->OpenSearchResult(
-      result()->id(), event.flags(),
-      ash::mojom::AppListLaunchedFrom::kLaunchedFromSuggestionChip,
-      ash::mojom::AppListLaunchType::kAppSearchResult,
-      index_in_suggestion_chip_container_);
+  view_delegate_->OpenSearchResult(result()->id(), event.flags());
 }
 
 void SearchResultSuggestionChipView::Layout() {
--- a/ash/app_list/views/search_result_tile_item_list_view.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/views/search_result_tile_item_list_view.cc	2019-05-17 18:53:08.092000000 +0300
@@ -6,23 +6,17 @@
 
 #include <stddef.h>
 
-#include <algorithm>
 #include <memory>
-#include <set>
-#include <string>
 
 #include "ash/app_list/app_list_util.h"
 #include "ash/app_list/app_list_view_delegate.h"
 #include "ash/app_list/model/search/search_result.h"
 #include "ash/app_list/views/search_result_page_view.h"
 #include "ash/app_list/views/search_result_tile_item_view.h"
-#include "ash/public/cpp/app_list/app_list_config.h"
+#include "ash/public/cpp/app_list/app_list_constants.h"
 #include "ash/public/cpp/app_list/app_list_features.h"
 #include "ash/public/cpp/app_list/internal_app_id_constants.h"
-#include "base/bind.h"
-#include "base/callback.h"
 #include "base/i18n/rtl.h"
-#include "base/stl_util.h"
 #include "ui/gfx/color_palette.h"
 #include "ui/gfx/geometry/insets.h"
 #include "ui/views/background.h"
@@ -53,26 +47,21 @@
     SearchResultPageView* search_result_page_view,
     views::Textfield* search_box,
     AppListViewDelegate* view_delegate)
-    : SearchResultContainerView(view_delegate),
-      search_result_page_view_(search_result_page_view),
+    : search_result_page_view_(search_result_page_view),
       search_box_(search_box),
       is_play_store_app_search_enabled_(
-          app_list_features::IsPlayStoreAppSearchEnabled()),
-      is_app_reinstall_recommendation_enabled_(
-          app_list_features::IsAppReinstallZeroStateEnabled()) {
+          app_list_features::IsPlayStoreAppSearchEnabled()) {
   SetLayoutManager(std::make_unique<views::BoxLayout>(
       views::BoxLayout::kHorizontal,
       gfx::Insets(kItemListVerticalSpacing, kItemListHorizontalSpacing),
       kBetweenItemSpacing));
   for (size_t i = 0; i < kMaxNumSearchResultTiles; ++i) {
-    if (is_app_reinstall_recommendation_enabled_ ||
-        is_play_store_app_search_enabled_) {
+    if (is_play_store_app_search_enabled_) {
       views::Separator* separator = new views::Separator;
       separator->SetVisible(false);
       separator->SetBorder(views::CreateEmptyBorder(
           kSeparatorTopPadding, kSeparatorLeftRightPadding,
-          AppListConfig::instance().search_tile_height() - kSeparatorHeight,
-          kSeparatorLeftRightPadding));
+          kSearchTileHeight - kSeparatorHeight, kSeparatorLeftRightPadding));
       separator->SetColor(kSeparatorColor);
 
       separator_views_.push_back(separator);
@@ -82,12 +71,9 @@
     SearchResultTileItemView* tile_item = new SearchResultTileItemView(
         view_delegate, nullptr /* pagination model */,
         false /* show_in_apps_page */);
-    tile_item->SetIndexInItemListView(i);
-    tile_item->SetParentBackgroundColor(
-        AppListConfig::instance().card_background_color());
+    tile_item->SetParentBackgroundColor(kCardBackgroundColor);
     tile_views_.push_back(tile_item);
     AddChildView(tile_item);
-    AddObservedResultView(tile_item);
   }
 }
 
@@ -108,27 +94,27 @@
 }
 
 int SearchResultTileItemListView::DoUpdate() {
-  std::vector<SearchResult*> display_results = GetDisplayResults();
+  base::string16 raw_query = search_box_->text();
+  base::string16 query;
+  base::TrimWhitespace(raw_query, base::TRIM_ALL, &query);
 
-  SearchResult::ResultType previous_type = ash::SearchResultType::kUnknown;
-  ash::SearchResultDisplayType previous_display_type =
-      ash::SearchResultDisplayType::kNone;
+  SearchResult::DisplayType display_type =
+      app_list_features::IsZeroStateSuggestionsEnabled()
+          ? (query.empty() ? ash::SearchResultDisplayType::kRecommendation
+                           : ash::SearchResultDisplayType::kTile)
+          : ash::SearchResultDisplayType::kTile;
+  // Do not display the continue reading app in the search result list.
+  std::vector<SearchResult*> display_results =
+      SearchModel::FilterSearchResultsByDisplayType(
+          results(), display_type,
+          /*excludes=*/{app_list::kInternalAppIdContinueReading},
+          kMaxNumSearchResultTiles);
 
-  std::set<std::string> result_id_removed, result_id_added;
+  SearchResult::ResultType previous_type = ash::SearchResultType::kUnknown;
   for (size_t i = 0; i < kMaxNumSearchResultTiles; ++i) {
-    // If the current result at i exists, wants to be notified and is a
-    // different id, notify it that it is being hidden.
-    SearchResult* current_result = tile_views_[i]->result();
-    if (current_result != nullptr) {
-      result_id_removed.insert(current_result->id());
-    }
-
     if (i >= display_results.size()) {
-      if (is_app_reinstall_recommendation_enabled_ ||
-          is_play_store_app_search_enabled_) {
+      if (is_play_store_app_search_enabled_)
         separator_views_[i]->SetVisible(false);
-      }
-
       tile_views_[i]->SetResult(nullptr);
       continue;
     }
@@ -134,14 +120,10 @@
     }
 
     SearchResult* item = display_results[i];
-
     tile_views_[i]->SetResult(item);
-    result_id_added.insert(item->id());
 
-    if (is_play_store_app_search_enabled_ ||
-        is_app_reinstall_recommendation_enabled_) {
-      if (i > 0 && (item->result_type() != previous_type ||
-                    item->display_type() != previous_display_type)) {
+    if (is_play_store_app_search_enabled_) {
+      if (i > 0 && item->result_type() != previous_type) {
         // Add a separator to separate search results of different types.
         // The strategy here is to only add a separator only if current search
         // result type is different from the previous one. The strategy is
@@ -154,34 +136,6 @@
     }
 
     previous_type = item->result_type();
-    previous_display_type = item->display_type();
-  }
-
-  // notify visibility changes, if needed.
-  std::set<std::string> actual_added_ids =
-      base::STLSetDifference<std::set<std::string>>(result_id_added,
-                                                    result_id_removed);
-
-  for (const std::string& added_id : actual_added_ids) {
-    SearchResult* added =
-        view_delegate()->GetSearchModel()->FindSearchResult(added_id);
-    if (added != nullptr && added->notify_visibility_change()) {
-      view_delegate()->OnSearchResultVisibilityChanged(added->id(), shown());
-    }
-  }
-  if (shown() != false) {
-    std::set<std::string> actual_removed_ids =
-        base::STLSetDifference<std::set<std::string>>(result_id_removed,
-                                                      result_id_added);
-    // we only notify removed items if we're in the middle of showing.
-    for (const std::string& removed_id : actual_removed_ids) {
-      SearchResult* removed =
-          view_delegate()->GetSearchModel()->FindSearchResult(removed_id);
-      if (removed != nullptr && removed->notify_visibility_change()) {
-        view_delegate()->OnSearchResultVisibilityChanged(removed->id(),
-                                                         false /*=shown*/);
-      }
-    }
   }
 
   set_container_score(
@@ -190,56 +144,9 @@
   return display_results.size();
 }
 
-std::vector<SearchResult*> SearchResultTileItemListView::GetDisplayResults() {
-  base::string16 raw_query = search_box_->text();
-  base::string16 query;
-  base::TrimWhitespace(raw_query, base::TRIM_ALL, &query);
-
-  // We ask for kMaxNumSearchResultTiles total results, and we prefer reinstall
-  // candidates if appropriate. we fetch |reinstall_results| first, and
-  // front-fill the rest from the regular result types.
-  auto reinstall_filter =
-      base::BindRepeating([](const SearchResult& r) -> bool {
-        return r.display_type() ==
-                   ash::SearchResultDisplayType::kRecommendation &&
-               r.result_type() == ash::SearchResultType::kPlayStoreReinstallApp;
-      });
-  std::vector<SearchResult*> reinstall_results =
-      is_app_reinstall_recommendation_enabled_ && query.empty()
-          ? SearchModel::FilterSearchResultsByFunction(
-                results(), reinstall_filter, kMaxNumSearchResultTiles)
-          : std::vector<SearchResult*>();
-
-  SearchResult::DisplayType display_type =
-      app_list_features::IsZeroStateSuggestionsEnabled()
-          ? (query.empty() ? ash::SearchResultDisplayType::kRecommendation
-                           : ash::SearchResultDisplayType::kTile)
-          : ash::SearchResultDisplayType::kTile;
-  size_t display_num = kMaxNumSearchResultTiles - reinstall_results.size();
-
-  // Do not display the continue reading app in the search result list.
-  auto non_reinstall_filter = base::BindRepeating(
-      [](const SearchResult::DisplayType& display_type,
-         const SearchResult& r) -> bool {
-        return r.display_type() == display_type &&
-               r.result_type() !=
-                   ash::SearchResultType::kPlayStoreReinstallApp &&
-               r.id() != app_list::kInternalAppIdContinueReading;
-      },
-      display_type);
-  std::vector<SearchResult*> display_results =
-      SearchModel::FilterSearchResultsByFunction(
-          results(), non_reinstall_filter, display_num);
-
-  // Append the reinstalls to the display results.
-  display_results.insert(display_results.end(), reinstall_results.begin(),
-                         reinstall_results.end());
-  return display_results;
-}
-
 bool SearchResultTileItemListView::OnKeyPressed(const ui::KeyEvent& event) {
   // Let the FocusManager handle Left/Right keys.
-  if (!IsUnhandledUpDownKeyEvent(event))
+  if (!CanProcessUpDownKeyTraversal(event))
     return false;
 
   views::View* next_focusable_view = nullptr;
@@ -276,37 +183,4 @@
   return "SearchResultTileItemListView";
 }
 
-void SearchResultTileItemListView::OnShownChanged() {
-  SearchResultContainerView::OnShownChanged();
-  for (const auto* tile_view : tile_views_) {
-    SearchResult* result = tile_view->result();
-    if (result == nullptr) {
-      continue;
-    }
-    if (result->notify_visibility_change()) {
-      view_delegate()->OnSearchResultVisibilityChanged(result->id(), shown());
-    }
-  }
-}
-
-void SearchResultTileItemListView::VisibilityChanged(View* starting_from,
-                                                     bool is_visible) {
-  SearchResultContainerView::VisibilityChanged(starting_from, is_visible);
-  // We only do this work when is_visible is false, since this is how we
-  // receive the event. We filter and only run when shown.
-  if (is_visible && shown()) {
-    return;
-  }
-  for (const auto* tile_view : tile_views_) {
-    SearchResult* result = tile_view->result();
-    if (result == nullptr) {
-      continue;
-    }
-    if (result->notify_visibility_change()) {
-      view_delegate()->OnSearchResultVisibilityChanged(result->id(),
-                                                       false /*=visible*/);
-    }
-  }
-}
-
 }  // namespace app_list
--- a/ash/app_list/views/search_result_tile_item_list_view.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/views/search_result_tile_item_list_view.h	2019-05-17 18:53:08.092000000 +0300
@@ -43,19 +43,10 @@
     return tile_views_;
   }
 
-  // Overridden from SearchResultContainerView:
-  void OnShownChanged() override;
-
- protected:
-  // View overrides:
-  void VisibilityChanged(View* starting_from, bool is_visible) override;
-
  private:
   // Overridden from SearchResultContainerView:
   int DoUpdate() override;
 
-  std::vector<SearchResult*> GetDisplayResults();
-
   std::vector<SearchResultTileItemView*> tile_views_;
 
   std::vector<views::Separator*> separator_views_;
@@ -66,8 +57,6 @@
 
   const bool is_play_store_app_search_enabled_;
 
-  const bool is_app_reinstall_recommendation_enabled_;
-
   DISALLOW_COPY_AND_ASSIGN(SearchResultTileItemListView);
 };
 
--- a/ash/app_list/views/search_result_tile_item_list_view_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/views/search_result_tile_item_list_view_unittest.cc	2019-05-17 18:53:08.092000000 +0300
@@ -4,7 +4,6 @@
 
 #include "ash/app_list/views/search_result_tile_item_list_view.h"
 
-#include <algorithm>
 #include <memory>
 #include <utility>
 
@@ -29,47 +28,34 @@
 constexpr int kMaxNumSearchResultTiles = 6;
 constexpr int kInstalledApps = 4;
 constexpr int kPlayStoreApps = 2;
-constexpr int kRecommendedApps = 1;
 }  // namespace
 
 class SearchResultTileItemListViewTest
     : public views::ViewsTestBase,
-      public ::testing::WithParamInterface<std::pair<bool, bool>> {
+      public ::testing::WithParamInterface<bool> {
  public:
   SearchResultTileItemListViewTest() = default;
   ~SearchResultTileItemListViewTest() override = default;
 
  protected:
   void CreateSearchResultTileItemListView() {
-    std::vector<base::Feature> enabled_features, disabled_features;
     // Enable fullscreen app list for parameterized Play Store app search
     // feature.
     // Zero State affects the UI behavior significantly. This test tests the
     // UI behavior with zero state being disable.
     // TODO(crbug.com/925195): Write new test cases for zero state.
     if (IsPlayStoreAppSearchEnabled()) {
-      enabled_features.push_back(app_list_features::kEnablePlayStoreAppSearch);
+      scoped_feature_list_.InitWithFeatures(
+          {app_list_features::kEnablePlayStoreAppSearch},
+          {app_list_features::kEnableZeroStateSuggestions});
     } else {
-      disabled_features.push_back(app_list_features::kEnablePlayStoreAppSearch);
+      scoped_feature_list_.InitWithFeatures(
+          {}, {app_list_features::kEnablePlayStoreAppSearch,
+               app_list_features::kEnableZeroStateSuggestions});
     }
-    if (IsReinstallAppRecommendationEnabled()) {
-      enabled_features.push_back(
-          app_list_features::kEnableAppReinstallZeroState);
-    } else {
-      disabled_features.push_back(
-          app_list_features::kEnableAppReinstallZeroState);
-    }
-
-    disabled_features.push_back(app_list_features::kEnableZeroStateSuggestions);
-
-    scoped_feature_list_.InitWithFeatures(enabled_features, disabled_features);
-
     ASSERT_EQ(IsPlayStoreAppSearchEnabled(),
               app_list_features::IsPlayStoreAppSearchEnabled());
 
-    ASSERT_EQ(IsReinstallAppRecommendationEnabled(),
-              app_list_features::IsAppReinstallZeroStateEnabled());
-
     // Sets up the views.
     textfield_ = std::make_unique<views::Textfield>();
     view_ = std::make_unique<SearchResultTileItemListView>(
@@ -77,9 +63,7 @@
     view_->SetResults(view_delegate_.GetSearchModel()->results());
   }
 
-  bool IsPlayStoreAppSearchEnabled() const { return GetParam().first; }
-
-  bool IsReinstallAppRecommendationEnabled() const { return GetParam().second; }
+  bool IsPlayStoreAppSearchEnabled() const { return GetParam(); }
 
   SearchResultTileItemListView* view() { return view_.get(); }
 
@@ -119,20 +103,6 @@
       }
     }
 
-    if (IsReinstallAppRecommendationEnabled()) {
-      for (int i = 0; i < kRecommendedApps; ++i) {
-        std::unique_ptr<TestSearchResult> result =
-            std::make_unique<TestSearchResult>();
-        result->set_result_id(base::StringPrintf("RecommendedApp %d", i));
-        result->set_display_type(ash::SearchResultDisplayType::kRecommendation);
-        result->set_result_type(ash::SearchResultType::kPlayStoreReinstallApp);
-        result->set_title(
-            base::UTF8ToUTF16(base::StringPrintf("RecommendedApp %d", i)));
-        result->SetRating(1 + i);
-        results->Add(std::move(result));
-      }
-    }
-
     // Adding results calls SearchResultContainerView::ScheduleUpdate().
     // It will post a delayed task to update the results and relayout.
     RunPendingMessages();
@@ -168,30 +138,20 @@
   SetUpSearchResults();
 
   const int results = GetResultCount();
-  int expected_results = kInstalledApps;
-
-  if (IsPlayStoreAppSearchEnabled()) {
-    expected_results += kPlayStoreApps;
-  }
-  if (IsReinstallAppRecommendationEnabled()) {
-    expected_results += kRecommendedApps;
-  }
-  expected_results = std::min(kMaxNumSearchResultTiles, expected_results);
-
+  const int expected_results = IsPlayStoreAppSearchEnabled()
+                                   ? kInstalledApps + kPlayStoreApps
+                                   : kInstalledApps;
   EXPECT_EQ(expected_results, results);
-
-  const bool separators_enabled =
-      IsPlayStoreAppSearchEnabled() || IsReinstallAppRecommendationEnabled();
-  // When the Play Store app search feature or app reinstallation feature is
-  // enabled, for each result, we added a separator for result type grouping.
-  const int expected_child_count = separators_enabled
+  // When the Play Store app search feature is enabled, for each results,
+  // we added a separator for result type grouping.
+  const int expected_child_count = IsPlayStoreAppSearchEnabled()
                                        ? kMaxNumSearchResultTiles * 2
                                        : kMaxNumSearchResultTiles;
   EXPECT_EQ(expected_child_count, view()->child_count());
 
   /// Test accessibility descriptions of tile views.
-  const int first_child = separators_enabled ? 1 : 0;
-  const int child_step = separators_enabled ? 2 : 1;
+  const int first_child = IsPlayStoreAppSearchEnabled() ? 1 : 0;
+  const int child_step = IsPlayStoreAppSearchEnabled() ? 2 : 1;
 
   for (int i = 0; i < kInstalledApps; ++i) {
     ui::AXNodeData node_data;
@@ -203,12 +163,7 @@
               node_data.GetStringAttribute(ax::mojom::StringAttribute::kName));
   }
 
-  const int expected_install_apps =
-      expected_results -
-      (IsReinstallAppRecommendationEnabled() ? kRecommendedApps : 0) -
-      kInstalledApps;
-  for (int i = kInstalledApps; i < (kInstalledApps + expected_install_apps);
-       ++i) {
+  for (int i = kInstalledApps; i < expected_results; ++i) {
     ui::AXNodeData node_data;
     view()
         ->child_at(first_child + i * child_step)
@@ -220,43 +175,15 @@
               node_data.GetStringAttribute(ax::mojom::StringAttribute::kName));
   }
 
-  // Recommendations.
-  const int start_index = kInstalledApps + expected_install_apps;
-  for (int i = kInstalledApps + expected_install_apps; i < expected_results;
-       ++i) {
-    ui::AXNodeData node_data;
-    view()
-        ->child_at(first_child + i * child_step)
-        ->GetAccessibleNodeData(&node_data);
-    EXPECT_EQ(ax::mojom::Role::kButton, node_data.role);
-    EXPECT_EQ(base::StringPrintf(
-                  "RecommendedApp %d, Star rating %d.0, App recommendation",
-                  i - start_index, i + 1 - start_index),
-              node_data.GetStringAttribute(ax::mojom::StringAttribute::kName));
-  }
-
   ResetOpenResultCount();
   for (int i = 0; i < results; ++i) {
     ui::KeyEvent event(ui::ET_KEY_PRESSED, ui::VKEY_RETURN, ui::EF_NONE);
     for (int j = 0; j <= i; ++j)
       view()->tile_views_for_test()[i]->OnKeyEvent(&event);
-    // When both app reinstalls and play store apps are enabled, we actually
-    // instantiate 7 results, but only show 6. So we have to look, for exactly 1
-    // result, a "skip" ahead for the reinstall result.
-    if (IsReinstallAppRecommendationEnabled() &&
-        IsPlayStoreAppSearchEnabled() && i == (results - 1)) {
-      EXPECT_EQ(i + 1, GetOpenResultCount(i + 1));
-    } else {
       EXPECT_EQ(i + 1, GetOpenResultCount(i));
     }
-  }
 }
 
-INSTANTIATE_TEST_SUITE_P(,
-                         SearchResultTileItemListViewTest,
-                         testing::ValuesIn({std::make_pair(false, false),
-                                            std::make_pair(false, true),
-                                            std::make_pair(true, false),
-                                            std::make_pair(true, true)}));
+INSTANTIATE_TEST_CASE_P(, SearchResultTileItemListViewTest, testing::Bool());
 
 }  // namespace app_list
--- a/ash/app_list/views/search_result_tile_item_view.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/views/search_result_tile_item_view.cc	2019-05-17 18:53:08.092000000 +0300
@@ -14,9 +14,9 @@
 #include "ash/app_list/pagination_model.h"
 #include "ash/app_list/views/app_list_item_view.h"
 #include "ash/public/cpp/app_list/app_list_config.h"
+#include "ash/public/cpp/app_list/app_list_constants.h"
 #include "ash/public/cpp/app_list/app_list_features.h"
 #include "ash/public/cpp/app_list/vector_icons/vector_icons.h"
-#include "ash/public/interfaces/app_list.mojom.h"
 #include "base/bind.h"
 #include "base/i18n/number_formatting.h"
 #include "base/metrics/histogram_macros.h"
@@ -58,13 +58,6 @@
 // Icon selected color, Google Grey 900 8%.
 constexpr int kIconSelectedColor = SkColorSetA(gfx::kGoogleGrey900, 0x14);
 
-// Offset for centering star rating when there is no price.
-constexpr int kSearchRatingCenteringOffset =
-    ((kSearchTileWidth -
-      (kSearchRatingSize + kSearchRatingStarHorizontalSpacing +
-       kSearchRatingStarSize)) /
-     2);
-
 constexpr SkColor kSearchTitleColor = gfx::kGoogleGrey900;
 constexpr SkColor kSearchAppRatingColor = gfx::kGoogleGrey700;
 constexpr SkColor kSearchAppPriceColor = gfx::kGoogleGreen600;
@@ -80,8 +73,6 @@
       pagination_model_(pagination_model),
       is_play_store_app_search_enabled_(
           app_list_features::IsPlayStoreAppSearchEnabled()),
-      is_app_reinstall_recommendation_enabled_(
-          app_list_features::IsAppReinstallZeroStateEnabled()),
       show_in_apps_page_(show_in_apps_page),
       weak_ptr_factory_(this) {
   SetFocusBehavior(FocusBehavior::ALWAYS);
@@ -97,8 +88,7 @@
   AddChildView(icon_);
 
   if (is_play_store_app_search_enabled_ ||
-      app_list_features::IsAppShortcutSearchEnabled() ||
-      is_app_reinstall_recommendation_enabled_) {
+      app_list_features::IsAppShortcutSearchEnabled()) {
     badge_ = new views::ImageView;
     badge_->set_can_process_events_within_subtree(false);
     badge_->SetVerticalAlignment(views::ImageView::LEADING);
@@ -115,8 +105,7 @@
   title_->SetAllowCharacterBreak(true);
   AddChildView(title_);
 
-  if (is_play_store_app_search_enabled_ ||
-      is_app_reinstall_recommendation_enabled_) {
+  if (is_play_store_app_search_enabled_) {
     rating_ = new views::Label;
     rating_->SetEnabledColor(kSearchAppRatingColor);
     rating_->SetLineHeight(kTileTextLineHeight);
@@ -168,36 +157,33 @@
   } else {
     // Set solid color background to avoid broken text. See crbug.com/746563.
     if (rating_) {
-      rating_->SetBackground(views::CreateSolidBackground(
-          AppListConfig::instance().card_background_color()));
+      rating_->SetBackground(
+          views::CreateSolidBackground(kCardBackgroundColor));
       if (!IsSuggestedAppTile()) {
         // App search results use different fonts than AppList apps.
         rating_->SetFontList(
             ui::ResourceBundle::GetSharedInstance().GetFontList(
-                AppListConfig::instance().search_result_title_font_style()));
+                kSearchResultTitleFontStyle));
       } else {
         rating_->SetFontList(font);
       }
     }
     if (price_) {
-      price_->SetBackground(views::CreateSolidBackground(
-          AppListConfig::instance().card_background_color()));
+      price_->SetBackground(views::CreateSolidBackground(kCardBackgroundColor));
       if (!IsSuggestedAppTile()) {
         // App search results use different fonts than AppList apps.
         price_->SetFontList(ui::ResourceBundle::GetSharedInstance().GetFontList(
-            AppListConfig::instance().search_result_title_font_style()));
+            kSearchResultTitleFontStyle));
       } else {
         price_->SetFontList(font);
       }
     }
-    title_->SetBackground(views::CreateSolidBackground(
-        AppListConfig::instance().card_background_color()));
+    title_->SetBackground(views::CreateSolidBackground(kCardBackgroundColor));
     if (!IsSuggestedAppTile()) {
       // App search results use different fonts than AppList apps.
       title_->SetFontList(
           ui::ResourceBundle::GetSharedInstance()
-              .GetFontList(
-                  AppListConfig::instance().search_result_title_font_style())
+              .GetFontList(kSearchResultTitleFontStyle)
               .DeriveWithSizeDelta(kSearchResultTileTitleTextSizeDelta));
     } else {
       title_->SetFontList(font);
@@ -230,20 +216,9 @@
   }
   if (price_ && price_->visible())
     accessible_name += base::UTF8ToUTF16(", ") + price_->text();
-
-  if (result()->result_type() ==
-      ash::SearchResultType::kPlayStoreReinstallApp) {
-    accessible_name +=
-        base::UTF8ToUTF16(", ") +
-        l10n_util::GetStringUTF16(IDS_APP_ACCESSIBILITY_APP_RECOMMENDATION_ARC);
-  }
   SetAccessibleName(accessible_name);
 }
 
-void SearchResultTileItemView::SetIndexInItemListView(size_t index) {
-  index_in_item_list_view_ = index;
-}
-
 void SearchResultTileItemView::SetParentBackgroundColor(SkColor color) {
   parent_background_color_ = color;
   UpdateBackgroundColor();
@@ -251,7 +226,12 @@
 
 void SearchResultTileItemView::ButtonPressed(views::Button* sender,
                                              const ui::Event& event) {
-  ActivateResult(event.flags());
+  if (IsSuggestedAppTile())
+    LogAppLaunch();
+
+  RecordSearchResultOpenSource(result(), view_delegate_->GetModel(),
+                               view_delegate_->GetSearchModel());
+  view_delegate_->OpenSearchResult(result()->id(), event.flags());
 }
 
 void SearchResultTileItemView::GetAccessibleNodeData(
@@ -279,9 +259,15 @@
     return true;
 
   if (event.key_code() == ui::VKEY_RETURN) {
-    ActivateResult(event.flags());
+    if (IsSuggestedAppTile())
+      LogAppLaunch();
+
+    RecordSearchResultOpenSource(result(), view_delegate_->GetModel(),
+                                 view_delegate_->GetSearchModel());
+    view_delegate_->OpenSearchResult(result()->id(), event.flags());
     return true;
   }
+
   return false;
 }
 
@@ -295,6 +281,7 @@
   }
   SetBackgroundHighlighted(true);
   UpdateBackgroundColor();
+  NotifyAccessibilityEvent(ax::mojom::Event::kSelection, true);
 }
 
 void SearchResultTileItemView::OnBlur() {
@@ -316,7 +303,7 @@
   flags.setStyle(cc::PaintFlags::kFill_Style);
   if (IsSuggestedAppTileShownInAppPage()) {
     rect.ClampToCenteredSize(AppListConfig::instance().grid_focus_size());
-    flags.setColor(AppListConfig::instance().grid_selected_color());
+    flags.setColor(kGridSelectedColor);
     canvas->DrawRoundRect(gfx::RectF(rect),
                           AppListConfig::instance().grid_focus_corner_radius(),
                           flags);
@@ -338,7 +325,7 @@
   Layout();
 }
 
-void SearchResultTileItemView::ShowContextMenuForViewImpl(
+void SearchResultTileItemView::ShowContextMenuForView(
     views::View* source,
     const gfx::Point& point,
     ui::MenuSourceType source_type) {
@@ -389,20 +376,6 @@
   }
 }
 
-void SearchResultTileItemView::ActivateResult(int event_flags) {
-  LogAppLaunchForSuggestedApp();
-
-  RecordSearchResultOpenSource(result(), view_delegate_->GetModel(),
-                               view_delegate_->GetSearchModel());
-  view_delegate_->OpenSearchResult(
-      result()->id(), event_flags,
-      ash::mojom::AppListLaunchedFrom::kLaunchedFromSearchBox,
-      ash::mojom::AppListLaunchType::kAppSearchResult,
-      index_in_item_list_view_);
-  view_delegate_->LogResultLaunchHistogram(
-      SearchResultLaunchLocation::kTileList, index_in_item_list_view_);
-}
-
 void SearchResultTileItemView::SetIcon(const gfx::ImageSkia& icon) {
   const int icon_size = AppListConfig::instance().search_tile_icon_dimension();
   gfx::ImageSkia resized(gfx::ImageSkiaOperations::CreateResizedImage(
@@ -499,19 +472,14 @@
   return IsSuggestedAppTile() && show_in_apps_page_;
 }
 
-void SearchResultTileItemView::LogAppLaunchForSuggestedApp() const {
+void SearchResultTileItemView::LogAppLaunch() const {
   // Only log the app launch if the class is being used as a suggested app.
   if (!IsSuggestedAppTile())
     return;
 
-  // We only need to record opening the installed app in zero state, no need to
-  // record the opening of a fast re-installed app, since the latter is already
-  // recorded in ArcAppReinstallAppResult::Open.
-  if (result()->result_type() !=
-      ash::SearchResultType::kPlayStoreReinstallApp) {
-    base::RecordAction(
-        base::UserMetricsAction("AppList_ZeroStateOpenInstalledApp"));
-  }
+  UMA_HISTOGRAM_BOOLEAN(kAppListAppLaunchedFullscreen,
+                        true /* suggested app */);
+  base::RecordAction(base::UserMetricsAction("AppList_OpenSuggestedApp"));
 }
 
 void SearchResultTileItemView::UpdateBackgroundColor() {
@@ -554,16 +522,9 @@
     rect.set_height(title_->GetPreferredSize().height());
     title_->SetBoundsRect(rect);
 
-    // If there is no price set, we center the rating.
-    const bool center_rating =
-        rating_ && rating_star_ && price_ && price_->text().empty();
-    const int rating_horizontal_offset =
-        center_rating ? kSearchRatingCenteringOffset : 0;
-
     if (rating_) {
       gfx::Rect rating_rect(rect);
-      rating_rect.Inset(rating_horizontal_offset,
-                        title_->GetPreferredSize().height(), 0, 0);
+      rating_rect.Inset(0, title_->GetPreferredSize().height(), 0, 0);
       rating_rect.set_size(rating_->GetPreferredSize());
       rating_rect.set_width(kSearchRatingSize);
       rating_->SetBoundsRect(rating_rect);
@@ -571,8 +532,8 @@
 
     if (rating_star_) {
       gfx::Rect rating_star_rect(rect);
-      rating_star_rect.Inset(rating_horizontal_offset + kSearchRatingSize +
-                                 kSearchRatingStarHorizontalSpacing,
+      rating_star_rect.Inset(
+          kSearchRatingSize + kSearchRatingStarHorizontalSpacing,
                              title_->GetPreferredSize().height() +
                                  kSearchRatingStarVerticalSpacing,
                              0, 0);
@@ -603,8 +564,7 @@
                      AppListConfig::instance().grid_tile_height());
   }
 
-  return gfx::Size(kSearchTileWidth,
-                   AppListConfig::instance().search_tile_height());
+  return gfx::Size(kSearchTileWidth, kSearchTileHeight);
 }
 
 bool SearchResultTileItemView::GetTooltipText(const gfx::Point& p,
--- a/ash/app_list/views/search_result_tile_item_view.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/views/search_result_tile_item_view.h	2019-05-17 18:53:08.092000000 +0300
@@ -39,7 +39,6 @@
   ~SearchResultTileItemView() override;
 
   void OnResultChanged() override;
-  void SetIndexInItemListView(size_t index);
 
   // Informs the SearchResultTileItemView of its parent's background color. The
   // controls within the SearchResultTileItemView will adapt to suit the given
@@ -61,7 +60,7 @@
   void OnMetadataChanged() override;
 
   // views::ContextMenuController overrides:
-  void ShowContextMenuForViewImpl(views::View* source,
+  void ShowContextMenuForView(views::View* source,
                                   const gfx::Point& point,
                                   ui::MenuSourceType source_type) override;
 
@@ -69,10 +68,7 @@
   void ExecuteCommand(int command_id, int event_flags) override;
 
  private:
-  // Launch the result and log to various histograms.
-  void ActivateResult(int event_flags);
-
-  // Bound by ShowContextMenuForViewImpl().
+  // Bound by ShowContextMenuForView().
   void OnGetContextMenuModel(views::View* source,
                              const gfx::Point& point,
                              ui::MenuSourceType source_type,
@@ -95,7 +91,7 @@
   bool IsSuggestedAppTileShownInAppPage() const;
 
   // Records an app being launched.
-  void LogAppLaunchForSuggestedApp() const;
+  void LogAppLaunch() const;
 
   void UpdateBackgroundColor();
 
@@ -119,14 +115,10 @@
   SkColor parent_background_color_ = SK_ColorTRANSPARENT;
 
   const bool is_play_store_app_search_enabled_;
-  const bool is_app_reinstall_recommendation_enabled_;
   const bool show_in_apps_page_;  // True if shown in app list's apps page.
 
   std::unique_ptr<AppListMenuModelAdapter> context_menu_;
 
-  // The index of this item in the search_result_tile_item_list_view, only used
-  // for logging.
-  int index_in_item_list_view_ = -1;
   base::WeakPtrFactory<SearchResultTileItemView> weak_ptr_factory_;
 
   DISALLOW_COPY_AND_ASSIGN(SearchResultTileItemView);
--- a/ash/app_list/views/search_result_view.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/views/search_result_view.cc	2019-05-17 18:53:08.092000000 +0300
@@ -16,6 +16,7 @@
 #include "ash/app_list/views/search_result_actions_view.h"
 #include "ash/app_list/views/search_result_list_view.h"
 #include "ash/public/cpp/app_list/app_list_config.h"
+#include "ash/public/cpp/app_list/app_list_constants.h"
 #include "ash/public/cpp/app_list/app_list_switches.h"
 #include "base/bind.h"
 #include "base/strings/utf_string_conversions.h"
@@ -35,7 +36,7 @@
 
 constexpr int kPreferredWidth = 640;
 constexpr int kPreferredHeight = 48;
-constexpr int kPreferredIconViewWidth = 56;
+constexpr int kIconLeftRightPadding = 18;
 constexpr int kTextTrailPadding = 16;
 // Extra margin at the right of the rightmost action icon.
 constexpr int kActionButtonRightMargin = 8;
@@ -54,8 +55,10 @@
 // Search result border color.
 constexpr SkColor kResultBorderColor = SkColorSetARGB(0xFF, 0xE5, 0xE5, 0xE5);
 
-// Delta applied to font size of all AppListSearchResult titles.
-constexpr int kSearchResultTitleTextSizeDelta = 2;
+int GetIconViewWidth() {
+  return AppListConfig::instance().search_list_icon_dimension() +
+         2 * kIconLeftRightPadding;
+}
 
 }  // namespace
 
@@ -67,19 +70,15 @@
     : list_view_(list_view),
       view_delegate_(view_delegate),
       icon_(new views::ImageView),
-      display_icon_(new views::ImageView),
       badge_icon_(new views::ImageView),
       actions_view_(new SearchResultActionsView(this)),
       progress_bar_(new views::ProgressBar),
       weak_ptr_factory_(this) {
   SetFocusBehavior(FocusBehavior::ALWAYS);
   icon_->set_can_process_events_within_subtree(false);
-  display_icon_->set_can_process_events_within_subtree(false);
-  SetDisplayIcon(gfx::ImageSkia());
   badge_icon_->set_can_process_events_within_subtree(false);
 
   AddChildView(icon_);
-  AddChildView(display_icon_);
   AddChildView(badge_icon_);
   AddChildView(actions_view_);
   AddChildView(progress_bar_);
@@ -143,7 +142,7 @@
   render_text->SetText(result()->title());
   ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
   render_text->SetFontList(
-      rb.GetFontList(AppListConfig::instance().search_result_title_font_style())
+      rb.GetFontList(kSearchResultTitleFontStyle)
           .DeriveWithSizeDelta(kSearchResultTitleTextSizeDelta));
   // When result is an omnibox non-url search, the matched tag indicates
   // proposed query. For all other cases, the matched tag indicates typed search
@@ -212,17 +211,14 @@
     return;
 
   gfx::Rect icon_bounds(rect);
-
-  const bool has_display_icon = !display_icon_->GetImage().isNull();
-  views::ImageView* icon = has_display_icon ? display_icon_ : icon_;
-  const int left_right_padding =
-      (kPreferredIconViewWidth - icon->GetImage().width()) / 2;
+  icon_bounds.set_width(GetIconViewWidth());
   const int top_bottom_padding =
-      (rect.height() - icon->GetImage().height()) / 2;
-  icon_bounds.set_width(kPreferredIconViewWidth);
-  icon_bounds.Inset(left_right_padding, top_bottom_padding);
+      (rect.height() - AppListConfig::instance().search_list_icon_dimension()) /
+      2;
+  icon_bounds.Inset(kIconLeftRightPadding, top_bottom_padding,
+                    kIconLeftRightPadding, top_bottom_padding);
   icon_bounds.Intersect(rect);
-  icon->SetBoundsRect(icon_bounds);
+  icon_->SetBoundsRect(icon_bounds);
 
   gfx::Rect badge_icon_bounds;
 
@@ -269,14 +265,6 @@
       }
       return true;
     }
-    case ui::VKEY_UP:
-    case ui::VKEY_DOWN: {
-      if (actions_view_->has_children()) {
-        return list_view_->HandleVerticalFocusMovement(
-            this, event.key_code() == ui::VKEY_UP);
-      }
-      break;
-    }
     default:
       break;
   }
@@ -295,14 +283,14 @@
 
   gfx::Rect content_rect(rect);
   gfx::Rect text_bounds(rect);
-  text_bounds.set_x(kPreferredIconViewWidth);
+  text_bounds.set_x(GetIconViewWidth());
   if (actions_view_->visible()) {
     text_bounds.set_width(
-        rect.width() - kPreferredIconViewWidth - kTextTrailPadding -
+        rect.width() - GetIconViewWidth() - kTextTrailPadding -
         actions_view_->bounds().width() -
         (actions_view_->has_children() ? kActionButtonRightMargin : 0));
   } else {
-    text_bounds.set_width(rect.width() - kPreferredIconViewWidth -
+    text_bounds.set_width(rect.width() - GetIconViewWidth() -
                           kTextTrailPadding - progress_bar_->bounds().width() -
                           kActionButtonRightMargin);
   }
@@ -311,8 +299,7 @@
 
   // Set solid color background to avoid broken text. See crbug.com/746563.
   // This should be drawn before selected color which is semi-transparent.
-  canvas->FillRect(text_bounds,
-                   AppListConfig::instance().card_background_color());
+  canvas->FillRect(text_bounds, kCardBackgroundColor);
 
   // Possibly call FillRect a second time (these colours are partially
   // transparent, so the previous FillRect is not redundant).
@@ -348,6 +335,7 @@
 
 void SearchResultView::OnFocus() {
   ScrollRectToVisible(GetLocalBounds());
+  NotifyAccessibilityEvent(ax::mojom::Event::kSelection, true);
   SetBackgroundHighlighted(true);
   selected_ = true;
   actions_view_->UpdateButtonsOnStateChanged();
@@ -367,30 +355,9 @@
   actions_view_->UpdateButtonsOnStateChanged();
 }
 
-void SearchResultView::GetAccessibleNodeData(ui::AXNodeData* node_data) {
-  if (!visible())
-    return;
-
-  // This is a work around to deal with the nested button case(append and remove
-  // button are child button of SearchResultView), which is not supported by
-  // ChromeVox. see details in crbug.com/924776.
-  // We change the role of the parent view SearchResultView to kGenericContainer
-  // i.e., not a kButton anymore.
-  node_data->role = ax::mojom::Role::kGenericContainer;
-  node_data->AddState(ax::mojom::State::kFocusable);
-  node_data->SetDefaultActionVerb(ax::mojom::DefaultActionVerb::kClick);
-  node_data->SetName(GetAccessibleName());
-}
-
-void SearchResultView::VisibilityChanged(View* starting_from, bool is_visible) {
-  NotifyAccessibilityEvent(ax::mojom::Event::kLayoutComplete, true);
-}
-
 void SearchResultView::OnGestureEvent(ui::GestureEvent* event) {
   switch (event->type()) {
     case ui::ET_GESTURE_LONG_PRESS:
-      if (actions_view_->IsValidActionIndex(
-              ash::OmniBoxZeroStateAction::kRemoveSuggestion)) {
         ScrollRectToVisible(GetLocalBounds());
         NotifyAccessibilityEvent(ax::mojom::Event::kSelection, true);
         SetBackgroundHighlighted(true);
@@ -398,7 +365,6 @@
         OnSearchResultActionActivated(
             ash::OmniBoxZeroStateAction::kRemoveSuggestion, event->flags());
         event->SetHandled();
-      }
       break;
     default:
       break;
@@ -484,9 +450,13 @@
       RemoveQueryConfirmationDialog* dialog = new RemoveQueryConfirmationDialog(
           base::BindOnce(&SearchResultView::OnQueryRemovalAccepted,
                          weak_ptr_factory_.GetWeakPtr()),
-          event_flags, list_view_->app_list_main_view()->contents_view());
+          event_flags);
 
-      dialog->Show(GetWidget()->GetNativeWindow());
+      // Calculate confirmation dialog's origin in screen coordinates.
+      gfx::Rect search_box_rect = list_view_->app_list_main_view()
+                                      ->search_box_view()
+                                      ->GetBoundsInScreen();
+      dialog->Show(GetWidget()->GetNativeWindow(), search_box_rect);
     } else if (button_action ==
                ash::OmniBoxZeroStateAction::kAppendSuggestion) {
       RecordZeroStateSearchResultUserActionHistogram(
@@ -500,8 +470,7 @@
   return IsMouseHovered() || selected();
 }
 
-void SearchResultView::ShowContextMenuForViewImpl(
-    views::View* source,
+void SearchResultView::ShowContextMenuForView(views::View* source,
     const gfx::Point& point,
     ui::MenuSourceType source_type) {
   // |result()| could be NULL when result list is changing.
@@ -538,10 +507,4 @@
   }
 }
 
-void SearchResultView::SetDisplayIcon(const gfx::ImageSkia& source) {
-  display_icon_->SetImage(source);
-  display_icon_->SetVisible(!source.isNull());
-  icon_->SetVisible(source.isNull());
-}
-
 }  // namespace app_list
--- a/ash/app_list/views/search_result_view.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/views/search_result_view.h	2019-05-17 18:53:08.092000000 +0300
@@ -64,16 +64,6 @@
   // Computes the button's spoken feedback name.
   base::string16 ComputeAccessibleName() const;
 
-  // Gets the index of this result in the |SearchResultListView|.
-  int get_index_in_search_result_list_view() const {
-    return index_in_search_result_list_view_;
-  }
-
-  // Stores the index of this result in the |SearchResultListView|.
-  void set_index_in_search_result_list_view(size_t index) {
-    index_in_search_result_list_view_ = index;
-  }
-
   void set_is_last_result(bool is_last) { is_last_result_ = is_last; }
 
   // AppListMenuModelAdapter::Delegate overrides:
@@ -81,8 +71,6 @@
 
   bool selected() const { return selected_; }
 
-  void SetDisplayIcon(const gfx::ImageSkia& source);
-
  private:
   friend class app_list::test::SearchResultListViewTest;
 
@@ -108,8 +96,6 @@
   void OnBlur() override;
   void OnMouseEntered(const ui::MouseEvent& event) override;
   void OnMouseExited(const ui::MouseEvent& event) override;
-  void GetAccessibleNodeData(ui::AXNodeData* node_data) override;
-  void VisibilityChanged(View* starting_from, bool is_visible) override;
 
   // ui::EventHandler overrides:
   void OnGestureEvent(ui::GestureEvent* event) override;
@@ -118,11 +104,11 @@
   void ButtonPressed(views::Button* sender, const ui::Event& event) override;
 
   // views::ContextMenuController overrides:
-  void ShowContextMenuForViewImpl(views::View* source,
+  void ShowContextMenuForView(views::View* source,
                                   const gfx::Point& point,
                                   ui::MenuSourceType source_type) override;
 
-  // Bound by ShowContextMenuForViewImpl().
+  // Bound by ShowContextMenuForView().
   void OnGetContextMenu(views::View* source,
                         const gfx::Point& point,
                         ui::MenuSourceType source_type,
@@ -150,8 +136,6 @@
   AppListViewDelegate* view_delegate_;
 
   views::ImageView* icon_;  // Owned by views hierarchy.
-  // If a |display_icon_| is set, we will show |display_icon_|, not |icon_|.
-  views::ImageView* display_icon_;  // Owned by views hierarchy.
   views::ImageView* badge_icon_;    // Owned by views hierarchy.
   std::unique_ptr<gfx::RenderText> title_text_;
   std::unique_ptr<gfx::RenderText> details_text_;
@@ -165,10 +149,6 @@
   // Whether the removal confirmation dialog is invoked by long press touch.
   bool confirm_remove_by_long_press_ = false;
 
-  // The index of this item in the search_result_tile_item_list_view, only
-  // used for logging.
-  int index_in_search_result_list_view_ = -1;
-
   base::WeakPtrFactory<SearchResultView> weak_ptr_factory_;
 
   DISALLOW_COPY_AND_ASSIGN(SearchResultView);
--- a/ash/app_list/views/suggestion_chip_container_view.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/views/suggestion_chip_container_view.cc	2019-05-17 18:53:08.092000000 +0300
@@ -12,9 +12,8 @@
 #include "ash/app_list/views/search_box_view.h"
 #include "ash/app_list/views/search_result_suggestion_chip_view.h"
 #include "ash/public/cpp/app_list/app_list_config.h"
+#include "ash/public/cpp/app_list/app_list_constants.h"
 #include "ash/public/cpp/app_list/app_list_features.h"
-#include "base/bind.h"
-#include "base/callback.h"
 #include "ui/views/accessibility/view_accessibility.h"
 #include "ui/views/controls/textfield/textfield.h"
 #include "ui/views/focus/focus_manager.h"
@@ -31,15 +30,13 @@
 
 SuggestionChipContainerView::SuggestionChipContainerView(
     ContentsView* contents_view)
-    : SearchResultContainerView(
-          contents_view != nullptr
-              ? contents_view->GetAppListMainView()->view_delegate()
-              : nullptr),
-      contents_view_(contents_view) {
+    : contents_view_(contents_view) {
   SetPaintToLayer();
   layer()->SetFillsBoundsOpaquely(false);
 
   DCHECK(contents_view);
+  view_delegate_ = contents_view_->GetAppListMainView()->view_delegate();
+
   views::BoxLayout* layout_manager =
       SetLayoutManager(std::make_unique<views::BoxLayout>(
           views::BoxLayout::Orientation::kHorizontal, gfx::Insets(),
@@ -47,11 +44,9 @@
   layout_manager->set_main_axis_alignment(
       views::BoxLayout::MainAxisAlignment::MAIN_AXIS_ALIGNMENT_CENTER);
 
-  for (size_t i = 0; i < static_cast<size_t>(
-                             AppListConfig::instance().num_start_page_tiles());
-       ++i) {
+  for (size_t i = 0; i < static_cast<size_t>(kNumStartPageTiles); ++i) {
     SearchResultSuggestionChipView* chip =
-        new SearchResultSuggestionChipView(view_delegate());
+        new SearchResultSuggestionChipView(view_delegate_);
     chip->SetVisible(false);
     chip->SetIndexInSuggestionChipContainer(i);
     suggestion_chip_views_.emplace_back(chip);
@@ -65,27 +60,20 @@
   if (IgnoreUpdateAndLayout())
     return num_results();
 
-  auto exclude_reinstall_filter = [](const SearchResult& r) -> bool {
-    return r.display_type() == ash::SearchResultDisplayType::kRecommendation &&
-           r.result_type() != ash::SearchResultType::kPlayStoreReinstallApp;
-  };
   std::vector<SearchResult*> display_results =
-      SearchModel::FilterSearchResultsByFunction(
-          results(), base::BindRepeating(exclude_reinstall_filter),
-          AppListConfig::instance().num_start_page_tiles());
+      SearchModel::FilterSearchResultsByDisplayType(
+          results(), ash::SearchResultDisplayType::kRecommendation,
+          /*excludes=*/{}, kNumStartPageTiles);
 
   // Update search results here, but wait until layout to add them as child
   // views when we know this view's bounds.
-  for (size_t i = 0; i < static_cast<size_t>(
-                             AppListConfig::instance().num_start_page_tiles());
-       ++i) {
+  for (size_t i = 0; i < static_cast<size_t>(kNumStartPageTiles); ++i) {
     suggestion_chip_views_[i]->SetResult(
         i < display_results.size() ? display_results[i] : nullptr);
   }
 
   Layout();
-  return std::min(AppListConfig::instance().num_start_page_tiles(),
-                  display_results.size());
+  return std::min(kNumStartPageTiles, static_cast<int>(display_results.size()));
 }
 
 const char* SuggestionChipContainerView::GetClassName() const {
@@ -117,7 +105,7 @@
 
 bool SuggestionChipContainerView::OnKeyPressed(const ui::KeyEvent& event) {
   // Let the FocusManager handle Left/Right keys.
-  if (!IsUnhandledUpDownKeyEvent(event))
+  if (!CanProcessUpDownKeyTraversal(event))
     return false;
 
   // Up key moves focus to the search box. Down key moves focus to the first
--- a/ash/app_list/views/suggestion_chip_container_view.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/views/suggestion_chip_container_view.h	2019-05-17 18:53:08.092000000 +0300
@@ -12,6 +12,7 @@
 
 namespace app_list {
 
+class AppListViewDelegate;
 class ContentsView;
 class SearchResultSuggestionChipView;
 
@@ -41,6 +42,7 @@
   bool IgnoreUpdateAndLayout() const;
 
   ContentsView* contents_view_ = nullptr;  // Not owned
+  AppListViewDelegate* view_delegate_ = nullptr;
 
   std::vector<SearchResultSuggestionChipView*> suggestion_chip_views_;  // Owned
 
--- a/ash/app_list/views/suggestion_chip_view.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/views/suggestion_chip_view.cc	2019-05-17 18:53:08.092000000 +0300
@@ -8,6 +8,7 @@
 #include <memory>
 #include <utility>
 
+#include "ash/assistant/ui/assistant_ui_constants.h"
 #include "ash/public/cpp/app_list/app_list_config.h"
 #include "ui/accessibility/ax_node_data.h"
 #include "ui/gfx/canvas.h"
@@ -25,12 +26,24 @@
 
 namespace {
 
-constexpr SkColor kBackgroundColor = SkColorSetA(gfx::kGoogleGrey100, 0x14);
-constexpr SkColor kTextColor = gfx::kGoogleGrey100;
-constexpr SkColor kRippleColor = SkColorSetA(gfx::kGoogleGrey100, 0x0F);
-constexpr SkColor kFocusColor = SkColorSetA(gfx::kGoogleGrey100, 0x14);
-constexpr int kMaxTextWidth = 192;
+// Assistant specific style:
+constexpr SkColor kAssistantBackgroundColor = SK_ColorWHITE;
+constexpr SkColor kAssistantFocusColor = SkColorSetA(gfx::kGoogleGrey900, 0x14);
+constexpr SkColor kAssistantStrokeColor =
+    SkColorSetA(gfx::kGoogleGrey900, 0x24);
+constexpr SkColor kAssistantTextColor = gfx::kGoogleGrey700;
+constexpr int kAssistantStrokeWidthDip = 1;
+
+// App list specific style:
+constexpr SkColor kAppListBackgroundColor =
+    SkColorSetA(gfx::kGoogleGrey100, 0x14);
+constexpr SkColor kAppListTextColor = gfx::kGoogleGrey100;
+constexpr SkColor kAppListRippleColor = SkColorSetA(gfx::kGoogleGrey100, 0x0F);
+constexpr SkColor kAppListFocusColor = SkColorSetA(gfx::kGoogleGrey100, 0x14);
+constexpr int kAppListMaxTextWidth = 192;
 constexpr int kBlurRadius = 5;
+
+// Shared style:
 constexpr int kIconMarginDip = 8;
 constexpr int kPaddingDip = 16;
 constexpr int kPreferredHeightDip = 32;
@@ -49,12 +62,14 @@
                                        views::ButtonListener* listener)
     : Button(listener),
       icon_view_(new views::ImageView()),
-      text_view_(new views::Label()) {
+      text_view_(new views::Label()),
+      assistant_style_(params.assistant_style) {
   SetFocusBehavior(FocusBehavior::ALWAYS);
   SetInkDropMode(InkDropMode::ON);
 
   // Set background blur for the chip and use mask layer to clip it into
   // rounded rect.
+  if (!assistant_style_)
   SetBackgroundBlurEnabled(false);
 
   InitLayout(params);
@@ -63,6 +78,8 @@
 SuggestionChipView::~SuggestionChipView() = default;
 
 void SuggestionChipView::SetBackgroundBlurEnabled(bool enabled) {
+  DCHECK(!assistant_style_);
+
   // Background blur is enabled if and only if layer exists.
   if (!!layer() == enabled)
     return;
@@ -124,9 +141,13 @@
 
   // Text.
   text_view_->SetAutoColorReadabilityEnabled(false);
-  text_view_->SetEnabledColor(kTextColor);
+  text_view_->SetEnabledColor(assistant_style_ ? kAssistantTextColor
+                                               : kAppListTextColor);
   text_view_->SetSubpixelRenderingEnabled(false);
-  text_view_->SetFontList(AppListConfig::instance().app_title_font());
+  text_view_->SetFontList(
+      assistant_style_
+          ? ash::assistant::ui::GetDefaultFontList().DeriveWithSizeDelta(1)
+          : AppListConfig::instance().app_title_font());
   SetText(params.text);
   AddChildView(text_view_);
 }
@@ -138,17 +159,31 @@
   gfx::Rect bounds = GetContentsBounds();
 
   // Background.
-  flags.setColor(kBackgroundColor);
+  flags.setColor(assistant_style_ ? kAssistantBackgroundColor
+                                  : kAppListBackgroundColor);
   canvas->DrawRoundRect(bounds, height() / 2, flags);
   if (HasFocus()) {
-    flags.setColor(kFocusColor);
+    flags.setColor(assistant_style_ ? kAssistantFocusColor
+                                    : kAppListFocusColor);
+    canvas->DrawRoundRect(bounds, height() / 2, flags);
+  }
+
+  // Border.
+  if (assistant_style_) {
+    // Stroke should be drawn within our contents bounds.
+    bounds.Inset(gfx::Insets(kAssistantStrokeWidthDip));
+
+    // Stroke.
+    flags.setColor(kAssistantStrokeColor);
+    flags.setStrokeWidth(kAssistantStrokeWidthDip);
+    flags.setStyle(cc::PaintFlags::Style::kStroke_Style);
     canvas->DrawRoundRect(bounds, height() / 2, flags);
   }
 }
 
 void SuggestionChipView::OnFocus() {
   SchedulePaint();
-  NotifyAccessibilityEvent(ax::mojom::Event::kFocus, true);
+  NotifyAccessibilityEvent(ax::mojom::Event::kSelection, true);
 }
 
 void SuggestionChipView::OnBlur() {
@@ -189,7 +224,7 @@
                    2 * ripple_radius, 2 * ripple_radius);
   return std::make_unique<views::FloodFillInkDropRipple>(
       size(), GetLocalBounds().InsetsFrom(bounds),
-      GetInkDropCenterBasedOnLastEvent(), kRippleColor, 1.0f);
+      GetInkDropCenterBasedOnLastEvent(), kAppListRippleColor, 1.0f);
 }
 
 std::unique_ptr<ui::Layer> SuggestionChipView::RecreateLayer() {
@@ -206,9 +241,11 @@
 
 void SuggestionChipView::SetText(const base::string16& text) {
   text_view_->SetText(text);
+  if (!assistant_style_) {
   gfx::Size size = text_view_->CalculatePreferredSize();
-  size.set_width(std::min(kMaxTextWidth, size.width()));
+    size.set_width(std::min(kAppListMaxTextWidth, size.width()));
   text_view_->SetPreferredSize(size);
+  }
 }
 
 const base::string16& SuggestionChipView::GetText() const {
--- a/ash/app_list/views/suggestion_chip_view.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/views/suggestion_chip_view.h	2019-05-17 18:53:08.092000000 +0300
@@ -35,6 +35,8 @@
     base::string16 text;
     // Optional icon.
     base::Optional<gfx::ImageSkia> icon;
+    // True if the chip should use assistant style.
+    bool assistant_style = false;
   };
 
   SuggestionChipView(const Params& params, views::ButtonListener* listener);
@@ -77,6 +79,9 @@
 
   views::BoxLayout* layout_manager_;  // Owned by view hierarchy.
 
+  // True if this chip should use assistant style.
+  bool assistant_style_;
+
   // The owner of a mask layer used to clip the chip.
   std::unique_ptr<ui::LayerOwner> chip_mask_;
 
--- a/ash/app_list/views/top_icon_animation_view.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_list/views/top_icon_animation_view.cc	2019-05-17 18:53:08.092000000 +0300
@@ -6,6 +6,7 @@
 
 #include "ash/app_list/views/app_list_item_view.h"
 #include "ash/public/cpp/app_list/app_list_config.h"
+#include "ash/public/cpp/app_list/app_list_constants.h"
 #include "base/threading/thread_task_runner_handle.h"
 #include "ui/compositor/scoped_layer_animation_settings.h"
 #include "ui/gfx/image/image_skia_operations.h"
@@ -91,8 +92,8 @@
   ui::ScopedLayerAnimationSettings settings(layer()->GetAnimator());
   settings.AddObserver(this);
   settings.SetTweenType(gfx::Tween::FAST_OUT_SLOW_IN);
-  settings.SetTransitionDuration(base::TimeDelta::FromMilliseconds(
-      AppListConfig::instance().folder_transition_in_duration_ms()));
+  settings.SetTransitionDuration(
+      base::TimeDelta::FromMilliseconds(kFolderTransitionInDurationMs));
   layer()->SetTransform(open_folder_ ? gfx::Transform() : transform);
   if (!item_in_folder_icon_)
     layer()->SetOpacity(open_folder_ ? 1.0f : 0.0f);
@@ -103,8 +104,8 @@
     ui::ScopedLayerAnimationSettings title_settings(
         title_->layer()->GetAnimator());
     title_settings.SetTweenType(gfx::Tween::FAST_OUT_SLOW_IN);
-    title_settings.SetTransitionDuration(base::TimeDelta::FromMilliseconds(
-        AppListConfig::instance().folder_transition_in_duration_ms()));
+    title_settings.SetTransitionDuration(
+        base::TimeDelta::FromMilliseconds(kFolderTransitionInDurationMs));
     title_->layer()->SetOpacity(open_folder_ ? 1.0f : 0.0f);
   }
 }
--- a/ash/app_menu/app_menu_export.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_menu/app_menu_export.h	2019-05-17 18:53:08.092000000 +0300
@@ -9,12 +9,21 @@
 // module can be exported to consumers.
 
 #if defined(COMPONENT_BUILD)
+#if defined(WIN32)
 
 #if defined(APP_MENU_IMPLEMENTATION)
+#define APP_MENU_EXPORT __declspec(dllexport)
+#else
+#define APP_MENU_EXPORT __declspec(dllimport)
+#endif  // defined(APP_MENU_IMPLEMENTATION)
+
+#else  // defined(WIN32)
+#if defined(APP_MENU_IMPLEMENTATION)
 #define APP_MENU_EXPORT __attribute__((visibility("default")))
 #else
 #define APP_MENU_EXPORT
 #endif
+#endif
 
 #else  // defined(COMPONENT_BUILD)
 #define APP_MENU_EXPORT
--- a/ash/app_menu/notification_menu_header_view.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_menu/notification_menu_header_view.cc	2019-05-17 18:53:08.096000000 +0300
@@ -53,7 +53,7 @@
 
   number_of_notifications_ = number_of_notifications;
 
-  counter_->SetText(base::NumberToString16(number_of_notifications_));
+  counter_->SetText(base::IntToString16(number_of_notifications_));
 }
 
 gfx::Size NotificationMenuHeaderView::CalculatePreferredSize() const {
--- a/ash/app_menu/notification_menu_view_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_menu/notification_menu_view_unittest.cc	2019-05-17 18:53:08.096000000 +0300
@@ -222,7 +222,7 @@
 
   // The counter should update to 1, and the displayed NotificationItemView
   // should match the notification.
-  EXPECT_EQ(base::NumberToString16(1), test_api()->GetCounterViewContents());
+  EXPECT_EQ(base::IntToString16(1), test_api()->GetCounterViewContents());
   EXPECT_EQ(1, test_api()->GetItemViewCount());
   CheckDisplayedNotification(notification_0);
 
@@ -231,13 +231,13 @@
   const message_center::Notification notification_1 =
       AddNotification("notification_id_1", base::ASCIIToUTF16("title_1"),
                       base::ASCIIToUTF16("message_1"));
-  EXPECT_EQ(base::NumberToString16(2), test_api()->GetCounterViewContents());
+  EXPECT_EQ(base::IntToString16(2), test_api()->GetCounterViewContents());
   EXPECT_EQ(2, test_api()->GetItemViewCount());
   CheckDisplayedNotification(notification_1);
 
   // Remove |notification_1|, |notification_0| should be shown.
   notification_menu_view()->OnNotificationRemoved(notification_1.id());
-  EXPECT_EQ(base::NumberToString16(1), test_api()->GetCounterViewContents());
+  EXPECT_EQ(base::IntToString16(1), test_api()->GetCounterViewContents());
   EXPECT_EQ(1, test_api()->GetItemViewCount());
   CheckDisplayedNotification(notification_0);
 }
@@ -309,7 +309,7 @@
                       base::ASCIIToUTF16("message_1"));
 
   // The latest notification should be shown.
-  EXPECT_EQ(base::NumberToString16(2), test_api()->GetCounterViewContents());
+  EXPECT_EQ(base::IntToString16(2), test_api()->GetCounterViewContents());
   EXPECT_EQ(2, test_api()->GetItemViewCount());
   CheckDisplayedNotification(notification_1);
 
@@ -317,7 +317,7 @@
   notification_menu_view()->OnNotificationRemoved(notification_0.id());
 
   // The latest notification, |notification_1|, should be shown.
-  EXPECT_EQ(base::NumberToString16(1), test_api()->GetCounterViewContents());
+  EXPECT_EQ(base::IntToString16(1), test_api()->GetCounterViewContents());
   EXPECT_EQ(1, test_api()->GetItemViewCount());
   CheckDisplayedNotification(notification_1);
 }
@@ -424,7 +424,7 @@
 
   // The displayed notification's contents should have changed to match the
   // updated notification.
-  EXPECT_EQ(base::NumberToString16(1), test_api()->GetCounterViewContents());
+  EXPECT_EQ(base::IntToString16(1), test_api()->GetCounterViewContents());
   EXPECT_EQ(1, test_api()->GetItemViewCount());
   CheckDisplayedNotification(updated_notification);
 
@@ -433,7 +433,7 @@
                      base::ASCIIToUTF16("Bad Message"));
 
   // Test that the displayed notification has not been changed.
-  EXPECT_EQ(base::NumberToString16(1), test_api()->GetCounterViewContents());
+  EXPECT_EQ(base::IntToString16(1), test_api()->GetCounterViewContents());
   EXPECT_EQ(1, test_api()->GetItemViewCount());
   CheckDisplayedNotification(updated_notification);
 }
--- a/ash/app_menu/notification_overflow_view_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/app_menu/notification_overflow_view_unittest.cc	2019-05-17 18:53:08.096000000 +0300
@@ -28,8 +28,7 @@
   // Adds a notification and returns the string identifier.
   std::string AddNotification() {
     message_center::ProportionalImageView image_view(gfx::Size(16, 16));
-    std::string notification_id =
-        base::NumberToString(notification_identifier_++);
+    std::string notification_id = base::IntToString(notification_identifier_++);
     notification_overflow_view_->AddIcon(image_view, notification_id);
     return notification_id;
   }
@@ -109,7 +108,7 @@
   EXPECT_TRUE(HasOverflowIcon());
 
   // Remove any notification that was added. The overflow icon should dissapear.
-  notification_overflow_view()->RemoveIcon(base::NumberToString(0));
+  notification_overflow_view()->RemoveIcon(base::IntToString(0));
   CheckNumberOfNotificationIcons(kMaxOverflowIcons);
   EXPECT_FALSE(HasOverflowIcon());
 
--- a/ash/ash_export.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/ash_export.h	2019-05-17 18:53:08.096000000 +0300
@@ -9,12 +9,21 @@
 // be exported to consumers.
 
 #if defined(COMPONENT_BUILD)
+#if defined(WIN32)
 
 #if defined(ASH_IMPLEMENTATION)
+#define ASH_EXPORT __declspec(dllexport)
+#else
+#define ASH_EXPORT __declspec(dllimport)
+#endif  // defined(ASH_IMPLEMENTATION)
+
+#else  // defined(WIN32)
+#if defined(ASH_IMPLEMENTATION)
 #define ASH_EXPORT __attribute__((visibility("default")))
 #else
 #define ASH_EXPORT
 #endif
+#endif
 
 #else  // defined(COMPONENT_BUILD)
 #define ASH_EXPORT
--- a/ash/ash_service.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/ash_service.cc	2019-05-17 18:53:08.096000000 +0300
@@ -17,9 +17,7 @@
 #include "base/threading/thread_task_runner_handle.h"
 #include "chromeos/audio/cras_audio_handler.h"
 #include "chromeos/dbus/dbus_thread_manager.h"
-#include "chromeos/dbus/hammerd/hammerd_client.h"
 #include "chromeos/dbus/power_policy_controller.h"
-#include "chromeos/dbus/system_clock/system_clock_client.h"
 #include "chromeos/network/network_connect.h"
 #include "chromeos/network/network_handler.h"
 #include "chromeos/system/fake_statistics_provider.h"
@@ -81,19 +79,17 @@
   Shell::DeleteInstance();
 
   statistics_provider_.reset();
-
+  // NOTE: PowerStatus is shutdown by Shell.
+  chromeos::CrasAudioHandler::Shutdown();
   chromeos::NetworkConnect::Shutdown();
   network_connect_delegate_.reset();
+  // We may not have started the NetworkHandler.
+  if (network_handler_initialized_)
   chromeos::NetworkHandler::Shutdown();
   device::BluetoothAdapterFactory::Shutdown();
   bluez::BluezDBusManager::Shutdown();
   chromeos::PowerPolicyController::Shutdown();
-
-  chromeos::SystemClockClient::Shutdown();
-  chromeos::PowerManagerClient::Shutdown();
-  chromeos::HammerdClient::Shutdown();
-  chromeos::CrasAudioHandler::Shutdown();
-
+  if (dbus_thread_manager_initialized_)
   chromeos::DBusThreadManager::Shutdown();
 
   // |gpu_host_| must be completely destroyed before Env as GpuHost depends on
@@ -129,7 +125,25 @@
 
   // Must occur after mojo::ApplicationRunner has initialized AtExitManager, but
   // before WindowManager::Init(). Tests might initialize their own instance.
-  InitializeDBusClients();
+  if (!chromeos::DBusThreadManager::IsInitialized()) {
+    chromeos::DBusThreadManager::Initialize(
+        chromeos::DBusThreadManager::kShared);
+    dbus_thread_manager_initialized_ = true;
+  }
+  chromeos::PowerPolicyController::Initialize(
+      chromeos::DBusThreadManager::Get()->GetPowerManagerClient());
+
+  // The initialization matches that in ChromeBrowserMainPartsChromeos.
+
+  bluez::BluezDBusManager::Initialize();
+  if (!chromeos::NetworkHandler::IsInitialized()) {
+    chromeos::NetworkHandler::Initialize();
+    network_handler_initialized_ = true;
+  }
+  network_connect_delegate_ = std::make_unique<NetworkConnectDelegateMus>();
+  chromeos::NetworkConnect::Initialize(network_connect_delegate_.get());
+  // TODO(jamescook): Initialize real audio handler.
+  chromeos::CrasAudioHandler::InitializeForTesting();
 
   // TODO(jamescook): Refactor StatisticsProvider so we can get just the data
   // we need in ash. Right now StatisticsProviderImpl launches the crossystem
@@ -152,33 +166,6 @@
   Shell::GetPrimaryRootWindow()->GetHost()->Show();
 }
 
-void AshService::InitializeDBusClients() {
-  CHECK(!chromeos::DBusThreadManager::IsInitialized());
-
-  // TODO(stevenjb): Eliminate use of DBusThreadManager and initialize
-  // dbus::Thread, dbus::Bus and required clients directly.
-  chromeos::DBusThreadManager::Initialize(chromeos::DBusThreadManager::kShared);
-  dbus::Bus* bus = chromeos::DBusThreadManager::Get()->GetSystemBus();
-
-  // TODO(jamescook): Initialize real audio handler.
-  chromeos::CrasAudioHandler::InitializeForTesting();
-  chromeos::HammerdClient::Initialize(bus);
-  chromeos::PowerManagerClient::Initialize(bus);
-  chromeos::SystemClockClient::Initialize(bus);
-
-  chromeos::PowerPolicyController::Initialize(
-      chromeos::PowerManagerClient::Get());
-
-  // TODO(ortuno): Eliminate BluezDBusManager code from Ash, crbug.com/830893.
-  bluez::BluezDBusManager::Initialize();
-
-  // TODO(stevenjb): Eliminate NetworkHandler code from Ash, crbug.com/644355.
-  CHECK(!chromeos::NetworkHandler::IsInitialized());
-  chromeos::NetworkHandler::Initialize();
-  network_connect_delegate_ = std::make_unique<NetworkConnectDelegateMus>();
-  chromeos::NetworkConnect::Initialize(network_connect_delegate_.get());
-}
-
 void AshService::OnStart() {
   mojo_interface_factory::RegisterInterfaces(
       &registry_, base::ThreadTaskRunnerHandle::Get());
--- a/ash/ash_service.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/ash_service.h	2019-05-17 18:53:08.096000000 +0300
@@ -86,8 +86,6 @@
   // once the service starts (from OnStart()).
   void InitForMash();
 
-  void InitializeDBusClients();
-
   void BindServiceFactory(
       service_manager::mojom::ServiceFactoryRequest request);
 
@@ -125,6 +123,12 @@
 
   std::unique_ptr<ws::InputDeviceController> input_device_controller_;
 
+  // Whether this class initialized NetworkHandler and needs to clean it up.
+  bool network_handler_initialized_ = false;
+
+  // Whether this class initialized DBusThreadManager and needs to clean it up.
+  bool dbus_thread_manager_initialized_ = false;
+
   DISALLOW_COPY_AND_ASSIGN(AshService);
 };
 
--- a/ash/ash_service_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/ash_service_unittest.cc	2019-05-17 18:53:08.096000000 +0300
@@ -6,8 +6,6 @@
 #include <memory>
 #include <vector>
 
-#include "ash/public/cpp/manifest.h"
-#include "ash/public/cpp/test_manifest.h"
 #include "ash/public/cpp/window_properties.h"
 #include "ash/public/interfaces/constants.mojom.h"
 #include "ash/public/interfaces/window_properties.mojom.h"
@@ -15,11 +13,9 @@
 #include "base/macros.h"
 #include "base/run_loop.h"
 #include "base/test/scoped_task_environment.h"
-#include "services/service_manager/public/cpp/manifest_builder.h"
 #include "services/service_manager/public/cpp/test/test_service.h"
 #include "services/service_manager/public/cpp/test/test_service_manager.h"
 #include "services/ws/public/cpp/property_type_converters.h"
-#include "services/ws/public/mojom/constants.mojom.h"
 #include "services/ws/public/mojom/window_manager.mojom.h"
 #include "services/ws/public/mojom/window_tree.mojom.h"
 #include "services/ws/public/mojom/window_tree_constants.mojom.h"
@@ -42,8 +38,6 @@
 
 namespace ash {
 
-const char kTestServiceName[] = "ash_unittests";
-
 class WindowTreeClientDelegate : public aura::WindowTreeClientDelegate {
  public:
   WindowTreeClientDelegate() = default;
@@ -78,33 +72,25 @@
 class AshServiceTest : public testing::Test {
  public:
   AshServiceTest()
-      : test_service_manager_(
-            {service_manager::Manifest(GetManifest())
-                 .Amend(GetManifestOverlayForTesting()),
-             service_manager::ManifestBuilder()
-                 .WithServiceName(kTestServiceName)
-                 .RequireCapability(ws::mojom::kServiceName, "app")
-                 .Build()}),
-        test_service_(
-            test_service_manager_.RegisterTestInstance(kTestServiceName)) {}
+      : test_service_(
+            test_service_manager_.RegisterTestInstance("ash_unittests")) {}
   ~AshServiceTest() override = default;
 
   // service_manager::test::ServiceTest:
   void SetUp() override {
-    old_mode_ = aura::test::EnvTestHelper().SetMode(aura::Env::Mode::MUS);
+    aura::test::EnvTestHelper().SetMode(aura::Env::Mode::MUS);
   }
 
   void TearDown() override {
     // Unset the screen installed by the test.
     display::Screen::SetScreenInstance(nullptr);
-    aura::test::EnvTestHelper().SetMode(old_mode_);
+    aura::test::EnvTestHelper().SetMode(aura::Env::Mode::LOCAL);
   }
 
  protected:
   service_manager::Connector* connector() { return test_service_.connector(); }
 
  private:
-  aura::Env::Mode old_mode_ = aura::Env::Mode::LOCAL;
   base::test::ScopedTaskEnvironment task_environment_;
   service_manager::TestServiceManager test_service_manager_;
   service_manager::TestService test_service_;
--- a/ash/assistant/assistant_alarm_timer_controller.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/assistant_alarm_timer_controller.cc	2019-05-17 18:53:08.100000000 +0300
@@ -4,10 +4,6 @@
 
 #include "ash/assistant/assistant_alarm_timer_controller.h"
 
-#include <map>
-#include <string>
-#include <utility>
-
 #include "ash/assistant/assistant_controller.h"
 #include "ash/assistant/assistant_notification_controller.h"
 #include "ash/assistant/util/deep_link_util.h"
@@ -49,7 +45,6 @@
   using chromeos::assistant::mojom::AssistantNotification;
   using chromeos::assistant::mojom::AssistantNotificationButton;
   using chromeos::assistant::mojom::AssistantNotificationPtr;
-  using chromeos::assistant::mojom::AssistantNotificationType;
 
   const std::string title =
       l10n_util::GetStringUTF8(IDS_ASSISTANT_TIMER_NOTIFICATION_TITLE);
@@ -60,23 +55,12 @@
 
   AssistantNotificationPtr notification = AssistantNotification::New();
 
-  // If in-Assistant notifications are supported, we'll allow alarm/timer
-  // notifications to show in either Assistant UI or the Message Center.
-  // Otherwise, we'll only allow the notification to show in the Message Center.
-  notification->type =
-      chromeos::assistant::features::IsInAssistantNotificationsEnabled()
-          ? AssistantNotificationType::kPreferInAssistant
-          : AssistantNotificationType::kSystem;
-
   notification->title = title;
   notification->message = message;
   notification->action_url = action_url;
   notification->client_id = alarm_timer.id;
   notification->grouping_key = kTimerNotificationGroupingKey;
 
-  // This notification should be able to wake up the display if it was off.
-  notification->is_high_priority = true;
-
   // "STOP" button.
   notification->buttons.push_back(AssistantNotificationButton::New(
       l10n_util::GetStringUTF8(IDS_ASSISTANT_TIMER_NOTIFICATION_STOP_BUTTON),
--- a/ash/assistant/assistant_controller.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/assistant_controller.cc	2019-05-17 18:53:08.100000000 +0300
@@ -102,18 +102,8 @@
 }
 
 void AssistantController::StartSpeakerIdEnrollmentFlow() {
-  mojom::ConsentStatus consent_status =
-      Shell::Get()->voice_interaction_controller()->consent_status().value_or(
-          mojom::ConsentStatus::kUnknown);
-  if (consent_status == mojom::ConsentStatus::kActivityControlAccepted) {
-    // If activity control has been accepted, launch the enrollment flow.
     setup_controller()->StartOnboarding(false /* relaunch */,
                                         mojom::FlowType::SPEAKER_ID_ENROLLMENT);
-  } else {
-    // If activity control has not been accepted, launch the opt-in flow.
-    setup_controller()->StartOnboarding(false /* relaunch */,
-                                        mojom::FlowType::CONSENT_FLOW);
-  }
 }
 
 void AssistantController::DownloadImage(
@@ -162,8 +152,6 @@
       Shell::Get()->new_window_controller()->ShowTaskManager();
       break;
     case DeepLinkType::kUnsupported:
-    case DeepLinkType::kLists:
-    case DeepLinkType::kNotes:
     case DeepLinkType::kOnboarding:
     case DeepLinkType::kQuery:
     case DeepLinkType::kReminders:
@@ -251,10 +239,6 @@
       std::move(request));
 }
 
-bool AssistantController::IsAssistantReady() const {
-  return !!assistant_;
-}
-
 void AssistantController::NotifyConstructed() {
   for (AssistantControllerObserver& observer : observers_)
     observer.OnAssistantControllerConstructed();
@@ -293,14 +277,12 @@
 
 void AssistantController::SendAssistantFeedback(
     bool assistant_debug_info_allowed,
-    const std::string& feedback_description,
-    const std::string& screenshot_png) {
+    const std::string& feedback_description) {
   chromeos::assistant::mojom::AssistantFeedbackPtr assistant_feedback =
       chromeos::assistant::mojom::AssistantFeedback::New();
   assistant_feedback->assistant_debug_info_allowed =
       assistant_debug_info_allowed;
   assistant_feedback->description = feedback_description;
-  assistant_feedback->screenshot_png = screenshot_png;
   assistant_->SendAssistantFeedback(std::move(assistant_feedback));
 }
 
--- a/ash/assistant/assistant_controller.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/assistant_controller.h	2019-05-17 18:53:08.100000000 +0300
@@ -85,8 +85,7 @@
   void OpenAssistantSettings() override;
   void StartSpeakerIdEnrollmentFlow() override;
   void SendAssistantFeedback(bool assistant_debug_info_allowed,
-                             const std::string& feedback_description,
-                             const std::string& screenshot_png) override;
+                             const std::string& feedback_description) override;
 
   // AssistantControllerObserver:
   void OnDeepLinkReceived(
@@ -142,8 +141,6 @@
 
   AssistantViewDelegate* view_delegate() { return &view_delegate_; }
 
-  bool IsAssistantReady() const;
-
   base::WeakPtr<AssistantController> GetWeakPtr();
 
  private:
--- a/ash/assistant/assistant_interaction_controller.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/assistant_interaction_controller.cc	2019-05-17 18:53:08.100000000 +0300
@@ -16,10 +16,8 @@
 #include "ash/assistant/model/assistant_ui_element.h"
 #include "ash/assistant/model/assistant_ui_model.h"
 #include "ash/assistant/ui/assistant_ui_constants.h"
-#include "ash/assistant/util/assistant_util.h"
 #include "ash/assistant/util/deep_link_util.h"
 #include "ash/assistant/util/histogram_util.h"
-#include "ash/public/cpp/app_list/app_list_features.h"
 #include "ash/public/cpp/ash_pref_names.h"
 #include "ash/public/interfaces/voice_interaction_controller.mojom.h"
 #include "ash/session/session_controller.h"
@@ -27,7 +25,6 @@
 #include "ash/strings/grit/ash_strings.h"
 #include "ash/voice_interaction/voice_interaction_controller.h"
 #include "ash/wm/tablet_mode/tablet_mode_controller.h"
-#include "base/bind.h"
 #include "base/optional.h"
 #include "base/strings/utf_string_conversions.h"
 #include "chromeos/services/assistant/public/features.h"
@@ -91,11 +88,9 @@
 
 void AssistantInteractionController::OnAssistantControllerConstructed() {
   assistant_controller_->ui_controller()->AddModelObserver(this);
-  assistant_controller_->view_delegate()->AddObserver(this);
 }
 
 void AssistantInteractionController::OnAssistantControllerDestroying() {
-  assistant_controller_->view_delegate()->RemoveObserver(this);
   assistant_controller_->ui_controller()->RemoveModelObserver(this);
 }
 
@@ -134,20 +129,9 @@
     return;
   }
 
-  // Explicitly call ShowUi() to set the correct Assistant entry point.
-  // ShowUi() will no-op if UI is already shown.
   assistant_controller_->ui_controller()->ShowUi(
       AssistantEntryPoint::kDeepLink);
-
-  // A text query originating from a deep link will carry forward the allowance/
-  // forbiddance of TTS from the previous response. This is predominately aimed
-  // at addressing the use case of tapping a card from a previous query response
-  // in which case we are essentially continuing the preceding interaction. Deep
-  // links are also potentially fired from notifications or other sources. If we
-  // need to allow deep link creators the ability to set |allow_tts| explicitly,
-  // we can expose a deep link parameter when the need arises.
-  StartTextInteraction(query.value(), /*allow_tts=*/model_.response() &&
-                                          model_.response()->has_tts(),
+  StartTextInteraction(query.value(), /*allow_tts=*/false,
                        /*query_source=*/AssistantQuerySource::kDeepLink);
 }
 
@@ -211,13 +195,10 @@
     HighlighterEnabledState state) {
   switch (state) {
     case HighlighterEnabledState::kEnabled:
-      // Skip setting input modality to stylus when the embedded Assistant
-      // feature is enabled to prevent highlighter aborting sessions in
-      // OnUiModeChanged.
-      if (!app_list_features::IsEmbeddedAssistantUIEnabled())
         model_.SetInputModality(InputModality::kStylus);
       break;
     case HighlighterEnabledState::kDisabledByUser:
+      FALLTHROUGH;
     case HighlighterEnabledState::kDisabledBySessionComplete:
       model_.SetInputModality(InputModality::kKeyboard);
       break;
@@ -232,7 +213,6 @@
 
 void AssistantInteractionController::OnHighlighterSelectionRecognized(
     const gfx::Rect& rect) {
-  assistant_controller_->ui_controller()->ShowUi(AssistantEntryPoint::kStylus);
   StartMetalayerInteraction(/*region=*/rect);
 }
 
@@ -532,11 +512,6 @@
     // earliest indication that the mic has closed.
     model_.SetMicState(MicState::kClosed);
 
-    // It is possible that an error Tts could be sent in addition to server Tts.
-    // In that case, the pending_response may have already been finalized.
-    if (!model_.pending_response())
-      model_.SetPendingResponse(std::make_unique<AssistantResponse>());
-
     // Add an error message to the response.
     model_.pending_response()->AddUiElement(
         std::make_unique<AssistantTextElement>(
@@ -547,8 +522,6 @@
   // We have an agreement with the server that TTS will always be the last part
   // of an interaction to be processed. To be timely in updating UI, we use
   // this as an opportunity to begin processing the Assistant response.
-  // TODO(xiaohuic): sometimes we actually do receive additional TTS responses,
-  // need to properly handle those cases.
   OnProcessPendingResponse();
 }
 
@@ -635,49 +608,38 @@
 
   const bool launch_with_mic_open =
       Shell::Get()->voice_interaction_controller()->launch_with_mic_open();
-  const bool prefer_voice = launch_with_mic_open || IsTabletMode();
 
-  // We don't explicitly start a new voice interaction if the entry point
-  // is hotword since in such cases a voice interaction will already be in
-  // progress.
-  if (assistant::util::IsVoiceEntryPoint(entry_point, prefer_voice) &&
-      entry_point != AssistantEntryPoint::kHotword) {
-    should_attempt_warmer_welcome_ = false;
+  switch (entry_point) {
+    case AssistantEntryPoint::kHotkey:
+    case AssistantEntryPoint::kLauncherSearchBox:
+    case AssistantEntryPoint::kLongPressLauncher: {
+      // When the user prefers it or when we are in tablet mode, launching
+      // Assistant UI will immediately start a voice interaction.
+      if (launch_with_mic_open || IsTabletMode()) {
     StartVoiceInteraction();
-    return;
-  }
-
-  if (entry_point == AssistantEntryPoint::kStylus) {
     should_attempt_warmer_welcome_ = false;
-    // When the embedded Assistant feature is enabled, we call ShowUi(kStylus)
-    // OnHighlighterSelectionRecognized. But we are not actually using stylus.
-    if (!app_list_features::IsEmbeddedAssistantUIEnabled())
-      model_.SetInputModality(InputModality::kStylus);
-    return;
   }
-
-  if (!chromeos::assistant::features::IsWarmerWelcomeEnabled())
-    return;
-
-  should_attempt_warmer_welcome_ =
-      should_attempt_warmer_welcome_ &&
-      assistant::util::ShouldAttemptWarmerWelcome(entry_point);
-
-  // Explicitly check the interaction state to ensure warmer welcome will
-  // not interrupt any ongoing active interactions. This happens, for example,
-  // when the first Assistant launch of the current user session is trigger by
-  // Assistant notification, or directly sending query without showing Ui
-  // during integration test.
-  if (model_.interaction_state() == InteractionState::kActive)
+      break;
+    }
+    case AssistantEntryPoint::kStylus:
+      model_.SetInputModality(InputModality::kStylus);
+      FALLTHROUGH;
+    case AssistantEntryPoint::kDeepLink:
+    case AssistantEntryPoint::kHotword:
     should_attempt_warmer_welcome_ = false;
-
-  if (!should_attempt_warmer_welcome_)
-    return;
+      break;
+    case AssistantEntryPoint::kUnspecified:
+    case AssistantEntryPoint::kSetup:
+      // No action necessary.
+      break;
+  }
 
   // TODO(yileili): Currently WW is only triggered when the first Assistant
   // launch of the user session does not automatically start an interaction that
   // would otherwise cause us to interrupt the user. Need further UX design to
   // attempt WW after the first interaction.
+  if (should_attempt_warmer_welcome_) {
+    if (chromeos::assistant::features::IsWarmerWelcomeEnabled()) {
   auto* pref_service =
       Shell::Get()->session_controller()->GetLastActiveUserPrefService();
 
@@ -694,7 +656,9 @@
     pref_service->SetInteger(prefs::kAssistantNumWarmerWelcomeTriggered,
                              ++num_warmer_welcome_triggered);
   }
+    }
   should_attempt_warmer_welcome_ = false;
+  }
 }
 
 void AssistantInteractionController::StartMetalayerInteraction(
--- a/ash/assistant/assistant_interaction_controller.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/assistant_interaction_controller.h	2019-05-17 18:53:08.100000000 +0300
@@ -14,7 +14,7 @@
 #include "ash/assistant/model/assistant_interaction_model.h"
 #include "ash/assistant/model/assistant_interaction_model_observer.h"
 #include "ash/assistant/model/assistant_ui_model_observer.h"
-#include "ash/assistant/ui/assistant_view_delegate.h"
+#include "ash/assistant/ui/dialog_plate/dialog_plate.h"
 #include "ash/highlighter/highlighter_controller.h"
 #include "base/macros.h"
 #include "base/memory/weak_ptr.h"
@@ -33,8 +33,8 @@
       public AssistantControllerObserver,
       public AssistantInteractionModelObserver,
       public AssistantUiModelObserver,
-      public AssistantViewDelegateObserver,
-      public HighlighterController::Observer {
+      public HighlighterController::Observer,
+      public DialogPlateObserver {
  public:
   using AssistantSuggestion = chromeos::assistant::mojom::AssistantSuggestion;
   using AssistantSuggestionPtr =
@@ -100,10 +100,12 @@
   void OnSpeechLevelUpdated(float speech_level) override;
   void OnTtsStarted(bool due_to_error) override;
 
-  // AssistantViewDelegateObserver:
+  // DialogPlateObserver:
   void OnDialogPlateButtonPressed(AssistantButtonId id) override;
   void OnDialogPlateContentsCommitted(const std::string& text) override;
-  void OnSuggestionChipPressed(const AssistantSuggestion* suggestion) override;
+
+  // Invoked on suggestion chip pressed event.
+  void OnSuggestionChipPressed(const AssistantSuggestion* suggestion);
 
  private:
   bool HasUnprocessedPendingResponse();
--- a/ash/assistant/assistant_notification_controller.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/assistant_notification_controller.cc	2019-05-17 18:53:08.100000000 +0300
@@ -4,9 +4,6 @@
 
 #include "ash/assistant/assistant_notification_controller.h"
 
-#include <memory>
-#include <utility>
-
 #include "ash/assistant/assistant_controller.h"
 #include "ash/assistant/util/deep_link_util.h"
 #include "ash/new_window_controller.h"
@@ -51,8 +48,7 @@
           /*delegate=*/nullptr, kNotificationAssistantIcon,
           message_center::SystemNotificationWarningLevel::NORMAL);
 
-  if (notification->is_high_priority)
-    system_notification->set_priority(message_center::HIGH_PRIORITY);
+  system_notification->set_priority(message_center::DEFAULT_PRIORITY);
 
   return system_notification;
 }
@@ -62,13 +58,6 @@
       message_center::NotifierType::SYSTEM_COMPONENT, kNotifierId);
 }
 
-bool IsSystemNotification(
-    const chromeos::assistant::mojom::AssistantNotification* notification) {
-  using chromeos::assistant::mojom::AssistantNotificationType;
-  return notification->type == AssistantNotificationType::kPreferInAssistant ||
-         notification->type == AssistantNotificationType::kSystem;
-}
-
 bool IsValidActionUrl(const GURL& action_url) {
   return action_url.is_valid() && (action_url.SchemeIsHTTPOrHTTPS() ||
                                    assistant::util::IsDeepLinkUrl(action_url));
@@ -84,13 +73,11 @@
       binding_(this),
       notifier_id_(GetNotifierId()) {
   AddModelObserver(this);
-  assistant_controller_->AddObserver(this);
   message_center::MessageCenter::Get()->AddObserver(this);
 }
 
 AssistantNotificationController::~AssistantNotificationController() {
   message_center::MessageCenter::Get()->RemoveObserver(this);
-  assistant_controller_->RemoveObserver(this);
   RemoveModelObserver(this);
 }
 
@@ -114,69 +101,10 @@
   assistant_ = assistant;
 }
 
-// AssistantControllerObserver -------------------------------------------------
-
-void AssistantNotificationController::OnAssistantControllerConstructed() {
-  assistant_controller_->ui_controller()->AddModelObserver(this);
-}
-
-void AssistantNotificationController::OnAssistantControllerDestroying() {
-  assistant_controller_->ui_controller()->RemoveModelObserver(this);
-}
-
-// AssistantUiModelObserver ----------------------------------------------------
-
-void AssistantNotificationController::OnUiVisibilityChanged(
-    AssistantVisibility new_visibility,
-    AssistantVisibility old_visibility,
-    base::Optional<AssistantEntryPoint> entry_point,
-    base::Optional<AssistantExitPoint> exit_point) {
-  switch (new_visibility) {
-    case AssistantVisibility::kVisible:
-      // When the Assistant UI becomes visible we convert any notifications of
-      // type |kPreferInAssistant| to type |kInAssistant|. This will cause them
-      // to be removed from the Message Center (if they had previously been
-      // added) and to finish out their lifetimes as in-Assistant notifications.
-      for (const auto* notification : model_.GetNotificationsByType(
-               AssistantNotificationType::kPreferInAssistant)) {
-        auto update = notification->Clone();
-        update->type = AssistantNotificationType::kInAssistant;
-        model_.AddOrUpdateNotification(std::move(update));
-      }
-      break;
-    case AssistantVisibility::kHidden:
-    case AssistantVisibility::kClosed:
-      // When the Assistant UI is no longer visible to the user we remove any
-      // notifications of type |kInAssistant| as this type of notification does
-      // not outlive the Assistant view hierarchy.
-      if (old_visibility == AssistantVisibility::kVisible) {
-        for (const auto* notification : model_.GetNotificationsByType(
-                 AssistantNotificationType::kInAssistant)) {
-          model_.RemoveNotificationById(notification->client_id,
-                                        /*from_server=*/false);
-        }
-      }
-      break;
-  }
-}
-
 // mojom::AssistantNotificationController --------------------------------------
 
 void AssistantNotificationController::AddOrUpdateNotification(
     AssistantNotificationPtr notification) {
-  const AssistantVisibility visibility =
-      assistant_controller_->ui_controller()->model()->visibility();
-
-  // If Assistant UI is visible and |notification| is of type
-  // |kPreferInAssistant|, we convert it to a notification of type
-  // |kInAssistant|. This will cause the notification to be removed from the
-  // Message Center (if it had previously been added) and it will finish out its
-  // lifetime as an in-Assistant notification.
-  if (visibility == AssistantVisibility::kVisible &&
-      notification->type == AssistantNotificationType::kPreferInAssistant) {
-    notification->type = AssistantNotificationType::kInAssistant;
-  }
-
   model_.AddOrUpdateNotification(std::move(notification));
 }
 
@@ -204,10 +132,6 @@
   if (!Shell::Get()->voice_interaction_controller()->notification_enabled())
     return;
 
-  // We only show system notifications in the Message Center.
-  if (!IsSystemNotification(notification))
-    return;
-
   message_center::MessageCenter::Get()->AddNotification(
       CreateSystemNotification(notifier_id_, notification));
 }
@@ -218,15 +142,6 @@
   if (!Shell::Get()->voice_interaction_controller()->notification_enabled())
     return;
 
-  // If the notification that was updated is *not* a system notification, we
-  // need to ensure that it is removed from the Message Center (given that it
-  // may have been a system notification prior to update).
-  if (!IsSystemNotification(notification)) {
-    message_center::MessageCenter::Get()->RemoveNotification(
-        notification->client_id, /*by_user=*/false);
-    return;
-  }
-
   message_center::MessageCenter::Get()->UpdateNotification(
       notification->client_id,
       CreateSystemNotification(notifier_id_, notification));
@@ -285,12 +200,6 @@
 void AssistantNotificationController::OnNotificationRemoved(
     const std::string& notification_id,
     bool by_user) {
-  // If the notification that was removed is a system notification, we need to
-  // update our notification model. If it is *not* a system notification, then
-  // the notification was removed from the Message Center due to a change of
-  // |type| so it should be retained in the model.
-  const auto* notification = model_.GetNotificationById(notification_id);
-  if (notification && IsSystemNotification(notification))
     model_.RemoveNotificationById(notification_id, /*from_server=*/false);
 }
 
--- a/ash/assistant/assistant_notification_controller.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/assistant_notification_controller.h	2019-05-17 18:53:08.100000000 +0300
@@ -8,10 +8,8 @@
 #include <string>
 
 #include "ash/ash_export.h"
-#include "ash/assistant/assistant_controller_observer.h"
 #include "ash/assistant/model/assistant_notification_model.h"
 #include "ash/assistant/model/assistant_notification_model_observer.h"
-#include "ash/assistant/model/assistant_ui_model_observer.h"
 #include "ash/public/interfaces/assistant_controller.mojom.h"
 #include "base/macros.h"
 #include "chromeos/services/assistant/public/mojom/assistant.mojom.h"
@@ -26,8 +24,6 @@
 // The class to manage Assistant notifications.
 class ASH_EXPORT AssistantNotificationController
     : public mojom::AssistantNotificationController,
-      public AssistantControllerObserver,
-      public AssistantUiModelObserver,
       public AssistantNotificationModelObserver,
       public message_center::MessageCenterObserver {
  public:
@@ -35,8 +31,6 @@
       chromeos::assistant::mojom::AssistantNotification;
   using AssistantNotificationPtr =
       chromeos::assistant::mojom::AssistantNotificationPtr;
-  using AssistantNotificationType =
-      chromeos::assistant::mojom::AssistantNotificationType;
 
   explicit AssistantNotificationController(
       AssistantController* assistant_controller);
@@ -54,17 +48,6 @@
   // Provides a pointer to the |assistant| owned by AssistantController.
   void SetAssistant(chromeos::assistant::mojom::Assistant* assistant);
 
-  // AssistantControllerObserver:
-  void OnAssistantControllerConstructed() override;
-  void OnAssistantControllerDestroying() override;
-
-  // AssistantUiModelObserver:
-  void OnUiVisibilityChanged(
-      AssistantVisibility new_visibility,
-      AssistantVisibility old_visibility,
-      base::Optional<AssistantEntryPoint> entry_point,
-      base::Optional<AssistantExitPoint> exit_point) override;
-
   // mojom::AssistantNotificationController:
   void AddOrUpdateNotification(AssistantNotificationPtr notification) override;
   void RemoveNotificationById(const std::string& id, bool from_server) override;
--- a/ash/assistant/assistant_screen_context_controller.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/assistant_screen_context_controller.cc	2019-05-17 18:53:08.100000000 +0300
@@ -16,7 +16,6 @@
 #include "ash/shell.h"
 #include "ash/voice_interaction/voice_interaction_controller.h"
 #include "ash/wm/mru_window_tracker.h"
-#include "ash/wm/overview/overview_controller.h"
 #include "base/bind.h"
 #include "base/memory/scoped_refptr.h"
 #include "base/stl_util.h"
@@ -85,14 +84,10 @@
 
   aura::Window* app_list_container =
       ash::Shell::GetContainer(root_window, kShellWindowId_AppListContainer);
-  aura::Window* app_list_tablet_mode_container = ash::Shell::GetContainer(
-      root_window, kShellWindowId_AppListTabletModeContainer);
 
   // Ignore app list to prevent interfering with app list animations.
   if (app_list_container)
     excluded_layers.insert(app_list_container->layer());
-  if (app_list_tablet_mode_container)
-    excluded_layers.insert(app_list_tablet_mode_container->layer());
 
   MruWindowTracker::WindowList windows =
       Shell::Get()->mru_window_tracker()->BuildMruWindowList();
@@ -170,13 +165,6 @@
     const gfx::Rect& rect,
     mojom::AssistantScreenContextController::RequestScreenshotCallback
         callback) {
-  // http://crbug.com/941276
-  // We need to avoid requesting screenshot in known situations that will break.
-  if (Shell::Get()->overview_controller()->IsSelecting() ||
-      Shell::Get()->overview_controller()->IsCompletingShutdownAnimations()) {
-    std::move(callback).Run(std::vector<uint8_t>());
-    return;
-  }
   aura::Window* root_window = Shell::Get()->GetRootWindowForNewWindows();
 
   std::unique_ptr<ui::LayerTreeOwner> layer_owner =
--- a/ash/assistant/assistant_screen_context_controller_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/assistant_screen_context_controller_unittest.cc	2019-05-17 18:53:08.100000000 +0300
@@ -11,7 +11,6 @@
 #include "ash/public/cpp/window_properties.h"
 #include "ash/shell.h"
 #include "ash/test/ash_test_base.h"
-#include "base/bind.h"
 #include "base/macros.h"
 #include "base/test/scoped_feature_list.h"
 #include "chromeos/constants/chromeos_switches.h"
--- a/ash/assistant/assistant_setup_controller.cc	2019-05-17 17:45:36.492000000 +0300
+++ b/ash/assistant/assistant_setup_controller.cc	2019-05-17 18:53:08.100000000 +0300
@@ -7,20 +7,6 @@
 #include "ash/assistant/assistant_controller.h"
 #include "ash/assistant/assistant_ui_controller.h"
 #include "ash/assistant/util/deep_link_util.h"
-#include "ash/assistant/util/i18n_util.h"
-#include "ash/public/interfaces/voice_interaction_controller.mojom.h"
-#include "ash/shell.h"
-#include "ash/voice_interaction/voice_interaction_controller.h"
-#include "base/bind.h"
-#include "base/bind_helpers.h"
-#include "chromeos/services/assistant/public/features.h"
-
-namespace {
-
-constexpr char kGSuiteAdministratorInstructionsUrl[] =
-    "https://support.9oo91e.qjz9zk/a/answer/6304876";
-
-}  // namespace
 
 namespace ash {
 
@@ -44,14 +30,6 @@
   assistant_setup_ = std::move(assistant_setup);
 }
 
-void AssistantSetupController::OnAssistantControllerConstructed() {
-  assistant_controller_->view_delegate()->AddObserver(this);
-}
-
-void AssistantSetupController::OnAssistantControllerDestroying() {
-  assistant_controller_->view_delegate()->RemoveObserver(this);
-}
-
 void AssistantSetupController::OnDeepLinkReceived(
     assistant::util::DeepLinkType type,
     const std::map<std::string, std::string>& params) {
@@ -67,16 +45,7 @@
 }
 
 void AssistantSetupController::OnOptInButtonPressed() {
-  mojom::ConsentStatus consent_status =
-      Shell::Get()->voice_interaction_controller()->consent_status().value_or(
-          mojom::ConsentStatus::kUnknown);
-
-  if (consent_status == mojom::ConsentStatus::kUnauthorized) {
-    assistant_controller_->OpenUrl(assistant::util::CreateLocalizedGURL(
-        kGSuiteAdministratorInstructionsUrl));
-  } else {
     StartOnboarding(/*relaunch=*/true);
-  }
 }
 
 void AssistantSetupController::StartOnboarding(bool relaunch,
--- a/ash/assistant/assistant_setup_controller.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/assistant_setup_controller.h	2019-05-17 18:53:08.100000000 +0300
@@ -9,7 +9,7 @@
 #include <string>
 
 #include "ash/assistant/assistant_controller_observer.h"
-#include "ash/assistant/ui/assistant_view_delegate.h"
+#include "ash/assistant/ui/main_stage/assistant_opt_in_view.h"
 #include "ash/public/interfaces/assistant_controller.mojom.h"
 #include "ash/public/interfaces/assistant_setup.mojom.h"
 #include "base/macros.h"
@@ -21,7 +21,7 @@
 
 class AssistantSetupController : public mojom::AssistantSetupController,
                                  public AssistantControllerObserver,
-                                 public AssistantViewDelegateObserver {
+                                 public AssistantOptInDelegate {
  public:
   explicit AssistantSetupController(AssistantController* assistant_controller);
   ~AssistantSetupController() override;
@@ -32,13 +32,11 @@
   void SetAssistantSetup(mojom::AssistantSetupPtr assistant_setup) override;
 
   // AssistantControllerObserver:
-  void OnAssistantControllerConstructed() override;
-  void OnAssistantControllerDestroying() override;
   void OnDeepLinkReceived(
       assistant::util::DeepLinkType type,
       const std::map<std::string, std::string>& params) override;
 
-  // AssistantViewDelegateObserver:
+  // AssistantOptInDelegate:
   void OnOptInButtonPressed() override;
 
   void StartOnboarding(bool relaunch,
--- a/ash/assistant/assistant_ui_controller.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/assistant_ui_controller.cc	2019-05-17 18:53:08.100000000 +0300
@@ -9,18 +9,15 @@
 #include "ash/assistant/assistant_screen_context_controller.h"
 #include "ash/assistant/ui/assistant_container_view.h"
 #include "ash/assistant/ui/assistant_ui_constants.h"
-#include "ash/assistant/util/assistant_util.h"
 #include "ash/assistant/util/deep_link_util.h"
 #include "ash/assistant/util/histogram_util.h"
 #include "ash/multi_user/multi_user_window_manager.h"
-#include "ash/public/cpp/app_list/app_list_features.h"
 #include "ash/session/session_controller.h"
 #include "ash/shell.h"
 #include "ash/strings/grit/ash_strings.h"
 #include "ash/system/toast/toast_data.h"
 #include "ash/system/toast/toast_manager.h"
 #include "ash/voice_interaction/voice_interaction_controller.h"
-#include "base/bind.h"
 #include "base/optional.h"
 #include "chromeos/services/assistant/public/mojom/assistant.mojom.h"
 #include "ui/base/l10n/l10n_util.h"
@@ -35,8 +32,6 @@
 // Toast -----------------------------------------------------------------------
 
 constexpr int kToastDurationMs = 2500;
-
-constexpr char kStylusPromptToastId[] = "stylus_prompt_for_embedded_ui";
 constexpr char kUnboundServiceToastId[] =
     "assistant_controller_unbound_service";
 
@@ -137,22 +132,27 @@
   if (model_.visibility() != AssistantVisibility::kVisible)
     return;
 
-  // TODO(wutao): Behavior is not defined.
-  if (model_.ui_mode() == AssistantUiMode::kLauncherEmbeddedUi)
-    return;
-
   // Once screen context request state has become idle, it is safe to activate
   // the Assistant widget without causing complications.
-  if (container_view_ && request_state == ScreenContextRequestState::kIdle)
+  if (request_state == ScreenContextRequestState::kIdle)
     container_view_->GetWidget()->Activate();
 }
 
+void AssistantUiController::OnAssistantMiniViewPressed() {
+  InputModality input_modality = assistant_controller_->interaction_controller()
+                                     ->model()
+                                     ->input_modality();
+
+  // When not using stylus input modality, pressing the Assistant mini view
+  // will cause the UI to expand.
+  if (input_modality != InputModality::kStylus)
+    UpdateUiMode(AssistantUiMode::kMainUi);
+}
+
 bool AssistantUiController::OnCaptionButtonPressed(AssistantButtonId id) {
   switch (id) {
     case AssistantButtonId::kBack:
-      UpdateUiMode(app_list_features::IsEmbeddedAssistantUIEnabled()
-                       ? AssistantUiMode::kLauncherEmbeddedUi
-                       : AssistantUiMode::kMainUi);
+      UpdateUiMode(AssistantUiMode::kMainUi);
       return true;
     case AssistantButtonId::kClose:
       CloseUi(AssistantExitPoint::kCloseButton);
@@ -178,27 +178,8 @@
       assistant::util::CreateAssistantSettingsDeepLink());
 }
 
-void AssistantUiController::OnMiniViewPressed() {
-  InputModality input_modality = assistant_controller_->interaction_controller()
-                                     ->model()
-                                     ->input_modality();
-
-  // When not using stylus input modality, pressing the Assistant mini view
-  // will cause the UI to expand.
-  if (input_modality != InputModality::kStylus)
-    UpdateUiMode(AssistantUiMode::kMainUi);
-}
-
 void AssistantUiController::OnHighlighterEnabledChanged(
     HighlighterEnabledState state) {
-  if (app_list_features::IsEmbeddedAssistantUIEnabled()) {
-    if (state == HighlighterEnabledState::kEnabled) {
-      ShowToast(kStylusPromptToastId, IDS_ASH_ASSISTANT_PROMPT_STYLUS);
-      CloseUi(AssistantExitPoint::kStylus);
-    }
-    return;
-  }
-
   switch (state) {
     case HighlighterEnabledState::kEnabled:
       if (model_.visibility() != AssistantVisibility::kVisible)
@@ -218,11 +199,9 @@
 void AssistantUiController::OnAssistantControllerConstructed() {
   assistant_controller_->interaction_controller()->AddModelObserver(this);
   assistant_controller_->screen_context_controller()->AddModelObserver(this);
-  assistant_controller_->view_delegate()->AddObserver(this);
 }
 
 void AssistantUiController::OnAssistantControllerDestroying() {
-  assistant_controller_->view_delegate()->RemoveObserver(this);
   assistant_controller_->screen_context_controller()->RemoveModelObserver(this);
   assistant_controller_->interaction_controller()->RemoveModelObserver(this);
 
@@ -251,12 +230,8 @@
   // navigation was initiated by a server response. Otherwise the navigation
   // was user initiated so we only hide the UI to retain session state. That way
   // the user can choose to resume their session if they are so inclined.
-  // However, we close the UI if the feature |IsEmbeddedAssistantUIEnabled| is
-  // enabled, where we only maintain |kVisible| and |kClosed| two states.
   if (from_server)
     CloseUi(AssistantExitPoint::kNewBrowserTabFromServer);
-  else if (app_list_features::IsEmbeddedAssistantUIEnabled())
-    CloseUi(AssistantExitPoint::kNewBrowserTabFromUser);
   else
     HideUi(AssistantExitPoint::kNewBrowserTabFromUser);
 }
@@ -295,15 +270,6 @@
       // Upon becoming visible, we stop the auto close timer.
       auto_close_timer_.Stop();
 
-      // Only record the entry point when Assistant UI becomes visible.
-      assistant::util::RecordAssistantEntryPoint(entry_point.value());
-
-      if (!container_view_) {
-        DCHECK_EQ(AssistantUiMode::kLauncherEmbeddedUi, model_.ui_mode());
-        event_monitor_.reset();
-        break;
-      }
-
       // We need to monitor events for the root window while we're visible to
       // give us an opportunity to dismiss Assistant UI when the user starts an
       // interaction outside of our bounds. TODO(dmblack): Investigate how this
@@ -326,16 +292,18 @@
               /*show_for_current_user=*/true);
         }
       }
+
+      // Only record the entry point when Assistant UI becomes visible.
+      assistant::util::RecordAssistantEntryPoint(entry_point.value());
       break;
   }
 
   // Metalayer should not be sticky. Disable when the UI is no longer visible.
   if (old_visibility == AssistantVisibility::kVisible) {
-    if (exit_point != AssistantExitPoint::kStylus)
       Shell::Get()->highlighter_controller()->AbortSession();
 
     // Only record the exit point when Assistant UI becomes invisible to
-    // avoid recording duplicate events (e.g. pressing ESC key).
+    // avoid duplicate happens (e.g., pressing ESC key).
     assistant::util::RecordAssistantExitPoint(exit_point.value());
   }
 }
@@ -360,14 +328,6 @@
     return;
   }
 
-  if (app_list_features::IsEmbeddedAssistantUIEnabled()) {
-    model_.SetUiMode(AssistantUiMode::kLauncherEmbeddedUi);
-    model_.SetVisible(entry_point);
-    return;
-  }
-
-  DCHECK_NE(AssistantUiMode::kLauncherEmbeddedUi, model_.ui_mode());
-
   if (model_.visibility() == AssistantVisibility::kVisible) {
     // If Assistant window is already visible, we just try to retake focus.
     container_view_->GetWidget()->Activate();
@@ -432,16 +392,7 @@
   // If a UI mode is provided, we will use it in lieu of updating UI mode on the
   // basis of interaction/widget visibility state.
   if (ui_mode.has_value()) {
-    AssistantUiMode mode = ui_mode.value();
-    // TODO(wutao): Behavior is not defined.
-    if (model_.ui_mode() == AssistantUiMode::kLauncherEmbeddedUi)
-      DCHECK_NE(AssistantUiMode::kMiniUi, mode);
-    model_.SetUiMode(mode);
-    return;
-  }
-
-  if (app_list_features::IsEmbeddedAssistantUIEnabled()) {
-    model_.SetUiMode(AssistantUiMode::kLauncherEmbeddedUi);
+    model_.SetUiMode(ui_mode.value());
     return;
   }
 
@@ -563,9 +514,6 @@
 }
 
 void AssistantUiController::CreateContainerView() {
-  DCHECK(!container_view_);
-  DCHECK(!app_list_features::IsEmbeddedAssistantUIEnabled());
-
   container_view_ =
       new AssistantContainerView(assistant_controller_->view_delegate());
   container_view_->GetWidget()->AddObserver(this);
--- a/ash/assistant/assistant_ui_controller.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/assistant_ui_controller.h	2019-05-17 18:53:08.100000000 +0300
@@ -15,8 +15,9 @@
 #include "ash/assistant/model/assistant_screen_context_model_observer.h"
 #include "ash/assistant/model/assistant_ui_model.h"
 #include "ash/assistant/model/assistant_ui_model_observer.h"
-#include "ash/assistant/ui/assistant_view_delegate.h"
+#include "ash/assistant/ui/assistant_mini_view.h"
 #include "ash/assistant/ui/caption_bar.h"
+#include "ash/assistant/ui/dialog_plate/dialog_plate.h"
 #include "ash/highlighter/highlighter_controller.h"
 #include "base/macros.h"
 #include "base/optional.h"
@@ -51,8 +52,9 @@
       public AssistantInteractionModelObserver,
       public AssistantScreenContextModelObserver,
       public AssistantUiModelObserver,
-      public AssistantViewDelegateObserver,
+      public AssistantMiniViewDelegate,
       public CaptionBarDelegate,
+      public DialogPlateObserver,
       public HighlighterController::Observer,
       public keyboard::KeyboardControllerObserver,
       public display::DisplayObserver,
@@ -85,12 +87,14 @@
   void OnScreenContextRequestStateChanged(
       ScreenContextRequestState request_state) override;
 
+  // AssistantMiniViewDelegate:
+  void OnAssistantMiniViewPressed() override;
+
   // CaptionBarDelegate:
   bool OnCaptionButtonPressed(AssistantButtonId id) override;
 
-  // AssistantViewDelegateObserver:
+  // DialogPlateObserver:
   void OnDialogPlateButtonPressed(AssistantButtonId id) override;
-  void OnMiniViewPressed() override;
 
   // HighlighterController::Observer:
   void OnHighlighterEnabledChanged(HighlighterEnabledState state) override;
--- a/ash/assistant/assistant_view_delegate_impl.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/assistant_view_delegate_impl.cc	2019-05-17 18:53:08.100000000 +0300
@@ -8,7 +8,6 @@
 #include "ash/assistant/assistant_controller.h"
 #include "ash/assistant/assistant_controller_observer.h"
 #include "ash/assistant/assistant_interaction_controller.h"
-#include "ash/assistant/assistant_notification_controller.h"
 #include "ash/shell.h"
 #include "ash/voice_interaction/voice_interaction_controller.h"
 #include "ash/wm/tablet_mode/tablet_mode_controller.h"
@@ -30,25 +29,10 @@
   return assistant_controller_->interaction_controller()->model();
 }
 
-const AssistantNotificationModel*
-AssistantViewDelegateImpl::GetNotificationModel() const {
-  return assistant_controller_->notification_controller()->model();
-}
-
 const AssistantUiModel* AssistantViewDelegateImpl::GetUiModel() const {
   return assistant_controller_->ui_controller()->model();
 }
 
-void AssistantViewDelegateImpl::AddObserver(
-    AssistantViewDelegateObserver* observer) {
-  view_delegate_observers_.AddObserver(observer);
-}
-
-void AssistantViewDelegateImpl::RemoveObserver(
-    AssistantViewDelegateObserver* observer) {
-  view_delegate_observers_.RemoveObserver(observer);
-}
-
 void AssistantViewDelegateImpl::AddCacheModelObserver(
     AssistantCacheModelObserver* observer) {
   assistant_controller_->cache_controller()->AddModelObserver(observer);
@@ -63,24 +46,12 @@
     AssistantInteractionModelObserver* observer) {
   assistant_controller_->interaction_controller()->AddModelObserver(observer);
 }
-
 void AssistantViewDelegateImpl::RemoveInteractionModelObserver(
     AssistantInteractionModelObserver* observer) {
   assistant_controller_->interaction_controller()->RemoveModelObserver(
       observer);
 }
 
-void AssistantViewDelegateImpl::AddNotificationModelObserver(
-    AssistantNotificationModelObserver* observer) {
-  assistant_controller_->notification_controller()->AddModelObserver(observer);
-}
-
-void AssistantViewDelegateImpl::RemoveNotificationModelObserver(
-    AssistantNotificationModelObserver* observer) {
-  assistant_controller_->notification_controller()->RemoveModelObserver(
-      observer);
-}
-
 void AssistantViewDelegateImpl::AddUiModelObserver(
     AssistantUiModelObserver* observer) {
   assistant_controller_->ui_controller()->AddModelObserver(observer);
@@ -85,12 +56,20 @@
     AssistantUiModelObserver* observer) {
   assistant_controller_->ui_controller()->AddModelObserver(observer);
 }
-
 void AssistantViewDelegateImpl::RemoveUiModelObserver(
     AssistantUiModelObserver* observer) {
   assistant_controller_->ui_controller()->RemoveModelObserver(observer);
 }
 
+void AssistantViewDelegateImpl::AddViewDelegateObserver(
+    AssistantViewDelegateObserver* observer) {
+  view_delegate_observers_.AddObserver(observer);
+}
+void AssistantViewDelegateImpl::RemoveViewDelegateObserver(
+    AssistantViewDelegateObserver* observer) {
+  view_delegate_observers_.RemoveObserver(observer);
+}
+
 void AssistantViewDelegateImpl::AddVoiceInteractionControllerObserver(
     DefaultVoiceInteractionObserver* observer) {
   Shell::Get()->voice_interaction_controller()->AddLocalObserver(observer);
@@ -105,20 +83,27 @@
   return assistant_controller_->ui_controller();
 }
 
+std::vector<DialogPlateObserver*>
+AssistantViewDelegateImpl::GetDialogPlateObservers() {
+  return {assistant_controller_->interaction_controller(),
+          assistant_controller_->ui_controller()};
+}
+
+AssistantMiniViewDelegate* AssistantViewDelegateImpl::GetMiniViewDelegate() {
+  return assistant_controller_->ui_controller();
+}
+
+AssistantOptInDelegate* AssistantViewDelegateImpl::GetOptInDelegate() {
+  return assistant_controller_->setup_controller();
+}
+
 void AssistantViewDelegateImpl::DownloadImage(
     const GURL& url,
     mojom::AssistantImageDownloader::DownloadCallback callback) {
   assistant_controller_->DownloadImage(url, std::move(callback));
 }
 
-mojom::ConsentStatus AssistantViewDelegateImpl::GetConsentStatus() const {
-  return Shell::Get()
-      ->voice_interaction_controller()
-      ->consent_status()
-      .value_or(mojom::ConsentStatus::kUnknown);
-}
-
-::wm::CursorManager* AssistantViewDelegateImpl::GetCursorManager() {
+wm::CursorManager* AssistantViewDelegateImpl::GetCursorManager() {
   return Shell::Get()->cursor_manager();
 }
 
@@ -131,49 +116,16 @@
   return Shell::Get()->GetRootWindowForNewWindows();
 }
 
-bool AssistantViewDelegateImpl::IsLaunchWithMicOpen() const {
-  return Shell::Get()->voice_interaction_controller()->launch_with_mic_open();
-}
-
 bool AssistantViewDelegateImpl::IsTabletMode() const {
   return Shell::Get()
       ->tablet_mode_controller()
       ->IsTabletModeWindowManagerEnabled();
 }
 
-void AssistantViewDelegateImpl::OnDialogPlateButtonPressed(
-    AssistantButtonId id) {
-  for (auto& observer : view_delegate_observers_)
-    observer.OnDialogPlateButtonPressed(id);
-}
-
-void AssistantViewDelegateImpl::OnDialogPlateContentsCommitted(
-    const std::string& text) {
-  for (auto& observer : view_delegate_observers_)
-    observer.OnDialogPlateContentsCommitted(text);
-}
-
-void AssistantViewDelegateImpl::OnMiniViewPressed() {
-  for (auto& observer : view_delegate_observers_)
-    observer.OnMiniViewPressed();
-}
-
-void AssistantViewDelegateImpl::OnNotificationButtonPressed(
-    const std::string& notification_id,
-    int notification_button_index) {
-  assistant_controller_->notification_controller()->OnNotificationClicked(
-      notification_id, notification_button_index, /*reply=*/base::nullopt);
-}
-
-void AssistantViewDelegateImpl::OnOptInButtonPressed() {
-  for (auto& observer : view_delegate_observers_)
-    observer.OnOptInButtonPressed();
-}
-
 void AssistantViewDelegateImpl::OnSuggestionChipPressed(
     const AssistantSuggestion* suggestion) {
-  for (AssistantViewDelegateObserver& observer : view_delegate_observers_)
-    observer.OnSuggestionChipPressed(suggestion);
+  assistant_controller_->interaction_controller()->OnSuggestionChipPressed(
+      suggestion);
 }
 
 void AssistantViewDelegateImpl::OpenUrlFromView(const GURL& url) {
@@ -187,4 +139,12 @@
     observer.OnDeepLinkReceived(type, params);
 }
 
+bool AssistantViewDelegateImpl::VoiceInteractionControllerSetupCompleted()
+    const {
+  return Shell::Get()
+      ->voice_interaction_controller()
+      ->setup_completed()
+      .value_or(false);
+}
+
 }  // namespace ash
--- a/ash/assistant/assistant_view_delegate_impl.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/assistant_view_delegate_impl.h	2019-05-17 18:53:08.100000000 +0300
@@ -5,8 +5,6 @@
 #ifndef ASH_ASSISTANT_ASSISTANT_VIEW_DELEGATE_IMPL_H_
 #define ASH_ASSISTANT_ASSISTANT_VIEW_DELEGATE_IMPL_H_
 
-#include <string>
-
 #include "ash/assistant/ui/assistant_view_delegate.h"
 #include "base/macros.h"
 
@@ -25,48 +23,41 @@
   // AssistantViewDelegate:
   const AssistantCacheModel* GetCacheModel() const override;
   const AssistantInteractionModel* GetInteractionModel() const override;
-  const AssistantNotificationModel* GetNotificationModel() const override;
   const AssistantUiModel* GetUiModel() const override;
-  void AddObserver(AssistantViewDelegateObserver* observer) override;
-  void RemoveObserver(AssistantViewDelegateObserver* observer) override;
   void AddCacheModelObserver(AssistantCacheModelObserver* observer) override;
   void RemoveCacheModelObserver(AssistantCacheModelObserver* observer) override;
   void AddInteractionModelObserver(
       AssistantInteractionModelObserver* observer) override;
   void RemoveInteractionModelObserver(
       AssistantInteractionModelObserver* observer) override;
-  void AddNotificationModelObserver(
-      AssistantNotificationModelObserver* observer) override;
-  void RemoveNotificationModelObserver(
-      AssistantNotificationModelObserver* observer) override;
   void AddUiModelObserver(AssistantUiModelObserver* observer) override;
   void RemoveUiModelObserver(AssistantUiModelObserver* observer) override;
+  void AddViewDelegateObserver(
+      AssistantViewDelegateObserver* observer) override;
+  void RemoveViewDelegateObserver(
+      AssistantViewDelegateObserver* observer) override;
   void AddVoiceInteractionControllerObserver(
       DefaultVoiceInteractionObserver* observer) override;
   void RemoveVoiceInteractionControllerObserver(
       DefaultVoiceInteractionObserver* observer) override;
   CaptionBarDelegate* GetCaptionBarDelegate() override;
+  std::vector<DialogPlateObserver*> GetDialogPlateObservers() override;
+  AssistantMiniViewDelegate* GetMiniViewDelegate() override;
+  AssistantOptInDelegate* GetOptInDelegate() override;
   void DownloadImage(
       const GURL& url,
       mojom::AssistantImageDownloader::DownloadCallback callback) override;
-  mojom::ConsentStatus GetConsentStatus() const override;
-  ::wm::CursorManager* GetCursorManager() override;
+  wm::CursorManager* GetCursorManager() override;
   void GetNavigableContentsFactoryForView(
       content::mojom::NavigableContentsFactoryRequest request) override;
   aura::Window* GetRootWindowForNewWindows() override;
-  bool IsLaunchWithMicOpen() const override;
   bool IsTabletMode() const override;
-  void OnDialogPlateButtonPressed(AssistantButtonId id) override;
-  void OnDialogPlateContentsCommitted(const std::string& text) override;
-  void OnMiniViewPressed() override;
-  void OnNotificationButtonPressed(const std::string& notification_id,
-                                   int notification_button_index) override;
-  void OnOptInButtonPressed() override;
   void OnSuggestionChipPressed(const AssistantSuggestion* suggestion) override;
   void OpenUrlFromView(const GURL& url) override;
+  bool VoiceInteractionControllerSetupCompleted() const override;
 
  private:
-  AssistantController* const assistant_controller_;
+  AssistantController* assistant_controller_;
   base::ObserverList<AssistantViewDelegateObserver> view_delegate_observers_;
 
   DISALLOW_COPY_AND_ASSIGN(AssistantViewDelegateImpl);
--- a/ash/assistant/model/assistant_cache_model.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/model/assistant_cache_model.cc	2019-05-17 18:53:08.100000000 +0300
@@ -48,7 +48,7 @@
     conversation_starters[id++] = starter.get();
 
   return conversation_starters;
-}
+};
 
 void AssistantCacheModel::NotifyConversationStartersChanged() {
   const std::map<int, const AssistantSuggestion*> conversation_starters =
--- a/ash/assistant/model/assistant_notification_model.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/model/assistant_notification_model.cc	2019-05-17 18:53:08.100000000 +0300
@@ -78,17 +78,6 @@
   return it != notifications_.end() ? it->second.get() : nullptr;
 }
 
-std::vector<const chromeos::assistant::mojom::AssistantNotification*>
-AssistantNotificationModel::GetNotificationsByType(
-    AssistantNotificationType type) const {
-  std::vector<const AssistantNotification*> notifications;
-  for (const auto& notification : notifications_) {
-    if (notification.second->type == type)
-      notifications.push_back(notification.second.get());
-  }
-  return notifications;
-}
-
 bool AssistantNotificationModel::HasNotificationForId(
     const std::string& id) const {
   return base::ContainsKey(notifications_, id);
--- a/ash/assistant/model/assistant_notification_model.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/model/assistant_notification_model.h	2019-05-17 18:53:08.100000000 +0300
@@ -7,7 +7,6 @@
 
 #include <map>
 #include <string>
-#include <vector>
 
 #include "base/component_export.h"
 #include "base/macros.h"
@@ -26,8 +25,6 @@
       chromeos::assistant::mojom::AssistantNotification;
   using AssistantNotificationPtr =
       chromeos::assistant::mojom::AssistantNotificationPtr;
-  using AssistantNotificationType =
-      chromeos::assistant::mojom::AssistantNotificationType;
 
   AssistantNotificationModel();
   ~AssistantNotificationModel();
@@ -57,10 +54,6 @@
   // Returns the notification uniquely identified by |id|.
   const AssistantNotification* GetNotificationById(const std::string& id) const;
 
-  // Returns all notifications matching the specified |type|.
-  std::vector<const AssistantNotification*> GetNotificationsByType(
-      AssistantNotificationType type) const;
-
   // Returns true if the model contains a notification uniquely identified by
   // |id|, otherwise false.
   bool HasNotificationForId(const std::string& id) const;
--- a/ash/assistant/model/assistant_query.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/model/assistant_query.cc	2019-05-17 18:53:08.100000000 +0300
@@ -16,7 +16,7 @@
 
 bool AssistantTextQuery::Empty() const {
   return text_.empty();
-}
+};
 
 // AssistantVoiceQuery ---------------------------------------------------------
 
--- a/ash/assistant/model/assistant_response.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/model/assistant_response.cc	2019-05-17 18:53:08.104000000 +0300
@@ -5,7 +5,6 @@
 #include "ash/assistant/model/assistant_response.h"
 
 #include "ash/assistant/model/assistant_ui_element.h"
-#include "base/bind.h"
 
 namespace ash {
 
--- a/ash/assistant/model/assistant_ui_element.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/model/assistant_ui_element.cc	2019-05-17 18:53:08.104000000 +0300
@@ -6,7 +6,6 @@
 
 #include "ash/assistant/ui/assistant_ui_constants.h"
 #include "base/base64.h"
-#include "ui/base/ui_base_features.h"
 
 namespace ash {
 
@@ -66,8 +65,6 @@
 
   contents_ = std::make_unique<content::NavigableContents>(
       contents_factory_, std::move(contents_params));
-  if (features::IsUsingWindowService())
-    contents_->ForceUseWindowService();
 
   // Observe |contents_| so that we are notified when loading is complete.
   contents_->AddObserver(this);
--- a/ash/assistant/model/assistant_ui_model.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/model/assistant_ui_model.cc	2019-05-17 18:53:08.104000000 +0300
@@ -5,14 +5,10 @@
 #include "ash/assistant/model/assistant_ui_model.h"
 
 #include "ash/assistant/model/assistant_ui_model_observer.h"
-#include "ash/public/cpp/app_list/app_list_features.h"
 
 namespace ash {
 
-AssistantUiModel::AssistantUiModel()
-    : ui_mode_(app_list_features::IsEmbeddedAssistantUIEnabled()
-                   ? AssistantUiMode::kLauncherEmbeddedUi
-                   : AssistantUiMode::kMainUi) {}
+AssistantUiModel::AssistantUiModel() = default;
 
 AssistantUiModel::~AssistantUiModel() = default;
 
@@ -33,18 +29,15 @@
 }
 
 void AssistantUiModel::SetVisible(AssistantEntryPoint entry_point) {
-  SetVisibility(AssistantVisibility::kVisible, entry_point,
-                /*exit_point=*/base::nullopt);
+  SetVisibility(AssistantVisibility::kVisible, entry_point, base::nullopt);
 }
 
 void AssistantUiModel::SetHidden(AssistantExitPoint exit_point) {
-  SetVisibility(AssistantVisibility::kHidden,
-                /*entry_point=*/base::nullopt, exit_point);
+  SetVisibility(AssistantVisibility::kHidden, base::nullopt, exit_point);
 }
 
 void AssistantUiModel::SetClosed(AssistantExitPoint exit_point) {
-  SetVisibility(AssistantVisibility::kClosed,
-                /*entry_point=*/base::nullopt, exit_point);
+  SetVisibility(AssistantVisibility::kClosed, base::nullopt, exit_point);
 }
 
 void AssistantUiModel::SetUsableWorkArea(const gfx::Rect& usable_work_area) {
--- a/ash/assistant/model/assistant_ui_model.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/model/assistant_ui_model.h	2019-05-17 18:53:08.104000000 +0300
@@ -26,10 +26,8 @@
   kLongPressLauncher = 5,
   kSetup = 6,
   kStylus = 7,
-  kLauncherSearchResult = 8,
-  kLauncherSearchBoxMic = 9,
   // Special enumerator value used by histogram macros.
-  kMaxValue = kLauncherSearchBoxMic
+  kMaxValue = kStylus
 };
 
 // Enumeration of Assistant exit points. These values are persisted to logs.
@@ -46,11 +44,8 @@
   kOutsidePress = 5,
   kSetup = 6,
   kStylus = 7,
-  kBackInLauncher = 8,
-  kLauncherClose = 9,
-  kLauncherOpen = 10,
   // Special enumerator value used by histogram macros.
-  kMaxValue = kLauncherOpen
+  kMaxValue = kStylus
 };
 
 // Enumeration of Assistant UI modes.
@@ -58,7 +53,6 @@
   kMainUi,
   kMiniUi,
   kWebUi,
-  kLauncherEmbeddedUi,
 };
 
 // Enumeration of Assistant visibility states.
@@ -78,8 +72,7 @@
   kKeyboardInputToggle = 4,
   kVoiceInputToggle = 5,
   kSettings = 6,
-  kBackInLauncherDeprecated = 7,
-  kMaxValue = kBackInLauncherDeprecated
+  kMaxValue = kSettings,
 };
 
 // Models the Assistant UI.
@@ -126,7 +119,7 @@
       base::Optional<AssistantExitPoint> exit_point);
   void NotifyUsableWorkAreaChanged();
 
-  AssistantUiMode ui_mode_;
+  AssistantUiMode ui_mode_ = AssistantUiMode::kMainUi;
 
   AssistantVisibility visibility_ = AssistantVisibility::kClosed;
 
--- a/ash/assistant/model/BUILD.gn	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/model/BUILD.gn	2019-05-17 18:53:08.100000000 +0300
@@ -40,7 +40,6 @@
 
   deps = [
     "//ash/assistant/ui:constants",
-    "//ash/public/cpp",
     "//chromeos/services/assistant/public/mojom",
     "//services/content/public/cpp",
     "//ui/gfx/geometry",
--- a/ash/assistant/model/DEPS	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/model/DEPS	2019-05-17 18:53:08.100000000 +0300
@@ -2,7 +2,6 @@
   "-ash",
   "+ash/assistant/ui/assistant_ui_constants.h",
   "+ash/assistant/model",
-  "+ash/public/cpp/app_list",
   "+chromeos/services/assistant/public" ,
   "+services/content/public",
   "+ui/gfx/geometry",
--- a/ash/assistant/test/test_assistant_service.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/test/test_assistant_service.h	2019-05-17 18:53:08.104000000 +0300
@@ -38,7 +38,7 @@
   void DismissNotification(chromeos::assistant::mojom::AssistantNotificationPtr
                                notification) override {}
   void CacheScreenContext(CacheScreenContextCallback callback) override;
-  void ClearScreenContextCache() override {}
+  void ClearScreenContextCache() override{};
   void OnAccessibilityStatusChanged(bool spoken_feedback_enabled) override {}
   void SendAssistantFeedback(
       chromeos::assistant::mojom::AssistantFeedbackPtr feedback) override {}
--- a/ash/assistant/ui/assistant_container_view_animator.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/ui/assistant_container_view_animator.h	2019-05-17 18:53:08.104000000 +0300
@@ -7,7 +7,6 @@
 
 #include <memory>
 
-#include "base/component_export.h"
 #include "base/macros.h"
 #include "ui/gfx/geometry/size.h"
 #include "ui/views/view_observer.h"
@@ -23,8 +22,7 @@
 
 // The AssistantContainerViewAnimator is the class responsible for smoothly
 // animating bound changes for the AssistantContainerView.
-class COMPONENT_EXPORT(ASSISTANT_UI) AssistantContainerViewAnimator
-    : public views::ViewObserver {
+class AssistantContainerViewAnimator : public views::ViewObserver {
  public:
   ~AssistantContainerViewAnimator() override;
 
--- a/ash/assistant/ui/assistant_container_view_animator_legacy_impl.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/ui/assistant_container_view_animator_legacy_impl.h	2019-05-17 18:53:08.104000000 +0300
@@ -8,7 +8,6 @@
 #include <memory>
 
 #include "ash/assistant/ui/assistant_container_view_animator.h"
-#include "base/component_export.h"
 #include "base/macros.h"
 #include "ui/compositor/layer.h"
 #include "ui/gfx/animation/animation_delegate.h"
@@ -28,7 +27,7 @@
 // AssistantContainerViewAnimator that performs rebounding of
 // AssistantContainerView at each frame in its resize animation. As such, it is
 // not very performant and we are working to deprecate this implementation.
-class COMPONENT_EXPORT(ASSISTANT_UI) AssistantContainerViewAnimatorLegacyImpl
+class AssistantContainerViewAnimatorLegacyImpl
     : public AssistantContainerViewAnimator,
       public gfx::AnimationDelegate {
  public:
--- a/ash/assistant/ui/assistant_container_view.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/ui/assistant_container_view.cc	2019-05-17 18:53:08.104000000 +0300
@@ -5,14 +5,11 @@
 #include "ash/assistant/ui/assistant_container_view.h"
 
 #include <algorithm>
-#include <set>
-#include <vector>
 
 #include "ash/assistant/model/assistant_ui_model.h"
 #include "ash/assistant/ui/assistant_container_view_animator.h"
 #include "ash/assistant/ui/assistant_main_view.h"
 #include "ash/assistant/ui/assistant_mini_view.h"
-#include "ash/assistant/ui/assistant_overlay.h"
 #include "ash/assistant/ui/assistant_ui_constants.h"
 #include "ash/assistant/ui/assistant_view_delegate.h"
 #include "ash/assistant/ui/assistant_web_view.h"
@@ -37,85 +34,8 @@
 // Appearance.
 constexpr SkColor kBackgroundColor = SK_ColorWHITE;
 
-// AssistantContainerClientView ------------------------------------------------
-
-// AssistantContainerClientView is the client view for AssistantContainerView
-// which provides support for adding overlays to the Assistant view hierarchy.
-// Because overlays are added to the AssistantContainerView client view, they
-// paint to a higher level in the layer tree than do direct children of
-// AssistantContainerView. This allows AssistantMainView, for example, to
-// pseudo-parent overlays that draw over top of Assistant cards.
-class AssistantContainerClientView : public views::ClientView,
-                                     public views::ViewObserver {
- public:
-  AssistantContainerClientView(views::Widget* widget,
-                               views::View* contents_view)
-      : views::ClientView(widget, contents_view) {}
-
-  ~AssistantContainerClientView() override = default;
-
-  // views::ClientView:
-  const char* GetClassName() const override {
-    return "AssistantContainerClientView";
-  }
-
-  void Layout() override {
-    views::ClientView::Layout();
-    for (AssistantOverlay* overlay : overlays_)
-      Layout(overlay);
-  }
-
-  // views::ViewObserver:
-  void OnViewIsDeleting(views::View* view) override {
-    view->RemoveObserver(this);
-
-    // We need to keep |overlays_| in sync with the view hierarchy.
-    auto it = overlays_.find(static_cast<AssistantOverlay*>(view));
-    DCHECK(it != overlays_.end());
-    overlays_.erase(it);
-  }
-
-  void OnViewPreferredSizeChanged(views::View* view) override {
-    Layout(static_cast<AssistantOverlay*>(view));
-    SchedulePaint();
-  }
-
-  void AddOverlays(std::vector<AssistantOverlay*> overlays) {
-    for (AssistantOverlay* overlay : overlays) {
-      overlays_.insert(overlay);
-      overlay->AddObserver(this);
-      AddChildView(overlay);
-    }
-  }
-
- private:
-  void Layout(AssistantOverlay* overlay) {
-    AssistantOverlay::LayoutParams layout_params = overlay->GetLayoutParams();
-    gfx::Size preferred_size = overlay->GetPreferredSize();
-
-    int left = layout_params.margins.left();
-    int top = layout_params.margins.top();
-    int width = std::min(preferred_size.width(), this->width());
-    int height = preferred_size.height();
-
-    // Gravity::kBottom.
-    using Gravity = AssistantOverlay::LayoutParams::Gravity;
-    if ((layout_params.gravity & Gravity::kBottom) != 0)
-      top = this->height() - height - layout_params.margins.bottom();
-
-    // Gravity::kCenterHorizontal.
-    if ((layout_params.gravity & Gravity::kCenterHorizontal) != 0) {
-      width = std::min(width, this->width() - layout_params.margins.width());
-      left = (this->width() - width) / 2;
-    }
-
-    overlay->SetBounds(left, top, width, height);
-  }
-
-  std::set<AssistantOverlay*> overlays_;
-
-  DISALLOW_COPY_AND_ASSIGN(AssistantContainerClientView);
-};
+// Window properties.
+DEFINE_UI_CLASS_PROPERTY_KEY(bool, kOnlyAllowMouseClickEvents, false);
 
 // AssistantContainerEventTargeter ---------------------------------------------
 
@@ -127,7 +47,7 @@
   // aura::WindowTargeter:
   bool SubtreeShouldBeExploredForEvent(aura::Window* window,
                                        const ui::LocatedEvent& event) override {
-    if (window->GetProperty(assistant::ui::kOnlyAllowMouseClickEvents)) {
+    if (window->GetProperty(kOnlyAllowMouseClickEvents)) {
       if (event.type() != ui::ET_MOUSE_PRESSED &&
           event.type() != ui::ET_MOUSE_RELEASED) {
         return false;
@@ -270,6 +190,11 @@
   delegate_->RemoveUiModelObserver(this);
 }
 
+// static
+void AssistantContainerView::OnlyAllowMouseClickEvents(aura::Window* window) {
+  window->SetProperty(kOnlyAllowMouseClickEvents, true);
+}
+
 const char* AssistantContainerView::GetClassName() const {
   return "AssistantContainerView";
 }
@@ -326,14 +251,6 @@
   params->keep_on_top = true;
 }
 
-views::ClientView* AssistantContainerView::CreateClientView(
-    views::Widget* widget) {
-  AssistantContainerClientView* client_view =
-      new AssistantContainerClientView(widget, GetContentsView());
-  client_view->AddOverlays(assistant_main_view_->GetOverlays());
-  return client_view;
-}
-
 void AssistantContainerView::Init() {
   SetLayoutManager(std::make_unique<AssistantContainerLayout>(delegate_));
 
@@ -348,6 +265,8 @@
 
   // Mini view.
   assistant_mini_view_ = new AssistantMiniView(delegate_);
+  assistant_mini_view_->set_mini_view_delegate(
+      delegate_->GetMiniViewDelegate());
   AddChildView(assistant_mini_view_);
 
   // Web view.
@@ -375,9 +294,6 @@
       if (assistant_web_view_)
         assistant_web_view_->RequestFocus();
       break;
-    case AssistantUiMode::kLauncherEmbeddedUi:
-      NOTREACHED();
-      break;
   }
 }
 
@@ -407,9 +323,6 @@
     case AssistantUiMode::kWebUi:
       assistant_web_view_->SetVisible(true);
       break;
-    case AssistantUiMode::kLauncherEmbeddedUi:
-      NOTREACHED();
-      break;
   }
 
   PreferredSizeChanged();
@@ -440,9 +353,6 @@
     case AssistantUiMode::kWebUi:
       // Default views::FocusSearch behavior is acceptable.
       return nullptr;
-    case AssistantUiMode::kLauncherEmbeddedUi:
-      NOTREACHED();
-      return nullptr;
   }
 }
 
--- a/ash/assistant/ui/assistant_container_view_focus_traversable.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/ui/assistant_container_view_focus_traversable.h	2019-05-17 18:53:08.104000000 +0300
@@ -7,7 +7,6 @@
 
 #include <memory>
 
-#include "base/component_export.h"
 #include "base/macros.h"
 #include "ui/views/focus/focus_manager.h"
 #include "ui/views/focus/focus_search.h"
@@ -22,8 +21,7 @@
 // belonging to AssistantContainerViewFocusTraversable. When there is no
 // currently focused view, it delegates to AssistantContainerView to find the
 // first focusable view for the given UI state.
-class COMPONENT_EXPORT(ASSISTANT_UI) AssistantContainerViewFocusSearch
-    : public views::FocusSearch {
+class AssistantContainerViewFocusSearch : public views::FocusSearch {
  public:
   explicit AssistantContainerViewFocusSearch(
       AssistantContainerView* assistant_container_view);
--- a/ash/assistant/ui/assistant_container_view.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/ui/assistant_container_view.h	2019-05-17 18:53:08.104000000 +0300
@@ -9,10 +9,13 @@
 
 #include "ash/assistant/model/assistant_ui_model_observer.h"
 #include "ash/assistant/ui/assistant_container_view_focus_traversable.h"
-#include "base/component_export.h"
 #include "base/macros.h"
 #include "ui/views/bubble/bubble_dialog_delegate_view.h"
 
+namespace aura {
+class Window;
+}  // namespace aura
+
 namespace ash {
 
 class AssistantContainerViewAnimator;
@@ -21,13 +24,17 @@
 class AssistantViewDelegate;
 class AssistantWebView;
 
-class COMPONENT_EXPORT(ASSISTANT_UI) AssistantContainerView
-    : public views::BubbleDialogDelegateView,
+class AssistantContainerView : public views::BubbleDialogDelegateView,
       public AssistantUiModelObserver {
  public:
   explicit AssistantContainerView(AssistantViewDelegate* delegate);
   ~AssistantContainerView() override;
 
+  // Instructs the event targeter for the Assistant window to only allow mouse
+  // click events to reach the specified |window|. All other events will not
+  // be explored by |window|'s subtree for handling.
+  static void OnlyAllowMouseClickEvents(aura::Window* window);
+
   // views::BubbleDialogDelegateView:
   const char* GetClassName() const override;
   void AddedToWidget() override;
@@ -41,7 +48,6 @@
   void SizeToContents() override;
   void OnBeforeBubbleWidgetInit(views::Widget::InitParams* params,
                                 views::Widget* widget) const override;
-  views::ClientView* CreateClientView(views::Widget* widget) override;
   void Init() override;
   void RequestFocus() override;
 
--- a/ash/assistant/ui/assistant_main_view.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/ui/assistant_main_view.cc	2019-05-17 18:53:08.104000000 +0300
@@ -5,11 +5,10 @@
 #include "ash/assistant/ui/assistant_main_view.h"
 
 #include <algorithm>
-#include <utility>
+#include <memory>
 
 #include "ash/assistant/model/assistant_interaction_model.h"
 #include "ash/assistant/model/assistant_ui_model.h"
-#include "ash/assistant/ui/assistant_notification_overlay.h"
 #include "ash/assistant/ui/assistant_ui_constants.h"
 #include "ash/assistant/ui/assistant_view_delegate.h"
 #include "ash/assistant/ui/caption_bar.h"
@@ -18,7 +17,6 @@
 #include "ash/assistant/util/animation_util.h"
 #include "ash/assistant/util/assistant_util.h"
 #include "base/time/time.h"
-#include "chromeos/services/assistant/public/features.h"
 #include "ui/aura/window.h"
 #include "ui/compositor/layer_animation_element.h"
 #include "ui/compositor/layer_animator.h"
@@ -55,11 +53,17 @@
   // Set delegate/observers.
   caption_bar_->set_delegate(delegate_->GetCaptionBarDelegate());
 
+  for (DialogPlateObserver* observer : delegate_->GetDialogPlateObservers())
+    dialog_plate_->AddObserver(observer);
+
   // The AssistantViewDelegate should outlive AssistantMainView.
   delegate_->AddUiModelObserver(this);
 }
 
 AssistantMainView::~AssistantMainView() {
+  for (DialogPlateObserver* observer : delegate_->GetDialogPlateObservers())
+    dialog_plate_->RemoveObserver(observer);
+
   delegate_->RemoveUiModelObserver(this);
 }
 
@@ -91,14 +95,6 @@
   min_height_dip_ = std::max(min_height_dip_, height());
 }
 
-void AssistantMainView::VisibilityChanged(views::View* starting_from,
-                                          bool visible) {
-  // Overlays behave like children of AssistantMainView so they should only be
-  // visible while AssistantMainView is visible.
-  for (std::unique_ptr<AssistantOverlay>& overlay : overlays_)
-    overlay->SetVisible(visible);
-}
-
 void AssistantMainView::ChildPreferredSizeChanged(views::View* child) {
   PreferredSizeChanged();
 
@@ -122,13 +118,6 @@
   return dialog_plate_->FindFirstFocusableView();
 }
 
-std::vector<AssistantOverlay*> AssistantMainView::GetOverlays() {
-  std::vector<AssistantOverlay*> overlays;
-  for (std::unique_ptr<AssistantOverlay>& overlay : overlays_)
-    overlays.push_back(overlay.get());
-  return overlays;
-}
-
 void AssistantMainView::InitLayout() {
   views::BoxLayout* layout_manager =
       SetLayoutManager(std::make_unique<views::BoxLayout>(
@@ -158,14 +147,6 @@
   dialog_plate_->layer()->SetFillsBoundsOpaquely(false);
 
   AddChildView(dialog_plate_);
-
-  // Notification overlay.
-  if (chromeos::assistant::features::IsInAssistantNotificationsEnabled()) {
-    auto notification_overlay =
-        std::make_unique<AssistantNotificationOverlay>(delegate_);
-    notification_overlay->set_owned_by_client();
-    overlays_.push_back(std::move(notification_overlay));
-  }
 }
 
 void AssistantMainView::OnUiVisibilityChanged(
--- a/ash/assistant/ui/assistant_main_view.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/ui/assistant_main_view.h	2019-05-17 18:53:08.104000000 +0300
@@ -5,25 +5,18 @@
 #ifndef ASH_ASSISTANT_UI_ASSISTANT_MAIN_VIEW_H_
 #define ASH_ASSISTANT_UI_ASSISTANT_MAIN_VIEW_H_
 
-#include <memory>
-#include <vector>
-
 #include "ash/assistant/model/assistant_ui_model_observer.h"
-#include "base/component_export.h"
 #include "base/macros.h"
 #include "ui/views/view.h"
 
 namespace ash {
 
 class AssistantMainStage;
-class AssistantOverlay;
 class AssistantViewDelegate;
 class CaptionBar;
 class DialogPlate;
 
-class COMPONENT_EXPORT(ASSISTANT_UI) AssistantMainView
-    : public views::View,
-      public AssistantUiModelObserver {
+class AssistantMainView : public views::View, public AssistantUiModelObserver {
  public:
   explicit AssistantMainView(AssistantViewDelegate* delegate);
   ~AssistantMainView() override;
@@ -35,7 +28,6 @@
   void ChildPreferredSizeChanged(views::View* child) override;
   void ChildVisibilityChanged(views::View* child) override;
   void OnBoundsChanged(const gfx::Rect& prev_bounds) override;
-  void VisibilityChanged(views::View* starting_from, bool visible) override;
   void RequestFocus() override;
 
   // AssistantUiModelObserver:
@@ -48,9 +40,6 @@
   // Returns the first focusable view or nullptr to defer to views::FocusSearch.
   views::View* FindFirstFocusableView();
 
-  // Returns the overlays that behave as pseudo-children of AssistantMainView.
-  std::vector<AssistantOverlay*> GetOverlays();
-
  private:
   void InitLayout();
 
@@ -60,11 +49,6 @@
   DialogPlate* dialog_plate_;                       // Owned by view hierarchy.
   AssistantMainStage* main_stage_;                  // Owned by view hierarchy.
 
-  // Overlays behave as pseudo-children of AssistantMainView. They paint to a
-  // higher lever in the layer tree so they are visible over the top of
-  // Assistant cards.
-  std::vector<std::unique_ptr<AssistantOverlay>> overlays_;
-
   int min_height_dip_;
 
   DISALLOW_COPY_AND_ASSIGN(AssistantMainView);
--- a/ash/assistant/ui/assistant_mini_view.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/ui/assistant_mini_view.cc	2019-05-17 18:53:08.104000000 +0300
@@ -97,7 +97,8 @@
 
 void AssistantMiniView::ButtonPressed(views::Button* sender,
                                       const ui::Event& event) {
-  delegate_->OnMiniViewPressed();
+  if (mini_view_delegate_)
+    mini_view_delegate_->OnAssistantMiniViewPressed();
 }
 
 void AssistantMiniView::OnInputModalityChanged(InputModality input_modality) {
--- a/ash/assistant/ui/assistant_mini_view.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/ui/assistant_mini_view.h	2019-05-17 18:53:08.104000000 +0300
@@ -10,7 +10,6 @@
 
 #include "ash/assistant/model/assistant_interaction_model_observer.h"
 #include "ash/assistant/model/assistant_ui_model_observer.h"
-#include "base/component_export.h"
 #include "base/macros.h"
 #include "base/optional.h"
 #include "ui/views/controls/button/button.h"
@@ -23,10 +22,22 @@
 
 class AssistantViewDelegate;
 
+// AssistantMiniViewDelegate ---------------------------------------------------
+
+// TODO(wutao): Remove this class and call methods on AssistantViewDelegate
+// derectly.
+class AssistantMiniViewDelegate {
+ public:
+  // Invoked when the AssistantMiniView is pressed.
+  virtual void OnAssistantMiniViewPressed() {}
+
+ protected:
+  virtual ~AssistantMiniViewDelegate() = default;
+};
+
 // AssistantMiniView -----------------------------------------------------------
 
-class COMPONENT_EXPORT(ASSISTANT_UI) AssistantMiniView
-    : public views::Button,
+class AssistantMiniView : public views::Button,
       public views::ButtonListener,
       public AssistantInteractionModelObserver,
       public AssistantUiModelObserver {
@@ -55,6 +66,10 @@
       base::Optional<AssistantEntryPoint> entry_point,
       base::Optional<AssistantExitPoint> exit_point) override;
 
+  void set_mini_view_delegate(AssistantMiniViewDelegate* delegate) {
+    mini_view_delegate_ = delegate;
+  }
+
  private:
   void InitLayout();
   void UpdatePrompt();
@@ -62,6 +77,8 @@
   AssistantViewDelegate* const delegate_;
   views::Label* label_;                              // Owned by view hierarchy.
 
+  AssistantMiniViewDelegate* mini_view_delegate_ = nullptr;
+
   // The most recent active query for the current Assistant UI session. If there
   // has been no active query for the current UI session, this is empty.
   base::Optional<std::string> last_active_query_;
--- a/ash/assistant/ui/assistant_ui_constants.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/ui/assistant_ui_constants.cc	2019-05-17 18:53:08.104000000 +0300
@@ -5,15 +5,12 @@
 #include "ash/assistant/ui/assistant_ui_constants.h"
 
 #include "base/no_destructor.h"
-#include "ui/base/class_property.h"
 #include "ui/gfx/font_list.h"
 
 namespace ash {
 namespace assistant {
 namespace ui {
 
-DEFINE_UI_CLASS_PROPERTY_KEY(bool, kOnlyAllowMouseClickEvents, false)
-
 const gfx::FontList& GetDefaultFontList() {
   static const base::NoDestructor<gfx::FontList> font_list("Google Sans, 12px");
   return *font_list;
--- a/ash/assistant/ui/assistant_ui_constants.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/ui/assistant_ui_constants.h	2019-05-17 18:53:08.104000000 +0300
@@ -5,9 +5,7 @@
 #ifndef ASH_ASSISTANT_UI_ASSISTANT_UI_CONSTANTS_H_
 #define ASH_ASSISTANT_UI_ASSISTANT_UI_CONSTANTS_H_
 
-#include "base/component_export.h"
 #include "third_party/skia/include/core/SkColor.h"
-#include "ui/aura/window.h"
 #include "ui/gfx/color_palette.h"
 
 namespace gfx {
@@ -20,7 +18,6 @@
 constexpr int kCornerRadiusDip = 20;
 constexpr int kMiniUiCornerRadiusDip = 24;
 constexpr int kMaxHeightDip = 640;
-constexpr int kMaxHeightEmbeddedDip = 440;
 constexpr int kPaddingDip = 14;
 constexpr int kPreferredWidthDip = 640;
 constexpr int kSpacingDip = 8;
@@ -28,21 +25,14 @@
 constexpr int kUiElementHorizontalMarginDip = 32;
 
 // Typography.
+constexpr SkColor kTextColorHint = gfx::kGoogleGrey700;
 constexpr SkColor kTextColorPrimary = gfx::kGoogleGrey900;
-constexpr SkColor kTextColorSecondary = gfx::kGoogleGrey700;
 
 // TODO(dmblack): Move the other constants into ash::assistant::ui.
 namespace assistant {
 namespace ui {
 
-// Window property to instruct the event targeter for the Assistant window to
-// only allow mouse click events to reach the specified |window|. All other
-// events will not be explored by |window|'s subtree for handling.
-COMPONENT_EXPORT(ASSISTANT_UI_CONSTANTS)
-extern const aura::WindowProperty<bool>* const kOnlyAllowMouseClickEvents;
-
 // Returns the default font list for Assistant UI.
-COMPONENT_EXPORT(ASSISTANT_UI_CONSTANTS)
 const gfx::FontList& GetDefaultFontList();
 
 }  // namespace ui
--- a/ash/assistant/ui/assistant_view_delegate.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/ui/assistant_view_delegate.h	2019-05-17 18:53:08.104000000 +0300
@@ -7,13 +7,12 @@
 
 #include <map>
 #include <string>
+#include <vector>
 
 #include "ash/assistant/model/assistant_cache_model.h"
 #include "ash/assistant/model/assistant_cache_model_observer.h"
 #include "ash/assistant/model/assistant_interaction_model.h"
 #include "ash/assistant/model/assistant_interaction_model_observer.h"
-#include "ash/assistant/model/assistant_notification_model.h"
-#include "ash/assistant/model/assistant_notification_model_observer.h"
 #include "ash/assistant/model/assistant_ui_model.h"
 #include "ash/assistant/model/assistant_ui_model_observer.h"
 #include "ash/assistant/ui/assistant_mini_view.h"
@@ -22,7 +21,6 @@
 #include "ash/assistant/ui/main_stage/assistant_opt_in_view.h"
 #include "ash/public/cpp/assistant/default_voice_interaction_observer.h"
 #include "ash/public/interfaces/assistant_image_downloader.mojom.h"
-#include "base/component_export.h"
 #include "base/observer_list_types.h"
 #include "chromeos/services/assistant/public/mojom/assistant.mojom.h"
 #include "services/content/public/mojom/navigable_contents_factory.mojom.h"
@@ -36,37 +34,20 @@
 }  // namespace util
 }  // namespace assistant
 
-class COMPONENT_EXPORT(ASSISTANT_UI) AssistantViewDelegateObserver
+class ASH_PUBLIC_EXPORT AssistantViewDelegateObserver
     : public base::CheckedObserver {
  public:
-  using AssistantSuggestion = chromeos::assistant::mojom::AssistantSuggestion;
-
   // Invoked when Assistant has received a deep link of the specified |type|
   // with the given |params|.
   virtual void OnDeepLinkReceived(
       assistant::util::DeepLinkType type,
       const std::map<std::string, std::string>& params) {}
-
-  // Invoked when the dialog plate button identified by |id| is pressed.
-  virtual void OnDialogPlateButtonPressed(AssistantButtonId id) {}
-
-  // Invoked when the dialog plate contents have been committed.
-  virtual void OnDialogPlateContentsCommitted(const std::string& text) {}
-
-  // Invoked when the mini view is pressed.
-  virtual void OnMiniViewPressed() {}
-
-  // Invoked when the opt in button is pressed.
-  virtual void OnOptInButtonPressed() {}
-
-  // Invoked when a suggestion chip is pressed.
-  virtual void OnSuggestionChipPressed(const AssistantSuggestion* suggestion) {}
 };
 
 // A delegate of views in assistant/ui that handles views related actions e.g.
 // get models for the views, adding observers, closing the views, opening urls,
 // etc.
-class COMPONENT_EXPORT(ASSISTANT_UI) AssistantViewDelegate {
+class ASH_PUBLIC_EXPORT AssistantViewDelegate {
  public:
   using AssistantSuggestion = chromeos::assistant::mojom::AssistantSuggestion;
 
@@ -78,16 +59,9 @@
   // Gets the interaction model associated with the view delegate.
   virtual const AssistantInteractionModel* GetInteractionModel() const = 0;
 
-  // Gets the notification model associated with the view delegate.
-  virtual const AssistantNotificationModel* GetNotificationModel() const = 0;
-
   // Gets the ui model associated with the view delegate.
   virtual const AssistantUiModel* GetUiModel() const = 0;
 
-  // Adds/removes the specified view delegate observer.
-  virtual void AddObserver(AssistantViewDelegateObserver* observer) = 0;
-  virtual void RemoveObserver(AssistantViewDelegateObserver* observer) = 0;
-
   // Adds/removes the cache model observer associated with the view delegate.
   virtual void AddCacheModelObserver(AssistantCacheModelObserver* observer) = 0;
   virtual void RemoveCacheModelObserver(
@@ -100,17 +74,16 @@
   virtual void RemoveInteractionModelObserver(
       AssistantInteractionModelObserver* observer) = 0;
 
-  // Adds/removes the notification model observer associated with the view
-  // delegate.
-  virtual void AddNotificationModelObserver(
-      AssistantNotificationModelObserver* observer) = 0;
-  virtual void RemoveNotificationModelObserver(
-      AssistantNotificationModelObserver* observer) = 0;
-
   // Adds/removes the ui model observer associated with the view delegate.
   virtual void AddUiModelObserver(AssistantUiModelObserver* observer) = 0;
   virtual void RemoveUiModelObserver(AssistantUiModelObserver* observer) = 0;
 
+  // Adds/removes the view delegate observer.
+  virtual void AddViewDelegateObserver(
+      AssistantViewDelegateObserver* observer) = 0;
+  virtual void RemoveViewDelegateObserver(
+      AssistantViewDelegateObserver* observer) = 0;
+
   // Adds/removes the voice interaction controller observer associated with the
   // view delegate.
   virtual void AddVoiceInteractionControllerObserver(
@@ -121,6 +94,15 @@
   // Gets the caption bar delegate associated with the view delegate.
   virtual CaptionBarDelegate* GetCaptionBarDelegate() = 0;
 
+  // Gets the dialog plate observers associated with the view delegate.
+  virtual std::vector<DialogPlateObserver*> GetDialogPlateObservers() = 0;
+
+  // Gets the mini view delegate associated with the view delegate.
+  virtual AssistantMiniViewDelegate* GetMiniViewDelegate() = 0;
+
+  // Gets the opt in delegate associated with the view delegate.
+  virtual AssistantOptInDelegate* GetOptInDelegate() = 0;
+
   // Downloads the image found at the specified |url|. On completion, the
   // supplied |callback| will be run with the downloaded image. If the download
   // attempt is unsuccessful, a NULL image is returned.
@@ -128,42 +110,19 @@
       const GURL& url,
       mojom::AssistantImageDownloader::DownloadCallback callback) = 0;
 
-  // Returns the status of the user's consent.
-  virtual mojom::ConsentStatus GetConsentStatus() const = 0;
-
   // Returns the cursor_manager.
-  virtual ::wm::CursorManager* GetCursorManager() = 0;
+  virtual wm::CursorManager* GetCursorManager() = 0;
 
   // Acquires a NavigableContentsFactory from the Content Service to allow
   // Assistant to display embedded web contents.
   virtual void GetNavigableContentsFactoryForView(
       content::mojom::NavigableContentsFactoryRequest request) = 0;
 
-  // Returns the root window that newly created windows should be added to.
   virtual aura::Window* GetRootWindowForNewWindows() = 0;
 
-  // Returns true if user prefers to start with voice interaction.
-  virtual bool IsLaunchWithMicOpen() const = 0;
-
   // Returns true if in tablet mode.
   virtual bool IsTabletMode() const = 0;
 
-  // Invoked when the dialog plate button identified by |id| is pressed.
-  virtual void OnDialogPlateButtonPressed(AssistantButtonId id) = 0;
-
-  // Invoked when the dialog plate contents have been committed.
-  virtual void OnDialogPlateContentsCommitted(const std::string& text) = 0;
-
-  // Invoked when the mini view is pressed.
-  virtual void OnMiniViewPressed() = 0;
-
-  // Invoked when an in-Assistant notification button is pressed.
-  virtual void OnNotificationButtonPressed(const std::string& notification_id,
-                                           int notification_button_index) = 0;
-
-  // Invoked when the opt in button is pressed.
-  virtual void OnOptInButtonPressed() {}
-
   // Invoked when suggestion chip is pressed.
   virtual void OnSuggestionChipPressed(
       const AssistantSuggestion* suggestion) = 0;
@@ -171,6 +130,9 @@
   // Opens the specified |url| in a new browser tab. Special handling is applied
   // to deep links which may cause deviation from this behavior.
   virtual void OpenUrlFromView(const GURL& url) = 0;
+
+  // Returns true if voice interaction controller setup completed.
+  virtual bool VoiceInteractionControllerSetupCompleted() const = 0;
 };
 
 }  // namespace ash
--- a/ash/assistant/ui/assistant_web_view.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/ui/assistant_web_view.cc	2019-05-17 18:53:08.104000000 +0300
@@ -11,12 +11,9 @@
 #include "ash/assistant/ui/assistant_ui_constants.h"
 #include "ash/assistant/ui/assistant_view_delegate.h"
 #include "ash/assistant/util/deep_link_util.h"
-#include "ash/public/cpp/app_list/app_list_features.h"
-#include "base/bind.h"
 #include "base/callback.h"
 #include "services/content/public/cpp/navigable_contents_view.h"
 #include "ui/aura/window.h"
-#include "ui/base/ui_base_features.h"
 #include "ui/compositor/layer.h"
 #include "ui/display/display.h"
 #include "ui/display/screen.h"
@@ -29,12 +26,6 @@
 
 namespace {
 
-int GetMaxHeight() {
-  return app_list_features::IsEmbeddedAssistantUIEnabled()
-             ? kMaxHeightEmbeddedDip
-             : kMaxHeightDip;
-}
-
 // ContentsMaskPainter ---------------------------------------------------------
 
 class ContentsMaskPainter : public views::Painter {
@@ -74,13 +65,13 @@
     : delegate_(delegate), weak_factory_(this) {
   InitLayout();
 
-  delegate_->AddObserver(this);
-  delegate_->AddUiModelObserver(this);
+  delegate_->AddViewDelegateObserver(this);
 }
 
 AssistantWebView::~AssistantWebView() {
-  delegate_->RemoveUiModelObserver(this);
-  delegate_->RemoveObserver(this);
+  delegate_->RemoveViewDelegateObserver(this);
+
+  RemoveContents();
 }
 
 const char* AssistantWebView::GetClassName() const {
@@ -92,14 +83,11 @@
 }
 
 int AssistantWebView::GetHeightForWidth(int width) const {
-  if (app_list_features::IsEmbeddedAssistantUIEnabled())
-    return GetMaxHeight();
-
-  // |height| <= |GetMaxHeight()|.
+  // |height| <= |kMaxHeightDip|.
   // |height| should not exceed the height of the usable work area.
   gfx::Rect usable_work_area = delegate_->GetUiModel()->usable_work_area();
 
-  return std::min(GetMaxHeight(), usable_work_area.height());
+  return std::min(kMaxHeightDip, usable_work_area.height());
 }
 
 void AssistantWebView::ChildPreferredSizeChanged(views::View* child) {
@@ -143,8 +131,6 @@
   caption_bar_ = new CaptionBar();
   caption_bar_->set_delegate(this);
   caption_bar_->SetButtonVisible(AssistantButtonId::kMinimize, false);
-  if (app_list_features::IsEmbeddedAssistantUIEnabled())
-    caption_bar_->SetButtonVisible(AssistantButtonId::kClose, false);
   AddChildView(caption_bar_);
 
   // Contents mask.
@@ -189,7 +175,7 @@
 
   const gfx::Size preferred_size =
       gfx::Size(kPreferredWidthDip,
-                GetMaxHeight() - caption_bar_->GetPreferredSize().height());
+                kMaxHeightDip - caption_bar_->GetPreferredSize().height());
 
   auto contents_params = content::mojom::NavigableContentsParams::New();
   contents_params->enable_view_auto_resize = true;
@@ -199,8 +185,6 @@
 
   contents_ = std::make_unique<content::NavigableContents>(
       contents_factory_.get(), std::move(contents_params));
-  if (features::IsUsingWindowService())
-    contents_->ForceUseWindowService();
 
   // We observe |contents_| so that we can handle events from the underlying
   // web contents.
@@ -215,12 +199,6 @@
 }
 
 void AssistantWebView::DidStopLoading() {
-  // We should only respond to the |DidStopLoading| event the first time, to add
-  // the view for the navigable contents to our view hierarchy and perform other
-  // one-time view initializations.
-  if (contents_->GetView()->view()->parent() == this)
-    return;
-
   AddChildView(contents_->GetView()->view());
   SetFocusBehavior(FocusBehavior::ALWAYS);
 
@@ -258,17 +236,6 @@
   contents_->Navigate(url);
 }
 
-void AssistantWebView::OnUiVisibilityChanged(
-    AssistantVisibility new_visibility,
-    AssistantVisibility old_visibility,
-    base::Optional<AssistantEntryPoint> entry_point,
-    base::Optional<AssistantExitPoint> exit_point) {
-  // When the Assistant UI is closed we need to clear the |contents_| in order
-  // to free the memory.
-  if (new_visibility == AssistantVisibility::kClosed)
-    RemoveContents();
-}
-
 void AssistantWebView::RemoveContents() {
   if (!contents_)
     return;
--- a/ash/assistant/ui/assistant_web_view.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/ui/assistant_web_view.h	2019-05-17 18:53:08.104000000 +0300
@@ -9,10 +9,8 @@
 #include <memory>
 #include <string>
 
-#include "ash/assistant/model/assistant_ui_model_observer.h"
 #include "ash/assistant/ui/assistant_view_delegate.h"
 #include "ash/assistant/ui/caption_bar.h"
-#include "base/component_export.h"
 #include "base/macros.h"
 #include "base/optional.h"
 #include "mojo/public/cpp/bindings/binding.h"
@@ -29,13 +27,11 @@
 // to render remotely hosted content within its bubble. It provides a CaptionBar
 // for window level controls and embeds web contents with help from the Content
 // Service.
-class COMPONENT_EXPORT(ASSISTANT_UI) AssistantWebView
-    : public views::View,
+class AssistantWebView : public views::View,
       public aura::WindowObserver,
       public AssistantViewDelegateObserver,
       public CaptionBarDelegate,
-      public content::NavigableContentsObserver,
-      public AssistantUiModelObserver {
+                         public content::NavigableContentsObserver {
  public:
   explicit AssistantWebView(AssistantViewDelegate* delegate);
   ~AssistantWebView() override;
@@ -70,13 +66,6 @@
                              WindowOpenDisposition disposition,
                              bool from_user_gesture) override;
 
-  // AssistantUiModelObserver:
-  void OnUiVisibilityChanged(
-      AssistantVisibility new_visibility,
-      AssistantVisibility old_visibility,
-      base::Optional<AssistantEntryPoint> entry_point,
-      base::Optional<AssistantExitPoint> exit_point) override;
-
  private:
   void InitLayout();
   void RemoveContents();
--- a/ash/assistant/ui/base/assistant_button.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/ui/base/assistant_button.h	2019-05-17 18:53:08.104000000 +0300
@@ -7,7 +7,6 @@
 
 #include <memory>
 
-#include "base/component_export.h"
 #include "base/macros.h"
 #include "third_party/skia/include/core/SkColor.h"
 #include "ui/gfx/color_palette.h"
@@ -26,8 +25,7 @@
 
 enum class AssistantButtonId;
 
-class COMPONENT_EXPORT(ASSISTANT_UI) AssistantButton
-    : public views::ImageButton,
+class AssistantButton : public views::ImageButton,
       public views::ButtonListener {
  public:
   AssistantButton(views::ButtonListener* listener, AssistantButtonId button_id);
--- a/ash/assistant/ui/base/assistant_scroll_view.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/ui/base/assistant_scroll_view.h	2019-05-17 18:53:08.104000000 +0300
@@ -5,16 +5,13 @@
 #ifndef ASH_ASSISTANT_UI_BASE_ASSISTANT_SCROLL_VIEW_H_
 #define ASH_ASSISTANT_UI_BASE_ASSISTANT_SCROLL_VIEW_H_
 
-#include "base/component_export.h"
 #include "base/macros.h"
 #include "ui/views/controls/scroll_view.h"
 #include "ui/views/view_observer.h"
 
 namespace ash {
 
-class COMPONENT_EXPORT(ASSISTANT_UI) AssistantScrollView
-    : public views::ScrollView,
-      views::ViewObserver {
+class AssistantScrollView : public views::ScrollView, views::ViewObserver {
  public:
   AssistantScrollView();
   ~AssistantScrollView() override;
--- a/ash/assistant/ui/BUILD.gn	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/ui/BUILD.gn	2019-05-17 18:53:08.104000000 +0300
@@ -3,15 +3,10 @@
 # found in the LICENSE file.
 
 import("//build/config/ui.gni")
-import("//chromeos/assistant/assistant.gni")
 
 assert(is_chromeos)
 
-component("constants") {
-  output_name = "assistant_ui_constants"
-
-  defines = [ "IS_ASSISTANT_UI_CONSTANTS_IMPL" ]
-
+source_set("constants") {
   sources = [
     "assistant_ui_constants.cc",
     "assistant_ui_constants.h",
@@ -20,105 +15,6 @@
   deps = [
     "//base",
     "//skia",
-    "//ui/aura",
-    "//ui/base",
-    "//ui/gfx",
-  ]
-}
-
-component("ui") {
-  output_name = "assistant_ui"
-
-  defines = [ "IS_ASSISTANT_UI_IMPL" ]
-
-  sources = [
-    "assistant_container_view.cc",
-    "assistant_container_view.h",
-    "assistant_container_view_animator.cc",
-    "assistant_container_view_animator.h",
-    "assistant_container_view_animator_legacy_impl.cc",
-    "assistant_container_view_animator_legacy_impl.h",
-    "assistant_container_view_focus_traversable.cc",
-    "assistant_container_view_focus_traversable.h",
-    "assistant_main_view.cc",
-    "assistant_main_view.h",
-    "assistant_mini_view.cc",
-    "assistant_mini_view.h",
-    "assistant_notification_overlay.cc",
-    "assistant_notification_overlay.h",
-    "assistant_notification_view.cc",
-    "assistant_notification_view.h",
-    "assistant_overlay.h",
-    "assistant_view_delegate.h",
-    "assistant_web_view.cc",
-    "assistant_web_view.h",
-    "base/assistant_button.cc",
-    "base/assistant_button.h",
-    "base/assistant_scroll_view.cc",
-    "base/assistant_scroll_view.h",
-    "caption_bar.cc",
-    "caption_bar.h",
-    "dialog_plate/action_view.cc",
-    "dialog_plate/action_view.h",
-    "dialog_plate/dialog_plate.cc",
-    "dialog_plate/dialog_plate.h",
-    "logo_view/base_logo_view.cc",
-    "logo_view/base_logo_view.h",
-    "main_stage/assistant_card_element_view.cc",
-    "main_stage/assistant_card_element_view.h",
-    "main_stage/assistant_footer_view.cc",
-    "main_stage/assistant_footer_view.h",
-    "main_stage/assistant_header_view.cc",
-    "main_stage/assistant_header_view.h",
-    "main_stage/assistant_main_stage.cc",
-    "main_stage/assistant_main_stage.h",
-    "main_stage/assistant_opt_in_view.cc",
-    "main_stage/assistant_opt_in_view.h",
-    "main_stage/assistant_progress_indicator.cc",
-    "main_stage/assistant_progress_indicator.h",
-    "main_stage/assistant_query_view.cc",
-    "main_stage/assistant_query_view.h",
-    "main_stage/assistant_text_element_view.cc",
-    "main_stage/assistant_text_element_view.h",
-    "main_stage/suggestion_chip_view.cc",
-    "main_stage/suggestion_chip_view.h",
-    "main_stage/suggestion_container_view.cc",
-    "main_stage/suggestion_container_view.h",
-    "main_stage/ui_element_container_view.cc",
-    "main_stage/ui_element_container_view.h",
-  ]
-
-  deps = [
-    "//ash/assistant/model",
-    "//ash/assistant/ui:constants",
-    "//ash/assistant/util",
-    "//ash/public/cpp",
-    "//ash/public/cpp/vector_icons",
-    "//ash/resources/vector_icons",
-    "//ash/strings",
-    "//base",
-    "//chromeos/assistant:buildflags",
-    "//chromeos/services/assistant/public:feature_flags",
-    "//chromeos/services/assistant/public/mojom",
-    "//services/content/public/cpp",
-    "//ui/aura",
-    "//ui/compositor",
     "//ui/gfx",
-    "//ui/views",
-    "//ui/views/window/vector_icons",
-    "//ui/wm",
-  ]
-
-  if (enable_cros_libassistant) {
-    sources += [
-      "logo_view/logo_view.cc",
-      "logo_view/logo_view.h",
-      "logo_view/shape/mic_part_shape.cc",
-      "logo_view/shape/mic_part_shape.h",
-      "logo_view/shape/shape.cc",
-      "logo_view/shape/shape.h",
     ]
-
-    deps += [ "//chromeos/assistant/internal/logo_view" ]
-  }
 }
--- a/ash/assistant/ui/caption_bar.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/ui/caption_bar.cc	2019-05-17 18:53:08.104000000 +0300
@@ -4,6 +4,8 @@
 
 #include "ash/assistant/ui/caption_bar.h"
 
+#include <memory>
+
 #include "ash/assistant/model/assistant_ui_model.h"
 #include "ash/assistant/ui/assistant_ui_constants.h"
 #include "ash/assistant/ui/base/assistant_button.h"
@@ -13,7 +15,6 @@
 #include "ui/gfx/paint_vector_icon.h"
 #include "ui/strings/grit/ui_strings.h"
 #include "ui/views/controls/button/image_button.h"
-#include "ui/views/event_monitor.h"
 #include "ui/views/layout/box_layout.h"
 #include "ui/views/widget/widget.h"
 #include "ui/views/window/vector_icons/vector_icons.h"
@@ -52,6 +53,28 @@
   return "CaptionBar";
 }
 
+bool CaptionBar::AcceleratorPressed(const ui::Accelerator& accelerator) {
+  switch (accelerator.key_code()) {
+    case ui::VKEY_BROWSER_BACK:
+      HandleButton(AssistantButtonId::kBack);
+      break;
+    case ui::VKEY_W:
+      if (accelerator.IsCtrlDown())
+        HandleButton(AssistantButtonId::kClose);
+      else {
+        NOTREACHED();
+        return false;
+      }
+      break;
+    default:
+      NOTREACHED();
+      return false;
+  }
+
+  // Don't let DialogClientView handle the accelerator.
+  return true;
+}
+
 gfx::Size CaptionBar::CalculatePreferredSize() const {
   return gfx::Size(INT_MAX, GetHeightForWidth(INT_MAX));
 }
@@ -60,47 +83,9 @@
   return kPreferredHeightDip;
 }
 
-void CaptionBar::VisibilityChanged(views::View* starting_from, bool visible) {
-  if (!IsDrawn()) {
-    event_monitor_.reset();
-    return;
-  }
-
-  views::Widget* widget = GetWidget();
-  if (!widget)
-    return;
-
-  // Only when the CaptionBar is drawn do we allow it to monitor key press
-  // events. We monitor key press events to handle hotkeys that behave the same
-  // as caption bar buttons. Note that we use an EventMonitor rather than adding
-  // accelerators so that we always receive key events, even if an embedded
-  // navigable contents in our view hierarchy has focus.
-  gfx::NativeWindow root_window = widget->GetNativeWindow()->GetRootWindow();
-  event_monitor_ = views::EventMonitor::CreateWindowMonitor(
-      this, root_window, {ui::ET_KEY_PRESSED});
-}
-
 void CaptionBar::ButtonPressed(views::Button* sender, const ui::Event& event) {
-  HandleButton(static_cast<AssistantButtonId>(sender->id()));
-}
-
-void CaptionBar::OnEvent(const ui::Event& event) {
-  const ui::KeyEvent& key_event = static_cast<const ui::KeyEvent&>(event);
-  switch (key_event.key_code()) {
-    case ui::VKEY_BROWSER_BACK:
-      HandleButton(AssistantButtonId::kBack);
-      break;
-    case ui::VKEY_ESCAPE:
-      HandleButton(AssistantButtonId::kClose);
-      break;
-    case ui::VKEY_W:
-      if (key_event.IsControlDown())
-        HandleButton(AssistantButtonId::kClose);
-      break;
-    default:
-      // No action necessary.
-      break;
-  }
+  auto id = static_cast<AssistantButtonId>(sender->id());
+  HandleButton(id);
 }
 
 void CaptionBar::SetButtonVisible(AssistantButtonId id, bool visible) {
@@ -119,8 +104,10 @@
       views::BoxLayout::CrossAxisAlignment::CROSS_AXIS_ALIGNMENT_CENTER);
 
   // Back.
-  AddChildView(CreateCaptionButton(kWindowControlBackIcon, IDS_APP_LIST_BACK,
-                                   AssistantButtonId::kBack, this));
+  auto* back_button =
+      CreateCaptionButton(kWindowControlBackIcon, IDS_APP_LIST_BACK,
+                          AssistantButtonId::kBack, this);
+  AddChildView(back_button);
 
   // Spacer.
   views::View* spacer = new views::View();
@@ -129,14 +116,20 @@
   layout_manager->SetFlexForView(spacer, 1);
 
   // Minimize.
-  AddChildView(CreateCaptionButton(views::kWindowControlMinimizeIcon,
-                                   IDS_APP_ACCNAME_MINIMIZE,
-                                   AssistantButtonId::kMinimize, this));
+  auto* minimize_button = CreateCaptionButton(
+      views::kWindowControlMinimizeIcon, IDS_APP_ACCNAME_MINIMIZE,
+      AssistantButtonId::kMinimize, this);
+  AddChildView(minimize_button);
 
   // Close.
-  AddChildView(CreateCaptionButton(views::kWindowControlCloseIcon,
-                                   IDS_APP_ACCNAME_CLOSE,
-                                   AssistantButtonId::kClose, this));
+  auto* close_button =
+      CreateCaptionButton(views::kWindowControlCloseIcon, IDS_APP_ACCNAME_CLOSE,
+                          AssistantButtonId::kClose, this);
+  AddChildView(close_button);
+
+  // Add a keyboard accelerator Ctrl + W to close Assistant UI.
+  AddAccelerator(ui::Accelerator(ui::VKEY_W, ui::EF_CONTROL_DOWN));
+  AddAccelerator(ui::Accelerator(ui::VKEY_BROWSER_BACK, ui::EF_NONE));
 }
 
 void CaptionBar::HandleButton(AssistantButtonId id) {
--- a/ash/assistant/ui/caption_bar.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/ui/caption_bar.h	2019-05-17 18:53:08.104000000 +0300
@@ -5,18 +5,10 @@
 #ifndef ASH_ASSISTANT_UI_CAPTION_BAR_H_
 #define ASH_ASSISTANT_UI_CAPTION_BAR_H_
 
-#include <memory>
-
-#include "base/component_export.h"
 #include "base/macros.h"
-#include "ui/events/event_observer.h"
 #include "ui/views/controls/button/button.h"
 #include "ui/views/view.h"
 
-namespace views {
-class EventMonitor;
-}  // namespace views
-
 namespace ash {
 
 enum class AssistantButtonId;
@@ -25,7 +17,7 @@
 
 // TODO(wutao): Remove this class and call methods on AssistantViewDelegate
 // derectly.
-class COMPONENT_EXPORT(ASSISTANT_UI) CaptionBarDelegate {
+class CaptionBarDelegate {
  public:
   // Invoked when the caption button identified by |id| is pressed. Return
   // |true| to prevent default behavior from being performed, false otherwise.
@@ -37,29 +29,20 @@
 
 // CaptionBar ------------------------------------------------------------------
 
-class COMPONENT_EXPORT(ASSISTANT_UI) CaptionBar : public views::View,
-                                                  public views::ButtonListener,
-                                                  public ui::EventObserver {
+class CaptionBar : public views::View, views::ButtonListener {
  public:
-  // This is necessary to inform clang that our overload of |OnEvent|,
-  // overridden from |ui::EventObserver|, is intentional.
-  using ui::EventHandler::OnEvent;
-
   CaptionBar();
   ~CaptionBar() override;
 
   // views::View:
   const char* GetClassName() const override;
+  bool AcceleratorPressed(const ui::Accelerator& accelerator) override;
   gfx::Size CalculatePreferredSize() const override;
   int GetHeightForWidth(int width) const override;
-  void VisibilityChanged(views::View* starting_from, bool visible) override;
 
   // views::ButtonListener:
   void ButtonPressed(views::Button* sender, const ui::Event& event) override;
 
-  // ui::EventObserver:
-  void OnEvent(const ui::Event& event) override;
-
   void set_delegate(CaptionBarDelegate* delegate) { delegate_ = delegate; }
 
   // Sets visibility for the caption button identified by |id|.
@@ -71,8 +54,6 @@
 
   CaptionBarDelegate* delegate_ = nullptr;
 
-  std::unique_ptr<views::EventMonitor> event_monitor_;
-
   DISALLOW_COPY_AND_ASSIGN(CaptionBar);
 };
 
--- a/ash/assistant/ui/dialog_plate/action_view.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/ui/dialog_plate/action_view.h	2019-05-17 18:53:08.108000000 +0300
@@ -7,7 +7,6 @@
 
 #include "ash/assistant/model/assistant_interaction_model_observer.h"
 #include "ash/assistant/ui/base/assistant_button.h"
-#include "base/component_export.h"
 #include "base/macros.h"
 
 namespace ash {
@@ -19,8 +18,7 @@
 
 // A stateful view belonging to DialogPlate which indicates current user input
 // modality and delivers notification of press events.
-class COMPONENT_EXPORT(ASSISTANT_UI) ActionView
-    : public AssistantButton,
+class ActionView : public AssistantButton,
       public AssistantInteractionModelObserver {
  public:
   ActionView(views::ButtonListener* listener,
--- a/ash/assistant/ui/dialog_plate/dialog_plate.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/ui/dialog_plate/dialog_plate.cc	2019-05-17 18:53:08.108000000 +0300
@@ -73,6 +73,14 @@
   delegate_->RemoveInteractionModelObserver(this);
 }
 
+void DialogPlate::AddObserver(DialogPlateObserver* observer) {
+  observers_.AddObserver(observer);
+}
+
+void DialogPlate::RemoveObserver(DialogPlateObserver* observer) {
+  observers_.RemoveObserver(observer);
+}
+
 const char* DialogPlate::GetClassName() const {
   return "DialogPlate";
 }
@@ -107,7 +115,8 @@
       // Only non-empty trimmed text is consider a valid contents commit.
       // Anything else will simply result in the DialogPlate being cleared.
       if (!trimmed_text.empty()) {
-        delegate_->OnDialogPlateContentsCommitted(
+        for (DialogPlateObserver& observer : observers_)
+          observer.OnDialogPlateContentsCommitted(
             base::UTF16ToUTF8(trimmed_text));
       }
 
@@ -318,7 +327,7 @@
       l10n_util::GetStringUTF16(IDS_ASH_ASSISTANT_DIALOG_PLATE_HINT);
   textfield_->set_placeholder_text(textfield_hint);
   textfield_->SetAccessibleName(textfield_hint);
-  textfield_->set_placeholder_text_color(kTextColorSecondary);
+  textfield_->set_placeholder_text_color(kTextColorHint);
   textfield_->SetTextColor(kTextColorPrimary);
   keyboard_layout_container_->AddChildView(textfield_);
 
@@ -379,7 +388,9 @@
 }
 
 void DialogPlate::OnButtonPressed(AssistantButtonId id) {
-  delegate_->OnDialogPlateButtonPressed(id);
+  for (DialogPlateObserver& observer : observers_)
+    observer.OnDialogPlateButtonPressed(id);
+
   textfield_->SetText(base::string16());
 }
 
--- a/ash/assistant/ui/dialog_plate/dialog_plate.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/ui/dialog_plate/dialog_plate.h	2019-05-17 18:53:08.108000000 +0300
@@ -12,8 +12,8 @@
 #include "ash/assistant/model/assistant_query_history.h"
 #include "ash/assistant/model/assistant_ui_model_observer.h"
 #include "ash/assistant/ui/dialog_plate/action_view.h"
-#include "base/component_export.h"
 #include "base/macros.h"
+#include "base/observer_list.h"
 #include "ui/views/controls/button/button.h"
 #include "ui/views/controls/textfield/textfield_controller.h"
 #include "ui/views/view.h"
@@ -32,6 +32,20 @@
 enum class AssistantButtonId;
 class AssistantViewDelegate;
 
+// DialogPlateObserver ---------------------------------------------------------
+
+class DialogPlateObserver : public base::CheckedObserver {
+ public:
+  // Invoked when the dialog plate button identified by |id| is pressed.
+  virtual void OnDialogPlateButtonPressed(AssistantButtonId id) {}
+
+  // Invoked on dialog plate contents committed event.
+  virtual void OnDialogPlateContentsCommitted(const std::string& text) {}
+
+ protected:
+  ~DialogPlateObserver() override = default;
+};
+
 // DialogPlate -----------------------------------------------------------------
 
 // DialogPlate is the child of AssistantMainView concerned with providing the
@@ -39,8 +53,7 @@
 // provides a textfield for use with the keyboard input modality, and an
 // ActionView which serves to either commit a text query, or toggle voice
 // interaction as appropriate for the user's current input modality.
-class COMPONENT_EXPORT(ASSISTANT_UI) DialogPlate
-    : public views::View,
+class DialogPlate : public views::View,
       public views::TextfieldController,
       public AssistantInteractionModelObserver,
       public AssistantUiModelObserver,
@@ -49,6 +62,10 @@
   explicit DialogPlate(AssistantViewDelegate* delegate);
   ~DialogPlate() override;
 
+  // Adds/removes the specified |observer|.
+  void AddObserver(DialogPlateObserver* observer);
+  void RemoveObserver(DialogPlateObserver* observer);
+
   // views::View:
   const char* GetClassName() const override;
   gfx::Size CalculatePreferredSize() const override;
@@ -102,6 +119,8 @@
   std::unique_ptr<ui::CallbackLayerAnimationObserver> animation_observer_;
   std::unique_ptr<AssistantQueryHistory::Iterator> query_history_iterator_;
 
+  base::ObserverList<DialogPlateObserver> observers_;
+
   DISALLOW_COPY_AND_ASSIGN(DialogPlate);
 };
 
--- a/ash/assistant/ui/logo_view/base_logo_view.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/ui/logo_view/base_logo_view.h	2019-05-17 18:53:08.108000000 +0300
@@ -5,13 +5,12 @@
 #ifndef ASH_ASSISTANT_UI_LOGO_VIEW_BASE_LOGO_VIEW_H_
 #define ASH_ASSISTANT_UI_LOGO_VIEW_BASE_LOGO_VIEW_H_
 
-#include "base/component_export.h"
 #include "base/macros.h"
 #include "ui/views/view.h"
 
 namespace ash {
 
-class COMPONENT_EXPORT(ASSISTANT_UI) BaseLogoView : public views::View {
+class BaseLogoView : public views::View {
  public:
   enum class State {
     kUndefined,
--- a/ash/assistant/ui/main_stage/assistant_card_element_view.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/ui/main_stage/assistant_card_element_view.cc	2019-05-17 18:53:08.108000000 +0300
@@ -8,9 +8,7 @@
 
 #include "ash/assistant/model/assistant_ui_element.h"
 #include "ash/assistant/ui/assistant_container_view.h"
-#include "ash/assistant/ui/assistant_ui_constants.h"
 #include "ash/assistant/ui/assistant_view_delegate.h"
-#include "ui/aura/window.h"
 #include "ui/aura/window_tree_host.h"
 #include "ui/events/event.h"
 #include "ui/events/event_sink.h"
@@ -82,7 +80,7 @@
   // vertically. As such, we need to prevent the Assistant card window from
   // receiving events it doesn't need. It needs mouse click events for
   // handling links.
-  window->SetProperty(ash::assistant::ui::kOnlyAllowMouseClickEvents, true);
+  AssistantContainerView::OnlyAllowMouseClickEvents(window);
 }
 
 void AssistantCardElementView::ChildPreferredSizeChanged(views::View* child) {
--- a/ash/assistant/ui/main_stage/assistant_card_element_view.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/ui/main_stage/assistant_card_element_view.h	2019-05-17 18:53:08.108000000 +0300
@@ -5,7 +5,6 @@
 #ifndef ASH_ASSISTANT_UI_MAIN_STAGE_ASSISTANT_CARD_ELEMENT_VIEW_H_
 #define ASH_ASSISTANT_UI_MAIN_STAGE_ASSISTANT_CARD_ELEMENT_VIEW_H_
 
-#include "base/component_export.h"
 #include "base/macros.h"
 #include "services/content/public/cpp/navigable_contents.h"
 #include "services/content/public/cpp/navigable_contents_view.h"
@@ -18,8 +17,7 @@
 
 // AssistantCardElementView is the visual representation of an
 // AssistantCardElement. It is a child view of UiElementContainerView.
-class COMPONENT_EXPORT(ASSISTANT_UI) AssistantCardElementView
-    : public views::View,
+class AssistantCardElementView : public views::View,
       public content::NavigableContentsObserver {
  public:
   AssistantCardElementView(AssistantViewDelegate* delegate,
--- a/ash/assistant/ui/main_stage/assistant_footer_view.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/ui/main_stage/assistant_footer_view.cc	2019-05-17 18:53:08.108000000 +0300
@@ -6,6 +6,7 @@
 
 #include <utility>
 
+#include "ash/assistant/assistant_setup_controller.h"
 #include "ash/assistant/ui/assistant_ui_constants.h"
 #include "ash/assistant/ui/assistant_view_delegate.h"
 #include "ash/assistant/ui/main_stage/assistant_opt_in_view.h"
@@ -68,50 +69,46 @@
   SetLayoutManager(std::make_unique<views::FillLayout>());
 
   // Initial view state is based on user consent state.
-  const bool consent_given = delegate_->GetConsentStatus() ==
-                             mojom::ConsentStatus::kActivityControlAccepted;
-
+  const bool setup_completed =
+      delegate_->VoiceInteractionControllerSetupCompleted();
   // Suggestion container.
   suggestion_container_ = new SuggestionContainerView(delegate_);
-  suggestion_container_->set_can_process_events_within_subtree(consent_given);
+  suggestion_container_->set_can_process_events_within_subtree(setup_completed);
 
   // Suggestion container will be animated on its own layer.
   suggestion_container_->SetPaintToLayer();
   suggestion_container_->layer()->SetFillsBoundsOpaquely(false);
-  suggestion_container_->layer()->SetOpacity(consent_given ? 1.f : 0.f);
-  suggestion_container_->SetVisible(consent_given);
+  suggestion_container_->layer()->SetOpacity(setup_completed ? 1.f : 0.f);
+  suggestion_container_->SetVisible(setup_completed);
 
   AddChildView(suggestion_container_);
 
   // Opt in view.
-  opt_in_view_ = new AssistantOptInView(delegate_);
-  opt_in_view_->set_can_process_events_within_subtree(!consent_given);
+  opt_in_view_ = new AssistantOptInView();
+  opt_in_view_->set_can_process_events_within_subtree(!setup_completed);
+  opt_in_view_->set_delegate(delegate_->GetOptInDelegate());
 
   // Opt in view will be animated on its own layer.
   opt_in_view_->SetPaintToLayer();
   opt_in_view_->layer()->SetFillsBoundsOpaquely(false);
-  opt_in_view_->layer()->SetOpacity(consent_given ? 0.f : 1.f);
-  opt_in_view_->SetVisible(!consent_given);
+  opt_in_view_->layer()->SetOpacity(setup_completed ? 0.f : 1.f);
+  opt_in_view_->SetVisible(!setup_completed);
 
   AddChildView(opt_in_view_);
 }
 
-void AssistantFooterView::OnVoiceInteractionConsentStatusUpdated(
-    mojom::ConsentStatus consent_status) {
+void AssistantFooterView::OnVoiceInteractionSetupCompleted(bool completed) {
   using assistant::util::CreateLayerAnimationSequence;
   using assistant::util::CreateOpacityElement;
   using assistant::util::StartLayerAnimationSequence;
 
-  const bool consent_given =
-      consent_status == mojom::ConsentStatus::kActivityControlAccepted;
-
   // When the consent state changes, we need to hide/show the appropriate views.
   views::View* hide_view =
-      consent_given ? static_cast<views::View*>(opt_in_view_)
+      completed ? static_cast<views::View*>(opt_in_view_)
                     : static_cast<views::View*>(suggestion_container_);
 
   views::View* show_view =
-      consent_given ? static_cast<views::View*>(suggestion_container_)
+      completed ? static_cast<views::View*>(suggestion_container_)
                     : static_cast<views::View*>(opt_in_view_);
 
   // Reset visibility to enable animation.
@@ -150,14 +147,14 @@
 
 bool AssistantFooterView::OnAnimationEnded(
     const ui::CallbackLayerAnimationObserver& observer) {
-  const bool consent_given = delegate_->GetConsentStatus() ==
-                             mojom::ConsentStatus::kActivityControlAccepted;
+  const bool setup_completed =
+      delegate_->VoiceInteractionControllerSetupCompleted();
 
   // Only the view relevant to our consent state should process events.
-  suggestion_container_->set_can_process_events_within_subtree(consent_given);
-  suggestion_container_->SetVisible(consent_given);
-  opt_in_view_->set_can_process_events_within_subtree(!consent_given);
-  opt_in_view_->SetVisible(!consent_given);
+  suggestion_container_->set_can_process_events_within_subtree(setup_completed);
+  suggestion_container_->SetVisible(setup_completed);
+  opt_in_view_->set_can_process_events_within_subtree(!setup_completed);
+  opt_in_view_->SetVisible(!setup_completed);
 
   // Return false to prevent the observer from destroying itself.
   return false;
--- a/ash/assistant/ui/main_stage/assistant_footer_view.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/ui/main_stage/assistant_footer_view.h	2019-05-17 18:53:08.108000000 +0300
@@ -10,7 +10,6 @@
 
 #include "ash/public/cpp/assistant/default_voice_interaction_observer.h"
 #include "ash/public/interfaces/voice_interaction_controller.mojom.h"
-#include "base/component_export.h"
 #include "base/macros.h"
 #include "ui/views/view.h"
 
@@ -24,8 +23,7 @@
 class AssistantViewDelegate;
 class SuggestionContainerView;
 
-class COMPONENT_EXPORT(ASSISTANT_UI) AssistantFooterView
-    : public views::View,
+class AssistantFooterView : public views::View,
       DefaultVoiceInteractionObserver {
  public:
   explicit AssistantFooterView(AssistantViewDelegate* delegate);
@@ -37,8 +35,7 @@
   int GetHeightForWidth(int width) const override;
 
   // mojom::VoiceInteractionObserver:
-  void OnVoiceInteractionConsentStatusUpdated(
-      mojom::ConsentStatus consent_status) override;
+  void OnVoiceInteractionSetupCompleted(bool completed) override;
 
  private:
   void InitLayout();
--- a/ash/assistant/ui/main_stage/assistant_header_view.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/ui/main_stage/assistant_header_view.h	2019-05-17 18:53:08.108000000 +0300
@@ -9,7 +9,6 @@
 
 #include "ash/assistant/model/assistant_interaction_model_observer.h"
 #include "ash/assistant/model/assistant_ui_model_observer.h"
-#include "base/component_export.h"
 #include "base/macros.h"
 #include "ui/views/view.h"
 
@@ -24,8 +23,7 @@
 
 // AssistantHeaderView is the child of UiElementContainerView which provides
 // the Assistant icon.
-class COMPONENT_EXPORT(ASSISTANT_UI) AssistantHeaderView
-    : public views::View,
+class AssistantHeaderView : public views::View,
       public AssistantInteractionModelObserver,
       public AssistantUiModelObserver {
  public:
--- a/ash/assistant/ui/main_stage/assistant_main_stage.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/ui/main_stage/assistant_main_stage.cc	2019-05-17 18:53:08.108000000 +0300
@@ -429,9 +429,6 @@
   using assistant::util::CreateOpacityElement;
   using assistant::util::CreateTransformElement;
 
-  if (!committed_query_view_)
-    return;
-
   // Clear the previously active query.
   OnActiveQueryCleared();
 
--- a/ash/assistant/ui/main_stage/assistant_main_stage.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/ui/main_stage/assistant_main_stage.h	2019-05-17 18:53:08.108000000 +0300
@@ -9,7 +9,6 @@
 
 #include "ash/assistant/model/assistant_interaction_model_observer.h"
 #include "ash/assistant/model/assistant_ui_model_observer.h"
-#include "base/component_export.h"
 #include "base/macros.h"
 #include "ui/views/view.h"
 #include "ui/views/view_observer.h"
@@ -34,8 +33,7 @@
 // AssistantMainStage is the child of AssistantMainView responsible for
 // displaying the Assistant interaction to the user. This includes visual
 // affordances for the query, response, as well as suggestions.
-class COMPONENT_EXPORT(ASSISTANT_UI) AssistantMainStage
-    : public views::View,
+class AssistantMainStage : public views::View,
       public views::ViewObserver,
       public AssistantInteractionModelObserver,
       public AssistantUiModelObserver {
--- a/ash/assistant/ui/main_stage/assistant_opt_in_view.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/ui/main_stage/assistant_opt_in_view.cc	2019-05-17 18:53:08.108000000 +0300
@@ -8,8 +8,6 @@
 #include <vector>
 
 #include "ash/assistant/ui/assistant_ui_constants.h"
-#include "ash/assistant/ui/assistant_view_delegate.h"
-#include "ash/public/cpp/app_list/app_list_features.h"
 #include "ash/strings/grit/ash_strings.h"
 #include "ui/base/l10n/l10n_util.h"
 #include "ui/gfx/canvas.h"
@@ -36,13 +34,6 @@
   return style;
 }
 
-base::string16 GetAction(mojom::ConsentStatus consent_status) {
-  return consent_status == mojom::ConsentStatus::kUnauthorized
-             ? l10n_util::GetStringUTF16(
-                   IDS_ASH_ASSISTANT_OPT_IN_ASK_ADMINISTRATOR)
-             : l10n_util::GetStringUTF16(IDS_ASH_ASSISTANT_OPT_IN_GET_STARTED);
-}
-
 // AssistantOptInContainer -----------------------------------------------------
 
 class AssistantOptInContainer : public views::Button {
@@ -86,15 +77,11 @@
 
 // AssistantOptInView ----------------------------------------------------------
 
-AssistantOptInView::AssistantOptInView(AssistantViewDelegate* delegate)
-    : delegate_(delegate) {
+AssistantOptInView::AssistantOptInView() {
   InitLayout();
-  delegate_->AddVoiceInteractionControllerObserver(this);
 }
 
-AssistantOptInView::~AssistantOptInView() {
-  delegate_->RemoveVoiceInteractionControllerObserver(this);
-}
+AssistantOptInView::~AssistantOptInView() = default;
 
 const char* AssistantOptInView::GetClassName() const {
   return "AssistantOptInView";
@@ -108,66 +95,49 @@
   label_->SizeToFit(width());
 }
 
-void AssistantOptInView::ButtonPressed(views::Button* sender,
-                                       const ui::Event& event) {
-  delegate_->OnOptInButtonPressed();
-}
-
-void AssistantOptInView::OnVoiceInteractionConsentStatusUpdated(
-    mojom::ConsentStatus consent_status) {
-  UpdateLabel(consent_status);
-}
-
 void AssistantOptInView::InitLayout() {
   views::BoxLayout* layout_manager =
       SetLayoutManager(std::make_unique<views::BoxLayout>(
           views::BoxLayout::Orientation::kHorizontal));
 
   layout_manager->set_cross_axis_alignment(
-      app_list_features::IsEmbeddedAssistantUIEnabled()
-          ? views::BoxLayout::CrossAxisAlignment::CROSS_AXIS_ALIGNMENT_CENTER
-          : views::BoxLayout::CrossAxisAlignment::CROSS_AXIS_ALIGNMENT_END);
+      views::BoxLayout::CrossAxisAlignment::CROSS_AXIS_ALIGNMENT_END);
 
   layout_manager->set_main_axis_alignment(
       views::BoxLayout::MainAxisAlignment::MAIN_AXIS_ALIGNMENT_CENTER);
 
   // Container.
-  container_ = new AssistantOptInContainer(/*listener=*/this);
+  AssistantOptInContainer* container =
+      new AssistantOptInContainer(/*listener=*/this);
 
   layout_manager =
-      container_->SetLayoutManager(std::make_unique<views::BoxLayout>(
+      container->SetLayoutManager(std::make_unique<views::BoxLayout>(
           views::BoxLayout::Orientation::kHorizontal,
           gfx::Insets(0, kPaddingDip)));
 
   layout_manager->set_cross_axis_alignment(
       views::BoxLayout::CrossAxisAlignment::CROSS_AXIS_ALIGNMENT_CENTER);
 
-  AddChildView(container_);
+  AddChildView(container);
 
   // Label.
   label_ = new views::StyledLabel(base::string16(), /*listener=*/nullptr);
   label_->set_auto_color_readability_enabled(false);
   label_->SetHorizontalAlignment(gfx::HorizontalAlignment::ALIGN_CENTER);
 
-  container_->AddChildView(label_);
-  container_->SetFocusForPlatform();
-
-  UpdateLabel(delegate_->GetConsentStatus());
-}
-
-void AssistantOptInView::UpdateLabel(mojom::ConsentStatus consent_status) {
   // First substitution string: "Unlock more Assistant features."
   const base::string16 unlock_features =
       l10n_util::GetStringUTF16(IDS_ASH_ASSISTANT_OPT_IN_UNLOCK_MORE_FEATURES);
 
-  // Second substitution string specifies the action to be taken.
-  const base::string16 action = GetAction(consent_status);
+  // Second substitution string: "Get Started".
+  const base::string16 get_started =
+      l10n_util::GetStringUTF16(IDS_ASH_ASSISTANT_OPT_IN_GET_STARTED);
 
   // Set the text, having replaced placeholders in the opt in prompt with
   // substitution strings and caching their offset positions for styling.
   std::vector<size_t> offsets;
   auto label_text = l10n_util::GetStringFUTF16(
-      IDS_ASH_ASSISTANT_OPT_IN_PROMPT, unlock_features, action, &offsets);
+      IDS_ASH_ASSISTANT_OPT_IN_PROMPT, unlock_features, get_started, &offsets);
   label_->SetText(label_text);
 
   // Style the first substitution string.
@@ -177,10 +147,19 @@
 
   // Style the second substitution string.
   label_->AddStyleRange(
-      gfx::Range(offsets.at(1), offsets.at(1) + action.length()),
+      gfx::Range(offsets.at(1), offsets.at(1) + get_started.length()),
       CreateStyleInfo(gfx::Font::Weight::BOLD));
 
-  container_->SetAccessibleName(label_text);
+  container->AddChildView(label_);
+
+  container->SetFocusForPlatform();
+  container->SetAccessibleName(label_text);
+}
+
+void AssistantOptInView::ButtonPressed(views::Button* sender,
+                                       const ui::Event& event) {
+  if (delegate_)
+    delegate_->OnOptInButtonPressed();
 }
 
 }  // namespace ash
--- a/ash/assistant/ui/main_stage/assistant_opt_in_view.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/ui/main_stage/assistant_opt_in_view.h	2019-05-17 18:53:08.108000000 +0300
@@ -5,9 +5,6 @@
 #ifndef ASH_ASSISTANT_UI_MAIN_STAGE_ASSISTANT_OPT_IN_VIEW_H_
 #define ASH_ASSISTANT_UI_MAIN_STAGE_ASSISTANT_OPT_IN_VIEW_H_
 
-#include "ash/public/cpp/assistant/default_voice_interaction_observer.h"
-#include "ash/public/interfaces/voice_interaction_controller.mojom.h"
-#include "base/component_export.h"
 #include "base/macros.h"
 #include "ui/views/controls/button/button.h"
 
@@ -17,16 +14,22 @@
 
 namespace ash {
 
-class AssistantViewDelegate;
+// AssistantOptInDelegate ------------------------------------------------------
+
+class AssistantOptInDelegate {
+ public:
+  // Invoked when the Assistant opt in button is pressed.
+  virtual void OnOptInButtonPressed() = 0;
+
+ protected:
+  virtual ~AssistantOptInDelegate() = default;
+};
 
 // AssistantOptInView ----------------------------------------------------------
 
-class COMPONENT_EXPORT(ASSISTANT_UI) AssistantOptInView
-    : public views::View,
-      public views::ButtonListener,
-      public DefaultVoiceInteractionObserver {
+class AssistantOptInView : public views::View, public views::ButtonListener {
  public:
-  explicit AssistantOptInView(AssistantViewDelegate* delegate_);
+  AssistantOptInView();
   ~AssistantOptInView() override;
 
   // views::View:
@@ -37,19 +40,14 @@
   // views::ButtonListener:
   void ButtonPressed(views::Button* sender, const ui::Event& event) override;
 
-  // DefaultVoiceInteractionObserver:
-  void OnVoiceInteractionConsentStatusUpdated(
-      mojom::ConsentStatus consent_status) override;
+  void set_delegate(AssistantOptInDelegate* delegate) { delegate_ = delegate; }
 
  private:
   void InitLayout();
-  void UpdateLabel(mojom::ConsentStatus consent_status);
 
   views::StyledLabel* label_;  // Owned by view hierarchy.
 
-  views::Button* container_;
-
-  AssistantViewDelegate* delegate_;
+  AssistantOptInDelegate* delegate_ = nullptr;
 
   DISALLOW_COPY_AND_ASSIGN(AssistantOptInView);
 };
--- a/ash/assistant/ui/main_stage/assistant_progress_indicator.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/ui/main_stage/assistant_progress_indicator.cc	2019-05-17 18:53:08.108000000 +0300
@@ -7,7 +7,6 @@
 #include <algorithm>
 
 #include "ash/assistant/util/animation_util.h"
-#include "ash/public/cpp/app_list/app_list_features.h"
 #include "base/bind.h"
 #include "base/time/time.h"
 #include "ui/compositor/layer_animation_element.h"
@@ -25,7 +24,6 @@
 constexpr int kDotCount = 3;
 constexpr float kDotLargeSizeDip = 9.f;
 constexpr float kDotSmallSizeDip = 6.f;
-constexpr int kEmbeddedUiPreferredHeightDip = 9;
 constexpr int kSpacingDip = 4;
 
 // Animation.
@@ -75,19 +73,26 @@
 
 AssistantProgressIndicator::~AssistantProgressIndicator() = default;
 
-const char* AssistantProgressIndicator::GetClassName() const {
-  return "AssistantProgressIndicator";
-}
+void AssistantProgressIndicator::InitLayout() {
+  SetLayoutManager(std::make_unique<views::BoxLayout>(
+      views::BoxLayout::Orientation::kHorizontal, gfx::Insets(), kSpacingDip));
 
-gfx::Size AssistantProgressIndicator::CalculatePreferredSize() const {
-  const int preferred_width = views::View::CalculatePreferredSize().width();
-  return gfx::Size(preferred_width, GetHeightForWidth(preferred_width));
+  // Initialize dots.
+  for (int i = 0; i < kDotCount; ++i) {
+    views::View* dot_view = new views::View();
+    dot_view->SetBackground(std::make_unique<DotBackground>());
+    dot_view->SetPreferredSize(gfx::Size(kDotSmallSizeDip, kDotSmallSizeDip));
+
+    // Dots will animate on their own layers.
+    dot_view->SetPaintToLayer();
+    dot_view->layer()->SetFillsBoundsOpaquely(false);
+
+    AddChildView(dot_view);
+  }
 }
 
-int AssistantProgressIndicator::GetHeightForWidth(int width) const {
-  return app_list_features::IsEmbeddedAssistantUIEnabled()
-             ? kEmbeddedUiPreferredHeightDip
-             : views::View::GetHeightForWidth(width);
+const char* AssistantProgressIndicator::GetClassName() const {
+  return "AssistantProgressIndicator";
 }
 
 void AssistantProgressIndicator::AddedToWidget() {
@@ -101,21 +106,17 @@
 void AssistantProgressIndicator::OnLayerOpacityChanged(
     ui::PropertyChangeReason reason) {
   VisibilityChanged(/*starting_from=*/this,
-                    /*is_visible=*/visible());
+                    /*is_visible=*/layer()->opacity() > 0.f);
 }
 
 void AssistantProgressIndicator::VisibilityChanged(views::View* starting_from,
                                                    bool is_visible) {
-  // Stop the animation when the view is either not visible or is "visible" but
-  // not actually visible to the user (because it is faded out).
-  const bool is_drawn =
-      IsDrawn() && !cc::MathUtil::IsWithinEpsilon(layer()->opacity(), 0.f);
-  if (is_drawn_ == is_drawn)
+  if (is_visible == is_visible_)
     return;
 
-  is_drawn_ = is_drawn;
+  is_visible_ = is_visible;
 
-  if (!is_drawn_) {
+  if (!is_visible_) {
     // Stop all animations.
     for (int i = 0; i < child_count(); ++i) {
       child_at(i)->layer()->GetAnimator()->StopAnimating();
@@ -160,27 +161,4 @@
   }
 }
 
-void AssistantProgressIndicator::InitLayout() {
-  views::BoxLayout* layout_manager =
-      SetLayoutManager(std::make_unique<views::BoxLayout>(
-          views::BoxLayout::Orientation::kHorizontal, gfx::Insets(),
-          kSpacingDip));
-
-  layout_manager->set_cross_axis_alignment(
-      views::BoxLayout::CrossAxisAlignment::CROSS_AXIS_ALIGNMENT_CENTER);
-
-  // Initialize dots.
-  for (int i = 0; i < kDotCount; ++i) {
-    views::View* dot_view = new views::View();
-    dot_view->SetBackground(std::make_unique<DotBackground>());
-    dot_view->SetPreferredSize(gfx::Size(kDotSmallSizeDip, kDotSmallSizeDip));
-
-    // Dots will animate on their own layers.
-    dot_view->SetPaintToLayer();
-    dot_view->layer()->SetFillsBoundsOpaquely(false);
-
-    AddChildView(dot_view);
-  }
-}
-
 }  // namespace ash
--- a/ash/assistant/ui/main_stage/assistant_progress_indicator.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/ui/main_stage/assistant_progress_indicator.h	2019-05-17 18:53:08.108000000 +0300
@@ -7,22 +7,18 @@
 
 #include <memory>
 
-#include "base/component_export.h"
 #include "base/macros.h"
 #include "ui/views/view.h"
 
 namespace ash {
 
-class COMPONENT_EXPORT(ASSISTANT_UI) AssistantProgressIndicator
-    : public views::View {
+class AssistantProgressIndicator : public views::View {
  public:
   AssistantProgressIndicator();
   ~AssistantProgressIndicator() override;
 
   // views::View:
   const char* GetClassName() const override;
-  gfx::Size CalculatePreferredSize() const override;
-  int GetHeightForWidth(int width) const override;
   void AddedToWidget() override;
   void RemovedFromWidget() override;
   void OnLayerOpacityChanged(ui::PropertyChangeReason reason) override;
@@ -33,7 +29,7 @@
 
   // Caches the last call to VisibilityChanged. Because we trigger this event
   // artificially, we want to make sure that we don't over trigger.
-  bool is_drawn_ = false;
+  bool is_visible_ = false;
 
   DISALLOW_COPY_AND_ASSIGN(AssistantProgressIndicator);
 };
--- a/ash/assistant/ui/main_stage/assistant_query_view.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/ui/main_stage/assistant_query_view.cc	2019-05-17 18:53:08.108000000 +0300
@@ -128,7 +128,7 @@
       label_->AddStyleRange(gfx::Range(high_confidence_text_16.length(),
                                        high_confidence_text_16.length() +
                                            low_confidence_text_16.length()),
-                            CreateStyleInfo(kTextColorSecondary));
+                            CreateStyleInfo(kTextColorHint));
     }
   }
   label_->SizeToFit(width());
--- a/ash/assistant/ui/main_stage/assistant_query_view.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/ui/main_stage/assistant_query_view.h	2019-05-17 18:53:08.108000000 +0300
@@ -7,7 +7,6 @@
 
 #include <string>
 
-#include "base/component_export.h"
 #include "base/macros.h"
 #include "ui/views/controls/styled_label.h"
 #include "ui/views/view.h"
@@ -18,7 +17,7 @@
 
 // AssistantQueryView is the visual representation of an AssistantQuery. It is a
 // child view of UiElementContainerView.
-class COMPONENT_EXPORT(ASSISTANT_UI) AssistantQueryView : public views::View {
+class AssistantQueryView : public views::View {
  public:
   AssistantQueryView();
   ~AssistantQueryView() override;
--- a/ash/assistant/ui/main_stage/assistant_text_element_view.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/ui/main_stage/assistant_text_element_view.h	2019-05-17 18:53:08.108000000 +0300
@@ -5,7 +5,6 @@
 #ifndef ASH_ASSISTANT_UI_MAIN_STAGE_ASSISTANT_TEXT_ELEMENT_VIEW_H_
 #define ASH_ASSISTANT_UI_MAIN_STAGE_ASSISTANT_TEXT_ELEMENT_VIEW_H_
 
-#include "base/component_export.h"
 #include "base/macros.h"
 #include "ui/views/controls/label.h"
 
@@ -15,8 +14,7 @@
 
 // AssistantTextElementView is the visual representation of an
 // AssistantTextElement. It is a child view of UiElementContainerView.
-class COMPONENT_EXPORT(ASSISTANT_UI) AssistantTextElementView
-    : public views::Label {
+class AssistantTextElementView : public views::Label {
  public:
   explicit AssistantTextElementView(const AssistantTextElement* text_element);
   ~AssistantTextElementView() override;
--- a/ash/assistant/ui/main_stage/suggestion_container_view.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/ui/main_stage/suggestion_container_view.cc	2019-05-17 18:53:08.108000000 +0300
@@ -12,8 +12,6 @@
 #include "ash/assistant/ui/assistant_ui_constants.h"
 #include "ash/assistant/ui/assistant_view_delegate.h"
 #include "ash/assistant/util/assistant_util.h"
-#include "ash/public/cpp/app_list/app_list_features.h"
-#include "base/bind.h"
 #include "base/strings/utf_string_conversions.h"
 #include "ui/views/layout/box_layout.h"
 
@@ -73,9 +71,7 @@
           gfx::Insets(0, kPaddingDip), kSpacingDip));
 
   layout_manager_->set_cross_axis_alignment(
-      app_list_features::IsEmbeddedAssistantUIEnabled()
-          ? views::BoxLayout::CrossAxisAlignment::CROSS_AXIS_ALIGNMENT_CENTER
-          : views::BoxLayout::CrossAxisAlignment::CROSS_AXIS_ALIGNMENT_END);
+      views::BoxLayout::CrossAxisAlignment::CROSS_AXIS_ALIGNMENT_END);
 
   // We center align when showing conversation starters.
   layout_manager_->set_main_axis_alignment(
@@ -119,7 +115,8 @@
     // suggestion chip view.
     const int id = suggestion.first;
 
-    SuggestionChipView::Params params;
+    app_list::SuggestionChipView::Params params;
+    params.assistant_style = true;
     params.text = base::UTF8ToUTF16(suggestion.second->text);
 
     if (!suggestion.second->icon_url.is_empty()) {
@@ -136,8 +133,8 @@
       params.icon = gfx::ImageSkia();
     }
 
-    SuggestionChipView* suggestion_chip_view =
-        new SuggestionChipView(params, /*listener=*/this);
+    app_list::SuggestionChipView* suggestion_chip_view =
+        new app_list::SuggestionChipView(params, /*listener=*/this);
     suggestion_chip_view->SetAccessibleName(params.text);
 
     // Given a suggestion chip view, we need to be able to look up the id of
@@ -184,6 +181,7 @@
             sender->id());
   }
 
+  // TODO(dmblack): Use a delegate pattern here similar to CaptionBar.
   delegate_->OnSuggestionChipPressed(suggestion);
 }
 
--- a/ash/assistant/ui/main_stage/suggestion_container_view.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/ui/main_stage/suggestion_container_view.h	2019-05-17 18:53:08.108000000 +0300
@@ -8,12 +8,11 @@
 #include <map>
 #include <memory>
 
+#include "ash/app_list/views/suggestion_chip_view.h"
 #include "ash/assistant/model/assistant_cache_model_observer.h"
 #include "ash/assistant/model/assistant_interaction_model_observer.h"
 #include "ash/assistant/model/assistant_ui_model_observer.h"
 #include "ash/assistant/ui/base/assistant_scroll_view.h"
-#include "ash/assistant/ui/main_stage/suggestion_chip_view.h"
-#include "base/component_export.h"
 #include "base/macros.h"
 #include "chromeos/services/assistant/public/mojom/assistant.mojom.h"
 #include "ui/views/controls/scroll_view.h"
@@ -29,8 +28,7 @@
 // SuggestionContainerView is the child of AssistantMainView concerned with
 // laying out SuggestionChipViews in response to Assistant interaction model
 // suggestion events.
-class COMPONENT_EXPORT(ASSISTANT_UI) SuggestionContainerView
-    : public AssistantScrollView,
+class SuggestionContainerView : public AssistantScrollView,
       public AssistantCacheModelObserver,
       public AssistantInteractionModelObserver,
       public AssistantUiModelObserver,
@@ -86,7 +84,7 @@
   // Cache of suggestion chip views owned by the view hierarchy. The key for the
   // map is the unique identifier by which the Assistant interaction model
   // identifies the view's underlying suggestion.
-  std::map<int, SuggestionChipView*> suggestion_chip_views_;
+  std::map<int, app_list::SuggestionChipView*> suggestion_chip_views_;
 
   // True if we have received a query response during this Assistant UI session,
   // false otherwise.
--- a/ash/assistant/ui/main_stage/ui_element_container_view.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/ui/main_stage/ui_element_container_view.cc	2019-05-17 18:53:08.108000000 +0300
@@ -13,7 +13,6 @@
 #include "ash/assistant/ui/main_stage/assistant_card_element_view.h"
 #include "ash/assistant/ui/main_stage/assistant_text_element_view.h"
 #include "ash/assistant/util/animation_util.h"
-#include "ash/public/cpp/app_list/app_list_features.h"
 #include "base/callback.h"
 #include "base/time/time.h"
 #include "ui/aura/window.h"
@@ -28,17 +27,14 @@
 namespace {
 
 // Appearance.
-constexpr int kEmbeddedUiFirstCardMarginTopDip = 8;
-constexpr int kEmbeddedUiPaddingBottomDip = 8;
-constexpr int kMainUiFirstCardMarginTopDip = 40;
-constexpr int kMainUiPaddingBottomDip = 24;
+constexpr int kFirstCardMarginTopDip = 40;
+constexpr int kPaddingBottomDip = 24;
 
 // Card element animation.
 constexpr float kCardElementAnimationFadeOutOpacity = 0.26f;
 
 // Text element animation.
-constexpr float kEmbeddedUiTextElementAnimationFadeOutOpacity = 0.26f;
-constexpr float kMainUiTextElementAnimationFadeOutOpacity = 0.f;
+constexpr float kTextElementAnimationFadeOutOpacity = 0.f;
 
 // UI element animation.
 constexpr base::TimeDelta kUiElementAnimationFadeInDelay =
@@ -47,27 +43,6 @@
     base::TimeDelta::FromMilliseconds(250);
 constexpr base::TimeDelta kUiElementAnimationFadeOutDuration =
     base::TimeDelta::FromMilliseconds(167);
-
-// Helpers ---------------------------------------------------------------------
-
-int GetFirstCardMarginTopDip() {
-  return app_list_features::IsEmbeddedAssistantUIEnabled()
-             ? kEmbeddedUiFirstCardMarginTopDip
-             : kMainUiFirstCardMarginTopDip;
-}
-
-int GetPaddingBottomDip() {
-  return app_list_features::IsEmbeddedAssistantUIEnabled()
-             ? kEmbeddedUiPaddingBottomDip
-             : kMainUiPaddingBottomDip;
-}
-
-float GetTextElementAnimationFadeOutOpacity() {
-  return app_list_features::IsEmbeddedAssistantUIEnabled()
-             ? kEmbeddedUiTextElementAnimationFadeOutOpacity
-             : kMainUiTextElementAnimationFadeOutOpacity;
-}
-
 }  // namespace
 
 // UiElementContainerView ------------------------------------------------------
@@ -131,7 +106,7 @@
 void UiElementContainerView::InitLayout() {
   content_view()->SetLayoutManager(std::make_unique<views::BoxLayout>(
       views::BoxLayout::Orientation::kVertical,
-      gfx::Insets(0, kUiElementHorizontalMarginDip, GetPaddingBottomDip(),
+      gfx::Insets(0, kUiElementHorizontalMarginDip, kPaddingBottomDip,
                   kUiElementHorizontalMarginDip),
       kSpacingDip));
 }
@@ -254,12 +229,12 @@
   if (is_first_card_) {
     is_first_card_ = false;
 
-    // The first card requires a top margin of |GetFirstCardMarginTopDip()|, but
+    // The first card requires a top margin of |kFirstCardMarginTopDip|, but
     // we need to account for child spacing because the first card is not
     // necessarily the first UI element.
     const int top_margin_dip = child_count() == 0
-                                   ? GetFirstCardMarginTopDip()
-                                   : GetFirstCardMarginTopDip() - kSpacingDip;
+                                   ? kFirstCardMarginTopDip
+                                   : kFirstCardMarginTopDip - kSpacingDip;
 
     // We effectively create a top margin by applying an empty border.
     card_element_view->SetBorder(
@@ -296,7 +271,7 @@
   // We cache the view for use during animations and its desired opacity that
   // we'll animate to while processing the next query response.
   ui_element_views_.push_back(std::pair<ui::LayerOwner*, float>(
-      text_element_view, GetTextElementAnimationFadeOutOpacity()));
+      text_element_view, kTextElementAnimationFadeOutOpacity));
 
   content_view()->AddChildView(text_element_view);
 }
--- a/ash/assistant/ui/main_stage/ui_element_container_view.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/ui/main_stage/ui_element_container_view.h	2019-05-17 18:53:08.108000000 +0300
@@ -12,7 +12,6 @@
 
 #include "ash/assistant/model/assistant_interaction_model_observer.h"
 #include "ash/assistant/ui/base/assistant_scroll_view.h"
-#include "base/component_export.h"
 #include "base/macros.h"
 #include "ui/views/view_observer.h"
 
@@ -30,8 +29,7 @@
 // UiElementContainerView is the child of AssistantMainView concerned with
 // laying out text views and embedded card views in response to Assistant
 // interaction model UI element events.
-class COMPONENT_EXPORT(ASSISTANT_UI) UiElementContainerView
-    : public AssistantScrollView,
+class UiElementContainerView : public AssistantScrollView,
       public AssistantInteractionModelObserver {
  public:
   explicit UiElementContainerView(AssistantViewDelegate* delegate);
--- a/ash/assistant/util/assistant_util.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/util/assistant_util.cc	2019-05-17 18:53:08.108000000 +0300
@@ -20,41 +20,6 @@
   return new_visibility == AssistantVisibility::kClosed;
 }
 
-bool IsVoiceEntryPoint(AssistantEntryPoint entry_point, bool prefer_voice) {
-  switch (entry_point) {
-    case AssistantEntryPoint::kHotword:
-    case AssistantEntryPoint::kLauncherSearchBoxMic:
-      return true;
-    case AssistantEntryPoint::kHotkey:
-    case AssistantEntryPoint::kLauncherSearchBox:
-    case AssistantEntryPoint::kLongPressLauncher:
-      return prefer_voice;
-    case AssistantEntryPoint::kUnspecified:
-    case AssistantEntryPoint::kDeepLink:
-    case AssistantEntryPoint::kLauncherSearchResult:
-    case AssistantEntryPoint::kSetup:
-    case AssistantEntryPoint::kStylus:
-      return false;
-  }
-}
-
-bool ShouldAttemptWarmerWelcome(AssistantEntryPoint entry_point) {
-  switch (entry_point) {
-    case AssistantEntryPoint::kDeepLink:
-    case AssistantEntryPoint::kHotword:
-    case AssistantEntryPoint::kLauncherSearchBoxMic:
-    case AssistantEntryPoint::kLauncherSearchResult:
-    case AssistantEntryPoint::kStylus:
-      return false;
-    case AssistantEntryPoint::kUnspecified:
-    case AssistantEntryPoint::kHotkey:
-    case AssistantEntryPoint::kLauncherSearchBox:
-    case AssistantEntryPoint::kLongPressLauncher:
-    case AssistantEntryPoint::kSetup:
-      return true;
-  }
-}
-
 }  // namespace util
 }  // namespace assistant
 }  // namespace ash
--- a/ash/assistant/util/assistant_util.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/util/assistant_util.h	2019-05-17 18:53:08.112000000 +0300
@@ -9,7 +9,6 @@
 
 namespace ash {
 
-enum class AssistantEntryPoint;
 enum class AssistantVisibility;
 
 namespace assistant {
@@ -24,17 +23,6 @@
 COMPONENT_EXPORT(ASSISTANT_UTIL)
 bool IsFinishingSession(AssistantVisibility new_visibility);
 
-// Returns true if the |entry_point| should start Assistant with a voice
-// interaction.
-// |prefer_voice| is true if user prefers voice input modality or if the device
-// is in tablet mode.
-COMPONENT_EXPORT(ASSISTANT_UTIL)
-bool IsVoiceEntryPoint(AssistantEntryPoint entry_point, bool prefer_voice);
-
-// Returns true if the |entry_point| should attempt warmer welcome.
-COMPONENT_EXPORT(ASSISTANT_UTIL)
-bool ShouldAttemptWarmerWelcome(AssistantEntryPoint entry_point);
-
 }  // namespace util
 }  // namespace assistant
 }  // namespace ash
--- a/ash/assistant/util/BUILD.gn	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/util/BUILD.gn	2019-05-17 18:53:08.108000000 +0300
@@ -18,8 +18,6 @@
     "deep_link_util.h",
     "histogram_util.cc",
     "histogram_util.h",
-    "i18n_util.cc",
-    "i18n_util.h",
   ]
 
   deps = [
--- a/ash/assistant/util/deep_link_util.cc	2019-05-17 17:45:36.492000000 +0300
+++ b/ash/assistant/util/deep_link_util.cc	2019-05-17 18:53:08.112000000 +0300
@@ -7,7 +7,7 @@
 #include <array>
 #include <set>
 
-#include "ash/assistant/util/i18n_util.h"
+#include "base/i18n/rtl.h"
 #include "base/stl_util.h"
 #include "base/strings/string_split.h"
 #include "base/strings/string_util.h"
@@ -27,14 +27,11 @@
 constexpr char kQueryParamKey[] = "q";
 constexpr char kPageParamKey[] = "page";
 constexpr char kRelaunchParamKey[] = "relaunch";
-constexpr char kSourceParamKey[] = "source";
 
 // Supported deep link prefixes. These values must be kept in sync with the
 // server. See more details at go/cros-assistant-deeplink.
 constexpr char kChromeSettingsPrefix[] = "googleassistant://chrome-settings";
 constexpr char kAssistantFeedbackPrefix[] = "googleassistant://send-feedback";
-constexpr char kAssistantListsPrefix[] = "googleassistant://lists";
-constexpr char kAssistantNotesPrefix[] = "googleassistant://notes";
 constexpr char kAssistantOnboardingPrefix[] = "googleassistant://onboarding";
 constexpr char kAssistantQueryPrefix[] = "googleassistant://send-query";
 constexpr char kAssistantRemindersPrefix[] = "googleassistant://reminders";
@@ -45,6 +42,15 @@
 constexpr char kAssistantWhatsOnMyScreenPrefix[] =
     "googleassistant://whats-on-my-screen";
 
+// Helpers ---------------------------------------------------------------------
+
+// Returns a GURL for the specified |url| having set the locale query parameter.
+GURL CreateLocalizedGURL(const std::string& url) {
+  static constexpr char kLocaleParamKey[] = "hl";
+  return net::AppendOrReplaceQueryParameter(GURL(url), kLocaleParamKey,
+                                            base::i18n::GetConfiguredLocale());
+}
+
 }  // namespace
 
 // Utilities -------------------------------------------------------------------
@@ -123,8 +129,6 @@
   static const std::map<DeepLinkType, std::string> kSupportedDeepLinks = {
       {DeepLinkType::kChromeSettings, kChromeSettingsPrefix},
       {DeepLinkType::kFeedback, kAssistantFeedbackPrefix},
-      {DeepLinkType::kLists, kAssistantListsPrefix},
-      {DeepLinkType::kNotes, kAssistantNotesPrefix},
       {DeepLinkType::kOnboarding, kAssistantOnboardingPrefix},
       {DeepLinkType::kQuery, kAssistantQueryPrefix},
       {DeepLinkType::kReminders, kAssistantRemindersPrefix},
@@ -150,40 +154,15 @@
   return GetDeepLinkType(url) != DeepLinkType::kUnsupported;
 }
 
-base::Optional<GURL> GetAssistantUrl(DeepLinkType type,
-                                     const base::Optional<std::string>& id) {
-  std::string top_level_url;
-  std::string by_id_url;
-
-  switch (type) {
-    case DeepLinkType::kLists:
-      top_level_url =
-          std::string("https://assistant.9oo91e.qjz9zk/lists/mainview");
-      by_id_url = std::string("https://assistant.9oo91e.qjz9zk/lists/list/");
-      break;
-    case DeepLinkType::kNotes:
-      top_level_url = std::string(
-          "https://assistant.9oo91e.qjz9zk/lists/mainview?note_tap=true");
-      by_id_url = std::string("https://assistant.9oo91e.qjz9zk/lists/note/");
-      break;
-    case DeepLinkType::kReminders:
-      top_level_url =
-          std::string("https://assistant.9oo91e.qjz9zk/reminders/mainview");
-      by_id_url = std::string("https://assistant.9oo91e.qjz9zk/reminders/id/");
-      break;
-    default:
-      NOTREACHED();
-      return base::nullopt;
-  }
-
-  const std::string url =
-      (id && !id.value().empty()) ? (by_id_url + id.value()) : top_level_url;
-
-  // Source is currently assumed to be |Assistant|. If need be, we can make
-  // |source| a deep link parameter in the future.
-  constexpr char kDefaultSource[] = "Assistant";
-  return net::AppendOrReplaceQueryParameter(CreateLocalizedGURL(url),
-                                            kSourceParamKey, kDefaultSource);
+GURL GetAssistantRemindersUrl(const base::Optional<std::string>& id) {
+  // TODO(b/113357196): Make these URLs configurable for development purposes.
+  static constexpr char kAssistantRemindersWebUrl[] =
+      "https://assistant.google.com/reminders/mainview";
+  static constexpr char kAssistantRemindersByIdWebUrl[] =
+      "https://assistant.google.com/reminders/id/";
+  return (id && !id.value().empty())
+             ? CreateLocalizedGURL(kAssistantRemindersByIdWebUrl + id.value())
+             : CreateLocalizedGURL(kAssistantRemindersWebUrl);
 }
 
 GURL GetChromeSettingsUrl(const base::Optional<std::string>& page) {
@@ -208,19 +187,17 @@
 base::Optional<GURL> GetWebUrl(
     DeepLinkType type,
     const std::map<std::string, std::string>& params) {
+  // TODO(b/113357196): Make these URLs configurable for development purposes.
   static constexpr char kAssistantSettingsWebUrl[] =
-      "https://assistant.9oo91e.qjz9zk/settings/mainpage";
+      "https://assistant.google.com/settings/mainpage";
 
   if (!IsWebDeepLinkType(type))
     return base::nullopt;
 
   switch (type) {
-    case DeepLinkType::kLists:
-    case DeepLinkType::kNotes:
-    case DeepLinkType::kReminders: {
-      const auto id = GetDeepLinkParam(params, DeepLinkParam::kId);
-      return GetAssistantUrl(type, id);
-    }
+    case DeepLinkType::kReminders:
+      return GetAssistantRemindersUrl(
+          GetDeepLinkParam(params, DeepLinkParam::kId));
     case DeepLinkType::kSettings:
       return CreateLocalizedGURL(kAssistantSettingsWebUrl);
     case DeepLinkType::kUnsupported:
@@ -245,8 +222,7 @@
 
 bool IsWebDeepLinkType(DeepLinkType type) {
   // Set of deep link types which open web contents in the Assistant UI.
-  static const std::set<DeepLinkType> kWebDeepLinks = {
-      DeepLinkType::kLists, DeepLinkType::kNotes, DeepLinkType::kReminders,
+  static const std::set<DeepLinkType> kWebDeepLinks = {DeepLinkType::kReminders,
       DeepLinkType::kSettings};
 
   return base::ContainsKey(kWebDeepLinks, type);
--- a/ash/assistant/util/deep_link_util.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/assistant/util/deep_link_util.h	2019-05-17 18:53:08.112000000 +0300
@@ -22,8 +22,6 @@
   kUnsupported,
   kChromeSettings,
   kFeedback,
-  kLists,
-  kNotes,
   kOnboarding,
   kQuery,
   kReminders,
@@ -82,14 +80,10 @@
 // Returns true if the specified |url| is a deep link, false otherwise.
 COMPONENT_EXPORT(ASSISTANT_UTIL) bool IsDeepLinkUrl(const GURL& url);
 
-// Returns the Assistant URL for the deep link of the specified |type|. A return
-// value will only be present if the deep link type is one of {kLists, kNotes,
-// or kReminders}. If |id| is absent, the returned URL will be for the top-level
-// Assistant URL. Otherwise, the URL will correspond to the resource identified
-// by |id|.
+// Returns the URL for the specified Assistant reminder |id|. If id is absent,
+// the returned URL will be for top-level Assistant Reminders.
 COMPONENT_EXPORT(ASSISTANT_UTIL)
-base::Optional<GURL> GetAssistantUrl(DeepLinkType type,
-                                     const base::Optional<std::string>& id);
+GURL GetAssistantRemindersUrl(const base::Optional<std::string>& id);
 
 // Returns the URL for the specified Chrome Settings |page|. If page is absent
 // or not allowed, the URL will be for top-level Chrome Settings.
--- a/ash/assistant/util/deep_link_util_unittest.cc	2019-05-17 17:45:36.496000000 +0300
+++ b/ash/assistant/util/deep_link_util_unittest.cc	2019-05-17 18:53:08.112000000 +0300
@@ -67,7 +67,7 @@
   ASSERT_TRUE(params.empty());
 
   // FAIL: Non-deep link URLs.
-  ParseDeepLinkParams("https://www.9oo91e.qjz9zk/search?q=query");
+  ParseDeepLinkParams("https://www.google.com/search?q=query");
   ASSERT_TRUE(params.empty());
 
   // FAIL: Empty URLs.
@@ -139,8 +139,6 @@
   const std::map<std::string, DeepLinkType> test_cases = {
       // OK: Supported deep links.
       {"googleassistant://chrome-settings", DeepLinkType::kChromeSettings},
-      {"googleassistant://lists", DeepLinkType::kLists},
-      {"googleassistant://notes", DeepLinkType::kNotes},
       {"googleassistant://onboarding", DeepLinkType::kOnboarding},
       {"googleassistant://reminders", DeepLinkType::kReminders},
       {"googleassistant://send-feedback", DeepLinkType::kFeedback},
@@ -153,8 +151,6 @@
       // OK: Parameterized deep links.
       {"googleassistant://chrome-settings?param=true",
        DeepLinkType::kChromeSettings},
-      {"googleassistant://lists?param=true", DeepLinkType::kLists},
-      {"googleassistant://notes?param=true", DeepLinkType::kNotes},
       {"googleassistant://onboarding?param=true", DeepLinkType::kOnboarding},
       {"googleassistant://reminders?param=true", DeepLinkType::kReminders},
       {"googleassistant://send-feedback?param=true", DeepLinkType::kFeedback},
@@ -168,8 +164,6 @@
 
       // UNSUPPORTED: Deep links are case sensitive.
       {"GOOGLEASSISTANT://CHROME-SETTINGS", DeepLinkType::kUnsupported},
-      {"GOOGLEASSISTANT://LISTS", DeepLinkType::kUnsupported},
-      {"GOOGLEASSISTANT://NOTES", DeepLinkType::kUnsupported},
       {"GOOGLEASSISTANT://ONBOARDING", DeepLinkType::kUnsupported},
       {"GOOGLEASSISTANT://REMINDERS", DeepLinkType::kUnsupported},
       {"GOOGLEASSISTANT://SEND-FEEDBACK", DeepLinkType::kUnsupported},
@@ -185,7 +179,7 @@
 
       // UNSUPPORTED: Non-deep link URLs.
       {std::string(), DeepLinkType::kUnsupported},
-      {"https://www.9oo91e.qjz9zk/", DeepLinkType::kUnsupported}};
+      {"https://www.google.com/", DeepLinkType::kUnsupported}};
 
   for (const auto& test_case : test_cases)
     ASSERT_EQ(test_case.second, GetDeepLinkType(GURL(test_case.first)));
@@ -195,8 +189,6 @@
   const std::map<std::string, DeepLinkType> test_cases = {
       // OK: Supported deep link types.
       {"googleassistant://chrome-settings", DeepLinkType::kChromeSettings},
-      {"googleassistant://lists", DeepLinkType::kLists},
-      {"googleassistant://notes", DeepLinkType::kNotes},
       {"googleassistant://onboarding", DeepLinkType::kOnboarding},
       {"googleassistant://reminders", DeepLinkType::kReminders},
       {"googleassistant://send-feedback", DeepLinkType::kFeedback},
@@ -209,8 +201,6 @@
       // OK: Parameterized deep link types.
       {"googleassistant://chrome-settings?param=true",
        DeepLinkType::kChromeSettings},
-      {"googleassistant://lists?param=true", DeepLinkType::kLists},
-      {"googleassistant://notes?param=true", DeepLinkType::kNotes},
       {"googleassistant://onboarding?param=true", DeepLinkType::kOnboarding},
       {"googleassistant://reminders?param=true", DeepLinkType::kReminders},
       {"googleassistant://send-feedback?param=true", DeepLinkType::kFeedback},
@@ -224,8 +214,6 @@
 
       // UNSUPPORTED: Deep links are case sensitive.
       {"GOOGLEASSISTANT://CHROME-SETTINGS", DeepLinkType::kUnsupported},
-      {"GOOGLEASSISTANT://LISTS", DeepLinkType::kUnsupported},
-      {"GOOGLEASSISTANT://NOTES", DeepLinkType::kUnsupported},
       {"GOOGLEASSISTANT://ONBOARDING", DeepLinkType::kUnsupported},
       {"GOOGLEASSISTANT://REMINDERS", DeepLinkType::kUnsupported},
       {"GOOGLEASSISTANT://SEND-FEEDBACK", DeepLinkType::kUnsupported},
@@ -239,7 +227,7 @@
 
       // UNSUPPORTED: Non-deep link URLs.
       {std::string(), DeepLinkType::kUnsupported},
-      {"https://www.9oo91e.qjz9zk/", DeepLinkType::kUnsupported}};
+      {"https://www.google.com/", DeepLinkType::kUnsupported}};
 
   for (const auto& test_case : test_cases)
     ASSERT_TRUE(IsDeepLinkType(GURL(test_case.first), test_case.second));
@@ -249,8 +237,6 @@
   const std::map<std::string, bool> test_cases = {
       // OK: Supported deep links.
       {"googleassistant://chrome-settings", true},
-      {"googleassistant://lists", true},
-      {"googleassistant://notes", true},
       {"googleassistant://onboarding", true},
       {"googleassistant://reminders", true},
       {"googleassistant://send-feedback", true},
@@ -262,8 +248,6 @@
 
       // OK: Parameterized deep links.
       {"googleassistant://chrome-settings?param=true", true},
-      {"googleassistant://lists?param=true", true},
-      {"googleassistant://notes?param=true", true},
       {"googleassistant://onboarding?param=true", true},
       {"googleassistant://reminders?param=true", true},
       {"googleassistant://send-feedback?param=true", true},
@@ -275,8 +259,6 @@
 
       // FAIL: Deep links are case sensitive.
       {"GOOGLEASSISTANT://CHROME-SETTINGS", false},
-      {"GOOGLEASSISTANT://LISTS", false},
-      {"GOOGLEASSISTANT://NOTES", false},
       {"GOOGLEASSISTANT://ONBOARDING", false},
       {"GOOGLEASSISTANT://REMINDERS", false},
       {"GOOGLEASSISTANT://SEND-FEEDBACK", false},
@@ -292,125 +274,27 @@
 
       // FAIL: Non-deep link URLs.
       {std::string(), false},
-      {"https://www.9oo91e.qjz9zk/", false}};
+      {"https://www.google.com/", false}};
 
   for (const auto& test_case : test_cases)
     ASSERT_EQ(test_case.second, IsDeepLinkUrl(GURL(test_case.first)));
 }
 
-TEST_F(DeepLinkUnitTest, GetAssistantUrl) {
-  using TestCase = std::pair<DeepLinkType, base::Optional<std::string>>;
-
-  auto CreateTestCase = [](DeepLinkType type, base::Optional<std::string> id) {
-    return std::make_pair(type, id);
-  };
-
-  auto CreateIgnoreCase = [](DeepLinkType type,
-                             base::Optional<std::string> id) {
-    return std::make_pair(std::make_pair(type, id), base::nullopt);
-  };
-
-  const std::map<TestCase, base::Optional<GURL>> test_cases = {
-      // OK: Top-level lists.
-
-      {CreateTestCase(DeepLinkType::kLists, /*id=*/base::nullopt),
-       GURL("https://assistant.9oo91e.qjz9zk/lists/"
-            "mainview?hl=en-US&source=Assistant")},
-
-      {CreateTestCase(DeepLinkType::kLists, /*id=*/std::string()),
-       GURL("https://assistant.9oo91e.qjz9zk/lists/"
-            "mainview?hl=en-US&source=Assistant")},
-
-      // OK: List by |id|.
-
-      {CreateTestCase(DeepLinkType::kLists, /*id=*/"123456"),
-       GURL("https://assistant.9oo91e.qjz9zk/lists/list/"
-            "123456?hl=en-US&source=Assistant")},
-
-      // OK: Top-level notes.
-
-      {CreateTestCase(DeepLinkType::kNotes, /*id=*/base::nullopt),
-       GURL("https://assistant.9oo91e.qjz9zk/lists/"
-            "mainview?note_tap=true&hl=en-US&source=Assistant")},
-
-      {CreateTestCase(DeepLinkType::kNotes, /*id=*/std::string()),
-       GURL("https://assistant.9oo91e.qjz9zk/lists/"
-            "mainview?note_tap=true&hl=en-US&source=Assistant")},
-
-      // OK: Note by |id|.
-
-      {CreateTestCase(DeepLinkType::kNotes, /*id=*/"123456"),
-       GURL("https://assistant.9oo91e.qjz9zk/lists/note/"
-            "123456?hl=en-US&source=Assistant")},
-
-      // OK: Top-level reminders.
-
-      {CreateTestCase(DeepLinkType::kReminders, /*id=*/base::nullopt),
-       GURL("https://assistant.9oo91e.qjz9zk/reminders/"
-            "mainview?hl=en-US&source=Assistant")},
-
-      {CreateTestCase(DeepLinkType::kReminders, /*id=*/std::string()),
-       GURL("https://assistant.9oo91e.qjz9zk/reminders/"
-            "mainview?hl=en-US&source=Assistant")},
-
-      // OK: Reminder by |id|.
-
-      {CreateTestCase(DeepLinkType::kReminders, /*id=*/"123456"),
-       GURL("https://assistant.9oo91e.qjz9zk/reminders/id/"
-            "123456?hl=en-US&source=Assistant")},
-
-      // IGNORE: Deep links of other types.
-
-      CreateIgnoreCase(DeepLinkType::kUnsupported, /*id=*/base::nullopt),
-      CreateIgnoreCase(DeepLinkType::kUnsupported, /*id=*/std::string()),
-      CreateIgnoreCase(DeepLinkType::kUnsupported, /*id=*/"123456"),
-      CreateIgnoreCase(DeepLinkType::kChromeSettings, /*id=*/base::nullopt),
-      CreateIgnoreCase(DeepLinkType::kChromeSettings, /*id=*/std::string()),
-      CreateIgnoreCase(DeepLinkType::kChromeSettings, /*id=*/"123456"),
-      CreateIgnoreCase(DeepLinkType::kFeedback, /*id=*/base::nullopt),
-      CreateIgnoreCase(DeepLinkType::kFeedback, /*id=*/std::string()),
-      CreateIgnoreCase(DeepLinkType::kFeedback, /*id=*/"123456"),
-      CreateIgnoreCase(DeepLinkType::kOnboarding, /*id=*/base::nullopt),
-      CreateIgnoreCase(DeepLinkType::kOnboarding, /*id=*/std::string()),
-      CreateIgnoreCase(DeepLinkType::kOnboarding, /*id=*/"123456"),
-      CreateIgnoreCase(DeepLinkType::kQuery, /*id=*/base::nullopt),
-      CreateIgnoreCase(DeepLinkType::kQuery, /*id=*/std::string()),
-      CreateIgnoreCase(DeepLinkType::kQuery, /*id=*/"123456"),
-      CreateIgnoreCase(DeepLinkType::kScreenshot, /*id=*/base::nullopt),
-      CreateIgnoreCase(DeepLinkType::kScreenshot, /*id=*/std::string()),
-      CreateIgnoreCase(DeepLinkType::kScreenshot, /*id=*/"123456"),
-      CreateIgnoreCase(DeepLinkType::kSettings, /*id=*/base::nullopt),
-      CreateIgnoreCase(DeepLinkType::kSettings, /*id=*/std::string()),
-      CreateIgnoreCase(DeepLinkType::kSettings, /*id=*/"123456"),
-      CreateIgnoreCase(DeepLinkType::kTaskManager, /*id=*/base::nullopt),
-      CreateIgnoreCase(DeepLinkType::kTaskManager, /*id=*/std::string()),
-      CreateIgnoreCase(DeepLinkType::kTaskManager, /*id=*/"123456"),
-      CreateIgnoreCase(DeepLinkType::kWhatsOnMyScreen, /*id=*/base::nullopt),
-      CreateIgnoreCase(DeepLinkType::kWhatsOnMyScreen, /*id=*/std::string()),
-      CreateIgnoreCase(DeepLinkType::kWhatsOnMyScreen, /*id=*/"123456")};
-
-  // For deep links that are not one of type {kLists, kNotes, kReminders}, we
-  // will hit NOTREACHED since this API isn't meant to be used in such cases.
-  // In unit tests, this would normally result in a DCHECK failure that would
-  // cause the test to fail so we'll use a |ScopedLogAssertHandler| to safely
-  // ignore the NOTREACHED assertion.
-  logging::ScopedLogAssertHandler handler(base::BindRepeating(
-      [](const char* file, int line, const base::StringPiece message,
-         const base::StringPiece stack_trace) {}));
-
-  for (const auto& test_case : test_cases) {
-    const base::Optional<GURL>& expected = test_case.second;
-    const base::Optional<GURL> actual = GetAssistantUrl(
-        /*type=*/test_case.first.first, /*id=*/test_case.first.second);
-
-    // Assert |has_value| equivalence.
-    ASSERT_EQ(expected, actual);
+TEST_F(DeepLinkUnitTest, GetAssistantRemindersUrl) {
+  const std::map<base::Optional<std::string>, std::string> test_cases = {
+      // OK: Absent/empty id.
+      {base::nullopt,
+       "https://assistant.google.com/reminders/mainview?hl=en-US"},
+      {base::Optional<std::string>(std::string()),
+       "https://assistant.google.com/reminders/mainview?hl=en-US"},
+
+      // OK: Specified id.
+      {base::Optional<std::string>("123456"),
+       "https://assistant.google.com/reminders/id/123456?hl=en-US"}};
 
-    // Assert |value| equivalence.
-    if (expected)
-      ASSERT_EQ(expected.value(), actual.value());
-  }
-}  // namespace util
+  for (const auto& test_case : test_cases)
+    ASSERT_EQ(test_case.second, GetAssistantRemindersUrl(test_case.first));
+}
 
 TEST_F(DeepLinkUnitTest, GetChromeSettingsUrl) {
   const std::map<base::Optional<std::string>, std::string> test_cases = {
@@ -437,33 +321,18 @@
 TEST_F(DeepLinkUnitTest, GetWebUrl) {
   const std::map<std::string, base::Optional<GURL>> test_cases = {
       // OK: Supported web deep links.
-      {"googleassistant://lists", GURL("https://assistant.9oo91e.qjz9zk/lists/"
-                                       "mainview?hl=en-US&source=Assistant")},
-      {"googleassistant://notes",
-       GURL("https://assistant.9oo91e.qjz9zk/lists/"
-            "mainview?note_tap=true&hl=en-US&source=Assistant")},
       {"googleassistant://reminders",
-       GURL("https://assistant.9oo91e.qjz9zk/reminders/"
-            "mainview?hl=en-US&source=Assistant")},
+       GURL("https://assistant.google.com/reminders/mainview?hl=en-US")},
       {"googleassistant://settings",
-       GURL("https://assistant.9oo91e.qjz9zk/settings/mainpage?hl=en-US")},
+       GURL("https://assistant.google.com/settings/mainpage?hl=en-US")},
 
       // OK: Parameterized deep links.
-      {"googleassistant://lists?id=123456",
-       GURL("https://assistant.9oo91e.qjz9zk/lists/list/"
-            "123456?hl=en-US&source=Assistant")},
-      {"googleassistant://notes?id=123456",
-       GURL("https://assistant.9oo91e.qjz9zk/lists/note/"
-            "123456?hl=en-US&source=Assistant")},
       {"googleassistant://reminders?id=123456",
-       GURL("https://assistant.9oo91e.qjz9zk/reminders/id/"
-            "123456?hl=en-US&source=Assistant")},
+       GURL("https://assistant.google.com/reminders/id/123456?hl=en-US")},
       {"googleassistant://settings?param=true",
-       GURL("https://assistant.9oo91e.qjz9zk/settings/mainpage?hl=en-US")},
+       GURL("https://assistant.google.com/settings/mainpage?hl=en-US")},
 
       // FAIL: Deep links are case sensitive.
-      {"GOOGLEASSISTANT://LISTS", base::nullopt},
-      {"GOOGLEASSISTANT://NOTES", base::nullopt},
       {"GOOGLEASSISTANT://REMINDERS", base::nullopt},
       {"GOOGLEASSISTANT://SETTINGS", base::nullopt},
 
@@ -478,7 +347,7 @@
 
       // FAIL: Non-deep link URLs.
       {std::string(), base::nullopt},
-      {"https://www.9oo91e.qjz9zk/", base::nullopt}};
+      {"https://www.google.com/", base::nullopt}};
 
   for (const auto& test_case : test_cases) {
     const base::Optional<GURL>& expected = test_case.second;
@@ -515,29 +384,13 @@
 
   const std::map<TestCase, base::Optional<GURL>> test_cases = {
       // OK: Supported web deep link types.
-      {CreateTestCase(DeepLinkType::kLists),
-       GURL("https://assistant.9oo91e.qjz9zk/lists/"
-            "mainview?hl=en-US&source=Assistant")},
-      {CreateTestCaseWithParam(DeepLinkType::kLists,
-                               std::make_pair("id", "123456")),
-       GURL("https://assistant.9oo91e.qjz9zk/lists/list/"
-            "123456?hl=en-US&source=Assistant")},
-      {CreateTestCase(DeepLinkType::kNotes),
-       GURL("https://assistant.9oo91e.qjz9zk/lists/"
-            "mainview?note_tap=true&hl=en-US&source=Assistant")},
-      {CreateTestCaseWithParam(DeepLinkType::kNotes,
-                               std::make_pair("id", "123456")),
-       GURL("https://assistant.9oo91e.qjz9zk/lists/note/"
-            "123456?hl=en-US&source=Assistant")},
       {CreateTestCase(DeepLinkType::kReminders),
-       GURL("https://assistant.9oo91e.qjz9zk/reminders/"
-            "mainview?hl=en-US&source=Assistant")},
+       GURL("https://assistant.google.com/reminders/mainview?hl=en-US")},
       {CreateTestCaseWithParam(DeepLinkType::kReminders,
                                std::make_pair("id", "123456")),
-       GURL("https://assistant.9oo91e.qjz9zk/reminders/id/"
-            "123456?hl=en-US&source=Assistant")},
+       GURL("https://assistant.google.com/reminders/id/123456?hl=en-US")},
       {CreateTestCase(DeepLinkType::kSettings),
-       GURL("https://assistant.9oo91e.qjz9zk/settings/mainpage?hl=en-US")},
+       GURL("https://assistant.google.com/settings/mainpage?hl=en-US")},
 
       // FAIL: Non-web deep link types.
       {CreateTestCase(DeepLinkType::kChromeSettings), base::nullopt},
@@ -568,20 +421,14 @@
 TEST_F(DeepLinkUnitTest, IsWebDeepLink) {
   const std::map<std::string, bool> test_cases = {
       // OK: Supported web deep links.
-      {"googleassistant://lists", true},
-      {"googleassistant://notes", true},
       {"googleassistant://reminders", true},
       {"googleassistant://settings", true},
 
       // OK: Parameterized deep links.
-      {"googleassistant://lists?param=true", true},
-      {"googleassistant://notes?param=true", true},
       {"googleassistant://reminders?param=true", true},
       {"googleassistant://settings?param=true", true},
 
       // FAIL: Deep links are case sensitive.
-      {"GOOGLEASSISTANT://LISTS", false},
-      {"GOOGLEASSISTANT://NOTES", false},
       {"GOOGLEASSISTANT://REMINDERS", false},
       {"GOOGLEASSISTANT://SETTINGS", false},
 
@@ -596,7 +443,7 @@
 
       // FAIL: Non-deep link URLs.
       {std::string(), false},
-      {"https://www.9oo91e.qjz9zk/", false}};
+      {"https://www.google.com/", false}};
 
   for (const auto& test_case : test_cases)
     ASSERT_EQ(test_case.second, IsWebDeepLink(GURL(test_case.first)));
@@ -605,8 +452,6 @@
 TEST_F(DeepLinkUnitTest, IsWebDeepLinkType) {
   const std::map<DeepLinkType, bool> test_cases = {
       // OK: Supported web deep link types.
-      {DeepLinkType::kLists, true},
-      {DeepLinkType::kNotes, true},
       {DeepLinkType::kReminders, true},
       {DeepLinkType::kSettings, true},
 
--- a/ash/autoclick/autoclick_controller.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/autoclick/autoclick_controller.cc	2019-05-17 18:53:08.112000000 +0300
@@ -14,12 +14,9 @@
 #include "ash/system/accessibility/autoclick_tray.h"
 #include "ash/system/status_area_widget.h"
 #include "ash/wm/root_window_finder.h"
-#include "base/bind.h"
-#include "base/command_line.h"
 #include "base/metrics/histogram_macros.h"
 #include "base/metrics/user_metrics.h"
 #include "base/timer/timer.h"
-#include "ui/accessibility/accessibility_switches.h"
 #include "ui/aura/window_tree_host.h"
 #include "ui/events/event.h"
 #include "ui/events/event_sink.h"
@@ -81,7 +78,6 @@
   Shell::GetPrimaryRootWindow()->GetHost()->GetEventSource()->AddEventRewriter(
       drag_event_rewriter_.get());
   InitClickTimers();
-  UpdateRingSize();
 }
 
 AutoclickController::~AutoclickController() {
@@ -142,11 +138,6 @@
   event_type_ = type;
 }
 
-void AutoclickController::SetMovementThreshold(int movement_threshold) {
-  movement_threshold_ = movement_threshold;
-  UpdateRingSize();
-}
-
 void AutoclickController::CreateAutoclickRingWidget(
     const gfx::Point& point_in_screen) {
   aura::Window* target = ash::wm::GetRootWindowAt(point_in_screen);
@@ -337,15 +328,6 @@
   }
 }
 
-void AutoclickController::UpdateRingSize() {
-  if (!base::CommandLine::ForCurrentProcess()->HasSwitch(
-          switches::kEnableExperimentalAccessibilityAutoclick)) {
-    return;
-  }
-  autoclick_ring_handler_->SetSize(movement_threshold_,
-                                   movement_threshold_ + 10);
-}
-
 bool AutoclickController::DragInProgress() const {
   return event_type_ == mojom::AutoclickEventType::kDragAndDrop &&
          drag_event_rewriter_->IsEnabled();
--- a/ash/autoclick/autoclick_controller.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/autoclick/autoclick_controller.h	2019-05-17 18:53:08.112000000 +0300
@@ -52,15 +52,17 @@
   // Sets the event type.
   void SetAutoclickEventType(mojom::AutoclickEventType type);
 
-  // Sets the movement threshold beyond which mouse movements cancel or begin
-  // a new Autoclick event.
-  void SetMovementThreshold(int movement_threshold);
-
   // Sets whether to revert to a left click after any other event type.
   void set_revert_to_left_click(bool revert_to_left_click) {
     revert_to_left_click_ = revert_to_left_click;
   }
 
+  // Sets the movement threshold beyond which mouse movements cancel or begin
+  // a new Autoclick event.
+  void set_movement_threshold(int movement_threshold) {
+    movement_threshold_ = movement_threshold;
+  }
+
   // Functionality for testing.
   static float GetStartGestureDelayRatioForTesting();
 
@@ -75,7 +77,6 @@
   void OnActionCompleted(mojom::AutoclickEventType event_type);
   void InitClickTimers();
   void UpdateRingWidget(const gfx::Point& mouse_location);
-  void UpdateRingSize();
   void RecordUserAction(mojom::AutoclickEventType event_type) const;
   bool DragInProgress() const;
 
--- a/ash/autoclick/autoclick_drag_event_rewriter.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/autoclick/autoclick_drag_event_rewriter.cc	2019-05-17 18:53:08.112000000 +0300
@@ -14,30 +14,38 @@
   return enabled_;
 }
 
-ui::EventDispatchDetails AutoclickDragEventRewriter::RewriteEvent(
+ui::EventRewriteStatus AutoclickDragEventRewriter::RewriteEvent(
     const ui::Event& event,
-    const Continuation continuation) {
+    std::unique_ptr<ui::Event>* new_event) {
   // Only rewrite mouse moved events to drag events when enabled.
   if (!enabled_)
-    return SendEvent(continuation, &event);
+    return ui::EVENT_REWRITE_CONTINUE;
 
   // On touchpads, a SCROLL_FLING_CANCEL can also indicate the start of a drag.
   // If this rewriter is enabled, a SCROLL_FLING_CANCEL should simply be
   // ignored.
   if (event.type() == ui::ET_SCROLL_FLING_CANCEL)
-    return DiscardEvent(continuation);
+    return ui::EVENT_REWRITE_DISCARD;
 
   // Only rewrite move events, but any other type should still go through.
   if (event.type() != ui::ET_MOUSE_MOVED)
-    return SendEvent(continuation, &event);
+    return ui::EVENT_REWRITE_CONTINUE;
 
   const ui::MouseEvent* mouse_event = event.AsMouseEvent();
-  ui::MouseEvent rewritten_event(
+  ui::MouseEvent* rewritten_event = new ui::MouseEvent(
       ui::ET_MOUSE_DRAGGED, mouse_event->location(),
       mouse_event->root_location(), mouse_event->time_stamp(),
       mouse_event->flags(), mouse_event->changed_button_flags(),
       mouse_event->pointer_details());
-  return SendEventFinally(continuation, &rewritten_event);
+  new_event->reset(rewritten_event);
+  return ui::EVENT_REWRITE_REWRITTEN;
+}
+
+ui::EventRewriteStatus AutoclickDragEventRewriter::NextDispatchEvent(
+    const ui::Event& last_event,
+    std::unique_ptr<ui::Event>* new_event) {
+  // Unused.
+  return ui::EVENT_REWRITE_CONTINUE;
 }
 
 }  // namespace ash
--- a/ash/autoclick/autoclick_drag_event_rewriter.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/autoclick/autoclick_drag_event_rewriter.h	2019-05-17 18:53:08.112000000 +0300
@@ -21,11 +21,16 @@
   bool IsEnabled() const;
 
   // ui::EventRewriter (visible for testing):
-  ui::EventDispatchDetails RewriteEvent(
+  ui::EventRewriteStatus RewriteEvent(
       const ui::Event& event,
-      const Continuation continuation) override;
+      std::unique_ptr<ui::Event>* new_event) override;
 
  private:
+  // ui::EventRewriter:
+  ui::EventRewriteStatus NextDispatchEvent(
+      const ui::Event& last_event,
+      std::unique_ptr<ui::Event>* new_event) override;
+
   bool enabled_ = false;
 
   DISALLOW_COPY_AND_ASSIGN(AutoclickDragEventRewriter);
--- a/ash/autoclick/autoclick_drag_event_rewriter_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/autoclick/autoclick_drag_event_rewriter_unittest.cc	2019-05-17 18:53:08.112000000 +0300
@@ -2,54 +2,35 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include <memory>
-
 #include "ash/autoclick/autoclick_drag_event_rewriter.h"
 #include "ash/test/ash_test_base.h"
 #include "ui/aura/window.h"
 #include "ui/aura/window_tree_host.h"
 #include "ui/events/base_event_utils.h"
 #include "ui/events/event_rewriter.h"
-#include "ui/events/event_sink.h"
 #include "ui/events/keycodes/keyboard_codes.h"
 #include "ui/events/test/event_generator.h"
-#include "ui/events/test/test_event_source.h"
 
 namespace ash {
 
-namespace {
-
-// EventSink that saves a copy of the most recent event.
-class CopyingSink : public ui::EventSink {
- public:
-  CopyingSink() {}
-  ~CopyingSink() override = default;
-  ui::Event* last_event() const { return last_event_.get(); }
-
-  // EventSink override:
-  ui::EventDispatchDetails OnEventFromSource(ui::Event* event) override {
-    last_event_ = ui::Event::Clone(*event);
-    return ui::EventDispatchDetails();
-  }
-
- private:
-  std::unique_ptr<ui::Event> last_event_;
-};
-
-}  // anonymous namespace
-
 class EventRecorder : public ui::EventRewriter {
  public:
   EventRecorder() = default;
   ~EventRecorder() override = default;
 
   // ui::EventRewriter:
-  ui::EventDispatchDetails RewriteEvent(
+  ui::EventRewriteStatus RewriteEvent(
       const ui::Event& event,
-      const Continuation continuation) override {
+      std::unique_ptr<ui::Event>* new_event) override {
     recorded_event_count_++;
     last_recorded_event_type_ = event.type();
-    return SendEvent(continuation, &event);
+    return ui::EVENT_REWRITE_CONTINUE;
+  }
+  ui::EventRewriteStatus NextDispatchEvent(
+      const ui::Event& last_event,
+      std::unique_ptr<ui::Event>* new_event) override {
+    NOTREACHED();
+    return ui::EVENT_REWRITE_CONTINUE;
   }
 
   // Count of events sent to the rewriter.
@@ -160,13 +141,10 @@
   int changed_button_flags = ui::EF_LEFT_MOUSE_BUTTON;  // Set a random flag.
   ui::MouseEvent event(ui::EventType::ET_MOUSE_MOVED, location, root_location,
                        time_stamp, flags, changed_button_flags);
-  CopyingSink sink;
-  ui::test::TestEventSource source(&sink);
-  source.AddEventRewriter(&drag_event_rewriter_);
-  source.Send(&event);
-  source.RemoveEventRewriter(&drag_event_rewriter_);
-  ui::Event* rewritten_event = sink.last_event();
-
+  std::unique_ptr<ui::Event> rewritten_event;
+  ui::EventRewriteStatus status =
+      drag_event_rewriter_.RewriteEvent(event, &rewritten_event);
+  EXPECT_EQ(ui::EVENT_REWRITE_REWRITTEN, status);
   // The type should be a drag.
   ASSERT_EQ(ui::ET_MOUSE_DRAGGED, rewritten_event->type());
 
--- a/ash/autoclick/autoclick_ring_handler.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/autoclick/autoclick_ring_handler.cc	2019-05-17 18:53:08.112000000 +0300
@@ -16,7 +16,6 @@
 namespace ash {
 namespace {
 
-// The default values of the autoclick ring widget size.
 const int kAutoclickRingOuterRadius = 30;
 const int kAutoclickRingInnerRadius = 20;
 
@@ -80,15 +79,11 @@
 class AutoclickRingHandler::AutoclickRingView : public views::View {
  public:
   AutoclickRingView(const gfx::Point& event_location,
-                    views::Widget* ring_widget,
-                    int outer_radius,
-                    int inner_radius)
+                    views::Widget* ring_widget)
       : views::View(),
         widget_(ring_widget),
         current_angle_(kAutoclickRingAngleStartValue),
-        current_scale_(kAutoclickRingScaleStartValue),
-        outer_radius_(outer_radius),
-        inner_radius_(inner_radius) {
+        current_scale_(kAutoclickRingScaleStartValue) {
     widget_->SetContentsView(this);
 
     // We are owned by the AutoclickRingHandler.
@@ -100,9 +95,9 @@
 
   void SetNewLocation(const gfx::Point& new_event_location) {
     gfx::Point point = new_event_location;
-    widget_->SetBounds(
-        gfx::Rect(point.x() - (outer_radius_ + kAutoclickRingGlowWidth),
-                  point.y() - (outer_radius_ + kAutoclickRingGlowWidth),
+    widget_->SetBounds(gfx::Rect(
+        point.x() - (kAutoclickRingOuterRadius + kAutoclickRingGlowWidth),
+        point.y() - (kAutoclickRingOuterRadius + kAutoclickRingGlowWidth),
                   GetPreferredSize().width(), GetPreferredSize().height()));
     widget_->Show();
     widget_->GetNativeView()->layer()->SetOpacity(
@@ -132,16 +127,11 @@
     SchedulePaint();
   }
 
-  void SetSize(int outer_radius, int inner_radius) {
-    outer_radius_ = outer_radius;
-    inner_radius_ = inner_radius;
-  }
-
  private:
   // Overridden from views::View.
   gfx::Size CalculatePreferredSize() const override {
-    return gfx::Size(2 * (outer_radius_ + kAutoclickRingGlowWidth),
-                     2 * (outer_radius_ + kAutoclickRingGlowWidth));
+    return gfx::Size(2 * (kAutoclickRingOuterRadius + kAutoclickRingGlowWidth),
+                     2 * (kAutoclickRingOuterRadius + kAutoclickRingGlowWidth));
   }
 
   void OnPaint(gfx::Canvas* canvas) override {
@@ -157,10 +147,10 @@
     canvas->Translate(-center.OffsetFromOrigin());
 
     // Paint inner circle.
-    PaintAutoclickRingArc(canvas, center, inner_radius_,
+    PaintAutoclickRingArc(canvas, center, kAutoclickRingInnerRadius,
                           kAutoclickRingInnerStartAngle, current_angle_);
     // Paint outer circle.
-    PaintAutoclickRingCircle(canvas, center, outer_radius_);
+    PaintAutoclickRingCircle(canvas, center, kAutoclickRingOuterRadius);
 
     canvas->Restore();
   }
@@ -168,8 +158,6 @@
   views::Widget* widget_;
   int current_angle_;
   double current_scale_;
-  int outer_radius_;
-  int inner_radius_;
 
   DISALLOW_COPY_AND_ASSIGN(AutoclickRingView);
 };
@@ -180,9 +168,7 @@
 AutoclickRingHandler::AutoclickRingHandler()
     : gfx::LinearAnimation(nullptr),
       ring_widget_(nullptr),
-      current_animation_type_(AnimationType::NONE),
-      outer_radius_(kAutoclickRingOuterRadius),
-      inner_radius_(kAutoclickRingInnerRadius) {}
+      current_animation_type_(AnimationType::NONE) {}
 
 AutoclickRingHandler::~AutoclickRingHandler() {
   StopAutoclickRing();
@@ -210,28 +196,19 @@
   tap_down_location_ = center_point_in_screen;
   ring_widget_ = widget;
 }
-
-void AutoclickRingHandler::SetSize(int outer_radius, int inner_radius) {
-  outer_radius_ = outer_radius;
-  inner_radius_ = inner_radius;
-  if (view_)
-    view_->SetSize(outer_radius, inner_radius);
-}
 ////////////////////////////////////////////////////////////////////////////////
 
 // AutoclickRingHandler, private
 void AutoclickRingHandler::StartAnimation(base::TimeDelta delay) {
   switch (current_animation_type_) {
     case AnimationType::GROW_ANIMATION: {
-      view_.reset(new AutoclickRingView(tap_down_location_, ring_widget_,
-                                        outer_radius_, inner_radius_));
+      view_.reset(new AutoclickRingView(tap_down_location_, ring_widget_));
       SetDuration(delay);
       Start();
       break;
     }
     case AnimationType::SHRINK_ANIMATION: {
-      view_.reset(new AutoclickRingView(tap_down_location_, ring_widget_,
-                                        outer_radius_, inner_radius_));
+      view_.reset(new AutoclickRingView(tap_down_location_, ring_widget_));
       SetDuration(delay);
       Start();
       break;
--- a/ash/autoclick/autoclick_ring_handler.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/autoclick/autoclick_ring_handler.h	2019-05-17 18:53:08.112000000 +0300
@@ -28,8 +28,6 @@
   void SetGestureCenter(const gfx::Point& center_point_in_screen,
                         views::Widget* widget);
 
-  void SetSize(int outer_radius, int inner_radius);
-
  private:
   class AutoclickRingView;
 
@@ -53,8 +51,6 @@
   gfx::Point tap_down_location_;
   AnimationType current_animation_type_;
   base::TimeDelta animation_duration_;
-  int outer_radius_;
-  int inner_radius_;
 
   DISALLOW_COPY_AND_ASSIGN(AutoclickRingHandler);
 };
--- a/ash/autoclick/autoclick_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/autoclick/autoclick_unittest.cc	2019-05-17 18:53:08.112000000 +0300
@@ -81,7 +81,7 @@
     scoped_task_environment_ =
         std::make_unique<base::test::ScopedTaskEnvironment>(
             base::test::ScopedTaskEnvironment::MainThreadType::UI_MOCK_TIME);
-  }
+  };
   ~AutoclickTest() override = default;
 
   void SetUp() override {
@@ -222,7 +222,7 @@
   // Try at a couple different thresholds.
   for (int movement_threshold = 10; movement_threshold < 50;
        movement_threshold += 10) {
-    GetAutoclickController()->SetMovementThreshold(movement_threshold);
+    GetAutoclickController()->set_movement_threshold(movement_threshold);
 
     // Run test for the secondary display too to test fix for crbug.com/449870.
     for (auto* root_window : root_windows) {
@@ -256,7 +256,7 @@
   }
 
   // Reset to default threshold.
-  GetAutoclickController()->SetMovementThreshold(20);
+  GetAutoclickController()->set_movement_threshold(20);
 }
 
 TEST_F(AutoclickTest, SingleKeyModifier) {
--- a/ash/BUILD.gn	2019-05-01 01:22:25.000000000 +0300
+++ b/ash/BUILD.gn	2019-05-17 18:53:08.060000000 +0300
@@ -4,8 +4,11 @@
 
 import("//build/config/features.gni")
 import("//build/config/ui.gni")
+import("//chromeos/assistant/assistant.gni")
 import("//mojo/public/tools/bindings/mojom.gni")
+import("//services/catalog/public/tools/catalog.gni")
 import("//services/service_manager/public/cpp/service_executable.gni")
+import("//services/service_manager/public/service_manifest.gni")
 import("//testing/test.gni")
 import("//tools/grit/repack.gni")
 import("//ui/base/ui_features.gni")
@@ -70,10 +73,8 @@
     "wm/mru_window_tracker.h",
     "wm/overview/overview_controller.h",
     "wm/splitview/split_view_controller.h",
-    "wm/tablet_mode/tablet_mode_browser_window_drag_delegate.h",
     "wm/tablet_mode/tablet_mode_controller.h",
     "wm/tablet_mode/tablet_mode_observer.h",
-    "wm/tablet_mode/tablet_mode_window_drag_controller.h",
     "wm/tablet_mode/tablet_mode_window_drag_delegate.h",
     "wm/window_finder.h",
     "wm/window_positioner.h",
@@ -157,6 +158,8 @@
     "app_list/app_list_controller_observer.h",
     "app_list/app_list_presenter_delegate_impl.cc",
     "app_list/app_list_presenter_delegate_impl.h",
+    "app_list/home_launcher_gesture_handler.cc",
+    "app_list/home_launcher_gesture_handler.h",
     "ash_export.h",
     "ash_service.cc",
     "assistant/assistant_alarm_timer_controller.cc",
@@ -178,6 +181,55 @@
     "assistant/assistant_ui_controller.h",
     "assistant/assistant_view_delegate_impl.cc",
     "assistant/assistant_view_delegate_impl.h",
+    "assistant/ui/assistant_background_layer.cc",
+    "assistant/ui/assistant_background_layer.h",
+    "assistant/ui/assistant_container_view.cc",
+    "assistant/ui/assistant_container_view.h",
+    "assistant/ui/assistant_container_view_animator.cc",
+    "assistant/ui/assistant_container_view_animator.h",
+    "assistant/ui/assistant_container_view_animator_legacy_impl.cc",
+    "assistant/ui/assistant_container_view_animator_legacy_impl.h",
+    "assistant/ui/assistant_container_view_focus_traversable.cc",
+    "assistant/ui/assistant_container_view_focus_traversable.h",
+    "assistant/ui/assistant_main_view.cc",
+    "assistant/ui/assistant_main_view.h",
+    "assistant/ui/assistant_mini_view.cc",
+    "assistant/ui/assistant_mini_view.h",
+    "assistant/ui/assistant_view_delegate.h",
+    "assistant/ui/assistant_web_view.cc",
+    "assistant/ui/assistant_web_view.h",
+    "assistant/ui/base/assistant_button.cc",
+    "assistant/ui/base/assistant_button.h",
+    "assistant/ui/base/assistant_scroll_view.cc",
+    "assistant/ui/base/assistant_scroll_view.h",
+    "assistant/ui/caption_bar.cc",
+    "assistant/ui/caption_bar.h",
+    "assistant/ui/dialog_plate/action_view.cc",
+    "assistant/ui/dialog_plate/action_view.h",
+    "assistant/ui/dialog_plate/dialog_plate.cc",
+    "assistant/ui/dialog_plate/dialog_plate.h",
+    "assistant/ui/logo_view/base_logo_view.cc",
+    "assistant/ui/logo_view/base_logo_view.h",
+    "assistant/ui/main_stage/assistant_card_element_view.cc",
+    "assistant/ui/main_stage/assistant_card_element_view.h",
+    "assistant/ui/main_stage/assistant_footer_view.cc",
+    "assistant/ui/main_stage/assistant_footer_view.h",
+    "assistant/ui/main_stage/assistant_header_view.cc",
+    "assistant/ui/main_stage/assistant_header_view.h",
+    "assistant/ui/main_stage/assistant_main_stage.cc",
+    "assistant/ui/main_stage/assistant_main_stage.h",
+    "assistant/ui/main_stage/assistant_opt_in_view.cc",
+    "assistant/ui/main_stage/assistant_opt_in_view.h",
+    "assistant/ui/main_stage/assistant_progress_indicator.cc",
+    "assistant/ui/main_stage/assistant_progress_indicator.h",
+    "assistant/ui/main_stage/assistant_query_view.cc",
+    "assistant/ui/main_stage/assistant_query_view.h",
+    "assistant/ui/main_stage/assistant_text_element_view.cc",
+    "assistant/ui/main_stage/assistant_text_element_view.h",
+    "assistant/ui/main_stage/suggestion_container_view.cc",
+    "assistant/ui/main_stage/suggestion_container_view.h",
+    "assistant/ui/main_stage/ui_element_container_view.cc",
+    "assistant/ui/main_stage/ui_element_container_view.h",
     "autoclick/autoclick_controller.cc",
     "autoclick/autoclick_controller.h",
     "autoclick/autoclick_drag_event_rewriter.cc",
@@ -190,10 +242,8 @@
     "cancel_mode.h",
     "cast_config_controller.cc",
     "cast_config_controller.h",
-    "custom_tab/arc_custom_tab_controller.cc",
-    "custom_tab/arc_custom_tab_controller.h",
-    "custom_tab/arc_custom_tab_view.cc",
-    "custom_tab/arc_custom_tab_view.h",
+    "contained_shell/contained_shell_controller.cc",
+    "contained_shell/contained_shell_controller.h",
     "dbus/ash_dbus_services.cc",
     "dbus/ash_dbus_services.h",
     "dbus/display_service_provider.cc",
@@ -307,12 +357,6 @@
     "highlighter/highlighter_result_view.h",
     "highlighter/highlighter_view.cc",
     "highlighter/highlighter_view.h",
-    "home_screen/home_launcher_gesture_handler.cc",
-    "home_screen/home_launcher_gesture_handler.h",
-    "home_screen/home_launcher_gesture_handler_observer.h",
-    "home_screen/home_screen_controller.cc",
-    "home_screen/home_screen_controller.h",
-    "home_screen/home_screen_delegate.h",
     "host/ash_window_tree_host.cc",
     "host/ash_window_tree_host.h",
     "host/ash_window_tree_host_init_params.h",
@@ -343,8 +387,6 @@
     "keyboard/virtual_keyboard_container_layout_manager.h",
     "keyboard/virtual_keyboard_controller.cc",
     "keyboard/virtual_keyboard_controller.h",
-    "kiosk_next/kiosk_next_shell_controller.cc",
-    "kiosk_next/kiosk_next_shell_controller.h",
     "laser/laser_pointer_controller.cc",
     "laser/laser_pointer_controller.h",
     "laser/laser_pointer_view.cc",
@@ -420,8 +462,6 @@
     "login/ui/non_accessible_view.h",
     "login/ui/note_action_launch_button.cc",
     "login/ui/note_action_launch_button.h",
-    "login/ui/parent_access_view.cc",
-    "login/ui/parent_access_view.h",
     "login/ui/pin_keyboard_animation.cc",
     "login/ui/pin_keyboard_animation.h",
     "login/ui/public_account_warning_dialog.cc",
@@ -454,11 +494,8 @@
     "metrics/demo_session_metrics_recorder.h",
     "metrics/desktop_task_switch_metric_recorder.cc",
     "metrics/desktop_task_switch_metric_recorder.h",
-    "metrics/histogram_macros.cc",
-    "metrics/histogram_macros.h",
     "metrics/login_metrics_recorder.cc",
     "metrics/login_metrics_recorder.h",
-    "metrics/pip_uma.h",
     "metrics/pointer_metrics_recorder.cc",
     "metrics/pointer_metrics_recorder.h",
     "metrics/task_switch_metrics_recorder.cc",
@@ -724,8 +761,6 @@
     "system/model/update_model.h",
     "system/model/virtual_keyboard_model.cc",
     "system/model/virtual_keyboard_model.h",
-    "system/network/active_network_icon.cc",
-    "system/network/active_network_icon.h",
     "system/network/auto_connect_notifier.cc",
     "system/network/auto_connect_notifier.h",
     "system/network/network_feature_pod_button.cc",
@@ -814,8 +849,6 @@
     "system/power/battery_notification.h",
     "system/power/dual_role_notification.cc",
     "system/power/dual_role_notification.h",
-    "system/power/notification_reporter.cc",
-    "system/power/notification_reporter.h",
     "system/power/peripheral_battery_notifier.cc",
     "system/power/peripheral_battery_notifier.h",
     "system/power/power_button_controller.cc",
@@ -1041,20 +1074,6 @@
     "wm/default_state.h",
     "wm/default_window_resizer.cc",
     "wm/default_window_resizer.h",
-    "wm/desks/close_desk_button.cc",
-    "wm/desks/close_desk_button.h",
-    "wm/desks/desk.cc",
-    "wm/desks/desk.h",
-    "wm/desks/desk_mini_view.cc",
-    "wm/desks/desk_mini_view.h",
-    "wm/desks/desk_mini_view_animations.cc",
-    "wm/desks/desk_mini_view_animations.h",
-    "wm/desks/desks_bar_view.cc",
-    "wm/desks/desks_bar_view.h",
-    "wm/desks/desks_controller.cc",
-    "wm/desks/desks_controller.h",
-    "wm/desks/new_desk_button.cc",
-    "wm/desks/new_desk_button.h",
     "wm/drag_details.cc",
     "wm/drag_details.h",
     "wm/drag_window_controller.cc",
@@ -1070,6 +1089,8 @@
     "wm/gestures/overview_gesture_handler.h",
     "wm/immersive_context_ash.cc",
     "wm/immersive_context_ash.h",
+    "wm/immersive_gesture_drag_handler.cc",
+    "wm/immersive_gesture_drag_handler.h",
     "wm/lock_action_handler_layout_manager.cc",
     "wm/lock_action_handler_layout_manager.h",
     "wm/lock_layout_manager.cc",
@@ -1102,7 +1123,6 @@
     "wm/overview/overview_grid.h",
     "wm/overview/overview_item.cc",
     "wm/overview/overview_item.h",
-    "wm/overview/overview_observer.h",
     "wm/overview/overview_session.cc",
     "wm/overview/overview_session.h",
     "wm/overview/overview_utils.cc",
@@ -1168,16 +1188,18 @@
     "wm/tablet_mode/internal_input_devices_event_blocker.h",
     "wm/tablet_mode/scoped_skip_user_session_blocked_check.cc",
     "wm/tablet_mode/scoped_skip_user_session_blocked_check.h",
+    "wm/tablet_mode/tablet_mode_app_window_drag_controller.cc",
     "wm/tablet_mode/tablet_mode_backdrop_delegate_impl.cc",
     "wm/tablet_mode/tablet_mode_backdrop_delegate_impl.h",
+    "wm/tablet_mode/tablet_mode_browser_window_drag_controller.cc",
+    "wm/tablet_mode/tablet_mode_browser_window_drag_controller.h",
     "wm/tablet_mode/tablet_mode_browser_window_drag_delegate.cc",
+    "wm/tablet_mode/tablet_mode_browser_window_drag_delegate.h",
     "wm/tablet_mode/tablet_mode_controller.cc",
     "wm/tablet_mode/tablet_mode_event_handler.cc",
     "wm/tablet_mode/tablet_mode_event_handler.h",
-    "wm/tablet_mode/tablet_mode_window_drag_controller.cc",
     "wm/tablet_mode/tablet_mode_window_drag_delegate.cc",
-    "wm/tablet_mode/tablet_mode_window_drag_metrics.cc",
-    "wm/tablet_mode/tablet_mode_window_drag_metrics.h",
+    "wm/tablet_mode/tablet_mode_window_drag_delegate.h",
     "wm/tablet_mode/tablet_mode_window_manager.cc",
     "wm/tablet_mode/tablet_mode_window_manager.h",
     "wm/tablet_mode/tablet_mode_window_state.cc",
@@ -1298,11 +1320,11 @@
     "//ash/app_list/presenter",
     "//ash/app_menu",
     "//ash/assistant/model",
-    "//ash/assistant/ui",
     "//ash/assistant/ui:constants",
     "//ash/assistant/util",
     "//ash/components/cursor",
     "//ash/components/fast_ink",
+    "//ash/components/quick_launch/public/mojom",
     "//ash/components/shortcut_viewer/public/mojom",
     "//ash/components/tap_visualizer/public/mojom",
     "//ash/keyboard/arc",
@@ -1323,7 +1345,6 @@
     "//chromeos/dbus",
     "//chromeos/dbus:power_manager_proto",
     "//chromeos/dbus/services:services",
-    "//chromeos/dbus/system_clock",
 
     # TODO(stevenjb): Remove this dependency, https://crbug.com/644355.
     "//chromeos/network",
@@ -1417,15 +1438,27 @@
     "//components/exo",
     "//components/exo/wayland",
   ]
+
+  if (enable_cros_libassistant) {
+    sources += [
+      "assistant/ui/logo_view/logo_view.cc",
+      "assistant/ui/logo_view/logo_view.h",
+      "assistant/ui/logo_view/shape/mic_part_shape.cc",
+      "assistant/ui/logo_view/shape/mic_part_shape.h",
+      "assistant/ui/logo_view/shape/shape.cc",
+      "assistant/ui/logo_view/shape/shape.h",
+    ]
+
+    deps += [ "//chromeos/assistant/internal/logo_view" ]
+  }
 }
 
 static_library("ash_shell_lib") {
   testonly = true
   sources = [
     "../ui/views/test/test_views_delegate_aura.cc",
+    "shell/app_list.cc",
     "shell/bubble.cc",
-    "shell/example_app_list_client.cc",
-    "shell/example_app_list_client.h",
     "shell/example_factory.h",
     "shell/example_session_controller_client.cc",
     "shell/example_session_controller_client.h",
@@ -1481,22 +1514,22 @@
     "shell/content/client/shell_content_browser_client.h",
     "shell/content/client/shell_main_delegate.cc",
     "shell/content/client/shell_main_delegate.h",
-    "shell/content/embedded_browser.cc",
-    "shell/content/embedded_browser.h",
   ]
 
   deps = [
     ":ash_shell_lib",
+    ":manifest",
     ":test_support",
+    "//ash/components/quick_launch:lib",
+    "//ash/components/quick_launch:manifest",
+    "//ash/components/quick_launch/public/mojom",
     "//ash/components/shortcut_viewer:lib",
-    "//ash/components/shortcut_viewer/public/cpp:manifest",
+    "//ash/components/shortcut_viewer:manifest",
     "//ash/components/shortcut_viewer/public/mojom",
     "//ash/components/tap_visualizer:lib",
-    "//ash/components/tap_visualizer/public/cpp:manifest",
+    "//ash/components/tap_visualizer:manifest",
     "//ash/components/tap_visualizer/public/mojom",
     "//ash/public/cpp",
-    "//ash/public/cpp:manifest",
-    "//ash/public/cpp:manifest_for_tests",
     "//base:i18n",
     "//chrome:packed_resources",
     "//chromeos",
@@ -1514,9 +1547,8 @@
     "//services/device/public/mojom",
     "//services/ws:lib",
     "//services/ws/ime/test_ime_driver:lib",
-    "//services/ws/ime/test_ime_driver/public/cpp:manifest",
+    "//services/ws/ime/test_ime_driver:manifest",
     "//services/ws/ime/test_ime_driver/public/mojom",
-    "//services/ws/remote_view_host",
     "//skia",
     "//ui/aura",
     "//ui/base",
@@ -1527,7 +1559,6 @@
     "//ui/message_center",
     "//ui/views:test_support",
     "//ui/views/examples:views_examples_with_content_lib",
-    "//ui/views/mus/remote_view:remote_view_provider",
     "//ui/wm",
   ]
 }
@@ -1561,9 +1592,9 @@
     "accessibility/touch_accessibility_enabler_unittest.cc",
     "accessibility/touch_exploration_controller_unittest.cc",
     "accessibility/touch_exploration_manager_unittest.cc",
-    "app_list/app_list_controller_impl_unittest.cc",
+    "app_launch_unittest.cc",
     "app_list/app_list_presenter_delegate_unittest.cc",
-    "app_list/app_list_unittest.cc",
+    "app_list/home_launcher_gesture_handler_unittest.cc",
     "app_list/model/app_list_item_list_unittest.cc",
     "app_list/model/app_list_model_unittest.cc",
     "app_list/presenter/app_list_presenter_impl_unittest.cc",
@@ -1578,6 +1609,8 @@
     "assistant/util/deep_link_util_unittest.cc",
     "autoclick/autoclick_drag_event_rewriter_unittest.cc",
     "autoclick/autoclick_unittest.cc",
+    "contained_shell/mock_contained_shell_client.cc",
+    "contained_shell/mock_contained_shell_client.h",
     "cursor_unittest.cc",
     "detachable_base/detachable_base_handler_unittest.cc",
     "detachable_base/detachable_base_notification_controller_unittest.cc",
@@ -1606,7 +1639,6 @@
     "display/window_tree_host_manager_unittest.cc",
     "drag_drop/drag_drop_controller_unittest.cc",
     "drag_drop/drag_drop_tracker_unittest.cc",
-    "drag_drop/drag_drop_unittest.cc",
     "drag_drop/drag_image_view_unittest.cc",
     "events/keyboard_driven_event_rewriter_unittest.cc",
     "events/select_to_speak_event_handler_unittest.cc",
@@ -1621,15 +1653,12 @@
     "frame/non_client_frame_view_ash_unittest.cc",
     "highlighter/highlighter_controller_unittest.cc",
     "highlighter/highlighter_gesture_util_unittest.cc",
-    "home_screen/home_launcher_gesture_handler_unittest.cc",
     "ime/ime_controller_unittest.cc",
     "ime/ime_focus_handler_unittest.cc",
     "keyboard/arc/arc_input_method_surface_manager_unittest.cc",
     "keyboard/ash_keyboard_controller_unittest.cc",
     "keyboard/virtual_keyboard_controller_unittest.cc",
     "keyboard/virtual_keyboard_unittest.cc",
-    "kiosk_next/mock_kiosk_next_shell_client.cc",
-    "kiosk_next/mock_kiosk_next_shell_client.h",
     "laser/laser_pointer_controller_unittest.cc",
     "laser/laser_segment_utils_unittest.cc",
     "lock_screen_action/lock_screen_action_background_controller_impl_unittest.cc",
@@ -1659,7 +1688,6 @@
     "login/ui/login_user_menu_view_unittest.cc",
     "login/ui/login_user_view_unittest.cc",
     "login/ui/note_action_launch_button_unittest.cc",
-    "login/ui/parent_access_view_unittest.cc",
     "magnifier/docked_magnifier_controller_unittest.cc",
     "magnifier/magnification_controller_unittest.cc",
     "magnifier/magnifier_test_utils.cc",
@@ -1670,10 +1698,8 @@
     "media/media_notification_view_unittest.cc",
     "metrics/demo_session_metrics_recorder_unittest.cc",
     "metrics/desktop_task_switch_metric_recorder_unittest.cc",
-    "metrics/histogram_macros_unittest.cc",
     "metrics/login_metrics_recorder_unittest.cc",
     "metrics/pointer_metrics_recorder_unittest.cc",
-    "metrics/presentation_time_recorder_unittest.cc",
     "metrics/task_switch_metrics_recorder_unittest.cc",
     "metrics/task_switch_time_tracker_unittest.cc",
     "metrics/user_metrics_recorder_unittest.cc",
@@ -1727,7 +1753,6 @@
     "system/message_center/session_state_notification_blocker_unittest.cc",
     "system/message_center/unified_message_center_view_unittest.cc",
     "system/message_center/unified_message_list_view_unittest.cc",
-    "system/network/active_network_icon_unittest.cc",
     "system/network/auto_connect_notifier_unittest.cc",
     "system/network/network_icon_unittest.cc",
     "system/network/sms_observer_unittest.cc",
@@ -1745,7 +1770,6 @@
     "system/palette/tools/metalayer_unittest.cc",
     "system/palette/tools/screenshot_unittest.cc",
     "system/power/backlights_forced_off_setter_unittest.cc",
-    "system/power/notification_reporter_unittest.cc",
     "system/power/peripheral_battery_notifier_unittest.cc",
     "system/power/power_button_controller_unittest.cc",
     "system/power/power_button_screenshot_controller_unittest.cc",
@@ -1798,11 +1822,11 @@
     "wm/client_controlled_state_unittest.cc",
     "wm/container_finder_unittest.cc",
     "wm/default_window_resizer_unittest.cc",
-    "wm/desks/desks_unittests.cc",
     "wm/drag_window_resizer_unittest.cc",
     "wm/fullscreen_window_finder_unittest.cc",
     "wm/gestures/overview_gesture_handler_unittest.cc",
     "wm/immersive_fullscreen_controller_unittest.cc",
+    "wm/immersive_gesture_drag_handler_unittest.cc",
     "wm/lock_action_handler_layout_manager_unittest.cc",
     "wm/lock_layout_manager_unittest.cc",
     "wm/lock_state_controller_unittest.cc",
@@ -1847,7 +1871,6 @@
     "wm/window_preview_view_unittest.cc",
     "wm/window_state_unittest.cc",
     "wm/window_util_unittest.cc",
-    "wm/wm_toplevel_window_event_handler_unittest.cc",
     "wm/workspace/magnetism_matcher_unittest.cc",
     "wm/workspace/multi_window_resize_controller_unittest.cc",
     "wm/workspace/workspace_event_handler_unittest.cc",
@@ -1867,21 +1890,20 @@
   deps = [
     ":ash",
     ":ash_service_resources",
+    ":ash_unittests_catalog_source",
     ":test_support",
     "//ash/app_list:test_support",
     "//ash/app_list/presenter",
     "//ash/app_menu",
     "//ash/assistant/model",
-    "//ash/assistant/ui",
     "//ash/assistant/util",
     "//ash/components/fast_ink",
     "//ash/components/fast_ink:unit_tests",
+    "//ash/components/quick_launch/public/mojom:constants",
     "//ash/components/shortcut_viewer:unit_tests",
     "//ash/components/tap_visualizer:unit_tests",
     "//ash/keyboard/arc",
     "//ash/public/cpp",
-    "//ash/public/cpp:manifest",
-    "//ash/public/cpp:manifest_for_tests",
     "//ash/public/cpp:test_support",
     "//ash/public/cpp:unit_tests",
     "//ash/public/cpp/vector_icons",
@@ -1919,6 +1941,7 @@
     "//extensions/common:common_constants",
     "//mojo/core/embedder",
     "//net:net",
+    "//services/catalog:lib",
     "//services/media_session/public/cpp/test:test_support",
     "//services/media_session/public/mojom",
     "//services/ws:test_support",
@@ -1974,6 +1997,7 @@
     ":ash_service_resources",
     ":ash_service",
     "//ash/resources:ash_test_resources_100_percent",
+    "//ash/components/quick_launch:quick_launch_app",
   ]
 
   data = [
@@ -2171,7 +2195,6 @@
     # TODO(stevenjb): Investigate whether this is OK. https://crbug.com/644336.
     "//chromeos/audio",
     "//chromeos/dbus:test_support",
-    "//chromeos/dbus/system_clock",
 
     # TODO(stevenjb): Remove this dependency, https://crbug.com/644355.
     "//chromeos/network:test_support",
@@ -2218,6 +2241,30 @@
   ]
 }
 
+static_library("interactive_ui_test_support") {
+  testonly = true
+  configs += [ "//build/config:precompiled_headers" ]
+  public_deps = [
+    ":test_support",
+    "//ash",
+  ]
+  sources = [
+    "test/ash_interactive_ui_test_base.cc",
+    "test/ash_interactive_ui_test_base.h",
+  ]
+  deps = [
+    ":test_support",
+    "//base",
+    "//mojo/core/embedder",
+    "//skia",
+    "//testing/gtest",
+    "//ui/aura",
+    "//ui/base",
+    "//ui/base:test_support",
+    "//ui/gl:test_support",
+  ]
+}
+
 service_executable("ash_service") {
   output_name = "ash"
 
@@ -2238,6 +2285,12 @@
   ]
 }
 
+service_manifest("manifest") {
+  name = "ash"
+  source = "manifest.json"
+  packaged_services = [ "//services/ws:manifest" ]
+}
+
 # TODO: Load locale-specific strings.
 # TODO: Avoid duplication between Mash and Chrome pak files: crbug.com/628715.
 repack("ash_service_resources") {
@@ -2281,3 +2334,25 @@
     "//ui/views/resources",
   ]
 }
+
+service_manifest("ash_unittests_manifest") {
+  name = "ash_unittests"
+  source = "ash_unittests_manifest.json"
+}
+
+catalog("ash_unittests_catalog") {
+  testonly = true
+
+  embedded_services = [ ":ash_unittests_manifest" ]
+
+  standalone_services = [
+    ":manifest",
+    "//ash/components/quick_launch:manifest",
+  ]
+}
+
+catalog_cpp_source("ash_unittests_catalog_source") {
+  testonly = true
+  catalog = ":ash_unittests_catalog"
+  generated_function_name = "ash::CreateUnittestsCatalog"
+}
--- a/ash/components/cursor/cursor_view.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/components/cursor/cursor_view.cc	2019-05-17 18:53:08.112000000 +0300
@@ -4,7 +4,6 @@
 
 #include "ash/components/cursor/cursor_view.h"
 
-#include "base/bind.h"
 #include "base/task/post_task.h"
 #include "base/threading/thread_task_runner_handle.h"
 #include "cc/paint/paint_canvas.h"
--- a/ash/components/fast_ink/fast_ink_view.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/components/fast_ink/fast_ink_view.cc	2019-05-17 18:53:08.116000000 +0300
@@ -10,7 +10,6 @@
 
 #include <memory>
 
-#include "base/bind.h"
 #include "base/threading/thread_task_runner_handle.h"
 #include "cc/base/math_util.h"
 #include "cc/trees/layer_tree_frame_sink.h"
--- a/ash/components/shortcut_viewer/BUILD.gn	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/components/shortcut_viewer/BUILD.gn	2019-05-17 18:53:08.116000000 +0300
@@ -2,6 +2,8 @@
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
+import("//services/service_manager/public/service_manifest.gni")
+
 # KSV: Keyboard Shortcut Viewer
 source_set("lib") {
   sources = [
@@ -49,6 +51,11 @@
   ]
 }
 
+service_manifest("manifest") {
+  name = "shortcut_viewer_app"
+  source = "manifest.json"
+}
+
 source_set("unit_tests") {
   testonly = true
   sources = [
@@ -60,7 +67,6 @@
     "//base/test:test_support",
     "//services/ws/public/cpp/input_devices:test_support",
     "//testing/gtest",
-    "//ui/compositor:test_support",
     "//ui/events:test_support",
     "//ui/views",
   ]
--- a/ash/components/shortcut_viewer/DEPS	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/components/shortcut_viewer/DEPS	2019-05-17 18:53:08.116000000 +0300
@@ -2,7 +2,6 @@
   # KSV is intended to be a small app with restrictive DEPS in order to make it
   # easy to be migrated to a completely independent mojo app under mustash.
   "+ash/components/strings",
-  "+services/ws/public",
   "+ui/accessibility",
   "+ui/chromeos/events",
   "+ui/chromeos/search_box",
@@ -12,6 +11,6 @@
   "keyboard_shortcut_view_unittest\.cc": [
     "+ash/shell.h",
     "+ash/test/ash_test_base.h",
-    "+ui/compositor",
+    "+services/ws/public/cpp/input_devices",
   ],
 }
--- a/ash/components/shortcut_viewer/keyboard_shortcut_viewer_metadata.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/components/shortcut_viewer/keyboard_shortcut_viewer_metadata.cc	2019-05-17 18:53:08.116000000 +0300
@@ -1183,13 +1183,6 @@
        {{ui::VKEY_LWIN}}},
 
       {// |categories|
-       {ShortcutCategory::kSystemAndDisplay},
-       IDS_KSV_DESCRIPTION_TOGGLE_APP_LIST_FULLSCREEN,
-       IDS_KSV_SHORTCUT_ONE_MODIFIER_ONE_KEY,
-       // |accelerator_ids|
-       {{ui::VKEY_LWIN, ui::EF_SHIFT_DOWN}}},
-
-      {// |categories|
        {ShortcutCategory::kTabAndWindow},
        IDS_KSV_DESCRIPTION_TAKE_WINDOW_SCREENSHOT,
        IDS_KSV_SHORTCUT_TWO_MODIFIERS_ONE_KEY,
--- a/ash/components/shortcut_viewer/ksv_export.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/components/shortcut_viewer/ksv_export.h	2019-05-17 18:53:08.116000000 +0300
@@ -9,12 +9,21 @@
 // the keyboard shortcut viewer module can be exported to consumers.
 
 #if defined(COMPONENT_BUILD)
+#if defined(WIN32)
 
 #if defined(KSV_IMPLEMENTATION)
+#define KSV_EXPORT __declspec(dllexport)
+#else
+#define KSV_EXPORT __declspec(dllimport)
+#endif  // defined(KSV_IMPLEMENTATION)
+
+#else  // defined(WIN32)
+#if defined(KSV_IMPLEMENTATION)
 #define KSV_EXPORT __attribute__((visibility("default")))
 #else
 #define KSV_EXPORT
 #endif
+#endif
 
 #else  // defined(COMPONENT_BUILD)
 #define KSV_EXPORT
--- a/ash/components/shortcut_viewer/OWNERS	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/components/shortcut_viewer/OWNERS	2019-05-17 18:53:08.116000000 +0300
@@ -1,2 +1,5 @@
 afakhry@chromium.org
 wutao@chromium.org
+
+per-file manifest.json=set noparent
+per-file manifest.json=file://ipc/SECURITY_OWNERS
--- a/ash/components/shortcut_viewer/public/mojom/shortcut_viewer.mojom	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/components/shortcut_viewer/public/mojom/shortcut_viewer.mojom	2019-05-17 18:53:08.116000000 +0300
@@ -8,10 +8,6 @@
 
 const string kServiceName = "shortcut_viewer_app";
 
-// Grants a client the ability to toggle the Keyboard Shortcut Viewer window
-// through the ShortcutViewer interface defined below.
-const string kToggleUiCapability = "toggle_ui";
-
 // Used to toggle the Keyboard Shortcut Viewer window.
 interface ShortcutViewer {
   // |user_gesture_time| is the time of the user gesture that caused the window
--- a/ash/components/shortcut_viewer/shortcut_viewer_application.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/components/shortcut_viewer/shortcut_viewer_application.cc	2019-05-17 18:53:08.116000000 +0300
@@ -7,7 +7,6 @@
 #include "ash/components/shortcut_viewer/last_window_closed_observer.h"
 #include "ash/components/shortcut_viewer/views/keyboard_shortcut_view.h"
 #include "ash/public/cpp/ash_client.h"
-#include "base/bind.h"
 #include "base/time/time.h"
 #include "base/trace_event/trace_event.h"
 #include "services/service_manager/public/cpp/connector.h"
--- a/ash/components/shortcut_viewer/views/keyboard_shortcut_view_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/components/shortcut_viewer/views/keyboard_shortcut_view_unittest.cc	2019-05-17 18:53:08.120000000 +0300
@@ -10,12 +10,10 @@
 #include "ash/components/shortcut_viewer/views/keyboard_shortcut_item_view.h"
 #include "ash/components/shortcut_viewer/views/ksv_search_box_view.h"
 #include "ash/test/ash_test_base.h"
-#include "base/bind.h"
 #include "base/test/metrics/histogram_tester.h"
 #include "services/ws/public/cpp/input_devices/input_device_client_test_api.h"
 #include "testing/gtest/include/gtest/gtest.h"
 #include "ui/aura/window.h"
-#include "ui/compositor/test/test_utils.h"
 #include "ui/display/display.h"
 #include "ui/display/screen.h"
 #include "ui/events/test/event_generator.h"
@@ -93,7 +91,12 @@
 
 TEST_F(KeyboardShortcutViewTest, StartupTimeHistogram) {
   views::Widget* widget = Toggle();
-  ui::WaitForNextFrameToBePresented(widget->GetCompositor());
+  base::RunLoop runloop;
+  widget->GetCompositor()->RequestPresentationTimeForNextFrame(base::BindOnce(
+      [](base::RepeatingClosure closure,
+         const gfx::PresentationFeedback& feedback) { closure.Run(); },
+      runloop.QuitClosure()));
+  runloop.Run();
   histograms_.ExpectTotalCount("Keyboard.ShortcutViewer.StartupTime", 1);
   widget->CloseNow();
 }
--- a/ash/components/shortcut_viewer/views/ksv_search_box_view.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/components/shortcut_viewer/views/ksv_search_box_view.cc	2019-05-17 18:53:08.120000000 +0300
@@ -32,7 +32,7 @@
 KSVSearchBoxView::KSVSearchBoxView(search_box::SearchBoxViewDelegate* delegate)
     : search_box::SearchBoxViewBase(delegate) {
   SetSearchBoxBackgroundCornerRadius(kBorderCornerRadius);
-  UpdateBackgroundColor(kDefaultSearchBoxBackgroundColor);
+  SetSearchBoxBackgroundColor(kDefaultSearchBoxBackgroundColor);
   search_box()->SetBackgroundColor(SK_ColorTRANSPARENT);
   search_box()->SetColor(gfx::kGoogleGrey900);
   search_box()->set_placeholder_text_color(gfx::kGoogleGrey900);
@@ -83,7 +83,7 @@
 }
 
 void KSVSearchBoxView::UpdateBackgroundColor(SkColor color) {
-  GetSearchBoxBackground()->SetNativeControlColor(color);
+  SetSearchBoxBackgroundColor(color);
 }
 
 void KSVSearchBoxView::UpdateSearchBoxBorder() {
@@ -98,12 +98,12 @@
   if (search_box()->HasFocus() || is_search_box_active()) {
     SetBorder(views::CreateRoundedRectBorder(
         kBorderThichness, kBorderCornerRadius, kActiveBorderColor));
-    UpdateBackgroundColor(gfx::kGoogleGrey100);
+    SetSearchBoxBackgroundColor(gfx::kGoogleGrey100);
     return;
   }
   SetBorder(views::CreateRoundedRectBorder(
       kBorderThichness, kBorderCornerRadius, SK_ColorTRANSPARENT));
-  UpdateBackgroundColor(kDefaultSearchBoxBackgroundColor);
+  SetSearchBoxBackgroundColor(kDefaultSearchBoxBackgroundColor);
 }
 
 void KSVSearchBoxView::SetupCloseButton() {
--- a/ash/components/tap_visualizer/BUILD.gn	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/components/tap_visualizer/BUILD.gn	2019-05-17 18:53:08.136000000 +0300
@@ -2,6 +2,8 @@
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
+import("//services/service_manager/public/service_manifest.gni")
+
 source_set("lib") {
   sources = [
     "tap_renderer.cc",
@@ -29,6 +31,11 @@
   ]
 }
 
+service_manifest("manifest") {
+  name = "tap_visualizer_app"
+  source = "manifest.json"
+}
+
 source_set("unit_tests") {
   testonly = true
   sources = [
--- a/ash/components/tap_visualizer/public/mojom/tap_visualizer.mojom	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/components/tap_visualizer/public/mojom/tap_visualizer.mojom	2019-05-17 18:53:08.136000000 +0300
@@ -6,10 +6,6 @@
 
 const string kServiceName = "tap_visualizer_app";
 
-// Grants a client the ability to show this service's UI through the
-// TapVisualizer interface defined below.
-const string kShowUiCapability = "show_ui";
-
 interface TapVisualizer {
   // Show the UI.
   Show();
--- a/ash/components/tap_visualizer/tap_visualizer_app.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/components/tap_visualizer/tap_visualizer_app.cc	2019-05-17 18:53:08.136000000 +0300
@@ -8,7 +8,6 @@
 
 #include "ash/components/tap_visualizer/tap_renderer.h"
 #include "ash/public/cpp/shell_window_ids.h"
-#include "base/bind.h"
 #include "base/macros.h"
 #include "base/strings/utf_string_conversions.h"
 #include "services/ws/public/cpp/property_type_converters.h"
--- a/ash/dbus/ash_dbus_services.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/dbus/ash_dbus_services.cc	2019-05-17 18:53:08.136000000 +0300
@@ -17,8 +17,14 @@
 namespace ash {
 
 AshDBusServices::AshDBusServices() {
-  // DBusThreadManager is initialized in Chrome or in AshService::InitForMash().
-  CHECK(chromeos::DBusThreadManager::IsInitialized());
+  // TODO(stevenjb): Figure out where else the D-Bus thread is getting
+  // initialized and then always init it here when we have the MASH
+  // config after the contention is sorted out.
+  if (!chromeos::DBusThreadManager::IsInitialized()) {
+    chromeos::DBusThreadManager::Initialize(
+        chromeos::DBusThreadManager::kShared);
+    initialized_dbus_thread_ = true;
+  }
 
   dbus::Bus* system_bus =
       chromeos::DBusThreadManager::Get()->IsUsingFakes()
@@ -51,6 +57,9 @@
   display_service_.reset();
   liveness_service_.reset();
   url_handler_service_.reset();
+  if (initialized_dbus_thread_) {
+    chromeos::DBusThreadManager::Shutdown();
+  }
 }
 
 }  // namespace ash
--- a/ash/dbus/ash_dbus_services.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/dbus/ash_dbus_services.h	2019-05-17 18:53:08.136000000 +0300
@@ -27,6 +27,7 @@
   void EmitAshInitialized();
 
  private:
+  bool initialized_dbus_thread_{false};
   std::unique_ptr<chromeos::CrosDBusService> display_service_;
   std::unique_ptr<chromeos::CrosDBusService> liveness_service_;
   std::unique_ptr<chromeos::CrosDBusService> url_handler_service_;
--- a/ash/DEPS	2019-05-01 01:22:25.000000000 +0300
+++ b/ash/DEPS	2019-05-17 18:53:08.060000000 +0300
@@ -25,6 +25,7 @@
   "+gpu/config",
   "+media",
   "+mojo/public",
+  "+services/catalog/public",
   "+services/content/public",
   "+services/media_session/public",
   "+services/preferences/public",
@@ -47,7 +48,7 @@
   "-ash/components",
 
   # Ash can talk to public interfaces for mini-apps.
-  "+ash/components/shortcut_viewer/public",
+  "+ash/components/quick_launch/public",
   "+ash/components/tap_visualizer/public",
 
   # Ash sits above content. Exceptions live in //ash/content.
@@ -62,13 +63,12 @@
   "+chromeos/dbus/dbus_thread_manager.h",
   "+chromeos/dbus/fake_power_manager_client.h",
   "+chromeos/dbus/fake_session_manager_client.h",
-  "+chromeos/dbus/hammerd",
   "+chromeos/dbus/power_manager",
   "+chromeos/dbus/power_manager_client.h",
   "+chromeos/dbus/power_policy_controller.h",
   "+chromeos/dbus/session_manager_client.h",
   "+chromeos/dbus/shill_device_client.h",
-  "+chromeos/dbus/system_clock",
+  "+chromeos/dbus/system_clock_client.h",
   # TODO(jamescook): Eliminate this. http://crbug.com/644355
   "+chromeos/network",
   "+chromeos/services/assistant/public" ,
@@ -102,6 +102,9 @@
 ]
 
 specific_include_rules = {
+  "app_launch_unittest.cc": [
+    "+ash/components/quick_launch/public",
+  ],
   "ash_service\.*": [
     "+chromeos/cryptohome",
   ],
--- a/ash/detachable_base/detachable_base_handler.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/detachable_base/detachable_base_handler.cc	2019-05-17 18:53:08.140000000 +0300
@@ -55,10 +55,9 @@
   if (shell_)
     shell_->AddShellObserver(this);
 
-  if (chromeos::HammerdClient::Get())  // May be null in tests
-    hammerd_observer_.Add(chromeos::HammerdClient::Get());
+  hammerd_observer_.Add(chromeos::DBusThreadManager::Get()->GetHammerdClient());
   chromeos::PowerManagerClient* power_manager_client =
-      chromeos::PowerManagerClient::Get();
+      chromeos::DBusThreadManager::Get()->GetPowerManagerClient();
   power_manager_observer_.Add(power_manager_client);
 
   power_manager_client->GetSwitchStates(
--- a/ash/detachable_base/detachable_base_handler.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/detachable_base/detachable_base_handler.h	2019-05-17 18:53:08.140000000 +0300
@@ -18,7 +18,7 @@
 #include "base/observer_list.h"
 #include "base/optional.h"
 #include "base/scoped_observer.h"
-#include "chromeos/dbus/hammerd/hammerd_client.h"
+#include "chromeos/dbus/hammerd_client.h"
 #include "chromeos/dbus/power_manager_client.h"
 
 class PrefRegistrySimple;
--- a/ash/detachable_base/detachable_base_handler_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/detachable_base/detachable_base_handler_unittest.cc	2019-05-17 18:53:08.140000000 +0300
@@ -14,8 +14,9 @@
 #include "base/run_loop.h"
 #include "base/test/scoped_task_environment.h"
 #include "base/time/time.h"
+#include "chromeos/dbus/dbus_thread_manager.h"
+#include "chromeos/dbus/fake_hammerd_client.h"
 #include "chromeos/dbus/fake_power_manager_client.h"
-#include "chromeos/dbus/hammerd/fake_hammerd_client.h"
 #include "components/account_id/account_id.h"
 #include "components/prefs/testing_pref_service.h"
 #include "testing/gtest/include/gtest/gtest.h"
@@ -85,12 +86,19 @@
 
   // testing::Test:
   void SetUp() override {
-    chromeos::HammerdClient::Initialize(nullptr /* bus */);
-    hammerd_client_ = chromeos::FakeHammerdClient::Get();
+    std::unique_ptr<chromeos::DBusThreadManagerSetter> dbus_setter =
+        chromeos::DBusThreadManager::GetSetterForTesting();
 
-    chromeos::PowerManagerClient::Initialize();
-    chromeos::FakePowerManagerClient::Get()->SetTabletMode(
+    auto hammerd_client = std::make_unique<chromeos::FakeHammerdClient>();
+    hammerd_client_ = hammerd_client.get();
+    dbus_setter->SetHammerdClient(std::move(hammerd_client));
+
+    auto power_manager_client =
+        std::make_unique<chromeos::FakePowerManagerClient>();
+    power_manager_client->SetTabletMode(
         chromeos::PowerManagerClient::TabletMode::OFF, base::TimeTicks());
+    power_manager_client_ = power_manager_client.get();
+    dbus_setter->SetPowerManagerClient(std::move(power_manager_client));
 
     default_user_ = CreateUser("user_1@foo.bar", "111111", UserType::kNormal);
 
@@ -99,21 +107,20 @@
     handler_->OnLocalStatePrefServiceInitialized(&local_state_);
     handler_->AddObserver(&detachable_base_observer_);
   }
-
   void TearDown() override {
     handler_->RemoveObserver(&detachable_base_observer_);
     handler_.reset();
     hammerd_client_ = nullptr;
-    chromeos::PowerManagerClient::Shutdown();
-    chromeos::HammerdClient::Shutdown();
+    power_manager_client_ = nullptr;
+    chromeos::DBusThreadManager::Shutdown();
   }
 
  protected:
   // Simulates system events associated with the detachable base being switched.
   void ChangePairedBase(const std::vector<uint8_t>& base_id) {
-    chromeos::FakePowerManagerClient::Get()->SetTabletMode(
+    power_manager_client_->SetTabletMode(
         chromeos::PowerManagerClient::TabletMode::ON, base::TimeTicks());
-    chromeos::FakePowerManagerClient::Get()->SetTabletMode(
+    power_manager_client_->SetTabletMode(
         chromeos::PowerManagerClient::TabletMode::OFF, base::TimeTicks());
     detachable_base_observer_.reset_pairing_status_changed_count();
 
@@ -137,7 +144,9 @@
     handler_->OnLocalStatePrefServiceInitialized(&local_state_);
   }
 
+  // Owned by DBusThreadManager:
   chromeos::FakeHammerdClient* hammerd_client_ = nullptr;
+  chromeos::FakePowerManagerClient* power_manager_client_ = nullptr;
 
   TestBaseObserver detachable_base_observer_;
 
@@ -163,11 +172,11 @@
 }
 
 TEST_F(DetachableBaseHandlerTest, TabletModeOnOnStartup) {
-  chromeos::FakePowerManagerClient::Get()->SetTabletMode(
+  power_manager_client_->SetTabletMode(
       chromeos::PowerManagerClient::TabletMode::ON, base::TimeTicks());
   RestartHandler();
 
-  chromeos::FakePowerManagerClient::Get()->SetTabletMode(
+  power_manager_client_->SetTabletMode(
       chromeos::PowerManagerClient::TabletMode::OFF, base::TimeTicks());
   hammerd_client_->FirePairChallengeSucceededSignal({0x01, 0x02, 0x03, 0x04});
 
@@ -197,7 +206,7 @@
   detachable_base_observer_.reset_pairing_status_changed_count();
 
   // Assume the base has been detached when the device switches to tablet mode.
-  chromeos::FakePowerManagerClient::Get()->SetTabletMode(
+  power_manager_client_->SetTabletMode(
       chromeos::PowerManagerClient::TabletMode::ON, base::TimeTicks());
   EXPECT_EQ(1, detachable_base_observer_.pairing_status_changed_count());
   EXPECT_EQ(DetachableBasePairingStatus::kNone, handler_->GetPairingStatus());
@@ -206,7 +215,7 @@
 
   // When the device exits tablet mode again, the base should not be reported
   // as paired until it's finished pairing.
-  chromeos::FakePowerManagerClient::Get()->SetTabletMode(
+  power_manager_client_->SetTabletMode(
       chromeos::PowerManagerClient::TabletMode::OFF, base::TimeTicks());
   EXPECT_EQ(DetachableBasePairingStatus::kNone, handler_->GetPairingStatus());
   EXPECT_FALSE(handler_->PairedBaseMatchesLastUsedByUser(*default_user_));
@@ -233,7 +242,7 @@
   detachable_base_observer_.reset_pairing_status_changed_count();
 
   // Assume the base has been detached when the device switches to tablet mode.
-  chromeos::FakePowerManagerClient::Get()->SetTabletMode(
+  power_manager_client_->SetTabletMode(
       chromeos::PowerManagerClient::TabletMode::ON, base::TimeTicks());
   EXPECT_EQ(1, detachable_base_observer_.pairing_status_changed_count());
   EXPECT_EQ(DetachableBasePairingStatus::kNone, handler_->GetPairingStatus());
@@ -255,7 +264,7 @@
   detachable_base_observer_.reset_pairing_status_changed_count();
 
   // Assume the base has been detached when the device switches to tablet mode.
-  chromeos::FakePowerManagerClient::Get()->SetTabletMode(
+  power_manager_client_->SetTabletMode(
       chromeos::PowerManagerClient::TabletMode::ON, base::TimeTicks());
   EXPECT_EQ(1, detachable_base_observer_.pairing_status_changed_count());
   EXPECT_EQ(DetachableBasePairingStatus::kNone, handler_->GetPairingStatus());
@@ -325,7 +334,7 @@
 
 TEST_F(DetachableBaseHandlerTest, TabletModeTurnedOnDuringHandlerInit) {
   hammerd_client_->FirePairChallengeSucceededSignal({0x01, 0x02, 0x03, 0x04});
-  chromeos::FakePowerManagerClient::Get()->SetTabletMode(
+  power_manager_client_->SetTabletMode(
       chromeos::PowerManagerClient::TabletMode::ON, base::TimeTicks());
 
   // Run loop so the callback for getting the initial power manager state gets
@@ -338,7 +347,7 @@
 }
 
 TEST_F(DetachableBaseHandlerTest, DetachableBaseChangeDetection) {
-  chromeos::FakePowerManagerClient::Get()->SetTabletMode(
+  power_manager_client_->SetTabletMode(
       chromeos::PowerManagerClient::TabletMode::OFF, base::TimeTicks());
   // Run loop so the callback for getting the initial power manager state gets
   // run.
@@ -459,9 +468,9 @@
 
   // Switch to non-trusted base, and verify it's reported as such regardless
   // of whether the user had previously used a detachable base.
-  chromeos::FakePowerManagerClient::Get()->SetTabletMode(
+  power_manager_client_->SetTabletMode(
       chromeos::PowerManagerClient::TabletMode::ON, base::TimeTicks());
-  chromeos::FakePowerManagerClient::Get()->SetTabletMode(
+  power_manager_client_->SetTabletMode(
       chromeos::PowerManagerClient::TabletMode::OFF, base::TimeTicks());
   detachable_base_observer_.reset_pairing_status_changed_count();
 
@@ -488,9 +497,9 @@
 
   // Switch to an invalid base, and verify it's reported as such regardless
   // of whether the user had previously used a base.
-  chromeos::FakePowerManagerClient::Get()->SetTabletMode(
+  power_manager_client_->SetTabletMode(
       chromeos::PowerManagerClient::TabletMode::ON, base::TimeTicks());
-  chromeos::FakePowerManagerClient::Get()->SetTabletMode(
+  power_manager_client_->SetTabletMode(
       chromeos::PowerManagerClient::TabletMode::OFF, base::TimeTicks());
   detachable_base_observer_.reset_pairing_status_changed_count();
 
@@ -642,7 +651,7 @@
   EXPECT_EQ(1, detachable_base_observer_.update_required_changed_count());
   EXPECT_TRUE(detachable_base_observer_.requires_update());
 
-  chromeos::FakePowerManagerClient::Get()->SetTabletMode(
+  power_manager_client_->SetTabletMode(
       chromeos::PowerManagerClient::TabletMode::ON, base::TimeTicks());
   EXPECT_EQ(2, detachable_base_observer_.update_required_changed_count());
   EXPECT_FALSE(detachable_base_observer_.requires_update());
--- a/ash/detachable_base/detachable_base_notification_controller_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/detachable_base/detachable_base_notification_controller_unittest.cc	2019-05-17 18:53:08.140000000 +0300
@@ -14,6 +14,7 @@
 #include "ash/test/ash_test_base.h"
 #include "base/macros.h"
 #include "base/time/time.h"
+#include "chromeos/dbus/dbus_thread_manager.h"
 #include "chromeos/dbus/fake_power_manager_client.h"
 #include "components/account_id/account_id.h"
 #include "components/user_manager/user_type.h"
@@ -40,10 +41,15 @@
   void SetUp() override {
     AshTestBase::SetUp();
 
-    chromeos::FakePowerManagerClient::Get()->SetTabletMode(
+    GetPowerManagerClient()->SetTabletMode(
         chromeos::PowerManagerClient::TabletMode::OFF, base::TimeTicks());
   }
 
+  chromeos::FakePowerManagerClient* GetPowerManagerClient() {
+    return static_cast<chromeos::FakePowerManagerClient*>(
+        chromeos::DBusThreadManager::Get()->GetPowerManagerClient());
+  }
+
   bool IsBaseChangedNotificationVisible() {
     return message_center::MessageCenter::Get()->FindVisibleNotificationById(
         DetachableBaseNotificationController::kBaseChangedNotificationId);
@@ -238,7 +244,7 @@
   EXPECT_TRUE(IsBaseRequiresUpdateNotificationVisible());
 
   // The notification should be removed when the base gets detached.
-  chromeos::FakePowerManagerClient::Get()->SetTabletMode(
+  GetPowerManagerClient()->SetTabletMode(
       chromeos::PowerManagerClient::TabletMode::ON, base::TimeTicks());
   EXPECT_FALSE(IsBaseRequiresUpdateNotificationVisible());
 }
@@ -255,7 +261,7 @@
   EXPECT_TRUE(IsBaseRequiresUpdateNotificationVisible());
 
   // The notification should be removed when the base gets detached.
-  chromeos::FakePowerManagerClient::Get()->SetTabletMode(
+  GetPowerManagerClient()->SetTabletMode(
       chromeos::PowerManagerClient::TabletMode::ON, base::TimeTicks());
   EXPECT_FALSE(IsBaseRequiresUpdateNotificationVisible());
 }
@@ -270,7 +276,7 @@
   EXPECT_TRUE(IsBaseRequiresUpdateNotificationVisible());
 
   // The notification should be removed when the base gets detached.
-  chromeos::FakePowerManagerClient::Get()->SetTabletMode(
+  GetPowerManagerClient()->SetTabletMode(
       chromeos::PowerManagerClient::TabletMode::ON, base::TimeTicks());
   EXPECT_FALSE(IsBaseRequiresUpdateNotificationVisible());
 }
--- a/ash/disconnected_app_handler.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/disconnected_app_handler.cc	2019-05-17 18:53:08.140000000 +0300
@@ -8,14 +8,14 @@
 #include "ui/aura/window.h"
 #include "ui/base/class_property.h"
 
-DEFINE_UI_CLASS_PROPERTY_TYPE(ash::DisconnectedAppHandler*)
+DEFINE_UI_CLASS_PROPERTY_TYPE(ash::DisconnectedAppHandler*);
 
 namespace ash {
 namespace {
 
 DEFINE_OWNED_UI_CLASS_PROPERTY_KEY(DisconnectedAppHandler,
                                    kDisconnectedAppHandlerKey,
-                                   nullptr)
+                                   nullptr);
 
 }  // namespace
 
--- a/ash/display/cros_display_config.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/display/cros_display_config.cc	2019-05-17 18:53:08.140000000 +0300
@@ -14,7 +14,6 @@
 #include "ash/shell.h"
 #include "ash/touch/ash_touch_transform_controller.h"
 #include "ash/wm/tablet_mode/tablet_mode_controller.h"
-#include "base/bind.h"
 #include "base/optional.h"
 #include "base/strings/string_number_conversions.h"
 #include "ui/display/display.h"
@@ -110,8 +109,8 @@
     if (placement.display_id == display::kInvalidDisplayId)
       continue;
     auto layout = mojom::DisplayLayout::New();
-    layout->id = base::NumberToString(placement.display_id);
-    layout->parent_id = base::NumberToString(placement.parent_display_id);
+    layout->id = base::Int64ToString(placement.display_id);
+    layout->parent_id = base::Int64ToString(placement.parent_display_id);
     layout->position = GetMojomDisplayLayoutPosition(placement.position);
     layout->offset = placement.offset;
     layouts.emplace_back(std::move(layout));
@@ -139,8 +138,8 @@
       const int64_t parent_id = column_index == 0
                                     ? matrix[row_index - 1][column_index]
                                     : row[column_index - 1];
-      layout->id = base::NumberToString(display_id);
-      layout->parent_id = base::NumberToString(parent_id);
+      layout->id = base::Int64ToString(display_id);
+      layout->parent_id = base::Int64ToString(parent_id);
       layout->position = column_index == 0
                              ? mojom::DisplayLayoutPosition::kBottom
                              : mojom::DisplayLayoutPosition::kRight;
@@ -229,7 +228,6 @@
   result->device_scale_factor = display_mode.device_scale_factor();
   result->refresh_rate = display_mode.refresh_rate();
   result->is_native = display_mode.native();
-  result->is_interlaced = display_mode.is_interlaced();
   return result;
 }
 
@@ -240,7 +238,7 @@
       display_manager->GetDisplayInfo(display.id());
 
   auto info = mojom::DisplayUnitInfo::New();
-  info->id = base::NumberToString(display.id());
+  info->id = base::Int64ToString(display.id());
   info->name = display_manager->GetDisplayNameForId(display.id());
 
   if (!display_info.manufacturer_id().empty() ||
@@ -417,8 +415,8 @@
     return mojom::DisplayConfigResult::kInvalidDisplayIdError;
 
   display::ManagedDisplayMode new_mode(
-      display_mode.size_in_native_pixels, display_mode.refresh_rate,
-      display_mode.is_interlaced, display_mode.is_native,
+      display_mode.size_in_native_pixels, current_mode.refresh_rate(),
+      current_mode.is_interlaced(), display_mode.is_native,
       display_mode.device_scale_factor);
 
   if (!new_mode.IsEquivalent(current_mode)) {
@@ -501,10 +499,10 @@
   } else if (display_manager->IsInMirrorMode()) {
     info->layout_mode = mojom::DisplayLayoutMode::kMirrored;
     info->mirror_source_id =
-        base::NumberToString(display_manager->mirroring_source_id());
+        base::Int64ToString(display_manager->mirroring_source_id());
     info->mirror_destination_ids = std::vector<std::string>();
     for (int64_t id : display_manager->GetMirroringDestinationDisplayIdList())
-      info->mirror_destination_ids->emplace_back(base::NumberToString(id));
+      info->mirror_destination_ids->emplace_back(base::Int64ToString(id));
   } else {
     info->layout_mode = mojom::DisplayLayoutMode::kNormal;
   }
--- a/ash/display/cros_display_config_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/display/cros_display_config_unittest.cc	2019-05-17 18:53:08.140000000 +0300
@@ -10,7 +10,6 @@
 #include "ash/shell.h"
 #include "ash/test/ash_test_base.h"
 #include "ash/touch/ash_touch_transform_controller.h"
-#include "base/bind.h"
 #include "base/command_line.h"
 #include "base/stl_util.h"
 #include "base/strings/string_number_conversions.h"
@@ -72,7 +71,7 @@
 class CrosDisplayConfigTest : public AshTestBase {
  public:
   CrosDisplayConfigTest() {}
-  ~CrosDisplayConfigTest() override {}
+  ~CrosDisplayConfigTest() override{};
 
   void SetUp() override {
     base::CommandLine::ForCurrentProcess()->AppendSwitch(
@@ -142,7 +141,7 @@
     mojom::DisplayConfigResult result;
     base::RunLoop run_loop;
     cros_display_config()->OverscanCalibration(
-        base::NumberToString(id), op, delta,
+        base::Int64ToString(id), op, delta,
         base::BindOnce(&SetResult, &result, run_loop.QuitClosure()));
     run_loop.Run();
     return result == mojom::DisplayConfigResult::kSuccess;
@@ -234,12 +233,12 @@
       *display_layout_info->layouts;
   ASSERT_EQ(2u, layouts.size());
 
-  EXPECT_EQ(base::NumberToString(displays[1].id()), layouts[0]->id);
-  EXPECT_EQ(base::NumberToString(displays[0].id()), layouts[0]->parent_id);
+  EXPECT_EQ(base::Int64ToString(displays[1].id()), layouts[0]->id);
+  EXPECT_EQ(base::Int64ToString(displays[0].id()), layouts[0]->parent_id);
   EXPECT_EQ(mojom::DisplayLayoutPosition::kRight, layouts[0]->position);
   EXPECT_EQ(0, layouts[0]->offset);
 
-  EXPECT_EQ(base::NumberToString(displays[2].id()), layouts[1]->id);
+  EXPECT_EQ(base::Int64ToString(displays[2].id()), layouts[1]->id);
   EXPECT_EQ(layouts[0]->id, layouts[1]->parent_id);
   EXPECT_EQ(mojom::DisplayLayoutPosition::kRight, layouts[1]->position);
   EXPECT_EQ(0, layouts[1]->offset);
@@ -303,11 +302,11 @@
 
   auto properties = mojom::DisplayLayoutInfo::New();
   properties->layout_mode = mojom::DisplayLayoutMode::kMirrored;
-  properties->mirror_source_id = base::NumberToString(displays[0].id());
+  properties->mirror_source_id = base::Int64ToString(displays[0].id());
   properties->mirror_destination_ids =
       base::make_optional<std::vector<std::string>>(
-          {base::NumberToString(displays[1].id()),
-           base::NumberToString(displays[3].id())});
+          {base::Int64ToString(displays[1].id()),
+           base::Int64ToString(displays[3].id())});
   mojom::DisplayConfigResult result =
       SetDisplayLayoutInfo(std::move(properties));
   EXPECT_EQ(mojom::DisplayConfigResult::kSuccess, result);
@@ -385,7 +384,7 @@
   auto properties = mojom::DisplayConfigProperties::New();
   properties->set_primary = true;
   mojom::DisplayConfigResult result = SetDisplayProperties(
-      base::NumberToString(secondary_id), std::move(properties));
+      base::Int64ToString(secondary_id), std::move(properties));
   EXPECT_EQ(mojom::DisplayConfigResult::kSuccess, result);
 
   // secondary display should now be primary.
@@ -400,7 +399,7 @@
   auto properties = mojom::DisplayConfigProperties::New();
   properties->overscan = gfx::Insets({199, 20, 51, 130});
   mojom::DisplayConfigResult result = SetDisplayProperties(
-      base::NumberToString(secondary.id()), std::move(properties));
+      base::Int64ToString(secondary.id()), std::move(properties));
   EXPECT_EQ(mojom::DisplayConfigResult::kSuccess, result);
   EXPECT_EQ("1200,0 150x250", secondary.bounds().ToString());
   const gfx::Insets overscan =
@@ -420,7 +419,7 @@
   auto properties = mojom::DisplayConfigProperties::New();
   properties->rotation =
       mojom::DisplayRotation::New(display::Display::ROTATE_90);
-  result = SetDisplayProperties(base::NumberToString(secondary.id()),
+  result = SetDisplayProperties(base::Int64ToString(secondary.id()),
                                 std::move(properties));
   EXPECT_EQ(mojom::DisplayConfigResult::kSuccess, result);
   EXPECT_EQ("1200,0 500x300", secondary.bounds().ToString());
@@ -429,7 +428,7 @@
   properties = mojom::DisplayConfigProperties::New();
   properties->rotation =
       mojom::DisplayRotation::New(display::Display::ROTATE_270);
-  result = SetDisplayProperties(base::NumberToString(secondary.id()),
+  result = SetDisplayProperties(base::Int64ToString(secondary.id()),
                                 std::move(properties));
   EXPECT_EQ(mojom::DisplayConfigResult::kSuccess, result);
   EXPECT_EQ("1200,0 500x300", secondary.bounds().ToString());
@@ -440,7 +439,7 @@
   properties->set_primary = true;
   properties->rotation =
       mojom::DisplayRotation::New(display::Display::ROTATE_180);
-  result = SetDisplayProperties(base::NumberToString(secondary.id()),
+  result = SetDisplayProperties(base::Int64ToString(secondary.id()),
                                 std::move(properties));
   EXPECT_EQ(mojom::DisplayConfigResult::kSuccess, result);
   const display::Display& primary =
@@ -458,28 +457,28 @@
 
   auto properties = mojom::DisplayConfigProperties::New();
   properties->bounds_origin = gfx::Point({-520, 50});
-  result = SetDisplayProperties(base::NumberToString(secondary.id()),
+  result = SetDisplayProperties(base::Int64ToString(secondary.id()),
                                 std::move(properties));
   EXPECT_EQ(mojom::DisplayConfigResult::kSuccess, result);
   EXPECT_EQ("-520,50 520x400", secondary.bounds().ToString());
 
   properties = mojom::DisplayConfigProperties::New();
   properties->bounds_origin = gfx::Point({1200, 100});
-  result = SetDisplayProperties(base::NumberToString(secondary.id()),
+  result = SetDisplayProperties(base::Int64ToString(secondary.id()),
                                 std::move(properties));
   EXPECT_EQ(mojom::DisplayConfigResult::kSuccess, result);
   EXPECT_EQ("1200,100 520x400", secondary.bounds().ToString());
 
   properties = mojom::DisplayConfigProperties::New();
   properties->bounds_origin = gfx::Point({1100, -400});
-  result = SetDisplayProperties(base::NumberToString(secondary.id()),
+  result = SetDisplayProperties(base::Int64ToString(secondary.id()),
                                 std::move(properties));
   EXPECT_EQ(mojom::DisplayConfigResult::kSuccess, result);
   EXPECT_EQ("1100,-400 520x400", secondary.bounds().ToString());
 
   properties = mojom::DisplayConfigProperties::New();
   properties->bounds_origin = gfx::Point({-350, 600});
-  result = SetDisplayProperties(base::NumberToString(secondary.id()),
+  result = SetDisplayProperties(base::Int64ToString(secondary.id()),
                                 std::move(properties));
   EXPECT_EQ(mojom::DisplayConfigResult::kSuccess, result);
   EXPECT_EQ("-350,600 520x400", secondary.bounds().ToString());
@@ -507,7 +506,7 @@
   auto properties = mojom::DisplayConfigProperties::New();
   properties->display_zoom_factor = zoom_factor_1;
   mojom::DisplayConfigResult result = SetDisplayProperties(
-      base::NumberToString(display_id_list[0]), std::move(properties));
+      base::Int64ToString(display_id_list[0]), std::move(properties));
   EXPECT_EQ(mojom::DisplayConfigResult::kSuccess, result);
   EXPECT_EQ(
       zoom_factor_1,
@@ -519,7 +518,7 @@
   // Set zoom factor for display 1.
   properties = mojom::DisplayConfigProperties::New();
   properties->display_zoom_factor = zoom_factor_2;
-  result = SetDisplayProperties(base::NumberToString(display_id_list[1]),
+  result = SetDisplayProperties(base::Int64ToString(display_id_list[1]),
                                 std::move(properties));
   EXPECT_EQ(mojom::DisplayConfigResult::kSuccess, result);
   EXPECT_EQ(
@@ -533,7 +532,7 @@
   const float invalid_zoom_factor = 0.01f;
   properties = mojom::DisplayConfigProperties::New();
   properties->display_zoom_factor = invalid_zoom_factor;
-  result = SetDisplayProperties(base::NumberToString(display_id_list[1]),
+  result = SetDisplayProperties(base::Int64ToString(display_id_list[1]),
                                 std::move(properties));
   EXPECT_EQ(mojom::DisplayConfigResult::kPropertyValueOutOfRangeError, result);
   EXPECT_EQ(
@@ -610,8 +609,7 @@
 
   InitExternalTouchDevices(internal_display_id);
 
-  EXPECT_FALSE(
-      StartTouchCalibration(base::NumberToString(internal_display_id)));
+  EXPECT_FALSE(StartTouchCalibration(base::Int64ToString(internal_display_id)));
   EXPECT_FALSE(IsTouchCalibrationActive());
 }
 
@@ -636,7 +634,7 @@
                                  : display_id_list[0];
 
   ws::InputDeviceClientTestApi().SetTouchscreenDevices({});
-  std::string id = base::NumberToString(display_id);
+  std::string id = base::Int64ToString(display_id);
 
   // Since no external touch devices are present, the calibration should fail.
   EXPECT_FALSE(StartTouchCalibration(id));
@@ -664,7 +662,7 @@
 
   InitExternalTouchDevices(display_id);
 
-  std::string id = base::NumberToString(display_id);
+  std::string id = base::Int64ToString(display_id);
 
   EXPECT_TRUE(StartTouchCalibration(id));
   mojom::TouchCalibrationPtr calibration = GetDefaultCalibration();
@@ -695,7 +693,7 @@
 
   InitExternalTouchDevices(display_id);
 
-  std::string id = base::NumberToString(display_id);
+  std::string id = base::Int64ToString(display_id);
 
   EXPECT_TRUE(StartTouchCalibration(id));
   EXPECT_TRUE(IsTouchCalibrationActive());
--- a/ash/display/cursor_window_controller.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/display/cursor_window_controller.cc	2019-05-17 18:53:08.140000000 +0300
@@ -133,7 +133,8 @@
   // early outing when there isn't a PrefService yet.
   Shell* shell = Shell::Get();
   display::DisplayManager* display_manager = shell->display_manager();
-  if ((display_manager->IsInSoftwareMirrorMode()) ||
+  if ((display_manager->is_multi_mirroring_enabled() &&
+       display_manager->IsInSoftwareMirrorMode()) ||
       display_manager->IsInUnifiedMode() ||
       display_manager->screen_capture_is_active()) {
     return true;
--- a/ash/display/display_color_manager.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/display/display_color_manager.cc	2019-05-17 18:53:08.140000000 +0300
@@ -36,8 +36,7 @@
   VLOG(1) << "Trying ICC file " << path.value()
           << " has_color_correction_matrix: "
           << (has_color_correction_matrix ? "true" : "false");
-  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
-                                                base::BlockingType::MAY_BLOCK);
+  base::ScopedBlockingCall scoped_blocking_call(base::BlockingType::MAY_BLOCK);
   // Reads from a file.
   qcms_profile* display_profile = qcms_profile_from_path(path.value().c_str());
   if (!display_profile) {
@@ -421,7 +420,7 @@
 }
 
 DisplayColorManager::ColorCalibrationData::ColorCalibrationData()
-    : correction_matrix{1, 0, 0, 0, 1, 0, 0, 0, 1} {}
+    : correction_matrix{1, 0, 0, 0, 1, 0, 0, 0, 1} {};
 
 DisplayColorManager::ColorCalibrationData::~ColorCalibrationData() = default;
 
--- a/ash/display/display_configuration_controller.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/display/display_configuration_controller.cc	2019-05-17 18:53:08.140000000 +0300
@@ -13,13 +13,15 @@
 #include "ash/shelf/shelf.h"
 #include "ash/shell.h"
 #include "ash/strings/grit/ash_strings.h"
-#include "base/bind.h"
 #include "base/time/time.h"
 #include "chromeos/system/devicemode.h"
+#include "ui/base/class_property.h"
 #include "ui/base/l10n/l10n_util.h"
 #include "ui/display/display_layout.h"
 #include "ui/display/manager/display_manager.h"
 
+DEFINE_UI_CLASS_PROPERTY_TYPE(ash::ScreenRotationAnimator*);
+
 namespace ash {
 
 namespace {
@@ -34,6 +36,12 @@
 const int64_t kCycleDisplayThrottleTimeoutMs = 4000;
 const int64_t kSetPrimaryDisplayThrottleTimeoutMs = 500;
 
+// A property key to store the ScreenRotationAnimator of the window; Used for
+// screen rotation.
+DEFINE_OWNED_UI_CLASS_PROPERTY_KEY(ash::ScreenRotationAnimator,
+                                   kScreenRotationAnimatorKey,
+                                   nullptr);
+
 bool g_disable_animator_for_test = false;
 
 display::DisplayPositionInUnifiedMatrix GetUnifiedModeShelfCellPosition() {
@@ -121,6 +129,13 @@
 }
 
 void DisplayConfigurationController::SetMirrorMode(bool mirror, bool throttle) {
+  if (!display_manager_->is_multi_mirroring_enabled() &&
+      display_manager_->num_connected_displays() > 2) {
+    ShowDisplayErrorNotification(
+        l10n_util::GetStringUTF16(IDS_ASH_DISPLAY_MIRRORING_NOT_SUPPORTED),
+        false);
+    return;
+  }
   if (display_manager_->num_connected_displays() <= 1 ||
       display_manager_->IsInMirrorMode() == mirror ||
       (throttle && IsLimited())) {
@@ -207,6 +222,13 @@
     display_animator_.reset(new DisplayAnimator());
 }
 
+void DisplayConfigurationController::SetScreenRotationAnimatorForTest(
+    int64_t display_id,
+    std::unique_ptr<ScreenRotationAnimator> animator) {
+  aura::Window* root_window = Shell::GetRootWindowForDisplayId(display_id);
+  root_window->SetProperty(kScreenRotationAnimatorKey, animator.release());
+}
+
 // Private
 
 void DisplayConfigurationController::SetThrottleTimeout(int64_t throttle_ms) {
@@ -251,7 +273,13 @@
 DisplayConfigurationController::GetScreenRotationAnimatorForDisplay(
     int64_t display_id) {
   aura::Window* root_window = Shell::GetRootWindowForDisplayId(display_id);
-  return ScreenRotationAnimator::GetForRootWindow(root_window);
+  ScreenRotationAnimator* animator =
+      root_window->GetProperty(kScreenRotationAnimatorKey);
+  if (!animator) {
+    animator = new ScreenRotationAnimator(root_window);
+    root_window->SetProperty(kScreenRotationAnimatorKey, animator);
+  }
+  return animator;
 }
 
 }  // namespace ash
--- a/ash/display/display_configuration_controller.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/display/display_configuration_controller.h	2019-05-17 18:53:08.140000000 +0300
@@ -96,6 +96,10 @@
   // Allow tests to enable or disable animations.
   void SetAnimatorForTest(bool enable);
 
+  void SetScreenRotationAnimatorForTest(
+      int64_t display_id,
+      std::unique_ptr<ScreenRotationAnimator> animator);
+
  private:
   class DisplayChangeLimiter;
 
--- a/ash/display/display_configuration_controller_test_api.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/display/display_configuration_controller_test_api.cc	2019-05-17 18:53:08.140000000 +0300
@@ -6,7 +6,6 @@
 
 #include "ash/display/display_configuration_controller.h"
 #include "ash/rotator/screen_rotation_animator.h"
-#include "ash/shell.h"
 
 namespace ash {
 
@@ -27,8 +26,7 @@
 void DisplayConfigurationControllerTestApi::SetScreenRotationAnimatorForDisplay(
     int64_t display_id,
     std::unique_ptr<ScreenRotationAnimator> animator) {
-  aura::Window* root_window = Shell::GetRootWindowForDisplayId(display_id);
-  ScreenRotationAnimator::SetScreenRotationAnimatorForTest(root_window,
+  controller_->SetScreenRotationAnimatorForTest(display_id,
                                                            std::move(animator));
 }
 
--- a/ash/display/display_configuration_observer.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/display/display_configuration_observer.cc	2019-05-17 18:53:08.144000000 +0300
@@ -8,7 +8,6 @@
 #include "ash/display/window_tree_host_manager.h"
 #include "ash/shell.h"
 #include "ash/wm/tablet_mode/tablet_mode_controller.h"
-#include "base/bind.h"
 #include "base/command_line.h"
 #include "chromeos/constants/chromeos_switches.h"
 #include "ui/display/manager/display_layout_store.h"
--- a/ash/display/display_error_observer.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/display/display_error_observer.cc	2019-05-17 18:53:08.144000000 +0300
@@ -41,7 +41,7 @@
   }
 
   base::string16 message =
-      (new_state == display::MULTIPLE_DISPLAY_STATE_MULTI_MIRROR)
+      (new_state == display::MULTIPLE_DISPLAY_STATE_DUAL_MIRROR)
           ? l10n_util::GetStringUTF16(IDS_ASH_DISPLAY_FAILURE_ON_MIRRORING)
           : ui::SubstituteChromeOSDeviceType(
                 IDS_ASH_DISPLAY_FAILURE_ON_NON_MIRRORING);
--- a/ash/display/display_error_observer_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/display/display_error_observer_unittest.cc	2019-05-17 18:53:08.144000000 +0300
@@ -70,7 +70,7 @@
   UpdateDisplay("200x200,300x300");
   observer()->OnDisplayModeChangeFailed(
       display::DisplayConfigurator::DisplayStateList(),
-      display::MULTIPLE_DISPLAY_STATE_MULTI_MIRROR);
+      display::MULTIPLE_DISPLAY_STATE_DUAL_MIRROR);
   EXPECT_EQ(l10n_util::GetStringUTF16(IDS_ASH_DISPLAY_FAILURE_ON_MIRRORING),
             GetMessageContents());
 }
@@ -79,13 +79,13 @@
   UpdateDisplay("200x200,300x300");
   observer()->OnDisplayModeChangeFailed(
       display::DisplayConfigurator::DisplayStateList(),
-      display::MULTIPLE_DISPLAY_STATE_MULTI_MIRROR);
+      display::MULTIPLE_DISPLAY_STATE_DUAL_MIRROR);
   base::string16 message = GetMessageContents();
   EXPECT_FALSE(message.empty());
 
   observer()->OnDisplayModeChangeFailed(
       display::DisplayConfigurator::DisplayStateList(),
-      display::MULTIPLE_DISPLAY_STATE_MULTI_MIRROR);
+      display::MULTIPLE_DISPLAY_STATE_DUAL_MIRROR);
   base::string16 message2 = GetMessageContents();
   EXPECT_FALSE(message2.empty());
   EXPECT_EQ(message, message2);
@@ -95,7 +95,7 @@
   UpdateDisplay("200x200,300x300");
   observer()->OnDisplayModeChangeFailed(
       display::DisplayConfigurator::DisplayStateList(),
-      display::MULTIPLE_DISPLAY_STATE_MULTI_MIRROR);
+      display::MULTIPLE_DISPLAY_STATE_DUAL_MIRROR);
   EXPECT_EQ(l10n_util::GetStringUTF16(IDS_ASH_DISPLAY_FAILURE_ON_MIRRORING),
             GetMessageContents());
 
--- a/ash/display/display_manager_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/display/display_manager_unittest.cc	2019-05-17 18:53:08.144000000 +0300
@@ -67,7 +67,7 @@
 namespace {
 
 std::string ToDisplayName(int64_t id) {
-  return "x-" + base::NumberToString(id);
+  return "x-" + base::Int64ToString(id);
 }
 
 }  // namespace
@@ -183,6 +183,22 @@
   DISALLOW_COPY_AND_ASSIGN(DisplayManagerTest);
 };
 
+class DisplayManagerTestDisableMultiMirroring : public DisplayManagerTest {
+ public:
+  DisplayManagerTestDisableMultiMirroring() = default;
+  ~DisplayManagerTestDisableMultiMirroring() override = default;
+
+  // DisplayManagerTest:
+  void SetUp() override {
+    base::CommandLine::ForCurrentProcess()->AppendSwitch(
+        ::switches::kDisableMultiMirroring);
+    DisplayManagerTest::SetUp();
+  }
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(DisplayManagerTestDisableMultiMirroring);
+};
+
 TEST_F(DisplayManagerTest, UpdateDisplayTest) {
   EXPECT_EQ(1U, display_manager()->GetNumDisplays());
 
@@ -1016,6 +1032,17 @@
   EXPECT_TRUE(layout.HasSamePlacementList(*(expected_layout_builder.Build())));
 }
 
+// TODO(weidongg/774795) Remove test when multi mirroring is enabled by default.
+TEST_F(DisplayManagerTestDisableMultiMirroring, NoMirrorInThreeDisplays) {
+  UpdateDisplay("640x480,320x200,400x300");
+  ash::Shell::Get()->display_configuration_controller()->SetMirrorMode(true,
+                                                                       false);
+  EXPECT_FALSE(display_manager()->IsInMirrorMode());
+  EXPECT_EQ(3u, display_manager()->GetNumDisplays());
+  EXPECT_EQ(l10n_util::GetStringUTF16(IDS_ASH_DISPLAY_MIRRORING_NOT_SUPPORTED),
+            GetDisplayErrorNotificationMessageForTest());
+}
+
 TEST_F(DisplayManagerTest, OverscanInsetsTest) {
   UpdateDisplay("0+0-500x500,0+501-400x400");
   reset();
@@ -1898,17 +1925,6 @@
       display::DisplayObserver::DISPLAY_METRIC_WORK_AREA |
       display::DisplayObserver::DISPLAY_METRIC_PRIMARY;
   EXPECT_EQ(expected_changed_metrics, changed_metrics());
-
-  // Exit docked mode by re-adding the internal display again.
-  reset();
-  display_info_list.clear();
-  display_info_list.emplace_back(internal_info);
-  display_info_list.emplace_back(external_info);
-  display_manager()->OnNativeDisplaysChanged(display_info_list);
-
-  // Expect that we get a "primary" change notification.
-  EXPECT_EQ("5 1 0 1 1", GetCountSummary());
-  EXPECT_EQ(expected_changed_metrics, changed_metrics());
 }
 
 TEST_F(DisplayManagerTest, Rotate) {
@@ -2224,6 +2240,41 @@
   SetSoftwareMirrorMode(false);
 }
 
+// TODO(weidongg/774795) Remove test when multi mirroring is enabled by default.
+// Make sure this does not cause any crashes. See http://crbug.com/412910
+TEST_F(DisplayManagerTestDisableMultiMirroring,
+       SoftwareMirroringWithCompositingCursor) {
+  UpdateDisplay("300x400,400x500");
+
+  MirrorWindowTestApi test_api;
+  EXPECT_TRUE(test_api.GetHosts().empty());
+
+  display::ManagedDisplayInfo secondary_info =
+      display_manager()->GetDisplayInfo(
+          display_manager()->GetSecondaryDisplay().id());
+
+  display_manager()->SetSoftwareMirroring(true);
+  display_manager()->UpdateDisplays();
+
+  aura::Window::Windows root_windows = Shell::GetAllRootWindows();
+  EXPECT_FALSE(root_windows[0]->Contains(test_api.GetCursorWindow()));
+
+  Shell::Get()->SetCursorCompositingEnabled(true);
+
+  EXPECT_TRUE(root_windows[0]->Contains(test_api.GetCursorWindow()));
+
+  // Removes the first display and keeps the second one.
+  display_manager()->SetSoftwareMirroring(false);
+  std::vector<display::ManagedDisplayInfo> new_info_list;
+  new_info_list.push_back(secondary_info);
+  display_manager()->OnNativeDisplaysChanged(new_info_list);
+
+  root_windows = Shell::GetAllRootWindows();
+  EXPECT_TRUE(root_windows[0]->Contains(test_api.GetCursorWindow()));
+
+  Shell::Get()->SetCursorCompositingEnabled(false);
+}
+
 TEST_F(DisplayManagerTest, InvertLayout) {
   EXPECT_EQ("left, 0",
             display::DisplayPlacement(display::DisplayPlacement::RIGHT, 0)
@@ -3264,7 +3315,7 @@
   // display zoom enabled.
   display_manager()->RegisterDisplayProperty(id, display::Display::ROTATE_0,
                                              -1000, nullptr, gfx::Size(), 1.f,
-                                             zoom_factor, 60.f, false);
+                                             zoom_factor);
 
   const display::ManagedDisplayInfo& info =
       display_manager()->GetDisplayInfo(id);
@@ -3274,9 +3325,8 @@
 
 TEST_F(DisplayManagerTest, CheckInitializationOfRotationProperty) {
   int64_t id = display_manager()->GetDisplayAt(0).id();
-  display_manager()->RegisterDisplayProperty(id, display::Display::ROTATE_90,
-                                             1.0f, nullptr, gfx::Size(), 1.0f,
-                                             1.0f, 60.f, false);
+  display_manager()->RegisterDisplayProperty(
+      id, display::Display::ROTATE_90, 1.0f, nullptr, gfx::Size(), 1.0f, 1.0f);
 
   const display::ManagedDisplayInfo& info =
       display_manager()->GetDisplayInfo(id);
@@ -3384,7 +3434,8 @@
   display::Screen* screen = display::Screen::GetScreen();
   DCHECK(screen);
   Shell* shell = Shell::Get();
-  display::DisplayChangeObserver observer(shell->display_manager());
+  display::DisplayChangeObserver observer(shell->display_configurator(),
+                                          display_manager());
   display::DisplayConfigurator::DisplayStateList outputs;
   std::unique_ptr<display::DisplaySnapshot> internal_snapshot =
       display::FakeDisplaySnapshot::Builder()
@@ -3430,7 +3481,9 @@
           .SetFirstDisplayAsInternalDisplay();
   display::Screen* screen = display::Screen::GetScreen();
   DCHECK(screen);
-  display::DisplayChangeObserver observer(display_manager());
+  Shell* shell = Shell::Get();
+  display::DisplayChangeObserver observer(shell->display_configurator(),
+                                          display_manager());
   display::DisplayConfigurator::DisplayStateList outputs;
   std::unique_ptr<display::DisplaySnapshot> internal_snapshot =
       display::FakeDisplaySnapshot::Builder()
@@ -3478,7 +3531,9 @@
   constexpr int64_t id2 = 2;
   display::Screen* screen = display::Screen::GetScreen();
   DCHECK(screen);
-  display::DisplayChangeObserver observer(display_manager());
+  Shell* shell = Shell::Get();
+  display::DisplayChangeObserver observer(shell->display_configurator(),
+                                          display_manager());
   display::DisplayConfigurator::DisplayStateList outputs;
   std::unique_ptr<display::DisplaySnapshot> snapshot1 =
       display::FakeDisplaySnapshot::Builder()
@@ -3508,7 +3563,7 @@
       display_manager()->GetCurrentDisplayIdList();
   display_manager()->layout_store()->UpdateDefaultUnified(current_list,
                                                           false /* unified */);
-  EXPECT_EQ(display::MULTIPLE_DISPLAY_STATE_MULTI_MIRROR,
+  EXPECT_EQ(display::MULTIPLE_DISPLAY_STATE_DUAL_MIRROR,
             observer.GetStateForDisplayIds(outputs));
 
   display_manager()->layout_store()->set_forced_mirror_mode_for_tablet(false);
--- a/ash/display/display_prefs.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/display/display_prefs.cc	2019-05-17 18:53:08.144000000 +0300
@@ -22,7 +22,6 @@
 #include "components/prefs/pref_service.h"
 #include "components/prefs/scoped_user_pref_update.h"
 #include "third_party/cros_system_api/dbus/service_constants.h"
-#include "ui/display/display_features.h"
 #include "ui/display/display_switches.h"
 #include "ui/display/manager/display_layout_store.h"
 #include "ui/display/manager/display_manager.h"
@@ -179,17 +178,17 @@
   std::string str;
   for (std::size_t row = 0; row < touch_calibration_data.point_pairs.size();
        row++) {
-    str += base::NumberToString(
-               touch_calibration_data.point_pairs[row].first.x()) +
+    str +=
+        base::IntToString(touch_calibration_data.point_pairs[row].first.x()) +
            " ";
-    str += base::NumberToString(
-               touch_calibration_data.point_pairs[row].first.y()) +
+    str +=
+        base::IntToString(touch_calibration_data.point_pairs[row].first.y()) +
            " ";
-    str += base::NumberToString(
-               touch_calibration_data.point_pairs[row].second.x()) +
+    str +=
+        base::IntToString(touch_calibration_data.point_pairs[row].second.x()) +
            " ";
-    str += base::NumberToString(
-        touch_calibration_data.point_pairs[row].second.y());
+    str +=
+        base::IntToString(touch_calibration_data.point_pairs[row].second.y());
     if (row != touch_calibration_data.point_pairs.size() - 1)
       str += " ";
   }
@@ -279,16 +278,6 @@
     if (dict_value->GetInteger("device-scale-factor", &dsf_value))
       device_scale_factor = static_cast<float>(dsf_value) / 1000.0f;
 
-    // Default refresh rate is 60 Hz, until
-    // DisplayManager::OnNativeDisplaysChanged() updates us with the actual
-    // display info.
-    double refresh_rate = 60.0;
-    bool is_interlaced = false;
-    if (display::features::IsListAllDisplayModesEnabled()) {
-      dict_value->GetDouble("refresh-rate", &refresh_rate);
-      dict_value->GetBoolean("interlaced", &is_interlaced);
-    }
-
     gfx::Insets insets;
     if (ValueToInsets(*dict_value, &insets))
       insets_to_set = &insets;
@@ -298,7 +287,7 @@
 
     GetDisplayManager()->RegisterDisplayProperty(
         id, rotation, ui_scale, insets_to_set, resolution_in_pixels,
-        device_scale_factor, display_zoom, refresh_rate, is_interlaced);
+        device_scale_factor, display_zoom);
   }
 }
 
@@ -578,11 +567,6 @@
       property_value->SetInteger(
           "device-scale-factor",
           static_cast<int>(mode.device_scale_factor() * 1000));
-
-      if (display::features::IsListAllDisplayModesEnabled()) {
-        property_value->SetBoolean("interlaced", mode.is_interlaced());
-        property_value->SetDouble("refresh-rate", mode.refresh_rate());
-      }
     }
     if (!info.overscan_insets_in_dip().IsEmpty())
       InsetsToValue(info.overscan_insets_in_dip(), property_value.get());
@@ -596,7 +580,7 @@
 
     property_value->SetDouble(kDisplayZoom, info.zoom_factor());
 
-    pref_data->Set(base::NumberToString(id), std::move(property_value));
+    pref_data->Set(base::Int64ToString(id), std::move(property_value));
   }
 }
 
@@ -670,8 +654,6 @@
 
   DictionaryPrefUpdate update(pref_service, prefs::kDisplayTouchAssociations);
   base::DictionaryValue* pref_data = update.Get();
-  pref_data->Clear();
-
   const display::TouchDeviceManager::TouchAssociationMap& touch_associations =
       touch_device_manager->touch_associations();
 
@@ -702,7 +684,7 @@
       // display id as key. This is a 1 to 1 mapping of a single entry from
       // AssociationInfoMap to its serialized form.
       association_info_map_value.SetKey(
-          base::NumberToString(association_info.first),
+          base::Int64ToString(association_info.first),
           association_info_value->Clone());
     }
     if (association_info_map_value.empty())
@@ -721,8 +703,6 @@
   DictionaryPrefUpdate update_port(pref_service,
                                    prefs::kDisplayTouchPortAssociations);
   pref_data = update_port.Get();
-  update_port->Clear();
-
   const display::TouchDeviceManager::PortAssociationMap& port_associations =
       touch_device_manager->port_associations();
 
@@ -735,7 +715,7 @@
                                    base::Value(association.first.ToString()));
     association_info_value->SetKey(
         kPortAssociationDisplayId,
-        base::Value(base::NumberToString(association.second)));
+        base::Value(base::Int64ToString(association.second)));
 
     pref_data->SetKey(association.first.SecondaryIdToString(),
                       association_info_value->Clone());
@@ -750,7 +730,7 @@
   const std::set<int64_t>& external_display_mirror_info =
       GetDisplayManager()->external_display_mirror_info();
   for (const auto& id : external_display_mirror_info)
-    pref_data->GetList().emplace_back(base::Value(base::NumberToString(id)));
+    pref_data->GetList().emplace_back(base::Value(base::Int64ToString(id)));
 }
 
 // Stores mixed mirror mode parameters. Clear the preferences if
@@ -767,12 +747,12 @@
     return;
 
   pref_data->SetKey(kMirroringSourceId,
-                    base::Value(base::NumberToString(mixed_params->source_id)));
+                    base::Value(base::Int64ToString(mixed_params->source_id)));
 
   base::ListValue mirroring_destination_ids_value;
   for (const auto& id : mixed_params->destination_ids) {
     mirroring_destination_ids_value.GetList().emplace_back(
-        base::Value(base::NumberToString(id)));
+        base::Value(base::Int64ToString(id)));
   }
   pref_data->SetKey(kMirroringDestinationIds,
                     std::move(mirroring_destination_ids_value));
@@ -918,11 +898,6 @@
   StoreDisplayTouchAssociations(pref_service);
   StoreExternalDisplayMirrorInfo(pref_service);
   StoreCurrentDisplayMixedMirrorModeParams(pref_service);
-
-  // The display prefs need to be committed immediately to guarantee they're not
-  // lost, and are restored properly on reboot. https://crbug.com/936884.
-  // This sends a request via mojo to commit the prefs to disk.
-  pref_service->CommitPendingWrite();
 }
 
 void DisplayPrefs::LoadDisplayPreferences() {
@@ -934,14 +909,6 @@
   LoadDisplayRotationState(local_state);
   LoadDisplayTouchAssociations(local_state);
 
-  // Now that the display prefs have been loaded, request to reconfigure the
-  // displays, but signal the display manager to restore the mirror state of
-  // external displays from the loaded prefs (if any).
-  Shell::Get()
-      ->display_manager()
-      ->set_should_restore_mirror_mode_from_display_prefs(true);
-  Shell::Get()->display_configurator()->OnConfigurationChanged();
-
   // Ensure that we have a reasonable initial display power state if
   // powerd fails to send us one over D-Bus. Otherwise, we won't restore
   // displays correctly after retaking control when changing virtual terminals.
@@ -990,7 +957,7 @@
   std::unique_ptr<base::DictionaryValue> property_value =
       std::make_unique<base::DictionaryValue>();
   TouchDataToValue(data, property_value.get());
-  pref_data->Set(base::NumberToString(display_id), std::move(property_value));
+  pref_data->Set(base::Int64ToString(display_id), std::move(property_value));
 }
 
 bool DisplayPrefs::ParseTouchCalibrationStringForTest(
--- a/ash/display/display_prefs_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/display/display_prefs_unittest.cc	2019-05-17 18:53:08.144000000 +0300
@@ -200,7 +200,7 @@
 
   void StoreDisplayOverscan(int64_t id, const gfx::Insets& insets) {
     DictionaryPrefUpdate update(local_state(), prefs::kDisplayProperties);
-    const std::string name = base::NumberToString(id);
+    const std::string name = base::Int64ToString(id);
 
     base::DictionaryValue* pref_data = update.Get();
     auto insets_value = std::make_unique<base::DictionaryValue>();
@@ -224,7 +224,7 @@
     base::ListValue* pref_data = update.Get();
     pref_data->Clear();
     for (const auto& id : external_display_mirror_info)
-      pref_data->GetList().emplace_back(base::Value(base::NumberToString(id)));
+      pref_data->GetList().emplace_back(base::Value(base::Int64ToString(id)));
   }
 
   std::string GetRegisteredDisplayPlacementStr(
@@ -387,9 +387,9 @@
   const base::DictionaryValue* displays =
       local_state()->GetDictionary(prefs::kSecondaryDisplays);
   const base::DictionaryValue* layout_value = nullptr;
-  std::string key = base::NumberToString(id1) + "," + base::NumberToString(id2);
+  std::string key = base::Int64ToString(id1) + "," + base::Int64ToString(id2);
   std::string dummy_key =
-      base::NumberToString(id1) + "," + base::NumberToString(dummy_id);
+      base::Int64ToString(id1) + "," + base::Int64ToString(dummy_id);
   EXPECT_TRUE(displays->GetDictionary(dummy_key, &layout_value));
 
   display::DisplayLayout stored_layout;
@@ -408,7 +408,7 @@
   const base::DictionaryValue* properties =
       local_state()->GetDictionary(prefs::kDisplayProperties);
   const base::DictionaryValue* property = nullptr;
-  EXPECT_TRUE(properties->GetDictionary(base::NumberToString(id1), &property));
+  EXPECT_TRUE(properties->GetDictionary(base::Int64ToString(id1), &property));
   int ui_scale = 0;
   int rotation = 0;
   EXPECT_TRUE(property->GetInteger("rotation", &rotation));
@@ -460,7 +460,7 @@
 
   std::string touch_str;
 
-  EXPECT_TRUE(properties->GetDictionary(base::NumberToString(id2), &property));
+  EXPECT_TRUE(properties->GetDictionary(base::Int64ToString(id2), &property));
   EXPECT_TRUE(property->GetInteger("rotation", &rotation));
   EXPECT_TRUE(property->GetInteger("ui-scale", &ui_scale));
   EXPECT_EQ(0, rotation);
@@ -491,7 +491,7 @@
 
   EXPECT_EQ(id2, display::Screen::GetScreen()->GetPrimaryDisplay().id());
 
-  EXPECT_TRUE(properties->GetDictionary(base::NumberToString(id1), &property));
+  EXPECT_TRUE(properties->GetDictionary(base::Int64ToString(id1), &property));
   width = 0;
   height = 0;
   // Internal display shouldn't store its resolution.
@@ -501,7 +501,7 @@
   // External display's resolution must be stored this time because
   // it's not best.
   int device_scale_factor = 0;
-  EXPECT_TRUE(properties->GetDictionary(base::NumberToString(id2), &property));
+  EXPECT_TRUE(properties->GetDictionary(base::Int64ToString(id2), &property));
   EXPECT_TRUE(property->GetInteger("width", &width));
   EXPECT_TRUE(property->GetInteger("height", &height));
   EXPECT_TRUE(
@@ -528,7 +528,7 @@
 
   std::string primary_id_str;
   EXPECT_TRUE(layout_value->GetString(kPrimaryIdKey, &primary_id_str));
-  EXPECT_EQ(base::NumberToString(id2), primary_id_str);
+  EXPECT_EQ(base::Int64ToString(id2), primary_id_str);
 
   display_manager()->SetLayoutForCurrentDisplays(
       display::test::CreateDisplayLayout(ash::Shell::Get()->display_manager(),
@@ -546,26 +546,26 @@
   EXPECT_EQ(20, offset);
   std::string id;
   EXPECT_TRUE(layout_value->GetString(kPlacementDisplayIdKey, &id));
-  EXPECT_EQ(base::NumberToString(id1), id);
+  EXPECT_EQ(base::Int64ToString(id1), id);
   EXPECT_TRUE(layout_value->GetString(kPlacementParentDisplayIdKey, &id));
-  EXPECT_EQ(base::NumberToString(id2), id);
+  EXPECT_EQ(base::Int64ToString(id2), id);
 
   EXPECT_TRUE(layout_value->GetString(kPrimaryIdKey, &primary_id_str));
-  EXPECT_EQ(base::NumberToString(id2), primary_id_str);
+  EXPECT_EQ(base::Int64ToString(id2), primary_id_str);
 
-  EXPECT_TRUE(properties->GetDictionary(base::NumberToString(id1), &property));
+  EXPECT_TRUE(properties->GetDictionary(base::Int64ToString(id1), &property));
   EXPECT_FALSE(property->GetInteger("width", &width));
   EXPECT_FALSE(property->GetInteger("height", &height));
 
   external_display_mirror_info =
       local_state()->GetList(prefs::kExternalDisplayMirrorInfo);
   EXPECT_EQ(1U, external_display_mirror_info->GetSize());
-  EXPECT_EQ(base::NumberToString(id2),
+  EXPECT_EQ(base::Int64ToString(id2),
             external_display_mirror_info->GetList()[0].GetString());
 
   // External display's selected resolution must not change
   // by mirroring.
-  EXPECT_TRUE(properties->GetDictionary(base::NumberToString(id2), &property));
+  EXPECT_TRUE(properties->GetDictionary(base::Int64ToString(id2), &property));
   EXPECT_TRUE(property->GetInteger("width", &width));
   EXPECT_TRUE(property->GetInteger("height", &height));
   EXPECT_EQ(300, width);
@@ -574,46 +574,46 @@
   // Set new display's selected resolution.
   display_manager()->RegisterDisplayProperty(
       id2 + 1, display::Display::ROTATE_0, 1.0f, nullptr, gfx::Size(500, 400),
-      1.0f, 1.0f, 60.f, false);
+      1.0f, 1.0f);
 
   UpdateDisplay("200x200*2, 600x500#600x500|500x400");
 
   // Update key as the 2nd display gets new id.
   id2 = display_manager()->GetSecondaryDisplay().id();
-  key = base::NumberToString(id1) + "," + base::NumberToString(id2);
+  key = base::Int64ToString(id1) + "," + base::Int64ToString(id2);
   EXPECT_TRUE(displays->GetDictionary(key, &layout_value));
   EXPECT_TRUE(layout_value->GetString(kPositionKey, &position));
   EXPECT_EQ("right", position);
   EXPECT_TRUE(layout_value->GetInteger(kOffsetKey, &offset));
   EXPECT_EQ(0, offset);
   EXPECT_TRUE(layout_value->GetString(kPrimaryIdKey, &primary_id_str));
-  EXPECT_EQ(base::NumberToString(id1), primary_id_str);
+  EXPECT_EQ(base::Int64ToString(id1), primary_id_str);
 
   // Best resolution should not be saved.
-  EXPECT_TRUE(properties->GetDictionary(base::NumberToString(id2), &property));
+  EXPECT_TRUE(properties->GetDictionary(base::Int64ToString(id2), &property));
   EXPECT_FALSE(property->GetInteger("width", &width));
   EXPECT_FALSE(property->GetInteger("height", &height));
 
   // Set yet another new display's selected resolution.
   display_manager()->RegisterDisplayProperty(
       id2 + 1, display::Display::ROTATE_0, 1.0f, nullptr, gfx::Size(500, 400),
-      1.0f, 1.0f, 60.f, false);
+      1.0f, 1.0f);
   // Disconnect 2nd display first to generate new id for external display.
   UpdateDisplay("200x200*2");
   UpdateDisplay("200x200*2, 500x400#600x500|500x400%60.0f");
   // Update key as the 2nd display gets new id.
   id2 = display_manager()->GetSecondaryDisplay().id();
-  key = base::NumberToString(id1) + "," + base::NumberToString(id2);
+  key = base::Int64ToString(id1) + "," + base::Int64ToString(id2);
   EXPECT_TRUE(displays->GetDictionary(key, &layout_value));
   EXPECT_TRUE(layout_value->GetString(kPositionKey, &position));
   EXPECT_EQ("right", position);
   EXPECT_TRUE(layout_value->GetInteger(kOffsetKey, &offset));
   EXPECT_EQ(0, offset);
   EXPECT_TRUE(layout_value->GetString(kPrimaryIdKey, &primary_id_str));
-  EXPECT_EQ(base::NumberToString(id1), primary_id_str);
+  EXPECT_EQ(base::Int64ToString(id1), primary_id_str);
 
   // External display's selected resolution must be updated.
-  EXPECT_TRUE(properties->GetDictionary(base::NumberToString(id2), &property));
+  EXPECT_TRUE(properties->GetDictionary(base::Int64ToString(id2), &property));
   EXPECT_TRUE(property->GetInteger("width", &width));
   EXPECT_TRUE(property->GetInteger("height", &height));
   EXPECT_EQ(500, width);
@@ -639,7 +639,7 @@
   const base::DictionaryValue* properties =
       local_state()->GetDictionary(prefs::kDisplayProperties);
   const base::DictionaryValue* property = nullptr;
-  EXPECT_TRUE(properties->GetDictionary(base::NumberToString(id), &property));
+  EXPECT_TRUE(properties->GetDictionary(base::Int64ToString(id), &property));
   int width = 0, height = 0;
   EXPECT_FALSE(property->GetInteger("width", &width));
   EXPECT_FALSE(property->GetInteger("height", &height));
@@ -654,7 +654,7 @@
   UpdateDisplay("300x200#500x400|400x300|300x200");
 
   property = nullptr;
-  EXPECT_TRUE(properties->GetDictionary(base::NumberToString(id), &property));
+  EXPECT_TRUE(properties->GetDictionary(base::Int64ToString(id), &property));
   EXPECT_TRUE(property->GetInteger("width", &width));
   EXPECT_TRUE(property->GetInteger("height", &height));
   EXPECT_EQ(300, width);
@@ -671,7 +671,7 @@
   SwapPrimaryDisplay();
   ASSERT_EQ(id1, display_manager()->GetSecondaryDisplay().id());
 
-  std::string key = base::NumberToString(id1) + "," + base::NumberToString(id2);
+  std::string key = base::Int64ToString(id1) + "," + base::Int64ToString(id2);
   const base::DictionaryValue* displays =
       local_state()->GetDictionary(prefs::kSecondaryDisplays);
   // Initial saved value is swapped.
@@ -873,7 +873,7 @@
       local_state()->GetDictionary(prefs::kDisplayProperties);
   const base::DictionaryValue* property = nullptr;
   EXPECT_TRUE(properties->GetDictionary(
-      base::NumberToString(display::Display::InternalDisplayId()), &property));
+      base::Int64ToString(display::Display::InternalDisplayId()), &property));
   int rotation = -1;
   EXPECT_TRUE(property->GetInteger("rotation", &rotation));
   EXPECT_EQ(display::Display::ROTATE_0, rotation);
@@ -884,7 +884,7 @@
   properties = local_state()->GetDictionary(prefs::kDisplayProperties);
   property = nullptr;
   EXPECT_TRUE(properties->GetDictionary(
-      base::NumberToString(display::Display::InternalDisplayId()), &property));
+      base::Int64ToString(display::Display::InternalDisplayId()), &property));
   rotation = -1;
   EXPECT_TRUE(property->GetInteger("rotation", &rotation));
   EXPECT_EQ(display::Display::ROTATE_0, rotation);
@@ -1055,7 +1055,7 @@
       local_state()->GetDictionary(prefs::kDisplayProperties);
   int64_t unified_id = display::Screen::GetScreen()->GetPrimaryDisplay().id();
   EXPECT_FALSE(
-      displays->GetDictionary(base::NumberToString(unified_id), &new_value));
+      displays->GetDictionary(base::Int64ToString(unified_id), &new_value));
 
   display::test::SetDisplayResolution(display_manager(), unified_id,
                                       gfx::Size(200, 100));
@@ -1063,7 +1063,7 @@
       "200x100",
       display::Screen::GetScreen()->GetPrimaryDisplay().size().ToString());
   EXPECT_FALSE(
-      displays->GetDictionary(base::NumberToString(unified_id), &new_value));
+      displays->GetDictionary(base::Int64ToString(unified_id), &new_value));
 
   // Mirror mode should remember if the default mode was unified.
   display_manager()->SetMirrorMode(display::MirrorMode::kNormal, base::nullopt);
@@ -1107,7 +1107,7 @@
   StoreDisplayBoolPropertyForList(list, "default_unified", true);
   StoreDisplayPropertyForList(
       list, "primary-id",
-      std::make_unique<base::Value>(base::NumberToString(first_display_id)));
+      std::make_unique<base::Value>(base::Int64ToString(first_display_id)));
   LoadDisplayPreferences();
 
   // Should not restore to unified unless unified desktop is enabled.
@@ -1302,7 +1302,7 @@
   const base::ListValue* pref_external_display_mirror_info =
       local_state()->GetList(prefs::kExternalDisplayMirrorInfo);
   EXPECT_EQ(1U, pref_external_display_mirror_info->GetSize());
-  EXPECT_EQ(base::NumberToString(first_display_masked_id),
+  EXPECT_EQ(base::Int64ToString(first_display_masked_id),
             pref_external_display_mirror_info->GetList()[0].GetString());
 
   // Add first display, mirror mode restores and the external display mirror
@@ -1313,7 +1313,7 @@
   pref_external_display_mirror_info =
       local_state()->GetList(prefs::kExternalDisplayMirrorInfo);
   EXPECT_EQ(1U, pref_external_display_mirror_info->GetSize());
-  EXPECT_EQ(base::NumberToString(first_display_masked_id),
+  EXPECT_EQ(base::Int64ToString(first_display_masked_id),
             pref_external_display_mirror_info->GetList()[0].GetString());
 
   // Add second display, mirror mode persists and the second display id is added
@@ -1324,9 +1324,9 @@
   pref_external_display_mirror_info =
       local_state()->GetList(prefs::kExternalDisplayMirrorInfo);
   EXPECT_EQ(2U, pref_external_display_mirror_info->GetSize());
-  EXPECT_EQ(base::NumberToString(first_display_masked_id),
+  EXPECT_EQ(base::Int64ToString(first_display_masked_id),
             pref_external_display_mirror_info->GetList()[0].GetString());
-  EXPECT_EQ(base::NumberToString(second_display_masked_id),
+  EXPECT_EQ(base::Int64ToString(second_display_masked_id),
             pref_external_display_mirror_info->GetList()[1].GetString());
 
   // Disconnect all external displays.
@@ -1342,7 +1342,7 @@
   pref_external_display_mirror_info =
       local_state()->GetList(prefs::kExternalDisplayMirrorInfo);
   EXPECT_EQ(1U, pref_external_display_mirror_info->GetSize());
-  EXPECT_EQ(base::NumberToString(second_display_masked_id),
+  EXPECT_EQ(base::Int64ToString(second_display_masked_id),
             pref_external_display_mirror_info->GetList()[0].GetString());
 
   // Add first display, mirror mode is off and the external display mirror info
@@ -1353,7 +1353,7 @@
   pref_external_display_mirror_info =
       local_state()->GetList(prefs::kExternalDisplayMirrorInfo);
   EXPECT_EQ(1U, pref_external_display_mirror_info->GetSize());
-  EXPECT_EQ(base::NumberToString(second_display_masked_id),
+  EXPECT_EQ(base::Int64ToString(second_display_masked_id),
             pref_external_display_mirror_info->GetList()[0].GetString());
 
   // Add second display, mirror mode remains off and the second display id is
@@ -1366,51 +1366,6 @@
   EXPECT_EQ(0U, pref_external_display_mirror_info->GetSize());
 }
 
-TEST_F(DisplayPrefsTest, ExternalDisplayConnectedBeforeLoadingPrefs) {
-  LoggedInAsUser();
-
-  base::CommandLine::ForCurrentProcess()->AppendSwitch(
-      chromeos::switches::kFirstExecAfterBoot);
-
-  const int64_t internal_display_id =
-      display::test::DisplayManagerTestApi(display_manager())
-          .SetFirstDisplayAsInternalDisplay();
-  constexpr int64_t external_display_id = 210000001;
-  display::ManagedDisplayInfo external_display_info =
-      display::CreateDisplayInfo(external_display_id,
-                                 gfx::Rect(1, 1, 500, 500));
-
-  // Both internal and external displays connect before the prefs are loaded.
-  std::vector<display::ManagedDisplayInfo> display_info_list;
-  display_info_list.push_back(display::CreateDisplayInfo(
-      internal_display_id, gfx::Rect(0, 0, 100, 100)));
-  display_info_list.push_back(external_display_info);
-  display_manager()->OnNativeDisplaysChanged(display_info_list);
-
-  EXPECT_FALSE(display_manager()->IsInMirrorMode());
-  EXPECT_EQ(2u, display_manager()->num_connected_displays());
-
-  // Add external display id to the external display mirror info.
-  std::set<int64_t> external_display_mirror_info;
-  const int64_t external_display_masked_id =
-      display::GetDisplayIdWithoutOutputIndex(external_display_id);
-  external_display_mirror_info.emplace(external_display_masked_id);
-  StoreExternalDisplayMirrorInfo(external_display_mirror_info);
-
-  // Load the preferences and simulate a native display reconfiguration. Expect
-  // that we are mirroring now.
-  LoadDisplayPreferences();
-
-  // Simulate a change in display configuration between loading the prefs, and
-  // reconfiguring after the prefs have been loaded. Make sure that the external
-  // display mirror configs are not overwritten, and the loaded prefs will be
-  // applied.
-  display_manager()->SetMirrorMode(display::MirrorMode::kOff, base::nullopt);
-
-  display_manager()->OnNativeDisplaysChanged(display_info_list);
-  EXPECT_TRUE(display_manager()->IsInMirrorMode());
-}
-
 TEST_F(DisplayPrefsTest, DisplayMixedMirrorMode) {
   LoggedInAsUser();
 
@@ -1449,12 +1404,12 @@
   // Check the preferences.
   const base::DictionaryValue* pref_data =
       local_state()->GetDictionary(prefs::kDisplayMixedMirrorModeParams);
-  EXPECT_EQ(base::NumberToString(internal_display_id),
+  EXPECT_EQ(base::Int64ToString(internal_display_id),
             pref_data->FindKey("mirroring_source_id")->GetString());
   const base::Value* destination_ids_value =
       pref_data->FindKey("mirroring_destination_ids");
   EXPECT_EQ(1U, destination_ids_value->GetList().size());
-  EXPECT_EQ(base::NumberToString(first_display_id),
+  EXPECT_EQ(base::Int64ToString(first_display_id),
             destination_ids_value->GetList()[0].GetString());
 
   // Overwrite current mixed mirror mode with a new configuration. (Mirror from
@@ -1474,11 +1429,11 @@
   // Check the preferences.
   pref_data =
       local_state()->GetDictionary(prefs::kDisplayMixedMirrorModeParams);
-  EXPECT_EQ(base::NumberToString(first_display_id),
+  EXPECT_EQ(base::Int64ToString(first_display_id),
             pref_data->FindKey("mirroring_source_id")->GetString());
   destination_ids_value = pref_data->FindKey("mirroring_destination_ids");
   EXPECT_EQ(1U, destination_ids_value->GetList().size());
-  EXPECT_EQ(base::NumberToString(second_display_id),
+  EXPECT_EQ(base::Int64ToString(second_display_id),
             destination_ids_value->GetList()[0].GetString());
 
   // Turn off mirror mode.
--- a/ash/display/display_util.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/display/display_util.cc	2019-05-17 18:53:08.144000000 +0300
@@ -17,7 +17,6 @@
 #include "ash/resources/vector_icons/vector_icons.h"
 #include "ash/shell.h"
 #include "ash/strings/grit/ash_strings.h"
-#include "base/bind.h"
 #include "base/strings/string_number_conversions.h"
 #include "base/strings/utf_string_conversions.h"
 #include "base/system/sys_info.h"
--- a/ash/display/mirror_window_controller.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/display/mirror_window_controller.cc	2019-05-17 18:53:08.144000000 +0300
@@ -226,7 +226,7 @@
       host_info->ash_host->SetRootWindowTransformer(std::move(transformer));
       // The accelerated widget is created synchronously.
       DCHECK_NE(gfx::kNullAcceleratedWidget, host->GetAcceleratedWidget());
-      if (!features::IsVizDisplayCompositorEnabled()) {
+      if (!base::FeatureList::IsEnabled(features::kVizDisplayCompositor)) {
         mirror_window->SetBounds(host->window()->bounds());
         mirror_window->Show();
         if (reflector_) {
@@ -248,7 +248,7 @@
       host->SetBoundsInPixels(display_info.bounds_in_native());
     }
 
-    if (features::IsVizDisplayCompositorEnabled()) {
+    if (base::FeatureList::IsEnabled(features::kVizDisplayCompositor)) {
       // |mirror_size| is the size of the mirror source in physical pixels.
       // The RootWindowTransformer corrects the scale of the mirrored display
       // and the location of input events.
--- a/ash/display/persistent_window_controller.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/display/persistent_window_controller.cc	2019-05-17 18:53:08.148000000 +0300
@@ -9,7 +9,6 @@
 #include "ash/shell.h"
 #include "ash/wm/mru_window_tracker.h"
 #include "ash/wm/window_state.h"
-#include "base/bind.h"
 #include "base/command_line.h"
 #include "base/metrics/histogram_macros.h"
 #include "ui/display/manager/display_manager.h"
--- a/ash/display/projecting_observer.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/display/projecting_observer.cc	2019-05-17 18:53:08.148000000 +0300
@@ -63,7 +63,12 @@
   bool projecting =
       has_internal_output_ && (output_count_ + casting_session_count_ > 1);
 
-  chromeos::PowerManagerClient::Get()->SetIsProjecting(projecting);
+  chromeos::PowerManagerClient* power_manager_client =
+      power_manager_client_for_test_
+          ? power_manager_client_for_test_
+          : chromeos::DBusThreadManager::Get()->GetPowerManagerClient();
+  if (power_manager_client)
+    power_manager_client->SetIsProjecting(projecting);
 }
 
 }  // namespace ash
--- a/ash/display/projecting_observer.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/display/projecting_observer.h	2019-05-17 18:53:08.148000000 +0300
@@ -10,6 +10,10 @@
 #include "base/macros.h"
 #include "ui/display/manager/display_configurator.h"
 
+namespace chromeos {
+class PowerManagerClient;
+}
+
 namespace ash {
 
 class ASH_EXPORT ProjectingObserver
@@ -31,6 +35,11 @@
  private:
   friend class ProjectingObserverTest;
 
+  void set_power_manager_client_for_test(
+      chromeos::PowerManagerClient* power_manager_client) {
+    power_manager_client_for_test_ = power_manager_client;
+  }
+
   // Sends the current projecting state to power manager.
   void SetIsProjecting();
 
@@ -46,6 +55,9 @@
   // Number of outstanding casting sessions.
   int casting_session_count_ = 0;
 
+  // Weak pointer to the DBusClient PowerManagerClient for testing;
+  chromeos::PowerManagerClient* power_manager_client_for_test_ = nullptr;
+
   DISALLOW_COPY_AND_ASSIGN(ProjectingObserver);
 };
 
--- a/ash/display/projecting_observer_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/display/projecting_observer_unittest.cc	2019-05-17 18:53:08.148000000 +0300
@@ -43,25 +43,15 @@
 
 class ProjectingObserverTest : public testing::Test {
  public:
-  ProjectingObserverTest() = default;
-
-  void SetUp() override {
-    chromeos::PowerManagerClient::Initialize();
+  ProjectingObserverTest() {
     observer_ = std::make_unique<ProjectingObserver>(nullptr);
-  }
-
-  void TearDown() override {
-    observer_.reset();
-    chromeos::PowerManagerClient::Shutdown();
+    observer_->set_power_manager_client_for_test(&fake_power_client_);
   }
 
   ~ProjectingObserverTest() override = default;
 
  protected:
-  chromeos::FakePowerManagerClient* power_client() {
-    return chromeos::FakePowerManagerClient::Get();
-  }
-
+  chromeos::FakePowerManagerClient fake_power_client_;
   std::unique_ptr<ProjectingObserver> observer_;
 
  private:
@@ -72,8 +62,8 @@
   std::vector<std::unique_ptr<display::DisplaySnapshot>> displays;
   observer_->OnDisplayModeChanged(GetPointers(displays));
 
-  EXPECT_EQ(1, power_client()->num_set_is_projecting_calls());
-  EXPECT_FALSE(power_client()->is_projecting());
+  EXPECT_EQ(1, fake_power_client_.num_set_is_projecting_calls());
+  EXPECT_FALSE(fake_power_client_.is_projecting());
 }
 
 TEST_F(ProjectingObserverTest, CheckWithoutInternalDisplay) {
@@ -81,8 +71,8 @@
   displays.push_back(CreateVGASnapshot());
   observer_->OnDisplayModeChanged(GetPointers(displays));
 
-  EXPECT_EQ(1, power_client()->num_set_is_projecting_calls());
-  EXPECT_FALSE(power_client()->is_projecting());
+  EXPECT_EQ(1, fake_power_client_.num_set_is_projecting_calls());
+  EXPECT_FALSE(fake_power_client_.is_projecting());
 }
 
 TEST_F(ProjectingObserverTest, CheckWithInternalDisplay) {
@@ -90,8 +80,8 @@
   displays.push_back(CreateInternalSnapshot());
   observer_->OnDisplayModeChanged(GetPointers(displays));
 
-  EXPECT_EQ(1, power_client()->num_set_is_projecting_calls());
-  EXPECT_FALSE(power_client()->is_projecting());
+  EXPECT_EQ(1, fake_power_client_.num_set_is_projecting_calls());
+  EXPECT_FALSE(fake_power_client_.is_projecting());
 }
 
 TEST_F(ProjectingObserverTest, CheckWithTwoVGADisplays) {
@@ -100,9 +90,9 @@
   displays.push_back(CreateVGASnapshot());
   observer_->OnDisplayModeChanged(GetPointers(displays));
 
-  EXPECT_EQ(1, power_client()->num_set_is_projecting_calls());
+  EXPECT_EQ(1, fake_power_client_.num_set_is_projecting_calls());
   // We need at least 1 internal display to set projecting to on.
-  EXPECT_FALSE(power_client()->is_projecting());
+  EXPECT_FALSE(fake_power_client_.is_projecting());
 }
 
 TEST_F(ProjectingObserverTest, CheckWithInternalAndVGADisplays) {
@@ -111,8 +101,8 @@
   displays.push_back(CreateVGASnapshot());
   observer_->OnDisplayModeChanged(GetPointers(displays));
 
-  EXPECT_EQ(1, power_client()->num_set_is_projecting_calls());
-  EXPECT_TRUE(power_client()->is_projecting());
+  EXPECT_EQ(1, fake_power_client_.num_set_is_projecting_calls());
+  EXPECT_TRUE(fake_power_client_.is_projecting());
 }
 
 TEST_F(ProjectingObserverTest, CheckWithVGADisplayAndOneCastingSession) {
@@ -122,9 +112,9 @@
 
   observer_->OnCastingSessionStartedOrStopped(true);
 
-  EXPECT_EQ(2, power_client()->num_set_is_projecting_calls());
+  EXPECT_EQ(2, fake_power_client_.num_set_is_projecting_calls());
   // Need at least one internal display to set projecting state to |true|.
-  EXPECT_FALSE(power_client()->is_projecting());
+  EXPECT_FALSE(fake_power_client_.is_projecting());
 }
 
 TEST_F(ProjectingObserverTest, CheckWithInternalDisplayAndOneCastingSession) {
@@ -134,8 +124,8 @@
 
   observer_->OnCastingSessionStartedOrStopped(true);
 
-  EXPECT_EQ(2, power_client()->num_set_is_projecting_calls());
-  EXPECT_TRUE(power_client()->is_projecting());
+  EXPECT_EQ(2, fake_power_client_.num_set_is_projecting_calls());
+  EXPECT_TRUE(fake_power_client_.is_projecting());
 }
 
 TEST_F(ProjectingObserverTest, CheckProjectingAfterClosingACastingSession) {
@@ -146,13 +136,13 @@
   observer_->OnCastingSessionStartedOrStopped(true);
   observer_->OnCastingSessionStartedOrStopped(true);
 
-  EXPECT_EQ(3, power_client()->num_set_is_projecting_calls());
-  EXPECT_TRUE(power_client()->is_projecting());
+  EXPECT_EQ(3, fake_power_client_.num_set_is_projecting_calls());
+  EXPECT_TRUE(fake_power_client_.is_projecting());
 
   observer_->OnCastingSessionStartedOrStopped(false);
 
-  EXPECT_EQ(4, power_client()->num_set_is_projecting_calls());
-  EXPECT_TRUE(power_client()->is_projecting());
+  EXPECT_EQ(4, fake_power_client_.num_set_is_projecting_calls());
+  EXPECT_TRUE(fake_power_client_.is_projecting());
 }
 
 TEST_F(ProjectingObserverTest,
@@ -164,8 +154,8 @@
   observer_->OnCastingSessionStartedOrStopped(true);
   observer_->OnCastingSessionStartedOrStopped(false);
 
-  EXPECT_EQ(3, power_client()->num_set_is_projecting_calls());
-  EXPECT_FALSE(power_client()->is_projecting());
+  EXPECT_EQ(3, fake_power_client_.num_set_is_projecting_calls());
+  EXPECT_FALSE(fake_power_client_.is_projecting());
 }
 
 TEST_F(ProjectingObserverTest,
@@ -179,8 +169,8 @@
   displays.erase(displays.begin() + 1);
   observer_->OnDisplayModeChanged(GetPointers(displays));
 
-  EXPECT_EQ(2, power_client()->num_set_is_projecting_calls());
-  EXPECT_FALSE(power_client()->is_projecting());
+  EXPECT_EQ(2, fake_power_client_.num_set_is_projecting_calls());
+  EXPECT_FALSE(fake_power_client_.is_projecting());
 }
 
 }  // namespace ash
--- a/ash/display/screen_ash.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/display/screen_ash.cc	2019-05-17 18:53:08.148000000 +0300
@@ -130,13 +130,8 @@
     // Windows. Check for this first.
     aura::WindowTreeHostMus* window_tree_host_mus =
         aura::WindowTreeHostMus::ForWindow(window);
-    if (window_tree_host_mus) {
-      // WindowTreeHostMus::GetDisplay() can return an invalid display (i.e.
-      // with ID == |kInvalidDisplayID|) if that display is being removed. Use
-      // the primary display instead.
-      const auto display = window_tree_host_mus->GetDisplay();
-      return display.is_valid() ? display : GetPrimaryDisplay();
-    }
+    if (window_tree_host_mus)
+      return window_tree_host_mus->GetDisplay();
   }
 
   const aura::Window* root_window = window->GetRootWindow();
--- a/ash/display/screen_orientation_controller.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/display/screen_orientation_controller.h	2019-05-17 18:53:08.148000000 +0300
@@ -76,7 +76,7 @@
 
   OrientationLockType natural_orientation() const {
     return natural_orientation_;
-  }
+  };
 
   // Add/Remove observers.
   void AddObserver(Observer* observer);
--- a/ash/display/touch_calibrator_controller.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/display/touch_calibrator_controller.cc	2019-05-17 18:53:08.152000000 +0300
@@ -12,7 +12,6 @@
 #include "ash/host/ash_window_tree_host.h"
 #include "ash/shell.h"
 #include "ash/touch/ash_touch_transform_controller.h"
-#include "base/bind.h"
 #include "base/threading/thread_task_runner_handle.h"
 #include "ui/aura/window_tree_host.h"
 #include "ui/display/manager/touch_device_manager.h"
--- a/ash/display/window_tree_host_manager.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/display/window_tree_host_manager.cc	2019-05-17 18:53:08.152000000 +0300
@@ -112,14 +112,6 @@
   return width >= 3000 ? "1024" : "512";
 }
 
-// Returns the Shell's WindowService instance or nullptr if Shell's
-// |window_service_owner_| is not yet created.
-ws::WindowService* GetWindowService() {
-  return Shell::Get()->window_service_owner()
-             ? Shell::Get()->window_service_owner()->window_service()
-             : nullptr;
-}
-
 }  // namespace
 
 // A utility class to store/restore focused/active window
@@ -354,6 +346,85 @@
   return controllers;
 }
 
+void WindowTreeHostManager::SetPrimaryDisplayId(int64_t id) {
+  // TODO(oshima): Move primary display management to DisplayManager.
+  DCHECK_NE(display::kInvalidDisplayId, id);
+  if (id == display::kInvalidDisplayId || primary_display_id == id ||
+      window_tree_hosts_.size() < 2) {
+    return;
+  }
+
+  const display::Display& new_primary_display =
+      GetDisplayManager()->GetDisplayForId(id);
+  if (!new_primary_display.is_valid()) {
+    LOG(ERROR) << "Invalid or non-existent display is requested:"
+               << new_primary_display.ToString();
+    return;
+  }
+
+  display::DisplayManager* display_manager = GetDisplayManager();
+  DCHECK(new_primary_display.is_valid());
+  DCHECK(display_manager->GetDisplayForId(new_primary_display.id()).is_valid());
+
+  AshWindowTreeHost* non_primary_host =
+      window_tree_hosts_[new_primary_display.id()];
+  LOG_IF(ERROR, !non_primary_host)
+      << "Unknown display is requested in SetPrimaryDisplay: id="
+      << new_primary_display.id();
+  if (!non_primary_host)
+    return;
+
+  display::Display old_primary_display =
+      display::Screen::GetScreen()->GetPrimaryDisplay();
+  DCHECK_EQ(old_primary_display.id(), primary_display_id);
+
+  // Swap root windows between current and new primary display.
+  AshWindowTreeHost* primary_host = window_tree_hosts_[primary_display_id];
+  CHECK(primary_host);
+  CHECK_NE(primary_host, non_primary_host);
+
+  aura::Window* primary_window = GetWindow(primary_host);
+  aura::Window* non_primary_window = GetWindow(non_primary_host);
+  window_tree_hosts_[new_primary_display.id()] = primary_host;
+  GetRootWindowSettings(primary_window)->display_id = new_primary_display.id();
+
+  window_tree_hosts_[old_primary_display.id()] = non_primary_host;
+  GetRootWindowSettings(non_primary_window)->display_id =
+      old_primary_display.id();
+
+  base::string16 old_primary_title = primary_window->GetTitle();
+  primary_window->SetTitle(non_primary_window->GetTitle());
+  non_primary_window->SetTitle(old_primary_title);
+
+  for (auto& observer : observers_)
+    observer.OnWindowTreeHostsSwappedDisplays(primary_host, non_primary_host);
+
+  const display::DisplayLayout& layout =
+      GetDisplayManager()->GetCurrentDisplayLayout();
+  // The requested primary id can be same as one in the stored layout
+  // when the primary id is set after new displays are connected.
+  // Only update the layout if it is requested to swap primary display.
+  if (layout.primary_id != new_primary_display.id()) {
+    std::unique_ptr<display::DisplayLayout> swapped_layout = layout.Copy();
+    swapped_layout->SwapPrimaryDisplay(new_primary_display.id());
+    display::DisplayIdList list = display_manager->GetCurrentDisplayIdList();
+    GetDisplayManager()->layout_store()->RegisterLayoutForDisplayIdList(
+        list, std::move(swapped_layout));
+  }
+
+  primary_display_id = new_primary_display.id();
+
+  UpdateWorkAreaOfDisplayNearestWindow(GetWindow(primary_host),
+                                       old_primary_display.GetWorkAreaInsets());
+  UpdateWorkAreaOfDisplayNearestWindow(GetWindow(non_primary_host),
+                                       new_primary_display.GetWorkAreaInsets());
+
+  // Update the dispay manager with new display info.
+  GetDisplayManager()->set_force_bounds_changed(true);
+  GetDisplayManager()->UpdateDisplays();
+  GetDisplayManager()->set_force_bounds_changed(false);
+}
+
 void WindowTreeHostManager::UpdateMouseLocationAfterDisplayChange() {
   // If the mouse is currently on a display in native location,
   // use the same native location. Otherwise find the display closest
@@ -522,8 +593,6 @@
     GetRootWindowSettings(GetWindow(ash_host))->display_id = display.id();
     for (auto& observer : observers_)
       observer.OnWindowTreeHostReusedForDisplay(ash_host, display);
-    if (auto* window_service = GetWindowService())
-      window_service->OnWindowTreeHostsDisplayIdChanged({GetWindow(ash_host)});
     const display::ManagedDisplayInfo& display_info =
         GetDisplayManager()->GetDisplayInfo(display.id());
     ash_host->AsWindowTreeHost()->SetBoundsInPixels(
@@ -550,7 +619,6 @@
   controller->Shutdown();
   if (primary_tree_host_for_replace_ == host_to_delete)
     primary_tree_host_for_replace_ = nullptr;
-  // NOTE: ShelfWidget is gone, but Shelf still exists until this task runs.
   base::ThreadTaskRunnerHandle::Get()->DeleteSoon(FROM_HERE, controller);
 }
 
@@ -591,10 +659,6 @@
 
     for (auto& observer : observers_)
       observer.OnWindowTreeHostsSwappedDisplays(host_to_delete, primary_host);
-    if (auto* window_service = GetWindowService()) {
-      window_service->OnWindowTreeHostsDisplayIdChanged(
-          {GetWindow(host_to_delete), GetWindow(primary_host)});
-    }
 
     OnDisplayMetricsChanged(
         GetDisplayManager()->GetDisplayForId(primary_display_id),
@@ -615,14 +679,15 @@
   // Shell creates |window_service_owner_| from Shell::Init(), but this
   // function may be called before |window_service_owner_| is created. It's safe
   // to ignore the call in this case as no clients have connected yet.
-  if (auto* window_service = GetWindowService())
+  ws::WindowService* window_service =
+      Shell::Get()->window_service_owner()
+          ? Shell::Get()->window_service_owner()->window_service()
+          : nullptr;
+  if (window_service)
     window_service->OnDisplayMetricsChanged(display, metrics);
-
   if (!(metrics & (DISPLAY_METRIC_BOUNDS | DISPLAY_METRIC_ROTATION |
-                   DISPLAY_METRIC_DEVICE_SCALE_FACTOR))) {
+                   DISPLAY_METRIC_DEVICE_SCALE_FACTOR)))
     return;
-  }
-
   const display::ManagedDisplayInfo& display_info =
       GetDisplayManager()->GetDisplayInfo(display.id());
   DCHECK(!display_info.bounds_in_native().IsEmpty());
@@ -683,93 +748,23 @@
   cursor_location_in_native_coords_for_restore_ = point_in_native;
 }
 
-void WindowTreeHostManager::SetPrimaryDisplayId(int64_t id) {
-  // TODO(oshima): Move primary display management to DisplayManager.
-  DCHECK_NE(display::kInvalidDisplayId, id);
-  if (id == display::kInvalidDisplayId || primary_display_id == id ||
-      window_tree_hosts_.size() < 2) {
-    return;
-  }
-
-  const display::Display& new_primary_display =
-      GetDisplayManager()->GetDisplayForId(id);
-  if (!new_primary_display.is_valid()) {
-    LOG(ERROR) << "Invalid or non-existent display is requested:"
-               << new_primary_display.ToString();
-    return;
-  }
+void WindowTreeHostManager::PostDisplayConfigurationChange() {
+  focus_activation_store_->Restore();
 
   display::DisplayManager* display_manager = GetDisplayManager();
-  DCHECK(new_primary_display.is_valid());
-  DCHECK(display_manager->GetDisplayForId(new_primary_display.id()).is_valid());
-
-  AshWindowTreeHost* non_primary_host =
-      window_tree_hosts_[new_primary_display.id()];
-  LOG_IF(ERROR, !non_primary_host)
-      << "Unknown display is requested in SetPrimaryDisplay: id="
-      << new_primary_display.id();
-  if (!non_primary_host)
-    return;
-
-  display::Display old_primary_display =
-      display::Screen::GetScreen()->GetPrimaryDisplay();
-  DCHECK_EQ(old_primary_display.id(), primary_display_id);
-
-  // Swap root windows between current and new primary display.
-  AshWindowTreeHost* primary_host = window_tree_hosts_[primary_display_id];
-  CHECK(primary_host);
-  CHECK_NE(primary_host, non_primary_host);
-
-  aura::Window* primary_window = GetWindow(primary_host);
-  aura::Window* non_primary_window = GetWindow(non_primary_host);
-  window_tree_hosts_[new_primary_display.id()] = primary_host;
-  GetRootWindowSettings(primary_window)->display_id = new_primary_display.id();
-
-  window_tree_hosts_[old_primary_display.id()] = non_primary_host;
-  GetRootWindowSettings(non_primary_window)->display_id =
-      old_primary_display.id();
-
-  base::string16 old_primary_title = primary_window->GetTitle();
-  primary_window->SetTitle(non_primary_window->GetTitle());
-  non_primary_window->SetTitle(old_primary_title);
-
-  for (auto& observer : observers_)
-    observer.OnWindowTreeHostsSwappedDisplays(primary_host, non_primary_host);
-  if (auto* window_service = GetWindowService()) {
-    window_service->OnWindowTreeHostsDisplayIdChanged(
-        {primary_window, non_primary_window});
-  }
-
-  const display::DisplayLayout& layout =
-      GetDisplayManager()->GetCurrentDisplayLayout();
-  // The requested primary id can be same as one in the stored layout
-  // when the primary id is set after new displays are connected.
-  // Only update the layout if it is requested to swap primary display.
-  if (layout.primary_id != new_primary_display.id()) {
-    std::unique_ptr<display::DisplayLayout> swapped_layout = layout.Copy();
-    swapped_layout->SwapPrimaryDisplay(new_primary_display.id());
+  display::DisplayLayoutStore* layout_store = display_manager->layout_store();
+  if (display_manager->num_connected_displays() > 1) {
     display::DisplayIdList list = display_manager->GetCurrentDisplayIdList();
-    GetDisplayManager()->layout_store()->RegisterLayoutForDisplayIdList(
-        list, std::move(swapped_layout));
+    const display::DisplayLayout& layout =
+        layout_store->GetRegisteredDisplayLayout(list);
+    layout_store->UpdateDefaultUnified(list, layout.default_unified);
+    if (display::Screen::GetScreen()->GetNumDisplays() > 1) {
+      SetPrimaryDisplayId(layout.primary_id == display::kInvalidDisplayId
+                              ? list[0]
+                              : layout.primary_id);
+    }
   }
 
-  primary_display_id = new_primary_display.id();
-
-  UpdateWorkAreaOfDisplayNearestWindow(GetWindow(primary_host),
-                                       old_primary_display.GetWorkAreaInsets());
-  UpdateWorkAreaOfDisplayNearestWindow(GetWindow(non_primary_host),
-                                       new_primary_display.GetWorkAreaInsets());
-
-  // Update the dispay manager with new display info.
-  GetDisplayManager()->set_force_bounds_changed(true);
-  GetDisplayManager()->UpdateDisplays();
-  GetDisplayManager()->set_force_bounds_changed(false);
-}
-
-void WindowTreeHostManager::PostDisplayConfigurationChange() {
-  focus_activation_store_->Restore();
-
-  display::DisplayManager* display_manager = GetDisplayManager();
   for (const display::Display& display :
        display_manager->active_display_list()) {
     bool output_is_secure =
@@ -787,12 +782,17 @@
 
   // Enable cursor compositing, so that cursor could be mirrored to destination
   // displays along with other display content through reflector.
+  if (display_manager->is_multi_mirroring_enabled())
   Shell::Get()->UpdateCursorCompositingEnabled();
 }
 
+display::DisplayConfigurator* WindowTreeHostManager::display_configurator() {
+  return Shell::Get()->display_configurator();
+}
+
 ui::EventDispatchDetails WindowTreeHostManager::DispatchKeyEventPostIME(
     ui::KeyEvent* event,
-    DispatchKeyEventPostIMECallback callback) {
+    base::OnceCallback<void(bool)> ack_callback) {
   aura::Window* root_window = nullptr;
   if (event->target()) {
     root_window = static_cast<aura::Window*>(event->target())->GetRootWindow();
@@ -805,8 +805,8 @@
     root_window = active_window ? active_window->GetRootWindow()
                                 : Shell::GetPrimaryRootWindow();
   }
-  return root_window->GetHost()->DispatchKeyEventPostIME(event,
-                                                         std::move(callback));
+  return root_window->GetHost()->DispatchKeyEventPostIME(
+      event, std::move(ack_callback));
 }
 
 AshWindowTreeHost* WindowTreeHostManager::AddWindowTreeHostForDisplay(
--- a/ash/display/window_tree_host_manager.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/display/window_tree_host_manager.h	2019-05-17 18:53:08.152000000 +0300
@@ -132,6 +132,10 @@
   // exist.
   AshWindowTreeHost* GetAshWindowTreeHostForDisplayId(int64_t id);
 
+  // Sets the primary display by display id. This re-assigns the current primary
+  // root window host to to new primary display.
+  void SetPrimaryDisplayId(int64_t id);
+
   // Returns all root windows. In non extended desktop mode, this
   // returns the primary root window only.
   aura::Window::Windows GetAllRootWindows();
@@ -168,14 +172,14 @@
   void CreateOrUpdateMirroringDisplay(
       const display::DisplayInfoList& info_list) override;
   void CloseMirroringDisplayIfNotNecessary() override;
-  void SetPrimaryDisplayId(int64_t id) override;
   void PreDisplayConfigurationChange(bool clear_focus) override;
   void PostDisplayConfigurationChange() override;
+  display::DisplayConfigurator* display_configurator() override;
 
   // ui::internal::InputMethodDelegate overrides:
   ui::EventDispatchDetails DispatchKeyEventPostIME(
       ui::KeyEvent* event,
-      DispatchKeyEventPostIMECallback callback) override;
+      base::OnceCallback<void(bool)> ack_callback) override;
 
  private:
   FRIEND_TEST_ALL_PREFIXES(WindowTreeHostManagerTest, BoundsUpdated);
--- a/ash/display/window_tree_host_manager_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/display/window_tree_host_manager_unittest.cc	2019-05-17 18:53:08.152000000 +0300
@@ -18,11 +18,9 @@
 #include "ash/wm/cursor_manager_test_api.h"
 #include "ash/wm/window_state.h"
 #include "ash/wm/wm_event.h"
-#include "base/bind_helpers.h"
 #include "base/command_line.h"
 #include "base/run_loop.h"
 #include "base/test/scoped_feature_list.h"
-#include "services/ws/test_window_tree_client.h"
 #include "ui/aura/client/focus_change_observer.h"
 #include "ui/aura/client/focus_client.h"
 #include "ui/aura/env.h"
@@ -1087,59 +1085,6 @@
   }
 }
 
-// Tests that SetPrimaryDisplayId updates the Window Service client.
-TEST_F(WindowTreeHostManagerTest, SetPrimaryDisplayIdUpdateWSClient) {
-  // Create two displays.
-  UpdateDisplay("200x200,300x300");
-  ASSERT_EQ(2200000000, display::Screen::GetScreen()->GetPrimaryDisplay().id());
-  int64_t non_primary_display_id =
-      display_manager()->GetSecondaryDisplay().id();
-  ASSERT_EQ(2200000001, non_primary_display_id);
-
-  std::vector<ws::Change>* ws_client_changes =
-      GetTestWindowTreeClient()->tracker()->changes();
-
-  // Create the first window (0,1) on primary display 2200000000.
-  ws_client_changes->clear();
-  std::unique_ptr<aura::Window> window_in_primary =
-      CreateTestWindow(gfx::Rect(0, 0, 30, 40));
-  auto iter = FirstChangeOfType(*ws_client_changes,
-                                ws::CHANGE_TYPE_ON_TOP_LEVEL_CREATED);
-  ASSERT_NE(iter, ws_client_changes->end());
-  ASSERT_EQ(1, static_cast<int>(iter->window_id));
-  ASSERT_EQ(2200000000, iter->display_id);
-
-  // Create the second window (0,2) on non-primary display 2200000001.
-  ws_client_changes->clear();
-  std::unique_ptr<aura::Window> window_in_non_primary =
-      CreateTestWindow(gfx::Rect(300, 0, 50, 60));
-  iter = FirstChangeOfType(*ws_client_changes,
-                           ws::CHANGE_TYPE_ON_TOP_LEVEL_CREATED);
-  ASSERT_NE(iter, ws_client_changes->end());
-  ASSERT_EQ(2, static_cast<int>(iter->window_id));
-  ASSERT_EQ(2200000001, iter->display_id);
-
-  // Set primary display id to the non-primary 2200000001. This triggers
-  // swapping of WindowTreeHosts and client should receive updates about the
-  // display id change and bounds change if their screen bounds is changed..
-  ws_client_changes->clear();
-  Shell::Get()->window_tree_host_manager()->SetPrimaryDisplayId(
-      non_primary_display_id);
-  EXPECT_TRUE(
-      ContainsChange(*ws_client_changes,
-                     "DisplayChanged window_id=0,1 display_id=2200000001"));
-  EXPECT_TRUE(
-      ContainsChange(*ws_client_changes,
-                     "DisplayChanged window_id=0,2 display_id=2200000000"));
-
-  // Window (0,2) on non-primary display changes its screen bounds. But
-  // window (0,1) on the primary display does not because the primary display
-  // origin is always (0,0).
-  EXPECT_TRUE(ContainsChange(
-      *ws_client_changes,
-      "BoundsChanged window=0,2 bounds=-100,0 50x60 local_surface_id=*"));
-}
-
 TEST_F(WindowTreeHostManagerTest, OverscanInsets) {
   WindowTreeHostManager* window_tree_host_manager =
       Shell::Get()->window_tree_host_manager();
--- a/ash/drag_drop/drag_drop_controller.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/drag_drop/drag_drop_controller.cc	2019-05-17 18:53:08.152000000 +0300
@@ -376,20 +376,12 @@
     case ui::ET_SCROLL_FLING_START:
       Drop(translated_target, *translated_event.get());
       break;
-    case ui::ET_GESTURE_END:
-      // This case occurs when IsUsingWindowService() is true and the user
-      // presses, pauses, and releases a touch without any movement between.
-      // That gesture should be interpreted as a long tap and show a menu, etc.
-      // Classic Ash handles this scenario below via ET_GESTURE_LONG_TAP, while
-      // Mash handles it in DragDropControllerMus::OnPerformDragDropCompleted.
-      DoDragCancel(kTouchCancelAnimationDuration);
-      break;
     case ui::ET_GESTURE_LONG_TAP:
       // Ideally we would want to just forward this long tap event to the
       // |drag_source_window_|. However, webkit does not accept events while a
       // drag drop is still in progress. The drag drop ends only when the nested
       // message loop ends. Due to this stupidity, we have to defer forwarding
-      // the long tap. This only occurs when IsUsingWindowService() is false.
+      // the long tap.
       pending_long_tap_.reset(new ui::GestureEvent(
           *event,
           static_cast<aura::Window*>(drag_drop_tracker_->capture_window()),
@@ -524,7 +516,7 @@
     } else {
       // See comment about this in OnGestureEvent().
       base::ThreadTaskRunnerHandle::Get()->PostTask(
-          FROM_HERE, base::BindOnce(&DragDropController::ForwardPendingLongTap,
+          FROM_HERE, base::Bind(&DragDropController::ForwardPendingLongTap,
                                     weak_factory_.GetWeakPtr()));
     }
   }
--- a/ash/drag_drop/drag_drop_controller_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/drag_drop/drag_drop_controller_unittest.cc	2019-05-17 18:53:08.152000000 +0300
@@ -8,7 +8,6 @@
 #include "ash/drag_drop/drag_image_view.h"
 #include "ash/shell.h"
 #include "ash/test/ash_test_base.h"
-#include "base/bind.h"
 #include "base/command_line.h"
 #include "base/location.h"
 #include "base/run_loop.h"
--- a/ash/events/spoken_feedback_event_rewriter.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/events/spoken_feedback_event_rewriter.cc	2019-05-17 18:53:08.156000000 +0300
@@ -15,8 +15,7 @@
 
 namespace ash {
 
-SpokenFeedbackEventRewriter::SpokenFeedbackEventRewriter()
-    : continuation_(nullptr) {}
+SpokenFeedbackEventRewriter::SpokenFeedbackEventRewriter() = default;
 
 SpokenFeedbackEventRewriter::~SpokenFeedbackEventRewriter() = default;
 
@@ -28,37 +27,22 @@
 void SpokenFeedbackEventRewriter::OnUnhandledSpokenFeedbackEvent(
     std::unique_ptr<ui::Event> event) const {
   DCHECK(event->IsKeyEvent()) << "Unexpected unhandled event type";
-  // Send the event to the most recently rewritten event's continuation,
-  // (that is, through its EventSource). Under the assumption that a single
-  // SpokenFeedbackEventRewriter is not registered to multiple EventSources,
-  // this will be the same as this event's original source.
-  const char* failure_reason = nullptr;
-  if (continuation_) {
-    ui::EventDispatchDetails details = SendEvent(continuation_, event.get());
-    if (details.dispatcher_destroyed)
-      failure_reason = "destroyed dispatcher";
-    else if (details.target_destroyed)
-      failure_reason = "destroyed target";
-  } else if (continuation_.WasInvalidated()) {
-    failure_reason = "destroyed source";
-  } else {
-    failure_reason = "no prior rewrite";
-  }
-  if (failure_reason) {
+  // For now, these events are sent directly to the primary display's EventSink.
+  // TODO: Pass the event to the original EventSource, not the primary one.
+  ui::EventSource* source =
+      Shell::GetPrimaryRootWindow()->GetHost()->GetEventSource();
+  if (SendEventToEventSource(source, event.get()).dispatcher_destroyed) {
     VLOG(0) << "Undispatched key " << event->AsKeyEvent()->key_code()
-            << " due to " << failure_reason << ".";
+            << " due to destroyed dispatcher.";
   }
 }
 
-ui::EventDispatchDetails SpokenFeedbackEventRewriter::RewriteEvent(
+ui::EventRewriteStatus SpokenFeedbackEventRewriter::RewriteEvent(
     const ui::Event& event,
-    const Continuation continuation) {
-  // Save continuation for |OnUnhandledSpokenFeedbackEvent()|.
-  continuation_ = continuation;
-
+    std::unique_ptr<ui::Event>* new_event) {
   if (!delegate_.is_bound() ||
       !Shell::Get()->accessibility_controller()->spoken_feedback_enabled())
-    return SendEvent(continuation, &event);
+    return ui::EVENT_REWRITE_CONTINUE;
 
   if (event.IsKeyEvent()) {
     const ui::KeyEvent* key_event = event.AsKeyEvent();
@@ -76,15 +60,21 @@
       capture = false;
 
     delegate_->DispatchKeyEventToChromeVox(ui::Event::Clone(event), capture);
-    return capture ? DiscardEvent(continuation)
-                   : SendEvent(continuation, &event);
+    return capture ? ui::EVENT_REWRITE_DISCARD : ui::EVENT_REWRITE_CONTINUE;
   }
 
   if (send_mouse_events_ && event.IsMouseEvent()) {
     delegate_->DispatchMouseEventToChromeVox(ui::Event::Clone(event));
   }
 
-  return SendEvent(continuation, &event);
+  return ui::EVENT_REWRITE_CONTINUE;
+}
+
+ui::EventRewriteStatus SpokenFeedbackEventRewriter::NextDispatchEvent(
+    const ui::Event& last_event,
+    std::unique_ptr<ui::Event>* new_event) {
+  NOTREACHED();
+  return ui::EVENT_REWRITE_CONTINUE;
 }
 
 }  // namespace ash
--- a/ash/events/spoken_feedback_event_rewriter.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/events/spoken_feedback_event_rewriter.h	2019-05-17 18:53:08.156000000 +0300
@@ -5,8 +5,6 @@
 #ifndef ASH_EVENTS_SPOKEN_FEEDBACK_EVENT_REWRITER_H_
 #define ASH_EVENTS_SPOKEN_FEEDBACK_EVENT_REWRITER_H_
 
-#include <memory>
-
 #include "ash/ash_export.h"
 #include "ash/public/interfaces/event_rewriter_controller.mojom.h"
 #include "base/macros.h"
@@ -37,12 +35,12 @@
 
  private:
   // ui::EventRewriter:
-  ui::EventDispatchDetails RewriteEvent(
+  ui::EventRewriteStatus RewriteEvent(
       const ui::Event& event,
-      const Continuation continuation) override;
-
-  // Continuation saved for OnUnhandledSpokenFeedbackEvent().
-  Continuation continuation_;
+      std::unique_ptr<ui::Event>* new_event) override;
+  ui::EventRewriteStatus NextDispatchEvent(
+      const ui::Event& last_event,
+      std::unique_ptr<ui::Event>* new_event) override;
 
   // The delegate used to send key events to the ChromeVox extension.
   mojom::SpokenFeedbackEventRewriterDelegatePtr delegate_;
--- a/ash/events/spoken_feedback_event_rewriter_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/events/spoken_feedback_event_rewriter_unittest.cc	2019-05-17 18:53:08.156000000 +0300
@@ -19,11 +19,37 @@
 #include "ui/events/event_rewriter.h"
 #include "ui/events/keycodes/keyboard_codes.h"
 #include "ui/events/test/event_generator.h"
-#include "ui/events/test/test_event_rewriter.h"
 
 namespace ash {
 namespace {
 
+// An event rewriter that simply records all events that it receives.
+class EventRecorder : public ui::EventRewriter {
+ public:
+  EventRecorder() = default;
+  ~EventRecorder() override = default;
+
+  // ui::EventRewriter:
+  ui::EventRewriteStatus RewriteEvent(
+      const ui::Event& event,
+      std::unique_ptr<ui::Event>* new_event) override {
+    recorded_event_count_++;
+    return ui::EVENT_REWRITE_CONTINUE;
+  }
+  ui::EventRewriteStatus NextDispatchEvent(
+      const ui::Event& last_event,
+      std::unique_ptr<ui::Event>* new_event) override {
+    NOTREACHED();
+    return ui::EVENT_REWRITE_CONTINUE;
+  }
+
+  // Count of events sent to the rewriter.
+  size_t recorded_event_count_ = 0;
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(EventRecorder);
+};
+
 // A test implementation of the spoken feedback delegate interface.
 class TestDelegate : public mojom::SpokenFeedbackEventRewriterDelegate {
  public:
@@ -106,8 +132,7 @@
   void ExpectCounts(size_t expected_recorded_count,
                     size_t expected_delegate_count,
                     size_t expected_captured_count) {
-    EXPECT_EQ(expected_recorded_count,
-              static_cast<size_t>(event_recorder_.events_seen()));
+    EXPECT_EQ(expected_recorded_count, event_recorder_.recorded_event_count_);
     EXPECT_EQ(expected_delegate_count, GetDelegateRecordedEventCount());
     EXPECT_EQ(expected_captured_count, GetDelegateCapturedEventCount());
   }
@@ -118,7 +143,7 @@
   // Generates ui::Events from simulated user input.
   ui::test::EventGenerator* generator_ = nullptr;
   // Records events delivered to the next event rewriter after spoken feedback.
-  ui::test::TestEventRewriter event_recorder_;
+  EventRecorder event_recorder_;
 
   SpokenFeedbackEventRewriter spoken_feedback_event_rewriter_;
 
@@ -133,18 +158,18 @@
   EXPECT_FALSE(controller->spoken_feedback_enabled());
 
   generator_->PressKey(ui::VKEY_A, ui::EF_NONE);
-  EXPECT_EQ(1, event_recorder_.events_seen());
+  EXPECT_EQ(1U, event_recorder_.recorded_event_count_);
   EXPECT_EQ(0U, GetDelegateRecordedEventCount());
   generator_->ReleaseKey(ui::VKEY_A, ui::EF_NONE);
-  EXPECT_EQ(2, event_recorder_.events_seen());
+  EXPECT_EQ(2U, event_recorder_.recorded_event_count_);
   EXPECT_EQ(0U, GetDelegateRecordedEventCount());
 
   generator_->ClickLeftButton();
-  EXPECT_EQ(4, event_recorder_.events_seen());
+  EXPECT_EQ(4U, event_recorder_.recorded_event_count_);
   EXPECT_EQ(0U, GetDelegateRecordedEventCount());
 
   generator_->GestureTapAt(gfx::Point());
-  EXPECT_EQ(6, event_recorder_.events_seen());
+  EXPECT_EQ(6U, event_recorder_.recorded_event_count_);
   EXPECT_EQ(0U, GetDelegateRecordedEventCount());
 }
 
@@ -156,42 +181,35 @@
   EXPECT_TRUE(controller->spoken_feedback_enabled());
 
   generator_->PressKey(ui::VKEY_A, ui::EF_NONE);
-  EXPECT_EQ(1, event_recorder_.events_seen());
+  EXPECT_EQ(1U, event_recorder_.recorded_event_count_);
   EXPECT_EQ(1U, GetDelegateRecordedEventCount());
   EXPECT_EQ(0U, GetDelegateCapturedEventCount());
   generator_->ReleaseKey(ui::VKEY_A, ui::EF_NONE);
-  EXPECT_EQ(2, event_recorder_.events_seen());
+  EXPECT_EQ(2U, event_recorder_.recorded_event_count_);
   EXPECT_EQ(2U, GetDelegateRecordedEventCount());
   EXPECT_EQ(0U, GetDelegateCapturedEventCount());
 
   generator_->ClickLeftButton();
-  EXPECT_EQ(4, event_recorder_.events_seen());
+  EXPECT_EQ(4U, event_recorder_.recorded_event_count_);
   EXPECT_EQ(2U, GetDelegateRecordedEventCount());
   EXPECT_EQ(0U, GetDelegateCapturedEventCount());
 
   generator_->GestureTapAt(gfx::Point());
-  EXPECT_EQ(6, event_recorder_.events_seen());
+  EXPECT_EQ(6U, event_recorder_.recorded_event_count_);
   EXPECT_EQ(2U, GetDelegateRecordedEventCount());
   EXPECT_EQ(0U, GetDelegateCapturedEventCount());
 }
 
 // Asynchronously unhandled events should be sent to subsequent rewriters.
 TEST_F(SpokenFeedbackEventRewriterTest, UnhandledEventsSentToOtherRewriters) {
-  // Before it can forward unhandled events, SpokenFeedbackEventRewriter
-  // must have seen at least one event in the first place.
-  generator_->PressKey(ui::VKEY_A, ui::EF_NONE);
-  EXPECT_EQ(1, event_recorder_.events_seen());
-  generator_->ReleaseKey(ui::VKEY_A, ui::EF_NONE);
-  EXPECT_EQ(2, event_recorder_.events_seen());
-
   spoken_feedback_event_rewriter_.OnUnhandledSpokenFeedbackEvent(
       std::make_unique<ui::KeyEvent>(ui::ET_KEY_PRESSED, ui::VKEY_A,
                                      ui::EF_NONE));
-  EXPECT_EQ(3, event_recorder_.events_seen());
+  EXPECT_EQ(1U, event_recorder_.recorded_event_count_);
   spoken_feedback_event_rewriter_.OnUnhandledSpokenFeedbackEvent(
       std::make_unique<ui::KeyEvent>(ui::ET_KEY_RELEASED, ui::VKEY_A,
                                      ui::EF_NONE));
-  EXPECT_EQ(4, event_recorder_.events_seen());
+  EXPECT_EQ(2U, event_recorder_.recorded_event_count_);
 }
 
 TEST_F(SpokenFeedbackEventRewriterTest, KeysNotEatenWithChromeVoxDisabled) {
@@ -201,26 +219,26 @@
 
   // Send Search+Shift+Right.
   generator_->PressKey(ui::VKEY_LWIN, ui::EF_COMMAND_DOWN);
-  EXPECT_EQ(1, event_recorder_.events_seen());
+  EXPECT_EQ(1U, event_recorder_.recorded_event_count_);
   generator_->PressKey(ui::VKEY_SHIFT, ui::EF_COMMAND_DOWN | ui::EF_SHIFT_DOWN);
-  EXPECT_EQ(2, event_recorder_.events_seen());
+  EXPECT_EQ(2U, event_recorder_.recorded_event_count_);
 
   // Mock successful commands lookup and dispatch; shouldn't matter either way.
   generator_->PressKey(ui::VKEY_RIGHT, ui::EF_COMMAND_DOWN | ui::EF_SHIFT_DOWN);
-  EXPECT_EQ(3, event_recorder_.events_seen());
+  EXPECT_EQ(3U, event_recorder_.recorded_event_count_);
 
   // Released keys shouldn't get eaten.
   generator_->ReleaseKey(ui::VKEY_RIGHT,
                          ui::EF_COMMAND_DOWN | ui::EF_SHIFT_DOWN);
   generator_->ReleaseKey(ui::VKEY_SHIFT, ui::EF_COMMAND_DOWN);
   generator_->ReleaseKey(ui::VKEY_LWIN, 0);
-  EXPECT_EQ(6, event_recorder_.events_seen());
+  EXPECT_EQ(6U, event_recorder_.recorded_event_count_);
 
   // Try releasing more keys.
   generator_->ReleaseKey(ui::VKEY_RIGHT, 0);
   generator_->ReleaseKey(ui::VKEY_SHIFT, 0);
   generator_->ReleaseKey(ui::VKEY_LWIN, 0);
-  EXPECT_EQ(9, event_recorder_.events_seen());
+  EXPECT_EQ(9U, event_recorder_.recorded_event_count_);
 
   EXPECT_EQ(0U, GetDelegateRecordedEventCount());
 }
--- a/ash/extended_desktop_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/extended_desktop_unittest.cc	2019-05-17 18:53:08.156000000 +0300
@@ -732,8 +732,7 @@
 }
 
 TEST_F(ExtendedDesktopTest, OpenSystemTray) {
-  // Two displays side by side and both are high enough for tray bubble.
-  UpdateDisplay("500x600,600x700");
+  UpdateDisplay("500x600,600x400");
   ASSERT_FALSE(IsBubbleShown());
 
   ui::test::EventGenerator* event_generator = GetEventGenerator();
@@ -744,17 +743,9 @@
   event_generator->ClickLeftButton();
   EXPECT_TRUE(IsBubbleShown());
 
-  // Verifies that the bubble is within the primary display.
-  const gfx::Rect primary_display_bounds = GetPrimaryDisplay().bounds();
-  const gfx::Rect tray_bubble_bounds =
-      GetPrimaryUnifiedSystemTray()->GetBubbleBoundsInScreen();
-  EXPECT_TRUE(primary_display_bounds.Contains(tray_bubble_bounds))
-      << "primary display bounds=" << primary_display_bounds.ToString()
-      << ", tray bubble bounds=" << tray_bubble_bounds.ToString();
-
   UpdateDisplay("500x600");
   EXPECT_TRUE(IsBubbleShown());
-  UpdateDisplay("500x600,600x700");
+  UpdateDisplay("500x600,600x400");
   EXPECT_TRUE(IsBubbleShown());
 
   // Closes the tray and again makes sure that adding/removing displays doesn't
@@ -766,7 +757,7 @@
 
   UpdateDisplay("500x600");
   EXPECT_FALSE(IsBubbleShown());
-  UpdateDisplay("500x600,600x700");
+  UpdateDisplay("500x600,600x400");
   EXPECT_FALSE(IsBubbleShown());
 }
 
--- a/ash/focus_cycler.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/focus_cycler.cc	2019-05-17 18:53:08.156000000 +0300
@@ -107,7 +107,7 @@
 bool FocusCycler::FocusWidget(views::Widget* widget) {
   // If the target is PIP window, temporarily make it activatable.
   if (wm::GetWindowState(widget->GetNativeWindow())->IsPip())
-    widget->widget_delegate()->SetCanActivate(true);
+    widget->widget_delegate()->set_can_activate(true);
 
   // Note: It is not necessary to set the focus directly to the pane since that
   // will be taken care of by the widget activation.
--- a/ash/focus_cycler_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/focus_cycler_unittest.cc	2019-05-17 18:53:08.156000000 +0300
@@ -44,7 +44,7 @@
     std::copy(accessible_panes_.begin(), accessible_panes_.end(),
               std::back_inserter(*panes));
   }
-  views::Widget* GetWidget() override { return widget_; }
+  views::Widget* GetWidget() override { return widget_; };
   const views::Widget* GetWidget() const override { return widget_; }
 
  private:
--- a/ash/frame/non_client_frame_view_ash.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/frame/non_client_frame_view_ash.cc	2019-05-17 18:53:08.156000000 +0300
@@ -37,13 +37,13 @@
 #include "ui/views/widget/widget.h"
 #include "ui/views/widget/widget_delegate.h"
 
-DEFINE_UI_CLASS_PROPERTY_TYPE(ash::NonClientFrameViewAsh*)
+DEFINE_UI_CLASS_PROPERTY_TYPE(ash::NonClientFrameViewAsh*);
 
 namespace ash {
 
 DEFINE_UI_CLASS_PROPERTY_KEY(NonClientFrameViewAsh*,
                              kNonClientFrameViewAshKey,
-                             nullptr)
+                             nullptr);
 
 ///////////////////////////////////////////////////////////////////////////////
 // NonClientFrameViewAshWindowStateDelegate
@@ -257,16 +257,14 @@
     immersive_helper_ =
         std::make_unique<NonClientFrameViewAshImmersiveHelper>(frame, this);
   }
-  Shell::Get()->overview_controller()->AddObserver(this);
+  Shell::Get()->AddShellObserver(this);
   Shell::Get()->split_view_controller()->AddObserver(this);
 
   frame_window->SetProperty(kNonClientFrameViewAshKey, this);
-  wm::MakeGestureDraggableInImmersiveMode(frame_window);
 }
 
 NonClientFrameViewAsh::~NonClientFrameViewAsh() {
-  if (Shell::Get()->overview_controller())
-    Shell::Get()->overview_controller()->RemoveObserver(this);
+  Shell::Get()->RemoveShellObserver(this);
   if (Shell::Get()->split_view_controller())
     Shell::Get()->split_view_controller()->RemoveObserver(this);
 }
@@ -491,7 +489,7 @@
   UpdateHeaderView();
 }
 
-void NonClientFrameViewAsh::ShowContextMenuForViewImpl(
+void NonClientFrameViewAsh::ShowContextMenuForView(
     views::View* source,
     const gfx::Point& point,
     ui::MenuSourceType source_type) {
--- a/ash/frame/non_client_frame_view_ash.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/frame/non_client_frame_view_ash.h	2019-05-17 18:53:08.160000000 +0300
@@ -11,7 +11,7 @@
 #include "ash/frame/header_view.h"
 #include "ash/public/cpp/menu_utils.h"
 #include "ash/public/interfaces/menu.mojom.h"
-#include "ash/wm/overview/overview_observer.h"
+#include "ash/shell_observer.h"
 #include "ash/wm/splitview/split_view_controller.h"
 #include "base/macros.h"
 #include "base/optional.h"
@@ -40,7 +40,7 @@
 // the top of the screen. See also views::CustomFrameView and
 // BrowserNonClientFrameViewAsh.
 class ASH_EXPORT NonClientFrameViewAsh : public views::NonClientFrameView,
-                                         public OverviewObserver,
+                                         public ShellObserver,
                                          public SplitViewController::Observer,
                                          public views::ContextMenuController,
                                          public ui::SimpleMenuModel::Delegate {
@@ -116,7 +116,7 @@
   // header of v2 and ARC apps.
   virtual void SetShouldPaintHeader(bool paint);
 
-  // OverviewObserver:
+  // ShellObserver:
   void OnOverviewModeStarting() override;
   void OnOverviewModeEnded() override;
 
@@ -125,7 +125,7 @@
                                SplitViewController::State state) override;
 
   // views::ContextMenuController:
-  void ShowContextMenuForViewImpl(View* source,
+  void ShowContextMenuForView(View* source,
                                   const gfx::Point& point,
                                   ui::MenuSourceType source_type) override;
 
@@ -153,7 +153,6 @@
   friend class NonClientFrameViewAshSizeLock;
   friend class NonClientFrameViewAshTestWidgetDelegate;
   friend class TestWidgetConstraintsDelegate;
-  friend class WindowServiceDelegateImplTest;
 
   // views::NonClientFrameView:
   bool DoesIntersectRect(const views::View* target,
--- a/ash/frame/non_client_frame_view_ash_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/frame/non_client_frame_view_ash_unittest.cc	2019-05-17 18:53:08.160000000 +0300
@@ -904,8 +904,6 @@
 }
 
 // Run frame color tests with and without custom wm::WindowStateDelegate.
-INSTANTIATE_TEST_SUITE_P(,
-                         NonClientFrameViewAshFrameColorTest,
-                         testing::Bool());
+INSTANTIATE_TEST_CASE_P(, NonClientFrameViewAshFrameColorTest, testing::Bool());
 
 }  // namespace ash
--- a/ash/frame/wide_frame_view.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/frame/wide_frame_view.cc	2019-05-17 18:53:08.160000000 +0300
@@ -9,8 +9,6 @@
 #include "ash/public/cpp/caption_buttons/frame_caption_button_container_view.h"
 #include "ash/public/cpp/immersive/immersive_fullscreen_controller.h"
 #include "ash/public/cpp/window_properties.h"
-#include "ash/shell.h"
-#include "ash/wm/overview/overview_controller.h"
 #include "ash/wm/window_state.h"
 #include "ash/wm/wm_event.h"
 #include "base/metrics/user_metrics.h"
@@ -84,7 +82,7 @@
 
 WideFrameView::WideFrameView(views::Widget* target)
     : target_(target), widget_(std::make_unique<views::Widget>()) {
-  Shell::Get()->overview_controller()->AddObserver(this);
+  Shell::Get()->AddShellObserver(this);
   display::Screen::GetScreen()->AddObserver(this);
 
   aura::Window* target_window = target->GetNativeWindow();
@@ -112,8 +110,7 @@
 WideFrameView::~WideFrameView() {
   if (widget_)
     widget_->CloseNow();
-  if (Shell::Get()->overview_controller())
-    Shell::Get()->overview_controller()->RemoveObserver(this);
+  Shell::Get()->RemoveShellObserver(this);
   display::Screen::GetScreen()->RemoveObserver(this);
   if (target_) {
     GetTargetHeaderView()->SetShouldPaintHeader(true);
--- a/ash/frame/wide_frame_view.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/frame/wide_frame_view.h	2019-05-17 18:53:08.160000000 +0300
@@ -8,7 +8,8 @@
 #include "ash/ash_export.h"
 #include "ash/public/cpp/caption_buttons/caption_button_model.h"
 #include "ash/public/cpp/immersive/immersive_fullscreen_controller_delegate.h"
-#include "ash/wm/overview/overview_observer.h"
+#include "ash/shell.h"
+#include "ash/shell_observer.h"
 #include "ui/aura/window_observer.h"
 #include "ui/display/display_observer.h"
 #include "ui/views/widget/widget_delegate.h"
@@ -36,7 +37,7 @@
       public aura::WindowObserver,
       public display::DisplayObserver,
       public ash::ImmersiveFullscreenControllerDelegate,
-      public OverviewObserver {
+      public ash::ShellObserver {
  public:
   explicit WideFrameView(views::Widget* target);
   ~WideFrameView() override;
@@ -75,7 +76,7 @@
   void SetVisibleFraction(double visible_fraction) override;
   std::vector<gfx::Rect> GetVisibleBoundsInScreen() const override;
 
-  // OverviewObserver:
+  // ash::ShellObserver:
   void OnOverviewModeStarting() override;
   void OnOverviewModeEnded() override;
 
--- a/ash/highlighter/highlighter_controller.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/highlighter/highlighter_controller.cc	2019-05-17 18:53:08.160000000 +0300
@@ -15,9 +15,7 @@
 #include "ash/shell.h"
 #include "ash/shell_state.h"
 #include "ash/system/palette/palette_utils.h"
-#include "base/bind.h"
 #include "base/metrics/histogram_macros.h"
-#include "base/timer/timer.h"
 #include "chromeos/constants/chromeos_switches.h"
 #include "ui/aura/window.h"
 #include "ui/aura/window_tree_host.h"
--- a/ash/highlighter/highlighter_controller_test_api.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/highlighter/highlighter_controller_test_api.cc	2019-05-17 18:53:08.160000000 +0300
@@ -7,7 +7,6 @@
 #include "ash/components/fast_ink/fast_ink_points.h"
 #include "ash/highlighter/highlighter_controller.h"
 #include "ash/highlighter/highlighter_view.h"
-#include "base/timer/timer.h"
 
 namespace ash {
 
--- a/ash/highlighter/highlighter_result_view.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/highlighter/highlighter_result_view.cc	2019-05-17 18:53:08.160000000 +0300
@@ -10,8 +10,6 @@
 #include "ash/highlighter/highlighter_view.h"
 #include "ash/public/cpp/shell_window_ids.h"
 #include "ash/shell.h"
-#include "base/bind.h"
-#include "base/timer/timer.h"
 #include "ui/compositor/paint_recorder.h"
 #include "ui/compositor/scoped_layer_animation_settings.h"
 #include "ui/gfx/geometry/rect_conversions.h"
--- a/ash/highlighter/highlighter_result_view.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/highlighter/highlighter_result_view.h	2019-05-17 18:53:08.160000000 +0300
@@ -15,10 +15,6 @@
 class Window;
 }
 
-namespace base {
-class OneShotTimer;
-}
-
 namespace ui {
 class Layer;
 }
--- a/ash/highlighter/highlighter_view.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/highlighter/highlighter_view.cc	2019-05-17 18:53:08.160000000 +0300
@@ -7,9 +7,7 @@
 #include <memory>
 
 #include "ash/highlighter/highlighter_gesture_util.h"
-#include "base/bind.h"
 #include "base/threading/thread_task_runner_handle.h"
-#include "base/timer/timer.h"
 #include "third_party/skia/include/core/SkColor.h"
 #include "third_party/skia/include/core/SkTypes.h"
 #include "ui/aura/window.h"
--- a/ash/highlighter/highlighter_view.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/highlighter/highlighter_view.h	2019-05-17 18:53:08.160000000 +0300
@@ -15,10 +15,6 @@
 class Window;
 }
 
-namespace base {
-class OneShotTimer;
-}
-
 namespace gfx {
 class PointF;
 }
--- a/ash/ime/ime_controller.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/ime/ime_controller.cc	2019-05-17 18:53:08.160000000 +0300
@@ -8,7 +8,6 @@
 #include "ash/ime/mode_indicator_observer.h"
 #include "ash/shell.h"
 #include "ash/system/tray/system_tray_notifier.h"
-#include "base/bind_helpers.h"
 #include "ui/base/accelerators/accelerator.h"
 #include "ui/base/ime/chromeos/extension_ime_util.h"
 #include "ui/display/manager/display_manager.h"
--- a/ash/ime/ime_mode_indicator_view.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/ime/ime_mode_indicator_view.cc	2019-05-17 18:53:08.164000000 +0300
@@ -51,7 +51,7 @@
 ImeModeIndicatorView::ImeModeIndicatorView(const gfx::Rect& cursor_bounds,
                                            const base::string16& label)
     : cursor_bounds_(cursor_bounds), label_view_(new views::Label(label)) {
-  SetCanActivate(false);
+  set_can_activate(false);
   set_accept_events(false);
   set_shadow(views::BubbleBorder::BIG_SHADOW);
   SetArrow(views::BubbleBorder::TOP_CENTER);
--- a/ash/keyboard/ash_keyboard_controller.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/keyboard/ash_keyboard_controller.cc	2019-05-17 18:53:08.164000000 +0300
@@ -10,12 +10,10 @@
 #include "ash/session/session_controller.h"
 #include "ash/shell.h"
 #include "ash/shell_delegate.h"
-#include "base/command_line.h"
 #include "ui/base/ui_base_features.h"
 #include "ui/gfx/geometry/rect.h"
 #include "ui/keyboard/keyboard_controller.h"
 #include "ui/keyboard/keyboard_ui_factory.h"
-#include "ui/keyboard/public/keyboard_switches.h"
 #include "ui/wm/core/coordinate_conversion.h"
 
 using keyboard::mojom::KeyboardConfig;
@@ -55,6 +53,10 @@
       keyboard_ui_factory_ ? keyboard_ui_factory_->CreateKeyboardUI()
                            : std::make_unique<AshKeyboardUI>(this),
       virtual_keyboard_controller_.get());
+
+  // Start preloading the virtual keyboard UI in the background, so that it
+  // shows up faster when needed.
+  keyboard_controller_->LoadKeyboardWindowInBackground();
 }
 
 void AshKeyboardController::DisableKeyboard() {
@@ -67,12 +69,6 @@
       << "keyboard_ui_factory can be null only when window service is used.";
   keyboard_ui_factory_ = std::move(keyboard_ui_factory);
   virtual_keyboard_controller_ = std::make_unique<VirtualKeyboardController>();
-
-  if (base::CommandLine::ForCurrentProcess()->HasSwitch(
-          keyboard::switches::kEnableVirtualKeyboard)) {
-    keyboard_controller_->SetEnableFlag(
-        KeyboardEnableFlag::kCommandLineEnabled);
-  }
 }
 
 void AshKeyboardController::DestroyVirtualKeyboard() {
@@ -80,9 +76,10 @@
 }
 
 void AshKeyboardController::SendOnKeyboardVisibleBoundsChanged(
-    const gfx::Rect& screen_bounds) {
-  DVLOG(1) << "OnKeyboardVisibleBoundsChanged: " << screen_bounds.ToString();
+    const gfx::Rect& bounds) {
+  DVLOG(1) << "OnKeyboardVisibleBoundsChanged: " << bounds.ToString();
   // Pass the bounds in screen coordinates over mojo.
+  gfx::Rect screen_bounds = BoundsToScreen(bounds);
   observers_.ForAllPtrs(
       [&screen_bounds](mojom::KeyboardControllerObserver* observer) {
         observer->OnKeyboardVisibleBoundsChanged(screen_bounds);
@@ -273,14 +270,15 @@
 }
 
 void AshKeyboardController::OnKeyboardVisibleBoundsChanged(
-    const gfx::Rect& screen_bounds) {
-  SendOnKeyboardVisibleBoundsChanged(screen_bounds);
+    const gfx::Rect& bounds) {
+  SendOnKeyboardVisibleBoundsChanged(bounds);
 }
 
 void AshKeyboardController::OnKeyboardWorkspaceOccludedBoundsChanged(
-    const gfx::Rect& screen_bounds) {
-  DVLOG(1) << "OnKeyboardOccludedBoundsChanged: " << screen_bounds.ToString();
+    const gfx::Rect& bounds) {
+  DVLOG(1) << "OnKeyboardOccludedBoundsChanged: " << bounds.ToString();
   // Pass the bounds in screen coordinates over mojo.
+  gfx::Rect screen_bounds = BoundsToScreen(bounds);
   observers_.ForAllPtrs(
       [&screen_bounds](mojom::KeyboardControllerObserver* observer) {
         observer->OnKeyboardOccludedBoundsChanged(screen_bounds);
@@ -303,4 +301,12 @@
       });
 }
 
+gfx::Rect AshKeyboardController::BoundsToScreen(const gfx::Rect& bounds) {
+  DCHECK(keyboard_controller_->GetKeyboardWindow());
+  gfx::Rect screen_bounds(bounds);
+  ::wm::ConvertRectToScreen(keyboard_controller_->GetKeyboardWindow(),
+                            &screen_bounds);
+  return screen_bounds;
+}
+
 }  // namespace ash
--- a/ash/keyboard/ash_keyboard_controller.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/keyboard/ash_keyboard_controller.h	2019-05-17 18:53:08.164000000 +0300
@@ -60,7 +60,7 @@
   void DestroyVirtualKeyboard();
 
   // Forwards events to mojo observers.
-  void SendOnKeyboardVisibleBoundsChanged(const gfx::Rect& screen_bounds);
+  void SendOnKeyboardVisibleBoundsChanged(const gfx::Rect& bounds);
   void SendOnLoadKeyboardContentsRequested();
   void SendOnKeyboardUIDestroyed();
 
@@ -113,14 +113,16 @@
   // keyboard::KeyboardControllerObserver
   void OnKeyboardConfigChanged() override;
   void OnKeyboardVisibilityStateChanged(bool is_visible) override;
-  void OnKeyboardVisibleBoundsChanged(const gfx::Rect& screen_bounds) override;
+  void OnKeyboardVisibleBoundsChanged(const gfx::Rect& bounds) override;
   void OnKeyboardWorkspaceOccludedBoundsChanged(
-      const gfx::Rect& screen_bounds) override;
+      const gfx::Rect& bounds) override;
   void OnKeyboardEnableFlagsChanged(
       std::set<keyboard::mojom::KeyboardEnableFlag>& keyboard_enable_flags)
       override;
   void OnKeyboardEnabledChanged(bool is_enabled) override;
 
+  gfx::Rect BoundsToScreen(const gfx::Rect& bounds);
+
   SessionController* session_controller_;  // unowned
   std::unique_ptr<keyboard::KeyboardUIFactory> keyboard_ui_factory_;
   std::unique_ptr<keyboard::KeyboardController> keyboard_controller_;
--- a/ash/keyboard/ash_keyboard_controller_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/keyboard/ash_keyboard_controller_unittest.cc	2019-05-17 18:53:08.164000000 +0300
@@ -12,7 +12,6 @@
 #include "ash/shell.h"
 #include "ash/test/ash_test_base.h"
 #include "ash/test/ash_test_helper.h"
-#include "base/bind.h"
 #include "base/run_loop.h"
 #include "base/stl_util.h"
 #include "base/test/scoped_task_environment.h"
@@ -161,7 +160,7 @@
 
 class TestContainerBehavior : public keyboard::ContainerBehavior {
  public:
-  TestContainerBehavior() : keyboard::ContainerBehavior(nullptr) {}
+  TestContainerBehavior() : keyboard::ContainerBehavior(nullptr){};
   ~TestContainerBehavior() override = default;
 
   // keyboard::ContainerBehavior
--- a/ash/keyboard/virtual_keyboard_controller.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/keyboard/virtual_keyboard_controller.cc	2019-05-17 18:53:08.164000000 +0300
@@ -16,8 +16,6 @@
 #include "ash/system/tray/system_tray_notifier.h"
 #include "ash/wm/tablet_mode/tablet_mode_controller.h"
 #include "ash/wm/window_util.h"
-#include "base/bind.h"
-#include "base/bind_helpers.h"
 #include "base/command_line.h"
 #include "base/strings/string_util.h"
 #include "ui/base/emoji/emoji_panel_helper.h"
--- a/ash/keyboard/virtual_keyboard_controller_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/keyboard/virtual_keyboard_controller_unittest.cc	2019-05-17 18:53:08.164000000 +0300
@@ -43,6 +43,21 @@
   VirtualKeyboardControllerTest() = default;
   ~VirtualKeyboardControllerTest() override = default;
 
+  void SetUp() override {
+    AshTestBase::SetUp();
+    ws::InputDeviceClientTestApi().SetKeyboardDevices({});
+    ws::InputDeviceClientTestApi().SetTouchscreenDevices({});
+    keyboard_controller_ = keyboard::KeyboardController::Get();
+  }
+
+  void TearDown() override {
+    // Ensure inputs devices are reset for the next test.
+    ws::InputDeviceClientTestApi().SetKeyboardDevices({});
+    ws::InputDeviceClientTestApi().SetTouchscreenDevices({});
+
+    AshTestBase::TearDown();
+  }
+
   display::Display GetPrimaryDisplay() {
     return display::Screen::GetScreen()->GetPrimaryDisplay();
   }
@@ -66,9 +81,7 @@
     focusable_window->Focus();
   }
 
-  keyboard::KeyboardController* keyboard_controller() {
-    return keyboard::KeyboardController::Get();
-  }
+  keyboard::KeyboardController* keyboard_controller_ = nullptr;
 
  private:
   DISALLOW_COPY_AND_ASSIGN(VirtualKeyboardControllerTest);
@@ -123,7 +136,7 @@
             client.last_keyset_);
 
   // Simulate the keyboard hiding.
-  if (keyboard_controller()->HasObserver(GetVirtualKeyboardController())) {
+  if (keyboard_controller_->HasObserver(GetVirtualKeyboardController())) {
     GetVirtualKeyboardController()->OnKeyboardHidden(
         false /* is_temporary_hide */);
   }
@@ -148,33 +161,33 @@
   Shell::Get()->ime_controller()->SetClient(client.CreateInterfacePtr());
 
   // Should show the keyboard by enabling it temporarily.
-  EXPECT_FALSE(keyboard_controller()->IsKeyboardEnableRequested());
-  EXPECT_FALSE(keyboard_controller()->IsEnableFlagSet(
-      KeyboardEnableFlag::kShelfEnabled));
+  EXPECT_FALSE(keyboard_controller_->IsKeyboardEnableRequested());
+  EXPECT_FALSE(
+      keyboard_controller_->IsEnableFlagSet(KeyboardEnableFlag::kShelfEnabled));
 
   GetVirtualKeyboardController()->ForceShowKeyboardWithKeyset(
       chromeos::input_method::mojom::ImeKeyset::kEmoji);
   Shell::Get()->ime_controller()->FlushMojoForTesting();
 
-  EXPECT_TRUE(keyboard_controller()->IsEnableFlagSet(
-      KeyboardEnableFlag::kShelfEnabled));
-  EXPECT_TRUE(keyboard_controller()->IsKeyboardEnableRequested());
+  EXPECT_TRUE(
+      keyboard_controller_->IsEnableFlagSet(KeyboardEnableFlag::kShelfEnabled));
+  EXPECT_TRUE(keyboard_controller_->IsKeyboardEnableRequested());
 
   // Keyset should be emoji.
   EXPECT_EQ(chromeos::input_method::mojom::ImeKeyset::kEmoji,
             client.last_keyset_);
 
   // Simulate the keyboard hiding.
-  if (keyboard_controller()->HasObserver(GetVirtualKeyboardController())) {
+  if (keyboard_controller_->HasObserver(GetVirtualKeyboardController())) {
     GetVirtualKeyboardController()->OnKeyboardHidden(
         false /* is_temporary_hide */);
   }
   base::RunLoop().RunUntilIdle();
 
   // The keyboard should still be disabled again.
-  EXPECT_FALSE(keyboard_controller()->IsKeyboardEnableRequested());
-  EXPECT_FALSE(keyboard_controller()->IsEnableFlagSet(
-      KeyboardEnableFlag::kShelfEnabled));
+  EXPECT_FALSE(keyboard_controller_->IsKeyboardEnableRequested());
+  EXPECT_FALSE(
+      keyboard_controller_->IsEnableFlagSet(KeyboardEnableFlag::kShelfEnabled));
 
   // Keyset should be reset to none.
   Shell::Get()->ime_controller()->FlushMojoForTesting();
@@ -193,25 +206,25 @@
       chromeos::input_method::mojom::ImeKeyset::kEmoji);
   Shell::Get()->ime_controller()->FlushMojoForTesting();
 
-  EXPECT_TRUE(keyboard_controller()->IsEnableFlagSet(
-      KeyboardEnableFlag::kShelfEnabled));
-  EXPECT_TRUE(keyboard_controller()->IsKeyboardEnableRequested());
+  EXPECT_TRUE(
+      keyboard_controller_->IsEnableFlagSet(KeyboardEnableFlag::kShelfEnabled));
+  EXPECT_TRUE(keyboard_controller_->IsKeyboardEnableRequested());
 
   // Keyset should be emoji.
   EXPECT_EQ(chromeos::input_method::mojom::ImeKeyset::kEmoji,
             client.last_keyset_);
 
   // Simulate the keyboard hiding temporarily.
-  if (keyboard_controller()->HasObserver(GetVirtualKeyboardController())) {
+  if (keyboard_controller_->HasObserver(GetVirtualKeyboardController())) {
     GetVirtualKeyboardController()->OnKeyboardHidden(
         true /* is_temporary_hide */);
   }
   base::RunLoop().RunUntilIdle();
 
   // The keyboard should still be enabled.
-  EXPECT_TRUE(keyboard_controller()->IsEnableFlagSet(
-      KeyboardEnableFlag::kShelfEnabled));
-  EXPECT_TRUE(keyboard_controller()->IsKeyboardEnableRequested());
+  EXPECT_TRUE(
+      keyboard_controller_->IsEnableFlagSet(KeyboardEnableFlag::kShelfEnabled));
+  EXPECT_TRUE(keyboard_controller_->IsKeyboardEnableRequested());
 
   // Keyset should still be emoji.
   EXPECT_EQ(chromeos::input_method::mojom::ImeKeyset::kEmoji,
@@ -270,13 +283,13 @@
   keyboard_devices.push_back(ui::InputDevice(
       1, ui::InputDeviceType::INPUT_DEVICE_INTERNAL, "keyboard"));
   ws::InputDeviceClientTestApi().SetKeyboardDevices(keyboard_devices);
-  ASSERT_FALSE(keyboard_controller()->IsKeyboardEnableRequested());
+  ASSERT_FALSE(keyboard_controller_->IsKeyboardEnableRequested());
   // Remove the internal keyboard. Virtual keyboard should now show.
   ws::InputDeviceClientTestApi().SetKeyboardDevices({});
-  EXPECT_TRUE(keyboard_controller()->IsKeyboardEnableRequested());
+  EXPECT_TRUE(keyboard_controller_->IsKeyboardEnableRequested());
   // Replug in the internal keyboard. Virtual keyboard should hide.
   ws::InputDeviceClientTestApi().SetKeyboardDevices(keyboard_devices);
-  EXPECT_FALSE(keyboard_controller()->IsKeyboardEnableRequested());
+  EXPECT_FALSE(keyboard_controller_->IsKeyboardEnableRequested());
 }
 
 TEST_F(VirtualKeyboardControllerAutoTest, DisabledIfNoTouchScreen) {
@@ -286,10 +299,10 @@
       ui::TouchscreenDevice(1, ui::InputDeviceType::INPUT_DEVICE_USB,
                             "Touchscreen", gfx::Size(800, 600), 0));
   ws::InputDeviceClientTestApi().SetTouchscreenDevices(devices);
-  EXPECT_TRUE(keyboard_controller()->IsKeyboardEnableRequested());
+  EXPECT_TRUE(keyboard_controller_->IsKeyboardEnableRequested());
   // Remove touchscreen. Keyboard should hide.
   ws::InputDeviceClientTestApi().SetTouchscreenDevices({});
-  EXPECT_FALSE(keyboard_controller()->IsKeyboardEnableRequested());
+  EXPECT_FALSE(keyboard_controller_->IsKeyboardEnableRequested());
 }
 
 TEST_F(VirtualKeyboardControllerAutoTest, SuppressedIfExternalKeyboardPresent) {
@@ -302,26 +315,26 @@
   keyboard_devices.push_back(
       ui::InputDevice(1, ui::InputDeviceType::INPUT_DEVICE_USB, "keyboard"));
   ws::InputDeviceClientTestApi().SetKeyboardDevices(keyboard_devices);
-  ASSERT_FALSE(keyboard_controller()->IsKeyboardEnableRequested());
+  ASSERT_FALSE(keyboard_controller_->IsKeyboardEnableRequested());
   ASSERT_TRUE(notified());
   ASSERT_TRUE(IsVirtualKeyboardSuppressed());
   // Toggle show keyboard. Keyboard should be visible.
   ResetObserver();
   GetVirtualKeyboardController()->ToggleIgnoreExternalKeyboard();
-  ASSERT_TRUE(keyboard_controller()->IsKeyboardEnableRequested());
+  ASSERT_TRUE(keyboard_controller_->IsKeyboardEnableRequested());
   ASSERT_TRUE(notified());
   ASSERT_TRUE(IsVirtualKeyboardSuppressed());
   // Toggle show keyboard. Keyboard should be hidden.
   ResetObserver();
   GetVirtualKeyboardController()->ToggleIgnoreExternalKeyboard();
-  ASSERT_FALSE(keyboard_controller()->IsKeyboardEnableRequested());
+  ASSERT_FALSE(keyboard_controller_->IsKeyboardEnableRequested());
   ASSERT_TRUE(notified());
   ASSERT_TRUE(IsVirtualKeyboardSuppressed());
   // Remove external keyboard. Should be notified that the keyboard is not
   // suppressed.
   ResetObserver();
   ws::InputDeviceClientTestApi().SetKeyboardDevices({});
-  ASSERT_TRUE(keyboard_controller()->IsKeyboardEnableRequested());
+  ASSERT_TRUE(keyboard_controller_->IsKeyboardEnableRequested());
   ASSERT_TRUE(notified());
   ASSERT_FALSE(IsVirtualKeyboardSuppressed());
 }
@@ -336,7 +349,7 @@
   keyboards.push_back(
       ui::InputDevice(3, ui::InputDeviceType::INPUT_DEVICE_USB, "keyboard"));
   ws::InputDeviceClientTestApi().SetKeyboardDevices(keyboards);
-  ASSERT_FALSE(keyboard_controller()->IsKeyboardEnableRequested());
+  ASSERT_FALSE(keyboard_controller_->IsKeyboardEnableRequested());
 }
 
 // Tests tablet mode interaction without disabling the internal keyboard.
@@ -350,13 +363,13 @@
   keyboard_devices.push_back(ui::InputDevice(
       1, ui::InputDeviceType::INPUT_DEVICE_INTERNAL, "Keyboard"));
   ws::InputDeviceClientTestApi().SetKeyboardDevices(keyboard_devices);
-  ASSERT_FALSE(keyboard_controller()->IsKeyboardEnableRequested());
+  ASSERT_FALSE(keyboard_controller_->IsKeyboardEnableRequested());
   // Toggle tablet mode on.
   TabletModeControllerTestApi().EnterTabletMode();
-  ASSERT_TRUE(keyboard_controller()->IsKeyboardEnableRequested());
+  ASSERT_TRUE(keyboard_controller_->IsKeyboardEnableRequested());
   // Toggle tablet mode off.
   TabletModeControllerTestApi().LeaveTabletMode();
-  ASSERT_FALSE(keyboard_controller()->IsKeyboardEnableRequested());
+  ASSERT_FALSE(keyboard_controller_->IsKeyboardEnableRequested());
 }
 
 // Tests that keyboard gets suppressed in tablet mode.
@@ -374,19 +387,19 @@
   ws::InputDeviceClientTestApi().SetKeyboardDevices(keyboard_devices);
   // Toggle tablet mode on.
   TabletModeControllerTestApi().EnterTabletMode();
-  ASSERT_FALSE(keyboard_controller()->IsKeyboardEnableRequested());
+  ASSERT_FALSE(keyboard_controller_->IsKeyboardEnableRequested());
   ASSERT_TRUE(notified());
   ASSERT_TRUE(IsVirtualKeyboardSuppressed());
   // Toggle show keyboard. Keyboard should be visible.
   ResetObserver();
   GetVirtualKeyboardController()->ToggleIgnoreExternalKeyboard();
-  ASSERT_TRUE(keyboard_controller()->IsKeyboardEnableRequested());
+  ASSERT_TRUE(keyboard_controller_->IsKeyboardEnableRequested());
   ASSERT_TRUE(notified());
   ASSERT_TRUE(IsVirtualKeyboardSuppressed());
   // Toggle show keyboard. Keyboard should be hidden.
   ResetObserver();
   GetVirtualKeyboardController()->ToggleIgnoreExternalKeyboard();
-  ASSERT_FALSE(keyboard_controller()->IsKeyboardEnableRequested());
+  ASSERT_FALSE(keyboard_controller_->IsKeyboardEnableRequested());
   ASSERT_TRUE(notified());
   ASSERT_TRUE(IsVirtualKeyboardSuppressed());
   // Remove external keyboard. Should be notified that the keyboard is not
@@ -394,12 +407,12 @@
   ResetObserver();
   keyboard_devices.pop_back();
   ws::InputDeviceClientTestApi().SetKeyboardDevices(keyboard_devices);
-  ASSERT_TRUE(keyboard_controller()->IsKeyboardEnableRequested());
+  ASSERT_TRUE(keyboard_controller_->IsKeyboardEnableRequested());
   ASSERT_TRUE(notified());
   ASSERT_FALSE(IsVirtualKeyboardSuppressed());
   // Toggle tablet mode oFF.
   TabletModeControllerTestApi().LeaveTabletMode();
-  ASSERT_FALSE(keyboard_controller()->IsKeyboardEnableRequested());
+  ASSERT_FALSE(keyboard_controller_->IsKeyboardEnableRequested());
 }
 
 class VirtualKeyboardControllerAlwaysEnabledTest
@@ -431,7 +444,7 @@
   keyboard_devices.push_back(
       ui::InputDevice(1, ui::InputDeviceType::INPUT_DEVICE_USB, "keyboard"));
   ws::InputDeviceClientTestApi().SetKeyboardDevices(keyboard_devices);
-  ASSERT_TRUE(keyboard_controller()->IsKeyboardEnableRequested());
+  ASSERT_TRUE(keyboard_controller_->IsKeyboardEnableRequested());
 }
 
 // Test for http://crbug.com/297858. |GetContainerForDefaultDisplay| should
@@ -580,11 +593,16 @@
        ShowKeyboardInSecondaryDisplay) {
   UpdateDisplay("500x500,500x500");
 
+  // Load in the primary display.
+  keyboard_controller_->LoadKeyboardWindowInBackground();
+  // Wait for the keyboard window to load.
+  base::RunLoop().RunUntilIdle();
+
   // Show in secondary display.
-  keyboard_controller()->ShowKeyboardInDisplay(GetSecondaryDisplay());
-  EXPECT_EQ(GetSecondaryRootWindow(), keyboard_controller()->GetRootWindow());
+  keyboard_controller_->ShowKeyboardInDisplay(GetSecondaryDisplay());
+  EXPECT_EQ(GetSecondaryRootWindow(), keyboard_controller_->GetRootWindow());
   ASSERT_TRUE(keyboard::WaitUntilShown());
-  EXPECT_TRUE(!keyboard_controller()->GetKeyboardWindow()->bounds().IsEmpty());
+  EXPECT_TRUE(!keyboard_controller_->GetKeyboardWindow()->bounds().IsEmpty());
 }
 
 }  // namespace ash
--- a/ash/keyboard/virtual_keyboard_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/keyboard/virtual_keyboard_unittest.cc	2019-05-17 18:53:08.164000000 +0300
@@ -4,7 +4,6 @@
 
 #include "ash/shell.h"
 #include "ash/test/ash_test_base.h"
-#include "base/bind_helpers.h"
 #include "base/command_line.h"
 #include "ui/aura/test/test_window_delegate.h"
 #include "ui/events/test/event_generator.h"
--- a/ash/laser/laser_pointer_controller.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/laser/laser_pointer_controller.cc	2019-05-17 18:53:08.164000000 +0300
@@ -10,7 +10,6 @@
 #include "ash/public/cpp/shell_window_ids.h"
 #include "ash/shell.h"
 #include "ash/system/palette/palette_utils.h"
-#include "base/bind.h"
 #include "ui/display/screen.h"
 #include "ui/events/base_event_utils.h"
 #include "ui/views/widget/widget.h"
--- a/ash/laser/laser_pointer_view.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/laser/laser_pointer_view.cc	2019-05-17 18:53:08.168000000 +0300
@@ -5,7 +5,6 @@
 #include "ash/laser/laser_pointer_view.h"
 
 #include "ash/laser/laser_segment_utils.h"
-#include "base/bind.h"
 #include "base/threading/thread_task_runner_handle.h"
 #include "third_party/skia/include/core/SkColor.h"
 #include "third_party/skia/include/core/SkTypes.h"
--- a/ash/lock_screen_action/lock_screen_note_display_state_handler_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/lock_screen_action/lock_screen_note_display_state_handler_unittest.cc	2019-05-17 18:53:08.168000000 +0300
@@ -18,10 +18,10 @@
 #include "ash/tray_action/test_tray_action_client.h"
 #include "ash/tray_action/tray_action.h"
 #include "ash/wm/tablet_mode/tablet_mode_controller.h"
-#include "base/bind.h"
 #include "base/command_line.h"
 #include "base/run_loop.h"
 #include "base/test/simple_test_tick_clock.h"
+#include "chromeos/dbus/dbus_thread_manager.h"
 #include "chromeos/dbus/fake_power_manager_client.h"
 #include "chromeos/dbus/power_manager/backlight.pb.h"
 #include "services/ws/public/cpp/input_devices/input_device_client_test_api.h"
@@ -35,8 +35,9 @@
 
 class TestPowerManagerObserver : public chromeos::PowerManagerClient::Observer {
  public:
-  TestPowerManagerObserver()
-      : power_manager_(chromeos::FakePowerManagerClient::Get()) {
+  explicit TestPowerManagerObserver(
+      chromeos::FakePowerManagerClient* power_manager)
+      : power_manager_(power_manager), scoped_observer_(this) {
     scoped_observer_.Add(power_manager_);
     power_manager_->set_user_activity_callback(base::BindRepeating(
         &TestPowerManagerObserver::OnUserActivity, base::Unretained(this)));
@@ -70,7 +71,7 @@
 
   ScopedObserver<chromeos::PowerManagerClient,
                  chromeos::PowerManagerClient::Observer>
-      scoped_observer_{this};
+      scoped_observer_;
 
   DISALLOW_COPY_AND_ASSIGN(TestPowerManagerObserver);
 };
@@ -87,13 +88,20 @@
     base::CommandLine::ForCurrentProcess()->AppendSwitch(
         switches::kAshEnableTabletMode);
 
-    AshTestBase::SetUp();
+    auto power_manager_client =
+        std::make_unique<chromeos::FakePowerManagerClient>();
+    power_manager_client_ = power_manager_client.get();
 
     power_manager::SetBacklightBrightnessRequest request;
     request.set_percent(kVisibleBrightnessPercent);
-    power_manager_client()->SetScreenBrightness(request);
+    power_manager_client_->SetScreenBrightness(request);
+
+    power_manager_observer_ =
+        std::make_unique<TestPowerManagerObserver>(power_manager_client_);
+    chromeos::DBusThreadManager::GetSetterForTesting()->SetPowerManagerClient(
+        std::move(power_manager_client));
 
-    power_manager_observer_ = std::make_unique<TestPowerManagerObserver>();
+    AshTestBase::SetUp();
 
     BlockUserSession(BLOCKED_BY_LOCK_SCREEN);
     InitializeTabletPowerButtonState();
@@ -113,6 +121,7 @@
   void TearDown() override {
     power_manager_observer_.reset();
     AshTestBase::TearDown();
+    chromeos::DBusThreadManager::Shutdown();
   }
 
   bool LaunchTimeoutRunning() {
@@ -137,18 +146,18 @@
   }
 
   void TurnScreenOffForUserInactivity() {
-    power_manager_client()->set_screen_brightness_percent(0);
+    power_manager_client_->set_screen_brightness_percent(0);
     power_manager::BacklightBrightnessChange change;
     change.set_percent(0.0);
     change.set_cause(power_manager::BacklightBrightnessChange_Cause_OTHER);
-    power_manager_client()->SendScreenBrightnessChanged(change);
+    power_manager_client_->SendScreenBrightnessChanged(change);
     power_manager_observer_->ClearBrightnessChanges();
   }
 
   void SimulatePowerButtonPress() {
-    power_manager_client()->SendPowerButtonEvent(true, tick_clock_.NowTicks());
+    power_manager_client_->SendPowerButtonEvent(true, tick_clock_.NowTicks());
     tick_clock_.Advance(base::TimeDelta::FromMilliseconds(10));
-    power_manager_client()->SendPowerButtonEvent(false, tick_clock_.NowTicks());
+    power_manager_client_->SendPowerButtonEvent(false, tick_clock_.NowTicks());
     base::RunLoop().RunUntilIdle();
   }
 
@@ -175,6 +184,7 @@
   }
 
  protected:
+  chromeos::FakePowerManagerClient* power_manager_client_ = nullptr;
   std::unique_ptr<TestPowerManagerObserver> power_manager_observer_;
   TestTrayActionClient tray_action_client_;
 
@@ -199,7 +209,7 @@
   devices_test_api.NotifyObserversStylusStateChanged(ui::StylusState::REMOVED);
   base::RunLoop().RunUntilIdle();
 
-  EXPECT_FALSE(power_manager_client()->backlights_forced_off());
+  EXPECT_FALSE(power_manager_client_->backlights_forced_off());
   EXPECT_TRUE(power_manager_observer_->brightness_changes().empty());
 
   ASSERT_TRUE(SimulateNoteLaunchStartedIfNoteActionRequested(
@@ -209,7 +219,7 @@
       mojom::TrayActionState::kActive);
   base::RunLoop().RunUntilIdle();
 
-  EXPECT_FALSE(power_manager_client()->backlights_forced_off());
+  EXPECT_FALSE(power_manager_client_->backlights_forced_off());
   EXPECT_TRUE(power_manager_observer_->brightness_changes().empty());
 
   ASSERT_FALSE(LaunchTimeoutRunning());
@@ -222,7 +232,7 @@
   devices_test_api.NotifyObserversStylusStateChanged(ui::StylusState::REMOVED);
   base::RunLoop().RunUntilIdle();
 
-  EXPECT_TRUE(power_manager_client()->backlights_forced_off());
+  EXPECT_TRUE(power_manager_client_->backlights_forced_off());
   EXPECT_EQ(std::vector<double>({0.0}),
             power_manager_observer_->brightness_changes());
   power_manager_observer_->ClearBrightnessChanges();
@@ -234,7 +244,7 @@
       mojom::TrayActionState::kActive);
   base::RunLoop().RunUntilIdle();
 
-  EXPECT_FALSE(power_manager_client()->backlights_forced_off());
+  EXPECT_FALSE(power_manager_client_->backlights_forced_off());
   EXPECT_EQ(std::vector<double>({kVisibleBrightnessPercent}),
             power_manager_observer_->brightness_changes());
 
@@ -248,7 +258,7 @@
   Shell::Get()->tray_action()->UpdateLockScreenNoteState(
       mojom::TrayActionState::kNotAvailable);
 
-  EXPECT_FALSE(power_manager_client()->backlights_forced_off());
+  EXPECT_FALSE(power_manager_client_->backlights_forced_off());
   EXPECT_TRUE(power_manager_observer_->brightness_changes().empty());
 
   ws::InputDeviceClientTestApi devices_test_api;
@@ -256,7 +266,7 @@
   base::RunLoop().RunUntilIdle();
 
   // Styluls eject is expected to turn the screen on due to user activity.
-  EXPECT_FALSE(power_manager_client()->backlights_forced_off());
+  EXPECT_FALSE(power_manager_client_->backlights_forced_off());
   EXPECT_EQ(std::vector<double>({kVisibleBrightnessPercent}),
             power_manager_observer_->brightness_changes());
   power_manager_observer_->ClearBrightnessChanges();
@@ -271,7 +281,7 @@
       mojom::TrayActionState::kActive);
   base::RunLoop().RunUntilIdle();
 
-  EXPECT_FALSE(power_manager_client()->backlights_forced_off());
+  EXPECT_FALSE(power_manager_client_->backlights_forced_off());
   EXPECT_TRUE(power_manager_observer_->brightness_changes().empty());
 
   ASSERT_FALSE(LaunchTimeoutRunning());
@@ -284,7 +294,7 @@
   devices_test_api.NotifyObserversStylusStateChanged(ui::StylusState::REMOVED);
   base::RunLoop().RunUntilIdle();
 
-  EXPECT_TRUE(power_manager_client()->backlights_forced_off());
+  EXPECT_TRUE(power_manager_client_->backlights_forced_off());
   EXPECT_EQ(std::vector<double>({0.0}),
             power_manager_observer_->brightness_changes());
   power_manager_observer_->ClearBrightnessChanges();
@@ -296,7 +306,7 @@
       mojom::TrayActionState::kAvailable);
   base::RunLoop().RunUntilIdle();
 
-  EXPECT_FALSE(power_manager_client()->backlights_forced_off());
+  EXPECT_FALSE(power_manager_client_->backlights_forced_off());
   EXPECT_EQ(std::vector<double>({kVisibleBrightnessPercent}),
             power_manager_observer_->brightness_changes());
 
@@ -311,7 +321,7 @@
 TEST_F(LockScreenNoteDisplayStateHandlerTest, EjectWhileScreenForcedOff) {
   SimulatePowerButtonPress();
 
-  ASSERT_TRUE(power_manager_client()->backlights_forced_off());
+  ASSERT_TRUE(power_manager_client_->backlights_forced_off());
   EXPECT_EQ(std::vector<double>({0.0}),
             power_manager_observer_->brightness_changes());
   power_manager_observer_->ClearBrightnessChanges();
@@ -320,7 +330,7 @@
   devices_test_api.NotifyObserversStylusStateChanged(ui::StylusState::REMOVED);
   base::RunLoop().RunUntilIdle();
 
-  EXPECT_TRUE(power_manager_client()->backlights_forced_off());
+  EXPECT_TRUE(power_manager_client_->backlights_forced_off());
   EXPECT_TRUE(power_manager_observer_->brightness_changes().empty());
 
   ASSERT_TRUE(SimulateNoteLaunchStartedIfNoteActionRequested(
@@ -330,7 +340,7 @@
       mojom::TrayActionState::kActive);
   base::RunLoop().RunUntilIdle();
 
-  EXPECT_FALSE(power_manager_client()->backlights_forced_off());
+  EXPECT_FALSE(power_manager_client_->backlights_forced_off());
   EXPECT_EQ(std::vector<double>({kVisibleBrightnessPercent}),
             power_manager_observer_->brightness_changes());
 
@@ -347,7 +357,7 @@
   ASSERT_TRUE(SimulateNoteLaunchStartedIfNoteActionRequested(
       mojom::LockScreenNoteOrigin::kStylusEject));
 
-  EXPECT_TRUE(power_manager_client()->backlights_forced_off());
+  EXPECT_TRUE(power_manager_client_->backlights_forced_off());
   EXPECT_EQ(std::vector<double>({0.0}),
             power_manager_observer_->brightness_changes());
   power_manager_observer_->ClearBrightnessChanges();
@@ -355,7 +365,7 @@
   ASSERT_TRUE(TriggerNoteLaunchTimeout());
   base::RunLoop().RunUntilIdle();
 
-  EXPECT_FALSE(power_manager_client()->backlights_forced_off());
+  EXPECT_FALSE(power_manager_client_->backlights_forced_off());
   EXPECT_EQ(std::vector<double>({kVisibleBrightnessPercent}),
             power_manager_observer_->brightness_changes());
   power_manager_observer_->ClearBrightnessChanges();
@@ -363,7 +373,7 @@
   Shell::Get()->tray_action()->UpdateLockScreenNoteState(
       mojom::TrayActionState::kActive);
   base::RunLoop().RunUntilIdle();
-  EXPECT_FALSE(power_manager_client()->backlights_forced_off());
+  EXPECT_FALSE(power_manager_client_->backlights_forced_off());
   EXPECT_TRUE(power_manager_observer_->brightness_changes().empty());
 
   ASSERT_FALSE(LaunchTimeoutRunning());
@@ -374,14 +384,14 @@
 // display configuration to off is still in progress.
 TEST_F(LockScreenNoteDisplayStateHandlerTest,
        StylusEjectWhileForcingDisplayOff) {
-  power_manager_client()
+  power_manager_client_
       ->set_enqueue_brightness_changes_on_backlights_forced_off(true);
 
   SimulatePowerButtonPress();
-  EXPECT_TRUE(power_manager_client()->backlights_forced_off());
+  EXPECT_TRUE(power_manager_client_->backlights_forced_off());
   EXPECT_TRUE(power_manager_observer_->brightness_changes().empty());
   EXPECT_EQ(1u,
-            power_manager_client()->pending_screen_brightness_changes().size());
+            power_manager_client_->pending_screen_brightness_changes().size());
 
   ws::InputDeviceClientTestApi devices_test_api;
   devices_test_api.NotifyObserversStylusStateChanged(ui::StylusState::REMOVED);
@@ -394,12 +404,12 @@
 
   // Apply screen brightness set by forcing backlights off,
   EXPECT_EQ(1u,
-            power_manager_client()->pending_screen_brightness_changes().size());
-  ASSERT_TRUE(power_manager_client()->ApplyPendingScreenBrightnessChange());
+            power_manager_client_->pending_screen_brightness_changes().size());
+  ASSERT_TRUE(power_manager_client_->ApplyPendingScreenBrightnessChange());
 
-  EXPECT_TRUE(power_manager_client()->backlights_forced_off());
+  EXPECT_TRUE(power_manager_client_->backlights_forced_off());
   EXPECT_TRUE(
-      power_manager_client()->pending_screen_brightness_changes().empty());
+      power_manager_client_->pending_screen_brightness_changes().empty());
   EXPECT_EQ(std::vector<double>({0.0}),
             power_manager_observer_->brightness_changes());
   power_manager_observer_->ClearBrightnessChanges();
@@ -410,8 +420,8 @@
   Shell::Get()->tray_action()->UpdateLockScreenNoteState(
       mojom::TrayActionState::kActive);
   base::RunLoop().RunUntilIdle();
-  EXPECT_FALSE(power_manager_client()->backlights_forced_off());
-  ASSERT_TRUE(power_manager_client()->ApplyPendingScreenBrightnessChange());
+  EXPECT_FALSE(power_manager_client_->backlights_forced_off());
+  ASSERT_TRUE(power_manager_client_->ApplyPendingScreenBrightnessChange());
   EXPECT_EQ(std::vector<double>({kVisibleBrightnessPercent}),
             power_manager_observer_->brightness_changes());
 
@@ -425,7 +435,7 @@
   a11y_controller->SetClient(a11y_client.CreateInterfacePtrAndBind());
 
   SimulatePowerButtonPress();
-  ASSERT_TRUE(power_manager_client()->backlights_forced_off());
+  ASSERT_TRUE(power_manager_client_->backlights_forced_off());
 
   a11y_controller->FlushMojoForTest();
   EXPECT_EQ(mojom::AccessibilityAlert::SCREEN_OFF,
@@ -437,7 +447,7 @@
 
   ASSERT_TRUE(SimulateNoteLaunchStartedIfNoteActionRequested(
       mojom::LockScreenNoteOrigin::kStylusEject));
-  EXPECT_TRUE(power_manager_client()->backlights_forced_off());
+  EXPECT_TRUE(power_manager_client_->backlights_forced_off());
 
   // Screen ON alert is delayed until the screen is turned on after lock screen
   // note launch.
--- a/ash/lock_screen_action/lock_screen_note_launcher_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/lock_screen_action/lock_screen_note_launcher_unittest.cc	2019-05-17 18:53:08.168000000 +0300
@@ -8,7 +8,6 @@
 #include "ash/test/ash_test_base.h"
 #include "ash/tray_action/test_tray_action_client.h"
 #include "ash/tray_action/tray_action.h"
-#include "base/bind.h"
 
 namespace ash {
 
--- a/ash/login/login_screen_controller.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/login/login_screen_controller.cc	2019-05-17 18:53:08.168000000 +0300
@@ -182,21 +182,6 @@
   login_screen_client_->AuthenticateUserWithEasyUnlock(account_id);
 }
 
-void LoginScreenController::ValidateParentAccessCode(
-    const AccountId& account_id,
-    const std::string& code,
-    OnParentAccessValidation callback) {
-  if (!login_screen_client_) {
-    std::move(callback).Run(base::nullopt);
-    return;
-  }
-
-  login_screen_client_->ValidateParentAccessCode(
-      account_id, code,
-      base::BindOnce(&LoginScreenController::OnParentAccessValidationComplete,
-                     weak_factory_.GetWeakPtr(), std::move(callback)));
-}
-
 void LoginScreenController::HardlockPod(const AccountId& account_id) {
   if (!login_screen_client_)
     return;
@@ -520,16 +505,11 @@
       ->SetShowGuestButtonInOobe(show);
 }
 
-void LoginScreenController::SetShowParentAccessButton(bool show) {
+void LoginScreenController::SetShowParentAccess(bool show) {
   Shelf::ForWindow(Shell::Get()->GetPrimaryRootWindow())
       ->shelf_widget()
       ->login_shelf_view()
-      ->SetShowParentAccessButton(show);
-}
-
-void LoginScreenController::SetShowParentAccessDialog(bool show) {
-  if (DataDispatcher())
-    DataDispatcher()->SetShowParentAccessDialog(show);
+      ->SetShowParentAccess(show);
 }
 
 void LoginScreenController::FocusLoginShelf(bool reverse) {
@@ -583,10 +563,6 @@
   login_screen_client_->FocusOobeDialog();
 }
 
-void LoginScreenController::NotifyUserActivity() {
-  login_screen_client_->OnUserActivity();
-}
-
 void LoginScreenController::OnAuthenticateComplete(
     OnAuthenticateCallback callback,
     bool success) {
@@ -595,12 +571,6 @@
   authentication_stage_ = AuthenticationStage::kIdle;
 }
 
-void LoginScreenController::OnParentAccessValidationComplete(
-    OnParentAccessValidation callback,
-    bool success) {
-  std::move(callback).Run(base::make_optional<bool>(success));
-}
-
 LoginDataDispatcher* LoginScreenController::DataDispatcher() const {
   if (!ash::LockScreen::HasInstance())
     return nullptr;
--- a/ash/login/login_screen_controller.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/login/login_screen_controller.h	2019-05-17 18:53:08.168000000 +0300
@@ -43,10 +43,6 @@
   // succeeded/failed.
   using OnAuthenticateCallback =
       base::OnceCallback<void(base::Optional<bool> success)>;
-  // Callback for parent access code validation. |success| is nullopt if
-  // validation did not run, otherwise it contains validation result.
-  using OnParentAccessValidation =
-      base::OnceCallback<void(base::Optional<bool> success)>;
 
   explicit LoginScreenController(SystemTrayNotifier* system_tray_notifier);
   ~LoginScreenController() override;
@@ -71,9 +67,6 @@
                                           OnAuthenticateCallback callback);
   void EnrollUserWithExternalBinary(OnAuthenticateCallback callback);
   void AuthenticateUserWithEasyUnlock(const AccountId& account_id);
-  void ValidateParentAccessCode(const AccountId& account_id,
-                                const std::string& code,
-                                OnParentAccessValidation callback);
   void HardlockPod(const AccountId& account_id);
   void OnFocusPod(const AccountId& account_id);
   void OnNoPodFocused();
@@ -98,7 +91,6 @@
   void ShowResetScreen();
   void ShowAccountAccessHelpApp();
   void FocusOobeDialog();
-  void NotifyUserActivity();
 
   // Add or remove an observer.
   void AddObserver(LoginScreenControllerObserver* observer);
@@ -165,8 +157,7 @@
   void SetShutdownButtonEnabled(bool enable) override;
   void SetAllowLoginAsGuest(bool allow_guest) override;
   void SetShowGuestButtonInOobe(bool show) override;
-  void SetShowParentAccessButton(bool show) override;
-  void SetShowParentAccessDialog(bool show) override;
+  void SetShowParentAccess(bool show) override;
   void FocusLoginShelf(bool reverse) override;
 
   // Flushes the mojo pipes - to be used in tests.
@@ -178,8 +169,6 @@
 
  private:
   void OnAuthenticateComplete(OnAuthenticateCallback callback, bool success);
-  void OnParentAccessValidationComplete(OnParentAccessValidation callback,
-                                        bool success);
 
   // Returns the active data dispatcher or nullptr if there is no lock screen.
   LoginDataDispatcher* DataDispatcher() const;
--- a/ash/login/login_screen_controller_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/login/login_screen_controller_unittest.cc	2019-05-17 18:53:08.168000000 +0300
@@ -16,7 +16,6 @@
 #include "ash/system/unified/unified_system_tray.h"
 #include "ash/test/ash_test_base.h"
 #include "ash/wallpaper/wallpaper_controller.h"
-#include "base/bind.h"
 #include "base/run_loop.h"
 #include "base/test/bind_test_util.h"
 #include "components/prefs/pref_service.h"
--- a/ash/login/login_screen_test_api.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/login/login_screen_test_api.cc	2019-05-17 18:53:08.168000000 +0300
@@ -21,29 +21,6 @@
 
 namespace ash {
 
-namespace {
-
-LoginShelfView* GetLoginShelfView() {
-  if (!Shell::HasInstance())
-    return nullptr;
-
-  return Shelf::ForWindow(Shell::GetPrimaryRootWindow())
-      ->shelf_widget()
-      ->login_shelf_view();
-}
-
-bool IsLoginShelfViewButtonShown(int button_view_id) {
-  LoginShelfView* shelf_view = GetLoginShelfView();
-  if (!shelf_view)
-    return false;
-
-  views::View* button_view = shelf_view->GetViewByID(button_view_id);
-
-  return button_view && button_view->visible();
-}
-
-}  // anonymous namespace
-
 // static
 void LoginScreenTestApi::BindRequest(mojom::LoginScreenTestApiRequest request) {
   mojo::MakeStrongBinding(std::make_unique<LoginScreenTestApi>(),
@@ -61,20 +38,11 @@
 }
 
 void LoginScreenTestApi::IsLoginShelfShown(IsLoginShelfShownCallback callback) {
-  LoginShelfView* view = GetLoginShelfView();
-  std::move(callback).Run(view && view->visible());
-}
-
-void LoginScreenTestApi::IsRestartButtonShown(
-    IsRestartButtonShownCallback callback) {
-  std::move(callback).Run(
-      IsLoginShelfViewButtonShown(LoginShelfView::kRestart));
-}
-
-void LoginScreenTestApi::IsShutdownButtonShown(
-    IsShutdownButtonShownCallback callback) {
-  std::move(callback).Run(
-      IsLoginShelfViewButtonShown(LoginShelfView::kShutdown));
+  std::move(callback).Run(Shell::HasInstance() &&
+                          Shelf::ForWindow(Shell::GetPrimaryRootWindow())
+                              ->shelf_widget()
+                              ->login_shelf_view()
+                              ->visible());
 }
 
 void LoginScreenTestApi::SubmitPassword(const AccountId& account_id,
@@ -102,10 +70,4 @@
   std::move(callback).Run();
 }
 
-void LoginScreenTestApi::GetUiUpdateCount(GetUiUpdateCountCallback callback) {
-  LoginShelfView* view = GetLoginShelfView();
-
-  std::move(callback).Run(view ? view->ui_update_count() : 0);
-}
-
 }  // namespace ash
--- a/ash/login/login_screen_test_api.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/login/login_screen_test_api.h	2019-05-17 18:53:08.168000000 +0300
@@ -23,12 +23,9 @@
   // mojom::LoginScreen:
   void IsLockShown(IsLockShownCallback callback) override;
   void IsLoginShelfShown(IsLoginShelfShownCallback callback) override;
-  void IsRestartButtonShown(IsRestartButtonShownCallback callback) override;
-  void IsShutdownButtonShown(IsShutdownButtonShownCallback callback) override;
   void SubmitPassword(const AccountId& account_id,
                       const std::string& password,
                       SubmitPasswordCallback callback) override;
-  void GetUiUpdateCount(GetUiUpdateCountCallback callback) override;
 
  private:
   DISALLOW_COPY_AND_ASSIGN(LoginScreenTestApi);
--- a/ash/login/mock_login_screen_client.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/login/mock_login_screen_client.cc	2019-05-17 18:53:08.168000000 +0300
@@ -59,14 +59,6 @@
   }
 }
 
-void MockLoginScreenClient::ValidateParentAccessCode(
-    const AccountId& account_id,
-    const std::string& code,
-    ValidateParentAccessCodeCallback callback) {
-  ValidateParentAccessCode_(account_id, code, callback);
-  std::move(callback).Run(validate_parent_access_code_result_);
-}
-
 std::unique_ptr<MockLoginScreenClient> BindMockLoginScreenClient() {
   auto client = std::make_unique<MockLoginScreenClient>();
   Shell::Get()->login_screen_controller()->SetClient(
--- a/ash/login/mock_login_screen_client.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/login/mock_login_screen_client.h	2019-05-17 18:53:08.168000000 +0300
@@ -30,10 +30,6 @@
                     AuthenticateUserWithExternalBinaryCallback& callback));
   MOCK_METHOD1(EnrollUserWithExternalBinary_,
                void(EnrollUserWithExternalBinaryCallback& callback));
-  MOCK_METHOD3(ValidateParentAccessCode_,
-               void(const AccountId& account_id,
-                    const std::string& access_code,
-                    ValidateParentAccessCodeCallback& callback));
 
   // Set the result that should be passed to |callback| in
   // |AuthenticateUserWithPasswordOrPin| or
@@ -42,12 +38,6 @@
     authenticate_user_callback_result_ = value;
   }
 
-  // Sets the result that should be passed to |callback| in
-  // |ValidateParentAccessCode|.
-  void set_validate_parent_access_code_result(bool value) {
-    validate_parent_access_code_result_ = value;
-  }
-
   // If set to non-null, when |AuthenticateUser| is called the callback will be
   // stored in |storage| instead of being executed.
   void set_authenticate_user_with_password_or_pin_callback_storage(
@@ -74,10 +64,6 @@
       AuthenticateUserWithExternalBinaryCallback callback) override;
   void EnrollUserWithExternalBinary(
       EnrollUserWithExternalBinaryCallback callback) override;
-  void ValidateParentAccessCode(
-      const AccountId& account_id,
-      const std::string& code,
-      ValidateParentAccessCodeCallback callback) override;
   MOCK_METHOD1(AuthenticateUserWithEasyUnlock,
                void(const AccountId& account_id));
   MOCK_METHOD1(HardlockPod, void(const AccountId& account_id));
@@ -108,11 +94,9 @@
   MOCK_METHOD0(ShowAccountAccessHelpApp, void());
   MOCK_METHOD0(FocusOobeDialog, void());
   MOCK_METHOD1(OnFocusLeavingSystemTray, void(bool reverse));
-  MOCK_METHOD0(OnUserActivity, void());
 
  private:
   bool authenticate_user_callback_result_ = true;
-  bool validate_parent_access_code_result_ = true;
   AuthenticateUserWithPasswordOrPinCallback*
       authenticate_user_with_password_or_pin_callback_storage_ = nullptr;
   AuthenticateUserWithExternalBinaryCallback*
--- a/ash/login/ui/animated_rounded_image_view.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/login/ui/animated_rounded_image_view.cc	2019-05-17 18:53:08.172000000 +0300
@@ -6,7 +6,6 @@
 
 #include <limits>
 
-#include "base/bind.h"
 #include "base/numerics/ranges.h"
 #include "skia/ext/image_operations.h"
 #include "third_party/skia/include/core/SkPath.h"
--- a/ash/login/ui/image_parser.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/login/ui/image_parser.cc	2019-05-17 18:53:08.172000000 +0300
@@ -7,7 +7,6 @@
 #include <utility>
 
 #include "ash/shell.h"
-#include "base/bind.h"
 #include "ipc/ipc_channel.h"
 #include "services/data_decoder/public/cpp/decode_image.h"
 
--- a/ash/login/ui/lock_contents_view.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/login/ui/lock_contents_view.cc	2019-05-17 18:53:08.172000000 +0300
@@ -22,7 +22,6 @@
 #include "ash/login/ui/login_user_view.h"
 #include "ash/login/ui/non_accessible_view.h"
 #include "ash/login/ui/note_action_launch_button.h"
-#include "ash/login/ui/parent_access_view.h"
 #include "ash/login/ui/scrollable_users_list_view.h"
 #include "ash/login/ui/views_utils.h"
 #include "ash/public/cpp/ash_features.h"
@@ -36,7 +35,6 @@
 #include "ash/system/status_area_widget_delegate.h"
 #include "ash/system/tray/system_tray_notifier.h"
 #include "ash/wm/tablet_mode/tablet_mode_controller.h"
-#include "base/bind.h"
 #include "base/command_line.h"
 #include "base/strings/string16.h"
 #include "base/strings/utf_string_conversions.h"
@@ -45,13 +43,10 @@
 #include "ui/accessibility/ax_node_data.h"
 #include "ui/base/l10n/l10n_util.h"
 #include "ui/base/ui_base_features.h"
-#include "ui/base/user_activity/user_activity_detector.h"
-#include "ui/base/user_activity/user_activity_observer.h"
 #include "ui/display/display.h"
 #include "ui/display/manager/display_manager.h"
 #include "ui/display/manager/managed_display_info.h"
 #include "ui/gfx/geometry/insets.h"
-#include "ui/gfx/geometry/point.h"
 #include "ui/gfx/geometry/rect.h"
 #include "ui/gfx/geometry/size.h"
 #include "ui/gfx/geometry/vector2d.h"
@@ -134,15 +129,15 @@
   DISALLOW_COPY_AND_ASSIGN(AuthErrorLearnMoreButton);
 };
 
-// Focuses the first or last focusable child of |root|. If |reverse| is false,
-// this focuses the first focusable child. If |reverse| is true, this focuses
+// Returns the first or last focusable child of |root|. If |reverse| is false,
+// this returns the first focusable child. If |reverse| is true, this returns
 // the last focusable child.
-void FocusFirstOrLastFocusableChild(views::View* root, bool reverse) {
+views::View* FindFirstOrLastFocusableChild(views::View* root, bool reverse) {
   views::FocusSearch search(root, reverse /*cycle*/,
                             false /*accessibility_mode*/);
   views::FocusTraversable* dummy_focus_traversable;
   views::View* dummy_focus_traversable_view;
-  views::View* focusable_view = search.FindNextFocusableView(
+  return search.FindNextFocusableView(
       root,
       reverse ? views::FocusSearch::SearchDirection::kBackwards
               : views::FocusSearch::SearchDirection::kForwards,
@@ -150,8 +145,6 @@
       views::FocusSearch::StartingViewPolicy::kSkipStartingView,
       views::FocusSearch::AnchoredDialogPolicy::kCanGoIntoAnchoredDialog,
       &dummy_focus_traversable, &dummy_focus_traversable_view);
-  if (focusable_view)
-    focusable_view->RequestFocus();
 }
 
 // Make a section of the text bold.
@@ -281,28 +274,6 @@
 
 }  // namespace
 
-class LockContentsView::AutoLoginUserActivityHandler
-    : public ui::UserActivityObserver {
- public:
-  AutoLoginUserActivityHandler() {
-    observer_.Add(ui::UserActivityDetector::Get());
-  }
-
-  ~AutoLoginUserActivityHandler() override = default;
-
-  void OnUserActivity(const ui::Event* event) override {
-    if (Shell::Get()->login_screen_controller()) {
-      Shell::Get()->login_screen_controller()->NotifyUserActivity();
-    }
-  }
-
- private:
-  ScopedObserver<ui::UserActivityDetector, ui::UserActivityObserver> observer_{
-      this};
-
-  DISALLOW_COPY_AND_ASSIGN(AutoLoginUserActivityHandler);
-};
-
 LockContentsView::TestApi::TestApi(LockContentsView* view) : view_(view) {}
 
 LockContentsView::TestApi::~TestApi() = default;
@@ -381,15 +352,20 @@
       screen_type_(screen_type),
       data_dispatcher_(data_dispatcher),
       detachable_base_model_(std::move(detachable_base_model)) {
-  if (screen_type == LockScreen::ScreenType::kLogin)
-    auto_login_user_activity_handler_ =
-        std::make_unique<AutoLoginUserActivityHandler>();
-
   data_dispatcher_->AddObserver(this);
   display_observer_.Add(display::Screen::GetScreen());
   Shell::Get()->login_screen_controller()->AddObserver(this);
   Shell::Get()->system_tray_notifier()->AddSystemTrayFocusObserver(this);
   keyboard::KeyboardController::Get()->AddObserver(this);
+  auth_error_bubble_ = LoginErrorBubble::CreateDefault();
+  supervised_user_deprecation_bubble_ = LoginErrorBubble::CreateDefault();
+  supervised_user_deprecation_bubble_->SetPersistent(true);
+  detachable_base_error_bubble_ = LoginErrorBubble::CreateDefault();
+  detachable_base_error_bubble_->SetPersistent(true);
+  tooltip_bubble_ = new LoginTooltipView(base::UTF8ToUTF16("") /*message*/,
+                                         nullptr /*anchor_view*/);
+  warning_banner_bubble_ = LoginErrorBubble::CreateDefault();
+  warning_banner_bubble_->SetPersistent(true);
 
   // We reuse the focusable state on this view as a signal that focus should
   // switch to the system tray. LockContentsView should otherwise not be
@@ -429,27 +405,9 @@
   expanded_view_->SetVisible(false);
   AddChildView(expanded_view_);
 
-  supervised_user_deprecation_bubble_ = new LoginErrorBubble();
-  supervised_user_deprecation_bubble_->SetPersistent(true);
-  AddChildView(supervised_user_deprecation_bubble_);
-
-  detachable_base_error_bubble_ = new LoginErrorBubble();
-  detachable_base_error_bubble_->SetPersistent(true);
-  AddChildView(detachable_base_error_bubble_);
-
-  tooltip_bubble_ = new LoginTooltipView(base::UTF8ToUTF16("") /*message*/,
-                                         nullptr /*anchor_view*/);
-  AddChildView(tooltip_bubble_);
-
-  warning_banner_bubble_ = new LoginErrorBubble();
-  warning_banner_bubble_->SetPersistent(true);
-  AddChildView(warning_banner_bubble_);
-
-  auth_error_bubble_ = new LoginErrorBubble();
-  AddChildView(auth_error_bubble_);
-
   OnLockScreenNoteStateChanged(initial_note_action_state);
-  chromeos::PowerManagerClient::Get()->AddObserver(this);
+  chromeos::DBusThreadManager::Get()->GetPowerManagerClient()->AddObserver(
+      this);
   RegisterAccelerators();
 }
 
@@ -467,7 +425,10 @@
     Shell::Get()->metrics()->login_metrics_recorder()->RecordNumLoginAttempts(
         unlock_attempt_, false /*success*/);
   }
-  chromeos::PowerManagerClient::Get()->RemoveObserver(this);
+  chromeos::DBusThreadManager::Get()->GetPowerManagerClient()->RemoveObserver(
+      this);
+
+  CleanupBubbles();
 }
 
 void LockContentsView::FocusNextUser() {
@@ -839,14 +800,13 @@
   if (!big_user || !big_user->auth_user())
     return;
 
-  if (tooltip_bubble_->visible())
+  if (tooltip_bubble_->IsVisible())
     tooltip_bubble_->Hide();
 
   if (icon->autoshow_tooltip) {
     tooltip_bubble_->SetAnchorView(big_user->auth_user()->password_view());
     tooltip_bubble_->SetText(icon->tooltip);
     tooltip_bubble_->Show();
-    tooltip_bubble_->SetVisible(true);
   }
 }
 
@@ -857,7 +817,7 @@
                   "warning banner.";
     return;
   }
-  if (warning_banner_bubble_->visible())
+  if (warning_banner_bubble_->IsVisible())
     warning_banner_bubble_->Hide();
   // Shows warning banner as a persistent error bubble.
   views::Label* label =
@@ -868,14 +828,14 @@
   label->SetHorizontalAlignment(gfx::ALIGN_LEFT);
   label->SetEnabledColor(SK_ColorWHITE);
 
+  warning_banner_bubble_->SetContent(label);
   warning_banner_bubble_->SetAnchorView(
       CurrentBigUserView()->auth_user()->password_view());
-  warning_banner_bubble_->SetContent(label);
   warning_banner_bubble_->Show();
 }
 
 void LockContentsView::OnHideWarningBanner() {
-  if (warning_banner_bubble_->visible())
+  if (warning_banner_bubble_->IsVisible())
     warning_banner_bubble_->Hide();
 }
 
@@ -1022,12 +982,12 @@
       (pairing_status == DetachableBasePairingStatus::kAuthenticated &&
        detachable_base_model_->PairedBaseMatchesLastUsedByUser(
            *CurrentBigUserView()->GetCurrentUser()->basic_user_info))) {
-    if (detachable_base_error_bubble_->visible())
+    if (detachable_base_error_bubble_->IsVisible())
       detachable_base_error_bubble_->Hide();
     return;
   }
 
-  if (auth_error_bubble_->visible())
+  if (auth_error_bubble_->IsVisible())
     auth_error_bubble_->Hide();
 
   base::string16 error_text =
@@ -1052,19 +1012,6 @@
     GetWidget()->GetFocusManager()->ClearFocus();
 }
 
-void LockContentsView::OnSetShowParentAccessDialog(bool show) {
-  if (!primary_big_view_)
-    return;
-
-  if (show) {
-    primary_big_view_->ShowParentAccessView();
-  } else {
-    primary_big_view_->HideParentAccessView();
-  }
-
-  Layout();
-}
-
 void LockContentsView::SetAvatarForUser(const AccountId& account_id,
                                         const mojom::UserAvatarPtr& avatar) {
   auto replace = [&](const mojom::LoginUserInfoPtr& user) {
@@ -1092,7 +1039,7 @@
   if (!reverse || lock_screen_apps_active_)
     FocusNextWidget(reverse);
   else
-    FocusFirstOrLastFocusableChild(this, reverse);
+    FindFirstOrLastFocusableChild(this, reverse)->RequestFocus();
 }
 
 void LockContentsView::OnOobeDialogStateChanged(mojom::OobeDialogState state) {
@@ -1108,7 +1055,7 @@
   // from the system shelf (or tray) - lock shelf view expect the focus to be
   // taken when it passes it to lock screen view, and can misbehave in case the
   // focus is kept in it.
-  FocusFirstOrLastFocusableChild(this, reverse);
+  FindFirstOrLastFocusableChild(this, reverse)->RequestFocus();
 
   if (lock_screen_apps_active_) {
     Shell::Get()->login_screen_controller()->FocusLockScreenApps(reverse);
@@ -1375,10 +1322,10 @@
 
 void LockContentsView::OnAuthenticate(bool auth_success) {
   if (auth_success) {
-    if (auth_error_bubble_->visible())
+    if (auth_error_bubble_->IsVisible())
       auth_error_bubble_->Hide();
 
-    if (detachable_base_error_bubble_->visible())
+    if (detachable_base_error_bubble_->IsVisible())
       detachable_base_error_bubble_->Hide();
 
     // Now that the user has been authenticated, update the user's last used
@@ -1577,7 +1524,7 @@
     supervised_user_deprecation_bubble_->SetAnchorView(
         CurrentBigUserView()->auth_user()->password_view());
     supervised_user_deprecation_bubble_->Show();
-  } else if (supervised_user_deprecation_bubble_->visible()) {
+  } else if (supervised_user_deprecation_bubble_->IsVisible()) {
     supervised_user_deprecation_bubble_->Hide();
   }
 
@@ -1586,7 +1533,7 @@
   OnDetachableBasePairingStatusChanged(
       detachable_base_model_->GetPairingStatus());
 
-  if (!detachable_base_error_bubble_->visible())
+  if (!detachable_base_error_bubble_->IsVisible())
     CurrentBigUserView()->RequestFocus();
 }
 
@@ -1681,6 +1628,9 @@
   container->AddChildView(label);
   container->AddChildView(learn_more_button);
 
+  if (auth_error_bubble_->IsVisible())
+    auth_error_bubble_->Hide();
+
   auth_error_bubble_->SetAnchorView(big_view->auth_user()->password_view());
   auth_error_bubble_->SetContent(container);
   auth_error_bubble_->SetPersistent(false);
@@ -1721,10 +1671,6 @@
   }
 }
 
-void LockContentsView::OnParentAccessValidationFinished(bool access_granted) {
-  OnSetShowParentAccessDialog(false);
-}
-
 keyboard::KeyboardController* LockContentsView::GetKeyboardControllerForView()
     const {
   return GetWidget() ? GetKeyboardControllerForWidget(GetWidget()) : nullptr;
@@ -1787,15 +1733,8 @@
   public_account_callbacks.on_public_account_tapped =
       base::BindRepeating(&LockContentsView::OnPublicAccountTapped,
                           base::Unretained(this), is_primary);
-
-  ParentAccessView::Callbacks parent_access_callbacks;
-  parent_access_callbacks.on_finished =
-      base::BindRepeating(&LockContentsView::OnParentAccessValidationFinished,
-                          base::Unretained(this));
-
   return new LoginBigUserView(user, auth_user_callbacks,
-                              public_account_callbacks,
-                              parent_access_callbacks);
+                              public_account_callbacks);
 }
 
 LoginBigUserView* LockContentsView::TryToFindBigUser(const AccountId& user,
@@ -1909,4 +1848,29 @@
   }
 }
 
+void LockContentsView::CleanupBubbles() {
+  // If any of the error bubbles have been shown once, it is hosted by a
+  // widget under the Ash menu container, so we should Close the widget when we
+  // destroy LockContentsView (otherwise it will live for the entire lifetime of
+  // the Menu container). If a bubble has never been shown, then we can just
+  // delete it, since it is owned directly by LockContentsView.
+  auto cleanup = [](LoginBaseBubbleView* bubble) {
+    if (bubble->GetWidget())
+      bubble->GetWidget()->Close();
+    else
+      delete bubble;
+  };
+
+  cleanup(auth_error_bubble_);
+  auth_error_bubble_ = nullptr;
+  cleanup(detachable_base_error_bubble_);
+  detachable_base_error_bubble_ = nullptr;
+  cleanup(tooltip_bubble_);
+  tooltip_bubble_ = nullptr;
+  cleanup(warning_banner_bubble_);
+  warning_banner_bubble_ = nullptr;
+  cleanup(supervised_user_deprecation_bubble_);
+  supervised_user_deprecation_bubble_ = nullptr;
+}
+
 }  // namespace ash
--- a/ash/login/ui/lock_contents_view.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/login/ui/lock_contents_view.h	2019-05-17 18:53:08.172000000 +0300
@@ -181,7 +181,6 @@
       bool show_full_management_disclosure) override;
   void OnDetachableBasePairingStatusChanged(
       DetachableBasePairingStatus pairing_status) override;
-  void OnSetShowParentAccessDialog(bool show) override;
 
   // SystemTrayFocusObserver:
   void OnFocusLeavingSystemTray(bool reverse) override;
@@ -193,7 +192,7 @@
   // views::StyledLabelListener:
   void StyledLabelLinkClicked(views::StyledLabel* label,
                               const gfx::Range& range,
-                              int event_flags) override {}
+                              int event_flags) override{};
   // SessionObserver:
   void OnLockStateChanged(bool locked) override;
 
@@ -224,8 +223,6 @@
     DISALLOW_COPY_AND_ASSIGN(UserState);
   };
 
-  class AutoLoginUserActivityHandler;
-
   using DisplayLayoutAction = base::RepeatingCallback<void(bool landscape)>;
 
   // Focus the next/previous widget.
@@ -306,9 +303,6 @@
   // Called when the easy unlock icon is tapped.
   void OnEasyUnlockIconTapped();
 
-  // Called when parent access validation finished.
-  void OnParentAccessValidationFinished(bool access_granted);
-
   // Returns keyboard controller for the view. Returns nullptr if keyboard is
   // not activated, view has not been added to the widget yet or keyboard is not
   // displayed in this window.
@@ -345,6 +339,10 @@
   // Performs the specified accelerator action.
   void PerformAction(AcceleratorAction action);
 
+  // Deletes the various bubbles, either by Close()-ing the hosting widget or
+  // deleting any orphaned views.
+  void CleanupBubbles();
+
   const LockScreen::ScreenType screen_type_;
 
   std::vector<UserState> users_;
@@ -379,9 +377,8 @@
       this};
   ScopedSessionObserver session_observer_{this};
 
-  // All error bubbles and the tooltip view are child views of LockContentsView,
-  // and will be torn down when LockContentsView is torn down.
-  // Bubble for displaying authentication error.
+  // Error bubbles are owned by LockContentsView, or by the Ash menu container
+  // if they have been shown. Bubble for displaying authentication error.
   LoginErrorBubble* auth_error_bubble_;
   // Bubble for displaying detachable base errors.
   LoginErrorBubble* detachable_base_error_bubble_;
@@ -412,11 +409,6 @@
   // Accelerators handled by login screen.
   std::map<ui::Accelerator, AcceleratorAction> accel_map_;
 
-  // Notifies Chrome when user activity is detected on the login screen so that
-  // the auto-login timer can be reset.
-  std::unique_ptr<AutoLoginUserActivityHandler>
-      auto_login_user_activity_handler_;
-
   DISALLOW_COPY_AND_ASSIGN(LockContentsView);
 };
 
--- a/ash/login/ui/lock_contents_view_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/login/ui/lock_contents_view_unittest.cc	2019-05-17 18:53:08.172000000 +0300
@@ -35,6 +35,7 @@
 #include "ash/tray_action/tray_action.h"
 #include "base/strings/utf_string_conversions.h"
 #include "base/test/simple_test_tick_clock.h"
+#include "chromeos/dbus/dbus_thread_manager.h"
 #include "chromeos/dbus/fake_power_manager_client.h"
 #include "chromeos/dbus/power_manager/suspend.pb.h"
 #include "testing/gtest/include/gtest/gtest.h"
@@ -725,7 +726,7 @@
 
   LockContentsView::TestApi test_api(lock);
   // Creating lock screen does not show tooltip bubble.
-  EXPECT_FALSE(test_api.tooltip_bubble()->visible());
+  EXPECT_FALSE(test_api.tooltip_bubble()->IsVisible());
 
   // Show an icon with |autoshow_tooltip| is false. Tooltip bubble is not
   // activated.
@@ -734,13 +735,13 @@
   icon->autoshow_tooltip = false;
   DataDispatcher()->ShowEasyUnlockIcon(users()[0]->basic_user_info->account_id,
                                        icon);
-  EXPECT_FALSE(test_api.tooltip_bubble()->visible());
+  EXPECT_FALSE(test_api.tooltip_bubble()->IsVisible());
 
   // Show icon with |autoshow_tooltip| set to true. Tooltip bubble is shown.
   icon->autoshow_tooltip = true;
   DataDispatcher()->ShowEasyUnlockIcon(users()[0]->basic_user_info->account_id,
                                        icon);
-  EXPECT_TRUE(test_api.tooltip_bubble()->visible());
+  EXPECT_TRUE(test_api.tooltip_bubble()->IsVisible());
 }
 
 // Verifies that easy unlock icon state persists when changing auth user.
@@ -859,59 +860,12 @@
   generator->PressKey(ui::KeyboardCode::VKEY_RETURN, 0);
   base::RunLoop().RunUntilIdle();
 
-  EXPECT_TRUE(test_api.auth_error_bubble()->visible());
+  EXPECT_TRUE(test_api.auth_error_bubble()->IsVisible());
 
   // The error bubble is expected to close on a user action - e.g. if they start
   // typing the password again.
   generator->PressKey(ui::KeyboardCode::VKEY_B, 0);
-  EXPECT_FALSE(test_api.auth_error_bubble()->visible());
-}
-
-TEST_F(LockContentsViewUnitTest, AuthErrorButtonClickable) {
-  // Build lock screen with a single user.
-  auto* contents = new LockContentsView(
-      mojom::TrayActionState::kNotAvailable, LockScreen::ScreenType::kLock,
-      DataDispatcher(),
-      std::make_unique<FakeLoginDetachableBaseModel>(DataDispatcher()));
-  SetUserCount(1);
-  SetWidget(CreateWidgetWithContent(contents));
-
-  LockContentsView::TestApi test_api(contents);
-
-  // Password submit runs mojo.
-  std::unique_ptr<MockLoginScreenClient> client = BindMockLoginScreenClient();
-  client->set_authenticate_user_callback_result(false);
-  EXPECT_CALL(*client,
-              AuthenticateUserWithPasswordOrPin_(
-                  users()[0]->basic_user_info->account_id, _, false, _));
-
-  // AuthErrorButton should not be visible yet.
-  EXPECT_FALSE(test_api.auth_error_bubble()->visible());
-
-  // Submit password.
-  ui::test::EventGenerator* generator = GetEventGenerator();
-  generator->PressKey(ui::KeyboardCode::VKEY_A, 0);
-  generator->PressKey(ui::KeyboardCode::VKEY_RETURN, 0);
-  base::RunLoop().RunUntilIdle();
-
-  // Auth Error button should be visible as an incorrect password was given.
-  EXPECT_TRUE(test_api.auth_error_bubble()->visible());
-
-  // Find button in auth_error_bubble children.
-  views::View* button = FindTopButton(test_api.auth_error_bubble());
-  ASSERT_TRUE(button);
-
-  // Expect ShowAccountAccessHelp() to be called due to button click.
-  EXPECT_CALL(*client, ShowAccountAccessHelpApp()).Times(1);
-
-  // Move mouse to AuthError's ShowAccountAccessHelp button and click it.
-  // Should result in ShowAccountAccessHelpApp().
-  generator->MoveMouseTo(button->GetBoundsInScreen().CenterPoint());
-  generator->ClickLeftButton();
-  Shell::Get()->login_screen_controller()->FlushForTesting();
-
-  // AuthErrorButton should go away after button press.
-  EXPECT_FALSE(test_api.auth_error_bubble()->visible());
+  EXPECT_FALSE(test_api.auth_error_bubble()->IsVisible());
 }
 
 // Gaia is never shown on lock, no mater how many times auth fails.
@@ -1003,17 +957,17 @@
   LockContentsView::TestApi test_api(contents);
   ui::test::EventGenerator* generator = GetEventGenerator();
 
-  EXPECT_FALSE(test_api.detachable_base_error_bubble()->visible());
+  EXPECT_FALSE(test_api.detachable_base_error_bubble()->IsVisible());
 
   // Change detachable base to a base different than the one previously used by
   // the user - verify that a detachable base error bubble is shown.
   detachable_base_model->SetPairingStatus(
       DetachableBasePairingStatus::kAuthenticated, "5678");
-  EXPECT_TRUE(test_api.detachable_base_error_bubble()->visible());
+  EXPECT_TRUE(test_api.detachable_base_error_bubble()->IsVisible());
 
   // Verify that the bubble is not hidden if the user starts typing.
   generator->PressKey(ui::KeyboardCode::VKEY_B, 0);
-  EXPECT_TRUE(test_api.detachable_base_error_bubble()->visible());
+  EXPECT_TRUE(test_api.detachable_base_error_bubble()->IsVisible());
 
   // Switching to the user that doesn't have previously used detachable base
   // (and should thus not be warned about the detachable base missmatch) should
@@ -1024,7 +978,7 @@
       secondary_test_api.user_view()->GetBoundsInScreen().CenterPoint());
   generator->ClickLeftButton();
 
-  EXPECT_FALSE(test_api.detachable_base_error_bubble()->visible());
+  EXPECT_FALSE(test_api.detachable_base_error_bubble()->IsVisible());
 
   // The error should be shown again when switching back to the primary user.
   LoginAuthUserView::TestApi primary_test_api(
@@ -1033,7 +987,7 @@
       primary_test_api.user_view()->GetBoundsInScreen().CenterPoint());
   generator->ClickLeftButton();
 
-  EXPECT_TRUE(test_api.detachable_base_error_bubble()->visible());
+  EXPECT_TRUE(test_api.detachable_base_error_bubble()->IsVisible());
   EXPECT_FALSE(primary_test_api.password_view()->HasFocus());
 
   EXPECT_EQ("1234",
@@ -1082,16 +1036,16 @@
   LockContentsView::TestApi test_api(contents);
   ui::test::EventGenerator* generator = GetEventGenerator();
 
-  EXPECT_FALSE(test_api.detachable_base_error_bubble()->visible());
+  EXPECT_FALSE(test_api.detachable_base_error_bubble()->IsVisible());
 
   // Show notification if unauthenticated base is attached.
   detachable_base_model->SetPairingStatus(
       DetachableBasePairingStatus::kNotAuthenticated, "");
-  EXPECT_TRUE(test_api.detachable_base_error_bubble()->visible());
+  EXPECT_TRUE(test_api.detachable_base_error_bubble()->IsVisible());
 
   // Verify that the bubble is not hidden if the user starts typing.
   generator->PressKey(ui::KeyboardCode::VKEY_B, 0);
-  EXPECT_TRUE(test_api.detachable_base_error_bubble()->visible());
+  EXPECT_TRUE(test_api.detachable_base_error_bubble()->IsVisible());
 
   // Switching to another user should not hide the error bubble.
   LoginAuthUserView::TestApi secondary_test_api(
@@ -1100,7 +1054,7 @@
       secondary_test_api.user_view()->GetBoundsInScreen().CenterPoint());
   generator->ClickLeftButton();
 
-  EXPECT_TRUE(test_api.detachable_base_error_bubble()->visible());
+  EXPECT_TRUE(test_api.detachable_base_error_bubble()->IsVisible());
   EXPECT_FALSE(secondary_test_api.password_view()->HasFocus());
 
   // The last trusted detachable used by the user should not be overriden by
@@ -1149,12 +1103,12 @@
   // the user - verify that a detachable base error bubble is shown.
   detachable_base_model->SetPairingStatus(
       DetachableBasePairingStatus::kAuthenticated, "5678");
-  EXPECT_TRUE(test_api.detachable_base_error_bubble()->visible());
+  EXPECT_TRUE(test_api.detachable_base_error_bubble()->IsVisible());
 
   // The notification should be hidden if the base gets detached.
   detachable_base_model->SetPairingStatus(DetachableBasePairingStatus::kNone,
                                           "");
-  EXPECT_FALSE(test_api.detachable_base_error_bubble()->visible());
+  EXPECT_FALSE(test_api.detachable_base_error_bubble()->IsVisible());
 }
 
 TEST_F(LockContentsViewUnitTest, DetachableBaseErrorClearsAuthError) {
@@ -1182,7 +1136,7 @@
   LockContentsView::TestApi test_api(contents);
   ui::test::EventGenerator* generator = GetEventGenerator();
 
-  EXPECT_FALSE(test_api.detachable_base_error_bubble()->visible());
+  EXPECT_FALSE(test_api.detachable_base_error_bubble()->IsVisible());
 
   // Attempt and fail user auth - an auth error is expected to be shown.
   std::unique_ptr<MockLoginScreenClient> client = BindMockLoginScreenClient();
@@ -1195,8 +1149,8 @@
   generator->PressKey(ui::KeyboardCode::VKEY_RETURN, 0);
   base::RunLoop().RunUntilIdle();
 
-  EXPECT_TRUE(test_api.auth_error_bubble()->visible());
-  EXPECT_FALSE(test_api.detachable_base_error_bubble()->visible());
+  EXPECT_TRUE(test_api.auth_error_bubble()->IsVisible());
+  EXPECT_FALSE(test_api.detachable_base_error_bubble()->IsVisible());
 
   // Change detachable base to a base different than the one previously used by
   // the user - verify that a detachable base error bubble is shown, and the
@@ -1204,8 +1158,8 @@
   detachable_base_model->SetPairingStatus(
       DetachableBasePairingStatus::kAuthenticated, "5678");
 
-  EXPECT_TRUE(test_api.detachable_base_error_bubble()->visible());
-  EXPECT_FALSE(test_api.auth_error_bubble()->visible());
+  EXPECT_TRUE(test_api.detachable_base_error_bubble()->IsVisible());
+  EXPECT_FALSE(test_api.auth_error_bubble()->IsVisible());
 }
 
 TEST_F(LockContentsViewUnitTest, AuthErrorDoesNotRemoveDetachableBaseError) {
@@ -1233,7 +1187,7 @@
   LockContentsView::TestApi test_api(contents);
   ui::test::EventGenerator* generator = GetEventGenerator();
 
-  EXPECT_FALSE(test_api.detachable_base_error_bubble()->visible());
+  EXPECT_FALSE(test_api.detachable_base_error_bubble()->IsVisible());
 
   // Change detachable base to a base different than the one previously used by
   // the user - verify that a detachable base error bubble is shown, and the
@@ -1241,7 +1195,7 @@
   detachable_base_model->SetPairingStatus(
       DetachableBasePairingStatus::kAuthenticated, "5678");
 
-  EXPECT_TRUE(test_api.detachable_base_error_bubble()->visible());
+  EXPECT_TRUE(test_api.detachable_base_error_bubble()->IsVisible());
 
   // Attempt and fail user auth - an auth error is expected to be shown.
   // Detachable base error should not be hidden.
@@ -1258,15 +1212,15 @@
   generator->PressKey(ui::KeyboardCode::VKEY_RETURN, 0);
   base::RunLoop().RunUntilIdle();
 
-  EXPECT_TRUE(test_api.auth_error_bubble()->visible());
-  EXPECT_TRUE(test_api.detachable_base_error_bubble()->visible());
+  EXPECT_TRUE(test_api.auth_error_bubble()->IsVisible());
+  EXPECT_TRUE(test_api.detachable_base_error_bubble()->IsVisible());
 
   // User action, like pressing a key should close the auth error bubble, but
   // not the detachable base error bubble.
   generator->PressKey(ui::KeyboardCode::VKEY_A, 0);
 
-  EXPECT_TRUE(test_api.detachable_base_error_bubble()->visible());
-  EXPECT_FALSE(test_api.auth_error_bubble()->visible());
+  EXPECT_TRUE(test_api.detachable_base_error_bubble()->IsVisible());
+  EXPECT_FALSE(test_api.auth_error_bubble()->IsVisible());
 }
 
 TEST_F(LockContentsViewKeyboardUnitTest, SwitchPinAndVirtualKeyboard) {
@@ -1879,47 +1833,15 @@
   EXPECT_TRUE(HasFocusInAnyChildView(status_area));
 }
 
-// Tests parent access dialog showing and hiding.
-TEST_F(LockContentsViewUnitTest, ParentAccessDialog) {
-  auto* contents = new LockContentsView(
-      mojom::TrayActionState::kAvailable, LockScreen::ScreenType::kLock,
-      DataDispatcher(),
-      std::make_unique<FakeLoginDetachableBaseModel>(DataDispatcher()));
-  AddChildUsers(1);
-  SetWidget(CreateWidgetWithContent(contents));
-
-  LoginBigUserView* primary_view =
-      LockContentsView::TestApi(contents).primary_big_view();
-  LoginAuthUserView::TestApi auth_user =
-      LoginAuthUserView::TestApi(primary_view->auth_user());
-
-  EXPECT_TRUE(primary_view->auth_user());
-  EXPECT_FALSE(primary_view->parent_access());
-  EXPECT_TRUE(LoginPasswordView::TestApi(auth_user.password_view())
-                  .textfield()
-                  ->HasFocus());
-
-  DataDispatcher()->SetShowParentAccessDialog(true);
-
-  EXPECT_TRUE(primary_view->auth_user());
-  EXPECT_TRUE(primary_view->parent_access());
-  EXPECT_FALSE(LoginPasswordView::TestApi(auth_user.password_view())
-                   .textfield()
-                   ->HasFocus());
-  EXPECT_TRUE(HasFocusInAnyChildView(
-      ParentAccessView::TestApi(primary_view->parent_access())
-          .access_code_view()));
-
-  DataDispatcher()->SetShowParentAccessDialog(false);
-
-  EXPECT_TRUE(primary_view->auth_user());
-  EXPECT_FALSE(primary_view->parent_access());
-  EXPECT_TRUE(LoginPasswordView::TestApi(auth_user.password_view())
-                  .textfield()
-                  ->HasFocus());
-}
+class LockContentsViewPowerManagerUnitTest : public LockContentsViewUnitTest {
+ public:
+  void SetUp() override {
+    chromeos::DBusThreadManager::GetSetterForTesting()->SetPowerManagerClient(
+        std::make_unique<chromeos::FakePowerManagerClient>());
 
-using LockContentsViewPowerManagerUnitTest = LockContentsViewUnitTest;
+    LockContentsViewUnitTest::SetUp();
+  }
+};
 
 // Ensures that a PowerManagerClient::Observer is added on LockScreen::Show()
 // and removed on LockScreen::Destroy().
@@ -1928,12 +1850,16 @@
   ASSERT_NO_FATAL_FAILURE(ShowLockScreen());
   LockContentsView* contents =
       LockScreen::TestApi(LockScreen::Get()).contents_view();
-  EXPECT_TRUE(chromeos::PowerManagerClient::Get()->HasObserver(contents));
+  EXPECT_TRUE(
+      chromeos::DBusThreadManager::Get()->GetPowerManagerClient()->HasObserver(
+          contents));
 
   LockScreen::Get()->Destroy();
   // Wait for LockScreen to be fully destroyed
   base::RunLoop().RunUntilIdle();
-  EXPECT_FALSE(chromeos::PowerManagerClient::Get()->HasObserver(contents));
+  EXPECT_FALSE(
+      chromeos::DBusThreadManager::Get()->GetPowerManagerClient()->HasObserver(
+          contents));
 }
 
 // Verifies that the password box for the active user is cleared if a suspend
@@ -2113,19 +2039,19 @@
   ui::test::EventGenerator* generator = GetEventGenerator();
 
   // Creating lock screen does not show warning banner bubble.
-  EXPECT_FALSE(test_api.warning_banner_bubble()->visible());
+  EXPECT_FALSE(test_api.warning_banner_bubble()->IsVisible());
 
   // Verifies that a warning banner is shown by giving a non-empty message.
   DataDispatcher()->ShowWarningBanner(base::ASCIIToUTF16("foo"));
-  EXPECT_TRUE(test_api.warning_banner_bubble()->visible());
+  EXPECT_TRUE(test_api.warning_banner_bubble()->IsVisible());
 
   // Verifies that a warning banner is hidden by HideWarningBanner().
   DataDispatcher()->HideWarningBanner();
-  EXPECT_FALSE(test_api.warning_banner_bubble()->visible());
+  EXPECT_FALSE(test_api.warning_banner_bubble()->IsVisible());
 
   // Shows a warning banner again.
   DataDispatcher()->ShowWarningBanner(base::ASCIIToUTF16("foo"));
-  EXPECT_TRUE(test_api.warning_banner_bubble()->visible());
+  EXPECT_TRUE(test_api.warning_banner_bubble()->IsVisible());
 
   // Attempt and fail user auth - an auth error is expected to be shown.
   // The warning banner should not be hidden.
@@ -2142,8 +2068,8 @@
   generator->PressKey(ui::KeyboardCode::VKEY_RETURN, 0);
   base::RunLoop().RunUntilIdle();
 
-  EXPECT_TRUE(test_api.auth_error_bubble()->visible());
-  EXPECT_TRUE(test_api.warning_banner_bubble()->visible());
+  EXPECT_TRUE(test_api.auth_error_bubble()->IsVisible());
+  EXPECT_TRUE(test_api.warning_banner_bubble()->IsVisible());
 }
 
 TEST_F(LockContentsViewUnitTest, RemoveUserFocusMovesBackToPrimaryUser) {
@@ -2258,18 +2184,4 @@
   lock->AcceleratorPressed(ui::Accelerator(ui::VKEY_LEFT, 0));
 }
 
-TEST_F(LockContentsViewUnitTest, OnFocusLeavingSystemTrayWithNoUsers) {
-  auto* lock = new LockContentsView(
-      mojom::TrayActionState::kNotAvailable, LockScreen::ScreenType::kLock,
-      DataDispatcher(),
-      std::make_unique<FakeLoginDetachableBaseModel>(DataDispatcher()));
-  SetWidget(CreateWidgetWithContent(lock));
-
-  // Check that there is always a focusable view after transitioning focus.
-  lock->OnFocusLeavingSystemTray(false /* reverse */);
-  EXPECT_TRUE(lock->GetFocusManager()->GetFocusedView());
-  lock->OnFocusLeavingSystemTray(true /* reverse */);
-  EXPECT_TRUE(lock->GetFocusManager()->GetFocusedView());
-}
-
 }  // namespace ash
--- a/ash/login/ui/lock_debug_view.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/login/ui/lock_debug_view.cc	2019-05-17 18:53:08.172000000 +0300
@@ -24,7 +24,6 @@
 #include "ash/shelf/shelf_widget.h"
 #include "ash/shell.h"
 #include "ash/wallpaper/wallpaper_controller.h"
-#include "base/bind.h"
 #include "base/optional.h"
 #include "base/stl_util.h"
 #include "base/strings/utf_string_conversions.h"
@@ -57,7 +56,6 @@
   kGlobalCycleAuthErrorMessage,
   kGlobalToggleWarningBanner,
   kGlobalToggleManagedSessionDisclosure,
-  kGlobalToggleParentAccess,
   kPerUserTogglePin,
   kPerUserToggleTap,
   kPerUserCycleEasyUnlockState,
@@ -691,8 +689,6 @@
             toggle_container);
   AddButton("Toggle warning banner", ButtonId::kGlobalToggleWarningBanner,
             toggle_container);
-  AddButton("Toggle parent access", ButtonId::kGlobalToggleParentAccess,
-            toggle_container);
 
   auto* kiosk_container = add_horizontal_container();
   AddButton("Add kiosk app", ButtonId::kGlobalAddKioskApp, kiosk_container);
@@ -1002,12 +998,6 @@
     UpdatePerUserActionContainer();
     Layout();
   }
-
-  // Toggle parent access view.
-  if (sender->id() == ButtonId::kGlobalToggleParentAccess) {
-    is_parent_access_shown_ = !is_parent_access_shown_;
-    lock_->OnSetShowParentAccessDialog(is_parent_access_shown_);
-  }
 }
 
 void LockDebugView::UpdatePerUserActionContainer() {
--- a/ash/login/ui/lock_debug_view.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/login/ui/lock_debug_view.h	2019-05-17 18:53:08.172000000 +0300
@@ -111,9 +111,6 @@
   // shown.
   bool is_managed_session_disclosure_shown_ = false;
 
-  // Whether parent access view is shown.
-  bool is_parent_access_shown_ = false;
-
   DISALLOW_COPY_AND_ASSIGN(LockDebugView);
 };
 
--- a/ash/login/ui/lock_screen.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/login/ui/lock_screen.cc	2019-05-17 18:53:08.172000000 +0300
@@ -19,7 +19,6 @@
 #include "ash/shell.h"
 #include "ash/tray_action/tray_action.h"
 #include "ash/wallpaper/wallpaper_controller.h"
-#include "base/bind.h"
 #include "base/command_line.h"
 #include "chromeos/constants/chromeos_switches.h"
 #include "ui/display/display.h"
--- a/ash/login/ui/login_auth_user_view.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/login/ui/login_auth_user_view.cc	2019-05-17 18:53:08.176000000 +0300
@@ -27,12 +27,10 @@
 #include "ash/wallpaper/wallpaper_controller.h"
 #include "base/bind.h"
 #include "base/strings/utf_string_conversions.h"
-#include "base/timer/timer.h"
 #include "chromeos/dbus/dbus_thread_manager.h"
 #include "components/user_manager/user.h"
 #include "ui/accessibility/ax_node_data.h"
 #include "ui/base/l10n/l10n_util.h"
-#include "ui/base/resource/resource_bundle.h"
 #include "ui/compositor/callback_layer_animation_observer.h"
 #include "ui/compositor/layer_animation_sequence.h"
 #include "ui/compositor/layer_animator.h"
@@ -504,8 +502,7 @@
   password_view_->UpdateForUser(user);
 
   pin_view_ =
-      new LoginPinView(LoginPinView::Style::kAlphanumeric,
-                       base::BindRepeating(&LoginPasswordView::InsertNumber,
+      new LoginPinView(base::BindRepeating(&LoginPasswordView::InsertNumber,
                                            base::Unretained(password_view_)),
                        base::BindRepeating(&LoginPasswordView::Backspace,
                                            base::Unretained(password_view_)));
@@ -654,7 +651,8 @@
   external_binary_enrollment_button_->SetVisible(has_external_binary);
 
   if (has_external_binary) {
-    power_manager_client_observer_.Add(chromeos::PowerManagerClient::Get());
+    power_manager_client_observer_.Add(
+        chromeos::DBusThreadManager::Get()->GetPowerManagerClient());
   }
 
   int padding_view_height = kDistanceBetweenPasswordFieldAndPinKeyboardDp;
--- a/ash/login/ui/login_auth_user_view_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/login/ui/login_auth_user_view_unittest.cc	2019-05-17 18:53:08.176000000 +0300
@@ -12,7 +12,9 @@
 #include "base/bind_helpers.h"
 #include "base/run_loop.h"
 #include "base/strings/utf_string_conversions.h"
+#include "chromeos/dbus/dbus_thread_manager.h"
 #include "chromeos/dbus/fake_power_manager_client.h"
+#include "chromeos/dbus/power_manager_client.h"
 #include "testing/gtest/include/gtest/gtest.h"
 #include "ui/events/event_utils.h"
 #include "ui/events/test/event_generator.h"
@@ -34,6 +36,9 @@
 
   // LoginTestBase:
   void SetUp() override {
+    power_manager_ = new chromeos::FakePowerManagerClient();
+    chromeos::DBusThreadManager::GetSetterForTesting()->SetPowerManagerClient(
+        base::WrapUnique(power_manager_));
     LoginTestBase::SetUp();
 
     user_ = CreateUser("user@domain.com");
@@ -63,6 +68,8 @@
   mojom::LoginUserInfoPtr user_;
   views::View* container_ = nullptr;   // Owned by test widget view hierarchy.
   LoginAuthUserView* view_ = nullptr;  // Owned by test widget view hierarchy.
+  chromeos::FakePowerManagerClient* power_manager_ =
+      nullptr;  // Owned by DBusThreadmanager
 
  private:
   DISALLOW_COPY_AND_ASSIGN(LoginAuthUserViewUnittest);
@@ -204,8 +211,8 @@
                                ->current_user()
                                ->basic_user_info->account_id,
                            _));
-  power_manager_client()->SetLidState(
-      chromeos::PowerManagerClient::LidState::OPEN, base::TimeTicks::Now());
+  power_manager_->SetLidState(chromeos::PowerManagerClient::LidState::OPEN,
+                              base::TimeTicks::Now());
 
   base::RunLoop().RunUntilIdle();
 
--- a/ash/login/ui/login_base_bubble_view.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/login/ui/login_base_bubble_view.cc	2019-05-17 18:53:08.176000000 +0300
@@ -4,9 +4,6 @@
 
 #include "ash/login/ui/login_base_bubble_view.h"
 
-#include <memory>
-
-#include "ash/login/ui/views_utils.h"
 #include "ash/public/cpp/shell_window_ids.h"
 #include "ash/shell.h"
 #include "base/scoped_observer.h"
@@ -15,7 +12,6 @@
 #include "ui/compositor/layer_animator.h"
 #include "ui/compositor/scoped_layer_animation_settings.h"
 #include "ui/events/event_handler.h"
-#include "ui/views/background.h"
 #include "ui/views/layout/box_layout.h"
 #include "ui/wm/core/coordinate_conversion.h"
 
@@ -34,9 +30,6 @@
 // Bottom margin of the bubble view.
 constexpr int kBubbleBottomMarginDp = 18;
 
-// Spacing between the child view inside the bubble view.
-constexpr int kBubbleBetweenChildSpacingDp = 6;
-
 // The amount of time for bubble show/hide animation.
 constexpr base::TimeDelta kBubbleAnimationDuration =
     base::TimeDelta::FromMilliseconds(300);
@@ -45,10 +38,13 @@
 
 // This class handles keyboard, mouse, and focus events, and dismisses the
 // associated bubble in response.
-class LoginBubbleHandler : public ui::EventHandler {
+class LoginBubbleHandler : public ui::EventHandler,
+                           public aura::client::FocusChangeObserver {
  public:
   LoginBubbleHandler(LoginBaseBubbleView* bubble) : bubble_(bubble) {
     Shell::Get()->AddPreTargetHandler(this);
+    focus_observer_.Add(
+        aura::client::GetFocusClient(Shell::GetPrimaryRootWindow()));
   }
 
   ~LoginBubbleHandler() override { Shell::Get()->RemovePreTargetHandler(this); }
@@ -72,22 +68,37 @@
       return;
     }
 
-    if (!bubble_->visible())
+    if (!bubble_->IsVisible())
       return;
 
     if (bubble_->GetBubbleOpener() && bubble_->GetBubbleOpener()->HasFocus())
       return;
 
-    if (login_views_utils::HasFocusInAnyChildView(bubble_))
+    if (bubble_->GetWidget()->IsActive())
       return;
 
     if (!bubble_->IsPersistent())
       bubble_->Hide();
   }
 
+  // aura::client::FocusChangeObserver:
+  void OnWindowFocused(aura::Window* gained_focus,
+                       aura::Window* lost_focus) override {
+    if (!bubble_->IsVisible())
+      return;
+
+    if (gained_focus &&
+        bubble_->GetWidget()->GetNativeView()->Contains(gained_focus)) {
+      return;
+    }
+
+    if (!bubble_->IsPersistent())
+      bubble_->Hide();
+  }
+
  private:
   void ProcessPressedEvent(const ui::LocatedEvent* event) {
-    if (!bubble_->visible())
+    if (!bubble_->IsVisible())
       return;
 
     gfx::Point screen_location = event->location();
@@ -111,6 +122,9 @@
 
   LoginBaseBubbleView* bubble_;
 
+  ScopedObserver<aura::client::FocusClient, aura::client::FocusChangeObserver>
+      focus_observer_{this};
+
   DISALLOW_COPY_AND_ASSIGN(LoginBubbleHandler);
 };
 
@@ -119,28 +133,36 @@
 
 LoginBaseBubbleView::LoginBaseBubbleView(views::View* anchor_view,
                                          aura::Window* parent_window)
-    : anchor_view_(anchor_view),
+    : BubbleDialogDelegateView(anchor_view, views::BubbleBorder::NONE),
       bubble_handler_(std::make_unique<LoginBubbleHandler>(this)) {
-  SetLayoutManager(std::make_unique<views::BoxLayout>(
-      views::BoxLayout::kVertical,
-      gfx::Insets(kBubbleTopMarginDp, kBubbleHorizontalMarginDp,
-                  kBubbleBottomMarginDp, kBubbleHorizontalMarginDp),
-      kBubbleBetweenChildSpacingDp));
-
-  SetVisible(false);
-  SetBackground(views::CreateSolidBackground(SK_ColorBLACK));
+  set_margins(gfx::Insets(kBubbleTopMarginDp, kBubbleHorizontalMarginDp,
+                          kBubbleBottomMarginDp, kBubbleHorizontalMarginDp));
+  set_color(SK_ColorBLACK);
+  set_can_activate(false);
+  set_close_on_deactivate(false);
 
   // Layer rendering is needed for animation.
   SetPaintToLayer();
+  layer()->SetFillsBoundsOpaquely(false);
+
+  set_parent_window(parent_window);
 }
 
 LoginBaseBubbleView::~LoginBaseBubbleView() = default;
 
 void LoginBaseBubbleView::Show() {
+  views::Widget* widget = GetWidget();
+
+  if (!widget)
+    widget = views::BubbleDialogDelegateView::CreateBubble(this);
+
   layer()->GetAnimator()->RemoveObserver(this);
 
-  SetSize(GetPreferredSize());
-  SetPosition(CalculatePosition());
+  Layout();
+  SizeToContents();
+
+  widget->ShowInactive();
+  widget->StackAtTop();
 
   ScheduleAnimation(true /*visible*/);
 
@@ -150,9 +172,14 @@
 }
 
 void LoginBaseBubbleView::Hide() {
+  if (GetWidget())
   ScheduleAnimation(false /*visible*/);
 }
 
+bool LoginBaseBubbleView::IsVisible() {
+  return GetWidget() && GetWidget()->IsVisible();
+}
+
 LoginButton* LoginBaseBubbleView::GetBubbleOpener() const {
   return nullptr;
 }
@@ -163,25 +190,31 @@
 
 void LoginBaseBubbleView::SetPersistent(bool persistent) {}
 
-gfx::Point LoginBaseBubbleView::CalculatePosition() {
-  if (GetAnchorView()) {
-    gfx::Point bottom_left = GetAnchorView()->bounds().bottom_left();
-    ConvertPointToTarget(GetAnchorView()->parent() /*source*/,
-                         parent() /*target*/, &bottom_left);
-    return bottom_left;
+void LoginBaseBubbleView::OnBeforeBubbleWidgetInit(
+    views::Widget::InitParams* params,
+    views::Widget* widget) const {
+  // This case only gets called if the bubble has no anchor and no parent
+  // container was specified. In this case, the parent container should default
+  // to MenuContainer, so that login bubbles are visible over the shelf and
+  // virtual keyboard. Shell may be null in tests.
+  if (!params->parent && Shell::HasInstance()) {
+    params->parent = Shell::GetContainer(Shell::GetPrimaryRootWindow(),
+                                         kShellWindowId_MenuContainer);
   }
+}
 
-  return gfx::Point();
+int LoginBaseBubbleView::GetDialogButtons() const {
+  return ui::DIALOG_BUTTON_NONE;
 }
 
 void LoginBaseBubbleView::SetAnchorView(views::View* anchor_view) {
-  anchor_view_ = anchor_view;
+  views::BubbleDialogDelegateView::SetAnchorView(anchor_view);
 }
 
 void LoginBaseBubbleView::OnLayerAnimationEnded(
     ui::LayerAnimationSequence* sequence) {
   layer()->GetAnimator()->RemoveObserver(this);
-  SetVisible(false);
+  GetWidget()->Hide();
 }
 
 gfx::Size LoginBaseBubbleView::CalculatePreferredSize() const {
@@ -191,20 +224,15 @@
   return size;
 }
 
-void LoginBaseBubbleView::Layout() {
-  views::View::Layout();
-
-  // If a Layout() is called while the bubble is visible (i.e. due to Show()),
-  // its bounds may change because of the parent's LayoutManager. This allows
-  // the bubbles to always determine their own size and position.
-  if (visible()) {
-    SetSize(GetPreferredSize());
-    SetPosition(CalculatePosition());
-  }
+void LoginBaseBubbleView::OnWidgetVisibilityChanged(views::Widget* widget,
+                                                    bool visible) {
+  if (visible)
+    EnsureInScreen();
 }
 
-void LoginBaseBubbleView::OnBlur() {
-  Hide();
+void LoginBaseBubbleView::OnWidgetBoundsChanged(views::Widget* widget,
+                                                const gfx::Rect& new_bounds) {
+  EnsureInScreen();
 }
 
 void LoginBaseBubbleView::ScheduleAnimation(bool visible) {
@@ -223,8 +251,6 @@
     std::swap(opacity_start, opacity_end);
     // We only need to handle animation ending if we're hiding the bubble.
     layer()->GetAnimator()->AddObserver(this);
-  } else {
-    SetVisible(true);
   }
 
   layer()->SetOpacity(opacity_start);
@@ -238,4 +264,26 @@
   }
 }
 
+void LoginBaseBubbleView::EnsureInScreen() {
+  DCHECK(GetWidget());
+
+  const gfx::Rect view_bounds = GetBoundsInScreen();
+  const gfx::Rect work_area =
+      display::Screen::GetScreen()
+          ->GetDisplayNearestWindow(GetWidget()->GetNativeWindow())
+          .work_area();
+
+  int horizontal_offset = 0;
+
+  // If the widget extends past the right side of the screen, make it go to
+  // the left instead.
+  if (work_area.right() < view_bounds.right()) {
+    horizontal_offset = -view_bounds.width();
+  }
+
+  set_anchor_view_insets(
+      anchor_view_insets().Offset(gfx::Vector2d(horizontal_offset, 0)));
+  OnAnchorBoundsChanged();
+}
+
 }  // namespace ash
--- a/ash/login/ui/login_base_bubble_view.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/login/ui/login_base_bubble_view.h	2019-05-17 18:53:08.176000000 +0300
@@ -17,7 +17,7 @@
 class LoginBubbleHandler;
 
 // Base bubble view for login screen bubbles.
-class ASH_EXPORT LoginBaseBubbleView : public views::View,
+class ASH_EXPORT LoginBaseBubbleView : public views::BubbleDialogDelegateView,
                                        public ui::LayerAnimationObserver {
  public:
   // Without specifying a parent_window, the bubble will default to being in the
@@ -30,6 +30,8 @@
   void Show();
   void Hide();
 
+  bool IsVisible();
+
   // Returns the button responsible for opening this bubble.
   virtual LoginButton* GetBubbleOpener() const;
 
@@ -38,27 +40,29 @@
   // Change the persistence of the bubble.
   virtual void SetPersistent(bool persistent);
 
-  // Determine the position of the bubble prior to showing.
-  virtual gfx::Point CalculatePosition();
-
+  // views::BubbleDialogDelegateView:
+  void OnBeforeBubbleWidgetInit(views::Widget::InitParams* params,
+                                views::Widget* widget) const override;
+  int GetDialogButtons() const override;
   void SetAnchorView(views::View* anchor_view);
-  views::View* GetAnchorView() const { return anchor_view_; }
 
   // ui::LayerAnimationObserver:
   void OnLayerAnimationEnded(ui::LayerAnimationSequence* sequence) override;
-  void OnLayerAnimationAborted(ui::LayerAnimationSequence* sequence) override {}
+  void OnLayerAnimationAborted(ui::LayerAnimationSequence* sequence) override{};
   void OnLayerAnimationScheduled(
-      ui::LayerAnimationSequence* sequence) override {}
+      ui::LayerAnimationSequence* sequence) override{};
 
   // views::View:
   gfx::Size CalculatePreferredSize() const override;
-  void Layout() override;
-  void OnBlur() override;
+
+  // views::WidgetObserver:
+  void OnWidgetVisibilityChanged(views::Widget* widget, bool visible) override;
+  void OnWidgetBoundsChanged(views::Widget* widget,
+                             const gfx::Rect& new_bounds) override;
 
  private:
   void ScheduleAnimation(bool visible);
-
-  views::View* anchor_view_;
+  void EnsureInScreen();
 
   std::unique_ptr<LoginBubbleHandler> bubble_handler_;
 
--- a/ash/login/ui/login_base_bubble_view_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/login/ui/login_base_bubble_view_unittest.cc	2019-05-17 18:53:08.176000000 +0300
@@ -15,6 +15,15 @@
 namespace {
 // Total width of the bubble view.
 constexpr int kBubbleTotalWidthDp = 178;
+
+// Horizontal margin of the bubble view.
+constexpr int kBubbleHorizontalMarginDp = 14;
+
+// Top margin of the bubble view.
+constexpr int kBubbleTopMarginDp = 13;
+
+// Bottom margin of the bubble view.
+constexpr int kBubbleBottomMarginDp = 18;
 }  // namespace
 
 class LoginBaseBubbleViewTest : public LoginTestBase {
@@ -27,7 +36,6 @@
     LoginTestBase::SetUp();
 
     anchor_ = new views::View();
-    anchor_->SetSize(gfx::Size(0, 25));
     container_ = new views::View();
     container_->SetLayoutManager(
         std::make_unique<views::BoxLayout>(views::BoxLayout::kVertical));
@@ -42,8 +50,6 @@
     bubble_->SetLayoutManager(
         std::make_unique<views::BoxLayout>(views::BoxLayout::kVertical));
     bubble_->AddChildView(label);
-
-    container_->AddChildView(bubble_);
   }
 
   LoginBaseBubbleView* bubble_;
@@ -55,54 +61,58 @@
 };
 
 TEST_F(LoginBaseBubbleViewTest, BasicProperties) {
-  EXPECT_FALSE(bubble_->visible());
+  EXPECT_FALSE(bubble_->IsVisible());
 
   bubble_->Show();
-  EXPECT_TRUE(bubble_->visible());
+  EXPECT_TRUE(bubble_->IsVisible());
 
+  EXPECT_EQ(bubble_->GetDialogButtons(), ui::DIALOG_BUTTON_NONE);
   EXPECT_EQ(bubble_->width(), kBubbleTotalWidthDp);
-  EXPECT_EQ(bubble_->background()->get_color(), SK_ColorBLACK);
+  EXPECT_EQ(bubble_->color(), SK_ColorBLACK);
+  EXPECT_EQ(bubble_->margins(),
+            gfx::Insets(kBubbleTopMarginDp, kBubbleHorizontalMarginDp,
+                        kBubbleBottomMarginDp, kBubbleHorizontalMarginDp));
 
   bubble_->Hide();
-  EXPECT_FALSE(bubble_->visible());
+  EXPECT_FALSE(bubble_->IsVisible());
 }
 
 TEST_F(LoginBaseBubbleViewTest, KeyEventHandling) {
-  EXPECT_FALSE(bubble_->visible());
+  EXPECT_FALSE(bubble_->IsVisible());
 
   // Verify that a random key event won't open the bubble.
   ui::test::EventGenerator* generator = GetEventGenerator();
   container_->RequestFocus();
   generator->PressKey(ui::KeyboardCode::VKEY_A, ui::EF_NONE);
-  EXPECT_FALSE(bubble_->visible());
+  EXPECT_FALSE(bubble_->IsVisible());
 
   // Verify that a key event will close the bubble if it is open.
   bubble_->Show();
-  EXPECT_TRUE(bubble_->visible());
+  EXPECT_TRUE(bubble_->IsVisible());
   generator->PressKey(ui::KeyboardCode::VKEY_A, ui::EF_NONE);
-  EXPECT_FALSE(bubble_->visible());
+  EXPECT_FALSE(bubble_->IsVisible());
 }
 
 TEST_F(LoginBaseBubbleViewTest, MouseEventHandling) {
-  EXPECT_FALSE(bubble_->visible());
+  EXPECT_FALSE(bubble_->IsVisible());
 
   // Verify that a random mouse event won't open the bubble.
   ui::test::EventGenerator* generator = GetEventGenerator();
   generator->MoveMouseTo(container_->GetBoundsInScreen().CenterPoint());
   generator->ClickLeftButton();
-  EXPECT_FALSE(bubble_->visible());
+  EXPECT_FALSE(bubble_->IsVisible());
 
   // Verify that a click event on the bubble won't close it.
   bubble_->Show();
-  EXPECT_TRUE(bubble_->visible());
+  EXPECT_TRUE(bubble_->IsVisible());
   generator->MoveMouseTo(bubble_->GetBoundsInScreen().CenterPoint());
   generator->ClickLeftButton();
-  EXPECT_TRUE(bubble_->visible());
+  EXPECT_TRUE(bubble_->IsVisible());
 
   // Verify that a click event outside the bubble will close it if it is open.
   generator->MoveMouseTo(anchor_->GetBoundsInScreen().CenterPoint());
   generator->ClickLeftButton();
-  EXPECT_FALSE(bubble_->visible());
+  EXPECT_FALSE(bubble_->IsVisible());
 }
 
 }  // namespace ash
--- a/ash/login/ui/login_big_user_view.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/login/ui/login_big_user_view.cc	2019-05-17 18:53:08.176000000 +0300
@@ -6,7 +6,6 @@
 #include "ash/public/cpp/login_constants.h"
 #include "ash/shell.h"
 #include "ash/wallpaper/wallpaper_controller.h"
-#include "components/account_id/account_id.h"
 #include "ui/views/background.h"
 #include "ui/views/layout/fill_layout.h"
 
@@ -18,10 +17,6 @@
   return user->basic_user_info->type == user_manager::USER_TYPE_PUBLIC_ACCOUNT;
 }
 
-bool IsChildAccountUser(const mojom::LoginUserInfoPtr& user) {
-  return user->basic_user_info->type == user_manager::USER_TYPE_CHILD;
-}
-
 // Returns true if either a or b have a value, but not both.
 bool OnlyOneSet(views::View* a, views::View* b) {
   return !!a ^ !!b;
@@ -32,17 +27,12 @@
 LoginBigUserView::LoginBigUserView(
     const mojom::LoginUserInfoPtr& user,
     const LoginAuthUserView::Callbacks& auth_user_callbacks,
-    const LoginPublicAccountUserView::Callbacks& public_account_callbacks,
-    const ParentAccessView::Callbacks& parent_access_callbacks)
+    const LoginPublicAccountUserView::Callbacks& public_account_callbacks)
     : NonAccessibleView(),
       auth_user_callbacks_(auth_user_callbacks),
-      public_account_callbacks_(public_account_callbacks),
-      parent_access_callbacks_(parent_access_callbacks) {
+      public_account_callbacks_(public_account_callbacks) {
   SetLayoutManager(std::make_unique<views::FillLayout>());
-  // Creates either |auth_user_| or |public_account_|. |parent_access_| cannot
-  // be used as a standalone view, it is only used together with |auth_user_|.
   CreateChildView(user);
-  DCHECK(!parent_access_);
 
   observer_.Add(Shell::Get()->wallpaper_controller());
   // Adding the observer will not run OnWallpaperBlurChanged; run it now to set
@@ -63,99 +53,44 @@
   // Rebuild child view for the following swap case:
   // 1. Public Account -> Auth User
   // 2. Auth User      -> Public Account
-  // If swap is performed when |parent_access_| is shown, both |parent_access_|
-  // and |auth_user_| will be destroyed and replaced with |public_user_|.
   if (IsPublicAccountUser(user) != IsPublicAccountUser(GetCurrentUser()))
     CreateChildView(user);
 
   DCHECK(OnlyOneSet(public_account_, auth_user_));
-  if (public_account_) {
-    DCHECK(!parent_access_);
+  if (public_account_)
     public_account_->UpdateForUser(user);
-  }
   if (auth_user_)
     auth_user_->UpdateForUser(user);
 }
 
-void LoginBigUserView::ShowParentAccessView() {
-  // Can be only combined with |auth_user_|.
-  DCHECK(OnlyOneSet(public_account_, auth_user_));
-  DCHECK(auth_user_);
-
-  // Do not show parent access if LoginBigUserView does not host regular user
-  // view or if ParentAccessView is already shown.
-  if (!auth_user_ || parent_access_)
-    return;
-
-  DCHECK(IsChildAccountUser(auth_user_->current_user()));
-  parent_access_ = new ParentAccessView(
-      auth_user_->current_user()->basic_user_info->account_id,
-      parent_access_callbacks_);
-  RemoveChildView(auth_user_);
-  AddChildView(parent_access_);
-  RequestFocus();
-}
-
-void LoginBigUserView::HideParentAccessView() {
-  // Can be only combined with |auth_user_|.
-  DCHECK(OnlyOneSet(public_account_, auth_user_));
-  DCHECK(auth_user_);
-
-  if (!auth_user_)
-    return;
-
-  DCHECK(IsChildAccountUser(auth_user_->current_user()));
-  DCHECK(parent_access_);
-  delete parent_access_;
-  parent_access_ = nullptr;
-  AddChildView(auth_user_);
-  RequestFocus();
-}
-
 const mojom::LoginUserInfoPtr& LoginBigUserView::GetCurrentUser() const {
   DCHECK(OnlyOneSet(public_account_, auth_user_));
-  if (public_account_) {
-    DCHECK(!parent_access_);
+  if (public_account_)
     return public_account_->current_user();
-  }
   return auth_user_->current_user();
 }
 
 LoginUserView* LoginBigUserView::GetUserView() {
   DCHECK(OnlyOneSet(public_account_, auth_user_));
-  if (public_account_) {
-    DCHECK(!parent_access_);
+  if (public_account_)
     return public_account_->user_view();
-  }
   return auth_user_->user_view();
 }
 
 bool LoginBigUserView::IsAuthEnabled() const {
   DCHECK(OnlyOneSet(public_account_, auth_user_));
-  if (public_account_) {
-    DCHECK(!parent_access_);
+  if (public_account_)
     return public_account_->auth_enabled();
-  }
   return auth_user_->auth_methods() != LoginAuthUserView::AUTH_NONE;
 }
 
 void LoginBigUserView::RequestFocus() {
   DCHECK(OnlyOneSet(public_account_, auth_user_));
-  if (public_account_) {
-    DCHECK(!parent_access_);
+  if (public_account_)
     return public_account_->RequestFocus();
-  }
-  if (parent_access_) {
-    DCHECK(auth_user_);
-    return parent_access_->RequestFocus();
-  }
   return auth_user_->RequestFocus();
 }
 
-void LoginBigUserView::ChildPreferredSizeChanged(views::View* child) {
-  parent()->Layout();
-}
-
 void LoginBigUserView::OnWallpaperBlurChanged() {
   if (Shell::Get()->wallpaper_controller()->IsWallpaperBlurred()) {
     SetPaintToLayer(ui::LayerType::LAYER_NOT_DRAWN);
@@ -174,7 +109,6 @@
 void LoginBigUserView::CreateAuthUser(const mojom::LoginUserInfoPtr& user) {
   DCHECK(!IsPublicAccountUser(user));
   DCHECK(!auth_user_);
-  DCHECK(!parent_access_);
 
   auth_user_ = new LoginAuthUserView(user, auth_user_callbacks_);
   delete public_account_;
@@ -189,10 +123,6 @@
 
   public_account_ =
       new LoginPublicAccountUserView(user, public_account_callbacks_);
-  if (parent_access_) {
-    delete parent_access_;
-    parent_access_ = nullptr;
-  }
   delete auth_user_;
   auth_user_ = nullptr;
   AddChildView(public_account_);
--- a/ash/login/ui/login_big_user_view.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/login/ui/login_big_user_view.h	2019-05-17 18:53:08.176000000 +0300
@@ -10,7 +10,6 @@
 #include "ash/login/ui/login_public_account_user_view.h"
 #include "ash/login/ui/login_user_view.h"
 #include "ash/login/ui/non_accessible_view.h"
-#include "ash/login/ui/parent_access_view.h"
 #include "ash/public/interfaces/user_info.mojom.h"
 #include "ash/wallpaper/wallpaper_controller_observer.h"
 
@@ -22,57 +21,31 @@
 // which has one of the following views as its only child:
 //  - LoginAuthUserView: for regular user.
 //  - LoginPublicAccountUserView: for public account user.
-//  - ParentAccessView: for child user when parent access was requested
-//    (it is swapped with LoginAuthUserView).
-// ParentAccessView cannot be used as a standalone view, it is only used
-// together with LoginAuthUserView. ParentAccessView cannot be used with
-// LoginPublicAccountUserView.
 class ASH_EXPORT LoginBigUserView : public NonAccessibleView,
                                     public WallpaperControllerObserver {
  public:
   LoginBigUserView(
       const mojom::LoginUserInfoPtr& user,
       const LoginAuthUserView::Callbacks& auth_user_callbacks,
-      const LoginPublicAccountUserView::Callbacks& public_account_callbacks,
-      const ParentAccessView::Callbacks& parent_access_callbacks);
+      const LoginPublicAccountUserView::Callbacks& public_account_callbacks);
   ~LoginBigUserView() override;
 
-  // Base on the user type, call CreateAuthUser or CreatePublicAccount.
+  // Base on the user type, call CreateAuthUser or CreatePublicAccount;
   void CreateChildView(const mojom::LoginUserInfoPtr& user);
 
   // Update the displayed name, icon, etc to that of |user|.
-  // It is safe to call it when ParentAccessView is shown.
-  // LoginPublicAccountUserView, even if not visible, will be updated and the
-  // result will be displayed after ParentAccessView is dismissed.
   void UpdateForUser(const mojom::LoginUserInfoPtr& user);
 
-  // Replaces LoginAuthUserView with ParentAccessView. Does not destroy
-  // LoginAuthUserView. Should not be called for LoginBigUserView that contains
-  // LoginPublicAccountUserView.
-  void ShowParentAccessView();
-
-  // Replaces ParentAccessView with previously stored LoginAuthUserView.
-  // Destroys ParentAccessView. Should not be called for LoginBigUserView that
-  // contains LoginPublicAccountUserView. Should only be called if
-  // ShowParentAccessView() was called before.
-  void HideParentAccessView();
-
-  // Safe to call in any state.
   const mojom::LoginUserInfoPtr& GetCurrentUser() const;
-
-  // Safe to call in any state.
   LoginUserView* GetUserView();
 
-  // Safe to call in any state.
   bool IsAuthEnabled() const;
 
   LoginPublicAccountUserView* public_account() { return public_account_; }
   LoginAuthUserView* auth_user() { return auth_user_; }
-  ParentAccessView* parent_access() { return parent_access_; }
 
   // views::View:
   void RequestFocus() override;
-  void ChildPreferredSizeChanged(views::View* child) override;
 
   // WallpaperControllerObserver:
   void OnWallpaperBlurChanged() override;
@@ -83,21 +56,15 @@
   void CreateAuthUser(const mojom::LoginUserInfoPtr& user);
 
   // Create LoginPublicAccountUserView and add it as child view.
-  // |auth_user_| and |parent_acesss_| will be deleted if exists to ensure the
-  // single child.
+  // |auth_user_| will be deleted if exists to ensure the single child.
   void CreatePublicAccount(const mojom::LoginUserInfoPtr& user);
 
   // Either |auth_user_| or |public_account_| must be null.
   LoginPublicAccountUserView* public_account_ = nullptr;
   LoginAuthUserView* auth_user_ = nullptr;
 
-  // It can be only used together with |auth_user_|. It is disallowed with
-  // |public_account_|.
-  ParentAccessView* parent_access_ = nullptr;
-
   LoginAuthUserView::Callbacks auth_user_callbacks_;
   LoginPublicAccountUserView::Callbacks public_account_callbacks_;
-  ParentAccessView::Callbacks parent_access_callbacks_;
 
   ScopedObserver<WallpaperController, LoginBigUserView> observer_{this};
 
--- a/ash/login/ui/login_data_dispatcher.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/login/ui/login_data_dispatcher.cc	2019-05-17 18:53:08.176000000 +0300
@@ -75,8 +75,6 @@
 void LoginDataDispatcher::Observer::OnDetachableBasePairingStatusChanged(
     DetachableBasePairingStatus pairing_status) {}
 
-void LoginDataDispatcher::Observer::OnSetShowParentAccessDialog(bool show) {}
-
 LoginDataDispatcher::LoginDataDispatcher() = default;
 
 LoginDataDispatcher::~LoginDataDispatcher() = default;
@@ -210,9 +208,4 @@
     observer.OnDetachableBasePairingStatusChanged(pairing_status);
 }
 
-void LoginDataDispatcher::SetShowParentAccessDialog(bool show) {
-  for (auto& observer : observers_)
-    observer.OnSetShowParentAccessDialog(show);
-}
-
 }  // namespace ash
--- a/ash/login/ui/login_data_dispatcher.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/login/ui/login_data_dispatcher.h	2019-05-17 18:53:08.176000000 +0300
@@ -122,9 +122,6 @@
     // base is attached or detached.
     virtual void OnDetachableBasePairingStatusChanged(
         DetachableBasePairingStatus pairing_status);
-
-    // Called when parent access code input dialog visibility should change.
-    virtual void OnSetShowParentAccessDialog(bool show);
   };
 
   LoginDataDispatcher();
@@ -167,7 +164,6 @@
       bool show_full_management_disclosure);
   void SetDetachableBasePairingStatus(
       DetachableBasePairingStatus pairing_status);
-  void SetShowParentAccessDialog(bool show);
 
  private:
   base::ObserverList<Observer>::Unchecked observers_;
--- a/ash/login/ui/login_error_bubble.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/login/ui/login_error_bubble.cc	2019-05-17 18:53:08.176000000 +0300
@@ -17,20 +17,48 @@
 namespace ash {
 namespace {
 
+// Vertical spacing between the anchor view and error bubble.
+constexpr int kAnchorViewErrorBubbleVerticalSpacingDp = 48;
+
 // The size of the alert icon in the error bubble.
 constexpr int kAlertIconSizeDp = 20;
 
+// Margin/inset of the entries for the user menu.
+constexpr int kUserMenuMarginWidth = 14;
+constexpr int kUserMenuMarginHeight = 18;
+
+// Spacing between the child view inside the bubble view.
+constexpr int kBubbleBetweenChildSpacingDp = 6;
+
 }  // namespace
 
-LoginErrorBubble::LoginErrorBubble()
-    : LoginErrorBubble(nullptr /*content*/,
-                       nullptr /*anchor_view*/,
-                       false /*is_persistent*/) {}
+// static
+LoginErrorBubble* LoginErrorBubble::CreateDefault() {
+  aura::Window* menu_container = Shell::GetContainer(
+      Shell::GetPrimaryRootWindow(), kShellWindowId_MenuContainer);
+  return new LoginErrorBubble(nullptr /* content */, nullptr /*anchor_view*/,
+                              menu_container /*parent_container*/,
+                              false /*is_persistent*/);
+}
 
 LoginErrorBubble::LoginErrorBubble(views::View* content,
                                    views::View* anchor_view,
+                                   aura::Window* parent_container,
                                    bool is_persistent)
-    : LoginBaseBubbleView(anchor_view), is_persistent_(is_persistent) {
+    : LoginBaseBubbleView(anchor_view, parent_container),
+      is_persistent_(is_persistent) {
+  set_anchor_view_insets(
+      gfx::Insets(kAnchorViewErrorBubbleVerticalSpacingDp, 0));
+
+  gfx::Insets margins(kUserMenuMarginHeight, kUserMenuMarginWidth);
+
+  set_margins(gfx::Insets(0, margins.left(), 0, margins.right()));
+
+  SetLayoutManager(std::make_unique<views::BoxLayout>(
+      views::BoxLayout::kVertical,
+      gfx::Insets(margins.top(), 0, margins.bottom(), 0),
+      kBubbleBetweenChildSpacingDp));
+
   auto* alert_view = new NonAccessibleView("AlertIconContainer");
   alert_view->SetLayoutManager(
       std::make_unique<views::BoxLayout>(views::BoxLayout::kHorizontal));
@@ -65,16 +93,6 @@
   is_persistent_ = persistent;
 }
 
-gfx::Size LoginErrorBubble::CalculatePreferredSize() const {
-  gfx::Size size;
-
-  if (GetAnchorView())
-    size.set_width(GetAnchorView()->width());
-
-  size.set_height(GetHeightForWidth(size.width()));
-  return size;
-}
-
 const char* LoginErrorBubble::GetClassName() const {
   return "LoginErrorBubble";
 }
--- a/ash/login/ui/login_error_bubble.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/login/ui/login_error_bubble.h	2019-05-17 18:53:08.176000000 +0300
@@ -13,9 +13,14 @@
 
 class ASH_EXPORT LoginErrorBubble : public LoginBaseBubbleView {
  public:
-  LoginErrorBubble();
+  // Factory method to create a non-persistent error bubble in the Ash menu
+  // container. The caller should manually Close() or delete the bubble, or
+  // else it will persist for the full lifetime of the Ash menu container.
+  static LoginErrorBubble* CreateDefault();
+
   LoginErrorBubble(views::View* content,
                    views::View* anchor_view,
+                   aura::Window* parent_container,
                    bool is_persistent);
   ~LoginErrorBubble() override;
 
@@ -26,7 +31,6 @@
   void SetPersistent(bool persistent) override;
 
   // views::View:
-  gfx::Size CalculatePreferredSize() const override;
   const char* GetClassName() const override;
   void GetAccessibleNodeData(ui::AXNodeData* node_data) override;
 
--- a/ash/login/ui/login_error_bubble_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/login/ui/login_error_bubble_unittest.cc	2019-05-17 18:53:08.176000000 +0300
@@ -27,32 +27,31 @@
                                  views::style::STYLE_PRIMARY);
 
   auto* bubble = new LoginErrorBubble(label /*content*/, anchor_view,
+                                      widget()->GetNativeView() /*container*/,
                                       true /*is_persistent*/);
-  container->AddChildView(bubble);
-
-  EXPECT_FALSE(bubble->visible());
+  EXPECT_FALSE(bubble->IsVisible());
 
   bubble->Show();
-  EXPECT_TRUE(bubble->visible());
+  EXPECT_TRUE(bubble->IsVisible());
 
   ui::test::EventGenerator* generator = GetEventGenerator();
 
   generator->MoveMouseTo(anchor_view->GetBoundsInScreen().CenterPoint());
   generator->ClickLeftButton();
-  EXPECT_TRUE(bubble->visible());
+  EXPECT_TRUE(bubble->IsVisible());
 
   generator->MoveMouseTo(bubble->GetBoundsInScreen().CenterPoint());
   generator->ClickLeftButton();
-  EXPECT_TRUE(bubble->visible());
+  EXPECT_TRUE(bubble->IsVisible());
 
   generator->GestureTapAt(anchor_view->GetBoundsInScreen().CenterPoint());
-  EXPECT_TRUE(bubble->visible());
+  EXPECT_TRUE(bubble->IsVisible());
 
   generator->GestureTapAt(bubble->GetBoundsInScreen().CenterPoint());
-  EXPECT_TRUE(bubble->visible());
+  EXPECT_TRUE(bubble->IsVisible());
 
   generator->PressKey(ui::KeyboardCode::VKEY_A, ui::EF_NONE);
-  EXPECT_TRUE(bubble->visible());
+  EXPECT_TRUE(bubble->IsVisible());
 }
 
 }  // namespace ash
--- a/ash/login/ui/login_expanded_public_account_view.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/login/ui/login_expanded_public_account_view.cc	2019-05-17 18:53:08.176000000 +0300
@@ -13,12 +13,9 @@
 #include "ash/login/ui/login_button.h"
 #include "ash/login/ui/login_user_view.h"
 #include "ash/login/ui/public_account_warning_dialog.h"
-#include "ash/login/ui/views_utils.h"
 #include "ash/resources/vector_icons/vector_icons.h"
 #include "ash/shell.h"
 #include "ash/strings/grit/ash_strings.h"
-#include "base/bind.h"
-#include "base/bind_helpers.h"
 #include "base/strings/utf_string_conversions.h"
 #include "components/vector_icons/vector_icons.h"
 #include "ui/base/l10n/l10n_util.h"
@@ -416,10 +413,20 @@
           current_user_->basic_user_info->account_id,
           selected_language_item_.value, selected_keyboard_item_.value);
     } else if (sender == language_selection_) {
-      DCHECK(language_menu_view_);
-      if (language_menu_view_->visible()) {
+      if (language_menu_view_ && language_menu_view_->IsVisible()) {
         language_menu_view_->Hide();
       } else {
+        if (language_menu_view_) {
+          language_menu_view_->GetWidget()->Close();
+          language_menu_view_ = nullptr;
+        }
+
+        language_menu_view_ = new LoginMenuView(
+            language_items_, language_selection_ /*anchor_view*/,
+            language_selection_ /*bubble_opener*/,
+            base::BindRepeating(&RightPaneView::OnLanguageSelected,
+                                weak_factory_.GetWeakPtr()));
+
         bool opener_had_focus = language_selection_->HasFocus();
 
         language_menu_view_->Show();
@@ -428,10 +435,19 @@
           language_menu_view_->RequestFocus();
       }
     } else if (sender == keyboard_selection_) {
-      DCHECK(keyboard_menu_view_);
-      if (keyboard_menu_view_->visible()) {
+      if (keyboard_menu_view_ && keyboard_menu_view_->IsVisible()) {
         keyboard_menu_view_->Hide();
       } else {
+        if (keyboard_menu_view_) {
+          keyboard_menu_view_->GetWidget()->Close();
+          keyboard_menu_view_ = nullptr;
+        }
+
+        keyboard_menu_view_ = new LoginMenuView(
+            keyboard_items_, keyboard_selection_ /*anchor_view*/,
+            keyboard_selection_ /*bubble_opener*/,
+            base::BindRepeating(&RightPaneView::OnKeyboardSelected,
+                                weak_factory_.GetWeakPtr()));
         bool opener_had_focus = keyboard_selection_->HasFocus();
 
         keyboard_menu_view_->Show();
@@ -478,6 +494,7 @@
   }
 
   void OnLanguageSelected(LoginMenuView::Item item) {
+    language_menu_view_ = nullptr;
     language_changed_by_user_ = true;
     selected_language_item_ = item;
     language_selection_->SetText(base::UTF8ToUTF16(item.title));
@@ -492,6 +509,7 @@
   }
 
   void OnKeyboardSelected(LoginMenuView::Item item) {
+    keyboard_menu_view_ = nullptr;
     selected_keyboard_item_ = item;
     keyboard_selection_->SetText(base::UTF8ToUTF16(item.title));
   }
@@ -514,14 +532,6 @@
       if (selected_language_item_.value == locale->language_code)
         selected_language_item_ = item;
     }
-
-    language_menu_view_ = new LoginMenuView(
-        language_items_, language_selection_ /*anchor_view*/,
-        language_selection_ /*bubble_opener*/,
-        base::BindRepeating(&RightPaneView::OnLanguageSelected,
-                            weak_factory_.GetWeakPtr()));
-    login_views_utils::GetTopLevelParentView(this)->AddChildView(
-        language_menu_view_);
   }
 
   void PopulateKeyboardItems(
@@ -538,14 +548,6 @@
       if (keyboard->selected)
         selected_keyboard_item_ = item;
     }
-
-    keyboard_menu_view_ = new LoginMenuView(
-        keyboard_items_, keyboard_selection_ /*anchor_view*/,
-        keyboard_selection_ /*bubble_opener*/,
-        base::BindRepeating(&RightPaneView::OnKeyboardSelected,
-                            weak_factory_.GetWeakPtr()));
-    login_views_utils::GetTopLevelParentView(this)->AddChildView(
-        keyboard_menu_view_);
   }
 
   LoginBaseBubbleView* GetLanguageMenuView() { return language_menu_view_; }
@@ -554,6 +556,16 @@
 
   // Close language and keyboard menus and reset local states.
   void Reset() {
+    if (language_menu_view_) {
+      language_menu_view_->GetWidget()->Close();
+      language_menu_view_ = nullptr;
+    }
+
+    if (keyboard_menu_view_) {
+      keyboard_menu_view_->GetWidget()->Close();
+      keyboard_menu_view_ = nullptr;
+    }
+
     show_advanced_changed_by_user_ = false;
     language_changed_by_user_ = false;
   }
@@ -573,9 +585,11 @@
   views::StyledLabel* learn_more_label_ = nullptr;
   MonitoringWarningView* monitoring_warning_view_ = nullptr;
 
-  // |language_menu_view_| and |keyboard_menu_view_| are parented by the top
-  // level view, either LockContentsView or LockDebugView. This allows the menu
-  // items to be clicked outside the bounds of the right pane view.
+  // |language_menu_view_| and |keyboard_menu_view_| are owned by their
+  // respective bubble widgets, which are always initialized with a Show() call
+  // after construction. menu_view_->GetWidget()->Close() is called on Reset()
+  // and before creating a new instance to avoid memory leaks. The views
+  // themselves should never be deleted directly.
   LoginMenuView* language_menu_view_ = nullptr;
   LoginMenuView* keyboard_menu_view_ = nullptr;
 
@@ -714,14 +728,20 @@
 
   // Ignore press event inside the language and keyboard menu.
   LoginBaseBubbleView* language_menu_view = right_pane_->GetLanguageMenuView();
-  if (language_menu_view &&
-      language_menu_view->GetBoundsInScreen().Contains(event->root_location()))
+  LoginBaseBubbleView* keyboard_menu_view = right_pane_->GetKeyboardMenuView();
+  if (language_menu_view) {
+    const gfx::Rect bounds =
+        language_menu_view->GetWidget()->GetWindowBoundsInScreen();
+    if (bounds.Contains(event->root_location()))
     return;
+  }
 
-  LoginBaseBubbleView* keyboard_menu_view = right_pane_->GetKeyboardMenuView();
-  if (keyboard_menu_view &&
-      keyboard_menu_view->GetBoundsInScreen().Contains(event->root_location()))
+  if (keyboard_menu_view) {
+    const gfx::Rect bounds =
+        keyboard_menu_view->GetWidget()->GetWindowBoundsInScreen();
+    if (bounds.Contains(event->root_location()))
     return;
+  }
 
   Hide();
 }
--- a/ash/login/ui/login_expanded_public_account_view_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/login/ui/login_expanded_public_account_view_unittest.cc	2019-05-17 18:53:08.176000000 +0300
@@ -9,7 +9,6 @@
 #include "ash/login/ui/login_test_utils.h"
 #include "ash/login/ui/public_account_warning_dialog.h"
 #include "ash/login/ui/views_utils.h"
-#include "base/bind_helpers.h"
 #include "testing/gtest/include/gtest/gtest.h"
 #include "ui/events/test/event_generator.h"
 #include "ui/views/layout/box_layout.h"
@@ -162,14 +161,14 @@
   views::View* link_view = styled_label_test.link_targets().begin()->first;
   TapOnView(link_view);
   EXPECT_NE(test_api.warning_dialog(), nullptr);
-  EXPECT_TRUE(test_api.warning_dialog()->visible());
+  EXPECT_TRUE(test_api.warning_dialog()->IsVisible());
 
   // When warning dialog is shown, tap outside of public account expanded view
   // should not hide it.
   TapOnView(other_view_);
   EXPECT_TRUE(public_account_->visible());
   EXPECT_NE(test_api.warning_dialog(), nullptr);
-  EXPECT_TRUE(test_api.warning_dialog()->visible());
+  EXPECT_TRUE(test_api.warning_dialog()->IsVisible());
 
   // If the warning dialog is shown, escape key should close the waring dialog,
   // but not the public account view.
@@ -222,8 +221,10 @@
   EXPECT_TRUE(test_api.advanced_view()->visible());
 
   // Tap on language selection button should bring up the language menu.
+  // Before the first show, language_menu_view is not initialized to anything.
+  EXPECT_EQ(nullptr, test_api.language_menu_view());
   TapOnView(test_api.language_selection_button());
-  EXPECT_TRUE(test_api.language_menu_view()->visible());
+  EXPECT_TRUE(test_api.language_menu_view()->IsVisible());
 
   // First language item is selected, and selected item should have focus.
   EXPECT_EQ(test_api.selected_language_item().value, kEnglishLanguageCode);
@@ -233,11 +234,13 @@
 
   // Select language item should close the language menu.
   GetEventGenerator()->PressKey(ui::KeyboardCode::VKEY_RETURN, 0);
-  EXPECT_FALSE(test_api.language_menu_view()->visible());
+  EXPECT_EQ(nullptr, test_api.language_menu_view());
 
   // Tap on keyboard selection button should bring up the keyboard menu.
+  // Before the first show, keyboard_menu_view is not initialized to anything.
+  EXPECT_EQ(nullptr, test_api.keyboard_menu_view());
   TapOnView(test_api.keyboard_selection_button());
-  EXPECT_TRUE(test_api.keyboard_menu_view()->visible());
+  EXPECT_TRUE(test_api.keyboard_menu_view()->IsVisible());
 
   // Second keyboard item is selected, and selected item should have focus.
   EXPECT_EQ(test_api.selected_keyboard_item().value, kKeyboardIdForItem2);
@@ -247,7 +250,7 @@
 
   // Select keyboard item should close the keyboard menu.
   GetEventGenerator()->PressKey(ui::KeyboardCode::VKEY_RETURN, 0);
-  EXPECT_FALSE(test_api.keyboard_menu_view()->visible());
+  EXPECT_EQ(nullptr, test_api.keyboard_menu_view());
 }
 
 TEST_P(LoginExpandedPublicAccountViewTest, ChangeMenuSelection) {
@@ -259,7 +262,7 @@
   // Try to change language selection.
   // Open language menu.
   TapOnView(test_api.language_selection_button());
-  EXPECT_TRUE(test_api.language_menu_view()->visible());
+  EXPECT_TRUE(test_api.language_menu_view()->IsVisible());
 
   // Select second language item:
   // 1. Language menu will be closed automatically.
@@ -274,14 +277,14 @@
   EXPECT_EQ(test_api.selected_language_item().value, kEnglishLanguageCode);
   LoginMenuView::TestApi language_test_api(test_api.language_menu_view());
   TapOnView(language_test_api.contents()->child_at(1));
-  EXPECT_FALSE(test_api.language_menu_view()->visible());
+  EXPECT_EQ(nullptr, test_api.language_menu_view());
   EXPECT_EQ(test_api.selected_language_item().value, kFrenchLanguageCode);
   base::RunLoop().RunUntilIdle();
 
   // Try to change keyboard selection.
   // Open keyboard menu.
   TapOnView(test_api.keyboard_selection_button());
-  EXPECT_TRUE(test_api.keyboard_menu_view()->visible());
+  EXPECT_TRUE(test_api.keyboard_menu_view()->IsVisible());
 
   // Select first keyboard item:
   // 1. Keyboard menu will be closed automatically.
@@ -289,11 +292,11 @@
   EXPECT_EQ(test_api.selected_keyboard_item().value, kKeyboardIdForItem2);
   LoginMenuView::TestApi keyboard_test_api(test_api.keyboard_menu_view());
   TapOnView(keyboard_test_api.contents()->child_at(0));
-  EXPECT_FALSE(test_api.keyboard_menu_view()->visible());
+  EXPECT_EQ(nullptr, test_api.keyboard_menu_view());
   EXPECT_EQ(test_api.selected_keyboard_item().value, kKeyboardIdForItem1);
 }
 
-INSTANTIATE_TEST_SUITE_P(,
+INSTANTIATE_TEST_CASE_P(,
                          LoginExpandedPublicAccountViewTest,
                          ::testing::Values("mouse", "touch"));
 
--- a/ash/login/ui/login_menu_view.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/login/ui/login_menu_view.cc	2019-05-17 18:53:08.176000000 +0300
@@ -6,7 +6,6 @@
 
 #include "ash/login/ui/hover_notifier.h"
 #include "ash/login/ui/non_accessible_view.h"
-#include "base/bind.h"
 #include "base/strings/utf_string_conversions.h"
 #include "ui/views/controls/button/button.h"
 #include "ui/views/controls/label.h"
@@ -73,6 +72,7 @@
       return;
 
     on_highlight_.Run(true /*by_selection*/);
+    GetWidget()->Close();
   }
 
   void OnHover(bool has_hover) {
@@ -126,7 +126,9 @@
                              LoginButton* opener,
                              const OnSelect& on_select)
     : LoginBaseBubbleView(anchor_view), opener_(opener), on_select_(on_select) {
-  SetBackground(views::CreateSolidBackground(kMenuBackgroundColor));
+  set_can_activate(true);
+  set_margins(gfx::Insets());
+  set_color(kMenuBackgroundColor);
   SetFocusBehavior(views::View::FocusBehavior::ALWAYS);
 
   scroller_ = new views::ScrollView();
@@ -171,7 +173,6 @@
   }
 
   if (by_selection) {
-    SetVisible(false);
     MenuItemView* menu_view = static_cast<MenuItemView*>(highlight_item);
     on_select_.Run(menu_view->item());
   }
--- a/ash/login/ui/login_password_view.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/login/ui/login_password_view.cc	2019-05-17 18:53:08.176000000 +0300
@@ -13,10 +13,8 @@
 #include "ash/resources/vector_icons/vector_icons.h"
 #include "ash/shell.h"
 #include "ash/strings/grit/ash_strings.h"
-#include "base/bind.h"
 #include "base/strings/string_number_conversions.h"
 #include "base/strings/utf_string_conversions.h"
-#include "base/timer/timer.h"
 #include "ui/accessibility/ax_node_data.h"
 #include "ui/base/l10n/l10n_util.h"
 #include "ui/base/resource/resource_bundle.h"
@@ -404,8 +402,8 @@
           kLockScreenArrowIcon, kSubmitButtonSizeDp,
           SkColorSetA(login_constants::kButtonEnabledColor,
                       login_constants::kButtonDisabledAlpha)));
-  submit_button_->SetAccessibleName(
-      l10n_util::GetStringUTF16(IDS_ASH_LOGIN_SUBMIT_BUTTON_ACCESSIBLE_NAME));
+  submit_button_->SetAccessibleName(l10n_util::GetStringUTF16(
+      IDS_ASH_LOGIN_POD_SUBMIT_BUTTON_ACCESSIBLE_NAME));
   password_row_->AddChildView(submit_button_);
 
   // Separator on bottom.
@@ -476,7 +474,7 @@
 }
 
 void LoginPasswordView::InsertNumber(int value) {
-  textfield_->InsertOrReplaceText(base::NumberToString16(value));
+  textfield_->InsertOrReplaceText(base::IntToString16(value));
 }
 
 void LoginPasswordView::Backspace() {
--- a/ash/login/ui/login_password_view_test.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/login/ui/login_password_view_test.cc	2019-05-17 18:53:08.176000000 +0300
@@ -6,7 +6,6 @@
 
 #include "ash/login/ui/login_test_base.h"
 #include "ash/shell.h"
-#include "base/bind.h"
 #include "base/strings/utf_string_conversions.h"
 #include "ui/events/test/event_generator.h"
 #include "ui/views/widget/widget.h"
--- a/ash/login/ui/login_pin_view.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/login/ui/login_pin_view.cc	2019-05-17 18:53:08.176000000 +0300
@@ -11,7 +11,6 @@
 #include "ash/public/cpp/login_constants.h"
 #include "ash/resources/vector_icons/vector_icons.h"
 #include "ash/strings/grit/ash_strings.h"
-#include "base/bind.h"
 #include "base/callback.h"
 #include "base/stl_util.h"
 #include "base/strings/utf_string_conversions.h"
@@ -19,7 +18,6 @@
 #include "ui/accessibility/ax_node_data.h"
 #include "ui/base/l10n/l10n_util.h"
 #include "ui/events/keycodes/dom/dom_code.h"
-#include "ui/gfx/geometry/size.h"
 #include "ui/gfx/paint_vector_icon.h"
 #include "ui/views/animation/flood_fill_ink_drop_ripple.h"
 #include "ui/views/animation/ink_drop_highlight.h"
@@ -60,12 +58,6 @@
 // Size of the md-ripple when a PIN button is tapped.
 constexpr int kRippleSizeDp = 54;
 
-// Button sizes. Button height varies per keyboard style, while button width is
-// the same for both styles.
-constexpr int kAlphanumericButtonHeightDp = 78;
-constexpr int kNumericButtonHeightDp = 70;
-constexpr int kButtonWidthDp = 78;
-
 base::string16 GetButtonLabelForNumber(int value) {
   DCHECK(value >= 0 && value < int{base::size(kPinLabels)});
   return base::ASCIIToUTF16(std::to_string(value));
@@ -86,13 +78,12 @@
 // A base class for pin button in the pin keyboard.
 class BasePinButton : public views::InkDropHostView {
  public:
-  explicit BasePinButton(const gfx::Size& size,
-                         const base::string16& accessible_name,
-                         const base::RepeatingClosure& on_press)
+  explicit BasePinButton(const base::RepeatingClosure& on_press,
+                         const base::string16& accessible_name)
       : on_press_(on_press), accessible_name_(accessible_name) {
     SetFocusBehavior(FocusBehavior::ALWAYS);
-    SetPreferredSize(size);
-
+    SetPreferredSize(
+        gfx::Size(LoginPinView::kButtonSizeDp, LoginPinView::kButtonSizeDp));
     auto layout =
         std::make_unique<views::BoxLayout>(views::BoxLayout::kVertical);
     layout->set_main_axis_alignment(
@@ -203,39 +194,32 @@
 // A PIN button that displays a digit number and corresponding letter mapping.
 class DigitPinButton : public BasePinButton {
  public:
-  DigitPinButton(int value,
-                 bool show_sub_label,
-                 const gfx::Size& size,
-                 const LoginPinView::OnPinKey& on_key)
-      : BasePinButton(size,
-                      GetButtonLabelForNumber(value),
-                      base::BindRepeating(on_key, value)) {
+  DigitPinButton(int value, const LoginPinView::OnPinKey& on_key)
+      : BasePinButton(base::BindRepeating(on_key, value),
+                      GetButtonLabelForNumber(value)) {
     set_id(GetViewIdForPinNumber(value));
     const gfx::FontList& base_font_list = views::Label::GetDefaultFontList();
     views::Label* label = new views::Label(GetButtonLabelForNumber(value),
                                            views::style::CONTEXT_BUTTON,
                                            views::style::STYLE_PRIMARY);
-    label->SetEnabledColor(login_constants::kButtonEnabledColor);
-    label->SetAutoColorReadabilityEnabled(false);
-    label->SetSubpixelRenderingEnabled(false);
-    label->SetFontList(base_font_list.Derive(8, gfx::Font::FontStyle::NORMAL,
-                                             gfx::Font::Weight::LIGHT));
-    AddChildView(label);
-
-    if (show_sub_label) {
       views::Label* sub_label = new views::Label(
           GetButtonSubLabelForNumber(value), views::style::CONTEXT_BUTTON,
           views::style::STYLE_PRIMARY);
+    label->SetEnabledColor(login_constants::kButtonEnabledColor);
       sub_label->SetEnabledColor(
           SkColorSetA(login_constants::kButtonEnabledColor,
                       login_constants::kButtonDisabledAlpha));
+    label->SetAutoColorReadabilityEnabled(false);
       sub_label->SetAutoColorReadabilityEnabled(false);
+    label->SetSubpixelRenderingEnabled(false);
       sub_label->SetSubpixelRenderingEnabled(false);
+    label->SetFontList(base_font_list.Derive(8, gfx::Font::FontStyle::NORMAL,
+                                             gfx::Font::Weight::LIGHT));
       sub_label->SetFontList(base_font_list.Derive(
           -3, gfx::Font::FontStyle::NORMAL, gfx::Font::Weight::NORMAL));
+    AddChildView(label);
       AddChildView(sub_label);
     }
-  }
 
   ~DigitPinButton() override = default;
 
@@ -245,15 +229,16 @@
 
 }  // namespace
 
+// static
+const int LoginPinView::kButtonSizeDp = 78;
+
 // A PIN button that displays backspace icon.
 class LoginPinView::BackspacePinButton : public BasePinButton {
  public:
-  BackspacePinButton(const gfx::Size& size,
-                     const base::RepeatingClosure& on_press)
-      : BasePinButton(size,
+  BackspacePinButton(const base::RepeatingClosure& on_press)
+      : BasePinButton(on_press,
                       l10n_util::GetStringUTF16(
-                          IDS_ASH_PIN_KEYBOARD_DELETE_ACCESSIBLE_NAME),
-                      on_press),
+                          IDS_ASH_PIN_KEYBOARD_DELETE_ACCESSIBLE_NAME)),
         delay_timer_(std::make_unique<base::OneShotTimer>()),
         repeat_timer_(std::make_unique<base::RepeatingTimer>()) {
     image_ = new views::ImageView();
@@ -365,13 +350,6 @@
   DISALLOW_COPY_AND_ASSIGN(BackspacePinButton);
 };
 
-// static
-gfx::Size LoginPinView::TestApi::GetButtonSize(Style style) {
-  return gfx::Size(kButtonWidthDp, style == Style::kNumeric
-                                       ? kNumericButtonHeightDp
-                                       : kAlphanumericButtonHeightDp);
-}
-
 LoginPinView::TestApi::TestApi(LoginPinView* view) : view_(view) {}
 
 LoginPinView::TestApi::~TestApi() = default;
@@ -391,8 +369,7 @@
                                          std::move(repeat_timer));
 }
 
-LoginPinView::LoginPinView(Style keyboard_style,
-                           const OnPinKey& on_key,
+LoginPinView::LoginPinView(const OnPinKey& on_key,
                            const OnPinBackspace& on_backspace)
     : NonAccessibleView(kLoginPinViewClassName),
       on_key_(on_key),
@@ -415,41 +392,31 @@
   SetLayoutManager(
       std::make_unique<views::BoxLayout>(views::BoxLayout::kVertical));
 
-  bool show_letters = keyboard_style == Style::kAlphanumeric;
-  const gfx::Size button_size =
-      gfx::Size(kButtonWidthDp, show_letters ? kAlphanumericButtonHeightDp
-                                             : kNumericButtonHeightDp);
-
-  auto add_digit_button = [&](View* row, int value) {
-    row->AddChildView(
-        new DigitPinButton(value, show_letters, button_size, on_key_));
-  };
-
   // 1-2-3
   auto* row = build_and_add_row();
-  add_digit_button(row, 1);
-  add_digit_button(row, 2);
-  add_digit_button(row, 3);
+  row->AddChildView(new DigitPinButton(1, on_key_));
+  row->AddChildView(new DigitPinButton(2, on_key_));
+  row->AddChildView(new DigitPinButton(3, on_key_));
 
   // 4-5-6
   row = build_and_add_row();
-  add_digit_button(row, 4);
-  add_digit_button(row, 5);
-  add_digit_button(row, 6);
+  row->AddChildView(new DigitPinButton(4, on_key_));
+  row->AddChildView(new DigitPinButton(5, on_key_));
+  row->AddChildView(new DigitPinButton(6, on_key_));
 
   // 7-8-9
   row = build_and_add_row();
-  add_digit_button(row, 7);
-  add_digit_button(row, 8);
-  add_digit_button(row, 9);
+  row->AddChildView(new DigitPinButton(7, on_key_));
+  row->AddChildView(new DigitPinButton(8, on_key_));
+  row->AddChildView(new DigitPinButton(9, on_key_));
 
   // 0-backspace
   row = build_and_add_row();
   auto* spacer = new NonAccessibleView();
-  spacer->SetPreferredSize(button_size);
+  spacer->SetPreferredSize(gfx::Size(kButtonSizeDp, kButtonSizeDp));
   row->AddChildView(spacer);
-  add_digit_button(row, 0);
-  backspace_ = new BackspacePinButton(button_size, on_backspace_);
+  row->AddChildView(new DigitPinButton(0, on_key_));
+  backspace_ = new BackspacePinButton(on_backspace_);
   row->AddChildView(backspace_);
 }
 
--- a/ash/login/ui/login_pin_view.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/login/ui/login_pin_view.h	2019-05-17 18:53:08.176000000 +0300
@@ -46,21 +46,11 @@
 //
 class ASH_EXPORT LoginPinView : public NonAccessibleView {
  public:
-  // Visual style of PIN keyboard.
-  enum class Style {
-    // Has a layout and look of a telephone keypad. Keys display a combination
-    // of a digit and letters. The letters can be used for mnemonic techniques.
-    kAlphanumeric,
-    // Has a layout of a telephone keypad, but keys display only digits, no
-    // letters.
-    kNumeric,
-  };
+  // Size of each button.
+  static const int kButtonSizeDp;
 
   class ASH_EXPORT TestApi {
    public:
-    // Returns expected button size for the given PIN keyboard |style|.
-    static gfx::Size GetButtonSize(Style style);
-
     explicit TestApi(LoginPinView* view);
     ~TestApi();
 
@@ -80,12 +69,10 @@
   using OnPinKey = base::RepeatingCallback<void(int value)>;
   using OnPinBackspace = base::RepeatingClosure;
 
-  // Creates PIN view with the specified |keyboard_style|.
   // |on_key| is called whenever the user taps one of the pin buttons.
   // |on_backspace| is called when the user wants to erase the most recently
   // tapped key. Neither callback can be null.
-  explicit LoginPinView(Style keyboard_style,
-                        const OnPinKey& on_key,
+  explicit LoginPinView(const OnPinKey& on_key,
                         const OnPinBackspace& on_backspace);
   ~LoginPinView() override;
 
--- a/ash/login/ui/login_pin_view_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/login/ui/login_pin_view_unittest.cc	2019-05-17 18:53:08.176000000 +0300
@@ -4,14 +4,10 @@
 
 #include "ash/login/ui/login_password_view.h"
 
-#include <algorithm>
 #include <memory>
-#include <set>
-#include <vector>
 
 #include "ash/login/ui/login_pin_view.h"
 #include "ash/login/ui/login_test_base.h"
-#include "base/bind.h"
 #include "base/timer/mock_timer.h"
 #include "ui/events/test/event_generator.h"
 #include "ui/views/widget/widget.h"
@@ -25,15 +21,13 @@
   LoginPinViewTest() = default;
   ~LoginPinViewTest() override = default;
 
-  // Creates login pin view with the specified keyboard |style| and sets it up
-  // in a widget.
-  void CreateLoginPinViewWithStyle(LoginPinView::Style style) {
-    view_ =
-        new LoginPinView(style,
-                         base::BindRepeating(&LoginPinViewTest::OnPinKey,
-                                             base::Unretained(this)),
-                         base::BindRepeating(&LoginPinViewTest::OnPinBackspace,
-                                             base::Unretained(this)));
+  // LoginScreenTest:
+  void SetUp() override {
+    LoginTestBase::SetUp();
+
+    view_ = new LoginPinView(
+        base::Bind(&LoginPinViewTest::OnPinKey, base::Unretained(this)),
+        base::Bind(&LoginPinViewTest::OnPinBackspace, base::Unretained(this)));
 
     SetWidget(CreateWidgetWithContent(view_));
   }
@@ -55,7 +49,6 @@
 
 // Verifies that PIN submit works with 'Enter'.
 TEST_F(LoginPinViewTest, ButtonsFireEvents) {
-  CreateLoginPinViewWithStyle(LoginPinView::Style::kAlphanumeric);
   ui::test::EventGenerator* generator = GetEventGenerator();
   LoginPinView::TestApi test_api(view_);
 
@@ -76,78 +69,23 @@
   EXPECT_EQ(1, backspace_);
 }
 
-// Validates buttons have the correct spacing for alphanumeric PIN keyboard
-// style.
-TEST_F(LoginPinViewTest, AlphanumericKeyboardButtonSpacingAndSize) {
-  CreateLoginPinViewWithStyle(LoginPinView::Style::kAlphanumeric);
+// Validates buttons have the correct spacing.
+TEST_F(LoginPinViewTest, ButtonSpacingAndSize) {
   LoginPinView::TestApi test_api(view_);
 
-  const gfx::Size expected_button_size =
-      LoginPinView::TestApi::GetButtonSize(LoginPinView::Style::kAlphanumeric);
-
-  // Validate pin button size.
-  for (int i = 0; i <= 9; ++i) {
-    DCHECK_EQ(test_api.GetButton(i)->size().width(),
-              expected_button_size.width());
-    DCHECK_EQ(test_api.GetButton(i)->size().height(),
-              expected_button_size.height());
-  }
-
-  // Validate backspace button size.
-  DCHECK_EQ(test_api.GetBackspaceButton()->size().width(),
-            expected_button_size.width());
-  DCHECK_EQ(test_api.GetBackspaceButton()->size().height(),
-            expected_button_size.height());
-
-  // Record all the x/y coordinates of the buttons.
-  std::set<int> seen_x;
-  std::set<int> seen_y;
-  for (int i = 0; i <= 9; ++i) {
-    gfx::Rect screen_bounds = test_api.GetButton(i)->GetBoundsInScreen();
-    seen_x.insert(screen_bounds.x());
-    seen_y.insert(screen_bounds.y());
-  }
-  seen_x.insert(test_api.GetBackspaceButton()->GetBoundsInScreen().x());
-  seen_y.insert(test_api.GetBackspaceButton()->GetBoundsInScreen().y());
-
-  // Sort the coordinates so we can easily check the distance between them.
-  std::vector<int> sorted_x(seen_x.begin(), seen_x.end());
-  std::vector<int> sorted_y(seen_y.begin(), seen_y.end());
-  std::sort(sorted_x.begin(), sorted_x.end());
-  std::sort(sorted_y.begin(), sorted_y.end());
-
-  // Validate each x or y coordinate has the correct distance between it and the
-  // next one. This is correct because we have already validated button size.
-  EXPECT_EQ(3u, sorted_x.size());
-  for (size_t i = 0; i < sorted_x.size() - 1; ++i)
-    EXPECT_EQ(sorted_x[i] + expected_button_size.width(), sorted_x[i + 1]);
-
-  EXPECT_EQ(4u, sorted_y.size());
-  for (size_t i = 0; i < sorted_y.size() - 1; ++i)
-    EXPECT_EQ(sorted_y[i] + expected_button_size.height(), sorted_y[i + 1]);
-}
-
-// Validates buttons have the correct spacing for numeric PIN keyboard style.
-TEST_F(LoginPinViewTest, NumericKeyboardButtonSpacingAndSize) {
-  CreateLoginPinViewWithStyle(LoginPinView::Style::kNumeric);
-  LoginPinView::TestApi test_api(view_);
-
-  const gfx::Size expected_button_size =
-      LoginPinView::TestApi::GetButtonSize(LoginPinView::Style::kNumeric);
-
   // Validate pin button size.
   for (int i = 0; i <= 9; ++i) {
     DCHECK_EQ(test_api.GetButton(i)->size().width(),
-              expected_button_size.width());
+              LoginPinView::kButtonSizeDp);
     DCHECK_EQ(test_api.GetButton(i)->size().height(),
-              expected_button_size.height());
+              LoginPinView::kButtonSizeDp);
   }
 
   // Validate backspace button size.
   DCHECK_EQ(test_api.GetBackspaceButton()->size().width(),
-            expected_button_size.width());
+            LoginPinView::kButtonSizeDp);
   DCHECK_EQ(test_api.GetBackspaceButton()->size().height(),
-            expected_button_size.height());
+            LoginPinView::kButtonSizeDp);
 
   // Record all the x/y coordinates of the buttons.
   std::set<int> seen_x;
@@ -170,17 +108,16 @@
   // next one. This is correct because we have already validated button size.
   EXPECT_EQ(3u, sorted_x.size());
   for (size_t i = 0; i < sorted_x.size() - 1; ++i)
-    EXPECT_EQ(sorted_x[i] + expected_button_size.width(), sorted_x[i + 1]);
+    EXPECT_EQ(sorted_x[i] + LoginPinView::kButtonSizeDp, sorted_x[i + 1]);
 
   EXPECT_EQ(4u, sorted_y.size());
   for (size_t i = 0; i < sorted_y.size() - 1; ++i)
-    EXPECT_EQ(sorted_y[i] + expected_button_size.height(), sorted_y[i + 1]);
+    EXPECT_EQ(sorted_y[i] + LoginPinView::kButtonSizeDp, sorted_y[i + 1]);
 }
 
 // Verifies that holding the backspace button automatically triggers and begins
 // repeating if it is held down.
 TEST_F(LoginPinViewTest, BackspaceAutoSubmitsAndRepeats) {
-  CreateLoginPinViewWithStyle(LoginPinView::Style::kAlphanumeric);
   ui::test::EventGenerator* generator = GetEventGenerator();
   LoginPinView::TestApi test_api(view_);
 
--- a/ash/login/ui/login_public_account_user_view.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/login/ui/login_public_account_user_view.cc	2019-05-17 18:53:08.176000000 +0300
@@ -10,7 +10,6 @@
 #include "ash/login/ui/hover_notifier.h"
 #include "ash/login/ui/login_display_style.h"
 #include "ash/login/ui/views_utils.h"
-#include "base/bind.h"
 #include "ui/compositor/scoped_layer_animation_settings.h"
 #include "ui/views/layout/box_layout.h"
 
--- a/ash/login/ui/login_public_account_user_view_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/login/ui/login_public_account_user_view_unittest.cc	2019-05-17 18:53:08.180000000 +0300
@@ -6,7 +6,6 @@
 #include "ash/login/ui/login_test_base.h"
 #include "ash/login/ui/login_test_utils.h"
 #include "ash/login/ui/login_user_view.h"
-#include "base/bind.h"
 #include "ui/events/test/event_generator.h"
 #include "ui/views/layout/box_layout.h"
 #include "ui/views/widget/widget.h"
--- a/ash/login/ui/login_test_base.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/login/ui/login_test_base.cc	2019-05-17 18:53:08.180000000 +0300
@@ -14,7 +14,6 @@
 #include "ash/session/test_session_controller_client.h"
 #include "ash/shell.h"
 #include "ash/wallpaper/wallpaper_controller.h"
-#include "base/bind.h"
 #include "base/strings/strcat.h"
 #include "services/ws/public/cpp/property_type_converters.h"
 #include "services/ws/public/mojom/window_manager.mojom.h"
@@ -138,17 +137,6 @@
   }
 
   // Notify any listeners that the user count has changed.
-  DataDispatcher()->NotifyUsers(users_);
-}
-
-void LoginTestBase::AddChildUsers(size_t num_users) {
-  for (size_t i = 0; i < num_users; i++) {
-    std::string email =
-        base::StrCat({"user", std::to_string(users_.size()), "@domain.com"});
-    users_.push_back(CreateChildUser(email));
-  }
-
-  // Notify any listeners that the user count has changed.
   DataDispatcher()->NotifyUsers(users_);
 }
 
--- a/ash/login/ui/login_test_base.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/login/ui/login_test_base.h	2019-05-17 18:53:08.180000000 +0300
@@ -60,10 +60,6 @@
   // |DataDispatcher()|.
   void AddPublicAccountUsers(size_t num_public_accounts);
 
-  // Creates and appends |num_users| of child user accounts.
-  // Changes the active number of users. Fires an event on |DataDispatcher()|.
-  void AddChildUsers(size_t num_users);
-
   std::vector<mojom::LoginUserInfoPtr>& users() { return users_; }
 
   const std::vector<mojom::LoginUserInfoPtr>& users() const { return users_; }
--- a/ash/login/ui/login_test_utils.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/login/ui/login_test_utils.cc	2019-05-17 18:53:08.180000000 +0300
@@ -12,20 +12,6 @@
 namespace {
 constexpr char kPrimaryName[] = "primary";
 constexpr char kSecondaryName[] = "secondary";
-
-mojom::LoginUserInfoPtr CreateUserWithType(const std::string& email,
-                                           user_manager::UserType user_type) {
-  auto user = mojom::LoginUserInfo::New();
-  user->basic_user_info = mojom::UserInfo::New();
-  user->basic_user_info->type = user_type;
-  user->basic_user_info->avatar = mojom::UserAvatar::New();
-  user->basic_user_info->account_id = AccountId::FromUserEmail(email);
-  user->basic_user_info->display_name = base::SplitString(
-      email, "@", base::TRIM_WHITESPACE, base::SPLIT_WANT_ALL)[0];
-  user->basic_user_info->display_email = email;
-  return user;
-}
-
 }  // namespace
 
 const char* AuthTargetToString(AuthTarget target) {
@@ -65,11 +51,14 @@
 }
 
 mojom::LoginUserInfoPtr CreateUser(const std::string& email) {
-  return CreateUserWithType(email, user_manager::UserType::USER_TYPE_REGULAR);
-}
-
-mojom::LoginUserInfoPtr CreateChildUser(const std::string& email) {
-  return CreateUserWithType(email, user_manager::UserType::USER_TYPE_CHILD);
+  auto user = mojom::LoginUserInfo::New();
+  user->basic_user_info = mojom::UserInfo::New();
+  user->basic_user_info->avatar = mojom::UserAvatar::New();
+  user->basic_user_info->account_id = AccountId::FromUserEmail(email);
+  user->basic_user_info->display_name = base::SplitString(
+      email, "@", base::TRIM_WHITESPACE, base::SPLIT_WANT_ALL)[0];
+  user->basic_user_info->display_email = email;
+  return user;
 }
 
 mojom::LoginUserInfoPtr CreatePublicAccountUser(const std::string& email) {
@@ -116,20 +105,4 @@
   return false;
 }
 
-// Performs a DFS for the first button in the views hierarchy
-// The last child is on the top of the z layer stack
-views::View* FindTopButton(views::View* current_view) {
-  for (int i = current_view->child_count() - 1; i >= 0; i--) {
-    views::View* child = current_view->child_at(i);
-    if (views::Button::AsButton(child))
-      return child;
-    if (child->has_children()) {
-      views::View* child_button = FindTopButton(child);
-      if (child_button)
-        return child_button;
-    }
-  }
-  return nullptr;
-}
-
 }  // namespace ash
--- a/ash/login/ui/login_test_utils.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/login/ui/login_test_utils.h	2019-05-17 18:53:08.180000000 +0300
@@ -34,10 +34,6 @@
 // for regular user.
 mojom::LoginUserInfoPtr CreateUser(const std::string& email);
 
-// Utility method to create a new |mojom::LoginUserInfoPtr| instance for child
-// user.
-mojom::LoginUserInfoPtr CreateChildUser(const std::string& email);
-
 // Utility method to create a new |mojom::LoginUserInfoPtr| instance for
 // public account user.
 mojom::LoginUserInfoPtr CreatePublicAccountUser(const std::string& email);
@@ -52,9 +48,6 @@
                     views::View* view,
                     bool reverse);
 
-// Find the first button in the z layer stack of the given view
-views::View* FindTopButton(views::View* current_view);
-
 }  // namespace ash
 
 #endif  // ASH_LOGIN_UI_LOGIN_TEST_UTILS_H_
--- a/ash/login/ui/login_tooltip_view.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/login/ui/login_tooltip_view.cc	2019-05-17 18:53:08.180000000 +0300
@@ -13,6 +13,8 @@
 LoginTooltipView::LoginTooltipView(const base::string16& message,
                                    views::View* anchor_view)
     : LoginBaseBubbleView(anchor_view) {
+  SetLayoutManager(
+      std::make_unique<views::BoxLayout>(views::BoxLayout::kVertical));
   SetText(message);
 }
 
@@ -30,14 +32,4 @@
   node_data->role = ax::mojom::Role::kTooltip;
 }
 
-gfx::Size LoginTooltipView::CalculatePreferredSize() const {
-  gfx::Size size;
-
-  if (GetAnchorView())
-    size.set_width(GetAnchorView()->width());
-
-  size.set_height(GetHeightForWidth(size.width()));
-  return size;
-}
-
 }  // namespace ash
--- a/ash/login/ui/login_tooltip_view.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/login/ui/login_tooltip_view.h	2019-05-17 18:53:08.180000000 +0300
@@ -21,9 +21,6 @@
   // LoginBaseBubbleView:
   void GetAccessibleNodeData(ui::AXNodeData* node_data) override;
 
-  // views::View:
-  gfx::Size CalculatePreferredSize() const override;
-
  private:
   DISALLOW_COPY_AND_ASSIGN(LoginTooltipView);
 };
--- a/ash/login/ui/login_user_menu_view.cc	2019-05-17 17:45:36.496000000 +0300
+++ b/ash/login/ui/login_user_menu_view.cc	2019-05-17 18:53:08.180000000 +0300
@@ -10,15 +10,13 @@
 #include "base/strings/utf_string_conversions.h"
 #include "ui/accessibility/ax_node_data.h"
 #include "ui/base/l10n/l10n_util.h"
-#include "ui/display/display.h"
-#include "ui/display/screen.h"
 #include "ui/views/controls/separator.h"
 #include "ui/views/layout/box_layout.h"
 #include "ui/views/layout/fill_layout.h"
 
 namespace {
 constexpr char kLegacySupervisedUserManagementDisplayURL[] =
-    "www.ch40me.qjz9zk/manage";
+    "www.chrome.com/manage";
 
 // Spacing between the child view inside the bubble view.
 constexpr int kBubbleBetweenChildSpacingDp = 6;
@@ -40,6 +38,9 @@
 // Margin around remove user button.
 constexpr int kUserMenuMarginAroundRemoveUserButtonDp = 4;
 
+// Horizontal spacing with the anchor view.
+constexpr int kAnchorViewUserMenuHorizontalSpacingDp = 98;
+
 // Vertical spacing between the anchor view and user menu.
 constexpr int kAnchorViewUserMenuVerticalSpacingDp = 4;
 
@@ -140,8 +141,16 @@
       bubble_opener_(bubble_opener),
       on_remove_user_warning_shown_(on_remove_user_warning_shown),
       on_remove_user_requested_(on_remove_user_requested) {
+  // This view has content the user can interact with if the remove user
+  // button is displayed.
+  set_can_activate(show_remove_user);
+
+  set_anchor_view_insets(gfx::Insets(kAnchorViewUserMenuVerticalSpacingDp,
+                                     kAnchorViewUserMenuHorizontalSpacingDp));
+
   // LoginUserMenuView does not use the parent margins. Further, because the
   // splitter spans the entire view set_margins cannot be used.
+  set_margins(gfx::Insets());
   // The bottom margin is less the margin around the remove user button, which
   // is always visible.
   gfx::Insets margins(
@@ -254,13 +263,6 @@
 
 LoginUserMenuView::~LoginUserMenuView() = default;
 
-void LoginUserMenuView::ResetState() {
-  if (remove_user_confirm_data_) {
-    remove_user_confirm_data_->SetVisible(false);
-    remove_user_label_->SetEnabledColor(kRemoveUserInitialColor);
-  }
-}
-
 LoginButton* LoginUserMenuView::GetBubbleOpener() const {
   return bubble_opener_;
 }
@@ -272,7 +274,8 @@
   if (!remove_user_confirm_data_->visible()) {
     remove_user_confirm_data_->SetVisible(true);
     remove_user_label_->SetEnabledColor(kRemoveUserConfirmColor);
-
+    SetSize(GetPreferredSize());
+    SizeToContents();
     Layout();
 
     // Fire an accessibility alert to make ChromeVox read the warning message
@@ -287,42 +290,15 @@
     return;
   }
 
-  // Immediately hide the bubble with no animation before running the remove
+  // Immediately hide the widget with no animation before running the remove
   // user callback. If an animation is triggered while the the views hierarchy
   // for this bubble is being torn down, we can get a crash.
-  SetVisible(false);
+  GetWidget()->Hide();
 
   if (on_remove_user_requested_)
     std::move(on_remove_user_requested_).Run();
 }
 
-gfx::Point LoginUserMenuView::CalculatePosition() {
-  gfx::Point position = LoginBaseBubbleView::CalculatePosition();
-
-  if (GetAnchorView())
-    position.set_y(position.y() + kAnchorViewUserMenuVerticalSpacingDp);
-
-  gfx::Rect screen_bounds =
-      display::Screen::GetScreen()->GetPrimaryDisplay().bounds();
-
-  // In handling the cases where the bubble could go off screen, we assume that
-  // the bubble can go either off the right side or off the bottom side.
-  if (position.x() + width() > screen_bounds.right() && GetAnchorView()) {
-    // If bubble would go off the right side of the screen, go left instead
-    position.set_x(position.x() + GetAnchorView()->width() - width());
-  } else if (position.y() + height() > screen_bounds.bottom() &&
-             GetAnchorView()) {
-    // If bubble would go off the bottom of the screen, go to the right of the
-    // anchor and upward.
-    position.set_x(position.x() + kAnchorViewUserMenuVerticalSpacingDp +
-                   GetAnchorView()->width());
-    position.set_y(position.y() +
-                   (screen_bounds.bottom() - (position.y() + height())));
-  }
-
-  return position;
-}
-
 void LoginUserMenuView::RequestFocus() {
   // This view has no actual interesting contents to focus, so immediately
   // forward to the button.
@@ -330,11 +306,26 @@
     remove_user_button_->RequestFocus();
 }
 
-bool LoginUserMenuView::HasFocus() const {
-  return remove_user_button_ && remove_user_button_->HasFocus();
+void LoginUserMenuView::AddedToWidget() {
+  LoginBaseBubbleView::AddedToWidget();
+  // Set up focus traversable parent so that keyboard focus can continue in
+  // the lock window, otherwise focus will be trapped inside the bubble.
+  if (GetAnchorView()) {
+    GetWidget()->SetFocusTraversableParent(
+        anchor_widget()->GetFocusTraversable());
+    GetWidget()->SetFocusTraversableParentView(GetAnchorView());
+  }
 }
 
 const char* LoginUserMenuView::GetClassName() const {
   return "LoginUserMenuView";
 }
+
+gfx::Size LoginUserMenuView::CalculatePreferredSize() const {
+  gfx::Size size = LoginBaseBubbleView::CalculatePreferredSize();
+  // We don't use margins() directly which means that we need to account for
+  // the margin width here. Margin height is accounted for by the layout code.
+  size.Enlarge(kUserMenuMarginWidth, 0);
+  return size;
+}
 }  // namespace ash
--- a/ash/login/ui/login_user_menu_view.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/login/ui/login_user_menu_view.h	2019-05-17 18:53:08.180000000 +0300
@@ -45,20 +45,17 @@
 
   ~LoginUserMenuView() override;
 
-  // Resets the user menu to the state where Remove User has not been pressed.
-  void ResetState();
-
   // LoginBaseBubbleView:
   LoginButton* GetBubbleOpener() const override;
-  gfx::Point CalculatePosition() override;
 
   // views::ButtonListener:
   void ButtonPressed(views::Button* sender, const ui::Event& event) override;
 
   // views::View:
   void RequestFocus() override;
-  bool HasFocus() const override;
+  void AddedToWidget() override;
   const char* GetClassName() const override;
+  gfx::Size CalculatePreferredSize() const override;
 
  private:
   LoginButton* bubble_opener_ = nullptr;
--- a/ash/login/ui/login_user_menu_view_unittest.cc	2019-05-17 17:45:36.496000000 +0300
+++ b/ash/login/ui/login_user_menu_view_unittest.cc	2019-05-17 18:53:08.180000000 +0300
@@ -2,8 +2,6 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include <memory>
-
 #include "ash/login/ui/login_user_menu_view.h"
 #include "ash/login/ui/login_button.h"
 #include "ash/login/ui/login_test_base.h"
@@ -40,11 +38,9 @@
                           &remove_warning_called),
       base::BindRepeating([](bool* remove_called) { *remove_called = true; },
                           &remove_called));
-  anchor->AddChildView(bubble);
-
   bubble->Show();
 
-  EXPECT_TRUE(bubble->visible());
+  EXPECT_TRUE(bubble->IsVisible());
 
   // Focus the remove user button (the menu should forward focus to the remove
   // button).
@@ -71,15 +67,14 @@
 
   auto* bubble = new LoginUserMenuView(
       base::UTF8ToUTF16("NedHasAReallyLongName StarkHasAReallyLongName"),
-      base::UTF8ToUTF16("reallyreallyextralonggaianame@9ma1l.qjz9zk"),
+      base::UTF8ToUTF16("reallyreallyextralonggaianame@gmail.com"),
       user_manager::USER_TYPE_REGULAR, false /*is_owner*/, anchor,
       nullptr /*bubble_opener*/, true /*show_remove_user*/, base::DoNothing(),
       base::DoNothing());
 
-  anchor->AddChildView(bubble);
   bubble->Show();
 
-  EXPECT_TRUE(bubble->visible());
+  EXPECT_TRUE(bubble->IsVisible());
 
   LoginUserMenuView::TestApi test_api(bubble);
   views::View* remove_user_button = test_api.remove_user_button();
@@ -127,45 +122,18 @@
       false /*is_owner*/, container /*anchor*/, bubble_opener,
       true /*show_remove_user*/, base::DoNothing(), base::DoNothing());
 
-  container->AddChildView(bubble);
-
   bubble->Show();
-  EXPECT_TRUE(bubble->visible());
+  EXPECT_TRUE(bubble->IsVisible());
   EXPECT_TRUE(ink_drop_api.HasInkDrop());
   EXPECT_EQ(ink_drop_api.GetInkDrop()->GetTargetInkDropState(),
             views::InkDropState::ACTIVATED);
   EXPECT_TRUE(ink_drop_api.GetInkDrop()->IsHighlightFadingInOrVisible());
 
   bubble->Hide();
-  EXPECT_FALSE(bubble->visible());
+  EXPECT_FALSE(bubble->IsVisible());
   EXPECT_EQ(ink_drop_api.GetInkDrop()->GetTargetInkDropState(),
             views::InkDropState::HIDDEN);
   EXPECT_FALSE(ink_drop_api.GetInkDrop()->IsHighlightFadingInOrVisible());
 }
 
-TEST_F(LoginUserMenuViewTest, ResetStateHidesConfirmData) {
-  auto* container = new views::View;
-  container->SetLayoutManager(
-      std::make_unique<views::BoxLayout>(views::BoxLayout::kVertical));
-  SetWidget(CreateWidgetWithContent(container));
-
-  auto* bubble = new LoginUserMenuView(
-      base::string16(), base::string16(), user_manager::USER_TYPE_REGULAR,
-      false /*is_owner*/, nullptr /*anchor*/, nullptr /*bubble_opener*/,
-      true /*show_remove_user*/, base::DoNothing(), base::DoNothing());
-  container->AddChildView(bubble);
-
-  bubble->Show();
-
-  LoginUserMenuView::TestApi test_api(bubble);
-  EXPECT_FALSE(test_api.remove_user_confirm_data()->visible());
-
-  test_api.remove_user_button()->RequestFocus();
-  GetEventGenerator()->PressKey(ui::KeyboardCode::VKEY_RETURN, 0);
-  EXPECT_TRUE(test_api.remove_user_confirm_data()->visible());
-
-  bubble->ResetState();
-  EXPECT_FALSE(test_api.remove_user_confirm_data()->visible());
-}
-
 }  // namespace ash
--- a/ash/login/ui/login_user_view.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/login/ui/login_user_view.cc	2019-05-17 18:53:08.180000000 +0300
@@ -19,7 +19,6 @@
 #include "ash/resources/vector_icons/vector_icons.h"
 #include "ash/strings/grit/ash_strings.h"
 #include "ash/system/user/rounded_image_view.h"
-#include "base/bind.h"
 #include "base/memory/weak_ptr.h"
 #include "base/strings/utf_string_conversions.h"
 #include "components/user_manager/user_type.h"
@@ -422,26 +421,17 @@
       this, base::Bind(&LoginUserView::OnHover, base::Unretained(this)));
 }
 
-LoginUserView::~LoginUserView() = default;
+LoginUserView::~LoginUserView() {
+  if (menu_) {
+    menu_->GetWidget()->Close();
+    menu_ = nullptr;
+  }
+}
 
 void LoginUserView::UpdateForUser(const mojom::LoginUserInfoPtr& user,
                                   bool animate) {
   current_user_ = user->Clone();
 
-  if (menu_ && menu_->parent()) {
-    menu_->parent()->RemoveChildView(menu_);
-    delete menu_;
-  }
-
-  menu_ = new LoginUserMenuView(
-      base::UTF8ToUTF16(current_user_->basic_user_info->display_name),
-      base::UTF8ToUTF16(current_user_->basic_user_info->display_email),
-      current_user_->basic_user_info->type, current_user_->is_device_owner,
-      dropdown_ /*anchor_view*/, dropdown_ /*bubble_opener*/,
-      current_user_->can_remove /*show_remove_user*/, on_remove_warning_shown_,
-      on_remove_);
-  menu_->SetVisible(false);
-
   if (animate) {
     // Stop any existing animation.
     user_image_->layer()->GetAnimator()->StopAnimating();
@@ -538,22 +528,30 @@
   // Handle click on the dropdown arrow.
   if (sender == dropdown_) {
     DCHECK(dropdown_);
-    DCHECK(menu_);
 
     // If menu is showing, just close it
-    if (menu_->visible()) {
+    if (menu_ && menu_->IsVisible()) {
       menu_->Hide();
       return;
     }
 
+    // If the menu exists but is hidden, delete it and create a new menu.
+    if (menu_) {
+      menu_->GetWidget()->Close();
+      menu_ = nullptr;
+    }
+
+    menu_ = new LoginUserMenuView(
+        base::UTF8ToUTF16(current_user_->basic_user_info->display_name),
+        base::UTF8ToUTF16(current_user_->basic_user_info->display_email),
+        current_user_->basic_user_info->type, current_user_->is_device_owner,
+        dropdown_ /*anchor_view*/, dropdown_ /*bubble_opener*/,
+        current_user_->can_remove /*show_remove_user*/,
+        on_remove_warning_shown_, on_remove_);
+
     bool opener_focused =
         menu_->GetBubbleOpener() && menu_->GetBubbleOpener()->HasFocus();
 
-    if (!menu_->parent())
-      login_views_utils::GetTopLevelParentView(this)->AddChildView(menu_);
-
-    // Reset state in case the remove-user button was clicked once previously.
-    menu_->ResetState();
     menu_->Show();
 
     // If the menu was opened by pressing Enter on the focused dropdown, focus
--- a/ash/login/ui/login_user_view.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/login/ui/login_user_view.h	2019-05-17 18:53:08.180000000 +0300
@@ -120,10 +120,10 @@
   LoginButton* dropdown_ = nullptr;
   TapButton* tap_button_ = nullptr;
 
-  // Bubble used for displaying the user dropdown menu. Its parent is the top
-  // level view, either LockContentsView or LockDebugView. This allows the menu
-  // to be clicked outside the bounds of the user view.
-  LoginUserMenuView* menu_ = nullptr;
+  // Bubble used for displaying the user dropdown menu. Owned by its widget,
+  // which is owned by LoginUserView. This widget is closed in
+  // LoginUserMenuView's d'tor.
+  LoginBaseBubbleView* menu_ = nullptr;
 
   // Show the domain information for public account user.
   UserDomainInfoView* user_domain_ = nullptr;
--- a/ash/login/ui/login_user_view_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/login/ui/login_user_view_unittest.cc	2019-05-17 18:53:08.180000000 +0300
@@ -6,7 +6,6 @@
 #include "ash/login/ui/login_display_style.h"
 #include "ash/login/ui/login_test_base.h"
 #include "ash/login/ui/login_test_utils.h"
-#include "base/bind.h"
 #include "testing/gtest/include/gtest/gtest.h"
 #include "ui/events/test/event_generator.h"
 #include "ui/gfx/geometry/rect.h"
--- a/ash/login/ui/scrollable_users_list_view.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/login/ui/scrollable_users_list_view.cc	2019-05-17 18:53:08.180000000 +0300
@@ -14,9 +14,7 @@
 #include "ash/public/interfaces/login_user_info.mojom.h"
 #include "ash/shell.h"
 #include "ash/wallpaper/wallpaper_controller.h"
-#include "base/bind.h"
 #include "base/numerics/ranges.h"
-#include "base/timer/timer.h"
 #include "ui/compositor/scoped_layer_animation_settings.h"
 #include "ui/display/screen.h"
 #include "ui/gfx/canvas.h"
--- a/ash/login/ui/views_utils.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/login/ui/views_utils.cc	2019-05-17 18:53:08.180000000 +0300
@@ -74,14 +74,5 @@
   return label;
 }
 
-views::View* GetTopLevelParentView(views::View* view) {
-  views::View* v = view;
-
-  while (v->parent() != nullptr)
-    v = v->parent();
-
-  return v;
-}
-
 }  // namespace login_views_utils
 }  // namespace ash
--- a/ash/login/ui/views_utils.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/login/ui/views_utils.h	2019-05-17 18:53:08.180000000 +0300
@@ -30,9 +30,6 @@
 // Creates a standard text label for use in the login bubbles.
 views::Label* CreateBubbleLabel(const base::string16& message, SkColor color);
 
-// Get the topmost level parent view for |view|.
-views::View* GetTopLevelParentView(views::View* view);
-
 }  // namespace login_views_utils
 
 }  // namespace ash
--- a/ash/magnifier/docked_magnifier_controller.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/magnifier/docked_magnifier_controller.cc	2019-05-17 18:53:08.180000000 +0300
@@ -18,7 +18,6 @@
 #include "ash/shell.h"
 #include "ash/wm/overview/overview_controller.h"
 #include "ash/wm/splitview/split_view_controller.h"
-#include "base/bind.h"
 #include "base/numerics/ranges.h"
 #include "components/prefs/pref_change_registrar.h"
 #include "components/prefs/pref_registry_simple.h"
@@ -408,7 +407,7 @@
     separator_layer_->SetBounds(
         SeparatorBoundsFromViewportBounds(viewport_bounds));
     SetViewportHeightInWorkArea(current_source_root_window_,
-                                GetTotalMagnifierHeight());
+                                separator_layer_->bounds().bottom());
 
     // Resolution changes, screen rotation, etc. can reset the host to confine
     // the mouse cursor inside the root window. We want to make sure the cursor
@@ -437,13 +436,6 @@
   }
 }
 
-int DockedMagnifierController::GetTotalMagnifierHeight() const {
-  if (separator_layer_)
-    return separator_layer_->bounds().bottom();
-
-  return 0;
-}
-
 const views::Widget* DockedMagnifierController::GetViewportWidgetForTesting()
     const {
   return viewport_widget_;
@@ -580,9 +572,10 @@
     auto* split_view_controller = shell->split_view_controller();
     if (split_view_controller->IsSplitViewModeActive()) {
       // In this case, we're in a single-split-view mode, i.e. a window is
-      // snapped to one side of the split view, while the other side has
-      // overview active. We need to exit split view as well as exiting overview
-      // mode, otherwise we'll be in an invalid state.
+      // snapped to one side of the split view, while the other side has the
+      // window selector active.
+      // We need to exit split view as well as exiting overview mode, otherwise
+      // we'll be in an invalid state.
       split_view_controller->EndSplitView(
           SplitViewController::EndReason::kNormal);
     }
@@ -699,7 +692,7 @@
   //    contain the viewport and the separator is allocated at the top of the
   //    screen.
   SetViewportHeightInWorkArea(current_source_root_window_,
-                              GetTotalMagnifierHeight());
+                              separator_layer_->bounds().bottom());
 
   // 6- Confine the mouse cursor within the remaining part of the display.
   ConfineMouseCursorOutsideViewport();
--- a/ash/magnifier/docked_magnifier_controller.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/magnifier/docked_magnifier_controller.h	2019-05-17 18:53:08.180000000 +0300
@@ -122,11 +122,6 @@
   bool GetFullscreenMagnifierEnabled() const;
   void SetFullscreenMagnifierEnabled(bool enabled);
 
-  // Returns the total height of the Docked Magnifier, which is the height of
-  // the viewport widget plus the height of the separator, if enabled, or zero
-  // if disabled.
-  int GetTotalMagnifierHeight() const;
-
   const views::Widget* GetViewportWidgetForTesting() const;
 
   const ui::Layer* GetViewportMagnifierLayerForTesting() const;
--- a/ash/magnifier/docked_magnifier_controller_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/magnifier/docked_magnifier_controller_unittest.cc	2019-05-17 18:53:08.180000000 +0300
@@ -12,6 +12,7 @@
 #include "ash/display/window_tree_host_manager.h"
 #include "ash/host/ash_window_tree_host.h"
 #include "ash/magnifier/magnifier_test_utils.h"
+#include "ash/public/cpp/ash_features.h"
 #include "ash/public/cpp/ash_pref_names.h"
 #include "ash/public/cpp/ash_switches.h"
 #include "ash/public/interfaces/docked_magnifier_controller.mojom.h"
@@ -26,6 +27,7 @@
 #include "ash/wm/tablet_mode/tablet_mode_controller.h"
 #include "ash/wm/window_state.h"
 #include "base/command_line.h"
+#include "base/test/scoped_feature_list.h"
 #include "components/prefs/pref_service.h"
 #include "components/session_manager/session_manager_types.h"
 #include "ui/aura/window.h"
@@ -70,6 +72,9 @@
 
   // AshTestBase:
   void SetUp() override {
+    // Explicitly enable the Docked Magnifier feature for the tests.
+    scoped_feature_list_.InitAndEnableFeature(features::kDockedMagnifier);
+
     // Explicitly enable --ash-constrain-pointer-to-root to be able to test
     // mouse cursor confinement outside the magnifier viewport.
     base::CommandLine::ForCurrentProcess()->AppendSwitch(
@@ -135,6 +140,8 @@
   }
 
  private:
+  base::test::ScopedFeatureList scoped_feature_list_;
+
   DISALLOW_COPY_AND_ASSIGN(DockedMagnifierTest);
 };
 
--- a/ash/magnifier/magnification_controller.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/magnifier/magnification_controller.cc	2019-05-17 18:53:08.180000000 +0300
@@ -4,7 +4,6 @@
 
 #include "ash/magnifier/magnification_controller.h"
 
-#include <algorithm>
 #include <memory>
 #include <utility>
 #include <vector>
@@ -491,14 +490,14 @@
     SwitchTargetRootWindow(current_root, true);
 }
 
-ui::EventDispatchDetails MagnificationController::RewriteEvent(
+ui::EventRewriteStatus MagnificationController::RewriteEvent(
     const ui::Event& event,
-    const Continuation continuation) {
+    std::unique_ptr<ui::Event>* rewritten_event) {
   if (!IsEnabled())
-    return SendEvent(continuation, &event);
+    return ui::EVENT_REWRITE_CONTINUE;
 
   if (!event.IsTouchEvent())
-    return SendEvent(continuation, &event);
+    return ui::EVENT_REWRITE_CONTINUE;
 
   const ui::TouchEvent* touch_event = event.AsTouchEvent();
 
@@ -517,7 +516,7 @@
         touch_event_copy.unique_event_id(), false /* event_consumed */,
         false /* is_source_touch_event_set_non_blocking */);
   } else {
-    return DiscardEvent(continuation);
+    return ui::EVENT_REWRITE_DISCARD;
   }
 
   // User can change zoom level with two fingers pinch and pan around with two
@@ -548,10 +547,8 @@
       // TouchExplorationController confused. Send cancelled event for recorded
       // touch events to the next event rewriter here instead of rewriting an
       // event in the stream.
-      ui::EventDispatchDetails details =
-          SendEvent(continuation, &touch_cancel_event);
-      if (details.dispatcher_destroyed || details.target_destroyed)
-        return details;
+      SendEventToEventSource(root_window_->GetHost()->GetEventSource(),
+                             &touch_cancel_event);
     }
     press_event_map_.clear();
   }
@@ -572,9 +570,16 @@
   }
 
   if (discard)
-    return DiscardEvent(continuation);
+    return ui::EVENT_REWRITE_DISCARD;
+
+  return ui::EVENT_REWRITE_CONTINUE;
+}
 
-  return SendEvent(continuation, &event);
+ui::EventRewriteStatus MagnificationController::NextDispatchEvent(
+    const ui::Event& last_event,
+    std::unique_ptr<ui::Event>* new_event) {
+  NOTREACHED();
+  return ui::EVENT_REWRITE_CONTINUE;
 }
 
 bool MagnificationController::Redraw(const gfx::PointF& position,
--- a/ash/magnifier/magnification_controller.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/magnifier/magnification_controller.h	2019-05-17 18:53:08.180000000 +0300
@@ -164,9 +164,12 @@
   void OnTouchEvent(ui::TouchEvent* event) override;
 
   // ui::EventRewriter overrides:
-  ui::EventDispatchDetails RewriteEvent(
+  ui::EventRewriteStatus RewriteEvent(
       const ui::Event& event,
-      const Continuation continuation) override;
+      std::unique_ptr<ui::Event>* new_event) override;
+  ui::EventRewriteStatus NextDispatchEvent(
+      const ui::Event& last_event,
+      std::unique_ptr<ui::Event>* new_event) override;
 
   // Redraws the magnification window with the given origin position and the
   // given scale. Returns true if the window is changed; otherwise, false.
--- a/ash/media/media_controller.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/media/media_controller.cc	2019-05-17 18:53:08.184000000 +0300
@@ -4,14 +4,10 @@
 
 #include "ash/media/media_controller.h"
 
-#include "base/bind.h"
 #include "base/feature_list.h"
-#include "base/metrics/histogram_macros.h"
 #include "media/base/media_switches.h"
 #include "services/media_session/public/mojom/constants.mojom.h"
-#include "services/media_session/public/mojom/media_session.mojom.h"
 #include "services/service_manager/public/cpp/connector.h"
-#include "ui/base/accelerators/media_keys_util.h"
 
 namespace ash {
 
@@ -63,35 +59,15 @@
   // If media session media key handling is enabled. Toggle play pause using the
   // media session service.
   if (ShouldUseMediaSession()) {
-    switch (media_session_info_->playback_state) {
-      case media_session::mojom::MediaPlaybackState::kPaused:
-        GetMediaSessionController()->Resume();
-        ui::RecordMediaHardwareKeyAction(
-            ui::MediaHardwareKeyAction::kPlay);
-        break;
-      case media_session::mojom::MediaPlaybackState::kPlaying:
-        GetMediaSessionController()->Suspend();
-        ui::RecordMediaHardwareKeyAction(
-            ui::MediaHardwareKeyAction::kPause);
-        break;
-    }
-
+    GetMediaSessionController()->ToggleSuspendResume();
     return;
   }
 
-  // If media session does not handle the key then we don't know whether the
-  // action will play or pause so we should record a generic "play/pause".
-  ui::RecordMediaHardwareKeyAction(
-      ui::MediaHardwareKeyAction::kPlayPause);
-
   if (client_)
     client_->HandleMediaPlayPause();
 }
 
 void MediaController::HandleMediaNextTrack() {
-  ui::RecordMediaHardwareKeyAction(
-      ui::MediaHardwareKeyAction::kNextTrack);
-
   // If media session media key handling is enabled. Fire next track using the
   // media session service.
   if (ShouldUseMediaSession()) {
@@ -104,9 +80,6 @@
 }
 
 void MediaController::HandleMediaPrevTrack() {
-  ui::RecordMediaHardwareKeyAction(
-      ui::MediaHardwareKeyAction::kPreviousTrack);
-
   // If media session media key handling is enabled. Fire previous track using
   // the media session service.
   if (ShouldUseMediaSession()) {
@@ -128,11 +101,6 @@
     client_->SuspendMediaSessions();
 }
 
-void MediaController::MediaSessionInfoChanged(
-    media_session::mojom::MediaSessionInfoPtr session_info) {
-  media_session_info_ = std::move(session_info);
-}
-
 void MediaController::MediaSessionActionsChanged(
     const std::vector<media_session::mojom::MediaSessionAction>& actions) {
   supported_media_session_action_ = false;
@@ -148,7 +116,7 @@
 void MediaController::SetMediaSessionControllerForTest(
     media_session::mojom::MediaControllerPtr controller) {
   media_session_controller_ptr_ = std::move(controller);
-  BindMediaControllerObserver();
+  BindMediaSessionObserver();
 }
 
 void MediaController::FlushForTesting() {
@@ -170,7 +138,7 @@
         base::BindRepeating(&MediaController::OnMediaSessionControllerError,
                             base::Unretained(this)));
 
-    BindMediaControllerObserver();
+    BindMediaSessionObserver();
   }
 
   return media_session_controller_ptr_.get();
@@ -181,19 +149,18 @@
   supported_media_session_action_ = false;
 }
 
-void MediaController::BindMediaControllerObserver() {
+void MediaController::BindMediaSessionObserver() {
   if (!media_session_controller_ptr_.is_bound())
     return;
 
-  media_session::mojom::MediaControllerObserverPtr observer;
-  media_controller_observer_binding_.Bind(mojo::MakeRequest(&observer));
+  media_session::mojom::MediaSessionObserverPtr observer;
+  media_session_observer_binding_.Bind(mojo::MakeRequest(&observer));
   media_session_controller_ptr_->AddObserver(std::move(observer));
 }
 
 bool MediaController::ShouldUseMediaSession() {
   return base::FeatureList::IsEnabled(media::kHardwareMediaKeyHandling) &&
-         GetMediaSessionController() && supported_media_session_action_ &&
-         !media_session_info_.is_null();
+         GetMediaSessionController() && supported_media_session_action_;
 }
 
 }  // namespace ash
--- a/ash/media/media_controller.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/media/media_controller.h	2019-05-17 18:53:08.184000000 +0300
@@ -13,6 +13,7 @@
 #include "mojo/public/cpp/bindings/associated_binding.h"
 #include "mojo/public/cpp/bindings/binding_set.h"
 #include "services/media_session/public/mojom/media_controller.mojom.h"
+#include "services/media_session/public/mojom/media_session.mojom.h"
 
 namespace service_manager {
 class Connector;
@@ -37,7 +38,7 @@
 // been provided to us.
 class ASH_EXPORT MediaController
     : public mojom::MediaController,
-      public media_session::mojom::MediaControllerObserver {
+      public media_session::mojom::MediaSessionObserver {
  public:
   // |connector| can be null in tests.
   explicit MediaController(service_manager::Connector* connector);
@@ -65,9 +66,9 @@
   void RequestCaptureState();
   void SuspendMediaSessions();
 
-  // media_session::mojom::MediaControllerObserver:
+  // media_session::mojom::MediaSessionObserver:
   void MediaSessionInfoChanged(
-      media_session::mojom::MediaSessionInfoPtr session_info) override;
+      media_session::mojom::MediaSessionInfoPtr session_info) override {}
   void MediaSessionMetadataChanged(
       const base::Optional<media_session::MediaMetadata>& metadata) override {}
   void MediaSessionActionsChanged(
@@ -80,9 +81,7 @@
   FRIEND_TEST_ALL_PREFIXES(MediaSessionAcceleratorTest,
                            MediaGlobalAccelerators_NextTrack);
   FRIEND_TEST_ALL_PREFIXES(MediaSessionAcceleratorTest,
-                           MediaGlobalAccelerators_Play);
-  FRIEND_TEST_ALL_PREFIXES(MediaSessionAcceleratorTest,
-                           MediaGlobalAccelerators_Pause);
+                           MediaGlobalAccelerators_PlayPause);
   FRIEND_TEST_ALL_PREFIXES(MediaSessionAcceleratorTest,
                            MediaGlobalAccelerators_PrevTrack);
   FRIEND_TEST_ALL_PREFIXES(MediaSessionAcceleratorTest,
@@ -100,7 +99,7 @@
 
   void OnMediaSessionControllerError();
 
-  void BindMediaControllerObserver();
+  void BindMediaSessionObserver();
 
   // Returns true if we should use the media session service for key handling.
   bool ShouldUseMediaSession();
@@ -109,17 +108,13 @@
   // media key.
   bool supported_media_session_action_ = false;
 
-  // The info about the current media session. It will be null if there is not
-  // a current session.
-  media_session::mojom::MediaSessionInfoPtr media_session_info_;
-
   // Mojo pointer to the active media session controller.
   media_session::mojom::MediaControllerPtr media_session_controller_ptr_;
 
   service_manager::Connector* const connector_;
 
-  mojo::Binding<media_session::mojom::MediaControllerObserver>
-      media_controller_observer_binding_{this};
+  mojo::Binding<media_session::mojom::MediaSessionObserver>
+      media_session_observer_binding_{this};
 
   // Bindings for users of the mojo interface.
   mojo::BindingSet<mojom::MediaController> bindings_;
--- a/ash/media/media_notification_constants.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/media/media_notification_constants.cc	2019-05-17 18:53:08.184000000 +0300
@@ -10,8 +10,4 @@
 
 const char kMediaSessionNotifierId[] = "media-session";
 
-const int kMediaSessionNotificationArtworkMinSize = 114;
-
-const int kMediaSessionNotificationArtworkDesiredSize = 512;
-
 }  // namespace ash
--- a/ash/media/media_notification_constants.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/media/media_notification_constants.h	2019-05-17 18:53:08.184000000 +0300
@@ -15,15 +15,6 @@
 // The notifier ID associated with the media session service.
 ASH_EXPORT extern const char kMediaSessionNotifierId[];
 
-// The minimum size in px that the media session artwork can be to be displayed
-// in the notification.
-ASH_EXPORT extern const int kMediaSessionNotificationArtworkMinSize;
-
-// The desired size in px for the media session artwork to be displayed in the
-// notification. The media session service will try and select artwork closest
-// to this size.
-ASH_EXPORT extern const int kMediaSessionNotificationArtworkDesiredSize;
-
 }  // namespace ash
 
 #endif  // ASH_MEDIA_MEDIA_NOTIFICATION_CONSTANTS_H_
--- a/ash/media/media_notification_controller.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/media/media_notification_controller.cc	2019-05-17 18:53:08.184000000 +0300
@@ -6,7 +6,6 @@
 
 #include "ash/media/media_notification_constants.h"
 #include "ash/media/media_notification_view.h"
-#include "base/bind.h"
 #include "base/stl_util.h"
 #include "services/media_session/public/mojom/constants.mojom.h"
 #include "services/service_manager/public/cpp/connector.h"
--- a/ash/media/media_notification_controller_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/media/media_notification_controller_unittest.cc	2019-05-17 18:53:08.184000000 +0300
@@ -191,24 +191,4 @@
             notification->custom_view_type());
 }
 
-// Test that if we recieve a null media session info that we hide the
-// notification.
-TEST_F(MediaNotificationControllerTest, HandleNullMediaSessionInfo) {
-  ExpectNotificationCount(0);
-
-  base::UnguessableToken id = base::UnguessableToken::Create();
-
-  Shell::Get()->media_notification_controller()->OnFocusGained(
-      GetRequestStateWithId(id));
-
-  ExpectNotificationCount(1);
-
-  Shell::Get()
-      ->media_notification_controller()
-      ->GetItem(id.ToString())
-      ->MediaSessionInfoChanged(nullptr);
-
-  ExpectNotificationCount(0);
-}
-
 }  // namespace ash
--- a/ash/media/media_notification_item.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/media/media_notification_item.cc	2019-05-17 18:53:08.184000000 +0300
@@ -7,7 +7,6 @@
 #include "ash/media/media_notification_constants.h"
 #include "ash/media/media_notification_view.h"
 #include "ash/public/cpp/notification_utils.h"
-#include "base/bind.h"
 #include "base/strings/string16.h"
 #include "base/time/time.h"
 #include "services/media_session/public/mojom/constants.mojom.h"
@@ -38,21 +37,11 @@
     : id_(id),
       media_controller_ptr_(std::move(controller)),
       session_info_(std::move(session_info)) {
+  // Bind an observer to the associated media session.
   if (media_controller_ptr_.is_bound()) {
-    // Bind an observer to the associated media controller.
-    media_session::mojom::MediaControllerObserverPtr media_controller_observer;
-    observer_binding_.Bind(mojo::MakeRequest(&media_controller_observer));
-    media_controller_ptr_->AddObserver(std::move(media_controller_observer));
-
-    // TODO(https://crbug.com/931397): Use dip to calculate the size.
-    // Bind an observer to be notified when the artwork changes.
-    media_session::mojom::MediaControllerImageObserverPtr artwork_observer;
-    artwork_observer_binding_.Bind(mojo::MakeRequest(&artwork_observer));
-    media_controller_ptr_->ObserveImages(
-        media_session::mojom::MediaSessionImageType::kArtwork,
-        kMediaSessionNotificationArtworkMinSize,
-        kMediaSessionNotificationArtworkDesiredSize,
-        std::move(artwork_observer));
+    media_session::mojom::MediaSessionObserverPtr media_session_observer;
+    observer_binding_.Bind(mojo::MakeRequest(&media_session_observer));
+    media_controller_ptr_->AddObserver(std::move(media_session_observer));
   }
 
   MaybeHideOrShowNotification();
@@ -89,27 +78,16 @@
     view_->UpdateWithMediaActions(session_actions_);
 }
 
-void MediaNotificationItem::MediaControllerImageChanged(
-    media_session::mojom::MediaSessionImageType type,
-    const SkBitmap& bitmap) {
-  DCHECK_EQ(media_session::mojom::MediaSessionImageType::kArtwork, type);
-
-  session_artwork_ = gfx::ImageSkia::CreateFrom1xBitmap(bitmap);
-
-  if (view_)
-    view_->UpdateWithMediaArtwork(session_artwork_);
-}
-
 void MediaNotificationItem::SetView(MediaNotificationView* view) {
   DCHECK(view_ || view);
 
   view_ = view;
 
   if (view) {
+    DCHECK(!session_info_.is_null());
     view_->UpdateWithMediaSessionInfo(session_info_);
     view_->UpdateWithMediaMetadata(session_metadata_);
     view_->UpdateWithMediaActions(session_actions_);
-    view_->UpdateWithMediaArtwork(session_artwork_);
   }
 }
 
@@ -120,7 +98,7 @@
 void MediaNotificationItem::MaybeHideOrShowNotification() {
   // If the |is_controllable| bit is set in MediaSessionInfo then we should show
   // a media notification.
-  if (!session_info_ || !session_info_->is_controllable) {
+  if (!session_info_->is_controllable) {
     HideNotification();
     return;
   }
--- a/ash/media/media_notification_item.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/media/media_notification_item.h	2019-05-17 18:53:08.184000000 +0300
@@ -13,8 +13,6 @@
 #include "base/memory/weak_ptr.h"
 #include "mojo/public/cpp/bindings/binding.h"
 #include "services/media_session/public/mojom/media_controller.mojom.h"
-#include "services/media_session/public/mojom/media_session.mojom.h"
-#include "ui/gfx/image/image_skia.h"
 
 namespace ash {
 
@@ -23,15 +21,14 @@
 // MediaNotificationItem manages hiding/showing a media notification and
 // updating the metadata for a single media session.
 class ASH_EXPORT MediaNotificationItem
-    : public media_session::mojom::MediaControllerObserver,
-      public media_session::mojom::MediaControllerImageObserver {
+    : public media_session::mojom::MediaSessionObserver {
  public:
   MediaNotificationItem(const std::string& id,
                         media_session::mojom::MediaControllerPtr controller,
                         media_session::mojom::MediaSessionInfoPtr session_info);
   ~MediaNotificationItem() override;
 
-  // media_session::mojom::MediaControllerObserver:
+  // media_session::mojom::MediaSessionObserver:
   void MediaSessionInfoChanged(
       media_session::mojom::MediaSessionInfoPtr session_info) override;
   void MediaSessionMetadataChanged(
@@ -40,11 +37,6 @@
       const std::vector<media_session::mojom::MediaSessionAction>& actions)
       override;
 
-  // media_session::mojom::MediaControllerImageObserver:
-  void MediaControllerImageChanged(
-      media_session::mojom::MediaSessionImageType type,
-      const SkBitmap& bitmap) override;
-
   void SetView(MediaNotificationView* view);
 
   void FlushForTesting();
@@ -77,13 +69,8 @@
 
   std::set<media_session::mojom::MediaSessionAction> session_actions_;
 
-  gfx::ImageSkia session_artwork_;
-
-  mojo::Binding<media_session::mojom::MediaControllerObserver>
-      observer_binding_{this};
-
-  mojo::Binding<media_session::mojom::MediaControllerImageObserver>
-      artwork_observer_binding_{this};
+  mojo::Binding<media_session::mojom::MediaSessionObserver> observer_binding_{
+      this};
 
   base::WeakPtrFactory<MediaNotificationItem> weak_ptr_factory_{this};
 
--- a/ash/media/media_notification_view.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/media/media_notification_view.cc	2019-05-17 18:53:08.184000000 +0300
@@ -17,9 +17,7 @@
 #include "ui/message_center/views/notification_control_buttons_view.h"
 #include "ui/message_center/views/notification_header_view.h"
 #include "ui/views/controls/button/image_button_factory.h"
-#include "ui/views/controls/image_view.h"
 #include "ui/views/layout/box_layout.h"
-#include "ui/views/layout/fill_layout.h"
 #include "ui/views/style/typography.h"
 
 namespace ash {
@@ -38,8 +36,6 @@
 // Dimensions.
 constexpr int kDefaultMarginSize = 16;
 constexpr int kMediaButtonIconSize = 24;
-constexpr gfx::Size kMediaArtworkSize = gfx::Size(104, 104);
-constexpr gfx::Size kMediaArtworkExpandedSize = gfx::Size(152, 152);
 
 SkColor GetMediaNotificationColor(const views::View& view) {
   return views::style::GetColor(view, views::style::CONTEXT_LABEL,
@@ -58,19 +54,8 @@
 MediaNotificationView::MediaNotificationView(
     const message_center::Notification& notification)
     : message_center::MessageView(notification) {
-  SetLayoutManager(std::make_unique<views::FillLayout>());
-
-  // |artwork_| displays the image showing the artwork for the media.
-  artwork_ = new views::ImageView();
-  artwork_->SetImageSize(kMediaArtworkSize);
-  artwork_->SetHorizontalAlignment(views::ImageView::TRAILING);
-  AddChildView(artwork_);
-
-  // |layout_row_| holds the main box layout for the notification.
-  layout_row_ = new views::View();
-  layout_row_->SetLayoutManager(std::make_unique<views::BoxLayout>(
+  SetLayoutManager(std::make_unique<views::BoxLayout>(
       views::BoxLayout::kVertical, gfx::Insets(), 0));
-  AddChildView(layout_row_);
 
   // |controls_button_view_| has the common notification control buttons.
   control_buttons_view_ =
@@ -83,11 +68,11 @@
   header_row_->SetExpandButtonEnabled(true);
   header_row_->SetAppName(
       message_center::MessageCenter::Get()->GetSystemNotificationAppName());
-  layout_row_->AddChildView(header_row_);
+  AddChildView(header_row_);
 
   // |main_row_| holds the main content of the notification.
   main_row_ = new views::View();
-  layout_row_->AddChildView(main_row_);
+  AddChildView(main_row_);
 
   // |title_artist_row_| contains the title and artist labels.
   title_artist_row_ = new views::View();
@@ -149,6 +134,8 @@
   CreateMediaButton(vector_icons::kMediaNextTrackIcon,
                     MediaSessionAction::kNextTrack);
 
+  // TODO(beccahughes): Add remaining UI for notification.
+
   UpdateControlButtonsVisibilityWithNotification(notification);
   UpdateCornerRadius(message_center::kNotificationCornerRadius,
                      message_center::kNotificationCornerRadius);
@@ -187,15 +174,6 @@
   PreferredSizeChanged();
 }
 
-gfx::Size MediaNotificationView::CalculatePreferredSize() const {
-  // The size of the notification should be the standard width and the height
-  // should be fixed to the height of the artwork based on whether the
-  // notification is expanded or not.
-  return gfx::Size(message_center::kNotificationWidth,
-                   expanded_ ? kMediaArtworkExpandedSize.height()
-                             : kMediaArtworkSize.height());
-}
-
 void MediaNotificationView::OnMouseEvent(ui::MouseEvent* event) {
   switch (event->type()) {
     case ui::ET_MOUSE_ENTERED:
@@ -227,8 +205,7 @@
 
 void MediaNotificationView::UpdateWithMediaSessionInfo(
     const media_session::mojom::MediaSessionInfoPtr& session_info) {
-  bool playing =
-      session_info && session_info->playback_state ==
+  bool playing = session_info->playback_state ==
                           media_session::mojom::MediaPlaybackState::kPlaying;
   play_pause_button_->SetToggled(playing);
 
@@ -236,8 +213,7 @@
       playing ? MediaSessionAction::kPause : MediaSessionAction::kPlay;
   play_pause_button_->set_tag(static_cast<int>(action));
   play_pause_button_->SetVisible(IsActionButtonVisible(action));
-
-  layout_row_->Layout();
+  PreferredSizeChanged();
 }
 
 void MediaNotificationView::UpdateWithMediaMetadata(
@@ -267,12 +243,7 @@
     const std::set<media_session::mojom::MediaSessionAction>& actions) {
   enabled_actions_ = actions;
   UpdateActionButtonsVisibility();
-  layout_row_->Layout();
-}
-
-void MediaNotificationView::UpdateWithMediaArtwork(
-    const gfx::ImageSkia& image) {
-  artwork_->SetImage(image);
+  PreferredSizeChanged();
 }
 
 void MediaNotificationView::UpdateControlButtonsVisibilityWithNotification(
@@ -321,8 +292,6 @@
                         kDefaultMarginSize, kRightMarginExpandedSize),
             kDefaultMarginSize))
         ->SetDefaultFlex(1);
-
-    artwork_->SetImageSize(kMediaArtworkExpandedSize);
   } else {
     main_row_
         ->SetLayoutManager(std::make_unique<views::BoxLayout>(
@@ -331,8 +300,6 @@
                         kRightMarginSize),
             kDefaultMarginSize, true))
         ->SetDefaultFlex(1);
-
-    artwork_->SetImageSize(kMediaArtworkSize);
   }
 
   header_row_->SetExpanded(expanded_);
--- a/ash/media/media_notification_view.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/media/media_notification_view.h	2019-05-17 18:53:08.184000000 +0300
@@ -12,10 +12,6 @@
 #include "ui/views/controls/button/image_button.h"
 #include "ui/views/controls/label.h"
 
-namespace gfx {
-class ImageSkia;
-}  // namespace gfx
-
 namespace media_session {
 struct MediaMetadata;
 }  // namespace media_session
@@ -29,7 +25,6 @@
 }  // namespace message_center
 
 namespace views {
-class ImageView;
 class ToggleImageButton;
 class View;
 }  // namespace views
@@ -55,7 +50,6 @@
   void SetExpanded(bool expanded) override;
 
   // views::View:
-  gfx::Size CalculatePreferredSize() const override;
   void OnMouseEvent(ui::MouseEvent* event) override;
 
   // views::ButtonListener:
@@ -66,7 +60,6 @@
   void UpdateWithMediaMetadata(const media_session::MediaMetadata& metadata);
   void UpdateWithMediaActions(
       const std::set<media_session::mojom::MediaSessionAction>& actions);
-  void UpdateWithMediaArtwork(const gfx::ImageSkia& image);
 
  private:
   friend class MediaNotificationViewTest;
@@ -102,9 +95,7 @@
   views::View* title_artist_row_ = nullptr;
   views::Label* title_label_ = nullptr;
   views::Label* artist_label_ = nullptr;
-  views::View* layout_row_ = nullptr;
   views::View* main_row_ = nullptr;
-  views::ImageView* artwork_ = nullptr;
 
   DISALLOW_COPY_AND_ASSIGN(MediaNotificationView);
 };
--- a/ash/media/media_notification_view_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/media/media_notification_view_unittest.cc	2019-05-17 18:53:08.184000000 +0300
@@ -16,7 +16,6 @@
 #include "ash/system/status_area_widget_test_helper.h"
 #include "ash/system/unified/unified_system_tray.h"
 #include "ash/test/ash_test_base.h"
-#include "base/bind.h"
 #include "base/macros.h"
 #include "base/strings/utf_string_conversions.h"
 #include "base/test/scoped_feature_list.h"
@@ -30,7 +29,6 @@
 #include "ui/message_center/views/message_view_factory.h"
 #include "ui/message_center/views/notification_control_buttons_view.h"
 #include "ui/message_center/views/notification_header_view.h"
-#include "ui/views/controls/image_view.h"
 
 namespace ash {
 
@@ -189,8 +187,6 @@
 
   views::View* title_artist_row() const { return view_->title_artist_row_; }
 
-  views::ImageView* artwork() const { return view_->artwork_; }
-
   views::Label* title_label() const { return view_->title_label_; }
 
   views::Label* artist_label() const { return view_->artist_label_; }
@@ -665,45 +661,4 @@
   EXPECT_FALSE(IsActionButtonVisible(MediaSessionAction::kNextTrack));
 }
 
-TEST_F(MediaNotificationViewTest, ArtworkHeightWhenCollapsedOrExpanded) {
-  EXPECT_TRUE(is_expanded());
-
-  // Ensure that the notification and the artwork are the same height.
-  int height = view()->height();
-  EXPECT_EQ(height, artwork()->height());
-
-  view()->SetExpanded(false);
-
-  // Ensure that the notification reduced in height and the artwork is the same
-  // height.
-  EXPECT_FALSE(is_expanded());
-  EXPECT_GT(height, view()->height());
-  EXPECT_EQ(view()->height(), artwork()->height());
-}
-
-TEST_F(MediaNotificationViewTest, UpdateArtworkFromItem) {
-  gfx::Size size = view()->size();
-
-  SkBitmap image;
-  image.allocN32Pixels(10, 10);
-
-  EXPECT_TRUE(artwork()->GetImage().isNull());
-
-  GetItem()->MediaControllerImageChanged(
-      media_session::mojom::MediaSessionImageType::kArtwork, image);
-
-  // Ensure that the image is displayed in |artwork| and that the size of the
-  // notification was not affected.
-  EXPECT_FALSE(artwork()->GetImage().isNull());
-  EXPECT_EQ(gfx::Size(10, 10), artwork()->GetImage().size());
-  EXPECT_EQ(size, view()->size());
-
-  GetItem()->MediaControllerImageChanged(
-      media_session::mojom::MediaSessionImageType::kArtwork, SkBitmap());
-
-  // Ensure that |artwork| was reset and the size was still not affected.
-  EXPECT_TRUE(artwork()->GetImage().isNull());
-  EXPECT_EQ(size, view()->size());
-}
-
 }  // namespace ash
--- a/ash/metrics/demo_session_metrics_recorder.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/metrics/demo_session_metrics_recorder.cc	2019-05-17 18:53:08.184000000 +0300
@@ -4,7 +4,6 @@
 
 #include "ash/metrics/demo_session_metrics_recorder.h"
 
-#include <iostream>
 #include <string>
 #include <utility>
 
@@ -13,7 +12,6 @@
 #include "ash/shelf/shelf_window_watcher.h"
 #include "ash/shell.h"
 #include "base/metrics/histogram_macros.h"
-#include "base/scoped_observer.h"
 #include "base/time/time.h"
 #include "base/timer/timer.h"
 #include "extensions/common/constants.h"
@@ -22,7 +20,6 @@
 #include "ui/aura/window.h"
 #include "ui/base/ui_base_features.h"
 #include "ui/base/user_activity/user_activity_detector.h"
-#include "ui/wm/core/focus_controller.h"
 #include "ui/wm/public/activation_client.h"
 
 namespace ash {
@@ -49,17 +46,8 @@
     return DemoModeApp::kHighlights;
   }
 
-  // Each version of the Screensaver app is bucketed into the same value.
-  if (app_id == extension_misc::kScreensaverAppId ||
-      app_id == extension_misc::kScreensaverAlt1AppId ||
-      app_id == extension_misc::kScreensaverAlt2AppId) {
-    return DemoModeApp::kScreensaver;
-  }
-
   if (app_id == extension_misc::kCameraAppId)
     return DemoModeApp::kCamera;
-  if (app_id == extension_misc::kChromeAppId)
-    return DemoModeApp::kBrowser;
   if (app_id == extension_misc::kFilesManagerAppId)
     return DemoModeApp::kFiles;
   if (app_id == extension_misc::kGeniusAppId)
@@ -98,46 +86,21 @@
   return DemoModeApp::kOtherArcApp;
 }
 
-AppType GetAppType(const aura::Window* window) {
-  return static_cast<AppType>(window->GetProperty(aura::client::kAppType));
-}
-
-bool IsArcWindow(const aura::Window* window) {
-  return (GetAppType(window) == AppType::ARC_APP);
-}
-
-const std::string* GetArcPackageName(const aura::Window* window) {
-  DCHECK(IsArcWindow(window));
-  return window->GetProperty(kArcPackageNameKey);
-}
-
-bool CanGetAppFromWindow(const aura::Window* window) {
-  // For ARC apps we can only get the App if the package
-  // name is not null.
-  if (IsArcWindow(window)) {
-    return GetArcPackageName(window) != nullptr;
-  }
-  // We can always get the App for non-ARC windows.
-  return true;
-}
-
-const ShelfID GetShelfID(const aura::Window* window) {
-  return ShelfID::Deserialize(window->GetProperty(kShelfIDKey));
-}
-
 // Maps the app-like thing in |window| to a DemoModeApp value for metrics.
 DemoModeApp GetAppFromWindow(const aura::Window* window) {
-  DCHECK(CanGetAppFromWindow(window));
-
-  AppType app_type = GetAppType(window);
-  if (app_type == AppType::ARC_APP) {
+  ash::AppType app_type =
+      static_cast<ash::AppType>(window->GetProperty(aura::client::kAppType));
+  if (app_type == ash::AppType::ARC_APP) {
     // The ShelfID app id isn't used to identify ARC++ apps since it's a hash of
     // both the package name and the activity.
-    const std::string* package_name = GetArcPackageName(window);
-    return GetAppFromPackageName(*package_name);
+    const std::string* package_name =
+        static_cast<std::string*>(window->GetProperty(kArcPackageNameKey));
+    return package_name ? GetAppFromPackageName(*package_name)
+                        : DemoModeApp::kOtherArcApp;
   }
 
-  std::string app_id = GetShelfID(window).app_id;
+  std::string app_id =
+      ShelfID::Deserialize(window->GetProperty(kShelfIDKey)).app_id;
 
   // The Chrome "app" in the shelf is just the browser.
   if (app_id == extension_misc::kChromeAppId)
@@ -153,208 +116,33 @@
 
   // If the window is the "browser" type, having an app ID other than the
   // default indicates a hosted/bookmark app.
-  if (app_type == AppType::CHROME_APP ||
-      (app_type == AppType::BROWSER && !is_default(app_id))) {
+  if (app_type == ash::AppType::CHROME_APP ||
+      (app_type == ash::AppType::BROWSER && !is_default(app_id))) {
     return GetAppFromAppId(app_id);
   }
 
-  if (app_type == AppType::BROWSER)
+  if (app_type == ash::AppType::BROWSER)
     return DemoModeApp::kBrowser;
   return DemoModeApp::kOtherWindow;
 }
 
 }  // namespace
 
-// Observes for changes in a window's ArcPackageName property for the purpose of
-// logging  of active app samples.
-class DemoSessionMetricsRecorder::ActiveAppArcPackageNameObserver
-    : public aura::WindowObserver {
- public:
-  explicit ActiveAppArcPackageNameObserver(
-      DemoSessionMetricsRecorder* metrics_recorder)
-      : metrics_recorder_(metrics_recorder), scoped_observer_(this) {}
-
-  // aura::WindowObserver
-  void OnWindowPropertyChanged(aura::Window* window,
-                               const void* key,
-                               intptr_t old) override {
-    if (key != kArcPackageNameKey)
-      return;
-
-    const std::string* package_name = GetArcPackageName(window);
-
-    if (package_name) {
-      metrics_recorder_->RecordActiveAppSample(
-          GetAppFromPackageName(*package_name));
-    } else {
-      VLOG(1) << "Got null ARC package name";
-    }
-
-    scoped_observer_.Remove(window);
-  }
-
-  void OnWindowDestroyed(aura::Window* window) override {
-    if (scoped_observer_.IsObserving(window))
-      scoped_observer_.Remove(window);
-  }
-
-  void ObserveWindow(aura::Window* window) { scoped_observer_.Add(window); }
-
- private:
-  DemoSessionMetricsRecorder* metrics_recorder_;
-  ScopedObserver<aura::Window, ActiveAppArcPackageNameObserver>
-      scoped_observer_;
-
-  DISALLOW_COPY_AND_ASSIGN(ActiveAppArcPackageNameObserver);
-};
-
-// Observes changes in a window's ArcPackageName property for the purpose of
-// logging of unique launches of ARC apps.
-class DemoSessionMetricsRecorder::UniqueAppsLaunchedArcPackageNameObserver
-    : public aura::WindowObserver {
- public:
-  explicit UniqueAppsLaunchedArcPackageNameObserver(
-      DemoSessionMetricsRecorder* metrics_recorder)
-      : metrics_recorder_(metrics_recorder), scoped_observer_(this) {}
-
-  // aura::WindowObserver
-  void OnWindowPropertyChanged(aura::Window* window,
-                               const void* key,
-                               intptr_t old) override {
-    if (key != kArcPackageNameKey)
-      return;
-
-    const std::string* package_name = GetArcPackageName(window);
-
-    if (package_name) {
-      metrics_recorder_->RecordAppLaunch(*package_name, AppType::ARC_APP);
-    } else {
-      VLOG(1) << "Got null ARC package name";
-    }
-
-    scoped_observer_.Remove(window);
-  }
-
-  void OnWindowDestroyed(aura::Window* window) override {
-    if (scoped_observer_.IsObserving(window))
-      scoped_observer_.Remove(window);
-  }
-
-  void ObserveWindow(aura::Window* window) { scoped_observer_.Add(window); }
-
- private:
-  DemoSessionMetricsRecorder* metrics_recorder_;
-  ScopedObserver<aura::Window, UniqueAppsLaunchedArcPackageNameObserver>
-      scoped_observer_;
-
-  DISALLOW_COPY_AND_ASSIGN(UniqueAppsLaunchedArcPackageNameObserver);
-};
-
 DemoSessionMetricsRecorder::DemoSessionMetricsRecorder(
     std::unique_ptr<base::RepeatingTimer> timer)
-    : timer_(std::move(timer)),
-      observer_(this),
-      unique_apps_arc_package_name_observer_(
-          std::make_unique<UniqueAppsLaunchedArcPackageNameObserver>(this)),
-      active_app_arc_package_name_observer_(
-          std::make_unique<ActiveAppArcPackageNameObserver>(this)) {
+    : timer_(std::move(timer)), observer_(this) {
   // Outside of tests, use a normal repeating timer.
   if (!timer_.get())
     timer_ = std::make_unique<base::RepeatingTimer>();
 
   StartRecording();
   observer_.Add(ui::UserActivityDetector::Get());
-
-  // Subscribe to window activation updates.  Even though this gets us
-  // notifications for all window activations, we ignore the ARC
-  // notifications because they don't contain the app_id.  We handle
-  // accounting for ARC windows with OnTaskCreated.
-  if (Shell::Get()->GetPrimaryRootWindow()) {
-    activation_client_ = Shell::Get()->focus_controller();
-    activation_client_->AddObserver(this);
-  }
 }
 
 DemoSessionMetricsRecorder::~DemoSessionMetricsRecorder() {
   // Report any remaining stored samples on exit. (If the user went idle, there
   // won't be any.)
   ReportSamples();
-
-  // Unsubscribe from window activation events.
-  activation_client_->RemoveObserver(this);
-
-  ReportUniqueAppsLaunched();
-}
-
-void DemoSessionMetricsRecorder::RecordAppLaunch(const std::string& id,
-                                                 AppType app_type) {
-  if (!ShouldRecordAppLaunch(id)) {
-    return;
-  }
-  DemoModeApp app;
-  if (app_type == AppType::ARC_APP)
-    app = GetAppFromPackageName(id);
-  else
-    app = GetAppFromAppId(id);
-
-  if (!unique_apps_launched_.contains(id)) {
-    unique_apps_launched_.insert(id);
-    // Only log each app launch once.  This is determined by
-    // checking the package_name instead of the DemoApp enum,
-    // because the DemoApp enum collapses unknown apps into
-    // a single enum.
-    UMA_HISTOGRAM_ENUMERATION("DemoMode.AppLaunched", app);
-  }
-}
-
-// Indicates whether the specified app_id should be recorded for
-// the unique-apps-launched stat.
-bool DemoSessionMetricsRecorder::ShouldRecordAppLaunch(
-    const std::string& app_id) {
-  return unique_apps_launched_recording_enabled_ &&
-         GetAppFromAppId(app_id) != DemoModeApp::kHighlights &&
-         GetAppFromAppId(app_id) != DemoModeApp::kScreensaver;
-}
-
-void DemoSessionMetricsRecorder::OnWindowActivated(ActivationReason reason,
-                                                   aura::Window* gained_active,
-                                                   aura::Window* lost_active) {
-  if (!gained_active)
-    return;
-
-  // Don't count popup windows.
-  if (gained_active->type() != aura::client::WINDOW_TYPE_NORMAL)
-    return;
-
-  AppType app_type = GetAppType(gained_active);
-
-  std::string app_id;
-  if (app_type == AppType::ARC_APP) {
-    const std::string* package_name = GetArcPackageName(gained_active);
-
-    if (!package_name) {
-      // The package name property for the window has not been set yet.
-      // Listen for changes to the window properties so we can
-      // be informed when the package name gets set.
-      if (!gained_active->HasObserver(
-              unique_apps_arc_package_name_observer_.get())) {
-        unique_apps_arc_package_name_observer_->ObserveWindow(gained_active);
-      }
-      return;
-    }
-    app_id = *package_name;
-  } else {
-    // This is a non-ARC window, so we just get the shelf ID, which should
-    // be unique per app.
-    app_id = GetShelfID(gained_active).app_id;
-  }
-
-  // Some app_ids are empty, i.e the "You will be signed out
-  // in X seconds" modal dialog in Demo Mode, so skip those.
-  if (app_id.empty())
-    return;
-
-  RecordAppLaunch(app_id, app_type);
 }
 
 void DemoSessionMetricsRecorder::OnUserActivity(const ui::Event* event) {
@@ -368,15 +156,10 @@
 }
 
 void DemoSessionMetricsRecorder::StartRecording() {
-  unique_apps_launched_recording_enabled_ = true;
   timer_->Start(FROM_HERE, kSamplePeriod, this,
                 &DemoSessionMetricsRecorder::TakeSampleOrPause);
 }
 
-void DemoSessionMetricsRecorder::RecordActiveAppSample(DemoModeApp app) {
-  unreported_samples_.push_back(app);
-}
-
 void DemoSessionMetricsRecorder::TakeSampleOrPause() {
   // After enough inactive time, assume the user left.
   if (++periods_since_activity_ > kMaxPeriodsWithoutActivity) {
@@ -386,21 +169,15 @@
     return;
   }
 
-  aura::Window* window = Shell::Get()->activation_client()->GetActiveWindow();
+  const aura::Window* window =
+      ash::Shell::Get()->activation_client()->GetActiveWindow();
   if (!window)
     return;
 
-  // If there is no ARC package name available, set up a listener
-  // to be informed when it is available.
-  if (IsArcWindow(window) && !CanGetAppFromWindow(window)) {
-    active_app_arc_package_name_observer_->ObserveWindow(window);
-    return;
-  }
-
   DemoModeApp app = window->type() == aura::client::WINDOW_TYPE_NORMAL
                         ? GetAppFromWindow(window)
                         : DemoModeApp::kOtherWindow;
-  RecordActiveAppSample(app);
+  unreported_samples_.push_back(app);
 }
 
 void DemoSessionMetricsRecorder::ReportSamples() {
@@ -409,11 +186,4 @@
   unreported_samples_.clear();
 }
 
-void DemoSessionMetricsRecorder::ReportUniqueAppsLaunched() {
-  if (unique_apps_launched_recording_enabled_)
-    UMA_HISTOGRAM_COUNTS_100("DemoMode.UniqueAppsLaunched",
-                             unique_apps_launched_.size());
-  unique_apps_launched_.clear();
-}
-
 }  // namespace ash
--- a/ash/metrics/demo_session_metrics_recorder.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/metrics/demo_session_metrics_recorder.h	2019-05-17 18:53:08.184000000 +0300
@@ -6,18 +6,12 @@
 #define ASH_METRICS_DEMO_SESSION_METRICS_RECORDER_H_
 
 #include <memory>
-#include <string>
 #include <vector>
 
 #include "ash/ash_export.h"
-#include "ash/public/cpp/app_types.h"
-#include "base/containers/flat_set.h"
 #include "base/macros.h"
 #include "base/scoped_observer.h"
-#include "ui/aura/window_observer.h"
 #include "ui/base/user_activity/user_activity_observer.h"
-#include "ui/wm/public/activation_change_observer.h"
-#include "ui/wm/public/activation_client.h"
 
 namespace base {
 class RepeatingTimer;
@@ -31,9 +25,7 @@
 
 // A metrics recorder for demo sessions that samples the active window's app or
 // window type. Only used when the device is in Demo Mode.
-class ASH_EXPORT DemoSessionMetricsRecorder
-    : public ui::UserActivityObserver,
-      public wm::ActivationChangeObserver {
+class ASH_EXPORT DemoSessionMetricsRecorder : public ui::UserActivityObserver {
  public:
   // These apps are preinstalled in Demo Mode. This list is not exhaustive, and
   // includes first- and third-party Chrome and ARC apps.
@@ -60,10 +52,9 @@
     kSquid = 16,  // Android note-taking app.
     kWebStore = 17,
     kYouTube = 18,
-    kScreensaver = 19,  // Demo Mode screensaver app.
     // Add future entries above this comment, in sync with enums.xml.
     // Update kMaxValue to the last value.
-    kMaxValue = kScreensaver,
+    kMaxValue = kYouTube,
   };
 
   // The recorder will create a normal timer by default. Tests should provide a
@@ -75,11 +66,6 @@
   // ui::UserActivityObserver:
   void OnUserActivity(const ui::Event* event) override;
 
-  // wm::ActivationChangeObserver:
-  void OnWindowActivated(wm::ActivationChangeObserver::ActivationReason reason,
-                         aura::Window* gained_active,
-                         aura::Window* lost_active) override;
-
  private:
   // Starts the timer for periodic sampling.
   void StartRecording();
@@ -91,33 +77,10 @@
   // Emits histograms for recorded samples.
   void ReportSamples();
 
-  // Records |app| as being seen while sampling all active apps.
-  void RecordActiveAppSample(DemoModeApp app);
-
-  // Indicates whether the specified app_id should be recorded for
-  // the unique-apps-launched stat.
-  bool ShouldRecordAppLaunch(const std::string& app_id);
-
-  // Records the specified app's launch, subject to the
-  // restrictions of ShouldRecordAppLaunch().
-  void RecordAppLaunch(const std::string& id, AppType app_type);
-
-  // Emits various histograms for unique apps launched.
-  void ReportUniqueAppsLaunched();
-
   // Stores samples as they are collected. Report to UMA if we see user
   // activity soon after. Guaranteed not to grow too large.
   std::vector<DemoModeApp> unreported_samples_;
 
-  // Indicates whether the unique-app-launch stats recording has been enabled.
-  bool unique_apps_launched_recording_enabled_ = false;
-
-  // Tracks the ids of apps that have been launched in Demo Mode.
-  base::flat_set<std::string> unique_apps_launched_;
-
-  // Used for subscribing to window activation events.
-  wm::ActivationClient* activation_client_ = nullptr;
-
   // How many periods have elapsed since the last user activity.
   int periods_since_activity_ = 0;
 
@@ -126,18 +89,9 @@
   ScopedObserver<ui::UserActivityDetector, DemoSessionMetricsRecorder>
       observer_;
 
-  class ActiveAppArcPackageNameObserver;
-  class UniqueAppsLaunchedArcPackageNameObserver;
-
-  std::unique_ptr<UniqueAppsLaunchedArcPackageNameObserver>
-      unique_apps_arc_package_name_observer_;
-
-  std::unique_ptr<ActiveAppArcPackageNameObserver>
-      active_app_arc_package_name_observer_;
-
   DISALLOW_COPY_AND_ASSIGN(DemoSessionMetricsRecorder);
 };
 
 }  // namespace ash
 
-#endif  // ASH_METRICS_DEMO_SESSION_METRICS_RECORDER_H_
+#endif  // ASH_METRICS_POINTER_METRICS_RECORDER_H_
--- a/ash/metrics/demo_session_metrics_recorder_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/metrics/demo_session_metrics_recorder_unittest.cc	2019-05-17 18:53:08.184000000 +0300
@@ -129,7 +129,6 @@
     window->SetProperty(
         kShelfIDKey,
         new std::string(ShelfID(app_id, std::string()).Serialize()));
-    if (!package_name.empty())
       window->SetProperty(kArcPackageNameKey, new std::string(package_name));
     return window;
   }
@@ -159,7 +158,7 @@
 
 // Verify samples are correct when one app window is active.
 TEST_F(DemoSessionMetricsRecorderTest, ActiveApp) {
-  std::unique_ptr<aura::Window> chrome_app_window =
+  auto chrome_app_window =
       CreateChromeAppWindow(extension_misc::kHighlightsAppId);
 
   wm::ActivateWindow(chrome_app_window.get());
@@ -175,8 +174,8 @@
 
 // Verify samples are correct when multiple browser windows become active.
 TEST_F(DemoSessionMetricsRecorderTest, BrowserWindows) {
-  std::unique_ptr<aura::Window> browser_window = CreateBrowserWindow();
-  std::unique_ptr<aura::Window> browser_window2 = CreateBrowserWindow();
+  auto browser_window = CreateBrowserWindow();
+  auto browser_window2 = CreateBrowserWindow();
 
   // Browser windows should all be treated as the same type.
   wm::ActivateWindow(browser_window.get());
@@ -194,13 +193,11 @@
 
 // Verify samples are correct when multiple windows types become active.
 TEST_F(DemoSessionMetricsRecorderTest, AppTypes) {
-  std::unique_ptr<aura::Window> browser_window = CreateBrowserWindow();
-  std::unique_ptr<aura::Window> chrome_app_window =
-      CreateChromeAppWindow(extension_misc::kCameraAppId);
-  std::unique_ptr<aura::Window> hosted_app_browser_window =
+  auto browser_window = CreateBrowserWindow();
+  auto chrome_app_window = CreateChromeAppWindow(extension_misc::kCameraAppId);
+  auto hosted_app_browser_window =
       CreateHostedAppBrowserWindow(extension_misc::kYoutubeAppId);
-  std::unique_ptr<aura::Window> arc_window =
-      CreateArcWindow("com.google.Photos");
+  auto arc_window = CreateArcWindow("com.google.Photos");
 
   wm::ActivateWindow(browser_window.get());
   FireTimer();
@@ -239,59 +236,10 @@
   histogram_tester_->ExpectTotalCount("DemoMode.ActiveApp", 10);
 }
 
-// Verify samples are correct when multiple windows types become active.
-TEST_F(DemoSessionMetricsRecorderTest, ActiveAppAfterDelayedArcPackageName) {
-  // Create an ARC window with an empty package name.
-  std::unique_ptr<aura::Window> arc_window = CreateArcWindow("");
-
-  wm::ActivateWindow(arc_window.get());
-  FireTimer();
-  SendUserActivity();
-
-  // There should be no app activity recorded yet, because there was
-  // no package name in the ARC window.
-  histogram_tester_->ExpectTotalCount("DemoMode.ActiveApp", 0);
-
-  // Set the package name after window creation/activation.
-  arc_window->SetProperty(kArcPackageNameKey,
-                          new std::string("com.google.Photos"));
-
-  // Trigger sample reporting by sending user activity.
-  SendUserActivity();
-
-  histogram_tester_->ExpectBucketCount(
-      "DemoMode.ActiveApp",
-      DemoSessionMetricsRecorder::DemoModeApp::kGooglePhotos, 1);
-
-  // Set the package name again.  The count shouldn't change because
-  // after getting the package name once, we stop observing the
-  // window.
-  arc_window->SetProperty(kArcPackageNameKey,
-                          new std::string("com.google.Photos"));
-  // Trigger sample reporting by sending user activity.
-  SendUserActivity();
-
-  histogram_tester_->ExpectBucketCount(
-      "DemoMode.ActiveApp",
-      DemoSessionMetricsRecorder::DemoModeApp::kGooglePhotos, 1);
-
-  // Delete the window.
-  arc_window.reset();
-
-  // Trigger sample reporting by sending user activity.
-  SendUserActivity();
-
-  // The count should not be affected.
-  histogram_tester_->ExpectBucketCount(
-      "DemoMode.ActiveApp",
-      DemoSessionMetricsRecorder::DemoModeApp::kGooglePhotos, 1);
-}
-
 // Verify popup windows are categorized as kOtherWindow.
 TEST_F(DemoSessionMetricsRecorderTest, PopupWindows) {
-  std::unique_ptr<aura::Window> chrome_app_window =
-      CreateChromeAppWindow(extension_misc::kCameraAppId);
-  std::unique_ptr<aura::Window> popup_window = CreatePopupWindow();
+  auto chrome_app_window = CreateChromeAppWindow(extension_misc::kCameraAppId);
+  auto popup_window = CreatePopupWindow();
 
   wm::ActivateWindow(chrome_app_window.get());
   for (int i = 0; i < 5; i++)
@@ -314,9 +262,9 @@
 
 // Verify unknown apps are categorized as "other" Chrome/ARC apps.
 TEST_F(DemoSessionMetricsRecorderTest, OtherApps) {
-  std::unique_ptr<aura::Window> chrome_app_window =
+  auto chrome_app_window =
       CreateChromeAppWindow("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa");
-  std::unique_ptr<aura::Window> arc_window = CreateArcWindow("com.foo.bar");
+  auto arc_window = CreateArcWindow("com.foo.bar");
 
   wm::ActivateWindow(chrome_app_window.get());
   FireTimer();
@@ -338,10 +286,8 @@
 
 // Verify samples are discarded after no user activity.
 TEST_F(DemoSessionMetricsRecorderTest, DiscardAfterInactivity) {
-  std::unique_ptr<aura::Window> chrome_app_window =
-      CreateChromeAppWindow(extension_misc::kCameraAppId);
-  std::unique_ptr<aura::Window> arc_window =
-      CreateChromeAppWindow("com.google.Photos");
+  auto chrome_app_window = CreateChromeAppWindow(extension_misc::kCameraAppId);
+  auto arc_window = CreateChromeAppWindow("com.google.Photos");
 
   wm::ActivateWindow(chrome_app_window.get());
   for (int i = 0; i < 5; i++)
@@ -365,8 +311,7 @@
 
 // Verify sample collection resumes after user activity.
 TEST_F(DemoSessionMetricsRecorderTest, ResumeAfterActivity) {
-  std::unique_ptr<aura::Window> chrome_app_window =
-      CreateChromeAppWindow(extension_misc::kCameraAppId);
+  auto chrome_app_window = CreateChromeAppWindow(extension_misc::kCameraAppId);
 
   wm::ActivateWindow(chrome_app_window.get());
 
@@ -389,9 +334,8 @@
 
 // Verify window activation during idle time doesn't trigger reporting.
 TEST_F(DemoSessionMetricsRecorderTest, ActivateWindowWhenIdle) {
-  std::unique_ptr<aura::Window> chrome_app_window =
-      CreateChromeAppWindow(extension_misc::kCameraAppId);
-  std::unique_ptr<aura::Window> chrome_app_window2 =
+  auto chrome_app_window = CreateChromeAppWindow(extension_misc::kCameraAppId);
+  auto chrome_app_window2 =
       CreateChromeAppWindow(extension_misc::kGoogleKeepAppId);
 
   wm::ActivateWindow(chrome_app_window.get());
@@ -409,10 +353,8 @@
 }
 
 TEST_F(DemoSessionMetricsRecorderTest, RepeatedUserActivity) {
-  std::unique_ptr<aura::Window> chrome_app_window =
-      CreateChromeAppWindow(extension_misc::kCameraAppId);
-  std::unique_ptr<aura::Window> arc_window =
-      CreateArcWindow("com.google.Photos");
+  auto chrome_app_window = CreateChromeAppWindow(extension_misc::kCameraAppId);
+  auto arc_window = CreateArcWindow("com.google.Photos");
 
   wm::ActivateWindow(chrome_app_window.get());
 
@@ -442,10 +384,9 @@
 
 // Verify remaining samples are recorded on exit.
 TEST_F(DemoSessionMetricsRecorderTest, RecordOnExit) {
-  std::unique_ptr<aura::Window> chrome_app_window =
+  auto chrome_app_window =
       CreateChromeAppWindow(extension_misc::kGoogleKeepAppId);
-  std::unique_ptr<aura::Window> arc_window =
-      CreateArcWindow("com.google.Photos");
+  auto arc_window = CreateArcWindow("com.google.Photos");
 
   wm::ActivateWindow(chrome_app_window.get());
   for (int i = 0; i < 2; i++)
@@ -468,7 +409,7 @@
 // Verify remaining samples are not recorded on exit because the user became
 // idle.
 TEST_F(DemoSessionMetricsRecorderTest, IgnoreOnIdleExit) {
-  std::unique_ptr<aura::Window> chrome_app_window =
+  auto chrome_app_window =
       CreateChromeAppWindow(extension_misc::kFilesManagerAppId);
 
   wm::ActivateWindow(chrome_app_window.get());
@@ -492,7 +433,7 @@
 // Verify remaining samples are not recorded on exit when the user was idle the
 // whole time.
 TEST_F(DemoSessionMetricsRecorderTest, IgnoreOnIdleSession) {
-  std::unique_ptr<aura::Window> chrome_app_window =
+  auto chrome_app_window =
       CreateChromeAppWindow(extension_misc::kHighlightsAppId);
 
   wm::ActivateWindow(chrome_app_window.get());
@@ -504,173 +445,5 @@
   histogram_tester_->ExpectTotalCount("DemoMode.ActiveApp", 0);
 }
 
-TEST_F(DemoSessionMetricsRecorderTest, UniqueAppsLaunchedOnDeletion) {
-  // Activate each window twice.  Despite activating each twice,
-  // the count should only be incremented once per unique app.
-  std::unique_ptr<aura::Window> chrome_app_window =
-      CreateChromeAppWindow(extension_misc::kCameraAppId);
-  wm::ActivateWindow(chrome_app_window.get());
-  wm::DeactivateWindow(chrome_app_window.get());
-  wm::ActivateWindow(chrome_app_window.get());
-
-  std::unique_ptr<aura::Window> chrome_browser_window =
-      CreateChromeAppWindow(extension_misc::kChromeAppId);
-  wm::ActivateWindow(chrome_browser_window.get());
-  wm::DeactivateWindow(chrome_browser_window.get());
-  wm::ActivateWindow(chrome_browser_window.get());
-
-  std::unique_ptr<aura::Window> arc_window_1 =
-      CreateArcWindow("com.google.Photos");
-  wm::ActivateWindow(arc_window_1.get());
-  wm::DeactivateWindow(arc_window_1.get());
-  wm::ActivateWindow(arc_window_1.get());
-
-  std::unique_ptr<aura::Window> arc_window_2 =
-      CreateArcWindow("com.google.Maps");
-  wm::ActivateWindow(arc_window_2.get());
-  wm::DeactivateWindow(arc_window_2.get());
-  wm::ActivateWindow(arc_window_2.get());
-
-  // Popup windows shouldn't be counted at all.
-  std::unique_ptr<aura::Window> popup_window = CreatePopupWindow();
-  wm::ActivateWindow(popup_window.get());
-  wm::DeactivateWindow(popup_window.get());
-  wm::ActivateWindow(popup_window.get());
-
-  DeleteMetricsRecorder();
-
-  histogram_tester_->ExpectUniqueSample("DemoMode.UniqueAppsLaunched", 4, 1);
-}
-
-TEST_F(DemoSessionMetricsRecorderTest,
-       NoUniqueAppsLaunchedOnMissingArcPackageName) {
-  // Create an ARC window with no package name set yet
-  std::unique_ptr<aura::Window> arc_window_1 = CreateArcWindow("");
-  wm::ActivateWindow(arc_window_1.get());
-
-  DeleteMetricsRecorder();
-
-  // There shuld be no unique apps reported if there was no package name.
-  histogram_tester_->ExpectUniqueSample("DemoMode.UniqueAppsLaunched", 0, 1);
-}
-
-TEST_F(DemoSessionMetricsRecorderTest,
-       UniqueAppsLaunchedOnDelayedArcPackageName) {
-  // Create an ARC window with no package name set yet.
-  std::unique_ptr<aura::Window> arc_window_1 = CreateArcWindow("");
-  wm::ActivateWindow(arc_window_1.get());
-
-  // Set the package name after window creation/activation.
-  arc_window_1->SetProperty(kArcPackageNameKey,
-                            new std::string("com.google.Photos"));
-
-  // Set the package name again. This shouldn't cause a double-recording
-  // of the stat.
-  arc_window_1->SetProperty(kArcPackageNameKey,
-                            new std::string("com.google.Photos"));
-
-  // Delete the window.
-  arc_window_1.reset();
-
-  std::unique_ptr<aura::Window> arc_window_2 =
-      CreateArcWindow("com.google.Maps");
-  wm::ActivateWindow(arc_window_2.get());
-
-  DeleteMetricsRecorder();
-
-  // There should be 2 unique apps reported.
-  histogram_tester_->ExpectUniqueSample("DemoMode.UniqueAppsLaunched", 2, 1);
-}
-
-TEST_F(DemoSessionMetricsRecorderTest, NoUniqueAppsLaunchedOnDeletion) {
-  DeleteMetricsRecorder();
-
-  // There should be no samples if the recorder is deleted with 0 unique apps
-  // launched.
-  histogram_tester_->ExpectUniqueSample("DemoMode.UniqueAppsLaunched", 0, 1);
-}
-
-TEST_F(DemoSessionMetricsRecorderTest, AppLaunched) {
-  // Activate each window twice.  Despite activating each twice,
-  // the sample should only be incremented once per unique app, except
-  // for apps for which we don't have enums, which all get recorded
-  // as "other" apps.
-
-  // Chrome browser window
-  std::unique_ptr<aura::Window> chrome_browser_window =
-      CreateChromeAppWindow(extension_misc::kChromeAppId);
-  wm::ActivateWindow(chrome_browser_window.get());
-  wm::DeactivateWindow(chrome_browser_window.get());
-  wm::ActivateWindow(chrome_browser_window.get());
-
-  // Chrome apps
-  std::unique_ptr<aura::Window> chrome_app_window_1 =
-      CreateChromeAppWindow(extension_misc::kCameraAppId);
-  wm::ActivateWindow(chrome_app_window_1.get());
-  wm::DeactivateWindow(chrome_app_window_1.get());
-  wm::ActivateWindow(chrome_app_window_1.get());
-
-  // The following 2 activations should get recorded as kOtherChromeApp
-  std::unique_ptr<aura::Window> chrome_app_window_2 =
-      CreateChromeAppWindow("otherappid2");
-  wm::ActivateWindow(chrome_app_window_2.get());
-  wm::DeactivateWindow(chrome_app_window_2.get());
-  wm::ActivateWindow(chrome_app_window_2.get());
-
-  std::unique_ptr<aura::Window> chrome_app_window_3 =
-      CreateChromeAppWindow("otherappid3");
-  wm::ActivateWindow(chrome_app_window_3.get());
-  wm::DeactivateWindow(chrome_app_window_3.get());
-  wm::ActivateWindow(chrome_app_window_3.get());
-
-  // ARC Apps
-  std::unique_ptr<aura::Window> arc_window_1 =
-      CreateArcWindow("com.google.Photos");
-  wm::ActivateWindow(arc_window_1.get());
-  wm::DeactivateWindow(arc_window_1.get());
-  wm::ActivateWindow(arc_window_1.get());
-
-  std::unique_ptr<aura::Window> arc_window_2 =
-      CreateArcWindow("com.google.Sheets");
-  wm::ActivateWindow(arc_window_2.get());
-  wm::DeactivateWindow(arc_window_2.get());
-  wm::ActivateWindow(arc_window_2.get());
-
-  // The following 2 activations should get recorded as kOtherArcApp
-  std::unique_ptr<aura::Window> arc_window_3 =
-      CreateArcWindow("com.some.other.App3");
-  wm::ActivateWindow(arc_window_3.get());
-  wm::DeactivateWindow(arc_window_3.get());
-  wm::ActivateWindow(arc_window_3.get());
-
-  std::unique_ptr<aura::Window> arc_window_4 =
-      CreateArcWindow("com.some.other.App4");
-  wm::ActivateWindow(arc_window_4.get());
-  wm::DeactivateWindow(arc_window_4.get());
-  wm::ActivateWindow(arc_window_4.get());
-
-  histogram_tester_->ExpectBucketCount(
-      "DemoMode.AppLaunched", DemoSessionMetricsRecorder::DemoModeApp::kBrowser,
-      1);
-  histogram_tester_->ExpectBucketCount(
-      "DemoMode.AppLaunched", DemoSessionMetricsRecorder::DemoModeApp::kCamera,
-      1);
-  // We should see 2 "other chrome apps"
-  histogram_tester_->ExpectBucketCount(
-      "DemoMode.AppLaunched",
-      DemoSessionMetricsRecorder::DemoModeApp::kOtherChromeApp, 2);
-
-  histogram_tester_->ExpectBucketCount(
-      "DemoMode.AppLaunched",
-      DemoSessionMetricsRecorder::DemoModeApp::kGooglePhotos, 1);
-  histogram_tester_->ExpectBucketCount(
-      "DemoMode.AppLaunched",
-      DemoSessionMetricsRecorder::DemoModeApp::kGoogleSheets, 1);
-  // We should see 2 "other arc apps"
-  histogram_tester_->ExpectBucketCount(
-      "DemoMode.AppLaunched",
-      DemoSessionMetricsRecorder::DemoModeApp::kOtherArcApp, 2);
-}
-
 }  // namespace
 }  // namespace ash
--- a/ash/metrics/login_metrics_recorder.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/metrics/login_metrics_recorder.cc	2019-05-17 18:53:08.184000000 +0300
@@ -143,10 +143,6 @@
       // Should not be called in LOCKED nor LOGIN_PRIMARY states.
       NOTREACHED();
       break;
-    case ShelfButtonClickTarget::kParentAccessButton:
-      DCHECK(is_lock);
-      LogUserClickOnLock(LockScreenUserClickTarget::kParentAccessButton);
-      break;
     case ShelfButtonClickTarget::kTargetCount:
       NOTREACHED();
       break;
--- a/ash/metrics/login_metrics_recorder.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/metrics/login_metrics_recorder.h	2019-05-17 18:53:08.188000000 +0300
@@ -28,7 +28,6 @@
     kImeTray,
     kNotificationTray,
     kLockScreenNoteActionButton,
-    kParentAccessButton,
     kTargetCount,
   };
 
@@ -66,7 +65,6 @@
     kAddUserButton,
     kCloseNoteButton,
     kCancelButton,
-    kParentAccessButton,
     kTargetCount,
   };
 
--- a/ash/metrics/pointer_metrics_recorder.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/metrics/pointer_metrics_recorder.cc	2019-05-17 18:53:08.188000000 +0300
@@ -29,38 +29,18 @@
 
 // Find the input type, form factor and destination combination of the down
 // event. Used to get the UMA histogram bucket.
-DownEventMetric FindCombinationDeprecated(DownEventSource input_type,
+DownEventMetric FindCombination(DownEventSource input_type,
                                           DownEventFormFactor form_factor,
                                           int destination) {
-  if (destination == static_cast<int>(AppType::CROSTINI_APP))
-    destination = static_cast<int>(AppType::OTHERS);
-  constexpr int kAppCountDeprecated = kAppCount - 1;
   int num_combination_per_input =
-      kAppCountDeprecated *
-      static_cast<int>(DownEventFormFactor::kFormFactorCount);
+      kAppCount * static_cast<int>(DownEventFormFactor::kFormFactorCount);
   int result = static_cast<int>(input_type) * num_combination_per_input +
-               static_cast<int>(form_factor) * kAppCountDeprecated +
-               destination;
+               static_cast<int>(form_factor) * kAppCount + destination;
   DCHECK(result >= 0 &&
          result < static_cast<int>(DownEventMetric::kCombinationCount));
   return static_cast<DownEventMetric>(result);
 }
 
-DownEventMetric2 FindCombination(int destination,
-                                 DownEventSource input_type,
-                                 DownEventFormFactor form_factor) {
-  constexpr int kNumCombinationPerDestination =
-      static_cast<int>(DownEventSource::kSourceCount) *
-      static_cast<int>(DownEventFormFactor::kFormFactorCount);
-  int result = destination * kNumCombinationPerDestination +
-               static_cast<int>(DownEventFormFactor::kFormFactorCount) *
-                   static_cast<int>(input_type) +
-               static_cast<int>(form_factor);
-  DCHECK(result >= 0 &&
-         result <= static_cast<int>(DownEventMetric2::kMaxValue));
-  return static_cast<DownEventMetric2>(result);
-}
-
 void RecordUMA(ui::EventPointerType type, ui::EventTarget* event_target) {
   DCHECK_NE(type, ui::EventPointerType::POINTER_TYPE_UNKNOWN);
   views::Widget* target = views::Widget::GetTopLevelWidgetForNativeView(
@@ -99,13 +79,8 @@
 
   UMA_HISTOGRAM_ENUMERATION(
       "Event.DownEventCount.PerInputFormFactorDestinationCombination",
-      FindCombinationDeprecated(input_type, form_factor,
-                                GetDestination(target)),
+      FindCombination(input_type, form_factor, GetDestination(target)),
       DownEventMetric::kCombinationCount);
-
-  UMA_HISTOGRAM_ENUMERATION(
-      "Event.DownEventCount.PerInputFormFactorDestinationCombination2",
-      FindCombination(GetDestination(target), input_type, form_factor));
 }
 
 }  // namespace
--- a/ash/metrics/pointer_metrics_recorder.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/metrics/pointer_metrics_recorder.h	2019-05-17 18:53:08.188000000 +0300
@@ -32,74 +32,6 @@
   kSourceCount,
 };
 
-// App type (Destination), Input and FormFactor Combination of the down event.
-// This enum is used to back an UMA histogram and new values should
-// be inserted immediately above kCombinationCount.
-enum class DownEventMetric2 {
-  // All "Unknown" types are deprecated, never occur in practice.
-  kOthersUnknownClamshell = 0,
-  kOthersUnknownTabletLandscape = 1,
-  kOthersUnknownTabletPortrait = 2,
-  kOthersMouseClamshell = 3,
-  kOthersMouseTabletLandscape = 4,
-  kOthersMouseTabletPortrait = 5,
-  kOthersStylusClamshell = 6,
-  kOthersStylusTabletLandscape = 7,
-  kOthersStylusTabletPortrait = 8,
-  kOthersTouchClamshell = 9,
-  kOthersTouchTabletLandscape = 10,
-  kOthersTouchTabletPortrait = 11,
-  kBrowserUnknownClamshell = 12,
-  kBrowserUnknownTabletLandscape = 13,
-  kBrowserUnknownTabletPortrait = 14,
-  kBrowserMouseClamshell = 15,
-  kBrowserMouseTabletLandscape = 16,
-  kBrowserMouseTabletPortrait = 17,
-  kBrowserStylusClamshell = 18,
-  kBrowserStylusTabletLandscape = 19,
-  kBrowserStylusTabletPortrait = 20,
-  kBrowserTouchClamshell = 21,
-  kBrowserTouchTabletLandscape = 22,
-  kBrowserTouchTabletPortrait = 23,
-  kChromeAppUnknownClamshell = 24,
-  kChromeAppUnknownTabletLandscape = 25,
-  kChromeAppUnknownTabletPortrait = 26,
-  kChromeAppMouseClamshell = 27,
-  kChromeAppMouseTabletLandscape = 28,
-  kChromeAppMouseTabletPortrait = 29,
-  kChromeAppStylusClamshell = 30,
-  kChromeAppStylusTabletLandscape = 31,
-  kChromeAppStylusTabletPortrait = 32,
-  kChromeAppTouchClamshell = 33,
-  kChromeAppTouchTabletLandscape = 34,
-  kChromeAppTouchTabletPortrait = 35,
-  kArcAppUnknownClamshell = 36,
-  kArcAppUnknownTabletLandscape = 37,
-  kArcAppUnknownTabletPortrait = 38,
-  kArcAppMouseClamshell = 39,
-  kArcAppMouseTabletLandscape = 40,
-  kArcAppMouseTabletPortrait = 41,
-  kArcAppStylusClamshell = 42,
-  kArcAppStylusTabletLandscape = 43,
-  kArcAppStylusTabletPortrait = 44,
-  kArcAppTouchClamshell = 45,
-  kArcAppTouchTabletLandscape = 46,
-  kArcAppTouchTabletPortrait = 47,
-  kCrostiniAppUnknownClamshell = 48,
-  kCrostiniAppUnknownTabletLandscape = 49,
-  kCrostiniAppUnknownTabletPortrait = 50,
-  kCrostiniAppMouseClamshell = 51,
-  kCrostiniAppMouseTabletLandscape = 52,
-  kCrostiniAppMouseTabletPortrait = 53,
-  kCrostiniAppStylusClamshell = 54,
-  kCrostiniAppStylusTabletLandscape = 55,
-  kCrostiniAppStylusTabletPortrait = 56,
-  kCrostiniAppTouchClamshell = 57,
-  kCrostiniAppTouchTabletLandscape = 58,
-  kCrostiniAppTouchTabletPortrait = 59,
-  kMaxValue = kCrostiniAppTouchTabletPortrait
-};
-
 // Input, FormFactor, and Destination Combination of the down event.
 // This enum is used to back an UMA histogram and new values should
 // be inserted immediately above kCombinationCount.
--- a/ash/metrics/pointer_metrics_recorder_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/metrics/pointer_metrics_recorder_unittest.cc	2019-05-17 18:53:08.188000000 +0300
@@ -20,11 +20,8 @@
 namespace ash {
 namespace {
 
-const char kCombinationDeprecatedHistogramName[] =
-    "Event.DownEventCount.PerInputFormFactorDestinationCombination";
-
 const char kCombinationHistogramName[] =
-    "Event.DownEventCount.PerInputFormFactorDestinationCombination2";
+    "Event.DownEventCount.PerInputFormFactorDestinationCombination";
 
 // Test fixture for the PointerMetricsRecorder class.
 class PointerMetricsRecorderTest : public AshTestBase {
@@ -119,7 +116,7 @@
                           base::TimeTicks(), 0, 0);
   pointer_metrics_recorder_->OnMouseEvent(&mouse_up);
 
-  histogram_tester_->ExpectTotalCount(kCombinationDeprecatedHistogramName, 0);
+  histogram_tester_->ExpectTotalCount(kCombinationHistogramName, 0);
 }
 
 // Verifies that down events from different combination of input type, form
@@ -134,518 +131,225 @@
                   DownEventFormFactor::kClamshell, AppType::OTHERS);
   histogram_tester_->ExpectBucketCount(
       kCombinationHistogramName,
-      static_cast<int>(DownEventMetric2::kOthersMouseClamshell), 1);
-
-  CreateDownEvent(ui::EventPointerType::POINTER_TYPE_MOUSE,
-                  DownEventFormFactor::kTabletModeLandscape, AppType::OTHERS);
-  histogram_tester_->ExpectBucketCount(
-      kCombinationHistogramName,
-      static_cast<int>(DownEventMetric2::kOthersMouseTabletLandscape), 1);
-
-  CreateDownEvent(ui::EventPointerType::POINTER_TYPE_MOUSE,
-                  DownEventFormFactor::kTabletModePortrait, AppType::OTHERS);
-  histogram_tester_->ExpectBucketCount(
-      kCombinationHistogramName,
-      static_cast<int>(DownEventMetric2::kOthersMouseTabletPortrait), 1);
-
-  CreateDownEvent(ui::EventPointerType::POINTER_TYPE_PEN,
-                  DownEventFormFactor::kClamshell, AppType::OTHERS);
-  histogram_tester_->ExpectBucketCount(
-      kCombinationHistogramName,
-      static_cast<int>(DownEventMetric2::kOthersStylusClamshell), 1);
-
-  CreateDownEvent(ui::EventPointerType::POINTER_TYPE_PEN,
-                  DownEventFormFactor::kTabletModeLandscape, AppType::OTHERS);
-  histogram_tester_->ExpectBucketCount(
-      kCombinationHistogramName,
-      static_cast<int>(DownEventMetric2::kOthersStylusTabletLandscape), 1);
-
-  CreateDownEvent(ui::EventPointerType::POINTER_TYPE_PEN,
-                  DownEventFormFactor::kTabletModePortrait, AppType::OTHERS);
-  histogram_tester_->ExpectBucketCount(
-      kCombinationHistogramName,
-      static_cast<int>(DownEventMetric2::kOthersStylusTabletPortrait), 1);
-
-  CreateDownEvent(ui::EventPointerType::POINTER_TYPE_TOUCH,
-                  DownEventFormFactor::kClamshell, AppType::OTHERS);
-  histogram_tester_->ExpectBucketCount(
-      kCombinationHistogramName,
-      static_cast<int>(DownEventMetric2::kOthersStylusClamshell), 1);
-
-  CreateDownEvent(ui::EventPointerType::POINTER_TYPE_TOUCH,
-                  DownEventFormFactor::kTabletModeLandscape, AppType::OTHERS);
-  histogram_tester_->ExpectBucketCount(
-      kCombinationHistogramName,
-      static_cast<int>(DownEventMetric2::kOthersStylusTabletLandscape), 1);
-
-  CreateDownEvent(ui::EventPointerType::POINTER_TYPE_TOUCH,
-                  DownEventFormFactor::kTabletModePortrait, AppType::OTHERS);
-  histogram_tester_->ExpectBucketCount(
-      kCombinationHistogramName,
-      static_cast<int>(DownEventMetric2::kOthersStylusTabletPortrait), 1);
-
-  CreateDownEvent(ui::EventPointerType::POINTER_TYPE_MOUSE,
-                  DownEventFormFactor::kClamshell, AppType::BROWSER);
-  histogram_tester_->ExpectBucketCount(
-      kCombinationHistogramName,
-      static_cast<int>(DownEventMetric2::kBrowserMouseClamshell), 1);
-
-  CreateDownEvent(ui::EventPointerType::POINTER_TYPE_MOUSE,
-                  DownEventFormFactor::kTabletModeLandscape, AppType::BROWSER);
-  histogram_tester_->ExpectBucketCount(
-      kCombinationHistogramName,
-      static_cast<int>(DownEventMetric2::kBrowserMouseTabletLandscape), 1);
-
-  CreateDownEvent(ui::EventPointerType::POINTER_TYPE_MOUSE,
-                  DownEventFormFactor::kTabletModePortrait, AppType::BROWSER);
-  histogram_tester_->ExpectBucketCount(
-      kCombinationHistogramName,
-      static_cast<int>(DownEventMetric2::kBrowserMouseTabletPortrait), 1);
-
-  CreateDownEvent(ui::EventPointerType::POINTER_TYPE_PEN,
-                  DownEventFormFactor::kClamshell, AppType::BROWSER);
-  histogram_tester_->ExpectBucketCount(
-      kCombinationHistogramName,
-      static_cast<int>(DownEventMetric2::kBrowserStylusClamshell), 1);
-
-  CreateDownEvent(ui::EventPointerType::POINTER_TYPE_PEN,
-                  DownEventFormFactor::kTabletModeLandscape, AppType::BROWSER);
-  histogram_tester_->ExpectBucketCount(
-      kCombinationHistogramName,
-      static_cast<int>(DownEventMetric2::kBrowserStylusTabletLandscape), 1);
-
-  CreateDownEvent(ui::EventPointerType::POINTER_TYPE_PEN,
-                  DownEventFormFactor::kTabletModePortrait, AppType::BROWSER);
-  histogram_tester_->ExpectBucketCount(
-      kCombinationHistogramName,
-      static_cast<int>(DownEventMetric2::kBrowserStylusTabletPortrait), 1);
-
-  CreateDownEvent(ui::EventPointerType::POINTER_TYPE_TOUCH,
-                  DownEventFormFactor::kClamshell, AppType::BROWSER);
-  histogram_tester_->ExpectBucketCount(
-      kCombinationHistogramName,
-      static_cast<int>(DownEventMetric2::kBrowserStylusClamshell), 1);
-
-  CreateDownEvent(ui::EventPointerType::POINTER_TYPE_TOUCH,
-                  DownEventFormFactor::kTabletModeLandscape, AppType::BROWSER);
-  histogram_tester_->ExpectBucketCount(
-      kCombinationHistogramName,
-      static_cast<int>(DownEventMetric2::kBrowserStylusTabletLandscape), 1);
-
-  CreateDownEvent(ui::EventPointerType::POINTER_TYPE_TOUCH,
-                  DownEventFormFactor::kTabletModePortrait, AppType::BROWSER);
-  histogram_tester_->ExpectBucketCount(
-      kCombinationHistogramName,
-      static_cast<int>(DownEventMetric2::kBrowserStylusTabletPortrait), 1);
-
-  CreateDownEvent(ui::EventPointerType::POINTER_TYPE_MOUSE,
-                  DownEventFormFactor::kClamshell, AppType::CHROME_APP);
-  histogram_tester_->ExpectBucketCount(
-      kCombinationHistogramName,
-      static_cast<int>(DownEventMetric2::kChromeAppMouseClamshell), 1);
-
-  CreateDownEvent(ui::EventPointerType::POINTER_TYPE_MOUSE,
-                  DownEventFormFactor::kTabletModeLandscape,
-                  AppType::CHROME_APP);
-  histogram_tester_->ExpectBucketCount(
-      kCombinationHistogramName,
-      static_cast<int>(DownEventMetric2::kChromeAppMouseTabletLandscape), 1);
-
-  CreateDownEvent(ui::EventPointerType::POINTER_TYPE_MOUSE,
-                  DownEventFormFactor::kTabletModePortrait,
-                  AppType::CHROME_APP);
-  histogram_tester_->ExpectBucketCount(
-      kCombinationHistogramName,
-      static_cast<int>(DownEventMetric2::kChromeAppMouseTabletPortrait), 1);
-
-  CreateDownEvent(ui::EventPointerType::POINTER_TYPE_PEN,
-                  DownEventFormFactor::kClamshell, AppType::CHROME_APP);
-  histogram_tester_->ExpectBucketCount(
-      kCombinationHistogramName,
-      static_cast<int>(DownEventMetric2::kChromeAppStylusClamshell), 1);
-
-  CreateDownEvent(ui::EventPointerType::POINTER_TYPE_PEN,
-                  DownEventFormFactor::kTabletModeLandscape,
-                  AppType::CHROME_APP);
-  histogram_tester_->ExpectBucketCount(
-      kCombinationHistogramName,
-      static_cast<int>(DownEventMetric2::kChromeAppStylusTabletLandscape), 1);
-
-  CreateDownEvent(ui::EventPointerType::POINTER_TYPE_PEN,
-                  DownEventFormFactor::kTabletModePortrait,
-                  AppType::CHROME_APP);
-  histogram_tester_->ExpectBucketCount(
-      kCombinationHistogramName,
-      static_cast<int>(DownEventMetric2::kChromeAppStylusTabletPortrait), 1);
-
-  CreateDownEvent(ui::EventPointerType::POINTER_TYPE_TOUCH,
-                  DownEventFormFactor::kClamshell, AppType::CHROME_APP);
-  histogram_tester_->ExpectBucketCount(
-      kCombinationHistogramName,
-      static_cast<int>(DownEventMetric2::kChromeAppStylusClamshell), 1);
-
-  CreateDownEvent(ui::EventPointerType::POINTER_TYPE_TOUCH,
-                  DownEventFormFactor::kTabletModeLandscape,
-                  AppType::CHROME_APP);
-  histogram_tester_->ExpectBucketCount(
-      kCombinationHistogramName,
-      static_cast<int>(DownEventMetric2::kChromeAppStylusTabletLandscape), 1);
-
-  CreateDownEvent(ui::EventPointerType::POINTER_TYPE_TOUCH,
-                  DownEventFormFactor::kTabletModePortrait,
-                  AppType::CHROME_APP);
-  histogram_tester_->ExpectBucketCount(
-      kCombinationHistogramName,
-      static_cast<int>(DownEventMetric2::kChromeAppStylusTabletPortrait), 1);
-
-  CreateDownEvent(ui::EventPointerType::POINTER_TYPE_MOUSE,
-                  DownEventFormFactor::kClamshell, AppType::ARC_APP);
-  histogram_tester_->ExpectBucketCount(
-      kCombinationHistogramName,
-      static_cast<int>(DownEventMetric2::kArcAppMouseClamshell), 1);
-
-  CreateDownEvent(ui::EventPointerType::POINTER_TYPE_MOUSE,
-                  DownEventFormFactor::kTabletModeLandscape, AppType::ARC_APP);
-  histogram_tester_->ExpectBucketCount(
-      kCombinationHistogramName,
-      static_cast<int>(DownEventMetric2::kArcAppMouseTabletLandscape), 1);
-
-  CreateDownEvent(ui::EventPointerType::POINTER_TYPE_MOUSE,
-                  DownEventFormFactor::kTabletModePortrait, AppType::ARC_APP);
-  histogram_tester_->ExpectBucketCount(
-      kCombinationHistogramName,
-      static_cast<int>(DownEventMetric2::kArcAppMouseTabletPortrait), 1);
-
-  CreateDownEvent(ui::EventPointerType::POINTER_TYPE_PEN,
-                  DownEventFormFactor::kClamshell, AppType::ARC_APP);
-  histogram_tester_->ExpectBucketCount(
-      kCombinationHistogramName,
-      static_cast<int>(DownEventMetric2::kArcAppStylusClamshell), 1);
-
-  CreateDownEvent(ui::EventPointerType::POINTER_TYPE_PEN,
-                  DownEventFormFactor::kTabletModeLandscape, AppType::ARC_APP);
-  histogram_tester_->ExpectBucketCount(
-      kCombinationHistogramName,
-      static_cast<int>(DownEventMetric2::kArcAppStylusTabletLandscape), 1);
-
-  CreateDownEvent(ui::EventPointerType::POINTER_TYPE_PEN,
-                  DownEventFormFactor::kTabletModePortrait, AppType::ARC_APP);
-  histogram_tester_->ExpectBucketCount(
-      kCombinationHistogramName,
-      static_cast<int>(DownEventMetric2::kArcAppStylusTabletPortrait), 1);
-
-  CreateDownEvent(ui::EventPointerType::POINTER_TYPE_TOUCH,
-                  DownEventFormFactor::kClamshell, AppType::ARC_APP);
-  histogram_tester_->ExpectBucketCount(
-      kCombinationHistogramName,
-      static_cast<int>(DownEventMetric2::kArcAppStylusClamshell), 1);
-
-  CreateDownEvent(ui::EventPointerType::POINTER_TYPE_TOUCH,
-                  DownEventFormFactor::kTabletModeLandscape, AppType::ARC_APP);
-  histogram_tester_->ExpectBucketCount(
-      kCombinationHistogramName,
-      static_cast<int>(DownEventMetric2::kArcAppStylusTabletLandscape), 1);
-
-  CreateDownEvent(ui::EventPointerType::POINTER_TYPE_TOUCH,
-                  DownEventFormFactor::kTabletModePortrait, AppType::ARC_APP);
-  histogram_tester_->ExpectBucketCount(
-      kCombinationHistogramName,
-      static_cast<int>(DownEventMetric2::kArcAppStylusTabletPortrait), 1);
-
-  CreateDownEvent(ui::EventPointerType::POINTER_TYPE_MOUSE,
-                  DownEventFormFactor::kClamshell, AppType::CROSTINI_APP);
-  histogram_tester_->ExpectBucketCount(
-      kCombinationHistogramName,
-      static_cast<int>(DownEventMetric2::kCrostiniAppMouseClamshell), 1);
-
-  CreateDownEvent(ui::EventPointerType::POINTER_TYPE_MOUSE,
-                  DownEventFormFactor::kTabletModeLandscape,
-                  AppType::CROSTINI_APP);
-  histogram_tester_->ExpectBucketCount(
-      kCombinationHistogramName,
-      static_cast<int>(DownEventMetric2::kCrostiniAppMouseTabletLandscape), 1);
-
-  CreateDownEvent(ui::EventPointerType::POINTER_TYPE_MOUSE,
-                  DownEventFormFactor::kTabletModePortrait,
-                  AppType::CROSTINI_APP);
-  histogram_tester_->ExpectBucketCount(
-      kCombinationHistogramName,
-      static_cast<int>(DownEventMetric2::kCrostiniAppMouseTabletPortrait), 1);
-
-  CreateDownEvent(ui::EventPointerType::POINTER_TYPE_PEN,
-                  DownEventFormFactor::kClamshell, AppType::CROSTINI_APP);
-  histogram_tester_->ExpectBucketCount(
-      kCombinationHistogramName,
-      static_cast<int>(DownEventMetric2::kCrostiniAppStylusClamshell), 1);
-
-  CreateDownEvent(ui::EventPointerType::POINTER_TYPE_PEN,
-                  DownEventFormFactor::kTabletModeLandscape,
-                  AppType::CROSTINI_APP);
-  histogram_tester_->ExpectBucketCount(
-      kCombinationHistogramName,
-      static_cast<int>(DownEventMetric2::kCrostiniAppStylusTabletLandscape), 1);
-
-  CreateDownEvent(ui::EventPointerType::POINTER_TYPE_PEN,
-                  DownEventFormFactor::kTabletModePortrait,
-                  AppType::CROSTINI_APP);
-  histogram_tester_->ExpectBucketCount(
-      kCombinationHistogramName,
-      static_cast<int>(DownEventMetric2::kCrostiniAppStylusTabletPortrait), 1);
-
-  CreateDownEvent(ui::EventPointerType::POINTER_TYPE_TOUCH,
-                  DownEventFormFactor::kClamshell, AppType::CROSTINI_APP);
-  histogram_tester_->ExpectBucketCount(
-      kCombinationHistogramName,
-      static_cast<int>(DownEventMetric2::kCrostiniAppStylusClamshell), 1);
-
-  CreateDownEvent(ui::EventPointerType::POINTER_TYPE_TOUCH,
-                  DownEventFormFactor::kTabletModeLandscape,
-                  AppType::CROSTINI_APP);
-  histogram_tester_->ExpectBucketCount(
-      kCombinationHistogramName,
-      static_cast<int>(DownEventMetric2::kCrostiniAppStylusTabletLandscape), 1);
-
-  CreateDownEvent(ui::EventPointerType::POINTER_TYPE_TOUCH,
-                  DownEventFormFactor::kTabletModePortrait,
-                  AppType::CROSTINI_APP);
-  histogram_tester_->ExpectBucketCount(
-      kCombinationHistogramName,
-      static_cast<int>(DownEventMetric2::kCrostiniAppStylusTabletPortrait), 1);
-
-  histogram_tester_->ExpectTotalCount(kCombinationHistogramName, 45);
-}
-
-// Verifies that down events from different combination of input type, form
-// factor and destination are recorded.
-TEST_F(PointerMetricsRecorderTest, DownEventPerCombinationDeprecated) {
-  int64_t display_id = display::Screen::GetScreen()->GetPrimaryDisplay().id();
-  display::DisplayManager* display_manager = Shell::Get()->display_manager();
-  display::test::ScopedSetInternalDisplayId set_internal(display_manager,
-                                                         display_id);
-
-  CreateDownEvent(ui::EventPointerType::POINTER_TYPE_MOUSE,
-                  DownEventFormFactor::kClamshell, AppType::OTHERS);
-  histogram_tester_->ExpectBucketCount(
-      kCombinationDeprecatedHistogramName,
       static_cast<int>(DownEventMetric::kMouseClamshellOthers), 1);
 
   CreateDownEvent(ui::EventPointerType::POINTER_TYPE_MOUSE,
                   DownEventFormFactor::kClamshell, AppType::BROWSER);
   histogram_tester_->ExpectBucketCount(
-      kCombinationDeprecatedHistogramName,
+      kCombinationHistogramName,
       static_cast<int>(DownEventMetric::kMouseClamshellBrowser), 1);
 
   CreateDownEvent(ui::EventPointerType::POINTER_TYPE_MOUSE,
                   DownEventFormFactor::kClamshell, AppType::CHROME_APP);
   histogram_tester_->ExpectBucketCount(
-      kCombinationDeprecatedHistogramName,
+      kCombinationHistogramName,
       static_cast<int>(DownEventMetric::kMouseClamshellChromeApp), 1);
 
   CreateDownEvent(ui::EventPointerType::POINTER_TYPE_MOUSE,
                   DownEventFormFactor::kClamshell, AppType::ARC_APP);
   histogram_tester_->ExpectBucketCount(
-      kCombinationDeprecatedHistogramName,
+      kCombinationHistogramName,
       static_cast<int>(DownEventMetric::kMouseClamshellArcApp), 1);
 
   CreateDownEvent(ui::EventPointerType::POINTER_TYPE_MOUSE,
                   DownEventFormFactor::kTabletModeLandscape, AppType::OTHERS);
   histogram_tester_->ExpectBucketCount(
-      kCombinationDeprecatedHistogramName,
+      kCombinationHistogramName,
       static_cast<int>(DownEventMetric::kMouseTabletLandscapeOthers), 1);
 
   CreateDownEvent(ui::EventPointerType::POINTER_TYPE_MOUSE,
                   DownEventFormFactor::kTabletModeLandscape, AppType::BROWSER);
   histogram_tester_->ExpectBucketCount(
-      kCombinationDeprecatedHistogramName,
+      kCombinationHistogramName,
       static_cast<int>(DownEventMetric::kMouseTabletLandscapeBrowser), 1);
 
   CreateDownEvent(ui::EventPointerType::POINTER_TYPE_MOUSE,
                   DownEventFormFactor::kTabletModeLandscape,
                   AppType::CHROME_APP);
   histogram_tester_->ExpectBucketCount(
-      kCombinationDeprecatedHistogramName,
+      kCombinationHistogramName,
       static_cast<int>(DownEventMetric::kMouseTabletLandscapeChromeApp), 1);
 
   CreateDownEvent(ui::EventPointerType::POINTER_TYPE_MOUSE,
                   DownEventFormFactor::kTabletModeLandscape, AppType::ARC_APP);
   histogram_tester_->ExpectBucketCount(
-      kCombinationDeprecatedHistogramName,
+      kCombinationHistogramName,
       static_cast<int>(DownEventMetric::kMouseTabletLandscapeArcApp), 1);
 
   CreateDownEvent(ui::EventPointerType::POINTER_TYPE_MOUSE,
                   DownEventFormFactor::kTabletModePortrait, AppType::OTHERS);
   histogram_tester_->ExpectBucketCount(
-      kCombinationDeprecatedHistogramName,
+      kCombinationHistogramName,
       static_cast<int>(DownEventMetric::kMouseTabletPortraitOthers), 1);
 
   CreateDownEvent(ui::EventPointerType::POINTER_TYPE_MOUSE,
                   DownEventFormFactor::kTabletModePortrait, AppType::BROWSER);
   histogram_tester_->ExpectBucketCount(
-      kCombinationDeprecatedHistogramName,
+      kCombinationHistogramName,
       static_cast<int>(DownEventMetric::kMouseTabletPortraitBrowser), 1);
 
   CreateDownEvent(ui::EventPointerType::POINTER_TYPE_MOUSE,
                   DownEventFormFactor::kTabletModePortrait,
                   AppType::CHROME_APP);
   histogram_tester_->ExpectBucketCount(
-      kCombinationDeprecatedHistogramName,
+      kCombinationHistogramName,
       static_cast<int>(DownEventMetric::kMouseTabletPortraitChromeApp), 1);
 
   CreateDownEvent(ui::EventPointerType::POINTER_TYPE_MOUSE,
                   DownEventFormFactor::kTabletModePortrait, AppType::ARC_APP);
   histogram_tester_->ExpectBucketCount(
-      kCombinationDeprecatedHistogramName,
+      kCombinationHistogramName,
       static_cast<int>(DownEventMetric::kMouseTabletPortraitArcApp), 1);
 
   CreateDownEvent(ui::EventPointerType::POINTER_TYPE_PEN,
                   DownEventFormFactor::kClamshell, AppType::OTHERS);
   histogram_tester_->ExpectBucketCount(
-      kCombinationDeprecatedHistogramName,
+      kCombinationHistogramName,
       static_cast<int>(DownEventMetric::kStylusClamshellOthers), 1);
 
   CreateDownEvent(ui::EventPointerType::POINTER_TYPE_PEN,
                   DownEventFormFactor::kClamshell, AppType::BROWSER);
   histogram_tester_->ExpectBucketCount(
-      kCombinationDeprecatedHistogramName,
+      kCombinationHistogramName,
       static_cast<int>(DownEventMetric::kStylusClamshellBrowser), 1);
 
   CreateDownEvent(ui::EventPointerType::POINTER_TYPE_PEN,
                   DownEventFormFactor::kClamshell, AppType::CHROME_APP);
   histogram_tester_->ExpectBucketCount(
-      kCombinationDeprecatedHistogramName,
+      kCombinationHistogramName,
       static_cast<int>(DownEventMetric::kStylusClamshellChromeApp), 1);
 
   CreateDownEvent(ui::EventPointerType::POINTER_TYPE_PEN,
                   DownEventFormFactor::kClamshell, AppType::ARC_APP);
   histogram_tester_->ExpectBucketCount(
-      kCombinationDeprecatedHistogramName,
+      kCombinationHistogramName,
       static_cast<int>(DownEventMetric::kStylusClamshellArcApp), 1);
 
   CreateDownEvent(ui::EventPointerType::POINTER_TYPE_PEN,
                   DownEventFormFactor::kTabletModeLandscape, AppType::OTHERS);
   histogram_tester_->ExpectBucketCount(
-      kCombinationDeprecatedHistogramName,
+      kCombinationHistogramName,
       static_cast<int>(DownEventMetric::kStylusTabletLandscapeOthers), 1);
 
   CreateDownEvent(ui::EventPointerType::POINTER_TYPE_PEN,
                   DownEventFormFactor::kTabletModeLandscape, AppType::BROWSER);
   histogram_tester_->ExpectBucketCount(
-      kCombinationDeprecatedHistogramName,
+      kCombinationHistogramName,
       static_cast<int>(DownEventMetric::kStylusTabletLandscapeBrowser), 1);
 
   CreateDownEvent(ui::EventPointerType::POINTER_TYPE_PEN,
                   DownEventFormFactor::kTabletModeLandscape,
                   AppType::CHROME_APP);
   histogram_tester_->ExpectBucketCount(
-      kCombinationDeprecatedHistogramName,
+      kCombinationHistogramName,
       static_cast<int>(DownEventMetric::kStylusTabletLandscapeChromeApp), 1);
 
   CreateDownEvent(ui::EventPointerType::POINTER_TYPE_PEN,
                   DownEventFormFactor::kTabletModeLandscape, AppType::ARC_APP);
   histogram_tester_->ExpectBucketCount(
-      kCombinationDeprecatedHistogramName,
+      kCombinationHistogramName,
       static_cast<int>(DownEventMetric::kStylusTabletLandscapeArcApp), 1);
 
   CreateDownEvent(ui::EventPointerType::POINTER_TYPE_PEN,
                   DownEventFormFactor::kTabletModePortrait, AppType::OTHERS);
   histogram_tester_->ExpectBucketCount(
-      kCombinationDeprecatedHistogramName,
+      kCombinationHistogramName,
       static_cast<int>(DownEventMetric::kStylusTabletPortraitOthers), 1);
 
   CreateDownEvent(ui::EventPointerType::POINTER_TYPE_PEN,
                   DownEventFormFactor::kTabletModePortrait, AppType::BROWSER);
   histogram_tester_->ExpectBucketCount(
-      kCombinationDeprecatedHistogramName,
+      kCombinationHistogramName,
       static_cast<int>(DownEventMetric::kStylusTabletPortraitBrowser), 1);
 
   CreateDownEvent(ui::EventPointerType::POINTER_TYPE_PEN,
                   DownEventFormFactor::kTabletModePortrait,
                   AppType::CHROME_APP);
   histogram_tester_->ExpectBucketCount(
-      kCombinationDeprecatedHistogramName,
+      kCombinationHistogramName,
       static_cast<int>(DownEventMetric::kStylusTabletPortraitChromeApp), 1);
 
   CreateDownEvent(ui::EventPointerType::POINTER_TYPE_PEN,
                   DownEventFormFactor::kTabletModePortrait, AppType::ARC_APP);
   histogram_tester_->ExpectBucketCount(
-      kCombinationDeprecatedHistogramName,
+      kCombinationHistogramName,
       static_cast<int>(DownEventMetric::kStylusTabletPortraitArcApp), 1);
 
   CreateDownEvent(ui::EventPointerType::POINTER_TYPE_TOUCH,
                   DownEventFormFactor::kClamshell, AppType::OTHERS);
   histogram_tester_->ExpectBucketCount(
-      kCombinationDeprecatedHistogramName,
+      kCombinationHistogramName,
       static_cast<int>(DownEventMetric::kStylusClamshellOthers), 1);
 
   CreateDownEvent(ui::EventPointerType::POINTER_TYPE_TOUCH,
                   DownEventFormFactor::kClamshell, AppType::BROWSER);
   histogram_tester_->ExpectBucketCount(
-      kCombinationDeprecatedHistogramName,
+      kCombinationHistogramName,
       static_cast<int>(DownEventMetric::kStylusClamshellBrowser), 1);
 
   CreateDownEvent(ui::EventPointerType::POINTER_TYPE_TOUCH,
                   DownEventFormFactor::kClamshell, AppType::CHROME_APP);
   histogram_tester_->ExpectBucketCount(
-      kCombinationDeprecatedHistogramName,
+      kCombinationHistogramName,
       static_cast<int>(DownEventMetric::kStylusClamshellChromeApp), 1);
 
   CreateDownEvent(ui::EventPointerType::POINTER_TYPE_TOUCH,
                   DownEventFormFactor::kClamshell, AppType::ARC_APP);
   histogram_tester_->ExpectBucketCount(
-      kCombinationDeprecatedHistogramName,
+      kCombinationHistogramName,
       static_cast<int>(DownEventMetric::kStylusClamshellArcApp), 1);
 
   CreateDownEvent(ui::EventPointerType::POINTER_TYPE_TOUCH,
                   DownEventFormFactor::kTabletModeLandscape, AppType::OTHERS);
   histogram_tester_->ExpectBucketCount(
-      kCombinationDeprecatedHistogramName,
+      kCombinationHistogramName,
       static_cast<int>(DownEventMetric::kStylusTabletLandscapeOthers), 1);
 
   CreateDownEvent(ui::EventPointerType::POINTER_TYPE_TOUCH,
                   DownEventFormFactor::kTabletModeLandscape, AppType::BROWSER);
   histogram_tester_->ExpectBucketCount(
-      kCombinationDeprecatedHistogramName,
+      kCombinationHistogramName,
       static_cast<int>(DownEventMetric::kStylusTabletLandscapeBrowser), 1);
 
   CreateDownEvent(ui::EventPointerType::POINTER_TYPE_TOUCH,
                   DownEventFormFactor::kTabletModeLandscape,
                   AppType::CHROME_APP);
   histogram_tester_->ExpectBucketCount(
-      kCombinationDeprecatedHistogramName,
+      kCombinationHistogramName,
       static_cast<int>(DownEventMetric::kStylusTabletLandscapeChromeApp), 1);
 
   CreateDownEvent(ui::EventPointerType::POINTER_TYPE_TOUCH,
                   DownEventFormFactor::kTabletModeLandscape, AppType::ARC_APP);
   histogram_tester_->ExpectBucketCount(
-      kCombinationDeprecatedHistogramName,
+      kCombinationHistogramName,
       static_cast<int>(DownEventMetric::kStylusTabletLandscapeArcApp), 1);
 
   CreateDownEvent(ui::EventPointerType::POINTER_TYPE_TOUCH,
                   DownEventFormFactor::kTabletModePortrait, AppType::OTHERS);
   histogram_tester_->ExpectBucketCount(
-      kCombinationDeprecatedHistogramName,
+      kCombinationHistogramName,
       static_cast<int>(DownEventMetric::kStylusTabletPortraitOthers), 1);
 
   CreateDownEvent(ui::EventPointerType::POINTER_TYPE_TOUCH,
                   DownEventFormFactor::kTabletModePortrait, AppType::BROWSER);
   histogram_tester_->ExpectBucketCount(
-      kCombinationDeprecatedHistogramName,
+      kCombinationHistogramName,
       static_cast<int>(DownEventMetric::kStylusTabletPortraitBrowser), 1);
 
   CreateDownEvent(ui::EventPointerType::POINTER_TYPE_TOUCH,
                   DownEventFormFactor::kTabletModePortrait,
                   AppType::CHROME_APP);
   histogram_tester_->ExpectBucketCount(
-      kCombinationDeprecatedHistogramName,
+      kCombinationHistogramName,
       static_cast<int>(DownEventMetric::kStylusTabletPortraitChromeApp), 1);
 
   CreateDownEvent(ui::EventPointerType::POINTER_TYPE_TOUCH,
                   DownEventFormFactor::kTabletModePortrait, AppType::ARC_APP);
   histogram_tester_->ExpectBucketCount(
-      kCombinationDeprecatedHistogramName,
+      kCombinationHistogramName,
       static_cast<int>(DownEventMetric::kStylusTabletPortraitArcApp), 1);
 
-  histogram_tester_->ExpectTotalCount(kCombinationDeprecatedHistogramName, 36);
+  histogram_tester_->ExpectTotalCount(kCombinationHistogramName, 36);
 }
 
 }  // namespace ash
--- a/ash/metrics/user_metrics_recorder.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/metrics/user_metrics_recorder.cc	2019-05-17 18:53:08.188000000 +0300
@@ -39,7 +39,6 @@
   ACTIVE_WINDOW_STATE_TYPE_SNAPPED,
   ACTIVE_WINDOW_STATE_TYPE_PINNED,
   ACTIVE_WINDOW_STATE_TYPE_TRUSTED_PINNED,
-  ACTIVE_WINDOW_STATE_TYPE_PIP,
   ACTIVE_WINDOW_STATE_TYPE_COUNT,
 };
 
@@ -65,14 +64,13 @@
       case mojom::WindowStateType::TRUSTED_PINNED:
         active_window_state_type = ACTIVE_WINDOW_STATE_TYPE_TRUSTED_PINNED;
         break;
-      case mojom::WindowStateType::PIP:
-        active_window_state_type = ACTIVE_WINDOW_STATE_TYPE_PIP;
-        break;
       case mojom::WindowStateType::DEFAULT:
       case mojom::WindowStateType::NORMAL:
       case mojom::WindowStateType::MINIMIZED:
       case mojom::WindowStateType::INACTIVE:
       case mojom::WindowStateType::AUTO_POSITIONED:
+      case mojom::WindowStateType::PIP:
+        // TODO: We probably want to record PIP state.
         active_window_state_type = ACTIVE_WINDOW_STATE_TYPE_OTHER;
         break;
     }
@@ -103,8 +101,7 @@
 // UMA statistics. Note the containers are ordered from top most visible
 // container to the lowest to allow the |GetNumVisibleWindows| method to short
 // circuit when processing a maximized or fullscreen window.
-int kVisibleWindowContainerIds[] = {kShellWindowId_PipContainer,
-                                    kShellWindowId_AlwaysOnTopContainer,
+int kVisibleWindowContainerIds[] = {kShellWindowId_AlwaysOnTopContainer,
                                     kShellWindowId_DefaultContainer};
 
 // Returns an approximate count of how many windows are currently visible in the
--- a/ash/mojo_interface_factory.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/mojo_interface_factory.cc	2019-05-17 18:53:08.188000000 +0300
@@ -16,7 +16,7 @@
 #include "ash/assistant/assistant_screen_context_controller.h"
 #include "ash/assistant/assistant_setup_controller.h"
 #include "ash/cast_config_controller.h"
-#include "ash/custom_tab/arc_custom_tab_controller.h"
+#include "ash/contained_shell/contained_shell_controller.h"
 #include "ash/display/ash_display_controller.h"
 #include "ash/display/cros_display_config.h"
 #include "ash/display/display_output_protection.h"
@@ -25,7 +25,6 @@
 #include "ash/highlighter/highlighter_controller.h"
 #include "ash/ime/ime_controller.h"
 #include "ash/keyboard/ash_keyboard_controller.h"
-#include "ash/kiosk_next/kiosk_next_shell_controller.h"
 #include "ash/login/login_screen_controller.h"
 #include "ash/magnifier/docked_magnifier_controller.h"
 #include "ash/media/media_controller.h"
@@ -83,11 +82,6 @@
   Shell::Get()->app_list_controller()->BindRequest(std::move(request));
 }
 
-void BindArcCustomTabControllerRequestOnMainThread(
-    mojom::ArcCustomTabControllerRequest request) {
-  Shell::Get()->arc_custom_tab_controller()->BindRequest(std::move(request));
-}
-
 void BindAshDisplayControllerRequestOnMainThread(
     mojom::AshDisplayControllerRequest request) {
   Shell::Get()->ash_display_controller()->BindRequest(std::move(request));
@@ -143,6 +137,11 @@
   Shell::Get()->cast_config()->BindRequest(std::move(request));
 }
 
+void BindContainedShellControllerRequestOnMainThread(
+    mojom::ContainedShellControllerRequest request) {
+  Shell::Get()->contained_shell_controller()->BindRequest(std::move(request));
+}
+
 void BindDisplayOutputProtectionRequestOnMainThread(
     mojom::DisplayOutputProtectionRequest request) {
   Shell::Get()->display_output_protection()->BindRequest(std::move(request));
@@ -177,11 +176,6 @@
   Shell::Get()->ash_keyboard_controller()->BindRequest(std::move(request));
 }
 
-void BindKioskNextShellControllerRequestOnMainThread(
-    mojom::KioskNextShellControllerRequest request) {
-  Shell::Get()->kiosk_next_shell_controller()->BindRequest(std::move(request));
-}
-
 void BindLocaleUpdateControllerOnMainThread(
     mojom::LocaleUpdateControllerRequest request) {
   Shell::Get()->locale_update_controller()->BindRequest(std::move(request));
@@ -280,9 +274,6 @@
   registry->AddInterface(
       base::BindRepeating(&BindAppListControllerRequestOnMainThread),
       main_thread_task_runner);
-  registry->AddInterface(
-      base::BindRepeating(&BindArcCustomTabControllerRequestOnMainThread),
-      main_thread_task_runner);
   if (chromeos::switches::IsAssistantEnabled()) {
     registry->AddInterface(
         base::BindRepeating(
@@ -317,17 +308,19 @@
       main_thread_task_runner);
   registry->AddInterface(base::BindRepeating(&BindCastConfigOnMainThread),
                          main_thread_task_runner);
-  if (base::FeatureList::IsEnabled(features::kKioskNextShell)) {
+  if (base::FeatureList::IsEnabled(features::kContainedShell)) {
     registry->AddInterface(
-        base::BindRepeating(&BindKioskNextShellControllerRequestOnMainThread),
+        base::BindRepeating(&BindContainedShellControllerRequestOnMainThread),
         main_thread_task_runner);
   }
   registry->AddInterface(
       base::BindRepeating(&BindDisplayOutputProtectionRequestOnMainThread),
       main_thread_task_runner);
+  if (features::IsDockedMagnifierEnabled()) {
   registry->AddInterface(
       base::BindRepeating(&BindDockedMagnifierControllerRequestOnMainThread),
       main_thread_task_runner);
+  }
   registry->AddInterface(
       base::BindRepeating(&BindEventRewriterControllerRequestOnMainThread),
       main_thread_task_runner);
@@ -355,9 +348,11 @@
   registry->AddInterface(
       base::BindRepeating(&BindNewWindowControllerRequestOnMainThread),
       main_thread_task_runner);
+  if (features::IsNightLightEnabled()) {
     registry->AddInterface(
         base::BindRepeating(&BindNightLightControllerRequestOnMainThread),
         main_thread_task_runner);
+  }
   registry->AddInterface(
       base::BindRepeating(&BindNoteTakingControllerRequestOnMainThread),
       main_thread_task_runner);
--- a/ash/multi_device_setup/multi_device_notification_presenter_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/multi_device_setup/multi_device_notification_presenter_unittest.cc	2019-05-17 18:53:08.188000000 +0300
@@ -12,7 +12,6 @@
 #include "ash/strings/grit/ash_strings.h"
 #include "ash/test/ash_test_base.h"
 #include "ash/test/ash_test_helper.h"
-#include "base/bind.h"
 #include "base/logging.h"
 #include "base/memory/ptr_util.h"
 #include "base/strings/utf_string_conversions.h"
--- a/ash/multi_user/multi_user_window_manager.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/multi_user/multi_user_window_manager.cc	2019-05-17 18:53:08.188000000 +0300
@@ -184,11 +184,6 @@
 
   if (GetWindowOwner(window) == account_id)
     return;
-
-  // Transient window ownership is tracked by the parent window's ownership.
-  if (GetOwningWindowInTransientChain(window))
-    return;
-
   DCHECK(GetWindowOwner(window).empty());
   std::unique_ptr<WindowEntry> window_entry_ptr =
       std::make_unique<WindowEntry>(account_id, std::move(window_id));
@@ -366,9 +361,8 @@
   // Remove the transient child if the window itself is owned, or one of the
   // windows in its transient parents chain.
   if (!GetWindowOwner(window).empty() ||
-      GetOwningWindowInTransientChain(window)) {
+      GetOwningWindowInTransientChain(window))
     RemoveTransientOwnerRecursive(transient_window);
-  }
 }
 
 void MultiUserWindowManager::OnTabletModeStarted() {
--- a/ash/multi_user/user_switch_animator.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/multi_user/user_switch_animator.cc	2019-05-17 18:53:08.188000000 +0300
@@ -9,7 +9,6 @@
 #include "ash/wallpaper/wallpaper_controller.h"
 #include "ash/wm/mru_window_tracker.h"
 #include "ash/wm/window_positioner.h"
-#include "base/bind.h"
 #include "ui/aura/client/aura_constants.h"
 #include "ui/compositor/layer_animation_observer.h"
 #include "ui/compositor/layer_tree_owner.h"
--- a/ash/mus_property_mirror_ash_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/mus_property_mirror_ash_unittest.cc	2019-05-17 18:53:08.188000000 +0300
@@ -59,6 +59,18 @@
             *window_2->GetProperty(aura::client::kTitleKey));
   EXPECT_NE(window_1->GetProperty(aura::client::kTitleKey),
             window_2->GetProperty(aura::client::kTitleKey));
+
+  window_1->ClearProperty(aura::client::kWindowIconKey);
+  EXPECT_EQ(nullptr, window_1->GetProperty(aura::client::kWindowIconKey));
+  window_2->ClearProperty(aura::client::kWindowIconKey);
+  EXPECT_EQ(nullptr, window_2->GetProperty(aura::client::kWindowIconKey));
+  window_1->SetProperty(aura::client::kWindowIconKey, new gfx::ImageSkia());
+  EXPECT_NE(nullptr, window_1->GetProperty(aura::client::kWindowIconKey));
+  mus_property_mirror_ash.MirrorPropertyFromWidgetWindowToRootWindow(
+      window_1.get(), window_2.get(), aura::client::kWindowIconKey);
+  EXPECT_NE(nullptr, window_2->GetProperty(aura::client::kWindowIconKey));
+  EXPECT_NE(window_1->GetProperty(aura::client::kWindowIconKey),
+            window_2->GetProperty(aura::client::kWindowIconKey));
 }
 
 }  // namespace ash
--- a/ash/note_taking_controller.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/note_taking_controller.cc	2019-05-17 18:53:08.192000000 +0300
@@ -3,7 +3,6 @@
 // found in the LICENSE file.
 
 #include "ash/note_taking_controller.h"
-#include "base/bind.h"
 
 namespace ash {
 
--- a/ash/OWNERS	2019-05-01 01:22:25.000000000 +0300
+++ b/ash/OWNERS	2019-05-17 18:53:08.060000000 +0300
@@ -13,4 +13,10 @@
 # Translation artifacts:
 per-file *.xtb=file://tools/translation/TRANSLATION_OWNERS
 
+per-file manifest.json=set noparent
+per-file manifest.json=file://ipc/SECURITY_OWNERS
+
+per-file ash_unittests_manifest.json=set noparent
+per-file ash_unittests_manifest.json=file://ipc/SECURITY_OWNERS
+
 # COMPONENT: UI>Shell
--- a/ash/perftests/ash_background_filter_blur_perftest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/perftests/ash_background_filter_blur_perftest.cc	2019-05-17 18:53:08.192000000 +0300
@@ -6,7 +6,7 @@
 
 #include "ash/shell.h"
 #include "ash/test/ash_test_base.h"
-#include "base/timer/lap_timer.h"
+#include "cc/base/lap_timer.h"
 #include "testing/perf/perf_test.h"
 #include "ui/aura/window.h"
 #include "ui/compositor/test/draw_waiter_for_test.h"
@@ -45,7 +45,7 @@
 
   ui::Compositor* compositor_ = nullptr;
 
-  base::LapTimer timer_;
+  cc::LapTimer timer_;
 
   DISALLOW_COPY_AND_ASSIGN(AshBackgroundFilterBlurPerfTest);
 };
--- a/ash/PRESUBMIT.py	2019-05-17 17:45:36.476000000 +0300
+++ b/ash/PRESUBMIT.py	2019-05-17 18:53:08.060000000 +0300
@@ -4,7 +4,7 @@
 
 """Presubmit script for ash (Chrome OS system UI).
 
-See http://dev.ch40m1um.qjz9zk/developers/how-tos/depottools/presubmit-scripts
+See http://dev.chromium.org/developers/how-tos/depottools/presubmit-scripts
 for more details about the presubmit API built into depot_tools.
 """
 
--- a/ash/public/cpp/accelerators.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/public/cpp/accelerators.cc	2019-05-17 18:53:08.192000000 +0300
@@ -16,8 +16,6 @@
      CYCLE_BACKWARD_MRU},
     {true, ui::VKEY_MEDIA_LAUNCH_APP1, ui::EF_NONE, TOGGLE_OVERVIEW},
     {true, ui::VKEY_BROWSER_SEARCH, ui::EF_NONE, TOGGLE_APP_LIST},
-    {true, ui::VKEY_BROWSER_SEARCH, ui::EF_SHIFT_DOWN,
-     TOGGLE_APP_LIST_FULLSCREEN},
     {true, ui::VKEY_WLAN, ui::EF_NONE, TOGGLE_WIFI},
     {true, ui::VKEY_KBD_BRIGHTNESS_DOWN, ui::EF_NONE, KEYBOARD_BRIGHTNESS_DOWN},
     {true, ui::VKEY_KBD_BRIGHTNESS_UP, ui::EF_NONE, KEYBOARD_BRIGHTNESS_UP},
@@ -108,7 +106,6 @@
     // act on release instead of press when using Search as a modifier key for
     // extended keyboard shortcuts.
     {false, ui::VKEY_LWIN, ui::EF_NONE, TOGGLE_APP_LIST},
-    {false, ui::VKEY_LWIN, ui::EF_SHIFT_DOWN, TOGGLE_APP_LIST_FULLSCREEN},
     {true, ui::VKEY_MEDIA_LAUNCH_APP2, ui::EF_NONE, TOGGLE_FULLSCREEN},
     {true, ui::VKEY_MEDIA_LAUNCH_APP2, ui::EF_SHIFT_DOWN, TOGGLE_FULLSCREEN},
     {true, ui::VKEY_ESCAPE, ui::EF_SHIFT_DOWN | ui::EF_COMMAND_DOWN, UNPIN},
--- a/ash/public/cpp/accelerators.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/public/cpp/accelerators.h	2019-05-17 18:53:08.192000000 +0300
@@ -20,6 +20,20 @@
   BRIGHTNESS_UP,
   CYCLE_BACKWARD_MRU,
   CYCLE_FORWARD_MRU,
+  DEBUG_PRINT_LAYER_HIERARCHY,
+  DEBUG_PRINT_VIEW_HIERARCHY,
+  DEBUG_PRINT_WINDOW_HIERARCHY,
+  DEBUG_SHOW_QUICK_LAUNCH,
+  DEBUG_SHOW_TOAST,
+  DEBUG_TOGGLE_DEVICE_SCALE_FACTOR,
+  DEBUG_TOGGLE_SHOW_DEBUG_BORDERS,
+  DEBUG_TOGGLE_SHOW_FPS_COUNTER,
+  DEBUG_TOGGLE_SHOW_PAINT_RECTS,
+  DEBUG_TOGGLE_TOUCH_PAD,
+  DEBUG_TOGGLE_TOUCH_SCREEN,
+  DEBUG_TOGGLE_TABLET_MODE,
+  DEBUG_TOGGLE_WALLPAPER_MODE,
+  DEBUG_TRIGGER_CRASH,  // Intentionally crash the ash process.
   DEV_ADD_REMOVE_DISPLAY,
   DEV_TOGGLE_UNIFIED_DESKTOP,
   DISABLE_CAPS_LOCK,
@@ -80,7 +94,6 @@
   TAKE_SCREENSHOT,
   TAKE_WINDOW_SCREENSHOT,
   TOGGLE_APP_LIST,
-  TOGGLE_APP_LIST_FULLSCREEN,
   TOGGLE_CAPS_LOCK,
   TOGGLE_DICTATION,
   TOGGLE_DOCKED_MAGNIFIER,
@@ -104,22 +117,6 @@
   WINDOW_CYCLE_SNAP_RIGHT,
   WINDOW_MINIMIZE,
   WINDOW_POSITION_CENTER,
-
-  // Debug accelerators are intentionally at the end, so that if you remove one
-  // you don't need to update tests which check hashes of the ids.
-  DEBUG_PRINT_LAYER_HIERARCHY,
-  DEBUG_PRINT_VIEW_HIERARCHY,
-  DEBUG_PRINT_WINDOW_HIERARCHY,
-  DEBUG_SHOW_TOAST,
-  DEBUG_TOGGLE_DEVICE_SCALE_FACTOR,
-  DEBUG_TOGGLE_SHOW_DEBUG_BORDERS,
-  DEBUG_TOGGLE_SHOW_FPS_COUNTER,
-  DEBUG_TOGGLE_SHOW_PAINT_RECTS,
-  DEBUG_TOGGLE_TOUCH_PAD,
-  DEBUG_TOGGLE_TOUCH_SCREEN,
-  DEBUG_TOGGLE_TABLET_MODE,
-  DEBUG_TOGGLE_WALLPAPER_MODE,
-  DEBUG_TRIGGER_CRASH,  // Intentionally crash the ash process.
 };
 
 struct AcceleratorData {
--- a/ash/public/cpp/app_list/app_list_config.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/public/cpp/app_list/app_list_config.cc	2019-05-17 18:53:08.192000000 +0300
@@ -12,8 +12,8 @@
 namespace app_list {
 
 AppListConfig::AppListConfig()
-    : grid_tile_width_(112),
-      grid_tile_height_(120),
+    : grid_tile_width_(120),
+      grid_tile_height_(112),
       grid_tile_spacing_(0),
       grid_icon_dimension_(64),
       grid_icon_bottom_padding_(24),
@@ -27,7 +27,6 @@
       search_tile_badge_icon_dimension_(22),
       search_tile_badge_icon_offset_(5),
       search_list_icon_dimension_(20),
-      search_list_icon_vertical_bar_dimension_(48),
       search_list_badge_icon_dimension_(14),
       suggestion_chip_icon_dimension_(16),
       app_title_max_line_height_(20),
@@ -58,23 +57,7 @@
       // TODO(manucornet): Share the value with ShelfConstants and use
       // 48 when the new shelf UI is turned off.
       shelf_height_(56),
-      blur_radius_(30),
-      contents_background_color_(SkColorSetRGB(0xF2, 0xF2, 0xF2)),
-      grid_selected_color_(SkColorSetARGB(0x1F, 0xFF, 0xFF, 0xFF)),
-      card_background_color_(SK_ColorWHITE),
-      page_transition_duration_ms_(250),
-      overscroll_page_transition_duration_ms_(50),
-      folder_transition_in_duration_ms_(250),
-      folder_transition_out_duration_ms_(30),
-      num_start_page_tiles_(5),
-      max_search_results_(6),
-      max_folder_pages_(3),
-      max_folder_items_per_page_(16),
-      max_folder_name_chars_(28),
-      all_apps_opacity_start_px_(8.0f),
-      all_apps_opacity_end_px_(144.0f),
-      search_result_title_font_style_(ui::ResourceBundle::BaseFont),
-      search_tile_height_(92) {}
+      blur_radius_(30) {}
 
 AppListConfig::~AppListConfig() = default;
 
--- a/ash/public/cpp/app_list/app_list_config.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/public/cpp/app_list/app_list_config.h	2019-05-17 18:53:08.192000000 +0300
@@ -46,9 +46,6 @@
     return search_tile_badge_icon_offset_;
   }
   int search_list_icon_dimension() const { return search_list_icon_dimension_; }
-  int search_list_icon_vertical_bar_dimension() const {
-    return search_list_icon_vertical_bar_dimension_;
-  }
   int search_list_badge_icon_dimension() const {
     return search_list_badge_icon_dimension_;
   }
@@ -77,12 +74,12 @@
   int folder_unclipped_icon_dimension() const {
     return folder_unclipped_icon_dimension_;
   }
-  int folder_icon_radius() const { return folder_icon_radius_; }
-  int folder_background_radius() const { return folder_background_radius_; }
-  int folder_bubble_color() const { return folder_bubble_color_; }
   int item_icon_in_folder_icon_dimension() const {
     return item_icon_in_folder_icon_dimension_;
   }
+  int folder_icon_radius() const { return folder_icon_radius_; }
+  int folder_background_radius() const { return folder_background_radius_; }
+  int folder_bubble_color() const { return folder_bubble_color_; }
   int folder_dropping_circle_radius() const {
     return folder_dropping_circle_radius_;
   }
@@ -94,36 +91,6 @@
   }
   int shelf_height() const { return shelf_height_; }
   int blur_radius() const { return blur_radius_; }
-  SkColor contents_background_color() const {
-    return contents_background_color_;
-  }
-  SkColor grid_selected_color() const { return grid_selected_color_; }
-  SkColor card_background_color() const { return card_background_color_; }
-  int page_transition_duration_ms() const {
-    return page_transition_duration_ms_;
-  }
-  int overscroll_page_transition_duration_ms() const {
-    return overscroll_page_transition_duration_ms_;
-  }
-  int folder_transition_in_duration_ms() const {
-    return folder_transition_in_duration_ms_;
-  }
-  int folder_transition_out_duration_ms() const {
-    return folder_transition_out_duration_ms_;
-  }
-  size_t num_start_page_tiles() const { return num_start_page_tiles_; }
-  size_t max_search_results() const { return max_search_results_; }
-  size_t max_folder_pages() const { return max_folder_pages_; }
-  size_t max_folder_items_per_page() const {
-    return max_folder_items_per_page_;
-  }
-  size_t max_folder_name_chars() const { return max_folder_name_chars_; }
-  float all_apps_opacity_start_px() const { return all_apps_opacity_start_px_; }
-  float all_apps_opacity_end_px() const { return all_apps_opacity_end_px_; }
-  ui::ResourceBundle::FontStyle search_result_title_font_style() const {
-    return search_result_title_font_style_;
-  }
-  int search_tile_height() const { return search_tile_height_; }
 
   gfx::Size grid_icon_size() const {
     return gfx::Size(grid_icon_dimension_, grid_icon_dimension_);
@@ -214,9 +181,6 @@
   // The icon dimension of list views in search result page view.
   const int search_list_icon_dimension_;
 
-  // The vertical bar icon dimension of list views in search result page view.
-  const int search_list_icon_vertical_bar_dimension_;
-
   // The badge background corner radius of list views in search result page
   // view.
   const int search_list_badge_icon_dimension_;
@@ -296,60 +260,7 @@
   const int shelf_height_;
 
   // The blur radius used in the app list.
-  const int blur_radius_;
-
-  // The background color of app list overlay.
-  const SkColor contents_background_color_;
-
-  // The keyboard select color for grid views, which are on top of a black
-  // shield view for new design (12% white).
-  const SkColor grid_selected_color_;
-
-  // The background color for views in search results page.
-  const SkColor card_background_color_;
-
-  // Duration in milliseconds for page transition.
-  const int page_transition_duration_ms_;
-
-  // Duration in milliseconds for over scroll page transition.
-  const int overscroll_page_transition_duration_ms_;
-
-  // Duration in milliseconds for fading in the target page when opening
-  // or closing a folder, and the duration for the top folder icon animation
-  // for flying in or out the folder.
-  const int folder_transition_in_duration_ms_;
-
-  // Duration in milliseconds for fading out the old page when opening or
-  // closing a folder.
-  const int folder_transition_out_duration_ms_;
-
-  // The number of apps shown in the start page app grid.
-  const size_t num_start_page_tiles_;
-
-  // Maximum number of results to show in the launcher Search UI.
-  const size_t max_search_results_;
-
-  // Max pages allowed in a folder.
-  const size_t max_folder_pages_;
-
-  // Max items per page allowed in a folder.
-  const size_t max_folder_items_per_page_;
-
-  // Maximum length of the folder name in chars.
-  const size_t max_folder_name_chars_;
-
-  // Range of the height of centerline above screen bottom that all apps should
-  // change opacity. NOTE: this is used to change page switcher's opacity as
-  // well.
-  const float all_apps_opacity_start_px_ = 8.0f;
-  const float all_apps_opacity_end_px_ = 144.0f;
-
-  // Font style for AppListSearchResultTileItemViews that are not suggested
-  // apps.
-  const ui::ResourceBundle::FontStyle search_result_title_font_style_;
-
-  // The height of tiles in search result.
-  const int search_tile_height_ = 90;
+  const int blur_radius_ = 30;
 };
 
 }  // namespace app_list
--- a/ash/public/cpp/app_list/app_list_features.cc	2019-05-17 17:45:36.500000000 +0300
+++ b/ash/public/cpp/app_list/app_list_features.cc	2019-05-17 18:53:08.192000000 +0300
@@ -7,7 +7,6 @@
 #include "ash/public/cpp/app_list/app_list_switches.h"
 #include "base/feature_list.h"
 #include "base/metrics/field_trial_params.h"
-#include "chromeos/constants/chromeos_switches.h"
 
 namespace app_list_features {
 
@@ -21,28 +20,22 @@
     "EnablePlayStoreAppSearch", base::FEATURE_DISABLED_BY_DEFAULT};
 const base::Feature kEnableAppDataSearch{"EnableAppDataSearch",
                                          base::FEATURE_DISABLED_BY_DEFAULT};
+const base::Feature kEnableHomeLauncherGestures{
+    "HomeLauncherGestures", base::FEATURE_ENABLED_BY_DEFAULT};
 const base::Feature kEnableSettingsShortcutSearch{
     "EnableSettingsShortcutSearch", base::FEATURE_DISABLED_BY_DEFAULT};
+const base::Feature kEnableAppsGridGapFeature{"EnableAppsGridGapFeature",
+                                              base::FEATURE_ENABLED_BY_DEFAULT};
 const base::Feature kEnableZeroStateSuggestions{
-    "EnableZeroStateSuggestions", base::FEATURE_ENABLED_BY_DEFAULT};
+    "EnableZeroStateSuggestions", base::FEATURE_DISABLED_BY_DEFAULT};
 const base::Feature kEnableAppListSearchAutocomplete{
     "EnableAppListSearchAutocomplete", base::FEATURE_ENABLED_BY_DEFAULT};
-const base::Feature kEnableAdaptiveResultRanker{
-    "EnableAdaptiveResultRanker", base::FEATURE_DISABLED_BY_DEFAULT};
 const base::Feature kEnableAppSearchResultRanker{
     "EnableAppSearchResultRanker", base::FEATURE_ENABLED_BY_DEFAULT};
-const base::Feature kEnableAppReinstallZeroState{
-    "EnableAppReinstallZeroState", base::FEATURE_DISABLED_BY_DEFAULT};
-const base::Feature kEnableEmbeddedAssistantUI{
-    "EnableEmbeddedAssistantUI", base::FEATURE_DISABLED_BY_DEFAULT};
-const base::Feature kEnableAppGridGhost{"EnableAppGridGhost",
-                                        base::FEATURE_DISABLED_BY_DEFAULT};
 
 bool IsAnswerCardEnabled() {
   // Not using local static variable to allow tests to change this value.
-  // Do not show answer card if the embedded Assistant UI is enabled.
-  return base::FeatureList::IsEnabled(kEnableAnswerCard) &&
-         !IsEmbeddedAssistantUIEnabled();
+  return base::FeatureList::IsEnabled(kEnableAnswerCard);
 }
 
 bool IsAppShortcutSearchEnabled() {
@@ -62,10 +55,18 @@
   return base::FeatureList::IsEnabled(kEnableAppDataSearch);
 }
 
+bool IsHomeLauncherGesturesEnabled() {
+  return base::FeatureList::IsEnabled(kEnableHomeLauncherGestures);
+}
+
 bool IsSettingsShortcutSearchEnabled() {
   return base::FeatureList::IsEnabled(kEnableSettingsShortcutSearch);
 }
 
+bool IsAppsGridGapFeatureEnabled() {
+  return base::FeatureList::IsEnabled(kEnableAppsGridGapFeature);
+}
+
 bool IsZeroStateSuggestionsEnabled() {
   return base::FeatureList::IsEnabled(kEnableZeroStateSuggestions);
 }
@@ -74,33 +75,16 @@
   return base::FeatureList::IsEnabled(kEnableAppListSearchAutocomplete);
 }
 
-bool IsAdaptiveResultRankerEnabled() {
-  return base::FeatureList::IsEnabled(kEnableAdaptiveResultRanker);
-}
-
 bool IsAppSearchResultRankerEnabled() {
   return base::FeatureList::IsEnabled(kEnableAppSearchResultRanker);
 }
 
-bool IsAppReinstallZeroStateEnabled() {
-  return base::FeatureList::IsEnabled(kEnableAppReinstallZeroState);
-}
-
-bool IsEmbeddedAssistantUIEnabled() {
-  return chromeos::switches::IsAssistantEnabled() &&
-         base::FeatureList::IsEnabled(kEnableEmbeddedAssistantUI);
-}
-
-bool IsAppGridGhostEnabled() {
-  return base::FeatureList::IsEnabled(kEnableAppGridGhost);
-}
-
 std::string AnswerServerUrl() {
   const std::string experiment_url =
       base::GetFieldTrialParamValueByFeature(kEnableAnswerCard, "ServerUrl");
   if (!experiment_url.empty())
     return experiment_url;
-  return "https://www.9oo91e.qjz9zk/coac";
+  return "https://www.google.com/coac";
 }
 
 std::string AnswerServerQuerySuffix() {
--- a/ash/public/cpp/app_list/app_list_features.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/public/cpp/app_list/app_list_features.h	2019-05-17 18:53:08.192000000 +0300
@@ -35,44 +35,36 @@
 // Enables in-app data search.
 ASH_PUBLIC_EXPORT extern const base::Feature kEnableAppDataSearch;
 
+// Enables using gestures to show or hide the home launcher.
+// TODO(crbug.com/872319): Remove this after the feature is launched.
+ASH_PUBLIC_EXPORT extern const base::Feature kEnableHomeLauncherGestures;
+
 // Enables the Settings shortcut search.
 ASH_PUBLIC_EXPORT extern const base::Feature kEnableSettingsShortcutSearch;
 
+// Enables the apps grid gap feature.
+ASH_PUBLIC_EXPORT extern const base::Feature kEnableAppsGridGapFeature;
+
 // Enables the feature to display zero state suggestions.
 ASH_PUBLIC_EXPORT extern const base::Feature kEnableZeroStateSuggestions;
 
 // Enables the feature to autocomplete text typed in the AppList search box.
 ASH_PUBLIC_EXPORT extern const base::Feature kEnableAppListSearchAutocomplete;
 
-// Enable an adaptive model that tweaks search result scores.
-ASH_PUBLIC_EXPORT extern const base::Feature kEnableAdaptiveResultRanker;
-
 // Enables the feature to rank app search result using AppSearchResultRanker.
 ASH_PUBLIC_EXPORT extern const base::Feature kEnableAppSearchResultRanker;
 
-// Enables the feature to include a single reinstallation candidate in
-// zero-state.
-ASH_PUBLIC_EXPORT extern const base::Feature kEnableAppReinstallZeroState;
-
-// Enables the embedded Assistant UI in the app list.
-ASH_PUBLIC_EXPORT extern const base::Feature kEnableEmbeddedAssistantUI;
-
-// Enables ghosting in any AppsGridView (folder or root) when dragging an item.
-ASH_PUBLIC_EXPORT extern const base::Feature kEnableAppGridGhost;
-
 bool ASH_PUBLIC_EXPORT IsAnswerCardEnabled();
 bool ASH_PUBLIC_EXPORT IsAppShortcutSearchEnabled();
 bool ASH_PUBLIC_EXPORT IsBackgroundBlurEnabled();
 bool ASH_PUBLIC_EXPORT IsPlayStoreAppSearchEnabled();
 bool ASH_PUBLIC_EXPORT IsAppDataSearchEnabled();
+bool ASH_PUBLIC_EXPORT IsHomeLauncherGesturesEnabled();
 bool ASH_PUBLIC_EXPORT IsSettingsShortcutSearchEnabled();
+bool ASH_PUBLIC_EXPORT IsAppsGridGapFeatureEnabled();
 bool ASH_PUBLIC_EXPORT IsZeroStateSuggestionsEnabled();
 bool ASH_PUBLIC_EXPORT IsAppListSearchAutocompleteEnabled();
-bool ASH_PUBLIC_EXPORT IsAdaptiveResultRankerEnabled();
 bool ASH_PUBLIC_EXPORT IsAppSearchResultRankerEnabled();
-bool ASH_PUBLIC_EXPORT IsAppReinstallZeroStateEnabled();
-bool ASH_PUBLIC_EXPORT IsEmbeddedAssistantUIEnabled();
-bool ASH_PUBLIC_EXPORT IsAppGridGhostEnabled();
 
 std::string ASH_PUBLIC_EXPORT AnswerServerUrl();
 std::string ASH_PUBLIC_EXPORT AnswerServerQuerySuffix();
--- a/ash/public/cpp/app_list/app_list_struct_traits.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/public/cpp/app_list/app_list_struct_traits.h	2019-05-17 18:53:08.192000000 +0300
@@ -27,8 +27,7 @@
         return ash::mojom::AppListState::kStateSearchResults;
       case ash::AppListState::kStateStart:
         return ash::mojom::AppListState::kStateStart;
-      case ash::AppListState::kStateEmbeddedAssistant:
-        return ash::mojom::AppListState::kStateEmbeddedAssistant;
+      case ash::AppListState::kStateCustomLauncherPageDeprecated:
       case ash::AppListState::kInvalidState:
         break;
     }
@@ -48,9 +47,6 @@
       case ash::mojom::AppListState::kStateStart:
         *out = ash::AppListState::kStateStart;
         return true;
-      case ash::mojom::AppListState::kStateEmbeddedAssistant:
-        *out = ash::AppListState::kStateEmbeddedAssistant;
-        return true;
     }
     NOTREACHED();
     return false;
@@ -113,10 +109,6 @@
         return ash::mojom::SearchResultType::kLauncher;
       case ash::SearchResultType::kAnswerCard:
         return ash::mojom::SearchResultType::kAnswerCard;
-      case ash::SearchResultType::kPlayStoreReinstallApp:
-        return ash::mojom::SearchResultType::kPlayStoreReinstallApp;
-      case ash::SearchResultType::kArcAppShortcut:
-        return ash::mojom::SearchResultType::kArcAppShortcut;
       case ash::SearchResultType::kUnknown:
         break;
     }
@@ -154,12 +146,6 @@
       case ash::mojom::SearchResultType::kAnswerCard:
         *out = ash::SearchResultType::kAnswerCard;
         return true;
-      case ash::mojom::SearchResultType::kPlayStoreReinstallApp:
-        *out = ash::SearchResultType::kPlayStoreReinstallApp;
-        return true;
-      case ash::mojom::SearchResultType::kArcAppShortcut:
-        *out = ash::SearchResultType::kArcAppShortcut;
-        return true;
     }
     NOTREACHED();
     return false;
--- a/ash/public/cpp/app_list/app_list_switches.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/public/cpp/app_list/app_list_switches.cc	2019-05-17 18:53:08.192000000 +0300
@@ -21,6 +21,12 @@
 // If set, the app list will be enabled as if enabled from CWS.
 const char kEnableAppList[] = "enable-app-list";
 
+// Enable/disable drive search in chrome launcher.
+const char kEnableDriveSearchInChromeLauncher[] =
+    "enable-drive-search-in-app-launcher";
+const char kDisableDriveSearchInChromeLauncher[] =
+    "disable-drive-search-in-app-launcher";
+
 // If set, the app list will forget it has been installed on startup. Note this
 // doesn't prevent the app list from running, it just makes Chrome think the app
 // list hasn't been enabled (as in kEnableAppList) yet.
@@ -31,5 +37,17 @@
       kDisableAppListDismissOnBlur);
 }
 
+bool IsDriveSearchInChromeLauncherEnabled() {
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch(
+          kEnableDriveSearchInChromeLauncher))
+    return true;
+
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch(
+          kDisableDriveSearchInChromeLauncher))
+    return false;
+
+  return true;
+}
+
 }  // namespace switches
 }  // namespace app_list
--- a/ash/public/cpp/app_list/app_list_switches.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/public/cpp/app_list/app_list_switches.h	2019-05-17 18:53:08.192000000 +0300
@@ -26,6 +26,8 @@
 // Determines whether the app list should not be dismissed on focus loss.
 bool ASH_PUBLIC_EXPORT ShouldNotDismissOnBlur();
 
+bool ASH_PUBLIC_EXPORT IsDriveSearchInChromeLauncherEnabled();
+
 }  // namespace switches
 }  // namespace app_list
 
--- a/ash/public/cpp/app_list/app_list_types.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/public/cpp/app_list/app_list_types.h	2019-05-17 18:53:08.192000000 +0300
@@ -13,13 +13,6 @@
 
 namespace ash {
 
-// The initial value of |profile_id_| in AppListControllerImpl.
-constexpr int kAppListInvalidProfileID = -1;
-
-// The value from which the unique profile id starts. Notice that this profile
-// id is only used for mojo callings between AppListController and AppListClient
-constexpr int kAppListProfileIdStartFrom = 0;
-
 // Id of OEM folder in app list.
 ASH_PUBLIC_EXPORT extern const char kOemFolderId[];
 
@@ -29,7 +22,7 @@
   kStateApps = 0,
   kStateSearchResults,
   kStateStart,
-  kStateEmbeddedAssistant,
+  kStateCustomLauncherPageDeprecated,  // Don't use over IPC
   // Add new values here.
 
   kInvalidState,               // Don't use over IPC
@@ -54,8 +47,6 @@
   kOmnibox,         // Results from Omnibox.
   kLauncher,        // Results from launcher search (currently only from Files).
   kAnswerCard,      // WebContents based answer card.
-  kPlayStoreReinstallApp,  // Reinstall recommendations from PlayStore.
-  kArcAppShortcut,         // ARC++ app shortcuts.
   // Add new values here.
 };
 
--- a/ash/public/cpp/app_list/vector_icons/BUILD.gn	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/public/cpp/app_list/vector_icons/BUILD.gn	2019-05-17 18:53:08.192000000 +0300
@@ -23,10 +23,6 @@
     "search_engine_not_google.icon",
     "search_result_append.icon",
     "search_result_remove.icon",
-    "vertical_bar_end.icon",
-    "vertical_bar_middle.icon",
-    "vertical_bar_single.icon",
-    "vertical_bar_start.icon",
   ]
 }
 
--- a/ash/public/cpp/app_types.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/public/cpp/app_types.h	2019-05-17 18:53:08.196000000 +0300
@@ -16,8 +16,7 @@
   BROWSER,
   CHROME_APP,
   ARC_APP,
-  CROSTINI_APP,
-  APP_TYPE_LAST = CROSTINI_APP,
+  APP_TYPE_LAST = ARC_APP,
 };
 
 const int kAppCount = static_cast<int>(AppType::APP_TYPE_LAST) + 1;
--- a/ash/public/cpp/ash_features.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/public/cpp/ash_features.cc	2019-05-17 18:53:08.196000000 +0300
@@ -16,9 +16,6 @@
 const base::Feature kDragTabsInTabletMode{"DragTabsInTabletMode",
                                           base::FEATURE_ENABLED_BY_DEFAULT};
 
-const base::Feature kEnableOverviewRoundedCorners{
-    "EnableOverviewRoundedCorners", base::FEATURE_ENABLED_BY_DEFAULT};
-
 const base::Feature kLockScreenNotifications{"LockScreenNotifications",
                                              base::FEATURE_DISABLED_BY_DEFAULT};
 
@@ -52,22 +49,20 @@
 const base::Feature kUnlockWithExternalBinary{
     "UnlockWithExternalBinary", base::FEATURE_DISABLED_BY_DEFAULT};
 
-const base::Feature kKioskNextShell{"KioskNextShell",
+const base::Feature kContainedShell{"ContainedShell",
                                     base::FEATURE_DISABLED_BY_DEFAULT};
 
 const base::Feature kViewsLogin{"ViewsLogin", base::FEATURE_ENABLED_BY_DEFAULT};
 
-const base::Feature kVirtualDesks{"VirtualDesks",
-                                  base::FEATURE_DISABLED_BY_DEFAULT};
-
 const base::Feature kUseBluetoothSystemInAsh{"UseBluetoothSystemInAsh",
                                              base::FEATURE_DISABLED_BY_DEFAULT};
 
 const base::Feature kSupervisedUserDeprecationNotice{
     "SupervisedUserDeprecationNotice", base::FEATURE_ENABLED_BY_DEFAULT};
 
-const base::Feature kNotificationStackingBarRedesign{
-    "NotificationStackingBarRedesign", base::FEATURE_DISABLED_BY_DEFAULT};
+bool IsDockedMagnifierEnabled() {
+  return base::FeatureList::IsEnabled(kDockedMagnifier);
+}
 
 bool IsLockScreenNotificationsEnabled() {
   return base::FeatureList::IsEnabled(kLockScreenNotifications);
@@ -82,6 +77,10 @@
       kLockScreenHideSensitiveNotificationsSupport);
 }
 
+bool IsNightLightEnabled() {
+  return base::FeatureList::IsEnabled(kNightLight);
+}
+
 bool IsNotificationExpansionAnimationEnabled() {
   return base::FeatureList::IsEnabled(kNotificationExpansionAnimation);
 }
@@ -104,10 +103,6 @@
   return use_trilinear_filtering;
 }
 
-bool IsVirtualDesksEnabled() {
-  return base::FeatureList::IsEnabled(kVirtualDesks);
-}
-
 bool IsViewsLoginEnabled() {
   // Always show webui login if --show-webui-login is present, which is passed
   // by session manager for automatic recovery. Otherwise, only show views
@@ -121,9 +116,5 @@
   return base::FeatureList::IsEnabled(kSupervisedUserDeprecationNotice);
 }
 
-bool IsNotificationStackingBarRedesignEnabled() {
-  return base::FeatureList::IsEnabled(kNotificationStackingBarRedesign);
-}
-
 }  // namespace features
 }  // namespace ash
--- a/ash/public/cpp/ash_features.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/public/cpp/ash_features.h	2019-05-17 18:53:08.196000000 +0300
@@ -21,11 +21,6 @@
 // https://crbug.com/823769.
 ASH_PUBLIC_EXPORT extern const base::Feature kDragTabsInTabletMode;
 
-// Enables rounded corners in overview mode for testing.
-// TODO(crbug.com/903486): Remove this when new rounded corners implementation
-// has landed.
-ASH_PUBLIC_EXPORT extern const base::Feature kEnableOverviewRoundedCorners;
-
 // Enables notifications on the lock screen.
 ASH_PUBLIC_EXPORT extern const base::Feature kLockScreenNotifications;
 
@@ -65,23 +60,19 @@
 // Enables running an external binary which provides lock screen authentication.
 ASH_PUBLIC_EXPORT extern const base::Feature kUnlockWithExternalBinary;
 
-// Enables the KioskNextShell feature.
-ASH_PUBLIC_EXPORT extern const base::Feature kKioskNextShell;
+// Enables the ContainedShell feature.
+ASH_PUBLIC_EXPORT extern const base::Feature kContainedShell;
 
 // Enables views login.
 ASH_PUBLIC_EXPORT extern const base::Feature kViewsLogin;
 
-// Enables the Virtual Desks feature.
-ASH_PUBLIC_EXPORT extern const base::Feature kVirtualDesks;
-
 // Enables using the BluetoothSystem Mojo interface for Bluetooth operations.
 ASH_PUBLIC_EXPORT extern const base::Feature kUseBluetoothSystemInAsh;
 
 // Enables the Supervised User Deprecation notices.
 ASH_PUBLIC_EXPORT extern const base::Feature kSupervisedUserDeprecationNotice;
 
-// Enables the notification stacking bar redesigned UI.
-ASH_PUBLIC_EXPORT extern const base::Feature kNotificationStackingBarRedesign;
+ASH_PUBLIC_EXPORT bool IsDockedMagnifierEnabled();
 
 ASH_PUBLIC_EXPORT bool IsKeyboardShortcutViewerAppEnabled();
 
@@ -91,6 +82,8 @@
 
 ASH_PUBLIC_EXPORT bool IsLockScreenHideSensitiveNotificationsSupported();
 
+ASH_PUBLIC_EXPORT bool IsNightLightEnabled();
+
 ASH_PUBLIC_EXPORT bool IsNotificationExpansionAnimationEnabled();
 
 ASH_PUBLIC_EXPORT bool IsNotificationScrollBarEnabled();
@@ -103,12 +96,8 @@
 
 ASH_PUBLIC_EXPORT bool IsViewsLoginEnabled();
 
-ASH_PUBLIC_EXPORT bool IsVirtualDesksEnabled();
-
 ASH_PUBLIC_EXPORT bool IsSupervisedUserDeprecationNoticeEnabled();
 
-ASH_PUBLIC_EXPORT bool IsNotificationStackingBarRedesignEnabled();
-
 }  // namespace features
 }  // namespace ash
 
--- a/ash/public/cpp/ash_pref_names.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/public/cpp/ash_pref_names.cc	2019-05-17 18:53:08.196000000 +0300
@@ -81,10 +81,6 @@
 // regardless of the state of a11y features.
 const char kShouldAlwaysShowAccessibilityMenu[] = "settings.a11y.enable_menu";
 
-// A boolean pref that stores whether the Kiosk Next Shell is enabled. When it
-// is, we start it after sign in.
-const char kKioskNextShellEnabled[] = "ash.kiosk_next_shell.enabled";
-
 // A boolean pref storing the enabled status of the Docked Magnifier feature.
 const char kDockedMagnifierEnabled[] = "ash.docked_magnifier.enabled";
 // A double pref storing the scale value of the Docked Magnifier feature by
@@ -187,12 +183,6 @@
 const char kNightLightCustomStartTime[] = "ash.night_light.custom_start_time";
 const char kNightLightCustomEndTime[] = "ash.night_light.custom_end_time";
 
-// Double prefs storing the most recent valid geoposition, which is only used
-// when the device lacks connectivity and we're unable to retrieve a valid
-// geoposition to calculate the sunset / sunrise times.
-const char kNightLightCachedLatitude[] = "ash.night_light.cached_latitude";
-const char kNightLightCachedLongitude[] = "ash.night_light.cached_longitude";
-
 // Whether the Chrome OS lock screen is allowed.
 const char kAllowScreenLock[] = "allow_screen_lock";
 
@@ -344,9 +334,6 @@
 const char kAssistantNumWarmerWelcomeTriggered[] =
     "ash.assistant.num_warmer_welcome_triggered";
 
-// Whether the user is allowed to disconnect and configure VPN connections.
-const char kVpnConfigAllowed[] = "vpn_config_allowed";
-
 // NOTE: New prefs should start with the "ash." prefix. Existing prefs moved
 // into this file should not be renamed, since they may be synced.
 
--- a/ash/public/cpp/ash_pref_names.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/public/cpp/ash_pref_names.h	2019-05-17 18:53:08.196000000 +0300
@@ -34,8 +34,6 @@
 ASH_PUBLIC_EXPORT extern const char kAccessibilityDictationEnabled[];
 ASH_PUBLIC_EXPORT extern const char kShouldAlwaysShowAccessibilityMenu[];
 
-ASH_PUBLIC_EXPORT extern const char kKioskNextShellEnabled[];
-
 ASH_PUBLIC_EXPORT extern const char kDockedMagnifierEnabled[];
 ASH_PUBLIC_EXPORT extern const char kDockedMagnifierScale[];
 ASH_PUBLIC_EXPORT extern const char
@@ -74,8 +72,6 @@
 ASH_PUBLIC_EXPORT extern const char kNightLightScheduleType[];
 ASH_PUBLIC_EXPORT extern const char kNightLightCustomStartTime[];
 ASH_PUBLIC_EXPORT extern const char kNightLightCustomEndTime[];
-ASH_PUBLIC_EXPORT extern const char kNightLightCachedLatitude[];
-ASH_PUBLIC_EXPORT extern const char kNightLightCachedLongitude[];
 
 ASH_PUBLIC_EXPORT extern const char kAllowScreenLock[];
 ASH_PUBLIC_EXPORT extern const char kEnableAutoScreenLock[];
@@ -134,8 +130,6 @@
 
 ASH_PUBLIC_EXPORT extern const char kAssistantNumWarmerWelcomeTriggered[];
 
-ASH_PUBLIC_EXPORT extern const char kVpnConfigAllowed[];
-
 }  // namespace prefs
 
 }  // namespace ash
--- a/ash/public/cpp/ash_public_export.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/public/cpp/ash_public_export.h	2019-05-17 18:53:08.196000000 +0300
@@ -7,12 +7,24 @@
 
 #if defined(COMPONENT_BUILD)
 
+#if defined(WIN32)
+
+#if defined(ASH_PUBLIC_IMPLEMENTATION)
+#define ASH_PUBLIC_EXPORT __declspec(dllexport)
+#else
+#define ASH_PUBLIC_EXPORT __declspec(dllimport)
+#endif
+
+#else  // !defined(WIN32)
+
 #if defined(ASH_PUBLIC_IMPLEMENTATION)
 #define ASH_PUBLIC_EXPORT __attribute((visibility("default")))
 #else
 #define ASH_PUBLIC_EXPORT
 #endif
 
+#endif  // defined(WIN32)
+
 #else  // !defined(COMPONENT_BUILD)
 
 #define ASH_PUBLIC_EXPORT
--- a/ash/public/cpp/assistant/assistant_state_base.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/public/cpp/assistant/assistant_state_base.h	2019-05-17 18:53:08.196000000 +0300
@@ -31,8 +31,8 @@
     return settings_enabled_;
   }
 
-  const base::Optional<mojom::ConsentStatus>& consent_status() const {
-    return consent_status_;
+  const base::Optional<bool>& setup_completed() const {
+    return setup_completed_;
   }
 
   const base::Optional<bool>& context_enabled() const {
@@ -59,8 +59,8 @@
   // Whether voice interaction is enabled in system settings.
   base::Optional<bool> settings_enabled_;
 
-  // The status of the user's consent.
-  base::Optional<mojom::ConsentStatus> consent_status_;
+  // Whether voice interaction setup flow has completed.
+  base::Optional<bool> setup_completed_;
 
   // Whether screen context is enabled.
   base::Optional<bool> context_enabled_;
--- a/ash/public/cpp/assistant/assistant_state_proxy.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/public/cpp/assistant/assistant_state_proxy.cc	2019-05-17 18:53:08.196000000 +0300
@@ -35,8 +35,8 @@
     observer->OnVoiceInteractionContextEnabled(context_enabled_.value());
   if (hotword_enabled_.has_value())
     observer->OnVoiceInteractionHotwordEnabled(hotword_enabled_.value());
-  if (consent_status_.has_value())
-    observer->OnVoiceInteractionConsentStatusUpdated(consent_status_.value());
+  if (setup_completed_.has_value())
+    observer->OnVoiceInteractionSetupCompleted(setup_completed_.value());
   if (hotword_always_on_.has_value())
     observer->OnVoiceInteractionHotwordAlwaysOn(hotword_always_on_.value());
   if (allowed_state_.has_value())
@@ -77,11 +77,10 @@
     observer.OnVoiceInteractionHotwordEnabled(hotword_enabled_.value());
 }
 
-void AssistantStateProxy::OnVoiceInteractionConsentStatusUpdated(
-    mojom::ConsentStatus consent_status) {
-  consent_status_ = consent_status;
+void AssistantStateProxy::OnVoiceInteractionSetupCompleted(bool completed) {
+  setup_completed_ = completed;
   for (auto& observer : observers_)
-    observer.OnVoiceInteractionConsentStatusUpdated(consent_status_.value());
+    observer.OnVoiceInteractionSetupCompleted(setup_completed_.value());
 }
 
 void AssistantStateProxy::OnVoiceInteractionHotwordAlwaysOn(bool always_on) {
--- a/ash/public/cpp/assistant/assistant_state_proxy.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/public/cpp/assistant/assistant_state_proxy.h	2019-05-17 18:53:08.196000000 +0300
@@ -40,21 +40,20 @@
  private:
   // mojom::VoiceInteractionObserver:
   void OnVoiceInteractionStatusChanged(
-      mojom::VoiceInteractionState state) override;
+      ash::mojom::VoiceInteractionState state) override;
   void OnVoiceInteractionSettingsEnabled(bool enabled) override;
   void OnVoiceInteractionContextEnabled(bool enabled) override;
   void OnVoiceInteractionHotwordEnabled(bool enabled) override;
-  void OnVoiceInteractionConsentStatusUpdated(
-      mojom::ConsentStatus consent_status) override;
+  void OnVoiceInteractionSetupCompleted(bool completed) override;
   void OnVoiceInteractionHotwordAlwaysOn(bool always_on) override;
   void OnAssistantFeatureAllowedChanged(
-      mojom::AssistantAllowedState state) override;
+      ash::mojom::AssistantAllowedState state) override;
   void OnLocaleChanged(const std::string& locale) override;
 
   base::ObserverList<DefaultVoiceInteractionObserver> observers_;
 
-  mojom::VoiceInteractionControllerPtr voice_interaction_controller_;
-  mojo::Binding<mojom::VoiceInteractionObserver>
+  ash::mojom::VoiceInteractionControllerPtr voice_interaction_controller_;
+  mojo::Binding<ash::mojom::VoiceInteractionObserver>
       voice_interaction_observer_binding_;
 
   DISALLOW_COPY_AND_ASSIGN(AssistantStateProxy);
--- a/ash/public/cpp/assistant/default_voice_interaction_observer.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/public/cpp/assistant/default_voice_interaction_observer.h	2019-05-17 18:53:08.196000000 +0300
@@ -28,8 +28,7 @@
   void OnVoiceInteractionSettingsEnabled(bool enabled) override {}
   void OnVoiceInteractionContextEnabled(bool enabled) override {}
   void OnVoiceInteractionHotwordEnabled(bool enabled) override {}
-  void OnVoiceInteractionConsentStatusUpdated(
-      ash::mojom::ConsentStatus consent_status) override {}
+  void OnVoiceInteractionSetupCompleted(bool completed) override {}
   void OnVoiceInteractionHotwordAlwaysOn(bool always_on) override {}
   void OnAssistantFeatureAllowedChanged(
       ash::mojom::AssistantAllowedState state) override {}
--- a/ash/public/cpp/BUILD.gn	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/public/cpp/BUILD.gn	2019-05-17 18:53:08.192000000 +0300
@@ -11,10 +11,10 @@
     "accelerators.h",
     "app_list/app_list_config.cc",
     "app_list/app_list_config.h",
+    "app_list/app_list_constants.cc",
+    "app_list/app_list_constants.h",
     "app_list/app_list_features.cc",
     "app_list/app_list_features.h",
-    "app_list/app_list_metrics.cc",
-    "app_list/app_list_metrics.h",
     "app_list/app_list_switches.cc",
     "app_list/app_list_switches.h",
     "app_list/app_list_types.cc",
@@ -61,8 +61,6 @@
     "default_frame_header.h",
     "default_scale_factor_retriever.cc",
     "default_scale_factor_retriever.h",
-    "fps_counter.cc",
-    "fps_counter.h",
     "frame_header.cc",
     "frame_header.h",
     "frame_utils.cc",
@@ -89,8 +87,6 @@
     "notification_utils.h",
     "power_utils.cc",
     "power_utils.h",
-    "presentation_time_recorder.cc",
-    "presentation_time_recorder.h",
     "remote_shelf_item_delegate.cc",
     "remote_shelf_item_delegate.h",
     "rounded_corner_decorator.cc",
@@ -132,7 +128,6 @@
 
   deps = [
     "//ash/public/cpp/vector_icons",
-    "//chromeos/constants",
     "//chromeos/dbus:power_manager_proto",
     "//components/prefs",
     "//mojo/public/cpp/bindings",
@@ -165,45 +160,6 @@
   output_name = "ash_public_cpp"
 }
 
-source_set("manifest") {
-  sources = [
-    "manifest.cc",
-    "manifest.h",
-  ]
-
-  deps = [
-    "//ash/public/interfaces:interfaces_internal",
-    "//base",
-    "//chromeos/services/multidevice_setup/public/mojom",
-    "//services/content/public/mojom",
-    "//services/data_decoder/public/mojom",
-    "//services/device/public/mojom",
-    "//services/preferences/public/mojom",
-    "//services/service_manager/public/cpp",
-    "//services/service_manager/public/mojom",
-    "//services/viz/public/interfaces",
-    "//services/ws/public/cpp:manifest",
-    "//services/ws/public/mojom",
-  ]
-}
-
-source_set("manifest_for_tests") {
-  testonly = true
-
-  sources = [
-    "test_manifest.cc",
-    "test_manifest.h",
-  ]
-
-  deps = [
-    ":manifest",
-    "//ash/public/interfaces:test_interfaces",
-    "//base",
-    "//services/service_manager/public/cpp",
-    "//services/service_manager/public/mojom",
-  ]
-}
-
 # Using a test service because the traits need to pass handles around. Revisit
 # this after Deserialize(Serialize()) API works with handles.
 mojom("test_interfaces") {
@@ -241,7 +197,6 @@
 }
 
 source_set("test_support") {
-  testonly = true
   sources = [
     "immersive/immersive_fullscreen_controller_test_api.cc",
     "immersive/immersive_fullscreen_controller_test_api.h",
@@ -254,7 +209,6 @@
     "//base",
     "//services/service_manager/public/cpp",
     "//ui/aura",
-    "//ui/aura:test_support",
     "//ui/gfx",
     "//ui/keyboard:mojom",
     "//ui/views",
--- a/ash/public/cpp/caption_buttons/frame_back_button.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/public/cpp/caption_buttons/frame_back_button.cc	2019-05-17 18:53:08.196000000 +0300
@@ -10,6 +10,7 @@
 #include "ui/base/hit_test.h"
 #include "ui/base/l10n/l10n_util.h"
 #include "ui/base/resource/resource_bundle.h"
+#include "ui/events/event_sink.h"
 #include "ui/strings/grit/ui_strings.h"
 #include "ui/views/widget/widget.h"
 #include "ui/views/window/caption_button_layout_constants.h"
@@ -28,14 +29,15 @@
 
 void FrameBackButton::ButtonPressed(Button* sender, const ui::Event& event) {
   // Send up event as well as down event as ARC++ clients expect this sequence.
-  // TODO: Investigate if we should be using the current modifiers.
   aura::Window* root_window = GetWidget()->GetNativeWindow()->GetRootWindow();
   ui::KeyEvent press_key_event(ui::ET_KEY_PRESSED, ui::VKEY_BROWSER_BACK,
                                ui::EF_NONE);
-  ignore_result(root_window->GetHost()->SendEventToSink(&press_key_event));
+  ignore_result(root_window->GetHost()->event_sink()->OnEventFromSource(
+      &press_key_event));
   ui::KeyEvent release_key_event(ui::ET_KEY_RELEASED, ui::VKEY_BROWSER_BACK,
                                  ui::EF_NONE);
-  ignore_result(root_window->GetHost()->SendEventToSink(&release_key_event));
+  ignore_result(root_window->GetHost()->event_sink()->OnEventFromSource(
+      &release_key_event));
 }
 
 }  // namespace ash
--- a/ash/public/cpp/default_frame_header.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/public/cpp/default_frame_header.h	2019-05-17 18:53:08.200000000 +0300
@@ -58,7 +58,7 @@
     ~ColorAnimator();
 
     void SetTargetColor(SkColor target);
-    SkColor target_color() const { return target_color_; }
+    SkColor target_color() const { return target_color_; };
     SkColor GetCurrentColor();
     float get_value() const { return animation_.GetCurrentValue(); }
 
--- a/ash/public/cpp/default_scale_factor_retriever.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/public/cpp/default_scale_factor_retriever.cc	2019-05-17 18:53:08.200000000 +0300
@@ -4,7 +4,6 @@
 
 #include "ash/public/cpp/default_scale_factor_retriever.h"
 #include "ash/public/interfaces/constants.mojom.h"
-#include "base/bind.h"
 
 namespace ash {
 
--- a/ash/public/cpp/default_scale_factor_retriever_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/public/cpp/default_scale_factor_retriever_unittest.cc	2019-05-17 18:53:08.200000000 +0300
@@ -5,7 +5,6 @@
 #include "ash/public/cpp/default_scale_factor_retriever.h"
 
 #include "ash/public/interfaces/cros_display_config.mojom.h"
-#include "base/bind.h"
 #include "base/message_loop/message_loop.h"
 #include "base/run_loop.h"
 #include "mojo/public/cpp/bindings/binding.h"
--- a/ash/public/cpp/DEPS	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/public/cpp/DEPS	2019-05-17 18:53:08.192000000 +0300
@@ -1,8 +1,5 @@
 include_rules = [
-  "+chromeos/constants",
   "+components/prefs",
-  "+services/data_decoder/public",
-  "+services/device/public",
   "+skia/public/interfaces",
   "+ui/display",
 ]
--- a/ash/public/cpp/immersive/immersive_fullscreen_controller.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/public/cpp/immersive/immersive_fullscreen_controller.cc	2019-05-17 18:53:08.200000000 +0300
@@ -10,9 +10,7 @@
 #include "ash/public/cpp/immersive/immersive_focus_watcher.h"
 #include "ash/public/cpp/immersive/immersive_fullscreen_controller_delegate.h"
 #include "ash/public/cpp/window_properties.h"
-#include "base/bind.h"
 #include "base/metrics/histogram_macros.h"
-#include "ui/aura/client/aura_constants.h"
 #include "ui/aura/client/cursor_client.h"
 #include "ui/aura/env.h"
 #include "ui/aura/window.h"
@@ -27,14 +25,8 @@
 #include "ui/views/view.h"
 #include "ui/views/widget/widget.h"
 
-DEFINE_UI_CLASS_PROPERTY_TYPE(ash::ImmersiveFullscreenController*)
-
 namespace ash {
 
-DEFINE_UI_CLASS_PROPERTY_KEY(ImmersiveFullscreenController*,
-                             kImmersiveFullscreenControllerKey,
-                             nullptr)
-
 namespace {
 
 // A window targeter installed on a Widget's window when it's in immersive mode.
@@ -117,15 +109,6 @@
   top_container_ = top_container;
   widget_ = widget;
 
-  // A widget can have more than one ImmersiveFullscreenController
-  // (WideFrameView does this), so this key only tracks the first
-  // ImmersiveFullscreenController.
-  if (nullptr == widget->GetNativeWindow()->GetProperty(
-                     kImmersiveFullscreenControllerKey)) {
-    widget->GetNativeWindow()->SetProperty(kImmersiveFullscreenControllerKey,
-                                           this);
-  }
-
   EnableWindowObservers(true);
 }
 
@@ -288,13 +271,6 @@
     widget->GetNativeWindow()->SetProperty(kImmersiveIsActive, enabled);
 }
 
-// static
-ImmersiveFullscreenController* ImmersiveFullscreenController::GetForTest(
-    views::Widget* widget) {
-  return widget->GetNativeWindow()->GetProperty(
-      kImmersiveFullscreenControllerKey);
-}
-
 ////////////////////////////////////////////////////////////////////////////////
 // private:
 
@@ -321,7 +297,7 @@
 
   aura::Window* window = widget_->GetNativeWindow();
   // For Mash, handle events sent to the Mus client's root window.
-  if (window->env()->mode() == aura::Env::Mode::MUS)
+  if (features::IsUsingWindowService())
     window = window->GetRootWindow();
   aura::Env* env = window->env();
   if (enable) {
@@ -686,16 +662,6 @@
     return false;
   }
 
-  // Don't perform an immersive reveal when gesture scrolls from the top ought
-  // to be dragging the window.
-  aura::Window* window = widget_->GetNativeWindow();
-  if (window->env()->mode() == aura::Env::Mode::MUS)
-    window = window->GetRootWindow();
-  if (window->GetProperty(
-          aura::client::kGestureDragFromClientAreaTopMovesWindow)) {
-    return false;
-  }
-
   // When the top-of-window views are not fully revealed, handle gestures which
   // start in the top few pixels of the screen.
   gfx::Rect hit_bounds_in_screen(GetDisplayBoundsInScreen());
--- a/ash/public/cpp/immersive/immersive_fullscreen_controller.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/public/cpp/immersive/immersive_fullscreen_controller.h	2019-05-17 18:53:08.200000000 +0300
@@ -137,8 +137,6 @@
 
   static void EnableForWidget(views::Widget* widget, bool enabled);
 
-  static ImmersiveFullscreenController* GetForTest(views::Widget* widget);
-
  private:
   friend class ImmersiveFullscreenControllerTest;
   friend class ImmersiveFullscreenControllerTestApi;
--- a/ash/public/cpp/immersive/immersive_fullscreen_controller_test_api.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/public/cpp/immersive/immersive_fullscreen_controller_test_api.cc	2019-05-17 18:53:08.200000000 +0300
@@ -6,44 +6,11 @@
 
 #include "ash/public/cpp/immersive/immersive_fullscreen_controller.h"
 #include "ash/public/cpp/immersive/immersive_fullscreen_controller_delegate.h"
-#include "base/run_loop.h"
 #include "ui/aura/env.h"
-#include "ui/aura/event_injector.h"
 #include "ui/aura/window.h"
-#include "ui/events/base_event_utils.h"
 #include "ui/gfx/geometry/rect.h"
 #include "ui/views/widget/widget.h"
 
-namespace {
-
-// Update mouse location for |window|. For local window, update its aura::Env
-// directly. For remote window, update aura::Env by injecting a mouse move
-// event. EventInjector is used so that the Window Service side code under mash
-// sees the updated mouse location as well.
-void UpdateMouseLocation(aura::Window* window,
-                         const gfx::Point& screen_location,
-                         bool wait) {
-  if (window->env()->mode() == aura::Env::Mode::LOCAL) {
-    window->env()->SetLastMouseLocation(screen_location);
-    return;
-  }
-
-  ui::MouseEvent event(ui::ET_MOUSE_MOVED, screen_location, screen_location,
-                       ui::EventTimeForNow(), ui::EF_NONE, 0);
-  if (!wait) {
-    aura::EventInjector().Inject(window->GetHost(), &event);
-    return;
-  }
-
-  // Ensure the mouse event goes through when |wait| is set.
-  aura::EventInjector event_injector;
-  base::RunLoop run_loop;
-  event_injector.Inject(window->GetHost(), &event, run_loop.QuitClosure());
-  run_loop.Run();
-}
-
-}  // namespace
-
 namespace ash {
 
 ImmersiveFullscreenControllerTestApi::ImmersiveFullscreenControllerTestApi(
@@ -53,8 +20,7 @@
 ImmersiveFullscreenControllerTestApi::~ImmersiveFullscreenControllerTestApi() =
     default;
 
-void ImmersiveFullscreenControllerTestApi::SetupForTest(
-    bool wait_for_mouse_event) {
+void ImmersiveFullscreenControllerTestApi::SetupForTest() {
   immersive_fullscreen_controller_->animations_disabled_for_test_ = true;
 
   // Move the mouse off of the top-of-window views so that it does not keep the
@@ -68,9 +34,10 @@
       bottommost_in_screen = bounds_in_screen[i].bottom();
   }
   gfx::Point cursor_pos(0, bottommost_in_screen + 10);
-  UpdateMouseLocation(
-      immersive_fullscreen_controller_->widget()->GetNativeView(), cursor_pos,
-      wait_for_mouse_event);
+  immersive_fullscreen_controller_->widget()
+      ->GetNativeView()
+      ->env()
+      ->SetLastMouseLocation(cursor_pos);
   immersive_fullscreen_controller_->UpdateLocatedEventRevealedLock();
 }
 
--- a/ash/public/cpp/immersive/immersive_fullscreen_controller_test_api.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/public/cpp/immersive/immersive_fullscreen_controller_test_api.h	2019-05-17 18:53:08.200000000 +0300
@@ -30,11 +30,8 @@
   };
 
   // Disables animations and moves the mouse so that it is not over the
-  // top-of-window views for the sake of testing. |wait_for_mouse_move| should
-  // normally be true to wait for the generated mouse events to go through under
-  // mash. It is provided for tests that call SetupForTest under the scope of
-  // TestMockTimeTaskRunner::ScopedContext that does not allow RunLoop::Run().
-  void SetupForTest(bool wait_for_mouse_event = true);
+  // top-of-window views for the sake of testing.
+  void SetupForTest();
 
   bool IsTopEdgeHoverTimerRunning() const;
 
--- a/ash/public/cpp/mus_property_mirror_ash.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/public/cpp/mus_property_mirror_ash.cc	2019-05-17 18:53:08.200000000 +0300
@@ -50,6 +50,8 @@
   } else if (key == kWindowPinTypeKey) {
     ash::mojom::WindowPinType value = window->GetProperty(kWindowPinTypeKey);
     root_window->SetProperty(kWindowPinTypeKey, value);
+  } else if (key == aura::client::kAppIconKey) {
+    MirrorOwnedProperty(window, root_window, aura::client::kAppIconKey);
   } else if (key == kRestoreBoundsOverrideKey) {
     MirrorOwnedProperty(window, root_window, kRestoreBoundsOverrideKey);
   } else if (key == kRestoreWindowStateTypeOverrideKey) {
@@ -71,6 +73,9 @@
   } else if (key == aura::client::kTopViewInset) {
     root_window->SetProperty(aura::client::kTopViewInset,
                              window->GetProperty(aura::client::kTopViewInset));
+
+  } else if (key == aura::client::kWindowIconKey) {
+    MirrorOwnedProperty(window, root_window, aura::client::kWindowIconKey);
   } else if (key == kFrameActiveColorKey) {
     root_window->SetProperty(kFrameActiveColorKey,
                              window->GetProperty(kFrameActiveColorKey));
--- a/ash/public/cpp/network_icon_image_source.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/public/cpp/network_icon_image_source.cc	2019-05-17 18:53:08.200000000 +0300
@@ -22,7 +22,7 @@
 
 // TODO(estade): share this alpha with other things in ash (battery, etc.).
 // See https://crbug.com/623987 and https://crbug.com/632827
-// For now, this value should match the one used in kTrayIconBackgroundAlpha
+// For now, this value should match the one used in kTrayIconBackgroundColor
 // in ash/system/tray/tray_constants.cc
 constexpr int kSignalStrengthImageBgAlpha = 0x4D;
 
--- a/ash/public/cpp/OWNERS	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/public/cpp/OWNERS	2019-05-17 18:53:08.192000000 +0300
@@ -1,8 +1,3 @@
-per-file manifest.cc=set noparent
-per-file manifest.cc=file://ipc/SECURITY_OWNERS
-per-file manifest.h=set noparent
-per-file manifest.h=file://ipc/SECURITY_OWNERS
-
 per-file *shelf*=file://ash/shelf/OWNERS
 
 per-file *.mojom=set noparent
--- a/ash/public/cpp/shelf_prefs.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/public/cpp/shelf_prefs.cc	2019-05-17 18:53:08.204000000 +0300
@@ -50,7 +50,7 @@
   if (local_pref->IsManaged())
     return value;
 
-  std::string pref_key = base::NumberToString(display_id);
+  std::string pref_key = base::Int64ToString(display_id);
   bool has_per_display_prefs = false;
   if (!pref_key.empty()) {
     const base::DictionaryValue* shelf_prefs =
@@ -95,7 +95,7 @@
   const base::DictionaryValue* current_shelf_prefs =
       prefs->GetDictionary(prefs::kShelfPreferences);
   DCHECK(current_shelf_prefs);
-  std::string display_key = base::NumberToString(display_id);
+  std::string display_key = base::Int64ToString(display_id);
   const base::DictionaryValue* current_display_prefs = nullptr;
   std::string current_value;
   if (current_shelf_prefs->GetDictionary(display_key, &current_display_prefs) &&
--- a/ash/public/cpp/shelf_struct_mojom_traits.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/public/cpp/shelf_struct_mojom_traits.h	2019-05-17 18:53:08.204000000 +0300
@@ -160,8 +160,6 @@
         return ash::mojom::ShelfLaunchSource::APP_LIST;
       case ash::LAUNCH_FROM_APP_LIST_SEARCH:
         return ash::mojom::ShelfLaunchSource::APP_LIST_SEARCH;
-      case ash::LAUNCH_FROM_SHELF:
-        return ash::mojom::ShelfLaunchSource::SHELF;
     }
     NOTREACHED();
     return ash::mojom::ShelfLaunchSource::UNKNOWN;
@@ -179,9 +177,6 @@
       case ash::mojom::ShelfLaunchSource::APP_LIST_SEARCH:
         *out = ash::LAUNCH_FROM_APP_LIST_SEARCH;
         return true;
-      case ash::mojom::ShelfLaunchSource::SHELF:
-        *out = ash::LAUNCH_FROM_SHELF;
-        return true;
     }
     NOTREACHED();
     return false;
--- a/ash/public/cpp/shelf_types.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/public/cpp/shelf_types.h	2019-05-17 18:53:08.204000000 +0300
@@ -53,13 +53,15 @@
   // The default transparent background.
   SHELF_BACKGROUND_DEFAULT,
 
-  // The background when a window is maximized or two windows are maximized
-  // for a split view.
+  // The background when a window is maximized.
   SHELF_BACKGROUND_MAXIMIZED,
 
   // The background when fullscreen app list is visible.
   SHELF_BACKGROUND_APP_LIST,
 
+  // The background when split view mode is active.
+  SHELF_BACKGROUND_SPLIT_VIEW,
+
   // The background when OOBE is active.
   SHELF_BACKGROUND_OOBE,
 
@@ -69,14 +71,11 @@
   // The background when login/lock/user-add is active and the wallpaper is not
   // blurred.
   SHELF_BACKGROUND_LOGIN_NONBLURRED_WALLPAPER,
-
-  // The background when overview is active.
-  SHELF_BACKGROUND_OVERVIEW,
 };
 
 // Source of the launch or activation request, for tracking.
 enum ShelfLaunchSource {
-  // The item was launched from an unknown source.
+  // The item was launched from an unknown source (ie. not the app list).
   LAUNCH_FROM_UNKNOWN,
 
   // The item was launched from a generic app list view.
@@ -84,9 +83,6 @@
 
   // The item was launched from an app list search view.
   LAUNCH_FROM_APP_LIST_SEARCH,
-
-  // The item was launched from the shelf itself.
-  LAUNCH_FROM_SHELF,
 };
 
 // The actions that may be performed when a shelf item is selected.
--- a/ash/public/cpp/shell_window_ids.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/public/cpp/shell_window_ids.cc	2019-05-17 18:53:08.204000000 +0300
@@ -12,25 +12,18 @@
 // containers appearing earlier in the list are activated before windows in
 // containers appearing later in the list.
 const int32_t kActivatableShellWindowIds[] = {
-    kShellWindowId_OverlayContainer,
-    kShellWindowId_LockSystemModalContainer,
+    kShellWindowId_OverlayContainer, kShellWindowId_LockSystemModalContainer,
     kShellWindowId_AccessibilityPanelContainer,
-    kShellWindowId_SettingBubbleContainer,
-    kShellWindowId_PowerMenuContainer,
+    kShellWindowId_SettingBubbleContainer, kShellWindowId_PowerMenuContainer,
     kShellWindowId_LockActionHandlerContainer,
-    kShellWindowId_LockScreenContainer,
-    kShellWindowId_SystemModalContainer,
-    kShellWindowId_AlwaysOnTopContainer,
-    kShellWindowId_AppListContainer,
-    kShellWindowId_DefaultContainer,
-    kShellWindowId_AppListTabletModeContainer,
+    kShellWindowId_LockScreenContainer, kShellWindowId_SystemModalContainer,
+    kShellWindowId_AlwaysOnTopContainer, kShellWindowId_AppListContainer,
+    kShellWindowId_DefaultContainer, kShellWindowId_AppListTabletModeContainer,
 
     // Launcher and status are intentionally checked after other containers
     // even though these layers are higher. The user expects their windows
     // to be focused before these elements.
-    kShellWindowId_PipContainer,
-    kShellWindowId_ShelfContainer,
-    kShellWindowId_ShelfBubbleContainer,
+    kShellWindowId_ShelfContainer, kShellWindowId_ShelfBubbleContainer,
     kShellWindowId_StatusContainer,
 };
 
--- a/ash/public/cpp/shell_window_ids.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/public/cpp/shell_window_ids.h	2019-05-17 18:53:08.204000000 +0300
@@ -60,9 +60,6 @@
   // The container for the app list in tablet mode.
   kShellWindowId_AppListTabletModeContainer,
 
-  // The container for the PIP window.
-  kShellWindowId_PipContainer,
-
   // The parent container that holds the ARC IME container and windows created
   // by ARC IME other than the virtual keyboard window.
   // This container window is to ensure that the ARC IME window is stacked above
@@ -138,10 +135,6 @@
   // The container for mouse cursor.
   kShellWindowId_MouseCursorContainer,
 
-  // The container for an image that should stay on top of everything except for
-  // the power off animation.
-  kShellWindowId_AlwaysOnTopWallpaperContainer,
-
   // The topmost container, used for power off animation.
   kShellWindowId_PowerButtonAnimationContainer,
 
@@ -188,7 +181,6 @@
     kShellWindowId_OverlayContainer,
     kShellWindowId_DockedMagnifierContainer,
     kShellWindowId_MouseCursorContainer,
-    kShellWindowId_AlwaysOnTopWallpaperContainer,
     kShellWindowId_PowerButtonAnimationContainer,
 };
 
--- a/ash/public/cpp/test/test_keyboard_controller_observer.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/public/cpp/test/test_keyboard_controller_observer.h	2019-05-17 18:53:08.208000000 +0300
@@ -7,7 +7,6 @@
 
 #include "ash/public/interfaces/keyboard_controller.mojom.h"
 #include "mojo/public/cpp/bindings/associated_binding.h"
-#include "ui/keyboard/public/keyboard_config.mojom.h"
 
 namespace ash {
 
--- a/ash/public/cpp/touch_uma.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/public/cpp/touch_uma.cc	2019-05-17 18:53:08.208000000 +0300
@@ -25,11 +25,11 @@
 
 DEFINE_OWNED_UI_CLASS_PROPERTY_KEY(WindowTouchDetails,
                                    kWindowTouchDetails,
-                                   NULL)
+                                   NULL);
 
 }  // namespace
 
-DEFINE_UI_CLASS_PROPERTY_TYPE(WindowTouchDetails*)
+DEFINE_UI_CLASS_PROPERTY_TYPE(WindowTouchDetails*);
 
 namespace ash {
 
--- a/ash/public/cpp/vector_icons/BUILD.gn	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/public/cpp/vector_icons/BUILD.gn	2019-05-17 18:53:08.208000000 +0300
@@ -10,8 +10,6 @@
 
   icons = [
     "assistant.icon",
-    "assistant_mic.icon",
-    "auto_launch_managed_guest_session.icon",
     "notification_assistant.icon",
     "notification_captive_portal.icon",
     "notification_cellular_alert.icon",
--- a/ash/public/cpp/window_properties.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/public/cpp/window_properties.cc	2019-05-17 18:53:08.208000000 +0300
@@ -12,7 +12,6 @@
 #include "ash/public/interfaces/window_pin_type.mojom.h"
 #include "ash/public/interfaces/window_properties.mojom.h"
 #include "ash/public/interfaces/window_state_type.mojom.h"
-#include "base/bind.h"
 #include "base/unguessable_token.h"
 #include "services/ws/public/mojom/window_manager.mojom.h"
 #include "ui/accessibility/platform/aura_window_properties.h"
@@ -68,10 +67,6 @@
       ws::mojom::WindowManager::kFrameInactiveColor_Property,
       aura::PropertyConverter::CreateAcceptAnyValueCallback());
   property_converter->RegisterPrimitiveProperty(
-      aura::client::kGestureDragFromClientAreaTopMovesWindow,
-      mojom::kGestureDragFromClientAreaTopMovesWindow_Property,
-      aura::PropertyConverter::CreateAcceptAnyValueCallback());
-  property_converter->RegisterPrimitiveProperty(
       kHideShelfWhenFullscreenKey, mojom::kHideShelfWhenFullscreen_Property,
       aura::PropertyConverter::CreateAcceptAnyValueCallback());
   property_converter->RegisterPrimitiveProperty(
@@ -95,9 +90,6 @@
       kIsShowingInOverviewKey, mojom::kIsShowingInOverview_Property,
       aura::PropertyConverter::CreateAcceptAnyValueCallback());
   property_converter->RegisterPrimitiveProperty(
-      kPrePipWindowStateTypeKey, mojom::kPrePipWindowStateType_Property,
-      base::BindRepeating(&IsValidWindowStateType));
-  property_converter->RegisterPrimitiveProperty(
       kRenderTitleAreaProperty,
       ws::mojom::WindowManager::kRenderParentTitleArea_Property,
       aura::PropertyConverter::CreateAcceptAnyValueCallback());
@@ -154,58 +146,57 @@
       aura::PropertyConverter::CreateAcceptAnyValueCallback());
 }
 
-DEFINE_OWNED_UI_CLASS_PROPERTY_KEY(std::string, kArcPackageNameKey, nullptr)
+DEFINE_OWNED_UI_CLASS_PROPERTY_KEY(std::string, kArcPackageNameKey, nullptr);
 DEFINE_UI_CLASS_PROPERTY_KEY(BackdropWindowMode,
                              kBackdropWindowMode,
-                             BackdropWindowMode::kAuto)
-DEFINE_UI_CLASS_PROPERTY_KEY(bool, kBlockedForAssistantSnapshotKey, false)
-DEFINE_UI_CLASS_PROPERTY_KEY(bool, kCanAttachToAnotherWindowKey, true)
-DEFINE_UI_CLASS_PROPERTY_KEY(bool, kCanConsumeSystemKeysKey, false)
-DEFINE_UI_CLASS_PROPERTY_KEY(bool, kHideInOverviewKey, false)
-DEFINE_UI_CLASS_PROPERTY_KEY(bool, kHideShelfWhenFullscreenKey, true)
-DEFINE_UI_CLASS_PROPERTY_KEY(bool, kImmersiveImpliedByFullscreen, true)
-DEFINE_UI_CLASS_PROPERTY_KEY(bool, kImmersiveIsActive, false)
+                             BackdropWindowMode::kAuto);
+DEFINE_UI_CLASS_PROPERTY_KEY(bool, kBlockedForAssistantSnapshotKey, false);
+DEFINE_UI_CLASS_PROPERTY_KEY(bool, kCanAttachToAnotherWindowKey, true);
+DEFINE_UI_CLASS_PROPERTY_KEY(bool, kCanConsumeSystemKeysKey, false);
+DEFINE_UI_CLASS_PROPERTY_KEY(bool, kHideInOverviewKey, false);
+DEFINE_UI_CLASS_PROPERTY_KEY(bool, kHideShelfWhenFullscreenKey, true);
+DEFINE_UI_CLASS_PROPERTY_KEY(bool, kImmersiveImpliedByFullscreen, true);
+DEFINE_UI_CLASS_PROPERTY_KEY(bool, kImmersiveIsActive, false);
 DEFINE_OWNED_UI_CLASS_PROPERTY_KEY(gfx::Rect,
                                    kImmersiveTopContainerBoundsInScreen,
-                                   nullptr)
+                                   nullptr);
 DEFINE_UI_CLASS_PROPERTY_KEY(
     int,
     kImmersiveWindowType,
-    ImmersiveFullscreenController::WindowType::WINDOW_TYPE_OTHER)
-DEFINE_UI_CLASS_PROPERTY_KEY(bool, kIsDeferredTabDraggingTargetWindowKey, false)
-DEFINE_UI_CLASS_PROPERTY_KEY(bool, kIsDraggingTabsKey, false)
-DEFINE_UI_CLASS_PROPERTY_KEY(bool, kIsShowingInOverviewKey, false)
-DEFINE_UI_CLASS_PROPERTY_KEY(mojom::WindowStateType,
-                             kPrePipWindowStateTypeKey,
-                             mojom::WindowStateType::DEFAULT)
-DEFINE_UI_CLASS_PROPERTY_KEY(bool, kRenderTitleAreaProperty, false)
+    ImmersiveFullscreenController::WindowType::WINDOW_TYPE_OTHER);
+DEFINE_UI_CLASS_PROPERTY_KEY(bool,
+                             kIsDeferredTabDraggingTargetWindowKey,
+                             false);
+DEFINE_UI_CLASS_PROPERTY_KEY(bool, kIsDraggingTabsKey, false);
+DEFINE_UI_CLASS_PROPERTY_KEY(bool, kIsShowingInOverviewKey, false);
+DEFINE_UI_CLASS_PROPERTY_KEY(bool, kRenderTitleAreaProperty, false);
 DEFINE_OWNED_UI_CLASS_PROPERTY_KEY(gfx::Rect,
                                    kRestoreBoundsOverrideKey,
-                                   nullptr)
+                                   nullptr);
 DEFINE_UI_CLASS_PROPERTY_KEY(mojom::WindowStateType,
                              kRestoreWindowStateTypeOverrideKey,
-                             mojom::WindowStateType::DEFAULT)
-DEFINE_UI_CLASS_PROPERTY_KEY(bool, kSearchKeyAcceleratorReservedKey, false)
-DEFINE_OWNED_UI_CLASS_PROPERTY_KEY(std::string, kShelfIDKey, nullptr)
-DEFINE_UI_CLASS_PROPERTY_KEY(int32_t, kShelfItemTypeKey, TYPE_UNDEFINED)
+                             mojom::WindowStateType::DEFAULT);
+DEFINE_UI_CLASS_PROPERTY_KEY(bool, kSearchKeyAcceleratorReservedKey, false);
+DEFINE_OWNED_UI_CLASS_PROPERTY_KEY(std::string, kShelfIDKey, nullptr);
+DEFINE_UI_CLASS_PROPERTY_KEY(int32_t, kShelfItemTypeKey, TYPE_UNDEFINED);
 DEFINE_UI_CLASS_PROPERTY_KEY(aura::Window*,
                              kTabDraggingSourceWindowKey,
-                             nullptr)
+                             nullptr);
 DEFINE_UI_CLASS_PROPERTY_KEY(mojom::WindowStateType,
                              kTabDroppedWindowStateTypeKey,
-                             mojom::WindowStateType::DEFAULT)
+                             mojom::WindowStateType::DEFAULT);
 
-DEFINE_UI_CLASS_PROPERTY_KEY(SkColor, kFrameActiveColorKey, kDefaultFrameColor)
+DEFINE_UI_CLASS_PROPERTY_KEY(SkColor, kFrameActiveColorKey, kDefaultFrameColor);
 DEFINE_UI_CLASS_PROPERTY_KEY(SkColor,
                              kFrameInactiveColorKey,
-                             kDefaultFrameColor)
+                             kDefaultFrameColor);
 DEFINE_UI_CLASS_PROPERTY_KEY(mojom::WindowPinType,
                              kWindowPinTypeKey,
-                             mojom::WindowPinType::NONE)
-DEFINE_UI_CLASS_PROPERTY_KEY(bool, kWindowPositionManagedTypeKey, false)
+                             mojom::WindowPinType::NONE);
+DEFINE_UI_CLASS_PROPERTY_KEY(bool, kWindowPositionManagedTypeKey, false);
 DEFINE_UI_CLASS_PROPERTY_KEY(mojom::WindowStateType,
                              kWindowStateTypeKey,
-                             mojom::WindowStateType::DEFAULT)
+                             mojom::WindowStateType::DEFAULT);
 
-DEFINE_UI_CLASS_PROPERTY_KEY(bool, kWindowPipTypeKey, false)
+DEFINE_UI_CLASS_PROPERTY_KEY(bool, kWindowPipTypeKey, false);
 }  // namespace ash
--- a/ash/public/cpp/window_properties.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/public/cpp/window_properties.h	2019-05-17 18:53:08.208000000 +0300
@@ -112,10 +112,6 @@
 ASH_PUBLIC_EXPORT extern const aura::WindowProperty<bool>* const
     kIsShowingInOverviewKey;
 
-// A property key to store the window state the window had before entering PIP.
-ASH_PUBLIC_EXPORT extern const aura::WindowProperty<
-    mojom::WindowStateType>* const kPrePipWindowStateTypeKey;
-
 // Maps to ws::mojom::WindowManager::kRenderParentTitleArea_Property.
 ASH_PUBLIC_EXPORT extern const aura::WindowProperty<bool>* const
     kRenderTitleAreaProperty;
--- a/ash/public/interfaces/accessibility_focus_ring_controller.mojom	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/public/interfaces/accessibility_focus_ring_controller.mojom	2019-05-17 18:53:08.208000000 +0300
@@ -38,10 +38,4 @@
   // Hides highlight on screen.
   // TODO(katie): Add |caller_id| to highlights as well.
   HideHighlights();
-
-  // Enables double focus rings and sets the second color for the given caller.
-  EnableDoubleFocusRing(uint32 skcolor, string caller_id);
-
-  // Disables double focus rings for the given caller.
-  DisableDoubleFocusRing(string caller_id);
 };
--- a/ash/public/interfaces/app_list.mojom	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/public/interfaces/app_list.mojom	2019-05-17 18:53:08.212000000 +0300
@@ -26,7 +26,6 @@
   string folder_id;   // The id of the item's folder.
   syncer.mojom.StringOrdinal position; // The position of the item.
   bool is_folder;     // Whether this item is a folder.
-  bool is_persistent; // Whether this folder is allowed to contain 1 item.
   gfx.mojom.ImageSkia? icon;  // The icon of this item.
   bool is_page_break; // Whether this item is a "page break" item.
 };
@@ -82,9 +81,6 @@
                                     // indicates its type, e.g. installable from
                                     // PlayStore, installable from WebStore,
                                     // etc.
-  // If set to true, whether or not to send visibility updates through to to
-  // the chrome side when this result is set visible/invisible.
-  bool notify_visibility_change;
 };
 
 // All possible states of the app list.
@@ -92,7 +88,6 @@
   kStateApps = 0,
   kStateSearchResults,
   kStateStart,
-  kStateEmbeddedAssistant,
 };
 
 // The status of the app list model.
@@ -101,24 +96,6 @@
   kStatusSyncing,  // Syncing apps or installing synced apps.
 };
 
-// The UI component the user launched the search result from. Must match
-// chrome/browser/ui/app_list/app_launch_event_logger.proto.
-enum AppListLaunchedFrom {
-  kLaunchedFromGrid = 1,
-  kLaunchedFromSuggestionChip,
-  kLaunchedFromShelf,
-  kLaunchedFromSearchBox,
-};
-
-// The UI representation of the search result. Currently all search results
-// that are not apps (OminboxResult, LauncherSearcResult, etc.) are grouped
-// into kSearchResult. Meanwhile SearchResultTileItemView (shown in zero state)
-// and suggested chips are considered kAppSearchResult.
-enum AppListLaunchType {
- kSearchResult = 0,
- kAppSearchResult,
-};
-
 // How the result should be displayed. Do not change the order of these as
 // they are used for metrics.
 enum SearchResultDisplayType {
@@ -141,8 +118,6 @@
   kOmnibox,         // Results from Omninbox.
   kLauncher,        // Results from launcher search (currently only from Files).
   kAnswerCard,      // WebContents based answer card.
-  kPlayStoreReinstallApp, // Reinstall recommendations from PlayStore.
-  kArcAppShortcut,  // ARC++ app shortcuts.
   // Add new values here.
 };
 
@@ -254,8 +229,7 @@
   // Publishes search results to Ash to render them.
   PublishSearchResults(array<SearchResultMetadata> results);
   // Update the whole model, usually when profile changes happen in Chrome.
-  SetModelData(int32 profile_id,
-               array<AppListItemMetadata> apps,
+  SetModelData(array<AppListItemMetadata> apps,
                bool is_search_engine_google);
 
   //////////////////////////////////////////////////////////////////////////////
@@ -333,17 +307,9 @@
   // Triggers a search query.
   // |trimmed_query|: the trimmed input texts from the search text field.
   StartSearch(mojo_base.mojom.String16 trimmed_query);
-  // Opens a search result and logs to metrics when its view is clicked or
-  // pressed.
+  // Opens a search result when its view is clicked or pressed.
   // |result_id|: the id of the search result the user wants to open.
-  // |launched_from|: where the result was launched.
-  // |launch_type|: how the result is represented in the UI.
-  // |suggestion_index|: the position of the result as a suggestion chip in
-  // the AppsGridView or the position of the result in the zero state search
-  // page.
-  OpenSearchResult(string result_id, int32 event_flags,
-                   AppListLaunchedFrom launched_from,
-                   AppListLaunchType launch_type, int32 suggestion_index);
+  OpenSearchResult(string result_id, int32 event_flags);
   // Invokes a custom action on a result with |result_id|.
   // |action_index| corresponds to the index of an action on the search result,
   // for example, installing. They are stored in SearchResult::actions_.
@@ -373,38 +339,27 @@
   OnAppListVisibilityChanged(bool visible);
 
   //////////////////////////////////////////////////////////////////////////////
-  // Interfaces on app list items. |profile_id| indicates the profile to which
-  // app list items belong. In multi-profile mode, each profile has its own
-  // app list model updater:
+  // Interfaces on app list items:
   // Activates (opens) the item with |id|.
-  ActivateItem(int32 profile_id, string id, int32 event_flags);
+  ActivateItem(string id, int32 event_flags);
   // Returns the context menu model for the item with |id|, or an empty array if
   // there is currently no menu for the item (e.g. during install).
-  GetContextMenuModel(int32 profile_id, string id) => (array<MenuItem> items);
+  GetContextMenuModel(string id) => (array<MenuItem> items);
   // Invoked when a context menu item of an app list item is clicked.
   // |id|: the clicked AppListItem's id.
   // |command_id|: the clicked menu item's command id.
   // |event_flags|: flags from the event which triggered this command.
-  ContextMenuItemSelected(int32 profile_id,
-                          string id,
-                          int32 command_id,
-                          int32 event_flags);
+  ContextMenuItemSelected(string id, int32 command_id, int32 event_flags);
   // Invoked when a folder is created in Ash (e.g. merge items into a folder).
-  OnFolderCreated(int32 profile_id, AppListItemMetadata folder);
+  OnFolderCreated(AppListItemMetadata folder);
   // Invoked when a folder has only one item left and so gets removed.
-  OnFolderDeleted(int32 profile_id, AppListItemMetadata folder);
+  OnFolderDeleted(AppListItemMetadata folder);
   // Invoked when user changes a folder's name or an item's position.
-  OnItemUpdated(int32 profile_id, AppListItemMetadata folder);
+  OnItemUpdated(AppListItemMetadata folder);
   // Invoked when a "page break" item is added with |id| and |position|.
-  OnPageBreakItemAdded(int32 profile_id,
-                       string id,
-                       syncer.mojom.StringOrdinal position);
+  OnPageBreakItemAdded(string id, syncer.mojom.StringOrdinal position);
   // Invoked when a "page break" item with |id| is deleted.
-  OnPageBreakItemDeleted(int32 profile_id, string id);
-
-  // Updated when item with |id| is set to |visible|. Only sent if
-  // |notify_visibility_change| was set on the SearchResultMetadata.
-  OnSearchResultVisibilityChanged(string id, bool visibility);
+  OnPageBreakItemDeleted(string id);
 
   // Acquires a NavigableContentsFactory (indirectly) from the Content Service
   // to allow the app list to display embedded web contents. Currently used only
--- a/ash/public/interfaces/assistant_controller.mojom	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/public/interfaces/assistant_controller.mojom	2019-05-17 18:53:08.212000000 +0300
@@ -32,9 +32,7 @@
   // true then the user gives permission to attach Assistant debug info.
   // |feedback_description| is user's feedback input.
   SendAssistantFeedback(
-    bool pii_allowed,
-    string feedback_description,
-    string screenshot_png);
+    bool pii_allowed, string feedback_description);
 };
 
 // Interface to the AssistantAlarmTimerController which is owned by the
--- a/ash/public/interfaces/assistant_setup.mojom	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/public/interfaces/assistant_setup.mojom	2019-05-17 18:53:08.212000000 +0300
@@ -9,8 +9,6 @@
   CONSENT_FLOW,
   // The speaker id enrollment flow.
   SPEAKER_ID_ENROLLMENT,
-  // The speaker id retrain flow.
-  SPEAKER_ID_RETRAIN,
 };
 
 // Interface for a class which is responsible for start Assistant OptIn flow.
--- a/ash/public/interfaces/BUILD.gn	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/public/interfaces/BUILD.gn	2019-05-17 18:53:08.208000000 +0300
@@ -18,7 +18,6 @@
     "accessibility_controller_enums.mojom",
     "accessibility_focus_ring_controller.mojom",
     "app_list.mojom",
-    "arc_custom_tab.mojom",
     "ash_display_controller.mojom",
     "ash_message_center_controller.mojom",
     "ash_window_manager.mojom",
@@ -28,6 +27,7 @@
     "assistant_volume_control.mojom",
     "cast_config.mojom",
     "constants.mojom",
+    "contained_shell.mojom",
     "cros_display_config.mojom",
     "display_output_protection.mojom",
     "docked_magnifier_controller.mojom",
@@ -39,7 +39,6 @@
     "ime_info.mojom",
     "keyboard_controller.mojom",
     "kiosk_app_info.mojom",
-    "kiosk_next_shell.mojom",
     "locale.mojom",
     "login_screen.mojom",
     "login_user_info.mojom",
--- a/ash/public/interfaces/cros_display_config.mojom	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/public/interfaces/cros_display_config.mojom	2019-05-17 18:53:08.212000000 +0300
@@ -143,8 +143,6 @@
   double refresh_rate;
   // True if the mode is the display's native mode.
   bool is_native;
-  // True if the mode is interlaced.
-  bool is_interlaced;
 };
 
 // Defines the properties of an individual display, returned by
--- a/ash/public/interfaces/login_screen.mojom	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/public/interfaces/login_screen.mojom	2019-05-17 18:53:08.212000000 +0300
@@ -219,10 +219,7 @@
   SetShowGuestButtonInOobe(bool show);
 
   // Sets whether parent access button can be shown on the login shelf.
-  SetShowParentAccessButton(bool show);
-
-  // Sets whether parent access code input dialog is shown on the lock screen.
-  SetShowParentAccessDialog(bool show);
+  SetShowParentAccess(bool show);
 
   // Transitions focus to the shelf area. If |reverse|, focuses the status area.
   FocusLoginShelf(bool reverse);
@@ -265,13 +262,6 @@
   // the other auth methods above.
   AuthenticateUserWithEasyUnlock(signin.mojom.AccountId account_id);
 
-  // Validates parent access code for the user identified by |account_id|.
-  // Passes validation result in the callback.
-  // Note: This should only be used for child user.
-  ValidateParentAccessCode(
-    signin.mojom.AccountId account_id,
-    string access_code) => (bool access_code_valid);
-
   // Request to hard lock the user pod.
   // |account_id|:    The account id of the user in the user pod.
   HardlockPod(signin.mojom.AccountId account_id);
@@ -356,7 +346,4 @@
   // the login screen / OOBE. |reverse| is true when the focus moves in the
   // reversed direction.
   OnFocusLeavingSystemTray(bool reverse);
-
-  // Used by Ash to signal that user activity occurred on the login screen.
-  OnUserActivity();
 };
--- a/ash/public/interfaces/login_screen_test_api.test-mojom	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/public/interfaces/login_screen_test_api.test-mojom	2019-05-17 18:53:08.212000000 +0300
@@ -14,15 +14,6 @@
   // Returns true if the login shelf is currently being shown.
   IsLoginShelfShown() => (bool is_shown);
 
-  // Returns true if Restart button is currently being shown.
-  IsRestartButtonShown() => (bool is_shown);
-
-  // Returns true if Shutdown button is currently being shown.
-  IsShutdownButtonShown() => (bool is_shown);
-
   // Submit |password| for |account_id|.
   SubmitPassword(signin.mojom.AccountId account_id, string password) => ();
-
-  // Fetches current UI update count.
-  GetUiUpdateCount() => (int64 count);
 };
--- a/ash/public/interfaces/login_user_info.mojom	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/public/interfaces/login_user_info.mojom	2019-05-17 18:53:08.212000000 +0300
@@ -10,7 +10,7 @@
 import "mojo/public/mojom/base/values.mojom";
 
 // Supported multi-profile user behavior values.
-// Keep in sync with the enum in chromeos_user_pod_row.js and user_pod_row.js
+// Keep in sync with the enum in md_user_pod_row.js and user_pod_row.js
 enum MultiProfileUserBehavior {
   UNRESTRICTED = 0,
   PRIMARY_ONLY = 1,
--- a/ash/public/interfaces/shelf.mojom	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/public/interfaces/shelf.mojom	2019-05-17 18:53:08.212000000 +0300
@@ -46,10 +46,9 @@
 // Source of the launch or activation request, for tracking.
 // These values match ash::ShelfLaunchSource.
 enum ShelfLaunchSource {
-  UNKNOWN,          // The item was launched from elsewhere.
+  UNKNOWN,          // The item was launched from outside the app list.
   APP_LIST,         // The item was launched from a generic app list view.
   APP_LIST_SEARCH,  // The item was launched from an app list search view.
-  SHELF,            // The item was launched from the shelf.
 };
 
 // The Shelf controller allows clients (eg. Chrome) to control the ash shelf.
--- a/ash/public/interfaces/tablet_mode.mojom	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/public/interfaces/tablet_mode.mojom	2019-05-17 18:53:08.216000000 +0300
@@ -15,7 +15,4 @@
   // Sets a client (e.g. chrome). Triggers OnTabletModeToggled() to provide
   // the initial state.
   SetClient(TabletModeClient client);
-
-  // Enables or disables tablet mode. For testing only.
-  SetTabletModeEnabledForTesting(bool enabled) => (bool enabled);
 };
--- a/ash/public/interfaces/voice_interaction_controller.mojom	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/public/interfaces/voice_interaction_controller.mojom	2019-05-17 18:53:08.216000000 +0300
@@ -46,9 +46,7 @@
   // Disallowed because the device is in demo mode.
   DISALLOWED_BY_DEMO_MODE,
   // Disallowed because the device is in public session.
-  DISALLOWED_BY_PUBLIC_SESSION,
-  // Disallowed because the user's account type is currently not supported.
-  DISALLOWED_BY_ACCOUNT_TYPE
+  DISALLOWED_BY_PUBLIC_SESSION
 };
 
 // Allows observing changes to voice interaction status and settings.
@@ -69,8 +67,8 @@
   // Called when hotword is set to always on/only with power source.
   OnVoiceInteractionHotwordAlwaysOn(bool always_on);
 
-  // Called when consent status is updated.
-  OnVoiceInteractionConsentStatusUpdated(ConsentStatus consent_status);
+  // Called when voice interaction setup flow completed.
+  OnVoiceInteractionSetupCompleted(bool completed);
 
   // Called when assistant feature allowed state has changed.
   OnAssistantFeatureAllowedChanged(AssistantAllowedState state);
@@ -101,8 +99,8 @@
   // Called when the hotword is set to always on/only with power source.
   NotifyHotwordAlwaysOn(bool enabled);
 
-  // Called when the consent status is obtained from the server.
-  NotifyConsentStatus(ConsentStatus consent_status);
+  // Called when the voice interaction setup complete status is changed.
+  NotifySetupCompleted(bool completed);
 
   // Notify if voice interaction feature is allowed or not. e.g. not allowed
   // if disabled by policy.
@@ -120,20 +118,3 @@
   // Add an observer.
   AddObserver(VoiceInteractionObserver observer);
 };
-
-// The status of the user's consent. The enum values cannot be changed because
-// they are persisted on disk.
-enum ConsentStatus {
-  // The status is unknown.
-  kUnknown = 0,
-
-  // The user accepted activity control access.
-  kActivityControlAccepted = 1,
-
-  // The user is not authorized to give consent.
-  kUnauthorized = 2,
-
-  // The user's consent information is not found. This is typically the case
-  // when consent from the user has never been requested.
-  kNotFound = 3,
-};
--- a/ash/public/interfaces/wallpaper.mojom	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/public/interfaces/wallpaper.mojom	2019-05-17 18:53:08.216000000 +0300
@@ -53,11 +53,14 @@
   //                                    reside.
   // |device_policy_wallpaper_path|: The file path of the device policy
   //                                 wallpaper (if any).
+  // |is_device_wallpaper_policy_enforced|: Whether the device wallpaper policy
+  //                                        is enforced on the device.
   Init(WallpaperControllerClient client,
        mojo_base.mojom.FilePath user_data_path,
        mojo_base.mojom.FilePath chromeos_wallpapers_path,
        mojo_base.mojom.FilePath chromeos_custom_wallpapers_path,
-       mojo_base.mojom.FilePath device_policy_wallpaper_path);
+       mojo_base.mojom.FilePath device_policy_wallpaper_path,
+       bool is_device_wallpaper_policy_enforced);
 
   // Sets wallpaper from a local file and updates the saved wallpaper info for
   // the user.
@@ -142,12 +145,9 @@
                      string wallpaper_files_id,
                      string data);
 
-  // Sets the path of device policy wallpaper.
-  // |device_policy_wallpaper_path|: The file path of the device policy
-  //                                 wallpaper if it was set or empty value if
-  //                                 it was cleared.
-  SetDevicePolicyWallpaperPath(
-      mojo_base.mojom.FilePath device_policy_wallpaper_path);
+  // Sets whether device wallpaper policy is enforced on this device. Updates/
+  // clears the device policy controlled wallpaper if applicable.
+  SetDeviceWallpaperPolicyEnforced(bool enforced);
 
   // Sets wallpaper from a third-party app (as opposed to the Chrome OS
   // wallpaper picker).
@@ -205,17 +205,6 @@
   // when using this method.
   ShowOneShotWallpaper(gfx.mojom.ImageSkia image);
 
-  // Shows a wallpaper that stays on top of everything except for the power off
-  // animation. All other wallpaper requests are ignored when the always-on-top
-  // wallpaper is being shown.
-  // |image_path|: The file path to read the image data from.
-  ShowAlwaysOnTopWallpaper(mojo_base.mojom.FilePath image_path);
-
-  // Removes the always-on-top wallpaper. The wallpaper will revert to the
-  // previous one, or a default one if there was none. No-op if the current
-  // wallpaper is not always-on-top.
-  RemoveAlwaysOnTopWallpaper();
-
   // Removes all of the user's saved wallpapers and related info.
   // |wallpaper_files_id|: The file id for user_info.account_id.
   RemoveUserWallpaper(WallpaperUserInfo user_info, string wallpaper_files_id);
--- a/ash/public/interfaces/window_properties.mojom	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/public/interfaces/window_properties.mojom	2019-05-17 18:53:08.216000000 +0300
@@ -53,9 +53,6 @@
 // If true, the window is currently showing in overview mode.
 const string kIsShowingInOverview_Property = "ash:is-showing-in-overview";
 
-// A property key to store the window state the window had before entering PIP.
-const string kPrePipWindowStateType_Property = "ash:pre-pip-window-state-type";
-
 // A property key to store the address of the source window that the drag
 // originated from if the window is currently in tab-dragging process.
 const string kTabDraggingSourceWindow_Property =
@@ -90,7 +87,3 @@
 
 // A boolean property to indicate a picture-in-picture window.
 const string kIsWindowPip_Property = "ash:is-window-pip";
-
-// A boolean that corresponds to kGestureDragFromClientAreaTopMovesWindow.
-const string kGestureDragFromClientAreaTopMovesWindow_Property =
-    "ash:gesture-drag-from-client-area-top-moves-window";
--- a/ash/resources/BUILD.gn	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/resources/BUILD.gn	2019-05-17 18:53:08.216000000 +0300
@@ -76,13 +76,9 @@
 ash_test_resources("with_content_100_percent") {
   percent = "100"
   sources = [
-    "$root_gen_dir/content/app/strings/content_strings_en-US.pak",
     "$root_gen_dir/content/content_resources.pak",
-    "$root_gen_dir/third_party/blink/public/resources/blink_scaled_resources_100_percent.pak",
   ]
   deps = [
     "//content:resources",
-    "//content/app/strings",
-    "//third_party/blink/public:scaled_resources_100_percent",
   ]
 }
--- a/ash/resources/PRESUBMIT.py	2019-05-17 17:45:36.500000000 +0300
+++ b/ash/resources/PRESUBMIT.py	2019-05-17 18:53:08.216000000 +0300
@@ -4,9 +4,9 @@
 
 """Presubmit script for Chromium Ash resources.
 
-See http://dev.ch40m1um.qjz9zk/developers/how-tos/depottools/presubmit-scripts
+See http://dev.chromium.org/developers/how-tos/depottools/presubmit-scripts
 for more details about the presubmit API built into depot_tools, and see
-https://chromium.9oo91esource.qjz9zk/chromium/b+/master/styleguide/web/web.md
+https://chromium.googlesource.com/chromium/b+/master/styleguide/web/web.md
 for the rules we're checking against here.
 """
 
--- a/ash/resources/vector_icons/BUILD.gn	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/resources/vector_icons/BUILD.gn	2019-05-17 18:53:08.216000000 +0300
@@ -11,16 +11,8 @@
   icons = [
     "always_show_shelf.icon",
     "auto_hide.icon",
-    "autoclick.icon",
-    "autoclick_double_click.icon",
-    "autoclick_drag.icon",
-    "autoclick_left_click.icon",
-    "autoclick_right_click.icon",
-    "autoclick_pause.icon",
     "captive_portal.icon",
     "check_circle.icon",
-    "desks_close_desk_button.icon",
-    "desks_new_desk_button.icon",
     "dictation_menu.icon",
     "dictation_off.icon",
     "dictation_off_newui.icon",
@@ -33,7 +25,6 @@
     "keyboard.icon",
     "lock_screen_alert.icon",
     "lock_screen_arrow.icon",
-    "lock_screen_arrow_back.icon",
     "lock_screen_backspace.icon",
     "lock_screen_caps_lock.icon",
     "lock_screen_dropdown.icon",
@@ -102,7 +93,6 @@
     "palette_tray_icon_laser_pointer.icon",
     "palette_tray_icon_magnify.icon",
     "palette_tray_icon_metalayer.icon",
-    "parent_access_lock.icon",
     "send.icon",
     "settings.icon",
     "shelf_add_person_button.icon",
@@ -118,6 +108,7 @@
     "shelf_overflow.icon",
     "shelf_overflow_horizontal_dots.icon",
     "shelf_overview.icon",
+    "shelf_parent_access_button.icon",
     "shelf_position.icon",
     "shelf_shutdown_button.icon",
     "shelf_sign_out_button.icon",
--- a/ash/resources/vector_icons/shelf_globe.icon	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/resources/vector_icons/shelf_globe.icon	2019-05-17 18:53:08.224000000 +0300
@@ -2,62 +2,64 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-CANVAS_DIMENSIONS, 20,
-MOVE_TO, 9.99f, 2,
-CUBIC_TO, 5.58f, 2, 2, 5.58f, 2, 10,
-R_CUBIC_TO, 0, 4.42f, 3.58f, 8, 7.99f, 8,
-CUBIC_TO, 14.42f, 18, 18, 14.42f, 18, 10,
-R_CUBIC_TO, 0, -4.42f, -3.58f, -8, -8.01f, -8,
-CLOSE,
-R_MOVE_TO, 5.54f, 4.8f,
-R_H_LINE_TO, -2.36f,
-R_CUBIC_TO, -0.26f, -1, -0.62f, -1.96f, -1.1f, -2.85f,
-R_CUBIC_TO, 1.47f, 0.5f, 2.7f, 1.53f, 3.46f, 2.85f,
-CLOSE,
-MOVE_TO, 10, 3.63f,
-R_CUBIC_TO, 0.66f, 0.96f, 1.18f, 2.02f, 1.53f, 3.17f,
-H_LINE_TO, 8.47f,
-R_CUBIC_TO, 0.34f, -1.14f, 0.86f, -2.21f, 1.53f, -3.17f,
-CLOSE,
-MOVE_TO, 3.81f, 11.6f,
-CUBIC_TO, 3.68f, 11.09f, 3.6f, 10.55f, 3.6f, 10,
-R_CUBIC_TO, 0, -0.55f, 0.08f, -1.09f, 0.21f, -1.6f,
-R_H_LINE_TO, 2.7f,
-CUBIC_TO, 6.45f, 8.93f, 6.4f, 9.46f, 6.4f, 10,
-R_CUBIC_TO, 0, 0.54f, 0.05f, 1.07f, 0.11f, 1.6f,
-CLOSE,
-R_MOVE_TO, 0.66f, 1.6f,
-R_H_LINE_TO, 2.36f,
-R_CUBIC_TO, 0.26f, 1, 0.62f, 1.96f, 1.1f, 2.85f,
-R_CUBIC_TO, -1.47f, -0.5f, -2.7f, -1.52f, -3.46f, -2.85f,
-CLOSE,
-R_MOVE_TO, 2.36f, -6.4f,
-R_H_LINE_TO, -2.36f,
-R_CUBIC_TO, 0.77f, -1.33f, 1.99f, -2.34f, 3.46f, -2.85f,
-CUBIC_TO, 7.45f, 4.84f, 7.08f, 5.8f, 6.82f, 6.8f,
-CLOSE,
-MOVE_TO, 10, 16.37f,
-R_CUBIC_TO, -0.66f, -0.96f, -1.18f, -2.02f, -1.53f, -3.17f,
-R_H_LINE_TO, 3.06f,
-R_CUBIC_TO, -0.34f, 1.14f, -0.86f, 2.21f, -1.53f, 3.17f,
-CLOSE,
-R_MOVE_TO, 1.87f, -4.77f,
-H_LINE_TO, 8.13f,
-CUBIC_TO, 8.06f, 11.07f, 8, 10.54f, 8, 10,
-R_CUBIC_TO, 0, -0.54f, 0.06f, -1.08f, 0.13f, -1.6f,
-R_H_LINE_TO, 3.74f,
-R_CUBIC_TO, 0.07f, 0.52f, 0.13f, 1.06f, 0.13f, 1.6f,
-R_CUBIC_TO, 0, 0.54f, -0.06f, 1.07f, -0.13f, 1.6f,
-CLOSE,
-R_MOVE_TO, 0.2f, 4.45f,
-R_CUBIC_TO, 0.48f, -0.89f, 0.85f, -1.85f, 1.1f, -2.85f,
-R_H_LINE_TO, 2.36f,
-R_CUBIC_TO, -0.77f, 1.32f, -1.99f, 2.34f, -3.46f, 2.85f,
-CLOSE,
-R_MOVE_TO, 1.42f, -4.45f,
-R_CUBIC_TO, 0.06f, -0.53f, 0.11f, -1.06f, 0.11f, -1.6f,
-R_CUBIC_TO, 0, -0.54f, -0.05f, -1.07f, -0.11f, -1.6f,
-R_H_LINE_TO, 2.7f,
-R_CUBIC_TO, 0.13f, 0.51f, 0.21f, 1.05f, 0.21f, 1.6f,
-R_CUBIC_TO, 0, 0.55f, -0.08f, 1.09f, -0.21f, 1.6f,
+CANVAS_DIMENSIONS, 24,
+MOVE_TO, 11.99f, 2,
+CUBIC_TO, 6.47f, 2, 2, 6.48f, 2, 12,
+R_CUBIC_TO, 0, 5.52f, 4.47f, 10, 9.99f, 10,
+CUBIC_TO, 17.52f, 22, 22, 17.52f, 22, 12,
+CUBIC_TO_SHORTHAND, 17.52f, 2, 11.99f, 2,
+CLOSE,
+R_MOVE_TO, 6.93f, 6,
+R_H_LINE_TO, -2.95f,
+R_CUBIC_TO, -0.32f, -1.25f, -0.78f, -2.45f, -1.38f, -3.56f,
+R_CUBIC_TO, 1.84f, 0.63f, 3.37f, 1.91f, 4.33f, 3.56f,
+CLOSE,
+MOVE_TO, 12, 4.04f,
+R_CUBIC_TO, 0.83f, 1.2f, 1.48f, 2.53f, 1.91f, 3.96f,
+R_H_LINE_TO, -3.82f,
+R_CUBIC_TO, 0.43f, -1.43f, 1.08f, -2.76f, 1.91f, -3.96f,
+CLOSE,
+MOVE_TO, 4.26f, 14,
+CUBIC_TO, 4.1f, 13.36f, 4, 12.69f, 4, 12,
+R_CUBIC_TO, 0, -0.69f, 0.1f, -1.36f, 0.26f, -2,
+R_H_LINE_TO, 3.38f,
+R_CUBIC_TO, -0.08f, 0.66f, -0.14f, 1.32f, -0.14f, 2,
+R_CUBIC_TO, 0, 0.68f, 0.06f, 1.34f, 0.14f, 2,
+H_LINE_TO, 4.26f,
+CLOSE,
+R_MOVE_TO, 0.82f, 2,
+R_H_LINE_TO, 2.95f,
+R_CUBIC_TO, 0.32f, 1.25f, 0.78f, 2.45f, 1.38f, 3.56f,
+R_CUBIC_TO, -1.84f, -0.63f, -3.37f, -1.9f, -4.33f, -3.56f,
+CLOSE,
+R_MOVE_TO, 2.95f, -8,
+H_LINE_TO, 5.08f,
+R_CUBIC_TO, 0.96f, -1.66f, 2.49f, -2.93f, 4.33f, -3.56f,
+CUBIC_TO, 8.81f, 5.55f, 8.35f, 6.75f, 8.03f, 8,
+CLOSE,
+MOVE_TO, 12, 19.96f,
+R_CUBIC_TO, -0.83f, -1.2f, -1.48f, -2.53f, -1.91f, -3.96f,
+R_H_LINE_TO, 3.82f,
+R_CUBIC_TO, -0.43f, 1.43f, -1.08f, 2.76f, -1.91f, 3.96f,
+CLOSE,
+MOVE_TO, 14.34f, 14,
+H_LINE_TO, 9.66f,
+R_CUBIC_TO, -0.09f, -0.66f, -0.16f, -1.32f, -0.16f, -2,
+R_CUBIC_TO, 0, -0.68f, 0.07f, -1.35f, 0.16f, -2,
+R_H_LINE_TO, 4.68f,
+R_CUBIC_TO, 0.09f, 0.65f, 0.16f, 1.32f, 0.16f, 2,
+R_CUBIC_TO, 0, 0.68f, -0.07f, 1.34f, -0.16f, 2,
+CLOSE,
+R_MOVE_TO, 0.25f, 5.56f,
+R_CUBIC_TO, 0.6f, -1.11f, 1.06f, -2.31f, 1.38f, -3.56f,
+R_H_LINE_TO, 2.95f,
+R_CUBIC_TO, -0.96f, 1.65f, -2.49f, 2.93f, -4.33f, 3.56f,
+CLOSE,
+MOVE_TO, 16.36f, 14,
+R_CUBIC_TO, 0.08f, -0.66f, 0.14f, -1.32f, 0.14f, -2,
+R_CUBIC_TO, 0, -0.68f, -0.06f, -1.34f, -0.14f, -2,
+R_H_LINE_TO, 3.38f,
+R_CUBIC_TO, 0.16f, 0.64f, 0.26f, 1.31f, 0.26f, 2,
+R_CUBIC_TO, 0, 0.69f, -0.1f, 1.36f, -0.26f, 2,
+R_H_LINE_TO, -3.38f,
 CLOSE
--- a/ash/root_window_controller.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/root_window_controller.cc	2019-05-17 18:53:08.236000000 +0300
@@ -57,7 +57,6 @@
 #include "ash/wm/window_util.h"
 #include "ash/wm/workspace/workspace_layout_manager.h"
 #include "ash/wm/workspace_controller.h"
-#include "base/bind.h"
 #include "base/command_line.h"
 #include "base/metrics/histogram_macros.h"
 #include "base/stl_util.h"
@@ -200,7 +199,6 @@
   const int kContainerIdsToMove[] = {
       kShellWindowId_DefaultContainer,
       kShellWindowId_AlwaysOnTopContainer,
-      kShellWindowId_PipContainer,
       kShellWindowId_SystemModalContainer,
       kShellWindowId_LockSystemModalContainer,
       kShellWindowId_UnparentedControlContainer,
@@ -775,11 +773,9 @@
 
   aura::Window* always_on_top_container =
       GetContainer(kShellWindowId_AlwaysOnTopContainer);
-  aura::Window* pip_container = GetContainer(kShellWindowId_PipContainer);
   DCHECK(always_on_top_container);
-  DCHECK(pip_container);
-  always_on_top_controller_ = std::make_unique<AlwaysOnTopController>(
-      always_on_top_container, pip_container);
+  always_on_top_controller_ =
+      std::make_unique<AlwaysOnTopController>(always_on_top_container);
 
   wm::WmSnapToPixelLayoutManager::InstallOnContainers(root);
 
@@ -867,12 +863,6 @@
   wm::SetSnapsChildrenToPhysicalPixelBoundary(app_list_container);
   app_list_container->SetProperty(::wm::kUsesScreenCoordinatesKey, true);
 
-  aura::Window* pip_container = CreateContainer(
-      kShellWindowId_PipContainer, "PipContainer", non_lock_screen_containers);
-  ::wm::SetChildWindowVisibilityChangesAnimated(pip_container);
-  wm::SetSnapsChildrenToPhysicalPixelBoundary(pip_container);
-  pip_container->SetProperty(::wm::kUsesScreenCoordinatesKey, true);
-
   aura::Window* arc_ime_parent_container = CreateContainer(
       kShellWindowId_ArcImeWindowParentContainer, "ArcImeWindowParentContainer",
       non_lock_screen_containers);
@@ -1010,9 +1000,6 @@
                       "MouseCursorContainer", screen_rotation_container);
   mouse_cursor_container->SetProperty(::wm::kUsesScreenCoordinatesKey, true);
 
-  CreateContainer(kShellWindowId_AlwaysOnTopWallpaperContainer,
-                  "AlwaysOnTopWallpaperContainer", screen_rotation_container);
-
   CreateContainer(kShellWindowId_PowerButtonAnimationContainer,
                   "PowerButtonAnimationContainer", screen_rotation_container);
 }
--- a/ash/root_window_settings.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/root_window_settings.cc	2019-05-17 18:53:08.236000000 +0300
@@ -9,13 +9,13 @@
 #include "ui/base/class_property.h"
 #include "ui/display/types/display_constants.h"
 
-DEFINE_UI_CLASS_PROPERTY_TYPE(ash::RootWindowSettings*)
+DEFINE_UI_CLASS_PROPERTY_TYPE(ash::RootWindowSettings*);
 
 namespace ash {
 
 DEFINE_OWNED_UI_CLASS_PROPERTY_KEY(RootWindowSettings,
                                    kRootWindowSettingsKey,
-                                   NULL)
+                                   NULL);
 
 RootWindowSettings::RootWindowSettings()
     : display_id(display::kInvalidDisplayId), controller(NULL) {}
--- a/ash/rotator/screen_rotation_animator.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/rotator/screen_rotation_animator.cc	2019-05-17 18:53:08.236000000 +0300
@@ -12,7 +12,6 @@
 #include "ash/rotator/screen_rotation_animator_observer.h"
 #include "ash/shell.h"
 #include "ash/utility/transformer_util.h"
-#include "base/bind.h"
 #include "base/command_line.h"
 #include "base/metrics/histogram_macros.h"
 #include "base/time/time.h"
@@ -20,7 +19,6 @@
 #include "components/viz/common/frame_sinks/copy_output_result.h"
 #include "third_party/khronos/GLES2/gl2.h"
 #include "ui/aura/window.h"
-#include "ui/base/class_property.h"
 #include "ui/compositor/callback_layer_animation_observer.h"
 #include "ui/compositor/layer.h"
 #include "ui/compositor/layer_animation_element.h"
@@ -28,7 +26,6 @@
 #include "ui/compositor/layer_animator.h"
 #include "ui/compositor/layer_owner.h"
 #include "ui/compositor/layer_tree_owner.h"
-#include "ui/compositor/scoped_animation_duration_scale_mode.h"
 #include "ui/display/display.h"
 #include "ui/display/manager/display_manager.h"
 #include "ui/display/manager/managed_display_info.h"
@@ -41,8 +38,6 @@
 #include "ui/gfx/transform_util.h"
 #include "ui/wm/core/window_util.h"
 
-DEFINE_UI_CLASS_PROPERTY_TYPE(ash::ScreenRotationAnimator*)
-
 namespace ash {
 
 namespace {
@@ -57,12 +52,6 @@
 const int kCounterClockWiseRotationFactor = 1;
 const int kClockWiseRotationFactor = -1;
 
-// A property key to store the ScreenRotationAnimator of the window; Used for
-// screen rotation.
-DEFINE_OWNED_UI_CLASS_PROPERTY_KEY(ScreenRotationAnimator,
-                                   kScreenRotationAnimatorKey,
-                                   nullptr)
-
 display::Display::Rotation GetCurrentScreenRotation(int64_t display_id) {
   return Shell::Get()
       ->display_manager()
@@ -170,24 +159,6 @@
 
 }  // namespace
 
-// static
-ScreenRotationAnimator* ScreenRotationAnimator::GetForRootWindow(
-    aura::Window* root_window) {
-  auto* animator = root_window->GetProperty(kScreenRotationAnimatorKey);
-  if (!animator) {
-    animator = new ScreenRotationAnimator(root_window);
-    root_window->SetProperty(kScreenRotationAnimatorKey, animator);
-  }
-  return animator;
-}
-
-// static
-void ScreenRotationAnimator::SetScreenRotationAnimatorForTest(
-    aura::Window* root_window,
-    std::unique_ptr<ScreenRotationAnimator> animator) {
-  root_window->SetProperty(kScreenRotationAnimatorKey, animator.release());
-}
-
 ScreenRotationAnimator::ScreenRotationAnimator(aura::Window* root_window)
     : root_window_(root_window),
       screen_rotation_state_(IDLE),
@@ -320,16 +291,6 @@
 
   old_layer_tree_owner_ = CopyLayerTree(std::move(result));
   AddLayerAtTopOfWindowLayers(root_window_, old_layer_tree_owner_->root());
-
-  // TODO(oshima): We need a better way to control animation and other
-  // activities during system wide animation.
-  animation_scale_mode_ =
-      std::make_unique<ui::ScopedAnimationDurationScaleMode>(
-          ui::ScopedAnimationDurationScaleMode::ZERO_DURATION);
-
-  for (auto& observer : screen_rotation_animator_observers_)
-    observer.OnScreenCopiedBeforeRotation();
-
   SetRotation(rotation_request->display_id, rotation_request->old_rotation,
               rotation_request->new_rotation, rotation_request->source);
 
@@ -342,11 +303,8 @@
 void ScreenRotationAnimator::OnScreenRotationContainerLayerCopiedAfterRotation(
     std::unique_ptr<ScreenRotationRequest> rotation_request,
     std::unique_ptr<viz::CopyOutputResult> result) {
-  animation_scale_mode_.reset();
-  if (IgnoreCopyResult(rotation_request->id, rotation_request_id_)) {
-    NotifyAnimationFinished(/*canceled=*/true);
+  if (IgnoreCopyResult(rotation_request->id, rotation_request_id_))
     return;
-  }
   // In the following cases, abort animation:
   // 1) if the display was removed,
   // 2) if the |root_window| was changed for |display_id|,
@@ -528,12 +486,12 @@
   }
 }
 
-void ScreenRotationAnimator::AddObserver(
+void ScreenRotationAnimator::AddScreenRotationAnimatorObserver(
     ScreenRotationAnimatorObserver* observer) {
   screen_rotation_animator_observers_.AddObserver(observer);
 }
 
-void ScreenRotationAnimator::RemoveObserver(
+void ScreenRotationAnimator::RemoveScreenRotationAnimatorObserver(
     ScreenRotationAnimatorObserver* observer) {
   screen_rotation_animator_observers_.RemoveObserver(observer);
 }
@@ -551,7 +509,9 @@
     return;
   }
 
-  NotifyAnimationFinished(/*canceled=*/false);
+  // This is only used in test to notify animator observer.
+  for (auto& observer : screen_rotation_animator_observers_)
+    observer.OnScreenRotationAnimationFinished(this);
 }
 
 bool ScreenRotationAnimator::IsRotating() const {
@@ -572,9 +532,4 @@
   mask_layer_tree_owner_.reset();
 }
 
-void ScreenRotationAnimator::NotifyAnimationFinished(bool canceled) {
-  for (auto& observer : screen_rotation_animator_observers_)
-    observer.OnScreenRotationAnimationFinished(this, canceled);
-}
-
 }  // namespace ash
--- a/ash/rotator/screen_rotation_animator.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/rotator/screen_rotation_animator.h	2019-05-17 18:53:08.236000000 +0300
@@ -6,7 +6,6 @@
 #define ASH_ROTATOR_SCREEN_ROTATION_ANIMATOR_H_
 
 #include <stdint.h>
-#include <memory>
 
 #include "ash/ash_export.h"
 #include "ash/display/display_configuration_controller.h"
@@ -29,7 +28,6 @@
 namespace ui {
 class AnimationMetricsReporter;
 class LayerTreeOwner;
-class ScopedAnimationDurationScaleMode;
 }  // namespace ui
 
 namespace ash {
@@ -33,13 +31,12 @@
 }  // namespace ui
 
 namespace ash {
+
 class ScreenRotationAnimatorObserver;
 
 // Utility to perform a screen rotation with an animation.
 class ASH_EXPORT ScreenRotationAnimator {
  public:
-  static ScreenRotationAnimator* GetForRootWindow(aura::Window* root_window);
-
   explicit ScreenRotationAnimator(aura::Window* root_window);
   virtual ~ScreenRotationAnimator();
 
@@ -54,8 +51,10 @@
               display::Display::RotationSource source,
               DisplayConfigurationController::RotationAnimation mode);
 
-  void AddObserver(ScreenRotationAnimatorObserver* observer);
-  void RemoveObserver(ScreenRotationAnimatorObserver* observer);
+  void AddScreenRotationAnimatorObserver(
+      ScreenRotationAnimatorObserver* observer);
+  void RemoveScreenRotationAnimatorObserver(
+      ScreenRotationAnimatorObserver* observer);
 
   // When screen rotation animation is ended or aborted, calls |Rotate()| with
   // the pending rotation request if the request queue is not empty. Otherwise
@@ -69,10 +68,6 @@
   // orientation if |IsRotating()| is false.
   display::Display::Rotation GetTargetRotation() const;
 
-  static void SetScreenRotationAnimatorForTest(
-      aura::Window* root_window,
-      std::unique_ptr<ScreenRotationAnimator> animator);
-
  protected:
   using CopyCallback =
       base::OnceCallback<void(std::unique_ptr<viz::CopyOutputResult> result)>;
@@ -161,8 +156,6 @@
   // |rotation_degrees| arc.
   void AnimateRotation(std::unique_ptr<ScreenRotationRequest> rotation_request);
 
-  void NotifyAnimationFinished(bool canceled);
-
   void set_disable_animation_timers_for_test(bool disable_timers) {
     disable_animation_timers_for_test_ = disable_timers;
   }
@@ -196,7 +189,6 @@
   std::unique_ptr<ScreenRotationRequest> last_pending_request_;
   base::Optional<ScreenRotationRequest> current_async_rotation_request_;
   display::Display::Rotation target_rotation_ = display::Display::ROTATE_0;
-  std::unique_ptr<ui::ScopedAnimationDurationScaleMode> animation_scale_mode_;
   base::WeakPtrFactory<ScreenRotationAnimator> weak_factory_;
 
   DISALLOW_COPY_AND_ASSIGN(ScreenRotationAnimator);
--- a/ash/rotator/screen_rotation_animator_observer.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/rotator/screen_rotation_animator_observer.h	2019-05-17 18:53:08.236000000 +0300
@@ -15,13 +15,9 @@
  public:
   ScreenRotationAnimatorObserver() {}
 
-  // This will be called when the screen is copied before rotation.
-  virtual void OnScreenCopiedBeforeRotation() = 0;
-
   // This will be called when the animation is ended or aborted.
   virtual void OnScreenRotationAnimationFinished(
-      ScreenRotationAnimator* animator,
-      bool canceled) = 0;
+      ScreenRotationAnimator* animator) = 0;
 
  protected:
   virtual ~ScreenRotationAnimatorObserver() {}
--- a/ash/rotator/screen_rotation_animator_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/rotator/screen_rotation_animator_unittest.cc	2019-05-17 18:53:08.236000000 +0300
@@ -20,7 +20,6 @@
 #include "ash/test/ash_test_base.h"
 #include "ash/test/ash_test_helper.h"
 #include "ash/wm/tablet_mode/tablet_mode_controller.h"
-#include "base/bind.h"
 #include "base/callback_forward.h"
 #include "base/command_line.h"
 #include "base/run_loop.h"
@@ -60,18 +59,15 @@
  public:
   AnimationObserver() = default;
 
-  bool copy_notified() const { return copy_notified_; }
-  bool finish_notified() const { return finish_notified_; }
+  bool notified() const { return notified_; }
 
-  void OnScreenCopiedBeforeRotation() override { copy_notified_ = true; }
-  void OnScreenRotationAnimationFinished(ScreenRotationAnimator* animator,
-                                         bool canceled) override {
-    finish_notified_ = true;
+  void OnScreenRotationAnimationFinished(
+      ScreenRotationAnimator* animator) override {
+    notified_ = true;
   }
 
  private:
-  bool copy_notified_ = false;
-  bool finish_notified_ = false;
+  bool notified_ = false;
 
   DISALLOW_COPY_AND_ASSIGN(AnimationObserver);
 };
@@ -230,7 +226,7 @@
 }
 
 void ScreenRotationAnimatorSmoothAnimationTest::QuitWaitForCopyCallback() {
-  run_loop_->Quit();
+  run_loop_->QuitWhenIdle();
 }
 
 void ScreenRotationAnimatorSmoothAnimationTest::SetUp() {
@@ -264,46 +260,40 @@
 TEST_F(ScreenRotationAnimatorSlowAnimationTest, ShouldNotifyObserver) {
   SetDisplayRotation(display_id(), display::Display::ROTATE_0);
   AnimationObserver observer;
-  animator()->AddObserver(&observer);
-  EXPECT_FALSE(observer.copy_notified());
-  EXPECT_FALSE(observer.finish_notified());
+  animator()->AddScreenRotationAnimatorObserver(&observer);
+  EXPECT_FALSE(observer.notified());
 
   animator()->Rotate(display::Display::ROTATE_90,
                      display::Display::RotationSource::USER,
                      DisplayConfigurationController::ANIMATION_SYNC);
-  EXPECT_FALSE(observer.copy_notified());
-  EXPECT_FALSE(observer.finish_notified());
+  EXPECT_FALSE(observer.notified());
 
   test_api()->CompleteAnimations();
-  EXPECT_FALSE(observer.copy_notified());
-  EXPECT_TRUE(observer.finish_notified());
+  EXPECT_TRUE(observer.notified());
   EXPECT_FALSE(test_api()->HasActiveAnimations());
-  animator()->RemoveObserver(&observer);
+  animator()->RemoveScreenRotationAnimatorObserver(&observer);
 }
 
 TEST_F(ScreenRotationAnimatorSlowAnimationTest, ShouldNotifyObserverOnce) {
   SetDisplayRotation(display_id(), display::Display::ROTATE_0);
   AnimationObserver observer;
-  animator()->AddObserver(&observer);
-  EXPECT_FALSE(observer.copy_notified());
-  EXPECT_FALSE(observer.finish_notified());
+  animator()->AddScreenRotationAnimatorObserver(&observer);
+  EXPECT_FALSE(observer.notified());
 
   animator()->Rotate(display::Display::ROTATE_90,
                      display::Display::RotationSource::USER,
                      DisplayConfigurationController::ANIMATION_SYNC);
-  EXPECT_FALSE(observer.copy_notified());
-  EXPECT_FALSE(observer.finish_notified());
+  EXPECT_FALSE(observer.notified());
 
   animator()->Rotate(display::Display::ROTATE_180,
                      display::Display::RotationSource::USER,
                      DisplayConfigurationController::ANIMATION_SYNC);
-  EXPECT_FALSE(observer.finish_notified());
+  EXPECT_FALSE(observer.notified());
 
   test_api()->CompleteAnimations();
-  EXPECT_FALSE(observer.copy_notified());
-  EXPECT_TRUE(observer.finish_notified());
+  EXPECT_TRUE(observer.notified());
   EXPECT_FALSE(test_api()->HasActiveAnimations());
-  animator()->RemoveObserver(&observer);
+  animator()->RemoveScreenRotationAnimatorObserver(&observer);
 }
 
 TEST_F(ScreenRotationAnimatorSlowAnimationTest, RotatesToDifferentRotation) {
@@ -398,42 +388,6 @@
   EXPECT_FALSE(GetTray()->visible());
 }
 
-TEST_F(ScreenRotationAnimatorSmoothAnimationTest, Observer) {
-  const int64_t display_id = display_manager()->GetDisplayAt(0).id();
-
-  SetScreenRotationAnimator(
-      Shell::GetRootWindowForDisplayId(display_id),
-      base::BindRepeating(
-          &ScreenRotationAnimatorSmoothAnimationTest::QuitWaitForCopyCallback,
-          base::Unretained(this)),
-      base::BindRepeating(
-          &ScreenRotationAnimatorSmoothAnimationTest::QuitWaitForCopyCallback,
-          base::Unretained(this)));
-  AnimationObserver observer;
-  animator()->AddObserver(&observer);
-  EXPECT_FALSE(observer.copy_notified());
-  EXPECT_FALSE(observer.finish_notified());
-
-  SetDisplayRotation(display_id, display::Display::ROTATE_0);
-  animator()->Rotate(display::Display::ROTATE_90,
-                     display::Display::RotationSource::USER,
-                     DisplayConfigurationController::ANIMATION_ASYNC);
-  EXPECT_TRUE(animator()->IsRotating());
-  WaitForCopyCallback();
-  EXPECT_TRUE(observer.copy_notified());
-  EXPECT_FALSE(observer.finish_notified());
-
-  WaitForCopyCallback();
-
-  EXPECT_TRUE(observer.copy_notified());
-  EXPECT_FALSE(observer.finish_notified());
-  test_api()->CompleteAnimations();
-  EXPECT_FALSE(test_api()->HasActiveAnimations());
-  EXPECT_EQ(display::Display::ROTATE_90, GetDisplayRotation(display_id));
-  EXPECT_TRUE(observer.copy_notified());
-  EXPECT_TRUE(observer.finish_notified());
-}
-
 // Test enable smooth screen rotation code path.
 TEST_F(ScreenRotationAnimatorSmoothAnimationTest,
        RotatesToDifferentRotationWithCopyCallback) {
@@ -444,11 +398,6 @@
       base::Bind(
           &ScreenRotationAnimatorSmoothAnimationTest::QuitWaitForCopyCallback,
           base::Unretained(this)));
-  AnimationObserver observer;
-  animator()->AddObserver(&observer);
-  EXPECT_FALSE(observer.copy_notified());
-  EXPECT_FALSE(observer.finish_notified());
-
   SetDisplayRotation(display_id, display::Display::ROTATE_0);
   animator()->Rotate(display::Display::ROTATE_90,
                      display::Display::RotationSource::USER,
@@ -457,14 +406,9 @@
 
   EXPECT_EQ(display::Display::ROTATE_90, animator()->GetTargetRotation());
   EXPECT_NE(display::Display::ROTATE_90, GetDisplayRotation(display_id));
-  EXPECT_FALSE(observer.copy_notified());
-  EXPECT_FALSE(observer.finish_notified());
 
   WaitForCopyCallback();
   EXPECT_TRUE(test_api()->HasActiveAnimations());
-  EXPECT_TRUE(observer.copy_notified());
-  EXPECT_FALSE(observer.finish_notified());
-
   EXPECT_EQ(display::Display::ROTATE_90, animator()->GetTargetRotation());
   // Once copy is made, the rotation is set to the target, with the
   // image that was rotated to the original orientation.
@@ -473,8 +417,6 @@
   test_api()->CompleteAnimations();
   EXPECT_FALSE(test_api()->HasActiveAnimations());
   EXPECT_EQ(display::Display::ROTATE_90, GetDisplayRotation(display_id));
-  EXPECT_TRUE(observer.copy_notified());
-  EXPECT_TRUE(observer.finish_notified());
 }
 
 // If the rotating external secondary display is removed before the first copy
--- a/ash/screen_util.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/screen_util.cc	2019-05-17 18:53:08.236000000 +0300
@@ -10,7 +10,6 @@
 #include "ash/public/cpp/shell_window_ids.h"
 #include "ash/root_window_controller.h"
 #include "ash/shelf/shelf.h"
-#include "ash/shelf/shelf_layout_manager.h"
 #include "ash/shell.h"
 #include "base/logging.h"
 #include "ui/aura/client/screen_position_client.h"
@@ -39,22 +38,6 @@
   return result;
 }
 
-gfx::Rect GetFullscreenWindowBoundsInParent(aura::Window* window) {
-  gfx::Rect result = GetDisplayBoundsInParent(window);
-
-  Shelf* shelf = Shelf::ForWindow(window);
-  ShelfLayoutManager* shelf_layout_manager =
-      shelf ? shelf->shelf_layout_manager() : nullptr;
-  if (shelf_layout_manager) {
-    result.Inset(0,
-                 shelf_layout_manager->accessibility_panel_height() +
-                     shelf_layout_manager->docked_magnifier_height(),
-                 0, 0);
-  }
-
-  return result;
-}
-
 gfx::Rect GetDisplayWorkAreaBoundsInParent(aura::Window* window) {
   gfx::Rect result =
       display::Screen::GetScreen()->GetDisplayNearestWindow(window).work_area();
--- a/ash/screen_util.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/screen_util.h	2019-05-17 18:53:08.236000000 +0300
@@ -26,11 +26,6 @@
 // Returns the display bounds in parent coordinates.
 ASH_EXPORT gfx::Rect GetDisplayBoundsInParent(aura::Window* window);
 
-// Returns the bounds of fullscreened windows in the parent coordinates of
-// |window| taking into account the height of the Docked Magnifier and Chromevox
-// panel (if they are enabled).
-ASH_EXPORT gfx::Rect GetFullscreenWindowBoundsInParent(aura::Window* window);
-
 // Returns the display's work area bounds in parent coordinates.
 ASH_EXPORT gfx::Rect GetDisplayWorkAreaBoundsInParent(aura::Window* window);
 
--- a/ash/screen_util_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/screen_util_unittest.cc	2019-05-17 18:53:08.236000000 +0300
@@ -4,16 +4,12 @@
 
 #include "ash/screen_util.h"
 
-#include <memory>
-
-#include "ash/magnifier/docked_magnifier_controller.h"
 #include "ash/root_window_controller.h"
 #include "ash/shelf/shelf.h"
 #include "ash/shelf/shelf_constants.h"
 #include "ash/shell.h"
 #include "ash/test/ash_test_base.h"
 #include "ash/wm/window_util.h"
-#include "ash/wm/wm_event.h"
 #include "ui/aura/env.h"
 #include "ui/aura/window.h"
 #include "ui/aura/window_event_dispatcher.h"
@@ -224,29 +220,4 @@
   EXPECT_EQ(snapped_bounds, gfx::Rect(0, 552, 800, 48));
 }
 
-// Tests that making a window fullscreen while the Docked Magnifier is enabled
-// won't make its bounds occupy the entire screen bounds, but will take into
-// account the Docked Magnifier height.
-TEST_F(ScreenUtilTest, FullscreenWindowBoundsWithDockedMagnifier) {
-  UpdateDisplay("1366x768");
-
-  std::unique_ptr<aura::Window> window = CreateToplevelTestWindow(
-      gfx::Rect(300, 300, 200, 150), kShellWindowId_DefaultContainer);
-
-  auto* docked_magnifier_controller =
-      Shell::Get()->docked_magnifier_controller();
-  docked_magnifier_controller->SetEnabled(true);
-
-  const wm::WMEvent event(wm::WM_EVENT_TOGGLE_FULLSCREEN);
-  wm::GetWindowState(window.get())->OnWMEvent(&event);
-
-  constexpr gfx::Rect kDisplayBounds{1366, 768};
-  EXPECT_NE(window->bounds(), kDisplayBounds);
-
-  gfx::Rect expected_bounds = kDisplayBounds;
-  expected_bounds.Inset(
-      0, docked_magnifier_controller->GetTotalMagnifierHeight(), 0, 0);
-  EXPECT_EQ(expected_bounds, window->bounds());
-}
-
 }  // namespace ash
--- a/ash/session/session_controller_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/session/session_controller_unittest.cc	2019-05-17 18:53:08.236000000 +0300
@@ -18,7 +18,6 @@
 #include "ash/test/ash_test_base.h"
 #include "ash/wm/overview/overview_controller.h"
 #include "ash/wm/window_util.h"
-#include "base/bind.h"
 #include "base/callback.h"
 #include "base/macros.h"
 #include "base/run_loop.h"
--- a/ash/shelf/app_list_button.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/shelf/app_list_button.cc	2019-05-17 18:53:08.240000000 +0300
@@ -24,7 +24,6 @@
 #include "ash/system/tray/tray_popup_utils.h"
 #include "ash/voice_interaction/voice_interaction_controller.h"
 #include "ash/wm/tablet_mode/tablet_mode_controller.h"
-#include "base/bind.h"
 #include "base/command_line.h"
 #include "base/metrics/histogram_macros.h"
 #include "base/metrics/user_metrics.h"
@@ -60,15 +59,11 @@
 
 }  // namespace
 
-// static
-const char AppListButton::kViewClassName[] = "ash/AppListButton";
-
 AppListButton::AppListButton(ShelfView* shelf_view, Shelf* shelf)
     : ShelfControlButton(shelf_view), shelf_(shelf) {
   DCHECK(shelf_);
   Shell::Get()->app_list_controller()->AddObserver(this);
   Shell::Get()->session_controller()->AddObserver(this);
-  Shell::Get()->tablet_mode_controller()->AddObserver(this);
 
   Shell::Get()->voice_interaction_controller()->AddLocalObserver(this);
   SetAccessibleName(
@@ -86,12 +81,10 @@
 }
 
 AppListButton::~AppListButton() {
-  // AppListController and TabletModeController are destroyed early when Shell
-  // is being destroyed, they may not exist.
+  // AppListController is destroyed early when Shell is being destroyed, it may
+  // not exist.
   if (Shell::Get()->app_list_controller())
     Shell::Get()->app_list_controller()->RemoveObserver(this);
-  if (Shell::Get()->tablet_mode_controller())
-    Shell::Get()->tablet_mode_controller()->RemoveObserver(this);
   Shell::Get()->session_controller()->RemoveObserver(this);
   Shell::Get()->voice_interaction_controller()->RemoveLocalObserver(this);
 }
@@ -148,7 +141,7 @@
       // If assistant overlay animation starts, we need to make sure the event
       // is handled in order to end the animation in |ET_GESTURE_TAP| or
       // |ET_GESTURE_TAP_CANCEL|.
-      DCHECK(event->handled());
+      DCHECK(event->stopped_propagation());
       return;
     case ui::ET_GESTURE_LONG_PRESS:
       if (UseVoiceInteractionStyle()) {
@@ -181,10 +174,6 @@
   }
 }
 
-const char* AppListButton::GetClassName() const {
-  return kViewClassName;
-}
-
 std::unique_ptr<views::InkDropRipple> AppListButton::CreateInkDropRipple()
     const {
   const int app_list_button_radius = ShelfConstants::control_border_radius();
@@ -302,8 +291,7 @@
   SchedulePaint();
 }
 
-void AppListButton::OnVoiceInteractionConsentStatusUpdated(
-    mojom::ConsentStatus consent_status) {
+void AppListButton::OnVoiceInteractionSetupCompleted(bool completed) {
   SchedulePaint();
 }
 
@@ -317,10 +305,6 @@
   }
 }
 
-void AppListButton::OnTabletModeStarted() {
-  AnimateInkDrop(views::InkDropState::DEACTIVATED, nullptr);
-}
-
 void AppListButton::StartVoiceInteractionAnimation() {
   assistant_overlay_->StartAnimation(false);
 }
@@ -329,14 +313,11 @@
   VoiceInteractionController* controller =
       Shell::Get()->voice_interaction_controller();
   bool settings_enabled = controller->settings_enabled().value_or(false);
-
-  const bool consent_given = controller->consent_status() ==
-                             mojom::ConsentStatus::kActivityControlAccepted;
-
+  bool setup_completed = controller->setup_completed().value_or(false);
   bool is_feature_allowed =
       controller->allowed_state() == mojom::AssistantAllowedState::ALLOWED;
   if (assistant_overlay_ && is_feature_allowed &&
-      (settings_enabled || !consent_given)) {
+      (settings_enabled || !setup_completed)) {
     return true;
   }
   return false;
--- a/ash/shelf/app_list_button.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/shelf/app_list_button.h	2019-05-17 18:53:08.240000000 +0300
@@ -13,7 +13,6 @@
 #include "ash/public/interfaces/voice_interaction_controller.mojom.h"
 #include "ash/session/session_observer.h"
 #include "ash/shelf/shelf_control_button.h"
-#include "ash/wm/tablet_mode/tablet_mode_observer.h"
 #include "base/macros.h"
 #include "third_party/skia/include/core/SkColor.h"
 
@@ -31,11 +30,8 @@
 class ASH_EXPORT AppListButton : public ShelfControlButton,
                                  public AppListControllerObserver,
                                  public SessionObserver,
-                                 public TabletModeObserver,
                                  public DefaultVoiceInteractionObserver {
  public:
-  static const char kViewClassName[];
-
   AppListButton(ShelfView* shelf_view, Shelf* shelf);
   ~AppListButton() override;
 
@@ -46,7 +42,6 @@
 
   // views::Button:
   void OnGestureEvent(ui::GestureEvent* event) override;
-  const char* GetClassName() const override;
 
  protected:
   // views::Button:
@@ -61,15 +56,11 @@
   void OnVoiceInteractionStatusChanged(
       mojom::VoiceInteractionState state) override;
   void OnVoiceInteractionSettingsEnabled(bool enabled) override;
-  void OnVoiceInteractionConsentStatusUpdated(
-      mojom::ConsentStatus consent_status) override;
+  void OnVoiceInteractionSetupCompleted(bool completed) override;
 
   // SessionObserver:
   void OnActiveUserSessionChanged(const AccountId& account_id) override;
 
-  // TabletModeObserver:
-  void OnTabletModeStarted() override;
-
   void StartVoiceInteractionAnimation();
 
   // Whether the voice interaction style should be used.
--- a/ash/shelf/app_list_button_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/shelf/app_list_button_unittest.cc	2019-05-17 18:53:08.240000000 +0300
@@ -8,7 +8,6 @@
 #include <string>
 
 #include "ash/app_list/test/app_list_test_helper.h"
-#include "ash/app_list/views/app_list_view.h"
 #include "ash/assistant/assistant_controller.h"
 #include "ash/assistant/assistant_ui_controller.h"
 #include "ash/assistant/model/assistant_ui_model.h"
@@ -16,6 +15,7 @@
 #include "ash/root_window_controller.h"
 #include "ash/session/session_controller.h"
 #include "ash/shelf/shelf.h"
+#include "ash/shelf/shelf_layout_manager.h"
 #include "ash/shelf/shelf_view.h"
 #include "ash/shelf/shelf_view_test_api.h"
 #include "ash/shell.h"
@@ -79,7 +79,7 @@
   // Swiping up less than the threshold should trigger a peeking app list.
   gfx::Point end = start;
   end.set_y(shelf->GetIdealBounds().bottom() -
-            app_list::AppListView::kDragSnapToPeekingThreshold + 10);
+            ShelfLayoutManager::kAppListDragSnapToPeekingThreshold + 10);
   GetEventGenerator()->GestureScrollSequence(
       start, end, base::TimeDelta::FromMilliseconds(100), 4 /* steps */);
   GetAppListTestHelper()->WaitUntilIdle();
@@ -93,7 +93,7 @@
 
   // Swiping above the threshold should trigger a fullscreen app list.
   end.set_y(shelf->GetIdealBounds().bottom() -
-            app_list::AppListView::kDragSnapToPeekingThreshold - 10);
+            ShelfLayoutManager::kAppListDragSnapToPeekingThreshold - 10);
   GetEventGenerator()->GestureScrollSequence(
       start, end, base::TimeDelta::FromMilliseconds(100), 4 /* steps */);
   base::RunLoop().RunUntilIdle();
@@ -103,42 +103,6 @@
       app_list::AppListViewState::FULLSCREEN_ALL_APPS);
 }
 
-TEST_F(AppListButtonTest, ClickToOpenAppList) {
-  Shelf* shelf = GetPrimaryShelf();
-  EXPECT_EQ(SHELF_ALIGNMENT_BOTTOM, shelf->alignment());
-
-  gfx::Point center = app_list_button()->GetCenterPoint();
-  views::View::ConvertPointToScreen(app_list_button(), &center);
-  GetEventGenerator()->MoveMouseTo(center);
-
-  // Click on the app list button should toggle the app list.
-  GetEventGenerator()->ClickLeftButton();
-  GetAppListTestHelper()->WaitUntilIdle();
-  GetAppListTestHelper()->CheckVisibility(true);
-  GetAppListTestHelper()->CheckState(app_list::AppListViewState::PEEKING);
-  GetEventGenerator()->ClickLeftButton();
-  GetAppListTestHelper()->WaitUntilIdle();
-  GetAppListTestHelper()->CheckVisibility(false);
-  GetAppListTestHelper()->CheckState(app_list::AppListViewState::CLOSED);
-
-  // Shift-click should open the app list in fullscreen.
-  GetEventGenerator()->set_flags(ui::EF_SHIFT_DOWN);
-  GetEventGenerator()->ClickLeftButton();
-  GetEventGenerator()->set_flags(0);
-  GetAppListTestHelper()->WaitUntilIdle();
-  GetAppListTestHelper()->CheckVisibility(true);
-  GetAppListTestHelper()->CheckState(
-      app_list::AppListViewState::FULLSCREEN_ALL_APPS);
-
-  // Another shift-click should close the app list.
-  GetEventGenerator()->set_flags(ui::EF_SHIFT_DOWN);
-  GetEventGenerator()->ClickLeftButton();
-  GetEventGenerator()->set_flags(0);
-  GetAppListTestHelper()->WaitUntilIdle();
-  GetAppListTestHelper()->CheckVisibility(false);
-  GetAppListTestHelper()->CheckState(app_list::AppListViewState::CLOSED);
-}
-
 TEST_F(AppListButtonTest, ButtonPositionInTabletMode) {
   // Finish all setup tasks. In particular we want to finish the
   // GetSwitchStates post task in (Fake)PowerManagerClient which is triggered
--- a/ash/shelf/app_list_shelf_item_delegate.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/shelf/app_list_shelf_item_delegate.cc	2019-05-17 18:53:08.240000000 +0300
@@ -24,10 +24,7 @@
                                             ItemSelectedCallback callback) {
   std::move(callback).Run(
       Shell::Get()->app_list_controller()->OnAppListButtonPressed(
-          display_id,
-          event->IsShiftDown() ? app_list::kShelfButtonFullscreen
-                               : app_list::kShelfButton,
-          event->time_stamp()),
+          display_id, app_list::kShelfButton, event->time_stamp()),
       base::nullopt);
 }
 
--- a/ash/shelf/app_list_shelf_item_delegate_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/shelf/app_list_shelf_item_delegate_unittest.cc	2019-05-17 18:53:08.240000000 +0300
@@ -13,7 +13,6 @@
 #include "ash/wm/tablet_mode/tablet_mode_controller.h"
 #include "ash/wm/window_state.h"
 #include "ash/wm/window_util.h"
-#include "base/bind.h"
 #include "base/macros.h"
 
 namespace ash {
@@ -51,7 +50,7 @@
       ui::EventType::ET_MOUSE_PRESSED, ui::VKEY_UNKNOWN, ui::EF_NONE);
   delegate()->ItemSelected(
       std::move(test_event), GetPrimaryDisplay().id(),
-      ShelfLaunchSource::LAUNCH_FROM_SHELF,
+      ShelfLaunchSource::LAUNCH_FROM_UNKNOWN,
       base::BindOnce(
           [](ash::ShelfAction, base::Optional<ash::MenuItemList>) {}));
   ASSERT_TRUE(wm::GetWindowState(w1.get())->IsMinimized());
--- a/ash/shelf/assistant_overlay.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/shelf/assistant_overlay.cc	2019-05-17 18:53:08.240000000 +0300
@@ -278,6 +278,7 @@
       AddPaintLayer(static_cast<PaintedShape>(i));
   }
   ~AssistantIconBackground() override = default;
+  ;
 
   void MoveLargeShadow(const gfx::PointF& new_center) {
     gfx::Transform transform;
--- a/ash/shelf/back_button.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/shelf/back_button.cc	2019-05-17 18:53:08.240000000 +0300
@@ -5,37 +5,51 @@
 #include "ash/shelf/back_button.h"
 
 #include "ash/resources/vector_icons/vector_icons.h"
+#include "ash/shelf/shelf.h"
+#include "ash/shelf/shelf_constants.h"
+#include "ash/shelf/shelf_view.h"
+#include "ash/shell.h"
 #include "ash/strings/grit/ash_strings.h"
+#include "ash/system/tray/tray_popup_utils.h"
+#include "ash/wm/tablet_mode/tablet_mode_controller.h"
+#include "base/metrics/user_metrics.h"
+#include "base/metrics/user_metrics_action.h"
 #include "ui/aura/window.h"
 #include "ui/aura/window_tree_host.h"
 #include "ui/base/l10n/l10n_util.h"
+#include "ui/events/event_sink.h"
 #include "ui/gfx/canvas.h"
 #include "ui/gfx/paint_vector_icon.h"
+#include "ui/views/animation/flood_fill_ink_drop_ripple.h"
+#include "ui/views/animation/ink_drop_impl.h"
+#include "ui/views/animation/ink_drop_mask.h"
 #include "ui/views/widget/widget.h"
 
 namespace ash {
 
-// static
-const char BackButton::kViewClassName[] = "ash/BackButton";
-
 BackButton::BackButton(ShelfView* shelf_view) : ShelfControlButton(shelf_view) {
   SetAccessibleName(l10n_util::GetStringUTF16(IDS_ASH_SHELF_BACK_BUTTON_TITLE));
 }
 
 BackButton::~BackButton() = default;
 
-void BackButton::NotifyClick(const ui::Event& event) {
-  Button::NotifyClick(event);
+void BackButton::OnGestureEvent(ui::GestureEvent* event) {
+  ShelfButton::OnGestureEvent(event);
+  if (event->type() == ui::ET_GESTURE_TAP ||
+      event->type() == ui::ET_GESTURE_TAP_DOWN) {
+    GenerateAndSendBackEvent(event->type());
+  }
+}
+
+bool BackButton::OnMousePressed(const ui::MouseEvent& event) {
+  ShelfButton::OnMousePressed(event);
+  GenerateAndSendBackEvent(event.type());
+  return true;
+}
 
-  // Send up event as well as down event as ARC++ clients expect this sequence.
-  // TODO: Investigate if we should be using the current modifiers.
-  aura::Window* root_window = GetWidget()->GetNativeWindow()->GetRootWindow();
-  ui::KeyEvent press_key_event(ui::ET_KEY_PRESSED, ui::VKEY_BROWSER_BACK,
-                               ui::EF_NONE);
-  ignore_result(root_window->GetHost()->SendEventToSink(&press_key_event));
-  ui::KeyEvent release_key_event(ui::ET_KEY_RELEASED, ui::VKEY_BROWSER_BACK,
-                                 ui::EF_NONE);
-  ignore_result(root_window->GetHost()->SendEventToSink(&release_key_event));
+void BackButton::OnMouseReleased(const ui::MouseEvent& event) {
+  ShelfButton::OnMouseReleased(event);
+  GenerateAndSendBackEvent(event.type());
 }
 
 void BackButton::PaintButtonContents(gfx::Canvas* canvas) {
@@ -46,8 +60,31 @@
                        GetCenterPoint().y() - img.height() / 2);
 }
 
-const char* BackButton::GetClassName() const {
-  return kViewClassName;
+void BackButton::GenerateAndSendBackEvent(
+    const ui::EventType& original_event_type) {
+  ui::EventType new_event_type;
+  switch (original_event_type) {
+    case ui::ET_MOUSE_PRESSED:
+    case ui::ET_GESTURE_TAP_DOWN:
+      new_event_type = ui::ET_KEY_PRESSED;
+      break;
+    case ui::ET_MOUSE_RELEASED:
+    case ui::ET_GESTURE_TAP:
+      new_event_type = ui::ET_KEY_RELEASED;
+      base::RecordAction(base::UserMetricsAction("Tablet_BackButton"));
+      break;
+    default:
+      return;
+  }
+
+  // Send the back event to the root window of the back button's widget.
+  const views::Widget* widget = GetWidget();
+  if (widget && widget->GetNativeWindow()) {
+    aura::Window* root_window = widget->GetNativeWindow()->GetRootWindow();
+    ui::KeyEvent key_event(new_event_type, ui::VKEY_BROWSER_BACK, ui::EF_NONE);
+    ignore_result(
+        root_window->GetHost()->event_sink()->OnEventFromSource(&key_event));
+  }
 }
 
 }  // namespace ash
--- a/ash/shelf/back_button.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/shelf/back_button.h	2019-05-17 18:53:08.240000000 +0300
@@ -18,18 +18,21 @@
 // in/out of the icon matches the movement of ShelfView's items.
 class ASH_EXPORT BackButton : public ShelfControlButton {
  public:
-  static const char kViewClassName[];
-
   explicit BackButton(ShelfView* shelf_view);
   ~BackButton() override;
 
  protected:
   // views::Button:
-  void NotifyClick(const ui::Event& event) override;
+  void OnGestureEvent(ui::GestureEvent* event) override;
+  bool OnMousePressed(const ui::MouseEvent& event) override;
+  void OnMouseReleased(const ui::MouseEvent& event) override;
   void PaintButtonContents(gfx::Canvas* canvas) override;
-  const char* GetClassName() const override;
 
  private:
+  // Generate and send a VKEY_BROWSER_BACK key event when the back button
+  // is pressed.
+  void GenerateAndSendBackEvent(const ui::EventType& original_event_type);
+
   DISALLOW_COPY_AND_ASSIGN(BackButton);
 };
 
--- a/ash/shelf/back_button_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/shelf/back_button_unittest.cc	2019-05-17 18:53:08.240000000 +0300
@@ -107,15 +107,11 @@
   ui::TestAcceleratorTarget target_back_release;
   controller->Register({accelerator_back_release}, &target_back_release);
 
-  // Verify that by pressing the back button no event is generated on the press,
-  // but there is one generated on the release.
+  // Verify that by clicking the back button, a back key sequence will be
+  // generated.
   ui::test::EventGenerator* generator = GetEventGenerator();
   generator->MoveMouseTo(back_button()->GetBoundsInScreen().CenterPoint());
-  generator->PressLeftButton();
-  EXPECT_EQ(0, target_back_press.accelerator_count());
-  EXPECT_EQ(0, target_back_release.accelerator_count());
-
-  generator->ReleaseLeftButton();
+  generator->ClickLeftButton();
   EXPECT_EQ(1, target_back_press.accelerator_count());
   EXPECT_EQ(1, target_back_release.accelerator_count());
 }
--- a/ash/shelf/login_shelf_view.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/shelf/login_shelf_view.cc	2019-05-17 18:53:08.240000000 +0300
@@ -18,6 +18,7 @@
 #include "ash/resources/vector_icons/vector_icons.h"
 #include "ash/root_window_controller.h"
 #include "ash/session/session_controller.h"
+#include "ash/session/session_observer.h"
 #include "ash/shelf/shelf.h"
 #include "ash/shelf/shelf_constants.h"
 #include "ash/shelf/shelf_widget.h"
@@ -54,7 +55,7 @@
 #include "ui/views/controls/menu/menu_types.h"
 #include "ui/views/focus/focus_search.h"
 #include "ui/views/layout/box_layout.h"
-#include "ui/views/view_class_properties.h"
+#include "ui/views/view_properties.h"
 #include "ui/views/widget/widget.h"
 
 using session_manager::SessionState;
@@ -62,8 +63,6 @@
 namespace ash {
 namespace {
 
-const char* kLoginShelfButtonClassName = "LoginShelfButton";
-
 LoginMetricsRecorder::ShelfButtonClickTarget GetUserClickTarget(int button_id) {
   switch (button_id) {
     case LoginShelfView::kShutdown:
@@ -80,8 +79,6 @@
       return LoginMetricsRecorder::ShelfButtonClickTarget::kAddUserButton;
     case LoginShelfView::kCancel:
       return LoginMetricsRecorder::ShelfButtonClickTarget::kCancelButton;
-    case LoginShelfView::kParentAccess:
-      return LoginMetricsRecorder::ShelfButtonClickTarget::kParentAccessButton;
   }
   return LoginMetricsRecorder::ShelfButtonClickTarget::kTargetCount;
 }
@@ -127,15 +124,14 @@
                     GetButtonHighlightPath(view).release());
 }
 
-class LoginShelfButton : public views::LabelButton {
+class LoginShelfButton : public views::LabelButton,
+                         public ash::SessionObserver {
  public:
   LoginShelfButton(views::ButtonListener* listener,
-                   int text_resource_id,
+                   const base::string16& text,
                    const gfx::VectorIcon& icon)
-      : LabelButton(listener, l10n_util::GetStringUTF16(text_resource_id)),
-        text_resource_id_(text_resource_id),
-        icon_(icon) {
-    SetAccessibleName(GetText());
+      : LabelButton(listener, text), icon_(icon) {
+    SetAccessibleName(text);
     SetImage(views::Button::STATE_NORMAL,
              gfx::CreateVectorIcon(icon, kButtonIconColor));
     SetImage(views::Button::STATE_DISABLED,
@@ -159,7 +155,9 @@
     SetTextSubpixelRenderingEnabled(false);
 
     SetImageLabelSpacing(kImageLabelSpacingDp);
-    SetEnabledTextColors(kButtonTextColor);
+    SetTextColor(views::Button::STATE_NORMAL, kButtonTextColor);
+    SetTextColor(views::Button::STATE_HOVERED, kButtonTextColor);
+    SetTextColor(views::Button::STATE_PRESSED, kButtonTextColor);
     SetTextColor(
         views::Button::STATE_DISABLED,
         SkColorSetA(kButtonTextColor, login_constants::kButtonDisabledAlpha));
@@ -169,18 +167,12 @@
 
   ~LoginShelfButton() override = default;
 
-  int text_resource_id() const { return text_resource_id_; }
-
   // views::LabelButton:
   gfx::Insets GetInsets() const override {
     return gfx::Insets(kButtonMarginTopDp, kButtonMarginLeftDp,
                        kButtonMarginBottomDp, kButtonMarginRightDp);
   }
 
-  const char* GetClassName() const override {
-    return kLoginShelfButtonClassName;
-  }
-
   void OnBoundsChanged(const gfx::Rect& previous_bounds) override {
     SetButtonHighlightPath(this);
     LabelButton::OnBoundsChanged(previous_bounds);
@@ -201,20 +193,25 @@
     return ink_drop;
   }
 
-  void PaintDarkColors() {
-    SetEnabledTextColors(gfx::kGoogleGrey600);
+  // ash::SessionObserver:
+  void OnSessionStateChanged(session_manager::SessionState state) override {
+    if (state == session_manager::SessionState::OOBE) {
+      SetTextColor(views::Button::STATE_NORMAL, gfx::kGoogleGrey600);
+      SetTextColor(views::Button::STATE_HOVERED, gfx::kGoogleGrey600);
+      SetTextColor(views::Button::STATE_PRESSED, gfx::kGoogleGrey600);
     SetImage(views::Button::STATE_NORMAL,
              gfx::CreateVectorIcon(icon_, gfx::kGoogleGrey600));
-  }
-
-  void PaintLightColors() {
-    SetEnabledTextColors(kButtonTextColor);
+    } else {
+      SetTextColor(views::Button::STATE_NORMAL, kButtonTextColor);
+      SetTextColor(views::Button::STATE_HOVERED, kButtonTextColor);
+      SetTextColor(views::Button::STATE_PRESSED, kButtonTextColor);
     SetImage(views::Button::STATE_NORMAL,
              gfx::CreateVectorIcon(icon_, kButtonTextColor));
   }
+  }
 
  private:
-  const int text_resource_id_;
+  ash::ScopedSessionObserver observer_{this};
   const gfx::VectorIcon& icon_;
 
   DISALLOW_COPY_AND_ASSIGN(LoginShelfButton);
@@ -227,9 +224,8 @@
                         public ui::SimpleMenuModel,
                         public ui::SimpleMenuModel::Delegate {
  public:
-  KioskAppsButton()
-      : MenuButton(l10n_util::GetStringUTF16(IDS_ASH_SHELF_APPS_BUTTON), this),
-        ui::SimpleMenuModel(this) {
+  KioskAppsButton(const base::string16& text, const gfx::ImageSkia& image)
+      : MenuButton(text, this), ui::SimpleMenuModel(this) {
     SetFocusBehavior(FocusBehavior::ALWAYS);
     SetInstallFocusRingOnFocus(true);
     focus_ring()->SetColor(kFocusBorderColor);
@@ -246,10 +242,11 @@
 
     SetTextSubpixelRenderingEnabled(false);
 
-    SetImage(views::Button::STATE_NORMAL,
-             CreateVectorIcon(kShelfAppsButtonIcon, kButtonIconColor));
+    SetImage(views::Button::STATE_NORMAL, image);
     SetImageLabelSpacing(kImageLabelSpacingDp);
-    SetEnabledTextColors(kButtonTextColor);
+    SetTextColor(views::Button::STATE_NORMAL, kButtonTextColor);
+    SetTextColor(views::Button::STATE_HOVERED, kButtonTextColor);
+    SetTextColor(views::Button::STATE_PRESSED, kButtonTextColor);
     label()->SetFontList(views::Label::GetDefaultFontList().Derive(
         1, gfx::Font::FontStyle::NORMAL, gfx::Font::Weight::NORMAL));
   }
@@ -301,18 +298,6 @@
     return ink_drop;
   }
 
-  void PaintDarkColors() {
-    SetEnabledTextColors(gfx::kGoogleGrey600);
-    SetImage(views::Button::STATE_NORMAL,
-             CreateVectorIcon(kShelfAppsButtonIcon, gfx::kGoogleGrey600));
-  }
-
-  void PaintLightColors() {
-    SetEnabledTextColors(kButtonTextColor);
-    SetImage(views::Button::STATE_NORMAL,
-             CreateVectorIcon(kShelfAppsButtonIcon, kButtonIconColor));
-  }
-
   // views::MenuButtonListener:
   void OnMenuButtonClicked(MenuButton* source,
                            const gfx::Point& point,
@@ -382,14 +367,16 @@
 
   auto add_button = [this](ButtonId id, int text_resource_id,
                            const gfx::VectorIcon& icon) {
-    LoginShelfButton* button =
-        new LoginShelfButton(this, text_resource_id, icon);
+    const base::string16 text = l10n_util::GetStringUTF16(text_resource_id);
+    LoginShelfButton* button = new LoginShelfButton(this, text, icon);
     button->set_id(id);
     AddChildView(button);
   };
   add_button(kShutdown, IDS_ASH_SHELF_SHUTDOWN_BUTTON,
              kShelfShutdownButtonIcon);
-  kiosk_apps_button_ = new KioskAppsButton();
+  kiosk_apps_button_ = new KioskAppsButton(
+      l10n_util::GetStringUTF16(IDS_ASH_SHELF_APPS_BUTTON),
+      CreateVectorIcon(kShelfAppsButtonIcon, kButtonIconColor));
   kiosk_apps_button_->set_id(kApps);
   AddChildView(kiosk_apps_button_);
   add_button(kRestart, IDS_ASH_SHELF_RESTART_BUTTON, kShelfShutdownButtonIcon);
@@ -400,7 +387,7 @@
              kShelfBrowseAsGuestButtonIcon);
   add_button(kAddUser, IDS_ASH_ADD_USER_BUTTON, kShelfAddPersonButtonIcon);
   add_button(kParentAccess, IDS_ASH_PARENT_ACCESS_BUTTON,
-             kParentAccessLockIcon);
+             kShelfParentAccessButtonIcon);
 
   // Adds observers for states that affect the visiblity of different buttons.
   tray_action_observer_.Add(Shell::Get()->tray_action());
@@ -408,7 +395,6 @@
   lock_screen_action_background_observer_.Add(lock_screen_action_background);
   login_screen_controller_observer_.Add(
       Shell::Get()->login_screen_controller());
-  locale_change_observer_.Add(Shell::Get()->locale_update_controller());
   UpdateUi();
 }
 
@@ -442,11 +428,13 @@
     }
   } else {
     // Focus goes to status area.
-    StatusAreaWidget* status_area_widget =
-        Shelf::ForWindow(GetWidget()->GetNativeWindow())->GetStatusAreaWidget();
-    status_area_widget->status_area_widget_delegate()
+    Shelf::ForWindow(GetWidget()->GetNativeWindow())
+        ->GetStatusAreaWidget()
+        ->status_area_widget_delegate()
         ->set_default_last_focusable_child(reverse);
-    Shell::Get()->focus_cycler()->FocusWidget(status_area_widget);
+    Shell::Get()->focus_cycler()->FocusWidget(
+        Shelf::ForWindow(GetWidget()->GetNativeWindow())
+            ->GetStatusAreaWidget());
   }
 }
 
@@ -499,9 +487,6 @@
       Shell::Get()->login_screen_controller()->ShowGaiaSignin(
           true /*can_close*/, base::nullopt /*prefilled_account*/);
       break;
-    case kParentAccess:
-      Shell::Get()->login_screen_controller()->SetShowParentAccessDialog(true);
-      break;
     default:
       NOTREACHED();
   }
@@ -523,7 +508,7 @@
   UpdateUi();
 }
 
-void LoginShelfView::SetShowParentAccessButton(bool show) {
+void LoginShelfView::SetShowParentAccess(bool show) {
   show_parent_access_ = show;
   UpdateUi();
 }
@@ -565,17 +550,6 @@
   UpdateUi();
 }
 
-void LoginShelfView::OnLocaleChanged() {
-  for (int i = 0; i < child_count(); ++i) {
-    views::View* child = child_at(i);
-    if (child->GetClassName() == kLoginShelfButtonClassName) {
-      auto* button = static_cast<LoginShelfButton*>(child);
-      button->SetText(l10n_util::GetStringUTF16(button->text_resource_id()));
-      button->SetAccessibleName(button->GetText());
-    }
-  }
-}
-
 bool LoginShelfView::LockScreenActionBackgroundAnimating() const {
   return lock_screen_action_background_->state() ==
              LockScreenActionBackgroundState::kShowing ||
@@ -593,7 +567,6 @@
       child_at(i)->SetVisible(false);
     return;
   }
-  ++ui_update_count_;
   bool show_reboot = Shell::Get()->shutdown_controller()->reboot_on_shutdown();
   mojom::TrayActionState tray_action_state =
       Shell::Get()->tray_action()->GetLockScreenNoteState();
@@ -651,48 +624,8 @@
   kiosk_apps_button_->SetVisible(
       (!dialog_visible ||
        dialog_state_ == mojom::OobeDialogState::GAIA_SIGNIN) &&
-      kiosk_apps_button_->HasApps() && (is_login_primary || is_oobe));
-
-  UpdateButtonColors(is_oobe);
+      kiosk_apps_button_->HasApps() && is_login_primary);
   Layout();
-  UpdateButtonUnionBounds();
-}
-
-void LoginShelfView::UpdateButtonColors(bool use_dark_colors) {
-  if (use_dark_colors) {
-    static_cast<LoginShelfButton*>(GetViewByID(kShutdown))->PaintDarkColors();
-    static_cast<LoginShelfButton*>(GetViewByID(kRestart))->PaintDarkColors();
-    static_cast<LoginShelfButton*>(GetViewByID(kSignOut))->PaintDarkColors();
-    static_cast<LoginShelfButton*>(GetViewByID(kCloseNote))->PaintDarkColors();
-    static_cast<LoginShelfButton*>(GetViewByID(kCancel))->PaintDarkColors();
-    static_cast<LoginShelfButton*>(GetViewByID(kParentAccess))
-        ->PaintDarkColors();
-    static_cast<LoginShelfButton*>(GetViewByID(kBrowseAsGuest))
-        ->PaintDarkColors();
-    static_cast<LoginShelfButton*>(GetViewByID(kAddUser))->PaintDarkColors();
-    kiosk_apps_button_->PaintDarkColors();
-  } else {
-    static_cast<LoginShelfButton*>(GetViewByID(kShutdown))->PaintLightColors();
-    static_cast<LoginShelfButton*>(GetViewByID(kRestart))->PaintLightColors();
-    static_cast<LoginShelfButton*>(GetViewByID(kSignOut))->PaintLightColors();
-    static_cast<LoginShelfButton*>(GetViewByID(kCloseNote))->PaintLightColors();
-    static_cast<LoginShelfButton*>(GetViewByID(kCancel))->PaintLightColors();
-    static_cast<LoginShelfButton*>(GetViewByID(kParentAccess))
-        ->PaintLightColors();
-    static_cast<LoginShelfButton*>(GetViewByID(kBrowseAsGuest))
-        ->PaintLightColors();
-    static_cast<LoginShelfButton*>(GetViewByID(kAddUser))->PaintLightColors();
-    kiosk_apps_button_->PaintLightColors();
-  }
-}
-
-void LoginShelfView::UpdateButtonUnionBounds() {
-  button_union_bounds_ = gfx::Rect();
-  View::Views children = GetChildrenInZOrder();
-  for (auto* child : children) {
-    if (child->visible())
-      button_union_bounds_.Union(child->bounds());
-  }
 }
 
 }  // namespace ash
--- a/ash/shelf/login_shelf_view.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/shelf/login_shelf_view.h	2019-05-17 18:53:08.240000000 +0300
@@ -14,7 +14,6 @@
 #include "ash/public/interfaces/kiosk_app_info.mojom.h"
 #include "ash/public/interfaces/login_screen.mojom.h"
 #include "ash/shutdown_controller.h"
-#include "ash/system/locale/locale_update_controller.h"
 #include "ash/tray_action/tray_action_observer.h"
 #include "base/scoped_observer.h"
 #include "ui/views/controls/button/button.h"
@@ -48,8 +47,7 @@
                                   public LockScreenActionBackgroundObserver,
                                   public ShutdownController::Observer,
                                   public LoginScreenControllerObserver,
-                                  public LoginDataDispatcher::Observer,
-                                  public LocaleChangeObserver {
+                                  public LoginDataDispatcher::Observer {
  public:
   enum ButtonId {
     kShutdown = 1,   // Shut down the device.
@@ -82,7 +80,7 @@
   void SetAllowLoginAsGuest(bool allow_guest);
 
   // Sets whether parent access button can be shown on the login shelf.
-  void SetShowParentAccessButton(bool show);
+  void SetShowParentAccess(bool show);
 
   // Sets if the guest button on the login shelf can be shown during gaia
   // signin screen.
@@ -103,9 +101,6 @@
   // views::ButtonListener:
   void ButtonPressed(views::Button* sender, const ui::Event& event) override;
 
-  int ui_update_count() const { return ui_update_count_; }
-  gfx::Rect get_button_union_bounds() const { return button_union_bounds_; }
-
  protected:
   // TrayActionObserver:
   void OnLockScreenNoteStateChanged(mojom::TrayActionState state) override;
@@ -124,9 +119,6 @@
   void OnUsersChanged(
       const std::vector<mojom::LoginUserInfoPtr>& users) override;
 
-  // LocaleChangeObserver:
-  void OnLocaleChanged() override;
-
  private:
   bool LockScreenActionBackgroundAnimating() const;
 
@@ -134,13 +126,6 @@
   // policy updates, session state changes etc.
   void UpdateUi();
 
-  // Updates the color of all buttons. Uses dark colors if |use_dark_colors| is
-  // true, light colors otherwise.
-  void UpdateButtonColors(bool use_dark_colors);
-
-  // Updates the total bounds of all buttons.
-  void UpdateButtonUnionBounds();
-
   mojom::OobeDialogState dialog_state_ = mojom::OobeDialogState::HIDDEN;
   bool allow_guest_ = true;
   bool allow_guest_in_oobe_ = false;
@@ -163,19 +148,8 @@
   ScopedObserver<LoginScreenController, LoginScreenControllerObserver>
       login_screen_controller_observer_;
 
-  ScopedObserver<LocaleUpdateController, LocaleChangeObserver>
-      locale_change_observer_{this};
-
   KioskAppsButton* kiosk_apps_button_ = nullptr;  // Owned by view hierarchy
 
-  // This is used in tests to wait until UI is updated.
-  int ui_update_count_ = 0;
-
-  // The bounds of all the buttons that this view is showing. Useful for
-  // letting events that target the "empty space" pass through. These
-  // coordinates are local to the view.
-  gfx::Rect button_union_bounds_;
-
   DISALLOW_COPY_AND_ASSIGN(LoginShelfView);
 };
 
--- a/ash/shelf/login_shelf_view_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/shelf/login_shelf_view_unittest.cc	2019-05-17 18:53:08.240000000 +0300
@@ -28,7 +28,6 @@
 #include "ash/tray_action/test_tray_action_client.h"
 #include "ash/tray_action/tray_action.h"
 #include "ash/wm/lock_state_controller.h"
-#include "base/bind.h"
 #include "base/command_line.h"
 #include "base/run_loop.h"
 #include "chromeos/constants/chromeos_switches.h"
@@ -523,7 +522,7 @@
 
 TEST_F(LoginShelfViewTest, ParentAccessButtonVisibility) {
   // Parent access button should only be visible on lock screen.
-  Shell::Get()->login_screen_controller()->SetShowParentAccessButton(true);
+  Shell::Get()->login_screen_controller()->SetShowParentAccess(true);
 
   NotifySessionStateChanged(SessionState::LOGIN_PRIMARY);
   EXPECT_TRUE(ShowsShelfButtons({LoginShelfView::kShutdown,
@@ -554,12 +553,12 @@
   EXPECT_TRUE(
       ShowsShelfButtons({LoginShelfView::kShutdown, LoginShelfView::kSignOut}));
 
-  Shell::Get()->login_screen_controller()->SetShowParentAccessButton(true);
+  Shell::Get()->login_screen_controller()->SetShowParentAccess(true);
   EXPECT_TRUE(
       ShowsShelfButtons({LoginShelfView::kShutdown, LoginShelfView::kSignOut,
                          LoginShelfView::kParentAccess}));
 
-  Shell::Get()->login_screen_controller()->SetShowParentAccessButton(false);
+  Shell::Get()->login_screen_controller()->SetShowParentAccess(false);
   EXPECT_TRUE(
       ShowsShelfButtons({LoginShelfView::kShutdown, LoginShelfView::kSignOut}));
 }
--- a/ash/shelf/overflow_button.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/shelf/overflow_button.cc	2019-05-17 18:53:08.240000000 +0300
@@ -48,8 +48,4 @@
   shelf_view()->ButtonPressed(this, event, nullptr);
 }
 
-const char* OverflowButton::GetClassName() const {
-  return "ash/OverflowButton";
-}
-
 }  // namespace ash
--- a/ash/shelf/overflow_button.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/shelf/overflow_button.h	2019-05-17 18:53:08.240000000 +0300
@@ -34,7 +34,6 @@
   // views::Button:
   bool ShouldEnterPushedState(const ui::Event& event) override;
   void NotifyClick(const ui::Event& event) override;
-  const char* GetClassName() const override;
 
   const gfx::ImageSkia horizontal_dots_image_;
   views::ImageView* horizontal_dots_image_view_;
--- a/ash/shelf/shelf_app_button.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/shelf/shelf_app_button.cc	2019-05-17 18:53:08.244000000 +0300
@@ -12,7 +12,7 @@
 #include "ash/shelf/shelf.h"
 #include "ash/shelf/shelf_constants.h"
 #include "ash/shelf/shelf_view.h"
-#include "base/bind.h"
+#include "ash/system/tray/tray_popup_utils.h"
 #include "base/metrics/histogram_macros.h"
 #include "base/stl_util.h"
 #include "base/time/time.h"
@@ -331,6 +331,8 @@
     notification_indicator_->SetVisible(false);
     AddChildView(notification_indicator_);
   }
+
+  SetFocusPainter(TrayPopupUtils::CreateFocusPainter());
 }
 
 ShelfAppButton::~ShelfAppButton() {
--- a/ash/shelf/shelf_background_animator.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/shelf/shelf_background_animator.cc	2019-05-17 18:53:08.244000000 +0300
@@ -143,12 +143,13 @@
     ShelfBackgroundType background_type) const {
   switch (background_type) {
     case SHELF_BACKGROUND_DEFAULT:
-    case SHELF_BACKGROUND_OVERVIEW:
       return kShelfTranslucentAlpha;
     case SHELF_BACKGROUND_MAXIMIZED:
       return kShelfTranslucentMaximizedWindow;
     case SHELF_BACKGROUND_APP_LIST:
       return kShelfTranslucentOverAppList;
+    case SHELF_BACKGROUND_SPLIT_VIEW:
+      return ShelfBackgroundAnimator::kMaxAlpha;
     case SHELF_BACKGROUND_OOBE:
       return SK_AlphaTRANSPARENT;
     case SHELF_BACKGROUND_LOGIN:
@@ -225,10 +226,10 @@
       duration_ms = 500;
       break;
     case SHELF_BACKGROUND_MAXIMIZED:
+    case SHELF_BACKGROUND_SPLIT_VIEW:
     case SHELF_BACKGROUND_OOBE:
     case SHELF_BACKGROUND_LOGIN:
     case SHELF_BACKGROUND_LOGIN_NONBLURRED_WALLPAPER:
-    case SHELF_BACKGROUND_OVERVIEW:
       duration_ms = 250;
       break;
   }
@@ -266,12 +267,14 @@
   switch (background_type) {
     case SHELF_BACKGROUND_DEFAULT:
     case SHELF_BACKGROUND_APP_LIST:
-    case SHELF_BACKGROUND_OVERVIEW:
       shelf_target_color = darken_wallpaper(kShelfTranslucentColorDarkenAlpha);
       break;
     case SHELF_BACKGROUND_MAXIMIZED:
       shelf_target_color = darken_wallpaper(kShelfOpaqueColorDarkenAlpha);
       break;
+    case SHELF_BACKGROUND_SPLIT_VIEW:
+      shelf_target_color = darken_wallpaper(ShelfBackgroundAnimator::kMaxAlpha);
+      break;
     case SHELF_BACKGROUND_OOBE:
       shelf_target_color = SK_ColorTRANSPARENT;
       break;
--- a/ash/shelf/shelf_background_animator_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/shelf/shelf_background_animator_unittest.cc	2019-05-17 18:53:08.244000000 +0300
@@ -26,10 +26,18 @@
 namespace ash {
 namespace {
 
+static auto kMaxAlpha = ShelfBackgroundAnimator::kMaxAlpha;
+
 // A valid color value that is distinct from any final animation state values.
 // Used to check if color values are changed during animations.
 const SkColor kDummyColor = SK_ColorBLUE;
 
+// Helper function to get the base color from |color|, i.e., remove the alpha.
+SkColor GetBaseColor(SkColor color) {
+  return SkColorSetRGB(SkColorGetR(color), SkColorGetG(color),
+                       SkColorGetB(color));
+}
+
 // Observer that caches color values for the last observation.
 class TestShelfBackgroundObserver : public ShelfBackgroundAnimatorObserver {
  public:
@@ -208,6 +216,14 @@
   EXPECT_EQ(kShelfTranslucentMaximizedWindow, observer_.GetBackgroundAlpha());
 }
 
+// Verify the alpha values for the SHELF_BACKGROUND_SPLIT_VIEW state.
+TEST_F(ShelfBackgroundAnimatorTest, SplitViewBackground) {
+  PaintBackground(SHELF_BACKGROUND_SPLIT_VIEW);
+
+  EXPECT_EQ(SHELF_BACKGROUND_SPLIT_VIEW, animator_->target_background_type());
+  EXPECT_EQ(kMaxAlpha, observer_.GetBackgroundAlpha());
+}
+
 // Verify the alpha values for the SHELF_BACKGROUND_APP_LIST state.
 TEST_F(ShelfBackgroundAnimatorTest, FullscreenAppListBackground) {
   PaintBackground(SHELF_BACKGROUND_APP_LIST);
@@ -296,44 +312,83 @@
   DISALLOW_COPY_AND_ASSIGN(ShelfBackgroundTargetColorTest);
 };
 
-// Verify the target color of the shelf background is updated based on session
-// state, starting from LOGIN_PRIMARY.
-TEST_F(ShelfBackgroundTargetColorTest, ShelfBackgroundColorUpdatedFromLogin) {
+// The tests only compare the base color, because different alpha values may be
+// applied based on |ShelfBackgroundType|, which is verifed by
+// |ShelfBackgroundAnimatorTest|.
+//
+// Verify the target colors of the shelf and item backgrounds are updated based
+// on session state, starting from LOGIN_PRIMARY.
+TEST_F(ShelfBackgroundTargetColorTest,
+       ShelfAndItemBackgroundColorUpdatedFromLogin) {
   ShelfBackgroundAnimatorTestApi test_api(
       Shelf::ForWindow(Shell::Get()->GetPrimaryRootWindow())
           ->shelf_widget()
           ->background_animator_for_testing());
 
   NotifySessionStateChanged(session_manager::SessionState::LOGIN_PRIMARY);
-  EXPECT_EQ(test_api.shelf_background_target_color(), SK_ColorTRANSPARENT);
+  EXPECT_EQ(GetBaseColor(test_api.shelf_background_target_color()),
+            GetBaseColor(SK_ColorTRANSPARENT));
 
   SimulateUserLogin("user1@test.com");
 
+  NotifySessionStateChanged(
+      session_manager::SessionState::LOGGED_IN_NOT_ACTIVE);
+  EXPECT_EQ(GetBaseColor(test_api.shelf_background_target_color()),
+            GetBaseColor(SK_ColorTRANSPARENT));
+
+  // The shelf has a non-transparent background only when session state is
+  // active.
+  NotifySessionStateChanged(session_manager::SessionState::ACTIVE);
+  EXPECT_EQ(GetBaseColor(test_api.shelf_background_target_color()),
+            GetBaseColor(kShelfDefaultBaseColor));
+
+  NotifySessionStateChanged(session_manager::SessionState::LOCKED);
+  EXPECT_EQ(GetBaseColor(test_api.shelf_background_target_color()),
+            GetBaseColor(SK_ColorTRANSPARENT));
+
+  // Ensure the shelf background color is correct after unlocking.
+  NotifySessionStateChanged(session_manager::SessionState::ACTIVE);
+  EXPECT_EQ(GetBaseColor(test_api.shelf_background_target_color()),
+            GetBaseColor(kShelfDefaultBaseColor));
+
+  NotifySessionStateChanged(session_manager::SessionState::LOGIN_SECONDARY);
+  EXPECT_EQ(GetBaseColor(test_api.shelf_background_target_color()),
+            GetBaseColor(SK_ColorTRANSPARENT));
+
+  // Ensure the shelf background color is correct after closing the user adding
+  // screen.
   NotifySessionStateChanged(session_manager::SessionState::ACTIVE);
-  EXPECT_EQ(test_api.shelf_background_target_color(),
-            SkColorSetA(kShelfDefaultBaseColor, kShelfTranslucentAlpha));
+  EXPECT_EQ(GetBaseColor(test_api.shelf_background_target_color()),
+            GetBaseColor(kShelfDefaultBaseColor));
 }
 
-// Verify the target color of the shelf background is updated based on session
-// state, starting from OOBE.
-TEST_F(ShelfBackgroundTargetColorTest, ShelfBackgroundColorUpdatedFromOOBE) {
+// Verify the target colors of the shelf and item backgrounds are updated based
+// on session state, starting from OOBE.
+// Note: the shelf is not supported for OOBE yet but it's good to check it here.
+// TODO(wzang|798869): The item backgrounds still keep the OOBE color if
+// directly transitioned from OOBE to LOGIN_PRIMARY. Revisit this when OOBE
+// shelf is supported.
+TEST_F(ShelfBackgroundTargetColorTest,
+       ShelfAndItemBackgroundColorUpdatedFromOOBE) {
   ShelfBackgroundAnimatorTestApi test_api(
       Shelf::ForWindow(Shell::Get()->GetPrimaryRootWindow())
           ->shelf_widget()
           ->background_animator_for_testing());
 
   NotifySessionStateChanged(session_manager::SessionState::OOBE);
-  EXPECT_EQ(test_api.shelf_background_target_color(), SK_ColorTRANSPARENT);
+  EXPECT_EQ(GetBaseColor(test_api.shelf_background_target_color()),
+            GetBaseColor(SK_ColorTRANSPARENT));
 
   SimulateUserLogin("user1@test.com");
 
   NotifySessionStateChanged(
       session_manager::SessionState::LOGGED_IN_NOT_ACTIVE);
-  EXPECT_EQ(test_api.shelf_background_target_color(), SK_ColorTRANSPARENT);
+  EXPECT_EQ(GetBaseColor(test_api.shelf_background_target_color()),
+            GetBaseColor(SK_ColorTRANSPARENT));
 
   NotifySessionStateChanged(session_manager::SessionState::ACTIVE);
-  EXPECT_EQ(test_api.shelf_background_target_color(),
-            SkColorSetA(kShelfDefaultBaseColor, kShelfTranslucentAlpha));
+  EXPECT_EQ(GetBaseColor(test_api.shelf_background_target_color()),
+            GetBaseColor(kShelfDefaultBaseColor));
 }
 
 }  // namespace ash
--- a/ash/shelf/shelf_bubble.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/shelf/shelf_bubble.cc	2019-05-17 18:53:08.244000000 +0300
@@ -39,13 +39,6 @@
           kShellWindowId_SettingBubbleContainer));
 }
 
-ax::mojom::Role ShelfBubble::GetAccessibleWindowRole() const {
-  // We override the role because the base class sets it to alert dialog,
-  // which results in each tooltip title being announced twice on screen
-  // readers each time it is shown.
-  return ax::mojom::Role::kDialog;
-}
-
 void ShelfBubble::CreateBubble() {
   // Actually create the bubble.
   views::BubbleDialogDelegateView::CreateBubble(this);
--- a/ash/shelf/shelf_bubble.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/shelf/shelf_bubble.h	2019-05-17 18:53:08.244000000 +0300
@@ -22,9 +22,6 @@
               ShelfAlignment alignment,
               SkColor background_co0lor);
 
-  // views::BubbleDialogDelegateView
-  ax::mojom::Role GetAccessibleWindowRole() const override;
-
   // Returns true if we should close when we get a press down event within our
   // bounds.
   virtual bool ShouldCloseOnPressDown() = 0;
@@ -34,7 +31,7 @@
   virtual bool ShouldCloseOnMouseExit() = 0;
 
  protected:
-  void set_border_radius(int radius) { border_radius_ = radius; }
+  void set_border_radius(int radius) { border_radius_ = radius; };
 
   // Performs the actual bubble creation.
   void CreateBubble();
--- a/ash/shelf/shelf_button.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/shelf/shelf_button.cc	2019-05-17 18:53:08.244000000 +0300
@@ -7,7 +7,6 @@
 #include "ash/shelf/ink_drop_button_listener.h"
 #include "ash/shelf/shelf_constants.h"
 #include "ash/shelf/shelf_view.h"
-#include "ash/system/tray/tray_popup_utils.h"
 #include "ui/accessibility/ax_node_data.h"
 #include "ui/views/animation/ink_drop_impl.h"
 
@@ -21,7 +20,6 @@
   set_ink_drop_visible_opacity(kShelfInkDropVisibleOpacity);
   SetFocusBehavior(FocusBehavior::ACCESSIBLE_ONLY);
   SetInkDropMode(InkDropMode::ON_NO_GESTURE_HANDLER);
-  SetFocusPainter(TrayPopupUtils::CreateFocusPainter());
 }
 
 ShelfButton::~ShelfButton() = default;
@@ -54,12 +52,6 @@
   return true;
 }
 
-void ShelfButton::AboutToRequestFocusFromTabTraversal(bool reverse) {
-  shelf_view_->OnShelfButtonAboutToRequestFocusFromTabTraversal(this, reverse);
-}
-
-// Do not remove this function to avoid unnecessary ChromeVox announcement
-// triggered by Button::GetAccessibleNodeData. (See https://crbug.com/932200)
 void ShelfButton::GetAccessibleNodeData(ui::AXNodeData* node_data) {
   node_data->role = ax::mojom::Role::kButton;
   node_data->SetName(GetAccessibleName());
@@ -97,8 +89,4 @@
   return std::move(ink_drop);
 }
 
-const char* ShelfButton::GetClassName() const {
-  return "ash/ShelfButton";
-}
-
 }  // namespace ash
--- a/ash/shelf/shelf_button.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/shelf/shelf_button.h	2019-05-17 18:53:08.244000000 +0300
@@ -23,7 +23,6 @@
   void OnMouseReleased(const ui::MouseEvent& event) override;
   void OnMouseCaptureLost() override;
   bool OnMouseDragged(const ui::MouseEvent& event) override;
-  void AboutToRequestFocusFromTabTraversal(bool reverse) override;
   void GetAccessibleNodeData(ui::AXNodeData* node_data) override;
   bool GetTooltipText(const gfx::Point& p,
                       base::string16* tooltip) const override;
@@ -35,7 +34,6 @@
   void NotifyClick(const ui::Event& event) override;
   bool ShouldEnterPushedState(const ui::Event& event) override;
   std::unique_ptr<views::InkDrop> CreateInkDrop() override;
-  const char* GetClassName() const override;
 
  private:
   // The shelf view hosting this button.
--- a/ash/shelf/shelf.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/shelf/shelf.cc	2019-05-17 18:53:08.240000000 +0300
@@ -19,7 +19,6 @@
 #include "ash/shelf/shelf_widget.h"
 #include "ash/shell.h"
 #include "ash/system/status_area_widget.h"
-#include "base/bind_helpers.h"
 #include "base/logging.h"
 #include "ui/display/types/display_constants.h"
 #include "ui/gfx/geometry/rect.h"
@@ -106,7 +105,7 @@
   ShelfItemDelegate* item_delegate = shelf_model->GetShelfItemDelegate(item.id);
   std::unique_ptr<ui::Event> event = std::make_unique<ui::KeyEvent>(
       ui::ET_KEY_RELEASED, ui::VKEY_UNKNOWN, ui::EF_NONE);
-  item_delegate->ItemSelected(std::move(event), display_id, LAUNCH_FROM_SHELF,
+  item_delegate->ItemSelected(std::move(event), display_id, LAUNCH_FROM_UNKNOWN,
                               base::DoNothing());
 }
 
@@ -143,12 +142,13 @@
 }
 
 aura::Window* Shelf::GetWindow() {
-  return shelf_widget_ ? shelf_widget_->GetNativeWindow() : nullptr;
+  return shelf_widget_->GetNativeWindow();
 }
 
 void Shelf::SetAlignment(ShelfAlignment alignment) {
-  if (!shelf_widget_)
-    return;
+  // Checks added for http://crbug.com/738011.
+  CHECK(shelf_widget_);
+  CHECK(shelf_layout_manager_);
 
   if (alignment_ == alignment)
     return;
@@ -217,8 +217,7 @@
 }
 
 ShelfBackgroundType Shelf::GetBackgroundType() const {
-  return shelf_widget_ ? shelf_widget_->GetBackgroundType()
-                       : SHELF_BACKGROUND_DEFAULT;
+  return shelf_widget_->GetBackgroundType();
 }
 
 void Shelf::UpdateVisibilityState() {
@@ -296,7 +295,7 @@
 }
 
 StatusAreaWidget* Shelf::GetStatusAreaWidget() const {
-  return shelf_widget_ ? shelf_widget_->status_area_widget() : nullptr;
+  return shelf_widget_->status_area_widget();
 }
 
 TrayBackgroundView* Shelf::GetSystemTrayAnchorView() const {
@@ -304,17 +303,19 @@
 }
 
 gfx::Rect Shelf::GetSystemTrayAnchorRect() const {
-  gfx::Rect work_area = GetUserWorkAreaBounds();
+  gfx::Rect workspace_bounds = GetUserWorkAreaBounds();
   switch (alignment_) {
     case SHELF_ALIGNMENT_BOTTOM:
     case SHELF_ALIGNMENT_BOTTOM_LOCKED:
-      return gfx::Rect(
-          base::i18n::IsRTL() ? work_area.x() : work_area.right() - 1,
-          work_area.bottom() - 1, 0, 0);
+      return gfx::Rect(base::i18n::IsRTL() ? workspace_bounds.x()
+                                           : (workspace_bounds.right() - 1),
+                       workspace_bounds.bottom() - 1, 0, 0);
     case SHELF_ALIGNMENT_LEFT:
-      return gfx::Rect(work_area.x(), work_area.bottom() - 1, 0, 0);
+      return gfx::Rect(workspace_bounds.x(), workspace_bounds.bottom() - 1, 0,
+                       0);
     case SHELF_ALIGNMENT_RIGHT:
-      return gfx::Rect(work_area.right() - 1, work_area.bottom() - 1, 0, 0);
+      return gfx::Rect(workspace_bounds.right() - 1,
+                       workspace_bounds.bottom() - 1, 0, 0);
   }
   NOTREACHED();
   return gfx::Rect();
--- a/ash/shelf/shelf_control_button.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/shelf/shelf_control_button.cc	2019-05-17 18:53:08.244000000 +0300
@@ -47,10 +47,6 @@
       size(), GetCenterPoint(), ShelfConstants::control_border_radius());
 }
 
-const char* ShelfControlButton::GetClassName() const {
-  return "ash/ShelfControlButton";
-}
-
 gfx::Rect ShelfControlButton::CalculateButtonBounds() const {
   ShelfAlignment alignment = shelf_->alignment();
   gfx::Rect content_bounds = GetContentsBounds();
--- a/ash/shelf/shelf_control_button.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/shelf/shelf_control_button.h	2019-05-17 18:53:08.244000000 +0300
@@ -31,7 +31,6 @@
   // views::Button:
   std::unique_ptr<views::InkDropRipple> CreateInkDropRipple() const override;
   std::unique_ptr<views::InkDropMask> CreateInkDropMask() const override;
-  const char* GetClassName() const override;
 
   void PaintBackground(gfx::Canvas* canvas, const gfx::Rect& bounds);
   void PaintButtonContents(gfx::Canvas* canvas) override;
--- a/ash/shelf/shelf_controller.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/shelf/shelf_controller.cc	2019-05-17 18:53:08.244000000 +0300
@@ -20,7 +20,6 @@
 #include "ash/system/message_center/arc/arc_notification_constants.h"
 #include "ash/wm/tablet_mode/tablet_mode_controller.h"
 #include "base/auto_reset.h"
-#include "base/bind.h"
 #include "chromeos/strings/grit/chromeos_strings.h"
 #include "components/pref_registry/pref_registry_syncable.h"
 #include "components/prefs/pref_change_registrar.h"
--- a/ash/shelf/shelf.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/shelf/shelf.h	2019-05-17 18:53:08.240000000 +0300
@@ -197,8 +197,6 @@
   // ShelfWidget and lifetimes are managed by the container windows themselves.
   ShelfLayoutManager* shelf_layout_manager_ = nullptr;
 
-  // Null during display teardown, see WindowTreeHostManager::DeleteHost() and
-  // RootWindowController::CloseAllChildWindows().
   std::unique_ptr<ShelfWidget> shelf_widget_;
 
   // These initial values hide the shelf until user preferences are available.
--- a/ash/shelf/shelf_layout_manager.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/shelf/shelf_layout_manager.cc	2019-05-17 18:53:08.244000000 +0300
@@ -10,11 +10,10 @@
 
 #include "ash/animation/animation_change_type.h"
 #include "ash/app_list/app_list_controller_impl.h"
-#include "ash/app_list/app_list_metrics.h"
+#include "ash/app_list/home_launcher_gesture_handler.h"
 #include "ash/app_list/model/app_list_view_state.h"
 #include "ash/app_list/views/app_list_view.h"
-#include "ash/home_screen/home_launcher_gesture_handler.h"
-#include "ash/home_screen/home_screen_controller.h"
+#include "ash/public/cpp/app_list/app_list_constants.h"
 #include "ash/public/cpp/app_list/app_list_features.h"
 #include "ash/public/cpp/shell_window_ids.h"
 #include "ash/root_window_controller.h"
@@ -180,12 +179,7 @@
   DCHECK(shelf_widget_);
   DCHECK(shelf_);
   Shell::Get()->AddShellObserver(this);
-  Shell::Get()->overview_controller()->AddObserver(this);
   Shell::Get()->app_list_controller()->AddObserver(this);
-  Shell::Get()
-      ->home_screen_controller()
-      ->home_launcher_gesture_handler()
-      ->AddObserver(this);
   Shell::Get()->lock_state_controller()->AddObserver(this);
   Shell::Get()->activation_client()->AddObserver(this);
   Shell::Get()->locale_update_controller()->AddObserver(this);
@@ -206,18 +200,10 @@
   Shell::Get()->locale_update_controller()->RemoveObserver(this);
   Shell::Get()->RemoveShellObserver(this);
   Shell::Get()->lock_state_controller()->RemoveObserver(this);
-  // The following are destroyed early when Shell is being destroyed so they
-  // may not exist.
-  if (Shell::Get()->home_screen_controller()) {
-    Shell::Get()
-        ->home_screen_controller()
-        ->home_launcher_gesture_handler()
-        ->RemoveObserver(this);
-  }
+  // AppListController is destroyed early when Shell is being destroyed, it may
+  // not exist.
   if (Shell::Get()->app_list_controller())
     Shell::Get()->app_list_controller()->RemoveObserver(this);
-  if (Shell::Get()->overview_controller())
-    Shell::Get()->overview_controller()->RemoveObserver(this);
 }
 
 void ShelfLayoutManager::PrepareForShutdown() {
@@ -342,7 +328,9 @@
             shelf_widget_->GetWindowBoundsInScreen().Contains(
                 display::Screen::GetScreen()->GetCursorScreenPoint());
       }
-      StartAutoHideTimer();
+      auto_hide_timer_.Start(
+          FROM_HERE, base::TimeDelta::FromMilliseconds(kAutoHideDelayMS), this,
+          &ShelfLayoutManager::UpdateAutoHideStateNow);
     }
   } else {
     StopAutoHideTimer();
@@ -364,22 +352,10 @@
     return;
 
   if (event->type() == ui::ET_MOUSE_PRESSED ||
-      event->type() == ui::ET_MOUSE_MOVED) {
-    if (GetVisibleShelfBounds().Contains(
-            display::Screen::GetScreen()->GetCursorScreenPoint())) {
-      UpdateAutoHideState();
-      last_seen_mouse_position_was_over_shelf_ = true;
-    } else {
-      // The event happened outside the shelf's bounds. If it's a click, hide
-      // the shelf immediately. If it's a mouse-out, hide after a delay (but
-      // only if it really is a mouse-out, meaning the mouse actually exited the
-      // shelf bounds as opposed to having been outside all along).
-      if (event->type() == ui::ET_MOUSE_PRESSED)
+      (event->type() == ui::ET_MOUSE_MOVED &&
+       GetVisibleShelfBounds().Contains(
+           display::Screen::GetScreen()->GetCursorScreenPoint()))) {
         UpdateAutoHideState();
-      else if (last_seen_mouse_position_was_over_shelf_)
-        StartAutoHideTimer();
-      last_seen_mouse_position_was_over_shelf_ = false;
-    }
   }
 }
 
@@ -502,16 +478,14 @@
       return SHELF_BACKGROUND_DEFAULT;
   }
 
-  if (Shell::Get()->IsSplitViewModeActive() ||
-      (state_.visibility_state != SHELF_AUTO_HIDE &&
-       state_.window_state == wm::WORKSPACE_WINDOW_STATE_MAXIMIZED)) {
+  if (state_.visibility_state != SHELF_AUTO_HIDE &&
+      state_.window_state == wm::WORKSPACE_WINDOW_STATE_MAXIMIZED) {
     return SHELF_BACKGROUND_MAXIMIZED;
   }
 
-  if (Shell::Get()->overview_controller() &&
-      Shell::Get()->overview_controller()->IsSelecting()) {
-    return SHELF_BACKGROUND_OVERVIEW;
-  }
+  // If split view mode is active, make the shelf fully opapue.
+  if (Shell::Get()->IsSplitViewModeActive())
+    return SHELF_BACKGROUND_SPLIT_VIEW;
 
   return SHELF_BACKGROUND_DEFAULT;
 }
@@ -570,13 +544,7 @@
   UpdateVisibilityState();
 }
 
-void ShelfLayoutManager::OnSplitViewModeStarted() {
-  MaybeUpdateShelfBackground(AnimationChangeType::ANIMATE);
-}
 
-void ShelfLayoutManager::OnSplitViewModeEnded() {
-  MaybeUpdateShelfBackground(AnimationChangeType::ANIMATE);
-}
 
 void ShelfLayoutManager::OnOverviewModeStartingAnimationComplete(
     bool canceled) {
@@ -589,6 +557,14 @@
   MaybeUpdateShelfBackground(AnimationChangeType::ANIMATE);
 }
 
+void ShelfLayoutManager::OnSplitViewModeStarted() {
+  MaybeUpdateShelfBackground(AnimationChangeType::ANIMATE);
+}
+
+void ShelfLayoutManager::OnSplitViewModeEnded() {
+  MaybeUpdateShelfBackground(AnimationChangeType::ANIMATE);
+}
+
 void ShelfLayoutManager::OnAppListVisibilityChanged(bool shown,
                                                     int64_t display_id) {
   // Shell may be under destruction.
@@ -626,7 +602,6 @@
     return;
 
   is_home_launcher_shown_ = shown;
-  is_home_launcher_target_position_shown_ = false;
   MaybeUpdateShelfBackground(AnimationChangeType::IMMEDIATE);
 }
 
@@ -1069,12 +1044,6 @@
   StopAutoHideTimer();
 }
 
-void ShelfLayoutManager::StartAutoHideTimer() {
-  auto_hide_timer_.Start(FROM_HERE,
-                         base::TimeDelta::FromMilliseconds(kAutoHideDelayMS),
-                         this, &ShelfLayoutManager::UpdateAutoHideStateNow);
-}
-
 void ShelfLayoutManager::StopAutoHideTimer() {
   auto_hide_timer_.Stop();
   mouse_over_shelf_when_auto_hide_timer_started_ = false;
@@ -1199,7 +1168,7 @@
 
   gfx::Point cursor_position_in_screen =
       display::Screen::GetScreen()->GetCursorScreenPoint();
-  // Cursor is invisible in tablet mode and plug in an external mouse in tablet
+  // Cursor is invisible in talbet mode and plug in an external mouse in tablet
   // mode will switch to clamshell mode.
   if (shelf_region.Contains(cursor_position_in_screen) &&
       !IsTabletModeEnabled()) {
@@ -1287,6 +1256,13 @@
 }
 
 bool ShelfLayoutManager::ShouldHomeGestureHandleEvent(float scroll_y) const {
+  HomeLauncherGestureHandler* home_launcher_handler =
+      Shell::Get()->app_list_controller()->home_launcher_gesture_handler();
+
+  // If there is no |home_launcher_handler|, return early.
+  if (!home_launcher_handler)
+    return false;
+
   // If the shelf is not visible, home gesture shouldn't trigger.
   if (!IsVisible())
     return false;
@@ -1323,7 +1299,7 @@
     GestureDragStatus previous_drag_status = gesture_drag_status_;
     gesture_drag_status_ = GESTURE_DRAG_APPLIST_IN_PROGRESS;
     HomeLauncherGestureHandler* home_launcher_handler =
-        Shell::Get()->home_screen_controller()->home_launcher_gesture_handler();
+        Shell::Get()->app_list_controller()->home_launcher_gesture_handler();
     if (home_launcher_handler->OnPressEvent(
             HomeLauncherGestureHandler::Mode::kSlideUpToShow,
             gesture_in_screen.location())) {
@@ -1354,7 +1330,7 @@
     const ui::GestureEvent& gesture_in_screen) {
   if (ShouldHomeGestureHandleEvent(gesture_in_screen.details().scroll_y())) {
     HomeLauncherGestureHandler* home_launcher_handler =
-        Shell::Get()->home_screen_controller()->home_launcher_gesture_handler();
+        Shell::Get()->app_list_controller()->home_launcher_gesture_handler();
     if (home_launcher_handler->OnScrollEvent(
             gesture_in_screen.location(),
             gesture_in_screen.details().scroll_y())) {
@@ -1418,17 +1394,43 @@
     return;
 
   HomeLauncherGestureHandler* home_launcher_handler =
-      Shell::Get()->home_screen_controller()->home_launcher_gesture_handler();
-  DCHECK(home_launcher_handler);
-  if (home_launcher_handler->OnReleaseEvent(gesture_in_screen.location())) {
+      Shell::Get()->app_list_controller()->home_launcher_gesture_handler();
+  if (home_launcher_handler &&
+      home_launcher_handler->OnReleaseEvent(gesture_in_screen.location())) {
     gesture_drag_status_ = GESTURE_DRAG_NONE;
     return;
   }
 
   using app_list::AppListViewState;
-  AppListViewState app_list_state =
-      Shell::Get()->app_list_controller()->CalculateStateAfterShelfDrag(
-          gesture_in_screen, launcher_above_shelf_bottom_amount_);
+  AppListViewState app_list_state = AppListViewState::PEEKING;
+  if (gesture_in_screen.type() == ui::ET_SCROLL_FLING_START &&
+      fabs(gesture_in_screen.details().velocity_y()) >
+          kAppListDragVelocityThreshold) {
+    // If the scroll sequence terminates with a fling, show the fullscreen app
+    // list if the fling was fast enough and in the correct direction, otherwise
+    // close it.
+    app_list_state = gesture_in_screen.details().velocity_y() < 0
+                         ? AppListViewState::FULLSCREEN_ALL_APPS
+                         : AppListViewState::CLOSED;
+  } else {
+    // Snap the app list to corresponding state according to the snapping
+    // thresholds.
+    if (IsTabletModeEnabled()) {
+      app_list_state = launcher_above_shelf_bottom_amount_ >
+                               kAppListDragSnapToFullscreenThreshold
+                           ? AppListViewState::FULLSCREEN_ALL_APPS
+                           : AppListViewState::CLOSED;
+    } else {
+      if (launcher_above_shelf_bottom_amount_ <=
+          kAppListDragSnapToClosedThreshold)
+        app_list_state = AppListViewState::CLOSED;
+      else if (launcher_above_shelf_bottom_amount_ <=
+               kAppListDragSnapToPeekingThreshold)
+        app_list_state = AppListViewState::PEEKING;
+      else
+        app_list_state = AppListViewState::FULLSCREEN_ALL_APPS;
+    }
+  }
 
   // Keep auto-hide shelf visible if failed to open the app list.
   base::Optional<Shelf::ScopedAutoHideLock> auto_hide_lock;
@@ -1435,15 +1437,15 @@
   if (app_list_state == AppListViewState::CLOSED)
     auto_hide_lock.emplace(shelf_);
   Shell::Get()->app_list_controller()->EndDragFromShelf(app_list_state);
+
   gesture_drag_status_ = GESTURE_DRAG_NONE;
 }
 
 void ShelfLayoutManager::CancelGestureDrag() {
   if (gesture_drag_status_ == GESTURE_DRAG_APPLIST_IN_PROGRESS) {
     HomeLauncherGestureHandler* home_launcher_handler =
-        Shell::Get()->home_screen_controller()->home_launcher_gesture_handler();
-    DCHECK(home_launcher_handler);
-    if (home_launcher_handler->IsDragInProgress())
+        Shell::Get()->app_list_controller()->home_launcher_gesture_handler();
+    if (home_launcher_handler && home_launcher_handler->IsDragInProgress())
       home_launcher_handler->Cancel();
     else
       Shell::Get()->app_list_controller()->DismissAppList();
--- a/ash/shelf/shelf_layout_manager.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/shelf/shelf_layout_manager.h	2019-05-17 18:53:08.244000000 +0300
@@ -9,7 +9,6 @@
 
 #include "ash/app_list/app_list_controller_observer.h"
 #include "ash/ash_export.h"
-#include "ash/home_screen/home_launcher_gesture_handler_observer.h"
 #include "ash/public/cpp/shelf_types.h"
 #include "ash/session/session_observer.h"
 #include "ash/shelf/shelf.h"
@@ -17,7 +16,6 @@
 #include "ash/system/locale/locale_update_controller.h"
 #include "ash/wallpaper/wallpaper_controller_observer.h"
 #include "ash/wm/lock_state_observer.h"
-#include "ash/wm/overview/overview_observer.h"
 #include "ash/wm/wm_snap_to_pixel_layout_manager.h"
 #include "ash/wm/workspace/workspace_types.h"
 #include "base/macros.h"
@@ -53,9 +51,7 @@
 // On mus, widget bounds management is handled by the window manager.
 class ASH_EXPORT ShelfLayoutManager
     : public AppListControllerObserver,
-      public HomeLauncherGestureHandlerObserver,
       public ShellObserver,
-      public OverviewObserver,
       public ::wm::ActivationChangeObserver,
       public keyboard::KeyboardControllerObserver,
       public LockStateObserver,
@@ -65,6 +61,19 @@
       public WallpaperControllerObserver,
       public LocaleChangeObserver {
  public:
+  // The snapping threshold for dragging app list from shelf in tablet mode,
+  // measured in DIPs.
+  static constexpr int kAppListDragSnapToFullscreenThreshold = 320;
+
+  // The snapping thresholds for dragging app list from shelf in laptop mode,
+  // measured in DIPs.
+  static constexpr int kAppListDragSnapToClosedThreshold = 144;
+  static constexpr int kAppListDragSnapToPeekingThreshold = 561;
+
+  // The velocity the app list must be dragged in order to change the state of
+  // the app list for fling event, measured in DIPs/event.
+  static constexpr int kAppListDragVelocityThreshold = 6;
+
   ShelfLayoutManager(ShelfWidget* shelf_widget, Shelf* shelf);
   ~ShelfLayoutManager() override;
 
@@ -146,17 +155,13 @@
   // ShellObserver:
   void OnShelfAutoHideBehaviorChanged(aura::Window* root_window) override;
   void OnPinnedStateChanged(aura::Window* pinned_window) override;
-  void OnSplitViewModeStarted() override;
-  void OnSplitViewModeEnded() override;
-
-  // OverviewObserver:
   void OnOverviewModeStartingAnimationComplete(bool canceled) override;
   void OnOverviewModeEndingAnimationComplete(bool canceled) override;
+  void OnSplitViewModeStarted() override;
+  void OnSplitViewModeEnded() override;
 
   // AppListControllerObserver:
   void OnAppListVisibilityChanged(bool shown, int64_t display_id) override;
-
-  // HomeLauncherGestureHandlerObserver:
   void OnHomeLauncherTargetPositionChanged(bool showing,
                                            int64_t display_id) override;
   void OnHomeLauncherAnimationComplete(bool shown, int64_t display_id) override;
@@ -308,10 +313,6 @@
   // Updates the auto hide state immediately.
   void UpdateAutoHideStateNow();
 
-  // Starts the auto hide timer, so that the shelf will be hidden after the
-  // timeout (unless something else happens to interrupt / reset it).
-  void StartAutoHideTimer();
-
   // Stops the auto hide timer and clears
   // |mouse_over_shelf_when_auto_hide_timer_started_|.
   void StopAutoHideTimer();
@@ -415,11 +416,6 @@
   // False when neither the auto hide timer nor the timer task are running.
   bool mouse_over_shelf_when_auto_hide_timer_started_ = false;
 
-  // Whether the mouse pointer (not the touch pointer) was over the shelf last
-  // time we saw it. This is used to differentiate between mouse and touch in
-  // the shelf autohide behavior.
-  bool last_seen_mouse_position_was_over_shelf_ = false;
-
   base::ObserverList<ShelfLayoutManagerObserver>::Unchecked observers_;
 
   // The shelf reacts to gesture-drags, and can be set to auto-hide for certain
--- a/ash/shelf/shelf_layout_manager_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/shelf/shelf_layout_manager_unittest.cc	2019-05-17 18:53:08.248000000 +0300
@@ -9,11 +9,10 @@
 
 #include "ash/accelerators/accelerator_controller.h"
 #include "ash/accelerators/accelerator_table.h"
+#include "ash/app_list/app_list_controller_impl.h"
+#include "ash/app_list/home_launcher_gesture_handler.h"
 #include "ash/app_list/test/app_list_test_helper.h"
-#include "ash/app_list/views/app_list_view.h"
 #include "ash/focus_cycler.h"
-#include "ash/home_screen/home_launcher_gesture_handler.h"
-#include "ash/home_screen/home_screen_controller.h"
 #include "ash/public/cpp/ash_switches.h"
 #include "ash/public/cpp/immersive/immersive_fullscreen_controller_test_api.h"
 #include "ash/public/cpp/shell_window_ids.h"
@@ -36,11 +35,12 @@
 #include "ash/window_factory.h"
 #include "ash/wm/lock_state_controller.h"
 #include "ash/wm/overview/overview_controller.h"
+#include "ash/wm/splitview/split_view_controller.h"
+#include "ash/wm/splitview/split_view_divider.h"
 #include "ash/wm/tablet_mode/tablet_mode_controller_test_api.h"
 #include "ash/wm/window_state.h"
 #include "ash/wm/window_util.h"
 #include "ash/wm/wm_event.h"
-#include "base/bind.h"
 #include "base/command_line.h"
 #include "base/run_loop.h"
 #include "base/stl_util.h"
@@ -438,18 +438,6 @@
     return true;
   }
 
-  // Performs a swipe up gesture to show an auto-hidden shelf.
-  void SwipeUpToShowShelf() {
-    gfx::Rect display_bounds =
-        display::Screen::GetScreen()->GetPrimaryDisplay().bounds();
-    const gfx::Point start(display_bounds.bottom_center());
-    const gfx::Point end(start + gfx::Vector2d(0, -80));
-    const base::TimeDelta kTimeDelta = base::TimeDelta::FromMilliseconds(100);
-    const int kNumScrollSteps = 4;
-    GetEventGenerator()->GestureScrollSequence(start, end, kTimeDelta,
-                                               kNumScrollSteps);
-  }
-
  private:
   base::TimeTicks timestamp_;
   gfx::Point current_point_;
@@ -850,7 +838,15 @@
   wm::ActivateWindow(window.get());
 
   if (autohide_shelf) {
-    SwipeUpToShowShelf();
+    gfx::Rect display_bounds =
+        display::Screen::GetScreen()->GetPrimaryDisplay().bounds();
+    const gfx::Point start(display_bounds.bottom_center());
+    const gfx::Point end(start + gfx::Vector2d(0, -80));
+    const base::TimeDelta kTimeDelta = base::TimeDelta::FromMilliseconds(100);
+    const int kNumScrollSteps = 4;
+    // Swipe up to show the auto-hide shelf.
+    GetEventGenerator()->GestureScrollSequence(start, end, kTimeDelta,
+                                               kNumScrollSteps);
     EXPECT_EQ(SHELF_AUTO_HIDE_SHOWN, shelf->GetAutoHideState());
   }
 
@@ -871,7 +867,7 @@
   // The home launcher gesture handler should not be handling any window
   // initially.
   HomeLauncherGestureHandler* gesture_handler =
-      Shell::Get()->home_screen_controller()->home_launcher_gesture_handler();
+      Shell::Get()->app_list_controller()->home_launcher_gesture_handler();
   ASSERT_TRUE(gesture_handler);
   ASSERT_FALSE(gesture_handler->GetWindow1());
 
@@ -1283,7 +1279,7 @@
   overview_controller->ToggleOverview();
   EXPECT_EQ(SHELF_AUTO_HIDE, shelf->GetVisibilityState());
   EXPECT_EQ(SHELF_AUTO_HIDE_SHOWN, shelf->GetAutoHideState());
-  EXPECT_EQ(SHELF_BACKGROUND_OVERVIEW, GetShelfWidget()->GetBackgroundType());
+  EXPECT_EQ(SHELF_BACKGROUND_DEFAULT, GetShelfWidget()->GetBackgroundType());
 
   // Test that on exiting overview mode, the shelf returns to auto hide state.
   overview_controller->ToggleOverview();
@@ -1763,9 +1759,9 @@
   // Fling up that exceeds the velocity threshold should show the fullscreen app
   // list.
   StartScroll(start);
-  UpdateScroll(-app_list::AppListView::kDragSnapToPeekingThreshold);
+  UpdateScroll(-ShelfLayoutManager::kAppListDragSnapToPeekingThreshold);
   EndScroll(true /* is_fling */,
-            -(app_list::AppListView::kDragVelocityThreshold + 10));
+            -(ShelfLayoutManager::kAppListDragVelocityThreshold + 10));
   GetAppListTestHelper()->WaitUntilIdle();
   GetAppListTestHelper()->CheckVisibility(true);
   GetAppListTestHelper()->CheckState(
@@ -1778,9 +1774,9 @@
 
   // Fling down that exceeds the velocity threshold should close the app list.
   StartScroll(start);
-  UpdateScroll(-app_list::AppListView::kDragSnapToPeekingThreshold);
+  UpdateScroll(-ShelfLayoutManager::kAppListDragSnapToPeekingThreshold);
   EndScroll(true /* is_fling */,
-            app_list::AppListView::kDragVelocityThreshold + 10);
+            ShelfLayoutManager::kAppListDragVelocityThreshold + 10);
   GetAppListTestHelper()->WaitUntilIdle();
   GetAppListTestHelper()->CheckVisibility(false);
   GetAppListTestHelper()->CheckState(app_list::AppListViewState::CLOSED);
@@ -1788,9 +1784,9 @@
   // Fling the app list not exceed the velocity threshold, the state depends on
   // the drag amount.
   StartScroll(start);
-  UpdateScroll(-(app_list::AppListView::kDragSnapToPeekingThreshold - 10));
+  UpdateScroll(-(ShelfLayoutManager::kAppListDragSnapToPeekingThreshold - 10));
   EndScroll(true /* is_fling */,
-            -(app_list::AppListView::kDragVelocityThreshold - 10));
+            -(ShelfLayoutManager::kAppListDragVelocityThreshold - 10));
   GetAppListTestHelper()->WaitUntilIdle();
   GetAppListTestHelper()->CheckVisibility(true);
   GetAppListTestHelper()->CheckState(app_list::AppListViewState::PEEKING);
@@ -1810,7 +1806,8 @@
                  shelf_widget_bounds.bottom() + 1);
   gfx::Point end = gfx::Point(
       start.x(), shelf_widget_bounds.bottom() -
-                     app_list::AppListView::kDragSnapToPeekingThreshold - 10);
+                     ShelfLayoutManager::kAppListDragSnapToPeekingThreshold -
+                     10);
   ui::test::EventGenerator* generator = GetEventGenerator();
   constexpr base::TimeDelta kTimeDelta = base::TimeDelta::FromMilliseconds(100);
   constexpr int kNumScrollSteps = 4;
@@ -1832,7 +1829,7 @@
   start.set_y(
       display::Screen::GetScreen()->GetPrimaryDisplay().work_area().y());
   end.set_y(shelf_widget_bounds.bottom() -
-            app_list::AppListView::kDragSnapToClosedThreshold + 10);
+            ShelfLayoutManager::kAppListDragSnapToClosedThreshold + 10);
   generator->GestureScrollSequence(start, end, kTimeDelta, kNumScrollSteps);
   GetAppListTestHelper()->WaitUntilIdle();
   GetAppListTestHelper()->CheckVisibility(false);
@@ -1847,7 +1844,7 @@
   EXPECT_EQ(SHELF_VISIBLE, shelf->GetVisibilityState());
 
   StartScroll(GetShelfWidget()->GetWindowBoundsInScreen().CenterPoint());
-  UpdateScroll(-app_list::AppListView::kDragSnapToPeekingThreshold);
+  UpdateScroll(-ShelfLayoutManager::kAppListDragSnapToPeekingThreshold);
   GetAppListTestHelper()->WaitUntilIdle();
   shelf->SetAlignment(SHELF_ALIGNMENT_LEFT);
   // Note, value -10 here has no specific meaning, it only used to make the
@@ -1874,7 +1871,7 @@
   gfx::Vector2d delta;
 
   // Swiping up less than the close threshold should close the app list.
-  delta.set_y(app_list::AppListView::kDragSnapToClosedThreshold - 10);
+  delta.set_y(ShelfLayoutManager::kAppListDragSnapToClosedThreshold - 10);
   gfx::Point end = start - delta;
   generator->GestureScrollSequence(start, end, kTimeDelta, kNumScrollSteps);
   EXPECT_EQ(SHELF_VISIBLE, shelf->GetVisibilityState());
@@ -1884,7 +1881,7 @@
 
   // Swiping up more than the close threshold but less than peeking threshold
   // should keep the app list at PEEKING state.
-  delta.set_y(app_list::AppListView::kDragSnapToPeekingThreshold - 10);
+  delta.set_y(ShelfLayoutManager::kAppListDragSnapToPeekingThreshold - 10);
   end = start - delta;
   generator->GestureScrollSequence(start, end, kTimeDelta, kNumScrollSteps);
   EXPECT_EQ(SHELF_VISIBLE, shelf->GetVisibilityState());
@@ -1899,7 +1896,7 @@
 
   // Swiping up more than the peeking threshold should keep the app list at
   // FULLSCREEN_ALL_APPS state.
-  delta.set_y(app_list::AppListView::kDragSnapToPeekingThreshold + 10);
+  delta.set_y(ShelfLayoutManager::kAppListDragSnapToPeekingThreshold + 10);
   end = start - delta;
   generator->GestureScrollSequence(start, end, kTimeDelta, kNumScrollSteps);
   EXPECT_EQ(SHELF_VISIBLE, shelf->GetVisibilityState());
@@ -1930,7 +1927,7 @@
   // Swiping up on the auto-hide shelf to drag up the app list. Close the app
   // list on drag ended since the short drag distance but keep the previous
   // shown auto-hide shelf still visible.
-  delta.set_y(app_list::AppListView::kDragSnapToClosedThreshold - 10);
+  delta.set_y(ShelfLayoutManager::kAppListDragSnapToClosedThreshold - 10);
   end = start - delta;
   generator->GestureScrollSequence(start, end, kTimeDelta, kNumScrollSteps);
   GetAppListTestHelper()->WaitUntilIdle();
@@ -2368,6 +2365,52 @@
   EXPECT_EQ(SHELF_BACKGROUND_MAXIMIZED, GetShelfWidget()->GetBackgroundType());
 }
 
+// Test the background color for split view mode.
+TEST_F(ShelfLayoutManagerTest, ShelfBackgroundColorInSplitView) {
+  // Split view is only enabled in tablet mode.
+  TabletModeControllerTestApi().EnterTabletMode();
+
+  std::unique_ptr<aura::Window> window1(CreateTestWindow());
+  window1->SetProperty(aura::client::kResizeBehaviorKey,
+                       ws::mojom::kResizeBehaviorCanResize |
+                           ws::mojom::kResizeBehaviorCanMaximize);
+  window1->Show();
+
+  SplitViewController* split_view_controller =
+      Shell::Get()->split_view_controller();
+  split_view_controller->SnapWindow(window1.get(), SplitViewController::LEFT);
+  EXPECT_EQ(SHELF_BACKGROUND_SPLIT_VIEW, GetShelfWidget()->GetBackgroundType());
+
+  std::unique_ptr<aura::Window> window2(CreateTestWindow());
+  window2->SetProperty(aura::client::kResizeBehaviorKey,
+                       ws::mojom::kResizeBehaviorCanResize |
+                           ws::mojom::kResizeBehaviorCanMaximize);
+  window2->Show();
+  split_view_controller->SnapWindow(window2.get(), SplitViewController::RIGHT);
+  EXPECT_EQ(SHELF_BACKGROUND_SPLIT_VIEW, GetShelfWidget()->GetBackgroundType());
+
+  // Should still keep SHELF_BACKGROUND_SPLIT_VIEW when both overview and
+  // splitview are active.
+  wm::WMEvent minimize_event(wm::WM_EVENT_MINIMIZE);
+  wm::GetWindowState(window1.get())->OnWMEvent(&minimize_event);
+  EXPECT_EQ(split_view_controller->IsSplitViewModeActive(), true);
+  EXPECT_EQ(split_view_controller->state(), SplitViewController::RIGHT_SNAPPED);
+  EXPECT_TRUE(Shell::Get()->overview_controller()->IsSelecting());
+  EXPECT_EQ(SHELF_BACKGROUND_SPLIT_VIEW, GetShelfWidget()->GetBackgroundType());
+
+  // Drag the divider to left to end split view mode, which will maximize the
+  // the right snapped window.
+  gfx::Point drag_point = split_view_controller->split_view_divider()
+                              ->GetDividerBoundsInScreen(false)
+                              .CenterPoint();
+  split_view_controller->StartResize(drag_point);
+  drag_point.set_x(0);
+  split_view_controller->EndResize(drag_point);
+
+  EXPECT_FALSE(Shell::Get()->overview_controller()->IsSelecting());
+  EXPECT_EQ(SHELF_BACKGROUND_MAXIMIZED, GetShelfWidget()->GetBackgroundType());
+}
+
 // Verify that the shelf doesn't have the opaque background if it's auto-hide
 // status.
 TEST_F(ShelfLayoutManagerTest, ShelfBackgroundColorAutoHide) {
@@ -2540,101 +2583,6 @@
   EXPECT_TRUE(GetPrimaryUnifiedSystemTray()->IsBubbleShown());
 }
 
-// Tests that swiping up on the AUTO_HIDE_HIDDEN shelf, with various speeds,
-// offsets, and angles, always shows the shelf.
-TEST_F(ShelfLayoutManagerTest, SwipeUpAutoHideHiddenShelf) {
-  ui::test::EventGenerator* generator = GetEventGenerator();
-  Shelf* shelf = GetPrimaryShelf();
-
-  // Create a window so that the shelf will hide.
-  const aura::Window* window = CreateTestWidget()->GetNativeWindow();
-  const gfx::Point tap_to_hide_shelf_location =
-      window->GetBoundsInScreen().CenterPoint();
-  const gfx::Rect display_bounds =
-      display::Screen::GetScreen()->GetPrimaryDisplay().bounds();
-
-  shelf->SetAutoHideBehavior(SHELF_AUTO_HIDE_BEHAVIOR_ALWAYS);
-  ShelfLayoutManager* layout_manager = GetShelfLayoutManager();
-  layout_manager->LayoutShelf();
-  EXPECT_EQ(SHELF_AUTO_HIDE, shelf->GetVisibilityState());
-  EXPECT_EQ(SHELF_AUTO_HIDE_HIDDEN, shelf->GetAutoHideState());
-
-  const int time_deltas[] = {10, 50, 100, 500};
-  const int num_scroll_steps[] = {2, 5, 10, 50};
-  const int y_bezel_start_offsets[] = {5, 10, 50};
-  const int x_offsets[] = {10, 20, 50};
-  const int y_offsets[] = {70, 100, 300, 500};
-
-  for (int time_delta : time_deltas) {
-    for (int num_scroll_steps : num_scroll_steps) {
-      for (int x_offset : x_offsets) {
-        for (int y_offset : y_offsets) {
-          for (int y_bezel_start_offset : y_bezel_start_offsets) {
-            const gfx::Point start(display_bounds.bottom_center() +
-                                   gfx::Vector2d(0, y_bezel_start_offset));
-            const gfx::Point end(start + gfx::Vector2d(x_offset, -y_offset));
-            generator->GestureScrollSequence(
-                start, end, base::TimeDelta::FromMilliseconds(time_delta),
-                num_scroll_steps);
-            EXPECT_EQ(SHELF_AUTO_HIDE_SHOWN, shelf->GetAutoHideState())
-                << "Failure to show shelf after a swipe up in " << time_delta
-                << "ms, " << num_scroll_steps << " steps, "
-                << y_bezel_start_offset << " Y bezel start offset, " << x_offset
-                << " X-offset and " << y_offset << " Y-offset.";
-            generator->GestureTapAt(tap_to_hide_shelf_location);
-            EXPECT_EQ(SHELF_AUTO_HIDE_HIDDEN, shelf->GetAutoHideState());
-          }
-        }
-      }
-    }
-  }
-}
-
-// Tests the auto-hide shelf status when moving the mouse in and out.
-TEST_F(ShelfLayoutManagerTest, AutoHideShelfOnMouseMove) {
-  // Create one window, or the shelf won't auto-hide.
-  CreateTestWidget();
-  Shelf* shelf = GetPrimaryShelf();
-  ui::test::EventGenerator* generator = GetEventGenerator();
-  display::Display display = display::Screen::GetScreen()->GetPrimaryDisplay();
-
-  // Set the shelf to auto-hide.
-  shelf->SetAutoHideBehavior(SHELF_AUTO_HIDE_BEHAVIOR_ALWAYS);
-  ShelfLayoutManager* layout_manager = GetShelfLayoutManager();
-  layout_manager->LayoutShelf();
-  EXPECT_EQ(SHELF_AUTO_HIDE, shelf->GetVisibilityState());
-  EXPECT_EQ(SHELF_AUTO_HIDE_HIDDEN, shelf->GetAutoHideState());
-
-  // Swipe up to show the shelf.
-  SwipeUpToShowShelf();
-  EXPECT_EQ(SHELF_AUTO_HIDE_SHOWN, shelf->GetAutoHideState());
-
-  // Move the mouse far away from the shelf, but without having been on the
-  // shelf first. This isn't technically a mouse-out event, so the shelf should
-  // not hide.
-  generator->MoveMouseTo(0, 0);
-  ASSERT_FALSE(TriggerAutoHideTimeout());
-  EXPECT_EQ(SHELF_AUTO_HIDE_SHOWN, shelf->GetAutoHideState());
-
-  // Now place the mouse on the shelf, then move away. The shelf should hide.
-  generator->MoveMouseTo(1, display.bounds().bottom() - 1);
-  generator->MoveMouseTo(0, 0);
-  ASSERT_TRUE(TriggerAutoHideTimeout());
-  EXPECT_EQ(SHELF_AUTO_HIDE_HIDDEN, shelf->GetAutoHideState());
-
-  // Now let's show the shelf again.
-  SwipeUpToShowShelf();
-  EXPECT_EQ(SHELF_AUTO_HIDE_SHOWN, shelf->GetAutoHideState());
-
-  // Move the mouse away, but move it back within the shelf immediately. The
-  // shelf should remain shown.
-  generator->MoveMouseTo(0, 0);
-  EXPECT_EQ(SHELF_AUTO_HIDE_SHOWN, shelf->GetAutoHideState());
-  generator->MoveMouseTo(1, display.bounds().bottom() - 1);
-  ASSERT_FALSE(TriggerAutoHideTimeout());
-  EXPECT_EQ(SHELF_AUTO_HIDE_SHOWN, shelf->GetAutoHideState());
-}
-
 // Tests the auto-hide shelf status with mouse events.
 TEST_F(ShelfLayoutManagerTest, AutoHideShelfOnMouseEvents) {
   views::Widget* widget = CreateTestWidget();
@@ -2649,11 +2597,17 @@
   EXPECT_EQ(SHELF_AUTO_HIDE, shelf->GetVisibilityState());
   EXPECT_EQ(SHELF_AUTO_HIDE_HIDDEN, shelf->GetAutoHideState());
 
+  gfx::Rect display_bounds =
+      display::Screen::GetScreen()->GetPrimaryDisplay().bounds();
+  const gfx::Point start(display_bounds.bottom_center());
+  const gfx::Point end(start + gfx::Vector2d(0, -80));
+  const base::TimeDelta kTimeDelta = base::TimeDelta::FromMilliseconds(100);
+  const int kNumScrollSteps = 4;
   // Swipe up to show the auto-hide shelf.
-  SwipeUpToShowShelf();
+  generator->GestureScrollSequence(start, end, kTimeDelta, kNumScrollSteps);
   EXPECT_EQ(SHELF_AUTO_HIDE_SHOWN, shelf->GetAutoHideState());
 
-  // Move the mouse should not hide the AUTO_HIDE_SHOWN shelf immediately.
+  // Move the mouse should not hide the AUTO_HIDE_SHOWN shelf.
   generator->MoveMouseTo(5, 5);
   EXPECT_EQ(SHELF_AUTO_HIDE_SHOWN, shelf->GetAutoHideState());
 
--- a/ash/shelf/shelf_locking_manager.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/shelf/shelf_locking_manager.h	2019-05-17 18:53:08.248000000 +0300
@@ -36,7 +36,7 @@
   // Update the shelf state for session and screen lock changes.
   void UpdateLockedState();
 
-  Shelf* const shelf_;
+  Shelf* shelf_;
   bool session_locked_ = false;
   bool screen_locked_ = false;
   ShelfAlignment stored_alignment_;
--- a/ash/shelf/shelf_tooltip_bubble.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/shelf/shelf_tooltip_bubble.cc	2019-05-17 18:53:08.248000000 +0300
@@ -37,7 +37,7 @@
     : ShelfBubble(anchor, alignment, background_color) {
   set_margins(gfx::Insets(kTooltipTopBottomMargin, kTooltipLeftRightMargin));
   set_close_on_deactivate(false);
-  SetCanActivate(false);
+  set_can_activate(false);
   set_accept_events(false);
   set_shadow(views::BubbleBorder::NO_ASSETS);
   SetLayoutManager(std::make_unique<views::FillLayout>());
--- a/ash/shelf/shelf_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/shelf/shelf_unittest.cc	2019-05-17 18:53:08.248000000 +0300
@@ -6,9 +6,7 @@
 
 #include "ash/public/cpp/shelf_model.h"
 #include "ash/root_window_controller.h"
-#include "ash/session/session_controller.h"
 #include "ash/session/test_session_controller_client.h"
-#include "ash/shelf/overflow_button.h"
 #include "ash/shelf/shelf.h"
 #include "ash/shelf/shelf_app_button.h"
 #include "ash/shelf/shelf_controller.h"
@@ -18,7 +16,6 @@
 #include "ash/shell.h"
 #include "ash/test/ash_test_base.h"
 #include "base/strings/string_number_conversions.h"
-#include "base/threading/thread_task_runner_handle.h"
 #include "components/session_manager/session_manager_types.h"
 #include "mojo/public/cpp/bindings/associated_binding.h"
 
@@ -33,13 +30,12 @@
   void SetUp() override {
     AshTestBase::SetUp();
 
-    shelf_view_ = GetPrimaryShelf()->GetShelfViewForTesting();
-    shelf_model_ = shelf_view_->model();
+    ShelfView* shelf_view = GetPrimaryShelf()->GetShelfViewForTesting();
+    shelf_model_ = shelf_view->model();
 
-    test_.reset(new ShelfViewTestAPI(shelf_view_));
+    test_.reset(new ShelfViewTestAPI(shelf_view));
   }
 
-  ShelfView* shelf_view() { return shelf_view_; }
   ShelfModel* shelf_model() { return shelf_model_; }
 
   ShelfViewTestAPI* test_api() { return test_.get(); }
@@ -52,7 +48,6 @@
   }
 
  private:
-  ShelfView* shelf_view_ = nullptr;
   ShelfModel* shelf_model_ = nullptr;
   std::unique_ptr<ShelfViewTestAPI> test_;
 
@@ -109,8 +104,8 @@
   ShelfItem item;
   item.type = TYPE_APP;
   item.status = STATUS_RUNNING;
-  while (!shelf_view()->GetOverflowButton()->visible()) {
-    item.id = ShelfID(base::NumberToString(shelf_model()->item_count()));
+  while (!test_api()->IsOverflowButtonVisible()) {
+    item.id = ShelfID(base::IntToString(shelf_model()->item_count()));
     shelf_model()->Add(item);
     ASSERT_LT(shelf_model()->item_count(), 10000);
   }
@@ -147,31 +142,5 @@
   }
 }
 
-using NoSessionShelfTest = NoSessionAshTestBase;
-
-// Regression test for crash in Shelf::SetAlignment(). https://crbug.com/937495
-TEST_F(NoSessionShelfTest, SetAlignmentDuringDisplayDisconnect) {
-  UpdateDisplay("1024x768,800x600");
-  base::RunLoop().RunUntilIdle();
-
-  // The task indirectly triggers Shelf::SetAlignment() via a SessionObserver.
-  base::ThreadTaskRunnerHandle::Get()->PostTask(
-      FROM_HERE,
-      base::BindOnce(
-          [](TestSessionControllerClient* session) {
-            session->SetSessionState(session_manager::SessionState::ACTIVE);
-          },
-          GetSessionControllerClient()));
-
-  // Remove the secondary display.
-  UpdateDisplay("1280x1024");
-
-  // The session activation task runs before the RootWindowController and the
-  // Shelf are deleted.
-  base::RunLoop().RunUntilIdle();
-
-  // No crash.
-}
-
 }  // namespace
 }  // namespace ash
--- a/ash/shelf/shelf_view.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/shelf/shelf_view.cc	2019-05-17 18:53:08.248000000 +0300
@@ -8,7 +8,6 @@
 #include <memory>
 
 #include "ash/drag_drop/drag_image_view.h"
-#include "ash/focus_cycler.h"
 #include "ash/metrics/user_metrics_recorder.h"
 #include "ash/public/cpp/ash_constants.h"
 #include "ash/public/cpp/shelf_item_delegate.h"
@@ -34,12 +33,10 @@
 #include "ash/system/model/system_tray_model.h"
 #include "ash/system/model/virtual_keyboard_model.h"
 #include "ash/system/status_area_widget.h"
-#include "ash/system/status_area_widget_delegate.h"
 #include "ash/wm/mru_window_tracker.h"
 #include "ash/wm/root_window_finder.h"
 #include "ash/wm/tablet_mode/tablet_mode_controller.h"
 #include "base/auto_reset.h"
-#include "base/bind.h"
 #include "base/containers/adapters.h"
 #include "base/metrics/histogram_macros.h"
 #include "base/strings/utf_string_conversions.h"
@@ -56,7 +53,6 @@
 #include "ui/gfx/canvas.h"
 #include "ui/gfx/geometry/point.h"
 #include "ui/keyboard/keyboard_controller.h"
-#include "ui/strings/grit/ui_strings.h"
 #include "ui/views/animation/bounds_animator.h"
 #include "ui/views/animation/ink_drop.h"
 #include "ui/views/border.h"
@@ -206,7 +202,7 @@
       new_index = 0;
 
     if (new_index >= overflow_cutoff)
-      shelf_view_->shelf_widget()->set_activated_from_other_widget(true);
+      shelf_view_->shelf_widget()->set_activated_from_overflow_bubble(true);
     return focusable_views[new_index];
   }
 
@@ -334,12 +330,8 @@
   DCHECK(shelf_widget_);
   Shell::Get()->tablet_mode_controller()->AddObserver(this);
   Shell::Get()->system_tray_model()->virtual_keyboard()->AddObserver(this);
-  Shell::Get()->AddShellObserver(this);
   bounds_animator_->AddObserver(this);
   set_context_menu_controller(this);
-
-  announcement_view_ = new views::View();
-  AddChildView(announcement_view_);
 }
 
 ShelfView::~ShelfView() {
@@ -347,7 +339,6 @@
   if (Shell::Get()->tablet_mode_controller())
     Shell::Get()->tablet_mode_controller()->RemoveObserver(this);
   Shell::Get()->system_tray_model()->virtual_keyboard()->RemoveObserver(this);
-  Shell::Get()->RemoveShellObserver(this);
   bounds_animator_->RemoveObserver(this);
   model_->RemoveObserver(this);
 }
@@ -388,6 +379,26 @@
   // We'll layout when our bounds change.
 }
 
+void ShelfView::OnShelfAlignmentChanged() {
+  LayoutToIdealBounds();
+  for (int i = 0; i < view_model_->view_size(); ++i) {
+    if (i >= first_visible_index_ && i <= last_visible_index_)
+      view_model_->view_at(i)->Layout();
+  }
+  tooltip_.Close();
+  if (overflow_bubble_)
+    overflow_bubble_->Hide();
+  // For crbug.com/587931, because AppListButton layout logic is in OnPaint.
+  AppListButton* app_list_button = GetAppListButton();
+  if (app_list_button)
+    app_list_button->SchedulePaint();
+
+  if (GetFocusManager()) {
+    GetFocusManager()->set_arrow_key_traversal_enabled_for_widget(
+        !shelf_->IsHorizontalAlignment());
+  }
+}
+
 gfx::Rect ShelfView::GetIdealBoundsOfItemIcon(const ShelfID& id) {
   int index = model_->ItemIndexByID(id);
   if (index < 0 || last_visible_index_ < 0 || index >= view_model_->view_size())
@@ -610,10 +621,8 @@
 
   // None of the checks in ShouldEventActivateButton() affects overflow button.
   // So, it is safe to be checked after handling overflow button.
-  if (!ShouldEventActivateButton(sender, event)) {
-    ink_drop->SnapToHidden();
+  if (!ShouldEventActivateButton(sender, event))
     return;
-  }
 
   // Prevent concurrent requests that may show application or context menus.
   // If a second request is sent before the first one can respond, the Chrome
@@ -645,9 +654,9 @@
   scoped_root_window_for_new_windows_ =
       std::make_unique<ScopedRootWindowForNewWindows>(window->GetRootWindow());
 
-  // Slow down activation animations if Control key is pressed.
+  // Slow down activation animations if shift key is pressed.
   std::unique_ptr<ui::ScopedAnimationDurationScaleMode> slowing_animations;
-  if (event.IsControlDown()) {
+  if (event.IsShiftDown()) {
     slowing_animations.reset(new ui::ScopedAnimationDurationScaleMode(
         ui::ScopedAnimationDurationScaleMode::SLOW_DURATION));
   }
@@ -686,7 +695,7 @@
   // Notify the item of its selection; handle the result in AfterItemSelected.
   item_awaiting_response_ = item.id;
   model_->GetShelfItemDelegate(item.id)->ItemSelected(
-      ui::Event::Clone(event), GetDisplayIdForView(this), LAUNCH_FROM_SHELF,
+      ui::Event::Clone(event), GetDisplayIdForView(this), LAUNCH_FROM_UNKNOWN,
       base::BindOnce(&ShelfView::AfterItemSelected, weak_factory_.GetWeakPtr(),
                      item, sender, base::Passed(ui::Event::Clone(event)),
                      ink_drop));
@@ -818,47 +827,6 @@
   return open_windows;
 }
 
-views::View* ShelfView::FindFirstFocusableChild() {
-  if (is_overflow_mode())
-    return main_shelf()->FindFirstFocusableChild();
-  return view_model_->view_at(first_visible_index());
-}
-
-views::View* ShelfView::FindLastFocusableChild() {
-  if (IsShowingOverflowBubble())
-    return overflow_shelf()->FindLastFocusableChild();
-  return overflow_button_->visible()
-             ? overflow_button_
-             : view_model_->view_at(last_visible_index());
-}
-
-views::View* ShelfView::FindFirstOrLastFocusableChild(bool last) {
-  return last ? FindLastFocusableChild() : FindFirstFocusableChild();
-}
-
-void ShelfView::OnShelfButtonAboutToRequestFocusFromTabTraversal(
-    ShelfButton* button,
-    bool reverse) {
-  if (is_overflow_mode()) {
-    main_shelf()->OnShelfButtonAboutToRequestFocusFromTabTraversal(button,
-                                                                   reverse);
-    return;
-  }
-
-  // The logic here seems backwards, but is actually correct. For instance if
-  // the ShelfView's internal focus cycling logic attemmpts to focus the first
-  // child (e.g. app list button) after hitting Tab, we intercept that and
-  // instead, advance through to the status area.
-  if ((reverse && button == FindLastFocusableChild()) ||
-      (!reverse && button == FindFirstFocusableChild())) {
-    StatusAreaWidget* status_area_widget =
-        Shelf::ForWindow(GetWidget()->GetNativeWindow())->GetStatusAreaWidget();
-    status_area_widget->status_area_widget_delegate()
-        ->set_default_last_focusable_child(reverse);
-    Shell::Get()->focus_cycler()->FocusWidget(status_area_widget);
-  }
-}
-
 void ShelfView::DestroyDragIconProxy() {
   drag_image_.reset();
   drag_image_offset_ = gfx::Vector2d(0, 0);
@@ -1236,13 +1204,6 @@
       IndexOfLastItemThatFitsSize(available_size - button_spacing);
   bool show_overflow = last_visible_index_ < model_->item_count() - 1;
 
-  // In the main shelf, the first visible index is either the back button (in
-  // tablet mode) or the launcher button (otherwise).
-  if (!is_overflow_mode()) {
-    first_visible_index_ =
-        IsTabletModeEnabled() ? kBackButtonIndex : kAppListButtonIndex;
-  }
-
   // Create space for the overflow button and place it in the last visible
   // position.
   if (show_overflow && last_visible_index_ > 0)
@@ -1797,8 +1758,7 @@
   overflow_view->overflow_mode_ = true;
   overflow_view->Init();
   overflow_view->set_owner_overflow_bubble(overflow_bubble_.get());
-  overflow_view->OnShelfAlignmentChanged(
-      GetWidget()->GetNativeWindow()->GetRootWindow());
+  overflow_view->OnShelfAlignmentChanged();
   overflow_view->main_shelf_ = this;
   UpdateOverflowRange(overflow_view);
 
@@ -1861,41 +1821,6 @@
   return gfx::Rect(origin, gfx::Size());
 }
 
-void ShelfView::AnnounceShelfAlignment() {
-  base::string16 announcement;
-  switch (shelf_->alignment()) {
-    case SHELF_ALIGNMENT_BOTTOM:
-    case SHELF_ALIGNMENT_BOTTOM_LOCKED:
-      announcement = l10n_util::GetStringUTF16(IDS_SHELF_ALIGNMENT_BOTTOM);
-      break;
-    case SHELF_ALIGNMENT_LEFT:
-      announcement = l10n_util::GetStringUTF16(IDS_SHELF_ALIGNMENT_LEFT);
-      break;
-    case SHELF_ALIGNMENT_RIGHT:
-      announcement = l10n_util::GetStringUTF16(IDS_SHELF_ALIGNMENT_RIGHT);
-      break;
-  }
-  announcement_view_->GetViewAccessibility().OverrideName(announcement);
-  announcement_view_->NotifyAccessibilityEvent(ax::mojom::Event::kAlert, true);
-}
-
-void ShelfView::AnnounceShelfAutohideBehavior() {
-  base::string16 announcement;
-  switch (shelf_->auto_hide_behavior()) {
-    case SHELF_AUTO_HIDE_BEHAVIOR_ALWAYS:
-      announcement = l10n_util::GetStringUTF16(IDS_SHELF_STATE_AUTO_HIDE);
-      break;
-    case SHELF_AUTO_HIDE_BEHAVIOR_NEVER:
-      announcement = l10n_util::GetStringUTF16(IDS_SHELF_STATE_ALWAYS_SHOWN);
-      break;
-    case SHELF_AUTO_HIDE_ALWAYS_HIDDEN:
-      announcement = l10n_util::GetStringUTF16(IDS_SHELF_STATE_ALWAYS_HIDDEN);
-      break;
-  }
-  announcement_view_->GetViewAccessibility().OverrideName(announcement);
-  announcement_view_->NotifyAccessibilityEvent(ax::mojom::Event::kAlert, true);
-}
-
 gfx::Rect ShelfView::GetBoundsForDragInsertInScreen() {
   gfx::Size preferred_size;
   if (is_overflow_mode()) {
@@ -2154,32 +2079,6 @@
   button->SchedulePaint();
 }
 
-void ShelfView::OnShelfAlignmentChanged(aura::Window* root_window) {
-  LayoutToIdealBounds();
-  for (int i = 0; i < view_model_->view_size(); ++i) {
-    if (i >= first_visible_index_ && i <= last_visible_index_)
-      view_model_->view_at(i)->Layout();
-  }
-  tooltip_.Close();
-  if (overflow_bubble_)
-    overflow_bubble_->Hide();
-  // For crbug.com/587931, because AppListButton layout logic is in OnPaint.
-  AppListButton* app_list_button = GetAppListButton();
-  if (app_list_button)
-    app_list_button->SchedulePaint();
-
-  if (GetFocusManager()) {
-    GetFocusManager()->set_arrow_key_traversal_enabled_for_widget(
-        !shelf_->IsHorizontalAlignment());
-  }
-
-  AnnounceShelfAlignment();
-}
-
-void ShelfView::OnShelfAutoHideBehaviorChanged(aura::Window* root_window) {
-  AnnounceShelfAutohideBehavior();
-}
-
 void ShelfView::AfterItemSelected(
     const ShelfItem& item,
     views::Button* sender,
@@ -2229,7 +2128,7 @@
            source_type);
 }
 
-void ShelfView::ShowContextMenuForViewImpl(views::View* source,
+void ShelfView::ShowContextMenuForView(views::View* source,
                                            const gfx::Point& point,
                                            ui::MenuSourceType source_type) {
   // Prevent concurrent requests that may show application or context menus.
--- a/ash/shelf/shelf_view.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/shelf/shelf_view.h	2019-05-17 18:53:08.248000000 +0300
@@ -18,14 +18,12 @@
 #include "ash/shelf/overflow_bubble_view.h"
 #include "ash/shelf/shelf_button_pressed_metric_tracker.h"
 #include "ash/shelf/shelf_tooltip_manager.h"
-#include "ash/shell_observer.h"
 #include "ash/system/model/virtual_keyboard_model.h"
 #include "ash/wm/tablet_mode/tablet_mode_observer.h"
 #include "base/macros.h"
 #include "base/memory/weak_ptr.h"
 #include "base/timer/timer.h"
 #include "third_party/skia/include/core/SkColor.h"
-#include "ui/views/accessibility/view_accessibility.h"
 #include "ui/views/animation/bounds_animator_observer.h"
 #include "ui/views/animation/ink_drop_state.h"
 #include "ui/views/context_menu_controller.h"
@@ -54,7 +52,6 @@
 class ScopedRootWindowForNewWindows;
 class Shelf;
 class ShelfAppButton;
-class ShelfButton;
 class ShelfModel;
 struct ShelfItem;
 class ShelfMenuModelAdapter;
@@ -114,7 +111,6 @@
 
 class ASH_EXPORT ShelfView : public views::View,
                              public ShelfModelObserver,
-                             public ShellObserver,
                              public InkDropButtonListener,
                              public views::ContextMenuController,
                              public views::FocusTraversable,
@@ -131,6 +127,8 @@
 
   void Init();
 
+  void OnShelfAlignmentChanged();
+
   // Returns the ideal bounds of the specified item, or an empty rect if id
   // isn't know. If the item is in an overflow shelf, the overflow icon location
   // will be returned.
@@ -265,21 +263,6 @@
   const std::vector<aura::Window*> GetOpenWindowsForShelfView(
       views::View* view);
 
-  // The three methods below return the first or last focusable child of the
-  // set including both the main shelf and the overflow shelf it it's showing.
-  // - The first focusable child is either the app list button, or the back
-  //   button in tablet mode.
-  // - The last focusable child can be either 1) the last app icon on the main
-  //   shelf if there aren't enough apps to overflow, 2) the overflow button
-  //   if it's visible but the overflow bubble isn't showing, or 3) the last
-  //   app icon in the overflow bubble if it's showing.
-  views::View* FindFirstOrLastFocusableChild(bool last);
-  views::View* FindFirstFocusableChild();
-  views::View* FindLastFocusableChild();
-
-  void OnShelfButtonAboutToRequestFocusFromTabTraversal(ShelfButton* button,
-                                                        bool reverse);
-
   // Return the view model for test purposes.
   const views::ViewModel* view_model_for_test() const {
     return view_model_.get();
@@ -426,9 +409,6 @@
                               const gfx::Point& location,
                               bool context_menu) const;
 
-  void AnnounceShelfAlignment();
-  void AnnounceShelfAutohideBehavior();
-
   // Overridden from ui::EventHandler:
   void OnGestureEvent(ui::GestureEvent* event) override;
   bool OnMouseWheel(const ui::MouseWheelEvent& event) override;
@@ -443,10 +423,6 @@
                                 ShelfItemDelegate* delegate) override;
   void ShelfItemStatusChanged(const ShelfID& id) override;
 
-  // Overridden from ShellObserver:
-  void OnShelfAlignmentChanged(aura::Window* root_window) override;
-  void OnShelfAutoHideBehaviorChanged(aura::Window* root_window) override;
-
   // Handles the result when querying ShelfItemDelegates for context menu items.
   // Shows a default shelf context menu with optional extra custom |menu_items|.
   void AfterGetContextMenuItems(const ShelfID& shelf_id,
@@ -466,7 +442,7 @@
       base::Optional<std::vector<mojom::MenuItemPtr>> menu_items);
 
   // Overridden from views::ContextMenuController:
-  void ShowContextMenuForViewImpl(views::View* source,
+  void ShowContextMenuForView(views::View* source,
                                   const gfx::Point& point,
                                   ui::MenuSourceType source_type) override;
 
@@ -524,12 +500,9 @@
   // item in |model_|.
   std::unique_ptr<views::ViewModel> view_model_;
 
-  // Index of the first visible launcher item. This is either:
-  // * 0 (back button) for the main shelf when tablet mode is on
-  // * 1 (app list button) for the main shelf when tablet mode is off
-  // * > 1 when this shelf view is the overflow shelf view and only shows a
-  //   subset of items.
-  mutable int first_visible_index_ = 0;
+  // Index of the first visible launcher item. This is not always zero because
+  // the overflow view (also a kind of shelf view) only shows a subset of items.
+  int first_visible_index_ = 0;
 
   // Last index of a launcher button that is visible
   // (does not go into overflow).
@@ -649,10 +622,6 @@
   // Owned by the view hierarchy.
   views::View* back_and_app_list_background_ = nullptr;
 
-  // A view used to make accessibility announcements (changes in the shelf's
-  // alignment or auto-hide state).
-  views::View* announcement_view_ = nullptr;  // Owned by ShelfView
-
   // For dragging: -1 if scrolling back, 1 if scrolling forward, 0 if neither.
   int drag_scroll_dir_ = 0;
 
--- a/ash/shelf/shelf_view_test_api.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/shelf/shelf_view_test_api.cc	2019-05-17 18:53:08.248000000 +0300
@@ -59,6 +59,18 @@
   return shelf_view_->view_model_->view_at(index);
 }
 
+int ShelfViewTestAPI::GetFirstVisibleIndex() {
+  return shelf_view_->first_visible_index_;
+}
+
+int ShelfViewTestAPI::GetLastVisibleIndex() {
+  return shelf_view_->last_visible_index_;
+}
+
+bool ShelfViewTestAPI::IsOverflowButtonVisible() {
+  return shelf_view_->overflow_button_->visible();
+}
+
 void ShelfViewTestAPI::ShowOverflowBubble() {
   DCHECK(!shelf_view_->IsShowingOverflowBubble());
   shelf_view_->ToggleOverflowBubble();
@@ -69,6 +81,10 @@
   shelf_view_->ToggleOverflowBubble();
 }
 
+bool ShelfViewTestAPI::IsShowingOverflowBubble() const {
+  return shelf_view_->IsShowingOverflowBubble();
+}
+
 const gfx::Rect& ShelfViewTestAPI::GetBoundsByIndex(int index) {
   return shelf_view_->view_model_->view_at(index)->bounds();
 }
@@ -119,6 +135,10 @@
   return shelf_view_->overflow_bubble_.get();
 }
 
+OverflowButton* ShelfViewTestAPI::overflow_button() const {
+  return shelf_view_->overflow_button_;
+}
+
 ShelfTooltipManager* ShelfViewTestAPI::tooltip_manager() {
   return &shelf_view_->tooltip_;
 }
--- a/ash/shelf/shelf_view_test_api.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/shelf/shelf_view_test_api.h	2019-05-17 18:53:08.248000000 +0300
@@ -20,6 +20,7 @@
 
 namespace ash {
 class OverflowBubble;
+class OverflowButton;
 class ShelfAppButton;
 class ShelfButtonPressedMetricTracker;
 class ShelfTooltipManager;
@@ -41,16 +42,28 @@
   // Retrieve the view at |index|.
   views::View* GetViewAt(int index);
 
+  // First visible button index.
+  int GetFirstVisibleIndex();
+
+  // Last visible button index.
+  int GetLastVisibleIndex();
+
   // Gets current/ideal bounds for button at |index|.
   const gfx::Rect& GetBoundsByIndex(int index);
   const gfx::Rect& GetIdealBoundsByIndex(int index);
 
+  // Returns true if overflow button is visible.
+  bool IsOverflowButtonVisible();
+
   // Makes shelf view show its overflow bubble.
   void ShowOverflowBubble();
 
   // Makes shelf view hide its overflow bubble.
   void HideOverflowBubble();
 
+  // Returns true if the overflow bubble is visible.
+  bool IsShowingOverflowBubble() const;
+
   // An accessor for the |bounds_animator_| duration.
   int GetAnimationDuration() const;
 
@@ -78,6 +91,9 @@
   // An accessor for overflow bubble.
   OverflowBubble* overflow_bubble();
 
+  // An accessor for overflow button.
+  OverflowButton* overflow_button() const;
+
   // Returns minimum distance before drag starts.
   int GetMinimumDragDistance() const;
 
--- a/ash/shelf/shelf_view_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/shelf/shelf_view_unittest.cc	2019-05-17 18:53:08.248000000 +0300
@@ -90,16 +90,6 @@
   return display::Screen::GetScreen()->GetPrimaryDisplay().id();
 }
 
-void ExpectFocused(views::View* view) {
-  EXPECT_TRUE(view->GetWidget()->IsActive());
-  EXPECT_TRUE(view->Contains(view->GetFocusManager()->GetFocusedView()));
-}
-
-void ExpectNotFocused(views::View* view) {
-  EXPECT_FALSE(view->GetWidget()->IsActive());
-  EXPECT_FALSE(view->Contains(view->GetFocusManager()->GetFocusedView()));
-}
-
 class TestShelfObserver : public ShelfObserver {
  public:
   explicit TestShelfObserver(Shelf* shelf) : shelf_(shelf) {
@@ -289,7 +279,7 @@
     AshTestBase::TearDown();
   }
 
-  std::string GetNextAppId() { return base::NumberToString(id_); }
+  std::string GetNextAppId() { return base::IntToString(id_); }
 
  protected:
   // Add shelf items of various types, and optionally wait for animations.
@@ -299,7 +289,7 @@
     if (type == TYPE_APP)
       item.status = STATUS_RUNNING;
 
-    item.id = ShelfID(base::NumberToString(id_++));
+    item.id = ShelfID(base::IntToString(id_++));
     model_->Add(item);
     // Set a delegate; some tests require one to select the item.
     model_->SetShelfItemDelegate(item.id,
@@ -355,7 +345,7 @@
   }
 
   void VerifyShelfItemBoundsAreValid() {
-    for (int i = 0; i <= shelf_view_->last_visible_index(); ++i) {
+    for (int i = 0; i <= test_api_->GetLastVisibleIndex(); ++i) {
       if (test_api_->GetButton(i)) {
         gfx::Rect shelf_view_bounds = shelf_view_->GetLocalBounds();
         gfx::Rect item_bounds = test_api_->GetBoundsByIndex(i);
@@ -511,7 +501,7 @@
 
   void AddButtonsUntilOverflow() {
     int items_added = 0;
-    while (!shelf_view_->GetOverflowButton()->visible()) {
+    while (!test_api_->IsOverflowButtonVisible()) {
       AddAppShortcut();
       ++items_added;
       ASSERT_LT(items_added, 10000);
@@ -526,11 +516,10 @@
   void TestDraggingAnItemFromShelfToOtherShelf(bool main_to_overflow,
                                                bool cancel) {
     test_api_->ShowOverflowBubble();
-    ASSERT_TRUE(shelf_view_->IsShowingOverflowBubble());
+    ASSERT_TRUE(test_api_->IsShowingOverflowBubble());
 
     ShelfViewTestAPI test_api_for_overflow(
         test_api_->overflow_bubble()->bubble_view()->shelf_view());
-    const ShelfView* overflow_shelf_view = shelf_view_->overflow_shelf();
 
     int total_item_count = model_->item_count();
 
@@ -538,29 +527,24 @@
     // completed. These ids are set assuming the both the main shelf and
     // overflow shelf has more than 3 items.
     ShelfID last_visible_item_id_in_shelf =
-        GetItemId(shelf_view_->last_visible_index());
+        GetItemId(test_api_->GetLastVisibleIndex());
     ShelfID second_last_visible_item_id_in_shelf =
-        GetItemId(shelf_view_->last_visible_index() - 1);
+        GetItemId(test_api_->GetLastVisibleIndex() - 1);
     ShelfID first_visible_item_id_in_overflow =
-        GetItemId(overflow_shelf_view->first_visible_index());
+        GetItemId(test_api_for_overflow.GetFirstVisibleIndex());
     ShelfID second_last_visible_item_id_in_overflow =
-        GetItemId(overflow_shelf_view->last_visible_index() - 1);
+        GetItemId(test_api_for_overflow.GetLastVisibleIndex() - 1);
 
     // |src_api| represents the test api of the shelf we are moving the item
     // from. |dest_api| represents the test api of the shelf we are moving the
     // item too.
     ShelfViewTestAPI* src_api =
         main_to_overflow ? test_api_.get() : &test_api_for_overflow;
-    const ShelfView* src_shelf_view =
-        main_to_overflow ? shelf_view_ : overflow_shelf_view;
     ShelfViewTestAPI* dest_api =
         main_to_overflow ? &test_api_for_overflow : test_api_.get();
-    const ShelfView* dest_shelf_view =
-        main_to_overflow ? overflow_shelf_view : shelf_view_;
 
     // Set the item to be dragged depending on |main_to_overflow|.
-    int drag_item_index =
-        main_to_overflow ? 3 : src_shelf_view->last_visible_index();
+    int drag_item_index = main_to_overflow ? 3 : src_api->GetLastVisibleIndex();
     ShelfID drag_item_id = GetItemId(drag_item_index);
     ShelfAppButton* drag_button = src_api->GetButton(drag_item_index);
     gfx::Point center_point_of_drag_item = GetButtonCenter(drag_button);
@@ -577,8 +561,7 @@
     ASSERT_FALSE(src_api->DraggedItemToAnotherShelf());
 
     // Move a dragged item into the destination shelf at |drop_index|.
-    int drop_index =
-        main_to_overflow ? dest_shelf_view->last_visible_index() : 3;
+    int drop_index = main_to_overflow ? dest_api->GetLastVisibleIndex() : 3;
     ShelfAppButton* drop_button = dest_api->GetButton(drop_index);
     gfx::Point drop_point = GetButtonCenter(drop_button);
     // To insert at |drop_index|, a smaller x-axis value of |drop_point|
@@ -610,13 +593,13 @@
     if (cancel) {
       // Item ids should remain unchanged if operation was canceled.
       EXPECT_EQ(last_visible_item_id_in_shelf,
-                GetItemId(shelf_view_->last_visible_index()));
+                GetItemId(test_api_->GetLastVisibleIndex()));
       EXPECT_EQ(second_last_visible_item_id_in_shelf,
-                GetItemId(shelf_view_->last_visible_index() - 1));
+                GetItemId(test_api_->GetLastVisibleIndex() - 1));
       EXPECT_EQ(first_visible_item_id_in_overflow,
-                GetItemId(overflow_shelf_view->first_visible_index()));
+                GetItemId(test_api_for_overflow.GetFirstVisibleIndex()));
       EXPECT_EQ(second_last_visible_item_id_in_overflow,
-                GetItemId(overflow_shelf_view->last_visible_index() - 1));
+                GetItemId(test_api_for_overflow.GetLastVisibleIndex() - 1));
     } else {
       EXPECT_EQ(drag_item_id, GetItemId(drop_index));
       EXPECT_EQ(total_item_count, model_->item_count());
@@ -630,11 +613,11 @@
         // item on the main shelf.
         // 3) The dragged item should now be the last item on the main shelf.
         EXPECT_EQ(last_visible_item_id_in_shelf,
-                  GetItemId(shelf_view_->last_visible_index() - 1));
+                  GetItemId(test_api_->GetLastVisibleIndex() - 1));
         EXPECT_EQ(first_visible_item_id_in_overflow,
-                  GetItemId(shelf_view_->last_visible_index()));
+                  GetItemId(test_api_->GetLastVisibleIndex()));
         EXPECT_EQ(drag_item_id,
-                  GetItemId(overflow_shelf_view->last_visible_index()));
+                  GetItemId(test_api_for_overflow.GetLastVisibleIndex()));
       } else {
         // If we move an item from the overflow shelf to the main shelf, the
         // following should happen:
@@ -648,13 +631,13 @@
         // last item on the overflow shelf (since there are 3 items on the
         // overflow shelf).
         EXPECT_EQ(last_visible_item_id_in_shelf,
-                  GetItemId(overflow_shelf_view->first_visible_index()));
+                  GetItemId(test_api_for_overflow.GetFirstVisibleIndex()));
         EXPECT_EQ(second_last_visible_item_id_in_shelf,
-                  GetItemId(shelf_view_->last_visible_index()));
+                  GetItemId(test_api_->GetLastVisibleIndex()));
         EXPECT_EQ(first_visible_item_id_in_overflow,
-                  GetItemId(overflow_shelf_view->first_visible_index() + 1));
+                  GetItemId(test_api_for_overflow.GetFirstVisibleIndex() + 1));
         EXPECT_EQ(second_last_visible_item_id_in_overflow,
-                  GetItemId(overflow_shelf_view->last_visible_index()));
+                  GetItemId(test_api_for_overflow.GetLastVisibleIndex()));
       }
     }
     test_api_->HideOverflowBubble();
@@ -720,10 +703,10 @@
             shelf_view_->GetBackButton()->GetMirroredBounds());
 
   // Just items in the overflow area return the overflow button's ideal bounds.
-  EXPECT_NE(bounds_1, shelf_view_->GetOverflowButton()->GetMirroredBounds());
+  EXPECT_NE(bounds_1, test_api_->overflow_button()->GetMirroredBounds());
   EXPECT_TRUE(GetButtonByID(id_1)->GetMirroredBounds().Contains(bounds_1));
-  EXPECT_EQ(bounds_2, shelf_view_->GetOverflowButton()->GetMirroredBounds());
-  EXPECT_EQ(bounds_3, shelf_view_->GetOverflowButton()->GetMirroredBounds());
+  EXPECT_EQ(bounds_2, test_api_->overflow_button()->GetMirroredBounds());
+  EXPECT_EQ(bounds_3, test_api_->overflow_button()->GetMirroredBounds());
 }
 
 // Checks that shelf view contents are considered in the correct drag group.
@@ -748,12 +731,12 @@
 // platform app button is hidden.
 TEST_F(ShelfViewTest, AddBrowserUntilOverflow) {
   // All buttons should be visible.
-  ASSERT_EQ(test_api_->GetButtonCount(), shelf_view_->last_visible_index() + 1);
+  ASSERT_EQ(test_api_->GetButtonCount(), test_api_->GetLastVisibleIndex() + 1);
 
   // Add platform app button until overflow.
   int items_added = 0;
   ShelfID last_added = AddApp();
-  while (!shelf_view_->GetOverflowButton()->visible()) {
+  while (!test_api_->IsOverflowButtonVisible()) {
     // Added button is visible after animation while in this loop.
     EXPECT_TRUE(GetButtonByID(last_added)->visible());
 
@@ -766,44 +749,19 @@
   EXPECT_FALSE(GetButtonByID(last_added)->visible());
 }
 
-TEST_F(ShelfViewTest, OverflowVisibleIndex) {
-  AddButtonsUntilOverflow();
-  ASSERT_TRUE(shelf_view_->GetOverflowButton()->visible());
-  const int last_visible_index = shelf_view_->last_visible_index();
-
-  test_api_->ShowOverflowBubble();
-  auto overflow_test_api = std::make_unique<ShelfViewTestAPI>(
-      shelf_view_->overflow_bubble()->bubble_view()->shelf_view());
-  base::RunLoop().RunUntilIdle();
-
-  // Opening overflow doesn't change last visible index.
-  EXPECT_EQ(last_visible_index, shelf_view_->last_visible_index());
-
-  test_api_->HideOverflowBubble();
-  AddAppShortcut();
-  test_api_->ShowOverflowBubble();
-  overflow_test_api = std::make_unique<ShelfViewTestAPI>(
-      shelf_view_->overflow_bubble()->bubble_view()->shelf_view());
-  base::RunLoop().RunUntilIdle();
-
-  // Adding another shortcut should go into overflow bubble and not change
-  // shelf index.
-  EXPECT_EQ(last_visible_index, shelf_view_->last_visible_index());
-}
-
 // Adds one platform app button then adds app shortcut until overflow. Verifies
 // that the browser button gets hidden on overflow and last added app shortcut
 // is still visible.
 TEST_F(ShelfViewTest, AddAppShortcutWithBrowserButtonUntilOverflow) {
   // All buttons should be visible.
-  ASSERT_EQ(test_api_->GetButtonCount(), shelf_view_->last_visible_index() + 1);
+  ASSERT_EQ(test_api_->GetButtonCount(), test_api_->GetLastVisibleIndex() + 1);
 
   ShelfID browser_button_id = AddApp();
 
   // Add app shortcut until overflow.
   int items_added = 0;
   ShelfID last_added = AddAppShortcut();
-  while (!shelf_view_->GetOverflowButton()->visible()) {
+  while (!test_api_->IsOverflowButtonVisible()) {
     // Added button is visible after animation while in this loop.
     EXPECT_TRUE(GetButtonByID(last_added)->visible());
 
@@ -821,7 +779,7 @@
 TEST_F(ShelfViewTest, AssertNoButtonsOverlap) {
   std::vector<ShelfID> button_ids;
   // Add app icons until the overflow button is visible.
-  while (!shelf_view_->GetOverflowButton()->visible()) {
+  while (!test_api_->IsOverflowButtonVisible()) {
     ShelfID id = AddApp();
     button_ids.push_back(id);
   }
@@ -834,7 +792,7 @@
     RemoveByID(id);
     button_ids.pop_back();
   }
-  EXPECT_FALSE(shelf_view_->GetOverflowButton()->visible());
+  EXPECT_FALSE(test_api_->IsOverflowButtonVisible());
   EXPECT_TRUE(GetButtonByID(button_ids.back())->visible());
 
   // Add 20 app icons, and expect to have overflow.
@@ -843,7 +801,7 @@
     button_ids.push_back(id);
   }
   ASSERT_LT(button_ids.size(), 10000U);
-  EXPECT_TRUE(shelf_view_->GetOverflowButton()->visible());
+  EXPECT_TRUE(test_api_->IsOverflowButtonVisible());
 
   // Test that any two successive visible icons never overlap in all shelf
   // alignment types.
@@ -874,13 +832,13 @@
 // chevron is gone.
 TEST_F(ShelfViewTest, RemoveButtonRevealsOverflowed) {
   // All buttons should be visible.
-  ASSERT_EQ(test_api_->GetButtonCount(), shelf_view_->last_visible_index() + 1);
+  ASSERT_EQ(test_api_->GetButtonCount(), test_api_->GetLastVisibleIndex() + 1);
 
   // Add platform app buttons until overflow.
   int items_added = 0;
   ShelfID first_added = AddApp();
   ShelfID last_added = first_added;
-  while (!shelf_view_->GetOverflowButton()->visible()) {
+  while (!test_api_->IsOverflowButtonVisible()) {
     last_added = AddApp();
     ++items_added;
     ASSERT_LT(items_added, 10000);
@@ -897,25 +855,25 @@
   // Last added button becomes visible and overflow chevron is gone.
   EXPECT_TRUE(GetButtonByID(last_added)->visible());
   EXPECT_EQ(1.0f, GetButtonByID(last_added)->layer()->opacity());
-  EXPECT_FALSE(shelf_view_->GetOverflowButton()->visible());
+  EXPECT_FALSE(test_api_->IsOverflowButtonVisible());
 }
 
 // Verifies that remove last overflowed button should hide overflow chevron.
 TEST_F(ShelfViewTest, RemoveLastOverflowed) {
   // All buttons should be visible.
-  ASSERT_EQ(test_api_->GetButtonCount(), shelf_view_->last_visible_index() + 1);
+  ASSERT_EQ(test_api_->GetButtonCount(), test_api_->GetLastVisibleIndex() + 1);
 
   // Add platform app button until overflow.
   int items_added = 0;
   ShelfID last_added = AddApp();
-  while (!shelf_view_->GetOverflowButton()->visible()) {
+  while (!test_api_->IsOverflowButtonVisible()) {
     last_added = AddApp();
     ++items_added;
     ASSERT_LT(items_added, 10000);
   }
 
   RemoveByID(last_added);
-  EXPECT_FALSE(shelf_view_->GetOverflowButton()->visible());
+  EXPECT_FALSE(test_api_->IsOverflowButtonVisible());
 }
 
 // Tests the visiblity of certain shelf items when the overflow bubble is open
@@ -937,7 +895,7 @@
       test_api_->overflow_bubble()->bubble_view()->shelf_view());
 
   // The main shelf is currently showing the item at |last_visible_index|.
-  const int last_visible_index = shelf_view_->last_visible_index();
+  const int last_visible_index = test_api_->GetLastVisibleIndex();
   EXPECT_TRUE(is_visible_on_shelf(last_visible_index, test_api_.get()));
   EXPECT_FALSE(is_visible_on_shelf(last_visible_index, &overflow_test_api));
 
@@ -948,16 +906,18 @@
   Shell::Get()->tablet_mode_controller()->EnableTabletModeWindowManager(true);
   test_api_->RunMessageLoopUntilAnimationsDone();
   overflow_test_api.RunMessageLoopUntilAnimationsDone();
-  ASSERT_TRUE(shelf_view_->IsShowingOverflowBubble());
-  EXPECT_FALSE(is_visible_on_shelf(last_visible_index, test_api_.get()));
-  EXPECT_TRUE(is_visible_on_shelf(last_visible_index, &overflow_test_api));
+  ASSERT_TRUE(test_api_->IsShowingOverflowBubble());
+  // TODO(manucornet): Parts of this test fail with the new UI. Find out why
+  // and re-enable. https://crbug.com/891080
+  // EXPECT_FALSE(is_visible_on_shelf(last_visible_index, test_api_.get()));
+  // EXPECT_TRUE(is_visible_on_shelf(last_visible_index, &overflow_test_api));
 
   // Verify that the item at |last_visible_index| is once again shown on the
   // main shelf after exiting tablet mode.
   Shell::Get()->tablet_mode_controller()->EnableTabletModeWindowManager(false);
   test_api_->RunMessageLoopUntilAnimationsDone();
   overflow_test_api.RunMessageLoopUntilAnimationsDone();
-  ASSERT_TRUE(shelf_view_->IsShowingOverflowBubble());
+  ASSERT_TRUE(test_api_->IsShowingOverflowBubble());
   EXPECT_TRUE(is_visible_on_shelf(last_visible_index, test_api_.get()));
   EXPECT_FALSE(is_visible_on_shelf(last_visible_index, &overflow_test_api));
 }
@@ -966,11 +926,11 @@
 // that all added buttons are visible.
 TEST_F(ShelfViewTest, AddButtonQuickly) {
   // All buttons should be visible.
-  ASSERT_EQ(test_api_->GetButtonCount(), shelf_view_->last_visible_index() + 1);
+  ASSERT_EQ(test_api_->GetButtonCount(), test_api_->GetLastVisibleIndex() + 1);
 
   // Add a few platform buttons quickly without wait for animation.
   int added_count = 0;
-  while (!shelf_view_->GetOverflowButton()->visible()) {
+  while (!test_api_->IsOverflowButtonVisible()) {
     AddAppNoWait();
     ++added_count;
     ASSERT_LT(added_count, 10000);
@@ -984,7 +944,7 @@
 
   // Verifies non-overflow buttons are visible. The back button at index 0 is
   // not visible.
-  for (int i = 1; i <= shelf_view_->last_visible_index(); ++i) {
+  for (int i = 1; i <= test_api_->GetLastVisibleIndex(); ++i) {
     ShelfAppButton* button = test_api_->GetButton(i);
     if (button) {
       EXPECT_TRUE(button->visible()) << "button index=" << i;
@@ -1192,7 +1152,7 @@
 // Confirm that item status changes are reflected in the buttons.
 TEST_F(ShelfViewTest, ShelfItemStatus) {
   // All buttons should be visible.
-  ASSERT_EQ(test_api_->GetButtonCount(), shelf_view_->last_visible_index() + 1);
+  ASSERT_EQ(test_api_->GetButtonCount(), test_api_->GetLastVisibleIndex() + 1);
 
   // Add platform app button.
   ShelfID last_added = AddApp();
@@ -1241,7 +1201,7 @@
 
   // Open overflow shelf and test api for it.
   test_api_->ShowOverflowBubble();
-  ASSERT_TRUE(shelf_view_->IsShowingOverflowBubble());
+  ASSERT_TRUE(test_api_->IsShowingOverflowBubble());
   ShelfViewTestAPI test_api_for_overflow(
       test_api_->overflow_bubble()->bubble_view()->shelf_view());
 
@@ -1261,7 +1221,7 @@
 
   // Verify that when an app from the overflow shelf is dragged to a location on
   // the main shelf, it is ripped off.
-  ASSERT_TRUE(shelf_view_->IsShowingOverflowBubble());
+  ASSERT_TRUE(test_api_->IsShowingOverflowBubble());
   generator->set_current_screen_location(overflow_app_location);
   generator->PressLeftButton();
   generator->MoveMouseTo(second_app_location);
@@ -1305,7 +1265,7 @@
 // for platform apps.
 TEST_F(ShelfViewTest, ShelfItemStatusPlatformApp) {
   // All buttons should be visible.
-  ASSERT_EQ(test_api_->GetButtonCount(), shelf_view_->last_visible_index() + 1);
+  ASSERT_EQ(test_api_->GetButtonCount(), test_api_->GetLastVisibleIndex() + 1);
 
   // Add platform app button.
   ShelfID last_added = AddApp();
@@ -1330,7 +1290,7 @@
 }
 
 TEST_F(ShelfViewTest, ShelfTooltipTest) {
-  ASSERT_EQ(shelf_view_->last_visible_index() + 1, test_api_->GetButtonCount());
+  ASSERT_EQ(test_api_->GetLastVisibleIndex() + 1, test_api_->GetButtonCount());
 
   // Prepare some items to the shelf.
   ShelfID app_button_id = AddAppShortcut();
@@ -1577,13 +1537,13 @@
 // new ideal bounds.
 TEST_F(ShelfViewTest, ResizeDuringOverflowAddAnimation) {
   // All buttons should be visible.
-  ASSERT_EQ(test_api_->GetButtonCount(), shelf_view_->last_visible_index() + 1);
+  ASSERT_EQ(test_api_->GetButtonCount(), test_api_->GetLastVisibleIndex() + 1);
 
   // Add buttons until overflow. Let the non-overflow add animations finish but
   // leave the last running.
   int items_added = 0;
   AddAppNoWait();
-  while (!shelf_view_->GetOverflowButton()->visible()) {
+  while (!test_api_->IsOverflowButtonVisible()) {
     test_api_->RunMessageLoopUntilAnimationsDone();
     AddAppNoWait();
     ++items_added;
@@ -1594,7 +1554,7 @@
   gfx::Rect bounds = shelf_view_->bounds();
   bounds.set_width(bounds.width() - ShelfConstants::shelf_size());
   shelf_view_->SetBoundsRect(bounds);
-  ASSERT_TRUE(shelf_view_->GetOverflowButton()->visible());
+  ASSERT_TRUE(test_api_->IsOverflowButtonVisible());
 
   // Finish the animation.
   test_api_->RunMessageLoopUntilAnimationsDone();
@@ -1617,14 +1577,14 @@
 
   // Show overflow bubble.
   test_api_->ShowOverflowBubble();
-  ASSERT_TRUE(shelf_view_->IsShowingOverflowBubble());
+  ASSERT_TRUE(test_api_->IsShowingOverflowBubble());
 
   ShelfViewTestAPI test_for_overflow_view(
       test_api_->overflow_bubble()->bubble_view()->shelf_view());
-  const ShelfView* overflow_shelf_view = shelf_view_->overflow_shelf();
 
-  int ripped_index = overflow_shelf_view->last_visible_index();
-  gfx::Size bubble_size = overflow_shelf_view->GetPreferredSize();
+  int ripped_index = test_for_overflow_view.GetLastVisibleIndex();
+  gfx::Size bubble_size =
+      test_for_overflow_view.shelf_view()->GetPreferredSize();
   int item_width =
       ShelfConstants::button_size() + ShelfConstants::button_spacing();
 
@@ -1643,23 +1603,23 @@
 
   // Check the overflow bubble size when an item is ripped off.
   EXPECT_EQ(bubble_size.width() - item_width,
-            overflow_shelf_view->GetPreferredSize().width());
-  ASSERT_TRUE(shelf_view_->IsShowingOverflowBubble());
+            test_for_overflow_view.shelf_view()->GetPreferredSize().width());
+  ASSERT_TRUE(test_api_->IsShowingOverflowBubble());
 
   // Re-insert an item into the overflow bubble.
-  int first_index = overflow_shelf_view->first_visible_index();
+  int first_index = test_for_overflow_view.GetFirstVisibleIndex();
   button = test_for_overflow_view.GetButton(first_index);
 
   // Check the bubble size after an item is re-inserted.
   generator->MoveMouseTo(button->GetBoundsInScreen().CenterPoint());
   test_for_overflow_view.RunMessageLoopUntilAnimationsDone();
   EXPECT_EQ(bubble_size.width(),
-            overflow_shelf_view->GetPreferredSize().width());
+            test_for_overflow_view.shelf_view()->GetPreferredSize().width());
 
   generator->ReleaseLeftButton();
   test_for_overflow_view.RunMessageLoopUntilAnimationsDone();
   EXPECT_EQ(bubble_size.width(),
-            overflow_shelf_view->GetPreferredSize().width());
+            test_for_overflow_view.shelf_view()->GetPreferredSize().width());
 }
 
 TEST_F(ShelfViewTest, OverflowShelfColorIsDerivedFromWallpaper) {
@@ -1683,7 +1643,7 @@
 
   // Show overflow bubble.
   test_api_->ShowOverflowBubble();
-  ASSERT_TRUE(shelf_view_->IsShowingOverflowBubble());
+  ASSERT_TRUE(test_api_->IsShowingOverflowBubble());
 
   int item_width =
       ShelfConstants::button_size() + ShelfConstants::button_spacing();
@@ -1697,13 +1657,12 @@
     AddAppShortcut();
   }
 
-  ASSERT_TRUE(shelf_view_->IsShowingOverflowBubble());
+  ASSERT_TRUE(test_api_->IsShowingOverflowBubble());
 
   ShelfViewTestAPI test_for_overflow_view(
       test_api_->overflow_bubble()->bubble_view()->shelf_view());
-  const ShelfView* overflow_shelf_view = shelf_view_->overflow_shelf();
-  int first_index = overflow_shelf_view->first_visible_index();
-  int last_index = overflow_shelf_view->last_visible_index();
+  int first_index = test_for_overflow_view.GetFirstVisibleIndex();
+  int last_index = test_for_overflow_view.GetLastVisibleIndex();
 
   ShelfAppButton* first_button = test_for_overflow_view.GetButton(first_index);
   ShelfAppButton* last_button = test_for_overflow_view.GetButton(last_index);
@@ -1744,14 +1703,13 @@
   // Test #1: Test drag insertion bounds of primary shelf.
   // Show overflow bubble.
   test_api_->ShowOverflowBubble();
-  ASSERT_TRUE(shelf_view_->IsShowingOverflowBubble());
+  ASSERT_TRUE(test_api_->IsShowingOverflowBubble());
 
   ShelfViewTestAPI test_api_for_overflow_view(
       test_api_->overflow_bubble()->bubble_view()->shelf_view());
-  const ShelfView* overflow_shelf_view = shelf_view_->overflow_shelf();
 
   ShelfAppButton* button = test_api_for_overflow_view.GetButton(
-      overflow_shelf_view->last_visible_index());
+      test_api_for_overflow_view.GetLastVisibleIndex());
 
   // Checks that a point in shelf is contained in drag insert bounds.
   gfx::Point point_in_shelf_view = button->GetBoundsInScreen().CenterPoint();
@@ -1765,16 +1723,14 @@
   // Test #2: Test drag insertion bounds of secondary shelf.
   // Show overflow bubble.
   test_api_for_secondary.ShowOverflowBubble();
-  ASSERT_TRUE(shelf_view_for_secondary->IsShowingOverflowBubble());
+  ASSERT_TRUE(test_api_for_secondary.IsShowingOverflowBubble());
 
   ShelfViewTestAPI test_api_for_overflow_view_of_secondary(
       test_api_for_secondary.overflow_bubble()->bubble_view()->shelf_view());
-  const ShelfView* overflow_shelf_view_of_secondary =
-      shelf_view_for_secondary->overflow_shelf();
 
   ShelfAppButton* button_in_secondary =
       test_api_for_overflow_view_of_secondary.GetButton(
-          overflow_shelf_view_of_secondary->last_visible_index());
+          test_api_for_overflow_view_of_secondary.GetLastVisibleIndex());
 
   // Checks that a point in shelf is contained in drag insert bounds.
   gfx::Point point_in_secondary_shelf_view =
@@ -1850,14 +1806,14 @@
   test_api_->ShowOverflowBubble();
   ShelfView* overflow_shelf_view =
       shelf_view_->overflow_bubble()->bubble_view()->shelf_view();
-  ASSERT_TRUE(shelf_view_->IsShowingOverflowBubble());
+  ASSERT_TRUE(test_api_->IsShowingOverflowBubble());
 
   ShelfViewTestAPI overflow_api(overflow_shelf_view);
 
   // We are going to drag the first item in the overflow (A) onto the last
   // one (B).
-  int item_a_initial_index = overflow_shelf_view->first_visible_index();
-  int item_b_initial_index = overflow_shelf_view->last_visible_index();
+  int item_a_initial_index = overflow_api.GetFirstVisibleIndex();
+  int item_b_initial_index = overflow_api.GetLastVisibleIndex();
   ShelfID item_a = GetItemId(item_a_initial_index);
   ShelfID item_b = GetItemId(item_b_initial_index);
   ShelfAppButton* item_a_button = overflow_api.GetButton(item_a_initial_index);
@@ -1879,10 +1835,10 @@
 
   // Now, item A should be the last item, and item B should be just before it.
   ShelfID new_first_visible_item =
-      GetItemId(overflow_shelf_view->first_visible_index());
+      GetItemId(overflow_api.GetFirstVisibleIndex());
   EXPECT_NE(item_a, new_first_visible_item);
-  EXPECT_EQ(item_a, GetItemId(overflow_shelf_view->last_visible_index()));
-  EXPECT_EQ(item_b, GetItemId(overflow_shelf_view->last_visible_index() - 1));
+  EXPECT_EQ(item_a, GetItemId(overflow_api.GetLastVisibleIndex()));
+  EXPECT_EQ(item_b, GetItemId(overflow_api.GetLastVisibleIndex() - 1));
 
   test_api_->HideOverflowBubble();
 }
@@ -1970,7 +1926,7 @@
 
   // Verify that by pressing anywhere outside the shelf and overflow bubble, the
   // overflow bubble will close if it were open.
-  EXPECT_FALSE(shelf_view_->IsShowingOverflowBubble());
+  EXPECT_FALSE(test_api_->IsShowingOverflowBubble());
   test_api_->ShowOverflowBubble();
 
   // Make sure the point we chose is not on the shelf or its overflow bubble.
@@ -1982,20 +1938,20 @@
                    ->GetBoundsInScreen()
                    .Contains(generator->current_screen_location()));
   generator->PressLeftButton();
-  EXPECT_FALSE(shelf_view_->IsShowingOverflowBubble());
+  EXPECT_FALSE(test_api_->IsShowingOverflowBubble());
   generator->ReleaseLeftButton();
 
   // Verify that by clicking a app which is on the main shelf while the overflow
   // bubble is opened, the overflow bubble will close.
-  EXPECT_FALSE(shelf_view_->IsShowingOverflowBubble());
+  EXPECT_FALSE(test_api_->IsShowingOverflowBubble());
   test_api_->ShowOverflowBubble();
   generator->set_current_screen_location(GetButtonCenter(first_app_id));
   generator->ClickLeftButton();
-  EXPECT_FALSE(shelf_view_->IsShowingOverflowBubble());
+  EXPECT_FALSE(test_api_->IsShowingOverflowBubble());
 
   // Verify that by clicking a app which is on the overflow shelf, the overflow
   // bubble will close.
-  EXPECT_FALSE(shelf_view_->IsShowingOverflowBubble());
+  EXPECT_FALSE(test_api_->IsShowingOverflowBubble());
   test_api_->ShowOverflowBubble();
   ShelfViewTestAPI test_api_for_overflow(
       test_api_->overflow_bubble()->bubble_view()->shelf_view());
@@ -2004,20 +1960,20 @@
   generator->set_current_screen_location(
       GetButtonCenter(button_on_overflow_shelf));
   generator->ClickLeftButton();
-  EXPECT_FALSE(shelf_view_->IsShowingOverflowBubble());
+  EXPECT_FALSE(test_api_->IsShowingOverflowBubble());
 
   // Verify that dragging apps on the main shelf does not close the overflow
   // bubble.
-  EXPECT_FALSE(shelf_view_->IsShowingOverflowBubble());
+  EXPECT_FALSE(test_api_->IsShowingOverflowBubble());
   test_api_->ShowOverflowBubble();
   generator->set_current_screen_location(GetButtonCenter(first_app_id));
   generator->DragMouseTo(GetButtonCenter(second_app_id));
-  EXPECT_TRUE(shelf_view_->IsShowingOverflowBubble());
+  EXPECT_TRUE(test_api_->IsShowingOverflowBubble());
   test_api_->HideOverflowBubble();
 
   // Verify dragging apps on the overflow shelf does not close the overflow
   // bubble.
-  EXPECT_FALSE(shelf_view_->IsShowingOverflowBubble());
+  EXPECT_FALSE(test_api_->IsShowingOverflowBubble());
   test_api_->ShowOverflowBubble();
   ShelfViewTestAPI test_api_for_overflow2(
       test_api_->overflow_bubble()->bubble_view()->shelf_view());
@@ -2028,7 +1984,7 @@
   generator->set_current_screen_location(
       GetButtonCenter(button_on_overflow_shelf));
   generator->DragMouseTo(GetButtonCenter(button_on_overflow_shelf1));
-  EXPECT_TRUE(shelf_view_->IsShowingOverflowBubble());
+  EXPECT_TRUE(test_api_->IsShowingOverflowBubble());
 }
 
 TEST_F(ShelfViewTest, UnpinningCancelsOverflow) {
@@ -2036,14 +1992,14 @@
   const ShelfID first_shelf_id = AddAppShortcut();
   AddButtonsUntilOverflow();
   test_api_->ShowOverflowBubble();
-  EXPECT_TRUE(shelf_view_->GetOverflowButton()->visible());
-  EXPECT_TRUE(shelf_view_->IsShowingOverflowBubble());
+  EXPECT_TRUE(test_api_->IsOverflowButtonVisible());
+  EXPECT_TRUE(test_api_->IsShowingOverflowBubble());
 
   // Unpinning an item should hide the overflow button and close the bubble.
   model_->UnpinAppWithID(first_shelf_id.app_id);
   test_api_->RunMessageLoopUntilAnimationsDone();
-  EXPECT_FALSE(shelf_view_->GetOverflowButton()->visible());
-  EXPECT_FALSE(shelf_view_->IsShowingOverflowBubble());
+  EXPECT_FALSE(test_api_->IsOverflowButtonVisible());
+  EXPECT_FALSE(test_api_->IsShowingOverflowBubble());
 }
 
 // Verify the animations of the shelf items are as long as expected.
@@ -2159,7 +2115,7 @@
 TEST_F(ShelfViewTest, NoContextMenuOnOverflowButton) {
   ui::test::EventGenerator* generator = GetEventGenerator();
   AddButtonsUntilOverflow();
-  views::View* overflow_button = shelf_view_->GetOverflowButton();
+  views::View* overflow_button = test_api_->overflow_button();
 
   generator->MoveMouseTo(overflow_button->GetBoundsInScreen().CenterPoint());
   generator->PressRightButton();
@@ -2292,7 +2248,7 @@
   DISALLOW_COPY_AND_ASSIGN(ShelfViewMenuTest);
 };
 
-INSTANTIATE_TEST_SUITE_P(, ShelfViewMenuTest, testing::Bool());
+INSTANTIATE_TEST_CASE_P(, ShelfViewMenuTest, testing::Bool());
 
 // Tests that menu anchor points are aligned with the shelf button bounds.
 TEST_P(ShelfViewMenuTest, ShelfViewMenuAnchorPoint) {
@@ -2448,18 +2404,18 @@
     AddAppShortcut();
   }
   test_api_->RunMessageLoopUntilAnimationsDone();
-  EXPECT_FALSE(shelf_view_->GetOverflowButton()->visible());
+  EXPECT_FALSE(test_api_->IsOverflowButtonVisible());
   CheckAllItemsAreInBounds();
   // Same for overflow case.
-  while (!shelf_view_->GetOverflowButton()->visible()) {
+  while (!test_api_->IsOverflowButtonVisible()) {
     AddAppShortcut();
   }
   test_api_->RunMessageLoopUntilAnimationsDone();
   CheckAllItemsAreInBounds();
 }
 
-INSTANTIATE_TEST_SUITE_P(LtrRtl, ShelfViewTextDirectionTest, testing::Bool());
-INSTANTIATE_TEST_SUITE_P(VisibleBounds,
+INSTANTIATE_TEST_CASE_P(LtrRtl, ShelfViewTextDirectionTest, testing::Bool());
+INSTANTIATE_TEST_CASE_P(VisibleBounds,
                          ShelfViewVisibleBoundsTest,
                          testing::Bool());
 
@@ -2971,30 +2927,6 @@
                           views::InkDropState::DEACTIVATED));
 }
 
-TEST_F(ShelfViewInkDropTest, DismissingMenuWithDoubleClickDoesntShowInkDrop) {
-  ui::test::EventGenerator* generator = GetEventGenerator();
-  InitBrowserButtonInkDrop();
-
-  views::Button* button = browser_button_;
-
-  // Show a context menu on the app list button.
-  generator->MoveMouseTo(
-      shelf_view_->GetAppListButton()->GetBoundsInScreen().CenterPoint());
-  generator->PressRightButton();
-  generator->ReleaseRightButton();
-  EXPECT_TRUE(shelf_view_->IsShowingMenu());
-
-  // Now check that double-clicking on the browser button dismisses the context
-  // menu, and does not show an ink drop.
-  EXPECT_EQ(views::InkDropState::HIDDEN,
-            browser_button_ink_drop_->GetTargetInkDropState());
-  generator->MoveMouseTo(button->GetBoundsInScreen().CenterPoint());
-  generator->DoubleClickLeftButton();
-  EXPECT_FALSE(shelf_view_->IsShowingMenu());
-  EXPECT_EQ(views::InkDropState::HIDDEN,
-            browser_button_ink_drop_->GetTargetInkDropState());
-}
-
 // Test fixture for testing material design ink drop on overflow button.
 class OverflowButtonInkDropTest : public ShelfViewInkDropTest {
  public:
@@ -3004,7 +2936,7 @@
   void SetUp() override {
     ShelfViewInkDropTest::SetUp();
 
-    overflow_button_ = shelf_view_->GetOverflowButton();
+    overflow_button_ = test_api_->overflow_button();
 
     auto overflow_button_ink_drop =
         std::make_unique<InkDropSpy>(std::make_unique<views::InkDropImpl>(
@@ -3014,8 +2946,8 @@
         .SetInkDrop(std::move(overflow_button_ink_drop));
 
     AddButtonsUntilOverflow();
-    EXPECT_TRUE(shelf_view_->GetOverflowButton()->visible());
-    EXPECT_FALSE(shelf_view_->IsShowingOverflowBubble());
+    EXPECT_TRUE(test_api_->IsOverflowButtonVisible());
+    EXPECT_FALSE(test_api_->IsShowingOverflowBubble());
   }
 
  protected:
@@ -3040,14 +2972,14 @@
 // bubble is shown or hidden.
 TEST_F(OverflowButtonInkDropTest, OnOverflowBubbleShowHide) {
   test_api_->ShowOverflowBubble();
-  ASSERT_TRUE(shelf_view_->IsShowingOverflowBubble());
+  ASSERT_TRUE(test_api_->IsShowingOverflowBubble());
   EXPECT_EQ(views::InkDropState::ACTIVATED,
             overflow_button_ink_drop_->GetTargetInkDropState());
   EXPECT_THAT(overflow_button_ink_drop_->GetAndResetRequestedStates(),
               ElementsAre(views::InkDropState::ACTIVATED));
 
   test_api_->HideOverflowBubble();
-  EXPECT_FALSE(shelf_view_->IsShowingOverflowBubble());
+  EXPECT_FALSE(test_api_->IsShowingOverflowBubble());
   EXPECT_EQ(views::InkDropState::HIDDEN,
             overflow_button_ink_drop_->GetTargetInkDropState());
   EXPECT_THAT(overflow_button_ink_drop_->GetAndResetRequestedStates(),
@@ -3073,7 +3005,7 @@
   EXPECT_THAT(overflow_button_ink_drop_->GetAndResetRequestedStates(),
               ElementsAre(views::InkDropState::ACTIVATED));
 
-  ASSERT_TRUE(shelf_view_->IsShowingOverflowBubble());
+  ASSERT_TRUE(test_api_->IsShowingOverflowBubble());
 }
 
 // Tests ink drop state transitions for the overflow button when the user
@@ -3100,7 +3032,7 @@
   EXPECT_THAT(overflow_button_ink_drop_->GetAndResetRequestedStates(),
               IsEmpty());
 
-  EXPECT_FALSE(shelf_view_->IsShowingOverflowBubble());
+  EXPECT_FALSE(test_api_->IsShowingOverflowBubble());
 }
 
 // Tests ink drop state transitions for the overflow button when the user
@@ -3134,7 +3066,7 @@
   EXPECT_THAT(overflow_button_ink_drop_->GetAndResetRequestedStates(),
               ElementsAre(views::InkDropState::ACTIVATED));
 
-  ASSERT_TRUE(shelf_view_->IsShowingOverflowBubble());
+  ASSERT_TRUE(test_api_->IsShowingOverflowBubble());
 }
 
 // Tests ink drop state transitions for the overflow button when the user
@@ -3155,7 +3087,7 @@
   EXPECT_THAT(overflow_button_ink_drop_->GetAndResetRequestedStates(),
               IsEmpty());
 
-  EXPECT_FALSE(shelf_view_->IsShowingOverflowBubble());
+  EXPECT_FALSE(test_api_->IsShowingOverflowBubble());
 }
 
 // Tests ink drop state transitions for the overflow button when the user taps
@@ -3176,7 +3108,7 @@
   EXPECT_THAT(overflow_button_ink_drop_->GetAndResetRequestedStates(),
               ElementsAre(views::InkDropState::ACTIVATED));
 
-  ASSERT_TRUE(shelf_view_->IsShowingOverflowBubble());
+  ASSERT_TRUE(test_api_->IsShowingOverflowBubble());
 }
 
 // Tests ink drop state transitions for the overflow button when the user taps
@@ -3203,7 +3135,7 @@
   EXPECT_THAT(overflow_button_ink_drop_->GetAndResetRequestedStates(),
               IsEmpty());
 
-  EXPECT_FALSE(shelf_view_->IsShowingOverflowBubble());
+  EXPECT_FALSE(test_api_->IsShowingOverflowBubble());
 }
 
 // Tests ink drop state transitions for the overflow button when the user taps
@@ -3236,7 +3168,7 @@
   EXPECT_THAT(overflow_button_ink_drop_->GetAndResetRequestedStates(),
               IsEmpty());
 
-  EXPECT_FALSE(shelf_view_->IsShowingOverflowBubble());
+  EXPECT_FALSE(test_api_->IsShowingOverflowBubble());
 }
 
 // Test fixture to run overflow button tests for LTR and RTL directions.
@@ -3258,7 +3190,7 @@
   DISALLOW_COPY_AND_ASSIGN(OverflowButtonTextDirectionTest);
 };
 
-INSTANTIATE_TEST_SUITE_P(
+INSTANTIATE_TEST_CASE_P(
     /* prefix intentionally left blank due to only one parameterization */,
     OverflowButtonTextDirectionTest,
     testing::Bool());
@@ -3274,7 +3206,7 @@
     OverflowButtonInkDropTest::SetUp();
 
     test_api_->ShowOverflowBubble();
-    ASSERT_TRUE(shelf_view_->IsShowingOverflowBubble());
+    ASSERT_TRUE(test_api_->IsShowingOverflowBubble());
     EXPECT_EQ(views::InkDropState::ACTIVATED,
               overflow_button_ink_drop_->GetTargetInkDropState());
     EXPECT_THAT(overflow_button_ink_drop_->GetAndResetRequestedStates(),
@@ -3303,7 +3235,7 @@
   EXPECT_THAT(overflow_button_ink_drop_->GetAndResetRequestedStates(),
               ElementsAre(views::InkDropState::DEACTIVATED));
 
-  EXPECT_FALSE(shelf_view_->IsShowingOverflowBubble());
+  EXPECT_FALSE(test_api_->IsShowingOverflowBubble());
 }
 
 // Tests ink drop state transitions for the overflow button when it is active
@@ -3331,7 +3263,7 @@
   EXPECT_THAT(overflow_button_ink_drop_->GetAndResetRequestedStates(),
               IsEmpty());
 
-  ASSERT_TRUE(shelf_view_->IsShowingOverflowBubble());
+  ASSERT_TRUE(test_api_->IsShowingOverflowBubble());
 }
 
 // Tests ink drop state transitions for the overflow button when it is active
@@ -3365,7 +3297,7 @@
   EXPECT_THAT(overflow_button_ink_drop_->GetAndResetRequestedStates(),
               ElementsAre(views::InkDropState::DEACTIVATED));
 
-  EXPECT_FALSE(shelf_view_->IsShowingOverflowBubble());
+  EXPECT_FALSE(test_api_->IsShowingOverflowBubble());
 }
 
 // Tests ink drop state transitions for the overflow button when it is active
@@ -3386,7 +3318,7 @@
   EXPECT_THAT(overflow_button_ink_drop_->GetAndResetRequestedStates(),
               ElementsAre(views::InkDropState::DEACTIVATED));
 
-  EXPECT_FALSE(shelf_view_->IsShowingOverflowBubble());
+  EXPECT_FALSE(test_api_->IsShowingOverflowBubble());
 }
 
 // Tests ink drop state transitions for the overflow button when it is active
@@ -3413,7 +3345,7 @@
   EXPECT_THAT(overflow_button_ink_drop_->GetAndResetRequestedStates(),
               IsEmpty());
 
-  ASSERT_TRUE(shelf_view_->IsShowingOverflowBubble());
+  ASSERT_TRUE(test_api_->IsShowingOverflowBubble());
 }
 
 // Tests ink drop state transitions for the overflow button when it is active
@@ -3447,7 +3379,7 @@
   EXPECT_THAT(overflow_button_ink_drop_->GetAndResetRequestedStates(),
               IsEmpty());
 
-  ASSERT_TRUE(shelf_view_->IsShowingOverflowBubble());
+  ASSERT_TRUE(test_api_->IsShowingOverflowBubble());
 }
 
 class ShelfViewFocusTest : public ShelfViewTest {
@@ -3463,13 +3395,8 @@
     AddAppShortcut();
     AddAppShortcut();
 
-    Shelf* shelf = Shelf::ForWindow(Shell::GetPrimaryRootWindow());
-    gfx::NativeWindow window = shelf->shelf_widget()->GetNativeWindow();
-    status_area_ = RootWindowController::ForWindow(window)
-                       ->GetStatusAreaWidget()
-                       ->GetContentsView();
-
     // Focus the shelf.
+    Shelf* shelf = Shelf::ForWindow(Shell::GetPrimaryRootWindow());
     Shell::Get()->focus_cycler()->FocusWidget(shelf->shelf_widget());
   }
 
@@ -3484,9 +3411,6 @@
                        ui::EventFlags::EF_SHIFT_DOWN);
   }
 
- protected:
-  views::View* status_area_ = nullptr;
-
  private:
   DISALLOW_COPY_AND_ASSIGN(ShelfViewFocusTest);
 };
@@ -3494,7 +3418,7 @@
 // Tests that the number of buttons is as expected and the shelf's widget
 // intially has focus.
 TEST_F(ShelfViewFocusTest, Basic) {
-  EXPECT_FALSE(shelf_view_->IsShowingOverflowBubble());
+  EXPECT_FALSE(test_api_->IsShowingOverflowBubble());
 
   // There are five buttons. The back button and launcher are always there, the
   // browser shortcut is added in ShelfViewTest and the two test apps added in
@@ -3517,16 +3441,19 @@
   DoTab();
   DoTab();
   EXPECT_TRUE(test_api_->GetViewAt(4)->HasFocus());
+
+  // The last element is currently focused so pressing tab once should advance
+  // focus to the first element.
+  DoTab();
+  EXPECT_TRUE(test_api_->GetViewAt(1)->HasFocus());
 }
 
 // Tests that the expected views have focus when cycling backwards through shelf
 // items with shift tab.
 TEST_F(ShelfViewFocusTest, BackwardCycling) {
-  // The first element is currently focused. Let's advance to the last element
-  // first.
-  DoTab();
-  DoTab();
-  DoTab();
+  // The first element is currently focused so pressing shift tab once should
+  // advance focus to the last element.
+  DoShiftTab();
   EXPECT_TRUE(test_api_->GetViewAt(4)->HasFocus());
 
   // Pressing shift tab once should advance focus to the previous element.
@@ -3544,41 +3471,6 @@
   EXPECT_TRUE(::wm::IsActiveWindow(window.get()));
 }
 
-// Verifies that focus moves as expected between the shelf and the status area.
-TEST_F(ShelfViewFocusTest, FocusCyclingBetweenShelfAndStatusWidget) {
-  // The first element of the shelf is focused at start.
-
-  // Focus the next few elements.
-  DoTab();
-  EXPECT_TRUE(test_api_->GetViewAt(2)->HasFocus());
-  DoTab();
-  EXPECT_TRUE(test_api_->GetViewAt(3)->HasFocus());
-  DoTab();
-  EXPECT_TRUE(test_api_->GetViewAt(4)->HasFocus());
-
-  // This is the last element. Tabbing once more should go into the status
-  // area.
-  DoTab();
-  ExpectNotFocused(shelf_view_);
-  ExpectFocused(status_area_);
-
-  // Shift-tab: we should be back at the last element in the shelf.
-  DoShiftTab();
-  EXPECT_TRUE(test_api_->GetViewAt(4)->HasFocus());
-  ExpectNotFocused(status_area_);
-
-  // Go into the status area again.
-  DoTab();
-  ExpectNotFocused(shelf_view_);
-  ExpectFocused(status_area_);
-
-  // And keep going forward, now we should be cycling back to the first shelf
-  // element.
-  DoTab();
-  EXPECT_TRUE(test_api_->GetViewAt(1)->HasFocus());
-  ExpectNotFocused(status_area_);
-}
-
 class ShelfViewOverflowFocusTest : public ShelfViewFocusTest {
  public:
   ShelfViewOverflowFocusTest() = default;
@@ -3621,8 +3513,8 @@
 // Tests that the overflow button is visible and that not all the items are
 // visible on the main shelf.
 TEST_F(ShelfViewOverflowFocusTest, Basic) {
-  EXPECT_TRUE(shelf_view_->GetOverflowButton()->visible());
-  EXPECT_FALSE(shelf_view_->IsShowingOverflowBubble());
+  EXPECT_TRUE(test_api_->IsOverflowButtonVisible());
+  EXPECT_FALSE(test_api_->IsShowingOverflowBubble());
 
   EXPECT_EQ(last_item_on_main_shelf_index_, items_ - 5);
   EXPECT_TRUE(shelf_view_->shelf_widget()->IsActive());
@@ -3632,7 +3524,7 @@
 TEST_F(ShelfViewOverflowFocusTest, OpenOverflow) {
   OpenOverflow();
   ASSERT_TRUE(overflow_shelf_test_api_);
-  EXPECT_TRUE(shelf_view_->IsShowingOverflowBubble());
+  EXPECT_TRUE(test_api_->IsShowingOverflowBubble());
   EXPECT_TRUE(test_api_->GetViewAt(1)->HasFocus());
 }
 
@@ -3646,14 +3538,17 @@
 
   // Focus the overflow button.
   DoTab();
-  EXPECT_TRUE(shelf_view_->GetOverflowButton()->HasFocus());
+  EXPECT_TRUE(test_api_->overflow_button()->HasFocus());
+
+  DoTab();
+  EXPECT_TRUE(test_api_->GetViewAt(1)->HasFocus());
 }
 
 // Tests that when cycling through the items with shift tab, the items in the
 // overflow shelf are ignored because it is not visible.
 TEST_F(ShelfViewOverflowFocusTest, BackwardCycling) {
-  while (!shelf_view_->GetOverflowButton()->HasFocus())
-    DoTab();
+  DoShiftTab();
+  EXPECT_TRUE(test_api_->overflow_button()->HasFocus());
 
   DoShiftTab();
   EXPECT_TRUE(test_api_->GetViewAt(last_item_on_main_shelf_index_)->HasFocus());
@@ -3670,7 +3565,7 @@
 
   // Focus the overflow button.
   DoTab();
-  EXPECT_TRUE(shelf_view_->GetOverflowButton()->HasFocus());
+  EXPECT_TRUE(test_api_->overflow_button()->HasFocus());
 
   // Tests that after pressing tab once more, the overflow bubble widget now is
   // active, and the first item on the overflow bubble shelf has focus.
@@ -3680,6 +3575,20 @@
   const int first_index_overflow_shelf = last_item_on_main_shelf_index_ + 1;
   EXPECT_TRUE(overflow_shelf_test_api_->GetViewAt(first_index_overflow_shelf)
                   ->HasFocus());
+
+  // Focus the last item on the overflow shelf.
+  test_api_->overflow_bubble()
+      ->bubble_view()
+      ->GetWidget()
+      ->GetFocusManager()
+      ->SetFocusedView(
+          overflow_shelf_test_api_->GetViewAt(first_index_overflow_shelf + 3));
+
+  // Tests that after pressing tab once more, the main shelf widget now is
+  // active, and the first item on the main shelf has focus.
+  DoTab();
+  EXPECT_TRUE(shelf_view_->shelf_widget()->IsActive());
+  EXPECT_TRUE(test_api_->GetViewAt(1)->HasFocus());
 }
 
 // Tests that backwards cycling through elements with shift tab works as
@@ -3687,77 +3596,33 @@
 TEST_F(ShelfViewOverflowFocusTest, BackwardCyclingWithBubbleOpen) {
   OpenOverflow();
 
+  // Tests that after pressing shift tab once, the overflow shelf bubble is
+  // active and the last item on the overflow shelf has focus.
+  DoShiftTab();
+  EXPECT_TRUE(
+      test_api_->overflow_bubble()->bubble_view()->GetWidget()->IsActive());
+  const int first_index_overflow_shelf = last_item_on_main_shelf_index_ + 1;
+  EXPECT_TRUE(
+      overflow_shelf_test_api_->GetViewAt(first_index_overflow_shelf + 3)
+          ->HasFocus());
+
   // Focus the first item on the overflow shelf.
-  while (!test_api_->overflow_bubble()->bubble_view()->GetWidget()->IsActive())
-    DoTab();
-  EXPECT_FALSE(shelf_view_->shelf_widget()->IsActive());
-  EXPECT_FALSE(shelf_view_->GetOverflowButton()->HasFocus());
+  test_api_->overflow_bubble()
+      ->bubble_view()
+      ->GetWidget()
+      ->GetFocusManager()
+      ->SetFocusedView(
+          overflow_shelf_test_api_->GetViewAt(first_index_overflow_shelf));
 
   // Tests that after pressing shift tab once, the main shelf is active and
   // the overflow button has focus.
   DoShiftTab();
   EXPECT_TRUE(shelf_view_->shelf_widget()->IsActive());
-  EXPECT_TRUE(shelf_view_->GetOverflowButton()->HasFocus());
+  EXPECT_TRUE(test_api_->overflow_button()->HasFocus());
 
   // One more shift tab and the last item on the main shelf has focus.
   DoShiftTab();
   EXPECT_TRUE(test_api_->GetViewAt(last_item_on_main_shelf_index_)->HasFocus());
 }
 
-// Verifies that focus moves as expected between the shelf and the status area
-// when the overflow bubble is showing.
-TEST_F(ShelfViewOverflowFocusTest, FocusCyclingBetweenShelfAndStatusWidget) {
-  OpenOverflow();
-  const int first_index_overflow_shelf = last_item_on_main_shelf_index_ + 1;
-
-  // We start with the first shelf item focused. Shift-tab should focus the
-  // status area.
-  DoShiftTab();
-  ExpectNotFocused(shelf_view_);
-  ExpectFocused(status_area_);
-
-  // Focus the shelf again.
-  DoTab();
-  ExpectFocused(shelf_view_);
-  EXPECT_TRUE(test_api_->GetViewAt(1)->HasFocus());
-  ExpectNotFocused(status_area_);
-
-  // Now advance to the last item on the main shelf.
-  while (!test_api_->GetViewAt(last_item_on_main_shelf_index_)->HasFocus())
-    DoTab();
-  ExpectNotFocused(status_area_);
-
-  // Focus the overflow button
-  DoTab();
-  EXPECT_TRUE(shelf_view_->GetOverflowButton()->HasFocus());
-
-  // Tab into the overflow bubble.
-  DoTab();
-  EXPECT_TRUE(overflow_shelf_test_api_->GetViewAt(first_index_overflow_shelf)
-                  ->HasFocus());
-
-  // Back onto the overflow button itself.
-  DoShiftTab();
-  EXPECT_TRUE(shelf_view_->GetOverflowButton()->HasFocus());
-
-  // Now advance until we get to the status area.
-  while (!status_area_->GetWidget()->IsActive())
-    DoTab();
-
-  // Go back once, we should be in the overflow bubble again.
-  DoShiftTab();
-  ExpectNotFocused(status_area_);
-  ExpectFocused(test_api_->overflow_bubble()->bubble_view());
-
-  // Go into the status area again.
-  DoTab();
-  ExpectFocused(status_area_);
-
-  // Now advance until the status area isn't focused anymore.
-  while (status_area_->GetWidget()->IsActive())
-    DoTab();
-  // This should have brought focus to the first element on the shelf.
-  EXPECT_TRUE(test_api_->GetViewAt(1)->HasFocus());
-}
-
 }  // namespace ash
--- a/ash/shelf/shelf_widget.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/shelf/shelf_widget.cc	2019-05-17 18:53:08.252000000 +0300
@@ -240,10 +240,9 @@
       -shelf->SelectValueForShelfAlignment(0, 0, safety_margin),
       -shelf->SelectValueForShelfAlignment(safety_margin, 0, 0));
 
-  // Show rounded corners except in maximized (which includes split view) mode.
-  if (background_type == SHELF_BACKGROUND_MAXIMIZED) {
-    if (mask_)
-      opaque_background_.RemoveCacheRenderSurfaceRequest();
+  // Show rounded corners except in maximized and split modes.
+  if (background_type == SHELF_BACKGROUND_MAXIMIZED ||
+      background_type == SHELF_BACKGROUND_SPLIT_VIEW) {
     mask_ = nullptr;
     opaque_background_.SetMaskLayer(nullptr);
   } else {
@@ -252,7 +251,6 @@
           views::Painter::CreateSolidRoundRectPainter(SK_ColorBLACK, radius));
       mask_->layer()->SetFillsBoundsOpaquely(false);
       opaque_background_.SetMaskLayer(mask_->layer());
-      opaque_background_.AddCacheRenderSurfaceRequest();
     }
     if (mask_->layer()->bounds() != opaque_background_bounds)
       mask_->layer()->SetBounds(opaque_background_bounds);
@@ -267,16 +265,12 @@
 }
 
 views::View* ShelfWidget::DelegateView::GetDefaultFocusableChild() {
-  if (!IsUsingViewsShelf())
-    return GetFirstFocusableChild();
-
-  if (shelf_widget_->login_shelf_view_->visible()) {
+  // If views-based login shelf is shown, we want to focus either its first or
+  // last child, otherwise focus on the first child as default.
+  if (IsUsingViewsShelf())
     return FindFirstOrLastFocusableChild(shelf_widget_->login_shelf_view_,
                                          default_last_focusable_child_);
-  } else {
-    return shelf_widget_->shelf_view_->FindFirstOrLastFocusableChild(
-        default_last_focusable_child_);
-  }
+  return GetFirstFocusableChild();
 }
 
 void ShelfWidget::DelegateView::UpdateShelfBackground(SkColor color) {
@@ -288,26 +282,6 @@
   return opaque_background_.background_color();
 }
 
-bool ShelfWidget::GetHitTestRects(aura::Window* target,
-                                  gfx::Rect* hit_test_rect_mouse,
-                                  gfx::Rect* hit_test_rect_touch) {
-  // This should only get called when the login shelf is visible, i.e. not
-  // during an active session. In an active session, hit test rects should be
-  // calculated higher up in the class hierarchy by |EasyResizeWindowTargeter|.
-  // When in OOBE or locked/login screen, let events pass through empty parts
-  // of the shelf.
-  DCHECK(login_shelf_view_->visible());
-  gfx::Rect login_view_button_bounds =
-      login_shelf_view_->ConvertRectToWidget(login_shelf_view_->GetMirroredRect(
-          login_shelf_view_->get_button_union_bounds()));
-  aura::Window* source = login_shelf_view_->GetWidget()->GetNativeWindow();
-  aura::Window::ConvertRectToTarget(source, target->parent(),
-                                    &login_view_button_bounds);
-  *hit_test_rect_mouse = login_view_button_bounds;
-  *hit_test_rect_touch = login_view_button_bounds;
-  return true;
-}
-
 ShelfWidget::ShelfWidget(aura::Window* shelf_container, Shelf* shelf)
     : shelf_(shelf),
       background_animator_(SHELF_BACKGROUND_DEFAULT,
@@ -415,6 +389,7 @@
 void ShelfWidget::OnShelfAlignmentChanged() {
   // Check added for http://crbug.com/738011.
   CHECK(status_area_widget_);
+  shelf_view_->OnShelfAlignmentChanged();
   status_area_widget_->UpdateAfterShelfAlignmentChange();
   // This call will in turn trigger a call to delegate_view_->SchedulePaint().
   delegate_view_->UpdateOpaqueBackground();
@@ -487,24 +462,15 @@
       default_last_focusable_child);
 }
 
-void ShelfWidget::FocusFirstOrLastFocusableChild(bool last) {
-  // This is only ever called during an active session.
-  if (!shelf_view_->visible())
-    return;
-  views::View* to_focus = shelf_view_->FindFirstOrLastFocusableChild(last);
-
-  Shell::Get()->focus_cycler()->FocusWidget(to_focus->GetWidget());
-  to_focus->GetFocusManager()->SetFocusedView(to_focus);
-}
-
 void ShelfWidget::OnWidgetActivationChanged(views::Widget* widget,
                                             bool active) {
   if (active) {
     // Do not focus the default element if the widget activation came from the
-    // another widget's focus cycling. The setter of
-    // |activated_from_other_widget_| should handle focusing the correct view.
-    if (activated_from_other_widget_) {
-      activated_from_other_widget_ = false;
+    // overflow bubble focus cycling. The setter of
+    // |activated_from_overflow_bubble_| should handle focusing the correct
+    // view.
+    if (activated_from_overflow_bubble_) {
+      activated_from_overflow_bubble_ = false;
       return;
     }
     delegate_view_->SetPaneFocusAndFocusDefault();
--- a/ash/shelf/shelf_widget.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/shelf/shelf_widget.h	2019-05-17 18:53:08.252000000 +0300
@@ -103,10 +103,6 @@
 
   void set_default_last_focusable_child(bool default_last_focusable_child);
 
-  // Finds the first or last focusable child of the set (main shelf + overflow)
-  // and focuses it.
-  void FocusFirstOrLastFocusableChild(bool last);
-
   // Overridden from views::WidgetObserver:
   void OnWidgetActivationChanged(views::Widget* widget, bool active) override;
 
@@ -121,9 +117,6 @@
   void OnSessionStateChanged(session_manager::SessionState state) override;
 
   SkColor GetShelfBackgroundColor() const;
-  bool GetHitTestRects(aura::Window* target,
-                       gfx::Rect* hit_test_rect_mouse,
-                       gfx::Rect* hit_test_rect_touch);
 
   // Internal implementation detail. Do not expose outside of tests.
   ShelfView* shelf_view_for_testing() const { return shelf_view_; }
@@ -131,8 +124,8 @@
     return &background_animator_;
   }
 
-  void set_activated_from_other_widget(bool val) {
-    activated_from_other_widget_ = val;
+  void set_activated_from_overflow_bubble(bool val) {
+    activated_from_overflow_bubble_ = val;
   }
 
  private:
@@ -170,10 +163,10 @@
   // Owned by the views hierarchy.
   LoginShelfView* const login_shelf_view_;
 
-  // Set to true when the widget is activated from another widget. Do not
-  // focus the default element in this case. This should be set when
-  // cycling focus from another widget to the shelf.
-  bool activated_from_other_widget_ = false;
+  // Set to true when the widget is activated from the shelf overflow bubble.
+  // Do not focus the default element in this case. This should be set when
+  // cycling focus from the overflow bubble to the main shelf.
+  bool activated_from_overflow_bubble_ = false;
 
   ScopedSessionObserver scoped_session_observer_;
 
--- a/ash/shelf/shelf_widget_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/shelf/shelf_widget_unittest.cc	2019-05-17 18:53:08.252000000 +0300
@@ -19,7 +19,6 @@
 #include "ash/test/ash_test_helper.h"
 #include "ash/test_shell_delegate.h"
 #include "ash/wm/window_util.h"
-#include "base/bind_helpers.h"
 #include "base/test/scoped_feature_list.h"
 #include "components/session_manager/session_manager_types.h"
 #include "ui/aura/window_event_dispatcher.h"
@@ -440,7 +439,7 @@
     ASSERT_NE(nullptr, primary_shelf_widget_);
     secondary_shelf_widget_ = Shelf::ForWindow(root_windows[1])->shelf_widget();
     ASSERT_NE(nullptr, secondary_shelf_widget_);
-  }
+  };
 
   void ExpectVisible(session_manager::SessionState state,
                      ShelfVisibility primary_shelf_visibility,
@@ -521,7 +520,10 @@
         keyboard::switches::kEnableVirtualKeyboard);
     AshTestBase::SetUp();
     ASSERT_TRUE(keyboard::IsKeyboardEnabled());
-    keyboard::test::WaitUntilLoaded();
+
+    keyboard_controller()->LoadKeyboardWindowInBackground();
+    // Wait for the keyboard window to load.
+    base::RunLoop().RunUntilIdle();
 
     // These tests only apply to the floating virtual keyboard, as it is the
     // only case where both the virtual keyboard and the shelf are visible.
--- a/ash/shelf/shelf_window_targeter.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/shelf/shelf_window_targeter.cc	2019-05-17 18:53:08.252000000 +0300
@@ -4,14 +4,9 @@
 
 #include "ash/shelf/shelf_window_targeter.h"
 
-#include "ash/public/cpp/session_types.h"
 #include "ash/public/cpp/shelf_types.h"
-#include "ash/public/cpp/shell_window_ids.h"
-#include "ash/session/session_controller.h"
 #include "ash/shelf/shelf.h"
 #include "ash/shelf/shelf_constants.h"
-#include "ash/shelf/shelf_widget.h"
-#include "ash/shell.h"
 #include "ui/aura/window.h"
 
 namespace ash {
@@ -46,29 +41,6 @@
   return true;
 }
 
-bool ShelfWindowTargeter::GetHitTestRects(
-    aura::Window* target,
-    gfx::Rect* hit_test_rect_mouse,
-    gfx::Rect* hit_test_rect_touch) const {
-  // We only want to special case a very specific situation where we are not
-  // currently in an active session (or unknown session state) and change only
-  // the behavior of the login shelf. On secondary displays, the login shelf
-  // will not be visible.
-  if (target->id() == kShellWindowId_ShelfContainer && shelf_->IsVisible() &&
-      Shell::Get()->session_controller()->GetSessionState() !=
-          session_manager::SessionState::ACTIVE &&
-      Shell::Get()->session_controller()->GetSessionState() !=
-          session_manager::SessionState::UNKNOWN) {
-    // When this is the case, let events pass through the "empty" part of
-    // the shelf.
-    return shelf_->shelf_widget()->GetHitTestRects(target, hit_test_rect_mouse,
-                                                   hit_test_rect_touch);
-  }
-  // Otherwise, fall back to what our superclass does.
-  return EasyResizeWindowTargeter::GetHitTestRects(target, hit_test_rect_mouse,
-                                                   hit_test_rect_touch);
-}
-
 void ShelfWindowTargeter::OnWindowDestroying(aura::Window* window) {
   window->RemoveObserver(this);
   shelf_->RemoveObserver(this);
--- a/ash/shelf/shelf_window_targeter.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/shelf/shelf_window_targeter.h	2019-05-17 18:53:08.252000000 +0300
@@ -27,9 +27,6 @@
  private:
   // ::wm::EasyResizeWindowTargeter:
   bool ShouldUseExtendedBounds(const aura::Window* window) const override;
-  bool GetHitTestRects(aura::Window* target,
-                       gfx::Rect* hit_test_rect_mouse,
-                       gfx::Rect* hit_test_rect_touch) const override;
 
   // aura::WindowObserver:
   void OnWindowDestroying(aura::Window* window) override;
--- a/ash/shelf/shelf_window_watcher.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/shelf/shelf_window_watcher.cc	2019-05-17 18:53:08.252000000 +0300
@@ -65,9 +65,7 @@
   }
 
   // Prefer app icons over window icons, they're typically larger.
-  gfx::ImageSkia* image = window->GetProperty(aura::client::kAppIconLargeKey);
-  if (!image || image->isNull())
-    image = window->GetProperty(aura::client::kAppIconKey);
+  gfx::ImageSkia* image = window->GetProperty(aura::client::kAppIconKey);
   if (!image || image->isNull())
     image = window->GetProperty(aura::client::kWindowIconKey);
   if (!image || image->isNull()) {
@@ -135,8 +133,7 @@
         ShelfID::Deserialize(window->GetProperty(kShelfIDKey)));
   }
 
-  if (key == aura::client::kAppIconLargeKey ||
-      key == aura::client::kAppIconKey || key == aura::client::kWindowIconKey ||
+  if (key == aura::client::kAppIconKey || key == aura::client::kWindowIconKey ||
       key == aura::client::kDrawAttentionKey || key == kShelfItemTypeKey ||
       key == kShelfIDKey) {
     window_watcher_->OnUserWindowPropertyChanged(window);
--- a/ash/shell/content/client/DEPS	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/shell/content/client/DEPS	2019-05-17 18:53:08.252000000 +0300
@@ -1,4 +1,5 @@
 include_rules = [
+  "+ash/components/quick_launch",
   "+ash/components/shortcut_viewer",
   "+ash/components/tap_visualizer",
   "+components/discardable_memory/public/interfaces",
--- a/ash/shell/content/client/shell_browser_main_parts.cc	2019-05-17 17:45:36.500000000 +0300
+++ b/ash/shell/content/client/shell_browser_main_parts.cc	2019-05-17 18:53:08.252000000 +0300
@@ -7,15 +7,12 @@
 #include <memory>
 #include <utility>
 
+#include "ash/components/quick_launch/public/mojom/constants.mojom.h"
 #include "ash/components/shortcut_viewer/public/mojom/shortcut_viewer.mojom.h"
 #include "ash/components/tap_visualizer/public/mojom/tap_visualizer.mojom.h"
 #include "ash/keyboard/test_keyboard_ui.h"
 #include "ash/login_status.h"
-#include "ash/public/cpp/mus_property_mirror_ash.h"
-#include "ash/public/cpp/window_properties.h"
 #include "ash/shell.h"
-#include "ash/shell/content/embedded_browser.h"
-#include "ash/shell/example_app_list_client.h"
 #include "ash/shell/example_session_controller_client.h"
 #include "ash/shell/shell_delegate_impl.h"
 #include "ash/shell/shell_views_delegate.h"
@@ -27,7 +24,6 @@
 #include "base/i18n/icu_util.h"
 #include "base/run_loop.h"
 #include "base/strings/string_number_conversions.h"
-#include "base/task/post_task.h"
 #include "base/threading/thread.h"
 #include "base/threading/thread_restrictions.h"
 #include "base/time/time.h"
@@ -35,8 +31,6 @@
 #include "chromeos/dbus/dbus_thread_manager.h"
 #include "chromeos/dbus/power_policy_controller.h"
 #include "components/exo/file_helper.h"
-#include "content/public/browser/browser_task_traits.h"
-#include "content/public/browser/browser_thread.h"
 #include "content/public/browser/context_factory.h"
 #include "content/public/browser/gpu_interface_provider_factory.h"
 #include "content/public/common/content_switches.h"
@@ -47,17 +41,13 @@
 #include "net/base/net_module.h"
 #include "services/service_manager/public/cpp/connector.h"
 #include "services/ws/ime/test_ime_driver/public/mojom/constants.mojom.h"
-#include "services/ws/public/mojom/constants.mojom.h"
 #include "ui/aura/env.h"
-#include "ui/aura/mus/window_tree_client.h"
 #include "ui/aura/window.h"
 #include "ui/aura/window_tree_host.h"
 #include "ui/base/material_design/material_design_controller.h"
-#include "ui/base/ui_base_features.h"
 #include "ui/base/ui_base_paths.h"
 #include "ui/compositor/compositor.h"
 #include "ui/views/examples/examples_window_with_content.h"
-#include "ui/views/mus/mus_client.h"
 #include "ui/wm/core/wm_state.h"
 
 namespace ash {
@@ -72,10 +62,6 @@
 
 void ShellBrowserMainParts::PostMainMessageLoopStart() {
   chromeos::DBusThreadManager::Initialize(chromeos::DBusThreadManager::kShared);
-
-  // WindowTreeClient needs to do some shutdown while the IO thread is alive.
-  if (mus_client_)
-    mus_client_->window_tree_client()->OnEarlyShutdown();
 }
 
 void ShellBrowserMainParts::ToolkitInitialized() {
@@ -98,27 +84,11 @@
   bluez::BluezDBusManager::Initialize();
 
   chromeos::PowerPolicyController::Initialize(
-      chromeos::PowerManagerClient::Get());
+      chromeos::DBusThreadManager::Get()->GetPowerManagerClient());
 
   service_manager::Connector* const connector =
       content::ServiceManagerConnection::GetForProcess()->GetConnector();
 
-  if (features::IsUsingWindowService()) {
-    connector->WarmService(
-        service_manager::ServiceFilter::ByName(ws::mojom::kServiceName));
-
-    views::MusClient::InitParams params;
-    params.connector = connector;
-    params.io_task_runner = base::CreateSingleThreadTaskRunnerWithTraits(
-        {content::BrowserThread::IO});
-    params.create_wm_state = false;
-    params.running_in_ws_process = features::IsSingleProcessMash();
-    mus_client_ = std::make_unique<views::MusClient>(params);
-    ash::RegisterWindowProperties(mus_client_->property_converter());
-    mus_client_->SetMusPropertyMirror(
-        std::make_unique<ash::MusPropertyMirrorAsh>());
-  }
-
   ui::MaterialDesignController::Initialize();
   ash::ShellInitParams init_params;
   init_params.delegate = std::make_unique<ash::shell::ShellDelegateImpl>();
@@ -139,15 +109,9 @@
   window_watcher_ = std::make_unique<WindowWatcher>();
 
   ash::shell::InitWindowTypeLauncher(
-      base::BindRepeating(&views::examples::ShowExamplesWindowWithContent,
+      base::Bind(&views::examples::ShowExamplesWindowWithContent,
                           base::Passed(base::OnceClosure()),
-                          base::Unretained(browser_context_.get()), nullptr),
-      base::BindRepeating(&EmbeddedBrowser::Create,
-                          base::Unretained(browser_context_.get()),
-                          GURL("https://www.9oo91e.qjz9zk")));
-
-  example_app_list_client_ = std::make_unique<ExampleAppListClient>(
-      Shell::Get()->app_list_controller());
+                 base::Unretained(browser_context_.get()), nullptr));
 
   ash::Shell::GetPrimaryRootWindow()->GetHost()->Show();
 
@@ -155,6 +119,8 @@
   connector->WarmService(service_manager::ServiceFilter::ByName(
       test_ime_driver::mojom::kServiceName));
   connector->WarmService(service_manager::ServiceFilter::ByName(
+      quick_launch::mojom::kServiceName));
+  connector->WarmService(service_manager::ServiceFilter::ByName(
       tap_visualizer::mojom::kServiceName));
   shortcut_viewer::mojom::ShortcutViewerPtr shortcut_viewer;
   connector->BindInterface(service_manager::ServiceFilter::ByName(
@@ -182,10 +148,7 @@
 }
 
 bool ShellBrowserMainParts::MainMessageLoopRun(int* result_code) {
-  base::RunLoop run_loop;
-  example_session_controller_client_->set_quit_closure(
-      run_loop.QuitWhenIdleClosure());
-  run_loop.Run();
+  base::RunLoop().Run();
   return true;
 }
 
--- a/ash/shell/content/client/shell_browser_main_parts.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/shell/content/client/shell_browser_main_parts.h	2019-05-17 18:53:08.252000000 +0300
@@ -20,7 +20,6 @@
 }
 
 namespace views {
-class MusClient;
 class ViewsDelegate;
 }
 
@@ -31,7 +30,6 @@
 namespace ash {
 namespace shell {
 
-class ExampleAppListClient;
 class ExampleSessionControllerClient;
 class WindowWatcher;
 
@@ -60,8 +58,6 @@
   std::unique_ptr<wm::WMState> wm_state_;
   std::unique_ptr<ExampleSessionControllerClient>
       example_session_controller_client_;
-  std::unique_ptr<ExampleAppListClient> example_app_list_client_;
-  std::unique_ptr<views::MusClient> mus_client_;
 
   DISALLOW_COPY_AND_ASSIGN(ShellBrowserMainParts);
 };
--- a/ash/shell/content/client/shell_content_browser_client.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/shell/content/client/shell_content_browser_client.cc	2019-05-17 18:53:08.256000000 +0300
@@ -4,16 +4,16 @@
 
 #include "ash/shell/content/client/shell_content_browser_client.h"
 
-#include <memory>
 #include <utility>
 
 #include "ash/ash_service.h"
-#include "ash/components/shortcut_viewer/public/cpp/manifest.h"
+#include "ash/components/quick_launch/manifest.h"
+#include "ash/components/quick_launch/public/mojom/constants.mojom.h"
+#include "ash/components/shortcut_viewer/manifest.h"
 #include "ash/components/shortcut_viewer/public/mojom/shortcut_viewer.mojom.h"
-#include "ash/components/tap_visualizer/public/cpp/manifest.h"
+#include "ash/components/tap_visualizer/manifest.h"
 #include "ash/components/tap_visualizer/public/mojom/tap_visualizer.mojom.h"
-#include "ash/public/cpp/manifest.h"
-#include "ash/public/cpp/test_manifest.h"
+#include "ash/manifest.h"
 #include "ash/public/cpp/window_properties.h"
 #include "ash/public/interfaces/constants.mojom.h"
 #include "ash/shell.h"
@@ -32,7 +32,7 @@
 #include "services/device/public/mojom/constants.mojom.h"
 #include "services/service_manager/public/cpp/manifest.h"
 #include "services/service_manager/public/cpp/manifest_builder.h"
-#include "services/ws/ime/test_ime_driver/public/cpp/manifest.h"
+#include "services/ws/ime/test_ime_driver/manifest.h"
 #include "services/ws/ime/test_ime_driver/public/mojom/constants.mojom.h"
 #include "services/ws/public/mojom/constants.mojom.h"
 #include "services/ws/window_service.h"
@@ -49,9 +49,9 @@
       service_manager::ManifestBuilder()
           .RequireCapability(device::mojom::kServiceName, "device:fingerprint")
           .RequireCapability(shortcut_viewer::mojom::kServiceName,
-                             shortcut_viewer::mojom::kToggleUiCapability)
+                             "shortcut_viewer")
           .RequireCapability(tap_visualizer::mojom::kServiceName,
-                             tap_visualizer::mojom::kShowUiCapability)
+                             "tap_visualizer")
           .Build()};
   return *manifest;
 }
@@ -59,10 +59,10 @@
 const service_manager::Manifest& GetAshShellPackagedServicesOverlayManifest() {
   static base::NoDestructor<service_manager::Manifest> manifest{
       service_manager::ManifestBuilder()
-          .PackageService(service_manager::Manifest(ash::GetManifest())
-                              .Amend(ash::GetManifestOverlayForTesting()))
-          .PackageService(shortcut_viewer::GetManifest())
-          .PackageService(tap_visualizer::GetManifest())
+          .PackageService(ash::GetManifest())
+          .PackageService(quick_launch_app::GetManifest())
+          .PackageService(shortcut_viewer_app::GetManifest())
+          .PackageService(tap_visualizer_app::GetManifest())
           .PackageService(test_ime_driver::GetManifest())
           .Build()};
   return *manifest;
@@ -86,8 +86,7 @@
     content::StoragePartition* partition,
     storage::OptionalQuotaSettingsCallback callback) {
   storage::GetNominalDynamicSettings(
-      partition->GetPath(), context->IsOffTheRecord(),
-      storage::GetDefaultDiskInfoHelper(), std::move(callback));
+      partition->GetPath(), context->IsOffTheRecord(), std::move(callback));
 }
 
 base::Optional<service_manager::Manifest>
@@ -105,6 +104,8 @@
 
 void ShellContentBrowserClient::RegisterOutOfProcessServices(
     OutOfProcessServiceMap* services) {
+  (*services)[quick_launch::mojom::kServiceName] = base::BindRepeating(
+      &base::ASCIIToUTF16, quick_launch::mojom::kServiceName);
   (*services)[shortcut_viewer::mojom::kServiceName] = base::BindRepeating(
       &base::ASCIIToUTF16, shortcut_viewer::mojom::kServiceName);
   (*services)[tap_visualizer::mojom::kServiceName] = base::BindRepeating(
--- a/ash/shell/content/client/shell_main_delegate.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/shell/content/client/shell_main_delegate.cc	2019-05-17 18:53:08.256000000 +0300
@@ -4,12 +4,13 @@
 
 #include "ash/shell/content/client/shell_main_delegate.h"
 
+#include "ash/components/quick_launch/public/mojom/constants.mojom.h"
+#include "ash/components/quick_launch/quick_launch_application.h"
 #include "ash/components/shortcut_viewer/public/mojom/shortcut_viewer.mojom.h"
 #include "ash/components/shortcut_viewer/shortcut_viewer_application.h"
 #include "ash/components/tap_visualizer/public/mojom/tap_visualizer.mojom.h"
 #include "ash/components/tap_visualizer/tap_visualizer_app.h"
 #include "ash/shell/content/client/shell_content_browser_client.h"
-#include "base/bind.h"
 #include "base/command_line.h"
 #include "base/files/file_path.h"
 #include "base/logging.h"
@@ -30,6 +31,13 @@
   content::UtilityThread::Get()->ReleaseProcess();
 }
 
+std::unique_ptr<service_manager::Service> CreateQuickLaunch(
+    service_manager::mojom::ServiceRequest request) {
+  logging::SetLogPrefix("quick");
+  return std::make_unique<quick_launch::QuickLaunchApplication>(
+      std::move(request));
+}
+
 std::unique_ptr<service_manager::Service> CreateShortcutViewer(
     service_manager::mojom::ServiceRequest request) {
   logging::SetLogPrefix("shortcut");
@@ -58,7 +66,9 @@
       const std::string& service_name,
       service_manager::mojom::ServiceRequest request) override {
     std::unique_ptr<service_manager::Service> service;
-    if (service_name == test_ime_driver::mojom::kServiceName)
+    if (service_name == quick_launch::mojom::kServiceName)
+      service = CreateQuickLaunch(std::move(request));
+    else if (service_name == test_ime_driver::mojom::kServiceName)
       service = CreateTestImeDriver(std::move(request));
     else if (service_name == shortcut_viewer::mojom::kServiceName)
       service = CreateShortcutViewer(std::move(request));
--- a/ash/shell/example_session_controller_client.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/shell/example_session_controller_client.cc	2019-05-17 18:53:08.256000000 +0300
@@ -54,10 +54,5 @@
   Shell::Get()->UpdateShelfVisibility();
 }
 
-void ExampleSessionControllerClient::RequestSignOut() {
-  DCHECK(quit_closure_);
-  std::move(quit_closure_).Run();
-}
-
 }  // namespace shell
 }  // namespace ash
--- a/ash/shell/example_session_controller_client.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/shell/example_session_controller_client.h	2019-05-17 18:53:08.256000000 +0300
@@ -5,10 +5,7 @@
 #ifndef ASH_SHELL_EXAMPLE_SESSION_CONTROLLER_CLIENT_H_
 #define ASH_SHELL_EXAMPLE_SESSION_CONTROLLER_CLIENT_H_
 
-#include <utility>
-
 #include "ash/session/test_session_controller_client.h"
-#include "base/callback.h"
 #include "base/macros.h"
 
 namespace ash {
@@ -26,18 +23,11 @@
 
   void Initialize();
 
-  void set_quit_closure(base::OnceClosure quit_closure) {
-    quit_closure_ = std::move(quit_closure);
-  }
-
   // TestSessionControllerClient
   void RequestLockScreen() override;
   void UnlockScreen() override;
-  void RequestSignOut() override;
 
  private:
-  base::OnceClosure quit_closure_;
-
   DISALLOW_COPY_AND_ASSIGN(ExampleSessionControllerClient);
 };
 
--- a/ash/shell/window_type_launcher.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/shell/window_type_launcher.cc	2019-05-17 18:53:08.256000000 +0300
@@ -163,21 +163,17 @@
 
 }  // namespace
 
-void InitWindowTypeLauncher(
-    base::RepeatingClosure show_views_examples_callback,
-    base::RepeatingClosure create_embedded_browser_callback) {
+void InitWindowTypeLauncher(const base::Closure& show_views_examples_callback) {
   views::Widget* widget = views::Widget::CreateWindowWithContextAndBounds(
-      new WindowTypeLauncher(show_views_examples_callback,
-                             create_embedded_browser_callback),
-      Shell::GetPrimaryRootWindow(), gfx::Rect(120, 120, 300, 410));
+      new WindowTypeLauncher(show_views_examples_callback),
+      Shell::GetPrimaryRootWindow(), gfx::Rect(120, 150, 300, 410));
   widget->GetNativeView()->SetName("WindowTypeLauncher");
   ::wm::SetShadowElevation(widget->GetNativeView(), kWindowShadowElevation);
   widget->Show();
 }
 
 WindowTypeLauncher::WindowTypeLauncher(
-    base::RepeatingClosure show_views_examples_callback,
-    base::RepeatingClosure create_embedded_browser_callback)
+    const base::Closure& show_views_examples_callback)
     : create_button_(
           MdTextButton::Create(this, base::ASCIIToUTF16("Create Window"))),
       create_nonresizable_button_(MdTextButton::Create(
@@ -211,11 +207,7 @@
       show_web_notification_(MdTextButton::Create(
           this,
           base::ASCIIToUTF16("Show a web/app notification"))),
-      embedded_browser_button_(
-          MdTextButton::Create(this, base::ASCIIToUTF16("Embedded Browser"))),
-      show_views_examples_callback_(std::move(show_views_examples_callback)),
-      create_embedded_browser_callback_(
-          std::move(create_embedded_browser_callback)) {
+      show_views_examples_callback_(show_views_examples_callback) {
   views::GridLayout* layout =
       SetLayoutManager(std::make_unique<views::GridLayout>(this));
   SetBorder(views::CreateEmptyBorder(gfx::Insets(5)));
@@ -234,7 +226,6 @@
   AddViewToLayout(layout, examples_button_);
   AddViewToLayout(layout, show_hide_window_button_);
   AddViewToLayout(layout, show_web_notification_);
-  AddViewToLayout(layout, embedded_browser_button_);
   set_context_menu_controller(this);
 }
 
@@ -274,8 +265,6 @@
     ToplevelWindow::CreateToplevelWindow(params);
   } else if (sender == create_nonresizable_button_) {
     ToplevelWindow::CreateToplevelWindow(ToplevelWindow::CreateParams());
-  } else if (sender == embedded_browser_button_) {
-    create_embedded_browser_callback_.Run();
   } else if (sender == bubble_button_) {
     CreatePointyBubble(sender);
   } else if (sender == lock_button_) {
@@ -315,8 +304,7 @@
 void WindowTypeLauncher::ExecuteCommand(int id, int event_flags) {
   switch (id) {
     case COMMAND_NEW_WINDOW:
-      InitWindowTypeLauncher(show_views_examples_callback_,
-                             create_embedded_browser_callback_);
+      InitWindowTypeLauncher(show_views_examples_callback_);
       break;
     case COMMAND_TOGGLE_FULLSCREEN:
       GetWidget()->SetFullscreen(!GetWidget()->IsFullscreen());
@@ -326,7 +314,7 @@
   }
 }
 
-void WindowTypeLauncher::ShowContextMenuForViewImpl(
+void WindowTypeLauncher::ShowContextMenuForView(
     views::View* source,
     const gfx::Point& point,
     ui::MenuSourceType source_type) {
--- a/ash/shell/window_type_launcher.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/shell/window_type_launcher.h	2019-05-17 18:53:08.256000000 +0300
@@ -25,11 +25,7 @@
 // is Run() when the user clicks on the views examples button. This should
 // be bound to either views::examples::ShowExamplesWindow() or
 // views::examples::ShowExamplesWindowWithContent().
-// |create_embedded_browser_callback| is Run when user clicks the "embedded
-// browser" button.
-void InitWindowTypeLauncher(
-    base::RepeatingClosure show_views_examples_callback,
-    base::RepeatingClosure create_embedded_browser_callback);
+void InitWindowTypeLauncher(const base::Closure& show_views_examples_callback);
 
 // The contents view/delegate of a window that shows some buttons that create
 // various window types.
@@ -38,8 +34,8 @@
                            public views::MenuDelegate,
                            public views::ContextMenuController {
  public:
-  WindowTypeLauncher(base::RepeatingClosure show_views_examples_callback,
-                     base::RepeatingClosure create_embedded_browser_callback);
+  explicit WindowTypeLauncher(
+      const base::Closure& show_views_examples_callback);
   ~WindowTypeLauncher() override;
 
  private:
@@ -67,7 +63,7 @@
   void ExecuteCommand(int id, int event_flags) override;
 
   // Override from views::ContextMenuController:
-  void ShowContextMenuForViewImpl(views::View* source,
+  void ShowContextMenuForView(views::View* source,
                                   const gfx::Point& point,
                                   ui::MenuSourceType source_type) override;
 
@@ -83,12 +79,8 @@
   views::Button* examples_button_;
   views::Button* show_hide_window_button_;
   views::Button* show_web_notification_;
-  views::Button* embedded_browser_button_;
-
   std::unique_ptr<views::MenuRunner> menu_runner_;
-
-  base::RepeatingClosure show_views_examples_callback_;
-  base::RepeatingClosure create_embedded_browser_callback_;
+  base::Closure show_views_examples_callback_;
 
   DISALLOW_COPY_AND_ASSIGN(WindowTypeLauncher);
 };
--- a/ash/shell/window_watcher.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/shell/window_watcher.cc	2019-05-17 18:53:08.256000000 +0300
@@ -90,7 +90,7 @@
   ShelfItem item;
   item.type = TYPE_APP;
   static int shelf_id = 0;
-  item.id = ShelfID(base::NumberToString(shelf_id++));
+  item.id = ShelfID(base::IntToString(shelf_id++));
   id_to_window_[item.id] = new_window;
 
   SkBitmap icon_bitmap;
@@ -98,7 +98,7 @@
   constexpr SkColor colors[] = {SK_ColorRED, SK_ColorGREEN, SK_ColorBLUE};
   icon_bitmap.eraseColor(colors[shelf_id % 3]);
   item.image = gfx::ImageSkia(gfx::ImageSkiaRep(icon_bitmap, 1.0f));
-  item.title = base::NumberToString16(shelf_id);
+  item.title = base::IntToString16(shelf_id);
   model->Add(item);
 
   model->SetShelfItemDelegate(
--- a/ash/shell.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/shell.cc	2019-05-17 18:53:08.252000000 +0300
@@ -24,7 +24,7 @@
 #include "ash/autoclick/autoclick_controller.h"
 #include "ash/cast_config_controller.h"
 #include "ash/components/tap_visualizer/public/mojom/tap_visualizer.mojom.h"
-#include "ash/custom_tab/arc_custom_tab_controller.h"
+#include "ash/contained_shell/contained_shell_controller.h"
 #include "ash/dbus/ash_dbus_services.h"
 #include "ash/detachable_base/detachable_base_handler.h"
 #include "ash/detachable_base/detachable_base_notification_controller.h"
@@ -54,12 +54,10 @@
 #include "ash/frame/non_client_frame_view_ash.h"
 #include "ash/high_contrast/high_contrast_controller.h"
 #include "ash/highlighter/highlighter_controller.h"
-#include "ash/home_screen/home_screen_controller.h"
 #include "ash/host/ash_window_tree_host_init_params.h"
 #include "ash/ime/ime_controller.h"
 #include "ash/ime/ime_focus_handler.h"
 #include "ash/keyboard/ash_keyboard_controller.h"
-#include "ash/kiosk_next/kiosk_next_shell_controller.h"
 #include "ash/laser/laser_pointer_controller.h"
 #include "ash/login/login_screen_controller.h"
 #include "ash/login_status.h"
@@ -105,12 +103,10 @@
 #include "ash/system/model/system_tray_model.h"
 #include "ash/system/network/sms_observer.h"
 #include "ash/system/network/vpn_list.h"
-#include "ash/system/network/vpn_list_view.h"
 #include "ash/system/night_light/night_light_controller.h"
 #include "ash/system/palette/palette_tray.h"
 #include "ash/system/palette/palette_welcome_bubble.h"
 #include "ash/system/power/backlights_forced_off_setter.h"
-#include "ash/system/power/notification_reporter.h"
 #include "ash/system/power/peripheral_battery_notifier.h"
 #include "ash/system/power/power_button_controller.h"
 #include "ash/system/power/power_event_observer.h"
@@ -135,7 +131,6 @@
 #include "ash/wm/ash_focus_rules.h"
 #include "ash/wm/container_finder.h"
 #include "ash/wm/cursor_manager_chromeos.h"
-#include "ash/wm/desks/desks_controller.h"
 #include "ash/wm/event_client_impl.h"
 #include "ash/wm/immersive_context_ash.h"
 #include "ash/wm/lock_state_controller.h"
@@ -252,9 +247,7 @@
   AccessibilityController::RegisterProfilePrefs(registry, for_test);
   AssistantController::RegisterProfilePrefs(registry);
   BluetoothPowerController::RegisterProfilePrefs(registry);
-  CapsLockNotificationController::RegisterProfilePrefs(registry, for_test);
   DockedMagnifierController::RegisterProfilePrefs(registry, for_test);
-  KioskNextShellController::RegisterProfilePrefs(registry);
   LoginScreenController::RegisterProfilePrefs(registry, for_test);
   LogoutButtonTray::RegisterProfilePrefs(registry);
   MessageCenterController::RegisterProfilePrefs(registry);
@@ -263,7 +256,7 @@
   PaletteWelcomeBubble::RegisterProfilePrefs(registry);
   ShelfController::RegisterProfilePrefs(registry);
   TouchDevicesController::RegisterProfilePrefs(registry);
-  tray::VPNListView::RegisterProfilePrefs(registry);
+  CapsLockNotificationController::RegisterProfilePrefs(registry, for_test);
 }
 
 }  // namespace
@@ -428,10 +421,6 @@
   PowerPrefs::RegisterUserProfilePrefs(registry, for_test);
 }
 
-display::DisplayConfigurator* Shell::display_configurator() {
-  return display_manager_->configurator();
-}
-
 void Shell::InitWaylandServer(std::unique_ptr<exo::FileHelper> file_helper) {
   wayland_server_controller_ = WaylandServerController::CreateIfNecessary(
       std::move(file_helper), aura_env_);
@@ -503,10 +492,12 @@
 }
 
 DockedMagnifierController* Shell::docked_magnifier_controller() {
+  DCHECK(features::IsDockedMagnifierEnabled());
   return docked_magnifier_controller_.get();
 }
 
 NightLightController* Shell::night_light_controller() {
+  DCHECK(features::IsNightLightEnabled());
   return night_light_controller_.get();
 }
 
@@ -586,6 +577,32 @@
     root_window_controller->UpdateAfterLoginStatusChange(status);
 }
 
+void Shell::NotifyOverviewModeStarting() {
+  for (auto& observer : shell_observers_)
+    observer.OnOverviewModeStarting();
+}
+
+void Shell::NotifyOverviewModeStartingAnimationComplete(bool canceled) {
+  for (auto& observer : shell_observers_)
+    observer.OnOverviewModeStartingAnimationComplete(canceled);
+}
+
+void Shell::NotifyOverviewModeEnding(OverviewSession* overview_session) {
+  DCHECK(overview_session);
+  for (auto& observer : shell_observers_)
+    observer.OnOverviewModeEnding(overview_session);
+}
+
+void Shell::NotifyOverviewModeEnded() {
+  for (auto& observer : shell_observers_)
+    observer.OnOverviewModeEnded();
+}
+
+void Shell::NotifyOverviewModeEndingAnimationComplete(bool canceled) {
+  for (auto& observer : shell_observers_)
+    observer.OnOverviewModeEndingAnimationComplete(canceled);
+}
+
 void Shell::NotifySplitViewModeStarting() {
   for (auto& observer : shell_observers_)
     observer.OnSplitViewModeStarting();
@@ -637,20 +654,18 @@
                           : nullptr),
       aura_env_(owned_aura_env_.get() ? owned_aura_env_.get()
                                       : aura::Env::GetInstance()),
-      arc_custom_tab_controller_(std::make_unique<ArcCustomTabController>()),
       ash_display_controller_(std::make_unique<AshDisplayController>()),
       brightness_control_delegate_(
           std::make_unique<system::BrightnessControllerChromeos>()),
       cast_config_(std::make_unique<CastConfigController>()),
       connector_(connector),
+      contained_shell_controller_(std::make_unique<ContainedShellController>()),
       first_run_helper_(std::make_unique<FirstRunHelper>()),
       focus_cycler_(std::make_unique<FocusCycler>()),
       ime_controller_(std::make_unique<ImeController>()),
       immersive_context_(std::make_unique<ImmersiveContextAsh>()),
       keyboard_brightness_control_delegate_(
           std::make_unique<KeyboardBrightnessController>()),
-      kiosk_next_shell_controller_(
-          std::make_unique<KioskNextShellController>()),
       locale_update_controller_(std::make_unique<LocaleUpdateController>()),
       media_controller_(std::make_unique<MediaController>(connector)),
       new_window_controller_(std::make_unique<NewWindowController>()),
@@ -662,6 +677,9 @@
       system_tray_notifier_(std::make_unique<SystemTrayNotifier>()),
       vpn_list_(std::make_unique<VpnList>()),
       window_cycle_controller_(std::make_unique<WindowCycleController>()),
+      display_configurator_(std::make_unique<display::DisplayConfigurator>()),
+      display_output_protection_(std::make_unique<DisplayOutputProtection>(
+          display_configurator_.get())),
       native_cursor_manager_(nullptr),
       weak_factory_(this) {
   // Ash doesn't properly remove pre-target-handlers.
@@ -675,8 +693,6 @@
   login_screen_controller_ =
       std::make_unique<LoginScreenController>(system_tray_notifier_.get());
   display_manager_.reset(ScreenAsh::CreateDisplayManager());
-  display_output_protection_ = std::make_unique<DisplayOutputProtection>(
-      display_manager_->configurator());
   window_tree_host_manager_ = std::make_unique<WindowTreeHostManager>();
   user_metrics_recorder_ = std::make_unique<UserMetricsRecorder>();
   ash_keyboard_controller_ =
@@ -697,9 +713,6 @@
 Shell::~Shell() {
   TRACE_EVENT0("shutdown", "ash::Shell::Destructor");
 
-  for (auto& observer : shell_observers_)
-    observer.OnShellDestroying();
-
   // Wayland depends upon some ash specific objects. Destroy it early on.
   wayland_server_controller_.reset();
 
@@ -749,11 +762,7 @@
   // Depends on |tablet_mode_controller_|.
   shelf_controller_->Shutdown();
 
-  // Destroy |home_screen_controller_| before |app_list_controller_| since
-  // the former delegates to the latter.
-  home_screen_controller_.reset();
-
-  // Destroy |app_list_controller_| earlier than |tablet_mode_controller_| since
+  // Destroy |app_list_controller_| early than |tablet_mode_controller_| since
   // the former may use the latter before destruction.
   app_list_controller_.reset();
 
@@ -806,8 +815,6 @@
   // |overview_controller_|.
   split_view_controller_.reset();
 
-  desks_controller_.reset();
-
   // Stop dispatching events (e.g. synthesized mouse exits from window close).
   // https://crbug.com/874156
   for (RootWindowController* rwc : GetAllRootWindowControllers())
@@ -912,11 +919,9 @@
   projecting_observer_.reset();
 
   if (display_change_observer_)
-    display_manager_->configurator()->RemoveObserver(
-        display_change_observer_.get());
+    display_configurator_->RemoveObserver(display_change_observer_.get());
   if (display_error_observer_)
-    display_manager_->configurator()->RemoveObserver(
-        display_error_observer_.get());
+    display_configurator_->RemoveObserver(display_error_observer_.get());
   display_change_observer_.reset();
   display_shutdown_observer_.reset();
 
@@ -925,7 +930,6 @@
   PowerStatus::Shutdown();
   // Depends on SessionController.
   power_event_observer_.reset();
-  notification_reporter_.reset();
 
   session_controller_->RemoveObserver(this);
   // BluetoothPowerController depends on the PrefService and must be destructed
@@ -1034,8 +1038,6 @@
   cursor_manager_ =
       std::make_unique<CursorManager>(base::WrapUnique(native_cursor_manager_));
 
-  InitializeDisplayManager();
-
   // In CLASSIC mode, |initial_display_prefs| contains the synchronously
   // loaded display pref values. Otherwise |initial_display_prefs| is null and
   // the pref values will be loaded once |local_state_| is available. (Any store
@@ -1043,6 +1045,8 @@
   display_prefs_ =
       std::make_unique<DisplayPrefs>(std::move(initial_display_prefs));
 
+  InitializeDisplayManager();
+
   // This will initialize aura::Env which requires |display_manager_| to
   // be initialized first.
   if (context_factory)
@@ -1052,6 +1056,7 @@
 
   // Night Light depends on the display manager, the display color manager, and
   // aura::Env, so initialize it after all have been initialized.
+  if (features::IsNightLightEnabled())
   night_light_controller_ = std::make_unique<NightLightController>();
 
   // The WindowModalityController needs to be at the front of the input event
@@ -1097,6 +1102,9 @@
   voice_interaction_controller_ =
       std::make_unique<VoiceInteractionController>();
 
+  // |app_list_controller_| is put after |tablet_mode_controller_| as the former
+  // uses the latter in constructor.
+  app_list_controller_ = std::make_unique<AppListControllerImpl>();
   shelf_controller_ = std::make_unique<ShelfController>();
 
   magnifier_key_scroll_handler_ = MagnifierKeyScroller::CreateHandler();
@@ -1130,9 +1138,9 @@
   sticky_keys_controller_.reset(new StickyKeysController);
   screen_pinning_controller_ = std::make_unique<ScreenPinningController>();
 
-  power_prefs_ =
-      std::make_unique<PowerPrefs>(chromeos::PowerPolicyController::Get(),
-                                   chromeos::PowerManagerClient::Get());
+  power_prefs_ = std::make_unique<PowerPrefs>(
+      chromeos::PowerPolicyController::Get(),
+      chromeos::DBusThreadManager::Get()->GetPowerManagerClient());
 
   backlights_forced_off_setter_ = std::make_unique<BacklightsForcedOffSetter>();
 
@@ -1145,7 +1153,7 @@
       backlights_forced_off_setter_.get());
   // Pass the initial display state to PowerButtonController.
   power_button_controller_->OnDisplayModeChanged(
-      display_configurator()->cached_displays());
+      display_configurator_->cached_displays());
 
   drag_drop_controller_ = std::make_unique<DragDropController>();
 
@@ -1170,22 +1178,15 @@
 
   magnification_controller_ = std::make_unique<MagnificationController>();
   mru_window_tracker_ = std::make_unique<MruWindowTracker>();
-  assistant_controller_ = chromeos::switches::IsAssistantEnabled()
-                              ? std::make_unique<AssistantController>()
-                              : nullptr;
-  home_screen_controller_ = std::make_unique<HomeScreenController>();
-
-  // |tablet_mode_controller_| |mru_window_tracker_|,
-  // |assistant_controller_| and |home_screen_controller_| are put before
-  // |app_list_controller_| as they are used in its constructor.
-  app_list_controller_ = std::make_unique<AppListControllerImpl>();
-  home_screen_controller_->SetDelegate(app_list_controller_.get());
 
   autoclick_controller_ = std::make_unique<AutoclickController>();
 
   high_contrast_controller_.reset(new HighContrastController);
 
-  docked_magnifier_controller_ = std::make_unique<DockedMagnifierController>();
+  if (features::IsDockedMagnifierEnabled()) {
+    docked_magnifier_controller_ =
+        std::make_unique<DockedMagnifierController>();
+  }
 
   video_detector_ = std::make_unique<VideoDetector>();
 
@@ -1229,6 +1230,12 @@
 
   window_tree_host_manager_->InitHosts();
 
+  // |assistant_controller_| needs to be created after InitHosts() since its
+  // keyboard observer function result has dependency on workspace change.
+  assistant_controller_ = chromeos::switches::IsAssistantEnabled()
+                              ? std::make_unique<AssistantController>()
+                              : nullptr;
+
   cursor_manager_->HideCursor();  // Hide the mouse cursor on startup.
   cursor_manager_->SetCursor(ui::CursorType::kPointer);
 
@@ -1247,9 +1254,6 @@
 
   split_view_controller_.reset(new SplitViewController());
 
-  if (features::IsVirtualDesksEnabled())
-    desks_controller_ = std::make_unique<DesksController>();
-
   key_accessibility_enabler_ = std::make_unique<KeyAccessibilityEnabler>();
 
   // The compositor thread and main message loop have to be running in
@@ -1284,8 +1288,6 @@
 
   user_metrics_recorder_->OnShellInitialized();
 
-  notification_reporter_ = std::make_unique<NotificationReporter>();
-
   // Initialize the D-Bus thread and services for ash.
   ash_dbus_services_ = std::make_unique<AshDBusServices>();
   // By this point ash shell should have initialized its D-Bus signal
@@ -1302,11 +1304,11 @@
 void Shell::InitializeDisplayManager() {
   bool display_initialized = display_manager_->InitFromCommandLine();
 
-  display_manager_->InitConfigurator(
-      ui::OzonePlatform::GetInstance()->CreateNativeDisplayDelegate());
   display_configuration_controller_ =
       std::make_unique<DisplayConfigurationController>(
           display_manager_.get(), window_tree_host_manager_.get());
+  display_configurator_->Init(
+      ui::OzonePlatform::GetInstance()->CreateNativeDisplayDelegate(), false);
   display_configuration_observer_ =
       std::make_unique<DisplayConfigurationObserver>();
 
@@ -1316,26 +1318,32 @@
       std::make_unique<PersistentWindowController>();
 
   projecting_observer_ =
-      std::make_unique<ProjectingObserver>(display_manager_->configurator());
+      std::make_unique<ProjectingObserver>(display_configurator_.get());
 
   if (!display_initialized) {
     if (chromeos::IsRunningAsSystemCompositor()) {
       display_change_observer_ =
           std::make_unique<display::DisplayChangeObserver>(
-              display_manager_.get());
+              display_configurator_.get(), display_manager_.get());
 
-      display_error_observer_ = std::make_unique<DisplayErrorObserver>();
       display_shutdown_observer_ = std::make_unique<DisplayShutdownObserver>(
-          display_manager_->configurator());
+          display_configurator_.get());
 
-      display_manager_->ForceInitialConfigureWithObservers(
-          display_change_observer_.get(), display_error_observer_.get());
+      // Register |display_change_observer_| first so that the rest of
+      // observer gets invoked after the root windows are configured.
+      display_configurator_->AddObserver(display_change_observer_.get());
+      display_error_observer_.reset(new DisplayErrorObserver());
+      display_configurator_->AddObserver(display_error_observer_.get());
+      display_configurator_->set_state_controller(
+          display_change_observer_.get());
+      display_configurator_->set_mirroring_controller(display_manager_.get());
+      display_configurator_->ForceInitialConfigure();
       display_initialized = true;
     }
   }
 
   display_color_manager_ = std::make_unique<DisplayColorManager>(
-      display_manager_->configurator(), display::Screen::GetScreen());
+      display_configurator_.get(), display::Screen::GetScreen());
 
   if (!display_initialized)
     display_manager_->InitDefaultDisplay();
@@ -1436,8 +1444,10 @@
   // the controller when the session is active. https://crbug.com/464118
   drag_drop_controller_->set_enabled(is_session_active);
 
-  if (is_session_active)
-    kiosk_next_shell_controller_->LaunchKioskNextShellIfEnabled();
+  if (base::FeatureList::IsEnabled(features::kContainedShell) &&
+      is_session_active) {
+    contained_shell_controller_->LaunchContainedShell();
+  }
 }
 
 void Shell::OnLoginStatusChanged(LoginStatus login_status) {
--- a/ash/shell.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/shell.h	2019-05-17 18:53:08.252000000 +0300
@@ -11,6 +11,7 @@
 
 #include "ash/ash_export.h"
 #include "ash/metrics/user_metrics_recorder.h"
+#include "ash/public/cpp/app_list/app_list_constants.h"
 #include "ash/public/cpp/shelf_types.h"
 #include "ash/session/session_observer.h"
 #include "ash/wm/system_modal_container_event_filter_delegate.h"
@@ -48,7 +49,7 @@
 namespace gfx {
 class Insets;
 class Point;
-}  // namespace gfx
+}
 
 namespace keyboard {
 class KeyboardUIFactory;
@@ -94,7 +95,6 @@
 class AccessibilityController;
 class AccessibilityDelegate;
 class AccessibilityFocusRingController;
-class ArcCustomTabController;
 class AshDBusServices;
 class AshDisplayController;
 class AppListControllerImpl;
@@ -108,8 +108,8 @@
 class BrightnessControlDelegate;
 class CastConfigController;
 class DisplayOutputProtection;
+class ContainedShellController;
 class CrosDisplayConfig;
-class DesksController;
 class DetachableBaseHandler;
 class DetachableBaseNotificationController;
 class DisplayColorManager;
@@ -128,13 +128,11 @@
 class FocusCycler;
 class HighContrastController;
 class HighlighterController;
-class HomeScreenController;
 class ImeController;
 class ImeFocusHandler;
 class ImmersiveContext;
 class KeyAccessibilityEnabler;
 class KeyboardBrightnessControlDelegate;
-class KioskNextShellController;
 class AshKeyboardController;
 class LaserPointerController;
 class LocaleUpdateController;
@@ -159,7 +157,6 @@
 class PolicyRecommendationRestorer;
 class PowerButtonController;
 class PowerEventObserver;
-class NotificationReporter;
 class PowerPrefs;
 class ProjectingObserver;
 class ResizeShadowController;
@@ -203,6 +200,7 @@
 class WindowServiceOwner;
 class WindowCycleController;
 class WindowPositioner;
+class OverviewSession;
 class OverviewController;
 class WindowTreeHostManager;
 
@@ -346,9 +344,6 @@
   AppListControllerImpl* app_list_controller() {
     return app_list_controller_.get();
   }
-  ArcCustomTabController* arc_custom_tab_controller() {
-    return arc_custom_tab_controller_.get();
-  }
   AshDisplayController* ash_display_controller() {
     return ash_display_controller_.get();
   }
@@ -370,11 +365,13 @@
   }
   CastConfigController* cast_config() { return cast_config_.get(); }
   service_manager::Connector* connector() { return connector_; }
+  ContainedShellController* contained_shell_controller() {
+    return contained_shell_controller_.get();
+  }
   CrosDisplayConfig* cros_display_config() {
     return cros_display_config_.get();
   }
   ::wm::CursorManager* cursor_manager() { return cursor_manager_.get(); }
-  DesksController* desks_controller() { return desks_controller_.get(); }
   DetachableBaseHandler* detachable_base_handler() {
     return detachable_base_handler_.get();
   }
@@ -385,8 +382,10 @@
     return display_configuration_controller_.get();
   }
 
-  display::DisplayConfigurator* display_configurator();
-
+  // TODO(oshima): Move these objects to WindowTreeHostManager.
+  display::DisplayConfigurator* display_configurator() {
+    return display_configurator_.get();
+  }
   DisplayColorManager* display_color_manager() {
     return display_color_manager_.get();
   }
@@ -407,9 +406,6 @@
   EventTransformationHandler* event_transformation_handler() {
     return event_transformation_handler_.get();
   }
-  HomeScreenController* home_screen_controller() {
-    return home_screen_controller_.get();
-  }
   FirstRunHelper* first_run_helper() { return first_run_helper_.get(); }
   ::wm::FocusController* focus_controller() { return focus_controller_.get(); }
   ::wm::FocusRules* focus_rules() { return focus_rules_; }
@@ -428,9 +424,6 @@
   KeyboardBrightnessControlDelegate* keyboard_brightness_control_delegate() {
     return keyboard_brightness_control_delegate_.get();
   }
-  KioskNextShellController* kiosk_next_shell_controller() {
-    return kiosk_next_shell_controller_.get();
-  }
   AshKeyboardController* ash_keyboard_controller() {
     return ash_keyboard_controller_.get();
   }
@@ -470,9 +463,6 @@
   NoteTakingController* note_taking_controller() {
     return note_taking_controller_.get();
   }
-  NotificationReporter* notification_reporter() {
-    return notification_reporter_.get();
-  }
   OverlayEventFilter* overlay_filter() { return overlay_filter_.get(); }
   PartialMagnificationController* partial_magnification_controller() {
     return partial_magnification_controller_.get();
@@ -611,6 +601,23 @@
   // TODO(oshima): Investigate if we can merge this and |OnLoginStateChanged|.
   void UpdateAfterLoginStatusChange(LoginStatus status);
 
+  // Notifies observers that overview mode is about to be started (before the
+  // windows get re-arranged).
+  void NotifyOverviewModeStarting();
+
+  // Notifies observers that the start overview mode animation has completed.
+  void NotifyOverviewModeStartingAnimationComplete(bool canceled);
+
+  // Notifies observers that overview mode is about to end (before the windows
+  // restore themselves). |overview_session| must not be null.
+  void NotifyOverviewModeEnding(OverviewSession* overview_session);
+
+  // Notifies observers that overview mode has ended.
+  void NotifyOverviewModeEnded();
+
+  // Notifies observers that the end overview mode animation has completed.
+  void NotifyOverviewModeEndingAnimationComplete(bool canceled);
+
   // Notifies observers that split view mode is about to be started (before the
   // window gets snapped and activated).
   void NotifySplitViewModeStarting();
@@ -716,7 +723,6 @@
   std::unique_ptr<AccessibilityFocusRingController>
       accessibility_focus_ring_controller_;
   std::unique_ptr<AppListControllerImpl> app_list_controller_;
-  std::unique_ptr<ArcCustomTabController> arc_custom_tab_controller_;
   std::unique_ptr<AshDBusServices> ash_dbus_services_;
   std::unique_ptr<AshDisplayController> ash_display_controller_;
   std::unique_ptr<AssistantController> assistant_controller_;
@@ -725,7 +731,7 @@
   std::unique_ptr<CastConfigController> cast_config_;
   std::unique_ptr<CrosDisplayConfig> cros_display_config_;
   service_manager::Connector* const connector_;
-  std::unique_ptr<DesksController> desks_controller_;
+  std::unique_ptr<ContainedShellController> contained_shell_controller_;
   std::unique_ptr<DetachableBaseHandler> detachable_base_handler_;
   std::unique_ptr<DetachableBaseNotificationController>
       detachable_base_notification_controller_;
@@ -733,13 +739,11 @@
   std::unique_ptr<DragDropController> drag_drop_controller_;
   std::unique_ptr<FirstRunHelper> first_run_helper_;
   std::unique_ptr<FocusCycler> focus_cycler_;
-  std::unique_ptr<HomeScreenController> home_screen_controller_;
   std::unique_ptr<ImeController> ime_controller_;
   std::unique_ptr<ImeFocusHandler> ime_focus_handler_;
   std::unique_ptr<ImmersiveContext> immersive_context_;
   std::unique_ptr<KeyboardBrightnessControlDelegate>
       keyboard_brightness_control_delegate_;
-  std::unique_ptr<KioskNextShellController> kiosk_next_shell_controller_;
   std::unique_ptr<LocaleUpdateController> locale_update_controller_;
   std::unique_ptr<LoginScreenController> login_screen_controller_;
   std::unique_ptr<LogoutConfirmationController> logout_confirmation_controller_;
@@ -836,6 +840,7 @@
   std::unique_ptr<TrayBluetoothHelper> tray_bluetooth_helper_;
   std::unique_ptr<AshKeyboardController> ash_keyboard_controller_;
   // Controls video output device state.
+  std::unique_ptr<display::DisplayConfigurator> display_configurator_;
   std::unique_ptr<DisplayOutputProtection> display_output_protection_;
   std::unique_ptr<DisplayColorManager> display_color_manager_;
   std::unique_ptr<DisplayErrorObserver> display_error_observer_;
@@ -885,8 +890,6 @@
 
   std::unique_ptr<MessageCenterController> message_center_controller_;
 
-  std::unique_ptr<NotificationReporter> notification_reporter_;
-
   base::ObserverList<ShellObserver>::Unchecked shell_observers_;
 
   base::WeakPtrFactory<Shell> weak_factory_;
--- a/ash/shell_observer.h	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/shell_observer.h	2019-05-17 18:53:08.256000000 +0300
@@ -16,6 +16,8 @@
 
 namespace ash {
 
+class OverviewSession;
+
 class ASH_EXPORT ShellObserver {
  public:
 
@@ -38,6 +40,27 @@
   // Invoked when |pinned_window| enter or exit pinned mode.
   virtual void OnPinnedStateChanged(aura::Window* pinned_window) {}
 
+  // Called when the overview mode is about to be started (before the windows
+  // get re-arranged).
+  virtual void OnOverviewModeStarting() {}
+
+  // Called after the animations that happen when overview mode is started are
+  // complete. If |canceled| it means overview was quit before the start
+  // animations were finished.
+  virtual void OnOverviewModeStartingAnimationComplete(bool canceled) {}
+
+  // Called when the overview mode is about to end (bofore the windows restore
+  // themselves). |overview_session| will not be null.
+  virtual void OnOverviewModeEnding(OverviewSession* overview_session) {}
+
+  // Called after overview mode has ended.
+  virtual void OnOverviewModeEnded() {}
+
+  // Called after the animations that happen when overview mode is ended are
+  // complete. If |canceled| it means overview was reentered before the exit
+  // animations were finished.
+  virtual void OnOverviewModeEndingAnimationComplete(bool canceled) {}
+
   // Called when the split view mode is about to be started before the window
   // gets snapped and activated).
   virtual void OnSplitViewModeStarting() {}
@@ -57,9 +80,6 @@
   // Called at the end of Shell::Init.
   virtual void OnShellInitialized() {}
 
-  // Called at the beginning of ~Shell.
-  virtual void OnShellDestroying() {}
-
   // Called near the end of ~Shell. Shell::Get() still returns the Shell, but
   // most of Shell's state has been deleted.
   virtual void OnShellDestroyed() {}
--- a/ash/shell_unittest.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/shell_unittest.cc	2019-05-17 18:53:08.256000000 +0300
@@ -555,7 +555,8 @@
 
 // Verifies keyboard is re-enabled on proper timing.
 TEST_F(ShellTest, KeyboardCreation) {
-  keyboard::SetTouchKeyboardEnabled(true);
+  base::CommandLine::ForCurrentProcess()->AppendSwitch(
+      keyboard::switches::kEnableVirtualKeyboard);
 
   ASSERT_TRUE(keyboard::IsKeyboardEnabled());
 
--- a/ash/shutdown_controller.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/shutdown_controller.cc	2019-05-17 18:53:08.256000000 +0300
@@ -46,10 +46,10 @@
   std::string description = base::StringPrintf("UI request from ash: %s",
                                                ShutdownReasonToString(reason));
   if (reboot_on_shutdown_) {
-    chromeos::PowerManagerClient::Get()->RequestRestart(
+    DBusThreadManager::Get()->GetPowerManagerClient()->RequestRestart(
         power_manager::REQUEST_RESTART_FOR_USER, description);
   } else {
-    chromeos::PowerManagerClient::Get()->RequestShutdown(
+    DBusThreadManager::Get()->GetPowerManagerClient()->RequestShutdown(
         power_manager::REQUEST_SHUTDOWN_FOR_USER, description);
   }
 }
--- a/ash/sticky_keys/sticky_keys_controller.cc	2019-05-01 01:22:26.000000000 +0300
+++ b/ash/sticky_keys/sticky_keys_controller.cc	2019-05-17 18:53:08.260000000 +0300
@@ -5,6 +5,7 @@
 #include "ash/sticky_keys/sticky_keys_controller.h"
 
 #include "ash/sticky_keys/sticky_keys_overlay.h"
+#include "base/debug/stack_trace.h"
 #include "ui/aura/window.h"
 #include "ui/aura/window_tracker.h"
 #include "ui/aura/window_tree_host.h"
--- a/ash/system/accessibility/autoclick_tray_action_list_view.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/accessibility/autoclick_tray_action_list_view.cc	2019-05-17 18:53:08.292000000 +0300
@@ -4,7 +4,6 @@
 
 #include "ash/system/accessibility/autoclick_tray_action_list_view.h"
 
-#include "ash/resources/vector_icons/vector_icons.h"
 #include "ash/strings/grit/ash_strings.h"
 #include "ash/system/accessibility/autoclick_tray.h"
 #include "ash/system/accessibility/autoclick_tray_action_view.h"
@@ -37,7 +36,6 @@
       this, mojom::AutoclickEventType::kLeftClick,
       l10n_util::GetStringUTF16(
           IDS_ASH_STATUS_TRAY_AUTOCLICK_OPTION_LEFT_CLICK),
-      kAutoclickLeftClickIcon,
       selected_event_type_ == mojom::AutoclickEventType::kLeftClick);
   left_click_view->set_id(kLeftClickViewID);
   AddChildView(left_click_view);
@@ -47,7 +45,6 @@
       this, mojom::AutoclickEventType::kRightClick,
       l10n_util::GetStringUTF16(
           IDS_ASH_STATUS_TRAY_AUTOCLICK_OPTION_RIGHT_CLICK),
-      kAutoclickRightClickIcon,
       selected_event_type_ == mojom::AutoclickEventType::kRightClick);
   right_click_view->set_id(kRightClickViewID);
   AddChildView(right_click_view);
@@ -57,7 +54,6 @@
       this, mojom::AutoclickEventType::kDoubleClick,
       l10n_util::GetStringUTF16(
           IDS_ASH_STATUS_TRAY_AUTOCLICK_OPTION_DOUBLE_CLICK),
-      kAutoclickDoubleClickIcon,
       selected_event_type_ == mojom::AutoclickEventType::kDoubleClick);
   double_click_view->set_id(kDoubleClickViewID);
   AddChildView(double_click_view);
@@ -67,7 +63,6 @@
       this, mojom::AutoclickEventType::kDragAndDrop,
       l10n_util::GetStringUTF16(
           IDS_ASH_STATUS_TRAY_AUTOCLICK_OPTION_DRAG_AND_DROP),
-      kAutoclickDragIcon,
       selected_event_type_ == mojom::AutoclickEventType::kDragAndDrop);
   drag_and_drop_view->set_id(kDragAndDropViewID);
   AddChildView(drag_and_drop_view);
@@ -76,7 +71,6 @@
   views::View* pause_view = new AutoclickTrayActionView(
       this, mojom::AutoclickEventType::kNoAction,
       l10n_util::GetStringUTF16(IDS_ASH_STATUS_TRAY_AUTOCLICK_OPTION_NO_ACTION),
-      kAutoclickPauseIcon,
       selected_event_type_ == mojom::AutoclickEventType::kNoAction);
   pause_view->set_id(kPauseViewID);
   AddChildView(pause_view);
--- a/ash/system/accessibility/autoclick_tray_action_view.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/accessibility/autoclick_tray_action_view.cc	2019-05-17 18:53:08.292000000 +0300
@@ -21,7 +21,6 @@
     AutoclickTrayActionListView* list_view,
     mojom::AutoclickEventType event_type,
     const base::string16& label,
-    const gfx::VectorIcon& vector_icon,
     bool selected)
     : ActionableView(TrayPopupInkDropStyle::FILL_BOUNDS),
       list_view_(list_view),
@@ -35,7 +34,8 @@
 
   views::ImageView* icon = new views::ImageView();
   // TODO(katie): Use autoclick assets when available.
-  icon->SetImage(gfx::CreateVectorIcon(vector_icon, gfx::kGoogleGrey700));
+  icon->SetImage(gfx::CreateVectorIcon(kSystemTraySelectToSpeakNewuiIcon,
+                                       gfx::kGoogleGrey700));
   tri_view->AddView(TriView::Container::START, icon);
 
   auto* label_view = TrayPopupUtils::CreateDefaultLabel();
--- a/ash/system/accessibility/autoclick_tray_action_view.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/accessibility/autoclick_tray_action_view.h	2019-05-17 18:53:08.292000000 +0300
@@ -8,7 +8,6 @@
 #include "ash/public/interfaces/accessibility_controller_enums.mojom.h"
 #include "ash/system/tray/actionable_view.h"
 #include "base/macros.h"
-#include "ui/gfx/vector_icon_types.h"
 
 namespace ash {
 class AutoclickTrayActionListView;
@@ -19,7 +18,6 @@
   AutoclickTrayActionView(AutoclickTrayActionListView* list_view,
                           mojom::AutoclickEventType event_type,
                           const base::string16& label,
-                          const gfx::VectorIcon& vector_icon,
                           bool selected);
   ~AutoclickTrayActionView() override = default;
 
--- a/ash/system/accessibility/autoclick_tray.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/accessibility/autoclick_tray.cc	2019-05-17 18:53:08.292000000 +0300
@@ -42,10 +42,11 @@
  public:
   explicit AutoclickTitleView(AutoclickTray* autoclick_tray)
       : autoclick_tray_(autoclick_tray) {
+    const int separator_width = TrayConstants::separator_width();
     SetBorder(views::CreatePaddedBorder(
-        views::CreateSolidSidedBorder(0, 0, kTraySeparatorWidth, 0,
+        views::CreateSolidSidedBorder(0, 0, separator_width, 0,
                                       kMenuSeparatorColor),
-        gfx::Insets(kMenuSeparatorVerticalPadding - kTraySeparatorWidth, 0)));
+        gfx::Insets(kMenuSeparatorVerticalPadding - separator_width, 0)));
     auto box_layout =
         std::make_unique<views::BoxLayout>(views::BoxLayout::kHorizontal);
     box_layout->set_minimum_cross_axis_size(kTrayPopupItemMinHeight);
@@ -227,7 +228,8 @@
       Shell::Get()->session_controller()->GetSessionState();
   SkColor color = TrayIconColor(session_state);
 
-  tray_image_ = gfx::CreateVectorIcon(kAutoclickIcon, color);
+  // TODO(katie): Use autoclick asset when available.
+  tray_image_ = gfx::CreateVectorIcon(kSystemTraySelectToSpeakNewuiIcon, color);
 }
 
 void AutoclickTray::CheckStatusAndUpdateIcon() {
--- a/ash/system/accessibility/tray_accessibility.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/accessibility/tray_accessibility.cc	2019-05-17 18:53:08.292000000 +0300
@@ -90,10 +90,12 @@
   TrayPopupUtils::UpdateCheckMarkVisibility(screen_magnifier_view_,
                                             screen_magnifier_enabled_);
 
+  if (features::IsDockedMagnifierEnabled()) {
   docked_magnifier_enabled_ =
       Shell::Get()->docked_magnifier_controller()->GetEnabled();
   TrayPopupUtils::UpdateCheckMarkVisibility(docked_magnifier_view_,
                                             docked_magnifier_enabled_);
+  }
 
   autoclick_enabled_ = controller->autoclick_enabled();
   TrayPopupUtils::UpdateCheckMarkVisibility(autoclick_view_,
@@ -171,6 +173,7 @@
           IDS_ASH_STATUS_TRAY_ACCESSIBILITY_SCREEN_MAGNIFIER),
       screen_magnifier_enabled_);
 
+  if (features::IsDockedMagnifierEnabled()) {
     docked_magnifier_enabled_ =
         Shell::Get()->docked_magnifier_controller()->GetEnabled();
     docked_magnifier_view_ = AddScrollListCheckableItem(
@@ -178,6 +181,7 @@
         l10n_util::GetStringUTF16(
             IDS_ASH_STATUS_TRAY_ACCESSIBILITY_DOCKED_MAGNIFIER),
         docked_magnifier_enabled_);
+  }
 
   autoclick_enabled_ = controller->autoclick_enabled();
   autoclick_view_ = AddScrollListCheckableItem(
@@ -271,7 +275,8 @@
                      ? UserMetricsAction("StatusArea_MagnifierDisabled")
                      : UserMetricsAction("StatusArea_MagnifierEnabled"));
     delegate->SetMagnifierEnabled(!delegate->IsMagnifierEnabled());
-  } else if (view == docked_magnifier_view_) {
+  } else if (features::IsDockedMagnifierEnabled() &&
+             view == docked_magnifier_view_) {
     auto* docked_magnifier_controller =
         Shell::Get()->docked_magnifier_controller();
     const bool new_state = !docked_magnifier_controller->GetEnabled();
--- a/ash/system/audio/display_speaker_controller.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/audio/display_speaker_controller.cc	2019-05-17 18:53:08.292000000 +0300
@@ -13,16 +13,17 @@
 #include "ui/display/screen.h"
 
 using chromeos::CrasAudioHandler;
+using chromeos::DBusThreadManager;
 
 namespace ash {
 
 DisplaySpeakerController::DisplaySpeakerController() {
   display::Screen::GetScreen()->AddObserver(this);
-  chromeos::PowerManagerClient::Get()->AddObserver(this);
+  DBusThreadManager::Get()->GetPowerManagerClient()->AddObserver(this);
 }
 
 DisplaySpeakerController::~DisplaySpeakerController() {
-  chromeos::PowerManagerClient::Get()->RemoveObserver(this);
+  DBusThreadManager::Get()->GetPowerManagerClient()->RemoveObserver(this);
   display::Screen::GetScreen()->RemoveObserver(this);
 }
 
--- a/ash/system/audio/unified_volume_view.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/audio/unified_volume_view.cc	2019-05-17 18:53:08.292000000 +0300
@@ -143,8 +143,7 @@
   // Indicate that the slider is inactive when it's muted.
   slider()->UpdateState(!is_muted);
 
-  // The button should be gray whay muted and colored otherwise.
-  button()->SetToggled(!is_muted);
+  button()->SetToggled(is_muted);
   button()->SetVectorIcon(is_muted ? kUnifiedMenuVolumeMuteIcon
                                    : GetVolumeIconForLevel(level));
 
--- a/ash/system/bluetooth/bluetooth_power_controller.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/bluetooth/bluetooth_power_controller.cc	2019-05-17 18:53:08.296000000 +0300
@@ -9,7 +9,6 @@
 #include "ash/public/cpp/ash_pref_names.h"
 #include "ash/session/session_controller.h"
 #include "ash/shell.h"
-#include "base/bind.h"
 #include "base/threading/thread_task_runner_handle.h"
 #include "components/device_event_log/device_event_log.h"
 #include "components/prefs/pref_registry_simple.h"
@@ -182,8 +181,7 @@
     // it has "initialized" signal in the future (http://crbug.com/765390).
     base::ThreadTaskRunnerHandle::Get()->PostDelayedTask(
         FROM_HERE,
-        base::BindOnce(
-            &BluetoothPowerController::TriggerRunPendingBluetoothTasks,
+        base::Bind(&BluetoothPowerController::TriggerRunPendingBluetoothTasks,
             weak_ptr_factory_.GetWeakPtr()),
         base::TimeDelta::FromMilliseconds(kBluetoothInitializationDelay));
   }
--- a/ash/system/bluetooth/bluetooth_power_controller_unittest.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/bluetooth/bluetooth_power_controller_unittest.cc	2019-05-17 18:53:08.296000000 +0300
@@ -10,7 +10,6 @@
 #include "ash/test/ash_test_base.h"
 #include "ash/test/ash_test_helper.h"
 #include "ash/test_shell_delegate.h"
-#include "base/bind_helpers.h"
 #include "base/run_loop.h"
 #include "components/prefs/pref_registry_simple.h"
 #include "components/prefs/testing_pref_service.h"
--- a/ash/system/bluetooth/tray_bluetooth_helper.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/bluetooth/tray_bluetooth_helper.cc	2019-05-17 18:53:08.296000000 +0300
@@ -3,7 +3,6 @@
 // found in the LICENSE file.
 
 #include "ash/system/bluetooth/tray_bluetooth_helper.h"
-#include "base/bind.h"
 #include "base/time/time.h"
 
 using device::mojom::BluetoothSystem;
--- a/ash/system/bluetooth/tray_bluetooth_helper_experimental.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/bluetooth/tray_bluetooth_helper_experimental.cc	2019-05-17 18:53:08.296000000 +0300
@@ -9,7 +9,6 @@
 
 #include "ash/shell.h"
 #include "ash/system/tray/system_tray_notifier.h"
-#include "base/bind.h"
 #include "base/bind_helpers.h"
 #include "services/device/public/mojom/constants.mojom.h"
 #include "services/service_manager/public/cpp/connector.h"
--- a/ash/system/bluetooth/tray_bluetooth_helper.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/bluetooth/tray_bluetooth_helper.h	2019-05-17 18:53:08.296000000 +0300
@@ -10,7 +10,6 @@
 
 #include "ash/ash_export.h"
 #include "base/macros.h"
-#include "base/timer/timer.h"
 #include "device/bluetooth/bluetooth_common.h"
 #include "services/device/public/mojom/bluetooth_system.mojom.h"
 
--- a/ash/system/bluetooth/tray_bluetooth_helper_legacy_unittest.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/bluetooth/tray_bluetooth_helper_legacy_unittest.cc	2019-05-17 18:53:08.296000000 +0300
@@ -9,7 +9,6 @@
 
 #include "ash/system/bluetooth/tray_bluetooth_helper.h"
 #include "ash/test/ash_test_base.h"
-#include "base/bind_helpers.h"
 #include "base/run_loop.h"
 #include "base/test/scoped_feature_list.h"
 #include "dbus/object_path.h"
--- a/ash/system/brightness/brightness_controller_chromeos.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/brightness/brightness_controller_chromeos.cc	2019-05-17 18:53:08.296000000 +0300
@@ -20,7 +20,9 @@
   if (accelerator.key_code() == ui::VKEY_BRIGHTNESS_DOWN)
     base::RecordAction(base::UserMetricsAction("Accel_BrightnessDown_F6"));
 
-  chromeos::PowerManagerClient::Get()->DecreaseScreenBrightness(true);
+  chromeos::DBusThreadManager::Get()
+      ->GetPowerManagerClient()
+      ->DecreaseScreenBrightness(true);
 }
 
 void BrightnessControllerChromeos::HandleBrightnessUp(
@@ -28,7 +30,9 @@
   if (accelerator.key_code() == ui::VKEY_BRIGHTNESS_UP)
     base::RecordAction(base::UserMetricsAction("Accel_BrightnessUp_F7"));
 
-  chromeos::PowerManagerClient::Get()->IncreaseScreenBrightness();
+  chromeos::DBusThreadManager::Get()
+      ->GetPowerManagerClient()
+      ->IncreaseScreenBrightness();
 }
 
 void BrightnessControllerChromeos::SetBrightnessPercent(double percent,
@@ -41,13 +45,16 @@
           : power_manager::SetBacklightBrightnessRequest_Transition_INSTANT);
   request.set_cause(
       power_manager::SetBacklightBrightnessRequest_Cause_USER_REQUEST);
-  chromeos::PowerManagerClient::Get()->SetScreenBrightness(request);
+  chromeos::DBusThreadManager::Get()
+      ->GetPowerManagerClient()
+      ->SetScreenBrightness(request);
 }
 
 void BrightnessControllerChromeos::GetBrightnessPercent(
     base::OnceCallback<void(base::Optional<double>)> callback) {
-  chromeos::PowerManagerClient::Get()->GetScreenBrightnessPercent(
-      std::move(callback));
+  chromeos::DBusThreadManager::Get()
+      ->GetPowerManagerClient()
+      ->GetScreenBrightnessPercent(std::move(callback));
 }
 
 }  // namespace system
--- a/ash/system/cast/cast_notification_controller.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/cast/cast_notification_controller.cc	2019-05-17 18:53:08.296000000 +0300
@@ -8,7 +8,6 @@
 #include "ash/resources/vector_icons/vector_icons.h"
 #include "ash/shell.h"
 #include "ash/strings/grit/ash_strings.h"
-#include "base/bind.h"
 #include "base/strings/utf_string_conversions.h"
 #include "ui/base/l10n/l10n_util.h"
 #include "ui/message_center/message_center.h"
--- a/ash/system/cast/tray_cast.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/cast/tray_cast.cc	2019-05-17 18:53:08.296000000 +0300
@@ -80,6 +80,16 @@
 
 CastDetailedView::~CastDetailedView() = default;
 
+void CastDetailedView::SimulateViewClickedForTest(
+    const std::string& receiver_id) {
+  for (const auto& it : view_to_sink_map_) {
+    if (it.second->id == receiver_id) {
+      HandleViewClicked(it.first);
+      break;
+    }
+  }
+}
+
 void CastDetailedView::CreateItems() {
   CreateScrollableList();
   CreateTitleRow(IDS_ASH_STATUS_TRAY_CAST);
--- a/ash/system/cast/tray_cast.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/cast/tray_cast.h	2019-05-17 18:53:08.296000000 +0300
@@ -25,6 +25,10 @@
                    const std::vector<mojom::SinkAndRoutePtr>& sinks_and_routes);
   ~CastDetailedView() override;
 
+  // Makes the detail view think the view associated with the given receiver_id
+  // was clicked. This will start a cast.
+  void SimulateViewClickedForTest(const std::string& receiver_id);
+
   // Updates the list of available receivers.
   void UpdateReceiverList(
       const std::vector<mojom::SinkAndRoutePtr>& sinks_routes);
--- a/ash/system/flag_warning/flag_warning_tray.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/flag_warning/flag_warning_tray.cc	2019-05-17 18:53:08.296000000 +0300
@@ -6,7 +6,7 @@
 
 #include <memory>
 
-#include "ash/components/shortcut_viewer/public/mojom/shortcut_viewer.mojom.h"
+#include "ash/components/quick_launch/public/mojom/constants.mojom.h"
 #include "ash/public/cpp/ash_typography.h"
 #include "ash/resources/vector_icons/vector_icons.h"
 #include "ash/shelf/shelf.h"
@@ -58,11 +58,11 @@
                                     const ui::Event& event) {
   DCHECK_EQ(button_, sender);
 
-  // Open the shortcut viewer mini-app to demonstrate that mini-apps work.
-  shortcut_viewer::mojom::ShortcutViewerPtr shortcut_viewer_ptr;
-  Shell::Get()->connector()->BindInterface(shortcut_viewer::mojom::kServiceName,
-                                           &shortcut_viewer_ptr);
-  shortcut_viewer_ptr->Toggle(base::TimeTicks::Now());
+  // Open the quick launch mojo mini-app to demonstrate that mini-apps work.
+  //
+  // TODO(https://crbug.com/904148): This should not use |WarmService()|.
+  Shell::Get()->connector()->WarmService(service_manager::ServiceFilter::ByName(
+      quick_launch::mojom::kServiceName));
 }
 
 void FlagWarningTray::GetAccessibleNodeData(ui::AXNodeData* node_data) {
--- a/ash/system/ime/ime_feature_pod_controller_unittest.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/ime/ime_feature_pod_controller_unittest.cc	2019-05-17 18:53:08.296000000 +0300
@@ -57,7 +57,7 @@
   void SetActiveIMECount(int count) {
     available_imes_.resize(count);
     for (int i = 0; i < count; ++i)
-      available_imes_[i].id = base::NumberToString(i);
+      available_imes_[i].id = base::IntToString(i);
     RefreshImeController();
   }
 
--- a/ash/system/ime_menu/ime_menu_tray.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/ime_menu/ime_menu_tray.cc	2019-05-17 18:53:08.300000000 +0300
@@ -126,10 +126,11 @@
 class ImeTitleView : public views::View, public views::ButtonListener {
  public:
   explicit ImeTitleView(bool show_settings_button) : settings_button_(nullptr) {
+    const int separator_width = TrayConstants::separator_width();
     SetBorder(views::CreatePaddedBorder(
-        views::CreateSolidSidedBorder(0, 0, kMenuSeparatorWidth, 0,
+        views::CreateSolidSidedBorder(0, 0, separator_width, 0,
                                       kMenuSeparatorColor),
-        gfx::Insets(kMenuSeparatorVerticalPadding - kMenuSeparatorWidth, 0)));
+        gfx::Insets(kMenuSeparatorVerticalPadding - separator_width, 0)));
     auto box_layout =
         std::make_unique<views::BoxLayout>(views::BoxLayout::kHorizontal);
     box_layout->set_minimum_cross_axis_size(kTrayPopupItemMinHeight);
@@ -221,12 +222,13 @@
   void Init(bool show_emoji, bool show_handwriting, bool show_voice) {
     auto box_layout =
         std::make_unique<views::BoxLayout>(views::BoxLayout::kHorizontal);
+    const int separator_width = TrayConstants::separator_width();
     box_layout->set_minimum_cross_axis_size(kTrayPopupItemMinHeight);
     SetLayoutManager(std::move(box_layout));
     SetBorder(views::CreatePaddedBorder(
-        views::CreateSolidSidedBorder(kMenuSeparatorWidth, 0, 0, 0,
+        views::CreateSolidSidedBorder(separator_width, 0, 0, 0,
                                       kMenuSeparatorColor),
-        gfx::Insets(kMenuSeparatorVerticalPadding - kMenuSeparatorWidth,
+        gfx::Insets(kMenuSeparatorVerticalPadding - separator_width,
                     kMenuExtraMarginFromLeftEdge)));
 
     const int right_border = 1;
@@ -393,9 +395,10 @@
 
 bool ImeMenuTray::ShouldShowBottomButtons() {
   // Emoji, handwriting and voice input is not supported for these cases:
-  // 1) third party IME extensions.
-  // 2) login/lock screen.
-  // 3) password input client.
+  // 1) features::kEHVInputOnImeMenu is not enabled.
+  // 2) third party IME extensions.
+  // 3) login/lock screen.
+  // 4) password input client.
 
   bool should_show_buttom_buttoms =
       ime_controller_->is_extra_input_options_enabled() &&
@@ -520,7 +523,7 @@
   if (chromeos::extension_ime_util::IsArcIME(current_ime.id)) {
     CreateImageView();
     image_view_->SetImage(
-        gfx::CreateVectorIcon(kShelfGlobeIcon, kTrayIconColor));
+        gfx::CreateVectorIcon(kShelfGlobeIcon, kTrayIconSize, kTrayIconColor));
     return;
   }
 
--- a/ash/system/keyboard_brightness/keyboard_brightness_controller.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/keyboard_brightness/keyboard_brightness_controller.cc	2019-05-17 18:53:08.300000000 +0300
@@ -23,7 +23,9 @@
   if (accelerator.key_code() == ui::VKEY_BRIGHTNESS_DOWN)
     RecordAction(UserMetricsAction("Accel_KeyboardBrightnessDown_F6"));
 
-  chromeos::PowerManagerClient::Get()->DecreaseKeyboardBrightness();
+  chromeos::DBusThreadManager::Get()
+      ->GetPowerManagerClient()
+      ->DecreaseKeyboardBrightness();
 }
 
 void KeyboardBrightnessController::HandleKeyboardBrightnessUp(
@@ -31,7 +33,9 @@
   if (accelerator.key_code() == ui::VKEY_BRIGHTNESS_UP)
     RecordAction(UserMetricsAction("Accel_KeyboardBrightnessUp_F7"));
 
-  chromeos::PowerManagerClient::Get()->IncreaseKeyboardBrightness();
+  chromeos::DBusThreadManager::Get()
+      ->GetPowerManagerClient()
+      ->IncreaseKeyboardBrightness();
 }
 
 }  // namespace ash
--- a/ash/system/message_center/arc/arc_notification_content_view.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/message_center/arc/arc_notification_content_view.cc	2019-05-17 18:53:08.300000000 +0300
@@ -743,7 +743,7 @@
 
   // Make the widget active.
   if (activate) {
-    GetWidget()->widget_delegate()->SetCanActivate(true);
+    GetWidget()->widget_delegate()->set_can_activate(true);
     GetWidget()->Activate();
 
     if (surface_)
@@ -751,7 +751,7 @@
     else
       activate_on_attach_ = true;
   } else {
-    GetWidget()->widget_delegate()->SetCanActivate(false);
+    GetWidget()->widget_delegate()->set_can_activate(false);
   }
 }
 
--- a/ash/system/message_center/arc/arc_notification_delegate.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/message_center/arc/arc_notification_delegate.cc	2019-05-17 18:53:08.300000000 +0300
@@ -23,7 +23,7 @@
 std::unique_ptr<message_center::MessageView>
 ArcNotificationDelegate::CreateCustomMessageView(
     const message_center::Notification& notification) {
-  CHECK(item_);
+  DCHECK(item_);
   DCHECK_EQ(item_->GetNotificationId(), notification.id());
   return std::make_unique<ArcNotificationView>(item_.get(), notification);
 }
--- a/ash/system/message_center/arc/arc_notification_manager.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/message_center/arc/arc_notification_manager.cc	2019-05-17 18:53:08.304000000 +0300
@@ -13,7 +13,6 @@
 #include "ash/system/message_center/arc/arc_notification_item_impl.h"
 #include "ash/system/message_center/arc/arc_notification_manager_delegate.h"
 #include "ash/system/message_center/arc/arc_notification_view.h"
-#include "base/bind.h"
 #include "base/command_line.h"
 #include "base/stl_util.h"
 #include "base/strings/utf_string_conversions.h"
--- a/ash/system/message_center/arc/arc_notification_view.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/message_center/arc/arc_notification_view.cc	2019-05-17 18:53:08.304000000 +0300
@@ -22,13 +22,13 @@
 #include "ui/views/controls/image_view.h"
 #include "ui/views/painter.h"
 
-DEFINE_UI_CLASS_PROPERTY_TYPE(ash::ArcNotificationView*)
+DEFINE_UI_CLASS_PROPERTY_TYPE(ash::ArcNotificationView*);
 
 namespace ash {
 
 DEFINE_UI_CLASS_PROPERTY_KEY(ArcNotificationView*,
                              kArcNotificationViewPropertyKey,
-                             nullptr)
+                             nullptr);
 
 // static
 ArcNotificationView* ArcNotificationView::FromView(views::View* view) {
--- a/ash/system/message_center/arc/arc_notification_view_unittest.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/message_center/arc/arc_notification_view_unittest.cc	2019-05-17 18:53:08.304000000 +0300
@@ -13,7 +13,6 @@
 #include "ash/system/message_center/arc/mock_arc_notification_item.h"
 #include "ash/system/message_center/arc/mock_arc_notification_surface.h"
 #include "ash/test/ash_test_base.h"
-#include "base/bind.h"
 #include "base/macros.h"
 #include "base/memory/ref_counted.h"
 #include "base/strings/utf_string_conversions.h"
--- a/ash/system/message_center/ash_message_center_lock_screen_controller.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/message_center/ash_message_center_lock_screen_controller.cc	2019-05-17 18:53:08.304000000 +0300
@@ -22,38 +22,22 @@
 
 namespace ash {
 
-// static private
-base::Optional<AshMessageCenterLockScreenController::Mode>
-    AshMessageCenterLockScreenController::overridden_mode_for_testing_;
-
 // static
 bool AshMessageCenterLockScreenController::IsEnabled() {
-  auto mode = GetMode();
-  bool is_showing = (mode == Mode::SHOW || mode == Mode::HIDE_SENSITIVE);
-  // If |isAllowed()| is false, must return false;
-  DCHECK(!is_showing || IsAllowed());
-  return is_showing;
+  return GetMode() != Mode::HIDE;
 }
 
 // static
-bool AshMessageCenterLockScreenController::IsAllowed() {
-  return GetMode() != Mode::PROHIBITED;
-}
-
-// static, private
 AshMessageCenterLockScreenController::Mode
 AshMessageCenterLockScreenController::GetMode() {
-  if (overridden_mode_for_testing_.has_value())
-    return *overridden_mode_for_testing_;
-
   if (!features::IsLockScreenNotificationsEnabled())
-    return Mode::PROHIBITED;
+    return Mode::HIDE;
 
   // User prefs may be null in some tests.
   PrefService* user_prefs =
       Shell::Get()->session_controller()->GetLastActiveUserPrefService();
   if (!user_prefs)
-    return Mode::PROHIBITED;
+    return Mode::HIDE;
 
   const std::string& mode =
       user_prefs->GetString(prefs::kMessageCenterLockScreenMode);
@@ -66,12 +50,6 @@
   return Mode::HIDE;
 }
 
-// static, only for testing
-void AshMessageCenterLockScreenController::OverrideModeForTest(
-    base::Optional<AshMessageCenterLockScreenController::Mode> new_mode) {
-  overridden_mode_for_testing_ = new_mode;
-}
-
 namespace {
 const char kToastId[] = "ash-lock-screen-manager";
 }  // anonymous namespace
@@ -87,8 +65,7 @@
 
 void AshMessageCenterLockScreenController::DismissLockScreenThenExecute(
     base::OnceClosure pending_callback,
-    base::OnceClosure cancel_callback,
-    int message_id) {
+    base::OnceClosure cancel_callback) {
   if (locked_) {
     // Invokes the previous cancel task if any.
     if (cancel_task_)
@@ -98,7 +75,7 @@
     pending_task_ = std::move(pending_callback);
     cancel_task_ = std::move(cancel_callback);
 
-    EncourageUserToUnlock(message_id);
+    EncourageUserToUnlock();
   } else {
     DCHECK(pending_task_.is_null());
     DCHECK(cancel_task_.is_null());
@@ -111,8 +88,7 @@
   return locked_;
 }
 
-void AshMessageCenterLockScreenController::EncourageUserToUnlock(
-    int message_id) {
+void AshMessageCenterLockScreenController::EncourageUserToUnlock() {
   DCHECK(locked_);
 
   DCHECK(LockScreen::Get());
@@ -126,23 +102,17 @@
     unified_system_tray->CloseBubble();
   }
 
-  base::string16 message;
-  if (message_id != -1) {
-    message = l10n_util::GetStringUTF16(message_id);
-  } else {
-    message =
+  // TODO(yoshiki): Update UI after the UX finalizes.
+  Shell::Get()->toast_manager()->Show(ToastData(
+      kToastId,
         (Shell::Get()->session_controller()->NumberOfLoggedInUsers() == 1 ||
          active_account_id_.empty())
             ? l10n_util::GetStringUTF16(
                   IDS_ASH_MESSAGE_CENTER_UNLOCK_TO_PERFORM_ACTION)
             : l10n_util::GetStringFUTF16(
                   IDS_ASH_MESSAGE_CENTER_UNLOCK_TO_PERFORM_ACTION_WITH_USER_ID,
-                  base::UTF8ToUTF16(active_account_id_.GetUserEmail()));
-  }
-
-  // TODO(yoshiki): Update UI after the UX finalizes.
-  Shell::Get()->toast_manager()->Show(
-      ToastData(kToastId, message, ToastData::kInfiniteDuration, base::nullopt,
+                base::UTF8ToUTF16(active_account_id_.GetUserEmail())),
+      ToastData::kInfiniteDuration, base::nullopt,
                 /*visible_on_lock_screen=*/true));
 }
 
--- a/ash/system/message_center/ash_message_center_lock_screen_controller.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/message_center/ash_message_center_lock_screen_controller.h	2019-05-17 18:53:08.304000000 +0300
@@ -7,7 +7,6 @@
 
 #include "ash/ash_export.h"
 #include "ash/session/session_observer.h"
-#include "base/optional.h"
 #include "components/account_id/account_id.h"
 #include "ui/message_center/lock_screen/lock_screen_controller.h"
 
@@ -18,52 +17,31 @@
     : public message_center::LockScreenController,
       public SessionObserver {
  public:
+  // Modes of the lock screen notification.
+  enum class Mode { HIDE, SHOW, HIDE_SENSITIVE };
+
   // Returns if the message center shows the notifications on the lock screen
   // or not. True if it shows, false if doesn't.
   static ASH_EXPORT bool IsEnabled();
 
-  // Returns if the message center on the lock screen is forcibly disabled,
-  // due to the policy or the corrupt state.
-  // When this returns true, |IsEnabled()| must return false.
-  static ASH_EXPORT bool IsAllowed();
+  // Returns the current mode of the lock screen notification.
+  static Mode GetMode();
 
   AshMessageCenterLockScreenController();
   ~AshMessageCenterLockScreenController() override;
 
   // message_center::LockScreenController:
   void DismissLockScreenThenExecute(base::OnceClosure pending_callback,
-                                    base::OnceClosure cancel_callback,
-                                    int message_id) override;
+                                    base::OnceClosure cancel_callback) override;
   bool IsScreenLocked() const override;
 
  private:
-  FRIEND_TEST_ALL_PREFIXES(UnifiedSystemTrayControllerTest,
-                           NotificationHiddenView_ModeShow);
-  FRIEND_TEST_ALL_PREFIXES(UnifiedSystemTrayControllerTest,
-                           NotificationHiddenView_ModeHide);
-  FRIEND_TEST_ALL_PREFIXES(UnifiedSystemTrayControllerTest,
-                           NotificationHiddenView_ModeHideSensitive);
-  FRIEND_TEST_ALL_PREFIXES(UnifiedSystemTrayControllerTest,
-                           NotificationHiddenView_ModeProhibited);
-
-  // Modes of the lock screen notification.
-  enum class Mode { PROHIBITED, HIDE, SHOW, HIDE_SENSITIVE };
-
-  // Returns the current mode of the lock screen notification.
-  static Mode GetMode();
-
-  // Override the current mode for tests.
-  // Exporting for test.
-  static ASH_EXPORT void OverrideModeForTest(base::Optional<Mode> new_mode);
-
-  static base::Optional<Mode> overridden_mode_for_testing_;
-
   // SessionObserver:
   void OnLockStateChanged(bool locked) override;
   void OnActiveUserSessionChanged(const AccountId& account_id) override;
 
   // Shows a message that asks a user to unlock the device.
-  void EncourageUserToUnlock(int message_id);
+  void EncourageUserToUnlock();
 
   bool locked_;
   AccountId active_account_id_ = EmptyAccountId();
--- a/ash/system/message_center/ash_popup_alignment_delegate.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/message_center/ash_popup_alignment_delegate.cc	2019-05-17 18:53:08.304000000 +0300
@@ -84,7 +84,8 @@
 }
 
 int AshPopupAlignmentDelegate::GetBaseline() const {
-  return work_area_.bottom() - kUnifiedMenuPadding - tray_bubble_height_;
+  return work_area_.bottom() - kUnifiedMenuVerticalPadding -
+         tray_bubble_height_;
 }
 
 gfx::Rect AshPopupAlignmentDelegate::GetWorkArea() const {
--- a/ash/system/message_center/message_center_controller.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/message_center/message_center_controller.cc	2019-05-17 18:53:08.304000000 +0300
@@ -127,7 +127,6 @@
   }
 
   message_center::RegisterVectorIcons({&kNotificationAssistantIcon,
-                                       &kAutoLaunchManagedGuestSessionIcon,
                                        &kNotificationCaptivePortalIcon,
                                        &kNotificationCellularAlertIcon,
                                        &kNotificationDownloadIcon,
--- a/ash/system/message_center/message_center_ui_delegate.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/message_center/message_center_ui_delegate.h	2019-05-17 18:53:08.304000000 +0300
@@ -12,7 +12,7 @@
 // Implementations are platform specific.
 class MessageCenterUiDelegate {
  public:
-  virtual ~MessageCenterUiDelegate() {}
+  virtual ~MessageCenterUiDelegate(){};
 
   // Called whenever a change to the visible UI has occurred.
   virtual void OnMessageCenterContentsChanged() = 0;
--- a/ash/system/message_center/unified_message_center_view.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/message_center/unified_message_center_view.cc	2019-05-17 18:53:08.308000000 +0300
@@ -4,9 +4,6 @@
 
 #include "ash/system/message_center/unified_message_center_view.h"
 
-#include <algorithm>
-#include <memory>
-
 #include "ash/public/cpp/ash_features.h"
 #include "ash/session/session_controller.h"
 #include "ash/shell.h"
@@ -15,7 +12,6 @@
 #include "ash/system/message_center/message_center_scroll_bar.h"
 #include "ash/system/message_center/unified_message_list_view.h"
 #include "ash/system/tray/tray_constants.h"
-#include "ash/system/tray/tray_popup_utils.h"
 #include "ash/system/unified/sign_out_button.h"
 #include "ash/system/unified/unified_system_tray_model.h"
 #include "ash/system/unified/unified_system_tray_view.h"
@@ -25,12 +21,6 @@
 #include "ui/message_center/message_center.h"
 #include "ui/message_center/public/cpp/message_center_constants.h"
 #include "ui/message_center/views/message_view.h"
-#include "ui/views/animation/flood_fill_ink_drop_ripple.h"
-#include "ui/views/animation/ink_drop_highlight.h"
-#include "ui/views/animation/ink_drop_impl.h"
-#include "ui/views/animation/ink_drop_mask.h"
-#include "ui/views/background.h"
-#include "ui/views/controls/button/label_button.h"
 #include "ui/views/controls/scroll_view.h"
 #include "ui/views/layout/box_layout.h"
 #include "ui/views/layout/fill_layout.h"
@@ -40,11 +30,6 @@
 
 namespace {
 
-enum ClearAllButtonTag {
-  kStackingBarClearAllButtonTag,
-  kBottomClearAllButtonTag,
-};
-
 constexpr int kClearAllButtonRowHeight = 3 * kUnifiedNotificationCenterSpacing;
 
 class ScrollerContentsView : public views::View {
@@ -70,7 +55,6 @@
                       IDS_ASH_MESSAGE_CENTER_CLEAR_ALL_BUTTON_LABEL));
     clear_all_button->SetTooltipText(l10n_util::GetStringUTF16(
         IDS_ASH_MESSAGE_CENTER_CLEAR_ALL_BUTTON_TOOLTIP));
-    clear_all_button->set_tag(kBottomClearAllButtonTag);
     button_container->AddChildView(clear_all_button);
     AddChildView(button_container);
   }
@@ -86,136 +70,25 @@
   DISALLOW_COPY_AND_ASSIGN(ScrollerContentsView);
 };
 
-// The "Clear all" button in the stacking notification bar.
-class StackingBarClearAllButton : public views::LabelButton {
- public:
-  StackingBarClearAllButton(views::ButtonListener* listener,
-                            const base::string16& text)
-      : views::LabelButton(listener, text) {
-    set_tag(kStackingBarClearAllButtonTag);
-    SetEnabledTextColors(kUnifiedMenuButtonColorActive);
-    SetHorizontalAlignment(gfx::ALIGN_CENTER);
-    SetBorder(views::CreateEmptyBorder(gfx::Insets()));
-    label()->SetSubpixelRenderingEnabled(false);
-    label()->SetFontList(views::Label::GetDefaultFontList().Derive(
-        1, gfx::Font::NORMAL, gfx::Font::Weight::MEDIUM));
-    TrayPopupUtils::ConfigureTrayPopupButton(this);
-  }
-
-  ~StackingBarClearAllButton() override = default;
-
-  // views::LabelButton:
-  gfx::Size CalculatePreferredSize() const override {
-    return gfx::Size(label()->GetPreferredSize().width() +
-                         kStackingNotificationClearAllButtonPadding.width(),
-                     label()->GetPreferredSize().height() +
-                         kStackingNotificationClearAllButtonPadding.height());
-  }
-
-  int GetHeightForWidth(int width) const override {
-    return label()->GetPreferredSize().height() +
-           kStackingNotificationClearAllButtonPadding.height();
-  }
-
-  void PaintButtonContents(gfx::Canvas* canvas) override {
-    views::LabelButton::PaintButtonContents(canvas);
-  }
-
-  std::unique_ptr<views::InkDrop> CreateInkDrop() override {
-    auto ink_drop = TrayPopupUtils::CreateInkDrop(this);
-    ink_drop->SetShowHighlightOnFocus(true);
-    ink_drop->SetShowHighlightOnHover(true);
-    return ink_drop;
-  }
-
-  std::unique_ptr<views::InkDropRipple> CreateInkDropRipple() const override {
-    return TrayPopupUtils::CreateInkDropRipple(
-        TrayPopupInkDropStyle::FILL_BOUNDS, this,
-        GetInkDropCenterBasedOnLastEvent(), SK_ColorBLACK);
-  }
-
-  std::unique_ptr<views::InkDropHighlight> CreateInkDropHighlight()
-      const override {
-    return TrayPopupUtils::CreateInkDropHighlight(
-        TrayPopupInkDropStyle::FILL_BOUNDS, this, SK_ColorBLACK);
-  }
-
-  std::unique_ptr<views::InkDropMask> CreateInkDropMask() const override {
-    SkScalar top_radius = SkIntToScalar(kUnifiedTrayCornerRadius);
-    SkScalar radii[8] = {0, 0, top_radius, top_radius, 0, 0, 0, 0};
-    SkPath path;
-    path.addRoundRect(gfx::RectToSkRect(GetContentsBounds()), radii);
-
-    return std::make_unique<views::PathInkDropMask>(size(), path);
-  }
-
- private:
-  DISALLOW_COPY_AND_ASSIGN(StackingBarClearAllButton);
-};
-
-int GetStackingNotificationCounterHeight() {
-  return features::IsNotificationStackingBarRedesignEnabled()
-             ? kStackingNotificationCounterWithClearAllHeight
-             : kStackingNotificationCounterHeight;
-}
-
 }  // namespace
 
-StackingNotificationCounterView::StackingNotificationCounterView(
-    views::ButtonListener* listener) {
-  if (!features::IsNotificationStackingBarRedesignEnabled())
-    return;
-
-  auto* layout = SetLayoutManager(std::make_unique<views::BoxLayout>(
-      views::BoxLayout::kHorizontal,
-      gfx::Insets(0, kStackingNotificationClearAllButtonPadding.left(), 0, 0),
-      0));
-  layout->set_cross_axis_alignment(
-      views::BoxLayout::CROSS_AXIS_ALIGNMENT_STRETCH);
-
-  count_label_ = new views::Label();
-  count_label_->SetEnabledColor(kStackingNotificationCounterLabelColor);
-  count_label_->SetFontList(views::Label::GetDefaultFontList().Derive(
-      1, gfx::Font::NORMAL, gfx::Font::Weight::MEDIUM));
-  AddChildView(count_label_);
-
-  views::View* spacer = new views::View;
-  AddChildView(spacer);
-  layout->SetFlexForView(spacer, 1);
-
-  clear_all_button_ = new StackingBarClearAllButton(
-      listener,
-      l10n_util::GetStringUTF16(IDS_ASH_MESSAGE_CENTER_CLEAR_ALL_BUTTON_LABEL));
-  clear_all_button_->SetTooltipText(l10n_util::GetStringUTF16(
-      IDS_ASH_MESSAGE_CENTER_CLEAR_ALL_BUTTON_TOOLTIP));
-  AddChildView(clear_all_button_);
+StackingNotificationCounterView::StackingNotificationCounterView() {
+  SetBorder(views::CreateSolidSidedBorder(
+      0, 0, 1, 0, kStackingNotificationCounterBorderColor));
 }
 
 StackingNotificationCounterView::~StackingNotificationCounterView() = default;
 
-void StackingNotificationCounterView::SetCount(int total_notification_count,
-                                               int stacked_notification_count) {
-  total_notification_count_ = total_notification_count;
-  stacked_notification_count_ = stacked_notification_count;
-
-  if (features::IsNotificationStackingBarRedesignEnabled()) {
-    SetVisible(total_notification_count_ > 1);
-    if (stacked_notification_count_ > 0) {
-      count_label_->SetText(l10n_util::GetStringFUTF16Int(
-          IDS_ASH_MESSAGE_CENTER_HIDDEN_NOTIFICATION_COUNT_LABEL,
-          stacked_notification_count_));
-      count_label_->SetVisible(true);
-    } else {
-      count_label_->SetVisible(false);
-    }
-  } else {
-    SetVisible(stacked_notification_count_ > 0);
-  }
-
+void StackingNotificationCounterView::SetCount(int stacking_count) {
+  stacking_count_ = std::min(stacking_count, kStackingNotificationCounterMax);
+  SetVisible(stacking_count > 0);
   SchedulePaint();
 }
 
 void StackingNotificationCounterView::OnPaint(gfx::Canvas* canvas) {
+  int x = kStackingNotificationCounterStartX;
+  const int y = kStackingNotificationCounterHeight / 2;
+
   cc::PaintFlags flags;
   flags.setColor(message_center::kNotificationBackgroundColor);
   flags.setStyle(cc::PaintFlags::kFill_Style);
@@ -225,27 +98,11 @@
   SkScalar top_radius = SkIntToScalar(kUnifiedTrayCornerRadius);
   SkScalar radii[8] = {top_radius, top_radius, top_radius, top_radius,
                        0,          0,          0,          0};
-
-  gfx::Rect bounds = GetLocalBounds();
-  background_path.addRoundRect(gfx::RectToSkRect(bounds), radii);
+  background_path.addRoundRect(gfx::RectToSkRect(GetLocalBounds()), radii);
   canvas->DrawPath(background_path, flags);
 
-  // We draw a border here than use a views::Border so the ink drop highlight
-  // of the clear all button overlays the border.
-  canvas->Draw1pxLine(gfx::PointF(bounds.bottom_left() - gfx::Vector2d(0, 1)),
-                      gfx::PointF(bounds.bottom_right() - gfx::Vector2d(0, 1)),
-                      kStackingNotificationCounterBorderColor);
-
-  if (features::IsNotificationStackingBarRedesignEnabled())
-    return;
-
-  // Draw the hidden notification dots for the the old UI.
-  int x = kStackingNotificationCounterStartX;
-  const int y = kStackingNotificationCounterHeight / 2;
-  int stacking_count =
-      std::min(stacked_notification_count_, kStackingNotificationCounterMax);
   flags.setColor(kStackingNotificationCounterColor);
-  for (int i = 0; i < stacking_count; ++i) {
+  for (int i = 0; i < stacking_count_; ++i) {
     canvas->DrawCircle(gfx::Point(x, y), kStackingNotificationCounterRadius,
                        flags);
     x += kStackingNotificationCounterDistanceX;
@@ -259,7 +116,7 @@
     UnifiedSystemTrayModel* model)
     : parent_(parent),
       model_(model),
-      stacking_counter_(new StackingNotificationCounterView(this)),
+      stacking_counter_(new StackingNotificationCounterView()),
       scroll_bar_(new MessageCenterScrollBar(this)),
       scroller_(new views::ScrollView()),
       message_list_view_(new UnifiedMessageListView(this, model)),
@@ -293,6 +150,7 @@
 void UnifiedMessageCenterView::ListPreferredSizeChanged() {
   UpdateVisibility();
   PreferredSizeChanged();
+  ScrollToTarget();
   Layout();
 
   if (GetWidget() && !GetWidget()->IsClosed())
@@ -318,23 +176,22 @@
 }
 
 void UnifiedMessageCenterView::Layout() {
-  stacking_counter_->SetCount(message_list_view_->GetTotalNotificationCount(),
-                              GetStackedNotificationCount());
+  stacking_counter_->SetCount(GetStackedNotificationCount());
   if (stacking_counter_->visible()) {
     gfx::Rect counter_bounds(GetContentsBounds());
-    counter_bounds.set_height(GetStackingNotificationCounterHeight());
+    counter_bounds.set_height(kStackingNotificationCounterHeight);
     stacking_counter_->SetBoundsRect(counter_bounds);
 
     gfx::Rect scroller_bounds(GetContentsBounds());
     scroller_bounds.Inset(
-        gfx::Insets(GetStackingNotificationCounterHeight(), 0, 0, 0));
+        gfx::Insets(kStackingNotificationCounterHeight, 0, 0, 0));
     scroller_->SetBoundsRect(scroller_bounds);
   } else {
     scroller_->SetBoundsRect(GetContentsBounds());
   }
 
   ScrollToTarget();
-  NotifyRectBelowScroll();
+  NotifyHeightBelowScroll();
 }
 
 gfx::Size UnifiedMessageCenterView::CalculatePreferredSize() const {
@@ -353,8 +210,7 @@
       UnifiedSystemTrayModel::NotificationTargetMode::LAST_POSITION);
 
   const bool was_visible = stacking_counter_->visible();
-  stacking_counter_->SetCount(message_list_view_->GetTotalNotificationCount(),
-                              GetStackedNotificationCount());
+  stacking_counter_->SetCount(GetStackedNotificationCount());
   if (was_visible != stacking_counter_->visible()) {
     const int previous_y = scroller_->y();
     Layout();
@@ -363,24 +219,13 @@
     scroll_bar_->ScrollByContentsOffset(previous_y - scroller_->y());
   }
 
-  NotifyRectBelowScroll();
+  NotifyHeightBelowScroll();
 }
 
 void UnifiedMessageCenterView::ButtonPressed(views::Button* sender,
                                              const ui::Event& event) {
-  if (sender) {
-    switch (sender->tag()) {
-      case kStackingBarClearAllButtonTag:
-        base::RecordAction(base::UserMetricsAction(
-            "StatusArea_Notifications_StackingBarClearAll"));
-        break;
-      case kBottomClearAllButtonTag:
         base::RecordAction(
             base::UserMetricsAction("StatusArea_Notifications_ClearAll"));
-        break;
-    }
-  }
-
   message_list_view_->ClearAllWithAnimation();
 }
 
@@ -389,15 +234,12 @@
 
 void UnifiedMessageCenterView::OnDidChangeFocus(views::View* before,
                                                 views::View* now) {
-  if (message_list_view_->is_deleting_removed_notifications())
-    return;
-
   OnMessageCenterScrolled();
 }
 
-void UnifiedMessageCenterView::SetNotificationRectBelowScroll(
-    const gfx::Rect& rect_below_scroll) {
-  parent_->SetNotificationRectBelowScroll(rect_below_scroll);
+void UnifiedMessageCenterView::SetNotificationHeightBelowScroll(
+    int height_below_scroll) {
+  parent_->SetNotificationHeightBelowScroll(height_below_scroll);
 }
 
 void UnifiedMessageCenterView::UpdateVisibility() {
@@ -467,29 +309,17 @@
   if (scroller_->bounds().IsEmpty())
     scroller_->SetBoundsRect(GetContentsBounds());
 
-  // Consistently use the y offset below the stacked notification bar in the
-  // UnifiedMessageCenterView to count number of hidden notifications.
+  // Consistently use the y offset absolutely kStackingNotificationCounterHeight
+  // below the top of UnifiedMessageCenterView to count number of hidden
+  // notifications.
   const int y_offset = scroller_->GetVisibleRect().y() - scroller_->y() +
-                       GetStackingNotificationCounterHeight();
+                       kStackingNotificationCounterHeight;
   return message_list_view_->CountNotificationsAboveY(y_offset);
 }
 
-void UnifiedMessageCenterView::NotifyRectBelowScroll() {
-  if (!visible())
-    return;
-
-  gfx::Rect rect_below_scroll;
-  rect_below_scroll.set_height(
-      std::max(0, message_list_view_->GetLastNotificationBounds().bottom() -
-                      scroller_->GetVisibleRect().bottom()));
-
-  gfx::Rect notification_bounds =
-      message_list_view_->GetNotificationBoundsBelowY(
-          scroller_->GetVisibleRect().bottom());
-  rect_below_scroll.set_x(notification_bounds.x());
-  rect_below_scroll.set_width(notification_bounds.width());
-
-  SetNotificationRectBelowScroll(rect_below_scroll);
+void UnifiedMessageCenterView::NotifyHeightBelowScroll() {
+  SetNotificationHeightBelowScroll(std::max(
+      0, message_list_view_->height() - scroller_->GetVisibleRect().bottom()));
 }
 
 }  // namespace ash
--- a/ash/system/message_center/unified_message_center_view.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/message_center/unified_message_center_view.h	2019-05-17 18:53:08.308000000 +0300
@@ -8,9 +8,7 @@
 #include "ash/ash_export.h"
 #include "ash/system/message_center/message_center_scroll_bar.h"
 #include "ash/system/message_center/unified_message_list_view.h"
-#include "ui/views/background.h"
 #include "ui/views/controls/button/button.h"
-#include "ui/views/controls/label.h"
 #include "ui/views/focus/focus_manager.h"
 #include "ui/views/view.h"
 
@@ -24,29 +22,18 @@
 class UnifiedSystemTrayModel;
 class UnifiedSystemTrayView;
 
-// The header shown above the notification list displaying the number of hidden
-// notifications. There are currently two UI implementations toggled by the
-// NotificationStackingBarRedesign feature flag.
 class StackingNotificationCounterView : public views::View {
  public:
-  explicit StackingNotificationCounterView(views::ButtonListener* listener);
+  StackingNotificationCounterView();
   ~StackingNotificationCounterView() override;
 
-  void SetCount(int total_notification_count, int stacked_notification_count);
+  void SetCount(int stacking_count);
 
   // views::View:
   void OnPaint(gfx::Canvas* canvas) override;
 
  private:
-  friend class UnifiedMessageCenterViewTest;
-
-  int total_notification_count_ = 0;
-  int stacked_notification_count_ = 0;
-
-  // These UI elements are only created and shown when the
-  // NotificationStackingBarRedesign feature is enabled.
-  views::Label* count_label_ = nullptr;
-  views::Button* clear_all_button_ = nullptr;
+  int stacking_count_ = 0;
 
   DISALLOW_COPY_AND_ASSIGN(StackingNotificationCounterView);
 };
@@ -93,8 +80,7 @@
 
  protected:
   // Virtual for testing.
-  virtual void SetNotificationRectBelowScroll(
-      const gfx::Rect& rect_below_scroll);
+  virtual void SetNotificationHeightBelowScroll(int height_below_scroll);
 
  private:
   friend class UnifiedMessageCenterViewTest;
@@ -104,9 +90,9 @@
   // Scroll the notification list to the target position.
   void ScrollToTarget();
 
-  // Notifies rect below scroll to |parent_| so that it can update
+  // Notifies height below scroll to |parent_| so that it can update
   // TopCornerBorder.
-  void NotifyRectBelowScroll();
+  void NotifyHeightBelowScroll();
 
   UnifiedSystemTrayView* const parent_;
   UnifiedSystemTrayModel* const model_;
--- a/ash/system/message_center/unified_message_center_view_unittest.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/message_center/unified_message_center_view_unittest.cc	2019-05-17 18:53:08.308000000 +0300
@@ -21,7 +21,6 @@
 #include "ui/message_center/message_center.h"
 #include "ui/message_center/views/message_view.h"
 #include "ui/views/controls/scroll_view.h"
-#include "ui/views/widget/widget.h"
 
 using message_center::MessageCenter;
 using message_center::MessageView;
@@ -31,7 +30,6 @@
 
 namespace {
 
-constexpr int kDefaultTrayMenuWidth = 360;
 constexpr int kDefaultMaxHeight = 500;
 
 class DummyEvent : public ui::Event {
@@ -47,15 +45,14 @@
 
   ~TestUnifiedMessageCenterView() override = default;
 
-  void SetNotificationRectBelowScroll(
-      const gfx::Rect& rect_below_scroll) override {
-    rect_below_scroll_ = rect_below_scroll;
+  void SetNotificationHeightBelowScroll(int height_below_scroll) override {
+    height_below_scroll_ = height_below_scroll;
   }
 
-  const gfx::Rect& rect_below_scroll() const { return rect_below_scroll_; }
+  int height_below_scroll() const { return height_below_scroll_; }
 
  private:
-  gfx::Rect rect_below_scroll_;
+  int height_below_scroll_ = -1;
 
   DISALLOW_COPY_AND_ASSIGN(TestUnifiedMessageCenterView);
 };
@@ -92,7 +89,7 @@
 
  protected:
   std::string AddNotification() {
-    std::string id = base::NumberToString(id_++);
+    std::string id = base::IntToString(id_++);
     MessageCenter::Get()->AddNotification(std::make_unique<Notification>(
         message_center::NOTIFICATION_TYPE_BASE_FORMAT, id,
         base::UTF8ToUTF16("test title"), base::UTF8ToUTF16("test message"),
@@ -107,7 +104,6 @@
         std::make_unique<TestUnifiedMessageCenterView>(model_.get());
     message_center_view_->AddObserver(this);
     message_center_view_->SetMaxHeight(max_height);
-    message_center_view_->set_owned_by_client();
     OnViewPreferredSizeChanged(message_center_view_.get());
     size_changed_count_ = 0;
   }
@@ -150,40 +146,6 @@
     return message_center_view()->stacking_counter_;
   }
 
-  views::View* GetStackingCounterLabel() {
-    return message_center_view()->stacking_counter_->count_label_;
-  }
-
-  views::View* GetStackingCounterClearAllButton() {
-    return message_center_view()->stacking_counter_->clear_all_button_;
-  }
-
-  message_center::MessageView* ToggleFocusToMessageView(int index,
-                                                        bool reverse) {
-    auto* focus_manager = message_center_view()->GetFocusManager();
-    if (!focus_manager)
-      return nullptr;
-
-    message_center::MessageView* focused_message_view = nullptr;
-    const int max_focus_toggles = 5 * GetMessageListView()->child_count();
-    for (int i = 0; i < max_focus_toggles; ++i) {
-      focus_manager->AdvanceFocus(reverse);
-      auto* focused_view = focus_manager->GetFocusedView();
-      // The MessageView is wrapped in container view in the MessageList.
-      if (focused_view->parent() == GetMessageListView()->child_at(index)) {
-        focused_message_view =
-            static_cast<message_center::MessageView*>(focused_view);
-        break;
-      }
-    }
-    return focused_message_view;
-  }
-
-  void EnableNotificationStackingBarRedesign() {
-    scoped_feature_list_.InitAndEnableFeature(
-        features::kNotificationStackingBarRedesign);
-  }
-
   TestUnifiedMessageCenterView* message_center_view() {
     return message_center_view_.get();
   }
@@ -193,7 +155,6 @@
   UnifiedSystemTrayModel* model() { return model_.get(); }
 
  private:
-  base::test::ScopedFeatureList scoped_feature_list_;
   int id_ = 0;
   int size_changed_count_ = 0;
 
@@ -433,11 +394,8 @@
   message_center_view()->OnMessageCenterScrolled();
 
   EXPECT_TRUE(GetStackingCounter()->visible());
-  // The offset change matches with the scroll amount plus the stacking bar
-  // height.
-  EXPECT_EQ(
-      previous_bounds -
-          gfx::Vector2d(0, scroll_amount + kStackingNotificationCounterHeight),
+  // The offset change matches with the scroll amount.
+  EXPECT_EQ(previous_bounds - gfx::Vector2d(0, scroll_amount),
       GetMessageViewVisibleBounds(2));
 
   GetScroller()->ScrollToPosition(GetScrollBar(), scroll_amount - 1);
@@ -464,109 +422,7 @@
   EXPECT_FALSE(GetStackingCounter()->visible());
 }
 
-TEST_F(UnifiedMessageCenterViewTest, RedesignedStackingCounterLayout) {
-  EnableNotificationStackingBarRedesign();
-
-  for (size_t i = 0; i < 6; ++i)
-    AddNotification();
-
-  // MessageCenterView is maxed out.
-  CreateMessageCenterView();
-  EXPECT_TRUE(message_center_view()->visible());
-
-  EXPECT_GT(GetMessageListView()->bounds().height(),
-            message_center_view()->bounds().height());
-
-  EXPECT_TRUE(GetStackingCounter()->visible());
-  EXPECT_EQ(0, GetStackingCounter()->bounds().y());
-  EXPECT_EQ(GetStackingCounter()->bounds().bottom(),
-            GetScroller()->bounds().y());
-  EXPECT_TRUE(GetStackingCounterLabel()->visible());
-  EXPECT_TRUE(GetStackingCounterClearAllButton()->visible());
-
-  // Scroll to the top, making the counter label invisible.
-  GetScroller()->ScrollToPosition(GetScrollBar(), 0);
-  message_center_view()->OnMessageCenterScrolled();
-  EXPECT_TRUE(GetStackingCounter()->visible());
-  EXPECT_FALSE(GetStackingCounterLabel()->visible());
-  EXPECT_TRUE(GetStackingCounterClearAllButton()->visible());
-}
-
-TEST_F(UnifiedMessageCenterViewTest,
-       RedesignedStackingCounterMessageListScrolled) {
-  EnableNotificationStackingBarRedesign();
-
-  for (size_t i = 0; i < 6; ++i)
-    AddNotification();
-  CreateMessageCenterView();
-  EXPECT_TRUE(message_center_view()->visible());
-  EXPECT_TRUE(GetStackingCounterLabel()->visible());
-  EXPECT_TRUE(GetStackingCounterClearAllButton()->visible());
-
-  // MessageCenterView is maxed out.
-  EXPECT_GT(GetMessageListView()->bounds().height(),
-            message_center_view()->bounds().height());
-
-  // Scroll to the top, making the counter label invisible.
-  GetScroller()->ScrollToPosition(GetScrollBar(), 0);
-  message_center_view()->OnMessageCenterScrolled();
-  EXPECT_TRUE(GetStackingCounter()->visible());
-  EXPECT_FALSE(GetStackingCounterLabel()->visible());
-  EXPECT_TRUE(GetStackingCounterClearAllButton()->visible());
-
-  gfx::Rect previous_bounds = GetMessageViewVisibleBounds(2);
-
-  // Scrolling past a notification should make the counter label visible.
-  const int scroll_amount = GetMessageViewVisibleBounds(0).height() + 1;
-  GetScroller()->ScrollToPosition(GetScrollBar(), scroll_amount);
-  message_center_view()->OnMessageCenterScrolled();
-
-  EXPECT_TRUE(GetStackingCounterLabel()->visible());
-  // The offset change matches with the scroll amount.
-  EXPECT_EQ(previous_bounds - gfx::Vector2d(0, scroll_amount),
-            GetMessageViewVisibleBounds(2));
-
-  // Scrolling back a tiny bit to reveal the notification should make the
-  // counter label invisible again.
-  GetScroller()->ScrollToPosition(GetScrollBar(), scroll_amount - 2);
-  message_center_view()->OnMessageCenterScrolled();
-  EXPECT_TRUE(GetStackingCounter()->visible());
-  EXPECT_FALSE(GetStackingCounterLabel()->visible());
-  EXPECT_TRUE(GetStackingCounterClearAllButton()->visible());
-}
-
-TEST_F(UnifiedMessageCenterViewTest,
-       RedesignedStackingCounterNotificationRemoval) {
-  EnableNotificationStackingBarRedesign();
-
-  std::vector<std::string> ids;
-  for (size_t i = 0; i < 6; ++i)
-    ids.push_back(AddNotification());
-  CreateMessageCenterView();
-  EXPECT_TRUE(message_center_view()->visible());
-
-  // MessageCenterView is maxed out.
-  EXPECT_GT(GetMessageListView()->bounds().height(),
-            message_center_view()->bounds().height());
-
-  // Dismiss until there are 2 notifications. The bar should still be visible.
-  EXPECT_TRUE(GetStackingCounter()->visible());
-  for (size_t i = 0; i < 4; ++i) {
-    MessageCenter::Get()->RemoveNotification(ids[i], true /* by_user */);
-    AnimateUntilIdle();
-  }
-  EXPECT_TRUE(GetStackingCounter()->visible());
-  EXPECT_FALSE(GetStackingCounterLabel()->visible());
-  EXPECT_TRUE(GetStackingCounterClearAllButton()->visible());
-
-  // Dismiss until there is only 1 notification left. The bar should be
-  // invisible.
-  MessageCenter::Get()->RemoveNotification(ids[4], true /* by_user */);
-  AnimateUntilIdle();
-  EXPECT_FALSE(GetStackingCounter()->visible());
-}
-
-TEST_F(UnifiedMessageCenterViewTest, RectBelowScroll) {
+TEST_F(UnifiedMessageCenterViewTest, HeightBelowScroll) {
   for (size_t i = 0; i < 6; ++i)
     AddNotification();
   CreateMessageCenterView();
@@ -577,15 +433,15 @@
             message_center_view()->bounds().height());
   message_center_view()->OnMessageCenterScrolled();
 
-  EXPECT_EQ(0, message_center_view()->rect_below_scroll().height());
+  EXPECT_EQ(0, message_center_view()->height_below_scroll());
 
   GetScroller()->ScrollToPosition(GetScrollBar(), 0);
   message_center_view()->OnMessageCenterScrolled();
-  EXPECT_LT(0, message_center_view()->rect_below_scroll().height());
+  EXPECT_LT(0, message_center_view()->height_below_scroll());
 }
 
 TEST_F(UnifiedMessageCenterViewTest,
-       RectBelowScrollWithTargetingFirstNotification) {
+       HeightBelowScrollWithTargetingFirstNotification) {
   std::vector<std::string> ids;
   for (size_t i = 0; i < 10; ++i)
     ids.push_back(AddNotification());
@@ -602,10 +458,11 @@
   EXPECT_EQ(0, GetScroller()->GetVisibleRect().y());
   EXPECT_EQ(
       GetMessageListView()->height() - GetScroller()->GetVisibleRect().height(),
-      message_center_view()->rect_below_scroll().height());
+      message_center_view()->height_below_scroll());
 }
 
-TEST_F(UnifiedMessageCenterViewTest, RectBelowScrollWithTargetingNotification) {
+TEST_F(UnifiedMessageCenterViewTest,
+       HeightBelowScrollWithTargetingNotification) {
   std::vector<std::string> ids;
   for (size_t i = 0; i < 10; ++i)
     ids.push_back(AddNotification());
@@ -620,11 +477,11 @@
   message_center_view()->OnMessageCenterScrolled();
 
   EXPECT_EQ(GetMessageListView()->GetLastNotificationBounds().height(),
-            message_center_view()->rect_below_scroll().height());
+            message_center_view()->height_below_scroll());
 }
 
 TEST_F(UnifiedMessageCenterViewTest,
-       RectBelowScrollWithTargetingLastNotification) {
+       HeightBelowScrollWithTargetingLastNotification) {
   std::vector<std::string> ids;
   for (size_t i = 0; i < 10; ++i)
     ids.push_back(AddNotification());
@@ -638,11 +495,11 @@
             message_center_view()->bounds().height());
   message_center_view()->OnMessageCenterScrolled();
 
-  EXPECT_EQ(0, message_center_view()->rect_below_scroll().height());
+  EXPECT_EQ(0, message_center_view()->height_below_scroll());
 }
 
 TEST_F(UnifiedMessageCenterViewTest,
-       RectBelowScrollWithTargetingInvalidNotification) {
+       HeightBelowScrollWithTargetingInvalidNotification) {
   std::vector<std::string> ids;
   for (size_t i = 0; i < 10; ++i)
     ids.push_back(AddNotification());
@@ -656,67 +513,7 @@
             message_center_view()->bounds().height());
   message_center_view()->OnMessageCenterScrolled();
 
-  EXPECT_EQ(0, message_center_view()->rect_below_scroll().height());
-}
-
-TEST_F(UnifiedMessageCenterViewTest, FocusClearedAfterNotificationRemoval) {
-  CreateMessageCenterView();
-
-  // We need to create a widget in order to initialize a FocusManager.
-  auto widget = CreateTestWidget();
-  widget->GetRootView()->AddChildView(message_center_view());
-  widget->Show();
-
-  // Add notifications and focus on a child view in the last notification.
-  AddNotification();
-  auto id1 = AddNotification();
-
-  // Toggle focus to the last notification MessageView.
-  auto* focused_message_view =
-      ToggleFocusToMessageView(1 /* index */, true /* reverse */);
-  ASSERT_TRUE(focused_message_view);
-  EXPECT_EQ(id1, focused_message_view->notification_id());
-
-  // Remove the notification and observe that the focus is cleared.
-  MessageCenter::Get()->RemoveNotification(id1, true /* by_user */);
-  AnimateUntilIdle();
-  EXPECT_FALSE(message_center_view()->GetFocusManager()->GetFocusedView());
-
-  widget->GetRootView()->RemoveChildView(message_center_view());
-}
-
-TEST_F(UnifiedMessageCenterViewTest, FocusChangeUpdatesStackingBar) {
-  CreateMessageCenterView();
-
-  // We need to create a widget in order to initialize a FocusManager.
-  auto widget = CreateTestWidget();
-  widget->GetRootView()->AddChildView(message_center_view());
-  widget->SetSize(gfx::Size(kDefaultTrayMenuWidth, kDefaultMaxHeight));
-  widget->Show();
-
-  // Add notifications such that the stacking counter is shown.
-  std::string first_notification_id = AddNotification();
-  for (int i = 0; i < 6; ++i)
-    AddNotification();
-  std::string last_notification_id = AddNotification();
-
-  // The ListView should be taller than the MessageCenterView so we can scroll
-  // and show the stacking counter.
-  EXPECT_GT(GetMessageListView()->bounds().height(),
-            message_center_view()->bounds().height());
-  EXPECT_TRUE(GetStackingCounter()->visible());
-
-  // Advancing focus causes list to scroll to the top, which hides the counter.
-  auto* message_view =
-      ToggleFocusToMessageView(0 /* index */, false /* reverse */);
-  EXPECT_EQ(first_notification_id, message_view->notification_id());
-  EXPECT_FALSE(GetStackingCounter()->visible());
-
-  // Reversing the focus more scrolls the list to the bottom, reshowing the
-  // counter.
-  message_view = ToggleFocusToMessageView(7 /* index */, false /* reverse */);
-  EXPECT_EQ(last_notification_id, message_view->notification_id());
-  EXPECT_TRUE(GetStackingCounter()->visible());
+  EXPECT_EQ(0, message_center_view()->height_below_scroll());
 }
 
 }  // namespace ash
--- a/ash/system/message_center/unified_message_list_view.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/message_center/unified_message_list_view.cc	2019-05-17 18:53:08.308000000 +0300
@@ -4,7 +4,6 @@
 
 #include "ash/system/message_center/unified_message_list_view.h"
 
-#include "ash/public/cpp/ash_features.h"
 #include "ash/system/message_center/notification_swipe_control_view.h"
 #include "ash/system/message_center/unified_message_center_view.h"
 #include "ash/system/tray/tray_constants.h"
@@ -213,16 +212,12 @@
 
 int UnifiedMessageListView::CountNotificationsAboveY(int y_offset) const {
   for (int i = 0; i < child_count(); ++i) {
-    if (child_at(i)->bounds().bottom() > y_offset)
+    if (child_at(i)->bounds().bottom() >= y_offset)
       return i;
   }
   return child_count();
 }
 
-int UnifiedMessageListView::GetTotalNotificationCount() const {
-  return child_count();
-}
-
 void UnifiedMessageListView::ChildPreferredSizeChanged(views::View* child) {
   if (ignore_size_change_)
     return;
@@ -263,16 +258,6 @@
   return GetContainer(child_count() - 1)->bounds();
 }
 
-gfx::Rect UnifiedMessageListView::GetNotificationBoundsBelowY(
-    int y_offset) const {
-  for (int i = 0; i < child_count(); ++i) {
-    auto* view = GetContainer(i);
-    if (view->bounds().bottom() >= y_offset)
-      return view->bounds();
-  }
-  return gfx::Rect();
-}
-
 gfx::Size UnifiedMessageListView::CalculatePreferredSize() const {
   return gfx::Size(kTrayMenuWidth,
                    gfx::Tween::IntValueBetween(GetCurrentValue(), start_height_,
@@ -422,12 +407,7 @@
 
 void UnifiedMessageListView::UpdateBorders() {
   for (int i = 0; i < child_count(); ++i) {
-    bool is_top = i == 0;
-    // When the stacking bar is shown, there should never be a top notification.
-    if (features::IsNotificationStackingBarRedesignEnabled() &&
-        GetTotalNotificationCount() > 1) {
-      is_top = false;
-    }
+    const bool is_top = i == 0;
     const bool is_bottom = i == child_count() - 1;
     GetContainer(i)->UpdateBorder(is_top, is_bottom);
   }
@@ -483,13 +463,10 @@
       removed_views.push_back(view);
   }
 
-  {
-    base::AutoReset<bool> auto_reset(&is_deleting_removed_notifications_, true);
     for (auto* view : removed_views) {
       model_->RemoveNotificationExpanded(view->GetNotificationId());
       delete view;
     }
-  }
 
   UpdateBorders();
 }
--- a/ash/system/message_center/unified_message_list_view.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/message_center/unified_message_list_view.h	2019-05-17 18:53:08.308000000 +0300
@@ -54,17 +54,10 @@
   // return an empty rect.
   gfx::Rect GetLastNotificationBounds() const;
 
-  // Return the bounds of the first notification whose bottom is below
-  // |y_offset|.
-  gfx::Rect GetNotificationBoundsBelowY(int y_offset) const;
-
   // Count the number of notifications whose bottom position is above
   // |y_offset|. O(n) where n is number of notifications.
   int CountNotificationsAboveY(int y_offset) const;
 
-  // Returns the total number of notifications in the list.
-  int GetTotalNotificationCount() const;
-
   // views::View:
   void ChildPreferredSizeChanged(views::View* child) override;
   void PreferredSizeChanged() override;
@@ -84,10 +77,6 @@
   void AnimationProgressed(const gfx::Animation* animation) override;
   void AnimationCanceled(const gfx::Animation* animation) override;
 
-  bool is_deleting_removed_notifications() const {
-    return is_deleting_removed_notifications_;
-  }
-
  protected:
   // Virtual for testing.
   virtual message_center::MessageView* CreateMessageView(
@@ -187,11 +176,6 @@
   // as height().
   int ideal_height_ = 0;
 
-  // True if the UnifiedMessageListView is currently deleting notifications
-  // marked for removal. This check is needed to prevent re-entrancing issues
-  // (e.g. crbug.com/933327) caused by the View destructor.
-  bool is_deleting_removed_notifications_ = false;
-
   DISALLOW_COPY_AND_ASSIGN(UnifiedMessageListView);
 };
 
--- a/ash/system/message_center/unified_message_list_view_unittest.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/message_center/unified_message_list_view_unittest.cc	2019-05-17 18:53:08.308000000 +0300
@@ -103,7 +103,7 @@
 
  protected:
   std::string AddNotification(bool pinned = false) {
-    std::string id = base::NumberToString(id_++);
+    std::string id = base::IntToString(id_++);
     auto notification = std::make_unique<Notification>(
         message_center::NOTIFICATION_TYPE_BASE_FORMAT, id,
         base::UTF8ToUTF16("test title"), base::UTF8ToUTF16("test message"),
--- a/ash/system/model/clock_model.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/model/clock_model.cc	2019-05-17 18:53:08.308000000 +0300
@@ -8,22 +8,20 @@
 #include "ash/shell.h"
 #include "ash/system/model/clock_observer.h"
 #include "ash/system/model/system_tray_model.h"
+#include "chromeos/dbus/dbus_thread_manager.h"
 
 namespace ash {
 
 ClockModel::ClockModel() : hour_clock_type_(base::GetHourClockType()) {
-  // SystemClockClient may be null in tests.
-  if (chromeos::SystemClockClient::Get()) {
-    chromeos::SystemClockClient::Get()->AddObserver(this);
-    can_set_time_ = chromeos::SystemClockClient::Get()->CanSetTime();
-  }
+  chromeos::DBusThreadManager::Get()->GetSystemClockClient()->AddObserver(this);
   chromeos::system::TimezoneSettings::GetInstance()->AddObserver(this);
+  can_set_time_ =
+      chromeos::DBusThreadManager::Get()->GetSystemClockClient()->CanSetTime();
 }
 
 ClockModel::~ClockModel() {
-  // SystemClockClient may be null in tests.
-  if (chromeos::SystemClockClient::Get())
-    chromeos::SystemClockClient::Get()->RemoveObserver(this);
+  chromeos::DBusThreadManager::Get()->GetSystemClockClient()->RemoveObserver(
+      this);
   chromeos::system::TimezoneSettings::GetInstance()->RemoveObserver(this);
 }
 
--- a/ash/system/model/clock_model.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/model/clock_model.h	2019-05-17 18:53:08.308000000 +0300
@@ -8,7 +8,7 @@
 #include "base/i18n/time_formatting.h"
 #include "base/macros.h"
 #include "base/observer_list.h"
-#include "chromeos/dbus/system_clock/system_clock_client.h"
+#include "chromeos/dbus/system_clock_client.h"
 #include "chromeos/settings/timezone_settings.h"
 
 namespace ash {
--- a/ash/system/model/system_tray_model.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/model/system_tray_model.cc	2019-05-17 18:53:08.308000000 +0300
@@ -13,7 +13,6 @@
 #include "ash/system/model/tracing_model.h"
 #include "ash/system/model/update_model.h"
 #include "ash/system/model/virtual_keyboard_model.h"
-#include "ash/system/network/active_network_icon.h"
 #include "ash/system/status_area_widget.h"
 #include "ash/system/unified/unified_system_tray.h"
 #include "base/logging.h"
@@ -27,8 +26,7 @@
       session_length_limit_(std::make_unique<SessionLengthLimitModel>()),
       tracing_(std::make_unique<TracingModel>()),
       update_model_(std::make_unique<UpdateModel>()),
-      virtual_keyboard_(std::make_unique<VirtualKeyboardModel>()),
-      active_network_icon_(std::make_unique<ActiveNetworkIcon>()) {}
+      virtual_keyboard_(std::make_unique<VirtualKeyboardModel>()) {}
 
 SystemTrayModel::~SystemTrayModel() = default;
 
--- a/ash/system/model/system_tray_model.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/model/system_tray_model.h	2019-05-17 18:53:08.308000000 +0300
@@ -13,7 +13,6 @@
 
 namespace ash {
 
-class ActiveNetworkIcon;
 class ClockModel;
 class EnterpriseDomainModel;
 class LocaleModel;
@@ -63,9 +62,6 @@
   TracingModel* tracing() { return tracing_.get(); }
   UpdateModel* update_model() { return update_model_.get(); }
   VirtualKeyboardModel* virtual_keyboard() { return virtual_keyboard_.get(); }
-  ActiveNetworkIcon* active_network_icon() {
-    return active_network_icon_.get();
-  }
 
   const mojom::SystemTrayClientPtr& client_ptr() { return client_ptr_; }
 
@@ -77,7 +73,6 @@
   std::unique_ptr<TracingModel> tracing_;
   std::unique_ptr<UpdateModel> update_model_;
   std::unique_ptr<VirtualKeyboardModel> virtual_keyboard_;
-  std::unique_ptr<ActiveNetworkIcon> active_network_icon_;
 
   // TODO(tetsui): Add following as a sub-model of SystemTrayModel:
   // * BluetoothModel
--- a/ash/system/model/update_model.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/model/update_model.cc	2019-05-17 18:53:08.308000000 +0300
@@ -46,8 +46,8 @@
 }
 
 mojom::UpdateSeverity UpdateModel::GetSeverity() const {
-  // TODO(https://crbug.com/927010): adjust severity according the amount of
-  // time passing after update is available over cellular connection. Use low
+  // TODO(weidongg/691108): adjust severity according the amount of time
+  // passing after update is available over cellular connection. Use low
   // severity for update available over cellular connection.
   return update_over_cellular_available_ ? mojom::UpdateSeverity::LOW
                                          : severity_;
--- a/ash/system/network/auto_connect_notifier.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/network/auto_connect_notifier.cc	2019-05-17 18:53:08.308000000 +0300
@@ -7,7 +7,6 @@
 #include "ash/public/cpp/network_icon_image_source.h"
 #include "ash/public/cpp/notification_utils.h"
 #include "ash/strings/grit/ash_strings.h"
-#include "base/bind_helpers.h"
 #include "base/logging.h"
 #include "base/strings/string16.h"
 #include "base/time/time.h"
--- a/ash/system/network/auto_connect_notifier_unittest.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/network/auto_connect_notifier_unittest.cc	2019-05-17 18:53:08.308000000 +0300
@@ -9,7 +9,6 @@
 #include "ash/shell.h"
 #include "ash/system/system_notification_controller.h"
 #include "ash/test/ash_test_base.h"
-#include "base/bind.h"
 #include "base/memory/ptr_util.h"
 #include "base/run_loop.h"
 #include "base/timer/mock_timer.h"
@@ -17,6 +16,7 @@
 #include "chromeos/dbus/shill_service_client.h"
 #include "chromeos/network/auto_connect_handler.h"
 #include "chromeos/network/network_cert_loader.h"
+#include "chromeos/network/network_connection_handler.h"
 #include "chromeos/network/network_handler.h"
 #include "dbus/object_path.h"
 #include "third_party/cros_system_api/dbus/shill/dbus-constants.h"
--- a/ash/system/network/network_feature_pod_button.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/network/network_feature_pod_button.cc	2019-05-17 18:53:08.308000000 +0300
@@ -6,12 +6,11 @@
 
 #include "ash/shell.h"
 #include "ash/strings/grit/ash_strings.h"
-#include "ash/system/model/system_tray_model.h"
-#include "ash/system/network/active_network_icon.h"
 #include "ash/system/network/network_icon.h"
 #include "ash/system/network/network_icon_animation.h"
 #include "ash/system/tray/system_tray_notifier.h"
 #include "base/strings/utf_string_conversions.h"
+#include "chromeos/network/network_connection_handler.h"
 #include "chromeos/network/network_state.h"
 #include "chromeos/network/network_state_handler.h"
 #include "third_party/cros_system_api/dbus/service_constants.h"
@@ -35,14 +34,18 @@
 const NetworkState* GetCurrentNetwork() {
   NetworkStateHandler* state_handler =
       NetworkHandler::Get()->network_state_handler();
+  NetworkConnectionHandler* connect_handler =
+      NetworkHandler::Get()->network_connection_handler();
   const NetworkState* connected_network =
       state_handler->ConnectedNetworkByType(NetworkTypePattern::NonVirtual());
   const NetworkState* connecting_network =
       state_handler->ConnectingNetworkByType(NetworkTypePattern::Wireless());
-  // If connecting to a network, and there is either no connected network or
-  // the connection was user requested, use the connecting network.
+  // If we are connecting to a network, and there is either no connected
+  // network, or the connection was user requested, or shill triggered a
+  // reconnection, use the connecting network.
   if (connecting_network &&
-      (!connected_network || connecting_network->connect_requested())) {
+      (!connected_network || connecting_network->IsReconnecting() ||
+       connect_handler->HasConnectingNetwork(connecting_network->path()))) {
     return connecting_network;
   }
 
@@ -86,10 +89,11 @@
 }
 
 void NetworkFeaturePodButton::Update() {
+  gfx::ImageSkia image;
   bool animating = false;
-  gfx::ImageSkia image =
-      Shell::Get()->system_tray_model()->active_network_icon()->GetSingleImage(
-          network_icon::ICON_TYPE_DEFAULT_VIEW, &animating);
+  network_icon::GetDefaultNetworkImageAndLabel(
+      network_icon::ICON_TYPE_DEFAULT_VIEW, &image, nullptr, &animating);
+
   if (animating)
     network_icon::NetworkIconAnimation::GetInstance()->AddObserver(this);
   else
@@ -119,7 +123,7 @@
 
   SetLabel(network_name);
 
-  if (network->IsConnectingState()) {
+  if (network->IsReconnecting() || network->IsConnectingState()) {
     SetSubLabel(l10n_util::GetStringUTF16(
         IDS_ASH_STATUS_TRAY_NETWORK_CONNECTING_SUBLABEL));
     SetTooltipState(l10n_util::GetStringFUTF16(
--- a/ash/system/network/network_icon_animation_observer.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/network/network_icon_animation_observer.h	2019-05-17 18:53:08.312000000 +0300
@@ -13,7 +13,8 @@
 // Observer interface class for animating network icons.
 class ASH_EXPORT AnimationObserver {
  public:
-  // Called when the image has changed due to animation.
+  // Called when the image has changed due to animation. The callback should
+  // trigger a call to GetImageForNetwork() to retrieve the image.
   virtual void NetworkIconChanged() = 0;
 
  protected:
--- a/ash/system/network/network_icon.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/network/network_icon.cc	2019-05-17 18:53:08.312000000 +0300
@@ -4,9 +4,6 @@
 
 #include "ash/system/network/network_icon.h"
 
-#include <utility>
-
-#include "ash/public/cpp/ash_features.h"
 #include "ash/public/cpp/network_icon_image_source.h"
 #include "ash/resources/vector_icons/vector_icons.h"
 #include "ash/strings/grit/ash_strings.h"
@@ -16,12 +13,13 @@
 #include "base/macros.h"
 #include "base/memory/ptr_util.h"
 #include "base/strings/utf_string_conversions.h"
+#include "components/vector_icons/vector_icons.h"
+#include "chromeos/network/network_connection_handler.h"
 #include "chromeos/network/network_state.h"
-#include "chromeos/network/network_type_pattern.h"
-#include "chromeos/network/onc/onc_translation_tables.h"
+#include "chromeos/network/network_state_handler.h"
+#include "chromeos/network/portal_detector/network_portal_detector.h"
 #include "chromeos/network/tether_constants.h"
-#include "components/onc/onc_constants.h"
-#include "components/vector_icons/vector_icons.h"
+#include "third_party/cros_system_api/dbus/service_constants.h"
 #include "ui/base/l10n/l10n_util.h"
 #include "ui/gfx/image/image_skia_operations.h"
 #include "ui/gfx/image/image_skia_source.h"
@@ -29,6 +27,11 @@
 #include "ui/gfx/skia_util.h"
 #include "ui/gfx/vector_icon_types.h"
 
+using chromeos::NetworkConnectionHandler;
+using chromeos::NetworkHandler;
+using chromeos::NetworkPortalDetector;
+using chromeos::NetworkState;
+using chromeos::NetworkStateHandler;
 using chromeos::NetworkTypePattern;
 
 namespace ash {
@@ -39,38 +42,58 @@
 // class used for maintaining a map of network state and images.
 class NetworkIconImpl {
  public:
-  NetworkIconImpl(const std::string& guid,
+  NetworkIconImpl(const std::string& path,
                   IconType icon_type,
-                  NetworkType network_type);
+                  const std::string& network_type);
 
   // Determines whether or not the associated network might be dirty and if so
   // updates and generates the icon. Does nothing if network no longer exists.
-  void Update(const NetworkIconState& network, bool show_vpn_badge);
+  void Update(const chromeos::NetworkState* network);
 
   const gfx::ImageSkia& image() const { return image_; }
 
  private:
   // Updates |strength_index_| for wireless networks. Returns true if changed.
-  bool UpdateWirelessStrengthIndex(const NetworkIconState& network);
+  bool UpdateWirelessStrengthIndex(const chromeos::NetworkState* network);
 
   // Updates the local state for cellular networks. Returns true if changed.
-  bool UpdateCellularState(const NetworkIconState& network);
+  bool UpdateCellularState(const chromeos::NetworkState* network);
+
+  // Updates the portal state for wireless networks. Returns true if changed.
+  bool UpdatePortalState(const chromeos::NetworkState* network);
+
+  // Updates the VPN badge. Returns true if changed.
+  bool UpdateVPNBadge();
 
   // Gets |badges| based on |network| and the current state.
-  void GetBadges(const NetworkIconState& network, Badges* badges);
+  void GetBadges(const NetworkState* network, Badges* badges);
 
   // Gets the appropriate icon and badges and composites the image.
-  void GenerateImage(const NetworkIconState& network);
+  void GenerateImage(const chromeos::NetworkState* network);
+
+  // Network path, used for debugging.
+  std::string network_path_;
 
   // Defines color theme and VPN badging
   const IconType icon_type_;
 
   // Cached state of the network when the icon was last generated.
-  ConnectionStateType connection_state_ = ConnectionStateType::kNotConnected;
-  int strength_index_ = -1;
+  std::string state_;
+
+  // Cached strength index of the network when the icon was last generated.
+  int strength_index_;
+
+  // Cached technology badge for the network when the icon was last generated.
   Badge technology_badge_ = {};
-  bool show_vpn_badge_ = false;
-  bool is_roaming_ = false;
+
+  // Cached vpn badge for the network when the icon was last generated.
+  Badge vpn_badge_ = {};
+
+  // Cached roaming state of the network when the icon was last generated.
+  bool is_roaming_;
+
+  // Cached portal state of the network when the icon was last generated.
+  bool behind_captive_portal_;
 
   // Generated icon image.
   gfx::ImageSkia image_;
@@ -106,14 +129,14 @@
 }
 
 void PurgeIconMap(IconType icon_type,
-                  const std::set<std::string>& network_guids) {
+                  const std::set<std::string>& network_paths) {
   NetworkIconMap* icon_map = GetIconMapInstance(icon_type, false);
   if (!icon_map)
     return;
   for (NetworkIconMap::iterator loop_iter = icon_map->begin();
        loop_iter != icon_map->end();) {
     NetworkIconMap::iterator cur_iter = loop_iter++;
-    if (network_guids.count(cur_iter->first) == 0) {
+    if (network_paths.count(cur_iter->first) == 0) {
       delete cur_iter->second;
       icon_map->erase(cur_iter);
     }
@@ -164,22 +187,36 @@
 //------------------------------------------------------------------------------
 // Utilities for extracting icon images.
 
-ImageType ImageTypeForNetworkType(NetworkType network_type) {
-  if (network_type == NetworkType::kWiFi)
+ImageType ImageTypeForNetworkType(const std::string& type) {
+  if (NetworkTypePattern::WiFi().MatchesType(type))
     return ARCS;
 
-  if (network_type == NetworkType::kCellular ||
-      network_type == NetworkType::kTether) {
+  if (NetworkTypePattern::Mobile().MatchesType(type))
     return BARS;
-  }
 
   return NONE;
 }
 
+// Returns the network type, performing a check to see if Wi-Fi networks
+// have an associated Tether network. Used to display the correct icon.
+std::string GetEffectiveNetworkType(const NetworkState* network,
+                                    IconType icon_type) {
+  if (IsTrayIcon(icon_type) && network->type() == shill::kTypeWifi &&
+      !network->tether_guid().empty()) {
+    return chromeos::kTypeTether;
+  }
+
+  return network->type();
+}
+
+ImageType ImageTypeForNetwork(const NetworkState* network, IconType icon_type) {
+  return ImageTypeForNetworkType(GetEffectiveNetworkType(network, icon_type));
+}
+
 gfx::Size GetSizeForIconType(IconType icon_type) {
   int size = kMenuIconSize;
   if (IsTrayIcon(icon_type)) {
-    size = kUnifiedTrayIconSize;
+    size = TrayConstants::GetTrayIconSize();
   } else if (icon_type == ICON_TYPE_DEFAULT_VIEW) {
     size = kUnifiedFeaturePodVectorIconSize;
   }
@@ -200,6 +237,16 @@
       GetSizeForIconType(icon_type), index, GetPaddingForIconType(icon_type));
 }
 
+// Returns an image to represent either a fully connected network or a
+// disconnected network.
+const gfx::ImageSkia GetBasicImage(bool connected,
+                                   IconType icon_type,
+                                   const std::string& network_type) {
+  DCHECK_NE(shill::kTypeVPN, network_type);
+  return GetImageForIndex(ImageTypeForNetworkType(network_type), icon_type,
+                          connected ? kNumNetworkImages - 1 : 0);
+}
+
 gfx::ImageSkia* ConnectingWirelessImage(ImageType image_type,
                                         IconType icon_type,
                                         double animation) {
@@ -237,6 +284,11 @@
           SkColorSetA(kMenuIconColor, kConnectingImageAlpha), kMenuIconColor));
 }
 
+Badge ConnectingVpnBadge(double animation, IconType icon_type) {
+  return {&kUnifiedNetworkBadgeVpnIcon,
+          SkColorSetA(GetDefaultColorForIconType(icon_type), 0xFF * animation)};
+}
+
 int StrengthIndex(int strength) {
   if (strength <= 0)
     return 0;
@@ -250,28 +302,28 @@
   return zero_based_index + 1;
 }
 
-Badge BadgeForNetworkTechnology(const NetworkIconState& network,
+Badge BadgeForNetworkTechnology(const NetworkState* network,
                                 IconType icon_type) {
   Badge badge = {nullptr, GetDefaultColorForIconType(icon_type)};
-  const std::string& technology = network.network_technology;
-  if (technology == onc::cellular::kTechnologyEvdo) {
+  const std::string& technology = network->network_technology();
+  if (technology == shill::kNetworkTechnologyEvdo) {
     badge.icon = &kNetworkBadgeTechnologyEvdoIcon;
-  } else if (technology == onc::cellular::kTechnologyCdma1Xrtt) {
+  } else if (technology == shill::kNetworkTechnology1Xrtt) {
     badge.icon = &kNetworkBadgeTechnology1xIcon;
-  } else if (technology == onc::cellular::kTechnologyGprs ||
-             technology == onc::cellular::kTechnologyGsm) {
+  } else if (technology == shill::kNetworkTechnologyGprs ||
+             technology == shill::kNetworkTechnologyGsm) {
     badge.icon = &kNetworkBadgeTechnologyGprsIcon;
-  } else if (technology == onc::cellular::kTechnologyEdge) {
+  } else if (technology == shill::kNetworkTechnologyEdge) {
     badge.icon = &kNetworkBadgeTechnologyEdgeIcon;
-  } else if (technology == onc::cellular::kTechnologyUmts) {
+  } else if (technology == shill::kNetworkTechnologyUmts) {
     badge.icon = &kNetworkBadgeTechnology3gIcon;
-  } else if (technology == onc::cellular::kTechnologyHspa) {
+  } else if (technology == shill::kNetworkTechnologyHspa) {
     badge.icon = &kNetworkBadgeTechnologyHspaIcon;
-  } else if (technology == onc::cellular::kTechnologyHspaPlus) {
+  } else if (technology == shill::kNetworkTechnologyHspaPlus) {
     badge.icon = &kNetworkBadgeTechnologyHspaPlusIcon;
-  } else if (technology == onc::cellular::kTechnologyLte) {
+  } else if (technology == shill::kNetworkTechnologyLte) {
     badge.icon = &kNetworkBadgeTechnologyLteIcon;
-  } else if (technology == onc::cellular::kTechnologyLteAdvanced) {
+  } else if (technology == shill::kNetworkTechnologyLteAdvanced) {
     badge.icon = &kNetworkBadgeTechnologyLteAdvancedIcon;
   } else {
     return {};
@@ -279,121 +331,88 @@
   return badge;
 }
 
-gfx::ImageSkia GetIcon(const NetworkIconState& network,
+gfx::ImageSkia GetIcon(const NetworkState* network,
                        IconType icon_type,
                        int strength_index) {
-  if (network.type == NetworkType::kEthernet) {
+  if (network->Matches(NetworkTypePattern::Ethernet())) {
     return gfx::CreateVectorIcon(vector_icons::kEthernetIcon,
                                  GetDefaultColorForIconType(icon_type));
   }
-  if (network.type == NetworkType::kVPN) {
+  if (network->Matches(NetworkTypePattern::Wireless())) {
+    return GetImageForIndex(ImageTypeForNetwork(network, icon_type), icon_type,
+                            strength_index);
+  }
+  if (network->Matches(NetworkTypePattern::VPN())) {
     DCHECK(!IsTrayIcon(icon_type));
     return gfx::CreateVectorIcon(kNetworkVpnIcon,
                                  GetDefaultColorForIconType(ICON_TYPE_LIST));
   }
-  return GetImageForIndex(ImageTypeForNetworkType(network.type), icon_type,
-                          strength_index);
-}
 
-gfx::ImageSkia GetConnectingVpnImage(IconType icon_type) {
-  double animation = NetworkIconAnimation::GetInstance()->GetAnimation();
-  gfx::ImageSkia icon = ConnectingVpnImage(animation);
-  return CreateNetworkIconImage(icon, Badges());
+  NOTREACHED() << "Request for icon for unsupported type: " << network->type();
+  return gfx::ImageSkia();
 }
 
-}  // namespace
+//------------------------------------------------------------------------------
+// Get connecting images
 
-NetworkIconState::NetworkIconState(const chromeos::NetworkState* network) {
-  guid = network->guid();
-  name = network->name();
-
-  const std::string& network_type = network->type();
-  if (NetworkTypePattern::Cellular().MatchesType(network_type) ||
-      NetworkTypePattern::Wimax().MatchesType(network_type)) {
-    type = NetworkType::kCellular;
-  } else if (NetworkTypePattern::Ethernet().MatchesType(network_type)) {
-    type = NetworkType::kEthernet;
-  } else if (NetworkTypePattern::Tether().MatchesType(network_type)) {
-    type = NetworkType::kTether;
-  } else if (NetworkTypePattern::VPN().MatchesType(network_type)) {
-    type = NetworkType::kVPN;
-  } else {
-    type = NetworkType::kWiFi;
+gfx::ImageSkia GetConnectingVpnImage(IconType icon_type) {
+  NetworkStateHandler* handler = NetworkHandler::Get()->network_state_handler();
+  const NetworkState* connected_network = nullptr;
+  if (IsTrayIcon(icon_type)) {
+    connected_network =
+        handler->ConnectedNetworkByType(NetworkTypePattern::NonVirtual());
   }
+  double animation = NetworkIconAnimation::GetInstance()->GetAnimation();
 
-  if (network->IsCaptivePortal()) {
-    connection_state = ConnectionStateType::kPortal;
-  } else if (network->IsConnectedState()) {
-    connection_state = ConnectionStateType::kConnected;
-  } else if (network->IsConnectingState()) {
-    connection_state = ConnectionStateType::kConnecting;
+  gfx::ImageSkia icon;
+  Badges badges;
+  if (connected_network) {
+    icon = GetImageForNetwork(connected_network, icon_type);
+    badges.bottom_left = ConnectingVpnBadge(animation, icon_type);
   } else {
-    connection_state = ConnectionStateType::kNotConnected;
+    icon = ConnectingVpnImage(animation);
   }
-
-  if (type == NetworkType::kWiFi && !network->security_class().empty()) {
-    chromeos::onc::TranslateStringToONC(chromeos::onc::kWiFiSecurityTable,
-                                        network->security_class(), &security);
-  }
-  if (type == NetworkType::kCellular) {
-    if (!network->network_technology().empty()) {
-      chromeos::onc::TranslateStringToONC(
-          chromeos::onc::kNetworkTechnologyTable, network->network_technology(),
-          &network_technology);
-    }
-    if (!network->activation_state().empty()) {
-      chromeos::onc::TranslateStringToONC(chromeos::onc::kActivationStateTable,
-                                          network->activation_state(),
-                                          &activation_state);
-    }
-  }
-  signal_strength = network->signal_strength();
-  is_roaming = network->IndicateRoaming();
+  return CreateNetworkIconImage(icon, badges);
 }
 
-NetworkIconState::NetworkIconState(const NetworkIconState& other) = default;
-
-NetworkIconState& NetworkIconState::operator=(const NetworkIconState& other) =
-    default;
-
-NetworkIconState::~NetworkIconState() = default;
+}  // namespace
 
 //------------------------------------------------------------------------------
 // NetworkIconImpl
 
-NetworkIconImpl::NetworkIconImpl(const std::string& guid,
+NetworkIconImpl::NetworkIconImpl(const std::string& path,
                                  IconType icon_type,
-                                 NetworkType network_type)
-    : icon_type_(icon_type) {
+                                 const std::string& network_type)
+    : network_path_(path),
+      icon_type_(icon_type),
+      strength_index_(-1),
+      behind_captive_portal_(false) {
   // Default image is null.
 }
 
-void NetworkIconImpl::Update(const NetworkIconState& network,
-                             bool show_vpn_badge) {
+void NetworkIconImpl::Update(const NetworkState* network) {
+  DCHECK(network);
   // Determine whether or not we need to update the icon.
   bool dirty = image_.isNull();
 
-  if (network.connection_state != connection_state_) {
-    VLOG(2) << "Update connection state: "
-            << static_cast<int>(network.connection_state);
-    connection_state_ = network.connection_state;
+  // If the network state has changed, the icon needs updating.
+  if (state_ != network->connection_state()) {
+    state_ = network->connection_state();
     dirty = true;
   }
 
-  NetworkType type = network.type;
-  if (type == NetworkType::kCellular || type == NetworkType::kTether ||
-      type == NetworkType::kWiFi) {
+  dirty |= UpdatePortalState(network);
+
+  if (network->Matches(NetworkTypePattern::Wireless())) {
     dirty |= UpdateWirelessStrengthIndex(network);
   }
 
-  if (type == NetworkType::kCellular)
+  if (network->Matches(NetworkTypePattern::Cellular()))
     dirty |= UpdateCellularState(network);
 
-  bool new_show_vpn_badge = show_vpn_badge && IconTypeHasVPNBadge(icon_type_);
-  if (new_show_vpn_badge != show_vpn_badge_) {
-    VLOG(2) << "Update VPN badge: " << new_show_vpn_badge;
-    show_vpn_badge_ = new_show_vpn_badge;
-    dirty = true;
+  if (IconTypeHasVPNBadge(icon_type_) &&
+      network->Matches(NetworkTypePattern::NonVirtual())) {
+    dirty |= UpdateVPNBadge();
   }
 
   if (dirty) {
@@ -402,61 +421,90 @@
   }
 }
 
-bool NetworkIconImpl::UpdateWirelessStrengthIndex(
-    const NetworkIconState& network) {
-  int index = StrengthIndex(network.signal_strength);
+bool NetworkIconImpl::UpdateWirelessStrengthIndex(const NetworkState* network) {
+  int index = StrengthIndex(network->signal_strength());
   if (index != strength_index_) {
-    VLOG(2) << "New strength index: " << index;
     strength_index_ = index;
     return true;
   }
   return false;
 }
 
-bool NetworkIconImpl::UpdateCellularState(const NetworkIconState& network) {
+bool NetworkIconImpl::UpdateCellularState(const NetworkState* network) {
   bool dirty = false;
-  if (!features::IsSeparateNetworkIconsEnabled()) {
-    const Badge technology_badge =
-        BadgeForNetworkTechnology(network, icon_type_);
+  const Badge technology_badge = BadgeForNetworkTechnology(network, icon_type_);
     if (technology_badge != technology_badge_) {
-      VLOG(2) << "New technology badge.";
       technology_badge_ = technology_badge;
       dirty = true;
     }
-  }
-
-  if (network.is_roaming != is_roaming_) {
-    VLOG(2) << "New is_roaming: " << network.is_roaming;
-    is_roaming_ = network.is_roaming;
+  bool is_roaming = network->IndicateRoaming();
+  if (is_roaming != is_roaming_) {
+    is_roaming_ = is_roaming;
     dirty = true;
   }
   return dirty;
 }
 
-void NetworkIconImpl::GetBadges(const NetworkIconState& network,
-                                Badges* badges) {
-  const NetworkType type = network.type;
+bool NetworkIconImpl::UpdatePortalState(const NetworkState* network) {
+  bool behind_captive_portal = false;
+  if (network && chromeos::network_portal_detector::IsInitialized()) {
+    NetworkPortalDetector::CaptivePortalState state =
+        chromeos::network_portal_detector::GetInstance()->GetCaptivePortalState(
+            network->guid());
+    behind_captive_portal =
+        state.status == NetworkPortalDetector::CAPTIVE_PORTAL_STATUS_PORTAL;
+  }
+
+  if (behind_captive_portal == behind_captive_portal_)
+    return false;
+  behind_captive_portal_ = behind_captive_portal;
+  return true;
+}
+
+bool NetworkIconImpl::UpdateVPNBadge() {
+  const NetworkState* vpn =
+      NetworkHandler::Get()->network_state_handler()->ConnectedNetworkByType(
+          NetworkTypePattern::VPN());
+  Badge vpn_badge = {};
+  if (vpn)
+    vpn_badge = {&kUnifiedNetworkBadgeVpnIcon,
+                 GetDefaultColorForIconType(icon_type_)};
+  if (vpn_badge != vpn_badge_) {
+    vpn_badge_ = vpn_badge;
+    return true;
+  }
+  return false;
+}
+
+void NetworkIconImpl::GetBadges(const NetworkState* network, Badges* badges) {
+  DCHECK(network);
+
+  const std::string& type = network->type();
   const SkColor icon_color = GetDefaultColorForIconType(icon_type_);
-  if (type == NetworkType::kWiFi) {
-    if (network.security != onc::wifi::kSecurityNone &&
+  if (type == shill::kTypeWifi) {
+    if (network->security_class() != shill::kSecurityNone &&
         !IsTrayIcon(icon_type_)) {
       badges->bottom_right = {&kUnifiedNetworkBadgeSecureIcon, icon_color};
     }
-  } else if (type == NetworkType::kCellular) {
+  } else if (type == shill::kTypeWimax) {
+    technology_badge_ = {&kNetworkBadgeTechnology4gIcon, icon_color};
+  } else if (type == shill::kTypeCellular) {
     // technology_badge_ is set in UpdateCellularState.
-    if (IsConnected(network) && network.is_roaming)
+    if (network->IsConnectedState() && network->IndicateRoaming())
       badges->bottom_right = {&kNetworkBadgeRoamingIcon, icon_color};
   }
-  // Only show technology badge when connected.
-  if (IsConnected(network) && !features::IsSeparateNetworkIconsEnabled())
+  // Only show technology, VPN, and captive portal badges when connected.
+  if (network->IsConnectedState()) {
     badges->top_left = technology_badge_;
-  if (show_vpn_badge_)
-    badges->bottom_left = {&kUnifiedNetworkBadgeVpnIcon, icon_color};
-  if (connection_state_ == ConnectionStateType::kPortal)
-    badges->bottom_right = {&kUnifiedNetworkBadgeCaptivePortalIcon, icon_color};
+    badges->bottom_left = vpn_badge_;
+    if (behind_captive_portal_)
+      badges->bottom_right = {&kUnifiedNetworkBadgeCaptivePortalIcon,
+                              icon_color};
+  }
 }
 
-void NetworkIconImpl::GenerateImage(const NetworkIconState& network) {
+void NetworkIconImpl::GenerateImage(const NetworkState* network) {
+  DCHECK(network);
   gfx::ImageSkia icon = GetIcon(network, icon_type_, strength_index_);
   Badges badges;
   GetBadges(network, &badges);
@@ -465,24 +513,22 @@
 
 namespace {
 
-NetworkIconImpl* FindAndUpdateImageImpl(const NetworkIconState& network,
-                                        IconType icon_type,
-                                        bool show_vpn_badge) {
+NetworkIconImpl* FindAndUpdateImageImpl(const NetworkState* network,
+                                        IconType icon_type) {
   // Find or add the icon.
   NetworkIconMap* icon_map = GetIconMap(icon_type);
   NetworkIconImpl* icon;
-  NetworkIconMap::iterator iter = icon_map->find(network.guid);
+  NetworkIconMap::iterator iter = icon_map->find(network->path());
   if (iter == icon_map->end()) {
-    VLOG(1) << "new NetworkIconImpl: " << network.name;
-    icon = new NetworkIconImpl(network.guid, icon_type, network.type);
-    icon_map->insert(std::make_pair(network.guid, icon));
+    icon = new NetworkIconImpl(network->path(), icon_type,
+                               GetEffectiveNetworkType(network, icon_type));
+    icon_map->insert(std::make_pair(network->path(), icon));
   } else {
-    VLOG(1) << "found NetworkIconImpl: " << network.name;
     icon = iter->second;
   }
 
   // Update and return the icon's image.
-  icon->Update(network, show_vpn_badge);
+  icon->Update(network);
   return icon;
 }
 
@@ -491,55 +537,25 @@
 //------------------------------------------------------------------------------
 // Public interface
 
-bool IsConnected(const NetworkIconState& icon_state) {
-  return icon_state.connection_state == ConnectionStateType::kConnected ||
-         icon_state.connection_state == ConnectionStateType::kPortal;
-}
-
-bool IsConnecting(const NetworkIconState& icon_state) {
-  return icon_state.connection_state == ConnectionStateType::kConnecting;
-}
-
-const gfx::ImageSkia GetBasicImage(IconType icon_type,
-                                   NetworkType network_type,
-                                   bool connected) {
-  DCHECK_NE(NetworkType::kVPN, network_type);
-  return GetImageForIndex(ImageTypeForNetworkType(network_type), icon_type,
-                          connected ? kNumNetworkImages - 1 : 0);
-}
-
-gfx::ImageSkia GetImageForNonVirtualNetwork(const NetworkIconState& network,
+gfx::ImageSkia GetImageForNetwork(const NetworkState* network,
                                             IconType icon_type,
-                                            bool show_vpn_badge,
                                             bool* animating) {
-  DCHECK_NE(NetworkType::kVPN, network.type);
-  NetworkType network_type = network.type;
-
-  if (IsConnecting(network)) {
-    if (animating)
-      *animating = true;
-    return GetConnectingImageForNetworkType(network_type, icon_type);
-  }
+  DCHECK(network);
+  const std::string network_type = GetEffectiveNetworkType(network, icon_type);
 
-  NetworkIconImpl* icon =
-      FindAndUpdateImageImpl(network, icon_type, show_vpn_badge);
+  if (!network->visible()) {
   if (animating)
     *animating = false;
-  return icon->image();
-}
+    return GetBasicImage(false /* is_connected */, icon_type, network_type);
+  }
 
-gfx::ImageSkia GetImageForVPN(const NetworkIconState& vpn,
-                              IconType icon_type,
-                              bool* animating) {
-  DCHECK_EQ(NetworkType::kVPN, vpn.type);
-  if (IsConnecting(vpn)) {
+  if (network->IsConnectingState()) {
     if (animating)
       *animating = true;
-    return GetConnectingVpnImage(icon_type);
+    return GetConnectingImageForNetworkType(network_type, icon_type);
   }
 
-  NetworkIconImpl* icon =
-      FindAndUpdateImageImpl(vpn, icon_type, false /* show_vpn_badge */);
+  NetworkIconImpl* icon = FindAndUpdateImageImpl(network, icon_type);
   if (animating)
     *animating = false;
   return icon->image();
@@ -553,7 +569,7 @@
   }
 
   gfx::ImageSkia image =
-      GetBasicImage(icon_type, NetworkType::kWiFi, true /* connected */);
+      GetBasicImage(true /* connected */, icon_type, shill::kTypeWifi);
   Badges badges;
   if (!enabled) {
     badges.center = {&kNetworkBadgeOffIcon,
@@ -562,9 +578,11 @@
   return CreateNetworkIconImage(image, badges);
 }
 
-gfx::ImageSkia GetConnectingImageForNetworkType(NetworkType network_type,
+gfx::ImageSkia GetConnectingImageForNetworkType(const std::string& network_type,
                                                 IconType icon_type) {
-  DCHECK_NE(NetworkType::kVPN, network_type);
+  if (network_type == shill::kTypeVPN)
+    return GetConnectingVpnImage(icon_type);
+
   ImageType image_type = ImageTypeForNetworkType(network_type);
   double animation = NetworkIconAnimation::GetInstance()->GetAnimation();
 
@@ -572,84 +590,207 @@
       *ConnectingWirelessImage(image_type, icon_type, animation), Badges());
 }
 
-gfx::ImageSkia GetConnectedNetworkWithConnectingVpnImage(
-    const NetworkIconState& connected_network,
-    IconType icon_type) {
-  gfx::ImageSkia icon = GetImageForNonVirtualNetwork(
-      connected_network, icon_type, false /* show_vpn_badge */);
-  double animation = NetworkIconAnimation::GetInstance()->GetAnimation();
-  Badges badges;
-  badges.bottom_left = {
-      &kUnifiedNetworkBadgeVpnIcon,
-      SkColorSetA(GetDefaultColorForIconType(icon_type), 0xFF * animation)};
-  return CreateNetworkIconImage(icon, badges);
-}
-
-gfx::ImageSkia GetDisconnectedImageForNetworkType(NetworkType network_type) {
-  return GetBasicImage(ICON_TYPE_LIST, network_type, false /* connected */);
+gfx::ImageSkia GetDisconnectedImageForNetworkType(
+    const std::string& network_type) {
+  return GetBasicImage(false /* not connected */, ICON_TYPE_LIST, network_type);
 }
 
 gfx::ImageSkia GetImageForNewWifiNetwork(SkColor icon_color,
                                          SkColor badge_color) {
   gfx::ImageSkia icon =
       gfx::CanvasImageSource::MakeImageSkia<SignalStrengthImageSource>(
-          ImageTypeForNetworkType(NetworkType::kWiFi), icon_color,
+          ImageTypeForNetworkType(shill::kTypeWifi), icon_color,
           GetSizeForIconType(ICON_TYPE_LIST), kNumNetworkImages - 1);
   Badges badges;
   badges.bottom_right = {&kNetworkBadgeAddOtherIcon, badge_color};
   return CreateNetworkIconImage(icon, badges);
 }
 
-base::string16 GetLabelForNetwork(const NetworkIconState& network,
+base::string16 GetLabelForNetwork(const chromeos::NetworkState* network,
                                   IconType icon_type) {
-  std::string activation_state = network.activation_state;
+  DCHECK(network);
+  std::string activation_state = network->activation_state();
   if (icon_type == ICON_TYPE_LIST || icon_type == ICON_TYPE_MENU_LIST) {
-    // Show "<network>: [Connecting|Activating]..."
-    if (icon_type != ICON_TYPE_MENU_LIST && IsConnecting(network)) {
+    // Show "<network>: [Connecting|Activating|Reconnecting]..."
+    // TODO(varkha): Remaining states should migrate to secondary status in the
+    // network item and no longer be part of the label.
+    // See http://crbug.com/676181 .
+    if (network->IsReconnecting()) {
+      return l10n_util::GetStringFUTF16(
+          IDS_ASH_STATUS_TRAY_NETWORK_LIST_RECONNECTING,
+          base::UTF8ToUTF16(network->name()));
+    }
+    if (icon_type != ICON_TYPE_MENU_LIST && network->IsConnectingState()) {
       return l10n_util::GetStringFUTF16(
           IDS_ASH_STATUS_TRAY_NETWORK_LIST_CONNECTING,
-          base::UTF8ToUTF16(network.name));
+          base::UTF8ToUTF16(network->name()));
     }
-    if (activation_state == onc::cellular::kActivating) {
+    if (activation_state == shill::kActivationStateActivating) {
       return l10n_util::GetStringFUTF16(
           IDS_ASH_STATUS_TRAY_NETWORK_LIST_ACTIVATING,
-          base::UTF8ToUTF16(network.name));
+          base::UTF8ToUTF16(network->name()));
     }
     // Show "Activate <network>" in list view only.
-    if (activation_state == onc::cellular::kNotActivated ||
-        activation_state == onc::cellular::kPartiallyActivated) {
+    if (activation_state == shill::kActivationStateNotActivated ||
+        activation_state == shill::kActivationStatePartiallyActivated) {
       return l10n_util::GetStringFUTF16(
           IDS_ASH_STATUS_TRAY_NETWORK_LIST_ACTIVATE,
-          base::UTF8ToUTF16(network.name));
+          base::UTF8ToUTF16(network->name()));
     }
   } else {
-    // Show "[Connected to|Connecting to|Activating] <network>" (non-list view).
-    if (IsConnected(network)) {
+    // Show "[Connected to|Connecting to|Activating|Reconnecting to] <network>"
+    // (non-list view).
+    if (network->IsReconnecting()) {
+      return l10n_util::GetStringFUTF16(
+          IDS_ASH_STATUS_TRAY_NETWORK_RECONNECTING,
+          base::UTF8ToUTF16(network->name()));
+    }
+    if (network->IsConnectedState()) {
       return l10n_util::GetStringFUTF16(IDS_ASH_STATUS_TRAY_NETWORK_CONNECTED,
-                                        base::UTF8ToUTF16(network.name));
+                                        base::UTF8ToUTF16(network->name()));
     }
-    if (IsConnecting(network)) {
+    if (network->IsConnectingState()) {
       return l10n_util::GetStringFUTF16(IDS_ASH_STATUS_TRAY_NETWORK_CONNECTING,
-                                        base::UTF8ToUTF16(network.name));
+                                        base::UTF8ToUTF16(network->name()));
     }
-    if (activation_state == onc::cellular::kActivating) {
+    if (activation_state == shill::kActivationStateActivating) {
       return l10n_util::GetStringFUTF16(IDS_ASH_STATUS_TRAY_NETWORK_ACTIVATING,
-                                        base::UTF8ToUTF16(network.name));
+                                        base::UTF8ToUTF16(network->name()));
     }
   }
 
   // Otherwise just show the network name or 'Ethernet'.
-  if (network.type == NetworkType::kEthernet)
+  if (network->Matches(NetworkTypePattern::Ethernet())) {
     return l10n_util::GetStringUTF16(IDS_ASH_STATUS_TRAY_ETHERNET);
-  return base::UTF8ToUTF16(network.name);
+  } else {
+    return base::UTF8ToUTF16(network->name());
+  }
+}
+
+int GetCellularUninitializedMsg() {
+  static base::Time s_uninitialized_state_time;
+  static int s_uninitialized_msg(0);
+
+  NetworkStateHandler* handler = NetworkHandler::Get()->network_state_handler();
+
+  if (handler->GetTechnologyState(NetworkTypePattern::Cellular()) ==
+      NetworkStateHandler::TECHNOLOGY_UNINITIALIZED) {
+    s_uninitialized_msg = IDS_ASH_STATUS_TRAY_INITIALIZING_CELLULAR;
+    s_uninitialized_state_time = base::Time::Now();
+    return s_uninitialized_msg;
+  }
+
+  if (handler->GetScanningByType(NetworkTypePattern::Cellular())) {
+    s_uninitialized_msg = IDS_ASH_STATUS_TRAY_MOBILE_SCANNING;
+    s_uninitialized_state_time = base::Time::Now();
+    return s_uninitialized_msg;
+  }
+
+  // There can be a delay between leaving the Initializing state and when
+  // a Cellular device shows up, so keep showing the initializing
+  // animation for a bit to avoid flashing the disconnect icon.
+  const int kInitializingDelaySeconds = 1;
+  base::TimeDelta dtime = base::Time::Now() - s_uninitialized_state_time;
+  if (dtime.InSeconds() < kInitializingDelaySeconds)
+    return s_uninitialized_msg;
+  return 0;
 }
 
-void PurgeNetworkIconCache(const std::set<std::string>& network_guids) {
-  PurgeIconMap(ICON_TYPE_TRAY_OOBE, network_guids);
-  PurgeIconMap(ICON_TYPE_TRAY_REGULAR, network_guids);
-  PurgeIconMap(ICON_TYPE_DEFAULT_VIEW, network_guids);
-  PurgeIconMap(ICON_TYPE_LIST, network_guids);
-  PurgeIconMap(ICON_TYPE_MENU_LIST, network_guids);
+void GetDefaultNetworkImageAndLabel(IconType icon_type,
+                                    gfx::ImageSkia* image,
+                                    base::string16* label,
+                                    bool* animating) {
+  NetworkStateHandler* state_handler =
+      NetworkHandler::Get()->network_state_handler();
+  NetworkConnectionHandler* connect_handler =
+      NetworkHandler::Get()->network_connection_handler();
+  const NetworkState* connected_network =
+      state_handler->ConnectedNetworkByType(NetworkTypePattern::NonVirtual());
+  const NetworkState* connecting_network =
+      state_handler->ConnectingNetworkByType(NetworkTypePattern::Wireless());
+  if (!connecting_network && IsTrayIcon(icon_type)) {
+    connecting_network =
+        state_handler->ConnectingNetworkByType(NetworkTypePattern::VPN());
+  }
+
+  const NetworkState* network;
+  // If we are connecting to a network, and there is either no connected
+  // network, or the connection was user requested, or shill triggered a
+  // reconnection, use the connecting network.
+  if (connecting_network &&
+      (!connected_network || connecting_network->IsReconnecting() ||
+       connect_handler->HasConnectingNetwork(connecting_network->path()))) {
+    network = connecting_network;
+  } else {
+    network = connected_network;
+  }
+
+  // Don't show ethernet in the tray
+  if (IsTrayIcon(icon_type) && network &&
+      network->Matches(NetworkTypePattern::Ethernet())) {
+    *image = gfx::ImageSkia();
+    *animating = false;
+    return;
+  }
+
+  if (!network) {
+    // If no connecting network, check if we are activating a network.
+    const NetworkState* mobile_network =
+        state_handler->FirstNetworkByType(NetworkTypePattern::Mobile());
+    if (mobile_network && (mobile_network->activation_state() ==
+                           shill::kActivationStateActivating)) {
+      network = mobile_network;
+    }
+  }
+  if (!network) {
+    // If no connecting network, check for mobile initializing. Do not display
+    // the message about enabling Bluetooth for Tether.
+    int uninitialized_msg = GetCellularUninitializedMsg();
+    if (uninitialized_msg != 0) {
+      *image =
+          GetConnectingImageForNetworkType(shill::kTypeCellular, icon_type);
+      if (label)
+        *label = l10n_util::GetStringUTF16(uninitialized_msg);
+      *animating = true;
+    } else {
+      // Otherwise show a Wi-Fi icon. If Wi-Fi is disabled, show a full icon
+      // with a strikethrough. If it's enabled then it's disconnected, so show
+      // an empty wedge.
+      bool wifi_enabled =
+          NetworkHandler::Get()->network_state_handler()->IsTechnologyEnabled(
+              NetworkTypePattern::WiFi());
+      *image = wifi_enabled ? GetBasicImage(false /* not connected */,
+                                            icon_type, shill::kTypeWifi)
+                            : GetImageForWiFiEnabledState(
+                                  false /* not enabled*/, icon_type);
+      if (label) {
+        *label = l10n_util::GetStringUTF16(
+            IDS_ASH_STATUS_TRAY_NETWORK_NOT_CONNECTED);
+      }
+      *animating = false;
+    }
+    return;
+  }
+  // Get icon and label for connected or connecting network.
+  *image = GetImageForNetwork(network, icon_type, animating);
+  if (label)
+    *label = GetLabelForNetwork(network, icon_type);
+}
+
+void PurgeNetworkIconCache() {
+  NetworkStateHandler::NetworkStateList networks;
+  NetworkHandler::Get()->network_state_handler()->GetVisibleNetworkList(
+      &networks);
+  std::set<std::string> network_paths;
+  for (NetworkStateHandler::NetworkStateList::iterator iter = networks.begin();
+       iter != networks.end(); ++iter) {
+    network_paths.insert((*iter)->path());
+  }
+  PurgeIconMap(ICON_TYPE_TRAY_OOBE, network_paths);
+  PurgeIconMap(ICON_TYPE_TRAY_REGULAR, network_paths);
+  PurgeIconMap(ICON_TYPE_DEFAULT_VIEW, network_paths);
+  PurgeIconMap(ICON_TYPE_LIST, network_paths);
+  PurgeIconMap(ICON_TYPE_MENU_LIST, network_paths);
 }
 
 SignalStrength GetSignalStrengthForNetwork(
--- a/ash/system/network/network_icon.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/network/network_icon.h	2019-05-17 18:53:08.312000000 +0300
@@ -5,7 +5,6 @@
 #ifndef ASH_SYSTEM_NETWORK_NETWORK_ICON_H_
 #define ASH_SYSTEM_NETWORK_NETWORK_ICON_H_
 
-#include <set>
 #include <string>
 
 #include "ash/ash_export.h"
@@ -21,42 +20,6 @@
 namespace ash {
 namespace network_icon {
 
-// TODO(stevenjb): Replace with mojo enum once available.
-enum class NetworkType : int32_t {
-  kCellular,
-  kEthernet,
-  kTether,
-  kVPN,
-  kWiFi,
-};
-
-// TODO(stevenjb): Replace with mojo enum once available.
-enum class ConnectionStateType : int32_t {
-  kNotConnected,
-  kConnecting,
-  kConnected,
-  kPortal,
-};
-
-// TODO(stevenjb): Replace with mojo type once available.
-struct ASH_EXPORT NetworkIconState {
-  // Constructs a NetworkIconState from a NetworkState.
-  explicit NetworkIconState(const chromeos::NetworkState* network);
-  NetworkIconState(const NetworkIconState& other);
-  NetworkIconState& operator=(const NetworkIconState& other);
-  ~NetworkIconState();
-
-  std::string guid;
-  std::string name;
-  NetworkType type;
-  ConnectionStateType connection_state;
-  std::string security;            // ONC security type
-  std::string network_technology;  // ONC network technology type
-  std::string activation_state;    // ONC activation state
-  int signal_strength = 0;         // 0-100.
-  bool is_roaming = false;
-};
-
 // Type of icon which dictates color theme and VPN badging
 enum IconType {
   ICON_TYPE_TRAY_OOBE,     // dark icons with VPN badges, used during OOBE
@@ -69,69 +32,56 @@
 // Strength of a wireless signal.
 enum class SignalStrength { NONE, WEAK, MEDIUM, STRONG, NOT_WIRELESS };
 
-// Returns true if |icon_state| is connected or portal.
-bool IsConnected(const NetworkIconState& icon_state);
-
-// Returns true if |icon_state| is connecting.
-bool IsConnecting(const NetworkIconState& icon_state);
-
-// Returns an image to represent either a fully connected network or a
-// disconnected network.
-const gfx::ImageSkia GetBasicImage(IconType icon_type,
-                                   NetworkType network_type,
-                                   bool connected);
-
-// Returns and caches an image for non VPN |network| which must not be null.
-// Use this for non virtual networks and for the default (tray) icon.
-// |icon_type| determines the color theme.
-// |badge_vpn| should be true if a VPN is also connected and a badge is desired.
-// |animating| is an optional out parameter that is set to true when the
-// returned image should be animated.
-ASH_EXPORT gfx::ImageSkia GetImageForNonVirtualNetwork(
-    const NetworkIconState& network,
-    IconType icon_type,
-    bool badge_vpn,
-    bool* animating = nullptr);
-
-// Similar to above but for displaying only VPN icons, e.g. for the VPN menu
-// or Settings section.
-ASH_EXPORT gfx::ImageSkia GetImageForVPN(const NetworkIconState& vpn,
+// Gets the image for provided |network|. |network| must not be NULL.
+// |icon_type| determines the color theme and whether or not to show the VPN
+// badge. This caches badged icons per network per |icon_type|. |animating| is
+// an optional out parameter that is set to true when the returned image can be
+// animated.
+ASH_EXPORT gfx::ImageSkia GetImageForNetwork(
+    const chromeos::NetworkState* network,
                                          IconType icon_type,
                                          bool* animating = nullptr);
 
-// Returns an image for a Wi-Fi network, either full strength or strike-through
+// Gets an image for a Wi-Fi network, either full strength or strike-through
 // based on |enabled|.
 ASH_EXPORT gfx::ImageSkia GetImageForWiFiEnabledState(
     bool enabled,
     IconType = ICON_TYPE_DEFAULT_VIEW);
 
-// Returns the connecting image for a shill network non-VPN type.
-gfx::ImageSkia GetConnectingImageForNetworkType(NetworkType network_type,
-                                                IconType icon_type);
-
-// Returns the connected image for |connected_network| and |network_type| with a
-// connecting VPN badge.
-gfx::ImageSkia GetConnectedNetworkWithConnectingVpnImage(
-    const NetworkIconState& connected_network,
+// Gets the conneting image for a shill network type.
+gfx::ImageSkia GetConnectingImageForNetworkType(const std::string& network_type,
     IconType icon_type);
 
-// Returns the disconnected image for a shill network type.
-gfx::ImageSkia GetDisconnectedImageForNetworkType(NetworkType network_type);
+// Gets the disconnected image for a shill network type.
+gfx::ImageSkia GetDisconnectedImageForNetworkType(
+    const std::string& network_type);
 
-// Returns the full strength image for a Wi-Fi network using |icon_color| for
-// the main icon and |badge_color| for the badge.
+// Gets the full strength image for a Wi-Fi network using |icon_color| for the
+// main icon and |badge_color| for the badge.
 ASH_EXPORT gfx::ImageSkia GetImageForNewWifiNetwork(SkColor icon_color,
                                                     SkColor badge_color);
 
 // Returns the label for |network| based on |icon_type|. |network| cannot be
 // nullptr.
-ASH_EXPORT base::string16 GetLabelForNetwork(const NetworkIconState&,
+ASH_EXPORT base::string16 GetLabelForNetwork(
+    const chromeos::NetworkState* network,
                                              IconType icon_type);
 
-// Called periodically with the current list of network guids. Removes cached
-// entries that are no longer in the list.
-ASH_EXPORT void PurgeNetworkIconCache(
-    const std::set<std::string>& network_guids);
+// Updates and returns the appropriate message id if the cellular network
+// is uninitialized.
+ASH_EXPORT int GetCellularUninitializedMsg();
+
+// Gets the correct icon and label for |icon_type|. Also sets |animating|
+// based on whether or not the icon is animating (i.e. connecting).
+ASH_EXPORT void GetDefaultNetworkImageAndLabel(IconType icon_type,
+                                               gfx::ImageSkia* image,
+                                               base::string16* label,
+                                               bool* animating);
+
+// Called when the list of networks changes. Retreives the list of networks
+// from the global NetworkStateHandler instance and removes cached entries
+// that are no longer in the list.
+ASH_EXPORT void PurgeNetworkIconCache();
 
 // Called by ChromeVox to give a verbal indication of the network icon. Returns
 // the signal strength of |network|, if it is a network type with a signal
--- a/ash/system/network/network_icon_purger.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/network/network_icon_purger.cc	2019-05-17 18:53:08.312000000 +0300
@@ -9,41 +9,26 @@
 #include "chromeos/network/network_state_handler.h"
 
 using chromeos::NetworkHandler;
-using chromeos::NetworkStateHandler;
-
-namespace ash {
 
 namespace {
-
 const int kPurgeDelayMs = 300;
-
-void PurgeNetworkIconCache() {
-  NetworkStateHandler::NetworkStateList networks;
-  NetworkHandler::Get()->network_state_handler()->GetVisibleNetworkList(
-      &networks);
-  std::set<std::string> network_guids;
-  for (NetworkStateHandler::NetworkStateList::iterator iter = networks.begin();
-       iter != networks.end(); ++iter) {
-    network_guids.insert((*iter)->guid());
-  }
-  network_icon::PurgeNetworkIconCache(network_guids);
-}
-
 }  // namespace
 
+namespace ash {
+
 NetworkIconPurger::NetworkIconPurger() {
   // NetworkHandler may not be initialized in tests.
   if (NetworkHandler::IsInitialized()) {
-    NetworkHandler::Get()->network_state_handler()->AddObserver(this,
-                                                                FROM_HERE);
+    auto* network_handler = NetworkHandler::Get();
+    network_handler->network_state_handler()->AddObserver(this, FROM_HERE);
   }
 }
 
 NetworkIconPurger::~NetworkIconPurger() {
   // NetworkHandler may not be initialized in tests.
   if (NetworkHandler::IsInitialized()) {
-    NetworkHandler::Get()->network_state_handler()->RemoveObserver(this,
-                                                                   FROM_HERE);
+    auto* network_handler = NetworkHandler::Get();
+    network_handler->network_state_handler()->RemoveObserver(this, FROM_HERE);
   }
 }
 
@@ -51,7 +36,7 @@
   if (timer_.IsRunning())
     return;
   timer_.Start(FROM_HERE, base::TimeDelta::FromMilliseconds(kPurgeDelayMs),
-               base::BindOnce(&PurgeNetworkIconCache));
+               base::BindOnce(&network_icon::PurgeNetworkIconCache));
 }
 
 }  // namespace ash
--- a/ash/system/network/network_icon_unittest.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/network/network_icon_unittest.cc	2019-05-17 18:53:08.312000000 +0300
@@ -5,74 +5,80 @@
 #include "ash/system/network/network_icon.h"
 
 #include <memory>
-#include <set>
 
 #include "ash/strings/grit/ash_strings.h"
-#include "ash/system/network/active_network_icon.h"
 #include "base/logging.h"
 #include "base/message_loop/message_loop.h"
 #include "base/run_loop.h"
 #include "base/test/scoped_task_environment.h"
+#include "chromeos/dbus/dbus_thread_manager.h"
+#include "chromeos/dbus/shill_device_client.h"
+#include "chromeos/network/network_handler.h"
 #include "chromeos/network/network_state.h"
 #include "chromeos/network/network_state_handler.h"
-#include "chromeos/network/network_state_test_helper.h"
+#include "chromeos/network/network_state_test.h"
 #include "chromeos/network/tether_constants.h"
 #include "testing/gtest/include/gtest/gtest.h"
 #include "third_party/cros_system_api/dbus/shill/dbus-constants.h"
-#include "ui/base/l10n/l10n_util.h"
 #include "ui/gfx/image/image_unittest_util.h"
 
-// This tests both the helper functions in network_icon, and ActiveNetworkIcon
-// which is a primary consumer of the helper functions.
-
 namespace ash {
 
 namespace network_icon {
 
-class NetworkIconTest : public testing::Test {
+namespace {
+
+const char kShillManagerClientStubWifiDevice[] = "/device/stub_wifi_device1";
+const char kShillManagerClientStubCellularDevice[] =
+    "/device/stub_cellular_device1";
+
+}  // namespace
+
+class NetworkIconTest : public chromeos::NetworkStateTest {
  public:
   NetworkIconTest() = default;
   ~NetworkIconTest() override = default;
 
   void SetUp() override {
+    chromeos::DBusThreadManager::Initialize();
+    NetworkStateTest::SetUp();
     SetUpDefaultNetworkState();
-    active_network_icon_ = std::make_unique<ActiveNetworkIcon>();
-    active_network_icon_->InitForTesting(helper().network_state_handler());
+
+    chromeos::NetworkHandler::Initialize();
+    base::RunLoop().RunUntilIdle();
   }
 
   void TearDown() override {
-    active_network_icon_.reset();
-    PurgeNetworkIconCache(std::set<std::string>());
-  }
+    PurgeNetworkIconCache();
+    chromeos::NetworkHandler::Shutdown();
 
-  std::string ConfigureService(const std::string& shill_json_string) {
-    return helper_.ConfigureService(shill_json_string);
-  }
+    ShutdownNetworkState();
+    chromeos::NetworkStateTest::TearDown();
 
-  void SetServiceProperty(const std::string& service_path,
-                          const std::string& key,
-                          const base::Value& value) {
-    helper_.SetServiceProperty(service_path, key, value);
+    chromeos::DBusThreadManager::Shutdown();
   }
 
   void SetUpDefaultNetworkState() {
-    // NetworkStateTestHelper default has a wifi device only and no services.
+    base::RunLoop().RunUntilIdle();  // Process any pending updates
+    device_test_ = chromeos::DBusThreadManager::Get()
+                       ->GetShillDeviceClient()
+                       ->GetTestInterface();
+    ASSERT_TRUE(device_test_);
+    device_test_->ClearDevices();
+    device_test_->AddDevice(kShillManagerClientStubWifiDevice, shill::kTypeWifi,
+                            "stub_wifi_device1");
+    device_test_->AddDevice(kShillManagerClientStubCellularDevice,
+                            shill::kTypeCellular, "stub_cellular_device1");
 
-    helper_.device_test()->AddDevice("/device/stub_cellular_device",
-                                     shill::kTypeCellular,
-                                     "stub_cellular_device");
-    base::RunLoop().RunUntilIdle();
+    ClearDefaultServices();
 
     wifi1_path_ = ConfigureService(
         R"({"GUID": "wifi1_guid", "Type": "wifi", "State": "idle"})");
-    ASSERT_FALSE(wifi1_path_.empty());
     wifi2_path_ = ConfigureService(
         R"({"GUID": "wifi2_guid", "Type": "wifi", "State": "idle"})");
-    ASSERT_FALSE(wifi2_path_.empty());
     cellular_path_ = ConfigureService(
         R"({"GUID": "cellular_guid", "Type": "cellular", "Technology": "LTE",
             "State": "idle"})");
-    ASSERT_FALSE(cellular_path_.empty());
   }
 
   std::unique_ptr<chromeos::NetworkState> CreateStandaloneNetworkState(
@@ -80,8 +86,12 @@
       const std::string& type,
       const std::string& connection_state,
       int signal_strength) {
-    return helper_.CreateStandaloneNetworkState(id, type, connection_state,
-                                                signal_strength);
+    auto network = std::make_unique<chromeos::NetworkState>(id);
+    network->set_type(type);
+    network->set_visible(true);
+    network->set_connection_state(connection_state);
+    network->set_signal_strength(signal_strength);
+    return network;
   }
 
   std::unique_ptr<chromeos::NetworkState>
@@ -96,22 +106,9 @@
     return network;
   }
 
-  gfx::Image GetImageForNonVirtualNetwork(const chromeos::NetworkState* network,
-                                          bool badge_vpn) {
-    return gfx::Image(network_icon::GetImageForNonVirtualNetwork(
-        network_icon::NetworkIconState(network), icon_type_, badge_vpn));
-  }
-
   gfx::Image ImageForNetwork(const chromeos::NetworkState* network) {
-    return GetImageForNonVirtualNetwork(network, false /* show_vpn_badge */);
-  }
-
-  void GetDefaultNetworkImageAndLabel(IconType icon_type,
-                                      gfx::ImageSkia* image,
-                                      base::string16* label,
-                                      bool* animating) {
-    *image = active_network_icon_->GetSingleImage(icon_type, animating);
-    *label = active_network_icon_->GetDefaultLabel(icon_type);
+    gfx::ImageSkia image_skia = GetImageForNetwork(network, icon_type_);
+    return gfx::Image(image_skia);
   }
 
   // The icon for a Tether network should be the same as one for a cellular
@@ -122,7 +119,8 @@
   void GetAndCompareImagesByNetworkType(
       const chromeos::NetworkState* wifi_network,
       const chromeos::NetworkState* cellular_network,
-      const chromeos::NetworkState* tether_network) {
+      const chromeos::NetworkState* tether_network,
+      const chromeos::NetworkState* wifi_tether_network) {
     ASSERT_EQ(wifi_network->type(), shill::kTypeWifi);
     gfx::Image wifi_image = ImageForNetwork(wifi_network);
 
@@ -132,23 +130,41 @@
     ASSERT_EQ(tether_network->type(), chromeos::kTypeTether);
     gfx::Image tether_image = ImageForNetwork(tether_network);
 
+    ASSERT_EQ(wifi_tether_network->type(), shill::kTypeWifi);
+    ASSERT_FALSE(wifi_tether_network->tether_guid().empty());
+    gfx::Image wifi_tether_image = ImageForNetwork(wifi_tether_network);
+
     EXPECT_FALSE(gfx::test::AreImagesEqual(tether_image, wifi_image));
     EXPECT_FALSE(gfx::test::AreImagesEqual(cellular_image, wifi_image));
     EXPECT_TRUE(gfx::test::AreImagesEqual(tether_image, cellular_image));
+
+    EXPECT_TRUE(gfx::test::AreImagesEqual(tether_image, wifi_tether_image));
   }
 
   void SetCellularUnavailable() {
-    helper_.manager_test()->RemoveTechnology(shill::kTypeCellular);
+    test_manager_client()->RemoveTechnology(shill::kTypeCellular);
 
     base::RunLoop().RunUntilIdle();
 
     ASSERT_EQ(
         chromeos::NetworkStateHandler::TechnologyState::TECHNOLOGY_UNAVAILABLE,
-        helper_.network_state_handler()->GetTechnologyState(
+        network_state_handler()->GetTechnologyState(
             chromeos::NetworkTypePattern::Cellular()));
   }
 
-  chromeos::NetworkStateTestHelper& helper() { return helper_; }
+  void SetCellularUninitialized() {
+    test_manager_client()->RemoveTechnology(shill::kTypeCellular);
+    test_manager_client()->AddTechnology(shill::kTypeCellular, false);
+    test_manager_client()->SetTechnologyInitializing(shill::kTypeCellular,
+                                                     true);
+
+    base::RunLoop().RunUntilIdle();
+
+    ASSERT_EQ(chromeos::NetworkStateHandler::TechnologyState::
+                  TECHNOLOGY_UNINITIALIZED,
+              network_state_handler()->GetTechnologyState(
+                  chromeos::NetworkTypePattern::Cellular()));
+  }
 
   const std::string& wifi1_path() const { return wifi1_path_; }
   const std::string& wifi2_path() const { return wifi2_path_; }
@@ -156,19 +172,16 @@
 
   IconType icon_type_ = ICON_TYPE_TRAY_REGULAR;
 
+  chromeos::ShillDeviceClient::TestInterface* device_test_;
+
  private:
   const base::MessageLoop message_loop_;
 
-  chromeos::NetworkStateTestHelper helper_{
-      false /* use_default_devices_and_services */};
-
   // Preconfigured service paths:
   std::string wifi1_path_;
   std::string wifi2_path_;
   std::string cellular_path_;
 
-  std::unique_ptr<ActiveNetworkIcon> active_network_icon_;
-
   DISALLOW_COPY_AND_ASSIGN(NetworkIconTest);
 };
 
@@ -198,8 +211,13 @@
       CreateStandaloneNetworkState("tether", chromeos::kTypeTether,
                                    shill::kStateIdle, 50);
 
+  std::unique_ptr<chromeos::NetworkState> wifi_tether_network =
+      CreateStandaloneWifiTetherNetworkState("wifi_tether", "tether",
+                                             shill::kStateIdle, 50);
+
   GetAndCompareImagesByNetworkType(wifi_network.get(), cellular_network.get(),
-                                   tether_network.get());
+                                   tether_network.get(),
+                                   wifi_tether_network.get());
 }
 
 TEST_F(NetworkIconTest, CompareImagesByNetworkType_Connecting) {
@@ -215,8 +233,13 @@
       CreateStandaloneNetworkState("tether", chromeos::kTypeTether,
                                    shill::kStateAssociation, 50);
 
+  std::unique_ptr<chromeos::NetworkState> wifi_tether_network =
+      CreateStandaloneWifiTetherNetworkState("wifi_tether", "tether",
+                                             shill::kStateAssociation, 50);
+
   GetAndCompareImagesByNetworkType(wifi_network.get(), cellular_network.get(),
-                                   tether_network.get());
+                                   tether_network.get(),
+                                   wifi_tether_network.get());
 }
 
 TEST_F(NetworkIconTest, CompareImagesByNetworkType_Connected) {
@@ -232,8 +255,40 @@
       CreateStandaloneNetworkState("tether", chromeos::kTypeTether,
                                    shill::kStateOnline, 50);
 
+  std::unique_ptr<chromeos::NetworkState> wifi_tether_network =
+      CreateStandaloneWifiTetherNetworkState("wifi_tether", "tether",
+                                             shill::kStateOnline, 50);
+
   GetAndCompareImagesByNetworkType(wifi_network.get(), cellular_network.get(),
-                                   tether_network.get());
+                                   tether_network.get(),
+                                   wifi_tether_network.get());
+}
+
+TEST_F(NetworkIconTest,
+       GetCellularUninitializedMsg_NoUninitializedMessageExpected) {
+  EXPECT_EQ(0, GetCellularUninitializedMsg());
+}
+
+TEST_F(NetworkIconTest, GetCellularUninitializedMsg_CellularUninitialized) {
+  SetCellularUninitialized();
+
+  EXPECT_EQ(IDS_ASH_STATUS_TRAY_INITIALIZING_CELLULAR,
+            GetCellularUninitializedMsg());
+}
+
+TEST_F(NetworkIconTest, GetCellularUninitializedMsg_CellularScanning) {
+  SetCellularUninitialized();
+
+  test_manager_client()->AddTechnology(shill::kTypeCellular, true);
+
+  device_test_->SetDeviceProperty(kShillManagerClientStubCellularDevice,
+                                  shill::kScanningProperty, base::Value(true),
+                                  /*notify_changed=*/true);
+  base::RunLoop().RunUntilIdle();
+  ASSERT_TRUE(network_state_handler()->GetScanningByType(
+      chromeos::NetworkTypePattern::Cellular()));
+
+  EXPECT_EQ(IDS_ASH_STATUS_TRAY_MOBILE_SCANNING, GetCellularUninitializedMsg());
 }
 
 TEST_F(NetworkIconTest, NetworkSignalStrength) {
@@ -247,7 +302,7 @@
       CreateStandaloneNetworkState("wifi", shill::kTypeWifi,
                                    shill::kStateOnline, 50);
 
-  // Verify non-wireless network types return SignalStrength::NOT_WIRELESS, and
+  // Verify non-wirless network types return SignalStrength::NOT_WIRELESS, and
   // wireless network types return something other than
   // SignalStrength::NOT_WIRELESS.
   EXPECT_EQ(ss::NOT_WIRELESS,
@@ -283,8 +338,8 @@
   gfx::ImageSkia default_image;
   base::string16 label;
   bool animating = false;
-  GetDefaultNetworkImageAndLabel(icon_type_, &default_image, &label,
-                                 &animating);
+  ash::network_icon::GetDefaultNetworkImageAndLabel(icon_type_, &default_image,
+                                                    &label, &animating);
   ASSERT_FALSE(default_image.isNull());
   EXPECT_FALSE(animating);
 
@@ -305,8 +360,8 @@
   gfx::ImageSkia default_image;
   base::string16 label;
   bool animating = false;
-  GetDefaultNetworkImageAndLabel(icon_type_, &default_image, &label,
-                                 &animating);
+  ash::network_icon::GetDefaultNetworkImageAndLabel(icon_type_, &default_image,
+                                                    &label, &animating);
   ASSERT_FALSE(default_image.isNull());
   EXPECT_TRUE(animating);
 
@@ -340,8 +395,8 @@
   gfx::ImageSkia default_image;
   base::string16 label;
   bool animating = false;
-  GetDefaultNetworkImageAndLabel(icon_type_, &default_image, &label,
-                                 &animating);
+  ash::network_icon::GetDefaultNetworkImageAndLabel(icon_type_, &default_image,
+                                                    &label, &animating);
   ASSERT_FALSE(default_image.isNull());
   EXPECT_FALSE(animating);
 
@@ -377,8 +432,8 @@
   // Verify that the default network is connecting icon for the initial default
   // network (even though the default network as reported by shill actually
   // changed).
-  GetDefaultNetworkImageAndLabel(icon_type_, &default_image, &label,
-                                 &animating);
+  ash::network_icon::GetDefaultNetworkImageAndLabel(icon_type_, &default_image,
+                                                    &label, &animating);
   ASSERT_FALSE(default_image.isNull());
   EXPECT_TRUE(animating);
 
@@ -401,8 +456,8 @@
   std::unique_ptr<chromeos::NetworkState> reference_network_2 =
       CreateStandaloneNetworkState("reference2", shill::kTypeCellular,
                                    shill::kStateOnline, 65);
-  GetDefaultNetworkImageAndLabel(icon_type_, &default_image, &label,
-                                 &animating);
+  ash::network_icon::GetDefaultNetworkImageAndLabel(icon_type_, &default_image,
+                                                    &label, &animating);
   ASSERT_FALSE(default_image.isNull());
   EXPECT_FALSE(animating);
 
@@ -417,8 +472,8 @@
   std::unique_ptr<chromeos::NetworkState> reference_network_3 =
       CreateStandaloneNetworkState("reference3", shill::kTypeWifi,
                                    shill::kStateOnline, 45);
-  GetDefaultNetworkImageAndLabel(icon_type_, &default_image, &label,
-                                 &animating);
+  ash::network_icon::GetDefaultNetworkImageAndLabel(icon_type_, &default_image,
+                                                    &label, &animating);
   ASSERT_FALSE(default_image.isNull());
   EXPECT_FALSE(animating);
 
@@ -445,8 +500,8 @@
   gfx::ImageSkia default_image;
   base::string16 label;
   bool animating = false;
-  GetDefaultNetworkImageAndLabel(icon_type_, &default_image, &label,
-                                 &animating);
+  ash::network_icon::GetDefaultNetworkImageAndLabel(icon_type_, &default_image,
+                                                    &label, &animating);
   ASSERT_FALSE(default_image.isNull());
   EXPECT_FALSE(animating);
 
@@ -482,8 +537,8 @@
   // another network connected and used as default.
   // TODO(tbarzic): Consider changing network icon logic to use a connected
   //     network icon if a network is connected while a network is reconnecting.
-  GetDefaultNetworkImageAndLabel(icon_type_, &default_image, &label,
-                                 &animating);
+  ash::network_icon::GetDefaultNetworkImageAndLabel(icon_type_, &default_image,
+                                                    &label, &animating);
   ASSERT_FALSE(default_image.isNull());
   EXPECT_TRUE(animating);
 
@@ -498,8 +553,8 @@
   SetServiceProperty(cellular_path(), shill::kStateProperty,
                      base::Value(shill::kStateReady));
 
-  GetDefaultNetworkImageAndLabel(icon_type_, &default_image, &label,
-                                 &animating);
+  ash::network_icon::GetDefaultNetworkImageAndLabel(icon_type_, &default_image,
+                                                    &label, &animating);
   ASSERT_FALSE(default_image.isNull());
   EXPECT_FALSE(animating);
   std::unique_ptr<chromeos::NetworkState> reference_network_2 =
@@ -513,8 +568,8 @@
   SetServiceProperty(cellular_path(), shill::kStateProperty,
                      base::Value(shill::kStateOnline));
 
-  GetDefaultNetworkImageAndLabel(icon_type_, &default_image, &label,
-                                 &animating);
+  ash::network_icon::GetDefaultNetworkImageAndLabel(icon_type_, &default_image,
+                                                    &label, &animating);
   ASSERT_FALSE(default_image.isNull());
   EXPECT_FALSE(animating);
   EXPECT_TRUE(gfx::test::AreImagesEqual(
@@ -523,7 +578,7 @@
 
 // Tests that the default network image shows a cellular network icon if
 // cellular network is connected while wifi is connecting.
-TEST_F(NetworkIconTest, DefaultImageConnectingToWifiWhileCellularConnected) {
+TEST_F(NetworkIconTest, DefaultImageConnectingToWifiWileCellularConnected) {
   // Connect cellular network, and set the wifi as connecting.
   SetServiceProperty(wifi1_path(), shill::kSignalStrengthProperty,
                      base::Value(45));
@@ -538,8 +593,8 @@
   gfx::ImageSkia default_image;
   base::string16 label;
   bool animating = false;
-  GetDefaultNetworkImageAndLabel(icon_type_, &default_image, &label,
-                                 &animating);
+  ash::network_icon::GetDefaultNetworkImageAndLabel(icon_type_, &default_image,
+                                                    &label, &animating);
   ASSERT_FALSE(default_image.isNull());
   EXPECT_FALSE(animating);
 
@@ -550,7 +605,7 @@
       gfx::Image(default_image), ImageForNetwork(reference_network.get())));
 }
 
-// Test that a connecting cellular icon is displayed when activating a cellular
+// Test that a cellular icon is displayed when activating cellular
 // network (if other networks are not connected).
 TEST_F(NetworkIconTest, DefaultNetworkImageActivatingCellularNetwork) {
   SetServiceProperty(cellular_path(), shill::kSignalStrengthProperty,
@@ -561,8 +616,8 @@
   gfx::ImageSkia default_image;
   base::string16 label;
   bool animating = false;
-  GetDefaultNetworkImageAndLabel(icon_type_, &default_image, &label,
-                                 &animating);
+  ash::network_icon::GetDefaultNetworkImageAndLabel(icon_type_, &default_image,
+                                                    &label, &animating);
   ASSERT_FALSE(default_image.isNull());
   EXPECT_FALSE(animating);
 
@@ -590,8 +645,8 @@
   gfx::ImageSkia default_image;
   base::string16 label;
   bool animating = false;
-  GetDefaultNetworkImageAndLabel(icon_type_, &default_image, &label,
-                                 &animating);
+  ash::network_icon::GetDefaultNetworkImageAndLabel(icon_type_, &default_image,
+                                                    &label, &animating);
   ASSERT_FALSE(default_image.isNull());
   EXPECT_FALSE(animating);
 
@@ -602,77 +657,6 @@
       gfx::Image(default_image), ImageForNetwork(reference_network.get())));
 }
 
-// Tests VPN badging for the default network.
-TEST_F(NetworkIconTest, DefaultNetworkVpnBadge) {
-  gfx::ImageSkia default_image;
-  base::string16 label;
-  bool animating = false;
-
-  // Set up initial state with Ethernet and WiFi connected.
-  std::string ethernet_path = ConfigureService(
-      R"({"GUID": "ethernet_guid", "Type": "ethernet", "State": "online"})");
-  ASSERT_FALSE(ethernet_path.empty());
-  // Wifi1 is set up by default but not connected. Also set its strength.
-  SetServiceProperty(wifi1_path(), shill::kStateProperty,
-                     base::Value(shill::kStateOnline));
-  SetServiceProperty(wifi1_path(), shill::kSignalStrengthProperty,
-                     base::Value(45));
-
-  // With Ethernet and WiFi connected, the default icon should be empty.
-  GetDefaultNetworkImageAndLabel(icon_type_, &default_image, &label,
-                                 &animating);
-  ASSERT_TRUE(default_image.isNull());
-  EXPECT_FALSE(animating);
-
-  // Add a connected VPN.
-  std::string vpn_path = ConfigureService(
-      R"({"GUID": "vpn_guid", "Type": "vpn", "State": "online"})");
-  ASSERT_FALSE(vpn_path.empty());
-
-  // When a VPN is connected, the default icon should be Ethernet with a badge.
-  GetDefaultNetworkImageAndLabel(icon_type_, &default_image, &label,
-                                 &animating);
-  ASSERT_FALSE(default_image.isNull());
-  EXPECT_FALSE(animating);
-
-  std::unique_ptr<chromeos::NetworkState> reference_eth =
-      CreateStandaloneNetworkState("reference_eth", shill::kTypeEthernet,
-                                   shill::kStateOnline, 0);
-  gfx::Image reference_eth_unbadged = GetImageForNonVirtualNetwork(
-      reference_eth.get(), false /* show_vpn_badge */);
-  gfx::Image reference_eth_badged = GetImageForNonVirtualNetwork(
-      reference_eth.get(), true /* show_vpn_badge */);
-
-  EXPECT_FALSE(gfx::test::AreImagesEqual(gfx::Image(default_image),
-                                         reference_eth_unbadged));
-  EXPECT_TRUE(gfx::test::AreImagesEqual(gfx::Image(default_image),
-                                        reference_eth_badged));
-
-  // Disconnect Ethernet. The default icon should become WiFi with a badge.
-  SetServiceProperty(ethernet_path, shill::kStateProperty,
-                     base::Value(shill::kStateIdle));
-  GetDefaultNetworkImageAndLabel(icon_type_, &default_image, &label,
-                                 &animating);
-  ASSERT_FALSE(default_image.isNull());
-  EXPECT_FALSE(animating);
-
-  std::unique_ptr<chromeos::NetworkState> reference_wifi =
-      CreateStandaloneNetworkState("reference_wifi", shill::kTypeWifi,
-                                   shill::kStateOnline, 45);
-  gfx::Image reference_wifi_badged = GetImageForNonVirtualNetwork(
-      reference_wifi.get(), true /* show_vpn_badge */);
-  EXPECT_TRUE(gfx::test::AreImagesEqual(gfx::Image(default_image),
-                                        reference_wifi_badged));
-
-  // Set the VPN to connecting; the default icon should be animating.
-  SetServiceProperty(vpn_path, shill::kStateProperty,
-                     base::Value(shill::kStateAssociation));
-  GetDefaultNetworkImageAndLabel(icon_type_, &default_image, &label,
-                                 &animating);
-  ASSERT_FALSE(default_image.isNull());
-  EXPECT_TRUE(animating);
-}
-
 // Tests that wifi image is shown when connecting to wifi network with vpn.
 TEST_F(NetworkIconTest, DefaultNetworkImageVpnAndWifi) {
   SetServiceProperty(wifi1_path(), shill::kSignalStrengthProperty,
@@ -687,8 +671,8 @@
   gfx::ImageSkia default_image;
   base::string16 label;
   bool animating = false;
-  GetDefaultNetworkImageAndLabel(icon_type_, &default_image, &label,
-                                 &animating);
+  ash::network_icon::GetDefaultNetworkImageAndLabel(icon_type_, &default_image,
+                                                    &label, &animating);
   ASSERT_FALSE(default_image.isNull());
   EXPECT_TRUE(animating);
 
@@ -714,8 +698,8 @@
   gfx::ImageSkia default_image;
   base::string16 label;
   bool animating = false;
-  GetDefaultNetworkImageAndLabel(icon_type_, &default_image, &label,
-                                 &animating);
+  ash::network_icon::GetDefaultNetworkImageAndLabel(icon_type_, &default_image,
+                                                    &label, &animating);
   ASSERT_FALSE(default_image.isNull());
   EXPECT_TRUE(animating);
 
--- a/ash/system/network/network_list.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/network/network_list.cc	2019-05-17 18:53:08.312000000 +0300
@@ -115,20 +115,19 @@
   SCOPED_NET_LOG_IF_SLOW();
   NetworkStateHandler* handler = NetworkHandler::Get()->network_state_handler();
 
+  // First, update state for all networks.
   bool animating = false;
+
   for (auto& info : network_list_) {
     const chromeos::NetworkState* network =
         handler->GetNetworkStateFromGuid(info->guid);
     if (!network)
       continue;
     bool prohibited_by_policy = network->blocked_by_policy();
-    network_icon::NetworkIconState network_icon_state(network);
     info->label = network_icon::GetLabelForNetwork(
-        network_icon_state, network_icon::ICON_TYPE_MENU_LIST);
-    // |network_list_| only contains non virtual networks.
-    info->image = network_icon::GetImageForNonVirtualNetwork(
-        network_icon_state, network_icon::ICON_TYPE_LIST,
-        false /* badge_vpn */);
+        network, network_icon::ICON_TYPE_MENU_LIST);
+    info->image =
+        network_icon::GetImageForNetwork(network, network_icon::ICON_TYPE_LIST);
     info->disable =
         (network->activation_state() == shill::kActivationStateActivating) ||
         prohibited_by_policy;
--- a/ash/system/network/network_section_header_view.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/network/network_section_header_view.cc	2019-05-17 18:53:08.312000000 +0300
@@ -12,7 +12,6 @@
 #include "ash/system/model/system_tray_model.h"
 #include "ash/system/network/network_icon.h"
 #include "ash/system/unified/top_shortcut_button.h"
-#include "base/bind.h"
 #include "chromeos/network/device_state.h"
 #include "chromeos/strings/grit/chromeos_strings.h"
 #include "components/vector_icons/vector_icons.h"
--- a/ash/system/network/network_section_header_view.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/network/network_section_header_view.h	2019-05-17 18:53:08.312000000 +0300
@@ -8,7 +8,6 @@
 #include "ash/system/network/network_row_title_view.h"
 #include "ash/system/tray/tray_popup_utils.h"
 #include "ash/system/tray/tri_view.h"
-#include "base/timer/timer.h"
 #include "chromeos/network/network_state_handler.h"
 #include "ui/views/controls/button/toggle_button.h"
 #include "ui/views/layout/fill_layout.h"
--- a/ash/system/network/network_state_list_detailed_view.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/network/network_state_list_detailed_view.cc	2019-05-17 18:53:08.312000000 +0300
@@ -244,14 +244,12 @@
       NetworkHandler::Get()->network_state_handler()->GetNetworkStateFromGuid(
           guid);
   bool can_connect = network && !network->IsConnectingOrConnected();
-  if (network) {
     if (network->IsDefaultCellular())
       can_connect = false;  // Default Cellular network is not connectable.
     if (!network->connectable() && IsSecondaryUser()) {
       // Secondary users can only connect to fully configured networks.
       can_connect = false;
     }
-  }
   if (can_connect) {
     Shell::Get()->metrics()->RecordUserMetricsAction(
         list_type_ == LIST_TYPE_VPN
--- a/ash/system/network/network_tray_icon_strategy.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/network/network_tray_icon_strategy.cc	2019-05-17 18:53:08.312000000 +0300
@@ -6,26 +6,51 @@
 
 #include "ash/session/session_controller.h"
 #include "ash/shell.h"
-#include "ash/system/model/system_tray_model.h"
-#include "ash/system/network/active_network_icon.h"
 #include "ash/system/network/network_icon.h"
 #include "base/logging.h"
+#include "chromeos/network/network_connection_handler.h"
 #include "chromeos/network/network_state.h"
 #include "chromeos/network/network_state_handler.h"
 #include "third_party/cros_system_api/dbus/service_constants.h"
 #include "ui/gfx/image/image_skia.h"
 
-using chromeos::NetworkConnectionHandler;
 using chromeos::NetworkHandler;
 using chromeos::NetworkState;
 using chromeos::NetworkStateHandler;
 using chromeos::NetworkTypePattern;
+using chromeos::NetworkConnectionHandler;
 
 namespace ash {
 namespace tray {
 
 namespace {
 
+const NetworkState* GetConnectingOrConnectedNetwork(
+    NetworkTypePattern pattern) {
+  NetworkStateHandler* state_handler =
+      NetworkHandler::Get()->network_state_handler();
+  NetworkConnectionHandler* connect_handler =
+      NetworkHandler::Get()->network_connection_handler();
+  const NetworkState* connecting_network =
+      state_handler->ConnectingNetworkByType(pattern);
+  const NetworkState* connected_network =
+      state_handler->ConnectedNetworkByType(pattern);
+  // If we are connecting to a network, and there is either no connected
+  // network, or the connection was user requested, or shill triggered a
+  // reconnection, use the connecting network.
+  if (connecting_network &&
+      (!connected_network || connecting_network->IsReconnecting() ||
+       connect_handler->HasConnectingNetwork(connecting_network->path()))) {
+    return connecting_network;
+  }
+  return connected_network;
+}
+
+bool NetworkTypeEnabled(NetworkTypePattern pattern) {
+  return NetworkHandler::Get()->network_state_handler()->IsTechnologyEnabled(
+      pattern);
+}
+
 // OOBE has a white background that makes regular tray icons not visible.
 network_icon::IconType GetIconType() {
   if (Shell::Get()->session_controller()->GetSessionState() ==
@@ -38,24 +63,49 @@
 }  // namespace
 
 gfx::ImageSkia DefaultNetworkTrayIconStrategy::GetNetworkIcon(bool* animating) {
-  return Shell::Get()
-      ->system_tray_model()
-      ->active_network_icon()
-      ->GetDualImagePrimary(GetIconType(), animating);
+  if (!NetworkTypeEnabled(NetworkTypePattern::WiFi()))
+    return gfx::ImageSkia();
+
+  auto icon_type = GetIconType();
+  const NetworkState* network =
+      GetConnectingOrConnectedNetwork(NetworkTypePattern::WiFi());
+  if (network) {
+    return network_icon::GetImageForNetwork(network, icon_type, animating);
+  }
+  *animating = false;
+  return network_icon::GetDisconnectedImageForNetworkType(shill::kTypeWifi);
 }
 
 gfx::ImageSkia MobileNetworkTrayIconStrategy::GetNetworkIcon(bool* animating) {
-  return Shell::Get()
-      ->system_tray_model()
-      ->active_network_icon()
-      ->GetDualImageCellular(GetIconType(), animating);
+  if (!NetworkTypeEnabled(NetworkTypePattern::Mobile()))
+    return gfx::ImageSkia();
+
+  auto icon_type = GetIconType();
+  // Check if we are initializing a mobile network.
+  if (network_icon::GetCellularUninitializedMsg()) {
+    *animating = true;
+    return network_icon::GetConnectingImageForNetworkType(shill::kTypeCellular,
+                                                          icon_type);
+  }
+
+  const NetworkState* network =
+      NetworkHandler::Get()->network_state_handler()->FirstNetworkByType(
+          NetworkTypePattern::Mobile());
+
+  if (network && network->IsConnectingOrConnected()) {
+    return network_icon::GetImageForNetwork(network, icon_type, animating);
+  }
+
+  *animating = false;
+  return network_icon::GetDisconnectedImageForNetworkType(shill::kTypeCellular);
 }
 
 gfx::ImageSkia SingleNetworkTrayIconStrategy::GetNetworkIcon(bool* animating) {
-  return Shell::Get()
-      ->system_tray_model()
-      ->active_network_icon()
-      ->GetSingleImage(GetIconType(), animating);
+  auto icon_type = GetIconType();
+  gfx::ImageSkia image;
+  network_icon::GetDefaultNetworkImageAndLabel(icon_type, &image,
+                                               /*label=*/nullptr, animating);
+  return image;
 }
 
 }  // namespace tray
--- a/ash/system/network/tray_network_state_observer.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/network/tray_network_state_observer.cc	2019-05-17 18:53:08.312000000 +0300
@@ -7,7 +7,6 @@
 #include <set>
 #include <string>
 
-#include "base/bind.h"
 #include "base/location.h"
 #include "chromeos/network/network_state.h"
 #include "chromeos/network/network_state_handler.h"
@@ -30,20 +29,26 @@
 namespace ash {
 
 TrayNetworkStateObserver::TrayNetworkStateObserver(Delegate* delegate)
-    : delegate_(delegate), update_frequency_(kUpdateFrequencyMs) {
+    : delegate_(delegate),
+      update_frequency_(kUpdateFrequencyMs) {
   if (ui::ScopedAnimationDurationScaleMode::duration_scale_mode() !=
       ui::ScopedAnimationDurationScaleMode::NORMAL_DURATION) {
     update_frequency_ = 0;  // Send updates immediately for tests.
   }
-  // TODO(mash): Figure out what to do about NetworkHandler.
+  // TODO(mash): Figure out what to do about NetworkHandler and
+  // NetworkPortalDetector.
   if (NetworkHandler::IsInitialized()) {
     NetworkHandler::Get()->network_state_handler()->AddObserver(this,
                                                                 FROM_HERE);
     wifi_enabled_ = IsWifiEnabled();
   }
+  if (chromeos::network_portal_detector::IsInitialized())
+    chromeos::network_portal_detector::GetInstance()->AddObserver(this);
 }
 
 TrayNetworkStateObserver::~TrayNetworkStateObserver() {
+  if (chromeos::network_portal_detector::IsInitialized())
+    chromeos::network_portal_detector::GetInstance()->RemoveObserver(this);
   if (NetworkHandler::IsInitialized()) {
     NetworkHandler::Get()->network_state_handler()->RemoveObserver(this,
                                                                    FROM_HERE);
@@ -58,8 +63,18 @@
   SignalUpdate(false /* notify_a11y */);
 }
 
-void TrayNetworkStateObserver::ActiveNetworksChanged(
-    const std::vector<const chromeos::NetworkState*>& active_networks) {
+// Any change to the Default (primary connected) network, including Strength
+// changes, should trigger a NetworkStateChanged update.
+void TrayNetworkStateObserver::DefaultNetworkChanged(
+    const chromeos::NetworkState* network) {
+  SignalUpdate(true /* notify_a11y */);
+}
+
+// Any change to the Connection State should trigger a NetworkStateChanged
+// update. This is important when both a VPN and a physical network are
+// connected.
+void TrayNetworkStateObserver::NetworkConnectionStateChanged(
+    const chromeos::NetworkState* network) {
   SignalUpdate(true /* notify_a11y */);
 }
 
@@ -71,10 +86,10 @@
   SignalUpdate(false /* notify_a11y */);
 }
 
-// Required to propagate changes to the "scanning" property of DeviceStates.
-void TrayNetworkStateObserver::DevicePropertiesUpdated(
-    const chromeos::DeviceState* device) {
-  SignalUpdate(false /* notify_a11y */);
+void TrayNetworkStateObserver::OnPortalDetectionCompleted(
+    const chromeos::NetworkState* network,
+    const chromeos::NetworkPortalDetector::CaptivePortalState& state) {
+  SignalUpdate(true /* notify_a11y */);
 }
 
 void TrayNetworkStateObserver::SignalUpdate(bool notify_a11y) {
--- a/ash/system/network/tray_network_state_observer.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/network/tray_network_state_observer.h	2019-05-17 18:53:08.312000000 +0300
@@ -5,15 +5,16 @@
 #ifndef ASH_SYSTEM_NETWORK_TRAY_NETWORK_STATE_OBSERVER_H_
 #define ASH_SYSTEM_NETWORK_TRAY_NETWORK_STATE_OBSERVER_H_
 
-#include <vector>
-
 #include "base/macros.h"
 #include "base/timer/timer.h"
 #include "chromeos/network/network_state_handler_observer.h"
+#include "chromeos/network/portal_detector/network_portal_detector.h"
 
 namespace ash {
 
-class TrayNetworkStateObserver : public chromeos::NetworkStateHandlerObserver {
+class TrayNetworkStateObserver
+    : public chromeos::NetworkStateHandlerObserver,
+      public chromeos::NetworkPortalDetector::Observer {
  public:
   class Delegate {
    public:
@@ -32,10 +33,16 @@
   // NetworkStateHandlerObserver
   void NetworkListChanged() override;
   void DeviceListChanged() override;
-  void ActiveNetworksChanged(const std::vector<const chromeos::NetworkState*>&
-                                 active_networks) override;
+  void DefaultNetworkChanged(const chromeos::NetworkState* network) override;
+  void NetworkConnectionStateChanged(
+      const chromeos::NetworkState* network) override;
   void NetworkPropertiesUpdated(const chromeos::NetworkState* network) override;
-  void DevicePropertiesUpdated(const chromeos::DeviceState* device) override;
+
+  // NetworkPortalDetector::Observer
+  void OnPortalDetectionCompleted(
+      const chromeos::NetworkState* network,
+      const chromeos::NetworkPortalDetector::CaptivePortalState& state)
+      override;
 
  private:
   void SignalUpdate(bool notify_a11y);
--- a/ash/system/network/vpn_list_view.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/network/vpn_list_view.cc	2019-05-17 18:53:08.316000000 +0300
@@ -8,9 +8,7 @@
 #include <vector>
 
 #include "ash/metrics/user_metrics_recorder.h"
-#include "ash/public/cpp/ash_pref_names.h"
 #include "ash/resources/vector_icons/vector_icons.h"
-#include "ash/session/session_controller.h"
 #include "ash/shell.h"
 #include "ash/strings/grit/ash_strings.h"
 #include "ash/system/model/system_tray_model.h"
@@ -30,8 +28,6 @@
 #include "chromeos/network/network_state.h"
 #include "chromeos/network/network_type_pattern.h"
 #include "components/onc/onc_constants.h"
-#include "components/prefs/pref_registry_simple.h"
-#include "components/prefs/pref_service.h"
 #include "third_party/cros_system_api/dbus/service_constants.h"
 #include "ui/base/l10n/l10n_util.h"
 #include "ui/gfx/image/image_skia.h"
@@ -45,11 +41,6 @@
 #include "ui/views/layout/fill_layout.h"
 #include "ui/views/view.h"
 
-using chromeos::NetworkHandler;
-using chromeos::NetworkState;
-using chromeos::NetworkStateHandler;
-using chromeos::NetworkTypePattern;
-
 namespace ash {
 namespace tray {
 namespace {
@@ -62,8 +53,8 @@
 
 // Indicates whether |network| belongs to this VPN provider.
 bool VpnProviderMatchesNetwork(const VPNProvider& provider,
-                               const NetworkState& network) {
-  const NetworkState::VpnProviderInfo* network_vpn_provider =
+                               const chromeos::NetworkState& network) {
+  const chromeos::NetworkState::VpnProviderInfo* network_vpn_provider =
       network.vpn_provider();
   // Never display non-VPN networks or VPNs with no provider info.
   if (network.type() != shill::kTypeVPN || !network_vpn_provider)
@@ -81,21 +72,6 @@
   }
 }
 
-// Returns the PrefService that should be used for kVpnConfigAllowed, which is
-// controlled by policy. If multiple users are logged in, the more restrictive
-// policy is most likely in the primary user.
-PrefService* GetPrefService() {
-  SessionController* controller = Shell::Get()->session_controller();
-  PrefService* prefs = controller->GetPrimaryUserPrefService();
-  return prefs ? prefs : controller->GetActivePrefService();
-}
-
-bool IsVpnConfigAllowed() {
-  PrefService* prefs = GetPrefService();
-  DCHECK(prefs);
-  return prefs->GetBoolean(prefs::kVpnConfigAllowed);
-}
-
 // A list entry that represents a VPN provider.
 class VPNListProviderEntry : public views::ButtonListener, public views::View {
  public:
@@ -163,7 +139,8 @@
 class VPNListNetworkEntry : public HoverHighlightView,
                             public network_icon::AnimationObserver {
  public:
-  VPNListNetworkEntry(VPNListView* vpn_list_view, const NetworkState* network);
+  VPNListNetworkEntry(VPNListView* vpn_list_view,
+                      const chromeos::NetworkState* network);
   ~VPNListNetworkEntry() override;
 
   // network_icon::AnimationObserver:
@@ -173,7 +150,7 @@
   void ButtonPressed(Button* sender, const ui::Event& event) override;
 
  private:
-  void UpdateFromNetworkState(const NetworkState* network);
+  void UpdateFromNetworkState(const chromeos::NetworkState* network);
 
   VPNListView* const owner_;
   const std::string guid_;
@@ -184,7 +161,7 @@
 };
 
 VPNListNetworkEntry::VPNListNetworkEntry(VPNListView* owner,
-                                         const NetworkState* network)
+                                         const chromeos::NetworkState* network)
     : HoverHighlightView(owner), owner_(owner), guid_(network->guid()) {
   UpdateFromNetworkState(network);
 }
@@ -194,9 +171,9 @@
 }
 
 void VPNListNetworkEntry::NetworkIconChanged() {
-  UpdateFromNetworkState(
-      NetworkHandler::Get()->network_state_handler()->GetNetworkStateFromGuid(
-          guid_));
+  UpdateFromNetworkState(chromeos::NetworkHandler::Get()
+                             ->network_state_handler()
+                             ->GetNetworkStateFromGuid(guid_));
 }
 
 void VPNListNetworkEntry::ButtonPressed(Button* sender,
@@ -209,39 +186,37 @@
   chromeos::NetworkConnect::Get()->DisconnectFromNetworkId(guid_);
 }
 
-void VPNListNetworkEntry::UpdateFromNetworkState(const NetworkState* vpn) {
-  if (vpn && vpn->IsConnectingState())
+void VPNListNetworkEntry::UpdateFromNetworkState(
+    const chromeos::NetworkState* network) {
+  if (network && network->IsConnectingState())
     network_icon::NetworkIconAnimation::GetInstance()->AddObserver(this);
   else
     network_icon::NetworkIconAnimation::GetInstance()->RemoveObserver(this);
 
-  if (!vpn) {
-    // This is a transient state where the vpn has been removed already but
+  if (!network) {
+    // This is a transient state where the network has been removed already but
     // the network list in the UI has not been updated yet.
     return;
   }
   Reset();
   disconnect_button_ = nullptr;
 
-  network_icon::NetworkIconState vpn_icon_state(vpn);
-  gfx::ImageSkia image = network_icon::GetImageForVPN(
-      vpn_icon_state, network_icon::ICON_TYPE_LIST);
+  gfx::ImageSkia image =
+      network_icon::GetImageForNetwork(network, network_icon::ICON_TYPE_LIST);
   base::string16 label = network_icon::GetLabelForNetwork(
-      vpn_icon_state, network_icon::ICON_TYPE_MENU_LIST);
+      network, network_icon::ICON_TYPE_MENU_LIST);
   AddIconAndLabel(image, label);
-  if (vpn->IsConnectedState()) {
+  if (network->IsConnectedState()) {
     owner_->SetupConnectedScrollListItem(this);
-    if (IsVpnConfigAllowed()) {
       disconnect_button_ = TrayPopupUtils::CreateTrayPopupButton(
           this, l10n_util::GetStringUTF16(IDS_ASH_STATUS_TRAY_VPN_DISCONNECT));
       AddRightView(disconnect_button_);
-    }
     tri_view()->SetContainerBorder(
         TriView::Container::END,
         views::CreateEmptyBorder(
             0, kTrayPopupButtonEndMargin - kTrayPopupLabelHorizontalPadding, 0,
             kTrayPopupButtonEndMargin));
-  } else if (vpn->IsConnectingState()) {
+  } else if (network->IsConnectingState()) {
     owner_->SetupConnectingScrollListItem(this);
   }
 
@@ -288,9 +263,11 @@
   list_empty_ = true;
 
   // Get the list of available VPN networks, in shill's priority order.
-  NetworkStateHandler::NetworkStateList networks;
-  NetworkHandler::Get()->network_state_handler()->GetVisibleNetworkListByType(
-      NetworkTypePattern::VPN(), &networks);
+  chromeos::NetworkStateHandler::NetworkStateList networks;
+  chromeos::NetworkHandler::Get()
+      ->network_state_handler()
+      ->GetVisibleNetworkListByType(chromeos::NetworkTypePattern::VPN(),
+                                    &networks);
 
   // Show all VPN providers and all networks that are currently disconnected.
   AddProvidersAndNetworks(networks);
@@ -339,25 +316,16 @@
   UpdateNetworkList();
 }
 
-void VPNListView::RegisterProfilePrefs(PrefRegistrySimple* registry) {
-  registry->RegisterBooleanPref(prefs::kVpnConfigAllowed, true,
-                                PrefRegistry::PUBLIC);
-}
-
-void VPNListView::AddNetwork(const NetworkState* network) {
+void VPNListView::AddNetwork(const chromeos::NetworkState* network) {
   views::View* entry(new VPNListNetworkEntry(this, network));
   scroll_content()->AddChildView(entry);
   network_view_guid_map_[entry] = network->guid();
   list_empty_ = false;
 }
 
-void VPNListView::AddProviderAndNetworks(const VPNProvider& vpn_provider) {
-  AddProviderAndNetworks(vpn_provider, NetworkStateHandler::NetworkStateList());
-}
-
 void VPNListView::AddProviderAndNetworks(
     const VPNProvider& vpn_provider,
-    const NetworkStateHandler::NetworkStateList& networks) {
+    const chromeos::NetworkStateHandler::NetworkStateList& networks) {
   // Add a visual separator, unless this is the topmost entry in the list.
   if (!list_empty_) {
     scroll_content()->AddChildView(CreateListSubHeaderSeparator());
@@ -376,29 +344,14 @@
   list_empty_ = false;
   // Add the networks belonging to this provider, in the priority order returned
   // by shill.
-  for (const NetworkState* const& network : networks) {
+  for (const chromeos::NetworkState* const& network : networks) {
     if (VpnProviderMatchesNetwork(vpn_provider, *network))
       AddNetwork(network);
   }
 }
 
-bool VPNListView::ProcessProviderForNetwork(
-    const NetworkState* network,
-    const NetworkStateHandler::NetworkStateList& networks,
-    std::vector<VPNProvider>* providers) {
-  for (auto provider_iter = providers->begin();
-       provider_iter != providers->end(); ++provider_iter) {
-    if (!VpnProviderMatchesNetwork(*provider_iter, *network))
-      continue;
-    AddProviderAndNetworks(*provider_iter, networks);
-    providers->erase(provider_iter);
-    return true;
-  }
-  return false;
-}
-
 void VPNListView::AddProvidersAndNetworks(
-    const NetworkStateHandler::NetworkStateList& networks) {
+    const chromeos::NetworkStateHandler::NetworkStateList& networks) {
   // Get the list of VPN providers enabled in the primary user's profile.
   std::vector<VPNProvider> extension_providers =
       Shell::Get()->vpn_list()->extension_vpn_providers();
@@ -410,33 +363,56 @@
 
   // Add connected ARCVPN network. If we can find the correct provider, nest
   // the network under the provider. Otherwise list it unnested.
-  for (const NetworkState* network : networks) {
+  for (const chromeos::NetworkState* const& network : networks) {
     if (!network->IsConnectingOrConnected())
       break;
     if (network->GetVpnProviderType() != shill::kProviderArcVpn)
       continue;
 
-    // If no matched provider found for this network. Show it unnested.
+    bool found_provider = false;
+    for (auto arc_provider_iter = arc_providers.begin();
+         arc_provider_iter != arc_providers.end(); ++arc_provider_iter) {
+      if (!VpnProviderMatchesNetwork(*arc_provider_iter, *network))
+        continue;
+      AddProviderAndNetworks(*arc_provider_iter, networks);
+      arc_providers.erase(arc_provider_iter);
+      found_provider = true;
+      break;
+    }
+    // No matched provider found for this network. Show it unnested.
     // TODO(lgcheng@) add UMA status to track this.
-    if (!ProcessProviderForNetwork(network, networks, &arc_providers))
+    if (!found_provider)
       AddNetwork(network);
   }
 
   // Add providers with at least one configured network along with their
   // networks. Providers are added in the order of their highest priority
   // network.
-  for (const NetworkState* network : networks)
-    ProcessProviderForNetwork(network, networks, &extension_providers);
+  for (const chromeos::NetworkState* const& network : networks) {
+    for (auto extension_provider_iter = extension_providers.begin();
+         extension_provider_iter != extension_providers.end();
+         ++extension_provider_iter) {
+      if (!VpnProviderMatchesNetwork(*extension_provider_iter, *network))
+        continue;
+      AddProviderAndNetworks(*extension_provider_iter, networks);
+      extension_providers.erase(extension_provider_iter);
+      break;
+    }
+  }
+
+  // Create a local networkstate list. Help AddProviderAndNetworks() by passing
+  // empty list of network states.
+  chromeos::NetworkStateHandler::NetworkStateList networkstate_empty_list;
 
   // Add providers without any configured networks, in the order that the
   // providers were returned by the extensions system.
-  for (const VPNProvider& extension_provider : extension_providers)
-    AddProviderAndNetworks(extension_provider);
+  for (const VPNProvider& provider : extension_providers)
+    AddProviderAndNetworks(provider, networkstate_empty_list);
 
   // Add Arc VPN providers without any connected or connecting networks. These
   // providers are sorted by last launch time.
   for (const VPNProvider& arc_provider : arc_providers) {
-    AddProviderAndNetworks(arc_provider);
+    AddProviderAndNetworks(arc_provider, networkstate_empty_list);
   }
 }
 
--- a/ash/system/network/vpn_list_view.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/network/vpn_list_view.h	2019-05-17 18:53:08.316000000 +0300
@@ -13,8 +13,6 @@
 #include "base/macros.h"
 #include "chromeos/network/network_state_handler.h"
 
-class PrefRegistrySimple;
-
 namespace chromeos {
 class NetworkState;
 }
@@ -56,33 +54,16 @@
   // VpnList::Observer:
   void OnVPNProvidersChanged() override;
 
-  // See Shell::RegisterProfilePrefs().
-  static void RegisterProfilePrefs(PrefRegistrySimple* registry);
-
  private:
   // Adds a network to the list.
   void AddNetwork(const chromeos::NetworkState* network);
 
   // Adds the VPN provider identified by |vpn_provider| to the list, along with
-  // no networks that belong to this provider.
-  void AddProviderAndNetworks(const VPNProvider& vpn_provider);
-
-  // Adds the VPN provider identified by |vpn_provider| to the list, along with
   // any networks that belong to this provider.
   void AddProviderAndNetworks(
       const VPNProvider& vpn_provider,
       const chromeos::NetworkStateHandler::NetworkStateList& networks);
 
-  // Finds VPN provider from |providers| that matches given |network|. Then adds
-  // the VPN provider along with any networks that belong to this provider. Will
-  // also remove the match from |providers| to avoid showing duplicate provider
-  // entry in VPN list view.
-  // Returns true if finds a match, returns false otherwise.
-  bool ProcessProviderForNetwork(
-      const chromeos::NetworkState* network,
-      const chromeos::NetworkStateHandler::NetworkStateList& networks,
-      std::vector<VPNProvider>* providers);
-
   // Adds all available VPN providers and networks to the list.
   void AddProvidersAndNetworks(
       const chromeos::NetworkStateHandler::NetworkStateList& networks);
--- a/ash/system/night_light/night_light_controller.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/night_light/night_light_controller.cc	2019-05-17 18:53:08.316000000 +0300
@@ -13,7 +13,6 @@
 #include "ash/public/cpp/ash_switches.h"
 #include "ash/session/session_controller.h"
 #include "ash/shell.h"
-#include "base/bind.h"
 #include "base/i18n/time_formatting.h"
 #include "base/logging.h"
 #include "base/metrics/histogram_macros.h"
@@ -70,39 +69,34 @@
   base::Time GetSunsetTime() const override { return GetSunRiseSet(false); }
   base::Time GetSunriseTime() const override { return GetSunRiseSet(true); }
   void SetGeoposition(mojom::SimpleGeopositionPtr position) override {
-    geoposition_ = std::move(position);
+    position_ = std::move(position);
   }
-  bool HasGeoposition() const override { return !!geoposition_; }
 
  private:
-  // Note that the below computation is intentionally performed every time
-  // GetSunsetTime() or GetSunriseTime() is called rather than once whenever we
-  // receive a geoposition (which happens at least once a day). This increases
-  // the chances of getting accurate values, especially around DST changes.
   base::Time GetSunRiseSet(bool sunrise) const {
-    if (!HasGeoposition()) {
+    if (!ValidatePosition()) {
       LOG(ERROR) << "Invalid geoposition. Using default time for "
                  << (sunrise ? "sunrise." : "sunset.");
       return sunrise ? TimeOfDay(kDefaultEndTimeOffsetMinutes).ToTimeToday()
                      : TimeOfDay(kDefaultStartTimeOffsetMinutes).ToTimeToday();
     }
 
-    icu::CalendarAstronomer astro(geoposition_->longitude,
-                                  geoposition_->latitude);
+    icu::CalendarAstronomer astro(position_->longitude, position_->latitude);
     // For sunset and sunrise times calculations to be correct, the time of the
     // icu::CalendarAstronomer object should be set to a time near local noon.
     // This avoids having the computation flopping over into an adjacent day.
     // See the documentation of icu::CalendarAstronomer::getSunRiseSet().
     // Note that the icu calendar works with milliseconds since epoch, and
     // base::Time::FromDoubleT() / ToDoubleT() work with seconds since epoch.
-    const double midday_today_sec =
-        TimeOfDay(12 * 60).ToTimeToday().ToDoubleT();
-    astro.setTime(midday_today_sec * 1000.0);
+    const double noon_today_sec = TimeOfDay(12 * 60).ToTimeToday().ToDoubleT();
+    astro.setTime(noon_today_sec * 1000.0);
     const double sun_rise_set_ms = astro.getSunRiseSet(sunrise);
     return base::Time::FromDoubleT(sun_rise_set_ms / 1000.0);
   }
 
-  mojom::SimpleGeopositionPtr geoposition_;
+  bool ValidatePosition() const { return !!position_; }
+
+  mojom::SimpleGeopositionPtr position_;
 
   DISALLOW_COPY_AND_ASSIGN(NightLightControllerDelegateImpl);
 };
@@ -307,11 +301,13 @@
   Shell::Get()->session_controller()->AddObserver(this);
   Shell::Get()->window_tree_host_manager()->AddObserver(this);
   Shell::Get()->aura_env()->AddObserver(this);
-  chromeos::PowerManagerClient::Get()->AddObserver(this);
+  chromeos::DBusThreadManager::Get()->GetPowerManagerClient()->AddObserver(
+      this);
 }
 
 NightLightController::~NightLightController() {
-  chromeos::PowerManagerClient::Get()->RemoveObserver(this);
+  chromeos::DBusThreadManager::Get()->GetPowerManagerClient()->RemoveObserver(
+      this);
   Shell::Get()->aura_env()->RemoveObserver(this);
   Shell::Get()->window_tree_host_manager()->RemoveObserver(this);
   Shell::Get()->session_controller()->RemoveObserver(this);
@@ -332,10 +328,6 @@
   registry->RegisterIntegerPref(prefs::kNightLightCustomEndTime,
                                 kDefaultEndTimeOffsetMinutes,
                                 PrefRegistry::PUBLIC);
-
-  // Non-public prefs, only meant to be used by ash.
-  registry->RegisterDoublePref(prefs::kNightLightCachedLatitude, 0.0);
-  registry->RegisterDoublePref(prefs::kNightLightCachedLongitude, 0.0);
 }
 
 // static
@@ -479,9 +471,6 @@
 void NightLightController::SetCurrentGeoposition(
     mojom::SimpleGeopositionPtr position) {
   VLOG(1) << "Received new geoposition.";
-
-  is_current_geoposition_from_cache_ = false;
-  StoreCachedGeoposition(position);
   delegate_->SetGeoposition(std::move(position));
 
   // If the schedule type is sunset to sunrise, then a potential change in the
@@ -512,52 +501,6 @@
   delegate_ = std::move(delegate);
 }
 
-void NightLightController::LoadCachedGeopositionIfNeeded() {
-  DCHECK(active_user_pref_service_);
-
-  // Even if there is a geoposition, but it's coming from a previously cached
-  // value, switching users should load the currently saved values for the
-  // new user. This is to keep users' prefs completely separate. We only ignore
-  // the cached values once we have a valid non-cached geoposition from any
-  // user in the same session.
-  if (delegate_->HasGeoposition() && !is_current_geoposition_from_cache_)
-    return;
-
-  if (!active_user_pref_service_->HasPrefPath(
-          prefs::kNightLightCachedLatitude) ||
-      !active_user_pref_service_->HasPrefPath(
-          prefs::kNightLightCachedLongitude)) {
-    VLOG(1) << "No valid current geoposition and no valid cached geoposition"
-               " are available. Will use default times for sunset / sunrise.";
-    return;
-  }
-
-  VLOG(1) << "Temporarily using a previously cached geoposition.";
-  delegate_->SetGeoposition(mojom::SimpleGeoposition::New(
-      active_user_pref_service_->GetDouble(prefs::kNightLightCachedLatitude),
-      active_user_pref_service_->GetDouble(prefs::kNightLightCachedLongitude)));
-  is_current_geoposition_from_cache_ = true;
-}
-
-void NightLightController::StoreCachedGeoposition(
-    const mojom::SimpleGeopositionPtr& position) {
-  DCHECK(position);
-
-  const SessionController* session_controller =
-      Shell::Get()->session_controller();
-  for (const auto& user_session : session_controller->GetUserSessions()) {
-    PrefService* pref_service = session_controller->GetUserPrefServiceForUser(
-        user_session->user_info->account_id);
-    if (!pref_service)
-      continue;
-
-    pref_service->SetDouble(prefs::kNightLightCachedLatitude,
-                            position->latitude);
-    pref_service->SetDouble(prefs::kNightLightCachedLongitude,
-                            position->longitude);
-  }
-}
-
 void NightLightController::RefreshLayersTemperature() {
   const float new_temperature = GetEnabled() ? GetColorTemperature() : 0.0f;
   temperature_animation_->AnimateToNewValue(
@@ -601,15 +544,10 @@
       prefs::kNightLightCustomEndTime,
       base::BindRepeating(&NightLightController::OnCustomSchedulePrefsChanged,
                           base::Unretained(this)));
-
-  // Note: No need to observe changes in the cached latitude/longitude since
-  // they're only accessed here in ash. We only load them when the active user
-  // changes, and store them whenever we receive an updated geoposition.
 }
 
 void NightLightController::InitFromUserPrefs() {
   StartWatchingPrefsChanges();
-  LoadCachedGeopositionIfNeeded();
   Refresh(true /* did_schedule_change */);
   NotifyStatusChanged();
   NotifyClientWithScheduleChange();
--- a/ash/system/night_light/night_light_controller.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/night_light/night_light_controller.h	2019-05-17 18:53:08.316000000 +0300
@@ -74,9 +74,6 @@
     // Provides the delegate with the geoposition so that it can be used to
     // calculate sunset and sunrise times.
     virtual void SetGeoposition(mojom::SimpleGeopositionPtr position) = 0;
-
-    // Returns true if a geoposition value is available.
-    virtual bool HasGeoposition() const = 0;
   };
 
   class Observer {
@@ -122,9 +119,6 @@
     return last_animation_duration_;
   }
   base::OneShotTimer* timer() { return &timer_; }
-  bool is_current_geoposition_from_cache() const {
-    return is_current_geoposition_from_cache_;
-  }
 
   void BindRequest(mojom::NightLightControllerRequest request);
 
@@ -169,15 +163,6 @@
   void SetDelegateForTesting(std::unique_ptr<Delegate> delegate);
 
  private:
-  // Called only when the active user changes in order to see if we need to use
-  // a previously cached geoposition value from the active user's prefs.
-  void LoadCachedGeopositionIfNeeded();
-
-  // Called whenever we receive a new geoposition update to cache it in all
-  // logged-in users' prefs so that it can be used later in the event of not
-  // being able to retrieve a valid geoposition.
-  void StoreCachedGeoposition(const mojom::SimpleGeopositionPtr& position);
-
   void RefreshLayersTemperature();
 
   void StartWatchingPrefsChanges();
@@ -239,15 +224,6 @@
   // type is either kSunsetToSunrise or kCustom.
   base::OneShotTimer timer_;
 
-  // True if the current geoposition value used by the Delegate is from a
-  // previously cached value in the user prefs of any of the users in the
-  // current session. It is reset to false once we receive a newly-updated
-  // geoposition from the client.
-  // This is used to treat the current geoposition as temporary until we receive
-  // a valid geoposition update, and also not to let a cached geoposition value
-  // to leak to another user for privacy reasons.
-  bool is_current_geoposition_from_cache_ = false;
-
   // The registrar used to watch NightLight prefs changes in the above
   // |active_user_pref_service_| from outside ash.
   // NOTE: Prefs are how Chrome communicates changes to the NightLight settings
--- a/ash/system/night_light/night_light_controller_unittest.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/night_light/night_light_controller_unittest.cc	2019-05-17 18:53:08.316000000 +0300
@@ -11,6 +11,7 @@
 
 #include "ash/display/cursor_window_controller.h"
 #include "ash/display/window_tree_host_manager.h"
+#include "ash/public/cpp/ash_features.h"
 #include "ash/public/cpp/ash_pref_names.h"
 #include "ash/public/cpp/session_types.h"
 #include "ash/root_window_controller.h"
@@ -26,6 +27,7 @@
 #include "base/macros.h"
 #include "base/memory/ptr_util.h"
 #include "base/strings/pattern.h"
+#include "base/test/scoped_feature_list.h"
 #include "components/prefs/pref_service.h"
 #include "ui/compositor/layer.h"
 #include "ui/display/manager/display_change_observer.h"
@@ -117,7 +119,6 @@
   base::Time GetSunsetTime() const override { return fake_sunset_; }
   base::Time GetSunriseTime() const override { return fake_sunrise_; }
   void SetGeoposition(mojom::SimpleGeopositionPtr position) override {
-    has_geoposition_ = true;
     if (position.Equals(mojom::SimpleGeoposition::New(
             kFakePosition1_Latitude, kFakePosition1_Longitude))) {
       // Set sunset and sunrise times associated with fake position 1.
@@ -130,13 +131,11 @@
       SetFakeSunrise(TimeOfDay(kFakePosition2_SunriseOffset));
     }
   }
-  bool HasGeoposition() const override { return has_geoposition_; }
 
  private:
   base::Time fake_now_;
   base::Time fake_sunset_;
   base::Time fake_sunrise_;
-  bool has_geoposition_ = false;
 
   DISALLOW_COPY_AND_ASSIGN(TestDelegate);
 };
@@ -160,6 +159,9 @@
 
   // AshTestBase:
   void SetUp() override {
+    // Explicitly enable the NightLight feature for the tests.
+    scoped_feature_list_.InitAndEnableFeature(features::kNightLight);
+
     NoSessionAshTestBase::SetUp();
     CreateTestUserSessions();
 
@@ -187,6 +189,8 @@
   }
 
  private:
+  base::test::ScopedFeatureList scoped_feature_list_;
+
   TestDelegate* delegate_ = nullptr;
 
   DISALLOW_COPY_AND_ASSIGN(NightLightTest);
@@ -641,101 +645,6 @@
             controller->timer()->GetCurrentDelay());
 }
 
-// Tests the behavior when there is no valid geoposition for example due to lack
-// of connectivity.
-TEST_F(NightLightTest, AbsentValidGeoposition) {
-  NightLightController* controller = GetController();
-  ASSERT_FALSE(delegate()->HasGeoposition());
-
-  // Initially, no values are stored in either of the two users' prefs.
-  ASSERT_FALSE(
-      user1_pref_service()->HasPrefPath(prefs::kNightLightCachedLatitude));
-  ASSERT_FALSE(
-      user1_pref_service()->HasPrefPath(prefs::kNightLightCachedLongitude));
-  ASSERT_FALSE(
-      user2_pref_service()->HasPrefPath(prefs::kNightLightCachedLatitude));
-  ASSERT_FALSE(
-      user2_pref_service()->HasPrefPath(prefs::kNightLightCachedLongitude));
-
-  // Store fake geoposition 2 in user 2's prefs.
-  user2_pref_service()->SetDouble(prefs::kNightLightCachedLatitude,
-                                  kFakePosition2_Latitude);
-  user2_pref_service()->SetDouble(prefs::kNightLightCachedLongitude,
-                                  kFakePosition2_Longitude);
-
-  // Switch to user 2 and expect that the delegate now has a geoposition, but
-  // the controller knows that it's from a cached value.
-  SwitchActiveUser(kUser2Email);
-  EXPECT_TRUE(delegate()->HasGeoposition());
-  EXPECT_TRUE(controller->is_current_geoposition_from_cache());
-  const TimeOfDay kSunset2{kFakePosition2_SunsetOffset};
-  const TimeOfDay kSunrise2{kFakePosition2_SunriseOffset};
-  EXPECT_EQ(delegate()->GetSunsetTime(), kSunset2.ToTimeToday());
-  EXPECT_EQ(delegate()->GetSunriseTime(), kSunrise2.ToTimeToday());
-
-  // Store fake geoposition 1 in user 1's prefs.
-  user1_pref_service()->SetDouble(prefs::kNightLightCachedLatitude,
-                                  kFakePosition1_Latitude);
-  user1_pref_service()->SetDouble(prefs::kNightLightCachedLongitude,
-                                  kFakePosition1_Longitude);
-
-  // Switching to user 1 should ignore the current geoposition since it's
-  // a cached value from user 2's prefs rather than a newly-updated value.
-  // User 1's cached values should be loaded.
-  SwitchActiveUser(kUser1Email);
-  EXPECT_TRUE(delegate()->HasGeoposition());
-  EXPECT_TRUE(controller->is_current_geoposition_from_cache());
-  const TimeOfDay kSunset1{kFakePosition1_SunsetOffset};
-  const TimeOfDay kSunrise1{kFakePosition1_SunriseOffset};
-  EXPECT_EQ(delegate()->GetSunsetTime(), kSunset1.ToTimeToday());
-  EXPECT_EQ(delegate()->GetSunriseTime(), kSunrise1.ToTimeToday());
-
-  // Now simulate receiving a geoposition update of fake geoposition 2.
-  controller->SetCurrentGeoposition(mojom::SimpleGeoposition::New(
-      kFakePosition2_Latitude, kFakePosition2_Longitude));
-  EXPECT_TRUE(delegate()->HasGeoposition());
-  EXPECT_FALSE(controller->is_current_geoposition_from_cache());
-  EXPECT_EQ(delegate()->GetSunsetTime(), kSunset2.ToTimeToday());
-  EXPECT_EQ(delegate()->GetSunriseTime(), kSunrise2.ToTimeToday());
-
-  // Update user 2's prefs with fake geoposition 1.
-  user2_pref_service()->SetDouble(prefs::kNightLightCachedLatitude,
-                                  kFakePosition1_Latitude);
-  user2_pref_service()->SetDouble(prefs::kNightLightCachedLongitude,
-                                  kFakePosition1_Longitude);
-
-  // Now switching to user 2 should completely ignore their cached geopsoition,
-  // since from now on we have a valid newly-retrieved value.
-  SwitchActiveUser(kUser2Email);
-  EXPECT_TRUE(delegate()->HasGeoposition());
-  EXPECT_FALSE(controller->is_current_geoposition_from_cache());
-  EXPECT_EQ(delegate()->GetSunsetTime(), kSunset2.ToTimeToday());
-  EXPECT_EQ(delegate()->GetSunriseTime(), kSunrise2.ToTimeToday());
-
-  // Clear all cached geoposition prefs for all users, just to make sure getting
-  // a new geoposition with persist it for all users not just the active one.
-  user1_pref_service()->ClearPref(prefs::kNightLightCachedLatitude);
-  user1_pref_service()->ClearPref(prefs::kNightLightCachedLongitude);
-  user2_pref_service()->ClearPref(prefs::kNightLightCachedLatitude);
-  user2_pref_service()->ClearPref(prefs::kNightLightCachedLongitude);
-
-  // Now simulate receiving a geoposition update of fake geoposition 1.
-  controller->SetCurrentGeoposition(mojom::SimpleGeoposition::New(
-      kFakePosition1_Latitude, kFakePosition1_Longitude));
-  EXPECT_TRUE(delegate()->HasGeoposition());
-  EXPECT_FALSE(controller->is_current_geoposition_from_cache());
-  EXPECT_EQ(delegate()->GetSunsetTime(), kSunset1.ToTimeToday());
-  EXPECT_EQ(delegate()->GetSunriseTime(), kSunrise1.ToTimeToday());
-  EXPECT_EQ(kFakePosition1_Latitude,
-            user1_pref_service()->GetDouble(prefs::kNightLightCachedLatitude));
-  EXPECT_EQ(kFakePosition1_Longitude,
-            user1_pref_service()->GetDouble(prefs::kNightLightCachedLongitude));
-  EXPECT_EQ(kFakePosition1_Latitude,
-            user2_pref_service()->GetDouble(prefs::kNightLightCachedLatitude));
-  EXPECT_EQ(kFakePosition1_Longitude,
-            user2_pref_service()->GetDouble(prefs::kNightLightCachedLongitude));
-}
-
 // Tests that on device resume from sleep, the NightLight status is updated
 // correctly if the time has changed meanwhile.
 TEST_F(NightLightTest, TestCustomScheduleOnResume) {
@@ -870,19 +779,23 @@
   static constexpr int64_t kId1 = 123;
   static constexpr int64_t kId2 = 456;
 
+  display::DisplayConfigurator* display_configurator() {
+    return Shell::Get()->display_configurator();
+  }
+
   // NightLightTest:
   void SetUp() override {
     NightLightTest::SetUp();
 
     native_display_delegate_ =
         new display::test::TestNativeDisplayDelegate(logger_.get());
-    display_manager()->configurator()->SetDelegateForTesting(
+    display_configurator()->SetDelegateForTesting(
         std::unique_ptr<display::NativeDisplayDelegate>(
             native_display_delegate_));
-    display_change_observer_ =
-        std::make_unique<display::DisplayChangeObserver>(display_manager());
+    display_change_observer_ = std::make_unique<display::DisplayChangeObserver>(
+        display_configurator(), display_manager());
     test_api_ = std::make_unique<display::DisplayConfigurator::TestApi>(
-        display_manager()->configurator());
+        display_configurator());
   }
 
   void TearDown() override {
@@ -934,7 +847,7 @@
   // display snapshots.
   void UpdateDisplays(const std::vector<display::DisplaySnapshot*>& outputs) {
     native_display_delegate_->set_outputs(outputs);
-    display_manager()->configurator()->OnConfigurationChanged();
+    display_configurator()->OnConfigurationChanged();
     EXPECT_TRUE(test_api_->TriggerConfigureTimeout());
     display_change_observer_->GetStateForDisplayIds(outputs);
     display_change_observer_->OnDisplayModeChanged(outputs);
--- a/ash/system/night_light/night_light_feature_pod_controller.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/night_light/night_light_feature_pod_controller.cc	2019-05-17 18:53:08.316000000 +0300
@@ -4,6 +4,7 @@
 
 #include "ash/system/night_light/night_light_feature_pod_controller.h"
 
+#include "ash/public/cpp/ash_features.h"
 #include "ash/resources/vector_icons/vector_icons.h"
 #include "ash/session/session_controller.h"
 #include "ash/shell.h"
@@ -32,6 +33,7 @@
   button_ = new FeaturePodButton(this);
   button_->SetVectorIcon(kUnifiedMenuNightLightIcon);
   button_->SetVisible(
+      features::IsNightLightEnabled() &&
       Shell::Get()->session_controller()->ShouldEnableSettings());
   button_->SetLabel(
       l10n_util::GetStringUTF16(IDS_ASH_STATUS_TRAY_NIGHT_LIGHT_BUTTON_LABEL));
@@ -44,6 +46,7 @@
 }
 
 void NightLightFeaturePodController::OnIconPressed() {
+  DCHECK(features::IsNightLightEnabled());
   Shell::Get()->night_light_controller()->Toggle();
   UpdateButton();
 
@@ -57,6 +60,7 @@
 }
 
 void NightLightFeaturePodController::OnLabelPressed() {
+  DCHECK(features::IsNightLightEnabled());
   if (TrayPopupUtils::CanOpenWebUISettings()) {
     base::RecordAction(
         base::UserMetricsAction("StatusArea_NightLight_Settings"));
@@ -70,7 +74,10 @@
 }
 
 void NightLightFeaturePodController::UpdateButton() {
-  const bool is_enabled = Shell::Get()->night_light_controller()->GetEnabled();
+  if (!features::IsNightLightEnabled())
+    return;
+
+  bool is_enabled = Shell::Get()->night_light_controller()->GetEnabled();
   button_->SetToggled(is_enabled);
   button_->SetSubLabel(l10n_util::GetStringUTF16(
       is_enabled ? IDS_ASH_STATUS_TRAY_NIGHT_LIGHT_ON_STATE
--- a/ash/system/night_light/night_light_toggle_button.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/night_light/night_light_toggle_button.cc	2019-05-17 18:53:08.316000000 +0300
@@ -4,6 +4,7 @@
 
 #include "ash/system/night_light/night_light_toggle_button.h"
 
+#include "ash/public/cpp/ash_features.h"
 #include "ash/shell.h"
 #include "ash/strings/grit/ash_strings.h"
 #include "ash/system/night_light/night_light_controller.h"
@@ -55,6 +56,7 @@
 }
 
 void NightLightToggleButton::Toggle() {
+  DCHECK(features::IsNightLightEnabled());
   Shell::Get()->night_light_controller()->Toggle();
   Update();
   NotifyAccessibilityEvent(ax::mojom::Event::kAriaAttributeChanged, true);
--- a/ash/system/overview/overview_button_tray.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/overview/overview_button_tray.cc	2019-05-17 18:53:08.316000000 +0300
@@ -22,7 +22,6 @@
 #include "base/metrics/user_metrics_action.h"
 #include "ui/base/l10n/l10n_util.h"
 #include "ui/gfx/paint_vector_icon.h"
-#include "ui/views/animation/ink_drop.h"
 #include "ui/views/border.h"
 #include "ui/views/controls/image_view.h"
 #include "ui/wm/core/window_util.h"
@@ -50,25 +49,20 @@
   // horizontal shelf, no separator is required.
   set_separator_visibility(false);
 
-  Shell::Get()->overview_controller()->AddObserver(this);
+  Shell::Get()->AddShellObserver(this);
   Shell::Get()->tablet_mode_controller()->AddObserver(this);
 }
 
 OverviewButtonTray::~OverviewButtonTray() {
-  if (Shell::Get()->overview_controller())
-    Shell::Get()->overview_controller()->RemoveObserver(this);
   if (Shell::Get()->tablet_mode_controller())
     Shell::Get()->tablet_mode_controller()->RemoveObserver(this);
+  Shell::Get()->RemoveShellObserver(this);
 }
 
 void OverviewButtonTray::UpdateAfterLoginStatusChange(LoginStatus status) {
   UpdateIconVisibility();
 }
 
-void OverviewButtonTray::SnapRippleToActivated() {
-  GetInkDrop()->SnapToActivated();
-}
-
 void OverviewButtonTray::OnGestureEvent(ui::GestureEvent* event) {
   Button::OnGestureEvent(event);
   if (event->type() == ui::ET_GESTURE_LONG_PRESS) {
--- a/ash/system/overview/overview_button_tray.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/overview/overview_button_tray.h	2019-05-17 18:53:08.316000000 +0300
@@ -7,8 +7,8 @@
 
 #include "ash/ash_export.h"
 #include "ash/session/session_observer.h"
+#include "ash/shell_observer.h"
 #include "ash/system/tray/tray_background_view.h"
-#include "ash/wm/overview/overview_observer.h"
 #include "ash/wm/tablet_mode/tablet_mode_observer.h"
 #include "base/macros.h"
 #include "ui/events/event_constants.h"
@@ -26,7 +26,7 @@
 // provide any bubble view windows.
 class ASH_EXPORT OverviewButtonTray : public TrayBackgroundView,
                                       public SessionObserver,
-                                      public OverviewObserver,
+                                      public ShellObserver,
                                       public TabletModeObserver {
  public:
   // Second taps within this time will be counted as double taps. Use this
@@ -45,9 +45,6 @@
   // state of TabletMode
   virtual void UpdateAfterLoginStatusChange(LoginStatus status);
 
-  // Sets the ink drop ripple to ACTIVATED immediately with no animations.
-  void SnapRippleToActivated();
-
   // views::Button:
   void OnGestureEvent(ui::GestureEvent* event) override;
 
@@ -57,7 +54,7 @@
   // SessionObserver:
   void OnSessionStateChanged(session_manager::SessionState state) override;
 
-  // OverviewObserver:
+  // ShellObserver:
   void OnOverviewModeStarting() override;
   void OnOverviewModeEnded() override;
 
--- a/ash/system/palette/palette_tray.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/palette/palette_tray.cc	2019-05-17 18:53:08.316000000 +0300
@@ -25,7 +25,6 @@
 #include "ash/system/tray/tray_container.h"
 #include "ash/system/tray/tray_popup_item_style.h"
 #include "ash/system/tray/tray_popup_utils.h"
-#include "base/bind.h"
 #include "base/metrics/histogram_macros.h"
 #include "components/pref_registry/pref_registry_syncable.h"
 #include "components/prefs/pref_change_registrar.h"
--- a/ash/system/palette/palette_welcome_bubble.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/palette/palette_welcome_bubble.cc	2019-05-17 18:53:08.320000000 +0300
@@ -37,7 +37,7 @@
   WelcomeBubbleView(views::View* anchor, views::BubbleBorder::Arrow arrow)
       : views::BubbleDialogDelegateView(anchor, arrow) {
     set_close_on_deactivate(true);
-    SetCanActivate(false);
+    set_can_activate(false);
     set_accept_events(true);
     set_parent_window(
         anchor_widget()->GetNativeWindow()->GetRootWindow()->GetChildById(
@@ -113,10 +113,8 @@
 
   base::Optional<user_manager::UserType> user_type =
       Shell::Get()->session_controller()->GetUserType();
-  if (user_type && (*user_type == user_manager::USER_TYPE_GUEST ||
-                    *user_type == user_manager::USER_TYPE_PUBLIC_ACCOUNT)) {
+  if (user_type && *user_type == user_manager::USER_TYPE_GUEST)
     return;
-  }
 
   if (!HasBeenShown())
     Show();
--- a/ash/system/palette/palette_welcome_bubble_unittest.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/palette/palette_welcome_bubble_unittest.cc	2019-05-17 18:53:08.320000000 +0300
@@ -25,7 +25,6 @@
 constexpr char kUser1Email[] = "user1@palettewelcome.com";
 constexpr char kUser2Email[] = "user2@palettewelcome.com";
 constexpr char kGuestEmail[] = "guest@palettewelcome.com";
-constexpr char kPublicAccountEmail[] = "public@palettewelcome.com";
 
 }  // namespace
 
@@ -141,27 +140,25 @@
   EXPECT_FALSE(welcome_bubble_->GetBubbleViewForTesting());
 }
 
-using PaletteWelcomeBubbleEmphemeralAccountTest = AshTestBase;
+class PaletteWelcomeBubbleGuestModeTest : public AshTestBase {
+ public:
+  PaletteWelcomeBubbleGuestModeTest() = default;
+  ~PaletteWelcomeBubbleGuestModeTest() override = default;
 
-TEST_F(PaletteWelcomeBubbleEmphemeralAccountTest, BubbleNotShownForGuest) {
-  auto welcome_bubble = std::make_unique<PaletteWelcomeBubble>(
-      StatusAreaWidgetTestHelper::GetStatusAreaWidget()->palette_tray());
+  // AshTestBase:
+  void SetUp() override {
+    AshTestBase::SetUp();
   GetSessionControllerClient()->AddUserSession(kGuestEmail,
                                                user_manager::USER_TYPE_GUEST);
-  GetSessionControllerClient()->SwitchActiveUser(
-      AccountId::FromUserEmail(kGuestEmail));
-  welcome_bubble->ShowIfNeeded();
-  EXPECT_FALSE(welcome_bubble->GetBubbleViewForTesting());
-}
+  }
 
-TEST_F(PaletteWelcomeBubbleEmphemeralAccountTest,
-       BubbleNotShownForPublicAccount) {
+ private:
+  DISALLOW_COPY_AND_ASSIGN(PaletteWelcomeBubbleGuestModeTest);
+};
+
+TEST_F(PaletteWelcomeBubbleGuestModeTest, BubbleNotShownForGuest) {
   auto welcome_bubble = std::make_unique<PaletteWelcomeBubble>(
       StatusAreaWidgetTestHelper::GetStatusAreaWidget()->palette_tray());
-  GetSessionControllerClient()->AddUserSession(
-      kPublicAccountEmail, user_manager::USER_TYPE_PUBLIC_ACCOUNT);
-  GetSessionControllerClient()->SwitchActiveUser(
-      AccountId::FromUserEmail(kPublicAccountEmail));
   welcome_bubble->ShowIfNeeded();
   EXPECT_FALSE(welcome_bubble->GetBubbleViewForTesting());
 }
--- a/ash/system/palette/tools/capture_region_mode.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/palette/tools/capture_region_mode.cc	2019-05-17 18:53:08.320000000 +0300
@@ -11,7 +11,6 @@
 #include "ash/system/toast/toast_data.h"
 #include "ash/system/toast/toast_manager.h"
 #include "ash/utility/screenshot_controller.h"
-#include "base/bind.h"
 #include "ui/base/l10n/l10n_util.h"
 
 namespace ash {
--- a/ash/system/palette/tools/metalayer_mode.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/palette/tools/metalayer_mode.cc	2019-05-17 18:53:08.320000000 +0300
@@ -14,7 +14,6 @@
 #include "ash/system/tray/hover_highlight_view.h"
 #include "ash/system/tray/tray_constants.h"
 #include "ash/voice_interaction/voice_interaction_controller.h"
-#include "base/bind.h"
 #include "ui/base/l10n/l10n_util.h"
 #include "ui/events/event.h"
 #include "ui/gfx/paint_vector_icon.h"
--- a/ash/system/power/backlights_forced_off_setter.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/power/backlights_forced_off_setter.cc	2019-05-17 18:53:08.320000000 +0300
@@ -11,6 +11,7 @@
 #include "base/bind.h"
 #include "base/command_line.h"
 #include "base/logging.h"
+#include "chromeos/dbus/dbus_thread_manager.h"
 #include "chromeos/dbus/power_manager/backlight.pb.h"
 #include "ui/display/manager/touch_device_manager.h"
 
@@ -20,13 +21,16 @@
     : power_manager_observer_(this), weak_ptr_factory_(this) {
   InitDisableTouchscreenWhileScreenOff();
 
-  power_manager_observer_.Add(chromeos::PowerManagerClient::Get());
+  power_manager_observer_.Add(
+      chromeos::DBusThreadManager::Get()->GetPowerManagerClient());
   GetInitialBacklightsForcedOff();
 }
 
 BacklightsForcedOffSetter::~BacklightsForcedOffSetter() {
   if (active_backlights_forced_off_count_ > 0) {
-    chromeos::PowerManagerClient::Get()->SetBacklightsForcedOff(false);
+    chromeos::DBusThreadManager::Get()
+        ->GetPowerManagerClient()
+        ->SetBacklightsForcedOff(false);
   }
 }
 
@@ -77,8 +81,9 @@
 
 void BacklightsForcedOffSetter::PowerManagerRestarted() {
   if (backlights_forced_off_.has_value()) {
-    chromeos::PowerManagerClient::Get()->SetBacklightsForcedOff(
-        backlights_forced_off_.value());
+    chromeos::DBusThreadManager::Get()
+        ->GetPowerManagerClient()
+        ->SetBacklightsForcedOff(backlights_forced_off_.value());
   } else {
     GetInitialBacklightsForcedOff();
   }
@@ -86,7 +91,9 @@
 
 void BacklightsForcedOffSetter::ResetForTest() {
   if (active_backlights_forced_off_count_ > 0) {
-    chromeos::PowerManagerClient::Get()->SetBacklightsForcedOff(false);
+    chromeos::DBusThreadManager::Get()
+        ->GetPowerManagerClient()
+        ->SetBacklightsForcedOff(false);
   }
 
   // Cancel all backlights forced off requests.
@@ -106,7 +113,9 @@
 }
 
 void BacklightsForcedOffSetter::GetInitialBacklightsForcedOff() {
-  chromeos::PowerManagerClient::Get()->GetBacklightsForcedOff(base::BindOnce(
+  chromeos::DBusThreadManager::Get()
+      ->GetPowerManagerClient()
+      ->GetBacklightsForcedOff(base::BindOnce(
       &BacklightsForcedOffSetter::OnGotInitialBacklightsForcedOff,
       weak_ptr_factory_.GetWeakPtr()));
 }
@@ -138,7 +147,9 @@
   }
 
   backlights_forced_off_ = forced_off;
-  chromeos::PowerManagerClient::Get()->SetBacklightsForcedOff(forced_off);
+  chromeos::DBusThreadManager::Get()
+      ->GetPowerManagerClient()
+      ->SetBacklightsForcedOff(forced_off);
 
   UpdateTouchscreenStatus();
 
--- a/ash/system/power/backlights_forced_off_setter_unittest.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/power/backlights_forced_off_setter_unittest.cc	2019-05-17 18:53:08.320000000 +0300
@@ -15,6 +15,7 @@
 #include "ash/touch/touch_devices_controller.h"
 #include "base/macros.h"
 #include "base/scoped_observer.h"
+#include "chromeos/dbus/dbus_thread_manager.h"
 #include "chromeos/dbus/fake_power_manager_client.h"
 #include "services/ws/public/cpp/input_devices/input_device_client_test_api.h"
 #include "ui/display/manager/display_manager.h"
@@ -70,6 +71,12 @@
   ~BacklightsForcedOffSetterTest() override = default;
 
   void SetUp() override {
+    auto power_manager_client =
+        std::make_unique<chromeos::FakePowerManagerClient>();
+    power_manager_client_ = power_manager_client.get();
+    chromeos::DBusThreadManager::GetSetterForTesting()->SetPowerManagerClient(
+        std::move(power_manager_client));
+
     AshTestBase::SetUp();
 
     backlights_forced_off_setter_ =
@@ -82,6 +89,7 @@
     backlights_forced_off_observer_.reset();
     backlights_forced_off_setter_.reset();
     AshTestBase::TearDown();
+    chromeos::DBusThreadManager::Shutdown();
   }
 
   void ResetBacklightsForcedOffSetter() {
@@ -90,6 +98,9 @@
   }
 
  protected:
+  // Owned by DBusThreadManager.
+  chromeos::FakePowerManagerClient* power_manager_client_ = nullptr;
+
   std::unique_ptr<BacklightsForcedOffSetter> backlights_forced_off_setter_;
   std::unique_ptr<TestObserver> backlights_forced_off_observer_;
 
@@ -98,52 +109,52 @@
 };
 
 TEST_F(BacklightsForcedOffSetterTest, SingleForcedOffRequest) {
-  ASSERT_FALSE(power_manager_client()->backlights_forced_off());
+  ASSERT_FALSE(power_manager_client_->backlights_forced_off());
 
   std::unique_ptr<ScopedBacklightsForcedOff> scoped_forced_off =
       backlights_forced_off_setter_->ForceBacklightsOff();
 
-  EXPECT_TRUE(power_manager_client()->backlights_forced_off());
+  EXPECT_TRUE(power_manager_client_->backlights_forced_off());
   EXPECT_EQ(std::vector<bool>({true}),
             backlights_forced_off_observer_->forced_off_states());
   backlights_forced_off_observer_->ClearForcedOffStates();
 
   scoped_forced_off.reset();
 
-  EXPECT_FALSE(power_manager_client()->backlights_forced_off());
+  EXPECT_FALSE(power_manager_client_->backlights_forced_off());
   EXPECT_EQ(std::vector<bool>({false}),
             backlights_forced_off_observer_->forced_off_states());
 }
 
 TEST_F(BacklightsForcedOffSetterTest, BacklightsForcedOffSetterDeleted) {
-  ASSERT_FALSE(power_manager_client()->backlights_forced_off());
+  ASSERT_FALSE(power_manager_client_->backlights_forced_off());
 
   std::unique_ptr<ScopedBacklightsForcedOff> scoped_forced_off =
       backlights_forced_off_setter_->ForceBacklightsOff();
 
-  EXPECT_TRUE(power_manager_client()->backlights_forced_off());
+  EXPECT_TRUE(power_manager_client_->backlights_forced_off());
   EXPECT_EQ(std::vector<bool>({true}),
             backlights_forced_off_observer_->forced_off_states());
   backlights_forced_off_observer_->ClearForcedOffStates();
 
   ResetBacklightsForcedOffSetter();
 
-  EXPECT_FALSE(power_manager_client()->backlights_forced_off());
+  EXPECT_FALSE(power_manager_client_->backlights_forced_off());
 
   // Verify that deleting scoped forced off request does not affect
   // power manager state (nor cause a crash).
   scoped_forced_off.reset();
-  EXPECT_FALSE(power_manager_client()->backlights_forced_off());
+  EXPECT_FALSE(power_manager_client_->backlights_forced_off());
 }
 
 TEST_F(BacklightsForcedOffSetterTest,
        OverlappingRequests_SecondRequestResetFirst) {
-  ASSERT_FALSE(power_manager_client()->backlights_forced_off());
+  ASSERT_FALSE(power_manager_client_->backlights_forced_off());
 
   std::unique_ptr<ScopedBacklightsForcedOff> scoped_forced_off_1 =
       backlights_forced_off_setter_->ForceBacklightsOff();
 
-  EXPECT_TRUE(power_manager_client()->backlights_forced_off());
+  EXPECT_TRUE(power_manager_client_->backlights_forced_off());
   EXPECT_EQ(std::vector<bool>({true}),
             backlights_forced_off_observer_->forced_off_states());
   backlights_forced_off_observer_->ClearForcedOffStates();
@@ -151,29 +162,29 @@
   std::unique_ptr<ScopedBacklightsForcedOff> scoped_forced_off_2 =
       backlights_forced_off_setter_->ForceBacklightsOff();
 
-  EXPECT_TRUE(power_manager_client()->backlights_forced_off());
+  EXPECT_TRUE(power_manager_client_->backlights_forced_off());
   EXPECT_TRUE(backlights_forced_off_observer_->forced_off_states().empty());
 
   scoped_forced_off_2.reset();
 
-  EXPECT_TRUE(power_manager_client()->backlights_forced_off());
+  EXPECT_TRUE(power_manager_client_->backlights_forced_off());
   EXPECT_TRUE(backlights_forced_off_observer_->forced_off_states().empty());
 
   scoped_forced_off_1.reset();
 
-  EXPECT_FALSE(power_manager_client()->backlights_forced_off());
+  EXPECT_FALSE(power_manager_client_->backlights_forced_off());
   EXPECT_EQ(std::vector<bool>({false}),
             backlights_forced_off_observer_->forced_off_states());
 }
 
 TEST_F(BacklightsForcedOffSetterTest,
        OverlappingRequests_FirstRequestResetFirst) {
-  ASSERT_FALSE(power_manager_client()->backlights_forced_off());
+  ASSERT_FALSE(power_manager_client_->backlights_forced_off());
 
   std::unique_ptr<ScopedBacklightsForcedOff> scoped_forced_off_1 =
       backlights_forced_off_setter_->ForceBacklightsOff();
 
-  EXPECT_TRUE(power_manager_client()->backlights_forced_off());
+  EXPECT_TRUE(power_manager_client_->backlights_forced_off());
   EXPECT_EQ(std::vector<bool>({true}),
             backlights_forced_off_observer_->forced_off_states());
   backlights_forced_off_observer_->ClearForcedOffStates();
@@ -181,7 +192,7 @@
   std::unique_ptr<ScopedBacklightsForcedOff> scoped_forced_off_2 =
       backlights_forced_off_setter_->ForceBacklightsOff();
 
-  EXPECT_TRUE(power_manager_client()->backlights_forced_off());
+  EXPECT_TRUE(power_manager_client_->backlights_forced_off());
   EXPECT_TRUE(backlights_forced_off_observer_->forced_off_states().empty());
 
   scoped_forced_off_1.reset();
@@ -190,7 +201,7 @@
 
   scoped_forced_off_2.reset();
 
-  EXPECT_FALSE(power_manager_client()->backlights_forced_off());
+  EXPECT_FALSE(power_manager_client_->backlights_forced_off());
   EXPECT_EQ(std::vector<bool>({false}),
             backlights_forced_off_observer_->forced_off_states());
 }
@@ -245,7 +256,7 @@
   change.set_cause(power_manager::BacklightBrightnessChange_Cause_OTHER);
   change.set_percent(0.0);
 
-  power_manager_client()->SendScreenBrightnessChanged(change);
+  power_manager_client_->SendScreenBrightnessChanged(change);
 
   // The touchscreens should be enabled.
   EXPECT_TRUE(Shell::Get()->touch_devices_controller()->GetTouchscreenEnabled(
@@ -284,7 +295,7 @@
   change.set_cause(power_manager::BacklightBrightnessChange_Cause_OTHER);
   change.set_percent(0.0);
 
-  power_manager_client()->SendScreenBrightnessChanged(change);
+  power_manager_client_->SendScreenBrightnessChanged(change);
 
   // The touchscreens should be disabled.
   EXPECT_FALSE(Shell::Get()->touch_devices_controller()->GetTouchscreenEnabled(
--- a/ash/system/power/battery_notification.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/power/battery_notification.cc	2019-05-17 18:53:08.320000000 +0300
@@ -69,25 +69,25 @@
       l10n_util::GetStringUTF16(IDS_ASH_STATUS_TRAY_BATTERY_PERCENT),
       static_cast<double>(status.GetRoundedBatteryPercent()) / 100.0);
 
-  const base::Optional<base::TimeDelta> time =
-      status.IsBatteryCharging() ? status.GetBatteryTimeToFull()
+  const base::TimeDelta time = status.IsBatteryCharging()
+                                   ? status.GetBatteryTimeToFull()
                                  : status.GetBatteryTimeToEmpty();
   base::string16 time_message;
   if (status.IsUsbChargerConnected()) {
     time_message = l10n_util::GetStringUTF16(
         IDS_ASH_STATUS_TRAY_BATTERY_CHARGING_UNRELIABLE);
-  } else if (time && power_utils::ShouldDisplayBatteryTime(*time) &&
+  } else if (power_utils::ShouldDisplayBatteryTime(time) &&
              !status.IsBatteryDischargingOnLinePower()) {
     if (status.IsBatteryCharging()) {
       base::string16 duration;
-      if (!TimeDurationFormat(*time, base::DURATION_WIDTH_NARROW, &duration))
-        LOG(ERROR) << "Failed to format duration " << *time;
+      if (!TimeDurationFormat(time, base::DURATION_WIDTH_NARROW, &duration))
+        LOG(ERROR) << "Failed to format duration " << time;
       time_message = l10n_util::GetStringFUTF16(
           IDS_ASH_STATUS_TRAY_BATTERY_TIME_UNTIL_FULL, duration);
     } else {
       // This is a low battery warning prompting the user in minutes.
       time_message = ui::TimeFormat::Simple(ui::TimeFormat::FORMAT_REMAINING,
-                                            ui::TimeFormat::LENGTH_LONG, *time);
+                                            ui::TimeFormat::LENGTH_LONG, time);
     }
   }
 
--- a/ash/system/power/dual_role_notification.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/power/dual_role_notification.cc	2019-05-17 18:53:08.320000000 +0300
@@ -12,7 +12,6 @@
 #include "ash/strings/grit/ash_strings.h"
 #include "ash/system/model/system_tray_model.h"
 #include "ash/system/power/power_status.h"
-#include "base/bind.h"
 #include "base/strings/utf_string_conversions.h"
 #include "ui/base/l10n/l10n_util.h"
 #include "ui/base/l10n/time_format.h"
--- a/ash/system/power/peripheral_battery_notifier.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/power/peripheral_battery_notifier.cc	2019-05-17 18:53:08.320000000 +0300
@@ -164,7 +164,8 @@
 PeripheralBatteryNotifier::PeripheralBatteryNotifier()
     : weakptr_factory_(
           new base::WeakPtrFactory<PeripheralBatteryNotifier>(this)) {
-  chromeos::PowerManagerClient::Get()->AddObserver(this);
+  chromeos::DBusThreadManager::Get()->GetPowerManagerClient()->AddObserver(
+      this);
   device::BluetoothAdapterFactory::GetAdapter(
       base::BindOnce(&PeripheralBatteryNotifier::InitializeOnBluetoothReady,
                      weakptr_factory_->GetWeakPtr()));
@@ -173,7 +174,8 @@
 PeripheralBatteryNotifier::~PeripheralBatteryNotifier() {
   if (bluetooth_adapter_.get())
     bluetooth_adapter_->RemoveObserver(this);
-  chromeos::PowerManagerClient::Get()->RemoveObserver(this);
+  chromeos::DBusThreadManager::Get()->GetPowerManagerClient()->RemoveObserver(
+      this);
 }
 
 void PeripheralBatteryNotifier::PeripheralBatteryStatusReceived(
--- a/ash/system/power/power_button_controller.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/power/power_button_controller.cc	2019-05-17 18:53:08.320000000 +0300
@@ -24,7 +24,6 @@
 #include "ash/wm/session_state_animator.h"
 #include "ash/wm/tablet_mode/tablet_mode_controller.h"
 #include "ash/wm/window_util.h"
-#include "base/bind.h"
 #include "base/command_line.h"
 #include "base/json/json_reader.h"
 #include "base/time/default_tick_clock.h"
@@ -158,7 +157,7 @@
   display_controller_ = std::make_unique<PowerButtonDisplayController>(
       backlights_forced_off_setter_, tick_clock_);
   chromeos::PowerManagerClient* power_manager_client =
-      chromeos::PowerManagerClient::Get();
+      chromeos::DBusThreadManager::Get()->GetPowerManagerClient();
   power_manager_client->AddObserver(this);
   power_manager_client->GetSwitchStates(base::BindOnce(
       &PowerButtonController::OnGetSwitchStates, weak_factory_.GetWeakPtr()));
@@ -175,7 +174,8 @@
     Shell::Get()->tablet_mode_controller()->RemoveObserver(this);
   Shell::Get()->display_configurator()->RemoveObserver(this);
   AccelerometerReader::GetInstance()->RemoveObserver(this);
-  chromeos::PowerManagerClient::Get()->RemoveObserver(this);
+  chromeos::DBusThreadManager::Get()->GetPowerManagerClient()->RemoveObserver(
+      this);
 }
 
 void PowerButtonController::OnPreShutdownTimeout() {
@@ -532,7 +532,7 @@
     return;
 
   std::unique_ptr<base::DictionaryValue> position_info =
-      base::DictionaryValue::From(base::JSONReader::ReadDeprecated(
+      base::DictionaryValue::From(base::JSONReader::Read(
           cl->GetSwitchValueASCII(switches::kAshPowerButtonPosition)));
   if (!position_info) {
     LOG(ERROR) << switches::kAshPowerButtonPosition << " flag has no value";
--- a/ash/system/power/power_button_controller_unittest.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/power/power_button_controller_unittest.cc	2019-05-17 18:53:08.320000000 +0300
@@ -74,7 +74,7 @@
     InitPowerButtonControllerMembers(PowerManagerClient::TabletMode::ON);
 
     SendBrightnessChange(kNonZeroBrightness, kUserCause);
-    EXPECT_FALSE(power_manager_client()->backlights_forced_off());
+    EXPECT_FALSE(power_manager_client_->backlights_forced_off());
 
     // Advance a duration longer than |kIgnorePowerButtonAfterResumeDelay| to
     // avoid events being ignored.
@@ -94,7 +94,7 @@
     power_manager::BacklightBrightnessChange change;
     change.set_percent(percent);
     change.set_cause(cause);
-    power_manager_client()->SendScreenBrightnessChanged(change);
+    power_manager_client_->SendScreenBrightnessChanged(change);
   }
 
   bool GetLockedState() {
@@ -115,10 +115,10 @@
   void TappingPowerButtonWhenScreenIsIdleOff() {
     SendBrightnessChange(0, kUserCause);
     PressPowerButton();
-    EXPECT_FALSE(power_manager_client()->backlights_forced_off());
+    EXPECT_FALSE(power_manager_client_->backlights_forced_off());
     SendBrightnessChange(kNonZeroBrightness, kUserCause);
     ReleasePowerButton();
-    EXPECT_FALSE(power_manager_client()->backlights_forced_off());
+    EXPECT_FALSE(power_manager_client_->backlights_forced_off());
     EXPECT_FALSE(power_button_test_api_->PowerButtonMenuTimerIsRunning());
   }
 
@@ -188,7 +188,7 @@
 TEST_F(PowerButtonControllerTest, TappingPowerButtonOfClamshell) {
   // Should not turn the screen off when screen is on.
   InitPowerButtonControllerMembers(PowerManagerClient::TabletMode::UNSUPPORTED);
-  EXPECT_FALSE(power_manager_client()->backlights_forced_off());
+  EXPECT_FALSE(power_manager_client_->backlights_forced_off());
   PressPowerButton();
   power_button_test_api_->SetShowMenuAnimationDone(false);
   // Start the showing power menu animation immediately as pressing the
@@ -196,7 +196,7 @@
   EXPECT_FALSE(power_button_test_api_->PowerButtonMenuTimerIsRunning());
   EXPECT_TRUE(power_button_test_api_->IsMenuOpened());
   ReleasePowerButton();
-  EXPECT_FALSE(power_manager_client()->backlights_forced_off());
+  EXPECT_FALSE(power_manager_client_->backlights_forced_off());
   // Start the dimissing power menu animation immediately as releasing the
   // clamsehll power button if showing animation hasn't finished.
   EXPECT_FALSE(power_button_test_api_->IsMenuOpened());
@@ -217,7 +217,7 @@
   power_button_test_api_->SetShowMenuAnimationDone(true);
   ASSERT_TRUE(power_button_test_api_->TriggerPreShutdownTimeout());
   ReleasePowerButton();
-  EXPECT_FALSE(power_manager_client()->backlights_forced_off());
+  EXPECT_FALSE(power_manager_client_->backlights_forced_off());
   // Power button menu should keep opened if showing animation has finished.
   EXPECT_TRUE(power_button_test_api_->IsMenuOpened());
 
@@ -226,7 +226,7 @@
   AdvanceClockToAvoidIgnoring();
   PressPowerButton();
   ReleasePowerButton();
-  EXPECT_FALSE(power_manager_client()->backlights_forced_off());
+  EXPECT_FALSE(power_manager_client_->backlights_forced_off());
   EXPECT_FALSE(power_button_test_api_->IsMenuOpened());
 }
 
@@ -238,11 +238,11 @@
   PressPowerButton();
   // Showing power menu animation hasn't started as power menu timer is running.
   EXPECT_TRUE(power_button_test_api_->PowerButtonMenuTimerIsRunning());
-  EXPECT_FALSE(power_manager_client()->backlights_forced_off());
+  EXPECT_FALSE(power_manager_client_->backlights_forced_off());
   EXPECT_FALSE(power_button_test_api_->IsMenuOpened());
   ReleasePowerButton();
   EXPECT_FALSE(power_button_test_api_->PowerButtonMenuTimerIsRunning());
-  EXPECT_TRUE(power_manager_client()->backlights_forced_off());
+  EXPECT_TRUE(power_manager_client_->backlights_forced_off());
   EXPECT_FALSE(power_button_test_api_->IsMenuOpened());
 
   // Should turn screen on if screen is off.
@@ -269,7 +269,7 @@
   EXPECT_TRUE(power_button_test_api_->PreShutdownTimerIsRunning());
   ReleasePowerButton();
   EXPECT_FALSE(power_button_test_api_->PreShutdownTimerIsRunning());
-  EXPECT_TRUE(power_manager_client()->backlights_forced_off());
+  EXPECT_TRUE(power_manager_client_->backlights_forced_off());
   EXPECT_FALSE(power_button_test_api_->IsMenuOpened());
 
   // Should turn screen on if screen is off.
@@ -285,10 +285,10 @@
   EnableTabletMode(true);
   PressPowerButton();
   ReleasePowerButton();
-  EXPECT_TRUE(power_manager_client()->backlights_forced_off());
+  EXPECT_TRUE(power_manager_client_->backlights_forced_off());
   PressPowerButton();
   ReleasePowerButton();
-  EXPECT_FALSE(power_manager_client()->backlights_forced_off());
+  EXPECT_FALSE(power_manager_client_->backlights_forced_off());
 
   // In laptop mode, tapping the power button shouldn't turn the screen off.
   // Instead, we should start showing the power menu animation.
@@ -297,7 +297,7 @@
   PressPowerButton();
   EXPECT_TRUE(power_button_test_api_->IsMenuOpened());
   ReleasePowerButton();
-  EXPECT_FALSE(power_manager_client()->backlights_forced_off());
+  EXPECT_FALSE(power_manager_client_->backlights_forced_off());
 
   // Tapping power button again in laptop mode when menu is opened should
   // dismiss the menu but keep the screen on.
@@ -307,7 +307,7 @@
   EXPECT_FALSE(power_button_test_api_->PowerButtonMenuTimerIsRunning());
   EXPECT_TRUE(power_button_test_api_->PreShutdownTimerIsRunning());
   ReleasePowerButton();
-  EXPECT_FALSE(power_manager_client()->backlights_forced_off());
+  EXPECT_FALSE(power_manager_client_->backlights_forced_off());
   EXPECT_FALSE(power_button_test_api_->IsMenuOpened());
 }
 
@@ -321,19 +321,19 @@
 
   PressPowerButton();
   ReleasePowerButton();
-  EXPECT_TRUE(power_manager_client()->backlights_forced_off());
+  EXPECT_TRUE(power_manager_client_->backlights_forced_off());
   PressPowerButton();
   ReleasePowerButton();
-  EXPECT_FALSE(power_manager_client()->backlights_forced_off());
+  EXPECT_FALSE(power_manager_client_->backlights_forced_off());
 
   EnableTabletMode(false);
   AdvanceClockToAvoidIgnoring();
   PressPowerButton();
   ReleasePowerButton();
-  EXPECT_TRUE(power_manager_client()->backlights_forced_off());
+  EXPECT_TRUE(power_manager_client_->backlights_forced_off());
   PressPowerButton();
   ReleasePowerButton();
-  EXPECT_FALSE(power_manager_client()->backlights_forced_off());
+  EXPECT_FALSE(power_manager_client_->backlights_forced_off());
 }
 
 // Tests that release power button after menu is opened but before trigger
@@ -342,7 +342,7 @@
   EnableTabletMode(true);
   PressPowerButton();
   EXPECT_TRUE(power_button_test_api_->PowerButtonMenuTimerIsRunning());
-  EXPECT_FALSE(power_manager_client()->backlights_forced_off());
+  EXPECT_FALSE(power_manager_client_->backlights_forced_off());
   ASSERT_TRUE(power_button_test_api_->TriggerPowerButtonMenuTimeout());
   ASSERT_TRUE(power_button_test_api_->TriggerPreShutdownTimeout());
   EXPECT_TRUE(lock_state_test_api_->shutdown_timer_is_running());
@@ -350,7 +350,7 @@
   EXPECT_TRUE(power_button_test_api_->IsMenuOpened());
   EXPECT_FALSE(lock_state_test_api_->shutdown_timer_is_running());
   EXPECT_FALSE(power_button_test_api_->PowerButtonMenuTimerIsRunning());
-  EXPECT_FALSE(power_manager_client()->backlights_forced_off());
+  EXPECT_FALSE(power_manager_client_->backlights_forced_off());
 }
 
 // Tests that tapping the power button dismisses the menu while in laptop mode.
@@ -391,10 +391,10 @@
   EnableTabletMode(true);
   PressLockButton();
   ReleaseLockButton();
-  EXPECT_FALSE(power_manager_client()->backlights_forced_off());
+  EXPECT_FALSE(power_manager_client_->backlights_forced_off());
   PressPowerButton();
   ReleasePowerButton();
-  EXPECT_TRUE(power_manager_client()->backlights_forced_off());
+  EXPECT_TRUE(power_manager_client_->backlights_forced_off());
 
   // Press lock button after tap power button should still lock screen.
   PressPowerButton();
@@ -411,14 +411,14 @@
   // and continue to turn screen off.
   Initialize(ButtonType::NORMAL, LoginStatus::USER);
   EnableTabletMode(true);
-  EXPECT_FALSE(power_manager_client()->backlights_forced_off());
+  EXPECT_FALSE(power_manager_client_->backlights_forced_off());
   PressPowerButton();
   PressLockButton();
   ReleaseLockButton();
   ReleasePowerButton();
   EXPECT_FALSE(lock_state_test_api_->is_animating_lock());
   EXPECT_EQ(0, session_manager_client_->request_lock_screen_call_count());
-  EXPECT_TRUE(power_manager_client()->backlights_forced_off());
+  EXPECT_TRUE(power_manager_client_->backlights_forced_off());
 
   // Turn the screen on.
   PressPowerButton();
@@ -431,7 +431,7 @@
   ReleaseLockButton();
   EXPECT_TRUE(lock_state_test_api_->is_animating_lock());
   EXPECT_EQ(1, session_manager_client_->request_lock_screen_call_count());
-  EXPECT_FALSE(power_manager_client()->backlights_forced_off());
+  EXPECT_FALSE(power_manager_client_->backlights_forced_off());
 }
 
 // Tests tapping power button when device is suspended without backlights forced
@@ -439,11 +439,11 @@
 TEST_F(PowerButtonControllerTest,
        TappingPowerButtonWhenSuspendedWithoutBacklightsForcedOff) {
   EnableTabletMode(true);
-  power_manager_client()->SendSuspendImminent(
+  power_manager_client_->SendSuspendImminent(
       power_manager::SuspendImminent_Reason_OTHER);
   SendBrightnessChange(0, kUserCause);
   // There is a power button pressed here, but PowerButtonEvent is sent later.
-  power_manager_client()->SendSuspendDone();
+  power_manager_client_->SendSuspendDone();
   SendBrightnessChange(kNonZeroBrightness, kUserCause);
 
   // Send the power button event after a short delay and check that backlights
@@ -453,7 +453,7 @@
   EXPECT_TRUE(power_button_test_api_->PowerButtonMenuTimerIsRunning());
   ReleasePowerButton();
   EXPECT_FALSE(power_button_test_api_->PowerButtonMenuTimerIsRunning());
-  EXPECT_FALSE(power_manager_client()->backlights_forced_off());
+  EXPECT_FALSE(power_manager_client_->backlights_forced_off());
 
   // Send the power button event after a longer delay and check that backlights
   // are forced off.
@@ -463,7 +463,7 @@
   ReleasePowerButton();
   SendBrightnessChange(0, kUserCause);
   EXPECT_FALSE(power_button_test_api_->PowerButtonMenuTimerIsRunning());
-  EXPECT_TRUE(power_manager_client()->backlights_forced_off());
+  EXPECT_TRUE(power_manager_client_->backlights_forced_off());
 }
 
 // Tests tapping power button when device is suspended with backlights forced
@@ -474,13 +474,13 @@
   PressPowerButton();
   ReleasePowerButton();
   SendBrightnessChange(0, kUserCause);
-  ASSERT_TRUE(power_manager_client()->backlights_forced_off());
-  power_manager_client()->SendSuspendImminent(
+  ASSERT_TRUE(power_manager_client_->backlights_forced_off());
+  power_manager_client_->SendSuspendImminent(
       power_manager::SuspendImminent_Reason_OTHER);
   // There is a power button pressed here, but PowerButtonEvent is sent later.
   // Because of backlights forced off, resuming system will not restore
   // brightness.
-  power_manager_client()->SendSuspendDone();
+  power_manager_client_->SendSuspendDone();
 
   // Send the power button event after a short delay and check that backlights
   // are not forced off.
@@ -490,7 +490,7 @@
   EXPECT_TRUE(power_button_test_api_->PowerButtonMenuTimerIsRunning());
   ReleasePowerButton();
   EXPECT_FALSE(power_button_test_api_->PowerButtonMenuTimerIsRunning());
-  EXPECT_FALSE(power_manager_client()->backlights_forced_off());
+  EXPECT_FALSE(power_manager_client_->backlights_forced_off());
 
   // Send the power button event after a longer delay and check that backlights
   // are forced off.
@@ -500,7 +500,7 @@
   ReleasePowerButton();
   SendBrightnessChange(0, kUserCause);
   EXPECT_FALSE(power_button_test_api_->PowerButtonMenuTimerIsRunning());
-  EXPECT_TRUE(power_manager_client()->backlights_forced_off());
+  EXPECT_TRUE(power_manager_client_->backlights_forced_off());
 }
 
 // For convertible device working on tablet mode, keyboard/mouse event should
@@ -511,12 +511,12 @@
   PressPowerButton();
   ReleasePowerButton();
   SendBrightnessChange(0, kUserCause);
-  ASSERT_TRUE(power_manager_client()->backlights_forced_off());
+  ASSERT_TRUE(power_manager_client_->backlights_forced_off());
   PressKey(ui::VKEY_L);
-  EXPECT_TRUE(power_manager_client()->backlights_forced_off());
+  EXPECT_TRUE(power_manager_client_->backlights_forced_off());
 
   GenerateMouseMoveEvent();
-  EXPECT_TRUE(power_manager_client()->backlights_forced_off());
+  EXPECT_TRUE(power_manager_client_->backlights_forced_off());
 }
 
 // Tests that a single set of power button pressed-and-released operation should
@@ -530,7 +530,7 @@
   // There are two |power_key_pressed| events and |power_key_released| events
   // generated for each pressing and releasing, and multiple repeating pressed
   // events depending on holding.
-  ASSERT_EQ(0, power_manager_client()->num_set_backlights_forced_off_calls());
+  ASSERT_EQ(0, power_manager_client_->num_set_backlights_forced_off_calls());
   EnableTabletMode(true);
   power_button_test_api_->SendKeyEvent(&power_key_pressed);
   power_button_test_api_->SendKeyEvent(&power_key_pressed);
@@ -541,7 +541,7 @@
   ReleasePowerButton();
   power_button_test_api_->SendKeyEvent(&power_key_released);
   power_button_test_api_->SendKeyEvent(&power_key_released);
-  EXPECT_EQ(1, power_manager_client()->num_set_backlights_forced_off_calls());
+  EXPECT_EQ(1, power_manager_client_->num_set_backlights_forced_off_calls());
 }
 
 // Tests that when the power button is pressed/released in tablet mode,
@@ -590,7 +590,7 @@
   EXPECT_FALSE(power_button_test_api_->PowerButtonMenuTimerIsRunning());
   tick_clock_.Advance(base::TimeDelta::FromMilliseconds(1500));
   ReleasePowerButton();
-  EXPECT_FALSE(power_manager_client()->backlights_forced_off());
+  EXPECT_FALSE(power_manager_client_->backlights_forced_off());
   EXPECT_FALSE(power_button_test_api_->IsMenuOpened());
 }
 
@@ -601,7 +601,7 @@
   PressPowerButton();
   ReleasePowerButton();
   SendBrightnessChange(0, kUserCause);
-  ASSERT_TRUE(power_manager_client()->backlights_forced_off());
+  ASSERT_TRUE(power_manager_client_->backlights_forced_off());
 
   // Test that a pressing-releasing operation after a short duration, backlights
   // forced off is stopped since we don't drop request for power button pressed.
@@ -609,21 +609,21 @@
   PressPowerButton();
   SendBrightnessChange(kNonZeroBrightness, kUserCause);
   ReleasePowerButton();
-  EXPECT_FALSE(power_manager_client()->backlights_forced_off());
+  EXPECT_FALSE(power_manager_client_->backlights_forced_off());
 
   // Test that after another short duration, backlights will not be forced off
   // since this immediately following forcing off request needs to be dropped.
   tick_clock_.Advance(base::TimeDelta::FromMilliseconds(200));
   PressPowerButton();
   ReleasePowerButton();
-  EXPECT_FALSE(power_manager_client()->backlights_forced_off());
+  EXPECT_FALSE(power_manager_client_->backlights_forced_off());
 
   // Test that after another long duration, backlights should be forced off.
   tick_clock_.Advance(base::TimeDelta::FromMilliseconds(800));
   PressPowerButton();
   ReleasePowerButton();
   SendBrightnessChange(0, kUserCause);
-  EXPECT_TRUE(power_manager_client()->backlights_forced_off());
+  EXPECT_TRUE(power_manager_client_->backlights_forced_off());
 }
 
 // Tests that repeated power button releases of clamshell should cancel the
@@ -655,12 +655,12 @@
   EnableTabletMode(true);
   PressPowerButton();
   ReleasePowerButton();
-  ASSERT_TRUE(power_manager_client()->backlights_forced_off());
+  ASSERT_TRUE(power_manager_client_->backlights_forced_off());
 
   // A lid closed event is received, we should stop forcing off backlights.
-  power_manager_client()->SetLidState(PowerManagerClient::LidState::CLOSED,
+  power_manager_client_->SetLidState(PowerManagerClient::LidState::CLOSED,
                                       tick_clock_.NowTicks());
-  EXPECT_FALSE(power_manager_client()->backlights_forced_off());
+  EXPECT_FALSE(power_manager_client_->backlights_forced_off());
 }
 
 // Tests that tablet mode events from powerd stop forcing off backlights.
@@ -668,18 +668,18 @@
   EnableTabletMode(true);
   PressPowerButton();
   ReleasePowerButton();
-  ASSERT_TRUE(power_manager_client()->backlights_forced_off());
-  power_manager_client()->SetTabletMode(PowerManagerClient::TabletMode::OFF,
+  ASSERT_TRUE(power_manager_client_->backlights_forced_off());
+  power_manager_client_->SetTabletMode(PowerManagerClient::TabletMode::OFF,
                                         tick_clock_.NowTicks());
-  EXPECT_FALSE(power_manager_client()->backlights_forced_off());
+  EXPECT_FALSE(power_manager_client_->backlights_forced_off());
 
   AdvanceClockToAvoidIgnoring();
   PressPowerButton();
   ReleasePowerButton();
-  ASSERT_TRUE(power_manager_client()->backlights_forced_off());
-  power_manager_client()->SetTabletMode(PowerManagerClient::TabletMode::ON,
+  ASSERT_TRUE(power_manager_client_->backlights_forced_off());
+  power_manager_client_->SetTabletMode(PowerManagerClient::TabletMode::ON,
                                         tick_clock_.NowTicks());
-  EXPECT_FALSE(power_manager_client()->backlights_forced_off());
+  EXPECT_FALSE(power_manager_client_->backlights_forced_off());
 }
 
 // Tests that with system reboot, the global touchscreen enabled status should
@@ -691,14 +691,14 @@
 
   // Simulate system reboot by resetting backlights forced off state in powerd
   // and PowerButtonController.
-  power_manager_client()->SetBacklightsForcedOff(false);
+  power_manager_client_->SetBacklightsForcedOff(false);
   ResetPowerButtonController();
   SetTabletModeSwitchState(PowerManagerClient::TabletMode::ON);
 
   // Run the event loop for PowerButtonDisplayController to get backlight state
   // and check that the global touchscreen status is correct.
   base::RunLoop().RunUntilIdle();
-  EXPECT_FALSE(power_manager_client()->backlights_forced_off());
+  EXPECT_FALSE(power_manager_client_->backlights_forced_off());
   EXPECT_TRUE(GetGlobalTouchscreenEnabled());
 }
 
@@ -714,7 +714,7 @@
   ReleasePowerButton();
   // Run the event loop for PowerButtonDisplayController to get backlight state.
   base::RunLoop().RunUntilIdle();
-  ASSERT_TRUE(power_manager_client()->backlights_forced_off());
+  ASSERT_TRUE(power_manager_client_->backlights_forced_off());
   EXPECT_TRUE(client.media_sessions_suspended());
 }
 
@@ -726,13 +726,13 @@
   PressPowerButton();
   ReleasePowerButton();
   SendBrightnessChange(0, kUserCause);
-  ASSERT_TRUE(power_manager_client()->backlights_forced_off());
+  ASSERT_TRUE(power_manager_client_->backlights_forced_off());
 
   // Simulate an edge case that system resumes because of tablet power button
   // pressed, but power button event is not delivered.
-  power_manager_client()->SendSuspendDone();
+  power_manager_client_->SendSuspendDone();
 
-  EXPECT_FALSE(power_manager_client()->backlights_forced_off());
+  EXPECT_FALSE(power_manager_client_->backlights_forced_off());
 }
 
 // Tests that during the interval that the display is turning on, tablet power
@@ -742,7 +742,7 @@
   PressPowerButton();
   ReleasePowerButton();
   SendBrightnessChange(0, kUserCause);
-  ASSERT_TRUE(power_manager_client()->backlights_forced_off());
+  ASSERT_TRUE(power_manager_client_->backlights_forced_off());
 
   // Simiulate the backlight no longer being forced off due to a key event
   // (which we need to briefly leave tablet mode to receive). Chrome will
@@ -750,7 +750,7 @@
   EnableTabletMode(false);
   PressKey(ui::VKEY_L);
   SendBrightnessChange(kNonZeroBrightness, kUserCause);
-  EXPECT_FALSE(power_manager_client()->backlights_forced_off());
+  EXPECT_FALSE(power_manager_client_->backlights_forced_off());
 
   // Since display could still be off, ignore additional button presses.
   tick_clock_.Advance(PowerButtonController::kScreenStateChangeDelay -
@@ -758,14 +758,14 @@
   EnableTabletMode(true);
   PressPowerButton();
   ReleasePowerButton();
-  EXPECT_FALSE(power_manager_client()->backlights_forced_off());
+  EXPECT_FALSE(power_manager_client_->backlights_forced_off());
 
   // After waiting long enough, we should be able to force the display off.
   AdvanceClockToAvoidIgnoring();
   PressPowerButton();
   ReleasePowerButton();
   SendBrightnessChange(0, kUserCause);
-  EXPECT_TRUE(power_manager_client()->backlights_forced_off());
+  EXPECT_TRUE(power_manager_client_->backlights_forced_off());
 }
 
 // Tests that a11y alert is sent on tablet power button induced screen state
@@ -904,7 +904,7 @@
   PressPowerButton();
   ReleasePowerButton();
   SendBrightnessChange(0, kUserCause);
-  EXPECT_TRUE(power_manager_client()->backlights_forced_off());
+  EXPECT_TRUE(power_manager_client_->backlights_forced_off());
   EXPECT_FALSE(power_button_test_api_->IsMenuOpened());
 
   // Long press the power button when backlights are off will show the menu.
@@ -918,17 +918,17 @@
   PressPowerButton();
   ReleasePowerButton();
   SendBrightnessChange(0, kUserCause);
-  EXPECT_TRUE(power_manager_client()->backlights_forced_off());
+  EXPECT_TRUE(power_manager_client_->backlights_forced_off());
   EXPECT_FALSE(power_button_test_api_->IsMenuOpened());
 }
 
 // Tests that suspend will dismiss the opened menu.
 TEST_F(PowerButtonControllerTest, SuspendWithMenuOn) {
   OpenPowerButtonMenu();
-  power_manager_client()->SendSuspendImminent(
+  power_manager_client_->SendSuspendImminent(
       power_manager::SuspendImminent_Reason_OTHER);
   EXPECT_FALSE(power_button_test_api_->IsMenuOpened());
-  power_manager_client()->SendSuspendDone();
+  power_manager_client_->SendSuspendDone();
   EXPECT_FALSE(power_button_test_api_->IsMenuOpened());
 }
 
@@ -1079,7 +1079,7 @@
   EXPECT_FALSE(power_button_test_api_->ShowMenuAnimationDone());
   // The partially shown menu should be dismissed by power button up.
   EXPECT_FALSE(power_button_test_api_->IsMenuOpened());
-  EXPECT_TRUE(power_manager_client()->backlights_forced_off());
+  EXPECT_TRUE(power_manager_client_->backlights_forced_off());
 }
 
 class PowerButtonControllerWithPositionTest
@@ -1363,7 +1363,7 @@
       power_button_test_api_->GetMenuBoundsInScreen()));
 }
 
-INSTANTIATE_TEST_SUITE_P(AshPowerButtonPosition,
+INSTANTIATE_TEST_CASE_P(AshPowerButtonPosition,
                          PowerButtonControllerWithPositionTest,
                          testing::Values(PowerButtonPosition::LEFT,
                                          PowerButtonPosition::RIGHT,
--- a/ash/system/power/power_button_display_controller.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/power/power_button_display_controller.cc	2019-05-17 18:53:08.324000000 +0300
@@ -36,7 +36,8 @@
       backlights_forced_off_observer_(this),
       tick_clock_(tick_clock),
       weak_ptr_factory_(this) {
-  chromeos::PowerManagerClient::Get()->AddObserver(this);
+  chromeos::DBusThreadManager::Get()->GetPowerManagerClient()->AddObserver(
+      this);
   ui::InputDeviceManager::GetInstance()->AddObserver(this);
   Shell::Get()->AddPreTargetHandler(this, ui::EventTarget::Priority::kSystem);
 
@@ -46,7 +47,8 @@
 PowerButtonDisplayController::~PowerButtonDisplayController() {
   Shell::Get()->RemovePreTargetHandler(this);
   ui::InputDeviceManager::GetInstance()->RemoveObserver(this);
-  chromeos::PowerManagerClient::Get()->RemoveObserver(this);
+  chromeos::DBusThreadManager::Get()->GetPowerManagerClient()->RemoveObserver(
+      this);
 }
 
 bool PowerButtonDisplayController::IsScreenOn() const {
--- a/ash/system/power/power_button_screenshot_controller_unittest.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/power/power_button_screenshot_controller_unittest.cc	2019-05-17 18:53:08.324000000 +0300
@@ -149,7 +149,7 @@
 
   // Releases power button now should not set display off.
   ReleasePowerButton();
-  EXPECT_FALSE(power_manager_client()->backlights_forced_off());
+  EXPECT_FALSE(power_manager_client_->backlights_forced_off());
   // Releases volume down key, and verifies nothing happens.
   ReleaseKey(ui::VKEY_VOLUME_DOWN);
   EXPECT_EQ(0, GetScreenshotCount());
@@ -174,7 +174,7 @@
   EXPECT_FALSE(LastKeyConsumed());
   // Releases power button now should not set display off.
   ReleasePowerButton();
-  EXPECT_FALSE(power_manager_client()->backlights_forced_off());
+  EXPECT_FALSE(power_manager_client_->backlights_forced_off());
   // Releases volume down key, and verifies nothing happens.
   ReleaseKey(ui::VKEY_VOLUME_DOWN);
   EXPECT_EQ(0, GetScreenshotCount());
@@ -192,7 +192,7 @@
   EXPECT_FALSE(power_button_test_api_->PowerButtonMenuTimerIsRunning());
   ReleasePowerButton();
   ReleaseKey(ui::VKEY_VOLUME_DOWN);
-  EXPECT_FALSE(power_manager_client()->backlights_forced_off());
+  EXPECT_FALSE(power_manager_client_->backlights_forced_off());
 
   // Tests volume up key can stop power button's shutdown timer and power button
   // menu timer. Also tests that volume up key is not consumed.
@@ -203,7 +203,7 @@
   EXPECT_FALSE(power_button_test_api_->PowerButtonMenuTimerIsRunning());
   ReleasePowerButton();
   ReleaseKey(ui::VKEY_VOLUME_UP);
-  EXPECT_FALSE(power_manager_client()->backlights_forced_off());
+  EXPECT_FALSE(power_manager_client_->backlights_forced_off());
   EXPECT_FALSE(LastKeyConsumed());
 }
 
@@ -251,7 +251,7 @@
 
   // Releases power button now should not set display off.
   ReleasePowerButton();
-  EXPECT_FALSE(power_manager_client()->backlights_forced_off());
+  EXPECT_FALSE(power_manager_client_->backlights_forced_off());
   // Releases volume down key, and verifies nothing happens.
   ReleaseKey(ui::VKEY_VOLUME_DOWN);
   EXPECT_EQ(0, GetScreenshotCount());
@@ -282,7 +282,7 @@
   EXPECT_FALSE(LastKeyConsumed());
   // Releases power button now should not set display off.
   ReleasePowerButton();
-  EXPECT_FALSE(power_manager_client()->backlights_forced_off());
+  EXPECT_FALSE(power_manager_client_->backlights_forced_off());
   // Releases volume down key, and verifies nothing happens.
   ReleaseKey(ui::VKEY_VOLUME_DOWN);
   EXPECT_EQ(0, GetScreenshotCount());
@@ -298,7 +298,7 @@
   EXPECT_FALSE(power_button_test_api_->PowerButtonMenuTimerIsRunning());
   ReleasePowerButton();
   ReleaseKey(ui::VKEY_VOLUME_DOWN);
-  EXPECT_FALSE(power_manager_client()->backlights_forced_off());
+  EXPECT_FALSE(power_manager_client_->backlights_forced_off());
 
   // Tests volume up key invalidates the power button behavior. Also
   // tests that volume up key is not consumed.
@@ -308,7 +308,7 @@
   EXPECT_FALSE(power_button_test_api_->PowerButtonMenuTimerIsRunning());
   ReleasePowerButton();
   ReleaseKey(ui::VKEY_VOLUME_UP);
-  EXPECT_FALSE(power_manager_client()->backlights_forced_off());
+  EXPECT_FALSE(power_manager_client_->backlights_forced_off());
   EXPECT_FALSE(LastKeyConsumed());
 }
 
--- a/ash/system/power/power_button_test_base.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/power/power_button_test_base.cc	2019-05-17 18:53:08.324000000 +0300
@@ -33,6 +33,8 @@
   // This also initializes DBusThreadManager.
   std::unique_ptr<chromeos::DBusThreadManagerSetter> dbus_setter =
       chromeos::DBusThreadManager::GetSetterForTesting();
+  power_manager_client_ = new chromeos::FakePowerManagerClient();
+  dbus_setter->SetPowerManagerClient(base::WrapUnique(power_manager_client_));
   session_manager_client_ = new chromeos::FakeSessionManagerClient;
   dbus_setter->SetSessionManagerClient(
       base::WrapUnique(session_manager_client_));
--- a/ash/system/power/power_button_test_base.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/power/power_button_test_base.h	2019-05-17 18:53:08.324000000 +0300
@@ -13,6 +13,7 @@
 #include "ui/events/keycodes/keyboard_codes_posix.h"
 
 namespace chromeos {
+class FakePowerManagerClient;
 class FakeSessionManagerClient;
 }  // namespace chromeos
 
@@ -85,6 +86,7 @@
   void AdvanceClockToAvoidIgnoring();
 
   // Ownership is passed on to chromeos::DBusThreadManager.
+  chromeos::FakePowerManagerClient* power_manager_client_ = nullptr;
   chromeos::FakeSessionManagerClient* session_manager_client_ = nullptr;
 
   PowerButtonController* power_button_controller_ = nullptr;  // Not owned.
--- a/ash/system/power/power_event_observer.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/power/power_event_observer.cc	2019-05-17 18:53:08.324000000 +0300
@@ -218,11 +218,13 @@
                       ? LockState::kLocked
                       : LockState::kUnlocked),
       session_observer_(this) {
-  chromeos::PowerManagerClient::Get()->AddObserver(this);
+  chromeos::DBusThreadManager::Get()->GetPowerManagerClient()->AddObserver(
+      this);
 }
 
 PowerEventObserver::~PowerEventObserver() {
-  chromeos::PowerManagerClient::Get()->RemoveObserver(this);
+  chromeos::DBusThreadManager::Get()->GetPowerManagerClient()->RemoveObserver(
+      this);
 }
 
 void PowerEventObserver::OnLockAnimationsComplete() {
@@ -249,9 +251,9 @@
     power_manager::SuspendImminent::Reason reason) {
   suspend_in_progress_ = true;
 
-  displays_suspended_callback_ =
-      chromeos::PowerManagerClient::Get()->GetSuspendReadinessCallback(
-          FROM_HERE);
+  displays_suspended_callback_ = chromeos::DBusThreadManager::Get()
+                                     ->GetPowerManagerClient()
+                                     ->GetSuspendReadinessCallback(FROM_HERE);
 
   // Stop compositing immediately if
   // * the screen lock flow has already completed
--- a/ash/system/power/power_event_observer_unittest.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/power/power_event_observer_unittest.cc	2019-05-17 18:53:08.324000000 +0300
@@ -70,7 +70,8 @@
 };
 
 TEST_F(PowerEventObserverTest, LockBeforeSuspend) {
-  chromeos::PowerManagerClient* client = chromeos::PowerManagerClient::Get();
+  chromeos::PowerManagerClient* client =
+      chromeos::DBusThreadManager::Get()->GetPowerManagerClient();
   ASSERT_EQ(0, client->GetNumPendingSuspendReadinessCallbacks());
 
   // Check that the observer requests a suspend-readiness callback when it hears
@@ -202,7 +203,8 @@
   SetCanLockScreen(true);
   SetShouldLockScreenAutomatically(true);
 
-  chromeos::PowerManagerClient* client = chromeos::PowerManagerClient::Get();
+  chromeos::PowerManagerClient* client =
+      chromeos::DBusThreadManager::Get()->GetPowerManagerClient();
   observer_->SuspendImminent(power_manager::SuspendImminent_Reason_OTHER);
   EXPECT_EQ(1, client->GetNumPendingSuspendReadinessCallbacks());
 
@@ -234,7 +236,8 @@
 
   UpdateDisplay("100x100,200x200");
 
-  chromeos::PowerManagerClient* client = chromeos::PowerManagerClient::Get();
+  chromeos::PowerManagerClient* client =
+      chromeos::DBusThreadManager::Get()->GetPowerManagerClient();
   observer_->SuspendImminent(power_manager::SuspendImminent_Reason_OTHER);
   EXPECT_EQ(1, client->GetNumPendingSuspendReadinessCallbacks());
 
@@ -282,7 +285,8 @@
 
   UpdateDisplay("100x100,200x200");
 
-  chromeos::PowerManagerClient* client = chromeos::PowerManagerClient::Get();
+  chromeos::PowerManagerClient* client =
+      chromeos::DBusThreadManager::Get()->GetPowerManagerClient();
   observer_->SuspendImminent(power_manager::SuspendImminent_Reason_OTHER);
   EXPECT_EQ(1, client->GetNumPendingSuspendReadinessCallbacks());
 
@@ -318,7 +322,8 @@
   SetCanLockScreen(true);
   SetShouldLockScreenAutomatically(true);
 
-  chromeos::PowerManagerClient* client = chromeos::PowerManagerClient::Get();
+  chromeos::PowerManagerClient* client =
+      chromeos::DBusThreadManager::Get()->GetPowerManagerClient();
   observer_->SuspendImminent(power_manager::SuspendImminent_Reason_OTHER);
   EXPECT_EQ(1, client->GetNumPendingSuspendReadinessCallbacks());
 
@@ -384,7 +389,8 @@
 // another wallpaper after the screen is locked).
 TEST_F(PowerEventObserverTest,
        DisplaysNotReadyForSuspendUntilWallpaperAnimationEnds) {
-  chromeos::PowerManagerClient* client = chromeos::PowerManagerClient::Get();
+  chromeos::PowerManagerClient* client =
+      chromeos::DBusThreadManager::Get()->GetPowerManagerClient();
   ASSERT_EQ(0, client->GetNumPendingSuspendReadinessCallbacks());
 
   SetCanLockScreen(true);
@@ -434,7 +440,8 @@
 // Tests that animated wallpaper changes will be finished immediately when
 // suspend starts (if the screen was locked when suspend started).
 TEST_F(PowerEventObserverTest, EndWallpaperAnimationOnSuspendWhileLocked) {
-  chromeos::PowerManagerClient* client = chromeos::PowerManagerClient::Get();
+  chromeos::PowerManagerClient* client =
+      chromeos::DBusThreadManager::Get()->GetPowerManagerClient();
   ASSERT_EQ(0, client->GetNumPendingSuspendReadinessCallbacks());
 
   SetCanLockScreen(true);
@@ -475,7 +482,8 @@
 // Tests that animated wallpaper changes will be finished immediately when
 // suspend starts (if the screen lock started before suspend).
 TEST_F(PowerEventObserverTest, EndWallpaperAnimationOnSuspendWhileLocking) {
-  chromeos::PowerManagerClient* client = chromeos::PowerManagerClient::Get();
+  chromeos::PowerManagerClient* client =
+      chromeos::DBusThreadManager::Get()->GetPowerManagerClient();
   ASSERT_EQ(0, client->GetNumPendingSuspendReadinessCallbacks());
 
   SetCanLockScreen(true);
@@ -517,7 +525,8 @@
 // Tests that animated wallpaper changes will be finished immediately when
 // suspend starts and causes a screen lock.
 TEST_F(PowerEventObserverTest, EndWallpaperAnimationAfterLockDueToSuspend) {
-  chromeos::PowerManagerClient* client = chromeos::PowerManagerClient::Get();
+  chromeos::PowerManagerClient* client =
+      chromeos::DBusThreadManager::Get()->GetPowerManagerClient();
   ASSERT_EQ(0, client->GetNumPendingSuspendReadinessCallbacks());
 
   SetCanLockScreen(true);
@@ -555,7 +564,8 @@
 // Tests that removing a display while power event observer is waiting for the
 // wallpaper animation does not cause suspend to hang.
 TEST_F(PowerEventObserverTest, DisplayRemovedDuringWallpaperAnimation) {
-  chromeos::PowerManagerClient* client = chromeos::PowerManagerClient::Get();
+  chromeos::PowerManagerClient* client =
+      chromeos::DBusThreadManager::Get()->GetPowerManagerClient();
   ASSERT_EQ(0, client->GetNumPendingSuspendReadinessCallbacks());
 
   SetCanLockScreen(true);
--- a/ash/system/power/power_notification_controller.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/power/power_notification_controller.cc	2019-05-17 18:53:08.324000000 +0300
@@ -185,20 +185,10 @@
 }
 
 bool PowerNotificationController::UpdateNotificationStateForRemainingTime() {
-  const base::Optional<base::TimeDelta> remaining_time =
-      PowerStatus::Get()->GetBatteryTimeToEmpty();
-
-  // Check that powerd actually provided an estimate. It doesn't if the battery
-  // current is so close to zero that the estimate would be huge.
-  if (!remaining_time) {
-    notification_state_ = NOTIFICATION_NONE;
-    return false;
-  }
-
   // The notification includes a rounded minutes value, so round the estimate
   // received from the power manager to match.
-  const int remaining_minutes =
-      static_cast<int>(remaining_time->InSecondsF() / 60.0 + 0.5);
+  const int remaining_minutes = static_cast<int>(
+      PowerStatus::Get()->GetBatteryTimeToEmpty().InSecondsF() / 60.0 + 0.5);
 
   if (remaining_minutes >= kNoWarningMinutes ||
       PowerStatus::Get()->IsBatteryFull()) {
--- a/ash/system/power/power_notification_controller_unittest.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/power/power_notification_controller_unittest.cc	2019-05-17 18:53:08.324000000 +0300
@@ -494,13 +494,4 @@
   }
 }
 
-// Test that a notification isn't shown if powerd sends a -1 time-to-empty value
-// to indicate that it couldn't produce an estimate: https://crbug.com/930358
-TEST_F(PowerNotificationControllerTest, IgnoreMissingBatteryEstimates) {
-  PowerSupplyProperties proto = DefaultPowerSupplyProperties();
-  proto.set_battery_time_to_empty_sec(-1);
-  UpdateNotificationState(proto, PowerNotificationController::NOTIFICATION_NONE,
-                          false, false);
-}
-
 }  // namespace ash
--- a/ash/system/power/power_prefs_unittest.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/power/power_prefs_unittest.cc	2019-05-17 18:53:08.324000000 +0300
@@ -17,6 +17,7 @@
 #include "ash/test/ash_test_base.h"
 #include "base/macros.h"
 #include "base/test/simple_test_tick_clock.h"
+#include "chromeos/dbus/dbus_thread_manager.h"
 #include "chromeos/dbus/fake_power_manager_client.h"
 #include "chromeos/dbus/power_manager/idle.pb.h"
 #include "chromeos/dbus/power_policy_controller.h"
@@ -48,9 +49,6 @@
 
 std::string GetExpectedPowerPolicyForPrefs(PrefService* prefs,
                                            ScreenLockState screen_lock_state) {
-  const bool is_smart_dim_enabled =
-      prefs->GetBoolean(prefs::kPowerSmartDimEnabled);
-
   power_manager::PowerManagementPolicy expected_policy;
   expected_policy.mutable_ac_delays()->set_screen_dim_ms(
       prefs->GetInteger(screen_lock_state == ScreenLockState::LOCKED
@@ -93,17 +91,10 @@
       prefs->GetBoolean(prefs::kPowerUseAudioActivity));
   expected_policy.set_use_video_activity(
       prefs->GetBoolean(prefs::kPowerUseVideoActivity));
-  if (is_smart_dim_enabled) {
-    // Screen-dim scaling factors are disabled by PowerPolicyController when
-    // smart-dimming is enabled.
-    expected_policy.set_presentation_screen_dim_delay_factor(1.0);
-    expected_policy.set_user_activity_screen_dim_delay_factor(1.0);
-  } else {
     expected_policy.set_presentation_screen_dim_delay_factor(
         prefs->GetDouble(prefs::kPowerPresentationScreenDimDelayFactor));
     expected_policy.set_user_activity_screen_dim_delay_factor(
         prefs->GetDouble(prefs::kPowerUserActivityScreenDimDelayFactor));
-  }
   expected_policy.set_wait_for_initial_user_activity(
       prefs->GetBoolean(prefs::kPowerWaitForInitialUserActivity));
   expected_policy.set_force_nonzero_brightness_for_user_activity(
@@ -125,6 +116,10 @@
 
   // NoSessionAshTestBase:
   void SetUp() override {
+    fake_power_manager_client_ = new chromeos::FakePowerManagerClient;
+    chromeos::DBusThreadManager::GetSetterForTesting()->SetPowerManagerClient(
+        base::WrapUnique(fake_power_manager_client_));
+
     NoSessionAshTestBase::SetUp();
 
     power_policy_controller_ = chromeos::PowerPolicyController::Get();
@@ -140,7 +135,7 @@
 
   std::string GetCurrentPowerPolicy() const {
     return chromeos::PowerPolicyController::GetPolicyDebugString(
-        power_manager_client()->policy());
+        fake_power_manager_client_->policy());
   }
 
   bool GetCurrentAllowScreenWakeLocks() const {
@@ -149,9 +144,9 @@
 
   std::vector<power_manager::PowerManagementPolicy_Action>
   GetCurrentPowerPolicyActions() const {
-    return {power_manager_client()->policy().ac_idle_action(),
-            power_manager_client()->policy().battery_idle_action(),
-            power_manager_client()->policy().lid_closed_action()};
+    return {fake_power_manager_client_->policy().ac_idle_action(),
+            fake_power_manager_client_->policy().battery_idle_action(),
+            fake_power_manager_client_->policy().lid_closed_action()};
   }
 
   void SetLockedState(ScreenLockState lock_state) {
@@ -163,9 +158,12 @@
   void NotifyScreenIdleOffChanged(bool off) {
     power_manager::ScreenIdleState proto;
     proto.set_off(off);
-    power_manager_client()->SendScreenIdleStateChanged(proto);
+    fake_power_manager_client_->SendScreenIdleStateChanged(proto);
   }
 
+  // Owned by chromeos::DBusThreadManager.
+  chromeos::FakePowerManagerClient* fake_power_manager_client_;
+
   chromeos::PowerPolicyController* power_policy_controller_ =
       nullptr;                         // Not owned.
   PowerPrefs* power_prefs_ = nullptr;  // Not owned.
--- a/ash/system/power/power_status.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/power/power_status.cc	2019-05-17 18:53:08.324000000 +0300
@@ -240,7 +240,9 @@
 }
 
 void PowerStatus::RequestStatusUpdate() {
-  chromeos::PowerManagerClient::Get()->RequestStatusUpdate();
+  chromeos::DBusThreadManager::Get()
+      ->GetPowerManagerClient()
+      ->RequestStatusUpdate();
 }
 
 bool PowerStatus::IsBatteryPresent() const {
@@ -276,23 +278,11 @@
   return proto_.is_calculating_battery_time();
 }
 
-base::Optional<base::TimeDelta> PowerStatus::GetBatteryTimeToEmpty() const {
-  // powerd omits the field if no battery is present and sends -1 if it couldn't
-  // compute a reasonable estimate.
-  if (!proto_.has_battery_time_to_empty_sec() ||
-      proto_.battery_time_to_empty_sec() < 0) {
-    return base::nullopt;
-  }
+base::TimeDelta PowerStatus::GetBatteryTimeToEmpty() const {
   return base::TimeDelta::FromSeconds(proto_.battery_time_to_empty_sec());
 }
 
-base::Optional<base::TimeDelta> PowerStatus::GetBatteryTimeToFull() const {
-  // powerd omits the field if no battery is present and sends -1 if it couldn't
-  // compute a reasonable estimate.
-  if (!proto_.has_battery_time_to_full_sec() ||
-      proto_.battery_time_to_full_sec() < 0) {
-    return base::nullopt;
-  }
+base::TimeDelta PowerStatus::GetBatteryTimeToFull() const {
   return base::TimeDelta::FromSeconds(proto_.battery_time_to_full_sec());
 }
 
@@ -394,12 +384,12 @@
       IsBatteryCharging()
           ? IDS_ASH_STATUS_TRAY_BATTERY_PERCENT_CHARGING_ACCESSIBLE
           : IDS_ASH_STATUS_TRAY_BATTERY_PERCENT_ACCESSIBLE,
-      base::NumberToString16(GetRoundedBatteryPercent()));
+      base::IntToString16(GetRoundedBatteryPercent()));
   if (!full_description)
     return battery_percentage_accessible;
 
   base::string16 battery_time_accessible = base::string16();
-  const base::Optional<base::TimeDelta> time =
+  const base::TimeDelta time =
       IsBatteryCharging() ? GetBatteryTimeToFull() : GetBatteryTimeToEmpty();
 
   if (IsUsbChargerConnected()) {
@@ -408,13 +398,13 @@
   } else if (IsBatteryTimeBeingCalculated()) {
     battery_time_accessible = l10n_util::GetStringUTF16(
         IDS_ASH_STATUS_TRAY_BATTERY_CALCULATING_ACCESSIBLE);
-  } else if (time && power_utils::ShouldDisplayBatteryTime(*time) &&
+  } else if (power_utils::ShouldDisplayBatteryTime(time) &&
              !IsBatteryDischargingOnLinePower()) {
     int hour = 0, min = 0;
-    power_utils::SplitTimeIntoHoursAndMinutes(*time, &hour, &min);
+    power_utils::SplitTimeIntoHoursAndMinutes(time, &hour, &min);
     base::string16 minute =
-        min < 10 ? base::ASCIIToUTF16("0") + base::NumberToString16(min)
-                 : base::NumberToString16(min);
+        min < 10 ? base::ASCIIToUTF16("0") + base::IntToString16(min)
+                 : base::IntToString16(min);
     battery_time_accessible = l10n_util::GetStringFUTF16(
         IsBatteryCharging()
             ? IDS_ASH_STATUS_TRAY_BATTERY_TIME_UNTIL_FULL_ACCESSIBLE
@@ -442,15 +432,14 @@
       status =
           l10n_util::GetStringUTF16(IDS_ASH_STATUS_TRAY_BATTERY_CALCULATING);
     } else {
-      base::Optional<base::TimeDelta> time = IsBatteryCharging()
-                                                 ? GetBatteryTimeToFull()
+      base::TimeDelta time = IsBatteryCharging() ? GetBatteryTimeToFull()
                                                  : GetBatteryTimeToEmpty();
-      if (time && power_utils::ShouldDisplayBatteryTime(*time) &&
+      if (power_utils::ShouldDisplayBatteryTime(time) &&
           !IsBatteryDischargingOnLinePower()) {
         base::string16 duration;
-        if (!base::TimeDurationFormat(*time, base::DURATION_WIDTH_NUMERIC,
+        if (!base::TimeDurationFormat(time, base::DURATION_WIDTH_NUMERIC,
                                       &duration))
-          LOG(ERROR) << "Failed to format duration " << *time;
+          LOG(ERROR) << "Failed to format duration " << time;
         status = l10n_util::GetStringFUTF16(
             IsBatteryCharging()
                 ? IDS_ASH_STATUS_TRAY_BATTERY_TIME_UNTIL_FULL_SHORT
@@ -481,12 +470,16 @@
 }
 
 PowerStatus::PowerStatus() {
-  chromeos::PowerManagerClient::Get()->AddObserver(this);
-  chromeos::PowerManagerClient::Get()->RequestStatusUpdate();
+  chromeos::DBusThreadManager::Get()->GetPowerManagerClient()->AddObserver(
+      this);
+  chromeos::DBusThreadManager::Get()
+      ->GetPowerManagerClient()
+      ->RequestStatusUpdate();
 }
 
 PowerStatus::~PowerStatus() {
-  chromeos::PowerManagerClient::Get()->RemoveObserver(this);
+  chromeos::DBusThreadManager::Get()->GetPowerManagerClient()->RemoveObserver(
+      this);
 }
 
 void PowerStatus::SetProtoForTesting(
--- a/ash/system/power/power_status.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/power/power_status.h	2019-05-17 18:53:08.324000000 +0300
@@ -11,7 +11,6 @@
 #include "ash/ash_export.h"
 #include "base/macros.h"
 #include "base/observer_list.h"
-#include "base/optional.h"
 #include "base/strings/string16.h"
 #include "base/time/time.h"
 #include "chromeos/dbus/power_manager/power_supply_properties.pb.h"
@@ -147,12 +146,8 @@
   // Returns the estimated time until the battery is empty (if line power
   // is disconnected) or full (if line power is connected). These estimates
   // should only be used if IsBatteryTimeBeingCalculated() returns false.
-  //
-  // Irrespective of IsBatteryTimeBeingCalculated(), estimates may be
-  // unavailable if powerd didn't provide them because the battery current was
-  // close to zero (resulting in time estimates approaching infinity).
-  base::Optional<base::TimeDelta> GetBatteryTimeToEmpty() const;
-  base::Optional<base::TimeDelta> GetBatteryTimeToFull() const;
+  base::TimeDelta GetBatteryTimeToEmpty() const;
+  base::TimeDelta GetBatteryTimeToFull() const;
 
   // Returns true if line power (including a charger of any type) is connected.
   bool IsLinePowerConnected() const;
--- a/ash/system/power/power_status_unittest.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/power/power_status_unittest.cc	2019-05-17 18:53:08.324000000 +0300
@@ -9,7 +9,7 @@
 #include "ash/resources/vector_icons/vector_icons.h"
 #include "base/run_loop.h"
 #include "base/test/scoped_task_environment.h"
-#include "chromeos/dbus/power_manager_client.h"
+#include "chromeos/dbus/dbus_thread_manager.h"
 #include "testing/gtest/include/gtest/gtest.h"
 #include "third_party/cros_system_api/dbus/service_constants.h"
 #include "ui/gfx/image/image.h"
@@ -47,7 +47,7 @@
   ~PowerStatusTest() override = default;
 
   void SetUp() override {
-    chromeos::PowerManagerClient::Initialize();
+    chromeos::DBusThreadManager::Initialize();
     PowerStatus::Initialize();
     power_status_ = PowerStatus::Get();
     test_observer_.reset(new TestObserver);
@@ -58,7 +58,7 @@
     power_status_->RemoveObserver(test_observer_.get());
     test_observer_.reset();
     PowerStatus::Shutdown();
-    chromeos::PowerManagerClient::Shutdown();
+    chromeos::DBusThreadManager::Shutdown();
   }
 
  protected:
@@ -236,59 +236,4 @@
   EXPECT_FALSE(gfx::test::AreImagesEqual(image_99, image_100));
 }
 
-// Tests that positive time-to-full and time-to-empty estimates are honored.
-TEST_F(PowerStatusTest, PositiveBatteryTimeEstimates) {
-  constexpr auto kTime = base::TimeDelta::FromSeconds(120);
-
-  PowerSupplyProperties prop;
-  prop.set_external_power(PowerSupplyProperties::AC);
-  prop.set_battery_state(PowerSupplyProperties::CHARGING);
-  prop.set_battery_time_to_full_sec(kTime.InSeconds());
-  power_status_->SetProtoForTesting(prop);
-  base::Optional<base::TimeDelta> time = power_status_->GetBatteryTimeToFull();
-  ASSERT_TRUE(time);
-  EXPECT_EQ(kTime, *time);
-
-  prop.Clear();
-  prop.set_external_power(PowerSupplyProperties::DISCONNECTED);
-  prop.set_battery_state(PowerSupplyProperties::DISCHARGING);
-  prop.set_battery_time_to_empty_sec(kTime.InSeconds());
-  power_status_->SetProtoForTesting(prop);
-  time = power_status_->GetBatteryTimeToEmpty();
-  ASSERT_TRUE(time);
-  EXPECT_EQ(kTime, *time);
-}
-
-// Tests that missing time-to-full and time-to-empty estimates (which powerd
-// sends when no battery is present) and negative ones (which powerd sends when
-// the battery current is close to zero) are disregarded:
-// https://crbug.com/930358
-TEST_F(PowerStatusTest, MissingBatteryTimeEstimates) {
-  // No battery.
-  PowerSupplyProperties prop;
-  prop.set_external_power(PowerSupplyProperties::AC);
-  prop.set_battery_state(PowerSupplyProperties::NOT_PRESENT);
-  power_status_->SetProtoForTesting(prop);
-  base::Optional<base::TimeDelta> time = power_status_->GetBatteryTimeToFull();
-  EXPECT_FALSE(time) << *time << " returned despite missing battery";
-  time = power_status_->GetBatteryTimeToEmpty();
-  EXPECT_FALSE(time) << *time << " returned despite missing battery";
-
-  // Battery is charging, but negative estimate provided.
-  prop.set_battery_state(PowerSupplyProperties::CHARGING);
-  prop.set_battery_time_to_full_sec(-1);
-  power_status_->SetProtoForTesting(prop);
-  time = power_status_->GetBatteryTimeToFull();
-  EXPECT_FALSE(time) << *time << " returned despite negative estimate";
-
-  // Battery is discharging, but negative estimate provided.
-  prop.Clear();
-  prop.set_external_power(PowerSupplyProperties::DISCONNECTED);
-  prop.set_battery_state(PowerSupplyProperties::DISCHARGING);
-  prop.set_battery_time_to_empty_sec(-1);
-  power_status_->SetProtoForTesting(prop);
-  time = power_status_->GetBatteryTimeToEmpty();
-  EXPECT_FALSE(time) << *time << " returned despite negative estimate";
-}
-
 }  // namespace ash
--- a/ash/system/power/tray_power.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/power/tray_power.cc	2019-05-17 18:53:08.328000000 +0300
@@ -109,11 +109,9 @@
   info_ = info;
   icon_session_state_color_ = session_state;
 
-  // Note: The icon color (both fg and bg) changes when the UI in in OOBE mode.
-  SkColor icon_fg_color = TrayIconColor(session_state);
-  SkColor icon_bg_color = SkColorSetA(icon_fg_color, kTrayIconBackgroundAlpha);
   image_view()->SetImage(PowerStatus::GetBatteryImage(
-      info, kUnifiedTrayIconSize, icon_bg_color, icon_fg_color));
+      info, TrayConstants::GetTrayIconSize(), kTrayIconBackgroundColor,
+      TrayIconColor(session_state)));
 }
 
 }  // namespace tray
--- a/ash/system/power/video_activity_notifier.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/power/video_activity_notifier.cc	2019-05-17 18:53:08.328000000 +0300
@@ -71,8 +71,10 @@
 
 void VideoActivityNotifier::MaybeNotifyPowerManager() {
   if (should_notify_power_manager()) {
-    chromeos::PowerManagerClient::Get()->NotifyVideoActivity(
-        video_state_ == VideoDetector::State::PLAYING_FULLSCREEN);
+    chromeos::DBusThreadManager::Get()
+        ->GetPowerManagerClient()
+        ->NotifyVideoActivity(video_state_ ==
+                              VideoDetector::State::PLAYING_FULLSCREEN);
   }
 }
 
--- a/ash/system/power/video_activity_notifier.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/power/video_activity_notifier.h	2019-05-17 18:53:08.328000000 +0300
@@ -11,7 +11,6 @@
 #include "base/compiler_specific.h"
 #include "base/macros.h"
 #include "base/time/time.h"
-#include "base/timer/timer.h"
 
 namespace ash {
 
--- a/ash/system/power/video_activity_notifier_unittest.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/power/video_activity_notifier_unittest.cc	2019-05-17 18:53:08.328000000 +0300
@@ -22,7 +22,7 @@
   void SetUp() override {
     AshTestBase::SetUp();
     power_client_ = static_cast<chromeos::FakePowerManagerClient*>(
-        chromeos::PowerManagerClient::Get());
+        chromeos::DBusThreadManager::Get()->GetPowerManagerClient());
     detector_ = std::make_unique<VideoDetector>();
     notifier_.reset(new VideoActivityNotifier(detector_.get()));
   }
--- a/ash/system/screen_layout_observer.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/screen_layout_observer.cc	2019-05-17 18:53:08.328000000 +0300
@@ -219,20 +219,9 @@
 
 bool ScreenLayoutObserver::GetDisplayMessageForNotification(
     const ScreenLayoutObserver::DisplayInfoMap& old_info,
-    bool should_notify_has_unassociated_display,
     base::string16* out_message,
     base::string16* out_additional_message) {
   if (old_display_mode_ != current_display_mode_) {
-    // Ensure that user still gets notified of connecting with excessive
-    // displays when display mode changes. For example, for the device which is
-    // in tablet mode and screen layout is in extending mode, user connects one
-    // additional external display to make the number of displays exceed the
-    // maximum that device can support. Display mode changes from extending mode
-    // to mirror mode.
-    if (should_notify_has_unassociated_display)
-      *out_additional_message = l10n_util::GetStringUTF16(
-          IDS_ASH_STATUS_TRAY_DISPLAY_REMOVED_EXCEEDED_MAXIMUM);
-
     // Detect changes in the mirror mode status.
     if (current_display_mode_ == DisplayMode::MIRRORING) {
       *out_message = GetEnterMirrorModeMessage();
@@ -272,9 +261,7 @@
           GetDisplayRemovedMessage(iter.second, out_additional_message);
       return true;
     }
-  }
-
-  if (display_info_.size() > old_info.size()) {
+  } else if (display_info_.size() > old_info.size()) {
     // A display has been added.
     for (const auto& iter : display_info_) {
       if (old_info.count(iter.first))
@@ -285,18 +272,6 @@
     }
   }
 
-  DCHECK_EQ(display_info_.size(), old_info.size());
-
-  if (should_notify_has_unassociated_display) {
-    // When user connects more external display than the maximum that device
-    // can support, |display_info_|'s size should be same with |old_info_|
-    // because the displays which have unassociated crtc are not included in
-    // |display_info_|.
-    *out_additional_message = l10n_util::GetStringUTF16(
-        IDS_ASH_STATUS_TRAY_DISPLAY_REMOVED_EXCEEDED_MAXIMUM);
-    return true;
-  }
-
   for (const auto& iter : display_info_) {
     DisplayInfoMap::const_iterator old_iter = old_info.find(iter.first);
     if (old_iter == old_info.end()) {
@@ -410,20 +385,6 @@
   DisplayInfoMap old_info;
   UpdateDisplayInfo(&old_info);
 
-  const bool current_has_unassociated_display =
-      ash::Shell::Get()->display_manager()->HasUnassociatedDisplay();
-
-  // Take |has_unassociated_display_| into consideration in order to avoid
-  // showing the notification too frequently. For example, user connects three
-  // displays with device which supports at most two displays. Without checking
-  // |has_unassociated_display_|, if user keeps three displays connected,
-  // any event changing the display configuration would trigger the notification
-  // of the unassociated display.
-  const bool should_notify_has_unassociated_display =
-      !has_unassociated_display_ && current_has_unassociated_display;
-
-  has_unassociated_display_ = current_has_unassociated_display;
-
   old_display_mode_ = current_display_mode_;
   if (GetDisplayManager()->IsInMirrorMode())
     current_display_mode_ = DisplayMode::MIRRORING;
@@ -443,18 +404,46 @@
 
   base::string16 message;
   base::string16 additional_message;
-  if (GetDisplayMessageForNotification(old_info,
-                                       should_notify_has_unassociated_display,
-                                       &message, &additional_message))
+  if (GetDisplayMessageForNotification(old_info, &message, &additional_message))
     CreateOrUpdateNotification(message, additional_message);
 }
 
 bool ScreenLayoutObserver::GetExitMirrorModeMessage(
     base::string16* out_message,
     base::string16* out_additional_message) {
+  if (GetDisplayManager()->is_multi_mirroring_enabled()) {
   *out_message =
       l10n_util::GetStringUTF16(IDS_ASH_STATUS_TRAY_DISPLAY_MIRROR_EXIT);
   return true;
+  }
+  switch (current_display_mode_) {
+    case DisplayMode::EXTENDED_3_PLUS:
+      // Mirror mode was turned off due to having more than two displays.
+      // Show a message that mirror mode for 3+ displays is not supported.
+      *out_message =
+          l10n_util::GetStringUTF16(IDS_ASH_DISPLAY_MIRRORING_NOT_SUPPORTED);
+      return true;
+
+    case DisplayMode::DOCKED:
+      // Handle disabling mirror mode as a result of going to docked mode
+      // when we only have a single display (this means we actually have two
+      // physical displays, one of which is the internal display, but they
+      // were in mirror mode, and hence considered as one. Closing the
+      // internal display disables mirror mode and we still have a single
+      // active display).
+      // Falls through.
+    case DisplayMode::SINGLE:
+      // We're exiting mirror mode because we removed one of the two
+      // displays.
+      *out_message =
+          l10n_util::GetStringUTF16(IDS_ASH_STATUS_TRAY_DISPLAY_MIRROR_EXIT);
+      return true;
+
+    default:
+      // Mirror mode was turned off; other messages should be shown e.g.
+      // extended mode is on, ... etc.
+      return false;
+  }
 }
 
 }  // namespace ash
--- a/ash/system/screen_layout_observer.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/screen_layout_observer.h	2019-05-17 18:53:08.328000000 +0300
@@ -42,8 +42,6 @@
   }
 
  private:
-  FRIEND_TEST_ALL_PREFIXES(ScreenLayoutObserverTestMultiMirroring,
-                           DisplayNotifications);
   friend class ScreenLayoutObserverTest;
 
   using DisplayInfoMap = std::map<int64_t, display::ManagedDisplayInfo>;
@@ -58,9 +56,7 @@
   // |out_message| to empty, which means the notification should be removed. It
   // also sets |out_additional_message| which appears in the notification with
   // the |out_message|.
-  bool GetDisplayMessageForNotification(
-      const DisplayInfoMap& old_info,
-      bool should_notify_has_unassociated_display,
+  bool GetDisplayMessageForNotification(const DisplayInfoMap& old_info,
       base::string16* out_message,
       base::string16* out_additional_message);
 
@@ -87,8 +83,6 @@
   DisplayMode old_display_mode_ = DisplayMode::SINGLE;
   DisplayMode current_display_mode_ = DisplayMode::SINGLE;
 
-  bool has_unassociated_display_ = false;
-
   // When the UI scale of a display is modified from the Settings UI, we should
   // ignore this change and avoid showing a notification for it.
   std::set<int64_t> displays_changed_from_settings_ui_;
--- a/ash/system/screen_layout_observer_unittest.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/screen_layout_observer_unittest.cc	2019-05-17 18:53:08.328000000 +0300
@@ -128,7 +128,34 @@
   return nullptr;
 }
 
-TEST_F(ScreenLayoutObserverTest, DisplayNotifications) {
+class ScreenLayoutObserverTestMultiMirroring
+    : public ScreenLayoutObserverTest,
+      public testing::WithParamInterface<bool> {
+ public:
+  ScreenLayoutObserverTestMultiMirroring() = default;
+  ~ScreenLayoutObserverTestMultiMirroring() override = default;
+
+ protected:
+  void SetUp() override {
+    bool should_disable_multi_mirroring = GetParam();
+    if (should_disable_multi_mirroring) {
+      base::CommandLine::ForCurrentProcess()->AppendSwitch(
+          ::switches::kDisableMultiMirroring);
+    }
+    ScreenLayoutObserverTest::SetUp();
+  }
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(ScreenLayoutObserverTestMultiMirroring);
+};
+
+// Instantiate the boolean which is used to enable/disable multi-mirroring in
+// the parameterized tests.
+INSTANTIATE_TEST_CASE_P(,
+                        ScreenLayoutObserverTestMultiMirroring,
+                        testing::Bool());
+
+TEST_P(ScreenLayoutObserverTestMultiMirroring, DisplayNotifications) {
   Shell::Get()->screen_layout_observer()->set_show_notifications_for_testing(
       true);
 
@@ -180,50 +207,6 @@
   display_info_list.emplace_back(second_display_info);
   display_manager()->OnNativeDisplaysChanged(display_info_list);
 
-  // Simulate that device can support at most two displays and user
-  // connects it with three displays. Notification should be created to warn
-  // user of it. See issue 827406 (https://crbug.com/827406).
-  display::test::DisplayManagerTestApi(Shell::Get()->display_manager())
-      .set_maximum_display(2u);
-  UpdateDisplay("400x400,200x200,100x100");
-  EXPECT_TRUE(GetDisplayNotificationText().empty());
-  EXPECT_EQ(l10n_util::GetStringUTF16(
-                IDS_ASH_STATUS_TRAY_DISPLAY_REMOVED_EXCEEDED_MAXIMUM),
-            GetDisplayNotificationAdditionalText());
-  EXPECT_TRUE(GetDisplayNotificationText().empty());
-  UpdateDisplay("400x400,200x200");
-  CloseNotification();
-
-  // Start tablet mode and wait until display mode is updated.
-  Shell::Get()->tablet_mode_controller()->EnableTabletModeWindowManager(true);
-  base::RunLoop().RunUntilIdle();
-
-  // Exit mirror mode manually. Now display mode should be extending mode.
-  display_manager()->SetMirrorMode(display::MirrorMode::kOff, base::nullopt);
-  EXPECT_EQ(l10n_util::GetStringUTF16(IDS_ASH_STATUS_TRAY_DISPLAY_MIRROR_EXIT),
-            GetDisplayNotificationText());
-  CloseNotification();
-
-  // Simulate that device can support at most two displays and user connects
-  // it with three displays. Because device is in tablet mode, display mode
-  // becomes mirror mode from extending mode. Under this circumstance, user is
-  // still notified of connecting more displays than maximum. See issue 827406
-  // (https://crbug.com/827406).
-  UpdateDisplay("400x400,200x200,100x100");
-  EXPECT_EQ(l10n_util::GetStringUTF16(
-                IDS_ASH_STATUS_TRAY_DISPLAY_REMOVED_EXCEEDED_MAXIMUM),
-            GetDisplayNotificationAdditionalText());
-  EXPECT_EQ(l10n_util::GetStringFUTF16(IDS_ASH_STATUS_TRAY_DISPLAY_MIRRORING,
-                                       GetMirroringDisplayNames()),
-            GetDisplayNotificationText());
-
-  // Reset the parameter. Close tablet mode and wait until display mode is
-  // updated.
-  display::test::DisplayManagerTestApi(Shell::Get()->display_manager())
-      .ResetMaximumDisplay();
-  Shell::Get()->tablet_mode_controller()->EnableTabletModeWindowManager(false);
-  base::RunLoop().RunUntilIdle();
-
   // Turn on mirror mode.
   CloseNotification();
   display_manager()->SetMirrorMode(display::MirrorMode::kNormal, base::nullopt);
@@ -252,8 +235,15 @@
   // Turn off mirror mode.
   CloseNotification();
   display_manager()->SetMirrorMode(display::MirrorMode::kOff, base::nullopt);
-  EXPECT_EQ(l10n_util::GetStringUTF16(IDS_ASH_STATUS_TRAY_DISPLAY_MIRROR_EXIT),
+  if (display_manager()->is_multi_mirroring_enabled()) {
+    EXPECT_EQ(
+        l10n_util::GetStringUTF16(IDS_ASH_STATUS_TRAY_DISPLAY_MIRROR_EXIT),
+        GetDisplayNotificationText());
+  } else {
+    EXPECT_EQ(l10n_util::GetStringFUTF16(IDS_ASH_STATUS_TRAY_DISPLAY_EXTENDED,
+                                         GetSecondDisplayName()),
             GetDisplayNotificationText());
+  }
   EXPECT_TRUE(GetDisplayNotificationAdditionalText().empty());
 
   // Rotate the second.
@@ -405,6 +395,37 @@
             GetDisplayNotificationText());
 }
 
+// TODO(crbug.com/774795) Remove this test when multi mirroring is enabled by
+// default.
+// Tests that exiting mirror mode because of adding a third display shows the
+// correct "3+ displays mirror mode is not supported" message.
+TEST_P(ScreenLayoutObserverTestMultiMirroring,
+       ExitMirrorModeBecauseOfThirdDisplayMessage) {
+  if (display_manager()->is_multi_mirroring_enabled()) {
+    // This test is not neccessary when mirroring across 3+ displays is
+    // supported.
+    return;
+  }
+  Shell::Get()->screen_layout_observer()->set_show_notifications_for_testing(
+      true);
+  UpdateDisplay("400x400,200x200");
+  display::Display::SetInternalDisplayId(
+      display_manager()->GetSecondaryDisplay().id());
+
+  // Mirroring.
+  UpdateDisplay("400x400,200x200");
+  display_manager()->SetMirrorMode(display::MirrorMode::kNormal, base::nullopt);
+  EXPECT_EQ(l10n_util::GetStringFUTF16(IDS_ASH_STATUS_TRAY_DISPLAY_MIRRORING,
+                                       GetMirroringDisplayNames()),
+            GetDisplayNotificationText());
+
+  // Adding a third display. Mirror mode for 3+ displays is not supported.
+  CloseNotification();
+  UpdateDisplay("400x400,200x200,100x100");
+  EXPECT_EQ(l10n_util::GetStringUTF16(IDS_ASH_DISPLAY_MIRRORING_NOT_SUPPORTED),
+            GetDisplayNotificationText());
+}
+
 // Special case: tests that exiting mirror mode by removing a display shows the
 // correct message.
 TEST_F(ScreenLayoutObserverTest,
--- a/ash/system/screen_security/screen_security_notification_controller.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/screen_security/screen_security_notification_controller.cc	2019-05-17 18:53:08.328000000 +0300
@@ -9,7 +9,6 @@
 #include "ash/shell.h"
 #include "ash/strings/grit/ash_strings.h"
 #include "ash/system/tray/system_tray_notifier.h"
-#include "base/bind.h"
 #include "ui/base/l10n/l10n_util.h"
 #include "ui/message_center/message_center.h"
 #include "ui/message_center/public/cpp/notification.h"
--- a/ash/system/screen_security/screen_security_notification_controller_unittest.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/screen_security/screen_security_notification_controller_unittest.cc	2019-05-17 18:53:08.328000000 +0300
@@ -7,7 +7,6 @@
 #include "ash/shell.h"
 #include "ash/system/tray/system_tray_notifier.h"
 #include "ash/test/ash_test_base.h"
-#include "base/bind_helpers.h"
 #include "ui/message_center/message_center.h"
 
 namespace ash {
--- a/ash/system/session/logout_button_tray.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/session/logout_button_tray.cc	2019-05-17 18:53:08.328000000 +0300
@@ -17,7 +17,6 @@
 #include "ash/system/tray/tray_constants.h"
 #include "ash/system/tray/tray_container.h"
 #include "ash/system/user/login_status.h"
-#include "base/bind.h"
 #include "base/metrics/user_metrics.h"
 #include "components/prefs/pref_change_registrar.h"
 #include "components/prefs/pref_registry_simple.h"
--- a/ash/system/session/logout_confirmation_controller.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/session/logout_confirmation_controller.cc	2019-05-17 18:53:08.328000000 +0300
@@ -13,7 +13,6 @@
 #include "ash/shell.h"
 #include "ash/shell_observer.h"
 #include "ash/system/session/logout_confirmation_dialog.h"
-#include "base/bind.h"
 #include "base/callback.h"
 #include "base/location.h"
 #include "base/metrics/user_metrics.h"
@@ -29,8 +28,7 @@
 
 // Shell window containers monitored for when the last window closes.
 const int kLastWindowClosedContainerIds[] = {
-    kShellWindowId_DefaultContainer, kShellWindowId_AlwaysOnTopContainer,
-    kShellWindowId_PipContainer};
+    kShellWindowId_DefaultContainer, kShellWindowId_AlwaysOnTopContainer};
 
 void SignOut(LogoutConfirmationController::Source source) {
   if (Shell::Get()->session_controller()->IsDemoSession() &&
--- a/ash/system/status_area_widget.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/status_area_widget.cc	2019-05-17 18:53:08.328000000 +0300
@@ -45,18 +45,24 @@
 }
 
 void StatusAreaWidget::Initialize() {
-  // Create the child views, left to right.
+  // Create the child views, right to left.
+  overview_button_tray_ = std::make_unique<OverviewButtonTray>(shelf_);
+  status_area_widget_delegate_->AddChildView(overview_button_tray_.get());
 
-  if (::features::IsMultiProcessMash()) {
-    flag_warning_tray_ = std::make_unique<FlagWarningTray>(shelf_);
-    status_area_widget_delegate_->AddChildView(flag_warning_tray_.get());
-  }
+  unified_system_tray_ = std::make_unique<UnifiedSystemTray>(shelf_);
+  status_area_widget_delegate_->AddChildView(unified_system_tray_.get());
 
-  logout_button_tray_ = std::make_unique<LogoutButtonTray>(shelf_);
-  status_area_widget_delegate_->AddChildView(logout_button_tray_.get());
+  palette_tray_ = std::make_unique<PaletteTray>(shelf_);
+  status_area_widget_delegate_->AddChildView(palette_tray_.get());
 
-  dictation_button_tray_ = std::make_unique<DictationButtonTray>(shelf_);
-  status_area_widget_delegate_->AddChildView(dictation_button_tray_.get());
+  virtual_keyboard_tray_ = std::make_unique<VirtualKeyboardTray>(shelf_);
+  status_area_widget_delegate_->AddChildView(virtual_keyboard_tray_.get());
+
+  ime_menu_tray_ = std::make_unique<ImeMenuTray>(shelf_);
+  status_area_widget_delegate_->AddChildView(ime_menu_tray_.get());
+
+  select_to_speak_tray_ = std::make_unique<SelectToSpeakTray>(shelf_);
+  status_area_widget_delegate_->AddChildView(select_to_speak_tray_.get());
 
   if (base::CommandLine::ForCurrentProcess()->HasSwitch(
           switches::kEnableExperimentalAccessibilityAutoclick)) {
@@ -64,23 +70,16 @@
     status_area_widget_delegate_->AddChildView(autoclick_tray_.get());
   }
 
-  select_to_speak_tray_ = std::make_unique<SelectToSpeakTray>(shelf_);
-  status_area_widget_delegate_->AddChildView(select_to_speak_tray_.get());
-
-  ime_menu_tray_ = std::make_unique<ImeMenuTray>(shelf_);
-  status_area_widget_delegate_->AddChildView(ime_menu_tray_.get());
-
-  virtual_keyboard_tray_ = std::make_unique<VirtualKeyboardTray>(shelf_);
-  status_area_widget_delegate_->AddChildView(virtual_keyboard_tray_.get());
-
-  palette_tray_ = std::make_unique<PaletteTray>(shelf_);
-  status_area_widget_delegate_->AddChildView(palette_tray_.get());
+  dictation_button_tray_ = std::make_unique<DictationButtonTray>(shelf_);
+  status_area_widget_delegate_->AddChildView(dictation_button_tray_.get());
 
-  unified_system_tray_ = std::make_unique<UnifiedSystemTray>(shelf_);
-  status_area_widget_delegate_->AddChildView(unified_system_tray_.get());
+  logout_button_tray_ = std::make_unique<LogoutButtonTray>(shelf_);
+  status_area_widget_delegate_->AddChildView(logout_button_tray_.get());
 
-  overview_button_tray_ = std::make_unique<OverviewButtonTray>(shelf_);
-  status_area_widget_delegate_->AddChildView(overview_button_tray_.get());
+  if (::features::IsMultiProcessMash()) {
+    flag_warning_tray_ = std::make_unique<FlagWarningTray>(shelf_);
+    status_area_widget_delegate_->AddChildView(flag_warning_tray_.get());
+  }
 
   // The layout depends on the number of children, so build it once after
   // adding all of them.
--- a/ash/system/status_area_widget_delegate.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/status_area_widget_delegate.cc	2019-05-17 18:53:08.328000000 +0300
@@ -6,6 +6,7 @@
 
 #include "ash/focus_cycler.h"
 #include "ash/root_window_controller.h"
+#include "ash/session/session_controller.h"
 #include "ash/shelf/shelf.h"
 #include "ash/shelf/shelf_constants.h"
 #include "ash/shell.h"
@@ -20,6 +21,8 @@
 
 namespace {
 
+using session_manager::SessionState;
+
 constexpr int kAnimationDurationMs = 250;
 
 constexpr int kPaddingBetweenWidgetsNewUi = 8;
@@ -65,6 +68,11 @@
 }
 
 bool StatusAreaWidgetDelegate::ShouldFocusOut(bool reverse) {
+  if (Shell::Get()->session_controller()->GetSessionState() ==
+      SessionState::ACTIVE) {
+    return false;
+  }
+
   views::View* focused_view = GetFocusManager()->GetFocusedView();
   return (reverse && focused_view == GetFirstFocusableChild()) ||
          (!reverse && focused_view == GetLastFocusableChild());
@@ -133,7 +141,7 @@
   views::ColumnSet* columns = layout->AddColumnSet(0);
 
   if (shelf_->IsHorizontalAlignment()) {
-    for (int c = 0; c < child_count(); ++c) {
+    for (int c = child_count() - 1; c >= 0; --c) {
       views::View* child = child_at(c);
       if (!child->visible())
         continue;
@@ -142,7 +150,7 @@
                          views::GridLayout::USE_PREF, 0, 0);
     }
     layout->StartRow(0, 0);
-    for (int c = 0; c < child_count(); ++c) {
+    for (int c = child_count() - 1; c >= 0; --c) {
       views::View* child = child_at(c);
       if (child->visible())
         layout->AddView(child);
@@ -151,7 +159,7 @@
     columns->AddColumn(views::GridLayout::FILL, views::GridLayout::CENTER,
                        0, /* resize percent */
                        views::GridLayout::USE_PREF, 0, 0);
-    for (int c = 0; c < child_count(); ++c) {
+    for (int c = child_count() - 1; c >= 0; --c) {
       views::View* child = child_at(c);
       if (!child->visible())
         continue;
--- a/ash/system/status_area_widget_unittest.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/status_area_widget_unittest.cc	2019-05-17 18:53:08.332000000 +0300
@@ -19,7 +19,6 @@
 #include "ash/system/unified/unified_system_tray.h"
 #include "ash/system/virtual_keyboard/virtual_keyboard_tray.h"
 #include "ash/test/ash_test_base.h"
-#include "base/bind_helpers.h"
 #include "base/command_line.h"
 #include "chromeos/dbus/dbus_thread_manager.h"
 #include "chromeos/network/network_handler.h"
@@ -126,8 +125,7 @@
 
 // Tests that tab traversal through status area widget in non-active session
 // could properly send FocusOut event.
-// TODO(crbug.com/934939): Failing on trybot.
-TEST_F(StatusAreaWidgetFocusTest, DISABLED_FocusOutObserverUnified) {
+TEST_F(StatusAreaWidgetFocusTest, FocusOutObserverUnified) {
   // Set session state to LOCKED.
   SessionController* session = Shell::Get()->session_controller();
   ASSERT_TRUE(session->IsActiveUserSessionStarted());
@@ -155,31 +153,28 @@
   status->ime_menu_tray()->OnIMEMenuActivationChanged(true);
   ASSERT_TRUE(status->ime_menu_tray()->visible());
 
-  // Set focus to status area widget. The first focused view will be the IME
-  // tray.
+  // Set focus to status area widget, which will be be system tray.
   ASSERT_TRUE(Shell::Get()->focus_cycler()->FocusWidget(status));
   views::FocusManager* focus_manager = status->GetFocusManager();
-  EXPECT_EQ(status->ime_menu_tray(), focus_manager->GetFocusedView());
+  EXPECT_EQ(status->unified_system_tray(), focus_manager->GetFocusedView());
 
-  // A tab key event will move focus to the system tray.
+  // A tab key event will move focus to notification tray.
   GenerateTabEvent(false);
-  EXPECT_EQ(status->unified_system_tray(), focus_manager->GetFocusedView());
+  EXPECT_EQ(status->ime_menu_tray(), focus_manager->GetFocusedView());
   EXPECT_EQ(0, test_observer_->focus_out_count());
   EXPECT_EQ(0, test_observer_->reverse_focus_out_count());
 
   // Another tab key event will send FocusOut event, since we are not handling
-  // this event, focus will remain within the status widhet and will be
-  // moved to the IME tray.
+  // this event, focus will still be moved to system tray.
   GenerateTabEvent(false);
-  EXPECT_EQ(status->ime_menu_tray(), focus_manager->GetFocusedView());
+  EXPECT_EQ(status->unified_system_tray(), focus_manager->GetFocusedView());
   EXPECT_EQ(1, test_observer_->focus_out_count());
   EXPECT_EQ(0, test_observer_->reverse_focus_out_count());
 
   // A reverse tab key event will send reverse FocusOut event, since we are not
-  // handling this event, focus will remain within the status widget and will
-  // be moved to the system tray.
+  // handling this event, focus will still be moved to notification tray.
   GenerateTabEvent(true);
-  EXPECT_EQ(status->unified_system_tray(), focus_manager->GetFocusedView());
+  EXPECT_EQ(status->ime_menu_tray(), focus_manager->GetFocusedView());
   EXPECT_EQ(1, test_observer_->focus_out_count());
   EXPECT_EQ(1, test_observer_->reverse_focus_out_count());
 }
@@ -254,7 +249,10 @@
         keyboard::switches::kEnableVirtualKeyboard);
     AshTestBase::SetUp();
     ASSERT_TRUE(keyboard::IsKeyboardEnabled());
-    keyboard::test::WaitUntilLoaded();
+
+    keyboard_controller()->LoadKeyboardWindowInBackground();
+    // Wait for the keyboard window to load.
+    base::RunLoop().RunUntilIdle();
 
     // These tests only apply to the floating virtual keyboard, as it is the
     // only case where both the virtual keyboard and the shelf are visible.
--- a/ash/system/time/time_view.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/time/time_view.cc	2019-05-17 18:53:08.332000000 +0300
@@ -22,6 +22,7 @@
 #include "third_party/icu/source/i18n/unicode/smpdtfmt.h"
 #include "ui/accessibility/ax_node_data.h"
 #include "ui/base/l10n/l10n_util.h"
+#include "ui/base/ui_base_features.h"
 #include "ui/gfx/geometry/insets.h"
 #include "ui/views/border.h"
 #include "ui/views/controls/button/button.h"
@@ -179,7 +180,13 @@
 
   NotifyAccessibilityEvent(ax::mojom::Event::kTextChanged, true);
 
-  base::string16 current_time = base::TimeFormatTimeOfDayWithHourClockType(
+  base::string16 current_time;
+  // Add a subtle indicator for SingleProcessMash that shows up in screenshots.
+  // TODO(crbug.com/918537): Remove before M-74 branch.
+  if (::features::IsSingleProcessMash()) {
+    current_time = base::ASCIIToUTF16("- ");
+  }
+  current_time += base::TimeFormatTimeOfDayWithHourClockType(
       now, model_->hour_clock_type(), base::kDropAmPm);
   horizontal_label_->SetText(current_time);
   horizontal_label_->SetTooltipText(base::TimeFormatFriendlyDate(now));
--- a/ash/system/toast/toast_manager_unittest.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/toast/toast_manager_unittest.cc	2019-05-17 18:53:08.332000000 +0300
@@ -84,7 +84,7 @@
   std::string ShowToast(const std::string& text,
                         int32_t duration,
                         bool visible_on_lock_screen = false) {
-    std::string id = "TOAST_ID_" + base::NumberToString(serial_++);
+    std::string id = "TOAST_ID_" + base::UintToString(serial_++);
     manager()->Show(ToastData(id, base::ASCIIToUTF16(text), duration,
                               base::string16(), visible_on_lock_screen));
     return id;
@@ -98,7 +98,7 @@
     if (dismiss_text.has_value())
       localized_dismiss = base::ASCIIToUTF16(dismiss_text.value());
 
-    std::string id = "TOAST_ID_" + base::NumberToString(serial_++);
+    std::string id = "TOAST_ID_" + base::UintToString(serial_++);
     manager()->Show(
         ToastData(id, base::ASCIIToUTF16(text), duration, localized_dismiss));
     return id;
--- a/ash/system/toast/toast_overlay.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/toast/toast_overlay.cc	2019-05-17 18:53:08.332000000 +0300
@@ -247,12 +247,9 @@
   ::wm::SetWindowVisibilityAnimationDuration(
       overlay_window,
       base::TimeDelta::FromMilliseconds(kSlideAnimationDurationMs));
-
-  keyboard::KeyboardController::Get()->AddObserver(this);
 }
 
 ToastOverlay::~ToastOverlay() {
-  keyboard::KeyboardController::Get()->RemoveObserver(this);
   overlay_widget_->Close();
 }
 
@@ -301,11 +298,6 @@
     delegate_->OnClosed();
 }
 
-void ToastOverlay::OnKeyboardWorkspaceOccludedBoundsChanged(
-    const gfx::Rect& new_bounds) {
-  UpdateOverlayBounds();
-}
-
 views::Widget* ToastOverlay::widget_for_testing() {
   return overlay_widget_.get();
 }
--- a/ash/system/toast/toast_overlay.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/toast/toast_overlay.h	2019-05-17 18:53:08.332000000 +0300
@@ -14,7 +14,6 @@
 #include "ui/events/event.h"
 #include "ui/events/event_constants.h"
 #include "ui/gfx/geometry/size.h"
-#include "ui/keyboard/keyboard_controller_observer.h"
 
 namespace gfx {
 class Rect;
@@ -30,8 +29,7 @@
 class ToastOverlayView;
 class ToastOverlayButton;
 
-class ASH_EXPORT ToastOverlay : public ui::ImplicitAnimationObserver,
-                                public keyboard::KeyboardControllerObserver {
+class ASH_EXPORT ToastOverlay : public ui::ImplicitAnimationObserver {
  public:
   class ASH_EXPORT Delegate {
    public:
@@ -71,10 +69,6 @@
   void OnImplicitAnimationsScheduled() override;
   void OnImplicitAnimationsCompleted() override;
 
-  // keyboard::KeyboardControllerObserver:
-  void OnKeyboardWorkspaceOccludedBoundsChanged(
-      const gfx::Rect& new_bounds) override;
-
   views::Widget* widget_for_testing();
   ToastOverlayButton* dismiss_button_for_testing();
   void ClickDismissButtonForTesting(const ui::Event& event);
--- a/ash/system/tracing_notification_controller.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/tracing_notification_controller.cc	2019-05-17 18:53:08.332000000 +0300
@@ -9,7 +9,6 @@
 #include "ash/shell.h"
 #include "ash/strings/grit/ash_strings.h"
 #include "ash/system/model/system_tray_model.h"
-#include "base/bind.h"
 #include "ui/base/l10n/l10n_util.h"
 #include "ui/message_center/message_center.h"
 #include "ui/message_center/public/cpp/notification.h"
--- a/ash/system/tray/actionable_view.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/tray/actionable_view.cc	2019-05-17 18:53:08.332000000 +0300
@@ -16,7 +16,7 @@
 #include "ui/views/animation/ink_drop_impl.h"
 #include "ui/views/animation/ink_drop_mask.h"
 #include "ui/views/painter.h"
-#include "ui/views/view_class_properties.h"
+#include "ui/views/view_properties.h"
 
 namespace ash {
 
--- a/ash/system/tray/detailed_view_delegate.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/tray/detailed_view_delegate.cc	2019-05-17 18:53:08.332000000 +0300
@@ -148,11 +148,12 @@
 void DetailedViewDelegate::ShowStickyHeaderSeparator(views::View* view,
                                                      bool show_separator) {
   if (show_separator) {
+    const int separator_width = ash::TrayConstants::separator_width();
     view->SetBorder(views::CreatePaddedBorder(
-        views::CreateSolidSidedBorder(0, 0, kTraySeparatorWidth, 0,
+        views::CreateSolidSidedBorder(0, 0, separator_width, 0,
                                       kUnifiedMenuSeparatorColor),
         gfx::Insets(kMenuSeparatorVerticalPadding, 0,
-                    kMenuSeparatorVerticalPadding - kTraySeparatorWidth, 0)));
+                    kMenuSeparatorVerticalPadding - separator_width, 0)));
   } else {
     view->SetBorder(views::CreateEmptyBorder(
         gfx::Insets(kMenuSeparatorVerticalPadding, 0)));
--- a/ash/system/tray/system_menu_button.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/tray/system_menu_button.cc	2019-05-17 18:53:08.332000000 +0300
@@ -17,7 +17,7 @@
 #include "ui/views/animation/ink_drop_mask.h"
 #include "ui/views/animation/square_ink_drop_ripple.h"
 #include "ui/views/painter.h"
-#include "ui/views/view_class_properties.h"
+#include "ui/views/view_properties.h"
 
 namespace ash {
 
--- a/ash/system/tray/tray_background_view.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/tray/tray_background_view.cc	2019-05-17 18:53:08.336000000 +0300
@@ -11,7 +11,6 @@
 #include "ash/login/ui/lock_screen.h"
 #include "ash/public/cpp/ash_constants.h"
 #include "ash/public/cpp/shell_window_ids.h"
-#include "ash/shelf/login_shelf_view.h"
 #include "ash/shelf/shelf_constants.h"
 #include "ash/shelf/shelf_layout_manager.h"
 #include "ash/shelf/shelf_widget.h"
@@ -42,7 +41,7 @@
 #include "ui/views/background.h"
 #include "ui/views/layout/fill_layout.h"
 #include "ui/views/painter.h"
-#include "ui/views/view_class_properties.h"
+#include "ui/views/view_properties.h"
 #include "ui/wm/core/window_animations.h"
 
 namespace {
@@ -72,13 +71,14 @@
   // "Primary" is the same direction as the shelf, "secondary" is orthogonal.
   const int primary_padding = 0;
   const int secondary_padding = -ash::kHitRegionPadding;
+  const int separator_width = ash::TrayConstants::separator_width();
 
   if (is_shelf_horizontal) {
     insets.Set(secondary_padding, primary_padding, secondary_padding,
-               primary_padding + ash::kTraySeparatorWidth);
+               primary_padding + separator_width);
   } else {
     insets.Set(primary_padding, secondary_padding,
-               primary_padding + ash::kTraySeparatorWidth, secondary_padding);
+               primary_padding + separator_width, secondary_padding);
   }
   MirrorInsetsIfNecessary(&insets);
   return insets;
@@ -269,36 +269,15 @@
       shelf->GetStatusAreaWidget()->status_area_widget_delegate();
   if (!delegate || !delegate->ShouldFocusOut(reverse))
     return;
-
-  // At this point, we know we should focus out of the status widget. It
-  // remains to be determined whether we should bring focus to the shelf, or
-  // whether we should delegate to system tray focus observers to decide
-  // where the focus goes next.
-  bool should_focus_shelf = true;
-
-  if (!ShelfWidget::IsUsingViewsShelf()) {
-    // Never bring the focus to the shelf if it's not a views-based shelf as
-    // it is visually not on par with the status widget.
-    return;
-  }
-
-  // If we are using a views-based shelf:
-  // * If we're in an active session, always bring focus to the shelf whether
-  //   we are going in reverse or not.
-  // * Otherwise (login/lock screen, OOBE), bring focus to the shelf only
-  //   if we're going in reverse; if we're going forward, let the system tray
-  //   focus observers focus the lock/login view.
-  if (shelf->shelf_widget()->login_shelf_view()->visible()) {
-    // Login/lock screen or OOBE.
-    should_focus_shelf = reverse;
-  }
-
-  if (should_focus_shelf) {
+  // Focus shelf widget when shift+tab is used and views-based shelf is shown.
+  if (reverse && ShelfWidget::IsUsingViewsShelf()) {
     shelf->shelf_widget()->set_default_last_focusable_child(reverse);
-    shelf->shelf_widget()->set_activated_from_other_widget(true);
     Shell::Get()->focus_cycler()->FocusWidget(shelf->shelf_widget());
-    shelf->shelf_widget()->FocusFirstOrLastFocusableChild(reverse);
   } else {
+    // Focus should leave the system tray if:
+    // 1) Tab is used, or
+    // 2) Shift+tab is used but views-based shelf is disabled. The shelf is not
+    // part of the system tray in this case.
     Shell::Get()->system_tray_notifier()->NotifyFocusOut(reverse);
   }
 }
--- a/ash/system/tray/tray_bubble_view.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/tray/tray_bubble_view.cc	2019-05-17 18:53:08.336000000 +0300
@@ -163,15 +163,13 @@
   // Only passes Tab, Shift+Tab, Esc to the widget as it can consume more key
   // events. e.g. Alt+Tab can be consumed as focus traversal by FocusManager.
   ui::KeyboardCode key_code = event->key_code();
-  int flags = event->flags() &
-              (ui::EF_SHIFT_DOWN | ui::EF_CONTROL_DOWN | ui::EF_ALT_DOWN |
-               ui::EF_COMMAND_DOWN | ui::EF_ALTGR_DOWN | ui::EF_MOD3_DOWN);
+  int flags = event->flags();
   if ((key_code == ui::VKEY_TAB && flags == ui::EF_NONE) ||
       (key_code == ui::VKEY_TAB && flags == ui::EF_SHIFT_DOWN) ||
       (key_code == ui::VKEY_ESCAPE && flags == ui::EF_NONE)) {
     // Make TrayBubbleView activatable as the following Widget::OnKeyEvent might
     // try to activate it.
-    tray_bubble_view_->SetCanActivate(true);
+    tray_bubble_view_->set_can_activate(true);
 
     tray_bubble_view_->GetWidget()->OnKeyEvent(event);
 
@@ -219,7 +217,7 @@
     bubble_border_->SetCornerRadius(init_params.corner_radius.value());
   bubble_border_->set_avoid_shadow_overlap(true);
   set_parent_window(params_.parent_window);
-  SetCanActivate(false);
+  set_can_activate(false);
   set_notify_enter_exit_on_child(true);
   set_close_on_deactivate(init_params.close_on_deactivate);
   set_margins(gfx::Insets());
@@ -236,8 +234,6 @@
   if (init_params.anchor_mode == AnchorMode::kRect) {
     SetAnchorView(nullptr);
     SetAnchorRect(init_params.anchor_rect);
-    if (init_params.insets.has_value())
-      bubble_border_->set_insets(init_params.insets.value());
   }
 }
 
@@ -483,7 +479,7 @@
 
   // No need to explicitly activate the widget. View::RequestFocus will activate
   // it if necessary.
-  SetCanActivate(true);
+  set_can_activate(true);
 
   view->RequestFocus();
 }
--- a/ash/system/tray/tray_bubble_view.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/tray/tray_bubble_view.h	2019-05-17 18:53:08.336000000 +0300
@@ -12,7 +12,6 @@
 #include "base/optional.h"
 #include "ui/accessibility/ax_enums.mojom.h"
 #include "ui/events/event.h"
-#include "ui/gfx/geometry/insets.h"
 #include "ui/gfx/geometry/rect.h"
 #include "ui/gfx/native_widget_types.h"
 #include "ui/views/bubble/bubble_dialog_delegate_view.h"
@@ -110,7 +109,6 @@
     // If not provided, the bg color will be derived from the NativeTheme.
     base::Optional<SkColor> bg_color;
     base::Optional<int> corner_radius;
-    base::Optional<gfx::Insets> insets;
     bool has_shadow = true;
   };
 
--- a/ash/system/tray/tray_constants.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/tray/tray_constants.cc	2019-05-17 18:53:08.336000000 +0300
@@ -54,10 +54,11 @@
 const SkColor kMobileNotConnectedXIconColor = SkColorSetRGB(0xb2, 0xb2, 0xb2);
 
 const SkColor kTrayIconColor = gfx::kGoogleGrey200;
-const SkColor kOobeTrayIconColor = gfx::kGoogleGrey600;
 // Note that the alpha value should match kSignalStrengthImageBgAlpha in
 // ash/public/cpp/network_icon_image_source.cc
-const int kTrayIconBackgroundAlpha = 0x4D /* 30% */;
+const SkColor kTrayIconBackgroundColor =
+    SkColorSetA(gfx::kGoogleGrey200, 0x4D /* 30% */);
+const SkColor kOobeTrayIconColor = gfx::kGoogleGrey600;
 
 const int kMenuIconSize = 20;
 const SkColor kMenuIconColor = gfx::kChromeIconGrey;
@@ -87,4 +88,9 @@
                                         kUnifiedFeaturePodItemsInRow,
               "Total feature pod width does not match kTrayMenuWidth");
 
+// static
+int TrayConstants::GetTrayIconSize() {
+  return kUnifiedTrayIconSize;
+}
+
 }  // namespace ash
--- a/ash/system/tray/tray_constants.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/tray/tray_constants.h	2019-05-17 18:53:08.336000000 +0300
@@ -85,12 +85,9 @@
 // Extra padding used to adjust hitting region around tray items.
 extern const int kHitRegionPadding;
 
-// Width of lines used to separate menu items (e.g. input method menu).
-constexpr int kMenuSeparatorWidth = 1;
-
-// Width of lines used to separate sections of the system tray, for instance
-// in tray detailed views.
-constexpr int kTraySeparatorWidth = 0;
+// Width of a line used to separate tray items in the shelf.
+ASH_EXPORT const int kSeparatorWidth = 1;
+const int kSeparatorWidthNewUi = 0;
 
 // The color of the separators used in the system menu.
 extern const SkColor kMenuSeparatorColor;
@@ -99,8 +96,8 @@
 // system tray.
 constexpr int kTrayIconSize = 16;
 extern const SkColor kTrayIconColor;
+extern const SkColor kTrayIconBackgroundColor;
 extern const SkColor kOobeTrayIconColor;
-extern const int kTrayIconBackgroundAlpha;
 
 // The padding around network tray icon in dip.
 constexpr int kTrayNetworkIconPadding = 2;
@@ -174,7 +171,7 @@
 constexpr gfx::Insets kUnifiedMenuItemPadding(0, 16, 16, 16);
 constexpr gfx::Insets kUnifiedSliderPadding(0, 16);
 
-constexpr int kUnifiedMenuPadding = 8;
+constexpr int kUnifiedMenuVerticalPadding = 8;
 constexpr int kUnifiedNotificationCenterSpacing = 16;
 constexpr int kUnifiedTrayIconSize = 20;
 constexpr int kUnifiedTraySpacingBetweenIcons = 6;
@@ -191,14 +188,10 @@
 constexpr int kStackingNotificationCounterStartX = 18;
 constexpr int kStackingNotificationCounterDistanceX = 10;
 constexpr int kStackingNotificationCounterHeight = 20;
-constexpr int kStackingNotificationCounterWithClearAllHeight = 32;
-constexpr gfx::Insets kStackingNotificationClearAllButtonPadding(8, 16);
 constexpr SkColor kStackingNotificationCounterColor =
     SkColorSetRGB(0x5f, 0x63, 0x68);
 constexpr SkColor kStackingNotificationCounterBorderColor =
     SkColorSetRGB(0xe0, 0xe0, 0xe0);
-constexpr SkColor kStackingNotificationCounterLabelColor =
-    SkColorSetRGB(0x5f, 0x64, 0x68);
 
 // Size of an icon drawn inside top shortcut buttons.
 // A dark disc with |kTrayItemSize| diameter is drawn in the background.
@@ -206,7 +199,6 @@
 
 constexpr int kUnifiedSystemInfoHeight = 16;
 constexpr int kUnifiedSystemInfoSpacing = 8;
-constexpr gfx::Insets kUnifiedSystemInfoDateViewPadding(3);
 
 // Constants used in FeaturePodsView of UnifiedSystemTray.
 constexpr gfx::Size kUnifiedFeaturePodIconSize(48, 48);
@@ -247,6 +239,17 @@
 constexpr gfx::Insets kUnifiedDetailedViewTitlePadding(0, 0, 0, 16);
 constexpr int kUnifiedDetailedViewTitleRowHeight = 64;
 
+// TODO(tetsui): Remove this class.
+class TrayConstants {
+ public:
+  // Returns the width of a line used to separate tray items in the shelf.
+  static int separator_width() { return kSeparatorWidthNewUi; }
+
+  static int GetTrayIconSize();
+
+  DISALLOW_IMPLICIT_CONSTRUCTORS(TrayConstants);
+};
+
 }  // namespace ash
 
 #endif  // ASH_SYSTEM_TRAY_TRAY_CONSTANTS_H_
--- a/ash/system/tray/tray_detailed_view.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/tray/tray_detailed_view.cc	2019-05-17 18:53:08.336000000 +0300
@@ -109,8 +109,9 @@
     // that's below the header view so we don't get both a separator and a full
     // shadow.
     if (y() != 0 && !did_draw_shadow)
-      DrawShadow(paint_info.context(),
-                 gfx::Rect(0, 0, width(), -y() - kTraySeparatorWidth));
+      DrawShadow(
+          paint_info.context(),
+          gfx::Rect(0, 0, width(), -y() - TrayConstants::separator_width()));
   }
 
   void Layout() override {
--- a/ash/system/tray/tray_popup_utils.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/tray/tray_popup_utils.cc	2019-05-17 18:53:08.336000000 +0300
@@ -224,11 +224,12 @@
 void TrayPopupUtils::ShowStickyHeaderSeparator(views::View* view,
                                                bool show_separator) {
   if (show_separator) {
+    const int separator_width = ash::TrayConstants::separator_width();
     view->SetBorder(views::CreatePaddedBorder(
-        views::CreateSolidSidedBorder(0, 0, kTraySeparatorWidth, 0,
+        views::CreateSolidSidedBorder(0, 0, separator_width, 0,
                                       kMenuSeparatorColor),
         gfx::Insets(kMenuSeparatorVerticalPadding, 0,
-                    kMenuSeparatorVerticalPadding - kTraySeparatorWidth, 0)));
+                    kMenuSeparatorVerticalPadding - separator_width, 0)));
   } else {
     view->SetBorder(views::CreateEmptyBorder(
         gfx::Insets(kMenuSeparatorVerticalPadding, 0)));
--- a/ash/system/unified/notification_hidden_view.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/unified/notification_hidden_view.cc	2019-05-17 18:53:08.340000000 +0300
@@ -7,12 +7,9 @@
 #include "ash/public/cpp/ash_features.h"
 #include "ash/shell.h"
 #include "ash/strings/grit/ash_strings.h"
-#include "ash/system/message_center/ash_message_center_lock_screen_controller.h"
 #include "ash/system/message_center/message_center_controller.h"
 #include "ash/system/tray/tray_constants.h"
 #include "ash/system/unified/sign_out_button.h"
-#include "base/bind.h"
-#include "base/bind_helpers.h"
 #include "ui/base/l10n/l10n_util.h"
 #include "ui/message_center/lock_screen/lock_screen_controller.h"
 #include "ui/message_center/message_center.h"
@@ -35,6 +32,9 @@
 }  // namespace
 
 NotificationHiddenView::NotificationHiddenView() {
+  const bool lock_screen_notification_enabled =
+      features::IsLockScreenNotificationsEnabled();
+
   auto* label = new views::Label;
   label->SetEnabledColor(kUnifiedMenuTextColor);
   label->SetAutoColorReadabilityEnabled(false);
@@ -55,16 +55,14 @@
   container->AddChildView(label);
   layout->SetFlexForView(label, 1);
 
-  // Shows the "Change" button, unless the locks screen notification is
-  // prohibited by policy or flag.
-  if (AshMessageCenterLockScreenController::IsAllowed()) {
-    change_button_ = new RoundedLabelButton(
+  if (lock_screen_notification_enabled) {
+    auto* change_button = new RoundedLabelButton(
         this,
         l10n_util::GetStringUTF16(IDS_ASH_MESSAGE_CENTER_LOCKSCREEN_CHANGE));
-    change_button_->SetTooltipText(l10n_util::GetStringUTF16(
+    change_button->SetTooltipText(l10n_util::GetStringUTF16(
         IDS_ASH_MESSAGE_CENTER_LOCKSCREEN_CHANGE_TOOLTIP));
 
-    container->AddChildView(change_button_);
+    container->AddChildView(change_button);
   }
 
   SetBorder(
@@ -82,7 +80,7 @@
       ->lock_screen_controller()
       ->DismissLockScreenThenExecute(
           base::BindOnce(&ShowLockScreenNotificationSettings),
-          base::DoNothing(), IDS_ASH_MESSAGE_CENTER_UNLOCK_TO_CHANGE_SETTING);
+          base::DoNothing());
 }
 
 }  // namespace ash
--- a/ash/system/unified/notification_hidden_view.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/unified/notification_hidden_view.h	2019-05-17 18:53:08.340000000 +0300
@@ -21,11 +21,7 @@
   // views::ButtonListener:
   void ButtonPressed(views::Button* sender, const ui::Event& event) override;
 
-  views::Button* change_button_for_testing() { return change_button_; }
-
  private:
-  views::Button* change_button_ = nullptr;
-
   DISALLOW_COPY_AND_ASSIGN(NotificationHiddenView);
 };
 
--- a/ash/system/unified/top_shortcut_button.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/unified/top_shortcut_button.cc	2019-05-17 18:53:08.340000000 +0300
@@ -13,7 +13,7 @@
 #include "ui/views/animation/ink_drop_highlight.h"
 #include "ui/views/animation/ink_drop_impl.h"
 #include "ui/views/animation/ink_drop_mask.h"
-#include "ui/views/view_class_properties.h"
+#include "ui/views/view_properties.h"
 
 namespace ash {
 
--- a/ash/system/unified/unified_slider_bubble_controller.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/unified/unified_slider_bubble_controller.cc	2019-05-17 18:53:08.340000000 +0300
@@ -165,14 +165,8 @@
   init_params.max_width = kTrayMenuWidth;
   init_params.delegate = this;
   init_params.parent_window = tray_->GetBubbleWindowContainer();
-  init_params.anchor_view = nullptr;
-  init_params.anchor_mode = TrayBubbleView::AnchorMode::kRect;
-  init_params.anchor_rect = tray_->shelf()->GetSystemTrayAnchorRect();
-  // Decrease bottom and right insets to compensate for the adjustment of
-  // the respective edges in Shelf::GetSystemTrayAnchorRect().
-  init_params.insets =
-      gfx::Insets(kUnifiedMenuPadding, kUnifiedMenuPadding,
-                  kUnifiedMenuPadding - 1, kUnifiedMenuPadding - 1);
+  init_params.anchor_view =
+      tray_->shelf()->GetSystemTrayAnchorView()->GetBubbleAnchor();
   init_params.corner_radius = kUnifiedTrayCornerRadius;
   init_params.has_shadow = false;
 
@@ -183,6 +177,8 @@
   bubble_view_->AddChildView(slider_view);
   bubble_view_->set_color(SK_ColorTRANSPARENT);
   bubble_view_->layer()->SetFillsBoundsOpaquely(false);
+  bubble_view_->set_anchor_view_insets(
+      UnifiedSystemTrayBubble::GetAdjustedAnchorInsets(tray_, bubble_view_));
 
   bubble_widget_ = views::BubbleDialogDelegateView::CreateBubble(bubble_view_);
 
--- a/ash/system/unified/unified_slider_bubble_controller.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/unified/unified_slider_bubble_controller.h	2019-05-17 18:53:08.340000000 +0300
@@ -9,7 +9,6 @@
 #include "ash/system/audio/unified_volume_slider_controller.h"
 #include "ash/system/tray/tray_bubble_view.h"
 #include "ash/system/unified/unified_system_tray_model.h"
-#include "base/timer/timer.h"
 #include "chromeos/audio/cras_audio_handler.h"
 
 namespace ash {
--- a/ash/system/unified/unified_system_info_view.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/unified/unified_system_info_view.cc	2019-05-17 18:53:08.340000000 +0300
@@ -63,7 +63,6 @@
   void Update();
 
   // views::Button:
-  gfx::Insets GetInsets() const override;
   std::unique_ptr<views::InkDrop> CreateInkDrop() override;
   std::unique_ptr<views::InkDropRipple> CreateInkDropRipple() const override;
   std::unique_ptr<views::InkDropHighlight> CreateInkDropHighlight()
@@ -117,11 +116,6 @@
   NotifyAccessibilityEvent(ax::mojom::Event::kTextChanged, true);
 }
 
-gfx::Insets DateView::GetInsets() const {
-  // This padding provides room to render the focus ring around this button.
-  return kUnifiedSystemInfoDateViewPadding;
-}
-
 std::unique_ptr<views::InkDrop> DateView::CreateInkDrop() {
   return TrayPopupUtils::CreateInkDrop(this);
 }
--- a/ash/system/unified/unified_system_tray_bubble.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/unified/unified_system_tray_bubble.cc	2019-05-17 18:53:08.344000000 +0300
@@ -61,6 +61,24 @@
 
 }  // namespace
 
+// static
+gfx::Insets UnifiedSystemTrayBubble::GetAdjustedAnchorInsets(
+    UnifiedSystemTray* tray,
+    TrayBubbleView* bubble_view) {
+  gfx::Insets anchor_insets =
+      tray->shelf()->GetSystemTrayAnchorView()->GetBubbleAnchorInsets();
+  gfx::Insets bubble_insets = bubble_view->GetBorderInsets();
+  if (tray->shelf()->IsHorizontalAlignment()) {
+    anchor_insets -=
+        gfx::Insets(kUnifiedMenuVerticalPadding - bubble_insets.bottom(), 0, 0,
+                    bubble_insets.right() + anchor_insets.right());
+  } else {
+    anchor_insets -=
+        gfx::Insets(0, 0, bubble_insets.bottom() + anchor_insets.bottom(), 0);
+  }
+  return anchor_insets;
+}
+
 UnifiedSystemTrayBubble::UnifiedSystemTrayBubble(UnifiedSystemTray* tray,
                                                  bool show_by_click)
     : controller_(
@@ -78,11 +96,6 @@
   init_params.anchor_view = nullptr;
   init_params.anchor_mode = TrayBubbleView::AnchorMode::kRect;
   init_params.anchor_rect = tray->shelf()->GetSystemTrayAnchorRect();
-  // Decrease bottom and right insets to compensate for the adjustment of
-  // the respective edges in Shelf::GetSystemTrayAnchorRect().
-  init_params.insets =
-      gfx::Insets(kUnifiedMenuPadding, kUnifiedMenuPadding,
-                  kUnifiedMenuPadding - 1, kUnifiedMenuPadding - 1);
   init_params.corner_radius = kUnifiedTrayCornerRadius;
   init_params.has_shadow = false;
   init_params.show_by_click = show_by_click;
@@ -98,6 +111,8 @@
   bubble_view_->SetMaxHeight(max_height);
   bubble_view_->AddChildView(new ContainerView(unified_view_));
 
+  bubble_view_->set_anchor_view_insets(
+      GetAdjustedAnchorInsets(tray, bubble_view_));
   bubble_view_->set_color(SK_ColorTRANSPARENT);
   bubble_view_->layer()->SetFillsBoundsOpaquely(false);
 
@@ -113,7 +128,6 @@
   }
 
   tray->tray_event_filter()->AddBubble(this);
-  tray->shelf()->AddObserver(this);
   Shell::Get()->tablet_mode_controller()->AddObserver(this);
   Shell::Get()->activation_client()->AddObserver(this);
 }
@@ -123,7 +137,6 @@
   if (Shell::Get()->tablet_mode_controller())
     Shell::Get()->tablet_mode_controller()->RemoveObserver(this);
   tray_->tray_event_filter()->RemoveBubble(this);
-  tray_->shelf()->RemoveObserver(this);
   if (bubble_widget_) {
     bubble_widget_->RemoveObserver(this);
     bubble_widget_->Close();
@@ -145,7 +158,7 @@
 
   if (bubble_widget_->IsClosed())
     return;
-  bubble_widget_->widget_delegate()->SetCanActivate(true);
+  bubble_widget_->widget_delegate()->set_can_activate(true);
   bubble_widget_->Activate();
 }
 
@@ -234,7 +247,7 @@
                                                        : anchor_bounds.bottom();
   int free_space_height_above_anchor =
       bottom - tray_->shelf()->GetUserWorkAreaBounds().y();
-  return free_space_height_above_anchor - kUnifiedMenuPadding * 2;
+  return free_space_height_above_anchor - kUnifiedMenuVerticalPadding * 2;
 }
 
 void UnifiedSystemTrayBubble::OnDisplayConfigurationChanged() {
@@ -286,11 +299,6 @@
   UpdateBubbleBounds();
 }
 
-void UnifiedSystemTrayBubble::OnAutoHideStateChanged(
-    ShelfAutoHideState new_state) {
-  UpdateBubbleBounds();
-}
-
 void UnifiedSystemTrayBubble::UpdateBubbleBounds() {
   int max_height = CalculateMaxHeight();
   unified_view_->SetMaxHeight(max_height);
--- a/ash/system/unified/unified_system_tray_bubble.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/unified/unified_system_tray_bubble.h	2019-05-17 18:53:08.344000000 +0300
@@ -7,7 +7,6 @@
 
 #include <memory>
 
-#include "ash/shelf/shelf_observer.h"
 #include "ash/system/screen_layout_observer.h"
 #include "ash/system/tray/time_to_click_recorder.h"
 #include "ash/system/tray/tray_bubble_base.h"
@@ -39,11 +38,14 @@
 class UnifiedSystemTrayBubble : public TrayBubbleBase,
                                 public ash::ScreenLayoutObserver,
                                 public views::WidgetObserver,
-                                public ShelfObserver,
                                 public ::wm::ActivationChangeObserver,
                                 public TimeToClickRecorder::Delegate,
                                 public TabletModeObserver {
  public:
+  // Return adjusted anchor insets that take into account shelf alignment and
+  // bubble insets.
+  static gfx::Insets GetAdjustedAnchorInsets(UnifiedSystemTray* tray,
+                                             TrayBubbleView* bubble_view);
 
   explicit UnifiedSystemTrayBubble(UnifiedSystemTray* tray, bool show_by_click);
   ~UnifiedSystemTrayBubble() override;
@@ -98,9 +100,6 @@
   void OnTabletModeStarted() override;
   void OnTabletModeEnded() override;
 
-  // ShelfObserver:
-  void OnAutoHideStateChanged(ShelfAutoHideState new_state) override;
-
  private:
   friend class UnifiedSystemTrayTestApi;
 
--- a/ash/system/unified/unified_system_tray_controller_unittest.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/unified/unified_system_tray_controller_unittest.cc	2019-05-17 18:53:08.344000000 +0300
@@ -4,12 +4,7 @@
 
 #include "ash/system/unified/unified_system_tray_controller.h"
 
-#include "ash/public/cpp/ash_features.h"
-#include "ash/public/interfaces/session_controller.mojom.h"
-#include "ash/session/session_controller.h"
 #include "ash/shell.h"
-#include "ash/system/message_center/ash_message_center_lock_screen_controller.h"
-#include "ash/system/unified/notification_hidden_view.h"
 #include "ash/system/unified/unified_system_tray_model.h"
 #include "ash/system/unified/unified_system_tray_view.h"
 #include "ash/test/ash_test_base.h"
@@ -22,17 +17,6 @@
 
 namespace ash {
 
-namespace {
-
-void SetSessionState(const session_manager::SessionState& state) {
-  mojom::SessionInfoPtr info_ptr = mojom::SessionInfo::New();
-  info_ptr->state = state;
-  SessionController* session_controller = Shell::Get()->session_controller();
-  session_controller->SetSessionInfo(std::move(info_ptr));
-}
-
-}  // anonymous namespace
-
 class UnifiedSystemTrayControllerTest : public AshTestBase,
                                         public views::ViewObserver {
  public:
@@ -52,11 +36,15 @@
 
     model_ = std::make_unique<UnifiedSystemTrayModel>();
     controller_ = std::make_unique<UnifiedSystemTrayController>(model());
+    view_.reset(controller_->CreateView());
+
+    view_->AddObserver(this);
+    OnViewPreferredSizeChanged(view());
+
+    preferred_size_changed_count_ = 0;
   }
 
   void TearDown() override {
-    DCHECK(view_) << "Must call InitializeView() during the tests";
-
     view_->RemoveObserver(this);
 
     view_.reset();
@@ -87,15 +75,6 @@
     return preferred_size_changed_count_;
   }
 
-  void InitializeView() {
-    view_.reset(controller_->CreateView());
-
-    view_->AddObserver(this);
-    OnViewPreferredSizeChanged(view());
-
-    preferred_size_changed_count_ = 0;
-  }
-
   UnifiedSystemTrayModel* model() { return model_.get(); }
   UnifiedSystemTrayController* controller() { return controller_.get(); }
   UnifiedSystemTrayView* view() { return view_.get(); }
@@ -114,8 +93,6 @@
 };
 
 TEST_F(UnifiedSystemTrayControllerTest, ToggleExpanded) {
-  InitializeView();
-
   EXPECT_TRUE(model()->IsExpandedOnOpen());
   const int expanded_height = view()->GetPreferredSize().height();
 
@@ -128,8 +105,6 @@
 }
 
 TEST_F(UnifiedSystemTrayControllerTest, PreferredSizeChanged) {
-  InitializeView();
-
   // Checks PreferredSizeChanged is not called too frequently.
   EXPECT_EQ(0, preferred_size_changed_count());
   view()->SetExpandedAmount(0.0);
@@ -142,55 +117,4 @@
   EXPECT_EQ(4, preferred_size_changed_count());
 }
 
-TEST_F(UnifiedSystemTrayControllerTest, NotificationHiddenView_ModeShow) {
-  AshMessageCenterLockScreenController::OverrideModeForTest(
-      AshMessageCenterLockScreenController::Mode::SHOW);
-  SetSessionState(session_manager::SessionState::LOCKED);
-  InitializeView();
-
-  EXPECT_TRUE(AshMessageCenterLockScreenController::IsAllowed());
-  EXPECT_TRUE(AshMessageCenterLockScreenController::IsEnabled());
-  EXPECT_FALSE(view()->notification_hidden_view_for_testing()->visible());
-}
-
-TEST_F(UnifiedSystemTrayControllerTest, NotificationHiddenView_ModeHide) {
-  AshMessageCenterLockScreenController::OverrideModeForTest(
-      AshMessageCenterLockScreenController::Mode::HIDE);
-  SetSessionState(session_manager::SessionState::LOCKED);
-  InitializeView();
-
-  EXPECT_TRUE(AshMessageCenterLockScreenController::IsAllowed());
-  EXPECT_FALSE(AshMessageCenterLockScreenController::IsEnabled());
-  EXPECT_TRUE(view()->notification_hidden_view_for_testing()->visible());
-  EXPECT_NE(nullptr, view()
-                         ->notification_hidden_view_for_testing()
-                         ->change_button_for_testing());
-}
-
-TEST_F(UnifiedSystemTrayControllerTest,
-       NotificationHiddenView_ModeHideSensitive) {
-  AshMessageCenterLockScreenController::OverrideModeForTest(
-      AshMessageCenterLockScreenController::Mode::HIDE_SENSITIVE);
-  SetSessionState(session_manager::SessionState::LOCKED);
-  InitializeView();
-
-  EXPECT_TRUE(AshMessageCenterLockScreenController::IsAllowed());
-  EXPECT_TRUE(AshMessageCenterLockScreenController::IsEnabled());
-  EXPECT_FALSE(view()->notification_hidden_view_for_testing()->visible());
-}
-
-TEST_F(UnifiedSystemTrayControllerTest, NotificationHiddenView_ModeProhibited) {
-  AshMessageCenterLockScreenController::OverrideModeForTest(
-      AshMessageCenterLockScreenController::Mode::PROHIBITED);
-  SetSessionState(session_manager::SessionState::LOCKED);
-  InitializeView();
-
-  EXPECT_FALSE(AshMessageCenterLockScreenController::IsAllowed());
-  EXPECT_FALSE(AshMessageCenterLockScreenController::IsEnabled());
-  EXPECT_TRUE(view()->notification_hidden_view_for_testing()->visible());
-  EXPECT_EQ(nullptr, view()
-                         ->notification_hidden_view_for_testing()
-                         ->change_button_for_testing());
-}
-
 }  // namespace ash
--- a/ash/system/unified/unified_system_tray_model.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/unified/unified_system_tray_model.cc	2019-05-17 18:53:08.344000000 +0300
@@ -7,7 +7,6 @@
 #include "ash/accessibility/accessibility_controller.h"
 #include "ash/shell.h"
 #include "ash/system/brightness_control_delegate.h"
-#include "base/bind.h"
 #include "chromeos/dbus/dbus_thread_manager.h"
 #include "chromeos/dbus/power_manager/backlight.pb.h"
 
@@ -38,14 +37,16 @@
 UnifiedSystemTrayModel::DBusObserver::DBusObserver(
     UnifiedSystemTrayModel* owner)
     : owner_(owner) {
-  chromeos::PowerManagerClient::Get()->AddObserver(this);
+  chromeos::DBusThreadManager::Get()->GetPowerManagerClient()->AddObserver(
+      this);
   Shell::Get()->brightness_control_delegate()->GetBrightnessPercent(
       base::BindOnce(&DBusObserver::HandleInitialBrightness,
                      weak_ptr_factory_.GetWeakPtr()));
 }
 
 UnifiedSystemTrayModel::DBusObserver::~DBusObserver() {
-  chromeos::PowerManagerClient::Get()->RemoveObserver(this);
+  chromeos::DBusThreadManager::Get()->GetPowerManagerClient()->RemoveObserver(
+      this);
 }
 
 void UnifiedSystemTrayModel::DBusObserver::HandleInitialBrightness(
--- a/ash/system/unified/unified_system_tray_unittest.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/unified/unified_system_tray_unittest.cc	2019-05-17 18:53:08.344000000 +0300
@@ -7,10 +7,7 @@
 #include "ash/system/status_area_widget.h"
 #include "ash/system/status_area_widget_test_helper.h"
 #include "ash/system/unified/unified_slider_bubble_controller.h"
-#include "ash/system/unified/unified_system_tray_bubble.h"
 #include "ash/test/ash_test_base.h"
-#include "ui/display/display.h"
-#include "ui/display/screen.h"
 
 namespace ash {
 
@@ -30,10 +27,6 @@
         ->slider_bubble_controller_->slider_type_;
   }
 
-  UnifiedSystemTrayBubble* GetUnifiedSystemTrayBubble() {
-    return GetPrimaryUnifiedSystemTray()->bubble_.get();
-  }
-
  private:
   DISALLOW_COPY_AND_ASSIGN(UnifiedSystemTrayTest);
 };
@@ -59,26 +52,4 @@
   EXPECT_FALSE(status->ShouldShowShelf());
 }
 
-TEST_F(UnifiedSystemTrayTest, ShowBubble_MultipleDisplays_OpenedOnSameDisplay) {
-  // Initialize two displays with 800x800 resolution.
-  UpdateDisplay("400+400-800x600,1220+400-800x600");
-  auto* screen = display::Screen::GetScreen();
-  EXPECT_EQ(2, screen->GetNumDisplays());
-
-  // The tray bubble for each display should be opened on the same display.
-  // See crbug.com/937420.
-  for (int i = 0; i < screen->GetNumDisplays(); ++i) {
-    auto* system_tray = GetPrimaryUnifiedSystemTray();
-    system_tray->ShowBubble(true /* show_by_click */);
-    const gfx::Rect primary_display_bounds = GetPrimaryDisplay().bounds();
-    const gfx::Rect tray_bubble_bounds =
-        GetPrimaryUnifiedSystemTray()->GetBubbleBoundsInScreen();
-    EXPECT_TRUE(primary_display_bounds.Contains(tray_bubble_bounds))
-        << "primary display bounds=" << primary_display_bounds.ToString()
-        << ", tray bubble bounds=" << tray_bubble_bounds.ToString();
-
-    SwapPrimaryDisplay();
-  }
-}
-
 }  // namespace ash
--- a/ash/system/unified/unified_system_tray_view.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/unified/unified_system_tray_view.cc	2019-05-17 18:53:08.344000000 +0300
@@ -36,16 +36,13 @@
 // Border applied to SystemTrayContainer and DetailedViewContainer to iminate
 // notification list scrolling under SystemTray part of UnifiedSystemTray.
 // The border paints mock notification frame behind the top corners based on
-// |rect_below_scroll|.
+// |height_below_scroll|.
 class TopCornerBorder : public views::Border {
  public:
   TopCornerBorder() = default;
 
   // views::Border:
   void Paint(const views::View& view, gfx::Canvas* canvas) override {
-    if (rect_below_scroll_.IsEmpty())
-      return;
-
     gfx::ScopedCanvas scoped(canvas);
 
     SkPath path;
@@ -59,22 +56,25 @@
     flags.setStyle(cc::PaintFlags::kFill_Style);
     flags.setAntiAlias(true);
 
-    gfx::Rect rect = rect_below_scroll_;
-    rect.set_height(std::min(rect.height(), kUnifiedTrayCornerRadius * 2));
-    rect.Inset(gfx::Insets(-kUnifiedTrayCornerRadius * 4, 0, 0, 0));
-    canvas->DrawRoundRect(gfx::RectF(rect), kUnifiedTrayCornerRadius, flags);
+    const int height = kUnifiedTrayCornerRadius * 4;
+    canvas->DrawRoundRect(
+        gfx::RectF(0,
+                   -height + std::min(height_below_scroll_,
+                                      kUnifiedTrayCornerRadius * 2),
+                   view.width(), height),
+        kUnifiedTrayCornerRadius, flags);
   }
 
   gfx::Insets GetInsets() const override { return gfx::Insets(); }
 
   gfx::Size GetMinimumSize() const override { return gfx::Size(); }
 
-  void set_rect_below_scroll(const gfx::Rect& rect_below_scroll) {
-    rect_below_scroll_ = rect_below_scroll;
+  void set_height_below_scroll(int height_below_scroll) {
+    height_below_scroll_ = height_below_scroll;
   }
 
  private:
-  gfx::Rect rect_below_scroll_;
+  int height_below_scroll_ = 0;
 
   DISALLOW_COPY_AND_ASSIGN(TopCornerBorder);
 };
@@ -357,12 +357,12 @@
          !message_center_view_->visible();
 }
 
-void UnifiedSystemTrayView::SetNotificationRectBelowScroll(
-    const gfx::Rect& rect_below_scroll) {
+void UnifiedSystemTrayView::SetNotificationHeightBelowScroll(
+    int height_below_scroll) {
   static_cast<TopCornerBorder*>(system_tray_container_->border())
-      ->set_rect_below_scroll(rect_below_scroll);
+      ->set_height_below_scroll(height_below_scroll);
   static_cast<TopCornerBorder*>(detailed_view_container_->border())
-      ->set_rect_below_scroll(rect_below_scroll);
+      ->set_height_below_scroll(height_below_scroll);
   SchedulePaint();
 }
 
--- a/ash/system/unified/unified_system_tray_view.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/unified/unified_system_tray_view.h	2019-05-17 18:53:08.344000000 +0300
@@ -14,7 +14,6 @@
 class FeaturePodButton;
 class FeaturePodsContainerView;
 class TopShortcutsView;
-class NotificationHiddenView;
 class UnifiedMessageCenterView;
 class UnifiedSystemInfoView;
 class UnifiedSystemTrayController;
@@ -92,10 +91,8 @@
   bool IsTransformEnabled() const;
 
   // Update the top of the SystemTray part to imitate notification list
-  // scrolling under SystemTray. |rect_below_scroll| is the region of
-  // notifications covered by SystemTray part, and its coordinate is relative to
-  // UnifiedSystemTrayView. It can be empty.
-  void SetNotificationRectBelowScroll(const gfx::Rect& rect_below_scroll);
+  // scrolling under SystemTray. |height_below_scroll| should not be negative.
+  void SetNotificationHeightBelowScroll(int height_below_scroll);
 
   // Create background of UnifiedSystemTray that is semi-transparent and has
   // rounded corners.
@@ -111,10 +108,6 @@
   views::FocusTraversable* GetFocusTraversableParent() override;
   views::View* GetFocusTraversableParentView() override;
 
-  NotificationHiddenView* notification_hidden_view_for_testing() {
-    return notification_hidden_view_;
-  }
-
  private:
   class FocusSearch;
 
@@ -124,7 +117,7 @@
   UnifiedSystemTrayController* const controller_;
 
   // Owned by views hierarchy.
-  NotificationHiddenView* const notification_hidden_view_;
+  views::View* const notification_hidden_view_;
   TopShortcutsView* const top_shortcuts_view_;
   FeaturePodsContainerView* const feature_pods_container_;
   UnifiedSlidersContainerView* const sliders_container_;
--- a/ash/system/unified/user_chooser_view.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/unified/user_chooser_view.cc	2019-05-17 18:53:08.344000000 +0300
@@ -77,6 +77,8 @@
   auto* icon = new views::ImageView;
   icon->SetImage(
       gfx::CreateVectorIcon(kSystemMenuNewUserIcon, kUnifiedMenuIconColor));
+  icon->set_tooltip_text(
+      l10n_util::GetStringUTF16(IDS_ASH_STATUS_TRAY_SIGN_IN_ANOTHER_ACCOUNT));
   AddChildView(icon);
 
   auto* label = new views::Label(
--- a/ash/system/update/update_notification_controller.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/update/update_notification_controller.cc	2019-05-17 18:53:08.344000000 +0300
@@ -9,7 +9,6 @@
 #include "ash/shell.h"
 #include "ash/strings/grit/ash_strings.h"
 #include "ash/system/model/system_tray_model.h"
-#include "base/bind.h"
 #include "ui/base/l10n/l10n_util.h"
 #include "ui/message_center/message_center.h"
 #include "ui/message_center/public/cpp/notification.h"
--- a/ash/system/virtual_keyboard/virtual_keyboard_tray_unittest.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/system/virtual_keyboard/virtual_keyboard_tray_unittest.cc	2019-05-17 18:53:08.344000000 +0300
@@ -7,7 +7,6 @@
 #include "ash/system/status_area_widget.h"
 #include "ash/system/status_area_widget_test_helper.h"
 #include "ash/test/ash_test_base.h"
-#include "base/bind_helpers.h"
 #include "base/command_line.h"
 #include "ui/keyboard/keyboard_controller.h"
 #include "ui/keyboard/keyboard_util.h"
@@ -23,10 +22,12 @@
         keyboard::switches::kEnableVirtualKeyboard);
     AshTestBase::SetUp();
     ASSERT_TRUE(keyboard::IsKeyboardEnabled());
-    keyboard::test::WaitUntilLoaded();
 
     // These tests only apply to the floating virtual keyboard, as it is the
     // only case where both the virtual keyboard and the shelf are visible.
+    keyboard_controller()->LoadKeyboardWindowInBackground();
+    // Wait for the keyboard window to load.
+    base::RunLoop().RunUntilIdle();
     keyboard_controller()->SetContainerType(
         keyboard::mojom::ContainerType::kFloating, base::nullopt,
         base::DoNothing());
--- a/ash/test/ash_test_base.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/test/ash_test_base.cc	2019-05-17 18:53:08.344000000 +0300
@@ -35,12 +35,9 @@
 #include "base/memory/ptr_util.h"
 #include "base/run_loop.h"
 #include "base/test/scoped_task_environment.h"
-#include "chromeos/dbus/fake_power_manager_client.h"
 #include "components/account_id/account_id.h"
 #include "components/user_manager/user_names.h"
 #include "mojo/public/cpp/bindings/map.h"
-#include "services/ws/public/cpp/input_devices/input_device_client.h"
-#include "services/ws/public/cpp/input_devices/input_device_client_test_api.h"
 #include "services/ws/public/cpp/property_type_converters.h"
 #include "services/ws/public/mojom/window_manager.mojom.h"
 #include "services/ws/public/mojom/window_tree_constants.mojom.h"
@@ -189,10 +186,6 @@
   // Some tests set an internal display id,
   // reset it here, so other tests will continue in a clean environment.
   display::Display::SetInternalDisplayId(display::kInvalidDisplayId);
-
-  // Tests can add devices, so reset the lists for future tests.
-  ws::InputDeviceClientTestApi().SetTouchscreenDevices({});
-  ws::InputDeviceClientTestApi().SetKeyboardDevices({});
 }
 
 // static
@@ -502,10 +495,6 @@
   return Shell::Get()->display_manager();
 }
 
-chromeos::FakePowerManagerClient* AshTestBase::power_manager_client() const {
-  return chromeos::FakePowerManagerClient::Get();
-}
-
 bool AshTestBase::TestIfMouseWarpsAt(ui::test::EventGenerator* event_generator,
                                      const gfx::Point& point_in_screen) {
   DCHECK(!Shell::Get()->display_manager()->IsInUnifiedMode());
--- a/ash/test/ash_test_base.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/test/ash_test_base.h	2019-05-17 18:53:08.344000000 +0300
@@ -34,10 +34,6 @@
 }
 }  // namespace base
 
-namespace chromeos {
-class FakePowerManagerClient;
-}
-
 namespace display {
 class Display;
 class DisplayManager;
@@ -179,9 +175,6 @@
   // Convenience method to return the DisplayManager.
   display::DisplayManager* display_manager();
 
-  // Convenience method to return the FakePowerManagerClient.
-  chromeos::FakePowerManagerClient* power_manager_client() const;
-
   // Test if moving a mouse to |point_in_screen| warps it to another
   // display.
   bool TestIfMouseWarpsAt(ui::test::EventGenerator* event_generator,
@@ -297,7 +290,6 @@
 // Base test class that forces single-process mash to be enabled *and* creates
 // a views::MusClient. This base class is useful for testing WindowService
 // related functionality exposed by Ash.
-// TODO(sky): this name is misleading. Rename to better indicate what it does.
 class SingleProcessMashTestBase : public AshTestBase {
  public:
   SingleProcessMashTestBase();
--- a/ash/test/ash_test_helper.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/test/ash_test_helper.cc	2019-05-17 18:53:08.344000000 +0300
@@ -24,14 +24,12 @@
 #include "ash/test/ash_test_views_delegate.h"
 #include "ash/test_shell_delegate.h"
 #include "ash/ws/window_service_owner.h"
-#include "base/bind.h"
 #include "base/guid.h"
 #include "base/run_loop.h"
 #include "base/strings/string_split.h"
 #include "base/token.h"
 #include "chromeos/audio/cras_audio_handler.h"
 #include "chromeos/dbus/dbus_thread_manager.h"
-#include "chromeos/dbus/hammerd/hammerd_client.h"
 #include "chromeos/dbus/power_policy_controller.h"
 #include "chromeos/network/network_handler.h"
 #include "chromeos/system/fake_statistics_provider.h"
@@ -161,8 +159,6 @@
   if (!chromeos::DBusThreadManager::IsInitialized()) {
     chromeos::DBusThreadManager::Initialize(
         chromeos::DBusThreadManager::kShared);
-    chromeos::HammerdClient::Initialize(
-        chromeos::DBusThreadManager::Get()->GetSystemBus());
     dbus_thread_manager_initialized_ = true;
   }
 
@@ -171,11 +167,9 @@
     bluez_dbus_manager_initialized_ = true;
   }
 
-  chromeos::PowerManagerClient::Initialize();
-
   if (!chromeos::PowerPolicyController::IsInitialized()) {
     chromeos::PowerPolicyController::Initialize(
-        chromeos::PowerManagerClient::Get());
+        chromeos::DBusThreadManager::Get()->GetPowerManagerClient());
     power_policy_controller_initialized_ = true;
   }
 
@@ -266,8 +260,6 @@
     power_policy_controller_initialized_ = false;
   }
 
-  chromeos::PowerManagerClient::Shutdown();
-
   if (bluez_dbus_manager_initialized_) {
     device::BluetoothAdapterFactory::Shutdown();
     bluez::BluezDBusManager::Shutdown();
@@ -275,7 +267,6 @@
   }
 
   if (dbus_thread_manager_initialized_) {
-    chromeos::HammerdClient::Shutdown();
     chromeos::DBusThreadManager::Shutdown();
     dbus_thread_manager_initialized_ = false;
   }
--- a/ash/test/ash_test_helper.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/test/ash_test_helper.h	2019-05-17 18:53:08.348000000 +0300
@@ -138,9 +138,11 @@
   std::unique_ptr<::wm::WMState> wm_state_;
   std::unique_ptr<AshTestViewsDelegate> test_views_delegate_;
 
-  // Flags for whether various services were initialized here.
+  // Check if DBus Thread Manager was initialized here.
   bool dbus_thread_manager_initialized_ = false;
+  // Check if Bluez DBus Manager was initialized here.
   bool bluez_dbus_manager_initialized_ = false;
+  // Check if PowerPolicyController was initialized here.
   bool power_policy_controller_initialized_ = false;
 
   std::unique_ptr<TestSessionControllerClient> session_controller_client_;
--- a/ash/test/ash_unittests.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/test/ash_unittests.cc	2019-05-17 18:53:08.348000000 +0300
@@ -2,16 +2,21 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "ash/ash_unittests_catalog_source.h"
 #include "ash/test/ash_test_suite.h"
 #include "base/bind.h"
 #include "base/test/launcher/unit_test_launcher.h"
 #include "base/threading/thread.h"
 #include "mojo/core/embedder/embedder.h"
 #include "mojo/core/embedder/scoped_ipc_support.h"
+#include "services/catalog/catalog.h"
 
 int main(int argc, char** argv) {
   ash::AshTestSuite test_suite(argc, argv);
 
+  // Load a catalog so that these tests can connect to services.
+  catalog::Catalog::SetDefaultCatalogManifest(ash::CreateUnittestsCatalog());
+
   mojo::core::Init();
   // The IPC thread is necessary for the window service.
   base::Thread ipc_thread("IPC thread");
--- a/ash/test/DEPS	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/test/DEPS	2019-05-17 18:53:08.344000000 +0300
@@ -3,6 +3,7 @@
   "+cc/test",
   "+components/viz/test",
   "+mojo/core/embedder",
+  "+services/catalog/catalog.h",
 ]
 
 specific_include_rules = {
--- a/ash/test/ui_controls_factory_ash.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/test/ui_controls_factory_ash.cc	2019-05-17 18:53:08.348000000 +0300
@@ -24,7 +24,7 @@
 using ui_controls::UIControlsAura;
 using ui_controls::MouseButton;
 
-DEFINE_OWNED_UI_CLASS_PROPERTY_KEY(UIControlsAura, kUIControlsKey, NULL)
+DEFINE_OWNED_UI_CLASS_PROPERTY_KEY(UIControlsAura, kUIControlsKey, NULL);
 
 // Returns the UIControls object for RootWindow.
 // kUIControlsKey is owned property and UIControls object
--- a/ash/touch/touch_devices_controller.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/touch/touch_devices_controller.cc	2019-05-17 18:53:08.348000000 +0300
@@ -11,7 +11,6 @@
 #include "ash/session/session_controller.h"
 #include "ash/shell.h"
 #include "ash/shell_delegate.h"
-#include "base/bind.h"
 #include "base/metrics/histogram_macros.h"
 #include "components/pref_registry/pref_registry_syncable.h"
 #include "components/prefs/pref_change_registrar.h"
--- a/ash/touch/touch_observer_hud.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/touch/touch_observer_hud.cc	2019-05-17 18:53:08.348000000 +0300
@@ -409,7 +409,7 @@
     if (hud) {
       std::unique_ptr<base::ListValue> list = hud->GetLogAsList();
       if (!list->empty())
-        value->Set(base::NumberToString(hud->display_id_), std::move(list));
+        value->Set(base::Int64ToString(hud->display_id_), std::move(list));
     }
   }
   return value;
--- a/ash/voice_interaction/voice_interaction_controller.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/voice_interaction/voice_interaction_controller.cc	2019-05-17 18:53:08.352000000 +0300
@@ -83,17 +83,16 @@
     observer.OnVoiceInteractionHotwordAlwaysOn(always_on);
 }
 
-void VoiceInteractionController::NotifyConsentStatus(
-    mojom::ConsentStatus consent_status) {
-  if (consent_status_.has_value() && consent_status_.value() == consent_status)
+void VoiceInteractionController::NotifySetupCompleted(bool completed) {
+  if (setup_completed_.has_value() && setup_completed_.value() == completed)
     return;
 
-  consent_status_ = consent_status;
-  observers_.ForAllPtrs([consent_status](auto* observer) {
-    observer->OnVoiceInteractionConsentStatusUpdated(consent_status);
+  setup_completed_ = completed;
+  observers_.ForAllPtrs([completed](auto* observer) {
+    observer->OnVoiceInteractionSetupCompleted(completed);
   });
   for (auto& observer : local_observers_)
-    observer.OnVoiceInteractionConsentStatusUpdated(consent_status);
+    observer.OnVoiceInteractionSetupCompleted(completed);
 }
 
 void VoiceInteractionController::NotifyFeatureAllowed(
@@ -157,8 +156,8 @@
     observer->OnVoiceInteractionContextEnabled(context_enabled_.value());
   if (hotword_enabled_.has_value())
     observer->OnVoiceInteractionHotwordEnabled(hotword_enabled_.value());
-  if (consent_status_.has_value())
-    observer->OnVoiceInteractionConsentStatusUpdated(consent_status_.value());
+  if (setup_completed_.has_value())
+    observer->OnVoiceInteractionSetupCompleted(setup_completed_.value());
   if (hotword_always_on_.has_value())
     observer->OnVoiceInteractionHotwordAlwaysOn(hotword_always_on_.value());
   if (allowed_state_.has_value())
--- a/ash/voice_interaction/voice_interaction_controller.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/voice_interaction/voice_interaction_controller.h	2019-05-17 18:53:08.352000000 +0300
@@ -32,7 +32,7 @@
   void NotifyContextEnabled(bool enabled) override;
   void NotifyHotwordEnabled(bool enabled) override;
   void NotifyHotwordAlwaysOn(bool always_on) override;
-  void NotifyConsentStatus(mojom::ConsentStatus consent_status) override;
+  void NotifySetupCompleted(bool completed) override;
   void NotifyFeatureAllowed(mojom::AssistantAllowedState state) override;
   void NotifyNotificationEnabled(bool enabled) override;
   void NotifyLocaleChanged(const std::string& locale) override;
--- a/ash/voice_interaction/voice_interaction_controller_unittest.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/voice_interaction/voice_interaction_controller_unittest.cc	2019-05-17 18:53:08.352000000 +0300
@@ -37,9 +37,8 @@
   void OnVoiceInteractionHotwordEnabled(bool enabled) override {
     hotword_enabled_ = enabled;
   }
-  void OnVoiceInteractionConsentStatusUpdated(
-      mojom::ConsentStatus consent_status) override {
-    consent_status_ = consent_status;
+  void OnVoiceInteractionSetupCompleted(bool completed) override {
+    setup_completed_ = completed;
   }
   void OnAssistantFeatureAllowedChanged(
       mojom::AssistantAllowedState state) override {}
@@ -52,7 +51,7 @@
   bool context_enabled() const { return context_enabled_; }
   bool hotword_always_on() const { return hotword_always_on_; }
   bool hotword_enabled() const { return hotword_enabled_; }
-  mojom::ConsentStatus consent_status() const { return consent_status_; }
+  bool setup_completed() const { return setup_completed_; }
 
   void SetVoiceInteractionController(VoiceInteractionController* controller) {
     mojom::VoiceInteractionObserverPtr ptr;
@@ -66,7 +65,7 @@
   bool context_enabled_ = false;
   bool hotword_always_on_ = false;
   bool hotword_enabled_ = false;
-  mojom::ConsentStatus consent_status_ = mojom::ConsentStatus::kUnknown;
+  bool setup_completed_ = false;
 
   mojo::Binding<mojom::VoiceInteractionObserver> voice_interaction_binding_;
 
@@ -148,16 +147,13 @@
   EXPECT_TRUE(observer()->hotword_enabled());
 }
 
-TEST_F(VoiceInteractionControllerTest, NotifyConsentStatus) {
-  controller()->NotifyConsentStatus(
-      mojom::ConsentStatus::kActivityControlAccepted);
+TEST_F(VoiceInteractionControllerTest, NotifySetupCompleted) {
+  controller()->NotifySetupCompleted(true);
   controller()->FlushForTesting();
   // The cached state should be updated.
-  EXPECT_TRUE(controller()->consent_status() ==
-              mojom::ConsentStatus::kActivityControlAccepted);
+  EXPECT_TRUE(controller()->setup_completed());
   // The observers should be notified.
-  EXPECT_TRUE(observer()->consent_status() ==
-              mojom::ConsentStatus::kActivityControlAccepted);
+  EXPECT_TRUE(observer()->setup_completed());
 }
 
 }  // namespace ash
--- a/ash/wallpaper/OWNERS	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wallpaper/OWNERS	2019-05-17 18:53:08.352000000 +0300
@@ -1,5 +1,4 @@
 achuith@chromium.org
-maybelle@chromium.org
 wzang@chromium.org
 xdai@chromium.org
 
--- a/ash/wallpaper/wallpaper_controller.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wallpaper/wallpaper_controller.cc	2019-05-17 18:53:08.352000000 +0300
@@ -103,6 +103,12 @@
   return *dir_chrome_os_custom_wallpapers;
 }
 
+// The file path of the device policy wallpaper (if any).
+base::FilePath& GlobalDevicePolicyWallpaperFile() {
+  static base::NoDestructor<base::FilePath> device_policy_wallpaper_file;
+  return *device_policy_wallpaper_file;
+}
+
 void SetGlobalUserDataDir(const base::FilePath& path) {
   base::FilePath& global_path = GlobalUserDataDir();
   global_path = path;
@@ -118,6 +124,11 @@
   global_path = path;
 }
 
+void SetGlobalDevicePolicyWallpaperFile(const base::FilePath& path) {
+  base::FilePath& global_path = GlobalDevicePolicyWallpaperFile();
+  global_path = path;
+}
+
 // Returns the appropriate wallpaper resolution for all root windows.
 WallpaperController::WallpaperResolution GetAppropriateResolution() {
   gfx::Size size = WallpaperController::GetMaxDisplaySizeInNative();
@@ -234,18 +245,25 @@
 // Returns true if a color should be extracted from the wallpaper based on the
 // command kAshShelfColor line arg.
 bool IsShelfColoringEnabled() {
-  const std::string explicit_switch_value =
+  const bool kDefaultValue = true;
+
+  if (!base::CommandLine::ForCurrentProcess()->HasSwitch(
+          switches::kAshShelfColor)) {
+    return kDefaultValue;
+  }
+
+  const std::string switch_value =
       base::CommandLine::ForCurrentProcess()->GetSwitchValueASCII(
           switches::kAshShelfColor);
-
-  // Always enabled, unless explicitly disabled.
-  if (explicit_switch_value == switches::kAshShelfColorDisabled) {
-    LOG(WARNING) << "Shelf coloring explicitly disabled. "
-                 << "This should only happen in tests.";
-    return false;
+  if (switch_value != switches::kAshShelfColorEnabled &&
+      switch_value != switches::kAshShelfColorDisabled) {
+    LOG(WARNING) << "Invalid '--" << switches::kAshShelfColor << "' value of '"
+                 << switch_value << "'. Defaulting to "
+                 << (kDefaultValue ? "enabled." : "disabled.");
+    return kDefaultValue;
   }
 
-  return true;
+  return switch_value == switches::kAshShelfColorEnabled;
 }
 
 // Gets the color profiles for extracting wallpaper prominent colors.
@@ -634,12 +652,7 @@
 
 void WallpaperController::ShowWallpaperImage(const gfx::ImageSkia& image,
                                              WallpaperInfo info,
-                                             bool preview_mode,
-                                             bool always_on_top) {
-  // Prevent showing other wallpapers if there is an always-on-top wallpaper.
-  if (is_always_on_top_wallpaper_ && !always_on_top)
-    return;
-
+                                             bool preview_mode) {
   // Ignore show wallpaper requests during preview mode. This could happen if a
   // custom wallpaper previously set on another device is being synced.
   if (confirm_preview_wallpaper_callback_ && !preview_mode)
@@ -717,15 +730,8 @@
 }
 
 bool WallpaperController::ShouldApplyDimming() const {
-  // Dim the wallpaper in a blocked user session or in tablet mode unless during
-  // wallpaper preview.
-  const bool should_dim =
-      Shell::Get()->session_controller()->IsUserSessionBlocked() ||
-      (Shell::Get()
-           ->tablet_mode_controller()
-           ->IsTabletModeWindowManagerEnabled() &&
-       !confirm_preview_wallpaper_callback_);
-  return should_dim && !IsOneShotWallpaper();
+  return Shell::Get()->session_controller()->IsUserSessionBlocked() &&
+         !IsOneShotWallpaper();
 }
 
 bool WallpaperController::IsBlurAllowed() const {
@@ -761,7 +767,7 @@
   auto wallpaper_info_dict = std::make_unique<base::DictionaryValue>();
   wallpaper_info_dict->SetString(
       kNewWallpaperDateNodeName,
-      base::NumberToString(info.date.ToInternalValue()));
+      base::Int64ToString(info.date.ToInternalValue()));
   wallpaper_info_dict->SetString(kNewWallpaperLocationNodeName, info.location);
   wallpaper_info_dict->SetInteger(kNewWallpaperLayoutNodeName, info.layout);
   wallpaper_info_dict->SetInteger(kNewWallpaperTypeNodeName, info.type);
@@ -869,13 +875,15 @@
     const base::FilePath& user_data_path,
     const base::FilePath& chromeos_wallpapers_path,
     const base::FilePath& chromeos_custom_wallpapers_path,
-    const base::FilePath& device_policy_wallpaper_path) {
+    const base::FilePath& device_policy_wallpaper_path,
+    bool is_device_wallpaper_policy_enforced) {
   DCHECK(!wallpaper_controller_client_.get());
   wallpaper_controller_client_ = std::move(client);
   SetGlobalUserDataDir(user_data_path);
   SetGlobalChromeOSWallpapersDir(chromeos_wallpapers_path);
   SetGlobalChromeOSCustomWallpapersDir(chromeos_custom_wallpapers_path);
-  SetDevicePolicyWallpaperPath(device_policy_wallpaper_path);
+  SetGlobalDevicePolicyWallpaperFile(device_policy_wallpaper_path);
+  is_device_wallpaper_policy_enforced_ = is_device_wallpaper_policy_enforced;
 }
 
 void WallpaperController::SetCustomWallpaper(
@@ -901,7 +909,7 @@
                             weak_factory_.GetWeakPtr(), image,
                             WallpaperInfo{std::string(), layout, CUSTOMIZED,
                                           base::Time::Now().LocalMidnight()},
-                            /*preview_mode=*/true, /*always_on_top=*/false);
+                            /*preview_mode=*/true);
     // Show the preview wallpaper.
     reload_preview_wallpaper_callback_.Run();
   } else {
@@ -1026,15 +1034,13 @@
                   std::move(callback));
 }
 
-void WallpaperController::SetDevicePolicyWallpaperPath(
-    const base::FilePath& device_policy_wallpaper_path) {
-  const bool was_device_policy_wallpaper_enforced =
-      !device_policy_wallpaper_path_.empty();
-  device_policy_wallpaper_path_ = device_policy_wallpaper_path;
+void WallpaperController::SetDeviceWallpaperPolicyEnforced(bool enforced) {
+  bool previous_enforced = is_device_wallpaper_policy_enforced_;
+  is_device_wallpaper_policy_enforced_ = enforced;
+
   if (ShouldSetDevicePolicyWallpaper()) {
     SetDevicePolicyWallpaper();
-  } else if (was_device_policy_wallpaper_enforced &&
-             device_policy_wallpaper_path.empty()) {
+  } else if ((previous_enforced != enforced) && !enforced) {
     // If the device wallpaper policy is cleared, the wallpaper should revert to
     // the wallpaper of the current user with the large pod in the users list in
     // the login screen. If there is no such user, use the first user in the
@@ -1150,8 +1156,7 @@
   // hit (e.g. when the first time the wallpaper is shown on login screen).
   gfx::ImageSkia user_wallpaper;
   if (GetWallpaperFromCache(account_id, &user_wallpaper)) {
-    ShowWallpaperImage(user_wallpaper, info, /*preview_mode=*/false,
-                       /*always_on_top=*/false);
+    ShowWallpaperImage(user_wallpaper, info, /*preview_mode=*/false);
     return;
   }
 
@@ -1170,8 +1175,7 @@
 
   base::FilePath wallpaper_path;
   if (info.type == DEVICE) {
-    DCHECK(!device_policy_wallpaper_path_.empty());
-    wallpaper_path = device_policy_wallpaper_path_;
+    wallpaper_path = GlobalDevicePolicyWallpaperFile();
   } else {
     std::string sub_dir = GetCustomWallpaperSubdirForCurrentResolution();
     // Wallpaper is not resized when layout is
@@ -1215,30 +1219,7 @@
   const WallpaperInfo info = {
       std::string(), WallpaperLayout::WALLPAPER_LAYOUT_STRETCH,
       WallpaperType::ONE_SHOT, base::Time::Now().LocalMidnight()};
-  ShowWallpaperImage(image, info, /*preview_mode=*/false,
-                     /*always_on_top=*/false);
-}
-
-void WallpaperController::ShowAlwaysOnTopWallpaper(
-    const base::FilePath& image_path) {
-  is_always_on_top_wallpaper_ = true;
-  const WallpaperInfo info = {
-      std::string(), WallpaperLayout::WALLPAPER_LAYOUT_CENTER_CROPPED,
-      WallpaperType::ONE_SHOT, base::Time::Now().LocalMidnight()};
-  ReadAndDecodeWallpaper(
-      base::BindOnce(&WallpaperController::OnAlwaysOnTopWallpaperDecoded,
-                     weak_factory_.GetWeakPtr(), info),
-      sequenced_task_runner_, image_path);
-}
-
-void WallpaperController::RemoveAlwaysOnTopWallpaper() {
-  if (!is_always_on_top_wallpaper_) {
-    DCHECK(!reload_always_on_top_wallpaper_callback_);
-    return;
-  }
-  is_always_on_top_wallpaper_ = false;
-  reload_always_on_top_wallpaper_callback_.Reset();
-  ReloadWallpaper(/*clear_cache=*/false);
+  ShowWallpaperImage(image, info, /*preview_mode=*/false);
 }
 
 void WallpaperController::RemoveUserWallpaper(
@@ -1385,14 +1366,6 @@
   }
 }
 
-void WallpaperController::OnShellInitialized() {
-  Shell::Get()->tablet_mode_controller()->AddObserver(this);
-}
-
-void WallpaperController::OnShellDestroying() {
-  Shell::Get()->tablet_mode_controller()->RemoveObserver(this);
-}
-
 void WallpaperController::OnWallpaperResized() {
   CalculateWallpaperColors();
   compositor_lock_.reset();
@@ -1438,14 +1411,6 @@
     MoveToLockedContainer();
 }
 
-void WallpaperController::OnTabletModeStarted() {
-  RepaintWallpaper();
-}
-
-void WallpaperController::OnTabletModeEnded() {
-  RepaintWallpaper();
-}
-
 void WallpaperController::CompositorLockTimedOut() {
   compositor_lock_.reset();
 }
@@ -1502,16 +1467,13 @@
 
   const int container_id = GetWallpaperContainerId(locked_);
   float blur = login_constants::kClearBlurSigma;
-  if (is_wallpaper_blurred)
+  if (is_wallpaper_blurred) {
     blur = session_blocked ? login_constants::kBlurSigma : kWallpaperBlurSigma;
-
-  WallpaperView* wallpaper_view = nullptr;
-  auto* wallpaper_widget_controller =
+  }
       RootWindowController::ForWindow(root_window)
-          ->wallpaper_widget_controller();
-  auto* widget =
-      CreateWallpaperWidget(root_window, container_id, &wallpaper_view);
-  wallpaper_widget_controller->SetWallpaperWidget(widget, wallpaper_view, blur);
+      ->wallpaper_widget_controller()
+      ->SetWallpaperWidget(CreateWallpaperWidget(root_window, container_id),
+                           blur);
 }
 
 void WallpaperController::InstallDesktopControllerForAllWindows() {
@@ -1532,9 +1494,6 @@
 }
 
 int WallpaperController::GetWallpaperContainerId(bool locked) {
-  if (is_always_on_top_wallpaper_)
-    return kShellWindowId_AlwaysOnTopWallpaperContainer;
-
   return locked ? kShellWindowId_LockScreenWallpaperContainer
                 : kShellWindowId_WallpaperContainer;
 }
@@ -1745,7 +1704,7 @@
                             weak_factory_.GetWeakPtr(), image,
                             WallpaperInfo{params.url, params.layout, ONLINE,
                                           base::Time::Now().LocalMidnight()},
-                            /*preview_mode=*/true, /*always_on_top=*/false);
+                            /*preview_mode=*/true);
     // Show the preview wallpaper.
     reload_preview_wallpaper_callback_.Run();
   } else {
@@ -1764,10 +1723,8 @@
     LOG(ERROR) << "Setting user wallpaper info fails. This should never happen "
                   "except in tests.";
   }
-  if (show_wallpaper) {
-    ShowWallpaperImage(image, wallpaper_info, /*preview_mode=*/false,
-                       /*always_on_top=*/false);
-  }
+  if (show_wallpaper)
+    ShowWallpaperImage(image, wallpaper_info, /*preview_mode=*/false);
 
   wallpaper_cache_map_[params.account_id] =
       CustomWallpaperElement(base::FilePath(), image);
@@ -1850,7 +1807,7 @@
     WallpaperInfo info(cached_default_wallpaper_.file_path.value(), layout,
                        DEFAULT, base::Time::Now().LocalMidnight());
     ShowWallpaperImage(cached_default_wallpaper_.image, info,
-                       /*preview_mode=*/false, /*always_on_top=*/false);
+                       /*preview_mode=*/false);
   }
 }
 
@@ -1906,10 +1863,8 @@
                        layout, base::Passed(std::move(deep_copy))));
   }
 
-  if (show_wallpaper) {
-    ShowWallpaperImage(image, info, /*preview_mode=*/false,
-                       /*always_on_top=*/false);
-  }
+  if (show_wallpaper)
+    ShowWallpaperImage(image, info, /*preview_mode=*/false);
 
   wallpaper_cache_map_[user_info->account_id] =
       CustomWallpaperElement(wallpaper_path, image);
@@ -1931,10 +1886,8 @@
   }
 
   wallpaper_cache_map_[account_id] = CustomWallpaperElement(path, image);
-  if (show_wallpaper) {
-    ShowWallpaperImage(image, info, /*preview_mode=*/false,
-                       /*always_on_top=*/false);
-  }
+  if (show_wallpaper)
+    ShowWallpaperImage(image, info, /*preview_mode=*/false);
 }
 
 void WallpaperController::ReloadWallpaper(bool clear_cache) {
@@ -1942,9 +1895,7 @@
   if (clear_cache)
     wallpaper_cache_map_.clear();
 
-  if (reload_always_on_top_wallpaper_callback_)
-    reload_always_on_top_wallpaper_callback_.Run();
-  else if (reload_preview_wallpaper_callback_)
+  if (reload_preview_wallpaper_callback_)
     reload_preview_wallpaper_callback_.Run();
   else if (current_user_)
     ShowUserWallpaper(std::move(current_user_));
@@ -2047,24 +1998,6 @@
   return cached_colors_out;
 }
 
-void WallpaperController::OnAlwaysOnTopWallpaperDecoded(
-    const WallpaperInfo& info,
-    const gfx::ImageSkia& image) {
-  // Do nothing if |RemoveAlwaysOnTopWallpaper| was called before decoding
-  // completes.
-  if (!is_always_on_top_wallpaper_)
-    return;
-  if (image.isNull()) {
-    is_always_on_top_wallpaper_ = false;
-    return;
-  }
-  reload_always_on_top_wallpaper_callback_ =
-      base::BindRepeating(&WallpaperController::ShowWallpaperImage,
-                          weak_factory_.GetWeakPtr(), image, info,
-                          /*preview_mode=*/false, /*always_on_top=*/true);
-  reload_always_on_top_wallpaper_callback_.Run();
-}
-
 bool WallpaperController::MoveToLockedContainer() {
   if (locked_)
     return false;
@@ -2094,12 +2027,16 @@
 bool WallpaperController::ShouldSetDevicePolicyWallpaper() const {
   // Only allow the device wallpaper if the policy is in effect for enterprise
   // managed devices.
-  if (device_policy_wallpaper_path_.empty())
+  if (!is_device_wallpaper_policy_enforced_)
     return false;
 
   // Only set the device wallpaper if we're at the login screen.
-  return Shell::Get()->session_controller()->GetSessionState() ==
-         session_manager::SessionState::LOGIN_PRIMARY;
+  if (Shell::Get()->session_controller()->GetSessionState() !=
+      session_manager::SessionState::LOGIN_PRIMARY) {
+    return false;
+  }
+
+  return true;
 }
 
 void WallpaperController::SetDevicePolicyWallpaper() {
@@ -2107,7 +2044,7 @@
   ReadAndDecodeWallpaper(
       base::BindRepeating(&WallpaperController::OnDevicePolicyWallpaperDecoded,
                           weak_factory_.GetWeakPtr()),
-      sequenced_task_runner_.get(), device_policy_wallpaper_path_);
+      sequenced_task_runner_.get(), GlobalDevicePolicyWallpaperFile());
 }
 
 void WallpaperController::OnDevicePolicyWallpaperDecoded(
@@ -2123,11 +2060,10 @@
     SetDefaultWallpaperImpl(EmptyAccountId(), user_manager::USER_TYPE_REGULAR,
                             /*show_wallpaper=*/true);
   } else {
-    WallpaperInfo info(device_policy_wallpaper_path_.value(),
+    WallpaperInfo info(GlobalDevicePolicyWallpaperFile().value(),
                        WALLPAPER_LAYOUT_CENTER_CROPPED, DEVICE,
                        base::Time::Now().LocalMidnight());
-    ShowWallpaperImage(image, info, /*preview_mode=*/false,
-                       /*always_on_top=*/false);
+    ShowWallpaperImage(image, info, /*preview_mode=*/false);
   }
 }
 
@@ -2185,13 +2121,4 @@
       this, kCompositorLockTimeout);
 }
 
-void WallpaperController::RepaintWallpaper() {
-  for (auto* root_window_controller : Shell::GetAllRootWindowControllers()) {
-    auto* wallpaper_view =
-        root_window_controller->wallpaper_widget_controller()->wallpaper_view();
-    if (wallpaper_view)
-      wallpaper_view->SchedulePaint();
-  }
-}
-
 }  // namespace ash
--- a/ash/wallpaper/wallpaper_controller.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wallpaper/wallpaper_controller.h	2019-05-17 18:53:08.352000000 +0300
@@ -20,7 +20,6 @@
 #include "ash/wallpaper/wallpaper_info.h"
 #include "ash/wallpaper/wallpaper_utils/wallpaper_color_calculator_observer.h"
 #include "ash/wallpaper/wallpaper_utils/wallpaper_resizer_observer.h"
-#include "ash/wm/tablet_mode/tablet_mode_observer.h"
 #include "base/files/file_path.h"
 #include "base/memory/ref_counted.h"
 #include "base/observer_list.h"
@@ -69,7 +68,6 @@
                                        public WallpaperResizerObserver,
                                        public WallpaperColorCalculatorObserver,
                                        public SessionObserver,
-                                       public TabletModeObserver,
                                        public ui::CompositorLockClient {
  public:
   enum WallpaperResolution {
@@ -155,15 +153,12 @@
   // always return true thereafter.
   bool HasShownAnyWallpaper() const;
 
-  // Shows the wallpaper and alerts observers of changes.
-  // Does not show the image if:
-  // 1)  |preview_mode| is false and the current wallpaper is still being
+  // Shows the wallpaper and alerts observers of changes. Does not show the
+  // image if |preview_mode| is false and the current wallpaper is still being
   //     previewed. See comments for |confirm_preview_wallpaper_callback_|.
-  // 2)  |always_on_top| is false but the current wallpaper is always-on-top.
   void ShowWallpaperImage(const gfx::ImageSkia& image,
                           WallpaperInfo info,
-                          bool preview_mode,
-                          bool always_on_top);
+                          bool preview_mode);
 
   // Returns whether a wallpaper policy is enforced for |account_id| (not
   // including device policy).
@@ -223,7 +218,8 @@
             const base::FilePath& user_data_path,
             const base::FilePath& chromeos_wallpapers_path,
             const base::FilePath& chromeos_custom_wallpapers_path,
-            const base::FilePath& device_policy_wallpaper_path) override;
+            const base::FilePath& device_policy_wallpaper_path,
+            bool is_device_wallpaper_policy_enforced) override;
   void SetCustomWallpaper(mojom::WallpaperUserInfoPtr user_info,
                           const std::string& wallpaper_files_id,
                           const std::string& file_name,
@@ -252,8 +248,7 @@
   void SetPolicyWallpaper(mojom::WallpaperUserInfoPtr user_info,
                           const std::string& wallpaper_files_id,
                           const std::string& data) override;
-  void SetDevicePolicyWallpaperPath(
-      const base::FilePath& device_policy_wallpaper_path) override;
+  void SetDeviceWallpaperPolicyEnforced(bool enforced) override;
   void SetThirdPartyWallpaper(mojom::WallpaperUserInfoPtr user_info,
                               const std::string& wallpaper_files_id,
                               const std::string& file_name,
@@ -267,8 +262,6 @@
   void ShowUserWallpaper(mojom::WallpaperUserInfoPtr user_info) override;
   void ShowSigninWallpaper() override;
   void ShowOneShotWallpaper(const gfx::ImageSkia& image) override;
-  void ShowAlwaysOnTopWallpaper(const base::FilePath& image_path) override;
-  void RemoveAlwaysOnTopWallpaper() override;
   void RemoveUserWallpaper(mojom::WallpaperUserInfoPtr user_info,
                            const std::string& wallpaper_files_id) override;
   void RemovePolicyWallpaper(mojom::WallpaperUserInfoPtr user_info,
@@ -296,8 +289,6 @@
   // ShellObserver:
   void OnRootWindowAdded(aura::Window* root_window) override;
   void OnLocalStatePrefServiceInitialized(PrefService* pref_service) override;
-  void OnShellInitialized() override;
-  void OnShellDestroying() override;
 
   // WallpaperResizerObserver:
   void OnWallpaperResized() override;
@@ -308,10 +299,6 @@
   // SessionObserver:
   void OnSessionStateChanged(session_manager::SessionState state) override;
 
-  // TabletModeObserver:
-  void OnTabletModeStarted() override;
-  void OnTabletModeEnded() override;
-
   // CompositorLockClient:
   void CompositorLockTimedOut() override;
 
@@ -513,10 +500,6 @@
   base::Optional<std::vector<SkColor>> GetCachedColors(
       const std::string& current_location) const;
 
-  // The callback when decoding of the always-on-top wallpaper completes.
-  void OnAlwaysOnTopWallpaperDecoded(const WallpaperInfo& info,
-                                     const gfx::ImageSkia& image);
-
   // Move all wallpaper widgets to the locked container.
   // Returns true if the wallpaper moved.
   bool MoveToLockedContainer();
@@ -556,10 +539,6 @@
   // simplicity, we only lock the compositor for the internal display.
   void GetInternalDisplayCompositorLock();
 
-  // Schedules paint on all WallpaperViews owned by WallpaperWidgetControllers.
-  // This is used when we want to change wallpaper dimming.
-  void RepaintWallpaper();
-
   bool locked_;
 
   WallpaperMode wallpaper_mode_;
@@ -618,15 +597,13 @@
   // The wallpaper animation duration. An empty value disables the animation.
   base::TimeDelta animation_duration_;
 
-  base::FilePath device_policy_wallpaper_path_;
+  // Whether the device wallpaper policy is enforced on this device.
+  bool is_device_wallpaper_policy_enforced_ = false;
 
   // Whether the current wallpaper (if any) is the first wallpaper since the
   // controller initialization. Empty wallpapers for testing don't count.
   bool is_first_wallpaper_ = false;
 
-  // If true, the current wallpaper should always stay on top.
-  bool is_always_on_top_wallpaper_ = false;
-
   scoped_refptr<base::SequencedTaskRunner> sequenced_task_runner_;
 
   ScopedSessionObserver scoped_session_observer_;
@@ -644,11 +621,6 @@
   // change). Has the same lifetime with |confirm_preview_wallpaper_callback_|.
   base::RepeatingClosure reload_preview_wallpaper_callback_;
 
-  // Called when the always-on-top wallpaper needs to be reloaded (e.g. display
-  // size change). Non-empty if and only if |is_always_on_top_wallpaper_| is
-  // true.
-  base::RepeatingClosure reload_always_on_top_wallpaper_callback_;
-
   // If true, use a solid color wallpaper as if it is the decoded image.
   bool bypass_decode_for_testing_ = false;
 
--- a/ash/wallpaper/wallpaper_controller_test_api.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wallpaper/wallpaper_controller_test_api.cc	2019-05-17 18:53:08.352000000 +0300
@@ -4,7 +4,6 @@
 
 #include "ash/wallpaper/wallpaper_controller_test_api.h"
 #include "ash/wallpaper/wallpaper_controller.h"
-#include "base/bind.h"
 #include "ui/gfx/canvas.h"
 #include "ui/gfx/color_utils.h"
 #include "ui/gfx/geometry/size.h"
@@ -34,7 +33,7 @@
 SkColor WallpaperControllerTestApi::ApplyColorProducingWallpaper() {
   controller_->ShowWallpaperImage(
       CreateImageWithColor(SkColorSetRGB(60, 40, 40)), kTestWallpaperInfo,
-      /*preview_mode=*/false, /*always_on_top=*/false);
+      false /*preview_mode=*/);
   return SkColorSetRGB(18, 12, 12);
 }
 
@@ -46,12 +45,12 @@
                      controller_->weak_factory_.GetWeakPtr(),
                      AccountId::FromUserEmail("user@test.com"),
                      user_manager::USER_TYPE_REGULAR, kTestWallpaperInfo,
-                     /*show_wallpaper=*/true);
-  controller_->reload_preview_wallpaper_callback_ = base::BindRepeating(
-      &WallpaperController::ShowWallpaperImage,
+                     true /*show_wallpaper=*/);
+  controller_->reload_preview_wallpaper_callback_ =
+      base::BindRepeating(&WallpaperController::ShowWallpaperImage,
       controller_->weak_factory_.GetWeakPtr(),
-      CreateImageWithColor(SK_ColorBLUE), kTestWallpaperInfo,
-      /*preview_mode=*/true, /*always_on_top=*/false);
+                          CreateImageWithColor(SK_ColorBLUE),
+                          kTestWallpaperInfo, true /*preview_mode=*/);
   // Show the preview wallpaper.
   controller_->reload_preview_wallpaper_callback_.Run();
 }
--- a/ash/wallpaper/wallpaper_controller_unittest.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wallpaper/wallpaper_controller_unittest.cc	2019-05-17 18:53:08.352000000 +0300
@@ -207,6 +207,7 @@
 
 // See content::RunAllTasksUntilIdle().
 void RunAllTasksUntilIdle() {
+  LOG(ERROR) << "RunAllTasksUntilIdle - before";
   while (true) {
     TaskObserver task_observer;
     base::MessageLoopCurrent::Get()->AddTaskObserver(&task_observer);
@@ -219,6 +220,7 @@
     if (!task_observer.processed())
       break;
   }
+  LOG(ERROR) << "RunAllTasksUntilIdle - after";
 }
 
 // A test implementation of the WallpaperObserver mojo interface.
@@ -352,7 +354,7 @@
     const gfx::ImageSkia kImage = CreateImage(10, 10, kWallpaperColor);
     controller_->ShowWallpaperImage(
         kImage, CreateWallpaperInfo(WALLPAPER_LAYOUT_STRETCH),
-        /*preview_mode=*/false, /*always_on_top=*/false);
+        false /*preview_mode=*/);
     SetSessionState(SessionState::ACTIVE);
 
     EXPECT_TRUE(ShouldCalculateColors());
@@ -535,10 +537,6 @@
 
   void ClearWallpaper() { controller_->current_wallpaper_.reset(); }
 
-  int GetWallpaperContainerId() {
-    return controller_->GetWallpaperContainerId(controller_->locked_);
-  }
-
   WallpaperController* controller_;  // Not owned.
 
   base::ScopedTempDir user_data_dir_;
@@ -698,9 +696,9 @@
 
   // Set the image as custom wallpaper, wait for the resize to finish, and check
   // that the resized image is the expected size.
-  controller_->ShowWallpaperImage(
-      image, CreateWallpaperInfo(WALLPAPER_LAYOUT_STRETCH),
-      /*preview_mode=*/false, /*always_on_top=*/false);
+  controller_->ShowWallpaperImage(image,
+                                  CreateWallpaperInfo(WALLPAPER_LAYOUT_STRETCH),
+                                  false /*preview_mode=*/);
   EXPECT_TRUE(image.BackedBySameObjectAs(controller_->GetWallpaper()));
   RunAllTasksUntilIdle();
   gfx::ImageSkia resized_image = controller_->GetWallpaper();
@@ -710,9 +708,9 @@
   // Load the original wallpaper again and check that we're still using the
   // previously-resized image instead of doing another resize
   // (http://crbug.com/321402).
-  controller_->ShowWallpaperImage(
-      image, CreateWallpaperInfo(WALLPAPER_LAYOUT_STRETCH),
-      /*preview_mode=*/false, /*always_on_top=*/false);
+  controller_->ShowWallpaperImage(image,
+                                  CreateWallpaperInfo(WALLPAPER_LAYOUT_STRETCH),
+                                  false /*preview_mode=*/);
   RunAllTasksUntilIdle();
   EXPECT_TRUE(resized_image.BackedBySameObjectAs(controller_->GetWallpaper()));
 }
@@ -771,7 +769,7 @@
     SCOPED_TRACE(base::StringPrintf("1200x600*2 high resolution"));
     controller_->ShowWallpaperImage(
         image_high_res, CreateWallpaperInfo(WALLPAPER_LAYOUT_CENTER),
-        /*preview_mode=*/false, /*always_on_top=*/false);
+        false /*preview_mode=*/);
     WallpaperFitToNativeResolution(wallpaper_view(), high_dsf,
                                    high_resolution.width(),
                                    high_resolution.height(), kWallpaperColor);
@@ -780,7 +778,7 @@
     SCOPED_TRACE(base::StringPrintf("1200x600*2 low resolution"));
     controller_->ShowWallpaperImage(
         image_low_res, CreateWallpaperInfo(WALLPAPER_LAYOUT_CENTER),
-        /*preview_mode=*/false, /*always_on_top=*/false);
+        false /*preview_mode=*/);
     WallpaperFitToNativeResolution(wallpaper_view(), high_dsf,
                                    low_resolution.width(),
                                    low_resolution.height(), kWallpaperColor);
@@ -791,7 +789,7 @@
     SCOPED_TRACE(base::StringPrintf("1200x600 high resolution"));
     controller_->ShowWallpaperImage(
         image_high_res, CreateWallpaperInfo(WALLPAPER_LAYOUT_CENTER),
-        /*preview_mode=*/false, /*always_on_top=*/false);
+        false /*preview_mode=*/);
     WallpaperFitToNativeResolution(wallpaper_view(), low_dsf,
                                    high_resolution.width(),
                                    high_resolution.height(), kWallpaperColor);
@@ -800,7 +798,7 @@
     SCOPED_TRACE(base::StringPrintf("1200x600 low resolution"));
     controller_->ShowWallpaperImage(
         image_low_res, CreateWallpaperInfo(WALLPAPER_LAYOUT_CENTER),
-        /*preview_mode=*/false, /*always_on_top=*/false);
+        false /*preview_mode=*/);
     WallpaperFitToNativeResolution(wallpaper_view(), low_dsf,
                                    low_resolution.width(),
                                    low_resolution.height(), kWallpaperColor);
@@ -811,7 +809,7 @@
     SCOPED_TRACE(base::StringPrintf("1200x600/u@1.5 high resolution"));
     controller_->ShowWallpaperImage(
         image_high_res, CreateWallpaperInfo(WALLPAPER_LAYOUT_CENTER),
-        /*preview_mode=*/false, /*always_on_top=*/false);
+        false /*preview_mode=*/);
     WallpaperFitToNativeResolution(wallpaper_view(), low_dsf,
                                    high_resolution.width(),
                                    high_resolution.height(), kWallpaperColor);
@@ -820,7 +818,7 @@
     SCOPED_TRACE(base::StringPrintf("1200x600/u@1.5 low resolution"));
     controller_->ShowWallpaperImage(
         image_low_res, CreateWallpaperInfo(WALLPAPER_LAYOUT_CENTER),
-        /*preview_mode=*/false, /*always_on_top=*/false);
+        false /*preview_mode=*/);
     WallpaperFitToNativeResolution(wallpaper_view(), low_dsf,
                                    low_resolution.width(),
                                    low_resolution.height(), kWallpaperColor);
@@ -1659,7 +1657,8 @@
             GetDecodeFilePaths()[0]);
 }
 
-// Display size change should trigger wallpaper reload.
+// Display size change should trigger reload for both user wallpaper and preview
+// wallpaper.
 TEST_F(WallpaperControllerTest, ReloadWallpaper) {
   CreateAndSaveWallpapers(account_id_1);
 
@@ -1698,26 +1697,6 @@
   UpdateDisplay("800x600");
   RunAllTasksUntilIdle();
   EXPECT_EQ(1, GetWallpaperCount());
-  ClearWallpaperCount();
-  controller_->CancelPreviewWallpaper();
-  RunAllTasksUntilIdle();
-  EXPECT_EQ(1, GetWallpaperCount());
-
-  // Show an always-on-top wallpaper.
-  const base::FilePath image_path =
-      base::CommandLine::ForCurrentProcess()->GetSwitchValuePath(
-          chromeos::switches::kGuestWallpaperLarge);
-  CreateDefaultWallpapers();
-  SetBypassDecode();
-  ClearWallpaperCount();
-  controller_->ShowAlwaysOnTopWallpaper(image_path);
-  RunAllTasksUntilIdle();
-  EXPECT_EQ(1, GetWallpaperCount());
-  // Rotating the display should trigger a wallpaper reload.
-  ClearWallpaperCount();
-  UpdateDisplay("800x600/r");
-  RunAllTasksUntilIdle();
-  EXPECT_EQ(1, GetWallpaperCount());
 }
 
 TEST_F(WallpaperControllerTest, UpdateCustomWallpaperLayout) {
@@ -1937,8 +1916,7 @@
 
   // Verify the device policy wallpaper is shown on login screen.
   SetSessionState(SessionState::LOGIN_PRIMARY);
-  controller_->SetDevicePolicyWallpaperPath(
-      base::FilePath(kDefaultSmallWallpaperName));
+  controller_->SetDeviceWallpaperPolicyEnforced(true);
   RunAllTasksUntilIdle();
   EXPECT_EQ(1, GetWallpaperCount());
   EXPECT_TRUE(IsDevicePolicyWallpaper());
@@ -2451,8 +2429,7 @@
   // Show the first wallpaper, verify the observer is notified.
   controller_->ShowWallpaperImage(CreateImage(640, 480, SK_ColorBLUE),
                                   CreateWallpaperInfo(WALLPAPER_LAYOUT_STRETCH),
-                                  /*preview_mode=*/false,
-                                  /*always_on_top=*/false);
+                                  false /*preview_mode=*/);
   RunAllTasksUntilIdle();
   EXPECT_EQ(SK_ColorBLUE, GetWallpaperColor());
   EXPECT_EQ(1, GetWallpaperCount());
@@ -2460,8 +2437,7 @@
   // Show the second wallpaper, verify the observer is not notified.
   controller_->ShowWallpaperImage(CreateImage(640, 480, SK_ColorCYAN),
                                   CreateWallpaperInfo(WALLPAPER_LAYOUT_STRETCH),
-                                  /*preview_mode=*/false,
-                                  /*always_on_top=*/false);
+                                  false /*preview_mode=*/);
   RunAllTasksUntilIdle();
   EXPECT_EQ(SK_ColorCYAN, GetWallpaperColor());
   EXPECT_EQ(2, GetWallpaperCount());
@@ -2513,55 +2489,6 @@
   EXPECT_EQ(kWallpaperColor, GetWallpaperColor());
 }
 
-TEST_F(WallpaperControllerTest, AlwaysOnTopWallpaper) {
-  CreateDefaultWallpapers();
-  SetBypassDecode();
-
-  // Show a default wallpaper.
-  EXPECT_EQ(0, GetWallpaperCount());
-  controller_->ShowSigninWallpaper();
-  RunAllTasksUntilIdle();
-  EXPECT_EQ(1, GetWallpaperCount());
-  EXPECT_EQ(controller_->GetWallpaperType(), DEFAULT);
-  EXPECT_EQ(kShellWindowId_WallpaperContainer, GetWallpaperContainerId());
-
-  // Show an always-on-top wallpaper.
-  const base::FilePath image_path =
-      base::CommandLine::ForCurrentProcess()->GetSwitchValuePath(
-          chromeos::switches::kGuestWallpaperLarge);
-  controller_->ShowAlwaysOnTopWallpaper(image_path);
-  RunAllTasksUntilIdle();
-  EXPECT_EQ(2, GetWallpaperCount());
-  EXPECT_EQ(controller_->GetWallpaperType(), ONE_SHOT);
-  EXPECT_EQ(kShellWindowId_AlwaysOnTopWallpaperContainer,
-            GetWallpaperContainerId());
-
-  // Subsequent wallpaper requests are ignored when the current wallpaper is
-  // always-on-top.
-  controller_->ShowSigninWallpaper();
-  RunAllTasksUntilIdle();
-  EXPECT_EQ(2, GetWallpaperCount());
-  EXPECT_EQ(controller_->GetWallpaperType(), ONE_SHOT);
-  EXPECT_EQ(kShellWindowId_AlwaysOnTopWallpaperContainer,
-            GetWallpaperContainerId());
-
-  // The wallpaper reverts to the default after the always-on-top wallpaper is
-  // removed.
-  controller_->RemoveAlwaysOnTopWallpaper();
-  RunAllTasksUntilIdle();
-  EXPECT_EQ(3, GetWallpaperCount());
-  EXPECT_EQ(controller_->GetWallpaperType(), DEFAULT);
-  EXPECT_EQ(kShellWindowId_WallpaperContainer, GetWallpaperContainerId());
-
-  // Calling |RemoveAlwaysOnTopWallpaper| is a no-op when the current wallpaper
-  // is not always-on-top.
-  controller_->RemoveAlwaysOnTopWallpaper();
-  RunAllTasksUntilIdle();
-  EXPECT_EQ(3, GetWallpaperCount());
-  EXPECT_EQ(controller_->GetWallpaperType(), DEFAULT);
-  EXPECT_EQ(kShellWindowId_WallpaperContainer, GetWallpaperContainerId());
-}
-
 // A test wallpaper controller client class.
 class TestWallpaperControllerClient : public mojom::WallpaperControllerClient {
  public:
--- a/ash/wallpaper/wallpaper_utils/wallpaper_decoder.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wallpaper/wallpaper_utils/wallpaper_decoder.cc	2019-05-17 18:53:08.352000000 +0300
@@ -5,7 +5,6 @@
 #include "ash/wallpaper/wallpaper_utils/wallpaper_decoder.h"
 
 #include "ash/shell.h"
-#include "base/bind.h"
 #include "ipc/ipc_channel.h"
 
 namespace ash {
--- a/ash/wallpaper/wallpaper_view.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wallpaper/wallpaper_view.cc	2019-05-17 18:53:08.352000000 +0300
@@ -12,7 +12,8 @@
 #include "ash/shell.h"
 #include "ash/wallpaper/wallpaper_controller.h"
 #include "ash/wallpaper/wallpaper_widget_controller.h"
-#include "ash/wm/tablet_mode/tablet_mode_controller.h"
+#include "ash/wm/overview/overview_controller.h"
+#include "ash/wm/overview/overview_utils.h"
 #include "ui/aura/window.h"
 #include "ui/display/display.h"
 #include "ui/display/manager/display_manager.h"
@@ -32,7 +33,7 @@
 
 // The value used for alpha to apply a dark filter to the wallpaper in tablet
 // mode. A higher number up to 255 results in a darker wallpaper.
-constexpr int kTabletModeWallpaperAlpha = 102;
+constexpr int kWallpaperDimnessInTabletMode = 102;
 
 // A view that controls the child view's layer so that the layer always has the
 // same size as the display's original, un-scaled size in DIP. The layer is then
@@ -85,27 +86,84 @@
       SkColorSetA(login_constants::kDefaultBaseColor,
                   login_constants::kTranslucentColorDarkenAlpha),
       SkColorSetA(darken_color, 0xFF));
+  return SkColorSetA(darken_color, login_constants::kTranslucentAlpha);
+}
 
-  int alpha = login_constants::kTranslucentAlpha;
-  if (Shell::Get()
-          ->tablet_mode_controller()
-          ->IsTabletModeWindowManagerEnabled()) {
-    alpha = kTabletModeWallpaperAlpha;
-  }
-
-  return SkColorSetA(darken_color, alpha);
+SkColor GetWallpaperDarkenColorForTabletMode() {
+  return SkColorSetA(GetWallpaperDarkenColor(), kWallpaperDimnessInTabletMode);
 }
 
 }  // namespace
 
+// This event handler receives events in the pre-target phase and takes care of
+// the following:
+//   - Disabling overview mode on touch release.
+//   - Disabling overview mode on mouse release.
+class PreEventDispatchHandler : public ui::EventHandler {
+ public:
+  PreEventDispatchHandler() = default;
+  ~PreEventDispatchHandler() override = default;
+
+ private:
+  // ui::EventHandler:
+  void OnMouseEvent(ui::MouseEvent* event) override {
+    if (event->type() == ui::ET_MOUSE_RELEASED)
+      HandleClickOrTap(event);
+  }
+
+  void OnGestureEvent(ui::GestureEvent* event) override {
+    if (event->type() == ui::ET_GESTURE_TAP)
+      HandleClickOrTap(event);
+  }
+
+  void HandleClickOrTap(ui::Event* event) {
+    CHECK_EQ(ui::EP_PRETARGET, event->phase());
+    OverviewController* controller = Shell::Get()->overview_controller();
+    if (!controller->IsSelecting())
+      return;
+    // Events that happen while app list is sliding out during overview should
+    // be ignored to prevent overview from disappearing out from under the user.
+    if (!IsSlidingOutOverviewFromShelf())
+      controller->ToggleOverview();
+    event->StopPropagation();
+  }
+
+  DISALLOW_COPY_AND_ASSIGN(PreEventDispatchHandler);
+};
+
 ////////////////////////////////////////////////////////////////////////////////
 // WallpaperView, public:
 
-WallpaperView::WallpaperView() {
+WallpaperView::WallpaperView()
+    : pre_dispatch_handler_(new PreEventDispatchHandler()) {
   set_context_menu_controller(this);
+  AddPreTargetHandler(pre_dispatch_handler_.get());
+  tablet_mode_observer_.Add(Shell::Get()->tablet_mode_controller());
+  is_tablet_mode_ = Shell::Get()
+                        ->tablet_mode_controller()
+                        ->IsTabletModeWindowManagerEnabled();
 }
 
-WallpaperView::~WallpaperView() = default;
+WallpaperView::~WallpaperView() {
+  RemovePreTargetHandler(pre_dispatch_handler_.get());
+}
+
+void WallpaperView::OnTabletModeStarted() {
+  is_tablet_mode_ = true;
+  SchedulePaint();
+}
+
+void WallpaperView::OnTabletModeEnded() {
+  is_tablet_mode_ = false;
+  SchedulePaint();
+}
+
+void WallpaperView::OnTabletControllerDestroyed() {
+  tablet_mode_observer_.RemoveAll();
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// WallpaperView, views::View overrides:
 
 void WallpaperView::OnPaint(gfx::Canvas* canvas) {
   // Scale the image while maintaining the aspect ratio, cropping as necessary
@@ -127,6 +185,9 @@
   if (controller->ShouldApplyDimming()) {
     flags.setColorFilter(SkColorFilter::MakeModeFilter(
         GetWallpaperDarkenColor(), SkBlendMode::kDarken));
+  } else if (is_tablet_mode_) {
+    flags.setColorFilter(SkColorFilter::MakeModeFilter(
+        GetWallpaperDarkenColorForTabletMode(), SkBlendMode::kDarken));
   }
 
   switch (layout) {
@@ -194,15 +255,14 @@
   return true;
 }
 
-void WallpaperView::ShowContextMenuForViewImpl(views::View* source,
+void WallpaperView::ShowContextMenuForView(views::View* source,
                                                const gfx::Point& point,
                                                ui::MenuSourceType source_type) {
   Shell::Get()->ShowContextMenu(point, source_type);
 }
 
 views::Widget* CreateWallpaperWidget(aura::Window* root_window,
-                                     int container_id,
-                                     WallpaperView** out_wallpaper_view) {
+                                     int container_id) {
   WallpaperController* controller = Shell::Get()->wallpaper_controller();
 
   views::Widget* wallpaper_widget = new views::Widget;
@@ -215,7 +275,6 @@
   wallpaper_widget->Init(params);
   WallpaperView* wallpaper_view = new WallpaperView();  // Owned by views.
   wallpaper_widget->SetContentsView(new LayerControlView(wallpaper_view));
-  *out_wallpaper_view = wallpaper_view;
   int animation_type =
       controller->ShouldShowInitialAnimation()
           ? wm::WINDOW_VISIBILITY_ANIMATION_TYPE_BRIGHTNESS_GRAYSCALE
--- a/ash/wallpaper/wallpaper_view.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wallpaper/wallpaper_view.h	2019-05-17 18:53:08.352000000 +0300
@@ -5,6 +5,11 @@
 #ifndef ASH_WALLPAPER_WALLPAPER_VIEW_H_
 #define ASH_WALLPAPER_WALLPAPER_VIEW_H_
 
+#include <memory>
+
+#include "ash/wm/tablet_mode/tablet_mode_controller.h"
+#include "ash/wm/tablet_mode/tablet_mode_observer.h"
+#include "base/scoped_observer.h"
 #include "ui/views/context_menu_controller.h"
 #include "ui/views/view.h"
 
@@ -14,7 +19,11 @@
 
 namespace ash {
 
-class WallpaperView : public views::View, public views::ContextMenuController {
+class PreEventDispatchHandler;
+
+class WallpaperView : public views::View,
+                      public views::ContextMenuController,
+                      TabletModeObserver {
  public:
   WallpaperView();
   ~WallpaperView() override;
@@ -22,21 +31,31 @@
  private:
   friend class WallpaperControllerTest;
 
-  // views::View:
+  // Overridden from views::View:
   void OnPaint(gfx::Canvas* canvas) override;
   bool OnMousePressed(const ui::MouseEvent& event) override;
 
-  // views::ContextMenuController:
-  void ShowContextMenuForViewImpl(views::View* source,
+  // Overridden from TabletModeObserver:
+  void OnTabletModeStarted() override;
+  void OnTabletModeEnded() override;
+  void OnTabletControllerDestroyed() override;
+
+  // Overridden from views::ContextMenuController:
+  void ShowContextMenuForView(views::View* source,
                                   const gfx::Point& point,
                                   ui::MenuSourceType source_type) override;
 
+  ScopedObserver<TabletModeController, TabletModeObserver>
+      tablet_mode_observer_{this};
+  bool is_tablet_mode_ = false;
+
+  std::unique_ptr<PreEventDispatchHandler> pre_dispatch_handler_;
+
   DISALLOW_COPY_AND_ASSIGN(WallpaperView);
 };
 
 views::Widget* CreateWallpaperWidget(aura::Window* root_window,
-                                     int container_id,
-                                     WallpaperView** out_wallpaper_view);
+                                     int container_id);
 
 }  // namespace ash
 
--- a/ash/wallpaper/wallpaper_widget_controller.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wallpaper/wallpaper_widget_controller.cc	2019-05-17 18:53:08.352000000 +0300
@@ -191,9 +191,7 @@
   animation_end_callbacks_.emplace_back(std::move(callback));
 }
 
-void WallpaperWidgetController::SetWallpaperWidget(
-    views::Widget* widget,
-    WallpaperView* wallpaper_view,
+void WallpaperWidgetController::SetWallpaperWidget(views::Widget* widget,
     float blur_sigma) {
   DCHECK(widget);
 
@@ -207,8 +205,6 @@
   animating_widget_ = std::make_unique<WidgetHandler>(this, widget);
   animating_widget_->SetBlur(blur_sigma);
   animating_widget_->Show();
-
-  wallpaper_view_ = wallpaper_view;
 }
 
 bool WallpaperWidgetController::Reparent(aura::Window* root_window,
--- a/ash/wallpaper/wallpaper_widget_controller.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wallpaper/wallpaper_widget_controller.h	2019-05-17 18:53:08.352000000 +0300
@@ -21,7 +21,6 @@
 }
 
 namespace ash {
-class WallpaperView;
 
 // This class manages widget-based wallpapers.
 // WallpaperWidgetController is owned by RootWindowController.
@@ -53,9 +52,7 @@
   // |animating_widget_|).
   // |blur_sigma| - if non-zero, the blur that should be applied to the
   //     wallpaper widget layer.
-  void SetWallpaperWidget(views::Widget* widget,
-                          WallpaperView* wallpaper_view,
-                          float blur_sigma);
+  void SetWallpaperWidget(views::Widget* widget, float blur_sigma);
 
   // Move the wallpaper for |root_window| to the specified |container|.
   // The lock screen moves the wallpaper container to hides the user's windows.
@@ -68,10 +65,6 @@
   // Returns the blur sigma applied on the wallpaper layer.
   float GetWallpaperBlur() const;
 
-  // TODO: Get the wallpaper view from |animating_widget_| or |active_widget_|
-  // instead of caching the pointer value.
-  WallpaperView* wallpaper_view() const { return wallpaper_view_; }
-
   // Reset, and closes both |active_widget_| and |animating_widget_|. Can be
   // used in tests to reset the wallpaper widget controller state.
   void ResetWidgetsForTesting();
@@ -104,10 +97,6 @@
   // shown.
   std::unique_ptr<WidgetHandler> animating_widget_;
 
-  // Pointer to the wallpaper view owned by |animating_widget_| if it exists,
-  // otherwise owned by |active_widget_|.
-  WallpaperView* wallpaper_view_ = nullptr;
-
   // Callbacks to be run when the |animating_widget_| stops animating and gets
   // set as the active widget.
   std::list<base::OnceClosure> animation_end_callbacks_;
--- a/ash/wm/always_on_top_controller.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/always_on_top_controller.cc	2019-05-17 18:53:08.356000000 +0300
@@ -5,52 +5,39 @@
 #include "ash/wm/always_on_top_controller.h"
 
 #include "ash/public/cpp/shell_window_ids.h"
-#include "ash/public/cpp/window_properties.h"
-#include "ash/wm/window_state.h"
 #include "ash/wm/workspace/workspace_layout_manager.h"
 #include "ui/aura/client/aura_constants.h"
 #include "ui/aura/window.h"
 
 namespace ash {
 
-DEFINE_UI_CLASS_PROPERTY_KEY(bool, kDisallowReparentKey, false)
-
-AlwaysOnTopController::AlwaysOnTopController(
-    aura::Window* always_on_top_container,
-    aura::Window* pip_container)
-    : always_on_top_container_(always_on_top_container),
-      pip_container_(pip_container) {
-  DCHECK_NE(kShellWindowId_DefaultContainer, always_on_top_container_->id());
-  DCHECK_NE(kShellWindowId_DefaultContainer, pip_container_->id());
+AlwaysOnTopController::AlwaysOnTopController(aura::Window* viewport)
+    : always_on_top_container_(viewport) {
+  DCHECK_NE(kShellWindowId_DefaultContainer, viewport->id());
   always_on_top_container_->SetLayoutManager(
-      new WorkspaceLayoutManager(always_on_top_container_));
-  pip_container_->SetLayoutManager(new WorkspaceLayoutManager(pip_container_));
+      new WorkspaceLayoutManager(viewport));
   // Container should be empty.
   DCHECK(always_on_top_container_->children().empty());
-  DCHECK(pip_container_->children().empty());
   always_on_top_container_->AddObserver(this);
-  pip_container->AddObserver(this);
 }
 
 AlwaysOnTopController::~AlwaysOnTopController() {
-  // At this point, all windows should be removed and AlwaysOnTopController
-  // will have removed itself as an observer in OnWindowDestroying.
-  DCHECK(!always_on_top_container_);
-  DCHECK(!pip_container_);
+  if (always_on_top_container_)
+    always_on_top_container_->RemoveObserver(this);
 }
 
 aura::Window* AlwaysOnTopController::GetContainer(aura::Window* window) const {
   DCHECK(always_on_top_container_);
-  DCHECK(pip_container_);
-
-  if (!window->GetProperty(aura::client::kAlwaysOnTopKey)) {
+  if (window->GetProperty(aura::client::kAlwaysOnTopKey))
+    return always_on_top_container_;
     return always_on_top_container_->GetRootWindow()->GetChildById(
         kShellWindowId_DefaultContainer);
-  }
-  if (window->parent() && wm::GetWindowState(window)->IsPip())
-    return pip_container_;
+}
 
-  return always_on_top_container_;
+// TODO(rsadam@): Refactor so that this cast is unneeded.
+WorkspaceLayoutManager* AlwaysOnTopController::GetLayoutManager() const {
+  return static_cast<WorkspaceLayoutManager*>(
+      always_on_top_container_->layout_manager());
 }
 
 void AlwaysOnTopController::SetLayoutManagerForTest(
@@ -58,48 +45,24 @@
   always_on_top_container_->SetLayoutManager(layout_manager.release());
 }
 
-void AlwaysOnTopController::SetDisallowReparent(aura::Window* window) {
-  window->SetProperty(kDisallowReparentKey, true);
-}
-
-void AlwaysOnTopController::AddWindow(aura::Window* window) {
-  window->AddObserver(this);
-  wm::GetWindowState(window)->AddObserver(this);
-}
-
-void AlwaysOnTopController::RemoveWindow(aura::Window* window) {
-  window->RemoveObserver(this);
-  wm::GetWindowState(window)->RemoveObserver(this);
-}
-
-void AlwaysOnTopController::ReparentWindow(aura::Window* window) {
-  DCHECK(window->type() == aura::client::WINDOW_TYPE_NORMAL ||
-         window->type() == aura::client::WINDOW_TYPE_POPUP);
-  aura::Window* container = GetContainer(window);
-  if (window->parent() != container &&
-      !window->GetProperty(ash::kDisallowReparentKey))
-    container->AddChild(window);
-}
-
 void AlwaysOnTopController::OnWindowHierarchyChanged(
     const HierarchyChangeParams& params) {
-  if (params.old_parent == always_on_top_container_ ||
-      params.old_parent == pip_container_) {
-    RemoveWindow(params.target);
-  }
-
-  if (params.new_parent == always_on_top_container_ ||
-      params.new_parent == pip_container_) {
-    AddWindow(params.target);
-  }
+  if (params.old_parent == always_on_top_container_)
+    params.target->RemoveObserver(this);
+  else if (params.new_parent == always_on_top_container_)
+    params.target->AddObserver(this);
 }
 
 void AlwaysOnTopController::OnWindowPropertyChanged(aura::Window* window,
                                                     const void* key,
                                                     intptr_t old) {
-  if (window != always_on_top_container_ && window != pip_container_ &&
+  if (window != always_on_top_container_ &&
       key == aura::client::kAlwaysOnTopKey) {
-    ReparentWindow(window);
+    DCHECK(window->type() == aura::client::WINDOW_TYPE_NORMAL ||
+           window->type() == aura::client::WINDOW_TYPE_POPUP);
+    aura::Window* container = GetContainer(window);
+    if (window->parent() != container)
+      container->AddChild(window);
   }
 }
 
@@ -107,18 +70,7 @@
   if (window == always_on_top_container_) {
     always_on_top_container_->RemoveObserver(this);
     always_on_top_container_ = nullptr;
-  } else if (window == pip_container_) {
-    pip_container_->RemoveObserver(this);
-    pip_container_ = nullptr;
-  } else {
-    RemoveWindow(window);
   }
 }
 
-void AlwaysOnTopController::OnPreWindowStateTypeChange(
-    wm::WindowState* window_state,
-    mojom::WindowStateType old_type) {
-  ReparentWindow(window_state->window());
-}
-
 }  // namespace ash
--- a/ash/wm/always_on_top_controller.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/always_on_top_controller.h	2019-05-17 18:53:08.356000000 +0300
@@ -8,7 +8,6 @@
 #include <memory>
 
 #include "ash/ash_export.h"
-#include "ash/wm/window_state_observer.h"
 #include "base/macros.h"
 #include "ui/aura/window_observer.h"
 
@@ -20,26 +19,20 @@
 // 'AlwaysOnTop' property. That is, putting a window into the worskpace
 // container if its "AlwaysOnTop" property is false. Otherwise, put it in
 // |always_on_top_container_|.
-class ASH_EXPORT AlwaysOnTopController : public aura::WindowObserver,
-                                         wm::WindowStateObserver {
+class ASH_EXPORT AlwaysOnTopController : public aura::WindowObserver {
  public:
-  explicit AlwaysOnTopController(aura::Window* always_on_top_container,
-                                 aura::Window* pip_container);
+  explicit AlwaysOnTopController(aura::Window* viewport);
   ~AlwaysOnTopController() override;
 
   // Gets container for given |window| based on its "AlwaysOnTop" property.
   aura::Window* GetContainer(aura::Window* window) const;
 
+  WorkspaceLayoutManager* GetLayoutManager() const;
+
   void SetLayoutManagerForTest(
       std::unique_ptr<WorkspaceLayoutManager> layout_manager);
 
-  static void SetDisallowReparent(aura::Window* window);
-
  private:
-  void AddWindow(aura::Window* window);
-  void RemoveWindow(aura::Window* window);
-  void ReparentWindow(aura::Window* window);
-
   // Overridden from aura::WindowObserver:
   void OnWindowHierarchyChanged(const HierarchyChangeParams& params) override;
   void OnWindowPropertyChanged(aura::Window* window,
@@ -47,16 +40,11 @@
                                intptr_t old) override;
   void OnWindowDestroying(aura::Window* window) override;
 
-  // Overridden from wm::WindowStateObserver:
-  void OnPreWindowStateTypeChange(wm::WindowState* window_state,
-                                  mojom::WindowStateType old_type) override;
-
   aura::Window* always_on_top_container_;
-  aura::Window* pip_container_;
 
   DISALLOW_COPY_AND_ASSIGN(AlwaysOnTopController);
 };
 
-}  // namespace ash
+}  // namepsace ash
 
 #endif  // ASH_WM_ALWAYS_ON_TOP_CONTROLLER_H_
--- a/ash/wm/always_on_top_controller_unittest.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/always_on_top_controller_unittest.cc	2019-05-17 18:53:08.356000000 +0300
@@ -9,12 +9,9 @@
 #include "ash/root_window_controller.h"
 #include "ash/shell.h"
 #include "ash/test/ash_test_base.h"
-#include "ash/wm/window_state.h"
-#include "ash/wm/wm_event.h"
 #include "ash/wm/workspace/workspace_layout_manager.h"
 #include "base/command_line.h"
 #include "base/memory/ptr_util.h"
-#include "ui/aura/client/aura_constants.h"
 #include "ui/keyboard/keyboard_controller.h"
 #include "ui/keyboard/keyboard_ui.h"
 #include "ui/keyboard/public/keyboard_switches.h"
@@ -22,10 +19,10 @@
 
 namespace ash {
 
-class AlwaysOnTopControllerTest : public AshTestBase {
+class VirtualKeyboardAlwaysOnTopControllerTest : public AshTestBase {
  public:
-  AlwaysOnTopControllerTest() = default;
-  ~AlwaysOnTopControllerTest() override = default;
+  VirtualKeyboardAlwaysOnTopControllerTest() = default;
+  ~VirtualKeyboardAlwaysOnTopControllerTest() override = default;
 
   void SetUp() override {
     base::CommandLine::ForCurrentProcess()->AppendSwitch(
@@ -34,7 +31,7 @@
   }
 
  private:
-  DISALLOW_COPY_AND_ASSIGN(AlwaysOnTopControllerTest);
+  DISALLOW_COPY_AND_ASSIGN(VirtualKeyboardAlwaysOnTopControllerTest);
 };
 
 class TestLayoutManager : public WorkspaceLayoutManager {
@@ -59,7 +56,7 @@
 
 // Verifies that the always on top controller is notified of keyboard bounds
 // changing events.
-TEST_F(AlwaysOnTopControllerTest, NotifyKeyboardBoundsChanging) {
+TEST_F(VirtualKeyboardAlwaysOnTopControllerTest, NotifyKeyboardBoundsChanging) {
   aura::Window* root_window = Shell::GetPrimaryRootWindow();
   aura::Window* always_on_top_container =
       Shell::GetContainer(root_window, kShellWindowId_AlwaysOnTopContainer);
@@ -79,81 +76,4 @@
   ASSERT_TRUE(manager->keyboard_bounds_changed());
 }
 
-TEST_F(AlwaysOnTopControllerTest,
-       AlwaysOnTopContainerReturnedForAlwaysOnTopWindow) {
-  RootWindowController* controller = Shell::GetPrimaryRootWindowController();
-  AlwaysOnTopController* always_on_top_controller =
-      controller->always_on_top_controller();
-
-  const gfx::Rect bounds(100, 100, 200, 200);
-  std::unique_ptr<aura::Window> always_on_top_window(
-      CreateTestWindowInShellWithBounds(bounds));
-  always_on_top_window->SetProperty(aura::client::kAlwaysOnTopKey, true);
-
-  aura::Window* container =
-      always_on_top_controller->GetContainer(always_on_top_window.get());
-  ASSERT_TRUE(container);
-  EXPECT_EQ(kShellWindowId_AlwaysOnTopContainer, container->id());
-}
-
-TEST_F(AlwaysOnTopControllerTest, PipContainerReturnedForAlwaysOnTopPipWindow) {
-  RootWindowController* controller = Shell::GetPrimaryRootWindowController();
-  AlwaysOnTopController* always_on_top_controller =
-      controller->always_on_top_controller();
-
-  const gfx::Rect bounds(100, 100, 200, 200);
-  std::unique_ptr<aura::Window> pip_window(
-      CreateTestWindowInShellWithBounds(bounds));
-
-  wm::WindowState* window_state = wm::GetWindowState(pip_window.get());
-  const wm::WMEvent enter_pip(wm::WM_EVENT_PIP);
-  window_state->OnWMEvent(&enter_pip);
-  pip_window->SetProperty(aura::client::kAlwaysOnTopKey, true);
-  EXPECT_TRUE(window_state->IsPip());
-
-  aura::Window* container =
-      always_on_top_controller->GetContainer(pip_window.get());
-  ASSERT_TRUE(container);
-  EXPECT_EQ(kShellWindowId_PipContainer, container->id());
-}
-
-TEST_F(AlwaysOnTopControllerTest,
-       DefaultContainerReturnedForWindowNotAlwaysOnTop) {
-  RootWindowController* controller = Shell::GetPrimaryRootWindowController();
-  AlwaysOnTopController* always_on_top_controller =
-      controller->always_on_top_controller();
-
-  const gfx::Rect bounds(100, 100, 200, 200);
-  std::unique_ptr<aura::Window> window(
-      CreateTestWindowInShellWithBounds(bounds));
-
-  aura::Window* container =
-      always_on_top_controller->GetContainer(window.get());
-  ASSERT_TRUE(container);
-  EXPECT_EQ(kShellWindowId_DefaultContainer, container->id());
-}
-
-TEST_F(AlwaysOnTopControllerTest,
-       AlwaysOnTopWindowMovedBetweenContainersWhenPipStateChanges) {
-  const gfx::Rect bounds(100, 100, 200, 200);
-  std::unique_ptr<aura::Window> window(
-      CreateTestWindowInShellWithBounds(bounds));
-  window->SetProperty(aura::client::kAlwaysOnTopKey, true);
-
-  EXPECT_EQ(kShellWindowId_AlwaysOnTopContainer, window->parent()->id());
-
-  wm::WindowState* window_state = wm::GetWindowState(window.get());
-  const wm::WMEvent enter_pip(wm::WM_EVENT_PIP);
-  window_state->OnWMEvent(&enter_pip);
-  EXPECT_TRUE(window_state->IsPip());
-
-  EXPECT_EQ(kShellWindowId_PipContainer, window->parent()->id());
-
-  const wm::WMEvent enter_normal(wm::WM_EVENT_NORMAL);
-  window_state->OnWMEvent(&enter_normal);
-  EXPECT_FALSE(window_state->IsPip());
-
-  EXPECT_EQ(kShellWindowId_AlwaysOnTopContainer, window->parent()->id());
-}
-
 }  // namespace ash
--- a/ash/wm/base_state.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/base_state.cc	2019-05-17 18:53:08.356000000 +0300
@@ -5,7 +5,6 @@
 #include "ash/wm/base_state.h"
 
 #include "ash/public/cpp/window_animation_types.h"
-#include "ash/public/cpp/window_properties.h"
 #include "ash/public/cpp/window_state_type.h"
 #include "ash/screen_util.h"
 #include "ash/shell.h"
@@ -150,12 +149,8 @@
     // Save the previous show state when it is not minimized so that we can
     // correctly restore it after exiting the minimized mode.
     if (!IsMinimizedWindowStateType(previous_state_type)) {
-      window->SetProperty(
-          aura::client::kPreMinimizedShowStateKey,
-          ToWindowShowState(
-              previous_state_type == mojom::WindowStateType::PIP
-                  ? window->GetProperty(ash::kPrePipWindowStateTypeKey)
-                  : previous_state_type));
+      window->SetProperty(aura::client::kPreMinimizedShowStateKey,
+                          ToWindowShowState(previous_state_type));
     }
     // Count minimizing a PIP window as dismissing it. Android apps in PIP mode
     // don't exit when they are dismissed, they just go back to being a regular
--- a/ash/wm/default_state.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/default_state.cc	2019-05-17 18:53:08.356000000 +0300
@@ -380,7 +380,7 @@
   }
   if (window_state->IsFullscreen() || window_state->IsPinned()) {
     window_state->SetBoundsDirect(
-        screen_util::GetFullscreenWindowBoundsInParent(window_state->window()));
+        screen_util::GetDisplayBoundsInParent(window_state->window()));
     return true;
   }
   return false;
@@ -389,8 +389,7 @@
 // static
 void DefaultState::SetBounds(WindowState* window_state,
                              const SetBoundsEvent* event) {
-  if (!event->animate() &&
-      (window_state->is_dragged() || window_state->allow_set_bounds_direct())) {
+  if (window_state->is_dragged() || window_state->allow_set_bounds_direct()) {
     // TODO(oshima|varkha): Is this still needed? crbug.com/485612.
     window_state->SetBoundsDirect(event->requested_bounds());
   } else if (!SetMaximizedOrFullscreenBounds(window_state)) {
@@ -553,7 +552,7 @@
     case mojom::WindowStateType::FULLSCREEN:
     case mojom::WindowStateType::PINNED:
     case mojom::WindowStateType::TRUSTED_PINNED:
-      bounds_in_parent = screen_util::GetFullscreenWindowBoundsInParent(window);
+      bounds_in_parent = screen_util::GetDisplayBoundsInParent(window);
       break;
 
     case mojom::WindowStateType::MINIMIZED:
--- a/ash/wm/default_window_resizer.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/default_window_resizer.cc	2019-05-17 18:53:08.356000000 +0300
@@ -27,7 +27,7 @@
     if (!did_move_or_resize_ && !details().restore_bounds.IsEmpty())
       window_state_->ClearRestoreBounds();
     did_move_or_resize_ = true;
-    SetBoundsDuringResize(bounds);
+    GetTarget()->SetBounds(bounds);
   }
 }
 
--- a/ash/wm/default_window_resizer_unittest.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/default_window_resizer_unittest.cc	2019-05-17 18:53:08.356000000 +0300
@@ -8,12 +8,10 @@
 #include "ash/shell.h"
 #include "ash/test/ash_test_base.h"
 #include "ash/window_factory.h"
-#include "base/test/metrics/histogram_tester.h"
 #include "ui/aura/client/aura_constants.h"
 #include "ui/aura/test/test_window_delegate.h"
 #include "ui/base/hit_test.h"
 #include "ui/base/ui_base_types.h"
-#include "ui/compositor/test/test_utils.h"
 
 namespace ash {
 
@@ -52,7 +50,6 @@
 
   aura::test::TestWindowDelegate delegate_;
   std::unique_ptr<aura::Window> aspect_ratio_window_;
-  base::HistogramTester histograms_;
 
  private:
   DISALLOW_COPY_AND_ASSIGN(DefaultWindowResizerTest);
@@ -158,40 +155,4 @@
   EXPECT_EQ("250,250 200x400", aspect_ratio_window_->bounds().ToString());
 }
 
-TEST_F(DefaultWindowResizerTest, NoResizeHistogramOnMove) {
-  std::unique_ptr<aura::Window> window =
-      window_factory::NewWindow(&delegate_, aura::client::WINDOW_TYPE_NORMAL);
-  window->Init(ui::LAYER_NOT_DRAWN);
-  ParentWindowInPrimaryRootWindow(window.get());
-  window->SetBounds(gfx::Rect(0, 0, 50, 50));
-  std::unique_ptr<WindowResizer> resizer(
-      CreateDefaultWindowResizer(window.get(), gfx::Point(), HTCAPTION));
-  ASSERT_TRUE(resizer.get());
-
-  // Move the window. A move should not generate a resize histogram.
-  resizer->Drag(gfx::Point(50, 50), 0);
-  EXPECT_EQ(gfx::Point(50, 50), window->bounds().origin());
-  resizer->CompleteDrag();
-  ui::WaitForNextFrameToBePresented(window->GetHost()->compositor());
-  histograms_.ExpectTotalCount("Ash.InteractiveWindowResize.TimeToPresent", 0);
-}
-
-TEST_F(DefaultWindowResizerTest, ResizeHistogram) {
-  std::unique_ptr<aura::Window> window =
-      window_factory::NewWindow(&delegate_, aura::client::WINDOW_TYPE_NORMAL);
-  window->Init(ui::LAYER_NOT_DRAWN);
-  ParentWindowInPrimaryRootWindow(window.get());
-  window->SetBounds(gfx::Rect(0, 0, 50, 50));
-  std::unique_ptr<WindowResizer> resizer(
-      CreateDefaultWindowResizer(window.get(), gfx::Point(), HTRIGHT));
-  ASSERT_TRUE(resizer.get());
-
-  // Resize the window, which should generate a resize histogram.
-  resizer->Drag(gfx::Point(50, 50), 0);
-  EXPECT_NE(gfx::Size(50, 50), window->bounds().size());
-  resizer->CompleteDrag();
-  ui::WaitForNextFrameToBePresented(window->GetHost()->compositor());
-  histograms_.ExpectTotalCount("Ash.InteractiveWindowResize.TimeToPresent", 1);
-}
-
 }  // namespace ash
--- a/ash/wm/drag_window_resizer_unittest.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/drag_window_resizer_unittest.cc	2019-05-17 18:53:08.360000000 +0300
@@ -225,7 +225,7 @@
     // Window origin should be adjusted for minimum visibility (25px).
     int expected_x = -50 + wm::kMinimumOnScreenArea;
 
-    EXPECT_EQ(base::NumberToString(expected_x) + ",10 50x60",
+    EXPECT_EQ(base::IntToString(expected_x) + ",10 50x60",
               window_->bounds().ToString());
   }
   // Dropping a window that is larger than the destination work area
--- a/ash/wm/immersive_fullscreen_controller_unittest.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/immersive_fullscreen_controller_unittest.cc	2019-05-17 18:53:08.360000000 +0300
@@ -4,8 +4,6 @@
 
 #include "ash/public/cpp/immersive/immersive_fullscreen_controller.h"
 
-#include "ash/frame/header_view.h"
-#include "ash/frame/non_client_frame_view_ash.h"
 #include "ash/public/cpp/ash_features.h"
 #include "ash/public/cpp/immersive/immersive_fullscreen_controller_delegate.h"
 #include "ash/public/cpp/immersive/immersive_fullscreen_controller_test_api.h"
@@ -119,10 +117,6 @@
   bool CanResize() const override { return true; }
   bool CanMaximize() const override { return true; }
   bool CanActivate() const override { return true; }
-  views::NonClientFrameView* CreateNonClientFrameView(
-      views::Widget* widget) override {
-    return new NonClientFrameViewAsh(widget);
-  }
 
  private:
   DISALLOW_COPY_AND_ASSIGN(TestWidgetDelegate);
@@ -136,42 +130,36 @@
     MODALITY_GESTURE_SCROLL
   };
 
-  ImmersiveFullscreenControllerTest() = default;
+  ImmersiveFullscreenControllerTest()
+      : widget_(nullptr), top_container_(nullptr), content_view_(nullptr) {}
   ~ImmersiveFullscreenControllerTest() override = default;
 
-  ImmersiveFullscreenController* controller() {
-    return ImmersiveFullscreenController::GetForTest(widget());
-  }
+  ImmersiveFullscreenController* controller() { return controller_.get(); }
 
   views::NativeViewHost* content_view() { return content_view_; }
 
-  views::View* top_container() {
-    return NonClientFrameViewAsh::Get(window())->GetHeaderView();
-  }
+  views::View* top_container() { return top_container_; }
 
   views::Widget* widget() { return widget_; }
 
   aura::Window* window() { return widget_->GetNativeWindow(); }
 
-  HeaderView* immersive_delegate() {
-    return NonClientFrameViewAsh::Get(window())->GetHeaderView();
+  MockImmersiveFullscreenControllerDelegate* delegate() {
+    return delegate_.get();
   }
 
   // Access to private data from the controller.
-  bool top_edge_hover_timer_running() {
-    return controller()->top_edge_hover_timer_.IsRunning();
+  bool top_edge_hover_timer_running() const {
+    return controller_->top_edge_hover_timer_.IsRunning();
   }
-  int mouse_x_when_hit_top() {
-    return controller()->mouse_x_when_hit_top_in_screen_;
+  int mouse_x_when_hit_top() const {
+    return controller_->mouse_x_when_hit_top_in_screen_;
   }
 
   // AshTestBase:
   void SetUp() override {
     AshTestBase::SetUp();
 
-    test_api_animation_disabler_ = std::make_unique<
-        ImmersiveFullscreenControllerTestApi::GlobalAnimationDisabler>();
-
     widget_ = new views::Widget();
     views::Widget::InitParams params;
     params.delegate = new TestWidgetDelegate();
@@ -185,9 +173,20 @@
     content_view_->SetBounds(0, 0, window_size.width(), window_size.height());
     widget_->GetContentsView()->AddChildView(content_view_);
 
-    test_api_ =
-        std::make_unique<ImmersiveFullscreenControllerTestApi>(controller());
-    test_api_->SetupForTest();
+    top_container_ = new views::View();
+    top_container_->SetBounds(0, 0, window_size.width(), 100);
+    top_container_->SetFocusBehavior(views::View::FocusBehavior::ALWAYS);
+    widget_->GetContentsView()->AddChildView(top_container_);
+
+    delegate_ = std::make_unique<MockImmersiveFullscreenControllerDelegate>(
+        top_container_);
+    controller_ = std::make_unique<ImmersiveFullscreenController>(
+        Shell::Get()->immersive_context());
+    controller_->Init(delegate_.get(), widget_, top_container_);
+    ImmersiveFullscreenControllerTestApi(controller_.get()).SetupForTest();
+
+    // The mouse is moved so that it is not over |top_container_| by
+    // AshTestBase.
   }
 
   // Enables / disables immersive fullscreen.
@@ -212,14 +211,14 @@
   // SetHovered(true) moves the mouse over the |top_container_| but does not
   // move it to the top of the screen so will not initiate a reveal.
   void SetHovered(bool is_mouse_hovered) {
-    MoveMouse(0, is_mouse_hovered ? 10 : top_container()->height() + 100);
+    MoveMouse(0, is_mouse_hovered ? 10 : top_container_->height() + 100);
   }
 
   // Move the mouse to the given coordinates. The coordinates should be in
   // |top_container_| coordinates.
   void MoveMouse(int x, int y) {
     gfx::Point screen_position(x, y);
-    views::View::ConvertPointToScreen(top_container(), &screen_position);
+    views::View::ConvertPointToScreen(top_container_, &screen_position);
     GetEventGenerator()->MoveMouseTo(screen_position.x(), screen_position.y());
 
     // If the top edge timer started running as a result of the mouse move, run
@@ -244,9 +243,8 @@
  private:
   // Attempt to change the revealed state to |revealed| via |modality|.
   void AttemptRevealStateChange(bool revealed, Modality modality) {
-    // Compute the event position in |top_container()| coordinates.
-    gfx::Point event_position(0,
-                              revealed ? 0 : top_container()->height() + 100);
+    // Compute the event position in |top_container_| coordinates.
+    gfx::Point event_position(0, revealed ? 0 : top_container_->height() + 100);
     switch (modality) {
       case MODALITY_MOUSE: {
         MoveMouse(event_position.x(), event_position.y());
@@ -254,7 +252,7 @@
       }
       case MODALITY_GESTURE_TAP: {
         gfx::Point screen_position = event_position;
-        views::View::ConvertPointToScreen(top_container(), &screen_position);
+        views::View::ConvertPointToScreen(top_container_, &screen_position);
         ui::test::EventGenerator* event_generator = GetEventGenerator();
         event_generator->MoveTouch(event_position);
         event_generator->PressTouch();
@@ -262,11 +260,11 @@
         break;
       }
       case MODALITY_GESTURE_SCROLL: {
-        gfx::Point start(0, revealed ? 0 : 2);
+        gfx::Point start(0, revealed ? 0 : top_container_->height() - 2);
         gfx::Vector2d scroll_delta(0, 40);
         gfx::Point end = revealed ? start + scroll_delta : start - scroll_delta;
-        views::View::ConvertPointToScreen(top_container(), &start);
-        views::View::ConvertPointToScreen(top_container(), &end);
+        views::View::ConvertPointToScreen(top_container_, &start);
+        views::View::ConvertPointToScreen(top_container_, &end);
         ui::test::EventGenerator* event_generator = GetEventGenerator();
         event_generator->GestureScrollSequence(
             start, end, base::TimeDelta::FromMilliseconds(30), 1);
@@ -275,12 +273,11 @@
     }
   }
 
-  std::unique_ptr<ImmersiveFullscreenControllerTestApi::GlobalAnimationDisabler>
-      test_api_animation_disabler_;
-  views::Widget* widget_ = nullptr;  // Owned by the native widget.
-  views::NativeViewHost* content_view_ =
-      nullptr;  // Owned by |widget_|'s root-view.
-  std::unique_ptr<ImmersiveFullscreenControllerTestApi> test_api_;
+  std::unique_ptr<ImmersiveFullscreenController> controller_;
+  std::unique_ptr<MockImmersiveFullscreenControllerDelegate> delegate_;
+  views::Widget* widget_;                // Owned by the native widget.
+  views::View* top_container_;           // Owned by |widget_|'s root-view.
+  views::NativeViewHost* content_view_;  // Owned by |widget_|'s root-view.
 
   base::test::ScopedFeatureList scoped_feature_list_;
 
@@ -290,38 +287,34 @@
 // Test the initial state and that the delegate gets notified of the
 // top-of-window views getting hidden and revealed.
 TEST_F(ImmersiveFullscreenControllerTest, Delegate) {
-  SetWindowShowState(ui::SHOW_STATE_MAXIMIZED);
-
   // Initial state.
   EXPECT_FALSE(controller()->IsEnabled());
   EXPECT_FALSE(controller()->IsRevealed());
-  EXPECT_FALSE(immersive_delegate()->in_immersive_mode());
+  EXPECT_FALSE(delegate()->is_enabled());
 
   // Enabling initially hides the top views.
   SetEnabled(true);
   EXPECT_TRUE(controller()->IsEnabled());
   EXPECT_FALSE(controller()->IsRevealed());
-  EXPECT_TRUE(immersive_delegate()->in_immersive_mode());
-  EXPECT_FALSE(immersive_delegate()->is_revealed());
+  EXPECT_TRUE(delegate()->is_enabled());
+  EXPECT_EQ(0, delegate()->visible_fraction());
 
   // Revealing shows the top views.
   AttemptReveal(MODALITY_MOUSE);
   EXPECT_TRUE(controller()->IsEnabled());
   EXPECT_TRUE(controller()->IsRevealed());
-  EXPECT_TRUE(immersive_delegate()->in_immersive_mode());
-  EXPECT_TRUE(immersive_delegate()->is_revealed());
+  EXPECT_TRUE(delegate()->is_enabled());
+  EXPECT_EQ(1, delegate()->visible_fraction());
 
   // Disabling ends the immersive reveal.
   SetEnabled(false);
   EXPECT_FALSE(controller()->IsEnabled());
   EXPECT_FALSE(controller()->IsRevealed());
-  EXPECT_FALSE(immersive_delegate()->in_immersive_mode());
+  EXPECT_FALSE(delegate()->is_enabled());
 }
 
 // GetRevealedLock() specific tests.
 TEST_F(ImmersiveFullscreenControllerTest, RevealedLock) {
-  SetWindowShowState(ui::SHOW_STATE_MAXIMIZED);
-
   std::unique_ptr<ImmersiveRevealedLock> lock1;
   std::unique_ptr<ImmersiveRevealedLock> lock2;
 
@@ -361,10 +354,6 @@
       ImmersiveFullscreenController::ANIMATE_REVEAL_NO));
   EXPECT_TRUE(controller()->IsRevealed());
 
-  // Move the mouse below the top container bounds so the hover doesn't make the
-  // reveal persist.
-  MoveMouse(0, top_container()->GetBoundsInScreen().bottom() + 10);
-
   // 3) Test that the top-of-window views are only hidden when all of the locks
   // are released.
   lock2.reset(controller()->GetRevealedLock(
@@ -701,17 +690,18 @@
 // Tests the top-of-window views for maximized/full-screened/snapped windows in
 // tablet mode.
 TEST_F(ImmersiveFullscreenControllerTest, WindowsInTabletMode) {
+  SetWindowShowState(ui::SHOW_STATE_MAXIMIZED);
   EnableTabletMode(true);
   SetEnabled(true);
   EXPECT_TRUE(controller()->IsEnabled());
   EXPECT_FALSE(controller()->IsRevealed());
 
   // Top-of-window views will not be revealed through gesture scroll for
-  // fullscreen window in tablet mode. (Instead, the window is dragged.)
+  // maximized window in tablet mode.
   AttemptReveal(MODALITY_GESTURE_SCROLL);
   EXPECT_FALSE(controller()->IsRevealed());
 
-  // Top-of-window views will be revealed for fullscreen windows not in tablet
+  // Top-of-window views will be revealed for maximized window not in tablet
   // mode.
   EnableTabletMode(false);
   AttemptReveal(MODALITY_GESTURE_SCROLL);
@@ -836,7 +826,6 @@
 // Check that the window state gets properly marked for immersive fullscreen.
 TEST_F(ImmersiveFullscreenControllerTest, WindowStateImmersiveFullscreen) {
   ash::wm::WindowState* window_state = ash::wm::GetWindowState(window());
-  SetWindowShowState(ui::SHOW_STATE_NORMAL);
 
   EXPECT_FALSE(window_state->IsInImmersiveFullscreen());
   SetEnabled(true);
@@ -880,18 +869,17 @@
   EXPECT_FALSE(controller()->IsRevealed());
 
   // 2) Test that focusing |unrelated_view| hides the top-of-window views.
-  AttemptReveal(MODALITY_MOUSE);
+  // Note: In this test we can cheat and trigger a reveal via focus because
+  // the top container does not hide when the top-of-window views are not
+  // revealed.
   child_view->RequestFocus();
-  SetHovered(false);
   EXPECT_TRUE(controller()->IsRevealed());
   unrelated_view->RequestFocus();
   EXPECT_FALSE(controller()->IsRevealed());
 
   // 3) Test that a loss of focus of |child_view| to |unrelated_view|
   // while immersive mode is disabled is properly registered.
-  AttemptReveal(MODALITY_MOUSE);
   child_view->RequestFocus();
-  SetHovered(false);
   EXPECT_TRUE(controller()->IsRevealed());
   SetEnabled(false);
   EXPECT_FALSE(controller()->IsRevealed());
@@ -901,9 +889,7 @@
 
   // Repeat test but with a revealed lock acquired when immersive mode is
   // disabled because the code path is different.
-  AttemptReveal(MODALITY_MOUSE);
   child_view->RequestFocus();
-  SetHovered(false);
   EXPECT_TRUE(controller()->IsRevealed());
   SetEnabled(false);
   std::unique_ptr<ImmersiveRevealedLock> lock(controller()->GetRevealedLock(
@@ -1021,14 +1007,14 @@
 
   views::BubbleDialogDelegateView* bubble_delegate4(
       new TestBubbleDialogDelegate(child_view));
-  bubble_delegate4->SetCanActivate(false);
+  bubble_delegate4->set_can_activate(false);
   views::Widget* bubble_widget4(
       views::BubbleDialogDelegateView::CreateBubble(bubble_delegate4));
   bubble_widget4->Show();
 
   views::BubbleDialogDelegateView* bubble_delegate5(
       new TestBubbleDialogDelegate(child_view));
-  bubble_delegate5->SetCanActivate(false);
+  bubble_delegate5->set_can_activate(false);
   views::Widget* bubble_widget5(
       views::BubbleDialogDelegateView::CreateBubble(bubble_delegate5));
   bubble_widget5->Show();
--- a/ash/wm/lock_layout_manager_unittest.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/lock_layout_manager_unittest.cc	2019-05-17 18:53:08.360000000 +0300
@@ -9,7 +9,6 @@
 #include "ash/shell.h"
 #include "ash/test/ash_test_base.h"
 #include "ash/wm/window_state.h"
-#include "base/bind.h"
 #include "base/command_line.h"
 #include "services/ws/public/mojom/window_tree_constants.mojom.h"
 #include "ui/aura/client/aura_constants.h"
--- a/ash/wm/lock_state_controller_unittest.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/lock_state_controller_unittest.cc	2019-05-17 18:53:08.360000000 +0300
@@ -21,7 +21,6 @@
 #include "ash/wm/lock_state_controller_test_api.h"
 #include "ash/wm/session_state_animator.h"
 #include "ash/wm/test_session_state_animator.h"
-#include "base/bind.h"
 #include "base/command_line.h"
 #include "base/run_loop.h"
 #include "base/time/time.h"
@@ -108,7 +107,7 @@
     power_manager::BacklightBrightnessChange change;
     change.set_percent(percent);
     change.set_cause(cause);
-    power_manager_client()->SendScreenBrightnessChanged(change);
+    power_manager_client_->SendScreenBrightnessChanged(change);
   }
 
   void ExpectPreLockAnimationStarted() {
--- a/ash/wm/mru_window_tracker.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/mru_window_tracker.cc	2019-05-17 18:53:08.364000000 +0300
@@ -144,14 +144,6 @@
     SetActiveWindow(wm::GetActiveWindow());
 }
 
-void MruWindowTracker::AddObserver(Observer* observer) {
-  observers_.AddObserver(observer);
-}
-
-void MruWindowTracker::RemoveObserver(Observer* observer) {
-  observers_.RemoveObserver(observer);
-}
-
 //////////////////////////////////////////////////////////////////////////////
 // MruWindowTracker, private:
 
@@ -182,9 +174,6 @@
   // else we may end up with a deleted window in |mru_windows_|.
   base::Erase(mru_windows_, window);
   window->RemoveObserver(this);
-
-  for (auto& observer : observers_)
-    observer.OnWindowUntracked(window);
 }
 
 }  // namespace ash
--- a/ash/wm/mru_window_tracker.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/mru_window_tracker.h	2019-05-17 18:53:08.364000000 +0300
@@ -9,7 +9,6 @@
 
 #include "ash/ash_export.h"
 #include "base/macros.h"
-#include "base/observer_list.h"
 #include "ui/aura/window_observer.h"
 #include "ui/wm/public/activation_change_observer.h"
 
@@ -22,12 +21,6 @@
  public:
   using WindowList = std::vector<aura::Window*>;
 
-  class Observer : public base::CheckedObserver {
-   public:
-    // Invoked when a tracked window is destroyed,
-    virtual void OnWindowUntracked(aura::Window* untracked_window) {}
-  };
-
   MruWindowTracker();
   ~MruWindowTracker() override;
 
@@ -51,10 +44,6 @@
   // windows to the front of the MRU window list.
   void SetIgnoreActivations(bool ignore);
 
-  // Add/Remove observers.
-  void AddObserver(Observer* observer);
-  void RemoveObserver(Observer* observer);
-
  private:
   // Updates the mru_windows_ list to insert/move |active_window| at/to the
   // front.
@@ -72,8 +61,6 @@
   // through, sorted such that the most recently used window comes last.
   std::vector<aura::Window*> mru_windows_;
 
-  base::ObserverList<Observer, true> observers_;
-
   bool ignore_window_activations_ = false;
 
   DISALLOW_COPY_AND_ASSIGN(MruWindowTracker);
--- a/ash/wm/non_client_frame_controller.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/non_client_frame_controller.cc	2019-05-17 18:53:08.364000000 +0300
@@ -25,8 +25,8 @@
 #include "base/strings/utf_string_conversions.h"
 #include "services/ws/public/cpp/property_type_converters.h"
 #include "services/ws/public/mojom/window_manager.mojom.h"
-#include "services/ws/top_level_proxy_window.h"
 #include "services/ws/window_properties.h"
+#include "services/ws/window_service.h"
 #include "services/ws/window_utils.h"
 #include "ui/accessibility/ax_node_data.h"
 #include "ui/accessibility/ax_tree_id.h"
@@ -44,14 +44,14 @@
 #include "ui/views/window/caption_button_layout_constants.h"
 #include "ui/wm/core/coordinate_conversion.h"
 
-DEFINE_UI_CLASS_PROPERTY_TYPE(ash::NonClientFrameController*)
+DEFINE_UI_CLASS_PROPERTY_TYPE(ash::NonClientFrameController*);
 
 namespace ash {
 namespace {
 
 DEFINE_UI_CLASS_PROPERTY_KEY(NonClientFrameController*,
                              kNonClientFrameControllerKey,
-                             nullptr)
+                             nullptr);
 
 bool DoesClientProvideFrame(
     std::map<std::string, std::vector<uint8_t>>* properties) {
@@ -201,9 +201,9 @@
  public:
   ClientViewMus(views::Widget* widget,
                 views::View* contents_view,
-                ws::TopLevelProxyWindow* top_level_proxy_window)
+                NonClientFrameController* frame_controller)
       : views::ClientView(widget, contents_view),
-        top_level_proxy_window_(top_level_proxy_window) {}
+        frame_controller_(frame_controller) {}
   ~ClientViewMus() override = default;
 
   // views::ClientView:
@@ -213,7 +213,8 @@
     // pass the request to the remote client and return false (to cancel the
     // close). If the remote client wants the window to close, it will close it
     // in a way that does not reenter this code path.
-    top_level_proxy_window_->RequestClose();
+    Shell::Get()->window_service_owner()->window_service()->RequestClose(
+        frame_controller_->window());
     return false;
   }
 
@@ -221,7 +222,7 @@
   const char* GetClassName() const override { return "ClientViewMus"; }
 
  private:
-  ws::TopLevelProxyWindow* top_level_proxy_window_;
+  NonClientFrameController* frame_controller_;
 
   DISALLOW_COPY_AND_ASSIGN(ClientViewMus);
 };
@@ -229,19 +230,22 @@
 }  // namespace
 
 NonClientFrameController::NonClientFrameController(
-    ws::TopLevelProxyWindow* top_level_proxy_window,
     aura::Window* parent,
     aura::Window* context,
     const gfx::Rect& bounds,
+    ws::mojom::WindowType window_type,
     aura::PropertyConverter* property_converter,
     std::map<std::string, std::vector<uint8_t>>* properties)
-    : widget_(new views::Widget),
-      top_level_proxy_window_(top_level_proxy_window) {
+    : widget_(new views::Widget), window_(nullptr) {
   // To simplify things this code creates a Widget. While a Widget is created
   // we need to ensure we don't inadvertently change random properties of the
   // underlying ui::Window. For example, showing the Widget shouldn't change
   // the bounds of the ui::Window in anyway.
-  views::Widget::InitParams params;
+  //
+  // Assertions around InitParams::Type matching ws::mojom::WindowType exist in
+  // MusClient.
+  views::Widget::InitParams params(
+      static_cast<views::Widget::InitParams::Type>(window_type));
   DCHECK((parent && !context) || (!parent && context));
   params.parent = parent;
   params.context = context;
@@ -250,7 +254,7 @@
   params.delegate = this;
   params.bounds = bounds;
   params.opacity = views::Widget::InitParams::OPAQUE_WINDOW;
-  params.layer_type = ui::LAYER_NOT_DRAWN;
+  params.layer_type = ui::LAYER_SOLID_COLOR;
   WmNativeWidgetAura* native_widget =
       new WmNativeWidgetAura(widget_, DoesClientProvideFrame(properties));
   window_ = native_widget->GetNativeView();
@@ -258,7 +262,7 @@
   window_->SetProperty(kWidgetCreationTypeKey, WidgetCreationType::FOR_CLIENT);
   window_->AddObserver(this);
   params.native_widget = native_widget;
-  aura::SetWindowType(window_, ws::mojom::WindowType::WINDOW);
+  aura::SetWindowType(window_, window_type);
   for (auto& property_pair : *properties) {
     property_converter->SetPropertyFromTransportValue(
         window_, property_pair.first, &property_pair.second);
@@ -270,7 +274,14 @@
   widget_->Init(params);
   did_init_native_widget_ = true;
 
-  wm::MakeGestureDraggableInImmersiveMode(window_);
+  // Only the caption draws any content. So the caption has its own layer (see
+  // above in WmNativeWidgetAura::CreateNonClientFrameView()). The rest of the
+  // region needs to take part in occlusion in the compositor, but not generate
+  // any content to draw. So the layer is marked as opaque and to draw
+  // solid-color (but the color is transparent, so nothing is actually drawn).
+  ui::Layer* layer = widget_->GetNativeWindow()->layer();
+  layer->SetColor(SK_ColorTRANSPARENT);
+  layer->SetFillsBoundsOpaquely(true);
 }
 
 // static
@@ -356,15 +367,7 @@
     views::Widget* widget) {
   DCHECK(!contents_view_);
   contents_view_ = new ContentsViewMus();  // Owned by views hierarchy.
-  return new ClientViewMus(widget, contents_view_, top_level_proxy_window_);
-}
-
-void NonClientFrameController::OnWindowBeginUserBoundsChange() {
-  top_level_proxy_window_->OnWindowResizeLoopStarted();
-}
-
-void NonClientFrameController::OnWindowEndUserBoundsChange() {
-  top_level_proxy_window_->OnWindowResizeLoopEnded();
+  return new ClientViewMus(widget, contents_view_, this);
 }
 
 void NonClientFrameController::OnWindowPropertyChanged(aura::Window* window,
--- a/ash/wm/non_client_frame_controller.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/non_client_frame_controller.h	2019-05-17 18:53:08.364000000 +0300
@@ -29,7 +29,9 @@
 }
 
 namespace ws {
-class TopLevelProxyWindow;
+namespace mojom {
+enum class WindowType;
+}
 }  // namespace ws
 
 namespace ash {
@@ -47,10 +49,10 @@
   // null for now. |bounds| is screen coordinates when |parent| is null,
   // otherwise local coordinates, see views::Widget::InitParams::bounds.
   NonClientFrameController(
-      ws::TopLevelProxyWindow* top_level_proxy_window,
       aura::Window* parent,
       aura::Window* context,
       const gfx::Rect& bounds,
+      ws::mojom::WindowType window_type,
       aura::PropertyConverter* property_converter,
       std::map<std::string, std::vector<uint8_t>>* properties);
 
@@ -72,10 +74,6 @@
   // value provided by the associated window's aura::WindowDelegate::GetCursor.
   void StoreCursor(const ui::Cursor& cursor);
 
-  ws::TopLevelProxyWindow* top_level_proxy_window() {
-    return top_level_proxy_window_;
-  }
-
   // views::WidgetDelegate:
   base::string16 GetWindowTitle() const override;
   bool CanResize() const override;
@@ -88,8 +86,6 @@
   const views::Widget* GetWidget() const override;
   views::View* GetContentsView() override;
   views::ClientView* CreateClientView(views::Widget* widget) override;
-  void OnWindowBeginUserBoundsChange() override;
-  void OnWindowEndUserBoundsChange() override;
 
   // aura::WindowObserver:
   void OnWindowPropertyChanged(aura::Window* window,
@@ -102,12 +98,10 @@
 
   views::Widget* widget_;
   views::View* contents_view_ = nullptr;
-  // Owned by the window-service.
-  ws::TopLevelProxyWindow* top_level_proxy_window_;
 
   // WARNING: as widget delays destruction there is a portion of time when this
   // is null.
-  aura::Window* window_ = nullptr;
+  aura::Window* window_;
 
   bool did_init_native_widget_ = false;
 
--- a/ash/wm/non_client_frame_controller_unittest.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/non_client_frame_controller_unittest.cc	2019-05-17 18:53:08.364000000 +0300
@@ -21,13 +21,10 @@
 #include "ui/accessibility/platform/aura_window_properties.h"
 #include "ui/aura/client/aura_constants.h"
 #include "ui/aura/env.h"
-#include "ui/aura/test/mus/change_completion_waiter.h"
 #include "ui/aura/window.h"
 #include "ui/aura/window_delegate.h"
 #include "ui/base/hit_test.h"
 #include "ui/base/ui_base_features.h"
-#include "ui/events/test/event_generator.h"
-#include "ui/views/mus/mus_client.h"
 #include "ui/views/widget/widget.h"
 
 namespace ash {
@@ -134,66 +131,4 @@
                           gfx::Point(window->bounds().width() - 10, 10)));
 }
 
-using NonClientFrameControllerSingleProcessMashTest = SingleProcessMashTestBase;
-
-// Used to track whether in a window resize loop.
-class ResizeLoopWidgetDelegate : public views::WidgetDelegateView {
- public:
-  ResizeLoopWidgetDelegate() = default;
-  ~ResizeLoopWidgetDelegate() override = default;
-
-  bool in_resize_loop() const { return in_resize_loop_; }
-
-  // views::WidgetDelegateView:
-  void OnWindowBeginUserBoundsChange() override {
-    EXPECT_FALSE(in_resize_loop_);
-    in_resize_loop_ = true;
-  }
-  void OnWindowEndUserBoundsChange() override {
-    EXPECT_TRUE(in_resize_loop_);
-    in_resize_loop_ = false;
-  }
-  int32_t GetResizeBehavior() const override {
-    return ws::mojom::kResizeBehaviorCanResize;
-  }
-
- private:
-  bool in_resize_loop_ = false;
-
-  DISALLOW_COPY_AND_ASSIGN(ResizeLoopWidgetDelegate);
-};
-
-TEST_F(NonClientFrameControllerSingleProcessMashTest, ResizeLoop) {
-  // Owned by |widget|.
-  ResizeLoopWidgetDelegate* widget_delegate = new ResizeLoopWidgetDelegate;
-  // Create a widget. This widget is backed by mus.
-  views::Widget widget;
-  views::Widget::InitParams params;
-  params.ownership = views::Widget::InitParams::WIDGET_OWNS_NATIVE_WIDGET;
-  params.bounds = gfx::Rect(0, 0, 200, 200);
-  params.delegate = widget_delegate;
-  params.native_widget =
-      views::MusClient::Get()->CreateNativeWidget(params, &widget);
-  widget.Init(params);
-  widget.Show();
-
-  // Should not initially be in a resize loop.
-  EXPECT_FALSE(widget_delegate->in_resize_loop());
-
-  // Flush all messages from the WindowTreeClient to ensure ash processes the
-  // widget creation.
-  aura::test::WaitForAllChangesToComplete();
-
-  // The resize loop is entered once a possible resize is detected.
-  GetEventGenerator()->MoveMouseTo(gfx::Point(5, 199));
-  GetEventGenerator()->PressLeftButton();
-  aura::test::WaitForAllChangesToComplete();
-  EXPECT_TRUE(widget_delegate->in_resize_loop());
-
-  // Releasing the button ends the loop.
-  GetEventGenerator()->ReleaseLeftButton();
-  aura::test::WaitForAllChangesToComplete();
-  EXPECT_FALSE(widget_delegate->in_resize_loop());
-}
-
 }  // namespace ash
--- a/ash/wm/overview/caption_container_view.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/overview/caption_container_view.cc	2019-05-17 18:53:08.364000000 +0300
@@ -10,13 +10,13 @@
 #include "ash/wm/overview/overview_item.h"
 #include "ash/wm/overview/overview_utils.h"
 #include "ash/wm/overview/rounded_rect_view.h"
-#include "ash/wm/overview/scoped_overview_animation_settings.h"
 #include "ash/wm/splitview/split_view_constants.h"
 #include "ash/wm/splitview/split_view_utils.h"
 #include "ui/aura/client/aura_constants.h"
 #include "ui/aura/window.h"
 #include "ui/base/l10n/l10n_util.h"
 #include "ui/compositor/layer.h"
+#include "ui/compositor/scoped_layer_animation_settings.h"
 #include "ui/gfx/image/image_skia_operations.h"
 #include "ui/gfx/paint_vector_icon.h"
 #include "ui/strings/grit/ui_strings.h"
@@ -60,9 +60,10 @@
 // The font delta of the overview window title.
 constexpr int kLabelFontDelta = 2;
 
-// Values of the backdrop.
-constexpr int kBackdropRoundingDp = 4;
-constexpr SkColor kBackdropColor = SkColorSetA(SK_ColorWHITE, 0x24);
+// Duration of the header and close button fade in/out when a drag is
+// started/finished on a window selector item;
+constexpr base::TimeDelta kDragAnimationDuration =
+    base::TimeDelta::FromMilliseconds(167);
 
 void AddChildWithLayer(views::View* parent, views::View* child) {
   child->SetPaintToLayer();
@@ -153,7 +154,7 @@
     if (listener()) {
       gfx::Point location(event.location());
       views::View::ConvertPointToScreen(this, &location);
-      listener()->HandlePressEvent(gfx::PointF(location));
+      listener()->HandlePressEvent(location);
       return true;
     }
     return views::Button::OnMousePressed(event);
@@ -163,7 +164,7 @@
     if (listener()) {
       gfx::Point location(event.location());
       views::View::ConvertPointToScreen(this, &location);
-      listener()->HandleDragEvent(gfx::PointF(location));
+      listener()->HandleDragEvent(location);
       return true;
     }
     return views::Button::OnMouseDragged(event);
@@ -173,7 +174,7 @@
     if (listener()) {
       gfx::Point location(event.location());
       views::View::ConvertPointToScreen(this, &location);
-      listener()->HandleReleaseEvent(gfx::PointF(location));
+      listener()->HandleReleaseEvent(location);
       return;
     }
     views::Button::OnMouseReleased(event);
@@ -186,8 +187,8 @@
     }
 
     if (listener()) {
-      const gfx::PointF location =
-          event->details().bounding_box_f().CenterPoint();
+      gfx::Point location(event->location());
+      views::View::ConvertPointToScreen(this, &location);
       switch (event->type()) {
         case ui::ET_GESTURE_TAP_DOWN:
           listener()->HandlePressEvent(location);
@@ -243,11 +244,7 @@
           kHorizontalLabelPaddingDp));
   AddChildWithLayer(listener_button_, header_view_);
 
-  // Prefer kAppIconSmallKey (set by the client in Mash), then kAppIconKey and
-  // kWindowIconKey (set for client windows in classic Ash but not Mash).
-  gfx::ImageSkia* icon = window->GetProperty(aura::client::kAppIconSmallKey);
-  if (!icon || icon->size().IsEmpty())
-    icon = window->GetProperty(aura::client::kAppIconKey);
+  gfx::ImageSkia* icon = window->GetProperty(aura::client::kAppIconKey);
   if (!icon || icon->size().IsEmpty())
     icon = window->GetProperty(aura::client::kWindowIconKey);
   if (icon && !icon->size().IsEmpty()) {
@@ -313,27 +310,14 @@
   AnimateLayerOpacity(header_view_->layer(), visible);
 }
 
-void CaptionContainerView::SetBackdropVisibility(bool visible) {
-  if (!backdrop_view_ && !visible)
-    return;
-
-  if (!backdrop_view_) {
-    backdrop_view_ = new RoundedRectView(kBackdropRoundingDp, kBackdropColor);
-    backdrop_view_->set_can_process_events_within_subtree(false);
-    AddChildWithLayer(this, backdrop_view_);
-    Layout();
-  }
-  backdrop_view_->SetVisible(visible);
-}
-
 void CaptionContainerView::SetCannotSnapLabelVisibility(bool visible) {
   if (!cannot_snap_container_ && !visible)
     return;
 
   DoSplitviewOpacityAnimation(GetCannotSnapContainer()->layer(),
                               visible
-                                  ? SPLITVIEW_ANIMATION_OVERVIEW_ITEM_FADE_IN
-                                  : SPLITVIEW_ANIMATION_OVERVIEW_ITEM_FADE_OUT);
+                                  ? SPLITVIEW_ANIMATION_SELECTOR_ITEM_FADE_IN
+                                  : SPLITVIEW_ANIMATION_SELECTOR_ITEM_FADE_OUT);
 }
 
 void CaptionContainerView::ResetListener() {
@@ -360,11 +344,8 @@
   listener_button_->SetBoundsRect(bounds);
 
   const int visible_height = close_button_->GetPreferredSize().height();
-  if (backdrop_view_) {
-    gfx::Rect backdrop_bounds = bounds;
-    backdrop_bounds.Inset(0, visible_height, 0, 0);
-    backdrop_view_->SetBoundsRect(backdrop_bounds);
-  }
+  backdrop_bounds_ = bounds;
+  backdrop_bounds_.Inset(0, visible_height, 0, 0);
 
   if (cannot_snap_container_) {
     gfx::Size label_size = cannot_snap_label_->CalculatePreferredSize();
@@ -401,11 +382,20 @@
     return;
 
   layer->SetOpacity(1.f - target_opacity);
-  ScopedOverviewAnimationSettings settings(
-      visible ? OVERVIEW_ANIMATION_OVERVIEW_TITLE_FADE_IN
-              : OVERVIEW_ANIMATION_OVERVIEW_TITLE_FADE_OUT,
-      layer->GetAnimator());
+  {
+    ui::LayerAnimator* animator = layer->GetAnimator();
+    ui::ScopedLayerAnimationSettings settings(animator);
+    settings.SetPreemptionStrategy(
+        ui::LayerAnimator::REPLACE_QUEUED_ANIMATIONS);
+    if (visible) {
+      animator->SchedulePauseForProperties(kDragAnimationDuration,
+                                           ui::LayerAnimationElement::OPACITY);
+    }
+    settings.SetTransitionDuration(kDragAnimationDuration);
+    settings.SetTweenType(visible ? gfx::Tween::LINEAR_OUT_SLOW_IN
+                                  : gfx::Tween::FAST_OUT_LINEAR_IN);
   layer->SetOpacity(target_opacity);
+  }
 }
 
 }  // namespace ash
--- a/ash/wm/overview/caption_container_view.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/overview/caption_container_view.h	2019-05-17 18:53:08.364000000 +0300
@@ -32,7 +32,6 @@
 // CaptionContainerView covers the overview window and listens for events. It
 // also draws a header for overview mode which contains a icon, title and close
 // button.
-// TODO(sammiequon): Rename this to something which describes it better.
 class ASH_EXPORT CaptionContainerView : public views::View {
  public:
   // The visibility of the header. It may be fully visible or invisible, or
@@ -52,9 +51,6 @@
 
   void SetHeaderVisibility(HeaderVisibility visibility);
 
-  // Sets the visiblity of |backdrop_view_|. Creates it if it is null.
-  void SetBackdropVisibility(bool visible);
-
   // Animates |cannot_snap_container_| to its visibility state.
   void SetCannotSnapLabelVisibility(bool visible);
 
@@ -69,7 +65,7 @@
   views::View* header_view() { return header_view_; }
   views::Label* title_label() { return title_label_; }
   views::Label* cannot_snap_label() { return cannot_snap_label_; }
-  RoundedRectView* backdrop_view() { return backdrop_view_; }
+  gfx::Rect backdrop_bounds() const { return backdrop_bounds_; }
 
  protected:
   // views::View:
@@ -102,9 +98,7 @@
   // |cannot_snap_label_| and to give the label rounded corners.
   RoundedRectView* cannot_snap_container_ = nullptr;
 
-  // A view that covers the area except the header. It is null when the window
-  // associated is not pillar or letter boxed.
-  RoundedRectView* backdrop_view_ = nullptr;
+  gfx::Rect backdrop_bounds_;
 
   DISALLOW_COPY_AND_ASSIGN(CaptionContainerView);
 };
--- a/ash/wm/overview/overview_animation_type.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/overview/overview_animation_type.h	2019-05-17 18:53:08.364000000 +0300
@@ -18,9 +18,9 @@
   OVERVIEW_ANIMATION_EXIT_OVERVIEW_MODE_FADE_OUT,
   // Used to position windows when entering/exiting overview mode and when a
   // window is closed while overview mode is active.
-  OVERVIEW_ANIMATION_LAYOUT_OVERVIEW_ITEMS_ON_ENTER,
-  OVERVIEW_ANIMATION_LAYOUT_OVERVIEW_ITEMS_IN_OVERVIEW,
-  OVERVIEW_ANIMATION_LAYOUT_OVERVIEW_ITEMS_ON_EXIT,
+  OVERVIEW_ANIMATION_LAY_OUT_SELECTOR_ITEMS_ON_ENTER,
+  OVERVIEW_ANIMATION_LAY_OUT_SELECTOR_ITEMS_IN_OVERVIEW,
+  OVERVIEW_ANIMATION_LAY_OUT_SELECTOR_ITEMS_ON_EXIT,
   // Used to restore windows to their original position when exiting overview
   // mode.
   OVERVIEW_ANIMATION_RESTORE_WINDOW,
@@ -28,26 +28,14 @@
   OVERVIEW_ANIMATION_RESTORE_WINDOW_ZERO,
   // Used to animate scaling down of a window that is about to get closed while
   // overview mode is active.
-  OVERVIEW_ANIMATION_CLOSING_OVERVIEW_ITEM,
+  OVERVIEW_ANIMATION_CLOSING_SELECTOR_ITEM,
   // Used to animate hiding of a window that is closed while overview mode is
   // active.
-  OVERVIEW_ANIMATION_CLOSE_OVERVIEW_ITEM,
+  OVERVIEW_ANIMATION_CLOSE_SELECTOR_ITEM,
   // Used to animate windows upon entering or exiting overview mode to or from
   // the home launcher.
   OVERVIEW_ANIMATION_ENTER_FROM_HOME_LAUNCHER,
   OVERVIEW_ANIMATION_EXIT_TO_HOME_LAUNCHER,
-  // Used to fade in the drop target when dragging an application to enter
-  // overview mode.
-  OVERVIEW_ANIMATION_DROP_TARGET_FADE_IN,
-  // Used to fade in the shield which covers the work area in and out.
-  OVERVIEW_ANIMATION_SHIELD_FADE,
-  // Used to animate the selection window which is activated by using tab or the
-  // arrow keys.
-  OVERVIEW_ANIMATION_SELECTION_WINDOW_SHADOW,
-  OVERVIEW_ANIMATION_SELECTION_WINDOW,
-  // Used to animate the overview items header visibility.
-  OVERVIEW_ANIMATION_OVERVIEW_TITLE_FADE_IN,
-  OVERVIEW_ANIMATION_OVERVIEW_TITLE_FADE_OUT,
 };
 
 }  // namespace ash
--- a/ash/wm/overview/overview_constants.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/overview/overview_constants.h	2019-05-17 18:53:08.364000000 +0300
@@ -34,10 +34,6 @@
 constexpr float kWallpaperBlurSigma = 10.f;
 constexpr float kWallpaperClearBlurSigma = 0.f;
 
-// Amount of time we wait to unpause the occlusion tracker after a overview item
-// is finished dragging. Waits a bit longer than the overview item animation.
-constexpr int kOcclusionPauseDurationForDragMs = 300;
-
 }  // namespace ash
 
 #endif  // ASH_WM_OVERVIEW_OVERVIEW_CONSTANTS_H_
--- a/ash/wm/overview/overview_controller.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/overview/overview_controller.cc	2019-05-17 18:53:08.364000000 +0300
@@ -5,6 +5,7 @@
 #include "ash/wm/overview/overview_controller.h"
 
 #include <algorithm>
+#include <vector>
 
 #include "ash/app_list/app_list_controller_impl.h"
 #include "ash/public/cpp/window_properties.h"
@@ -27,7 +28,6 @@
 #include "ash/wm/tablet_mode/tablet_mode_controller.h"
 #include "ash/wm/window_state.h"
 #include "ash/wm/window_util.h"
-#include "base/bind.h"
 #include "base/containers/unique_ptr_adapters.h"
 #include "base/metrics/histogram_macros.h"
 #include "base/metrics/user_metrics.h"
@@ -49,12 +49,12 @@
 constexpr int kBlurSlideDurationMs = 250;
 
 // It can take up to two frames until the frame created in the UI thread that
-// triggered animation observer is drawn. Wait 50ms in attempt to let its draw
-// and swap finish.
+// triggered animation observer is drawn. Wait 50ms in attemp to
+// let its draw and swap finish.
 constexpr int kOcclusionPauseDurationForStartMs = 50;
 
-// Wait longer when exiting overview mode in case when a user may re-enter
-// overview mode immediately, contents are ready.
+// Wait longer when exiting overview mode in case when a user
+// may re-enter overview mode immediately, contents are ready.
 constexpr int kOcclusionPauseDurationForEndMs = 500;
 
 bool IsBlurAllowed() {
@@ -320,7 +320,10 @@
     }
 
     // Suspend occlusion tracker until the exit animation is complete.
-    PauseOcclusionTracker();
+    reset_pauser_task_.Cancel();
+    occlusion_tracker_pauser_ =
+        std::make_unique<aura::WindowOcclusionTracker::ScopedPause>(
+            Shell::Get()->aura_env());
 
     overview_session_->set_enter_exit_overview_type(new_type);
     if (type == OverviewSession::EnterExitOverviewType::kWindowsMinimized ||
@@ -355,12 +358,14 @@
     delayed_animations_.clear();
 
     // Suspend occlusion tracker until the enter animation is complete.
-    PauseOcclusionTracker();
+    reset_pauser_task_.Cancel();
+    occlusion_tracker_pauser_ =
+        std::make_unique<aura::WindowOcclusionTracker::ScopedPause>(
+            Shell::Get()->aura_env());
 
     overview_session_ = std::make_unique<OverviewSession>(this);
     overview_session_->set_enter_exit_overview_type(new_type);
-    for (auto& observer : observers_)
-      observer.OnOverviewModeStarting();
+    Shell::Get()->NotifyOverviewModeStarting();
     overview_session_->Init(windows, hide_windows);
     if (IsBlurAllowed())
       overview_blur_controller_->Blur(/*animate_only=*/false);
@@ -375,11 +380,14 @@
   if (IsBlurAllowed())
     overview_blur_controller_->Blur(/*animate_only=*/true);
 
-  for (auto& observer : observers_)
-    observer.OnOverviewModeStartingAnimationComplete(canceled);
+  Shell::Get()->NotifyOverviewModeStartingAnimationComplete(canceled);
   if (overview_session_)
     overview_session_->OnStartingAnimationComplete(canceled);
-  UnpauseOcclusionTracker(kOcclusionPauseDurationForStartMs);
+  reset_pauser_task_.Reset(base::BindOnce(&OverviewController::ResetPauser,
+                                          weak_ptr_factory_.GetWeakPtr()));
+  base::ThreadTaskRunnerHandle::Get()->PostDelayedTask(
+      FROM_HERE, reset_pauser_task_.callback(),
+      base::TimeDelta::FromMilliseconds(kOcclusionPauseDurationForStartMs));
 }
 
 void OverviewController::OnEndingAnimationComplete(bool canceled) {
@@ -389,9 +397,12 @@
   if (IsBlurAllowed() && !canceled)
     overview_blur_controller_->Unblur();
 
-  for (auto& observer : observers_)
-    observer.OnOverviewModeEndingAnimationComplete(canceled);
-  UnpauseOcclusionTracker(occlusion_pause_duration_for_end_ms_);
+  Shell::Get()->NotifyOverviewModeEndingAnimationComplete(canceled);
+  reset_pauser_task_.Reset(base::BindOnce(&OverviewController::ResetPauser,
+                                          weak_ptr_factory_.GetWeakPtr()));
+  base::ThreadTaskRunnerHandle::Get()->PostDelayedTask(
+      FROM_HERE, reset_pauser_task_.callback(),
+      base::TimeDelta::FromMilliseconds(occlusion_pause_duration_for_end_ms_));
 }
 
 void OverviewController::ResetPauser() {
@@ -447,8 +458,10 @@
     aura::Window* active_window = wm::GetActiveWindow();
     while (::wm::GetTransientParent(active_window))
       active_window = ::wm::GetTransientParent(active_window);
-    if (!split_view_controller->IsWindowInSplitView(active_window))
+    if (active_window != split_view_controller->left_window() &&
+        active_window != split_view_controller->right_window()) {
       active_window = split_view_controller->GetDefaultSnappedWindow();
+    }
     DCHECK(active_window);
     split_view_controller->EndSplitView();
     if (IsSelecting())
@@ -490,7 +503,7 @@
       item_to_snap = current_grid->GetOverviewItemContaining(active_window);
   } else {
     // Currently in overview mode, with no snapped windows. Retrieve the first
-    // overview item and attempt to snap that window.
+    // window selector item and attempt to snap that window.
     DCHECK(overview_session_);
     OverviewGrid* current_grid = overview_session_->GetGridWithRootWindow(
         wm::GetRootWindowAt(event_location));
@@ -512,40 +525,15 @@
       base::UserMetricsAction("Tablet_LongPressOverviewButtonEnterSplitView"));
 }
 
-bool OverviewController::IsInStartAnimation() {
-  return !start_animations_.empty();
-}
-
-void OverviewController::PauseOcclusionTracker() {
-  if (occlusion_tracker_pauser_)
-    return;
-
-  reset_pauser_task_.Cancel();
-  occlusion_tracker_pauser_ =
-      std::make_unique<aura::WindowOcclusionTracker::ScopedPause>(
-          Shell::Get()->aura_env());
-}
-
-void OverviewController::UnpauseOcclusionTracker(int delay) {
-  reset_pauser_task_.Reset(base::BindOnce(&OverviewController::ResetPauser,
-                                          weak_ptr_factory_.GetWeakPtr()));
-  base::ThreadTaskRunnerHandle::Get()->PostDelayedTask(
-      FROM_HERE, reset_pauser_task_.callback(),
-      base::TimeDelta::FromMilliseconds(delay));
-}
-
-void OverviewController::AddObserver(OverviewObserver* observer) {
-  observers_.AddObserver(observer);
-}
-
-void OverviewController::RemoveObserver(OverviewObserver* observer) {
-  observers_.RemoveObserver(observer);
-}
-
-void OverviewController::DelayedUpdateMaskAndShadow() {
-  base::ThreadTaskRunnerHandle::Get()->PostTask(
-      FROM_HERE, base::BindOnce(&OverviewController::UpdateMaskAndShadow,
-                                weak_ptr_factory_.GetWeakPtr()));
+std::vector<aura::Window*>
+OverviewController::GetWindowsListInOverviewGridsForTesting() {
+  std::vector<aura::Window*> windows;
+  for (const std::unique_ptr<OverviewGrid>& grid :
+       overview_session_->grid_list_for_testing()) {
+    for (const auto& overview_session_item : grid->window_list())
+      windows.push_back(overview_session_item->GetWindow());
+  }
+  return windows;
 }
 
 // TODO(flackr): Make OverviewController observe the activation of
@@ -556,25 +544,26 @@
   if (!IsSelecting())
     return;
 
-  if (!occlusion_tracker_pauser_)
-    PauseOcclusionTracker();
+  if (!occlusion_tracker_pauser_) {
+    reset_pauser_task_.Cancel();
+    occlusion_tracker_pauser_ =
+        std::make_unique<aura::WindowOcclusionTracker::ScopedPause>(
+            Shell::Get()->aura_env());
+  }
 
   if (!start_animations_.empty())
     OnStartingAnimationComplete(/*canceled=*/true);
   start_animations_.clear();
 
-  auto* overview_session = overview_session_.release();
-  // Do not show mask and show during overview shutdown.
-  overview_session->UpdateMaskAndShadow();
+  overview_session_->UpdateMaskAndShadow(/*show=*/false);
 
-  for (auto& observer : observers_)
-    observer.OnOverviewModeEnding(overview_session);
+  auto* overview_session = overview_session_.release();
+  Shell::Get()->NotifyOverviewModeEnding(overview_session);
   overview_session->Shutdown();
   // Don't delete |overview_session_| yet since the stack is still using it.
   base::ThreadTaskRunnerHandle::Get()->DeleteSoon(FROM_HERE, overview_session);
   last_selection_time_ = base::Time::Now();
-  for (auto& observer : observers_)
-    observer.OnOverviewModeEnded();
+  Shell::Get()->NotifyOverviewModeEnded();
   if (delayed_animations_.empty())
     OnEndingAnimationComplete(/*canceled=*/false);
 }
@@ -624,17 +613,6 @@
   return overview_blur_controller_->has_blur_animation();
 }
 
-std::vector<aura::Window*>
-OverviewController::GetWindowsListInOverviewGridsForTest() {
-  std::vector<aura::Window*> windows;
-  for (const std::unique_ptr<OverviewGrid>& grid :
-       overview_session_->grid_list_for_testing()) {
-    for (const auto& overview_session_item : grid->window_list())
-      windows.push_back(overview_session_item->GetWindow());
-  }
-  return windows;
-}
-
 void OverviewController::AddStartAnimationObserver(
     std::unique_ptr<DelayedAnimationObserver> animation_observer) {
   animation_observer->SetOwner(this);
@@ -650,11 +628,6 @@
     OnStartingAnimationComplete(/*canceled=*/false);
 }
 
-void OverviewController::UpdateMaskAndShadow() {
-  if (overview_session_)
-    overview_session_->UpdateMaskAndShadow();
-}
-
 // static
 void OverviewController::SetDoNotChangeWallpaperBlurForTests() {
   g_disable_wallpaper_blur_for_tests = true;
--- a/ash/wm/overview/overview_controller.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/overview/overview_controller.h	2019-05-17 18:53:08.364000000 +0300
@@ -10,11 +10,9 @@
 
 #include "ash/ash_export.h"
 #include "ash/wm/overview/overview_delegate.h"
-#include "ash/wm/overview/overview_observer.h"
 #include "ash/wm/overview/overview_session.h"
 #include "base/macros.h"
 #include "base/memory/weak_ptr.h"
-#include "base/observer_list.h"
 #include "base/time/time.h"
 #include "ui/aura/window_occlusion_tracker.h"
 
@@ -63,19 +61,9 @@
   // if device is not currently in overview mode.
   void OnOverviewButtonTrayLongPressed(const gfx::Point& event_location);
 
-  // Returns true if we're in start-overview animation.
-  bool IsInStartAnimation();
-
-  // Pause or unpause the occlusion tracker. Resets the unpause delay if we were
-  // already in the process of unpausing.
-  void PauseOcclusionTracker();
-  void UnpauseOcclusionTracker(int delay);
-
-  void AddObserver(OverviewObserver* observer);
-  void RemoveObserver(OverviewObserver* observer);
-
-  // Post a task to update the shadow and mask of overview windows.
-  void DelayedUpdateMaskAndShadow();
+  // Gets the windows list that are shown in the overview windows grids if the
+  // overview mode is active for testing.
+  std::vector<aura::Window*> GetWindowsListInOverviewGridsForTesting();
 
   // OverviewDelegate:
   void OnSelectionEnded() override;
@@ -108,10 +96,6 @@
   bool HasBlurForTest() const;
   bool HasBlurAnimationForTest() const;
 
-  // Gets the windows list that are shown in the overview windows grids if the
-  // overview mode is active for testing.
-  std::vector<aura::Window*> GetWindowsListInOverviewGridsForTest();
-
  private:
   class OverviewBlurController;
   friend class OverviewSessionTest;
@@ -128,8 +112,6 @@
   void OnEndingAnimationComplete(bool canceled);
   void ResetPauser();
 
-  void UpdateMaskAndShadow();
-
   // Collection of DelayedAnimationObserver objects that own widgets that may be
   // still animating after overview mode ends. If shell needs to shut down while
   // those animations are in progress, the animations are shut down and the
@@ -153,8 +135,6 @@
 
   base::CancelableOnceClosure reset_pauser_task_;
 
-  base::ObserverList<OverviewObserver> observers_;
-
   base::WeakPtrFactory<OverviewController> weak_ptr_factory_;
 
   DISALLOW_COPY_AND_ASSIGN(OverviewController);
--- a/ash/wm/overview/overview_controller_unittest.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/overview/overview_controller_unittest.cc	2019-05-17 18:53:08.364000000 +0300
@@ -6,9 +6,9 @@
 
 #include "ash/app_list/test/app_list_test_helper.h"
 #include "ash/shell.h"
+#include "ash/shell_observer.h"
 #include "ash/test/ash_test_base.h"
 #include "ash/wallpaper/wallpaper_widget_controller.h"
-#include "ash/wm/overview/overview_observer.h"
 #include "ash/wm/overview/overview_session.h"
 #include "ash/wm/tablet_mode/tablet_mode_controller_test_api.h"
 #include "ash/wm/window_resizer.h"
@@ -34,7 +34,7 @@
   return location;
 }
 
-class TestOverviewObserver : public OverviewObserver {
+class TestShellObserver : public ShellObserver {
  public:
   enum AnimationState {
     UNKNOWN,
@@ -42,15 +42,13 @@
     CANCELED,
   };
 
-  explicit TestOverviewObserver(bool should_monitor_animation_state)
+  explicit TestShellObserver(bool should_monitor_animation_state)
       : should_monitor_animation_state_(should_monitor_animation_state) {
-    Shell::Get()->overview_controller()->AddObserver(this);
-  }
-  ~TestOverviewObserver() override {
-    Shell::Get()->overview_controller()->RemoveObserver(this);
+    Shell::Get()->AddShellObserver(this);
   }
+  ~TestShellObserver() override { Shell::Get()->RemoveShellObserver(this); }
 
-  // OverviewObserver:
+  // ShellObserver:
   void OnOverviewModeStarting() override {
     UpdateLastAnimationWasSlide(
         Shell::Get()->overview_controller()->overview_session());
@@ -123,7 +121,7 @@
 
   std::unique_ptr<base::RunLoop> run_loop_;
 
-  DISALLOW_COPY_AND_ASSIGN(TestOverviewObserver);
+  DISALLOW_COPY_AND_ASSIGN(TestShellObserver);
 };
 
 void WaitForOcclusionStateChange(aura::Window* window) {
@@ -160,13 +158,12 @@
 TEST_F(OverviewControllerTest, AnimationCallbacks) {
   ui::ScopedAnimationDurationScaleMode non_zero(
       ui::ScopedAnimationDurationScaleMode::NON_ZERO_DURATION);
-  TestOverviewObserver observer(/*should_monitor_animation_state = */ true);
+  TestShellObserver observer(/*should_monitor_animation_state = */ true);
   // Enter without windows.
   auto* shell = Shell::Get();
   shell->overview_controller()->ToggleOverview();
   EXPECT_TRUE(shell->overview_controller()->IsSelecting());
-  EXPECT_EQ(TestOverviewObserver::COMPLETED,
-            observer.starting_animation_state());
+  EXPECT_EQ(TestShellObserver::COMPLETED, observer.starting_animation_state());
   auto* overview_controller = shell->overview_controller();
   EXPECT_TRUE(overview_controller->HasBlurForTest());
   EXPECT_TRUE(overview_controller->HasBlurAnimationForTest());
@@ -174,12 +171,12 @@
   // Exit without windows still creates an animation.
   shell->overview_controller()->ToggleOverview();
   EXPECT_FALSE(shell->overview_controller()->IsSelecting());
-  EXPECT_EQ(TestOverviewObserver::UNKNOWN, observer.ending_animation_state());
+  EXPECT_EQ(TestShellObserver::UNKNOWN, observer.ending_animation_state());
   EXPECT_TRUE(overview_controller->HasBlurForTest());
   EXPECT_TRUE(overview_controller->HasBlurAnimationForTest());
 
   observer.WaitForEndingAnimationComplete();
-  EXPECT_EQ(TestOverviewObserver::COMPLETED, observer.ending_animation_state());
+  EXPECT_EQ(TestShellObserver::COMPLETED, observer.ending_animation_state());
   EXPECT_FALSE(overview_controller->HasBlurForTest());
   EXPECT_FALSE(overview_controller->HasBlurAnimationForTest());
 
@@ -190,24 +187,23 @@
       CreateTestWindowInShellWithBounds(bounds));
 
   observer.Reset();
-  ASSERT_EQ(TestOverviewObserver::UNKNOWN, observer.starting_animation_state());
-  ASSERT_EQ(TestOverviewObserver::UNKNOWN, observer.ending_animation_state());
+  ASSERT_EQ(TestShellObserver::UNKNOWN, observer.starting_animation_state());
+  ASSERT_EQ(TestShellObserver::UNKNOWN, observer.ending_animation_state());
 
   // Enter with windows.
   shell->overview_controller()->ToggleOverview();
   EXPECT_TRUE(shell->overview_controller()->IsSelecting());
-  EXPECT_EQ(TestOverviewObserver::UNKNOWN, observer.starting_animation_state());
-  EXPECT_EQ(TestOverviewObserver::UNKNOWN, observer.ending_animation_state());
+  EXPECT_EQ(TestShellObserver::UNKNOWN, observer.starting_animation_state());
+  EXPECT_EQ(TestShellObserver::UNKNOWN, observer.ending_animation_state());
   EXPECT_FALSE(overview_controller->HasBlurForTest());
   EXPECT_FALSE(overview_controller->HasBlurAnimationForTest());
 
   // Exit with windows before starting animation ends.
   shell->overview_controller()->ToggleOverview();
   EXPECT_FALSE(shell->overview_controller()->IsSelecting());
-  EXPECT_EQ(TestOverviewObserver::CANCELED,
-            observer.starting_animation_state());
+  EXPECT_EQ(TestShellObserver::CANCELED, observer.starting_animation_state());
   // No shield so ending animation ends immediately.
-  EXPECT_EQ(TestOverviewObserver::COMPLETED, observer.ending_animation_state());
+  EXPECT_EQ(TestShellObserver::COMPLETED, observer.ending_animation_state());
   // Blur animation never started.
   EXPECT_FALSE(overview_controller->HasBlurForTest());
   EXPECT_FALSE(overview_controller->HasBlurAnimationForTest());
@@ -217,8 +213,8 @@
   // Enter again before exit animation ends.
   shell->overview_controller()->ToggleOverview();
   EXPECT_TRUE(shell->overview_controller()->IsSelecting());
-  EXPECT_EQ(TestOverviewObserver::UNKNOWN, observer.ending_animation_state());
-  EXPECT_EQ(TestOverviewObserver::UNKNOWN, observer.starting_animation_state());
+  EXPECT_EQ(TestShellObserver::UNKNOWN, observer.ending_animation_state());
+  EXPECT_EQ(TestShellObserver::UNKNOWN, observer.starting_animation_state());
   // Blur animation will start when animation is completed.
   EXPECT_FALSE(overview_controller->HasBlurForTest());
   EXPECT_FALSE(overview_controller->HasBlurAnimationForTest());
@@ -226,8 +222,7 @@
   // Activating window while entering animation should cancel the overview.
   wm::ActivateWindow(window1.get());
   EXPECT_FALSE(shell->overview_controller()->IsSelecting());
-  EXPECT_EQ(TestOverviewObserver::CANCELED,
-            observer.starting_animation_state());
+  EXPECT_EQ(TestShellObserver::CANCELED, observer.starting_animation_state());
   // Blur animation never started.
   EXPECT_FALSE(overview_controller->HasBlurForTest());
   EXPECT_FALSE(overview_controller->HasBlurAnimationForTest());
@@ -235,7 +230,7 @@
 
 // Tests the slide animation for overview is never used in clamshell.
 TEST_F(OverviewControllerTest, OverviewEnterExitAnimationClamshell) {
-  TestOverviewObserver observer(/*should_monitor_animation_state = */ false);
+  TestShellObserver observer(/*should_monitor_animation_state = */ false);
 
   const gfx::Rect bounds(200, 200);
   std::unique_ptr<aura::Window> window(
@@ -258,7 +253,7 @@
 // are minimized, and that if overview is exited from the home launcher all
 // windows are minimized.
 TEST_F(OverviewControllerTest, OverviewEnterExitAnimationTablet) {
-  TestOverviewObserver observer(/*should_monitor_animation_state = */ false);
+  TestShellObserver observer(/*should_monitor_animation_state = */ false);
 
   // Ensure calls to EnableTabletModeWindowManager complete.
   base::RunLoop().RunUntilIdle();
@@ -291,7 +286,7 @@
   Shell::Get()
       ->overview_controller()
       ->set_occlusion_pause_duration_for_end_ms_for_test(100);
-  TestOverviewObserver observer(/*should_monitor_animation_state = */ true);
+  TestShellObserver observer(/*should_monitor_animation_state = */ true);
   ui::ScopedAnimationDurationScaleMode non_zero(
       ui::ScopedAnimationDurationScaleMode::NON_ZERO_DURATION);
   gfx::Rect bounds(0, 0, 100, 100);
@@ -383,8 +378,8 @@
     TabletModeControllerTestApi().EnterTabletMode();
     base::RunLoop().RunUntilIdle();
     ASSERT_TRUE(keyboard::IsKeyboardEnabled());
-    keyboard::test::WaitUntilLoaded();
 
+    keyboard_controller()->LoadKeyboardWindowInBackground();
     keyboard_controller()->GetKeyboardWindow()->SetBounds(
         keyboard::KeyboardBoundsFromRootBounds(
             Shell::GetPrimaryRootWindow()->bounds(), 100));
--- a/ash/wm/overview/overview_grid.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/overview/overview_grid.cc	2019-05-17 18:53:08.368000000 +0300
@@ -6,18 +6,17 @@
 
 #include <algorithm>
 #include <functional>
+#include <memory>
+#include <set>
 #include <utility>
+#include <vector>
 
-#include "ash/metrics/histogram_macros.h"
-#include "ash/public/cpp/ash_features.h"
-#include "ash/public/cpp/fps_counter.h"
 #include "ash/public/cpp/shelf_types.h"
 #include "ash/public/cpp/shell_window_ids.h"
 #include "ash/public/cpp/wallpaper_types.h"
 #include "ash/public/cpp/window_properties.h"
 #include "ash/public/cpp/window_state_type.h"
 #include "ash/root_window_controller.h"
-#include "ash/rotator/screen_rotation_animator.h"
 #include "ash/screen_util.h"
 #include "ash/shelf/shelf.h"
 #include "ash/shelf/shelf_constants.h"
@@ -25,7 +24,6 @@
 #include "ash/strings/grit/ash_strings.h"
 #include "ash/wallpaper/wallpaper_controller.h"
 #include "ash/wallpaper/wallpaper_widget_controller.h"
-#include "ash/wm/desks/desks_bar_view.h"
 #include "ash/wm/overview/cleanup_animation_observer.h"
 #include "ash/wm/overview/drop_target_view.h"
 #include "ash/wm/overview/overview_constants.h"
@@ -52,6 +50,7 @@
 #include "ui/compositor/layer_animation_observer.h"
 #include "ui/compositor/scoped_layer_animation_settings.h"
 #include "ui/compositor_extra/shadow.h"
+#include "ui/gfx/animation/tween.h"
 #include "ui/gfx/color_analysis.h"
 #include "ui/gfx/color_utils.h"
 #include "ui/gfx/geometry/safe_integer_conversions.h"
@@ -67,6 +66,11 @@
 namespace ash {
 namespace {
 
+// Time it takes for the selector widget to move to the next target. The same
+// time is used for fading out shield widget when the overview mode is opened
+// or closed.
+constexpr int kOverviewSelectorTransitionMilliseconds = 250;
+
 // The color and opacity of the screen shield in overview.
 constexpr SkColor kShieldColor = SkColorSetARGB(255, 0, 0, 0);
 
@@ -100,25 +104,8 @@
 constexpr SkColor kNoItemsIndicatorTextColor = SK_ColorWHITE;
 constexpr float kNoItemsIndicatorBackgroundOpacity = 0.8f;
 
-// Histogram names for overview enter/exit smoothness in clamshell,
-// tablet mode and splitview.
-constexpr char kOverviewEnterClamshellHistogram[] =
-    "Ash.Overview.AnimationSmoothness.Enter.ClamshellMode";
-constexpr char kOverviewEnterSingleClamshellHistogram[] =
-    "Ash.Overview.AnimationSmoothness.Enter.SingleClamshellMode";
-constexpr char kOverviewEnterTabletHistogram[] =
-    "Ash.Overview.AnimationSmoothness.Enter.TabletMode";
-constexpr char kOverviewEnterSplitViewHistogram[] =
-    "Ash.Overview.AnimationSmoothness.Enter.SplitView";
-
-constexpr char kOverviewExitClamshellHistogram[] =
-    "Ash.Overview.AnimationSmoothness.Exit.ClamshellMode";
-constexpr char kOverviewExitSingleClamshellHistogram[] =
-    "Ash.Overview.AnimationSmoothness.Exit.SingleClamshellMode";
-constexpr char kOverviewExitTabletHistogram[] =
-    "Ash.Overview.AnimationSmoothness.Exit.TabletMode";
-constexpr char kOverviewExitSplitViewHistogram[] =
-    "Ash.Overview.AnimationSmoothness.Exit.SplitView";
+// Time duration of the show animation of the drop target.
+constexpr int kDropTargetTransitionMilliseconds = 250;
 
 // Returns the vector for the fade in animation.
 gfx::Vector2d GetSlideVectorForFadeIn(OverviewSession::Direction direction,
@@ -137,68 +124,6 @@
   return vector;
 }
 
-template <const char* clamshell_single_name,
-          const char* clamshell_multi_name,
-          const char* tablet_name,
-          const char* splitview_name>
-class OverviewFpsCounter : public FpsCounter {
- public:
-  OverviewFpsCounter(ui::Compositor* compositor,
-                     bool single_animation_in_clamshell)
-      : FpsCounter(compositor),
-        single_animation_in_clamshell_(single_animation_in_clamshell) {}
-  ~OverviewFpsCounter() override {
-    int smoothness = ComputeSmoothness();
-    if (smoothness < 0)
-      return;
-    if (single_animation_in_clamshell_)
-      UMA_HISTOGRAM_PERCENTAGE_IN_CLAMSHELL(clamshell_single_name, smoothness);
-    else
-      UMA_HISTOGRAM_PERCENTAGE_IN_CLAMSHELL(clamshell_multi_name, smoothness);
-    UMA_HISTOGRAM_PERCENTAGE_IN_TABLET_NON_SPLITVIEW(tablet_name, smoothness);
-    UMA_HISTOGRAM_PERCENTAGE_IN_SPLITVIEW(splitview_name, smoothness);
-  }
-
- private:
-  // True if only top window animates upon enter/exit overview in clamshell.
-  bool single_animation_in_clamshell_;
-
-  DISALLOW_COPY_AND_ASSIGN(OverviewFpsCounter);
-};
-
-using OverviewEnterFpsCounter =
-    OverviewFpsCounter<kOverviewEnterSingleClamshellHistogram,
-                       kOverviewEnterClamshellHistogram,
-                       kOverviewEnterTabletHistogram,
-                       kOverviewEnterSplitViewHistogram>;
-using OverviewExitFpsCounter =
-    OverviewFpsCounter<kOverviewExitSingleClamshellHistogram,
-                       kOverviewExitClamshellHistogram,
-                       kOverviewExitTabletHistogram,
-                       kOverviewExitSplitViewHistogram>;
-
-class ShutdownAnimationFpsCounterObserver : public OverviewObserver {
- public:
-  ShutdownAnimationFpsCounterObserver(ui::Compositor* compositor,
-                                      bool single_animation)
-      : fps_counter_(compositor, single_animation) {
-    Shell::Get()->overview_controller()->AddObserver(this);
-  }
-  ~ShutdownAnimationFpsCounterObserver() override {
-    Shell::Get()->overview_controller()->RemoveObserver(this);
-  }
-
-  // OverviewObserver:
-  void OnOverviewModeEndingAnimationComplete(bool canceled) override {
-    delete this;
-  }
-
- private:
-  OverviewExitFpsCounter fps_counter_;
-
-  DISALLOW_COPY_AND_ASSIGN(ShutdownAnimationFpsCounterObserver);
-};
-
 // Creates |drop_target_widget_|. It's created when a window (not from overview)
 // is dragged around and destroyed when the drag ends. If |animate| is true, do
 // the opacity animation for the drop target.
@@ -224,12 +149,15 @@
 
   if (animate) {
     widget->SetOpacity(0.f);
-    ScopedOverviewAnimationSettings settings(
-        OVERVIEW_ANIMATION_DROP_TARGET_FADE_IN, widget->GetNativeWindow());
-    widget->SetOpacity(1.f);
-  } else {
-    widget->SetOpacity(1.f);
+    ui::ScopedLayerAnimationSettings animation_settings(
+        widget->GetNativeWindow()->layer()->GetAnimator());
+    animation_settings.SetTransitionDuration(
+        base::TimeDelta::FromMilliseconds(kDropTargetTransitionMilliseconds));
+    animation_settings.SetTweenType(gfx::Tween::EASE_IN);
+    animation_settings.SetPreemptionStrategy(
+        ui::LayerAnimator::IMMEDIATELY_ANIMATE_TO_NEW_TARGET);
   }
+  widget->SetOpacity(1.f);
   return widget;
 }
 
@@ -273,9 +201,6 @@
 
 // ShieldView contains the background for overview mode. It also contains text
 // which is shown if there are no windows to be displayed.
-// This view also takes care of disabling overview mode on:
-//   - Gesture tap.
-//   - Mouse release.
 class OverviewGrid::ShieldView : public views::View {
  public:
   ShieldView() {
@@ -316,20 +241,6 @@
 
   ~ShieldView() override = default;
 
-  const DesksBarView* desks_bar_view() const { return desks_bar_view_; }
-
-  // Call this only after this view has been added to a widget. This is needed
-  // because the desks mini views need to access the widget to get the
-  // root window in order to know how to layout themselves.
-  void MaybeInitVirtualDesksBar() {
-    if (!features::IsVirtualDesksEnabled())
-      return;
-
-    desks_bar_view_ = new DesksBarView;
-    AddChildView(desks_bar_view_);
-    desks_bar_view_->Init();
-  }
-
   void SetBackgroundColor(SkColor color) {
     background_view_->layer()->SetColor(color);
   }
@@ -352,70 +263,19 @@
     label_container_bounds.ClampToCenteredSize(
         gfx::Size(label_width, kNoItemsIndicatorHeightDp));
     label_container_->SetBoundsRect(label_container_bounds);
-
-    UpdateDesksBarBounds();
   }
 
   bool IsLabelVisible() const { return label_container_->visible(); }
 
  protected:
   // views::View:
-  void Layout() override {
-    background_view_->SetBoundsRect(GetLocalBounds());
-    UpdateDesksBarBounds();
-  }
+  void Layout() override { background_view_->SetBoundsRect(GetLocalBounds()); }
 
  private:
-  // ui::EventHandler:
-  void OnMouseEvent(ui::MouseEvent* event) override {
-    if (event->type() == ui::ET_MOUSE_PRESSED) {
-      // In order to receive subsequent mouse release events in this view, we
-      // must mark the event as handled in this view.
-      event->SetHandled();
-      return;
-    }
-
-    HandleClickReleaseOrTap(event);
-  }
-
-  void OnGestureEvent(ui::GestureEvent* event) override {
-    HandleClickReleaseOrTap(event);
-  }
-
-  void HandleClickReleaseOrTap(ui::Event* event) {
-    if (event->type() != ui::ET_MOUSE_RELEASED &&
-        event->type() != ui::ET_GESTURE_TAP) {
-      return;
-    }
-
-    OverviewController* controller = Shell::Get()->overview_controller();
-    if (!controller->IsSelecting())
-      return;
-
-    // Events that happen while app list is sliding out during overview should
-    // be ignored to prevent overview from disappearing out from under the user.
-    if (!IsSlidingOutOverviewFromShelf())
-      controller->ToggleOverview();
-
-    event->StopPropagation();
-  }
-
-  void UpdateDesksBarBounds() {
-    if (!desks_bar_view_)
-      return;
-
-    // TODO: Make the ShieldView's bounds match the overview grid bounds rather
-    // than the entire screen?
-    const auto bar_bounds =
-        gfx::Rect{bounds().width(), DesksBarView::GetBarHeight()};
-    desks_bar_view_->SetBoundsRect(bar_bounds);
-  }
-
   // Owned by views heirarchy.
   views::View* background_view_ = nullptr;
   RoundedRectView* label_container_ = nullptr;
   views::Label* label_ = nullptr;
-  DesksBarView* desks_bar_view_ = nullptr;
 
   DISALLOW_COPY_AND_ASSIGN(ShieldView);
 };
@@ -535,41 +395,14 @@
 }
 
 void OverviewGrid::Shutdown() {
-  ScreenRotationAnimator::GetForRootWindow(root_window_)->RemoveObserver(this);
-
-  bool has_non_cover_animating = false;
-  int animate_count = 0;
-
-  for (const auto& window : window_list_) {
-    if (window->should_animate_when_exiting() && !has_non_cover_animating) {
-      has_non_cover_animating |=
-          !CanCoverAvailableWorkspace(window->GetWindow());
-      animate_count++;
-    }
+  for (const auto& window : window_list_)
     window->Shutdown();
-  }
-  bool single_animation_in_clamshell =
-      (animate_count == 1 && !has_non_cover_animating) &&
-      !Shell::Get()
-           ->tablet_mode_controller()
-           ->IsTabletModeWindowManagerEnabled();
-
-  // OverviewGrid in splitscreen does not include the window to be activated.
-  if (!window_list_.empty() ||
-      Shell::Get()->split_view_controller()->IsSplitViewModeActive()) {
-    // The following instance self-destructs when shutdown animation ends.
-    new ShutdownAnimationFpsCounterObserver(
-        root_window_->layer()->GetCompositor(), single_animation_in_clamshell);
-  }
 
   // Shutdown() implies |overview_session_| is about to be deleted, so reset it.
   auto exit_overview_session_type =
       overview_session_->enter_exit_overview_type();
   overview_session_ = nullptr;
 
-  while (!window_list_.empty())
-    RemoveItem(window_list_.back().get(), /*reposition=*/false);
-
   // HomeLauncherGestureHandler will handle fading/sliding |shield_widget_| in
   // this exit mode.
   if (exit_overview_session_type ==
@@ -581,7 +414,8 @@
     // Fade out the shield widget. This animation continues past the lifetime
     // of |this|.
     FadeOutWidgetAndMaybeSlideOnExit(std::move(shield_widget_),
-                                     OVERVIEW_ANIMATION_RESTORE_WINDOW);
+                                     OVERVIEW_ANIMATION_RESTORE_WINDOW,
+                                     /*slide=*/false);
   }
 }
 
@@ -592,18 +426,13 @@
   for (const auto& window : window_list_)
     window->PrepareForOverview();
   prepared_for_overview_ = true;
-  if (Shell::Get()
-          ->tablet_mode_controller()
-          ->IsTabletModeWindowManagerEnabled()) {
-    ScreenRotationAnimator::GetForRootWindow(root_window_)->AddObserver(this);
-  }
 }
 
 void OverviewGrid::PositionWindows(
     bool animate,
     OverviewItem* ignored_item,
     OverviewSession::OverviewTransition transition) {
-  if (!overview_session_ || suspend_reposition_)
+  if (!overview_session_)
     return;
 
   DCHECK_NE(transition, OverviewSession::OverviewTransition::kExit);
@@ -619,25 +448,19 @@
   if (window_list_.empty())
     return;
 
-  std::vector<gfx::RectF> rects = GetWindowRects(ignored_item);
+  std::vector<gfx::Rect> rects = GetWindowRects(ignored_item);
 
   // Position the windows centering the left-aligned rows vertically. Do not
   // position |ignored_item| if it is not nullptr and matches a item in
   // |window_list_|.
   OverviewAnimationType animation_type =
       transition == OverviewSession::OverviewTransition::kEnter
-          ? OVERVIEW_ANIMATION_LAYOUT_OVERVIEW_ITEMS_ON_ENTER
-          : OVERVIEW_ANIMATION_LAYOUT_OVERVIEW_ITEMS_IN_OVERVIEW;
-
-  int animate_count = 0;
-  bool has_non_cover_animating = false;
-  OverviewAnimationType animation_types[rects.size()];
-
+          ? OVERVIEW_ANIMATION_LAY_OUT_SELECTOR_ITEMS_ON_ENTER
+          : OVERVIEW_ANIMATION_LAY_OUT_SELECTOR_ITEMS_IN_OVERVIEW;
   for (size_t i = 0; i < window_list_.size(); ++i) {
     OverviewItem* window_item = window_list_[i].get();
     if (window_item->animating_to_close() ||
         (ignored_item != nullptr && window_item == ignored_item)) {
-      rects[i].SetRect(0, 0, 0, 0);
       continue;
     }
 
@@ -651,37 +474,10 @@
     // animation by ourselves.
     if (IsDropTargetWindow(window_item->GetWindow()))
       should_animate_item = false;
-    if (animate && transition == OverviewSession::OverviewTransition::kEnter) {
-      if (window_item->should_animate_when_entering() &&
-          !has_non_cover_animating) {
-        has_non_cover_animating |=
-            !CanCoverAvailableWorkspace(window_item->GetWindow());
-        animate_count++;
-      }
-    }
-    animation_types[i] =
-        should_animate_item ? animation_type : OVERVIEW_ANIMATION_NONE;
-  }
-
-  if (animate && transition == OverviewSession::OverviewTransition::kEnter &&
-      !window_list_.empty()) {
-    bool single_animation_in_clamshell =
-        animate_count == 1 && !has_non_cover_animating &&
-        !Shell::Get()
-             ->tablet_mode_controller()
-             ->IsTabletModeWindowManagerEnabled();
-    fps_counter_ = std::make_unique<OverviewEnterFpsCounter>(
-        window_list_[0]->GetWindow()->layer()->GetCompositor(),
-        single_animation_in_clamshell);
-  }
 
-  // Apply the animation after creating fps_counter_ so that unit test
-  // can correctly count the measure requests.
-  for (size_t i = 0; i < window_list_.size(); ++i) {
-    if (rects[i].IsEmpty())
-      continue;
-    OverviewItem* window_item = window_list_[i].get();
-    window_item->SetBounds(rects[i], animation_types[i]);
+    window_item->SetBounds(rects[i], should_animate_item
+                                         ? animation_type
+                                         : OVERVIEW_ANIMATION_NONE);
   }
 
   // If the selection widget is active, reposition it without any animation.
@@ -696,7 +492,7 @@
   bool recreate_selection_widget = false;
   bool out_of_bounds = false;
   bool changed_selection_index = false;
-  gfx::RectF old_bounds;
+  gfx::Rect old_bounds;
   if (SelectedWindow()) {
     old_bounds = SelectedWindow()->target_bounds();
     // Make the old selected window header non-transparent first.
@@ -783,20 +579,16 @@
     PositionWindows(animate);
 }
 
-void OverviewGrid::RemoveItem(OverviewItem* overview_item, bool reposition) {
-  auto* window = overview_item->GetWindow();
-  // Use reverse iterator to be efficiently when removing all.
-  auto iter = std::find_if(window_list_.rbegin(), window_list_.rend(),
-                           [window](std::unique_ptr<OverviewItem>& item) {
-                             return item->GetWindow() == window;
-                           });
-  if (iter != window_list_.rend()) {
-    window_observer_.Remove(window);
-    window_state_observer_.Remove(wm::GetWindowState(window));
+void OverviewGrid::RemoveItem(OverviewItem* selector_item, bool reposition) {
+  auto iter = GetOverviewItemIterContainingWindow(selector_item->GetWindow());
+  if (iter != window_list_.end()) {
+    window_observer_.Remove(selector_item->GetWindow());
+    window_state_observer_.Remove(
+        wm::GetWindowState(selector_item->GetWindow()));
     // Erase from the list first because deleting OverviewItem can lead to
     // iterating through the |window_list_|.
     std::unique_ptr<OverviewItem> tmp = std::move(*iter);
-    window_list_.erase(std::next(iter).base());
+    window_list_.erase(iter);
   }
 
   if (reposition)
@@ -911,8 +703,8 @@
     }
 
     // Also clear ash::kIsDeferredTabDraggingTargetWindowKey key on the target
-    // overview item so that it can't merge into this overview item if the
-    // dragged window is currently in preview window area.
+    // window selector item so that it can't merge into this window selector
+    // item if the dragged window is currently in preview window area.
     if (target_window && !IsDropTargetWindow(target_window))
       target_window->ClearProperty(ash::kIsDeferredTabDraggingTargetWindowKey);
 
@@ -920,7 +712,7 @@
   }
 
   // Show the selection widget if |location_in_screen| is contained by the
-  // browser windows' overview item in overview.
+  // browser windows' selector items in overview.
   if (target_window &&
       target_window->GetProperty(ash::kIsDeferredTabDraggingTargetWindowKey)) {
     size_t previous_selected_index = selected_index_;
@@ -1034,7 +826,7 @@
 
   if (empty()) {
     selection_widget_.reset();
-    // If the grid is now empty, notify |overview_session_| so that it erases us
+    // If the grid is now empty, notify the window selector so that it erases us
     // from its grid list.
     if (overview_session_)
       overview_session_->OnGridEmpty(this);
@@ -1074,16 +866,6 @@
   PositionWindows(false);
 }
 
-void OverviewGrid::OnWindowPropertyChanged(aura::Window* window,
-                                           const void* key,
-                                           intptr_t old) {
-  if (prepared_for_overview_ && key == aura::client::kTopViewInset &&
-      window->GetProperty(aura::client::kTopViewInset) !=
-          static_cast<int>(old)) {
-    PositionWindows(/*animate=*/false);
-  }
-}
-
 void OverviewGrid::OnPostWindowStateTypeChange(
     wm::WindowState* window_state,
     mojom::WindowStateType old_type) {
@@ -1115,26 +897,7 @@
   }
 }
 
-void OverviewGrid::OnScreenCopiedBeforeRotation() {
-  for (auto& window : window_list()) {
-    window->set_disable_mask(true);
-    window->UpdateMaskAndShadow();
-  }
-}
-
-void OverviewGrid::OnScreenRotationAnimationFinished(
-    ScreenRotationAnimator* animator,
-    bool canceled) {
-  for (auto& window : window_list())
-    window->set_disable_mask(false);
-  Shell::Get()->overview_controller()->DelayedUpdateMaskAndShadow();
-}
-
-void OverviewGrid::OnStartingAnimationComplete(bool canceled) {
-  fps_counter_.reset();
-  if (canceled)
-    return;
-
+void OverviewGrid::OnStartingAnimationComplete() {
   if (!shield_widget_) {
     InitShieldWidget(/*animate=*/true);
     ShowNoRecentsWindowMessage(window_list_.empty());
@@ -1145,15 +908,9 @@
 }
 
 bool OverviewGrid::ShouldAnimateWallpaper() const {
-  // Never animate when doing app dragging.
-  if (overview_session_->enter_exit_overview_type() ==
-      OverviewSession::EnterExitOverviewType::kWindowDragged) {
-    return false;
-  }
-
   // If one of the windows covers the workspace, we do not need to animate.
-  for (const auto& overview_item : window_list_) {
-    if (CanCoverAvailableWorkspace(overview_item->GetWindow()))
+  for (const auto& selector_item : window_list_) {
+    if (CanCoverAvailableWorkspace(selector_item->GetWindow()))
       return false;
   }
 
@@ -1254,11 +1011,11 @@
 
   // Get the bounds of the windows currently, and the bounds if |item| were to
   // be removed.
-  std::vector<gfx::RectF> src_rects;
+  std::vector<gfx::Rect> src_rects;
   for (const auto& window_item : window_list_)
     src_rects.push_back(window_item->target_bounds());
 
-  std::vector<gfx::RectF> dst_rects = GetWindowRects(item);
+  std::vector<gfx::Rect> dst_rects = GetWindowRects(item);
 
   // Get the index of |item|.
   size_t index =
@@ -1275,10 +1032,10 @@
   // should not be used. The item at |index| is marked with a 0. The heights of
   // items are all set to the same value so a new row is determined if the y
   // value has changed from the previous item.
-  auto get_rows = [](const std::vector<gfx::RectF>& bounds_list, size_t index) {
+  auto get_rows = [](const std::vector<gfx::Rect>& bounds_list, size_t index) {
     std::vector<int> row_numbers;
     int current_row = 1;
-    float last_y = 0;
+    int last_y = 0;
     for (size_t i = 0; i < bounds_list.size(); ++i) {
       if (i == index) {
         row_numbers.push_back(0);
@@ -1378,8 +1135,8 @@
     OverviewItem* nudged_item = window_list_[data.index].get();
     double nudge_param = value * value / 30.0;
     nudge_param = base::ClampToRange(nudge_param, 0.0, 1.0);
-    gfx::RectF bounds =
-        gfx::Tween::RectFValueBetween(nudge_param, data.src, data.dst);
+    gfx::Rect bounds =
+        gfx::Tween::RectValueBetween(nudge_param, data.src, data.dst);
     nudged_item->SetBounds(bounds, OVERVIEW_ANIMATION_NONE);
   }
 }
@@ -1398,17 +1155,6 @@
     float opacity,
     const gfx::Rect& work_area,
     OverviewSession::UpdateAnimationSettingsCallback callback) {
-  // Translate the window items to |new_y| with the opacity.
-  for (const auto& window_item : window_list_)
-    window_item->UpdateYPositionAndOpacity(new_y, opacity, callback);
-
-  // Shield widget can be null because it's created asynchronously. The
-  // shield_widget won't use the same transform when created if this
-  // happened. Since shield widget will be removed soon, this is leave it as is.
-  // (https://crbug.com/942759)
-  if (!shield_widget_)
-    return;
-
   // Translate |shield_widget_| to |new_y|. The shield widget covers the shelf
   // so scale it down while moving it, so that it does not cover the launcher,
   // which is showing as this is disappearing.
@@ -1426,35 +1172,25 @@
   shield_window->SetTransform(gfx::Transform(1.f, 0.f, 0.f, height_ratio, 0.f,
                                              static_cast<float>(new_y)));
   shield_window->layer()->SetOpacity(opacity);
+
+  // Apply the same translation and opacity change to the windows in the grid.
+  for (const auto& window_item : window_list_) {
+    window_item->UpdateYPositionAndOpacity(new_y, opacity, callback);
+  }
 }
 
 aura::Window* OverviewGrid::GetTargetWindowOnLocation(
     const gfx::Point& location_in_screen) {
-  // Find the overview item that contains |location_in_screen|.
-  auto iter = std::find_if(
-      window_list_.begin(), window_list_.end(),
+  // Find the window selector item that contains |location_in_screen|.
+  auto iter =
+      std::find_if(window_list_.begin(), window_list_.end(),
       [&location_in_screen](std::unique_ptr<OverviewItem>& item) {
-        return item->target_bounds().Contains(gfx::PointF(location_in_screen));
+                     return item->target_bounds().Contains(location_in_screen);
       });
 
   return (iter != window_list_.end()) ? (*iter)->GetWindow() : nullptr;
 }
 
-const DesksBarView* OverviewGrid::GetDesksBarViewForTesting() const {
-  return shield_view_->desks_bar_view();
-}
-
-bool OverviewGrid::IsDesksBarViewActive() const {
-  DCHECK(features::IsVirtualDesksEnabled());
-
-  // The desk bar view is not active if there is only a single desk when
-  // overview is started. Once there are more than one desk, it should stay
-  // active even if the 2nd to last desk is deleted.
-  return DesksController::Get()->desks().size() > 1 ||
-         (shield_view_ &&
-          !shield_view_->desks_bar_view()->mini_views().empty());
-}
-
 void OverviewGrid::InitShieldWidget(bool animate) {
   // TODO(varkha): The code assumes that SHELF_BACKGROUND_MAXIMIZED is
   // synonymous with a black shelf background. Update this code if that
@@ -1467,7 +1203,7 @@
   shield_widget_ = CreateBackgroundWidget(
       root_window_, ui::LAYER_NOT_DRAWN, SK_ColorTRANSPARENT, 0, 0,
       SK_ColorTRANSPARENT, initial_opacity, /*parent=*/nullptr,
-      /*stack_on_top=*/true, /*accept_events=*/true);
+      /*stack_on_top=*/true);
   aura::Window* widget_window = shield_widget_->GetNativeWindow();
   aura::Window* parent_window = widget_window->parent();
   const gfx::Rect bounds = ash::screen_util::SnapBoundsToDisplayEdge(
@@ -1477,15 +1213,19 @@
 
   // Create |shield_view_| and animate its background and label if needed.
   shield_view_ = new ShieldView();
-  shield_widget_->SetContentsView(shield_view_);
-  shield_view_->MaybeInitVirtualDesksBar();
   shield_view_->SetBackgroundColor(GetShieldColor());
   shield_view_->SetGridBounds(bounds_);
+  shield_widget_->SetContentsView(shield_view_);
 
   if (animate) {
     shield_widget_->SetOpacity(initial_opacity);
-    ScopedOverviewAnimationSettings settings(OVERVIEW_ANIMATION_SHIELD_FADE,
-                                             shield_widget_->GetNativeWindow());
+    ui::ScopedLayerAnimationSettings animation_settings(
+        widget_window->layer()->GetAnimator());
+    animation_settings.SetTransitionDuration(base::TimeDelta::FromMilliseconds(
+        kOverviewSelectorTransitionMilliseconds));
+    animation_settings.SetTweenType(gfx::Tween::EASE_OUT);
+    animation_settings.SetPreemptionStrategy(
+        ui::LayerAnimator::IMMEDIATELY_ANIMATE_TO_NEW_TARGET);
     shield_widget_->SetOpacity(1.f);
   } else {
     shield_widget_->SetOpacity(1.f);
@@ -1496,10 +1236,9 @@
   selection_widget_ = CreateBackgroundWidget(
       root_window_, ui::LAYER_TEXTURED, kWindowSelectionColor, 0,
       kWindowSelectionRadius, SK_ColorTRANSPARENT, 0.f, /*parent=*/nullptr,
-      /*stack_on_top=*/true, /*accept_events=*/false);
+      /*stack_on_top=*/true);
   aura::Window* widget_window = selection_widget_->GetNativeWindow();
-  gfx::Rect target_bounds =
-      gfx::ToEnclosedRect(SelectedWindow()->target_bounds());
+  gfx::Rect target_bounds = SelectedWindow()->target_bounds();
   ::wm::ConvertRectFromScreen(root_window_, &target_bounds);
   gfx::Vector2d fade_out_direction =
       GetSlideVectorForFadeIn(direction, target_bounds);
@@ -1527,15 +1266,21 @@
     gfx::Vector2d fade_out_direction =
         GetSlideVectorForFadeIn(direction, old_selection_window->bounds());
 
-    ScopedOverviewAnimationSettings settings(
-        OVERVIEW_ANIMATION_SELECTION_WINDOW, old_selection_window);
+    ui::ScopedLayerAnimationSettings animation_settings(
+        old_selection_window->layer()->GetAnimator());
+    animation_settings.SetTransitionDuration(base::TimeDelta::FromMilliseconds(
+        kOverviewSelectorTransitionMilliseconds));
+    animation_settings.SetPreemptionStrategy(
+        ui::LayerAnimator::IMMEDIATELY_ANIMATE_TO_NEW_TARGET);
+    animation_settings.SetTweenType(gfx::Tween::FAST_OUT_LINEAR_IN);
     // CleanupAnimationObserver will delete itself (and the widget) when the
-    // motion animation is complete. Ownership over the observer is passed to
-    // the overview_session_->delegate() which has longer lifetime so that
-    // animations can continue even after the overview session is shut down.
+    // motion animation is complete.
+    // Ownership over the observer is passed to the
+    // overview_session_->delegate() which has longer lifetime so that
+    // animations can continue even after the overview mode is shut down.
     std::unique_ptr<CleanupAnimationObserver> observer(
         new CleanupAnimationObserver(std::move(selection_widget_)));
-    settings.AddObserver(observer.get());
+    animation_settings.AddObserver(observer.get());
     overview_session_->delegate()->AddDelayedAnimationObserver(
         std::move(observer));
     old_selection->SetOpacity(0.f);
@@ -1557,19 +1302,30 @@
 }
 
 void OverviewGrid::MoveSelectionWidgetToTarget(bool animate) {
-  gfx::Rect bounds = gfx::ToEnclosingRect(SelectedWindow()->target_bounds());
+  gfx::Rect bounds = SelectedWindow()->target_bounds();
   ::wm::ConvertRectFromScreen(root_window_, &bounds);
   if (animate) {
-    ScopedOverviewAnimationSettings settings(
-        OVERVIEW_ANIMATION_SELECTION_WINDOW,
-        selection_widget_->GetNativeWindow());
+    aura::Window* selection_widget_window =
+        selection_widget_->GetNativeWindow();
+    ui::ScopedLayerAnimationSettings animation_settings(
+        selection_widget_window->layer()->GetAnimator());
+    animation_settings.SetTransitionDuration(base::TimeDelta::FromMilliseconds(
+        kOverviewSelectorTransitionMilliseconds));
+    animation_settings.SetTweenType(gfx::Tween::EASE_IN_OUT);
+    animation_settings.SetPreemptionStrategy(
+        ui::LayerAnimator::IMMEDIATELY_ANIMATE_TO_NEW_TARGET);
     selection_widget_->SetBounds(bounds);
     selection_widget_->SetOpacity(1.f);
 
     if (selector_shadow_) {
-      ScopedOverviewAnimationSettings settings(
-          OVERVIEW_ANIMATION_SELECTION_WINDOW_SHADOW,
+      ui::ScopedLayerAnimationSettings animation_settings_shadow(
           selector_shadow_->shadow_layer()->GetAnimator());
+      animation_settings_shadow.SetTransitionDuration(
+          base::TimeDelta::FromMilliseconds(
+              kOverviewSelectorTransitionMilliseconds));
+      animation_settings_shadow.SetTweenType(gfx::Tween::EASE_IN_OUT);
+      animation_settings_shadow.SetPreemptionStrategy(
+          ui::LayerAnimator::IMMEDIATELY_ANIMATE_TO_NEW_TARGET);
       bounds.Inset(1, 1);
       selector_shadow_->SetContentBounds(
           gfx::Rect(gfx::Point(1, 1), bounds.size()));
@@ -1585,22 +1341,9 @@
   }
 }
 
-std::vector<gfx::RectF> OverviewGrid::GetWindowRects(
+std::vector<gfx::Rect> OverviewGrid::GetWindowRects(
     OverviewItem* ignored_item) {
   gfx::Rect total_bounds = bounds_;
-
-  if (features::IsVirtualDesksEnabled()) {
-    const int desks_bar_height = DesksBarView::GetBarHeight();
-
-    // Always reduce the grid's height, even if the desks bar is not active. We
-    // do this to avoid changing the overview windows sizes once the desks bar
-    // becomes active, and we shift the grid downwards.
-    total_bounds.set_height(total_bounds.height() - desks_bar_height);
-
-    if (IsDesksBarViewActive())
-      total_bounds.Offset(0, desks_bar_height);
-  }
-
   // Windows occupy vertically centered area with additional vertical insets.
   int horizontal_inset =
       gfx::ToFlooredInt(std::min(kOverviewInsetRatio * total_bounds.width(),
@@ -1610,7 +1353,7 @@
       kOverviewVerticalInset * (total_bounds.height() - 2 * horizontal_inset);
   total_bounds.Inset(std::max(0, horizontal_inset - kWindowMargin),
                      std::max(0, vertical_inset - kWindowMargin));
-  std::vector<gfx::RectF> rects;
+  std::vector<gfx::Rect> rects;
 
   // Keep track of the lowest coordinate.
   int max_bottom = total_bounds.y();
@@ -1634,7 +1377,8 @@
   // true and the rows are balanced by repeatedly squeezing the widest row to
   // cause windows to overflow to the subsequent rows.
   int low_height = 2 * kWindowMargin;
-  int high_height = std::max(low_height, total_bounds.height() + 1);
+  int high_height =
+      std::max(low_height, static_cast<int>(total_bounds.height() + 1));
   int height = 0.5 * (low_height + high_height);
   bool height_fixed = false;
 
@@ -1703,7 +1447,7 @@
         ignored_item, &rects, &max_bottom, &min_right, &max_right);
   }
 
-  gfx::Vector2dF offset(0, (total_bounds.bottom() - max_bottom) / 2.f);
+  gfx::Vector2d offset(0, (total_bounds.bottom() - max_bottom) / 2);
   for (size_t i = 0; i < rects.size(); ++i)
     rects[i] += offset;
   return rects;
@@ -1712,7 +1456,7 @@
 bool OverviewGrid::FitWindowRectsInBounds(const gfx::Rect& bounds,
                                           int height,
                                           OverviewItem* ignored_item,
-                                          std::vector<gfx::RectF>* out_rects,
+                                          std::vector<gfx::Rect>* out_rects,
                                           int* out_max_bottom,
                                           int* out_min_right,
                                           int* out_max_right) {
@@ -1744,7 +1488,7 @@
       continue;
     }
 
-    const gfx::RectF target_bounds = window->GetTargetBoundsInScreen();
+    const gfx::Rect target_bounds = window->GetTargetBoundsInScreen();
     int width = std::max(1, gfx::ToFlooredInt(target_bounds.width() *
                                               window->GetItemScale(item_size)) +
                                 2 * kWindowMargin);
@@ -1787,10 +1531,10 @@
     }
 
     // Position the current rect.
-    (*out_rects)[i] = gfx::RectF(gfx::Rect(left, top, width, height));
+    (*out_rects)[i].SetRect(left, top, width, height);
 
     // Increment horizontal position using sanitized positive |width()|.
-    left += gfx::ToRoundedInt((*out_rects)[i].width());
+    left += (*out_rects)[i].width();
 
     if (++i == out_rects->size()) {
       // Update the narrowest and widest row width for the last row.
@@ -1805,23 +1549,23 @@
 }
 
 void OverviewGrid::CalculateOverviewItemAnimationState(
-    OverviewItem* overview_item,
+    OverviewItem* selector_item,
     bool* has_covered_available_workspace,
     bool selected,
     OverviewSession::OverviewTransition transition) {
-  if (!overview_item)
+  if (!selector_item)
     return;
 
-  aura::Window* window = overview_item->GetWindow();
-  // |overview_item| should be contained in the |window_list_|.
+  aura::Window* window = selector_item->GetWindow();
+  // |selector_item| should be contained in the |window_list_|.
   DCHECK(GetOverviewItemContaining(window));
 
   bool can_cover_available_workspace = CanCoverAvailableWorkspace(window);
   const bool should_animate = selected || !(*has_covered_available_workspace);
   if (transition == OverviewSession::OverviewTransition::kEnter)
-    overview_item->set_should_animate_when_entering(should_animate);
+    selector_item->set_should_animate_when_entering(should_animate);
   if (transition == OverviewSession::OverviewTransition::kExit)
-    overview_item->set_should_animate_when_exiting(should_animate);
+    selector_item->set_should_animate_when_exiting(should_animate);
 
   if (!(*has_covered_available_workspace) && can_cover_available_workspace)
     *has_covered_available_workspace = true;
@@ -1857,8 +1601,8 @@
     if (old_bounds != new_bounds) {
       // It's for smoother animation.
       gfx::Transform transform =
-          ScopedOverviewTransformWindow::GetTransformForRect(
-              gfx::RectF(new_bounds), gfx::RectF(old_bounds));
+          ScopedOverviewTransformWindow::GetTransformForRect(new_bounds,
+                                                             old_bounds);
       dragged_window->SetTransform(transform);
     }
     dragged_window->ClearProperty(ash::kCanAttachToAnotherWindowKey);
--- a/ash/wm/overview/overview_grid.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/overview/overview_grid.h	2019-05-17 18:53:08.368000000 +0300
@@ -8,9 +8,9 @@
 #include <stddef.h>
 
 #include <memory>
+#include <set>
 #include <vector>
 
-#include "ash/rotator/screen_rotation_animator_observer.h"
 #include "ash/wm/overview/overview_session.h"
 #include "ash/wm/window_state_observer.h"
 #include "base/macros.h"
@@ -18,7 +18,6 @@
 #include "base/scoped_observer.h"
 #include "ui/aura/window_observer.h"
 #include "ui/gfx/geometry/rect.h"
-#include "ui/gfx/geometry/rect_f.h"
 
 namespace ui {
 class Shadow;
@@ -30,8 +29,6 @@
 
 namespace ash {
 
-class DesksBarView;
-class FpsCounter;
 class OverviewItem;
 
 // Represents a grid of windows in the Overview Mode in a particular root
@@ -53,8 +50,7 @@
 // The selector is switched to the next window grid (if available) or wrapped if
 // it reaches the end of its movement sequence.
 class ASH_EXPORT OverviewGrid : public aura::WindowObserver,
-                                public wm::WindowStateObserver,
-                                public ScreenRotationAnimatorObserver {
+                                public wm::WindowStateObserver {
  public:
   OverviewGrid(aura::Window* root_window,
                const std::vector<aura::Window*>& window_list,
@@ -101,17 +97,17 @@
   // reposition with animation.
   void AddItem(aura::Window* window, bool reposition, bool animate);
 
-  // Removes |overview_item| from the grid. If |reposition| is true, reposition
+  // Removes |selector_item| from the grid. If |reprosition| is ture, reposition
   // all window items in the grid after removing the item.
-  void RemoveItem(OverviewItem* overview_item, bool reposition);
+  void RemoveItem(OverviewItem* selector_item, bool reposition);
 
   // Sets bounds for the window grid and positions all windows in the grid.
   void SetBoundsAndUpdatePositions(const gfx::Rect& bounds_in_screen);
   void SetBoundsAndUpdatePositionsIgnoringWindow(const gfx::Rect& bounds,
                                                  OverviewItem* ignored_item);
 
-  // Shows or hides the selection widget. To be called by an overview item when
-  // it is dragged.
+  // Shows or hides the selection widget. To be called by a window selector item
+  // when it is dragged.
   void SetSelectionWidgetVisibility(bool visible);
 
   void ShowNoRecentsWindowMessage(bool visible);
@@ -136,33 +132,24 @@
   // Returns true if |window| is the placeholder window from the drop target.
   bool IsDropTargetWindow(aura::Window* window) const;
 
-  // Returns the overview item that accociates with |drop_target_widget_|.
+  // Returns the selector item that accociates with |drop_target_widget_|.
   // Returns nullptr if overview does not have the drop target.
   OverviewItem* GetDropTarget();
 
   // aura::WindowObserver:
   void OnWindowDestroying(aura::Window* window) override;
-  // TODO(flackr): Handle window bounds changed in OverviewItem. See also
-  // OnWindowPropertyChanged() below.
+  // TODO(flackr): Handle window bounds changed in OverviewItem.
   void OnWindowBoundsChanged(aura::Window* window,
                              const gfx::Rect& old_bounds,
                              const gfx::Rect& new_bounds,
                              ui::PropertyChangeReason reason) override;
-  void OnWindowPropertyChanged(aura::Window* window,
-                               const void* key,
-                               intptr_t old) override;
 
   // wm::WindowStateObserver:
   void OnPostWindowStateTypeChange(wm::WindowState* window_state,
                                    mojom::WindowStateType old_type) override;
 
-  // ScreenRotationAnimatorObserver:
-  void OnScreenCopiedBeforeRotation() override;
-  void OnScreenRotationAnimationFinished(ScreenRotationAnimator* animator,
-                                         bool canceled) override;
-
   // Called when overview starting animation completes.
-  void OnStartingAnimationComplete(bool canceled);
+  void OnStartingAnimationComplete();
 
   // Checks if the grid needs to have the wallpaper animated. Returns false if
   // one of the grids windows covers the the entire workspace, true otherwise.
@@ -173,9 +160,9 @@
   gfx::Rect GetNoItemsIndicatorLabelBoundsForTesting() const;
 
   // Calculates |should_animate_when_entering_| and
-  // |should_animate_when_exiting_| of the overview items based on where
+  // |should_animate_when_exiting_| of the window selector items based on where
   // the first MRU window covering the available workspace is found.
-  // |selected_item| is not nullptr if |selected_item| is the selected item when
+  // |selector_item| is not nullptr if |selector_item| is the selected item when
   // exiting overview mode.
   void CalculateWindowListAnimationStates(
       OverviewItem* selected_item,
@@ -216,17 +203,14 @@
       const gfx::Rect& work_area,
       OverviewSession::UpdateAnimationSettingsCallback callback);
 
-  // Returns the window of the overview item that contains |location_in_screen|.
+  // Returns the window of the window selector item that contains
+  // |location_in_screen|.
   aura::Window* GetTargetWindowOnLocation(const gfx::Point& location_in_screen);
 
-  // Returns true when the desks bar view is showing desks mini views (or will
-  // show them once it is created).
-  bool IsDesksBarViewActive() const;
-
   // Returns true if the grid has no more windows.
   bool empty() const { return window_list_.empty(); }
 
-  // Returns how many overview items are in the grid.
+  // Returns how many window selector items are in the grid.
   size_t size() const { return window_list_.size(); }
 
   // Returns true if the selection widget is active.
@@ -253,10 +237,6 @@
     return drop_target_widget_.get();
   }
 
-  void set_suspend_reposition(bool value) { suspend_reposition_ = value; }
-
-  const DesksBarView* GetDesksBarViewForTesting() const;
-
  private:
   class ShieldView;
   class TargetWindowObserver;
@@ -265,8 +245,8 @@
   // Struct which holds data required to perform nudges.
   struct NudgeData {
     size_t index;
-    gfx::RectF src;
-    gfx::RectF dst;
+    gfx::Rect src;
+    gfx::Rect dst;
   };
 
   // Initializes the screen shield widget.
@@ -284,7 +264,7 @@
   // Moves the selection widget to the targeted window.
   void MoveSelectionWidgetToTarget(bool animate);
 
-  // Gets the layout of the overview items. Layout is done in 2 stages
+  // Gets the layout of the window selector items. Layout is done in 2 stages
   // maintaining fixed MRU ordering.
   // 1. Optimal height is determined. In this stage |height| is bisected to find
   //    maximum height which still allows all the windows to fit.
@@ -294,7 +274,7 @@
   // Overall this achieves the goals of maximum size for previews (or maximum
   // row height which is equivalent assuming fixed height), balanced rows and
   // minimal wasted space.
-  std::vector<gfx::RectF> GetWindowRects(OverviewItem* ignored_item);
+  std::vector<gfx::Rect> GetWindowRects(OverviewItem* ignored_item);
 
   // Attempts to fit all |out_rects| inside |bounds|. The method ensures that
   // the |out_rects| vector has appropriate size and populates it with the
@@ -309,21 +289,21 @@
   bool FitWindowRectsInBounds(const gfx::Rect& bounds,
                               int height,
                               OverviewItem* ignored_item,
-                              std::vector<gfx::RectF>* out_rects,
+                              std::vector<gfx::Rect>* out_rects,
                               int* out_max_bottom,
                               int* out_min_right,
                               int* out_max_right);
 
-  // Calculates |overview_item|'s |should_animate_when_entering_|,
-  // |should_animate_when_exiting_|. |selected| is true if |overview_item| is
+  // Calculates |selector_item|'s |should_animate_when_entering_|,
+  // |should_animate_when_exiting_|. |selected| is true if if |selector_item| is
   // the selected item when exiting overview mode.
   void CalculateOverviewItemAnimationState(
-      OverviewItem* overview_item,
+      OverviewItem* selector_item,
       bool* has_fullscreen_coverred,
       bool selected,
       OverviewSession::OverviewTransition transition);
 
-  // Returns the overview item iterator that contains |window|.
+  // Returns the window selector item iterator that contains |window|.
   std::vector<std::unique_ptr<OverviewItem>>::iterator
   GetOverviewItemIterContainingWindow(aura::Window* window);
 
@@ -334,7 +314,7 @@
   // Root window the grid is in.
   aura::Window* root_window_;
 
-  // Pointer to the OverviewSession that spawned this grid.
+  // Pointer to the window selector that spawned this grid.
   OverviewSession* overview_session_;
 
   // Vector containing all the windows in this grid.
@@ -391,13 +371,6 @@
   // non-empty if a nudge is in progress.
   std::vector<NudgeData> nudge_data_;
 
-  // Measures the animation smoothness of overview animation.
-  std::unique_ptr<FpsCounter> fps_counter_;
-
-  // True to skip |PositionWindows()|. Used to avoid O(n^2) layout
-  // when reposition windows in tablet overview mode.
-  bool suspend_reposition_ = false;
-
   DISALLOW_COPY_AND_ASSIGN(OverviewGrid);
 };
 
--- a/ash/wm/overview/overview_item.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/overview/overview_item.cc	2019-05-17 18:53:08.368000000 +0300
@@ -52,6 +52,10 @@
 
 constexpr int kShadowElevation = 16;
 
+// Values of the backdrop.
+constexpr int kBackdropRoundingDp = 4;
+constexpr SkColor kBackdropColor = SkColorSetARGB(0x24, 0xFF, 0xFF, 0xFF);
+
 // The amount of translation an item animates by when it is closed by using
 // swipe to close.
 constexpr int kSwipeToCloseCloseTranslationDp = 96;
@@ -60,43 +64,17 @@
 // |kPreDragScale| to indicate its selection.
 constexpr float kDragWindowScale = 0.04f;
 
-}  // namespace
-
-// The class to cache render surface to the specified window's layer.
-class OverviewItem::WindowSurfaceCacheObserver : public aura::WindowObserver {
- public:
-  explicit WindowSurfaceCacheObserver(aura::Window* window) {
-    StartObserving(window);
-  }
-
-  ~WindowSurfaceCacheObserver() override { StopObserving(); }
-
-  void StartObserving(aura::Window* window) {
-    // If we're already observing a window, stop observing it first.
-    StopObserving();
-
-    window_ = window;
-    window_->AddObserver(this);
-    for (auto* window : wm::GetTransientTreeIterator(window_))
-      window->layer()->AddCacheRenderSurfaceRequest();
-  }
-
-  // aura::WindowObserver:
-  void OnWindowDestroying(aura::Window* window) override { StopObserving(); }
-
- private:
-  void StopObserving() {
-    if (window_) {
-      for (auto* window : wm::GetTransientTreeIterator(window_))
-        window->layer()->RemoveCacheRenderSurfaceRequest();
-      window_->RemoveObserver(this);
-      window_ = nullptr;
-    }
-  }
+std::unique_ptr<views::Widget> CreateBackdropWidget(aura::Window* parent) {
+  auto widget = CreateBackgroundWidget(
+      /*root_window=*/nullptr, ui::LAYER_TEXTURED, kBackdropColor,
+      /*border_thickness=*/0, kBackdropRoundingDp, kBackdropColor,
+      /*initial_opacity=*/1.f, parent,
+      /*stack_on_top=*/false);
+  widget->GetNativeWindow()->SetName("OverviewBackdrop");
+  return widget;
+}
 
-  aura::Window* window_ = nullptr;
-  DISALLOW_COPY_AND_ASSIGN(WindowSurfaceCacheObserver);
-};
+}  // namespace
 
 OverviewItem::OverviewItem(aura::Window* window,
                            OverviewSession* overview_session,
@@ -136,7 +114,9 @@
 void OverviewItem::RestoreWindow(bool reset_transform) {
   caption_container_view_->ResetListener();
   transform_window_.RestoreWindow(
-      reset_transform, overview_session_->enter_exit_overview_type());
+      reset_transform,
+      overview_session_->enter_exit_overview_type() ==
+          OverviewSession::EnterExitOverviewType::kWindowsMinimized);
 }
 
 void OverviewItem::EnsureVisible() {
@@ -144,6 +124,23 @@
 }
 
 void OverviewItem::Shutdown() {
+  if (transform_window_.GetTopInset()) {
+    // Activating a window (even when it is the window that was active before
+    // overview) results in stacking it at the top. Maintain the label window
+    // stacking position above the item to make the header transformation more
+    // gradual upon exiting the overview mode.
+    aura::Window* widget_window = item_widget_->GetNativeWindow();
+
+    // |widget_window| was originally created in the same container as the
+    // |transform_window_| but when closing overview the |transform_window_|
+    // could have been reparented if a drag was active. Only change stacking
+    // if the windows still belong to the same container.
+    if (widget_window->parent() == transform_window_.window()->parent()) {
+      widget_window->parent()->StackChildAbove(widget_window,
+                                               transform_window_.window());
+    }
+  }
+
   // On swiping from the shelf, the caller handles the animation via calls to
   // UpdateYAndOpacity, so do not additional fade out or slide animation to the
   // window.
@@ -159,29 +156,24 @@
 
 void OverviewItem::PrepareForOverview() {
   transform_window_.PrepareForOverview();
-  aura::Window* widget_window = item_widget_->GetNativeWindow();
-  widget_window->parent()->StackChildBelow(widget_window,
-                                           GetWindowForStacking());
+  RestackItemWidget();
 }
 
 void OverviewItem::SlideWindowIn() {
   // |transform_window_|'s |minimized_widget| is non null because this only gets
   // called if we see the home launcher on enter (all windows are minimized).
   DCHECK(transform_window_.minimized_widget());
-  // The |item_widget_| and mask and shadow will be shown when animation ends.
-  // Update the mask after starting the animation since starting the animation
-  // lets the controller know we are in starting animation.
+  // The |item_widget_| will be shown when animation ends.
   FadeInWidgetAndMaybeSlideOnEnter(transform_window_.minimized_widget(),
                                    OVERVIEW_ANIMATION_ENTER_FROM_HOME_LAUNCHER,
                                    /*slide=*/true);
-  UpdateMaskAndShadow();
 }
 
 void OverviewItem::UpdateYPositionAndOpacity(
     int new_grid_y,
     float opacity,
     OverviewSession::UpdateAnimationSettingsCallback callback) {
-  // Animate |item_widget_| and the window itself.
+  // Animate the window selector widget and the window itself.
   // TODO(sammiequon): Investigate if we can combine with
   // FadeInWidgetAndMaybeSlideOnEnter. Also when animating we should remove
   // shadow and rounded corners.
@@ -226,21 +218,21 @@
 }
 
 float OverviewItem::GetItemScale(const gfx::Size& size) {
-  gfx::SizeF inset_size(size.width(), size.height() - 2 * kWindowMargin);
+  gfx::Size inset_size(size.width(), size.height() - 2 * kWindowMargin);
   return ScopedOverviewTransformWindow::GetItemScale(
       GetTargetBoundsInScreen().size(), inset_size,
       transform_window_.GetTopInset(), kHeaderHeightDp);
 }
 
-gfx::RectF OverviewItem::GetTargetBoundsInScreen() const {
+gfx::Rect OverviewItem::GetTargetBoundsInScreen() const {
   return ::ash::GetTargetBoundsInScreen(transform_window_.GetOverviewWindow());
 }
 
-gfx::RectF OverviewItem::GetTransformedBounds() const {
+gfx::Rect OverviewItem::GetTransformedBounds() const {
   return transform_window_.GetTransformedBounds();
 }
 
-void OverviewItem::SetBounds(const gfx::RectF& target_bounds,
+void OverviewItem::SetBounds(const gfx::Rect& target_bounds,
                              OverviewAnimationType animation_type) {
   if (in_bounds_update_)
     return;
@@ -259,7 +251,7 @@
   const bool is_first_update = target_bounds_.IsEmpty();
   target_bounds_ = target_bounds;
 
-  gfx::RectF inset_bounds(target_bounds);
+  gfx::Rect inset_bounds(target_bounds);
   inset_bounds.Inset(kWindowMargin, kWindowMargin);
 
   // Do not animate if entering when the window is minimized, as it will be
@@ -278,8 +270,14 @@
   // animations, manually set the shadow. Shadow relies on both the window
   // transform and |item_widget_|'s new bounds so set it after SetItemBounds
   // and UpdateHeaderLayout. Do not apply the shadow for drop target.
-  if (new_animation_type == OVERVIEW_ANIMATION_NONE)
-    UpdateMaskAndShadow();
+  if (new_animation_type == OVERVIEW_ANIMATION_NONE) {
+    SetShadowBounds(
+        overview_grid_->IsDropTargetWindow(GetWindow())
+            ? base::nullopt
+            : base::make_optional(transform_window_.GetTransformedBounds()));
+  }
+
+  UpdateBackdropBounds();
 }
 
 void OverviewItem::SendAccessibleSelectionEvent() {
@@ -301,7 +299,7 @@
   auto animate_window = [this](aura::Window* window,
                                const gfx::Transform& transform, bool observe) {
     ScopedOverviewAnimationSettings settings(
-        OVERVIEW_ANIMATION_CLOSE_OVERVIEW_ITEM, window);
+        OVERVIEW_ANIMATION_CLOSE_SELECTOR_ITEM, window);
     gfx::Transform original_transform = window->transform();
     original_transform.ConcatTransform(transform);
     window->SetTransform(original_transform);
@@ -309,30 +307,28 @@
       settings.AddObserver(this);
   };
 
-  AnimateOpacity(0.0, OVERVIEW_ANIMATION_CLOSE_OVERVIEW_ITEM);
+  AnimateOpacity(0.0, OVERVIEW_ANIMATION_CLOSE_SELECTOR_ITEM);
   animate_window(item_widget_->GetNativeWindow(), transform, false);
   animate_window(GetWindowForStacking(), transform, true);
 }
 
 void OverviewItem::CloseWindow() {
-  gfx::RectF inset_bounds(target_bounds_);
+  gfx::Rect inset_bounds(target_bounds_);
   inset_bounds.Inset(target_bounds_.width() * kPreCloseScale,
                      target_bounds_.height() * kPreCloseScale);
   // Scale down both the window and label.
-  SetBounds(inset_bounds, OVERVIEW_ANIMATION_CLOSING_OVERVIEW_ITEM);
+  SetBounds(inset_bounds, OVERVIEW_ANIMATION_CLOSING_SELECTOR_ITEM);
   // First animate opacity to an intermediate value concurrently with the
   // scaling animation.
-  AnimateOpacity(kClosingItemOpacity, OVERVIEW_ANIMATION_CLOSING_OVERVIEW_ITEM);
+  AnimateOpacity(kClosingItemOpacity, OVERVIEW_ANIMATION_CLOSING_SELECTOR_ITEM);
 
   // Fade out the window and the label, effectively hiding them.
-  AnimateOpacity(0.0, OVERVIEW_ANIMATION_CLOSE_OVERVIEW_ITEM);
+  AnimateOpacity(0.0, OVERVIEW_ANIMATION_CLOSE_SELECTOR_ITEM);
   transform_window_.Close();
 }
 
 void OverviewItem::OnMinimizedStateChanged() {
   transform_window_.UpdateMirrorWindowForMinimizedState();
-  if (window_surface_cache_observers_)
-    window_surface_cache_observers_->StartObserving(GetWindowForStacking());
 }
 
 void OverviewItem::UpdateCannotSnapWarningVisibility() {
@@ -352,33 +348,15 @@
 }
 
 void OverviewItem::OnSelectorItemDragStarted(OverviewItem* item) {
-  is_being_dragged_ = (item == this);
-  // Disable mask and shadow for the dragged overview item during dragging.
-  if (is_being_dragged_)
-    UpdateMaskAndShadow();
-
   caption_container_view_->SetHeaderVisibility(
-      is_being_dragged_
+      item == this
           ? CaptionContainerView::HeaderVisibility::kInvisible
           : CaptionContainerView::HeaderVisibility::kCloseButtonInvisibleOnly);
-
-  // Start caching render surface during overview window dragging.
-  window_surface_cache_observers_ =
-      std::make_unique<WindowSurfaceCacheObserver>(GetWindowForStacking());
 }
 
 void OverviewItem::OnSelectorItemDragEnded() {
-  // Re-show mask and shadow for the dragged overview item after drag ends.
-  if (is_being_dragged_) {
-    is_being_dragged_ = false;
-    UpdateMaskAndShadow();
-  }
-
   caption_container_view_->SetHeaderVisibility(
       CaptionContainerView::HeaderVisibility::kVisible);
-
-  // Stop caching render surface after overview window dragging.
-  window_surface_cache_observers_.reset();
 }
 
 ScopedOverviewTransformWindow::GridWindowFillMode
@@ -387,29 +365,72 @@
 }
 
 void OverviewItem::UpdateWindowDimensionsType() {
+  // TODO(oshima|sammiequan|xdai): Use EnableBackdropIfNeeded.
   transform_window_.UpdateWindowDimensionsType();
-  const bool show_backdrop =
-      GetWindowDimensionsType() !=
-      ScopedOverviewTransformWindow::GridWindowFillMode::kNormal;
-  caption_container_view_->SetBackdropVisibility(show_backdrop);
+  if (GetWindowDimensionsType() ==
+      ScopedOverviewTransformWindow::GridWindowFillMode::kNormal) {
+    // Delete the backdrop widget, if it exists for normal windows.
+    if (backdrop_widget_)
+      backdrop_widget_.reset();
+  } else {
+    // Create the backdrop widget if needed.
+    if (!backdrop_widget_) {
+      backdrop_widget_ =
+          CreateBackdropWidget(transform_window_.window()->parent());
+    }
+  }
+}
+
+void OverviewItem::EnableBackdropIfNeeded() {
+  if (GetWindowDimensionsType() ==
+      ScopedOverviewTransformWindow::GridWindowFillMode::kNormal) {
+    DisableBackdrop();
+    return;
+  }
+  if (!backdrop_widget_) {
+    backdrop_widget_ =
+        CreateBackdropWidget(transform_window_.window()->parent());
+  }
+  UpdateBackdropBounds();
+}
+
+void OverviewItem::DisableBackdrop() {
+  if (backdrop_widget_)
+    backdrop_widget_->Hide();
+}
+
+void OverviewItem::UpdateBackdropBounds() {
+  if (!backdrop_widget_)
+    return;
+
+  gfx::Rect backdrop_bounds = caption_container_view_->backdrop_bounds();
+  ::wm::ConvertRectToScreen(item_widget_->GetNativeWindow(), &backdrop_bounds);
+  backdrop_widget_->SetBounds(backdrop_bounds);
+  backdrop_widget_->Show();
 }
 
 gfx::Rect OverviewItem::GetBoundsOfSelectedItem() {
-  gfx::RectF original_bounds = target_bounds();
+  gfx::Rect original_bounds = target_bounds();
   ScaleUpSelectedItem(OVERVIEW_ANIMATION_NONE);
-  gfx::RectF selected_bounds = transform_window_.GetTransformedBounds();
+  gfx::Rect selected_bounds = transform_window_.GetTransformedBounds();
   SetBounds(original_bounds, OVERVIEW_ANIMATION_NONE);
-  return gfx::ToEnclosedRect(selected_bounds);
+  return selected_bounds;
 }
 
 void OverviewItem::ScaleUpSelectedItem(OverviewAnimationType animation_type) {
-  gfx::RectF scaled_bounds = target_bounds();
+  gfx::Rect scaled_bounds(target_bounds());
   scaled_bounds.Inset(-scaled_bounds.width() * kDragWindowScale,
                       -scaled_bounds.height() * kDragWindowScale);
   SetBounds(scaled_bounds, animation_type);
 }
 
-void OverviewItem::HandlePressEvent(const gfx::PointF& location_in_screen) {
+void OverviewItem::RestackItemWidget() {
+  aura::Window* widget_window = item_widget_->GetNativeWindow();
+  widget_window->parent()->StackChildAbove(widget_window,
+                                           GetWindowForStacking());
+}
+
+void OverviewItem::HandlePressEvent(const gfx::Point& location_in_screen) {
   // We allow switching finger while dragging, but do not allow dragging two or
   // more items.
   if (overview_session_->window_drag_controller() &&
@@ -421,29 +442,28 @@
   overview_session_->InitiateDrag(this, location_in_screen);
 }
 
-void OverviewItem::HandleReleaseEvent(const gfx::PointF& location_in_screen) {
+void OverviewItem::HandleReleaseEvent(const gfx::Point& location_in_screen) {
   if (!IsDragItem())
     return;
-
   overview_grid_->SetSelectionWidgetVisibility(true);
   overview_session_->CompleteDrag(this, location_in_screen);
 }
 
-void OverviewItem::HandleDragEvent(const gfx::PointF& location_in_screen) {
+void OverviewItem::HandleDragEvent(const gfx::Point& location_in_screen) {
   if (!IsDragItem())
     return;
 
   overview_session_->Drag(this, location_in_screen);
 }
 
-void OverviewItem::HandleLongPressEvent(const gfx::PointF& location_in_screen) {
+void OverviewItem::HandleLongPressEvent(const gfx::Point& location_in_screen) {
   if (!ShouldAllowSplitView())
     return;
 
   overview_session_->StartSplitViewDragMode(location_in_screen);
 }
 
-void OverviewItem::HandleFlingStartEvent(const gfx::PointF& location_in_screen,
+void OverviewItem::HandleFlingStartEvent(const gfx::Point& location_in_screen,
                                          float velocity_x,
                                          float velocity_y) {
   overview_session_->Fling(this, location_in_screen, velocity_x, velocity_y);
@@ -488,27 +508,27 @@
         Shell::Get()->split_view_controller()->GetDefaultSnappedWindow();
     if (snapped_window->parent() == parent_window &&
         dragged_window->parent() == parent_window) {
-      parent_window->StackChildBelow(dragged_window, snapped_window);
-      parent_window->StackChildBelow(dragged_widget_window, dragged_window);
+      parent_window->StackChildBelow(dragged_widget_window, snapped_window);
+      parent_window->StackChildBelow(dragged_window, dragged_widget_window);
     }
   }
 
-  // Then find the window which was stacked right above this overview item's
-  // window before dragging and stack this overview item's window below it.
-  const std::vector<std::unique_ptr<OverviewItem>>& overview_items =
+  // Then find the window which was stacked right above this selector item's
+  // window before dragging and stack this selector item's window below it.
+  const std::vector<std::unique_ptr<OverviewItem>>& selector_items =
       overview_grid_->window_list();
   aura::Window* stacking_target = nullptr;
-  for (size_t index = 0; index < overview_items.size(); index++) {
+  for (size_t index = 0; index < selector_items.size(); index++) {
     if (index > 0) {
-      aura::Window* window = overview_items[index - 1].get()->GetWindow();
+      aura::Window* window = selector_items[index - 1].get()->GetWindow();
       if (window->parent() == parent_window &&
           dragged_window->parent() == parent_window) {
         stacking_target = window;
       }
     }
-    if (overview_items[index].get() == this && stacking_target) {
-      parent_window->StackChildBelow(dragged_window, stacking_target);
-      parent_window->StackChildBelow(dragged_widget_window, dragged_window);
+    if (selector_items[index].get() == this && stacking_target) {
+      parent_window->StackChildBelow(dragged_widget_window, stacking_target);
+      parent_window->StackChildBelow(dragged_window, dragged_widget_window);
       break;
     }
   }
@@ -537,40 +557,18 @@
   shadow_->SetContentBounds(bounds_in_item);
 }
 
-void OverviewItem::UpdateMaskAndShadow() {
-  // Do not show mask and shadow if:
-  // 1) overview is shutting down or
-  // 2) this overview item is in an overview grid that contains more than 10
-  //    windows. In this case don't apply rounded corner mask because it can
-  //    push the compositor memory usage to the limit. TODO(oshima): Remove
-  //    this once new rounded corner impl is available. (crbug.com/903486)
-  // 3) we're currently in entering overview animation or
-  // 4) this overview item is being dragged or
-  // 5) this overview item is the drop target window or
-  // 6) this overview item is in animation.
-  bool should_show = true;
-  OverviewController* overview_controller = Shell::Get()->overview_controller();
-  if (disable_mask_ || !overview_controller ||
-      !overview_controller->IsSelecting() ||
-      overview_grid_->window_list().size() > 10 ||
-      overview_controller->IsInStartAnimation() || is_being_dragged_ ||
-      overview_grid_->IsDropTargetWindow(GetWindow()) ||
-      transform_window_.GetOverviewWindow()
-          ->layer()
-          ->GetAnimator()
-          ->is_animating()) {
-    should_show = false;
-  }
+void OverviewItem::UpdateMaskAndShadow(bool show) {
+  transform_window_.UpdateMask(show);
 
-  if (!should_show) {
-    transform_window_.UpdateMask(false);
+  // Do not apply the shadow for the drop target in overview.
+  if (!show || overview_grid_->IsDropTargetWindow(GetWindow())) {
     SetShadowBounds(base::nullopt);
+    DisableBackdrop();
     return;
   }
 
-  transform_window_.UpdateMask(true);
-  SetShadowBounds(
-      gfx::ToEnclosedRect(transform_window_.GetTransformedBounds()));
+  SetShadowBounds(transform_window_.GetTransformedBounds());
+  EnableBackdropIfNeeded();
 }
 
 void OverviewItem::OnStartingAnimationComplete() {
@@ -578,10 +576,7 @@
   FadeInWidgetAndMaybeSlideOnEnter(
       item_widget_.get(), OVERVIEW_ANIMATION_ENTER_OVERVIEW_MODE_FADE_IN,
       /*slide=*/false);
-  const bool show_backdrop =
-      GetWindowDimensionsType() !=
-      ScopedOverviewTransformWindow::GridWindowFillMode::kNormal;
-  caption_container_view_->SetBackdropVisibility(show_backdrop);
+  EnableBackdropIfNeeded();
 }
 
 void OverviewItem::SetOpacity(float opacity) {
@@ -595,7 +590,7 @@
 
 OverviewAnimationType OverviewItem::GetExitOverviewAnimationType() {
   return should_animate_when_exiting_
-             ? OVERVIEW_ANIMATION_LAYOUT_OVERVIEW_ITEMS_ON_EXIT
+             ? OVERVIEW_ANIMATION_LAY_OUT_SELECTOR_ITEMS_ON_EXIT
              : OVERVIEW_ANIMATION_NONE;
 }
 
@@ -640,11 +635,6 @@
 void OverviewItem::OnWindowDestroying(aura::Window* window) {
   window->RemoveObserver(this);
   transform_window_.OnWindowDestroyed();
-
-  if (is_being_dragged_) {
-    Shell::Get()->overview_controller()->UnpauseOcclusionTracker(
-        kOcclusionPauseDurationForDragMs);
-  }
 }
 
 void OverviewItem::OnWindowTitleChanged(aura::Window* window) {
@@ -672,42 +662,30 @@
   return shadow_->content_bounds();
 }
 
-void OverviewItem::SetItemBounds(const gfx::RectF& target_bounds,
+void OverviewItem::SetItemBounds(const gfx::Rect& target_bounds,
                                  OverviewAnimationType animation_type) {
   aura::Window* window = GetWindow();
   DCHECK(root_window_ == window->GetRootWindow());
-  gfx::RectF screen_rect = gfx::RectF(GetTargetBoundsInScreen());
+  gfx::Rect screen_rect = GetTargetBoundsInScreen();
 
   // Avoid division by zero by ensuring screen bounds is not empty.
-  gfx::SizeF screen_size(screen_rect.size());
-  screen_size.SetToMax(gfx::SizeF(1.f, 1.f));
+  gfx::Size screen_size(screen_rect.size());
+  screen_size.SetToMax(gfx::Size(1, 1));
   screen_rect.set_size(screen_size);
 
   const int top_view_inset = transform_window_.GetTopInset();
-  gfx::RectF overview_item_bounds =
+  gfx::Rect selector_item_bounds =
       transform_window_.ShrinkRectToFitPreservingAspectRatio(
           screen_rect, target_bounds, top_view_inset, kHeaderHeightDp);
   // Do not set transform for drop target, set bounds instead.
   if (overview_grid_->IsDropTargetWindow(window)) {
-    window->layer()->SetBounds(gfx::ToEnclosedRect(overview_item_bounds));
+    window->layer()->SetBounds(selector_item_bounds);
     transform_window_.GetOverviewWindow()->SetTransform(gfx::Transform());
     return;
   }
 
-  // Stop the current fade in animation if we shouldn't be animating.
-  if (wm::GetWindowState(window)->IsMinimized() &&
-      animation_type == OVERVIEW_ANIMATION_NONE) {
-    views::Widget* minimized_widget = transform_window_.minimized_widget();
-    if (minimized_widget) {
-      minimized_widget->GetNativeWindow()
-          ->layer()
-          ->GetAnimator()
-          ->StopAnimating();
-    }
-  }
-
   gfx::Transform transform = ScopedOverviewTransformWindow::GetTransformForRect(
-      screen_rect, overview_item_bounds);
+      screen_rect, selector_item_bounds);
   ScopedOverviewTransformWindow::ScopedAnimationSettings animation_settings;
   transform_window_.BeginScopedAnimation(animation_type, &animation_settings);
   SetTransform(transform_window_.GetOverviewWindow(), transform);
@@ -730,7 +708,8 @@
   item_widget_->set_focus_on_creation(false);
   item_widget_->Init(params_label);
   aura::Window* widget_window = item_widget_->GetNativeWindow();
-  widget_window->parent()->StackChildBelow(widget_window,
+  // Stack the widget above the transform window so that it can block events.
+  widget_window->parent()->StackChildAbove(widget_window,
                                            transform_window_.window());
 
   shadow_ = std::make_unique<ui::Shadow>();
@@ -746,10 +725,10 @@
 }
 
 void OverviewItem::UpdateHeaderLayout(OverviewAnimationType animation_type) {
-  gfx::RectF transformed_window_bounds =
+  gfx::Rect transformed_window_bounds =
       transform_window_.overview_bounds().value_or(
           transform_window_.GetTransformedBounds());
-  ::wm::TranslateRectFromScreen(root_window_, &transformed_window_bounds);
+  ::wm::ConvertRectFromScreen(root_window_, &transformed_window_bounds);
 
   gfx::Rect label_rect(kHeaderHeightDp, kHeaderHeightDp);
   label_rect.set_width(transformed_window_bounds.width());
@@ -763,7 +742,7 @@
 
   // Create a start animation observer if this is an enter overview layout
   // animation.
-  if (animation_type == OVERVIEW_ANIMATION_LAYOUT_OVERVIEW_ITEMS_ON_ENTER) {
+  if (animation_type == OVERVIEW_ANIMATION_LAY_OUT_SELECTOR_ITEMS_ON_ENTER) {
     auto start_observer = std::make_unique<StartAnimationObserver>();
     animation_settings.AddObserver(start_observer.get());
     Shell::Get()->overview_controller()->AddStartAnimationObserver(
@@ -777,8 +756,8 @@
   label_rect.Inset(-kOverviewMargin, -kOverviewMargin);
   widget_window->SetBounds(label_rect);
   gfx::Transform label_transform;
-  label_transform.Translate(gfx::ToRoundedInt(transformed_window_bounds.x()),
-                            gfx::ToRoundedInt(transformed_window_bounds.y()));
+  label_transform.Translate(transformed_window_bounds.x(),
+                            transformed_window_bounds.y());
   widget_window->SetTransform(label_transform);
 }
 
@@ -797,6 +776,10 @@
   widget_window->layer()->SetOpacity(header_opacity);
 }
 
+aura::Window* OverviewItem::GetOverviewWindowForMinimizedStateForTest() {
+  return transform_window_.GetOverviewWindowForMinimizedState();
+}
+
 void OverviewItem::StartDrag() {
   overview_grid_->SetSelectionWidgetVisibility(false);
 
@@ -811,8 +794,8 @@
   if (widget_window && widget_window->parent() == window->parent()) {
     // TODO(xdai): This might not work if there is an always on top window.
     // See crbug.com/733760.
-    widget_window->parent()->StackChildAtTop(window);
-    widget_window->parent()->StackChildBelow(widget_window, window);
+    widget_window->parent()->StackChildAtTop(widget_window);
+    widget_window->parent()->StackChildBelow(window, widget_window);
   }
 }
 
--- a/ash/wm/overview/overview_item.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/overview/overview_item.h	2019-05-17 18:53:08.368000000 +0300
@@ -14,7 +14,6 @@
 #include "ui/aura/window_observer.h"
 #include "ui/compositor/layer_animation_observer.h"
 #include "ui/gfx/geometry/rect.h"
-#include "ui/gfx/geometry/rect_f.h"
 #include "ui/views/controls/button/button.h"
 
 namespace ui {
@@ -82,15 +81,15 @@
   // Returns the union of the original target bounds of all transformed windows
   // managed by |this| item, i.e. all regular (normal or panel transient
   // descendants of the window returned by GetWindow()).
-  gfx::RectF GetTargetBoundsInScreen() const;
+  gfx::Rect GetTargetBoundsInScreen() const;
 
   // Returns the transformed bound of |transform_window_|.
-  gfx::RectF GetTransformedBounds() const;
+  gfx::Rect GetTransformedBounds() const;
 
-  // Sets the bounds of this overview item to |target_bounds| in the
+  // Sets the bounds of this window selector item to |target_bounds| in the
   // |root_window_| root window. The bounds change will be animated as specified
   // by |animation_type|.
-  void SetBounds(const gfx::RectF& target_bounds,
+  void SetBounds(const gfx::Rect& target_bounds,
                  OverviewAnimationType animation_type);
 
   // Activates or deactivates selection depending on |selected|.
@@ -129,6 +128,12 @@
   // |window_|'s bounds change.
   void UpdateWindowDimensionsType();
 
+  // Enable or disable the backdrop. If the window is not letter or pillar
+  // boxed, nothing will happen.
+  void EnableBackdropIfNeeded();
+  void DisableBackdrop();
+  void UpdateBackdropBounds();
+
   // TODO(minch): Do not actually scale up the item to get the bounds.
   // http://crbug.com/876567.
   // Returns the bounds of the selected item, which will be scaled up a little
@@ -139,7 +144,13 @@
   // Increases the bounds of the dragged item.
   void ScaleUpSelectedItem(OverviewAnimationType animation_type);
 
-  const gfx::RectF& target_bounds() const { return target_bounds_; }
+  const gfx::Rect& target_bounds() const { return target_bounds_; }
+
+  // Stacks the |item_widget_| in the correct place. |item_widget_| may be
+  // initially stacked in the wrong place due to animation or if it is a
+  // minimized window, the overview minimized widget is not available on
+  // |item_widget_|'s creation.
+  void RestackItemWidget();
 
   // Shift the window item up and then animates it to its original spot. Used
   // to transition from the home launcher.
@@ -157,11 +168,11 @@
   void UpdateItemContentViewForMinimizedWindow();
 
   // Handle the mouse/gesture event and facilitate dragging the item.
-  void HandlePressEvent(const gfx::PointF& location_in_screen);
-  void HandleReleaseEvent(const gfx::PointF& location_in_screen);
-  void HandleDragEvent(const gfx::PointF& location_in_screen);
-  void HandleLongPressEvent(const gfx::PointF& location_in_screen);
-  void HandleFlingStartEvent(const gfx::PointF& location_in_screen,
+  void HandlePressEvent(const gfx::Point& location_in_screen);
+  void HandleReleaseEvent(const gfx::Point& location_in_screen);
+  void HandleDragEvent(const gfx::Point& location_in_screen);
+  void HandleLongPressEvent(const gfx::Point& location_in_screen);
+  void HandleFlingStartEvent(const gfx::Point& location_in_screen,
                              float velocity_x,
                              float velocity_y);
   void ActivateDraggedWindow();
@@ -180,8 +191,8 @@
   // the shadow is hidden.
   void SetShadowBounds(base::Optional<gfx::Rect> bounds_in_screen);
 
-  // Updates the mask and shadow on this overview window item.
-  void UpdateMaskAndShadow();
+  // Show or hide the mask and shadow on this window item.
+  void UpdateMaskAndShadow(bool show);
 
   // Called when the starting animation is completed, or called immediately
   // if there was no starting animation.
@@ -231,21 +242,19 @@
   bool animating_to_close() const { return animating_to_close_; }
   void set_animating_to_close(bool val) { animating_to_close_ = val; }
 
-  void set_disable_mask(bool disable) { disable_mask_ = disable; }
-
   float GetCloseButtonVisibilityForTesting() const;
   float GetTitlebarOpacityForTesting() const;
   gfx::Rect GetShadowBoundsForTesting();
 
  private:
   friend class OverviewSessionTest;
-  class WindowSurfaceCacheObserver;
   FRIEND_TEST_ALL_PREFIXES(SplitViewOverviewSessionTest,
                            OverviewUnsnappableIndicatorVisibility);
 
-  // Sets the bounds of this overview item to |target_bounds| in |root_window_|.
-  // The bounds change will be animated as specified by |animation_type|.
-  void SetItemBounds(const gfx::RectF& target_bounds,
+  // Sets the bounds of this selector's items to |target_bounds| in
+  // |root_window_|. The bounds change will be animated as specified
+  // by |animation_type|.
+  void SetItemBounds(const gfx::Rect& target_bounds,
                      OverviewAnimationType animation_type);
 
   // Creates the window label.
@@ -262,6 +271,8 @@
   // Allows a test to directly set animation state.
   gfx::SlideAnimation* GetBackgroundViewAnimation();
 
+  aura::Window* GetOverviewWindowForMinimizedStateForTest();
+
   // Called before dragging. Scales up the window a little bit to indicate its
   // selection and stacks the window at the top of the Z order in order to keep
   // it visible while dragging around.
@@ -273,8 +284,8 @@
   // The contained Window's wrapper.
   ScopedOverviewTransformWindow transform_window_;
 
-  // The target bounds this overview item is fit within.
-  gfx::RectF target_bounds_;
+  // The target bounds this selector item is fit within.
+  gfx::Rect target_bounds_;
 
   // True if running SetItemBounds. This prevents recursive calls resulting from
   // the bounds update when calling ::wm::RecreateWindowLayers to copy
@@ -290,6 +301,11 @@
   // NOT_DRAWN layer since most of its surface is transparent.
   std::unique_ptr<views::Widget> item_widget_;
 
+  // A widget that is available if the window is letter or pillar boxed. It is
+  // stacked below |transform_window_|'s window. This is nullptr when the window
+  // is normal boxed.
+  std::unique_ptr<views::Widget> backdrop_widget_;
+
   // Container view that owns a Button view covering the |transform_window_|.
   // That button serves as an event shield to receive all events such as clicks
   // targeting the |transform_window_| or the overview header above the window.
@@ -320,20 +336,11 @@
   // OverviewGrid::PositionWindows.
   bool animating_to_close_ = false;
 
-  // True if this overview item is currently being dragged around.
-  bool is_being_dragged_ = false;
-
-  // True to always disable mask regardless of the state.
-  bool disable_mask_ = false;
-
   // The shadow around the overview window. Shadows the original window, not
   // |item_widget_|. Done here instead of on the original window because of the
   // rounded edges mask applied on entering overview window.
   std::unique_ptr<ui::Shadow> shadow_;
 
-  // The observer to observe the window that has cached its render surface.
-  std::unique_ptr<WindowSurfaceCacheObserver> window_surface_cache_observers_;
-
   DISALLOW_COPY_AND_ASSIGN(OverviewItem);
 };
 
--- a/ash/wm/overview/overview_session.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/overview/overview_session.cc	2019-05-17 18:53:08.368000000 +0300
@@ -448,7 +448,7 @@
 }
 
 void OverviewSession::InitiateDrag(OverviewItem* item,
-                                   const gfx::PointF& location_in_screen) {
+                                   const gfx::Point& location_in_screen) {
   window_drag_controller_ =
       std::make_unique<OverviewWindowDragController>(this);
   window_drag_controller_->InitiateDrag(item, location_in_screen);
@@ -458,14 +458,14 @@
 }
 
 void OverviewSession::Drag(OverviewItem* item,
-                           const gfx::PointF& location_in_screen) {
+                           const gfx::Point& location_in_screen) {
   DCHECK(window_drag_controller_);
   DCHECK_EQ(item, window_drag_controller_->item());
   window_drag_controller_->Drag(location_in_screen);
 }
 
 void OverviewSession::CompleteDrag(OverviewItem* item,
-                                   const gfx::PointF& location_in_screen) {
+                                   const gfx::Point& location_in_screen) {
   DCHECK(window_drag_controller_);
   DCHECK_EQ(item, window_drag_controller_->item());
   window_drag_controller_->CompleteDrag(location_in_screen);
@@ -475,12 +475,12 @@
 }
 
 void OverviewSession::StartSplitViewDragMode(
-    const gfx::PointF& location_in_screen) {
+    const gfx::Point& location_in_screen) {
   window_drag_controller_->StartSplitViewDragMode(location_in_screen);
 }
 
 void OverviewSession::Fling(OverviewItem* item,
-                            const gfx::PointF& location_in_screen,
+                            const gfx::Point& location_in_screen,
                             float velocity_x,
                             float velocity_y) {
   // Its possible a fling event is not paired with a tap down event. Ignore
@@ -566,20 +566,26 @@
     grid->UpdateYPositionAndOpacity(new_y, opacity, work_area, callback);
 }
 
-void OverviewSession::UpdateMaskAndShadow() {
-  for (auto& grid : grid_list_)
+void OverviewSession::UpdateMaskAndShadow(bool show) {
+  for (auto& grid : grid_list_) {
+    // Don't apply rounded corner mask if the grid has move than 10 windows
+    // because it can push the compositor memory usage to the limit.
+    // TODO(osima): Remove this once new rounded corner impl is available.
+    // (crbug.com/903486)
+    if (show && grid->window_list().size() > 10)
+      continue;
     for (auto& window : grid->window_list())
-      window->UpdateMaskAndShadow();
+      window->UpdateMaskAndShadow(show);
+  }
 }
 
 void OverviewSession::OnStartingAnimationComplete(bool canceled) {
-  for (auto& grid : grid_list_)
-    grid->OnStartingAnimationComplete(canceled);
-
   if (!canceled) {
+    UpdateMaskAndShadow(!canceled);
     if (overview_focus_widget_)
       overview_focus_widget_->Show();
-    Shell::Get()->overview_controller()->DelayedUpdateMaskAndShadow();
+    for (auto& grid : grid_list_)
+      grid->OnStartingAnimationComplete();
   }
 }
 
@@ -640,16 +646,6 @@
   return nullptr;
 }
 
-void OverviewSession::SuspendReposition() {
-  for (auto& grid : grid_list_)
-    grid->set_suspend_reposition(true);
-}
-
-void OverviewSession::ResumeReposition() {
-  for (auto& grid : grid_list_)
-    grid->set_suspend_reposition(false);
-}
-
 void OverviewSession::OnDisplayRemoved(const display::Display& display) {
   // TODO(flackr): Keep window selection active on remaining displays.
   CancelSelection();
@@ -805,14 +801,6 @@
   PositionWindows(/*animate=*/false);
 }
 
-bool OverviewSession::IsEmpty() const {
-  for (const auto& grid : grid_list_) {
-    if (!grid->empty())
-      return false;
-  }
-  return true;
-}
-
 void OverviewSession::ResetFocusRestoreWindow(bool focus) {
   if (!restore_focus_window_)
     return;
@@ -876,4 +864,12 @@
     split_view_drag_indicators_->OnDisplayBoundsChanged();
 }
 
+bool OverviewSession::IsEmpty() {
+  for (const auto& grid : grid_list_) {
+    if (!grid->empty())
+      return false;
+  }
+  return true;
+}
+
 }  // namespace ash
--- a/ash/wm/overview/overview_session.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/overview/overview_session.h	2019-05-17 18:53:08.368000000 +0300
@@ -37,11 +37,11 @@
 
 namespace ash {
 
-class OverviewDelegate;
-class OverviewGrid;
-class OverviewItem;
 class OverviewWindowDragController;
 class SplitViewDragIndicators;
+class OverviewGrid;
+class OverviewDelegate;
+class OverviewItem;
 
 enum class IndicatorState;
 
@@ -105,7 +105,7 @@
   // Cancels window selection.
   void CancelSelection();
 
-  // Called when the last overview item from a grid is deleted.
+  // Called when the last window selector item from a grid is deleted.
   void OnGridEmpty(OverviewGrid* grid);
 
   // Moves the current selection by |increment| items. Positive values of
@@ -147,8 +147,8 @@
   // then added to the overview.
   void AddItem(aura::Window* window, bool reposition, bool animate);
 
-  // Removes the overview item from the overview grid. And if
-  // |reposition| is true, re-position all windows in the target overview grid.
+  // Removes the window selector item from the overview window grid. And if
+  // |reposition| is true, re-position all windows in the target window grid.
   // This may be called in two scenarioes: 1) when a user drags an overview item
   // to snap to one side of the screen, the item should be removed from the
   // overview grid; 2) when a window (not from overview) ends its dragging while
@@ -156,12 +156,12 @@
   // the windows in the window grid do not need to be repositioned.
   void RemoveOverviewItem(OverviewItem* item, bool reposition);
 
-  void InitiateDrag(OverviewItem* item, const gfx::PointF& location_in_screen);
-  void Drag(OverviewItem* item, const gfx::PointF& location_in_screen);
-  void CompleteDrag(OverviewItem* item, const gfx::PointF& location_in_screen);
-  void StartSplitViewDragMode(const gfx::PointF& location_in_screen);
+  void InitiateDrag(OverviewItem* item, const gfx::Point& location_in_screen);
+  void Drag(OverviewItem* item, const gfx::Point& location_in_screen);
+  void CompleteDrag(OverviewItem* item, const gfx::Point& location_in_screen);
+  void StartSplitViewDragMode(const gfx::Point& location_in_screen);
   void Fling(OverviewItem* item,
-             const gfx::PointF& location_in_screen,
+             const gfx::Point& location_in_screen,
              float velocity_x,
              float velocity_y);
   void ActivateDraggedWindow();
@@ -201,8 +201,8 @@
       const gfx::Rect& work_area,
       UpdateAnimationSettingsCallback callback);
 
-  // Updates all the overview items' mask and shadow.
-  void UpdateMaskAndShadow();
+  // Shows or hides all the window selector items' mask and shadow.
+  void UpdateMaskAndShadow(bool show);
 
   // Called when the overview mode starting animation completes.
   void OnStartingAnimationComplete(bool canceled);
@@ -221,10 +221,6 @@
   // Gets the window which keeps focus for the duration of overview mode.
   aura::Window* GetOverviewFocusWindow();
 
-  // Suspends/Resumes window re-positiong in overview.
-  void SuspendReposition();
-  void ResumeReposition();
-
   OverviewDelegate* delegate() { return delegate_; }
 
   SplitViewDragIndicators* split_view_drag_indicators() {
@@ -266,9 +262,6 @@
                                SplitViewController::State state) override;
   void OnSplitViewDividerPositionChanged() override;
 
-  // Returns true if all its window grids don't have any window item.
-  bool IsEmpty() const;
-
  private:
   friend class OverviewSessionTest;
 
@@ -286,11 +279,14 @@
   // Called when the display area for the overview window grids changed.
   void OnDisplayBoundsChanged();
 
+  // Returns true if all its window grids don't have any window item.
+  bool IsEmpty();
+
   // Tracks observed windows.
   base::flat_set<aura::Window*> observed_windows_;
 
-  // Weak pointer to the overview delegate which will be called when a selection
-  // is made.
+  // Weak pointer to the selector delegate which will be called when a
+  // selection is made.
   OverviewDelegate* delegate_;
 
   // A weak pointer to the window which was focused on beginning window
--- a/ash/wm/overview/overview_session_unittest.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/overview/overview_session_unittest.cc	2019-05-17 18:53:08.368000000 +0300
@@ -14,7 +14,6 @@
 #include "ash/display/screen_orientation_controller.h"
 #include "ash/display/screen_orientation_controller_test_api.h"
 #include "ash/drag_drop/drag_drop_controller.h"
-#include "ash/public/cpp/fps_counter.h"
 #include "ash/public/cpp/window_properties.h"
 #include "ash/screen_util.h"
 #include "ash/shelf/shelf.h"
@@ -30,13 +29,10 @@
 #include "ash/wm/overview/overview_session.h"
 #include "ash/wm/overview/overview_utils.h"
 #include "ash/wm/overview/overview_window_drag_controller.h"
-#include "ash/wm/overview/rounded_rect_view.h"
 #include "ash/wm/splitview/split_view_controller.h"
 #include "ash/wm/splitview/split_view_divider.h"
-#include "ash/wm/splitview/split_view_utils.h"
-#include "ash/wm/tablet_mode/tablet_mode_browser_window_drag_delegate.h"
+#include "ash/wm/tablet_mode/tablet_mode_app_window_drag_controller.h"
 #include "ash/wm/tablet_mode/tablet_mode_controller.h"
-#include "ash/wm/tablet_mode/tablet_mode_window_drag_controller.h"
 #include "ash/wm/window_state.h"
 #include "ash/wm/window_util.h"
 #include "ash/wm/wm_event.h"
@@ -44,7 +40,6 @@
 #include "base/run_loop.h"
 #include "base/stl_util.h"
 #include "base/strings/utf_string_conversions.h"
-#include "base/test/metrics/histogram_tester.h"
 #include "base/test/metrics/user_action_tester.h"
 #include "services/ws/public/mojom/window_tree_constants.mojom.h"
 #include "ui/aura/client/aura_constants.h"
@@ -130,25 +125,14 @@
   OverviewSessionTest() = default;
   ~OverviewSessionTest() override = default;
 
-  // AshTestBase:
   void SetUp() override {
     AshTestBase::SetUp();
-    Shell::Get()->aura_env()->set_throttle_input_on_resize_for_testing(false);
+
     shelf_view_test_api_ = std::make_unique<ShelfViewTestAPI>(
         GetPrimaryShelf()->GetShelfViewForTesting());
     shelf_view_test_api_->SetAnimationDuration(1);
     ScopedOverviewTransformWindow::SetImmediateCloseForTests();
     OverviewController::SetDoNotChangeWallpaperBlurForTests();
-    FpsCounter::SetFoceReportZeroAnimationForTest(true);
-    ash::PresentationTimeRecorder::SetReportPresentationTimeImmediatelyForTest(
-        true);
-  }
-  void TearDown() override {
-    ash::PresentationTimeRecorder::SetReportPresentationTimeImmediatelyForTest(
-        false);
-    FpsCounter::SetFoceReportZeroAnimationForTest(false);
-    trace_names_.clear();
-    AshTestBase::TearDown();
   }
 
   // Enters tablet mode. Needed by tests that test dragging and or splitview,
@@ -182,8 +166,7 @@
   aura::Window* GetOverviewWindowForMinimizedState(int index,
                                                    aura::Window* window) {
     OverviewItem* item = GetWindowItemForWindow(index, window);
-    views::Widget* widget = minimized_widget(item);
-    return widget ? widget->GetNativeWindow() : nullptr;
+    return item->GetOverviewWindowForMinimizedStateForTest();
   }
 
   gfx::Rect GetTransformedBounds(aura::Window* window) {
@@ -282,20 +265,16 @@
     return os->grid_list_[os->selected_grid_index_]->is_selecting();
   }
 
-  views::ImageButton* GetCloseButton(OverviewItem* item) {
-    return item->caption_container_view_->GetCloseButton();
+  views::ImageButton* GetCloseButton(OverviewItem* window) {
+    return window->caption_container_view_->GetCloseButton();
   }
 
-  views::Label* GetLabelView(OverviewItem* item) {
-    return item->caption_container_view_->title_label();
+  views::Label* GetLabelView(OverviewItem* window) {
+    return window->caption_container_view_->title_label();
   }
 
-  views::Label* GetCannotSnapLabelView(OverviewItem* item) {
-    return item->caption_container_view_->cannot_snap_label();
-  }
-
-  RoundedRectView* GetBackdropView(OverviewItem* item) {
-    return item->caption_container_view_->backdrop_view();
+  views::Label* GetCannotSnapLabelView(OverviewItem* window) {
+    return window->caption_container_view_->cannot_snap_label();
   }
 
   // Tests that a window is contained within a given OverviewItem, and that both
@@ -321,13 +300,6 @@
     return gfx::Rect();
   }
 
-  views::Widget* GetShieldWidget(int index) {
-    if (overview_session())
-      return overview_session()->grid_list_[index]->shield_widget();
-
-    return nullptr;
-  }
-
   views::Widget* item_widget(OverviewItem* item) {
     return item->item_widget_.get();
   }
@@ -336,25 +308,12 @@
     return item->transform_window_.minimized_widget();
   }
 
-  bool HasMaskForItem(OverviewItem* item) const {
-    return !!item->transform_window_.mask_;
+  views::Widget* backdrop_widget(OverviewItem* item) {
+    return item->backdrop_widget_.get();
   }
 
-  void CheckOverviewEnterExitHistogram(const char* trace,
-                                       std::vector<int>&& enter_counts,
-                                       std::vector<int>&& exit_counts) {
-    DCHECK(!base::ContainsValue(trace_names_, trace)) << trace;
-    trace_names_.push_back(trace);
-    {
-      SCOPED_TRACE(trace + std::string(".Enter"));
-      CheckOverviewHistogram("Ash.Overview.AnimationSmoothness.Enter",
-                             std::move(enter_counts));
-    }
-    {
-      SCOPED_TRACE(trace + std::string(".Exit"));
-      CheckOverviewHistogram("Ash.Overview.AnimationSmoothness.Exit",
-                             std::move(exit_counts));
-    }
+  bool HasMaskForItem(OverviewItem* item) const {
+    return !!item->transform_window_.mask_;
   }
 
   static void StubForTest(ExitWarningHandler* ewh) {
@@ -363,23 +322,7 @@
   static bool is_ui_shown(ExitWarningHandler* ewh) { return !!ewh->widget_; }
 
  private:
-  void CheckOverviewHistogram(const char* histogram,
-                              std::vector<int>&& counts) {
-    ASSERT_EQ(3u, counts.size());
-    // There should be no histogram for split view.
-    histograms_.ExpectTotalCount(histogram + std::string(".SplitView"), 0);
-
-    histograms_.ExpectTotalCount(histogram + std::string(".ClamshellMode"),
-                                 counts[0]);
-    histograms_.ExpectTotalCount(
-        histogram + std::string(".SingleClamshellMode"), counts[1]);
-    histograms_.ExpectTotalCount(histogram + std::string(".TabletMode"),
-                                 counts[2]);
-  }
-
   std::unique_ptr<ShelfViewTestAPI> shelf_view_test_api_;
-  std::vector<std::string> trace_names_;
-  base::HistogramTester histograms_;
 
   DISALLOW_COPY_AND_ASSIGN(OverviewSessionTest);
 };
@@ -433,14 +376,12 @@
   // Hide the cursor before entering overview to test that it will be shown.
   aura::client::GetCursorClient(root_window)->HideCursor();
 
-  CheckOverviewEnterExitHistogram("Init", {0, 0, 0}, {0, 0, 0});
   // In overview mode the windows should no longer overlap and the overview
   // focus window should be focused.
   ToggleOverview();
   EXPECT_EQ(overview_session()->GetOverviewFocusWindow(),
             wm::GetFocusedWindow());
   EXPECT_FALSE(WindowsOverlapping(window1.get(), window2.get()));
-  CheckOverviewEnterExitHistogram("Enter", {1, 0, 0}, {0, 0, 0});
 
   // Clicking window 1 should activate it.
   ClickWindow(window1.get());
@@ -450,8 +391,6 @@
 
   // Cursor should have been unlocked.
   EXPECT_FALSE(aura::client::GetCursorClient(root_window)->IsCursorLocked());
-
-  CheckOverviewEnterExitHistogram("Exit", {1, 0, 0}, {1, 0, 0});
 }
 
 // Tests activating minimized window.
@@ -806,48 +745,14 @@
 
   // Enter overview and select the fullscreen window.
   ToggleOverview();
-  CheckOverviewEnterExitHistogram("FullscreenWindowEnter1", {0, 1, 0},
-                                  {0, 0, 0});
   ClickWindow(window1.get());
   EXPECT_TRUE(wm::GetWindowState(window1.get())->IsFullscreen());
-  CheckOverviewEnterExitHistogram("FullscreenWindowExit1", {0, 1, 0},
-                                  {0, 1, 0});
 
   // Entering overview and selecting another window, the previous window remains
   // fullscreen.
   ToggleOverview();
-  CheckOverviewEnterExitHistogram("FullscreenWindowEnter2", {0, 2, 0},
-                                  {0, 1, 0});
   ClickWindow(window2.get());
   EXPECT_TRUE(wm::GetWindowState(window1.get())->IsFullscreen());
-  CheckOverviewEnterExitHistogram("FullscreenWindowExit2", {0, 2, 0},
-                                  {1, 1, 0});
-}
-
-// Tests entering overview mode with maximized window.
-TEST_F(OverviewSessionTest, MaximizedWindow) {
-  std::unique_ptr<aura::Window> window1(CreateTestWindow());
-  std::unique_ptr<aura::Window> window2(CreateTestWindow());
-  ::wm::ActivateWindow(window1.get());
-
-  const wm::WMEvent maximize_event(wm::WM_EVENT_MAXIMIZE);
-  wm::GetWindowState(window1.get())->OnWMEvent(&maximize_event);
-  EXPECT_TRUE(wm::GetWindowState(window1.get())->IsMaximized());
-
-  // Enter overview and select the fullscreen window.
-  ToggleOverview();
-  CheckOverviewEnterExitHistogram("MaximizedWindowEnter1", {0, 1, 0},
-                                  {0, 0, 0});
-  ClickWindow(window1.get());
-  EXPECT_TRUE(wm::GetWindowState(window1.get())->IsMaximized());
-  CheckOverviewEnterExitHistogram("MaximizedWindowExit1", {0, 1, 0}, {0, 1, 0});
-
-  ToggleOverview();
-  CheckOverviewEnterExitHistogram("MaximizedWindowEnter2", {0, 2, 0},
-                                  {0, 1, 0});
-  ClickWindow(window2.get());
-  EXPECT_TRUE(wm::GetWindowState(window1.get())->IsMaximized());
-  CheckOverviewEnterExitHistogram("MaximizedWindowExit2", {0, 2, 0}, {1, 1, 0});
 }
 
 // Tests that entering overview when a fullscreen window is active in maximized
@@ -875,11 +780,10 @@
   display::Screen* screen = display::Screen::GetScreen();
   EXPECT_EQ(gfx::Rect(800, 600),
             screen->GetDisplayNearestWindow(window1.get()).work_area());
+
   ToggleOverview();
   EXPECT_EQ(fullscreen,
             screen->GetDisplayNearestWindow(window1.get()).work_area());
-  CheckOverviewEnterExitHistogram("FullscreenWindowTabletEnter1", {0, 0, 1},
-                                  {0, 0, 0});
 
   // Window 2 would normally resize to normal window bounds on showing the shelf
   // for overview but this is deferred until overview is exited.
@@ -891,26 +795,17 @@
   // Since the fullscreen window is still active, window2 will still have the
   // larger bounds.
   EXPECT_EQ(fullscreen_window_bounds, window2->GetTargetBounds());
-  CheckOverviewEnterExitHistogram("FullscreenWindowTabletExit1", {0, 0, 1},
-                                  {0, 0, 1});
 
   // Enter overview again and select window 2. Selecting window 2 should show
   // the shelf bringing window2 back to the normal bounds.
   ToggleOverview();
-  CheckOverviewEnterExitHistogram("FullscreenWindowTabletEnter2", {0, 0, 2},
-                                  {0, 0, 1});
-
   ClickWindow(window2.get());
   // Selecting non fullscreen window should set the work area back to normal.
   EXPECT_EQ(normal_work_area,
             screen->GetDisplayNearestWindow(window1.get()).work_area());
   EXPECT_EQ(normal_window_bounds, window2->GetTargetBounds());
-  CheckOverviewEnterExitHistogram("FullscreenWindowTabletExit2", {0, 0, 2},
-                                  {0, 0, 2});
 
   ToggleOverview();
-  CheckOverviewEnterExitHistogram("FullscreenWindowTabletEnter3", {0, 0, 3},
-                                  {0, 0, 2});
   EXPECT_EQ(normal_work_area,
             screen->GetDisplayNearestWindow(window1.get()).work_area());
   ClickWindow(window1.get());
@@ -918,8 +813,6 @@
   // well.
   EXPECT_EQ(fullscreen,
             screen->GetDisplayNearestWindow(window1.get()).work_area());
-  CheckOverviewEnterExitHistogram("FullscreenWindowTabletExit3", {0, 0, 3},
-                                  {0, 0, 3});
 }
 
 TEST_F(OverviewSessionTest, SkipOverviewWindow) {
@@ -970,19 +863,6 @@
   ToggleOverview();
 }
 
-// Tests that a change to the |kTopViewInset| window property during overview is
-// corrected for.
-TEST_F(OverviewSessionTest, TopViewInsetChangeDuringOverview) {
-  std::unique_ptr<aura::Window> window = CreateTestWindow(gfx::Rect(400, 400));
-  window->SetProperty(aura::client::kTopViewInset, 32);
-  ToggleOverview();
-  gfx::Rect overview_bounds = GetTransformedTargetBounds(window.get());
-  window->SetProperty(aura::client::kTopViewInset, 0);
-  gfx::Rect new_overview_bounds = GetTransformedTargetBounds(window.get());
-  EXPECT_NE(overview_bounds, new_overview_bounds);
-  ToggleOverview();
-}
-
 // Tests that a newly created window aborts overview.
 TEST_F(OverviewSessionTest, NewWindowCancelsOverview) {
   std::unique_ptr<aura::Window> window1(CreateTestWindow());
@@ -1275,8 +1155,7 @@
 
   // Labels are located based on target_bounds, not the actual window item
   // bounds.
-  gfx::RectF label_bounds =
-      gfx::RectF(label->GetWidget()->GetWindowBoundsInScreen());
+  gfx::Rect label_bounds = label->GetWidget()->GetWindowBoundsInScreen();
   label_bounds.Inset(kWindowMargin, kWindowMargin);
   EXPECT_EQ(label_bounds, window_item->target_bounds());
 }
@@ -2103,7 +1982,6 @@
 // Verify that the selector item can animate after the item is dragged and
 // released.
 TEST_F(OverviewSessionTest, WindowItemCanAnimateOnDragRelease) {
-  base::HistogramTester histogram_tester;
   UpdateDisplay("400x400");
   std::unique_ptr<aura::Window> window1(CreateTestWindow());
   std::unique_ptr<aura::Window> window2(CreateTestWindow());
@@ -2115,33 +1993,22 @@
   OverviewItem* item2 = GetWindowItemForWindow(0, window2.get());
   // Drag |item2| in a way so that |window2| does not get activated.
   ui::test::EventGenerator* generator = GetEventGenerator();
-  generator->MoveMouseTo(
-      gfx::ToRoundedPoint(item2->target_bounds().CenterPoint()));
+  generator->MoveMouseTo(item2->target_bounds().CenterPoint());
   generator->PressLeftButton();
   base::RunLoop().RunUntilIdle();
 
   generator->MoveMouseTo(gfx::Point(200, 200));
-  histogram_tester.ExpectTotalCount(
-      "Ash.Overview.WindowDrag.PresentationTime.TabletMode", 1);
-  histogram_tester.ExpectTotalCount(
-      "Ash.Overview.WindowDrag.PresentationTime.MaxLatency.TabletMode", 0);
-
   ui::ScopedAnimationDurationScaleMode test_duration_mode(
       ui::ScopedAnimationDurationScaleMode::NON_ZERO_DURATION);
   generator->ReleaseLeftButton();
   EXPECT_TRUE(window2->layer()->GetAnimator()->IsAnimatingProperty(
       ui::LayerAnimationElement::AnimatableProperty::TRANSFORM));
   base::RunLoop().RunUntilIdle();
-  histogram_tester.ExpectTotalCount(
-      "Ash.Overview.WindowDrag.PresentationTime.TabletMode", 1);
-  histogram_tester.ExpectTotalCount(
-      "Ash.Overview.WindowDrag.PresentationTime.MaxLatency.TabletMode", 1);
 }
 
 // Verify that the overview items titlebar and close button change visibility
 // when a item is being dragged.
 TEST_F(OverviewSessionTest, WindowItemTitleCloseVisibilityOnDrag) {
-  base::HistogramTester histogram_tester;
   UpdateDisplay("400x400");
   std::unique_ptr<aura::Window> window1(CreateTestWindow());
   std::unique_ptr<aura::Window> window2(CreateTestWindow());
@@ -2155,8 +2022,7 @@
   // opaque as its a child of the header which handles fading away the whole
   // header. All other items, |item2| should only have the close button hidden.
   ui::test::EventGenerator* generator = GetEventGenerator();
-  generator->MoveMouseTo(
-      gfx::ToRoundedPoint(item1->target_bounds().CenterPoint()));
+  generator->MoveMouseTo(item1->target_bounds().CenterPoint());
   generator->PressLeftButton();
   base::RunLoop().RunUntilIdle();
   EXPECT_EQ(0.f, item1->GetTitlebarOpacityForTesting());
@@ -2168,26 +2034,16 @@
   // within a certain threshold count as clicks). Verify the close button and
   // titlebar is visible for all items.
   generator->MoveMouseTo(gfx::Point(200, 200));
-  histogram_tester.ExpectTotalCount(
-      "Ash.Overview.WindowDrag.PresentationTime.TabletMode", 1);
-  histogram_tester.ExpectTotalCount(
-      "Ash.Overview.WindowDrag.PresentationTime.MaxLatency.TabletMode", 0);
-
   generator->ReleaseLeftButton();
   base::RunLoop().RunUntilIdle();
   EXPECT_EQ(1.f, item1->GetTitlebarOpacityForTesting());
   EXPECT_EQ(1.f, item1->GetCloseButtonVisibilityForTesting());
   EXPECT_EQ(1.f, item2->GetTitlebarOpacityForTesting());
   EXPECT_EQ(1.f, item2->GetCloseButtonVisibilityForTesting());
-  histogram_tester.ExpectTotalCount(
-      "Ash.Overview.WindowDrag.PresentationTime.TabletMode", 1);
-  histogram_tester.ExpectTotalCount(
-      "Ash.Overview.WindowDrag.PresentationTime.MaxLatency.TabletMode", 1);
 }
 
 // Tests that overview widgets are stacked in the correct order.
 TEST_F(OverviewSessionTest, OverviewWidgetStackingOrder) {
-  base::HistogramTester histogram_tester;
   // Create three windows, including one minimized.
   std::unique_ptr<aura::Window> window(CreateTestWindow());
   std::unique_ptr<aura::Window> minimized(CreateTestWindow());
@@ -2233,20 +2089,19 @@
   EXPECT_EQ(parent, widget3->GetNativeWindow()->parent());
   EXPECT_EQ(parent, min_widget2->GetNativeWindow()->parent());
 
-  // Verify that the item widget is stacked below the window if not minimized.
-  // Verify that the item widget is stacked below the minimized widget if
+  // Verify that the item widget is stacked above the window if not minimized.
+  // Verify that the item widget is stacked above the minimized widget if
   // minimized.
-  EXPECT_LT(IndexOf(widget1->GetNativeWindow(), parent),
+  EXPECT_GT(IndexOf(widget1->GetNativeWindow(), parent),
             IndexOf(window.get(), parent));
-  EXPECT_LT(IndexOf(widget2->GetNativeWindow(), parent),
+  EXPECT_GT(IndexOf(widget2->GetNativeWindow(), parent),
             IndexOf(min_widget2->GetNativeWindow(), parent));
-  EXPECT_LT(IndexOf(widget3->GetNativeWindow(), parent),
+  EXPECT_GT(IndexOf(widget3->GetNativeWindow(), parent),
             IndexOf(window3.get(), parent));
 
   // Drag the first window. Verify that it's item widget is not stacked above
   // the other two.
-  const gfx::Point start_drag =
-      gfx::ToRoundedPoint(item1->target_bounds().CenterPoint());
+  const gfx::Point start_drag = item1->target_bounds().CenterPoint();
   ui::test::EventGenerator* generator = GetEventGenerator();
   generator->MoveMouseTo(start_drag);
   generator->PressLeftButton();
@@ -2254,21 +2109,11 @@
             IndexOf(widget2->GetNativeWindow(), parent));
   EXPECT_GT(IndexOf(widget1->GetNativeWindow(), parent),
             IndexOf(widget3->GetNativeWindow(), parent));
-  histogram_tester.ExpectTotalCount(
-      "Ash.Overview.WindowDrag.PresentationTime.TabletMode", 0);
 
   // Drag to origin and then back to the start to avoid activating the window or
   // entering splitview.
   generator->MoveMouseTo(gfx::Point());
-  histogram_tester.ExpectTotalCount(
-      "Ash.Overview.WindowDrag.PresentationTime.TabletMode", 1);
-
   generator->MoveMouseTo(start_drag);
-  histogram_tester.ExpectTotalCount(
-      "Ash.Overview.WindowDrag.PresentationTime.TabletMode", 2);
-  histogram_tester.ExpectTotalCount(
-      "Ash.Overview.WindowDrag.PresentationTime.MaxLatency.TabletMode", 0);
-
   generator->ReleaseLeftButton();
 
   // Verify the stacking order is same as before dragging started.
@@ -2276,10 +2121,51 @@
             IndexOf(widget1->GetNativeWindow(), parent));
   EXPECT_GT(IndexOf(widget1->GetNativeWindow(), parent),
             IndexOf(widget2->GetNativeWindow(), parent));
-  histogram_tester.ExpectTotalCount(
-      "Ash.Overview.WindowDrag.PresentationTime.TabletMode", 2);
-  histogram_tester.ExpectTotalCount(
-      "Ash.Overview.WindowDrag.PresentationTime.MaxLatency.TabletMode", 1);
+}
+
+// Tests that overview widgets are stacked in the correct order.
+TEST_F(OverviewSessionTest, OverviewWidgetStackingOrderWithDragging) {
+  std::unique_ptr<aura::Window> window1(CreateTestWindow());
+  std::unique_ptr<aura::Window> window2(CreateTestWindow());
+  std::unique_ptr<aura::Window> window3(CreateTestWindow());
+
+  EnterTabletMode();
+  ToggleOverview();
+  OverviewItem* item1 = GetWindowItemForWindow(0, window1.get());
+  OverviewItem* item2 = GetWindowItemForWindow(0, window2.get());
+  OverviewItem* item3 = GetWindowItemForWindow(0, window3.get());
+  views::Widget* widget1 = item_widget(item1);
+  views::Widget* widget2 = item_widget(item2);
+  views::Widget* widget3 = item_widget(item3);
+
+  // Initially the highest stacked widget is the most recently used window, in
+  // this case it is the most recently created window.
+  aura::Window* parent = window1->parent();
+  EXPECT_GT(IndexOf(widget3->GetNativeWindow(), parent),
+            IndexOf(widget2->GetNativeWindow(), parent));
+  EXPECT_GT(IndexOf(widget2->GetNativeWindow(), parent),
+            IndexOf(widget1->GetNativeWindow(), parent));
+
+  // Verify that during drag the dragged item widget is stacked above the other
+  // two.
+  const gfx::Point start_drag = item1->target_bounds().CenterPoint();
+  ui::test::EventGenerator* generator = GetEventGenerator();
+  generator->MoveMouseTo(start_drag);
+  generator->PressLeftButton();
+  generator->MoveMouseTo(gfx::Point());
+  generator->MoveMouseTo(start_drag);
+  EXPECT_GT(IndexOf(widget1->GetNativeWindow(), parent),
+            IndexOf(widget3->GetNativeWindow(), parent));
+  EXPECT_GT(IndexOf(widget1->GetNativeWindow(), parent),
+            IndexOf(widget2->GetNativeWindow(), parent));
+
+  // Verify that after release the ordering is the same as before dragging.
+  generator->ReleaseLeftButton();
+  base::RunLoop().RunUntilIdle();
+  EXPECT_GT(IndexOf(widget3->GetNativeWindow(), parent),
+            IndexOf(widget2->GetNativeWindow(), parent));
+  EXPECT_GT(IndexOf(widget2->GetNativeWindow(), parent),
+            IndexOf(widget1->GetNativeWindow(), parent));
 }
 
 // Verify that a windows which enter overview mode have a visible backdrop, if
@@ -2300,13 +2186,10 @@
   OverviewItem* tall_item = GetWindowItemForWindow(0, tall.get());
   OverviewItem* normal_item = GetWindowItemForWindow(0, normal.get());
 
-  // Only very tall and very wide windows will have a backdrop. The backdrop
-  // only gets created if we need it once during the overview session.
-  ASSERT_TRUE(GetBackdropView(wide_item));
-  EXPECT_TRUE(GetBackdropView(wide_item)->visible());
-  EXPECT_TRUE(GetBackdropView(tall_item));
-  ASSERT_TRUE(GetBackdropView(tall_item)->visible());
-  EXPECT_FALSE(GetBackdropView(normal_item));
+  // Only very tall and very wide windows will have a backdrop.
+  EXPECT_TRUE(backdrop_widget(wide_item));
+  EXPECT_TRUE(backdrop_widget(tall_item));
+  EXPECT_FALSE(backdrop_widget(normal_item));
 
   display::Screen* screen = display::Screen::GetScreen();
   const display::Display& display = screen->GetPrimaryDisplay();
@@ -2314,20 +2197,18 @@
       display.id(), display::Display::ROTATE_90,
       display::Display::RotationSource::ACTIVE);
 
-  // After rotation the former wide window will be a normal window and its
-  // backdrop will still be there but invisible.
-  ASSERT_TRUE(GetBackdropView(wide_item));
-  EXPECT_FALSE(GetBackdropView(wide_item)->visible());
-  EXPECT_TRUE(GetBackdropView(tall_item));
-  ASSERT_TRUE(GetBackdropView(tall_item)->visible());
-  EXPECT_FALSE(GetBackdropView(normal_item));
+  // After rotation the former wide window will be a normal window and lose its
+  // backdrop.
+  EXPECT_FALSE(backdrop_widget(wide_item));
+  EXPECT_TRUE(backdrop_widget(tall_item));
+  EXPECT_FALSE(backdrop_widget(normal_item));
 
   // Test that leaving overview mode cleans up properly.
   ToggleOverview();
 }
 
-// Test that the mask that is applied to add rounded corners in overview mode
-// is removed during animations.
+// Verify that the mask that is applied to add rounded corners in overview mode
+// is removed during animations and drags.
 TEST_F(OverviewSessionTest, RoundedEdgeMaskVisibility) {
   std::unique_ptr<aura::Window> window1(CreateTestWindow());
   std::unique_ptr<aura::Window> window2(CreateTestWindow());
@@ -2335,85 +2216,27 @@
   ::wm::ActivateWindow(window2.get());
   ::wm::ActivateWindow(window1.get());
 
-  ui::ScopedAnimationDurationScaleMode test_duration_mode(
-      ui::ScopedAnimationDurationScaleMode::NON_ZERO_DURATION);
-
-  // Test that entering overview mode normally will disable all the masks until
-  // the animation is complete.
   EnterTabletMode();
   ToggleOverview();
+  base::RunLoop().RunUntilIdle();
   OverviewItem* item1 = GetWindowItemForWindow(0, window1.get());
   OverviewItem* item2 = GetWindowItemForWindow(0, window2.get());
-  EXPECT_FALSE(HasMaskForItem(item1));
-  EXPECT_FALSE(HasMaskForItem(item2));
-  window1->layer()->GetAnimator()->StopAnimating();
-  window2->layer()->GetAnimator()->StopAnimating();
-
-  // Mask is set asynchronously.
-  EXPECT_FALSE(HasMaskForItem(item1));
-  EXPECT_FALSE(HasMaskForItem(item2));
-  base::RunLoop().RunUntilIdle();
   EXPECT_TRUE(HasMaskForItem(item1));
   EXPECT_TRUE(HasMaskForItem(item2));
 
-  // Tests that entering overview mode with all windows minimized (launcher
-  // button pressed) will still disable all the masks until the animation is
-  // complete.
-  ToggleOverview();
-  wm::GetWindowState(window1.get())->Minimize();
-  wm::GetWindowState(window2.get())->Minimize();
-  ToggleOverview();
-  item1 = GetWindowItemForWindow(0, window1.get());
-  item2 = GetWindowItemForWindow(0, window2.get());
-  EXPECT_FALSE(HasMaskForItem(item1));
-  EXPECT_FALSE(HasMaskForItem(item2));
-  minimized_widget(item1)
-      ->GetNativeWindow()
-      ->layer()
-      ->GetAnimator()
-      ->StopAnimating();
-  minimized_widget(item2)
-      ->GetNativeWindow()
-      ->layer()
-      ->GetAnimator()
-      ->StopAnimating();
-  EXPECT_FALSE(HasMaskForItem(item1));
-  EXPECT_FALSE(HasMaskForItem(item2));
-  base::RunLoop().RunUntilIdle();
-  EXPECT_TRUE(HasMaskForItem(item1));
-  EXPECT_TRUE(HasMaskForItem(item2));
-
-  // Test that leaving overview mode cleans up properly.
-  ToggleOverview();
-}
-
-// Test that the mask that is applied to add rounded corners in overview mode
-// is removed during drags.
-TEST_F(OverviewSessionTest, RoundedEdgeMaskVisibilityDragging) {
-  std::unique_ptr<aura::Window> window1(CreateTestWindow());
-  std::unique_ptr<aura::Window> window2(CreateTestWindow());
-
-  ::wm::ActivateWindow(window2.get());
-  ::wm::ActivateWindow(window1.get());
-
-  EnterTabletMode();
-  ToggleOverview();
-  OverviewItem* item1 = GetWindowItemForWindow(0, window1.get());
-  OverviewItem* item2 = GetWindowItemForWindow(0, window2.get());
   ui::ScopedAnimationDurationScaleMode test_duration_mode(
       ui::ScopedAnimationDurationScaleMode::NON_ZERO_DURATION);
 
-  // Drag the first window. Verify that the mask was removed for the first
-  // window but still exists for the second window as we do not apply mask
-  // for a dragged window.
-  const gfx::Point start_drag =
-      gfx::ToRoundedPoint(item1->target_bounds().CenterPoint());
+  // Drag the first window. Verify that the mask still exists for both items as
+  // we do not apply any animation to the window items at this point.
+  const gfx::Point start_drag = item1->target_bounds().CenterPoint();
   ui::test::EventGenerator* generator = GetEventGenerator();
   generator->MoveMouseTo(start_drag);
   generator->PressLeftButton();
   EXPECT_FALSE(window1->layer()->GetAnimator()->is_animating());
   EXPECT_FALSE(window2->layer()->GetAnimator()->is_animating());
-  EXPECT_FALSE(HasMaskForItem(item1));
+  base::RunLoop().RunUntilIdle();
+  EXPECT_TRUE(HasMaskForItem(item1));
   EXPECT_TRUE(HasMaskForItem(item2));
 
   // Drag to horizontally and then back to the start to avoid activating the
@@ -2430,8 +2253,12 @@
   // Verify that the mask is visble again after animation is finished.
   window1->layer()->GetAnimator()->StopAnimating();
   window2->layer()->GetAnimator()->StopAnimating();
+  base::RunLoop().RunUntilIdle();
   EXPECT_TRUE(HasMaskForItem(item1));
   EXPECT_TRUE(HasMaskForItem(item2));
+
+  // Test that leaving overview mode cleans up properly.
+  ToggleOverview();
 }
 
 TEST_F(OverviewSessionTest, NoRoundedEdgeMaskFor11Windows) {
@@ -2538,8 +2365,8 @@
   OverviewItem* item1 = GetWindowItemForWindow(0, window1.get());
   OverviewItem* item2 = GetWindowItemForWindow(0, window2.get());
 
-  const gfx::RectF original_bounds1 = item1->target_bounds();
-  const gfx::RectF original_bounds2 = item2->target_bounds();
+  const gfx::Rect original_bounds1 = item1->target_bounds();
+  const gfx::Rect original_bounds2 = item2->target_bounds();
 
   constexpr int kTouchId1 = 1;
   constexpr int kTouchId2 = 2;
@@ -2556,8 +2383,7 @@
 
   // Verify that the bounds of the tapped window expand when touched.
   ui::test::EventGenerator* generator = GetEventGenerator();
-  generator->set_current_screen_location(
-      gfx::ToRoundedPoint(original_bounds1.CenterPoint()));
+  generator->set_current_screen_location(original_bounds1.CenterPoint());
   generator->PressTouchId(kTouchId1);
   dispatch_long_press();
   EXPECT_GT(item1->target_bounds().width(), original_bounds1.width());
@@ -2566,8 +2392,7 @@
   // Verify that attempting to touch the second window with a second finger does
   // nothing to the second window. The first window remains the window to be
   // dragged.
-  generator->set_current_screen_location(
-      gfx::ToRoundedPoint(original_bounds2.CenterPoint()));
+  generator->set_current_screen_location(original_bounds2.CenterPoint());
   generator->PressTouchId(kTouchId2);
   dispatch_long_press();
   EXPECT_GT(item1->target_bounds().width(), original_bounds1.width());
@@ -2575,7 +2400,7 @@
   EXPECT_EQ(item2->target_bounds(), original_bounds2);
 
   // Verify the first window moves on drag.
-  gfx::PointF last_center_point = item1->target_bounds().CenterPoint();
+  gfx::Point last_center_point = item1->target_bounds().CenterPoint();
   generator->MoveTouchIdBy(kTouchId1, 40, 40);
   EXPECT_NE(last_center_point, item1->target_bounds().CenterPoint());
   EXPECT_EQ(original_bounds2.CenterPoint(),
@@ -2636,9 +2461,9 @@
   OverviewItem* item1 = GetWindowItemForWindow(0, window1.get());
   OverviewItem* item2 = GetWindowItemForWindow(0, window2.get());
   OverviewItem* item3 = GetWindowItemForWindow(0, window3.get());
-  const gfx::RectF bounds1 = item1->target_bounds();
-  const gfx::RectF bounds2 = item2->target_bounds();
-  const gfx::RectF bounds3 = item3->target_bounds();
+  const gfx::Rect bounds1 = item1->target_bounds();
+  const gfx::Rect bounds2 = item2->target_bounds();
+  const gfx::Rect bounds3 = item3->target_bounds();
 
   // Verify that the bounds remain the same when calling PositionWindows again.
   overview_session()->PositionWindows(/*animate=*/false);
@@ -2666,9 +2491,8 @@
   EXPECT_NE(bounds3, item3->target_bounds());
 }
 
-// Tests that overview mode is entered with kWindowDragged mode when a window is
-// dragged from the top of the screen. For the purposes of this test, we use a
-// browser window.
+// Tests that overview mode is entered with kWindowDragged mode when an app is
+// dragged from the top of the screen.
 TEST_F(OverviewSessionTest, DraggingFromTopAnimation) {
   EnterTabletMode();
   std::unique_ptr<views::Widget> widget(CreateTestWidget(
@@ -2676,16 +2500,12 @@
   widget->GetNativeWindow()->SetProperty(aura::client::kTopViewInset, 20);
 
   // Drag from the the top of the app to enter overview.
+  auto drag_controller = std::make_unique<TabletModeAppWindowDragController>();
   ui::GestureEvent event(0, 0, 0, base::TimeTicks(),
                          ui::GestureEventDetails(ui::ET_GESTURE_SCROLL_BEGIN));
-  wm::WindowState* window_state = wm::GetWindowState(widget->GetNativeWindow());
-  window_state->CreateDragDetails(event.location(), HTCAPTION,
-                                  ::wm::WINDOW_MOVE_SOURCE_TOUCH);
-  auto drag_controller = std::make_unique<TabletModeWindowDragController>(
-      window_state, std::make_unique<TabletModeBrowserWindowDragDelegate>());
   ui::Event::DispatcherApi dispatch_helper(&event);
   dispatch_helper.set_target(widget->GetNativeWindow());
-  drag_controller->Drag(event.location(), event.flags());
+  drag_controller->DragWindowFromTop(&event);
 
   ASSERT_TRUE(IsSelecting());
   EXPECT_EQ(OverviewSession::EnterExitOverviewType::kWindowDragged,
@@ -2727,47 +2547,6 @@
   ToggleOverview();
 }
 
-TEST_F(OverviewSessionTest, GridShieldAnimation) {
-  ui::ScopedAnimationDurationScaleMode test_duration_mode(
-      ui::ScopedAnimationDurationScaleMode::NON_ZERO_DURATION);
-  std::unique_ptr<aura::Window> window(CreateTestWindow(gfx::Rect(200, 200)));
-
-  // Tests that if the window does not cover the workspace, the shield will not
-  // exist since it is created and animated in after position windows animations
-  // are finished.
-  ToggleOverview();
-  EXPECT_FALSE(GetShieldWidget(0));
-  ToggleOverview();
-
-  // Tests that if the window covers the workspace for example maximized, the
-  // shield will exist, and not be animated.
-  wm::GetWindowState(window.get())->Maximize();
-  ToggleOverview();
-  ASSERT_TRUE(GetShieldWidget(0));
-  EXPECT_FALSE(GetShieldWidget(0)
-                   ->GetNativeWindow()
-                   ->layer()
-                   ->GetAnimator()
-                   ->is_animating());
-}
-
-// Tests that windows that have a backdrop can still be tapped normally.
-// Regression test for crbug.com/938645.
-TEST_F(OverviewSessionTest, SelectingWindowWithBackdrop) {
-  std::unique_ptr<aura::Window> window(CreateTestWindow(gfx::Rect(500, 200)));
-
-  ToggleOverview();
-  OverviewItem* item = GetWindowItemForWindow(0, window.get());
-  ASSERT_EQ(ScopedOverviewTransformWindow::GridWindowFillMode::kLetterBoxed,
-            item->GetWindowDimensionsType());
-
-  // Tap the target.
-  GetEventGenerator()->set_current_screen_location(
-      gfx::ToRoundedPoint(item->target_bounds().CenterPoint()));
-  GetEventGenerator()->ClickLeftButton();
-  EXPECT_FALSE(IsSelecting());
-}
-
 class SplitViewOverviewSessionTest : public OverviewSessionTest {
  public:
   SplitViewOverviewSessionTest() = default;
@@ -2790,18 +2569,6 @@
     return Shell::Get()->split_view_controller();
   }
 
-  bool IsDividerAnimating() {
-    return split_view_controller()->IsDividerAnimating();
-  }
-
-  void SkipDividerSnapAnimation() {
-    if (!IsDividerAnimating())
-      return;
-    split_view_controller()->StopAndShoveAnimatedDivider();
-    split_view_controller()->EndResizeImpl();
-    split_view_controller()->EndSplitViewAfterResizingIfAppropriate();
-  }
-
   void EndSplitView() { split_view_controller()->EndSplitView(); }
 
  protected:
@@ -2851,10 +2618,10 @@
   // want to long press after every press, which enables dragging vertically to
   // close an item.
   void DragWindowTo(OverviewItem* item,
-                    const gfx::PointF& end_location,
+                    const gfx::Point& end_location,
                     SelectorItemLocation location,
                     bool long_press = true) {
-    gfx::PointF start_location;
+    gfx::Point start_location;
     switch (location) {
       case SelectorItemLocation::CENTER:
         start_location = item->target_bounds().CenterPoint();
@@ -2883,7 +2650,7 @@
   }
 
   // Drags a overview item |item| from its center point to |end_location|.
-  void DragWindowTo(OverviewItem* item, const gfx::PointF& end_location) {
+  void DragWindowTo(OverviewItem* item, const gfx::Point& end_location) {
     DragWindowTo(item, end_location, SelectorItemLocation::CENTER, true);
   }
 
@@ -2925,9 +2692,9 @@
 
   // Drag |window1| selector item to snap to left.
   const int grid_index = 0;
-  OverviewItem* overview_item1 =
+  OverviewItem* selector_item1 =
       GetWindowItemForWindow(grid_index, window1.get());
-  DragWindowTo(overview_item1, gfx::PointF(0, 0));
+  DragWindowTo(selector_item1, gfx::Point(0, 0));
 
   EXPECT_TRUE(split_view_controller()->IsSplitViewModeActive());
   EXPECT_EQ(split_view_controller()->state(),
@@ -2937,9 +2704,9 @@
   // Drag |window2| selector item to attempt to snap to left. Since there is
   // already one left snapped window |window1|, |window1| will be put in
   // overview mode.
-  OverviewItem* overview_item2 =
+  OverviewItem* selector_item2 =
       GetWindowItemForWindow(grid_index, window2.get());
-  DragWindowTo(overview_item2, gfx::PointF(0, 0));
+  DragWindowTo(selector_item2, gfx::Point(0, 0));
 
   EXPECT_EQ(split_view_controller()->state(),
             SplitViewController::LEFT_SNAPPED);
@@ -2948,11 +2715,10 @@
       window1.get()));
 
   // Drag |window3| selector item to snap to right.
-  OverviewItem* overview_item3 =
+  OverviewItem* selector_item3 =
       GetWindowItemForWindow(grid_index, window3.get());
-  const gfx::PointF end_location3(GetWorkAreaInScreen(window3.get()).width(),
-                                  0.f);
-  DragWindowTo(overview_item3, end_location3);
+  const gfx::Point end_location3(GetWorkAreaInScreen(window3.get()).width(), 0);
+  DragWindowTo(selector_item3, end_location3);
 
   EXPECT_EQ(split_view_controller()->state(),
             SplitViewController::BOTH_SNAPPED);
@@ -2978,7 +2744,7 @@
   using DragBehavior = OverviewWindowDragController::DragBehavior;
   ui::test::EventGenerator* generator = GetEventGenerator();
   generator->set_current_screen_location(
-      gfx::ToRoundedPoint(window_item1->target_bounds().CenterPoint()));
+      window_item1->target_bounds().CenterPoint());
   generator->PressTouch();
   OverviewWindowDragController* drag_controller =
       overview_session()->window_drag_controller();
@@ -2992,7 +2758,7 @@
   // Verify that if a drag is orginally vertical, the drag behavior is drag to
   // close.
   generator->set_current_screen_location(
-      gfx::ToRoundedPoint(window_item2->target_bounds().CenterPoint()));
+      window_item2->target_bounds().CenterPoint());
   generator->PressTouch();
   drag_controller = overview_session()->window_drag_controller();
   EXPECT_EQ(DragBehavior::kUndefined, drag_controller->current_drag_behavior());
@@ -3014,21 +2780,21 @@
   ASSERT_TRUE(overview_controller()->IsSelecting());
 
   OverviewItem* item = GetWindowItemForWindow(0, widget->GetNativeWindow());
-  const gfx::PointF start = item->target_bounds().CenterPoint();
+  const gfx::Point start = item->target_bounds().CenterPoint();
   ASSERT_TRUE(item);
 
   // This drag has not covered enough distance, so the widget is not closed and
   // we remain in overview mode.
   overview_session()->InitiateDrag(item, start);
-  overview_session()->Drag(item, start + gfx::Vector2dF(0, 80));
-  overview_session()->CompleteDrag(item, start + gfx::Vector2dF(0, 80));
+  overview_session()->Drag(item, start + gfx::Vector2d(0, 80));
+  overview_session()->CompleteDrag(item, start + gfx::Vector2d(0, 80));
   ASSERT_TRUE(overview_session());
 
   // Verify that the second drag has enough vertical distance, so the widget
   // will be closed and overview mode will be exited.
   overview_session()->InitiateDrag(item, start);
-  overview_session()->Drag(item, start + gfx::Vector2dF(0, 180));
-  overview_session()->CompleteDrag(item, start + gfx::Vector2dF(0, 180));
+  overview_session()->Drag(item, start + gfx::Vector2d(0, 180));
+  overview_session()->CompleteDrag(item, start + gfx::Vector2d(0, 180));
   base::RunLoop().RunUntilIdle();
   EXPECT_FALSE(overview_session());
   EXPECT_TRUE(widget->IsClosed());
@@ -3045,26 +2811,26 @@
   EXPECT_EQ(1u, overview_session()->grid_list_for_testing()[0]->size());
 
   OverviewItem* item = GetWindowItemForWindow(0, widget->GetNativeWindow());
-  const gfx::PointF start = item->target_bounds().CenterPoint();
+  const gfx::Point start = item->target_bounds().CenterPoint();
   ASSERT_TRUE(item);
 
   // Verify that items flung horizontally do not close the item.
   overview_session()->InitiateDrag(item, start);
-  overview_session()->Drag(item, start + gfx::Vector2dF(0, 50));
+  overview_session()->Drag(item, start + gfx::Vector2d(0, 50));
   overview_session()->Fling(item, start, 2500, 0);
   ASSERT_TRUE(overview_session());
 
   // Verify that items flung vertically but without enough velocity do not
   // close the item.
   overview_session()->InitiateDrag(item, start);
-  overview_session()->Drag(item, start + gfx::Vector2dF(0, 50));
+  overview_session()->Drag(item, start + gfx::Vector2d(0, 50));
   overview_session()->Fling(item, start, 0, 1500);
   ASSERT_TRUE(overview_session());
 
   // Verify that flinging the item closes it, and since it is the last item in
   // overview mode, overview mode is exited.
   overview_session()->InitiateDrag(item, start);
-  overview_session()->Drag(item, start + gfx::Vector2dF(0, 50));
+  overview_session()->Drag(item, start + gfx::Vector2d(0, 50));
   overview_session()->Fling(item, start, 0, 2500);
   base::RunLoop().RunUntilIdle();
   EXPECT_FALSE(overview_session());
@@ -3090,15 +2856,15 @@
   OverviewItem* item2 = GetWindowItemForWindow(0, window2.get());
   OverviewItem* item3 = GetWindowItemForWindow(0, window3.get());
 
-  const gfx::RectF item1_bounds = item1->target_bounds();
-  const gfx::RectF item2_bounds = item2->target_bounds();
-  const gfx::RectF item3_bounds = item3->target_bounds();
+  const gfx::Rect item1_bounds = item1->target_bounds();
+  const gfx::Rect item2_bounds = item2->target_bounds();
+  const gfx::Rect item3_bounds = item3->target_bounds();
 
   // Drag |item1| vertically. |item2| and |item3| bounds should change as they
   // should be nudging towards their final bounds.
   overview_session()->InitiateDrag(item1, item1_bounds.CenterPoint());
   overview_session()->Drag(item1,
-                           item1_bounds.CenterPoint() + gfx::Vector2dF(0, 160));
+                           item1_bounds.CenterPoint() + gfx::Vector2d(0, 160));
   EXPECT_NE(item2_bounds, item2->target_bounds());
   EXPECT_NE(item3_bounds, item3->target_bounds());
 
@@ -3111,7 +2877,7 @@
   // should be nudging towards their final bounds.
   overview_session()->InitiateDrag(item3, item3_bounds.CenterPoint());
   overview_session()->Drag(item3,
-                           item3_bounds.CenterPoint() + gfx::Vector2dF(0, 160));
+                           item3_bounds.CenterPoint() + gfx::Vector2d(0, 160));
   EXPECT_NE(item1_bounds, item1->target_bounds());
   EXPECT_NE(item2_bounds, item2->target_bounds());
 }
@@ -3136,16 +2902,16 @@
   OverviewItem* item3 = GetWindowItemForWindow(0, window3.get());
   OverviewItem* item4 = GetWindowItemForWindow(0, window4.get());
 
-  const gfx::RectF item1_bounds = item1->target_bounds();
-  const gfx::RectF item2_bounds = item2->target_bounds();
-  const gfx::RectF item3_bounds = item3->target_bounds();
-  const gfx::RectF item4_bounds = item4->target_bounds();
+  const gfx::Rect item1_bounds = item1->target_bounds();
+  const gfx::Rect item2_bounds = item2->target_bounds();
+  const gfx::Rect item3_bounds = item3->target_bounds();
+  const gfx::Rect item4_bounds = item4->target_bounds();
 
   // Drag |item1| past the drag to swipe threshold. None of the other window
   // bounds should change, as none of them should be nudged.
   overview_session()->InitiateDrag(item1, item1_bounds.CenterPoint());
   overview_session()->Drag(item1,
-                           item1_bounds.CenterPoint() + gfx::Vector2dF(0, 160));
+                           item1_bounds.CenterPoint() + gfx::Vector2d(0, 160));
   EXPECT_EQ(item2_bounds, item2->target_bounds());
   EXPECT_EQ(item3_bounds, item3->target_bounds());
   EXPECT_EQ(item4_bounds, item4->target_bounds());
@@ -3169,7 +2935,7 @@
   ASSERT_TRUE(overview_controller()->IsSelecting());
 
   OverviewItem* items[kWindows];
-  gfx::RectF item_bounds[kWindows];
+  gfx::Rect item_bounds[kWindows];
   for (int i = 0; i < kWindows; ++i) {
     items[i] = GetWindowItemForWindow(0, windows[i].get());
     item_bounds[i] = items[i]->target_bounds();
@@ -3181,7 +2947,7 @@
   // first row to the second.
   overview_session()->InitiateDrag(items[3], item_bounds[3].CenterPoint());
   overview_session()->Drag(
-      items[3], item_bounds[3].CenterPoint() + gfx::Vector2dF(0, 160));
+      items[3], item_bounds[3].CenterPoint() + gfx::Vector2d(0, 160));
   EXPECT_EQ(item_bounds[0], items[0]->target_bounds());
   EXPECT_EQ(item_bounds[1], items[1]->target_bounds());
   EXPECT_EQ(item_bounds[2], items[2]->target_bounds());
@@ -3198,7 +2964,7 @@
   // row than the first item.
   overview_session()->InitiateDrag(items[0], item_bounds[0].CenterPoint());
   overview_session()->Drag(
-      items[0], item_bounds[0].CenterPoint() + gfx::Vector2dF(0, 160));
+      items[0], item_bounds[0].CenterPoint() + gfx::Vector2d(0, 160));
   EXPECT_NE(item_bounds[1], items[1]->target_bounds());
   EXPECT_NE(item_bounds[2], items[2]->target_bounds());
   EXPECT_EQ(item_bounds[3], items[3]->target_bounds());
@@ -3221,16 +2987,16 @@
   const int grid_index = 0;
   const int window_width =
       Shell::Get()->GetPrimaryRootWindow()->GetBoundsInScreen().width();
-  OverviewItem* overview_item =
+  OverviewItem* selector_item =
       GetWindowItemForWindow(grid_index, window1.get());
-  gfx::RectF overview_item_bounds = overview_item->target_bounds();
-  gfx::PointF start_location(overview_item_bounds.CenterPoint());
-  overview_session()->InitiateDrag(overview_item, start_location);
+  gfx::Rect selector_item_bounds = selector_item->target_bounds();
+  gfx::Point start_location(selector_item_bounds.CenterPoint());
+  overview_session()->InitiateDrag(selector_item, start_location);
 
   // Verify that when dragged to the left, the window grid is located where the
   // right window of split view mode should be.
-  const gfx::PointF left(0, 0);
-  overview_session()->Drag(overview_item, left);
+  const gfx::Point left(0, 0);
+  overview_session()->Drag(selector_item, left);
   EXPECT_FALSE(split_view_controller()->IsSplitViewModeActive());
   EXPECT_EQ(SplitViewController::NO_SNAP, split_view_controller()->state());
   EXPECT_TRUE(split_view_controller()->left_window() == nullptr);
@@ -3238,37 +3004,37 @@
 
   // Verify that when dragged to the right, the window grid is located where the
   // left window of split view mode should be.
-  const gfx::PointF right(window_width, 0);
-  overview_session()->Drag(overview_item, right);
+  const gfx::Point right(window_width, 0);
+  overview_session()->Drag(selector_item, right);
   EXPECT_EQ(SplitViewController::NO_SNAP, split_view_controller()->state());
   EXPECT_TRUE(split_view_controller()->right_window() == nullptr);
   EXPECT_EQ(GetSplitViewLeftWindowBounds(window1.get()), GetGridBounds());
 
   // Verify that when dragged to the center, the window grid is has the
   // dimensions of the work area.
-  const gfx::PointF center(window_width / 2, 0);
-  overview_session()->Drag(overview_item, center);
+  const gfx::Point center(window_width / 2, 0);
+  overview_session()->Drag(selector_item, center);
   EXPECT_EQ(SplitViewController::NO_SNAP, split_view_controller()->state());
   EXPECT_EQ(GetWorkAreaInScreen(window1.get()), GetGridBounds());
 
   // Snap window1 to the left and initialize dragging for window2.
-  overview_session()->Drag(overview_item, left);
-  overview_session()->CompleteDrag(overview_item, left);
+  overview_session()->Drag(selector_item, left);
+  overview_session()->CompleteDrag(selector_item, left);
   ASSERT_EQ(SplitViewController::LEFT_SNAPPED,
             split_view_controller()->state());
   ASSERT_EQ(window1.get(), split_view_controller()->left_window());
-  overview_item = GetWindowItemForWindow(grid_index, window2.get());
-  overview_item_bounds = overview_item->target_bounds();
-  start_location = overview_item_bounds.CenterPoint();
-  overview_session()->InitiateDrag(overview_item, start_location);
+  selector_item = GetWindowItemForWindow(grid_index, window2.get());
+  selector_item_bounds = selector_item->target_bounds();
+  start_location = selector_item_bounds.CenterPoint();
+  overview_session()->InitiateDrag(selector_item, start_location);
 
   // Verify that when there is a snapped window, the window grid bounds remain
   // constant despite overview items being dragged left and right.
-  overview_session()->Drag(overview_item, left);
+  overview_session()->Drag(selector_item, left);
   EXPECT_EQ(GetSplitViewRightWindowBounds(window1.get()), GetGridBounds());
-  overview_session()->Drag(overview_item, right);
+  overview_session()->Drag(selector_item, right);
   EXPECT_EQ(GetSplitViewRightWindowBounds(window1.get()), GetGridBounds());
-  overview_session()->Drag(overview_item, center);
+  overview_session()->Drag(selector_item, center);
   EXPECT_EQ(GetSplitViewRightWindowBounds(window1.get()), GetGridBounds());
 }
 
@@ -3289,17 +3055,17 @@
 
   // Verify that after dragging the unsnappable window to the left and right,
   // the window grid bounds do not change.
-  OverviewItem* overview_item =
+  OverviewItem* selector_item =
       GetWindowItemForWindow(0, unsnappable_window.get());
   overview_session()->InitiateDrag(
-      overview_item, overview_item->target_bounds().CenterPoint());
-  overview_session()->Drag(overview_item, gfx::PointF());
+      selector_item, selector_item->target_bounds().CenterPoint());
+  overview_session()->Drag(selector_item, gfx::Point(0, 0));
   EXPECT_EQ(expected_grid_bounds, GetGridBounds());
-  overview_session()->Drag(overview_item,
-                           gfx::PointF(root_window_bounds.right(), 0.f));
+  overview_session()->Drag(selector_item,
+                           gfx::Point(root_window_bounds.right(), 0));
   EXPECT_EQ(expected_grid_bounds, GetGridBounds());
-  overview_session()->Drag(overview_item,
-                           gfx::PointF(root_window_bounds.right() / 2.f, 0.f));
+  overview_session()->Drag(selector_item,
+                           gfx::Point(root_window_bounds.right() / 2, 0));
   EXPECT_EQ(expected_grid_bounds, GetGridBounds());
 }
 
@@ -3315,9 +3081,9 @@
 
   // Drag |window1| selector item to snap to left.
   const int grid_index = 0;
-  OverviewItem* overview_item1 =
+  OverviewItem* selector_item1 =
       GetWindowItemForWindow(grid_index, window1.get());
-  DragWindowTo(overview_item1, gfx::PointF());
+  DragWindowTo(selector_item1, gfx::Point(0, 0));
 
   // Test that overview mode is active in this single window case.
   EXPECT_EQ(split_view_controller()->IsSplitViewModeActive(), true);
@@ -3368,8 +3134,8 @@
   // Now enter overview and split view again. Test that exiting tablet mode can
   // end split view and overview correctly.
   ToggleOverview();
-  overview_item1 = GetWindowItemForWindow(grid_index, window1.get());
-  DragWindowTo(overview_item1, gfx::PointF());
+  selector_item1 = GetWindowItemForWindow(grid_index, window1.get());
+  DragWindowTo(selector_item1, gfx::Point(0, 0));
   EXPECT_TRUE(Shell::Get()->IsSplitViewModeActive());
   EXPECT_TRUE(overview_controller()->IsSelecting());
   Shell::Get()->tablet_mode_controller()->EnableTabletModeWindowManager(false);
@@ -3409,18 +3175,18 @@
   ToggleOverview();
   // Test that dragging |window1| to the left of the screen snaps it to left.
   const int grid_index = 0;
-  OverviewItem* overview_item1 =
+  OverviewItem* selector_item1 =
       GetWindowItemForWindow(grid_index, window1.get());
-  DragWindowTo(overview_item1, gfx::PointF());
+  DragWindowTo(selector_item1, gfx::Point(0, 0));
   EXPECT_EQ(split_view_controller()->state(), svc::LEFT_SNAPPED);
   EXPECT_EQ(split_view_controller()->left_window(), window1.get());
 
   // Test that dragging |window2| to the right of the screen snaps it to right.
-  OverviewItem* overview_item2 =
+  OverviewItem* selector_item2 =
       GetWindowItemForWindow(grid_index, window2.get());
   gfx::Rect work_area_rect = GetWorkAreaInScreen(window2.get());
-  gfx::PointF end_location2(work_area_rect.width(), work_area_rect.height());
-  DragWindowTo(overview_item2, end_location2);
+  gfx::Point end_location2(work_area_rect.width(), work_area_rect.height());
+  DragWindowTo(selector_item2, end_location2);
   EXPECT_EQ(split_view_controller()->state(), svc::BOTH_SNAPPED);
   EXPECT_EQ(split_view_controller()->right_window(), window2.get());
 
@@ -3439,16 +3205,16 @@
   ToggleOverview();
 
   // Test that dragging |window1| to the top of the screen snaps it to left.
-  overview_item1 = GetWindowItemForWindow(grid_index, window1.get());
-  DragWindowTo(overview_item1, gfx::PointF(0, 0));
+  selector_item1 = GetWindowItemForWindow(grid_index, window1.get());
+  DragWindowTo(selector_item1, gfx::Point(0, 0));
   EXPECT_EQ(split_view_controller()->state(), svc::LEFT_SNAPPED);
   EXPECT_EQ(split_view_controller()->left_window(), window1.get());
 
   // Test that dragging |window2| to the bottom of the screen snaps it to right.
-  overview_item2 = GetWindowItemForWindow(grid_index, window2.get());
+  selector_item2 = GetWindowItemForWindow(grid_index, window2.get());
   work_area_rect = GetWorkAreaInScreen(window2.get());
-  end_location2 = gfx::PointF(work_area_rect.width(), work_area_rect.height());
-  DragWindowTo(overview_item2, end_location2, SelectorItemLocation::ORIGIN);
+  end_location2 = gfx::Point(work_area_rect.width(), work_area_rect.height());
+  DragWindowTo(selector_item2, end_location2, SelectorItemLocation::ORIGIN);
   EXPECT_EQ(split_view_controller()->state(), svc::BOTH_SNAPPED);
   EXPECT_EQ(split_view_controller()->right_window(), window2.get());
 
@@ -3467,16 +3233,16 @@
   ToggleOverview();
 
   // Test that dragging |window1| to the left of the screen snaps it to right.
-  overview_item1 = GetWindowItemForWindow(grid_index, window1.get());
-  DragWindowTo(overview_item1, gfx::PointF());
+  selector_item1 = GetWindowItemForWindow(grid_index, window1.get());
+  DragWindowTo(selector_item1, gfx::Point(0, 0));
   EXPECT_EQ(split_view_controller()->state(), svc::RIGHT_SNAPPED);
   EXPECT_EQ(split_view_controller()->right_window(), window1.get());
 
   // Test that dragging |window2| to the right of the screen snaps it to left.
-  overview_item2 = GetWindowItemForWindow(grid_index, window2.get());
+  selector_item2 = GetWindowItemForWindow(grid_index, window2.get());
   work_area_rect = GetWorkAreaInScreen(window2.get());
-  end_location2 = gfx::PointF(work_area_rect.width(), work_area_rect.height());
-  DragWindowTo(overview_item2, end_location2, SelectorItemLocation::ORIGIN);
+  end_location2 = gfx::Point(work_area_rect.width(), work_area_rect.height());
+  DragWindowTo(selector_item2, end_location2, SelectorItemLocation::ORIGIN);
   EXPECT_EQ(split_view_controller()->state(), svc::BOTH_SNAPPED);
   EXPECT_EQ(split_view_controller()->left_window(), window2.get());
 
@@ -3495,16 +3261,16 @@
   ToggleOverview();
 
   // Test that dragging |window1| to the top of the screen snaps it to right.
-  overview_item1 = GetWindowItemForWindow(grid_index, window1.get());
-  DragWindowTo(overview_item1, gfx::PointF(0, 0));
+  selector_item1 = GetWindowItemForWindow(grid_index, window1.get());
+  DragWindowTo(selector_item1, gfx::Point(0, 0));
   EXPECT_EQ(split_view_controller()->state(), svc::RIGHT_SNAPPED);
   EXPECT_EQ(split_view_controller()->right_window(), window1.get());
 
   // Test that dragging |window2| to the bottom of the screen snaps it to left.
-  overview_item2 = GetWindowItemForWindow(grid_index, window2.get());
+  selector_item2 = GetWindowItemForWindow(grid_index, window2.get());
   work_area_rect = GetWorkAreaInScreen(window2.get());
-  end_location2 = gfx::PointF(work_area_rect.width(), work_area_rect.height());
-  DragWindowTo(overview_item2, end_location2);
+  end_location2 = gfx::Point(work_area_rect.width(), work_area_rect.height());
+  DragWindowTo(selector_item2, end_location2);
   EXPECT_EQ(split_view_controller()->state(), svc::BOTH_SNAPPED);
   EXPECT_EQ(split_view_controller()->left_window(), window2.get());
 
@@ -3531,9 +3297,9 @@
 
   // Drag |window1| selector item to snap to left.
   const int grid_index = 0;
-  OverviewItem* overview_item1 =
+  OverviewItem* selector_item1 =
       GetWindowItemForWindow(grid_index, window1.get());
-  DragWindowTo(overview_item1, gfx::PointF());
+  DragWindowTo(selector_item1, gfx::Point(0, 0));
 
   EXPECT_EQ(split_view_controller()->state(),
             SplitViewController::LEFT_SNAPPED);
@@ -3550,7 +3316,6 @@
   split_view_controller()->StartResize(resize_start_location);
   const gfx::Point resize_end_location(300, 0);
   split_view_controller()->EndResize(resize_end_location);
-  SkipDividerSnapAnimation();
 
   const gfx::Rect window1_bounds_after_resize = window1->GetBoundsInScreen();
   const gfx::Rect overview_grid_bounds_after_resize = GetGridBounds();
@@ -3585,11 +3350,11 @@
 
   // Select the unsnappable window.
   const int grid_index = 0;
-  OverviewItem* overview_item =
+  OverviewItem* selector_item =
       GetWindowItemForWindow(grid_index, unsnappable_window.get());
   ui::test::EventGenerator* generator = GetEventGenerator();
   generator->set_current_screen_location(
-      gfx::ToRoundedPoint(overview_item->target_bounds().CenterPoint()));
+      selector_item->target_bounds().CenterPoint());
   generator->ClickLeftButton();
 
   // Verify that we are out of split view and overview mode, and that the active
@@ -3617,9 +3382,9 @@
   EXPECT_TRUE(overview_controller()->IsSelecting());
 
   // Now select the unsnappable window.
-  overview_item = GetWindowItemForWindow(grid_index, unsnappable_window.get());
+  selector_item = GetWindowItemForWindow(grid_index, unsnappable_window.get());
   generator->set_current_screen_location(
-      gfx::ToRoundedPoint(overview_item->target_bounds().CenterPoint()));
+      selector_item->target_bounds().CenterPoint());
   generator->ClickLeftButton();
 
   // Split view mode should be ended. And the unsnappable window should be the
@@ -3643,23 +3408,23 @@
   ASSERT_TRUE(overview_controller()->IsSelecting());
 
   const int grid_index = 0;
-  OverviewItem* snappable_overview_item =
+  OverviewItem* snappable_selector_item =
       GetWindowItemForWindow(grid_index, window2.get());
-  OverviewItem* unsnappable_overview_item =
+  OverviewItem* unsnappable_selector_item =
       GetWindowItemForWindow(grid_index, unsnappable_window.get());
 
   // Note: |cannot_snap_label_view_| and its parent will be created on demand.
-  EXPECT_FALSE(GetCannotSnapLabelView(snappable_overview_item));
-  ASSERT_FALSE(GetCannotSnapLabelView(unsnappable_overview_item));
+  EXPECT_FALSE(GetCannotSnapLabelView(snappable_selector_item));
+  ASSERT_FALSE(GetCannotSnapLabelView(unsnappable_selector_item));
 
   // Snap the extra snappable window to enter split view mode.
   split_view_controller()->SnapWindow(window1.get(), SplitViewController::LEFT);
   ASSERT_TRUE(split_view_controller()->IsSplitViewModeActive());
-  EXPECT_FALSE(GetCannotSnapLabelView(snappable_overview_item));
-  ASSERT_TRUE(GetCannotSnapLabelView(unsnappable_overview_item));
-  ASSERT_TRUE(GetCannotSnapLabelView(unsnappable_overview_item)->parent());
+  EXPECT_FALSE(GetCannotSnapLabelView(snappable_selector_item));
+  ASSERT_TRUE(GetCannotSnapLabelView(unsnappable_selector_item));
+  ASSERT_TRUE(GetCannotSnapLabelView(unsnappable_selector_item)->parent());
   ui::Layer* unsnappable_layer =
-      GetCannotSnapLabelView(unsnappable_overview_item)->parent()->layer();
+      GetCannotSnapLabelView(unsnappable_selector_item)->parent()->layer();
   EXPECT_EQ(1.f, unsnappable_layer->opacity());
 
   // Exiting the splitview will hide the unsnappable label.
@@ -3668,7 +3433,6 @@
   GetEventGenerator()->set_current_screen_location(
       divider_bounds.CenterPoint());
   GetEventGenerator()->DragMouseTo(0, 0);
-  SkipDividerSnapAnimation();
 
   EXPECT_FALSE(split_view_controller()->IsSplitViewModeActive());
   EXPECT_EQ(0.f, unsnappable_layer->opacity());
@@ -3688,9 +3452,9 @@
 
   // Drag |window1| selector item to snap to left.
   const int grid_index = 0;
-  OverviewItem* overview_item1 =
+  OverviewItem* selector_item1 =
       GetWindowItemForWindow(grid_index, window1.get());
-  DragWindowTo(overview_item1, gfx::PointF());
+  DragWindowTo(selector_item1, gfx::Point(0, 0));
   // Test that overview mode and split view mode are both active.
   EXPECT_TRUE(split_view_controller()->IsSplitViewModeActive());
   EXPECT_TRUE(Shell::Get()->overview_controller()->IsSelecting());
@@ -3699,16 +3463,15 @@
   gfx::Rect divider_bounds = GetSplitViewDividerBounds(false /* is_dragging */);
   split_view_controller()->StartResize(divider_bounds.CenterPoint());
   split_view_controller()->EndResize(gfx::Point(0, 0));
-  SkipDividerSnapAnimation();
 
   // Test that split view mode is ended. Overview mode is still active.
   EXPECT_FALSE(split_view_controller()->IsSplitViewModeActive());
   EXPECT_TRUE(Shell::Get()->overview_controller()->IsSelecting());
 
   // Now drag |window2| selector item to snap to left.
-  OverviewItem* overview_item2 =
+  OverviewItem* selector_item2 =
       GetWindowItemForWindow(grid_index, window2.get());
-  DragWindowTo(overview_item2, gfx::PointF());
+  DragWindowTo(selector_item2, gfx::Point(0, 0));
   // Test that overview mode and split view mode are both active.
   EXPECT_TRUE(split_view_controller()->IsSplitViewModeActive());
   EXPECT_TRUE(Shell::Get()->overview_controller()->IsSelecting());
@@ -3718,7 +3481,6 @@
   const gfx::Rect display_bounds = GetWorkAreaInScreen(window2.get());
   split_view_controller()->StartResize(divider_bounds.CenterPoint());
   split_view_controller()->EndResize(display_bounds.bottom_right());
-  SkipDividerSnapAnimation();
 
   // Test that split view mode is ended. Overview mode is also ended. |window2|
   // should be activated.
@@ -3734,21 +3496,21 @@
   ToggleOverview();
   ASSERT_TRUE(overview_controller()->IsSelecting());
 
-  OverviewItem* overview_item = GetWindowItemForWindow(0, window1.get());
-  gfx::PointF start_location(overview_item->target_bounds().CenterPoint());
-  const gfx::RectF original_bounds(overview_item->target_bounds());
+  OverviewItem* selector_item = GetWindowItemForWindow(0, window1.get());
+  gfx::Point start_location(selector_item->target_bounds().CenterPoint());
+  const gfx::Rect original_bounds(selector_item->target_bounds());
 
   // Verify that when a overview item receives a resetting gesture, we
   // stay in overview mode and the bounds of the item are the same as they were
   // before the press sequence started.
-  overview_session()->InitiateDrag(overview_item, start_location);
+  overview_session()->InitiateDrag(selector_item, start_location);
   overview_session()->ResetDraggedWindowGesture();
   EXPECT_TRUE(overview_controller()->IsSelecting());
-  EXPECT_EQ(original_bounds, overview_item->target_bounds());
+  EXPECT_EQ(original_bounds, selector_item->target_bounds());
 
   // Verify that when a overview item is tapped, we exit overview mode,
   // and the current active window is the item.
-  overview_session()->InitiateDrag(overview_item, start_location);
+  overview_session()->InitiateDrag(selector_item, start_location);
   overview_session()->ActivateDraggedWindow();
   EXPECT_FALSE(overview_controller()->IsSelecting());
   EXPECT_EQ(window1.get(), wm::GetActiveWindow());
@@ -3771,9 +3533,9 @@
 
   // Drag |window1| selector item to snap to left.
   const int grid_index = 0;
-  OverviewItem* overview_item1 =
+  OverviewItem* selector_item1 =
       GetWindowItemForWindow(grid_index, window1.get());
-  DragWindowTo(overview_item1, gfx::PointF());
+  DragWindowTo(selector_item1, gfx::Point(0, 0));
   EXPECT_EQ(SplitViewController::LEFT_SNAPPED,
             split_view_controller()->state());
   EXPECT_TRUE(Shell::Get()->overview_controller()->IsSelecting());
@@ -3784,7 +3546,6 @@
   // Drag the divider to a point that is close enough but still have a short
   // distance to the edge of the screen.
   split_view_controller()->EndResize(gfx::Point(20, 20));
-  SkipDividerSnapAnimation();
 
   // Test that split view mode is ended. Overview mode is still active.
   EXPECT_FALSE(split_view_controller()->IsSplitViewModeActive());
@@ -3795,12 +3556,12 @@
   EXPECT_EQ(window1->bounds().width(), screen_width);
 
   // Drag |window2| selector item to snap to right.
-  OverviewItem* overview_item2 =
+  OverviewItem* selector_item2 =
       GetWindowItemForWindow(grid_index, window2.get());
   const gfx::Rect work_area_rect = GetWorkAreaInScreen(window2.get());
   gfx::Point end_location2 =
       gfx::Point(work_area_rect.width(), work_area_rect.height());
-  DragWindowTo(overview_item2, gfx::PointF(end_location2));
+  DragWindowTo(selector_item2, end_location2);
   EXPECT_EQ(SplitViewController::RIGHT_SNAPPED,
             split_view_controller()->state());
   EXPECT_TRUE(Shell::Get()->overview_controller()->IsSelecting());
@@ -3812,7 +3573,6 @@
   // distance to the edge of the screen.
   end_location2.Offset(-20, -20);
   split_view_controller()->EndResize(end_location2);
-  SkipDividerSnapAnimation();
 
   // Test that split view mode is ended. Overview mode is still active.
   EXPECT_FALSE(split_view_controller()->IsSplitViewModeActive());
@@ -3837,16 +3597,16 @@
   // Drag |window1| selector item to snap to left. There should be two items on
   // the overview grid afterwards, |window2| and |window3|.
   const int grid_index = 0;
-  OverviewItem* overview_item1 =
+  OverviewItem* selector_item1 =
       GetWindowItemForWindow(grid_index, window1.get());
-  DragWindowTo(overview_item1, gfx::PointF());
+  DragWindowTo(selector_item1, gfx::Point(0, 0));
   EXPECT_EQ(SplitViewController::LEFT_SNAPPED,
             split_view_controller()->state());
   EXPECT_TRUE(IsSelecting());
   EXPECT_TRUE(split_view_controller()->IsSplitViewModeActive());
   ASSERT_TRUE(split_view_controller()->split_view_divider());
   std::vector<aura::Window*> window_list =
-      overview_controller()->GetWindowsListInOverviewGridsForTest();
+      overview_controller()->GetWindowsListInOverviewGridsForTesting();
   EXPECT_EQ(2u, window_list.size());
   EXPECT_FALSE(base::ContainsValue(window_list, window1.get()));
   EXPECT_TRUE(wm::IsActiveWindow(window1.get()));
@@ -3857,13 +3617,13 @@
   GetEventGenerator()->set_current_screen_location(
       divider_bounds.CenterPoint());
   GetEventGenerator()->DragMouseTo(0, 0);
-  SkipDividerSnapAnimation();
 
   // Verify that it is still in overview mode and that |window1| is returned to
   // the overview list.
   EXPECT_TRUE(IsSelecting());
   EXPECT_FALSE(split_view_controller()->IsSplitViewModeActive());
-  window_list = overview_controller()->GetWindowsListInOverviewGridsForTest();
+  window_list =
+      overview_controller()->GetWindowsListInOverviewGridsForTesting();
   EXPECT_EQ(3u, window_list.size());
   EXPECT_TRUE(base::ContainsValue(window_list, window1.get()));
   EXPECT_FALSE(wm::IsActiveWindow(window1.get()));
@@ -3900,7 +3660,6 @@
   EXPECT_EQ(200, grid->bounds().width());
   EXPECT_GT(grid->bounds().right(), 600);
   generator->ReleaseLeftButton();
-  SkipDividerSnapAnimation();
 
   // Releasing close to the edge will activate the left window and exit
   // overview.
@@ -3924,7 +3683,6 @@
   EXPECT_EQ(200, grid->bounds().width());
   EXPECT_LT(grid->bounds().x(), 0);
   generator->ReleaseLeftButton();
-  SkipDividerSnapAnimation();
 }
 
 // Test that when splitview mode is active, minimizing one of the snapped window
@@ -3938,9 +3696,9 @@
   ToggleOverview();
 
   const int grid_index = 0;
-  OverviewItem* overview_item1 =
+  OverviewItem* selector_item1 =
       GetWindowItemForWindow(grid_index, window1.get());
-  DragWindowTo(overview_item1, gfx::PointF());
+  DragWindowTo(selector_item1, gfx::Point(0, 0));
   EXPECT_EQ(split_view_controller()->state(),
             SplitViewController::LEFT_SNAPPED);
   EXPECT_EQ(split_view_controller()->left_window(), window1.get());
@@ -3953,8 +3711,8 @@
   EXPECT_TRUE(GetWindowItemForWindow(grid_index, window1.get()));
 
   // Now snap both |window1| and |window2|.
-  overview_item1 = GetWindowItemForWindow(grid_index, window1.get());
-  DragWindowTo(overview_item1, gfx::PointF());
+  selector_item1 = GetWindowItemForWindow(grid_index, window1.get());
+  DragWindowTo(selector_item1, gfx::Point(0, 0));
   ::wm::ActivateWindow(window2.get());
   EXPECT_FALSE(IsSelecting());
   EXPECT_EQ(split_view_controller()->state(),
@@ -3998,19 +3756,19 @@
   EXPECT_FALSE(window2->layer()->GetTargetTransform().IsIdentity());
   EXPECT_FALSE(window3->layer()->GetTargetTransform().IsIdentity());
   const int grid_index = 0;
-  OverviewItem* overview_item1 =
+  OverviewItem* selector_item1 =
       GetWindowItemForWindow(grid_index, window1.get());
-  DragWindowTo(overview_item1, gfx::PointF());
+  DragWindowTo(selector_item1, gfx::Point(0, 0));
   EXPECT_EQ(SplitViewController::LEFT_SNAPPED,
             split_view_controller()->state());
   // Drag |window2| to snap to right.
-  OverviewItem* overview_item2 =
+  OverviewItem* selector_item2 =
       GetWindowItemForWindow(grid_index, window2.get());
   const gfx::Rect work_area_rect =
       screen_util::GetDisplayWorkAreaBoundsInScreenForDefaultContainer(
           window2.get());
-  const gfx::PointF end_location2(work_area_rect.width(), 0);
-  DragWindowTo(overview_item2, end_location2);
+  const gfx::Point end_location2(work_area_rect.width(), 0);
+  DragWindowTo(selector_item2, end_location2);
   EXPECT_EQ(SplitViewController::BOTH_SNAPPED,
             split_view_controller()->state());
   EXPECT_FALSE(overview_controller()->IsSelecting());
@@ -4073,15 +3831,15 @@
 // double tapping on the divider can swap the window's position with the
 // overview window grid's postion.
 TEST_F(SplitViewOverviewSessionTest, SwapWindowAndOverviewGrid) {
-  const gfx::Rect bounds(400, 400);
+  const gfx::Rect bounds(0, 0, 400, 400);
   std::unique_ptr<aura::Window> window1(CreateWindow(bounds));
   std::unique_ptr<aura::Window> window2(CreateWindow(bounds));
 
   ToggleOverview();
   const int grid_index = 0;
-  OverviewItem* overview_item1 =
+  OverviewItem* selector_item1 =
       GetWindowItemForWindow(grid_index, window1.get());
-  DragWindowTo(overview_item1, gfx::PointF());
+  DragWindowTo(selector_item1, gfx::Point(0, 0));
   EXPECT_EQ(split_view_controller()->state(),
             SplitViewController::LEFT_SNAPPED);
   EXPECT_EQ(split_view_controller()->default_snap_position(),
--- a/ash/wm/overview/overview_utils.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/overview/overview_utils.cc	2019-05-17 18:53:08.368000000 +0300
@@ -6,8 +6,8 @@
 
 #include <utility>
 
-#include "ash/home_screen/home_launcher_gesture_handler.h"
-#include "ash/home_screen/home_screen_controller.h"
+#include "ash/app_list/app_list_controller_impl.h"
+#include "ash/app_list/home_launcher_gesture_handler.h"
 #include "ash/public/cpp/ash_features.h"
 #include "ash/public/cpp/shell_window_ids.h"
 #include "ash/shell.h"
@@ -35,8 +35,8 @@
 
 namespace {
 
-// The transform applied to an overview item when animating to or from the home
-// launcher.
+// The transform applied to a window selector item when animating to or from the
+// home launcher.
 const gfx::Transform& GetShiftTransform() {
   static const base::NoDestructor<gfx::Transform> matrix(1, 0, 0, 1, 0, -100);
   return *matrix;
@@ -148,8 +148,9 @@
 }
 
 void FadeOutWidgetAndMaybeSlideOnExit(std::unique_ptr<views::Widget> widget,
-                                      OverviewAnimationType animation_type) {
-  // The overview controller may be nullptr on shutdown.
+                                      OverviewAnimationType animation_type,
+                                      bool slide) {
+  // The window selector controller may be nullptr on shutdown.
   OverviewController* controller = Shell::Get()->overview_controller();
   if (!controller) {
     widget->SetOpacity(0.f);
@@ -163,16 +164,14 @@
                                                      widget->GetNativeWindow());
   // CleanupAnimationObserver will delete itself (and the widget) when the
   // opacity animation is complete. Ownership over the observer is passed to the
-  // overview controller which has longer lifetime so that animations can
+  // window selector controller which has longer lifetime so that animations can
   // continue even after the overview mode is shut down.
   views::Widget* widget_ptr = widget.get();
   auto observer = std::make_unique<CleanupAnimationObserver>(std::move(widget));
   animation_settings.AddObserver(observer.get());
   controller->AddDelayedAnimationObserver(std::move(observer));
   widget_ptr->SetOpacity(0.f);
-
-  // Slide |widget| towards to top of screen if exit overview to home launcher.
-  if (animation_type == OVERVIEW_ANIMATION_EXIT_TO_HOME_LAUNCHER) {
+  if (slide) {
     gfx::Transform new_transform = widget_ptr->GetNativeWindow()->transform();
     new_transform.ConcatTransform(GetShiftTransform());
     widget_ptr->GetNativeWindow()->SetTransform(new_transform);
@@ -187,8 +186,7 @@
                                                       SkColor border_color,
                                                       float initial_opacity,
                                                       aura::Window* parent,
-                                                      bool stack_on_top,
-                                                      bool accept_events) {
+                                                      bool stack_on_top) {
   std::unique_ptr<views::Widget> widget = std::make_unique<views::Widget>();
   views::Widget::InitParams params;
   params.type = views::Widget::InitParams::TYPE_POPUP;
@@ -196,7 +194,7 @@
   params.ownership = views::Widget::InitParams::WIDGET_OWNS_NATIVE_WIDGET;
   params.opacity = views::Widget::InitParams::TRANSLUCENT_WINDOW;
   params.layer_type = layer_type;
-  params.accept_events = accept_events;
+  params.accept_events = false;
   widget->set_focus_on_creation(false);
   // Parenting in kShellWindowId_WallpaperContainer allows proper layering of
   // the shield and selection widgets. Since that container is created with
@@ -229,19 +227,19 @@
   return widget;
 }
 
-gfx::RectF GetTransformedBounds(aura::Window* transformed_window,
+gfx::Rect GetTransformedBounds(aura::Window* transformed_window,
                                 int top_inset) {
-  gfx::RectF bounds;
+  gfx::Rect bounds;
   for (auto* window : wm::GetTransientTreeIterator(transformed_window)) {
-    // Ignore other window types when computing bounding box of overview target
-    // item.
+    // Ignore other window types when computing bounding box of window
+    // selector target item.
     if (window != transformed_window &&
         window->type() != aura::client::WINDOW_TYPE_NORMAL) {
       continue;
     }
     gfx::RectF window_bounds(window->GetTargetBounds());
     gfx::Transform new_transform =
-        TransformAboutPivot(gfx::ToRoundedPoint(window_bounds.origin()),
+        TransformAboutPivot(gfx::Point(window_bounds.x(), window_bounds.y()),
                             window->layer()->GetTargetTransform());
     new_transform.TransformRect(&window_bounds);
 
@@ -252,36 +250,37 @@
       gfx::RectF header_bounds(window_bounds);
       header_bounds.set_height(top_inset);
       new_transform.TransformRect(&header_bounds);
-      window_bounds.Inset(0, header_bounds.height(), 0, 0);
+      window_bounds.Inset(0, gfx::ToCeiledInt(header_bounds.height()), 0, 0);
     }
-    ::wm::TranslateRectToScreen(window->parent(), &window_bounds);
-    bounds.Union(window_bounds);
+    gfx::Rect enclosing_bounds = ToEnclosingRect(window_bounds);
+    ::wm::ConvertRectToScreen(window->parent(), &enclosing_bounds);
+    bounds.Union(enclosing_bounds);
   }
   return bounds;
 }
 
-gfx::RectF GetTargetBoundsInScreen(aura::Window* window) {
-  gfx::RectF bounds;
+gfx::Rect GetTargetBoundsInScreen(aura::Window* window) {
+  gfx::Rect bounds;
   for (auto* window_iter : wm::GetTransientTreeIterator(window)) {
-    // Ignore other window types when computing bounding box of overview target
-    // item.
+    // Ignore other window types when computing bounding box of window
+    // selector target item.
     if (window_iter != window &&
         window_iter->type() != aura::client::WINDOW_TYPE_NORMAL) {
       continue;
     }
-    gfx::RectF target_bounds(window_iter->GetTargetBounds());
-    ::wm::TranslateRectToScreen(window_iter->parent(), &target_bounds);
+    gfx::Rect target_bounds = window_iter->GetTargetBounds();
+    ::wm::ConvertRectToScreen(window_iter->parent(), &target_bounds);
     bounds.Union(target_bounds);
   }
   return bounds;
 }
 
 void SetTransform(aura::Window* window, const gfx::Transform& transform) {
-  gfx::PointF target_origin(GetTargetBoundsInScreen(window).origin());
+  gfx::Point target_origin(GetTargetBoundsInScreen(window).origin());
   for (auto* window_iter : wm::GetTransientTreeIterator(window)) {
     aura::Window* parent_window = window_iter->parent();
-    gfx::RectF original_bounds(window_iter->GetTargetBounds());
-    ::wm::TranslateRectToScreen(parent_window, &original_bounds);
+    gfx::Rect original_bounds(window_iter->GetTargetBounds());
+    ::wm::ConvertRectToScreen(parent_window, &original_bounds);
     gfx::Transform new_transform =
         TransformAboutPivot(gfx::Point(target_origin.x() - original_bounds.x(),
                                        target_origin.y() - original_bounds.y()),
@@ -294,10 +293,11 @@
   if (!Shell::Get()->overview_controller()->IsSelecting())
     return false;
 
-  if (Shell::Get()
-          ->home_screen_controller()
-          ->home_launcher_gesture_handler()
-          ->mode() == HomeLauncherGestureHandler::Mode::kSlideUpToShow) {
+  HomeLauncherGestureHandler* home_launcher_gesture_handler =
+      Shell::Get()->app_list_controller()->home_launcher_gesture_handler();
+  if (home_launcher_gesture_handler &&
+      home_launcher_gesture_handler->mode() ==
+          HomeLauncherGestureHandler::Mode::kSlideUpToShow) {
     return true;
   }
 
--- a/ash/wm/overview/overview_utils.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/overview/overview_utils.h	2019-05-17 18:53:08.368000000 +0300
@@ -37,9 +37,11 @@
 // Fades |widget| to opacity zero with animation settings depending on
 // |animation_type|. Used by several classes which need to be destroyed on
 // exiting overview, but have some widgets which need to continue animating.
-// |widget| is destroyed after finishing animation.
+// |widget| is destroyed after finishing animation. Additionally slide |widget|
+// towards the top of screen if |slide| is true.
 void FadeOutWidgetAndMaybeSlideOnExit(std::unique_ptr<views::Widget> widget,
-                                      OverviewAnimationType animation_type);
+                                      OverviewAnimationType animation_type,
+                                      bool slide);
 
 // Creates and returns a background translucent widget parented in
 // |root_window|'s default container and having |background_color|.
@@ -48,8 +50,7 @@
 // The new background widget starts with |initial_opacity| and then fades in.
 // If |parent| is prvoided the return widget will be parented to that window,
 // otherwise its parent will be in kShellWindowId_WallpaperContainer of
-// |root_window|. |accept_events| is true if the newly-created widget should
-// handle events.
+// |root_window|.
 std::unique_ptr<views::Widget> CreateBackgroundWidget(aura::Window* root_window,
                                                       ui::LayerType layer_type,
                                                       SkColor background_color,
@@ -58,20 +59,18 @@
                                                       SkColor border_color,
                                                       float initial_opacity,
                                                       aura::Window* parent,
-                                                      bool stack_on_top,
-                                                      bool accept_events);
+                                                      bool stack_on_top);
 
 // Calculates the bounds of the |transformed_window|. Those bounds are a union
 // of all regular (normal and panel) windows in the |transformed_window|'s
 // transient hierarchy. The returned Rect is in virtual screen coordinates. The
 // returned bounds are adjusted to allow the original |transformed_window|'s
 // header to be hidden if |top_inset| is not zero.
-gfx::RectF GetTransformedBounds(aura::Window* transformed_window,
-                                int top_inset);
+gfx::Rect GetTransformedBounds(aura::Window* transformed_window, int top_inset);
 
 // Returns the original target bounds of |window|. The bounds are a union of all
 // regular (normal and panel) windows in the window's transient hierarchy.
-gfx::RectF GetTargetBoundsInScreen(aura::Window* window);
+gfx::Rect GetTargetBoundsInScreen(aura::Window* window);
 
 // Applies the |transform| to |window| and all of its transient children. Note
 // |transform| is the transform that is applied to |window| and needs to be
--- a/ash/wm/overview/overview_window_drag_controller.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/overview/overview_window_drag_controller.cc	2019-05-17 18:53:08.368000000 +0300
@@ -6,11 +6,8 @@
 
 #include <memory>
 
-#include "ash/public/cpp/presentation_time_recorder.h"
 #include "ash/screen_util.h"
 #include "ash/shell.h"
-#include "ash/wm/overview/overview_constants.h"
-#include "ash/wm/overview/overview_controller.h"
 #include "ash/wm/overview/overview_grid.h"
 #include "ash/wm/overview/overview_item.h"
 #include "ash/wm/overview/overview_session.h"
@@ -19,7 +16,6 @@
 #include "ash/wm/splitview/split_view_drag_indicators.h"
 #include "ash/wm/splitview/split_view_utils.h"
 #include "ash/wm/window_positioning_utils.h"
-#include "ash/wm/window_util.h"
 #include "base/numerics/ranges.h"
 #include "ui/aura/window.h"
 #include "ui/wm/core/coordinate_conversion.h"
@@ -33,33 +29,21 @@
 constexpr float kDragToCloseDistanceThresholdDp = 160.f;
 
 // The minimum distance that will be considered as a drag event.
-constexpr float kMinimumDragDistanceDp = 5.f;
+constexpr int kMinimumDragDistanceDp = 5;
 // Items dragged to within |kDistanceFromEdgeDp| of the screen will get snapped
 // even if they have not moved by |kMinimumDragDistanceDp|.
-constexpr float kDistanceFromEdgeDp = 16.f;
+constexpr int kDistanceFromEdgeDp = 16;
 // The minimum distance that an item must be moved before it is snapped. This
 // prevents accidental snaps.
-constexpr float kMinimumDragToSnapDistanceDp = 96.f;
+constexpr int kMinimumDragToSnapDistanceDp = 96;
 // The minimum distance that an item must be moved before it is considered a
 // drag event, if the drag starts in one of the snap regions.
-constexpr float kMinimumDragDistanceAlreadyInSnapRegionDp = 48.f;
+constexpr int kMinimumDragDistanceAlreadyInSnapRegionDp = 48;
 
 // Flings with less velocity than this will not close the dragged item.
 constexpr float kFlingToCloseVelocityThreshold = 2000.f;
 constexpr float kItemMinOpacity = 0.4f;
 
-// The UMA histogram that records presentation time for window dragging
-// operation in overview mode.
-constexpr char kOverviewWindowDragHistogram[] =
-    "Ash.Overview.WindowDrag.PresentationTime.TabletMode";
-constexpr char kOverviewWindowDragMaxLatencyHistogram[] =
-    "Ash.Overview.WindowDrag.PresentationTime.MaxLatency.TabletMode";
-
-void UnpauseOcclusionTracker() {
-  Shell::Get()->overview_controller()->UnpauseOcclusionTracker(
-      kOcclusionPauseDurationForDragMs);
-}
-
 }  // namespace
 
 OverviewWindowDragController::OverviewWindowDragController(
@@ -71,29 +55,22 @@
 
 void OverviewWindowDragController::InitiateDrag(
     OverviewItem* item,
-    const gfx::PointF& location_in_screen) {
+    const gfx::Point& location_in_screen) {
   item_ = item;
+  previous_event_location_ = location_in_screen;
   initial_event_location_ = location_in_screen;
-  initial_centerpoint_ = item_->target_bounds().CenterPoint();
   if (ShouldAllowSplitView()) {
     started_in_snap_region_ =
         GetSnapPosition(location_in_screen) != SplitViewController::NONE;
   }
   current_drag_behavior_ = DragBehavior::kUndefined;
-  Shell::Get()->overview_controller()->PauseOcclusionTracker();
-  DCHECK(!presentation_time_recorder_);
-
-  presentation_time_recorder_ =
-      std::make_unique<ash::PresentationTimeHistogramRecorder>(
-          item_->root_window()->layer()->GetCompositor(),
-          kOverviewWindowDragHistogram, kOverviewWindowDragMaxLatencyHistogram);
 }
 
-void OverviewWindowDragController::Drag(const gfx::PointF& location_in_screen) {
+void OverviewWindowDragController::Drag(const gfx::Point& location_in_screen) {
   if (!did_move_) {
-    gfx::Vector2dF distance = location_in_screen - initial_event_location_;
+    gfx::Vector2d distance = location_in_screen - previous_event_location_;
     // Do not start dragging if the distance from |location_in_screen| to
-    // |initial_event_location_| is not greater than |kMinimumDragDistanceDp|.
+    // |previous_event_location_| is not greater than |kMinimumDragDistanceDp|.
     if (std::abs(distance.x()) < kMinimumDragDistanceDp &&
         std::abs(distance.y()) < kMinimumDragDistanceDp) {
       return;
@@ -110,11 +87,13 @@
     }
   }
 
+  int x_offset = 0;
   // Update the state based on the drag behavior.
   if (current_drag_behavior_ == DragBehavior::kDragToClose) {
     // Update |item_|'s opacity based on its distance. |item_|'s x coordinate
     // should not change while in drag to close state.
-    float val = std::abs(location_in_screen.y() - initial_event_location_.y()) /
+    float val = std::abs(static_cast<float>(location_in_screen.y()) -
+                         initial_event_location_.y()) /
                 kDragToCloseDistanceThresholdDp;
     overview_session_->GetGridWithRootWindow(item_->root_window())
         ->UpdateNudge(item_, val);
@@ -125,6 +104,7 @@
     item_->SetOpacity(opacity);
   } else if (current_drag_behavior_ == DragBehavior::kDragToSnap) {
     UpdateDragIndicatorsAndOverviewGrid(location_in_screen);
+    x_offset = location_in_screen.x() - previous_event_location_.x();
   }
 
   // Update the split view divider bar status if necessary. If splitview is
@@ -133,31 +113,23 @@
   if (ShouldAllowSplitView())
     split_view_controller_->OnWindowDragStarted(item_->GetWindow());
 
-  if (presentation_time_recorder_)
-    presentation_time_recorder_->RequestNext();
-
-  // Update the dragged |item_|'s bounds accordingly. The distance from the new
-  // location to the new centerpoint should be the same it was initially. Do not
-  // update x bounds if dragging to close.
-  gfx::RectF bounds(item_->target_bounds());
-  const gfx::PointF centerpoint =
-      location_in_screen - (initial_event_location_ - initial_centerpoint_);
-  if (current_drag_behavior_ == DragBehavior::kDragToSnap)
-    bounds.set_x(centerpoint.x() - bounds.width() / 2.f);
-  bounds.set_y(centerpoint.y() - bounds.height() / 2.f);
+  // Update the dragged |item_|'s bounds accordingly.
+  gfx::Rect bounds(item_->target_bounds());
+  bounds.Offset(x_offset,
+                location_in_screen.y() - previous_event_location_.y());
   item_->SetBounds(bounds, OVERVIEW_ANIMATION_NONE);
+  previous_event_location_ = location_in_screen;
 }
 
 void OverviewWindowDragController::CompleteDrag(
-    const gfx::PointF& location_in_screen) {
+    const gfx::Point& location_in_screen) {
   // Update the split view divider bar stuatus if necessary. The divider bar
   // should be placed above the dragged window after drag ends. Note here the
   // passed paramters |snap_position_| and |location_in_screen| won't be used in
   // this function for this case, but they are passed in as placeholders.
   if (ShouldAllowSplitView()) {
     split_view_controller_->OnWindowDragEnded(
-        item_->GetWindow(), snap_position_,
-        gfx::ToRoundedPoint(location_in_screen));
+        item_->GetWindow(), snap_position_, location_in_screen);
   }
 
   // Update window grid bounds and |snap_position_| in case the screen
@@ -197,26 +169,24 @@
   did_move_ = false;
   item_ = nullptr;
   current_drag_behavior_ = DragBehavior::kNoDrag;
-  UnpauseOcclusionTracker();
-  presentation_time_recorder_.reset();
 }
 
 void OverviewWindowDragController::StartSplitViewDragMode(
-    const gfx::PointF& location_in_screen) {
+    const gfx::Point& location_in_screen) {
   DCHECK(ShouldAllowSplitView());
 
   item_->ScaleUpSelectedItem(
-      OVERVIEW_ANIMATION_LAYOUT_OVERVIEW_ITEMS_IN_OVERVIEW);
+      OVERVIEW_ANIMATION_LAY_OUT_SELECTOR_ITEMS_IN_OVERVIEW);
 
   did_move_ = true;
   current_drag_behavior_ = DragBehavior::kDragToSnap;
   overview_session_->SetSplitViewDragIndicatorsIndicatorState(
       CanSnapInSplitview(item_->GetWindow()) ? IndicatorState::kDragArea
                                              : IndicatorState::kCannotSnap,
-      gfx::ToRoundedPoint(location_in_screen));
+      location_in_screen);
 }
 
-void OverviewWindowDragController::Fling(const gfx::PointF& location_in_screen,
+void OverviewWindowDragController::Fling(const gfx::Point& location_in_screen,
                                          float velocity_x,
                                          float velocity_y) {
   if (current_drag_behavior_ == DragBehavior::kDragToClose ||
@@ -224,8 +194,7 @@
     if (std::abs(velocity_y) > kFlingToCloseVelocityThreshold) {
       if (ShouldAllowSplitView()) {
         split_view_controller_->OnWindowDragEnded(
-            item_->GetWindow(), snap_position_,
-            gfx::ToRoundedPoint(location_in_screen));
+            item_->GetWindow(), snap_position_, location_in_screen);
       }
 
       item_->AnimateAndCloseWindow(
@@ -233,7 +202,6 @@
       did_move_ = false;
       item_ = nullptr;
       current_drag_behavior_ = DragBehavior::kNoDrag;
-      UnpauseOcclusionTracker();
       return;
     }
   }
@@ -263,7 +231,6 @@
     split_view_controller_->ShowAppCannotSnapToast();
   }
   current_drag_behavior_ = DragBehavior::kNoDrag;
-  UnpauseOcclusionTracker();
 }
 
 void OverviewWindowDragController::ResetGesture() {
@@ -276,7 +243,6 @@
   // CompleteDrag but stops dragging as well, so reset |item_|.
   item_ = nullptr;
   current_drag_behavior_ = DragBehavior::kNoDrag;
-  UnpauseOcclusionTracker();
 }
 
 void OverviewWindowDragController::ResetOverviewSession() {
@@ -284,7 +250,7 @@
 }
 
 void OverviewWindowDragController::UpdateDragIndicatorsAndOverviewGrid(
-    const gfx::PointF& location_in_screen) {
+    const gfx::Point& location_in_screen) {
   DCHECK(ShouldAllowSplitView());
   if (!ShouldUpdateDragIndicatorsOrSnap(location_in_screen))
     return;
@@ -328,7 +294,7 @@
 }
 
 bool OverviewWindowDragController::ShouldUpdateDragIndicatorsOrSnap(
-    const gfx::PointF& event_location) {
+    const gfx::Point& event_location) {
   auto snap_position = GetSnapPosition(event_location);
   const bool inverted = !IsCurrentScreenOrientationPrimary();
   // Note: in some orientations SplitViewController::LEFT is not physically on
@@ -343,20 +309,19 @@
       screen_util::GetDisplayWorkAreaBoundsInParent(item_->GetWindow()));
   ::wm::ConvertRectToScreen(item_->GetWindow()->GetRootWindow(), &area);
   area.Inset(kDistanceFromEdgeDp, kDistanceFromEdgeDp);
-  const gfx::Point event_location_i = gfx::ToRoundedPoint(event_location);
-  if ((landscape && (event_location_i.x() < area.x() ||
-                     event_location_i.x() > area.right())) ||
-      (!landscape && (event_location_i.y() < area.y() ||
-                      event_location_i.y() > area.bottom()))) {
+  if ((landscape &&
+       (event_location.x() < area.x() || event_location.x() > area.right())) ||
+      (!landscape &&
+       (event_location.y() < area.y() || event_location.y() > area.bottom()))) {
     return true;
   }
 
   // The drag indicators can update or the item can snap even if the drag events
   // are in the snap region, if the event has travelled past the threshold in
   // the direction of the attempted snap region.
-  const gfx::Vector2dF distance = event_location - initial_event_location_;
+  const gfx::Vector2d distance = event_location - initial_event_location_;
   // Check the x-axis distance for landscape, y-axis distance for portrait.
-  const float distance_scalar = landscape ? distance.x() : distance.y();
+  const int distance_scalar = landscape ? distance.x() : distance.y();
 
   // If not started in a snap region, snap if the item has been dragged
   // |kMinimumDragDistanceDp|. This prevents accidental snaps.
@@ -386,7 +351,7 @@
 }
 
 SplitViewController::SnapPosition OverviewWindowDragController::GetSnapPosition(
-    const gfx::PointF& location_in_screen) const {
+    const gfx::Point& location_in_screen) const {
   DCHECK(item_);
   DCHECK(ShouldAllowSplitView());
   gfx::Rect area(
@@ -401,8 +366,8 @@
   // should show the preview window as soon as the window past the split divider
   // bar.
   if (split_view_controller_->IsSplitViewModeActive()) {
-    const int position = gfx::ToRoundedInt(
-        is_landscape ? location_in_screen.x() : location_in_screen.y());
+    const int position =
+        is_landscape ? location_in_screen.x() : location_in_screen.y();
     SplitViewController::SnapPosition default_snap_position =
         split_view_controller_->default_snap_position();
     // If we're trying to snap to a position that already has a snapped window:
--- a/ash/wm/overview/overview_window_drag_controller.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/overview/overview_window_drag_controller.h	2019-05-17 18:53:08.368000000 +0300
@@ -10,13 +10,12 @@
 #include "ash/ash_export.h"
 #include "ash/wm/splitview/split_view_controller.h"
 #include "base/macros.h"
-#include "ui/gfx/geometry/point_f.h"
+#include "ui/gfx/geometry/point.h"
 
 namespace ash {
 
 class OverviewItem;
 class OverviewSession;
-class PresentationTimeRecorder;
 
 // The drag controller for an overview window item in overview mode. It updates
 // the position of the corresponding window item using transform while dragging.
@@ -38,11 +37,11 @@
   explicit OverviewWindowDragController(OverviewSession* overview_session);
   ~OverviewWindowDragController();
 
-  void InitiateDrag(OverviewItem* item, const gfx::PointF& location_in_screen);
-  void Drag(const gfx::PointF& location_in_screen);
-  void CompleteDrag(const gfx::PointF& location_in_screen);
-  void StartSplitViewDragMode(const gfx::PointF& location_in_screen);
-  void Fling(const gfx::PointF& location_in_screen,
+  void InitiateDrag(OverviewItem* item, const gfx::Point& location_in_screen);
+  void Drag(const gfx::Point& location_in_screen);
+  void CompleteDrag(const gfx::Point& location_in_screen);
+  void StartSplitViewDragMode(const gfx::Point& location_in_screen);
+  void Fling(const gfx::Point& location_in_screen,
              float velocity_x,
              float velocity_y);
   void ActivateDraggedWindow();
@@ -61,15 +60,15 @@
  private:
   // Updates visuals for the user while dragging items around.
   void UpdateDragIndicatorsAndOverviewGrid(
-      const gfx::PointF& location_in_screen);
+      const gfx::Point& location_in_screen);
 
   // Dragged items should not attempt to update the indicators or snap if
   // the drag started in a snap region and has not been dragged pass the
   // threshold.
-  bool ShouldUpdateDragIndicatorsOrSnap(const gfx::PointF& event_location);
+  bool ShouldUpdateDragIndicatorsOrSnap(const gfx::Point& event_location);
 
   SplitViewController::SnapPosition GetSnapPosition(
-      const gfx::PointF& location_in_screen) const;
+      const gfx::Point& location_in_screen) const;
 
   // Returns the expected window grid bounds based on |snap_position|.
   gfx::Rect GetGridBounds(SplitViewController::SnapPosition snap_position);
@@ -85,12 +84,11 @@
 
   DragBehavior current_drag_behavior_ = DragBehavior::kNoDrag;
 
-  // The location of the initial mouse/touch/gesture event in screen.
-  gfx::PointF initial_event_location_;
+  // The location of the previous mouse/touch/gesture event in screen.
+  gfx::Point previous_event_location_;
 
-  // Stores the bounds of |item_| when a drag is started. Used to calculate the
-  // new bounds on a drag event.
-  gfx::PointF initial_centerpoint_;
+  // The location of the initial mouse/touch/gesture event in screen.
+  gfx::Point initial_event_location_;
 
   // False if the initial drag location was not a snap region, or if it was in
   // a snap region but the drag has since moved out.
@@ -104,9 +102,6 @@
   // Set to true once the bounds of |item_| change.
   bool did_move_ = false;
 
-  // Records the presentation time of window drag operation in overview mode.
-  std::unique_ptr<PresentationTimeRecorder> presentation_time_recorder_;
-
   SplitViewController::SnapPosition snap_position_ = SplitViewController::NONE;
 
   DISALLOW_COPY_AND_ASSIGN(OverviewWindowDragController);
--- a/ash/wm/overview/scoped_overview_animation_settings.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/overview/scoped_overview_animation_settings.cc	2019-05-17 18:53:08.368000000 +0300
@@ -4,7 +4,6 @@
 
 #include "ash/wm/overview/scoped_overview_animation_settings.h"
 
-#include "ash/metrics/histogram_macros.h"
 #include "base/lazy_instance.h"
 #include "base/metrics/histogram_macros.h"
 #include "base/time/time.h"
@@ -19,72 +18,46 @@
 namespace {
 
 // The time duration for transformation animations.
-constexpr base::TimeDelta kTransition = base::TimeDelta::FromMilliseconds(300);
+constexpr int kTransitionMs = 300;
 
 // The time duration for fading out when closing an item.
-constexpr base::TimeDelta kCloseFadeOut =
-    base::TimeDelta::FromMilliseconds(100);
+constexpr int kCloseFadeOutMs = 100;
 
 // The time duration for scaling down when an item is closed.
-constexpr base::TimeDelta kCloseScale = base::TimeDelta::FromMilliseconds(100);
+constexpr int kCloseScaleMs = 100;
 
 // The time duration for widgets to fade in.
-constexpr base::TimeDelta kFadeInDelay = base::TimeDelta::FromMilliseconds(83);
-constexpr base::TimeDelta kFadeIn = base::TimeDelta::FromMilliseconds(167);
+constexpr int kFadeInDelayMs = 83;
+constexpr int kFadeInMs = 167;
 
 // The time duration for widgets to fade out.
-constexpr base::TimeDelta kFadeOut = base::TimeDelta::FromMilliseconds(100);
+constexpr int kFadeOutMs = 100;
 
-constexpr base::TimeDelta kFromHomeLauncherDelay =
-    base::TimeDelta::FromMilliseconds(250);
-constexpr base::TimeDelta kHomeLauncherTransition =
-    base::TimeDelta::FromMilliseconds(250);
-
-// Time it takes for the selector widget to move to the next target. The same
-// time is used for fading out shield widget when the overview mode is opened
-// or closed.
-constexpr base::TimeDelta kOverviewSelectorTransition =
-    base::TimeDelta::FromMilliseconds(250);
-
-// Time duration of the show animation of the drop target.
-constexpr base::TimeDelta kDropTargetFadeIn =
-    base::TimeDelta::FromMilliseconds(250);
-
-// Duration of the show/hide animation of the overview title bar.
-constexpr base::TimeDelta kOverviewTitleFade =
-    base::TimeDelta::FromMilliseconds(167);
+constexpr int kFromHomeLauncherDelayMs = 250;
+constexpr int kHomeLauncherTransitionMs = 250;
 
 base::TimeDelta GetAnimationDuration(OverviewAnimationType animation_type) {
   switch (animation_type) {
     case OVERVIEW_ANIMATION_NONE:
       return base::TimeDelta();
     case OVERVIEW_ANIMATION_ENTER_OVERVIEW_MODE_FADE_IN:
-      return kFadeIn;
+      return base::TimeDelta::FromMilliseconds(kFadeInMs);
     case OVERVIEW_ANIMATION_EXIT_OVERVIEW_MODE_FADE_OUT:
-      return kFadeOut;
-    case OVERVIEW_ANIMATION_LAYOUT_OVERVIEW_ITEMS_ON_ENTER:
-    case OVERVIEW_ANIMATION_LAYOUT_OVERVIEW_ITEMS_IN_OVERVIEW:
-    case OVERVIEW_ANIMATION_LAYOUT_OVERVIEW_ITEMS_ON_EXIT:
+      return base::TimeDelta::FromMilliseconds(kFadeOutMs);
+    case OVERVIEW_ANIMATION_LAY_OUT_SELECTOR_ITEMS_ON_ENTER:
+    case OVERVIEW_ANIMATION_LAY_OUT_SELECTOR_ITEMS_IN_OVERVIEW:
+    case OVERVIEW_ANIMATION_LAY_OUT_SELECTOR_ITEMS_ON_EXIT:
     case OVERVIEW_ANIMATION_RESTORE_WINDOW:
     case OVERVIEW_ANIMATION_RESTORE_WINDOW_ZERO:
-      return kTransition;
-    case OVERVIEW_ANIMATION_CLOSING_OVERVIEW_ITEM:
-      return kCloseScale;
-    case OVERVIEW_ANIMATION_CLOSE_OVERVIEW_ITEM:
-      return kCloseFadeOut;
+      return base::TimeDelta::FromMilliseconds(kTransitionMs);
+    case OVERVIEW_ANIMATION_CLOSING_SELECTOR_ITEM:
+      return base::TimeDelta::FromMilliseconds(kCloseScaleMs);
+    case OVERVIEW_ANIMATION_CLOSE_SELECTOR_ITEM:
+      return base::TimeDelta::FromMilliseconds(kCloseFadeOutMs);
     case OVERVIEW_ANIMATION_ENTER_FROM_HOME_LAUNCHER:
     case OVERVIEW_ANIMATION_EXIT_TO_HOME_LAUNCHER:
-      return kHomeLauncherTransition;
-    case OVERVIEW_ANIMATION_DROP_TARGET_FADE_IN:
-      return kDropTargetFadeIn;
-    case OVERVIEW_ANIMATION_SHIELD_FADE:
-    case OVERVIEW_ANIMATION_SELECTION_WINDOW_SHADOW:
-    case OVERVIEW_ANIMATION_SELECTION_WINDOW:
-      return kOverviewSelectorTransition;
-    case OVERVIEW_ANIMATION_OVERVIEW_TITLE_FADE_IN:
-    case OVERVIEW_ANIMATION_OVERVIEW_TITLE_FADE_OUT:
-      return kOverviewTitleFade;
-  };
+      return base::TimeDelta::FromMilliseconds(kHomeLauncherTransitionMs);
+  }
   NOTREACHED();
   return base::TimeDelta();
 }
@@ -125,10 +98,6 @@
   void Report(int value) override {
     UMA_HISTOGRAM_PERCENTAGE("Ash.WindowSelector.AnimationSmoothness.Close",
                              value);
-    UMA_HISTOGRAM_PERCENTAGE_IN_CLAMSHELL(
-        "Ash.Overview.AnimationSmoothness.Close.ClamshellMode", value);
-    UMA_HISTOGRAM_PERCENTAGE_IN_TABLET(
-        "Ash.Overview.AnimationSmoothness.Close.TabletMode", value);
   }
 
  private:
@@ -146,26 +115,20 @@
     OverviewAnimationType animation_type) {
   switch (animation_type) {
     case OVERVIEW_ANIMATION_NONE:
-    case OVERVIEW_ANIMATION_LAYOUT_OVERVIEW_ITEMS_IN_OVERVIEW:
-    case OVERVIEW_ANIMATION_DROP_TARGET_FADE_IN:
-    case OVERVIEW_ANIMATION_SHIELD_FADE:
-    case OVERVIEW_ANIMATION_SELECTION_WINDOW_SHADOW:
-    case OVERVIEW_ANIMATION_SELECTION_WINDOW:
-    case OVERVIEW_ANIMATION_OVERVIEW_TITLE_FADE_IN:
-    case OVERVIEW_ANIMATION_OVERVIEW_TITLE_FADE_OUT:
+    case OVERVIEW_ANIMATION_LAY_OUT_SELECTOR_ITEMS_IN_OVERVIEW:
       return nullptr;
     case OVERVIEW_ANIMATION_ENTER_OVERVIEW_MODE_FADE_IN:
-    case OVERVIEW_ANIMATION_LAYOUT_OVERVIEW_ITEMS_ON_ENTER:
+    case OVERVIEW_ANIMATION_LAY_OUT_SELECTOR_ITEMS_ON_ENTER:
     case OVERVIEW_ANIMATION_ENTER_FROM_HOME_LAUNCHER:
       return g_reporter_enter.Pointer();
     case OVERVIEW_ANIMATION_EXIT_OVERVIEW_MODE_FADE_OUT:
     case OVERVIEW_ANIMATION_RESTORE_WINDOW:
     case OVERVIEW_ANIMATION_RESTORE_WINDOW_ZERO:
-    case OVERVIEW_ANIMATION_LAYOUT_OVERVIEW_ITEMS_ON_EXIT:
+    case OVERVIEW_ANIMATION_LAY_OUT_SELECTOR_ITEMS_ON_EXIT:
     case OVERVIEW_ANIMATION_EXIT_TO_HOME_LAUNCHER:
       return g_reporter_exit.Pointer();
-    case OVERVIEW_ANIMATION_CLOSING_OVERVIEW_ITEM:
-    case OVERVIEW_ANIMATION_CLOSE_OVERVIEW_ITEM:
+    case OVERVIEW_ANIMATION_CLOSING_SELECTOR_ITEM:
+    case OVERVIEW_ANIMATION_CLOSE_SELECTOR_ITEM:
       return g_reporter_close.Pointer();
   }
   NOTREACHED();
@@ -177,46 +140,41 @@
 ScopedOverviewAnimationSettings::ScopedOverviewAnimationSettings(
     OverviewAnimationType animation_type,
     aura::Window* window)
-    : ScopedOverviewAnimationSettings(animation_type,
-                                      window->layer()->GetAnimator()) {}
-
-ScopedOverviewAnimationSettings::ScopedOverviewAnimationSettings(
-    OverviewAnimationType animation_type,
-    ui::LayerAnimator* animator)
-    : animation_settings_(
-          std::make_unique<ui::ScopedLayerAnimationSettings>(animator)) {
+    : animation_settings_(new ui::ScopedLayerAnimationSettings(
+          window->layer()->GetAnimator())) {
   switch (animation_type) {
     case OVERVIEW_ANIMATION_NONE:
       animation_settings_->SetPreemptionStrategy(
           ui::LayerAnimator::REPLACE_QUEUED_ANIMATIONS);
       break;
     case OVERVIEW_ANIMATION_ENTER_OVERVIEW_MODE_FADE_IN:
+      window->layer()->GetAnimator()->SchedulePauseForProperties(
+          base::TimeDelta::FromMilliseconds(kFadeInDelayMs),
+          ui::LayerAnimationElement::OPACITY);
       animation_settings_->SetTweenType(gfx::Tween::FAST_OUT_SLOW_IN);
       animation_settings_->SetPreemptionStrategy(
           ui::LayerAnimator::REPLACE_QUEUED_ANIMATIONS);
-      animator->SchedulePauseForProperties(kFadeInDelay,
-                                           ui::LayerAnimationElement::OPACITY);
       break;
     case OVERVIEW_ANIMATION_EXIT_OVERVIEW_MODE_FADE_OUT:
       animation_settings_->SetTweenType(gfx::Tween::FAST_OUT_SLOW_IN);
       animation_settings_->SetPreemptionStrategy(
           ui::LayerAnimator::REPLACE_QUEUED_ANIMATIONS);
       break;
-    case OVERVIEW_ANIMATION_LAYOUT_OVERVIEW_ITEMS_ON_ENTER:
-    case OVERVIEW_ANIMATION_LAYOUT_OVERVIEW_ITEMS_IN_OVERVIEW:
-    case OVERVIEW_ANIMATION_LAYOUT_OVERVIEW_ITEMS_ON_EXIT:
+    case OVERVIEW_ANIMATION_LAY_OUT_SELECTOR_ITEMS_ON_ENTER:
+    case OVERVIEW_ANIMATION_LAY_OUT_SELECTOR_ITEMS_IN_OVERVIEW:
+    case OVERVIEW_ANIMATION_LAY_OUT_SELECTOR_ITEMS_ON_EXIT:
     case OVERVIEW_ANIMATION_RESTORE_WINDOW:
       animation_settings_->SetTweenType(gfx::Tween::EASE_OUT);
       animation_settings_->SetPreemptionStrategy(
           ui::LayerAnimator::IMMEDIATELY_ANIMATE_TO_NEW_TARGET);
       break;
     case OVERVIEW_ANIMATION_RESTORE_WINDOW_ZERO:
-      animation_settings_->SetTweenType(gfx::Tween::ZERO);
       animation_settings_->SetPreemptionStrategy(
           ui::LayerAnimator::IMMEDIATELY_ANIMATE_TO_NEW_TARGET);
+      animation_settings_->SetTweenType(gfx::Tween::ZERO);
       break;
-    case OVERVIEW_ANIMATION_CLOSING_OVERVIEW_ITEM:
-    case OVERVIEW_ANIMATION_CLOSE_OVERVIEW_ITEM:
+    case OVERVIEW_ANIMATION_CLOSING_SELECTOR_ITEM:
+    case OVERVIEW_ANIMATION_CLOSE_SELECTOR_ITEM:
       animation_settings_->SetTweenType(gfx::Tween::EASE_OUT);
       animation_settings_->SetPreemptionStrategy(
           ui::LayerAnimator::ENQUEUE_NEW_ANIMATION);
@@ -225,8 +183,9 @@
       animation_settings_->SetTweenType(gfx::Tween::FAST_OUT_SLOW_IN);
       animation_settings_->SetPreemptionStrategy(
           ui::LayerAnimator::ENQUEUE_NEW_ANIMATION);
-      animator->SchedulePauseForProperties(
-          kFromHomeLauncherDelay, ui::LayerAnimationElement::OPACITY |
+      window->layer()->GetAnimator()->SchedulePauseForProperties(
+          base::TimeDelta::FromMilliseconds(kFromHomeLauncherDelayMs),
+          ui::LayerAnimationElement::OPACITY |
                                       ui::LayerAnimationElement::TRANSFORM);
       break;
     case OVERVIEW_ANIMATION_EXIT_TO_HOME_LAUNCHER:
@@ -234,34 +193,6 @@
       animation_settings_->SetPreemptionStrategy(
           ui::LayerAnimator::REPLACE_QUEUED_ANIMATIONS);
       break;
-    case OVERVIEW_ANIMATION_DROP_TARGET_FADE_IN:
-      animation_settings_->SetTweenType(gfx::Tween::EASE_IN);
-      animation_settings_->SetPreemptionStrategy(
-          ui::LayerAnimator::IMMEDIATELY_ANIMATE_TO_NEW_TARGET);
-      break;
-    case OVERVIEW_ANIMATION_SHIELD_FADE:
-    case OVERVIEW_ANIMATION_SELECTION_WINDOW_SHADOW:
-      animation_settings_->SetTweenType(gfx::Tween::EASE_IN_OUT);
-      animation_settings_->SetPreemptionStrategy(
-          ui::LayerAnimator::IMMEDIATELY_ANIMATE_TO_NEW_TARGET);
-      break;
-    case OVERVIEW_ANIMATION_SELECTION_WINDOW:
-      animation_settings_->SetTweenType(gfx::Tween::EASE_OUT);
-      animation_settings_->SetPreemptionStrategy(
-          ui::LayerAnimator::IMMEDIATELY_ANIMATE_TO_NEW_TARGET);
-      break;
-    case OVERVIEW_ANIMATION_OVERVIEW_TITLE_FADE_IN:
-      animation_settings_->SetTweenType(gfx::Tween::LINEAR_OUT_SLOW_IN);
-      animation_settings_->SetPreemptionStrategy(
-          ui::LayerAnimator::REPLACE_QUEUED_ANIMATIONS);
-      animator->SchedulePauseForProperties(kOverviewTitleFade,
-                                           ui::LayerAnimationElement::OPACITY);
-      break;
-    case OVERVIEW_ANIMATION_OVERVIEW_TITLE_FADE_OUT:
-      animation_settings_->SetTweenType(gfx::Tween::FAST_OUT_LINEAR_IN);
-      animation_settings_->SetPreemptionStrategy(
-          ui::LayerAnimator::REPLACE_QUEUED_ANIMATIONS);
-      break;
   }
   animation_settings_->SetTransitionDuration(
       GetAnimationDuration(animation_type));
--- a/ash/wm/overview/scoped_overview_animation_settings.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/overview/scoped_overview_animation_settings.h	2019-05-17 18:53:08.368000000 +0300
@@ -16,21 +16,17 @@
 
 namespace ui {
 class ImplicitAnimationObserver;
-class LayerAnimator;
 class ScopedLayerAnimationSettings;
 }  // namespace ui
 
 namespace ash {
 
 // ScopedOverviewAnimationSettings correctly configures the animation
-// settings for an aura::Window or ui::LayerAnimator given an
-// OverviewAnimationType.
+// settings for an aura::Window given an OverviewAnimationType.
 class ScopedOverviewAnimationSettings {
  public:
   ScopedOverviewAnimationSettings(OverviewAnimationType animation_type,
                                   aura::Window* window);
-  ScopedOverviewAnimationSettings(OverviewAnimationType animation_type,
-                                  ui::LayerAnimator* animator);
   ~ScopedOverviewAnimationSettings();
   void AddObserver(ui::ImplicitAnimationObserver* observer);
   void CacheRenderSurface();
--- a/ash/wm/overview/scoped_overview_transform_window.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/overview/scoped_overview_transform_window.cc	2019-05-17 18:53:08.368000000 +0300
@@ -14,23 +14,24 @@
 #include "ash/wm/overview/overview_controller.h"
 #include "ash/wm/overview/overview_grid.h"
 #include "ash/wm/overview/overview_item.h"
+#include "ash/wm/overview/overview_session.h"
 #include "ash/wm/overview/overview_utils.h"
 #include "ash/wm/overview/scoped_overview_animation_settings.h"
 #include "ash/wm/overview/start_animation_observer.h"
-#include "ash/wm/tablet_mode/tablet_mode_controller.h"
 #include "ash/wm/window_preview_view.h"
 #include "ash/wm/window_state.h"
 #include "ash/wm/window_transient_descendant_iterator.h"
 #include "ash/wm/window_util.h"
-#include "base/bind.h"
 #include "base/macros.h"
 #include "base/single_thread_task_runner.h"
 #include "base/threading/thread_task_runner_handle.h"
 #include "ui/aura/client/aura_constants.h"
+#include "ui/aura/null_window_targeter.h"
 #include "ui/aura/window.h"
 #include "ui/compositor/layer.h"
 #include "ui/compositor/layer_observer.h"
 #include "ui/compositor/paint_recorder.h"
+#include "ui/gfx/geometry/rect.h"
 #include "ui/gfx/geometry/safe_integer_conversions.h"
 #include "ui/gfx/transform_util.h"
 #include "ui/views/widget/widget.h"
@@ -169,48 +170,49 @@
 };
 
 ScopedOverviewTransformWindow::ScopedOverviewTransformWindow(
-    OverviewItem* overview_item,
+    OverviewItem* selector_item,
     aura::Window* window)
-    : overview_item_(overview_item),
+    : selector_item_(selector_item),
       window_(window),
       original_opacity_(window->layer()->GetTargetOpacity()),
       original_mask_layer_(window_->layer()->layer_mask_layer()),
       weak_ptr_factory_(this) {
   type_ = GetWindowDimensionsType(window);
-  original_event_targeting_policy_ = window_->event_targeting_policy();
-  window_->SetEventTargetingPolicy(ws::mojom::EventTargetingPolicy::NONE);
+  original_targeter_ =
+      window_->SetEventTargeter(std::make_unique<aura::NullWindowTargeter>());
+  null_targeter_ = window_->targeter();
 }
 
 ScopedOverviewTransformWindow::~ScopedOverviewTransformWindow() {
-  window_->SetEventTargetingPolicy(original_event_targeting_policy_);
-  UpdateMask(/*show=*/false);
+  if (null_targeter_ == window_->targeter())
+    window_->SetEventTargeter(std::move(original_targeter_));
+
   StopObservingImplicitAnimations();
 }
 
 // static
-float ScopedOverviewTransformWindow::GetItemScale(const gfx::SizeF& source,
-                                                  const gfx::SizeF& target,
+float ScopedOverviewTransformWindow::GetItemScale(const gfx::Size& source,
+                                                  const gfx::Size& target,
                                                   int top_view_inset,
                                                   int title_height) {
-  return std::min(2.0f, (target.height() - title_height) /
+  return std::min(2.0f, static_cast<float>((target.height() - title_height)) /
                             (source.height() - top_view_inset));
 }
 
 // static
 gfx::Transform ScopedOverviewTransformWindow::GetTransformForRect(
-    const gfx::RectF& src_rect,
-    const gfx::RectF& dst_rect) {
+    const gfx::Rect& src_rect,
+    const gfx::Rect& dst_rect) {
   DCHECK(!src_rect.IsEmpty());
   gfx::Transform transform;
   transform.Translate(dst_rect.x() - src_rect.x(), dst_rect.y() - src_rect.y());
-  transform.Scale(dst_rect.width() / src_rect.width(),
-                  dst_rect.height() / src_rect.height());
+  transform.Scale(static_cast<float>(dst_rect.width()) / src_rect.width(),
+                  static_cast<float>(dst_rect.height()) / src_rect.height());
   return transform;
 }
 
-void ScopedOverviewTransformWindow::RestoreWindow(
-    bool reset_transform,
-    OverviewSession::EnterExitOverviewType type) {
+void ScopedOverviewTransformWindow::RestoreWindow(bool reset_transform,
+                                                  bool use_slide_animation) {
   // Shadow controller may be null on shutdown.
   if (Shell::Get()->shadow_controller())
     Shell::Get()->shadow_controller()->UpdateShadowForWindow(window_);
@@ -219,13 +221,15 @@
     // lifetime of |this|.
     FadeOutWidgetAndMaybeSlideOnExit(
         std::move(minimized_widget_),
-        GetExitOverviewAnimationTypeForMinimizedWindow(type));
+        use_slide_animation ? OVERVIEW_ANIMATION_EXIT_TO_HOME_LAUNCHER
+                            : OVERVIEW_ANIMATION_EXIT_OVERVIEW_MODE_FADE_OUT,
+        use_slide_animation);
     return;
   }
 
   if (reset_transform) {
     ScopedAnimationSettings animation_settings_list;
-    BeginScopedAnimation(overview_item_->GetExitTransformAnimationType(),
+    BeginScopedAnimation(selector_item_->GetExitTransformAnimationType(),
                          &animation_settings_list);
     // Use identity transform directly to reset window's transform when exiting
     // overview.
@@ -242,7 +246,7 @@
   }
 
   ScopedOverviewAnimationSettings animation_settings(
-      overview_item_->GetExitOverviewAnimationType(), window_);
+      selector_item_->GetExitOverviewAnimationType(), window_);
   SetOpacity(original_opacity_);
   window_->layer()->SetMaskLayer(original_mask_layer_);
 }
@@ -253,6 +257,11 @@
   if (animation_type == OVERVIEW_ANIMATION_NONE)
     return;
 
+  // Remove the mask before animating because masks affect animation
+  // performance. Observe the animation and add the mask after animating if the
+  // animation type is layouting selector items during overview.
+  selector_item_->UpdateMaskAndShadow(/*show=*/false);
+
   for (auto* window : wm::GetTransientTreeIterator(GetOverviewWindow())) {
     auto settings = std::make_unique<ScopedOverviewAnimationSettings>(
         animation_type, window);
@@ -260,7 +269,7 @@
 
     // Create a start animation observer if this is an enter overview layout
     // animation.
-    if (animation_type == OVERVIEW_ANIMATION_LAYOUT_OVERVIEW_ITEMS_ON_ENTER) {
+    if (animation_type == OVERVIEW_ANIMATION_LAY_OUT_SELECTOR_ITEMS_ON_ENTER) {
       auto start_observer = std::make_unique<StartAnimationObserver>();
       settings->AddObserver(start_observer.get());
       Shell::Get()->overview_controller()->AddStartAnimationObserver(
@@ -270,7 +279,7 @@
     animation_settings->push_back(std::move(settings));
   }
 
-  if (animation_type == OVERVIEW_ANIMATION_LAYOUT_OVERVIEW_ITEMS_IN_OVERVIEW &&
+  if (animation_type == OVERVIEW_ANIMATION_LAY_OUT_SELECTOR_ITEMS_IN_OVERVIEW &&
       animation_settings->size() > 0u) {
     animation_settings->front()->AddObserver(this);
   }
@@ -281,13 +290,11 @@
     if (window->Contains(target))
       return true;
   }
-
-  if (!minimized_widget_)
-    return false;
-  return minimized_widget_->GetNativeWindow()->Contains(target);
+  aura::Window* mirror = GetOverviewWindowForMinimizedState();
+  return mirror && mirror->Contains(target);
 }
 
-gfx::RectF ScopedOverviewTransformWindow::GetTransformedBounds() const {
+gfx::Rect ScopedOverviewTransformWindow::GetTransformedBounds() const {
   return ::ash::GetTransformedBounds(GetOverviewWindow(), GetTopInset());
 }
 
@@ -330,21 +337,23 @@
   }
 }
 
-gfx::RectF ScopedOverviewTransformWindow::ShrinkRectToFitPreservingAspectRatio(
-    const gfx::RectF& rect,
-    const gfx::RectF& bounds,
+gfx::Rect ScopedOverviewTransformWindow::ShrinkRectToFitPreservingAspectRatio(
+    const gfx::Rect& rect,
+    const gfx::Rect& bounds,
     int top_view_inset,
     int title_height) {
   DCHECK(!rect.IsEmpty());
   DCHECK_LE(top_view_inset, rect.height());
   const float scale =
       GetItemScale(rect.size(), bounds.size(), top_view_inset, title_height);
-  const float horizontal_offset = 0.5 * (bounds.width() - scale * rect.width());
-  const float width = bounds.width() - 2.f * horizontal_offset;
-  const float vertical_offset = title_height - scale * top_view_inset;
-  const float height =
-      std::min(scale * rect.height(), bounds.height() - vertical_offset);
-  gfx::RectF new_bounds(bounds.x() + horizontal_offset,
+  const int horizontal_offset = gfx::ToFlooredInt(
+      0.5 * (bounds.width() - gfx::ToFlooredInt(scale * rect.width())));
+  const int width = bounds.width() - 2 * horizontal_offset;
+  const int vertical_offset =
+      title_height - gfx::ToCeiledInt(scale * top_view_inset);
+  const int height = std::min(gfx::ToCeiledInt(scale * rect.height()),
+                              bounds.height() - vertical_offset);
+  gfx::Rect new_bounds(bounds.x() + horizontal_offset,
                         bounds.y() + vertical_offset, width, height);
 
   switch (type()) {
@@ -356,13 +365,15 @@
       const bool is_pillar =
           type() ==
           ScopedOverviewTransformWindow::GridWindowFillMode::kPillarBoxed;
-      gfx::RectF src = rect;
+      gfx::Rect src = rect;
       new_bounds = bounds;
       src.Inset(0, top_view_inset, 0, 0);
       new_bounds.Inset(0, title_height, 0, 0);
-      float scale = is_pillar ? new_bounds.height() / src.height()
-                              : new_bounds.width() / src.width();
-      gfx::SizeF size(is_pillar ? src.width() * scale : new_bounds.width(),
+      float scale = is_pillar ? static_cast<float>(new_bounds.height()) /
+                                    static_cast<float>(src.height())
+                              : static_cast<float>(new_bounds.width()) /
+                                    static_cast<float>(src.width());
+      gfx::Size size(is_pillar ? src.width() * scale : new_bounds.width(),
                       is_pillar ? new_bounds.height() : src.height() * scale);
       new_bounds.ClampToCenteredSize(size);
 
@@ -432,7 +443,7 @@
 
 aura::Window* ScopedOverviewTransformWindow::GetOverviewWindow() const {
   if (minimized_widget_)
-    return minimized_widget_->GetNativeWindow();
+    return GetOverviewWindowForMinimizedState();
   return window_;
 }
 
@@ -440,20 +451,24 @@
   original_opacity_ = 1.f;
 }
 
+aura::Window*
+ScopedOverviewTransformWindow::GetOverviewWindowForMinimizedState() const {
+  return minimized_widget_ ? minimized_widget_->GetNativeWindow() : nullptr;
+}
+
 void ScopedOverviewTransformWindow::UpdateWindowDimensionsType() {
   type_ = GetWindowDimensionsType(window_);
   overview_bounds_.reset();
 }
 
 void ScopedOverviewTransformWindow::UpdateMask(bool show) {
-  if (!base::FeatureList::IsEnabled(features::kEnableOverviewRoundedCorners) ||
-      !show) {
+  if (!show) {
     mask_.reset();
     return;
   }
 
-  // Add the mask which gives the overview item rounded corners, and add the
-  // shadow around the window.
+  // Add the mask which gives the window selector items rounded corners, and add
+  // the shadow around the window.
   ui::Layer* layer = minimized_widget_
                          ? minimized_widget_->GetNativeWindow()->layer()
                          : window_->layer();
@@ -496,16 +511,9 @@
   minimized_widget_->SetContentsView(preview_view);
 }
 
-void ScopedOverviewTransformWindow::OnLayerAnimationStarted(
-    ui::LayerAnimationSequence* sequence) {
-  // Remove the mask before animating because masks affect animation
-  // performance. The mask will be added back once the animation is completed.
-  overview_item_->UpdateMaskAndShadow();
-}
-
 void ScopedOverviewTransformWindow::OnImplicitAnimationsCompleted() {
-  overview_item_->UpdateMaskAndShadow();
-  overview_item_->OnDragAnimationCompleted();
+  selector_item_->UpdateMaskAndShadow(/*show=*/true);
+  selector_item_->OnDragAnimationCompleted();
 }
 
 gfx::Rect ScopedOverviewTransformWindow::GetMaskBoundsForTesting() const {
@@ -542,10 +550,7 @@
     bounds.Inset(0, 0, 0, inset);
   }
   minimized_widget_->SetBounds(bounds);
-  minimized_widget_->SetVisibilityAnimationTransition(
-      views::Widget::ANIMATE_NONE);
   minimized_widget_->Show();
-  minimized_widget_->SetOpacity(0.f);
 
   // Stack the minimized window at the bottom since it is never transformed in
   // and only faded in, so it should always be underneath non minimized windows.
@@ -556,24 +561,4 @@
       /*slide=*/false);
 }
 
-OverviewAnimationType
-ScopedOverviewTransformWindow::GetExitOverviewAnimationTypeForMinimizedWindow(
-    OverviewSession::EnterExitOverviewType type) {
-  // EnterExitOverviewType can only be set to kWindowMinimized in talbet mode.
-  // Fade out the minimized window without animation if switch from tablet mode
-  // to clamshell mode.
-  if (type == OverviewSession::EnterExitOverviewType::kWindowsMinimized) {
-    return Shell::Get()
-                   ->tablet_mode_controller()
-                   ->IsTabletModeWindowManagerEnabled()
-               ? OVERVIEW_ANIMATION_EXIT_TO_HOME_LAUNCHER
-               : OVERVIEW_ANIMATION_NONE;
-  }
-
-  DCHECK(overview_item_);
-  return overview_item_->should_animate_when_exiting()
-             ? OVERVIEW_ANIMATION_EXIT_OVERVIEW_MODE_FADE_OUT
-             : OVERVIEW_ANIMATION_RESTORE_WINDOW_ZERO;
-}
-
 }  // namespace ash
--- a/ash/wm/overview/scoped_overview_transform_window.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/overview/scoped_overview_transform_window.h	2019-05-17 18:53:08.368000000 +0300
@@ -10,19 +10,21 @@
 
 #include "ash/ash_export.h"
 #include "ash/wm/overview/overview_animation_type.h"
-#include "ash/wm/overview/overview_session.h"
 #include "base/macros.h"
 #include "base/memory/weak_ptr.h"
 #include "base/optional.h"
-#include "services/ws/public/mojom/window_tree_constants.mojom.h"
 #include "ui/compositor/layer_animation_observer.h"
 #include "ui/gfx/geometry/rect.h"
-#include "ui/gfx/geometry/rect_f.h"
 #include "ui/gfx/geometry/size.h"
 #include "ui/gfx/transform.h"
 
 namespace aura {
 class Window;
+class WindowTargeter;
+}  // namespace aura
+
+namespace gfx {
+class Rect;
 }
 
 namespace ui {
@@ -64,16 +66,16 @@
 
   // Calculates and returns an optimal scale ratio. This is only taking into
   // account |size.height()| as the width can vary.
-  static float GetItemScale(const gfx::SizeF& source,
-                            const gfx::SizeF& target,
+  static float GetItemScale(const gfx::Size& source,
+                            const gfx::Size& target,
                             int top_view_inset,
                             int title_height);
 
   // Returns the transform turning |src_rect| into |dst_rect|.
-  static gfx::Transform GetTransformForRect(const gfx::RectF& src_rect,
-                                            const gfx::RectF& dst_rect);
+  static gfx::Transform GetTransformForRect(const gfx::Rect& src_rect,
+                                            const gfx::Rect& dst_rect);
 
-  ScopedOverviewTransformWindow(OverviewItem* overview_item,
+  ScopedOverviewTransformWindow(OverviewItem* selector_item,
                                 aura::Window* window);
   ~ScopedOverviewTransformWindow() override;
 
@@ -95,12 +97,12 @@
   void BeginScopedAnimation(OverviewAnimationType animation_type,
                             ScopedAnimationSettings* animation_settings);
 
-  // Returns true if this overview window contains the |target|.
+  // Returns true if this window selector window contains the |target|.
   bool Contains(const aura::Window* target) const;
 
   // Returns transformed bounds of the overview window. See
   // OverviewUtil::GetTransformedBounds for more details.
-  gfx::RectF GetTransformedBounds() const;
+  gfx::Rect GetTransformedBounds() const;
 
   // Returns the kTopViewInset property of |window_| unless there are transient
   // ancestors, in which case returns 0.
@@ -110,8 +112,7 @@
   // If |reset_transform| equals false, the window's transform will not be reset
   // to identity transform when exiting the overview mode. See
   // OverviewItem::RestoreWindow() for details why we need this.
-  void RestoreWindow(bool reset_transform,
-                     OverviewSession::EnterExitOverviewType type);
+  void RestoreWindow(bool reset_transform, bool use_slide_animation);
 
   // Informs the ScopedOverviewTransformWindow that the window being watched was
   // destroyed. This resets the internal window pointer.
@@ -131,8 +132,8 @@
   // tall in the original window getting replaced by a window caption that is
   // |title_height| tall in the transformed window. If |type_| is not normal,
   // write |overview_bounds_|, which would differ than the return bounds.
-  gfx::RectF ShrinkRectToFitPreservingAspectRatio(const gfx::RectF& rect,
-                                                  const gfx::RectF& bounds,
+  gfx::Rect ShrinkRectToFitPreservingAspectRatio(const gfx::Rect& rect,
+                                                 const gfx::Rect& bounds,
                                                   int top_view_inset,
                                                   int title_height);
 
@@ -140,9 +141,7 @@
 
   GridWindowFillMode type() const { return type_; }
 
-  base::Optional<gfx::RectF> overview_bounds() const {
-    return overview_bounds_;
-  }
+  base::Optional<gfx::Rect> overview_bounds() const { return overview_bounds_; }
 
   // Closes the transient root of the window managed by |this|.
   void Close();
@@ -154,6 +153,10 @@
   // Ensures that a window is visible by setting its opacity to 1.
   void EnsureVisible();
 
+  // Returns an overview window created for minimized window, or nullptr if it
+  // does not exist.
+  aura::Window* GetOverviewWindowForMinimizedState() const;
+
   // Called via OverviewItem from OverviewGrid when |window_|'s bounds
   // change. Must be called before PositionWindows in OverviewGrid.
   void UpdateWindowDimensionsType();
@@ -175,7 +178,6 @@
   views::Widget* minimized_widget() { return minimized_widget_.get(); }
 
   // ui::ImplicitAnimationObserver:
-  void OnLayerAnimationStarted(ui::LayerAnimationSequence* sequence) override;
   void OnImplicitAnimationsCompleted() override;
 
   gfx::Rect GetMaskBoundsForTesting() const;
@@ -192,14 +194,11 @@
 
   void CreateMirrorWindowForMinimizedState();
 
-  OverviewAnimationType GetExitOverviewAnimationTypeForMinimizedWindow(
-      OverviewSession::EnterExitOverviewType type);
-
   // Makes Close() execute synchronously when used in tests.
   static void SetImmediateCloseForTests();
 
-  // A weak pointer to the overview item that owns the transform window.
-  OverviewItem* overview_item_;
+  // A weak pointer to the window selector item that owns the transform window.
+  OverviewItem* selector_item_;
 
   // A weak pointer to the real window in the overview.
   aura::Window* window_;
@@ -213,17 +212,12 @@
   // The original opacity of the window before entering overview mode.
   float original_opacity_;
 
-  // For the duration of this object |window_| event targeting policy will be
-  // sent to NONE. Store the original so we can change it back when destroying
-  // this object.
-  ws::mojom::EventTargetingPolicy original_event_targeting_policy_;
-
   // Specifies how the window is laid out in the grid.
   GridWindowFillMode type_ = GridWindowFillMode::kNormal;
 
-  // Empty if window is of type normal. Contains the bounds the overview item
-  // should be if the window is too wide or too tall.
-  base::Optional<gfx::RectF> overview_bounds_;
+  // Empty if window is of type normal. Contains the bounds the window selector
+  // item should be if the window is too wide or too tall.
+  base::Optional<gfx::Rect> overview_bounds_;
 
   // A widget that holds the content for the minimized window.
   std::unique_ptr<views::Widget> minimized_widget_;
@@ -241,6 +235,15 @@
   // The original mask layer of the window before entering overview mode.
   ui::Layer* original_mask_layer_ = nullptr;
 
+  // Stores the targeter for the window. For the duration of this object,
+  // |window_|'s event targeter will be replaced by a NullWindowTargeter to
+  // prevent events from reaching |window_|.
+  // TODO(sammiequon): Investigate if we can use a custom event targeter on
+  // windows for overview mode and remove the need for the extra widget which
+  // blocks events in OverviewItem.
+  std::unique_ptr<aura::WindowTargeter> original_targeter_;
+  aura::WindowTargeter* null_targeter_ = nullptr;
+
   base::WeakPtrFactory<ScopedOverviewTransformWindow> weak_ptr_factory_;
 
   DISALLOW_COPY_AND_ASSIGN(ScopedOverviewTransformWindow);
--- a/ash/wm/overview/scoped_overview_transform_window_unittest.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/overview/scoped_overview_transform_window_unittest.cc	2019-05-17 18:53:08.368000000 +0300
@@ -15,8 +15,8 @@
 
 namespace {
 
-float GetItemScale(const gfx::RectF& source,
-                   const gfx::RectF& target,
+float GetItemScale(const gfx::Rect& source,
+                   const gfx::Rect& target,
                    int top_view_inset,
                    int title_height) {
   return ScopedOverviewTransformWindow::GetItemScale(
@@ -38,36 +38,36 @@
       CreateTestWindow(gfx::Rect(10, 10, 100, 100));
   ScopedOverviewTransformWindow transform_window(nullptr, window.get());
 
-  gfx::RectF rect(50.f, 50.f, 200.f, 400.f);
-  gfx::RectF bounds(100.f, 100.f, 50.f, 50.f);
-  gfx::RectF transformed_rect =
+  gfx::Rect rect(50, 50, 200, 400);
+  gfx::Rect bounds(100, 100, 50, 50);
+  gfx::Rect transformed_rect =
       transform_window.ShrinkRectToFitPreservingAspectRatio(rect, bounds, 0, 0);
   float scale = GetItemScale(rect, bounds, 0, 0);
   EXPECT_NEAR(scale * rect.width(), transformed_rect.width(), 1);
   EXPECT_NEAR(scale * rect.height(), transformed_rect.height(), 1);
 
-  rect = gfx::RectF(50.f, 50.f, 400.f, 200.f);
+  rect = gfx::Rect(50, 50, 400, 200);
   scale = GetItemScale(rect, bounds, 0, 0);
   transformed_rect =
       transform_window.ShrinkRectToFitPreservingAspectRatio(rect, bounds, 0, 0);
   EXPECT_NEAR(scale * rect.width(), transformed_rect.width(), 1);
   EXPECT_NEAR(scale * rect.height(), transformed_rect.height(), 1);
 
-  rect = gfx::RectF(50.f, 50.f, 25.f, 25.f);
+  rect = gfx::Rect(50, 50, 25, 25);
   scale = GetItemScale(rect, bounds, 0, 0);
   transformed_rect =
       transform_window.ShrinkRectToFitPreservingAspectRatio(rect, bounds, 0, 0);
   EXPECT_NEAR(scale * rect.width(), transformed_rect.width(), 1);
   EXPECT_NEAR(scale * rect.height(), transformed_rect.height(), 1);
 
-  rect = gfx::RectF(50.f, 50.f, 25.f, 50.f);
+  rect = gfx::Rect(50, 50, 25, 50);
   scale = GetItemScale(rect, bounds, 0, 0);
   transformed_rect =
       transform_window.ShrinkRectToFitPreservingAspectRatio(rect, bounds, 0, 0);
   EXPECT_NEAR(scale * rect.width(), transformed_rect.width(), 1);
   EXPECT_NEAR(scale * rect.height(), transformed_rect.height(), 1);
 
-  rect = gfx::RectF(50.f, 50.f, 50.f, 25.f);
+  rect = gfx::Rect(50, 50, 50, 25);
   scale = GetItemScale(rect, bounds, 0, 0);
   transformed_rect =
       transform_window.ShrinkRectToFitPreservingAspectRatio(rect, bounds, 0, 0);
@@ -80,9 +80,9 @@
   std::unique_ptr<aura::Window> window =
       CreateTestWindow(gfx::Rect(10, 10, 100, 100));
   ScopedOverviewTransformWindow transform_window(nullptr, window.get());
-  gfx::RectF rect(50.f, 50.f, 200.f, 400.f);
-  gfx::RectF bounds(100.f, 100.f, 50.f, 50.f);
-  gfx::RectF transformed_rect =
+  gfx::Rect rect(50, 50, 200, 400);
+  gfx::Rect bounds(100, 100, 50, 50);
+  gfx::Rect transformed_rect =
       transform_window.ShrinkRectToFitPreservingAspectRatio(rect, bounds, 0, 0);
   EXPECT_GE(transformed_rect.x(), bounds.x());
   EXPECT_LE(transformed_rect.right(), bounds.right());
@@ -100,12 +100,12 @@
   std::unique_ptr<aura::Window> window =
       CreateTestWindow(gfx::Rect(10, 10, 100, 100));
   ScopedOverviewTransformWindow transform_window(nullptr, window.get());
-  gfx::RectF rect(50.f, 50.f, 400.f, 200.f);
-  gfx::RectF bounds(100.f, 100.f, 50.f, 50.f);
+  gfx::Rect rect(50, 50, 400, 200);
+  gfx::Rect bounds(100, 100, 50, 50);
   const int inset = 20;
   const int header_height = 10;
   const float scale = GetItemScale(rect, bounds, inset, header_height);
-  gfx::RectF transformed_rect =
+  gfx::Rect transformed_rect =
       transform_window.ShrinkRectToFitPreservingAspectRatio(rect, bounds, inset,
                                                             header_height);
   // The |rect| width does not fit and therefore it gets centered outside
@@ -136,10 +136,10 @@
 
   // Without any headers, the width should match the target, and the height
   // should be such that the aspect ratio of |original_bounds| is maintained.
-  const gfx::RectF overview_bounds(100.f, 100.f);
-  gfx::RectF transformed_rect =
+  const gfx::Rect overview_bounds(0, 0, 100, 100);
+  gfx::Rect transformed_rect =
       transform_window.ShrinkRectToFitPreservingAspectRatio(
-          gfx::RectF(original_bounds), overview_bounds, 0, 0);
+          original_bounds, overview_bounds, 0, 0);
   EXPECT_EQ(overview_bounds.width(), transformed_rect.width());
   EXPECT_NEAR(overview_bounds.height() / scale, transformed_rect.height(), 1);
 
@@ -149,19 +149,18 @@
   const int original_header = 10;
   const int overview_header = 20;
   transformed_rect = transform_window.ShrinkRectToFitPreservingAspectRatio(
-      gfx::RectF(original_bounds), overview_bounds, original_header,
-      overview_header);
+      original_bounds, overview_bounds, original_header, overview_header);
   EXPECT_EQ(overview_bounds.width(), transformed_rect.width());
   EXPECT_NEAR((overview_bounds.height() - original_header) / scale,
               transformed_rect.height() - original_header / scale, 1);
   EXPECT_TRUE(overview_bounds.Contains(transformed_rect));
 
   // Verify that for an extreme window, the transform window stores the
-  // original overview item bounds, minus the header.
-  gfx::RectF new_overview_bounds = overview_bounds;
-  new_overview_bounds.Inset(0, overview_header, 0, 0);
+  // original window selector bounds, minus the header.
+  gfx::Rect selector_bounds = overview_bounds;
+  selector_bounds.Inset(0, overview_header, 0, 0);
   ASSERT_TRUE(transform_window.overview_bounds().has_value());
-  EXPECT_EQ(transform_window.overview_bounds().value(), new_overview_bounds);
+  EXPECT_EQ(transform_window.overview_bounds().value(), selector_bounds);
 }
 
 // Verify that a window which will be displayed like a pillar box on the window
@@ -177,10 +176,10 @@
 
   // Without any headers, the height should match the target, and the width
   // should be such that the aspect ratio of |original_bounds| is maintained.
-  const gfx::RectF overview_bounds(100.f, 100.f);
-  gfx::RectF transformed_rect =
+  const gfx::Rect overview_bounds(0, 0, 100, 100);
+  gfx::Rect transformed_rect =
       transform_window.ShrinkRectToFitPreservingAspectRatio(
-          gfx::RectF(original_bounds), overview_bounds, 0, 0);
+          original_bounds, overview_bounds, 0, 0);
   EXPECT_EQ(overview_bounds.height(), transformed_rect.height());
   EXPECT_NEAR(overview_bounds.width() / scale, transformed_rect.width(), 1);
 
@@ -190,18 +189,17 @@
   const int original_header = 10;
   const int overview_header = 20;
   transformed_rect = transform_window.ShrinkRectToFitPreservingAspectRatio(
-      gfx::RectF(original_bounds), overview_bounds, original_header,
-      overview_header);
+      original_bounds, overview_bounds, original_header, overview_header);
   EXPECT_NEAR(overview_bounds.height() - overview_header,
               transformed_rect.height() - original_header / scale, 1);
   EXPECT_TRUE(overview_bounds.Contains(transformed_rect));
 
   // Verify that for an extreme window, the transform window stores the
-  // original overview item bounds, minus the header.
-  gfx::RectF new_overview_bounds = overview_bounds;
-  new_overview_bounds.Inset(0, overview_header, 0, 0);
+  // original window selector bounds, minus the header.
+  gfx::Rect selector_bounds = overview_bounds;
+  selector_bounds.Inset(0, overview_header, 0, 0);
   ASSERT_TRUE(transform_window.overview_bounds().has_value());
-  EXPECT_EQ(transform_window.overview_bounds().value(), new_overview_bounds);
+  EXPECT_EQ(transform_window.overview_bounds().value(), selector_bounds);
 }
 
 // Tests the cases when very wide or tall windows enter overview mode.
--- a/ash/wm/pip/pip_positioner.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/pip/pip_positioner.cc	2019-05-17 18:53:08.368000000 +0300
@@ -16,7 +16,6 @@
 #include "ui/aura/window.h"
 #include "ui/gfx/geometry/insets.h"
 #include "ui/keyboard/keyboard_controller.h"
-#include "ui/wm/core/coordinate_conversion.h"
 
 namespace ash {
 
@@ -88,7 +87,6 @@
         continue;
       // Use the target bounds in case an animation is in progress.
       rects.push_back(window->GetTargetBounds());
-      ::wm::ConvertRectToScreen(root_window, &rects.back());
       rects.back().Inset(-kPipWorkAreaInsetsDp, -kPipWorkAreaInsetsDp);
     }
   }
@@ -100,7 +98,6 @@
       keyboard_controller->GetRootWindow() == root_window &&
       !keyboard_controller->visual_bounds_in_screen().IsEmpty()) {
     rects.push_back(keyboard_controller->visual_bounds_in_screen());
-    ::wm::ConvertRectToScreen(root_window, &rects.back());
     rects.back().Inset(-kPipWorkAreaInsetsDp, -kPipWorkAreaInsetsDp);
   }
 
@@ -189,15 +186,13 @@
 
 gfx::Rect PipPositioner::GetMovementArea(const display::Display& display) {
   gfx::Rect work_area = display.work_area();
+  auto* keyboard_controller = keyboard::KeyboardController::Get();
 
   // Include keyboard if it's not floating.
-  auto* keyboard_controller = keyboard::KeyboardController::Get();
   if (keyboard_controller->IsEnabled() &&
       keyboard_controller->GetActiveContainerType() !=
           keyboard::mojom::ContainerType::kFloating) {
     gfx::Rect keyboard_bounds = keyboard_controller->visual_bounds_in_screen();
-    ::wm::ConvertRectToScreen(Shell::GetRootWindowForDisplayId(display.id()),
-                              &keyboard_bounds);
     work_area.Subtract(keyboard_bounds);
   }
 
@@ -206,16 +201,16 @@
 }
 
 gfx::Rect PipPositioner::GetBoundsForDrag(const display::Display& display,
-                                          const gfx::Rect& bounds_in_screen) {
-  gfx::Rect drag_bounds = bounds_in_screen;
+                                          const gfx::Rect& bounds) {
+  gfx::Rect drag_bounds = bounds;
   drag_bounds.AdjustToFit(GetMovementArea(display));
   drag_bounds = AvoidObstacles(display, drag_bounds);
   return drag_bounds;
 }
 
 gfx::Rect PipPositioner::GetRestingPosition(const display::Display& display,
-                                            const gfx::Rect& bounds_in_screen) {
-  gfx::Rect resting_bounds = bounds_in_screen;
+                                            const gfx::Rect& bounds) {
+  gfx::Rect resting_bounds = bounds;
   gfx::Rect area = GetMovementArea(display);
   resting_bounds.AdjustToFit(area);
 
@@ -224,24 +219,21 @@
   return AvoidObstacles(display, resting_bounds);
 }
 
-gfx::Rect PipPositioner::GetDismissedPosition(
-    const display::Display& display,
-    const gfx::Rect& bounds_in_screen) {
+gfx::Rect PipPositioner::GetDismissedPosition(const display::Display& display,
+                                              const gfx::Rect& bounds) {
   gfx::Rect work_area = GetMovementArea(display);
-  const int gravity = GetGravityToClosestEdge(bounds_in_screen, work_area);
+  const int gravity = GetGravityToClosestEdge(bounds, work_area);
   // Allow the bounds to move at most |kPipDismissMovementProportion| of the
   // length of the bounds in the direction of movement.
-  gfx::Rect bounds_movement_area = bounds_in_screen;
-  bounds_movement_area.Inset(
-      -bounds_in_screen.width() * kPipDismissMovementProportion,
-      -bounds_in_screen.height() * kPipDismissMovementProportion);
-  gfx::Rect dismissed_bounds = GetAdjustedBoundsByGravity(
-      bounds_in_screen, bounds_movement_area, gravity);
+  gfx::Rect bounds_movement_area = bounds;
+  bounds_movement_area.Inset(-bounds.width() * kPipDismissMovementProportion,
+                             -bounds.height() * kPipDismissMovementProportion);
+  gfx::Rect dismissed_bounds =
+      GetAdjustedBoundsByGravity(bounds, bounds_movement_area, gravity);
 
   // If the PIP window isn't close enough to the edge of the screen, don't slide
   // it out.
-  return work_area.Intersects(dismissed_bounds) ? bounds_in_screen
-                                                : dismissed_bounds;
+  return work_area.Intersects(dismissed_bounds) ? bounds : dismissed_bounds;
 }
 
 gfx::Rect PipPositioner::GetPositionAfterMovementAreaChange(
@@ -249,15 +241,14 @@
   // Restore to previous bounds if we have them. This lets us move the PIP
   // window back to its original bounds after transient movement area changes,
   // like the keyboard popping up and pushing the PIP window up.
-  const gfx::Rect bounds_in_screen =
-      window_state->HasRestoreBounds()
+  const gfx::Rect bounds = window_state->HasRestoreBounds()
           ? window_state->GetRestoreBoundsInScreen()
           : window_state->window()->GetBoundsInScreen();
-  return GetRestingPosition(window_state->GetDisplay(), bounds_in_screen);
+  return GetRestingPosition(window_state->GetDisplay(), bounds);
 }
 
 gfx::Rect PipPositioner::AvoidObstacles(const display::Display& display,
-                                        const gfx::Rect& bounds_in_screen) {
+                                        const gfx::Rect& bounds) {
   gfx::Rect work_area = GetMovementArea(display);
   auto rects = CollectCollisionRects(display);
   // The worst case for this should be: floating keyboard + one system tray +
@@ -266,34 +257,32 @@
                                 "should be optimized if there are a lot of "
                                 "windows. Please see crrev.com/c/1221427 for a "
                                 "description of an N^2 algorithm.";
-  return AvoidObstaclesInternal(work_area, rects, bounds_in_screen);
+  return AvoidObstaclesInternal(work_area, rects, bounds);
 }
 
 gfx::Rect PipPositioner::AvoidObstaclesInternal(
     const gfx::Rect& work_area,
     const std::vector<gfx::Rect>& rects,
-    const gfx::Rect& bounds_in_screen) {
+    const gfx::Rect& bounds) {
   gfx::Rect inset_work_area = work_area;
 
   // For even sized bounds, there is no 'center' integer point, so we need
   // to adjust the obstacles and work area to account for this.
-  inset_work_area.Inset(
-      bounds_in_screen.width() / 2, bounds_in_screen.height() / 2,
-      (bounds_in_screen.width() - 1) / 2, (bounds_in_screen.height() - 1) / 2);
+  inset_work_area.Inset(bounds.width() / 2, bounds.height() / 2,
+                        (bounds.width() - 1) / 2, (bounds.height() - 1) / 2);
   std::vector<gfx::Rect> inset_rects(rects);
   for (auto& rect : inset_rects) {
     // Reduce the collision resolution problem from rectangles-rectangle
     // resolution to rectangles-point resolution, by expanding each obstacle
-    // by |bounds_in_screen| size.
-    rect.Inset(-(bounds_in_screen.width() - 1) / 2,
-               -(bounds_in_screen.height() - 1) / 2,
-               -bounds_in_screen.width() / 2, -bounds_in_screen.height() / 2);
+    // by |bounds| size.
+    rect.Inset(-(bounds.width() - 1) / 2, -(bounds.height() - 1) / 2,
+               -bounds.width() / 2, -bounds.height() / 2);
   }
 
   gfx::Point moved_center = ComputeBestCandidatePoint(
-      bounds_in_screen.CenterPoint(), inset_work_area, inset_rects);
-  gfx::Rect moved_bounds = bounds_in_screen;
-  moved_bounds.Offset(moved_center - bounds_in_screen.CenterPoint());
+      bounds.CenterPoint(), inset_work_area, inset_rects);
+  gfx::Rect moved_bounds = bounds;
+  moved_bounds.Offset(moved_center - bounds.CenterPoint());
   return moved_bounds;
 }
 
--- a/ash/wm/pip/pip_positioner.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/pip/pip_positioner.h	2019-05-17 18:53:08.368000000 +0300
@@ -19,8 +19,8 @@
 class WindowState;
 }  // namespace wm
 
-// Computes resting and dragging positions for PIP windows. Note that this
-// class uses only Screen coordinates.
+class PipPositionerTest;
+
 class ASH_EXPORT PipPositioner {
  public:
   static const int kPipDismissTimeMs = 300;
@@ -36,19 +36,20 @@
   // this will be at a screen edge, not in the middle of the screen.
   // TODO(edcourtney): This should consider drag velocity for fling as well.
   static gfx::Rect GetRestingPosition(const display::Display& display,
-                                      const gfx::Rect& bounds_in_screen);
+                                      const gfx::Rect& bounds);
 
   // Adjusts bounds during a drag of a PIP window. For example, this will
   // ensure that the PIP window cannot leave the PIP movement area.
+  // |bounds| is in screen coordinates.
   static gfx::Rect GetBoundsForDrag(const display::Display& display,
-                                    const gfx::Rect& bounds_in_screen);
+                                    const gfx::Rect& bounds);
 
   // Based on the current PIP window position, finds a final location of where
   // the PIP window should be animated to to show a dismissal off the side
   // of the screen. Note that this may return somewhere not off-screen if
   // animating the PIP window off-screen would travel too far.
   static gfx::Rect GetDismissedPosition(const display::Display& display,
-                                        const gfx::Rect& bounds_in_screen);
+                                        const gfx::Rect& bounds);
 
   // Gets the position the PIP window should be moved to after a movement area
   // change. For example, if the shelf is changed from auto-hidden to always
@@ -57,13 +58,12 @@
       wm::WindowState* window_state);
 
  private:
-  friend class PipPositionerDisplayTest;
-  friend class PipPositionerLogicTest;
+  friend class PipPositionerTest;
 
   // Moves |bounds| such that it does not intersect with system ui areas, such
   // as the unified system tray or the floating keyboard.
   static gfx::Rect AvoidObstacles(const display::Display& display,
-                                  const gfx::Rect& bounds_in_screen);
+                                  const gfx::Rect& bounds);
 
   // Internal method for collision resolution. Returns a gfx::Rect with the
   // same size as |bounds|. That rectangle will not intersect any of the
@@ -72,7 +72,7 @@
   // closest such rectangle to |bounds|.
   static gfx::Rect AvoidObstaclesInternal(const gfx::Rect& work_area,
                                           const std::vector<gfx::Rect>& rects,
-                                          const gfx::Rect& bounds_in_screen);
+                                          const gfx::Rect& bounds);
 
   DISALLOW_COPY_AND_ASSIGN(PipPositioner);
 };
--- a/ash/wm/pip/pip_positioner_unittest.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/pip/pip_positioner_unittest.cc	2019-05-17 18:53:08.372000000 +0300
@@ -6,91 +6,52 @@
 
 #include <memory>
 #include <string>
-#include <tuple>
 #include <vector>
 
-#include "ash/root_window_controller.h"
-#include "ash/scoped_root_window_for_new_windows.h"
-#include "ash/shelf/shelf.h"
-#include "ash/shelf/shelf_layout_manager.h"
 #include "ash/shell.h"
 #include "ash/system/unified/unified_system_tray.h"
 #include "ash/test/ash_test_base.h"
 #include "ash/wm/window_state.h"
 #include "ash/wm/wm_event.h"
-#include "base/bind_helpers.h"
 #include "base/command_line.h"
 #include "ui/aura/window.h"
 #include "ui/gfx/geometry/insets.h"
 #include "ui/keyboard/keyboard_controller.h"
 #include "ui/keyboard/public/keyboard_switches.h"
 #include "ui/keyboard/test/keyboard_test_util.h"
-#include "ui/wm/core/coordinate_conversion.h"
 
 namespace ash {
 
 namespace {
 
-display::Display GetDisplayForWindow(aura::Window* window) {
-  return display::Screen::GetScreen()->GetDisplayNearestWindow(window);
-}
-
-gfx::Rect ConvertToScreenForWindow(aura::Window* window,
-                                   const gfx::Rect& bounds) {
-  gfx::Rect new_bounds = bounds;
-  ::wm::ConvertRectToScreen(window->GetRootWindow(), &new_bounds);
-  return new_bounds;
-}
+// WindowState based on a given initial state.
+class FakeWindowState : public wm::WindowState::State {
+ public:
+  explicit FakeWindowState(mojom::WindowStateType initial_state_type)
+      : state_type_(initial_state_type) {}
+  ~FakeWindowState() override = default;
+
+  // WindowState::State overrides:
+  void OnWMEvent(wm::WindowState* window_state,
+                 const wm::WMEvent* event) override {}
+  mojom::WindowStateType GetType() const override { return state_type_; }
+  void AttachState(wm::WindowState* window_state,
+                   wm::WindowState::State* previous_state) override {}
+  void DetachState(wm::WindowState* window_state) override {}
 
-void ForceHideShelves() {
-  for (auto* root_window_controller : Shell::GetAllRootWindowControllers()) {
-    auto* shelf = root_window_controller->shelf();
-    auto* layout_manager = shelf->shelf_layout_manager();
-    shelf->SetAutoHideBehavior(SHELF_AUTO_HIDE_ALWAYS_HIDDEN);
-    layout_manager->LayoutShelf();  // Force layout to end animation.
-  }
-}
+ private:
+  mojom::WindowStateType state_type_;
 
-gfx::Rect ConvertPrimaryToScreen(const gfx::Rect& bounds) {
-  return ConvertToScreenForWindow(Shell::GetPrimaryRootWindow(), bounds);
-}
+  DISALLOW_COPY_AND_ASSIGN(FakeWindowState);
+};
 
 }  // namespace
 
-using PipPositionerTest = AshTestBase;
-
-TEST_F(PipPositionerTest,
-       PipRestingPositionSnapsInDisplayWithLargeAspectRatio) {
-  UpdateDisplay("1600x400");
-
-  // Snap to the top edge instead of the far left edge.
-  EXPECT_EQ(ConvertPrimaryToScreen(gfx::Rect(500, 8, 100, 100)),
-            PipPositioner::GetRestingPosition(
-                GetPrimaryDisplay(),
-                ConvertPrimaryToScreen(gfx::Rect(500, 100, 100, 100))));
-}
-
-TEST_F(PipPositionerTest, AvoidObstaclesAvoidsUnifiedSystemTray) {
-  UpdateDisplay("1000x1000");
-  auto* unified_system_tray = GetPrimaryUnifiedSystemTray();
-  unified_system_tray->ShowBubble(/*show_by_click=*/false);
-
-  auto display = GetPrimaryDisplay();
-  gfx::Rect area = PipPositioner::GetMovementArea(display);
-  gfx::Rect bubble_bounds = unified_system_tray->GetBubbleBoundsInScreen();
-  gfx::Rect bounds = gfx::Rect(bubble_bounds.x(), bubble_bounds.y(), 100, 100);
-  gfx::Rect moved_bounds = PipPositioner::GetRestingPosition(display, bounds);
-
-  // Expect that the returned bounds don't intersect the unified system tray
-  // but also don't leave the PIP movement area.
-  EXPECT_FALSE(moved_bounds.Intersects(bubble_bounds));
-  EXPECT_TRUE(area.Contains(moved_bounds));
-}
-
-class PipPositionerDisplayTest : public AshTestBase,
-                                 public ::testing::WithParamInterface<
-                                     std::tuple<std::string, std::size_t>> {
+class PipPositionerTest : public AshTestBase {
  public:
+  PipPositionerTest() = default;
+  ~PipPositionerTest() override = default;
+
   void SetUp() override {
     base::CommandLine::ForCurrentProcess()->AppendSwitch(
         keyboard::switches::kEnableVirtualKeyboard);
@@ -98,25 +59,23 @@
     SetTouchKeyboardEnabled(true);
     Shell::Get()->EnableKeyboard();
 
-    const std::string& display_string = std::get<0>(GetParam());
-    const std::size_t root_window_index = std::get<1>(GetParam());
-    UpdateWorkArea(display_string);
-    ASSERT_LT(root_window_index, Shell::GetAllRootWindows().size());
-    root_window_ = Shell::GetAllRootWindows()[root_window_index];
-    scoped_root_.reset(new ScopedRootWindowForNewWindows(root_window_));
+    UpdateWorkArea("400x400");
+    window_ = CreateTestWindowInShellWithBounds(gfx::Rect(200, 200, 100, 100));
+    wm::WindowState* window_state = wm::GetWindowState(window_);
+    test_state_ = new FakeWindowState(mojom::WindowStateType::PIP);
+    window_state->SetStateObject(
+        std::unique_ptr<wm::WindowState::State>(test_state_));
   }
 
   void TearDown() override {
-    scoped_root_.reset();
     SetTouchKeyboardEnabled(false);
     AshTestBase::TearDown();
   }
 
- protected:
-  display::Display GetDisplay() { return GetDisplayForWindow(root_window_); }
-
-  gfx::Rect ConvertToScreen(const gfx::Rect& bounds) {
-    return ConvertToScreenForWindow(root_window_, bounds);
+  void UpdateWorkArea(const std::string& bounds) {
+    UpdateDisplay(bounds);
+    aura::Window* root = Shell::GetPrimaryRootWindow();
+    Shell::Get()->SetDisplayWorkAreaInsets(root, gfx::Insets());
   }
 
   gfx::Rect CallAvoidObstacles(const display::Display& display,
@@ -124,244 +83,219 @@
     return PipPositioner::AvoidObstacles(display, bounds);
   }
 
-  // TODO dedpue?
-  void UpdateWorkArea(const std::string& bounds) {
-    UpdateDisplay(bounds);
-    for (aura::Window* root : Shell::GetAllRootWindows())
-      Shell::Get()->SetDisplayWorkAreaInsets(root, gfx::Insets());
+  gfx::Rect CallAvoidObstaclesInternal(const gfx::Rect& work_area,
+                                       const std::vector<gfx::Rect>& rects,
+                                       const gfx::Rect& bounds) {
+    return PipPositioner::AvoidObstaclesInternal(work_area, rects, bounds);
   }
 
+ protected:
+  aura::Window* window() { return window_; }
+  wm::WindowState* window_state() { return wm::GetWindowState(window_); }
+  FakeWindowState* test_state() { return test_state_; }
+
  private:
-  std::unique_ptr<ScopedRootWindowForNewWindows> scoped_root_;
-  aura::Window* root_window_;
+  aura::Window* window_;
+  FakeWindowState* test_state_;
+
+  DISALLOW_COPY_AND_ASSIGN(PipPositionerTest);
 };
 
-TEST_P(PipPositionerDisplayTest, PipMovementAreaIsInset) {
-  gfx::Rect area = PipPositioner::GetMovementArea(GetDisplay());
-  EXPECT_EQ(ConvertToScreen(gfx::Rect(8, 8, 384, 384)), area);
+TEST_F(PipPositionerTest, PipMovementAreaIsInset) {
+  gfx::Rect area = PipPositioner::GetMovementArea(window_state()->GetDisplay());
+  EXPECT_EQ(gfx::Rect(8, 8, 384, 384), area);
 }
 
-TEST_P(PipPositionerDisplayTest,
-       PipMovementAreaIncludesKeyboardIfKeyboardIsShown) {
+TEST_F(PipPositionerTest, PipMovementAreaIncludesKeyboardIfKeyboardIsShown) {
   auto* keyboard_controller = keyboard::KeyboardController::Get();
-  keyboard_controller->ShowKeyboardInDisplay(GetDisplay());
-  ASSERT_TRUE(keyboard::WaitUntilShown());
+  keyboard_controller->ShowKeyboard(/*lock=*/true);
   aura::Window* keyboard_window = keyboard_controller->GetKeyboardWindow();
   keyboard_window->SetBounds(gfx::Rect(0, 300, 400, 100));
+  ASSERT_TRUE(keyboard::WaitUntilShown());
 
-  gfx::Rect area = PipPositioner::GetMovementArea(GetDisplay());
-  EXPECT_EQ(ConvertToScreen(gfx::Rect(8, 8, 384, 284)), area);
+  gfx::Rect area = PipPositioner::GetMovementArea(window_state()->GetDisplay());
+  EXPECT_EQ(gfx::Rect(8, 8, 384, 284), area);
 }
 
-TEST_P(PipPositionerDisplayTest, PipRestingPositionSnapsToClosestEdge) {
-  auto display = GetDisplay();
+TEST_F(PipPositionerTest, PipRestingPositionSnapsToClosestEdge) {
+  auto display = window_state()->GetDisplay();
 
   // Snap near top edge to top.
-  EXPECT_EQ(ConvertToScreen(gfx::Rect(100, 8, 100, 100)),
-            PipPositioner::GetRestingPosition(
-                display, ConvertToScreen(gfx::Rect(100, 50, 100, 100))));
+  EXPECT_EQ(
+      gfx::Rect(100, 8, 100, 100),
+      PipPositioner::GetRestingPosition(display, gfx::Rect(100, 50, 100, 100)));
 
   // Snap near bottom edge to bottom.
-  EXPECT_EQ(ConvertToScreen(gfx::Rect(100, 292, 100, 100)),
-            PipPositioner::GetRestingPosition(
-                display, ConvertToScreen(gfx::Rect(100, 250, 100, 100))));
+  EXPECT_EQ(gfx::Rect(100, 292, 100, 100),
+            PipPositioner::GetRestingPosition(display,
+                                              gfx::Rect(100, 250, 100, 100)));
 
   // Snap near left edge to left.
-  EXPECT_EQ(ConvertToScreen(gfx::Rect(8, 100, 100, 100)),
-            PipPositioner::GetRestingPosition(
-                display, ConvertToScreen(gfx::Rect(50, 100, 100, 100))));
+  EXPECT_EQ(
+      gfx::Rect(8, 100, 100, 100),
+      PipPositioner::GetRestingPosition(display, gfx::Rect(50, 100, 100, 100)));
 
   // Snap near right edge to right.
-  EXPECT_EQ(ConvertToScreen(gfx::Rect(292, 100, 100, 100)),
-            PipPositioner::GetRestingPosition(
-                display, ConvertToScreen(gfx::Rect(250, 100, 100, 100))));
+  EXPECT_EQ(gfx::Rect(292, 100, 100, 100),
+            PipPositioner::GetRestingPosition(display,
+                                              gfx::Rect(250, 100, 100, 100)));
 }
 
-TEST_P(PipPositionerDisplayTest, PipRestingPositionSnapsInsideDisplay) {
-  auto display = GetDisplay();
+TEST_F(PipPositionerTest, PipRestingPositionSnapsInsideDisplay) {
+  auto display = window_state()->GetDisplay();
 
   // Snap near top edge outside movement area to top.
-  EXPECT_EQ(ConvertToScreen(gfx::Rect(100, 8, 100, 100)),
-            PipPositioner::GetRestingPosition(
-                display, ConvertToScreen(gfx::Rect(100, -50, 100, 100))));
+  EXPECT_EQ(gfx::Rect(100, 8, 100, 100),
+            PipPositioner::GetRestingPosition(display,
+                                              gfx::Rect(100, -50, 100, 100)));
 
   // Snap near bottom edge outside movement area to bottom.
-  EXPECT_EQ(ConvertToScreen(gfx::Rect(100, 292, 100, 100)),
-            PipPositioner::GetRestingPosition(
-                display, ConvertToScreen(gfx::Rect(100, 450, 100, 100))));
+  EXPECT_EQ(gfx::Rect(100, 292, 100, 100),
+            PipPositioner::GetRestingPosition(display,
+                                              gfx::Rect(100, 450, 100, 100)));
 
   // Snap near left edge outside movement area to left.
-  EXPECT_EQ(ConvertToScreen(gfx::Rect(8, 100, 100, 100)),
-            PipPositioner::GetRestingPosition(
-                display, ConvertToScreen(gfx::Rect(-50, 100, 100, 100))));
+  EXPECT_EQ(gfx::Rect(8, 100, 100, 100),
+            PipPositioner::GetRestingPosition(display,
+                                              gfx::Rect(-50, 100, 100, 100)));
 
   // Snap near right edge outside movement area to right.
-  EXPECT_EQ(ConvertToScreen(gfx::Rect(292, 100, 100, 100)),
-            PipPositioner::GetRestingPosition(
-                display, ConvertToScreen(gfx::Rect(450, 100, 100, 100))));
+  EXPECT_EQ(gfx::Rect(292, 100, 100, 100),
+            PipPositioner::GetRestingPosition(display,
+                                              gfx::Rect(450, 100, 100, 100)));
+}
+
+TEST_F(PipPositionerTest,
+       PipRestingPositionSnapsInDisplayWithLargeAspectRatio) {
+  UpdateDisplay("1600x400");
+  auto display = window_state()->GetDisplay();
+
+  // Snap to the top edge instead of the far left edge.
+  EXPECT_EQ(gfx::Rect(500, 8, 100, 100),
+            PipPositioner::GetRestingPosition(display,
+                                              gfx::Rect(500, 100, 100, 100)));
 }
 
-TEST_P(PipPositionerDisplayTest, PipAdjustPositionForDragClampsToMovementArea) {
-  auto display = GetDisplay();
+TEST_F(PipPositionerTest, PipAdjustPositionForDragClampsToMovementArea) {
+  auto display = window_state()->GetDisplay();
 
   // Adjust near top edge outside movement area.
-  EXPECT_EQ(ConvertToScreen(gfx::Rect(100, 8, 100, 100)),
-            PipPositioner::GetBoundsForDrag(
-                display, ConvertToScreen(gfx::Rect(100, -50, 100, 100))));
+  EXPECT_EQ(
+      gfx::Rect(100, 8, 100, 100),
+      PipPositioner::GetBoundsForDrag(display, gfx::Rect(100, -50, 100, 100)));
 
   // Adjust near bottom edge outside movement area.
-  EXPECT_EQ(ConvertToScreen(gfx::Rect(100, 292, 100, 100)),
-            PipPositioner::GetBoundsForDrag(
-                display, ConvertToScreen(gfx::Rect(100, 450, 100, 100))));
+  EXPECT_EQ(
+      gfx::Rect(100, 292, 100, 100),
+      PipPositioner::GetBoundsForDrag(display, gfx::Rect(100, 450, 100, 100)));
 
   // Adjust near left edge outside movement area.
-  EXPECT_EQ(ConvertToScreen(gfx::Rect(8, 100, 100, 100)),
-            PipPositioner::GetBoundsForDrag(
-                display, ConvertToScreen(gfx::Rect(-50, 100, 100, 100))));
+  EXPECT_EQ(
+      gfx::Rect(8, 100, 100, 100),
+      PipPositioner::GetBoundsForDrag(display, gfx::Rect(-50, 100, 100, 100)));
 
   // Adjust near right edge outside movement area.
-  EXPECT_EQ(ConvertToScreen(gfx::Rect(292, 100, 100, 100)),
-            PipPositioner::GetBoundsForDrag(
-                display, ConvertToScreen(gfx::Rect(450, 100, 100, 100))));
+  EXPECT_EQ(
+      gfx::Rect(292, 100, 100, 100),
+      PipPositioner::GetBoundsForDrag(display, gfx::Rect(450, 100, 100, 100)));
 }
 
-TEST_P(PipPositionerDisplayTest, PipRestingPositionWorksIfKeyboardIsDisabled) {
+TEST_F(PipPositionerTest, PipRestingPositionWorksIfKeyboardIsDisabled) {
   Shell::Get()->DisableKeyboard();
-  auto display = GetDisplay();
+  auto display = window_state()->GetDisplay();
 
   // Snap near top edge to top.
-  EXPECT_EQ(ConvertToScreen(gfx::Rect(100, 8, 100, 100)),
-            PipPositioner::GetRestingPosition(
-                display, ConvertToScreen(gfx::Rect(100, 50, 100, 100))));
+  EXPECT_EQ(
+      gfx::Rect(100, 8, 100, 100),
+      PipPositioner::GetRestingPosition(display, gfx::Rect(100, 50, 100, 100)));
 }
 
-TEST_P(PipPositionerDisplayTest,
-       PipDismissedPositionDoesNotMoveAnExcessiveDistance) {
-  auto display = GetDisplay();
+TEST_F(PipPositionerTest, PipDismissedPositionDoesNotMoveAnExcessiveDistance) {
+  auto display = window_state()->GetDisplay();
 
-  EXPECT_EQ(ConvertToScreen(gfx::Rect(100, 100, 100, 100)),
-            PipPositioner::GetDismissedPosition(
-                display, ConvertToScreen(gfx::Rect(100, 100, 100, 100))));
+  EXPECT_EQ(gfx::Rect(100, 100, 100, 100),
+            PipPositioner::GetDismissedPosition(display,
+                                                gfx::Rect(100, 100, 100, 100)));
 }
 
-TEST_P(PipPositionerDisplayTest, PipDismissedPositionChosesClosestEdge) {
-  auto display = GetDisplay();
+TEST_F(PipPositionerTest, PipDismissedPositionChosesClosestEdge) {
+  auto display = window_state()->GetDisplay();
 
   // Dismiss near top edge outside movement area towards top.
-  EXPECT_EQ(ConvertToScreen(gfx::Rect(100, -100, 100, 100)),
-            PipPositioner::GetDismissedPosition(
-                display, ConvertToScreen(gfx::Rect(100, 50, 100, 100))));
+  EXPECT_EQ(gfx::Rect(100, -100, 100, 100),
+            PipPositioner::GetDismissedPosition(display,
+                                                gfx::Rect(100, 50, 100, 100)));
 
   // Dismiss near bottom edge outside movement area towards bottom.
-  EXPECT_EQ(ConvertToScreen(gfx::Rect(100, 400, 100, 100)),
-            PipPositioner::GetDismissedPosition(
-                display, ConvertToScreen(gfx::Rect(100, 250, 100, 100))));
+  EXPECT_EQ(gfx::Rect(100, 400, 100, 100),
+            PipPositioner::GetDismissedPosition(display,
+                                                gfx::Rect(100, 250, 100, 100)));
 
   // Dismiss near left edge outside movement area towards left.
-  EXPECT_EQ(ConvertToScreen(gfx::Rect(-100, 100, 100, 100)),
-            PipPositioner::GetDismissedPosition(
-                display, ConvertToScreen(gfx::Rect(50, 100, 100, 100))));
+  EXPECT_EQ(gfx::Rect(-100, 100, 100, 100),
+            PipPositioner::GetDismissedPosition(display,
+                                                gfx::Rect(50, 100, 100, 100)));
 
   // Dismiss near right edge outside movement area towards right.
-  EXPECT_EQ(ConvertToScreen(gfx::Rect(400, 100, 100, 100)),
-            PipPositioner::GetDismissedPosition(
-                display, ConvertToScreen(gfx::Rect(250, 100, 100, 100))));
+  EXPECT_EQ(gfx::Rect(400, 100, 100, 100),
+            PipPositioner::GetDismissedPosition(display,
+                                                gfx::Rect(250, 100, 100, 100)));
 }
 
 // Verify that if two edges are equally close, the PIP window prefers dismissing
 // out horizontally.
-TEST_P(PipPositionerDisplayTest, PipDismissedPositionPrefersHorizontal) {
-  auto display = GetDisplay();
+TEST_F(PipPositionerTest, PipDismissedPositionPrefersHorizontal) {
+  auto display = window_state()->GetDisplay();
 
   // Top left corner.
-  EXPECT_EQ(ConvertToScreen(gfx::Rect(-150, 0, 100, 100)),
-            PipPositioner::GetDismissedPosition(
-                display, ConvertToScreen(gfx::Rect(0, 0, 100, 100))));
+  EXPECT_EQ(
+      gfx::Rect(-150, 0, 100, 100),
+      PipPositioner::GetDismissedPosition(display, gfx::Rect(0, 0, 100, 100)));
 
   // Top right corner.
-  EXPECT_EQ(ConvertToScreen(gfx::Rect(450, 0, 100, 100)),
-            PipPositioner::GetDismissedPosition(
-                display, ConvertToScreen(gfx::Rect(300, 0, 100, 100))));
+  EXPECT_EQ(gfx::Rect(450, 0, 100, 100),
+            PipPositioner::GetDismissedPosition(display,
+                                                gfx::Rect(300, 0, 100, 100)));
 
   // Bottom left corner.
-  EXPECT_EQ(ConvertToScreen(gfx::Rect(-150, 300, 100, 100)),
-            PipPositioner::GetDismissedPosition(
-                display, ConvertToScreen(gfx::Rect(0, 300, 100, 100))));
+  EXPECT_EQ(gfx::Rect(-150, 300, 100, 100),
+            PipPositioner::GetDismissedPosition(display,
+                                                gfx::Rect(0, 300, 100, 100)));
 
   // Bottom right corner.
-  EXPECT_EQ(ConvertToScreen(gfx::Rect(450, 300, 100, 100)),
-            PipPositioner::GetDismissedPosition(
-                display, ConvertToScreen(gfx::Rect(300, 300, 100, 100))));
-}
-
-TEST_P(PipPositionerDisplayTest, AvoidObstaclesAvoidsFloatingKeyboard) {
-  auto display = GetDisplay();
-
-  auto* keyboard_controller = keyboard::KeyboardController::Get();
-  keyboard_controller->SetContainerType(
-      keyboard::mojom::ContainerType::kFloating, base::nullopt,
-      base::DoNothing());
-  keyboard_controller->ShowKeyboardInDisplay(display);
-  ASSERT_TRUE(keyboard::WaitUntilShown());
-  aura::Window* keyboard_window = keyboard_controller->GetKeyboardWindow();
-  keyboard_window->SetBounds(gfx::Rect(0, 0, 100, 100));
-  ForceHideShelves();  // Showing the keyboard may have shown the shelf.
-
-  gfx::Rect area = PipPositioner::GetMovementArea(display);
-  gfx::Rect moved_bounds =
-      CallAvoidObstacles(display, ConvertToScreen(gfx::Rect(8, 8, 100, 100)));
-
-  // Expect that the returned bounds don't intersect the floating keyboard
-  // but also don't leave the PIP movement area.
-  EXPECT_FALSE(moved_bounds.Intersects(keyboard_window->GetBoundsInScreen()));
-  EXPECT_TRUE(area.Contains(moved_bounds));
+  EXPECT_EQ(gfx::Rect(450, 300, 100, 100),
+            PipPositioner::GetDismissedPosition(display,
+                                                gfx::Rect(300, 300, 100, 100)));
 }
 
-TEST_P(PipPositionerDisplayTest,
-       AvoidObstaclesDoesNotChangeBoundsIfThereIsNoCollision) {
-  auto display = GetDisplay();
-  EXPECT_EQ(ConvertToScreen(gfx::Rect(100, 100, 100, 100)),
-            CallAvoidObstacles(display,
-                               ConvertToScreen(gfx::Rect(100, 100, 100, 100))));
+TEST_F(PipPositionerTest,
+       PipRestoresToPreviousBoundsOnMovementAreaChangeIfTheyExist) {
+  // Position the PIP window on the side of the screen where it will be next
+  // to an edge and therefore in a resting position for the whole test.
+  const gfx::Rect bounds = gfx::Rect(292, 200, 100, 100);
+  // Set restore position to where the window currently is.
+  window()->SetBounds(bounds);
+  window_state()->SetRestoreBoundsInScreen(bounds);
+  EXPECT_TRUE(window_state()->HasRestoreBounds());
+
+  // Update the work area so that the PIP window should be pushed upward.
+  UpdateWorkArea("400x200");
+
+  // Set PIP to the updated constrained bounds.
+  const gfx::Rect constrained_bounds =
+      PipPositioner::GetPositionAfterMovementAreaChange(window_state());
+  EXPECT_EQ(gfx::Rect(292, 92, 100, 100), constrained_bounds);
+  window()->SetBounds(constrained_bounds);
+
+  // Restore the original work area.
+  UpdateWorkArea("400x400");
+
+  // Expect that the PIP window is put back to where it was before.
+  EXPECT_EQ(gfx::Rect(292, 200, 100, 100),
+            PipPositioner::GetPositionAfterMovementAreaChange(window_state()));
 }
 
-TEST_P(PipPositionerDisplayTest, GetRestingPositionAvoidsKeyboard) {
-  auto display = GetDisplay();
-
-  auto* keyboard_controller = keyboard::KeyboardController::Get();
-  keyboard_controller->ShowKeyboardInDisplay(display);
-  ASSERT_TRUE(keyboard::WaitUntilShown());
-  aura::Window* keyboard_window = keyboard_controller->GetKeyboardWindow();
-  keyboard_window->SetBounds(gfx::Rect(0, 300, 400, 100));
-
-  EXPECT_EQ(ConvertToScreen(gfx::Rect(8, 192, 100, 100)),
-            PipPositioner::GetRestingPosition(
-                display, ConvertToScreen(gfx::Rect(8, 300, 100, 100))));
-}
-
-// TODO: UpdateDisplay() doesn't support different layouts of multiple displays.
-// We should add some way to try multiple layouts.
-INSTANTIATE_TEST_SUITE_P(
-    /* no prefix */,
-    PipPositionerDisplayTest,
-    testing::Values(std::make_tuple("400x400", 0u),
-                    std::make_tuple("400x400/r", 0u),
-                    std::make_tuple("400x400/u", 0u),
-                    std::make_tuple("400x400/l", 0u),
-                    std::make_tuple("800x800*2", 0u),
-                    std::make_tuple("400x400,400x400", 0u),
-                    std::make_tuple("400x400,400x400", 1u)));
-
-class PipPositionerLogicTest : public ::testing::Test {
- public:
-  gfx::Rect CallAvoidObstaclesInternal(const gfx::Rect& work_area,
-                                       const std::vector<gfx::Rect>& rects,
-                                       const gfx::Rect& bounds) {
-    return PipPositioner::AvoidObstaclesInternal(work_area, rects, bounds);
-  }
-};
-
-TEST_F(PipPositionerLogicTest,
+TEST_F(PipPositionerTest,
        AvoidObstaclesDoesNotMoveBoundsIfThereIsNoIntersection) {
   const gfx::Rect area(0, 0, 400, 400);
 
@@ -402,7 +336,7 @@
                                        gfx::Rect(100, 300, 100, 100)));
 }
 
-TEST_F(PipPositionerLogicTest, AvoidObstaclesOffByOneCases) {
+TEST_F(PipPositionerTest, AvoidObstaclesOffByOneCases) {
   const gfx::Rect area(0, 0, 400, 400);
 
   // Test 1x1 PIP window intersecting a 1x1 obstacle.
@@ -530,7 +464,7 @@
                                        gfx::Rect(9, 12, 3, 3)));
 }
 
-TEST_F(PipPositionerLogicTest, AvoidObstaclesNestedObstacle) {
+TEST_F(PipPositionerTest, AvoidObstaclesNestedObstacle) {
   const gfx::Rect area(0, 0, 400, 400);
   EXPECT_EQ(gfx::Rect(9, 16, 1, 1),
             CallAvoidObstaclesInternal(
@@ -538,7 +472,7 @@
                 gfx::Rect(16, 16, 1, 1)));
 }
 
-TEST_F(PipPositionerLogicTest, AvoidObstaclesAvoidsTwoObstacles) {
+TEST_F(PipPositionerTest, AvoidObstaclesAvoidsTwoObstacles) {
   const gfx::Rect area(0, 0, 400, 400);
   const std::vector<gfx::Rect> obstacles = {gfx::Rect(4, 1, 4, 5),
                                             gfx::Rect(2, 4, 4, 5)};
@@ -554,7 +488,7 @@
             CallAvoidObstaclesInternal(area, obstacles, gfx::Rect(4, 1, 2, 2)));
 }
 
-TEST_F(PipPositionerLogicTest, AvoidObstaclesAvoidsThreeObstacles) {
+TEST_F(PipPositionerTest, AvoidObstaclesAvoidsThreeObstacles) {
   const gfx::Rect area(0, 0, 400, 400);
   const std::vector<gfx::Rect> obstacles = {
       gfx::Rect(4, 1, 4, 5), gfx::Rect(2, 4, 4, 5), gfx::Rect(2, 1, 3, 4)};
@@ -567,8 +501,7 @@
             CallAvoidObstaclesInternal(area, obstacles, gfx::Rect(3, 3, 2, 2)));
 }
 
-TEST_F(PipPositionerLogicTest,
-       AvoidObstaclesDoesNotPositionBoundsOutsideOfPipArea) {
+TEST_F(PipPositionerTest, AvoidObstaclesDoesNotPositionBoundsOutsideOfPipArea) {
   // Position the bounds such that moving it the least distance to stop
   // intersecting |obstacle| would put it outside of |area|. It should go
   // instead to the position of second least distance, which would be below
@@ -580,8 +513,7 @@
             CallAvoidObstaclesInternal(area, {obstacle}, bounds));
 }
 
-TEST_F(PipPositionerLogicTest,
-       AvoidObstaclesPositionsBoundsWithLeastDisplacement) {
+TEST_F(PipPositionerTest, AvoidObstaclesPositionsBoundsWithLeastDisplacement) {
   const gfx::Rect area(0, 0, 400, 400);
   const gfx::Rect obstacle(200, 200, 100, 100);
 
@@ -606,4 +538,49 @@
                                        gfx::Rect(200, 150, 100, 100)));
 }
 
+TEST_F(PipPositionerTest, AvoidObstaclesAvoidsUnifiedSystemTray) {
+  UpdateDisplay("1000x1000");
+  auto* unified_system_tray = GetPrimaryUnifiedSystemTray();
+  unified_system_tray->ShowBubble(/*show_by_click=*/false);
+
+  auto display = window_state()->GetDisplay();
+  gfx::Rect area = PipPositioner::GetMovementArea(display);
+  gfx::Rect bubble_bounds = unified_system_tray->GetBubbleBoundsInScreen();
+  gfx::Rect bounds = gfx::Rect(bubble_bounds.x(), bubble_bounds.y(), 100, 100);
+  gfx::Rect moved_bounds = CallAvoidObstacles(display, bounds);
+
+  // Expect that the returned bounds don't intersect the unified system tray
+  // but also don't leave the PIP movement area.
+  EXPECT_FALSE(moved_bounds.Intersects(bubble_bounds));
+  EXPECT_TRUE(area.Contains(moved_bounds));
+}
+
+TEST_F(PipPositionerTest, AvoidObstaclesAvoidsFloatingKeyboard) {
+  auto* keyboard_controller = keyboard::KeyboardController::Get();
+  keyboard_controller->SetContainerType(
+      keyboard::mojom::ContainerType::kFloating, base::nullopt,
+      base::DoNothing());
+  keyboard_controller->ShowKeyboard(/*lock=*/true);
+  aura::Window* keyboard_window = keyboard_controller->GetKeyboardWindow();
+  keyboard_window->SetBounds(gfx::Rect(200, 200, 100, 100));
+  ASSERT_TRUE(keyboard::WaitUntilShown());
+
+  auto display = window_state()->GetDisplay();
+  gfx::Rect area = PipPositioner::GetMovementArea(display);
+  gfx::Rect moved_bounds =
+      CallAvoidObstacles(display, gfx::Rect(150, 200, 100, 100));
+
+  // Expect that the returned bounds don't intersect the floating keyboard
+  // but also don't leave the PIP movement area.
+  EXPECT_FALSE(moved_bounds.Intersects(keyboard_window->GetBoundsInScreen()));
+  EXPECT_TRUE(area.Contains(moved_bounds));
+}
+
+TEST_F(PipPositionerTest,
+       AvoidObstaclesDoesNotChangeBoundsIfThereIsNoCollision) {
+  auto display = window_state()->GetDisplay();
+  EXPECT_EQ(gfx::Rect(100, 100, 100, 100),
+            CallAvoidObstacles(display, gfx::Rect(100, 100, 100, 100)));
+}
+
 }  // namespace ash
--- a/ash/wm/pip/pip_unittest.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/pip/pip_unittest.cc	2019-05-17 18:53:08.372000000 +0300
@@ -13,53 +13,30 @@
 #include "ash/shell.h"
 #include "ash/system/status_area_widget.h"
 #include "ash/test/ash_test_base.h"
-#include "ash/wm/pip/pip_positioner.h"
 #include "ash/wm/window_state.h"
 #include "ash/wm/wm_event.h"
 #include "base/command_line.h"
 #include "ui/aura/window.h"
 #include "ui/events/test/event_generator.h"
-#include "ui/keyboard/keyboard_controller.h"
-#include "ui/keyboard/public/keyboard_switches.h"
-#include "ui/keyboard/test/keyboard_test_util.h"
 #include "ui/views/widget/widget.h"
 #include "ui/views/widget/widget_delegate.h"
 
 namespace ash {
 
-namespace {
+using PipTest = AshTestBase;
 
-std::unique_ptr<views::Widget> CreateWidget(aura::Window* context) {
+std::unique_ptr<views::Widget> CreateWidget() {
   std::unique_ptr<views::Widget> widget(new views::Widget);
   views::Widget::InitParams params;
   params.delegate = new views::WidgetDelegateView();
   params.ownership = views::Widget::InitParams::WIDGET_OWNS_NATIVE_WIDGET;
-  params.context = context;
+  params.context = Shell::GetPrimaryRootWindow();
   widget->Init(params);
   return widget;
 }
 
-}  // namespace
-
-class PipTest : public AshTestBase {
- public:
-  PipTest() = default;
-  ~PipTest() override = default;
-
-  void SetUp() override {
-    base::CommandLine::ForCurrentProcess()->AppendSwitch(
-        keyboard::switches::kEnableVirtualKeyboard);
-    AshTestBase::SetUp();
-  }
-
-  void TearDown() override { AshTestBase::TearDown(); }
-
- private:
-  DISALLOW_COPY_AND_ASSIGN(PipTest);
-};
-
 TEST_F(PipTest, ShowInactive) {
-  auto widget = CreateWidget(Shell::GetPrimaryRootWindow());
+  auto widget = CreateWidget();
   const wm::WMEvent pip_event(wm::WM_EVENT_PIP);
   auto* window_state = wm::GetWindowState(widget->GetNativeWindow());
   window_state->OnWMEvent(&pip_event);
@@ -85,8 +62,8 @@
 }
 
 TEST_F(PipTest, ShortcutNavigation) {
-  auto widget = CreateWidget(Shell::GetPrimaryRootWindow());
-  auto pip_widget = CreateWidget(Shell::GetPrimaryRootWindow());
+  auto widget = CreateWidget();
+  auto pip_widget = CreateWidget();
   widget->Show();
   pip_widget->Show();
   const wm::WMEvent pip_event(wm::WM_EVENT_PIP);
@@ -132,125 +109,4 @@
   EXPECT_TRUE(pip_widget->IsActive());
 }
 
-TEST_F(PipTest, PipInitialPositionAvoidsObstacles) {
-  UpdateDisplay("400x400");
-  std::unique_ptr<aura::Window> window(
-      CreateTestWindowInShellWithBounds(gfx::Rect(100, 300, 100, 100)));
-  wm::WindowState* window_state = wm::GetWindowState(window.get());
-  const wm::WMEvent enter_pip(wm::WM_EVENT_PIP);
-  window_state->OnWMEvent(&enter_pip);
-  window->Show();
-
-  Shell::Get()->EnableKeyboard();
-  auto* keyboard_controller = keyboard::KeyboardController::Get();
-  keyboard_controller->ShowKeyboard(/*lock=*/true);
-  ASSERT_TRUE(keyboard::WaitUntilShown());
-  aura::Window* keyboard_window = keyboard_controller->GetKeyboardWindow();
-  keyboard_window->SetBounds(gfx::Rect(0, 300, 400, 100));
-
-  // Expect the PIP position is shifted below the keyboard.
-  EXPECT_TRUE(window_state->IsPip());
-  EXPECT_TRUE(window->layer()->visible());
-  EXPECT_EQ(gfx::Rect(100, 192, 100, 100), window->layer()->GetTargetBounds());
-}
-
-TEST_F(PipTest, TargetBoundsAffectedByWorkAreaChange) {
-  UpdateDisplay("400x400");
-  Shell::Get()->EnableKeyboard();
-
-  // Place a keyboard window at the initial position of a PIP window.
-  auto* keyboard_controller = keyboard::KeyboardController::Get();
-  keyboard_controller->ShowKeyboard(/*lock=*/true);
-  ASSERT_TRUE(keyboard::WaitUntilShown());
-  aura::Window* keyboard_window = keyboard_controller->GetKeyboardWindow();
-  keyboard_window->SetBounds(gfx::Rect(0, 300, 400, 100));
-
-  std::unique_ptr<aura::Window> window(
-      CreateTestWindowInShellWithBounds(gfx::Rect(100, 300, 100, 100)));
-  wm::WindowState* window_state = wm::GetWindowState(window.get());
-  const wm::WMEvent enter_pip(wm::WM_EVENT_PIP);
-  window_state->OnWMEvent(&enter_pip);
-  window->Show();
-
-  // Ensure the initial PIP position is shifted below the keyboard.
-  EXPECT_TRUE(window_state->IsPip());
-  EXPECT_TRUE(window->layer()->visible());
-  EXPECT_EQ(gfx::Rect(100, 192, 100, 100), window->bounds());
-}
-
-TEST_F(PipTest, PipRestoresToPreviousBoundsOnMovementAreaChangeIfTheyExist) {
-  UpdateDisplay("400x400");
-  std::unique_ptr<aura::Window> window(
-      CreateTestWindowInShellWithBounds(gfx::Rect(200, 200, 100, 100)));
-  wm::WindowState* window_state = wm::GetWindowState(window.get());
-  const wm::WMEvent enter_pip(wm::WM_EVENT_PIP);
-  window_state->OnWMEvent(&enter_pip);
-  window->Show();
-
-  // Position the PIP window on the side of the screen where it will be next
-  // to an edge and therefore in a resting position for the whole test.
-  const gfx::Rect bounds = gfx::Rect(292, 200, 100, 100);
-  // Set restore position to where the window currently is.
-  window->SetBounds(bounds);
-  window_state->SetRestoreBoundsInParent(bounds);
-  EXPECT_TRUE(window_state->HasRestoreBounds());
-
-  // Update the work area so that the PIP window should be pushed upward.
-  UpdateDisplay("400x200");
-  Shell::Get()->SetDisplayWorkAreaInsets(Shell::GetPrimaryRootWindow(),
-                                         gfx::Insets());
-
-  // Set PIP to the updated constrained bounds.
-  const gfx::Rect constrained_bounds =
-      PipPositioner::GetPositionAfterMovementAreaChange(window_state);
-  EXPECT_EQ(gfx::Rect(292, 92, 100, 100), constrained_bounds);
-  window->SetBoundsInScreen(constrained_bounds, window_state->GetDisplay());
-
-  // Restore the original work area.
-  UpdateDisplay("400x400");
-
-  // Expect that the PIP window is put back to where it was before.
-  EXPECT_EQ(gfx::Rect(292, 200, 100, 100),
-            PipPositioner::GetPositionAfterMovementAreaChange(window_state));
-}
-
-TEST_F(
-    PipTest,
-    PipRestoresToPreviousBoundsOnMovementAreaChangeIfTheyExistOnExternalDisplay) {
-  UpdateDisplay("400x400,400x400");
-  auto* root_window = Shell::GetAllRootWindows()[1];
-
-  // Position the PIP window on the side of the screen where it will be next
-  // to an edge and therefore in a resting position for the whole test.
-  auto widget = CreateWidget(root_window);
-  auto* window = widget->GetNativeWindow();
-  wm::WindowState* window_state = wm::GetWindowState(window);
-  const wm::WMEvent enter_pip(wm::WM_EVENT_PIP);
-  window_state->OnWMEvent(&enter_pip);
-  window->Show();
-  window->SetBounds(gfx::Rect(8, 292, 100, 100));
-
-  // Set restore position to where the window currently is.
-  window_state->SetRestoreBoundsInParent(window->bounds());
-  EXPECT_TRUE(window_state->HasRestoreBounds());
-
-  // Update the work area so that the PIP window should be pushed upward.
-  UpdateDisplay("400x400,400x200");
-  Shell::Get()->SetDisplayWorkAreaInsets(root_window, gfx::Insets());
-
-  // Set PIP to the updated constrained bounds.
-  // const gfx::Rect constrained_bounds =
-  // PipPositioner::GetPositionAfterMovementAreaChange(window_state);
-  EXPECT_EQ(gfx::Rect(408, 92, 100, 100), window->GetBoundsInScreen());
-  // window->SetBoundsInScreen(constrained_bounds, window_state->GetDisplay());
-
-  // Restore the original work area.
-  UpdateDisplay("400x400,400x400");
-  Shell::Get()->SetDisplayWorkAreaInsets(root_window, gfx::Insets());
-
-  // Expect that the PIP window is put back to where it was before.
-  EXPECT_EQ(gfx::Rect(408, 292, 100, 100), window->GetBoundsInScreen());
-  // PipPositioner::GetPositionAfterMovementAreaChange(window_state));
-}
-
 }  // namespace ash
--- a/ash/wm/pip/pip_window_resizer.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/pip/pip_window_resizer.cc	2019-05-17 18:53:08.372000000 +0300
@@ -4,16 +4,10 @@
 
 #include "ash/wm/pip/pip_window_resizer.h"
 
-#include <algorithm>
-#include <utility>
-
-#include "ash/metrics/pip_uma.h"
 #include "ash/wm/pip/pip_positioner.h"
 #include "ash/wm/widget_finder.h"
 #include "ash/wm/window_util.h"
 #include "ash/wm/wm_event.h"
-#include "base/metrics/histogram_functions.h"
-#include "base/metrics/histogram_macros.h"
 #include "ui/aura/window.h"
 #include "ui/compositor/scoped_layer_animation_settings.h"
 #include "ui/display/screen.h"
@@ -59,80 +53,6 @@
   return bounds.x() < area.x() || bounds.right() > area.right();
 }
 
-void CollectFreeResizeAreaMetric(const char* metric_name,
-                                 aura::Window* window) {
-  aura::Window* root_window = window->GetRootWindow();
-  const gfx::Rect bounds = window->GetBoundsInRootWindow();
-  const int root_window_area =
-      root_window->bounds().width() * root_window->bounds().height();
-  const int window_area = bounds.width() * bounds.height();
-  if (root_window_area != 0) {
-    const int percentage =
-        std::round(float(window_area) / float(root_window_area) * 100.f);
-    base::UmaHistogramPercentage(metric_name, percentage);
-  }
-}
-
-int ComputeIntersectionArea(const gfx::Rect& ninth, const gfx::Rect& bounds) {
-  gfx::Rect intersection = ninth;
-  intersection.Intersect(bounds);
-  return intersection.width() * intersection.height();
-}
-
-gfx::Rect ScaleRect(const gfx::Rect& rect, int scale) {
-  return gfx::Rect(rect.x() * scale, rect.y() * scale, rect.width() * scale,
-                   rect.height() * scale);
-}
-
-void CollectPositionMetric(const gfx::Rect& bounds_in_screen,
-                           const gfx::Rect& area_in_screen) {
-  const int width = area_in_screen.width();
-  const int height = area_in_screen.height();
-  // Scale by three to avoid truncation.
-  const gfx::Rect area = ScaleRect(area_in_screen, 3);
-  const gfx::Rect bounds = ScaleRect(bounds_in_screen, 3);
-
-  // Choose corners first, then edges, and finally middle in the case of a tie.
-  // This is based on the enum integer values.
-  // For this to work, all of the 9 buckets need to have the same area.
-  std::pair<int, AshPipPosition> area_ninths[9] = {
-      {ComputeIntersectionArea(
-           gfx::Rect(area.x() + width, area.y() + height, width, height),
-           bounds),
-       AshPipPosition::MIDDLE},
-      {ComputeIntersectionArea(
-           gfx::Rect(area.x() + width, area.y(), width, height), bounds),
-       AshPipPosition::TOP_MIDDLE},
-      {ComputeIntersectionArea(
-           gfx::Rect(area.x(), area.y() + height, width, height), bounds),
-       AshPipPosition::MIDDLE_LEFT},
-      {ComputeIntersectionArea(
-           gfx::Rect(area.x() + 2 * width, area.y() + height, width, height),
-           bounds),
-       AshPipPosition::MIDDLE_RIGHT},
-      {ComputeIntersectionArea(
-           gfx::Rect(area.x() + width, area.y() + 2 * height, width, height),
-           bounds),
-       AshPipPosition::BOTTOM_MIDDLE},
-      {ComputeIntersectionArea(gfx::Rect(area.x(), area.y(), width, height),
-                               bounds),
-       AshPipPosition::TOP_LEFT},
-      {ComputeIntersectionArea(
-           gfx::Rect(area.x() + 2 * width, area.y(), width, height), bounds),
-       AshPipPosition::TOP_RIGHT},
-      {ComputeIntersectionArea(
-           gfx::Rect(area.x(), area.y() + 2 * height, width, height), bounds),
-       AshPipPosition::BOTTOM_LEFT},
-      {ComputeIntersectionArea(gfx::Rect(area.x() + 2 * width,
-                                         area.y() + 2 * height, width, height),
-                               bounds),
-       AshPipPosition::BOTTOM_RIGHT}};
-
-  std::sort(area_ninths, area_ninths + base::size(area_ninths));
-  UMA_HISTOGRAM_ENUMERATION(kAshPipPositionHistogramName,
-                            area_ninths[8].second);
-}
-
 }  // namespace
 
 PipWindowResizer::PipWindowResizer(wm::WindowState* window_state)
@@ -140,13 +60,8 @@
   window_state->OnDragStarted(details().window_component);
 
   bool is_resize = details().bounds_change & kBoundsChange_Resizes;
-  if (is_resize) {
-    UMA_HISTOGRAM_ENUMERATION(kAshPipEventsHistogramName,
-                              AshPipEvents::FREE_RESIZE);
-    CollectFreeResizeAreaMetric(kAshPipFreeResizeInitialAreaHistogramName,
-                                GetTarget());
-  } else {
     // Don't allow swipe-to-dismiss for resizes.
+  if (!is_resize) {
     gfx::Rect area = PipPositioner::GetMovementArea(window_state->GetDisplay());
     // Check in which directions we can dismiss. Usually this is only in one
     // direction, except when the PIP window is in the corner. In that case,
@@ -159,11 +74,7 @@
   }
 }
 
-PipWindowResizer::~PipWindowResizer() {
-  // Drag details should be deleted upon destruction of the resizer.
-  if (window_state())
-    window_state()->DeleteDragDetails();
-}
+PipWindowResizer::~PipWindowResizer() {}
 
 // TODO(edcourtney): Implement swipe-to-dismiss on fling.
 void PipWindowResizer::Drag(const gfx::Point& location_in_parent,
@@ -182,9 +93,6 @@
   }
 
   gfx::Rect new_bounds = CalculateBoundsForDrag(location_in_parent);
-  // We do everything in Screen coordinates, so convert here.
-  ::wm::ConvertRectToScreen(GetTarget()->parent(), &new_bounds);
-
   display::Display display = window_state()->GetDisplay();
   gfx::Rect area = PipPositioner::GetMovementArea(display);
 
@@ -203,16 +111,14 @@
   // window is no longer poking outside of the movement area, disable any
   // further swipe-to-dismiss gesture for this drag. Use the initial bounds
   // to decide the locked axis position.
-  gfx::Rect initial_bounds_in_screen = details().initial_bounds_in_parent;
-  ::wm::ConvertRectToScreen(GetTarget()->parent(), &initial_bounds_in_screen);
   if (may_dismiss_horizontally_) {
     if (IsPastLeftOrRightEdge(new_bounds, area))
-      new_bounds.set_y(initial_bounds_in_screen.y());
+      new_bounds.set_y(details().initial_bounds_in_parent.y());
     else if (!IsAtLeftOrRightEdge(new_bounds, area))
       may_dismiss_horizontally_ = false;
   } else if (may_dismiss_vertically_) {
     if (IsPastTopOrBottomEdge(new_bounds, area))
-      new_bounds.set_x(initial_bounds_in_screen.x());
+      new_bounds.set_x(details().initial_bounds_in_parent.x());
     else if (!IsAtTopOrBottomEdge(new_bounds, area))
       may_dismiss_vertically_ = false;
   }
@@ -221,7 +127,9 @@
   if (!may_dismiss_horizontally_ && !may_dismiss_vertically_) {
     // Reset opacity if it's not a dismiss gesture.
     GetTarget()->layer()->SetOpacity(1.f);
+    ::wm::ConvertRectToScreen(GetTarget()->parent(), &new_bounds);
     new_bounds = PipPositioner::GetBoundsForDrag(display, new_bounds);
+    ::wm::ConvertRectFromScreen(GetTarget()->parent(), &new_bounds);
   } else {
     gfx::Rect dismiss_bounds = new_bounds;
     dismiss_bounds.Intersect(area);
@@ -242,27 +150,15 @@
     may_dismiss_vertically_ = false;
   }
 
-  // Convert back to root window coordinates for setting bounds.
-  ::wm::ConvertRectFromScreen(GetTarget()->parent(), &new_bounds);
   if (new_bounds != GetTarget()->bounds()) {
     moved_or_resized_ = true;
-    SetBoundsDuringResize(new_bounds);
+    GetTarget()->SetBounds(new_bounds);
   }
 }
 
 void PipWindowResizer::CompleteDrag() {
-  if (details().bounds_change & kBoundsChange_Resizes) {
-    CollectFreeResizeAreaMetric(kAshPipFreeResizeFinishAreaHistogramName,
-                                GetTarget());
-  } else {
-    // Collect final position on drag-move.
-    display::Display display = window_state()->GetDisplay();
-    gfx::Rect area = PipPositioner::GetMovementArea(display);
-    CollectPositionMetric(GetTarget()->GetBoundsInScreen(), area);
-  }
-
   window_state()->OnCompleteDrag(last_location_in_screen_);
-
+  window_state()->DeleteDragDetails();
   window_state()->ClearRestoreBounds();
   window_state()->set_bounds_changed_by_user(moved_or_resized_);
 
@@ -278,7 +174,9 @@
   if (should_dismiss) {
     // Close the widget. This will trigger an animation dismissing the PIP
     // window.
-    wm::CloseWidgetForWindow(window_state()->window());
+    auto* widget = GetInternalWidgetForWindow(window_state()->window());
+    if (widget)
+      widget->Close();
   } else {
     // Animate the PIP window to its resting position.
     gfx::Rect bounds;
@@ -312,7 +210,7 @@
     // TODO(edcourtney): This may not be the best place for this. Consider
     // doing this a different way or saving these bounds at a later point when
     // the work area changes.
-    window_state()->SetRestoreBoundsInParent(bounds);
+    window_state()->SaveCurrentBoundsForRestore();
   }
 }
 
--- a/ash/wm/pip/pip_window_resizer_unittest.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/pip/pip_window_resizer_unittest.cc	2019-05-17 18:53:08.372000000 +0300
@@ -5,20 +5,15 @@
 #include "ash/wm/pip/pip_window_resizer.h"
 
 #include <string>
-#include <tuple>
 #include <utility>
 
-#include "ash/metrics/pip_uma.h"
-#include "ash/scoped_root_window_for_new_windows.h"
 #include "ash/shelf/shelf.h"
 #include "ash/shell.h"
 #include "ash/test/ash_test_base.h"
 #include "ash/wm/tablet_mode/tablet_mode_controller.h"
 #include "ash/wm/window_state.h"
 #include "ash/wm/wm_event.h"
-#include "base/bind_helpers.h"
 #include "base/command_line.h"
-#include "base/test/metrics/histogram_tester.h"
 #include "ui/aura/client/aura_constants.h"
 #include "ui/aura/window.h"
 #include "ui/base/hit_test.h"
@@ -71,11 +66,7 @@
 
 }  // namespace
 
-using Sample = base::HistogramBase::Sample;
-
-class PipWindowResizerTest : public AshTestBase,
-                             public ::testing::WithParamInterface<
-                                 std::tuple<std::string, std::size_t>> {
+class PipWindowResizerTest : public AshTestBase {
  public:
   PipWindowResizerTest() = default;
   ~PipWindowResizerTest() override = default;
@@ -85,58 +76,39 @@
         keyboard::switches::kEnableVirtualKeyboard);
     AshTestBase::SetUp();
     SetTouchKeyboardEnabled(true);
+  }
 
-    const std::string& display_string = std::get<0>(GetParam());
-    const std::size_t root_window_index = std::get<1>(GetParam());
-    UpdateWorkArea(display_string);
-    ASSERT_LT(root_window_index, Shell::GetAllRootWindows().size());
-    scoped_root_.reset(new ScopedRootWindowForNewWindows(
-        Shell::GetAllRootWindows()[root_window_index]));
+  void PreparePipWindow(const gfx::Rect& bounds) {
+    widget_ = CreateWidgetForTest(bounds);
+    window_ = widget_->GetNativeWindow();
+    window_->SetProperty(aura::client::kAlwaysOnTopKey, true);
+    test_state_ = new FakeWindowState(mojom::WindowStateType::PIP);
+    wm::GetWindowState(window_)->SetStateObject(
+        std::unique_ptr<wm::WindowState::State>(test_state_));
   }
 
   void TearDown() override {
-    scoped_root_.reset();
     SetTouchKeyboardEnabled(false);
     AshTestBase::TearDown();
   }
 
  protected:
-  views::Widget* widget() { return widget_.get(); }
   aura::Window* window() { return window_; }
   FakeWindowState* test_state() { return test_state_; }
-  base::HistogramTester& histograms() { return histograms_; }
 
   std::unique_ptr<views::Widget> CreateWidgetForTest(const gfx::Rect& bounds) {
-    auto* root_window = Shell::GetRootWindowForNewWindows();
-    gfx::Rect screen_bounds = bounds;
-    ::wm::ConvertRectToScreen(root_window, &screen_bounds);
-
-    std::unique_ptr<views::Widget> widget(new views::Widget);
-    views::Widget::InitParams params;
-    params.ownership = views::Widget::InitParams::WIDGET_OWNS_NATIVE_WIDGET;
-    params.bounds = screen_bounds;
-    params.keep_on_top = true;
-    params.context = root_window;
-    widget->Init(params);
-    widget->Show();
-    return widget;
+    return CreateTestWidget(nullptr, kShellWindowId_AlwaysOnTopContainer,
+                            bounds);
   }
 
   PipWindowResizer* CreateResizerForTest(int window_component) {
-    return CreateResizerForTest(window_component, window(),
-                                window()->bounds().CenterPoint());
-  }
-
-  PipWindowResizer* CreateResizerForTest(int window_component,
-                                         gfx::Point point_in_parent) {
-    return CreateResizerForTest(window_component, window(), point_in_parent);
+    return CreateResizerForTest(window_component, window());
   }
 
   PipWindowResizer* CreateResizerForTest(int window_component,
-                                         aura::Window* window,
-                                         gfx::Point point_in_parent) {
+                                         aura::Window* window) {
     wm::WindowState* window_state = wm::GetWindowState(window);
-    window_state->CreateDragDetails(point_in_parent, window_component,
+    window_state->CreateDragDetails(gfx::Point(), window_component,
                                     ::wm::WINDOW_MOVE_SOURCE_MOUSE);
     return new PipWindowResizer(window_state);
   }
@@ -164,33 +136,23 @@
     resizer->FlingOrSwipe(&event);
   }
 
-  void PreparePipWindow(const gfx::Rect& bounds) {
-    widget_ = CreateWidgetForTest(bounds);
-    window_ = widget_->GetNativeWindow();
-    test_state_ = new FakeWindowState(mojom::WindowStateType::PIP);
-    wm::GetWindowState(window_)->SetStateObject(
-        std::unique_ptr<wm::WindowState::State>(test_state_));
+  void UpdateWorkArea(const std::string& bounds) {
+    UpdateDisplay(bounds);
+    aura::Window* root = Shell::GetPrimaryRootWindow();
+    Shell::Get()->SetDisplayWorkAreaInsets(root, gfx::Insets());
   }
 
  private:
   std::unique_ptr<views::Widget> widget_;
   aura::Window* window_;
   FakeWindowState* test_state_;
-  base::HistogramTester histograms_;
-  std::unique_ptr<ScopedRootWindowForNewWindows> scoped_root_;
-
-  void UpdateWorkArea(const std::string& bounds) {
-    UpdateDisplay(bounds);
-    for (aura::Window* root : Shell::GetAllRootWindows())
-      Shell::Get()->SetDisplayWorkAreaInsets(root, gfx::Insets());
-  }
 
   DISALLOW_COPY_AND_ASSIGN(PipWindowResizerTest);
 };
 
-TEST_P(PipWindowResizerTest, PipWindowCanDrag) {
+TEST_F(PipWindowResizerTest, PipWindowCanDrag) {
+  UpdateWorkArea("400x800");
   PreparePipWindow(gfx::Rect(200, 200, 100, 100));
-
   std::unique_ptr<PipWindowResizer> resizer(CreateResizerForTest(HTCAPTION));
   ASSERT_TRUE(resizer.get());
 
@@ -198,7 +160,8 @@
   EXPECT_EQ(gfx::Rect(200, 210, 100, 100), test_state()->last_bounds());
 }
 
-TEST_P(PipWindowResizerTest, PipWindowCanResize) {
+TEST_F(PipWindowResizerTest, PipWindowCanResize) {
+  UpdateWorkArea("400x800");
   PreparePipWindow(gfx::Rect(200, 200, 100, 100));
   std::unique_ptr<PipWindowResizer> resizer(CreateResizerForTest(HTBOTTOM));
   ASSERT_TRUE(resizer.get());
@@ -207,35 +170,33 @@
   EXPECT_EQ(gfx::Rect(200, 200, 100, 110), test_state()->last_bounds());
 }
 
-TEST_P(PipWindowResizerTest, PipWindowDragIsRestrictedToWorkArea) {
+TEST_F(PipWindowResizerTest, PipWindowDragIsRestrictedToWorkArea) {
+  UpdateWorkArea("400x400");
   PreparePipWindow(gfx::Rect(200, 200, 100, 100));
-  // Specify point in parent as center so the drag point does not leave the
-  // display. If the drag point is not in any display bounds, it causes the
-  // window to be moved to the default display.
-  std::unique_ptr<PipWindowResizer> resizer(
-      CreateResizerForTest(HTCAPTION, gfx::Point(250, 250)));
+  std::unique_ptr<PipWindowResizer> resizer(CreateResizerForTest(HTCAPTION));
   ASSERT_TRUE(resizer.get());
 
   // Drag to the right.
-  resizer->Drag(CalculateDragPoint(*resizer, 250, 0), 0);
+  resizer->Drag(CalculateDragPoint(*resizer, 800, 0), 0);
   EXPECT_EQ(gfx::Rect(292, 200, 100, 100), test_state()->last_bounds());
 
   // Drag down.
-  resizer->Drag(CalculateDragPoint(*resizer, 0, 250), 0);
+  resizer->Drag(CalculateDragPoint(*resizer, 0, 800), 0);
   EXPECT_EQ(gfx::Rect(200, 292, 100, 100), test_state()->last_bounds());
 
   // Drag to the left.
-  resizer->Drag(CalculateDragPoint(*resizer, -250, 0), 0);
+  resizer->Drag(CalculateDragPoint(*resizer, -800, 0), 0);
   EXPECT_EQ(gfx::Rect(8, 200, 100, 100), test_state()->last_bounds());
 
   // Drag up.
-  resizer->Drag(CalculateDragPoint(*resizer, 0, -250), 0);
+  resizer->Drag(CalculateDragPoint(*resizer, 0, -800), 0);
   EXPECT_EQ(gfx::Rect(200, 8, 100, 100), test_state()->last_bounds());
 }
 
-TEST_P(PipWindowResizerTest, PipWindowCanBeDraggedInTabletMode) {
+TEST_F(PipWindowResizerTest, PipWindowCanBeDraggedInTabletMode) {
   Shell::Get()->tablet_mode_controller()->EnableTabletModeWindowManager(true);
 
+  UpdateWorkArea("400x800");
   PreparePipWindow(gfx::Rect(200, 200, 100, 100));
   std::unique_ptr<PipWindowResizer> resizer(CreateResizerForTest(HTCAPTION));
   ASSERT_TRUE(resizer.get());
@@ -244,9 +205,10 @@
   EXPECT_EQ(gfx::Rect(200, 210, 100, 100), test_state()->last_bounds());
 }
 
-TEST_P(PipWindowResizerTest, PipWindowCanBeResizedInTabletMode) {
+TEST_F(PipWindowResizerTest, PipWindowCanBeResizedInTabletMode) {
   Shell::Get()->tablet_mode_controller()->EnableTabletModeWindowManager(true);
 
+  UpdateWorkArea("400x800");
   PreparePipWindow(gfx::Rect(200, 200, 100, 100));
   std::unique_ptr<PipWindowResizer> resizer(CreateResizerForTest(HTBOTTOM));
   ASSERT_TRUE(resizer.get());
@@ -255,9 +217,17 @@
   EXPECT_EQ(gfx::Rect(200, 200, 100, 110), test_state()->last_bounds());
 }
 
-TEST_P(PipWindowResizerTest, PipWindowCanBeSwipeDismissed) {
-  PreparePipWindow(gfx::Rect(8, 8, 100, 100));
-  std::unique_ptr<PipWindowResizer> resizer(CreateResizerForTest(HTCAPTION));
+TEST_F(PipWindowResizerTest, PipWindowCanBeSwipeDismissed) {
+  UpdateWorkArea("400x400");
+  PreparePipWindow(gfx::Rect(200, 200, 100, 100));
+  auto widget = CreateWidgetForTest(gfx::Rect(8, 8, 100, 100));
+  auto* window = widget->GetNativeWindow();
+  FakeWindowState* test_state =
+      new FakeWindowState(mojom::WindowStateType::PIP);
+  wm::GetWindowState(window)->SetStateObject(
+      std::unique_ptr<wm::WindowState::State>(test_state));
+  std::unique_ptr<PipWindowResizer> resizer(
+      CreateResizerForTest(HTCAPTION, window));
   ASSERT_TRUE(resizer.get());
 
   // Drag to the left.
@@ -265,12 +235,20 @@
 
   // Should be dismissed when the drag completes.
   resizer->CompleteDrag();
-  EXPECT_TRUE(widget()->IsClosed());
+  EXPECT_TRUE(widget->IsClosed());
 }
 
-TEST_P(PipWindowResizerTest, PipWindowPartiallySwipedDoesNotDismiss) {
-  PreparePipWindow(gfx::Rect(8, 8, 100, 100));
-  std::unique_ptr<PipWindowResizer> resizer(CreateResizerForTest(HTCAPTION));
+TEST_F(PipWindowResizerTest, PipWindowPartiallySwipedDoesNotDismiss) {
+  UpdateWorkArea("400x400");
+  PreparePipWindow(gfx::Rect(200, 200, 100, 100));
+  auto widget = CreateWidgetForTest(gfx::Rect(8, 8, 100, 100));
+  auto* window = widget->GetNativeWindow();
+  FakeWindowState* test_state =
+      new FakeWindowState(mojom::WindowStateType::PIP);
+  wm::GetWindowState(window)->SetStateObject(
+      std::unique_ptr<wm::WindowState::State>(test_state));
+  std::unique_ptr<PipWindowResizer> resizer(
+      CreateResizerForTest(HTCAPTION, window));
   ASSERT_TRUE(resizer.get());
 
   // Drag to the left, but only a little bit.
@@ -278,77 +256,117 @@
 
   // Should not be dismissed when the drag completes.
   resizer->CompleteDrag();
-  EXPECT_FALSE(widget()->IsClosed());
-  EXPECT_EQ(gfx::Rect(8, 8, 100, 100), test_state()->last_bounds());
+  EXPECT_FALSE(widget->IsClosed());
+  EXPECT_EQ(gfx::Rect(8, 8, 100, 100), test_state->last_bounds());
 }
 
-TEST_P(PipWindowResizerTest, PipWindowInSwipeToDismissGestureLocksToAxis) {
-  PreparePipWindow(gfx::Rect(8, 8, 100, 100));
+TEST_F(PipWindowResizerTest, PipWindowInSwipeToDismissGestureLocksToAxis) {
+  UpdateWorkArea("400x400");
+  PreparePipWindow(gfx::Rect(200, 200, 100, 100));
+  auto widget = CreateWidgetForTest(gfx::Rect(8, 8, 100, 100));
+  auto* window = widget->GetNativeWindow();
+  FakeWindowState* test_state =
+      new FakeWindowState(mojom::WindowStateType::PIP);
+  wm::GetWindowState(window)->SetStateObject(
+      std::unique_ptr<wm::WindowState::State>(test_state));
   std::unique_ptr<PipWindowResizer> resizer(
-      CreateResizerForTest(HTCAPTION, gfx::Point(50, 50)));
+      CreateResizerForTest(HTCAPTION, window));
   ASSERT_TRUE(resizer.get());
 
   // Drag to the left, but only a little bit, to start a swipe-to-dismiss.
   resizer->Drag(CalculateDragPoint(*resizer, -30, 0), 0);
-  EXPECT_EQ(gfx::Rect(-22, 8, 100, 100), test_state()->last_bounds());
+  EXPECT_EQ(gfx::Rect(-22, 8, 100, 100), test_state->last_bounds());
 
   // Now try to drag down, it should be locked to the horizontal axis.
   resizer->Drag(CalculateDragPoint(*resizer, -30, 30), 0);
-  EXPECT_EQ(gfx::Rect(-22, 8, 100, 100), test_state()->last_bounds());
+  EXPECT_EQ(gfx::Rect(-22, 8, 100, 100), test_state->last_bounds());
 }
 
-TEST_P(PipWindowResizerTest,
+TEST_F(PipWindowResizerTest,
        PipWindowMovedAwayFromScreenEdgeNoLongerCanSwipeToDismiss) {
-  PreparePipWindow(gfx::Rect(8, 16, 100, 100));
-  std::unique_ptr<PipWindowResizer> resizer(CreateResizerForTest(HTCAPTION));
+  UpdateWorkArea("400x400");
+  PreparePipWindow(gfx::Rect(200, 200, 100, 100));
+  auto widget = CreateWidgetForTest(gfx::Rect(8, 16, 100, 100));
+  auto* window = widget->GetNativeWindow();
+  FakeWindowState* test_state =
+      new FakeWindowState(mojom::WindowStateType::PIP);
+  wm::GetWindowState(window)->SetStateObject(
+      std::unique_ptr<wm::WindowState::State>(test_state));
+  std::unique_ptr<PipWindowResizer> resizer(
+      CreateResizerForTest(HTCAPTION, window));
   ASSERT_TRUE(resizer.get());
 
   // Drag to the right and up a bit.
   resizer->Drag(CalculateDragPoint(*resizer, 30, -8), 0);
-  EXPECT_EQ(gfx::Rect(38, 8, 100, 100), test_state()->last_bounds());
+  EXPECT_EQ(gfx::Rect(38, 8, 100, 100), test_state->last_bounds());
 
   // Now try to drag to the left start a swipe-to-dismiss. It should stop
   // at the edge of the work area.
   resizer->Drag(CalculateDragPoint(*resizer, -30, -8), 0);
-  EXPECT_EQ(gfx::Rect(8, 8, 100, 100), test_state()->last_bounds());
+  EXPECT_EQ(gfx::Rect(8, 8, 100, 100), test_state->last_bounds());
 }
 
-TEST_P(PipWindowResizerTest, PipWindowAtCornerLocksToOneAxisOnSwipeToDismiss) {
-  PreparePipWindow(gfx::Rect(8, 8, 100, 100));
-  std::unique_ptr<PipWindowResizer> resizer(CreateResizerForTest(HTCAPTION));
+TEST_F(PipWindowResizerTest, PipWindowAtCornerLocksToOneAxisOnSwipeToDismiss) {
+  UpdateWorkArea("400x400");
+  PreparePipWindow(gfx::Rect(200, 200, 100, 100));
+  auto widget = CreateWidgetForTest(gfx::Rect(8, 8, 100, 100));
+  auto* window = widget->GetNativeWindow();
+  FakeWindowState* test_state =
+      new FakeWindowState(mojom::WindowStateType::PIP);
+  wm::GetWindowState(window)->SetStateObject(
+      std::unique_ptr<wm::WindowState::State>(test_state));
+  std::unique_ptr<PipWindowResizer> resizer(
+      CreateResizerForTest(HTCAPTION, window));
   ASSERT_TRUE(resizer.get());
 
   // Try dragging up and to the left. It should lock onto the axis with the
   // largest displacement.
   resizer->Drag(CalculateDragPoint(*resizer, -30, -40), 0);
-  EXPECT_EQ(gfx::Rect(8, -32, 100, 100), test_state()->last_bounds());
+  EXPECT_EQ(gfx::Rect(8, -32, 100, 100), test_state->last_bounds());
 }
 
-TEST_P(
+TEST_F(
     PipWindowResizerTest,
     PipWindowMustBeDraggedMostlyInDirectionOfDismissToInitiateSwipeToDismiss) {
-  PreparePipWindow(gfx::Rect(8, 8, 100, 100));
-  std::unique_ptr<PipWindowResizer> resizer(CreateResizerForTest(HTCAPTION));
+  UpdateWorkArea("400x400");
+  PreparePipWindow(gfx::Rect(200, 200, 100, 100));
+  auto widget = CreateWidgetForTest(gfx::Rect(8, 8, 100, 100));
+  auto* window = widget->GetNativeWindow();
+  FakeWindowState* test_state =
+      new FakeWindowState(mojom::WindowStateType::PIP);
+  wm::GetWindowState(window)->SetStateObject(
+      std::unique_ptr<wm::WindowState::State>(test_state));
+  std::unique_ptr<PipWindowResizer> resizer(
+      CreateResizerForTest(HTCAPTION, window));
   ASSERT_TRUE(resizer.get());
 
   // Try a lot downward and a bit to the left. Swiping should not be initiated.
   resizer->Drag(CalculateDragPoint(*resizer, -30, 50), 0);
-  EXPECT_EQ(gfx::Rect(8, 58, 100, 100), test_state()->last_bounds());
+  EXPECT_EQ(gfx::Rect(8, 58, 100, 100), test_state->last_bounds());
 }
 
-TEST_P(PipWindowResizerTest,
+TEST_F(PipWindowResizerTest,
        PipWindowDoesNotMoveUntilStatusOfSwipeToDismissGestureIsKnown) {
-  PreparePipWindow(gfx::Rect(8, 8, 100, 100));
-  std::unique_ptr<PipWindowResizer> resizer(CreateResizerForTest(HTCAPTION));
+  UpdateWorkArea("400x400");
+  PreparePipWindow(gfx::Rect(200, 200, 100, 100));
+  auto widget = CreateWidgetForTest(gfx::Rect(8, 8, 100, 100));
+  auto* window = widget->GetNativeWindow();
+  FakeWindowState* test_state =
+      new FakeWindowState(mojom::WindowStateType::PIP);
+  wm::GetWindowState(window)->SetStateObject(
+      std::unique_ptr<wm::WindowState::State>(test_state));
+  std::unique_ptr<PipWindowResizer> resizer(
+      CreateResizerForTest(HTCAPTION, window));
   ASSERT_TRUE(resizer.get());
 
   // Move a small amount - this should not trigger any bounds change, since
   // we don't know whether a swipe will start or not.
   resizer->Drag(CalculateDragPoint(*resizer, -4, 0), 0);
-  EXPECT_TRUE(test_state()->last_bounds().IsEmpty());
+  EXPECT_TRUE(test_state->last_bounds().IsEmpty());
 }
 
-TEST_P(PipWindowResizerTest, PipWindowIsFlungToEdge) {
+TEST_F(PipWindowResizerTest, PipWindowIsFlungToEdge) {
+  UpdateWorkArea("400x400");
   PreparePipWindow(gfx::Rect(200, 200, 100, 100));
 
   {
@@ -396,7 +414,8 @@
   }
 }
 
-TEST_P(PipWindowResizerTest, PipWindowIsFlungDiagonally) {
+TEST_F(PipWindowResizerTest, PipWindowIsFlungDiagonally) {
+  UpdateWorkArea("400x400");
   PreparePipWindow(gfx::Rect(200, 200, 100, 100));
 
   {
@@ -499,15 +518,14 @@
   }
 }
 
-TEST_P(PipWindowResizerTest, PipWindowFlungAvoidsFloatingKeyboard) {
-  PreparePipWindow(gfx::Rect(200, 200, 75, 75));
+TEST_F(PipWindowResizerTest, PipWindowFlungAvoidsFloatingKeyboard) {
+  PreparePipWindow(gfx::Rect(200, 200, 100, 100));
 
   auto* keyboard_controller = keyboard::KeyboardController::Get();
   keyboard_controller->SetContainerType(
       keyboard::mojom::ContainerType::kFloating, gfx::Rect(0, 0, 1, 1),
       base::DoNothing());
-  keyboard_controller->ShowKeyboardInDisplay(
-      wm::GetWindowState(window())->GetDisplay());
+  keyboard_controller->ShowKeyboard(/*lock=*/true);
   ASSERT_TRUE(keyboard::WaitUntilShown());
 
   aura::Window* keyboard_window = keyboard_controller->GetKeyboardWindow();
@@ -521,367 +539,58 @@
   Fling(std::move(resizer), -4000.f, 0.f);
 
   // Appear below the keyboard.
-  EXPECT_EQ(gfx::Rect(8, 258, 75, 75), test_state()->last_bounds());
+  EXPECT_EQ(gfx::Rect(8, 258, 100, 100), test_state()->last_bounds());
 }
 
-TEST_P(PipWindowResizerTest, PipWindowDoesNotChangeDisplayOnDrag) {
+TEST_F(PipWindowResizerTest, PipWindowInsidePrimaryDisplay) {
+  UpdateWorkArea("400x400,400x400");
+
+  // Ensure the initial position is in the primary display.
+  const display::Display& primary_display =
+      Shell::Get()->display_manager()->GetDisplayAt(0);
   PreparePipWindow(gfx::Rect(200, 200, 100, 100));
-  display::Display display = wm::GetWindowState(window())->GetDisplay();
   gfx::Rect rect_in_screen = window()->bounds();
   ::wm::ConvertRectToScreen(window()->parent(), &rect_in_screen);
-  EXPECT_TRUE(display.bounds().Contains(rect_in_screen));
+  EXPECT_TRUE(primary_display.bounds().Contains(rect_in_screen));
 
   // Drag inside the display.
   std::unique_ptr<PipWindowResizer> resizer(CreateResizerForTest(HTCAPTION));
   ASSERT_TRUE(resizer.get());
   resizer->Drag(CalculateDragPoint(*resizer, 10, 10), 0);
 
-  // Ensure the position is still in the display.
+  // Ensure the position is still in the primary display.
   EXPECT_EQ(gfx::Rect(210, 210, 100, 100), test_state()->last_bounds());
-  EXPECT_EQ(display.id(), test_state()->last_window_state()->GetDisplay().id());
+  EXPECT_EQ(primary_display.id(),
+            test_state()->last_window_state()->GetDisplay().id());
   rect_in_screen = window()->bounds();
   ::wm::ConvertRectToScreen(window()->parent(), &rect_in_screen);
-  EXPECT_TRUE(display.bounds().Contains(rect_in_screen));
-}
-
-TEST_P(PipWindowResizerTest, PipRestoreBoundsSetOnFling) {
-  PreparePipWindow(gfx::Rect(200, 200, 100, 100));
-
-  {
-    std::unique_ptr<PipWindowResizer> resizer(CreateResizerForTest(HTCAPTION));
-    ASSERT_TRUE(resizer.get());
-
-    resizer->Drag(CalculateDragPoint(*resizer, 10, 10), 0);
-    Fling(std::move(resizer), 3000.f, 3000.f);
-  }
-
-  wm::WindowState* window_state = wm::GetWindowState(window());
-  EXPECT_TRUE(window_state->HasRestoreBounds());
-  EXPECT_EQ(gfx::Rect(292, 292, 100, 100),
-            window_state->GetRestoreBoundsInParent());
-}
-
-TEST_P(PipWindowResizerTest, PipStartAndFinishFreeResizeUmaMetrics) {
-  PreparePipWindow(gfx::Rect(200, 200, 100, 100));
-  std::unique_ptr<PipWindowResizer> resizer(CreateResizerForTest(HTBOTTOM));
-  ASSERT_TRUE(resizer.get());
-
-  EXPECT_EQ(1, histograms().GetBucketCount(kAshPipEventsHistogramName,
-                                           Sample(AshPipEvents::FREE_RESIZE)));
-  histograms().ExpectTotalCount(kAshPipEventsHistogramName, 1);
-
-  resizer->Drag(CalculateDragPoint(*resizer, 100, 0), 0);
-  resizer->CompleteDrag();
-
-  histograms().ExpectTotalCount(kAshPipEventsHistogramName, 1);
-}
-
-TEST_P(PipWindowResizerTest, PipFreeResizeAreaUmaMetrics) {
-  PreparePipWindow(gfx::Rect(200, 200, 100, 100));
-  std::unique_ptr<PipWindowResizer> resizer(CreateResizerForTest(HTBOTTOM));
-  ASSERT_TRUE(resizer.get());
-
-  EXPECT_EQ(1, histograms().GetBucketCount(
-                   kAshPipFreeResizeInitialAreaHistogramName, Sample(6)));
-  histograms().ExpectTotalCount(kAshPipFreeResizeInitialAreaHistogramName, 1);
-
-  window()->layer()->SetBounds(gfx::Rect(200, 200, 100, 190));
-  resizer->CompleteDrag();
-
-  EXPECT_EQ(1, histograms().GetBucketCount(
-                   kAshPipFreeResizeFinishAreaHistogramName, Sample(12)));
-  histograms().ExpectTotalCount(kAshPipFreeResizeFinishAreaHistogramName, 1);
-}
-
-TEST_P(PipWindowResizerTest, DragDetailsAreDestroyed) {
-  PreparePipWindow(gfx::Rect(200, 200, 100, 100));
-  wm::WindowState* window_state = wm::GetWindowState(window());
-
-  {
-    std::unique_ptr<PipWindowResizer> resizer(CreateResizerForTest(HTCAPTION));
-    ASSERT_TRUE(resizer.get());
-
-    resizer->Drag(CalculateDragPoint(*resizer, 0, 10), 0);
-    EXPECT_NE(nullptr, window_state->drag_details());
-
-    resizer->CompleteDrag();
-    EXPECT_NE(nullptr, window_state->drag_details());
-  }
-  EXPECT_EQ(nullptr, window_state->drag_details());
-}
-
-// TODO: UpdateDisplay() doesn't support different layouts of multiple displays.
-// We should add some way to try multiple layouts.
-INSTANTIATE_TEST_SUITE_P(
-    /* no prefix */,
-    PipWindowResizerTest,
-    testing::Values(std::make_tuple("400x400", 0u),
-                    std::make_tuple("400x400/r", 0u),
-                    std::make_tuple("400x400/u", 0u),
-                    std::make_tuple("400x400/l", 0u),
-                    std::make_tuple("800x800*2", 0u),
-                    std::make_tuple("400x400,400x400", 0u),
-                    std::make_tuple("400x400,400x400", 1u)));
-
-using PipWindowResizerNonSquareAspectRatioTest = PipWindowResizerTest;
-
-TEST_P(PipWindowResizerNonSquareAspectRatioTest, PipPositionUmaMetrics) {
-  histograms().ExpectTotalCount(kAshPipPositionHistogramName, 0);
-
-  {
-    // Check TOP_LEFT.
-    PreparePipWindow(gfx::Rect(0, 0, 100, 100));
-    std::unique_ptr<PipWindowResizer> resizer(CreateResizerForTest(HTCAPTION));
-    ASSERT_TRUE(resizer.get());
-    resizer->Drag(CalculateDragPoint(*resizer, 0, 0), 0);
-    resizer->CompleteDrag();
-
-    EXPECT_EQ(1, histograms().GetBucketCount(kAshPipPositionHistogramName,
-                                             Sample(AshPipPosition::TOP_LEFT)));
-    histograms().ExpectTotalCount(kAshPipPositionHistogramName, 1);
-  }
-
-  {
-    // Check TOP_MIDDLE.
-    PreparePipWindow(gfx::Rect(100, 0, 100, 100));
-    std::unique_ptr<PipWindowResizer> resizer(CreateResizerForTest(HTCAPTION));
-    ASSERT_TRUE(resizer.get());
-    resizer->Drag(CalculateDragPoint(*resizer, 0, 0), 0);
-    resizer->CompleteDrag();
-
-    EXPECT_EQ(1,
-              histograms().GetBucketCount(kAshPipPositionHistogramName,
-                                          Sample(AshPipPosition::TOP_MIDDLE)));
-    histograms().ExpectTotalCount(kAshPipPositionHistogramName, 2);
-  }
-
-  {
-    // Check TOP_RIGHT.
-    PreparePipWindow(gfx::Rect(250, 0, 100, 100));
-    std::unique_ptr<PipWindowResizer> resizer(CreateResizerForTest(HTCAPTION));
-    ASSERT_TRUE(resizer.get());
-    resizer->Drag(CalculateDragPoint(*resizer, 0, 0), 0);
-    resizer->CompleteDrag();
-
-    EXPECT_EQ(1,
-              histograms().GetBucketCount(kAshPipPositionHistogramName,
-                                          Sample(AshPipPosition::TOP_RIGHT)));
-    histograms().ExpectTotalCount(kAshPipPositionHistogramName, 3);
-  }
-
-  {
-    // Check MIDDLE_LEFT.
-    PreparePipWindow(gfx::Rect(0, 100, 100, 100));
-    std::unique_ptr<PipWindowResizer> resizer(CreateResizerForTest(HTCAPTION));
-    ASSERT_TRUE(resizer.get());
-    resizer->Drag(CalculateDragPoint(*resizer, 0, 0), 0);
-    resizer->CompleteDrag();
-
-    EXPECT_EQ(1,
-              histograms().GetBucketCount(kAshPipPositionHistogramName,
-                                          Sample(AshPipPosition::MIDDLE_LEFT)));
-    histograms().ExpectTotalCount(kAshPipPositionHistogramName, 4);
-  }
-
-  {
-    // Check MIDDLE.
-    PreparePipWindow(gfx::Rect(100, 100, 100, 100));
-    std::unique_ptr<PipWindowResizer> resizer(CreateResizerForTest(HTCAPTION));
-    ASSERT_TRUE(resizer.get());
-    resizer->Drag(CalculateDragPoint(*resizer, 0, 0), 0);
-    resizer->CompleteDrag();
-
-    EXPECT_EQ(1, histograms().GetBucketCount(kAshPipPositionHistogramName,
-                                             Sample(AshPipPosition::MIDDLE)));
-    histograms().ExpectTotalCount(kAshPipPositionHistogramName, 5);
-  }
-
-  {
-    // Check MIDDLE_RIGHT.
-    PreparePipWindow(gfx::Rect(250, 100, 100, 100));
-    std::unique_ptr<PipWindowResizer> resizer(CreateResizerForTest(HTCAPTION));
-    ASSERT_TRUE(resizer.get());
-    resizer->Drag(CalculateDragPoint(*resizer, 0, 0), 0);
-    resizer->CompleteDrag();
-
-    EXPECT_EQ(
-        1, histograms().GetBucketCount(kAshPipPositionHistogramName,
-                                       Sample(AshPipPosition::MIDDLE_RIGHT)));
-    histograms().ExpectTotalCount(kAshPipPositionHistogramName, 6);
-  }
-
-  {
-    // Check BOTTOM_LEFT.
-    PreparePipWindow(gfx::Rect(0, 250, 100, 100));
-    std::unique_ptr<PipWindowResizer> resizer(CreateResizerForTest(HTCAPTION));
-    ASSERT_TRUE(resizer.get());
-    resizer->Drag(CalculateDragPoint(*resizer, 0, 0), 0);
-    resizer->CompleteDrag();
-
-    EXPECT_EQ(1,
-              histograms().GetBucketCount(kAshPipPositionHistogramName,
-                                          Sample(AshPipPosition::BOTTOM_LEFT)));
-    histograms().ExpectTotalCount(kAshPipPositionHistogramName, 7);
-  }
-
-  {
-    // Check BOTTOM_MIDDLE.
-    PreparePipWindow(gfx::Rect(100, 250, 100, 100));
-    std::unique_ptr<PipWindowResizer> resizer(CreateResizerForTest(HTCAPTION));
-    ASSERT_TRUE(resizer.get());
-    resizer->Drag(CalculateDragPoint(*resizer, 0, 0), 0);
-    resizer->CompleteDrag();
-
-    EXPECT_EQ(
-        1, histograms().GetBucketCount(kAshPipPositionHistogramName,
-                                       Sample(AshPipPosition::BOTTOM_MIDDLE)));
-    histograms().ExpectTotalCount(kAshPipPositionHistogramName, 8);
-  }
-
-  {
-    // Check BOTTOM_RIGHT.
-    PreparePipWindow(gfx::Rect(250, 250, 100, 100));
-    std::unique_ptr<PipWindowResizer> resizer(CreateResizerForTest(HTCAPTION));
-    ASSERT_TRUE(resizer.get());
-    resizer->Drag(CalculateDragPoint(*resizer, 0, 0), 0);
-    resizer->CompleteDrag();
-
-    EXPECT_EQ(
-        1, histograms().GetBucketCount(kAshPipPositionHistogramName,
-                                       Sample(AshPipPosition::BOTTOM_RIGHT)));
-    histograms().ExpectTotalCount(kAshPipPositionHistogramName, 9);
-  }
-}
-
-TEST_P(PipWindowResizerNonSquareAspectRatioTest,
-       PipPositionUmaMetricsCornerPriority) {
-  histograms().ExpectTotalCount(kAshPipPositionHistogramName, 0);
-
-  // Check corners are priotised over edges and middle.
-  {
-    // Check TOP_LEFT.
-    PreparePipWindow(gfx::Rect(0, 0, 300, 210));
-    std::unique_ptr<PipWindowResizer> resizer(CreateResizerForTest(HTCAPTION));
-    ASSERT_TRUE(resizer.get());
-    resizer->Drag(CalculateDragPoint(*resizer, 0, 0), 0);
-    resizer->CompleteDrag();
-
-    EXPECT_EQ(1, histograms().GetBucketCount(kAshPipPositionHistogramName,
-                                             Sample(AshPipPosition::TOP_LEFT)));
-    histograms().ExpectTotalCount(kAshPipPositionHistogramName, 1);
-  }
-
-  {
-    // Check TOP_RIGHT.
-    PreparePipWindow(gfx::Rect(100, 0, 300, 210));
-    std::unique_ptr<PipWindowResizer> resizer(CreateResizerForTest(HTCAPTION));
-    ASSERT_TRUE(resizer.get());
-    resizer->Drag(CalculateDragPoint(*resizer, 0, 0), 0);
-    resizer->CompleteDrag();
-
-    EXPECT_EQ(1,
-              histograms().GetBucketCount(kAshPipPositionHistogramName,
-                                          Sample(AshPipPosition::TOP_RIGHT)));
-    histograms().ExpectTotalCount(kAshPipPositionHistogramName, 2);
-  }
-
-  {
-    // Check BOTTOM_LEFT.
-    PreparePipWindow(gfx::Rect(0, 190, 300, 210));
-    std::unique_ptr<PipWindowResizer> resizer(CreateResizerForTest(HTCAPTION));
-    ASSERT_TRUE(resizer.get());
-    resizer->Drag(CalculateDragPoint(*resizer, 0, 0), 0);
-    resizer->CompleteDrag();
-
-    EXPECT_EQ(1,
-              histograms().GetBucketCount(kAshPipPositionHistogramName,
-                                          Sample(AshPipPosition::BOTTOM_LEFT)));
-    histograms().ExpectTotalCount(kAshPipPositionHistogramName, 3);
-  }
-
-  {
-    // Check BOTTOM_RIGHT.
-    PreparePipWindow(gfx::Rect(100, 190, 300, 210));
-    std::unique_ptr<PipWindowResizer> resizer(CreateResizerForTest(HTCAPTION));
-    ASSERT_TRUE(resizer.get());
-    resizer->Drag(CalculateDragPoint(*resizer, 0, 0), 0);
-    resizer->CompleteDrag();
-
-    EXPECT_EQ(
-        1, histograms().GetBucketCount(kAshPipPositionHistogramName,
-                                       Sample(AshPipPosition::BOTTOM_RIGHT)));
-    histograms().ExpectTotalCount(kAshPipPositionHistogramName, 4);
-  }
+  EXPECT_TRUE(primary_display.bounds().Contains(rect_in_screen));
 }
 
-TEST_P(PipWindowResizerNonSquareAspectRatioTest,
-       PipPositionUmaMetricsEdgePriority) {
-  histograms().ExpectTotalCount(kAshPipPositionHistogramName, 0);
+TEST_F(PipWindowResizerTest, PipWindowInsideExternalDisplay) {
+  UpdateWorkArea("400x400,400x400");
 
-  // Test that edges are prioritised over middle.
-  {
-    // Check TOP_MIDDLE.
-    PreparePipWindow(gfx::Rect(100, 0, 200, 220));
-    std::unique_ptr<PipWindowResizer> resizer(CreateResizerForTest(HTCAPTION));
-    ASSERT_TRUE(resizer.get());
-    resizer->Drag(CalculateDragPoint(*resizer, 0, 0), 0);
-    resizer->CompleteDrag();
-
-    EXPECT_EQ(1,
-              histograms().GetBucketCount(kAshPipPositionHistogramName,
-                                          Sample(AshPipPosition::TOP_MIDDLE)));
-    histograms().ExpectTotalCount(kAshPipPositionHistogramName, 1);
-  }
-
-  {
-    // Check BOTTOM_MIDDLE.
-    PreparePipWindow(gfx::Rect(100, 80, 200, 220));
-    std::unique_ptr<PipWindowResizer> resizer(CreateResizerForTest(HTCAPTION));
-    ASSERT_TRUE(resizer.get());
-    resizer->Drag(CalculateDragPoint(*resizer, 0, 0), 0);
-    resizer->CompleteDrag();
-
-    EXPECT_EQ(
-        1, histograms().GetBucketCount(kAshPipPositionHistogramName,
-                                       Sample(AshPipPosition::BOTTOM_MIDDLE)));
-    histograms().ExpectTotalCount(kAshPipPositionHistogramName, 2);
-  }
-
-  {
-    // Check MIDDLE_LEFT.
-    PreparePipWindow(gfx::Rect(0, 90, 300, 120));
-    std::unique_ptr<PipWindowResizer> resizer(CreateResizerForTest(HTCAPTION));
-    ASSERT_TRUE(resizer.get());
-    resizer->Drag(CalculateDragPoint(*resizer, 0, 0), 0);
-    resizer->CompleteDrag();
-
-    EXPECT_EQ(1,
-              histograms().GetBucketCount(kAshPipPositionHistogramName,
-                                          Sample(AshPipPosition::MIDDLE_LEFT)));
-    histograms().ExpectTotalCount(kAshPipPositionHistogramName, 3);
-  }
+  // Ensure the initial position is in the secondary display.
+  const display::Display& secondary_display =
+      Shell::Get()->display_manager()->GetDisplayAt(1);
+  PreparePipWindow(gfx::Rect(600, 200, 100, 100));
+  gfx::Rect rect_in_screen = window()->bounds();
+  ::wm::ConvertRectToScreen(window()->parent(), &rect_in_screen);
+  EXPECT_TRUE(secondary_display.bounds().Contains(rect_in_screen));
 
-  {
-    // Check MIDDLE_RIGHT.
-    PreparePipWindow(gfx::Rect(100, 90, 300, 120));
+  // Drag inside the display.
     std::unique_ptr<PipWindowResizer> resizer(CreateResizerForTest(HTCAPTION));
     ASSERT_TRUE(resizer.get());
-    resizer->Drag(CalculateDragPoint(*resizer, 0, 0), 0);
-    resizer->CompleteDrag();
+  resizer->Drag(CalculateDragPoint(*resizer, 10, 10), 0);
 
-    EXPECT_EQ(
-        1, histograms().GetBucketCount(kAshPipPositionHistogramName,
-                                       Sample(AshPipPosition::MIDDLE_RIGHT)));
-    histograms().ExpectTotalCount(kAshPipPositionHistogramName, 4);
-  }
+  // Ensure the position is still in the secondary display.
+  EXPECT_EQ(gfx::Rect(210, 210, 100, 100), test_state()->last_bounds());
+  EXPECT_EQ(secondary_display.id(),
+            test_state()->last_window_state()->GetDisplay().id());
+  rect_in_screen = window()->bounds();
+  ::wm::ConvertRectToScreen(window()->parent(), &rect_in_screen);
+  EXPECT_TRUE(secondary_display.bounds().Contains(rect_in_screen));
 }
 
-INSTANTIATE_TEST_SUITE_P(
-    /* no prefix */,
-    PipWindowResizerNonSquareAspectRatioTest,
-    testing::Values(std::make_tuple("400x300", 0u),
-                    std::make_tuple("400x300,4000x3000", 0u),
-                    std::make_tuple("4000x3000,400x300", 1u)));
-
 }  // namespace wm
 }  // namespace ash
--- a/ash/wm/screen_pinning_controller.h	2019-05-17 17:45:36.504000000 +0300
+++ b/ash/wm/screen_pinning_controller.h	2019-05-17 18:53:08.372000000 +0300
@@ -28,7 +28,7 @@
 // interrupted by notifications. This could be used, for example, if you are
 // developing an education app to support high stakes assessment requirements on
 // Android, or a single-purpose or kiosk application."
-// https://developer.8n6r01d.qjz9zk/about/versions/android-5.0.html#ScreenPinning
+// https://developer.android.com/about/versions/android-5.0.html#ScreenPinning
 // See also ArcKioskAppLauncher::CheckAndPinWindow().
 class ASH_EXPORT ScreenPinningController
     : public WindowTreeHostManager::Observer {
--- a/ash/wm/splitview/split_view_constants.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/splitview/split_view_constants.h	2019-05-17 18:53:08.372000000 +0300
@@ -12,10 +12,10 @@
 
 // The ratio between a highlight view's primary axis, and the screens
 // primary axis.
-ASH_EXPORT constexpr float kHighlightScreenPrimaryAxisRatio = 0.10;
+ASH_EXPORT constexpr double kHighlightScreenPrimaryAxisRatio = 0.10;
 
 // The padding between a highlight view and the edge of the screen.
-ASH_EXPORT constexpr float kHighlightScreenEdgePaddingDp = 8;
+ASH_EXPORT constexpr double kHighlightScreenEdgePaddingDp = 8;
 
 // The amount of inset to be applied on a split view label. Here horizontal and
 // vertical apply to the orientation before rotation (if there is rotation).
--- a/ash/wm/splitview/split_view_controller.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/splitview/split_view_controller.cc	2019-05-17 18:53:08.376000000 +0300
@@ -9,7 +9,6 @@
 
 #include "ash/accessibility/accessibility_controller.h"
 #include "ash/display/screen_orientation_controller.h"
-#include "ash/public/cpp/presentation_time_recorder.h"
 #include "ash/public/cpp/window_properties.h"
 #include "ash/screen_util.h"
 #include "ash/session/session_controller.h"
@@ -42,8 +41,6 @@
 #include "ui/base/hit_test.h"
 #include "ui/base/l10n/l10n_util.h"
 #include "ui/compositor/layer.h"
-#include "ui/gfx/animation/slide_animation.h"
-#include "ui/gfx/animation/tween.h"
 #include "ui/gfx/transform_util.h"
 #include "ui/views/widget/widget.h"
 #include "ui/wm/core/coordinate_conversion.h"
@@ -71,30 +68,10 @@
 constexpr float kBlackScrimFadeInRatio = 0.1f;
 constexpr float kBlackScrimOpacity = 0.4f;
 
-// The duration of the divider snap animation, in milliseconds.
-constexpr int kDividerSnapDurationMs = 300;
-
 // Toast data.
 constexpr char kAppCannotSnapToastId[] = "split_view_app_cannot_snap";
 constexpr int kAppCannotSnapToastDurationMs = 2500;
 
-// Histogram names that record presentation time of resize operation with
-// following conditions, a) single snapped window, empty overview, b) two
-// snapped windows, c) single snapped window and non empty overview.
-constexpr char kSplitViewResizeSingleHistogram[] =
-    "Ash.SplitViewResize.PresentationTime.TabletMode.SingleWindow";
-constexpr char kSplitViewResizeMultiHistogram[] =
-    "Ash.SplitViewResize.PresentationTime.TabletMode.MultiWindow";
-constexpr char kSplitViewResizeWithOverviewHistogram[] =
-    "Ash.SplitViewResize.PresentationTime.TabletMode.WithOverview";
-
-constexpr char kSplitViewResizeSingleMaxLatencyHistogram[] =
-    "Ash.SplitViewResize.PresentationTime.MaxLatency.TabletMode.SingleWindow";
-constexpr char kSplitViewResizeMultiMaxLatencyHistogram[] =
-    "Ash.SplitViewResize.PresentationTime.MaxLatency.TabletMode.MultiWindow";
-constexpr char kSplitViewResizeWithOverviewMaxLatencyHistogram[] =
-    "Ash.SplitViewResize.PresentationTime.MaxLatency.TabletMode.WithOverview";
-
 gfx::Point GetBoundedPosition(const gfx::Point& location_in_screen,
                               const gfx::Rect& bounds_in_screen) {
   return gfx::Point(
@@ -137,7 +114,7 @@
     minimum_width = is_landscape ? minimum_size.width() : minimum_size.height();
   }
   return minimum_width;
-}
+};
 
 // Returns true if |window| is currently snapped.
 bool IsSnapped(aura::Window* window) {
@@ -235,56 +212,6 @@
   DISALLOW_COPY_AND_ASSIGN(TabDraggedWindowObserver);
 };
 
-// Animates the divider to its closest fixed position.
-// SplitViewController::is_resizing_ is assumed to be already set to false
-// before this animation starts, but some resizing logic is delayed until this
-// animation ends.
-class SplitViewController::DividerSnapAnimation
-    : public gfx::SlideAnimation,
-      public gfx::AnimationDelegate {
- public:
-  DividerSnapAnimation(SplitViewController* split_view_controller,
-                       int starting_position,
-                       int ending_position)
-      : gfx::SlideAnimation(this),
-        split_view_controller_(split_view_controller),
-        starting_position_(starting_position),
-        ending_position_(ending_position) {
-    SetSlideDuration(kDividerSnapDurationMs);
-    SetTweenType(gfx::Tween::EASE_IN);
-  }
-
-  ~DividerSnapAnimation() override = default;
-
-  int ending_position() const { return ending_position_; }
-
- private:
-  // gfx::AnimationDelegate:
-  void AnimationEnded(const gfx::Animation* animation) override {
-    DCHECK(split_view_controller_->IsSplitViewModeActive());
-    DCHECK(!split_view_controller_->is_resizing_);
-    DCHECK_EQ(ending_position_, split_view_controller_->divider_position_);
-
-    split_view_controller_->EndResizeImpl();
-    split_view_controller_->EndSplitViewAfterResizingIfAppropriate();
-  }
-
-  void AnimationProgressed(const gfx::Animation* animation) override {
-    DCHECK(split_view_controller_->IsSplitViewModeActive());
-    DCHECK(!split_view_controller_->is_resizing_);
-
-    split_view_controller_->divider_position_ =
-        CurrentValueBetween(starting_position_, ending_position_);
-    split_view_controller_->NotifyDividerPositionChanged();
-    split_view_controller_->UpdateSnappedWindowsAndDividerBounds();
-    split_view_controller_->SetWindowsTransformDuringResizing();
-  }
-
-  SplitViewController* split_view_controller_;
-  int starting_position_;
-  int ending_position_;
-};
-
 SplitViewController::SplitViewController() {
   Shell::Get()->accessibility_controller()->AddObserver(this);
   display::Screen::GetScreen()->AddObserver(this);
@@ -310,14 +237,6 @@
                                      SnapPosition snap_position) {
   DCHECK(window && CanSnapInSplitview(window));
   DCHECK_NE(snap_position, NONE);
-  DCHECK(!is_resizing_);
-
-  // This check detects the case that you try to snap a window while watching
-  // the divider snap animation. It also detects the case that you click a
-  // window in overview while tap dragging the divider (possible by using the
-  // emulator or chrome://flags/#force-tablet-mode).
-  if (IsDividerAnimating())
-    return;
 
   UpdateSnappingWindowTransformedBounds(window);
   RemoveWindowFromOverviewIfApplicable(window);
@@ -325,7 +244,6 @@
   if (state_ == NO_SNAP) {
     // Add observers when the split view mode starts.
     Shell::Get()->AddShellObserver(this);
-    Shell::Get()->overview_controller()->AddObserver(this);
     Shell::Get()->activation_client()->AddObserver(this);
     Shell::Get()->NotifySplitViewModeStarting();
 
@@ -368,7 +286,7 @@
   // Since the minimum size of |window| maybe larger than currently bounds in
   // |snap_position|.
   if (state_ != NO_SNAP) {
-    divider_position_ = GetClosestFixedDividerPosition();
+    MoveDividerToClosestFixedPosition();
     UpdateSnappedWindowsAndDividerBounds();
   }
 
@@ -390,18 +308,6 @@
 void SplitViewController::SwapWindows() {
   DCHECK(IsSplitViewModeActive());
 
-  // Ignore |is_resizing_| because it will be true in case of double tapping
-  // (not double clicking) the divider without ever actually dragging it
-  // anywhere. Double tapping the divider triggers StartResize(), EndResize(),
-  // StartResize(), SwapWindows(), EndResize(). Double clicking the divider
-  // (possible by using the emulator or chrome://flags/#force-tablet-mode)
-  // triggers StartResize(), EndResize(), StartResize(), EndResize(),
-  // SwapWindows(). Those two sequences of function calls are what were mainly
-  // considered in writing the condition for bailing out here, to disallow
-  // swapping windows when the divider is being dragged or is animating.
-  if (IsDividerAnimating())
-    return;
-
   aura::Window* new_left_window = right_window_;
   aura::Window* new_right_window = left_window_;
   left_window_ = new_left_window;
@@ -411,7 +317,7 @@
   if (!left_window_ || !right_window_)
     default_snap_position_ = left_window_ ? LEFT : RIGHT;
 
-  divider_position_ = GetClosestFixedDividerPosition();
+  MoveDividerToClosestFixedPosition();
   UpdateSnappedWindowsAndDividerBounds();
   UpdateSplitViewStateAndNotifyObservers();
 
@@ -489,17 +395,6 @@
 
 void SplitViewController::StartResize(const gfx::Point& location_in_screen) {
   DCHECK(IsSplitViewModeActive());
-
-  // |is_resizing_| may be true here, because you can start dragging the divider
-  // with a pointing device while already dragging it by touch, or vice versa.
-  // It is possible by using the emulator or chrome://flags/#force-tablet-mode.
-  // Bailing out here does not stop the user from dragging by touch and with a
-  // pointing device simultaneously; it just avoids duplicate calls to
-  // CreateDragDetails() and OnDragStarted(). We also bail out here if you try
-  // to start dragging the divider during its snap animation.
-  if (is_resizing_ || IsDividerAnimating())
-    return;
-
   is_resizing_ = true;
   split_view_divider_->UpdateDividerBounds();
   previous_event_location_ = location_in_screen;
@@ -517,25 +412,6 @@
   }
 
   base::RecordAction(base::UserMetricsAction("SplitView_ResizeWindows"));
-  if (state_ == BOTH_SNAPPED) {
-    presentation_time_recorder_ =
-        std::make_unique<PresentationTimeHistogramRecorder>(
-            split_view_divider_->divider_widget()->GetCompositor(),
-            kSplitViewResizeMultiHistogram,
-            kSplitViewResizeMultiMaxLatencyHistogram);
-  } else if (GetOverviewSession() && !GetOverviewSession()->IsEmpty()) {
-    presentation_time_recorder_ =
-        std::make_unique<PresentationTimeHistogramRecorder>(
-            split_view_divider_->divider_widget()->GetCompositor(),
-            kSplitViewResizeWithOverviewHistogram,
-            kSplitViewResizeWithOverviewMaxLatencyHistogram);
-  } else {
-    presentation_time_recorder_ =
-        std::make_unique<PresentationTimeHistogramRecorder>(
-            split_view_divider_->divider_widget()->GetCompositor(),
-            kSplitViewResizeSingleHistogram,
-            kSplitViewResizeSingleMaxLatencyHistogram);
-  }
 }
 
 void SplitViewController::Resize(const gfx::Point& location_in_screen) {
@@ -543,7 +419,7 @@
 
   if (!is_resizing_)
     return;
-  presentation_time_recorder_->RequestNext();
+
   const gfx::Rect work_area_bounds =
       screen_util::GetDisplayWorkAreaBoundsInScreenForDefaultContainer(
           GetDefaultSnappedWindow());
@@ -567,10 +443,7 @@
 }
 
 void SplitViewController::EndResize(const gfx::Point& location_in_screen) {
-  presentation_time_recorder_.reset();
   DCHECK(IsSplitViewModeActive());
-  if (!is_resizing_)
-    return;
   // TODO(xdai): Use fade out animation instead of just removing it.
   black_scrim_layer_.reset();
   is_resizing_ = false;
@@ -581,20 +454,44 @@
   gfx::Point modified_location_in_screen =
       GetBoundedPosition(location_in_screen, work_area_bounds);
   UpdateDividerPosition(modified_location_in_screen);
+  MoveDividerToClosestFixedPosition();
   NotifyDividerPositionChanged();
+  RestoreWindowsTransformAfterResizing();
+
+  // Update snapped window/windows bounds before sending OnCompleteDrag() for
+  // smoother resizing visual result.
+  UpdateSnappedWindowsAndDividerBounds();
+
+  FinishWindowResizing(left_window_);
+  FinishWindowResizing(right_window_);
+
   // Need to update snapped windows bounds even if the split view mode may have
   // to exit. Otherwise it's possible for a snapped window stuck in the edge of
   // of the screen while overview mode is active.
   UpdateSnappedWindowsAndDividerBounds();
 
-  const int target_divider_position = GetClosestFixedDividerPosition();
-  if (divider_position_ == target_divider_position) {
-    EndResizeImpl();
-    EndSplitViewAfterResizingIfAppropriate();
-  } else {
-    divider_snap_animation_ = std::make_unique<DividerSnapAnimation>(
-        this, divider_position_, target_divider_position);
-    divider_snap_animation_->Show();
+  // Check if one of the snapped windows needs to be closed.
+  if (ShouldEndSplitViewAfterResizing()) {
+    aura::Window* active_window = GetActiveWindowAfterResizingUponExit();
+
+    // Track the window that needs to be put back into the overview list if we
+    // remain in overview mode.
+    aura::Window* insert_overview_window = nullptr;
+    if (Shell::Get()->overview_controller()->IsSelecting())
+      insert_overview_window = GetDefaultSnappedWindow();
+    EndSplitView();
+    if (active_window) {
+      EndOverview();
+      wm::ActivateWindow(active_window);
+    } else if (insert_overview_window) {
+      // The dimensions of |window| will be very slim because of dragging the
+      // divider to the edge. Change the window dimensions to its tablet mode
+      // dimensions. Note: if split view is no longer constrained to tablet mode
+      // this will be need to updated.
+      TabletModeWindowState::UpdateWindowPosition(
+          wm::GetWindowState(insert_overview_window), /*animate=*/false);
+      InsertWindowToOverview(insert_overview_window);
+    }
   }
 }
 
@@ -614,19 +511,14 @@
 
   // If we are currently in a resize but split view is ending, make sure to end
   // the resize. This can happen, for example, on the transition back to
-  // clamshell mode or when a task is minimized during a resize. Likewise, if
-  // split view is ending during the divider snap animation, then clean that up.
-  const bool is_divider_animating = IsDividerAnimating();
-  if (is_resizing_ || is_divider_animating) {
-    is_resizing_ = false;
-    if (is_divider_animating)
-      StopAndShoveAnimatedDivider();
-    EndResizeImpl();
+  // clamshell mode or when a task is minimized during a resize.
+  if (is_resizing_) {
+    FinishWindowResizing(left_window_);
+    FinishWindowResizing(right_window_);
   }
 
   // Remove observers when the split view mode ends.
   Shell::Get()->RemoveShellObserver(this);
-  Shell::Get()->overview_controller()->RemoveObserver(this);
   Shell::Get()->activation_client()->RemoveObserver(this);
 
   StopObserving(LEFT);
@@ -644,15 +536,10 @@
                            base::Time::Now() - splitview_start_time_);
 }
 
-bool SplitViewController::IsWindowInSplitView(
-    const aura::Window* window) const {
-  return window && (window == left_window_ || window == right_window_);
-}
-
 void SplitViewController::OnWindowDragStarted(aura::Window* dragged_window) {
   DCHECK(dragged_window);
-  if (IsWindowInSplitView(dragged_window))
-    OnSnappedWindowDetached(dragged_window, /*window_drag=*/true);
+  if (dragged_window == left_window_ || dragged_window == right_window_)
+    OnSnappedWindowDetached(dragged_window);
 
   // OnSnappedWindowDetached() may end split view mode.
   if (IsSplitViewModeActive())
@@ -696,11 +583,11 @@
 
 void SplitViewController::OnWindowDestroyed(aura::Window* window) {
   DCHECK(IsSplitViewModeActive());
-  DCHECK(IsWindowInSplitView(window));
+  DCHECK(window == left_window_ || window == right_window_);
   auto iter = snapping_window_transformed_bounds_map_.find(window);
   if (iter != snapping_window_transformed_bounds_map_.end())
     snapping_window_transformed_bounds_map_.erase(iter);
-  OnSnappedWindowDetached(window, /*window_drag=*/false);
+  OnSnappedWindowDetached(window);
 }
 
 void SplitViewController::OnWindowPropertyChanged(aura::Window* window,
@@ -728,7 +615,7 @@
     EndSplitView();
     EndOverview();
   } else if (window_state->IsMinimized()) {
-    OnSnappedWindowDetached(window_state->window(), /*window_drag=*/false);
+    OnSnappedWindowDetached(window_state->window());
     // Insert the minimized window back to overview if split view mode is ended
     // because of the minimization of the window, but overview mode is still
     // active at the moment.
@@ -763,11 +650,9 @@
   }
 
   // Do not snap the window if the activation change is caused by dragging a
-  // window, regardless of tab drag or window drag.
-  if (wm::GetWindowState(gained_active)->is_dragged() ||
-      wm::IsDraggingTabs(gained_active)) {
+  // window's tabs around.
+  if (wm::IsDraggingTabs(gained_active))
     return;
-  }
 
   // Only windows in MRU list can be snapped.
   if (!base::ContainsValue(
@@ -895,16 +780,6 @@
     return;
   }
 
-  // Before adjusting the divider position for the new display metrics, if the
-  // divider is animating to a snap position, then stop it and shove it there.
-  // Postpone EndSplitViewAfterResizingIfAppropriate() until after the
-  // adjustment, because the new display metrics will be used to compare the
-  // divider position against the edges of the screen.
-  if (IsDividerAnimating()) {
-    StopAndShoveAnimatedDivider();
-    EndResizeImpl();
-  }
-
   if ((metrics & display::DisplayObserver::DISPLAY_METRIC_ROTATION) ||
       (metrics & display::DisplayObserver::DISPLAY_METRIC_WORK_AREA)) {
     const gfx::Size divider_size = SplitViewDivider::GetDividerSize(
@@ -928,11 +803,7 @@
   // For other display configuration changes, we only move the divider to the
   // closest fixed position.
   if (!is_resizing_)
-    divider_position_ = GetClosestFixedDividerPosition();
-
-  EndSplitViewAfterResizingIfAppropriate();
-  if (!IsSplitViewModeActive())
-    return;
+    MoveDividerToClosestFixedPosition();
 
   NotifyDividerPositionChanged();
   UpdateSnappedWindowsAndDividerBounds();
@@ -994,12 +865,11 @@
       break;
   }
 
-  // Ensure that overview mode is active if and only if there is a window
-  // snapped to one side but no window snapped to the other side.
+  // If there is a window snapped to one side but no window snapped to the other
+  // side, then overview should be started (to be seen on the side with no
+  // snapped window).
   if (state_ == LEFT_SNAPPED || state_ == RIGHT_SNAPPED)
     StartOverview();
-  else
-    EndOverview();
 }
 
 void SplitViewController::StartObserving(aura::Window* window) {
@@ -1228,7 +1098,7 @@
   }
 }
 
-int SplitViewController::GetClosestFixedDividerPosition() {
+void SplitViewController::MoveDividerToClosestFixedPosition() {
   DCHECK(IsSplitViewModeActive());
 
   const gfx::Rect work_area_bounds_in_screen =
@@ -1250,23 +1120,9 @@
   divider_closest_ratio_ = FindClosestPositionRatio(
       divider_position_ + std::floor(divider_thickness / 2.f),
       divider_end_position);
-  int fix_position = std::floor(divider_end_position * divider_closest_ratio_);
+  divider_position_ = std::floor(divider_end_position * divider_closest_ratio_);
   if (divider_closest_ratio_ > 0.f && divider_closest_ratio_ < 1.f)
-    fix_position -= std::floor(divider_thickness / 2.f);
-  return fix_position;
-}
-
-bool SplitViewController::IsDividerAnimating() {
-  return divider_snap_animation_ && divider_snap_animation_->is_animating();
-}
-
-void SplitViewController::StopAndShoveAnimatedDivider() {
-  DCHECK(IsDividerAnimating());
-
-  divider_snap_animation_->Stop();
-  divider_position_ = divider_snap_animation_->ending_position();
-  NotifyDividerPositionChanged();
-  UpdateSnappedWindowsAndDividerBounds();
+    divider_position_ -= std::floor(divider_thickness / 2.f);
 }
 
 bool SplitViewController::ShouldEndSplitViewAfterResizing() {
@@ -1275,32 +1131,6 @@
   return divider_position_ == 0 || divider_position_ == GetDividerEndPosition();
 }
 
-void SplitViewController::EndSplitViewAfterResizingIfAppropriate() {
-  if (!ShouldEndSplitViewAfterResizing())
-    return;
-
-  aura::Window* active_window = GetActiveWindowAfterResizingUponExit();
-
-  // Track the window that needs to be put back into the overview list if we
-  // remain in overview mode.
-  aura::Window* insert_overview_window = nullptr;
-  if (Shell::Get()->overview_controller()->IsSelecting())
-    insert_overview_window = GetDefaultSnappedWindow();
-  EndSplitView();
-  if (active_window) {
-    EndOverview();
-    wm::ActivateWindow(active_window);
-  } else if (insert_overview_window) {
-    // The dimensions of |window| will be very slim because of dragging the
-    // divider to the edge. Change the window dimensions to its tablet mode
-    // dimensions. Note: if split view is no longer constrained to tablet mode
-    // this will be need to updated.
-    TabletModeWindowState::UpdateWindowPosition(
-        wm::GetWindowState(insert_overview_window), /*animate=*/false);
-    InsertWindowToOverview(insert_overview_window);
-  }
-}
-
 aura::Window* SplitViewController::GetActiveWindowAfterResizingUponExit() {
   DCHECK(IsSplitViewModeActive());
 
@@ -1328,19 +1158,21 @@
   ActivateAndStackSnappedWindow(window);
 }
 
-void SplitViewController::OnSnappedWindowDetached(aura::Window* window,
-                                                  bool window_drag) {
-  DCHECK(IsWindowInSplitView(window));
+void SplitViewController::OnSnappedWindowDetached(aura::Window* window) {
+  DCHECK(window);
+  DCHECK(window == left_window_ || window == right_window_);
   if (left_window_ == window) {
     StopObserving(LEFT);
   } else {
     StopObserving(RIGHT);
   }
 
-  // Resizing (or the divider snap animation) may continue, but |window| will no
-  // longer have anything to do with it.
-  if (is_resizing_ || IsDividerAnimating())
+  if (is_resizing_) {
+    // If the window is minimized or destroyed before the resize ends, if/when
+    // EndResize() is eventually called, it will have no way of knowing that
+    // it should finish the drag for the destroyed window. So, do it here.
     FinishWindowResizing(window);
+  }
 
   if (!left_window_ && !right_window_) {
     // If there is no snapped window at this moment, ends split view mode. Note
@@ -1352,7 +1184,7 @@
     // window, update its snap state and open overview window grid.
     default_snap_position_ = left_window_ ? LEFT : RIGHT;
     UpdateSplitViewStateAndNotifyObservers();
-    StartOverview(window_drag);
+    StartOverview();
   }
 }
 
@@ -1440,7 +1272,7 @@
 }
 
 int SplitViewController::GetWindowComponentForResize(aura::Window* window) {
-  if (IsWindowInSplitView(window)) {
+  if (window && (window == left_window_ || window == right_window_)) {
     switch (GetCurrentScreenOrientation()) {
       case OrientationLockType::kLandscapePrimary:
         return (window == left_window_) ? HTRIGHT : HTLEFT;
@@ -1461,7 +1293,7 @@
     aura::Window* window,
     const gfx::Point& location_in_screen) {
   gfx::Point end_location(location_in_screen);
-  if (!IsWindowInSplitView(window))
+  if (!window || (window != left_window_ && window != right_window_))
     return end_location;
 
   const gfx::Rect bounds = (window == left_window_)
@@ -1488,7 +1320,7 @@
 }
 
 void SplitViewController::RestoreTransformIfApplicable(aura::Window* window) {
-  DCHECK(IsWindowInSplitView(window));
+  DCHECK(window == left_window_ || window == right_window_);
 
   // If the transform of the window has been changed, calculate a good starting
   // transform based on its transformed bounds before to be snapped.
@@ -1506,8 +1338,8 @@
     const gfx::Rect snapped_bounds = GetSnappedWindowBoundsInScreen(
         window, (window == left_window_) ? LEFT : RIGHT);
     const gfx::Transform starting_transform =
-        ScopedOverviewTransformWindow::GetTransformForRect(
-            gfx::RectF(snapped_bounds), gfx::RectF(item_bounds));
+        ScopedOverviewTransformWindow::GetTransformForRect(snapped_bounds,
+                                                           item_bounds);
     SetTransformWithAnimation(window, starting_transform, gfx::Transform());
   }
 }
@@ -1594,8 +1426,7 @@
     aura::Window* window,
     const gfx::Transform& start_transform,
     const gfx::Transform& target_transform) {
-  gfx::Point target_origin =
-      gfx::ToRoundedPoint(GetTargetBoundsInScreen(window).origin());
+  gfx::Point target_origin(GetTargetBoundsInScreen(window).origin());
   for (auto* window_iter : wm::GetTransientTreeIterator(window)) {
     // Adjust |start_transform| and |target_transform| for the transient child.
     aura::Window* parent_window = window_iter->parent();
@@ -1645,7 +1476,7 @@
     aura::Window* window) {
   if (!window->layer()->GetTargetTransform().IsIdentity()) {
     snapping_window_transformed_bounds_map_[window] =
-        gfx::ToEnclosedRect(GetTransformedBounds(window, /*top_inset=*/0));
+        GetTransformedBounds(window, /*top_inset=*/0);
   }
 }
 
@@ -1655,12 +1486,9 @@
   GetOverviewSession()->AddItem(window, /*reposition=*/true, /*animate=*/true);
 }
 
-void SplitViewController::StartOverview(bool window_drag) {
-  if (!Shell::Get()->overview_controller()->IsSelecting()) {
-    Shell::Get()->overview_controller()->ToggleOverview(
-        window_drag ? OverviewSession::EnterExitOverviewType::kWindowDragged
-                    : OverviewSession::EnterExitOverviewType::kNormal);
-  }
+void SplitViewController::StartOverview() {
+  if (!Shell::Get()->overview_controller()->IsSelecting())
+    Shell::Get()->overview_controller()->ToggleOverview();
 }
 
 void SplitViewController::EndOverview() {
@@ -1677,16 +1505,6 @@
   }
 }
 
-void SplitViewController::EndResizeImpl() {
-  DCHECK(IsSplitViewModeActive());
-  DCHECK(!is_resizing_);
-  // Resize may not end with |EndResize()|, so make sure to clear here too.
-  presentation_time_recorder_.reset();
-  RestoreWindowsTransformAfterResizing();
-  FinishWindowResizing(left_window_);
-  FinishWindowResizing(right_window_);
-}
-
 void SplitViewController::EndWindowDragImpl(
     aura::Window* window,
     bool is_being_destroyed,
--- a/ash/wm/splitview/split_view_controller.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/splitview/split_view_controller.h	2019-05-17 18:53:08.376000000 +0300
@@ -5,15 +5,12 @@
 #ifndef ASH_WM_SPLITSVIEW_SPLIT_VIEW_CONTROLLER_H_
 #define ASH_WM_SPLITSVIEW_SPLIT_VIEW_CONTROLLER_H_
 
-#include <memory>
-
 #include "ash/accessibility/accessibility_observer.h"
 #include "ash/ash_export.h"
 #include "ash/display/screen_orientation_controller.h"
 #include "ash/public/interfaces/split_view.mojom.h"
 #include "ash/session/session_observer.h"
 #include "ash/shell_observer.h"
-#include "ash/wm/overview/overview_observer.h"
 #include "ash/wm/tablet_mode/tablet_mode_controller.h"
 #include "ash/wm/tablet_mode/tablet_mode_observer.h"
 #include "ash/wm/window_state_observer.h"
@@ -35,7 +32,6 @@
 }  // namespace ui
 
 namespace ash {
-class PresentationTimeRecorder;
 class OverviewSession;
 class SplitViewControllerTest;
 class SplitViewDivider;
@@ -50,7 +46,6 @@
                                        public ash::wm::WindowStateObserver,
                                        public ::wm::ActivationChangeObserver,
                                        public ShellObserver,
-                                       public OverviewObserver,
                                        public display::DisplayObserver,
                                        public TabletModeObserver,
                                        public AccessibilityObserver,
@@ -140,9 +135,6 @@
   // Ends the split view mode.
   void EndSplitView(EndReason end_reason = EndReason::kNormal);
 
-  // Returns true if |window| is a snapped window in splitview.
-  bool IsWindowInSplitView(const aura::Window* window) const;
-
   // Called when a window (either it's browser window or an app window) start/
   // end being dragged.
   void OnWindowDragStarted(aura::Window* dragged_window);
@@ -176,8 +168,6 @@
 
   // ShellObserver:
   void OnPinnedStateChanged(aura::Window* pinned_window) override;
-
-  // OverviewObserver:
   void OnOverviewModeStarting() override;
   void OnOverviewModeEnding(OverviewSession* overview_session) override;
 
@@ -209,7 +199,6 @@
   friend class SplitViewControllerTest;
   friend class SplitViewOverviewSessionTest;
   class TabDraggedWindowObserver;
-  class DividerSnapAnimation;
 
   // Start observing |window|.
   void StartObserving(aura::Window* window);
@@ -255,23 +244,14 @@
                  gfx::Rect* left_or_top_rect,
                  gfx::Rect* right_or_bottom_rect);
 
-  // Returns the closest fix location for |divider_position_|.
-  int GetClosestFixedDividerPosition();
-
-  // Returns true during the divider snap animation.
-  bool IsDividerAnimating();
-
-  // While the divider is animating to somewhere, stop it and shove it there.
-  void StopAndShoveAnimatedDivider();
+  // Finds the closest fix location for |divider_position_| and updates its
+  // value.
+  void MoveDividerToClosestFixedPosition();
 
   // Returns true if we should end split view mode after resizing, i.e., the
   // split view divider is near to the edge of the screen.
   bool ShouldEndSplitViewAfterResizing();
 
-  // Ends split view if ShouldEndSplitViewAfterResizing() returns true. Handles
-  // extra details associated with dragging the divider off the screen.
-  void EndSplitViewAfterResizingIfAppropriate();
-
   // After resizing, if we should end split view mode, returns the window that
   // needs to be activated. Returns nullptr if there is no such window.
   aura::Window* GetActiveWindowAfterResizingUponExit();
@@ -291,9 +271,8 @@
   // window side of the screen. If there is only one snapped windows, closing/
   // minimizing/tab-dragging the sanpped window will end split view mode and
   // adjust the overview window grid bounds if the overview mode is active at
-  // that moment. |window_drag| is true if the window was detached as a result
-  // of dragging.
-  void OnSnappedWindowDetached(aura::Window* window, bool window_drag);
+  // that moment.
+  void OnSnappedWindowDetached(aura::Window* window);
 
   // If the desired bounds of the snapped windows bounds |left_or_top_rect| and
   // |right_or_bottom_rect| are smaller than the minimum bounds of the snapped
@@ -359,17 +338,13 @@
   void InsertWindowToOverview(aura::Window* window);
 
   // Starts/Ends overview mode if the overview mode is inactive/active.
-  void StartOverview(bool window_drag = false);
+  void StartOverview();
   void EndOverview();
 
   // Finalizes and cleans up after stopping dragging the divider bar to resize
   // snapped windows.
   void FinishWindowResizing(aura::Window* window);
 
-  // Finalizes and cleans up divider dragging/animating. Called when the divider
-  // snapping animation completes or is interrupted or totally skipped.
-  void EndResizeImpl();
-
   // Called by OnWindowDragEnded to do the actual work of finishing the window
   // dragging. If |is_being_destroyed| equals true, the dragged window is to be
   // destroyed, and SplitViewController should not try to put it in splitview.
@@ -425,9 +400,6 @@
   // The location of the previous mouse/gesture event in screen coordinates.
   gfx::Point previous_event_location_;
 
-  // The animation that animates the divider to a fixed position after resizing.
-  std::unique_ptr<DividerSnapAnimation> divider_snap_animation_;
-
   // Current snap state.
   State state_ = NO_SNAP;
 
@@ -440,7 +412,7 @@
   // The previous orientation of the screen.
   OrientationLockType previous_screen_orientation_ = OrientationLockType::kAny;
 
-  // True when the divider is being dragged (not during its snap animation).
+  // If the divider is currently being dragging.
   bool is_resizing_ = false;
 
   // Stores the reason which cause splitview to end.
@@ -458,9 +430,6 @@
   ScopedObserver<TabletModeController, TabletModeObserver>
       tablet_mode_observer_{this};
 
-  // Records the presentation time of resize operation in split view mode.
-  std::unique_ptr<PresentationTimeRecorder> presentation_time_recorder_;
-
   DISALLOW_COPY_AND_ASSIGN(SplitViewController);
 };
 
--- a/ash/wm/splitview/split_view_controller_unittest.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/splitview/split_view_controller_unittest.cc	2019-05-17 18:53:08.376000000 +0300
@@ -9,10 +9,7 @@
 #include "ash/display/screen_orientation_controller_test_api.h"
 #include "ash/magnifier/docked_magnifier_controller.h"
 #include "ash/public/cpp/app_types.h"
-#include "ash/public/cpp/fps_counter.h"
-#include "ash/public/cpp/presentation_time_recorder.h"
 #include "ash/public/cpp/window_properties.h"
-#include "ash/root_window_controller.h"
 #include "ash/screen_util.h"
 #include "ash/session/session_controller.h"
 #include "ash/session/test_session_controller_client.h"
@@ -28,13 +25,12 @@
 #include "ash/wm/overview/overview_controller.h"
 #include "ash/wm/overview/overview_grid.h"
 #include "ash/wm/overview/overview_item.h"
-#include "ash/wm/overview/overview_observer.h"
 #include "ash/wm/splitview/split_view_divider.h"
 #include "ash/wm/splitview/split_view_drag_indicators.h"
 #include "ash/wm/splitview/split_view_utils.h"
-#include "ash/wm/tablet_mode/tablet_mode_browser_window_drag_delegate.h"
+#include "ash/wm/tablet_mode/tablet_mode_app_window_drag_controller.h"
+#include "ash/wm/tablet_mode/tablet_mode_browser_window_drag_controller.h"
 #include "ash/wm/tablet_mode/tablet_mode_controller.h"
-#include "ash/wm/tablet_mode/tablet_mode_window_drag_controller.h"
 #include "ash/wm/tablet_mode/tablet_mode_window_drag_delegate.h"
 #include "ash/wm/window_resizer.h"
 #include "ash/wm/window_state.h"
@@ -42,7 +38,6 @@
 #include "ash/wm/window_util.h"
 #include "ash/wm/wm_event.h"
 #include "base/stl_util.h"
-#include "base/test/metrics/histogram_tester.h"
 #include "services/ws/public/mojom/window_tree_constants.mojom.h"
 #include "ui/aura/client/aura_constants.h"
 #include "ui/aura/test/test_window_delegate.h"
@@ -62,17 +57,17 @@
 namespace {
 
 // The observer to observe the overview states in |root_window_|.
-class OverviewStatesObserver : public OverviewObserver {
+class OverviewStatesObserver : public ShellObserver {
  public:
   OverviewStatesObserver(aura::Window* root_window)
       : root_window_(root_window) {
-    Shell::Get()->overview_controller()->AddObserver(this);
+    Shell::Get()->AddShellObserver(this);
   }
   ~OverviewStatesObserver() override {
-    Shell::Get()->overview_controller()->RemoveObserver(this);
+    Shell::Get()->RemoveShellObserver(this);
   }
 
-  // OverviewObserver:
+  // ShellObserver:
   void OnOverviewModeStarting() override {
     // Reset the value to true.
     overview_animate_when_exiting_ = true;
@@ -126,16 +121,6 @@
     // mode.
     base::RunLoop().RunUntilIdle();
     Shell::Get()->tablet_mode_controller()->EnableTabletModeWindowManager(true);
-    FpsCounter::SetFoceReportZeroAnimationForTest(true);
-    ash::PresentationTimeRecorder::SetReportPresentationTimeImmediatelyForTest(
-        true);
-  }
-  void TearDown() override {
-    ash::PresentationTimeRecorder::SetReportPresentationTimeImmediatelyForTest(
-        false);
-    FpsCounter::SetFoceReportZeroAnimationForTest(false);
-    trace_names_.clear();
-    AshTestBase::TearDown();
   }
 
   aura::Window* CreateWindow(
@@ -153,18 +138,6 @@
     return window;
   }
 
-  bool IsDividerAnimating() {
-    return split_view_controller()->IsDividerAnimating();
-  }
-
-  void SkipDividerSnapAnimation() {
-    if (!IsDividerAnimating())
-      return;
-    split_view_controller()->StopAndShoveAnimatedDivider();
-    split_view_controller()->EndResizeImpl();
-    split_view_controller()->EndSplitViewAfterResizingIfAppropriate();
-  }
-
   void EndSplitView() { split_view_controller()->EndSplitView(); }
 
   void ToggleOverview() {
@@ -182,7 +155,7 @@
   std::vector<aura::Window*> GetWindowsInOverviewGrids() {
     return Shell::Get()
         ->overview_controller()
-        ->GetWindowsListInOverviewGridsForTest();
+        ->GetWindowsListInOverviewGridsForTesting();
   }
 
   SplitViewController* split_view_controller() {
@@ -210,40 +183,7 @@
     void OnWindowDestroyed(aura::Window* window) override { delete this; }
   };
 
-  void CheckOverviewEnterExitHistogram(const char* trace,
-                                       std::vector<int>&& enter_counts,
-                                       std::vector<int>&& exit_counts) {
-    DCHECK(!base::ContainsValue(trace_names_, trace)) << trace;
-    trace_names_.push_back(trace);
-    {
-      SCOPED_TRACE(trace + std::string(".Enter"));
-      CheckOverviewHistogram("Ash.Overview.AnimationSmoothness.Enter",
-                             std::move(enter_counts));
-    }
-    {
-      SCOPED_TRACE(trace + std::string(".Exit"));
-      CheckOverviewHistogram("Ash.Overview.AnimationSmoothness.Exit",
-                             std::move(exit_counts));
-    }
-  }
-
-  const base::HistogramTester& histograms() const { return histograms_; }
-
  private:
-  void CheckOverviewHistogram(const char* histogram, std::vector<int> counts) {
-    // These two events should never happen in this test.
-    histograms_.ExpectTotalCount(histogram + std::string(".ClamshellMode"), 0);
-    histograms_.ExpectTotalCount(
-        histogram + std::string(".SingleClamshellMode"), 0);
-
-    histograms_.ExpectTotalCount(histogram + std::string(".TabletMode"),
-                                 counts[0]);
-    histograms_.ExpectTotalCount(histogram + std::string(".SplitView"),
-                                 counts[1]);
-  }
-  std::vector<std::string> trace_names_;
-  base::HistogramTester histograms_;
-
   DISALLOW_COPY_AND_ASSIGN(SplitViewControllerTest);
 };
 
@@ -550,8 +490,6 @@
   EXPECT_EQ(split_view_controller()->IsSplitViewModeActive(), false);
 
   ToggleOverview();
-  CheckOverviewEnterExitHistogram("EnterInTablet", {1, 0}, {0, 0});
-
   split_view_controller()->SnapWindow(window1.get(), SplitViewController::LEFT);
   EXPECT_EQ(split_view_controller()->IsSplitViewModeActive(), true);
   EXPECT_EQ(split_view_controller()->state(),
@@ -562,7 +500,6 @@
   EXPECT_EQ(split_view_controller()->state(),
             SplitViewController::BOTH_SNAPPED);
   EXPECT_EQ(split_view_controller()->right_window(), window3.get());
-  CheckOverviewEnterExitHistogram("ExitInSplitView", {1, 0}, {0, 1});
 }
 
 // Tests that if split view mode is active when entering overview, the overview
@@ -582,15 +519,11 @@
   EXPECT_EQ(split_view_controller()->GetDefaultSnappedWindow(), window1.get());
 
   ToggleOverview();
-  CheckOverviewEnterExitHistogram("EnterInSplitView", {0, 1}, {0, 0});
   EXPECT_EQ(split_view_controller()->state(),
             SplitViewController::LEFT_SNAPPED);
   EXPECT_FALSE(
       base::ContainsValue(GetWindowsInOverviewGrids(),
                           split_view_controller()->GetDefaultSnappedWindow()));
-
-  ToggleOverview();
-  CheckOverviewEnterExitHistogram("ExitInSplitView", {0, 1}, {0, 1});
 }
 
 // Tests that the split divider was created when the split view mode is active
@@ -645,7 +578,6 @@
   GetEventGenerator()->set_current_screen_location(
       divider_bounds.CenterPoint());
   GetEventGenerator()->DragMouseTo(screen_width * 0.67f, 0);
-  SkipDividerSnapAnimation();
   window1_width = window1->GetBoundsInScreen().width();
   window2_width = window2->GetBoundsInScreen().width();
   const int old_window1_width = window1_width;
@@ -662,7 +594,6 @@
   GetEventGenerator()->set_current_screen_location(
       divider_bounds.CenterPoint());
   GetEventGenerator()->DragMouseTo(screen_width * 0.7f, 0);
-  SkipDividerSnapAnimation();
   window1_width = window1->GetBoundsInScreen().width();
   window2_width = window2->GetBoundsInScreen().width();
   EXPECT_EQ(window1_width, old_window1_width);
@@ -675,7 +606,6 @@
   GetEventGenerator()->set_current_screen_location(
       divider_bounds.CenterPoint());
   GetEventGenerator()->DragMouseTo(screen_width * 0.33f, 0);
-  SkipDividerSnapAnimation();
   window1_width = window1->GetBoundsInScreen().width();
   window2_width = window2->GetBoundsInScreen().width();
   EXPECT_GT(window2_width, 2 * window1_width);
@@ -734,178 +664,8 @@
             new_bounds_divider.x() + new_bounds_divider.width());
 }
 
-// Tests that the bounds of the snapped windows and divider are adjusted when
-// the internal screen display configuration changes.
-TEST_F(SplitViewControllerTest, InternalDisplayConfigurationChangeTest) {
-  UpdateDisplay("407x400");
-  int64_t display_id = display::Screen::GetScreen()->GetPrimaryDisplay().id();
-  display::DisplayManager* display_manager = Shell::Get()->display_manager();
-  display::test::ScopedSetInternalDisplayId set_internal(display_manager,
-                                                         display_id);
-
-  const gfx::Rect bounds(0, 0, 200, 200);
-  std::unique_ptr<aura::Window> window1(CreateWindow(bounds));
-  std::unique_ptr<aura::Window> window2(CreateWindow(bounds));
-
-  split_view_controller()->SnapWindow(window1.get(), SplitViewController::LEFT);
-  split_view_controller()->SnapWindow(window2.get(),
-                                      SplitViewController::RIGHT);
-
-  const gfx::Rect bounds_window1 = window1->GetBoundsInScreen();
-  const gfx::Rect bounds_window2 = window2->GetBoundsInScreen();
-  const gfx::Rect bounds_divider =
-      split_view_divider()->GetDividerBoundsInScreen(false /* is_dragging */);
-
-  // Test that |window1| and |window2| has the same width and height after snap.
-  EXPECT_NEAR(bounds_window1.width(), bounds_window2.width(), 1);
-  EXPECT_EQ(bounds_window1.height(), bounds_window2.height());
-  EXPECT_EQ(bounds_divider.height(), bounds_window1.height());
-
-  // Test that |window1|, divider, |window2| are aligned properly.
-  EXPECT_EQ(bounds_divider.x(), bounds_window1.x() + bounds_window1.width());
-  EXPECT_EQ(bounds_window2.x(), bounds_divider.x() + bounds_divider.width());
-
-  // Now change the display configuration.
-  UpdateDisplay("507x500");
-  const gfx::Rect new_bounds_window1 = window1->GetBoundsInScreen();
-  const gfx::Rect new_bounds_window2 = window2->GetBoundsInScreen();
-  const gfx::Rect new_bounds_divider =
-      split_view_divider()->GetDividerBoundsInScreen(false /* is_dragging */);
-
-  // Test that the new bounds are different with the old ones.
-  EXPECT_NE(bounds_window1, new_bounds_window1);
-  EXPECT_NE(bounds_window2, new_bounds_window2);
-  EXPECT_NE(bounds_divider, new_bounds_divider);
-
-  // Test that |window1|, divider, |window2| are still aligned properly.
-  EXPECT_EQ(new_bounds_divider.x(),
-            new_bounds_window1.x() + new_bounds_window1.width());
-  EXPECT_EQ(new_bounds_window2.x(),
-            new_bounds_divider.x() + new_bounds_divider.width());
-}
-
-// Test that if the internal screen display configuration changes during the
-// divider snap animation, then this animation stops, and the bounds of the
-// snapped windows and divider are adjusted as normal.
-TEST_F(SplitViewControllerTest,
-       InternalDisplayConfigurationChangeDuringDividerSnap) {
-  UpdateDisplay("407x400");
-  int64_t display_id = display::Screen::GetScreen()->GetPrimaryDisplay().id();
-  display::DisplayManager* display_manager = Shell::Get()->display_manager();
-  display::test::ScopedSetInternalDisplayId set_internal(display_manager,
-                                                         display_id);
-
-  const gfx::Rect bounds(0, 0, 200, 200);
-  std::unique_ptr<aura::Window> window1(CreateWindow(bounds));
-  std::unique_ptr<aura::Window> window2(CreateWindow(bounds));
-
-  split_view_controller()->SnapWindow(window1.get(), SplitViewController::LEFT);
-  split_view_controller()->SnapWindow(window2.get(),
-                                      SplitViewController::RIGHT);
-
-  const gfx::Rect bounds_window1 = window1->GetBoundsInScreen();
-  const gfx::Rect bounds_window2 = window2->GetBoundsInScreen();
-  const gfx::Rect bounds_divider =
-      split_view_divider()->GetDividerBoundsInScreen(false /* is_dragging */);
-
-  // Test that |window1| and |window2| has the same width and height after snap.
-  EXPECT_NEAR(bounds_window1.width(), bounds_window2.width(), 1);
-  EXPECT_EQ(bounds_window1.height(), bounds_window2.height());
-  EXPECT_EQ(bounds_divider.height(), bounds_window1.height());
-
-  // Test that |window1|, divider, |window2| are aligned properly.
-  EXPECT_EQ(bounds_divider.x(), bounds_window1.x() + bounds_window1.width());
-  EXPECT_EQ(bounds_window2.x(), bounds_divider.x() + bounds_divider.width());
-
-  // Drag the divider to trigger the snap animation.
-  const gfx::Point divider_center =
-      split_view_divider()
-          ->GetDividerBoundsInScreen(false /* is_dragging */)
-          .CenterPoint();
-  GetEventGenerator()->set_current_screen_location(divider_center);
-  GetEventGenerator()->DragMouseBy(20, 0);
-  ASSERT_TRUE(IsDividerAnimating());
-  const gfx::Rect animation_start_bounds_window1 = window1->GetBoundsInScreen();
-  const gfx::Rect animation_start_bounds_window2 = window2->GetBoundsInScreen();
-  const gfx::Rect animation_start_bounds_divider =
-      split_view_divider()->GetDividerBoundsInScreen(false /* is_dragging */);
-
-  // Change the display configuration and check that the snap animation stops.
-  UpdateDisplay("507x500");
-  EXPECT_FALSE(IsDividerAnimating());
-  const gfx::Rect new_bounds_window1 = window1->GetBoundsInScreen();
-  const gfx::Rect new_bounds_window2 = window2->GetBoundsInScreen();
-  const gfx::Rect new_bounds_divider =
-      split_view_divider()->GetDividerBoundsInScreen(false /* is_dragging */);
-
-  // Test that the new bounds are different with the old ones.
-  EXPECT_NE(bounds_window1, new_bounds_window1);
-  EXPECT_NE(bounds_window2, new_bounds_window2);
-  EXPECT_NE(bounds_divider, new_bounds_divider);
-
-  // Test that the new bounds are also different with the ones from the start of
-  // the divider snap animation.
-  EXPECT_NE(bounds_window1, animation_start_bounds_window1);
-  EXPECT_NE(bounds_window2, animation_start_bounds_window2);
-  EXPECT_NE(bounds_divider, animation_start_bounds_divider);
-
-  // Test that |window1|, divider, |window2| are still aligned properly.
-  EXPECT_EQ(new_bounds_divider.x(),
-            new_bounds_window1.x() + new_bounds_window1.width());
-  EXPECT_EQ(new_bounds_window2.x(),
-            new_bounds_divider.x() + new_bounds_divider.width());
-}
-
-// Test that if the internal screen display configuration changes during the
-// divider snap animation, and if the adjusted divider bounds place it at an
-// edge of the screen, then split view ends.
-TEST_F(SplitViewControllerTest,
-       InternalDisplayConfigurationChangeDuringDividerSnapToEndSplitView) {
-  UpdateDisplay("407x400");
-  int64_t display_id = display::Screen::GetScreen()->GetPrimaryDisplay().id();
-  display::DisplayManager* display_manager = Shell::Get()->display_manager();
-  display::test::ScopedSetInternalDisplayId set_internal(display_manager,
-                                                         display_id);
-
-  const gfx::Rect bounds(0, 0, 200, 200);
-  std::unique_ptr<aura::Window> window1(CreateWindow(bounds));
-  std::unique_ptr<aura::Window> window2(CreateWindow(bounds));
-
-  split_view_controller()->SnapWindow(window1.get(), SplitViewController::LEFT);
-  split_view_controller()->SnapWindow(window2.get(),
-                                      SplitViewController::RIGHT);
-
-  const gfx::Rect bounds_window1 = window1->GetBoundsInScreen();
-  const gfx::Rect bounds_window2 = window2->GetBoundsInScreen();
-  const gfx::Rect bounds_divider =
-      split_view_divider()->GetDividerBoundsInScreen(false /* is_dragging */);
-
-  // Test that |window1| and |window2| has the same width and height after snap.
-  EXPECT_NEAR(bounds_window1.width(), bounds_window2.width(), 1);
-  EXPECT_EQ(bounds_window1.height(), bounds_window2.height());
-  EXPECT_EQ(bounds_divider.height(), bounds_window1.height());
-
-  // Test that |window1|, divider, |window2| are aligned properly.
-  EXPECT_EQ(bounds_divider.x(), bounds_window1.x() + bounds_window1.width());
-  EXPECT_EQ(bounds_window2.x(), bounds_divider.x() + bounds_divider.width());
-
-  // Drag the divider to end split view pending the snap animation.
-  const gfx::Point divider_center =
-      split_view_divider()
-          ->GetDividerBoundsInScreen(false /* is_dragging */)
-          .CenterPoint();
-  GetEventGenerator()->set_current_screen_location(divider_center);
-  GetEventGenerator()->DragMouseBy(bounds_window2.width() - 20, 0);
-  ASSERT_TRUE(split_view_controller()->IsSplitViewModeActive());
-  ASSERT_TRUE(IsDividerAnimating());
-
-  // Change the display configuration and check that split view ends.
-  UpdateDisplay("507x500");
-  EXPECT_FALSE(split_view_controller()->IsSplitViewModeActive());
-}
-
 // Verify the left and right windows get swapped when SwapWindows is called or
-// the divider is double clicked.
+// the divider is double tapped.
 TEST_F(SplitViewControllerTest, SwapWindows) {
   const gfx::Rect bounds(0, 0, 400, 400);
   std::unique_ptr<aura::Window> window1(CreateWindow(bounds));
@@ -914,8 +674,8 @@
   split_view_controller()->SnapWindow(window1.get(), SplitViewController::LEFT);
   split_view_controller()->SnapWindow(window2.get(),
                                       SplitViewController::RIGHT);
-  ASSERT_EQ(split_view_controller()->left_window(), window1.get());
-  ASSERT_EQ(split_view_controller()->right_window(), window2.get());
+  EXPECT_EQ(split_view_controller()->left_window(), window1.get());
+  EXPECT_EQ(split_view_controller()->right_window(), window2.get());
 
   gfx::Rect left_bounds = window1->GetBoundsInScreen();
   gfx::Rect right_bounds = window2->GetBoundsInScreen();
@@ -934,8 +694,8 @@
   split_view_controller()->SnapWindow(window1.get(),
                                       SplitViewController::RIGHT);
   split_view_controller()->SnapWindow(window2.get(), SplitViewController::LEFT);
-  ASSERT_EQ(split_view_controller()->right_window(), window1.get());
-  ASSERT_EQ(split_view_controller()->left_window(), window2.get());
+  EXPECT_EQ(split_view_controller()->right_window(), window1.get());
+  EXPECT_EQ(split_view_controller()->left_window(), window2.get());
 
   left_bounds = window2->GetBoundsInScreen();
   right_bounds = window1->GetBoundsInScreen();
@@ -946,7 +706,7 @@
   EXPECT_EQ(left_bounds, window1->GetBoundsInScreen());
   EXPECT_EQ(right_bounds, window2->GetBoundsInScreen());
 
-  // Perform a double click on the divider center.
+  // Perform a double tap on the divider center.
   const gfx::Point divider_center =
       split_view_divider()
           ->GetDividerBoundsInScreen(false /* is_dragging */)
@@ -960,146 +720,6 @@
   EXPECT_EQ(right_bounds, window1->GetBoundsInScreen());
 }
 
-// Verify the left and right windows get swapped when the divider is double
-// tapped. SwapWindows() contains a long code comment that shows it is worth
-// having separate tests for double clicking and double tapping the divider.
-TEST_F(SplitViewControllerTest, DoubleTapDivider) {
-  const gfx::Rect bounds(0, 0, 400, 400);
-  std::unique_ptr<aura::Window> window1(CreateWindow(bounds));
-  std::unique_ptr<aura::Window> window2(CreateWindow(bounds));
-
-  split_view_controller()->SnapWindow(window1.get(), SplitViewController::LEFT);
-  split_view_controller()->SnapWindow(window2.get(),
-                                      SplitViewController::RIGHT);
-  ASSERT_EQ(split_view_controller()->left_window(), window1.get());
-  ASSERT_EQ(split_view_controller()->right_window(), window2.get());
-
-  gfx::Rect left_bounds = window1->GetBoundsInScreen();
-  gfx::Rect right_bounds = window2->GetBoundsInScreen();
-
-  // Perform a double tap on the divider center.
-  const gfx::Point divider_center =
-      split_view_divider()
-          ->GetDividerBoundsInScreen(false /* is_dragging */)
-          .CenterPoint();
-  GetEventGenerator()->GestureTapAt(divider_center);
-  GetEventGenerator()->GestureTapAt(divider_center);
-
-  EXPECT_EQ(split_view_controller()->left_window(), window2.get());
-  EXPECT_EQ(split_view_controller()->right_window(), window1.get());
-  EXPECT_EQ(left_bounds, window2->GetBoundsInScreen());
-  EXPECT_EQ(right_bounds, window1->GetBoundsInScreen());
-}
-
-// Verify the left and right windows do not get swapped when the divider is
-// dragged and double clicked.
-TEST_F(SplitViewControllerTest, DragAndDoubleClickDivider) {
-  const gfx::Rect bounds(0, 0, 400, 400);
-  std::unique_ptr<aura::Window> window1(CreateWindow(bounds));
-  std::unique_ptr<aura::Window> window2(CreateWindow(bounds));
-
-  split_view_controller()->SnapWindow(window1.get(), SplitViewController::LEFT);
-  split_view_controller()->SnapWindow(window2.get(),
-                                      SplitViewController::RIGHT);
-  ASSERT_EQ(split_view_controller()->left_window(), window1.get());
-  ASSERT_EQ(split_view_controller()->right_window(), window2.get());
-
-  // Drag the divider and double click it before the snap animation moves it.
-  const gfx::Point divider_center =
-      split_view_divider()
-          ->GetDividerBoundsInScreen(false /* is_dragging */)
-          .CenterPoint();
-  GetEventGenerator()->set_current_screen_location(divider_center);
-  GetEventGenerator()->DragMouseBy(20, 0);
-  GetEventGenerator()->DoubleClickLeftButton();
-
-  EXPECT_EQ(split_view_controller()->left_window(), window1.get());
-  EXPECT_EQ(split_view_controller()->right_window(), window2.get());
-}
-
-// Verify the left and right windows do not get swapped when the divider is
-// dragged and double tapped.
-TEST_F(SplitViewControllerTest, DragAndDoubleTapDivider) {
-  const gfx::Rect bounds(0, 0, 400, 400);
-  std::unique_ptr<aura::Window> window1(CreateWindow(bounds));
-  std::unique_ptr<aura::Window> window2(CreateWindow(bounds));
-
-  split_view_controller()->SnapWindow(window1.get(), SplitViewController::LEFT);
-  split_view_controller()->SnapWindow(window2.get(),
-                                      SplitViewController::RIGHT);
-  ASSERT_EQ(split_view_controller()->left_window(), window1.get());
-  ASSERT_EQ(split_view_controller()->right_window(), window2.get());
-
-  // Drag the divider and double tap it before the snap animation moves it.
-  const gfx::Point divider_center =
-      split_view_divider()
-          ->GetDividerBoundsInScreen(false /* is_dragging */)
-          .CenterPoint();
-  GetEventGenerator()->set_current_screen_location(divider_center);
-  const gfx::Point drag_destination = divider_center + gfx::Vector2d(20, 0);
-  GetEventGenerator()->DragMouseTo(drag_destination);
-  GetEventGenerator()->GestureTapAt(drag_destination);
-  GetEventGenerator()->GestureTapAt(drag_destination);
-
-  EXPECT_EQ(split_view_controller()->left_window(), window1.get());
-  EXPECT_EQ(split_view_controller()->right_window(), window2.get());
-}
-
-// Verify that you cannot snap a window during the divider snap animation.
-TEST_F(SplitViewControllerTest, SnapWindowDuringDividerSnapAnimation) {
-  const gfx::Rect bounds(0, 0, 400, 400);
-  std::unique_ptr<aura::Window> window1(CreateWindow(bounds));
-  std::unique_ptr<aura::Window> window2(CreateWindow(bounds));
-  std::unique_ptr<aura::Window> window3(CreateWindow(bounds));
-  std::unique_ptr<aura::Window> window4(CreateWindow(bounds));
-
-  split_view_controller()->SnapWindow(window1.get(), SplitViewController::LEFT);
-  split_view_controller()->SnapWindow(window2.get(),
-                                      SplitViewController::RIGHT);
-  ASSERT_EQ(split_view_controller()->left_window(), window1.get());
-  ASSERT_EQ(split_view_controller()->right_window(), window2.get());
-
-  // Drag the divider to trigger the snap animation.
-  const gfx::Point divider_center =
-      split_view_divider()
-          ->GetDividerBoundsInScreen(false /* is_dragging */)
-          .CenterPoint();
-  GetEventGenerator()->set_current_screen_location(divider_center);
-  GetEventGenerator()->DragMouseBy(20, 0);
-  ASSERT_TRUE(IsDividerAnimating());
-
-  split_view_controller()->SnapWindow(window3.get(), SplitViewController::LEFT);
-  split_view_controller()->SnapWindow(window4.get(),
-                                      SplitViewController::RIGHT);
-  EXPECT_EQ(split_view_controller()->left_window(), window1.get());
-  EXPECT_EQ(split_view_controller()->right_window(), window2.get());
-}
-
-// Verify that you cannot start dragging the divider during its snap animation.
-TEST_F(SplitViewControllerTest, StartDraggingDividerDuringSnapAnimation) {
-  const gfx::Rect bounds(0, 0, 400, 400);
-  std::unique_ptr<aura::Window> window1(CreateWindow(bounds));
-  std::unique_ptr<aura::Window> window2(CreateWindow(bounds));
-
-  split_view_controller()->SnapWindow(window1.get(), SplitViewController::LEFT);
-  split_view_controller()->SnapWindow(window2.get(),
-                                      SplitViewController::RIGHT);
-  ASSERT_EQ(split_view_controller()->left_window(), window1.get());
-  ASSERT_EQ(split_view_controller()->right_window(), window2.get());
-
-  // Drag the divider and then try to start dragging it again without waiting
-  // for the snap animation.
-  const gfx::Point divider_center =
-      split_view_divider()
-          ->GetDividerBoundsInScreen(false /* is_dragging */)
-          .CenterPoint();
-  GetEventGenerator()->set_current_screen_location(divider_center);
-  GetEventGenerator()->DragMouseBy(20, 0);
-  GetEventGenerator()->PressLeftButton();
-  EXPECT_FALSE(split_view_controller()->is_resizing());
-  GetEventGenerator()->ReleaseLeftButton();
-}
-
 // Verifies that by long pressing on the overview button tray, split view gets
 // activated iff we have two or more windows in the mru list.
 TEST_F(SplitViewControllerTest, LongPressEntersSplitView) {
@@ -1257,7 +877,6 @@
   ToggleOverview();
   ASSERT_TRUE(Shell::Get()->overview_controller()->IsSelecting());
   ASSERT_FALSE(split_view_controller()->IsSplitViewModeActive());
-  CheckOverviewEnterExitHistogram("EnterInTablet", {1, 0}, {0, 0});
 
   // Nothing happens if there is only one window.
   LongPressOnOverivewButtonTray();
@@ -1267,18 +886,13 @@
   // enter splitview.
   std::unique_ptr<aura::Window> window2(CreateWindow(bounds));
   wm::ActivateWindow(window2.get());
-  CheckOverviewEnterExitHistogram("ExitByActivation", {1, 0}, {1, 0});
-
   ToggleOverview();
-  CheckOverviewEnterExitHistogram("EnterInTablet2", {2, 0}, {1, 0});
   ASSERT_TRUE(Shell::Get()->overview_controller()->IsSelecting());
   ASSERT_FALSE(split_view_controller()->IsSplitViewModeActive());
 
   LongPressOnOverivewButtonTray();
   EXPECT_TRUE(split_view_controller()->IsSplitViewModeActive());
   EXPECT_EQ(window2.get(), split_view_controller()->left_window());
-  // This scenario should not trigger animation.
-  CheckOverviewEnterExitHistogram("NoTransition", {2, 0}, {1, 0});
 }
 
 TEST_F(SplitViewControllerTest, LongPressWithUnsnappableWindow) {
@@ -1485,11 +1099,6 @@
   split_view_controller()->StartResize(divider_bounds.CenterPoint());
   gfx::Point resize_point(display_bounds.width() * 0.33f, 0);
   split_view_controller()->Resize(resize_point);
-  histograms().ExpectTotalCount(
-      "Ash.SplitViewResize.PresentationTime.TabletMode.SingleWindow", 1);
-  histograms().ExpectTotalCount(
-      "Ash.SplitViewResize.PresentationTime.MaxLatency.TabletMode.SingleWindow",
-      0);
 
   gfx::Rect snapped_window_bounds =
       split_view_controller()->GetSnappedWindowBoundsInScreen(
@@ -1500,13 +1109,6 @@
             window1->delegate()->GetMinimumSize().width());
   EXPECT_FALSE(window1->layer()->GetTargetTransform().IsIdentity());
   split_view_controller()->EndResize(resize_point);
-  histograms().ExpectTotalCount(
-      "Ash.SplitViewResize.PresentationTime.TabletMode.SingleWindow", 1);
-  histograms().ExpectTotalCount(
-      "Ash.SplitViewResize.PresentationTime.MaxLatency.TabletMode.SingleWindow",
-      1);
-
-  SkipDividerSnapAnimation();
   EndSplitView();
 
   // Rotate the screen by 270 degree.
@@ -1536,7 +1138,6 @@
             window1->delegate()->GetMinimumSize().height());
   EXPECT_FALSE(window1->layer()->GetTargetTransform().IsIdentity());
   split_view_controller()->EndResize(resize_point);
-  SkipDividerSnapAnimation();
   EndSplitView();
 
   // Rotate the screen by 180 degree.
@@ -1568,7 +1169,6 @@
             window1->delegate()->GetMinimumSize().width());
   EXPECT_FALSE(window1->layer()->GetTargetTransform().IsIdentity());
   split_view_controller()->EndResize(resize_point);
-  SkipDividerSnapAnimation();
   EndSplitView();
 
   // Rotate the screen by 90 degree.
@@ -1600,7 +1200,6 @@
             window1->delegate()->GetMinimumSize().height());
   EXPECT_FALSE(window1->layer()->GetTargetTransform().IsIdentity());
   split_view_controller()->EndResize(resize_point);
-  SkipDividerSnapAnimation();
   EndSplitView();
 }
 
@@ -1629,7 +1228,6 @@
       split_view_divider()->GetDividerBoundsInScreen(false);
   generator->set_current_screen_location(divider_bounds.CenterPoint());
   generator->DragMouseTo(gfx::Point(workarea_bounds.width() * 0.33f, 0));
-  SkipDividerSnapAnimation();
   EXPECT_GT(divider_position(), 0.33f * workarea_bounds.width());
   EXPECT_LE(divider_position(), 0.5f * workarea_bounds.width());
 
@@ -1637,7 +1235,6 @@
   // dragging.
   generator->set_current_screen_location(divider_bounds.CenterPoint());
   generator->DragMouseTo(gfx::Point(workarea_bounds.width() * 0.67f, 0));
-  SkipDividerSnapAnimation();
   EXPECT_GT(divider_position(), 0.5f * workarea_bounds.width());
   EXPECT_LE(divider_position(), 0.67f * workarea_bounds.width());
   EndSplitView();
@@ -1652,7 +1249,6 @@
   divider_bounds = split_view_divider()->GetDividerBoundsInScreen(false);
   generator->set_current_screen_location(divider_bounds.CenterPoint());
   generator->DragMouseTo(gfx::Point(workarea_bounds.width() * 0.67f, 0));
-  SkipDividerSnapAnimation();
   EXPECT_GT(divider_position(), 0.33f * workarea_bounds.width());
   EXPECT_LE(divider_position(), 0.5f * workarea_bounds.width());
 
@@ -1660,7 +1256,6 @@
   // dragging.
   generator->set_current_screen_location(divider_bounds.CenterPoint());
   generator->DragMouseTo(gfx::Point(workarea_bounds.width() * 0.33f, 0));
-  SkipDividerSnapAnimation();
   EXPECT_GT(divider_position(), 0);
   EXPECT_LE(divider_position(), 0.33f * workarea_bounds.width());
   EndSplitView();
@@ -1680,7 +1275,6 @@
   divider_bounds = split_view_divider()->GetDividerBoundsInScreen(false);
   generator->set_current_screen_location(divider_bounds.CenterPoint());
   generator->DragMouseTo(gfx::Point(workarea_bounds.width() * 0.33f, 0));
-  SkipDividerSnapAnimation();
   EXPECT_GT(divider_position(), 0.33f * workarea_bounds.width());
   EXPECT_LE(divider_position(), 0.5f * workarea_bounds.width());
 
@@ -1688,7 +1282,6 @@
   // position after dragging.
   generator->set_current_screen_location(divider_bounds.CenterPoint());
   generator->DragMouseTo(gfx::Point(workarea_bounds.width() * 0.67f, 0));
-  SkipDividerSnapAnimation();
   EXPECT_GT(divider_position(), 0.33f * workarea_bounds.width());
   EXPECT_LE(divider_position(), 0.5f * workarea_bounds.width());
   EndSplitView();
@@ -1717,7 +1310,6 @@
       split_view_divider()->GetDividerBoundsInScreen(false);
   generator->set_current_screen_location(divider_bounds.CenterPoint());
   generator->DragMouseTo(gfx::Point(workarea_bounds.width() * 0.67f, 0));
-  SkipDividerSnapAnimation();
   EXPECT_GT(divider_position(), 0.5f * workarea_bounds.width());
   EXPECT_LE(divider_position(), 0.67f * workarea_bounds.width());
 
@@ -1981,7 +1573,6 @@
   ToggleOverview();
   EXPECT_FALSE(Shell::Get()->overview_controller()->IsSelecting());
   EXPECT_TRUE(overview_observer->overview_animate_when_exiting());
-  CheckOverviewEnterExitHistogram("NormalEnterExit", {1, 0}, {1, 0});
 
   // 2) If overview is ended because of activating a window:
   ToggleOverview();
@@ -1989,7 +1580,6 @@
   wm::ActivateWindow(window1.get());
   EXPECT_FALSE(Shell::Get()->overview_controller()->IsSelecting());
   EXPECT_TRUE(overview_observer->overview_animate_when_exiting());
-  CheckOverviewEnterExitHistogram("EnterExitByActivation", {2, 0}, {2, 0});
 
   // 3) If overview is ended because of snapping a window:
   split_view_controller()->SnapWindow(window1.get(), SplitViewController::LEFT);
@@ -2000,25 +1590,19 @@
   EXPECT_TRUE(Shell::Get()->overview_controller()->IsSelecting());
   // Test |overview_animate_when_exiting_| has been properly reset.
   EXPECT_TRUE(overview_observer->overview_animate_when_exiting());
-  CheckOverviewEnterExitHistogram("EnterInSplitView", {2, 1}, {2, 0});
-
   split_view_controller()->SnapWindow(window2.get(),
                                       SplitViewController::RIGHT);
   EXPECT_FALSE(Shell::Get()->overview_controller()->IsSelecting());
   EXPECT_FALSE(overview_observer->overview_animate_when_exiting());
-  CheckOverviewEnterExitHistogram("ExitBySnap", {2, 1}, {2, 1});
 
   // 4) If ending overview causes a window to snap:
   ToggleOverview();
   EXPECT_TRUE(Shell::Get()->overview_controller()->IsSelecting());
   // Test |overview_animate_when_exiting_| has been properly reset.
   EXPECT_TRUE(overview_observer->overview_animate_when_exiting());
-  CheckOverviewEnterExitHistogram("EnterInSplitView2", {2, 2}, {2, 1});
-
   ToggleOverview();
   EXPECT_FALSE(Shell::Get()->overview_controller()->IsSelecting());
   EXPECT_FALSE(overview_observer->overview_animate_when_exiting());
-  CheckOverviewEnterExitHistogram("ExitInSplitView", {2, 2}, {2, 2});
 }
 
 // Test the window state is normally maximized on splitview end, except when we
@@ -2134,7 +1718,6 @@
   // Drag the divider to one third position of the work area's width.
   generator->DragMouseTo(
       gfx::Point(workarea_bounds.width() * 0.33f, workarea_bounds.y()));
-  SkipDividerSnapAnimation();
   EXPECT_EQ(divider_closest_ratio(), 0.33f);
 
   // Divider closest position ratio changed from one third to two thirds if
@@ -2205,168 +1788,15 @@
   EXPECT_FALSE(ShouldAllowSplitView());
 }
 
-// Test that if split view ends while the divider is dragged to where a snapped
-// window is sliding off the screen because it has reached minimum size, then
-// the offset is cleared.
-TEST_F(SplitViewControllerTest, EndSplitViewWhileResizingBeyondMinimum) {
-  int64_t display_id = display::Screen::GetScreen()->GetPrimaryDisplay().id();
-  display::DisplayManager* display_manager = Shell::Get()->display_manager();
-  display::test::ScopedSetInternalDisplayId set_internal(display_manager,
-                                                         display_id);
-  ScreenOrientationControllerTestApi test_api(
-      Shell::Get()->screen_orientation_controller());
-
-  const gfx::Rect bounds(0, 0, 300, 200);
-  std::unique_ptr<aura::Window> window(CreateWindow(bounds));
-  aura::test::TestWindowDelegate* delegate =
-      static_cast<aura::test::TestWindowDelegate*>(window->delegate());
-
-  // Set the screen orientation to LANDSCAPE_PRIMARY
-  test_api.SetDisplayRotation(display::Display::ROTATE_0,
-                              display::Display::RotationSource::ACTIVE);
-
-  gfx::Rect display_bounds =
-      screen_util::GetDisplayWorkAreaBoundsInScreenForDefaultContainer(
-          window.get());
-  split_view_controller()->SnapWindow(window.get(), SplitViewController::LEFT);
-  delegate->set_minimum_size(
-      gfx::Size(display_bounds.width() * 0.4f, display_bounds.height()));
-
-  gfx::Rect divider_bounds =
-      split_view_divider()->GetDividerBoundsInScreen(false);
-  split_view_controller()->StartResize(divider_bounds.CenterPoint());
-  gfx::Point resize_point(display_bounds.width() * 0.33f, 0);
-  split_view_controller()->Resize(resize_point);
-  histograms().ExpectTotalCount(
-      "Ash.SplitViewResize.PresentationTime.TabletMode.SingleWindow", 1);
-  histograms().ExpectTotalCount(
-      "Ash.SplitViewResize.PresentationTime.MaxLatency.TabletMode.SingleWindow",
-      0);
-
-  ASSERT_FALSE(window->layer()->GetTargetTransform().IsIdentity());
-  EndSplitView();
-  histograms().ExpectTotalCount(
-      "Ash.SplitViewResize.PresentationTime.TabletMode.SingleWindow", 1);
-  histograms().ExpectTotalCount(
-      "Ash.SplitViewResize.PresentationTime.MaxLatency.TabletMode.SingleWindow",
-      1);
-
-  EXPECT_TRUE(window->layer()->GetTargetTransform().IsIdentity());
-}
-
-// Test if presentation time is recorded for multi window resizing
-// and resizing with overview.
-TEST_F(SplitViewControllerTest, ResizeTwoWindows) {
-  int64_t display_id = display::Screen::GetScreen()->GetPrimaryDisplay().id();
-  display::DisplayManager* display_manager = Shell::Get()->display_manager();
-  display::test::ScopedSetInternalDisplayId set_internal(display_manager,
-                                                         display_id);
-  ScreenOrientationControllerTestApi test_api(
-      Shell::Get()->screen_orientation_controller());
-
-  const gfx::Rect bounds(0, 0, 300, 200);
-  std::unique_ptr<aura::Window> window1(CreateWindow(bounds));
-  std::unique_ptr<aura::Window> window2(CreateWindow(bounds));
-
-  gfx::Rect display_bounds =
-      screen_util::GetDisplayWorkAreaBoundsInScreenForDefaultContainer(
-          window1.get());
-  split_view_controller()->SnapWindow(window1.get(), SplitViewController::LEFT);
-  split_view_controller()->SnapWindow(window2.get(),
-                                      SplitViewController::RIGHT);
-
-  gfx::Rect divider_bounds =
-      split_view_divider()->GetDividerBoundsInScreen(false);
-  split_view_controller()->StartResize(divider_bounds.CenterPoint());
-  gfx::Point resize_point(display_bounds.width() * 0.33f, 0);
-  split_view_controller()->Resize(resize_point);
-  histograms().ExpectTotalCount(
-      "Ash.SplitViewResize.PresentationTime.TabletMode.MultiWindow", 1);
-  split_view_controller()->Resize(
-      gfx::Point(resize_point.x(), resize_point.y() + 1));
-  histograms().ExpectTotalCount(
-      "Ash.SplitViewResize.PresentationTime.TabletMode.MultiWindow", 2);
-  histograms().ExpectTotalCount(
-      "Ash.SplitViewResize.PresentationTime.MaxLatency.TabletMode.MultiWindow",
-      0);
-
-  split_view_controller()->EndResize(resize_point);
-  histograms().ExpectTotalCount(
-      "Ash.SplitViewResize.PresentationTime.TabletMode.MultiWindow", 2);
-  histograms().ExpectTotalCount(
-      "Ash.SplitViewResize.PresentationTime.MaxLatency.TabletMode.MultiWindow",
-      1);
-
-  ToggleOverview();
-
-  split_view_controller()->StartResize(divider_bounds.CenterPoint());
-  split_view_controller()->Resize(resize_point);
-  histograms().ExpectTotalCount(
-      "Ash.SplitViewResize.PresentationTime.TabletMode.WithOverview", 1);
-  split_view_controller()->Resize(
-      gfx::Point(resize_point.x(), resize_point.y() + 1));
-  histograms().ExpectTotalCount(
-      "Ash.SplitViewResize.PresentationTime.TabletMode.WithOverview", 2);
-  histograms().ExpectTotalCount(
-      "Ash.SplitViewResize.PresentationTime.MaxLatency.TabletMode.WithOverview",
-      0);
-  split_view_controller()->EndResize(resize_point);
-  histograms().ExpectTotalCount(
-      "Ash.SplitViewResize.PresentationTime.TabletMode.WithOverview", 2);
-  histograms().ExpectTotalCount(
-      "Ash.SplitViewResize.PresentationTime.MaxLatency.TabletMode.WithOverview",
-      1);
-}
-
-// Test that if split view ends during the divider snap animation while a
-// snapped window is sliding off the screen because it has reached minimum size,
-// then the animation is ended and the window offset is cleared.
-TEST_F(SplitViewControllerTest, EndSplitViewDuringDividerSnapAnimation) {
-  int64_t display_id = display::Screen::GetScreen()->GetPrimaryDisplay().id();
-  display::DisplayManager* display_manager = Shell::Get()->display_manager();
-  display::test::ScopedSetInternalDisplayId set_internal(display_manager,
-                                                         display_id);
-  ScreenOrientationControllerTestApi test_api(
-      Shell::Get()->screen_orientation_controller());
-
-  const gfx::Rect bounds(0, 0, 300, 200);
-  std::unique_ptr<aura::Window> window(CreateWindow(bounds));
-  aura::test::TestWindowDelegate* delegate =
-      static_cast<aura::test::TestWindowDelegate*>(window->delegate());
-
-  // Set the screen orientation to LANDSCAPE_PRIMARY
-  test_api.SetDisplayRotation(display::Display::ROTATE_0,
-                              display::Display::RotationSource::ACTIVE);
-
-  gfx::Rect display_bounds =
-      screen_util::GetDisplayWorkAreaBoundsInScreenForDefaultContainer(
-          window.get());
-  split_view_controller()->SnapWindow(window.get(), SplitViewController::LEFT);
-  delegate->set_minimum_size(
-      gfx::Size(display_bounds.width() * 0.4f, display_bounds.height()));
-
-  gfx::Rect divider_bounds =
-      split_view_divider()->GetDividerBoundsInScreen(false);
-  split_view_controller()->StartResize(divider_bounds.CenterPoint());
-  gfx::Point resize_point((int)(display_bounds.width() * 0.33f) + 20, 0);
-  split_view_controller()->Resize(resize_point);
-  split_view_controller()->EndResize(resize_point);
-  ASSERT_TRUE(IsDividerAnimating());
-  ASSERT_FALSE(window->layer()->GetTargetTransform().IsIdentity());
-  EndSplitView();
-  EXPECT_FALSE(IsDividerAnimating());
-  EXPECT_TRUE(window->layer()->GetTargetTransform().IsIdentity());
-}
-
-// TestOverviewObserver which tracks how many overview items there are when
+// TestShellObserver which tracks how many overview items there are when
 // overview mode is about to end.
-class TestOverviewItemsOnOverviewModeEndObserver : public OverviewObserver {
+class TestOverviewItemsOnOverviewModeEndObserver : public ShellObserver {
  public:
   TestOverviewItemsOnOverviewModeEndObserver() {
-    Shell::Get()->overview_controller()->AddObserver(this);
+    Shell::Get()->AddShellObserver(this);
   }
   ~TestOverviewItemsOnOverviewModeEndObserver() override {
-    Shell::Get()->overview_controller()->RemoveObserver(this);
+    Shell::Get()->RemoveShellObserver(this);
   }
   void OnOverviewModeEnding(OverviewSession* overview_session) override {
     items_on_last_overview_end_ = overview_session->num_items_for_testing();
@@ -2404,42 +1834,6 @@
   EXPECT_EQ(0, observer.items_on_last_overview_end());
 }
 
-// Test that resizing ends properly if split view ends during divider dragging.
-TEST_F(SplitViewControllerTest, EndSplitViewWhileDragging) {
-  // Enter split view mode.
-  std::unique_ptr<aura::Window> window = CreateTestWindow();
-  split_view_controller()->SnapWindow(window.get(), SplitViewController::LEFT);
-
-  // Start resizing.
-  gfx::Rect divider_bounds =
-      split_view_divider()->GetDividerBoundsInScreen(false);
-
-  split_view_controller()->StartResize(divider_bounds.CenterPoint());
-
-  // Verify the setup.
-  ASSERT_TRUE(split_view_controller()->IsSplitViewModeActive());
-  ASSERT_TRUE(split_view_controller()->is_resizing());
-
-  gfx::Point resize_point(divider_bounds.CenterPoint());
-  resize_point.Offset(100, 0);
-
-  split_view_controller()->Resize(resize_point);
-  histograms().ExpectTotalCount(
-      "Ash.SplitViewResize.PresentationTime.TabletMode.SingleWindow", 1);
-  histograms().ExpectTotalCount(
-      "Ash.SplitViewResize.PresentationTime.MaxLatency.TabletMode.SingleWindow",
-      0);
-
-  // End split view and check that resizing has ended properly.
-  split_view_controller()->EndSplitView();
-  EXPECT_FALSE(split_view_controller()->is_resizing());
-  histograms().ExpectTotalCount(
-      "Ash.SplitViewResize.PresentationTime.TabletMode.SingleWindow", 1);
-  histograms().ExpectTotalCount(
-      "Ash.SplitViewResize.PresentationTime.MaxLatency.TabletMode.SingleWindow",
-      1);
-}
-
 // Test the tab-dragging related functionalities in tablet mode. Tab(s) can be
 // dragged out of a window and then put in split view mode or merge into another
 // window.
@@ -2466,12 +1860,8 @@
   std::unique_ptr<WindowResizer> StartDrag(aura::Window* dragged_window,
                                            aura::Window* source_window) {
     SetIsInTabDragging(dragged_window, /*is_dragging=*/true, source_window);
-    std::unique_ptr<WindowResizer> resizer = CreateResizerForTest(
-        dragged_window, dragged_window->bounds().origin(), HTCAPTION);
-    GetBrowserWindowDragController(resizer.get())
-        ->drag_delegate_for_testing()
-        ->set_drag_start_deadline_for_testing(base::Time::Now());
-    return resizer;
+    return CreateResizerForTest(dragged_window,
+                                dragged_window->bounds().origin(), HTCAPTION);
   }
 
   // Drags the window to |end_position|.
@@ -2539,20 +1929,18 @@
     }
   }
 
-  TabletModeWindowDragController* GetBrowserWindowDragController(
-      WindowResizer* resizer) {
+  IndicatorState GetIndicatorState(WindowResizer* resizer) {
     WindowResizer* real_window_resizer;
     // TODO(xdai): This piece of codes seems knowing too much impl details about
     // WindowResizer. Revisit the logic here later to see if there is anything
     // we can do to simplify the logic and hide impl details.
     real_window_resizer = static_cast<DragWindowResizer*>(resizer)
                               ->next_window_resizer_for_testing();
-    return static_cast<TabletModeWindowDragController*>(real_window_resizer);
-  }
+    TabletModeBrowserWindowDragController* browser_controller =
+        static_cast<TabletModeBrowserWindowDragController*>(
+            real_window_resizer);
 
-  IndicatorState GetIndicatorState(WindowResizer* resizer) {
-    return GetBrowserWindowDragController(resizer)
-        ->drag_delegate_for_testing()
+    return browser_controller->drag_delegate_for_testing()
         ->split_view_drag_indicators_for_testing()
         ->current_indicator_state();
   }
@@ -2575,8 +1963,8 @@
         overview_session->GetGridWithRootWindow(window->GetRootWindow());
     DCHECK(current_grid);
 
-    OverviewItem* overview_item = current_grid->GetDropTarget();
-    return gfx::ToEnclosedRect(overview_item->GetTransformedBounds());
+    OverviewItem* selector_item = current_grid->GetDropTarget();
+    return selector_item->GetTransformedBounds();
   }
 
  private:
@@ -2953,8 +2341,6 @@
   EXPECT_FALSE(overview_session->IsWindowInOverview(window1.get()));
   EXPECT_FALSE(overview_session->IsWindowInOverview(window2.get()));
   EXPECT_TRUE(overview_session->IsWindowInOverview(window3.get()));
-  // Drag to enter doesn't trigger animation.
-  CheckOverviewEnterExitHistogram("EnterInSplitViewByDrag", {0, 0}, {0, 0});
 
   // 1.a. If the window is only dragged for a small distance, the window will
   // be put back to its original position. Overview mode will be ended.
@@ -2965,7 +2351,6 @@
   EXPECT_EQ(split_view_controller()->left_window(), window1.get());
   EXPECT_EQ(split_view_controller()->right_window(), window2.get());
   EXPECT_FALSE(Shell::Get()->overview_controller()->IsSelecting());
-  CheckOverviewEnterExitHistogram("ExitInSplitViewByDrag", {0, 0}, {0, 1});
 
   // 1.b. If the window is dragged long enough, it can replace the other split
   // window.
@@ -2975,8 +2360,6 @@
   DragWindowTo(resizer.get(), gfx::Point(600, 300));
   // No preview window shows up on overview side of the screen.
   EXPECT_EQ(GetIndicatorState(resizer.get()), IndicatorState::kNone);
-  CheckOverviewEnterExitHistogram("EnterInSplitViewByDrag2", {0, 0}, {0, 1});
-
   CompleteDrag(std::move(resizer));
   EXPECT_EQ(split_view_controller()->state(),
             SplitViewController::RIGHT_SNAPPED);
@@ -2986,13 +2369,10 @@
   EXPECT_FALSE(overview_session->IsWindowInOverview(window1.get()));
   EXPECT_TRUE(overview_session->IsWindowInOverview(window2.get()));
   EXPECT_TRUE(overview_session->IsWindowInOverview(window3.get()));
-  // Still in overview.
-  CheckOverviewEnterExitHistogram("DoNotExitInSplitViewByDrag", {0, 0}, {0, 1});
   // Snap |window2| again to test 1.c.
   split_view_controller()->SnapWindow(window2.get(), SplitViewController::LEFT);
   EXPECT_EQ(split_view_controller()->state(),
             SplitViewController::BOTH_SNAPPED);
-  CheckOverviewEnterExitHistogram("ExitInSplitViewBySnap", {0, 0}, {0, 2});
 
   // 1.c. If the dragged window is destroyed during dragging (may happen due to
   // all its tabs are attached into another window), nothing changes.
@@ -3001,7 +2381,6 @@
             SplitViewController::LEFT_SNAPPED);
   ASSERT_TRUE(resizer.get());
   EXPECT_TRUE(Shell::Get()->overview_controller()->IsSelecting());
-  CheckOverviewEnterExitHistogram("EnterInSplitViewByDrag3", {0, 0}, {0, 2});
   resizer->Drag(gfx::Point(100, 100), 0);
   resizer->CompleteDrag();
   resizer.reset();
@@ -3009,9 +2388,6 @@
   EXPECT_EQ(split_view_controller()->state(),
             SplitViewController::LEFT_SNAPPED);
   EXPECT_TRUE(Shell::Get()->overview_controller()->IsSelecting());
-  // Still in overview.
-  CheckOverviewEnterExitHistogram("DoNotExitInSplitViewByDrag3", {0, 0},
-                                  {0, 2});
 
   // Recreate |window1| and snap it to test the following senarioes.
   window1.reset(CreateWindowWithType(bounds, AppType::BROWSER));
@@ -3021,7 +2397,6 @@
             SplitViewController::BOTH_SNAPPED);
   EXPECT_EQ(split_view_controller()->left_window(), window2.get());
   EXPECT_EQ(split_view_controller()->right_window(), window1.get());
-  CheckOverviewEnterExitHistogram("ExitInSplitViewBySnap2", {0, 0}, {0, 3});
 
   // 2. If the dragged window is not the source window:
   // In this case, |window3| can be regarded as a window that originates from
@@ -3037,9 +2412,6 @@
   EXPECT_EQ(window2->GetBoundsInScreen(),
             split_view_controller()->GetSnappedWindowBoundsInScreen(
                 window2.get(), SplitViewController::LEFT));
-  // Not in overview.
-  CheckOverviewEnterExitHistogram("DoNotEnterInSplitViewByDrag", {0, 0},
-                                  {0, 3});
 
   // 2.a. If the window is only dragged for a small amount of distance, it will
   // replace the same side of the split window that it originates from.
@@ -3060,8 +2432,6 @@
   EXPECT_EQ(split_view_controller()->left_window(), window3.get());
   EXPECT_EQ(split_view_controller()->right_window(), window1.get());
   EXPECT_FALSE(Shell::Get()->overview_controller()->IsSelecting());
-  CheckOverviewEnterExitHistogram("DoNotEnterInSplitViewByDrag2", {0, 0},
-                                  {0, 3});
 
   // 2.b. If the window is dragged long enough, it can replace the other side of
   // the split window.
@@ -3072,15 +2442,9 @@
   EXPECT_EQ(split_view_controller()->left_window(), window3.get());
   EXPECT_EQ(split_view_controller()->right_window(), window1.get());
   EXPECT_FALSE(Shell::Get()->overview_controller()->IsSelecting());
-  CheckOverviewEnterExitHistogram("DoNotEnterInSplitViewByDrag3", {0, 0},
-                                  {0, 3});
-
   DragWindowTo(resizer.get(), gfx::Point(0, 300));
   // No preview window shows up on overview side of the screen.
   EXPECT_EQ(GetIndicatorState(resizer.get()), IndicatorState::kNone);
-  CheckOverviewEnterExitHistogram("DoNotEnterInSplitViewByDrag4", {0, 0},
-                                  {0, 3});
-
   CompleteDrag(std::move(resizer));
   EXPECT_EQ(split_view_controller()->state(),
             SplitViewController::BOTH_SNAPPED);
@@ -3111,7 +2475,6 @@
   EXPECT_EQ(split_view_controller()->state(),
             SplitViewController::LEFT_SNAPPED);
   EXPECT_EQ(split_view_controller()->left_window(), window1.get());
-  CheckOverviewEnterExitHistogram("EnterInSplitView", {0, 1}, {0, 0});
 
   // 1. If the dragged window is the source window:
   std::unique_ptr<WindowResizer> resizer =
@@ -3129,14 +2492,10 @@
   DragWindowTo(resizer.get(),
                gfx::Point(200, GetIndicatorsThreshold(window1.get())));
   EXPECT_EQ(GetIndicatorState(resizer.get()), IndicatorState::kDragArea);
-  EXPECT_FALSE(split_view_controller()->IsSplitViewModeActive());
   CompleteDrag(std::move(resizer));
   EXPECT_TRUE(wm::GetWindowState(window1.get())->IsMaximized());
   EXPECT_FALSE(Shell::Get()->overview_controller()->IsSelecting());
   EXPECT_FALSE(split_view_controller()->IsSplitViewModeActive());
-  // It exits SplitView during drag, so exit animation is performed in tablet
-  // mode.
-  CheckOverviewEnterExitHistogram("ExitInSplitViewToTablet", {0, 1}, {1, 0});
 
   // 1.b. If the window is dragged long enough, it can be snappped again.
   // Prepare the testing senario first.
@@ -3144,14 +2503,10 @@
   split_view_controller()->SnapWindow(window2.get(),
                                       SplitViewController::RIGHT);
   ToggleOverview();
-  CheckOverviewEnterExitHistogram("EnterInSplitView2", {0, 2}, {1, 0});
-
   resizer = StartDrag(window1.get(), window1.get());
   ASSERT_TRUE(resizer.get());
   EXPECT_TRUE(Shell::Get()->overview_controller()->IsSelecting());
   EXPECT_FALSE(split_view_controller()->IsSplitViewModeActive());
-  CheckOverviewEnterExitHistogram("DoNotExitInSplitView2", {0, 2}, {1, 0});
-
   DragWindowTo(resizer.get(), gfx::Point(0, 300));
   EXPECT_EQ(GetIndicatorState(resizer.get()), IndicatorState::kPreviewAreaLeft);
   CompleteDrag(std::move(resizer));
@@ -3163,7 +2518,6 @@
       Shell::Get()->overview_controller()->overview_session();
   EXPECT_TRUE(overview_session->IsWindowInOverview(window2.get()));
   EXPECT_TRUE(overview_session->IsWindowInOverview(window3.get()));
-  CheckOverviewEnterExitHistogram("DoNotExitInSplitView3", {0, 2}, {1, 0});
 
   // 2. If the dragged window is not the source window:
   // Prepare the testing senario first. Remove |window2| from overview first
@@ -3190,7 +2543,6 @@
   EXPECT_EQ(window1->GetBoundsInScreen(),
             split_view_controller()->GetSnappedWindowBoundsInScreen(
                 window1.get(), SplitViewController::LEFT));
-  CheckOverviewEnterExitHistogram("DoNotExitInSplitView4", {0, 2}, {1, 0});
 
   // 2.a. The dragged window can replace the only snapped window in the split
   // screen. After that, the old snapped window will be put back in overview.
@@ -3205,7 +2557,6 @@
   overview_session = Shell::Get()->overview_controller()->overview_session();
   EXPECT_TRUE(overview_session->IsWindowInOverview(window1.get()));
   EXPECT_TRUE(overview_session->IsWindowInOverview(window3.get()));
-  CheckOverviewEnterExitHistogram("DoNotExitInSplitView5", {0, 2}, {1, 0});
 
   // 2.b. The dragged window can snap to the other side of the splitscreen,
   // causing overview mode to end.
@@ -3224,7 +2575,6 @@
   EXPECT_EQ(split_view_controller()->left_window(), window2.get());
   EXPECT_EQ(split_view_controller()->right_window(), window1.get());
   EXPECT_FALSE(Shell::Get()->overview_controller()->IsSelecting());
-  CheckOverviewEnterExitHistogram("ExitInSplitView", {0, 2}, {1, 1});
 }
 
 // Test that if a window is in tab-dragging process when overview is open, the
@@ -3269,8 +2619,7 @@
       drop_target_widget->GetNativeWindow());
   ASSERT_TRUE(drop_target);
   EXPECT_EQ(drop_target, current_grid->window_list().front().get());
-  const gfx::Rect drop_target_bounds =
-      gfx::ToEnclosingRect(drop_target->target_bounds());
+  const gfx::Rect drop_target_bounds = drop_target->target_bounds();
   DragWindowTo(resizer.get(), drop_target_bounds.CenterPoint());
   CompleteDrag(std::move(resizer));
 
@@ -3280,9 +2629,9 @@
   // Test that the dragged window has been added to the overview mode, and it is
   // added at the front of the grid.
   EXPECT_EQ(current_grid->window_list().size(), 2u);
-  OverviewItem* first_overview_item =
+  OverviewItem* first_selector_item =
       current_grid->GetOverviewItemContaining(window1.get());
-  EXPECT_EQ(first_overview_item, current_grid->window_list().front().get());
+  EXPECT_EQ(first_selector_item, current_grid->window_list().front().get());
   EXPECT_TRUE(overview_session->IsWindowInOverview(window1.get()));
   EXPECT_TRUE(overview_session->IsWindowInOverview(window3.get()));
   // Test that the new window item widget has been destroyed.
@@ -3545,10 +2894,9 @@
   ASSERT_TRUE(current_grid);
   EXPECT_EQ(1u, current_grid->window_list().size());
 
-  OverviewItem* overview_item = current_grid->GetDropTarget();
-  ASSERT_TRUE(overview_item);
-  gfx::Rect drop_target_bounds =
-      gfx::ToEnclosingRect(overview_item->target_bounds());
+  OverviewItem* selector_item = current_grid->GetDropTarget();
+  ASSERT_TRUE(selector_item);
+  gfx::Rect drop_target_bounds = selector_item->target_bounds();
   DragWindowTo(resizer.get(), drop_target_bounds.CenterPoint());
 
   CompleteDrag(std::move(resizer));
@@ -3557,11 +2905,10 @@
   EXPECT_TRUE(overview_session->IsWindowInOverview(window1.get()));
   // |window1|'s bounds should have been updated to its tablet mode bounds.
   EXPECT_EQ(tablet_mode_bounds, window1->bounds());
-  overview_item = current_grid->window_list().front().get();
-  // The new overview item's bounds should be the same during drag and after
-  // drag.
-  EXPECT_EQ(drop_target_bounds,
-            gfx::ToEnclosingRect(overview_item->target_bounds()));
+  selector_item = current_grid->window_list().front().get();
+  // The new window selector item's bounds should be the same during drag and
+  // after drag.
+  EXPECT_EQ(drop_target_bounds, selector_item->target_bounds());
   ToggleOverview();
   EXPECT_FALSE(overview_controller->IsSelecting());
 
@@ -4219,14 +3566,20 @@
   ~SplitViewAppDraggingTest() override = default;
 
   // SplitViewControllerTest:
+  void SetUp() override {
+    SplitViewControllerTest::SetUp();
+    controller_ = std::make_unique<TabletModeAppWindowDragController>();
+  }
+
+  // SplitViewControllerTest:
   void TearDown() override {
-    window_.reset();
     controller_.reset();
     SplitViewControllerTest::TearDown();
   }
 
  protected:
-  std::unique_ptr<aura::Window> CreateTestWindowWithWidget(bool can_activate) {
+  std::unique_ptr<aura::Window> CreateTestWindowWithWidget(
+      bool can_activate = true) {
     views::Widget::InitParams params(views::Widget::InitParams::TYPE_WINDOW);
     params.show_state = ui::SHOW_STATE_MAXIMIZED;
     views::Widget* widget = new views::Widget;
@@ -4240,172 +3593,192 @@
     return base::WrapUnique<aura::Window>(widget->GetNativeView());
   }
 
-  void InitializeWindow(bool can_activate = true) {
-    window_ = CreateTestWindowWithWidget(can_activate);
-  }
-
   // Sends a gesture scroll sequence to TabletModeAppWindowDragController.
-  void SendGestureEvents(const gfx::Point& location) {
-    SendScrollStartAndUpdate(location);
-    EndScrollSequence();
-  }
-
-  void SendScrollStartAndUpdate(const gfx::Point& location) {
-    wm::WindowState* window_state = wm::GetWindowState(window());
-    window_state->CreateDragDetails(location, HTCAPTION,
-                                    ::wm::WINDOW_MOVE_SOURCE_TOUCH);
-    controller_ = std::make_unique<TabletModeWindowDragController>(
-        window_state, std::make_unique<TabletModeBrowserWindowDragDelegate>());
-    controller_->drag_delegate_for_testing()
-        ->set_drag_start_deadline_for_testing(base::Time::Now());
-    controller_->Drag(location, 0);
-  }
+  void SendGestureEvents(const gfx::Point& start,
+                         float scroll_delta,
+                         aura::Window* window) {
+    base::TimeTicks timestamp = base::TimeTicks::Now();
+    SendScrollStartAndUpdate(start, scroll_delta, timestamp, window);
 
-  void EndScrollSequence() {
-    controller_->CompleteDrag();
-    wm::GetWindowState(window())->DeleteDragDetails();
+    EndScrollSequence(start, scroll_delta, timestamp, window);
   }
 
-  void Fling(const gfx::Point& location, float velocity_y, float velocity_x) {
-    ui::GestureEvent event = ui::GestureEvent(
-        location.x(), location.y(), ui::EF_NONE, base::TimeTicks::Now(),
-        ui::GestureEventDetails(ui::ET_SCROLL_FLING_START, velocity_x,
-                                velocity_y));
-    ui::Event::DispatcherApi(&event).set_target(window());
-    controller_->FlingOrSwipe(&event);
-    wm::GetWindowState(window())->DeleteDragDetails();
+  void SendScrollStartAndUpdate(const gfx::Point& start,
+                                float scroll_y,
+                                base::TimeTicks& timestamp,
+                                aura::Window* window,
+                                float scroll_x = 0.f) {
+    SendGestureEventToController(
+        start.x(), start.y(), timestamp,
+        ui::GestureEventDetails(ui::ET_GESTURE_SCROLL_BEGIN, 0, 0), window);
+
+    timestamp += base::TimeDelta::FromMilliseconds(100);
+    SendGestureEventToController(
+        start.x() + scroll_x, start.y() + scroll_y, timestamp,
+        ui::GestureEventDetails(ui::ET_GESTURE_SCROLL_UPDATE, scroll_x,
+                                scroll_y),
+        window);
+  }
+
+  void EndScrollSequence(const gfx::Point& start,
+                         float scroll_delta,
+                         base::TimeTicks& timestamp,
+                         aura::Window* window,
+                         bool is_fling = false,
+                         float velocity_y = 0.f,
+                         float velocity_x = 0.f) {
+    timestamp += base::TimeDelta::FromMilliseconds(100);
+    ui::GestureEventDetails details =
+        is_fling ? ui::GestureEventDetails(ui::ET_SCROLL_FLING_START,
+                                           velocity_x, velocity_y)
+                 : ui::GestureEventDetails(ui::ET_GESTURE_SCROLL_END);
+    SendGestureEventToController(start.x(), start.y() + scroll_delta, timestamp,
+                                 details, window);
   }
 
   IndicatorState GetIndicatorState() {
-    return controller_->drag_delegate_for_testing()
+    return controller_->drag_delegate()
         ->split_view_drag_indicators_for_testing()
         ->current_indicator_state();
   }
 
-  aura::Window* window() { return window_.get(); }
-
-  std::unique_ptr<TabletModeWindowDragController> controller_;
+ private:
+  void SendGestureEventToController(int x,
+                                    int y,
+                                    base::TimeTicks& timestamp,
+                                    const ui::GestureEventDetails& details,
+                                    aura::Window* window) {
+    ui::GestureEvent event =
+        ui::GestureEvent(x, y, ui::EF_NONE, timestamp, details);
+    ui::Event::DispatcherApi(&event).set_target(window);
+    controller_->DragWindowFromTop(&event);
+  }
 
-  std::unique_ptr<aura::Window> window_;
+  std::unique_ptr<TabletModeAppWindowDragController> controller_;
 
- private:
   DISALLOW_COPY_AND_ASSIGN(SplitViewAppDraggingTest);
 };
 
 // Tests that drag the window that cannot be snapped from top of the display
 // will not snap the window into splitscreen.
-TEST_F(SplitViewAppDraggingTest, DragNonActiveMaximizedWindow) {
+TEST_F(SplitViewAppDraggingTest, DragNoneActiveMaximizedWindow) {
   UpdateDisplay("800x600");
-  InitializeWindow(false);
-  EXPECT_TRUE(wm::GetWindowState(window())->IsMaximized());
+  std::unique_ptr<aura::Window> window = CreateTestWindowWithWidget(false);
+  EXPECT_TRUE(wm::GetWindowState(window.get())->IsMaximized());
   gfx::Rect display_bounds =
       screen_util::GetDisplayWorkAreaBoundsInScreenForDefaultContainer(
-          window());
+          window.get());
   const float long_scroll_delta = display_bounds.height() / 4 + 5;
 
-  const gfx::Point location(0, long_scroll_delta);
+  const gfx::Point start;
   // Drag the window that cannot be snapped long enough, the window will be
   // dropped into overview.
-  SendScrollStartAndUpdate(location);
+  base::TimeTicks timestamp = base::TimeTicks::Now();
+  SendScrollStartAndUpdate(start, long_scroll_delta, timestamp, window.get());
   OverviewController* overview_controller = Shell::Get()->overview_controller();
   EXPECT_TRUE(overview_controller->IsSelecting());
-  EXPECT_FALSE(
-      overview_controller->overview_session()->IsWindowInOverview(window()));
-  EndScrollSequence();
+  EXPECT_FALSE(overview_controller->overview_session()->IsWindowInOverview(
+      window.get()));
+  EndScrollSequence(start, long_scroll_delta, timestamp, window.get());
   EXPECT_TRUE(overview_controller->IsSelecting());
   EXPECT_FALSE(split_view_controller()->IsSplitViewModeActive());
-  EXPECT_TRUE(
-      overview_controller->overview_session()->IsWindowInOverview(window()));
+  EXPECT_TRUE(overview_controller->overview_session()->IsWindowInOverview(
+      window.get()));
 }
 
 // Tests the functionalities that are related to dragging a maximized window
 // into splitscreen.
 TEST_F(SplitViewAppDraggingTest, DragActiveMaximizedWindow) {
   UpdateDisplay("800x600");
-  InitializeWindow();
-  EXPECT_TRUE(wm::GetWindowState(window())->IsMaximized());
+  std::unique_ptr<aura::Window> window = CreateTestWindowWithWidget();
+  EXPECT_TRUE(wm::GetWindowState(window.get())->IsMaximized());
   gfx::Rect display_bounds =
       screen_util::GetDisplayWorkAreaBoundsInScreenForDefaultContainer(
-          window());
+          window.get());
 
   // Move the window by a small amount of distance will maximize the window
   // again.
-  gfx::Point location(0, 10);
-  SendGestureEvents(location);
-  EXPECT_TRUE(wm::GetWindowState(window())->IsMaximized());
+  const gfx::Point start;
+  SendGestureEvents(start, 10, window.get());
+  EXPECT_TRUE(wm::GetWindowState(window.get())->IsMaximized());
 
   // Drag the window long enough (pass one fourth of the screen vertical
   // height) to snap the window to splitscreen.
   const float long_scroll_delta = display_bounds.height() / 4 + 5;
-  location.set_y(long_scroll_delta);
-  SendScrollStartAndUpdate(location);
+  base::TimeTicks timestamp = base::TimeTicks::Now();
+  SendScrollStartAndUpdate(start, long_scroll_delta, timestamp, window.get());
   OverviewController* overview_controller = Shell::Get()->overview_controller();
   EXPECT_TRUE(overview_controller->IsSelecting());
-  EXPECT_FALSE(
-      overview_controller->overview_session()->IsWindowInOverview(window()));
-  EndScrollSequence();
+  EXPECT_FALSE(overview_controller->overview_session()->IsWindowInOverview(
+      window.get()));
+  EndScrollSequence(start, long_scroll_delta, timestamp, window.get());
   EXPECT_TRUE(overview_controller->IsSelecting());
   EXPECT_TRUE(split_view_controller()->IsSplitViewModeActive());
-  EXPECT_EQ(split_view_controller()->left_window(), window());
+  EXPECT_EQ(split_view_controller()->left_window(), window.get());
   EXPECT_EQ(split_view_controller()->state(),
             SplitViewController::LEFT_SNAPPED);
-  EXPECT_TRUE(wm::GetWindowState(window())->IsSnapped());
+  EXPECT_TRUE(wm::GetWindowState(window.get())->IsSnapped());
 
   // FLING the window with small velocity (smaller than
   // kFlingToOverviewThreshold) will not able to drop the window into overview.
-  location.set_y(10);
-  SendScrollStartAndUpdate(location);
+  timestamp = base::TimeTicks::Now();
+  SendScrollStartAndUpdate(start, 10, timestamp, window.get());
   overview_controller = Shell::Get()->overview_controller();
   EXPECT_TRUE(overview_controller->IsSelecting());
-  Fling(location,
-        TabletModeWindowDragDelegate::kFlingToOverviewThreshold - 10.f, 0);
+  EndScrollSequence(
+      start, 10, timestamp, window.get(), /*is_fling=*/true,
+      /*velocity_y=*/
+      TabletModeWindowDragDelegate::kFlingToOverviewThreshold - 10.f);
   EXPECT_FALSE(overview_controller->IsSelecting());
 
-  // FLING the window with large velocity (larger than
+  // FLING the window with large veloicty (larger than
   // kFlingToOverviewThreshold) will drop the window into overview.
-  SendScrollStartAndUpdate(location);
+  timestamp = base::TimeTicks::Now();
+  SendScrollStartAndUpdate(start, 10, timestamp, window.get());
   overview_controller = Shell::Get()->overview_controller();
   EXPECT_TRUE(overview_controller->IsSelecting());
-  Fling(location,
-        TabletModeWindowDragDelegate::kFlingToOverviewThreshold + 10.f, 0);
+  EndScrollSequence(
+      start, 10, timestamp, window.get(), /*is_fling=*/true,
+      /*velocity_y=*/
+      TabletModeWindowDragDelegate::kFlingToOverviewThreshold + 10.f);
   EXPECT_TRUE(overview_controller->IsSelecting());
 }
 
 // Tests the shelf visibility when a fullscreened window is being dragged.
 TEST_F(SplitViewAppDraggingTest, ShelfVisibilityIfDraggingFullscreenedWindow) {
   UpdateDisplay("800x600");
-  InitializeWindow();
+  std::unique_ptr<aura::Window> window = CreateTestWindowWithWidget();
   ShelfLayoutManager* shelf_layout_manager =
       AshTestBase::GetPrimaryShelf()->shelf_layout_manager();
   gfx::Rect display_bounds =
       screen_util::GetDisplayWorkAreaBoundsInScreenForDefaultContainer(
-          window());
+          window.get());
 
-  // Shelf will be auto-hidden if the window requests to be fullscreened.
-  wm::WindowState* window_state = wm::GetWindowState(window());
+  // Shelf will be auto-hidden if the winodw requests to be fullscreened.
+  wm::WindowState* window_state = wm::GetWindowState(window.get());
   const wm::WMEvent fullscreen_event(wm::WM_EVENT_TOGGLE_FULLSCREEN);
   window_state->OnWMEvent(&fullscreen_event);
   window_state->SetHideShelfWhenFullscreen(false);
-  window()->SetProperty(kImmersiveIsActive, true);
+  window->SetProperty(kImmersiveIsActive, true);
   shelf_layout_manager->UpdateVisibilityState();
   EXPECT_TRUE(window_state->IsFullscreen());
   EXPECT_FALSE(shelf_layout_manager->IsVisible());
 
   // Drag the window by a small amount of distance, the window will back to
   // fullscreened, and shelf will be hidden again.
-  gfx::Point location(0, 10);
-  SendGestureEvents(location);
-  shelf_layout_manager->UpdateVisibilityState();
-  EXPECT_TRUE(window_state->IsFullscreen());
+  const gfx::Point start;
+  SendGestureEvents(start, 10, window.get());
+  EXPECT_TRUE(wm::GetWindowState(window.get())->IsFullscreen());
   EXPECT_FALSE(shelf_layout_manager->IsVisible());
 
   // Shelf is visible during dragging.
-  location.set_y(display_bounds.height() / 4 + 5);
-  SendScrollStartAndUpdate(location);
+  base::TimeTicks timestamp = base::TimeTicks::Now();
+  const float long_scroll_delta = display_bounds.height() / 4 + 5;
+  SendScrollStartAndUpdate(start, long_scroll_delta, timestamp, window.get());
   EXPECT_TRUE(shelf_layout_manager->IsVisible());
-  EndScrollSequence();
+  EndScrollSequence(start, long_scroll_delta, timestamp, window.get());
   EXPECT_TRUE(split_view_controller()->IsSplitViewModeActive());
-  EXPECT_TRUE(wm::GetWindowState(window())->IsSnapped());
+  EXPECT_TRUE(wm::GetWindowState(window.get())->IsSnapped());
   EXPECT_TRUE(shelf_layout_manager->IsVisible());
 }
 
@@ -4414,47 +3787,85 @@
   UpdateDisplay("800x600");
   Shelf* shelf = GetPrimaryShelf();
   shelf->SetAutoHideBehavior(SHELF_AUTO_HIDE_BEHAVIOR_NEVER);
-  InitializeWindow();
+  std::unique_ptr<aura::Window> window = CreateTestWindowWithWidget();
   gfx::Rect display_bounds =
       display::Screen::GetScreen()->GetPrimaryDisplay().bounds();
   ShelfLayoutManager* shelf_layout_manager =
       AshTestBase::GetPrimaryShelf()->shelf_layout_manager();
   shelf_layout_manager->LayoutShelf();
   EXPECT_EQ(SHELF_VISIBLE, shelf->GetVisibilityState());
-  EXPECT_TRUE(wm::GetWindowState(window())->IsMaximized());
+  EXPECT_TRUE(wm::GetWindowState(window.get())->IsMaximized());
 
   shelf->SetAutoHideBehavior(SHELF_AUTO_HIDE_BEHAVIOR_ALWAYS);
   shelf_layout_manager->LayoutShelf();
   EXPECT_EQ(SHELF_AUTO_HIDE, shelf->GetVisibilityState());
   EXPECT_EQ(SHELF_AUTO_HIDE_HIDDEN, shelf->GetAutoHideState());
 
-  const gfx::Point location(0, display_bounds.height() / 4 + 5);
-  SendScrollStartAndUpdate(location);
+  base::TimeTicks timestamp = base::TimeTicks::Now();
+  const gfx::Point start;
+  const float long_scroll_delta = display_bounds.height() / 4 + 5;
+  SendScrollStartAndUpdate(start, long_scroll_delta, timestamp, window.get());
   EXPECT_EQ(SHELF_AUTO_HIDE_BEHAVIOR_ALWAYS, shelf->auto_hide_behavior());
   EXPECT_EQ(SHELF_AUTO_HIDE, shelf->GetVisibilityState());
   // Shelf should be shown during drag.
   EXPECT_EQ(SHELF_AUTO_HIDE_SHOWN, shelf->GetAutoHideState());
-  EndScrollSequence();
+  EndScrollSequence(start, long_scroll_delta, timestamp, window.get());
   EXPECT_EQ(split_view_controller()->state(),
             SplitViewController::LEFT_SNAPPED);
   EXPECT_EQ(SHELF_AUTO_HIDE, shelf->GetVisibilityState());
   // Shelf should be shown after drag and snapped window should be covered by
   // the auto-hide-shown shelf.
   EXPECT_EQ(SHELF_AUTO_HIDE_SHOWN, shelf->GetAutoHideState());
-  EXPECT_EQ(
-      split_view_controller()
-          ->GetSnappedWindowBoundsInScreen(window(), SplitViewController::LEFT)
+  EXPECT_EQ(split_view_controller()
+                ->GetSnappedWindowBoundsInScreen(window.get(),
+                                                 SplitViewController::LEFT)
           .height(),
       display_bounds.height());
 }
 
+// Tests that the app drag will be reverted if the screen is being rotated.
+TEST_F(SplitViewAppDraggingTest, DisplayConfigurationChangeTest) {
+  UpdateDisplay("800x600");
+  int64_t display_id = display::Screen::GetScreen()->GetPrimaryDisplay().id();
+  display::DisplayManager* display_manager = Shell::Get()->display_manager();
+  display::test::ScopedSetInternalDisplayId set_internal(display_manager,
+                                                         display_id);
+  ScreenOrientationControllerTestApi test_api(
+      Shell::Get()->screen_orientation_controller());
+  // Set the screen orientation to LANDSCAPE_PRIMARY.
+  test_api.SetDisplayRotation(display::Display::ROTATE_0,
+                              display::Display::RotationSource::ACTIVE);
+  EXPECT_EQ(test_api.GetCurrentOrientation(),
+            OrientationLockType::kLandscapePrimary);
+
+  std::unique_ptr<aura::Window> window = CreateTestWindowWithWidget();
+  EXPECT_TRUE(wm::GetWindowState(window.get())->IsMaximized());
+
+  // Drag the window a small distance that will not drop the window into
+  // overview.
+  base::TimeTicks timestamp = base::TimeTicks::Now();
+  SendScrollStartAndUpdate(gfx::Point(0, 0), 10, timestamp, window.get());
+  OverviewController* overview_controller = Shell::Get()->overview_controller();
+  EXPECT_TRUE(overview_controller->IsSelecting());
+  EXPECT_TRUE(wm::GetWindowState(window.get())->is_dragged());
+
+  // Rotate the screen during drag.
+  test_api.SetDisplayRotation(display::Display::ROTATE_270,
+                              display::Display::RotationSource::ACTIVE);
+  EXPECT_EQ(test_api.GetCurrentOrientation(),
+            OrientationLockType::kPortraitPrimary);
+  EXPECT_TRUE(wm::GetWindowState(window.get())->IsMaximized());
+  EXPECT_FALSE(overview_controller->IsSelecting());
+  EXPECT_FALSE(wm::GetWindowState(window.get())->is_dragged());
+}
+
 // Tests the functionalities that fling the window when preview area is shown.
 TEST_F(SplitViewAppDraggingTest, FlingWhenPreviewAreaIsShown) {
-  InitializeWindow();
-  EXPECT_TRUE(wm::GetWindowState(window())->IsMaximized());
+  std::unique_ptr<aura::Window> window = CreateTestWindowWithWidget();
+  EXPECT_TRUE(wm::GetWindowState(window.get())->IsMaximized());
   gfx::Rect display_bounds =
       screen_util::GetDisplayWorkAreaBoundsInScreenForDefaultContainer(
-          window());
+          window.get());
 
   const float long_scroll_delta = display_bounds.height() / 4 + 5;
   float large_velocity =
@@ -4463,96 +3874,112 @@
   float small_velocity =
       TabletModeWindowDragDelegate::kFlingToOverviewFromSnappingAreaThreshold -
       10.f;
+  gfx::Point start;
+  base::TimeTicks timestamp = base::TimeTicks::Now();
 
   // Fling to the right with large enough velocity when trying to snap the
   // window to the left should drop the window to overview.
-  gfx::Point location(0, long_scroll_delta);
-  SendScrollStartAndUpdate(location);
+  SendScrollStartAndUpdate(start, long_scroll_delta, timestamp, window.get());
   EXPECT_EQ(IndicatorState::kPreviewAreaLeft, GetIndicatorState());
-  Fling(location, /*velocity_y*/ 0, /*velocity_x=*/large_velocity);
+  EndScrollSequence(start, long_scroll_delta, timestamp, window.get(),
+                    /*is_fling=*/true, /*velocity_y*/ 0,
+                    /*velocity_x=*/large_velocity);
   OverviewController* overview_controller = Shell::Get()->overview_controller();
   OverviewSession* overview_session = overview_controller->overview_session();
   EXPECT_TRUE(overview_controller->IsSelecting());
-  EXPECT_TRUE(overview_session->IsWindowInOverview(window()));
+  EXPECT_TRUE(overview_session->IsWindowInOverview(window.get()));
   ToggleOverview();
-  EXPECT_TRUE(wm::GetWindowState(window())->IsMaximized());
+  EXPECT_TRUE(wm::GetWindowState(window.get())->IsMaximized());
 
   // Fling to the right with small velocity when trying to snap the
   // window to the left should still snap the window to left.
-  SendScrollStartAndUpdate(location);
+  SendScrollStartAndUpdate(start, long_scroll_delta, timestamp, window.get());
   EXPECT_EQ(IndicatorState::kPreviewAreaLeft, GetIndicatorState());
-  Fling(location, /*velocity_y*/ 0, /*velocity_x=*/small_velocity);
-  EXPECT_TRUE(wm::GetWindowState(window())->IsSnapped());
+  EndScrollSequence(start, long_scroll_delta, timestamp, window.get(),
+                    /*is_fling=*/true, /*velocity_y*/ 0,
+                    /*velocity_x=*/small_velocity);
+  EXPECT_TRUE(wm::GetWindowState(window.get())->IsSnapped());
   EndSplitView();
-  EXPECT_TRUE(wm::GetWindowState(window())->IsMaximized());
+  EXPECT_TRUE(wm::GetWindowState(window.get())->IsMaximized());
 
   // Fling to the left with large enough velocity when trying to snap the window
   // to the right should drop the window to overvie.
-  location = gfx::Point(display_bounds.right(), long_scroll_delta);
-  SendScrollStartAndUpdate(location);
+  start = gfx::Point(display_bounds.right(), 0);
+  SendScrollStartAndUpdate(start, long_scroll_delta, timestamp, window.get());
   EXPECT_EQ(IndicatorState::kPreviewAreaRight, GetIndicatorState());
-  Fling(location, /*velocity_y*/ 0, /*velocity_x=*/-large_velocity);
+  EndScrollSequence(start, long_scroll_delta, timestamp, window.get(),
+                    /*is_fling=*/true, /*velocity_y*/ 0,
+                    /*velocity_x=*/-large_velocity);
   overview_session = overview_controller->overview_session();
   EXPECT_TRUE(overview_controller->IsSelecting());
-  EXPECT_TRUE(overview_session->IsWindowInOverview(window()));
+  EXPECT_TRUE(overview_session->IsWindowInOverview(window.get()));
   ToggleOverview();
 
   // Fling to the left with small velocity when trying to snap the
   // window to the right should still snap the window to right.
-  SendScrollStartAndUpdate(location);
+  SendScrollStartAndUpdate(start, long_scroll_delta, timestamp, window.get());
   EXPECT_EQ(IndicatorState::kPreviewAreaRight, GetIndicatorState());
-  Fling(location, /*velocity_y*/ 0, /*velocity_x=*/-small_velocity);
-  EXPECT_TRUE(wm::GetWindowState(window())->IsSnapped());
+  EndScrollSequence(start, long_scroll_delta, timestamp, window.get(),
+                    /*is_fling=*/true, /*velocity_y*/ 0,
+                    /*velocity_x=*/-small_velocity);
+  EXPECT_TRUE(wm::GetWindowState(window.get())->IsSnapped());
 }
 
 // Tests the functionalities that fling a window when splitview is active.
 TEST_F(SplitViewAppDraggingTest, FlingWhenSplitViewIsActive) {
-  InitializeWindow();
-  std::unique_ptr<aura::Window> window2 = CreateTestWindowWithWidget(true);
+  std::unique_ptr<aura::Window> window1 = CreateTestWindowWithWidget();
+  std::unique_ptr<aura::Window> window2 = CreateTestWindowWithWidget();
 
-  split_view_controller()->SnapWindow(window(), SplitViewController::LEFT);
+  split_view_controller()->SnapWindow(window1.get(), SplitViewController::LEFT);
   split_view_controller()->SnapWindow(window2.get(),
                                       SplitViewController::RIGHT);
 
   gfx::Rect display_bounds =
       screen_util::GetDisplayWorkAreaBoundsInScreenForDefaultContainer(
-          window());
+          window1.get());
   const float long_scroll_y = display_bounds.bottom() - 10;
   float large_velocity =
       TabletModeWindowDragDelegate::kFlingToOverviewFromSnappingAreaThreshold +
       10.f;
+  const gfx::Point start;
 
   // Fling the window in left snapping area to left should still snap the
   // window.
-  gfx::Point location(0, long_scroll_y);
-  SendScrollStartAndUpdate(location);
-  Fling(location, /*velocity_y=*/0, /*velocity_x=*/-large_velocity);
-  EXPECT_TRUE(wm::GetWindowState(window())->IsSnapped());
+  base::TimeTicks timestamp = base::TimeTicks::Now();
+  SendScrollStartAndUpdate(start, long_scroll_y, timestamp, window1.get());
+  EndScrollSequence(start, long_scroll_y, timestamp, window1.get(),
+                    /*is_fling=*/true, /*velocity_y=*/0,
+                    /*velocity_x=*/-large_velocity);
+  EXPECT_TRUE(wm::GetWindowState(window1.get())->IsSnapped());
   EXPECT_EQ(SplitViewController::BOTH_SNAPPED,
             split_view_controller()->state());
 
   // Fling the window in left snapping area to right should drop the window
   // into overview.
-  SendScrollStartAndUpdate(location);
-  Fling(location, /*velocity_y=*/0, /*velocity_x=*/large_velocity);
+  SendScrollStartAndUpdate(start, long_scroll_y, timestamp, window1.get());
+  EndScrollSequence(start, long_scroll_y, timestamp, window1.get(),
+                    /*is_fling=*/true, /*velocity_y=*/0,
+                    /*velocity_x=*/large_velocity);
   OverviewController* selector_controller = Shell::Get()->overview_controller();
-  EXPECT_TRUE(
-      selector_controller->overview_session()->IsWindowInOverview(window()));
+  EXPECT_TRUE(selector_controller->overview_session()->IsWindowInOverview(
+      window1.get()));
   EXPECT_EQ(SplitViewController::RIGHT_SNAPPED,
             split_view_controller()->state());
-  EXPECT_TRUE(IsTabletMode());
   ToggleOverview();
-  EXPECT_TRUE(IsTabletMode());
 
   // Fling the window in right snapping area to left should drop the window into
   // overview.
   EXPECT_EQ(SplitViewController::BOTH_SNAPPED,
             split_view_controller()->state());
-  location.set_x(display_bounds.CenterPoint().x() + 10);
-  SendScrollStartAndUpdate(location);
-  Fling(location, /*velocity_y=*/0, /*velocity_x=*/-large_velocity);
-  EXPECT_TRUE(
-      selector_controller->overview_session()->IsWindowInOverview(window()));
+  const int scroll_x = display_bounds.CenterPoint().x() + 10;
+  SendScrollStartAndUpdate(start, long_scroll_y, timestamp, window1.get(),
+                           scroll_x);
+  gfx::Point end(scroll_x, 0);
+  EndScrollSequence(end, long_scroll_y, timestamp, window1.get(),
+                    /*is_fling=*/true, /*velocity_y=*/0,
+                    /*velocity_x=*/-large_velocity);
+  EXPECT_TRUE(selector_controller->overview_session()->IsWindowInOverview(
+      window1.get()));
   EXPECT_EQ(SplitViewController::RIGHT_SNAPPED,
             split_view_controller()->state());
   ToggleOverview();
@@ -4561,60 +3988,16 @@
   // right side.
   EXPECT_EQ(SplitViewController::BOTH_SNAPPED,
             split_view_controller()->state());
-  SendScrollStartAndUpdate(location);
-  Fling(location, /*velocity_y=*/0, /*velocity_x=*/large_velocity);
-  EXPECT_EQ(split_view_controller()->right_window(), window());
+  SendScrollStartAndUpdate(start, long_scroll_y, timestamp, window1.get(),
+                           scroll_x);
+  EndScrollSequence(end, long_scroll_y, timestamp, window1.get(),
+                    /*is_fling=*/true, /*velocity_y=*/0,
+                    /*velocity_x=*/large_velocity);
+  EXPECT_EQ(split_view_controller()->right_window(), window1.get());
   EXPECT_TRUE(selector_controller->overview_session()->IsWindowInOverview(
       window2.get()));
   EXPECT_EQ(SplitViewController::RIGHT_SNAPPED,
             split_view_controller()->state());
 }
 
-// Tests the backdrop bounds during window drag.
-TEST_F(SplitViewAppDraggingTest, BackdropBoundsDuringDrag) {
-  InitializeWindow();
-  std::unique_ptr<aura::Window> window2 = CreateTestWindowWithWidget(true);
-  split_view_controller()->SnapWindow(window(), SplitViewController::LEFT);
-  split_view_controller()->SnapWindow(window2.get(),
-                                      SplitViewController::RIGHT);
-  EXPECT_EQ(window2.get(), wm::GetActiveWindow());
-
-  const aura::Window* default_container =
-      Shell::GetPrimaryRootWindowController()->GetContainer(
-          kShellWindowId_DefaultContainer);
-
-  // Backdrop window should below two snapped windows and its bounds should be
-  // the same as the container bounds.
-  EXPECT_EQ(3U, default_container->children().size());
-  EXPECT_EQ(window(), default_container->children()[1]);
-  EXPECT_EQ(window2.get(), default_container->children()[2]);
-  EXPECT_EQ(default_container->bounds(),
-            default_container->children()[0]->bounds());
-
-  // Start window drag and activate the dragged window during drag.
-  gfx::Point location(0, 10);
-  SendScrollStartAndUpdate(location);
-  wm::ActivateWindow(window());
-
-  aura::Window::Windows windows = default_container->children();
-  auto it = std::find(windows.begin(), windows.end(), window2.get());
-  // Backdrop window should be the window that just below the snapped |window2|
-  // and its bounds should be the same as the snapped window during drag.
-  aura::Window* backdrop_window = nullptr;
-  if (it != windows.begin())
-    backdrop_window = *(--it);
-  DCHECK(backdrop_window);
-  EXPECT_EQ(window2->bounds(), backdrop_window->bounds());
-
-  // Backdrop should restore back to container bounds after drag.
-  EndScrollSequence();
-  EXPECT_EQ(window(), wm::GetActiveWindow());
-  windows = default_container->children();
-  it = std::find(windows.begin(), windows.end(), window2.get());
-  if (it != windows.begin())
-    backdrop_window = *(--it);
-  DCHECK(backdrop_window);
-  EXPECT_EQ(backdrop_window->bounds(), default_container->bounds());
-}
-
 }  // namespace ash
--- a/ash/wm/splitview/split_view_divider.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/splitview/split_view_divider.cc	2019-05-17 18:53:08.376000000 +0300
@@ -23,7 +23,6 @@
 #include "ui/compositor/scoped_layer_animation_settings.h"
 #include "ui/gfx/animation/animation_delegate.h"
 #include "ui/gfx/animation/slide_animation.h"
-#include "ui/gfx/animation/tween.h"
 #include "ui/gfx/canvas.h"
 #include "ui/views/view.h"
 #include "ui/views/view_targeter_delegate.h"
@@ -55,7 +54,7 @@
 
 // The distance to the divider edge in which a touch gesture will be considered
 // as a valid event on the divider.
-constexpr int kDividerEdgeInsetForTouch = 8;
+constexpr int kDividerEdgeInsetForTouch = 5;
 
 // The window targeter that is installed on the always on top container window
 // when the split view mode is active.
@@ -126,7 +125,6 @@
     SetEventTargeter(
         std::unique_ptr<views::ViewTargeter>(new views::ViewTargeter(this)));
     white_bar_animation_.SetSlideDuration(kWhiteBarBoundsChangeDurationMs);
-    white_bar_animation_.SetTweenType(gfx::Tween::EASE_IN);
   }
   ~DividerView() override { white_bar_animation_.Stop(); }
 
--- a/ash/wm/splitview/split_view_drag_indicators.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/splitview/split_view_drag_indicators.cc	2019-05-17 18:53:08.376000000 +0300
@@ -298,10 +298,8 @@
                                                previous_indicator_state_);
     right_rotated_view_->OnIndicatorTypeChanged(indicator_state,
                                                 previous_indicator_state_);
-    left_highlight_view_->OnIndicatorTypeChanged(indicator_state,
-                                                 previous_indicator_state_);
-    right_highlight_view_->OnIndicatorTypeChanged(indicator_state,
-                                                  previous_indicator_state_);
+    left_highlight_view_->OnIndicatorTypeChanged(indicator_state);
+    right_highlight_view_->OnIndicatorTypeChanged(indicator_state);
 
     if (indicator_state != IndicatorState::kNone)
       Layout(previous_indicator_state_ != IndicatorState::kNone);
--- a/ash/wm/splitview/split_view_drag_indicators_unittest.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/splitview/split_view_drag_indicators_unittest.cc	2019-05-17 18:53:08.376000000 +0300
@@ -4,7 +4,6 @@
 
 #include "ash/wm/splitview/split_view_drag_indicators.h"
 
-#include "ash/public/cpp/presentation_time_recorder.h"
 #include "ash/shell.h"
 #include "ash/test/ash_test_base.h"
 #include "ash/wm/overview/overview_controller.h"
@@ -14,7 +13,6 @@
 #include "ash/wm/splitview/split_view_constants.h"
 #include "ash/wm/splitview/split_view_controller.h"
 #include "ash/wm/tablet_mode/tablet_mode_controller.h"
-#include "base/test/metrics/histogram_tester.h"
 #include "services/ws/public/mojom/window_tree_constants.mojom.h"
 #include "ui/aura/client/aura_constants.h"
 #include "ui/aura/env.h"
@@ -36,13 +34,6 @@
     base::RunLoop().RunUntilIdle();
     Shell::Get()->tablet_mode_controller()->EnableTabletModeWindowManager(true);
     base::RunLoop().RunUntilIdle();
-    ash::PresentationTimeRecorder::SetReportPresentationTimeImmediatelyForTest(
-        true);
-  }
-  void TearDown() override {
-    ash::PresentationTimeRecorder::SetReportPresentationTimeImmediatelyForTest(
-        false);
-    AshTestBase::TearDown();
   }
 
   void ToggleOverview() {
@@ -88,7 +79,7 @@
     return iter->get();
   }
 
-  float GetEdgeInset(int screen_width) const {
+  int GetEdgeInset(int screen_width) const {
     return screen_width * kHighlightScreenPrimaryAxisRatio +
            kHighlightScreenEdgePaddingDp;
   }
@@ -110,11 +101,10 @@
 };
 
 TEST_F(SplitViewDragIndicatorsTest, Dragging) {
-  base::HistogramTester histogram_tester;
   Shell::Get()->aura_env()->set_throttle_input_on_resize_for_testing(false);
   UpdateDisplay("800x600");
   const int screen_width = 800;
-  const float edge_inset = GetEdgeInset(screen_width);
+  const int edge_inset = GetEdgeInset(screen_width);
   std::unique_ptr<aura::Window> right_window(CreateTestWindow());
   std::unique_ptr<aura::Window> left_window(CreateTestWindow());
   ui::test::EventGenerator* generator = GetEventGenerator();
@@ -144,25 +134,14 @@
   // must move by |drag_offset| before split view acknowledges the drag (ie.
   // starts moving the selector item).
   generator->set_current_screen_location(
-      gfx::ToRoundedPoint(left_item->target_bounds().CenterPoint()));
+      left_item->target_bounds().CenterPoint());
   generator->PressLeftButton();
-  const gfx::RectF left_original_bounds = left_item->target_bounds();
+  const gfx::Rect left_original_bounds = left_item->target_bounds();
   generator->MoveMouseBy(drag_offset - 1, 0);
   EXPECT_EQ(left_original_bounds, left_item->target_bounds());
-  histogram_tester.ExpectTotalCount(
-      "Ash.Overview.WindowDrag.PresentationTime.TabletMode", 0);
   generator->MoveMouseBy(1, 0);
   EXPECT_NE(left_original_bounds, left_item->target_bounds());
-  histogram_tester.ExpectTotalCount(
-      "Ash.Overview.WindowDrag.PresentationTime.TabletMode", 1);
-  histogram_tester.ExpectTotalCount(
-      "ash.overview.windowdrag.presentationtime.maxlatency.tabletmode", 0);
-
   generator->ReleaseLeftButton();
-  histogram_tester.ExpectTotalCount(
-      "Ash.Overview.WindowDrag.PresentationTime.TabletMode", 1);
-  histogram_tester.ExpectTotalCount(
-      "Ash.Overview.WindowDrag.PresentationTime.MaxLatency.TabletMode", 1);
 
   // Verify if the drag is started in the left snap region, the drag needs to
   // move by |drag_offset_snap_region| towards the right side of the screen
@@ -171,27 +150,16 @@
   generator->set_current_screen_location(
       gfx::Point(left_item->target_bounds().origin().x() + item_inset,
                  left_item->target_bounds().CenterPoint().y()));
-
   generator->PressLeftButton();
   generator->MoveMouseBy(-drag_offset, 0);
   EXPECT_FALSE(IsPreviewAreaShowing());
   generator->MoveMouseBy(drag_offset_snap_region, 0);
-  EXPECT_FALSE(IsPreviewAreaShowing());
   generator->MoveMouseBy(-minimum_drag_offset, 0);
   EXPECT_TRUE(IsPreviewAreaShowing());
-
   // Drag back to the middle before releasing so that we stay in overview mode
   // on release.
-  generator->MoveMouseTo(
-      gfx::ToRoundedPoint(left_original_bounds.CenterPoint()));
-  histogram_tester.ExpectTotalCount(
-      "Ash.Overview.WindowDrag.PresentationTime.TabletMode", 5);
-  histogram_tester.ExpectTotalCount(
-      "Ash.Overview.WindowDrag.PresentationTime.MaxLatency.TabletMode", 1);
-
+  generator->MoveMouseTo(left_original_bounds.CenterPoint());
   generator->ReleaseLeftButton();
-  histogram_tester.ExpectTotalCount(
-      "Ash.Overview.WindowDrag.PresentationTime.MaxLatency.TabletMode", 2);
 
   // Verify if the drag is started in the right snap region, the drag needs to
   // move by |drag_offset_snap_region| towards the left side of the screen
@@ -206,23 +174,13 @@
   generator->MoveMouseBy(-drag_offset_snap_region, 0);
   generator->MoveMouseBy(minimum_drag_offset, 0);
   EXPECT_TRUE(IsPreviewAreaShowing());
-  histogram_tester.ExpectTotalCount(
-      "Ash.Overview.WindowDrag.PresentationTime.TabletMode", 8);
-  histogram_tester.ExpectTotalCount(
-      "Ash.Overview.WindowDrag.PresentationTime.MaxLatency.TabletMode", 2);
-
-  generator->ReleaseLeftButton();
-  histogram_tester.ExpectTotalCount(
-      "Ash.Overview.WindowDrag.PresentationTime.TabletMode", 8);
-  histogram_tester.ExpectTotalCount(
-      "Ash.Overview.WindowDrag.PresentationTime.MaxLatency.TabletMode", 3);
 }
 
 // Verify the split view preview area becomes visible when expected.
 TEST_F(SplitViewDragIndicatorsTest, PreviewAreaVisibility) {
   UpdateDisplay("800x600");
   const int screen_width = 800;
-  const float edge_inset = GetEdgeInset(screen_width);
+  const int edge_inset = GetEdgeInset(screen_width);
   std::unique_ptr<aura::Window> window(CreateTestWindow());
   ToggleOverview();
 
@@ -230,19 +188,19 @@
   // range [0, edge_inset] or [screen_width - edge_inset - 1, screen_width].
   OverviewItem* item = GetOverviewItemForWindow(window.get());
   ASSERT_TRUE(item);
-  const gfx::PointF start_location(item->target_bounds().CenterPoint());
+  const gfx::Point start_location(item->target_bounds().CenterPoint());
   // Drag horizontally to avoid activating drag to close.
-  const float y = start_location.y();
+  const int y = start_location.y();
   overview_session_->InitiateDrag(item, start_location);
   EXPECT_FALSE(IsPreviewAreaShowing());
-  overview_session_->Drag(item, gfx::PointF(edge_inset + 1, y));
+  overview_session_->Drag(item, gfx::Point(edge_inset + 1, y));
   EXPECT_FALSE(IsPreviewAreaShowing());
-  overview_session_->Drag(item, gfx::PointF(edge_inset, y));
+  overview_session_->Drag(item, gfx::Point(edge_inset, y));
   EXPECT_TRUE(IsPreviewAreaShowing());
 
-  overview_session_->Drag(item, gfx::PointF(screen_width - edge_inset - 2, y));
+  overview_session_->Drag(item, gfx::Point(screen_width - edge_inset - 2, y));
   EXPECT_FALSE(IsPreviewAreaShowing());
-  overview_session_->Drag(item, gfx::PointF(screen_width - edge_inset - 1, y));
+  overview_session_->Drag(item, gfx::Point(screen_width - edge_inset - 1, y));
   EXPECT_TRUE(IsPreviewAreaShowing());
 
   // Drag back to |start_location| before compeleting the drag, otherwise
@@ -262,12 +220,12 @@
   ToggleOverview();
 
   OverviewItem* item = GetOverviewItemForWindow(window.get());
-  const gfx::PointF start_location(item->target_bounds().CenterPoint());
+  const gfx::Point start_location(item->target_bounds().CenterPoint());
   overview_session_->InitiateDrag(item, start_location);
   EXPECT_FALSE(IsPreviewAreaShowing());
-  overview_session_->Drag(item, gfx::PointF(0.f, 1.f));
+  overview_session_->Drag(item, gfx::Point(0, 1));
   EXPECT_FALSE(IsPreviewAreaShowing());
-  overview_session_->Drag(item, gfx::PointF(screen_width, 1.f));
+  overview_session_->Drag(item, gfx::Point(screen_width, 1));
   EXPECT_FALSE(IsPreviewAreaShowing());
 
   overview_session_->CompleteDrag(item, start_location);
@@ -278,7 +236,7 @@
 TEST_F(SplitViewDragIndicatorsTest, SplitViewDragIndicatorsState) {
   UpdateDisplay("800x600");
   const int screen_width = 800;
-  const float edge_inset = GetEdgeInset(screen_width);
+  const int edge_inset = GetEdgeInset(screen_width);
   std::unique_ptr<aura::Window> window1(CreateTestWindow());
   std::unique_ptr<aura::Window> window2(CreateTestWindow());
   ToggleOverview();
@@ -286,7 +244,7 @@
   // Verify that when are no snapped windows, the indicator is visible once
   // there is a long press or after the drag has started.
   OverviewItem* item = GetOverviewItemForWindow(window1.get());
-  gfx::PointF start_location(item->target_bounds().CenterPoint());
+  gfx::Point start_location(item->target_bounds().CenterPoint());
   overview_session_->InitiateDrag(item, start_location);
   EXPECT_EQ(IndicatorState::kNone, indicator_state());
   overview_session_->StartSplitViewDragMode(start_location);
@@ -298,16 +256,16 @@
   // Verify the indicator is visible once the item starts moving, and becomes a
   // preview area once we reach the left edge of the screen. Drag horizontal to
   // avoid activating drag to close.
-  const float y_position = start_location.y();
+  const int y_position = start_location.y();
   overview_session_->InitiateDrag(item, start_location);
   EXPECT_EQ(IndicatorState::kNone, indicator_state());
-  overview_session_->Drag(item, gfx::PointF(edge_inset + 1, y_position));
+  overview_session_->Drag(item, gfx::Point(edge_inset + 1, y_position));
   EXPECT_EQ(IndicatorState::kDragArea, indicator_state());
-  overview_session_->Drag(item, gfx::PointF(edge_inset, y_position));
+  overview_session_->Drag(item, gfx::Point(edge_inset, y_position));
   EXPECT_EQ(IndicatorState::kPreviewAreaLeft, indicator_state());
 
   // Snap window to the left.
-  overview_session_->CompleteDrag(item, gfx::PointF(edge_inset, y_position));
+  overview_session_->CompleteDrag(item, gfx::Point(edge_inset, y_position));
   ASSERT_TRUE(split_view_controller()->IsSplitViewModeActive());
   ASSERT_EQ(SplitViewController::LEFT_SNAPPED,
             split_view_controller()->state());
@@ -318,7 +276,7 @@
   start_location = item->target_bounds().CenterPoint();
   overview_session_->InitiateDrag(item, start_location);
   EXPECT_EQ(IndicatorState::kNone, indicator_state());
-  overview_session_->Drag(item, gfx::PointF(screen_width - 1, y_position));
+  overview_session_->Drag(item, gfx::Point(screen_width - 1, y_position));
   EXPECT_EQ(IndicatorState::kPreviewAreaRight, indicator_state());
   overview_session_->CompleteDrag(item, start_location);
 }
@@ -331,11 +289,11 @@
   ToggleOverview();
 
   OverviewItem* item = GetOverviewItemForWindow(unsnappable_window.get());
-  gfx::PointF start_location(item->target_bounds().CenterPoint());
+  gfx::Point start_location(item->target_bounds().CenterPoint());
   overview_session_->InitiateDrag(item, start_location);
   overview_session_->StartSplitViewDragMode(start_location);
   EXPECT_EQ(IndicatorState::kCannotSnap, indicator_state());
-  const gfx::PointF end_location1(0.f, 0.f);
+  const gfx::Point end_location1(0, 0);
   overview_session_->Drag(item, end_location1);
   EXPECT_EQ(IndicatorState::kCannotSnap, indicator_state());
   overview_session_->CompleteDrag(item, end_location1);
@@ -409,28 +367,26 @@
   // Select an item on the primary display and verify the drag indicators
   // widget's parent is the primary root window.
   OverviewItem* item = GetOverviewItemForWindow(primary_screen_window.get());
-  gfx::PointF start_location(item->target_bounds().CenterPoint());
+  gfx::Point start_location(item->target_bounds().CenterPoint());
   overview_session_->InitiateDrag(item, start_location);
-  overview_session_->Drag(item, gfx::PointF(100.f, start_location.y()));
+  overview_session_->Drag(item, gfx::Point(100, start_location.y()));
   EXPECT_EQ(IndicatorState::kDragArea, indicator_state());
   EXPECT_EQ(root_windows[0], overview_session_->split_view_drag_indicators()
                                  ->widget_->GetNativeView()
                                  ->GetRootWindow());
   // Drag the item in a way that neither opens the window nor activates
   // splitview mode.
-  overview_session_->Drag(item,
-                          gfx::PointF(primary_screen_bounds.CenterPoint()));
-  overview_session_->CompleteDrag(
-      item, gfx::PointF(primary_screen_bounds.CenterPoint()));
+  overview_session_->Drag(item, primary_screen_bounds.CenterPoint());
+  overview_session_->CompleteDrag(item, primary_screen_bounds.CenterPoint());
   ASSERT_TRUE(Shell::Get()->overview_controller()->IsSelecting());
   ASSERT_FALSE(split_view_controller()->IsSplitViewModeActive());
 
   // Select an item on the secondary display and verify the indicators widget
   // has reparented to the secondary root window.
   item = GetOverviewItemForWindow(secondary_screen_window.get(), 1);
-  start_location = item->target_bounds().CenterPoint();
+  start_location = gfx::Point(item->target_bounds().CenterPoint());
   overview_session_->InitiateDrag(item, start_location);
-  overview_session_->Drag(item, gfx::PointF(800.f, start_location.y()));
+  overview_session_->Drag(item, gfx::Point(800, start_location.y()));
   EXPECT_EQ(IndicatorState::kDragArea, indicator_state());
   EXPECT_EQ(root_windows[1], overview_session_->split_view_drag_indicators()
                                  ->widget_->GetNativeView()
--- a/ash/wm/splitview/split_view_highlight_view.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/splitview/split_view_highlight_view.cc	2019-05-17 18:53:08.376000000 +0300
@@ -171,45 +171,21 @@
 }
 
 void SplitViewHighlightView::OnIndicatorTypeChanged(
-    IndicatorState indicator_state,
-    IndicatorState previous_indicator_state) {
+    IndicatorState indicator_state) {
   if (indicator_state == IndicatorState::kNone) {
-    if (!SplitViewDragIndicators::IsPreviewAreaState(
-            previous_indicator_state)) {
       DoSplitviewOpacityAnimation(layer(),
                                   SPLITVIEW_ANIMATION_HIGHLIGHT_FADE_OUT);
       return;
     }
 
-    // There are two SplitViewHighlightView objects,
-    // |SplitViewDragIndicatorsView::left_highlight_view_| and
-    // |SplitViewDragIndicatorsView::right_highlight_view_|.
-    // |was_this_the_preview| indicates that this (in the sense of the keyword
-    // this) is the one that represented the preview area.
-    const bool was_this_the_preview =
-        is_right_or_bottom_ !=
-        SplitViewDragIndicators::IsPreviewAreaOnLeftTopOfScreen(
-            previous_indicator_state);
-    if (was_this_the_preview) {
-      DoSplitviewOpacityAnimation(layer(),
-                                  SPLITVIEW_ANIMATION_PREVIEW_AREA_FADE_OUT);
-    }
-    return;
-  }
-
   if (SplitViewDragIndicators::IsPreviewAreaState(indicator_state)) {
-    // There are two SplitViewHighlightView objects,
-    // |SplitViewDragIndicatorsView::left_highlight_view_| and
-    // |SplitViewDragIndicatorsView::right_highlight_view_|.
-    // |is_this_the_preview| indicates that this (in the sense of the keyword
-    // this) is the one that represents the preview area.
-    const bool is_this_the_preview =
-        is_right_or_bottom_ !=
+    const bool is_preview_on_left_or_top =
         SplitViewDragIndicators::IsPreviewAreaOnLeftTopOfScreen(
             indicator_state);
+    const bool should_fade_in = is_right_or_bottom_ ? !is_preview_on_left_or_top
+                                                    : is_preview_on_left_or_top;
     DoSplitviewOpacityAnimation(
-        layer(), is_this_the_preview
-                     ? SPLITVIEW_ANIMATION_PREVIEW_AREA_FADE_IN
+        layer(), should_fade_in ? SPLITVIEW_ANIMATION_PREVIEW_AREA_FADE_IN
                      : SPLITVIEW_ANIMATION_OTHER_HIGHLIGHT_FADE_OUT);
     return;
   }
--- a/ash/wm/splitview/split_view_highlight_view.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/splitview/split_view_highlight_view.h	2019-05-17 18:53:08.376000000 +0300
@@ -31,10 +31,8 @@
 
   void SetColor(SkColor color);
 
-  // Called to update the opacity of the highlights view on transition from
-  // |previous_indicator_state| to |indicator_state|.
-  void OnIndicatorTypeChanged(IndicatorState indicator_state,
-                              IndicatorState previous_indicator_state);
+  // Called to update the opacity of the highlights view on |indicator_state|.
+  void OnIndicatorTypeChanged(IndicatorState indicator_state);
 
  private:
   friend class SplitViewHighlightViewTestApi;
--- a/ash/wm/splitview/split_view_highlight_view_unittest.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/splitview/split_view_highlight_view_unittest.cc	2019-05-17 18:53:08.376000000 +0300
@@ -163,7 +163,7 @@
                   .ApproximatelyEqual(expected_end_transform));
 }
 
-INSTANTIATE_TEST_SUITE_P(Bounds,
+INSTANTIATE_TEST_CASE_P(Bounds,
                          SplitViewHighlightViewPortraitTest,
                          testing::Bool());
 
--- a/ash/wm/splitview/split_view_utils.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/splitview/split_view_utils.cc	2019-05-17 18:53:08.376000000 +0300
@@ -42,8 +42,6 @@
 // The time duration for the window transformation animations.
 constexpr base::TimeDelta kWindowTransformMs =
     base::TimeDelta::FromMilliseconds(250);
-constexpr base::TimeDelta kPreviewAreaFadeOutMs =
-    base::TimeDelta::FromMilliseconds(67);
 
 constexpr float kHighlightOpacity = 0.3f;
 constexpr float kPreviewAreaHighlightOpacity = 0.18f;
@@ -60,29 +58,29 @@
     case SPLITVIEW_ANIMATION_HIGHLIGHT_FADE_IN:
     case SPLITVIEW_ANIMATION_HIGHLIGHT_FADE_OUT:
     case SPLITVIEW_ANIMATION_PREVIEW_AREA_FADE_IN:
-    case SPLITVIEW_ANIMATION_OVERVIEW_ITEM_FADE_IN:
-    case SPLITVIEW_ANIMATION_OVERVIEW_ITEM_FADE_OUT:
+    case SPLITVIEW_ANIMATION_PREVIEW_AREA_FADE_OUT:
+    case SPLITVIEW_ANIMATION_SELECTOR_ITEM_FADE_IN:
+    case SPLITVIEW_ANIMATION_SELECTOR_ITEM_FADE_OUT:
     case SPLITVIEW_ANIMATION_TEXT_FADE_IN_WITH_HIGHLIGHT:
     case SPLITVIEW_ANIMATION_TEXT_FADE_OUT_WITH_HIGHLIGHT:
     case SPLITVIEW_ANIMATION_PREVIEW_AREA_SLIDE_IN_OUT:
       *out_duration = kHighlightsFadeInOutMs;
       *out_tween_type = gfx::Tween::FAST_OUT_SLOW_IN;
       return;
+    case SPLITVIEW_ANIMATION_OTHER_HIGHLIGHT_FADE_IN:
     case SPLITVIEW_ANIMATION_OTHER_HIGHLIGHT_SLIDE_IN:
       *out_duration = kOtherFadeInOutMs;
       *out_tween_type = gfx::Tween::LINEAR_OUT_SLOW_IN;
       return;
     case SPLITVIEW_ANIMATION_TEXT_FADE_IN:
+    case SPLITVIEW_ANIMATION_TEXT_FADE_OUT:
     case SPLITVIEW_ANIMATION_TEXT_SLIDE_IN:
+    case SPLITVIEW_ANIMATION_TEXT_SLIDE_OUT:
+      if (type == SPLITVIEW_ANIMATION_TEXT_SLIDE_IN)
       *out_delay = kLabelAnimationDelayMs;
       *out_duration = kLabelAnimationMs;
       *out_tween_type = gfx::Tween::LINEAR_OUT_SLOW_IN;
       return;
-    case SPLITVIEW_ANIMATION_TEXT_FADE_OUT:
-    case SPLITVIEW_ANIMATION_TEXT_SLIDE_OUT:
-      *out_duration = kLabelAnimationMs;
-      *out_tween_type = gfx::Tween::FAST_OUT_LINEAR_IN;
-      return;
     case SPLITVIEW_ANIMATION_OTHER_HIGHLIGHT_FADE_OUT:
     case SPLITVIEW_ANIMATION_OTHER_HIGHLIGHT_SLIDE_OUT:
       *out_delay = kOtherFadeOutDelayMs;
@@ -95,10 +93,6 @@
       *out_preemption_strategy =
           ui::LayerAnimator::IMMEDIATELY_ANIMATE_TO_NEW_TARGET;
       return;
-    case SPLITVIEW_ANIMATION_PREVIEW_AREA_FADE_OUT:
-      *out_duration = kPreviewAreaFadeOutMs;
-      *out_tween_type = gfx::Tween::FAST_OUT_LINEAR_IN;
-      return;
   }
 
   NOTREACHED();
@@ -133,19 +127,20 @@
   switch (type) {
     case SPLITVIEW_ANIMATION_HIGHLIGHT_FADE_OUT:
     case SPLITVIEW_ANIMATION_OTHER_HIGHLIGHT_FADE_OUT:
-    case SPLITVIEW_ANIMATION_PREVIEW_AREA_FADE_OUT:
-    case SPLITVIEW_ANIMATION_OVERVIEW_ITEM_FADE_OUT:
+    case SPLITVIEW_ANIMATION_SELECTOR_ITEM_FADE_OUT:
     case SPLITVIEW_ANIMATION_TEXT_FADE_OUT:
     case SPLITVIEW_ANIMATION_TEXT_FADE_OUT_WITH_HIGHLIGHT:
       target_opacity = 0.f;
       break;
+    case SPLITVIEW_ANIMATION_HIGHLIGHT_FADE_IN:
+    case SPLITVIEW_ANIMATION_OTHER_HIGHLIGHT_FADE_IN:
     case SPLITVIEW_ANIMATION_PREVIEW_AREA_FADE_IN:
       target_opacity = kPreviewAreaHighlightOpacity;
       break;
-    case SPLITVIEW_ANIMATION_HIGHLIGHT_FADE_IN:
+    case SPLITVIEW_ANIMATION_PREVIEW_AREA_FADE_OUT:
       target_opacity = kHighlightOpacity;
       break;
-    case SPLITVIEW_ANIMATION_OVERVIEW_ITEM_FADE_IN:
+    case SPLITVIEW_ANIMATION_SELECTOR_ITEM_FADE_IN:
     case SPLITVIEW_ANIMATION_TEXT_FADE_IN:
     case SPLITVIEW_ANIMATION_TEXT_FADE_IN_WITH_HIGHLIGHT:
       target_opacity = 1.f;
--- a/ash/wm/splitview/split_view_utils.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/splitview/split_view_utils.h	2019-05-17 18:53:08.376000000 +0300
@@ -27,22 +27,24 @@
   // to drag a selector item.
   SPLITVIEW_ANIMATION_HIGHLIGHT_FADE_IN,
   SPLITVIEW_ANIMATION_HIGHLIGHT_FADE_OUT,
-  // Used to fade out the other highlight. There are normally two highlights,
-  // one on each side. When entering a state with a preview highlight, one
-  // highlight is the preview highlight, and the other highlight is the other
-  // highlight.
+  // Used to fade in and out the other highlight. There are normally two
+  // highlights, one on each side. When entering a state with a preview
+  // highlight, one highlight is the preview highlight, and the other highlight
+  // is the other highlight.
+  SPLITVIEW_ANIMATION_OTHER_HIGHLIGHT_FADE_IN,
   SPLITVIEW_ANIMATION_OTHER_HIGHLIGHT_FADE_OUT,
-  // Used to fade in and out the preview area highlight which indicates the
-  // bounds of the window that is about to get snapped.
+  // Used to fade in and out the preview area highlight which indicate the
+  // bounds of
+  // the window that is about to get snapped.
   SPLITVIEW_ANIMATION_PREVIEW_AREA_FADE_IN,
   SPLITVIEW_ANIMATION_PREVIEW_AREA_FADE_OUT,
-  // Used to fade in and out the label on the overview item which warns users
-  // the item cannot be snapped. The label appears on the overview item after
+  // Used to fade in and out the label on the selector item which warns users
+  // the item cannot be snapped. The label appears on the selector item after
   // another window has been snapped.
-  SPLITVIEW_ANIMATION_OVERVIEW_ITEM_FADE_IN,
-  SPLITVIEW_ANIMATION_OVERVIEW_ITEM_FADE_OUT,
+  SPLITVIEW_ANIMATION_SELECTOR_ITEM_FADE_IN,
+  SPLITVIEW_ANIMATION_SELECTOR_ITEM_FADE_OUT,
   // Used to fade in and out the labels which appear on either side of overview
-  // mode when a overview item is selected. They indicate where to drag the
+  // mode when a selector item is selected. They indicate where to drag the
   // selector item if it is snappable, or if an item cannot be snapped.
   SPLITVIEW_ANIMATION_TEXT_FADE_IN,
   SPLITVIEW_ANIMATION_TEXT_FADE_OUT,
--- a/ash/wm/system_gesture_event_filter_unittest.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/system_gesture_event_filter_unittest.cc	2019-05-17 18:53:08.376000000 +0300
@@ -60,12 +60,12 @@
 
  private:
   gfx::Size GetMaximumSize() const override { return gfx::Size(200, 200); }
-  gfx::Rect GetBoundsForClientView() const override { return gfx::Rect(); }
+  gfx::Rect GetBoundsForClientView() const override { return gfx::Rect(); };
 
   gfx::Rect GetWindowBoundsForClientBounds(
       const gfx::Rect& client_bounds) const override {
     return gfx::Rect();
-  }
+  };
 
   // This function must ask the ClientView to do a hittest.  We don't do this in
   // the parent NonClientView because that makes it more difficult to calculate
--- a/ash/wm/tablet_mode/tablet_mode_browser_window_drag_delegate.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/tablet_mode/tablet_mode_browser_window_drag_delegate.cc	2019-05-17 18:53:08.380000000 +0300
@@ -17,6 +17,7 @@
 #include "ash/wm/overview/overview_grid.h"
 #include "ash/wm/overview/overview_utils.h"
 #include "ash/wm/splitview/split_view_constants.h"
+#include "ash/wm/tablet_mode/tablet_mode_browser_window_drag_controller.h"
 #include "ash/wm/tablet_mode/tablet_mode_window_state.h"
 #include "ash/wm/window_util.h"
 #include "ui/aura/window.h"
@@ -158,7 +159,7 @@
     shield_widget_ = CreateBackgroundWidget(
         root_window, ui::LAYER_SOLID_COLOR, SK_ColorTRANSPARENT, 0, 0,
         SK_ColorTRANSPARENT, /*initial_opacity*/ 1.f, /*parent=*/nullptr,
-        /*stack_on_top=*/true, /*accept_events=*/false);
+        /*stack_on_top=*/true);
     aura::Window* widget_window = shield_widget_->GetNativeWindow();
     const gfx::Rect bounds = widget_window->parent()->bounds();
     widget_window->SetBounds(bounds);
@@ -305,7 +306,8 @@
   aura::Window* source_window =
       dragged_window_->GetProperty(ash::kTabDraggingSourceWindowKey);
   if (!source_window || source_window == dragged_window_ ||
-      split_view_controller_->IsWindowInSplitView(source_window) ||
+      source_window == split_view_controller_->left_window() ||
+      source_window == split_view_controller_->right_window() ||
       source_window->GetProperty(ash::kIsShowingInOverviewKey)) {
     return;
   }
--- a/ash/wm/tablet_mode/tablet_mode_browser_window_drag_delegate.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/tablet_mode/tablet_mode_browser_window_drag_delegate.h	2019-05-17 18:53:08.380000000 +0300
@@ -5,7 +5,6 @@
 #ifndef ASH_WM_TABLET_MODE_TABLET_MODE_BROWSER_WINDOW_DRAG_DELEGATE_H_
 #define ASH_WM_TABLET_MODE_TABLET_MODE_BROWSER_WINDOW_DRAG_DELEGATE_H_
 
-#include "ash/ash_export.h"
 #include "ash/wm/tablet_mode/tablet_mode_window_drag_delegate.h"
 #include "base/macros.h"
 
@@ -15,7 +14,7 @@
 // TabletModeWindowDragDelegate, but also has special logic for browser windows,
 // e.g., scales the source window, shows/hides the other windows below the
 // source window.
-class ASH_EXPORT TabletModeBrowserWindowDragDelegate
+class TabletModeBrowserWindowDragDelegate
     : public TabletModeWindowDragDelegate {
  public:
   TabletModeBrowserWindowDragDelegate();
--- a/ash/wm/tablet_mode/tablet_mode_controller.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/tablet_mode/tablet_mode_controller.cc	2019-05-17 18:53:08.380000000 +0300
@@ -4,8 +4,6 @@
 
 #include "ash/wm/tablet_mode/tablet_mode_controller.h"
 
-#include <algorithm>
-#include <string>
 #include <utility>
 
 #include "ash/public/cpp/ash_switches.h"
@@ -25,7 +23,7 @@
 #include "base/metrics/user_metrics.h"
 #include "base/time/default_tick_clock.h"
 #include "base/time/tick_clock.h"
-#include "chromeos/dbus/power_manager_client.h"
+#include "chromeos/dbus/dbus_thread_manager.h"
 #include "ui/base/accelerators/accelerator.h"
 #include "ui/display/display.h"
 #include "ui/display/manager/display_manager.h"
@@ -83,11 +81,6 @@
 constexpr base::TimeDelta kRecordLidAngleInterval =
     base::TimeDelta::FromHours(1);
 
-// Time that should wait to reset |occlusion_tracker_pauser_| on
-// entering/exiting tablet mode.
-constexpr base::TimeDelta kOcclusionTrackerTimeout =
-    base::TimeDelta::FromMilliseconds(500);
-
 // The angle between AccelerometerReadings are considered stable if
 // their magnitudes do not differ greatly. This returns false if the deviation
 // between the screen and keyboard accelerometers is too high.
@@ -155,7 +148,7 @@
             base::Unretained(this)));
   }
   chromeos::PowerManagerClient* power_manager_client =
-      chromeos::PowerManagerClient::Get();
+      chromeos::DBusThreadManager::Get()->GetPowerManagerClient();
   power_manager_client->AddObserver(this);
   power_manager_client->GetSwitchStates(base::BindOnce(
       &TabletModeController::OnGetSwitchStates, weak_factory_.GetWeakPtr()));
@@ -166,23 +159,15 @@
 }
 
 TabletModeController::~TabletModeController() {
-  UMA_HISTOGRAM_COUNTS_1000("Tablet.AppWindowDrag.CountOfPerUserSession",
-                            app_window_drag_count_);
-  UMA_HISTOGRAM_COUNTS_1000(
-      "Tablet.AppWindowDrag.InSplitView.CountOfPerUserSession",
-      app_window_drag_in_splitview_count_);
-  UMA_HISTOGRAM_COUNTS_1000("Tablet.TabDrag.CountOfPerUserSession",
-                            tab_drag_count_);
-  UMA_HISTOGRAM_COUNTS_1000("Tablet.TabDrag.InSplitView.CountOfPerUserSession",
-                            tab_drag_in_splitview_count_);
-
   Shell::Get()->RemoveShellObserver(this);
+
   if (IsEnabled()) {
     Shell::Get()->window_tree_host_manager()->RemoveObserver(this);
     AccelerometerReader::GetInstance()->RemoveObserver(this);
     ui::InputDeviceManager::GetInstance()->RemoveObserver(this);
   }
-  chromeos::PowerManagerClient::Get()->RemoveObserver(this);
+  chromeos::DBusThreadManager::Get()->GetPowerManagerClient()->RemoveObserver(
+      this);
 
   for (auto& observer : tablet_mode_observers_)
     observer.OnTabletControllerDestroyed();
@@ -204,9 +189,6 @@
     RootWindowController::ForWindow(root_window)->HideContextMenu();
 
   if (should_enable) {
-    // Suspend occlusion tracker when entering tablet mode.
-    SuspendOcclusionTracker();
-
     tablet_mode_window_manager_.reset(new TabletModeWindowManager());
     base::RecordAction(base::UserMetricsAction("Touchview_Enabled"));
     RecordTabletModeUsageInterval(TABLET_MODE_INTERVAL_INACTIVE);
@@ -228,9 +210,6 @@
       client_->OnTabletModeToggled(true);
     VLOG(1) << "Enter tablet mode.";
   } else {
-    // Suspend occlusion tracker when exiting tablet mode.
-    SuspendOcclusionTracker();
-
     tablet_mode_window_manager_->SetIgnoreWmEventsForExit();
     for (auto& observer : tablet_mode_observers_)
       observer.OnTabletModeEnding();
@@ -304,9 +283,6 @@
 }
 
 void TabletModeController::OnDisplayConfigurationChanged() {
-  if (!AllowUiModeChange())
-    return;
-
   if (!HasActiveInternalDisplay()) {
     AttemptLeaveTabletMode();
   } else if (tablet_mode_switch_is_on_ && !IsTabletModeWindowManagerEnabled()) {
@@ -601,21 +577,6 @@
   client_->OnTabletModeToggled(IsTabletModeWindowManagerEnabled());
 }
 
-// Used for testing. Called via Mojo.
-void TabletModeController::SetTabletModeEnabledForTesting(
-    bool enabled,
-    SetTabletModeEnabledForTestingCallback callback) {
-  // Disable Accelerometer and PowerManagerClient observers to prevent possible
-  // tablet mode overrides. It won't be possible to physically switch to/from
-  // tablet mode after calling this function. This is needed for tests that
-  // run on DUTs and require switching to/back tablet mode in runtime, like some
-  // ARC++ Tast tests.
-  AccelerometerReader::GetInstance()->RemoveObserver(this);
-  chromeos::PowerManagerClient::Get()->RemoveObserver(this);
-  EnableTabletModeWindowManager(enabled);
-  std::move(callback).Run(IsTabletModeWindowManagerEnabled());
-}
-
 bool TabletModeController::AllowUiModeChange() const {
   return force_ui_mode_ == UiMode::kNone;
 }
@@ -657,14 +618,13 @@
   // Enter clamshell mode whenever an external pointing device is attached.
   if (has_external_pointing_device) {
     AttemptLeaveTabletMode();
-  } else if (HasActiveInternalDisplay() &&
-             (LidAngleIsInTabletModeRange() || tablet_mode_switch_is_on_)) {
-    // If there is no external pointing device, only enter tablet mode if docked
-    // mode is inactive and 1) the lid angle can be detected and is in tablet
-    // mode angle range. or 2) if the lid angle can't be detected (e.g., tablet
-    // device or clamshell device) and |tablet_mode_switch_is_on_| is true (it
-    // can only happen for tablet device as |tablet_mode_switch_is_on_| should
-    // never be true for a clamshell device).
+  } else if (LidAngleIsInTabletModeRange() || tablet_mode_switch_is_on_) {
+    // If there is no external pointing device, only enter tablet mode if 1) the
+    // lid angle can be detected and is in tablet mode angle range. or 2) if the
+    // lid angle can't be detected (e.g., tablet device or clamshell device) and
+    // |tablet_mode_switch_is_on_| is true (it can only happen for tablet device
+    // as |tablet_mode_switch_is_on_| should never be true for a clamshell
+    // device).
     AttemptEnterTabletMode();
   }
 }
@@ -690,7 +650,7 @@
   if (IsTabletModeWindowManagerEnabled()) {
     // If we are currently in tablet mode, the internal input events should
     // always be blocked.
-    should_block_internal_events = (force_ui_mode_ == UiMode::kNone);
+    should_block_internal_events = true;
   } else if (HasActiveInternalDisplay() &&
              (LidAngleIsInTabletModeRange() || tablet_mode_switch_is_on_)) {
     // If we are currently in clamshell mode, the intenral input events should
@@ -715,18 +675,4 @@
          lid_angle_ >= kEnterTabletModeAngle;
 }
 
-void TabletModeController::SuspendOcclusionTracker() {
-  occlusion_tracker_reset_timer_.Stop();
-  occlusion_tracker_pauser_ =
-      std::make_unique<aura::WindowOcclusionTracker::ScopedPause>(
-          Shell::Get()->aura_env());
-  occlusion_tracker_reset_timer_.Start(FROM_HERE, kOcclusionTrackerTimeout,
-                                       this,
-                                       &TabletModeController::ResetPauser);
-}
-
-void TabletModeController::ResetPauser() {
-  occlusion_tracker_pauser_.reset();
-}
-
 }  // namespace ash
--- a/ash/wm/tablet_mode/tablet_mode_controller.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/tablet_mode/tablet_mode_controller.h	2019-05-17 18:53:08.380000000 +0300
@@ -25,7 +25,6 @@
 #include "chromeos/dbus/power_manager_client.h"
 #include "mojo/public/cpp/bindings/binding.h"
 #include "mojo/public/cpp/bindings/interface_ptr_set.h"
-#include "ui/aura/window_occlusion_tracker.h"
 #include "ui/events/devices/input_device_event_observer.h"
 #include "ui/gfx/geometry/vector3d_f.h"
 
@@ -140,15 +139,6 @@
   void OnInputDeviceConfigurationChanged(uint8_t input_device_types) override;
   void OnDeviceListsComplete() override;
 
-  void increment_app_window_drag_count() { ++app_window_drag_count_; }
-  void increment_app_window_drag_in_splitview_count() {
-    ++app_window_drag_in_splitview_count_;
-  }
-  void increment_tab_drag_count() { ++tab_drag_count_; }
-  void increment_tab_drag_in_splitview_count() {
-    ++tab_drag_in_splitview_count_;
-  }
-
  private:
   friend class TabletModeControllerTestApi;
 
@@ -203,9 +193,6 @@
 
   // mojom::TabletModeController:
   void SetClient(mojom::TabletModeClientPtr client) override;
-  void SetTabletModeEnabledForTesting(
-      bool enabled,
-      SetTabletModeEnabledForTestingCallback callback) override;
 
   // Checks whether we want to allow change the current ui mode to tablet mode
   // or clamshell mode. This returns false if the user set a flag for the
@@ -231,13 +218,6 @@
   // angle range.
   bool LidAngleIsInTabletModeRange();
 
-  // Suspends |occlusion_tracker_pauser_| for the duration of
-  // kOcclusionTrackTimeout.
-  void SuspendOcclusionTracker();
-
-  // Resets |occlusion_tracker_pauser_|.
-  void ResetPauser();
-
   // The maximized window manager (if enabled).
   std::unique_ptr<TabletModeWindowManager> tablet_mode_window_manager_;
 
@@ -284,19 +264,6 @@
   // not enter tablet mode if this is true.
   bool has_external_pointing_device_ = false;
 
-  // Counts the app window drag from top in tablet mode.
-  int app_window_drag_count_ = 0;
-
-  // Counts the app window drag from top when splitview is active.
-  int app_window_drag_in_splitview_count_ = 0;
-
-  // Counts of the tab drag from top in tablet mode, includes both non-source
-  // window and source window drag.
-  int tab_drag_count_ = 0;
-
-  // Counts of the tab drag from top when splitview is active.
-  int tab_drag_in_splitview_count_ = 0;
-
   // Tracks smoothed accelerometer data over time. This is done when the hinge
   // is approaching vertical to remove abrupt acceleration that can lead to
   // incorrect calculations of hinge angles.
@@ -317,13 +284,6 @@
 
   ScopedSessionObserver scoped_session_observer_;
 
-  std::unique_ptr<aura::WindowOcclusionTracker::ScopedPause>
-      occlusion_tracker_pauser_;
-
-  // Starts when enter/exit tablet mode. Runs ResetPauser to reset the
-  // occlustion tracker.
-  base::OneShotTimer occlusion_tracker_reset_timer_;
-
   // Observer to observe the bluetooth devices.
   std::unique_ptr<BluetoothDevicesObserver> bluetooth_devices_observer_;
 
--- a/ash/wm/tablet_mode/tablet_mode_controller_unittest.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/tablet_mode/tablet_mode_controller_unittest.cc	2019-05-17 18:53:08.380000000 +0300
@@ -11,18 +11,13 @@
 #include "ash/accelerometer/accelerometer_reader.h"
 #include "ash/accelerometer/accelerometer_types.h"
 #include "ash/app_list/app_list_controller_impl.h"
-#include "ash/app_list/test/app_list_test_helper.h"
-#include "ash/app_list/views/app_list_view.h"
 #include "ash/display/screen_orientation_controller.h"
 #include "ash/public/cpp/app_types.h"
 #include "ash/public/cpp/ash_switches.h"
 #include "ash/public/cpp/tablet_mode.h"
-#include "ash/public/cpp/window_properties.h"
-#include "ash/screen_util.h"
 #include "ash/shell.h"
 #include "ash/test/ash_test_base.h"
 #include "ash/wm/overview/overview_controller.h"
-#include "ash/wm/splitview/split_view_utils.h"
 #include "ash/wm/tablet_mode/tablet_mode_controller_test_api.h"
 #include "ash/wm/wm_event.h"
 #include "base/command_line.h"
@@ -34,8 +29,6 @@
 #include "chromeos/dbus/fake_power_manager_client.h"
 #include "services/ws/public/cpp/input_devices/input_device_client_test_api.h"
 #include "ui/aura/client/aura_constants.h"
-#include "ui/aura/test/test_window_delegate.h"
-#include "ui/base/hit_test.h"
 #include "ui/display/manager/display_manager.h"
 #include "ui/display/screen.h"
 #include "ui/display/test/display_manager_test_api.h"
@@ -656,7 +649,11 @@
 // state will trigger a mode update.
 TEST_F(TabletModeControllerTest, InitializedWhileTabletModeSwitchOn) {
   base::RunLoop().RunUntilIdle();
-  power_manager_client()->SetTabletMode(
+  // FakePowerManagerClient is always installed for tests
+  chromeos::FakePowerManagerClient* power_manager_client =
+      static_cast<chromeos::FakePowerManagerClient*>(
+          chromeos::DBusThreadManager::Get()->GetPowerManagerClient());
+  power_manager_client->SetTabletMode(
       chromeos::PowerManagerClient::TabletMode::ON, base::TimeTicks::Now());
 
   // Clear the callback that was set by the original TabletModeController.
@@ -731,7 +728,9 @@
 TEST_F(TabletModeControllerTest, CannotEnterTabletModeWithExternalMouse) {
   // Set the current list of devices to empty so that they don't interfere
   // with the test.
+  base::RunLoop().RunUntilIdle();
   ws::InputDeviceClientTestApi().SetMouseDevices({});
+  base::RunLoop().RunUntilIdle();
 
   OpenLidToAngle(300.0f);
   EXPECT_TRUE(IsTabletModeStarted());
@@ -742,6 +741,7 @@
   // Attach a external mouse.
   ws::InputDeviceClientTestApi().SetMouseDevices(
       {ui::InputDevice(3, ui::InputDeviceType::INPUT_DEVICE_USB, "mouse")});
+  base::RunLoop().RunUntilIdle();
   EXPECT_FALSE(IsTabletModeStarted());
 
   // Open lid to tent mode. Verify that tablet mode is not started.
@@ -754,7 +754,9 @@
 TEST_F(TabletModeControllerTest, LeaveTabletModeWhenExternalMouseConnected) {
   // Set the current list of devices to empty so that they don't interfere
   // with the test.
+  base::RunLoop().RunUntilIdle();
   ws::InputDeviceClientTestApi().SetMouseDevices({});
+  base::RunLoop().RunUntilIdle();
 
   // Start in tablet mode.
   OpenLidToAngle(300.0f);
@@ -765,11 +767,13 @@
   // events are still blocked because the keyboard is still facing the bottom.
   ws::InputDeviceClientTestApi().SetMouseDevices(
       {ui::InputDevice(3, ui::InputDeviceType::INPUT_DEVICE_USB, "mouse")});
+  base::RunLoop().RunUntilIdle();
   EXPECT_FALSE(IsTabletModeStarted());
   EXPECT_TRUE(AreEventsBlocked());
 
   // Verify that after unplugging the mouse, tablet mode will resume.
   ws::InputDeviceClientTestApi().SetMouseDevices({});
+  base::RunLoop().RunUntilIdle();
   EXPECT_TRUE(IsTabletModeStarted());
   EXPECT_TRUE(AreEventsBlocked());
 }
@@ -779,7 +783,9 @@
 TEST_F(TabletModeControllerTest, ExternalMouseInLaptopMode) {
   // Set the current list of devices to empty so that they don't interfere
   // with the test.
+  base::RunLoop().RunUntilIdle();
   ws::InputDeviceClientTestApi().SetMouseDevices({});
+  base::RunLoop().RunUntilIdle();
 
   // Start in laptop mode.
   OpenLidToAngle(30.0f);
@@ -789,55 +795,16 @@
   // Attach external mouse doesn't change the mode.
   ws::InputDeviceClientTestApi().SetMouseDevices(
       {ui::InputDevice(3, ui::InputDeviceType::INPUT_DEVICE_USB, "mouse")});
+  base::RunLoop().RunUntilIdle();
   EXPECT_FALSE(IsTabletModeStarted());
   EXPECT_FALSE(AreEventsBlocked());
 
   // Now remove the external mouse. It still should maintain in laptop mode
   // because its lid angle is still in laptop mode.
   ws::InputDeviceClientTestApi().SetMouseDevices({});
-  EXPECT_FALSE(IsTabletModeStarted());
-  EXPECT_FALSE(AreEventsBlocked());
-}
-
-// Test that docked mode prevents entering tablet mode on detaching an external
-// mouse while in tablet position.
-TEST_F(TabletModeControllerTest, ExternalMouseInDockedMode) {
-  // Set the current list of devices to empty so that they don't interfere
-  // with the test.
-  base::RunLoop().RunUntilIdle();
-  ws::InputDeviceClientTestApi().SetMouseDevices({});
   base::RunLoop().RunUntilIdle();
-
-  UpdateDisplay("800x600, 800x600");
-  const int64_t internal_display_id =
-      display::test::DisplayManagerTestApi(display_manager())
-          .SetFirstDisplayAsInternalDisplay();
-
-  // Set the current list of devices with an external mouse.
-  ws::InputDeviceClientTestApi().SetMouseDevices(
-      {ui::InputDevice(3, ui::InputDeviceType::INPUT_DEVICE_USB, "mouse")});
-
-  // Deactivate internal display to simulate Docked Mode.
-  std::vector<display::ManagedDisplayInfo> all_displays;
-  all_displays.push_back(display_manager()->GetDisplayInfo(
-      display_manager()->GetDisplayAt(0).id()));
-  std::vector<display::ManagedDisplayInfo> secondary_only;
-  display::ManagedDisplayInfo secondary_display =
-      display_manager()->GetDisplayInfo(
-          display_manager()->GetDisplayAt(1).id());
-  all_displays.push_back(secondary_display);
-  secondary_only.push_back(secondary_display);
-  display_manager()->OnNativeDisplaysChanged(secondary_only);
-  ASSERT_FALSE(display_manager()->IsActiveDisplayId(internal_display_id));
-
-  // Enter tablet position.
-  SetTabletMode(true);
-  ASSERT_FALSE(IsTabletModeStarted());
-
-  // Detach the external mouse.
-  ws::InputDeviceClientTestApi().SetMouseDevices({});
-  // Still expect clamshell mode.
   EXPECT_FALSE(IsTabletModeStarted());
+  EXPECT_FALSE(AreEventsBlocked());
 }
 
 // Test that the ui mode and input event blocker should be both correctly
@@ -845,7 +812,9 @@
 TEST_F(TabletModeControllerTest, ExternalMouseWithLidAngleTest) {
   // Set the current list of devices to empty so that they don't interfere
   // with the test.
+  base::RunLoop().RunUntilIdle();
   ws::InputDeviceClientTestApi().SetMouseDevices({});
+  base::RunLoop().RunUntilIdle();
 
   // Start in laptop mode.
   OpenLidToAngle(30.0f);
@@ -855,6 +824,7 @@
   // Attach external mouse doesn't change the mode.
   ws::InputDeviceClientTestApi().SetMouseDevices(
       {ui::InputDevice(3, ui::InputDeviceType::INPUT_DEVICE_USB, "mouse")});
+  base::RunLoop().RunUntilIdle();
   EXPECT_FALSE(IsTabletModeStarted());
   EXPECT_FALSE(AreEventsBlocked());
 
@@ -868,12 +838,14 @@
   // Remove the external mouse should enter tablet mode now. The internal input
   // events should still be blocked.
   ws::InputDeviceClientTestApi().SetMouseDevices({});
+  base::RunLoop().RunUntilIdle();
   EXPECT_TRUE(IsTabletModeStarted());
   EXPECT_TRUE(AreEventsBlocked());
 
   // Attach the mouse again should enter clamshell mode again.
   ws::InputDeviceClientTestApi().SetMouseDevices(
       {ui::InputDevice(3, ui::InputDeviceType::INPUT_DEVICE_USB, "mouse")});
+  base::RunLoop().RunUntilIdle();
   EXPECT_FALSE(IsTabletModeStarted());
   EXPECT_TRUE(AreEventsBlocked());
 
@@ -886,6 +858,7 @@
   // Now remove the mouse. The device should stay in clamshell mode and the
   // internal events should not be blocked.
   ws::InputDeviceClientTestApi().SetMouseDevices({});
+  base::RunLoop().RunUntilIdle();
   EXPECT_FALSE(IsTabletModeStarted());
   EXPECT_FALSE(AreEventsBlocked());
 }
@@ -896,7 +869,9 @@
 TEST_F(TabletModeControllerTest, ExternalMouseWithTabletModeSwithTest) {
   // Set the current list of devices to empty so that they don't interfere
   // with the test.
+  base::RunLoop().RunUntilIdle();
   ws::InputDeviceClientTestApi().SetMouseDevices({});
+  base::RunLoop().RunUntilIdle();
 
   // Start in laptop mode.
   SetTabletMode(false);
@@ -906,6 +881,7 @@
   // Attach external mouse doesn't change the mode.
   ws::InputDeviceClientTestApi().SetMouseDevices(
       {ui::InputDevice(3, ui::InputDeviceType::INPUT_DEVICE_USB, "mouse")});
+  base::RunLoop().RunUntilIdle();
   EXPECT_FALSE(IsTabletModeStarted());
   EXPECT_FALSE(AreEventsBlocked());
 
@@ -919,12 +895,14 @@
   // Remove the external mouse should enter tablet mode now. The internal input
   // events should still be blocked.
   ws::InputDeviceClientTestApi().SetMouseDevices({});
+  base::RunLoop().RunUntilIdle();
   EXPECT_TRUE(IsTabletModeStarted());
   EXPECT_TRUE(AreEventsBlocked());
 
   // Attach the mouse again should enter clamshell mode again.
   ws::InputDeviceClientTestApi().SetMouseDevices(
       {ui::InputDevice(3, ui::InputDeviceType::INPUT_DEVICE_USB, "mouse")});
+  base::RunLoop().RunUntilIdle();
   EXPECT_FALSE(IsTabletModeStarted());
   EXPECT_TRUE(AreEventsBlocked());
 
@@ -937,6 +915,7 @@
   // Now remove the mouse. The device should stay in clamshell mode and the
   // internal events should not be blocked.
   ws::InputDeviceClientTestApi().SetMouseDevices({});
+  base::RunLoop().RunUntilIdle();
   EXPECT_FALSE(IsTabletModeStarted());
   EXPECT_FALSE(AreEventsBlocked());
 }
@@ -946,8 +925,10 @@
 TEST_F(TabletModeControllerTest, ExternalTouchPadTest) {
   // Set the current list of devices to empty so that they don't interfere
   // with the test.
+  base::RunLoop().RunUntilIdle();
   ws::InputDeviceClientTestApi().SetMouseDevices({});
   ws::InputDeviceClientTestApi().SetTouchpadDevices({});
+  base::RunLoop().RunUntilIdle();
 
   OpenLidToAngle(300.0f);
   EXPECT_TRUE(IsTabletModeStarted());
@@ -958,6 +939,7 @@
   // Attach a external touchpad.
   ws::InputDeviceClientTestApi().SetTouchpadDevices(
       {ui::InputDevice(3, ui::InputDeviceType::INPUT_DEVICE_USB, "touchpad")});
+  base::RunLoop().RunUntilIdle();
   EXPECT_FALSE(IsTabletModeStarted());
   EXPECT_FALSE(AreEventsBlocked());
 
@@ -968,6 +950,7 @@
 
   // Verify that after unplugging the touchpad, tablet mode will resume.
   ws::InputDeviceClientTestApi().SetTouchpadDevices({});
+  base::RunLoop().RunUntilIdle();
   EXPECT_TRUE(IsTabletModeStarted());
   EXPECT_TRUE(AreEventsBlocked());
 }
@@ -1033,49 +1016,26 @@
 
 // Verify when the force touch view mode flag is turned on, tablet mode is on
 // initially, and opening the lid to less than 180 degress or setting tablet
-// mode to off will not turn off tablet mode. The internal keyboard and trackpad
-// should still work as it makes testing easier.
+// mode to off will not turn off tablet mode.
 TEST_F(TabletModeControllerForceTabletModeTest, ForceTabletModeTest) {
   EXPECT_EQ(TabletModeController::UiMode::kTabletMode, forced_ui_mode());
   EXPECT_TRUE(IsTabletModeStarted());
-  EXPECT_FALSE(AreEventsBlocked());
+  EXPECT_TRUE(AreEventsBlocked());
 
   OpenLidToAngle(30.0f);
   EXPECT_TRUE(IsTabletModeStarted());
-  EXPECT_FALSE(AreEventsBlocked());
+  EXPECT_TRUE(AreEventsBlocked());
 
   SetTabletMode(false);
   EXPECT_TRUE(IsTabletModeStarted());
-  EXPECT_FALSE(AreEventsBlocked());
+  EXPECT_TRUE(AreEventsBlocked());
 
   // Tests that attaching a external mouse will not change the mode.
   ws::InputDeviceClientTestApi().SetMouseDevices(
       {ui::InputDevice(3, ui::InputDeviceType::INPUT_DEVICE_USB, "mouse")});
+  base::RunLoop().RunUntilIdle();
   EXPECT_TRUE(IsTabletModeStarted());
-  EXPECT_FALSE(AreEventsBlocked());
-}
-
-TEST_F(TabletModeControllerForceTabletModeTest, DockInForcedTabletMode) {
-  UpdateDisplay("800x600, 800x600");
-  const int64_t internal_display_id =
-      display::test::DisplayManagerTestApi(display_manager())
-          .SetFirstDisplayAsInternalDisplay();
-
-  // Deactivate internal display to simulate Docked Mode.
-  std::vector<display::ManagedDisplayInfo> all_displays;
-  all_displays.push_back(display_manager()->GetDisplayInfo(
-      display_manager()->GetDisplayAt(0).id()));
-  std::vector<display::ManagedDisplayInfo> secondary_only;
-  display::ManagedDisplayInfo secondary_display =
-      display_manager()->GetDisplayInfo(
-          display_manager()->GetDisplayAt(1).id());
-  all_displays.push_back(secondary_display);
-  secondary_only.push_back(secondary_display);
-  display_manager()->OnNativeDisplaysChanged(secondary_only);
-  ASSERT_FALSE(display_manager()->IsActiveDisplayId(internal_display_id));
-
-  // Still expect tablet mode.
-  EXPECT_TRUE(IsTabletModeStarted());
+  EXPECT_TRUE(AreEventsBlocked());
 }
 
 class TabletModeControllerForceClamshellModeTest
@@ -1237,219 +1197,6 @@
   EXPECT_TRUE(GetDeferBoundsUpdates(extra_right_window.get()));
 }
 
-// Test that if before tablet mode, the active window is a transient child of a
-// window snapped on the left, then split view is activated with the parent
-// snapped on the left.
-TEST_F(TabletModeControllerTest, StartTabletActiveTransientChildOfLeftSnap) {
-  SplitViewController* split_view_controller =
-      Shell::Get()->split_view_controller();
-  std::unique_ptr<aura::Window> parent = CreateDesktopWindowSnappedLeft();
-  std::unique_ptr<aura::Window> child =
-      CreateTestWindow(gfx::Rect(), aura::client::WINDOW_TYPE_POPUP);
-  ::wm::AddTransientChild(parent.get(), child.get());
-  ::wm::ActivateWindow(parent.get());
-  ::wm::ActivateWindow(child.get());
-  tablet_mode_controller()->EnableTabletModeWindowManager(true);
-  EXPECT_EQ(SplitViewController::LEFT_SNAPPED, split_view_controller->state());
-  EXPECT_EQ(parent.get(), split_view_controller->left_window());
-  EXPECT_TRUE(Shell::Get()->overview_controller()->IsSelecting());
-  EXPECT_FALSE(GetDeferBoundsUpdates(parent.get()));
-}
-
-// Test that if before tablet mode, the active window is the app list and the
-// previous window is snapped on the left, then split view is activated with the
-// previous window on the left.
-TEST_F(TabletModeControllerTest, StartTabletActiveAppListPreviousLeftSnap) {
-  SplitViewController* split_view_controller =
-      Shell::Get()->split_view_controller();
-  std::unique_ptr<aura::Window> window = CreateDesktopWindowSnappedLeft();
-  ::wm::ActivateWindow(window.get());
-  Shell::Get()->app_list_controller()->ShowAppList();
-  ASSERT_TRUE(::wm::IsActiveWindow(
-      GetAppListTestHelper()->GetAppListView()->GetWidget()->GetNativeView()));
-  tablet_mode_controller()->EnableTabletModeWindowManager(true);
-  EXPECT_EQ(SplitViewController::LEFT_SNAPPED, split_view_controller->state());
-  EXPECT_EQ(window.get(), split_view_controller->left_window());
-  EXPECT_TRUE(Shell::Get()->overview_controller()->IsSelecting());
-  EXPECT_FALSE(GetDeferBoundsUpdates(window.get()));
-}
-
-// Test that if before tablet mode, the active window is being dragged and the
-// previous window is snapped on the left, then split view is activated with the
-// previous window on the left.
-TEST_F(TabletModeControllerTest, StartTabletActiveDraggedPreviousLeftSnap) {
-  SplitViewController* split_view_controller =
-      Shell::Get()->split_view_controller();
-  std::unique_ptr<aura::Window> dragged_window = CreateTestWindow();
-  wm::WindowState* dragged_window_state =
-      wm::GetWindowState(dragged_window.get());
-  dragged_window_state->CreateDragDetails(
-      gfx::Point(), HTNOWHERE,
-      ::wm::WindowMoveSource::WINDOW_MOVE_SOURCE_MOUSE);
-  dragged_window_state->OnDragStarted(HTNOWHERE);
-  ASSERT_TRUE(dragged_window_state->is_dragged());
-  std::unique_ptr<aura::Window> snapped_window =
-      CreateDesktopWindowSnappedLeft();
-  ::wm::ActivateWindow(snapped_window.get());
-  ::wm::ActivateWindow(dragged_window.get());
-  tablet_mode_controller()->EnableTabletModeWindowManager(true);
-  EXPECT_EQ(SplitViewController::LEFT_SNAPPED, split_view_controller->state());
-  EXPECT_EQ(snapped_window.get(), split_view_controller->left_window());
-  EXPECT_TRUE(Shell::Get()->overview_controller()->IsSelecting());
-  EXPECT_FALSE(GetDeferBoundsUpdates(snapped_window.get()));
-}
-
-// Test that if before tablet mode, the active window is hidden from overview
-// and the previous window is snapped on the left, then split view is activated
-// with the previous window on the left.
-TEST_F(TabletModeControllerTest,
-       StartTabletActiveHiddenFromOverviewPreviousLeftSnap) {
-  SplitViewController* split_view_controller =
-      Shell::Get()->split_view_controller();
-  std::unique_ptr<aura::Window> window_hidden_from_overview =
-      CreateTestWindow();
-  window_hidden_from_overview->SetProperty(kHideInOverviewKey, true);
-  std::unique_ptr<aura::Window> snapped_window =
-      CreateDesktopWindowSnappedLeft();
-  ::wm::ActivateWindow(snapped_window.get());
-  ::wm::ActivateWindow(window_hidden_from_overview.get());
-  tablet_mode_controller()->EnableTabletModeWindowManager(true);
-  EXPECT_EQ(SplitViewController::LEFT_SNAPPED, split_view_controller->state());
-  EXPECT_EQ(snapped_window.get(), split_view_controller->left_window());
-  EXPECT_TRUE(Shell::Get()->overview_controller()->IsSelecting());
-  EXPECT_FALSE(GetDeferBoundsUpdates(snapped_window.get()));
-}
-
-// Test that if before tablet mode, the active window is snapped on the left but
-// does not meet the requirements to be snapped in split view, and the previous
-// window is snapped on the right, then split view is not activated.
-TEST_F(TabletModeControllerTest,
-       StartTabletActiveDesktopOnlyLeftSnapPreviousRightSnap) {
-  SplitViewController* split_view_controller =
-      Shell::Get()->split_view_controller();
-  aura::test::TestWindowDelegate left_window_delegate;
-  std::unique_ptr<aura::Window> left_window(CreateTestWindowInShellWithDelegate(
-      &left_window_delegate, /*id=*/-1, /*bounds=*/gfx::Rect(0, 0, 400, 400)));
-  const gfx::Rect display_bounds =
-      screen_util::GetDisplayWorkAreaBoundsInScreenForDefaultContainer(
-          left_window.get());
-  left_window_delegate.set_minimum_size(
-      gfx::Size(display_bounds.width() * 0.67f, display_bounds.height()));
-  wm::WindowState* left_window_state = wm::GetWindowState(left_window.get());
-  ASSERT_TRUE(left_window_state->CanSnap());
-  ASSERT_FALSE(CanSnapInSplitview(left_window.get()));
-  wm::WMEvent snap_to_left(wm::WM_EVENT_CYCLE_SNAP_LEFT);
-  left_window_state->OnWMEvent(&snap_to_left);
-  std::unique_ptr<aura::Window> right_window =
-      CreateDesktopWindowSnappedRight();
-  ::wm::ActivateWindow(right_window.get());
-  ::wm::ActivateWindow(left_window.get());
-  tablet_mode_controller()->EnableTabletModeWindowManager(true);
-  EXPECT_EQ(SplitViewController::NO_SNAP, split_view_controller->state());
-  EXPECT_FALSE(Shell::Get()->overview_controller()->IsSelecting());
-  EXPECT_FALSE(GetDeferBoundsUpdates(left_window.get()));
-  EXPECT_FALSE(GetDeferBoundsUpdates(right_window.get()));
-}
-
-// Test that if before tablet mode, the active window is snapped on the right
-// but does not meet the requirements to be snapped in split view, and the
-// previous window is snapped on the left, then split view is not activated.
-TEST_F(TabletModeControllerTest,
-       StartTabletActiveDesktopOnlyRightSnapPreviousLeftSnap) {
-  SplitViewController* split_view_controller =
-      Shell::Get()->split_view_controller();
-  std::unique_ptr<aura::Window> left_window = CreateDesktopWindowSnappedLeft();
-  aura::test::TestWindowDelegate right_window_delegate;
-  std::unique_ptr<aura::Window> right_window(
-      CreateTestWindowInShellWithDelegate(
-          &right_window_delegate, /*id=*/-1,
-          /*bounds=*/gfx::Rect(0, 0, 400, 400)));
-  const gfx::Rect display_bounds =
-      screen_util::GetDisplayWorkAreaBoundsInScreenForDefaultContainer(
-          right_window.get());
-  right_window_delegate.set_minimum_size(
-      gfx::Size(display_bounds.width() * 0.67f, display_bounds.height()));
-  wm::WindowState* right_window_state = wm::GetWindowState(right_window.get());
-  ASSERT_TRUE(right_window_state->CanSnap());
-  ASSERT_FALSE(CanSnapInSplitview(right_window.get()));
-  wm::WMEvent snap_to_right(wm::WM_EVENT_CYCLE_SNAP_RIGHT);
-  right_window_state->OnWMEvent(&snap_to_right);
-  ::wm::ActivateWindow(left_window.get());
-  ::wm::ActivateWindow(right_window.get());
-  tablet_mode_controller()->EnableTabletModeWindowManager(true);
-  EXPECT_EQ(SplitViewController::NO_SNAP, split_view_controller->state());
-  EXPECT_FALSE(Shell::Get()->overview_controller()->IsSelecting());
-  EXPECT_FALSE(GetDeferBoundsUpdates(left_window.get()));
-  EXPECT_FALSE(GetDeferBoundsUpdates(right_window.get()));
-}
-
-// Test that if before tablet mode, the active window is snapped on the left and
-// the previous window is snapped on the right but does not meet the
-// requirements to be snapped in split view, then split view is activated with
-// the active window on the left.
-TEST_F(TabletModeControllerTest,
-       StartTabletActiveLeftSnapPreviousDesktopOnlyRightSnap) {
-  SplitViewController* split_view_controller =
-      Shell::Get()->split_view_controller();
-  std::unique_ptr<aura::Window> left_window = CreateDesktopWindowSnappedLeft();
-  aura::test::TestWindowDelegate right_window_delegate;
-  std::unique_ptr<aura::Window> right_window(
-      CreateTestWindowInShellWithDelegate(
-          &right_window_delegate, /*id=*/-1,
-          /*bounds=*/gfx::Rect(0, 0, 400, 400)));
-  const gfx::Rect display_bounds =
-      screen_util::GetDisplayWorkAreaBoundsInScreenForDefaultContainer(
-          right_window.get());
-  right_window_delegate.set_minimum_size(
-      gfx::Size(display_bounds.width() * 0.67f, display_bounds.height()));
-  wm::WindowState* right_window_state = wm::GetWindowState(right_window.get());
-  ASSERT_TRUE(right_window_state->CanSnap());
-  ASSERT_FALSE(CanSnapInSplitview(right_window.get()));
-  wm::WMEvent snap_to_right(wm::WM_EVENT_CYCLE_SNAP_RIGHT);
-  right_window_state->OnWMEvent(&snap_to_right);
-  ::wm::ActivateWindow(right_window.get());
-  ::wm::ActivateWindow(left_window.get());
-  tablet_mode_controller()->EnableTabletModeWindowManager(true);
-  EXPECT_EQ(SplitViewController::LEFT_SNAPPED, split_view_controller->state());
-  EXPECT_EQ(left_window.get(), split_view_controller->left_window());
-  EXPECT_TRUE(Shell::Get()->overview_controller()->IsSelecting());
-  EXPECT_FALSE(GetDeferBoundsUpdates(left_window.get()));
-  EXPECT_TRUE(GetDeferBoundsUpdates(right_window.get()));
-}
-
-// Test that if before tablet mode, the active window is snapped on the right
-// and the previous window is snapped on the left but does not meet the
-// requirements to be snapped in split view, then split view is activated with
-// the active window on the right.
-TEST_F(TabletModeControllerTest,
-       StartTabletActiveRightSnapPreviousDesktopOnlyLeftSnap) {
-  SplitViewController* split_view_controller =
-      Shell::Get()->split_view_controller();
-  aura::test::TestWindowDelegate left_window_delegate;
-  std::unique_ptr<aura::Window> left_window(CreateTestWindowInShellWithDelegate(
-      &left_window_delegate, /*id=*/-1, /*bounds=*/gfx::Rect(0, 0, 400, 400)));
-  const gfx::Rect display_bounds =
-      screen_util::GetDisplayWorkAreaBoundsInScreenForDefaultContainer(
-          left_window.get());
-  left_window_delegate.set_minimum_size(
-      gfx::Size(display_bounds.width() * 0.67f, display_bounds.height()));
-  wm::WindowState* left_window_state = wm::GetWindowState(left_window.get());
-  ASSERT_TRUE(left_window_state->CanSnap());
-  ASSERT_FALSE(CanSnapInSplitview(left_window.get()));
-  wm::WMEvent snap_to_left(wm::WM_EVENT_CYCLE_SNAP_LEFT);
-  left_window_state->OnWMEvent(&snap_to_left);
-  std::unique_ptr<aura::Window> right_window =
-      CreateDesktopWindowSnappedRight();
-  ::wm::ActivateWindow(left_window.get());
-  ::wm::ActivateWindow(right_window.get());
-  tablet_mode_controller()->EnableTabletModeWindowManager(true);
-  EXPECT_EQ(SplitViewController::RIGHT_SNAPPED, split_view_controller->state());
-  EXPECT_EQ(right_window.get(), split_view_controller->right_window());
-  EXPECT_TRUE(Shell::Get()->overview_controller()->IsSelecting());
-  EXPECT_TRUE(GetDeferBoundsUpdates(left_window.get()));
-  EXPECT_FALSE(GetDeferBoundsUpdates(right_window.get()));
-}
-
 // Test that if overview is triggered on entering tablet mode, then the app list
 // can still be successfully shown and actually seen.
 TEST_F(TabletModeControllerTest, AppListWorksAfterEnteringTabletForOverview) {
--- a/ash/wm/tablet_mode/tablet_mode_observer.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/tablet_mode/tablet_mode_observer.h	2019-05-17 18:53:08.380000000 +0300
@@ -2,8 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#ifndef ASH_WM_TABLET_MODE_TABLET_MODE_OBSERVER_H_
-#define ASH_WM_TABLET_MODE_TABLET_MODE_OBSERVER_H_
+#ifndef ASH_TABLET_MODE_TABLET_MODE_OBSERVER_H_
+#define ASH_TABLET_MODE_TABLET_MODE_OBSERVER_H_
 
 #include "ash/ash_export.h"
 
@@ -39,4 +39,4 @@
 
 }  // namespace ash
 
-#endif  // ASH_WM_TABLET_MODE_TABLET_MODE_OBSERVER_H_
+#endif  // ASH_TABLET_MODE_TABLET_MODE_OBSERVER_H_
--- a/ash/wm/tablet_mode/tablet_mode_window_drag_delegate.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/tablet_mode/tablet_mode_window_drag_delegate.cc	2019-05-17 18:53:08.380000000 +0300
@@ -7,9 +7,6 @@
 #include "ash/root_window_controller.h"
 #include "ash/shelf/shelf_layout_manager.h"
 #include "ash/shell.h"
-#include "ash/system/overview/overview_button_tray.h"
-#include "ash/system/status_area_widget.h"
-#include "ash/wm/mru_window_tracker.h"
 #include "ash/wm/overview/overview_controller.h"
 #include "ash/wm/overview/overview_grid.h"
 #include "ash/wm/overview/overview_item.h"
@@ -20,14 +17,7 @@
 #include "ash/wm/splitview/split_view_controller.h"
 #include "ash/wm/splitview/split_view_drag_indicators.h"
 #include "ash/wm/splitview/split_view_utils.h"
-#include "ash/wm/tablet_mode/tablet_mode_controller.h"
-#include "ash/wm/tablet_mode/tablet_mode_window_drag_metrics.h"
 #include "ash/wm/window_transient_descendant_iterator.h"
-#include "ash/wm/window_util.h"
-#include "base/metrics/histogram_macros.h"
-#include "base/metrics/user_metrics.h"
-#include "base/metrics/user_metrics_action.h"
-#include "ui/compositor/layer.h"
 #include "ui/compositor/scoped_layer_animation_settings.h"
 #include "ui/gfx/transform_util.h"
 #include "ui/wm/core/coordinate_conversion.h"
@@ -41,19 +31,6 @@
 // tablet mode.
 constexpr float kIndicatorsThresholdRatio = 0.1;
 
-// Duration of a drag that it will be considered as an intended drag.
-constexpr base::TimeDelta kIsWindowMovedTimeoutMs =
-    base::TimeDelta::FromMilliseconds(300);
-
-constexpr char kSwipeDownDragWindowHistogram[] =
-    "Ash.SwipeDownDrag.Window.PresentationTime.TabletMode";
-constexpr char kSwipeDownDragWindowMaxLatencyHistogram[] =
-    "Ash.SwipeDownDrag.Window.PresentationTime.MaxLatency.TabletMode";
-constexpr char kSwipeDownDragTabHistogram[] =
-    "Ash.SwipeDownDrag.Tab.PresentationTime.TabletMode";
-constexpr char kSwipeDownDragTabMaxLatencyHistogram[] =
-    "Ash.SwipeDownDrag.Tab.PresentationTime.MaxLatency.TabletMode";
-
 // Returns the overview session if overview mode is active, otherwise returns
 // nullptr.
 OverviewSession* GetOverviewSession() {
@@ -109,24 +86,8 @@
   DCHECK(!occlusion_excluder_);
   occlusion_excluder_.emplace(dragged_window);
 
-  DCHECK(!presentation_time_recorder_);
-  presentation_time_recorder_.reset();
-  if (wm::IsDraggingTabs(dragged_window)) {
-    presentation_time_recorder_ =
-        std::make_unique<PresentationTimeHistogramRecorder>(
-            dragged_window->layer()->GetCompositor(),
-            kSwipeDownDragTabHistogram, kSwipeDownDragTabMaxLatencyHistogram);
-  } else {
-    presentation_time_recorder_ =
-        std::make_unique<PresentationTimeHistogramRecorder>(
-            dragged_window->layer()->GetCompositor(),
-            kSwipeDownDragWindowHistogram,
-            kSwipeDownDragWindowMaxLatencyHistogram);
-  }
-
   dragged_window_ = dragged_window;
   initial_location_in_screen_ = location_in_screen;
-  drag_start_deadline_ = base::Time::Now() + kIsWindowMovedTimeoutMs;
 
   PrepareWindowDrag(location_in_screen);
 
@@ -143,8 +104,6 @@
   OverviewController* controller = Shell::Get()->overview_controller();
   bool was_overview_open = controller->IsSelecting();
 
-  const bool was_splitview_active =
-      split_view_controller_->IsSplitViewModeActive();
   // If the dragged window is one of the snapped windows, SplitViewController
   // might open overview in the dragged window side of the screen.
   split_view_controller_->OnWindowDragStarted(dragged_window_);
@@ -148,13 +107,8 @@
   // If the dragged window is one of the snapped windows, SplitViewController
   // might open overview in the dragged window side of the screen.
   split_view_controller_->OnWindowDragStarted(dragged_window_);
+
   if (ShouldOpenOverviewWhenDragStarts() && !controller->IsSelecting()) {
-    OverviewButtonTray* overview_button_tray =
-        RootWindowController::ForWindow(dragged_window_)
-            ->GetStatusAreaWidget()
-            ->overview_button_tray();
-    DCHECK(overview_button_tray);
-    overview_button_tray->SnapRippleToActivated();
     controller->ToggleOverview(
         OverviewSession::EnterExitOverviewType::kWindowDragged);
   }
@@ -174,43 +128,22 @@
   original_shadow_elevation_ =
       ::wm::GetShadowElevationConvertDefault(dragged_window_);
   ::wm::SetShadowElevation(dragged_window_, ::wm::kShadowElevationActiveWindow);
-
-  Shell* shell = Shell::Get();
-  TabletModeController* tablet_mode_controller =
-      shell->tablet_mode_controller();
-  if (wm::IsDraggingTabs(dragged_window_)) {
-    tablet_mode_controller->increment_tab_drag_count();
-    if (was_splitview_active)
-      tablet_mode_controller->increment_tab_drag_in_splitview_count();
-
-    // For tab drag, we only open the overview behind if the dragged window is
-    // the source window.
-    if (ShouldOpenOverviewWhenDragStarts())
-      RecordTabDragTypeHistogram(TabDragType::kDragSourceWindow);
-    else
-      RecordTabDragTypeHistogram(TabDragType::kDragTabOutOfWindow);
-  } else {
-    tablet_mode_controller->increment_app_window_drag_count();
-    if (was_splitview_active)
-      tablet_mode_controller->increment_app_window_drag_in_splitview_count();
-  }
-  if (controller->IsSelecting()) {
-    UMA_HISTOGRAM_COUNTS_100(
-        "Tablet.WindowDrag.OpenedWindowsNumber",
-        shell->mru_window_tracker()->BuildMruWindowList().size());
-    base::RecordAction(
-        base::UserMetricsAction("Tablet.WindowDrag.OpenedOverview"));
-  }
 }
 
 void TabletModeWindowDragDelegate::ContinueWindowDrag(
     const gfx::Point& location_in_screen,
     UpdateDraggedWindowType type,
     const gfx::Rect& target_bounds) {
-  UpdateIsWindowConsideredMoved(location_in_screen.y());
-
-  if (presentation_time_recorder_)
-    presentation_time_recorder_->RequestNext();
+  if (!did_move_) {
+    const gfx::Rect work_area_bounds =
+        display::Screen::GetScreen()
+            ->GetDisplayNearestWindow(dragged_window_)
+            .work_area();
+    if (location_in_screen.y() >=
+        GetIndicatorsVerticalThreshold(work_area_bounds)) {
+      did_move_ = true;
+    }
+  }
 
   if (type == UpdateDraggedWindowType::UPDATE_BOUNDS) {
     // UPDATE_BOUNDS is used when dragging tab(s) out of a browser window.
@@ -257,8 +190,7 @@
 
   // The window might merge into an overview window or become a new window item
   // in overview mode.
-  OverviewSession* overview_session = GetOverviewSession();
-  if (overview_session) {
+  if (GetOverviewSession()) {
     GetOverviewSession()->OnWindowDragEnded(
         dragged_window_, location_in_screen,
         ShouldDropWindowIntoOverview(snap_position, location_in_screen));
@@ -273,25 +205,9 @@
 
   // For child class to do its special handling if any.
   EndedWindowDrag(location_in_screen);
-
-  if (!wm::IsDraggingTabs(dragged_window_)) {
-    if (split_view_controller_->IsWindowInSplitView(dragged_window_)) {
-      RecordAppDragEndWindowStateHistogram(
-          AppWindowDragEndWindowState::kDraggedIntoSplitView);
-    } else if (overview_session &&
-               overview_session->IsWindowInOverview(dragged_window_)) {
-      RecordAppDragEndWindowStateHistogram(
-          AppWindowDragEndWindowState::kDraggedIntoOverview);
-    } else {
-      RecordAppDragEndWindowStateHistogram(
-          AppWindowDragEndWindowState::kBackToMaximizedOrFullscreen);
-    }
-  }
-
-  presentation_time_recorder_.reset();
   occlusion_excluder_.reset();
   dragged_window_ = nullptr;
-  is_window_considered_moved_ = false;
+  did_move_ = false;
 }
 
 void TabletModeWindowDragDelegate::FlingOrSwipe(ui::GestureEvent* event) {
@@ -324,10 +240,16 @@
   if (split_view_controller_->IsSplitViewModeActive())
     return IndicatorState::kNone;
 
-  // Do not show the drag indicators if the window hasn't been considered as
-  // moved.
-  if (!is_window_considered_moved_)
+  // If the event location hasn't passed the indicator vertical threshold, do
+  // not show the drag indicators.
+  const gfx::Rect work_area_bounds =
+      display::Screen::GetScreen()
+          ->GetDisplayNearestWindow(dragged_window_)
+          .work_area();
+  if (!did_move_ && location_in_screen.y() <
+                        GetIndicatorsVerticalThreshold(work_area_bounds)) {
     return IndicatorState::kNone;
+  }
 
   // No top drag indicator if in portrait screen orientation.
   if (IsCurrentScreenOrientationLandscape())
@@ -371,13 +293,16 @@
     }
   }
 
-  // Do not snap the window if it hasn't be considered as moved.
-  if (!is_window_considered_moved_)
-    return SplitViewController::NONE;
-
+  // Otherwise, the user has to drag pass the indicator vertical threshold to
+  // snap the window.
   gfx::Rect work_area_bounds = display::Screen::GetScreen()
                                    ->GetDisplayNearestWindow(dragged_window_)
                                    .work_area();
+  if (!did_move_ && location_in_screen.y() <
+                        GetIndicatorsVerticalThreshold(work_area_bounds)) {
+    return SplitViewController::NONE;
+  }
+
   // Check to see if the current event location |location_in_screen|is within
   // the drag indicators bounds.
   if (is_landscape) {
@@ -520,21 +445,4 @@
   return event->details().velocity_y() > kFlingToOverviewThreshold;
 }
 
-void TabletModeWindowDragDelegate::UpdateIsWindowConsideredMoved(
-    int y_location_in_screen) {
-  if (is_window_considered_moved_)
-    return;
-
-  if (base::Time::Now() < drag_start_deadline_)
-    return;
-
-  DCHECK(dragged_window_);
-  const gfx::Rect work_area_bounds =
-      display::Screen::GetScreen()
-          ->GetDisplayNearestWindow(dragged_window_)
-          .work_area();
-  is_window_considered_moved_ =
-      y_location_in_screen >= GetIndicatorsVerticalThreshold(work_area_bounds);
-}
-
 }  // namespace ash
--- a/ash/wm/tablet_mode/tablet_mode_window_drag_delegate.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/tablet_mode/tablet_mode_window_drag_delegate.h	2019-05-17 18:53:08.380000000 +0300
@@ -7,7 +7,6 @@
 
 #include <memory>
 
-#include "ash/public/cpp/presentation_time_recorder.h"
 #include "ash/public/cpp/window_properties.h"
 #include "ash/wm/splitview/split_view_controller.h"
 #include "ash/wm/wm_toplevel_window_event_handler.h"
@@ -20,7 +19,6 @@
 
 enum class IndicatorState;
 class SplitViewDragIndicators;
-class PresentationTimeRecorder;
 
 // This class includes the common logic when dragging a window around, either
 // it's a browser window, or an app window. It does almost everything needs to
@@ -81,10 +79,6 @@
     return split_view_drag_indicators_.get();
   }
 
-  void set_drag_start_deadline_for_testing(base::Time time) {
-    drag_start_deadline_ = time;
-  }
-
  protected:
   // These four methods are used by its child class to do its special handling
   // before/during/after dragging.
@@ -121,10 +115,6 @@
   // Returns true if fling event should drop the window into overview grid.
   bool ShouldFlingIntoOverview(const ui::GestureEvent* event) const;
 
-  // Updates |is_window_considered_moved_| on current time and
-  // |y_location_in_screen|.
-  void UpdateIsWindowConsideredMoved(int y_location_in_screen);
-
   SplitViewController* const split_view_controller_;
 
   // A widget to display the drag indicators and preview window.
@@ -147,23 +137,15 @@
   // desired window transform during dragging.
   gfx::Rect bounds_of_selected_drop_target_;
 
-  // True if the |dragged_window_| has been considered as moved. Only after it
-  // has been dragged longer than kIsWindowMovedTimeoutMs on time and further
-  // than GetIndicatorsVerticalThreshold on distance, it can be considered as
-  // moved. Only change its window state or show the drag indicators if it has
-  // been 'moved'. Once it has been 'moved', it will stay as 'moved'.
-  bool is_window_considered_moved_ = false;
-
-  // Drag need to last later than the deadline here to be considered as 'moved'.
-  base::Time drag_start_deadline_;
+  // Flag to indicate whether a window is considered as moved. A window needs to
+  // be dragged vertically a small amount of distance to be considered as moved.
+  // The drag indicators will only show up after the window has been moved. Once
+  // the window is moved, it will stay as 'moved'.
+  bool did_move_ = false;
 
   base::Optional<aura::WindowOcclusionTracker::ScopedExclude>
       occlusion_excluder_;
 
-  // Records the presentation time for app/browser/tab window dragging
-  // in tablet mode.
-  std::unique_ptr<PresentationTimeRecorder> presentation_time_recorder_;
-
   base::WeakPtrFactory<TabletModeWindowDragDelegate> weak_ptr_factory_;
 
  private:
--- a/ash/wm/tablet_mode/tablet_mode_window_manager.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/tablet_mode/tablet_mode_window_manager.cc	2019-05-17 18:53:08.384000000 +0300
@@ -13,8 +13,6 @@
 #include "ash/shell.h"
 #include "ash/wm/mru_window_tracker.h"
 #include "ash/wm/overview/overview_controller.h"
-#include "ash/wm/overview/overview_session.h"
-#include "ash/wm/splitview/split_view_utils.h"
 #include "ash/wm/tablet_mode/scoped_skip_user_session_blocked_check.h"
 #include "ash/wm/tablet_mode/tablet_mode_backdrop_delegate_impl.h"
 #include "ash/wm/tablet_mode/tablet_mode_event_handler.h"
@@ -49,7 +47,6 @@
     window->RemoveObserver(this);
   added_windows_.clear();
   Shell::Get()->RemoveShellObserver(this);
-  Shell::Get()->overview_controller()->RemoveObserver(this);
   display::Screen::GetScreen()->RemoveObserver(this);
   Shell::Get()->split_view_controller()->RemoveObserver(this);
   EnableBackdropBehindTopWindowOnEachDisplay(false);
@@ -64,12 +61,13 @@
 void TabletModeWindowManager::AddWindow(aura::Window* window) {
   // Only add the window if it is a direct dependent of a container window
   // and not yet tracked.
-  if (base::ContainsKey(window_state_map_, window) ||
+  if (!ShouldHandleWindow(window) ||
+      base::ContainsKey(window_state_map_, window) ||
       !IsContainerWindow(window->parent())) {
     return;
   }
 
-  TrackWindow(window);
+  MaximizeAndTrackWindow(window);
 }
 
 void TabletModeWindowManager::WindowStateDestroyed(aura::Window* window) {
@@ -85,35 +83,6 @@
     window_state_map_.erase(it);
 }
 
-void TabletModeWindowManager::OnSplitViewModeEnded() {
-  switch (Shell::Get()->split_view_controller()->end_reason()) {
-    case SplitViewController::EndReason::kNormal:
-    case SplitViewController::EndReason::kUnsnappableWindowActivated:
-      break;
-    case SplitViewController::EndReason::kHomeLauncherPressed:
-    case SplitViewController::EndReason::kActiveUserChanged:
-      // For the case of kHomeLauncherPressed, the home launcher will minimize
-      // the snapped windows after ending splitview, so avoid maximizing them
-      // here. For the case of kActiveUserChanged, the snapped windows will be
-      // used to restore the splitview layout when switching back, and it is
-      // already too late to maximize them anyway (the for loop below would
-      // iterate over windows in the newly activated user session).
-      return;
-  }
-
-  // Maximize all snapped windows upon exiting split view mode. Note the snapped
-  // window might not be tracked in our |window_state_map_|.
-  MruWindowTracker::WindowList windows =
-      Shell::Get()->mru_window_tracker()->BuildWindowListIgnoreModal();
-  for (auto* window : windows) {
-    wm::WindowState* window_state = wm::GetWindowState(window);
-    if (window_state->IsSnapped()) {
-      wm::WMEvent event(wm::WM_EVENT_MAXIMIZE);
-      window_state->OnWMEvent(&event);
-    }
-  }
-}
-
 void TabletModeWindowManager::OnOverviewModeStarting() {
   aura::Window* default_snapped_window =
       Shell::Get()->split_view_controller()->GetDefaultSnappedWindow();
@@ -153,6 +122,35 @@
   }
 }
 
+void TabletModeWindowManager::OnSplitViewModeEnded() {
+  switch (Shell::Get()->split_view_controller()->end_reason()) {
+    case SplitViewController::EndReason::kNormal:
+    case SplitViewController::EndReason::kUnsnappableWindowActivated:
+      break;
+    case SplitViewController::EndReason::kHomeLauncherPressed:
+    case SplitViewController::EndReason::kActiveUserChanged:
+      // For the case of kHomeLauncherPressed, the home launcher will minimize
+      // the snapped windows after ending splitview, so avoid maximizing them
+      // here. For the case of kActiveUserChanged, the snapped windows will be
+      // used to restore the splitview layout when switching back, and it is
+      // already too late to maximize them anyway (the for loop below would
+      // iterate over windows in the newly activated user session).
+      return;
+  }
+
+  // Maximize all snapped windows upon exiting split view mode. Note the snapped
+  // window might not be tracked in our |window_state_map_|.
+  MruWindowTracker::WindowList windows =
+      Shell::Get()->mru_window_tracker()->BuildWindowListIgnoreModal();
+  for (auto* window : windows) {
+    wm::WindowState* window_state = wm::GetWindowState(window);
+    if (window_state->IsSnapped()) {
+      wm::WMEvent event(wm::WM_EVENT_MAXIMIZE);
+      window_state->OnWMEvent(&event);
+    }
+  }
+}
+
 void TabletModeWindowManager::OnWindowDestroying(aura::Window* window) {
   if (IsContainerWindow(window)) {
     // container window can be removed on display destruction.
@@ -184,7 +182,7 @@
       }
       return;
     }
-    TrackWindow(params.target);
+    MaximizeAndTrackWindow(params.target);
     // When the state got added, the "WM_EVENT_ADDED_TO_WORKSPACE" event got
     // already sent and we have to notify our state again.
     if (base::ContainsKey(window_state_map_, params.target)) {
@@ -211,18 +209,11 @@
     ui::PropertyChangeReason reason) {
   if (!IsContainerWindow(window))
     return;
-
-  auto* session = Shell::Get()->overview_controller()->overview_session();
-  if (session)
-    session->SuspendReposition();
-
   // Reposition all non maximizeable windows.
   for (auto& pair : window_state_map_) {
     pair.second->UpdateWindowPosition(wm::GetWindowState(pair.first),
                                       /*animate=*/false);
   }
-  if (session)
-    session->ResumeReposition();
 }
 
 void TabletModeWindowManager::OnWindowVisibilityChanged(aura::Window* window,
@@ -235,7 +226,7 @@
       base::ContainsKey(added_windows_, window) && visible) {
     added_windows_.erase(window);
     window->RemoveObserver(this);
-    TrackWindow(window);
+    MaximizeAndTrackWindow(window);
     // When the state got added, the "WM_EVENT_ADDED_TO_WORKSPACE" event got
     // already sent and we have to notify our state again.
     if (base::ContainsKey(window_state_map_, window)) {
@@ -296,85 +287,81 @@
   EnableBackdropBehindTopWindowOnEachDisplay(true);
   display::Screen::GetScreen()->AddObserver(this);
   Shell::Get()->AddShellObserver(this);
-  Shell::Get()->overview_controller()->AddObserver(this);
   Shell::Get()->split_view_controller()->AddObserver(this);
   event_handler_ = std::make_unique<wm::TabletModeEventHandler>();
 }
 
 void TabletModeWindowManager::ArrangeWindowsForTabletMode() {
-  // |split_view_eligible_windows| is for determining split view layout.
-  // |activatable_windows| includes all windows to be tracked, and that includes
-  // windows on the lock screen via |scoped_skip_user_session_blocked_check|.
-  MruWindowTracker::WindowList split_view_eligible_windows =
-      Shell::Get()->mru_window_tracker()->BuildWindowForCycleList();
+  // We want the build mru list to include windows on the lock screen.
   ScopedSkipUserSessionBlockedCheck scoped_skip_user_session_blocked_check;
-  MruWindowTracker::WindowList activatable_windows =
+
+  MruWindowTracker::WindowList windows =
       Shell::Get()->mru_window_tracker()->BuildWindowListIgnoreModal();
 
-  // If split_view_eligible_windows[0] does not exist, cannot be snapped in
-  // split view, or is ARC or not snapped, then just maximize all windows.
-  if (split_view_eligible_windows.empty() ||
-      !CanSnapInSplitview(split_view_eligible_windows[0]) ||
-      static_cast<ash::AppType>(split_view_eligible_windows[0]->GetProperty(
+  // Specifically check for the case of no windows, so that subsequent logic can
+  // refer to the active window and assume it exists.
+  if (windows.empty())
+    return;
+
+  const mojom::WindowStateType active_window_state_type =
+      wm::GetWindowState(windows[0])->GetStateType();
+
+  // If the active window is ARC or not snapped, then just maximize all windows.
+  if (static_cast<ash::AppType>(windows[0]->GetProperty(
           aura::client::kAppType)) == AppType::ARC_APP ||
-      !wm::GetWindowState(split_view_eligible_windows[0])->IsSnapped()) {
-    for (auto* window : activatable_windows)
-      TrackWindow(window);
+      (active_window_state_type != mojom::WindowStateType::LEFT_SNAPPED &&
+       active_window_state_type != mojom::WindowStateType::RIGHT_SNAPPED)) {
+    for (auto* window : windows)
+      MaximizeAndTrackWindow(window);
     return;
   }
 
-  // Carry over split_view_eligible_windows[0] to split view, along with
-  // split_view_eligible_windows[1] if it exists, is snapped on the opposite
-  // side, can be snapped in split view, and is not ARC.
-  const bool prev_win_eligible =
-      split_view_eligible_windows.size() > 1u &&
-      CanSnapInSplitview(split_view_eligible_windows[1]) &&
-      static_cast<ash::AppType>(split_view_eligible_windows[1]->GetProperty(
+  // The snapped active window will be represented by split view, which will be
+  // activated after maximizing all windows. The split view layout is decided
+  // here by examining window states before all those states become maximized.
+  const bool prev_win_not_arc =
+      windows.size() > 1u && static_cast<ash::AppType>(windows[1]->GetProperty(
           aura::client::kAppType)) != AppType::ARC_APP;
-  std::vector<SplitViewController::SnapPosition> snap_positions;
-  if (wm::GetWindowState(split_view_eligible_windows[0])->GetStateType() ==
-      mojom::WindowStateType::LEFT_SNAPPED) {
-    // split_view_eligible_windows[0] goes on the left.
-    snap_positions.push_back(SplitViewController::LEFT);
+  SplitViewController::SnapPosition curr_win_snap_pos =
+      SplitViewController::NONE;
+  SplitViewController::SnapPosition prev_win_snap_pos =
+      SplitViewController::NONE;
+  if (active_window_state_type == mojom::WindowStateType::LEFT_SNAPPED) {
+    // The active window snapped on the left shall go there in split view.
+    curr_win_snap_pos = SplitViewController::LEFT;
 
-    if (prev_win_eligible &&
-        wm::GetWindowState(split_view_eligible_windows[1])->GetStateType() ==
+    if (prev_win_not_arc && wm::GetWindowState(windows[1])->GetStateType() ==
             mojom::WindowStateType::RIGHT_SNAPPED) {
-      // split_view_eligible_windows[1] goes on the right.
-      snap_positions.push_back(SplitViewController::RIGHT);
+      // The previous window snapped on the right shall go there in split view.
+      prev_win_snap_pos = SplitViewController::RIGHT;
     }
   } else {
-    DCHECK_EQ(
-        mojom::WindowStateType::RIGHT_SNAPPED,
-        wm::GetWindowState(split_view_eligible_windows[0])->GetStateType());
+    DCHECK_EQ(mojom::WindowStateType::RIGHT_SNAPPED, active_window_state_type);
 
-    // split_view_eligible_windows[0] goes on the right.
-    snap_positions.push_back(SplitViewController::RIGHT);
+    // The active window snapped on the right shall go there in split view.
+    curr_win_snap_pos = SplitViewController::RIGHT;
 
-    if (prev_win_eligible &&
-        wm::GetWindowState(split_view_eligible_windows[1])->GetStateType() ==
+    if (prev_win_not_arc && wm::GetWindowState(windows[1])->GetStateType() ==
             mojom::WindowStateType::LEFT_SNAPPED) {
-      // split_view_eligible_windows[1] goes on the left.
-      snap_positions.push_back(SplitViewController::LEFT);
+      // The previous window snapped on the left shall go there in split view.
+      prev_win_snap_pos = SplitViewController::LEFT;
     }
   }
 
-  for (auto* window : activatable_windows) {
-    bool snap = false;
-    for (size_t i = 0u; i < snap_positions.size(); ++i) {
-      if (window == split_view_eligible_windows[i]) {
-        snap = true;
-        break;
-      }
-    }
-    TrackWindow(window, snap, /*animate_bounds_on_attach=*/false);
-  }
+  // Use |defer_bounds_update| to suppress the maximizing animation which would
+  // look weird here, especially when overview appears beside the active window.
+  for (auto* window : windows)
+    MaximizeAndTrackWindow(window, /*defer_bounds_update=*/true);
+
+  // Implement the previously decided split view layout.
   SplitViewController* split_view_controller =
       Shell::Get()->split_view_controller();
-  for (size_t i = 0u; i < snap_positions.size(); ++i) {
-    split_view_controller->SnapWindow(split_view_eligible_windows[i],
-                                      snap_positions[i]);
-  }
+  split_view_controller->SnapWindow(windows[0], curr_win_snap_pos);
+  if (prev_win_snap_pos != SplitViewController::NONE)
+    split_view_controller->SnapWindow(windows[1], prev_win_snap_pos);
+
+  for (auto* window : windows)
+    SetDeferBoundsUpdates(window, false);
 }
 
 void TabletModeWindowManager::ArrangeWindowsForDesktopMode() {
@@ -389,9 +376,9 @@
     iter->second->SetDeferBoundsUpdates(defer_bounds_updates);
 }
 
-void TabletModeWindowManager::TrackWindow(aura::Window* window,
-                                          bool snap,
-                                          bool animate_bounds_on_attach) {
+void TabletModeWindowManager::MaximizeAndTrackWindow(
+    aura::Window* window,
+    bool defer_bounds_updates) {
   if (!ShouldHandleWindow(window))
     return;
 
@@ -401,7 +388,7 @@
   // We create and remember a tablet mode state which will attach itself to
   // the provided state object.
   window_state_map_[window] =
-      new TabletModeWindowState(window, this, snap, animate_bounds_on_attach);
+      new TabletModeWindowState(window, this, defer_bounds_updates);
 }
 
 void TabletModeWindowManager::ForgetWindow(aura::Window* window,
--- a/ash/wm/tablet_mode/tablet_mode_window_manager.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/tablet_mode/tablet_mode_window_manager.h	2019-05-17 18:53:08.384000000 +0300
@@ -12,7 +12,6 @@
 
 #include "ash/ash_export.h"
 #include "ash/shell_observer.h"
-#include "ash/wm/overview/overview_observer.h"
 #include "ash/wm/splitview/split_view_controller.h"
 #include "ash/wm/window_state.h"
 #include "base/macros.h"
@@ -41,7 +40,6 @@
     : public aura::WindowObserver,
       public display::DisplayObserver,
       public ShellObserver,
-      public OverviewObserver,
       public SplitViewController::Observer {
  public:
   // This should only be deleted by the creator (ash::Shell).
@@ -60,12 +58,10 @@
   void WindowStateDestroyed(aura::Window* window);
 
   // ShellObserver:
-  void OnSplitViewModeEnded() override;
-
-  // OverviewObserver:
   void OnOverviewModeStarting() override;
   void OnOverviewModeEnding(OverviewSession* overview_session) override;
   void OnOverviewModeEnded() override;
+  void OnSplitViewModeEnded() override;
 
   // aura::WindowObserver:
   void OnWindowDestroying(aura::Window* window) override;
@@ -113,13 +109,13 @@
   // will be updated as they may be stale.
   void SetDeferBoundsUpdates(aura::Window* window, bool defer_bounds_updates);
 
-  // If the given window should be handled by us, this function will add it to
-  // the list of known windows (remembering the initial show state).
+  // If the given window should be handled by us, this function will maximize it
+  // and add it to the list of known windows (remembering the initial show
+  // state).
   // Note: If the given window cannot be handled by us the function will return
   // immediately.
-  void TrackWindow(aura::Window* window,
-                   bool snap = false,
-                   bool animate_bounds_on_attach = true);
+  void MaximizeAndTrackWindow(aura::Window* window,
+                              bool defer_bounds_updates = false);
 
   // Remove a window from our tracking list. If the window is going to be
   // destroyed, do not restore its old previous window state object as it will
--- a/ash/wm/tablet_mode/tablet_mode_window_state.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/tablet_mode/tablet_mode_window_state.cc	2019-05-17 18:53:08.384000000 +0300
@@ -77,10 +77,8 @@
 
 // Returns the maximized/full screen and/or centered bounds of a window.
 gfx::Rect GetBoundsInMaximizedMode(wm::WindowState* state_object) {
-  if (state_object->IsFullscreen() || state_object->IsPinned()) {
-    return screen_util::GetFullscreenWindowBoundsInParent(
-        state_object->window());
-  }
+  if (state_object->IsFullscreen() || state_object->IsPinned())
+    return screen_util::GetDisplayBoundsInParent(state_object->window());
 
   if (state_object->GetStateType() == mojom::WindowStateType::LEFT_SNAPPED) {
     return Shell::Get()
@@ -170,18 +168,14 @@
 
 TabletModeWindowState::TabletModeWindowState(aura::Window* window,
                                              TabletModeWindowManager* creator,
-                                             bool snap,
-                                             bool animate_bounds_on_attach)
+                                             bool defer_bounds_updates)
     : window_(window),
       creator_(creator),
-      animate_bounds_on_attach_(animate_bounds_on_attach) {
-  wm::WindowState* state = wm::GetWindowState(window);
-  current_state_type_ = state->GetStateType();
-  DCHECK(!snap || CanSnapInSplitview(window));
-  state_type_on_attach_ =
-      snap ? current_state_type_ : GetMaximizedOrCenteredWindowType(state);
-  old_state_.reset(
-      state->SetStateObject(std::unique_ptr<State>(this)).release());
+      current_state_type_(wm::GetWindowState(window)->GetStateType()),
+      defer_bounds_updates_(defer_bounds_updates) {
+  old_state_.reset(wm::GetWindowState(window)
+                       ->SetStateObject(std::unique_ptr<State>(this))
+                       .release());
 }
 
 TabletModeWindowState::~TabletModeWindowState() {
@@ -347,13 +341,14 @@
                               window_state->GetShowState());
   }
 
+  // Initialize the state to a good preset.
   if (current_state_type_ != mojom::WindowStateType::MAXIMIZED &&
       current_state_type_ != mojom::WindowStateType::MINIMIZED &&
       current_state_type_ != mojom::WindowStateType::FULLSCREEN &&
       current_state_type_ != mojom::WindowStateType::PINNED &&
       current_state_type_ != mojom::WindowStateType::TRUSTED_PINNED) {
-    UpdateWindow(window_state, state_type_on_attach_,
-                 animate_bounds_on_attach_);
+    UpdateWindow(window_state, GetMaximizedOrCenteredWindowType(window_state),
+                 true /* animated */);
   }
 }
 
--- a/ash/wm/tablet_mode/tablet_mode_window_state.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/tablet_mode/tablet_mode_window_state.h	2019-05-17 18:53:08.384000000 +0300
@@ -23,18 +23,12 @@
   static void UpdateWindowPosition(wm::WindowState* window_state, bool animate);
 
   // The |window|'s state object will be modified to use this new window mode
-  // state handler. |snap| is for carrying over a snapped state from clamshell
-  // mode to tablet mode. If |snap| is false, then the window will be maximized,
-  // unless the original state was MAXIMIZED, MINIMIZED, FULLSCREEN, PINNED, or
-  // TRUSTED_PINNED. Use |animate_bounds_on_attach| to specify whether to
-  // animate the corresponding bounds update. Call LeaveTabletMode() to restore
-  // the previous state handler, whereupon ~TabletModeWindowState() will call
-  // |creator::WindowStateDestroyed()| to inform that the window mode was
-  // reverted to the old window manager.
+  // state handler. Upon destruction it will restore the previous state handler
+  // and call |creator::WindowStateDestroyed()| to inform that the window mode
+  // was reverted to the old window manager.
   TabletModeWindowState(aura::Window* window,
                         TabletModeWindowManager* creator,
-                        bool snap,
-                        bool animate_bounds_on_attach);
+                        bool defer_bounds_updates);
   ~TabletModeWindowState() override;
 
   void set_ignore_wm_events(bool ignore) { ignore_wm_events_ = ignore; }
@@ -96,15 +90,6 @@
   // The creator which needs to be informed when this state goes away.
   TabletModeWindowManager* creator_;
 
-  // The state type to be established in AttachState(), unless
-  // previous_state->GetType() is MAXIMIZED, MINIMIZED, FULLSCREEN, PINNED, or
-  // TRUSTED_PINNED.
-  mojom::WindowStateType state_type_on_attach_;
-
-  // Whether to animate in case of a bounds update when switching to
-  // |state_type_on_attach_|.
-  bool animate_bounds_on_attach_;
-
   // The current state type. Due to the nature of this state, this can only be
   // WM_STATE_TYPE{NORMAL, MINIMIZED, MAXIMIZED}.
   mojom::WindowStateType current_state_type_;
--- a/ash/wm/toplevel_window_event_handler.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/toplevel_window_event_handler.cc	2019-05-17 18:53:08.384000000 +0300
@@ -6,7 +6,6 @@
 
 #include "ash/shell.h"
 #include "ash/wm/window_state.h"
-#include "base/bind.h"
 #include "base/run_loop.h"
 #include "ui/aura/client/cursor_client.h"
 #include "ui/aura/env.h"
@@ -51,9 +50,13 @@
   ::wm::WindowMoveSource source = gesture_target
                                       ? ::wm::WINDOW_MOVE_SOURCE_TOUCH
                                       : ::wm::WINDOW_MOVE_SOURCE_MOUSE;
+  if (gesture_target) {
+    window->env()->gesture_recognizer()->TransferEventsTo(
+        gesture_target, window, ui::TransferTouchesBehavior::kDontCancel);
+  }
   return wm_toplevel_window_event_handler_.AttemptToStartDrag(
-      window, point_in_parent, window_component, source, std::move(end_closure),
-      /*update_gesture_target=*/true);
+      window, point_in_parent, window_component, source,
+      std::move(end_closure));
 }
 
 ::wm::WindowMoveResult ToplevelWindowEventHandler::RunMoveLoop(
@@ -92,8 +95,7 @@
   if (!wm_toplevel_window_event_handler_.AttemptToStartDrag(
           source, drag_location, HTCAPTION, move_source,
           base::Bind(&ToplevelWindowEventHandler::OnDragCompleted,
-                     weak_factory_.GetWeakPtr(), &result, &run_loop),
-          /*update_gesture_target=*/false)) {
+                     weak_factory_.GetWeakPtr(), &result, &run_loop))) {
     return ::wm::MOVE_CANCELED;
   }
 
--- a/ash/wm/toplevel_window_event_handler_unittest.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/toplevel_window_event_handler_unittest.cc	2019-05-17 18:53:08.384000000 +0300
@@ -15,7 +15,6 @@
 #include "ash/wm/window_util.h"
 #include "ash/wm/wm_event.h"
 #include "ash/wm/workspace_controller.h"
-#include "base/bind.h"
 #include "base/compiler_specific.h"
 #include "base/run_loop.h"
 #include "base/threading/thread_task_runner_handle.h"
@@ -26,7 +25,6 @@
 #include "ui/aura/test/aura_test_base.h"
 #include "ui/aura/test/test_window_delegate.h"
 #include "ui/aura/window_event_dispatcher.h"
-#include "ui/aura/window_observer.h"
 #include "ui/base/hit_test.h"
 #include "ui/display/display_layout_builder.h"
 #include "ui/display/manager/display_manager.h"
@@ -56,39 +54,6 @@
   DISALLOW_COPY_AND_ASSIGN(TestWindowDelegate);
 };
 
-class ResizeLoopWindowObserver : public aura::WindowObserver {
- public:
-  explicit ResizeLoopWindowObserver(aura::Window* w) : window_(w) {
-    window_->AddObserver(this);
-  }
-  ~ResizeLoopWindowObserver() override {
-    if (window_)
-      window_->RemoveObserver(this);
-  }
-
-  bool in_resize_loop() const { return in_resize_loop_; }
-
-  // aura::WindowObserver:
-  void OnResizeLoopStarted(aura::Window* window) override {
-    EXPECT_FALSE(in_resize_loop_);
-    in_resize_loop_ = true;
-  }
-  void OnResizeLoopEnded(aura::Window* window) override {
-    EXPECT_TRUE(in_resize_loop_);
-    in_resize_loop_ = false;
-  }
-  void OnWindowDestroying(aura::Window* window) override {
-    window_->RemoveObserver(this);
-    window_ = nullptr;
-  }
-
- private:
-  aura::Window* window_;
-  bool in_resize_loop_ = false;
-
-  DISALLOW_COPY_AND_ASSIGN(ResizeLoopWindowObserver);
-};
-
 class ToplevelWindowEventHandlerTest : public AshTestBase {
  public:
   ToplevelWindowEventHandlerTest() = default;
@@ -172,9 +137,8 @@
       ::wm::GetWindowMoveClient(w1->GetRootWindow());
   base::ThreadTaskRunnerHandle::Get()->PostTask(
       FROM_HERE,
-      base::BindOnce(&ContinueAndCompleteDrag, base::Unretained(&generator),
-                     base::Unretained(window_state),
-                     base::Unretained(w1.get())));
+      base::Bind(&ContinueAndCompleteDrag, base::Unretained(&generator),
+                 base::Unretained(window_state), base::Unretained(w1.get())));
   EXPECT_EQ(::wm::MOVE_SUCCESSFUL,
             move_client->RunMoveLoop(w1.get(), gfx::Vector2d(100, 100),
                                      ::wm::WINDOW_MOVE_SOURCE_MOUSE));
@@ -191,9 +155,8 @@
   generator.PressLeftButton();
   base::ThreadTaskRunnerHandle::Get()->PostTask(
       FROM_HERE,
-      base::BindOnce(&ContinueAndCompleteDrag, base::Unretained(&generator),
-                     base::Unretained(window_state),
-                     base::Unretained(w1.get())));
+      base::Bind(&ContinueAndCompleteDrag, base::Unretained(&generator),
+                 base::Unretained(window_state), base::Unretained(w1.get())));
   EXPECT_EQ(::wm::MOVE_SUCCESSFUL,
             move_client->RunMoveLoop(w1.get(), gfx::Vector2d(100, 100),
                                      ::wm::WINDOW_MOVE_SOURCE_MOUSE));
@@ -230,7 +193,7 @@
   // Size should have increased by 100,100.
   EXPECT_EQ(gfx::Size(200, 200).ToString(), w1->bounds().size().ToString());
 
-  // Shrink the window by (-100, -100).
+  // Shrink the wnidow by (-100, -100).
   generator.DragMouseBy(-100, -100);
   // Position should not have changed.
   EXPECT_EQ(position.ToString(), w1->bounds().origin().ToString());
@@ -1019,9 +982,9 @@
   ::wm::WindowMoveClient* move_client =
       ::wm::GetWindowMoveClient(window->GetRootWindow());
   base::ThreadTaskRunnerHandle::Get()->PostTask(
-      FROM_HERE, base::BindOnce(&SendMouseReleaseAndReleaseCapture,
-                                base::Unretained(&generator),
-                                base::Unretained(window.get())));
+      FROM_HERE,
+      base::Bind(&SendMouseReleaseAndReleaseCapture,
+                 base::Unretained(&generator), base::Unretained(window.get())));
   EXPECT_EQ(::wm::MOVE_SUCCESSFUL,
             move_client->RunMoveLoop(window.get(), gfx::Vector2d(),
                                      ::wm::WINDOW_MOVE_SOURCE_MOUSE));
@@ -1046,7 +1009,7 @@
   ::wm::WindowMoveClient* move_client =
       ::wm::GetWindowMoveClient(window->GetRootWindow());
   base::ThreadTaskRunnerHandle::Get()->PostTask(
-      FROM_HERE, base::BindOnce(&CheckHasCaptureAndReleaseCapture,
+      FROM_HERE, base::Bind(&CheckHasCaptureAndReleaseCapture,
                                 base::Unretained(window.get())));
   EXPECT_EQ(::wm::MOVE_SUCCESSFUL,
             move_client->RunMoveLoop(window.get(), gfx::Vector2d(),
@@ -1090,37 +1053,6 @@
       w1->GetBoundsInScreen()));
 }
 
-TEST_F(ToplevelWindowEventHandlerTest, MoveDoesntEnterResizeLoop) {
-  std::unique_ptr<aura::Window> w1(CreateWindow(HTCAPTION));
-  ResizeLoopWindowObserver window_observer(w1.get());
-  ui::test::EventGenerator generator(Shell::GetPrimaryRootWindow(), w1.get());
-  // A click on the caption does not trigger the resize loop.
-  generator.PressLeftButton();
-  EXPECT_FALSE(window_observer.in_resize_loop());
-
-  // A move in the caption does not trigger the resize loop either.
-  generator.MoveMouseBy(100, 100);
-  EXPECT_FALSE(window_observer.in_resize_loop());
-  w1->RemoveObserver(&window_observer);
-}
-
-TEST_F(ToplevelWindowEventHandlerTest, EnterResizeLoopOnResize) {
-  std::unique_ptr<aura::Window> w1(CreateWindow(HTGROWBOX));
-  ResizeLoopWindowObserver window_observer(w1.get());
-  ui::test::EventGenerator generator(Shell::GetPrimaryRootWindow(), w1.get());
-  // The resize loop is entered once a possible resize is detected.
-  generator.PressLeftButton();
-  EXPECT_TRUE(window_observer.in_resize_loop());
-
-  // Should remain in the resize loop while dragging.
-  generator.MoveMouseBy(100, 100);
-  EXPECT_TRUE(window_observer.in_resize_loop());
-
-  // Releasing the button should end the loop.
-  generator.ReleaseLeftButton();
-  EXPECT_FALSE(window_observer.in_resize_loop());
-}
-
 // Showing the resize shadows when the mouse is over the window edges is
 // tested in resize_shadow_and_cursor_test.cc
 
--- a/ash/wm/top_level_window_factory.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/top_level_window_factory.cc	2019-05-17 18:53:08.384000000 +0300
@@ -18,7 +18,6 @@
 #include "services/ws/public/cpp/property_type_converters.h"
 #include "services/ws/public/mojom/window_manager.mojom.h"
 #include "services/ws/public/mojom/window_tree_constants.mojom.h"
-#include "services/ws/top_level_proxy_window.h"
 #include "services/ws/window_delegate_impl.h"
 #include "services/ws/window_properties.h"
 #include "ui/aura/client/aura_constants.h"
@@ -119,7 +118,6 @@
 // Does the real work of CreateAndParentTopLevelWindow() once the appropriate
 // RootWindowController was found.
 aura::Window* CreateAndParentTopLevelWindowInRoot(
-    ws::TopLevelProxyWindow* top_level_proxy_window,
     RootWindowController* root_window_controller,
     ws::mojom::WindowType window_type,
     aura::PropertyConverter* property_converter,
@@ -144,8 +142,8 @@
   if (provide_non_client_frame) {
     // See NonClientFrameController for details on lifetime.
     NonClientFrameController* non_client_frame_controller =
-        new NonClientFrameController(top_level_proxy_window, container_window,
-                                     context, bounds, property_converter,
+        new NonClientFrameController(container_window, context, bounds,
+                                     window_type, property_converter,
                                      properties);
     return non_client_frame_controller->window();
   }
@@ -157,7 +155,7 @@
   window_delegate->set_window(window);
   aura::SetWindowType(window, window_type);
   ApplyProperties(window, property_converter, *properties);
-  window->Init(ui::LAYER_NOT_DRAWN);
+  window->Init(ui::LAYER_TEXTURED);
 
   if (container_window) {
     // |bounds| are in local coordinates.
@@ -177,7 +175,6 @@
 }  // namespace
 
 aura::Window* CreateAndParentTopLevelWindow(
-    ws::TopLevelProxyWindow* top_level_proxy_window,
     ws::mojom::WindowType window_type,
     aura::PropertyConverter* property_converter,
     std::map<std::string, std::vector<uint8_t>>* properties) {
@@ -187,8 +184,7 @@
   RootWindowController* root_window_controller =
       GetRootWindowControllerForNewTopLevelWindow(properties);
   aura::Window* window = CreateAndParentTopLevelWindowInRoot(
-      top_level_proxy_window, root_window_controller, window_type,
-      property_converter, properties);
+      root_window_controller, window_type, property_converter, properties);
   DisconnectedAppHandler::Create(window);
 
   // TODO: kFocusable_InitProperty should be removed. http://crbug.com/837713.
@@ -200,7 +196,7 @@
         NonClientFrameController::Get(window);
     window->SetProperty(ws::kCanFocus, can_focus);
     if (non_client_frame_controller)
-      non_client_frame_controller->SetCanActivate(can_focus);
+      non_client_frame_controller->set_can_activate(can_focus);
     // No need to persist this value.
     properties->erase(focusable_iter);
   }
--- a/ash/wm/top_level_window_factory.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/top_level_window_factory.h	2019-05-17 18:53:08.384000000 +0300
@@ -22,7 +22,6 @@
 namespace mojom {
 enum class WindowType;
 }
-class TopLevelProxyWindow;
 }  // namespace ws
 
 namespace ash {
@@ -31,7 +30,6 @@
 // aura::Window is owned by its parent. A value of null is returned if invalid
 // poarameters are supplied.
 ASH_EXPORT aura::Window* CreateAndParentTopLevelWindow(
-    ws::TopLevelProxyWindow* top_level_proxy_window,
     ws::mojom::WindowType window_type,
     aura::PropertyConverter* property_converter,
     std::map<std::string, std::vector<uint8_t>>* properties);
--- a/ash/wm/video_detector.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/video_detector.cc	2019-05-17 18:53:08.384000000 +0300
@@ -7,7 +7,6 @@
 #include "ash/public/cpp/shell_window_ids.h"
 #include "ash/shell.h"
 #include "ash/wm/window_state.h"
-#include "base/bind.h"
 #include "components/viz/host/host_frame_sink_manager.h"
 #include "ui/aura/env.h"
 #include "ui/aura/window.h"
--- a/ash/wm/window_animations.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/window_animations.cc	2019-05-17 18:53:08.384000000 +0300
@@ -10,8 +10,8 @@
 #include <utility>
 #include <vector>
 
-#include "ash/home_screen/home_launcher_gesture_handler.h"
-#include "ash/home_screen/home_screen_controller.h"
+#include "ash/app_list/app_list_controller_impl.h"
+#include "ash/app_list/home_launcher_gesture_handler.h"
 #include "ash/public/cpp/window_animation_types.h"
 #include "ash/shelf/shelf.h"
 #include "ash/shell.h"
@@ -246,17 +246,17 @@
 }
 
 bool AnimateShowWindow_SlideDown(aura::Window* window) {
-  HomeScreenController* home_screen_controller =
-      Shell::Get()->home_screen_controller();
+  AppListControllerImpl* app_list_controller =
+      Shell::Get()->app_list_controller();
   const TabletModeController* tablet_mode_controller =
       Shell::Get()->tablet_mode_controller();
 
-  if (home_screen_controller && tablet_mode_controller &&
+  if (app_list_controller && tablet_mode_controller &&
       tablet_mode_controller->IsTabletModeWindowManagerEnabled()) {
     // Slide down the window from above screen to show and, meanwhile, slide
     // down the home launcher off screen.
     HomeLauncherGestureHandler* handler =
-        home_screen_controller->home_launcher_gesture_handler();
+        app_list_controller->home_launcher_gesture_handler();
     if (handler &&
         handler->HideHomeLauncherForWindow(
             display::Screen::GetScreen()->GetDisplayNearestView(window),
--- a/ash/wm/window_animations_unittest.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/window_animations_unittest.cc	2019-05-17 18:53:08.384000000 +0300
@@ -326,7 +326,7 @@
       ui::ScopedAnimationDurationScaleMode::ZERO_DURATION);
 
   std::unique_ptr<aura::Window> window(CreateTestWindowInShellWithId(0));
-  window->SetBounds(gfx::Rect(8, 8, 100, 100));
+  window->SetBounds(gfx::Rect(0, 0, 100, 100));
 
   wm::WindowState* window_state = wm::GetWindowState(window.get());
   const wm::WMEvent enter_pip(wm::WM_EVENT_PIP);
@@ -335,25 +335,23 @@
 
   window->Show();
   EXPECT_TRUE(window->layer()->visible());
-  EXPECT_EQ("8,8 100x100", window->layer()->GetTargetBounds().ToString());
 
   window->Hide();
   EXPECT_EQ(0.0f, window->layer()->GetTargetOpacity());
   EXPECT_FALSE(window->layer()->GetTargetVisibility());
   EXPECT_FALSE(window->layer()->visible());
-  EXPECT_EQ("-142,8 100x100", window->layer()->GetTargetBounds().ToString());
+  EXPECT_EQ("-150,0 100x100", window->layer()->GetTargetBounds().ToString());
 
   // Reset the position and try again.
   window->Show();
-  window->SetBounds(gfx::Rect(8, 8, 100, 100));
+  window->SetBounds(gfx::Rect(0, 0, 100, 100));
   EXPECT_TRUE(window->layer()->visible());
-  EXPECT_EQ("8,8 100x100", window->layer()->GetTargetBounds().ToString());
 
   window->Hide();
   EXPECT_EQ(0.0f, window->layer()->GetTargetOpacity());
   EXPECT_FALSE(window->layer()->GetTargetVisibility());
   EXPECT_FALSE(window->layer()->visible());
-  EXPECT_EQ("-142,8 100x100", window->layer()->GetTargetBounds().ToString());
+  EXPECT_EQ("-150,0 100x100", window->layer()->GetTargetBounds().ToString());
 }
 
 }  // namespace ash
--- a/ash/wm/window_cycle_event_filter.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/window_cycle_event_filter.cc	2019-05-17 18:53:08.388000000 +0300
@@ -8,7 +8,6 @@
 #include "ash/shell.h"
 #include "ash/wm/window_cycle_controller.h"
 #include "ash/wm/window_cycle_list.h"
-#include "base/bind.h"
 #include "ui/events/event.h"
 
 namespace ash {
--- a/ash/wm/window_finder_unittest.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/window_finder_unittest.cc	2019-05-17 18:53:08.388000000 +0300
@@ -141,10 +141,10 @@
   OverviewGrid* grid =
       overview_controller->overview_session()->GetGridWithRootWindow(
           window1->GetRootWindow());
-  gfx::Rect bounds1 = gfx::ToEnclosedRect(
-      grid->GetOverviewItemContaining(window1.get())->target_bounds());
-  gfx::Rect bounds2 = gfx::ToEnclosedRect(
-      grid->GetOverviewItemContaining(window2.get())->target_bounds());
+  gfx::Rect bounds1 =
+      grid->GetOverviewItemContaining(window1.get())->target_bounds();
+  gfx::Rect bounds2 =
+      grid->GetOverviewItemContaining(window2.get())->target_bounds();
 
   std::set<aura::Window*> ignore;
   aura::Window* real_topmost = nullptr;
--- a/ash/wm/window_mirror_view.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/window_mirror_view.cc	2019-05-17 18:53:08.388000000 +0300
@@ -7,14 +7,10 @@
 #include <algorithm>
 #include <memory>
 
-#include "ash/wm/non_client_frame_controller.h"
 #include "ash/wm/widget_finder.h"
 #include "ash/wm/window_state.h"
-#include "services/ws/top_level_proxy_window.h"
 #include "ui/aura/client/aura_constants.h"
-#include "ui/aura/env.h"
 #include "ui/aura/window.h"
-#include "ui/aura/window_occlusion_tracker.h"
 #include "ui/compositor/layer.h"
 #include "ui/compositor/layer_tree_owner.h"
 #include "ui/views/widget/widget.h"
@@ -136,10 +132,6 @@
   target_ = GetWidget()->GetNativeWindow();
   target_->TrackOcclusionState();
 
-  force_occlusion_tracker_visible_.reset();
-  force_proxy_window_visible_.reset();
-  env_observer_.RemoveAll();
-
   // Allocate new memory for |target_window_list| here because as soon as a
   // call is made to SetProperty, the previous memory will be deallocated.
   auto temp_list =
@@ -154,19 +146,6 @@
   // NOTE: This will deallocate the current property value so make sure new
   // memory has been allocated for the property value.
   source_->SetProperty(aura::client::kMirrorWindowList, temp_list.release());
-
-  // If |source_| represents a remote client, it needs to be made visible,
-  // otherwise it won't produce frames.
-  if (target_ && NonClientFrameController::Get(source_)) {
-    // Wait for window-occlusion tracker to be running before forcing
-    // visibility. This is done to minimize the amount of work during the
-    // initial animation when entering overview. In particular, telling the
-    // remote client it is visible is likely to result in a fair amount of work.
-    if (source_->env()->GetWindowOcclusionTracker()->IsPaused())
-      env_observer_.Add(target_->env());
-    else
-      ForceVisibilityAndOcclusionForProxyWindow();
-  }
 }
 
 void WindowMirrorView::InitLayerOwner() {
@@ -212,27 +191,5 @@
   return client_view->ConvertRectToWidget(client_view->GetLocalBounds());
 }
 
-void WindowMirrorView::ForceVisibilityAndOcclusionForProxyWindow() {
-  NonClientFrameController* frame_controller =
-      NonClientFrameController::Get(source_);
-  // Earlier checks ensure we only get here if there is a
-  // NonClientFrameController.
-  DCHECK(frame_controller);
-  // In order for the remote client to produce frames the client needs to think
-  // the window is visible. It may not actually be visible now, so force it.
-  force_proxy_window_visible_ =
-      frame_controller->top_level_proxy_window()->ForceVisible();
-
-  // Similarly, force the occlusion tracker to treat the source as visible.
-  force_occlusion_tracker_visible_ =
-      std::make_unique<aura::WindowOcclusionTracker::ScopedForceVisible>(
-          source_);
-}
-
-void WindowMirrorView::OnWindowOcclusionTrackingResumed() {
-  ForceVisibilityAndOcclusionForProxyWindow();
-  env_observer_.RemoveAll();
-}
-
 }  // namespace wm
 }  // namespace ash
--- a/ash/wm/window_mirror_view.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/window_mirror_view.h	2019-05-17 18:53:08.388000000 +0300
@@ -9,10 +9,6 @@
 
 #include "ash/ash_export.h"
 #include "base/macros.h"
-#include "base/scoped_observer.h"
-#include "ui/aura/env.h"
-#include "ui/aura/env_observer.h"
-#include "ui/aura/window_occlusion_tracker.h"
 #include "ui/views/view.h"
 
 namespace aura {
@@ -23,16 +19,12 @@
 class LayerTreeOwner;
 }
 
-namespace ws {
-class ScopedForceVisible;
-}
-
 namespace ash {
+
 namespace wm {
 
 // A view that mirrors the client area of a single (source) window.
-class ASH_EXPORT WindowMirrorView : public views::View,
-                                    public aura::EnvObserver {
+class ASH_EXPORT WindowMirrorView : public views::View {
  public:
   WindowMirrorView(aura::Window* source, bool trilinear_filtering_on_init);
   ~WindowMirrorView() override;
@@ -68,11 +60,6 @@
   // coordinate space.
   gfx::Rect GetClientAreaBounds() const;
 
-  void ForceVisibilityAndOcclusionForProxyWindow();
-
-  // aura::EnvObserver:
-  void OnWindowOcclusionTrackingResumed() override;
-
   // The original window that is being represented by |this|.
   aura::Window* source_;
 
@@ -87,14 +74,6 @@
   // InitLayerOwner().
   bool trilinear_filtering_on_init_;
 
-  // These are used when mirroring a window from a remote client (a proxy
-  // window from the window-service).
-  std::unique_ptr<aura::WindowOcclusionTracker::ScopedForceVisible>
-      force_occlusion_tracker_visible_;
-  std::unique_ptr<ws::ScopedForceVisible> force_proxy_window_visible_;
-
-  ScopedObserver<aura::Env, aura::EnvObserver> env_observer_{this};
-
   DISALLOW_COPY_AND_ASSIGN(WindowMirrorView);
 };
 
--- a/ash/wm/window_mirror_view_unittest.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/window_mirror_view_unittest.cc	2019-05-17 18:53:08.388000000 +0300
@@ -6,15 +6,10 @@
 
 #include "ash/test/ash_test_base.h"
 #include "mojo/public/cpp/bindings/map.h"
-#include "services/ws/client_root.h"
-#include "services/ws/client_root_test_helper.h"
-#include "services/ws/proxy_window.h"
 #include "services/ws/window_tree_test_helper.h"
 #include "ui/aura/client/aura_constants.h"
-#include "ui/aura/window_occlusion_tracker.h"
 #include "ui/gfx/geometry/size.h"
 #include "ui/views/widget/widget.h"
-#include "ui/views/widget/widget_delegate.h"
 
 namespace ash {
 namespace wm {
@@ -38,58 +33,6 @@
   EXPECT_FALSE(mirror_view->CalculatePreferredSize().IsEmpty());
 }
 
-TEST_F(WindowMirrorViewTest, RemoteClientForcedVisible) {
-  auto properties = CreatePropertiesForProxyWindow(gfx::Rect(0, 0, 400, 300));
-  std::unique_ptr<aura::Window> window(
-      GetWindowTreeTestHelper()->NewTopLevelWindow(
-          mojo::MapToFlatMap(properties)));
-
-  ws::ClientRootTestHelper client_root_test_helper(
-      ws::ProxyWindow::GetMayBeNull(window.get())
-          ->owning_window_tree()
-          ->GetClientRootForWindow(window.get()));
-  EXPECT_FALSE(client_root_test_helper.IsWindowForcedVisible());
-  // Assertions only make sense if window occlusion tracker is running, which it
-  // should be at this point.
-  EXPECT_FALSE(window->env()->GetWindowOcclusionTracker()->IsPaused());
-  auto widget = CreateTestWidget();
-  widget->Hide();
-  auto mirror_view = std::make_unique<WindowMirrorView>(
-      window.get(), /*trilinear_filtering_on_init=*/false);
-  widget->widget_delegate()->GetContentsView()->AddChildView(mirror_view.get());
-  // Even though the widget is hidden, the remote client should think it's
-  // visible.
-  EXPECT_TRUE(client_root_test_helper.IsWindowForcedVisible());
-}
-
-TEST_F(WindowMirrorViewTest, RemoteClientForcedVisibleWhenRunning) {
-  auto properties = CreatePropertiesForProxyWindow(gfx::Rect(0, 0, 400, 300));
-  std::unique_ptr<aura::Window> window(
-      GetWindowTreeTestHelper()->NewTopLevelWindow(
-          mojo::MapToFlatMap(properties)));
-
-  ws::ClientRootTestHelper client_root_test_helper(
-      ws::ProxyWindow::GetMayBeNull(window.get())
-          ->owning_window_tree()
-          ->GetClientRootForWindow(window.get()));
-
-  auto pause_occlusion_tracker =
-      std::make_unique<aura::WindowOcclusionTracker::ScopedPause>(
-          window->env());
-  auto widget = CreateTestWidget();
-  widget->Hide();
-  auto mirror_view = std::make_unique<WindowMirrorView>(
-      window.get(), /*trilinear_filtering_on_init=*/false);
-  widget->widget_delegate()->GetContentsView()->AddChildView(mirror_view.get());
-
-  // As occlusion tracking is paused, the remote window should remain hidden.
-  EXPECT_FALSE(client_root_test_helper.IsWindowForcedVisible());
-
-  // When occlusion tracking is enabled, the remote window shoul be visible.
-  pause_occlusion_tracker.reset();
-  EXPECT_TRUE(client_root_test_helper.IsWindowForcedVisible());
-}
-
 }  // namespace
 }  // namespace wm
 }  // namespace ash
--- a/ash/wm/window_properties.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/window_properties.cc	2019-05-17 18:53:08.388000000 +0300
@@ -7,19 +7,19 @@
 #include "ash/wm/window_state.h"
 #include "ui/gfx/geometry/rect.h"
 
-DEFINE_EXPORTED_UI_CLASS_PROPERTY_TYPE(ASH_EXPORT, ash::wm::WindowState*)
-DEFINE_EXPORTED_UI_CLASS_PROPERTY_TYPE(ASH_EXPORT, ash::WidgetCreationType)
+DEFINE_EXPORTED_UI_CLASS_PROPERTY_TYPE(ASH_EXPORT, ash::wm::WindowState*);
+DEFINE_EXPORTED_UI_CLASS_PROPERTY_TYPE(ASH_EXPORT, ash::WidgetCreationType);
 
 namespace ash {
 
-DEFINE_UI_CLASS_PROPERTY_KEY(bool, kLockedToRootKey, false)
+DEFINE_UI_CLASS_PROPERTY_KEY(bool, kLockedToRootKey, false);
 
 DEFINE_UI_CLASS_PROPERTY_KEY(WidgetCreationType,
                              kWidgetCreationTypeKey,
-                             WidgetCreationType::INTERNAL)
+                             WidgetCreationType::INTERNAL);
 
-DEFINE_UI_CLASS_PROPERTY_KEY(bool, kWindowIsJanky, false)
+DEFINE_UI_CLASS_PROPERTY_KEY(bool, kWindowIsJanky, false);
 
-DEFINE_OWNED_UI_CLASS_PROPERTY_KEY(ash::wm::WindowState, kWindowStateKey, NULL)
+DEFINE_OWNED_UI_CLASS_PROPERTY_KEY(ash::wm::WindowState, kWindowStateKey, NULL);
 
 }  // namespace ash
--- a/ash/wm/window_resizer.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/window_resizer.cc	2019-05-17 18:53:08.388000000 +0300
@@ -7,40 +7,20 @@
 #include "ash/wm/root_window_finder.h"
 #include "ash/wm/window_positioning_utils.h"
 #include "ash/wm/window_state.h"
-#include "base/bind.h"
-#include "base/metrics/histogram_macros.h"
-#include "base/time/time.h"
 #include "ui/aura/client/aura_constants.h"
 #include "ui/aura/window.h"
 #include "ui/aura/window_delegate.h"
-#include "ui/aura/window_tracker.h"
-#include "ui/aura/window_tree_host.h"
 #include "ui/base/hit_test.h"
 #include "ui/base/ui_base_types.h"
-#include "ui/compositor/compositor.h"
 #include "ui/display/display.h"
 #include "ui/display/screen.h"
 #include "ui/gfx/geometry/rect.h"
-#include "ui/gfx/presentation_feedback.h"
 #include "ui/views/window/window_resize_utils.h"
 #include "ui/wm/core/coordinate_conversion.h"
 
 namespace ash {
-namespace {
-
-void OnFramePresented(base::TimeTicks start_time,
-                      const gfx::PresentationFeedback& feedback) {
-  UMA_HISTOGRAM_TIMES("Ash.InteractiveWindowResize.TimeToPresent",
-                      feedback.timestamp - start_time);
-}
 
-void RecordMetricsForResize(base::TimeTicks start_time, aura::Window* window) {
-  DCHECK(window);
-  ui::Compositor* compositor = window->GetHost()->compositor();
-  DCHECK(compositor);
-  compositor->RequestPresentationTimeForNextFrame(
-      base::BindOnce(&OnFramePresented, start_time));
-}
+namespace {
 
 // Returns true for resize components along the right edge, where a drag in
 // positive x will make the window larger.
@@ -276,22 +256,6 @@
          window_component == HTBOTTOMRIGHT || window_component == HTGROWBOX;
 }
 
-void WindowResizer::SetBoundsDuringResize(const gfx::Rect& bounds) {
-  aura::Window* window = GetTarget();
-  DCHECK(window);
-  // Consider having this time come from the event.
-  base::TimeTicks start = base::TimeTicks::Now();
-  const gfx::Rect original_bounds = window->bounds();
-  window->SetBounds(bounds);
-  aura::WindowTracker tracker;
-  tracker.Add(window);
-  if (tracker.windows().empty())
-    return;  // Assume we've been destroyed.
-  if (bounds.size() == original_bounds.size())
-    return;
-  RecordMetricsForResize(start, window);
-}
-
 void WindowResizer::AdjustDeltaForTouchResize(int* delta_x, int* delta_y) {
   if (details().source != ::wm::WINDOW_MOVE_SOURCE_TOUCH ||
       !(details().bounds_change & kBoundsChange_Resizes))
--- a/ash/wm/window_resizer.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/window_resizer.h	2019-05-17 18:53:08.388000000 +0300
@@ -81,10 +81,6 @@
 
   static bool IsBottomEdge(int component);
 
-  // Call during an active resize to change the bounds of the window. This
-  // should not be called as the result of a revert.
-  void SetBoundsDuringResize(const gfx::Rect& bounds);
-
   // WindowState of the drag target.
   wm::WindowState* window_state_;
 
--- a/ash/wm/window_state.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/window_state.cc	2019-05-17 18:53:08.388000000 +0300
@@ -8,8 +8,6 @@
 #include <utility>
 
 #include "ash/focus_cycler.h"
-#include "ash/metrics/pip_uma.h"
-#include "ash/public/cpp/app_types.h"
 #include "ash/public/cpp/shell_window_ids.h"
 #include "ash/public/cpp/window_animation_types.h"
 #include "ash/public/cpp/window_properties.h"
@@ -19,6 +17,7 @@
 #include "ash/screen_util.h"
 #include "ash/shell.h"
 #include "ash/wm/default_state.h"
+#include "ash/wm/immersive_gesture_drag_handler.h"
 #include "ash/wm/pip/pip_positioner.h"
 #include "ash/wm/tablet_mode/tablet_mode_controller.h"
 #include "ash/wm/window_animations.h"
@@ -29,7 +28,6 @@
 #include "ash/wm/window_util.h"
 #include "ash/wm/wm_event.h"
 #include "base/auto_reset.h"
-#include "base/metrics/histogram_macros.h"
 #include "services/ws/public/mojom/window_tree_constants.mojom.h"
 #include "ui/aura/client/aura_constants.h"
 #include "ui/aura/layout_manager.h"
@@ -160,24 +158,6 @@
     MoveAllTransientChildrenToNewRoot(child);
 }
 
-void CollectPipEnterExitMetrics(aura::Window* window, bool enter) {
-  const bool is_android = window->GetProperty(aura::client::kAppType) ==
-                          static_cast<int>(ash::AppType::ARC_APP);
-  if (enter) {
-    UMA_HISTOGRAM_ENUMERATION(kAshPipEventsHistogramName,
-                              AshPipEvents::PIP_START);
-    UMA_HISTOGRAM_ENUMERATION(kAshPipEventsHistogramName,
-                              is_android ? AshPipEvents::ANDROID_PIP_START
-                                         : AshPipEvents::CHROME_PIP_START);
-  } else {
-    UMA_HISTOGRAM_ENUMERATION(kAshPipEventsHistogramName,
-                              AshPipEvents::PIP_END);
-    UMA_HISTOGRAM_ENUMERATION(kAshPipEventsHistogramName,
-                              is_android ? AshPipEvents::ANDROID_PIP_END
-                                         : AshPipEvents::CHROME_PIP_END);
-  }
-}
-
 }  // namespace
 
 constexpr base::TimeDelta WindowState::kBoundsChangeSlideDuration;
@@ -297,8 +277,7 @@
 }
 
 bool WindowState::HasRestoreBounds() const {
-  gfx::Rect* bounds = window_->GetProperty(aura::client::kRestoreBoundsKey);
-  return bounds != nullptr && !bounds->IsEmpty();
+  return window_->GetProperty(aura::client::kRestoreBoundsKey) != nullptr;
 }
 
 void WindowState::Maximize() {
@@ -329,7 +308,7 @@
 }
 
 void WindowState::DisableAlwaysOnTop(aura::Window* window_on_top) {
-  if (GetAlwaysOnTop() && !IsPip()) {
+  if (GetAlwaysOnTop()) {
     // |window_| is hidden first to avoid canceling fullscreen mode when it is
     // no longer always on top and gets added to default container. This avoids
     // sending redundant OnFullscreenStateChanged to the layout manager. The
@@ -514,7 +493,7 @@
   if (IsPip()) {
     views::Widget::GetWidgetForNativeWindow(window())
         ->widget_delegate()
-        ->SetCanActivate(false);
+        ->set_can_activate(false);
   }
 }
 
@@ -550,7 +529,7 @@
       ignore_property_change_(false),
       current_state_(new DefaultState(ToWindowStateType(GetShowState()))) {
   window_->AddObserver(this);
-  UpdatePipState(mojom::WindowStateType::DEFAULT);
+  UpdatePipState(/*was_pip=*/false);
 }
 
 bool WindowState::GetAlwaysOnTop() const {
@@ -623,7 +602,7 @@
     mojom::WindowStateType old_window_state_type) {
   for (auto& observer : observer_list_)
     observer.OnPreWindowStateTypeChange(this, old_window_state_type);
-  UpdatePipState(old_window_state_type);
+  UpdatePipState(old_window_state_type == mojom::WindowStateType::PIP);
 }
 
 void WindowState::NotifyPostStateTypeChange(
@@ -703,44 +682,33 @@
   CrossFadeAnimation(window_, std::move(old_layer_owner), animation_type);
 }
 
-void WindowState::UpdatePipState(mojom::WindowStateType old_window_state_type) {
+void WindowState::UpdatePipState(bool was_pip) {
   auto* widget = views::Widget::GetWidgetForNativeWindow(window());
   if (IsPip()) {
     // widget may not exit in some unit tests.
     // TODO(oshima): Fix unit tests and add DCHECK.
     if (widget) {
-      widget->widget_delegate()->SetCanActivate(false);
+      widget->widget_delegate()->set_can_activate(false);
       if (widget->IsActive())
         widget->Deactivate();
       Shell::Get()->focus_cycler()->AddWidget(widget);
     }
     ::wm::SetWindowVisibilityAnimationType(
         window(), WINDOW_VISIBILITY_ANIMATION_TYPE_FADE_IN_SLIDE_OUT);
-    // There may already be a system ui window on the initial position.
-    UpdatePipBounds();
-    if (old_window_state_type != mojom::WindowStateType::PIP) {
-      window()->SetProperty(ash::kPrePipWindowStateTypeKey,
-                            old_window_state_type);
-    }
-
-    CollectPipEnterExitMetrics(window(), /*enter=*/true);
-  } else if (old_window_state_type == mojom::WindowStateType::PIP) {
+  } else if (was_pip) {
     if (widget) {
-      widget->widget_delegate()->SetCanActivate(true);
+      widget->widget_delegate()->set_can_activate(true);
       Shell::Get()->focus_cycler()->RemoveWidget(widget);
     }
     ::wm::SetWindowVisibilityAnimationType(
         window(), ::wm::WINDOW_VISIBILITY_ANIMATION_TYPE_DEFAULT);
-
-    CollectPipEnterExitMetrics(window(), /*enter=*/false);
   }
 }
 
 void WindowState::UpdatePipBounds() {
   gfx::Rect new_bounds =
       PipPositioner::GetPositionAfterMovementAreaChange(this);
-  ::wm::ConvertRectFromScreen(window()->GetRootWindow(), &new_bounds);
-  if (window()->bounds() != new_bounds) {
+  if (window()->GetBoundsInScreen() != new_bounds) {
     wm::SetBoundsEvent event(wm::WM_EVENT_SET_BOUNDS, new_bounds,
                              /*animate=*/true);
     OnWMEvent(&event);
@@ -818,6 +786,16 @@
       // on our changed state.
       ash::Shell::Get()->UpdateShelfVisibility();
     }
+    if (key == kImmersiveIsActive) {
+      if (IsInImmersiveFullscreen()) {
+        if (!immersive_gesture_drag_handler_) {
+          immersive_gesture_drag_handler_ =
+              std::make_unique<ImmersiveGestureDragHandler>(window);
+        }
+      } else {
+        immersive_gesture_drag_handler_.reset();
+      }
+    }
     return;
   }
 }
@@ -831,15 +809,11 @@
 
 void WindowState::OnWindowDestroying(aura::Window* window) {
   DCHECK_EQ(window_, window);
-
-  // If the window is destroyed during PIP, count that as exiting.
-  if (IsPip())
-    CollectPipEnterExitMetrics(window, /*enter=*/false);
-
   auto* widget = views::Widget::GetWidgetForNativeWindow(window);
   if (widget)
     Shell::Get()->focus_cycler()->RemoveWidget(widget);
 
+  immersive_gesture_drag_handler_.reset();
   current_state_->OnWindowDestroying(this);
   delegate_.reset();
 }
--- a/ash/wm/window_state.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/window_state.h	2019-05-17 18:53:08.388000000 +0300
@@ -26,6 +26,7 @@
 }
 
 namespace ash {
+class ImmersiveGestureDragHandler;
 class LockWindowState;
 class TabletModeWindowState;
 
@@ -411,7 +412,7 @@
 
   // Update PIP related state, such as next window animation type, upon
   // state change.
-  void UpdatePipState(mojom::WindowStateType old_window_state_type);
+  void UpdatePipState(bool was_pip);
 
   // Update the PIP bounds if necessary. This may need to happen when the
   // display work area changes, or if system ui regions like the virtual
@@ -467,6 +468,10 @@
 
   std::unique_ptr<State> current_state_;
 
+  // An object that assists with dragging immersive mode windows in tablet mode.
+  // Only non-null when immersive mode is active.
+  std::unique_ptr<ImmersiveGestureDragHandler> immersive_gesture_drag_handler_;
+
   DISALLOW_COPY_AND_ASSIGN(WindowState);
 };
 
--- a/ash/wm/window_state_unittest.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/window_state_unittest.cc	2019-05-17 18:53:08.392000000 +0300
@@ -6,15 +6,12 @@
 
 #include <utility>
 
-#include "ash/metrics/pip_uma.h"
-#include "ash/public/cpp/app_types.h"
 #include "ash/public/cpp/window_properties.h"
 #include "ash/shelf/shelf_constants.h"
 #include "ash/test/ash_test_base.h"
 #include "ash/wm/window_state_util.h"
 #include "ash/wm/window_util.h"
 #include "ash/wm/wm_event.h"
-#include "base/test/metrics/histogram_tester.h"
 #include "services/ws/public/mojom/window_tree_constants.mojom.h"
 #include "ui/aura/client/aura_constants.h"
 #include "ui/aura/test/test_window_delegate.h"
@@ -60,7 +57,6 @@
 }  // namespace
 
 using WindowStateTest = AshTestBase;
-using Sample = base::HistogramBase::Sample;
 
 // Test that a window gets properly snapped to the display's edges in a
 // multi monitor environment.
@@ -166,102 +162,6 @@
   EXPECT_FALSE(window_state->CanSnap());
 }
 
-TEST_F(WindowStateTest, ChromePipWindowUmaMetrics) {
-  base::HistogramTester histograms;
-  std::unique_ptr<aura::Window> window(
-      CreateTestWindowInShellWithBounds(gfx::Rect(100, 100, 100, 100)));
-
-  WindowState* window_state = GetWindowState(window.get());
-  const WMEvent enter_pip(WM_EVENT_PIP);
-  window_state->OnWMEvent(&enter_pip);
-
-  EXPECT_EQ(1, histograms.GetBucketCount(kAshPipEventsHistogramName,
-                                         Sample(AshPipEvents::PIP_START)));
-  EXPECT_EQ(1,
-            histograms.GetBucketCount(kAshPipEventsHistogramName,
-                                      Sample(AshPipEvents::CHROME_PIP_START)));
-  histograms.ExpectTotalCount(kAshPipEventsHistogramName, 2);
-
-  const WMEvent enter_normal(WM_EVENT_NORMAL);
-  window_state->OnWMEvent(&enter_normal);
-
-  EXPECT_EQ(1, histograms.GetBucketCount(kAshPipEventsHistogramName,
-                                         Sample(AshPipEvents::PIP_END)));
-  EXPECT_EQ(1, histograms.GetBucketCount(kAshPipEventsHistogramName,
-                                         Sample(AshPipEvents::CHROME_PIP_END)));
-  histograms.ExpectTotalCount(kAshPipEventsHistogramName, 4);
-}
-
-TEST_F(WindowStateTest, AndroidPipWindowUmaMetrics) {
-  base::HistogramTester histograms;
-  std::unique_ptr<aura::Window> window(
-      CreateTestWindowInShellWithBounds(gfx::Rect(100, 100, 100, 100)));
-  window->SetProperty(aura::client::kAppType,
-                      static_cast<int>(ash::AppType::ARC_APP));
-
-  WindowState* window_state = GetWindowState(window.get());
-  const WMEvent enter_pip(WM_EVENT_PIP);
-  window_state->OnWMEvent(&enter_pip);
-
-  EXPECT_EQ(1, histograms.GetBucketCount(kAshPipEventsHistogramName,
-                                         Sample(AshPipEvents::PIP_START)));
-  EXPECT_EQ(1,
-            histograms.GetBucketCount(kAshPipEventsHistogramName,
-                                      Sample(AshPipEvents::ANDROID_PIP_START)));
-  histograms.ExpectTotalCount(kAshPipEventsHistogramName, 2);
-
-  const WMEvent enter_normal(WM_EVENT_NORMAL);
-  window_state->OnWMEvent(&enter_normal);
-
-  EXPECT_EQ(1, histograms.GetBucketCount(kAshPipEventsHistogramName,
-                                         Sample(AshPipEvents::PIP_END)));
-  EXPECT_EQ(1,
-            histograms.GetBucketCount(kAshPipEventsHistogramName,
-                                      Sample(AshPipEvents::ANDROID_PIP_END)));
-  histograms.ExpectTotalCount(kAshPipEventsHistogramName, 4);
-}
-
-TEST_F(WindowStateTest, ChromePipWindowUmaMetricsCountsExitOnDestroy) {
-  base::HistogramTester histograms;
-  std::unique_ptr<aura::Window> window(
-      CreateTestWindowInShellWithBounds(gfx::Rect(100, 100, 100, 100)));
-
-  WindowState* window_state = GetWindowState(window.get());
-  const WMEvent enter_pip(WM_EVENT_PIP);
-  window_state->OnWMEvent(&enter_pip);
-
-  // Destroy the window.
-  window.reset();
-
-  EXPECT_EQ(1, histograms.GetBucketCount(kAshPipEventsHistogramName,
-                                         Sample(AshPipEvents::PIP_END)));
-  EXPECT_EQ(1, histograms.GetBucketCount(kAshPipEventsHistogramName,
-                                         Sample(AshPipEvents::CHROME_PIP_END)));
-  histograms.ExpectTotalCount(kAshPipEventsHistogramName, 4);
-}
-
-TEST_F(WindowStateTest, AndroidPipWindowUmaMetricsCountsExitOnDestroy) {
-  base::HistogramTester histograms;
-  std::unique_ptr<aura::Window> window(
-      CreateTestWindowInShellWithBounds(gfx::Rect(100, 100, 100, 100)));
-  window->SetProperty(aura::client::kAppType,
-                      static_cast<int>(ash::AppType::ARC_APP));
-
-  WindowState* window_state = GetWindowState(window.get());
-  const WMEvent enter_pip(WM_EVENT_PIP);
-  window_state->OnWMEvent(&enter_pip);
-
-  // Destroy the window.
-  window.reset();
-
-  EXPECT_EQ(1, histograms.GetBucketCount(kAshPipEventsHistogramName,
-                                         Sample(AshPipEvents::PIP_END)));
-  EXPECT_EQ(1,
-            histograms.GetBucketCount(kAshPipEventsHistogramName,
-                                      Sample(AshPipEvents::ANDROID_PIP_END)));
-  histograms.ExpectTotalCount(kAshPipEventsHistogramName, 4);
-}
-
 // Test that modal window dialogs can be snapped.
 TEST_F(WindowStateTest, SnapModalWindowWithoutMaximumSizeLimit) {
   UpdateDisplay("0+0-600x900");
@@ -673,41 +573,6 @@
   EXPECT_TRUE(window_state->CanConsumeSystemKeys());
 }
 
-TEST_F(WindowStateTest, RestoreStateAfterDismissingPip) {
-  std::unique_ptr<aura::Window> window(CreateTestWindowInShellWithId(0));
-  wm::WindowState* window_state = wm::GetWindowState(window.get());
-  window->Show();
-  EXPECT_TRUE(window->layer()->visible());
-
-  // Ensure a maximized window gets maximized again after it enters PIP, gets
-  // minimized, and unminimized.
-  window_state->Maximize();
-  ASSERT_TRUE(window_state->IsMaximized());
-
-  const wm::WMEvent enter_pip(wm::WM_EVENT_PIP);
-  window_state->OnWMEvent(&enter_pip);
-  EXPECT_TRUE(window_state->IsPip());
-
-  window_state->Minimize();
-  ASSERT_TRUE(window_state->IsMinimized());
-
-  window_state->Unminimize();
-  ASSERT_TRUE(window_state->IsMaximized());
-
-  // Ensure a freeform window gets freeform again after it enters PIP, gets
-  // minimized, and unminimized.
-  ::wm::SetWindowState(window.get(), ui::SHOW_STATE_NORMAL);
-
-  window_state->OnWMEvent(&enter_pip);
-  EXPECT_TRUE(window_state->IsPip());
-
-  window_state->Minimize();
-  ASSERT_TRUE(window_state->IsMinimized());
-
-  window_state->Unminimize();
-  ASSERT_TRUE(window_state->GetStateType() == mojom::WindowStateType::NORMAL);
-}
-
 // TODO(skuhne): Add more unit test to verify the correctness for the restore
 // operation.
 
--- a/ash/wm/window_util.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/window_util.cc	2019-05-17 18:53:08.392000000 +0300
@@ -6,7 +6,6 @@
 
 #include <memory>
 
-#include "ash/public/cpp/app_types.h"
 #include "ash/public/cpp/ash_constants.h"
 #include "ash/public/cpp/shell_window_ids.h"
 #include "ash/public/cpp/window_properties.h"
@@ -16,8 +15,6 @@
 #include "ash/shelf/shelf.h"
 #include "ash/shell.h"
 #include "ash/wm/splitview/split_view_controller.h"
-#include "ash/wm/tablet_mode/tablet_mode_controller.h"
-#include "ash/wm/tablet_mode/tablet_mode_observer.h"
 #include "ash/wm/widget_finder.h"
 #include "ash/wm/window_positioning_utils.h"
 #include "ash/wm/window_state.h"
@@ -101,14 +98,6 @@
   }
 
   bool ShouldUseExtendedBounds(const aura::Window* target) const override {
-    // Fullscreen/maximized windows can't be drag-resized.
-    const WindowState* window_state = GetWindowState(window());
-    const WindowState* target_window_state = GetWindowState(target);
-    if ((window_state && window_state->IsMaximizedOrFullscreenOrPinned()) ||
-        (target_window_state && !target_window_state->CanResize())) {
-      return false;
-    }
-
     // The shrunken hit region only applies to children of |window()|.
     return target->parent() == window();
   }
@@ -117,65 +106,7 @@
   DISALLOW_COPY_AND_ASSIGN(InteriorResizeHandleTargeter);
 };
 
-// A class to track immersive and tablet mode state and update
-// kGestureDragFromClientAreaTopMovesWindow accordingly. It is owned by the
-// window it tracks by way of being an owned property.
-class GestureDraggableTracker : public aura::WindowObserver,
-                                public TabletModeObserver {
- public:
-  explicit GestureDraggableTracker(aura::Window* window)
-      : observed_window_(window) {
-    observed_window_->AddObserver(this);
-    Shell::Get()->tablet_mode_controller()->AddObserver(this);
-  }
-
-  ~GestureDraggableTracker() override {
-    observed_window_->RemoveObserver(this);
-    if (Shell::Get()->tablet_mode_controller())
-      Shell::Get()->tablet_mode_controller()->RemoveObserver(this);
-  }
-
-  // aura::WindowObserver:
-  void OnWindowPropertyChanged(aura::Window* window,
-                               const void* key,
-                               intptr_t old) override {
-    if (key == kImmersiveIsActive)
-      UpdateFlag();
-  }
-
-  // TabletModeObserver:
-  void OnTabletModeStarted() override { UpdateFlag(); }
-  void OnTabletModeEnded() override { UpdateFlag(); }
-
- private:
-  void UpdateFlag() {
-    observed_window_->SetProperty(
-        aura::client::kGestureDragFromClientAreaTopMovesWindow,
-        observed_window_->GetProperty(kImmersiveIsActive) &&
-            Shell::Get()->tablet_mode_controller() &&
-            Shell::Get()
-                ->tablet_mode_controller()
-                ->IsTabletModeWindowManagerEnabled());
-  }
-
-  // |observed_window_| owns |this|.
-  aura::Window* observed_window_;
-
-  DISALLOW_COPY_AND_ASSIGN(GestureDraggableTracker);
-};
-
-DEFINE_OWNED_UI_CLASS_PROPERTY_KEY(GestureDraggableTracker,
-                                   kGestureDraggableTracker,
-                                   nullptr)
-
 }  // namespace
-}  // namespace wm
-}  // namespace ash
-
-DEFINE_UI_CLASS_PROPERTY_TYPE(ash::wm::GestureDraggableTracker*)
-
-namespace ash {
-namespace wm {
 
 // TODO(beng): replace many of these functions with the corewm versions.
 void ActivateWindow(aura::Window* window) {
@@ -322,19 +253,6 @@
                       kResizeInsideBoundsSize);
 }
 
-void MakeGestureDraggableInImmersiveMode(aura::Window* frame_window) {
-  // For Browser windows, gesture drags from the top in immersive mode reveal
-  // the frame, so kGestureDragFromClientAreaTopMovesWindow should always be
-  // false.
-  if (static_cast<ash::AppType>(frame_window->GetProperty(
-          aura::client::kAppType)) == AppType::BROWSER) {
-    return;
-  }
-
-  frame_window->SetProperty(kGestureDraggableTracker,
-                            new GestureDraggableTracker(frame_window));
-}
-
 bool IsDraggingTabs(const aura::Window* window) {
   return window->GetProperty(ash::kIsDraggingTabsKey);
 }
--- a/ash/wm/window_util.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/window_util.h	2019-05-17 18:53:08.392000000 +0300
@@ -100,10 +100,6 @@
 ASH_EXPORT void InstallResizeHandleWindowTargeterForWindow(
     aura::Window* window);
 
-// Sets up the given window to be draggable via gesture sequences in certain
-// circumstances. See aura::client::kGestureDragFromClientAreaTopMovesWindow.
-ASH_EXPORT void MakeGestureDraggableInImmersiveMode(aura::Window* frame_window);
-
 // Returns true if |window| is currently in tab-dragging process.
 ASH_EXPORT bool IsDraggingTabs(const aura::Window* window);
 
--- a/ash/wm/wm_shadow_controller_delegate.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/wm_shadow_controller_delegate.cc	2019-05-17 18:53:08.392000000 +0300
@@ -25,7 +25,8 @@
   SplitViewController* split_view_controller =
       Shell::Get()->split_view_controller();
   if (split_view_controller &&
-      split_view_controller->IsWindowInSplitView(window)) {
+      (window == split_view_controller->left_window() ||
+       window == split_view_controller->right_window())) {
     return false;
   }
 
--- a/ash/wm/wm_toplevel_window_event_handler.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/wm_toplevel_window_event_handler.cc	2019-05-17 18:53:08.392000000 +0300
@@ -4,7 +4,6 @@
 
 #include "ash/wm/wm_toplevel_window_event_handler.h"
 
-#include "ash/public/cpp/app_types.h"
 #include "ash/shell.h"
 #include "ash/wm/resize_shadow_controller.h"
 #include "ash/wm/tablet_mode/tablet_mode_controller.h"
@@ -13,17 +12,12 @@
 #include "ash/wm/window_state_observer.h"
 #include "ash/wm/window_util.h"
 #include "ash/wm/wm_event.h"
-#include "ui/aura/client/aura_constants.h"
 #include "ui/aura/client/window_types.h"
-#include "ui/aura/env.h"
 #include "ui/aura/window.h"
 #include "ui/aura/window_delegate.h"
 #include "ui/aura/window_observer.h"
 #include "ui/base/hit_test.h"
-#include "ui/base/ui_base_features.h"
 #include "ui/events/event.h"
-#include "ui/events/gestures/gesture_recognizer.h"
-#include "ui/views/widget/widget.h"
 #include "ui/wm/core/coordinate_conversion.h"
 
 namespace ash {
@@ -31,78 +25,6 @@
 
 namespace {
 
-// How many pixels are reserved for gesture events to start dragging the app
-// window from the top of the screen in tablet mode.
-constexpr int kDragStartTopEdgeInset = 8;
-
-// Returns the toplevel window that should be dragged for a gesture event that
-// occurs in the HTCLIENT area of a window. Returns null if there shouldn't be
-// special casing for this HTCLIENT area gesture. This is used to drag app
-// windows which are fullscreened/maximized in tablet mode from the top of the
-// screen, which don't have a window frame.
-aura::Window* GetTargetForClientAreaGesture(ui::GestureEvent* event,
-                                            aura::Window* target) {
-  if (event->type() != ui::ET_GESTURE_SCROLL_BEGIN)
-    return nullptr;
-
-  views::Widget* widget = views::Widget::GetTopLevelWidgetForNativeView(target);
-  if (!widget)
-    return nullptr;
-
-  aura::Window* toplevel = widget->GetNativeWindow();
-  if (features::IsUsingWindowService()) {
-    if (!toplevel->GetProperty(
-            aura::client::kGestureDragFromClientAreaTopMovesWindow)) {
-      return nullptr;
-    }
-  } else {
-    // Classic Ash: duplicate the logic from
-    // MakeGestureDraggableInImmersiveMode since there's no clear place during
-    // Widget init to hook that in.
-    if (!Shell::Get()
-             ->tablet_mode_controller()
-             ->IsTabletModeWindowManagerEnabled()) {
-      return nullptr;
-    }
-    wm::WindowState* window_state = wm::GetWindowState(toplevel);
-    if (!window_state ||
-        (!window_state->IsMaximized() && !window_state->IsFullscreen() &&
-         !window_state->IsSnapped())) {
-      return nullptr;
-    }
-
-    if (toplevel->GetProperty(aura::client::kAppType) ==
-        static_cast<int>(AppType::BROWSER)) {
-      return nullptr;
-    }
-  }
-
-  if (event->details().scroll_y_hint() < 0)
-    return nullptr;
-
-  const gfx::Point location_in_screen =
-      event->target()->GetScreenLocation(*event);
-  const gfx::Rect work_area_bounds =
-      display::Screen::GetScreen()
-          ->GetDisplayNearestWindow(static_cast<aura::Window*>(event->target()))
-          .work_area();
-
-  gfx::Rect hit_bounds_in_screen(work_area_bounds);
-  hit_bounds_in_screen.set_height(kDragStartTopEdgeInset);
-
-  // There may be a bezel sensor off screen logically above
-  // |hit_bounds_in_screen|. Handles the ET_GESTURE_SCROLL_BEGIN event
-  // triggered in the bezel area too.
-  bool in_bezel = location_in_screen.y() < hit_bounds_in_screen.y() &&
-                  location_in_screen.x() >= hit_bounds_in_screen.x() &&
-                  location_in_screen.x() < hit_bounds_in_screen.right();
-
-  if (hit_bounds_in_screen.Contains(location_in_screen) || in_bezel)
-    return toplevel;
-
-  return nullptr;
-}
-
 // Returns whether |window| can be moved via a two finger drag given
 // the hittest results of the two fingers.
 bool CanStartTwoFingerMove(aura::Window* window,
@@ -171,9 +93,6 @@
   // Returns true if the drag moves the window and does not resize.
   bool IsMove() const;
 
-  // Returns true if the window may be resized.
-  bool IsResize() const;
-
   WindowResizer* resizer() { return resizer_.get(); }
 
   // WindowObserver overrides:
@@ -190,9 +109,6 @@
   // Whether ScopedWindowResizer grabbed capture.
   bool grabbed_capture_;
 
-  // Set to true if OnWindowDestroying() is received.
-  bool window_destroying_ = false;
-
   DISALLOW_COPY_AND_ASSIGN(ScopedWindowResizer);
 };
 
@@ -204,9 +120,6 @@
   target->AddObserver(this);
   GetWindowState(target)->AddObserver(this);
 
-  if (IsResize())
-    target->NotifyResizeLoopStarted();
-
   if (!target->HasCapture()) {
     grabbed_capture_ = true;
     target->SetCapture();
@@ -219,8 +132,6 @@
   GetWindowState(target)->RemoveObserver(this);
   if (grabbed_capture_)
     target->ReleaseCapture();
-  if (!window_destroying_ && IsResize())
-    target->NotifyResizeLoopEnded();
 }
 
 bool WmToplevelWindowEventHandler::ScopedWindowResizer::IsMove() const {
@@ -228,11 +139,6 @@
          WindowResizer::kBoundsChange_Repositions;
 }
 
-bool WmToplevelWindowEventHandler::ScopedWindowResizer::IsResize() const {
-  return (resizer_->details().bounds_change &
-          WindowResizer::kBoundsChange_Resizes) != 0;
-}
-
 void WmToplevelWindowEventHandler::ScopedWindowResizer::
     OnPreWindowStateTypeChange(wm::WindowState* window_state,
                                mojom::WindowStateType old) {
@@ -242,7 +148,6 @@
 void WmToplevelWindowEventHandler::ScopedWindowResizer::OnWindowDestroying(
     aura::Window* window) {
   DCHECK_EQ(resizer_->GetTarget(), window);
-  window_destroying_ = true;
   handler_->ResizerWindowDestroyed();
 }
 
@@ -252,29 +157,12 @@
 WmToplevelWindowEventHandler::WmToplevelWindowEventHandler()
     : first_finger_hittest_(HTNOWHERE) {
   Shell::Get()->window_tree_host_manager()->AddObserver(this);
-  display::Screen::GetScreen()->AddObserver(this);
 }
 
 WmToplevelWindowEventHandler::~WmToplevelWindowEventHandler() {
-  display::Screen::GetScreen()->RemoveObserver(this);
   Shell::Get()->window_tree_host_manager()->RemoveObserver(this);
 }
 
-void WmToplevelWindowEventHandler::OnDisplayMetricsChanged(
-    const display::Display& display,
-    uint32_t metrics) {
-  if (!window_resizer_ || !(metrics & DISPLAY_METRIC_ROTATION))
-    return;
-
-  display::Display current_display =
-      display::Screen::GetScreen()->GetDisplayNearestWindow(
-          window_resizer_->resizer()->GetTarget());
-  if (display.id() != current_display.id())
-    return;
-
-  RevertDrag();
-}
-
 void WmToplevelWindowEventHandler::OnKeyEvent(ui::KeyEvent* event) {
   if (window_resizer_.get() && event->type() == ui::ET_KEY_PRESSED &&
       event->key_code() == ui::VKEY_ESCAPE) {
@@ -325,51 +213,23 @@
 
 void WmToplevelWindowEventHandler::OnGestureEvent(ui::GestureEvent* event,
                                                   aura::Window* target) {
-  DCHECK_EQ(event->target(), target);
-  int component = GetNonClientComponent(target, event->location());
-  gfx::Point event_location = event->location();
-
-  aura::Window* original_target = target;
-  bool client_area_drag = false;
-  if (component == HTCLIENT) {
-    // When dragging on a client area starts a gesture drag, |this| stops the
-    // propagation of the ET_GESTURE_SCROLL_BEGIN event. Subsequent gestures on
-    // the HTCLIENT area should also be stopped lest the client receive an
-    // ET_GESTURE_SCROLL_UPDATE without the ET_GESTURE_SCROLL_BEGIN.
-    if (in_gesture_drag_ && target != gesture_target_) {
-      event->StopPropagation();
-      return;
-    }
-
-    aura::Window* new_target = GetTargetForClientAreaGesture(event, target);
-
-    client_area_drag = !!new_target;
-    if (new_target && (target != new_target)) {
-      DCHECK_EQ(ui::ET_GESTURE_SCROLL_BEGIN, event->type());
-      aura::Window::ConvertPointToTarget(target, new_target, &event_location);
-
-      original_target->env()->gesture_recognizer()->TransferEventsTo(
-          original_target, new_target, ui::TransferTouchesBehavior::kCancel);
-      UpdateGestureTarget(new_target, event_location);
-      target = new_target;
-    }
-  }
-
   if (event->type() == ui::ET_GESTURE_END)
     UpdateGestureTarget(nullptr);
   else if (event->type() == ui::ET_GESTURE_BEGIN)
-    UpdateGestureTarget(target, event_location);
+    UpdateGestureTarget(target, event->location());
 
   if (event->handled())
     return;
   if (!target->delegate())
     return;
 
-  if (window_resizer_ && !in_gesture_drag_)
+  if (window_resizer_.get() && !in_gesture_drag_)
     return;
 
-  if (window_resizer_ && window_resizer_->resizer()->GetTarget() != target)
+  if (window_resizer_.get() &&
+      window_resizer_->resizer()->GetTarget() != target) {
     return;
+  }
 
   if (event->details().touch_points() > 2) {
     if (CompleteDrag(DragResult::SUCCESS))
@@ -379,26 +239,18 @@
 
   switch (event->type()) {
     case ui::ET_GESTURE_TAP_DOWN: {
+      int component = GetNonClientComponent(target, event->location());
       if (!(WindowResizer::GetBoundsChangeForWindowComponent(component) &
-            WindowResizer::kBoundsChange_Resizes) ||
-          (!client_area_drag && !CanStartOneFingerDrag(component)))
+            WindowResizer::kBoundsChange_Resizes))
         return;
-
       ShowResizeShadow(target, component);
-
-      gfx::Point location_in_parent = event_location;
-      aura::Window::ConvertPointToTarget(target, target->parent(),
-                                         &location_in_parent);
-      AttemptToStartDrag(target, location_in_parent, component,
-                         ::wm::WINDOW_MOVE_SOURCE_TOUCH, EndClosure(),
-                         /*update_gesture_target=*/false);
-      event->StopPropagation();
       return;
     }
     case ui::ET_GESTURE_END: {
       HideResizeShadow(target);
 
-      if (window_resizer_ && (event->details().touch_points() == 1 ||
+      if (window_resizer_.get() &&
+          (event->details().touch_points() == 1 ||
                               !CanStartOneFingerDrag(first_finger_hittest_))) {
         CompleteDrag(DragResult::SUCCESS);
         event->StopPropagation();
@@ -407,11 +259,12 @@
     }
     case ui::ET_GESTURE_BEGIN: {
       if (event->details().touch_points() == 1) {
-        first_finger_touch_point_ = event_location;
+        first_finger_touch_point_ = event->location();
         aura::Window::ConvertPointToTarget(target, target->parent(),
                                            &first_finger_touch_point_);
-        first_finger_hittest_ = component;
-      } else if (window_resizer_) {
+        first_finger_hittest_ =
+            GetNonClientComponent(target, event->location());
+      } else if (window_resizer_.get()) {
         if (!window_resizer_->IsMove()) {
           // The transition from resizing with one finger to resizing with two
           // fingers causes unintended resizing because the location of
@@ -422,12 +275,12 @@
           event->StopPropagation();
         }
       } else {
-        int second_finger_hittest = component;
+        int second_finger_hittest =
+            GetNonClientComponent(target, event->location());
         if (CanStartTwoFingerMove(target, first_finger_hittest_,
                                   second_finger_hittest)) {
           AttemptToStartDrag(target, first_finger_touch_point_, HTCAPTION,
-                             ::wm::WINDOW_MOVE_SOURCE_TOUCH, EndClosure(),
-                             /*update_gesture_target=*/false);
+                             ::wm::WINDOW_MOVE_SOURCE_TOUCH, EndClosure());
           event->StopPropagation();
         }
       }
@@ -441,16 +294,14 @@
       // finger's position to the position in the middle of the two fingers.
       if (window_resizer_.get())
         return;
-
-      if (!client_area_drag && !CanStartOneFingerDrag(component))
+      int component = GetNonClientComponent(target, event->location());
+      if (!CanStartOneFingerDrag(component))
         return;
-
-      gfx::Point location_in_parent = event_location;
+      gfx::Point location_in_parent = event->location();
       aura::Window::ConvertPointToTarget(target, target->parent(),
                                          &location_in_parent);
       AttemptToStartDrag(target, location_in_parent, component,
-                         ::wm::WINDOW_MOVE_SOURCE_TOUCH, EndClosure(),
-                         /*update_gesture_target=*/false);
+                         ::wm::WINDOW_MOVE_SOURCE_TOUCH, EndClosure());
       event->StopPropagation();
       return;
     }
@@ -513,15 +364,7 @@
     const gfx::Point& point_in_parent,
     int window_component,
     ::wm::WindowMoveSource source,
-    EndClosure end_closure,
-    bool update_gesture_target) {
-  if (gesture_target_ != nullptr && update_gesture_target) {
-    DCHECK_EQ(source, ::wm::WINDOW_MOVE_SOURCE_TOUCH);
-    // Transfer events for gesture if switching to new target.
-    window->env()->gesture_recognizer()->TransferEventsTo(
-        gesture_target_, window, ui::TransferTouchesBehavior::kDontCancel);
-  }
-
+    EndClosure end_closure) {
   if (!PrepareForDrag(window, point_in_parent, window_component, source)) {
     // Treat failure to start as a revert.
     if (end_closure)
@@ -531,12 +374,6 @@
 
   end_closure_ = std::move(end_closure);
   in_gesture_drag_ = (source == ::wm::WINDOW_MOVE_SOURCE_TOUCH);
-  // |gesture_target_| needs to be updated if the drag originated from a
-  // client (i.e. |this| never handled ET_GESTURE_EVENT_BEGIN).
-  if (in_gesture_drag_ && (!gesture_target_ || update_gesture_target)) {
-    UpdateGestureTarget(window);
-  }
-
   return true;
 }
 
@@ -604,8 +441,7 @@
     aura::Window::ConvertPointToTarget(target, target->parent(),
                                        &location_in_parent);
     AttemptToStartDrag(target, location_in_parent, component,
-                       ::wm::WINDOW_MOVE_SOURCE_MOUSE, EndClosure(),
-                       /*update_gesture_target=*/false);
+                       ::wm::WINDOW_MOVE_SOURCE_MOUSE, EndClosure());
     // Set as handled so that other event handlers do no act upon the event
     // but still receive it so that they receive both parts of each pressed/
     // released pair.
--- a/ash/wm/wm_toplevel_window_event_handler.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/wm_toplevel_window_event_handler.h	2019-05-17 18:53:08.392000000 +0300
@@ -12,7 +12,6 @@
 #include "base/callback.h"
 #include "base/macros.h"
 #include "ui/aura/window_observer.h"
-#include "ui/display/display_observer.h"
 #include "ui/gfx/geometry/rect.h"
 #include "ui/wm/public/window_move_client.h"
 
@@ -39,8 +38,7 @@
 // EventHandler.
 class ASH_EXPORT WmToplevelWindowEventHandler
     : public WindowTreeHostManager::Observer,
-      public aura::WindowObserver,
-      public display::DisplayObserver {
+      public aura::WindowObserver {
  public:
   // Describes what triggered ending the drag.
   enum class DragResult {
@@ -57,25 +55,18 @@
   WmToplevelWindowEventHandler();
   ~WmToplevelWindowEventHandler() override;
 
-  // display::DisplayObserver:
-  void OnDisplayMetricsChanged(const display::Display& display,
-                               uint32_t metrics) override;
-
   void OnKeyEvent(ui::KeyEvent* event);
   void OnMouseEvent(ui::MouseEvent* event, aura::Window* target);
   void OnGestureEvent(ui::GestureEvent* event, aura::Window* target);
 
   // Attempts to start a drag if one is not already in progress. Returns true if
   // successful. |end_closure| is run when the drag completes, including if the
-  // drag is not started. If |update_gesture_target| is true, the gesture
-  // target is forcefully updated and gesture events are transferred to
-  // new target if any.
+  // drag is not started.
   bool AttemptToStartDrag(aura::Window* window,
                           const gfx::Point& point_in_parent,
                           int window_component,
                           ::wm::WindowMoveSource source,
-                          EndClosure end_closure,
-                          bool update_gesture_target);
+                          EndClosure end_closure);
 
   // If there is a drag in progress it is reverted, otherwise does nothing.
   void RevertDrag();
--- a/ash/wm/workspace/backdrop_controller.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/workspace/backdrop_controller.cc	2019-05-17 18:53:08.392000000 +0300
@@ -18,7 +18,6 @@
 #include "ash/screen_util.h"
 #include "ash/shell.h"
 #include "ash/wallpaper/wallpaper_controller.h"
-#include "ash/wm/always_on_top_controller.h"
 #include "ash/wm/overview/overview_controller.h"
 #include "ash/wm/window_state.h"
 #include "ash/wm/window_util.h"
@@ -74,7 +73,6 @@
     : container_(container) {
   DCHECK(container_);
   Shell::Get()->AddShellObserver(this);
-  Shell::Get()->overview_controller()->AddObserver(this);
   Shell::Get()->accessibility_controller()->AddObserver(this);
   Shell::Get()->app_list_controller()->AddObserver(this);
   Shell::Get()->wallpaper_controller()->AddObserver(this);
@@ -83,8 +81,6 @@
 BackdropController::~BackdropController() {
   Shell::Get()->accessibility_controller()->RemoveObserver(this);
   Shell::Get()->wallpaper_controller()->RemoveObserver(this);
-  if (Shell::Get()->overview_controller())
-    Shell::Get()->overview_controller()->RemoveObserver(this);
   Shell::Get()->RemoveShellObserver(this);
   // AppListController is destroyed early when Shell is being destroyed, it may
   // not exist.
@@ -163,14 +159,6 @@
   container_->StackChildAbove(window, backdrop_window_);
 }
 
-void BackdropController::OnSplitViewModeStarting() {
-  Shell::Get()->split_view_controller()->AddObserver(this);
-}
-
-void BackdropController::OnSplitViewModeEnded() {
-  Shell::Get()->split_view_controller()->RemoveObserver(this);
-}
-
 void BackdropController::OnOverviewModeStarting() {
   if (backdrop_window_)
     backdrop_window_->SetProperty(aura::client::kAnimationsDisabledKey, true);
@@ -189,6 +177,14 @@
     backdrop_window_->ClearProperty(aura::client::kAnimationsDisabledKey);
 }
 
+void BackdropController::OnSplitViewModeStarting() {
+  Shell::Get()->split_view_controller()->AddObserver(this);
+}
+
+void BackdropController::OnSplitViewModeEnded() {
+  Shell::Get()->split_view_controller()->RemoveObserver(this);
+}
+
 void BackdropController::OnAppListVisibilityChanged(bool shown,
                                                     int64_t display_id) {
   UpdateBackdrop();
@@ -232,9 +228,6 @@
   backdrop_->Init(params);
   backdrop_window_ = backdrop_->GetNativeWindow();
   backdrop_window_->SetName("Backdrop");
-  // The backdrop window in always on top container can be reparented without
-  // this when the window is set to fullscreen.
-  AlwaysOnTopController::SetDisallowReparent(backdrop_window_);
   ::wm::SetWindowVisibilityAnimationType(
       backdrop_window_, ::wm::WINDOW_VISIBILITY_ANIMATION_TYPE_FADE);
   backdrop_window_->layer()->SetColor(SK_ColorBLACK);
--- a/ash/wm/workspace/backdrop_controller.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/workspace/backdrop_controller.h	2019-05-17 18:53:08.392000000 +0300
@@ -11,7 +11,6 @@
 #include "ash/app_list/app_list_controller_observer.h"
 #include "ash/shell_observer.h"
 #include "ash/wallpaper/wallpaper_controller_observer.h"
-#include "ash/wm/overview/overview_observer.h"
 #include "ash/wm/splitview/split_view_controller.h"
 #include "base/macros.h"
 
@@ -48,7 +47,6 @@
 class BackdropController : public AccessibilityObserver,
                            public AppListControllerObserver,
                            public ShellObserver,
-                           public OverviewObserver,
                            public SplitViewController::Observer,
                            public WallpaperControllerObserver {
  public:
@@ -72,13 +70,11 @@
   aura::Window* backdrop_window() { return backdrop_window_; }
 
   // ShellObserver:
-  void OnSplitViewModeStarting() override;
-  void OnSplitViewModeEnded() override;
-
-  // OverviewObserver:
   void OnOverviewModeStarting() override;
   void OnOverviewModeEnding(OverviewSession* overview_session) override;
   void OnOverviewModeEndingAnimationComplete(bool canceled) override;
+  void OnSplitViewModeStarting() override;
+  void OnSplitViewModeEnded() override;
 
   // AppListControllerObserver:
   void OnAppListVisibilityChanged(bool shown, int64_t display_id) override;
--- a/ash/wm/workspace/workspace_layout_manager_unittest.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/workspace/workspace_layout_manager_unittest.cc	2019-05-17 18:53:08.396000000 +0300
@@ -29,7 +29,6 @@
 #include "ash/test/ash_test_base.h"
 #include "ash/wallpaper/wallpaper_controller_test_api.h"
 #include "ash/window_factory.h"
-#include "ash/wm/always_on_top_controller.h"
 #include "ash/wm/fullscreen_window_finder.h"
 #include "ash/wm/overview/overview_controller.h"
 #include "ash/wm/splitview/split_view_controller.h"
@@ -39,11 +38,9 @@
 #include "ash/wm/window_state.h"
 #include "ash/wm/window_util.h"
 #include "ash/wm/wm_event.h"
-#include "ash/wm/workspace/backdrop_controller.h"
 #include "ash/wm/workspace/backdrop_delegate.h"
 #include "ash/wm/workspace/workspace_window_resizer.h"
 #include "ash/wm/workspace_controller_test_api.h"
-#include "base/bind_helpers.h"
 #include "base/command_line.h"
 #include "base/run_loop.h"
 #include "chromeos/audio/chromeos_sounds.h"
@@ -865,35 +862,6 @@
   EXPECT_EQ(nullptr, wm::GetWindowForFullscreenMode(fullscreen_window.get()));
 }
 
-TEST_F(WorkspaceLayoutManagerSoloTest,
-       FullscreenDoesNotSuspendAlwaysOnTopForPip) {
-  gfx::Rect bounds(100, 100, 200, 200);
-  std::unique_ptr<aura::Window> fullscreen_window(
-      CreateTestWindowInShellWithBounds(bounds));
-  std::unique_ptr<aura::Window> pip_window(
-      CreateTestWindowInShellWithBounds(bounds));
-
-  wm::WindowState* window_state = wm::GetWindowState(pip_window.get());
-  const wm::WMEvent enter_pip(wm::WM_EVENT_PIP);
-  window_state->OnWMEvent(&enter_pip);
-  pip_window->SetProperty(aura::client::kAlwaysOnTopKey, true);
-  EXPECT_TRUE(window_state->IsPip());
-  EXPECT_TRUE(pip_window->GetProperty(aura::client::kAlwaysOnTopKey));
-
-  // Making a window fullscreen temporarily suspends always on top state, but
-  // should not do so for PIP.
-  fullscreen_window->SetProperty(aura::client::kShowStateKey,
-                                 ui::SHOW_STATE_FULLSCREEN);
-  EXPECT_TRUE(pip_window->GetProperty(aura::client::kAlwaysOnTopKey));
-  EXPECT_NE(nullptr, wm::GetWindowForFullscreenMode(fullscreen_window.get()));
-
-  // Making fullscreen window normal does not affect PIP.
-  fullscreen_window->SetProperty(aura::client::kShowStateKey,
-                                 ui::SHOW_STATE_NORMAL);
-  EXPECT_TRUE(pip_window->GetProperty(aura::client::kAlwaysOnTopKey));
-  EXPECT_EQ(nullptr, wm::GetWindowForFullscreenMode(fullscreen_window.get()));
-}
-
 // Similary, pinned window causes always_on_top_ windows to stack below.
 TEST_F(WorkspaceLayoutManagerSoloTest, PinnedSuspendsAlwaysOnTop) {
   gfx::Rect bounds(100, 100, 200, 200);
@@ -931,45 +899,6 @@
       always_on_top_window3->GetProperty(aura::client::kAlwaysOnTopKey));
 }
 
-TEST_F(WorkspaceLayoutManagerSoloTest, PinnedDoesNotSuspendAlwaysOnTopForPip) {
-  gfx::Rect bounds(100, 100, 200, 200);
-  std::unique_ptr<aura::Window> pinned_window(
-      CreateTestWindowInShellWithBounds(bounds));
-  std::unique_ptr<aura::Window> pip_window(
-      CreateTestWindowInShellWithBounds(bounds));
-  {
-    wm::WindowState* window_state = wm::GetWindowState(pip_window.get());
-    const wm::WMEvent enter_pip(wm::WM_EVENT_PIP);
-    window_state->OnWMEvent(&enter_pip);
-    pip_window->SetProperty(aura::client::kAlwaysOnTopKey, true);
-    EXPECT_TRUE(window_state->IsPip());
-    EXPECT_TRUE(pip_window->GetProperty(aura::client::kAlwaysOnTopKey));
-  }
-
-  // Making a window pinned temporarily suspends always on top state, except
-  // for PIP.
-  const bool trusted = false;
-  wm::PinWindow(pinned_window.get(), trusted);
-  EXPECT_TRUE(pip_window->GetProperty(aura::client::kAlwaysOnTopKey));
-
-  // Adding a new PIP window should still end up always on top.
-  std::unique_ptr<aura::Window> pip_window2(
-      CreateTestWindowInShellWithBounds(bounds));
-  {
-    wm::WindowState* window_state = wm::GetWindowState(pip_window2.get());
-    const wm::WMEvent enter_pip(wm::WM_EVENT_PIP);
-    window_state->OnWMEvent(&enter_pip);
-    pip_window2->SetProperty(aura::client::kAlwaysOnTopKey, true);
-    EXPECT_TRUE(window_state->IsPip());
-    EXPECT_TRUE(pip_window2->GetProperty(aura::client::kAlwaysOnTopKey));
-  }
-
-  // Making pinned window normal should not affect existing PIP windows.
-  wm::GetWindowState(pinned_window.get())->Restore();
-  EXPECT_TRUE(pip_window->GetProperty(aura::client::kAlwaysOnTopKey));
-  EXPECT_TRUE(pip_window2->GetProperty(aura::client::kAlwaysOnTopKey));
-}
-
 // Tests fullscreen window size during root window resize.
 TEST_F(WorkspaceLayoutManagerSoloTest, FullscreenRootWindowResize) {
   gfx::Rect bounds(100, 100, 200, 200);
@@ -2046,32 +1975,4 @@
   EXPECT_GE(test_state()->num_system_ui_area_changes(), 1);
 }
 
-
-TEST_F(WorkspaceLayoutManagerBackdropTest,
-       BackdropWindowIsNotReparentedFromAlwaysOnTopContainer) {
-  WorkspaceController* wc = ShellTestApi(Shell::Get()).workspace_controller();
-  WorkspaceControllerTestApi test_helper(wc);
-  RootWindowController* controller = Shell::GetPrimaryRootWindowController();
-  AlwaysOnTopController* always_on_top_controller =
-      controller->always_on_top_controller();
-
-  std::unique_ptr<aura::Window> always_on_top_window(
-      CreateTestWindowInShellWithBounds(gfx::Rect(1, 2, 3, 4)));
-  always_on_top_window->Show();
-  always_on_top_window->SetProperty(aura::client::kAlwaysOnTopKey, true);
-
-  aura::Window* always_on_top_container =
-  always_on_top_controller->GetContainer(always_on_top_window.get());
-  ShowTopWindowBackdropForContainer(always_on_top_container, true);
-  // AlwaysOnTopContainer has |always_on_top_window| and a backdrop window
-  // at this moment.
-  ASSERT_EQ(always_on_top_container->children().size(), 2U);
-
-  always_on_top_window->SetProperty(aura::client::kAlwaysOnTopKey, false);
-  // Make sure the backdrop window stays in AlwaysOnTopContainer even after
-  // |always_on_top_window| moves to the default container.
-  ASSERT_EQ(always_on_top_container->children().size(), 1U);
-  EXPECT_EQ(always_on_top_container->children()[0]->GetName(), "Backdrop");
-}
-
 }  // namespace ash
--- a/ash/wm/workspace/workspace_window_resizer.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/workspace/workspace_window_resizer.cc	2019-05-17 18:53:08.396000000 +0300
@@ -17,12 +17,9 @@
 #include "ash/shell.h"
 #include "ash/wm/default_window_resizer.h"
 #include "ash/wm/drag_window_resizer.h"
-#include "ash/wm/overview/overview_controller.h"
 #include "ash/wm/pip/pip_window_resizer.h"
-#include "ash/wm/tablet_mode/tablet_mode_browser_window_drag_delegate.h"
+#include "ash/wm/tablet_mode/tablet_mode_browser_window_drag_controller.h"
 #include "ash/wm/tablet_mode/tablet_mode_controller.h"
-#include "ash/wm/tablet_mode/tablet_mode_window_drag_controller.h"
-#include "ash/wm/tablet_mode/tablet_mode_window_drag_delegate.h"
 #include "ash/wm/window_positioning_utils.h"
 #include "ash/wm/window_state.h"
 #include "ash/wm/window_util.h"
@@ -44,67 +41,24 @@
 #include "ui/wm/core/coordinate_conversion.h"
 #include "ui/wm/core/cursor_manager.h"
 
-namespace ash {
-
 namespace {
 
 constexpr double kMinHorizVelocityForWindowSwipe = 1100;
 constexpr double kMinVertVelocityForWindowMinimize = 1000;
 
-// The drag delegate for app windows. It not only includes the logic in
-// TabletModeWindowDragDelegate, but also has special logic for app windows.
-class TabletModeAppWindowDragDelegate : public TabletModeWindowDragDelegate {
- public:
-  TabletModeAppWindowDragDelegate() = default;
-  ~TabletModeAppWindowDragDelegate() override = default;
-
- private:
-  // TabletModeWindowDragDelegate:
-  void PrepareWindowDrag(const gfx::Point& location_in_screen) override {}
-  void UpdateWindowDrag(const gfx::Point& location_in_screen) override {}
-  void EndingWindowDrag(wm::WmToplevelWindowEventHandler::DragResult result,
-                        const gfx::Point& location_in_screen) override {}
-  void EndedWindowDrag(const gfx::Point& location_in_screen) override {}
-  void StartFling(const ui::GestureEvent* event) override {
-    if (ShouldFlingIntoOverview(event)) {
-      DCHECK(Shell::Get()->overview_controller()->IsSelecting());
-      Shell::Get()->overview_controller()->overview_session()->AddItem(
-          dragged_window_, /*reposition=*/true, /*animate=*/false);
-    }
-  }
-
-  DISALLOW_COPY_AND_ASSIGN(TabletModeAppWindowDragDelegate);
-};
-
 // Returns true if |window| can be dragged from the top of the screen in tablet
 // mode.
-std::unique_ptr<WindowResizer> CreateWindowResizerForTabletMode(
-    aura::Window* window,
-    const gfx::Point& point_in_parent,
-    int window_component,
-    ::wm::WindowMoveSource source) {
-  wm::WindowState* window_state = wm::GetWindowState(window);
+bool CanDragInTabletMode(aura::Window* window, int window_component) {
+  ash::wm::WindowState* window_state = ash::wm::GetWindowState(window);
+  // Pip window can't be dragged.
+  if (window_state->IsPip())
+    return false;
+
   // Only maximized/fullscreen/snapped window can be dragged from the top of
   // the screen.
   if (!window_state->IsMaximized() && !window_state->IsFullscreen() &&
       !window_state->IsSnapped()) {
-    return nullptr;
-  }
-
-  AppType app_type =
-      static_cast<AppType>(window->GetProperty(aura::client::kAppType));
-  // App windows can be dragged from the client area (see
-  // WmToplevelWindowEventHandler).
-  if (app_type != AppType::BROWSER && window_component == HTCLIENT) {
-    DCHECK_EQ(source, ::wm::WINDOW_MOVE_SOURCE_TOUCH);
-    window_state->CreateDragDetails(point_in_parent, HTCLIENT,
-                                    ::wm::WINDOW_MOVE_SOURCE_TOUCH);
-    std::unique_ptr<WindowResizer> window_resizer =
-        std::make_unique<TabletModeWindowDragController>(
-            window_state, std::make_unique<TabletModeAppWindowDragDelegate>());
-    window_resizer = std::make_unique<DragWindowResizer>(
-        std::move(window_resizer), window_state);
-    return window_resizer;
+    return false;
   }
 
   // Only allow drag that happens on caption or top area. Note: for a maxmized
@@ -112,7 +66,7 @@
   // for a snapped window, the window component here can either be HTCAPTION or
   // HTTOP.
   if (window_component != HTCAPTION && window_component != HTTOP)
-    return nullptr;
+    return false;
 
   // Note: only browser windows and chrome app windows are included here.
   // For browser windows, this piece of codes will be called no matter the
@@ -120,23 +74,25 @@
   // But for app window, this piece of codes will only be called if the chrome
   // app window has its customized caption area and can't be hidden in tablet
   // mode (and thus the drag for this type of chrome app window always happens
-  // on caption or top area). The case where the caption area of the chrome app
-  // window can be hidden is handled above.
-  if (app_type != AppType::BROWSER && app_type != AppType::CHROME_APP)
-    return nullptr;
+  // on caption or top area). If the caption area of the chrome app window can
+  // be hidden, ImmersiveGestureHandlerClassic will handle the window drag
+  // through TabletModeAppWindowDragController.
+  // TODO(xdai, minch): Merge the logic in ImmersiveGestureHandlerClassic into
+  // CreateWindowResizer() in future.
+  ash::AppType app_type =
+      static_cast<ash::AppType>(window->GetProperty(aura::client::kAppType));
+  if (app_type != ash::AppType::BROWSER &&
+      app_type != ash::AppType::CHROME_APP) {
+    return false;
+  }
 
-  window_state->CreateDragDetails(point_in_parent, window_component, source);
-  std::unique_ptr<WindowResizer> window_resizer =
-      std::make_unique<TabletModeWindowDragController>(
-          window_state,
-          std::make_unique<TabletModeBrowserWindowDragDelegate>());
-  window_resizer = std::make_unique<DragWindowResizer>(
-      std::move(window_resizer), window_state);
-  return window_resizer;
+  return true;
 }
 
 }  // namespace
 
+namespace ash {
+
 std::unique_ptr<WindowResizer> CreateWindowResizer(
     aura::Window* window,
     const gfx::Point& point_in_parent,
@@ -172,8 +127,15 @@
   if (Shell::Get()
           ->tablet_mode_controller()
           ->IsTabletModeWindowManagerEnabled()) {
-    return CreateWindowResizerForTabletMode(window, point_in_parent,
-                                            window_component, source);
+    if (!CanDragInTabletMode(window, window_component))
+      return nullptr;
+
+    window_state->CreateDragDetails(point_in_parent, window_component, source);
+    window_resizer =
+        std::make_unique<TabletModeBrowserWindowDragController>(window_state);
+    window_resizer = std::make_unique<DragWindowResizer>(
+        std::move(window_resizer), window_state);
+    return window_resizer;
   }
 
   if (!window_state->IsNormalOrSnapped())
@@ -474,7 +436,7 @@
     // the drag and quit early if so.
     base::WeakPtr<WorkspaceWindowResizer> resizer(
         weak_ptr_factory_.GetWeakPtr());
-    SetBoundsDuringResize(bounds);
+    GetTarget()->SetBounds(bounds);
     if (!resizer)
       return;
   }
--- a/ash/wm/workspace/workspace_window_resizer_unittest.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/workspace/workspace_window_resizer_unittest.cc	2019-05-17 18:53:08.396000000 +0300
@@ -20,14 +20,12 @@
 #include "base/command_line.h"
 #include "base/strings/string_number_conversions.h"
 #include "base/strings/stringprintf.h"
-#include "base/test/metrics/histogram_tester.h"
 #include "services/ws/public/mojom/window_tree_constants.mojom.h"
 #include "ui/aura/client/aura_constants.h"
 #include "ui/aura/test/test_window_delegate.h"
 #include "ui/aura/test/test_windows.h"
 #include "ui/aura/window_event_dispatcher.h"
 #include "ui/base/hit_test.h"
-#include "ui/compositor/test/test_utils.h"
 #include "ui/display/display_layout.h"
 #include "ui/display/manager/display_manager.h"
 #include "ui/display/screen.h"
@@ -159,7 +157,7 @@
       if (*i == window_.get() || *i == window2_.get() || *i == window3_.get()) {
         if (!result.empty())
           result += " ";
-        result += base::NumberToString((*i)->id());
+        result += base::IntToString((*i)->id());
       }
     }
     return result;
@@ -633,7 +631,7 @@
     // With the resolution of 500x600 we will hit in this case the 50% screen
     // size setting.
     // TODO(varkha): Insets are updated because of http://crbug.com/292238
-    EXPECT_EQ("250,0 250x" + base::NumberToString(bottom),
+    EXPECT_EQ("250,0 250x" + base::IntToString(bottom),
               window_->bounds().ToString());
     EXPECT_EQ("800,10 400x60",
               window_state->GetRestoreBoundsInScreen().ToString());
@@ -821,7 +819,7 @@
   resizer->Drag(CalculateDragPoint(*resizer, 0, 600), 0);
   int expected_y =
       kRootHeight - WorkspaceWindowResizer::kMinOnscreenHeight - 10;
-  EXPECT_EQ("100," + base::NumberToString(expected_y) + " 300x400",
+  EXPECT_EQ("100," + base::IntToString(expected_y) + " 300x400",
             window_->bounds().ToString());
 }
 
@@ -851,7 +849,7 @@
     // When the mouse cursor is in the primary display, the window cannot move
     // on non-work area but can get all the way towards the bottom,
     // restricted only by the window height.
-    EXPECT_EQ("100," + base::NumberToString(expected_y) + " 300x20",
+    EXPECT_EQ("100," + base::IntToString(expected_y) + " 300x20",
               window_->bounds().ToString());
     // Revert the drag in order to not remember the restore bounds.
     resizer->RevertDrag();
@@ -870,7 +868,7 @@
         kRootHeight - WorkspaceWindowResizer::kMinOnscreenHeight - 10;
     // When the mouse cursor is in the primary display, the window cannot move
     // on non-work area with kMinOnscreenHeight margin.
-    EXPECT_EQ("100," + base::NumberToString(expected_y) + " 300x400",
+    EXPECT_EQ("100," + base::IntToString(expected_y) + " 300x400",
               window_->bounds().ToString());
     resizer->CompleteDrag();
   }
@@ -926,9 +924,8 @@
       window_.get(), gfx::Point(pixels_to_left_border, 0), HTRIGHT));
   ASSERT_TRUE(resizer.get());
   resizer->Drag(CalculateDragPoint(*resizer, -window_width, 0), 0);
-  EXPECT_EQ(base::NumberToString(window_x) + ",100 " +
-                base::NumberToString(wm::kMinimumOnScreenArea - window_x) +
-                "x380",
+  EXPECT_EQ(base::IntToString(window_x) + ",100 " +
+                base::IntToString(wm::kMinimumOnScreenArea - window_x) + "x380",
             window_->bounds().ToString());
 }
 
@@ -945,8 +942,8 @@
       CreateResizerForTest(window_.get(), gfx::Point(window_x, 0), HTLEFT));
   ASSERT_TRUE(resizer.get());
   resizer->Drag(CalculateDragPoint(*resizer, window_width, 0), 0);
-  EXPECT_EQ(base::NumberToString(right - wm::kMinimumOnScreenArea) + ",100 " +
-                base::NumberToString(window_width - pixels_to_right_border +
+  EXPECT_EQ(base::IntToString(right - wm::kMinimumOnScreenArea) + ",100 " +
+                base::IntToString(window_width - pixels_to_right_border +
                                      wm::kMinimumOnScreenArea) +
                 "x380",
             window_->bounds().ToString());
@@ -964,10 +961,10 @@
       window_.get(), gfx::Point(0, bottom - delta_to_bottom), HTTOP));
   ASSERT_TRUE(resizer.get());
   resizer->Drag(CalculateDragPoint(*resizer, 0, bottom), 0);
-  EXPECT_EQ("100," + base::NumberToString(bottom - wm::kMinimumOnScreenArea) +
+  EXPECT_EQ("100," + base::IntToString(bottom - wm::kMinimumOnScreenArea) +
                 " 300x" +
-                base::NumberToString(
-                    height - (delta_to_bottom - wm::kMinimumOnScreenArea)),
+                base::IntToString(height -
+                                  (delta_to_bottom - wm::kMinimumOnScreenArea)),
             window_->bounds().ToString());
 }
 
@@ -988,8 +985,8 @@
       CreateResizerForTest(window_.get(), gfx::Point(window_x, 0), HTCAPTION));
   ASSERT_TRUE(resizer.get());
   resizer->Drag(CalculateDragPoint(*resizer, window_width, 0), 0);
-  EXPECT_EQ(base::NumberToString(right - wm::kMinimumOnScreenArea) + ",100 " +
-                base::NumberToString(window_width) + "x380",
+  EXPECT_EQ(base::IntToString(right - wm::kMinimumOnScreenArea) + ",100 " +
+                base::IntToString(window_width) + "x380",
             window_->bounds().ToString());
 
   // With secondary display.  Operation itself is same but doesn't change
@@ -999,8 +996,8 @@
                                          gfx::Insets(0, 0, 50, 0));
   window_->SetBounds(gfx::Rect(window_x, 100, window_width, 380));
   resizer->Drag(CalculateDragPoint(*resizer, window_width, 0), 0);
-  EXPECT_EQ(base::NumberToString(window_x + window_width) + ",100 " +
-                base::NumberToString(window_width) + "x380",
+  EXPECT_EQ(base::IntToString(window_x + window_width) + ",100 " +
+                base::IntToString(window_width) + "x380",
             window_->bounds().ToString());
 }
 
@@ -1884,23 +1881,4 @@
             touch_resize_window_->bounds().ToString());
 }
 
-TEST_F(WorkspaceWindowResizerTest, ResizeHistogram) {
-  base::HistogramTester histograms;
-  window_->SetBounds(gfx::Rect(20, 30, 400, 60));
-  std::unique_ptr<WindowResizer> resizer(
-      CreateResizerForTest(window_.get(), gfx::Point(), HTRIGHT));
-  ASSERT_TRUE(resizer.get());
-  resizer->Drag(gfx::Point(50, 50), 0);
-
-  // A resize should generate a histogram.
-  EXPECT_NE(gfx::Size(400, 60), window_->bounds().size());
-  ui::WaitForNextFrameToBePresented(window_->GetHost()->compositor());
-  histograms.ExpectTotalCount("Ash.InteractiveWindowResize.TimeToPresent", 1);
-
-  // Completing the drag should not generate another histogram.
-  resizer->CompleteDrag();
-  ui::WaitForNextFrameToBePresented(window_->GetHost()->compositor());
-  histograms.ExpectTotalCount("Ash.InteractiveWindowResize.TimeToPresent", 1);
-}
-
 }  // namespace ash
--- a/ash/wm/workspace_controller_unittest.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/wm/workspace_controller_unittest.cc	2019-05-17 18:53:08.396000000 +0300
@@ -725,7 +725,7 @@
 
   // |window1| should be horizontally centered.
   int x_window1 = (desktop_area.width() - 300) / 2;
-  EXPECT_EQ(base::NumberToString(x_window1) + ",32 300x300",
+  EXPECT_EQ(base::IntToString(x_window1) + ",32 300x300",
             window1->bounds().ToString());
 
   // Create a |child| window and make it a transient child of |window1|.
@@ -738,7 +738,7 @@
   wm::ActivateWindow(child.get());
 
   // The |child| should be where it was created.
-  EXPECT_EQ(base::NumberToString(x_child) + ",20 200x200",
+  EXPECT_EQ(base::IntToString(x_child) + ",20 200x200",
             child->bounds().ToString());
 
   // Create and show a second window forcing the first window and its child to
@@ -753,12 +753,10 @@
   // Check that both |window1| and |child| have moved left.
   EXPECT_EQ("0,32 300x300", window1->bounds().ToString());
   int x = x_child - x_window1;
-  EXPECT_EQ(base::NumberToString(x) + ",20 200x200",
-            child->bounds().ToString());
+  EXPECT_EQ(base::IntToString(x) + ",20 200x200", child->bounds().ToString());
   // Check that |window2| has moved right.
   x = desktop_area.width() - window2->bounds().width();
-  EXPECT_EQ(base::NumberToString(x) + ",48 250x250",
-            window2->bounds().ToString());
+  EXPECT_EQ(base::IntToString(x) + ",48 250x250", window2->bounds().ToString());
 }
 
 // Test the basic auto placement of one and or two windows in a "simulated
@@ -800,13 +798,13 @@
   // |window1| should be flush left and |window3| flush right.
   EXPECT_EQ("0,32 640x320", window1->bounds().ToString());
   EXPECT_EQ(
-      base::NumberToString(desktop_area.width() - window3->bounds().width()) +
+      base::IntToString(desktop_area.width() - window3->bounds().width()) +
           ",48 256x512",
       window3->bounds().ToString());
 
   // After removing |window3|, |window1| should be centered again.
   window3.reset();
-  EXPECT_EQ(base::NumberToString(
+  EXPECT_EQ(base::IntToString(
                 (desktop_area.width() - window1->bounds().width()) / 2) +
                 ",32 640x320",
             window1->bounds().ToString());
@@ -821,7 +819,7 @@
   window4->SetBounds(gfx::Rect(32, 48, 256, 512));
   window1->Show();
   // |window1| should be centered and |window4| untouched.
-  EXPECT_EQ(base::NumberToString(
+  EXPECT_EQ(base::IntToString(
                 (desktop_area.width() - window1->bounds().width()) / 2) +
                 ",32 640x320",
             window1->bounds().ToString());
@@ -834,7 +832,7 @@
   window1->Hide();
   window1->Show();
   // |window1| should be centered.
-  EXPECT_EQ(base::NumberToString(
+  EXPECT_EQ(base::IntToString(
                 (desktop_area.width() - window1->bounds().width()) / 2) +
                 ",32 640x320",
             window1->bounds().ToString());
@@ -873,7 +871,7 @@
   // |window1| should be flush left and |window2| flush right.
   EXPECT_EQ("0,32 640x320", window1->bounds().ToString());
   EXPECT_EQ(
-      base::NumberToString(desktop_area.width() - window2->bounds().width()) +
+      base::IntToString(desktop_area.width() - window2->bounds().width()) +
           ",48 256x512",
       window2->bounds().ToString());
   // FLag should now be reset.
@@ -958,10 +956,10 @@
   window2->Show();
 
   // |window1| should be flush left and |window2| flush right.
-  EXPECT_EQ("0," + base::NumberToString(user_pos.y()) + " 640x320",
+  EXPECT_EQ("0," + base::IntToString(user_pos.y()) + " 640x320",
             window1->bounds().ToString());
   EXPECT_EQ(
-      base::NumberToString(desktop_area.width() - window2->bounds().width()) +
+      base::IntToString(desktop_area.width() - window2->bounds().width()) +
           ",48 256x512",
       window2->bounds().ToString());
   window2->Hide();
@@ -1041,7 +1039,7 @@
   // |window2| should be centered now.
   EXPECT_TRUE(window2->IsVisible());
   EXPECT_TRUE(window2_state->IsNormalStateType());
-  EXPECT_EQ(base::NumberToString(
+  EXPECT_EQ(base::IntToString(
                 (desktop_area.width() - window2->bounds().width()) / 2) +
                 ",48 256x512",
             window2->bounds().ToString());
@@ -1049,7 +1047,7 @@
   window1_state->Restore();
   // |window1| should be flush right and |window3| flush left.
   EXPECT_EQ(
-      base::NumberToString(desktop_area.width() - window1->bounds().width()) +
+      base::IntToString(desktop_area.width() - window1->bounds().width()) +
           ",32 640x320",
       window1->bounds().ToString());
   EXPECT_EQ("0,48 256x512", window2->bounds().ToString());
@@ -1073,7 +1071,7 @@
   // |window2| should be centered now.
   EXPECT_TRUE(window2->IsVisible());
   EXPECT_TRUE(window2_state->IsNormalStateType());
-  EXPECT_EQ(base::NumberToString(
+  EXPECT_EQ(base::IntToString(
                 (desktop_area.width() - window2->bounds().width()) / 2) +
                 ",48 256x512",
             window2->bounds().ToString());
@@ -1098,7 +1096,7 @@
 
   // |window1| should be flush right and |window3| flush left.
   EXPECT_EQ(
-      base::NumberToString(desktop_area.width() - window1->bounds().width()) +
+      base::IntToString(desktop_area.width() - window1->bounds().width()) +
           ",32 640x320",
       window1->bounds().ToString());
   EXPECT_EQ("0,40 256x512", window2->bounds().ToString());
@@ -1109,7 +1107,7 @@
   // |window2| should be centered now.
   EXPECT_TRUE(window2->IsVisible());
   EXPECT_TRUE(window2_state->IsNormalStateType());
-  EXPECT_EQ(base::NumberToString(
+  EXPECT_EQ(base::IntToString(
                 (desktop_area.width() - window2->bounds().width()) / 2) +
                 ",40 256x512",
             window2->bounds().ToString());
@@ -1133,7 +1131,7 @@
 
   // |window1| should be flush right and |window3| flush left.
   EXPECT_EQ(
-      base::NumberToString(desktop_area.width() - window1->bounds().width()) +
+      base::IntToString(desktop_area.width() - window1->bounds().width()) +
           ",32 640x320",
       window1->bounds().ToString());
   EXPECT_EQ("0,40 256x512", window2->bounds().ToString());
@@ -1143,7 +1141,7 @@
 
   // |window1| should be flush right and |window2| flush left.
   EXPECT_EQ(
-      base::NumberToString(desktop_area.width() - window1->bounds().width()) +
+      base::IntToString(desktop_area.width() - window1->bounds().width()) +
           ",32 640x320",
       window1->bounds().ToString());
   EXPECT_EQ("0,40 256x512", window2->bounds().ToString());
@@ -1181,7 +1179,7 @@
   window2->layer()->GetAnimator()->StopAnimating();
   // |window1| should be flush right and |window2| flush left.
   EXPECT_EQ(
-      base::NumberToString(desktop_area.width() - window1->bounds().width()) +
+      base::IntToString(desktop_area.width() - window1->bounds().width()) +
           ",32 640x320",
       window1->bounds().ToString());
   EXPECT_EQ("0,48 256x512", window2->bounds().ToString());
--- a/ash/ws/ash_gpu_interface_provider.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/ws/ash_gpu_interface_provider.cc	2019-05-17 18:53:08.396000000 +0300
@@ -27,8 +27,8 @@
 
 void AshGpuInterfaceProvider::RegisterGpuInterfaces(
     service_manager::BinderRegistry* registry) {
-  registry->AddInterface<ws::mojom::ArcGpu>(base::BindRepeating(
-      &AshGpuInterfaceProvider::BindArcGpuRequest, base::Unretained(this)));
+  registry->AddInterface<ws::mojom::Arc>(base::BindRepeating(
+      &AshGpuInterfaceProvider::BindArcRequest, base::Unretained(this)));
   registry->AddInterface(base::BindRepeating(
       &AshGpuInterfaceProvider::BindDiscardableSharedMemoryManagerRequest,
       base::Unretained(this)));
@@ -42,9 +42,8 @@
   gpu_host_->BindOzoneGpuInterface(interface_name, std::move(handle));
 }
 
-void AshGpuInterfaceProvider::BindArcGpuRequest(
-    ws::mojom::ArcGpuRequest request) {
-  gpu_host_->AddArcGpu(std::move(request));
+void AshGpuInterfaceProvider::BindArcRequest(ws::mojom::ArcRequest request) {
+  gpu_host_->AddArc(std::move(request));
 }
 
 void AshGpuInterfaceProvider::BindDiscardableSharedMemoryManagerRequest(
--- a/ash/ws/ash_gpu_interface_provider.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/ws/ash_gpu_interface_provider.h	2019-05-17 18:53:08.396000000 +0300
@@ -7,7 +7,7 @@
 
 #include "components/discardable_memory/public/interfaces/discardable_shared_memory_manager.mojom.h"
 #include "services/ws/public/cpp/host/gpu_interface_provider.h"
-#include "services/ws/public/mojom/arc_gpu.mojom.h"
+#include "services/ws/public/mojom/arc.mojom.h"
 #include "services/ws/public/mojom/gpu.mojom.h"
 
 namespace discardable_memory {
@@ -37,7 +37,7 @@
                              mojo::ScopedMessagePipeHandle handle) override;
 
  private:
-  void BindArcGpuRequest(ws::mojom::ArcGpuRequest request);
+  void BindArcRequest(ws::mojom::ArcRequest request);
   void BindDiscardableSharedMemoryManagerRequest(
       discardable_memory::mojom::DiscardableSharedMemoryManagerRequest request);
   void BindGpuRequest(ws::mojom::GpuRequest request);
--- a/ash/ws/ax_ash_window_utils.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/ws/ax_ash_window_utils.cc	2019-05-17 18:53:08.396000000 +0300
@@ -4,11 +4,7 @@
 
 #include "ash/ws/ax_ash_window_utils.h"
 
-#include <vector>
-
-#include "ash/shell.h"
 #include "ash/ws/window_lookup.h"
-#include "base/stl_util.h"
 #include "ui/views/widget/widget.h"
 
 namespace ash {
@@ -61,12 +57,10 @@
 }
 
 bool AXAshWindowUtils::IsRootWindow(aura::Window* window) const {
-  if (!window->IsRootWindow())
-    return false;
   // SingleProcessMash behaves like classic ash. Only display roots are
-  // considered root windows for accessibility, not top-level Widgets or embeds.
-  std::vector<aura::Window*> roots = Shell::GetAllRootWindows();
-  return base::ContainsValue(roots, window);
+  // considered root windows for accessibility, not top-level Widgets.
+  return window->IsRootWindow() &&
+         !views::Widget::GetWidgetForNativeWindow(window);
 }
 
 views::Widget* AXAshWindowUtils::GetWidgetForNativeView(aura::Window* window) {
--- a/ash/ws/ax_ash_window_utils.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/ws/ax_ash_window_utils.h	2019-05-17 18:53:08.396000000 +0300
@@ -13,7 +13,7 @@
 
 // Provides functions for walking a tree of aura::Windows for accessibility. For
 // SingleProcessMash we want the accessibility tree to jump from a proxy aura
-// Window on the ash side directly to its corresponding client window. This is
+// Window on the ash side direclty to its corresponding client window. This is
 // just a temporary solution to that issue and should be removed once Mash is
 // fully launched. https://crbug.com/911945
 class ASH_EXPORT AXAshWindowUtils : public views::AXAuraWindowUtils {
--- a/ash/ws/ax_ash_window_utils_unittest.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/ws/ax_ash_window_utils_unittest.cc	2019-05-17 18:53:08.396000000 +0300
@@ -20,8 +20,6 @@
 #include "ui/aura/env.h"
 #include "ui/aura/mus/window_mus.h"
 #include "ui/aura/mus/window_tree_client.h"
-#include "ui/aura/mus/window_tree_host_mus.h"
-#include "ui/aura/mus/window_tree_host_mus_init_params.h"
 #include "ui/aura/test/mus/change_completion_waiter.h"
 #include "ui/aura/window.h"
 #include "ui/base/ui_base_features.h"
@@ -196,29 +194,5 @@
   EXPECT_EQ(textfield_wrapper, cache->GetFocus());
 }
 
-TEST_F(AXAshWindowUtilsTest, IsRootWindow) {
-  AXAshWindowUtils utils;
-
-  // From the client's perspective a widget's root window is a root.
-  aura::Window* widget_root = widget_->GetNativeWindow()->GetRootWindow();
-  EXPECT_TRUE(widget_root->IsRootWindow());
-
-  // Simulate an embedded remote client window.
-  aura::WindowTreeHostMus window_tree_host(aura::CreateInitParamsForTopLevel(
-      views::MusClient::Get()->window_tree_client()));
-  window_tree_host.InitHost();
-  window_tree_host.SetBounds(gfx::Rect(0, 0, 100, 200),
-                             viz::LocalSurfaceIdAllocation());
-  aura::Window* embed_root = window_tree_host.window();
-
-  // From the client's perspective the embed is a root.
-  EXPECT_TRUE(embed_root->IsRootWindow());
-
-  // Accessibility serialization only considers display roots to be roots.
-  EXPECT_TRUE(utils.IsRootWindow(Shell::GetPrimaryRootWindow()));
-  EXPECT_FALSE(utils.IsRootWindow(embed_root));
-  EXPECT_FALSE(utils.IsRootWindow(widget_root));
-}
-
 }  // namespace
 }  // namespace ash
--- a/ash/ws/window_service_delegate_impl.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/ws/window_service_delegate_impl.cc	2019-05-17 18:53:08.396000000 +0300
@@ -11,7 +11,6 @@
 #include "ash/shell.h"
 #include "ash/wm/container_finder.h"
 #include "ash/wm/non_client_frame_controller.h"
-#include "ash/wm/resize_shadow_controller.h"
 #include "ash/wm/top_level_window_factory.h"
 #include "ash/wm/toplevel_window_event_handler.h"
 #include "ash/wm/window_finder.h"
@@ -82,7 +81,6 @@
 WindowServiceDelegateImpl::~WindowServiceDelegateImpl() = default;
 
 std::unique_ptr<aura::Window> WindowServiceDelegateImpl::NewTopLevel(
-    ws::TopLevelProxyWindow* top_level_proxy_window,
     aura::PropertyConverter* property_converter,
     const base::flat_map<std::string, std::vector<uint8_t>>& properties) {
   std::map<std::string, std::vector<uint8_t>> property_map =
@@ -90,8 +88,8 @@
   ws::mojom::WindowType window_type =
       aura::GetWindowTypeFromProperties(property_map);
 
-  auto* window = CreateAndParentTopLevelWindow(
-      top_level_proxy_window, window_type, property_converter, &property_map);
+  auto* window = CreateAndParentTopLevelWindow(window_type, property_converter,
+                                               &property_map);
   return base::WrapUnique<aura::Window>(window);
 }
 
@@ -115,7 +113,6 @@
     aura::Window* window,
     ws::mojom::MoveLoopSource source,
     const gfx::Point& cursor,
-    int window_component,
     DoneCallback callback) {
   if (!ShouldStartMoveLoop(window)) {
     std::move(callback).Run(false);
@@ -137,9 +134,8 @@
       ->toplevel_window_event_handler()
       ->wm_toplevel_window_event_handler()
       ->AttemptToStartDrag(
-          window, location_in_parent, window_component, aura_source,
-          base::BindOnce(&OnMoveLoopCompleted, std::move(callback)),
-          /*update_gesture_target=*/false);
+          window, location_in_parent, HTCAPTION, aura_source,
+          base::BindOnce(&OnMoveLoopCompleted, std::move(callback)));
 }
 
 void WindowServiceDelegateImpl::CancelWindowMoveLoop() {
@@ -177,15 +173,6 @@
   aura::client::GetDragDropClient(window->GetRootWindow())->DragCancel();
 }
 
-void WindowServiceDelegateImpl::SetWindowResizeShadow(aura::Window* window,
-                                                      int hit_test) {
-  ResizeShadowController* controller = Shell::Get()->resize_shadow_controller();
-  if (hit_test == HTNOWHERE)
-    controller->HideShadow(window);
-  else
-    controller->ShowShadow(window, hit_test);
-}
-
 void WindowServiceDelegateImpl::UpdateTextInputState(
     aura::Window* window,
     ui::mojom::TextInputStatePtr state) {
--- a/ash/ws/window_service_delegate_impl.h	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/ws/window_service_delegate_impl.h	2019-05-17 18:53:08.396000000 +0300
@@ -18,7 +18,6 @@
 
   // ws::WindowServiceDelegate:
   std::unique_ptr<aura::Window> NewTopLevel(
-      ws::TopLevelProxyWindow* top_level_proxy_window,
       aura::PropertyConverter* property_converter,
       const base::flat_map<std::string, std::vector<uint8_t>>& properties)
       override;
@@ -27,7 +26,6 @@
   void RunWindowMoveLoop(aura::Window* window,
                          ws::mojom::MoveLoopSource source,
                          const gfx::Point& cursor,
-                         int window_component,
                          DoneCallback callback) override;
   void CancelWindowMoveLoop() override;
   void RunDragLoop(aura::Window* window,
@@ -37,7 +35,6 @@
                    ui::DragDropTypes::DragEventSource source,
                    DragDropCompletedCallback callback) override;
   void CancelDragLoop(aura::Window* window) override;
-  void SetWindowResizeShadow(aura::Window* window, int hit_test) override;
   void UpdateTextInputState(aura::Window* window,
                             ui::mojom::TextInputStatePtr state) override;
   void UpdateImeVisibility(aura::Window* window,
--- a/ash/ws/window_service_delegate_impl_unittest.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/ws/window_service_delegate_impl_unittest.cc	2019-05-17 18:53:08.400000000 +0300
@@ -2,11 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "ash/frame/non_client_frame_view_ash.h"
 #include "ash/shell.h"
 #include "ash/test/ash_test_base.h"
-#include "ash/wm/resize_shadow.h"
-#include "ash/wm/resize_shadow_controller.h"
 #include "ash/wm/toplevel_window_event_handler.h"
 #include "ash/ws/window_service_owner.h"
 #include "base/run_loop.h"
@@ -20,7 +17,6 @@
 #include "ui/aura/client/drag_drop_delegate.h"
 #include "ui/aura/window.h"
 #include "ui/base/dragdrop/drag_drop_types.h"
-#include "ui/base/hit_test.h"
 #include "ui/display/display.h"
 #include "ui/display/screen.h"
 #include "ui/events/test/event_generator.h"
@@ -50,12 +46,6 @@
   DISALLOW_COPY_AND_ASSIGN(TestDragDropDelegate);
 };
 
-bool IsResizeShadowVisible(ResizeShadow* resize_shadow) {
-  if (!resize_shadow)
-    return false;
-  return resize_shadow->GetLayerForTest()->GetTargetVisibility();
-}
-
 }  // namespace
 
 // This test creates a top-level window via the WindowService in SetUp() and
@@ -92,8 +82,6 @@
   // AshTestBase:
   void SetUp() override {
     AshTestBase::SetUp();
-    Shell::Get()->aura_env()->set_throttle_input_on_resize_for_testing(false);
-    NonClientFrameViewAsh::use_empty_minimum_size_for_test_ = true;
     top_level_ = CreateTestWindow(gfx::Rect(100, 100, 100, 100));
     ASSERT_TRUE(top_level_);
     GetEventGenerator()->PressLeftButton();
@@ -103,7 +91,6 @@
     // needs to delete |top_level_| before the WindowTree is deleted, otherwise
     // the WindowTree will delete |top_level_|, leading to a double delete.
     top_level_.reset();
-    NonClientFrameViewAsh::use_empty_minimum_size_for_test_ = false;
     AshTestBase::TearDown();
   }
 
@@ -117,8 +104,8 @@
 
 TEST_F(WindowServiceDelegateImplTest, RunWindowMoveLoop) {
   GetWindowTreeTestHelper()->window_tree()->PerformWindowMove(
-      21, GetTopLevelWindowId(), ws::mojom::MoveLoopSource::MOUSE, gfx::Point(),
-      HTCAPTION);
+      21, GetTopLevelWindowId(), ws::mojom::MoveLoopSource::MOUSE,
+      gfx::Point());
   EXPECT_TRUE(event_handler()->is_drag_in_progress());
   GetEventGenerator()->MoveMouseTo(gfx::Point(5, 6));
   EXPECT_EQ(gfx::Point(105, 106), top_level_->bounds().origin());
@@ -135,7 +122,7 @@
   UpdateDisplay("500x500,500x500");
   GetWindowTreeTestHelper()->window_tree()->PerformWindowMove(
       21, GetTopLevelWindowId(), ws::mojom::MoveLoopSource::MOUSE,
-      top_level_->GetBoundsInScreen().origin(), HTCAPTION);
+      top_level_->GetBoundsInScreen().origin());
   GetEventGenerator()->MoveMouseTo(gfx::Point(501, 1));
   GetWindowTreeClientChanges()->clear();
   GetEventGenerator()->ReleaseLeftButton();
@@ -147,8 +134,8 @@
                      "DisplayChanged window_id=0,1 display_id=2200000001"));
   EXPECT_TRUE(ContainsChange(
       *GetWindowTreeClientChanges(),
-      std::string("BoundsChanged window=0,1 bounds=500,0 100x100 "
-                  "local_surface_id=*")));
+      std::string("BoundsChanged window=0,1 old_bounds=500,0 104x100 "
+                  "new_bounds=500,0 104x100 local_surface_id=*")));
 }
 
 TEST_F(WindowServiceDelegateImplTest, SetWindowBoundsToDifferentDisplay) {
@@ -157,19 +144,24 @@
 
   GetWindowTreeClientChanges()->clear();
   GetWindowTreeTestHelper()->window_tree()->SetWindowBounds(
-      21, GetTopLevelWindowId(), gfx::Rect(600, 100, 100, 100), base::nullopt);
+      21, GetTopLevelWindowId(), gfx::Rect(600, 100, 100, 100),
+      base::Optional<viz::LocalSurfaceId>());
   EXPECT_EQ(gfx::Point(600, 100), top_level_->GetBoundsInScreen().origin());
   EXPECT_EQ(Shell::GetRootWindowForDisplayId(GetSecondaryDisplay().id()),
             top_level_->GetRootWindow());
   EXPECT_TRUE(
       ContainsChange(*GetWindowTreeClientChanges(),
                      "DisplayChanged window_id=0,1 display_id=2200000001"));
+  EXPECT_TRUE(ContainsChange(
+      *GetWindowTreeClientChanges(),
+      std::string("BoundsChanged window=0,1 old_bounds=100,100 100x100 "
+                  "new_bounds=600,100 104x100 local_surface_id=*")));
 }
 
 TEST_F(WindowServiceDelegateImplTest, DeleteWindowWithInProgressRunLoop) {
   GetWindowTreeTestHelper()->window_tree()->PerformWindowMove(
-      29, GetTopLevelWindowId(), ws::mojom::MoveLoopSource::MOUSE, gfx::Point(),
-      HTCAPTION);
+      29, GetTopLevelWindowId(), ws::mojom::MoveLoopSource::MOUSE,
+      gfx::Point());
   EXPECT_TRUE(event_handler()->is_drag_in_progress());
   top_level_.reset();
   EXPECT_FALSE(event_handler()->is_drag_in_progress());
@@ -189,7 +181,7 @@
 
   GetWindowTreeTestHelper()->window_tree()->PerformWindowMove(
       21, GetTopLevelWindowId(), ws::mojom::MoveLoopSource::MOUSE,
-      gfx::Point(605, 106), HTCAPTION);
+      gfx::Point(605, 106));
 
   EXPECT_TRUE(event_handler()->is_drag_in_progress());
   GetEventGenerator()->MoveMouseTo(gfx::Point(615, 120));
@@ -198,8 +190,8 @@
 
 TEST_F(WindowServiceDelegateImplTest, CancelWindowMoveLoop) {
   GetWindowTreeTestHelper()->window_tree()->PerformWindowMove(
-      21, GetTopLevelWindowId(), ws::mojom::MoveLoopSource::MOUSE, gfx::Point(),
-      HTCAPTION);
+      21, GetTopLevelWindowId(), ws::mojom::MoveLoopSource::MOUSE,
+      gfx::Point());
   EXPECT_TRUE(event_handler()->is_drag_in_progress());
   GetEventGenerator()->MoveMouseTo(gfx::Point(5, 6));
   EXPECT_EQ(gfx::Point(105, 106), top_level_->bounds().origin());
@@ -212,61 +204,6 @@
   EXPECT_EQ(gfx::Point(100, 100), top_level_->bounds().origin());
 }
 
-TEST_F(WindowServiceDelegateImplTest, WindowResize) {
-  gfx::Rect bounds = top_level_->bounds();
-  GetWindowTreeTestHelper()->window_tree()->PerformWindowMove(
-      21, GetTopLevelWindowId(), ws::mojom::MoveLoopSource::MOUSE, gfx::Point(),
-      HTTOPLEFT);
-  EXPECT_TRUE(event_handler()->is_drag_in_progress());
-  GetEventGenerator()->MoveMouseBy(5, 6);
-  bounds.Inset(5, 6, 0, 0);
-  EXPECT_EQ(bounds, top_level_->bounds());
-  GetWindowTreeClientChanges()->clear();
-  GetEventGenerator()->ReleaseLeftButton();
-
-  // Releasing the mouse completes the move loop.
-  EXPECT_TRUE(ContainsChange(*GetWindowTreeClientChanges(),
-                             "ChangeCompleted id=21 success=true"));
-  EXPECT_EQ(bounds, top_level_->bounds());
-}
-
-TEST_F(WindowServiceDelegateImplTest, InvalidWindowComponent) {
-  gfx::Rect bounds = top_level_->bounds();
-  GetWindowTreeTestHelper()->window_tree()->PerformWindowMove(
-      21, GetTopLevelWindowId(), ws::mojom::MoveLoopSource::MOUSE,
-      bounds.origin(), HTCLIENT);
-  EXPECT_FALSE(event_handler()->is_drag_in_progress());
-  GetEventGenerator()->MoveMouseTo(5, 6);
-  EXPECT_EQ(bounds, top_level_->bounds());
-  GetEventGenerator()->ReleaseLeftButton();
-}
-
-TEST_F(WindowServiceDelegateImplTest, SetWindowResizeShadow) {
-  ResizeShadowController* controller = Shell::Get()->resize_shadow_controller();
-
-  GetWindowTreeTestHelper()->window_tree()->SetWindowResizeShadow(
-      GetTopLevelWindowId(), HTNOWHERE);
-  EXPECT_FALSE(IsResizeShadowVisible(
-      controller->GetShadowForWindowForTest(top_level_.get())));
-
-  GetWindowTreeTestHelper()->window_tree()->SetWindowResizeShadow(
-      GetTopLevelWindowId(), HTTOPLEFT);
-  ResizeShadow* shadow =
-      controller->GetShadowForWindowForTest(top_level_.get());
-  EXPECT_TRUE(IsResizeShadowVisible(shadow));
-  EXPECT_EQ(HTTOPLEFT, shadow->GetLastHitTestForTest());
-
-  // Nothing should change for invalid hit-test.
-  GetWindowTreeTestHelper()->window_tree()->SetWindowResizeShadow(
-      GetTopLevelWindowId(), HTCLIENT);
-  EXPECT_TRUE(IsResizeShadowVisible(shadow));
-  EXPECT_EQ(HTTOPLEFT, shadow->GetLastHitTestForTest());
-
-  GetWindowTreeTestHelper()->window_tree()->SetWindowResizeShadow(
-      GetTopLevelWindowId(), HTNOWHERE);
-  EXPECT_FALSE(IsResizeShadowVisible(shadow));
-}
-
 TEST_F(WindowServiceDelegateImplTest, RunDragLoop) {
   SetCanAcceptDrops();
   GetWindowTreeTestHelper()->window_tree()->PerformDragDrop(
@@ -439,8 +376,8 @@
             screen->GetDisplayNearestWindow(top_level_.get()).id());
 
   GetWindowTreeTestHelper()->window_tree()->PerformWindowMove(
-      21, GetTopLevelWindowId(), ws::mojom::MoveLoopSource::MOUSE, gfx::Point(),
-      HTCAPTION);
+      21, GetTopLevelWindowId(), ws::mojom::MoveLoopSource::MOUSE,
+      gfx::Point());
   EXPECT_TRUE(event_handler()->is_drag_in_progress());
   GetEventGenerator()->MoveMouseTo(gfx::Point(610, 6));
   GetWindowTreeClientChanges()->clear();
@@ -479,8 +416,8 @@
                          base::NumberToString(display1.id())));
   EXPECT_TRUE(ContainsChange(
       *GetWindowTreeClientChanges(),
-      std::string("BoundsChanged window=0,1 bounds=100,100 100x100 "
-                  "local_surface_id=*")));
+      std::string("BoundsChanged window=0,1 old_bounds=* "
+                  "new_bounds=100,100 104x100 local_surface_id=*")));
 }
 
 TEST_F(WindowServiceDelegateImplTest, MultiDisplayEventInjector) {
--- a/ash/ws/window_service_owner.cc	2019-05-01 01:22:27.000000000 +0300
+++ b/ash/ws/window_service_owner.cc	2019-05-17 18:53:08.400000000 +0300
@@ -10,7 +10,6 @@
 #include "ash/shell.h"
 #include "ash/wm/non_client_frame_controller.h"
 #include "ash/ws/window_service_delegate_impl.h"
-#include "base/bind_helpers.h"
 #include "base/lazy_instance.h"
 #include "base/unguessable_token.h"
 #include "services/content/public/cpp/buildflags.h"
--- a/ash/accelerators/accelerator_interactive_uitest_chromeos.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/ash/accelerators/accelerator_interactive_uitest_chromeos.cc	2019-05-17 18:53:08.064000000 +0300
@@ -0,0 +1,204 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ash/accelerators/accelerator_controller.h"
+
+#include "ash/app_list/test/app_list_test_helper.h"
+#include "ash/shell.h"
+#include "ash/shell_observer.h"
+#include "ash/system/network/network_observer.h"
+#include "ash/system/tray/system_tray_notifier.h"
+#include "ash/test/ash_interactive_ui_test_base.h"
+#include "ash/test_screenshot_delegate.h"
+#include "ash/wm/window_state.h"
+#include "ash/wm/window_util.h"
+#include "base/run_loop.h"
+#include "base/test/metrics/user_action_tester.h"
+#include "chromeos/network/network_handler.h"
+#include "ui/base/test/ui_controls.h"
+
+namespace ash {
+
+namespace {
+
+// A network observer to watch for the toggle wifi events.
+class TestNetworkObserver : public NetworkObserver {
+ public:
+  TestNetworkObserver() : wifi_enabled_status_(false) {}
+
+  // ash::NetworkObserver:
+  void RequestToggleWifi() override {
+    wifi_enabled_status_ = !wifi_enabled_status_;
+  }
+
+  bool wifi_enabled_status() const { return wifi_enabled_status_; }
+
+ private:
+  bool wifi_enabled_status_;
+
+  DISALLOW_COPY_AND_ASSIGN(TestNetworkObserver);
+};
+
+}  // namespace
+
+////////////////////////////////////////////////////////////////////////////////
+
+// This is intended to test few samples from each category of accelerators to
+// make sure they work properly. The test is done as an interactive ui test
+// using ui_controls::Send*() functions.
+// This is to catch any future regressions (crbug.com/469235).
+class AcceleratorInteractiveUITest : public AshInteractiveUITestBase,
+                                     public ShellObserver {
+ public:
+  AcceleratorInteractiveUITest() : is_in_overview_mode_(false) {}
+
+  void SetUp() override {
+    AshInteractiveUITestBase::SetUp();
+
+    Shell::Get()->AddShellObserver(this);
+
+    chromeos::NetworkHandler::Initialize();
+  }
+
+  void TearDown() override {
+    chromeos::NetworkHandler::Shutdown();
+
+    Shell::Get()->RemoveShellObserver(this);
+
+    AshInteractiveUITestBase::TearDown();
+  }
+
+  // Sends a key press event and waits synchronously until it's completely
+  // processed.
+  void SendKeyPressSync(ui::KeyboardCode key,
+                        bool control,
+                        bool shift,
+                        bool alt) {
+    base::RunLoop loop;
+    ui_controls::SendKeyPressNotifyWhenDone(Shell::GetPrimaryRootWindow(), key,
+                                            control, shift, alt, false,
+                                            loop.QuitClosure());
+    loop.Run();
+  }
+
+  // ash::ShellObserver:
+  void OnOverviewModeStarting() override { is_in_overview_mode_ = true; }
+  void OnOverviewModeEnded() override { is_in_overview_mode_ = false; }
+
+ protected:
+  bool is_in_overview_mode_;
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(AcceleratorInteractiveUITest);
+};
+
+////////////////////////////////////////////////////////////////////////////////
+
+#if defined(OFFICIAL_BUILD)
+#define MAYBE_NonRepeatableNeedingWindowActions \
+  DISABLED_NonRepeatableNeedingWindowActions
+#define MAYBE_ChromeOsAccelerators DISABLED_ChromeOsAccelerators
+#define MAYBE_ToggleAppList DISABLED_ToggleAppList
+#else
+#define MAYBE_NonRepeatableNeedingWindowActions \
+  NonRepeatableNeedingWindowActions
+#define MAYBE_ChromeOsAccelerators ChromeOsAccelerators
+#define MAYBE_ToggleAppList ToggleAppList
+#endif  // defined(OFFICIAL_BUILD)
+
+// Tests a sample of the non-repeatable accelerators that need windows to be
+// enabled.
+TEST_F(AcceleratorInteractiveUITest, MAYBE_NonRepeatableNeedingWindowActions) {
+  // Create a bunch of windows to work with.
+  aura::Window* window_1 =
+      CreateTestWindowInShellWithBounds(gfx::Rect(0, 0, 100, 100));
+  aura::Window* window_2 =
+      CreateTestWindowInShellWithBounds(gfx::Rect(0, 0, 100, 100));
+  window_1->Show();
+  wm::ActivateWindow(window_1);
+  window_2->Show();
+  wm::ActivateWindow(window_2);
+
+  // Test TOGGLE_OVERVIEW.
+  EXPECT_FALSE(is_in_overview_mode_);
+  SendKeyPressSync(ui::VKEY_MEDIA_LAUNCH_APP1, false, false, false);
+  EXPECT_TRUE(is_in_overview_mode_);
+  SendKeyPressSync(ui::VKEY_MEDIA_LAUNCH_APP1, false, false, false);
+  EXPECT_FALSE(is_in_overview_mode_);
+
+  // Test CYCLE_FORWARD_MRU and CYCLE_BACKWARD_MRU.
+  wm::ActivateWindow(window_1);
+  EXPECT_TRUE(wm::IsActiveWindow(window_1));
+  EXPECT_FALSE(wm::IsActiveWindow(window_2));
+  SendKeyPressSync(ui::VKEY_TAB, false, false, true);  // CYCLE_FORWARD_MRU.
+  EXPECT_TRUE(wm::IsActiveWindow(window_2));
+  EXPECT_FALSE(wm::IsActiveWindow(window_1));
+  SendKeyPressSync(ui::VKEY_TAB, false, true, true);  // CYCLE_BACKWARD_MRU.
+  EXPECT_TRUE(wm::IsActiveWindow(window_1));
+  EXPECT_FALSE(wm::IsActiveWindow(window_2));
+
+  // Test TOGGLE_FULLSCREEN.
+  wm::WindowState* active_window_state = wm::GetActiveWindowState();
+  EXPECT_FALSE(active_window_state->IsFullscreen());
+  SendKeyPressSync(ui::VKEY_MEDIA_LAUNCH_APP2, false, false, false);
+  EXPECT_TRUE(active_window_state->IsFullscreen());
+  SendKeyPressSync(ui::VKEY_MEDIA_LAUNCH_APP2, false, false, false);
+  EXPECT_FALSE(active_window_state->IsFullscreen());
+}
+
+// Tests a sample of ChromeOS specific accelerators.
+TEST_F(AcceleratorInteractiveUITest, MAYBE_ChromeOsAccelerators) {
+  // Test TAKE_SCREENSHOT and TAKE_PARTIAL_SCREENSHOT.
+  TestScreenshotDelegate* screenshot_delegate = GetScreenshotDelegate();
+  screenshot_delegate->set_can_take_screenshot(true);
+  EXPECT_EQ(0, screenshot_delegate->handle_take_screenshot_count());
+  SendKeyPressSync(ui::VKEY_MEDIA_LAUNCH_APP1, true, false, false);
+  EXPECT_EQ(1, screenshot_delegate->handle_take_screenshot_count());
+  SendKeyPressSync(ui::VKEY_SNAPSHOT, false, false, false);
+  EXPECT_EQ(2, screenshot_delegate->handle_take_screenshot_count());
+  SendKeyPressSync(ui::VKEY_MEDIA_LAUNCH_APP1, true, true, false);
+  EXPECT_EQ(2, screenshot_delegate->handle_take_screenshot_count());
+  // Press ESC to go out of the partial screenshot mode.
+  SendKeyPressSync(ui::VKEY_ESCAPE, false, false, false);
+
+  // Test VOLUME_MUTE.
+  base::UserActionTester user_action_tester;
+  EXPECT_EQ(0, user_action_tester.GetActionCount("Accel_VolumeMute_F8"));
+  SendKeyPressSync(ui::VKEY_VOLUME_MUTE, false, false, false);
+  EXPECT_EQ(1, user_action_tester.GetActionCount("Accel_VolumeMute_F8"));
+  // Test VOLUME_DOWN.
+  EXPECT_EQ(0, user_action_tester.GetActionCount("Accel_VolumeDown_F9"));
+  SendKeyPressSync(ui::VKEY_VOLUME_DOWN, false, false, false);
+  EXPECT_EQ(1, user_action_tester.GetActionCount("Accel_VolumeDown_F9"));
+  // Test VOLUME_UP.
+  EXPECT_EQ(0, user_action_tester.GetActionCount("Accel_VolumeUp_F10"));
+  SendKeyPressSync(ui::VKEY_VOLUME_UP, false, false, false);
+  EXPECT_EQ(1, user_action_tester.GetActionCount("Accel_VolumeUp_F10"));
+
+  // Test TOGGLE_WIFI.
+  TestNetworkObserver network_observer;
+  Shell::Get()->system_tray_notifier()->AddNetworkObserver(&network_observer);
+
+  EXPECT_FALSE(network_observer.wifi_enabled_status());
+  SendKeyPressSync(ui::VKEY_WLAN, false, false, false);
+  EXPECT_TRUE(network_observer.wifi_enabled_status());
+  SendKeyPressSync(ui::VKEY_WLAN, false, false, false);
+  EXPECT_FALSE(network_observer.wifi_enabled_status());
+
+  Shell::Get()->system_tray_notifier()->RemoveNetworkObserver(
+      &network_observer);
+}
+
+// Tests the app list accelerator.
+TEST_F(AcceleratorInteractiveUITest, MAYBE_ToggleAppList) {
+  GetAppListTestHelper()->CheckVisibility(false);
+  SendKeyPressSync(ui::VKEY_LWIN, false, false, false);
+  base::RunLoop().RunUntilIdle();
+  GetAppListTestHelper()->CheckVisibility(true);
+  SendKeyPressSync(ui::VKEY_LWIN, false, false, false);
+  base::RunLoop().RunUntilIdle();
+  GetAppListTestHelper()->CheckVisibility(false);
+}
+
+}  // namespace ash
--- a/ash/app_launch_unittest.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/ash/app_launch_unittest.cc	2019-05-17 18:53:08.072000000 +0300
@@ -0,0 +1,75 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ash/components/quick_launch/public/mojom/constants.mojom.h"
+#include "ash/public/interfaces/constants.mojom.h"
+#include "base/bind.h"
+#include "base/command_line.h"
+#include "base/run_loop.h"
+#include "base/test/scoped_task_environment.h"
+#include "services/service_manager/public/cpp/test/test_service.h"
+#include "services/service_manager/public/cpp/test/test_service_manager.h"
+#include "services/ws/public/mojom/constants.mojom.h"
+#include "services/ws/public/mojom/window_server_test.mojom.h"
+#include "testing/gtest/include/gtest/gtest.h"
+#include "ui/base/ui_base_features.h"
+#include "ui/views/layout/layout_provider.h"
+
+namespace ash {
+
+void RunCallback(bool* success, base::RepeatingClosure callback, bool result) {
+  *success = result;
+  std::move(callback).Run();
+}
+
+class AppLaunchTest : public testing::Test {
+ public:
+  AppLaunchTest()
+      : test_service_(
+            test_service_manager_.RegisterTestInstance("ash_unittests")) {}
+  ~AppLaunchTest() override = default;
+
+ protected:
+  service_manager::Connector* connector() { return test_service_.connector(); }
+
+ private:
+  void SetUp() override {
+    base::CommandLine::ForCurrentProcess()->AppendSwitch("use-test-config");
+  }
+
+  base::test::ScopedTaskEnvironment task_environment_;
+  service_manager::TestServiceManager test_service_manager_;
+  service_manager::TestService test_service_;
+  views::LayoutProvider layout_provider_;
+
+  DISALLOW_COPY_AND_ASSIGN(AppLaunchTest);
+};
+
+TEST_F(AppLaunchTest, TestQuickLaunch) {
+  // This test launches ash in a separate service. That doesn't make sense with
+  // SingleProcessMash.
+  if (features::IsSingleProcessMash())
+    return;
+
+  // TODO(https://crbug.com/904148): These should not use |WarmService()|.
+  connector()->WarmService(
+      service_manager::ServiceFilter::ByName(mojom::kServiceName));
+  connector()->WarmService(service_manager::ServiceFilter::ByName(
+      quick_launch::mojom::kServiceName));
+
+  ws::mojom::WindowServerTestPtr test_interface;
+  connector()->BindInterface(
+      service_manager::ServiceFilter::ByName(ws::mojom::kServiceName),
+      mojo::MakeRequest(&test_interface));
+
+  base::RunLoop run_loop;
+  bool success = false;
+  test_interface->EnsureClientHasDrawnWindow(
+      quick_launch::mojom::kServiceName,
+      base::BindOnce(&RunCallback, &success, run_loop.QuitClosure()));
+  run_loop.Run();
+  EXPECT_TRUE(success);
+}
+
+}  // namespace ash
--- a/ash/app_list/app_list_interactive_uitest.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/ash/app_list/app_list_interactive_uitest.cc	2019-05-17 18:53:08.072000000 +0300
@@ -0,0 +1,65 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include <memory>
+
+#include "ash/app_list/app_list_controller_impl.h"
+#include "ash/app_list/presenter/app_list_presenter_impl.h"
+#include "ash/public/cpp/shell_window_ids.h"
+#include "ash/shelf/app_list_button.h"
+#include "ash/shelf/shelf.h"
+#include "ash/shelf/shelf_view.h"
+#include "ash/shelf/shelf_view_test_api.h"
+#include "ash/shelf/shelf_widget.h"
+#include "ash/shell.h"
+#include "ash/test/ash_interactive_ui_test_base.h"
+#include "ui/aura/window.h"
+#include "ui/events/test/event_generator.h"
+
+using AppListTest = ash::AshInteractiveUITestBase;
+
+// An integration test to toggle the app list by pressing the shelf button.
+TEST_F(AppListTest, PressAppListButtonToShowAndDismiss) {
+  aura::Window* root_window = ash::Shell::GetPrimaryRootWindow();
+  ash::Shelf* shelf = ash::Shelf::ForWindow(root_window);
+  ash::ShelfWidget* shelf_widget = shelf->shelf_widget();
+  ash::ShelfView* shelf_view = shelf->GetShelfViewForTesting();
+  ash::ShelfViewTestAPI(shelf_view).RunMessageLoopUntilAnimationsDone();
+  ash::AppListButton* app_list_button = shelf_widget->GetAppListButton();
+  // Ensure animations progressed to give the app list button a non-empty size.
+  ASSERT_GT(app_list_button->GetBoundsInScreen().height(), 0);
+
+  aura::Window* app_list_container =
+      root_window->GetChildById(ash::kShellWindowId_AppListContainer);
+  ui::test::EventGenerator generator(root_window);
+
+  // Click the app list button to show the app list.
+  ash::Shell* shell = ash::Shell::Get();
+  auto* controller = shell->app_list_controller();
+  auto* presenter = controller->presenter();
+  EXPECT_FALSE(controller->GetTargetVisibility());
+  EXPECT_FALSE(presenter->GetTargetVisibility());
+  EXPECT_EQ(0u, app_list_container->children().size());
+  EXPECT_FALSE(app_list_button->is_showing_app_list());
+  generator.set_current_screen_location(
+      app_list_button->GetBoundsInScreen().CenterPoint());
+  generator.ClickLeftButton();
+  // Flush the mojo message from Ash to Chrome to show the app list.
+  controller->FlushForTesting();
+  EXPECT_TRUE(presenter->GetTargetVisibility());
+  // Flush the mojo message from Chrome to Ash reporting the visibility change.
+  EXPECT_TRUE(controller->GetTargetVisibility());
+  EXPECT_EQ(1u, app_list_container->children().size());
+  EXPECT_TRUE(app_list_button->is_showing_app_list());
+
+  // Click the button again to dismiss the app list; it will animate to close.
+  generator.ClickLeftButton();
+  // Flush the mojo message from Ash to Chrome to hide the app list.
+  controller->FlushForTesting();
+  EXPECT_FALSE(presenter->GetTargetVisibility());
+  // Flush the mojo message from Chrome to Ash reporting the visibility change.
+  EXPECT_FALSE(controller->GetTargetVisibility());
+  EXPECT_EQ(1u, app_list_container->children().size());
+  EXPECT_FALSE(app_list_button->is_showing_app_list());
+}
--- a/ash/app_list/home_launcher_gesture_handler.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/ash/app_list/home_launcher_gesture_handler.cc	2019-05-17 18:53:08.076000000 +0300
@@ -0,0 +1,839 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ash/app_list/home_launcher_gesture_handler.h"
+
+#include "ash/app_list/app_list_controller_impl.h"
+#include "ash/app_list/model/app_list_view_state.h"
+#include "ash/root_window_controller.h"
+#include "ash/scoped_animation_disabler.h"
+#include "ash/screen_util.h"
+#include "ash/shell.h"
+#include "ash/wm/mru_window_tracker.h"
+#include "ash/wm/overview/overview_controller.h"
+#include "ash/wm/overview/overview_session.h"
+#include "ash/wm/splitview/split_view_controller.h"
+#include "ash/wm/splitview/split_view_divider.h"
+#include "ash/wm/window_state.h"
+#include "ash/wm/window_transient_descendant_iterator.h"
+#include "ash/wm/window_util.h"
+#include "ash/wm/workspace/backdrop_controller.h"
+#include "ash/wm/workspace/workspace_layout_manager.h"
+#include "ash/wm/workspace_controller.h"
+#include "base/metrics/user_metrics.h"
+#include "base/numerics/ranges.h"
+#include "ui/aura/client/window_types.h"
+#include "ui/aura/null_window_targeter.h"
+#include "ui/compositor/scoped_layer_animation_settings.h"
+#include "ui/gfx/animation/tween.h"
+#include "ui/gfx/geometry/rect_f.h"
+#include "ui/views/widget/widget.h"
+#include "ui/wm/core/transient_window_manager.h"
+#include "ui/wm/core/window_util.h"
+
+namespace ash {
+
+namespace {
+
+// The animation speed at which the window moves when the gesture is released.
+constexpr base::TimeDelta kAnimationDurationMs =
+    base::TimeDelta::FromMilliseconds(250);
+
+// The animation speed at which the window moves when a window is acitvated from
+// the shelf, or deacitvated via home launcher button minimize.
+constexpr base::TimeDelta kActivationChangedAnimationDurationMs =
+    base::TimeDelta::FromMilliseconds(350);
+
+// The velocity the app list or shelf must be dragged in order to transition to
+// the next state regardless of where the gesture ends, measured in DIPs/event.
+constexpr int kScrollVelocityThreshold = 6;
+
+// The width of the target of screen bounds will be the work area width times
+// this ratio.
+constexpr float kWidthRatio = 0.8f;
+
+bool IsTabletMode() {
+  return Shell::Get()
+      ->tablet_mode_controller()
+      ->IsTabletModeWindowManagerEnabled();
+}
+
+// Checks if |window| can be hidden or shown with a gesture.
+bool CanProcessWindow(aura::Window* window,
+                      HomeLauncherGestureHandler::Mode mode) {
+  if (!window)
+    return false;
+
+  if (!window->IsVisible() &&
+      mode == HomeLauncherGestureHandler::Mode::kSlideUpToShow) {
+    return false;
+  }
+
+  if (window->IsVisible() &&
+      mode == HomeLauncherGestureHandler::Mode::kSlideDownToHide) {
+    return false;
+  }
+
+  if (!IsTabletMode())
+    return false;
+
+  if (window->type() == aura::client::WINDOW_TYPE_POPUP)
+    return false;
+
+  // Do not process if |window| is not the root of a transient tree.
+  if (::wm::GetTransientParent(window))
+    return false;
+
+  return true;
+}
+
+// Find the transform that will convert |src| to |dst|.
+gfx::Transform CalculateTransform(const gfx::RectF& src,
+                                  const gfx::RectF& dst) {
+  return gfx::Transform(dst.width() / src.width(), 0, 0,
+                        dst.height() / src.height(), dst.x() - src.x(),
+                        dst.y() - src.y());
+}
+
+// Get the target offscreen workspace bounds.
+gfx::RectF GetOffscreenWorkspaceBounds(const gfx::RectF& work_area) {
+  gfx::RectF new_work_area;
+  new_work_area.set_x(((1.f - kWidthRatio) / 2.f) * work_area.width() +
+                      work_area.x());
+  new_work_area.set_width(kWidthRatio * work_area.width());
+  new_work_area.set_height(kWidthRatio * work_area.height());
+  new_work_area.set_y(work_area.y() - work_area.height());
+  return new_work_area;
+}
+
+// Get the target bounds of a window. It should maintain the same ratios
+// relative the work area.
+gfx::RectF GetOffscreenWindowBounds(aura::Window* window,
+                                    const gfx::RectF& src_work_area,
+                                    const gfx::RectF& dst_work_area) {
+  gfx::RectF bounds = gfx::RectF(window->GetTargetBounds());
+  float ratio = dst_work_area.width() / src_work_area.width();
+
+  gfx::RectF dst_bounds;
+  dst_bounds.set_x(bounds.x() * ratio + dst_work_area.x());
+  dst_bounds.set_y(bounds.y() * ratio + dst_work_area.y());
+  dst_bounds.set_width(bounds.width() * ratio);
+  dst_bounds.set_height(bounds.height() * ratio);
+  return dst_bounds;
+}
+
+// Given a |location_in_screen|, find out where it lies as a ratio in the
+// work area, where the top of the work area is 0.f and the bottom is 1.f.
+double GetHeightInWorkAreaAsRatio(const gfx::Point& location_in_screen,
+                                  const gfx::Rect& work_area) {
+  int clamped_y = base::ClampToRange(location_in_screen.y(), work_area.y(),
+                                     work_area.bottom());
+  double ratio =
+      static_cast<double>(clamped_y) / static_cast<double>(work_area.height());
+  return 1.0 - ratio;
+}
+
+bool IsLastEventInTopHalf(const gfx::Point& location_in_screen,
+                          const gfx::Rect& work_area) {
+  return GetHeightInWorkAreaAsRatio(location_in_screen, work_area) > 0.5;
+}
+
+// Returns the window of the widget which contains the workspace backdrop. May
+// be nullptr if the backdrop is not shown.
+aura::Window* GetBackdropWindow(aura::Window* window) {
+  WorkspaceLayoutManager* layout_manager =
+      RootWindowController::ForWindow(window->GetRootWindow())
+          ->workspace_controller()
+          ->layout_manager();
+  return layout_manager
+             ? layout_manager->backdrop_controller()->backdrop_window()
+             : nullptr;
+}
+
+// Returns the window of the widget of the split view divider. May be nullptr if
+// split view is not active.
+aura::Window* GetDividerWindow() {
+  SplitViewController* split_view_controller =
+      Shell::Get()->split_view_controller();
+  if (!split_view_controller->IsSplitViewModeActive())
+    return nullptr;
+  return split_view_controller->split_view_divider()
+      ->divider_widget()
+      ->GetNativeWindow();
+}
+
+}  // namespace
+
+// Class which allows us to make modifications to a window, and removes those
+// modifications on destruction.
+// TODO(sammiequon): Move to separate file and add test for
+// ComputeWindowValues.
+class HomeLauncherGestureHandler::ScopedWindowModifier
+    : public aura::WindowObserver {
+ public:
+  explicit ScopedWindowModifier(aura::Window* window) : window_(window) {
+    DCHECK(window_);
+    original_targeter_ =
+        window_->SetEventTargeter(std::make_unique<aura::NullWindowTargeter>());
+  }
+  ~ScopedWindowModifier() override {
+    for (const auto& descendant : transient_descendants_values_)
+      descendant.first->RemoveObserver(this);
+
+    ResetOpacityAndTransform();
+    window_->SetEventTargeter(std::move(original_targeter_));
+  }
+
+  bool IsAnimating() const {
+    if (window_->layer()->GetAnimator()->is_animating())
+      return true;
+
+    for (const auto& descendant : transient_descendants_values_) {
+      if (descendant.first->layer()->GetAnimator()->is_animating())
+        return true;
+    }
+
+    return false;
+  }
+
+  void StopAnimating() {
+    window_->layer()->GetAnimator()->StopAnimating();
+    for (const auto& descendant : transient_descendants_values_)
+      descendant.first->layer()->GetAnimator()->StopAnimating();
+  }
+
+  void ResetOpacityAndTransform() {
+    window_->SetTransform(window_values_.initial_transform);
+    window_->layer()->SetOpacity(window_values_.initial_opacity);
+    for (const auto& descendant : transient_descendants_values_) {
+      descendant.first->SetTransform(descendant.second.initial_transform);
+      descendant.first->layer()->SetOpacity(descendant.second.initial_opacity);
+    }
+  }
+
+  // Calculates the values for |window_| and its transient descendants.
+  void ComputeWindowValues(const gfx::RectF& work_area,
+                           const gfx::RectF& target_work_area) {
+    transient_descendants_values_.clear();
+    for (auto* window : wm::GetTransientTreeIterator(window_)) {
+      WindowValues values;
+      values.initial_opacity = window->layer()->opacity();
+      values.initial_transform = window->transform();
+      values.target_opacity = 0.f;
+      values.target_transform = CalculateTransform(
+          gfx::RectF(window->GetTargetBounds()),
+          GetOffscreenWindowBounds(window, work_area, target_work_area));
+      if (window == window_) {
+        window_values_ = values;
+        continue;
+      }
+
+      window->AddObserver(this);
+      transient_descendants_values_[window] = values;
+    }
+  }
+
+  // aura::WindowObserver:
+  void OnWindowDestroying(aura::Window* window) override {
+    auto it = transient_descendants_values_.find(window);
+    DCHECK(it != transient_descendants_values_.end());
+
+    window->RemoveObserver(this);
+    transient_descendants_values_.erase(it);
+  }
+
+  aura::Window* window() { return window_; }
+  WindowValues window_values() const { return window_values_; }
+  const std::map<aura::Window*, WindowValues>& transient_descendants_values()
+      const {
+    return transient_descendants_values_;
+  }
+
+ private:
+  aura::Window* window_;
+
+  // Original and target transform and opacity of |window_|.
+  WindowValues window_values_;
+
+  // Tracks the transient descendants of |window_| and their initial and
+  // target opacities and transforms.
+  std::map<aura::Window*, WindowValues> transient_descendants_values_;
+
+  std::unique_ptr<aura::WindowTargeter> original_targeter_;
+
+  DISALLOW_COPY_AND_ASSIGN(ScopedWindowModifier);
+};
+
+HomeLauncherGestureHandler::HomeLauncherGestureHandler(
+    AppListControllerImpl* app_list_controller)
+    : app_list_controller_(app_list_controller) {
+  tablet_mode_observer_.Add(Shell::Get()->tablet_mode_controller());
+}
+
+HomeLauncherGestureHandler::~HomeLauncherGestureHandler() {
+  StopObservingImplicitAnimations();
+}
+
+bool HomeLauncherGestureHandler::OnPressEvent(Mode mode,
+                                              const gfx::Point& location) {
+  // Do not start a new session if a window is currently being processed.
+  if (!IsIdle())
+    return false;
+
+  display_ = display::Screen::GetScreen()->GetDisplayNearestPoint(location);
+  if (!display_.is_valid())
+    return false;
+
+  if (!SetUpWindows(mode, /*window=*/nullptr))
+    return false;
+
+  mode_ = mode;
+  last_event_location_ = base::make_optional(location);
+
+  if (mode != Mode::kNone) {
+    app_list_controller_->NotifyHomeLauncherTargetPositionChanged(
+        mode == Mode::kSlideUpToShow /*showing*/, display_.id());
+  }
+
+  UpdateWindows(0.0, /*animate=*/false);
+  return true;
+}
+
+bool HomeLauncherGestureHandler::OnScrollEvent(const gfx::Point& location,
+                                               float scroll_y) {
+  if (IsAnimating())
+    return false;
+
+  if (!IsDragInProgress())
+    return false;
+
+  last_event_location_ = base::make_optional(location);
+  last_scroll_y_ = scroll_y;
+
+  DCHECK(display_.is_valid());
+  UpdateWindows(GetHeightInWorkAreaAsRatio(location, display_.work_area()),
+                /*animate=*/false);
+  return true;
+}
+
+bool HomeLauncherGestureHandler::OnReleaseEvent(const gfx::Point& location) {
+  if (IsAnimating())
+    return false;
+
+  if (!IsDragInProgress()) {
+    if (GetWindow1()) {
+      // |window1_| may not be nullptr when this release event is triggered
+      // by opening |window1_| with modal dialog in OnPressEvent(). In that
+      // case, just leave the |window1_| in show state and stop tracking.
+      AnimateToFinalState();
+      RemoveObserversAndStopTracking();
+      return true;
+    }
+    return false;
+  }
+
+  last_event_location_ = base::make_optional(location);
+  AnimateToFinalState();
+  return true;
+}
+
+void HomeLauncherGestureHandler::Cancel() {
+  if (!IsDragInProgress())
+    return;
+
+  AnimateToFinalState();
+  return;
+}
+
+bool HomeLauncherGestureHandler::ShowHomeLauncher(
+    const display::Display& display) {
+  if (!IsIdle())
+    return false;
+
+  if (!display.is_valid())
+    return false;
+
+  if (!SetUpWindows(Mode::kSlideUpToShow, /*window=*/nullptr))
+    return false;
+
+  display_ = display;
+  mode_ = Mode::kSlideUpToShow;
+
+  UpdateWindows(0.0, /*animate=*/false);
+  AnimateToFinalState();
+  return true;
+}
+
+bool HomeLauncherGestureHandler::HideHomeLauncherForWindow(
+    const display::Display& display,
+    aura::Window* window) {
+  if (!IsIdle())
+    return false;
+
+  if (!display.is_valid())
+    return false;
+
+  if (!SetUpWindows(Mode::kSlideDownToHide, window))
+    return false;
+
+  display_ = display;
+  mode_ = Mode::kSlideDownToHide;
+
+  UpdateWindows(1.0, /*animate=*/false);
+  AnimateToFinalState();
+  return true;
+}
+
+aura::Window* HomeLauncherGestureHandler::GetWindow1() {
+  if (!window1_)
+    return nullptr;
+  return window1_->window();
+}
+
+aura::Window* HomeLauncherGestureHandler::GetWindow2() {
+  if (!window2_)
+    return nullptr;
+  return window2_->window();
+}
+
+void HomeLauncherGestureHandler::OnWindowDestroying(aura::Window* window) {
+  if (window1_ && window == GetWindow1()) {
+    for (auto* hidden_window : hidden_windows_)
+      hidden_window->Show();
+
+    RemoveObserversAndStopTracking();
+    return;
+  }
+
+  if (window2_ && window == GetWindow2()) {
+    DCHECK(window1_);
+    window->RemoveObserver(this);
+    window2_.reset();
+    return;
+  }
+
+  DCHECK(base::ContainsValue(hidden_windows_, window));
+  window->RemoveObserver(this);
+  hidden_windows_.erase(
+      std::find(hidden_windows_.begin(), hidden_windows_.end(), window));
+}
+
+void HomeLauncherGestureHandler::OnTabletModeEnded() {
+  if (IsIdle())
+    return;
+
+  // When leaving tablet mode advance to the end of the in progress scroll
+  // session or animation.
+  StopObservingImplicitAnimations();
+  if (window1_)
+    window1_->StopAnimating();
+  if (window2_)
+    window2_->StopAnimating();
+  UpdateWindows(IsFinalStateShow() ? 1.0 : 0.0, /*animate=*/false);
+  OnImplicitAnimationsCompleted();
+}
+
+void HomeLauncherGestureHandler::OnImplicitAnimationsCompleted() {
+  float app_list_opacity = 1.f;
+  const bool is_final_state_show = IsFinalStateShow();
+  app_list_controller_->NotifyHomeLauncherAnimationComplete(
+      is_final_state_show /*shown*/, display_.id());
+  if (Shell::Get()->overview_controller()->IsSelecting()) {
+    if (overview_active_on_gesture_start_ && is_final_state_show) {
+      // Exit overview if event is released on the top half. This will also
+      // end splitview if it is active as SplitViewController observes
+      // overview mode ends.
+      Shell::Get()->overview_controller()->ToggleOverview(
+          OverviewSession::EnterExitOverviewType::kSwipeFromShelf);
+    } else {
+      app_list_opacity = 0.f;
+    }
+  }
+
+  // Return the app list to its original opacity and transform without
+  // animation.
+  DCHECK(display_.is_valid());
+  app_list_controller_->presenter()->UpdateYPositionAndOpacityForHomeLauncher(
+      display_.work_area().y(), app_list_opacity, base::NullCallback());
+
+  if (!window1_) {
+    RemoveObserversAndStopTracking();
+    return;
+  }
+
+  // Explicitly exit split view if two windows are snapped.
+  if (is_final_state_show && Shell::Get()->split_view_controller()->state() ==
+                                 SplitViewController::BOTH_SNAPPED) {
+    Shell::Get()->split_view_controller()->EndSplitView();
+  }
+
+  window1_->ResetOpacityAndTransform();
+  if (window2_)
+    window2_->ResetOpacityAndTransform();
+
+  if (is_final_state_show) {
+    std::vector<aura::Window*> windows_to_hide_minimize;
+    windows_to_hide_minimize.push_back(GetWindow1());
+
+    if (window2_)
+      windows_to_hide_minimize.push_back(GetWindow2());
+
+    // Minimize the hidden windows so they can be used normally with alt+tab
+    // and overview. Minimize in reverse order to preserve mru ordering.
+    windows_to_hide_minimize.resize(windows_to_hide_minimize.size() +
+                                    hidden_windows_.size());
+    std::copy(hidden_windows_.rbegin(), hidden_windows_.rend(),
+              windows_to_hide_minimize.end() - hidden_windows_.size());
+    wm::HideAndMaybeMinimizeWithoutAnimation(windows_to_hide_minimize,
+                                             /*minimize=*/true);
+  } else {
+    // Reshow all windows previously hidden.
+    for (auto* window : hidden_windows_) {
+      ScopedAnimationDisabler disable(window);
+      window->Show();
+    }
+  }
+
+  // Update the backdrop last as the backdrop controller listens for some
+  // state changes like minimizing above which may also alter the backdrop.
+  aura::Window* backdrop_window = GetBackdropWindow(GetWindow1());
+  if (backdrop_window) {
+    backdrop_window->SetTransform(gfx::Transform());
+    backdrop_window->layer()->SetOpacity(1.f);
+  }
+
+  RemoveObserversAndStopTracking();
+}
+
+void HomeLauncherGestureHandler::AnimateToFinalState() {
+  const bool is_final_state_show = IsFinalStateShow();
+  UpdateWindows(is_final_state_show ? 1.0 : 0.0, /*animate=*/true);
+
+  if (!is_final_state_show && mode_ == Mode::kSlideDownToHide) {
+    app_list_controller_->NotifyHomeLauncherTargetPositionChanged(
+        false /*showing*/, display_.id());
+    base::RecordAction(
+        base::UserMetricsAction("AppList_HomeLauncherToMRUWindow"));
+  } else if (is_final_state_show && mode_ == Mode::kSlideUpToShow) {
+    app_list_controller_->NotifyHomeLauncherTargetPositionChanged(
+        true /*showing*/, display_.id());
+    base::RecordAction(
+        base::UserMetricsAction("AppList_CurrentWindowToHomeLauncher"));
+  }
+}
+
+void HomeLauncherGestureHandler::UpdateSettings(
+    ui::ScopedLayerAnimationSettings* settings,
+    bool observe) {
+  settings->SetTransitionDuration(IsDragInProgress()
+                                      ? kAnimationDurationMs
+                                      : kActivationChangedAnimationDurationMs);
+  settings->SetTweenType(IsDragInProgress() ? gfx::Tween::LINEAR
+                                            : gfx::Tween::FAST_OUT_SLOW_IN);
+  settings->SetPreemptionStrategy(
+      ui::LayerAnimator::IMMEDIATELY_ANIMATE_TO_NEW_TARGET);
+
+  if (observe)
+    settings->AddObserver(this);
+}
+
+void HomeLauncherGestureHandler::UpdateWindows(double progress, bool animate) {
+  // Update full screen applist.
+  DCHECK(display_.is_valid());
+  const gfx::Rect work_area = display_.work_area();
+  const int y_position =
+      gfx::Tween::IntValueBetween(progress, work_area.bottom(), work_area.y());
+  const float opacity = gfx::Tween::FloatValueBetween(progress, 0.f, 1.f);
+  app_list_controller_->presenter()->UpdateYPositionAndOpacityForHomeLauncher(
+      y_position, opacity,
+      animate ? base::BindRepeating(&HomeLauncherGestureHandler::UpdateSettings,
+                                    base::Unretained(this))
+              : base::NullCallback());
+
+  // Update the overview grid if needed.
+  OverviewController* controller = Shell::Get()->overview_controller();
+  if (overview_active_on_gesture_start_ && controller->IsSelecting()) {
+    DCHECK_EQ(mode_, Mode::kSlideUpToShow);
+    controller->overview_session()->UpdateGridAtLocationYPositionAndOpacity(
+        display_.id(), y_position - work_area.height(), 1.f - opacity,
+        work_area,
+        animate
+            ? base::BindRepeating(&HomeLauncherGestureHandler::UpdateSettings,
+                                  base::Unretained(this))
+            : base::NullCallback());
+  }
+
+  if (!window1_)
+    return;
+
+  // Helper to update a single windows opacity and transform based on by
+  // calculating the in between values using |value| and |values|.
+  auto update_windows_helper = [this](double progress, bool animate,
+                                      aura::Window* window,
+                                      const WindowValues& values) {
+    float opacity = gfx::Tween::FloatValueBetween(
+        progress, values.initial_opacity, values.target_opacity);
+    gfx::Transform transform = gfx::Tween::TransformValueBetween(
+        progress, values.initial_transform, values.target_transform);
+
+    std::unique_ptr<ui::ScopedLayerAnimationSettings> settings;
+    if (animate) {
+      settings = std::make_unique<ui::ScopedLayerAnimationSettings>(
+          window->layer()->GetAnimator());
+      // There are multiple animations run on a release event (app list,
+      // overview and the stored windows). We only want to act on one
+      // animation end, so only observe one of the animations. If overview
+      // is active, observe the shield widget of the grid, else observe
+      // |window1_|.
+      UpdateSettings(settings.get(),
+                     this->GetWindow1() == window &&
+                         !(overview_active_on_gesture_start_ &&
+                           Shell::Get()->overview_controller()->IsSelecting()));
+    }
+    window->layer()->SetOpacity(opacity);
+    window->SetTransform(transform);
+  };
+
+  aura::Window* backdrop_window = GetBackdropWindow(GetWindow1());
+  if (backdrop_window && backdrop_values_) {
+    update_windows_helper(progress, animate, backdrop_window,
+                          *backdrop_values_);
+  }
+
+  aura::Window* divider_window = GetDividerWindow();
+  if (divider_window && divider_values_) {
+    update_windows_helper(progress, animate, divider_window, *divider_values_);
+  }
+
+  if (window2_) {
+    for (const auto& descendant : window2_->transient_descendants_values()) {
+      update_windows_helper(progress, animate, descendant.first,
+                            descendant.second);
+    }
+    update_windows_helper(progress, animate, GetWindow2(),
+                          window2_->window_values());
+  }
+
+  for (const auto& descendant : window1_->transient_descendants_values()) {
+    update_windows_helper(progress, animate, descendant.first,
+                          descendant.second);
+  }
+  update_windows_helper(progress, animate, GetWindow1(),
+                        window1_->window_values());
+}
+
+void HomeLauncherGestureHandler::RemoveObserversAndStopTracking() {
+  display_.set_id(display::kInvalidDisplayId);
+  backdrop_values_ = base::nullopt;
+  divider_values_ = base::nullopt;
+  last_event_location_ = base::nullopt;
+  last_scroll_y_ = 0.f;
+  mode_ = Mode::kNone;
+
+  for (auto* window : hidden_windows_)
+    window->RemoveObserver(this);
+  hidden_windows_.clear();
+
+  if (window1_)
+    GetWindow1()->RemoveObserver(this);
+  window1_.reset();
+
+  if (window2_)
+    GetWindow2()->RemoveObserver(this);
+  window2_.reset();
+}
+
+bool HomeLauncherGestureHandler::IsIdle() {
+  return !IsDragInProgress() && !IsAnimating();
+}
+
+bool HomeLauncherGestureHandler::IsAnimating() {
+  if (window1_ && window1_->IsAnimating())
+    return true;
+
+  if (window2_ && window2_->IsAnimating())
+    return true;
+
+  if (overview_active_on_gesture_start_ &&
+      Shell::Get()->overview_controller()->IsSelecting() &&
+      Shell::Get()
+          ->overview_controller()
+          ->overview_session()
+          ->IsOverviewGridAnimating()) {
+    return true;
+  }
+
+  return false;
+}
+
+bool HomeLauncherGestureHandler::IsFinalStateShow() {
+  DCHECK_NE(Mode::kNone, mode_);
+  DCHECK(display_.is_valid());
+
+  // If fling velocity is greater than the threshold, show the launcher if
+  // sliding up, or hide the launcher if sliding down, irregardless of
+  // |last_event_location_|.
+  if (mode_ == Mode::kSlideUpToShow &&
+      last_scroll_y_ < -kScrollVelocityThreshold) {
+    return true;
+  }
+
+  if (mode_ == Mode::kSlideDownToHide &&
+      last_scroll_y_ > kScrollVelocityThreshold) {
+    return false;
+  }
+
+  return last_event_location_
+             ? IsLastEventInTopHalf(*last_event_location_, display_.work_area())
+             : mode_ == Mode::kSlideUpToShow;
+}
+
+bool HomeLauncherGestureHandler::SetUpWindows(Mode mode, aura::Window* window) {
+  SplitViewController* split_view_controller =
+      Shell::Get()->split_view_controller();
+  overview_active_on_gesture_start_ =
+      Shell::Get()->overview_controller()->IsSelecting();
+  const bool split_view_active = split_view_controller->IsSplitViewModeActive();
+  auto windows = Shell::Get()->mru_window_tracker()->BuildWindowForCycleList();
+  if (window && (mode != Mode::kSlideDownToHide ||
+                 overview_active_on_gesture_start_ || split_view_active)) {
+    window1_.reset();
+    return false;
+  }
+
+  if (window && !windows.empty() && windows[0] != window &&
+      windows[0]->IsVisible()) {
+    // Do not run slide down animation for the |window| if another active
+    // window in mru list exists. Windows minimized in clamshell mode may
+    // have opacity of 0, so set them to 1 to ensure visibility.
+    if (wm::GetWindowState(window)->IsMinimized())
+      window->layer()->SetOpacity(1.f);
+    window1_.reset();
+    return false;
+  }
+
+  if (IsTabletMode() && overview_active_on_gesture_start_ &&
+      !split_view_active) {
+    DCHECK_EQ(Mode::kSlideUpToShow, mode);
+    window1_.reset();
+    return true;
+  }
+
+  // Always hide split view windows if they exist. Otherwise, hide the
+  // specified window if it is not null. If none of above is true, we want
+  // the first window in the mru list, if it exists and is usable.
+  aura::Window* first_window =
+      split_view_active
+          ? split_view_controller->GetDefaultSnappedWindow()
+          : (window ? window : (windows.empty() ? nullptr : windows[0]));
+  if (!CanProcessWindow(first_window, mode)) {
+    window1_.reset();
+    return false;
+  }
+
+  DCHECK(base::ContainsValue(windows, first_window));
+  DCHECK_NE(Mode::kNone, mode);
+  base::RecordAction(base::UserMetricsAction(
+      mode == Mode::kSlideDownToHide
+          ? "AppList_HomeLauncherToMRUWindowAttempt"
+          : "AppList_CurrentWindowToHomeLauncherAttempt"));
+  window1_ = std::make_unique<ScopedWindowModifier>(first_window);
+  GetWindow1()->AddObserver(this);
+  base::EraseIf(windows, [this](aura::Window* elem) {
+    return elem == this->GetWindow1();
+  });
+
+  // Alter a second window if we are in split view mode with two windows
+  // snapped.
+  if (mode == Mode::kSlideUpToShow &&
+      split_view_controller->state() == SplitViewController::BOTH_SNAPPED) {
+    DCHECK_GT(windows.size(), 0u);
+    aura::Window* second_window =
+        split_view_controller->default_snap_position() ==
+                SplitViewController::LEFT
+            ? split_view_controller->right_window()
+            : split_view_controller->left_window();
+    DCHECK(base::ContainsValue(windows, second_window));
+    window2_ = std::make_unique<ScopedWindowModifier>(second_window);
+    GetWindow2()->AddObserver(this);
+    base::EraseIf(windows, [this](aura::Window* elem) {
+      return elem == this->GetWindow2();
+    });
+  }
+
+  // Show |window1_| if we are swiping down to hide.
+  if (mode == Mode::kSlideDownToHide) {
+    ScopedAnimationDisabler disable(GetWindow1());
+    GetWindow1()->Show();
+
+    // When |window1_| has a modal dialog child, window1_->Show() above would
+    // cancel the current gesture and trigger OnReleaseEvent() to reset
+    // |window1_|.
+    if (!window1_ || !GetWindow1())
+      return false;
+
+    wm::ActivateWindow(GetWindow1());
+    GetWindow1()->layer()->SetOpacity(1.f);
+  }
+
+  const gfx::RectF work_area =
+      gfx::RectF(screen_util::GetDisplayWorkAreaBoundsInParent(GetWindow1()));
+  const gfx::RectF target_work_area = GetOffscreenWorkspaceBounds(work_area);
+
+  window1_->ComputeWindowValues(work_area, target_work_area);
+  if (window2_)
+    window2_->ComputeWindowValues(work_area, target_work_area);
+
+  aura::Window* backdrop_window = GetBackdropWindow(GetWindow1());
+  if (backdrop_window) {
+    // Store the values needed to transform the backdrop. The backdrop
+    // actually covers the area behind the shelf as well, so initially
+    // transform it to be sized to the work area. Without the transform
+    // tweak, there is an extra shelf sized black area under |window1_|. Go
+    // to 0.01 opacity instead of 0 opacity otherwise animation end code
+    // will attempt to update the backdrop which will try to show a 0
+    // opacity window which causes a crash.
+    backdrop_values_ = base::make_optional(WindowValues());
+    backdrop_values_->initial_opacity = 1.f;
+    backdrop_values_->initial_transform = gfx::Transform(
+        1.f, 0.f, 0.f,
+        work_area.height() /
+            static_cast<float>(backdrop_window->bounds().height()),
+        0.f, 0.f);
+    backdrop_values_->target_opacity = 0.01f;
+    backdrop_values_->target_transform = CalculateTransform(
+        gfx::RectF(backdrop_window->bounds()), target_work_area);
+  }
+
+  // Stores values needed to transform the split view divider if it exists.
+  aura::Window* divider_window = GetDividerWindow();
+  if (divider_window) {
+    divider_values_ = base::make_optional(WindowValues());
+    divider_values_->initial_opacity = 1.f;
+    divider_values_->initial_transform = gfx::Transform();
+    divider_values_->target_opacity = 0.f;
+    divider_values_->target_transform = CalculateTransform(
+        gfx::RectF(divider_window->bounds()),
+        GetOffscreenWindowBounds(divider_window, work_area, target_work_area));
+  }
+
+  // Hide all visible windows which are behind our window so that when we
+  // scroll, the home launcher will be visible. This is only needed when
+  // swiping up, and not when overview mode is active.
+  hidden_windows_.clear();
+  if (mode == Mode::kSlideUpToShow && !overview_active_on_gesture_start_) {
+    for (auto* window : windows) {
+      if (window->IsVisible()) {
+        hidden_windows_.push_back(window);
+        window->AddObserver(this);
+      }
+    }
+    wm::HideAndMaybeMinimizeWithoutAnimation(hidden_windows_,
+                                             /*minimize=*/false);
+  }
+
+  return true;
+}
+
+}  // namespace ash
--- a/ash/app_list/home_launcher_gesture_handler.h	1970-01-01 03:00:00.000000000 +0300
+++ b/ash/app_list/home_launcher_gesture_handler.h	2019-05-17 18:53:08.076000000 +0300
@@ -0,0 +1,184 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef ASH_APP_LIST_HOME_LAUNCHER_GESTURE_HANDLER_H_
+#define ASH_APP_LIST_HOME_LAUNCHER_GESTURE_HANDLER_H_
+
+#include <map>
+#include <vector>
+
+#include "ash/ash_export.h"
+#include "ash/wm/tablet_mode/tablet_mode_controller.h"
+#include "ash/wm/tablet_mode/tablet_mode_observer.h"
+#include "base/macros.h"
+#include "base/optional.h"
+#include "base/scoped_observer.h"
+#include "ui/aura/window.h"
+#include "ui/aura/window_observer.h"
+#include "ui/compositor/layer_animation_observer.h"
+#include "ui/gfx/geometry/point.h"
+#include "ui/gfx/transform.h"
+
+namespace ash {
+
+class AppListControllerImpl;
+
+// HomeLauncherGestureHandler makes modifications to a window's transform and
+// opacity when gesture drag events are received and forwarded to it.
+// Additionally hides windows which may block the home launcher. All
+// modifications are either transitioned to their final state, or back to their
+// initial state on release event.
+class ASH_EXPORT HomeLauncherGestureHandler
+    : public aura::WindowObserver,
+      public TabletModeObserver,
+      public ui::ImplicitAnimationObserver {
+ public:
+  // Enum which tracks which mode the current scroll process is in.
+  enum class Mode {
+    // There is no current scroll process.
+    kNone,
+    // Sliding up the MRU window to display launcher. If in overview mode,
+    // slides up overview mode as well.
+    kSlideUpToShow,
+    // Sliding down the MRU window to hide launcher.
+    kSlideDownToHide,
+  };
+
+  explicit HomeLauncherGestureHandler(
+      AppListControllerImpl* app_list_controller);
+  ~HomeLauncherGestureHandler() override;
+
+  // Called by owner of this object when a gesture event is received. |location|
+  // should be in screen coordinates. Returns false if the the gesture event
+  // was not processed.
+  bool OnPressEvent(Mode mode, const gfx::Point& location);
+  bool OnScrollEvent(const gfx::Point& location, float scroll_y);
+  bool OnReleaseEvent(const gfx::Point& location);
+
+  // Cancel a current drag and animates the items to their final state based on
+  // |last_event_location_|.
+  void Cancel();
+
+  // Hide MRU window and show home launcher on specified display.
+  bool ShowHomeLauncher(const display::Display& display);
+
+  // Hide home launcher and show MRU window on specified display.
+  bool HideHomeLauncherForWindow(const display::Display& display,
+                                 aura::Window* window);
+
+  // Returns the windows being tracked. May be null.
+  aura::Window* GetWindow1();
+  aura::Window* GetWindow2();
+
+  bool IsDragInProgress() const { return last_event_location_.has_value(); }
+
+  // TODO(sammiequon): Investigate if it is needed to observe potential window
+  // visibility changes, if they can happen.
+  // aura::WindowObserver:
+  void OnWindowDestroying(aura::Window* window) override;
+
+  // TabletModeObserver:
+  void OnTabletModeEnded() override;
+
+  // ui::ImplicitAnimationObserver:
+  void OnImplicitAnimationsCompleted() override;
+
+  Mode mode() const { return mode_; }
+
+ private:
+  class ScopedWindowModifier;
+  FRIEND_TEST_ALL_PREFIXES(HomeLauncherModeGestureHandlerTest,
+                           AnimatingToEndResetsState);
+
+  // Stores the initial and target opacities and transforms of window.
+  struct WindowValues {
+    float initial_opacity;
+    float target_opacity;
+    gfx::Transform initial_transform;
+    gfx::Transform target_transform;
+  };
+
+  // Animates the items based on IsFinalStateShow().
+  void AnimateToFinalState();
+
+  // Updates |settings| based on what we want for this class. This will listen
+  // for animation complete call if |observe| is true.
+  void UpdateSettings(ui::ScopedLayerAnimationSettings* settings, bool observe);
+
+  // Updates the opacity and transform |window_| and its transient children base
+  // on the values in |window_values_| and |transient_descendants_values_|.
+  // |progress| is between 0.0 and 1.0, where 0.0 means the window will have its
+  // original opacity and transform, and 1.0 means the window will be faded out
+  // and transformed offscreen.
+  void UpdateWindows(double progress, bool animate);
+
+  // Stop observing all windows and remove their local pointers.
+  void RemoveObserversAndStopTracking();
+
+  // Returns true if there's no gesture dragging and animation.
+  bool IsIdle();
+
+  // Returns true if animation is running.
+  bool IsAnimating();
+
+  // Returns true if home launcher should run animation to show. Otherwise,
+  // returns false.
+  bool IsFinalStateShow();
+
+  // Sets up windows that will be used in dragging and animation. If |window| is
+  // not null for kSlideDownToHide mode, it will be set as the window to run
+  // slide down animation. |window| is not used for kSlideUpToShow mode. Returns
+  // true if windows are successfully set up.
+  bool SetUpWindows(Mode mode, aura::Window* window);
+
+  Mode mode_ = Mode::kNone;
+
+  // The windows we are tracking. They are null if a drag is not underway, or if
+  // overview without splitview is active. |window2_| is the secondary window
+  // for splitview and is always null if |window1_| is null.
+  std::unique_ptr<ScopedWindowModifier> window1_;
+  std::unique_ptr<ScopedWindowModifier> window2_;
+
+  // Original and target transform and opacity of the backdrop window. Empty if
+  // there is no backdrop on mouse pressed.
+  base::Optional<WindowValues> backdrop_values_;
+
+  // Original and target transform and opacity of the split view divider window.
+  // Empty if there is no divider on press event (ie. split view is not active).
+  base::Optional<WindowValues> divider_values_;
+
+  // Stores windows which were shown behind the mru window. They need to be
+  // hidden so the home launcher is visible when swiping up.
+  std::vector<aura::Window*> hidden_windows_;
+
+  // Tracks the location of the last received event in screen coordinates. Empty
+  // if there is currently no window being processed.
+  base::Optional<gfx::Point> last_event_location_;
+
+  // Tracks the last y scroll amount. On gesture end, animates to end state if
+  // |last_scroll_y_| is greater than a certain threshold, even if
+  // |last_event_location_| is in a different half.
+  float last_scroll_y_ = 0.f;
+
+  // Stores whether overview was actived when we first perform the swipe up
+  // gesture. This is needed in case someone enters overview while the show home
+  // launcher animation is running, overview will be active, but we do not want
+  // to toggle overview again in that case.
+  bool overview_active_on_gesture_start_ = false;
+
+  ScopedObserver<TabletModeController, TabletModeObserver>
+      tablet_mode_observer_{this};
+
+  // Unowned and guaranteed to be non null for the lifetime of this.
+  AppListControllerImpl* app_list_controller_;
+
+  // The display where the windows are being processed.
+  display::Display display_;
+
+  DISALLOW_COPY_AND_ASSIGN(HomeLauncherGestureHandler);
+};
+
+}  // namespace ash
+
+#endif  // ASH_APP_LIST_HOME_LAUNCHER_GESTURE_HANDLER_H_
--- a/ash/app_list/home_launcher_gesture_handler_unittest.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/ash/app_list/home_launcher_gesture_handler_unittest.cc	2019-05-17 18:53:08.076000000 +0300
@@ -0,0 +1,584 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ash/app_list/home_launcher_gesture_handler.h"
+
+#include "ash/app_list/app_list_controller_impl.h"
+#include "ash/public/cpp/shelf_types.h"
+#include "ash/shelf/shelf.h"
+#include "ash/shelf/shelf_layout_manager.h"
+#include "ash/shell.h"
+#include "ash/test/ash_test_base.h"
+#include "ash/wm/overview/overview_controller.h"
+#include "ash/wm/splitview/split_view_controller.h"
+#include "ash/wm/tablet_mode/tablet_mode_controller.h"
+#include "ash/wm/window_state.h"
+#include "ui/aura/window.h"
+#include "ui/compositor/scoped_animation_duration_scale_mode.h"
+#include "ui/gfx/geometry/point.h"
+#include "ui/gfx/transform.h"
+#include "ui/wm/core/transient_window_manager.h"
+#include "ui/wm/core/window_util.h"
+
+namespace ash {
+
+using Mode = HomeLauncherGestureHandler::Mode;
+
+class HomeLauncherGestureHandlerTest : public AshTestBase {
+ public:
+  HomeLauncherGestureHandlerTest() = default;
+  ~HomeLauncherGestureHandlerTest() override = default;
+
+  // testing::Test:
+  void SetUp() override {
+    AshTestBase::SetUp();
+
+    Shell::Get()->tablet_mode_controller()->EnableTabletModeWindowManager(true);
+  }
+
+  // Create a test window and set the base transform to identity and
+  // the base opacity to opaque for easier testing.
+  virtual std::unique_ptr<aura::Window> CreateWindowForTesting() {
+    std::unique_ptr<aura::Window> window = CreateTestWindow();
+    window->SetTransform(gfx::Transform());
+    window->layer()->SetOpacity(1.f);
+    return window;
+  }
+
+  HomeLauncherGestureHandler* GetGestureHandler() {
+    return Shell::Get()->app_list_controller()->home_launcher_gesture_handler();
+  }
+
+  void DoPress(Mode mode) {
+    DCHECK_NE(mode, Mode::kNone);
+    gfx::Point press_location;
+    if (mode == Mode::kSlideUpToShow) {
+      press_location = Shelf::ForWindow(Shell::GetPrimaryRootWindow())
+                           ->GetIdealBounds()
+                           .CenterPoint();
+    }
+
+    GetGestureHandler()->OnPressEvent(mode, press_location);
+  }
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(HomeLauncherGestureHandlerTest);
+};
+
+// Tests that the gesture handler will not have a window to act on if there are
+// none in the mru list.
+TEST_F(HomeLauncherGestureHandlerTest, NeedsOneWindowToShow) {
+  DoPress(Mode::kSlideUpToShow);
+  EXPECT_FALSE(GetGestureHandler()->GetWindow1());
+
+  auto window = CreateWindowForTesting();
+  DoPress(Mode::kSlideUpToShow);
+  EXPECT_TRUE(GetGestureHandler()->GetWindow1());
+}
+
+// Tests that the gesture handler will not have a window to act on if there are
+// none in the mru list, or if they are not minimized.
+TEST_F(HomeLauncherGestureHandlerTest, NeedsOneMinimizedWindowToHide) {
+  DoPress(Mode::kSlideDownToHide);
+  EXPECT_FALSE(GetGestureHandler()->GetWindow1());
+
+  auto window = CreateWindowForTesting();
+  DoPress(Mode::kSlideDownToHide);
+  EXPECT_FALSE(GetGestureHandler()->GetWindow1());
+
+  wm::GetWindowState(window.get())->Minimize();
+  DoPress(Mode::kSlideDownToHide);
+  EXPECT_TRUE(GetGestureHandler()->GetWindow1());
+}
+
+// Tests that if there are other visible windows behind the most recent one,
+// they get hidden on press event so that the home launcher is visible.
+TEST_F(HomeLauncherGestureHandlerTest, ShowWindowsAreHidden) {
+  auto window1 = CreateWindowForTesting();
+  auto window2 = CreateWindowForTesting();
+  auto window3 = CreateWindowForTesting();
+  ASSERT_TRUE(window1->IsVisible());
+  ASSERT_TRUE(window2->IsVisible());
+  ASSERT_TRUE(window3->IsVisible());
+
+  // Test that the most recently activated window is visible, but the others are
+  // not.
+  ::wm::ActivateWindow(window1.get());
+  DoPress(Mode::kSlideUpToShow);
+  EXPECT_TRUE(window1->IsVisible());
+  EXPECT_FALSE(window2->IsVisible());
+  EXPECT_FALSE(window3->IsVisible());
+}
+
+TEST_F(HomeLauncherGestureHandlerTest, CancellingSlideUp) {
+  UpdateDisplay("400x456");
+
+  auto window = CreateWindowForTesting();
+  ASSERT_TRUE(window->IsVisible());
+
+  // Tests that when cancelling a scroll that was on the bottom half, the window
+  // is still visible.
+  DoPress(Mode::kSlideUpToShow);
+  GetGestureHandler()->OnScrollEvent(gfx::Point(0, 300), 1.f);
+  GetGestureHandler()->Cancel();
+  EXPECT_TRUE(window->IsVisible());
+
+  // Tests that when cancelling a scroll that was on the top half, the window is
+  // now invisible.
+  DoPress(Mode::kSlideUpToShow);
+  GetGestureHandler()->OnScrollEvent(gfx::Point(0, 100), 1.f);
+  GetGestureHandler()->Cancel();
+  EXPECT_FALSE(window->IsVisible());
+}
+
+// Tests that if we fling with enough velocity while sliding up, the launcher
+// becomes visible even if the event is released below the halfway mark.
+TEST_F(HomeLauncherGestureHandlerTest, FlingingSlideUp) {
+  UpdateDisplay("400x456");
+
+  auto window = CreateWindowForTesting();
+  ASSERT_TRUE(window->IsVisible());
+
+  // Tests that flinging down in this mode will keep the window visible.
+  DoPress(Mode::kSlideUpToShow);
+  GetGestureHandler()->OnScrollEvent(gfx::Point(0, 300), 10.f);
+  GetGestureHandler()->OnReleaseEvent(gfx::Point(0, 300));
+  ASSERT_TRUE(window->IsVisible());
+
+  // Tests that flinging up in this mode will hide the window and show the
+  // home launcher.
+  DoPress(Mode::kSlideUpToShow);
+  GetGestureHandler()->OnScrollEvent(gfx::Point(0, 300), -10.f);
+  GetGestureHandler()->OnReleaseEvent(gfx::Point(0, 300));
+  EXPECT_FALSE(window->IsVisible());
+}
+
+// Tests that if we fling with enough velocity while sliding up, the launcher
+// becomes visible even if the event is released below the halfway mark.
+TEST_F(HomeLauncherGestureHandlerTest, FlingingSlideDown) {
+  UpdateDisplay("400x456");
+
+  auto window = CreateWindowForTesting();
+  wm::GetWindowState(window.get())->Minimize();
+  ASSERT_FALSE(window->IsVisible());
+
+  // Tests that flinging up in this mode will not show the mru window.
+  DoPress(Mode::kSlideDownToHide);
+  GetGestureHandler()->OnScrollEvent(gfx::Point(0, 100), -10.f);
+  GetGestureHandler()->OnReleaseEvent(gfx::Point(0, 100));
+  ASSERT_FALSE(window->IsVisible());
+
+  // Tests that flinging down in this mode will show the mru window.
+  DoPress(Mode::kSlideDownToHide);
+  GetGestureHandler()->OnScrollEvent(gfx::Point(0, 100), 10.f);
+  GetGestureHandler()->OnReleaseEvent(gfx::Point(0, 100));
+  EXPECT_TRUE(window->IsVisible());
+}
+
+TEST_F(HomeLauncherGestureHandlerTest, SlidingBelowPressPoint) {
+  UpdateDisplay("400x456");
+
+  auto window = CreateWindowForTesting();
+  ASSERT_TRUE(window->IsVisible());
+
+  // Tests that the windows transform does not change when trying to slide below
+  // the press event location.
+  GetGestureHandler()->OnPressEvent(Mode::kSlideUpToShow, gfx::Point(0, 400));
+  GetGestureHandler()->OnScrollEvent(gfx::Point(0, 420), 1.f);
+  EXPECT_EQ(gfx::Transform(), window->transform());
+}
+
+// Tests that the home launcher gestures work with overview mode as expected.
+TEST_F(HomeLauncherGestureHandlerTest, OverviewMode) {
+  UpdateDisplay("400x456");
+
+  auto window1 = CreateWindowForTesting();
+  auto window2 = CreateWindowForTesting();
+  EXPECT_FALSE(wm::GetWindowState(window1.get())->IsMinimized());
+  EXPECT_FALSE(wm::GetWindowState(window2.get())->IsMinimized());
+
+  OverviewController* controller = Shell::Get()->overview_controller();
+  controller->ToggleOverview();
+  const int window1_initial_translation =
+      window1->transform().To2dTranslation().y();
+  const int window2_initial_translation =
+      window2->transform().To2dTranslation().y();
+  DoPress(Mode::kSlideUpToShow);
+  EXPECT_FALSE(GetGestureHandler()->GetWindow1());
+
+  // Tests that while scrolling the window transform changes.
+  GetGestureHandler()->OnScrollEvent(gfx::Point(0, 300), 1.f);
+  EXPECT_NE(window1_initial_translation,
+            window1->transform().To2dTranslation().y());
+  EXPECT_NE(window2_initial_translation,
+            window2->transform().To2dTranslation().y());
+
+  // Tests that after releasing at below the halfway point, we remain in
+  // overview mode.
+  GetGestureHandler()->OnReleaseEvent(gfx::Point(0, 300));
+  EXPECT_TRUE(controller->IsSelecting());
+  EXPECT_EQ(window1_initial_translation,
+            window1->transform().To2dTranslation().y());
+  EXPECT_EQ(window2_initial_translation,
+            window2->transform().To2dTranslation().y());
+
+  // Tests that after releasing on the bottom half, overview mode has been
+  // exited, and the two windows have been minimized to show the home launcher.
+  DoPress(Mode::kSlideUpToShow);
+  GetGestureHandler()->OnReleaseEvent(gfx::Point(0, 100));
+  EXPECT_FALSE(controller->IsSelecting());
+  EXPECT_TRUE(wm::GetWindowState(window1.get())->IsMinimized());
+  EXPECT_TRUE(wm::GetWindowState(window2.get())->IsMinimized());
+}
+
+// Tests that there is no crash if entering overview mode while home launcher is
+// still in process of animating a window.
+TEST_F(HomeLauncherGestureHandlerTest, OverviewModeEnteredWhileAnimating) {
+  UpdateDisplay("400x456");
+  ui::ScopedAnimationDurationScaleMode scoped_animation_duration(
+      ui::ScopedAnimationDurationScaleMode::NON_ZERO_DURATION);
+
+  auto window = CreateWindowForTesting();
+  GetGestureHandler()->ShowHomeLauncher(
+      display_manager()->FindDisplayContainingPoint(gfx::Point(10, 10)));
+  Shell::Get()->overview_controller()->ToggleOverview();
+}
+
+// Tests that HomeLauncherGestureHandler works as expected when one window is
+// snapped, and overview mode is active on the other side.
+TEST_F(HomeLauncherGestureHandlerTest, SplitviewOneSnappedWindow) {
+  UpdateDisplay("400x456");
+
+  auto window1 = CreateWindowForTesting();
+  auto window2 = CreateWindowForTesting();
+
+  // Snap one window and leave overview mode open with the other window.
+  OverviewController* overview_controller = Shell::Get()->overview_controller();
+  overview_controller->ToggleOverview();
+  SplitViewController* split_view_controller =
+      Shell::Get()->split_view_controller();
+  split_view_controller->SnapWindow(window1.get(), SplitViewController::LEFT);
+  ASSERT_TRUE(overview_controller->IsSelecting());
+  ASSERT_TRUE(split_view_controller->IsSplitViewModeActive());
+
+  const int window2_initial_translation =
+      window2->transform().To2dTranslation().y();
+  DoPress(Mode::kSlideUpToShow);
+  EXPECT_EQ(window1.get(), GetGestureHandler()->GetWindow1());
+
+  // Tests that while scrolling the window transforms change.
+  GetGestureHandler()->OnScrollEvent(gfx::Point(0, 300), 1.f);
+  EXPECT_NE(window1->transform(), gfx::Transform());
+  EXPECT_NE(window2_initial_translation,
+            window2->transform().To2dTranslation().y());
+
+  // Tests that after releasing at below the halfway point, we remain in
+  // both splitview and overview mode.
+  GetGestureHandler()->OnReleaseEvent(gfx::Point(0, 300));
+  EXPECT_EQ(window1->transform(), gfx::Transform());
+  EXPECT_EQ(window2_initial_translation,
+            window2->transform().To2dTranslation().y());
+  EXPECT_TRUE(overview_controller->IsSelecting());
+  EXPECT_TRUE(split_view_controller->IsSplitViewModeActive());
+
+  // Tests that after releasing on the bottom half, overivew and splitview have
+  // both been exited, and both windows are minimized to show the home launcher.
+  DoPress(Mode::kSlideUpToShow);
+  GetGestureHandler()->OnReleaseEvent(gfx::Point(0, 100));
+  EXPECT_FALSE(overview_controller->IsSelecting());
+  EXPECT_FALSE(split_view_controller->IsSplitViewModeActive());
+  EXPECT_TRUE(wm::GetWindowState(window1.get())->IsMinimized());
+  EXPECT_TRUE(wm::GetWindowState(window2.get())->IsMinimized());
+}
+
+// Tests that swipe to close works as expected when there are two snapped
+// windows.
+TEST_F(HomeLauncherGestureHandlerTest, SplitviewTwoSnappedWindows) {
+  UpdateDisplay("400x456");
+
+  auto window1 = CreateWindowForTesting();
+  auto window2 = CreateWindowForTesting();
+
+  // Snap two windows to start.
+  SplitViewController* split_view_controller =
+      Shell::Get()->split_view_controller();
+  split_view_controller->SnapWindow(window1.get(), SplitViewController::LEFT);
+  split_view_controller->SnapWindow(window2.get(), SplitViewController::RIGHT);
+  ASSERT_TRUE(split_view_controller->IsSplitViewModeActive());
+
+  // Make |window1| the most recent used window. It should be the main window in
+  // HomeLauncherGestureHandler.
+  ::wm::ActivateWindow(window1.get());
+  DoPress(Mode::kSlideUpToShow);
+  EXPECT_EQ(window1.get(), GetGestureHandler()->GetWindow1());
+  EXPECT_EQ(window2.get(), GetGestureHandler()->GetWindow2());
+
+  // Tests that while scrolling the window transforms change.
+  GetGestureHandler()->OnScrollEvent(gfx::Point(0, 300), 1.f);
+  EXPECT_NE(window1->transform(), gfx::Transform());
+  EXPECT_NE(window2->transform(), gfx::Transform());
+
+  // Tests that after releasing at below the halfway point, we remain in
+  // splitview.
+  GetGestureHandler()->OnReleaseEvent(gfx::Point(0, 300));
+  EXPECT_EQ(window1->transform(), gfx::Transform());
+  EXPECT_EQ(window2->transform(), gfx::Transform());
+  EXPECT_TRUE(split_view_controller->IsSplitViewModeActive());
+
+  // Tests that after releasing on the bottom half, splitview has been ended,
+  // and the two windows have been minimized to show the home launcher.
+  DoPress(Mode::kSlideUpToShow);
+  GetGestureHandler()->OnReleaseEvent(gfx::Point(0, 100));
+  EXPECT_FALSE(split_view_controller->IsSplitViewModeActive());
+  EXPECT_TRUE(wm::GetWindowState(window1.get())->IsMinimized());
+  EXPECT_TRUE(wm::GetWindowState(window2.get())->IsMinimized());
+}
+
+// Tests that the shelf background is transparent when the home launcher is
+// dragged, and does not shift to opaque until the home launcher is completely
+// hidden from view and the finger is released.
+TEST_F(HomeLauncherGestureHandlerTest, TransparentShelfWileDragging) {
+  UpdateDisplay("400x456");
+
+  auto window = CreateWindowForTesting();
+  ASSERT_TRUE(window->IsVisible());
+  ASSERT_EQ(ShelfBackgroundType::SHELF_BACKGROUND_MAXIMIZED,
+            AshTestBase::GetPrimaryShelf()
+                ->shelf_layout_manager()
+                ->GetShelfBackgroundType());
+
+  // Begin to show the home launcher, the shelf should become transparent.
+  DoPress(Mode::kSlideUpToShow);
+  EXPECT_EQ(ShelfBackgroundType::SHELF_BACKGROUND_DEFAULT,
+            AshTestBase::GetPrimaryShelf()
+                ->shelf_layout_manager()
+                ->GetShelfBackgroundType());
+
+  // Fling up to complete showing the home launcher, the shelf should remain
+  // transparent.
+  GetGestureHandler()->OnScrollEvent(gfx::Point(0, 300), -10.f);
+  GetGestureHandler()->OnReleaseEvent(gfx::Point(0, 300));
+  EXPECT_EQ(ShelfBackgroundType::SHELF_BACKGROUND_DEFAULT,
+            AshTestBase::GetPrimaryShelf()
+                ->shelf_layout_manager()
+                ->GetShelfBackgroundType());
+
+  // Begin to hide the home launcher, the background should still be
+  // transparent.
+  DoPress(Mode::kSlideDownToHide);
+  EXPECT_EQ(ShelfBackgroundType::SHELF_BACKGROUND_DEFAULT,
+            AshTestBase::GetPrimaryShelf()
+                ->shelf_layout_manager()
+                ->GetShelfBackgroundType());
+
+  // Fling down to hide the home launcher, the shelf should still be
+  // transparent.
+  GetGestureHandler()->OnScrollEvent(gfx::Point(0, 100), -10.f);
+  EXPECT_EQ(ShelfBackgroundType::SHELF_BACKGROUND_DEFAULT,
+            AshTestBase::GetPrimaryShelf()
+                ->shelf_layout_manager()
+                ->GetShelfBackgroundType());
+
+  // The shelf should transition to opauqe when the gesture sequence has
+  // completed.
+  GetGestureHandler()->OnReleaseEvent(gfx::Point(0, 300));
+  EXPECT_EQ(ShelfBackgroundType::SHELF_BACKGROUND_MAXIMIZED,
+            AshTestBase::GetPrimaryShelf()
+                ->shelf_layout_manager()
+                ->GetShelfBackgroundType());
+}
+
+class HomeLauncherModeGestureHandlerTest
+    : public HomeLauncherGestureHandlerTest,
+      public testing::WithParamInterface<Mode> {
+ public:
+  HomeLauncherModeGestureHandlerTest() : mode_(GetParam()) {}
+  virtual ~HomeLauncherModeGestureHandlerTest() = default;
+
+  // HomeLauncherGestureHandlerTest:
+  std::unique_ptr<aura::Window> CreateWindowForTesting() override {
+    std::unique_ptr<aura::Window> window =
+        HomeLauncherGestureHandlerTest::CreateWindowForTesting();
+    if (mode_ == Mode::kSlideDownToHide)
+      wm::GetWindowState(window.get())->Minimize();
+    return window;
+  }
+
+ protected:
+  Mode mode_;
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(HomeLauncherModeGestureHandlerTest);
+};
+
+INSTANTIATE_TEST_CASE_P(,
+                        HomeLauncherModeGestureHandlerTest,
+                        testing::Values(Mode::kSlideDownToHide,
+                                        Mode::kSlideUpToShow));
+
+// Tests that the window transform and opacity changes as we scroll.
+TEST_P(HomeLauncherModeGestureHandlerTest, TransformAndOpacityChangesOnScroll) {
+  auto window = CreateWindowForTesting();
+
+  DoPress(mode_);
+  ASSERT_TRUE(GetGestureHandler()->GetWindow1());
+
+  // Test that on scrolling to a point on the top half of the work area, the
+  // window's opacity is between 0 and 0.5 and its transform has changed.
+  GetGestureHandler()->OnScrollEvent(gfx::Point(0, 100), 1.f);
+  const gfx::Transform top_half_transform = window->transform();
+  EXPECT_NE(gfx::Transform(), top_half_transform);
+  EXPECT_GT(window->layer()->opacity(), 0.f);
+  EXPECT_LT(window->layer()->opacity(), 0.5f);
+
+  // Test that on scrolling to a point on the bottom half of the work area, the
+  // window's opacity is between 0.5 and 1 and its transform has changed.
+  GetGestureHandler()->OnScrollEvent(gfx::Point(0, 300), 1.f);
+  EXPECT_NE(gfx::Transform(), window->transform());
+  EXPECT_NE(gfx::Transform(), top_half_transform);
+  EXPECT_GT(window->layer()->opacity(), 0.5f);
+  EXPECT_LT(window->layer()->opacity(), 1.f);
+}
+
+// Tests that releasing a drag at the bottom of the work area will show the
+// window.
+TEST_P(HomeLauncherModeGestureHandlerTest, BelowHalfShowsWindow) {
+  UpdateDisplay("400x400");
+  auto window3 = CreateWindowForTesting();
+  auto window2 = CreateWindowForTesting();
+  auto window1 = CreateWindowForTesting();
+
+  DoPress(mode_);
+  ASSERT_TRUE(GetGestureHandler()->GetWindow1());
+  ASSERT_FALSE(window2->IsVisible());
+  ASSERT_FALSE(window3->IsVisible());
+
+  // After a scroll the transform and opacity are no longer the identity and 1.
+  GetGestureHandler()->OnScrollEvent(gfx::Point(0, 300), 1.f);
+  EXPECT_NE(gfx::Transform(), window1->transform());
+  EXPECT_NE(1.f, window1->layer()->opacity());
+
+  // Tests the transform and opacity have returned to the identity and 1.
+  GetGestureHandler()->OnReleaseEvent(gfx::Point(0, 300));
+  EXPECT_EQ(gfx::Transform(), window1->transform());
+  EXPECT_EQ(1.f, window1->layer()->opacity());
+
+  if (mode_ == Mode::kSlideDownToHide)
+    return;
+
+  // The other windows return to their original visibility if mode is swiping
+  // up.
+  EXPECT_TRUE(window2->IsVisible());
+  EXPECT_TRUE(window3->IsVisible());
+}
+
+// Tests that a drag released at the top half of the work area will minimize the
+// window under action.
+TEST_P(HomeLauncherModeGestureHandlerTest, AboveHalfReleaseMinimizesWindow) {
+  UpdateDisplay("400x400");
+  auto window3 = CreateWindowForTesting();
+  auto window2 = CreateWindowForTesting();
+  auto window1 = CreateWindowForTesting();
+
+  DoPress(mode_);
+  ASSERT_TRUE(GetGestureHandler()->GetWindow1());
+  ASSERT_FALSE(window2->IsVisible());
+  ASSERT_FALSE(window3->IsVisible());
+
+  // Test that |window1| is minimized on release.
+  GetGestureHandler()->OnReleaseEvent(gfx::Point(0, 100));
+  EXPECT_TRUE(wm::GetWindowState(window1.get())->IsMinimized());
+
+  // The rest of the windows remain invisible, to show the home launcher.
+  EXPECT_FALSE(window2->IsVisible());
+  EXPECT_FALSE(window3->IsVisible());
+}
+
+// Tests on swipe up, the transient child of a window which is getting hidden
+// will have its opacity and transform altered as well.
+TEST_P(HomeLauncherModeGestureHandlerTest, WindowWithTransientChild) {
+  UpdateDisplay("400x456");
+
+  // Create a window with a transient child.
+  auto parent = CreateWindowForTesting();
+  auto child = CreateTestWindow(gfx::Rect(100, 100, 200, 200),
+                                aura::client::WINDOW_TYPE_POPUP);
+  child->SetTransform(gfx::Transform());
+  child->layer()->SetOpacity(1.f);
+  ::wm::AddTransientChild(parent.get(), child.get());
+
+  // |parent| should be the window that is getting hidden.
+  DoPress(mode_);
+  ASSERT_EQ(parent.get(), GetGestureHandler()->GetWindow1());
+
+  // Tests that after scrolling to the halfway point, the transient child's
+  // opacity and transform are halfway to their final values.
+  GetGestureHandler()->OnScrollEvent(gfx::Point(0, 200), 1.f);
+  EXPECT_LE(0.45f, child->layer()->opacity());
+  EXPECT_GE(0.55f, child->layer()->opacity());
+  EXPECT_NE(gfx::Transform(), child->transform());
+
+  // Tests that after releasing on the bottom half, the transient child reverts
+  // to its original values.
+  GetGestureHandler()->OnReleaseEvent(gfx::Point(0, 300));
+  EXPECT_EQ(1.0f, child->layer()->opacity());
+  EXPECT_EQ(gfx::Transform(), child->transform());
+}
+
+// Tests that when tablet mode is ended while in the middle of a scroll session,
+// the window is advanced to its end state.
+TEST_P(HomeLauncherModeGestureHandlerTest, EndScrollOnTabletModeEnd) {
+  auto window = CreateWindowForTesting();
+
+  DoPress(mode_);
+  ASSERT_TRUE(GetGestureHandler()->GetWindow1());
+
+  // Scroll to a point above the halfway mark of the work area.
+  GetGestureHandler()->OnScrollEvent(gfx::Point(0, 50), 1.f);
+  EXPECT_TRUE(GetGestureHandler()->GetWindow1());
+  EXPECT_FALSE(wm::GetWindowState(window.get())->IsMinimized());
+
+  // Tests that on exiting tablet mode, |window| gets minimized and is no longer
+  // tracked by the gesture handler.
+  Shell::Get()->tablet_mode_controller()->EnableTabletModeWindowManager(false);
+  EXPECT_FALSE(GetGestureHandler()->GetWindow1());
+  EXPECT_TRUE(wm::GetWindowState(window.get())->IsMinimized());
+}
+
+// Tests that the variables get set as expected during dragging, and get reset
+// after finishing a drag.
+TEST_P(HomeLauncherModeGestureHandlerTest, AnimatingToEndResetsState) {
+  // Create a window with a transient child to test that case.
+  auto window1 = CreateWindowForTesting();
+  auto window2 = CreateWindowForTesting();
+  auto child = CreateTestWindow(gfx::Rect(100, 100, 200, 200),
+                                aura::client::WINDOW_TYPE_POPUP);
+  ::wm::AddTransientChild(window1.get(), child.get());
+  ::wm::ActivateWindow(window1.get());
+
+  // For swipe down to hide launcher, all windows must be minimized.
+  if (mode_ == Mode::kSlideDownToHide) {
+    wm::GetWindowState(window2.get())->Minimize();
+    wm::GetWindowState(window1.get())->Minimize();
+  }
+
+  // Tests that the variables which change when dragging are as expected.
+  DoPress(mode_);
+  EXPECT_EQ(window1.get(), GetGestureHandler()->GetWindow1());
+  EXPECT_TRUE(GetGestureHandler()->last_event_location_);
+  EXPECT_EQ(mode_, GetGestureHandler()->mode_);
+  // We only need to hide windows when swiping up, so this will only be non
+  // empty in that case.
+  if (mode_ == Mode::kSlideUpToShow)
+    EXPECT_FALSE(GetGestureHandler()->hidden_windows_.empty());
+
+  // Tests that after a drag, the variables are either null or empty.
+  GetGestureHandler()->OnReleaseEvent(gfx::Point(10, 10));
+  EXPECT_FALSE(GetGestureHandler()->GetWindow1());
+  EXPECT_FALSE(GetGestureHandler()->last_event_location_);
+  EXPECT_EQ(Mode::kNone, GetGestureHandler()->mode_);
+  EXPECT_TRUE(GetGestureHandler()->hidden_windows_.empty());
+}
+
+}  // namespace ash
--- a/ash/ash_unittests_manifest.json	1970-01-01 03:00:00.000000000 +0300
+++ b/ash/ash_unittests_manifest.json	2019-05-17 18:53:08.100000000 +0300
@@ -0,0 +1,11 @@
+{
+  "name": "ash_unittests",
+  "display_name": "Ash Unittests",
+  "interface_provider_specs": {
+    "service_manager:connector": {
+      "requires": {
+        "*": [ "app", "test" ]
+      }
+    }
+  }
+}
--- a/ash/assistant/ui/assistant_background_layer.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/ash/assistant/ui/assistant_background_layer.cc	2019-05-17 18:53:08.104000000 +0300
@@ -0,0 +1,358 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ash/assistant/ui/assistant_background_layer.h"
+
+#include "ui/compositor/layer_animation_element.h"
+#include "ui/compositor/layer_animation_observer.h"
+#include "ui/compositor/layer_animation_sequence.h"
+#include "ui/compositor/layer_delegate.h"
+#include "ui/compositor/paint_recorder.h"
+#include "ui/compositor/scoped_layer_animation_settings.h"
+#include "ui/gfx/geometry/insets.h"
+#include "ui/gfx/geometry/rect_conversions.h"
+#include "ui/gfx/skia_paint_util.h"
+#include "ui/views/animation/ink_drop_painted_layer_delegates.h"
+
+namespace ash {
+namespace {
+
+constexpr float kBackgroundInitSizeDip = 48.f;
+constexpr float kBackgroundSizeDip = 48.f;
+constexpr float kBackgroundShadowElevationDip = 24.f;
+// TODO(xiaohuic): this is 2x device size, 1x actually have a different size.
+// Need to figure out a way to dynamically change sizes.
+constexpr float kBackgroundLargeWidthDip = 352.5f;
+constexpr float kBackgroundLargeHeightDip = 540.0f;
+constexpr float kBackgroundCornerRadiusDip = 12.f;
+constexpr int kBackgroundMorphDurationMs = 150;
+
+// The minimum scale factor to use when scaling rectangle layers. Smaller values
+// were causing visual anomalies.
+constexpr float kMinimumRectScale = 0.0001f;
+
+// The minimum scale factor to use when scaling circle layers. Smaller values
+// were causing visual anomalies.
+constexpr float kMinimumCircleScale = 0.001f;
+
+}  // namespace
+
+AssistantBackgroundLayer::AssistantBackgroundLayer()
+    : Layer(ui::LAYER_NOT_DRAWN),
+      large_size_(
+          gfx::Size(kBackgroundLargeWidthDip, kBackgroundLargeHeightDip)),
+      small_size_(gfx::Size(kBackgroundSizeDip, kBackgroundSizeDip)),
+      center_point_(
+          gfx::PointF(kBackgroundSizeDip / 2, kBackgroundSizeDip / 2)),
+      circle_layer_delegate_(
+          std::make_unique<views::CircleLayerDelegate>(SK_ColorWHITE,
+                                                       kBackgroundSizeDip / 2)),
+      rect_layer_delegate_(std::make_unique<views::RectangleLayerDelegate>(
+          SK_ColorWHITE,
+          gfx::SizeF(small_size_))) {
+  set_name("AssistantOverlay:BACKGROUND_LAYER");
+  SetBounds(gfx::Rect(0, 0, kBackgroundInitSizeDip, kBackgroundInitSizeDip));
+  SetFillsBoundsOpaquely(false);
+  SetMasksToBounds(false);
+
+  shadow_values_ =
+      gfx::ShadowValue::MakeMdShadowValues(kBackgroundShadowElevationDip);
+  const gfx::Insets shadow_margin = gfx::ShadowValue::GetMargin(shadow_values_);
+
+  border_shadow_delegate_ = std::make_unique<views::BorderShadowLayerDelegate>(
+      shadow_values_, gfx::Rect(large_size_), SK_ColorWHITE,
+      kBackgroundCornerRadiusDip);
+
+  large_shadow_layer_ = std::make_unique<ui::Layer>();
+  large_shadow_layer_->set_delegate(border_shadow_delegate_.get());
+  large_shadow_layer_->SetFillsBoundsOpaquely(false);
+  large_shadow_layer_->SetBounds(
+      gfx::Rect(shadow_margin.left(), shadow_margin.top(),
+                kBackgroundLargeWidthDip - shadow_margin.width(),
+                kBackgroundLargeHeightDip - shadow_margin.height()));
+  Add(large_shadow_layer_.get());
+
+  shadow_layer_ = std::make_unique<ui::Layer>();
+  shadow_layer_->set_delegate(this);
+  shadow_layer_->SetFillsBoundsOpaquely(false);
+  shadow_layer_->SetBounds(
+      gfx::Rect(shadow_margin.left(), shadow_margin.top(),
+                kBackgroundInitSizeDip - shadow_margin.width(),
+                kBackgroundInitSizeDip - shadow_margin.height()));
+  Add(shadow_layer_.get());
+
+  for (int i = 0; i < PAINTED_SHAPE_COUNT; ++i)
+    AddPaintLayer(static_cast<PaintedShape>(i));
+}
+
+AssistantBackgroundLayer::~AssistantBackgroundLayer() = default;
+
+void AssistantBackgroundLayer::MoveLargeShadow(const gfx::PointF& new_center) {
+  gfx::Transform transform;
+  transform.Translate(new_center.x() - kBackgroundLargeWidthDip / 2,
+                      new_center.y() - kBackgroundLargeHeightDip / 2);
+  large_shadow_layer_->SetTransform(transform);
+}
+
+void AssistantBackgroundLayer::AnimateToLarge(
+    const gfx::PointF& new_center,
+    ui::LayerAnimationObserver* animation_observer) {
+  PaintedShapeTransforms transforms;
+  // Setup the painted layers to be the small round size and show it
+  CalculateCircleTransforms(small_size_, &transforms);
+  SetTransforms(transforms);
+  SetPaintedLayersVisible(true);
+
+  // Hide the shadow layer
+  shadow_layer_->SetVisible(false);
+  // Also hide the large shadow layer, it will be shown when animation ends.
+  large_shadow_layer_->SetVisible(false);
+  // Move the shadow to the right place.
+  MoveLargeShadow(new_center);
+
+  center_point_ = new_center;
+  // Animate the painted layers to the large rectangle size
+  CalculateRectTransforms(large_size_, kBackgroundCornerRadiusDip, &transforms);
+
+  AnimateToTransforms(
+      transforms, base::TimeDelta::FromMilliseconds(kBackgroundMorphDurationMs),
+      ui::LayerAnimator::IMMEDIATELY_ANIMATE_TO_NEW_TARGET,
+      gfx::Tween::LINEAR_OUT_SLOW_IN, animation_observer);
+}
+
+void AssistantBackgroundLayer::SetToLarge(const gfx::PointF& new_center) {
+  PaintedShapeTransforms transforms;
+  SetPaintedLayersVisible(true);
+  // Hide the shadow layer
+  shadow_layer_->SetVisible(false);
+  // Show the large shadow behind
+  large_shadow_layer_->SetVisible(true);
+  // Move the shadow to the right place.
+  MoveLargeShadow(new_center);
+
+  center_point_ = new_center;
+  // Set the painted layers to the large rectangle size
+  CalculateRectTransforms(large_size_, kBackgroundCornerRadiusDip, &transforms);
+  SetTransforms(transforms);
+}
+
+void AssistantBackgroundLayer::ResetShape() {
+  // This reverts to the original small round shape.
+  shadow_layer_->SetVisible(true);
+  large_shadow_layer_->SetVisible(false);
+  SetPaintedLayersVisible(false);
+  center_point_.SetPoint(small_size_.width() / 2.f, small_size_.height() / 2.f);
+}
+
+void AssistantBackgroundLayer::AddPaintLayer(PaintedShape painted_shape) {
+  ui::LayerDelegate* delegate = nullptr;
+  switch (painted_shape) {
+    case TOP_LEFT_CIRCLE:
+    case TOP_RIGHT_CIRCLE:
+    case BOTTOM_RIGHT_CIRCLE:
+    case BOTTOM_LEFT_CIRCLE:
+      delegate = circle_layer_delegate_.get();
+      break;
+    case HORIZONTAL_RECT:
+    case VERTICAL_RECT:
+      delegate = rect_layer_delegate_.get();
+      break;
+    case PAINTED_SHAPE_COUNT:
+      NOTREACHED() << "PAINTED_SHAPE_COUNT is not an actual shape type.";
+      break;
+  }
+
+  ui::Layer* layer = new ui::Layer();
+  Add(layer);
+
+  layer->SetBounds(gfx::Rect(small_size_));
+  layer->SetFillsBoundsOpaquely(false);
+  layer->set_delegate(delegate);
+  layer->SetVisible(true);
+  layer->SetOpacity(1.0);
+  layer->SetMasksToBounds(false);
+  layer->set_name("PAINTED_SHAPE_COUNT:" + ToLayerName(painted_shape));
+
+  painted_layers_[static_cast<int>(painted_shape)].reset(layer);
+}
+
+void AssistantBackgroundLayer::SetTransforms(
+    const PaintedShapeTransforms transforms) {
+  for (int i = 0; i < PAINTED_SHAPE_COUNT; ++i)
+    painted_layers_[i]->SetTransform(transforms[i]);
+}
+
+void AssistantBackgroundLayer::SetPaintedLayersVisible(bool visible) {
+  for (int i = 0; i < PAINTED_SHAPE_COUNT; ++i)
+    painted_layers_[i]->SetVisible(visible);
+}
+
+void AssistantBackgroundLayer::CalculateCircleTransforms(
+    const gfx::Size& size,
+    PaintedShapeTransforms* transforms_out) const {
+  CalculateRectTransforms(size, std::min(size.width(), size.height()) / 2.0f,
+                          transforms_out);
+}
+
+void AssistantBackgroundLayer::CalculateRectTransforms(
+    const gfx::Size& desired_size,
+    float corner_radius,
+    PaintedShapeTransforms* transforms_out) const {
+  DCHECK_GE(desired_size.width() / 2.0f, corner_radius)
+      << "The circle's diameter should not be greater than the total width.";
+  DCHECK_GE(desired_size.height() / 2.0f, corner_radius)
+      << "The circle's diameter should not be greater than the total height.";
+
+  gfx::SizeF size(desired_size);
+  // This function can be called before the layer's been added to a view,
+  // either at construction time or in tests.
+  if (GetCompositor()) {
+    // Modify |desired_size| so that the ripple aligns to pixel bounds.
+    const float dsf = GetCompositor()->device_scale_factor();
+    gfx::RectF ripple_bounds((gfx::PointF(center_point_)), gfx::SizeF());
+    ripple_bounds.Inset(-gfx::InsetsF(desired_size.height() / 2.0f,
+                                      desired_size.width() / 2.0f));
+    ripple_bounds.Scale(dsf);
+    ripple_bounds = gfx::RectF(gfx::ToEnclosingRect(ripple_bounds));
+    ripple_bounds.Scale(1.0f / dsf);
+    size = ripple_bounds.size();
+  }
+
+  // The shapes are drawn such that their center points are not at the origin.
+  // Thus we use the CalculateCircleTransform() and CalculateRectTransform()
+  // methods to calculate the complex Transforms.
+
+  const float circle_scale = std::max(
+      kMinimumCircleScale,
+      corner_radius / static_cast<float>(circle_layer_delegate_->radius()));
+
+  const float circle_target_x_offset = size.width() / 2.0f - corner_radius;
+  const float circle_target_y_offset = size.height() / 2.0f - corner_radius;
+
+  (*transforms_out)[TOP_LEFT_CIRCLE] = CalculateCircleTransform(
+      circle_scale, -circle_target_x_offset, -circle_target_y_offset);
+  (*transforms_out)[TOP_RIGHT_CIRCLE] = CalculateCircleTransform(
+      circle_scale, circle_target_x_offset, -circle_target_y_offset);
+  (*transforms_out)[BOTTOM_RIGHT_CIRCLE] = CalculateCircleTransform(
+      circle_scale, circle_target_x_offset, circle_target_y_offset);
+  (*transforms_out)[BOTTOM_LEFT_CIRCLE] = CalculateCircleTransform(
+      circle_scale, -circle_target_x_offset, circle_target_y_offset);
+
+  const float rect_delegate_width = rect_layer_delegate_->size().width();
+  const float rect_delegate_height = rect_layer_delegate_->size().height();
+
+  (*transforms_out)[HORIZONTAL_RECT] = CalculateRectTransform(
+      std::max(kMinimumRectScale, size.width() / rect_delegate_width),
+      std::max(kMinimumRectScale,
+               (size.height() - 2.0f * corner_radius) / rect_delegate_height));
+
+  (*transforms_out)[VERTICAL_RECT] = CalculateRectTransform(
+      std::max(kMinimumRectScale,
+               (size.width() - 2.0f * corner_radius) / rect_delegate_width),
+      std::max(kMinimumRectScale, size.height() / rect_delegate_height));
+}
+
+gfx::Transform AssistantBackgroundLayer::CalculateCircleTransform(
+    float scale,
+    float target_center_x,
+    float target_center_y) const {
+  gfx::Transform transform;
+  // Offset for the center point of the ripple.
+  transform.Translate(center_point_.x(), center_point_.y());
+  // Move circle to target.
+  transform.Translate(target_center_x, target_center_y);
+  transform.Scale(scale, scale);
+  // Align center point of the painted circle.
+  const gfx::Vector2dF circle_center_offset =
+      circle_layer_delegate_->GetCenteringOffset();
+  transform.Translate(-circle_center_offset.x(), -circle_center_offset.y());
+  return transform;
+}
+
+gfx::Transform AssistantBackgroundLayer::CalculateRectTransform(
+    float x_scale,
+    float y_scale) const {
+  gfx::Transform transform;
+  transform.Translate(center_point_.x(), center_point_.y());
+  transform.Scale(x_scale, y_scale);
+  const gfx::Vector2dF rect_center_offset =
+      rect_layer_delegate_->GetCenteringOffset();
+  transform.Translate(-rect_center_offset.x(), -rect_center_offset.y());
+  return transform;
+}
+
+void AssistantBackgroundLayer::AnimateToTransforms(
+    const PaintedShapeTransforms transforms,
+    base::TimeDelta duration,
+    ui::LayerAnimator::PreemptionStrategy preemption_strategy,
+    gfx::Tween::Type tween,
+    ui::LayerAnimationObserver* animation_observer) {
+  for (int i = 0; i < PAINTED_SHAPE_COUNT; ++i) {
+    ui::LayerAnimator* animator = painted_layers_[i]->GetAnimator();
+    ui::ScopedLayerAnimationSettings animation(animator);
+    animation.SetPreemptionStrategy(preemption_strategy);
+    animation.SetTweenType(tween);
+    std::unique_ptr<ui::LayerAnimationElement> element =
+        ui::LayerAnimationElement::CreateTransformElement(transforms[i],
+                                                          duration);
+    ui::LayerAnimationSequence* sequence =
+        new ui::LayerAnimationSequence(std::move(element));
+
+    if (animation_observer)
+      sequence->AddObserver(animation_observer);
+
+    animator->StartAnimation(sequence);
+  }
+
+  {
+    ui::ScopedLayerAnimationSettings animation(
+        large_shadow_layer_->GetAnimator());
+    animation.SetTweenType(tween);
+    animation.SetTransitionDuration(duration);
+
+    large_shadow_layer_->SetVisible(true);
+  }
+}
+
+std::string AssistantBackgroundLayer::ToLayerName(PaintedShape painted_shape) {
+  switch (painted_shape) {
+    case TOP_LEFT_CIRCLE:
+      return "TOP_LEFT_CIRCLE";
+    case TOP_RIGHT_CIRCLE:
+      return "TOP_RIGHT_CIRCLE";
+    case BOTTOM_RIGHT_CIRCLE:
+      return "BOTTOM_RIGHT_CIRCLE";
+    case BOTTOM_LEFT_CIRCLE:
+      return "BOTTOM_LEFT_CIRCLE";
+    case HORIZONTAL_RECT:
+      return "HORIZONTAL_RECT";
+    case VERTICAL_RECT:
+      return "VERTICAL_RECT";
+    case PAINTED_SHAPE_COUNT:
+      NOTREACHED() << "The PAINTED_SHAPE_COUNT value should never be used.";
+      return "PAINTED_SHAPE_COUNT";
+  }
+  return "UNKNOWN";
+}
+
+void AssistantBackgroundLayer::OnPaintLayer(const ui::PaintContext& context) {
+  // Radius is based on the parent layer size, the shadow layer is expanded
+  // to make room for the shadow.
+  float radius = size().width() / 2.f;
+
+  ui::PaintRecorder recorder(context, shadow_layer_->size());
+  gfx::Canvas* canvas = recorder.canvas();
+
+  cc::PaintFlags flags;
+  flags.setColor(SK_ColorWHITE);
+  flags.setAntiAlias(true);
+  flags.setStyle(cc::PaintFlags::kFill_Style);
+  flags.setLooper(gfx::CreateShadowDrawLooper(shadow_values_));
+  gfx::Rect shadow_bounds = shadow_layer_->bounds();
+  canvas->DrawCircle(
+      gfx::PointF(radius - shadow_bounds.x(), radius - shadow_bounds.y()),
+      radius, flags);
+}
+
+}  // namespace ash
--- a/ash/assistant/ui/assistant_background_layer.h	1970-01-01 03:00:00.000000000 +0300
+++ b/ash/assistant/ui/assistant_background_layer.h	2019-05-17 18:53:08.104000000 +0300
@@ -0,0 +1,129 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef ASH_ASSISTANT_UI_ASSISTANT_BACKGROUND_LAYER_H_
+#define ASH_ASSISTANT_UI_ASSISTANT_BACKGROUND_LAYER_H_
+
+#include <memory>
+
+#include "ash/ash_export.h"
+#include "base/macros.h"
+#include "base/time/time.h"
+#include "ui/compositor/layer.h"
+#include "ui/compositor/layer_animator.h"
+#include "ui/compositor/layer_delegate.h"
+#include "ui/gfx/animation/tween.h"
+#include "ui/gfx/shadow_value.h"
+
+namespace ui {
+class LayerAnimationObserver;
+}  // namespace ui
+
+namespace views {
+class BorderShadowLayerDelegate;
+class CircleLayerDelegate;
+class RectangleLayerDelegate;
+}  // namespace views
+
+namespace ash {
+
+// TODO(wutao): This class is copied from assistant_overlay.cc for future
+// animation smoothness improvement so that we can track the changes.
+class ASH_EXPORT AssistantBackgroundLayer : public ui::Layer,
+                                            public ui::LayerDelegate {
+ public:
+  AssistantBackgroundLayer();
+  ~AssistantBackgroundLayer() override;
+
+  void MoveLargeShadow(const gfx::PointF& new_center);
+
+  void AnimateToLarge(const gfx::PointF& new_center,
+                      ui::LayerAnimationObserver* animation_observer);
+
+  void SetToLarge(const gfx::PointF& new_center);
+
+  void ResetShape();
+
+ private:
+  // Enumeration of the different shapes that compose the background.
+  enum PaintedShape {
+    TOP_LEFT_CIRCLE = 0,
+    TOP_RIGHT_CIRCLE,
+    BOTTOM_RIGHT_CIRCLE,
+    BOTTOM_LEFT_CIRCLE,
+    HORIZONTAL_RECT,
+    VERTICAL_RECT,
+    // The total number of shapes, not an actual shape.
+    PAINTED_SHAPE_COUNT
+  };
+
+  typedef gfx::Transform PaintedShapeTransforms[PAINTED_SHAPE_COUNT];
+
+  void AddPaintLayer(PaintedShape painted_shape);
+
+  void SetTransforms(const PaintedShapeTransforms transforms);
+
+  void SetPaintedLayersVisible(bool visible);
+
+  void CalculateCircleTransforms(const gfx::Size& size,
+                                 PaintedShapeTransforms* transforms_out) const;
+
+  void CalculateRectTransforms(const gfx::Size& desired_size,
+                               float corner_radius,
+                               PaintedShapeTransforms* transforms_out) const;
+
+  gfx::Transform CalculateCircleTransform(float scale,
+                                          float target_center_x,
+                                          float target_center_y) const;
+
+  gfx::Transform CalculateRectTransform(float x_scale, float y_scale) const;
+
+  void AnimateToTransforms(
+      const PaintedShapeTransforms transforms,
+      base::TimeDelta duration,
+      ui::LayerAnimator::PreemptionStrategy preemption_strategy,
+      gfx::Tween::Type tween,
+      ui::LayerAnimationObserver* animation_observer);
+
+  std::string ToLayerName(PaintedShape painted_shape);
+
+  // ui::LayerDelegate:
+  void OnPaintLayer(const ui::PaintContext& context) override;
+  void OnDeviceScaleFactorChanged(float old_device_scale_factor,
+                                  float new_device_scale_factor) override {}
+
+  // ui::Layers for all of the painted shape layers that compose the morphing
+  // shape.
+  std::unique_ptr<ui::Layer> painted_layers_[PAINTED_SHAPE_COUNT];
+
+  const gfx::Size large_size_;
+
+  const gfx::Size small_size_;
+
+  // The center point of the painted shape.
+  gfx::PointF center_point_;
+
+  // ui::LayerDelegate to paint circles for all the circle layers.
+  std::unique_ptr<views::CircleLayerDelegate> circle_layer_delegate_;
+
+  // ui::LayerDelegate to paint rectangles for all the rectangle layers.
+  std::unique_ptr<views::RectangleLayerDelegate> rect_layer_delegate_;
+
+  // ui::LayerDelegate to paint rounded rectangle with shadow.
+  std::unique_ptr<views::BorderShadowLayerDelegate> border_shadow_delegate_;
+
+  gfx::ShadowValues shadow_values_;
+
+  // This layer shows the small circle with shadow.
+  std::unique_ptr<ui::Layer> shadow_layer_;
+
+  // This layer shows the large rounded rectangle with shadow.
+  std::unique_ptr<ui::Layer> large_shadow_layer_;
+
+  DISALLOW_COPY_AND_ASSIGN(AssistantBackgroundLayer);
+};
+
+}  // namespace ash
+
+#endif  // ASH_ASSISTANT_UI_ASSISTANT_BACKGROUND_LAYER_H_
diff -BbuN a/ash/components/quick_launch/BUILD.gn b/ash/components/quick_launch/BUILD.gn
--- a/ash/components/quick_launch/BUILD.gn	1970-01-01 03:00:00.000000000 +0300
+++ b/ash/components/quick_launch/BUILD.gn	2019-05-17 18:53:08.116000000 +0300
@@ -0,0 +1,50 @@
+# Copyright 2016 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+import("//build/config/ui.gni")
+import("//mojo/public/tools/bindings/mojom.gni")
+import("//services/service_manager/public/cpp/service_executable.gni")
+import("//services/service_manager/public/service_manifest.gni")
+import("//tools/grit/repack.gni")
+
+source_set("lib") {
+  sources = [
+    "quick_launch_application.cc",
+    "quick_launch_application.h",
+  ]
+
+  deps = [
+    "//ash/public/cpp",
+    "//base",
+    "//mash/public/mojom",
+    "//mojo/public/cpp/bindings",
+    "//services/catalog/public/mojom",
+    "//services/service_manager/public/cpp",
+    "//services/service_manager/public/mojom",
+    "//ui/views",
+    "//ui/views/mus:for_mojo_application",
+    "//url",
+  ]
+}
+
+service_executable("quick_launch_app") {
+  sources = [
+    "main.cc",
+  ]
+
+  deps = [
+    ":lib",
+    "//services/service_manager/public/cpp",
+    "//ui/views/mus:for_mojo_application",
+  ]
+
+  data_deps = [
+    "//ui/views/mus:resources",
+  ]
+}
+
+service_manifest("manifest") {
+  name = "quick_launch_app"
+  source = "manifest.json"
+}
diff -BbuN a/ash/components/quick_launch/DEPS b/ash/components/quick_launch/DEPS
--- a/ash/components/quick_launch/DEPS	1970-01-01 03:00:00.000000000 +0300
+++ b/ash/components/quick_launch/DEPS	2019-05-17 18:53:08.116000000 +0300
@@ -0,0 +1,5 @@
+include_rules = [
+  "+mash/public",
+  "+services/catalog/public",
+  "+url",
+]
diff -BbuN a/ash/components/quick_launch/main.cc b/ash/components/quick_launch/main.cc
--- a/ash/components/quick_launch/main.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/ash/components/quick_launch/main.cc	2019-05-17 18:53:08.116000000 +0300
@@ -0,0 +1,14 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ash/components/quick_launch/quick_launch_application.h"
+#include "base/message_loop/message_loop.h"
+#include "services/service_manager/public/cpp/service_executable/service_main.h"
+
+void ServiceMain(service_manager::mojom::ServiceRequest request) {
+  base::MessageLoop message_loop;
+  quick_launch::QuickLaunchApplication service(std::move(request));
+  service.set_running_standalone(true);
+  service.RunUntilTermination();
+}
diff -BbuN a/ash/components/quick_launch/manifest.json b/ash/components/quick_launch/manifest.json
--- a/ash/components/quick_launch/manifest.json	1970-01-01 03:00:00.000000000 +0300
+++ b/ash/components/quick_launch/manifest.json	2019-05-17 18:53:08.116000000 +0300
@@ -0,0 +1,16 @@
+{
+  "name": "quick_launch_app",
+  "display_name": "Quick Launch Bar",
+  "sandbox_type": "none",
+  "interface_provider_specs": {
+    "service_manager:connector": {
+      "requires": {
+        "*": [ "app", "mash:launchable" ],
+        "catalog": [
+          "catalog:catalog",
+          "directory"
+        ]
+      }
+    }
+  }
+}
diff -BbuN a/ash/components/quick_launch/OWNERS b/ash/components/quick_launch/OWNERS
--- a/ash/components/quick_launch/OWNERS	1970-01-01 03:00:00.000000000 +0300
+++ b/ash/components/quick_launch/OWNERS	2019-05-17 18:53:08.116000000 +0300
@@ -0,0 +1,2 @@
+per-file manifest.json=set noparent
+per-file manifest.json=file://ipc/SECURITY_OWNERS
 : a/ash/components/quick_launch/public  b/ash/components/quick_launch/public
diff -BbuN a/ash/components/quick_launch/quick_launch_application.cc b/ash/components/quick_launch/quick_launch_application.cc
--- a/ash/components/quick_launch/quick_launch_application.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/ash/components/quick_launch/quick_launch_application.cc	2019-05-17 18:53:08.116000000 +0300
@@ -0,0 +1,206 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ash/components/quick_launch/quick_launch_application.h"
+
+#include "ash/public/cpp/ash_client.h"
+#include "base/macros.h"
+#include "base/memory/ptr_util.h"
+#include "base/run_loop.h"
+#include "base/strings/string16.h"
+#include "base/strings/string_util.h"
+#include "base/strings/utf_string_conversions.h"
+#include "mash/public/mojom/launchable.mojom.h"
+#include "services/catalog/public/mojom/catalog.mojom.h"
+#include "services/catalog/public/mojom/constants.mojom.h"
+#include "services/service_manager/public/cpp/connector.h"
+#include "services/service_manager/public/cpp/service.h"
+#include "ui/aura/window.h"
+#include "ui/aura/window_tree_host.h"
+#include "ui/views/background.h"
+#include "ui/views/controls/textfield/textfield.h"
+#include "ui/views/controls/textfield/textfield_controller.h"
+#include "ui/views/mus/aura_init.h"
+#include "ui/views/widget/widget.h"
+#include "ui/views/widget/widget_delegate.h"
+#include "url/gurl.h"
+
+namespace quick_launch {
+namespace {
+
+class QuickLaunchUI : public views::WidgetDelegateView,
+                      public views::TextfieldController {
+ public:
+  QuickLaunchUI(QuickLaunchApplication* quick_launch,
+                service_manager::Connector* connector,
+                catalog::mojom::CatalogPtr catalog)
+      : quick_launch_(quick_launch),
+        connector_(connector),
+        prompt_(new views::Textfield),
+        catalog_(std::move(catalog)) {
+    SetBackground(views::CreateStandardPanelBackground());
+    prompt_->set_controller(this);
+    AddChildView(prompt_);
+
+    UpdateEntries();
+  }
+  ~QuickLaunchUI() override { quick_launch_->Quit(); }
+
+ private:
+  // Overridden from views::WidgetDelegate:
+  base::string16 GetWindowTitle() const override {
+    // TODO(beng): use resources.
+    return base::ASCIIToUTF16("QuickLaunch");
+  }
+
+  // Overridden from views::View:
+  void Layout() override {
+    gfx::Rect bounds = GetLocalBounds();
+    bounds.Inset(5, 5);
+    prompt_->SetBoundsRect(bounds);
+  }
+  gfx::Size CalculatePreferredSize() const override {
+    gfx::Size ps = prompt_->GetPreferredSize();
+    ps.Enlarge(500, 10);
+    return ps;
+  }
+
+  // Overridden from views::TextFieldController:
+  bool HandleKeyEvent(views::Textfield* sender,
+                      const ui::KeyEvent& key_event) override {
+    if (key_event.type() != ui::ET_KEY_PRESSED)
+      return false;
+
+    // The user didn't like our suggestion, don't make another until they
+    // type another character.
+    suggestion_rejected_ = key_event.key_code() == ui::VKEY_BACK ||
+                           key_event.key_code() == ui::VKEY_DELETE;
+    if (key_event.key_code() == ui::VKEY_RETURN) {
+      Launch(Canonicalize(prompt_->text()), key_event.IsControlDown());
+      prompt_->SetText(base::string16());
+      UpdateEntries();
+    }
+    return false;
+  }
+
+  void ContentsChanged(views::Textfield* sender,
+                       const base::string16& new_contents) override {
+    // Don't keep making a suggestion if the user didn't like what we offered.
+    if (suggestion_rejected_)
+      return;
+
+    if (new_contents.empty())
+      return;
+
+    // TODO(beng): it'd be nice if we persisted some history/scoring here.
+    for (const auto& name : app_names_) {
+      if (base::StartsWith(name, new_contents,
+                           base::CompareCase::INSENSITIVE_ASCII)) {
+        base::string16 suffix = name;
+        base::ReplaceSubstringsAfterOffset(&suffix, 0, new_contents,
+                                           base::string16());
+        gfx::Range range(static_cast<uint32_t>(new_contents.size()),
+                         static_cast<uint32_t>(name.size()));
+        prompt_->SetText(name);
+        prompt_->SelectRange(range);
+        break;
+      }
+    }
+  }
+
+  std::string Canonicalize(const base::string16& input) const {
+    base::string16 working;
+    base::TrimWhitespace(input, base::TRIM_ALL, &working);
+    GURL url(working);
+    if (url.scheme() != "service" && url.scheme() != "exe")
+      working = base::ASCIIToUTF16("") + working;
+    return base::UTF16ToUTF8(working);
+  }
+
+  void UpdateEntries() {
+    catalog_->GetEntriesProvidingCapability(
+        "mash:launchable",
+        base::BindRepeating(&QuickLaunchUI::OnGotCatalogEntries,
+                            base::Unretained(this)));
+  }
+
+  void OnGotCatalogEntries(std::vector<catalog::mojom::EntryPtr> entries) {
+    for (const auto& entry : entries)
+      app_names_.insert(base::UTF8ToUTF16(entry->name));
+  }
+
+  void Launch(const std::string& name, bool new_window) {
+    // TODO(jamescook): Start the service by name. Most services don't
+    // support the Launchable interface any more.
+    ::mash::mojom::LaunchablePtr launchable;
+    connector_->BindInterface(name, &launchable);
+    launchable->Launch(mash::mojom::kWindow,
+                       new_window ? mash::mojom::LaunchMode::MAKE_NEW
+                                  : mash::mojom::LaunchMode::REUSE);
+  }
+
+  QuickLaunchApplication* quick_launch_;
+  service_manager::Connector* connector_;
+  views::Textfield* prompt_;
+  catalog::mojom::CatalogPtr catalog_;
+  std::set<base::string16> app_names_;
+  bool suggestion_rejected_ = false;
+
+  DISALLOW_COPY_AND_ASSIGN(QuickLaunchUI);
+};
+
+}  // namespace
+
+QuickLaunchApplication::QuickLaunchApplication(
+    service_manager::mojom::ServiceRequest request)
+    : service_binding_(this, std::move(request)) {}
+
+QuickLaunchApplication::~QuickLaunchApplication() {
+  if (window_)
+    window_->CloseNow();
+}
+
+void QuickLaunchApplication::Quit() {
+  window_ = nullptr;
+  Terminate();
+}
+
+void QuickLaunchApplication::OnStart() {
+  // If AuraInit was unable to initialize there is no longer a peer connection.
+  // The ServiceManager is in the process of shutting down, however we haven't
+  // been notified yet. We just self-terminate in this case.
+  views::AuraInit::InitParams params;
+  params.connector = service_binding_.GetConnector();
+  params.identity = service_binding_.identity();
+  params.register_path_provider = running_standalone_;
+  params.use_accessibility_host = true;
+  aura_init_ = views::AuraInit::Create(params);
+  if (!aura_init_) {
+    Terminate();
+    return;
+  }
+
+  // Register as a client of the window manager.
+  ash::ash_client::Init();
+
+  catalog::mojom::CatalogPtr catalog;
+  service_binding_.GetConnector()->BindInterface(catalog::mojom::kServiceName,
+                                                 &catalog);
+
+  window_ = views::Widget::CreateWindowWithContextAndBounds(
+      new QuickLaunchUI(this, service_binding_.GetConnector(),
+                        std::move(catalog)),
+      nullptr, gfx::Rect(10, 640, 0, 0));
+  window_->GetNativeWindow()->GetHost()->window()->SetName("QuickLaunch");
+  window_->Show();
+}
+
+void QuickLaunchApplication::OnBindInterface(
+    const service_manager::BindSourceInfo& source_info,
+    const std::string& interface_name,
+    mojo::ScopedMessagePipeHandle interface_pipe) {
+  registry_.BindInterface(interface_name, std::move(interface_pipe));
+}
+
+}  // namespace quick_launch
diff -BbuN a/ash/components/quick_launch/quick_launch_application.h b/ash/components/quick_launch/quick_launch_application.h
--- a/ash/components/quick_launch/quick_launch_application.h	1970-01-01 03:00:00.000000000 +0300
+++ b/ash/components/quick_launch/quick_launch_application.h	2019-05-17 18:53:08.116000000 +0300
@@ -0,0 +1,54 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef ASH_COMPONENTS_QUICK_LAUNCH_QUICK_LAUNCH_APPLICATION_H_
+#define ASH_COMPONENTS_QUICK_LAUNCH_QUICK_LAUNCH_APPLICATION_H_
+
+#include <memory>
+
+#include "base/macros.h"
+#include "services/service_manager/public/cpp/binder_registry.h"
+#include "services/service_manager/public/cpp/service.h"
+#include "services/service_manager/public/cpp/service_binding.h"
+
+namespace views {
+class AuraInit;
+class Widget;
+}  // namespace views
+
+namespace quick_launch {
+
+class QuickLaunchApplication : public service_manager::Service {
+ public:
+  explicit QuickLaunchApplication(
+      service_manager::mojom::ServiceRequest request);
+  ~QuickLaunchApplication() override;
+
+  void Quit();
+
+  void set_running_standalone(bool value) { running_standalone_ = value; }
+
+ private:
+  // service_manager::Service:
+  void OnStart() override;
+  void OnBindInterface(const service_manager::BindSourceInfo& source_info,
+                       const std::string& interface_name,
+                       mojo::ScopedMessagePipeHandle interface_pipe) override;
+
+  service_manager::ServiceBinding service_binding_;
+
+  views::Widget* window_ = nullptr;
+
+  service_manager::BinderRegistry registry_;
+
+  std::unique_ptr<views::AuraInit> aura_init_;
+
+  bool running_standalone_ = false;
+
+  DISALLOW_COPY_AND_ASSIGN(QuickLaunchApplication);
+};
+
+}  // namespace quick_launch
+
+#endif  // ASH_COMPONENTS_QUICK_LAUNCH_QUICK_LAUNCH_APPLICATION_H_
--- a/ash/components/shortcut_viewer/manifest.json	1970-01-01 03:00:00.000000000 +0300
+++ b/ash/components/shortcut_viewer/manifest.json	2019-05-17 18:53:08.116000000 +0300
@@ -0,0 +1,16 @@
+{
+  "name": "shortcut_viewer_app",
+  "display_name": "Keyboard Shortcut Viewer",
+  "sandbox_type": "none",
+  "interface_provider_specs": {
+    "service_manager:connector": {
+      "provides": {
+        "shortcut_viewer": [ "shortcut_viewer.mojom.ShortcutViewer" ]
+      },
+      "requires": {
+        "*": [ "app" ],
+        "service_manager": [ "service_manager:service_manager" ]
+      }
+    }
+  }
+}
--- a/ash/components/tap_visualizer/manifest.json	1970-01-01 03:00:00.000000000 +0300
+++ b/ash/components/tap_visualizer/manifest.json	2019-05-17 18:53:08.136000000 +0300
@@ -0,0 +1,16 @@
+{
+  "name": "tap_visualizer_app",
+  "display_name": "Show Taps",
+  "sandbox_type": "none",
+  "interface_provider_specs": {
+    "service_manager:connector": {
+      "provides": {
+        "tap_visualizer": [ "tap_visualizer.mojom.TapVisualizer" ]
+      },
+      "requires": {
+        "*": [ "app" ],
+        "service_manager": [ "service_manager:service_manager" ]
+      }
+    }
+  }
+}
--- a/ash/components/tap_visualizer/OWNERS	1970-01-01 03:00:00.000000000 +0300
+++ b/ash/components/tap_visualizer/OWNERS	2019-05-17 18:53:08.136000000 +0300
@@ -0,0 +1,2 @@
+per-file manifest.json=set noparent
+per-file manifest.json=file://ipc/SECURITY_OWNERS
diff -BbuN a/ash/contained_shell/contained_shell_controller.cc b/ash/contained_shell/contained_shell_controller.cc
--- a/ash/contained_shell/contained_shell_controller.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/ash/contained_shell/contained_shell_controller.cc	2019-05-17 18:53:08.136000000 +0300
@@ -0,0 +1,35 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ash/contained_shell/contained_shell_controller.h"
+#include "ash/session/session_controller.h"
+#include "ash/shell.h"
+#include "components/account_id/account_id.h"
+
+#include <utility>
+
+namespace ash {
+
+ContainedShellController::ContainedShellController() = default;
+
+ContainedShellController::~ContainedShellController() = default;
+
+void ContainedShellController::BindRequest(
+    mojom::ContainedShellControllerRequest request) {
+  bindings_.AddBinding(this, std::move(request));
+}
+
+void ContainedShellController::LaunchContainedShell() {
+  contained_shell_client_->LaunchContainedShell(Shell::Get()
+                                                    ->session_controller()
+                                                    ->GetPrimaryUserSession()
+                                                    ->user_info->account_id);
+}
+
+void ContainedShellController::SetClient(
+    mojom::ContainedShellClientPtr client) {
+  contained_shell_client_ = std::move(client);
+}
+
+}  // namespace ash
diff -BbuN a/ash/contained_shell/contained_shell_controller.h b/ash/contained_shell/contained_shell_controller.h
--- a/ash/contained_shell/contained_shell_controller.h	1970-01-01 03:00:00.000000000 +0300
+++ b/ash/contained_shell/contained_shell_controller.h	2019-05-17 18:53:08.136000000 +0300
@@ -0,0 +1,44 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef ASH_CONTAINED_SHELL_CONTAINED_SHELL_CONTROLLER_H_
+#define ASH_CONTAINED_SHELL_CONTAINED_SHELL_CONTROLLER_H_
+
+#include "ash/ash_export.h"
+#include "ash/public/interfaces/contained_shell.mojom.h"
+#include "base/macros.h"
+#include "mojo/public/cpp/bindings/binding_set.h"
+
+namespace ash {
+
+// ContainedShellController allows a consumer of ash to provide a
+// ContainedShellClient, to which we dispatch requests.
+// TODO(910226): remove this code once the ContainedShell demo is complete and
+// no longer needed.
+class ASH_EXPORT ContainedShellController
+    : public mojom::ContainedShellController {
+ public:
+  ContainedShellController();
+  ~ContainedShellController() override;
+
+  // Binds the mojom::ContainedShellController interface to this object.
+  void BindRequest(mojom::ContainedShellControllerRequest request);
+
+  // Starts the ContainedShell feature by sending LaunchContainedShell
+  // request to ContainedShellClient.
+  void LaunchContainedShell();
+
+  // mojom::ContainedShellController:
+  void SetClient(mojom::ContainedShellClientPtr client) override;
+
+ private:
+  mojom::ContainedShellClientPtr contained_shell_client_;
+  mojo::BindingSet<mojom::ContainedShellController> bindings_;
+
+  DISALLOW_COPY_AND_ASSIGN(ContainedShellController);
+};
+
+}  // namespace ash
+
+#endif  // ASH_CONTAINED_SHELL_CONTAINED_SHELL_CONTROLLER_H
diff -BbuN a/ash/contained_shell/mock_contained_shell_client.cc b/ash/contained_shell/mock_contained_shell_client.cc
--- a/ash/contained_shell/mock_contained_shell_client.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/ash/contained_shell/mock_contained_shell_client.cc	2019-05-17 18:53:08.136000000 +0300
@@ -0,0 +1,30 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ash/contained_shell/mock_contained_shell_client.h"
+
+#include "ash/contained_shell/contained_shell_controller.h"
+#include "ash/shell.h"
+
+namespace ash {
+
+MockContainedShellClient::MockContainedShellClient() = default;
+
+MockContainedShellClient::~MockContainedShellClient() = default;
+
+mojom::ContainedShellClientPtr
+MockContainedShellClient::CreateInterfacePtrAndBind() {
+  mojom::ContainedShellClientPtr ptr;
+  binding_.Bind(mojo::MakeRequest(&ptr));
+  return ptr;
+}
+
+std::unique_ptr<MockContainedShellClient> BindMockContainedShellClient() {
+  auto client = std::make_unique<MockContainedShellClient>();
+  Shell::Get()->contained_shell_controller()->SetClient(
+      client->CreateInterfacePtrAndBind());
+  return client;
+}
+
+}  // namespace ash
diff -BbuN a/ash/contained_shell/mock_contained_shell_client.h b/ash/contained_shell/mock_contained_shell_client.h
--- a/ash/contained_shell/mock_contained_shell_client.h	1970-01-01 03:00:00.000000000 +0300
+++ b/ash/contained_shell/mock_contained_shell_client.h	2019-05-17 18:53:08.136000000 +0300
@@ -0,0 +1,40 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef ASH_CONTAINED_SHELL_MOCK_CONTAINED_SHELL_CLIENT_H_
+#define ASH_CONTAINED_SHELL_MOCK_CONTAINED_SHELL_CLIENT_H_
+
+#include <memory>
+
+#include "ash/public/interfaces/contained_shell.mojom.h"
+#include "base/macros.h"
+#include "components/account_id/account_id.h"
+#include "mojo/public/cpp/bindings/binding.h"
+#include "testing/gmock/include/gmock/gmock.h"
+
+namespace ash {
+
+class MockContainedShellClient : public mojom::ContainedShellClient {
+ public:
+  MockContainedShellClient();
+  ~MockContainedShellClient() override;
+
+  mojom::ContainedShellClientPtr CreateInterfacePtrAndBind();
+
+  // mojom::ContainedShellClient:
+  MOCK_METHOD1(LaunchContainedShell, void(const AccountId& account_id));
+
+ private:
+  mojo::Binding<mojom::ContainedShellClient> binding_{this};
+
+  DISALLOW_COPY_AND_ASSIGN(MockContainedShellClient);
+};
+
+// Helper function to bind a ContainedShellClient so that it receives mojo
+// calls.
+std::unique_ptr<MockContainedShellClient> BindMockContainedShellClient();
+
+}  // namespace ash
+
+#endif  // ASH_CONTAINED_SHELL_MOCK_CONTAINED_SHELL_CLIENT_H
diff -BbuN a/ash/contained_shell/OWNERS b/ash/contained_shell/OWNERS
--- a/ash/contained_shell/OWNERS	1970-01-01 03:00:00.000000000 +0300
+++ b/ash/contained_shell/OWNERS	2019-05-17 18:53:08.136000000 +0300
@@ -0,0 +1,3 @@
+qnnguyen@chromium.org
+michaelpg@chromium.org
+jdufault@chromium.org
  a/ash/display/test_data/06af5c10.icc  b/ash/display/test_data/06af5c10.icc 
  a/ash/display/test_data/0dae3211.icc  b/ash/display/test_data/0dae3211.icc 
  a/ash/display/test_data/4c834a42.icc  b/ash/display/test_data/4c834a42.icc 
--- a/ash/drag_drop/drag_drop_interactive_uitest.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/ash/drag_drop/drag_drop_interactive_uitest.cc	2019-05-17 18:53:08.152000000 +0300
@@ -0,0 +1,147 @@
+// Copyright (c) 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ash/drag_drop/drag_drop_controller.h"
+
+#include "ash/shell.h"
+#include "ash/test/ash_interactive_ui_test_base.h"
+#include "base/bind.h"
+#include "base/run_loop.h"
+#include "base/strings/utf_string_conversions.h"
+#include "ui/aura/window_event_dispatcher.h"
+#include "ui/base/dragdrop/drag_drop_types.h"
+#include "ui/base/test/ui_controls.h"
+#include "ui/views/view.h"
+#include "ui/views/widget/widget.h"
+
+namespace ash {
+namespace {
+
+class DraggableView : public views::View {
+ public:
+  DraggableView() = default;
+  ~DraggableView() override = default;
+
+  // views::View overrides:
+  int GetDragOperations(const gfx::Point& press_pt) override {
+    return ui::DragDropTypes::DRAG_MOVE;
+  }
+  void WriteDragData(const gfx::Point& press_pt,
+                     OSExchangeData* data) override {
+    data->SetString(base::UTF8ToUTF16("test"));
+  }
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(DraggableView);
+};
+
+class TargetView : public views::View {
+ public:
+  TargetView() : dropped_(false) {}
+  ~TargetView() override = default;
+
+  // views::View overrides:
+  bool GetDropFormats(
+      int* formats,
+      std::set<ui::ClipboardFormatType>* format_types) override {
+    *formats = ui::OSExchangeData::STRING;
+    return true;
+  }
+  bool AreDropTypesRequired() override { return false; }
+  bool CanDrop(const OSExchangeData& data) override { return true; }
+  int OnDragUpdated(const ui::DropTargetEvent& event) override {
+    return ui::DragDropTypes::DRAG_MOVE;
+  }
+  int OnPerformDrop(const ui::DropTargetEvent& event) override {
+    dropped_ = true;
+    return ui::DragDropTypes::DRAG_MOVE;
+  }
+
+  bool dropped() const { return dropped_; }
+
+ private:
+  bool dropped_;
+
+  DISALLOW_COPY_AND_ASSIGN(TargetView);
+};
+
+views::Widget* CreateWidget(views::View* contents_view,
+                            const gfx::Rect& bounds,
+                            aura::Window* context) {
+  views::Widget* widget = new views::Widget;
+  views::Widget::InitParams params;
+  params.type = views::Widget::InitParams::TYPE_WINDOW_FRAMELESS;
+  params.accept_events = true;
+  params.bounds = bounds;
+  params.context = context;
+  widget->Init(params);
+
+  widget->SetContentsView(contents_view);
+  widget->Show();
+  return widget;
+}
+
+void QuitLoop() {
+  base::RunLoop::QuitCurrentWhenIdleDeprecated();
+}
+
+void DragDropAcrossMultiDisplay_Step4() {
+  ui_controls::SendMouseEventsNotifyWhenDone(ui_controls::LEFT, ui_controls::UP,
+                                             base::BindOnce(&QuitLoop));
+}
+
+void DragDropAcrossMultiDisplay_Step3() {
+  // Move to the edge of the 1st display so that the mouse
+  // is moved to 2nd display by ash.
+  ui_controls::SendMouseMoveNotifyWhenDone(
+      399, 10, base::BindOnce(&DragDropAcrossMultiDisplay_Step4));
+}
+
+void DragDropAcrossMultiDisplay_Step2() {
+  ui_controls::SendMouseMoveNotifyWhenDone(
+      20, 10, base::BindOnce(&DragDropAcrossMultiDisplay_Step3));
+}
+
+void DragDropAcrossMultiDisplay_Step1() {
+  ui_controls::SendMouseEventsNotifyWhenDone(
+      ui_controls::LEFT, ui_controls::DOWN,
+      base::BindOnce(&DragDropAcrossMultiDisplay_Step2));
+}
+
+}  // namespace
+
+using DragDropTest = AshInteractiveUITestBase;
+
+// Test if the mouse gets moved properly to another display
+// during drag & drop operation.
+TEST_F(DragDropTest, DragDropAcrossMultiDisplay) {
+  UpdateDisplay("400x400,400x400");
+  aura::Window::Windows root_windows = Shell::Get()->GetAllRootWindows();
+  views::View* draggable_view = new DraggableView();
+  draggable_view->set_drag_controller(NULL);
+  draggable_view->SetBounds(0, 0, 100, 100);
+  views::Widget* source =
+      CreateWidget(draggable_view, gfx::Rect(0, 0, 100, 100), CurrentContext());
+
+  TargetView* target_view = new TargetView();
+  target_view->SetBounds(0, 0, 100, 100);
+  views::Widget* target =
+      CreateWidget(target_view, gfx::Rect(400, 0, 100, 100), CurrentContext());
+
+  // Make sure they're on the different root windows.
+  EXPECT_EQ(root_windows[0], source->GetNativeView()->GetRootWindow());
+  EXPECT_EQ(root_windows[1], target->GetNativeView()->GetRootWindow());
+
+  ui_controls::SendMouseMoveNotifyWhenDone(
+      10, 10, base::BindOnce(&DragDropAcrossMultiDisplay_Step1));
+
+  base::RunLoop().Run();
+
+  EXPECT_TRUE(target_view->dropped());
+
+  source->Close();
+  target->Close();
+}
+
+}  // namespace ash
--- a/ash/manifest.json	1970-01-01 03:00:00.000000000 +0300
+++ b/ash/manifest.json	2019-05-17 18:53:08.184000000 +0300
@@ -0,0 +1,93 @@
+{
+  "name": "ash",
+  "display_name": "Ash Window Manager and Shell",
+  "sandbox_type": "none",
+  "options" : {
+    "instance_sharing" : "singleton"
+  },
+  "interface_provider_specs": {
+    "service_manager:connector": {
+      "provides": {
+        // Modifications here should correspond with changes to
+        // chrome_content_browser_manifest_overlay.json.
+        "system_ui": [
+          "app_list.mojom.AppList",
+          "ash.mojom.AcceleratorController",
+          "ash.mojom.AccessibilityController",
+          "ash.mojom.AccessibilityFocusRingController",
+          "ash.mojom.AppListController",
+          "ash.mojom.AshMessageCenterController",
+          "ash.mojom.AssistantAlarmTimerController",
+          "ash.mojom.AssistantController",
+          "ash.mojom.AssistantNotificationController",
+          "ash.mojom.AssistantScreenContextController",
+          "ash.mojom.AssistantSetupController",
+          "ash.mojom.AssistantVolumeControl",
+          "ash.mojom.CastConfig",
+          "ash.mojom.ContainedShellController",
+          "ash.mojom.CrosDisplayConfigController",
+          "ash.mojom.DockedMagnifierController",
+          "ash.mojom.EventRewriterController",
+          "ash.mojom.FirstRunHelper",
+          "ash.mojom.HighlighterController",
+          "ash.mojom.ImeController",
+          "ash.mojom.KeyboardController",
+          "ash.mojom.LocaleUpdateController",
+          "ash.mojom.LoginScreen",
+          "ash.mojom.MediaController",
+          "ash.mojom.NewWindowController",
+          "ash.mojom.NightLightController",
+          "ash.mojom.NoteTakingController",
+          "ash.mojom.ProcessCreationTimeRecorder",
+          "ash.mojom.SessionController",
+          "ash.mojom.ShelfController",
+          "ash.mojom.ShellState",
+          "ash.mojom.ShutdownController",
+          "ash.mojom.SplitViewController",
+          "ash.mojom.SystemTray",
+          "ash.mojom.TabletModeController",
+          "ash.mojom.TrayAction",
+          "ash.mojom.VoiceInteractionController",
+          "ash.mojom.VpnList",
+          "ash.mojom.WallpaperController"
+        ],
+        // Test-only interfaces.
+        "test": [
+          "ash.mojom.LoginScreenTestApi",
+          "ash.mojom.ShelfTestApi",
+          "ash.mojom.ShellTestApi",
+          "ash.mojom.StatusAreaWidgetTestApi",
+          "ash.mojom.SystemTrayTestApi",
+          "ash.mojom.TimeToFirstPresentRecorderTestApi"
+        ],
+        // Only chrome is allowed to use this (required as dbus runs in Chrome).
+        "display": [
+          "ash.mojom.AshDisplayController",
+          "ash.mojom.DisplayOutputProtection"
+        ],
+        "mus:window_manager": [ "ui.mojom.AcceleratorRegistrar" ],
+        "service_manager:service_factory": [
+          "service_manager.mojom.ServiceFactory"
+        ]
+      },
+      "requires": {
+        "*": [ "accessibility", "app" ],
+        "ash_pref_connector": [ "pref_connector" ],
+        "catalog": [ "directory" ],
+        "content": [ "navigation" ],
+        "device": [
+          "device:bluetooth_system",
+          "device:fingerprint"
+        ],
+        "local_state": [ "pref_client" ],
+        "multidevice_setup": [ "multidevice_setup" ],
+        "ui": [
+          "ozone",
+          "window_manager"
+        ],
+        "data_decoder": [ "image_decoder" ],
+        "viz": [ "viz_host" ]
+      }
+    }
+  }
+}
--- a/ash/public/cpp/app_list/app_list_constants.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/ash/public/cpp/app_list/app_list_constants.cc	2019-05-17 18:53:08.192000000 +0300
@@ -0,0 +1,215 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ash/public/cpp/app_list/app_list_constants.h"
+
+#include "build/build_config.h"
+#include "ui/gfx/color_palette.h"
+
+namespace app_list {
+
+const SkColor kContentsBackgroundColor = SkColorSetRGB(0xF2, 0xF2, 0xF2);
+
+// Color of bottom separtor under folder title (12% white) in full screen mode.
+const SkColor kBottomSeparatorColor = SkColorSetARGB(0x1F, 0xFF, 0xFF, 0xFF);
+
+// The color of the separator used inside dialogs in the app list.
+const SkColor kDialogSeparatorColor = SkColorSetRGB(0xD1, 0xD1, 0xD1);
+
+// The mouse hover colour (3% black).
+const SkColor kHighlightedColor = SkColorSetARGB(8, 0, 0, 0);
+// The keyboard select color for grid views, which are on top of a black shield
+// view for new design (12% white).
+const SkColor kGridSelectedColor = SkColorSetARGB(0x1F, 0xFF, 0xFF, 0xFF);
+// Selection color for answer card (3% black).
+const SkColor kAnswerCardSelectedColor = SkColorSetARGB(0x08, 0x00, 0x00, 0x00);
+
+const SkColor kPagerHoverColor = SkColorSetRGB(0xB4, 0xB4, 0xB4);
+const SkColor kPagerNormalColor = SkColorSetRGB(0xE2, 0xE2, 0xE2);
+const SkColor kPagerSelectedColor = SkColorSetRGB(0x46, 0x8F, 0xFC);
+
+// The preferred height for horizontal pages. For page #01 in the apps grid, it
+// includes the top/bottom 24px padding. For page #02 and all the followings,
+// it includes top 24px padding and bottom 56px padding.
+const int kHorizontalPagePreferredHeight = 623;
+
+const SkColor kFolderTitleColor = gfx::kGoogleGrey700;
+const SkColor kFolderTitleHintTextColor = SkColorSetRGB(0xA0, 0xA0, 0xA0);
+// Color of the folder bubble shadow.
+const SkColor kFolderShadowColor = SkColorSetRGB(0xBF, 0xBF, 0xBF);
+const float kFolderBubbleOpacity = 0.12f;
+
+const SkColor kCardBackgroundColor = SK_ColorWHITE;
+
+// Duration in milliseconds for page transition.
+const int kPageTransitionDurationInMs = 250;
+
+// Dampening value for PaginationModel's SlideAnimation.
+const int kPageTransitionDurationDampening = 3;
+
+// Duration in milliseconds for over scroll page transition.
+const int kOverscrollPageTransitionDurationMs = 50;
+
+// Duration in milliseconds for fading in the target page when opening
+// or closing a folder, and the duration for the top folder icon animation
+// for flying in or out the folder.
+const int kFolderTransitionInDurationMs = 250;
+
+// Duration in milliseconds for fading out the old page when opening or closing
+// a folder.
+const int kFolderTransitionOutDurationMs = 30;
+
+// The height of the custom page widget when collapsed on the start page.
+const int kCustomPageCollapsedHeight = 78;
+
+// Animation curve used for fading in the target page when opening or closing
+// a folder.
+const gfx::Tween::Type kFolderFadeInTweenType = gfx::Tween::EASE_IN_2;
+
+// Animation curve used for fading out the target page when opening or closing
+// a folder.
+const gfx::Tween::Type kFolderFadeOutTweenType = gfx::Tween::FAST_OUT_LINEAR_IN;
+
+// The number of apps shown in the start page app grid.
+const int kNumStartPageTiles = 5;
+
+// Maximum number of results to show in the launcher Search UI.
+const size_t kMaxSearchResults = 6;
+
+// Radius of the circle, in which if entered, show re-order preview.
+const int kReorderDroppingCircleRadius = 35;
+
+// The padding around the outside of the apps grid (sides).
+const int kAppsGridPadding = 24;
+
+// The left and right side padding of the apps grid. The
+// space is used for page switcher and its padding on the right side. Left side
+// should have the same space to keep the apps grid horizontally centered.
+const int kAppsGridLeftRightPadding = 40;
+
+// The left and right padding from the folder name bottom separator to the edge
+// of the left or right edge of the left most and right most app item.
+const int kBottomSeparatorLeftRightPadding = 24;
+
+// The bottom padding from the bottom separator to the top of the app item.
+const int kBottomSeparatorBottomPadding = 24;
+
+// Bottom padding of search box in peeking state.
+const int kSearchBoxPeekingBottomPadding = 12;
+
+// Bottom padding of search box.
+const int kSearchBoxBottomPadding = 24;
+
+// Max pages allowed in a folder.
+const size_t kMaxFolderPages = 3;
+
+// Max items per page allowed in a folder.
+const size_t kMaxFolderItemsPerPage = 16;
+
+// Maximum length of the folder name in chars.
+const size_t kMaxFolderNameChars = 28;
+
+// Font style for app item labels.
+const ui::ResourceBundle::FontStyle kItemTextFontStyle =
+    ui::ResourceBundle::SmallFont;
+
+// Range of the height of centerline above screen bottom that all apps should
+// change opacity. NOTE: this is used to change page switcher's opacity as well.
+const float kAllAppsOpacityStartPx = 8.0f;
+const float kAllAppsOpacityEndPx = 144.0f;
+
+// Delta applied to font size of all AppListSearchResult titles.
+const int kSearchResultTitleTextSizeDelta = 2;
+
+// Font style for AppListSearchResultTileItemViews that are not suggested apps.
+const ui::ResourceBundle::FontStyle kSearchResultTitleFontStyle =
+    ui::ResourceBundle::BaseFont;
+
+// The UMA histogram that logs usage of suggested and regular apps.
+const char kAppListAppLaunched[] = "Apps.AppListAppLaunched";
+
+// The UMA histogram that logs usage of suggested and regular apps while the
+// fullscreen launcher is enabled.
+const char kAppListAppLaunchedFullscreen[] =
+    "Apps.AppListAppLaunchedFullscreen";
+
+// The UMA histogram that logs different ways to move an app in app list's apps
+// grid.
+const char kAppListAppMovingType[] = "Apps.AppListAppMovingType";
+
+// The UMA histogram that logs the creation time of the AppListView.
+const char kAppListCreationTimeHistogram[] = "Apps.AppListCreationTime";
+
+// The UMA histogram that logs usage of state transitions in the new
+// app list UI.
+const char kAppListStateTransitionSourceHistogram[] =
+    "Apps.AppListStateTransitionSource";
+
+// The UMA histogram that logs the source of vertical page switcher usage in the
+// app list.
+const char kAppListPageSwitcherSourceHistogram[] =
+    "Apps.AppListPageSwitcherSource";
+
+// The UMA histogram that logs usage of the original and redesigned folders.
+const char kAppListFolderOpenedHistogram[] = "Apps.AppListFolderOpened";
+
+// The UMA histogram that logs how the app list transitions from peeking to
+// fullscreen.
+const char kAppListPeekingToFullscreenHistogram[] =
+    "Apps.AppListPeekingToFullscreenSource";
+
+// The UMA histogram that logs how the app list is shown.
+const char kAppListToggleMethodHistogram[] = "Apps.AppListShowSource";
+
+// The UMA histogram that logs which page gets opened by the user.
+const char kPageOpenedHistogram[] = "Apps.AppListPageOpened";
+
+// The UMA histogram that logs how many apps users have in folders.
+const char kNumberOfAppsInFoldersHistogram[] =
+    "Apps.AppsInFolders.FullscreenAppListEnabled";
+
+// The UMA histogram that logs how many folders users have.
+const char kNumberOfFoldersHistogram[] = "Apps.NumberOfFolders";
+
+// The UMA histogram that logs how many pages users have in top level apps grid.
+const char kNumberOfPagesHistogram[] = "Apps.NumberOfPages";
+
+// The UMA histogram that logs how many pages with empty slots users have in top
+// level apps grid.
+const char kNumberOfPagesNotFullHistogram[] = "Apps.NumberOfPagesNotFull";
+
+// The UMA histogram that logs the type of search result opened.
+const char kSearchResultOpenDisplayTypeHistogram[] =
+    "Apps.AppListSearchResultOpenDisplayType";
+
+// The UMA histogram that logs how long the search query was when a result was
+// opened.
+const char kSearchQueryLength[] = "Apps.AppListSearchQueryLength";
+
+// The UMA histogram that logs the Manhattan distance from the origin of the
+// search results to the selected result.
+const char kSearchResultDistanceFromOrigin[] =
+    "Apps.AppListSearchResultDistanceFromOrigin";
+
+// The height of tiles in search result.
+const int kSearchTileHeight = 92;
+
+gfx::ShadowValue GetShadowForZHeight(int z_height) {
+  if (z_height <= 0)
+    return gfx::ShadowValue();
+
+  switch (z_height) {
+    case 1:
+      return gfx::ShadowValue(gfx::Vector2d(0, 1), 4,
+                              SkColorSetARGB(0x4C, 0, 0, 0));
+    case 2:
+      return gfx::ShadowValue(gfx::Vector2d(0, 2), 8,
+                              SkColorSetARGB(0x33, 0, 0, 0));
+    default:
+      return gfx::ShadowValue(gfx::Vector2d(0, 8), 24,
+                              SkColorSetARGB(0x3F, 0, 0, 0));
+  }
+}
+
+}  // namespace app_list
--- a/ash/public/cpp/app_list/app_list_constants.h	1970-01-01 03:00:00.000000000 +0300
+++ b/ash/public/cpp/app_list/app_list_constants.h	2019-05-17 18:53:08.192000000 +0300
@@ -0,0 +1,180 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef ASH_PUBLIC_CPP_APP_LIST_APP_LIST_CONSTANTS_H_
+#define ASH_PUBLIC_CPP_APP_LIST_APP_LIST_CONSTANTS_H_
+
+#include <stddef.h>
+
+#include "ash/public/cpp/app_list/app_list_types.h"
+#include "ash/public/cpp/ash_public_export.h"
+#include "build/build_config.h"
+#include "third_party/skia/include/core/SkColor.h"
+#include "ui/base/resource/resource_bundle.h"
+#include "ui/gfx/animation/tween.h"
+#include "ui/gfx/shadow_value.h"
+
+namespace app_list {
+
+// TODO(crbug.com/854836): Move everything here to app_list_config.h.
+ASH_PUBLIC_EXPORT extern const SkColor kContentsBackgroundColor;
+
+ASH_PUBLIC_EXPORT extern const SkColor kBottomSeparatorColor;
+ASH_PUBLIC_EXPORT extern const SkColor kDialogSeparatorColor;
+
+ASH_PUBLIC_EXPORT extern const SkColor kHighlightedColor;
+ASH_PUBLIC_EXPORT extern const SkColor kGridSelectedColor;
+ASH_PUBLIC_EXPORT extern const SkColor kAnswerCardSelectedColor;
+
+ASH_PUBLIC_EXPORT extern const SkColor kPagerHoverColor;
+ASH_PUBLIC_EXPORT extern const SkColor kPagerNormalColor;
+ASH_PUBLIC_EXPORT extern const SkColor kPagerSelectedColor;
+
+ASH_PUBLIC_EXPORT extern const int kHorizontalPagePreferredHeight;
+
+ASH_PUBLIC_EXPORT extern const SkColor kFolderTitleColor;
+ASH_PUBLIC_EXPORT extern const SkColor kFolderTitleHintTextColor;
+ASH_PUBLIC_EXPORT extern const SkColor kFolderShadowColor;
+ASH_PUBLIC_EXPORT extern const float kFolderBubbleOpacity;
+
+ASH_PUBLIC_EXPORT extern const SkColor kCardBackgroundColor;
+
+ASH_PUBLIC_EXPORT extern const int kPageTransitionDurationInMs;
+ASH_PUBLIC_EXPORT extern const int kPageTransitionDurationDampening;
+ASH_PUBLIC_EXPORT extern const int kOverscrollPageTransitionDurationMs;
+ASH_PUBLIC_EXPORT extern const int kFolderTransitionInDurationMs;
+ASH_PUBLIC_EXPORT extern const int kFolderTransitionOutDurationMs;
+ASH_PUBLIC_EXPORT extern const int kCustomPageCollapsedHeight;
+ASH_PUBLIC_EXPORT extern const gfx::Tween::Type kFolderFadeInTweenType;
+ASH_PUBLIC_EXPORT extern const gfx::Tween::Type kFolderFadeOutTweenType;
+
+ASH_PUBLIC_EXPORT extern const int kNumStartPageTiles;
+ASH_PUBLIC_EXPORT extern const size_t kMaxSearchResults;
+
+ASH_PUBLIC_EXPORT extern const int kReorderDroppingCircleRadius;
+
+ASH_PUBLIC_EXPORT extern const int kAppsGridPadding;
+ASH_PUBLIC_EXPORT extern const int kAppsGridLeftRightPadding;
+ASH_PUBLIC_EXPORT extern const int kBottomSeparatorLeftRightPadding;
+ASH_PUBLIC_EXPORT extern const int kBottomSeparatorBottomPadding;
+ASH_PUBLIC_EXPORT extern const int kSearchBoxPeekingBottomPadding;
+ASH_PUBLIC_EXPORT extern const int kSearchBoxBottomPadding;
+
+ASH_PUBLIC_EXPORT extern const size_t kMaxFolderPages;
+ASH_PUBLIC_EXPORT extern const size_t kMaxFolderItemsPerPage;
+ASH_PUBLIC_EXPORT extern const size_t kMaxFolderNameChars;
+
+ASH_PUBLIC_EXPORT extern const ui::ResourceBundle::FontStyle kItemTextFontStyle;
+
+ASH_PUBLIC_EXPORT extern const float kAllAppsOpacityStartPx;
+ASH_PUBLIC_EXPORT extern const float kAllAppsOpacityEndPx;
+
+ASH_PUBLIC_EXPORT extern const int kSearchResultTitleTextSizeDelta;
+ASH_PUBLIC_EXPORT extern const ui::ResourceBundle::FontStyle
+    kSearchResultTitleFontStyle;
+
+// The different ways that the app list can transition from PEEKING to
+// FULLSCREEN_ALL_APPS. These values are written to logs.  New enum
+// values can be added, but existing enums must never be renumbered or deleted
+// and reused.
+enum AppListPeekingToFullscreenSource {
+  kSwipe = 0,
+  kExpandArrow = 1,
+  kMousepadScroll = 2,
+  kMousewheelScroll = 3,
+  kMaxPeekingToFullscreen = 4,
+};
+
+// The different ways the app list can be shown. These values are written to
+// logs.  New enum values can be added, but existing enums must never be
+// renumbered or deleted and reused.
+enum AppListShowSource {
+  kSearchKey = 0,
+  kShelfButton = 1,
+  kSwipeFromShelf = 2,
+  kTabletMode = 3,
+  kMaxAppListToggleMethod = 4,
+};
+
+// The two versions of folders. These values are written to logs.  New enum
+// values can be added, but existing enums must never be renumbered or deleted
+// and reused.
+enum AppListFolderOpened {
+  kOldFolders = 0,
+  kFullscreenAppListFolders = 1,
+  kMaxFolderOpened = 2,
+};
+
+// The valid AppListState transitions. These values are written to logs.  New
+// enum values can be added, but existing enums must never be renumbered or
+// deleted and reused. If adding a state transition, add it to the switch
+// statement in AppListView::GetAppListStateTransitionSource.
+enum AppListStateTransitionSource {
+  kFullscreenAllAppsToClosed = 0,
+  kFullscreenAllAppsToFullscreenSearch = 1,
+  kFullscreenAllAppsToPeeking = 2,
+  kFullscreenSearchToClosed = 3,
+  kFullscreenSearchToFullscreenAllApps = 4,
+  kHalfToClosed = 5,
+  KHalfToFullscreenSearch = 6,
+  kHalfToPeeking = 7,
+  kPeekingToClosed = 8,
+  kPeekingToFullscreenAllApps = 9,
+  kPeekingToHalf = 10,
+  kMaxAppListStateTransition = 11,
+};
+
+// The different ways to change pages in the app list's app grid. These values
+// are written to logs.  New enum values can be added, but existing enums must
+// never be renumbered or deleted and reused.
+enum AppListPageSwitcherSource {
+  kTouchPageIndicator = 0,
+  kClickPageIndicator = 1,
+  kSwipeAppGrid = 2,
+  kFlingAppGrid = 3,
+  kMouseWheelScroll = 4,
+  kMousePadScroll = 5,
+  kDragAppToBorder = 6,
+  kMaxAppListPageSwitcherSource = 7,
+};
+
+// The different ways to move an app in app list's apps grid. These values are
+// written to logs. New enum values can be added, but existing enums must never
+// be renumbered or deleted and reused.
+enum AppListAppMovingType {
+  kMoveIntoFolder = 0,
+  kMoveOutOfFolder = 1,
+  kMoveIntoAnotherFolder = 2,
+  kReorderInFolder = 3,
+  kReorderInTopLevel = 4,
+  kMaxAppListAppMovingType = 5,
+};
+
+ASH_PUBLIC_EXPORT extern const char kAppListAppLaunched[];
+ASH_PUBLIC_EXPORT extern const char kAppListAppLaunchedFullscreen[];
+ASH_PUBLIC_EXPORT extern const char kAppListAppMovingType[];
+ASH_PUBLIC_EXPORT extern const char kAppListCreationTimeHistogram[];
+ASH_PUBLIC_EXPORT extern const char kAppListStateTransitionSourceHistogram[];
+ASH_PUBLIC_EXPORT extern const char kAppListPageSwitcherSourceHistogram[];
+ASH_PUBLIC_EXPORT extern const char kAppListFolderOpenedHistogram[];
+ASH_PUBLIC_EXPORT extern const char kAppListPeekingToFullscreenHistogram[];
+ASH_PUBLIC_EXPORT extern const char kAppListToggleMethodHistogram[];
+ASH_PUBLIC_EXPORT extern const char kPageOpenedHistogram[];
+ASH_PUBLIC_EXPORT extern const char kNumberOfAppsInFoldersHistogram[];
+ASH_PUBLIC_EXPORT extern const char kNumberOfFoldersHistogram[];
+ASH_PUBLIC_EXPORT extern const char kNumberOfPagesHistogram[];
+ASH_PUBLIC_EXPORT extern const char kNumberOfPagesNotFullHistogram[];
+
+ASH_PUBLIC_EXPORT extern const char kSearchResultOpenDisplayTypeHistogram[];
+ASH_PUBLIC_EXPORT extern const char kSearchQueryLength[];
+ASH_PUBLIC_EXPORT extern const char kSearchResultDistanceFromOrigin[];
+
+ASH_PUBLIC_EXPORT extern const int kSearchTileHeight;
+
+// Returns the shadow values for a view at |z_height|.
+ASH_PUBLIC_EXPORT gfx::ShadowValue GetShadowForZHeight(int z_height);
+
+}  // namespace app_list
+
+#endif  // ASH_PUBLIC_CPP_APP_LIST_APP_LIST_CONSTANTS_H_
--- a/ash/public/interfaces/contained_shell.mojom	1970-01-01 03:00:00.000000000 +0300
+++ b/ash/public/interfaces/contained_shell.mojom	2019-05-17 18:53:08.212000000 +0300
@@ -0,0 +1,23 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+module ash.mojom;
+
+import "components/account_id/interfaces/account_id.mojom";
+
+// Performs browser-side functionality for the ContainedShell feature,
+// e.g. launching a WebView to host the ContainedShell.
+interface ContainedShellClient {
+  // Launch a contained shell experience for the current user, identified by
+  // |account_id|.
+  LaunchContainedShell(signin.mojom.AccountId account_id);
+};
+
+// Allows Ash and its consumers to interact with the ContainedShell
+// feature, e.g. by requesting to launch the ContainedShell WebView.
+// These requests are forwarded to the ContainedShellClient.
+interface ContainedShellController {
+  // Provides a client for dispatching requests.
+  SetClient(ContainedShellClient client);
+};
--- a/ash/resources/vector_icons/shelf_parent_access_button.icon	1970-01-01 03:00:00.000000000 +0300
+++ b/ash/resources/vector_icons/shelf_parent_access_button.icon	2019-05-17 18:53:08.224000000 +0300
@@ -0,0 +1,71 @@
+CANVAS_DIMENSIONS, 40,
+MOVE_TO, 30, 13.33f,
+R_H_LINE_TO, -1.67f,
+V_LINE_TO, 10,
+R_CUBIC_TO, 0, -4.6f, -3.73f, -8.33f, -8.33f, -8.33f,
+ARC_TO, 8.34f, 8.34f, 0, 0, 0, 11.67f, 10,
+R_V_LINE_TO, 3.33f,
+H_LINE_TO, 10,
+R_ARC_TO, 3.34f, 3.34f, 0, 0, 0, -3.33f, 3.33f,
+R_V_LINE_TO, 16.67f,
+R_CUBIC_TO, 0, 1.83f, 1.5f, 3.33f, 3.33f, 3.33f,
+R_H_LINE_TO, 20,
+R_CUBIC_TO, 1.83f, 0, 3.33f, -1.5f, 3.33f, -3.33f,
+V_LINE_TO, 16.67f,
+R_CUBIC_TO, 0, -1.83f, -1.5f, -3.33f, -3.33f, -3.33f,
+CLOSE,
+MOVE_TO, 15, 10,
+R_CUBIC_TO, 0, -2.77f, 2.23f, -5, 5, -5,
+R_CUBIC_TO, 2.77f, 0, 5, 2.23f, 5, 5,
+R_V_LINE_TO, 3.33f,
+H_LINE_TO, 15,
+V_LINE_TO, 10,
+CLOSE,
+R_MOVE_TO, 15, 23.33f,
+H_LINE_TO, 10,
+V_LINE_TO, 16.67f,
+R_H_LINE_TO, 20,
+R_V_LINE_TO, 16.67f,
+CLOSE,
+R_MOVE_TO, -10, -5,
+R_CUBIC_TO, 1.83f, 0, 3.33f, -1.5f, 3.33f, -3.33f,
+R_CUBIC_TO, 0, -1.83f, -1.5f, -3.33f, -3.33f, -3.33f,
+ARC_TO, 3.34f, 3.34f, 0, 0, 0, 16.67f, 25,
+R_CUBIC_TO, 0, 1.83f, 1.5f, 3.33f, 3.33f, 3.33f,
+CLOSE
+
+CANVAS_DIMENSIONS, 20,
+MOVE_TO, 15, 6.67f,
+R_H_LINE_TO, -0.83f,
+V_LINE_TO, 5,
+CUBIC_TO, 14.17f, 2.7f, 12.3f, 0.83f, 10, 0.83f,
+ARC_TO, 4.17f, 4.17f, 0, 0, 0, 5.83f, 5,
+R_V_LINE_TO, 1.67f,
+H_LINE_TO, 5,
+R_CUBIC_TO, -0.92f, 0, -1.67f, 0.75f, -1.67f, 1.67f,
+R_V_LINE_TO, 8.33f,
+R_CUBIC_TO, 0, 0.92f, 0.75f, 1.67f, 1.67f, 1.67f,
+R_H_LINE_TO, 10,
+R_CUBIC_TO, 0.92f, 0, 1.67f, -0.75f, 1.67f, -1.67f,
+V_LINE_TO, 8.33f,
+R_CUBIC_TO, 0, -0.92f, -0.75f, -1.67f, -1.67f, -1.67f,
+CLOSE,
+MOVE_TO, 7.5f, 5,
+R_CUBIC_TO, 0, -1.38f, 1.12f, -2.5f, 2.5f, -2.5f,
+R_CUBIC_TO, 1.38f, 0, 2.5f, 1.12f, 2.5f, 2.5f,
+R_V_LINE_TO, 1.67f,
+R_H_LINE_TO, -5,
+V_LINE_TO, 5,
+CLOSE,
+MOVE_TO, 15, 16.67f,
+H_LINE_TO, 5,
+V_LINE_TO, 8.33f,
+R_H_LINE_TO, 10,
+R_V_LINE_TO, 8.33f,
+CLOSE,
+R_MOVE_TO, -5, -2.5f,
+R_CUBIC_TO, 0.92f, 0, 1.67f, -0.75f, 1.67f, -1.67f,
+R_CUBIC_TO, 0, -0.92f, -0.75f, -1.67f, -1.67f, -1.67f,
+R_CUBIC_TO, -0.92f, 0, -1.67f, 0.75f, -1.67f, 1.67f,
+R_CUBIC_TO, 0, 0.92f, 0.75f, 1.67f, 1.67f, 1.67f,
+CLOSE
--- a/ash/shell/app_list.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/ash/shell/app_list.cc	2019-05-17 18:53:08.252000000 +0300
@@ -0,0 +1,351 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include <memory>
+#include <string>
+#include <utility>
+#include <vector>
+
+#include "ash/app_list/app_list_controller_impl.h"
+#include "ash/app_list/app_list_view_delegate.h"
+#include "ash/app_list/model/app_list_item.h"
+#include "ash/app_list/model/app_list_item_list.h"
+#include "ash/app_list/model/app_list_model.h"
+#include "ash/app_list/model/search/search_box_model.h"
+#include "ash/app_list/model/search/search_model.h"
+#include "ash/app_list/model/search/search_result.h"
+#include "ash/session/session_controller.h"
+#include "ash/shell.h"
+#include "ash/shell/example_factory.h"
+#include "ash/shell/toplevel_window.h"
+#include "base/bind_helpers.h"
+#include "base/callback.h"
+#include "base/files/file_path.h"
+#include "base/i18n/case_conversion.h"
+#include "base/i18n/string_search.h"
+#include "base/stl_util.h"
+#include "base/strings/string_number_conversions.h"
+#include "base/strings/string_util.h"
+#include "base/strings/utf_string_conversions.h"
+#include "ui/gfx/canvas.h"
+#include "ui/gfx/font_list.h"
+#include "ui/gfx/geometry/rect.h"
+#include "ui/gfx/image/image_skia.h"
+#include "ui/views/examples/example_base.h"
+#include "ui/views/examples/examples_window.h"
+
+namespace ash {
+namespace shell {
+
+namespace {
+
+// WindowTypeShelfItem is an app item of app list. It carries a window
+// launch type and launches corresponding example window when activated.
+class WindowTypeShelfItem : public app_list::AppListItem {
+ public:
+  enum Type {
+    TOPLEVEL_WINDOW = 0,
+    NON_RESIZABLE_WINDOW,
+    LOCK_SCREEN,
+    WIDGETS_WINDOW,
+    EXAMPLES_WINDOW,
+    LAST_TYPE,
+  };
+
+  WindowTypeShelfItem(const std::string& id, Type type);
+  ~WindowTypeShelfItem() override;
+
+  static gfx::ImageSkia GetIcon(Type type) {
+    static const SkColor kColors[] = {
+        SK_ColorRED, SK_ColorGREEN, SK_ColorBLUE, SK_ColorYELLOW, SK_ColorCYAN,
+    };
+
+    const int kIconSize = 128;
+    SkBitmap icon;
+    icon.allocN32Pixels(kIconSize, kIconSize);
+    icon.eraseColor(kColors[static_cast<int>(type) % base::size(kColors)]);
+    return gfx::ImageSkia::CreateFrom1xBitmap(icon);
+  }
+
+  // The text below is not localized as this is an example code.
+  static std::string GetTitle(Type type) {
+    switch (type) {
+      case TOPLEVEL_WINDOW:
+        return "Create Window";
+      case NON_RESIZABLE_WINDOW:
+        return "Create Non-Resizable Window";
+      case LOCK_SCREEN:
+        return "Lock Screen";
+      case WIDGETS_WINDOW:
+        return "Show Example Widgets";
+      case EXAMPLES_WINDOW:
+        return "Open Views Examples Window";
+      default:
+        return "Unknown window type.";
+    }
+  }
+
+  // The text below is not localized as this is an example code.
+  static std::string GetDetails(Type type) {
+    // Assigns details only to some types so that we see both one-line
+    // and two-line results.
+    switch (type) {
+      case WIDGETS_WINDOW:
+        return "Creates a window to show example widgets";
+      case EXAMPLES_WINDOW:
+        return "Creates a window to show views example.";
+      default:
+        return std::string();
+    }
+  }
+
+  static void ActivateItem(Type type, int event_flags) {
+    switch (type) {
+      case TOPLEVEL_WINDOW: {
+        ToplevelWindow::CreateParams params;
+        params.can_resize = true;
+        ToplevelWindow::CreateToplevelWindow(params);
+        break;
+      }
+      case NON_RESIZABLE_WINDOW: {
+        ToplevelWindow::CreateToplevelWindow(ToplevelWindow::CreateParams());
+        break;
+      }
+      case LOCK_SCREEN: {
+        Shell::Get()->session_controller()->LockScreen();
+        break;
+      }
+      case WIDGETS_WINDOW: {
+        CreateWidgetsWindow();
+        break;
+      }
+      case EXAMPLES_WINDOW: {
+        views::examples::ShowExamplesWindow(base::DoNothing());
+        break;
+      }
+      default:
+        break;
+    }
+  }
+
+  void Activate(int event_flags) { ActivateItem(type_, event_flags); }
+
+ private:
+  Type type_;
+
+  DISALLOW_COPY_AND_ASSIGN(WindowTypeShelfItem);
+};
+
+WindowTypeShelfItem::WindowTypeShelfItem(const std::string& id, Type type)
+    : app_list::AppListItem(id), type_(type) {
+  std::string title(GetTitle(type));
+  SetIcon(GetIcon(type));
+  SetName(title);
+}
+
+WindowTypeShelfItem::~WindowTypeShelfItem() = default;
+
+// ExampleSearchResult is an app list search result. It provides what icon to
+// show, what should title and details text look like. It also carries the
+// matching window launch type so that AppListViewDelegate knows how to open
+// it.
+class ExampleSearchResult : public app_list::SearchResult {
+ public:
+  ExampleSearchResult(WindowTypeShelfItem::Type type,
+                      const base::string16& query)
+      : type_(type) {
+    SetIcon(WindowTypeShelfItem::GetIcon(type_));
+
+    base::string16 title =
+        base::UTF8ToUTF16(WindowTypeShelfItem::GetTitle(type_));
+    set_title(title);
+
+    Tags title_tags;
+    const size_t match_len = query.length();
+
+    // Highlight matching parts in title with bold.
+    // Note the following is not a proper way to handle i18n string.
+    title = base::i18n::ToLower(title);
+    size_t match_start = title.find(query);
+    while (match_start != base::string16::npos) {
+      title_tags.push_back(
+          Tag(Tag::MATCH, match_start, match_start + match_len));
+      match_start = title.find(query, match_start + match_len);
+    }
+    set_title_tags(title_tags);
+
+    base::string16 details =
+        base::UTF8ToUTF16(WindowTypeShelfItem::GetDetails(type_));
+    set_details(details);
+    Tags details_tags;
+    details_tags.push_back(Tag(Tag::DIM, 0, details.length()));
+    set_details_tags(details_tags);
+  }
+
+  WindowTypeShelfItem::Type type() const { return type_; }
+
+ private:
+  WindowTypeShelfItem::Type type_;
+
+  DISALLOW_COPY_AND_ASSIGN(ExampleSearchResult);
+};
+
+class ExampleAppListViewDelegate : public app_list::AppListViewDelegate {
+ public:
+  ExampleAppListViewDelegate()
+      : model_(std::make_unique<app_list::AppListModel>()),
+        search_model_(std::make_unique<app_list::SearchModel>()) {
+    PopulateApps();
+    DecorateSearchBox(search_model_->search_box());
+  }
+
+ private:
+  void PopulateApps() {
+    for (int i = 0; i < static_cast<int>(WindowTypeShelfItem::LAST_TYPE); ++i) {
+      WindowTypeShelfItem::Type type =
+          static_cast<WindowTypeShelfItem::Type>(i);
+      std::string id = base::IntToString(i);
+      std::unique_ptr<WindowTypeShelfItem> shelf_item(
+          new WindowTypeShelfItem(id, type));
+      model_->AddItem(std::move(shelf_item));
+    }
+  }
+
+  void DecorateSearchBox(app_list::SearchBoxModel* search_box_model) {
+    search_box_model->SetHintText(base::ASCIIToUTF16("Type to search..."));
+  }
+
+  // Overridden from app_list::AppListViewDelegate:
+  app_list::AppListModel* GetModel() override { return model_.get(); }
+
+  app_list::SearchModel* GetSearchModel() override {
+    return search_model_.get();
+  }
+
+  void OpenSearchResult(const std::string& result_id,
+                        int event_flags) override {
+    const ExampleSearchResult* example_result =
+        static_cast<const ExampleSearchResult*>(
+            search_model_->FindSearchResult(result_id));
+    WindowTypeShelfItem::ActivateItem(example_result->type(), event_flags);
+  }
+
+  void InvokeSearchResultAction(const std::string& result_id,
+                                int action_index,
+                                int event_flags) override {
+    NOTIMPLEMENTED();
+  }
+
+  void StartAssistant() override { NOTIMPLEMENTED(); }
+
+  void StartSearch(const base::string16& raw_query) override {
+    base::string16 query;
+    base::TrimWhitespace(raw_query, base::TRIM_ALL, &query);
+    query = base::i18n::ToLower(query);
+
+    search_model_->results()->DeleteAll();
+    if (query.empty())
+      return;
+
+    for (int i = 0; i < static_cast<int>(WindowTypeShelfItem::LAST_TYPE); ++i) {
+      WindowTypeShelfItem::Type type =
+          static_cast<WindowTypeShelfItem::Type>(i);
+
+      base::string16 title =
+          base::UTF8ToUTF16(WindowTypeShelfItem::GetTitle(type));
+      if (base::i18n::StringSearchIgnoringCaseAndAccents(query, title, NULL,
+                                                         NULL)) {
+        search_model_->results()->Add(
+            std::make_unique<ExampleSearchResult>(type, query));
+      }
+    }
+  }
+
+  void ViewShown(int64_t display_id) override {
+    // Nothing needs to be done.
+  }
+
+  void DismissAppList() override {
+    Shell::Get()->app_list_controller()->DismissAppList();
+  }
+
+  void ViewClosing() override {
+    // Nothing needs to be done.
+  }
+
+  void ViewClosed() override {
+    // Nothing needs to be done.
+  }
+
+  void GetWallpaperProminentColors(
+      GetWallpaperProminentColorsCallback callback) override {
+    NOTIMPLEMENTED();
+  }
+
+  void ActivateItem(const std::string& id, int event_flags) override {
+    WindowTypeShelfItem* item =
+        static_cast<WindowTypeShelfItem*>(model_->FindItem(id));
+    if (!item)
+      return;
+    item->Activate(event_flags);
+  }
+
+  void GetContextMenuModel(const std::string& id,
+                           GetContextMenuModelCallback callback) override {
+    NOTIMPLEMENTED();
+  }
+
+  void GetSearchResultContextMenuModel(
+      const std::string& result_id,
+      GetContextMenuModelCallback callback) override {
+    NOTIMPLEMENTED();
+  }
+
+  void ContextMenuItemSelected(const std::string& id,
+                               int command_id,
+                               int event_flags) override {
+    NOTIMPLEMENTED();
+  }
+
+  void ShowWallpaperContextMenu(const gfx::Point& onscreen_location,
+                                ui::MenuSourceType source_type) override {
+    NOTIMPLEMENTED();
+  }
+
+  void SearchResultContextMenuItemSelected(const std::string& result_id,
+                                           int command_id,
+                                           int event_flags) override {
+    NOTIMPLEMENTED();
+  }
+
+  bool ProcessHomeLauncherGesture(ui::GestureEvent* event,
+                                  const gfx::Point& screen_location) override {
+    NOTIMPLEMENTED();
+    return false;
+  }
+
+  bool CanProcessEventsOnApplistViews() override {
+    NOTIMPLEMENTED();
+    return true;
+  }
+
+  void GetNavigableContentsFactory(
+      content::mojom::NavigableContentsFactoryRequest request) override {
+    NOTIMPLEMENTED();
+  }
+
+  std::unique_ptr<app_list::AppListModel> model_;
+  std::unique_ptr<app_list::SearchModel> search_model_;
+
+  DISALLOW_COPY_AND_ASSIGN(ExampleAppListViewDelegate);
+};
+
+}  // namespace
+
+app_list::AppListViewDelegate* CreateAppListViewDelegate() {
+  return new ExampleAppListViewDelegate;
+}
+
+}  // namespace shell
+}  // namespace ash
--- a/ash/test/ash_interactive_ui_test_base.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/ash/test/ash_interactive_ui_test_base.cc	2019-05-17 18:53:08.344000000 +0300
@@ -0,0 +1,67 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ash/test/ash_interactive_ui_test_base.h"
+
+#include "ash/test/ui_controls_factory_ash.h"
+#include "base/lazy_instance.h"
+#include "base/path_service.h"
+#include "mojo/core/embedder/embedder.h"
+#include "ui/aura/env.h"
+#include "ui/base/resource/resource_bundle.h"
+#include "ui/base/test/ui_controls_aura.h"
+#include "ui/base/ui_base_features.h"
+#include "ui/base/ui_base_paths.h"
+#include "ui/gl/test/gl_surface_test_support.h"
+
+namespace ash {
+
+namespace {
+
+class MojoInitializer {
+ public:
+  MojoInitializer() { mojo::core::Init(); }
+};
+
+base::LazyInstance<MojoInitializer>::Leaky mojo_initializer;
+
+// Initialize mojo once per process.
+void InitializeMojo() {
+  mojo_initializer.Get();
+}
+
+}  // namespace
+
+AshInteractiveUITestBase::AshInteractiveUITestBase() = default;
+
+AshInteractiveUITestBase::~AshInteractiveUITestBase() = default;
+
+void AshInteractiveUITestBase::SetUp() {
+  InitializeMojo();
+
+  gl::GLSurfaceTestSupport::InitializeOneOff();
+
+  ui::RegisterPathProvider();
+  ui::ResourceBundle::InitSharedInstanceWithLocale(
+      "en-US", NULL, ui::ResourceBundle::LOAD_COMMON_RESOURCES);
+  base::FilePath resources_pack_path;
+  base::PathService::Get(base::DIR_MODULE, &resources_pack_path);
+  resources_pack_path =
+      resources_pack_path.Append(FILE_PATH_LITERAL("resources.pak"));
+  ui::ResourceBundle::GetSharedInstance().AddDataPackFromPath(
+      resources_pack_path, ui::SCALE_FACTOR_NONE);
+  env_ = aura::Env::CreateInstance(features::IsSingleProcessMash()
+                                       ? aura::Env::Mode::MUS
+                                       : aura::Env::Mode::LOCAL);
+  ui_controls::InstallUIControlsAura(test::CreateAshUIControls());
+
+  AshTestBase::SetUp();
+}
+
+void AshInteractiveUITestBase::TearDown() {
+  AshTestBase::TearDown();
+  env_.reset();
+}
+
+}  // namespace ash
--- a/ash/test/ash_interactive_ui_test_base.h	1970-01-01 03:00:00.000000000 +0300
+++ b/ash/test/ash_interactive_ui_test_base.h	2019-05-17 18:53:08.344000000 +0300
@@ -0,0 +1,38 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef ASH_TEST_ASH_INTERACTIVE_UI_TEST_BASE_H_
+#define ASH_TEST_ASH_INTERACTIVE_UI_TEST_BASE_H_
+
+#include <memory>
+#include <string>
+
+#include "ash/test/ash_test_base.h"
+#include "base/macros.h"
+
+namespace aura {
+class Env;
+}
+
+namespace ash {
+
+class AshInteractiveUITestBase : public AshTestBase {
+ public:
+  AshInteractiveUITestBase();
+  ~AshInteractiveUITestBase() override;
+
+ protected:
+  // testing::Test:
+  void SetUp() override;
+  void TearDown() override;
+
+ private:
+  std::unique_ptr<aura::Env> env_;
+
+  DISALLOW_COPY_AND_ASSIGN(AshInteractiveUITestBase);
+};
+
+}  // namespace ash
+
+#endif  // ASH_TEST_ASH_INTERACTIVE_UI_TEST_BASE_H_
--- a/ash/wm/immersive_gesture_drag_handler.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/ash/wm/immersive_gesture_drag_handler.cc	2019-05-17 18:53:08.360000000 +0300
@@ -0,0 +1,131 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ash/wm/immersive_gesture_drag_handler.h"
+
+#include "ash/public/cpp/app_types.h"
+#include "ash/public/cpp/ash_features.h"
+#include "ash/public/cpp/immersive/immersive_fullscreen_controller.h"
+#include "ash/shell.h"
+#include "ash/wm/tablet_mode/tablet_mode_app_window_drag_controller.h"
+#include "ash/wm/tablet_mode/tablet_mode_controller.h"
+#include "ash/wm/tablet_mode/tablet_mode_window_drag_delegate.h"
+#include "ash/wm/window_state.h"
+#include "ui/aura/client/aura_constants.h"
+#include "ui/aura/client/screen_position_client.h"
+#include "ui/aura/window.h"
+#include "ui/display/screen.h"
+#include "ui/events/event.h"
+#include "ui/views/widget/widget.h"
+
+namespace ash {
+namespace {
+
+// How many pixels are reserved for gesture events to start dragging the app
+// window from the top of the screen in tablet mode.
+constexpr int kDragStartTopEdgeInset = 8;
+
+// Check whether we should start gesture dragging app window according to the
+// given ET_GETURE_SCROLL_BEGIN type |event|.
+bool CanBeginGestureDrag(ui::GestureEvent* event) {
+  if (event->details().scroll_y_hint() < 0)
+    return false;
+
+  const gfx::Point location_in_screen =
+      event->target()->GetScreenLocation(*event);
+  const gfx::Rect work_area_bounds =
+      display::Screen::GetScreen()
+          ->GetDisplayNearestWindow(static_cast<aura::Window*>(event->target()))
+          .work_area();
+
+  gfx::Rect hit_bounds_in_screen(work_area_bounds);
+  hit_bounds_in_screen.set_height(kDragStartTopEdgeInset);
+  if (hit_bounds_in_screen.Contains(location_in_screen))
+    return true;
+
+  // There may be a bezel sensor off screen logically above
+  // |hit_bounds_in_screen|. Handles the ET_GESTURE_SCROLL_BEGIN event
+  // triggerd in the bezel area too.
+  return location_in_screen.y() < hit_bounds_in_screen.y() &&
+         location_in_screen.x() >= hit_bounds_in_screen.x() &&
+         location_in_screen.x() < hit_bounds_in_screen.right();
+}
+
+}  // namespace
+
+ImmersiveGestureDragHandler::ImmersiveGestureDragHandler(aura::Window* window)
+    : window_(window) {
+  Shell::Get()->AddPreTargetHandler(this);
+}
+
+ImmersiveGestureDragHandler::~ImmersiveGestureDragHandler() {
+  Shell::Get()->RemovePreTargetHandler(this);
+}
+
+void ImmersiveGestureDragHandler::OnGestureEvent(ui::GestureEvent* event) {
+  if (CanDrag(event)) {
+    DCHECK(tablet_mode_app_window_drag_controller_);
+    if (tablet_mode_app_window_drag_controller_->DragWindowFromTop(event))
+      event->SetHandled();
+  } else if (tablet_mode_app_window_drag_controller_ &&
+             tablet_mode_app_window_drag_controller_->drag_delegate()
+                 ->dragged_window()) {
+    // Set the event as handled during app window drag if CanDrag(event) is
+    // false. Then the gesture events that triggered outside of the dragged
+    // window will not be proceeded to break the drag. Note, browser window
+    // doesn't use TabletModeWindowAppWindowDragController but WindowResizer to
+    // do window drag. It has its own logic to deal with the case.
+    event->SetHandled();
+  }
+}
+
+bool ImmersiveGestureDragHandler::CanDrag(ui::GestureEvent* event) {
+  views::Widget* widget = views::Widget::GetTopLevelWidgetForNativeView(
+      static_cast<aura::Window*>(event->target()));
+  if (!widget)
+    return false;
+
+  if (widget->GetNativeWindow() != window_)
+    return false;
+
+  // Maximized, fullscreened and snapped windows in tablet mode are allowed to
+  // be dragged.
+  wm::WindowState* window_state = wm::GetWindowState(window_);
+  if (!window_state ||
+      (!window_state->IsMaximized() && !window_state->IsFullscreen() &&
+       !window_state->IsSnapped()) ||
+      !Shell::Get()
+           ->tablet_mode_controller()
+           ->IsTabletModeWindowManagerEnabled()) {
+    return false;
+  }
+
+  // Fullscreen browser windows are not draggable. Dragging from top should show
+  // the frame.
+  if (window_state->IsFullscreen() &&
+      window_->GetProperty(aura::client::kAppType) ==
+          static_cast<int>(AppType::BROWSER)) {
+    return false;
+  }
+
+  // Start to drag window until ET_GESTURE_SCROLL_BEGIN event happened.
+  if (event->type() == ui::ET_GESTURE_SCROLL_BEGIN) {
+    if (!CanBeginGestureDrag(event))
+      return false;
+    tablet_mode_app_window_drag_controller_ =
+        std::make_unique<TabletModeAppWindowDragController>();
+    return true;
+  }
+
+  // Should not start dragging window until
+  // |tablet_mode_app_window_drag_controller_| have been created.
+  if (event->type() != ui::ET_GESTURE_SCROLL_BEGIN &&
+      !tablet_mode_app_window_drag_controller_) {
+    return false;
+  }
+
+  return true;
+}
+
+}  // namespace ash
--- a/ash/wm/immersive_gesture_drag_handler.h	1970-01-01 03:00:00.000000000 +0300
+++ b/ash/wm/immersive_gesture_drag_handler.h	2019-05-17 18:53:08.360000000 +0300
@@ -0,0 +1,46 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef ASH_WM_IMMERSIVE_GESTURE_DRAG_HANDLER_H_
+#define ASH_WM_IMMERSIVE_GESTURE_DRAG_HANDLER_H_
+
+#include <memory>
+
+#include "ash/ash_export.h"
+#include "ui/events/event_handler.h"
+
+namespace aura {
+class Window;
+}
+
+namespace ash {
+
+class TabletModeAppWindowDragController;
+
+// ImmersiveGestureHandler is responsible for calling
+// TabletAppModeWindowDragController::DragWindowFromTop() to drag the window
+// from the top if CanDrag is true when a gesture is received.
+class ASH_EXPORT ImmersiveGestureDragHandler : public ui::EventHandler {
+ public:
+  explicit ImmersiveGestureDragHandler(aura::Window* window);
+  ~ImmersiveGestureDragHandler() override;
+
+  // ui::EventHandler:
+  void OnGestureEvent(ui::GestureEvent* event) override;
+
+ private:
+  // Returns true if the target of |event| can be dragged.
+  bool CanDrag(ui::GestureEvent* event);
+
+  std::unique_ptr<TabletModeAppWindowDragController>
+      tablet_mode_app_window_drag_controller_;
+
+  aura::Window* window_;
+
+  DISALLOW_COPY_AND_ASSIGN(ImmersiveGestureDragHandler);
+};
+
+}  // namespace ash
+
+#endif  // ASH_WM_IMMERSIVE_GESTURE_DRAG_HANDLER_H_
--- a/ash/wm/immersive_gesture_drag_handler_unittest.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/ash/wm/immersive_gesture_drag_handler_unittest.cc	2019-05-17 18:53:08.360000000 +0300
@@ -0,0 +1,127 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ash/wm/immersive_gesture_drag_handler.h"
+
+#include "ash/public/cpp/app_types.h"
+#include "ash/shell.h"
+#include "ash/system/overview/overview_button_tray.h"
+#include "ash/system/status_area_widget.h"
+#include "ash/system/status_area_widget_test_helper.h"
+#include "ash/test/ash_test_base.h"
+#include "ash/wm/overview/overview_controller.h"
+#include "ash/wm/overview/overview_grid.h"
+#include "ash/wm/overview/overview_item.h"
+#include "ash/wm/tablet_mode/tablet_mode_controller_test_api.h"
+#include "ash/wm/window_state.h"
+#include "base/time/time.h"
+#include "ui/aura/client/aura_constants.h"
+#include "ui/events/test/event_generator.h"
+
+namespace ash {
+
+class ImmersiveGestureDragHandlerTest : public AshTestBase {
+ public:
+  ImmersiveGestureDragHandlerTest() = default;
+  ~ImmersiveGestureDragHandlerTest() override = default;
+
+  void SetUp() override {
+    AshTestBase::SetUp();
+    TabletModeControllerTestApi().EnterTabletMode();
+
+    dragged_window_ = CreateTestWindow();
+    none_dragged_window_ = CreateTestWindow();
+    dragged_window_->SetProperty(aura::client::kAppType,
+                                 static_cast<int>(AppType::CHROME_APP));
+    handler_ =
+        std::make_unique<ImmersiveGestureDragHandler>(dragged_window_.get());
+  }
+
+  void TearDown() override {
+    handler_.reset();
+    none_dragged_window_.reset();
+    dragged_window_.reset();
+    AshTestBase::TearDown();
+  }
+
+ protected:
+  // Send gesture event with |type| to |handler_|.
+  void SendGestureEvent(const gfx::Point& position,
+                        int scroll_x,
+                        int scroll_y,
+                        ui::EventType type) {
+    ui::GestureEvent event = ui::GestureEvent(
+        position.x(), position.y(), ui::EF_NONE, base::TimeTicks::Now(),
+        ui::GestureEventDetails(type, scroll_x, scroll_y));
+    ui::Event::DispatcherApi(&event).set_target(dragged_window_.get());
+    handler_->OnGestureEvent(&event);
+  }
+
+  std::unique_ptr<aura::Window> dragged_window_;
+  std::unique_ptr<aura::Window> none_dragged_window_;
+  std::unique_ptr<ImmersiveGestureDragHandler> handler_;
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(ImmersiveGestureDragHandlerTest);
+};
+
+// Tests that tap the window in overview grid during window drag should not end
+// the overview mode and the window should still be kept in overview grid.
+TEST_F(ImmersiveGestureDragHandlerTest,
+       TapWindowInOverviewGridDuringWindowDrag) {
+  ASSERT_TRUE(TabletModeControllerTestApi().IsTabletModeStarted());
+
+  SendGestureEvent(gfx::Point(0, 0), 0, 5, ui::ET_GESTURE_SCROLL_BEGIN);
+  // Drag the window to the right corner to avoid overlap with
+  // |none_dragged_window_| in overview grid.
+  SendGestureEvent(gfx::Point(700, 500), 700, 500,
+                   ui::ET_GESTURE_SCROLL_UPDATE);
+  EXPECT_TRUE(wm::GetWindowState(dragged_window_.get())->is_dragged());
+
+  EXPECT_TRUE(Shell::Get()->overview_controller()->IsSelecting());
+  OverviewSession* overview_session =
+      Shell::Get()->overview_controller()->overview_session();
+  EXPECT_TRUE(overview_session->IsWindowInOverview(none_dragged_window_.get()));
+
+  OverviewGrid* current_grid = overview_session->GetGridWithRootWindow(
+      none_dragged_window_->GetRootWindow());
+  OverviewItem* item =
+      current_grid->GetOverviewItemContaining(none_dragged_window_.get());
+  GetEventGenerator()->GestureTapAt(item->GetTransformedBounds().CenterPoint());
+
+  // Overview mode is still active and |none_dragged_window_| is still in
+  // overview grid after tried to tap it in overview grid.
+  EXPECT_TRUE(Shell::Get()->overview_controller()->IsSelecting());
+  EXPECT_TRUE(overview_session->IsWindowInOverview(none_dragged_window_.get()));
+}
+
+// Tests that tap the overview button during window drag should not end overview
+// mode.
+TEST_F(ImmersiveGestureDragHandlerTest, TapOverviewButtonDuringWindowDrag) {
+  ASSERT_TRUE(TabletModeControllerTestApi().IsTabletModeStarted());
+
+  SendGestureEvent(gfx::Point(0, 0), 0, 5, ui::ET_GESTURE_SCROLL_BEGIN);
+  // Drag the window to the right corner to avoid overlap with
+  // |none_dragged_window_| in overview grid.
+  SendGestureEvent(gfx::Point(700, 500), 700, 500,
+                   ui::ET_GESTURE_SCROLL_UPDATE);
+  EXPECT_TRUE(wm::GetWindowState(dragged_window_.get())->is_dragged());
+  EXPECT_TRUE(Shell::Get()->overview_controller()->IsSelecting());
+  OverviewSession* overview_session =
+      Shell::Get()->overview_controller()->overview_session();
+
+  EXPECT_TRUE(Shell::Get()->overview_controller()->IsSelecting());
+  OverviewButtonTray* overview_button_tray =
+      StatusAreaWidgetTestHelper::GetStatusAreaWidget()->overview_button_tray();
+  ASSERT_TRUE(overview_button_tray->visible());
+  GetEventGenerator()->GestureTapAt(
+      overview_button_tray->GetBoundsInScreen().CenterPoint());
+
+  // Overview mode is still active and |none_dragged_window_| is still in
+  // overview grid after tap the overview button.
+  EXPECT_TRUE(Shell::Get()->overview_controller()->IsSelecting());
+  EXPECT_TRUE(overview_session->IsWindowInOverview(none_dragged_window_.get()));
+}
+
+}  // namespace ash
--- a/ash/wm/native_cursor_manager_ash_interactive_uitest.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/ash/wm/native_cursor_manager_ash_interactive_uitest.cc	2019-05-17 18:53:08.364000000 +0300
@@ -0,0 +1,64 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ash/wm/native_cursor_manager_ash.h"
+
+#include "ash/shell.h"
+#include "ash/test/ash_interactive_ui_test_base.h"
+#include "ash/wm/cursor_manager_test_api.h"
+#include "base/run_loop.h"
+#include "ui/aura/window.h"
+#include "ui/aura/window_tree_host.h"
+#include "ui/base/test/ui_controls.h"
+#include "ui/display/manager/display_manager.h"
+#include "ui/display/manager/managed_display_info.h"
+
+namespace ash {
+
+using NativeCursorManagerAshTest = AshInteractiveUITestBase;
+
+namespace {
+
+display::ManagedDisplayInfo CreateDisplayInfo(int64_t id,
+                                              const gfx::Rect& bounds,
+                                              float device_scale_factor) {
+  display::ManagedDisplayInfo info(id, "", false);
+  info.SetBounds(bounds);
+  info.set_device_scale_factor(device_scale_factor);
+  return info;
+}
+
+void MoveMouseSync(aura::Window* window, int x, int y) {
+  // Send and wait for a key event to make sure that mouse
+  // events are fully processed.
+  base::RunLoop loop;
+  ui_controls::SendKeyPressNotifyWhenDone(window, ui::VKEY_SPACE, false, false,
+                                          false, false, loop.QuitClosure());
+  loop.Run();
+}
+
+}  // namespace
+
+// Disabled on non-X11 before X11 was deprecated.
+TEST_F(NativeCursorManagerAshTest, DISABLED_CursorChangeOnEnterNotify) {
+  ::wm::CursorManager* cursor_manager = Shell::Get()->cursor_manager();
+  CursorManagerTestApi test_api(cursor_manager);
+
+  display::ManagedDisplayInfo display_info1 =
+      CreateDisplayInfo(10, gfx::Rect(0, 0, 500, 300), 1.0f);
+  display::ManagedDisplayInfo display_info2 =
+      CreateDisplayInfo(20, gfx::Rect(500, 0, 500, 300), 2.0f);
+  std::vector<display::ManagedDisplayInfo> display_info_list;
+  display_info_list.push_back(display_info1);
+  display_info_list.push_back(display_info2);
+  display_manager()->OnNativeDisplaysChanged(display_info_list);
+
+  MoveMouseSync(Shell::GetAllRootWindows()[0], 10, 10);
+  EXPECT_EQ(1.0f, test_api.GetCurrentCursor().device_scale_factor());
+
+  MoveMouseSync(Shell::GetAllRootWindows()[0], 600, 10);
+  EXPECT_EQ(2.0f, test_api.GetCurrentCursor().device_scale_factor());
+}
+
+}  // namespace ash
--- a/ash/wm/tablet_mode/tablet_mode_app_window_drag_controller.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/ash/wm/tablet_mode/tablet_mode_app_window_drag_controller.cc	2019-05-17 18:53:08.380000000 +0300
@@ -0,0 +1,140 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ash/wm/tablet_mode/tablet_mode_app_window_drag_controller.h"
+
+#include "ash/shell.h"
+#include "ash/wm/overview/overview_controller.h"
+#include "ash/wm/splitview/split_view_drag_indicators.h"
+#include "ash/wm/tablet_mode/tablet_mode_window_drag_delegate.h"
+#include "ash/wm/window_state.h"
+#include "ui/base/hit_test.h"
+#include "ui/views/widget/widget.h"
+#include "ui/wm/core/coordinate_conversion.h"
+
+namespace ash {
+
+namespace {
+
+// The drag delegate for app windows. It not only includes the logic in
+// TabletModeWindowDragDelegate, but also has special logic for app windows.
+class TabletModeAppWindowDragDelegate : public TabletModeWindowDragDelegate {
+ public:
+  TabletModeAppWindowDragDelegate() = default;
+  ~TabletModeAppWindowDragDelegate() override = default;
+
+ private:
+  // TabletModeWindowDragDelegate:
+  void PrepareWindowDrag(const gfx::Point& location_in_screen) override {
+    wm::GetWindowState(dragged_window_)
+        ->CreateDragDetails(location_in_screen, HTCLIENT,
+                            ::wm::WINDOW_MOVE_SOURCE_TOUCH);
+  }
+  void UpdateWindowDrag(const gfx::Point& location_in_screen) override {}
+  void EndingWindowDrag(wm::WmToplevelWindowEventHandler::DragResult result,
+                        const gfx::Point& location_in_screen) override {
+    wm::GetWindowState(dragged_window_)->DeleteDragDetails();
+  }
+  void EndedWindowDrag(const gfx::Point& location_in_screen) override {}
+  void StartFling(const ui::GestureEvent* event) override {
+    if (ShouldFlingIntoOverview(event)) {
+      DCHECK(Shell::Get()->overview_controller()->IsSelecting());
+      Shell::Get()->overview_controller()->overview_session()->AddItem(
+          dragged_window_, /*reposition=*/true, /*animate=*/false);
+    }
+  }
+
+  DISALLOW_COPY_AND_ASSIGN(TabletModeAppWindowDragDelegate);
+};
+
+}  // namespace
+
+TabletModeAppWindowDragController::TabletModeAppWindowDragController()
+    : drag_delegate_(std::make_unique<TabletModeAppWindowDragDelegate>()) {
+  display::Screen::GetScreen()->AddObserver(this);
+}
+
+TabletModeAppWindowDragController::~TabletModeAppWindowDragController() {
+  display::Screen::GetScreen()->RemoveObserver(this);
+}
+
+bool TabletModeAppWindowDragController::DragWindowFromTop(
+    ui::GestureEvent* event) {
+  previous_location_in_screen_ =
+      drag_delegate_->GetEventLocationInScreen(event);
+  if (event->type() == ui::ET_GESTURE_SCROLL_BEGIN)
+    return StartWindowDrag(event);
+
+  if (!drag_delegate_->dragged_window())
+    return false;
+
+  if (event->type() == ui::ET_GESTURE_SCROLL_UPDATE) {
+    UpdateWindowDrag(event);
+    return true;
+  }
+
+  if (event->type() == ui::ET_GESTURE_SCROLL_END) {
+    EndWindowDrag(event, wm::WmToplevelWindowEventHandler::DragResult::SUCCESS);
+    return true;
+  }
+
+  if (event->type() == ui::ET_SCROLL_FLING_START) {
+    FlingOrSwipe(event);
+    return true;
+  }
+
+  EndWindowDrag(event, wm::WmToplevelWindowEventHandler::DragResult::REVERT);
+  return false;
+}
+
+bool TabletModeAppWindowDragController::StartWindowDrag(
+    ui::GestureEvent* event) {
+  views::Widget* widget = views::Widget::GetTopLevelWidgetForNativeView(
+      static_cast<aura::Window*>(event->target()));
+  if (!widget)
+    return false;
+
+  drag_delegate_->StartWindowDrag(
+      widget->GetNativeWindow(),
+      drag_delegate_->GetEventLocationInScreen(event));
+  return true;
+}
+
+void TabletModeAppWindowDragController::UpdateWindowDrag(
+    ui::GestureEvent* event) {
+  // Update the dragged window's tranform during dragging.
+  drag_delegate_->ContinueWindowDrag(
+      drag_delegate_->GetEventLocationInScreen(event),
+      TabletModeWindowDragDelegate::UpdateDraggedWindowType::UPDATE_TRANSFORM);
+}
+
+void TabletModeAppWindowDragController::EndWindowDrag(
+    ui::GestureEvent* event,
+    wm::WmToplevelWindowEventHandler::DragResult result) {
+  drag_delegate_->EndWindowDrag(
+      result, drag_delegate_->GetEventLocationInScreen(event));
+}
+
+void TabletModeAppWindowDragController::FlingOrSwipe(ui::GestureEvent* event) {
+  drag_delegate_->FlingOrSwipe(event);
+}
+
+void TabletModeAppWindowDragController::OnDisplayMetricsChanged(
+    const display::Display& display,
+    uint32_t metrics) {
+  if (!drag_delegate_->dragged_window() || !(metrics & DISPLAY_METRIC_ROTATION))
+    return;
+
+  display::Display current_display =
+      display::Screen::GetScreen()->GetDisplayNearestWindow(
+          drag_delegate_->dragged_window());
+  if (display.id() != current_display.id())
+    return;
+
+  drag_delegate_->EndWindowDrag(
+      wm::WmToplevelWindowEventHandler::DragResult::REVERT,
+      previous_location_in_screen_);
+}
+
+}  // namespace ash
--- a/ash/wm/tablet_mode/tablet_mode_app_window_drag_controller.h	1970-01-01 03:00:00.000000000 +0300
+++ b/ash/wm/tablet_mode/tablet_mode_app_window_drag_controller.h	2019-05-17 18:53:08.380000000 +0300
@@ -0,0 +1,55 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef ASH_WM_TABLET_MODE_TABLET_MODE_APP_WINDOW_DRAG_CONTROLLER_H_
+#define ASH_WM_TABLET_MODE_TABLET_MODE_APP_WINDOW_DRAG_CONTROLLER_H_
+
+#include "ash/ash_export.h"
+#include "ash/wm/wm_toplevel_window_event_handler.h"
+#include "ui/display/display_observer.h"
+
+namespace ui {
+class GestureEvent;
+}  // namespace ui
+
+namespace ash {
+class TabletModeWindowDragDelegate;
+
+// Handles app windows dragging in tablet mode. App windows can be dragged into
+// splitscreen through swiping from the top of the screen in tablet mode.
+class ASH_EXPORT TabletModeAppWindowDragController
+    : public display::DisplayObserver {
+ public:
+  TabletModeAppWindowDragController();
+  ~TabletModeAppWindowDragController() override;
+
+  // Processes a gesture event and updates the transform of |dragged_window_|.
+  // Returns true if the gesture has been handled and it should not be processed
+  // any further, false otherwise. Depending on the event position, the dragged
+  // window may be 1) maximized, or 2) snapped in splitscren.
+  bool DragWindowFromTop(ui::GestureEvent* event);
+
+  TabletModeWindowDragDelegate* drag_delegate() { return drag_delegate_.get(); }
+
+ private:
+  // Gesture window drag related functions. Used in DragWindowFromTop.
+  bool StartWindowDrag(ui::GestureEvent* event);
+  void UpdateWindowDrag(ui::GestureEvent* event);
+  void EndWindowDrag(ui::GestureEvent* event,
+                     wm::WmToplevelWindowEventHandler::DragResult result);
+  void FlingOrSwipe(ui::GestureEvent* event);
+
+  // display::DisplayObserver:
+  void OnDisplayMetricsChanged(const display::Display& display,
+                               uint32_t metrics) override;
+
+  std::unique_ptr<TabletModeWindowDragDelegate> drag_delegate_;
+  gfx::Point previous_location_in_screen_;
+
+  DISALLOW_COPY_AND_ASSIGN(TabletModeAppWindowDragController);
+};
+
+}  // namespace ash
+
+#endif  // ASH_WM_TABLET_MODE_TABLET_MODE_APP_WINDOW_DRAG_CONTROLLER_H_
--- a/ash/wm/tablet_mode/tablet_mode_browser_window_drag_controller.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/ash/wm/tablet_mode/tablet_mode_browser_window_drag_controller.cc	2019-05-17 18:53:08.380000000 +0300
@@ -0,0 +1,86 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ash/wm/tablet_mode/tablet_mode_browser_window_drag_controller.h"
+
+#include "ash/shell.h"
+#include "ash/wm/tablet_mode/tablet_mode_browser_window_drag_delegate.h"
+#include "ash/wm/window_util.h"
+#include "ui/wm/core/coordinate_conversion.h"
+#include "ui/wm/core/cursor_manager.h"
+
+namespace ash {
+
+TabletModeBrowserWindowDragController::TabletModeBrowserWindowDragController(
+    wm::WindowState* window_state)
+    : WindowResizer(window_state),
+      drag_delegate_(std::make_unique<TabletModeBrowserWindowDragDelegate>()),
+      weak_ptr_factory_(this) {
+  DCHECK(details().is_resizable);
+  DCHECK(!window_state->allow_set_bounds_direct());
+
+  if (details().source != ::wm::WINDOW_MOVE_SOURCE_TOUCH) {
+    Shell::Get()->cursor_manager()->LockCursor();
+    did_lock_cursor_ = true;
+  }
+
+  previous_location_in_screen_ = details().initial_location_in_parent;
+  ::wm::ConvertPointToScreen(GetTarget()->parent(),
+                             &previous_location_in_screen_);
+
+  drag_delegate_->StartWindowDrag(GetTarget(), previous_location_in_screen_);
+}
+
+TabletModeBrowserWindowDragController::
+    ~TabletModeBrowserWindowDragController() {
+  if (did_lock_cursor_)
+    Shell::Get()->cursor_manager()->UnlockCursor();
+}
+
+void TabletModeBrowserWindowDragController::Drag(
+    const gfx::Point& location_in_parent,
+    int event_flags) {
+  gfx::Point location_in_screen = location_in_parent;
+  ::wm::ConvertPointToScreen(GetTarget()->parent(), &location_in_screen);
+  previous_location_in_screen_ = location_in_screen;
+
+  // Update the dragged window, the drag indicators, the preview window,
+  // source window position, blurred background, etc, if necessary.
+  if (wm::IsDraggingTabs(GetTarget())) {
+    // Update the dragged window's bounds if it's tab-dragging.
+    base::WeakPtr<TabletModeBrowserWindowDragController> resizer(
+        weak_ptr_factory_.GetWeakPtr());
+    drag_delegate_->ContinueWindowDrag(
+        location_in_screen,
+        TabletModeWindowDragDelegate::UpdateDraggedWindowType::UPDATE_BOUNDS,
+        CalculateBoundsForDrag(location_in_parent));
+    // Note, this might have been deleted when reaching here.
+    if (!resizer)
+      return;
+  } else {
+    // Otherwise, update the dragged window's transform.
+    drag_delegate_->ContinueWindowDrag(
+        location_in_screen, TabletModeWindowDragDelegate::
+                                UpdateDraggedWindowType::UPDATE_TRANSFORM);
+  }
+}
+
+void TabletModeBrowserWindowDragController::CompleteDrag() {
+  drag_delegate_->EndWindowDrag(
+      wm::WmToplevelWindowEventHandler::DragResult::SUCCESS,
+      previous_location_in_screen_);
+}
+
+void TabletModeBrowserWindowDragController::RevertDrag() {
+  drag_delegate_->EndWindowDrag(
+      wm::WmToplevelWindowEventHandler::DragResult::REVERT,
+      previous_location_in_screen_);
+}
+
+void TabletModeBrowserWindowDragController::FlingOrSwipe(
+    ui::GestureEvent* event) {
+  drag_delegate_->FlingOrSwipe(event);
+}
+
+}  // namespace ash
--- a/ash/wm/tablet_mode/tablet_mode_browser_window_drag_controller.h	1970-01-01 03:00:00.000000000 +0300
+++ b/ash/wm/tablet_mode/tablet_mode_browser_window_drag_controller.h	2019-05-17 18:53:08.380000000 +0300
@@ -0,0 +1,61 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef ASH_WM_TABLET_MODE_TABLET_MODE_BROWSER_WINDOW_DRAG_CONTROLLER_H_
+#define ASH_WM_TABLET_MODE_TABLET_MODE_BROWSER_WINDOW_DRAG_CONTROLLER_H_
+
+#include <memory>
+
+#include "ash/wm/window_resizer.h"
+#include "ash/wm/wm_toplevel_window_event_handler.h"
+#include "base/macros.h"
+#include "base/memory/weak_ptr.h"
+
+namespace ash {
+class TabletModeWindowDragDelegate;
+
+namespace wm {
+class WindowState;
+}  // namespace wm
+
+// WindowResizer implementation for browser windows in tablet mode. Currently we
+// don't allow any resizing and any dragging happening on the area other than
+// the caption tabs area in tablet mode. Only browser windows with tabs are
+// allowed to be dragged. Depending on the event position, the dragged window
+// may be 1) maximized, or 2) snapped in splitscreen, or 3) merged to an
+// existing window.
+class TabletModeBrowserWindowDragController : public WindowResizer {
+ public:
+  explicit TabletModeBrowserWindowDragController(wm::WindowState* window_state);
+  ~TabletModeBrowserWindowDragController() override;
+
+  // WindowResizer:
+  void Drag(const gfx::Point& location_in_parent, int event_flags) override;
+  void CompleteDrag() override;
+  void RevertDrag() override;
+  void FlingOrSwipe(ui::GestureEvent* event) override;
+
+  TabletModeWindowDragDelegate* drag_delegate_for_testing() {
+    return drag_delegate_.get();
+  }
+
+ private:
+  // The drag delegate that does the real work: shows/hides the drag indicators,
+  // preview windows, blurred background, etc, during dragging.
+  std::unique_ptr<TabletModeWindowDragDelegate> drag_delegate_;
+
+  gfx::Point previous_location_in_screen_;
+
+  bool did_lock_cursor_ = false;
+
+  // Used to determine if this has been deleted during a drag such as when a tab
+  // gets dragged into another browser window.
+  base::WeakPtrFactory<TabletModeBrowserWindowDragController> weak_ptr_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(TabletModeBrowserWindowDragController);
+};
+
+}  // namespace ash
+
+#endif  // ASH_WM_TABLET_MODE_TABLET_MODE_BROWSER_WINDOW_DRAG_CONTROLLER_H_
