--- a/services/audio/audio_sandbox_win.cc	2019-05-17 17:45:42.492000000 +0300
+++ b/services/audio/audio_sandbox_win.cc	2019-05-17 18:53:37.772000000 +0300
@@ -39,7 +39,7 @@
   // WASAPIAudioInputStream::Open() will fail with error code E_ACCESSDENIED
   // (0x80070005) when trying to get a reference to ISimpleAudioVolume
   // interface. See
-  // https://cs.ch40m1um.qjz9zk/chromium/bmedia/audio/win/audio_low_latency_input_win.cc
+  // https://cs.chromium.org/chromium/bmedia/audio/win/audio_low_latency_input_win.cc
   policy->SetTokenLevel(sandbox::USER_RESTRICTED_SAME_ACCESS,
                         sandbox::USER_NON_ADMIN);
   policy->SetDelayedIntegrityLevel(sandbox::INTEGRITY_LEVEL_LOW);
--- a/services/audio/BUILD.gn	2019-05-01 01:22:56.000000000 +0300
+++ b/services/audio/BUILD.gn	2019-05-17 18:53:37.772000000 +0300
@@ -4,7 +4,9 @@
 
 import("//build/config/chromecast_build.gni")
 import("//media/webrtc/audio_processing.gni")
+import("//services/catalog/public/tools/catalog.gni")
 import("//services/service_manager/public/cpp/service_executable.gni")
+import("//services/service_manager/public/service_manifest.gni")
 import("//testing/test.gni")
 
 # Currently standalone service binaries are not supported on Android or iOS.
@@ -22,6 +24,11 @@
   ]
 }
 
+service_manifest("manifest") {
+  name = "audio"
+  source = "manifest.json"
+}
+
 source_set("lib") {
   sources = [
     "debug_recording.cc",
@@ -170,25 +177,62 @@
   deps = [
     ":audio",
     ":lib",
+    ":tests_catalog_source",
     "//base/test:test_support",
     "//media:test_support",
     "//mojo/core/embedder",
     "//services/audio/public/cpp",
-    "//services/audio/public/cpp:manifest",
     "//services/audio/public/cpp:test_support",
     "//services/audio/public/mojom",
     "//services/service_manager/public/cpp",
     "//services/service_manager/public/cpp/test:test_support",
-    "//services/service_manager/public/mojom",
     "//testing/gmock",
     "//testing/gtest",
   ]
 
   if (standalone_supported) {
     sources += [ "test/standalone_service_test.cc" ]
+    deps += [ ":standalone_unittest_catalog_source" ]
   }
 
   data_deps = [
     ":audio",
   ]
 }
+
+# Embedded tests support.
+service_manifest("unittest_manifest") {
+  name = "audio_unittests"
+  source = "test/service_unittest_manifest.json"
+  packaged_services = [ ":manifest" ]
+}
+
+catalog("tests_catalog") {
+  testonly = true
+  embedded_services = [ ":unittest_manifest" ]
+}
+
+catalog_cpp_source("tests_catalog_source") {
+  testonly = true
+  catalog = ":tests_catalog"
+  generated_function_name = "audio::CreateUnittestCatalog"
+}
+
+# Standalone tests support.
+if (standalone_supported) {
+  service_manifest("standalone_unittest_manifest") {
+    name = "audio_unittests"
+    source = "test/service_unittest_manifest.json"
+    generated_namespace = "standalone_audio_unittest"
+  }
+
+  catalog("standalone_unittest_catalog") {
+    embedded_services = [ ":standalone_unittest_manifest" ]
+    standalone_services = [ ":manifest" ]
+  }
+
+  catalog_cpp_source("standalone_unittest_catalog_source") {
+    catalog = ":standalone_unittest_catalog"
+    generated_function_name = "audio::CreateStandaloneUnittestCatalog"
+  }
+}
--- a/services/audio/debug_recording.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/audio/debug_recording.cc	2019-05-17 18:53:37.772000000 +0300
@@ -7,7 +7,6 @@
 #include <memory>
 #include <utility>
 
-#include "base/bind.h"
 #include "media/audio/audio_debug_recording_manager.h"
 #include "media/audio/audio_manager.h"
 
--- a/services/audio/device_notifier.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/audio/device_notifier.cc	2019-05-17 18:53:37.772000000 +0300
@@ -6,7 +6,6 @@
 
 #include <utility>
 
-#include "base/bind.h"
 #include "base/sequenced_task_runner.h"
 #include "base/threading/sequenced_task_runner_handle.h"
 #include "base/trace_event/trace_event.h"
--- a/services/audio/input_controller.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/audio/input_controller.cc	2019-05-17 18:53:37.772000000 +0300
@@ -554,6 +554,7 @@
       if (output_stream)
         stream_->SetOutputDeviceForAec(output_stream->GetDeviceId());
       break;
+    case media::EchoCancellationType::kAec2:
     case media::EchoCancellationType::kAec3:
 #if defined(AUDIO_PROCESSING_IN_AUDIO_SERVICE)
       if (processing_helper_)
@@ -802,6 +803,7 @@
 void InputController::UpdateVolumeAndAPMStats(
     base::Optional<double> new_volume) {
   DCHECK_CALLED_ON_VALID_THREAD(owning_thread_);
+  processing_helper_->GetAudioProcessor()->UpdateInternalStats();
   if (new_volume)
     SetVolume(*new_volume);
 }
--- a/services/audio/input_controller_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/audio/input_controller_unittest.cc	2019-05-17 18:53:37.772000000 +0300
@@ -13,11 +13,11 @@
 #include "base/test/scoped_feature_list.h"
 #include "base/test/scoped_task_environment.h"
 #include "media/audio/audio_manager.h"
+#include "media/audio/audio_processing.h"
 #include "media/audio/fake_audio_input_stream.h"
 #include "media/audio/fake_audio_log_factory.h"
 #include "media/audio/fake_audio_manager.h"
 #include "media/audio/test_audio_thread.h"
-#include "media/base/audio_processing.h"
 #include "media/base/user_input_monitor.h"
 #include "media/webrtc/audio_processor.h"
 #include "media/webrtc/webrtc_switches.h"
@@ -270,9 +270,9 @@
 }
 
 #if defined(AUDIO_PROCESSING_IN_AUDIO_SERVICE)
-INSTANTIATE_TEST_SUITE_P(, InputControllerTest, ::testing::Bool());
+INSTANTIATE_TEST_CASE_P(, InputControllerTest, ::testing::Bool());
 #else
-INSTANTIATE_TEST_SUITE_P(, InputControllerTest, testing::Values(false));
+INSTANTIATE_TEST_CASE_P(, InputControllerTest, testing::Values(false));
 #endif
 
 }  // namespace audio
--- a/services/audio/input_stream.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/audio/input_stream.cc	2019-05-17 18:53:37.772000000 +0300
@@ -7,7 +7,6 @@
 #include <string>
 #include <utility>
 
-#include "base/bind.h"
 #include "base/bind_helpers.h"
 #include "base/strings/strcat.h"
 #include "base/trace_event/trace_event.h"
--- a/services/audio/input_stream_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/audio/input_stream_unittest.cc	2019-05-17 18:53:37.772000000 +0300
@@ -8,7 +8,6 @@
 #include <string>
 #include <utility>
 
-#include "base/bind.h"
 #include "base/test/scoped_task_environment.h"
 #include "media/audio/audio_io.h"
 #include "media/audio/mock_audio_manager.h"
--- a/services/audio/local_muter.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/audio/local_muter.cc	2019-05-17 18:53:37.776000000 +0300
@@ -6,7 +6,6 @@
 
 #include <utility>
 
-#include "base/bind.h"
 #include "services/audio/loopback_group_member.h"
 
 namespace audio {
--- a/services/audio/log_factory_adapter.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/audio/log_factory_adapter.h	2019-05-17 18:53:37.776000000 +0300
@@ -10,7 +10,6 @@
 #include "base/containers/queue.h"
 #include "media/audio/audio_logging.h"
 #include "media/audio/fake_audio_log_factory.h"
-#include "media/mojo/interfaces/audio_logging.mojom.h"
 #include "services/audio/public/mojom/log_factory_manager.mojom.h"
 
 namespace media {
--- a/services/audio/log_factory_manager_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/audio/log_factory_manager_unittest.cc	2019-05-17 18:53:37.776000000 +0300
@@ -60,7 +60,7 @@
     MockCreateAudioLog(component, component_id);
     mojo::MakeStrongBinding(base::WrapUnique(mock_logs_[current_mock_log_++]),
                             std::move(audio_log_request));
-  }
+  };
 
   MockAudioLog* GetMockLog(size_t index) { return mock_logs_[index]; }
 
--- a/services/audio/loopback_stream.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/audio/loopback_stream.cc	2019-05-17 18:53:37.776000000 +0300
@@ -23,18 +23,12 @@
 
 namespace audio {
 
-namespace {
-
-// Start with a conservative, but reasonable capture delay that should work for
-// most platforms (i.e., not needing an increase during a loopback session).
-constexpr base::TimeDelta kInitialCaptureDelay =
-    base::TimeDelta::FromMilliseconds(20);
-
-}  // namespace
-
 // static
 constexpr double LoopbackStream::kMaxVolume;
 
+// static
+constexpr base::TimeDelta LoopbackStream::kCaptureDelay;
+
 LoopbackStream::LoopbackStream(
     CreatedCallback created_callback,
     BindingLostCallback binding_lost_callback,
@@ -300,7 +294,6 @@
   first_generate_time_ = clock_->NowTicks();
   frames_elapsed_ = 0;
   next_generate_time_ = first_generate_time_;
-  capture_delay_ = kInitialCaptureDelay;
 
   flow_task_runner_->PostTask(
       FROM_HERE,
@@ -326,38 +319,21 @@
   TRACE_EVENT_WITH_FLOW0("audio", "GenerateMoreAudio", this,
                          TRACE_EVENT_FLAG_FLOW_IN | TRACE_EVENT_FLAG_FLOW_OUT);
 
+  // Always generate audio from the recent past, to prevent buffer underruns
+  // in the inputs.
+  const base::TimeTicks delayed_capture_time =
+      next_generate_time_ - kCaptureDelay;
+
   // Drive the audio flows from the SnooperNodes and produce the single result
   // stream. Hold the lock during this part of the process to prevent any of the
   // control methods from altering the configuration of the network.
   double output_volume;
-  base::TimeTicks delayed_capture_time;
   {
     base::AutoLock scoped_lock(lock_);
     output_volume = volume_;
 
     HelpDiagnoseCauseOfLoopbackCrash("generating");
 
-    // Compute the reference time to use for audio rendering. Query each input
-    // node and update |capture_delay_|, if necessary. This is used to always
-    // generate audio from a "safe point" in the recent past, to prevent buffer
-    // underruns in the inputs. http://crbug.com/934770
-    delayed_capture_time = next_generate_time_ - capture_delay_;
-    for (SnooperNode* node : inputs_) {
-      const base::Optional<base::TimeTicks> suggestion =
-          node->SuggestLatestRenderTime(mix_bus_->frames());
-      if (suggestion.value_or(delayed_capture_time) < delayed_capture_time) {
-        const base::TimeDelta increase = delayed_capture_time - (*suggestion);
-        TRACE_EVENT_INSTANT2("audio", "GenerateMoreAudio Capture Delay Change",
-                             TRACE_EVENT_SCOPE_THREAD, "old capture delay (µs)",
-                             capture_delay_.InMicroseconds(), "change (µs)",
-                             increase.InMicroseconds());
-        delayed_capture_time = *suggestion;
-        capture_delay_ += increase;
-      }
-    }
-    TRACE_COUNTER_ID1("audio", "Loopback Capture Delay (µs)", this,
-                      capture_delay_.InMicroseconds());
-
     // Render the audio from each input, apply this stream's volume setting by
     // scaling the data, then mix it all together to form a single audio
     // signal. If there are no snoopers, just render silence.
--- a/services/audio/loopback_stream.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/audio/loopback_stream.h	2019-05-17 18:53:37.776000000 +0300
@@ -99,6 +99,13 @@
   // than 1.0.
   static constexpr double kMaxVolume = 2.0;
 
+  // The amount of time in the past from which to capture the audio. The audio
+  // recorded from each LoopbackGroupMember is being generated with a target
+  // playout time in the near future (usually 1 to 20 ms). To avoid underflow,
+  // LoopbackStream fetches the audio from a position in the recent past.
+  static constexpr base::TimeDelta kCaptureDelay =
+      base::TimeDelta::FromMilliseconds(20);
+
  private:
   // Drives all audio flows, re-mixing the audio from multiple SnooperNodes into
   // a single audio stream. This class mainly operates on a separate task runner
@@ -194,14 +201,6 @@
     int64_t frames_elapsed_ = 0;
     base::TimeTicks next_generate_time_;
 
-    // The amount of time in the past from which to capture the audio. The audio
-    // recorded from each SnooperNode input is being generated with a target
-    // playout time in the near future (usually 1 to 20 ms). To avoid underflow,
-    // audio is always fetched from a safe position in the recent past.
-    //
-    // This is updated to match the SnooperNode whose recording is most delayed.
-    base::TimeDelta capture_delay_;
-
     // Used to transfer the audio from each SnooperNode and mix them into a
     // single audio signal. |transfer_bus_| is only allocated when first needed,
     // but |mix_bus_| is allocated in the constructor because it is always
--- a/services/audio/loopback_stream_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/audio/loopback_stream_unittest.cc	2019-05-17 18:53:37.776000000 +0300
@@ -9,7 +9,6 @@
 #include <cstdint>
 #include <memory>
 
-#include "base/bind.h"
 #include "base/containers/unique_ptr_adapters.h"
 #include "base/memory/scoped_refptr.h"
 #include "base/test/scoped_task_environment.h"
--- a/services/audio/output_controller_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/audio/output_controller_unittest.cc	2019-05-17 18:53:37.776000000 +0300
@@ -707,7 +707,7 @@
   EXPECT_EQ(mute_stream, last_closed_stream());
 }
 
-INSTANTIATE_TEST_SUITE_P(OutputControllerSnoopingTest,
+INSTANTIATE_TEST_CASE_P(OutputControllerSnoopingTest,
                          WithSnoopingMode,
                          ::testing::Values(Snoopable::SnoopingMode::kDeferred,
                                            Snoopable::SnoopingMode::kRealtime));
--- a/services/audio/output_stream.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/audio/output_stream.cc	2019-05-17 18:53:37.776000000 +0300
@@ -7,7 +7,6 @@
 #include <utility>
 
 #include "base/bind.h"
-#include "base/bind_helpers.h"
 #include "base/threading/sequenced_task_runner_handle.h"
 #include "base/trace_event/trace_event.h"
 
--- a/services/audio/output_stream_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/audio/output_stream_unittest.cc	2019-05-17 18:53:37.776000000 +0300
@@ -6,7 +6,6 @@
 
 #include <utility>
 
-#include "base/bind.h"
 #include "base/test/mock_callback.h"
 #include "base/test/scoped_task_environment.h"
 #include "base/unguessable_token.h"
--- a/services/audio/OWNERS	2019-05-01 01:22:56.000000000 +0300
+++ b/services/audio/OWNERS	2019-05-17 18:53:37.772000000 +0300
@@ -3,6 +3,9 @@
 dalecurtis@chromium.org
 miu@chromium.org
 
+per-file manifest.json=set noparent
+per-file manifest.json=file://ipc/SECURITY_OWNERS
+
 per-file audio_sandbox_hook_linux.*=file://sandbox/linux/OWNERS
 per-file audio_sandbox_win.*=file://sandbox/win/OWNERS
 
--- a/services/audio/public/cpp/audio_processing_mojom_traits.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/audio/public/cpp/audio_processing_mojom_traits.h	2019-05-17 18:53:37.780000000 +0300
@@ -5,7 +5,7 @@
 #ifndef SERVICES_AUDIO_PUBLIC_CPP_AUDIO_PROCESSING_MOJOM_TRAITS_H_
 #define SERVICES_AUDIO_PUBLIC_CPP_AUDIO_PROCESSING_MOJOM_TRAITS_H_
 
-#include "media/base/audio_processing.h"
+#include "media/audio/audio_processing.h"
 #include "mojo/public/cpp/bindings/struct_traits.h"
 #include "services/audio/public/mojom/audio_processing.mojom.h"
 
@@ -59,6 +59,8 @@
     switch (type) {
       case media::EchoCancellationType::kDisabled:
         return audio::mojom::EchoCancellationType::kDisabled;
+      case media::EchoCancellationType::kAec2:
+        return audio::mojom::EchoCancellationType::kAec2;
       case media::EchoCancellationType::kAec3:
         return audio::mojom::EchoCancellationType::kAec3;
       case media::EchoCancellationType::kSystemAec:
@@ -74,6 +76,9 @@
       case audio::mojom::EchoCancellationType::kDisabled:
         *out = media::EchoCancellationType::kDisabled;
         return true;
+      case audio::mojom::EchoCancellationType::kAec2:
+        *out = media::EchoCancellationType::kAec2;
+        return true;
       case audio::mojom::EchoCancellationType::kAec3:
         *out = media::EchoCancellationType::kAec3;
         return true;
--- a/services/audio/public/cpp/audio_processing.typemap	2019-05-01 01:22:56.000000000 +0300
+++ b/services/audio/public/cpp/audio_processing.typemap	2019-05-17 18:53:37.776000000 +0300
@@ -4,7 +4,7 @@
 
 mojom = "//services/audio/public/mojom/audio_processing.mojom"
 public_headers = [
-  "//media/base/audio_processing.h",
+  "//media/audio/audio_processing.h",
   "//third_party/webrtc/api/media_stream_interface.h",
 ]
 traits_headers =
--- a/services/audio/public/cpp/BUILD.gn	2019-05-01 01:22:56.000000000 +0300
+++ b/services/audio/public/cpp/BUILD.gn	2019-05-17 18:53:37.776000000 +0300
@@ -30,18 +30,6 @@
   ]
 }
 
-source_set("manifest") {
-  sources = [
-    "manifest.cc",
-    "manifest.h",
-  ]
-  deps = [
-    "//base",
-    "//services/audio/public/mojom",
-    "//services/service_manager/public/cpp",
-  ]
-}
-
 source_set("test_support") {
   testonly = true
 
--- a/services/audio/public/cpp/debug_recording_session.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/audio/public/cpp/debug_recording_session.cc	2019-05-17 18:53:37.780000000 +0300
@@ -6,7 +6,6 @@
 
 #include <utility>
 
-#include "base/bind.h"
 #include "base/files/file_path.h"
 #include "base/strings/string_number_conversions.h"
 #include "build/build_config.h"
@@ -20,9 +19,9 @@
 namespace {
 
 #if defined(OS_WIN)
-#define NumberToStringType base::NumberToString16
+#define IntToStringType base::IntToString16
 #else
-#define NumberToStringType base::NumberToString
+#define IntToStringType base::IntToString
 #endif
 
 const base::FilePath::CharType* StreamTypeToStringType(
@@ -61,7 +60,7 @@
                                              base::File::FLAG_WRITE);
           },
           file_name_base_.AddExtension(StreamTypeToStringType(stream_type))
-              .AddExtension(NumberToStringType(id))
+              .AddExtension(IntToStringType(id))
               .AddExtension(FILE_PATH_LITERAL("wav"))),
       std::move(reply_callback));
 }
--- a/services/audio/public/cpp/fake_stream_factory.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/audio/public/cpp/fake_stream_factory.h	2019-05-17 18:53:37.780000000 +0300
@@ -7,11 +7,8 @@
 
 #include <string>
 
-#include "media/mojo/interfaces/audio_input_stream.mojom.h"
-#include "media/mojo/interfaces/audio_logging.mojom.h"
 #include "mojo/public/cpp/bindings/binding.h"
 #include "mojo/public/cpp/bindings/interface_request.h"
-#include "services/audio/public/mojom/audio_processing.mojom.h"
 #include "services/audio/public/mojom/stream_factory.mojom.h"
 
 namespace audio {
--- a/services/audio/public/cpp/fake_system_info.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/audio/public/cpp/fake_system_info.cc	2019-05-17 18:53:37.780000000 +0300
@@ -4,7 +4,6 @@
 
 #include "services/audio/public/cpp/fake_system_info.h"
 
-#include "base/bind.h"
 #include "services/audio/public/mojom/constants.mojom.h"
 #include "services/service_manager/public/cpp/service_binding.h"
 
--- a/services/audio/public/cpp/input_ipc.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/audio/public/cpp/input_ipc.cc	2019-05-17 18:53:37.780000000 +0300
@@ -6,11 +6,8 @@
 
 #include <utility>
 
-#include "base/bind.h"
 #include "base/bind_helpers.h"
-#include "media/mojo/interfaces/audio_data_pipe.mojom.h"
 #include "mojo/public/cpp/system/platform_handle.h"
-#include "services/audio/public/mojom/audio_processing.mojom.h"
 #include "services/audio/public/mojom/constants.mojom.h"
 
 namespace audio {
--- a/services/audio/public/cpp/input_ipc.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/audio/public/cpp/input_ipc.h	2019-05-17 18:53:37.780000000 +0300
@@ -15,7 +15,6 @@
 #include "base/time/time.h"
 #include "media/audio/audio_input_ipc.h"
 #include "media/mojo/interfaces/audio_input_stream.mojom.h"
-#include "media/mojo/interfaces/audio_logging.mojom.h"
 #include "mojo/public/cpp/bindings/binding.h"
 #include "services/audio/public/mojom/stream_factory.mojom.h"
 #include "services/service_manager/public/cpp/connector.h"
--- a/services/audio/public/cpp/input_ipc_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/audio/public/cpp/input_ipc_unittest.cc	2019-05-17 18:53:37.780000000 +0300
@@ -7,7 +7,6 @@
 #include <string>
 #include <utility>
 
-#include "base/bind.h"
 #include "base/test/scoped_task_environment.h"
 #include "media/mojo/interfaces/audio_data_pipe.mojom.h"
 #include "mojo/public/cpp/system/buffer.h"
--- a/services/audio/public/cpp/output_device.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/audio/public/cpp/output_device.cc	2019-05-17 18:53:37.780000000 +0300
@@ -6,12 +6,9 @@
 
 #include <utility>
 
-#include "base/bind.h"
 #include "base/optional.h"
 #include "base/threading/thread_restrictions.h"
 #include "media/audio/audio_output_device_thread_callback.h"
-#include "media/mojo/interfaces/audio_data_pipe.mojom.h"
-#include "media/mojo/interfaces/audio_logging.mojom.h"
 #include "mojo/public/cpp/system/platform_handle.h"
 #include "services/audio/public/mojom/constants.mojom.h"
 
--- a/services/audio/public/cpp/output_device.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/audio/public/cpp/output_device.h	2019-05-17 18:53:37.780000000 +0300
@@ -10,7 +10,6 @@
 
 #include "media/base/audio_renderer_sink.h"
 #include "media/mojo/interfaces/audio_output_stream.mojom.h"
-#include "services/audio/public/mojom/audio_processing.mojom.h"
 #include "services/audio/public/mojom/stream_factory.mojom.h"
 #include "services/service_manager/public/cpp/connector.h"
 
--- a/services/audio/public/cpp/output_device_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/audio/public/cpp/output_device_unittest.cc	2019-05-17 18:53:37.784000000 +0300
@@ -6,13 +6,11 @@
 
 #include <utility>
 
-#include "base/bind.h"
 #include "base/run_loop.h"
 #include "base/test/scoped_task_environment.h"
 #include "build/build_config.h"
 #include "media/audio/audio_sync_reader.h"
 #include "media/base/audio_renderer_sink.h"
-#include "media/mojo/interfaces/audio_data_pipe.mojom.h"
 #include "mojo/public/cpp/bindings/binding.h"
 #include "mojo/public/cpp/system/platform_handle.h"
 #include "services/audio/public/cpp/fake_stream_factory.h"
--- a/services/audio/public/cpp/OWNERS	2019-05-01 01:22:56.000000000 +0300
+++ b/services/audio/public/cpp/OWNERS	2019-05-17 18:53:37.776000000 +0300
@@ -1,7 +1,3 @@
-per-file manifest.cc=set noparent
-per-file manifest.cc=file://ipc/SECURITY_OWNERS
-per-file manifest.h=set noparent
-per-file manifest.h=file://ipc/SECURITY_OWNERS
 per-file *_mojom_traits*.*=set noparent
 per-file *_mojom_traits*.*=file://ipc/SECURITY_OWNERS
 per-file *.typemap=set noparent
--- a/services/audio/public/mojom/audio_processing.mojom	2019-05-01 01:22:56.000000000 +0300
+++ b/services/audio/public/mojom/audio_processing.mojom	2019-05-17 18:53:37.784000000 +0300
@@ -47,6 +47,7 @@
 
 enum EchoCancellationType {
   kDisabled,
+  kAec2,
   kAec3,
   kSystemAec
 };
--- a/services/audio/service.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/audio/service.cc	2019-05-17 18:53:37.784000000 +0300
@@ -6,7 +6,6 @@
 
 #include <utility>
 
-#include "base/bind.h"
 #include "base/logging.h"
 #include "base/macros.h"
 #include "base/single_thread_task_runner.h"
--- a/services/audio/service_factory.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/audio/service_factory.cc	2019-05-17 18:53:37.784000000 +0300
@@ -7,7 +7,6 @@
 #include <string>
 #include <utility>
 
-#include "base/bind.h"
 #include "base/command_line.h"
 #include "base/metrics/field_trial_params.h"
 #include "base/optional.h"
--- a/services/audio/snooper_node.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/audio/snooper_node.cc	2019-05-17 18:53:37.784000000 +0300
@@ -39,12 +39,6 @@
 // data extraction.
 constexpr int kResamplerRequestSize = 3 * media::SincResampler::kKernelSize;
 
-// Returns the deviation, around an estimated reference time, beyond which a
-// SnooperNode considers a skip in input/output to have occurred.
-base::TimeDelta GetReferenceTimeSkipThreshold(base::TimeDelta bus_duration) {
-  return bus_duration / 2;
-}
-
 }  // namespace
 
 // static
@@ -68,7 +62,6 @@
       buffer_(
           Helper::TimeToFrames(kDelayBufferSize, input_params_.sample_rate())),
       write_position_(kNullPosition),
-      checkpoint_time_(base::TimeTicks::Min()),
       read_position_(kNullPosition),
       correction_fps_(0),
       resampler_(
@@ -125,36 +118,13 @@
   if (write_position_ == kNullPosition) {
     write_position_ = kWriteStartPosition;
   } else {
-    const base::TimeDelta threshold =
-        GetReferenceTimeSkipThreshold(input_bus_duration_);
     const base::TimeDelta delta = reference_time - write_reference_time_;
-    if (delta < -threshold) {
-      TRACE_EVENT_INSTANT1("audio", "SnooperNode Discards Input",
-                           TRACE_EVENT_SCOPE_THREAD, "wait_time_remaining (μs)",
-                           (-delta).InMicroseconds());
-      // It's illegal to back-track the |write_position_| and/or attempt to
-      // "rewrite history" in the delay buffer. Thus, simply drop input until it
-      // catches up. Events such as this are generally only caused by device-
-      // switching in audio::OutputController, where the delay timestamps may
-      // shift. http://crbug.com/934770
-      return;
-    } else if (delta > threshold) {
+    if (delta >= input_bus_duration_) {
       TRACE_EVENT_INSTANT1("audio", "SnooperNode Input Gap",
                            TRACE_EVENT_SCOPE_THREAD, "gap (μs)",
                            delta.InMicroseconds());
-      // Skip the |write_position_| forward, which will create a zero-fill gap
-      // in the delay buffer.
       write_position_ +=
           Helper::TimeToFrames(delta, input_params_.sample_rate());
-    } else {
-      // Normal case: Continue writing into the delay buffer at the current
-      // |write_position_|.
-      //
-      // Note that, if input was being discarded (in the prior OnData() call),
-      // there will be no "recovery adjustment" to the |write_position_|.
-      // Instead, any significant jump in |write_reference_time_| will cause
-      // Render() to gradually re-synchronize the audio. There will be no
-      // zero-fill gap inserted into the delay buffer.
     }
   }
 
@@ -164,41 +134,6 @@
   write_reference_time_ = reference_time + input_bus_duration_;
 }
 
-base::Optional<base::TimeTicks> SnooperNode::SuggestLatestRenderTime(
-    FrameTicks duration) {
-  DCHECK_GE(duration, 0);
-
-  const base::TimeTicks last_checkpoint_time = checkpoint_time_;
-  {
-    base::AutoLock scoped_lock(lock_);
-    if (write_position_ == kNullPosition) {
-      return base::nullopt;  // OnData() never called yet.
-    }
-    checkpoint_time_ = write_reference_time_;
-  }
-
-  // Do not suggest any changes if OnData() has not been called since the last
-  // call to this method. This may indicate an input discontinuity is occurring.
-  if (checkpoint_time_ == last_checkpoint_time) {
-    return base::nullopt;
-  }
-
-  // Suggest a render time by working backwards from the end time of the data
-  // currently recorded in the delay buffer. Subtract from the end time: 1) the
-  // maximum duration prebufferred in the resampler; 2) the duration to be
-  // rendered; 3) a safety margin (to help avoid underruns when the machine is
-  // under high stress).
-  const base::TimeDelta max_resampler_prebuffer_duration = Helper::FramesToTime(
-      kResamplerRequestSize + media::SincResampler::kKernelSize,
-      input_params_.sample_rate());
-  const base::TimeDelta render_duration =
-      Helper::FramesToTime(duration, output_params_.sample_rate());
-  const base::TimeDelta safety_margin =
-      GetReferenceTimeSkipThreshold(render_duration);
-  return checkpoint_time_ - max_resampler_prebuffer_duration - render_duration -
-         safety_margin;
-}
-
 void SnooperNode::Render(base::TimeTicks reference_time,
                          media::AudioBus* output_bus) {
   DCHECK_EQ(output_bus->channels(), output_params_.channels());
@@ -237,10 +172,8 @@
         estimated_output_position + std::lround(resampler_.BufferedFrames());
     DCHECK_EQ(correction_fps_, 0);
   } else {
-    const base::TimeDelta threshold =
-        GetReferenceTimeSkipThreshold(output_bus_duration_);
     const base::TimeDelta delta = reference_time - render_reference_time_;
-    if (delta.magnitude() < threshold) {  // Normal case: No gap.
+    if (delta < output_bus_duration_) {  // Normal case: No gap.
       // Compute the drift, which is the number of frames the resampler is
       // behind in reading from the delay buffer. This calculation also accounts
       // for the frames buffered within the resampler.
@@ -258,24 +191,28 @@
       // this prevents excessive "churn" within the resampler, where otherwise
       // it would be recomputing its convolution kernel too often.
       const int fps_step = input_params_.sample_rate() / kStepBasisHz;
-      DCHECK_GT(fps_step, 0);
 
-      // Adjust the correction rate (and resampling ratio) if the above-computed
-      // |target_correction_fps| is more than one |fps_step| different than the
-      // current |correction_fps_|. Otherwise, leave the current rate unchanged,
-      // to avoid reconfiguring the resampler too often.
+      // Adjust the correction rate (and resampling ratio) based on how
+      // different the target correction FPS is from the current correction
+      // FPS. If more than two steps away, make an aggressive adjustment. If
+      // only more than one step away, nudge the current rate by just one
+      // step. Otherwise, leave the current rate unchanged.
       const int diff = target_correction_fps - correction_fps_;
-      if (diff > fps_step || diff < -fps_step) {
-        UpdateCorrectionRate(correction_fps_ + ((diff / fps_step) * fps_step));
+      if (std::abs(diff) > 2 * fps_step) {
+        UpdateCorrectionRate(target_correction_fps);
+      } else if (diff > fps_step) {
+        UpdateCorrectionRate(correction_fps_ + fps_step);
+      } else if (diff < -fps_step) {
+        UpdateCorrectionRate(correction_fps_ - fps_step);
       } else {
         // No correction necessary.
       }
-    } else {  // Some type of rewind, fast-forward, or a rendering gap.
-      TRACE_EVENT_INSTANT1("audio", "SnooperNode Render Skip",
-                           TRACE_EVENT_SCOPE_THREAD, "delta (μs)",
+    } else /* if (delta >= threshold) */ {  // Gap detected.
+      TRACE_EVENT_INSTANT1("audio", "SnooperNode Render Gap",
+                           TRACE_EVENT_SCOPE_THREAD, "gap (μs)",
                            delta.InMicroseconds());
 
-      // Rather than flush and re-prime the resampler, just seek to its next
+      // Rather than flush and re-prime the resampler, just skip-ahead its next
       // read-from position.
       read_position_ +=
           Helper::TimeToFrames(delta, input_params_.sample_rate());
--- a/services/audio/snooper_node.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/audio/snooper_node.h	2019-05-17 18:53:37.784000000 +0300
@@ -9,7 +9,6 @@
 #include <memory>
 
 #include "base/macros.h"
-#include "base/optional.h"
 #include "base/synchronization/lock.h"
 #include "base/time/time.h"
 #include "media/base/audio_parameters.h"
@@ -75,13 +74,6 @@
               base::TimeTicks reference_time,
               double volume) final;
 
-  // Given the timing of recent OnData() calls and the |duration| of output that
-  // would be requested in a call to Render(), determine the latest possible
-  // |reference_time| for a Render() call that won't result in an underrun.
-  // Returns base::nullopt while current conditions prohibit making a reliable
-  // suggestion.
-  base::Optional<base::TimeTicks> SuggestLatestRenderTime(FrameTicks duration);
-
   // Renders more audio that was recorded from the GroupMember until
   // |output_bus| is filled, resampling and remixing the channels if necessary.
   // |reference_time| is used for detecting skip-ahead (i.e., a significant
@@ -127,11 +119,6 @@
   FrameTicks write_position_;             // Guarded by |lock_|.
   base::TimeTicks write_reference_time_;  // Guarded by |lock_|.
 
-  // Used by SuggestLatestRenderTime() to track whether OnData() has been called
-  // recently, and as a basis for its suggestion. Other methods should not
-  // depend on this value for anything.
-  base::TimeTicks checkpoint_time_;
-
   // The next frame position from which to read from the delay buffer. This is
   // the position of the frames about to be pushed into the resampler, not the
   // position of frames about to be Render()'ed.
--- a/services/audio/snooper_node_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/audio/snooper_node_unittest.cc	2019-05-17 18:53:37.784000000 +0300
@@ -8,12 +8,8 @@
 #include <memory>
 #include <vector>
 
-#include "base/bind.h"
-#include "base/command_line.h"
-#include "base/files/file_path.h"
 #include "base/memory/scoped_refptr.h"
 #include "base/optional.h"
-#include "base/strings/string_piece.h"
 #include "base/test/test_mock_time_task_runner.h"
 #include "media/base/audio_bus.h"
 #include "media/base/audio_parameters.h"
@@ -43,9 +39,11 @@
 constexpr base::TimeDelta kInputAdvanceTime =
     base::TimeDelta::FromMilliseconds(2);
 
-// Command-line switch to request dumping the recorded output to a WAV file for
-// analyzing the recorded output from one of the tests.
-constexpr base::StringPiece kDumpAsWavSwitch = "dump-as-wav";
+// The amount of time in the past from which outbound audio is being rendered.
+// This simulates the loopback stream's "capture from the recent past" mode-of-
+// operation.
+constexpr base::TimeDelta kOutputDelayTime =
+    base::TimeDelta::FromMilliseconds(20);
 
 // Test parameters.
 struct InputAndOutputParams {
@@ -63,6 +61,11 @@
 
 class SnooperNodeTest : public testing::TestWithParam<InputAndOutputParams> {
  public:
+  // Positions is a vector containing positions (in terms of frames elasped
+  // since the first) where an AudioBus input or output task should not be
+  // scheduled. This simulates missing input or skipped consumption.
+  using Positions = std::vector<int>;
+
   SnooperNodeTest() = default;
   ~SnooperNodeTest() override = default;
 
@@ -72,60 +75,12 @@
   const media::AudioParameters& output_params() const {
     return GetParam().output;
   }
-  base::TimeDelta output_delay() const { return output_delay_; }
-  double max_relative_error() const { return max_relative_error_; }
 
-  base::TestMockTimeTaskRunner* task_runner() const {
-    return task_runner_.get();
-  }
   FakeLoopbackGroupMember* group_member() { return &*group_member_; }
   SnooperNode* node() { return &*node_; }
   FakeConsumer* consumer() { return &*consumer_; }
 
   void SetUp() override {
-    // Determine the amount of time in the past from which outbound audio should
-    // be rendered. Use 20 ms as a reasonable baseline--the same as the initial
-    // setting in audio::LoopbackStream--which will work for almost all normal
-    // use cases.
-    constexpr base::TimeDelta kBaselineOutputDelay =
-        base::TimeDelta::FromMilliseconds(20);
-    output_delay_ = kBaselineOutputDelay;
-
-    // Increase the output delay in special cases...
-    if (input_params().sample_rate() < 32000) {
-      // At the lower input sample rates (e.g., 8 kHz), prebufferring inside
-      // SnooperNode's resampler becomes an issue: It uses a fixed size buffer
-      // of 128 samples, which equates to a much longer duration of audio at the
-      // lower sampling rates. With more buffering involved, the output delay
-      // must be increased to avoid underruns.
-      output_delay_ *= 2;
-    } else if (input_params().GetBufferDuration() >
-               output_params().GetBufferDuration()) {
-      // For the HandlesBackwardsInput() test, the input goes backward by a full
-      // buffer. If the duration of an input buffer is larger than an output
-      // buffer, this could cause a brief moment of underrun (which is WAI!).
-      // Rather than write lots of extra test code around such a specific
-      // scenario, just fudge the delay up a little such that the underrun
-      // cannot occur.
-      output_delay_ += input_params().GetBufferDuration();
-    }
-
-    // Determine the maximum allowable error when measuring expected amplitudes.
-    // This varies with the sampling rate because the loss of resolution at the
-    // lower sampling rates can introduce error in the "amplitude-sensing
-    // logic." Higher frequencies in the audio signal are especially vulnerable
-    // to the error introduced by using low sampling rates.
-    constexpr double kHighResAllowedError = 0.02;  // 2% at 48 kHz
-    constexpr double kHighResSampleRate = 48000;
-    constexpr double kLowResAllowedError = 0.10;  // 10% at 8 kHz
-    constexpr double kLowResSampleRate = 8000;
-    const int the_lower_sample_rate =
-        std::min(input_params().sample_rate(), output_params().sample_rate());
-    const double t = (the_lower_sample_rate - kHighResSampleRate) /
-                     (kLowResSampleRate - kHighResSampleRate);
-    max_relative_error_ =
-        kHighResAllowedError + t * (kLowResAllowedError - kHighResAllowedError);
-
     // Initialize a test clock and task runner. The starting TimeTicks value is
     // "huge" to ensure time calculations are being tested for overflow cases.
     task_runner_ = base::MakeRefCounted<base::TestMockTimeTaskRunner>(
@@ -133,69 +88,17 @@
                           base::TimeDelta::FromMicroseconds(INT64_C(1) << 62));
   }
 
-  void TearDown() override {
-    // If the "dump-as-wav" command-line switch is present, dump whatever has
-    // been recorded in the consumer.
-    const base::FilePath path =
-        base::CommandLine::ForCurrentProcess()->GetSwitchValuePath(
-            kDumpAsWavSwitch);
-    if (!path.empty()) {
-      if (consumer_) {
-        consumer_->SaveToFile(path);
-      } else {
-        LOG(ERROR) << "No consumer: ignoring --" << kDumpAsWavSwitch;
-      }
-    }
-  }
-
-  // Selects which frequency to return for each channel based on the input and
-  // output channel layout.
-  enum WhichFlow : int8_t {
-    FOR_INPUT,
-    FOR_SWAPPED_INPUT,
-    FOR_OUTPUT,
-    FOR_SWAPPED_OUTPUT,
-  };
-
-  double GetLeftChannelFrequency(WhichFlow which) const {
-    switch (which) {
-      case FOR_INPUT:
-      case FOR_OUTPUT:
-        return kLeftChannelFrequency;
-      case FOR_SWAPPED_INPUT:
-      case FOR_SWAPPED_OUTPUT:
-        return kRightChannelFrequency;
-    }
-  }
-
-  double GetRightChannelFrequency(WhichFlow which) const {
-    switch (which) {
-      // If the test parameters call for stereo→mono channel down-mixing, use
-      // the left channel frequency again for the right channel input. Down-
-      // mixing is tested elsewhere.
-      case FOR_INPUT:
-        return (output_params().channels() == 1 ? kLeftChannelFrequency
-                                                : kRightChannelFrequency);
-      case FOR_SWAPPED_INPUT:
-        return (output_params().channels() == 1 ? kRightChannelFrequency
-                                                : kLeftChannelFrequency);
-
-      // If the input was monaural, the output's right channel should contain
-      // the input's "left" channel frequency.
-      case FOR_OUTPUT:
-        return (input_params().channels() == 1 ? kLeftChannelFrequency
-                                               : kRightChannelFrequency);
-      case FOR_SWAPPED_OUTPUT:
-        return (input_params().channels() == 1 ? kRightChannelFrequency
-                                               : kLeftChannelFrequency);
-    }
-  }
-
   void CreateNewPipeline() {
     group_member_.emplace(input_params());
-    group_member_->SetChannelTone(0, GetLeftChannelFrequency(FOR_INPUT));
+    group_member_->SetChannelTone(0, kLeftChannelFrequency);
     if (input_params().channels() > 1) {
-      group_member_->SetChannelTone(1, GetRightChannelFrequency(FOR_INPUT));
+      // Set the right channel to kRightChannelFrequency unless the test
+      // parameters call for stereo→mono channel down-mixing. In that case, just
+      // use kLeftChannelFrequency again, and the test will confirm that the
+      // amplitude is 2X because there were two source channels mixed into one.
+      group_member_->SetChannelTone(1, output_params().channels() == 1
+                                           ? kLeftChannelFrequency
+                                           : kRightChannelFrequency);
     }
     group_member_->SetVolume(kSourceVolume);
 
@@ -206,79 +109,85 @@
                       output_params().sample_rate());
   }
 
-  // Have the SnooperNode render more output data and store it in the consumer
-  // for later analysis.
-  void RenderAndConsume(base::TimeTicks output_time) {
-    // Assign invalid sample values to the AudioBus. Then, after the Render()
-    // call, confirm that every sample was overwritten in the output AudioBus.
-    const auto bus = media::AudioBus::Create(output_params());
-    for (int ch = 0; ch < bus->channels(); ++ch) {
-      std::fill_n(bus->channel(ch), bus->frames(), kInvalidAudioSample);
-    }
-
-    // If the SnooperNode provides a suggestion, check that |output_time| is
-    // okay. Otherwise, Render() will be producing zero-fill gaps as the end of
-    // |bus|. Don't do this check if there is already a test failure, and this
-    // would just keep spamming the test output.
-    if (!HasFailure()) {
-      const base::Optional<base::TimeTicks> suggestion =
-          node_->SuggestLatestRenderTime(bus->frames());
-      if (suggestion) {
-        EXPECT_LE(output_time, *suggestion)
-            << "at frame=" << consumer_->GetRecordedFrameCount();
-      }
-    }
-
-    node_->Render(output_time, bus.get());
-
-    for (int ch = 0; ch < bus->channels(); ++ch) {
-      EXPECT_FALSE(
-          std::any_of(bus->channel(ch), bus->channel(ch) + bus->frames(),
-                      [](float x) { return x == kInvalidAudioSample; }))
-          << " at output_time=" << output_time << ", ch=" << ch;
-    }
-    consumer_->Consume(*bus);
-  }
+  void ScheduleInputTasks(double skew, const Positions& drop_positions) {
+    CHECK(std::is_sorted(drop_positions.begin(), drop_positions.end()));
 
-  // Post delayed tasks to schedule normal, uninterrupted input with the default
-  // kInputAdvanceTime delay.
-  void ScheduleDefaultInputTasks(double skew = 1.0) {
-    const base::TimeTicks start_time = task_runner_->NowTicks();
+    const base::TimeTicks start_time =
+        task_runner_->NowTicks() + kInputAdvanceTime;
     const base::TimeTicks end_time = start_time + kTestDuration;
     const double time_step = skew / input_params().sample_rate();
+
+    auto drop_it = drop_positions.begin();
     for (int position = 0;; position += input_params().frames_per_buffer()) {
-      const base::TimeTicks task_time =
+      // If a drop point has been reached, do not schedule an input task.
+      if (drop_it != drop_positions.end() && *drop_it == position) {
+        ++drop_it;
+        continue;
+      }
+
+      const base::TimeTicks next_time =
           start_time + base::TimeDelta::FromSecondsD(position * time_step);
-      if (task_time >= end_time) {
+      if (next_time >= end_time) {
         break;
       }
-      const base::TimeTicks reference_time = task_time + kInputAdvanceTime;
+
+      // FakeLoopbackGroupMember pushes audio into the SnooperNode.
       task_runner_->PostDelayedTask(
           FROM_HERE,
           base::BindOnce(&FakeLoopbackGroupMember::RenderMoreAudio,
-                         base::Unretained(group_member()), reference_time),
-          task_time - start_time);
+                         base::Unretained(group_member()), next_time),
+          next_time - start_time);
     }
   }
 
-  // Post delayed tasks to schedule normal, uninterrupted output rendering to
-  // occur at the default kCaptureDelay.
-  void ScheduleDefaultRenderTasks(double skew = 1.0) {
-    const base::TimeTicks start_time = task_runner_->NowTicks();
+  void ScheduleOutputTasks(double skew, const Positions& skip_positions) {
+    CHECK(std::is_sorted(skip_positions.begin(), skip_positions.end()));
+
+    const base::TimeTicks start_time =
+        task_runner_->NowTicks() - kOutputDelayTime;
     const base::TimeTicks end_time = start_time + kTestDuration;
     const double time_step = skew / output_params().sample_rate();
+
+    auto skip_it = skip_positions.begin();
     for (int position = 0;; position += output_params().frames_per_buffer()) {
-      const base::TimeTicks task_time =
+      // If a skip point has been reached, do not schedule an output task.
+      if (skip_it != skip_positions.end() && *skip_it == position) {
+        ++skip_it;
+        continue;
+      }
+
+      const base::TimeTicks next_time =
           start_time + base::TimeDelta::FromSecondsD(position * time_step);
-      if (task_time >= end_time) {
+      if (next_time >= end_time) {
         break;
       }
-      const base::TimeTicks reference_time = task_time - output_delay();
+
       task_runner_->PostDelayedTask(
           FROM_HERE,
-          base::BindOnce(&SnooperNodeTest::RenderAndConsume,
-                         base::Unretained(this), reference_time),
-          task_time - start_time);
+          base::BindOnce(
+              [](SnooperNodeTest* test, base::TimeTicks output_time) {
+                // Have the SnooperNode render more output data. Before that,
+                // assign invalid sample values to the AudioBus. Then, after the
+                // Render() call, confirm that every sample was overwritten in
+                // the output AudioBus.
+                const auto bus = media::AudioBus::Create(test->output_params());
+                for (int ch = 0; ch < bus->channels(); ++ch) {
+                  std::fill_n(bus->channel(ch), bus->frames(),
+                              kInvalidAudioSample);
+                }
+                test->node_->Render(output_time, bus.get());
+                for (int ch = 0; ch < bus->channels(); ++ch) {
+                  EXPECT_FALSE(std::any_of(
+                      bus->channel(ch), bus->channel(ch) + bus->frames(),
+                      [](float x) { return x == kInvalidAudioSample; }))
+                      << " at output_time=" << output_time << ", ch=" << ch;
+                }
+
+                // Pass the output to the consumer to store for later analysis.
+                test->consumer_->Consume(*bus);
+              },
+              this, next_time),
+          next_time - start_time);
     }
   }
 
@@ -286,33 +195,21 @@
 
  private:
   scoped_refptr<base::TestMockTimeTaskRunner> task_runner_;
-
-  // A suitable output delay to use for rendering audio from the pipeline. See
-  // comments in SetUp() for further details.
-  base::TimeDelta output_delay_;
-
-  // The maximum allowable error relative to an expected amplitude.
-  double max_relative_error_ = 0.0;
-
-  // The pipeline from source to consumer.
   base::Optional<FakeLoopbackGroupMember> group_member_;
   base::Optional<SnooperNode> node_;
   base::Optional<FakeConsumer> consumer_;
 };
 
-// The skew test here is generating 10 seconds of audio per iteration, with
-// 5*5=25 iterations. That's 250 seconds of audio being generated to check for
-// skew-related issues. That's a lot of processing power needed! Thus, only
-// enable this test on optimized, non-debug builds, where it will run in a
-// reasonable amount of time. http://crbug.com/842428
+// Performance of this test on debug builds is abysmal. So, only run it on
+// optimized builds.
+// TODO(crbug.com/842428): Analyze why only Windows debug test runs have this
+// problem and re-enable test.
 #ifdef NDEBUG
 #define MAYBE_ContinuousAudioFlowAdaptsToSkew ContinuousAudioFlowAdaptsToSkew
 #else
 #define MAYBE_ContinuousAudioFlowAdaptsToSkew \
   DISABLED_ContinuousAudioFlowAdaptsToSkew
 #endif
-// Tests that the internal time-stretching logic can handle various combinations
-// of input and output skews.
 TEST_P(SnooperNodeTest, MAYBE_ContinuousAudioFlowAdaptsToSkew) {
   // Note: A skew of 0.999 or 1.001 is very extreme. This is like saying the
   // clocks drift 1 ms for every second that goes by. If the implementation can
@@ -323,16 +220,18 @@
       SCOPED_TRACE(testing::Message() << "input_skew=" << input_skew
                                       << ", output_skew=" << output_skew);
 
+      // Set up the components, schedule all audio generation and consumption
+      // tasks, and then run them.
       CreateNewPipeline();
-      ScheduleDefaultInputTasks(input_skew);
-      ScheduleDefaultRenderTasks(output_skew);
+      ScheduleInputTasks(input_skew, Positions());
+      ScheduleOutputTasks(output_skew, Positions());
       RunAllPendingTasks();
 
       // All rendering for points-in-time before the audio from the source was
       // first recorded should be silence.
       const double expected_end_of_silence_position =
           ((input_skew * kInputAdvanceTime.InSecondsF()) +
-           (output_skew * output_delay().InSecondsF())) *
+           (output_skew * kOutputDelayTime.InSecondsF())) *
           output_params().sample_rate();
       const double frames_in_one_millisecond =
           output_params().sample_rate() / 1000.0;
@@ -351,15 +250,16 @@
         const int end_frame =
             consumer()->GetRecordedFrameCount() * i / kNumToneChecks;
         SCOPED_TRACE(testing::Message() << "end_frame=" << end_frame);
-        EXPECT_NEAR(kSourceVolume,
-                    consumer()->ComputeAmplitudeAt(
-                        0, GetLeftChannelFrequency(FOR_OUTPUT), end_frame),
-                    kSourceVolume * max_relative_error());
+        EXPECT_NEAR(
+            kSourceVolume,
+            consumer()->ComputeAmplitudeAt(0, kLeftChannelFrequency, end_frame),
+            0.01);
         if (output_params().channels() > 1) {
+          const double freq = input_params().channels() == 1
+                                  ? kLeftChannelFrequency
+                                  : kRightChannelFrequency;
           EXPECT_NEAR(kSourceVolume,
-                      consumer()->ComputeAmplitudeAt(
-                          1, GetRightChannelFrequency(FOR_OUTPUT), end_frame),
-                      kSourceVolume * max_relative_error());
+                      consumer()->ComputeAmplitudeAt(1, freq, end_frame), 0.01);
         }
       }
 
@@ -370,42 +270,46 @@
   }
 }
 
-// Tests that gaps in the input are detected, are handled by introducing
-// zero-fill gaps in the output, and don't throw-off the timing/synchronization
-// between input and output.
-TEST_P(SnooperNodeTest, HandlesMissingInput) {
-  CreateNewPipeline();
-
-  // Schedule all input tasks, with drops to occur once per second for 1/4
-  // second duration.
-  const base::TimeTicks start_time = task_runner()->NowTicks();
-  const base::TimeTicks end_time = start_time + kTestDuration;
-  const double time_step = 1.0 / input_params().sample_rate();
+// Performance of this test on debug builds is abysmal. So, only run it on
+// optimized builds.
+// TODO(crbug.com/842428): Analyze why only Windows debug test runs have this
+// problem and re-enable test.
+#ifdef NDEBUG
+#define MAYBE_HandlesMissingInput HandlesMissingInput
+#else
+#define MAYBE_HandlesMissingInput DISABLED_HandlesMissingInput
+#endif
+TEST_P(SnooperNodeTest, MAYBE_HandlesMissingInput) {
+  // Compute drops to occur once per second for 1/4 second duration. Each drop
+  // position must be aligned to input_params().frames_per_buffer() for the
+  // heuristics in ScheduleInputTasks() to process these drop positions
+  // correctly.
+  Positions drop_positions;
   const int input_frames_in_one_second = input_params().sample_rate();
-  // Drop duration: 1/4 second in terms of frames, aligned to frame buffer size.
-  const int drop_duration =
-      ((input_frames_in_one_second / 4) / input_params().frames_per_buffer()) *
+  const int input_frames_in_a_quarter_second = input_frames_in_one_second / 4;
+  int unaligned_drop_position = input_frames_in_one_second;
+  for (int gap = 0; gap < 5; ++gap) {
+    const int aligned_drop_position =
+        (unaligned_drop_position / input_params().frames_per_buffer()) *
       input_params().frames_per_buffer();
-  int next_drop_position = input_frames_in_one_second;
-  for (int position = 0;; position += input_params().frames_per_buffer()) {
-    if (position >= next_drop_position) {
-      position += drop_duration;
-      next_drop_position += input_frames_in_one_second;
-    }
-    const base::TimeTicks task_time =
-        start_time + base::TimeDelta::FromSecondsD(position * time_step);
-    if (task_time >= end_time) {
+    const int end_position =
+        aligned_drop_position + input_frames_in_a_quarter_second;
+    for (int i = 0;; ++i) {
+      const int next_drop_position =
+          aligned_drop_position + i * input_params().frames_per_buffer();
+      if (next_drop_position >= end_position) {
       break;
     }
-    const base::TimeTicks reference_time = task_time + kInputAdvanceTime;
-    task_runner()->PostDelayedTask(
-        FROM_HERE,
-        base::BindOnce(&FakeLoopbackGroupMember::RenderMoreAudio,
-                       base::Unretained(group_member()), reference_time),
-        task_time - start_time);
+      drop_positions.push_back(next_drop_position);
+    }
+    unaligned_drop_position += input_frames_in_one_second;
   }
 
-  ScheduleDefaultRenderTasks();
+  // Set up the components, schedule all audio generation and consumption tasks,
+  // and then run them.
+  CreateNewPipeline();
+  ScheduleInputTasks(1.0, drop_positions);
+  ScheduleOutputTasks(1.0, Positions());
   RunAllPendingTasks();
 
   // Check that there is silence in the drop positions, and that tones are
@@ -417,7 +321,7 @@
   const int output_frames_in_20_milliseconds =
       output_frames_in_one_second * 20 / 1000;
   int output_silence_position =
-      ((kInputAdvanceTime + output_delay()).InSecondsF() + 1.0) *
+      ((kInputAdvanceTime + kOutputDelayTime).InSecondsF() + 1.0) *
       output_params().sample_rate();
   for (int gap = 0; gap < 5; ++gap) {
     SCOPED_TRACE(testing::Message() << "gap=" << gap);
@@ -427,16 +331,9 @@
         output_silence_position - output_frames_in_20_milliseconds;
     EXPECT_NEAR(
         kSourceVolume,
-        consumer()->ComputeAmplitudeAt(0, GetLeftChannelFrequency(FOR_OUTPUT),
+        consumer()->ComputeAmplitudeAt(0, kLeftChannelFrequency,
                                        position_a_little_before_silence_begins),
-        kSourceVolume * max_relative_error());
-    if (output_params().channels() > 1) {
-      EXPECT_NEAR(kSourceVolume,
-                  consumer()->ComputeAmplitudeAt(
-                      1, GetRightChannelFrequency(FOR_OUTPUT),
-                      position_a_little_before_silence_begins),
-                  kSourceVolume * max_relative_error());
-    }
+        0.01);
 
     // There should be silence during the drop.
     const int position_a_little_after_silence_begins =
@@ -455,286 +352,14 @@
         2 * output_frames_in_20_milliseconds;
     EXPECT_NEAR(
         kSourceVolume,
-        consumer()->ComputeAmplitudeAt(0, GetLeftChannelFrequency(FOR_OUTPUT),
-                                       position_a_little_after_silence_ends),
-        kSourceVolume * max_relative_error());
-    if (output_params().channels() > 1) {
-      EXPECT_NEAR(kSourceVolume,
-                  consumer()->ComputeAmplitudeAt(
-                      1, GetRightChannelFrequency(FOR_OUTPUT),
+        consumer()->ComputeAmplitudeAt(0, kLeftChannelFrequency,
                       position_a_little_after_silence_ends),
-                  kSourceVolume * max_relative_error());
-    }
+        0.01);
     output_silence_position += output_frames_in_one_second;
   }
 }
 
-// Tests that a backwards-jump in input reference timestamps doesn't attempt to
-// "re-write history" and otherwise maintains the timing/synchronization between
-// input and output. This is a regression test for http://crbug.com/934770.
-TEST_P(SnooperNodeTest, HandlesBackwardsInput) {
-  CreateNewPipeline();
-
-  // Schedule all input tasks. At the halfway point, simulate a device change
-  // that shifts the timestamps backward by one buffer duration, and the
-  // left/right sound tones are swapped.
-  const base::TimeTicks start_time = task_runner()->NowTicks();
-  const base::TimeTicks end_time = start_time + kTestDuration;
-  const double time_step = 1.0 / input_params().sample_rate();
-  const int change_position =
-      input_params().sample_rate() * kTestDuration.InSeconds() / 2;
-  int position_offset = 0;
-  for (int position = 0;; position += input_params().frames_per_buffer()) {
-    const base::TimeTicks task_time =
-        start_time + base::TimeDelta::FromSecondsD(position * time_step);
-    if (task_time >= end_time) {
-      break;
-    }
-    if (position_offset == 0 && position >= change_position) {
-      position_offset = -input_params().frames_per_buffer();
-      task_runner()->PostDelayedTask(
-          FROM_HERE,
-          base::BindOnce(
-              [](SnooperNodeTest* test) {
-                test->group_member()->SetChannelTone(
-                    0, test->GetLeftChannelFrequency(FOR_SWAPPED_INPUT));
-                if (test->input_params().channels() > 1) {
-                  test->group_member()->SetChannelTone(
-                      1, test->GetRightChannelFrequency(FOR_SWAPPED_INPUT));
-                }
-              },
-              this),
-          task_time - start_time);
-    }
-    const base::TimeTicks reference_time =
-        start_time + kInputAdvanceTime +
-        base::TimeDelta::FromSecondsD((position + position_offset) * time_step);
-    task_runner()->PostDelayedTask(
-        FROM_HERE,
-        base::BindOnce(&FakeLoopbackGroupMember::RenderMoreAudio,
-                       base::Unretained(group_member()), reference_time),
-        task_time - start_time);
-  }
-
-  ScheduleDefaultRenderTasks();
-  RunAllPendingTasks();
-
-  // In the consumer's recording, there should be audio having the default tones
-  // before before the halfway point. After the halfway point, the tones should
-  // be swapped (left vs right). Sample once every second, starting at a
-  // ~half-second offset.
-  const int output_position_halfway =
-      (kInputAdvanceTime + output_delay() + (kTestDuration / 2)).InSecondsF() *
-      output_params().sample_rate();
-  const int output_frames_in_one_second = output_params().sample_rate();
-  int output_position =
-      ((kInputAdvanceTime + output_delay()).InSecondsF() + 0.5) *
-      output_params().sample_rate();
-  for (int output_end = consumer()->GetRecordedFrameCount();
-       output_position < output_end;
-       output_position += output_frames_in_one_second) {
-    const int left_ch_freq = (output_position < output_position_halfway)
-                                 ? GetLeftChannelFrequency(FOR_OUTPUT)
-                                 : GetLeftChannelFrequency(FOR_SWAPPED_OUTPUT);
-    EXPECT_NEAR(
-        kSourceVolume,
-        consumer()->ComputeAmplitudeAt(0, left_ch_freq, output_position),
-        kSourceVolume * max_relative_error());
-    if (output_params().channels() > 1) {
-      const int right_ch_freq =
-          (output_position < output_position_halfway)
-              ? GetRightChannelFrequency(FOR_OUTPUT)
-              : GetRightChannelFrequency(FOR_SWAPPED_OUTPUT);
-      EXPECT_NEAR(
-          kSourceVolume,
-          consumer()->ComputeAmplitudeAt(1, right_ch_freq, output_position),
-          kSourceVolume * max_relative_error());
-    }
-  }
-}
-
-// Tests that reasonable render times are suggested as audio is feeding into, or
-// not feeding into, the SnooperNode.
-TEST_P(SnooperNodeTest, SuggestsRenderTimes) {
-  constexpr base::TimeDelta kTwentyMilliseconds =
-      base::TimeDelta::FromMilliseconds(20);
-
-  CreateNewPipeline();
-
-  // Before any audio has flowed into the SnooperNode, there should be nothing
-  // to base a suggestion on.
-  EXPECT_FALSE(
-      node()->SuggestLatestRenderTime(output_params().frames_per_buffer()));
-
-  // Feed-in the first buffer and expect a render time suggestion that is
-  // greater than 150% the output buffer's duration amount of time in the
-  // past. (The extra 50% is a safety margin; see internal code comments for
-  // further details.) The suggestion should also not be too far in the past.
-  const base::TimeTicks first_input_time = task_runner()->NowTicks();
-  group_member()->RenderMoreAudio(first_input_time);
-  const base::Optional<base::TimeTicks> first_suggestion =
-      node()->SuggestLatestRenderTime(output_params().frames_per_buffer());
-  ASSERT_TRUE(first_suggestion);
-  const base::TimeTicks time_at_end_of_input =
-      first_input_time + input_params().GetBufferDuration();
-  const base::TimeDelta required_duration_buffered =
-      output_params().GetBufferDuration() * 3 / 2;
-  EXPECT_GT(time_at_end_of_input - required_duration_buffered,
-            *first_suggestion);
-  EXPECT_LT(
-      time_at_end_of_input - required_duration_buffered - kTwentyMilliseconds,
-      *first_suggestion);
-
-  // If another suggestion is solicited before more input was provided,
-  // SnooperNode shouldn't give one.
-  for (int i = 0; i < 3; ++i) {
-    EXPECT_FALSE(
-        node()->SuggestLatestRenderTime(output_params().frames_per_buffer()));
-  }
-
-  // When feeding-in successive buffers, a new suggestion can be given after
-  // each, reflecting the timing of the additional audio that has been buffered.
-  for (int i = 1; i <= 3; ++i) {
-    const base::TimeTicks next_input_time =
-        first_input_time +
-        base::TimeDelta::FromSecondsD(
-            i * input_params().frames_per_buffer() /
-            static_cast<double>(input_params().sample_rate()));
-    group_member()->RenderMoreAudio(next_input_time);
-    const base::Optional<base::TimeTicks> next_suggestion =
-        node()->SuggestLatestRenderTime(output_params().frames_per_buffer());
-    ASSERT_TRUE(next_suggestion);
-    const base::TimeTicks time_at_end_of_input =
-        next_input_time + input_params().GetBufferDuration();
-    EXPECT_GT(time_at_end_of_input - required_duration_buffered,
-              *next_suggestion);
-    EXPECT_LT(
-        time_at_end_of_input - required_duration_buffered - kTwentyMilliseconds,
-        *next_suggestion);
-  }
-}
-
-namespace {
-
-// Used in the HandlesSeekedRenderTimes test below. Returns one of 10 possible
-// tone frequencies to use at the specified time |offset| in the audio.
-double MapTimeOffsetToATone(base::TimeDelta offset) {
-  constexpr double kMinFrequency = 200;
-  constexpr double kMaxFrequency = 2000;
-  constexpr int kNumToneSteps = 10;
-
-  const int64_t step_number = offset / (kTestDuration / kNumToneSteps);
-  const double t = static_cast<double>(step_number) / kNumToneSteps;
-  return kMinFrequency + t * (kMaxFrequency - kMinFrequency);
-}
-
-}  // namespace
-
-// Tests that the SnooperNode can be asked to seek (forward or backward) its
-// Render() positions, as the needs of the system demand.
-TEST_P(SnooperNodeTest, HandlesSeekedRenderTimes) {
-  constexpr base::TimeDelta kQuarterSecond =
-      base::TimeDelta::FromMilliseconds(250);
-
-  CreateNewPipeline();
-
-  // Schedule input tasks where the audio tones are changed once per second, to
-  // allow for identifying the timing of the audio in the consumer's recording
-  // later on.
-  const base::TimeTicks start_time = task_runner()->NowTicks();
-  const base::TimeTicks end_time = start_time + kTestDuration;
-  double time_step = 1.0 / input_params().sample_rate();
-  for (int position = 0;; position += input_params().frames_per_buffer()) {
-    const base::TimeTicks task_time =
-        start_time + base::TimeDelta::FromSecondsD(position * time_step);
-    if (task_time >= end_time) {
-      break;
-    }
-    const base::TimeTicks reference_time = task_time + kInputAdvanceTime;
-    task_runner()->PostDelayedTask(
-        FROM_HERE,
-        base::BindOnce(
-            [](FakeLoopbackGroupMember* group_member,
-               base::TimeTicks start_time, base::TimeTicks reference_time) {
-              group_member->SetChannelTone(
-                  FakeLoopbackGroupMember::kSetAllChannels,
-                  MapTimeOffsetToATone(reference_time - start_time));
-              group_member->RenderMoreAudio(reference_time);
-            },
-            group_member(), start_time, reference_time),
-        task_time - start_time);
-  }
-
-  // Schedule normal render tasks for the first third of the test, then skip
-  // back a quarter-second and run for another third of the test, then skip
-  // forward a quarter-second and run to the end.
-  time_step = 1.0 / output_params().sample_rate();
-  for (int position = 0;; position += output_params().frames_per_buffer()) {
-    const base::TimeTicks task_time =
-        start_time + base::TimeDelta::FromSecondsD(position * time_step);
-    if (task_time >= end_time) {
-      break;
-    }
-    base::TimeDelta time_offset = task_time - start_time;
-    if (time_offset < (kTestDuration / 3) ||
-        time_offset >= (kTestDuration * 2 / 3)) {
-      time_offset = base::TimeDelta();
-    } else {
-      time_offset = -kQuarterSecond;
-    }
-    const base::TimeTicks reference_time =
-        task_time + time_offset - output_delay();
-    task_runner()->PostDelayedTask(
-        FROM_HERE,
-        base::BindOnce(&SnooperNodeTest::RenderAndConsume,
-                       base::Unretained(this), reference_time),
-        task_time - start_time);
-  }
-
-  RunAllPendingTasks();
-
-  // Examine the consumer's recorded audio for the expected audio signal: For
-  // the first third of the test, the consumer should hear the first few tones.
-  // Then, at the point where rendering seeked backward, there will be a
-  // zero-fill gap for a quarter second, followed by the tone changes being
-  // "late" by a quarter second. Finally, at the point where rendering seeked
-  // forward, the tone changes will be shifted back again.
-  const base::TimeDelta lead_in = kInputAdvanceTime + output_delay();
-  for (base::TimeDelta recording_time = lead_in + kQuarterSecond;
-       recording_time < kTestDuration; recording_time += kQuarterSecond) {
-    const base::TimeDelta render_time = recording_time - kInputAdvanceTime;
-
-    base::TimeDelta input_time =
-        recording_time - lead_in - input_params().GetBufferDuration();
-    // The recording is shifted forward during the middle-third of the test.
-    if (render_time >= (kTestDuration / 3) &&
-        render_time < (kTestDuration * 2 / 3)) {
-      input_time -= kQuarterSecond;
-    }
-
-    const double expected_freq = MapTimeOffsetToATone(input_time);
-    SCOPED_TRACE(testing::Message() << "recording_time=" << recording_time
-                                    << ", expected_freq=" << expected_freq);
-    const int position =
-        output_params().sample_rate() * recording_time.InSecondsF() -
-        output_params().frames_per_buffer();
-    if (render_time >= (kTestDuration / 3) &&
-        render_time < (kTestDuration / 3 + kQuarterSecond)) {
-      // Special case: Expect the zero-fill gap immediately after the first
-      // discontinuity.
-      for (int ch = 0; ch < output_params().channels(); ++ch) {
-        EXPECT_TRUE(consumer()->IsSilentInRange(
-            ch, position - output_params().frames_per_buffer(), position));
-      }
-    } else {
-      for (int ch = 0; ch < output_params().channels(); ++ch) {
-        EXPECT_NEAR(kSourceVolume,
-                    consumer()->ComputeAmplitudeAt(ch, expected_freq, position),
-                    kSourceVolume * max_relative_error());
-      }
-    }
-  }
-}
+// TODO: TEST_P(SnooperNodeTest, HandlesSkippingOutput) {}
 
 InputAndOutputParams MakeParams(media::ChannelLayout input_channel_layout,
                                 int input_sample_rate,
@@ -751,8 +376,7 @@
                              output_frames_per_buffer)};
 }
 
-INSTANTIATE_TEST_SUITE_P(
-    ,
+INSTANTIATE_TEST_CASE_P(,
     SnooperNodeTest,
     testing::Values(MakeParams(media::CHANNEL_LAYOUT_STEREO,
                                48000,
--- a/services/audio/stream_factory.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/audio/stream_factory.cc	2019-05-17 18:53:37.784000000 +0300
@@ -6,7 +6,6 @@
 
 #include <utility>
 
-#include "base/bind.h"
 #include "base/strings/stringprintf.h"
 #include "base/trace_event/trace_event.h"
 #include "base/unguessable_token.h"
@@ -54,9 +53,9 @@
   CHECK_EQ(magic_bytes_, 0x600DC0DEu);
   DCHECK_CALLED_ON_VALID_SEQUENCE(owning_sequence_);
   SetStateForCrashing("creating input stream");
-  TRACE_EVENT_NESTABLE_ASYNC_INSTANT2(
+  TRACE_EVENT_NESTABLE_ASYNC_INSTANT1(
       "audio", "CreateInputStream", bindings_.dispatch_context().id_for_trace(),
-      "device id", device_id, "params", params.AsHumanReadableString());
+      "device id", device_id);
 
   if (processing_config && processing_config->settings.requires_apm() &&
       params.GetBufferDuration() != base::TimeDelta::FromMilliseconds(10)) {
@@ -112,10 +111,10 @@
   CHECK_EQ(magic_bytes_, 0x600DC0DEu);
   DCHECK_CALLED_ON_VALID_SEQUENCE(owning_sequence_);
   SetStateForCrashing("creating output stream");
-  TRACE_EVENT_NESTABLE_ASYNC_INSTANT2(
+  TRACE_EVENT_NESTABLE_ASYNC_INSTANT1(
       "audio", "CreateOutputStream",
       bindings_.dispatch_context().id_for_trace(), "device id",
-      output_device_id, "params", params.AsHumanReadableString());
+      output_device_id);
 
   media::mojom::AudioOutputStreamObserverAssociatedPtr observer;
   observer.Bind(std::move(observer_info));
@@ -183,11 +182,10 @@
   CHECK_EQ(magic_bytes_, 0x600DC0DEu);
   DCHECK_CALLED_ON_VALID_SEQUENCE(owning_sequence_);
   SetStateForCrashing("creating loopback stream");
-  TRACE_EVENT_NESTABLE_ASYNC_INSTANT2(
+  TRACE_EVENT_NESTABLE_ASYNC_INSTANT1(
       "audio", "CreateLoopbackStream",
       bindings_.dispatch_context().id_for_trace(), "group id",
-      group_id.GetLowForSerialization(), "params",
-      params.AsHumanReadableString());
+      group_id.GetLowForSerialization());
 
   auto stream = std::make_unique<LoopbackStream>(
       std::move(created_callback),
--- a/services/audio/sync_reader_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/audio/sync_reader_unittest.cc	2019-05-17 18:53:37.788000000 +0300
@@ -10,7 +10,6 @@
 #include <type_traits>
 #include <utility>
 
-#include "base/bind.h"
 #include "base/memory/unsafe_shared_memory_region.h"
 #include "base/sync_socket.h"
 #include "base/test/scoped_task_environment.h"
@@ -112,7 +111,7 @@
   reader.Read(output_bus.get());
 }
 
-INSTANTIATE_TEST_SUITE_P(,
+INSTANTIATE_TEST_CASE_P(,
                          SyncReaderBitstreamTest,
                          ::testing::ValuesIn(overflow_test_case_values));
 
--- a/services/audio/test/audio_system_to_service_adapter_test.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/audio/test/audio_system_to_service_adapter_test.cc	2019-05-17 18:53:37.788000000 +0300
@@ -4,7 +4,6 @@
 
 #include "services/audio/public/cpp/audio_system_to_service_adapter.h"
 
-#include "base/bind.h"
 #include "base/message_loop/message_loop.h"
 #include "base/test/mock_callback.h"
 #include "base/test/scoped_task_environment.h"
@@ -518,7 +517,7 @@
 using AudioSystemToServiceAdapterTestVariations =
     testing::Types<audio::AudioSystemToServiceAdapterTestBase>;
 
-INSTANTIATE_TYPED_TEST_SUITE_P(AudioSystemToServiceAdapter,
+INSTANTIATE_TYPED_TEST_CASE_P(AudioSystemToServiceAdapter,
                                AudioSystemTestTemplate,
                                AudioSystemToServiceAdapterTestVariations);
 }  // namespace media
--- a/services/audio/test/debug_recording_session_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/audio/test/debug_recording_session_unittest.cc	2019-05-17 18:53:37.788000000 +0300
@@ -7,7 +7,6 @@
 #include <limits>
 #include <memory>
 
-#include "base/bind.h"
 #include "base/files/file_path.h"
 #include "base/files/file_util.h"
 #include "base/files/scoped_temp_dir.h"
@@ -30,9 +29,9 @@
 namespace {
 
 #if defined(OS_WIN)
-#define NumberToStringType base::NumberToString16
+#define IntToStringType base::IntToString16
 #else
-#define NumberToStringType base::NumberToString
+#define IntToStringType base::IntToString
 #endif
 
 const base::FilePath::CharType kBaseFileName[] =
@@ -62,7 +61,7 @@
   base::FilePath GetFileName(const base::FilePath::StringType& stream_type,
                              uint32_t id) {
     return file_path_.AddExtension(stream_type)
-        .AddExtension(NumberToStringType(id))
+        .AddExtension(IntToStringType(id))
         .AddExtension(kWavExtension);
   }
 
@@ -184,7 +183,7 @@
   scoped_task_environment_.RunUntilIdle();
 
   base::FilePath file_name(
-      GetFileName(NumberToStringType(invalid_stream_type), id));
+      GetFileName(IntToStringType(invalid_stream_type), id));
   EXPECT_FALSE(base::PathExists(file_name));
 }
 
--- a/services/audio/test/fake_consumer.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/audio/test/fake_consumer.cc	2019-05-17 18:53:37.788000000 +0300
@@ -6,18 +6,10 @@
 
 #include <algorithm>
 #include <cmath>
-#include <memory>
-#include <utility>
 
-#include "base/files/file.h"
 #include "base/logging.h"
 #include "base/numerics/math_constants.h"
-#include "base/task/task_scheduler/task_scheduler.h"
-#include "base/test/scoped_task_environment.h"
-#include "media/audio/audio_debug_file_writer.h"
 #include "media/base/audio_bus.h"
-#include "media/base/audio_parameters.h"
-#include "media/base/channel_layout.h"
 
 namespace audio {
 
@@ -119,30 +111,4 @@
          normalization_factor;
 }
 
-void FakeConsumer::SaveToFile(const base::FilePath& path) const {
-  // Not all tests set-up a full task environment. However, AudioDebugFileWriter
-  // requires one. Provide a temporary one here, if necessary.
-  std::unique_ptr<base::test::ScopedTaskEnvironment> task_environment;
-  if (!base::TaskScheduler::GetInstance()) {
-    task_environment = std::make_unique<base::test::ScopedTaskEnvironment>();
-  }
-
-  const media::AudioParameters params(
-      media::AudioParameters::AUDIO_PCM_LOW_LATENCY,
-      media::GuessChannelLayout(recorded_channel_data_.size()), sample_rate_,
-      recorded_channel_data_[0].size());
-  media::AudioDebugFileWriter writer(params);
-  base::File file(path, base::File::FLAG_CREATE_ALWAYS | base::File::FLAG_READ |
-                            base::File::FLAG_WRITE);
-  CHECK(file.IsValid());
-  writer.Start(std::move(file));
-  auto bus = media::AudioBus::Create(params);
-  for (int i = 0; i < params.channels(); ++i) {
-    memcpy(bus->channel(i), recorded_channel_data_[i].data(),
-           sizeof(float) * recorded_channel_data_[i].size());
-  }
-  writer.Write(std::move(bus));
-  writer.Stop();
-}
-
 }  // namespace audio
--- a/services/audio/test/fake_consumer.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/audio/test/fake_consumer.h	2019-05-17 18:53:37.788000000 +0300
@@ -7,7 +7,6 @@
 
 #include <vector>
 
-#include "base/files/file_path.h"
 #include "base/macros.h"
 
 namespace media {
@@ -48,10 +47,6 @@
   // before the given |end_frame| position.
   double ComputeAmplitudeAt(int channel, double frequency, int end_frame) const;
 
-  // Saves the recorded content to a WAV-format file, overwriting it if it
-  // exists.
-  void SaveToFile(const base::FilePath& path) const;
-
  private:
   const int sample_rate_;
   std::vector<std::vector<float>> recorded_channel_data_;
--- a/services/audio/test/fake_loopback_group_member.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/audio/test/fake_loopback_group_member.cc	2019-05-17 18:53:37.788000000 +0300
@@ -25,15 +25,7 @@
 FakeLoopbackGroupMember::~FakeLoopbackGroupMember() = default;
 
 void FakeLoopbackGroupMember::SetChannelTone(int ch, double frequency) {
-  if (ch == kSetAllChannels) {
-    for (double& channel_frequency : frequency_by_channel_) {
-      channel_frequency = frequency;
-    }
-  } else {
-    CHECK_LE(0, ch);
-    CHECK_LT(ch, params_.channels());
     frequency_by_channel_[ch] = frequency;
-  }
 }
 
 void FakeLoopbackGroupMember::SetVolume(double volume) {
--- a/services/audio/test/fake_loopback_group_member.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/audio/test/fake_loopback_group_member.h	2019-05-17 18:53:37.788000000 +0300
@@ -33,9 +33,7 @@
   ~FakeLoopbackGroupMember() override;
 
   // Sets the sine wave |frequency| rendered into channel |ch|. Note that
-  // setting the frequency to zero will zero-out the channel signal. For
-  // convenience, pass |kSetAllChannels| for |ch| to set all channels to the
-  // same frequency.
+  // setting the frequency to zero will zero-out the channel signal.
   void SetChannelTone(int ch, double frequency);
 
   // Sets the volume of this FakeLoopbackGroupMember. This simulates the current
@@ -55,8 +53,6 @@
   void StartMuting() override;
   void StopMuting() override;
 
-  static constexpr int kSetAllChannels = -1;
-
  private:
   const media::AudioParameters params_;
   const std::unique_ptr<media::AudioBus> audio_bus_;
--- a/services/audio/test/in_process_service_test.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/audio/test/in_process_service_test.cc	2019-05-17 18:53:37.788000000 +0300
@@ -2,7 +2,6 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "base/bind.h"
 #include "base/test/scoped_task_environment.h"
 #include "media/audio/audio_system_test_util.h"
 #include "media/audio/mock_audio_manager.h"
@@ -11,16 +10,14 @@
 #include "services/audio/in_process_audio_manager_accessor.h"
 #include "services/audio/public/cpp/audio_system_to_service_adapter.h"
 #include "services/audio/public/cpp/fake_system_info.h"
-#include "services/audio/public/cpp/manifest.h"
 #include "services/audio/public/mojom/constants.mojom.h"
 #include "services/audio/service.h"
 #include "services/audio/test/service_lifetime_test_template.h"
+#include "services/audio/tests_catalog_source.h"
 #include "services/service_manager/public/cpp/binder_registry.h"
-#include "services/service_manager/public/cpp/manifest_builder.h"
 #include "services/service_manager/public/cpp/service.h"
 #include "services/service_manager/public/cpp/service_binding.h"
 #include "services/service_manager/public/cpp/test/test_service_manager.h"
-#include "services/service_manager/public/mojom/constants.mojom.h"
 #include "services/service_manager/public/mojom/service_factory.mojom.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
@@ -130,8 +127,6 @@
   DISALLOW_COPY_AND_ASSIGN(ServiceTestHelper);
 };
 
-const char kTestServiceName[] = "audio_unittests";
-
 // if |use_audio_thread| is true, AudioManager has a dedicated audio thread and
 // Audio service lives on it; otherwise audio thread is the main thread of the
 // test fixture, and that's where Service lives. So in the former case the
@@ -142,24 +137,13 @@
 class InProcessServiceTest : public testing::Test {
  public:
   explicit InProcessServiceTest(base::TimeDelta service_quit_timeout)
-      : test_service_manager_(
-            {service_manager::ManifestBuilder()
-                 .WithServiceName(kTestServiceName)
-                 .ExposeCapability(
-                     "service_manager:service_factory",
-                     service_manager::Manifest::InterfaceList<
-                         service_manager::mojom::ServiceFactory>())
-                 .RequireCapability(mojom::kServiceName, "info")
-                 .RequireCapability(service_manager::mojom::kServiceName,
-                                    "service_manager:service_manager")
-                 .PackageService(GetManifest())
-                 .Build()}),
+      : test_service_manager_(CreateUnittestCatalog()),
         audio_manager_(
             std::make_unique<media::TestAudioThread>(use_audio_thread)),
         helper_(std::make_unique<ServiceTestHelper>(
             &audio_manager_,
             service_quit_timeout,
-            test_service_manager_.RegisterTestInstance(kTestServiceName))),
+            test_service_manager_.RegisterTestInstance("audio_unittests"))),
         audio_system_(std::make_unique<AudioSystemToServiceAdapter>(
             connector()->Clone())) {}
 
@@ -242,7 +226,7 @@
   DISALLOW_COPY_AND_ASSIGN(InProcessServiceLifetimeTestBase);
 };
 
-INSTANTIATE_TYPED_TEST_SUITE_P(InProcessAudioService,
+INSTANTIATE_TYPED_TEST_CASE_P(InProcessAudioService,
                                ServiceLifetimeTestTemplate,
                                InProcessServiceLifetimeTestBase);
 
@@ -256,7 +240,7 @@
     testing::Types<audio::InProcessServiceTest<false>,
                    audio::InProcessServiceTest<true>>;
 
-INSTANTIATE_TYPED_TEST_SUITE_P(InProcessAudioService,
+INSTANTIATE_TYPED_TEST_CASE_P(InProcessAudioService,
                                AudioSystemTestTemplate,
                                AudioSystemTestVariations);
 
--- a/services/audio/test/service_lifetime_connector_test.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/audio/test/service_lifetime_connector_test.cc	2019-05-17 18:53:37.788000000 +0300
@@ -2,7 +2,6 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "base/bind.h"
 #include "base/run_loop.h"
 #include "base/test/mock_callback.h"
 #include "base/test/scoped_task_environment.h"
--- a/services/audio/test/service_lifetime_test_template.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/audio/test/service_lifetime_test_template.h	2019-05-17 18:53:37.788000000 +0300
@@ -48,7 +48,7 @@
   DISALLOW_COPY_AND_ASSIGN(ServiceLifetimeTestTemplate);
 };
 
-TYPED_TEST_SUITE_P(ServiceLifetimeTestTemplate);
+TYPED_TEST_CASE_P(ServiceLifetimeTestTemplate);
 
 TYPED_TEST_P(ServiceLifetimeTestTemplate, ServiceQuitsWhenClientDisconnects) {
   mojom::SystemInfoPtr info;
@@ -132,7 +132,7 @@
   }
 }
 
-REGISTER_TYPED_TEST_SUITE_P(ServiceLifetimeTestTemplate,
+REGISTER_TYPED_TEST_CASE_P(ServiceLifetimeTestTemplate,
                             ServiceQuitsWhenClientDisconnects,
                             ServiceQuitsWhenLastClientDisconnects,
                             ServiceRestartsWhenClientReconnects);
--- a/services/audio/test/service_observer_mock.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/audio/test/service_observer_mock.cc	2019-05-17 18:53:37.788000000 +0300
@@ -11,7 +11,7 @@
     service_manager::mojom::ServiceManagerListenerRequest request)
     : service_name_(service_name), binding_(this, std::move(request)) {}
 
-ServiceObserverMock::~ServiceObserverMock() {}
+ServiceObserverMock::~ServiceObserverMock(){};
 
 void ServiceObserverMock::OnInit(
     std::vector<service_manager::mojom::RunningServiceInfoPtr> instances) {
--- a/services/audio/test/standalone_service_test.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/audio/test/standalone_service_test.cc	2019-05-17 18:53:37.788000000 +0300
@@ -6,31 +6,19 @@
 #include "base/strings/string_number_conversions.h"
 #include "base/test/scoped_task_environment.h"
 #include "media/base/media_switches.h"
-#include "services/audio/public/cpp/manifest.h"
-#include "services/audio/public/mojom/constants.mojom.h"
 #include "services/audio/service.h"
+#include "services/audio/standalone_unittest_catalog_source.h"
 #include "services/audio/test/service_lifetime_test_template.h"
-#include "services/service_manager/public/cpp/manifest_builder.h"
 #include "services/service_manager/public/cpp/test/test_service.h"
 #include "services/service_manager/public/cpp/test/test_service_manager.h"
-#include "services/service_manager/public/mojom/constants.mojom.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
 namespace audio {
 
-const char kTestServiceName[] = "audio_unittests";
-
 class StandaloneAudioServiceTest : public testing::Test {
  public:
   StandaloneAudioServiceTest()
-      : test_service_manager_(
-            {GetManifest(),
-             service_manager::ManifestBuilder()
-                 .WithServiceName(kTestServiceName)
-                 .RequireCapability(mojom::kServiceName, "info")
-                 .RequireCapability(service_manager::mojom::kServiceName,
-                                    "service_manager:service_manager")
-                 .Build()}),
+      : test_service_manager_(CreateStandaloneUnittestCatalog()),
         test_service_(
             test_service_manager_.RegisterTestInstance("audio_unittests")) {}
 
@@ -40,7 +28,7 @@
   void SetUp() override {
     base::CommandLine* cmd_line = base::CommandLine::ForCurrentProcess();
     cmd_line->AppendSwitchASCII(switches::kAudioServiceQuitTimeoutMs,
-                                base::NumberToString(10));
+                                base::UintToString(10));
   }
 
  private:
@@ -51,7 +39,7 @@
   DISALLOW_COPY_AND_ASSIGN(StandaloneAudioServiceTest);
 };
 
-INSTANTIATE_TYPED_TEST_SUITE_P(StandaloneAudioService,
+INSTANTIATE_TYPED_TEST_CASE_P(StandaloneAudioService,
                                ServiceLifetimeTestTemplate,
                                StandaloneAudioServiceTest);
 }  // namespace audio
--- a/services/BUILD.gn	2019-05-17 17:45:42.492000000 +0300
+++ b/services/BUILD.gn	2019-05-17 18:53:37.772000000 +0300
@@ -13,7 +13,7 @@
 # service subdirectory and add it as a dependency here.
 test("services_unittests") {
   # If your service does not run on iOS, its tests should go in the !iOS
-  # section below. If you are unsure, contact blundell@ch40m1um.qjz9zk.
+  # section below. If you are unsure, contact blundell@chromium.org.
   deps = [
     "//services/content:tests",
     "//services/identity:tests",
@@ -84,7 +84,6 @@
 if (!is_ios) {
   test("services_perftests") {
     deps = [
-      "//services/device:perftests",
       "//services/test:run_all_unittests",
       "//services/viz/public/cpp/compositing:perftests",
     ]
--- a/services/content/BUILD.gn	2019-05-01 01:22:56.000000000 +0300
+++ b/services/content/BUILD.gn	2019-05-17 18:53:37.792000000 +0300
@@ -4,6 +4,7 @@
 
 import("//build/config/ui.gni")
 import("//services/content/public/features.gni")
+import("//services/service_manager/public/service_manifest.gni")
 
 source_set("impl") {
   visibility = [
@@ -75,3 +76,8 @@
     "//url",
   ]
 }
+
+service_manifest("manifest") {
+  name = "content"
+  source = "manifest.json"
+}
--- a/services/content/navigable_contents_impl.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/content/navigable_contents_impl.cc	2019-05-17 18:53:37.792000000 +0300
@@ -58,12 +58,12 @@
   delegate_->GoBack(std::move(callback));
 }
 
-void NavigableContentsImpl::CreateView(bool use_window_service,
+void NavigableContentsImpl::CreateView(bool in_service_process,
                                        CreateViewCallback callback) {
   DCHECK(native_content_view_);
 
 #if BUILDFLAG(ENABLE_REMOTE_NAVIGABLE_CONTENTS_VIEW)
-  if (use_window_service) {
+  if (!in_service_process) {
     remote_view_provider_ =
         std::make_unique<views::RemoteViewProvider>(native_content_view_);
     remote_view_provider_->GetEmbedToken(
@@ -72,7 +72,7 @@
     return;
   }
 #else
-  if (use_window_service) {
+  if (!in_service_process) {
     DLOG(ERROR) << "Remote NavigableContentsView clients are not supported on "
                 << "this platform.";
     return;
--- a/services/content/OWNERS	2019-05-01 01:22:56.000000000 +0300
+++ b/services/content/OWNERS	2019-05-17 18:53:37.792000000 +0300
@@ -2,3 +2,6 @@
 clamy@chromium.org
 jam@chromium.org
 rockot@google.com
+
+per-file manifest.json=set noparent
+per-file manifest.json=file://ipc/SECURITY_OWNERS
--- a/services/content/public/cpp/BUILD.gn	2019-05-01 01:22:56.000000000 +0300
+++ b/services/content/public/cpp/BUILD.gn	2019-05-17 18:53:37.792000000 +0300
@@ -56,16 +56,3 @@
     deps += [ "//ui/aura" ]
   }
 }
-
-source_set("manifest") {
-  sources = [
-    "manifest.cc",
-    "manifest.h",
-  ]
-
-  deps = [
-    "//base",
-    "//services/content/public/mojom",
-    "//services/service_manager/public/cpp",
-  ]
-}
--- a/services/content/public/cpp/navigable_contents.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/content/public/cpp/navigable_contents.cc	2019-05-17 18:53:37.796000000 +0300
@@ -4,7 +4,6 @@
 
 #include "services/content/public/cpp/navigable_contents.h"
 
-#include "base/bind.h"
 #include "base/memory/ptr_util.h"
 #include "services/content/public/cpp/navigable_contents_view.h"
 
@@ -36,7 +35,7 @@
   if (!view_) {
     view_ = base::WrapUnique(new NavigableContentsView(this));
     contents_->CreateView(
-        ShouldUseWindowService(),
+        NavigableContentsView::IsClientRunningInServiceProcess(),
         base::BindOnce(&NavigableContents::OnEmbedTokenReceived,
                        base::Unretained(this)));
   }
@@ -65,18 +64,6 @@
   contents_->FocusThroughTabTraversal(reverse);
 }
 
-void NavigableContents::ForceUseWindowService() {
-  // This should only be called before |view_| is created.
-  DCHECK(!view_);
-
-  force_use_window_service_ = true;
-}
-
-bool NavigableContents::ShouldUseWindowService() const {
-  return !NavigableContentsView::IsClientRunningInServiceProcess() ||
-         force_use_window_service_;
-}
-
 void NavigableContents::ClearViewFocus() {
   if (view_)
     view_->ClearNativeFocus();
--- a/services/content/public/cpp/navigable_contents.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/content/public/cpp/navigable_contents.h	2019-05-17 18:53:37.796000000 +0300
@@ -69,13 +69,6 @@
   // being done via Tab-key cycling or a similar mechanism.
   void FocusThroughTabTraversal(bool reverse);
 
-  // Force NavigableContents to use Window Service for embedding. Note this must
-  // be called before its view is created.
-  void ForceUseWindowService();
-
-  // Whether to use Window Service for embedding.
-  bool ShouldUseWindowService() const;
-
  private:
   // mojom::NavigableContentsClient:
   void ClearViewFocus() override;
@@ -101,8 +94,6 @@
 
   ui::AXTreeID content_ax_tree_id_;
 
-  bool force_use_window_service_ = false;
-
   DISALLOW_COPY_AND_ASSIGN(NavigableContents);
 };
 
--- a/services/content/public/cpp/navigable_contents_view.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/content/public/cpp/navigable_contents_view.cc	2019-05-17 18:53:37.796000000 +0300
@@ -6,7 +6,6 @@
 
 #include <map>
 
-#include "base/bind_helpers.h"
 #include "base/callback.h"
 #include "base/no_destructor.h"
 #include "base/synchronization/atomic_flag.h"
@@ -164,7 +163,7 @@
     : contents_(contents) {
 #if defined(TOOLKIT_VIEWS) && defined(USE_AURA)
 #if BUILDFLAG(ENABLE_REMOTE_NAVIGABLE_CONTENTS_VIEW)
-  if (contents_->ShouldUseWindowService()) {
+  if (!IsClientRunningInServiceProcess()) {
     RemoteViewManager* manager = GetRemoteViewManager().get();
     if (manager)
       view_ = manager->CreateRemoteViewHost();
@@ -201,7 +200,7 @@
     const base::UnguessableToken& token) {
 #if defined(TOOLKIT_VIEWS)
 #if BUILDFLAG(ENABLE_REMOTE_NAVIGABLE_CONTENTS_VIEW)
-  if (contents_->ShouldUseWindowService()) {
+  if (!IsClientRunningInServiceProcess()) {
     RemoteViewManager* manager = GetRemoteViewManager().get();
     if (manager) {
       manager->EmbedUsingToken(view_.get(), token);
--- a/services/content/public/cpp/test/fake_navigable_contents.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/content/public/cpp/test/fake_navigable_contents.cc	2019-05-17 18:53:37.796000000 +0300
@@ -5,7 +5,6 @@
 #include "services/content/public/cpp/test/fake_navigable_contents.h"
 
 #include "base/bind.h"
-#include "base/bind_helpers.h"
 #include "base/unguessable_token.h"
 #include "services/content/public/cpp/navigable_contents_view.h"
 #include "services/content/public/cpp/test/fake_navigable_contents_factory.h"
--- a/services/content/public/cpp/test/fake_navigable_contents_factory_unittest.cc	2019-05-17 17:45:42.496000000 +0300
+++ b/services/content/public/cpp/test/fake_navigable_contents_factory_unittest.cc	2019-05-17 18:53:37.796000000 +0300
@@ -100,7 +100,7 @@
   FakeNavigableContents contents_impl;
   factory().WaitForAndBindNextContentsRequest(&contents_impl);
 
-  const GURL kTestUrl("https://www.9oo91e.qjz9zk/");
+  const GURL kTestUrl("https://www.google.com/");
   contents.Navigate(kTestUrl);
 
   NavigationObserver observer(&contents);
@@ -121,8 +121,8 @@
   FakeNavigableContents contents2_impl;
   factory().WaitForAndBindNextContentsRequest(&contents2_impl);
 
-  const GURL kTestUrl1("https://www.9oo91e.qjz9zk/?q=cats");
-  const GURL kTestUrl2("https://www.9oo91e.qjz9zk/?q=dogs");
+  const GURL kTestUrl1("https://www.google.com/?q=cats");
+  const GURL kTestUrl2("https://www.google.com/?q=dogs");
   contents1.Navigate(kTestUrl1);
   contents2.Navigate(kTestUrl2);
 
@@ -157,7 +157,7 @@
   test_headers->AddHeader(kTestHeader2 + ": " + kTestHeaderValue2);
   contents_impl.set_default_response_headers(test_headers);
 
-  const GURL kTestUrl("https://www.9oo91e.qjz9zk/");
+  const GURL kTestUrl("https://www.google.com/");
   contents.Navigate(kTestUrl);
 
   NavigationObserver observer(&contents);
--- a/services/content/public/mojom/navigable_contents.mojom	2019-05-01 01:22:56.000000000 +0300
+++ b/services/content/public/mojom/navigable_contents.mojom	2019-05-17 18:53:37.796000000 +0300
@@ -37,13 +37,14 @@
   // be given to Mus in order to authorize embedding of that visual
   // representation within the client application's own window tree.
   //
-  // |use_window_service| is true when the client calling this method wants to
-  // use Window Service for embedding. This is the case when the client and the
-  // Content Service are using different window trees.
+  // |in_service_process| must be true iff the client calling this method is
+  // running in the same process as the Content Service. This can be known in
+  // the client by calling
+  // |NavigableContentsView::IsClientRunningInServiceProcess()|.
   //
-  // TODO(https://crbug.com/874143): Remove the |use_window_service| flag once
+  // TODO(https://crbug.com/874143): Remove the |in_service_process| flag once
   // we have more widely available UI Service support.
-  CreateView(bool use_window_service)
+  CreateView(bool in_service_process)
       => (mojo_base.mojom.UnguessableToken embed_token);
 
   // Attempts to transfer global input focus to the navigated contents if they
--- a/services/content/service_delegate.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/content/service_delegate.h	2019-05-17 18:53:37.796000000 +0300
@@ -38,6 +38,6 @@
                                   mojom::NavigableContentsClient* client) = 0;
 };
 
-}  // namespace content
+};  // namespace content
 
 #endif  // SERVICES_CONTENT_CONTENT_SERVICE_DELEGATE_H_
--- a/services/content/service.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/content/service.h	2019-05-17 18:53:37.796000000 +0300
@@ -69,6 +69,6 @@
   DISALLOW_COPY_AND_ASSIGN(Service);
 };
 
-}  // namespace content
+};  // namespace content
 
 #endif  // SERVICES_CONTENT_SERVICE_H_
--- a/services/content/simple_browser/BUILD.gn	2019-05-01 01:22:56.000000000 +0300
+++ b/services/content/simple_browser/BUILD.gn	2019-05-17 18:53:37.796000000 +0300
@@ -4,6 +4,7 @@
 
 import("//build/config/ui.gni")
 import("//services/content/public/features.gni")
+import("//services/service_manager/public/service_manifest.gni")
 
 component("simple_browser") {
   public = [
@@ -50,3 +51,8 @@
     ]
   }
 }
+
+service_manifest("manifest") {
+  name = "simple_browser"
+  source = "manifest.json"
+}
--- a/services/content/simple_browser/OWNERS	2019-05-01 01:22:56.000000000 +0300
+++ b/services/content/simple_browser/OWNERS	2019-05-17 18:53:37.796000000 +0300
@@ -0,0 +1,2 @@
+per-file manifest.json=set noparent
+per-file manifest.json=file://ipc/SECURITY_OWNERS
--- a/services/data_decoder/BUILD.gn	2019-05-01 01:22:56.000000000 +0300
+++ b/services/data_decoder/BUILD.gn	2019-05-17 18:53:37.796000000 +0300
@@ -2,6 +2,7 @@
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
+import("//services/service_manager/public/service_manifest.gni")
 import("//testing/libfuzzer/fuzzer_test.gni")
 
 source_set("lib") {
@@ -69,6 +70,11 @@
   ]
 }
 
+service_manifest("manifest") {
+  name = "data_decoder"
+  source = "manifest.json"
+}
+
 fuzzer_test("xml_parser_fuzzer") {
   sources = [
     "xml_parser_fuzzer.cc",
--- a/services/data_decoder/json_parser_impl.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/data_decoder/json_parser_impl.cc	2019-05-17 18:53:37.796000000 +0300
@@ -21,9 +21,8 @@
 void JsonParserImpl::Parse(const std::string& json, ParseCallback callback) {
   int error_code;
   std::string error;
-  std::unique_ptr<base::Value> value =
-      base::JSONReader::ReadAndReturnErrorDeprecated(json, base::JSON_PARSE_RFC,
-                                                     &error_code, &error);
+  std::unique_ptr<base::Value> value = base::JSONReader::ReadAndReturnError(
+      json, base::JSON_PARSE_RFC, &error_code, &error);
   if (value) {
     std::move(callback).Run(base::make_optional(std::move(*value)),
                             base::nullopt);
--- a/services/data_decoder/OWNERS	2019-05-01 01:22:56.000000000 +0300
+++ b/services/data_decoder/OWNERS	2019-05-17 18:53:37.796000000 +0300
@@ -1,3 +1,5 @@
+per-file manifest.json=set noparent
+per-file manifest.json=file://ipc/SECURITY_OWNERS
 
 jcivelli@chromium.org
 rsesek@chromium.org
--- a/services/data_decoder/public/cpp/BUILD.gn	2019-05-01 01:22:56.000000000 +0300
+++ b/services/data_decoder/public/cpp/BUILD.gn	2019-05-17 18:53:37.800000000 +0300
@@ -55,16 +55,3 @@
     "//services/service_manager/public/cpp/test:test_support",
   ]
 }
-
-source_set("manifest") {
-  sources = [
-    "manifest.cc",
-    "manifest.h",
-  ]
-
-  deps = [
-    "//base",
-    "//services/data_decoder/public/mojom",
-    "//services/service_manager/public/cpp",
-  ]
-}
--- a/services/data_decoder/public/cpp/decode_image.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/data_decoder/public/cpp/decode_image.cc	2019-05-17 18:53:37.800000000 +0300
@@ -6,7 +6,6 @@
 
 #include <utility>
 
-#include "base/bind.h"
 #include "base/bind_helpers.h"
 #include "services/data_decoder/public/mojom/constants.mojom.h"
 #include "services/service_manager/public/cpp/connector.h"
--- a/services/data_decoder/public/cpp/json_sanitizer_android.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/data_decoder/public/cpp/json_sanitizer_android.cc	2019-05-17 18:53:37.800000000 +0300
@@ -77,12 +77,12 @@
 
 void JsonSanitizerAndroid::OnSuccess(const std::string& json) {
   base::SequencedTaskRunnerHandle::Get()->PostTask(
-      FROM_HERE, base::BindOnce(success_callback_, json));
+      FROM_HERE, base::Bind(success_callback_, json));
 }
 
 void JsonSanitizerAndroid::OnError(const std::string& error) {
   base::SequencedTaskRunnerHandle::Get()->PostTask(
-      FROM_HERE, base::BindOnce(error_callback_, error));
+      FROM_HERE, base::Bind(error_callback_, error));
 }
 
 }  // namespace
--- a/services/data_decoder/public/cpp/json_sanitizer_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/data_decoder/public/cpp/json_sanitizer_unittest.cc	2019-05-17 18:53:37.800000000 +0300
@@ -62,15 +62,14 @@
 void JsonSanitizerTest::CheckSuccess(const std::string& json) {
   SCOPED_TRACE(json);
   Sanitize(json);
-  std::unique_ptr<base::Value> parsed = base::JSONReader::ReadDeprecated(json);
+  std::unique_ptr<base::Value> parsed = base::JSONReader::Read(json);
   ASSERT_TRUE(parsed);
   EXPECT_EQ(State::STATE_SUCCESS, state_) << "Error: " << error_;
 
   // The JSON parser should accept the result.
   int error_code;
   std::string error;
-  std::unique_ptr<base::Value> reparsed =
-      base::JSONReader::ReadAndReturnErrorDeprecated(
+  std::unique_ptr<base::Value> reparsed = base::JSONReader::ReadAndReturnError(
           result_, base::JSON_PARSE_RFC, &error_code, &error);
   EXPECT_TRUE(reparsed) << "Invalid result: " << error;
 
--- a/services/data_decoder/public/cpp/safe_json_parser_android.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/data_decoder/public/cpp/safe_json_parser_android.cc	2019-05-17 18:53:37.800000000 +0300
@@ -40,8 +40,7 @@
 
   int error_code;
   std::string error;
-  std::unique_ptr<base::Value> value =
-      base::JSONReader::ReadAndReturnErrorDeprecated(
+  std::unique_ptr<base::Value> value = base::JSONReader::ReadAndReturnError(
           sanitized_json, base::JSON_PARSE_RFC, &error_code, &error);
 
   if (!value) {
--- a/services/data_decoder/public/cpp/safe_json_parser_impl.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/data_decoder/public/cpp/safe_json_parser_impl.cc	2019-05-17 18:53:37.800000000 +0300
@@ -4,7 +4,6 @@
 
 #include "services/data_decoder/public/cpp/safe_json_parser_impl.h"
 
-#include "base/bind.h"
 #include "base/callback.h"
 #include "base/sequenced_task_runner.h"
 #include "base/strings/string_number_conversions.h"
--- a/services/data_decoder/public/cpp/testing_json_parser.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/data_decoder/public/cpp/testing_json_parser.cc	2019-05-17 18:53:37.800000000 +0300
@@ -47,8 +47,7 @@
 void TestingJsonParser::Start() {
   int error_code;
   std::string error;
-  std::unique_ptr<base::Value> value =
-      base::JSONReader::ReadAndReturnErrorDeprecated(
+  std::unique_ptr<base::Value> value = base::JSONReader::ReadAndReturnError(
           unsafe_json_, base::JSON_PARSE_RFC, &error_code, &error);
 
   // Run the callback asynchronously. Post the delete task first, so that the
--- a/services/device/battery/battery_monitor_impl_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/battery/battery_monitor_impl_unittest.cc	2019-05-17 18:53:37.808000000 +0300
@@ -6,7 +6,6 @@
 
 #include <utility>
 
-#include "base/bind.h"
 #include "base/macros.h"
 #include "base/run_loop.h"
 #include "base/threading/thread_task_runner_handle.h"
@@ -59,7 +58,7 @@
   void InvokeUpdateCallback() {
     // Invoke asynchronously to mimic the OS-specific battery managers.
     base::ThreadTaskRunnerHandle::Get()->PostTask(
-        FROM_HERE, base::BindOnce(callback_, status_));
+        FROM_HERE, base::Bind(callback_, status_));
   }
 
   void set_battery_status(const mojom::BatteryStatus& status) {
--- a/services/device/battery/battery_status_manager_chromeos.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/battery/battery_status_manager_chromeos.cc	2019-05-17 18:53:37.808000000 +0300
@@ -29,7 +29,7 @@
     if (currently_listening_)
       return;
     chromeos::PowerManagerClient* power_client =
-        chromeos::PowerManagerClient::Get();
+        chromeos::DBusThreadManager::Get()->GetPowerManagerClient();
     power_client->AddObserver(this);
     power_client->RequestStatusUpdate();
     currently_listening_ = true;
@@ -39,7 +39,8 @@
   void Stop() {
     if (!currently_listening_)
       return;
-    chromeos::PowerManagerClient::Get()->RemoveObserver(this);
+    chromeos::DBusThreadManager::Get()->GetPowerManagerClient()->RemoveObserver(
+        this);
     currently_listening_ = false;
   }
 
--- a/services/device/battery/battery_status_manager_default.cc	2019-05-17 17:45:28.340000000 +0300
+++ b/services/device/battery/battery_status_manager_default.cc	2019-05-17 18:53:37.808000000 +0300
@@ -22,10 +22,11 @@
  private:
   // BatteryStatusManager:
   bool StartListeningBatteryChange() override {
+    NOTIMPLEMENTED();
     return false;
   }
 
-  void StopListeningBatteryChange() override { }
+  void StopListeningBatteryChange() override { NOTIMPLEMENTED(); }
 
   DISALLOW_COPY_AND_ASSIGN(BatteryStatusManagerDefault);
 };
--- a/services/device/battery/battery_status_manager_linux.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/battery/battery_status_manager_linux.cc	2019-05-17 18:53:37.808000000 +0300
@@ -13,8 +13,6 @@
 #include <utility>
 #include <vector>
 
-#include "base/bind.h"
-#include "base/bind_helpers.h"
 #include "base/macros.h"
 #include "base/message_loop/message_loop.h"
 #include "base/metrics/histogram_macros.h"
@@ -325,7 +323,7 @@
     // end. It needs to happen on the BatteryStatusNotificationThread.
     task_runner()->PostTask(
         FROM_HERE,
-        base::BindOnce(&BatteryStatusNotificationThread::ShutdownDBusConnection,
+        base::Bind(&BatteryStatusNotificationThread::ShutdownDBusConnection,
                        base::Unretained(this)));
 
     // Drain the message queue of the BatteryStatusNotificationThread and stop.
@@ -478,7 +476,7 @@
     // Shutdown DBus connection later because there may be pending tasks on
     // this thread.
     task_runner()->PostTask(
-        FROM_HERE, base::BindOnce(&dbus::Bus::ShutdownAndBlock, system_bus_));
+        FROM_HERE, base::Bind(&dbus::Bus::ShutdownAndBlock, system_bus_));
     system_bus_ = nullptr;
   }
 
@@ -584,8 +582,7 @@
     return false;
 
   notifier_thread_->task_runner()->PostTask(
-      FROM_HERE,
-      base::BindOnce(&BatteryStatusNotificationThread::StartListening,
+      FROM_HERE, base::Bind(&BatteryStatusNotificationThread::StartListening,
                      base::Unretained(notifier_thread_.get())));
   return true;
 }
@@ -595,7 +592,7 @@
     return;
 
   notifier_thread_->task_runner()->PostTask(
-      FROM_HERE, base::BindOnce(&BatteryStatusNotificationThread::StopListening,
+      FROM_HERE, base::Bind(&BatteryStatusNotificationThread::StopListening,
                                 base::Unretained(notifier_thread_.get())));
 }
 
--- a/services/device/battery/battery_status_manager_linux_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/battery/battery_status_manager_linux_unittest.cc	2019-05-17 18:53:37.808000000 +0300
@@ -470,8 +470,8 @@
 void BatteryStatusManagerLinuxTest::DeviceSignalChanged(
     MockBatteryObject* device) {
   manager_->GetNotifierThreadForTesting()->task_runner()->PostTask(
-      FROM_HERE, base::BindOnce(&MockBatteryObject::SignalChanged,
-                                base::Unretained(device)));
+      FROM_HERE,
+      base::Bind(&MockBatteryObject::SignalChanged, base::Unretained(device)));
   SyncWithNotifierThread();
 }
 
@@ -479,7 +479,7 @@
     MockBatteryObject* device,
     const std::string& property_name) {
   manager_->GetNotifierThreadForTesting()->task_runner()->PostTask(
-      FROM_HERE, base::BindOnce(&MockBatteryObject::SignalPropertyChanged,
+      FROM_HERE, base::Bind(&MockBatteryObject::SignalPropertyChanged,
                                 base::Unretained(device), property_name));
   SyncWithNotifierThread();
 }
@@ -488,7 +488,7 @@
     const std::string& device_path) {
   ASSERT_FALSE(mock_upower_.signal_callback_device_added.is_null());
   manager_->GetNotifierThreadForTesting()->task_runner()->PostTask(
-      FROM_HERE, base::BindOnce(&MockUPowerObject::SignalDeviceAdded,
+      FROM_HERE, base::Bind(&MockUPowerObject::SignalDeviceAdded,
                                 base::Unretained(&mock_upower_), device_path));
   SyncWithNotifierThread();
 }
@@ -497,7 +497,7 @@
     const std::string& device_path) {
   ASSERT_FALSE(mock_upower_.signal_callback_device_removed.is_null());
   manager_->GetNotifierThreadForTesting()->task_runner()->PostTask(
-      FROM_HERE, base::BindOnce(&MockUPowerObject::SignalDeviceRemoved,
+      FROM_HERE, base::Bind(&MockUPowerObject::SignalDeviceRemoved,
                                 base::Unretained(&mock_upower_), device_path));
   SyncWithNotifierThread();
 }
@@ -536,7 +536,7 @@
                             base::WaitableEvent::InitialState::NOT_SIGNALED);
   manager_->GetNotifierThreadForTesting()->task_runner()->PostTask(
       FROM_HERE,
-      base::BindOnce(&base::WaitableEvent::Signal, base::Unretained(&event)));
+      base::Bind(&base::WaitableEvent::Signal, base::Unretained(&event)));
   event.Wait();
 }
 
--- a/services/device/battery/battery_status_service.cc	2019-05-17 17:45:35.272000000 +0300
+++ b/services/device/battery/battery_status_service.cc	2019-05-17 18:53:37.808000000 +0300
@@ -19,7 +19,10 @@
     : main_thread_task_runner_(base::ThreadTaskRunnerHandle::Get()),
       update_callback_(base::Bind(&BatteryStatusService::NotifyConsumers,
                                   base::Unretained(this))),
+      status_updated_(false),
       is_shutdown_(false) {
+  callback_list_.set_removal_callback(base::Bind(
+      &BatteryStatusService::ConsumersChanged, base::Unretained(this)));
 }
 
 BatteryStatusService::~BatteryStatusService() {}
@@ -35,16 +38,57 @@
   DCHECK(main_thread_task_runner_->BelongsToCurrentThread());
   DCHECK(!is_shutdown_);
 
-  // Always pass the default values.
+  if (!battery_fetcher_)
+    battery_fetcher_ = BatteryStatusManager::Create(update_callback_);
+
+  if (callback_list_.empty()) {
+    bool success = battery_fetcher_->StartListeningBatteryChange();
+    // On failure pass the default values back.
+    if (!success)
   callback.Run(mojom::BatteryStatus());
+  }
+
+  if (status_updated_) {
+    // Send recent status to the new callback if already available.
+    callback.Run(status_);
+  }
 
   return callback_list_.Add(callback);
 }
 
+void BatteryStatusService::ConsumersChanged() {
+  if (is_shutdown_)
+    return;
+
+  if (callback_list_.empty()) {
+    battery_fetcher_->StopListeningBatteryChange();
+    status_updated_ = false;
+  }
+}
+
 void BatteryStatusService::NotifyConsumers(const mojom::BatteryStatus& status) {
+  DCHECK(!is_shutdown_);
+
+  main_thread_task_runner_->PostTask(
+      FROM_HERE, base::Bind(&BatteryStatusService::NotifyConsumersOnMainThread,
+                            base::Unretained(this), status));
+}
+
+void BatteryStatusService::NotifyConsumersOnMainThread(
+    const mojom::BatteryStatus& status) {
+  DCHECK(main_thread_task_runner_->BelongsToCurrentThread());
+  if (callback_list_.empty())
+    return;
+
+  status_ = status;
+  status_updated_ = true;
+  callback_list_.Notify(status_);
 }
 
 void BatteryStatusService::Shutdown() {
+  if (!callback_list_.empty())
+    battery_fetcher_->StopListeningBatteryChange();
+  battery_fetcher_.reset();
   is_shutdown_ = true;
 }
 
@@ -55,6 +99,9 @@
 
 void BatteryStatusService::SetBatteryManagerForTesting(
     std::unique_ptr<BatteryStatusManager> test_battery_manager) {
+  battery_fetcher_ = std::move(test_battery_manager);
+  status_ = mojom::BatteryStatus();
+  status_updated_ = false;
   is_shutdown_ = false;
   main_thread_task_runner_ = base::ThreadTaskRunnerHandle::Get();
 }
--- a/services/device/battery/battery_status_service.h	2019-05-17 17:45:35.272000000 +0300
+++ b/services/device/battery/battery_status_service.h	2019-05-17 18:53:37.808000000 +0300
@@ -56,10 +56,15 @@
   // Updates current battery status and sends new status to interested
   // render processes. Can be called on any thread via a callback.
   void NotifyConsumers(const mojom::BatteryStatus& status);
+  void NotifyConsumersOnMainThread(const mojom::BatteryStatus& status);
+  void ConsumersChanged();
 
   scoped_refptr<base::SingleThreadTaskRunner> main_thread_task_runner_;
+  std::unique_ptr<BatteryStatusManager> battery_fetcher_;
   BatteryUpdateCallbackList callback_list_;
   BatteryUpdateCallback update_callback_;
+  mojom::BatteryStatus status_;
+  bool status_updated_;
   bool is_shutdown_;
 
   DISALLOW_COPY_AND_ASSIGN(BatteryStatusService);
--- a/services/device/bluetooth/bluetooth_system.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/bluetooth/bluetooth_system.cc	2019-05-17 18:53:37.808000000 +0300
@@ -140,11 +140,9 @@
   switch (state_) {
     case State::kUnsupported:
     case State::kUnavailable:
-      std::move(callback).Run(SetPoweredResult::kFailedBluetoothUnavailable);
+      std::move(callback).Run(SetPoweredResult::kBluetoothUnavailable);
       return;
     case State::kTransitioning:
-      std::move(callback).Run(SetPoweredResult::kFailedInProgress);
-      return;
     case State::kPoweredOff:
     case State::kPoweredOn:
       break;
@@ -155,9 +153,12 @@
     return;
   }
 
-  DCHECK_NE(state_, State::kTransitioning);
+  // Update the BluetoothSystem state to kTransitioning if a previous call to
+  // SetPowered() has not done so already.
+  if (state_ != State::kTransitioning) {
   state_ = State::kTransitioning;
   client_ptr_->OnStateChanged(state_);
+  }
 
   GetBluetoothAdapterClient()
       ->GetProperties(active_adapter_.value())
@@ -192,7 +193,7 @@
     case State::kUnavailable:
     case State::kPoweredOff:
     case State::kTransitioning:
-      std::move(callback).Run(StartScanResult::kFailedBluetoothUnavailable);
+      std::move(callback).Run(StartScanResult::kBluetoothUnavailable);
       return;
     case State::kPoweredOn:
       break;
@@ -210,7 +211,7 @@
     case State::kUnavailable:
     case State::kPoweredOff:
     case State::kTransitioning:
-      std::move(callback).Run(StopScanResult::kFailedBluetoothUnavailable);
+      std::move(callback).Run(StopScanResult::kBluetoothUnavailable);
       return;
     case State::kPoweredOn:
       break;
--- a/services/device/bluetooth/bluetooth_system_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/bluetooth/bluetooth_system_unittest.cc	2019-05-17 18:53:37.808000000 +0300
@@ -4,14 +4,12 @@
 
 #include "services/device/bluetooth/bluetooth_system.h"
 
-#include <deque>
 #include <map>
 #include <memory>
 #include <string>
 #include <utility>
 #include <vector>
 
-#include "base/bind.h"
 #include "base/observer_list.h"
 #include "base/optional.h"
 #include "base/run_loop.h"
@@ -120,7 +118,7 @@
           callback.Run(GetValueAndReset(&next_set_powered_response_));
           return;
         }
-        set_powered_callbacks_.push_back(callback);
+        set_property_callbacks_.push_back(callback);
       } else {
         NOTIMPLEMENTED();
       }
@@ -130,10 +128,10 @@
     base::Optional<bool> next_set_powered_response_;
     base::Optional<bool> last_set_powered_value_;
 
-    // Saved `Set('powered')` callbacks. If there is no next response set for a
-    // `Set()` call, then the callback is saved here. TestBluetoothAdapterClient
+    // Saved `Set()` callbacks. If there is no next response set for a `Set()`
+    // call, then the callback is saved here. TestBluetoothAdapterClient
     // runs all these callbacks after the adapter is removed.
-    std::deque<base::OnceCallback<void(bool)>> set_powered_callbacks_;
+    std::vector<base::OnceCallback<void(bool)>> set_property_callbacks_;
   };
 
   TestBluetoothAdapterClient() = default;
@@ -207,8 +205,8 @@
     DCHECK_EQ(1u, removed);
 
     // After the adapter is removed, any pending Set calls get run with `false`.
-    for (auto& set_powered_callback : properties->set_powered_callbacks_) {
-      std::move(set_powered_callback).Run(false);
+    for (auto& set_property_callback : properties->set_property_callbacks_) {
+      std::move(set_property_callback).Run(false);
     }
   }
 
@@ -249,17 +247,6 @@
         ->GetLastSetPoweredValue();
   }
 
-  void SimulateSetPoweredCompleted(
-      bool success,
-      const std::string& object_path_str = kDefaultAdapterObjectPathStr) {
-    auto& callbacks = GetProperties(dbus::ObjectPath(object_path_str))
-                          ->set_powered_callbacks_;
-    auto callback = std::move(callbacks.front());
-    callbacks.pop_front();
-
-    std::move(callback).Run(success);
-  }
-
   // Simulates adapter at |object_path_str| changing its discovering state to
   // |powered|.
   void SimulateAdapterDiscoveringStateChanged(
@@ -419,12 +406,6 @@
     NOTIMPLEMENTED();
   }
 
-  void SetLongTermKeys(const dbus::ObjectPath& object_path,
-                       const std::vector<std::vector<uint8_t>>& long_term_keys,
-                       ErrorCallback error_callback) override {
-    NOTIMPLEMENTED();
-  }
-
  private:
   // Keeps track of how many times methods have been called.
   struct CallCounts {
@@ -1004,11 +985,9 @@
 TEST_F(BluetoothSystemTest, SetPowered_NoAdapter) {
   auto system = CreateBluetoothSystem();
 
-  EXPECT_EQ(
-      mojom::BluetoothSystem::SetPoweredResult::kFailedBluetoothUnavailable,
+  EXPECT_EQ(mojom::BluetoothSystem::SetPoweredResult::kBluetoothUnavailable,
       SetPoweredAndWait(system, false));
-  EXPECT_EQ(
-      mojom::BluetoothSystem::SetPoweredResult::kFailedBluetoothUnavailable,
+  EXPECT_EQ(mojom::BluetoothSystem::SetPoweredResult::kBluetoothUnavailable,
       SetPoweredAndWait(system, false));
 }
 
@@ -1217,216 +1196,6 @@
   EXPECT_TRUE(on_state_changed_states_.empty());
 }
 
-// Tests power off call with pending power off call.
-TEST_F(BluetoothSystemTest, SetPoweredOff_PendingSetPoweredOff) {
-  test_bluetooth_adapter_client_->SimulatePoweredOnAdapter();
-
-  auto system = CreateBluetoothSystem();
-  ASSERT_EQ(mojom::BluetoothSystem::State::kPoweredOn, GetStateAndWait(system));
-
-  // Start powering off BT and wait for the state to change to
-  // kTransitioning.
-  base::RunLoop run_loop;
-  base::Optional<mojom::BluetoothSystem::SetPoweredResult>
-      set_powered_off_result;
-  system->SetPowered(false,
-                     base::BindLambdaForTesting(
-                         [&](mojom::BluetoothSystem::SetPoweredResult r) {
-                           set_powered_off_result = r;
-                           run_loop.Quit();
-                         }));
-
-  EXPECT_EQ(mojom::BluetoothSystem::State::kTransitioning,
-            GetStateAndWait(system));
-  EXPECT_EQ(StateVector({mojom::BluetoothSystem::State::kTransitioning}),
-            on_state_changed_states_);
-  EXPECT_EQ(1u, test_bluetooth_adapter_client_->GetSetPoweredCallCount());
-  EXPECT_FALSE(test_bluetooth_adapter_client_->GetLastSetPoweredValue());
-
-  ResetResults();
-  test_bluetooth_adapter_client_->ResetCallCount();
-
-  // Try to power off BT; should fail with kInProgress.
-  EXPECT_EQ(mojom::BluetoothSystem::SetPoweredResult::kFailedInProgress,
-            SetPoweredAndWait(system, false));
-
-  EXPECT_EQ(0u, test_bluetooth_adapter_client_->GetSetPoweredCallCount());
-  EXPECT_EQ(mojom::BluetoothSystem::State::kTransitioning,
-            GetStateAndWait(system));
-  EXPECT_EQ(StateVector(), on_state_changed_states_);
-
-  ResetResults();
-
-  // Finish initial call to power off BT.
-  test_bluetooth_adapter_client_->SimulateSetPoweredCompleted(true);
-  test_bluetooth_adapter_client_->SimulateAdapterPowerStateChanged(false);
-  run_loop.Run();
-
-  EXPECT_EQ(mojom::BluetoothSystem::State::kPoweredOff,
-            GetStateAndWait(system));
-  EXPECT_EQ(StateVector({mojom::BluetoothSystem::State::kPoweredOff}),
-            on_state_changed_states_);
-  EXPECT_EQ(mojom::BluetoothSystem::SetPoweredResult::kSuccess,
-            set_powered_off_result.value());
-}
-
-// Tests power off call with pending power on call.
-TEST_F(BluetoothSystemTest, SetPoweredOff_PendingSetPoweredOn) {
-  test_bluetooth_adapter_client_->SimulateAdapterAdded();
-
-  auto system = CreateBluetoothSystem();
-  ASSERT_EQ(mojom::BluetoothSystem::State::kPoweredOff,
-            GetStateAndWait(system));
-
-  // Start powering on BT and wait for the state to change to
-  // kTransitioning.
-  base::RunLoop run_loop;
-  base::Optional<mojom::BluetoothSystem::SetPoweredResult>
-      set_powered_on_result;
-  system->SetPowered(true, base::BindLambdaForTesting(
-                               [&](mojom::BluetoothSystem::SetPoweredResult r) {
-                                 set_powered_on_result = r;
-                                 run_loop.Quit();
-                               }));
-
-  EXPECT_EQ(mojom::BluetoothSystem::State::kTransitioning,
-            GetStateAndWait(system));
-  EXPECT_EQ(StateVector({mojom::BluetoothSystem::State::kTransitioning}),
-            on_state_changed_states_);
-  EXPECT_EQ(1u, test_bluetooth_adapter_client_->GetSetPoweredCallCount());
-  EXPECT_TRUE(test_bluetooth_adapter_client_->GetLastSetPoweredValue());
-
-  ResetResults();
-  test_bluetooth_adapter_client_->ResetCallCount();
-
-  // Try to power off BT; should fail with kInProgress.
-  EXPECT_EQ(mojom::BluetoothSystem::SetPoweredResult::kFailedInProgress,
-            SetPoweredAndWait(system, false));
-
-  EXPECT_EQ(0u, test_bluetooth_adapter_client_->GetSetPoweredCallCount());
-  EXPECT_EQ(mojom::BluetoothSystem::State::kTransitioning,
-            GetStateAndWait(system));
-  EXPECT_EQ(StateVector(), on_state_changed_states_);
-
-  ResetResults();
-
-  // Finish initial call to power on BT.
-  test_bluetooth_adapter_client_->SimulateSetPoweredCompleted(true);
-  test_bluetooth_adapter_client_->SimulateAdapterPowerStateChanged(true);
-  run_loop.Run();
-
-  EXPECT_EQ(mojom::BluetoothSystem::State::kPoweredOn, GetStateAndWait(system));
-  EXPECT_EQ(StateVector({mojom::BluetoothSystem::State::kPoweredOn}),
-            on_state_changed_states_);
-  EXPECT_EQ(mojom::BluetoothSystem::SetPoweredResult::kSuccess,
-            set_powered_on_result.value());
-}
-
-// Tests power on call with pending power off call.
-TEST_F(BluetoothSystemTest, SetPoweredOn_PendingSetPoweredOff) {
-  test_bluetooth_adapter_client_->SimulatePoweredOnAdapter();
-
-  auto system = CreateBluetoothSystem();
-  ASSERT_EQ(mojom::BluetoothSystem::State::kPoweredOn, GetStateAndWait(system));
-
-  // Start powering off BT and wait for the state to change to
-  // kTransitioning.
-  base::RunLoop run_loop;
-  base::Optional<mojom::BluetoothSystem::SetPoweredResult>
-      set_powered_off_result;
-  system->SetPowered(false,
-                     base::BindLambdaForTesting(
-                         [&](mojom::BluetoothSystem::SetPoweredResult r) {
-                           set_powered_off_result = r;
-                           run_loop.Quit();
-                         }));
-
-  EXPECT_EQ(mojom::BluetoothSystem::State::kTransitioning,
-            GetStateAndWait(system));
-  EXPECT_EQ(StateVector({mojom::BluetoothSystem::State::kTransitioning}),
-            on_state_changed_states_);
-  EXPECT_EQ(1u, test_bluetooth_adapter_client_->GetSetPoweredCallCount());
-  EXPECT_FALSE(test_bluetooth_adapter_client_->GetLastSetPoweredValue());
-
-  ResetResults();
-  test_bluetooth_adapter_client_->ResetCallCount();
-
-  // Try to power on BT; should fail with kInProgress.
-  EXPECT_EQ(mojom::BluetoothSystem::SetPoweredResult::kFailedInProgress,
-            SetPoweredAndWait(system, true));
-
-  EXPECT_EQ(0u, test_bluetooth_adapter_client_->GetSetPoweredCallCount());
-  EXPECT_EQ(mojom::BluetoothSystem::State::kTransitioning,
-            GetStateAndWait(system));
-  EXPECT_EQ(StateVector(), on_state_changed_states_);
-
-  ResetResults();
-
-  // Finish initial call to power off BT.
-  test_bluetooth_adapter_client_->SimulateSetPoweredCompleted(true);
-  test_bluetooth_adapter_client_->SimulateAdapterPowerStateChanged(false);
-  run_loop.Run();
-
-  EXPECT_EQ(mojom::BluetoothSystem::State::kPoweredOff,
-            GetStateAndWait(system));
-  EXPECT_EQ(StateVector({mojom::BluetoothSystem::State::kPoweredOff}),
-            on_state_changed_states_);
-  EXPECT_EQ(mojom::BluetoothSystem::SetPoweredResult::kSuccess,
-            set_powered_off_result.value());
-}
-
-// Tests power on call with pending power on call.
-TEST_F(BluetoothSystemTest, SetPoweredOn_PendingSetPoweredOn) {
-  test_bluetooth_adapter_client_->SimulateAdapterAdded();
-
-  auto system = CreateBluetoothSystem();
-  ASSERT_EQ(mojom::BluetoothSystem::State::kPoweredOff,
-            GetStateAndWait(system));
-
-  // Start powering on BT and wait for the state to change to
-  // kTransitioning.
-  base::RunLoop run_loop;
-  base::Optional<mojom::BluetoothSystem::SetPoweredResult>
-      set_powered_on_result;
-  system->SetPowered(true, base::BindLambdaForTesting(
-                               [&](mojom::BluetoothSystem::SetPoweredResult r) {
-                                 set_powered_on_result = r;
-                                 run_loop.Quit();
-                               }));
-
-  EXPECT_EQ(mojom::BluetoothSystem::State::kTransitioning,
-            GetStateAndWait(system));
-  EXPECT_EQ(StateVector({mojom::BluetoothSystem::State::kTransitioning}),
-            on_state_changed_states_);
-  EXPECT_EQ(1u, test_bluetooth_adapter_client_->GetSetPoweredCallCount());
-  EXPECT_TRUE(test_bluetooth_adapter_client_->GetLastSetPoweredValue());
-
-  ResetResults();
-  test_bluetooth_adapter_client_->ResetCallCount();
-
-  // Try to power on BT; should fail with kInProgress.
-  EXPECT_EQ(mojom::BluetoothSystem::SetPoweredResult::kFailedInProgress,
-            SetPoweredAndWait(system, true));
-
-  EXPECT_EQ(0u, test_bluetooth_adapter_client_->GetSetPoweredCallCount());
-  EXPECT_EQ(mojom::BluetoothSystem::State::kTransitioning,
-            GetStateAndWait(system));
-  EXPECT_EQ(StateVector(), on_state_changed_states_);
-
-  ResetResults();
-
-  // Finish initial call to power on BT.
-  test_bluetooth_adapter_client_->SimulateSetPoweredCompleted(true);
-  test_bluetooth_adapter_client_->SimulateAdapterPowerStateChanged(true);
-  run_loop.Run();
-
-  EXPECT_EQ(mojom::BluetoothSystem::State::kPoweredOn, GetStateAndWait(system));
-  EXPECT_EQ(StateVector({mojom::BluetoothSystem::State::kPoweredOn}),
-            on_state_changed_states_);
-  EXPECT_EQ(mojom::BluetoothSystem::SetPoweredResult::kSuccess,
-            set_powered_on_result.value());
-}
-
 // Tests scan state is kNotScanning when there is no adapter.
 TEST_F(BluetoothSystemTest, ScanState_NoAdapter) {
   auto system = CreateBluetoothSystem();
@@ -1573,8 +1342,7 @@
 TEST_F(BluetoothSystemTest, StartScan_NoAdapter) {
   auto system = CreateBluetoothSystem();
 
-  EXPECT_EQ(
-      mojom::BluetoothSystem::StartScanResult::kFailedBluetoothUnavailable,
+  EXPECT_EQ(mojom::BluetoothSystem::StartScanResult::kBluetoothUnavailable,
       StartScanAndWait(system));
 }
 
@@ -1585,8 +1353,7 @@
 
   auto system = CreateBluetoothSystem();
 
-  EXPECT_EQ(
-      mojom::BluetoothSystem::StartScanResult::kFailedBluetoothUnavailable,
+  EXPECT_EQ(mojom::BluetoothSystem::StartScanResult::kBluetoothUnavailable,
       StartScanAndWait(system));
   EXPECT_EQ(0u, test_bluetooth_adapter_client_->GetStartDiscoveryCallCount());
 }
@@ -1654,8 +1421,7 @@
   ResetResults();
 
   // Start scan should fail without sending the command to the adapter.
-  EXPECT_EQ(
-      mojom::BluetoothSystem::StartScanResult::kFailedBluetoothUnavailable,
+  EXPECT_EQ(mojom::BluetoothSystem::StartScanResult::kBluetoothUnavailable,
       StartScanAndWait(system));
   EXPECT_EQ(0u, test_bluetooth_adapter_client_->GetStartDiscoveryCallCount());
   EXPECT_EQ(mojom::BluetoothSystem::ScanState::kNotScanning,
@@ -1685,8 +1451,7 @@
   ResetResults();
 
   // Start scan should fail without sending the command to the adapter.
-  EXPECT_EQ(
-      mojom::BluetoothSystem::StartScanResult::kFailedBluetoothUnavailable,
+  EXPECT_EQ(mojom::BluetoothSystem::StartScanResult::kBluetoothUnavailable,
       StartScanAndWait(system));
   EXPECT_EQ(0u, test_bluetooth_adapter_client_->GetStartDiscoveryCallCount());
   EXPECT_EQ(mojom::BluetoothSystem::ScanState::kNotScanning,
@@ -1706,7 +1471,7 @@
 TEST_F(BluetoothSystemTest, StopScan_NoAdapter) {
   auto system = CreateBluetoothSystem();
 
-  EXPECT_EQ(mojom::BluetoothSystem::StopScanResult::kFailedBluetoothUnavailable,
+  EXPECT_EQ(mojom::BluetoothSystem::StopScanResult::kBluetoothUnavailable,
             StopScanAndWait(system));
 }
 
@@ -1717,7 +1482,7 @@
 
   auto system = CreateBluetoothSystem();
 
-  EXPECT_EQ(mojom::BluetoothSystem::StopScanResult::kFailedBluetoothUnavailable,
+  EXPECT_EQ(mojom::BluetoothSystem::StopScanResult::kBluetoothUnavailable,
             StopScanAndWait(system));
   EXPECT_EQ(0u, test_bluetooth_adapter_client_->GetStopDiscoveryCallCount());
 }
@@ -1796,7 +1561,7 @@
   ResetResults();
 
   // Stop scan should fail without sending the command to the adapter.
-  EXPECT_EQ(mojom::BluetoothSystem::StopScanResult::kFailedBluetoothUnavailable,
+  EXPECT_EQ(mojom::BluetoothSystem::StopScanResult::kBluetoothUnavailable,
             StopScanAndWait(system));
   EXPECT_EQ(0u, test_bluetooth_adapter_client_->GetStopDiscoveryCallCount());
   EXPECT_EQ(mojom::BluetoothSystem::ScanState::kNotScanning,
@@ -1833,7 +1598,7 @@
   ResetResults();
 
   // Stop scan should fail without sending the command to the adapter.
-  EXPECT_EQ(mojom::BluetoothSystem::StopScanResult::kFailedBluetoothUnavailable,
+  EXPECT_EQ(mojom::BluetoothSystem::StopScanResult::kBluetoothUnavailable,
             StopScanAndWait(system));
   EXPECT_EQ(0u, test_bluetooth_adapter_client_->GetStopDiscoveryCallCount());
   EXPECT_EQ(mojom::BluetoothSystem::ScanState::kScanning,
--- a/services/device/BUILD.gn	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/BUILD.gn	2019-05-17 18:53:37.804000000 +0300
@@ -3,6 +3,7 @@
 # found in the LICENSE file.
 
 import("//build/config/features.gni")
+import("//services/service_manager/public/service_manifest.gni")
 
 if (is_android) {
   import("//build/config/android/rules.gni")
@@ -66,24 +67,6 @@
 
 is_linux_without_udev = is_linux && !use_udev
 
-source_set("perftests") {
-  testonly = true
-
-  sources = [
-    "geolocation/position_cache_impl_perftest.cc",
-  ]
-
-  deps = [
-    ":test_support",
-    "//base",
-    "//base/test:test_support",
-    "//services/device/geolocation",
-    "//services/device/geolocation:test_support",
-    "//testing/gtest",
-    "//testing/perf",
-  ]
-}
-
 source_set("tests") {
   testonly = true
 
@@ -110,7 +93,6 @@
     "geolocation/geolocation_service_unittest.cc",
     "geolocation/location_arbitrator_unittest.cc",
     "geolocation/network_location_provider_unittest.cc",
-    "geolocation/position_cache_impl_unittest.cc",
     "geolocation/public_ip_address_geolocator_unittest.cc",
     "geolocation/public_ip_address_location_notifier_unittest.cc",
     "geolocation/wifi_data_provider_chromeos_unittest.cc",
@@ -240,6 +222,11 @@
   }
 }
 
+service_manifest("manifest") {
+  name = "device"
+  source = "manifest.json"
+}
+
 source_set("test_support") {
   testonly = true
 
--- a/services/device/device_service.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/device_service.cc	2019-05-17 18:53:37.808000000 +0300
@@ -96,7 +96,6 @@
       url_loader_factory_(std::move(url_loader_factory)),
       geolocation_api_key_(geolocation_api_key),
       wake_lock_context_callback_(wake_lock_context_callback),
-      wake_lock_provider_(file_task_runner_, wake_lock_context_callback_),
       java_interface_provider_initialized_(false) {
   java_nfc_delegate_.Reset(java_nfc_delegate);
 }
@@ -111,8 +110,7 @@
       file_task_runner_(std::move(file_task_runner)),
       io_task_runner_(std::move(io_task_runner)),
       url_loader_factory_(std::move(url_loader_factory)),
-      geolocation_api_key_(geolocation_api_key),
-      wake_lock_provider_(file_task_runner_, wake_lock_context_callback_) {}
+      geolocation_api_key_(geolocation_api_key) {}
 #endif
 
 DeviceService::~DeviceService() {
@@ -297,8 +295,8 @@
 #if defined(OS_ANDROID)
   if (io_task_runner_) {
     io_task_runner_->PostTask(
-        FROM_HERE, base::BindOnce(&ScreenOrientationListenerAndroid::Create,
-                                  std::move(request)));
+        FROM_HERE, base::Bind(&ScreenOrientationListenerAndroid::Create,
+                              base::Passed(&request)));
   }
 #endif
 }
@@ -307,8 +305,8 @@
     mojom::SensorProviderRequest request) {
   if (io_task_runner_) {
     io_task_runner_->PostTask(
-        FROM_HERE, base::BindOnce(&device::SensorProviderImpl::Create,
-                                  file_task_runner_, std::move(request)));
+        FROM_HERE, base::Bind(&device::SensorProviderImpl::Create,
+                              file_task_runner_, base::Passed(&request)));
   }
 }
 
@@ -321,7 +319,8 @@
 
 void DeviceService::BindWakeLockProviderRequest(
     mojom::WakeLockProviderRequest request) {
-  wake_lock_provider_.AddBinding(std::move(request));
+  WakeLockProvider::Create(std::move(request), file_task_runner_,
+                           wake_lock_context_callback_);
 }
 
 void DeviceService::BindUsbDeviceManagerRequest(
--- a/services/device/device_service.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/device_service.h	2019-05-17 18:53:37.808000000 +0300
@@ -33,7 +33,6 @@
 #include "services/device/public/mojom/vibration_manager.mojom.h"
 #include "services/device/public/mojom/wake_lock_provider.mojom.h"
 #include "services/device/wake_lock/wake_lock_context.h"
-#include "services/device/wake_lock/wake_lock_provider.h"
 #include "services/service_manager/public/cpp/binder_registry.h"
 #include "services/service_manager/public/cpp/interface_provider.h"
 #include "services/service_manager/public/cpp/service.h"
@@ -182,7 +181,6 @@
 
   const std::string geolocation_api_key_;
   WakeLockContextCallback wake_lock_context_callback_;
-  WakeLockProvider wake_lock_provider_;
 
 #if defined(OS_ANDROID)
   // Binds |java_interface_provider_| to an interface registry that exposes
--- a/services/device/device_service_test_base.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/device_service_test_base.cc	2019-05-17 18:53:37.808000000 +0300
@@ -6,12 +6,10 @@
 
 #include <memory>
 
-#include "base/bind.h"
 #include "base/macros.h"
 #include "base/memory/ref_counted.h"
 #include "base/message_loop/message_loop.h"
 #include "base/single_thread_task_runner.h"
-#include "base/task/post_task.h"
 #include "mojo/public/cpp/bindings/binding_set.h"
 #include "services/device/device_service.h"
 #include "services/device/public/cpp/geolocation/location_provider.h"
@@ -52,17 +50,19 @@
 }  // namespace
 
 DeviceServiceTestBase::DeviceServiceTestBase()
-    : file_task_runner_(base::CreateSingleThreadTaskRunnerWithTraits(
-          {base::MayBlock(), base::TaskPriority::BEST_EFFORT})),
-      io_task_runner_(base::CreateSingleThreadTaskRunnerWithTraits(
-          {base::TaskPriority::USER_VISIBLE})),
-      connector_(test_connector_factory_.CreateConnector()) {}
+    : file_thread_("DeviceServiceTestFileThread"),
+      io_thread_("DeviceServiceTestIOThread"),
+      connector_(test_connector_factory_.CreateConnector()) {
+  file_thread_.Start();
+  io_thread_.StartWithOptions(
+      base::Thread::Options(base::MessageLoop::TYPE_IO, 0));
+}
 
 DeviceServiceTestBase::~DeviceServiceTestBase() = default;
 
 void DeviceServiceTestBase::SetUp() {
   service_ = CreateTestDeviceService(
-      file_task_runner_, io_task_runner_,
+      file_thread_.task_runner(), io_thread_.task_runner(),
       base::MakeRefCounted<network::WeakWrapperSharedURLLoaderFactory>(
           &test_url_loader_factory_),
       test_connector_factory_.RegisterInstance(mojom::kServiceName));
--- a/services/device/device_service_test_base.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/device_service_test_base.h	2019-05-17 18:53:37.808000000 +0300
@@ -7,6 +7,7 @@
 
 #include "base/macros.h"
 #include "base/test/scoped_task_environment.h"
+#include "base/threading/thread.h"
 #include "services/network/test/test_url_loader_factory.h"
 #include "services/service_manager/public/cpp/test/test_connector_factory.h"
 #include "testing/gtest/include/gtest/gtest.h"
@@ -32,12 +33,8 @@
   service_manager::Connector* connector() { return connector_.get(); }
 
   base::test::ScopedTaskEnvironment task_environment_;
-
-  // Both of these task runners should be deprecated in favor of individual
-  // components of the device service creating their own.
-  scoped_refptr<base::SingleThreadTaskRunner> file_task_runner_;
-  scoped_refptr<base::SingleThreadTaskRunner> io_task_runner_;
-
+  base::Thread file_thread_;
+  base::Thread io_thread_;
   network::TestURLLoaderFactory test_url_loader_factory_;
 
  private:
--- a/services/device/fingerprint/fingerprint_chromeos.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/fingerprint/fingerprint_chromeos.cc	2019-05-17 18:53:37.808000000 +0300
@@ -6,7 +6,6 @@
 
 #include <string.h>
 
-#include "base/bind.h"
 #include "chromeos/dbus/dbus_thread_manager.h"
 #include "mojo/public/cpp/bindings/strong_binding.h"
 #include "services/device/fingerprint/fingerprint.h"
@@ -115,6 +114,11 @@
   if (!result)
     return;
 
+  ScheduleStartEnroll(user_id, label);
+}
+
+void FingerprintChromeOS::ScheduleStartEnroll(const std::string& user_id,
+                                              const std::string& label) {
   GetBiodClient()->StartEnrollSession(
       user_id, label,
       base::Bind(&FingerprintChromeOS::OnStartEnrollSession,
@@ -161,9 +165,7 @@
         base::BindRepeating(&FingerprintChromeOS::OnCloseEnrollSessionForAuth,
                             weak_ptr_factory_.GetWeakPtr()));
   } else {
-    GetBiodClient()->StartAuthSession(
-        base::Bind(&FingerprintChromeOS::OnStartAuthSession,
-                   weak_ptr_factory_.GetWeakPtr()));
+    ScheduleStartAuth();
   }
 }
 
@@ -171,6 +173,10 @@
   if (!result)
     return;
 
+  ScheduleStartAuth();
+}
+
+void FingerprintChromeOS::ScheduleStartAuth() {
   GetBiodClient()->StartAuthSession(
       base::Bind(&FingerprintChromeOS::OnStartAuthSession,
                  weak_ptr_factory_.GetWeakPtr()));
--- a/services/device/fingerprint/fingerprint_chromeos.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/fingerprint/fingerprint_chromeos.h	2019-05-17 18:53:37.808000000 +0300
@@ -79,6 +79,9 @@
   void OnCloseAuthSessionForEnroll(const std::string& user_id,
                                    const std::string& label,
                                    bool result);
+  void ScheduleStartEnroll(const std::string& user_id,
+                           const std::string& label);
+  void ScheduleStartAuth();
 
   void RunGetRecordsForUser(const std::string& user_id,
                             GetRecordsForUserCallback callback);
--- a/services/device/fingerprint/fingerprint_chromeos_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/fingerprint/fingerprint_chromeos_unittest.cc	2019-05-17 18:53:37.808000000 +0300
@@ -4,7 +4,6 @@
 
 #include "services/device/fingerprint/fingerprint_chromeos.h"
 
-#include "base/bind.h"
 #include "base/macros.h"
 #include "base/message_loop/message_loop.h"
 #include "base/run_loop.h"
--- a/services/device/generic_sensor/generic_sensor_service_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/generic_sensor/generic_sensor_service_unittest.cc	2019-05-17 18:53:37.812000000 +0300
@@ -3,7 +3,6 @@
 // found in the LICENSE file.
 
 #include "base/barrier_closure.h"
-#include "base/bind.h"
 #include "base/bind_helpers.h"
 #include "base/macros.h"
 #include "base/memory/ref_counted.h"
@@ -155,7 +154,8 @@
 class GenericSensorServiceTest : public DeviceServiceTestBase {
  public:
   GenericSensorServiceTest()
-      : io_loop_finished_event_(
+      : io_thread_task_runner_(io_thread_.task_runner()),
+        io_loop_finished_event_(
             base::WaitableEvent::ResetPolicy::AUTOMATIC,
             base::WaitableEvent::InitialState::NOT_SIGNALED) {}
 
@@ -163,7 +163,7 @@
     scoped_feature_list_.InitWithFeatures(
         {features::kGenericSensor, features::kGenericSensorExtraClasses}, {});
     DeviceServiceTestBase::SetUp();
-    io_task_runner_->PostTask(
+    io_thread_task_runner_->PostTask(
         FROM_HERE, base::BindOnce(&GenericSensorServiceTest::SetUpOnIOThread,
                                   base::Unretained(this)));
     io_loop_finished_event_.Wait();
@@ -172,7 +172,7 @@
   }
 
   void TearDown() override {
-    io_task_runner_->PostTask(
+    io_thread_task_runner_->PostTask(
         FROM_HERE, base::BindOnce(&GenericSensorServiceTest::TearDownOnIOThread,
                                   base::Unretained(this)));
     io_loop_finished_event_.Wait();
@@ -195,6 +195,7 @@
     io_loop_finished_event_.Signal();
   }
   mojom::SensorProviderPtr sensor_provider_;
+  scoped_refptr<base::SingleThreadTaskRunner> io_thread_task_runner_;
   base::WaitableEvent io_loop_finished_event_;
   base::test::ScopedFeatureList scoped_feature_list_;
 
--- a/services/device/generic_sensor/linux/sensor_data_linux.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/generic_sensor/linux/sensor_data_linux.cc	2019-05-17 18:53:37.812000000 +0300
@@ -4,7 +4,6 @@
 
 #include "services/device/generic_sensor/linux/sensor_data_linux.h"
 
-#include "base/bind.h"
 #include "base/system/sys_info.h"
 #include "base/version.h"
 #include "services/device/generic_sensor/generic_sensor_consts.h"
@@ -141,9 +140,9 @@
       SensorTraits<SensorType::GYROSCOPE>::kDefaultFrequency);
 }
 
-// TODO(maksims): Verify magnetometer works correctly on a chromebook when
+// TODO(maksims): Verify magnitometer works correctly on a chromebook when
 // I get one with that sensor onboard.
-void InitMagnetometerSensorData(SensorPathsLinux* data) {
+void InitMagnitometerSensorData(SensorPathsLinux* data) {
   std::vector<std::string> file_names_x{"in_magn_x_raw"};
   std::vector<std::string> file_names_y{"in_magn_y_raw"};
   std::vector<std::string> file_names_z{"in_magn_z_raw"};
@@ -186,7 +185,7 @@
       InitGyroscopeSensorData(data);
       break;
     case SensorType::MAGNETOMETER:
-      InitMagnetometerSensorData(data);
+      InitMagnitometerSensorData(data);
       break;
     default:
       return false;
--- a/services/device/generic_sensor/linux/sensor_device_manager.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/generic_sensor/linux/sensor_device_manager.cc	2019-05-17 18:53:37.812000000 +0300
@@ -4,7 +4,6 @@
 
 #include "services/device/generic_sensor/linux/sensor_device_manager.h"
 
-#include "base/bind.h"
 #include "base/strings/string_number_conversions.h"
 #include "base/threading/scoped_blocking_call.h"
 #include "base/threading/thread_task_runner_handle.h"
@@ -34,8 +33,7 @@
 
 void SensorDeviceManager::Start(Delegate* delegate) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
-  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
-                                                base::BlockingType::MAY_BLOCK);
+  base::ScopedBlockingCall scoped_blocking_call(base::BlockingType::MAY_BLOCK);
   DCHECK(!delegate_);
 
   delegate_ = delegate;
@@ -47,7 +45,7 @@
 
   task_runner_->PostTask(
       FROM_HERE,
-      base::BindOnce(&SensorDeviceManager::Delegate::OnSensorNodesEnumerated,
+      base::Bind(&SensorDeviceManager::Delegate::OnSensorNodesEnumerated,
                      base::Unretained(delegate_)));
 }
 
@@ -144,9 +142,9 @@
         sensor_offset_value, reporting_mode, data.apply_scaling_func,
         std::move(sensor_file_names)));
     task_runner_->PostTask(
-        FROM_HERE, base::BindOnce(&SensorDeviceManager::Delegate::OnDeviceAdded,
+        FROM_HERE, base::Bind(&SensorDeviceManager::Delegate::OnDeviceAdded,
                                   base::Unretained(delegate_), data.type,
-                                  std::move(device)));
+                              base::Passed(&device)));
 
     // One |dev| can represent more than one sensor.
     // For example, there is an accelerometer and gyroscope represented by one
@@ -171,8 +169,7 @@
   sensors_by_node_.erase(sensor);
 
   task_runner_->PostTask(
-      FROM_HERE,
-      base::BindOnce(&SensorDeviceManager::Delegate::OnDeviceRemoved,
+      FROM_HERE, base::Bind(&SensorDeviceManager::Delegate::OnDeviceRemoved,
                      base::Unretained(delegate_), type, device_node));
 }
 
--- a/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc	2019-05-17 17:45:42.496000000 +0300
+++ b/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc	2019-05-17 18:53:37.816000000 +0300
@@ -20,7 +20,7 @@
 // hardware to a lux value.
 double LMUvalueToLux(uint64_t raw_value) {
   // Conversion formula from regression.
-  // https://bugzilla.m0z111a.qjz9zk/show_bug.cgi?id=793728
+  // https://bugzilla.mozilla.org/show_bug.cgi?id=793728
   // Let x = raw_value, then
   // lux = -2.978303814*(10^-27)*x^4 + 2.635687683*(10^-19)*x^3 -
   //       3.459747434*(10^-12)*x^2 + 3.905829689*(10^-5)*x - 0.1932594532
--- a/services/device/generic_sensor/platform_sensor_and_provider_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/generic_sensor/platform_sensor_and_provider_unittest.cc	2019-05-17 18:53:37.816000000 +0300
@@ -4,7 +4,6 @@
 
 #include "services/device/generic_sensor/platform_sensor_provider.h"
 
-#include "base/bind.h"
 #include "base/macros.h"
 #include "base/memory/singleton.h"
 #include "base/test/scoped_task_environment.h"
--- a/services/device/generic_sensor/platform_sensor_and_provider_unittest_linux.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/generic_sensor/platform_sensor_and_provider_unittest_linux.cc	2019-05-17 18:53:37.816000000 +0300
@@ -4,7 +4,6 @@
 
 #include <memory>
 
-#include "base/bind.h"
 #include "base/files/file_util.h"
 #include "base/files/scoped_temp_dir.h"
 #include "base/message_loop/message_loop.h"
@@ -93,7 +92,7 @@
   void EnumerationReady() {
     bool success = task_runner_->PostTask(
         FROM_HERE,
-        base::BindOnce(&SensorDeviceManager::Delegate::OnSensorNodesEnumerated,
+        base::Bind(&SensorDeviceManager::Delegate::OnSensorNodesEnumerated,
                        base::Unretained(delegate_)));
     ASSERT_TRUE(success);
   }
@@ -296,8 +295,7 @@
     }
     udev_device* dev = nullptr;
     bool success = base::ThreadTaskRunnerHandle::Get()->PostTask(
-        FROM_HERE,
-        base::BindOnce(&MockSensorDeviceManager::DeviceRemoved,
+        FROM_HERE, base::Bind(&MockSensorDeviceManager::DeviceRemoved,
                        base::Unretained(manager_), dev /* not used */));
     ASSERT_TRUE(success);
   }
--- a/services/device/generic_sensor/platform_sensor_and_provider_unittest_win.cc	2019-05-17 17:45:42.496000000 +0300
+++ b/services/device/generic_sensor/platform_sensor_and_provider_unittest_win.cc	2019-05-17 18:53:37.816000000 +0300
@@ -296,7 +296,7 @@
           if (this->run_loop_) {
             scoped_task_environment_.GetMainThreadTaskRunner()->PostTask(
                 FROM_HERE,
-                base::BindOnce(&PlatformSensorAndProviderTestWin::QuitInnerLoop,
+                base::Bind(&PlatformSensorAndProviderTestWin::QuitInnerLoop,
                                base::Unretained(this)));
           }
           return S_OK;
@@ -310,7 +310,7 @@
           if (this->run_loop_) {
             scoped_task_environment_.GetMainThreadTaskRunner()->PostTask(
                 FROM_HERE,
-                base::BindOnce(&PlatformSensorAndProviderTestWin::QuitInnerLoop,
+                base::Bind(&PlatformSensorAndProviderTestWin::QuitInnerLoop,
                                base::Unretained(this)));
           }
           return S_OK;
@@ -730,7 +730,7 @@
   base::win::ScopedPropVariant pvQuat;
 
   // The SENSOR_DATA_TYPE_QUATERNION property has [VT_VECTOR | VT_UI1] type.
-  // https://msdn.m1cr050ft.qjz9zk/en-us/library/windows/hardware/dn265187(v=vs.85).aspx
+  // https://msdn.microsoft.com/en-us/library/windows/hardware/dn265187(v=vs.85).aspx
   // Helper functions e.g., InitVariantFromDoubleArray cannot be used for its
   // intialization and the only way to initialize it, is to use
   // InitPropVariantFromGUIDAsBuffer with quaternion format GUID.
--- a/services/device/generic_sensor/platform_sensor_android.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/generic_sensor/platform_sensor_android.cc	2019-05-17 18:53:37.816000000 +0300
@@ -71,8 +71,7 @@
     JNIEnv*,
     const JavaRef<jobject>& caller) {
   task_runner_->PostTask(
-      FROM_HERE,
-      base::BindOnce(&PlatformSensorAndroid::NotifySensorError, this));
+      FROM_HERE, base::Bind(&PlatformSensorAndroid::NotifySensorError, this));
 }
 
 void PlatformSensorAndroid::UpdatePlatformSensorReading(
--- a/services/device/generic_sensor/platform_sensor.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/generic_sensor/platform_sensor.cc	2019-05-17 18:53:37.816000000 +0300
@@ -6,7 +6,6 @@
 
 #include <utility>
 
-#include "base/bind.h"
 #include "base/logging.h"
 #include "base/threading/thread_task_runner_handle.h"
 #include "services/device/generic_sensor/platform_sensor_provider.h"
@@ -113,8 +112,8 @@
 void PlatformSensor::UpdateSharedBufferAndNotifyClients(
     const SensorReading& reading) {
   UpdateSharedBuffer(reading);
-  task_runner_->PostTask(
-      FROM_HERE, base::BindOnce(&PlatformSensor::NotifySensorReadingChanged,
+  task_runner_->PostTask(FROM_HERE,
+                         base::Bind(&PlatformSensor::NotifySensorReadingChanged,
                                 weak_factory_.GetWeakPtr()));
 }
 
--- a/services/device/generic_sensor/platform_sensor_fusion.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/generic_sensor/platform_sensor_fusion.cc	2019-05-17 18:53:37.816000000 +0300
@@ -6,7 +6,6 @@
 
 #include <algorithm>
 
-#include "base/bind.h"
 #include "base/logging.h"
 #include "base/memory/scoped_refptr.h"
 #include "services/device/generic_sensor/platform_sensor_fusion_algorithm.h"
--- a/services/device/generic_sensor/platform_sensor_fusion_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/generic_sensor/platform_sensor_fusion_unittest.cc	2019-05-17 18:53:37.816000000 +0300
@@ -4,7 +4,6 @@
 
 #include <memory>
 
-#include "base/bind.h"
 #include "base/bind_helpers.h"
 #include "base/macros.h"
 #include "base/memory/ref_counted.h"
--- a/services/device/generic_sensor/platform_sensor_linux.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/generic_sensor/platform_sensor_linux.cc	2019-05-17 18:53:37.816000000 +0300
@@ -4,7 +4,6 @@
 
 #include "services/device/generic_sensor/platform_sensor_linux.h"
 
-#include "base/bind.h"
 #include "base/single_thread_task_runner.h"
 #include "services/device/generic_sensor/linux/sensor_data_linux.h"
 #include "services/device/generic_sensor/platform_sensor_reader_linux.h"
@@ -72,7 +71,7 @@
   DCHECK(task_runner_->BelongsToCurrentThread());
   polling_thread_task_runner_->PostTask(
       FROM_HERE,
-      base::BindOnce(&SensorReader::StartFetchingData,
+      base::Bind(&SensorReader::StartFetchingData,
                      base::Unretained(sensor_reader_.get()), configuration));
   return true;
 }
@@ -80,7 +79,7 @@
 void PlatformSensorLinux::StopSensor() {
   DCHECK(task_runner_->BelongsToCurrentThread());
   polling_thread_task_runner_->PostTask(
-      FROM_HERE, base::BindOnce(&SensorReader::StopFetchingData,
+      FROM_HERE, base::Bind(&SensorReader::StopFetchingData,
                                 base::Unretained(sensor_reader_.get())));
 }
 
--- a/services/device/generic_sensor/platform_sensor_provider_base.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/generic_sensor/platform_sensor_provider_base.cc	2019-05-17 18:53:37.816000000 +0300
@@ -6,7 +6,6 @@
 
 #include <utility>
 
-#include "base/bind.h"
 #include "base/stl_util.h"
 #include "services/device/public/mojom/sensor_provider.mojom.h"
 
--- a/services/device/generic_sensor/platform_sensor_provider_linux.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/generic_sensor/platform_sensor_provider_linux.cc	2019-05-17 18:53:37.816000000 +0300
@@ -7,7 +7,6 @@
 #include <utility>
 #include <vector>
 
-#include "base/bind.h"
 #include "base/memory/ref_counted.h"
 #include "base/memory/singleton.h"
 #include "base/message_loop/message_loop.h"
@@ -66,7 +65,7 @@
     if (!sensor_nodes_enumeration_started_) {
       sensor_nodes_enumeration_started_ = file_task_runner_->PostTask(
           FROM_HERE,
-          base::BindOnce(&SensorDeviceManager::Start,
+          base::Bind(&SensorDeviceManager::Start,
                          base::Unretained(sensor_device_manager_.get()), this));
     }
     return;
@@ -119,7 +118,7 @@
   // Stop() can only be called on a different thread that allows I/O.
   // Thus, browser's file thread is used for this purpose.
   file_task_runner_->PostTask(
-      FROM_HERE, base::BindOnce(&PlatformSensorProviderLinux::StopPollingThread,
+      FROM_HERE, base::Bind(&PlatformSensorProviderLinux::StopPollingThread,
                                 base::Unretained(this)));
 }
 
--- a/services/device/generic_sensor/platform_sensor_provider_unittest_android.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/generic_sensor/platform_sensor_provider_unittest_android.cc	2019-05-17 18:53:37.816000000 +0300
@@ -4,7 +4,6 @@
 
 #include "services/device/generic_sensor/platform_sensor_provider_android.h"
 
-#include "base/bind.h"
 #include "base/macros.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
--- a/services/device/generic_sensor/platform_sensor_provider_win.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/generic_sensor/platform_sensor_provider_win.cc	2019-05-17 18:53:37.816000000 +0300
@@ -9,7 +9,6 @@
 
 #include <iomanip>
 
-#include "base/bind.h"
 #include "base/memory/singleton.h"
 #include "base/task/post_task.h"
 #include "base/task/task_traits.h"
--- a/services/device/generic_sensor/platform_sensor_reader_linux.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/generic_sensor/platform_sensor_reader_linux.cc	2019-05-17 18:53:37.820000000 +0300
@@ -4,7 +4,6 @@
 
 #include "services/device/generic_sensor/platform_sensor_reader_linux.h"
 
-#include "base/bind.h"
 #include "base/files/file_util.h"
 #include "base/single_thread_task_runner.h"
 #include "base/stl_util.h"
@@ -123,8 +122,7 @@
 
   if (is_reading_active_) {
     task_runner_->PostTask(
-        FROM_HERE,
-        base::BindOnce(&PlatformSensorLinux::UpdatePlatformSensorReading,
+        FROM_HERE, base::Bind(&PlatformSensorLinux::UpdatePlatformSensorReading,
                        sensor_, readings));
   }
 }
@@ -158,8 +156,7 @@
   if (is_reading_active_) {
     task_runner_->PostTask(
         FROM_HERE,
-        base::BindOnce(&PlatformSensorLinux::NotifyPlatformSensorError,
-                       sensor_));
+        base::Bind(&PlatformSensorLinux::NotifyPlatformSensorError, sensor_));
   }
 }
 
--- a/services/device/generic_sensor/platform_sensor_reader_win.cc	2019-05-17 17:45:42.500000000 +0300
+++ b/services/device/generic_sensor/platform_sensor_reader_win.cc	2019-05-17 18:53:37.820000000 +0300
@@ -10,7 +10,6 @@
 
 #include <iomanip>
 
-#include "base/bind.h"
 #include "base/memory/ptr_util.h"
 #include "base/stl_util.h"
 #include "base/threading/thread_task_runner_handle.h"
@@ -99,7 +98,7 @@
     // gravity. Therefore, sensor hosted by the device at rest on a leveled
     // surface while the screen is facing towards the sky, must report -1G along
     // the Z axis.
-    // https://msdn.m1cr050ft.qjz9zk/en-us/library/windows/hardware/dn642102(v=vs.85).aspx
+    // https://msdn.microsoft.com/en-us/library/windows/hardware/dn642102(v=vs.85).aspx
     // Change sign of values, to report 'reaction force', and convert values
     // from G/s^2 to m/s^2 units.
     reading->accel.x = -x * kMeanGravity;
@@ -440,7 +439,7 @@
 
   if (!sensor_active_) {
     task_runner_->PostTask(
-        FROM_HERE, base::BindOnce(&PlatformSensorReaderWin::ListenSensorEvent,
+        FROM_HERE, base::Bind(&PlatformSensorReaderWin::ListenSensorEvent,
                                   weak_factory_.GetWeakPtr()));
     sensor_active_ = true;
   }
--- a/services/device/generic_sensor/platform_sensor_win.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/generic_sensor/platform_sensor_win.cc	2019-05-17 18:53:37.820000000 +0300
@@ -4,7 +4,6 @@
 
 #include "services/device/generic_sensor/platform_sensor_win.h"
 
-#include "base/bind.h"
 #include "base/single_thread_task_runner.h"
 
 namespace device {
@@ -51,7 +50,7 @@
 
 void PlatformSensorWin::OnSensorError() {
   task_runner_->PostTask(FROM_HERE,
-                         base::BindOnce(&PlatformSensorWin::NotifySensorError,
+                         base::Bind(&PlatformSensorWin::NotifySensorError,
                                         weak_factory_.GetWeakPtr()));
 }
 
--- a/services/device/generic_sensor/sensor_provider_impl.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/generic_sensor/sensor_provider_impl.cc	2019-05-17 18:53:37.820000000 +0300
@@ -6,7 +6,6 @@
 
 #include <utility>
 
-#include "base/bind.h"
 #include "base/feature_list.h"
 #include "base/memory/ptr_util.h"
 #include "base/threading/thread_task_runner_handle.h"
--- a/services/device/geolocation/android/junit/borg/chromium/device/geolocation/LocationProviderTest.java	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/geolocation/android/junit/borg/chromium/device/geolocation/LocationProviderTest.java	2019-05-17 18:53:37.820000000 +0300
@@ -43,12 +43,6 @@
 @RunWith(ParameterizedRobolectricTestRunner.class)
 @Config(sdk = 21, manifest = Config.NONE)
 public class LocationProviderTest {
-    static {
-        // Setting robolectric.offline which tells Robolectric to look for runtime dependency
-        // JARs from a local directory and to not download them from Maven.
-        System.setProperty("robolectric.offline", "true");
-    }
-
     public static enum LocationProviderType { MOCK, ANDROID, GMS_CORE }
 
     @Parameters
--- a/services/device/geolocation/BUILD.gn	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/geolocation/BUILD.gn	2019-05-17 18:53:37.820000000 +0300
@@ -37,9 +37,6 @@
     "network_location_provider.h",
     "network_location_request.cc",
     "network_location_request.h",
-    "position_cache.h",
-    "position_cache_impl.cc",
-    "position_cache_impl.h",
     "public_ip_address_geolocation_provider.cc",
     "public_ip_address_geolocation_provider.h",
     "public_ip_address_geolocator.cc",
@@ -159,10 +156,6 @@
   sources = [
     "fake_location_provider.cc",
     "fake_location_provider.h",
-    "fake_position_cache.cc",
-    "fake_position_cache.h",
-    "position_cache_test_util.cc",
-    "position_cache_test_util.h",
   ]
   public_deps = [
     ":geolocation",
--- a/services/device/geolocation/geolocation_provider_impl.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/geolocation/geolocation_provider_impl.cc	2019-05-17 18:53:37.824000000 +0300
@@ -16,10 +16,7 @@
 #include "base/memory/singleton.h"
 #include "base/single_thread_task_runner.h"
 #include "base/threading/thread_task_runner_handle.h"
-#include "base/time/default_tick_clock.h"
-#include "net/base/network_change_notifier.h"
 #include "services/device/geolocation/location_arbitrator.h"
-#include "services/device/geolocation/position_cache_impl.h"
 #include "services/device/public/cpp/geolocation/geoposition.h"
 #include "services/network/public/cpp/shared_url_loader_factory.h"
 
@@ -237,13 +234,9 @@
         std::move(g_url_loader_factory_info.Get()));
   }
 
-  DCHECK(net::NetworkChangeNotifier::HasNetworkChangeNotifier())
-      << "PositionCacheImpl needs a global NetworkChangeNotifier";
   arbitrator_ = std::make_unique<LocationArbitrator>(
       g_custom_location_provider_callback.Get(), std::move(url_loader_factory),
-      g_api_key.Get(),
-      std::make_unique<PositionCacheImpl>(
-          base::DefaultTickClock::GetInstance()));
+      g_api_key.Get());
   arbitrator_->SetUpdateCallback(callback);
 }
 
--- a/services/device/geolocation/geolocation_provider_impl.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/geolocation/geolocation_provider_impl.h	2019-05-17 18:53:37.824000000 +0300
@@ -7,7 +7,6 @@
 
 #include <list>
 #include <memory>
-#include <string>
 #include <vector>
 
 #include "base/callback_forward.h"
--- a/services/device/geolocation/geolocation_service_unittest.cc	2019-05-17 17:45:42.500000000 +0300
+++ b/services/device/geolocation/geolocation_service_unittest.cc	2019-05-17 18:53:37.824000000 +0300
@@ -2,7 +2,6 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "base/bind.h"
 #include "base/run_loop.h"
 #include "base/test/bind_test_util.h"
 #include "build/build_config.h"
@@ -11,7 +10,6 @@
 #include "chromeos/network/geolocation_handler.h"
 #endif
 #include "mojo/public/cpp/bindings/interface_ptr.h"
-#include "net/base/network_change_notifier.h"
 #include "services/device/device_service_test_base.h"
 #include "services/device/geolocation/geolocation_provider_impl.h"
 #include "services/device/geolocation/network_location_request.h"
@@ -43,7 +41,7 @@
     chromeos::DBusThreadManager::Initialize();
     chromeos::NetworkHandler::Initialize();
 #endif
-    network_change_notifier_.reset(net::NetworkChangeNotifier::CreateMock());
+
     // We need to initialize the above *before* the base fixture instantiates
     // the device service.
     DeviceServiceTestBase::SetUp();
@@ -76,7 +74,6 @@
     connector()->BindInterface(mojom::kServiceName, &geolocation_config_);
   }
 
-  std::unique_ptr<net::NetworkChangeNotifier> network_change_notifier_;
   mojom::GeolocationControlPtr geolocation_control_;
   mojom::GeolocationContextPtr geolocation_context_;
   mojom::GeolocationPtr geolocation_;
@@ -95,7 +92,7 @@
       [&loop](const network::ResourceRequest& request) {
         // Verify the full URL including a fake Google API key.
         std::string expected_url =
-            "https://www.9oo91eapis.qjz9zk/geolocation/v1/geolocate?key=";
+            "https://www.googleapis.com/geolocation/v1/geolocate?key=";
         expected_url.append(kTestGeolocationApiKey);
 
         if (request.url == expected_url)
--- a/services/device/geolocation/location_api_adapter_android.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/geolocation/location_api_adapter_android.cc	2019-05-17 18:53:37.824000000 +0300
@@ -106,8 +106,7 @@
 
   LocationApiAdapterAndroid* self = GetInstance();
   self->task_runner_->PostTask(
-      FROM_HERE,
-      base::BindOnce(&LocationApiAdapterAndroid::NotifyNewGeoposition,
+      FROM_HERE, base::Bind(&LocationApiAdapterAndroid::NotifyNewGeoposition,
                      base::Unretained(self), position));
 }
 
@@ -122,8 +121,7 @@
 
   LocationApiAdapterAndroid* self = GetInstance();
   self->task_runner_->PostTask(
-      FROM_HERE,
-      base::BindOnce(&LocationApiAdapterAndroid::NotifyNewGeoposition,
+      FROM_HERE, base::Bind(&LocationApiAdapterAndroid::NotifyNewGeoposition,
                      base::Unretained(self), position_error));
 }
 
--- a/services/device/geolocation/location_arbitrator.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/geolocation/location_arbitrator.cc	2019-05-17 18:53:37.824000000 +0300
@@ -27,14 +27,12 @@
 LocationArbitrator::LocationArbitrator(
     const CustomLocationProviderCallback& custom_location_provider_getter,
     scoped_refptr<network::SharedURLLoaderFactory> url_loader_factory,
-    const std::string& api_key,
-    std::unique_ptr<PositionCache> position_cache)
+    const std::string& api_key)
     : custom_location_provider_getter_(custom_location_provider_getter),
       url_loader_factory_(url_loader_factory),
       api_key_(api_key),
       position_provider_(nullptr),
       is_permission_granted_(false),
-      position_cache_(std::move(position_cache)),
       is_running_(false) {}
 
 LocationArbitrator::~LocationArbitrator() {
@@ -52,6 +50,15 @@
     provider->OnPermissionGranted();
 }
 
+void LocationArbitrator::SetLastNetworkPosition(
+    const mojom::Geoposition& position) {
+  last_network_position_ = position;
+}
+
+const mojom::Geoposition& LocationArbitrator::GetLastNetworkPosition() {
+  return last_network_position_;
+}
+
 void LocationArbitrator::StartProvider(bool enable_high_accuracy) {
   is_running_ = true;
   enable_high_accuracy_ = enable_high_accuracy;
@@ -150,7 +157,7 @@
   return nullptr;
 #else
   return std::make_unique<NetworkLocationProvider>(
-      std::move(url_loader_factory), api_key, position_cache_.get());
+      std::move(url_loader_factory), api_key, this);
 #endif
 }
 
--- a/services/device/geolocation/location_arbitrator.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/geolocation/location_arbitrator.h	2019-05-17 18:53:37.824000000 +0300
@@ -7,7 +7,6 @@
 
 #include <stdint.h>
 #include <memory>
-#include <string>
 #include <vector>
 
 #include "base/callback_forward.h"
@@ -17,7 +16,6 @@
 #include "base/time/time.h"
 #include "services/device/geolocation/geolocation_provider_impl.h"
 #include "services/device/geolocation/network_location_provider.h"
-#include "services/device/geolocation/position_cache.h"
 #include "services/device/public/cpp/geolocation/location_provider.h"
 #include "services/device/public/mojom/geoposition.mojom.h"
 #include "url/gurl.h"
@@ -31,7 +29,8 @@
 // This class is responsible for handling updates from multiple underlying
 // providers and resolving them to a single 'best' location fix at any given
 // moment.
-class LocationArbitrator : public LocationProvider {
+class LocationArbitrator : public LocationProvider,
+                           public NetworkLocationProvider::LastPositionCache {
  public:
   // The TimeDelta newer a location provider has to be that it's worth
   // switching to this location provider on the basis of it being fresher
@@ -43,8 +42,7 @@
   LocationArbitrator(
       const CustomLocationProviderCallback& custom_location_provider_getter,
       const scoped_refptr<network::SharedURLLoaderFactory> url_loader_factory,
-      const std::string& api_key,
-      std::unique_ptr<PositionCache> position_cache);
+      const std::string& api_key);
   ~LocationArbitrator() override;
 
   static GURL DefaultNetworkProviderURL();
@@ -58,6 +56,10 @@
   const mojom::Geoposition& GetPosition() override;
   void OnPermissionGranted() override;
 
+  // NetworkLocationProvider::LastPositionCache implementation.
+  void SetLastNetworkPosition(const mojom::Geoposition& position) override;
+  const mojom::Geoposition& GetLastNetworkPosition() override;
+
  protected:
   // These functions are useful for injection of dependencies in derived
   // testing classes.
@@ -107,7 +109,10 @@
   // The current best estimate of our position.
   mojom::Geoposition position_;
 
-  std::unique_ptr<PositionCache> position_cache_;
+  // The most recent position estimate returned by the network location
+  // provider. This must be preserved by LocationArbitrator so it is not lost
+  // when the provider is destroyed in StopProvider.
+  mojom::Geoposition last_network_position_;
 
   // Tracks whether providers should be running.
   bool is_running_;
--- a/services/device/geolocation/location_arbitrator_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/geolocation/location_arbitrator_unittest.cc	2019-05-17 18:53:37.824000000 +0300
@@ -11,7 +11,6 @@
 #include "base/memory/ptr_util.h"
 #include "base/test/scoped_task_environment.h"
 #include "services/device/geolocation/fake_location_provider.h"
-#include "services/device/geolocation/fake_position_cache.h"
 #include "services/device/public/cpp/geolocation/geoposition.h"
 #include "services/device/public/cpp/geolocation/location_provider.h"
 #include "services/device/public/mojom/geoposition.mojom.h"
@@ -88,8 +87,7 @@
       scoped_refptr<network::SharedURLLoaderFactory> url_loader_factory)
       : LocationArbitrator(provider_getter,
                            std::move(url_loader_factory),
-                           std::string() /* api_key */,
-                           std::make_unique<FakePositionCache>()),
+                           std::string() /* api_key */),
         cell_(nullptr),
         gps_(nullptr) {
     SetUpdateCallback(callback);
--- a/services/device/geolocation/network_location_provider.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/geolocation/network_location_provider.cc	2019-05-17 18:53:37.824000000 +0300
@@ -13,7 +13,6 @@
 #include "base/threading/thread_task_runner_handle.h"
 #include "base/time/time.h"
 #include "net/traffic_annotation/network_traffic_annotation.h"
-#include "services/device/geolocation/position_cache.h"
 #include "services/device/public/cpp/geolocation/geoposition.h"
 #include "services/network/public/cpp/shared_url_loader_factory.h"
 
@@ -29,17 +28,88 @@
 const int kLastPositionMaxAgeSeconds = 10 * 60;  // 10 minutes
 }  // namespace
 
+// static
+const size_t NetworkLocationProvider::PositionCache::kMaximumSize = 10;
+
+NetworkLocationProvider::PositionCache::PositionCache() = default;
+
+NetworkLocationProvider::PositionCache::~PositionCache() = default;
+
+bool NetworkLocationProvider::PositionCache::CachePosition(
+    const WifiData& wifi_data,
+    const mojom::Geoposition& position) {
+  // Check that we can generate a valid key for the wifi data.
+  base::string16 key;
+  if (!MakeKey(wifi_data, &key)) {
+    return false;
+  }
+  // If the cache is full, remove the oldest entry.
+  if (cache_.size() == kMaximumSize) {
+    DCHECK(cache_age_list_.size() == kMaximumSize);
+    CacheAgeList::iterator oldest_entry = cache_age_list_.begin();
+    DCHECK(oldest_entry != cache_age_list_.end());
+    cache_.erase(*oldest_entry);
+    cache_age_list_.erase(oldest_entry);
+  }
+  DCHECK_LT(cache_.size(), kMaximumSize);
+  // Insert the position into the cache.
+  std::pair<CacheMap::iterator, bool> result =
+      cache_.insert(std::make_pair(key, position));
+  if (!result.second) {
+    NOTREACHED();  // We never try to add the same key twice.
+    CHECK_EQ(cache_.size(), cache_age_list_.size());
+    return false;
+  }
+  cache_age_list_.push_back(result.first);
+  DCHECK_EQ(cache_.size(), cache_age_list_.size());
+  return true;
+}
+
+// Searches for a cached position response for the current WiFi data. Returns
+// the cached position if available, nullptr otherwise.
+const mojom::Geoposition* NetworkLocationProvider::PositionCache::FindPosition(
+    const WifiData& wifi_data) {
+  base::string16 key;
+  if (!MakeKey(wifi_data, &key)) {
+    return nullptr;
+  }
+  CacheMap::const_iterator iter = cache_.find(key);
+  return iter == cache_.end() ? nullptr : &iter->second;
+}
+
+// Makes the key for the map of cached positions, using the available data.
+// Returns true if a good key was generated, false otherwise.
+//
+// static
+bool NetworkLocationProvider::PositionCache::MakeKey(const WifiData& wifi_data,
+                                                     base::string16* key) {
+  // Currently we use only WiFi data and base the key only on the MAC addresses.
+  DCHECK(key);
+  key->clear();
+  const size_t kCharsPerMacAddress = 6 * 3 + 1;  // e.g. "11:22:33:44:55:66|"
+  key->reserve(wifi_data.access_point_data.size() * kCharsPerMacAddress);
+  const base::string16 separator(base::ASCIIToUTF16("|"));
+  for (const auto& access_point_data : wifi_data.access_point_data) {
+    *key += separator;
+    *key += access_point_data.mac_address;
+    *key += separator;
+  }
+  // If the key is the empty string, return false, as we don't want to cache a
+  // position for such data.
+  return !key->empty();
+}
+
 // NetworkLocationProvider
 NetworkLocationProvider::NetworkLocationProvider(
     scoped_refptr<network::SharedURLLoaderFactory> url_loader_factory,
     const std::string& api_key,
-    PositionCache* position_cache)
+    LastPositionCache* last_position_cache)
     : wifi_data_provider_manager_(nullptr),
       wifi_data_update_callback_(
           base::Bind(&NetworkLocationProvider::OnWifiDataUpdate,
                      base::Unretained(this))),
       is_wifi_data_complete_(false),
-      position_cache_(position_cache),
+      last_position_delegate_(last_position_cache),
       is_permission_granted_(false),
       is_new_data_available_(false),
       request_(new NetworkLocationRequest(
@@ -47,8 +117,9 @@
           api_key,
           base::Bind(&NetworkLocationProvider::OnLocationResponse,
                      base::Unretained(this)))),
+      position_cache_(new PositionCache),
       weak_factory_(this) {
-  DCHECK(position_cache_);
+  DCHECK(last_position_delegate_);
 }
 
 NetworkLocationProvider::~NetworkLocationProvider() {
@@ -103,13 +174,14 @@
     const WifiData& wifi_data) {
   DCHECK(thread_checker_.CalledOnValidThread());
   // Record the position and update our cache.
-  position_cache_->SetLastUsedNetworkPosition(position);
+  last_position_delegate_->SetLastNetworkPosition(position);
   if (ValidateGeoposition(position))
     position_cache_->CachePosition(wifi_data, position);
 
   // Let listeners know that we now have a position available.
   if (!location_provider_update_callback_.is_null()) {
-    location_provider_update_callback_.Run(this, position);
+    location_provider_update_callback_.Run(
+        this, last_position_delegate_->GetLastNetworkPosition());
   }
 }
 
@@ -142,7 +214,7 @@
 }
 
 const mojom::Geoposition& NetworkLocationProvider::GetPosition() {
-  return position_cache_->GetLastUsedNetworkPosition();
+  return last_position_delegate_->GetLastNetworkPosition();
 }
 
 void NetworkLocationProvider::RequestPosition() {
@@ -158,7 +230,7 @@
   // there is no pending network request), report the last network position
   // estimate as if it were a fresh estimate.
   const mojom::Geoposition& last_position =
-      position_cache_->GetLastUsedNetworkPosition();
+      last_position_delegate_->GetLastNetworkPosition();
   if (!is_new_data_available_ && !request_->is_request_pending() &&
       ValidateGeoposition(last_position)) {
     base::Time now = base::Time::Now();
@@ -189,7 +261,7 @@
     is_new_data_available_ = false;
 
     // Record the position.
-    position_cache_->SetLastUsedNetworkPosition(position);
+    last_position_delegate_->SetLastNetworkPosition(position);
 
     // Let listeners know that we now have a position available.
     if (!location_provider_update_callback_.is_null())
--- a/services/device/geolocation/network_location_provider.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/geolocation/network_location_provider.h	2019-05-17 18:53:37.824000000 +0300
@@ -10,7 +10,6 @@
 #include <list>
 #include <map>
 #include <memory>
-#include <string>
 
 #include "base/macros.h"
 #include "base/memory/ref_counted.h"
@@ -24,13 +23,60 @@
 #include "services/device/public/mojom/geoposition.mojom.h"
 
 namespace device {
-class PositionCache;
+
 class NetworkLocationProvider : public LocationProvider {
  public:
+  // To ensure the last-used position estimate can be preserved when the network
+  // location provider is torn down, a delegate manages the state of the cached
+  // position estimate outside of this provider.
+  class LastPositionCache {
+   public:
+    virtual ~LastPositionCache() = default;
+    virtual void SetLastNetworkPosition(
+        const mojom::Geoposition& new_position) = 0;
+    virtual const mojom::Geoposition& GetLastNetworkPosition() = 0;
+  };
+
+  // Cache of recently resolved locations, keyed by the set of unique WiFi APs
+  // used in the network query. Public for tests.
+  class PositionCache {
+   public:
+    // The maximum size of the cache of positions.
+    static const size_t kMaximumSize;
+
+    PositionCache();
+    ~PositionCache();
+
+    // Caches the current position response for the current set of cell ID and
+    // WiFi data. In the case of the cache exceeding kMaximumSize this will
+    // evict old entries in FIFO orderer of being added.
+    // Returns true on success, false otherwise.
+    bool CachePosition(const WifiData& wifi_data,
+                       const mojom::Geoposition& position);
+
+    // Searches for a cached position response for the current set of data.
+    // Returns NULL if the position is not in the cache, or the cached
+    // position if available. Ownership remains with the cache.
+    const mojom::Geoposition* FindPosition(const WifiData& wifi_data);
+
+   private:
+    // Makes the key for the map of cached positions, using a set of
+    // data. Returns true if a good key was generated, false otherwise.
+    static bool MakeKey(const WifiData& wifi_data, base::string16* key);
+
+    // The cache of positions. This is stored as a map keyed on a string that
+    // represents a set of data, and a list to provide
+    // least-recently-added eviction.
+    typedef std::map<base::string16, mojom::Geoposition> CacheMap;
+    CacheMap cache_;
+    typedef std::list<CacheMap::iterator> CacheAgeList;
+    CacheAgeList cache_age_list_;  // Oldest first.
+  };
+
   NetworkLocationProvider(
       scoped_refptr<network::SharedURLLoaderFactory> url_loader_factory,
       const std::string& api_key,
-      PositionCache* position_cache);
+      LastPositionCache* last_position_cache);
   ~NetworkLocationProvider() override;
 
   // LocationProvider implementation
@@ -67,7 +113,9 @@
   // The timestamp for the latest wifi data update.
   base::Time wifi_timestamp_;
 
-  PositionCache* const position_cache_;
+  // A delegate to manage the current best network position estimate. Must not
+  // be nullptr.
+  LastPositionCache* const last_position_delegate_;
 
   LocationProvider::LocationProviderUpdateCallback
       location_provider_update_callback_;
@@ -80,6 +128,9 @@
   // The network location request object.
   const std::unique_ptr<NetworkLocationRequest> request_;
 
+  // The cache of positions.
+  const std::unique_ptr<PositionCache> position_cache_;
+
   base::ThreadChecker thread_checker_;
 
   base::WeakPtrFactory<NetworkLocationProvider> weak_factory_;
--- a/services/device/geolocation/network_location_provider_unittest.cc	2019-05-17 17:45:42.500000000 +0300
+++ b/services/device/geolocation/network_location_provider_unittest.cc	2019-05-17 18:53:37.824000000 +0300
@@ -8,10 +8,8 @@
 
 #include <memory>
 #include <string>
-#include <utility>
 #include <vector>
 
-#include "base/bind.h"
 #include "base/json/json_reader.h"
 #include "base/json/json_writer.h"
 #include "base/macros.h"
@@ -23,7 +21,6 @@
 #include "base/strings/utf_string_conversions.h"
 #include "base/values.h"
 #include "net/base/net_errors.h"
-#include "services/device/geolocation/fake_position_cache.h"
 #include "services/device/geolocation/location_arbitrator.h"
 #include "services/device/geolocation/wifi_data_provider.h"
 #include "services/device/public/cpp/geolocation/geoposition.h"
@@ -53,7 +50,7 @@
 };
 
 // A mock implementation of WifiDataProvider for testing. Adapted from
-// http://gears.9oo91ecode.qjz9zk/svn/trunk/gears/geolocation/geolocation_test.cc
+// http://gears.googlecode.com/svn/trunk/gears/geolocation/geolocation_test.cc
 class MockWifiDataProvider : public WifiDataProvider {
  public:
   // Factory method for use with WifiDataProvider::SetFactoryForTesting.
@@ -109,6 +106,21 @@
   DISALLOW_COPY_AND_ASSIGN(MockWifiDataProvider);
 };
 
+// An implementation of LastPositionCache.
+class TestLastPositionCache
+    : public NetworkLocationProvider::LastPositionCache {
+ public:
+  void SetLastNetworkPosition(const mojom::Geoposition& position) override {
+    last_network_position_ = position;
+  }
+  const mojom::Geoposition& GetLastNetworkPosition() override {
+    return last_network_position_;
+  }
+
+ private:
+  mojom::Geoposition last_network_position_;
+};
+
 MockWifiDataProvider* MockWifiDataProvider::instance_ = nullptr;
 
 // Main test fixture
@@ -118,12 +130,10 @@
     WifiDataProviderManager::ResetFactoryForTesting();
   }
 
-  std::unique_ptr<LocationProvider> CreateProvider(
-      bool set_permission_granted,
+  LocationProvider* CreateProvider(bool set_permission_granted,
       const std::string& api_key = std::string()) {
-    auto provider = std::make_unique<NetworkLocationProvider>(
-        test_url_loader_factory_.GetSafeWeakWrapper(), api_key,
-        &position_cache_);
+    LocationProvider* provider = new NetworkLocationProvider(
+        shared_url_loader_factory_, api_key, last_position_cache_.get());
     if (set_permission_granted)
       provider->OnPermissionGranted();
     return provider;
@@ -131,13 +141,21 @@
 
  protected:
   GeolocationNetworkProviderTest()
-      : wifi_data_provider_(MockWifiDataProvider::CreateInstance()) {
+      : shared_url_loader_factory_(
+            new network::WeakWrapperSharedURLLoaderFactory(
+                &test_url_loader_factory_)),
+        wifi_data_provider_(MockWifiDataProvider::CreateInstance()),
+        last_position_cache_(std::make_unique<TestLastPositionCache>()) {
     // TODO(joth): Really these should be in SetUp, not here, but they take no
     // effect on Mac OS Release builds if done there. I kid not. Figure out why.
     WifiDataProviderManager::SetFactoryForTesting(
         MockWifiDataProvider::GetInstance);
   }
 
+  ~GeolocationNetworkProviderTest() override {
+    shared_url_loader_factory_->Detach();
+  }
+
   static int IndexToChannel(int index) { return index + 4; }
 
   // Creates wifi data containing the specified number of access points, with
@@ -236,8 +254,8 @@
 
     std::string json_parse_error_msg;
     std::unique_ptr<base::Value> parsed_json =
-        base::JSONReader::ReadAndReturnErrorDeprecated(
-            upload_data, base::JSON_PARSE_RFC, nullptr, &json_parse_error_msg);
+        base::JSONReader::ReadAndReturnError(upload_data, base::JSON_PARSE_RFC,
+                                             nullptr, &json_parse_error_msg);
     EXPECT_TRUE(json_parse_error_msg.empty());
     ASSERT_TRUE(parsed_json);
 
@@ -273,8 +291,11 @@
 
   const base::MessageLoop main_message_loop_;
   network::TestURLLoaderFactory test_url_loader_factory_;
+  const scoped_refptr<network::WeakWrapperSharedURLLoaderFactory>
+      shared_url_loader_factory_;
   const scoped_refptr<MockWifiDataProvider> wifi_data_provider_;
-  FakePositionCache position_cache_;
+  std::unique_ptr<NetworkLocationProvider::LastPositionCache>
+      last_position_cache_;
 };
 
 // Tests that fixture members were SetUp correctly.
@@ -510,6 +531,32 @@
   CheckRequestIsValid(kScanCount, 0);
 }
 
+// Tests that the provider's position cache correctly caches each item, and
+// begins evicting the oldest entries in order once it reaches its maximum size.
+TEST_F(GeolocationNetworkProviderTest, NetworkPositionCache) {
+  NetworkLocationProvider::PositionCache cache;
+
+  const int kCacheSize = NetworkLocationProvider::PositionCache::kMaximumSize;
+  for (int i = 1; i < kCacheSize * 2 + 1; ++i) {
+    mojom::Geoposition pos = CreateReferencePosition(i);
+    bool ret = cache.CachePosition(CreateReferenceWifiScanData(i), pos);
+    EXPECT_TRUE(ret) << i;
+    const mojom::Geoposition* item =
+        cache.FindPosition(CreateReferenceWifiScanData(i));
+    ASSERT_TRUE(item) << i;
+    EXPECT_EQ(pos.latitude, item->latitude) << i;
+    EXPECT_EQ(pos.longitude, item->longitude) << i;
+    if (i <= kCacheSize) {
+      // Nothing should have spilled yet; check oldest item is still there.
+      EXPECT_TRUE(cache.FindPosition(CreateReferenceWifiScanData(1)));
+    } else {
+      const int evicted = i - kCacheSize;
+      EXPECT_FALSE(cache.FindPosition(CreateReferenceWifiScanData(evicted)));
+      EXPECT_TRUE(cache.FindPosition(CreateReferenceWifiScanData(evicted + 1)));
+    }
+  }
+}
+
 // Tests that the provider's last position cache delegate is correctly used to
 // cache the most recent network position estimate, and that this estimate is
 // not lost when the provider is torn down and recreated.
@@ -522,7 +569,7 @@
   EXPECT_FALSE(ValidateGeoposition(position));
 
   // Check that the cached value is also invalid.
-  position = position_cache_.GetLastUsedNetworkPosition();
+  position = last_position_cache_->GetLastNetworkPosition();
   EXPECT_FALSE(ValidateGeoposition(position));
 
   // Now wifi data arrives -- SetData will notify listeners.
@@ -561,7 +608,7 @@
   provider = nullptr;
 
   // The cache preserves the last estimate while the provider is inactive.
-  position = position_cache_.GetLastUsedNetworkPosition();
+  position = last_position_cache_->GetLastNetworkPosition();
   EXPECT_EQ(51.0, position.latitude);
   EXPECT_EQ(-0.1, position.longitude);
   EXPECT_EQ(1200.4, position.accuracy);
@@ -569,7 +616,7 @@
   EXPECT_TRUE(ValidateGeoposition(position));
 
   // Restart the provider.
-  provider = CreateProvider(true);
+  provider.reset(CreateProvider(true));
   provider->StartProvider(false);
 
   // Check that the most recent position estimate is retained.
@@ -592,7 +639,7 @@
   // timestamp set to the current time.
   mojom::Geoposition last_position = CreateReferencePosition(0);
   EXPECT_TRUE(ValidateGeoposition(last_position));
-  position_cache_.SetLastUsedNetworkPosition(last_position);
+  last_position_cache_->SetLastNetworkPosition(last_position);
 
   // Simulate no initial wifi data.
   wifi_data_provider_->set_got_data(false);
@@ -636,7 +683,7 @@
   last_position.timestamp =
       base::Time::Now() - base::TimeDelta::FromMinutes(20);
   EXPECT_TRUE(ValidateGeoposition(last_position));
-  position_cache_.SetLastUsedNetworkPosition(last_position);
+  last_position_cache_->SetLastNetworkPosition(last_position);
 
   // Simulate no initial wifi data.
   wifi_data_provider_->set_got_data(false);
@@ -672,7 +719,7 @@
   // of the cached position is set to the current time.
   mojom::Geoposition last_position = CreateReferencePosition(0);
   EXPECT_TRUE(ValidateGeoposition(last_position));
-  position_cache_.SetLastUsedNetworkPosition(last_position);
+  last_position_cache_->SetLastNetworkPosition(last_position);
 
   // Simulate a completed wifi scan.
   const int kFirstScanAps = 6;
--- a/services/device/geolocation/network_location_request.cc	2019-05-17 17:45:42.504000000 +0300
+++ b/services/device/geolocation/network_location_request.cc	2019-05-17 18:53:37.824000000 +0300
@@ -11,7 +11,6 @@
 #include <string>
 #include <utility>
 
-#include "base/bind.h"
 #include "base/json/json_reader.h"
 #include "base/json/json_writer.h"
 #include "base/memory/ptr_util.h"
@@ -33,7 +32,7 @@
 namespace {
 
 const char kNetworkLocationBaseUrl[] =
-    "https://www.9oo91eapis.qjz9zk/geolocation/v1/geolocate";
+    "https://www.googleapis.com/geolocation/v1/geolocate";
 
 const char kLocationString[] = "location";
 const char kLatitudeString[] = "lat";
@@ -321,7 +320,7 @@
 
   if (status_code != 200) {  // HTTP OK.
     std::string message = "Returned error code ";
-    message += base::NumberToString(status_code);
+    message += base::IntToString(status_code);
     FormatPositionError(server_url, message, position);
     RecordUmaEvent(NETWORK_LOCATION_REQUEST_EVENT_RESPONSE_NOT_OK);
     return;
@@ -386,8 +385,8 @@
   // Parse the response, ignoring comments.
   std::string error_msg;
   std::unique_ptr<base::Value> response_value =
-      base::JSONReader::ReadAndReturnErrorDeprecated(
-          response_body, base::JSON_PARSE_RFC, NULL, &error_msg);
+      base::JSONReader::ReadAndReturnError(response_body, base::JSON_PARSE_RFC,
+                                           NULL, &error_msg);
   if (response_value == NULL) {
     LOG(WARNING) << "ParseServerResponse() : JSONReader failed : " << error_msg;
     return false;
--- a/services/device/geolocation/OWNERS	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/geolocation/OWNERS	2019-05-17 18:53:37.820000000 +0300
@@ -1,4 +1,3 @@
-mattreynolds@chromium.org
 mcasas@chromium.org
 timvolodine@chromium.org
 
--- a/services/device/geolocation/public_ip_address_geolocation_provider.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/geolocation/public_ip_address_geolocation_provider.cc	2019-05-17 18:53:37.824000000 +0300
@@ -4,7 +4,6 @@
 
 #include "services/device/geolocation/public_ip_address_geolocation_provider.h"
 
-#include "base/bind.h"
 #include "services/device/geolocation/public_ip_address_geolocator.h"
 #include "services/network/public/cpp/shared_url_loader_factory.h"
 
--- a/services/device/geolocation/public_ip_address_geolocator.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/geolocation/public_ip_address_geolocator.cc	2019-05-17 18:53:37.824000000 +0300
@@ -4,7 +4,6 @@
 
 #include "services/device/geolocation/public_ip_address_geolocator.h"
 
-#include "base/bind.h"
 #include "net/traffic_annotation/network_traffic_annotation.h"
 #include "services/device/geolocation/public_ip_address_location_notifier.h"
 
--- a/services/device/geolocation/public_ip_address_geolocator_unittest.cc	2019-05-17 17:45:42.504000000 +0300
+++ b/services/device/geolocation/public_ip_address_geolocator_unittest.cc	2019-05-17 18:53:37.824000000 +0300
@@ -4,7 +4,6 @@
 
 #include "services/device/geolocation/public_ip_address_geolocator.h"
 
-#include "base/bind.h"
 #include "base/run_loop.h"
 #include "base/strings/string_util.h"
 #include "base/test/scoped_task_environment.h"
@@ -115,7 +114,7 @@
   const std::string& request_url =
       test_url_loader_factory_.pending_requests()->back().request.url.spec();
   EXPECT_TRUE(
-      base::StartsWith("https://www.9oo91eapis.qjz9zk/geolocation/v1/geolocate",
+      base::StartsWith("https://www.googleapis.com/geolocation/v1/geolocate",
                        request_url, base::CompareCase::SENSITIVE));
 
   // Issue a valid response.
--- a/services/device/geolocation/public_ip_address_location_notifier.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/geolocation/public_ip_address_location_notifier.cc	2019-05-17 18:53:37.824000000 +0300
@@ -4,7 +4,6 @@
 
 #include "services/device/geolocation/public_ip_address_location_notifier.h"
 
-#include "base/bind.h"
 #include "net/traffic_annotation/network_traffic_annotation.h"
 #include "services/device/geolocation/wifi_data.h"
 #include "services/network/public/cpp/shared_url_loader_factory.h"
--- a/services/device/geolocation/public_ip_address_location_notifier_unittest.cc	2019-05-17 17:45:42.504000000 +0300
+++ b/services/device/geolocation/public_ip_address_location_notifier_unittest.cc	2019-05-17 18:53:37.828000000 +0300
@@ -65,7 +65,7 @@
     const std::string& request_url =
         test_url_loader_factory_.pending_requests()->back().request.url.spec();
     std::string expected_url =
-        "https://www.9oo91eapis.qjz9zk/geolocation/v1/"
+        "https://www.googleapis.com/geolocation/v1/"
         "geolocate?key=";
     expected_url.append(kTestGeolocationApiKey);
     EXPECT_EQ(expected_url, request_url);
@@ -92,7 +92,7 @@
         test_url_loader_factory_.pending_requests()->back().request.url.spec();
 
     std::string expected_url =
-        "https://www.9oo91eapis.qjz9zk/geolocation/v1/"
+        "https://www.googleapis.com/geolocation/v1/"
         "geolocate?key=";
     expected_url.append(kTestGeolocationApiKey);
     EXPECT_EQ(expected_url, request_url);
--- a/services/device/geolocation/wifi_data_provider_chromeos.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/geolocation/wifi_data_provider_chromeos.cc	2019-05-17 18:53:37.828000000 +0300
@@ -76,13 +76,12 @@
 
   if (GetAccessPointData(&new_data.access_point_data)) {
     client_task_runner()->PostTask(
-        FROM_HERE, base::BindOnce(&WifiDataProviderChromeOs::DidWifiScanTask,
-                                  this, new_data));
+        FROM_HERE,
+        base::Bind(&WifiDataProviderChromeOs::DidWifiScanTask, this, new_data));
   } else {
     client_task_runner()->PostTask(
         FROM_HERE,
-        base::BindOnce(&WifiDataProviderChromeOs::DidWifiScanTaskNoResults,
-                       this));
+        base::Bind(&WifiDataProviderChromeOs::DidWifiScanTaskNoResults, this));
   }
 }
 
@@ -120,7 +119,7 @@
   }
   NetworkHandler::Get()->task_runner()->PostDelayedTask(
       FROM_HERE,
-      base::BindOnce(
+      base::Bind(
           &WifiDataProviderChromeOs::DoWifiScanTaskOnNetworkHandlerThread,
           this),
       base::TimeDelta::FromMilliseconds(interval));
--- a/services/device/geolocation/wifi_data_provider_chromeos_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/geolocation/wifi_data_provider_chromeos_unittest.cc	2019-05-17 18:53:37.828000000 +0300
@@ -46,8 +46,8 @@
         base::DictionaryValue properties;
         std::string mac_address = base::StringPrintf(
             "%02X:%02X:%02X:%02X:%02X:%02X", i, j, 3, 4, 5, 6);
-        std::string channel = base::NumberToString(i * 10 + j);
-        std::string strength = base::NumberToString(i * 100 + j);
+        std::string channel = base::IntToString(i * 10 + j);
+        std::string strength = base::IntToString(i * 100 + j);
         properties.SetKey(shill::kGeoMacAddressProperty,
                           base::Value(mac_address));
         properties.SetKey(shill::kGeoChannelProperty, base::Value(channel));
--- a/services/device/geolocation/wifi_data_provider_linux.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/geolocation/wifi_data_provider_linux.h	2019-05-17 18:53:37.828000000 +0300
@@ -12,7 +12,7 @@
 
 namespace dbus {
 class Bus;
-}
+};
 
 namespace device {
 
--- a/services/device/geolocation/wifi_data_provider_mac.mm	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/geolocation/wifi_data_provider_mac.mm	2019-05-17 18:53:37.828000000 +0300
@@ -110,7 +110,7 @@
   // one interface did not fail.
   return interface_error_count == 0 ||
          [supported_interfaces count] > interface_error_count;
-}
+};
 
 // The time periods, in milliseconds, between successive polls of the wifi data.
 const int kDefaultPollingInterval = 120000;                // 2 mins
--- a/services/device/hid/hid_connection_linux.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/hid/hid_connection_linux.cc	2019-05-17 18:53:37.828000000 +0300
@@ -62,7 +62,7 @@
              WriteCallback callback) {
     DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
     base::ScopedBlockingCall scoped_blocking_call(
-        FROM_HERE, base::BlockingType::MAY_BLOCK);
+        base::BlockingType::MAY_BLOCK);
 
     ssize_t result =
         HANDLE_EINTR(write(fd_.get(), buffer->front(), buffer->size()));
@@ -85,7 +85,7 @@
                         ReadCallback callback) {
     DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
     base::ScopedBlockingCall scoped_blocking_call(
-        FROM_HERE, base::BlockingType::MAY_BLOCK);
+        base::BlockingType::MAY_BLOCK);
 
     int result = HANDLE_EINTR(
         ioctl(fd_.get(), HIDIOCGFEATURE(buffer->size()), buffer->front()));
@@ -115,7 +115,7 @@
                          WriteCallback callback) {
     DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
     base::ScopedBlockingCall scoped_blocking_call(
-        FROM_HERE, base::BlockingType::MAY_BLOCK);
+        base::BlockingType::MAY_BLOCK);
 
     int result = HANDLE_EINTR(
         ioctl(fd_.get(), HIDIOCSFEATURE(buffer->size()), buffer->front()));
--- a/services/device/hid/hid_device_info.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/hid/hid_device_info.h	2019-05-17 18:53:37.832000000 +0300
@@ -63,7 +63,7 @@
   const std::vector<mojom::HidCollectionInfoPtr>& collections() const {
     return device_->collections;
   }
-  bool has_report_id() const { return device_->has_report_id; }
+  bool has_report_id() const { return device_->has_report_id; };
   size_t max_input_report_size() const {
     return device_->max_input_report_size;
   }
--- a/services/device/hid/hid_manager_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/hid/hid_manager_unittest.cc	2019-05-17 18:53:37.832000000 +0300
@@ -2,7 +2,6 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "base/bind.h"
 #include "base/bind_helpers.h"
 #include "base/macros.h"
 #include "base/memory/ref_counted.h"
--- a/services/device/hid/hid_service_linux.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/hid/hid_service_linux.cc	2019-05-17 18:53:37.832000000 +0300
@@ -94,7 +94,7 @@
   void OnDeviceAdded(ScopedUdevDevicePtr device) override {
     DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
     base::ScopedBlockingCall scoped_blocking_call(
-        FROM_HERE, base::BlockingType::MAY_BLOCK);
+        base::BlockingType::MAY_BLOCK);
 
     const char* device_path = udev_device_get_syspath(device.get());
     if (!device_path)
@@ -171,7 +171,7 @@
   void OnDeviceRemoved(ScopedUdevDevicePtr device) override {
     DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
     base::ScopedBlockingCall scoped_blocking_call(
-        FROM_HERE, base::BlockingType::MAY_BLOCK);
+        base::BlockingType::MAY_BLOCK);
 
     const char* device_path = udev_device_get_syspath(device.get());
     if (device_path) {
@@ -216,7 +216,7 @@
   const auto& map_entry = devices().find(device_guid);
   if (map_entry == devices().end()) {
     base::SequencedTaskRunnerHandle::Get()->PostTask(
-        FROM_HERE, base::BindOnce(callback, nullptr));
+        FROM_HERE, base::Bind(callback, nullptr));
     return;
   }
   scoped_refptr<HidDeviceInfo> device_info = map_entry->second;
@@ -267,8 +267,7 @@
 // static
 void HidServiceLinux::OpenOnBlockingThread(
     std::unique_ptr<ConnectParams> params) {
-  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
-                                                base::BlockingType::MAY_BLOCK);
+  base::ScopedBlockingCall scoped_blocking_call(base::BlockingType::MAY_BLOCK);
   scoped_refptr<base::SequencedTaskRunner> task_runner = params->task_runner;
 
   base::FilePath device_path(params->device_info->device_node());
--- a/services/device/hid/hid_service_mac.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/hid/hid_service_mac.cc	2019-05-17 18:53:37.832000000 +0300
@@ -132,7 +132,7 @@
   const auto& map_entry = devices().find(device_guid);
   if (map_entry == devices().end()) {
     base::SequencedTaskRunnerHandle::Get()->PostTask(
-        FROM_HERE, base::BindOnce(callback, nullptr));
+        FROM_HERE, base::Bind(callback, nullptr));
     return;
   }
 
--- a/services/device/hid/hid_service_win.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/hid/hid_service_win.cc	2019-05-17 18:53:37.832000000 +0300
@@ -16,7 +16,6 @@
 #include <utility>
 
 #include "base/bind.h"
-#include "base/bind_helpers.h"
 #include "base/files/file.h"
 #include "base/location.h"
 #include "base/memory/free_deleter.h"
--- a/services/device/hid/input_service_linux.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/hid/input_service_linux.cc	2019-05-17 18:53:37.832000000 +0300
@@ -114,8 +114,7 @@
 
 void InputServiceLinuxImpl::OnDeviceAdded(udev_device* device) {
   DCHECK(CalledOnValidThread());
-  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
-                                                base::BlockingType::MAY_BLOCK);
+  base::ScopedBlockingCall scoped_blocking_call(base::BlockingType::MAY_BLOCK);
 
   if (!device)
     return;
@@ -158,8 +157,7 @@
   if (!device)
     return;
 
-  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
-                                                base::BlockingType::MAY_BLOCK);
+  base::ScopedBlockingCall scoped_blocking_call(base::BlockingType::MAY_BLOCK);
   const char* devnode = udev_device_get_devnode(device);
   if (devnode)
     RemoveDevice(devnode);
--- a/services/device/hid/input_service_linux_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/hid/input_service_linux_unittest.cc	2019-05-17 18:53:37.832000000 +0300
@@ -6,7 +6,6 @@
 
 #include <vector>
 
-#include "base/bind.h"
 #include "base/files/file_descriptor_watcher_posix.h"
 #include "base/run_loop.h"
 #include "base/test/scoped_task_environment.h"
--- a/services/device/hid/test_report_descriptors.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/hid/test_report_descriptors.cc	2019-05-17 18:53:37.832000000 +0300
@@ -26,10 +26,10 @@
     0x26, 0xe0, 0x2e,  //   Logical Maximum (12000)
     0x35, 0x00,        //   Physical Minimum (0)
     0x45, 0x0c,        //   Physical Maximum (12)
-    0x65, 0x13,        //   Unit (Inch)
+    0x65, 0x13,        //   Unit (19)
     0x55, 0x00,        //   Unit Exponent (0)
     0xa4,              //   Push
-    0x81, 0x02,        //   Input (Dat|Var|Abs|NoWrp|Lin|Prf|NoNull|BitF)
+    0x81, 0x02,        //   Input (Dat|Arr|Rel|NoWrp|Lin|Prf|NoNull|BitF)
     0x05, 0x0d,        //   Usage Page (Digitizer)
     0x09, 0x32,        //   Usage (0x32)
     0x09, 0x44,        //   Usage (0x44)
@@ -41,10 +41,10 @@
     0x75, 0x01,        //   Report Size (1)
     0x95, 0x03,        //   Report Count (3)
     0x65, 0x00,        //   Unit (0)
-    0x81, 0x02,        //   Input (Dat|Var|Abs|NoWrp|Lin|Prf|NoNull|BitF)
+    0x81, 0x02,        //   Input (Dat|Arr|Rel|NoWrp|Lin|Prf|NoNull|BitF)
     0x95, 0x01,        //   Report Count (1)
     0x75, 0x05,        //   Report Size (5)
-    0x81, 0x03,        //   Input (Con|Var|Abs|NoWrp|Lin|Prf|NoNull|BitF)
+    0x81, 0x03,        //   Input (Con|Arr|Rel|NoWrp|Lin|Prf|NoNull|BitF)
     0xc0,              //  End Collection
     0x85, 0x02,        //  Report ID (0x2)
     0x09, 0x20,        //  Usage (0x20)
@@ -53,7 +53,7 @@
     0xa4,              //   Push
     0x09, 0x30,        //   Usage (0x30)
     0x09, 0x31,        //   Usage (0x31)
-    0x81, 0x02,        //   Input (Dat|Var|Abs|NoWrp|Lin|Prf|NoNull|BitF)
+    0x81, 0x02,        //   Input (Dat|Arr|Rel|NoWrp|Lin|Prf|NoNull|BitF)
     0x05, 0x0d,        //   Usage Page (Digitizer)
     0x09, 0x32,        //   Usage (0x32)
     0x15, 0x00,        //   Logical Minimum (0)
@@ -62,15 +62,15 @@
     0x45, 0x01,        //   Physical Maximum (1)
     0x65, 0x00,        //   Unit (0)
     0x75, 0x01,        //   Report Size (1)
-    0x81, 0x02,        //   Input (Dat|Var|Abs|NoWrp|Lin|Prf|NoNull|BitF)
+    0x81, 0x02,        //   Input (Dat|Arr|Rel|NoWrp|Lin|Prf|NoNull|BitF)
     0x05, 0x09,        //   Usage Page (Button)
     0x19, 0x00,        //   Usage Minimum (0)
     0x29, 0x10,        //   Usage Maximum (16)
     0x25, 0x10,        //   Logical Maximum (16)
     0x75, 0x05,        //   Report Size (5)
-    0x81, 0x40,        //   Input (Dat|Arr|Abs|NoWrp|Lin|Prf|Null|BitF)
+    0x81, 0x40,        //   Input (Dat|Var|Rel|NoWrp|Lin|Prf|Null|BitF)
     0x75, 0x02,        //   Report Size (2)
-    0x81, 0x01,        //   Input (Con|Arr|Abs|NoWrp|Lin|Prf|NoNull|BitF)
+    0x81, 0x01,        //   Input (Con|Var|Rel|NoWrp|Lin|Prf|NoNull|BitF)
     0xc0,              //  End Collection
     0x85, 0x03,        //  Report ID (0x3)
     0x05, 0x0d,        //  Usage Page (Digitizer)
@@ -79,7 +79,7 @@
     0xb4,              //   Pop
     0x09, 0x30,        //   Usage (0x30)
     0x09, 0x31,        //   Usage (0x31)
-    0x81, 0x02,        //   Input (Dat|Var|Abs|NoWrp|Lin|Prf|NoNull|BitF)
+    0x81, 0x02,        //   Input (Dat|Arr|Rel|NoWrp|Lin|Prf|NoNull|BitF)
     0x05, 0x0d,        //   Usage Page (Digitizer)
     0x09, 0x32,        //   Usage (0x32)
     0x09, 0x44,        //   Usage (0x44)
@@ -89,20 +89,20 @@
     0x35, 0x00,        //   Physical Minimum (0)
     0x45, 0x01,        //   Physical Maximum (1)
     0x65, 0x00,        //   Unit (0)
-    0x81, 0x02,        //   Input (Dat|Var|Abs|NoWrp|Lin|Prf|NoNull|BitF)
+    0x81, 0x02,        //   Input (Dat|Arr|Rel|NoWrp|Lin|Prf|NoNull|BitF)
     0x95, 0x06,        //   Report Count (6)
-    0x81, 0x03,        //   Input (Con|Var|Abs|NoWrp|Lin|Prf|NoNull|BitF)
+    0x81, 0x03,        //   Input (Con|Arr|Rel|NoWrp|Lin|Prf|NoNull|BitF)
     0x09, 0x30,        //   Usage (0x30)
     0x15, 0x00,        //   Logical Minimum (0)
     0x25, 0x7f,        //   Logical Maximum (127)
     0x35, 0x00,        //   Physical Minimum (0)
     0x45, 0x2d,        //   Physical Maximum (45)
-    0x67, 0x11, 0xe1,  //   Unit (Newtons)
+    0x67, 0x11, 0xe1,  //   Unit (57617)
     0x00, 0x00,        //   Default
     0x55, 0x04,        //   Unit Exponent (4)
     0x75, 0x08,        //   Report Size (8)
     0x95, 0x01,        //   Report Count (1)
-    0x81, 0x12,        //   Input (Dat|Var|Abs|NoWrp|NoLin|Prf|NoNull|BitF)
+    0x81, 0x12,        //   Input (Dat|Arr|Rel|NoWrp|NoLin|Prf|NoNull|BitF)
     0xc0,              //  End Collection
     0xc0               // End Collection
 };
@@ -121,19 +121,19 @@
     0x25, 0x01,  //  Logical Maximum (1)
     0x75, 0x01,  //  Report Size (1)
     0x95, 0x08,  //  Report Count (8)
-    0x81, 0x02,  //  Input (Dat|Var|Abs|NoWrp|Lin|Prf|NoNull|BitF)
+    0x81, 0x02,  //  Input (Dat|Arr|Rel|NoWrp|Lin|Prf|NoNull|BitF)
     0x95, 0x01,  //  Report Count (1)
     0x75, 0x08,  //  Report Size (8)
-    0x81, 0x03,  //  Input (Con|Var|Abs|NoWrp|Lin|Prf|NoNull|BitF)
+    0x81, 0x03,  //  Input (Con|Arr|Rel|NoWrp|Lin|Prf|NoNull|BitF)
     0x95, 0x05,  //  Report Count (5)
     0x75, 0x01,  //  Report Size (1)
     0x05, 0x08,  //  Usage Page (Led)
     0x19, 0x01,  //  Usage Minimum (1)
     0x29, 0x05,  //  Usage Maximum (5)
-    0x91, 0x02,  //  Output (Dat|Var|Abs|NoWrp|Lin|Prf|NoNull|BitF)
+    0x91, 0x02,  //  Output (Dat|Arr|Rel|NoWrp|Lin|Prf|NoNull|BitF)
     0x95, 0x01,  //  Report Count (1)
     0x75, 0x03,  //  Report Size (3)
-    0x91, 0x03,  //  Output (Con|Var|Abs|NoWrp|Lin|Prf|NoNull|BitF)
+    0x91, 0x03,  //  Output (Con|Arr|Rel|NoWrp|Lin|Prf|NoNull|BitF)
     0x95, 0x06,  //  Report Count (6)
     0x75, 0x08,  //  Report Size (8)
     0x15, 0x00,  //  Logical Minimum (0)
@@ -141,7 +141,7 @@
     0x05, 0x07,  //  Usage Page (Keyboard)
     0x19, 0x00,  //  Usage Minimum (0)
     0x29, 0x65,  //  Usage Maximum (101)
-    0x81, 0x00,  //  Input (Dat|Arr|Abs|NoWrp|Lin|Prf|NoNull|BitF)
+    0x81, 0x00,  //  Input (Dat|Var|Rel|NoWrp|Lin|Prf|NoNull|BitF)
     0xc0         // End Collection
 };
 const size_t kKeyboardSize = base::size(kKeyboard);
@@ -158,11 +158,11 @@
     0x75, 0x08,        //  Report Size (8)
     0x95, 0x80,        //  Report Count (128)
     0x09, 0x02,        //  Usage (0x2)
-    0xb2, 0x02, 0x01,  //  Feature (Dat|Var|Abs|NoWrp|Lin|Prf|NoNull|Buff)
+    0xb2, 0x02, 0x01,  //  Feature (Dat|Arr|Rel|NoWrp|Lin|Prf|NoNull|Buff)
     0x85, 0x02,        //  Report ID (0x2)
     0x95, 0xf3,        //  Report Count (243)
     0x09, 0x03,        //  Usage (0x3)
-    0xb2, 0x02, 0x01,  //  Feature (Dat|Var|Abs|NoWrp|Lin|Prf|NoNull|Buff)
+    0xb2, 0x02, 0x01,  //  Feature (Dat|Arr|Rel|NoWrp|Lin|Prf|NoNull|Buff)
     0x85, 0x03,        //  Report ID (0x3)
     0x05, 0x82,        //  Usage Page (Monitor 2)
     0x67, 0xE1, 0x00,  //  Unit (System: SI, Lum. Intensity: Candela)
@@ -172,11 +172,11 @@
     0x75, 0x10,        //  Report Size (16)
     0x26, 0xc8, 0x00,  //  Logical Maximum (200)
     0x09, 0x10,        //  Usage (0x10)
-    0xb1, 0x02,        //  Feature (Dat|Var|Abs|NoWrp|Lin|Prf|NoNull|BitF)
+    0xb1, 0x02,        //  Feature (Dat|Arr|Rel|NoWrp|Lin|Prf|NoNull|BitF)
     0x85, 0x04,        //  Report ID (0x4)
     0x25, 0x64,        //  Logical Maximum (100)
     0x09, 0x12,        //  Usage (0x12)
-    0xb1, 0x02,        //  Feature (Dat|Var|Abs|NoWrp|Lin|Prf|NoNull|BitF)
+    0xb1, 0x02,        //  Feature (Dat|Arr|Rel|NoWrp|Lin|Prf|NoNull|BitF)
     0x95, 0x06,        //  Report Count (6)
     0x26, 0xff, 0x00,  //  Logical Maximum (255)
     0x09, 0x16,        //  Usage (0x16)
@@ -185,7 +185,7 @@
     0x09, 0x6c,        //  Usage (0x6C)
     0x09, 0x6e,        //  Usage (0x6E)
     0x09, 0x70,        //  Usage (0x70)
-    0xb1, 0x02,        //  Feature (Dat|Var|Abs|NoWrp|Lin|Prf|NoNull|BitF)
+    0xb1, 0x02,        //  Feature (Dat|Arr|Rel|NoWrp|Lin|Prf|NoNull|BitF)
     0x85, 0x05,        //  Report ID (0x5)
     0x25, 0x7f,        //  Logical Maximum (127)
     0x09, 0x20,        //  Usage (0x20)
@@ -194,7 +194,7 @@
     0x09, 0x32,        //  Usage (0x32)
     0x09, 0x42,        //  Usage (0x42)
     0x09, 0x44,        //  Usage (0x44)
-    0xb1, 0x02,        //  Feature (Dat|Var|Abs|NoWrp|Lin|Prf|NoNull|BitF)
+    0xb1, 0x02,        //  Feature (Dat|Arr|Rel|NoWrp|Lin|Prf|NoNull|BitF)
     0xc0               // End Collection
 };
 const size_t kMonitorSize = base::size(kMonitor);
@@ -214,10 +214,10 @@
     0x25, 0x01,  //   Logical Maximum (1)
     0x95, 0x03,  //   Report Count (3)
     0x75, 0x01,  //   Report Size (1)
-    0x81, 0x02,  //   Input (Dat|Var|Abs|NoWrp|Lin|Prf|NoNull|BitF)
+    0x81, 0x02,  //   Input (Dat|Arr|Rel|NoWrp|Lin|Prf|NoNull|BitF)
     0x95, 0x01,  //   Report Count (1)
     0x75, 0x05,  //   Report Size (5)
-    0x81, 0x03,  //   Input (Con|Var|Abs|NoWrp|Lin|Prf|NoNull|BitF)
+    0x81, 0x03,  //   Input (Con|Arr|Rel|NoWrp|Lin|Prf|NoNull|BitF)
     0x05, 0x01,  //   Usage Page (Generic Desktop)
     0x09, 0x30,  //   Usage (0x30)
     0x09, 0x31,  //   Usage (0x31)
@@ -225,7 +225,7 @@
     0x25, 0x7f,  //   Logical Maximum (127)
     0x75, 0x08,  //   Report Size (8)
     0x95, 0x02,  //   Report Count (2)
-    0x81, 0x06,  //   Input (Dat|Var|Rel|NoWrp|Lin|Prf|NoNull|BitF)
+    0x81, 0x06,  //   Input (Dat|Arr|Abs|NoWrp|Lin|Prf|NoNull|BitF)
     0xc0,        //  End Collection
     0xc0         // End Collection
 };
@@ -242,9 +242,9 @@
     0x15, 0x00,        //  Logical Minimum (0)
     0x26, 0xFF, 0x00,  //  Logical Maximum (255)
     0x09, 0x01,        //  Usage (0x1)
-    0x81, 0x00,        //  Input (Dat|Arr|Abs|NoWrp|Lin|Prf|NoNull|BitF)
+    0x81, 0x00,        //  Input (Dat|Var|Rel|NoWrp|Lin|Prf|NoNull|BitF)
     0x09, 0x01,        //  Usage (0x1)
-    0x91, 0x00,        //  Output (Dat|Arr|Abs|NoWrp|Lin|Prf|NoNull|BitF)
+    0x91, 0x00,        //  Output (Dat|Var|Rel|NoWrp|Lin|Prf|NoNull|BitF)
     0xC0,              // End Collection
     0x06, 0x00, 0xFF,  // Usage Page (Vendor)
     0x09, 0x02,        // Usage (0x2)
@@ -255,9 +255,9 @@
     0x15, 0x00,        //  Logical Minimum (0)
     0x26, 0xFF, 0x00,  //  Logical Maximum (255)
     0x09, 0x02,        //  Usage (0x2)
-    0x81, 0x00,        //  Input (Dat|Arr|Abs|NoWrp|Lin|Prf|NoNull|BitF)
+    0x81, 0x00,        //  Input (Dat|Var|Rel|NoWrp|Lin|Prf|NoNull|BitF)
     0x09, 0x02,        //  Usage (0x2)
-    0x91, 0x00,        //  Output (Dat|Arr|Abs|NoWrp|Lin|Prf|NoNull|BitF)
+    0x91, 0x00,        //  Output (Dat|Var|Rel|NoWrp|Lin|Prf|NoNull|BitF)
     0xC0,              // End Collection
     0x06, 0x00, 0xFF,  // Usage Page (Vendor)
     0x09, 0x04,        // Usage (0x4)
@@ -268,17 +268,17 @@
     0x15, 0x00,        //  Logical Minimum (0)
     0x26, 0xFF, 0x00,  //  Logical Maximum (255)
     0x09, 0x41,        //  Usage (0x41)
-    0x81, 0x00,        //  Input (Dat|Arr|Abs|NoWrp|Lin|Prf|NoNull|BitF)
+    0x81, 0x00,        //  Input (Dat|Var|Rel|NoWrp|Lin|Prf|NoNull|BitF)
     0x09, 0x41,        //  Usage (0x41)
-    0x91, 0x00,        //  Output (Dat|Arr|Abs|NoWrp|Lin|Prf|NoNull|BitF)
+    0x91, 0x00,        //  Output (Dat|Var|Rel|NoWrp|Lin|Prf|NoNull|BitF)
     0x85, 0x21,        //  Report ID (0x21)
     0x95, 0x1F,        //  Report Count (31)
     0x15, 0x00,        //  Logical Minimum (0)
     0x26, 0xFF, 0x00,  //  Logical Maximum (255)
     0x09, 0x42,        //  Usage (0x42)
-    0x81, 0x00,        //  Input (Dat|Arr|Abs|NoWrp|Lin|Prf|NoNull|BitF)
+    0x81, 0x00,        //  Input (Dat|Var|Rel|NoWrp|Lin|Prf|NoNull|BitF)
     0x09, 0x42,        //  Usage (0x42)
-    0x91, 0x00,        //  Output (Dat|Arr|Abs|NoWrp|Lin|Prf|NoNull|BitF)
+    0x91, 0x00,        //  Output (Dat|Var|Rel|NoWrp|Lin|Prf|NoNull|BitF)
     0xC0               // End Collection
 };
 const size_t kLogitechUnifyingReceiverSize =
@@ -288,8 +288,8 @@
 const uint8_t kSonyDualshock3[] = {
     0x05, 0x01,        // Usage Page (Generic Desktop Ctrls)
     0x09, 0x04,        // Usage (Joystick)
-    0xA1, 0x01,        // Collection (Application)
-    0xA1, 0x02,        //   Collection (Logical)
+    0xA1, 0x01,        // Collection (Physical)
+    0xA1, 0x02,        //   Collection (Application)
     0x85, 0x01,        //     Report ID (1)
     0x75, 0x08,        //     Report Size (8)
     0x95, 0x01,        //     Report Count (1)
@@ -318,7 +318,7 @@
     0x26, 0xFF, 0x00,  //     Logical Maximum (255)
     0x05, 0x01,        //     Usage Page (Generic Desktop Ctrls)
     0x09, 0x01,        //     Usage (Pointer)
-    0xA1, 0x00,        //     Collection (Physical)
+    0xA1, 0x00,        //     Collection (Undefined)
     0x75, 0x08,        //       Report Size (8)
     0x95, 0x04,        //       Report Count (4)
     0x35, 0x00,        //       Physical Minimum (0)
@@ -347,7 +347,7 @@
     0xB1, 0x02,        //     Feature (Data,Var,Abs,No Wrap,Linear,Preferred
                        //     State,No Null Position,Non-volatile)
     0xC0,              //   End Collection
-    0xA1, 0x02,        //   Collection (Logical)
+    0xA1, 0x02,        //   Collection (Application)
     0x85, 0x02,        //     Report ID (2)
     0x75, 0x08,        //     Report Size (8)
     0x95, 0x30,        //     Report Count (48)
@@ -355,7 +355,7 @@
     0xB1, 0x02,        //     Feature (Data,Var,Abs,No Wrap,Linear,Preferred
                        //     State,No Null Position,Non-volatile)
     0xC0,              //   End Collection
-    0xA1, 0x02,        //   Collection (Logical)
+    0xA1, 0x02,        //   Collection (Application)
     0x85, 0xEE,        //     Report ID (238)
     0x75, 0x08,        //     Report Size (8)
     0x95, 0x30,        //     Report Count (48)
@@ -363,7 +363,7 @@
     0xB1, 0x02,        //     Feature (Data,Var,Abs,No Wrap,Linear,Preferred
                        //     State,No Null Position,Non-volatile)
     0xC0,              //   End Collection
-    0xA1, 0x02,        //   Collection (Logical)
+    0xA1, 0x02,        //   Collection (Application)
     0x85, 0xEF,        //     Report ID (239)
     0x75, 0x08,        //     Report Size (8)
     0x95, 0x30,        //     Report Count (48)
@@ -1642,328 +1642,4 @@
 const size_t kMicrosoftXboxAdaptiveControllerSize =
     base::size(kMicrosoftXboxAdaptiveController);
 
-const uint8_t kNexusPlayerController[] = {
-    0x05, 0x01,        // Usage Page (Generic Desktop Ctrls)
-    0x09, 0x05,        // Usage (Game Pad)
-    0xA1, 0x01,        // Collection (Application)
-    0x85, 0x01,        //   Report ID (1)
-    0x05, 0x09,        //   Usage Page (Button)
-    0x0A, 0x01, 0x00,  //   Usage (0x01)
-    0x0A, 0x02, 0x00,  //   Usage (0x02)
-    0x0A, 0x04, 0x00,  //   Usage (0x04)
-    0x0A, 0x05, 0x00,  //   Usage (0x05)
-    0x0A, 0x07, 0x00,  //   Usage (0x07)
-    0x0A, 0x08, 0x00,  //   Usage (0x08)
-    0x0A, 0x0E, 0x00,  //   Usage (0x0E)
-    0x0A, 0x0F, 0x00,  //   Usage (0x0F)
-    0x0A, 0x0D, 0x00,  //   Usage (0x0D)
-    0x05, 0x0C,        //   Usage Page (Consumer)
-    0x0A, 0x24, 0x02,  //   Usage (AC Back)
-    0x0A, 0x23, 0x02,  //   Usage (AC Home)
-    0x15, 0x00,        //   Logical Minimum (0)
-    0x25, 0x01,        //   Logical Maximum (1)
-    0x75, 0x01,        //   Report Size (1)
-    0x95, 0x0B,        //   Report Count (11)
-    0x81, 0x02,        //   Input (Data,Var,Abs,No Wrap,Linear,Preferred State,
-                       //   No Null Position)
-    0x75, 0x01,        //   Report Size (1)
-    0x95, 0x01,        //   Report Count (1)
-    0x81, 0x03,        //   Input (Const,Var,Abs,No Wrap,Linear,Preferred State,
-                       //   No Null Position)
-    0x05, 0x01,        //   Usage Page (Generic Desktop Ctrls)
-    0x75, 0x04,        //   Report Size (4)
-    0x95, 0x01,        //   Report Count (1)
-    0x25, 0x07,        //   Logical Maximum (7)
-    0x46, 0x3B, 0x01,  //   Physical Maximum (315)
-    0x66, 0x14, 0x00,  //   Unit (System: English Rotation, Length: Centimeter)
-    0x09, 0x39,        //   Usage (Hat switch)
-    0x81, 0x42,        //   Input (Data,Var,Abs,No Wrap,Linear,Preferred State,
-                       //   Null State)
-    0x66, 0x00, 0x00,  //   Unit (None)
-    0xA1, 0x00,        //   Collection (Physical)
-    0x09, 0x30,        //     Usage (X)
-    0x09, 0x31,        //     Usage (Y)
-    0x09, 0x32,        //     Usage (Z)
-    0x09, 0x35,        //     Usage (Rz)
-    0x05, 0x02,        //     Usage Page (Sim Ctrls)
-    0x09, 0xC5,        //     Usage (Brake)
-    0x09, 0xC4,        //     Usage (Accelerator)
-    0x15, 0x00,        //     Logical Minimum (0)
-    0x26, 0xFF, 0x00,  //     Logical Maximum (255)
-    0x35, 0x00,        //     Physical Minimum (0)
-    0x46, 0xFF, 0x00,  //     Physical Maximum (255)
-    0x75, 0x08,        //     Report Size (8)
-    0x95, 0x06,        //     Report Count (6)
-    0x81, 0x02,        //     Input (Data,Var,Abs,No Wrap,Linear,Preferred
-                       //     State,No Null Position)
-    0xC0,              //   End Collection
-    0x85, 0x02,        //   Report ID (2)
-    0x05, 0x08,        //   Usage Page (LEDs)
-    0x0A, 0x01, 0x00,  //   Usage (Num Lock)
-    0x0A, 0x02, 0x00,  //   Usage (Caps Lock)
-    0x0A, 0x03, 0x00,  //   Usage (Scroll Lock)
-    0x0A, 0x04, 0x00,  //   Usage (Compose)
-    0x15, 0x00,        //   Logical Minimum (0)
-    0x25, 0x01,        //   Logical Maximum (1)
-    0x75, 0x01,        //   Report Size (1)
-    0x95, 0x04,        //   Report Count (4)
-    0x91, 0x02,        //   Output (Data,Var,Abs,No Wrap,Linear,Preferred State,
-                       //   No Null Position,Non-volatile)
-    0x75, 0x04,        //   Report Size (4)
-    0x95, 0x01,        //   Report Count (1)
-    0x91, 0x03,        //   Output (Const,Var,Abs,No Wrap,Linear,Preferred
-                       //   State,No Null Position,Non-volatile)
-    0xC0,              // End Collection
-    0x05, 0x01,        // Usage Page (Generic Desktop Ctrls)
-    0x09, 0x05,        // Usage (Game Pad)
-    0xA1, 0x01,        // Collection (Application)
-    0x85, 0x03,        //   Report ID (3)
-    0x05, 0x06,        //   Usage Page (Generic Dev Ctrls)
-    0x09, 0x20,        //   Usage (Battery Strength)
-    0x15, 0x00,        //   Logical Minimum (0)
-    0x26, 0xFF, 0x00,  //   Logical Maximum (255)
-    0x75, 0x08,        //   Report Size (8)
-    0x95, 0x01,        //   Report Count (1)
-    0x81, 0x02,        //   Input (Data,Var,Abs,No Wrap,Linear,Preferred State,
-                       //   No Null Position)
-    0x06, 0xBC, 0xFF,  //   Usage Page (Vendor Defined 0xFFBC)
-    0x0A, 0xAD, 0xBD,  //   Usage (0xBDAD)
-    0x75, 0x08,        //   Report Size (8)
-    0x95, 0x06,        //   Report Count (6)
-    0x81, 0x02,        //   Input (Data,Var,Abs,No Wrap,Linear,Preferred State,
-                       //   No Null Position)
-    0xC0,              // End Collection
-    0x00,              // Unknown (bTag: 0x00, bType: 0x00)
-};
-const size_t kNexusPlayerControllerSize = base::size(kNexusPlayerController);
-
-const uint8_t kSteamControllerKeyboard[] = {
-    0x05, 0x01,  // Usage Page (Generic Desktop Ctrls)
-    0x09, 0x06,  // Usage (Keyboard)
-    0x95, 0x01,  // Report Count (1)
-    0xA1, 0x01,  // Collection (Application)
-    0x05, 0x07,  //   Usage Page (Kbrd/Keypad)
-    0x19, 0xE0,  //   Usage Minimum (0xE0)
-    0x29, 0xE7,  //   Usage Maximum (0xE7)
-    0x15, 0x00,  //   Logical Minimum (0)
-    0x25, 0x01,  //   Logical Maximum (1)
-    0x75, 0x01,  //   Report Size (1)
-    0x95, 0x08,  //   Report Count (8)
-    0x81, 0x02,  //   Input (Data,Var,Abs,No Wrap,Linear,Preferred State,
-                 //   No Null Position)
-    0x95, 0x01,  //   Report Count (1)
-    0x75, 0x08,  //   Report Size (8)
-    0x81, 0x01,  //   Input (Const,Array,Abs,No Wrap,Linear,Preferred
-                 //   State,No Null Position)
-    0x95, 0x05,  //   Report Count (5)
-    0x75, 0x01,  //   Report Size (1)
-    0x05, 0x08,  //   Usage Page (LEDs)
-    0x19, 0x01,  //   Usage Minimum (Num Lock)
-    0x29, 0x05,  //   Usage Maximum (Kana)
-    0x91, 0x02,  //   Output (Data,Var,Abs,No Wrap,Linear,Preferred State,
-                 //   No Null Position,Non-volatile)
-    0x95, 0x01,  //   Report Count (1)
-    0x75, 0x03,  //   Report Size (3)
-    0x91, 0x01,  //   Output (Const,Array,Abs,No Wrap,Linear,Preferred
-                 //   State,No Null Position,Non-volatile)
-    0x95, 0x06,  //   Report Count (6)
-    0x75, 0x08,  //   Report Size (8)
-    0x15, 0x00,  //   Logical Minimum (0)
-    0x25, 0x65,  //   Logical Maximum (101)
-    0x05, 0x07,  //   Usage Page (Kbrd/Keypad)
-    0x19, 0x00,  //   Usage Minimum (0x00)
-    0x29, 0x65,  //   Usage Maximum (0x65)
-    0x81, 0x00,  //   Input (Data,Array,Abs,No Wrap,Linear,Preferred
-                 //   State,No Null Position)
-    0xC0,        // End Collection
-};
-const size_t kSteamControllerKeyboardSize =
-    base::size(kSteamControllerKeyboard);
-
-const uint8_t kSteamControllerMouse[] = {
-    0x05, 0x01,  // Usage Page (Generic Desktop Ctrls)
-    0x09, 0x02,  // Usage (Mouse)
-    0xA1, 0x01,  // Collection (Application)
-    0x09, 0x01,  //   Usage (Pointer)
-    0xA1, 0x00,  //   Collection (Physical)
-    0x05, 0x09,  //     Usage Page (Button)
-    0x19, 0x01,  //     Usage Minimum (0x01)
-    0x29, 0x05,  //     Usage Maximum (0x05)
-    0x15, 0x00,  //     Logical Minimum (0)
-    0x25, 0x01,  //     Logical Maximum (1)
-    0x95, 0x05,  //     Report Count (5)
-    0x75, 0x01,  //     Report Size (1)
-    0x81, 0x02,  //     Input (Data,Var,Abs,No Wrap,Linear,Preferred
-                 //     State,No Null Position)
-    0x95, 0x01,  //     Report Count (1)
-    0x75, 0x03,  //     Report Size (3)
-    0x81, 0x01,  //     Input (Const,Array,Abs,No Wrap,Linear,Preferred
-                 //     State,No Null Position)
-    0x05, 0x01,  //     Usage Page (Generic Desktop Ctrls)
-    0x09, 0x30,  //     Usage (X)
-    0x09, 0x31,  //     Usage (Y)
-    0x09, 0x38,  //     Usage (Wheel)
-    0x15, 0x81,  //     Logical Minimum (-127)
-    0x25, 0x7F,  //     Logical Maximum (127)
-    0x75, 0x08,  //     Report Size (8)
-    0x95, 0x03,  //     Report Count (3)
-    0x81, 0x06,  //     Input (Data,Var,Rel,No Wrap,Linear,Preferred
-                 //     State,No Null Position)
-    0xC0,        //   End Collection
-    0xC0,        // End Collection
-};
-const size_t kSteamControllerMouseSize = base::size(kSteamControllerMouse);
-
-const uint8_t kSteamControllerVendor[] = {
-    0x06, 0x00, 0xFF,  // Usage Page (Vendor Defined 0xFF00)
-    0x09, 0x01,        // Usage (0x01)
-    0xA1, 0x01,        // Collection (Application)
-    0x15, 0x00,        //   Logical Minimum (0)
-    0x26, 0xFF, 0x00,  //   Logical Maximum (255)
-    0x75, 0x08,        //   Report Size (8)
-    0x95, 0x40,        //   Report Count (64)
-    0x09, 0x01,        //   Usage (0x01)
-    0x81, 0x02,        //   Input (Data,Var,Abs,No Wrap,Linear,Preferred State,
-                       //   No Null Position)
-    0x95, 0x40,        //   Report Count (64)
-    0x09, 0x01,        //   Usage (0x01)
-    0x91, 0x02,        //   Output (Data,Var,Abs,No Wrap,Linear,Preferred State,
-                       //   No Null Position,Non-volatile)
-    0x95, 0x40,        //   Report Count (64)
-    0x09, 0x01,        //   Usage (0x01)
-    0xB1, 0x02,        //   Feature (Data,Var,Abs,No Wrap,Linear,Preferred
-                       //   State,No Null Position,Non-volatile)
-    0xC0,              // End Collection
-};
-const size_t kSteamControllerVendorSize = base::size(kSteamControllerVendor);
-
-const uint8_t kXSkillsUsbAdapter[] = {
-    0x05, 0x01,        // Usage Page (Generic Desktop Ctrls)
-    0x09, 0x04,        // Usage (Joystick)
-    0xA1, 0x01,        // Collection (Application)
-    0x05, 0x09,        //   Usage Page (Button)
-    0x19, 0x01,        //   Usage Minimum (0x01)
-    0x29, 0x0C,        //   Usage Maximum (0x0C)
-    0x15, 0x00,        //   Logical Minimum (0)
-    0x25, 0x01,        //   Logical Maximum (1)
-    0x35, 0x00,        //   Physical Minimum (0)
-    0x45, 0x01,        //   Physical Maximum (1)
-    0x75, 0x01,        //   Report Size (1)
-    0x95, 0x0C,        //   Report Count (12)
-    0x81, 0x02,        //   Input (Data,Var,Abs,No Wrap,Linear,Preferred State,
-                       //   No Null Position)
-    0x95, 0x04,        //   Report Count (4)
-    0x81, 0x03,        //   Input (Const,Var,Abs,No Wrap,Linear,Preferred State,
-                       //   No Null Position)
-    0x05, 0x01,        //   Usage Page (Generic Desktop Ctrls)
-    0x09, 0x30,        //   Usage (X)
-    0x09, 0x31,        //   Usage (Y)
-    0x09, 0x35,        //   Usage (Rz)
-    0x09, 0x32,        //   Usage (Z)
-    0x26, 0xFF, 0x00,  //   Logical Maximum (255)
-    0x46, 0xFF, 0x00,  //   Physical Maximum (255)
-    0x66, 0x00, 0x00,  //   Unit (None)
-    0x75, 0x08,        //   Report Size (8)
-    0x95, 0x04,        //   Report Count (4)
-    0x81, 0x02,        //   Input (Data,Var,Abs,No Wrap,Linear,Preferred State,
-                       //   No Null Position)
-    0x09, 0x33,        //   Usage (Rx)
-    0x09, 0x34,        //   Usage (Ry)
-    0x26, 0x0F, 0x00,  //   Logical Maximum (15)
-    0x46, 0x0F, 0x00,  //   Physical Maximum (15)
-    0x75, 0x04,        //   Report Size (4)
-    0x95, 0x02,        //   Report Count (2)
-    0x81, 0x02,        //   Input (Data,Var,Abs,No Wrap,Linear,Preferred State,
-                       //   No Null Position)
-    0x75, 0x08,        //   Report Size (8)
-    0x06, 0x00, 0xFF,  //   Usage Page (Vendor Defined 0xFF00)
-    0x19, 0x01,        //   Usage Minimum (0x01)
-    0x29, 0x04,        //   Usage Maximum (0x04)
-    0x95, 0x04,        //   Report Count (4)
-    0x91, 0x02,        //   Output (Data,Var,Abs,No Wrap,Linear,Preferred State,
-                       //   No Null Position,Non-volatile)
-    0xC0,              // End Collection
-};
-const size_t kXSkillsUsbAdapterSize = base::size(kXSkillsUsbAdapter);
-
-const uint8_t kBelkinNostromoKeyboard[] = {
-    0x05, 0x01,  // Usage Page (Generic Desktop Ctrls)
-    0x09, 0x06,  // Usage (Keyboard)
-    0xA1, 0x01,  // Collection (Application)
-    0x05, 0x07,  //   Usage Page (Kbrd/Keypad)
-    0x19, 0xE0,  //   Usage Minimum (0xE0)
-    0x29, 0xE7,  //   Usage Maximum (0xE7)
-    0x15, 0x00,  //   Logical Minimum (0)
-    0x25, 0x01,  //   Logical Maximum (1)
-    0x75, 0x01,  //   Report Size (1)
-    0x95, 0x08,  //   Report Count (8)
-    0x81, 0x02,  //   Input (Data,Var,Abs,No Wrap,Linear,Preferred State,
-                 //   No Null Position)
-    0x95, 0x01,  //   Report Count (1)
-    0x75, 0x08,  //   Report Size (8)
-    0x81, 0x01,  //   Input (Const,Array,Abs,No Wrap,Linear,Preferred
-                 //   State,No Null Position)
-    0x95, 0x06,  //   Report Count (6)
-    0x75, 0x08,  //   Report Size (8)
-    0x15, 0x00,  //   Logical Minimum (0)
-    0x25, 0x65,  //   Logical Maximum (101)
-    0x05, 0x07,  //   Usage Page (Kbrd/Keypad)
-    0x19, 0x00,  //   Usage Minimum (0x00)
-    0x29, 0x65,  //   Usage Maximum (0x65)
-    0x81, 0x00,  //   Input (Data,Array,Abs,No Wrap,Linear,Preferred
-                 //   State,No Null Position)
-    0xC0,        // End Collection
-};
-const size_t kBelkinNostromoKeyboardSize = base::size(kBelkinNostromoKeyboard);
-
-const uint8_t kBelkinNostromoMouseAndExtra[] = {
-    0x05, 0x01,  // Usage Page (Generic Desktop Ctrls)
-    0x09, 0x02,  // Usage (Mouse)
-    0xA1, 0x01,  // Collection (Application)
-    0x09, 0x01,  //   Usage (Pointer)
-    0xA1, 0x00,  //   Collection (Physical)
-    0x05, 0x09,  //     Usage Page (Button)
-    0x19, 0x01,  //     Usage Minimum (0x01)
-    0x29, 0x03,  //     Usage Maximum (0x03)
-    0x15, 0x00,  //     Logical Minimum (0)
-    0x25, 0x01,  //     Logical Maximum (1)
-    0x95, 0x03,  //     Report Count (3)
-    0x75, 0x01,  //     Report Size (1)
-    0x81, 0x02,  //     Input (Data,Var,Abs,No Wrap,Linear,Preferred
-                 //     State,No Null Position)
-    0x95, 0x01,  //     Report Count (1)
-    0x75, 0x05,  //     Report Size (5)
-    0x81, 0x01,  //     Input (Const,Array,Abs,No Wrap,Linear,Preferred
-                 //     State,No Null Position)
-    0x05, 0x01,  //     Usage Page (Generic Desktop Ctrls)
-    0x09, 0x30,  //     Usage (X)
-    0x09, 0x31,  //     Usage (Y)
-    0x09, 0x38,  //     Usage (Wheel)
-    0x15, 0x81,  //     Logical Minimum (-127)
-    0x25, 0x7F,  //     Logical Maximum (127)
-    0x75, 0x08,  //     Report Size (8)
-    0x95, 0x03,  //     Report Count (3)
-    0x81, 0x06,  //     Input (Data,Var,Rel,No Wrap,Linear,Preferred
-                 //     State,No Null Position)
-    0x05, 0x08,  //     Usage Page (LEDs)
-    0x19, 0x01,  //     Usage Minimum (Num Lock)
-    0x29, 0x03,  //     Usage Maximum (Scroll Lock)
-    0x15, 0x00,  //     Logical Minimum (0)
-    0x25, 0x01,  //     Logical Maximum (1)
-    0x35, 0x00,  //     Physical Minimum (0)
-    0x45, 0x01,  //     Physical Maximum (1)
-    0x75, 0x01,  //     Report Size (1)
-    0x95, 0x03,  //     Report Count (3)
-    0x91, 0x02,  //     Output (Data,Var,Abs,No Wrap,Linear,Preferred
-                 //     State,No Null Position,Non-volatile)
-    0x75, 0x05,  //     Report Size (5)
-    0x95, 0x01,  //     Report Count (1)
-    0x91, 0x01,  //     Output (Const,Array,Abs,No Wrap,Linear,Preferred
-                 //     State,No Null Position,Non-volatile)
-    0xC0,        //   End Collection
-    0xC0,        // End Collection
-};
-const size_t kBelkinNostromoMouseAndExtraSize =
-    base::size(kBelkinNostromoMouseAndExtra);
-
 }  // namespace device
--- a/services/device/hid/test_report_descriptors.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/hid/test_report_descriptors.h	2019-05-17 18:53:37.832000000 +0300
@@ -54,28 +54,6 @@
 extern const uint8_t kMicrosoftXboxAdaptiveController[];
 extern const size_t kMicrosoftXboxAdaptiveControllerSize;
 
-// Nexus Player Controller descriptor
-extern const uint8_t kNexusPlayerController[];
-extern const size_t kNexusPlayerControllerSize;
-
-// Steam Controller descriptors
-extern const uint8_t kSteamControllerKeyboard[];
-extern const size_t kSteamControllerKeyboardSize;
-extern const uint8_t kSteamControllerMouse[];
-extern const size_t kSteamControllerMouseSize;
-extern const uint8_t kSteamControllerVendor[];
-extern const size_t kSteamControllerVendorSize;
-
-// XSkills Gamecube USB controller adapter descriptor
-extern const uint8_t kXSkillsUsbAdapter[];
-extern const size_t kXSkillsUsbAdapterSize;
-
-// Belkin Nostromo SpeedPad descriptors
-extern const uint8_t kBelkinNostromoKeyboard[];
-extern const size_t kBelkinNostromoKeyboardSize;
-extern const uint8_t kBelkinNostromoMouseAndExtra[];
-extern const size_t kBelkinNostromoMouseAndExtraSize;
-
 }  // namespace device
 
 #endif  // SERVICES_DEVICE_HID_TEST_REPORT_DESCRIPTORS_H_
--- a/services/device/media_transfer_protocol/mtp_device_manager.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/media_transfer_protocol/mtp_device_manager.cc	2019-05-17 18:53:37.836000000 +0300
@@ -4,8 +4,6 @@
 
 #include "services/device/media_transfer_protocol/mtp_device_manager.h"
 
-#include "base/bind.h"
-#include "base/bind_helpers.h"
 #include "chromeos/dbus/dbus_thread_manager.h"
 #include "dbus/bus.h"
 #include "third_party/cros_system_api/dbus/service_constants.h"
--- a/services/device/nfc/android/BUILD.gn	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/nfc/android/BUILD.gn	2019-05-17 18:53:37.836000000 +0300
@@ -11,10 +11,10 @@
     "//services/device:*",
   ]
   java_files = [
-    "java/borg/chromium/device/nfc/InvalidNdefMessageException.java",
+    "java/borg/chromium/device/nfc/InvalidNfcMessageException.java",
     "java/borg/chromium/device/nfc/NfcProviderImpl.java",
     "java/borg/chromium/device/nfc/NfcImpl.java",
-    "java/borg/chromium/device/nfc/NdefMessageValidator.java",
+    "java/borg/chromium/device/nfc/NfcMessageValidator.java",
     "java/borg/chromium/device/nfc/NfcTagHandler.java",
     "java/borg/chromium/device/nfc/NfcTypeConverter.java",
   ]
--- a/services/device/nfc/android/java/borg/chromium/device/nfc/NfcImpl.java	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/nfc/android/java/borg/chromium/device/nfc/NfcImpl.java	2019-05-17 18:53:37.836000000 +0300
@@ -10,6 +10,7 @@
 import android.content.Context;
 import android.content.pm.PackageManager;
 import android.nfc.FormatException;
+import android.nfc.NdefMessage;
 import android.nfc.NfcAdapter;
 import android.nfc.NfcAdapter.ReaderCallback;
 import android.nfc.NfcManager;
@@ -23,11 +24,11 @@
 import org.chromium.base.Callback;
 import org.chromium.base.ContextUtils;
 import org.chromium.base.Log;
-import org.chromium.device.mojom.NdefMessage;
 import org.chromium.device.mojom.Nfc;
 import org.chromium.device.mojom.NfcClient;
 import org.chromium.device.mojom.NfcError;
 import org.chromium.device.mojom.NfcErrorType;
+import org.chromium.device.mojom.NfcMessage;
 import org.chromium.device.mojom.NfcPushOptions;
 import org.chromium.device.mojom.NfcPushTarget;
 import org.chromium.device.mojom.NfcWatchMode;
@@ -80,7 +81,7 @@
 
     /**
      * Object that contains data that was passed to method
-     * #push(NdefMessage message, NfcPushOptions options, PushResponse callback)
+     * #push(NfcMessage message, NfcPushOptions options, PushResponse callback)
      * @see PendingPushOperation
      */
     private PendingPushOperation mPendingPushOperation;
@@ -92,7 +93,7 @@
     private NfcTagHandler mTagHandler;
 
     /**
-     * Client interface used to deliver NdefMessages for registered watch operations.
+     * Client interface used to deliver NFCMessages for registered watch operations.
      * @see #watch
      */
     private NfcClient mClient;
@@ -106,7 +107,7 @@
      * Map of watchId <-> NfcWatchOptions. All NfcWatchOptions are matched against tag that is in
      * proximity, when match algorithm (@see #matchesWatchOptions) returns true, watcher with
      * corresponding ID would be notified using NfcClient interface.
-     * @see NfcClient#onWatch(int[] id, NdefMessage message)
+     * @see NfcClient#onWatch(int[] id, NfcMessage message)
      */
     private final SparseArray<NfcWatchOptions> mWatchers = new SparseArray<>();
 
@@ -163,7 +164,7 @@
 
     /**
      * Sets NfcClient. NfcClient interface is used to notify mojo NFC service client when NFC
-     * device is in proximity and has NdefMessage that matches NfcWatchOptions criteria.
+     * device is in proximity and has NfcMessage that matches NfcWatchOptions criteria.
      * @see Nfc#watch(NfcWatchOptions options, WatchResponse callback)
      *
      * @param client @see NfcClient
@@ -174,7 +175,7 @@
     }
 
     /**
-     * Pushes NdefMessage to Tag or Peer, whenever NFC device is in proximity. At the moment, only
+     * Pushes NfcMessage to Tag or Peer, whenever NFC device is in proximity. At the moment, only
      * passive NFC devices are supported (NfcPushTarget.TAG).
      *
      * @param message that should be pushed to NFC device.
@@ -182,10 +183,10 @@
      * @param callback that is used to notify when push operation is completed.
      */
     @Override
-    public void push(NdefMessage message, NfcPushOptions options, PushResponse callback) {
+    public void push(NfcMessage message, NfcPushOptions options, PushResponse callback) {
         if (!checkIfReady(callback)) return;
 
-        if (!NdefMessageValidator.isValid(message)) {
+        if (!NfcMessageValidator.isValid(message)) {
             callback.call(createError(NfcErrorType.INVALID_MESSAGE));
             return;
         }
@@ -236,13 +237,13 @@
     }
 
     /**
-     * Watch method allows to set filtering criteria for NdefMessages that are found when NFC device
+     * Watch method allows to set filtering criteria for NfcMessages that are found when NFC device
      * is within proximity. On success, watch ID is returned to caller through WatchResponse
-     * callback. When NdefMessage that matches NfcWatchOptions is found, it is passed to NfcClient
+     * callback. When NfcMessage that matches NfcWatchOptions is found, it is passed to NfcClient
      * interface together with corresponding watch ID.
-     * @see NfcClient#onWatch(int[] id, NdefMessage message)
+     * @see NfcClient#onWatch(int[] id, NfcMessage message)
      *
-     * @param options used to filter NdefMessages, @see NfcWatchOptions.
+     * @param options used to filter NfcMessages, @see NfcWatchOptions.
      * @param callback that is used to notify caller when watch() is completed and return watch ID.
      */
     @Override
@@ -323,13 +324,13 @@
      * Holds information about pending push operation.
      */
     private static class PendingPushOperation {
-        public final NdefMessage ndefMessage;
+        public final NfcMessage nfcMessage;
         public final NfcPushOptions nfcPushOptions;
         private final PushResponse mPushResponseCallback;
 
         public PendingPushOperation(
-                NdefMessage message, NfcPushOptions options, PushResponse callback) {
-            ndefMessage = message;
+                NfcMessage message, NfcPushOptions options, PushResponse callback) {
+            nfcMessage = message;
             nfcPushOptions = options;
             mPushResponseCallback = callback;
         }
@@ -499,10 +500,10 @@
 
         try {
             mTagHandler.connect();
-            mTagHandler.write(NfcTypeConverter.toNdefMessage(mPendingPushOperation.ndefMessage));
+            mTagHandler.write(NfcTypeConverter.toNdefMessage(mPendingPushOperation.nfcMessage));
             pendingPushOperationCompleted(null);
-        } catch (InvalidNdefMessageException e) {
-            Log.w(TAG, "Cannot write data to NFC tag. Invalid NdefMessage.");
+        } catch (InvalidNfcMessageException e) {
+            Log.w(TAG, "Cannot write data to NFC tag. Invalid NfcMessage.");
             pendingPushOperationCompleted(createError(NfcErrorType.INVALID_MESSAGE));
         } catch (TagLostException e) {
             Log.w(TAG, "Cannot write data to NFC tag. Tag is lost.");
@@ -514,7 +515,7 @@
     }
 
     /**
-     * Reads NdefMessage from a tag and forwards message to matching method.
+     * Reads NfcMessage from a tag and forwards message to matching method.
      */
     private void processPendingWatchOperations() {
         if (mTagHandler == null || mClient == null || mWatchers.size() == 0) return;
@@ -529,13 +530,13 @@
             return;
         }
 
-        android.nfc.NdefMessage message = null;
+        NdefMessage message = null;
 
         try {
             mTagHandler.connect();
             message = mTagHandler.read();
-            if (message.getByteArrayLength() > NdefMessage.MAX_SIZE) {
-                Log.w(TAG, "Cannot read data from NFC tag. NdefMessage exceeds allowed size.");
+            if (message.getByteArrayLength() > NfcMessage.MAX_SIZE) {
+                Log.w(TAG, "Cannot read data from NFC tag. NfcMessage exceeds allowed size.");
                 return;
             }
         } catch (TagLostException e) {
@@ -549,15 +550,15 @@
 
     /**
      * Iterates through active watchers and if any of those match NfcWatchOptions criteria,
-     * delivers NdefMessage to the client.
+     * delivers NfcMessage to the client.
      */
-    private void notifyMatchingWatchers(android.nfc.NdefMessage message) {
+    private void notifyMatchingWatchers(NdefMessage message) {
         try {
-            NdefMessage ndefMessage = NfcTypeConverter.toNdefMessage(message);
+            NfcMessage nfcMessage = NfcTypeConverter.toNfcMessage(message);
             List<Integer> watchIds = new ArrayList<Integer>();
             for (int i = 0; i < mWatchers.size(); i++) {
                 NfcWatchOptions options = mWatchers.valueAt(i);
-                if (matchesWatchOptions(ndefMessage, options)) watchIds.add(mWatchers.keyAt(i));
+                if (matchesWatchOptions(nfcMessage, options)) watchIds.add(mWatchers.keyAt(i));
             }
 
             if (watchIds.size() != 0) {
@@ -565,17 +566,17 @@
                 for (int i = 0; i < watchIds.size(); ++i) {
                     ids[i] = watchIds.get(i).intValue();
                 }
-                mClient.onWatch(ids, ndefMessage);
+                mClient.onWatch(ids, nfcMessage);
             }
         } catch (UnsupportedEncodingException e) {
-            Log.w(TAG, "Cannot convert NdefMessage to NdefMessage.");
+            Log.w(TAG, "Cannot convert NdefMessage to NfcMessage.");
         }
     }
 
     /**
      * Implements matching algorithm.
      */
-    private boolean matchesWatchOptions(NdefMessage message, NfcWatchOptions options) {
+    private boolean matchesWatchOptions(NfcMessage message, NfcWatchOptions options) {
         // Valid WebNFC message must have non-empty url.
         if (options.mode == NfcWatchMode.WEBNFC_ONLY
                 && (message.url == null || message.url.isEmpty())) {
--- a/services/device/nfc/android/java/borg/chromium/device/nfc/NfcTypeConverter.java	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/nfc/android/java/borg/chromium/device/nfc/NfcTypeConverter.java	2019-05-17 18:53:37.836000000 +0300
@@ -5,13 +5,15 @@
 package org.chromium.device.nfc;
 
 import android.net.Uri;
+import android.nfc.NdefMessage;
+import android.nfc.NdefRecord;
 import android.os.Build;
 
 import org.chromium.base.ApiCompatibilityUtils;
 import org.chromium.base.Log;
-import org.chromium.device.mojom.NdefMessage;
-import org.chromium.device.mojom.NdefRecord;
-import org.chromium.device.mojom.NdefRecordType;
+import org.chromium.device.mojom.NfcMessage;
+import org.chromium.device.mojom.NfcRecord;
+import org.chromium.device.mojom.NfcRecordType;
 
 import java.io.UnsupportedEncodingException;
 import java.util.ArrayList;
@@ -20,7 +22,7 @@
 
 /**
  * Utility class that provides convesion between Android NdefMessage
- * and mojo NdefMessage data structures.
+ * and mojo NfcMessage data structures.
  */
 public final class NfcTypeConverter {
     private static final String TAG = "NfcTypeConverter";
@@ -33,57 +35,56 @@
     private static final String CHARSET_UTF16 = ";charset=UTF-16";
 
     /**
-     * Converts mojo NdefMessage to android.nfc.NdefMessage
+     * Converts mojo NfcMessage to android.nfc.NdefMessage
      */
-    public static android.nfc.NdefMessage toNdefMessage(NdefMessage message)
-            throws InvalidNdefMessageException {
+    public static NdefMessage toNdefMessage(NfcMessage message) throws InvalidNfcMessageException {
         try {
-            List<android.nfc.NdefRecord> records = new ArrayList<android.nfc.NdefRecord>();
+            List<NdefRecord> records = new ArrayList<NdefRecord>();
             for (int i = 0; i < message.data.length; ++i) {
                 records.add(toNdefRecord(message.data[i]));
             }
-            records.add(android.nfc.NdefRecord.createExternal(
+            records.add(NdefRecord.createExternal(
                     DOMAIN, TYPE, ApiCompatibilityUtils.getBytesUtf8(message.url)));
-            android.nfc.NdefRecord[] ndefRecords = new android.nfc.NdefRecord[records.size()];
+            NdefRecord[] ndefRecords = new NdefRecord[records.size()];
             records.toArray(ndefRecords);
-            return new android.nfc.NdefMessage(ndefRecords);
-        } catch (UnsupportedEncodingException | InvalidNdefMessageException
+            return new NdefMessage(ndefRecords);
+        } catch (UnsupportedEncodingException | InvalidNfcMessageException
                 | IllegalArgumentException e) {
-            throw new InvalidNdefMessageException();
+            throw new InvalidNfcMessageException();
         }
     }
 
     /**
-     * Converts android.nfc.NdefMessage to mojo NdefMessage
+     * Converts android.nfc.NdefMessage to mojo NfcMessage
      */
-    public static NdefMessage toNdefMessage(android.nfc.NdefMessage ndefMessage)
+    public static NfcMessage toNfcMessage(NdefMessage ndefMessage)
             throws UnsupportedEncodingException {
-        android.nfc.NdefRecord[] ndefRecords = ndefMessage.getRecords();
-        NdefMessage webNdefMessage = new NdefMessage();
-        List<NdefRecord> nfcRecords = new ArrayList<NdefRecord>();
+        NdefRecord[] ndefRecords = ndefMessage.getRecords();
+        NfcMessage nfcMessage = new NfcMessage();
+        List<NfcRecord> nfcRecords = new ArrayList<NfcRecord>();
 
         for (int i = 0; i < ndefRecords.length; i++) {
-            if ((ndefRecords[i].getTnf() == android.nfc.NdefRecord.TNF_EXTERNAL_TYPE)
+            if ((ndefRecords[i].getTnf() == NdefRecord.TNF_EXTERNAL_TYPE)
                     && (Arrays.equals(ndefRecords[i].getType(),
                             ApiCompatibilityUtils.getBytesUtf8(WEBNFC_URN)))) {
-                webNdefMessage.url = new String(ndefRecords[i].getPayload(), "UTF-8");
+                nfcMessage.url = new String(ndefRecords[i].getPayload(), "UTF-8");
                 continue;
             }
 
-            NdefRecord nfcRecord = toNdefRecord(ndefRecords[i]);
+            NfcRecord nfcRecord = toNfcRecord(ndefRecords[i]);
             if (nfcRecord != null) nfcRecords.add(nfcRecord);
         }
 
-        webNdefMessage.data = new NdefRecord[nfcRecords.size()];
-        nfcRecords.toArray(webNdefMessage.data);
-        return webNdefMessage;
+        nfcMessage.data = new NfcRecord[nfcRecords.size()];
+        nfcRecords.toArray(nfcMessage.data);
+        return nfcMessage;
     }
 
     /**
-     * Returns charset of mojo NdefRecord. Only applicable for URL and TEXT records.
+     * Returns charset of mojo NfcRecord. Only applicable for URL and TEXT records.
      * If charset cannot be determined, UTF-8 charset is used by default.
      */
-    private static String getCharset(NdefRecord record) {
+    private static String getCharset(NfcRecord record) {
         if (record.mediaType.endsWith(CHARSET_UTF8)) return "UTF-8";
 
         // When 16bit WTF::String data is converted to bytearray, it is in LE byte order, without
@@ -97,47 +98,45 @@
     }
 
     /**
-     * Converts mojo NdefRecord to android.nfc.NdefRecord
+     * Converts mojo NfcRecord to android.nfc.NdefRecord
      */
-    private static android.nfc.NdefRecord toNdefRecord(NdefRecord record)
-            throws InvalidNdefMessageException, IllegalArgumentException,
+    private static NdefRecord toNdefRecord(NfcRecord record) throws InvalidNfcMessageException,
+                                                                    IllegalArgumentException,
                    UnsupportedEncodingException {
         switch (record.recordType) {
-            case NdefRecordType.URL:
-                return android.nfc.NdefRecord.createUri(
-                        new String(record.data, getCharset(record)));
-            case NdefRecordType.TEXT:
+            case NfcRecordType.URL:
+                return NdefRecord.createUri(new String(record.data, getCharset(record)));
+            case NfcRecordType.TEXT:
                 if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
-                    return android.nfc.NdefRecord.createTextRecord(
+                    return NdefRecord.createTextRecord(
                             "en-US", new String(record.data, getCharset(record)));
                 } else {
-                    return android.nfc.NdefRecord.createMime(TEXT_MIME, record.data);
+                    return NdefRecord.createMime(TEXT_MIME, record.data);
                 }
-            case NdefRecordType.JSON:
-            case NdefRecordType.OPAQUE_RECORD:
-                return android.nfc.NdefRecord.createMime(record.mediaType, record.data);
-            case NdefRecordType.EMPTY:
-                return new android.nfc.NdefRecord(
-                        android.nfc.NdefRecord.TNF_EMPTY, null, null, null);
+            case NfcRecordType.JSON:
+            case NfcRecordType.OPAQUE_RECORD:
+                return NdefRecord.createMime(record.mediaType, record.data);
+            case NfcRecordType.EMPTY:
+                return new NdefRecord(NdefRecord.TNF_EMPTY, null, null, null);
             default:
-                throw new InvalidNdefMessageException();
+                throw new InvalidNfcMessageException();
         }
     }
 
     /**
-     * Converts android.nfc.NdefRecord to mojo NdefRecord
+     * Converts android.nfc.NdefRecord to mojo NfcRecord
      */
-    private static NdefRecord toNdefRecord(android.nfc.NdefRecord ndefRecord)
+    private static NfcRecord toNfcRecord(NdefRecord ndefRecord)
             throws UnsupportedEncodingException {
         switch (ndefRecord.getTnf()) {
-            case android.nfc.NdefRecord.TNF_EMPTY:
+            case NdefRecord.TNF_EMPTY:
                 return createEmptyRecord();
-            case android.nfc.NdefRecord.TNF_MIME_MEDIA:
+            case NdefRecord.TNF_MIME_MEDIA:
                 return createMIMERecord(
                         new String(ndefRecord.getType(), "UTF-8"), ndefRecord.getPayload());
-            case android.nfc.NdefRecord.TNF_ABSOLUTE_URI:
+            case NdefRecord.TNF_ABSOLUTE_URI:
                 return createURLRecord(ndefRecord.toUri());
-            case android.nfc.NdefRecord.TNF_WELL_KNOWN:
+            case NdefRecord.TNF_WELL_KNOWN:
                 return createWellKnownRecord(ndefRecord);
         }
         return null;
@@ -146,43 +145,42 @@
     /**
      * Constructs empty NdefMessage
      */
-    public static android.nfc.NdefMessage emptyNdefMessage() {
-        return new android.nfc.NdefMessage(
-                new android.nfc.NdefRecord(android.nfc.NdefRecord.TNF_EMPTY, null, null, null));
+    public static NdefMessage emptyNdefMessage() {
+        return new NdefMessage(new NdefRecord(NdefRecord.TNF_EMPTY, null, null, null));
     }
 
     /**
-     * Constructs empty NdefRecord
+     * Constructs empty NfcRecord
      */
-    private static NdefRecord createEmptyRecord() {
-        NdefRecord nfcRecord = new NdefRecord();
-        nfcRecord.recordType = NdefRecordType.EMPTY;
+    private static NfcRecord createEmptyRecord() {
+        NfcRecord nfcRecord = new NfcRecord();
+        nfcRecord.recordType = NfcRecordType.EMPTY;
         nfcRecord.mediaType = "";
         nfcRecord.data = new byte[0];
         return nfcRecord;
     }
 
     /**
-     * Constructs URL NdefRecord
+     * Constructs URL NfcRecord
      */
-    private static NdefRecord createURLRecord(Uri uri) {
+    private static NfcRecord createURLRecord(Uri uri) {
         if (uri == null) return null;
-        NdefRecord nfcRecord = new NdefRecord();
-        nfcRecord.recordType = NdefRecordType.URL;
+        NfcRecord nfcRecord = new NfcRecord();
+        nfcRecord.recordType = NfcRecordType.URL;
         nfcRecord.mediaType = TEXT_MIME;
         nfcRecord.data = ApiCompatibilityUtils.getBytesUtf8(uri.toString());
         return nfcRecord;
     }
 
     /**
-     * Constructs MIME or JSON NdefRecord
+     * Constructs MIME or JSON NfcRecord
      */
-    private static NdefRecord createMIMERecord(String mediaType, byte[] payload) {
-        NdefRecord nfcRecord = new NdefRecord();
+    private static NfcRecord createMIMERecord(String mediaType, byte[] payload) {
+        NfcRecord nfcRecord = new NfcRecord();
         if (mediaType.equals(JSON_MIME)) {
-            nfcRecord.recordType = NdefRecordType.JSON;
+            nfcRecord.recordType = NfcRecordType.JSON;
         } else {
-            nfcRecord.recordType = NdefRecordType.OPAQUE_RECORD;
+            nfcRecord.recordType = NfcRecordType.OPAQUE_RECORD;
         }
         nfcRecord.mediaType = mediaType;
         nfcRecord.data = payload;
@@ -190,16 +188,16 @@
     }
 
     /**
-     * Constructs TEXT NdefRecord
+     * Constructs TEXT NfcRecord
      */
-    private static NdefRecord createTextRecord(byte[] text) {
+    private static NfcRecord createTextRecord(byte[] text) {
         // Check that text byte array is not empty.
         if (text.length == 0) {
             return null;
         }
 
-        NdefRecord nfcRecord = new NdefRecord();
-        nfcRecord.recordType = NdefRecordType.TEXT;
+        NfcRecord nfcRecord = new NfcRecord();
+        nfcRecord.recordType = NfcRecordType.TEXT;
         nfcRecord.mediaType = TEXT_MIME;
         // According to NFCForum-TS-RTD_Text_1.0 specification, section 3.2.1 Syntax.
         // First byte of the payload is status byte, defined in Table 3: Status Byte Encodings.
@@ -216,14 +214,14 @@
     }
 
     /**
-     * Constructs well known type (TEXT or URI) NdefRecord
+     * Constructs well known type (TEXT or URI) NfcRecord
      */
-    private static NdefRecord createWellKnownRecord(android.nfc.NdefRecord record) {
-        if (Arrays.equals(record.getType(), android.nfc.NdefRecord.RTD_URI)) {
+    private static NfcRecord createWellKnownRecord(NdefRecord record) {
+        if (Arrays.equals(record.getType(), NdefRecord.RTD_URI)) {
             return createURLRecord(record.toUri());
         }
 
-        if (Arrays.equals(record.getType(), android.nfc.NdefRecord.RTD_TEXT)) {
+        if (Arrays.equals(record.getType(), NdefRecord.RTD_TEXT)) {
             return createTextRecord(record.getPayload());
         }
 
--- a/services/device/nfc/android/junit/borg/chromium/device/nfc/NFCTest.java	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/nfc/android/junit/borg/chromium/device/nfc/NFCTest.java	2019-05-17 18:53:37.836000000 +0300
@@ -23,6 +23,8 @@
 import android.content.Context;
 import android.content.pm.PackageManager;
 import android.nfc.FormatException;
+import android.nfc.NdefMessage;
+import android.nfc.NdefRecord;
 import android.nfc.NfcAdapter;
 import android.nfc.NfcAdapter.ReaderCallback;
 import android.nfc.NfcManager;
@@ -42,10 +44,6 @@
 import org.chromium.base.Callback;
 import org.chromium.base.ContextUtils;
 import org.chromium.base.test.util.Feature;
-import org.chromium.device.mojom.NdefMessage;
-import org.chromium.device.mojom.NdefRecord;
-import org.chromium.device.mojom.NdefRecordType;
-import org.chromium.device.mojom.NdefRecordTypeFilter;
 import org.chromium.device.mojom.Nfc.CancelAllWatchesResponse;
 import org.chromium.device.mojom.Nfc.CancelPushResponse;
 import org.chromium.device.mojom.Nfc.CancelWatchResponse;
@@ -54,8 +52,12 @@
 import org.chromium.device.mojom.NfcClient;
 import org.chromium.device.mojom.NfcError;
 import org.chromium.device.mojom.NfcErrorType;
+import org.chromium.device.mojom.NfcMessage;
 import org.chromium.device.mojom.NfcPushOptions;
 import org.chromium.device.mojom.NfcPushTarget;
+import org.chromium.device.mojom.NfcRecord;
+import org.chromium.device.mojom.NfcRecordType;
+import org.chromium.device.mojom.NfcRecordTypeFilter;
 import org.chromium.device.mojom.NfcWatchMode;
 import org.chromium.device.mojom.NfcWatchOptions;
 import org.chromium.testing.local.LocalRobolectricTestRunner;
@@ -154,7 +156,7 @@
         doReturn(false).when(mNfcTagHandler).isTagOutOfRange();
         try {
             doNothing().when(mNfcTagHandler).connect();
-            doNothing().when(mNfcTagHandler).write(any(android.nfc.NdefMessage.class));
+            doNothing().when(mNfcTagHandler).write(any(NdefMessage.class));
             doReturn(createUrlWebNFCNdefMessage(TEST_URL)).when(mNfcTagHandler).read();
             doNothing().when(mNfcTagHandler).close();
         } catch (IOException | FormatException e) {
@@ -208,164 +210,148 @@
     }
 
     /**
-     * Test conversion from NdefMessage to mojo NdefMessage.
+     * Test conversion from NdefMessage to mojo NfcMessage.
      */
     @Test
     @Feature({"NFCTest"})
     public void testNdefToMojoConversion() throws UnsupportedEncodingException {
         // Test EMPTY record conversion.
-        android.nfc.NdefMessage emptyNdefMessage = new android.nfc.NdefMessage(
-                new android.nfc.NdefRecord(android.nfc.NdefRecord.TNF_EMPTY, null, null, null));
-        NdefMessage emptyMojoNdefMessage = NfcTypeConverter.toNdefMessage(emptyNdefMessage);
-        assertNull(emptyMojoNdefMessage.url);
-        assertEquals(1, emptyMojoNdefMessage.data.length);
-        assertEquals(NdefRecordType.EMPTY, emptyMojoNdefMessage.data[0].recordType);
-        assertEquals(true, emptyMojoNdefMessage.data[0].mediaType.isEmpty());
-        assertEquals(0, emptyMojoNdefMessage.data[0].data.length);
+        NdefMessage emptyNdefMessage =
+                new NdefMessage(new NdefRecord(NdefRecord.TNF_EMPTY, null, null, null));
+        NfcMessage emptyNfcMessage = NfcTypeConverter.toNfcMessage(emptyNdefMessage);
+        assertNull(emptyNfcMessage.url);
+        assertEquals(1, emptyNfcMessage.data.length);
+        assertEquals(NfcRecordType.EMPTY, emptyNfcMessage.data[0].recordType);
+        assertEquals(true, emptyNfcMessage.data[0].mediaType.isEmpty());
+        assertEquals(0, emptyNfcMessage.data[0].data.length);
 
         // Test URL record conversion.
-        android.nfc.NdefMessage urlNdefMessage =
-                new android.nfc.NdefMessage(android.nfc.NdefRecord.createUri(TEST_URL));
-        NdefMessage urlMojoNdefMessage = NfcTypeConverter.toNdefMessage(urlNdefMessage);
-        assertNull(urlMojoNdefMessage.url);
-        assertEquals(1, urlMojoNdefMessage.data.length);
-        assertEquals(NdefRecordType.URL, urlMojoNdefMessage.data[0].recordType);
-        assertEquals(TEXT_MIME, urlMojoNdefMessage.data[0].mediaType);
-        assertEquals(TEST_URL, new String(urlMojoNdefMessage.data[0].data));
+        NdefMessage urlNdefMessage = new NdefMessage(NdefRecord.createUri(TEST_URL));
+        NfcMessage urlNfcMessage = NfcTypeConverter.toNfcMessage(urlNdefMessage);
+        assertNull(urlNfcMessage.url);
+        assertEquals(1, urlNfcMessage.data.length);
+        assertEquals(NfcRecordType.URL, urlNfcMessage.data[0].recordType);
+        assertEquals(TEXT_MIME, urlNfcMessage.data[0].mediaType);
+        assertEquals(TEST_URL, new String(urlNfcMessage.data[0].data));
 
         // Test TEXT record conversion.
-        android.nfc.NdefMessage textNdefMessage = new android.nfc.NdefMessage(
-                android.nfc.NdefRecord.createTextRecord(LANG_EN_US, TEST_TEXT));
-        NdefMessage textMojoNdefMessage = NfcTypeConverter.toNdefMessage(textNdefMessage);
-        assertNull(textMojoNdefMessage.url);
-        assertEquals(1, textMojoNdefMessage.data.length);
-        assertEquals(NdefRecordType.TEXT, textMojoNdefMessage.data[0].recordType);
-        assertEquals(TEXT_MIME, textMojoNdefMessage.data[0].mediaType);
-        assertEquals(TEST_TEXT, new String(textMojoNdefMessage.data[0].data));
+        NdefMessage textNdefMessage =
+                new NdefMessage(NdefRecord.createTextRecord(LANG_EN_US, TEST_TEXT));
+        NfcMessage textNfcMessage = NfcTypeConverter.toNfcMessage(textNdefMessage);
+        assertNull(textNfcMessage.url);
+        assertEquals(1, textNfcMessage.data.length);
+        assertEquals(NfcRecordType.TEXT, textNfcMessage.data[0].recordType);
+        assertEquals(TEXT_MIME, textNfcMessage.data[0].mediaType);
+        assertEquals(TEST_TEXT, new String(textNfcMessage.data[0].data));
 
         // Test MIME record conversion.
-        android.nfc.NdefMessage mimeNdefMessage =
-                new android.nfc.NdefMessage(android.nfc.NdefRecord.createMime(
-                        TEXT_MIME, ApiCompatibilityUtils.getBytesUtf8(TEST_TEXT)));
-        NdefMessage mimeMojoNdefMessage = NfcTypeConverter.toNdefMessage(mimeNdefMessage);
-        assertNull(mimeMojoNdefMessage.url);
-        assertEquals(1, mimeMojoNdefMessage.data.length);
-        assertEquals(NdefRecordType.OPAQUE_RECORD, mimeMojoNdefMessage.data[0].recordType);
-        assertEquals(TEXT_MIME, textMojoNdefMessage.data[0].mediaType);
-        assertEquals(TEST_TEXT, new String(textMojoNdefMessage.data[0].data));
+        NdefMessage mimeNdefMessage = new NdefMessage(
+                NdefRecord.createMime(TEXT_MIME, ApiCompatibilityUtils.getBytesUtf8(TEST_TEXT)));
+        NfcMessage mimeNfcMessage = NfcTypeConverter.toNfcMessage(mimeNdefMessage);
+        assertNull(mimeNfcMessage.url);
+        assertEquals(1, mimeNfcMessage.data.length);
+        assertEquals(NfcRecordType.OPAQUE_RECORD, mimeNfcMessage.data[0].recordType);
+        assertEquals(TEXT_MIME, textNfcMessage.data[0].mediaType);
+        assertEquals(TEST_TEXT, new String(textNfcMessage.data[0].data));
 
         // Test JSON record conversion.
-        android.nfc.NdefMessage jsonNdefMessage =
-                new android.nfc.NdefMessage(android.nfc.NdefRecord.createMime(
-                        JSON_MIME, ApiCompatibilityUtils.getBytesUtf8(TEST_JSON)));
-        NdefMessage jsonMojoNdefMessage = NfcTypeConverter.toNdefMessage(jsonNdefMessage);
-        assertNull(jsonMojoNdefMessage.url);
-        assertEquals(1, jsonMojoNdefMessage.data.length);
-        assertEquals(NdefRecordType.JSON, jsonMojoNdefMessage.data[0].recordType);
-        assertEquals(JSON_MIME, jsonMojoNdefMessage.data[0].mediaType);
-        assertEquals(TEST_JSON, new String(jsonMojoNdefMessage.data[0].data));
-
-        // Test NdefMessage with WebNFC external type.
-        android.nfc.NdefRecord jsonNdefRecord = android.nfc.NdefRecord.createMime(
-                JSON_MIME, ApiCompatibilityUtils.getBytesUtf8(TEST_JSON));
-        android.nfc.NdefRecord extNdefRecord = android.nfc.NdefRecord.createExternal(
+        NdefMessage jsonNdefMessage = new NdefMessage(
+                NdefRecord.createMime(JSON_MIME, ApiCompatibilityUtils.getBytesUtf8(TEST_JSON)));
+        NfcMessage jsonNfcMessage = NfcTypeConverter.toNfcMessage(jsonNdefMessage);
+        assertNull(jsonNfcMessage.url);
+        assertEquals(1, jsonNfcMessage.data.length);
+        assertEquals(NfcRecordType.JSON, jsonNfcMessage.data[0].recordType);
+        assertEquals(JSON_MIME, jsonNfcMessage.data[0].mediaType);
+        assertEquals(TEST_JSON, new String(jsonNfcMessage.data[0].data));
+
+        // Test NfcMessage with WebNFC external type.
+        NdefRecord jsonNdefRecord =
+                NdefRecord.createMime(JSON_MIME, ApiCompatibilityUtils.getBytesUtf8(TEST_JSON));
+        NdefRecord extNdefRecord = NdefRecord.createExternal(
                 DOMAIN, TYPE, ApiCompatibilityUtils.getBytesUtf8(TEST_URL));
-        android.nfc.NdefMessage webNdefMessage =
-                new android.nfc.NdefMessage(jsonNdefRecord, extNdefRecord);
-        NdefMessage webMojoNdefMessage = NfcTypeConverter.toNdefMessage(webNdefMessage);
-        assertEquals(TEST_URL, webMojoNdefMessage.url);
-        assertEquals(1, webMojoNdefMessage.data.length);
-        assertEquals(NdefRecordType.JSON, webMojoNdefMessage.data[0].recordType);
-        assertEquals(JSON_MIME, webMojoNdefMessage.data[0].mediaType);
-        assertEquals(TEST_JSON, new String(webMojoNdefMessage.data[0].data));
+        NdefMessage webNdefMessage = new NdefMessage(jsonNdefRecord, extNdefRecord);
+        NfcMessage webNfcMessage = NfcTypeConverter.toNfcMessage(webNdefMessage);
+        assertEquals(TEST_URL, webNfcMessage.url);
+        assertEquals(1, webNfcMessage.data.length);
+        assertEquals(NfcRecordType.JSON, webNfcMessage.data[0].recordType);
+        assertEquals(JSON_MIME, webNfcMessage.data[0].mediaType);
+        assertEquals(TEST_JSON, new String(webNfcMessage.data[0].data));
     }
 
     /**
-     * Test conversion from mojo NdefMessage to android NdefMessage.
+     * Test conversion from mojo NfcMessage to android NdefMessage.
      */
     @Test
     @Feature({"NFCTest"})
-    public void testMojoToNdefConversion() throws InvalidNdefMessageException {
+    public void testMojoToNdefConversion() throws InvalidNfcMessageException {
         // Test URL record conversion.
-        android.nfc.NdefMessage urlNdefMessage = createUrlWebNFCNdefMessage(TEST_URL);
+        NdefMessage urlNdefMessage = createUrlWebNFCNdefMessage(TEST_URL);
         assertEquals(2, urlNdefMessage.getRecords().length);
-        assertEquals(
-                android.nfc.NdefRecord.TNF_WELL_KNOWN, urlNdefMessage.getRecords()[0].getTnf());
+        assertEquals(NdefRecord.TNF_WELL_KNOWN, urlNdefMessage.getRecords()[0].getTnf());
         assertEquals(TEST_URL, urlNdefMessage.getRecords()[0].toUri().toString());
-        assertEquals(
-                android.nfc.NdefRecord.TNF_EXTERNAL_TYPE, urlNdefMessage.getRecords()[1].getTnf());
+        assertEquals(NdefRecord.TNF_EXTERNAL_TYPE, urlNdefMessage.getRecords()[1].getTnf());
         assertEquals(DOMAIN + ":" + TYPE, new String(urlNdefMessage.getRecords()[1].getType()));
 
         // Test TEXT record conversion.
-        NdefRecord textMojoNdefRecord = new NdefRecord();
-        textMojoNdefRecord.recordType = NdefRecordType.TEXT;
-        textMojoNdefRecord.mediaType = TEXT_MIME;
-        textMojoNdefRecord.data = ApiCompatibilityUtils.getBytesUtf8(TEST_TEXT);
-        NdefMessage textMojoNdefMessage = createMojoNdefMessage(TEST_URL, textMojoNdefRecord);
-        android.nfc.NdefMessage textNdefMessage =
-                NfcTypeConverter.toNdefMessage(textMojoNdefMessage);
+        NfcRecord textNfcRecord = new NfcRecord();
+        textNfcRecord.recordType = NfcRecordType.TEXT;
+        textNfcRecord.mediaType = TEXT_MIME;
+        textNfcRecord.data = ApiCompatibilityUtils.getBytesUtf8(TEST_TEXT);
+        NfcMessage textNfcMessage = createNfcMessage(TEST_URL, textNfcRecord);
+        NdefMessage textNdefMessage = NfcTypeConverter.toNdefMessage(textNfcMessage);
         assertEquals(2, textNdefMessage.getRecords().length);
         short tnf = textNdefMessage.getRecords()[0].getTnf();
-        boolean isWellKnownOrMime = tnf == android.nfc.NdefRecord.TNF_WELL_KNOWN
-                || tnf == android.nfc.NdefRecord.TNF_MIME_MEDIA;
+        boolean isWellKnownOrMime =
+                (tnf == NdefRecord.TNF_WELL_KNOWN || tnf == NdefRecord.TNF_MIME_MEDIA);
         assertEquals(true, isWellKnownOrMime);
-        assertEquals(
-                android.nfc.NdefRecord.TNF_EXTERNAL_TYPE, textNdefMessage.getRecords()[1].getTnf());
+        assertEquals(NdefRecord.TNF_EXTERNAL_TYPE, textNdefMessage.getRecords()[1].getTnf());
 
         // Test MIME record conversion.
-        NdefRecord mimeMojoNdefRecord = new NdefRecord();
-        mimeMojoNdefRecord.recordType = NdefRecordType.OPAQUE_RECORD;
-        mimeMojoNdefRecord.mediaType = TEXT_MIME;
-        mimeMojoNdefRecord.data = ApiCompatibilityUtils.getBytesUtf8(TEST_TEXT);
-        NdefMessage mimeMojoNdefMessage = createMojoNdefMessage(TEST_URL, mimeMojoNdefRecord);
-        android.nfc.NdefMessage mimeNdefMessage =
-                NfcTypeConverter.toNdefMessage(mimeMojoNdefMessage);
+        NfcRecord mimeNfcRecord = new NfcRecord();
+        mimeNfcRecord.recordType = NfcRecordType.OPAQUE_RECORD;
+        mimeNfcRecord.mediaType = TEXT_MIME;
+        mimeNfcRecord.data = ApiCompatibilityUtils.getBytesUtf8(TEST_TEXT);
+        NfcMessage mimeNfcMessage = createNfcMessage(TEST_URL, mimeNfcRecord);
+        NdefMessage mimeNdefMessage = NfcTypeConverter.toNdefMessage(mimeNfcMessage);
         assertEquals(2, mimeNdefMessage.getRecords().length);
-        assertEquals(
-                android.nfc.NdefRecord.TNF_MIME_MEDIA, mimeNdefMessage.getRecords()[0].getTnf());
+        assertEquals(NdefRecord.TNF_MIME_MEDIA, mimeNdefMessage.getRecords()[0].getTnf());
         assertEquals(TEXT_MIME, mimeNdefMessage.getRecords()[0].toMimeType());
         assertEquals(TEST_TEXT, new String(mimeNdefMessage.getRecords()[0].getPayload()));
-        assertEquals(
-                android.nfc.NdefRecord.TNF_EXTERNAL_TYPE, mimeNdefMessage.getRecords()[1].getTnf());
+        assertEquals(NdefRecord.TNF_EXTERNAL_TYPE, mimeNdefMessage.getRecords()[1].getTnf());
 
         // Test JSON record conversion.
-        NdefRecord jsonMojoNdefRecord = new NdefRecord();
-        jsonMojoNdefRecord.recordType = NdefRecordType.OPAQUE_RECORD;
-        jsonMojoNdefRecord.mediaType = JSON_MIME;
-        jsonMojoNdefRecord.data = ApiCompatibilityUtils.getBytesUtf8(TEST_JSON);
-        NdefMessage jsonMojoNdefMessage = createMojoNdefMessage(TEST_URL, jsonMojoNdefRecord);
-        android.nfc.NdefMessage jsonNdefMessage =
-                NfcTypeConverter.toNdefMessage(jsonMojoNdefMessage);
+        NfcRecord jsonNfcRecord = new NfcRecord();
+        jsonNfcRecord.recordType = NfcRecordType.OPAQUE_RECORD;
+        jsonNfcRecord.mediaType = JSON_MIME;
+        jsonNfcRecord.data = ApiCompatibilityUtils.getBytesUtf8(TEST_JSON);
+        NfcMessage jsonNfcMessage = createNfcMessage(TEST_URL, jsonNfcRecord);
+        NdefMessage jsonNdefMessage = NfcTypeConverter.toNdefMessage(jsonNfcMessage);
         assertEquals(2, jsonNdefMessage.getRecords().length);
-        assertEquals(
-                android.nfc.NdefRecord.TNF_MIME_MEDIA, jsonNdefMessage.getRecords()[0].getTnf());
+        assertEquals(NdefRecord.TNF_MIME_MEDIA, jsonNdefMessage.getRecords()[0].getTnf());
         assertEquals(JSON_MIME, jsonNdefMessage.getRecords()[0].toMimeType());
         assertEquals(TEST_JSON, new String(jsonNdefMessage.getRecords()[0].getPayload()));
-        assertEquals(
-                android.nfc.NdefRecord.TNF_EXTERNAL_TYPE, jsonNdefMessage.getRecords()[1].getTnf());
+        assertEquals(NdefRecord.TNF_EXTERNAL_TYPE, jsonNdefMessage.getRecords()[1].getTnf());
 
         // Test EMPTY record conversion.
-        NdefRecord emptyMojoNdefRecord = new NdefRecord();
-        emptyMojoNdefRecord.recordType = NdefRecordType.EMPTY;
-        NdefMessage emptyMojoNdefMessage = createMojoNdefMessage(TEST_URL, emptyMojoNdefRecord);
-        android.nfc.NdefMessage emptyNdefMessage =
-                NfcTypeConverter.toNdefMessage(emptyMojoNdefMessage);
+        NfcRecord emptyNfcRecord = new NfcRecord();
+        emptyNfcRecord.recordType = NfcRecordType.EMPTY;
+        NfcMessage emptyNfcMessage = createNfcMessage(TEST_URL, emptyNfcRecord);
+        NdefMessage emptyNdefMessage = NfcTypeConverter.toNdefMessage(emptyNfcMessage);
         assertEquals(2, emptyNdefMessage.getRecords().length);
-        assertEquals(android.nfc.NdefRecord.TNF_EMPTY, emptyNdefMessage.getRecords()[0].getTnf());
-        assertEquals(android.nfc.NdefRecord.TNF_EXTERNAL_TYPE,
-                emptyNdefMessage.getRecords()[1].getTnf());
+        assertEquals(NdefRecord.TNF_EMPTY, emptyNdefMessage.getRecords()[0].getTnf());
+        assertEquals(NdefRecord.TNF_EXTERNAL_TYPE, emptyNdefMessage.getRecords()[1].getTnf());
     }
 
     /**
-     * Test that invalid NdefMessage is rejected with INVALID_MESSAGE error code.
+     * Test that invalid NfcMessage is rejected with INVALID_MESSAGE error code.
      */
     @Test
     @Feature({"NFCTest"})
-    public void testInvalidNdefMessage() {
+    public void testInvalidNfcMessage() {
         TestNfcImpl nfc = new TestNfcImpl(mContext, mDelegate);
         mDelegate.invokeCallback();
         PushResponse mockCallback = mock(PushResponse.class);
-        nfc.push(new NdefMessage(), createNfcPushOptions(), mockCallback);
+        nfc.push(new NfcMessage(), createNfcPushOptions(), mockCallback);
         nfc.processPendingOperationsForTesting(mNfcTagHandler);
         verify(mockCallback).call(mErrorCaptor.capture());
         assertEquals(NfcErrorType.INVALID_MESSAGE, mErrorCaptor.getValue().errorType);
@@ -401,7 +387,7 @@
 
         // Check that client was notified and watch with correct id was triggered.
         verify(mNfcClient, times(1))
-                .onWatch(mOnWatchCallbackCaptor.capture(), any(NdefMessage.class));
+                .onWatch(mOnWatchCallbackCaptor.capture(), any(NfcMessage.class));
         assertEquals(mWatchCaptor.getValue().intValue(), mOnWatchCallbackCaptor.getValue()[0]);
     }
 
@@ -414,7 +400,7 @@
         TestNfcImpl nfc = new TestNfcImpl(mContext, mDelegate);
         mDelegate.invokeCallback();
         PushResponse mockCallback = mock(PushResponse.class);
-        nfc.push(createMojoNdefMessage(), createNfcPushOptions(), mockCallback);
+        nfc.push(createNfcMessage(), createNfcPushOptions(), mockCallback);
         nfc.processPendingOperationsForTesting(mNfcTagHandler);
         verify(mockCallback).call(mErrorCaptor.capture());
         assertNull(mErrorCaptor.getValue());
@@ -430,7 +416,7 @@
         mDelegate.invokeCallback();
         PushResponse mockPushCallback = mock(PushResponse.class);
         CancelPushResponse mockCancelPushCallback = mock(CancelPushResponse.class);
-        nfc.push(createMojoNdefMessage(), createNfcPushOptions(), mockPushCallback);
+        nfc.push(createNfcMessage(), createNfcPushOptions(), mockPushCallback);
         nfc.cancelPush(NfcPushTarget.ANY, mockCancelPushCallback);
 
         // Check that push request was cancelled with OPERATION_CANCELLED.
@@ -472,7 +458,7 @@
 
         // Check that client was notified and correct watch ids were provided.
         verify(mNfcClient, times(1))
-                .onWatch(mOnWatchCallbackCaptor.capture(), any(NdefMessage.class));
+                .onWatch(mOnWatchCallbackCaptor.capture(), any(NfcMessage.class));
         assertEquals(watchId1, mOnWatchCallbackCaptor.getValue()[0]);
         assertEquals(watchId2, mOnWatchCallbackCaptor.getValue()[1]);
     }
@@ -510,8 +496,8 @@
         // Should match by record type.
         NfcWatchOptions options3 = createNfcWatchOptions();
         options3.mode = NfcWatchMode.ANY;
-        NdefRecordTypeFilter typeFilter = new NdefRecordTypeFilter();
-        typeFilter.recordType = NdefRecordType.URL;
+        NfcRecordTypeFilter typeFilter = new NfcRecordTypeFilter();
+        typeFilter.recordType = NfcRecordType.URL;
         options3.recordFilter = typeFilter;
         WatchResponse mockWatchCallback3 = mock(WatchResponse.class);
         nfc.watch(options3, mockWatchCallback3);
@@ -533,7 +519,7 @@
 
         // Check that client was notified and watch with correct id was triggered.
         verify(mNfcClient, times(1))
-                .onWatch(mOnWatchCallbackCaptor.capture(), any(NdefMessage.class));
+                .onWatch(mOnWatchCallbackCaptor.capture(), any(NfcMessage.class));
         assertEquals(3, mOnWatchCallbackCaptor.getValue().length);
         assertEquals(watchId1, mOnWatchCallbackCaptor.getValue()[0]);
         assertEquals(watchId2, mOnWatchCallbackCaptor.getValue()[1]);
@@ -563,7 +549,7 @@
 
         // Check that watch is not triggered when NFC tag is in proximity.
         nfc.processPendingOperationsForTesting(mNfcTagHandler);
-        verify(mNfcClient, times(0)).onWatch(any(int[].class), any(NdefMessage.class));
+        verify(mNfcClient, times(0)).onWatch(any(int[].class), any(NfcMessage.class));
     }
 
     /**
@@ -649,7 +635,7 @@
 
         // Check that client was not notified.
         verify(mNfcClient, times(0))
-                .onWatch(mOnWatchCallbackCaptor.capture(), any(NdefMessage.class));
+                .onWatch(mOnWatchCallbackCaptor.capture(), any(NfcMessage.class));
     }
 
     /**
@@ -663,10 +649,8 @@
         PushResponse mockCallback = mock(PushResponse.class);
 
         // Force write operation to fail
-        doThrow(IllegalStateException.class)
-                .when(mNfcTagHandler)
-                .write(any(android.nfc.NdefMessage.class));
-        nfc.push(createMojoNdefMessage(), createNfcPushOptions(), mockCallback);
+        doThrow(IllegalStateException.class).when(mNfcTagHandler).write(any(NdefMessage.class));
+        nfc.push(createNfcMessage(), createNfcPushOptions(), mockCallback);
         nfc.processPendingOperationsForTesting(mNfcTagHandler);
         verify(mockCallback).call(mErrorCaptor.capture());
 
@@ -686,7 +670,7 @@
         PushResponse mockCallback = mock(PushResponse.class);
 
         // Set 1 millisecond timeout.
-        nfc.push(createMojoNdefMessage(), createNfcPushOptions(1), mockCallback);
+        nfc.push(createNfcMessage(), createNfcPushOptions(1), mockCallback);
 
         // Wait for timeout.
         ShadowLooper.runUiThreadTasksIncludingDelayedTasks();
@@ -708,8 +692,8 @@
 
         PushResponse mockCallback1 = mock(PushResponse.class);
         PushResponse mockCallback2 = mock(PushResponse.class);
-        nfc.push(createMojoNdefMessage(), createNfcPushOptions(), mockCallback1);
-        nfc.push(createMojoNdefMessage(), createNfcPushOptions(), mockCallback2);
+        nfc.push(createNfcMessage(), createNfcPushOptions(), mockCallback1);
+        nfc.push(createNfcMessage(), createNfcPushOptions(), mockCallback2);
 
         verify(mNfcAdapter, times(1))
                 .enableReaderMode(any(Activity.class), any(ReaderCallback.class), anyInt(),
@@ -732,7 +716,7 @@
         PushResponse mockCallback = mock(PushResponse.class);
 
         // Set 1 millisecond timeout.
-        nfc.push(createMojoNdefMessage(), createNfcPushOptions(1), mockCallback);
+        nfc.push(createNfcMessage(), createNfcPushOptions(1), mockCallback);
 
         verify(mNfcAdapter, times(1))
                 .enableReaderMode(any(Activity.class), any(ReaderCallback.class), anyInt(),
@@ -763,13 +747,13 @@
         PushResponse mockCallback1 = mock(PushResponse.class);
 
         // First push without timeout, must be completed with OPERATION_CANCELLED.
-        nfc.push(createMojoNdefMessage(), createNfcPushOptions(), mockCallback1);
+        nfc.push(createNfcMessage(), createNfcPushOptions(), mockCallback1);
 
         PushResponse mockCallback2 = mock(PushResponse.class);
 
         // Second push with 1 millisecond timeout, should be cancelled before timer expires,
         // thus, operation must be completed with OPERATION_CANCELLED.
-        nfc.push(createMojoNdefMessage(), createNfcPushOptions(1), mockCallback2);
+        nfc.push(createNfcMessage(), createNfcPushOptions(1), mockCallback2);
 
         verify(mNfcAdapter, times(1))
                 .enableReaderMode(any(Activity.class), any(ReaderCallback.class), anyInt(),
@@ -809,12 +793,12 @@
         PushResponse mockCallback1 = mock(PushResponse.class);
 
         // First push without timeout, must be completed with OPERATION_CANCELLED.
-        nfc.push(createMojoNdefMessage(), createNfcPushOptions(1), mockCallback1);
+        nfc.push(createNfcMessage(), createNfcPushOptions(1), mockCallback1);
 
         PushResponse mockCallback2 = mock(PushResponse.class);
 
         // Second push with 1 millisecond timeout, should be cancelled with TIMER_EXPIRED.
-        nfc.push(createMojoNdefMessage(), createNfcPushOptions(1), mockCallback2);
+        nfc.push(createNfcMessage(), createNfcPushOptions(1), mockCallback2);
 
         verify(mNfcAdapter, times(1))
                 .enableReaderMode(any(Activity.class), any(ReaderCallback.class), anyInt(),
@@ -853,7 +837,7 @@
 
         PushResponse mockPushCallback = mock(PushResponse.class);
         // Should be cancelled with TIMER_EXPIRED.
-        nfc.push(createMojoNdefMessage(), createNfcPushOptions(1), mockPushCallback);
+        nfc.push(createNfcMessage(), createNfcPushOptions(1), mockPushCallback);
 
         verify(mNfcAdapter, times(1))
                 .enableReaderMode(any(Activity.class), any(ReaderCallback.class), anyInt(),
@@ -891,7 +875,7 @@
         PushResponse mockCallback = mock(PushResponse.class);
 
         // Long overflow
-        nfc.push(createMojoNdefMessage(), createNfcPushOptions(Long.MAX_VALUE + 1), mockCallback);
+        nfc.push(createNfcMessage(), createNfcPushOptions(Long.MAX_VALUE + 1), mockCallback);
 
         verify(mockCallback).call(mErrorCaptor.capture());
         assertNotNull(mErrorCaptor.getValue());
@@ -899,7 +883,7 @@
 
         // Test negative timeout
         PushResponse mockCallback2 = mock(PushResponse.class);
-        nfc.push(createMojoNdefMessage(), createNfcPushOptions(-1), mockCallback2);
+        nfc.push(createNfcMessage(), createNfcPushOptions(-1), mockCallback2);
 
         verify(mockCallback2).call(mErrorCaptor.capture());
         assertNotNull(mErrorCaptor.getValue());
@@ -1002,13 +986,13 @@
                 .read();
         nfc.processPendingOperationsForTesting(mNfcTagHandler);
 
-        // None of the watches should match NdefMessage with this WebNFC Id.
+        // None of the watches should match NFCMessage with this WebNFC Id.
         doReturn(createUrlWebNFCNdefMessage("https://notest.com/foo")).when(mNfcTagHandler).read();
         nfc.processPendingOperationsForTesting(mNfcTagHandler);
 
         // Check that client was notified and watch with correct id was triggered.
         verify(mNfcClient, times(1))
-                .onWatch(mOnWatchCallbackCaptor.capture(), any(NdefMessage.class));
+                .onWatch(mOnWatchCallbackCaptor.capture(), any(NfcMessage.class));
         assertEquals(4, mOnWatchCallbackCaptor.getValue().length);
         assertEquals(watchId1, mOnWatchCallbackCaptor.getValue()[0]);
         assertEquals(watchId2, mOnWatchCallbackCaptor.getValue()[1]);
@@ -1049,7 +1033,7 @@
         nfc.processPendingOperationsForTesting(mNfcTagHandler);
 
         verify(mNfcClient, times(0))
-                .onWatch(mOnWatchCallbackCaptor.capture(), any(NdefMessage.class));
+                .onWatch(mOnWatchCallbackCaptor.capture(), any(NfcMessage.class));
     }
 
     /**
@@ -1063,11 +1047,11 @@
         PushResponse mockCallback = mock(PushResponse.class);
 
         // Create message with empty record.
-        NdefRecord emptyNdefRecord = new NdefRecord();
-        emptyNdefRecord.recordType = NdefRecordType.EMPTY;
-        NdefMessage ndefMessage = createMojoNdefMessage(TEST_URL, emptyNdefRecord);
+        NfcRecord emptyNfcRecord = new NfcRecord();
+        emptyNfcRecord.recordType = NfcRecordType.EMPTY;
+        NfcMessage nfcMessage = createNfcMessage(TEST_URL, emptyNfcRecord);
 
-        nfc.push(ndefMessage, createNfcPushOptions(), mockCallback);
+        nfc.push(nfcMessage, createNfcPushOptions(), mockCallback);
         nfc.processPendingOperationsForTesting(mNfcTagHandler);
         verify(mockCallback).call(mErrorCaptor.capture());
         assertNull(mErrorCaptor.getValue());
@@ -1104,36 +1088,36 @@
         return options;
     }
 
-    private NdefMessage createMojoNdefMessage() {
-        NdefMessage message = new NdefMessage();
+    private NfcMessage createNfcMessage() {
+        NfcMessage message = new NfcMessage();
         message.url = "";
-        message.data = new NdefRecord[1];
+        message.data = new NfcRecord[1];
 
-        NdefRecord nfcRecord = new NdefRecord();
-        nfcRecord.recordType = NdefRecordType.TEXT;
+        NfcRecord nfcRecord = new NfcRecord();
+        nfcRecord.recordType = NfcRecordType.TEXT;
         nfcRecord.mediaType = TEXT_MIME;
         nfcRecord.data = ApiCompatibilityUtils.getBytesUtf8(TEST_TEXT);
         message.data[0] = nfcRecord;
         return message;
     }
 
-    private NdefMessage createMojoNdefMessage(String url, NdefRecord record) {
-        NdefMessage message = new NdefMessage();
+    private NfcMessage createNfcMessage(String url, NfcRecord record) {
+        NfcMessage message = new NfcMessage();
         message.url = url;
-        message.data = new NdefRecord[1];
+        message.data = new NfcRecord[1];
         message.data[0] = record;
         return message;
     }
 
-    private android.nfc.NdefMessage createUrlWebNFCNdefMessage(String webNfcId) {
-        NdefRecord urlMojoNdefRecord = new NdefRecord();
-        urlMojoNdefRecord.recordType = NdefRecordType.URL;
-        urlMojoNdefRecord.mediaType = TEXT_MIME;
-        urlMojoNdefRecord.data = ApiCompatibilityUtils.getBytesUtf8(TEST_URL);
-        NdefMessage urlNdefMessage = createMojoNdefMessage(webNfcId, urlMojoNdefRecord);
+    private NdefMessage createUrlWebNFCNdefMessage(String webNfcId) {
+        NfcRecord urlNfcRecord = new NfcRecord();
+        urlNfcRecord.recordType = NfcRecordType.URL;
+        urlNfcRecord.mediaType = TEXT_MIME;
+        urlNfcRecord.data = ApiCompatibilityUtils.getBytesUtf8(TEST_URL);
+        NfcMessage urlNfcMessage = createNfcMessage(webNfcId, urlNfcRecord);
         try {
-            return NfcTypeConverter.toNdefMessage(urlNdefMessage);
-        } catch (InvalidNdefMessageException e) {
+            return NfcTypeConverter.toNdefMessage(urlNfcMessage);
+        } catch (InvalidNfcMessageException e) {
             return null;
         }
     }
--- a/services/device/OWNERS	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/OWNERS	2019-05-17 18:53:37.804000000 +0300
@@ -5,3 +5,6 @@
 reillyg@chromium.org
 rockot@google.com
 
+per-file manifest.json=set noparent
+per-file manifest.json=file://ipc/SECURITY_OWNERS
+
--- a/services/device/public/cpp/bluetooth/bluetooth_utils.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/public/cpp/bluetooth/bluetooth_utils.h	2019-05-17 18:53:37.836000000 +0300
@@ -20,6 +20,6 @@
 base::string16 GetBluetoothDeviceNameForDisplay(
     const mojom::BluetoothDeviceInfoPtr& device_info);
 
-}  // namespace device
+};  // namespace device
 
 #endif  // SERVICES_DEVICE_PUBLIC_CPP_BLUETOOTH_BLUETOOTH_UTILS_H_
--- a/services/device/public/cpp/BUILD.gn	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/public/cpp/BUILD.gn	2019-05-17 18:53:37.836000000 +0300
@@ -19,23 +19,3 @@
 
   defines = [ "DEVICE_FEATURES_IMPLEMENTATION" ]
 }
-
-source_set("manifest") {
-  sources = [
-    "manifest.cc",
-    "manifest.h",
-  ]
-
-  deps = [
-    "//base",
-    "//device/usb/public/mojom",
-    "//device/usb/public/mojom:test",
-    "//services/device/public/mojom",
-    "//services/device/public/mojom:generic_sensor",
-    "//services/service_manager/public/cpp",
-  ]
-
-  if (is_chromeos && use_dbus) {
-    defines = [ "USE_DBUS=1" ]
-  }
-}
--- a/services/device/public/cpp/generic_sensor/BUILD.gn	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/public/cpp/generic_sensor/BUILD.gn	2019-05-17 18:53:37.840000000 +0300
@@ -4,6 +4,8 @@
 
 source_set("generic_sensor") {
   sources = [
+    "platform_sensor_configuration.cc",
+    "platform_sensor_configuration.h",
     "sensor_reading.cc",
     "sensor_reading.h",
     "sensor_reading_shared_buffer_reader.cc",
@@ -13,7 +15,6 @@
   ]
 
   public_deps = [
-    ":sensor_configuration",
     "//services/device/public/mojom:generic_sensor",
   ]
 
@@ -22,14 +23,3 @@
     "//device/base/synchronization",
   ]
 }
-
-source_set("sensor_configuration") {
-  sources = [
-    "platform_sensor_configuration.cc",
-    "platform_sensor_configuration.h",
-  ]
-
-  deps = [
-    "//base",
-  ]
-}
--- a/services/device/public/cpp/hid/BUILD.gn	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/public/cpp/hid/BUILD.gn	2019-05-17 18:53:37.840000000 +0300
@@ -12,18 +12,12 @@
   sources = [
     "fake_input_service_linux.cc",
     "fake_input_service_linux.h",
-    "hid_collection.cc",
-    "hid_collection.h",
     "hid_device_filter.cc",
     "hid_device_filter.h",
-    "hid_item_state_table.cc",
-    "hid_item_state_table.h",
     "hid_report_descriptor.cc",
     "hid_report_descriptor.h",
     "hid_report_descriptor_item.cc",
     "hid_report_descriptor_item.h",
-    "hid_report_item.cc",
-    "hid_report_item.h",
     "hid_usage_and_page.cc",
     "hid_usage_and_page.h",
   ]
--- a/services/device/public/cpp/hid/fake_input_service_linux.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/public/cpp/hid/fake_input_service_linux.h	2019-05-17 18:53:37.840000000 +0300
@@ -2,8 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#ifndef SERVICES_DEVICE_PUBLIC_CPP_HID_FAKE_INPUT_SERVICE_LINUX_H_
-#define SERVICES_DEVICE_PUBLIC_CPP_HID_FAKE_INPUT_SERVICE_LINUX_H_
+#ifndef DEVICE_HID_FAKE_INPUT_SERVICE_LINUX_H_
+#define DEVICE_HID_FAKE_INPUT_SERVICE_LINUX_H_
 
 #include <map>
 #include <string>
@@ -42,4 +42,4 @@
 
 }  // namespace device
 
-#endif  // SERVICES_DEVICE_PUBLIC_CPP_HID_FAKE_INPUT_SERVICE_LINUX_H_
+#endif  // DEVICE_HID_FAKE_INPUT_SERVICE_LINUX_H_
--- a/services/device/public/cpp/hid/hid_device_filter.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/public/cpp/hid/hid_device_filter.h	2019-05-17 18:53:37.840000000 +0300
@@ -2,8 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#ifndef SERVICES_DEVICE_PUBLIC_CPP_HID_HID_DEVICE_FILTER_H_
-#define SERVICES_DEVICE_PUBLIC_CPP_HID_HID_DEVICE_FILTER_H_
+#ifndef DEVICE_HID_HID_DEVICE_FILTER_H_
+#define DEVICE_HID_HID_DEVICE_FILTER_H_
 
 #include <stdint.h>
 #include <vector>
@@ -41,4 +41,4 @@
 
 }  // namespace device
 
-#endif  // SERVICES_DEVICE_PUBLIC_CPP_HID_HID_DEVICE_FILTER_H_
+#endif  // DEVICE_HID_HID_DEVICE_FILTER_H_
--- a/services/device/public/cpp/hid/hid_report_descriptor.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/public/cpp/hid/hid_report_descriptor.cc	2019-05-17 18:53:37.840000000 +0300
@@ -4,10 +4,7 @@
 
 #include "services/device/public/cpp/hid/hid_report_descriptor.h"
 
-#include <algorithm>
-#include <limits>
-#include <utility>
-
+#include "base/memory/ptr_util.h"
 #include "base/stl_util.h"
 
 namespace device {
@@ -22,11 +19,11 @@
   size_t header_index = 0;
   HidReportDescriptorItem* item = nullptr;
   while (header_index < bytes.size()) {
-    items_.push_back(HidReportDescriptorItem::Create(
-        &bytes[header_index], bytes.size() - header_index, item));
-    header_index += items_.back()->GetSize();
+    item = new HidReportDescriptorItem(&bytes[header_index],
+                                       bytes.size() - header_index, item);
+    items_.push_back(base::WrapUnique(item));
+    header_index += item->GetSize();
   }
-  collections_ = HidCollection::BuildCollections(items_);
 }
 
 HidReportDescriptor::~HidReportDescriptor() {}
@@ -34,37 +31,126 @@
 void HidReportDescriptor::GetDetails(
     std::vector<mojom::HidCollectionInfoPtr>* top_level_collections,
     bool* has_report_id,
-    size_t* max_input_report_bytes,
-    size_t* max_output_report_bytes,
-    size_t* max_feature_report_bytes) const {
+    size_t* max_input_report_size,
+    size_t* max_output_report_size,
+    size_t* max_feature_report_size) {
   DCHECK(top_level_collections);
-  DCHECK(has_report_id);
-  DCHECK(max_input_report_bytes);
-  DCHECK(max_output_report_bytes);
-  DCHECK(max_feature_report_bytes);
+  DCHECK(max_input_report_size);
+  DCHECK(max_output_report_size);
+  DCHECK(max_feature_report_size);
   base::STLClearObject(top_level_collections);
 
-  size_t max_input_report_bits = 0;
-  size_t max_output_report_bits = 0;
-  size_t max_feature_report_bits = 0;
   *has_report_id = false;
-  for (const auto& collection : collections_) {
-    size_t input_bits;
-    size_t output_bits;
-    size_t feature_bits;
-    collection->GetMaxReportSizes(&input_bits, &output_bits, &feature_bits);
-    top_level_collections->push_back(collection->ToMojo());
-    if (collection->HasReportId())
+  *max_input_report_size = 0;
+  *max_output_report_size = 0;
+  *max_feature_report_size = 0;
+
+  // Global tags data:
+  auto current_usage_page = mojom::kPageUndefined;
+  size_t current_report_count = 0;
+  size_t cached_report_count = 0;
+  size_t current_report_size = 0;
+  size_t cached_report_size = 0;
+  size_t current_input_report_size = 0;
+  size_t current_output_report_size = 0;
+  size_t current_feature_report_size = 0;
+
+  // Local tags data:
+  uint32_t current_usage = 0;
+
+  for (const auto& current_item : items()) {
+    switch (current_item->tag()) {
+      // Main tags:
+      case HidReportDescriptorItem::kTagCollection:
+        if (!current_item->parent() &&
+            (current_usage <= std::numeric_limits<uint16_t>::max())) {
+          // This is a top-level collection.
+          auto collection = mojom::HidCollectionInfo::New();
+          collection->usage = mojom::HidUsageAndPage::New(
+              static_cast<uint16_t>(current_usage),
+              static_cast<uint16_t>(current_usage_page));
+          top_level_collections->push_back(std::move(collection));
+        }
+        break;
+      case HidReportDescriptorItem::kTagInput:
+        current_input_report_size += current_report_count * current_report_size;
+        break;
+      case HidReportDescriptorItem::kTagOutput:
+        current_output_report_size +=
+            current_report_count * current_report_size;
+        break;
+      case HidReportDescriptorItem::kTagFeature:
+        current_feature_report_size +=
+            current_report_count * current_report_size;
+        break;
+
+      // Global tags:
+      case HidReportDescriptorItem::kTagUsagePage:
+        current_usage_page = current_item->GetShortData();
+        break;
+      case HidReportDescriptorItem::kTagReportId:
+        if (top_level_collections->size() > 0) {
+          // Store report ID.
+          top_level_collections->back()->report_ids.push_back(
+              current_item->GetShortData());
       *has_report_id = true;
-    max_input_report_bits = std::max(max_input_report_bits, input_bits);
-    max_output_report_bits = std::max(max_output_report_bits, output_bits);
-    max_feature_report_bits = std::max(max_feature_report_bits, feature_bits);
+
+          // Update max report sizes.
+          *max_input_report_size =
+              std::max(*max_input_report_size, current_input_report_size);
+          *max_output_report_size =
+              std::max(*max_output_report_size, current_output_report_size);
+          *max_feature_report_size =
+              std::max(*max_feature_report_size, current_feature_report_size);
+
+          // Reset the report sizes for the next report ID.
+          current_input_report_size = 0;
+          current_output_report_size = 0;
+          current_feature_report_size = 0;
+        }
+        break;
+      case HidReportDescriptorItem::kTagReportCount:
+        current_report_count = current_item->GetShortData();
+        break;
+      case HidReportDescriptorItem::kTagReportSize:
+        current_report_size = current_item->GetShortData();
+        break;
+      case HidReportDescriptorItem::kTagPush:
+        // Cache report count and size.
+        cached_report_count = current_report_count;
+        cached_report_size = current_report_size;
+        break;
+      case HidReportDescriptorItem::kTagPop:
+        // Restore cache.
+        current_report_count = cached_report_count;
+        current_report_size = cached_report_size;
+        // Reset cache.
+        cached_report_count = 0;
+        cached_report_size = 0;
+        break;
+
+      // Local tags:
+      case HidReportDescriptorItem::kTagUsage:
+        current_usage = current_item->GetShortData();
+        break;
+
+      default:
+        break;
+    }
   }
 
-  // Convert bits into bytes.
-  *max_input_report_bytes = max_input_report_bits / kBitsPerByte;
-  *max_output_report_bytes = max_output_report_bits / kBitsPerByte;
-  *max_feature_report_bytes = max_feature_report_bits / kBitsPerByte;
+  // Update max report sizes
+  *max_input_report_size =
+      std::max(*max_input_report_size, current_input_report_size);
+  *max_output_report_size =
+      std::max(*max_output_report_size, current_output_report_size);
+  *max_feature_report_size =
+      std::max(*max_feature_report_size, current_feature_report_size);
+
+  // Convert bits into bytes
+  *max_input_report_size /= kBitsPerByte;
+  *max_output_report_size /= kBitsPerByte;
+  *max_feature_report_size /= kBitsPerByte;
 }
 
 }  // namespace device
--- a/services/device/public/cpp/hid/hid_report_descriptor.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/public/cpp/hid/hid_report_descriptor.h	2019-05-17 18:53:37.840000000 +0300
@@ -2,8 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#ifndef SERVICES_DEVICE_PUBLIC_CPP_HID_HID_REPORT_DESCRIPTOR_H_
-#define SERVICES_DEVICE_PUBLIC_CPP_HID_HID_REPORT_DESCRIPTOR_H_
+#ifndef DEVICE_HID_HID_REPORT_DESCRIPTOR_H_
+#define DEVICE_HID_HID_REPORT_DESCRIPTOR_H_
 
 #include <stddef.h>
 #include <stdint.h>
@@ -11,7 +11,6 @@
 #include <memory>
 #include <vector>
 
-#include "services/device/public/cpp/hid/hid_collection.h"
 #include "services/device/public/cpp/hid/hid_report_descriptor_item.h"
 #include "services/device/public/mojom/hid.mojom.h"
 
@@ -28,29 +27,19 @@
     return items_;
   }
 
-  const std::vector<std::unique_ptr<HidCollection>>& collections() const {
-    return collections_;
-  }
-
-  // Return the top-level collections present in the descriptor,
-  // together with max report sizes.
+  // Returns top-level collections present in the descriptor,
+  // together with max report sizes
   void GetDetails(
       std::vector<mojom::HidCollectionInfoPtr>* top_level_collections,
       bool* has_report_id,
-      size_t* max_input_report_bytes,
-      size_t* max_output_report_bytes,
-      size_t* max_feature_report_bytes) const;
+      size_t* max_input_report_size,
+      size_t* max_output_report_size,
+      size_t* max_feature_report_size);
 
  private:
-  // An ordered sequence of HidReportDescriptorItem objects representing the
-  // items that make up a HID report descriptor.
   std::vector<std::unique_ptr<HidReportDescriptorItem>> items_;
-
-  // A hierarchichal representation of the collections and reports described by
-  // the HID report descriptor.
-  std::vector<std::unique_ptr<HidCollection>> collections_;
 };
 
 }  // namespace device
 
-#endif  // SERVICES_DEVICE_PUBLIC_CPP_HID_HID_REPORT_DESCRIPTOR_H_
+#endif  // DEVICE_HID_HID_REPORT_DESCRIPTOR_H_
--- a/services/device/public/cpp/hid/hid_report_descriptor_item.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/public/cpp/hid/hid_report_descriptor_item.cc	2019-05-17 18:53:37.840000000 +0300
@@ -93,4 +93,29 @@
   return shortData_;
 }
 
+HidReportDescriptorItem::CollectionType
+HidReportDescriptorItem::GetCollectionTypeFromValue(uint32_t value) {
+  switch (value) {
+    case 0x00:
+      return kCollectionTypePhysical;
+    case 0x01:
+      return kCollectionTypeApplication;
+    case 0x02:
+      return kCollectionTypeLogical;
+    case 0x03:
+      return kCollectionTypeReport;
+    case 0x04:
+      return kCollectionTypeNamedArray;
+    case 0x05:
+      return kCollectionTypeUsageSwitch;
+    case 0x06:
+      return kCollectionTypeUsageModifier;
+    default:
+      break;
+  }
+  if (0x80 < value && value < 0xFF)
+    return kCollectionTypeVendor;
+  return kCollectionTypeReserved;
+}
+
 }  // namespace device
--- a/services/device/public/cpp/hid/hid_report_descriptor_item.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/public/cpp/hid/hid_report_descriptor_item.h	2019-05-17 18:53:37.840000000 +0300
@@ -2,19 +2,19 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#ifndef SERVICES_DEVICE_PUBLIC_CPP_HID_HID_REPORT_DESCRIPTOR_ITEM_H_
-#define SERVICES_DEVICE_PUBLIC_CPP_HID_HID_REPORT_DESCRIPTOR_ITEM_H_
+#ifndef DEVICE_HID_HID_REPORT_DESCRIPTOR_ITEM_H_
+#define DEVICE_HID_HID_REPORT_DESCRIPTOR_ITEM_H_
 
 #include <stddef.h>
 #include <stdint.h>
 
-#include <memory>
-
 namespace device {
 
 // An element of a HID report descriptor.
 class HidReportDescriptorItem {
  private:
+  friend class HidReportDescriptor;
+
   enum Type {
     kTypeMain = 0,
     kTypeGlobal = 1,
@@ -100,11 +100,7 @@
   // Can be retrieved from GetShortData()
   // when item.tag() == HidReportDescriptorItem::kTagInput
   // or HidReportDescriptorItem::kTagOutput
-  // or HidReportDescriptorItem::kTagFeature.
-  // The ReportInfo struct matches the layout of the bitfield defined in section
-  // 6.2.2.5 of the Device Class Definition for HID v1.11. Pad to 32-bits so it
-  // can be safely cast to and from uint32_t.
-#pragma pack(push, 1)
+  // or HidReportDescriptorItem::kTagFeature
   struct ReportInfo {
     uint8_t data_or_constant : 1;
     uint8_t array_or_variable : 1;
@@ -113,14 +109,25 @@
     uint8_t linear : 1;
     uint8_t preferred : 1;
     uint8_t null : 1;
-    uint8_t is_volatile : 1;
+    uint8_t reserved_1 : 1;
     uint8_t bit_field_or_buffer : 1;
-    uint8_t reserved : 7;
-    uint8_t reserved2[2];
+    uint8_t reserved_2 : 1;
+  };
+
+  // HID collection type.
+  // Can be retrieved from GetShortData()
+  // when item.tag() == HidReportDescriptorItem::kTagCollection
+  enum CollectionType {
+    kCollectionTypePhysical,
+    kCollectionTypeApplication,
+    kCollectionTypeLogical,
+    kCollectionTypeReport,
+    kCollectionTypeNamedArray,
+    kCollectionTypeUsageSwitch,
+    kCollectionTypeUsageModifier,
+    kCollectionTypeReserved,
+    kCollectionTypeVendor
   };
-#pragma pack(pop)
-  static_assert(sizeof(ReportInfo) == sizeof(uint32_t),
-                "incorrect report info size");
 
  private:
   HidReportDescriptorItem(const uint8_t* bytes,
@@ -130,22 +137,16 @@
  public:
   ~HidReportDescriptorItem() {}
 
-  static std::unique_ptr<HidReportDescriptorItem>
-  Create(const uint8_t* bytes, size_t size, HidReportDescriptorItem* previous) {
-    return std::unique_ptr<HidReportDescriptorItem>(
-        new HidReportDescriptorItem(bytes, size, previous));
-  }
-
   // Previous element in report descriptor.
   // Owned by descriptor instance.
-  HidReportDescriptorItem* previous() const { return previous_; }
+  HidReportDescriptorItem* previous() const { return previous_; };
   // Next element in report descriptor.
   // Owned by descriptor instance.
-  HidReportDescriptorItem* next() const { return next_; }
+  HidReportDescriptorItem* next() const { return next_; };
   // Parent element in report descriptor.
   // Owned by descriptor instance.
   // Can be NULL.
-  HidReportDescriptorItem* parent() const { return parent_; }
+  HidReportDescriptorItem* parent() const { return parent_; };
   // Level in Parent-Children relationship tree.
   // 0 for top-level items (parent()==NULL).
   // 1 if parent() is top-level.
@@ -157,12 +158,13 @@
   // Raw data of a short item.
   // Not valid for a long item.
   uint32_t GetShortData() const;
-  // Size of this item in bytes, including the header.
-  size_t GetSize() const;
+
+  static CollectionType GetCollectionTypeFromValue(uint32_t value);
 
  private:
   size_t GetHeaderSize() const;
   size_t payload_size() const { return payload_size_; }
+  size_t GetSize() const;
 
   HidReportDescriptorItem* previous_;
   HidReportDescriptorItem* next_;
@@ -174,4 +176,4 @@
 
 }  // namespace device
 
-#endif  // SERVICES_DEVICE_PUBLIC_CPP_HID_HID_REPORT_DESCRIPTOR_ITEM_H_
+#endif  // DEVICE_HID_HID_REPORT_DESCRIPTOR_ITEM_H_
--- a/services/device/public/cpp/hid/hid_report_descriptor_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/public/cpp/hid/hid_report_descriptor_unittest.cc	2019-05-17 18:53:37.840000000 +0300
@@ -5,325 +5,43 @@
 #include <stddef.h>
 #include <stdint.h>
 
-#include <limits>
 #include <sstream>
-#include <unordered_map>
-#include <utility>
 
 #include "base/macros.h"
 #include "services/device/hid/test_report_descriptors.h"
 #include "services/device/public/cpp/hid/hid_report_descriptor.h"
-#include "services/device/public/cpp/hid/hid_usage_and_page.h"
 #include "services/device/public/mojom/hid.mojom.h"
 #include "testing/gmock/include/gmock/gmock.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
 namespace device {
 
-namespace {
-using HidReport = std::vector<std::unique_ptr<HidReportItem>>;
-using HidReportMap = std::unordered_map<uint8_t, HidReport>;
-using HidCollectionVector = std::vector<std::unique_ptr<HidCollection>>;
-
-// HID unit values.
-const uint32_t kUnitCandela = 0x010000e1;
-const uint32_t kUnitDegrees = 0x14;
-const uint32_t kUnitInch = 0x13;
-const uint32_t kUnitNewton = 0xe111;
-const uint32_t kUnitSecond = 0x1001;
-
-// Report info bitfield values. The bits are:
-//   bit 0: Data (0) | Constant (1)
-//   bit 1: Array (0) | Variable (1)
-//   bit 2: Absolute (0) | Relative (1)
-//   bit 3: No Wrap (0) | Wrap (1)
-//   bit 4: Linear (0) | Non-Linear (1)
-//   bit 5: Preferred State (0) | No Preferred State (1)
-//   bit 6: No Null Value (0) | Has Null Value (1)
-//   bit 7: Non-Volatile (0) | Volatile (1)
-//   bit 8: Bit Field (0) | Buffered Bytes (1)
-const uint16_t kNonNullableArray = 0x0000;
-const uint16_t kConstantArray = 0x0001;
-const uint16_t kAbsoluteVariable = 0x0002;
-const uint16_t kConstant = 0x0003;
-const uint16_t kRelativeVariable = 0x0006;
-const uint16_t kNonLinearVariable = 0x0012;
-const uint16_t kNullableArray = 0x0040;
-const uint16_t kNullableAbsoluteVariable = 0x0042;
-const uint16_t kVolatileConstant = 0x0083;
-const uint16_t kBufferedBytes = 0x0102;
-
-// Vendor usage pages.
-const uint16_t kPageVendor02 = mojom::kPageVendor + 0x02;
-const uint16_t kPageVendor05 = mojom::kPageVendor + 0x05;
-const uint16_t kPageVendor80 = mojom::kPageVendor + 0x80;
-
-// Bit-width and mask for the usage ID field in a 32-bit usage value.
-const size_t kUsageIdSizeBits = sizeof(uint16_t) * 8;
-const uint32_t kUsageIdMask = std::numeric_limits<uint16_t>::max();
-
-// Combined usage page and usage ID values. The usage page occupies the high 16
-// bits, the usage ID occupies the low 16 bits.
-const uint32_t kUsageButton = (mojom::kPageButton << kUsageIdSizeBits);
-const uint32_t kUsageConsumer = (mojom::kPageConsumer << kUsageIdSizeBits);
-const uint32_t kUsageConsumerACBack = kUsageConsumer | 0x0224;
-const uint32_t kUsageConsumerACHome = kUsageConsumer | 0x0223;
-const uint32_t kUsageConsumerControl = kUsageConsumer | 0x01;
-const uint32_t kUsageConsumerModeStep = kUsageConsumer | 0x82;
-const uint32_t kUsageDigitizer = (mojom::kPageDigitizer << kUsageIdSizeBits);
-const uint32_t kUsageDigitizerDigitizer = kUsageDigitizer | 0x01;
-const uint32_t kUsageDigitizerBarrelSwitch = kUsageDigitizer | 0x44;
-const uint32_t kUsageDigitizerInRange = kUsageDigitizer | 0x32;
-const uint32_t kUsageDigitizerPuck = kUsageDigitizer | 0x21;
-const uint32_t kUsageDigitizerStylus = kUsageDigitizer | 0x20;
-const uint32_t kUsageDigitizerTipPressure = kUsageDigitizer | 0x30;
-const uint32_t kUsageDigitizerTipSwitch = kUsageDigitizer | 0x42;
-const uint32_t kUsageGenericDesktop =
-    (mojom::kPageGenericDesktop << kUsageIdSizeBits);
-const uint32_t kUsageGenericDesktopDial =
-    kUsageGenericDesktop | mojom::kGenericDesktopDial;
-const uint32_t kUsageGenericDesktopGamePad =
-    kUsageGenericDesktop | mojom::kGenericDesktopGamePad;
-const uint32_t kUsageGenericDesktopHatSwitch =
-    kUsageGenericDesktop | mojom::kGenericDesktopHatSwitch;
-const uint32_t kUsageGenericDesktopJoystick =
-    kUsageGenericDesktop | mojom::kGenericDesktopJoystick;
-const uint32_t kUsageGenericDesktopKeyboard =
-    kUsageGenericDesktop | mojom::kGenericDesktopKeyboard;
-const uint32_t kUsageGenericDesktopMouse =
-    kUsageGenericDesktop | mojom::kGenericDesktopMouse;
-const uint32_t kUsageGenericDesktopPointer =
-    kUsageGenericDesktop | mojom::kGenericDesktopPointer;
-const uint32_t kUsageGenericDesktopRx =
-    kUsageGenericDesktop | mojom::kGenericDesktopRx;
-const uint32_t kUsageGenericDesktopRy =
-    kUsageGenericDesktop | mojom::kGenericDesktopRy;
-const uint32_t kUsageGenericDesktopRz =
-    kUsageGenericDesktop | mojom::kGenericDesktopRz;
-const uint32_t kUsageGenericDesktopSystemControl =
-    kUsageGenericDesktop | mojom::kGenericDesktopSystemControl;
-const uint32_t kUsageGenericDesktopSystemMainMenu =
-    kUsageGenericDesktop | mojom::kGenericDesktopSystemMainMenu;
-const uint32_t kUsageGenericDesktopVbrx =
-    kUsageGenericDesktop | mojom::kGenericDesktopVbrx;
-const uint32_t kUsageGenericDesktopVbry =
-    kUsageGenericDesktop | mojom::kGenericDesktopVbry;
-const uint32_t kUsageGenericDesktopVbrz =
-    kUsageGenericDesktop | mojom::kGenericDesktopVbrz;
-const uint32_t kUsageGenericDesktopVx =
-    kUsageGenericDesktop | mojom::kGenericDesktopVx;
-const uint32_t kUsageGenericDesktopVy =
-    kUsageGenericDesktop | mojom::kGenericDesktopVy;
-const uint32_t kUsageGenericDesktopVz =
-    kUsageGenericDesktop | mojom::kGenericDesktopVz;
-const uint32_t kUsageGenericDesktopWheel =
-    kUsageGenericDesktop | mojom::kGenericDesktopWheel;
-const uint32_t kUsageGenericDesktopX =
-    kUsageGenericDesktop | mojom::kGenericDesktopX;
-const uint32_t kUsageGenericDesktopY =
-    kUsageGenericDesktop | mojom::kGenericDesktopY;
-const uint32_t kUsageGenericDesktopZ =
-    kUsageGenericDesktop | mojom::kGenericDesktopZ;
-const uint32_t kUsageGenericDeviceBatteryStrength =
-    (mojom::kPageGenericDevice << kUsageIdSizeBits) | 0x20;
-const uint32_t kUsageKeyboard = (mojom::kPageKeyboard << kUsageIdSizeBits);
-const uint32_t kUsageKeyboardApplication = kUsageKeyboard | 0x65;
-const uint32_t kUsageKeyboardLeftControl = kUsageKeyboard | 0xe0;
-const uint32_t kUsageKeyboardRightGui = kUsageKeyboard | 0xe7;
-const uint32_t kUsageLedNumLock = (mojom::kPageLed << kUsageIdSizeBits) | 0x01;
-const uint32_t kUsageLedCapsLock = (mojom::kPageLed << kUsageIdSizeBits) | 0x02;
-const uint32_t kUsageLedScrollLock =
-    (mojom::kPageLed << kUsageIdSizeBits) | 0x03;
-const uint32_t kUsageLedCompose = (mojom::kPageLed << kUsageIdSizeBits) | 0x04;
-const uint32_t kUsageLedKana = (mojom::kPageLed << kUsageIdSizeBits) | 0x05;
-const uint32_t kUsageMonitorControl =
-    (mojom::kPageMonitor0 << kUsageIdSizeBits) | 0x01;
-const uint32_t kUsageMonitorEdidInfo =
-    (mojom::kPageMonitor0 << kUsageIdSizeBits) | 0x02;
-const uint32_t kUsageMonitorVdifInfo =
-    (mojom::kPageMonitor0 << kUsageIdSizeBits) | 0x03;
-const uint32_t kUsageMonitorBrightness =
-    (mojom::kPageMonitor2 << kUsageIdSizeBits) | 0x10;
-const uint32_t kUsageMonitorContrast =
-    (mojom::kPageMonitor2 << kUsageIdSizeBits) | 0x12;
-const uint32_t kUsageMonitorRedVideoGain =
-    (mojom::kPageMonitor2 << kUsageIdSizeBits) | 0x16;
-const uint32_t kUsageMonitorGreenVideoGain =
-    (mojom::kPageMonitor2 << kUsageIdSizeBits) | 0x18;
-const uint32_t kUsageMonitorBlueVideoGain =
-    (mojom::kPageMonitor2 << kUsageIdSizeBits) | 0x1a;
-const uint32_t kUsageMonitorHorizontalPosition =
-    (mojom::kPageMonitor2 << kUsageIdSizeBits) | 0x20;
-const uint32_t kUsageMonitorHorizontalSize =
-    (mojom::kPageMonitor2 << kUsageIdSizeBits) | 0x22;
-const uint32_t kUsageMonitorVerticalPosition =
-    (mojom::kPageMonitor2 << kUsageIdSizeBits) | 0x30;
-const uint32_t kUsageMonitorVerticalSize =
-    (mojom::kPageMonitor2 << kUsageIdSizeBits) | 0x32;
-const uint32_t kUsageMonitorTrapezoidalDistortion =
-    (mojom::kPageMonitor2 << kUsageIdSizeBits) | 0x42;
-const uint32_t kUsageMonitorTilt =
-    (mojom::kPageMonitor2 << kUsageIdSizeBits) | 0x44;
-const uint32_t kUsageMonitorRedVideoBlackLevel =
-    (mojom::kPageMonitor2 << kUsageIdSizeBits) | 0x6c;
-const uint32_t kUsageMonitorGreenVideoBlackLevel =
-    (mojom::kPageMonitor2 << kUsageIdSizeBits) | 0x6e;
-const uint32_t kUsageMonitorBlueVideoBlackLevel =
-    (mojom::kPageMonitor2 << kUsageIdSizeBits) | 0x70;
-const uint32_t kUsagePidSetEffectReport =
-    (mojom::kPagePidPage << kUsageIdSizeBits) | 0x21;
-const uint32_t kUsagePidDuration =
-    (mojom::kPagePidPage << kUsageIdSizeBits) | 0x50;
-const uint32_t kUsagePidMagnitude =
-    (mojom::kPagePidPage << kUsageIdSizeBits) | 0x70;
-const uint32_t kUsagePidLoopCount =
-    (mojom::kPagePidPage << kUsageIdSizeBits) | 0x7c;
-const uint32_t kUsagePidDCEnableActuators =
-    (mojom::kPagePidPage << kUsageIdSizeBits) | 0x97;
-const uint32_t kUsagePidStartDelay =
-    (mojom::kPagePidPage << kUsageIdSizeBits) | 0xa7;
-const uint32_t kUsageSimulationAccelerator =
-    (mojom::kPageSimulation << kUsageIdSizeBits) | 0xc4;
-const uint32_t kUsageSimulationBrake =
-    (mojom::kPageSimulation << kUsageIdSizeBits) | 0xc5;
-const uint32_t kUsageVendor = mojom::kPageVendor << kUsageIdSizeBits;
-const uint32_t kUsageVendor02 = kPageVendor02 << kUsageIdSizeBits;
-const uint32_t kUsageVendor05 = kPageVendor05 << kUsageIdSizeBits;
-const uint32_t kUsageVendor80 = kPageVendor80 << kUsageIdSizeBits;
-
-// Report item tags.
-const HidReportDescriptorItem::Tag kInput = HidReportDescriptorItem::kTagInput;
-const HidReportDescriptorItem::Tag kOutput =
-    HidReportDescriptorItem::kTagOutput;
-const HidReportDescriptorItem::Tag kFeature =
-    HidReportDescriptorItem::kTagFeature;
-const uint32_t kCollectionTypeApplication =
-    mojom::kHIDCollectionTypeApplication;
-const uint32_t kCollectionTypeLogical = mojom::kHIDCollectionTypeLogical;
-const uint32_t kCollectionTypePhysical = mojom::kHIDCollectionTypePhysical;
-
-}  // namespace
-
 class HidReportDescriptorTest : public testing::Test {
  protected:
   using HidUsageAndPage = mojom::HidUsageAndPage;
   using HidCollectionInfo = mojom::HidCollectionInfo;
   using HidCollectionInfoPtr = mojom::HidCollectionInfoPtr;
 
-  void TearDown() override {
-    descriptor_ = nullptr;
-    expected_collection_infos_.clear();
-    expected_collections_.clear();
-    report_id_ = 0;
-    globals_ = HidItemStateTable::HidGlobalItemState();
-  }
-
- public:
-  // Add a top-level collection to |expected_collection_infos_|.
-  void AddTopCollectionInfo(HidCollectionInfoPtr collection_info) {
-    expected_collection_infos_.push_back(std::move(collection_info));
-  }
-
-  // Create a new collection and append it to |expected_collections_|.
-  HidCollection* AddTopCollection(uint32_t usage, uint32_t collection_type) {
-    uint16_t usage_page = (usage >> kUsageIdSizeBits) & kUsageIdMask;
-    usage = usage & kUsageIdMask;
-    expected_collections_.push_back(std::make_unique<HidCollection>(
-        nullptr, usage_page, usage, static_cast<uint32_t>(collection_type)));
-    return expected_collections_.back().get();
-  }
-
-  // Create a new collection as a child of |parent|.
-  HidCollection* AddChild(HidCollection* parent,
-                          uint32_t usage,
-                          uint32_t collection_type) {
-    uint16_t usage_page = (usage >> kUsageIdSizeBits) & kUsageIdMask;
-    usage = usage & kUsageIdMask;
-    parent->AddChildForTesting(std::make_unique<HidCollection>(
-        parent, usage_page, usage, static_cast<uint32_t>(collection_type)));
-    return parent->GetChildren().back().get();
-  }
-
-  // Set the |report_id|. Subsequent report items will be appended to the report
-  // with this ID.
-  void SetReportId(uint8_t report_id) { report_id_ = report_id; }
-
-  // Set the |unit| and |unit_exponent|. Subsequent report items will inherit
-  // these values.
-  void SetUnitAndUnitExponent(uint32_t unit, uint32_t unit_exponent) {
-    globals_.unit = unit;
-    globals_.unit_exponent = unit_exponent;
-  }
-
-  // Set the logical and physical minimums and maximums. Subsequent report items
-  // will inherit these values.
-  void SetLogicalAndPhysicalBounds(uint32_t logical_minimum,
-                                   uint32_t logical_maximum,
-                                   uint32_t physical_minimum,
-                                   uint32_t physical_maximum) {
-    globals_.logical_minimum = int32_t{logical_minimum};
-    globals_.logical_maximum = int32_t{logical_maximum};
-    globals_.physical_minimum = int32_t{physical_minimum};
-    globals_.physical_maximum = int32_t{physical_maximum};
-  }
-
-  // Set the |report_size| in bits, and the |report_count|. Subsequent report
-  // items will inherit these values.
-  void SetReportSizeAndCount(uint32_t report_size, uint32_t report_count) {
-    globals_.report_size = report_size;
-    globals_.report_count = report_count;
-  }
+  void SetUp() override { descriptor_ = nullptr; }
 
-  // Add a report item with a size and count but no usage value.
-  void AddReportConstant(HidCollection* collection,
-                         HidReportDescriptorItem::Tag tag,
-                         uint32_t report_info) {
-    HidItemStateTable state;
-    state.global_stack.push_back(globals_);
-    state.report_id = report_id_;
-    for (const HidCollection* c = collection; c; c = c->GetParent())
-      const_cast<HidCollection*>(c)->AddReportItem(tag, report_info, state);
+  void TearDown() override {
+    if (descriptor_) {
+      delete descriptor_;
   }
-
-  // Add a report item for one or more usages with the same size. The size of
-  // |usage_ids| is not required to be the same as the report count.
-  void AddReportItem(HidCollection* collection,
-                     HidReportDescriptorItem::Tag tag,
-                     uint32_t report_info,
-                     const std::vector<uint32_t>& usage_ids) {
-    HidItemStateTable state;
-    state.global_stack.push_back(globals_);
-    state.report_id = report_id_;
-    state.local.usages = usage_ids;
-    for (const HidCollection* c = collection; c; c = c->GetParent())
-      const_cast<HidCollection*>(c)->AddReportItem(tag, report_info, state);
-  }
-
-  // Add a report item for a range of usages. The item may be a variable or an
-  // array.
-  void AddReportItemRange(HidCollection* collection,
-                          HidReportDescriptorItem::Tag tag,
-                          uint32_t report_info,
-                          uint32_t usage_minimum,
-                          uint32_t usage_maximum) {
-    HidItemStateTable state;
-    state.global_stack.push_back(globals_);
-    state.report_id = report_id_;
-    state.local.usage_minimum = usage_minimum;
-    state.local.usage_maximum = usage_maximum;
-    for (const HidCollection* c = collection; c; c = c->GetParent())
-      const_cast<HidCollection*>(c)->AddReportItem(tag, report_info, state);
   }
 
+ public:
   void ValidateDetails(
+      const std::vector<HidCollectionInfoPtr>& expected_collection_infos,
       const bool expected_has_report_id,
       const size_t expected_max_input_report_size,
       const size_t expected_max_output_report_size,
       const size_t expected_max_feature_report_size,
       const uint8_t* bytes,
       size_t size) {
-    descriptor_ = std::make_unique<HidReportDescriptor>(
-        std::vector<uint8_t>(bytes, bytes + size));
+    descriptor_ =
+        new HidReportDescriptor(std::vector<uint8_t>(bytes, bytes + size));
+
     std::vector<HidCollectionInfoPtr> actual_collection_infos;
     bool actual_has_report_id;
     size_t actual_max_input_report_size;
@@ -334,11 +52,12 @@
                             &actual_max_output_report_size,
                             &actual_max_feature_report_size);
 
-    ASSERT_EQ(expected_collection_infos_.size(),
-              actual_collection_infos.size());
+    ASSERT_EQ(expected_collection_infos.size(), actual_collection_infos.size());
+
     auto actual_info_iter = actual_collection_infos.begin();
-    auto expected_info_iter = expected_collection_infos_.begin();
-    while (expected_info_iter != expected_collection_infos_.end() &&
+    auto expected_info_iter = expected_collection_infos.begin();
+
+    while (expected_info_iter != expected_collection_infos.end() &&
            actual_info_iter != actual_collection_infos.end()) {
       const HidCollectionInfoPtr& expected_info = *expected_info_iter;
       const HidCollectionInfoPtr& actual_info = *actual_info_iter;
@@ -350,1364 +71,180 @@
       ++expected_info_iter;
       ++actual_info_iter;
     }
+
     ASSERT_EQ(expected_has_report_id, actual_has_report_id);
     ASSERT_EQ(expected_max_input_report_size, actual_max_input_report_size);
     ASSERT_EQ(expected_max_output_report_size, actual_max_output_report_size);
     ASSERT_EQ(expected_max_feature_report_size, actual_max_feature_report_size);
   }
 
-  static void ValidateReportItem(const HidReportItem& expected,
-                                 const HidReportItem& actual) {
-    uint32_t expected_report_info =
-        *reinterpret_cast<const uint32_t*>(&expected.GetReportInfo());
-    uint32_t actual_report_info =
-        *reinterpret_cast<const uint32_t*>(&actual.GetReportInfo());
-    ASSERT_EQ(expected.GetTag(), actual.GetTag());
-    ASSERT_EQ(expected_report_info, actual_report_info);
-    ASSERT_EQ(expected.GetReportId(), actual.GetReportId());
-    ASSERT_THAT(actual.GetUsages(), testing::ContainerEq(expected.GetUsages()));
-    ASSERT_EQ(expected.GetUsageMinimum(), actual.GetUsageMinimum());
-    ASSERT_EQ(expected.GetUsageMaximum(), actual.GetUsageMaximum());
-    ASSERT_EQ(expected.GetDesignatorMinimum(), actual.GetDesignatorMinimum());
-    ASSERT_EQ(expected.GetDesignatorMaximum(), actual.GetDesignatorMaximum());
-    ASSERT_EQ(expected.GetStringMinimum(), actual.GetStringMinimum());
-    ASSERT_EQ(expected.GetStringMaximum(), actual.GetStringMaximum());
-    ASSERT_EQ(expected.GetLogicalMinimum(), actual.GetLogicalMinimum());
-    ASSERT_EQ(expected.GetLogicalMaximum(), actual.GetLogicalMaximum());
-    ASSERT_EQ(expected.GetPhysicalMinimum(), actual.GetPhysicalMinimum());
-    ASSERT_EQ(expected.GetPhysicalMaximum(), actual.GetPhysicalMaximum());
-    ASSERT_EQ(expected.GetUnitExponent(), actual.GetUnitExponent());
-    ASSERT_EQ(expected.GetUnit(), actual.GetUnit());
-    ASSERT_EQ(expected.GetReportSize(), actual.GetReportSize());
-    ASSERT_EQ(expected.GetReportCount(), actual.GetReportCount());
-  }
-
-  static void ValidateReportMap(const HidReportMap& expected_reports,
-                                const HidReportMap& actual_reports) {
-    for (const auto& expected_entry : expected_reports) {
-      auto find_it = actual_reports.find(expected_entry.first);
-      ASSERT_NE(find_it, actual_reports.end());
-      const auto& expected_report = expected_entry.second;
-      const auto& actual_report = find_it->second;
-      ASSERT_EQ(expected_report.size(), actual_report.size());
-      auto expected_item_iter = expected_report.begin();
-      auto actual_item_iter = actual_report.begin();
-      while (expected_item_iter != expected_report.end() &&
-             actual_item_iter != actual_report.end()) {
-        ValidateReportItem(**expected_item_iter, **actual_item_iter);
-        ++expected_item_iter;
-        ++actual_item_iter;
-      }
-    }
-    ASSERT_EQ(expected_reports.size(), actual_reports.size());
-  }
-
-  static void ValidateLinkCollection(const HidCollection* expected_collection,
-                                     const HidCollection* actual_collection) {
-    ASSERT_EQ(expected_collection->GetUsagePage(),
-              actual_collection->GetUsagePage());
-    ASSERT_EQ(expected_collection->GetUsage(), actual_collection->GetUsage());
-    ASSERT_EQ(expected_collection->GetCollectionType(),
-              actual_collection->GetCollectionType());
-    ValidateReportMap(expected_collection->GetInputReports(),
-                      actual_collection->GetInputReports());
-    ValidateReportMap(expected_collection->GetOutputReports(),
-                      actual_collection->GetOutputReports());
-    ValidateReportMap(expected_collection->GetFeatureReports(),
-                      actual_collection->GetFeatureReports());
-    const auto& expected_children = expected_collection->GetChildren();
-    const auto& actual_children = actual_collection->GetChildren();
-    auto expected_child_iter = expected_children.begin();
-    auto actual_child_iter = actual_children.begin();
-    while (expected_child_iter != expected_children.end() &&
-           actual_child_iter != actual_children.end()) {
-      const HidCollection* expected_child = expected_child_iter->get();
-      const HidCollection* actual_child = actual_child_iter->get();
-      ASSERT_EQ(actual_child->GetParent(), actual_collection);
-      ValidateLinkCollection(expected_child, actual_child);
-      ++expected_child_iter;
-      ++actual_child_iter;
-    }
-    ASSERT_EQ(expected_children.size(), actual_children.size());
-  }
-
-  void ValidateCollections(const uint8_t* bytes, size_t size) {
-    descriptor_ = std::make_unique<HidReportDescriptor>(
-        std::vector<uint8_t>(bytes, bytes + size));
-    const auto& actual_collections = descriptor_->collections();
-    auto actual_collection_iter = actual_collections.begin();
-    auto expected_collection_iter = expected_collections_.begin();
-    while (expected_collection_iter != expected_collections_.end() &&
-           actual_collection_iter != actual_collections.end()) {
-      ValidateLinkCollection(expected_collection_iter->get(),
-                             actual_collection_iter->get());
-      ++expected_collection_iter;
-      ++actual_collection_iter;
-    }
-    ASSERT_EQ(expected_collections_.size(), actual_collections.size());
-  }
-
  private:
-  std::unique_ptr<HidReportDescriptor> descriptor_;
-  std::vector<HidCollectionInfoPtr> expected_collection_infos_;
-  HidCollectionVector expected_collections_;
-  uint8_t report_id_ = 0;
-  HidItemStateTable::HidGlobalItemState globals_;
+  HidReportDescriptor* descriptor_;
 };
 
 TEST_F(HidReportDescriptorTest, ValidateDetails_Digitizer) {
+  const uint16_t usage_page = mojom::kPageDigitizer;
+  const uint16_t usage = 0x01;  // Digitizer
+
   auto digitizer = HidCollectionInfo::New();
-  digitizer->usage = HidUsageAndPage::New(0x01, mojom::kPageDigitizer);
-  ASSERT_EQ(IsProtected(*digitizer->usage), false);
+  digitizer->usage = HidUsageAndPage::New(usage, usage_page);
   digitizer->report_ids = {0x01, 0x02, 0x03};
-  AddTopCollectionInfo(std::move(digitizer));
-  ValidateDetails(true, 6, 0, 0, kDigitizer, kDigitizerSize);
-}
 
-TEST_F(HidReportDescriptorTest, ValidateCollections_Digitizer) {
-  auto* top =
-      AddTopCollection(kUsageDigitizerDigitizer, kCollectionTypeApplication);
-  auto* puck = AddChild(top, kUsageDigitizerPuck, kCollectionTypePhysical);
-  SetReportId(0x01);
-  SetLogicalAndPhysicalBounds(0, 12000, 0, 12);
-  SetUnitAndUnitExponent(kUnitInch, 0);
-  SetReportSizeAndCount(16, 2);
-  AddReportItem(puck, kInput, kAbsoluteVariable,
-                {kUsageGenericDesktopX, kUsageGenericDesktopY});
-  SetLogicalAndPhysicalBounds(0, 1, 0, 1);
-  SetUnitAndUnitExponent(0, 0);
-  SetReportSizeAndCount(1, 3);
-  AddReportItem(puck, kInput, kAbsoluteVariable,
-                {kUsageDigitizerInRange, kUsageDigitizerBarrelSwitch,
-                 kUsageDigitizerTipSwitch});
-  SetReportSizeAndCount(5, 1);
-  AddReportConstant(puck, kInput, kConstant);
-  SetReportId(0x02);
-  auto* stylus_up =
-      AddChild(top, kUsageDigitizerStylus, kCollectionTypePhysical);
-  SetLogicalAndPhysicalBounds(0, 12000, 0, 12);
-  SetUnitAndUnitExponent(kUnitInch, 0);
-  SetReportSizeAndCount(16, 2);
-  AddReportItem(stylus_up, kInput, kAbsoluteVariable,
-                {kUsageGenericDesktopX, kUsageGenericDesktopY});
-  SetLogicalAndPhysicalBounds(0, 1, 0, 1);
-  SetUnitAndUnitExponent(0, 0);
-  SetReportSizeAndCount(1, 2);
-  AddReportItem(stylus_up, kInput, kAbsoluteVariable, {kUsageDigitizerInRange});
-  SetLogicalAndPhysicalBounds(0, 16, 0, 1);
-  SetReportSizeAndCount(5, 2);
-  AddReportItemRange(stylus_up, kInput, kNullableArray, kUsageButton,
-                     kUsageButton + 16);
-  SetReportSizeAndCount(2, 2);
-  AddReportConstant(stylus_up, kInput, kConstantArray);
-  SetReportId(0x03);
-  auto* stylus_down =
-      AddChild(top, kUsageDigitizerStylus, kCollectionTypePhysical);
-  SetLogicalAndPhysicalBounds(0, 12000, 0, 12);
-  SetUnitAndUnitExponent(kUnitInch, 0);
-  SetReportSizeAndCount(16, 2);
-  AddReportItem(stylus_down, kInput, kAbsoluteVariable,
-                {kUsageGenericDesktopX, kUsageGenericDesktopY});
-  SetLogicalAndPhysicalBounds(0, 1, 0, 1);
-  SetUnitAndUnitExponent(0, 0);
-  SetReportSizeAndCount(1, 2);
-  AddReportItem(stylus_down, kInput, kAbsoluteVariable,
-                {kUsageDigitizerInRange, kUsageDigitizerBarrelSwitch});
-  SetReportSizeAndCount(1, 6);
-  AddReportConstant(stylus_down, kInput, kConstant);
-  SetLogicalAndPhysicalBounds(0, 127, 0, 45);
-  SetUnitAndUnitExponent(kUnitNewton, 4);
-  SetReportSizeAndCount(8, 1);
-  AddReportItem(stylus_down, kInput, kNonLinearVariable,
-                {kUsageDigitizerTipPressure});
-  ValidateCollections(kDigitizer, kDigitizerSize);
+  std::vector<HidCollectionInfoPtr> expected_infos;
+  expected_infos.push_back(std::move(digitizer));
+  ValidateDetails(expected_infos, true, 6, 0, 0, kDigitizer, kDigitizerSize);
 }
 
 TEST_F(HidReportDescriptorTest, ValidateDetails_Keyboard) {
+  const uint16_t usage_page = mojom::kPageGenericDesktop;
+  const uint16_t usage = mojom::kGenericDesktopKeyboard;
+
   auto keyboard = HidCollectionInfo::New();
-  keyboard->usage = HidUsageAndPage::New(mojom::kGenericDesktopKeyboard,
-                                         mojom::kPageGenericDesktop);
-  ASSERT_EQ(IsProtected(*keyboard->usage), true);
-  AddTopCollectionInfo(std::move(keyboard));
-  ValidateDetails(false, 8, 1, 0, kKeyboard, kKeyboardSize);
-}
+  keyboard->usage = HidUsageAndPage::New(usage, usage_page);
 
-TEST_F(HidReportDescriptorTest, ValidateCollections_Keyboard) {
-  auto* top = AddTopCollection(kUsageGenericDesktopKeyboard,
-                               kCollectionTypeApplication);
-  SetLogicalAndPhysicalBounds(0, 1, 0, 0);
-  SetReportSizeAndCount(1, 8);
-  AddReportItemRange(top, kInput, kAbsoluteVariable, kUsageKeyboardLeftControl,
-                     kUsageKeyboardRightGui);
-  SetReportSizeAndCount(8, 1);
-  AddReportConstant(top, kInput, kConstant);
-  SetReportSizeAndCount(1, 5);
-  AddReportItemRange(top, kOutput, kAbsoluteVariable, kUsageLedNumLock,
-                     kUsageLedKana);
-  SetReportSizeAndCount(3, 1);
-  AddReportConstant(top, kOutput, kConstant);
-  SetLogicalAndPhysicalBounds(0, 101, 0, 0);
-  SetReportSizeAndCount(8, 6);
-  AddReportItemRange(top, kInput, kNonNullableArray, kUsageKeyboard,
-                     kUsageKeyboardApplication);
-  ValidateCollections(kKeyboard, kKeyboardSize);
+  std::vector<HidCollectionInfoPtr> expected_infos;
+  expected_infos.push_back(std::move(keyboard));
+  ValidateDetails(expected_infos, false, 8, 1, 0, kKeyboard, kKeyboardSize);
 }
 
 TEST_F(HidReportDescriptorTest, ValidateDetails_Monitor) {
+  const uint16_t usage_page = mojom::kPageMonitor0;  // USB monitor
+  const uint16_t usage = 0x01;                       // Monitor control
+
   auto monitor = HidCollectionInfo::New();
-  monitor->usage = HidUsageAndPage::New(0x01, mojom::kPageMonitor0);
-  ASSERT_EQ(IsProtected(*monitor->usage), false);
-  monitor->report_ids = {0x01, 0x02, 0x03, 0x04, 0x05};
-  AddTopCollectionInfo(std::move(monitor));
-  ValidateDetails(true, 0, 0, 243, kMonitor, kMonitorSize);
-}
+  monitor->usage = HidUsageAndPage::New(usage, usage_page);
+  monitor->report_ids = {1, 2, 3, 4, 5};
 
-TEST_F(HidReportDescriptorTest, ValidateCollections_Monitor) {
-  auto* top =
-      AddTopCollection(kUsageMonitorControl, kCollectionTypeApplication);
-  SetReportId(0x01);
-  SetLogicalAndPhysicalBounds(0, 255, 0, 0);
-  SetReportSizeAndCount(8, 128);
-  AddReportItem(top, kFeature, kBufferedBytes, {kUsageMonitorEdidInfo});
-  SetReportId(0x02);
-  SetReportSizeAndCount(8, 243);
-  AddReportItem(top, kFeature, kBufferedBytes, {kUsageMonitorVdifInfo});
-  SetReportId(0x03);
-  SetUnitAndUnitExponent(kUnitCandela, 0x0e);
-  SetReportSizeAndCount(16, 1);
-  SetLogicalAndPhysicalBounds(0, 200, 0, 0);
-  AddReportItem(top, kFeature, kAbsoluteVariable, {kUsageMonitorBrightness});
-  SetReportId(0x04);
-  SetLogicalAndPhysicalBounds(0, 100, 0, 0);
-  AddReportItem(top, kFeature, kAbsoluteVariable, {kUsageMonitorContrast});
-  SetReportSizeAndCount(16, 6);
-  SetLogicalAndPhysicalBounds(0, 255, 0, 0);
-  AddReportItem(
-      top, kFeature, kAbsoluteVariable,
-      {kUsageMonitorRedVideoGain, kUsageMonitorGreenVideoGain,
-       kUsageMonitorBlueVideoGain, kUsageMonitorRedVideoBlackLevel,
-       kUsageMonitorGreenVideoBlackLevel, kUsageMonitorBlueVideoBlackLevel});
-  SetReportId(0x05);
-  SetLogicalAndPhysicalBounds(0, 127, 0, 0);
-  AddReportItem(top, kFeature, kAbsoluteVariable,
-                {kUsageMonitorHorizontalPosition, kUsageMonitorHorizontalSize,
-                 kUsageMonitorVerticalPosition, kUsageMonitorVerticalSize,
-                 kUsageMonitorTrapezoidalDistortion, kUsageMonitorTilt});
-  ValidateCollections(kMonitor, kMonitorSize);
+  std::vector<HidCollectionInfoPtr> expected_infos;
+  expected_infos.push_back(std::move(monitor));
+  ValidateDetails(expected_infos, true, 0, 0, 243, kMonitor, kMonitorSize);
 }
 
 TEST_F(HidReportDescriptorTest, ValidateDetails_Mouse) {
+  const uint16_t usage_page = mojom::kPageGenericDesktop;
+  const uint16_t usage = mojom::kGenericDesktopMouse;
+
   auto mouse = HidCollectionInfo::New();
-  mouse->usage = HidUsageAndPage::New(mojom::kGenericDesktopMouse,
-                                      mojom::kPageGenericDesktop);
-  ASSERT_EQ(IsProtected(*mouse->usage), true);
-  AddTopCollectionInfo(std::move(mouse));
-  ValidateDetails(false, 3, 0, 0, kMouse, kMouseSize);
-}
+  mouse->usage = HidUsageAndPage::New(usage, usage_page);
 
-TEST_F(HidReportDescriptorTest, ValidateCollections_Mouse) {
-  auto* top =
-      AddTopCollection(kUsageGenericDesktopMouse, kCollectionTypeApplication);
-  auto* physical =
-      AddChild(top, kUsageGenericDesktopPointer, kCollectionTypePhysical);
-  SetLogicalAndPhysicalBounds(0, 1, 0, 0);
-  SetReportSizeAndCount(1, 3);
-  AddReportItemRange(physical, kInput, kAbsoluteVariable, kUsageButton + 1,
-                     kUsageButton + 3);
-  SetReportSizeAndCount(5, 1);
-  AddReportConstant(physical, kInput, kConstant);
-  SetLogicalAndPhysicalBounds(0x81, 0x7f, 0, 0);
-  SetReportSizeAndCount(8, 2);
-  AddReportItem(physical, kInput, kRelativeVariable,
-                {kUsageGenericDesktopX, kUsageGenericDesktopY});
-  ValidateCollections(kMouse, kMouseSize);
+  std::vector<HidCollectionInfoPtr> expected_infos;
+  expected_infos.push_back(std::move(mouse));
+  ValidateDetails(expected_infos, false, 3, 0, 0, kMouse, kMouseSize);
 }
 
 TEST_F(HidReportDescriptorTest, ValidateDetails_LogitechUnifyingReceiver) {
+  const uint16_t usage_page = mojom::kPageVendor;
+  const uint16_t usage_hidpp_short = 0x01;  // Vendor-defined
+  const uint16_t usage_hidpp_long = 0x02;   // Vendor-defined
+  const uint16_t usage_hidpp_dj = 0x04;     // Vendor-defined
+
   auto hidpp_short = HidCollectionInfo::New();
-  hidpp_short->usage = HidUsageAndPage::New(0x01, mojom::kPageVendor);
-  ASSERT_EQ(IsProtected(*hidpp_short->usage), false);
+  hidpp_short->usage = HidUsageAndPage::New(usage_hidpp_short, usage_page);
   hidpp_short->report_ids = {0x10};
   auto hidpp_long = HidCollectionInfo::New();
-  hidpp_long->usage = HidUsageAndPage::New(0x02, mojom::kPageVendor);
-  ASSERT_EQ(IsProtected(*hidpp_long->usage), false);
+  hidpp_long->usage = HidUsageAndPage::New(usage_hidpp_long, usage_page);
   hidpp_long->report_ids = {0x11};
   auto hidpp_dj = HidCollectionInfo::New();
-  hidpp_dj->usage = HidUsageAndPage::New(0x04, mojom::kPageVendor);
-  ASSERT_EQ(IsProtected(*hidpp_dj->usage), false);
+  hidpp_dj->usage = HidUsageAndPage::New(usage_hidpp_dj, usage_page);
   hidpp_dj->report_ids = {0x20, 0x21};
-  AddTopCollectionInfo(std::move(hidpp_short));
-  AddTopCollectionInfo(std::move(hidpp_long));
-  AddTopCollectionInfo(std::move(hidpp_dj));
-  ValidateDetails(true, 31, 31, 0, kLogitechUnifyingReceiver,
-                  kLogitechUnifyingReceiverSize);
-}
 
-TEST_F(HidReportDescriptorTest, ValidateCollections_LogitechUnifyingReceiver) {
-  auto* short_collection =
-      AddTopCollection(kUsageVendor + 0x01, kCollectionTypeApplication);
-  SetReportId(0x10);
-  SetLogicalAndPhysicalBounds(0, 255, 0, 0);
-  SetReportSizeAndCount(8, 6);
-  AddReportItem(short_collection, kInput, kNonNullableArray,
-                {kUsageVendor + 0x01});
-  AddReportItem(short_collection, kOutput, kNonNullableArray,
-                {kUsageVendor + 0x01});
-  auto* long_collection =
-      AddTopCollection(kUsageVendor + 0x02, kCollectionTypeApplication);
-  SetReportId(0x11);
-  SetReportSizeAndCount(8, 19);
-  AddReportItem(long_collection, kInput, kNonNullableArray,
-                {kUsageVendor + 0x02});
-  AddReportItem(long_collection, kOutput, kNonNullableArray,
-                {kUsageVendor + 0x02});
-  auto* dj_collection =
-      AddTopCollection(kUsageVendor + 0x04, kCollectionTypeApplication);
-  SetReportId(0x20);
-  SetReportSizeAndCount(8, 14);
-  AddReportItem(dj_collection, kInput, kNonNullableArray,
-                {kUsageVendor + 0x41});
-  AddReportItem(dj_collection, kOutput, kNonNullableArray,
-                {kUsageVendor + 0x41});
-  SetReportId(0x21);
-  SetReportSizeAndCount(8, 31);
-  AddReportItem(dj_collection, kInput, kNonNullableArray,
-                {kUsageVendor + 0x42});
-  AddReportItem(dj_collection, kOutput, kNonNullableArray,
-                {kUsageVendor + 0x42});
-  ValidateCollections(kLogitechUnifyingReceiver, kLogitechUnifyingReceiverSize);
+  std::vector<HidCollectionInfoPtr> expected_infos;
+  expected_infos.push_back(std::move(hidpp_short));
+  expected_infos.push_back(std::move(hidpp_long));
+  expected_infos.push_back(std::move(hidpp_dj));
+  ValidateDetails(expected_infos, true, 31, 31, 0, kLogitechUnifyingReceiver,
+                  kLogitechUnifyingReceiverSize);
 }
 
 TEST_F(HidReportDescriptorTest, ValidateDetails_SonyDualshock3) {
+  const uint16_t usage_page = mojom::kPageGenericDesktop;
+  const uint16_t usage = mojom::kGenericDesktopJoystick;
+
   auto top_info = HidCollectionInfo::New();
-  top_info->usage = HidUsageAndPage::New(mojom::kGenericDesktopJoystick,
-                                         mojom::kPageGenericDesktop);
-  ASSERT_EQ(IsProtected(*top_info->usage), false);
+  top_info->usage = HidUsageAndPage::New(usage, usage_page);
   top_info->report_ids = {0x01, 0x02, 0xee, 0xef};
-  AddTopCollectionInfo(std::move(top_info));
-  ValidateDetails(true, 48, 48, 48, kSonyDualshock3, kSonyDualshock3Size);
-}
 
-TEST_F(HidReportDescriptorTest, ValidateCollections_SonyDualshock3) {
-  auto* top = AddTopCollection(kUsageGenericDesktopJoystick,
-                               kCollectionTypeApplication);
-  auto* joystick = AddChild(top, kUsageGenericDesktop, kCollectionTypeLogical);
-  SetReportId(0x01);
-  SetLogicalAndPhysicalBounds(0, 255, 0, 0);
-  SetReportSizeAndCount(8, 1);
-  AddReportConstant(joystick, kInput, kConstant);
-  SetLogicalAndPhysicalBounds(0, 1, 0, 1);
-  SetReportSizeAndCount(1, 19);
-  AddReportItemRange(joystick, kInput, kAbsoluteVariable, kUsageButton + 1,
-                     kUsageButton + 19);
-  SetReportSizeAndCount(1, 13);
-  AddReportConstant(joystick, kInput, kConstant);
-  auto* stick_axes =
-      AddChild(joystick, kUsageGenericDesktopPointer, kCollectionTypePhysical);
-  SetLogicalAndPhysicalBounds(0, 255, 0, 255);
-  SetReportSizeAndCount(8, 4);
-  AddReportItem(stick_axes, kInput, kAbsoluteVariable,
-                {kUsageGenericDesktopX, kUsageGenericDesktopY,
-                 kUsageGenericDesktopZ, kUsageGenericDesktopRz});
-  SetReportSizeAndCount(8, 39);
-  AddReportItem(joystick, kInput, kAbsoluteVariable,
-                {kUsageGenericDesktopPointer});
-  SetReportSizeAndCount(8, 48);
-  AddReportItem(joystick, kOutput, kAbsoluteVariable,
-                {kUsageGenericDesktopPointer});
-  AddReportItem(joystick, kFeature, kAbsoluteVariable,
-                {kUsageGenericDesktopPointer});
-  auto* report_02_collection =
-      AddChild(top, kUsageGenericDesktop, kCollectionTypeLogical);
-  SetReportId(0x02);
-  AddReportItem(report_02_collection, kFeature, kAbsoluteVariable,
-                {kUsageGenericDesktopPointer});
-  auto* report_ee_collection =
-      AddChild(top, kUsageGenericDesktop, kCollectionTypeLogical);
-  SetReportId(0xee);
-  AddReportItem(report_ee_collection, kFeature, kAbsoluteVariable,
-                {kUsageGenericDesktopPointer});
-  auto* report_ef_collection =
-      AddChild(top, kUsageGenericDesktop, kCollectionTypeLogical);
-  SetReportId(0xef);
-  AddReportItem(report_ef_collection, kFeature, kAbsoluteVariable,
-                {kUsageGenericDesktopPointer});
-  ValidateCollections(kSonyDualshock3, kSonyDualshock3Size);
+  std::vector<HidCollectionInfoPtr> expected_infos;
+  expected_infos.push_back(std::move(top_info));
+  ValidateDetails(expected_infos, true, 48, 48, 48, kSonyDualshock3,
+                  kSonyDualshock3Size);
 }
 
 TEST_F(HidReportDescriptorTest, ValidateDetails_SonyDualshock4) {
+  const uint16_t usage_page = mojom::kPageGenericDesktop;
+  const uint16_t usage = mojom::kGenericDesktopGamePad;
+
   auto top_info = HidCollectionInfo::New();
-  top_info->usage = HidUsageAndPage::New(mojom::kGenericDesktopGamePad,
-                                         mojom::kPageGenericDesktop);
-  ASSERT_EQ(IsProtected(*top_info->usage), false);
+  top_info->usage = HidUsageAndPage::New(usage, usage_page);
   top_info->report_ids = {0x01, 0x05, 0x04, 0x02, 0x08, 0x10, 0x11, 0x12, 0x13,
                           0x14, 0x15, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86,
                           0x87, 0x88, 0x89, 0x90, 0x91, 0x92, 0x93, 0xa0, 0xa1,
                           0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xf0, 0xf1, 0xf2, 0xa7,
                           0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0};
-  AddTopCollectionInfo(std::move(top_info));
-  ValidateDetails(true, 63, 31, 63, kSonyDualshock4, kSonyDualshock4Size);
-}
 
-TEST_F(HidReportDescriptorTest, ValidateCollections_SonyDualshock4) {
-  auto* top =
-      AddTopCollection(kUsageGenericDesktopGamePad, kCollectionTypeApplication);
-  SetReportId(0x01);
-  SetLogicalAndPhysicalBounds(0, 255, 0, 0);
-  SetReportSizeAndCount(8, 4);
-  AddReportItem(top, kInput, kAbsoluteVariable,
-                {kUsageGenericDesktopX, kUsageGenericDesktopY,
-                 kUsageGenericDesktopZ, kUsageGenericDesktopRz});
-  SetLogicalAndPhysicalBounds(0, 7, 0, 315);
-  SetUnitAndUnitExponent(kUnitDegrees, 0);
-  SetReportSizeAndCount(4, 1);
-  AddReportItem(top, kInput, kNullableAbsoluteVariable,
-                {kUsageGenericDesktopHatSwitch});
-  SetLogicalAndPhysicalBounds(0, 1, 0, 315);
-  SetUnitAndUnitExponent(0, 0);
-  SetReportSizeAndCount(1, 14);
-  AddReportItemRange(top, kInput, kAbsoluteVariable, kUsageButton + 1,
-                     kUsageButton + 14);
-  SetLogicalAndPhysicalBounds(0, 127, 0, 315);
-  SetReportSizeAndCount(6, 1);
-  AddReportItem(top, kInput, kAbsoluteVariable, {kUsageVendor + 0x20});
-  SetLogicalAndPhysicalBounds(0, 255, 0, 315);
-  SetReportSizeAndCount(8, 2);
-  AddReportItem(top, kInput, kAbsoluteVariable,
-                {kUsageGenericDesktopRx, kUsageGenericDesktopRy});
-  SetReportSizeAndCount(8, 54);
-  AddReportItem(top, kInput, kAbsoluteVariable, {kUsageVendor + 0x21});
-  SetReportId(0x05);
-  SetReportSizeAndCount(8, 31);
-  AddReportItem(top, kOutput, kAbsoluteVariable, {kUsageVendor + 0x22});
-  SetReportId(0x04);
-  SetReportSizeAndCount(8, 36);
-  AddReportItem(top, kFeature, kAbsoluteVariable, {kUsageVendor + 0x23});
-  SetReportId(0x02);
-  AddReportItem(top, kFeature, kAbsoluteVariable, {kUsageVendor + 0x24});
-  SetReportId(0x08);
-  SetReportSizeAndCount(8, 3);
-  AddReportItem(top, kFeature, kAbsoluteVariable, {kUsageVendor + 0x25});
-  SetReportId(0x10);
-  SetReportSizeAndCount(8, 4);
-  AddReportItem(top, kFeature, kAbsoluteVariable, {kUsageVendor + 0x26});
-  SetReportId(0x11);
-  SetReportSizeAndCount(8, 2);
-  AddReportItem(top, kFeature, kAbsoluteVariable, {kUsageVendor + 0x27});
-  SetReportId(0x12);
-  SetReportSizeAndCount(8, 15);
-  AddReportItem(top, kFeature, kAbsoluteVariable, {kUsageVendor02 + 0x21});
-  SetReportId(0x13);
-  SetReportSizeAndCount(8, 22);
-  AddReportItem(top, kFeature, kAbsoluteVariable, {kUsageVendor02 + 0x22});
-  SetReportId(0x14);
-  SetReportSizeAndCount(8, 16);
-  AddReportItem(top, kFeature, kAbsoluteVariable, {kUsageVendor05 + 0x20});
-  SetReportId(0x15);
-  SetReportSizeAndCount(8, 44);
-  AddReportItem(top, kFeature, kAbsoluteVariable, {kUsageVendor05 + 0x21});
-  SetReportId(0x80);
-  SetReportSizeAndCount(8, 6);
-  AddReportItem(top, kFeature, kAbsoluteVariable, {kUsageVendor80 + 0x20});
-  SetReportId(0x81);
-  AddReportItem(top, kFeature, kAbsoluteVariable, {kUsageVendor80 + 0x21});
-  SetReportId(0x82);
-  SetReportSizeAndCount(8, 5);
-  AddReportItem(top, kFeature, kAbsoluteVariable, {kUsageVendor80 + 0x22});
-  SetReportId(0x83);
-  SetReportSizeAndCount(8, 1);
-  AddReportItem(top, kFeature, kAbsoluteVariable, {kUsageVendor80 + 0x23});
-  SetReportId(0x84);
-  SetReportSizeAndCount(8, 4);
-  AddReportItem(top, kFeature, kAbsoluteVariable, {kUsageVendor80 + 0x24});
-  SetReportId(0x85);
-  SetReportSizeAndCount(8, 6);
-  AddReportItem(top, kFeature, kAbsoluteVariable, {kUsageVendor80 + 0x25});
-  SetReportId(0x86);
-  AddReportItem(top, kFeature, kAbsoluteVariable, {kUsageVendor80 + 0x26});
-  SetReportId(0x87);
-  SetReportSizeAndCount(8, 35);
-  AddReportItem(top, kFeature, kAbsoluteVariable, {kUsageVendor80 + 0x27});
-  SetReportId(0x88);
-  SetReportSizeAndCount(8, 34);
-  AddReportItem(top, kFeature, kAbsoluteVariable, {kUsageVendor80 + 0x28});
-  SetReportId(0x89);
-  SetReportSizeAndCount(8, 2);
-  AddReportItem(top, kFeature, kAbsoluteVariable, {kUsageVendor80 + 0x29});
-  SetReportId(0x90);
-  SetReportSizeAndCount(8, 5);
-  AddReportItem(top, kFeature, kAbsoluteVariable, {kUsageVendor80 + 0x30});
-  SetReportId(0x91);
-  SetReportSizeAndCount(8, 3);
-  AddReportItem(top, kFeature, kAbsoluteVariable, {kUsageVendor80 + 0x31});
-  SetReportId(0x92);
-  AddReportItem(top, kFeature, kAbsoluteVariable, {kUsageVendor80 + 0x32});
-  SetReportId(0x93);
-  SetReportSizeAndCount(8, 12);
-  AddReportItem(top, kFeature, kAbsoluteVariable, {kUsageVendor80 + 0x33});
-  SetReportId(0xa0);
-  SetReportSizeAndCount(8, 6);
-  AddReportItem(top, kFeature, kAbsoluteVariable, {kUsageVendor80 + 0x40});
-  SetReportId(0xa1);
-  SetReportSizeAndCount(8, 1);
-  AddReportItem(top, kFeature, kAbsoluteVariable, {kUsageVendor80 + 0x41});
-  SetReportId(0xa2);
-  AddReportItem(top, kFeature, kAbsoluteVariable, {kUsageVendor80 + 0x42});
-  SetReportId(0xa3);
-  SetReportSizeAndCount(8, 48);
-  AddReportItem(top, kFeature, kAbsoluteVariable, {kUsageVendor80 + 0x43});
-  SetReportId(0xa4);
-  SetReportSizeAndCount(8, 13);
-  AddReportItem(top, kFeature, kAbsoluteVariable, {kUsageVendor80 + 0x44});
-  SetReportId(0xa5);
-  SetReportSizeAndCount(8, 21);
-  AddReportItem(top, kFeature, kAbsoluteVariable, {kUsageVendor80 + 0x45});
-  SetReportId(0xa6);
-  AddReportItem(top, kFeature, kAbsoluteVariable, {kUsageVendor80 + 0x46});
-  SetReportId(0xf0);
-  SetReportSizeAndCount(8, 63);
-  AddReportItem(top, kFeature, kAbsoluteVariable, {kUsageVendor80 + 0x47});
-  SetReportId(0xf1);
-  AddReportItem(top, kFeature, kAbsoluteVariable, {kUsageVendor80 + 0x48});
-  SetReportId(0xf2);
-  SetReportSizeAndCount(8, 15);
-  AddReportItem(top, kFeature, kAbsoluteVariable, {kUsageVendor80 + 0x49});
-  SetReportId(0xa7);
-  SetReportSizeAndCount(8, 1);
-  AddReportItem(top, kFeature, kAbsoluteVariable, {kUsageVendor80 + 0x4a});
-  SetReportId(0xa8);
-  AddReportItem(top, kFeature, kAbsoluteVariable, {kUsageVendor80 + 0x4b});
-  SetReportId(0xa9);
-  SetReportSizeAndCount(8, 8);
-  AddReportItem(top, kFeature, kAbsoluteVariable, {kUsageVendor80 + 0x4c});
-  SetReportId(0xaa);
-  SetReportSizeAndCount(8, 1);
-  AddReportItem(top, kFeature, kAbsoluteVariable, {kUsageVendor80 + 0x4e});
-  SetReportId(0xab);
-  SetReportSizeAndCount(8, 57);
-  AddReportItem(top, kFeature, kAbsoluteVariable, {kUsageVendor80 + 0x4f});
-  SetReportId(0xac);
-  AddReportItem(top, kFeature, kAbsoluteVariable, {kUsageVendor80 + 0x50});
-  SetReportId(0xad);
-  SetReportSizeAndCount(8, 11);
-  AddReportItem(top, kFeature, kAbsoluteVariable, {kUsageVendor80 + 0x51});
-  SetReportId(0xae);
-  SetReportSizeAndCount(8, 1);
-  AddReportItem(top, kFeature, kAbsoluteVariable, {kUsageVendor80 + 0x52});
-  SetReportId(0xaf);
-  SetReportSizeAndCount(8, 2);
-  AddReportItem(top, kFeature, kAbsoluteVariable, {kUsageVendor80 + 0x53});
-  SetReportId(0xb0);
-  SetReportSizeAndCount(8, 63);
-  AddReportItem(top, kFeature, kAbsoluteVariable, {kUsageVendor80 + 0x54});
-  ValidateCollections(kSonyDualshock4, kSonyDualshock4Size);
+  std::vector<HidCollectionInfoPtr> expected_infos;
+  expected_infos.push_back(std::move(top_info));
+  ValidateDetails(expected_infos, true, 63, 31, 63, kSonyDualshock4,
+                  kSonyDualshock4Size);
 }
 
 TEST_F(HidReportDescriptorTest, ValidateDetails_XboxWirelessController) {
+  const uint16_t usage_page = mojom::kPageGenericDesktop;
+  const uint16_t usage = mojom::kGenericDesktopGamePad;
+
   auto top_info = HidCollectionInfo::New();
-  top_info->usage = HidUsageAndPage::New(mojom::kGenericDesktopGamePad,
-                                         mojom::kPageGenericDesktop);
-  ASSERT_EQ(IsProtected(*top_info->usage), false);
+  top_info->usage = HidUsageAndPage::New(usage, usage_page);
   top_info->report_ids = {0x01, 0x02, 0x03, 0x04};
-  AddTopCollectionInfo(std::move(top_info));
-  ValidateDetails(true, 15, 8, 0, kMicrosoftXboxWirelessController,
-                  kMicrosoftXboxWirelessControllerSize);
-}
 
-TEST_F(HidReportDescriptorTest, ValidateCollections_XboxWirelessController) {
-  auto* top =
-      AddTopCollection(kUsageGenericDesktopGamePad, kCollectionTypeApplication);
-  SetReportId(0x01);
-  auto* left_stick =
-      AddChild(top, kUsageGenericDesktopPointer, kCollectionTypePhysical);
-  SetLogicalAndPhysicalBounds(0, 0xffff, 0, 0);
-  SetReportSizeAndCount(16, 2);
-  AddReportItem(left_stick, kInput, kAbsoluteVariable,
-                {kUsageGenericDesktopX, kUsageGenericDesktopY});
-  auto* right_stick =
-      AddChild(top, kUsageGenericDesktopPointer, kCollectionTypePhysical);
-  SetLogicalAndPhysicalBounds(0, 0xffff, 0, 0);
-  AddReportItem(right_stick, kInput, kAbsoluteVariable,
-                {kUsageGenericDesktopRx, kUsageGenericDesktopRy});
-  SetLogicalAndPhysicalBounds(0, 1023, 0, 0);
-  SetReportSizeAndCount(10, 1);
-  AddReportItem(top, kInput, kAbsoluteVariable, {kUsageGenericDesktopZ});
-  SetLogicalAndPhysicalBounds(0, 0, 0, 0);
-  SetReportSizeAndCount(6, 1);
-  AddReportConstant(top, kInput, kConstant);
-  SetLogicalAndPhysicalBounds(0, 1023, 0, 0);
-  SetReportSizeAndCount(10, 1);
-  AddReportItem(top, kInput, kAbsoluteVariable, {kUsageGenericDesktopRz});
-  SetLogicalAndPhysicalBounds(0, 0, 0, 0);
-  SetReportSizeAndCount(6, 1);
-  AddReportConstant(top, kInput, kConstant);
-  SetLogicalAndPhysicalBounds(1, 8, 0, 315);
-  SetUnitAndUnitExponent(kUnitDegrees, 0);
-  SetReportSizeAndCount(4, 1);
-  AddReportItem(top, kInput, kNullableAbsoluteVariable,
-                {kUsageGenericDesktopHatSwitch});
-  SetLogicalAndPhysicalBounds(0, 0, 0, 0);
-  SetUnitAndUnitExponent(0, 0);
-  AddReportConstant(top, kInput, kConstant);
-  SetLogicalAndPhysicalBounds(0, 1, 0, 0);
-  SetReportSizeAndCount(1, 10);
-  AddReportItemRange(top, kInput, kAbsoluteVariable, kUsageButton + 1,
-                     kUsageButton + 10);
-  SetLogicalAndPhysicalBounds(0, 0, 0, 0);
-  SetReportSizeAndCount(6, 1);
-  AddReportConstant(top, kInput, kConstant);
-  SetReportId(0x02);
-  auto* mode_collection =
-      AddChild(top, kUsageGenericDesktopSystemControl, kCollectionTypePhysical);
-  SetLogicalAndPhysicalBounds(0, 1, 0, 0);
-  SetReportSizeAndCount(1, 1);
-  AddReportItem(mode_collection, kInput, kAbsoluteVariable,
-                {kUsageGenericDesktopSystemMainMenu});
-  SetLogicalAndPhysicalBounds(0, 0, 0, 0);
-  SetReportSizeAndCount(7, 1);
-  AddReportConstant(mode_collection, kInput, kConstant);
-  SetReportId(0x03);
-  auto* pid_collection =
-      AddChild(top, kUsagePidSetEffectReport, kCollectionTypeLogical);
-  SetLogicalAndPhysicalBounds(0, 1, 0, 0);
-  SetReportSizeAndCount(4, 1);
-  AddReportItem(pid_collection, kOutput, kAbsoluteVariable,
-                {kUsagePidDCEnableActuators});
-  SetLogicalAndPhysicalBounds(0, 0, 0, 0);
-  AddReportConstant(pid_collection, kOutput, kConstant);
-  SetLogicalAndPhysicalBounds(0, 100, 0, 0);
-  SetReportSizeAndCount(8, 4);
-  AddReportItem(pid_collection, kOutput, kAbsoluteVariable,
-                {kUsagePidMagnitude});
-  SetLogicalAndPhysicalBounds(0, 255, 0, 0);
-  SetUnitAndUnitExponent(kUnitSecond, 0x0e);
-  SetReportSizeAndCount(8, 1);
-  AddReportItem(pid_collection, kOutput, kAbsoluteVariable,
-                {kUsagePidDuration});
-  AddReportItem(pid_collection, kOutput, kAbsoluteVariable,
-                {kUsagePidStartDelay});
-  SetUnitAndUnitExponent(0, 0);
-  AddReportItem(pid_collection, kOutput, kAbsoluteVariable,
-                {kUsagePidLoopCount});
-  SetReportId(0x04);
-  AddReportItem(top, kInput, kAbsoluteVariable,
-                {kUsageGenericDeviceBatteryStrength});
-  ValidateCollections(kMicrosoftXboxWirelessController,
+  std::vector<HidCollectionInfoPtr> expected_info;
+  expected_info.push_back(std::move(top_info));
+  ValidateDetails(expected_info, true, 15, 8, 0,
+                  kMicrosoftXboxWirelessController,
                       kMicrosoftXboxWirelessControllerSize);
 }
 
 TEST_F(HidReportDescriptorTest, ValidateDetails_NintendoSwitchProController) {
+  const uint16_t usage_page = mojom::kPageGenericDesktop;
+  const uint16_t usage = mojom::kGenericDesktopJoystick;
+
   auto top_info = HidCollectionInfo::New();
-  top_info->usage = HidUsageAndPage::New(mojom::kGenericDesktopJoystick,
-                                         mojom::kPageGenericDesktop);
-  ASSERT_EQ(IsProtected(*top_info->usage), false);
+  top_info->usage = HidUsageAndPage::New(usage, usage_page);
   top_info->report_ids = {0x30, 0x21, 0x81, 0x01, 0x10, 0x80, 0x82};
-  AddTopCollectionInfo(std::move(top_info));
-  ValidateDetails(true, 63, 63, 0, kNintendoSwitchProController,
-                  kNintendoSwitchProControllerSize);
-}
 
-TEST_F(HidReportDescriptorTest,
-       ValidateCollections_NintendoSwitchProController) {
-  auto* top = AddTopCollection(kUsageGenericDesktopJoystick,
-                               kCollectionTypeApplication);
-  SetReportId(0x30);
-  SetLogicalAndPhysicalBounds(0, 1, 0, 0);
-  SetUnitAndUnitExponent(0, 0);
-  SetReportSizeAndCount(1, 10);
-  AddReportItemRange(top, kInput, kAbsoluteVariable, kUsageButton + 1,
-                     kUsageButton + 10);
-  SetReportSizeAndCount(1, 4);
-  AddReportItemRange(top, kInput, kAbsoluteVariable, kUsageButton + 11,
-                     kUsageButton + 14);
-  SetReportSizeAndCount(1, 2);
-  AddReportConstant(top, kInput, kConstant);
-  auto* stick_axes =
-      AddChild(top, kUsageGenericDesktopPointer, kCollectionTypePhysical);
-  SetLogicalAndPhysicalBounds(0, 0xffff, 0, 0);
-  SetReportSizeAndCount(16, 4);
-  AddReportItem(stick_axes, kInput, kAbsoluteVariable,
-                {kUsageGenericDesktopX, kUsageGenericDesktopY,
-                 kUsageGenericDesktopZ, kUsageGenericDesktopRz});
-  SetLogicalAndPhysicalBounds(0, 7, 0, 315);
-  SetUnitAndUnitExponent(kUnitDegrees, 0);
-  SetReportSizeAndCount(4, 1);
-  AddReportItem(top, kInput, kAbsoluteVariable,
-                {kUsageGenericDesktopHatSwitch});
-  SetLogicalAndPhysicalBounds(0, 1, 0, 315);
-  SetReportSizeAndCount(1, 4);
-  AddReportItemRange(top, kInput, kAbsoluteVariable, kUsageButton + 15,
-                     kUsageButton + 18);
-  SetReportSizeAndCount(8, 52);
-  AddReportConstant(top, kInput, kConstant);
-  SetReportId(0x21);
-  SetReportSizeAndCount(8, 63);
-  AddReportItem(top, kInput, kConstant, {kUsageVendor + 0x01});
-  SetReportId(0x81);
-  AddReportItem(top, kInput, kConstant, {kUsageVendor + 0x02});
-  SetReportId(0x01);
-  AddReportItem(top, kOutput, kVolatileConstant, {kUsageVendor + 0x03});
-  SetReportId(0x10);
-  AddReportItem(top, kOutput, kVolatileConstant, {kUsageVendor + 0x04});
-  SetReportId(0x80);
-  AddReportItem(top, kOutput, kVolatileConstant, {kUsageVendor + 0x05});
-  SetReportId(0x82);
-  AddReportItem(top, kOutput, kVolatileConstant, {kUsageVendor + 0x06});
-  ValidateCollections(kNintendoSwitchProController,
+  std::vector<HidCollectionInfoPtr> expected_info;
+  expected_info.push_back(std::move(top_info));
+  ValidateDetails(expected_info, true, 63, 63, 0, kNintendoSwitchProController,
                       kNintendoSwitchProControllerSize);
 }
 
 TEST_F(HidReportDescriptorTest, ValidateDetails_XboxAdaptiveController) {
-  auto gamepad_info = HidCollectionInfo::New();
-  gamepad_info->usage = HidUsageAndPage::New(mojom::kGenericDesktopGamePad,
-                                             mojom::kPageGenericDesktop);
-  ASSERT_EQ(IsProtected(*gamepad_info->usage), false);
-  gamepad_info->report_ids = {0x01, 0x02, 0x03, 0x04, 0x06,
+  const uint16_t usage_page = mojom::kPageGenericDesktop;
+  const uint16_t usage_gamepad = mojom::kGenericDesktopGamePad;
+  const uint16_t usage_keyboard = mojom::kGenericDesktopKeyboard;
+  const uint8_t report_ids_gamepad[] = {0x01, 0x02, 0x03, 0x04, 0x06,
                               0x07, 0x08, 0x09, 0x0a, 0x0b};
-  auto keyboard_info = HidCollectionInfo::New();
-  keyboard_info->usage = HidUsageAndPage::New(mojom::kGenericDesktopKeyboard,
-                                              mojom::kPageGenericDesktop);
-  ASSERT_EQ(IsProtected(*keyboard_info->usage), true);
-  keyboard_info->report_ids = {0x05};
-  AddTopCollectionInfo(std::move(gamepad_info));
-  AddTopCollectionInfo(std::move(keyboard_info));
-  ValidateDetails(true, 54, 8, 64, kMicrosoftXboxAdaptiveController,
-                  kMicrosoftXboxAdaptiveControllerSize);
-}
-
-TEST_F(HidReportDescriptorTest, ValidateCollections_XboxAdaptiveController) {
-  auto* gamepad =
-      AddTopCollection(kUsageGenericDesktopGamePad, kCollectionTypeApplication);
-  SetReportId(0x01);
-  auto* left_stick =
-      AddChild(gamepad, kUsageGenericDesktopPointer, kCollectionTypePhysical);
-  SetLogicalAndPhysicalBounds(0, 0xffff, 0, 0);
-  SetReportSizeAndCount(16, 2);
-  AddReportItem(left_stick, kInput, kAbsoluteVariable,
-                {kUsageGenericDesktopX, kUsageGenericDesktopY});
-  auto* right_stick =
-      AddChild(gamepad, kUsageGenericDesktopPointer, kCollectionTypePhysical);
-  AddReportItem(right_stick, kInput, kAbsoluteVariable,
-                {kUsageGenericDesktopZ, kUsageGenericDesktopRz});
-  SetLogicalAndPhysicalBounds(0, 1023, 0, 0);
-  SetReportSizeAndCount(10, 1);
-  AddReportItem(gamepad, kInput, kAbsoluteVariable, {kUsageSimulationBrake});
-  SetLogicalAndPhysicalBounds(0, 0, 0, 0);
-  SetReportSizeAndCount(6, 1);
-  AddReportConstant(gamepad, kInput, kConstant);
-  SetLogicalAndPhysicalBounds(0, 1023, 0, 0);
-  SetReportSizeAndCount(10, 1);
-  AddReportItem(gamepad, kInput, kAbsoluteVariable,
-                {kUsageSimulationAccelerator});
-  SetLogicalAndPhysicalBounds(0, 0, 0, 0);
-  SetReportSizeAndCount(6, 1);
-  AddReportConstant(gamepad, kInput, kConstant);
-  SetLogicalAndPhysicalBounds(1, 8, 0, 315);
-  SetUnitAndUnitExponent(kUnitDegrees, 0);
-  SetReportSizeAndCount(4, 1);
-  AddReportItem(gamepad, kInput, kNullableAbsoluteVariable,
-                {kUsageGenericDesktopHatSwitch});
-  SetLogicalAndPhysicalBounds(0, 0, 0, 0);
-  SetUnitAndUnitExponent(0, 0);
-  AddReportConstant(gamepad, kInput, kConstant);
-  SetLogicalAndPhysicalBounds(0, 1, 0, 0);
-  SetReportSizeAndCount(1, 15);
-  AddReportItemRange(gamepad, kInput, kAbsoluteVariable, kUsageButton + 1,
-                     kUsageButton + 15);
-  SetLogicalAndPhysicalBounds(0, 0, 0, 0);
-  SetReportSizeAndCount(1, 1);
-  AddReportConstant(gamepad, kInput, kConstant);
-  SetLogicalAndPhysicalBounds(0, 1, 0, 0);
-  AddReportItem(gamepad, kInput, kAbsoluteVariable, {kUsageConsumerACBack});
-  SetLogicalAndPhysicalBounds(0, 0, 0, 0);
-  SetReportSizeAndCount(7, 1);
-  AddReportConstant(gamepad, kInput, kConstant);
-  auto* left_stick2 =
-      AddChild(gamepad, kUsageGenericDesktopPointer, kCollectionTypePhysical);
-  SetLogicalAndPhysicalBounds(0, 0xffff, 0, 0);
-  SetReportSizeAndCount(16, 2);
-  AddReportItem(left_stick2, kInput, kAbsoluteVariable,
-                {kUsageGenericDesktopVx, kUsageGenericDesktopVy});
-  auto* right_stick2 =
-      AddChild(gamepad, kUsageGenericDesktopPointer, kCollectionTypePhysical);
-  SetLogicalAndPhysicalBounds(0, 0xffff, 0, 0);
-  AddReportItem(right_stick2, kInput, kAbsoluteVariable,
-                {kUsageGenericDesktopVbrx, kUsageGenericDesktopVbry});
-  SetLogicalAndPhysicalBounds(0, 1023, 0, 0);
-  SetReportSizeAndCount(10, 1);
-  AddReportItem(gamepad, kInput, kAbsoluteVariable, {kUsageGenericDesktopVz});
-  SetLogicalAndPhysicalBounds(0, 0, 0, 0);
-  SetReportSizeAndCount(6, 1);
-  AddReportConstant(gamepad, kInput, kConstant);
-  SetLogicalAndPhysicalBounds(0, 1023, 0, 0);
-  SetReportSizeAndCount(10, 1);
-  AddReportItem(gamepad, kInput, kAbsoluteVariable, {kUsageGenericDesktopVbrz});
-  SetLogicalAndPhysicalBounds(0, 0, 0, 0);
-  SetReportSizeAndCount(6, 1);
-  AddReportConstant(gamepad, kInput, kConstant);
-  SetLogicalAndPhysicalBounds(1, 8, 0, 315);
-  SetUnitAndUnitExponent(kUnitDegrees, 0);
-  SetReportSizeAndCount(4, 1);
-  AddReportItem(gamepad, kInput, kNullableAbsoluteVariable,
-                {kUsageGenericDesktopDial});
-  SetLogicalAndPhysicalBounds(0, 0, 0, 0);
-  SetUnitAndUnitExponent(0, 0);
-  AddReportConstant(gamepad, kInput, kConstant);
-  SetLogicalAndPhysicalBounds(0, 1, 0, 0);
-  SetReportSizeAndCount(1, 15);
-  AddReportItemRange(gamepad, kInput, kAbsoluteVariable, kUsageButton + 16,
-                     kUsageButton + 30);
-  SetLogicalAndPhysicalBounds(0, 0, 0, 0);
-  SetReportSizeAndCount(1, 1);
-  AddReportConstant(gamepad, kInput, kConstant);
-  SetLogicalAndPhysicalBounds(0, 1, 0, 0);
-  AddReportItem(gamepad, kInput, kAbsoluteVariable, {kUsageConsumerModeStep});
-  SetLogicalAndPhysicalBounds(0, 0, 0, 0);
-  SetReportSizeAndCount(7, 1);
-  AddReportConstant(gamepad, kInput, kConstant);
-  auto* consumer_collection =
-      AddChild(gamepad, kUsageConsumerControl, kCollectionTypeApplication);
-  SetLogicalAndPhysicalBounds(0, 255, 0, 0);
-  SetReportSizeAndCount(4, 1);
-  AddReportItem(consumer_collection, kInput, kAbsoluteVariable,
-                {kUsageConsumer + 0x81});
-  SetLogicalAndPhysicalBounds(0, 0, 0, 0);
-  AddReportConstant(consumer_collection, kInput, kConstant);
-  SetLogicalAndPhysicalBounds(0, 255, 0, 0);
-  AddReportItem(consumer_collection, kInput, kAbsoluteVariable,
-                {kUsageConsumer + 0x84});
-  SetLogicalAndPhysicalBounds(0, 0, 0, 0);
-  AddReportConstant(consumer_collection, kInput, kConstant);
-  SetLogicalAndPhysicalBounds(0, 255, 0, 0);
-  SetReportSizeAndCount(8, 1);
-  AddReportItem(consumer_collection, kInput, kAbsoluteVariable,
-                {kUsageConsumer + 0x85});
-  SetReportSizeAndCount(4, 1);
-  AddReportItem(consumer_collection, kInput, kAbsoluteVariable,
-                {kUsageConsumer + 0x99});
-  SetLogicalAndPhysicalBounds(0, 0, 0, 0);
-  AddReportConstant(consumer_collection, kInput, kConstant);
-  SetLogicalAndPhysicalBounds(0, 255, 0, 0);
-  SetReportSizeAndCount(8, 1);
-  AddReportItem(consumer_collection, kInput, kAbsoluteVariable,
-                {kUsageConsumer + 0x9e});
-  AddReportItem(consumer_collection, kInput, kAbsoluteVariable,
-                {kUsageConsumer + 0xa1});
-  AddReportItem(consumer_collection, kInput, kAbsoluteVariable,
-                {kUsageConsumer + 0xa2});
-  AddReportItem(consumer_collection, kInput, kAbsoluteVariable,
-                {kUsageConsumer + 0xa3});
-  AddReportItem(consumer_collection, kInput, kAbsoluteVariable,
-                {kUsageConsumer + 0xa4});
-  AddReportItem(consumer_collection, kInput, kAbsoluteVariable,
-                {kUsageConsumer + 0xb9});
-  AddReportItem(consumer_collection, kInput, kAbsoluteVariable,
-                {kUsageConsumer + 0xba});
-  AddReportItem(consumer_collection, kInput, kAbsoluteVariable,
-                {kUsageConsumer + 0xbb});
-  AddReportItem(consumer_collection, kInput, kAbsoluteVariable,
-                {kUsageConsumer + 0xbe});
-  AddReportItem(consumer_collection, kInput, kAbsoluteVariable,
-                {kUsageConsumer + 0xc0});
-  AddReportItem(consumer_collection, kInput, kAbsoluteVariable,
-                {kUsageConsumer + 0xc1});
-  AddReportItem(consumer_collection, kInput, kAbsoluteVariable,
-                {kUsageConsumer + 0xc2});
-  AddReportItem(consumer_collection, kInput, kAbsoluteVariable,
-                {kUsageConsumer + 0xc3});
-  AddReportItem(consumer_collection, kInput, kAbsoluteVariable,
-                {kUsageConsumer + 0xc4});
-  AddReportItem(consumer_collection, kInput, kAbsoluteVariable,
-                {kUsageConsumer + 0xc5});
-  AddReportItem(consumer_collection, kInput, kAbsoluteVariable,
-                {kUsageConsumer + 0xc6});
-  AddReportItem(consumer_collection, kInput, kAbsoluteVariable,
-                {kUsageConsumer + 0xc7});
-  AddReportItem(consumer_collection, kInput, kAbsoluteVariable,
-                {kUsageConsumer + 0xc8});
-  SetReportId(0x02);
-  auto* mode_collection =
-      AddChild(gamepad, kUsageConsumerControl, kCollectionTypeApplication);
-  SetLogicalAndPhysicalBounds(0, 1, 0, 0);
-  SetReportSizeAndCount(1, 1);
-  AddReportItem(mode_collection, kInput, kAbsoluteVariable,
-                {kUsageConsumerACHome});
-  SetLogicalAndPhysicalBounds(0, 0, 0, 0);
-  SetReportSizeAndCount(7, 1);
-  AddReportConstant(mode_collection, kInput, kConstant);
-  SetReportId(0x03);
-  auto* pid_collection =
-      AddChild(gamepad, kUsagePidSetEffectReport, kCollectionTypeLogical);
-  SetLogicalAndPhysicalBounds(0, 1, 0, 0);
-  SetReportSizeAndCount(4, 1);
-  AddReportItem(pid_collection, kOutput, kAbsoluteVariable,
-                {kUsagePidDCEnableActuators});
-  SetLogicalAndPhysicalBounds(0, 0, 0, 0);
-  AddReportConstant(pid_collection, kOutput, kConstant);
-  SetLogicalAndPhysicalBounds(0, 100, 0, 0);
-  SetReportSizeAndCount(8, 4);
-  AddReportItem(pid_collection, kOutput, kAbsoluteVariable,
-                {kUsagePidMagnitude});
-  SetLogicalAndPhysicalBounds(0, 255, 0, 0);
-  SetUnitAndUnitExponent(kUnitSecond, 0x0e);
-  SetReportSizeAndCount(8, 1);
-  AddReportItem(pid_collection, kOutput, kAbsoluteVariable,
-                {kUsagePidDuration});
-  AddReportItem(pid_collection, kOutput, kAbsoluteVariable,
-                {kUsagePidStartDelay});
-  SetUnitAndUnitExponent(0, 0);
-  AddReportItem(pid_collection, kOutput, kAbsoluteVariable,
-                {kUsagePidLoopCount});
-  SetReportId(0x04);
-  AddReportItem(gamepad, kInput, kAbsoluteVariable,
-                {kUsageGenericDeviceBatteryStrength});
-  SetReportId(0x06);
-  auto* report_06_collection =
-      AddChild(gamepad, kUsageVendor + 0x01, kCollectionTypeLogical);
-  SetLogicalAndPhysicalBounds(0, 100, 0, 0);
-  AddReportItem(report_06_collection, kFeature, kAbsoluteVariable,
-                {kUsageVendor + 0x01});
-  AddReportItem(report_06_collection, kFeature, kAbsoluteVariable,
-                {kUsageVendor + 0x02});
-  SetLogicalAndPhysicalBounds(0, 255, 0, 0);
-  AddReportItem(report_06_collection, kFeature, kAbsoluteVariable,
-                {kUsageVendor + 0x03});
-  SetReportSizeAndCount(8, 60);
-  AddReportItem(report_06_collection, kFeature, kBufferedBytes,
-                {kUsageVendor + 0x04});
-  SetReportId(0x07);
-  auto* report_07_collection =
-      AddChild(gamepad, kUsageVendor + 0x02, kCollectionTypeLogical);
-  SetLogicalAndPhysicalBounds(0, 100, 0, 0);
-  SetReportSizeAndCount(8, 1);
-  AddReportItem(report_07_collection, kFeature, kAbsoluteVariable,
-                {kUsageVendor + 0x05});
-  AddReportItem(report_07_collection, kFeature, kAbsoluteVariable,
-                {kUsageVendor + 0x06});
-  AddReportItem(report_07_collection, kFeature, kAbsoluteVariable,
-                {kUsageVendor + 0x07});
-  SetReportId(0x08);
-  auto* report_08_collection =
-      AddChild(gamepad, kUsageVendor + 0x03, kCollectionTypeLogical);
-  AddReportItem(report_08_collection, kFeature, kAbsoluteVariable,
-                {kUsageVendor + 0x08});
-  AddReportItem(report_08_collection, kFeature, kAbsoluteVariable,
-                {kUsageVendor + 0x09});
-  SetLogicalAndPhysicalBounds(0, 255, 0, 0);
-  AddReportItem(report_08_collection, kFeature, kAbsoluteVariable,
-                {kUsageVendor + 0x0a});
-  SetReportId(0x09);
-  auto* report_09_collection =
-      AddChild(gamepad, kUsageVendor + 0x04, kCollectionTypeApplication);
-  SetLogicalAndPhysicalBounds(0, 100, 0, 0);
-  AddReportItem(report_09_collection, kFeature, kAbsoluteVariable,
-                {kUsageVendor + 0x0b});
-  AddReportItem(report_09_collection, kFeature, kAbsoluteVariable,
-                {kUsageVendor + 0x0c});
-  AddReportItem(report_09_collection, kFeature, kAbsoluteVariable,
-                {kUsageVendor + 0x0d});
-  SetLogicalAndPhysicalBounds(0, 255, 0, 0);
-  AddReportItem(report_09_collection, kFeature, kAbsoluteVariable,
-                {kUsageVendor + 0x0e});
-  SetReportSizeAndCount(8, 60);
-  AddReportItem(report_09_collection, kFeature, kBufferedBytes,
-                {kUsageVendor + 0x0f});
-  SetReportId(0x0a);
-  auto* report_0a_collection =
-      AddChild(gamepad, kUsageVendor + 0x05, kCollectionTypeApplication);
-  SetLogicalAndPhysicalBounds(0, 0x7fffffff, 0, 0);
-  SetReportSizeAndCount(32, 1);
-  AddReportItem(report_0a_collection, kInput, kAbsoluteVariable,
-                {kUsageVendor + 0x10});
-  AddReportItem(report_0a_collection, kInput, kAbsoluteVariable,
-                {kUsageVendor + 0x11});
-  SetLogicalAndPhysicalBounds(0, 255, 0, 0);
-  SetReportSizeAndCount(8, 2);
-  AddReportItem(report_0a_collection, kInput, kAbsoluteVariable,
-                {kUsageVendor + 0x12});
-  SetReportSizeAndCount(8, 1);
-  AddReportItem(report_0a_collection, kInput, kAbsoluteVariable,
-                {kUsageVendor + 0x13});
-  SetReportId(0x0b);
-  auto* report_0b_collection =
-      AddChild(gamepad, kUsageVendor + 0x06, kCollectionTypeLogical);
-  SetLogicalAndPhysicalBounds(0, 100, 0, 0);
-
-  AddReportItem(report_0b_collection, kFeature, kAbsoluteVariable,
-                {kUsageVendor + 0x14});
-  SetReportId(0x05);
-  auto* keyboard = AddTopCollection(kUsageGenericDesktopKeyboard,
-                                    kCollectionTypeApplication);
-  SetLogicalAndPhysicalBounds(0, 1, 0, 0);
-  SetReportSizeAndCount(1, 8);
-  AddReportItemRange(keyboard, kInput, kAbsoluteVariable,
-                     kUsageKeyboardLeftControl, kUsageKeyboardRightGui);
-  SetReportSizeAndCount(8, 1);
-  AddReportConstant(keyboard, kInput, kConstant);
-  SetLogicalAndPhysicalBounds(0, 101, 0, 0);
-  SetReportSizeAndCount(8, 6);
-  AddReportItemRange(keyboard, kInput, kNonNullableArray, kUsageKeyboard,
-                     kUsageKeyboardApplication);
-  ValidateCollections(kMicrosoftXboxAdaptiveController,
-                      kMicrosoftXboxAdaptiveControllerSize);
-}
+  const size_t report_ids_gamepad_size = base::size(report_ids_gamepad);
+  const uint8_t report_ids_keyboard[] = {0x05};
+  const size_t report_ids_keyboard_size = base::size(report_ids_keyboard);
 
-TEST_F(HidReportDescriptorTest, ValidateDetails_NexusPlayerController) {
   auto gamepad_info = HidCollectionInfo::New();
-  gamepad_info->usage = HidUsageAndPage::New(mojom::kGenericDesktopGamePad,
-                                             mojom::kPageGenericDesktop);
-  ASSERT_EQ(IsProtected(*gamepad_info->usage), false);
-  gamepad_info->report_ids = {0x01, 0x02};
-  auto status_info = HidCollectionInfo::New();
-  status_info->usage = HidUsageAndPage::New(mojom::kGenericDesktopGamePad,
-                                            mojom::kPageGenericDesktop);
-  ASSERT_EQ(IsProtected(*status_info->usage), false);
-  status_info->report_ids = {0x03};
-  AddTopCollectionInfo(std::move(gamepad_info));
-  AddTopCollectionInfo(std::move(status_info));
-  ValidateDetails(true, 8, 1, 0, kNexusPlayerController,
-                  kNexusPlayerControllerSize);
-}
-
-TEST_F(HidReportDescriptorTest, ValidateCollections_NexusPlayerController) {
-  auto* gamepad =
-      AddTopCollection(kUsageGenericDesktopGamePad, kCollectionTypeApplication);
-  SetReportId(0x01);
-  SetLogicalAndPhysicalBounds(0, 1, 0, 0);
-  SetReportSizeAndCount(1, 11);
-  AddReportItem(
-      gamepad, kInput, kAbsoluteVariable,
-      {kUsageButton + 1, kUsageButton + 2, kUsageButton + 4, kUsageButton + 5,
-       kUsageButton + 7, kUsageButton + 8, kUsageButton + 14, kUsageButton + 15,
-       kUsageButton + 13, kUsageConsumerACBack, kUsageConsumerACHome});
-  SetReportSizeAndCount(1, 1);
-  AddReportConstant(gamepad, kInput, kConstant);
-  SetLogicalAndPhysicalBounds(0, 7, 0, 315);
-  SetUnitAndUnitExponent(kUnitDegrees, 0);
-  SetReportSizeAndCount(4, 1);
-  AddReportItem(gamepad, kInput, kNullableAbsoluteVariable,
-                {kUsageGenericDesktopHatSwitch});
-  SetUnitAndUnitExponent(0, 0);
-  auto* axes_collection =
-      AddChild(gamepad, kUsageGenericDesktop, kCollectionTypePhysical);
-  SetLogicalAndPhysicalBounds(0, 255, 0, 255);
-  SetReportSizeAndCount(8, 6);
-  AddReportItem(axes_collection, kInput, kAbsoluteVariable,
-                {kUsageGenericDesktopX, kUsageGenericDesktopY,
-                 kUsageGenericDesktopZ, kUsageGenericDesktopRz,
-                 kUsageSimulationBrake, kUsageSimulationAccelerator});
-  SetReportId(0x02);
-  SetLogicalAndPhysicalBounds(0, 1, 0, 255);
-  SetReportSizeAndCount(1, 4);
-  AddReportItem(gamepad, kOutput, kAbsoluteVariable,
-                {kUsageLedNumLock, kUsageLedCapsLock, kUsageLedScrollLock,
-                 kUsageLedCompose});
-  SetReportSizeAndCount(4, 1);
-  AddReportConstant(gamepad, kOutput, kConstant);
-  SetReportId(0x03);
-  auto* status =
-      AddTopCollection(kUsageGenericDesktopGamePad, kCollectionTypeApplication);
-  SetLogicalAndPhysicalBounds(0, 255, 0, 255);
-  SetReportSizeAndCount(8, 1);
-  AddReportItem(status, kInput, kAbsoluteVariable,
-                {kUsageGenericDeviceBatteryStrength});
-  SetReportSizeAndCount(8, 6);
-  AddReportItem(status, kInput, kAbsoluteVariable, {0xffbcbdad});
-  ValidateCollections(kNexusPlayerController, kNexusPlayerControllerSize);
-}
-
-TEST_F(HidReportDescriptorTest, ValidateDetails_SteamControllerKeyboard) {
-  auto info = HidCollectionInfo::New();
-  info->usage = HidUsageAndPage::New(mojom::kGenericDesktopKeyboard,
-                                     mojom::kPageGenericDesktop);
-  ASSERT_EQ(IsProtected(*info->usage), true);
-  AddTopCollectionInfo(std::move(info));
-  ValidateDetails(false, 8, 1, 0, kSteamControllerKeyboard,
-                  kSteamControllerKeyboardSize);
-}
-
-TEST_F(HidReportDescriptorTest, ValidateCollections_SteamControllerKeyboard) {
-  auto* top = AddTopCollection(kUsageGenericDesktopKeyboard,
-                               kCollectionTypeApplication);
-  SetLogicalAndPhysicalBounds(0, 1, 0, 0);
-  SetReportSizeAndCount(1, 8);
-  AddReportItemRange(top, kInput, kAbsoluteVariable, kUsageKeyboardLeftControl,
-                     kUsageKeyboardRightGui);
-  SetReportSizeAndCount(8, 1);
-  AddReportConstant(top, kInput, kConstantArray);
-  SetReportSizeAndCount(1, 5);
-  AddReportItemRange(top, kOutput, kAbsoluteVariable, kUsageLedNumLock,
-                     kUsageLedKana);
-  SetReportSizeAndCount(3, 1);
-  AddReportConstant(top, kOutput, kConstantArray);
-  SetReportSizeAndCount(8, 6);
-  SetLogicalAndPhysicalBounds(0, 101, 0, 0);
-  AddReportItemRange(top, kInput, kNonNullableArray, kUsageKeyboard,
-                     kUsageKeyboardApplication);
-  ValidateCollections(kSteamControllerKeyboard, kSteamControllerKeyboardSize);
-}
-
-TEST_F(HidReportDescriptorTest, ValidateDetails_SteamControllerMouse) {
-  auto info = HidCollectionInfo::New();
-  info->usage = HidUsageAndPage::New(mojom::kGenericDesktopMouse,
-                                     mojom::kPageGenericDesktop);
-  ASSERT_EQ(IsProtected(*info->usage), true);
-  AddTopCollectionInfo(std::move(info));
-  ValidateDetails(false, 4, 0, 0, kSteamControllerMouse,
-                  kSteamControllerMouseSize);
-}
+  gamepad_info->usage = HidUsageAndPage::New(usage_gamepad, usage_page);
+  gamepad_info->report_ids.insert(gamepad_info->report_ids.begin(),
+                                  report_ids_gamepad,
+                                  report_ids_gamepad + report_ids_gamepad_size);
 
-TEST_F(HidReportDescriptorTest, ValidateCollections_SteamControllerMouse) {
-  auto* top =
-      AddTopCollection(kUsageGenericDesktopMouse, kCollectionTypeApplication);
-  auto* pointer =
-      AddChild(top, kUsageGenericDesktopPointer, kCollectionTypePhysical);
-  SetLogicalAndPhysicalBounds(0, 1, 0, 0);
-  SetReportSizeAndCount(1, 5);
-  AddReportItemRange(pointer, kInput, kAbsoluteVariable, kUsageButton + 1,
-                     kUsageButton + 5);
-  SetReportSizeAndCount(3, 1);
-  AddReportConstant(pointer, kInput, kConstantArray);
-  SetLogicalAndPhysicalBounds(0x81, 0x7f, 0, 0);
-  SetReportSizeAndCount(8, 3);
-  AddReportItem(pointer, kInput, kRelativeVariable,
-                {kUsageGenericDesktopX, kUsageGenericDesktopY,
-                 kUsageGenericDesktopWheel});
-  ValidateCollections(kSteamControllerMouse, kSteamControllerMouseSize);
-}
-
-TEST_F(HidReportDescriptorTest, ValidateDetails_SteamControllerVendor) {
-  auto info = HidCollectionInfo::New();
-  info->usage = HidUsageAndPage::New(0x01, mojom::kPageVendor);
-  ASSERT_EQ(IsProtected(*info->usage), false);
-  AddTopCollectionInfo(std::move(info));
-  ValidateDetails(false, 64, 64, 64, kSteamControllerVendor,
-                  kSteamControllerVendorSize);
-}
-
-TEST_F(HidReportDescriptorTest, ValidateCollections_SteamControllerVendor) {
-  auto* top = AddTopCollection(kUsageVendor + 0x01, kCollectionTypeApplication);
-  SetLogicalAndPhysicalBounds(0, 255, 0, 0);
-  SetReportSizeAndCount(8, 64);
-  AddReportItem(top, kInput, kAbsoluteVariable, {kUsageVendor + 0x01});
-  AddReportItem(top, kOutput, kAbsoluteVariable, {kUsageVendor + 0x01});
-  AddReportItem(top, kFeature, kAbsoluteVariable, {kUsageVendor + 0x01});
-  ValidateCollections(kSteamControllerVendor, kSteamControllerVendorSize);
-}
-
-TEST_F(HidReportDescriptorTest, ValidateDetails_XSkillsUsbAdapter) {
-  auto info = HidCollectionInfo::New();
-  info->usage = HidUsageAndPage::New(mojom::kGenericDesktopJoystick,
-                                     mojom::kPageGenericDesktop);
-  ASSERT_EQ(IsProtected(*info->usage), false);
-  AddTopCollectionInfo(std::move(info));
-  ValidateDetails(false, 7, 4, 0, kXSkillsUsbAdapter, kXSkillsUsbAdapterSize);
-}
-
-TEST_F(HidReportDescriptorTest, ValidateCollections_XSkillsUsbAdapter) {
-  auto* top = AddTopCollection(kUsageGenericDesktopJoystick,
-                               kCollectionTypeApplication);
-  SetLogicalAndPhysicalBounds(0, 1, 0, 1);
-  SetReportSizeAndCount(1, 12);
-  AddReportItemRange(top, kInput, kAbsoluteVariable, kUsageButton + 1,
-                     kUsageButton + 12);
-  SetReportSizeAndCount(1, 4);
-  AddReportConstant(top, kInput, kConstant);
-  SetLogicalAndPhysicalBounds(0, 255, 0, 255);
-  SetReportSizeAndCount(8, 4);
-  AddReportItem(top, kInput, kAbsoluteVariable,
-                {kUsageGenericDesktopX, kUsageGenericDesktopY,
-                 kUsageGenericDesktopRz, kUsageGenericDesktopZ});
-  SetLogicalAndPhysicalBounds(0, 15, 0, 15);
-  SetReportSizeAndCount(4, 2);
-  AddReportItem(top, kInput, kAbsoluteVariable,
-                {kUsageGenericDesktopRx, kUsageGenericDesktopRy});
-  SetReportSizeAndCount(8, 4);
-  AddReportItemRange(top, kOutput, kAbsoluteVariable, kUsageVendor + 0x01,
-                     kUsageVendor + 0x04);
-  ValidateCollections(kXSkillsUsbAdapter, kXSkillsUsbAdapterSize);
-}
-
-TEST_F(HidReportDescriptorTest, ValidateDetails_BelkinNostromoKeyboard) {
-  auto info = HidCollectionInfo::New();
-  info->usage = HidUsageAndPage::New(mojom::kGenericDesktopKeyboard,
-                                     mojom::kPageGenericDesktop);
-  ASSERT_EQ(IsProtected(*info->usage), true);
-  AddTopCollectionInfo(std::move(info));
-  ValidateDetails(false, 8, 0, 0, kBelkinNostromoKeyboard,
-                  kBelkinNostromoKeyboardSize);
-}
-
-TEST_F(HidReportDescriptorTest, ValidateCollections_BelkinNostromoKeyboard) {
-  auto* top = AddTopCollection(kUsageGenericDesktopKeyboard,
-                               kCollectionTypeApplication);
-  SetLogicalAndPhysicalBounds(0, 1, 0, 0);
-  SetReportSizeAndCount(1, 8);
-  AddReportItemRange(top, kInput, kAbsoluteVariable, kUsageKeyboardLeftControl,
-                     kUsageKeyboardRightGui);
-  SetReportSizeAndCount(8, 1);
-  AddReportConstant(top, kInput, kConstantArray);
-  SetLogicalAndPhysicalBounds(0, 101, 0, 0);
-  SetReportSizeAndCount(8, 6);
-  AddReportItemRange(top, kInput, kNonNullableArray, kUsageKeyboard,
-                     kUsageKeyboardApplication);
-  ValidateCollections(kBelkinNostromoKeyboard, kBelkinNostromoKeyboardSize);
-}
-
-TEST_F(HidReportDescriptorTest, ValidateDetails_BelkinNostromoMouseAndExtra) {
-  auto info = HidCollectionInfo::New();
-  info->usage = HidUsageAndPage::New(mojom::kGenericDesktopMouse,
-                                     mojom::kPageGenericDesktop);
-  ASSERT_EQ(IsProtected(*info->usage), true);
-  AddTopCollectionInfo(std::move(info));
-  ValidateDetails(false, 4, 1, 0, kBelkinNostromoMouseAndExtra,
-                  kBelkinNostromoMouseAndExtraSize);
-}
-
-TEST_F(HidReportDescriptorTest,
-       ValidateCollections_BelkinNostromoMouseAndExtra) {
-  auto* top =
-      AddTopCollection(kUsageGenericDesktopMouse, kCollectionTypeApplication);
-  auto* pointer =
-      AddChild(top, kUsageGenericDesktopPointer, kCollectionTypePhysical);
-  SetLogicalAndPhysicalBounds(0, 1, 0, 0);
-  SetReportSizeAndCount(1, 3);
-  AddReportItemRange(pointer, kInput, kAbsoluteVariable, kUsageButton + 1,
-                     kUsageButton + 3);
-  SetReportSizeAndCount(5, 1);
-  AddReportConstant(pointer, kInput, kConstantArray);
-  SetLogicalAndPhysicalBounds(0x81, 0x7f, 0, 0);
-  SetReportSizeAndCount(8, 3);
-  AddReportItem(pointer, kInput, kRelativeVariable,
-                {kUsageGenericDesktopX, kUsageGenericDesktopY,
-                 kUsageGenericDesktopWheel});
-  SetLogicalAndPhysicalBounds(0, 1, 0, 1);
-  SetReportSizeAndCount(1, 3);
-  AddReportItemRange(pointer, kOutput, kAbsoluteVariable, kUsageLedNumLock,
-                     kUsageLedScrollLock);
-  SetReportSizeAndCount(5, 1);
-  AddReportConstant(pointer, kOutput, kConstantArray);
-  ValidateCollections(kBelkinNostromoMouseAndExtra,
-                      kBelkinNostromoMouseAndExtraSize);
-}
-
-TEST_F(HidReportDescriptorTest, InvalidReportSizeIgnored) {
-  // Report size can be at most 32 bits. Make sure a report item with invalid
-  // size does not affect the maximum report size. The descriptor below
-  // describes a report with one 64-bit constant field.
-  static const uint8_t kInvalidReportSizeDescriptor[] = {
-      0xA0,        // Collection
-      0x95, 0x01,  //   Report Count (1)
-      0x75, 0x40,  //   Report Size (64)
-      0x90         //   Output
-  };
-  static const size_t kInvalidReportSizeDescriptorSize =
-      base::size(kInvalidReportSizeDescriptor);
-  auto info = HidCollectionInfo::New();
-  info->usage = HidUsageAndPage::New(0, 0);
-  AddTopCollectionInfo(std::move(info));
-  // Maximum report sizes should not be affected by the invalid report item.
-  ValidateDetails(false, 0, 0, 0, kInvalidReportSizeDescriptor,
-                  kInvalidReportSizeDescriptorSize);
-
-  // The report item with invalid size should still be included in the
-  // collection info.
-  auto* top = AddTopCollection(0, kCollectionTypePhysical);
-  SetReportSizeAndCount(64, 1);
-  AddReportConstant(top, kOutput, kNonNullableArray);
-  ValidateCollections(kInvalidReportSizeDescriptor,
-                      kInvalidReportSizeDescriptorSize);
-}
-
-TEST_F(HidReportDescriptorTest, ReasonablyHugeReportNotIgnored) {
-  // The descriptor below defines a 2^16-1 byte output report. Larger reports
-  // are considered unreasonable and are ignored in the max report size
-  // calculation.
-  static const uint8_t kReasonablyHugeReportDescriptor[] = {
-      0xA0,              // Collection
-      0x96, 0xff, 0xff,  //   Report Count (65535)
-      0x75, 0x08,        //   Report Size (8)
-      0x90               //   Output
-  };
-  static const size_t kReasonablyHugeReportDescriptorSize =
-      base::size(kReasonablyHugeReportDescriptor);
-  auto info = HidCollectionInfo::New();
-  info->usage = HidUsageAndPage::New(0, 0);
-  AddTopCollectionInfo(std::move(info));
-  // Maximum report sizes should include the huge report.
-  ValidateDetails(false, 0, 65535, 0, kReasonablyHugeReportDescriptor,
-                  kReasonablyHugeReportDescriptorSize);
-
-  auto* top = AddTopCollection(0, kCollectionTypePhysical);
-  SetReportSizeAndCount(8, 65535);
-  AddReportConstant(top, kOutput, kNonNullableArray);
-  ValidateCollections(kReasonablyHugeReportDescriptor,
-                      kReasonablyHugeReportDescriptorSize);
-}
-
-TEST_F(HidReportDescriptorTest, UnreasonablyHugeReportIgnored) {
-  // The descriptor below defines a 2^16 byte output report. The report is
-  // larger than the maximum report size considered reasonable and will be
-  // ignored when computing the max report size.
-  static const uint8_t kUnreasonablyHugeReportDescriptor[] = {
-      0xA0,                          // Collection
-      0x97, 0x00, 0x00, 0x01, 0x00,  //   Report Count (65536)
-      0x75, 0x08,                    //   Report Size (8)
-      0x90                           //   Output
-  };
-  static const size_t kUnreasonablyHugeReportDescriptorSize =
-      base::size(kUnreasonablyHugeReportDescriptor);
-  auto info = HidCollectionInfo::New();
-  info->usage = HidUsageAndPage::New(0, 0);
-  AddTopCollectionInfo(std::move(info));
-  // Maximum report sizes should not be affected by the huge report.
-  ValidateDetails(false, 0, 0, 0, kUnreasonablyHugeReportDescriptor,
-                  kUnreasonablyHugeReportDescriptorSize);
-
-  // The unreasonably huge report item should still be included in the
-  // collection info.
-  auto* top = AddTopCollection(0, kCollectionTypePhysical);
-  SetReportSizeAndCount(8, 65536);
-  AddReportConstant(top, kOutput, kNonNullableArray);
-  ValidateCollections(kUnreasonablyHugeReportDescriptor,
-                      kUnreasonablyHugeReportDescriptorSize);
-}
-
-TEST_F(HidReportDescriptorTest, HighlyNestedReportLimitsDepth) {
-  // The HID report descriptor parser sets a maximum depth to prevent issues
-  // with descriptors that define many nested collections. The descriptor below
-  // nests a single constant inside 51 collections.
-  static const uint8_t kHighlyNestedReportDescriptor[] = {
-      0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0,
-      0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0,
-      0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0,
-      0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0,
-      0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0,
-
-      0x95, 0x01,  // Report Count (1)
-      0x75, 0x08,  // Report Size (8)
-      0x90         // Output
-  };
-  static const size_t kHighlyNestedReportDescriptorSize =
-      base::size(kHighlyNestedReportDescriptor);
-  auto info = HidCollectionInfo::New();
-  info->usage = HidUsageAndPage::New(0, 0);
-  AddTopCollectionInfo(std::move(info));
-  // The item in the innermost collection should still be reflected in the
-  // maximum report size.
-  ValidateDetails(false, 0, 1, 0, kHighlyNestedReportDescriptor,
-                  kHighlyNestedReportDescriptorSize);
-
-  // Construct nested collections up to the depth limit. The item from the
-  // innermost collection should be propagated to all its parents even though
-  // the depth limit has been reached.
-  auto* parent = AddTopCollection(0, kCollectionTypePhysical);
-  for (size_t i = 1; i < 50; ++i)
-    parent = AddChild(parent, 0, kCollectionTypePhysical);
-  SetReportSizeAndCount(8, 1);
-  AddReportConstant(parent, kOutput, kNonNullableArray);
-  ValidateCollections(kHighlyNestedReportDescriptor,
-                      kHighlyNestedReportDescriptorSize);
+  auto keyboard_info = HidCollectionInfo::New();
+  keyboard_info->usage = HidUsageAndPage::New(usage_keyboard, usage_page);
+  keyboard_info->report_ids.insert(
+      keyboard_info->report_ids.begin(), report_ids_keyboard,
+      report_ids_keyboard + report_ids_keyboard_size);
+
+  std::vector<HidCollectionInfoPtr> expected_info;
+  expected_info.push_back(std::move(gamepad_info));
+  expected_info.push_back(std::move(keyboard_info));
+  ValidateDetails(expected_info, true, 54, 8, 64,
+                  kMicrosoftXboxAdaptiveController,
+                  kMicrosoftXboxAdaptiveControllerSize);
 }
 
 }  // namespace device
--- a/services/device/public/cpp/hid/hid_usage_and_page.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/public/cpp/hid/hid_usage_and_page.h	2019-05-17 18:53:37.840000000 +0300
@@ -2,8 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#ifndef SERVICES_DEVICE_PUBLIC_CPP_HID_HID_USAGE_AND_PAGE_H_
-#define SERVICES_DEVICE_PUBLIC_CPP_HID_HID_USAGE_AND_PAGE_H_
+#ifndef DEVICE_HID_PUBLIC_CPP_HID_USAGE_AND_PAGE_H_
+#define DEVICE_HID_PUBLIC_CPP_HID_USAGE_AND_PAGE_H_
 
 #include "services/device/public/mojom/hid.mojom.h"
 
@@ -14,4 +14,4 @@
 
 }  // namespace device
 
-#endif  // SERVICES_DEVICE_PUBLIC_CPP_HID_HID_USAGE_AND_PAGE_H_
+#endif  // DEVICE_HID_PUBLIC_CPP_HID_USAGE_AND_PAGE_H_
--- a/services/device/public/cpp/test/test_wake_lock_provider.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/public/cpp/test/test_wake_lock_provider.cc	2019-05-17 18:53:37.840000000 +0300
@@ -4,9 +4,6 @@
 
 #include "services/device/public/cpp/test/test_wake_lock_provider.h"
 
-#include <memory>
-#include <utility>
-
 #include "base/callback.h"
 #include "base/logging.h"
 #include "mojo/public/cpp/bindings/binding.h"
@@ -19,52 +16,29 @@
 class TestWakeLockProvider::TestWakeLock : public mojom::WakeLock,
                                            public service_manager::Service {
  public:
-  TestWakeLock(mojom::WakeLockRequest request,
-               mojom::WakeLockType type,
-               TestWakeLockProvider* provider)
-      : type_(type), provider_(provider) {
-    AddClient(std::move(request));
-    bindings_.set_connection_error_handler(base::BindRepeating(
-        &TestWakeLock::OnConnectionError, base::Unretained(this)));
+  TestWakeLock(TestWakeLockProvider* provider, mojom::WakeLockType type)
+      : provider_(provider), type_(type) {}
+  ~TestWakeLock() override {
+    if (active_)
+      provider_->OnWakeLockDeactivated(this);
   }
 
-  ~TestWakeLock() override = default;
-
   mojom::WakeLockType type() const { return type_; }
 
   // mojom::WakeLock:
   void RequestWakeLock() override {
-    DCHECK(bindings_.dispatch_context());
-    DCHECK_GE(num_lock_requests_, 0);
-
-    // Coalesce consecutive requests from the same client.
-    if (*bindings_.dispatch_context())
-      return;
-
-    *bindings_.dispatch_context() = true;
-    num_lock_requests_++;
-    CheckAndNotifyProvider();
+    if (!active_) {
+      provider_->OnWakeLockActivated(this);
+      active_ = true;
+    }
   }
-
   void CancelWakeLock() override {
-    DCHECK(bindings_.dispatch_context());
-
-    // Coalesce consecutive cancel requests from the same client. Also ignore a
-    // CancelWakeLock call without a RequestWakeLock call.
-    if (!(*bindings_.dispatch_context()))
-      return;
-
-    DCHECK_GT(num_lock_requests_, 0);
-    *bindings_.dispatch_context() = false;
-    num_lock_requests_--;
-    CheckAndNotifyProvider();
-  }
-
-  void AddClient(mojom::WakeLockRequest request) override {
-    bindings_.AddBinding(this, std::move(request),
-                         std::make_unique<bool>(false));
+    if (active_) {
+      provider_->OnWakeLockDeactivated(this);
+      active_ = false;
   }
-
+  }
+  void AddClient(mojom::WakeLockRequest request) override { NOTIMPLEMENTED(); }
   void ChangeType(mojom::WakeLockType type,
                   ChangeTypeCallback callback) override {
     NOTIMPLEMENTED();
@@ -69,86 +43,37 @@
                   ChangeTypeCallback callback) override {
     NOTIMPLEMENTED();
   }
-
   void HasWakeLockForTests(HasWakeLockForTestsCallback callback) override {
     NOTIMPLEMENTED();
   }
 
-  void OnConnectionError() {
-    // If there is an outstanding request by this client then decrement its
-    // request and check if the wake lock is deactivated.
-    DCHECK(bindings_.dispatch_context());
-    if (*bindings_.dispatch_context() && num_lock_requests_ > 0) {
-      num_lock_requests_--;
-      CheckAndNotifyProvider();
-    }
-
-    // TestWakeLockProvider will take care of deleting this object as it owns
-    // it.
-    if (bindings_.empty())
-      provider_->OnConnectionError(type_, this);
-  }
-
  private:
-  void CheckAndNotifyProvider() {
-    if (num_lock_requests_ == 1) {
-      provider_->OnWakeLockActivated(type_);
-      return;
-    }
-
-    if (num_lock_requests_ == 0) {
-      provider_->OnWakeLockDeactivated(type_);
-      return;
-    }
-  }
+  TestWakeLockProvider* provider_;  // Not owned.
 
   mojom::WakeLockType type_;
 
-  // Not owned.
-  TestWakeLockProvider* provider_;
-
-  mojo::BindingSet<mojom::WakeLock, std::unique_ptr<bool>> bindings_;
-
-  int num_lock_requests_ = 0;
+  // Set to true by RequestWakeLock and back to false by CancelWakeLock.
+  bool active_ = false;
 
   DISALLOW_COPY_AND_ASSIGN(TestWakeLock);
 };
 
-// Holds the state associated with wake locks of a single type across the
-// system i.e. if 3 |kAppSuspension| wake locks are currently held the |count|
-// would be 3.
-struct TestWakeLockProvider::WakeLockDataPerType {
-  WakeLockDataPerType() = default;
-  WakeLockDataPerType(WakeLockDataPerType&&) = default;
-  ~WakeLockDataPerType() = default;
-
-  // Currently held count of this wake lock type.
-  int64_t count = 0;
-
-  // Map of all wake locks of this type created by this provider. An entry is
-  // removed from this map when an |OnConnectionError| is received.
-  std::map<TestWakeLock*, std::unique_ptr<TestWakeLock>> wake_locks;
-
-  // Observers for this wake lock type.
-  mojo::InterfacePtrSet<mojom::WakeLockObserver> observers;
-
-  DISALLOW_COPY_AND_ASSIGN(WakeLockDataPerType);
-};
-
 TestWakeLockProvider::TestWakeLockProvider(
     service_manager::mojom::ServiceRequest request)
-    : service_binding_(this, std::move(request)) {
-  // Populates |wake_lock_store_| with entries for all types of wake locks.
-  wake_lock_store_[mojom::WakeLockType::kPreventAppSuspension] =
-      std::make_unique<WakeLockDataPerType>();
-  wake_lock_store_[mojom::WakeLockType::kPreventDisplaySleep] =
-      std::make_unique<WakeLockDataPerType>();
-  wake_lock_store_[mojom::WakeLockType::kPreventDisplaySleepAllowDimming] =
-      std::make_unique<WakeLockDataPerType>();
-}
+    : service_binding_(this, std::move(request)) {}
 
 TestWakeLockProvider::~TestWakeLockProvider() = default;
 
+int TestWakeLockProvider::GetActiveWakeLocksOfType(
+    mojom::WakeLockType type) const {
+  int count = 0;
+  for (const auto* lock : active_wake_locks_) {
+    if (lock->type() == type)
+      count++;
+  }
+  return count;
+}
+
 void TestWakeLockProvider::GetWakeLockContextForID(
     int context_id,
     mojo::InterfaceRequest<mojom::WakeLockContext> request) {
@@ -161,11 +86,8 @@
     mojom::WakeLockReason reason,
     const std::string& description,
     mojom::WakeLockRequest request) {
-  // Create a wake lock and store it to manage it's lifetime.
-  auto wake_lock =
-      std::make_unique<TestWakeLock>(std::move(request), type, this);
-  GetWakeLockDataPerType(type).wake_locks[wake_lock.get()] =
-      std::move(wake_lock);
+  auto wake_lock = std::make_unique<TestWakeLock>(this, type);
+  mojo::MakeStrongBinding(std::move(wake_lock), std::move(request));
 }
 
 void TestWakeLockProvider::OnBindInterface(
@@ -177,60 +99,18 @@
       this, mojom::WakeLockProviderRequest(std::move(interface_pipe)));
 }
 
-void TestWakeLockProvider::OnConnectionError(mojom::WakeLockType type,
-                                             TestWakeLock* wake_lock) {
-  size_t result = GetWakeLockDataPerType(type).wake_locks.erase(wake_lock);
-  DCHECK_GT(result, 0UL);
-}
-
-TestWakeLockProvider::WakeLockDataPerType&
-TestWakeLockProvider::GetWakeLockDataPerType(mojom::WakeLockType type) const {
-  auto it = wake_lock_store_.find(type);
-  // An entry for |type| should always be created in the constructor.
-  DCHECK(it != wake_lock_store_.end());
-  return *(it->second);
+void TestWakeLockProvider::OnWakeLockActivated(TestWakeLock* wake_lock) {
+  DCHECK(!active_wake_locks_.count(wake_lock));
+  active_wake_locks_.insert(wake_lock);
+  if (wake_lock_requested_callback_)
+    wake_lock_requested_callback_.Run();
 }
 
-void TestWakeLockProvider::OnWakeLockActivated(mojom::WakeLockType type) {
-  // Increment the currently activated wake locks of type |type|.
-  const int64_t old_count = GetWakeLockDataPerType(type).count;
-  DCHECK_GE(old_count, 0);
-
-  GetWakeLockDataPerType(type).count = old_count + 1;
-}
-
-void TestWakeLockProvider::OnWakeLockDeactivated(mojom::WakeLockType type) {
-  // Decrement the currently activated wake locks of type |type|.
-  const int64_t old_count = GetWakeLockDataPerType(type).count;
-  DCHECK_GT(old_count, 0);
-
-  const int64_t new_count = old_count - 1;
-  GetWakeLockDataPerType(type).count = new_count;
-  // Notify observers of the last cancelation i.e. deactivation of wake lock
-  // type |type|.
-  if (new_count == 0) {
-    GetWakeLockDataPerType(type).observers.ForAllPtrs(
-        [type](mojom::WakeLockObserver* wake_lock_observer) {
-          wake_lock_observer->OnWakeLockDeactivated(type);
-        });
-  }
-}
-
-void TestWakeLockProvider::NotifyOnWakeLockDeactivation(
-    mojom::WakeLockType type,
-    mojom::WakeLockObserverPtr observer) {
-  // Notify observer immediately if wake lock is deactivated. Add it to the
-  // observers list for future deactivation notifications.
-  if (GetWakeLockDataPerType(type).count == 0) {
-    observer->OnWakeLockDeactivated(type);
-  }
-  GetWakeLockDataPerType(type).observers.AddPtr(std::move(observer));
-}
-
-void TestWakeLockProvider::GetActiveWakeLocksForTests(
-    mojom::WakeLockType type,
-    GetActiveWakeLocksForTestsCallback callback) {
-  std::move(callback).Run(GetWakeLockDataPerType(type).count);
+void TestWakeLockProvider::OnWakeLockDeactivated(TestWakeLock* wake_lock) {
+  DCHECK(active_wake_locks_.count(wake_lock));
+  active_wake_locks_.erase(wake_lock);
+  if (wake_lock_canceled_callback_)
+    wake_lock_canceled_callback_.Run();
 }
 
 }  // namespace device
--- a/services/device/public/cpp/test/test_wake_lock_provider.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/public/cpp/test/test_wake_lock_provider.h	2019-05-17 18:53:37.840000000 +0300
@@ -5,15 +5,12 @@
 #ifndef SERVICES_DEVICE_PUBLIC_CPP_TEST_TEST_WAKE_LOCK_PROVIDER_H_
 #define SERVICES_DEVICE_PUBLIC_CPP_TEST_TEST_WAKE_LOCK_PROVIDER_H_
 
-#include <map>
-#include <memory>
 #include <set>
 #include <string>
 
 #include "base/callback_forward.h"
 #include "base/macros.h"
 #include "mojo/public/cpp/bindings/binding_set.h"
-#include "mojo/public/cpp/bindings/interface_ptr_set.h"
 #include "services/device/public/mojom/wake_lock.mojom.h"
 #include "services/device/public/mojom/wake_lock_provider.mojom.h"
 #include "services/service_manager/public/cpp/service.h"
@@ -29,8 +26,16 @@
   explicit TestWakeLockProvider(service_manager::mojom::ServiceRequest request);
   ~TestWakeLockProvider() override;
 
-  // For internal use only.
-  class TestWakeLock;
+  void set_wake_lock_requested_callback(const base::RepeatingClosure& cb) {
+    wake_lock_requested_callback_ = cb;
+  }
+  void set_wake_lock_canceled_callback(const base::RepeatingClosure& cb) {
+    wake_lock_canceled_callback_ = cb;
+  }
+
+  // Returns the number of active (i.e. currently-requested) wake locks of type
+  // |type|.
+  int GetActiveWakeLocksOfType(mojom::WakeLockType type) const;
 
   // mojom::WakeLockProvider:
   void GetWakeLockContextForID(
@@ -40,39 +45,32 @@
                                  mojom::WakeLockReason reason,
                                  const std::string& description,
                                  mojom::WakeLockRequest request) override;
-  void NotifyOnWakeLockDeactivation(
-      mojom::WakeLockType type,
-      mojom::WakeLockObserverPtr observer) override;
-  void GetActiveWakeLocksForTests(
-      mojom::WakeLockType type,
-      GetActiveWakeLocksForTestsCallback callback) override;
 
   // service_manager::Service:
   void OnBindInterface(const service_manager::BindSourceInfo& source_info,
                        const std::string& interface_name,
                        mojo::ScopedMessagePipeHandle interface_pipe) override;
 
-  void OnConnectionError(mojom::WakeLockType type, TestWakeLock* wake_lock);
-
  private:
-  struct WakeLockDataPerType;
-
-  // Returns |WakeLockDataPerType| associated with wake lock of type |type|.
-  WakeLockDataPerType& GetWakeLockDataPerType(mojom::WakeLockType type) const;
+  class TestWakeLock;
 
-  // Called by a wake lock when the lock is requested for the first time.
-  void OnWakeLockActivated(mojom::WakeLockType type);
+  // Called by |wake_lock| when the lock is requested for the first time.
+  void OnWakeLockActivated(TestWakeLock* wake_lock);
 
-  // Called by a wake lock when the lock is canceled for the last time.
-  void OnWakeLockDeactivated(mojom::WakeLockType type);
+  // Called by |wake_lock| when the lock is canceled for the last time.
+  void OnWakeLockDeactivated(TestWakeLock* wake_lock);
 
   service_manager::ServiceBinding service_binding_;
 
   mojo::BindingSet<mojom::WakeLockProvider> bindings_;
 
-  // Stores wake lock count and observers associated with each wake lock type.
-  std::map<mojom::WakeLockType, std::unique_ptr<WakeLockDataPerType>>
-      wake_lock_store_;
+  // Locks that have been passed to OnWakeLockRequested and haven't yet been
+  // released.
+  std::set<const TestWakeLock*> active_wake_locks_;
+
+  // Callbacks to execute when wake locks are requested or canceled.
+  base::RepeatingClosure wake_lock_requested_callback_;
+  base::RepeatingClosure wake_lock_canceled_callback_;
 
   DISALLOW_COPY_AND_ASSIGN(TestWakeLockProvider);
 };
--- a/services/device/public/mojom/bluetooth_system.mojom	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/public/mojom/bluetooth_system.mojom	2019-05-17 18:53:37.844000000 +0300
@@ -101,27 +101,19 @@
     // Unknown failure when sending the command to the BT radio.
     kFailedUnknownReason,
     // Can't use Bluetooth right now e.g. a BT radio is not present.
-    kFailedBluetoothUnavailable,
-    // Can't change the radio state right now, there is an in-progress call.
-    kFailedInProgress,
+    kBluetoothUnavailable,
   };
 
   // Attempts to change the state of the Bluetooth to `kPoweredOn` if |powered|
-  // and `kPoweredOff` otherwise . Callback is run with `kSuccess` if the
-  // command was successfully sent to the BT radio. The state immediately
-  // changes to kTransitioning and once the BT radio actually changes state
-  // BluetoothSystemClient::OnStateChanged will be called. Does not support
-  // concurrent calls.
-  //
-  // To keep the implementation simple and because no clients need it (UI
-  // clients disable the power toggle during `kTransitioning`), this function
-  // does not support concurrent calls. Meaning, if there is a pending call to
-  // SetPowered(), all new calls to SetPowered() will immediately fail with
-  // `kFailedInProgress`.
-  //
-  // TODO(https://crbug.com/896113): This function is missing one feature:
+  // and `kPoweredOff` otherwise . Callback is run with `kSuccess if the command
+  // was successfully sent to the BT radio. The state immediately changes to
+  // kTransitioning and once the BT radio actually changes state
+  // BluetoothSystemClient::OnStateChanged will be called.
+  // TODO(https://crbug.com/896113): This function is missing two features:
   //  1. The new state should be saved in the user's pref so that the next time
-  //     the machine restarts the state matches the user pref.
+  //     the machine turns off the state matches the user pref.
+  //  2. Support concurrent calls; currently BlueZ just drops other calls if
+  //     there is one in progress already.
   SetPowered(bool powered) => (SetPoweredResult result);
 
   // Whether the BT radio is scanning for devices.
@@ -145,7 +137,7 @@
     kFailedUnknownReason,
     // Can't use Bluetooth right now e.g. BT radio is off, not present, or
     // transitioning between states.
-    kFailedBluetoothUnavailable,
+    kBluetoothUnavailable,
     // TODO(https://crbug.com/897996): Add more specific error codes.
   };
 
@@ -165,7 +157,7 @@
     // Unknown failure when sending the command to the BT radio.
     kFailedUnknownReason,
     // Can't use Bluetooth right now e.g. BT radio is off, or not present.
-    kFailedBluetoothUnavailable,
+    kBluetoothUnavailable,
     // TODO(https://crbug.com/897996): Add more specific error codes.
   };
 
--- a/services/device/public/mojom/hid.mojom	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/public/mojom/hid.mojom	2019-05-17 18:53:37.844000000 +0300
@@ -16,7 +16,6 @@
 const uint16 kPageVirtualReality = 0x03;
 const uint16 kPageSport = 0x04;
 const uint16 kPageGame = 0x05;
-const uint16 kPageGenericDevice = 0x06;
 const uint16 kPageKeyboard = 0x07;
 const uint16 kPageLed = 0x08;
 const uint16 kPageButton = 0x09;
@@ -42,12 +41,10 @@
 const uint16 kPageReservedPointOfSale = 0x8F;
 const uint16 kPageCameraControl = 0x90;
 const uint16 kPageArcade = 0x91;
-const uint16 kPageFido = 0xF1D0;
 const uint16 kPageVendor = 0xFF00;
 const uint16 kPageMediaCenter = 0xFFBC;
 
-// These usage enumerations are derived from the HID Usage Tables v1.12 spec.
-// https://www.usb.org/sites/default/files/documents/hut1_12v2.pdf
+// These usage enumerations are derived from the HID Usage Tables v1.11 spec.
 const uint16 kGenericDesktopUndefined = 0x00;
 const uint16 kGenericDesktopPointer = 0x01;
 const uint16 kGenericDesktopMouse = 0x02;
@@ -118,137 +115,18 @@
 const uint16 kGenericDesktopSystemDisplayToggle = 0xb5;
 const uint16 kGenericDesktopSystemDisplaySwap = 0xb6;
 
-// These collection types are defined in section 6.2.2.6 of the Device Class
-// Definition for HID.
-// https://www.usb.org/sites/default/files/documents/hid1_11.pdf
-const uint32 kHIDCollectionTypePhysical = 0x00;
-const uint32 kHIDCollectionTypeApplication = 0x01;
-const uint32 kHIDCollectionTypeLogical = 0x02;
-const uint32 kHIDCollectionTypeReport = 0x03;
-const uint32 kHIDCollectionTypeNamedArray = 0x04;
-const uint32 kHIDCollectionTypeUsageSwitch = 0x05;
-const uint32 kHIDCollectionTypeUsageModifier = 0x06;
-const uint32 kHIDCollectionTypeVendorMin = 0x80;
-const uint32 kHIDCollectionTypeVendorMax = 0xff;
-
 struct HidUsageAndPage {
   uint16 usage;
   uint16 usage_page;
 };
 
-struct HidReportItem {
-  // True if the usages for this item are defined by |usage_minimum| and
-  // |usage_maximum|. False if the usages for this item are defined by |usages|.
-  bool is_range;
-
-  // Data associated with the Main item. See section 6.2.2.5 of the Device Class
-  // Definition for HID.
-  // https://www.usb.org/sites/default/files/documents/hid1_11.pdf
-  bool is_constant;         // Constant (true) or Data (false).
-  bool is_variable;         // Variable (true) or Array (false).
-  bool is_relative;         // Relative (true) or Absolute (false).
-  bool wrap;                // Wrap (true) or No Wrap (false).
-  bool is_non_linear;       // Non Linear (true) or Linear (false).
-  bool no_preferred_state;  // No Preferred (true) or Preferred State (false).
-  bool has_null_position;   // Null state (true) or No Null position (false).
-  bool is_volatile;         // Volatile (true) or Non Volatile (false).
-  bool is_buffered_bytes;   // Buffered Bytes (true) or Bit Field (false).
-
-  // Local items. See section 6.2.2.8 of the Device Class Definition for HID.
-  // https://www.usb.org/sites/default/files/documents/hid1_11.pdf
-
-  // If |is_range| is false, usages for this item are listed in |usages| in the
-  // order they were encountered in the report descriptor.
-  array<HidUsageAndPage> usages;
-
-  // If |is_range| is true, usages for this item are assigned from a range of
-  // usages starting at |usage_minimum| and incrementing until |usage_maximum|.
-  // If this item is a Variable and |report_count| is larger than the number of
-  // usages in this range, all remaining fields are also assigned
-  // |usage_maximum|.
-  HidUsageAndPage usage_minimum;
-  HidUsageAndPage usage_maximum;
-
-  // If this item has one or more entries in the Physical descriptor table,
-  // |designator_minimum| and |designator_maximum| are set to the minimum and
-  // maximum indices of these entries. If the item has no designators, both are
-  // set to zero. A designator describes the body part intended to be used with
-  // a particular control.
-  uint32 designator_minimum;
-  uint32 designator_maximum;
-
-  // If this item has one or more entries in the String descriptor table,
-  // |string_minimum| and |string_maximum| are set to the minimum and maximum
-  // indices of these entries. If the item has no strings, both are set to zero.
-  // The String descriptor contains a list of text strings for the device.
-  uint32 string_minimum;
-  uint32 string_maximum;
-
-  // Global items. See section 6.2.2.7 of the Device Class Definition for HID.
-  // https://www.usb.org/sites/default/files/documents/hid1_11.pdf
-
-  // |logical_minimum| and |logical_maximum| define the extent of valid data
-  // values for the item in logical units. If |has_null_position| is true,
-  // values outside this range are interpreted as null input.
-  int32 logical_minimum;
-  int32 logical_maximum;
-
-  // |physical_minimum| and |physical_maximum| define the extent of valid data
-  // values after applying units to the logical extents.
-  int32 physical_minimum;
-  int32 physical_maximum;
-
-  // The value of the unit exponent in base 10. Values between 0x0 and 0x7
-  // represent positive exponents 0 to 7, values between 0x8 and 0xF represent
-  // nevative exponents -8 to -1. Bits [4:31] are reserved and should be set to
-  // zero.
-  uint32 unit_exponent;
-
-  // The units to apply to this item. The |unit| value is coded as seven 4-bit
-  // fields that define the unit system and the exponents on units of length,
-  // mass, time, temperature, current, and luminous intensity. Bits [28:31] are
-  // reserved and should be set to zero.
-  uint32 unit;
-
-  // A single report item may define multiple same-sized fields within a report.
-  // |report_size| and |report_count| define the size of one field (in bits) and
-  // the number of fields within the item. The total size of this item in bits
-  // is equal to the product of these values.
-  uint32 report_size;
-  uint32 report_count;
-};
-
-struct HidReportDescription {
-  // Report ID associated with this report, or zero if the device does not use
-  // report IDs.
-  uint8 report_id;
-
-  // The sequence of report items that describe this report.
-  array<HidReportItem> items;
-};
-
 struct HidCollectionInfo {
   // Collection's usage ID.
   HidUsageAndPage usage;
 
-  // HID report IDs which belong to this collection or to its embedded
-  // collections, in the order they appear in the report descriptor.
-  array<uint8> report_ids;
-
-  // Collection type.
-  uint32 collection_type;
-
-  // Reports described in the report descriptor.
-  array<HidReportDescription> input_reports;
-  array<HidReportDescription> output_reports;
-  array<HidReportDescription> feature_reports;
-
-  // The children of this collection in the order they appear in the report
-  // descriptor. In child collections, the reports described in the
-  // |input_reports|, |output_reports|, and |feature_reports| members include
-  // only the subsequence of report items from the parent collection that appear
-  // within the child collection.
-  array<HidCollectionInfo> children;
+  // HID report IDs which belong to this collection or to its
+  // embedded collections.
+  array<int32> report_ids;
 };
 
 struct HidDeviceInfo {
--- a/services/device/public/mojom/nfc.mojom	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/public/mojom/nfc.mojom	2019-05-17 18:53:37.844000000 +0300
@@ -16,7 +16,7 @@
   IO_ERROR
 };
 
-enum NDEFRecordType {
+enum NFCRecordType {
   EMPTY,
   TEXT,
   URL,
@@ -46,20 +46,20 @@
   NFCErrorType error_type;
 };
 
-struct NDEFRecord {
-  // The type of NDEFRecord.
-  NDEFRecordType record_type;
+struct NFCRecord {
+  // The type of NFCRecord.
+  NFCRecordType record_type;
 
-  // Represents the IANA media type of the NDEFRecord data field.
+  // Represents the IANA media type of the NFCRecord data field.
   string? media_type;
 
-  // Payload of the NDEFRecord.
+  // Payload of the NFCRecord.
   array<uint8> data;
 };
 
-struct NDEFMessage {
-  // The body of the NDEFMessage is a collection of NDEFRecord objects.
-  array<NDEFRecord> data;
+struct NFCMessage {
+  // The body of the NFCMessage is a collection of NFCRecord objects.
+  array<NFCRecord> data;
 
   // The |url| field is an ASCII serialized origin, optionally followed by a URL
   // path. It represents Web NFC id, that can be used for matching Web NFC
@@ -82,8 +82,8 @@
   bool ignore_read;
 };
 
-struct NDEFRecordTypeFilter {
-  NDEFRecordType record_type;
+struct NFCRecordTypeFilter {
+  NFCRecordType record_type;
 };
 
 struct NFCWatchOptions {
@@ -91,7 +91,7 @@
   string? url;
 
   // Defines filtering constraint for NFC records with specified record type.
-  NDEFRecordTypeFilter? record_filter;
+  NFCRecordTypeFilter? record_filter;
 
   // Defines media type filtering constraint.
   string? media_type;
@@ -101,7 +101,7 @@
 };
 
 interface NFC {
-  // NFCClient interface is used to notify |client| when NDEFMessage matches one
+  // NFCClient interface is used to notify |client| when NFCMessage matches one
   // or more pending watch operations.
   SetClient(NFCClient client);
 
@@ -109,7 +109,7 @@
   // NFCPushOptions specify timeout and type of device where data should be
   // pushed. If timeout is defined and data is not pushed before timeout is
   // expired, callback with corresponding error is called.
-  Push(NDEFMessage message, NFCPushOptions? options) => (NFCError? error);
+  Push(NFCMessage message, NFCPushOptions? options) => (NFCError? error);
 
   // Cancels pending push request.
   CancelPush(NFCPushTarget target) => (NFCError? error);
@@ -133,5 +133,5 @@
 };
 
 interface NFCClient {
-  OnWatch(array<uint32> watch_ids, NDEFMessage message);
+  OnWatch(array<uint32> watch_ids, NFCMessage message);
 };
--- a/services/device/public/mojom/screen_orientation.mojom	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/public/mojom/screen_orientation.mojom	2019-05-17 18:53:37.844000000 +0300
@@ -12,9 +12,21 @@
   UnlockOrientation();
 };
 
-// NOTE: this could probably be merged with `ScreenOrientation`. It used to be a
-// separate service for Android Jelly Bean devices.
+// ScreenOrientationListener is expected to be used when the platform requires
+// heavy work in order to accurately know the screen orientation.
+// For example, on Android, this is required for Jelly Bean, where there is no
+// API to be notified of a screen orientation change of 180 degrees.
 interface ScreenOrientationListener {
+  // The renderer process is now using the Screen Orientation API and informs
+  // the browser process that it should start accurately listening to the screen
+  // orientation if it wasn't already.
+  Start();
+  
+  // The renderer process is no longer using the Screen Orientation API and
+  // informs the browser process that it can stop accurately listening to the
+  // screen orientation if no other process cares about it.
+  Stop();
+
   // Queries whether accelerometer auto rotation of screen orientation is
   // enabled, or the user has locked the screen orientation at the OS level.
   // This can be called at any time, whether or not the listener is started.
--- a/services/device/public/mojom/sensor.typemap	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/public/mojom/sensor.typemap	2019-05-17 18:53:37.844000000 +0300
@@ -6,9 +6,6 @@
 public_headers = [
   "//services/device/public/cpp/generic_sensor/platform_sensor_configuration.h",
 ]
-public_deps = [
-  "//services/device/public/cpp/generic_sensor:sensor_configuration",
-]
 traits_headers =
     [ "//services/device/public/cpp/generic_sensor/sensor_mojom_traits.h" ]
 sources = [
--- a/services/device/public/mojom/serial.mojom	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/public/mojom/serial.mojom	2019-05-17 18:53:37.844000000 +0300
@@ -97,9 +97,14 @@
 // Performs asynchronous I/O on serial devices.
 interface SerialPort {
   // Initiates an Open of the device then returns result.
-  Open(SerialConnectionOptions options,
-       handle<data_pipe_producer> out_stream,
-       associated SerialPortClient client) => (bool success);
+  Open(SerialConnectionOptions options) => (bool success);
+
+  // Performs a Read operation then returns retrieved data and the
+  // result. Note that the Read may succeed partially, means that even if
+  // |error| indicates an error other than NONE, |data| may still contain
+  // some retrieved data with the max size |bytes|. Behavior is undefined if
+  // this is called while a Read is already pending.
+  Read(uint32 bytes) => (array<uint8> data, SerialReceiveError error);
 
   // Performs a Write operation then returns written data and the result.
   // Note that the Write may succeed partially, means that even if |error|
@@ -108,10 +113,8 @@
   // is called while a Write is already pending.
   Write(array<uint8> data) => (uint32 bytes_written, SerialSendError error);
 
-  // Try to clear existing read error and reconnect the data pipe for read.
-  // This is supposed to be called after SerialPortClient#OnReadError is
-  // notified.
-  ClearReadError(handle<data_pipe_producer> producer);
+  // Attempts to cancel a pending read operation.
+  CancelRead(SerialReceiveError reason);
 
   // Attempts to cancel a pending write operation.
   CancelWrite(SerialSendError reason);
@@ -139,7 +142,3 @@
   // state.
   ClearBreak() => (bool success);
 };
-
-interface SerialPortClient {
-  OnReadError(SerialReceiveError error);
-};
--- a/services/device/public/mojom/wake_lock_provider.mojom	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/public/mojom/wake_lock_provider.mojom	2019-05-17 18:53:37.844000000 +0300
@@ -22,19 +22,4 @@
                             WakeLockReason reason,
                             string description,
                             WakeLock& wake_lock);
-
-  // Notifies the caller if no wake lock of type |type| is currently activated.
-  // If it is activated then the caller is notified on each deactivation event
-  // after this call.
-  NotifyOnWakeLockDeactivation(WakeLockType type, WakeLockObserver observer);
-
-  // Test-only method that returns the number of activated wake locks of type
-  // |type|.
-  GetActiveWakeLocksForTests(WakeLockType type) => (int32 count);
-};
-
-interface WakeLockObserver {
-  // Called when a wake lock of type |type| is canceled for the last time i.e.
-  // no wake lock of type |type| is held across the system.
-  OnWakeLockDeactivated(WakeLockType type);
 };
--- a/services/device/screen_orientation/android/java/borg/chromium/device/screen_orientation/ScreenOrientationListener.java	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/screen_orientation/android/java/borg/chromium/device/screen_orientation/ScreenOrientationListener.java	2019-05-17 18:53:37.848000000 +0300
@@ -7,8 +7,10 @@
 import android.provider.Settings;
 
 import org.chromium.base.ContextUtils;
+import org.chromium.base.ThreadUtils;
 import org.chromium.base.annotations.CalledByNative;
 import org.chromium.base.annotations.JNINamespace;
+import org.chromium.ui.display.DisplayAndroid;
 
 /**
  * Android implementation details for device::ScreenOrientationListenerAndroid.
@@ -16,6 +18,26 @@
 @JNINamespace("device")
 class ScreenOrientationListener {
     @CalledByNative
+    static void startAccurateListening() {
+        ThreadUtils.runOnUiThread(new Runnable() {
+            @Override
+            public void run() {
+                DisplayAndroid.startAccurateListening();
+            }
+        });
+    }
+
+    @CalledByNative
+    static void stopAccurateListening() {
+        ThreadUtils.runOnUiThread(new Runnable() {
+            @Override
+            public void run() {
+                DisplayAndroid.stopAccurateListening();
+            }
+        });
+    }
+
+    @CalledByNative
     static boolean isAutoRotateEnabledByUser() {
         return Settings.System.getInt(ContextUtils.getApplicationContext().getContentResolver(),
                        Settings.System.ACCELEROMETER_ROTATION, 0)
--- a/services/device/screen_orientation/screen_orientation_listener_android.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/screen_orientation/screen_orientation_listener_android.cc	2019-05-17 18:53:37.848000000 +0300
@@ -19,10 +19,40 @@
       std::move(request));
 }
 
-ScreenOrientationListenerAndroid::ScreenOrientationListenerAndroid() = default;
+ScreenOrientationListenerAndroid::ScreenOrientationListenerAndroid()
+    : listeners_count_(0) {}
 
 ScreenOrientationListenerAndroid::~ScreenOrientationListenerAndroid() {
   DCHECK(base::MessageLoopCurrentForIO::IsSet());
+  if (listeners_count_ > 0) {
+    Java_ScreenOrientationListener_startAccurateListening(
+        base::android::AttachCurrentThread());
+  }
+}
+
+void ScreenOrientationListenerAndroid::Start() {
+  DCHECK(base::MessageLoopCurrentForIO::IsSet());
+  ++listeners_count_;
+  if (listeners_count_ == 1) {
+    // Ask the ScreenOrientationListener (Java) to start accurately listening to
+    // the screen orientation. It keep track of the number of start request if
+    // it is already running an accurate listening.
+    Java_ScreenOrientationListener_startAccurateListening(
+        base::android::AttachCurrentThread());
+  }
+}
+
+void ScreenOrientationListenerAndroid::Stop() {
+  DCHECK(base::MessageLoopCurrentForIO::IsSet());
+  DCHECK(listeners_count_ > 0);
+  --listeners_count_;
+  if (listeners_count_ == 0) {
+    // Ask the ScreenOrientationListener (Java) to stop accurately listening to
+    // the screen orientation. It will actually stop only if the number of stop
+    // requests matches the number of start requests.
+    Java_ScreenOrientationListener_stopAccurateListening(
+        base::android::AttachCurrentThread());
+  }
 }
 
 void ScreenOrientationListenerAndroid::IsAutoRotateEnabledByUser(
--- a/services/device/screen_orientation/screen_orientation_listener_android.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/screen_orientation/screen_orientation_listener_android.h	2019-05-17 18:53:37.848000000 +0300
@@ -21,9 +21,13 @@
   ScreenOrientationListenerAndroid();
 
   // mojom::ScreenOrientationListener:
+  void Start() override;
+  void Stop() override;
   void IsAutoRotateEnabledByUser(
       IsAutoRotateEnabledByUserCallback callback) override;
 
+  int listeners_count_;
+
   DISALLOW_COPY_AND_ASSIGN(ScreenOrientationListenerAndroid);
 };
 
--- a/services/device/serial/buffer.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/serial/buffer.cc	2019-05-17 18:53:37.848000000 +0300
@@ -4,8 +4,6 @@
 
 #include "services/device/serial/buffer.h"
 
-#include <utility>
-
 #include "base/numerics/safe_conversions.h"
 #include "net/base/io_buffer.h"
 
@@ -38,7 +36,7 @@
                            static_cast<device::mojom::SerialSendError>(error));
 }
 
-ReceiveBuffer::ReceiveBuffer(char* buffer,
+ReceiveBuffer::ReceiveBuffer(scoped_refptr<net::IOBuffer> buffer,
                              uint32_t size,
                              ReceiveCompleteCallback callback)
     : buffer_(buffer), size_(size), callback_(std::move(callback)) {}
@@ -46,7 +44,7 @@
 ReceiveBuffer::~ReceiveBuffer() = default;
 
 char* ReceiveBuffer::GetData() {
-  return buffer_;
+  return buffer_->data();
 }
 
 uint32_t ReceiveBuffer::GetSize() {
--- a/services/device/serial/buffer.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/serial/buffer.h	2019-05-17 18:53:37.848000000 +0300
@@ -7,8 +7,6 @@
 
 #include <stdint.h>
 
-#include <vector>
-
 #include "base/callback.h"
 #include "net/base/io_buffer.h"
 #include "services/device/public/mojom/serial.mojom.h"
@@ -66,7 +64,9 @@
  public:
   using ReceiveCompleteCallback =
       base::OnceCallback<void(int, device::mojom::SerialReceiveError)>;
-  ReceiveBuffer(char* buffer, uint32_t size, ReceiveCompleteCallback callback);
+  ReceiveBuffer(scoped_refptr<net::IOBuffer> buffer,
+                uint32_t size,
+                ReceiveCompleteCallback callback);
   ~ReceiveBuffer() override;
 
   char* GetData() override;
@@ -75,7 +75,7 @@
   void DoneWithError(uint32_t bytes_written, int32_t error) override;
 
  private:
-  char* buffer_;
+  scoped_refptr<net::IOBuffer> buffer_;
   const uint32_t size_;
   ReceiveCompleteCallback callback_;
 };
--- a/services/device/serial/serial_device_enumerator_linux.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/serial/serial_device_enumerator_linux.cc	2019-05-17 18:53:37.848000000 +0300
@@ -41,8 +41,7 @@
 
 std::vector<mojom::SerialPortInfoPtr>
 SerialDeviceEnumeratorLinux::GetDevices() {
-  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
-                                                base::BlockingType::MAY_BLOCK);
+  base::ScopedBlockingCall scoped_blocking_call(base::BlockingType::MAY_BLOCK);
 
   std::vector<mojom::SerialPortInfoPtr> devices;
   ScopedUdevEnumeratePtr enumerate(udev_enumerate_new(udev_.get()));
--- a/services/device/serial/serial_device_enumerator_mac.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/serial/serial_device_enumerator_mac.cc	2019-05-17 18:53:37.848000000 +0300
@@ -144,8 +144,7 @@
 SerialDeviceEnumeratorMac::GetDevicesNew() {
   std::vector<mojom::SerialPortInfoPtr> devices;
 
-  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
-                                                base::BlockingType::MAY_BLOCK);
+  base::ScopedBlockingCall scoped_blocking_call(base::BlockingType::MAY_BLOCK);
   // Make a service query to find all serial devices.
   CFMutableDictionaryRef matchingDict =
       IOServiceMatching(kIOSerialBSDServiceValue);
@@ -226,8 +225,7 @@
   valid_patterns.insert("/dev/tty.*");
   valid_patterns.insert("/dev/cu.*");
 
-  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
-                                                base::BlockingType::MAY_BLOCK);
+  base::ScopedBlockingCall scoped_blocking_call(base::BlockingType::MAY_BLOCK);
   std::vector<mojom::SerialPortInfoPtr> devices;
   base::FileEnumerator enumerator(kDevRoot, false, kFilesAndSymLinks);
   do {
--- a/services/device/serial/serial_device_enumerator_win.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/serial/serial_device_enumerator_win.cc	2019-05-17 18:53:37.848000000 +0300
@@ -146,8 +146,7 @@
 SerialDeviceEnumeratorWin::GetDevicesNew() {
   std::vector<mojom::SerialPortInfoPtr> devices;
 
-  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
-                                                base::BlockingType::MAY_BLOCK);
+  base::ScopedBlockingCall scoped_blocking_call(base::BlockingType::MAY_BLOCK);
   // Make a device interface query to find all serial devices.
   HDEVINFO dev_info =
       SetupDiGetClassDevs(&GUID_DEVCLASS_PORTS, 0, 0, DIGCF_PRESENT);
@@ -204,8 +203,7 @@
 // less information about the devices than the new method.
 std::vector<mojom::SerialPortInfoPtr>
 SerialDeviceEnumeratorWin::GetDevicesOld() {
-  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
-                                                base::BlockingType::MAY_BLOCK);
+  base::ScopedBlockingCall scoped_blocking_call(base::BlockingType::MAY_BLOCK);
   base::win::RegistryValueIterator iter_key(
       HKEY_LOCAL_MACHINE, L"HARDWARE\\DEVICEMAP\\SERIALCOMM\\");
   std::vector<mojom::SerialPortInfoPtr> devices;
--- a/services/device/serial/serial_io_handler_posix.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/serial/serial_io_handler_posix.cc	2019-05-17 18:53:37.848000000 +0300
@@ -10,7 +10,6 @@
 #include <algorithm>
 #include <utility>
 
-#include "base/bind.h"
 #include "base/files/file_util.h"
 #include "base/posix/eintr_wrapper.h"
 #include "build/build_config.h"
--- a/services/device/serial/serial_port_impl.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/serial/serial_port_impl.cc	2019-05-17 18:53:37.848000000 +0300
@@ -7,7 +7,6 @@
 #include <memory>
 #include <utility>
 
-#include "base/bind.h"
 #include "base/single_thread_task_runner.h"
 #include "base/task/post_task.h"
 #include "mojo/public/cpp/bindings/strong_binding.h"
@@ -29,24 +28,28 @@
 SerialPortImpl::SerialPortImpl(
     const base::FilePath& path,
     scoped_refptr<base::SingleThreadTaskRunner> ui_task_runner)
-    : io_handler_(device::SerialIoHandler::Create(path, ui_task_runner)),
-      out_stream_watcher_(FROM_HERE, mojo::SimpleWatcher::ArmingPolicy::MANUAL),
-      weak_factory_(this) {}
+    : io_handler_(device::SerialIoHandler::Create(path, ui_task_runner)) {}
 
 SerialPortImpl::~SerialPortImpl() = default;
 
 void SerialPortImpl::Open(mojom::SerialConnectionOptionsPtr options,
-                          mojo::ScopedDataPipeProducerHandle out_stream,
-                          mojom::SerialPortClientAssociatedPtrInfo client,
                           OpenCallback callback) {
-  DCHECK(out_stream);
-  out_stream_ = std::move(out_stream);
-  if (client) {
-    client_.Bind(std::move(client));
-  }
-  io_handler_->Open(*options, base::BindOnce(&SerialPortImpl::OnOpenCompleted,
-                                             weak_factory_.GetWeakPtr(),
-                                             std::move(callback)));
+  io_handler_->Open(*options, std::move(callback));
+}
+
+void SerialPortImpl::Read(uint32_t bytes, ReadCallback callback) {
+  auto buffer = base::MakeRefCounted<net::IOBuffer>(static_cast<size_t>(bytes));
+  io_handler_->Read(std::make_unique<ReceiveBuffer>(
+      buffer, bytes,
+      base::BindOnce(
+          [](ReadCallback callback, scoped_refptr<net::IOBuffer> buffer,
+             int bytes_read, mojom::SerialReceiveError error) {
+            std::move(callback).Run(
+                std::vector<uint8_t>(buffer->data(),
+                                     buffer->data() + bytes_read),
+                error);
+          },
+          std::move(callback), buffer)));
 }
 
 void SerialPortImpl::Write(const std::vector<uint8_t>& data,
@@ -60,22 +63,8 @@
                 std::move(callback))));
 }
 
-void SerialPortImpl::ClearReadError(
-    mojo::ScopedDataPipeProducerHandle producer) {
-  // Make sure |io_handler_| is still open and the |out_stream_| has been
-  // closed.
-  if (!io_handler_ || out_stream_) {
-    return;
-  }
-  out_stream_watcher_.Cancel();
-  out_stream_.swap(producer);
-  out_stream_watcher_.Watch(
-      out_stream_.get(),
-      MOJO_HANDLE_SIGNAL_WRITABLE | MOJO_HANDLE_SIGNAL_PEER_CLOSED,
-      MOJO_TRIGGER_CONDITION_SIGNALS_SATISFIED,
-      base::BindRepeating(&SerialPortImpl::ReadFromPortAndWriteOut,
-                          weak_factory_.GetWeakPtr()));
-  out_stream_watcher_.ArmOrNotify();
+void SerialPortImpl::CancelRead(mojom::SerialReceiveError reason) {
+  io_handler_->CancelRead(reason);
 }
 
 void SerialPortImpl::CancelWrite(mojom::SerialSendError reason) {
@@ -99,8 +88,6 @@
 void SerialPortImpl::ConfigurePort(mojom::SerialConnectionOptionsPtr options,
                                    ConfigurePortCallback callback) {
   std::move(callback).Run(io_handler_->ConfigurePort(*options));
-  // Cancel pending reading as the new configure options are applied.
-  io_handler_->CancelRead(mojom::SerialReceiveError::NONE);
 }
 
 void SerialPortImpl::GetPortInfo(GetPortInfoCallback callback) {
@@ -115,61 +102,4 @@
   std::move(callback).Run(io_handler_->ClearBreak());
 }
 
-void SerialPortImpl::OnOpenCompleted(OpenCallback callback, bool success) {
-  if (success) {
-    out_stream_watcher_.Watch(
-        out_stream_.get(),
-        MOJO_HANDLE_SIGNAL_WRITABLE | MOJO_HANDLE_SIGNAL_PEER_CLOSED,
-        MOJO_TRIGGER_CONDITION_SIGNALS_SATISFIED,
-        base::BindRepeating(&SerialPortImpl::ReadFromPortAndWriteOut,
-                            weak_factory_.GetWeakPtr()));
-    out_stream_watcher_.ArmOrNotify();
-  }
-  std::move(callback).Run(success);
-}
-
-void SerialPortImpl::ReadFromPortAndWriteOut(
-    MojoResult result,
-    const mojo::HandleSignalsState& state) {
-  void* buffer;
-  uint32_t num_bytes;
-  if (result == MOJO_RESULT_OK) {
-    result = out_stream_->BeginWriteData(&buffer, &num_bytes,
-                                         MOJO_WRITE_DATA_FLAG_NONE);
-  }
-  if (result == MOJO_RESULT_OK) {
-    io_handler_->Read(std::make_unique<ReceiveBuffer>(
-        static_cast<char*>(buffer), num_bytes,
-        base::BindOnce(&SerialPortImpl::WriteToOutStream,
-                       weak_factory_.GetWeakPtr())));
-    return;
-  }
-  if (result == MOJO_RESULT_SHOULD_WAIT) {
-    // If there is no space to write, wait for more space.
-    out_stream_watcher_.ArmOrNotify();
-    return;
-  }
-  if (result == MOJO_RESULT_FAILED_PRECONDITION) {
-    // The |out_stream_| has been closed.
-    out_stream_.reset();
-    return;
-  }
-  // The code should not reach other cases.
-  NOTREACHED();
-}
-
-void SerialPortImpl::WriteToOutStream(int bytes_read,
-                                      mojom::SerialReceiveError error) {
-  out_stream_->EndWriteData(static_cast<uint32_t>(bytes_read));
-
-  if (error != mojom::SerialReceiveError::NONE) {
-    out_stream_.reset();
-    if (client_) {
-      client_->OnReadError(error);
-    }
-    return;
-  }
-  out_stream_watcher_.ArmOrNotify();
-}
-
 }  // namespace device
--- a/services/device/serial/serial_port_impl.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/serial/serial_port_impl.h	2019-05-17 18:53:37.848000000 +0300
@@ -10,9 +10,6 @@
 
 #include "base/macros.h"
 #include "base/memory/ref_counted.h"
-#include "base/memory/weak_ptr.h"
-#include "mojo/public/cpp/system/data_pipe.h"
-#include "mojo/public/cpp/system/simple_watcher.h"
 #include "services/device/public/mojom/serial.mojom.h"
 
 namespace base {
@@ -41,11 +38,10 @@
  private:
   // mojom::SerialPort methods:
   void Open(mojom::SerialConnectionOptionsPtr options,
-            mojo::ScopedDataPipeProducerHandle out_stream,
-            mojom::SerialPortClientAssociatedPtrInfo client,
             OpenCallback callback) override;
+  void Read(uint32_t bytes, ReadCallback callback) override;
   void Write(const std::vector<uint8_t>& data, WriteCallback callback) override;
-  void ClearReadError(mojo::ScopedDataPipeProducerHandle producer) override;
+  void CancelRead(mojom::SerialReceiveError reason) override;
   void CancelWrite(mojom::SerialSendError reason) override;
   void Flush(FlushCallback callback) override;
   void GetControlSignals(GetControlSignalsCallback callback) override;
@@ -57,17 +53,8 @@
   void SetBreak(SetBreakCallback callback) override;
   void ClearBreak(ClearBreakCallback callback) override;
 
-  void OnOpenCompleted(OpenCallback callback, bool success);
-  void ReadFromPortAndWriteOut(MojoResult result,
-                               const mojo::HandleSignalsState& state);
-  void WriteToOutStream(int bytes_read, mojom::SerialReceiveError error);
-
   scoped_refptr<SerialIoHandler> io_handler_;
-  mojom::SerialPortClientAssociatedPtr client_;
-  mojo::ScopedDataPipeProducerHandle out_stream_;
-  mojo::SimpleWatcher out_stream_watcher_;
 
-  base::WeakPtrFactory<SerialPortImpl> weak_factory_;
   DISALLOW_COPY_AND_ASSIGN(SerialPortImpl);
 };
 
--- a/services/device/serial/serial_port_manager_impl.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/serial/serial_port_manager_impl.cc	2019-05-17 18:53:37.852000000 +0300
@@ -7,7 +7,6 @@
 #include <string>
 #include <utility>
 
-#include "base/bind.h"
 #include "base/sequenced_task_runner.h"
 #include "mojo/public/cpp/bindings/strong_binding.h"
 #include "services/device/serial/serial_device_enumerator.h"
--- a/services/device/serial/serial_port_manager_impl_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/serial/serial_port_manager_impl_unittest.cc	2019-05-17 18:53:37.852000000 +0300
@@ -9,7 +9,6 @@
 #include <utility>
 #include <vector>
 
-#include "base/bind.h"
 #include "base/macros.h"
 #include "base/message_loop/message_loop.h"
 #include "base/task/post_task.h"
@@ -87,19 +86,24 @@
 
 class SerialPortManagerImplTest : public DeviceServiceTestBase {
  public:
-  SerialPortManagerImplTest() = default;
+  SerialPortManagerImplTest() {
+    blockable_runner_ = base::CreateSequencedTaskRunnerWithTraits(
+        {base::MayBlock(), base::TaskPriority::BEST_EFFORT});
+  }
   ~SerialPortManagerImplTest() override = default;
 
  protected:
   void SetUp() override { DeviceServiceTestBase::SetUp(); }
 
   void BindSerialPortManager(mojom::SerialPortManagerRequest request) {
-    file_task_runner_->PostTask(
-        FROM_HERE,
-        base::BindOnce(&CreateAndBindOnBlockableRunner, std::move(request),
-                       io_task_runner_, base::ThreadTaskRunnerHandle::Get()));
+    blockable_runner_->PostTask(
+        FROM_HERE, base::BindOnce(&CreateAndBindOnBlockableRunner,
+                                  std::move(request), io_thread_.task_runner(),
+                                  base::ThreadTaskRunnerHandle::Get()));
   }
 
+  scoped_refptr<base::SequencedTaskRunner> blockable_runner_;
+
   DISALLOW_COPY_AND_ASSIGN(SerialPortManagerImplTest);
 };
 
--- a/services/device/time_zone_monitor/time_zone_monitor_linux.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/time_zone_monitor/time_zone_monitor_linux.cc	2019-05-17 18:53:37.852000000 +0300
@@ -94,7 +94,7 @@
                             base::RetainedRef(this));
 
     base::ScopedBlockingCall scoped_blocking_call(
-        FROM_HERE, base::BlockingType::MAY_BLOCK);
+        base::BlockingType::MAY_BLOCK);
 
     // There is no true standard for where time zone information is actually
     // stored. glibc uses /etc/localtime, uClibc uses /etc/TZ, and some older
--- a/services/device/wake_lock/power_save_blocker/BUILD.gn	2019-05-17 17:45:28.340000000 +0300
+++ b/services/device/wake_lock/power_save_blocker/BUILD.gn	2019-05-17 18:53:37.856000000 +0300
@@ -62,9 +62,6 @@
   if (is_chromeos || !use_x11 || !use_dbus) {
     sources -= [ "power_save_blocker_x11.cc" ]
   }
-  if (!is_chromeos && use_x11 && !use_dbus) {
-    sources += [ "power_save_blocker_ozone.cc" ]
-  }
 
   if (is_android) {
     deps += [ ":jni_headers" ]
--- a/services/device/wake_lock/power_save_blocker/power_save_blocker_android.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/wake_lock/power_save_blocker/power_save_blocker_android.cc	2019-05-17 18:53:37.856000000 +0300
@@ -79,8 +79,8 @@
 
 PowerSaveBlocker::~PowerSaveBlocker() {
   if (delegate_.get()) {
-    ui_task_runner_->PostTask(
-        FROM_HERE, base::BindOnce(&Delegate::RemoveBlock, delegate_));
+    ui_task_runner_->PostTask(FROM_HERE,
+                              base::Bind(&Delegate::RemoveBlock, delegate_));
   }
 }
 
--- a/services/device/wake_lock/power_save_blocker/power_save_blocker_chromeos.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/wake_lock/power_save_blocker/power_save_blocker_chromeos.cc	2019-05-17 18:53:37.856000000 +0300
@@ -106,12 +106,12 @@
       ui_task_runner_(ui_task_runner),
       blocking_task_runner_(blocking_task_runner) {
   ui_task_runner_->PostTask(FROM_HERE,
-                            base::BindOnce(&Delegate::ApplyBlock, delegate_));
+                            base::Bind(&Delegate::ApplyBlock, delegate_));
 }
 
 PowerSaveBlocker::~PowerSaveBlocker() {
   ui_task_runner_->PostTask(FROM_HERE,
-                            base::BindOnce(&Delegate::RemoveBlock, delegate_));
+                            base::Bind(&Delegate::RemoveBlock, delegate_));
 }
 
 }  // namespace device
--- a/services/device/wake_lock/power_save_blocker/power_save_blocker_mac.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/wake_lock/power_save_blocker/power_save_blocker_mac.cc	2019-05-17 18:53:37.856000000 +0300
@@ -111,12 +111,12 @@
       ui_task_runner_(ui_task_runner),
       blocking_task_runner_(blocking_task_runner) {
   g_power_thread.Pointer()->task_runner()->PostTask(
-      FROM_HERE, base::BindOnce(&Delegate::ApplyBlock, delegate_));
+      FROM_HERE, base::Bind(&Delegate::ApplyBlock, delegate_));
 }
 
 PowerSaveBlocker::~PowerSaveBlocker() {
   g_power_thread.Pointer()->task_runner()->PostTask(
-      FROM_HERE, base::BindOnce(&Delegate::RemoveBlock, delegate_));
+      FROM_HERE, base::Bind(&Delegate::RemoveBlock, delegate_));
 }
 
 }  // namespace device
--- a/services/device/wake_lock/power_save_blocker/power_save_blocker_win.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/wake_lock/power_save_blocker/power_save_blocker_win.cc	2019-05-17 18:53:37.856000000 +0300
@@ -119,12 +119,12 @@
       ui_task_runner_(ui_task_runner),
       blocking_task_runner_(blocking_task_runner) {
   ui_task_runner_->PostTask(FROM_HERE,
-                            base::BindOnce(&Delegate::ApplyBlock, delegate_));
+                            base::Bind(&Delegate::ApplyBlock, delegate_));
 }
 
 PowerSaveBlocker::~PowerSaveBlocker() {
   ui_task_runner_->PostTask(FROM_HERE,
-                            base::BindOnce(&Delegate::RemoveBlock, delegate_));
+                            base::Bind(&Delegate::RemoveBlock, delegate_));
 }
 
 }  // namespace device
--- a/services/device/wake_lock/power_save_blocker/power_save_blocker_x11.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/wake_lock/power_save_blocker/power_save_blocker_x11.cc	2019-05-17 18:53:37.856000000 +0300
@@ -187,7 +187,7 @@
   unblock_inflight_ = false;
   enqueue_unblock_ = false;
   ui_task_runner_->PostTask(FROM_HERE,
-                            base::BindOnce(&Delegate::InitOnUIThread, this));
+                            base::Bind(&Delegate::InitOnUIThread, this));
 }
 
 void PowerSaveBlocker::Delegate::CleanUp() {
@@ -199,12 +199,12 @@
     enqueue_apply_ = false;
   } else {
     if (ShouldBlock()) {
-      blocking_task_runner_->PostTask(
-          FROM_HERE, base::BindOnce(&Delegate::RemoveBlock, this));
+      blocking_task_runner_->PostTask(FROM_HERE,
+                                      base::Bind(&Delegate::RemoveBlock, this));
     }
 
     ui_task_runner_->PostTask(
-        FROM_HERE, base::BindOnce(&Delegate::XSSSuspendSet, this, false));
+        FROM_HERE, base::Bind(&Delegate::XSSSuspendSet, this, false));
   }
 }
 
@@ -219,8 +219,8 @@
       // D-Bus library, so we need to use the same thread above for
       // RemoveBlock(). It must be a thread that allows I/O operations, so we
       // use the FILE thread.
-      blocking_task_runner_->PostTask(
-          FROM_HERE, base::BindOnce(&Delegate::ApplyBlock, this));
+      blocking_task_runner_->PostTask(FROM_HERE,
+                                      base::Bind(&Delegate::ApplyBlock, this));
     }
     XSSSuspendSet(true);
   }
@@ -334,8 +334,8 @@
     enqueue_unblock_ = false;
     // RemoveBlock() was called while the Inhibit operation was in flight,
     // so go ahead and remove the block now.
-    blocking_task_runner_->PostTask(
-        FROM_HERE, base::BindOnce(&Delegate::RemoveBlock, this));
+    blocking_task_runner_->PostTask(FROM_HERE,
+                                    base::Bind(&Delegate::RemoveBlock, this));
   }
 }
 
--- a/services/device/wake_lock/wake_lock.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/wake_lock/wake_lock.cc	2019-05-17 18:53:37.856000000 +0300
@@ -3,7 +3,6 @@
 // found in the LICENSE file.
 
 #include "services/device/wake_lock/wake_lock.h"
-#include "base/bind.h"
 
 #include <utility>
 
@@ -52,7 +51,6 @@
 void WakeLock::RequestWakeLock() {
   DCHECK(main_task_runner_->RunsTasksInCurrentSequence());
   DCHECK(binding_set_.dispatch_context());
-  DCHECK_GE(num_lock_requests_, 0);
 
   // Uses the Context to get the outstanding status of current binding.
   // Two consecutive requests from the same client should be coalesced
@@ -70,8 +68,6 @@
   DCHECK(main_task_runner_->RunsTasksInCurrentSequence());
   DCHECK(binding_set_.dispatch_context());
 
-  // TODO(crbug.com/935063): Calling CancelWakeLock befoe RequestWakeLock
-  // shouldn't be allowed.
   if (!(*binding_set_.dispatch_context()))
     return;
 
@@ -100,12 +96,8 @@
   mojom::WakeLockType old_type = type_;
   type_ = type;
 
-  if (type_ != old_type && wake_lock_) {
+  if (type_ != old_type && wake_lock_)
     SwapWakeLock();
-    for (auto& observer : observers_) {
-      observer.OnWakeLockChanged(old_type, type_);
-    }
-  }
 
   std::move(callback).Run(true);
 }
@@ -178,11 +170,7 @@
   }
 
   if (binding_set_.empty()) {
-    // In reality there is only one observer to this class i.e.
-    // WakeLockProvider, it will take care of deleting this object as it owns
-    // it.
-    for (auto& observer : observers_)
-      observer.OnConnectionError(type_, this);
+    base::ThreadTaskRunnerHandle::Get()->DeleteSoon(FROM_HERE, this);
   }
 }
 
--- a/services/device/wake_lock/wake_lock.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/wake_lock/wake_lock.h	2019-05-17 18:53:37.856000000 +0300
@@ -49,11 +49,6 @@
     // number of holders goes to 0.
     virtual void OnWakeLockDeactivated(mojom::WakeLockType type) {}
 
-    // Called when the tracked wake lock's type is changed via ChangeType.
-    // |old_type| refers to its old type and new type refers to its new type.
-    virtual void OnWakeLockChanged(mojom::WakeLockType old_type,
-                                   mojom::WakeLockType new_type) {}
-
     // Called when |WakeLock| has no bindings left.
     virtual void OnConnectionError(mojom::WakeLockType type,
                                    WakeLock* wake_lock) {}
--- a/services/device/wake_lock/wake_lock_provider.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/wake_lock/wake_lock_provider.cc	2019-05-17 18:53:37.856000000 +0300
@@ -13,46 +13,23 @@
 
 namespace device {
 
-// Holds the state associated with wake locks of a single type across the
-// system i.e. if 3 |kAppSuspension| wake locks are currently held the |count|
-// would be 3.
-struct WakeLockProvider::WakeLockDataPerType {
-  WakeLockDataPerType() = default;
-  WakeLockDataPerType(WakeLockDataPerType&&) = default;
-  ~WakeLockDataPerType() = default;
-
-  // Currently activated wake locks of this wake lock type.
-  int64_t count = 0;
-
-  // Map of all wake locks of this type created by this provider. An entry is
-  // removed from this map when an |OnConnectionError| is received.
-  std::map<WakeLock*, std::unique_ptr<WakeLock>> wake_locks;
-
-  // Observers for this wake lock type.
-  mojo::InterfacePtrSet<mojom::WakeLockObserver> observers;
-
-  DISALLOW_COPY_AND_ASSIGN(WakeLockDataPerType);
-};
+// static
+void WakeLockProvider::Create(
+    mojom::WakeLockProviderRequest request,
+    scoped_refptr<base::SingleThreadTaskRunner> file_task_runner,
+    const WakeLockContextCallback& native_view_getter) {
+  mojo::MakeStrongBinding(std::make_unique<WakeLockProvider>(
+                              std::move(file_task_runner), native_view_getter),
+                          std::move(request));
+}
 
 WakeLockProvider::WakeLockProvider(
     scoped_refptr<base::SingleThreadTaskRunner> file_task_runner,
     const WakeLockContextCallback& native_view_getter)
     : file_task_runner_(std::move(file_task_runner)),
-      native_view_getter_(native_view_getter) {
-  // Populates |wake_lock_store_| with entries for all types of wake locks.
-  wake_lock_store_[mojom::WakeLockType::kPreventAppSuspension] =
-      std::make_unique<WakeLockDataPerType>();
-  wake_lock_store_[mojom::WakeLockType::kPreventDisplaySleep] =
-      std::make_unique<WakeLockDataPerType>();
-  wake_lock_store_[mojom::WakeLockType::kPreventDisplaySleepAllowDimming] =
-      std::make_unique<WakeLockDataPerType>();
-}
+      native_view_getter_(native_view_getter) {}
 
-WakeLockProvider::~WakeLockProvider() = default;
-
-void WakeLockProvider::AddBinding(mojom::WakeLockProviderRequest request) {
-  bindings_.AddBinding(this, std::move(request));
-}
+WakeLockProvider::~WakeLockProvider() {}
 
 void WakeLockProvider::GetWakeLockContextForID(
     int context_id,
@@ -69,78 +46,10 @@
     mojom::WakeLockReason reason,
     const std::string& description,
     mojom::WakeLockRequest request) {
-  std::unique_ptr<WakeLock> wake_lock =
-      std::make_unique<WakeLock>(std::move(request), type, reason, description,
-                                 WakeLockContext::WakeLockInvalidContextId,
-                                 native_view_getter_, file_task_runner_);
-  wake_lock->AddObserver(this);
-  GetWakeLockDataPerType(type).wake_locks[wake_lock.get()] =
-      std::move(wake_lock);
-}
-
-void WakeLockProvider::NotifyOnWakeLockDeactivation(
-    mojom::WakeLockType type,
-    mojom::WakeLockObserverPtr observer) {
-  // If |type| is not held then notify the observer immediately. Add it to the
-  // observer list for future deactivation notifications.
-  if (GetWakeLockDataPerType(type).count == 0) {
-    observer->OnWakeLockDeactivated(type);
-  }
-  GetWakeLockDataPerType(type).observers.AddPtr(std::move(observer));
-}
-
-void WakeLockProvider::GetActiveWakeLocksForTests(
-    mojom::WakeLockType type,
-    GetActiveWakeLocksForTestsCallback callback) {
-  std::move(callback).Run(GetWakeLockDataPerType(type).count);
-}
-
-void WakeLockProvider::OnWakeLockActivated(mojom::WakeLockType type) {
-  DVLOG(1) << __func__;
-  const int64_t old_count = GetWakeLockDataPerType(type).count;
-  DCHECK_GE(old_count, 0);
-
-  GetWakeLockDataPerType(type).count = old_count + 1;
-}
-
-void WakeLockProvider::OnWakeLockDeactivated(mojom::WakeLockType type) {
-  DVLOG(1) << __func__;
-  const int64_t old_count = GetWakeLockDataPerType(type).count;
-  DCHECK_GT(old_count, 0);
-
-  const int64_t new_count = old_count - 1;
-  GetWakeLockDataPerType(type).count = new_count;
-  // Notify observers of the last cancelation i.e. deactivation of wake lock
-  // type |type|.
-  if (new_count == 0) {
-    GetWakeLockDataPerType(type).observers.ForAllPtrs(
-        [type](mojom::WakeLockObserver* wake_lock_observer) {
-          wake_lock_observer->OnWakeLockDeactivated(type);
-        });
-  }
-}
-
-void WakeLockProvider::OnWakeLockChanged(mojom::WakeLockType old_type,
-                                         mojom::WakeLockType new_type) {
-  // This event is only received iff |old_type| had just one client. A change
-  // event means there is one less wake lock of |old_type| i.e. the same path
-  // as the deactivation event needs to be triggered.
-  OnWakeLockDeactivated(old_type);
-  OnWakeLockActivated(new_type);
-}
-
-void WakeLockProvider::OnConnectionError(mojom::WakeLockType type,
-                                         WakeLock* wake_lock) {
-  size_t result = GetWakeLockDataPerType(type).wake_locks.erase(wake_lock);
-  DCHECK_GT(result, 0UL);
-}
-
-WakeLockProvider::WakeLockDataPerType& WakeLockProvider::GetWakeLockDataPerType(
-    mojom::WakeLockType type) {
-  auto it = wake_lock_store_.find(type);
-  // An entry for |type| should always be created in the constructor.
-  DCHECK(it != wake_lock_store_.end());
-  return *(it->second);
+  // WakeLock owns itself.
+  new WakeLock(std::move(request), type, reason, description,
+               WakeLockContext::WakeLockInvalidContextId, native_view_getter_,
+               file_task_runner_);
 }
 
 }  // namespace device
--- a/services/device/wake_lock/wake_lock_provider.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/wake_lock/wake_lock_provider.h	2019-05-17 18:53:37.856000000 +0300
@@ -5,34 +5,29 @@
 #ifndef SERVICES_DEVICE_WAKE_LOCK_WAKE_LOCK_PROVIDER_H_
 #define SERVICES_DEVICE_WAKE_LOCK_WAKE_LOCK_PROVIDER_H_
 
-#include <map>
-#include <memory>
-#include <string>
-
 #include "base/sequenced_task_runner.h"
 #include "base/single_thread_task_runner.h"
-#include "mojo/public/cpp/bindings/interface_ptr_set.h"
 #include "mojo/public/cpp/bindings/interface_request.h"
 #include "services/device/public/mojom/wake_lock_context.mojom.h"
 #include "services/device/public/mojom/wake_lock_provider.mojom.h"
-#include "services/device/wake_lock/wake_lock.h"
 #include "services/device/wake_lock/wake_lock_context.h"
 #include "ui/gfx/native_widget_types.h"
 
 namespace device {
 
 // Serves requests for WakeLockContext connections.
-class WakeLockProvider : public mojom::WakeLockProvider,
-                         public device::WakeLock::Observer {
+class WakeLockProvider : public mojom::WakeLockProvider {
  public:
   WakeLockProvider(scoped_refptr<base::SingleThreadTaskRunner> file_task_runner,
                    const WakeLockContextCallback& native_view_getter);
   ~WakeLockProvider() override;
 
-  // Adds this request to |bindings_|.
-  void AddBinding(mojom::WakeLockProviderRequest request);
+  static void Create(
+      mojom::WakeLockProviderRequest request,
+      scoped_refptr<base::SingleThreadTaskRunner> file_task_runner,
+      const WakeLockContextCallback& native_view_getter);
 
-  // mojom::WakeLockProvider overrides.
+  // mojom::WakeLockProvider:
   void GetWakeLockContextForID(
       int context_id,
       mojo::InterfaceRequest<mojom::WakeLockContext> request) override;
@@ -36,42 +31,18 @@
   void GetWakeLockContextForID(
       int context_id,
       mojo::InterfaceRequest<mojom::WakeLockContext> request) override;
+
   void GetWakeLockWithoutContext(mojom::WakeLockType type,
                                  mojom::WakeLockReason reason,
                                  const std::string& description,
                                  mojom::WakeLockRequest request) override;
-  void NotifyOnWakeLockDeactivation(
-      mojom::WakeLockType type,
-      mojom::WakeLockObserverPtr observer) override;
-  void GetActiveWakeLocksForTests(
-      mojom::WakeLockType type,
-      GetActiveWakeLocksForTestsCallback callback) override;
-
-  // device::WakeLock:Observer overrides.
-  void OnWakeLockActivated(mojom::WakeLockType type) override;
-  void OnWakeLockDeactivated(mojom::WakeLockType type) override;
-  void OnWakeLockChanged(mojom::WakeLockType old_type,
-                         mojom::WakeLockType new_type) override;
-  void OnConnectionError(mojom::WakeLockType type,
-                         WakeLock* wake_lock) override;
 
  private:
-  struct WakeLockDataPerType;
-
-  // Returns |WakeLockDataPerType| associated with wake lock of type |type|.
-  WakeLockDataPerType& GetWakeLockDataPerType(mojom::WakeLockType type);
-
   scoped_refptr<base::SingleThreadTaskRunner> file_task_runner_;
   WakeLockContextCallback native_view_getter_;
 
-  mojo::BindingSet<mojom::WakeLockProvider> bindings_;
-
-  // Stores wake lock count and observers associated with each wake lock type.
-  std::map<mojom::WakeLockType, std::unique_ptr<WakeLockDataPerType>>
-      wake_lock_store_;
-
   DISALLOW_COPY_AND_ASSIGN(WakeLockProvider);
-};  // namespace device
+};
 
 }  // namespace device
 
--- a/services/device/wake_lock/wake_lock_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/device/wake_lock/wake_lock_unittest.cc	2019-05-17 18:53:37.856000000 +0300
@@ -4,13 +4,8 @@
 
 #include "services/device/wake_lock/wake_lock.h"
 
-#include <map>
-#include <utility>
-
-#include "base/bind.h"
 #include "base/run_loop.h"
 #include "mojo/public/cpp/bindings/interface_ptr.h"
-#include "mojo/public/cpp/bindings/interface_ptr_set.h"
 #include "services/device/device_service_test_base.h"
 #include "services/device/public/mojom/constants.mojom.h"
 #include "services/device/public/mojom/wake_lock.mojom.h"
@@ -22,47 +17,6 @@
 
 namespace {
 
-class TestWakeLockObserver : public mojom::WakeLockObserver {
- public:
-  TestWakeLockObserver() {
-    wake_lock_events_.emplace(mojom::WakeLockType::kPreventAppSuspension,
-                              EventCount());
-    wake_lock_events_.emplace(mojom::WakeLockType::kPreventDisplaySleep,
-                              EventCount());
-    wake_lock_events_.emplace(
-        mojom::WakeLockType::kPreventDisplaySleepAllowDimming, EventCount());
-  }
-
-  ~TestWakeLockObserver() override = default;
-
-  void AddBinding(mojom::WakeLockObserverRequest request) {
-    bindings_.AddBinding(this, std::move(request));
-  }
-
-  // mojom::WakeLockObserver overrides.
-  void OnWakeLockDeactivated(mojom::WakeLockType type) override {
-    wake_lock_events_[type].on_deactivation_count++;
-  }
-
-  // Returns the number of calls to |OnWakeLockDeactivated|.
-  int64_t GetOnDeactivationCount(mojom::WakeLockType type) {
-    DCHECK(wake_lock_events_.find(type) != wake_lock_events_.end());
-    return wake_lock_events_[type].on_deactivation_count;
-  }
-
- private:
-  struct EventCount {
-    int64_t on_activation_count = 0;
-    int64_t on_deactivation_count = 0;
-  };
-
-  mojo::BindingSet<mojom::WakeLockObserver> bindings_;
-
-  std::map<mojom::WakeLockType, EventCount> wake_lock_events_;
-
-  DISALLOW_COPY_AND_ASSIGN(TestWakeLockObserver);
-};
-
 class WakeLockTest : public DeviceServiceTestBase {
  public:
   WakeLockTest() = default;
@@ -74,8 +28,8 @@
     connector()->BindInterface(mojom::kServiceName, &wake_lock_provider_);
 
     wake_lock_provider_->GetWakeLockWithoutContext(
-        mojom::WakeLockType::kPreventAppSuspension,
-        mojom::WakeLockReason::kOther, "WakeLockTest",
+        device::mojom::WakeLockType::kPreventAppSuspension,
+        device::mojom::WakeLockReason::kOther, "WakeLockTest",
         mojo::MakeRequest(&wake_lock_));
   }
 
@@ -89,7 +43,7 @@
     quit_closure.Run();
   }
 
-  bool ChangeType(mojom::WakeLockType type) {
+  bool ChangeType(device::mojom::WakeLockType type) {
     result_ = false;
 
     base::RunLoop run_loop;
@@ -113,22 +67,6 @@
     return has_wakelock_;
   }
 
-  // Returns the number of active wake locks of type |type|.
-  int GetActiveWakeLocks(mojom::WakeLockType type) {
-    base::RunLoop run_loop;
-    int result_count = 0;
-    wake_lock_provider_->GetActiveWakeLocksForTests(
-        type,
-        base::BindOnce(
-            [](base::RunLoop* run_loop, int* result_count, int32_t count) {
-              *result_count = count;
-              run_loop->Quit();
-            },
-            &run_loop, &result_count));
-    run_loop.Run();
-    return result_count;
-  }
-
   bool has_wakelock_;
   bool result_;
 
@@ -144,29 +82,23 @@
 
   wake_lock_->RequestWakeLock();
   EXPECT_TRUE(HasWakeLock());
-  EXPECT_EQ(1, GetActiveWakeLocks(mojom::WakeLockType::kPreventAppSuspension));
 
   wake_lock_->CancelWakeLock();
   EXPECT_FALSE(HasWakeLock());
-  EXPECT_EQ(0, GetActiveWakeLocks(mojom::WakeLockType::kPreventAppSuspension));
 }
 
 // Cancel a wake lock first, which should have no effect.
 TEST_F(WakeLockTest, CancelThenRequest) {
   EXPECT_FALSE(HasWakeLock());
-  EXPECT_EQ(0, GetActiveWakeLocks(mojom::WakeLockType::kPreventAppSuspension));
 
   wake_lock_->CancelWakeLock();
   EXPECT_FALSE(HasWakeLock());
-  EXPECT_EQ(0, GetActiveWakeLocks(mojom::WakeLockType::kPreventAppSuspension));
 
   wake_lock_->RequestWakeLock();
   EXPECT_TRUE(HasWakeLock());
-  EXPECT_EQ(1, GetActiveWakeLocks(mojom::WakeLockType::kPreventAppSuspension));
 
   wake_lock_->CancelWakeLock();
   EXPECT_FALSE(HasWakeLock());
-  EXPECT_EQ(0, GetActiveWakeLocks(mojom::WakeLockType::kPreventAppSuspension));
 }
 
 // Send multiple requests, which should be coalesced as one request.
@@ -177,11 +109,9 @@
   wake_lock_->RequestWakeLock();
   wake_lock_->RequestWakeLock();
   EXPECT_TRUE(HasWakeLock());
-  EXPECT_EQ(1, GetActiveWakeLocks(mojom::WakeLockType::kPreventAppSuspension));
 
   wake_lock_->CancelWakeLock();
   EXPECT_FALSE(HasWakeLock());
-  EXPECT_EQ(0, GetActiveWakeLocks(mojom::WakeLockType::kPreventAppSuspension));
 }
 
 // Test Change Type. ChangeType() has no effect when wake lock is shared by
@@ -194,53 +124,20 @@
   EXPECT_TRUE(ChangeType(device::mojom::WakeLockType::kPreventDisplaySleep));
   EXPECT_TRUE(ChangeType(
       device::mojom::WakeLockType::kPreventDisplaySleepAllowDimming));
-  // Still inactive.
-  EXPECT_FALSE(HasWakeLock());
-  EXPECT_EQ(0, GetActiveWakeLocks(mojom::WakeLockType::kPreventAppSuspension));
-  EXPECT_EQ(0, GetActiveWakeLocks(mojom::WakeLockType::kPreventDisplaySleep));
-  EXPECT_EQ(0, GetActiveWakeLocks(
-                   mojom::WakeLockType::kPreventDisplaySleepAllowDimming));
+  EXPECT_FALSE(HasWakeLock());  // still inactive.
 
-  // At this point the wake lock is of type |kPreventDisplaySleepAllowDimming|.
-  // Check for activation count of that type.
   wake_lock_->RequestWakeLock();
   EXPECT_TRUE(HasWakeLock());
-  EXPECT_EQ(0, GetActiveWakeLocks(mojom::WakeLockType::kPreventAppSuspension));
-  EXPECT_EQ(0, GetActiveWakeLocks(mojom::WakeLockType::kPreventDisplaySleep));
-  EXPECT_EQ(1, GetActiveWakeLocks(
-                   mojom::WakeLockType::kPreventDisplaySleepAllowDimming));
-
   // Call ChangeType() on a wake lock that is in active status.
-  // No effect when the type is the same.
   EXPECT_TRUE(ChangeType(device::mojom::WakeLockType::kPreventAppSuspension));
-  EXPECT_EQ(1, GetActiveWakeLocks(mojom::WakeLockType::kPreventAppSuspension));
-  EXPECT_EQ(0, GetActiveWakeLocks(mojom::WakeLockType::kPreventDisplaySleep));
-  EXPECT_EQ(0, GetActiveWakeLocks(
-                   mojom::WakeLockType::kPreventDisplaySleepAllowDimming));
-
   EXPECT_TRUE(ChangeType(device::mojom::WakeLockType::kPreventDisplaySleep));
-  EXPECT_EQ(0, GetActiveWakeLocks(mojom::WakeLockType::kPreventAppSuspension));
-  EXPECT_EQ(1, GetActiveWakeLocks(mojom::WakeLockType::kPreventDisplaySleep));
-  EXPECT_EQ(0, GetActiveWakeLocks(
-                   mojom::WakeLockType::kPreventDisplaySleepAllowDimming));
-
   EXPECT_TRUE(ChangeType(
       device::mojom::WakeLockType::kPreventDisplaySleepAllowDimming));
-  EXPECT_EQ(0, GetActiveWakeLocks(mojom::WakeLockType::kPreventAppSuspension));
-  EXPECT_EQ(0, GetActiveWakeLocks(mojom::WakeLockType::kPreventDisplaySleep));
-  EXPECT_EQ(1, GetActiveWakeLocks(
-                   mojom::WakeLockType::kPreventDisplaySleepAllowDimming));
-
-  // Still active.
-  EXPECT_TRUE(HasWakeLock());
+  EXPECT_TRUE(HasWakeLock());  // still active.
 
   // Send multiple requests, should be coalesced as usual.
   wake_lock_->RequestWakeLock();
   wake_lock_->RequestWakeLock();
-  EXPECT_EQ(0, GetActiveWakeLocks(mojom::WakeLockType::kPreventAppSuspension));
-  EXPECT_EQ(0, GetActiveWakeLocks(mojom::WakeLockType::kPreventDisplaySleep));
-  EXPECT_EQ(1, GetActiveWakeLocks(
-                   mojom::WakeLockType::kPreventDisplaySleepAllowDimming));
 
   mojom::WakeLockPtr wake_lock_1;
   wake_lock_->AddClient(mojo::MakeRequest(&wake_lock_1));
@@ -250,54 +147,32 @@
   wake_lock_->CancelWakeLock();
   wake_lock_1->CancelWakeLock();
   EXPECT_FALSE(HasWakeLock());
-  EXPECT_EQ(0, GetActiveWakeLocks(mojom::WakeLockType::kPreventAppSuspension));
-  EXPECT_EQ(0, GetActiveWakeLocks(mojom::WakeLockType::kPreventDisplaySleep));
-  EXPECT_EQ(0, GetActiveWakeLocks(
-                   mojom::WakeLockType::kPreventDisplaySleepAllowDimming));
 #else  // OS_ANDROID:
   EXPECT_FALSE(ChangeType(device::mojom::WakeLockType::kPreventAppSuspension));
   EXPECT_FALSE(ChangeType(device::mojom::WakeLockType::kPreventDisplaySleep));
   EXPECT_FALSE(ChangeType(
       device::mojom::WakeLockType::kPreventDisplaySleepAllowDimming));
-  EXPECT_EQ(0, GetActiveWakeLocks(mojom::WakeLockType::kPreventAppSuspension));
-  EXPECT_EQ(0, GetActiveWakeLocks(mojom::WakeLockType::kPreventDisplaySleep));
-  EXPECT_EQ(0, GetActiveWakeLocks(
-                   mojom::WakeLockType::kPreventDisplaySleepAllowDimming));
 #endif
 }
 
 // WakeLockProvider connection broken doesn't affect WakeLock.
 TEST_F(WakeLockTest, OnWakeLockProviderConnectionError) {
   EXPECT_FALSE(HasWakeLock());
-  EXPECT_EQ(0, GetActiveWakeLocks(mojom::WakeLockType::kPreventAppSuspension));
 
   wake_lock_->RequestWakeLock();
   EXPECT_TRUE(HasWakeLock());
-  int32_t count =
-      GetActiveWakeLocks(mojom::WakeLockType::kPreventAppSuspension);
-  EXPECT_EQ(1, count);
 
-  // Reset wake lock provider and check if the wake lock is still valid.
   wake_lock_provider_.reset();
   base::RunLoop().RunUntilIdle();
-  EXPECT_TRUE(HasWakeLock());
 
-  // Instantiate wake lock provider and check if the wake lock count remains the
-  // same as before since the provider implementation is a singleton.
-  connector()->BindInterface(mojom::kServiceName, &wake_lock_provider_);
-  EXPECT_EQ(count,
-            GetActiveWakeLocks(mojom::WakeLockType::kPreventAppSuspension));
-
-  // Cancel wake lock and check the count.
+  EXPECT_TRUE(HasWakeLock());
   wake_lock_->CancelWakeLock();
   EXPECT_FALSE(HasWakeLock());
-  EXPECT_EQ(0, GetActiveWakeLocks(mojom::WakeLockType::kPreventAppSuspension));
 }
 
 // One WakeLock instance can serve multiple clients at same time.
 TEST_F(WakeLockTest, MultipleClients) {
   EXPECT_FALSE(HasWakeLock());
-  EXPECT_EQ(0, GetActiveWakeLocks(mojom::WakeLockType::kPreventAppSuspension));
 
   mojom::WakeLockPtr wake_lock_1;
   mojom::WakeLockPtr wake_lock_2;
@@ -307,29 +182,24 @@
   wake_lock_->AddClient(mojo::MakeRequest(&wake_lock_3));
 
   EXPECT_FALSE(HasWakeLock());
-  EXPECT_EQ(0, GetActiveWakeLocks(mojom::WakeLockType::kPreventAppSuspension));
 
   wake_lock_1->RequestWakeLock();
   wake_lock_2->RequestWakeLock();
   wake_lock_3->RequestWakeLock();
   EXPECT_TRUE(HasWakeLock());
-  EXPECT_EQ(1, GetActiveWakeLocks(mojom::WakeLockType::kPreventAppSuspension));
 
   wake_lock_1->CancelWakeLock();
   wake_lock_2->CancelWakeLock();
   EXPECT_TRUE(HasWakeLock());
-  EXPECT_EQ(1, GetActiveWakeLocks(mojom::WakeLockType::kPreventAppSuspension));
 
   wake_lock_3->CancelWakeLock();
   EXPECT_FALSE(HasWakeLock());
-  EXPECT_EQ(0, GetActiveWakeLocks(mojom::WakeLockType::kPreventAppSuspension));
 }
 
 // WakeLock should update the wake lock status correctly when
 // connection error happens.
 TEST_F(WakeLockTest, OnWakeLockConnectionError) {
   EXPECT_FALSE(HasWakeLock());
-  EXPECT_EQ(0, GetActiveWakeLocks(mojom::WakeLockType::kPreventAppSuspension));
 
   mojom::WakeLockPtr wake_lock_1;
   mojom::WakeLockPtr wake_lock_2;
@@ -339,30 +209,25 @@
   wake_lock_->AddClient(mojo::MakeRequest(&wake_lock_3));
 
   EXPECT_FALSE(HasWakeLock());
-  EXPECT_EQ(0, GetActiveWakeLocks(mojom::WakeLockType::kPreventAppSuspension));
 
   wake_lock_1->RequestWakeLock();
   wake_lock_2->RequestWakeLock();
   wake_lock_3->RequestWakeLock();
   EXPECT_TRUE(HasWakeLock());
-  EXPECT_EQ(1, GetActiveWakeLocks(mojom::WakeLockType::kPreventAppSuspension));
 
   wake_lock_1.reset();
   base::RunLoop().RunUntilIdle();
   EXPECT_TRUE(HasWakeLock());
-  EXPECT_EQ(1, GetActiveWakeLocks(mojom::WakeLockType::kPreventAppSuspension));
 
   wake_lock_2.reset();
   wake_lock_3.reset();
   base::RunLoop().RunUntilIdle();
   EXPECT_FALSE(HasWakeLock());
-  EXPECT_EQ(0, GetActiveWakeLocks(mojom::WakeLockType::kPreventAppSuspension));
 }
 
 // Test mixed operations.
 TEST_F(WakeLockTest, MixedTest) {
   EXPECT_FALSE(HasWakeLock());
-  EXPECT_EQ(0, GetActiveWakeLocks(mojom::WakeLockType::kPreventAppSuspension));
 
   mojom::WakeLockPtr wake_lock_1;
   mojom::WakeLockPtr wake_lock_2;
@@ -372,162 +237,27 @@
   wake_lock_->AddClient(mojo::MakeRequest(&wake_lock_3));
 
   EXPECT_FALSE(HasWakeLock());
-  EXPECT_EQ(0, GetActiveWakeLocks(mojom::WakeLockType::kPreventAppSuspension));
 
   // Execute a series of calls that should result in |wake_lock_1| and
   // |wake_lock_3| having outstanding wake lock requests.
   wake_lock_1->RequestWakeLock();
-  EXPECT_EQ(1, GetActiveWakeLocks(mojom::WakeLockType::kPreventAppSuspension));
   wake_lock_1->CancelWakeLock();
-  EXPECT_EQ(0, GetActiveWakeLocks(mojom::WakeLockType::kPreventAppSuspension));
-
   wake_lock_2->RequestWakeLock();
-  EXPECT_EQ(1, GetActiveWakeLocks(mojom::WakeLockType::kPreventAppSuspension));
-
   wake_lock_1->RequestWakeLock();
-  EXPECT_EQ(1, GetActiveWakeLocks(mojom::WakeLockType::kPreventAppSuspension));
   wake_lock_1->RequestWakeLock();
-  EXPECT_EQ(1, GetActiveWakeLocks(mojom::WakeLockType::kPreventAppSuspension));
-
   wake_lock_3->CancelWakeLock();
-  EXPECT_EQ(1, GetActiveWakeLocks(mojom::WakeLockType::kPreventAppSuspension));
   wake_lock_3->CancelWakeLock();
-  EXPECT_EQ(1, GetActiveWakeLocks(mojom::WakeLockType::kPreventAppSuspension));
-
   wake_lock_2->CancelWakeLock();
-  EXPECT_EQ(1, GetActiveWakeLocks(mojom::WakeLockType::kPreventAppSuspension));
-
   wake_lock_3->RequestWakeLock();
-  EXPECT_EQ(1, GetActiveWakeLocks(mojom::WakeLockType::kPreventAppSuspension));
-
   wake_lock_2.reset();
   EXPECT_TRUE(HasWakeLock());
-  EXPECT_EQ(1, GetActiveWakeLocks(mojom::WakeLockType::kPreventAppSuspension));
 
   wake_lock_1.reset();
   base::RunLoop().RunUntilIdle();
   EXPECT_TRUE(HasWakeLock());
-  EXPECT_EQ(1, GetActiveWakeLocks(mojom::WakeLockType::kPreventAppSuspension));
 
   wake_lock_3->CancelWakeLock();
   EXPECT_FALSE(HasWakeLock());
-  EXPECT_EQ(0, GetActiveWakeLocks(mojom::WakeLockType::kPreventAppSuspension));
-}
-
-TEST_F(WakeLockTest, SameWakeLockTypeObserverTest) {
-  // Set up observer for |kPreventAppSuspension| wake lock events.
-  mojom::WakeLockObserverPtr observer;
-  TestWakeLockObserver test_wake_lock_observer;
-  test_wake_lock_observer.AddBinding(mojo::MakeRequest(&observer));
-  wake_lock_provider_->NotifyOnWakeLockDeactivation(
-      mojom::WakeLockType::kPreventAppSuspension, std::move(observer));
-  EXPECT_EQ(0, GetActiveWakeLocks(mojom::WakeLockType::kPreventAppSuspension));
-  // Observer should be triggered since the wake lock wasn't held.
-  EXPECT_EQ(1, test_wake_lock_observer.GetOnDeactivationCount(
-                   mojom::WakeLockType::kPreventAppSuspension));
-
-  // Make two wake lock requests from the same client, these should be coalesced
-  // into one and result in the first |kPreventAppSuspension| wake lock being
-  // created. This should result in an acquire event.
-  wake_lock_->RequestWakeLock();
-  wake_lock_->RequestWakeLock();
-  wake_lock_.FlushForTesting();
-  EXPECT_EQ(1, GetActiveWakeLocks(mojom::WakeLockType::kPreventAppSuspension));
-  EXPECT_EQ(1, test_wake_lock_observer.GetOnDeactivationCount(
-                   mojom::WakeLockType::kPreventAppSuspension));
-
-  // Add another client for the same wake lock type and make a request. This
-  // shouldn't affect wake up counts as a |kPreventAppSuspension| wake lock is
-  // already held.
-  mojom::WakeLockPtr wake_lock2;
-  wake_lock_provider_->GetWakeLockWithoutContext(
-      device::mojom::WakeLockType::kPreventAppSuspension,
-      device::mojom::WakeLockReason::kOther, "WakeLockTest",
-      mojo::MakeRequest(&wake_lock2));
-  wake_lock2->RequestWakeLock();
-  wake_lock2.FlushForTesting();
-  EXPECT_EQ(2, GetActiveWakeLocks(mojom::WakeLockType::kPreventAppSuspension));
-  EXPECT_EQ(1, test_wake_lock_observer.GetOnDeactivationCount(
-                   mojom::WakeLockType::kPreventAppSuspension));
-
-  // Cancel request should result in no change in counts as two clients
-  // requested wake locks.
-  wake_lock_->CancelWakeLock();
-  wake_lock_.FlushForTesting();
-  EXPECT_EQ(1, GetActiveWakeLocks(mojom::WakeLockType::kPreventAppSuspension));
-  EXPECT_EQ(1, test_wake_lock_observer.GetOnDeactivationCount(
-                   mojom::WakeLockType::kPreventAppSuspension));
-
-  // Resetting second client should result in it's wake lock be released and no
-  // |kPreventAppSuspension| wake locks being present in the system i.e. on a
-  // release event. For reset events |FlushForTesting| can't be used.
-  base::RunLoop run_loop4;
-  wake_lock2.reset();
-  run_loop4.RunUntilIdle();
-  EXPECT_EQ(0, GetActiveWakeLocks(mojom::WakeLockType::kPreventAppSuspension));
-  EXPECT_EQ(2, test_wake_lock_observer.GetOnDeactivationCount(
-                   mojom::WakeLockType::kPreventAppSuspension));
-
-  // Resetting first wake lock client should result in no change in event count.
-  // For reset events |FlushForTesting| can't be used.
-  base::RunLoop run_loop5;
-  wake_lock_.reset();
-  run_loop5.RunUntilIdle();
-  EXPECT_EQ(0, GetActiveWakeLocks(mojom::WakeLockType::kPreventAppSuspension));
-  EXPECT_EQ(2, test_wake_lock_observer.GetOnDeactivationCount(
-                   mojom::WakeLockType::kPreventAppSuspension));
-}
-
-TEST_F(WakeLockTest, DifferentWakeLockTypesObserverTest) {
-  // Setup observer that will observe events for two different types of wake
-  // locks. No wake locks should be active and deactivation counts should be
-  // received for each type of observed wake lock.
-  mojom::WakeLockObserverPtr observer;
-  TestWakeLockObserver test_wake_lock_observer;
-  test_wake_lock_observer.AddBinding(mojo::MakeRequest(&observer));
-  wake_lock_provider_->NotifyOnWakeLockDeactivation(
-      mojom::WakeLockType::kPreventAppSuspension, std::move(observer));
-  observer.reset();
-  test_wake_lock_observer.AddBinding(mojo::MakeRequest(&observer));
-  wake_lock_provider_->NotifyOnWakeLockDeactivation(
-      mojom::WakeLockType::kPreventDisplaySleep, std::move(observer));
-  EXPECT_EQ(0, GetActiveWakeLocks(mojom::WakeLockType::kPreventAppSuspension));
-  EXPECT_EQ(0, GetActiveWakeLocks(mojom::WakeLockType::kPreventDisplaySleep));
-  EXPECT_EQ(1, test_wake_lock_observer.GetOnDeactivationCount(
-                   mojom::WakeLockType::kPreventAppSuspension));
-  EXPECT_EQ(1, test_wake_lock_observer.GetOnDeactivationCount(
-                   mojom::WakeLockType::kPreventDisplaySleep));
-
-  // Acquire two different type of wake locks and check if the observer for each
-  // gets an acquire event.
-  mojom::WakeLockPtr wake_lock2;
-  wake_lock_provider_->GetWakeLockWithoutContext(
-      device::mojom::WakeLockType::kPreventDisplaySleep,
-      device::mojom::WakeLockReason::kOther, "WakeLockTest",
-      mojo::MakeRequest(&wake_lock2));
-  wake_lock_->RequestWakeLock();
-  wake_lock2->RequestWakeLock();
-  wake_lock_.FlushForTesting();
-  wake_lock2.FlushForTesting();
-  EXPECT_EQ(1, GetActiveWakeLocks(mojom::WakeLockType::kPreventAppSuspension));
-  EXPECT_EQ(1, GetActiveWakeLocks(mojom::WakeLockType::kPreventDisplaySleep));
-  EXPECT_EQ(1, test_wake_lock_observer.GetOnDeactivationCount(
-                   mojom::WakeLockType::kPreventAppSuspension));
-  EXPECT_EQ(1, test_wake_lock_observer.GetOnDeactivationCount(
-                   mojom::WakeLockType::kPreventDisplaySleep));
-
-  // Release wake locks of both types and check if observers for each got on
-  // release events. For reset events |FlushForTesting| can't be used.
-  base::RunLoop run_loop2;
-  wake_lock_.reset();
-  wake_lock2.reset();
-  run_loop2.RunUntilIdle();
-  EXPECT_EQ(0, GetActiveWakeLocks(mojom::WakeLockType::kPreventAppSuspension));
-  EXPECT_EQ(0, GetActiveWakeLocks(mojom::WakeLockType::kPreventDisplaySleep));
-  EXPECT_EQ(2, test_wake_lock_observer.GetOnDeactivationCount(
-                   mojom::WakeLockType::kPreventAppSuspension));
-  EXPECT_EQ(2, test_wake_lock_observer.GetOnDeactivationCount(
-                   mojom::WakeLockType::kPreventDisplaySleep));
 }
 
 }  // namespace
--- a/services/file/BUILD.gn	2019-05-01 01:22:56.000000000 +0300
+++ b/services/file/BUILD.gn	2019-05-17 18:53:37.856000000 +0300
@@ -2,6 +2,8 @@
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
+import("//services/service_manager/public/service_manifest.gni")
+
 source_set("lib") {
   sources = [
     "file_service.cc",
@@ -27,3 +29,8 @@
     "//url",
   ]
 }
+
+service_manifest("manifest") {
+  name = "file"
+  source = "manifest.json"
+}
--- a/services/file/file_service.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/file/file_service.cc	2019-05-17 18:53:37.856000000 +0300
@@ -109,9 +109,9 @@
     const service_manager::BindSourceInfo& source_info) {
   file_service_runner_->PostTask(
       FROM_HERE,
-      base::BindOnce(&FileService::FileSystemObjects::OnFileSystemRequest,
+      base::Bind(&FileService::FileSystemObjects::OnFileSystemRequest,
                      file_system_objects_->AsWeakPtr(), source_info.identity,
-                     std::move(request)));
+                 base::Passed(&request)));
 }
 
 void FileService::BindLevelDBServiceRequest(
@@ -119,10 +119,9 @@
     const service_manager::BindSourceInfo& source_info) {
   leveldb_service_runner_->PostTask(
       FROM_HERE,
-      base::BindOnce(
-          &FileService::LevelDBServiceObjects::OnLevelDBServiceRequest,
+      base::Bind(&FileService::LevelDBServiceObjects::OnLevelDBServiceRequest,
           leveldb_objects_->AsWeakPtr(), source_info.identity,
-          std::move(request)));
+                 base::Passed(&request)));
 }
 
 }  // namespace user_service
--- a/services/file/OWNERS	2019-05-01 01:22:56.000000000 +0300
+++ b/services/file/OWNERS	2019-05-17 18:53:37.856000000 +0300
@@ -1 +1,4 @@
 rockot@google.com
+
+per-file manifest.json=set noparent
+per-file manifest.json=file://ipc/SECURITY_OWNERS
--- a/services/identity/BUILD.gn	2019-05-01 01:22:56.000000000 +0300
+++ b/services/identity/BUILD.gn	2019-05-17 18:53:37.860000000 +0300
@@ -2,14 +2,16 @@
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
+import("//services/service_manager/public/service_manifest.gni")
+
 if (is_android) {
   import("//build/config/android/rules.gni")
 }
 
 source_set("lib") {
   sources = [
-    "identity_accessor_impl.cc",
-    "identity_accessor_impl.h",
+    "identity_manager_impl.cc",
+    "identity_manager_impl.h",
     "identity_service.cc",
     "identity_service.h",
   ]
@@ -20,13 +22,18 @@
     "//base",
     "//components/signin/core/browser:internals",
     "//components/signin/core/browser:shared",
-    "//services/identity/public/cpp:cpp",
+    "//services/identity/public/cpp:cpp_types",
     "//services/identity/public/mojom",
     "//services/service_manager/public/cpp",
     "//services/service_manager/public/mojom",
   ]
 }
 
+service_manifest("manifest") {
+  name = "identity"
+  source = "manifest.json"
+}
+
 source_set("tests") {
   testonly = true
   deps = [
@@ -36,6 +43,7 @@
     "//components/prefs:test_support",
     "//components/signin/core/browser:internals",
     "//components/signin/core/browser:internals_test_support",
+    "//components/signin/core/browser:internals_test_support",
     "//components/signin/core/browser:shared",
     "//components/sync_preferences:test_support",
     "//mojo/public/cpp/bindings",
@@ -49,7 +57,7 @@
     "//testing/gtest",
   ]
   sources = [
-    "identity_accessor_impl_unittest.cc",
+    "identity_manager_impl_unittest.cc",
     "public/cpp/access_token_fetcher_unittest.cc",
     "public/cpp/identity_manager_unittest.cc",
     "public/cpp/identity_test_environment_unittest.cc",
--- a/services/identity/DEPS	2019-05-01 01:22:56.000000000 +0300
+++ b/services/identity/DEPS	2019-05-17 18:53:37.860000000 +0300
@@ -1,9 +1,6 @@
 include_rules = [
-  "+components/prefs/pref_service.h",
   "+components/signin/core/browser/account_info.h",
   "+components/signin/core/browser/account_tracker_service.h",
-  "+components/signin/core/browser/device_id_helper.h",
-  "+components/signin/core/browser/test_image_decoder.h",
   "+components/signin/core/browser/fake_profile_oauth2_token_service.h",
   "+components/signin/core/browser/fake_signin_manager.h",
   "+components/signin/core/browser/profile_oauth2_token_service.h",
--- a/services/identity/identity_service.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/identity/identity_service.cc	2019-05-17 18:53:37.860000000 +0300
@@ -4,22 +4,23 @@
 
 #include "services/identity/identity_service.h"
 
-#include <utility>
-
-#include "base/bind.h"
-#include "services/identity/identity_accessor_impl.h"
-#include "services/identity/public/cpp/identity_manager.h"
+#include "services/identity/identity_manager_impl.h"
 
 namespace identity {
 
-IdentityService::IdentityService(IdentityManager* identity_manager,
-                                 AccountTrackerService* account_tracker,
+IdentityService::IdentityService(AccountTrackerService* account_tracker,
+                                 SigninManagerBase* signin_manager,
+                                 ProfileOAuth2TokenService* token_service,
                                  service_manager::mojom::ServiceRequest request)
     : service_binding_(this, std::move(request)),
-      identity_manager_(identity_manager),
-      account_tracker_(account_tracker) {
-  registry_.AddInterface<mojom::IdentityAccessor>(
+      account_tracker_(account_tracker),
+      signin_manager_(signin_manager),
+      token_service_(token_service) {
+  registry_.AddInterface<mojom::IdentityManager>(
       base::Bind(&IdentityService::Create, base::Unretained(this)));
+  signin_manager_shutdown_subscription_ =
+      signin_manager_->RegisterOnShutdownCallback(
+          base::Bind(&IdentityService::ShutDown, base::Unretained(this)));
 }
 
 IdentityService::~IdentityService() {
@@ -37,21 +38,23 @@
   if (IsShutDown())
     return;
 
-  identity_manager_ = nullptr;
+  signin_manager_ = nullptr;
+  signin_manager_shutdown_subscription_.reset();
+  token_service_ = nullptr;
   account_tracker_ = nullptr;
 }
 
 bool IdentityService::IsShutDown() {
-  return (identity_manager_ == nullptr);
+  return (signin_manager_ == nullptr);
 }
 
-void IdentityService::Create(mojom::IdentityAccessorRequest request) {
+void IdentityService::Create(mojom::IdentityManagerRequest request) {
   // This instance cannot service requests if it has already been shut down.
   if (IsShutDown())
     return;
 
-  IdentityAccessorImpl::Create(std::move(request), identity_manager_,
-                               account_tracker_);
+  IdentityManagerImpl::Create(std::move(request), account_tracker_,
+                              signin_manager_, token_service_);
 }
 
 }  // namespace identity
--- a/services/identity/identity_service.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/identity/identity_service.h	2019-05-17 18:53:37.860000000 +0300
@@ -6,21 +6,22 @@
 #define SERVICES_IDENTITY_IDENTITY_SERVICE_H_
 
 #include "components/signin/core/browser/signin_manager_base.h"
-#include "services/identity/public/cpp/identity_manager.h"
-#include "services/identity/public/mojom/identity_accessor.mojom.h"
+#include "services/identity/public/mojom/identity_manager.mojom.h"
 #include "services/service_manager/public/cpp/binder_registry.h"
 #include "services/service_manager/public/cpp/service.h"
 #include "services/service_manager/public/cpp/service_binding.h"
 #include "services/service_manager/public/mojom/service.mojom.h"
 
 class AccountTrackerService;
+class ProfileOAuth2TokenService;
 
 namespace identity {
 
 class IdentityService : public service_manager::Service {
  public:
-  IdentityService(IdentityManager* identity_manager,
-                  AccountTrackerService* account_tracker,
+  IdentityService(AccountTrackerService* account_tracker,
+                  SigninManagerBase* signin_manager,
+                  ProfileOAuth2TokenService* token_service,
                   service_manager::mojom::ServiceRequest request);
   ~IdentityService() override;
 
@@ -30,7 +31,7 @@
                        const std::string& interface_name,
                        mojo::ScopedMessagePipeHandle interface_pipe) override;
 
-  void Create(mojom::IdentityAccessorRequest request);
+  void Create(mojom::IdentityManagerRequest request);
 
   // Shuts down this instance, blocking it from serving any pending or future
   // requests. Safe to call multiple times; will be a no-op after the first
@@ -40,8 +41,12 @@
 
   service_manager::ServiceBinding service_binding_;
 
-  IdentityManager* identity_manager_;
   AccountTrackerService* account_tracker_;
+  SigninManagerBase* signin_manager_;
+  ProfileOAuth2TokenService* token_service_;
+
+  std::unique_ptr<base::CallbackList<void()>::Subscription>
+      signin_manager_shutdown_subscription_;
 
   service_manager::BinderRegistry registry_;
 
--- a/services/identity/OWNERS	2019-05-01 01:22:56.000000000 +0300
+++ b/services/identity/OWNERS	2019-05-17 18:53:37.860000000 +0300
@@ -1,6 +1,8 @@
 # COMPONENT: Services>SignIn
 
 blundell@chromium.org
-droger@chromium.org
 msarda@chromium.org
 sdefresne@chromium.org
+
+per-file manifest.json=set noparent
+per-file manifest.json=file://ipc/SECURITY_OWNERS
--- a/services/identity/public/cpp/access_token_fetcher_unittest.cc	2019-05-17 17:45:42.508000000 +0300
+++ b/services/identity/public/cpp/access_token_fetcher_unittest.cc	2019-05-17 18:53:37.860000000 +0300
@@ -34,8 +34,8 @@
 
 const char kTestGaiaId[] = "dummyId";
 const char kTestGaiaId2[] = "dummyId2";
-const char kTestEmail[] = "me@9ma1l.qjz9zk";
-const char kTestEmail2[] = "me2@9ma1l.qjz9zk";
+const char kTestEmail[] = "me@gmail.com";
+const char kTestEmail2[] = "me2@gmail.com";
 
 // Used just to check that the id_token is passed along.
 const char kIdTokenEmptyServices[] =
--- a/services/identity/public/cpp/accounts_mutator.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/identity/public/cpp/accounts_mutator.h	2019-05-17 18:53:37.860000000 +0300
@@ -56,18 +56,11 @@
   // Removes the credentials associated to account_id from the internal storage,
   // and moves them to |target|. The credentials are not revoked on the server,
   // but the IdentityManager::Observer::OnRefreshTokenRemovedForAccount()
-  // notification is sent to the observers. Also recreates a new device ID for
-  // this mutator. The device ID of the current mutator is not moved to the
-  // target mutator.
+  // notification is sent to the observers.
   virtual void MoveAccount(AccountsMutator* target,
                            const std::string& account_id) = 0;
 #endif
 
-  // Updates the refresh token for the supervised user.
-  // TODO(860492): Remove this once supervised user support is removed.
-  virtual void LegacySetRefreshTokenForSupervisedUser(
-      const std::string& refresh_token) = 0;
-
  private:
   DISALLOW_COPY_AND_ASSIGN(AccountsMutator);
 };
--- a/services/identity/public/cpp/accounts_mutator_impl.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/identity/public/cpp/accounts_mutator_impl.cc	2019-05-17 18:53:37.860000000 +0300
@@ -4,13 +4,9 @@
 
 #include "services/identity/public/cpp/accounts_mutator_impl.h"
 
-#include <string>
-
 #include "base/logging.h"
-#include "components/prefs/pref_service.h"
 #include "components/signin/core/browser/account_info.h"
 #include "components/signin/core/browser/account_tracker_service.h"
-#include "components/signin/core/browser/device_id_helper.h"
 #include "components/signin/core/browser/profile_oauth2_token_service.h"
 #include "components/signin/core/browser/signin_manager_base.h"
 
@@ -19,18 +15,13 @@
 AccountsMutatorImpl::AccountsMutatorImpl(
     ProfileOAuth2TokenService* token_service,
     AccountTrackerService* account_tracker_service,
-    SigninManagerBase* signin_manager,
-    PrefService* pref_service)
+    SigninManagerBase* signin_manager)
     : token_service_(token_service),
       account_tracker_service_(account_tracker_service),
       signin_manager_(signin_manager) {
   DCHECK(token_service_);
   DCHECK(account_tracker_service_);
   DCHECK(signin_manager_);
-#if BUILDFLAG(ENABLE_DICE_SUPPORT)
-  pref_service_ = pref_service;
-  DCHECK(pref_service_);
-#endif
 }
 
 AccountsMutatorImpl::~AccountsMutatorImpl() {}
@@ -96,20 +87,7 @@
   auto* target_impl = static_cast<AccountsMutatorImpl*>(target);
   target_impl->account_tracker_service_->SeedAccountInfo(account_info);
   token_service_->ExtractCredentials(target_impl->token_service_, account_id);
-
-  // Reset the device ID from the source mutator: the exported token is linked
-  // to the device ID of the current mutator on the server. Reset the device ID
-  // of the current mutator to avoid tying it with the new mutator. See
-  // https://crbug.com/813928#c16
-  signin::RecreateSigninScopedDeviceId(pref_service_);
 }
 #endif
 
-void AccountsMutatorImpl::LegacySetRefreshTokenForSupervisedUser(
-    const std::string& refresh_token) {
-  token_service_->UpdateCredentials(
-      "managed_user@localhost", refresh_token,
-      signin_metrics::SourceForRefreshTokenOperation::kSupervisedUser_InitSync);
-}
-
 }  // namespace identity
--- a/services/identity/public/cpp/accounts_mutator_impl.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/identity/public/cpp/accounts_mutator_impl.h	2019-05-17 18:53:37.860000000 +0300
@@ -5,16 +5,11 @@
 #ifndef SERVICES_IDENTITY_PUBLIC_CPP_ACCOUNTS_MUTATOR_IMPL_H_
 #define SERVICES_IDENTITY_PUBLIC_CPP_ACCOUNTS_MUTATOR_IMPL_H_
 
-#include <string>
-
 #include "base/macros.h"
-#include "build/buildflag.h"
-#include "components/signin/core/browser/signin_buildflags.h"
 #include "components/signin/core/browser/signin_metrics.h"
 #include "services/identity/public/cpp/accounts_mutator.h"
 
 class AccountTrackerService;
-class PrefService;
 class ProfileOAuth2TokenService;
 class SigninManagerBase;
 
@@ -25,44 +20,54 @@
  public:
   explicit AccountsMutatorImpl(ProfileOAuth2TokenService* token_service,
                                AccountTrackerService* account_tracker_service,
-                               SigninManagerBase* signin_manager,
-                               PrefService* pref_service);
+                               SigninManagerBase* signin_manager);
   ~AccountsMutatorImpl() override;
 
-  // AccountsMutator:
+  // Updates the information of the account associated with |gaia_id|, first
+  // adding that account to the system if it is not known.
   std::string AddOrUpdateAccount(
       const std::string& gaia_id,
       const std::string& email,
       const std::string& refresh_token,
       bool is_under_advanced_protection,
       signin_metrics::SourceForRefreshTokenOperation source) override;
+
+  // Updates the information about account identified by |account_id|.
   void UpdateAccountInfo(
       const std::string& account_id,
       base::Optional<bool> is_child_account,
       base::Optional<bool> is_under_advanced_protection) override;
+
+  // Removes the account given by |account_id|. Also revokes the token
+  // server-side if needed.
   void RemoveAccount(
       const std::string& account_id,
       signin_metrics::SourceForRefreshTokenOperation source) override;
+
+  // Removes all accounts.
   void RemoveAllAccounts(
       signin_metrics::SourceForRefreshTokenOperation source) override;
+
+  // Invalidates the refresh token of the primary account.
+  // The primary account must necessarily be set by the time this method
+  // is invoked.
   void InvalidateRefreshTokenForPrimaryAccount(
       signin_metrics::SourceForRefreshTokenOperation source) override;
 
 #if BUILDFLAG(ENABLE_DICE_SUPPORT)
+  // Removes the credentials associated to account_id from the internal storage,
+  // and moves them to |target|. The credentials are not revoked on the server,
+  // but the IdentityManager::Observer::OnRefreshTokenRemovedForAccount()
+  // notification is sent to the observers.
   void MoveAccount(AccountsMutator* target,
                    const std::string& account_id) override;
 #endif
 
-  void LegacySetRefreshTokenForSupervisedUser(
-      const std::string& refresh_token) override;
-
  private:
   ProfileOAuth2TokenService* token_service_;
   AccountTrackerService* account_tracker_service_;
   SigninManagerBase* signin_manager_;
-#if BUILDFLAG(ENABLE_DICE_SUPPORT)
-  PrefService* pref_service_;
-#endif
+
   DISALLOW_COPY_AND_ASSIGN(AccountsMutatorImpl);
 };
 
--- a/services/identity/public/cpp/accounts_mutator_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/identity/public/cpp/accounts_mutator_unittest.cc	2019-05-17 18:53:37.860000000 +0300
@@ -4,19 +4,14 @@
 
 #include "services/identity/public/cpp/accounts_mutator_impl.h"
 
-#include "base/bind.h"
 #include "base/message_loop/message_loop.h"
 #include "base/optional.h"
 #include "base/test/gtest_util.h"
-#include "components/signin/core/browser/device_id_helper.h"
 #include "components/signin/core/browser/signin_metrics.h"
-#include "components/sync_preferences/testing_pref_service_syncable.h"
 #include "services/identity/public/cpp/accounts_mutator_impl.h"
 #include "services/identity/public/cpp/identity_manager.h"
 #include "services/identity/public/cpp/identity_test_environment.h"
 #include "services/identity/public/cpp/identity_test_utils.h"
-#include "services/identity/public/cpp/test_identity_manager_observer.h"
-#include "services/network/test/test_url_loader_factory.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
 namespace {
@@ -27,57 +22,48 @@
 const char kTestEmail2[] = "test_user@test-2.com";
 const char kRefreshToken[] = "refresh_token";
 const char kRefreshToken2[] = "refresh_token_2";
-const char kSupervisedUserPseudoEmail[] = "managed_user@localhost";
 
-// Class that observes diagnostics updates from identity::IdentityManager.
-class TestIdentityManagerDiagnosticsObserver
-    : public identity::IdentityManager::DiagnosticsObserver {
+// Class that observes updates from identity::IdentityManager.
+class TestIdentityManagerObserver : public identity::IdentityManager::Observer {
  public:
-  explicit TestIdentityManagerDiagnosticsObserver(
+  explicit TestIdentityManagerObserver(
       identity::IdentityManager* identity_manager)
       : identity_manager_(identity_manager) {
-    identity_manager_->AddDiagnosticsObserver(this);
+    identity_manager_->AddObserver(this);
   }
-  ~TestIdentityManagerDiagnosticsObserver() override {
-    identity_manager_->RemoveDiagnosticsObserver(this);
+  ~TestIdentityManagerObserver() override {
+    identity_manager_->RemoveObserver(this);
   }
 
-  const std::string& token_updator_account_id() {
-    return token_updator_account_id_;
+  void set_on_refresh_token_updated_callback(
+      base::OnceCallback<void(const std::string&)> callback) {
+    on_refresh_token_updated_callback_ = std::move(callback);
   }
-  const std::string& token_updator_source() { return token_updator_source_; }
-  bool is_token_updator_refresh_token_valid() {
-    return is_token_updator_refresh_token_valid_;
-  }
-  const std::string& token_remover_account_id() {
-    return token_remover_account_id_;
+
+  void set_on_refresh_token_removed_callback(
+      base::OnceCallback<void(const std::string&)> callback) {
+    on_refresh_token_removed_callback_ = std::move(callback);
   }
-  const std::string& token_remover_source() { return token_remover_source_; }
 
  private:
-  // identity::IdentityManager::DiagnosticsObserver:
-  void OnRefreshTokenUpdatedForAccountFromSource(
-      const std::string& account_id,
-      bool is_refresh_token_valid,
-      const std::string& source) override {
-    token_updator_account_id_ = account_id;
-    is_token_updator_refresh_token_valid_ = is_refresh_token_valid;
-    token_updator_source_ = source;
+  // identity::IdentityManager::Observer:
+  void OnRefreshTokenUpdatedForAccount(
+      const AccountInfo& account_info) override {
+    if (on_refresh_token_updated_callback_)
+      std::move(on_refresh_token_updated_callback_)
+          .Run(account_info.account_id);
   }
 
-  void OnRefreshTokenRemovedForAccountFromSource(
-      const std::string& account_id,
-      const std::string& source) override {
-    token_remover_account_id_ = account_id;
-    token_remover_source_ = source;
+  void OnRefreshTokenRemovedForAccount(const std::string& account_id) override {
+    if (on_refresh_token_removed_callback_)
+      std::move(on_refresh_token_removed_callback_).Run(account_id);
   }
 
   identity::IdentityManager* identity_manager_;
-  std::string token_updator_account_id_;
-  std::string token_updator_source_;
-  std::string token_remover_account_id_;
-  std::string token_remover_source_;
-  bool is_token_updator_refresh_token_valid_;
+  base::OnceCallback<void(const std::string&)>
+      on_refresh_token_updated_callback_;
+  base::OnceCallback<void(const std::string&)>
+      on_refresh_token_removed_callback_;
 };
 
 }  // namespace
@@ -85,25 +71,16 @@
 namespace identity {
 class AccountsMutatorTest : public testing::Test {
  public:
-  AccountsMutatorTest()
-      : identity_test_env_(&test_url_loader_factory_, &prefs_),
-        identity_manager_diagnostics_observer_(identity_manager()) {}
+  AccountsMutatorTest() : identity_manager_observer_(identity_manager()) {}
 
   ~AccountsMutatorTest() override {}
 
-  PrefService* pref_service() { return &prefs_; }
-
   identity::IdentityManager* identity_manager() {
     return identity_test_env_.identity_manager();
   }
 
   TestIdentityManagerObserver* identity_manager_observer() {
-    return identity_test_env_.identity_manager_observer();
-  }
-
-  TestIdentityManagerDiagnosticsObserver*
-  identity_manager_diagnostics_observer() {
-    return &identity_manager_diagnostics_observer_;
+    return &identity_manager_observer_;
   }
 
   AccountsMutator* accounts_mutator() {
@@ -112,10 +89,8 @@
 
  private:
   base::MessageLoop message_loop_;
-  sync_preferences::TestingPrefServiceSyncable prefs_;
-  network::TestURLLoaderFactory test_url_loader_factory_;
   identity::IdentityTestEnvironment identity_test_env_;
-  TestIdentityManagerDiagnosticsObserver identity_manager_diagnostics_observer_;
+  TestIdentityManagerObserver identity_manager_observer_;
 
   DISALLOW_COPY_AND_ASSIGN(AccountsMutatorTest);
 };
@@ -133,8 +108,12 @@
     return;
 
   base::RunLoop run_loop;
-  identity_manager_observer()->SetOnRefreshTokenUpdatedCallback(
-      run_loop.QuitClosure());
+  identity_manager_observer()->set_on_refresh_token_updated_callback(
+      base::BindOnce(
+          [](base::OnceClosure quit_closure, const std::string& account_id) {
+            std::move(quit_closure).Run();
+          },
+          run_loop.QuitClosure()));
 
   std::string account_id = accounts_mutator()->AddOrUpdateAccount(
       kTestGaiaId, kTestEmail, kRefreshToken,
@@ -166,8 +145,12 @@
 
   // First of all add the account to the account tracker service.
   base::RunLoop run_loop;
-  identity_manager_observer()->SetOnRefreshTokenUpdatedCallback(
-      run_loop.QuitClosure());
+  identity_manager_observer()->set_on_refresh_token_updated_callback(
+      base::BindOnce(
+          [](base::OnceClosure quit_closure, const std::string& account_id) {
+            std::move(quit_closure).Run();
+          },
+          run_loop.QuitClosure()));
 
   std::string account_id = accounts_mutator()->AddOrUpdateAccount(
       kTestGaiaId, kTestEmail, kRefreshToken,
@@ -190,8 +173,15 @@
   // Now try adding the account again with the same account id but with
   // different information, and check that the account gets updated.
   base::RunLoop run_loop2;
-  identity_manager_observer()->SetOnRefreshTokenUpdatedCallback(
-      run_loop2.QuitClosure());
+  identity_manager_observer()->set_on_refresh_token_updated_callback(
+      base::BindOnce(
+          [](base::OnceClosure quit_closure,
+             const std::string& expected_account_id,
+             const std::string& added_account_id) {
+            EXPECT_EQ(added_account_id, expected_account_id);
+            std::move(quit_closure).Run();
+          },
+          run_loop2.QuitClosure(), account_id));
 
   // The internals of IdentityService is migrating from email to gaia id
   // as the account id. Detect whether the current plaform has completed
@@ -210,11 +200,6 @@
       signin_metrics::SourceForRefreshTokenOperation::kUnknown);
   run_loop2.Run();
 
-  EXPECT_EQ(identity_manager_observer()
-                ->AccountFromRefreshTokenUpdatedCallback()
-                .account_id,
-            account_id);
-
   // No new accounts should be created, just the information should be updated.
   EXPECT_EQ(identity_manager()->GetAccountsWithRefreshTokens().size(), 1U);
   AccountInfo updated_account_info =
@@ -240,8 +225,12 @@
 
   // First of all add the account to the account tracker service.
   base::RunLoop run_loop;
-  identity_manager_observer()->SetOnRefreshTokenUpdatedCallback(
-      run_loop.QuitClosure());
+  identity_manager_observer()->set_on_refresh_token_updated_callback(
+      base::BindOnce(
+          [](base::OnceClosure quit_closure, const std::string& account_id) {
+            std::move(quit_closure).Run();
+          },
+          run_loop.QuitClosure()));
 
   std::string account_id = accounts_mutator()->AddOrUpdateAccount(
       kTestGaiaId, kTestEmail, kRefreshToken,
@@ -329,17 +318,20 @@
 
   // Now try invalidating the primary account, and check that it gets updated.
   base::RunLoop run_loop;
-  identity_manager_observer()->SetOnRefreshTokenUpdatedCallback(
-      run_loop.QuitClosure());
+  identity_manager_observer()->set_on_refresh_token_updated_callback(
+      base::BindOnce(
+          [](base::OnceClosure quit_closure,
+             const std::string& expected_account_id,
+             const std::string& added_or_updated_account_id) {
+            EXPECT_EQ(added_or_updated_account_id, expected_account_id);
+            std::move(quit_closure).Run();
+          },
+          run_loop.QuitClosure(), primary_account_info.account_id));
 
   accounts_mutator()->InvalidateRefreshTokenForPrimaryAccount(
       signin_metrics::SourceForRefreshTokenOperation::kUnknown);
   run_loop.Run();
 
-  EXPECT_EQ(identity_manager_observer()
-                ->AccountFromRefreshTokenUpdatedCallback()
-                .account_id,
-            primary_account_info.account_id);
   EXPECT_TRUE(identity_manager()->HasAccountWithRefreshToken(
       primary_account_info.account_id));
   EXPECT_TRUE(
@@ -367,8 +359,12 @@
 
   // Next, add a secondary account.
   base::RunLoop run_loop;
-  identity_manager_observer()->SetOnRefreshTokenUpdatedCallback(
-      run_loop.QuitClosure());
+  identity_manager_observer()->set_on_refresh_token_updated_callback(
+      base::BindOnce(
+          [](base::OnceClosure quit_closure, const std::string& account_id) {
+            std::move(quit_closure).Run();
+          },
+          run_loop.QuitClosure()));
 
   std::string account_id = accounts_mutator()->AddOrUpdateAccount(
       kTestGaiaId, kTestEmail, kRefreshToken,
@@ -384,18 +380,20 @@
 
   // Now try invalidating the primary account, and check that it gets updated.
   base::RunLoop run_loop2;
-  identity_manager_observer()->SetOnRefreshTokenUpdatedCallback(
-      run_loop2.QuitClosure());
+  identity_manager_observer()->set_on_refresh_token_updated_callback(
+      base::BindOnce(
+          [](base::OnceClosure quit_closure,
+             const std::string& expected_account_id,
+             const std::string& added_or_updated_account_id) {
+            EXPECT_EQ(added_or_updated_account_id, expected_account_id);
+            std::move(quit_closure).Run();
+          },
+          run_loop2.QuitClosure(), primary_account_info.account_id));
 
   accounts_mutator()->InvalidateRefreshTokenForPrimaryAccount(
       signin_metrics::SourceForRefreshTokenOperation::kUnknown);
   run_loop2.Run();
 
-  EXPECT_EQ(identity_manager_observer()
-                ->AccountFromRefreshTokenUpdatedCallback()
-                .account_id,
-            primary_account_info.account_id);
-
   // Check whether the primary account refresh token got invalidated.
   EXPECT_TRUE(identity_manager()->HasAccountWithRefreshToken(
       primary_account_info.account_id));
@@ -444,8 +442,8 @@
     return;
 
   base::RunLoop run_loop;
-  identity_manager_observer()->SetOnRefreshTokenUpdatedCallback(
-      base::BindOnce([]() {
+  identity_manager_observer()->set_on_refresh_token_updated_callback(
+      base::BindOnce([](const std::string& account_id) {
         // This callback should not be invoked now.
         EXPECT_TRUE(false);
       }));
@@ -470,8 +468,12 @@
 
   // First of all add the account to the account tracker service.
   base::RunLoop run_loop;
-  identity_manager_observer()->SetOnRefreshTokenUpdatedCallback(
-      run_loop.QuitClosure());
+  identity_manager_observer()->set_on_refresh_token_updated_callback(
+      base::BindOnce(
+          [](base::OnceClosure quit_closure, const std::string& account_id) {
+            std::move(quit_closure).Run();
+          },
+          run_loop.QuitClosure()));
 
   std::string account_id = accounts_mutator()->AddOrUpdateAccount(
       kTestGaiaId, kTestEmail, kRefreshToken,
@@ -487,17 +489,20 @@
 
   // Now remove the account that we just added.
   base::RunLoop run_loop2;
-  identity_manager_observer()->SetOnRefreshTokenRemovedCallback(
-      run_loop2.QuitClosure());
+  identity_manager_observer()->set_on_refresh_token_removed_callback(
+      base::BindOnce(
+          [](base::OnceClosure quit_closure,
+             const std::string& expected_account_id,
+             const std::string& removed_account_id) {
+            EXPECT_EQ(removed_account_id, expected_account_id);
+            std::move(quit_closure).Run();
+          },
+          run_loop2.QuitClosure(), account_id));
 
   accounts_mutator()->RemoveAccount(
       account_id, signin_metrics::SourceForRefreshTokenOperation::kUnknown);
   run_loop2.Run();
 
-  EXPECT_EQ(
-      identity_manager_observer()->AccountIdFromRefreshTokenRemovedCallback(),
-      account_id);
-
   EXPECT_FALSE(identity_manager()->HasAccountWithRefreshToken(account_id));
   EXPECT_FALSE(
       identity_manager()->HasAccountWithRefreshTokenInPersistentErrorState(
@@ -514,8 +519,12 @@
 
   // First of all the first account to the account tracker service.
   base::RunLoop run_loop;
-  identity_manager_observer()->SetOnRefreshTokenUpdatedCallback(
-      run_loop.QuitClosure());
+  identity_manager_observer()->set_on_refresh_token_updated_callback(
+      base::BindOnce(
+          [](base::OnceClosure quit_closure, const std::string& account_id) {
+            std::move(quit_closure).Run();
+          },
+          run_loop.QuitClosure()));
 
   std::string account_id = accounts_mutator()->AddOrUpdateAccount(
       kTestGaiaId, kTestEmail, kRefreshToken,
@@ -531,8 +540,12 @@
 
   // Now add the second account.
   base::RunLoop run_loop2;
-  identity_manager_observer()->SetOnRefreshTokenUpdatedCallback(
-      run_loop2.QuitClosure());
+  identity_manager_observer()->set_on_refresh_token_updated_callback(
+      base::BindOnce(
+          [](base::OnceClosure quit_closure, const std::string& account_id) {
+            std::move(quit_closure).Run();
+          },
+          run_loop2.QuitClosure()));
 
   std::string account_id2 = accounts_mutator()->AddOrUpdateAccount(
       kTestGaiaId2, kTestEmail2, kRefreshToken2,
@@ -576,19 +589,10 @@
   auto* other_accounts_mutator =
       other_identity_test_env.identity_manager()->GetAccountsMutator();
 
-  std::string device_id_1 = signin::GetOrCreateScopedDeviceId(pref_service());
-  EXPECT_FALSE(device_id_1.empty());
-
   accounts_mutator()->MoveAccount(other_accounts_mutator,
                                   account_info.account_id);
   EXPECT_EQ(0U, identity_manager()->GetAccountsWithRefreshTokens().size());
 
-  std::string device_id_2 = signin::GetOrCreateScopedDeviceId(pref_service());
-  EXPECT_FALSE(device_id_2.empty());
-  // |device_id_1| and |device_id_2| should be different as the divice ID is
-  // recreated in MoveAccount().
-  EXPECT_NE(device_id_1, device_id_2);
-
   auto other_accounts_with_refresh_token =
       other_identity_test_env.identity_manager()
           ->GetAccountsWithRefreshTokens();
@@ -602,83 +606,4 @@
 }
 #endif  // BUILDFLAG(ENABLE_DICE_SUPPORT)
 
-TEST_F(AccountsMutatorTest, LegacySetRefreshTokenForSupervisedUser) {
-  // Abort the test if the current platform does not support accounts mutation.
-  if (!accounts_mutator())
-    return;
-
-  EXPECT_EQ(identity_manager()->GetAccountsWithRefreshTokens().size(), 0U);
-
-  base::RunLoop run_loop;
-  identity_manager_observer()->SetOnRefreshTokenUpdatedCallback(
-      run_loop.QuitClosure());
-
-  accounts_mutator()->LegacySetRefreshTokenForSupervisedUser(kRefreshToken);
-  run_loop.Run();
-
-  // In the context of supervised users, the ProfileOAuth2TokenService is used
-  // without the AccountTrackerService being used, so we can't use any of the
-  // IdentityManager::FindAccountInfoForAccountWithRefreshTokenBy*() methods
-  // since they won't find any account. Use GetAccountsWithRefreshTokens() and
-  // HasAccountWithRefreshToken*() instead, that only relies in the PO2TS.
-  std::vector<AccountInfo> accounts =
-      identity_manager()->GetAccountsWithRefreshTokens();
-  EXPECT_EQ(accounts.size(), 1U);
-  EXPECT_EQ(accounts[0].account_id, kSupervisedUserPseudoEmail);
-  EXPECT_EQ(accounts[0].email, kSupervisedUserPseudoEmail);
-  EXPECT_TRUE(
-      identity_manager()->HasAccountWithRefreshToken(accounts[0].account_id));
-  EXPECT_FALSE(
-      identity_manager()->HasAccountWithRefreshTokenInPersistentErrorState(
-          accounts[0].account_id));
-}
-
-TEST_F(AccountsMutatorTest, UpdateAccessTokenFromSource) {
-  // Abort the test if the current platform does not support accounts mutation.
-  if (!accounts_mutator())
-    return;
-
-  // Add a default account.
-  std::string account_id = accounts_mutator()->AddOrUpdateAccount(
-      kTestGaiaId, kTestEmail, "refresh_token", false,
-      signin_metrics::SourceForRefreshTokenOperation::kUnknown);
-  EXPECT_EQ(
-      account_id,
-      identity_manager_diagnostics_observer()->token_updator_account_id());
-  EXPECT_TRUE(identity_manager_diagnostics_observer()
-                  ->is_token_updator_refresh_token_valid());
-  EXPECT_EQ("Unknown",
-            identity_manager_diagnostics_observer()->token_updator_source());
-
-  // Update the default account with different source.
-  accounts_mutator()->AddOrUpdateAccount(
-      kTestGaiaId, kTestEmail, "refresh_token2", true,
-      signin_metrics::SourceForRefreshTokenOperation::kSettings_Signout);
-  EXPECT_EQ(
-      account_id,
-      identity_manager_diagnostics_observer()->token_updator_account_id());
-  EXPECT_TRUE(identity_manager_diagnostics_observer()
-                  ->is_token_updator_refresh_token_valid());
-  EXPECT_EQ("Settings::Signout",
-            identity_manager_diagnostics_observer()->token_updator_source());
-}
-
-TEST_F(AccountsMutatorTest, RemoveRefreshTokenFromSource) {
-  // Abort the test if the current platform does not support accounts mutation.
-  if (!accounts_mutator())
-    return;
-
-  // Add a default account.
-  std::string account_id = accounts_mutator()->AddOrUpdateAccount(
-      kTestGaiaId, kTestEmail, "refresh_token", false,
-      signin_metrics::SourceForRefreshTokenOperation::kSettings_Signout);
-
-  // Remove the default account.
-  accounts_mutator()->RemoveAccount(
-      kTestGaiaId,
-      signin_metrics::SourceForRefreshTokenOperation::kSettings_Signout);
-  EXPECT_EQ("Settings::Signout",
-            identity_manager_diagnostics_observer()->token_remover_source());
-}
-
 }  // namespace identity
--- a/services/identity/public/cpp/BUILD.gn	2019-05-01 01:22:56.000000000 +0300
+++ b/services/identity/public/cpp/BUILD.gn	2019-05-17 18:53:37.860000000 +0300
@@ -8,15 +8,9 @@
     "access_token_fetcher.h",
     "access_token_info.cc",
     "access_token_info.h",
-    "accounts_cookie_mutator.h",
-    "accounts_cookie_mutator_impl.cc",
-    "accounts_cookie_mutator_impl.h",
     "accounts_in_cookie_jar_info.cc",
     "accounts_in_cookie_jar_info.h",
     "accounts_mutator.h",
-    "diagnostics_provider.h",
-    "diagnostics_provider_impl.cc",
-    "diagnostics_provider_impl.h",
     "identity_manager.cc",
     "identity_manager.h",
     "primary_account_access_token_fetcher.cc",
@@ -47,10 +41,6 @@
     "//services/identity/public/cpp:cpp_types",
     "//services/network/public/cpp",
   ]
-
-  deps = [
-    "//components/prefs:prefs",
-  ]
 }
 
 # A source_set for types which the public interfaces depend on for typemapping.
@@ -74,29 +64,22 @@
     "identity_test_environment.h",
     "identity_test_utils.cc",
     "identity_test_utils.h",
-    "test_identity_manager_observer.cc",
-    "test_identity_manager_observer.h",
   ]
 
   public_deps = [
     ":cpp",
-    "//components/signin/core/browser:internals_test_support",
-    "//components/sync_preferences:test_support",
-    "//google_apis:test_support",
   ]
 
   deps = [
-    "//components/image_fetcher/core:test_support",
-    "//components/signin/core/browser",
+    "//components/signin/core/browser:internals_test_support",
+    "//components/sync_preferences:test_support",
   ]
 }
 
 source_set("tests") {
   testonly = true
   sources = [
-    "accounts_cookie_mutator_unittest.cc",
     "accounts_mutator_unittest.cc",
-    "diagnostics_provider_unittest.cc",
     "primary_account_mutator_unittest.cc",
   ]
 
@@ -105,23 +88,6 @@
     ":test_support",
     "//base",
     "//base/test:test_support",
-    "//components/signin/core/browser:internals_test_support",
-    "//components/sync_preferences:test_support",
-    "//services/network:test_support",
-    "//testing/gmock",
     "//testing/gtest",
   ]
 }
-
-source_set("manifest") {
-  sources = [
-    "manifest.cc",
-    "manifest.h",
-  ]
-
-  deps = [
-    "//base",
-    "//services/identity/public/mojom",
-    "//services/service_manager/public/cpp",
-  ]
-}
--- a/services/identity/public/cpp/DEPS	2019-05-01 01:22:56.000000000 +0300
+++ b/services/identity/public/cpp/DEPS	2019-05-17 18:53:37.860000000 +0300
@@ -1,24 +1,21 @@
 include_rules = [
   "+components/prefs/testing_pref_service.h",
-  "+components/signin/core/browser/account_consistency_method.h",
   "+components/signin/core/browser/account_fetcher_service.h",
   "+components/signin/core/browser/account_info.h",
-  "+components/signin/core/browser/child_account_info_fetcher_android.h",
-  "+components/signin/core/browser/test_image_decoder.h",
+  "+components/signin/core/browser/fake_account_fetcher_service.h",
+  "+components/signin/core/browser/fake_gaia_cookie_manager_service.h",
   "+components/signin/core/browser/gaia_cookie_manager_service.h",
-  "+components/signin/core/browser/list_accounts_test_utils.h",
-  "+components/signin/core/browser/oauth2_token_service_delegate_android.h",
+  "+components/signin/core/browser/account_consistency_method.h",
   "+components/signin/core/browser/signin_buildflags.h",
+  "+components/signin/core/browser/signin_internals_util.h",
   "+components/signin/core/browser/signin_metrics.h",
   "+components/signin/core/browser/signin_switches.h",
   "+components/signin/core/browser/ubertoken_fetcher_impl.h",
   "+components/signin/core/browser/ubertoken_fetcher.h",
-  "+google_apis/gaia/gaia_auth_fetcher.h",
   "+google_apis/gaia/gaia_auth_util.h",
   "+google_apis/gaia/google_service_auth_error.h",
   "+google_apis/gaia/oauth2_access_token_consumer.h",
   "+google_apis/gaia/oauth2_token_service.h",
-  "+google_apis/gaia/oauth2_token_service_delegate.h",
   "+services/network/public/cpp",
 ]
 
@@ -27,21 +24,8 @@
     "+google_apis/gaia/oauth2_token_service_delegate.h",
     "+services/network/test/test_url_loader_factory.h",
   ],
-  "accounts_cookie_mutator_unittest.cc" : [
-    "+google_apis/gaia/gaia_constants.h",
-    "+google_apis/gaia/gaia_urls.h",
-    "+services/network/test/test_url_loader_factory.h",
-    "+services/network/test/test_utils.h",
-  ],
-  "accounts_mutator_unittest.cc": [
-    "+services/network/test/test_url_loader_factory.h",
-  ],
   "identity_manager_unittest.cc": [
     "+google_apis/gaia/oauth2_token_service_delegate.h",
-    "+services/network/test/test_cookie_manager.h",
     "+services/network/test/test_url_loader_factory.h",
-  ],
-  "diagnostics_provider_unittest.cc": [
-    "+google_apis/gaia/fake_oauth2_token_service_delegate.h",
   ]
 }
--- a/services/identity/public/cpp/identity_manager.cc	2019-05-17 17:45:42.512000000 +0300
+++ b/services/identity/public/cpp/identity_manager.cc	2019-05-17 18:53:37.864000000 +0300
@@ -4,22 +4,13 @@
 
 #include "services/identity/public/cpp/identity_manager.h"
 
-#include <string>
-
 #include "build/build_config.h"
-#include "components/signin/core/browser/account_fetcher_service.h"
 #include "components/signin/core/browser/ubertoken_fetcher_impl.h"
 #include "google_apis/gaia/gaia_auth_util.h"
-#include "services/identity/public/cpp/accounts_cookie_mutator.h"
 #include "services/identity/public/cpp/accounts_mutator.h"
-#include "services/identity/public/cpp/diagnostics_provider.h"
 #include "services/identity/public/cpp/primary_account_mutator.h"
 #include "services/network/public/cpp/shared_url_loader_factory.h"
 
-#if defined(OS_ANDROID)
-#include "components/signin/core/browser/oauth2_token_service_delegate_android.h"
-#endif
-
 namespace identity {
 
 namespace {
@@ -42,25 +33,16 @@
 IdentityManager::IdentityManager(
     SigninManagerBase* signin_manager,
     ProfileOAuth2TokenService* token_service,
-    AccountFetcherService* account_fetcher_service,
     AccountTrackerService* account_tracker_service,
     GaiaCookieManagerService* gaia_cookie_manager_service,
     std::unique_ptr<PrimaryAccountMutator> primary_account_mutator,
-    std::unique_ptr<AccountsMutator> accounts_mutator,
-    std::unique_ptr<AccountsCookieMutator> accounts_cookie_mutator,
-    std::unique_ptr<DiagnosticsProvider> diagnostics_provider)
+    std::unique_ptr<AccountsMutator> accounts_mutator)
     : signin_manager_(signin_manager),
       token_service_(token_service),
-      account_fetcher_service_(account_fetcher_service),
       account_tracker_service_(account_tracker_service),
       gaia_cookie_manager_service_(gaia_cookie_manager_service),
       primary_account_mutator_(std::move(primary_account_mutator)),
-      accounts_mutator_(std::move(accounts_mutator)),
-      accounts_cookie_mutator_(std::move(accounts_cookie_mutator)),
-      diagnostics_provider_(std::move(diagnostics_provider)) {
-  DCHECK(account_fetcher_service_);
-  DCHECK(accounts_cookie_mutator_);
-  DCHECK(diagnostics_provider_);
+      accounts_mutator_(std::move(accounts_mutator)) {
   signin_manager_->AddObserver(this);
   token_service_->AddDiagnosticsObserver(this);
   token_service_->AddObserver(this);
@@ -105,7 +87,7 @@
 AccountsInCookieJarInfo IdentityManager::GetAccountsInCookieJar() const {
   // TODO(859882): Change this implementation to interact asynchronously with
   // GaiaCookieManagerService as detailed in
-  // https://docs.9oo91e.qjz9zk/document/d/1hcrJ44facCSHtMGBmPusvcoP-fAR300Hi-UFez8ffYQ/edit?pli=1#heading=h.w97eil1cygs2.
+  // https://docs.google.com/document/d/1hcrJ44facCSHtMGBmPusvcoP-fAR300Hi-UFez8ffYQ/edit?pli=1#heading=h.w97eil1cygs2.
   std::vector<gaia::ListedAccount> signed_in_accounts;
   std::vector<gaia::ListedAccount> signed_out_accounts;
   bool accounts_are_fresh = gaia_cookie_manager_service_->ListAccounts(
@@ -138,20 +120,6 @@
   return token_service_->AreAllCredentialsLoaded();
 }
 
-base::Optional<AccountInfo> IdentityManager::FindExtendedAccountInfoForAccount(
-    const CoreAccountInfo& account_info) const {
-  AccountInfo extended_account_info =
-      account_tracker_service_->GetAccountInfo(account_info.account_id);
-
-  // AccountTrackerService always returns an AccountInfo, even on failure. In
-  // case of failure, the AccountInfo will be unpopulated, thus we should not
-  // be able to find a valid refresh token.
-  if (!HasAccountWithRefreshToken(extended_account_info.account_id))
-    return base::nullopt;
-
-  return GetAccountInfoForAccountWithRefreshToken(account_info.account_id);
-}
-
 base::Optional<AccountInfo>
 IdentityManager::FindAccountInfoForAccountWithRefreshTokenByAccountId(
     const std::string& account_id) const {
@@ -266,11 +234,6 @@
   return AccountTrackerService::IsMigrationSupported();
 }
 
-// static
-void IdentityManager::RegisterPrefs(PrefRegistrySimple* registry) {
-  SigninManagerBase::RegisterPrefs(registry);
-}
-
 void IdentityManager::LegacySetAccountIdMigrationDone() {
   account_tracker_service_->SetMigrationDone();
 }
@@ -295,67 +258,15 @@
   return accounts_mutator_.get();
 }
 
-AccountsCookieMutator* IdentityManager::GetAccountsCookieMutator() {
-  return accounts_cookie_mutator_.get();
-}
-
-void IdentityManager::OnNetworkInitialized() {
-  gaia_cookie_manager_service_->InitCookieListener();
-  account_fetcher_service_->OnNetworkInitialized();
-}
-
-void IdentityManager::LegacyLoadCredentialsForSupervisedUser(
+void IdentityManager::LegacyLoadCredentials(
     const std::string& primary_account_id) {
   token_service_->LoadCredentials(primary_account_id);
 }
 
-DiagnosticsProvider* IdentityManager::GetDiagnosticsProvider() {
-  return diagnostics_provider_.get();
-}
-
 std::string IdentityManager::LegacySeedAccountInfo(const AccountInfo& info) {
   return account_tracker_service_->SeedAccountInfo(info);
 }
 
-#if defined(OS_IOS)
-void IdentityManager::ForceTriggerOnCookieChange() {
-  gaia_cookie_manager_service_->ForceOnCookieChangeProcessing();
-}
-
-void IdentityManager::LegacyAddAccountFromSystem(
-    const std::string& account_id) {
-  token_service_->GetDelegate()->AddAccountFromSystem(account_id);
-}
-#endif
-
-#if defined(OS_ANDROID) || defined(OS_IOS)
-void IdentityManager::LegacyReloadAccountsFromSystem() {
-  token_service_->GetDelegate()->ReloadAccountsFromSystem(
-      GetPrimaryAccountId());
-}
-#endif
-
-#if defined(OS_ANDROID)
-base::android::ScopedJavaLocalRef<jobject>
-IdentityManager::LegacyGetAccountTrackerServiceJavaObject() {
-  return account_tracker_service_->GetJavaObject();
-}
-
-base::android::ScopedJavaLocalRef<jobject>
-IdentityManager::LegacyGetOAuth2TokenServiceJavaObject() {
-  OAuth2TokenServiceDelegateAndroid* delegate =
-      static_cast<OAuth2TokenServiceDelegateAndroid*>(
-          token_service_->GetDelegate());
-  return delegate->GetJavaObject();
-}
-
-void IdentityManager::ForceRefreshOfExtendedAccountInfo(
-    const std::string& account_id) {
-  DCHECK(HasAccountWithRefreshToken(account_id));
-  account_fetcher_service_->ForceRefreshOfAccountInfo(account_id);
-}
-#endif
-
 void IdentityManager::AddObserver(Observer* observer) {
   observer_list_.AddObserver(observer);
 }
@@ -384,10 +295,6 @@
   return account_tracker_service_;
 }
 
-GaiaCookieManagerService* IdentityManager::GetGaiaCookieManagerService() {
-  return gaia_cookie_manager_service_;
-}
-
 void IdentityManager::SetPrimaryAccountSynchronouslyForTests(
     const std::string& gaia_id,
     const std::string& email_address,
@@ -449,6 +356,14 @@
   }
 }
 
+void IdentityManager::GoogleSigninSucceededWithPassword(
+    const AccountInfo& account_info,
+    const std::string& password) {
+  for (auto& observer : observer_list_) {
+    observer.OnPrimaryAccountSetWithPassword(account_info, password);
+  }
+}
+
 void IdentityManager::GoogleSignedOut(const AccountInfo& account_info) {
   DCHECK(!HasPrimaryAccount());
   for (auto& observer : observer_list_) {
@@ -462,7 +377,7 @@
 }
 
 void IdentityManager::OnRefreshTokenAvailable(const std::string& account_id) {
-  CoreAccountInfo account_info =
+  AccountInfo account_info =
       GetAccountInfoForAccountWithRefreshToken(account_id);
 
   for (auto& observer : observer_list_) {
@@ -481,6 +396,11 @@
     observer.OnRefreshTokensLoaded();
 }
 
+void IdentityManager::OnStartBatchChanges() {
+  for (auto& observer : observer_list_)
+    observer.OnStartBatchOfRefreshTokenStateChanges();
+}
+
 void IdentityManager::OnEndBatchChanges() {
   for (auto& observer : observer_list_)
     observer.OnEndBatchOfRefreshTokenStateChanges();
@@ -489,7 +409,7 @@
 void IdentityManager::OnAuthErrorChanged(
     const std::string& account_id,
     const GoogleServiceAuthError& auth_error) {
-  CoreAccountInfo account_info =
+  AccountInfo account_info =
       GetAccountInfoForAccountWithRefreshToken(account_id);
 
   for (auto& observer : observer_list_)
@@ -510,9 +430,11 @@
   }
 }
 
-void IdentityManager::OnGaiaCookieDeletedByUserAction() {
+void IdentityManager::OnAddAccountToCookieCompleted(
+    const std::string& account_id,
+    const GoogleServiceAuthError& error) {
   for (auto& observer : observer_list_) {
-    observer.OnAccountsCookieDeletedByUserAction();
+    observer.OnAddAccountToCookieCompleted(account_id, error);
   }
 }
 
@@ -527,47 +449,15 @@
   }
 }
 
-void IdentityManager::OnFetchAccessTokenComplete(const std::string& account_id,
-                                                 const std::string& consumer_id,
-                                                 const ScopeSet& scopes,
-                                                 GoogleServiceAuthError error,
-                                                 base::Time expiration_time) {
-  for (auto& observer : diagnostics_observer_list_)
-    observer.OnAccessTokenRequestCompleted(account_id, consumer_id, scopes,
-                                           error, expiration_time);
-}
-
-void IdentityManager::OnAccessTokenRemoved(const std::string& account_id,
-                                           const ScopeSet& scopes) {
-  for (auto& observer : diagnostics_observer_list_)
-    observer.OnAccessTokenRemovedFromCache(account_id, scopes);
-}
-
-void IdentityManager::OnRefreshTokenAvailableFromSource(
-    const std::string& account_id,
-    bool is_refresh_token_valid,
-    const std::string& source) {
-  for (auto& observer : diagnostics_observer_list_)
-    observer.OnRefreshTokenUpdatedForAccountFromSource(
-        account_id, is_refresh_token_valid, source);
-}
-
-void IdentityManager::OnRefreshTokenRevokedFromSource(
-    const std::string& account_id,
-    const std::string& source) {
-  for (auto& observer : diagnostics_observer_list_)
-    observer.OnRefreshTokenRemovedForAccountFromSource(account_id, source);
-}
-
 void IdentityManager::OnAccountUpdated(const AccountInfo& info) {
   for (auto& observer : observer_list_) {
-    observer.OnExtendedAccountInfoUpdated(info);
+    observer.OnAccountUpdated(info);
   }
 }
 
 void IdentityManager::OnAccountRemoved(const AccountInfo& info) {
   for (auto& observer : observer_list_)
-    observer.OnExtendedAccountInfoRemoved(info);
+    observer.OnAccountRemovedWithInfo(info);
 }
 
 }  // namespace identity
--- a/services/identity/public/cpp/identity_manager.h	2019-05-17 17:45:42.512000000 +0300
+++ b/services/identity/public/cpp/identity_manager.h	2019-05-17 18:53:37.864000000 +0300
@@ -5,21 +5,16 @@
 #ifndef SERVICES_IDENTITY_PUBLIC_CPP_IDENTITY_MANAGER_H_
 #define SERVICES_IDENTITY_PUBLIC_CPP_IDENTITY_MANAGER_H_
 
-#include <memory>
-#include <string>
-
 #include "base/observer_list.h"
-#include "build/build_config.h"
-#include "components/signin/core/browser/account_fetcher_service.h"
 #include "components/signin/core/browser/account_info.h"
 #include "components/signin/core/browser/account_tracker_service.h"
 #include "components/signin/core/browser/gaia_cookie_manager_service.h"
 #include "components/signin/core/browser/profile_oauth2_token_service.h"
+#include "components/signin/core/browser/signin_internals_util.h"
 #include "components/signin/core/browser/signin_manager_base.h"
 #include "components/signin/core/browser/signin_metrics.h"
 #include "components/signin/core/browser/ubertoken_fetcher.h"
 #include "services/identity/public/cpp/access_token_fetcher.h"
-#include "services/identity/public/cpp/accounts_cookie_mutator.h"
 #include "services/identity/public/cpp/accounts_in_cookie_jar_info.h"
 #include "services/identity/public/cpp/scope_set.h"
 
@@ -27,10 +22,6 @@
 #include "components/signin/core/browser/signin_manager.h"
 #endif
 
-#if defined(OS_ANDROID)
-#include "base/android/jni_android.h"
-#endif
-
 // Necessary to declare this class as a friend.
 namespace arc {
 class ArcTermsOfServiceDefaultNegotiatorTest;
@@ -40,26 +31,20 @@
 namespace chromeos {
 class ChromeSessionManager;
 class UserSessionManager;
-}  // namespace chromeos
+}
 
 namespace network {
 class SharedURLLoaderFactory;
-class TestURLLoaderFactory;
-}  // namespace network
+}
 
 // Necessary to declare these classes as friends.
 class ArcSupportHostTest;
-class IdentityManagerFactory;
-class PrefRegistrySimple;
 
 namespace identity {
 
 class AccountsMutator;
-class AccountsCookieMutator;
-class DiagnosticsProvider;
 class PrimaryAccountMutator;
 enum class ClearPrimaryAccountPolicy;
-struct CookieParams;
 
 // Gives access to information about the user's Google identities. See
 // ./README.md for detailed documentation.
@@ -79,13 +64,20 @@
 
     // Called when an account becomes the user's primary account.
     // This method is not called during a reauth.
-    virtual void OnPrimaryAccountSet(
-        const CoreAccountInfo& primary_account_info) {}
+    virtual void OnPrimaryAccountSet(const AccountInfo& primary_account_info) {}
+
+    // Called when an account becomes the user's primary account using the
+    // legacy workflow (non-DICE). If access to the password is not required,
+    // it is preferred to instead override OnPrimaryAccountSet() which will
+    // also be called at the same time.
+    virtual void OnPrimaryAccountSetWithPassword(
+        const AccountInfo& primary_account_info,
+        const std::string& password) {}
 
     // Called when when the user moves from having a primary account to no
     // longer having a primary account.
     virtual void OnPrimaryAccountCleared(
-        const CoreAccountInfo& previous_primary_account_info) {}
+        const AccountInfo& previous_primary_account_info) {}
 
     // Called when the user attempts but fails to set their primary
     // account. |error| gives the reason for the failure.
@@ -97,9 +89,9 @@
     // OnPrimaryAccountSet() callback is undefined. If you as a client are
     // interested in both callbacks, PrimaryAccountAccessTokenFetcher will
     // likely meet your needs. Otherwise, if this lack of ordering is
-    // problematic for your use case, please contact blundell@ch40m1um.qjz9zk.
+    // problematic for your use case, please contact blundell@chromium.org.
     virtual void OnRefreshTokenUpdatedForAccount(
-        const CoreAccountInfo& account_info) {}
+        const AccountInfo& account_info) {}
 
     // Called when the refresh token previously associated with |account_id|
     // has been removed. At the time that this callback is invoked, there is
@@ -111,7 +103,7 @@
     // TODO(https://crbug.com/884731): Eliminate these corner cases.
     // NOTE: On a signout event, the ordering of this callback wrt the
     // OnPrimaryAccountCleared() callback is undefined.If this lack of ordering
-    // is problematic for your use case, please contact blundell@ch40m1um.qjz9zk.
+    // is problematic for your use case, please contact blundell@chromium.org.
     virtual void OnRefreshTokenRemovedForAccount(
         const std::string& account_id) {}
 
@@ -120,7 +112,7 @@
     // |OnRefreshTokenUpdatedForAccount| when the refresh token is updated. It
     // is not called when the refresh token is removed.
     virtual void OnErrorStateOfRefreshTokenUpdatedForAccount(
-        const CoreAccountInfo& account_info,
+        const AccountInfo& account_info,
         const GoogleServiceAuthError& error) {}
 
     // Called after refresh tokens are loaded.
@@ -144,18 +136,24 @@
         const AccountsInCookieJarInfo& accounts_in_cookie_jar_info,
         const GoogleServiceAuthError& error) {}
 
-    // Called when the Gaia cookie has been deleted explicitly by a user
-    // action, e.g. from the settings or by an extension.
-    virtual void OnAccountsCookieDeletedByUserAction() {}
+    // Called whenever an attempt to add |account_id| to the list of Gaia
+    // accounts in the cookie jar has finished. If |error| is equal to
+    // GoogleServiceAuthError::AuthErrorNone() then the addittion succeeded.
+    virtual void OnAddAccountToCookieCompleted(
+        const std::string& account_id,
+        const GoogleServiceAuthError& error) {}
+
+    // Called before a batch of refresh token state changes is started.
+    virtual void OnStartBatchOfRefreshTokenStateChanges() {}
 
     // Called after a batch of refresh token state chagnes is completed.
     virtual void OnEndBatchOfRefreshTokenStateChanges() {}
 
     // Called after an account is updated.
-    virtual void OnExtendedAccountInfoUpdated(const AccountInfo& info) {}
+    virtual void OnAccountUpdated(const AccountInfo& info) {}
 
     // Called after removing an account info.
-    virtual void OnExtendedAccountInfoRemoved(const AccountInfo& info) {}
+    virtual void OnAccountRemovedWithInfo(const AccountInfo& info) {}
   };
 
   // Observer interface for classes that want to monitor status of various
@@ -172,31 +170,6 @@
     virtual void OnAccessTokenRequested(const std::string& account_id,
                                         const std::string& consumer_id,
                                         const identity::ScopeSet& scopes) {}
-
-    // Called when an access token request is completed. Contains diagnostic
-    // information about the access token request.
-    virtual void OnAccessTokenRequestCompleted(const std::string& account_id,
-                                               const std::string& consumer_id,
-                                               const ScopeSet& scopes,
-                                               GoogleServiceAuthError error,
-                                               base::Time expiration_time) {}
-
-    // Called when an access token was removed.
-    virtual void OnAccessTokenRemovedFromCache(const std::string& account_id,
-                                               const ScopeSet& scopes) {}
-
-    // Called when a new refresh token is available. Contains diagnostic
-    // information about the source of the operation.
-    virtual void OnRefreshTokenUpdatedForAccountFromSource(
-        const std::string& account_id,
-        bool is_refresh_token_valid,
-        const std::string& source) {}
-
-    // Called when a refreh token is removed. Contains diagnostic information
-    // about the source that initiated the revokation operation.
-    virtual void OnRefreshTokenRemovedForAccountFromSource(
-        const std::string& account_id,
-        const std::string& source) {}
   };
 
   // Possible values for the account ID migration state, needs to be kept in
@@ -211,13 +184,10 @@
   IdentityManager(
       SigninManagerBase* signin_manager,
       ProfileOAuth2TokenService* token_service,
-      AccountFetcherService* account_fetcher_service,
       AccountTrackerService* account_tracker_service,
       GaiaCookieManagerService* gaia_cookie_manager_service,
       std::unique_ptr<PrimaryAccountMutator> primary_account_mutator,
-      std::unique_ptr<AccountsMutator> accounts_mutator,
-      std::unique_ptr<AccountsCookieMutator> accounts_cookie_mutator,
-      std::unique_ptr<DiagnosticsProvider> diagnostics_provider);
+      std::unique_ptr<AccountsMutator> accounts_mutator);
   ~IdentityManager() override;
 
   // Provides access to the extended information of the user's primary account.
@@ -279,12 +249,6 @@
   // Returns true if all refresh tokens have been loaded from disk.
   bool AreRefreshTokensLoaded() const;
 
-  // Returns extended information for account identified by |account_info|.
-  // The information will be returned if the information is available and
-  // refresh token is available for account.
-  base::Optional<AccountInfo> FindExtendedAccountInfoForAccount(
-      const CoreAccountInfo& account_info) const;
-
   // Looks up and returns information for account with given |account_id|. If
   // the account cannot be found, return an empty optional. This is equivalent
   // to searching on the vector returned by GetAccountsWithRefreshTokens() but
@@ -359,9 +323,6 @@
   // supported for the current platform.
   static bool IsAccountIdMigrationSupported();
 
-  // Registers local state prefs used by this class.
-  static void RegisterPrefs(PrefRegistrySimple* registry);
-
   // Marks the migration state for account IDs as finished.
   void LegacySetAccountIdMigrationDone();
 
@@ -378,22 +339,14 @@
   // returns null.
   AccountsMutator* GetAccountsMutator();
 
-  // Returns pointer to the object used to manipulate the cookies stored and the
-  // accounts associated with them. Guaranteed to be non-null.
-  AccountsCookieMutator* GetAccountsCookieMutator();
-
-  // Performs initalization that is dependent on the network being initialized.
-  void OnNetworkInitialized();
-
-  // Explicitly triggers the loading of accounts in the context of supervised
-  // users.
-  // TODO(https://crbug.com/860492): Eliminate the need to expose this.
-  void LegacyLoadCredentialsForSupervisedUser(
-      const std::string& primary_account_id);
-
-  // Returns pointer to the object used to obtain diagnostics about the internal
-  // state of IdentityManager.
-  DiagnosticsProvider* GetDiagnosticsProvider();
+  // Loads credentials from a backing persistent store to make them available
+  // after service is used between profile restarts.
+  // NOTE: In normal usage this method SHOULD NOT be called as the loading of
+  // accounts from disk occurs as part of the internal startup flow. The method
+  // is only used in production for a very small number of corner case startup
+  // flows.
+  // TODO(https://crbug.com/922450): Eliminate the need to expose this.
+  void LegacyLoadCredentials(const std::string& primary_account_id);
 
   // Picks the correct account_id for the specified account depending on the
   // migration state.
@@ -411,54 +364,6 @@
   // account id. It's only for replacement of production code.
   std::string LegacySeedAccountInfo(const AccountInfo& info);
 
-#if defined(OS_IOS)
-  // Forces the processing of GaiaCookieManagerService::OnCookieChange. On
-  // iOS, it's necessary to force-trigger the processing of cookie changes
-  // from the client as the normal mechanism for internally observing them
-  // is not wired up.
-  // TODO(https://crbug.com/930582) : Remove the need to expose this method
-  // or move it to the network::CookieManager.
-  void ForceTriggerOnCookieChange();
-
-  // Adds a given account to the token service from a system account. This
-  // API calls OAuth2TokenServiceDelegate::AddAccountFromSystem and it
-  // triggers platform specific implementation for IOS.
-  // NOTE: In normal usage, this method SHOULD NOT be called.
-  // TODO(https://crbug.com/930094): Eliminate the need to expose this.
-  void LegacyAddAccountFromSystem(const std::string& account_id);
-#endif
-
-#if defined(OS_ANDROID) || defined(OS_IOS)
-  // Reloads the accounts in the token service from the system accounts. This
-  // API calls OAuth2TokenServiceDelegate::ReloadAccountsFromSystem and it
-  // triggers platform specific implementation for Android and IOS.
-  // NOTE: In normal usage, this method SHOULD NOT be called.
-  // TODO(https://crbug.com/930094): Eliminate the need to expose this.
-  void LegacyReloadAccountsFromSystem();
-#endif
-
-#if defined(OS_ANDROID)
-  // Returns a pointer to the AccountTrackerService Java instance associated
-  // with this object.
-  // TODO(https://crbug.com/934688): Eliminate this method once
-  // AccountTrackerService.java has no more client usage.
-  base::android::ScopedJavaLocalRef<jobject>
-  LegacyGetAccountTrackerServiceJavaObject();
-
-  // Returns a pointer to the OAuth2TokenService Java instance associated
-  // with this object.
-  // TODO(https://crbug.com/934688): Eliminate this method once
-  // OAuth2TokenService.java has no more client usage.
-  base::android::ScopedJavaLocalRef<jobject>
-  LegacyGetOAuth2TokenServiceJavaObject();
-
-  // This method has the contractual assumption that the account is a known
-  // account and has as its semantics that it fetches the account info for the
-  // account, triggering an OnExtendedAccountInfoUpdated() callback if the info
-  // was successfully fetched.
-  void ForceRefreshOfExtendedAccountInfo(const std::string& refresh_token);
-#endif
-
   // Methods to register or remove observers.
   void AddObserver(Observer* observer);
   void RemoveObserver(Observer* observer);
@@ -467,7 +372,7 @@
 
  private:
   // These test helpers need to use some of the private methods below.
-  friend CoreAccountInfo SetPrimaryAccount(IdentityManager* identity_manager,
+  friend AccountInfo SetPrimaryAccount(IdentityManager* identity_manager,
                                            const std::string& email);
   friend void SetRefreshTokenForPrimaryAccount(
       IdentityManager* identity_manager,
@@ -493,9 +398,6 @@
                                            const std::string& account_id);
   friend void UpdateAccountInfoForAccount(IdentityManager* identity_manager,
                                           AccountInfo account_info);
-  friend void SetFreshnessOfAccountsInGaiaCookie(
-      IdentityManager* identity_manager,
-      bool accounts_are_fresh);
   friend void UpdatePersistentErrorOfRefreshTokenForAccount(
       IdentityManager* identity_manager,
       const std::string& account_id,
@@ -503,26 +405,16 @@
 
   friend void DisableAccessTokenFetchRetries(IdentityManager* identity_manager);
 
-  friend void CancelAllOngoingGaiaCookieOperations(
-      IdentityManager* identity_manager);
-
-  friend void SetCookieAccounts(
-      IdentityManager* identity_manager,
-      network::TestURLLoaderFactory* test_url_loader_factory,
-      const std::vector<identity::CookieParams>& cookie_accounts);
-
   // These clients needs to call SetPrimaryAccountSynchronously().
   friend ArcSupportHostTest;
   friend arc::ArcTermsOfServiceDefaultNegotiatorTest;
   friend chromeos::ChromeSessionManager;
   friend chromeos::UserSessionManager;
-  friend IdentityManagerFactory;
 
   // Private getters used for testing only (i.e. see identity_test_utils.h).
   SigninManagerBase* GetSigninManager();
   ProfileOAuth2TokenService* GetTokenService();
   AccountTrackerService* GetAccountTrackerService();
-  GaiaCookieManagerService* GetGaiaCookieManagerService();
 
   // Sets the primary account info synchronously with both the IdentityManager
   // and its backing SigninManager/ProfileOAuth2TokenService instances.
@@ -549,6 +441,8 @@
 
   // SigninManagerBase::Observer:
   void GoogleSigninSucceeded(const AccountInfo& account_info) override;
+  void GoogleSigninSucceededWithPassword(const AccountInfo& account_info,
+                                         const std::string& password) override;
   void GoogleSignedOut(const AccountInfo& account_info) override;
   void GoogleSigninFailed(const GoogleServiceAuthError& error) override;
 
@@ -556,6 +450,7 @@
   void OnRefreshTokenAvailable(const std::string& account_id) override;
   void OnRefreshTokenRevoked(const std::string& account_id) override;
   void OnRefreshTokensLoaded() override;
+  void OnStartBatchChanges() override;
   void OnEndBatchChanges() override;
   void OnAuthErrorChanged(const std::string& account_id,
                           const GoogleServiceAuthError& auth_error) override;
@@ -565,25 +460,15 @@
       const std::vector<gaia::ListedAccount>& signed_in_accounts,
       const std::vector<gaia::ListedAccount>& signed_out_accounts,
       const GoogleServiceAuthError& error) override;
-  void OnGaiaCookieDeletedByUserAction() override;
+  void OnAddAccountToCookieCompleted(
+      const std::string& account_id,
+      const GoogleServiceAuthError& error) override;
 
   // OAuth2TokenService::DiagnosticsObserver:
   void OnAccessTokenRequested(
       const std::string& account_id,
       const std::string& consumer_id,
       const OAuth2TokenService::ScopeSet& scopes) override;
-  void OnFetchAccessTokenComplete(const std::string& account_id,
-                                  const std::string& consumer_id,
-                                  const ScopeSet& scopes,
-                                  GoogleServiceAuthError error,
-                                  base::Time expiration_time) override;
-  void OnAccessTokenRemoved(const std::string& account_id,
-                            const ScopeSet& scopes) override;
-  void OnRefreshTokenAvailableFromSource(const std::string& account_id,
-                                         bool is_refresh_token_valid,
-                                         const std::string& source) override;
-  void OnRefreshTokenRevokedFromSource(const std::string& account_id,
-                                       const std::string& source) override;
 
   // AccountTrackerService::Observer:
   void OnAccountUpdated(const AccountInfo& info) override;
@@ -595,7 +480,6 @@
   // backed by the Identity Service.
   SigninManagerBase* signin_manager_;
   ProfileOAuth2TokenService* token_service_;
-  AccountFetcherService* account_fetcher_service_;
   AccountTrackerService* account_tracker_service_;
   GaiaCookieManagerService* gaia_cookie_manager_service_;
 
@@ -607,13 +491,6 @@
   // supported on the current platform.
   std::unique_ptr<AccountsMutator> accounts_mutator_;
 
-  // AccountsCookieMutator instance. Guaranteed to be non-null, as this
-  // functionality is supported on all platforms.
-  std::unique_ptr<AccountsCookieMutator> accounts_cookie_mutator_;
-
-  // DiagnosticsProvider instance.
-  std::unique_ptr<DiagnosticsProvider> diagnostics_provider_;
-
   // Lists of observers.
   // Makes sure lists are empty on destruction.
   base::ObserverList<Observer, true>::Unchecked observer_list_;
--- a/services/identity/public/cpp/identity_manager_unittest.cc	2019-05-17 17:45:42.516000000 +0300
+++ b/services/identity/public/cpp/identity_manager_unittest.cc	2019-05-17 18:53:37.864000000 +0300
@@ -3,69 +3,47 @@
 // found in the LICENSE file.
 
 #include "services/identity/public/cpp/identity_manager.h"
-
-#include <memory>
-#include <utility>
-#include <vector>
-
-#include "base/bind.h"
 #include "base/command_line.h"
 #include "base/containers/flat_set.h"
 #include "base/message_loop/message_loop.h"
 #include "base/run_loop.h"
 #include "base/stl_util.h"
-#include "base/test/bind_test_util.h"
 #include "build/build_config.h"
 #include "components/signin/core/browser/account_consistency_method.h"
 #include "components/signin/core/browser/account_tracker_service.h"
+#include "components/signin/core/browser/fake_gaia_cookie_manager_service.h"
 #include "components/signin/core/browser/fake_profile_oauth2_token_service.h"
-#include "components/signin/core/browser/list_accounts_test_utils.h"
-#include "components/signin/core/browser/signin_manager.h"
+#include "components/signin/core/browser/fake_signin_manager.h"
 #include "components/signin/core/browser/signin_switches.h"
-#include "components/signin/core/browser/test_image_decoder.h"
 #include "components/signin/core/browser/test_signin_client.h"
 #include "components/sync_preferences/testing_pref_service_syncable.h"
 #include "google_apis/gaia/google_service_auth_error.h"
 #include "google_apis/gaia/oauth2_token_service_delegate.h"
-#include "services/identity/public/cpp/accounts_cookie_mutator.h"
-#include "services/identity/public/cpp/accounts_cookie_mutator_impl.h"
 #include "services/identity/public/cpp/accounts_mutator.h"
-#include "services/identity/public/cpp/diagnostics_provider_impl.h"
-#include "services/identity/public/cpp/identity_manager.h"
 #include "services/identity/public/cpp/identity_test_utils.h"
 #include "services/identity/public/cpp/primary_account_mutator.h"
-#include "services/identity/public/cpp/test_identity_manager_observer.h"
 #include "services/network/public/cpp/weak_wrapper_shared_url_loader_factory.h"
-#include "services/network/test/test_cookie_manager.h"
 #include "services/network/test/test_url_loader_factory.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
-#if defined(OS_ANDROID)
-#include "components/signin/core/browser/child_account_info_fetcher_android.h"
-#endif
-
 namespace identity {
 namespace {
 
-const char kTestConsumerId[] = "dummy_consumer";
-const char kTestConsumerId2[] = "dummy_consumer 2";
+#if defined(OS_CHROMEOS)
+using SigninManagerForTest = FakeSigninManagerBase;
+#else
+using SigninManagerForTest = FakeSigninManager;
+#endif  // OS_CHROMEOS
+
 const char kTestGaiaId[] = "dummyId";
 const char kTestGaiaId2[] = "dummyId2";
 const char kTestGaiaId3[] = "dummyId3";
-const char kTestEmail[] = "me@9ma1l.qjz9zk";
-const char kTestEmail2[] = "me2@9ma1l.qjz9zk";
-const char kTestEmail3[] = "me3@9ma1l.qjz9zk";
-
-#if defined(OS_ANDROID)
-const char kTestHostedDomain[] = "example.com";
-const char kTestFullName[] = "full_name";
-const char kTestGivenName[] = "given_name";
-const char kTestLocale[] = "locale";
-const char kTestPictureUrl[] = "http://picture.example.com/picture.jpg";
-#endif
+const char kTestEmail[] = "me@gmail.com";
+const char kTestEmail2[] = "me2@gmail.com";
+const char kTestEmail3[] = "me3@gmail.com";
 
 #if defined(OS_CHROMEOS)
-const char kTestEmailWithPeriod[] = "m.e@9ma1l.qjz9zk";
+const char kTestEmailWithPeriod[] = "m.e@gmail.com";
 #endif
 
 // Subclass of FakeProfileOAuth2TokenService with bespoke behavior.
@@ -96,12 +74,6 @@
       EXPECT_EQ(expected_account_id_to_invalidate_, account_id);
       EXPECT_EQ(expected_scopes_to_invalidate_, scopes);
       EXPECT_EQ(expected_access_token_to_invalidate_, access_token);
-
-      // It should trigger OnAccessTokenRemovedFromCache from
-      // IdentityManager::DiagnosticsObserver.
-      for (auto& observer : GetDiagnicsObservers())
-        observer.OnAccessTokenRemoved(account_id, scopes);
-
       std::move(on_access_token_invalidated_callback_).Run();
     }
   }
@@ -141,28 +113,24 @@
     on_google_signed_out_callback_ = std::move(callback);
   }
 
-  const CoreAccountInfo& primary_account_from_signin_callback() const {
+  const AccountInfo& primary_account_from_signin_callback() const {
     return primary_account_from_signin_callback_;
   }
-  const CoreAccountInfo& primary_account_from_signout_callback() const {
+  const AccountInfo& primary_account_from_signout_callback() const {
     return primary_account_from_signout_callback_;
   }
 
  private:
   // SigninManager::Observer:
-  void GoogleSigninSucceeded(const AccountInfo&) override {
-    // Fetch the primary account from IdentityManager. The goal is to check
-    // that the account from IdentityManager has correct values even if other
-    // SigninManager::Observer are notified.
+  void GoogleSigninSucceeded(const AccountInfo& account_info) override {
+    ASSERT_TRUE(identity_manager_);
     primary_account_from_signin_callback_ =
         identity_manager_->GetPrimaryAccountInfo();
     if (on_google_signin_succeeded_callback_)
       std::move(on_google_signin_succeeded_callback_).Run();
   }
-  void GoogleSignedOut(const AccountInfo&) override {
-    // Fetch the primary account from IdentityManager. The goal is to check
-    // that the account from IdentityManager has correct values even if other
-    // SigninManager::Observer are notified.
+  void GoogleSignedOut(const AccountInfo& account_info) override {
+    ASSERT_TRUE(identity_manager_);
     primary_account_from_signout_callback_ =
         identity_manager_->GetPrimaryAccountInfo();
     if (on_google_signed_out_callback_)
@@ -174,8 +142,8 @@
   base::OnceClosure on_google_signin_succeeded_callback_;
   base::OnceClosure on_google_signin_failed_callback_;
   base::OnceClosure on_google_signed_out_callback_;
-  CoreAccountInfo primary_account_from_signin_callback_;
-  CoreAccountInfo primary_account_from_signout_callback_;
+  AccountInfo primary_account_from_signin_callback_;
+  AccountInfo primary_account_from_signout_callback_;
 };
 
 // Class that observes updates from ProfileOAuth2TokenService and and verifies
@@ -222,6 +190,216 @@
   base::OnceClosure on_refresh_token_revoked_callback_;
 };
 
+class TestIdentityManagerObserver : IdentityManager::Observer {
+ public:
+  explicit TestIdentityManagerObserver(IdentityManager* identity_manager)
+      : identity_manager_(identity_manager) {
+    identity_manager_->AddObserver(this);
+  }
+  ~TestIdentityManagerObserver() override {
+    identity_manager_->RemoveObserver(this);
+  }
+
+  void set_on_primary_account_set_callback(base::OnceClosure callback) {
+    on_primary_account_set_callback_ = std::move(callback);
+  }
+  void set_on_primary_account_cleared_callback(base::OnceClosure callback) {
+    on_primary_account_cleared_callback_ = std::move(callback);
+  }
+  void set_on_primary_account_signin_failed_callback(
+      base::OnceClosure callback) {
+    on_primary_account_signin_failed_callback_ = std::move(callback);
+  }
+
+  const AccountInfo& primary_account_from_set_callback() {
+    return primary_account_from_set_callback_;
+  }
+  const AccountInfo& primary_account_from_cleared_callback() {
+    return primary_account_from_cleared_callback_;
+  }
+
+  void set_on_refresh_token_updated_callback(base::OnceClosure callback) {
+    on_refresh_token_updated_callback_ = std::move(callback);
+  }
+  // This method uses a RepeatingCallback to simplify verification of multiple
+  // removed tokens.
+  void set_on_refresh_token_removed_callback(
+      base::RepeatingCallback<void(const std::string&)> callback) {
+    on_refresh_token_removed_callback_ = std::move(callback);
+  }
+  void set_on_error_state_of_refresh_token_updated_callback(
+      base::OnceClosure callback) {
+    on_error_state_of_refresh_token_updated_callback_ = std::move(callback);
+  }
+
+  void set_on_refresh_tokens_loaded_callback(base::OnceClosure callback) {
+    on_refresh_tokens_loaded_callback_ = std::move(callback);
+  }
+
+  const AccountInfo& account_from_refresh_token_updated_callback() {
+    return account_from_refresh_token_updated_callback_;
+  }
+  const std::string& account_from_refresh_token_removed_callback() {
+    return account_from_refresh_token_removed_callback_;
+  }
+  const AccountInfo&
+  account_from_error_state_of_refresh_token_updated_callback() {
+    return account_from_error_state_of_refresh_token_updated_callback_;
+  }
+  const GoogleServiceAuthError&
+  error_from_error_state_of_refresh_token_updated_callback() const {
+    return error_from_error_state_of_refresh_token_updated_callback_;
+  }
+
+  void set_on_accounts_in_cookie_updated_callback(base::OnceClosure callback) {
+    on_accounts_in_cookie_updated_callback_ = std::move(callback);
+  }
+
+  const AccountsInCookieJarInfo& accounts_info_from_cookie_change_callback() {
+    return accounts_info_from_cookie_change_callback_;
+  }
+
+  const std::string& account_from_add_account_to_cookie_completed_callback()
+      const {
+    return account_from_add_account_to_cookie_completed_callback_;
+  }
+
+  const GoogleServiceAuthError&
+  error_from_add_account_to_cookie_completed_callback() const {
+    return error_from_add_account_to_cookie_completed_callback_;
+  }
+
+  const GoogleServiceAuthError& error_from_signin_failed_callback() const {
+    return google_signin_failed_error_;
+  }
+
+  // Each element represents all the changes from an individual batch that has
+  // occurred, with the elements ordered from oldest to newest batch occurrence.
+  const std::vector<std::vector<std::string>>& batch_change_records() const {
+    return batch_change_records_;
+  }
+
+  const AccountInfo& account_from_account_updated_callback() {
+    return account_from_account_updated_callback_;
+  }
+
+  const AccountInfo& account_from_account_removed_with_info_callback() {
+    return account_from_account_removed_with_info_callback_;
+  }
+
+  bool was_called_account_removed_with_info_callback() {
+    return was_called_account_removed_with_info_callback_;
+  }
+
+ private:
+  // IdentityManager::Observer:
+  void OnPrimaryAccountSet(const AccountInfo& primary_account_info) override {
+    primary_account_from_set_callback_ = primary_account_info;
+    if (on_primary_account_set_callback_)
+      std::move(on_primary_account_set_callback_).Run();
+  }
+  void OnPrimaryAccountCleared(
+      const AccountInfo& previous_primary_account_info) override {
+    primary_account_from_cleared_callback_ = previous_primary_account_info;
+    if (on_primary_account_cleared_callback_)
+      std::move(on_primary_account_cleared_callback_).Run();
+  }
+  void OnPrimaryAccountSigninFailed(
+      const GoogleServiceAuthError& error) override {
+    google_signin_failed_error_ = error;
+    if (on_primary_account_signin_failed_callback_)
+      std::move(on_primary_account_signin_failed_callback_).Run();
+  }
+  void OnRefreshTokenUpdatedForAccount(
+      const AccountInfo& account_info) override {
+    EXPECT_TRUE(is_inside_batch_);
+    batch_change_records_.rbegin()->emplace_back(account_info.account_id);
+    account_from_refresh_token_updated_callback_ = account_info;
+    if (on_refresh_token_updated_callback_)
+      std::move(on_refresh_token_updated_callback_).Run();
+  }
+  void OnRefreshTokenRemovedForAccount(const std::string& account_id) override {
+    EXPECT_TRUE(is_inside_batch_);
+    batch_change_records_.rbegin()->emplace_back(account_id);
+    account_from_refresh_token_removed_callback_ = account_id;
+    if (on_refresh_token_removed_callback_)
+      on_refresh_token_removed_callback_.Run(account_id);
+  }
+  void OnErrorStateOfRefreshTokenUpdatedForAccount(
+      const AccountInfo& account_info,
+      const GoogleServiceAuthError& error) override {
+    account_from_error_state_of_refresh_token_updated_callback_ = account_info;
+    error_from_error_state_of_refresh_token_updated_callback_ = error;
+    if (on_error_state_of_refresh_token_updated_callback_)
+      std::move(on_error_state_of_refresh_token_updated_callback_).Run();
+  }
+  void OnRefreshTokensLoaded() override {
+    if (on_refresh_tokens_loaded_callback_)
+      std::move(on_refresh_tokens_loaded_callback_).Run();
+  }
+  void OnAccountsInCookieUpdated(
+      const AccountsInCookieJarInfo& accounts_in_cookie_jar_info,
+      const GoogleServiceAuthError& error) override {
+    accounts_info_from_cookie_change_callback_ = accounts_in_cookie_jar_info;
+    if (on_accounts_in_cookie_updated_callback_)
+      std::move(on_accounts_in_cookie_updated_callback_).Run();
+  }
+  void OnAddAccountToCookieCompleted(
+      const std::string& account_id,
+      const GoogleServiceAuthError& error) override {
+    account_from_add_account_to_cookie_completed_callback_ = account_id;
+    error_from_add_account_to_cookie_completed_callback_ = error;
+  }
+
+  void OnStartBatchOfRefreshTokenStateChanges() override {
+    EXPECT_FALSE(is_inside_batch_);
+    is_inside_batch_ = true;
+
+    // Start a new batch.
+    batch_change_records_.emplace_back(std::vector<std::string>());
+  }
+  void OnEndBatchOfRefreshTokenStateChanges() override {
+    EXPECT_TRUE(is_inside_batch_);
+    is_inside_batch_ = false;
+  }
+
+  void OnAccountUpdated(const AccountInfo& info) override {
+    account_from_account_updated_callback_ = info;
+  }
+
+  void OnAccountRemovedWithInfo(const AccountInfo& info) override {
+    was_called_account_removed_with_info_callback_ = true;
+    account_from_account_removed_with_info_callback_ = info;
+  }
+
+  IdentityManager* identity_manager_;
+  base::OnceClosure on_primary_account_set_callback_;
+  base::OnceClosure on_primary_account_cleared_callback_;
+  base::OnceClosure on_primary_account_signin_failed_callback_;
+  base::OnceClosure on_refresh_token_updated_callback_;
+  base::RepeatingCallback<void(const std::string&)>
+      on_refresh_token_removed_callback_;
+  base::OnceClosure on_error_state_of_refresh_token_updated_callback_;
+  base::OnceClosure on_refresh_tokens_loaded_callback_;
+  base::OnceClosure on_accounts_in_cookie_updated_callback_;
+  AccountInfo primary_account_from_set_callback_;
+  AccountInfo primary_account_from_cleared_callback_;
+  AccountInfo account_from_refresh_token_updated_callback_;
+  std::string account_from_refresh_token_removed_callback_;
+  AccountInfo account_from_error_state_of_refresh_token_updated_callback_;
+  AccountInfo account_from_account_updated_callback_;
+  AccountInfo account_from_account_removed_with_info_callback_;
+  GoogleServiceAuthError
+      error_from_error_state_of_refresh_token_updated_callback_;
+  AccountsInCookieJarInfo accounts_info_from_cookie_change_callback_;
+  std::string account_from_add_account_to_cookie_completed_callback_;
+  GoogleServiceAuthError error_from_add_account_to_cookie_completed_callback_;
+  GoogleServiceAuthError google_signin_failed_error_;
+  bool is_inside_batch_ = false;
+  bool was_called_account_removed_with_info_callback_ = false;
+  std::vector<std::vector<std::string>> batch_change_records_;
+};
+
 class TestIdentityManagerDiagnosticsObserver
     : IdentityManager::DiagnosticsObserver {
  public:
@@ -238,11 +416,6 @@
     on_access_token_requested_callback_ = std::move(callback);
   }
 
-  void set_on_access_token_request_completed_callback(
-      base::OnceClosure callback) {
-    on_access_token_request_completed_callback_ = std::move(callback);
-  }
-
   const std::string& token_requestor_account_id() {
     return token_requestor_account_id_;
   }
@@ -252,24 +425,6 @@
   const identity::ScopeSet& token_requestor_scopes() {
     return token_requestor_scopes_;
   }
-  const std::string& token_remover_account_id() {
-    return token_remover_account_id_;
-  }
-  const identity::ScopeSet& token_remover_scopes() {
-    return token_remover_scopes_;
-  }
-  const std::string& on_access_token_request_completed_account_id() {
-    return access_token_request_completed_account_id_;
-  }
-  const std::string& on_access_token_request_completed_consumer_id() {
-    return access_token_request_completed_consumer_id_;
-  }
-  const identity::ScopeSet& on_access_token_request_completed_scopes() {
-    return access_token_request_completed_scopes_;
-  }
-  const GoogleServiceAuthError& on_access_token_request_completed_error() {
-    return access_token_request_completed_error_;
-  }
 
  private:
   // IdentityManager::DiagnosticsObserver:
@@ -284,80 +439,35 @@
       std::move(on_access_token_requested_callback_).Run();
   }
 
-  void OnAccessTokenRemovedFromCache(const std::string& account_id,
-                                     const ScopeSet& scopes) override {
-    token_remover_account_id_ = account_id;
-    token_remover_scopes_ = scopes;
-  }
-
-  void OnAccessTokenRequestCompleted(const std::string& account_id,
-                                     const std::string& consumer_id,
-                                     const ScopeSet& scopes,
-                                     GoogleServiceAuthError error,
-                                     base::Time expiration_time) override {
-    access_token_request_completed_account_id_ = account_id;
-    access_token_request_completed_consumer_id_ = consumer_id;
-    access_token_request_completed_scopes_ = scopes;
-    access_token_request_completed_error_ = error;
-
-    if (on_access_token_request_completed_callback_)
-      std::move(on_access_token_request_completed_callback_).Run();
-  }
-
   IdentityManager* identity_manager_;
   base::OnceClosure on_access_token_requested_callback_;
-  base::OnceClosure on_access_token_request_completed_callback_;
   std::string token_requestor_account_id_;
   std::string token_requestor_consumer_id_;
-  std::string token_remover_account_id_;
   identity::ScopeSet token_requestor_scopes_;
-  identity::ScopeSet token_remover_scopes_;
-  std::string access_token_request_completed_account_id_;
-  std::string access_token_request_completed_consumer_id_;
-  identity::ScopeSet access_token_request_completed_scopes_;
-  GoogleServiceAuthError access_token_request_completed_error_;
 };
 
 }  // namespace
 
 class IdentityManagerTest : public testing::Test {
- protected:
+ public:
   IdentityManagerTest()
       : signin_client_(&pref_service_),
         token_service_(&pref_service_),
-        gaia_cookie_manager_service_(
-            &token_service_,
+        gaia_cookie_manager_service_(&token_service_,
             &signin_client_,
-            base::BindRepeating(
-                [](network::TestURLLoaderFactory* test_url_loader_factory)
-                    -> scoped_refptr<network::SharedURLLoaderFactory> {
-                  return test_url_loader_factory->GetSafeWeakWrapper();
-                },
-                test_url_loader_factory())) {
+                                     &test_url_loader_factory_) {
     AccountTrackerService::RegisterPrefs(pref_service_.registry());
-    AccountFetcherService::RegisterPrefs(pref_service_.registry());
     ProfileOAuth2TokenService::RegisterProfilePrefs(pref_service_.registry());
     SigninManagerBase::RegisterProfilePrefs(pref_service_.registry());
     SigninManagerBase::RegisterPrefs(pref_service_.registry());
 
     account_tracker_.Initialize(&pref_service_, base::FilePath());
-    account_fetcher_.Initialize(&signin_client_, &token_service_,
-                                &account_tracker_,
-                                std::make_unique<TestImageDecoder>());
 
     RecreateSigninAndIdentityManager(
         signin::AccountConsistencyMethod::kDisabled,
         SigninManagerSetup::kWithAuthenticatedAccout);
   }
 
-  ~IdentityManagerTest() override {
-    signin_client_.Shutdown();
-    token_service_.Shutdown();
-    gaia_cookie_manager_service_.Shutdown();
-    account_tracker_.Shutdown();
-    account_fetcher_.Shutdown();
-  }
-
   IdentityManager* identity_manager() { return identity_manager_.get(); }
   TestIdentityManagerObserver* identity_manager_observer() {
     return identity_manager_observer_.get();
@@ -367,12 +477,11 @@
     return identity_manager_diagnostics_observer_.get();
   }
   AccountTrackerServiceForTest* account_tracker() { return &account_tracker_; }
-  AccountFetcherService* account_fetcher() { return &account_fetcher_; }
-  SigninManagerBase* signin_manager() { return signin_manager_.get(); }
+  SigninManagerForTest* signin_manager() { return signin_manager_.get(); }
   CustomFakeProfileOAuth2TokenService* token_service() {
     return &token_service_;
   }
-  GaiaCookieManagerService* gaia_cookie_manager_service() {
+  FakeGaiaCookieManagerService* gaia_cookie_manager_service() {
     return &gaia_cookie_manager_service_;
   }
 
@@ -405,10 +514,10 @@
 #if defined(OS_CHROMEOS)
     DCHECK_EQ(account_consistency, signin::AccountConsistencyMethod::kDisabled)
         << "AccountConsistency is not used by SigninManagerBase";
-    signin_manager_ = std::make_unique<SigninManagerBase>(
+    signin_manager_ = std::make_unique<FakeSigninManagerBase>(
         &signin_client_, &token_service_, &account_tracker_);
 #else
-    signin_manager_ = std::make_unique<SigninManager>(
+    signin_manager_ = std::make_unique<FakeSigninManager>(
         &signin_client_, &token_service_, &account_tracker_,
         &gaia_cookie_manager_service_, account_consistency);
 #endif
@@ -441,12 +550,8 @@
     identity_manager_.reset();
 
     identity_manager_.reset(new IdentityManager(
-        signin_manager_.get(), &token_service_, &account_fetcher_,
-        &account_tracker_, &gaia_cookie_manager_service_, nullptr, nullptr,
-        std::make_unique<AccountsCookieMutatorImpl>(
-            &gaia_cookie_manager_service_),
-        std::make_unique<DiagnosticsProviderImpl>(
-            &token_service_, &gaia_cookie_manager_service_)));
+        signin_manager_.get(), &token_service_, &account_tracker_,
+        &gaia_cookie_manager_service_, nullptr, nullptr));
     identity_manager_observer_.reset(
         new TestIdentityManagerObserver(identity_manager_.get()));
     identity_manager_diagnostics_observer_.reset(
@@ -464,34 +569,15 @@
     consumer->OnMergeSessionFailure(error);
   }
 
-  void SimulateCookieDeletedByUser(
-      network::mojom::CookieChangeListener* listener,
-      const net::CanonicalCookie& cookie) {
-    listener->OnCookieChange(cookie,
-                             network::mojom::CookieChangeCause::EXPLICIT);
-  }
-
-  void SimulateOAuthMultiloginFinished(GaiaAuthConsumer* consumer,
-                                       const OAuthMultiloginResult& result) {
-    consumer->OnOAuthMultiloginFinished(result);
-  }
-
-  TestSigninClient* signin_client() { return &signin_client_; }
-
-  network::TestURLLoaderFactory* test_url_loader_factory() {
-    return &test_url_loader_factory_;
-  }
-
  private:
   base::MessageLoop message_loop_;
   sync_preferences::TestingPrefServiceSyncable pref_service_;
   AccountTrackerServiceForTest account_tracker_;
-  AccountFetcherService account_fetcher_;
   TestSigninClient signin_client_;
   CustomFakeProfileOAuth2TokenService token_service_;
   network::TestURLLoaderFactory test_url_loader_factory_;
-  GaiaCookieManagerService gaia_cookie_manager_service_;
-  std::unique_ptr<SigninManagerBase> signin_manager_;
+  FakeGaiaCookieManagerService gaia_cookie_manager_service_;
+  std::unique_ptr<SigninManagerForTest> signin_manager_;
   std::unique_ptr<IdentityManager> identity_manager_;
   std::unique_ptr<TestIdentityManagerObserver> identity_manager_observer_;
   std::unique_ptr<TestIdentityManagerDiagnosticsObserver>
@@ -502,7 +588,7 @@
 
 // Test that IdentityManager starts off with the information in SigninManager.
 TEST_F(IdentityManagerTest, PrimaryAccountInfoAtStartup) {
-  CoreAccountInfo primary_account_info =
+  AccountInfo primary_account_info =
       identity_manager()->GetPrimaryAccountInfo();
   EXPECT_EQ(kTestGaiaId, primary_account_info.gaia);
   EXPECT_EQ(kTestEmail, primary_account_info.email);
@@ -514,16 +600,19 @@
 // Test that the user signing in results in firing of the IdentityManager
 // observer callback and the IdentityManager's state being updated.
 TEST_F(IdentityManagerTest, PrimaryAccountInfoAfterSignin) {
-  ClearPrimaryAccount(identity_manager(), ClearPrimaryAccountPolicy::DEFAULT);
+  base::RunLoop run_loop;
+  identity_manager_observer()->set_on_primary_account_set_callback(
+      run_loop.QuitClosure());
 
-  SetPrimaryAccount(identity_manager(), kTestEmail);
+  signin_manager()->SignIn(kTestGaiaId, kTestEmail, "password");
+  run_loop.Run();
 
-  CoreAccountInfo primary_account_from_set_callback =
-      identity_manager_observer()->PrimaryAccountFromSetCallback();
+  AccountInfo primary_account_from_set_callback =
+      identity_manager_observer()->primary_account_from_set_callback();
   EXPECT_EQ(kTestGaiaId, primary_account_from_set_callback.gaia);
   EXPECT_EQ(kTestEmail, primary_account_from_set_callback.email);
 
-  CoreAccountInfo primary_account_info =
+  AccountInfo primary_account_info =
       identity_manager()->GetPrimaryAccountInfo();
   EXPECT_EQ(kTestGaiaId, primary_account_info.gaia);
   EXPECT_EQ(kTestEmail, primary_account_info.email);
@@ -536,21 +625,29 @@
 // Test that the user signing out results in firing of the IdentityManager
 // observer callback and the IdentityManager's state being updated.
 TEST_F(IdentityManagerTest, PrimaryAccountInfoAfterSigninAndSignout) {
-  ClearPrimaryAccount(identity_manager(), ClearPrimaryAccountPolicy::DEFAULT);
   // First ensure that the user is signed in from the POV of the
   // IdentityManager.
-  SetPrimaryAccount(identity_manager(), kTestEmail);
+  base::RunLoop run_loop;
+  identity_manager_observer()->set_on_primary_account_set_callback(
+      run_loop.QuitClosure());
+  signin_manager()->SignIn(kTestGaiaId, kTestEmail, "password");
+  run_loop.Run();
 
   // Sign the user out and check that the IdentityManager responds
   // appropriately.
-  ClearPrimaryAccount(identity_manager(), ClearPrimaryAccountPolicy::DEFAULT);
+  base::RunLoop run_loop2;
+  identity_manager_observer()->set_on_primary_account_cleared_callback(
+      run_loop2.QuitClosure());
 
-  CoreAccountInfo primary_account_from_cleared_callback =
-      identity_manager_observer()->PrimaryAccountFromClearedCallback();
+  signin_manager()->ForceSignOut();
+  run_loop2.Run();
+
+  AccountInfo primary_account_from_cleared_callback =
+      identity_manager_observer()->primary_account_from_cleared_callback();
   EXPECT_EQ(kTestGaiaId, primary_account_from_cleared_callback.gaia);
   EXPECT_EQ(kTestEmail, primary_account_from_cleared_callback.email);
 
-  CoreAccountInfo primary_account_info =
+  AccountInfo primary_account_info =
       identity_manager()->GetPrimaryAccountInfo();
   EXPECT_EQ("", primary_account_info.gaia);
   EXPECT_EQ("", primary_account_info.email);
@@ -563,17 +660,20 @@
 // Test that the primary account's ID remains tracked by the IdentityManager
 // after signing in even after having removed the account without signing out.
 TEST_F(IdentityManagerTest, PrimaryAccountInfoAfterSigninAndAccountRemoval) {
-  ClearPrimaryAccount(identity_manager(), ClearPrimaryAccountPolicy::DEFAULT);
   // First ensure that the user is signed in from the POV of the
   // IdentityManager.
-  SetPrimaryAccount(identity_manager(), kTestEmail);
+  base::RunLoop run_loop;
+  identity_manager_observer()->set_on_primary_account_set_callback(
+      run_loop.QuitClosure());
+  signin_manager()->SignIn(kTestGaiaId, kTestEmail, "password");
+  run_loop.Run();
 
   // Remove the account from the AccountTrackerService and check that
   // the returned AccountInfo won't have a valid ID anymore, even if
   // the IdentityManager is still storing the primary account's ID.
   account_tracker()->RemoveAccount(kTestGaiaId);
 
-  CoreAccountInfo primary_account_info =
+  AccountInfo primary_account_info =
       identity_manager()->GetPrimaryAccountInfo();
   EXPECT_EQ("", primary_account_info.gaia);
   EXPECT_EQ("", primary_account_info.email);
@@ -595,7 +695,12 @@
 #if !defined(OS_CHROMEOS)
   // Signing out should cause IdentityManager to recognize that there is no
   // longer a primary account.
-  ClearPrimaryAccount(identity_manager(), ClearPrimaryAccountPolicy::DEFAULT);
+  base::RunLoop run_loop;
+  identity_manager_observer()->set_on_primary_account_cleared_callback(
+      run_loop.QuitClosure());
+
+  signin_manager()->ForceSignOut();
+  run_loop.Run();
   EXPECT_FALSE(identity_manager()->HasPrimaryAccount());
 #endif
 }
@@ -638,7 +743,7 @@
 
 TEST_F(IdentityManagerTest,
        QueryingOfRefreshTokensInteractionWithPrimaryAccount) {
-  CoreAccountInfo account_info = identity_manager()->GetPrimaryAccountInfo();
+  AccountInfo account_info = identity_manager()->GetPrimaryAccountInfo();
   std::string account_id = account_info.account_id;
 
   // Should not have a refresh token for the primary account at initialization.
@@ -701,7 +806,7 @@
 
 TEST_F(IdentityManagerTest,
        QueryingOfRefreshTokensReflectsNonemptyInitialState) {
-  CoreAccountInfo account_info = identity_manager()->GetPrimaryAccountInfo();
+  AccountInfo account_info = identity_manager()->GetPrimaryAccountInfo();
   std::string account_id = account_info.account_id;
 
   EXPECT_FALSE(
@@ -944,7 +1049,7 @@
 TEST_F(
     IdentityManagerTest,
     HasAccountWithRefreshTokenInteractionBetweenPrimaryAndSecondaryAccounts) {
-  CoreAccountInfo primary_account_info =
+  AccountInfo primary_account_info =
       identity_manager()->GetPrimaryAccountInfo();
   std::string primary_account_id = primary_account_info.account_id;
 
@@ -986,7 +1091,7 @@
 
 TEST_F(IdentityManagerTest,
        CallbackSentOnUpdateToErrorStateOfRefreshTokenForAccount) {
-  CoreAccountInfo primary_account_info =
+  AccountInfo primary_account_info =
       identity_manager()->GetPrimaryAccountInfo();
   std::string primary_account_id = primary_account_info.account_id;
   SetRefreshTokenForPrimaryAccount(identity_manager());
@@ -1009,22 +1114,22 @@
                                              account_deleted_error);
   EXPECT_EQ(account_id2,
             identity_manager_observer()
-                ->AccountFromErrorStateOfRefreshTokenUpdatedCallback()
+                ->account_from_error_state_of_refresh_token_updated_callback()
                 .account_id);
   EXPECT_EQ(account_deleted_error,
             identity_manager_observer()
-                ->ErrorFromErrorStateOfRefreshTokenUpdatedCallback());
+                ->error_from_error_state_of_refresh_token_updated_callback());
 
   // A transient error should not cause a callback.
   token_service()->UpdateAuthErrorForTesting(primary_account_id,
                                              transient_error);
   EXPECT_EQ(account_id2,
             identity_manager_observer()
-                ->AccountFromErrorStateOfRefreshTokenUpdatedCallback()
+                ->account_from_error_state_of_refresh_token_updated_callback()
                 .account_id);
   EXPECT_EQ(account_deleted_error,
             identity_manager_observer()
-                ->ErrorFromErrorStateOfRefreshTokenUpdatedCallback());
+                ->error_from_error_state_of_refresh_token_updated_callback());
 
   // Set a different persistent error for the primary account and check that
   // it's reflected.
@@ -1032,15 +1137,15 @@
                                              account_disabled_error);
   EXPECT_EQ(primary_account_id,
             identity_manager_observer()
-                ->AccountFromErrorStateOfRefreshTokenUpdatedCallback()
+                ->account_from_error_state_of_refresh_token_updated_callback()
                 .account_id);
   EXPECT_EQ(account_disabled_error,
             identity_manager_observer()
-                ->ErrorFromErrorStateOfRefreshTokenUpdatedCallback());
+                ->error_from_error_state_of_refresh_token_updated_callback());
 }
 
 TEST_F(IdentityManagerTest, GetErrorStateOfRefreshTokenForAccount) {
-  CoreAccountInfo primary_account_info =
+  AccountInfo primary_account_info =
       identity_manager()->GetPrimaryAccountInfo();
   std::string primary_account_id = primary_account_info.account_id;
 
@@ -1165,14 +1270,6 @@
                                                  access_token);
 
   run_loop.Run();
-
-  // RemoveAccessTokenFromCache should lead to OnAccessTokenRemovedFromCache
-  // from IdentityManager::DiagnosticsObserver.
-  EXPECT_EQ(
-      account_id,
-      identity_manager_diagnostics_observer()->token_remover_account_id());
-  EXPECT_EQ(scopes,
-            identity_manager_diagnostics_observer()->token_remover_scopes());
 }
 
 TEST_F(IdentityManagerTest, CreateAccessTokenFetcher) {
@@ -1181,7 +1278,7 @@
       [](GoogleServiceAuthError error, AccessTokenInfo access_token_info) {});
   std::unique_ptr<AccessTokenFetcher> token_fetcher =
       identity_manager()->CreateAccessTokenFetcherForAccount(
-          identity_manager()->GetPrimaryAccountId(), kTestConsumerId, scopes,
+          identity_manager()->GetPrimaryAccountId(), "dummy_consumer", scopes,
           std::move(callback), AccessTokenFetcher::Mode::kImmediate);
   EXPECT_TRUE(token_fetcher);
 }
@@ -1208,7 +1305,7 @@
           &test_url_loader_factory));
   std::unique_ptr<AccessTokenFetcher> token_fetcher =
       identity_manager()->CreateAccessTokenFetcherForAccount(
-          account_id, kTestConsumerId, test_shared_url_loader_factory, scopes,
+          account_id, "dummy_consumer", test_shared_url_loader_factory, scopes,
           std::move(callback), AccessTokenFetcher::Mode::kImmediate);
 
   run_loop.Run();
@@ -1226,7 +1323,7 @@
       account_id,
       identity_manager_diagnostics_observer()->token_requestor_account_id());
   EXPECT_EQ(
-      kTestConsumerId,
+      "dummy_consumer",
       identity_manager_diagnostics_observer()->token_requestor_consumer_id());
 
   // Cancel the pending request in preparation to check that creating an
@@ -1249,7 +1346,7 @@
   // No changes to the declared scopes and callback, we can reuse them.
   std::unique_ptr<AccessTokenFetcher> token_fetcher2 =
       identity_manager()->CreateAccessTokenFetcherForAccount(
-          account_id2, kTestConsumerId2, scopes, std::move(callback),
+          account_id2, "dummy_consumer 2", scopes, std::move(callback),
           AccessTokenFetcher::Mode::kImmediate);
 
   run_loop2.Run();
@@ -1270,7 +1367,7 @@
       account_id2,
       identity_manager_diagnostics_observer()->token_requestor_account_id());
   EXPECT_EQ(
-      kTestConsumerId2,
+      "dummy_consumer 2",
       identity_manager_diagnostics_observer()->token_requestor_consumer_id());
 }
 
@@ -1288,7 +1385,7 @@
       [](GoogleServiceAuthError error, AccessTokenInfo access_token_info) {});
   std::unique_ptr<AccessTokenFetcher> token_fetcher =
       identity_manager()->CreateAccessTokenFetcherForAccount(
-          identity_manager()->GetPrimaryAccountId(), kTestConsumerId, scopes,
+          identity_manager()->GetPrimaryAccountId(), "dummy_consumer", scopes,
           std::move(callback), AccessTokenFetcher::Mode::kImmediate);
 
   run_loop.Run();
@@ -1297,117 +1394,22 @@
       account_id,
       identity_manager_diagnostics_observer()->token_requestor_account_id());
   EXPECT_EQ(
-      kTestConsumerId,
+      "dummy_consumer",
       identity_manager_diagnostics_observer()->token_requestor_consumer_id());
   EXPECT_EQ(scopes,
             identity_manager_diagnostics_observer()->token_requestor_scopes());
 }
 
-TEST_F(IdentityManagerTest,
-       ObserveAccessTokenRequestCompletionWithoutRefreshToken) {
-  base::RunLoop run_loop;
-  identity_manager_diagnostics_observer()
-      ->set_on_access_token_request_completed_callback(run_loop.QuitClosure());
-
-  std::set<std::string> scopes{"scope"};
-  AccessTokenFetcher::TokenCallback callback = base::BindOnce(
-      [](GoogleServiceAuthError error, AccessTokenInfo access_token_info) {});
-  // Account has no refresh token.
-  std::unique_ptr<AccessTokenFetcher> token_fetcher =
-      identity_manager()->CreateAccessTokenFetcherForAccount(
-          identity_manager()->GetPrimaryAccountId(), kTestConsumerId, scopes,
-          std::move(callback), AccessTokenFetcher::Mode::kImmediate);
-
-  run_loop.Run();
-
-  EXPECT_TRUE(token_fetcher);
-  EXPECT_EQ(GoogleServiceAuthError(GoogleServiceAuthError::USER_NOT_SIGNED_UP),
-            identity_manager_diagnostics_observer()
-                ->on_access_token_request_completed_error());
-}
-
-TEST_F(IdentityManagerTest,
-       ObserveAccessTokenRequestCompletionWithRefreshToken) {
-  base::RunLoop run_loop;
-  identity_manager_diagnostics_observer()
-      ->set_on_access_token_request_completed_callback(run_loop.QuitClosure());
-
-  signin_manager()->SetAuthenticatedAccountInfo(kTestGaiaId, kTestEmail);
-  std::string account_id = signin_manager()->GetAuthenticatedAccountId();
-  token_service()->UpdateCredentials(account_id, "refresh_token");
-  token_service()->set_auto_post_fetch_response_on_message_loop(true);
-
-  std::set<std::string> scopes{"scope"};
-  AccessTokenFetcher::TokenCallback callback = base::BindOnce(
-      [](GoogleServiceAuthError error, AccessTokenInfo access_token_info) {});
-  // This should result in a request for an access token without an error.
-  std::unique_ptr<AccessTokenFetcher> token_fetcher =
-      identity_manager()->CreateAccessTokenFetcherForAccount(
-          identity_manager()->GetPrimaryAccountId(), kTestConsumerId, scopes,
-          std::move(callback), AccessTokenFetcher::Mode::kImmediate);
-
-  run_loop.Run();
-
-  EXPECT_TRUE(token_fetcher);
-  EXPECT_EQ(account_id, identity_manager_diagnostics_observer()
-                            ->on_access_token_request_completed_account_id());
-  EXPECT_EQ(kTestConsumerId,
-            identity_manager_diagnostics_observer()
-                ->on_access_token_request_completed_consumer_id());
-  EXPECT_EQ(scopes, identity_manager_diagnostics_observer()
-                        ->on_access_token_request_completed_scopes());
-  EXPECT_EQ(GoogleServiceAuthError(GoogleServiceAuthError::NONE),
-            identity_manager_diagnostics_observer()
-                ->on_access_token_request_completed_error());
-}
-
-TEST_F(IdentityManagerTest,
-       ObserveAccessTokenRequestCompletionAfterRevokingRefreshToken) {
-  base::RunLoop run_loop;
-  identity_manager_diagnostics_observer()
-      ->set_on_access_token_request_completed_callback(run_loop.QuitClosure());
-
-  account_tracker()->SeedAccountInfo(kTestGaiaId2, kTestEmail2);
-  std::string account_id2 =
-      account_tracker()->FindAccountInfoByGaiaId(kTestGaiaId2).account_id;
-  token_service()->UpdateCredentials(account_id2, "refresh_token");
-
-  std::set<std::string> scopes{"scope"};
-  AccessTokenFetcher::TokenCallback callback = base::BindOnce(
-      [](GoogleServiceAuthError error, AccessTokenInfo access_token_info) {});
-  // This should result in a request for an access token.
-  std::unique_ptr<AccessTokenFetcher> token_fetcher =
-      identity_manager()->CreateAccessTokenFetcherForAccount(
-          account_id2, kTestConsumerId2, scopes, std::move(callback),
-          AccessTokenFetcher::Mode::kImmediate);
-
-  // Revoke the refresh token result cancelling access token request.
-  token_service()->RevokeCredentials(account_id2);
-
-  run_loop.Run();
-
-  EXPECT_TRUE(token_fetcher);
-  EXPECT_EQ(GoogleServiceAuthError(GoogleServiceAuthError::REQUEST_CANCELED),
-            identity_manager_diagnostics_observer()
-                ->on_access_token_request_completed_error());
-}
-
-TEST_F(IdentityManagerTest, GetAccountsCookieMutator) {
-  AccountsCookieMutator* mutator =
-      identity_manager()->GetAccountsCookieMutator();
-  EXPECT_TRUE(mutator);
-}
-
 // Tests that requesting a load of accounts results in the notification
 // firing that tokens were loaded.
 TEST_F(IdentityManagerTest, LegacyLoadCredentials) {
   base::RunLoop run_loop;
-  identity_manager_observer()->SetOnRefreshTokensLoadedCallback(
+  identity_manager_observer()->set_on_refresh_tokens_loaded_callback(
       run_loop.QuitClosure());
 
   // Load the accounts and ensure that we see the resulting notification that
   // they were loaded.
-  identity_manager()->LegacyLoadCredentialsForSupervisedUser("");
+  identity_manager()->LegacyLoadCredentials("");
   run_loop.Run();
 }
 
@@ -1434,25 +1436,11 @@
   EXPECT_EQ(account_info.gaia, kTestGaiaId2);
 }
 
-#if defined(OS_IOS)
-TEST_F(IdentityManagerTest, ForceTriggerOnCookieChange) {
-  base::RunLoop run_loop;
-  identity_manager_observer()->SetOnAccountsInCookieUpdatedCallback(
-      run_loop.QuitClosure());
-
-  signin::SetListAccountsResponseNoAccounts(test_url_loader_factory());
-  // Forces the processing of OnCookieChange and it calls
-  // OnGaiaAccountsInCookieUpdated.
-  identity_manager()->ForceTriggerOnCookieChange();
-  run_loop.Run();
-}
-#endif
-
 #if !defined(OS_CHROMEOS)
 TEST_F(
     IdentityManagerTest,
     IdentityManagerGivesConsistentValuesFromSigninManagerObserverNotificationOfSignIn) {
-  ClearPrimaryAccount(identity_manager(), ClearPrimaryAccountPolicy::DEFAULT);
+  signin_manager()->ForceSignOut();
 
   base::RunLoop run_loop;
   TestSigninManagerObserver signin_manager_observer(signin_manager());
@@ -1467,12 +1455,10 @@
   RecreateIdentityManager();
   signin_manager_observer.set_identity_manager(identity_manager());
 
-  SigninManager::FromSigninManagerBase(signin_manager())
-      ->OnExternalSigninCompleted(kTestEmail);
-
+  signin_manager()->SignIn(kTestGaiaId, kTestEmail, "password");
   run_loop.Run();
 
-  CoreAccountInfo primary_account_from_signin_callback =
+  AccountInfo primary_account_from_signin_callback =
       signin_manager_observer.primary_account_from_signin_callback();
   EXPECT_EQ(kTestGaiaId, primary_account_from_signin_callback.gaia);
   EXPECT_EQ(kTestEmail, primary_account_from_signin_callback.email);
@@ -1494,10 +1480,10 @@
   RecreateIdentityManager();
   signin_manager_observer.set_identity_manager(identity_manager());
 
-  ClearPrimaryAccount(identity_manager(), ClearPrimaryAccountPolicy::DEFAULT);
+  signin_manager()->ForceSignOut();
   run_loop.Run();
 
-  CoreAccountInfo primary_account_from_signout_callback =
+  AccountInfo primary_account_from_signout_callback =
       signin_manager_observer.primary_account_from_signout_callback();
   EXPECT_EQ(std::string(), primary_account_from_signout_callback.gaia);
   EXPECT_EQ(std::string(), primary_account_from_signout_callback.email);
@@ -1514,7 +1500,7 @@
 // IdentityManager correctly reflects the updated version. See crbug.com/842041
 // and crbug.com/842670 for further details.
 TEST_F(IdentityManagerTest, IdentityManagerReflectsUpdatedEmailAddress) {
-  CoreAccountInfo primary_account_info =
+  AccountInfo primary_account_info =
       identity_manager()->GetPrimaryAccountInfo();
   EXPECT_EQ(kTestGaiaId, primary_account_info.gaia);
   EXPECT_EQ(kTestEmail, primary_account_info.email);
@@ -1540,8 +1526,9 @@
 
   SetRefreshTokenForPrimaryAccount(identity_manager());
 
-  CoreAccountInfo account_info =
-      identity_manager_observer()->AccountFromRefreshTokenUpdatedCallback();
+  AccountInfo account_info =
+      identity_manager_observer()
+          ->account_from_refresh_token_updated_callback();
   EXPECT_EQ(kTestGaiaId, account_info.gaia);
   EXPECT_EQ(kTestEmail, account_info.email);
 }
@@ -1552,8 +1539,9 @@
 
   SetInvalidRefreshTokenForPrimaryAccount(identity_manager());
 
-  CoreAccountInfo account_info =
-      identity_manager_observer()->AccountFromRefreshTokenUpdatedCallback();
+  AccountInfo account_info =
+      identity_manager_observer()
+          ->account_from_refresh_token_updated_callback();
   EXPECT_EQ(kTestGaiaId, account_info.gaia);
   EXPECT_EQ(kTestEmail, account_info.email);
 }
@@ -1565,9 +1553,8 @@
 
   RemoveRefreshTokenForPrimaryAccount(identity_manager());
 
-  EXPECT_EQ(
-      account_id,
-      identity_manager_observer()->AccountIdFromRefreshTokenRemovedCallback());
+  EXPECT_EQ(account_id, identity_manager_observer()
+                            ->account_from_refresh_token_removed_callback());
 }
 
 TEST_F(IdentityManagerTest,
@@ -1576,8 +1563,9 @@
       MakeAccountAvailable(identity_manager(), kTestEmail2);
   EXPECT_EQ(kTestEmail2, expected_account_info.email);
 
-  CoreAccountInfo account_info =
-      identity_manager_observer()->AccountFromRefreshTokenUpdatedCallback();
+  AccountInfo account_info =
+      identity_manager_observer()
+          ->account_from_refresh_token_updated_callback();
   EXPECT_EQ(expected_account_info.account_id, account_info.account_id);
   EXPECT_EQ(expected_account_info.gaia, account_info.gaia);
   EXPECT_EQ(expected_account_info.email, account_info.email);
@@ -1592,8 +1580,9 @@
   SetInvalidRefreshTokenForAccount(identity_manager(),
                                    expected_account_info.account_id);
 
-  CoreAccountInfo account_info =
-      identity_manager_observer()->AccountFromRefreshTokenUpdatedCallback();
+  AccountInfo account_info =
+      identity_manager_observer()
+          ->account_from_refresh_token_updated_callback();
   EXPECT_EQ(expected_account_info.account_id, account_info.account_id);
   EXPECT_EQ(expected_account_info.gaia, account_info.gaia);
   EXPECT_EQ(expected_account_info.email, account_info.email);
@@ -1607,23 +1596,28 @@
   RemoveRefreshTokenForAccount(identity_manager(),
                                expected_account_info.account_id);
 
-  EXPECT_EQ(
-      expected_account_info.account_id,
-      identity_manager_observer()->AccountIdFromRefreshTokenRemovedCallback());
+  EXPECT_EQ(expected_account_info.account_id,
+            identity_manager_observer()
+                ->account_from_refresh_token_removed_callback());
 }
 
 #if !defined(OS_CHROMEOS)
 TEST_F(
     IdentityManagerTest,
     CallbackSentOnSecondaryAccountRefreshTokenUpdateWithValidTokenWhenNoPrimaryAccount) {
-  ClearPrimaryAccount(identity_manager(), ClearPrimaryAccountPolicy::DEFAULT);
+  base::RunLoop run_loop;
+  identity_manager_observer()->set_on_primary_account_cleared_callback(
+      run_loop.QuitClosure());
+  signin_manager()->ForceSignOut();
+  run_loop.Run();
 
   AccountInfo expected_account_info =
       MakeAccountAvailable(identity_manager(), kTestEmail2);
   EXPECT_EQ(kTestEmail2, expected_account_info.email);
 
-  CoreAccountInfo account_info =
-      identity_manager_observer()->AccountFromRefreshTokenUpdatedCallback();
+  AccountInfo account_info =
+      identity_manager_observer()
+          ->account_from_refresh_token_updated_callback();
   EXPECT_EQ(expected_account_info.account_id, account_info.account_id);
   EXPECT_EQ(expected_account_info.gaia, account_info.gaia);
   EXPECT_EQ(expected_account_info.email, account_info.email);
@@ -1632,7 +1626,11 @@
 TEST_F(
     IdentityManagerTest,
     CallbackSentOnSecondaryAccountRefreshTokenUpdateWithInvalidTokenWhenNoPrimaryAccount) {
-  ClearPrimaryAccount(identity_manager(), ClearPrimaryAccountPolicy::DEFAULT);
+  base::RunLoop run_loop;
+  identity_manager_observer()->set_on_primary_account_cleared_callback(
+      run_loop.QuitClosure());
+  signin_manager()->ForceSignOut();
+  run_loop.Run();
 
   AccountInfo expected_account_info =
       MakeAccountAvailable(identity_manager(), kTestEmail2);
@@ -1641,8 +1639,9 @@
   SetInvalidRefreshTokenForAccount(identity_manager(),
                                    expected_account_info.account_id);
 
-  CoreAccountInfo account_info =
-      identity_manager_observer()->AccountFromRefreshTokenUpdatedCallback();
+  AccountInfo account_info =
+      identity_manager_observer()
+          ->account_from_refresh_token_updated_callback();
   EXPECT_EQ(expected_account_info.account_id, account_info.account_id);
   EXPECT_EQ(expected_account_info.gaia, account_info.gaia);
   EXPECT_EQ(expected_account_info.email, account_info.email);
@@ -1650,7 +1649,11 @@
 
 TEST_F(IdentityManagerTest,
        CallbackSentOnSecondaryAccountRefreshTokenRemovalWhenNoPrimaryAccount) {
-  ClearPrimaryAccount(identity_manager(), ClearPrimaryAccountPolicy::DEFAULT);
+  base::RunLoop run_loop;
+  identity_manager_observer()->set_on_primary_account_cleared_callback(
+      run_loop.QuitClosure());
+  signin_manager()->ForceSignOut();
+  run_loop.Run();
 
   AccountInfo expected_account_info =
       MakeAccountAvailable(identity_manager(), kTestEmail2);
@@ -1659,9 +1662,9 @@
   RemoveRefreshTokenForAccount(identity_manager(),
                                expected_account_info.account_id);
 
-  EXPECT_EQ(
-      expected_account_info.account_id,
-      identity_manager_observer()->AccountIdFromRefreshTokenRemovedCallback());
+  EXPECT_EQ(expected_account_info.account_id,
+            identity_manager_observer()
+                ->account_from_refresh_token_removed_callback());
 }
 #endif
 
@@ -1679,9 +1682,9 @@
   token_service()->RevokeCredentials(dummy_account_id);
   run_loop.RunUntilIdle();
 
-  EXPECT_EQ(
-      dummy_account_id,
-      identity_manager_observer()->AccountIdFromRefreshTokenRemovedCallback());
+  EXPECT_EQ(dummy_account_id,
+            identity_manager_observer()
+                ->account_from_refresh_token_removed_callback());
 }
 
 TEST_F(
@@ -1747,7 +1750,7 @@
   std::string account_id = signin_manager()->GetAuthenticatedAccountId();
 
   base::RunLoop run_loop;
-  identity_manager_observer()->SetOnRefreshTokensLoadedCallback(
+  identity_manager_observer()->set_on_refresh_tokens_loaded_callback(
       run_loop.QuitClosure());
 
   // Credentials are already loaded in SigninManager::Initialize()
@@ -1762,16 +1765,15 @@
 TEST_F(IdentityManagerTest,
        CallbackSentOnUpdateToAccountsInCookieWithNoAccounts) {
   base::RunLoop run_loop;
-  identity_manager_observer()->SetOnAccountsInCookieUpdatedCallback(
+  identity_manager_observer()->set_on_accounts_in_cookie_updated_callback(
       run_loop.QuitClosure());
 
-  signin::SetListAccountsResponseNoAccounts(test_url_loader_factory());
+  gaia_cookie_manager_service()->SetListAccountsResponseNoAccounts();
   gaia_cookie_manager_service()->TriggerListAccounts();
   run_loop.Run();
 
   const AccountsInCookieJarInfo& accounts_in_cookie_jar_info =
-      identity_manager_observer()
-          ->AccountsInfoFromAccountsInCookieUpdatedCallback();
+      identity_manager_observer()->accounts_info_from_cookie_change_callback();
   EXPECT_TRUE(accounts_in_cookie_jar_info.accounts_are_fresh);
   EXPECT_TRUE(accounts_in_cookie_jar_info.signed_in_accounts.empty());
 }
@@ -1779,17 +1781,16 @@
 TEST_F(IdentityManagerTest,
        CallbackSentOnUpdateToAccountsInCookieWithOneAccount) {
   base::RunLoop run_loop;
-  identity_manager_observer()->SetOnAccountsInCookieUpdatedCallback(
+  identity_manager_observer()->set_on_accounts_in_cookie_updated_callback(
       run_loop.QuitClosure());
 
-  signin::SetListAccountsResponseOneAccount(kTestEmail, kTestGaiaId,
-                                            test_url_loader_factory());
+  gaia_cookie_manager_service()->SetListAccountsResponseOneAccount(kTestEmail,
+                                                                   kTestGaiaId);
   gaia_cookie_manager_service()->TriggerListAccounts();
   run_loop.Run();
 
   const AccountsInCookieJarInfo& accounts_in_cookie_jar_info =
-      identity_manager_observer()
-          ->AccountsInfoFromAccountsInCookieUpdatedCallback();
+      identity_manager_observer()->accounts_info_from_cookie_change_callback();
   EXPECT_TRUE(accounts_in_cookie_jar_info.accounts_are_fresh);
   ASSERT_EQ(1u, accounts_in_cookie_jar_info.signed_in_accounts.size());
   ASSERT_TRUE(accounts_in_cookie_jar_info.signed_out_accounts.empty());
@@ -1806,18 +1807,16 @@
 TEST_F(IdentityManagerTest,
        CallbackSentOnUpdateToAccountsInCookieWithTwoAccounts) {
   base::RunLoop run_loop;
-  identity_manager_observer()->SetOnAccountsInCookieUpdatedCallback(
+  identity_manager_observer()->set_on_accounts_in_cookie_updated_callback(
       run_loop.QuitClosure());
 
-  signin::SetListAccountsResponseTwoAccounts(kTestEmail, kTestGaiaId,
-                                             kTestEmail2, kTestGaiaId2,
-                                             test_url_loader_factory());
+  gaia_cookie_manager_service()->SetListAccountsResponseTwoAccounts(
+      kTestEmail, kTestGaiaId, kTestEmail2, kTestGaiaId2);
   gaia_cookie_manager_service()->TriggerListAccounts();
   run_loop.Run();
 
   const AccountsInCookieJarInfo& accounts_in_cookie_jar_info =
-      identity_manager_observer()
-          ->AccountsInfoFromAccountsInCookieUpdatedCallback();
+      identity_manager_observer()->accounts_info_from_cookie_change_callback();
   EXPECT_TRUE(accounts_in_cookie_jar_info.accounts_are_fresh);
   ASSERT_EQ(2u, accounts_in_cookie_jar_info.signed_in_accounts.size());
   ASSERT_TRUE(accounts_in_cookie_jar_info.signed_out_accounts.empty());
@@ -1849,15 +1848,14 @@
 
   for (const auto& signed_out_status : signed_out_status_set) {
     base::RunLoop run_loop;
-    identity_manager_observer()->SetOnAccountsInCookieUpdatedCallback(
+    identity_manager_observer()->set_on_accounts_in_cookie_updated_callback(
         run_loop.QuitClosure());
 
-    signin::SetListAccountsResponseWithParams(
+    gaia_cookie_manager_service()->SetListAccountsResponseWithParams(
         {{kTestEmail, kTestGaiaId, true /* valid */,
           signed_out_status.account_1 /* signed_out */, true /* verified */},
          {kTestEmail2, kTestGaiaId2, true /* valid */,
-          signed_out_status.account_2 /* signed_out */, true /* verified */}},
-        test_url_loader_factory());
+          signed_out_status.account_2 /* signed_out */, true /* verified */}});
 
     gaia_cookie_manager_service()->TriggerListAccounts();
     run_loop.Run();
@@ -1866,7 +1864,7 @@
         signed_out_status.account_1 + signed_out_status.account_2;
     const AccountsInCookieJarInfo& accounts_in_cookie_jar_info =
         identity_manager_observer()
-            ->AccountsInfoFromAccountsInCookieUpdatedCallback();
+            ->accounts_info_from_cookie_change_callback();
     EXPECT_TRUE(accounts_in_cookie_jar_info.accounts_are_fresh);
     ASSERT_EQ(2 - accounts_signed_out,
               accounts_in_cookie_jar_info.signed_in_accounts.size());
@@ -1906,17 +1904,16 @@
 TEST_F(IdentityManagerTest,
        CallbackSentOnUpdateToAccountsInCookieWithStaleAccounts) {
   base::RunLoop run_loop;
-  identity_manager_observer()->SetOnAccountsInCookieUpdatedCallback(
+  identity_manager_observer()->set_on_accounts_in_cookie_updated_callback(
       run_loop.QuitClosure());
 
   // Configure list accounts to return a permanent Gaia auth error.
-  signin::SetListAccountsResponseWebLoginRequired(test_url_loader_factory());
+  gaia_cookie_manager_service()->SetListAccountsResponseWebLoginRequired();
   gaia_cookie_manager_service()->TriggerListAccounts();
   run_loop.Run();
 
   const AccountsInCookieJarInfo& accounts_in_cookie_jar_info =
-      identity_manager_observer()
-          ->AccountsInfoFromAccountsInCookieUpdatedCallback();
+      identity_manager_observer()->accounts_info_from_cookie_change_callback();
   EXPECT_FALSE(accounts_in_cookie_jar_info.accounts_are_fresh);
   EXPECT_TRUE(accounts_in_cookie_jar_info.signed_in_accounts.empty());
   EXPECT_TRUE(accounts_in_cookie_jar_info.signed_out_accounts.empty());
@@ -1924,10 +1921,10 @@
 
 TEST_F(IdentityManagerTest, GetAccountsInCookieJarWithNoAccounts) {
   base::RunLoop run_loop;
-  identity_manager_observer()->SetOnAccountsInCookieUpdatedCallback(
+  identity_manager_observer()->set_on_accounts_in_cookie_updated_callback(
       run_loop.QuitClosure());
 
-  signin::SetListAccountsResponseNoAccounts(test_url_loader_factory());
+  gaia_cookie_manager_service()->SetListAccountsResponseNoAccounts();
 
   // Do an initial call to GetAccountsInCookieJar(). This call should return no
   // accounts but should also trigger an internal update and eventual
@@ -1952,11 +1949,11 @@
 
 TEST_F(IdentityManagerTest, GetAccountsInCookieJarWithOneAccount) {
   base::RunLoop run_loop;
-  identity_manager_observer()->SetOnAccountsInCookieUpdatedCallback(
+  identity_manager_observer()->set_on_accounts_in_cookie_updated_callback(
       run_loop.QuitClosure());
 
-  signin::SetListAccountsResponseOneAccount(kTestEmail, kTestGaiaId,
-                                            test_url_loader_factory());
+  gaia_cookie_manager_service()->SetListAccountsResponseOneAccount(kTestEmail,
+                                                                   kTestGaiaId);
 
   // Do an initial call to GetAccountsInCookieJar(). This call should return no
   // accounts but should also trigger an internal update and eventual
@@ -1989,12 +1986,11 @@
 
 TEST_F(IdentityManagerTest, GetAccountsInCookieJarWithTwoAccounts) {
   base::RunLoop run_loop;
-  identity_manager_observer()->SetOnAccountsInCookieUpdatedCallback(
+  identity_manager_observer()->set_on_accounts_in_cookie_updated_callback(
       run_loop.QuitClosure());
 
-  signin::SetListAccountsResponseTwoAccounts(kTestEmail, kTestGaiaId,
-                                             kTestEmail2, kTestGaiaId2,
-                                             test_url_loader_factory());
+  gaia_cookie_manager_service()->SetListAccountsResponseTwoAccounts(
+      kTestEmail, kTestGaiaId, kTestEmail2, kTestGaiaId2);
 
   // Do an initial call to GetAccountsInCookieJar(). This call should return no
   // accounts but should also trigger an internal update and eventual
@@ -2037,228 +2033,32 @@
 
 TEST_F(IdentityManagerTest, CallbackSentOnSuccessfulAdditionOfAccountToCookie) {
   const char kTestAccountId[] = "account_id";
-
-  std::string account_from_add_account_to_cookie_completed_callback;
-  GoogleServiceAuthError error_from_add_account_to_cookie_completed_callback;
-  auto completion_callback = base::BindLambdaForTesting(
-      [&](const std::string& account_id, const GoogleServiceAuthError& error) {
-        account_from_add_account_to_cookie_completed_callback = account_id;
-        error_from_add_account_to_cookie_completed_callback = error;
-      });
-
-  gaia_cookie_manager_service()->AddAccountToCookie(
-      kTestAccountId, gaia::GaiaSource::kChrome,
-      std::move(completion_callback));
+  gaia_cookie_manager_service()->AddAccountToCookie(kTestAccountId,
+                                                    gaia::GaiaSource::kChrome);
   SimulateAdditionOfAccountToCookieSuccess(gaia_cookie_manager_service(),
                                            "token");
-  EXPECT_EQ(account_from_add_account_to_cookie_completed_callback,
+  EXPECT_EQ(identity_manager_observer()
+                ->account_from_add_account_to_cookie_completed_callback(),
             kTestAccountId);
-  EXPECT_EQ(error_from_add_account_to_cookie_completed_callback,
+  EXPECT_EQ(identity_manager_observer()
+                ->error_from_add_account_to_cookie_completed_callback(),
             GoogleServiceAuthError::AuthErrorNone());
 }
 
 TEST_F(IdentityManagerTest, CallbackSentOnFailureAdditionOfAccountToCookie) {
   const char kTestAccountId[] = "account_id";
-
-  std::string account_from_add_account_to_cookie_completed_callback;
-  GoogleServiceAuthError error_from_add_account_to_cookie_completed_callback;
-  auto completion_callback = base::BindLambdaForTesting(
-      [&](const std::string& account_id, const GoogleServiceAuthError& error) {
-        account_from_add_account_to_cookie_completed_callback = account_id;
-        error_from_add_account_to_cookie_completed_callback = error;
-      });
-
-  gaia_cookie_manager_service()->AddAccountToCookie(
-      kTestAccountId, gaia::GaiaSource::kChrome,
-      std::move(completion_callback));
+  gaia_cookie_manager_service()->AddAccountToCookie(kTestAccountId,
+                                                    gaia::GaiaSource::kChrome);
 
   GoogleServiceAuthError error(GoogleServiceAuthError::SERVICE_ERROR);
   SimulateAdditionOfAccountToCookieSuccessFailure(gaia_cookie_manager_service(),
                                                   error);
-
-  EXPECT_EQ(account_from_add_account_to_cookie_completed_callback,
+  EXPECT_EQ(identity_manager_observer()
+                ->account_from_add_account_to_cookie_completed_callback(),
             kTestAccountId);
-  EXPECT_EQ(error_from_add_account_to_cookie_completed_callback, error);
-}
-
-TEST_F(IdentityManagerTest,
-       CallbackSentOnSetAccountsInCookieCompleted_Success) {
-  const char kTestAccountId[] = "account_id";
-  const char kTestAccountId2[] = "account_id2";
-  const std::vector<std::string> account_ids = {kTestAccountId,
-                                                kTestAccountId2};
-
-  GoogleServiceAuthError error_from_set_accounts_in_cookie_completed_callback;
-  auto completion_callback = base::BindLambdaForTesting(
-      [&error_from_set_accounts_in_cookie_completed_callback](
-          const GoogleServiceAuthError& error) {
-        error_from_set_accounts_in_cookie_completed_callback = error;
-      });
-
-  // Needed to insert request in the queue.
-  gaia_cookie_manager_service()->SetAccountsInCookie(
-      account_ids, gaia::GaiaSource::kChrome, std::move(completion_callback));
-
-  // Sample success cookie response.
-  std::string data =
-      R"()]}'
-      {
-        "status": "OK",
-        "cookies":[
-        {
-            "name":"SID",
-            "value":"vAlUe1",
-            "domain":".google.ru",
-            "path":"/",
-            "isSecure":true,
-            "isHttpOnly":false,
-            "priority":"HIGH",
-            "maxAge":63070000
-          }
-        ]
-      }
-    )";
-  OAuthMultiloginResult result(data);
-
-  SimulateOAuthMultiloginFinished(gaia_cookie_manager_service(), result);
-
-  EXPECT_EQ(error_from_set_accounts_in_cookie_completed_callback,
-            GoogleServiceAuthError::AuthErrorNone());
-}
-
-TEST_F(IdentityManagerTest,
-       CallbackSentOnSetAccountsInCookieCompleted_Failure) {
-  const char kTestAccountId[] = "account_id";
-  const char kTestAccountId2[] = "account_id2";
-  const std::vector<std::string> account_ids = {kTestAccountId,
-                                                kTestAccountId2};
-
-  GoogleServiceAuthError error_from_set_accounts_in_cookie_completed_callback;
-  auto completion_callback = base::BindLambdaForTesting(
-      [&error_from_set_accounts_in_cookie_completed_callback](
-          const GoogleServiceAuthError& error) {
-        error_from_set_accounts_in_cookie_completed_callback = error;
-      });
-
-  // Needed to insert request in the queue.
-  gaia_cookie_manager_service()->SetAccountsInCookie(
-      account_ids, gaia::GaiaSource::kChrome, std::move(completion_callback));
-
-  // Sample an erroneous response.
-  GoogleServiceAuthError error(GoogleServiceAuthError::SERVICE_ERROR);
-  OAuthMultiloginResult result(error);
-
-  SimulateOAuthMultiloginFinished(gaia_cookie_manager_service(), result);
-
-  EXPECT_EQ(error_from_set_accounts_in_cookie_completed_callback, error);
-}
-
-TEST_F(IdentityManagerTest, CallbackSentOnAccountsCookieDeletedByUserAction) {
-  const char kTestAccountId[] = "account_id";
-  const char kTestAccountId2[] = "account_id2";
-  const std::vector<std::string> account_ids = {kTestAccountId,
-                                                kTestAccountId2};
-
-  // Needed to insert request in the queue.
-  gaia_cookie_manager_service()->SetAccountsInCookie(
-      account_ids, gaia::GaiaSource::kChrome,
-      GaiaCookieManagerService::SetAccountsInCookieCompletedCallback());
-
-  // Sample success cookie response.
-  std::string data =
-      R"()]}'
-      {
-        "status": "OK",
-        "cookies":[
-        {
-            "name":"APISID",
-            "value":"vAlUe1",
-            "domain":".9oo91e.qjz9zk",
-            "path":"/",
-            "isSecure":true,
-            "isHttpOnly":false,
-            "priority":"HIGH",
-            "maxAge":63070000
-          }
-        ]
-      }
-    )";
-  OAuthMultiloginResult result(data);
-
-  SimulateOAuthMultiloginFinished(gaia_cookie_manager_service(), result);
-  base::RunLoop().RunUntilIdle();
-
-  base::RunLoop run_loop;
-  identity_manager_observer()->SetOnCookieDeletedByUserCallback(
-      run_loop.QuitClosure());
-
-  const std::vector<net::CanonicalCookie>& cookies = result.cookies();
-  SimulateCookieDeletedByUser(gaia_cookie_manager_service(), cookies[0]);
-  run_loop.Run();
-}
-
-TEST_F(IdentityManagerTest, OnNetworkInitialized) {
-  const char kTestAccountId[] = "account_id";
-  const char kTestAccountId2[] = "account_id2";
-  const std::vector<std::string> account_ids = {kTestAccountId,
-                                                kTestAccountId2};
-
-  auto test_cookie_manager = std::make_unique<network::TestCookieManager>();
-  network::TestCookieManager* test_cookie_manager_ptr =
-      test_cookie_manager.get();
-  signin_client()->set_cookie_manager(std::move(test_cookie_manager));
-
-  identity_manager()->OnNetworkInitialized();
-
-  // Needed to insert request in the queue.
-  gaia_cookie_manager_service()->SetAccountsInCookie(
-      account_ids, gaia::GaiaSource::kChrome,
-      GaiaCookieManagerService::SetAccountsInCookieCompletedCallback());
-
-  // Sample success cookie response.
-  std::string data =
-      R"()]}'
-      {
-        "status": "OK",
-        "cookies":[
-        {
-            "name":"APISID",
-            "value":"vAlUe1",
-            "domain":".9oo91e.qjz9zk",
-            "path":"/",
-            "isSecure":true,
-            "isHttpOnly":false,
-            "priority":"HIGH",
-            "maxAge":63070000
-          }
-        ]
-      }
-    )";
-  OAuthMultiloginResult result(data);
-
-  SimulateOAuthMultiloginFinished(gaia_cookie_manager_service(), result);
-  base::RunLoop().RunUntilIdle();
-
-  base::RunLoop run_loop;
-  identity_manager_observer()->SetOnCookieDeletedByUserCallback(
-      run_loop.QuitClosure());
-
-  const std::vector<net::CanonicalCookie>& cookies = result.cookies();
-
-  // Dispatch a known change of a known cookie instance *through the mojo
-  // pipe* in order to ensure the GCMS is listening to CookieManager changes.
-  //
-  // It is important the the cause of the change is known here (ie
-  // network::mojom::CookieChangeCause::EXPLICIT) so the test can block of the
-  // proper IdentityManager observer callback to be called (in this case
-  // OnAccountsCookieDeletedByUserAction).
-  //
-  // Note that this call differs from calling SimulateCookieDeletedByUser()
-  // directly in the sense that SimulateCookieDeletedByUser() does not go
-  // through any mojo pipe.
-  test_cookie_manager_ptr->DispatchCookieChange(
-      cookies[0], network::mojom::CookieChangeCause::EXPLICIT);
-  run_loop.Run();
+  EXPECT_EQ(identity_manager_observer()
+                ->error_from_add_account_to_cookie_completed_callback(),
+            error);
 }
 
 TEST_F(IdentityManagerTest,
@@ -2267,11 +2067,11 @@
   std::string account_id = signin_manager()->GetAuthenticatedAccountId();
   token_service()->UpdateCredentials(account_id, "refresh_token");
 
-  EXPECT_EQ(1ul, identity_manager_observer()->BatchChangeRecords().size());
+  EXPECT_EQ(1ul, identity_manager_observer()->batch_change_records().size());
   EXPECT_EQ(1ul,
-            identity_manager_observer()->BatchChangeRecords().at(0).size());
+            identity_manager_observer()->batch_change_records().at(0).size());
   EXPECT_EQ(account_id,
-            identity_manager_observer()->BatchChangeRecords().at(0).at(0));
+            identity_manager_observer()->batch_change_records().at(0).at(0));
 }
 
 // Checks that FindAccountInfoForAccountWithRefreshTokenByAccountId() returns
@@ -2353,7 +2153,7 @@
 // Checks that AreRefreshTokensLoaded() returns true after LoadCredentials.
 TEST_F(IdentityManagerTest, AreRefreshTokensLoaded) {
   base::RunLoop run_loop;
-  identity_manager_observer()->SetOnRefreshTokensLoadedCallback(
+  identity_manager_observer()->set_on_refresh_tokens_loaded_callback(
       run_loop.QuitClosure());
 
   // Credentials are already loaded in SigninManager::Initialize()
@@ -2391,12 +2191,13 @@
   account_tracker()->SetAccountInfoFromUserInfo(account_info.account_id,
                                                 &user_info);
 
-  EXPECT_EQ(account_info.account_id, identity_manager_observer()
-                                         ->AccountFromAccountUpdatedCallback()
+  EXPECT_EQ(account_info.account_id,
+            identity_manager_observer()
+                ->account_from_account_updated_callback()
                                          .account_id);
-  EXPECT_EQ(
-      account_info.email,
-      identity_manager_observer()->AccountFromAccountUpdatedCallback().email);
+  EXPECT_EQ(account_info.email, identity_manager_observer()
+                                    ->account_from_account_updated_callback()
+                                    .email);
 }
 
 TEST_F(IdentityManagerTest, TestOnAccountRemovedWithInfoCallback) {
@@ -2408,17 +2209,17 @@
 
   // Check if OnAccountRemovedWithInfo is called after removing |account_info|
   // by RemoveAccount().
-  EXPECT_TRUE(
-      identity_manager_observer()->WasCalledAccountRemovedWithInfoCallback());
+  EXPECT_TRUE(identity_manager_observer()
+                  ->was_called_account_removed_with_info_callback());
 
   // Check if the passed AccountInfo is the same to the removing one.
   EXPECT_EQ(account_info.account_id,
             identity_manager_observer()
-                ->AccountFromAccountRemovedWithInfoCallback()
+                ->account_from_account_removed_with_info_callback()
                 .account_id);
   EXPECT_EQ(account_info.email,
             identity_manager_observer()
-                ->AccountFromAccountRemovedWithInfoCallback()
+                ->account_from_account_removed_with_info_callback()
                 .email);
 }
 
@@ -2436,90 +2237,4 @@
   }
 }
 
-// Check that FindExtendedAccountInfoForAccount returns a valid account info
-// iff the account is known, has refresh token and all the extended information
-// is available.
-TEST_F(IdentityManagerTest, FindExtendedAccountInfoForAccount) {
-  CoreAccountInfo account_info;
-  account_info.email = kTestEmail;
-  account_info.gaia = kTestGaiaId;
-  account_info.account_id = identity_manager()->LegacyPickAccountIdForAccount(
-      kTestGaiaId, kTestEmail);
-
-  // FindExtendedAccountInfoForAccount() returns empty optional if the
-  // account_info is invalid.
-  EXPECT_FALSE(identity_manager()
-                   ->FindExtendedAccountInfoForAccount(CoreAccountInfo{})
-                   .has_value());
-
-  // FindExtendedAccountInfoForAccount() returns empty optional if the
-  // account_info is unknown.
-  EXPECT_FALSE(identity_manager()
-                   ->FindExtendedAccountInfoForAccount(account_info)
-                   .has_value());
-
-  // Insert the core account information in the AccountTrackerService.
-  const std::string account_id =
-      account_tracker()->SeedAccountInfo(kTestGaiaId, kTestEmail);
-  ASSERT_EQ(account_info.account_id, account_id);
-
-  // FindExtendedAccountInfoForAccount() returns empty optional if the account
-  // has no refresh token.
-  EXPECT_FALSE(identity_manager()
-                   ->FindExtendedAccountInfoForAccount(account_info)
-                   .has_value());
-
-  // Insert refresh token for account.
-  SetRefreshTokenForAccount(identity_manager(), account_info.account_id,
-                            "refresh-token");
-
-  // FindExtendedAccountInfoForAccount() returns extended account information if
-  // the account is known and has valid refresh token.
-  const base::Optional<AccountInfo> extended_account_info =
-      identity_manager()->FindExtendedAccountInfoForAccount(account_info);
-
-  ASSERT_TRUE(extended_account_info.has_value());
-  EXPECT_EQ(account_info.gaia, extended_account_info.value().gaia);
-  EXPECT_EQ(account_info.email, extended_account_info.value().email);
-  EXPECT_EQ(account_info.account_id, extended_account_info.value().account_id);
-}
-
-#if defined(OS_ANDROID)
-TEST_F(IdentityManagerTest, ForceRefreshOfExtendedAccountInfo) {
-  // The flow of this test results in an interaction with
-  // ChildAccountInfoFetcherAndroid, which requires initialization in order to
-  // avoid a crash.
-  ChildAccountInfoFetcherAndroid::InitializeForTests();
-
-  account_fetcher()->OnNetworkInitialized();
-  AccountInfo account_info =
-      MakeAccountAvailable(identity_manager(), kTestEmail2);
-
-  identity_manager()->ForceRefreshOfExtendedAccountInfo(
-      account_info.account_id);
-
-  base::DictionaryValue user_info;
-  user_info.SetString("id", account_info.account_id);
-  user_info.SetString("email", account_info.email);
-  user_info.SetString("hd", kTestHostedDomain);
-  user_info.SetString("name", kTestFullName);
-  user_info.SetString("given_name", kTestGivenName);
-  user_info.SetString("locale", kTestLocale);
-  user_info.SetString("picture", kTestPictureUrl);
-  account_tracker()->SetAccountInfoFromUserInfo(account_info.account_id,
-                                                &user_info);
-
-  const AccountInfo& refreshed_account_info =
-      identity_manager_observer()->AccountFromAccountUpdatedCallback();
-  EXPECT_EQ(account_info.account_id, refreshed_account_info.account_id);
-  EXPECT_EQ(account_info.email, refreshed_account_info.email);
-  EXPECT_EQ(account_info.gaia, refreshed_account_info.gaia);
-  EXPECT_EQ(kTestHostedDomain, refreshed_account_info.hosted_domain);
-  EXPECT_EQ(kTestFullName, refreshed_account_info.full_name);
-  EXPECT_EQ(kTestGivenName, refreshed_account_info.given_name);
-  EXPECT_EQ(kTestLocale, refreshed_account_info.locale);
-  EXPECT_EQ(kTestPictureUrl, refreshed_account_info.picture_url);
-}
-#endif
-
 }  // namespace identity
--- a/services/identity/public/cpp/identity_test_environment.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/identity/public/cpp/identity_test_environment.cc	2019-05-17 18:53:37.864000000 +0300
@@ -4,26 +4,16 @@
 
 #include "services/identity/public/cpp/identity_test_environment.h"
 
-#include "base/bind.h"
 #include "build/build_config.h"
 
 #include "base/run_loop.h"
 #include "base/threading/thread_task_runner_handle.h"
-#include "components/signin/core/browser/account_tracker_service.h"
-#include "components/signin/core/browser/fake_profile_oauth2_token_service.h"
-#include "components/signin/core/browser/gaia_cookie_manager_service.h"
-#include "components/signin/core/browser/signin_manager.h"
-#include "components/signin/core/browser/test_image_decoder.h"
 #include "components/signin/core/browser/test_signin_client.h"
 #include "components/sync_preferences/testing_pref_service_syncable.h"
 #include "google_apis/gaia/oauth2_access_token_consumer.h"
-#include "services/identity/public/cpp/accounts_cookie_mutator.h"
-#include "services/identity/public/cpp/accounts_cookie_mutator_impl.h"
 #include "services/identity/public/cpp/accounts_mutator.h"
-#include "services/identity/public/cpp/diagnostics_provider_impl.h"
 #include "services/identity/public/cpp/identity_test_utils.h"
 #include "services/identity/public/cpp/primary_account_mutator.h"
-#include "services/identity/public/cpp/test_identity_manager_observer.h"
 
 #if !defined(OS_CHROMEOS)
 #include "services/identity/public/cpp/primary_account_mutator_impl.h"
@@ -33,10 +23,6 @@
 #include "services/identity/public/cpp/accounts_mutator_impl.h"
 #endif
 
-#if defined(OS_ANDROID)
-#include "components/signin/core/browser/child_account_info_fetcher_android.h"
-#endif
-
 namespace identity {
 
 class IdentityManagerDependenciesOwner {
@@ -44,24 +30,19 @@
   IdentityManagerDependenciesOwner(
       network::TestURLLoaderFactory* test_url_loader_factory,
       sync_preferences::TestingPrefServiceSyncable* pref_service,
-      signin::AccountConsistencyMethod account_consistency,
-      TestSigninClient* test_signin_client);
+      signin::AccountConsistencyMethod account_consistency);
   ~IdentityManagerDependenciesOwner();
 
   AccountTrackerService* account_tracker_service();
 
-  AccountFetcherService* account_fetcher_service();
-
-  SigninManagerBase* signin_manager();
+  SigninManagerForTest* signin_manager();
 
   FakeProfileOAuth2TokenService* token_service();
 
-  GaiaCookieManagerService* gaia_cookie_manager_service();
+  FakeGaiaCookieManagerService* gaia_cookie_manager_service();
 
   sync_preferences::TestingPrefServiceSyncable* pref_service();
 
-  TestSigninClient* signin_client();
-
  private:
   // Depending on whether a |pref_service| instance is passed in
   // the constructor, exactly one of these will be non-null.
@@ -69,18 +50,11 @@
       owned_pref_service_;
   sync_preferences::TestingPrefServiceSyncable* raw_pref_service_ = nullptr;
 
-  std::unique_ptr<TestSigninClient> owned_signin_client_;
-  TestSigninClient* raw_signin_client_ = nullptr;
-
   AccountTrackerService account_tracker_;
-  AccountFetcherService account_fetcher_;
+  TestSigninClient signin_client_;
   FakeProfileOAuth2TokenService token_service_;
-#if defined(OS_CHROMEOS)
-  SigninManagerBase signin_manager_;
-#else
-  SigninManager signin_manager_;
-#endif
-  std::unique_ptr<GaiaCookieManagerService> gaia_cookie_manager_service_;
+  SigninManagerForTest signin_manager_;
+  std::unique_ptr<FakeGaiaCookieManagerService> gaia_cookie_manager_service_;
 
   DISALLOW_COPY_AND_ASSIGN(IdentityManagerDependenciesOwner);
 };
@@ -88,72 +62,50 @@
 IdentityManagerDependenciesOwner::IdentityManagerDependenciesOwner(
     network::TestURLLoaderFactory* test_url_loader_factory,
     sync_preferences::TestingPrefServiceSyncable* pref_service_param,
-    signin::AccountConsistencyMethod account_consistency,
-    TestSigninClient* signin_client_param)
+    signin::AccountConsistencyMethod account_consistency)
     : owned_pref_service_(
           pref_service_param
               ? nullptr
               : std::make_unique<
                     sync_preferences::TestingPrefServiceSyncable>()),
       raw_pref_service_(pref_service_param),
-      owned_signin_client_(
-          signin_client_param
-              ? nullptr
-              : std::make_unique<TestSigninClient>(pref_service())),
-      raw_signin_client_(signin_client_param),
+      signin_client_(pref_service()),
       token_service_(pref_service()),
 #if defined(OS_CHROMEOS)
-      signin_manager_(signin_client(), &token_service_, &account_tracker_) {
+      signin_manager_(&signin_client_, &token_service_, &account_tracker_) {
 #else
-      signin_manager_(signin_client(),
+      signin_manager_(&signin_client_,
                       &token_service_,
                       &account_tracker_,
                       nullptr,
                       account_consistency) {
 #endif
   if (test_url_loader_factory != nullptr) {
-    gaia_cookie_manager_service_ = std::make_unique<GaiaCookieManagerService>(
-        &token_service_, signin_client(),
-        base::BindRepeating(
-            [](network::TestURLLoaderFactory* test_url_loader_factory)
-                -> scoped_refptr<network::SharedURLLoaderFactory> {
-              return test_url_loader_factory->GetSafeWeakWrapper();
-            },
-            test_url_loader_factory));
+    gaia_cookie_manager_service_ =
+        std::make_unique<FakeGaiaCookieManagerService>(
+            &token_service_, &signin_client_, test_url_loader_factory);
   } else {
-    gaia_cookie_manager_service_ = std::make_unique<GaiaCookieManagerService>(
-        &token_service_, signin_client());
+    gaia_cookie_manager_service_ =
+        std::make_unique<FakeGaiaCookieManagerService>(&token_service_,
+                                                       &signin_client_);
   }
   AccountTrackerService::RegisterPrefs(pref_service()->registry());
-  AccountFetcherService::RegisterPrefs(pref_service()->registry());
   ProfileOAuth2TokenService::RegisterProfilePrefs(pref_service()->registry());
   SigninManagerBase::RegisterProfilePrefs(pref_service()->registry());
   SigninManagerBase::RegisterPrefs(pref_service()->registry());
 
   account_tracker_.Initialize(pref_service(), base::FilePath());
-  account_fetcher_.Initialize(signin_client(), &token_service_,
-                              &account_tracker_,
-                              std::make_unique<TestImageDecoder>());
   signin_manager_.Initialize(pref_service());
 }
 
-IdentityManagerDependenciesOwner::~IdentityManagerDependenciesOwner() {
-  signin_manager_.Shutdown();
-  account_fetcher_.Shutdown();
-  account_tracker_.Shutdown();
-}
+IdentityManagerDependenciesOwner::~IdentityManagerDependenciesOwner() {}
 
 AccountTrackerService*
 IdentityManagerDependenciesOwner::account_tracker_service() {
   return &account_tracker_;
 }
 
-AccountFetcherService*
-IdentityManagerDependenciesOwner::account_fetcher_service() {
-  return &account_fetcher_;
-}
-
-SigninManagerBase* IdentityManagerDependenciesOwner::signin_manager() {
+SigninManagerForTest* IdentityManagerDependenciesOwner::signin_manager() {
   return &signin_manager_;
 }
 
@@ -162,7 +114,7 @@
   return &token_service_;
 }
 
-GaiaCookieManagerService*
+FakeGaiaCookieManagerService*
 IdentityManagerDependenciesOwner::gaia_cookie_manager_service() {
   return gaia_cookie_manager_service_.get();
 }
@@ -175,83 +127,54 @@
   return raw_pref_service_ ? raw_pref_service_ : owned_pref_service_.get();
 }
 
-TestSigninClient* IdentityManagerDependenciesOwner::signin_client() {
-  DCHECK(raw_signin_client_ || owned_signin_client_);
-  DCHECK(!(raw_signin_client_ && owned_signin_client_));
-
-  return raw_signin_client_ ? raw_signin_client_ : owned_signin_client_.get();
-}
-
 IdentityTestEnvironment::IdentityTestEnvironment(
     network::TestURLLoaderFactory* test_url_loader_factory,
     sync_preferences::TestingPrefServiceSyncable* pref_service,
-    signin::AccountConsistencyMethod account_consistency,
-    TestSigninClient* test_signin_client)
+    signin::AccountConsistencyMethod account_consistency)
     : IdentityTestEnvironment(
-          /*pref_service=*/nullptr,
           /*account_tracker_service=*/nullptr,
-          /*account_fetcher_service=*/nullptr,
           /*token_service=*/nullptr,
           /*signin_manager=*/nullptr,
           /*gaia_cookie_manager_service=*/nullptr,
-          /*test_url_loader_factory=*/test_url_loader_factory,
           std::make_unique<IdentityManagerDependenciesOwner>(
               test_url_loader_factory,
               pref_service,
-              account_consistency,
-              test_signin_client),
+              account_consistency),
           /*identity_manager=*/nullptr) {}
 
 IdentityTestEnvironment::IdentityTestEnvironment(
-    PrefService* pref_service,
     AccountTrackerService* account_tracker_service,
-    AccountFetcherService* account_fetcher_service,
     FakeProfileOAuth2TokenService* token_service,
-    SigninManagerBase* signin_manager,
-    GaiaCookieManagerService* gaia_cookie_manager_service,
-    network::TestURLLoaderFactory* test_url_loader_factory)
-    : IdentityTestEnvironment(pref_service,
-                              account_tracker_service,
-                              account_fetcher_service,
+    SigninManagerForTest* signin_manager,
+    FakeGaiaCookieManagerService* gaia_cookie_manager_service)
+    : IdentityTestEnvironment(account_tracker_service,
                               token_service,
                               signin_manager,
                               gaia_cookie_manager_service,
-                              test_url_loader_factory,
                               /*dependency_owner=*/nullptr,
                               /*identity_manager=*/nullptr) {}
 
 IdentityTestEnvironment::IdentityTestEnvironment(
-    PrefService* pref_service,
     AccountTrackerService* account_tracker_service,
-    AccountFetcherService* account_fetcher_service,
     FakeProfileOAuth2TokenService* token_service,
-    SigninManagerBase* signin_manager,
-    GaiaCookieManagerService* gaia_cookie_manager_service,
-    IdentityManager* identity_manager,
-    network::TestURLLoaderFactory* test_url_loader_factory)
-    : IdentityTestEnvironment(pref_service,
-                              account_tracker_service,
-                              account_fetcher_service,
+    SigninManagerForTest* signin_manager,
+    FakeGaiaCookieManagerService* gaia_cookie_manager_service,
+    IdentityManager* identity_manager)
+    : IdentityTestEnvironment(account_tracker_service,
                               token_service,
                               signin_manager,
                               gaia_cookie_manager_service,
-                              test_url_loader_factory,
                               /*dependency_owner=*/nullptr,
                               identity_manager) {}
 
 IdentityTestEnvironment::IdentityTestEnvironment(
-    PrefService* pref_service,
     AccountTrackerService* account_tracker_service,
-    AccountFetcherService* account_fetcher_service,
     FakeProfileOAuth2TokenService* token_service,
-    SigninManagerBase* signin_manager,
-    GaiaCookieManagerService* gaia_cookie_manager_service,
-    network::TestURLLoaderFactory* test_url_loader_factory,
+    SigninManagerForTest* signin_manager,
+    FakeGaiaCookieManagerService* gaia_cookie_manager_service,
     std::unique_ptr<IdentityManagerDependenciesOwner> dependencies_owner,
     IdentityManager* identity_manager)
-    : pref_service_(pref_service),
-      test_url_loader_factory_(test_url_loader_factory),
-      weak_ptr_factory_(this) {
+    : weak_ptr_factory_(this) {
   DCHECK(base::ThreadTaskRunnerHandle::Get())
       << "IdentityTestEnvironment requires a properly set up task environment. "
          "If your test has an existing one, move it to be initialized before "
@@ -259,40 +182,27 @@
          "base::test::ScopedTaskEnvironment.";
 
   if (dependencies_owner) {
-    DCHECK(!(pref_service_ || account_tracker_service ||
-             account_fetcher_service || token_service || signin_manager ||
+    DCHECK(!(account_tracker_service || token_service || signin_manager ||
              gaia_cookie_manager_service || identity_manager));
 
     dependencies_owner_ = std::move(dependencies_owner);
 
     account_tracker_service_ = dependencies_owner_->account_tracker_service();
-    account_fetcher_service_ = dependencies_owner_->account_fetcher_service();
     token_service_ = dependencies_owner_->token_service();
     signin_manager_ = dependencies_owner_->signin_manager();
     gaia_cookie_manager_service_ =
         dependencies_owner_->gaia_cookie_manager_service();
-    pref_service_ = dependencies_owner_->pref_service();
+
   } else {
-    DCHECK(pref_service_ && account_tracker_service &&
-           account_fetcher_service && token_service && signin_manager &&
+    DCHECK(account_tracker_service && token_service && signin_manager &&
            gaia_cookie_manager_service);
 
     account_tracker_service_ = account_tracker_service;
-    account_fetcher_service_ = account_fetcher_service;
     token_service_ = token_service;
     signin_manager_ = signin_manager;
     gaia_cookie_manager_service_ = gaia_cookie_manager_service;
   }
 
-  // TODO(sdefresne): services should be initialized when this version of
-  // the constructor is used. However, this break a large number of tests
-  // (all those that use an IdentityTestEnvironment and its dependencies
-  // as member fields; they should be changed to before the check can be
-  // enabled).
-  // DCHECK(account_tracker_service_->account_fetcher_service())
-  //     << "IdentityTestEnvironment requires its services to be initialized "
-  //     << "before passing them to the constructor.";
-
   if (identity_manager) {
     raw_identity_manager_ = identity_manager;
   } else {
@@ -305,27 +215,15 @@
 
 #if !defined(OS_ANDROID) && !defined(OS_IOS)
     accounts_mutator = std::make_unique<AccountsMutatorImpl>(
-        token_service_, account_tracker_service_, signin_manager_,
-        pref_service_);
+        token_service_, account_tracker_service_, signin_manager_);
 #endif
-    std::unique_ptr<DiagnosticsProvider> diagnostics_provider =
-        std::make_unique<DiagnosticsProviderImpl>(token_service_,
-                                                  gaia_cookie_manager_service_);
-
-    std::unique_ptr<AccountsCookieMutator> accounts_cookie_mutator =
-        std::make_unique<AccountsCookieMutatorImpl>(
-            gaia_cookie_manager_service_);
 
     owned_identity_manager_ = std::make_unique<IdentityManager>(
-        signin_manager_, token_service_, account_fetcher_service_,
-        account_tracker_service_, gaia_cookie_manager_service_,
-        std::move(primary_account_mutator), std::move(accounts_mutator),
-        std::move(accounts_cookie_mutator), std::move(diagnostics_provider));
+        signin_manager_, token_service_, account_tracker_service_,
+        gaia_cookie_manager_service_, std::move(primary_account_mutator),
+        std::move(accounts_mutator));
   }
 
-  test_identity_manager_observer_ =
-      std::make_unique<TestIdentityManagerObserver>(this->identity_manager());
-
   this->identity_manager()->AddDiagnosticsObserver(this);
 }
 
@@ -341,12 +239,7 @@
                                : owned_identity_manager_.get();
 }
 
-TestIdentityManagerObserver*
-IdentityTestEnvironment::identity_manager_observer() {
-  return test_identity_manager_observer_.get();
-}
-
-CoreAccountInfo IdentityTestEnvironment::SetPrimaryAccount(
+AccountInfo IdentityTestEnvironment::SetPrimaryAccount(
     const std::string& email) {
   return identity::SetPrimaryAccount(identity_manager(), email);
 }
@@ -403,10 +296,7 @@
 
 void IdentityTestEnvironment::SetCookieAccounts(
     const std::vector<CookieParams>& cookie_accounts) {
-  DCHECK(test_url_loader_factory_)
-      << "IdentityTestEnvironment constructor must have been passed a "
-         "test_url_loader_factory in order to use this method.";
-  identity::SetCookieAccounts(identity_manager(), test_url_loader_factory_,
+  identity::SetCookieAccounts(gaia_cookie_manager_service_, identity_manager(),
                               cookie_accounts);
 }
 
@@ -561,47 +451,10 @@
   token_service_->LoadCredentials("");
 }
 
-bool IdentityTestEnvironment::IsAccessTokenRequestPending() {
-  return token_service_->GetPendingRequests().size();
-}
-
 void IdentityTestEnvironment::SetFreshnessOfAccountsInGaiaCookie(
     bool accounts_are_fresh) {
-  identity::SetFreshnessOfAccountsInGaiaCookie(identity_manager(),
+  gaia_cookie_manager_service_->set_list_accounts_stale_for_testing(
                                                accounts_are_fresh);
 }
 
-void IdentityTestEnvironment::EnableRemovalOfExtendedAccountInfo() {
-  account_fetcher_service_->EnableAccountRemovalForTest();
-}
-
-void IdentityTestEnvironment::SimulateSuccessfulFetchOfAccountInfo(
-    const std::string& account_id,
-    const std::string& email,
-    const std::string& gaia,
-    const std::string& hosted_domain,
-    const std::string& full_name,
-    const std::string& given_name,
-    const std::string& locale,
-    const std::string& picture_url) {
-  base::DictionaryValue user_info;
-  user_info.SetString("id", gaia);
-  user_info.SetString("email", email);
-  user_info.SetString("hd", hosted_domain);
-  user_info.SetString("name", full_name);
-  user_info.SetString("given_name", given_name);
-  user_info.SetString("locale", locale);
-  user_info.SetString("picture", picture_url);
-  account_tracker_service_->SetAccountInfoFromUserInfo(account_id, &user_info);
-}
-
-void IdentityTestEnvironment::SimulateMergeSessionFailure(
-    const GoogleServiceAuthError& auth_error) {
-  // GaiaCookieManagerService changes the visibility of inherited method
-  // OnMergeSessionFailure from public to private. Cast to a base class pointer
-  // to use call the method.
-  static_cast<GaiaAuthConsumer*>(gaia_cookie_manager_service_)
-      ->OnMergeSessionFailure(auth_error);
-}
-
 }  // namespace identity
--- a/services/identity/public/cpp/identity_test_environment.h	2019-05-17 17:45:42.520000000 +0300
+++ b/services/identity/public/cpp/identity_test_environment.h	2019-05-17 18:53:37.864000000 +0300
@@ -7,34 +7,33 @@
 
 #include "base/optional.h"
 #include "components/signin/core/browser/account_consistency_method.h"
+#include "components/signin/core/browser/account_tracker_service.h"
+#include "components/signin/core/browser/fake_gaia_cookie_manager_service.h"
+#include "components/signin/core/browser/fake_profile_oauth2_token_service.h"
+#include "components/signin/core/browser/fake_signin_manager.h"
 #include "services/identity/public/cpp/identity_manager.h"
 #include "services/identity/public/cpp/identity_test_utils.h"
 
-class AccountFetcherService;
-class AccountTrackerService;
-class FakeProfileOAuth2TokenService;
-class GaiaCookieManagerService;
 class IdentityTestEnvironmentChromeBrowserStateAdaptor;
 class IdentityTestEnvironmentProfileAdaptor;
-class PrefService;
-class SigninManager;
-class TestSigninClient;
 
 namespace sync_preferences {
 class TestingPrefServiceSyncable;
 }
 
-namespace network {
-class TestURLLoaderFactory;
-}
-
 namespace identity {
 
-class IdentityManagerDependenciesOwner;
-class TestIdentityManagerObserver;
+namespace {
+#if defined(OS_CHROMEOS)
+using SigninManagerForTest = FakeSigninManagerBase;
+#else
+using SigninManagerForTest = FakeSigninManager;
+#endif  // OS_CHROMEOS
+}  // namespace
 
-// Necessary to declare this test as a temporary friend.
-class IdentityAccessorImplTest;
+// Internal class that creates and owns dependencies of IdentityManager
+// when those dependencies are not passed in externally.
+class IdentityManagerDependenciesOwner;
 
 // Class that creates an IdentityManager for use in testing contexts and
 // provides facilities for driving that IdentityManager. The IdentityManager
@@ -55,8 +54,6 @@
   //
   // This constructor takes an optional parameter |test_url_loader_factory| to
   // use for cookie-related network requests.
-  // Note: the provided |test_url_loader_factory| is expected to outlive
-  // IdentityTestEnvironment.
   //
   // This constructor also takes an optional PrefService instance as parameter,
   // which allows tests to move away from referencing IdentityManager's
@@ -70,34 +67,39 @@
       network::TestURLLoaderFactory* test_url_loader_factory = nullptr,
       sync_preferences::TestingPrefServiceSyncable* pref_service = nullptr,
       signin::AccountConsistencyMethod account_consistency =
-          signin::AccountConsistencyMethod::kDisabled,
-      TestSigninClient* test_signin_client = nullptr);
+          signin::AccountConsistencyMethod::kDisabled);
+
+  // Constructor that takes in instances of the dependencies of
+  // IdentityManager and constructs an IdentityManager instance from those
+  // dependencies. For use in contexts where those dependencies are still
+  // being used directly by the creator of this object (i.e., while a test is
+  // being incrementally converted). Prefer the above constructor, and switch to
+  // that constructor once possible (e.g., when an incremental conversion is
+  // completed). NOTE: The passed-in objects must all outlive this object.
+  IdentityTestEnvironment(
+      AccountTrackerService* account_tracker_service,
+      FakeProfileOAuth2TokenService* token_service,
+      SigninManagerForTest* signin_manager,
+      FakeGaiaCookieManagerService* gaia_cookie_manager_service);
 
   ~IdentityTestEnvironment() override;
 
   // The IdentityManager instance associated with this instance.
   IdentityManager* identity_manager();
 
-  // Returns the |TestIdentityManagerObserver| watching the IdentityManager.
-  TestIdentityManagerObserver* identity_manager_observer();
-
   // Sets the primary account for the given email address, generating a GAIA ID
   // that corresponds uniquely to that email address. On non-ChromeOS, results
   // in the firing of the IdentityManager and SigninManager callbacks for signin
-  // success. Blocks until the primary account is set. Returns the
-  // CoreAccountInfo of the newly-set account.
-  CoreAccountInfo SetPrimaryAccount(const std::string& email);
+  // success. Blocks until the primary account is set. Returns the AccountInfo
+  // of the newly-set account.
+  AccountInfo SetPrimaryAccount(const std::string& email);
 
   // Sets a refresh token for the primary account (which must already be set).
-  // Before updating the refresh token, blocks until refresh tokens are loaded.
-  // After updating the token, blocks until the update is processed by
-  // |identity_manager|.
+  // Blocks until the refresh token is set.
   void SetRefreshTokenForPrimaryAccount();
 
   // Sets a special invalid refresh token for the primary account (which must
-  // already be set). Before updating the refresh token, blocks until refresh
-  // tokens are loaded. After updating the token, blocks until the update is
-  // processed by |identity_manager|.
+  // already be set). Blocks until the refresh token is set.
   void SetInvalidRefreshTokenForPrimaryAccount();
 
   // Removes any refresh token for the primary account, if present. Blocks until
@@ -126,17 +128,13 @@
   AccountInfo MakeAccountAvailable(const std::string& email);
 
   // Sets a refresh token for the given account (which must already be
-  // available). Before updating the refresh token, blocks until refresh tokens
-  // are loaded. After updating the token, blocks until the update is processed
-  // by |identity_manager|. NOTE: See disclaimer at top of file re: direct
-  // usage.
+  // available). Blocks until the refresh token is set. NOTE: See disclaimer at
+  // top of file re: direct usage.
   void SetRefreshTokenForAccount(const std::string& account_id);
 
   // Sets a special invalid refresh token for the given account (which must
-  // already be available). Before updating the refresh token, blocks until
-  // refresh tokens are loaded. After updating the token, blocks until the
-  // update is processed by |identity_manager|. NOTE: See disclaimer at top of
-  // file re: direct usage.
+  // already be available). Blocks until the refresh token is set. NOTE: See
+  // disclaimer at top of file re: direct usage.
   void SetInvalidRefreshTokenForAccount(const std::string& account_id);
 
   // Removes any refresh token that is present for the given account. Blocks
@@ -244,41 +242,14 @@
   // Simulates the reloading of the accounts from disk.
   void ReloadAccountsFromDisk();
 
-  // Returns whether there is a access token request pending.
-  bool IsAccessTokenRequestPending();
-
   // Sets whether the list of accounts in Gaia cookie jar is fresh and does not
   // need to be updated.
   void SetFreshnessOfAccountsInGaiaCookie(bool accounts_are_fresh);
 
-  // By default, extended account info removal is disabled in testing
-  // contexts. This call enables it for tests that require
-  // IdentityManager::Observer::OnExtendedAccountInfoRemoved() to fire as
-  // expected. TODO(https://crbug.com/927687): Enable this unconditionally.
-  void EnableRemovalOfExtendedAccountInfo();
-
-  // Simulate account fetching using AccountTrackerService without sending
-  // network requests.
-  void SimulateSuccessfulFetchOfAccountInfo(const std::string& account_id,
-                                            const std::string& email,
-                                            const std::string& gaia,
-                                            const std::string& hosted_domain,
-                                            const std::string& full_name,
-                                            const std::string& given_name,
-                                            const std::string& locale,
-                                            const std::string& picture_url);
-
-  // Simulates a merge session failure with |auth_error| as the error.
-  void SimulateMergeSessionFailure(const GoogleServiceAuthError& auth_error);
-
  private:
   friend class ::IdentityTestEnvironmentChromeBrowserStateAdaptor;
   friend class ::IdentityTestEnvironmentProfileAdaptor;
 
-  // TODO(https://crbug.com/933109): Remove friendship after conversion to
-  // IdentityManager is complete.
-  friend class identity::IdentityAccessorImplTest;
-
   struct AccessTokenRequestState {
     AccessTokenRequestState();
     ~AccessTokenRequestState();
@@ -293,22 +264,6 @@
     base::OnceClosure on_available;
   };
 
-  // Constructor that takes in instances of the dependencies of
-  // IdentityManager and constructs an IdentityManager instance from those
-  // dependencies. For use in contexts where those dependencies are still
-  // being used directly by the creator of this object (i.e., while a test is
-  // being incrementally converted). Prefer the above constructor, and switch to
-  // that constructor once possible (e.g., when an incremental conversion is
-  // completed). NOTE: The passed-in objects must all outlive this object.
-  IdentityTestEnvironment(
-      PrefService* pref_service,
-      AccountTrackerService* account_tracker_service,
-      AccountFetcherService* account_fetcher_service,
-      FakeProfileOAuth2TokenService* token_service,
-      SigninManagerBase* signin_manager,
-      GaiaCookieManagerService* gaia_cookie_manager_service,
-      network::TestURLLoaderFactory* test_url_loader_factory = nullptr);
-
   // Constructor that takes in an IdentityManager instance as well as instances
   // of the dependencies of that IdentityManager. For use only in contexts where
   // IdentityManager and its dependencies are all unavoidably created by the
@@ -323,16 +278,13 @@
   // NOTE: This constructor is for usage only in the special case of embedder
   // unittests that must use the IdentityManager instance associated with the
   // Profile/ChromeBrowserState. If you think you have another use case for it,
-  // contact blundell@ch40m1um.qjz9zk.
+  // contact blundell@chromium.org.
   IdentityTestEnvironment(
-      PrefService* pref_service,
       AccountTrackerService* account_tracker_service,
-      AccountFetcherService* account_fetcher_service,
       FakeProfileOAuth2TokenService* token_service,
-      SigninManagerBase* signin_manager,
-      GaiaCookieManagerService* gaia_cookie_manager_service,
-      IdentityManager* identity_manager,
-      network::TestURLLoaderFactory* test_url_loader_factory = nullptr);
+      SigninManagerForTest* signin_manager,
+      FakeGaiaCookieManagerService* gaia_cookie_manager_service,
+      IdentityManager* identity_manager);
 
   // Constructs this object from the supplied
   // dependencies of IdentityManager and potentially IdentityManager itself.
@@ -346,13 +298,10 @@
   // this object will create and own an IdentityManager instance from the
   // supplied dependencies.
   IdentityTestEnvironment(
-      PrefService* pref_service,
       AccountTrackerService* account_tracker_service,
-      AccountFetcherService* account_fetcher_service,
       FakeProfileOAuth2TokenService* token_service,
-      SigninManagerBase* signin_manager,
-      GaiaCookieManagerService* gaia_cookie_manager_service,
-      network::TestURLLoaderFactory* test_url_loader_factory,
+      SigninManagerForTest* signin_manager,
+      FakeGaiaCookieManagerService* gaia_cookie_manager_service,
       std::unique_ptr<IdentityManagerDependenciesOwner> dependencies_owner,
       IdentityManager* identity_manager);
 
@@ -378,16 +327,10 @@
   // pointed to below in the case where those objects are not passed in via
   // the IdentityTestEnvironment constructor.
   std::unique_ptr<IdentityManagerDependenciesOwner> dependencies_owner_;
-  PrefService* pref_service_ = nullptr;
   AccountTrackerService* account_tracker_service_ = nullptr;
-  AccountFetcherService* account_fetcher_service_ = nullptr;
   FakeProfileOAuth2TokenService* token_service_ = nullptr;
-  SigninManagerBase* signin_manager_ = nullptr;
-  GaiaCookieManagerService* gaia_cookie_manager_service_ = nullptr;
-
-  // Used to set fake responses for cookie-related requests.
-  // This can be null if no TestURLLoaderFactory was passed via the constructor.
-  network::TestURLLoaderFactory* test_url_loader_factory_ = nullptr;
+  SigninManagerForTest* signin_manager_ = nullptr;
+  FakeGaiaCookieManagerService* gaia_cookie_manager_service_ = nullptr;
 
   // Depending on which constructor is used, exactly one of these will be
   // non-null. See the documentation on the constructor wherein IdentityManager
@@ -395,8 +338,6 @@
   std::unique_ptr<IdentityManager> owned_identity_manager_;
   IdentityManager* raw_identity_manager_ = nullptr;
 
-  std::unique_ptr<TestIdentityManagerObserver> test_identity_manager_observer_;
-
   base::OnceClosure on_access_token_requested_callback_;
   std::vector<AccessTokenRequestState> requesters_;
 
--- a/services/identity/public/cpp/identity_test_environment_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/identity/public/cpp/identity_test_environment_unittest.cc	2019-05-17 18:53:37.864000000 +0300
@@ -3,7 +3,6 @@
 // found in the LICENSE file.
 
 #include "services/identity/public/cpp/identity_test_environment.h"
-#include "base/bind.h"
 #include "base/test/scoped_task_environment.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
--- a/services/identity/public/cpp/identity_test_utils.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/identity/public/cpp/identity_test_utils.cc	2019-05-17 18:53:37.864000000 +0300
@@ -10,40 +10,111 @@
 #include "base/run_loop.h"
 #include "base/strings/string_split.h"
 #include "components/signin/core/browser/account_tracker_service.h"
-#include "components/signin/core/browser/list_accounts_test_utils.h"
+#include "components/signin/core/browser/fake_gaia_cookie_manager_service.h"
 #include "components/signin/core/browser/profile_oauth2_token_service.h"
 #include "google_apis/gaia/gaia_auth_util.h"
 #include "services/identity/public/cpp/identity_manager.h"
-#include "services/identity/public/cpp/test_identity_manager_observer.h"
-
-#if defined(OS_ANDROID)
-#include "components/signin/core/browser/oauth2_token_service_delegate_android.h"
-#endif
 
 namespace identity {
 
 namespace {
 
-void WaitForLoadCredentialsToComplete(IdentityManager* identity_manager) {
-  base::RunLoop run_loop;
-  TestIdentityManagerObserver load_credentials_observer(identity_manager);
-  load_credentials_observer.SetOnRefreshTokensLoadedCallback(
-      run_loop.QuitClosure());
+enum class IdentityManagerEvent {
+  PRIMARY_ACCOUNT_SET,
+  PRIMARY_ACCOUNT_CLEARED,
+  REFRESH_TOKEN_UPDATED,
+  REFRESH_TOKEN_REMOVED,
+  ACCOUNTS_IN_COOKIE_UPDATED,
+};
+
+class OneShotIdentityManagerObserver : public IdentityManager::Observer {
+ public:
+  OneShotIdentityManagerObserver(IdentityManager* identity_manager,
+                                 base::OnceClosure done_closure,
+                                 IdentityManagerEvent event_to_wait_on);
+  ~OneShotIdentityManagerObserver() override;
+
+ private:
+  // IdentityManager::Observer:
+  void OnPrimaryAccountSet(const AccountInfo& primary_account_info) override;
+  void OnPrimaryAccountCleared(
+      const AccountInfo& previous_primary_account_info) override;
+  void OnRefreshTokenUpdatedForAccount(
+      const AccountInfo& account_info) override;
+  void OnRefreshTokenRemovedForAccount(const std::string& account_id) override;
+  void OnAccountsInCookieUpdated(
+      const AccountsInCookieJarInfo& accounts_in_cookie_jar_info,
+      const GoogleServiceAuthError& error) override;
+
+  IdentityManager* identity_manager_;
+  base::OnceClosure done_closure_;
+  IdentityManagerEvent event_to_wait_on_;
+
+  DISALLOW_COPY_AND_ASSIGN(OneShotIdentityManagerObserver);
+};
+
+OneShotIdentityManagerObserver::OneShotIdentityManagerObserver(
+    IdentityManager* identity_manager,
+    base::OnceClosure done_closure,
+    IdentityManagerEvent event_to_wait_on)
+    : identity_manager_(identity_manager),
+      done_closure_(std::move(done_closure)),
+      event_to_wait_on_(event_to_wait_on) {
+  identity_manager_->AddObserver(this);
+}
 
-  if (identity_manager->AreRefreshTokensLoaded())
+OneShotIdentityManagerObserver::~OneShotIdentityManagerObserver() {
+  identity_manager_->RemoveObserver(this);
+}
+
+void OneShotIdentityManagerObserver::OnPrimaryAccountSet(
+    const AccountInfo& primary_account_info) {
+  if (event_to_wait_on_ != IdentityManagerEvent::PRIMARY_ACCOUNT_SET)
     return;
 
-  // Do NOT explicitly load credentials here:
-  // 1. It is not re-entrant and will DCHECK fail.
-  // 2. It should have been called by IdentityManager during its initialization.
+  DCHECK(done_closure_);
+  std::move(done_closure_).Run();
+}
+
+void OneShotIdentityManagerObserver::OnPrimaryAccountCleared(
+    const AccountInfo& previous_primary_account_info) {
+  if (event_to_wait_on_ != IdentityManagerEvent::PRIMARY_ACCOUNT_CLEARED)
+    return;
 
-  run_loop.Run();
+  DCHECK(done_closure_);
+  std::move(done_closure_).Run();
+}
+
+void OneShotIdentityManagerObserver::OnRefreshTokenUpdatedForAccount(
+    const AccountInfo& account_info) {
+  if (event_to_wait_on_ != IdentityManagerEvent::REFRESH_TOKEN_UPDATED)
+    return;
+
+  DCHECK(done_closure_);
+  std::move(done_closure_).Run();
+}
+
+void OneShotIdentityManagerObserver::OnRefreshTokenRemovedForAccount(
+    const std::string& account_id) {
+  if (event_to_wait_on_ != IdentityManagerEvent::REFRESH_TOKEN_REMOVED)
+    return;
+
+  DCHECK(done_closure_);
+  std::move(done_closure_).Run();
+}
+
+void OneShotIdentityManagerObserver::OnAccountsInCookieUpdated(
+    const AccountsInCookieJarInfo& accounts_in_cookie_jar_info,
+    const GoogleServiceAuthError& error) {
+  if (event_to_wait_on_ != IdentityManagerEvent::ACCOUNTS_IN_COOKIE_UPDATED)
+    return;
+
+  DCHECK(done_closure_);
+  std::move(done_closure_).Run();
 }
 
 // Helper function that updates the refresh token for |account_id| to
-// |new_token|. Before updating the refresh token, blocks until refresh tokens
-// are loaded. After updating the token, blocks until the update is processed by
-// |identity_manager|.
+// |new_token|. Blocks until the update is processed by |identity_manager|.
 void UpdateRefreshTokenForAccount(
     ProfileOAuth2TokenService* token_service,
     AccountTrackerService* account_tracker_service,
@@ -54,17 +125,10 @@
             account_id)
       << "To set the refresh token for an unknown account, use "
          "MakeAccountAvailable()";
-
-  // Ensure that refresh tokens are loaded; some platforms enforce the invariant
-  // that refresh token mutation cannot occur until refresh tokens are loaded,
-  // and it is desired to eventually enforce that invariant across all
-  // platforms.
-  WaitForLoadCredentialsToComplete(identity_manager);
-
   base::RunLoop run_loop;
-  TestIdentityManagerObserver token_updated_observer(identity_manager);
-  token_updated_observer.SetOnRefreshTokenUpdatedCallback(
-      run_loop.QuitClosure());
+  OneShotIdentityManagerObserver token_updated_observer(
+      identity_manager, run_loop.QuitClosure(),
+      IdentityManagerEvent::REFRESH_TOKEN_UPDATED);
 
   token_service->UpdateCredentials(account_id, new_token);
 
@@ -70,27 +134,16 @@
 
   run_loop.Run();
 }
-
 }  // namespace
 
-CoreAccountInfo SetPrimaryAccount(IdentityManager* identity_manager,
+AccountInfo SetPrimaryAccount(IdentityManager* identity_manager,
                                   const std::string& email) {
   DCHECK(!identity_manager->HasPrimaryAccount());
+
   SigninManagerBase* signin_manager = identity_manager->GetSigninManager();
   DCHECK(!signin_manager->IsAuthenticated());
 
-  AccountTrackerService* account_tracker_service =
-      identity_manager->GetAccountTrackerService();
-  AccountInfo account_info =
-      account_tracker_service->FindAccountInfoByEmail(email);
-  if (account_info.account_id.empty()) {
     std::string gaia_id = GetTestGaiaIdForEmail(email);
-    account_tracker_service->SeedAccountInfo(gaia_id, email);
-    account_info = account_tracker_service->FindAccountInfoByEmail(email);
-  }
-
-  std::string gaia_id = account_info.gaia;
-  DCHECK(!gaia_id.empty());
 
 #if defined(OS_CHROMEOS)
   // ChromeOS has no real notion of signin, so just plumb the information
@@ -99,9 +152,26 @@
   identity_manager->SetPrimaryAccountSynchronously(gaia_id, email,
                                                    /*refresh_token=*/"");
 #else
+
+  base::RunLoop run_loop;
+  OneShotIdentityManagerObserver signin_observer(
+      identity_manager, run_loop.QuitClosure(),
+      IdentityManagerEvent::PRIMARY_ACCOUNT_SET);
+
   SigninManager* real_signin_manager =
       SigninManager::FromSigninManagerBase(signin_manager);
-  real_signin_manager->OnExternalSigninCompleted(email);
+  // Note: It's important to pass base::DoNothing() (rather than a null
+  // callback) to make this work with both SigninManager and FakeSigninManager.
+  // If we would pass a null callback, then SigninManager would call
+  // CompletePendingSignin directly, but FakeSigninManager never does that.
+  // Note: pass an empty string as the refresh token so that no refresh token is
+  // set.
+  real_signin_manager->StartSignInWithRefreshToken(
+      /*refresh_token=*/"", gaia_id, email, /*password=*/"",
+      /*oauth_fetched_callback=*/base::DoNothing());
+  real_signin_manager->CompletePendingSignin();
+
+  run_loop.Run();
 #endif
 
   DCHECK(signin_manager->IsAuthenticated());
@@ -135,15 +205,9 @@
 
 AccountInfo MakePrimaryAccountAvailable(IdentityManager* identity_manager,
                                         const std::string& email) {
-  CoreAccountInfo account_info = SetPrimaryAccount(identity_manager, email);
+  AccountInfo account_info = SetPrimaryAccount(identity_manager, email);
   SetRefreshTokenForPrimaryAccount(identity_manager);
-  base::Optional<AccountInfo> primary_account_info =
-      identity_manager->FindAccountInfoForAccountWithRefreshTokenByAccountId(
-          account_info.account_id);
-  // Ensure that extended information for the account is available after setting
-  // the refresh token.
-  DCHECK(primary_account_info.has_value());
-  return primary_account_info.value();
+  return account_info;
 }
 
 void ClearPrimaryAccount(IdentityManager* identity_manager,
@@ -158,8 +222,9 @@
     return;
 
   base::RunLoop run_loop;
-  TestIdentityManagerObserver signout_observer(identity_manager);
-  signout_observer.SetOnPrimaryAccountClearedCallback(run_loop.QuitClosure());
+  OneShotIdentityManagerObserver signout_observer(
+      identity_manager, run_loop.QuitClosure(),
+      IdentityManagerEvent::PRIMARY_ACCOUNT_CLEARED);
 
   SigninManager* real_signin_manager = SigninManager::FromSigninManagerBase(
       identity_manager->GetSigninManager());
@@ -195,10 +260,6 @@
   DCHECK(account_tracker_service);
   DCHECK(account_tracker_service->FindAccountInfoByEmail(email).IsEmpty());
 
-  // Wait until tokens are loaded, otherwise the account will be removed as soon
-  // as tokens finish loading.
-  WaitForLoadCredentialsToComplete(identity_manager);
-
   std::string gaia_id = GetTestGaiaIdForEmail(email);
   account_tracker_service->SeedAccountInfo(gaia_id, email);
 
@@ -236,19 +297,19 @@
     return;
 
   base::RunLoop run_loop;
-  TestIdentityManagerObserver token_updated_observer(identity_manager);
-  token_updated_observer.SetOnRefreshTokenRemovedCallback(
-      run_loop.QuitClosure());
+  OneShotIdentityManagerObserver token_updated_observer(
+      identity_manager, run_loop.QuitClosure(),
+      IdentityManagerEvent::REFRESH_TOKEN_REMOVED);
 
   identity_manager->GetTokenService()->RevokeCredentials(account_id);
 
   run_loop.Run();
 }
 
-void SetCookieAccounts(IdentityManager* identity_manager,
-                       network::TestURLLoaderFactory* test_url_loader_factory,
+void SetCookieAccounts(FakeGaiaCookieManagerService* cookie_manager,
+                       IdentityManager* identity_manager,
                        const std::vector<CookieParams>& cookie_accounts) {
-  // Convert |cookie_accounts| to the format list_accounts_test_utils wants.
+  // Convert |cookie_accounts| to the format FakeGaiaCookieManagerService wants.
   std::vector<signin::CookieParams> gaia_cookie_accounts;
   for (const CookieParams& params : cookie_accounts) {
     gaia_cookie_accounts.push_back({params.email, params.gaia_id,
@@ -257,14 +318,12 @@
   }
 
   base::RunLoop run_loop;
-  TestIdentityManagerObserver cookie_observer(identity_manager);
-  cookie_observer.SetOnAccountsInCookieUpdatedCallback(run_loop.QuitClosure());
+  OneShotIdentityManagerObserver cookie_observer(
+      identity_manager, run_loop.QuitClosure(),
+      IdentityManagerEvent::ACCOUNTS_IN_COOKIE_UPDATED);
 
-  signin::SetListAccountsResponseWithParams(gaia_cookie_accounts,
-                                            test_url_loader_factory);
+  cookie_manager->SetListAccountsResponseWithParams(gaia_cookie_accounts);
 
-  GaiaCookieManagerService* cookie_manager =
-      identity_manager->GetGaiaCookieManagerService();
   cookie_manager->set_list_accounts_stale_for_testing(true);
   cookie_manager->ListAccounts(nullptr, nullptr);
 
@@ -285,13 +344,6 @@
   account_tracker_service->SeedAccountInfo(account_info);
 }
 
-void SetFreshnessOfAccountsInGaiaCookie(IdentityManager* identity_manager,
-                                        bool accounts_are_fresh) {
-  GaiaCookieManagerService* cookie_manager =
-      identity_manager->GetGaiaCookieManagerService();
-  cookie_manager->set_list_accounts_stale_for_testing(!accounts_are_fresh);
-}
-
 std::string GetTestGaiaIdForEmail(const std::string& email) {
   std::string gaia_id =
       std::string("gaia_id_for_") + gaia::CanonicalizeEmail(email);
@@ -315,15 +367,4 @@
       ->set_max_authorization_token_fetch_retries_for_testing(0);
 }
 
-#if defined(OS_ANDROID)
-void DisableInteractionWithSystemAccounts() {
-  OAuth2TokenServiceDelegateAndroid::
-      set_disable_interaction_with_system_accounts();
-}
-#endif
-
-void CancelAllOngoingGaiaCookieOperations(IdentityManager* identity_manager) {
-  identity_manager->GetGaiaCookieManagerService()->CancelAll();
-}
-
 }  // namespace identity
--- a/services/identity/public/cpp/identity_test_utils.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/identity/public/cpp/identity_test_utils.h	2019-05-17 18:53:37.864000000 +0300
@@ -10,10 +10,7 @@
 #include "build/build_config.h"
 #include "components/signin/core/browser/account_info.h"
 
-namespace network {
-class TestURLLoaderFactory;
-}
-
+class FakeGaiaCookieManagerService;
 class GoogleServiceAuthError;
 
 // Test-related utilities that don't fit in either IdentityTestEnvironment or
@@ -48,9 +45,9 @@
 // address, generating a GAIA ID that corresponds uniquely to that email
 // address. On non-ChromeOS, results in the firing of the IdentityManager and
 // SigninManager callbacks for signin success. Blocks until the primary account
-// is set. Returns the CoreAccountInfo of the newly-set account.
+// is set. Returns the AccountInfo of the newly-set account.
 // NOTE: See disclaimer at top of file re: direct usage.
-CoreAccountInfo SetPrimaryAccount(IdentityManager* identity_manager,
+AccountInfo SetPrimaryAccount(IdentityManager* identity_manager,
                                   const std::string& email);
 
 // Sets a refresh token for the primary account (which must already be set).
@@ -64,12 +61,14 @@
 // Sets a special invalid refresh token for the primary account (which must
 // already be set). Blocks until the refresh token is set.
 // NOTE: See disclaimer at top of file re: direct usage.
-void SetInvalidRefreshTokenForPrimaryAccount(IdentityManager* identity_manager);
+void SetInvalidRefreshTokenForPrimaryAccount(
+    IdentityManager* identity_manager);
 
 // Removes any refresh token for the primary account, if present. Blocks until
 // the refresh token is removed.
 // NOTE: See disclaimer at top of file re: direct usage.
-void RemoveRefreshTokenForPrimaryAccount(IdentityManager* identity_manager);
+void RemoveRefreshTokenForPrimaryAccount(
+    IdentityManager* identity_manager);
 
 // Makes the primary account (which must not already be set) available for the
 // given email address, generating a GAIA ID and refresh token that correspond
@@ -78,7 +77,8 @@
 // the primary account is available. Returns the AccountInfo of the
 // newly-available account.
 // NOTE: See disclaimer at top of file re: direct usage.
-AccountInfo MakePrimaryAccountAvailable(IdentityManager* identity_manager,
+AccountInfo MakePrimaryAccountAvailable(
+    IdentityManager* identity_manager,
                                         const std::string& email);
 
 // Clears the primary account if present, with |policy| used to determine
@@ -121,12 +121,9 @@
 
 // Puts the given accounts into the Gaia cookie, replacing any previous
 // accounts. Blocks until the accounts have been set.
-// |test_url_loader_factory| is used to set a fake ListAccounts response
-// containing the provided |cookie_accounts|, which are then put into
-// the Gaia cookie.
 // NOTE: See disclaimer at top of file re: direct usage.
-void SetCookieAccounts(IdentityManager* identity_manager,
-                       network::TestURLLoaderFactory* test_url_loader_factory,
+void SetCookieAccounts(FakeGaiaCookieManagerService* cookie_manager,
+                       IdentityManager* identity_manager,
                        const std::vector<CookieParams>& cookie_accounts);
 
 // Updates the info for |account_info.account_id|, which must be a known
@@ -134,11 +131,6 @@
 void UpdateAccountInfoForAccount(IdentityManager* identity_manager,
                                  AccountInfo account_info);
 
-// Sets whether the list of accounts in Gaia cookie jar is fresh and does not
-// need to be updated.
-void SetFreshnessOfAccountsInGaiaCookie(IdentityManager* identity_manager,
-                                        bool accounts_are_fresh);
-
 std::string GetTestGaiaIdForEmail(const std::string& email);
 
 // Updates the persistent auth error set on |account_id| which must be a known
@@ -151,14 +143,6 @@
 // Disables internal retries of failed access token fetches.
 void DisableAccessTokenFetchRetries(IdentityManager* identity_manager);
 
-#if defined(OS_ANDROID)
-// Disables interaction with system accounts, which requires special permission.
-void DisableInteractionWithSystemAccounts();
-#endif
-
-// Cancels all ongoing operations related to the accounts in the Gaia cookie.
-void CancelAllOngoingGaiaCookieOperations(IdentityManager* identity_manager);
-
 }  // namespace identity
 
 #endif  // SERVICES_IDENTITY_PUBLIC_CPP_IDENTITY_TEST_UTILS_H_
--- a/services/identity/public/cpp/OWNERS	2019-05-01 01:22:56.000000000 +0300
+++ b/services/identity/public/cpp/OWNERS	2019-05-17 18:53:37.860000000 +0300
@@ -2,7 +2,3 @@
 per-file *_mojom_traits*.*=file://ipc/SECURITY_OWNERS
 per-file *.typemap=set noparent
 per-file *.typemap=file://ipc/SECURITY_OWNERS
-per-file manifest.cc=set noparent
-per-file manifest.cc=file://ipc/SECURITY_OWNERS
-per-file manifest.h=set noparent
-per-file manifest.h=file://ipc/SECURITY_OWNERS
--- a/services/identity/public/cpp/primary_account_access_token_fetcher.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/identity/public/cpp/primary_account_access_token_fetcher.cc	2019-05-17 18:53:37.864000000 +0300
@@ -6,7 +6,6 @@
 
 #include <utility>
 
-#include "base/bind.h"
 #include "base/logging.h"
 #include "services/identity/public/cpp/identity_manager.h"
 
@@ -71,12 +70,12 @@
 }
 
 void PrimaryAccountAccessTokenFetcher::OnPrimaryAccountSet(
-    const CoreAccountInfo& primary_account_info) {
+    const AccountInfo& primary_account_info) {
   ProcessSigninStateChange();
 }
 
 void PrimaryAccountAccessTokenFetcher::OnRefreshTokenUpdatedForAccount(
-    const CoreAccountInfo& account_info) {
+    const AccountInfo& account_info) {
   ProcessSigninStateChange();
 }
 
--- a/services/identity/public/cpp/primary_account_access_token_fetcher.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/identity/public/cpp/primary_account_access_token_fetcher.h	2019-05-17 18:53:37.864000000 +0300
@@ -62,10 +62,9 @@
   void StartAccessTokenRequest();
 
   // IdentityManager::Observer implementation.
-  void OnPrimaryAccountSet(
-      const CoreAccountInfo& primary_account_info) override;
+  void OnPrimaryAccountSet(const AccountInfo& primary_account_info) override;
   void OnRefreshTokenUpdatedForAccount(
-      const CoreAccountInfo& account_info) override;
+      const AccountInfo& account_info) override;
 
   // Checks whether credentials are now available and starts an access token
   // request if so. Should only be called in mode |kWaitUntilAvailable|.
--- a/services/identity/public/cpp/primary_account_access_token_fetcher_unittest.cc	2019-05-17 17:45:42.520000000 +0300
+++ b/services/identity/public/cpp/primary_account_access_token_fetcher_unittest.cc	2019-05-17 18:53:37.864000000 +0300
@@ -68,7 +68,7 @@
 
   // Signs the user in to the primary account, returning the account ID.
   std::string SignIn() {
-    return identity_test_env_.MakePrimaryAccountAvailable("me@9ma1l.qjz9zk")
+    return identity_test_env_.MakePrimaryAccountAvailable("me@gmail.com")
         .account_id;
   }
 
@@ -161,7 +161,7 @@
        OneShotCallsBackWhenNoRefreshToken) {
   base::RunLoop run_loop;
 
-  identity_test_env()->SetPrimaryAccount("me@9ma1l.qjz9zk");
+  identity_test_env()->SetPrimaryAccount("me@gmail.com");
 
   // Signed in, but there is no refresh token -> we should get called back.
   auto fetcher = CreateFetcher(
@@ -217,7 +217,7 @@
   TestTokenCallback callback;
 
   std::string account_id =
-      identity_test_env()->SetPrimaryAccount("me@9ma1l.qjz9zk").account_id;
+      identity_test_env()->SetPrimaryAccount("me@gmail.com").account_id;
 
   // Signed in, but there is no refresh token -> we should not get called back
   // (yet).
@@ -247,7 +247,7 @@
   // Signed-in to account_id, but there's only a refresh token for a different
   // account.
   std::string account_id =
-      identity_test_env()->SetPrimaryAccount("me@9ma1l.qjz9zk").account_id;
+      identity_test_env()->SetPrimaryAccount("me@gmail.com").account_id;
   identity_test_env()->MakeAccountAvailable(account_id + "2");
 
   // The fetcher should wait for the correct refresh token.
--- a/services/identity/public/cpp/primary_account_mutator.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/identity/public/cpp/primary_account_mutator.h	2019-05-17 18:53:37.864000000 +0300
@@ -10,6 +10,8 @@
 #include "base/callback_forward.h"
 #include "components/signin/core/browser/signin_metrics.h"
 
+struct AccountInfo;
+
 namespace identity {
 
 // PrimaryAccountMutator is the interface to set and clear the primary account
@@ -65,6 +67,43 @@
   // Sets the pattern controlling which user names are allowed when setting
   // the primary account.
   virtual void SetAllowedPrimaryAccountPattern(const std::string& pattern) = 0;
+
+  // All the following APIs are for use by legacy code only. They are deprecated
+  // and should not be used when writing new code. They will be removed when the
+  // old sign-in workflow has been turned down.
+
+  // Attempts to sign-in user with a given refresh token and account. If it is
+  // defined, |callback| should invoke either ClearPrimaryAccount() or
+  // LegacyCompletePendingPrimaryAccountSignin() to either cancel or continue
+  // the in progress sign-in (legacy, pre-DICE workflow).
+  virtual void LegacyStartSigninWithRefreshTokenForPrimaryAccount(
+      const std::string& refresh_token,
+      const std::string& gaia_id,
+      const std::string& username,
+      const std::string& password,
+      base::OnceCallback<void(const std::string&)> callback) = 0;
+
+  // Complete the in-process sign-in (legacy, pre-DICE workflow).
+  virtual void LegacyCompletePendingPrimaryAccountSignin() = 0;
+
+  // If applicable, merges the signed-in account into the cookie jar (legacy,
+  // pre-DICE workflow).
+  virtual void LegacyMergeSigninCredentialIntoCookieJar() = 0;
+
+  // Returns true if there is a sign-in in progress (legacy, pre-DICE workflow).
+  virtual bool LegacyIsPrimaryAccountAuthInProgress() const = 0;
+
+  // If an authentication is in progress, returns the AccountInfo for the
+  // account being authenticated. Returns an empty AccountInfo if no auth is
+  // in progress (legacy, pre-DICE workflow).
+  virtual AccountInfo LegacyPrimaryAccountForAuthInProgress() const = 0;
+
+  // Copy auth credentials from the other PrimaryAccountMutator to this one.
+  // Used when creating a new profile during the sign-in process to transfer
+  // the in-progress credential information to the new profile (legacy, pre-
+  // DICE workflow).
+  virtual void LegacyCopyCredentialsFrom(
+      const PrimaryAccountMutator& source) = 0;
 };
 
 }  // namespace identity
--- a/services/identity/public/cpp/primary_account_mutator_impl.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/identity/public/cpp/primary_account_mutator_impl.cc	2019-05-17 18:53:37.864000000 +0300
@@ -4,8 +4,6 @@
 
 #include "services/identity/public/cpp/primary_account_mutator_impl.h"
 
-#include <utility>
-
 #include "components/signin/core/browser/account_tracker_service.h"
 #include "components/signin/core/browser/signin_manager.h"
 
@@ -43,7 +41,10 @@
     ClearAccountsAction action,
     signin_metrics::ProfileSignout source_metric,
     signin_metrics::SignoutDelete delete_metric) {
-  if (!signin_manager_->IsAuthenticated())
+  // Check if and auth process is ongoing before reporting failure to support
+  // the legacy workflow of cancelling it by clearing the primary account.
+  if (!signin_manager_->IsAuthenticated() &&
+      !LegacyIsPrimaryAccountAuthInProgress())
     return false;
 
   switch (action) {
@@ -75,4 +76,46 @@
   NOTIMPLEMENTED();
 }
 
+void PrimaryAccountMutatorImpl::
+    LegacyStartSigninWithRefreshTokenForPrimaryAccount(
+        const std::string& refresh_token,
+        const std::string& gaia_id,
+        const std::string& username,
+        const std::string& password,
+        base::OnceCallback<void(const std::string&)> callback) {
+  signin_manager_->StartSignInWithRefreshToken(refresh_token, gaia_id, username,
+                                               password, std::move(callback));
+}
+
+void PrimaryAccountMutatorImpl::LegacyCompletePendingPrimaryAccountSignin() {
+  signin_manager_->CompletePendingSignin();
+}
+
+void PrimaryAccountMutatorImpl::LegacyMergeSigninCredentialIntoCookieJar() {
+  signin_manager_->MergeSigninCredentialIntoCookieJar();
+}
+
+bool PrimaryAccountMutatorImpl::LegacyIsPrimaryAccountAuthInProgress() const {
+  return signin_manager_->AuthInProgress();
+}
+
+AccountInfo PrimaryAccountMutatorImpl::LegacyPrimaryAccountForAuthInProgress()
+    const {
+  if (!LegacyIsPrimaryAccountAuthInProgress())
+    return AccountInfo{};
+
+  AccountInfo account_info;
+  account_info.account_id = signin_manager_->GetAccountIdForAuthInProgress();
+  account_info.gaia = signin_manager_->GetGaiaIdForAuthInProgress();
+  account_info.email = signin_manager_->GetUsernameForAuthInProgress();
+
+  return account_info;
+}
+
+void PrimaryAccountMutatorImpl::LegacyCopyCredentialsFrom(
+    const PrimaryAccountMutator& source) {
+  signin_manager_->CopyCredentialsFrom(
+      *static_cast<const PrimaryAccountMutatorImpl&>(source).signin_manager_);
+}
+
 }  // namespace identity
--- a/services/identity/public/cpp/primary_account_mutator_impl.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/identity/public/cpp/primary_account_mutator_impl.h	2019-05-17 18:53:37.864000000 +0300
@@ -29,6 +29,17 @@
   bool IsSettingPrimaryAccountAllowed() const override;
   void SetSettingPrimaryAccountAllowed(bool allowed) override;
   void SetAllowedPrimaryAccountPattern(const std::string& pattern) override;
+  void LegacyStartSigninWithRefreshTokenForPrimaryAccount(
+      const std::string& refresh_token,
+      const std::string& gaia_id,
+      const std::string& username,
+      const std::string& password,
+      base::OnceCallback<void(const std::string&)> callback) override;
+  void LegacyCompletePendingPrimaryAccountSignin() override;
+  void LegacyMergeSigninCredentialIntoCookieJar() override;
+  bool LegacyIsPrimaryAccountAuthInProgress() const override;
+  AccountInfo LegacyPrimaryAccountForAuthInProgress() const override;
+  void LegacyCopyCredentialsFrom(const PrimaryAccountMutator& source) override;
 
  private:
   // Pointers to the services used by the PrimaryAccountMutatorImpl. They
--- a/services/identity/public/cpp/primary_account_mutator_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/identity/public/cpp/primary_account_mutator_unittest.cc	2019-05-17 18:53:37.864000000 +0300
@@ -4,7 +4,6 @@
 
 #include "services/identity/public/cpp/primary_account_mutator.h"
 
-#include "base/bind.h"
 #include "base/containers/flat_set.h"
 #include "base/run_loop.h"
 #include "base/scoped_observer.h"
@@ -20,6 +19,8 @@
 const char kUnknownAccountId[] = "{unknown account id}";
 const char kPrimaryAccountEmail[] = "primary.account@example.com";
 const char kAnotherAccountEmail[] = "another.account@example.com";
+const char kRefreshToken[] = "refresh_token";
+const char kPassword[] = "password";
 
 // All account consistency methods that are tested by those unit tests when
 // testing ClearPrimaryAccount method.
@@ -38,7 +39,7 @@
 // method OnPrimaryAccountCleared is invoked. The parameter will be a
 // reference to the still valid primary account that was cleared.
 using PrimaryAccountClearedCallback =
-    base::RepeatingCallback<void(const CoreAccountInfo&)>;
+    base::RepeatingCallback<void(const AccountInfo&)>;
 
 // This callback will be invoked every time the IdentityManager::Observer
 // method OnPrimaryAccountSigninFailed is invoked. The parameter will be
@@ -74,7 +75,7 @@
   }
 
   // identity::IdentityManager::Observer implementation.
-  void OnPrimaryAccountCleared(const CoreAccountInfo& account_info) override {
+  void OnPrimaryAccountCleared(const AccountInfo& account_info) override {
     on_primary_account_cleared_.Run(account_info);
   }
 
@@ -162,7 +163,7 @@
   base::RunLoop run_loop;
   PrimaryAccountClearedCallback primary_account_cleared_callback =
       base::BindRepeating([](base::RepeatingClosure quit_closure,
-                             const CoreAccountInfo&) { quit_closure.Run(); },
+                             const AccountInfo&) { quit_closure.Run(); },
                           run_loop.QuitClosure());
 
   // Authentication error should not occur.
@@ -443,9 +444,9 @@
       signin_metrics::SIGNOUT_TEST,
       signin_metrics::SignoutDelete::IGNORE_METRIC));
 
-  // The underlying SigninManager in IdentityTestEnvironment will be created
-  // with signin::AccountConsistencyMethod::kDisabled, which should result in
-  // ClearPrimaryAccount() removing all the tokens.
+  // The underlying SigninManager in IdentityTestEnvironment (FakeSigninManager)
+  // will be created with signin::AccountConsistencyMethod::kDisabled, which
+  // should result in ClearPrimaryAccount() removing all the tokens.
   EXPECT_FALSE(identity_manager->HasPrimaryAccount());
   EXPECT_FALSE(identity_manager->HasAccountWithRefreshToken(
       primary_account_info.account_id));
@@ -519,3 +520,426 @@
       identity::PrimaryAccountMutator::ClearAccountsAction::kDefault,
       RemoveAccountExpectation::kRemovePrimary, AuthExpectation::kAuthError);
 }
+
+// Test that ClearPrimaryAccount(...) with authentication in progress notifies
+// Observers that sign-in is canceled and does not remove any tokens.
+TEST_F(PrimaryAccountMutatorTest, ClearPrimaryAccount_AuthInProgress) {
+  base::test::ScopedTaskEnvironment task_environment;
+  identity::IdentityTestEnvironment environment;
+
+  identity::IdentityManager* identity_manager = environment.identity_manager();
+  identity::PrimaryAccountMutator* primary_account_mutator =
+      identity_manager->GetPrimaryAccountMutator();
+
+  // Abort the test if the current platform does not support mutation of the
+  // primary account (the returned PrimaryAccountMutator* will be null).
+  if (!primary_account_mutator)
+    return;
+
+  AccountInfo account_info =
+      environment.MakeAccountAvailable(kPrimaryAccountEmail);
+  EXPECT_TRUE(
+      identity_manager->HasAccountWithRefreshToken(account_info.account_id));
+
+  // Account available in the tracker service but still not authenticated means
+  // there's neither a primary account nor an authentication process ongoing.
+  EXPECT_FALSE(identity_manager->HasPrimaryAccount());
+  EXPECT_FALSE(primary_account_mutator->LegacyIsPrimaryAccountAuthInProgress());
+
+  // Add a secondary account to verify that its refresh token survives the
+  // call to ClearPrimaryAccount(...) below.
+  AccountInfo secondary_account_info =
+      MakeAccountAvailable(identity_manager, kAnotherAccountEmail);
+  EXPECT_TRUE(identity_manager->HasAccountWithRefreshToken(
+      secondary_account_info.account_id));
+
+  // Start a signin process for the account we just made available and check
+  // that it's reported to be in progress before the process is completed.
+  base::RunLoop run_loop;
+  std::string signed_account_refresh_token;
+  primary_account_mutator->LegacyStartSigninWithRefreshTokenForPrimaryAccount(
+      kRefreshToken, account_info.gaia, account_info.email, kPassword,
+      base::BindOnce(
+          [](std::string* out_refresh_token, const std::string& refresh_token) {
+            *out_refresh_token = refresh_token;
+          },
+          base::Unretained(&signed_account_refresh_token)));
+
+  EXPECT_TRUE(primary_account_mutator->LegacyIsPrimaryAccountAuthInProgress());
+
+  AccountInfo auth_in_progress_account_info =
+      primary_account_mutator->LegacyPrimaryAccountForAuthInProgress();
+
+  // No primary account to "clear", so no callback.
+  PrimaryAccountClearedCallback primary_account_cleared_callback =
+      base::BindRepeating([](const AccountInfo&) {
+        FAIL() << "no primary account is set, so nothing should be cleared";
+      });
+
+  // Capture the authentication error and make sure we exit the run loop.
+  GoogleServiceAuthError captured_auth_error;
+  PrimaryAccountSigninFailedCallback primary_account_signin_failed_callback =
+      base::BindRepeating(
+          [](base::RepeatingClosure quit_closure,
+             GoogleServiceAuthError* out_auth_error,
+             const GoogleServiceAuthError& auth_error) {
+            *out_auth_error = auth_error;
+            quit_closure.Run();
+          },
+          run_loop.QuitClosure(), &captured_auth_error);
+
+  // Observer should not be notified of any token removals.
+  RefreshTokenRemovedCallback refresh_token_removed_callback =
+      base::BindRepeating([](const std::string& removed_account) {
+        FAIL() << "no token removal should happen";
+      });
+
+  ClearPrimaryAccountTestObserver scoped_observer(
+      identity_manager, primary_account_cleared_callback,
+      primary_account_signin_failed_callback, refresh_token_removed_callback);
+
+  EXPECT_TRUE(primary_account_mutator->ClearPrimaryAccount(
+      identity::PrimaryAccountMutator::ClearAccountsAction::kRemoveAll,
+      signin_metrics::SIGNOUT_TEST,
+      signin_metrics::SignoutDelete::IGNORE_METRIC));
+  run_loop.Run();
+
+  // Verify in-progress authentication was canceled.
+  EXPECT_EQ(captured_auth_error.state(),
+            GoogleServiceAuthError::State::REQUEST_CANCELED);
+  EXPECT_FALSE(primary_account_mutator->LegacyIsPrimaryAccountAuthInProgress());
+
+  // We didn't have a primary account to start with, we shouldn't have one now
+  // either.
+  EXPECT_FALSE(identity_manager->HasPrimaryAccount());
+  EXPECT_FALSE(identity_manager->HasPrimaryAccountWithRefreshToken());
+
+  // Secondary account token still exists.
+  EXPECT_TRUE(identity_manager->HasAccountWithRefreshToken(
+      secondary_account_info.account_id));
+}
+
+// Checks that checking whether an authentication process is in progress reports
+// true before starting and after successfully completing the signin process.
+TEST_F(PrimaryAccountMutatorTest, SigninWithRefreshToken) {
+  base::test::ScopedTaskEnvironment task_environment;
+  identity::IdentityTestEnvironment environment;
+
+  identity::IdentityManager* identity_manager = environment.identity_manager();
+  identity::PrimaryAccountMutator* primary_account_mutator =
+      identity_manager->GetPrimaryAccountMutator();
+
+  // Abort the test if the current platform does not support mutation of the
+  // primary account (the returned PrimaryAccountMutator* will be null).
+  if (!primary_account_mutator)
+    return;
+
+  // We'll sign in the same account twice, using SetPrimaryAccount() and
+  // LegacyStartSigninWithRefreshTokenForPrimaryAccount(), and check that
+  // in both cases the end result is the same.
+  AccountInfo account_info =
+      environment.MakeAccountAvailable(kPrimaryAccountEmail);
+
+  EXPECT_FALSE(identity_manager->HasPrimaryAccount());
+  EXPECT_TRUE(
+      primary_account_mutator->SetPrimaryAccount(account_info.account_id));
+
+  const std::string primary_account_id_1 =
+      identity_manager->GetPrimaryAccountId();
+
+  EXPECT_TRUE(identity_manager->HasPrimaryAccount());
+  EXPECT_FALSE(primary_account_id_1.empty());
+  EXPECT_EQ(primary_account_id_1, account_info.account_id);
+
+  EXPECT_TRUE(
+      identity_manager->HasAccountWithRefreshToken(primary_account_id_1));
+  EXPECT_FALSE(identity_manager->GetPrimaryAccountInfo().email.empty());
+
+  // Sign out the account to try to sign in again with the other mechanism, but
+  // using kKeepAll so we can use the same account we made available before.
+  EXPECT_TRUE(primary_account_mutator->ClearPrimaryAccount(
+      identity::PrimaryAccountMutator::ClearAccountsAction::kKeepAll,
+      signin_metrics::SIGNOUT_TEST,
+      signin_metrics::SignoutDelete::IGNORE_METRIC));
+
+  EXPECT_FALSE(identity_manager->HasPrimaryAccount());
+  EXPECT_TRUE(identity_manager->GetPrimaryAccountId().empty());
+  EXPECT_TRUE(identity_manager->GetPrimaryAccountInfo().email.empty());
+
+  // Start a signin process for the account and complete it right away to check
+  // whether we end up with a similar result than with SetPrimaryAccount().
+  std::string signed_account_refresh_token;
+  primary_account_mutator->LegacyStartSigninWithRefreshTokenForPrimaryAccount(
+      kRefreshToken, account_info.gaia, account_info.email, kPassword,
+      base::BindOnce(
+          [](std::string* out_refresh_token, const std::string& refresh_token) {
+            *out_refresh_token = refresh_token;
+          },
+          base::Unretained(&signed_account_refresh_token)));
+
+  primary_account_mutator->LegacyCompletePendingPrimaryAccountSignin();
+
+  // The refresh token assigned to the account should match the one passed.
+  EXPECT_EQ(signed_account_refresh_token, kRefreshToken);
+
+  EXPECT_TRUE(identity_manager->HasPrimaryAccount());
+  EXPECT_FALSE(primary_account_id_1.empty());
+  EXPECT_EQ(primary_account_id_1, account_info.account_id);
+
+  EXPECT_TRUE(
+      identity_manager->HasAccountWithRefreshToken(primary_account_id_1));
+  EXPECT_FALSE(identity_manager->GetPrimaryAccountInfo().email.empty());
+
+  const std::string primary_account_id_2 =
+      identity_manager->GetPrimaryAccountId();
+
+  EXPECT_TRUE(identity_manager->HasPrimaryAccount());
+  EXPECT_FALSE(primary_account_id_2.empty());
+  EXPECT_EQ(primary_account_id_2, account_info.account_id);
+
+  EXPECT_TRUE(
+      identity_manager->HasAccountWithRefreshToken(primary_account_id_2));
+  EXPECT_FALSE(identity_manager->GetPrimaryAccountInfo().email.empty());
+
+  // Information retrieved via the IdentityManager now for the current primary
+  // account should match the data of the account we signed in before.
+  EXPECT_EQ(primary_account_id_1, primary_account_id_2);
+}
+
+// Checks that checking whether an authentication process is in progress reports
+// true before starting and after successfully completing the signin process.
+TEST_F(PrimaryAccountMutatorTest, AuthInProgress_SigninCompleted) {
+  base::test::ScopedTaskEnvironment task_environment;
+  identity::IdentityTestEnvironment environment;
+
+  identity::IdentityManager* identity_manager = environment.identity_manager();
+  identity::PrimaryAccountMutator* primary_account_mutator =
+      identity_manager->GetPrimaryAccountMutator();
+
+  // Abort the test if the current platform does not support mutation of the
+  // primary account (the returned PrimaryAccountMutator* will be null).
+  if (!primary_account_mutator)
+    return;
+
+  AccountInfo account_info =
+      environment.MakeAccountAvailable(kPrimaryAccountEmail);
+
+  // Account available in the tracker service but still not authenticated means
+  // there's neither a primary account nor an authentication process ongoing.
+  EXPECT_FALSE(identity_manager->HasPrimaryAccount());
+  EXPECT_FALSE(primary_account_mutator->LegacyIsPrimaryAccountAuthInProgress());
+
+  // Start a signin process for the account we just made available and check
+  // that it's reported to be in progress before the process is completed.
+  base::RunLoop run_loop;
+  std::string signed_account_refresh_token;
+  primary_account_mutator->LegacyStartSigninWithRefreshTokenForPrimaryAccount(
+      kRefreshToken, account_info.gaia, account_info.email, kPassword,
+      base::BindOnce(
+          [](std::string* out_refresh_token, const std::string& refresh_token) {
+            *out_refresh_token = refresh_token;
+          },
+          base::Unretained(&signed_account_refresh_token)));
+
+  EXPECT_TRUE(primary_account_mutator->LegacyIsPrimaryAccountAuthInProgress());
+
+  AccountInfo auth_in_progress_account_info =
+      primary_account_mutator->LegacyPrimaryAccountForAuthInProgress();
+
+  // The data from the AccountInfo related to the authentication process still
+  // in progress should match the data of the account being signed in.
+  EXPECT_EQ(auth_in_progress_account_info.account_id, account_info.account_id);
+  EXPECT_EQ(auth_in_progress_account_info.gaia, account_info.gaia);
+  EXPECT_EQ(auth_in_progress_account_info.email, account_info.email);
+
+  // Finally, complete the signin process so that we can do further checks.
+  primary_account_mutator->LegacyCompletePendingPrimaryAccountSignin();
+  run_loop.RunUntilIdle();
+
+  // The refresh token assigned to the account should match the one passed.
+  EXPECT_EQ(signed_account_refresh_token, kRefreshToken);
+
+  // An account has been authenticated now, so there should be a primary account
+  // authenticated and no authentication process reported as in progress now.
+  EXPECT_TRUE(identity_manager->HasPrimaryAccount());
+  EXPECT_FALSE(primary_account_mutator->LegacyIsPrimaryAccountAuthInProgress());
+
+  // Information retrieved via the IdentityManager now for the current primary
+  // account should match the data of the account being signed in.
+  EXPECT_EQ(identity_manager->GetPrimaryAccountId(), account_info.account_id);
+  AccountInfo identity_manager_account_info =
+      identity_manager->GetPrimaryAccountInfo();
+  EXPECT_EQ(identity_manager_account_info.account_id, account_info.account_id);
+  EXPECT_EQ(identity_manager_account_info.gaia, account_info.gaia);
+  EXPECT_EQ(identity_manager_account_info.email, account_info.email);
+}
+
+// Checks that checking whether an authentication process is in progress reports
+// true before starting and after cancelling and ongoing signin process.
+TEST_F(PrimaryAccountMutatorTest, AuthInProgress_SigninCancelled) {
+  base::test::ScopedTaskEnvironment task_environment;
+  identity::IdentityTestEnvironment environment;
+
+  identity::IdentityManager* identity_manager = environment.identity_manager();
+  identity::PrimaryAccountMutator* primary_account_mutator =
+      identity_manager->GetPrimaryAccountMutator();
+
+  // Abort the test if the current platform does not support mutation of the
+  // primary account (the returned PrimaryAccountMutator* will be null).
+  if (!primary_account_mutator)
+    return;
+
+  AccountInfo account_info =
+      environment.MakeAccountAvailable(kPrimaryAccountEmail);
+
+  // Account available in the tracker service but still not authenticated means
+  // there's neither a primary account nor an authentication process ongoing.
+  EXPECT_FALSE(identity_manager->HasPrimaryAccount());
+  EXPECT_FALSE(primary_account_mutator->LegacyIsPrimaryAccountAuthInProgress());
+
+  // Start a signin process for the account we just made available and check
+  // that it's reported to be in progress before the process is completed.
+  base::RunLoop run_loop;
+  std::string signed_account_refresh_token;
+  primary_account_mutator->LegacyStartSigninWithRefreshTokenForPrimaryAccount(
+      kRefreshToken, account_info.gaia, account_info.email, kPassword,
+      base::BindOnce(
+          [](std::string* out_refresh_token, const std::string& refresh_token) {
+            *out_refresh_token = refresh_token;
+          },
+          base::Unretained(&signed_account_refresh_token)));
+
+  EXPECT_TRUE(primary_account_mutator->LegacyIsPrimaryAccountAuthInProgress());
+
+  AccountInfo auth_in_progress_account_info =
+      primary_account_mutator->LegacyPrimaryAccountForAuthInProgress();
+
+  // The data from the AccountInfo related to the authentication process still
+  // in progress should match the data of the account being signed in.
+  EXPECT_EQ(auth_in_progress_account_info.account_id, account_info.account_id);
+  EXPECT_EQ(auth_in_progress_account_info.gaia, account_info.gaia);
+  EXPECT_EQ(auth_in_progress_account_info.email, account_info.email);
+
+  // Now cancel the signin process (by attempting to clear the primary account
+  // we were trying to sign in so far), so that we can do further checks.
+  EXPECT_TRUE(primary_account_mutator->ClearPrimaryAccount(
+      identity::PrimaryAccountMutator::ClearAccountsAction::kRemoveAll,
+      signin_metrics::SIGNOUT_TEST,
+      signin_metrics::SignoutDelete::IGNORE_METRIC));
+  run_loop.RunUntilIdle();
+
+  // The refresh token assigned to the account should match the one passed.
+  EXPECT_EQ(signed_account_refresh_token, kRefreshToken);
+
+  // The request has been cancelled, so there should not be a primary account
+  // signed in, the refresh we just received should not be valid for the primary
+  // account (even if it's been fetched and stored for the account already) and
+  // no authentication process reported as in progress now.
+  EXPECT_FALSE(identity_manager->HasPrimaryAccount());
+  EXPECT_FALSE(identity_manager->HasPrimaryAccountWithRefreshToken());
+  EXPECT_TRUE(
+      identity_manager->HasAccountWithRefreshToken(account_info.account_id));
+  EXPECT_FALSE(primary_account_mutator->LegacyIsPrimaryAccountAuthInProgress());
+
+  // Information retrieved via the IdentityManager confirms the cancelation.
+  EXPECT_EQ(identity_manager->GetPrimaryAccountId(), std::string());
+  EXPECT_TRUE(identity_manager->GetPrimaryAccountInfo().IsEmpty());
+}
+
+// Checks that copying the credentials from another PrimaryAccountMutator works.
+TEST_F(PrimaryAccountMutatorTest, CopyCredentialsFrom) {
+  base::test::ScopedTaskEnvironment task_environment;
+  identity::IdentityTestEnvironment environment;
+
+  identity::IdentityManager* identity_manager = environment.identity_manager();
+  identity::PrimaryAccountMutator* primary_account_mutator =
+      identity_manager->GetPrimaryAccountMutator();
+
+  // Abort the test if the current platform does not support mutation of the
+  // primary account (the returned PrimaryAccountMutator* will be null).
+  if (!primary_account_mutator)
+    return;
+
+  // We will need another PrimaryAccountMutator to copy the credentials from the
+  // one used previously and check that they match later on.
+  identity::IdentityTestEnvironment other_environment;
+  identity::IdentityManager* other_identity_manager =
+      other_environment.identity_manager();
+  identity::PrimaryAccountMutator* other_primary_account_mutator =
+      other_identity_manager->GetPrimaryAccountMutator();
+
+  AccountInfo account_info =
+      environment.MakeAccountAvailable(kPrimaryAccountEmail);
+
+  // Start a signin process for the account we just made available so that we
+  // can check whether the credentials copied to another PrimaryAccountMutator.
+  base::RunLoop run_loop;
+  std::string signed_account_refresh_token;
+  primary_account_mutator->LegacyStartSigninWithRefreshTokenForPrimaryAccount(
+      kRefreshToken, account_info.gaia, account_info.email, kPassword,
+      base::BindOnce(
+          [](std::string* out_refresh_token, const std::string& refresh_token) {
+            *out_refresh_token = refresh_token;
+          },
+          base::Unretained(&signed_account_refresh_token)));
+  run_loop.RunUntilIdle();
+
+  // The refresh token assigned to the account should match the one passed.
+  EXPECT_EQ(signed_account_refresh_token, kRefreshToken);
+
+  // This is a good moment to copy the credentials from one mutator to the other
+  // since internal transient data hold by the SigninManager in this state will
+  // be non-empty while the authentication process is ongoing (e.g. possibly
+  // invalid account ID, Gaia ID and email), allowing us to compare values.
+  base::RunLoop run_loop2;
+  other_primary_account_mutator->LegacyCopyCredentialsFrom(
+      *primary_account_mutator);
+  run_loop2.RunUntilIdle();
+
+  EXPECT_TRUE(primary_account_mutator->LegacyIsPrimaryAccountAuthInProgress());
+  EXPECT_TRUE(
+      other_primary_account_mutator->LegacyIsPrimaryAccountAuthInProgress());
+
+  AccountInfo auth_in_progress_account_info =
+      primary_account_mutator->LegacyPrimaryAccountForAuthInProgress();
+  AccountInfo other_auth_in_progress_account_info =
+      other_primary_account_mutator->LegacyPrimaryAccountForAuthInProgress();
+
+  EXPECT_FALSE(auth_in_progress_account_info.IsEmpty());
+  EXPECT_FALSE(other_auth_in_progress_account_info.IsEmpty());
+
+  EXPECT_EQ(auth_in_progress_account_info.account_id,
+            other_auth_in_progress_account_info.account_id);
+  EXPECT_EQ(auth_in_progress_account_info.gaia,
+            other_auth_in_progress_account_info.gaia);
+  EXPECT_EQ(auth_in_progress_account_info.email,
+            other_auth_in_progress_account_info.email);
+
+  // Finally, complete the signin process so that we can do further checks.
+  base::RunLoop run_loop3;
+  primary_account_mutator->LegacyCompletePendingPrimaryAccountSignin();
+  run_loop3.RunUntilIdle();
+
+  // An account has been authenticated now, so there should be a primary account
+  // authenticated and no authentication process reported as in progress now.
+  EXPECT_TRUE(identity_manager->HasPrimaryAccount());
+  EXPECT_FALSE(primary_account_mutator->LegacyIsPrimaryAccountAuthInProgress());
+
+  // Query again the information for each of the two different environments now
+  // that the original one has completed the authentication process and compare
+  // them one more time: they should not match as the original one is no longer
+  // in the middle of the authentication process.
+  EXPECT_TRUE(identity_manager->HasPrimaryAccount());
+  EXPECT_FALSE(other_identity_manager->HasPrimaryAccount());
+
+  EXPECT_FALSE(primary_account_mutator->LegacyIsPrimaryAccountAuthInProgress());
+  EXPECT_TRUE(
+      other_primary_account_mutator->LegacyIsPrimaryAccountAuthInProgress());
+
+  auth_in_progress_account_info =
+      primary_account_mutator->LegacyPrimaryAccountForAuthInProgress();
+  other_auth_in_progress_account_info =
+      other_primary_account_mutator->LegacyPrimaryAccountForAuthInProgress();
+  EXPECT_TRUE(auth_in_progress_account_info.IsEmpty());
+  EXPECT_FALSE(other_auth_in_progress_account_info.IsEmpty());
+}
--- a/services/identity/public/mojom/BUILD.gn	2019-05-01 01:22:56.000000000 +0300
+++ b/services/identity/public/mojom/BUILD.gn	2019-05-17 18:53:37.864000000 +0300
@@ -10,7 +10,7 @@
     "account_info.mojom",
     "account_state.mojom",
     "google_service_auth_error.mojom",
-    "identity_accessor.mojom",
+    "identity_manager.mojom",
     "scope_set.mojom",
   ]
 
--- a/services/identity/public/objc/identity_manager_observer_bridge.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/identity/public/objc/identity_manager_observer_bridge.h	2019-05-17 18:53:37.868000000 +0300
@@ -22,16 +22,18 @@
 // IdentityManager::Observer in identity_manager.h for the specification of
 // these semantics.
 
-- (void)onPrimaryAccountSet:(const CoreAccountInfo&)primaryAccountInfo;
-- (void)onPrimaryAccountCleared:
-    (const CoreAccountInfo&)previousPrimaryAccountInfo;
+- (void)onPrimaryAccountSet:(const AccountInfo&)primaryAccountInfo;
+- (void)onPrimaryAccountSet:(const AccountInfo&)primaryAccountInfo
+               withPassword:(const std::string&)password;
+- (void)onPrimaryAccountCleared:(const AccountInfo&)previousPrimaryAccountInfo;
 - (void)onPrimaryAccountSigninFailed:(const GoogleServiceAuthError&)error;
-- (void)onRefreshTokenUpdatedForAccount:(const CoreAccountInfo&)accountInfo;
+- (void)onRefreshTokenUpdatedForAccount:(const AccountInfo&)accountInfo;
 - (void)onRefreshTokenRemovedForAccount:(const std::string&)accountId;
 - (void)onRefreshTokensLoaded;
 - (void)onAccountsInCookieUpdated:
             (const identity::AccountsInCookieJarInfo&)accountsInCookieJarInfo
                             error:(const GoogleServiceAuthError&)error;
+- (void)onStartBatchOfRefreshTokenStateChanges;
 - (void)onEndBatchOfRefreshTokenStateChanges;
 
 @end
@@ -48,19 +50,21 @@
   ~IdentityManagerObserverBridge() override;
 
   // IdentityManager::Observer.
-  void OnPrimaryAccountSet(
-      const CoreAccountInfo& primary_account_info) override;
+  void OnPrimaryAccountSet(const AccountInfo& primary_account_info) override;
+  void OnPrimaryAccountSetWithPassword(const AccountInfo& primary_account_info,
+                                       const std::string& password) override;
   void OnPrimaryAccountCleared(
-      const CoreAccountInfo& previous_primary_account_info) override;
+      const AccountInfo& previous_primary_account_info) override;
   void OnPrimaryAccountSigninFailed(
       const GoogleServiceAuthError& error) override;
   void OnRefreshTokenUpdatedForAccount(
-      const CoreAccountInfo& account_info) override;
+      const AccountInfo& account_info) override;
   void OnRefreshTokenRemovedForAccount(const std::string& account_id) override;
   void OnRefreshTokensLoaded() override;
   void OnAccountsInCookieUpdated(
       const identity::AccountsInCookieJarInfo& accounts_in_cookie_jar_info,
       const GoogleServiceAuthError& error) override;
+  void OnStartBatchOfRefreshTokenStateChanges() override;
   void OnEndBatchOfRefreshTokenStateChanges() override;
 
  private:
--- a/services/identity/public/objc/identity_manager_observer_bridge.mm	2019-05-01 01:22:56.000000000 +0300
+++ b/services/identity/public/objc/identity_manager_observer_bridge.mm	2019-05-17 18:53:37.868000000 +0300
@@ -22,14 +22,23 @@
 }
 
 void IdentityManagerObserverBridge::OnPrimaryAccountSet(
-    const CoreAccountInfo& primary_account_info) {
+    const AccountInfo& primary_account_info) {
   if ([delegate_ respondsToSelector:@selector(onPrimaryAccountSet:)]) {
     [delegate_ onPrimaryAccountSet:primary_account_info];
   }
 }
 
+void IdentityManagerObserverBridge::OnPrimaryAccountSetWithPassword(
+    const AccountInfo& primary_account_info,
+    const std::string& password) {
+  if ([delegate_ respondsToSelector:@selector(onPrimaryAccountSet:
+                                                     withPassword:)]) {
+    [delegate_ onPrimaryAccountSet:primary_account_info withPassword:password];
+  }
+}
+
 void IdentityManagerObserverBridge::OnPrimaryAccountCleared(
-    const CoreAccountInfo& previous_primary_account_info) {
+    const AccountInfo& previous_primary_account_info) {
   if ([delegate_ respondsToSelector:@selector(onPrimaryAccountCleared:)]) {
     [delegate_ onPrimaryAccountCleared:previous_primary_account_info];
   }
@@ -43,7 +52,7 @@
 }
 
 void IdentityManagerObserverBridge::OnRefreshTokenUpdatedForAccount(
-    const CoreAccountInfo& account_info) {
+    const AccountInfo& account_info) {
   if ([delegate_
           respondsToSelector:@selector(onRefreshTokenUpdatedForAccount:)]) {
     [delegate_ onRefreshTokenUpdatedForAccount:account_info];
@@ -74,6 +83,13 @@
   }
 }
 
+void IdentityManagerObserverBridge::OnStartBatchOfRefreshTokenStateChanges() {
+  if ([delegate_ respondsToSelector:@selector
+                 (onStartBatchOfRefreshTokenStateChanges)]) {
+    [delegate_ onStartBatchOfRefreshTokenStateChanges];
+  }
+}
+
 void IdentityManagerObserverBridge::OnEndBatchOfRefreshTokenStateChanges() {
   if ([delegate_
           respondsToSelector:@selector(onEndBatchOfRefreshTokenStateChanges)]) {
--- a/services/identity/README.md	2019-05-01 01:22:56.000000000 +0300
+++ b/services/identity/README.md	2019-05-17 18:53:37.860000000 +0300
@@ -106,6 +106,19 @@
 been built. Contact blundell@chromium.org with your use case, which can help
 drive the bringup of this interface.
 
+## Obtaining the Information of All Accounts
+
+If you are currently calling AccountTracker::GetAccounts(),
+AccountTrackerService::GetAccounts(), or OAuth2TokenService::GetAccounts(), the
+corresponding interface in the Identity Service is
+IdentityManager::GetAccounts(). Note the semantics of this method carefully (as
+described in its documentation). In particular, this method returns only
+accounts that have a refresh token available, which is not necessarily the
+same behavior as AccountTracker::GetAccounts() or
+AccountTrackerService::GetAccounts() (but *is* the same behavior as
+OAuth2TokenService::GetAccounts()). If your use case is difficult to
+implement with the semantics of this method, contact blundell@chromium.org.
+
 ## Other Needs
 
 If you have any need that is not covered by the above guidance, contact
--- a/services/image_annotation/annotator.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/image_annotation/annotator.cc	2019-05-17 18:53:37.868000000 +0300
@@ -4,25 +4,14 @@
 
 #include "services/image_annotation/annotator.h"
 
-#include <algorithm>
-#include <tuple>
 #include <utility>
 
 #include "base/base64.h"
-#include "base/bind.h"
 #include "base/feature_list.h"
+#include "base/json/json_reader.h"
 #include "base/json/json_writer.h"
-#include "base/location.h"
-#include "base/logging.h"
-#include "base/no_destructor.h"
-#include "base/stl_util.h"
-#include "components/google/core/common/google_util.h"
 #include "net/base/load_flags.h"
-#include "net/base/net_errors.h"
 #include "net/traffic_annotation/network_traffic_annotation.h"
-#include "services/data_decoder/public/mojom/constants.mojom.h"
-#include "services/image_annotation/image_annotation_metrics.h"
-#include "services/service_manager/public/cpp/connector.h"
 #include "url/gurl.h"
 
 namespace image_annotation {
@@ -31,262 +20,150 @@
 
 constexpr size_t kMaxResponseSize = 1024 * 1024;  // 1MB.
 
-// The server returns separate OCR results for each region of the image; we
-// naively concatenate these into one response string.
-//
-// Returns a null pointer if there is any unexpected structure to the
-// annotations message.
-mojom::AnnotationPtr ParseJsonOcrAnnotation(const base::Value& ocr_engine,
-                                            const double min_ocr_confidence) {
-  if (!ocr_engine.is_dict())
-    return mojom::AnnotationPtr(nullptr);
-
-  // No OCR regions is valid - it just means there is no text.
-  const base::Value* const ocr_regions = ocr_engine.FindKey("ocrRegions");
-  if (!ocr_regions) {
-    ReportOcrAnnotation(1.0 /* confidence */, true /* empty */);
-    return mojom::Annotation::New(mojom::AnnotationType::kOcr, 1.0 /* score */,
-                                  std::string() /* text */);
-  }
-
-  if (!ocr_regions->is_list())
-    return mojom::AnnotationPtr(nullptr);
-
-  std::string all_ocr_text;
-  int word_count = 0;
-  double word_confidence_sum = 0.0;
-  for (const base::Value& ocr_region : ocr_regions->GetList()) {
-    if (!ocr_region.is_dict())
-      continue;
-
-    const base::Value* const words = ocr_region.FindKey("words");
-    if (!words || !words->is_list())
-      continue;
-
-    std::string region_ocr_text;
-    for (const base::Value& word : words->GetList()) {
-      if (!word.is_dict())
-        continue;
-
-      const base::Value* const detected_text = word.FindKey("detectedText");
-      if (!detected_text || !detected_text->is_string())
-        continue;
-
-      // A confidence value of 0 or 1 is interpreted as an int and not a double.
-      const base::Value* const confidence = word.FindKey("confidenceScore");
-      if (!confidence || (!confidence->is_double() && !confidence->is_int()) ||
-          confidence->GetDouble() < 0.0 || confidence->GetDouble() > 1.0)
-        continue;
-
-      if (confidence->GetDouble() < min_ocr_confidence)
-        continue;
+// The minimum confidence value needed to return an OCR result.
+// TODO(crbug.com/916420): tune this value.
+constexpr double kMinOcrConfidence = 0.7;
+
+// Constructs and returns a JSON string representing an OCR request for the
+// given image bytes.
+std::string FormatJsonOcrRequest(const std::string& source_id,
+                                 const std::vector<uint8_t>& image_bytes) {
+  // Re-encode image bytes into base64, which can be represented in JSON.
+  std::string base64_data;
+  Base64Encode(
+      base::StringPiece(reinterpret_cast<const char*>(image_bytes.data()),
+                        image_bytes.size()),
+      &base64_data);
 
-      const std::string& detected_text_str = detected_text->GetString();
+  base::Value image_request(base::Value::Type::DICTIONARY);
+  image_request.SetKey("image_id", base::Value(source_id));
+  image_request.SetKey("image_bytes", base::Value(std::move(base64_data)));
 
-      if (detected_text_str.empty())
-        continue;
+  // TODO(crbug.com/916420): batch multiple images into one request.
+  base::Value image_request_list(base::Value::Type::LIST);
+  image_request_list.GetList().push_back(std::move(image_request));
 
-      if (!region_ocr_text.empty())
-        region_ocr_text += " ";
+  // TODO(crbug.com/916420): accept and propagate page language info to improve
+  //                         OCR accuracy.
+  base::Value feature_request(base::Value::Type::DICTIONARY);
+  feature_request.SetKey("ocr_feature",
+                         base::Value(base::Value::Type::DICTIONARY));
 
-      region_ocr_text += detected_text_str;
-      ++word_count;
-      word_confidence_sum += confidence->GetDouble();
-    }
+  base::Value request(base::Value::Type::DICTIONARY);
+  request.SetKey("image_requests", base::Value(std::move(image_request_list)));
+  request.SetKey("feature_request", std::move(feature_request));
 
-    if (!all_ocr_text.empty() && !region_ocr_text.empty())
-      all_ocr_text += "\n";
-    all_ocr_text += region_ocr_text;
-  }
+  std::string json_request;
+  base::JSONWriter::Write(request, &json_request);
 
-  const double all_ocr_confidence =
-      word_count == 0 ? 1.0 : word_confidence_sum / word_count;
-  ReportOcrAnnotation(all_ocr_confidence, all_ocr_text.empty());
-  return mojom::Annotation::New(mojom::AnnotationType::kOcr, all_ocr_confidence,
-                                all_ocr_text);
+  return json_request;
 }
 
-// Extracts annotations from the given description engine result into the second
-// element of the return tuple.
-//
-// The first element of the return tuple will be true if the image was
-// classified as containing adult content.
-std::tuple<bool, std::vector<mojom::AnnotationPtr>> ParseJsonDescAnnotations(
-    const base::Value& desc_engine) {
-  static const base::NoDestructor<std::map<std::string, mojom::AnnotationType>>
-      kAnnotationTypes({{"OCR", mojom::AnnotationType::kOcr},
-                        {"CAPTION", mojom::AnnotationType::kCaption},
-                        {"LABEL", mojom::AnnotationType::kLabel}});
-
-  bool adult = false;
-  std::vector<mojom::AnnotationPtr> results;
-
-  if (!desc_engine.is_dict())
-    return {adult, std::move(results)};
-
-  // If there is a failure reason, log it and track whether it is due to adult
-  // content.
-  const base::Value* const failure_reason_value =
-      desc_engine.FindKey("failureReason");
-  if (failure_reason_value && failure_reason_value->is_string()) {
-    const DescFailureReason failure_reason =
-        ParseDescFailureReason(failure_reason_value->GetString());
-    ReportDescFailure(failure_reason);
-    adult = failure_reason == DescFailureReason::kAdult;
-  }
-
-  const base::Value* const desc_list_dict =
-      desc_engine.FindKey("descriptionList");
-  if (!desc_list_dict || !desc_list_dict->is_dict())
-    return {adult, std::move(results)};
-
-  const base::Value* const desc_list = desc_list_dict->FindKey("descriptions");
-  if (!desc_list || !desc_list->is_list())
-    return {adult, std::move(results)};
-
-  for (const base::Value& desc : desc_list->GetList()) {
-    if (!desc.is_dict())
-      continue;
-
-    const base::Value* const type = desc.FindKey("type");
-    if (!type || !type->is_string())
-      continue;
-
-    const auto type_lookup = kAnnotationTypes->find(type->GetString());
-    if (type_lookup == kAnnotationTypes->end())
-      continue;
+// Creates a URL loader that calls the image annotation server with an OCR
+// request for the given image bytes.
+std::unique_ptr<network::SimpleURLLoader> MakeOcrRequestLoader(
+    const GURL& server_url,
+    const std::string& source_id,
+    const std::vector<uint8_t>& image_bytes) {
+  auto resource_request = std::make_unique<network::ResourceRequest>();
+  resource_request->method = "POST";
 
-    const base::Value* const score = desc.FindKey("score");
-    if (!score || (!score->is_double() && !score->is_int()) ||
-        score->GetDouble() < 0.0 || score->GetDouble() > 1.0)
-      continue;
+  // TODO(crbug.com/916420): accept and pass API key when the server is
+  //                         configured to require it.
+  resource_request->url = server_url;
 
-    const base::Value* const text = desc.FindKey("text");
-    if (!text || !text->is_string() || text->GetString().empty())
-      continue;
+  resource_request->load_flags = net::LOAD_DO_NOT_SAVE_COOKIES |
+                                 net::LOAD_DO_NOT_SEND_COOKIES |
+                                 net::LOAD_DO_NOT_SEND_AUTH_DATA;
 
-    ReportDescAnnotation(type_lookup->second, score->GetDouble(),
-                         text->GetString().empty());
-    results.push_back(mojom::Annotation::New(
-        type_lookup->second, score->GetDouble(), text->GetString()));
+  // TODO(crbug.com/916420): update this annotation to be more general and to
+  //                         reflect specfics of the UI when it is implemented.
+  const net::NetworkTrafficAnnotationTag traffic_annotation =
+      net::DefineNetworkTrafficAnnotation("image_annotation", R"(
+        semantics {
+          sender: "Image Annotation"
+          description:
+            "Chrome can identify text inside images and provide this text to "
+            "screen readers (for visually-impaired users) by sending images to "
+            "Google's servers. If image text extraction is enabled for a page, "
+            "Chrome will send the URLs and pixels of all images on the "
+            "page to Google's servers, which will return any textual content "
+            "identified inside the images. This content is made accessible to "
+            "screen reading software."
+          trigger: "A page containing images is loaded for a user who has "
+                   "automatic image text extraction enabled."
+          data: "Image pixels and URLs. No user identifier is sent along with "
+                "the data."
+          destination: GOOGLE_OWNED_SERVICE
   }
+        policy {
+          cookies_allowed: NO
+          setting:
+            "You can enable or disable this feature via the context menu "
+            "for images, or via 'Image Labeling' in Chrome's settings under "
+            "Accessibility. This feature is disabled by default."
+          policy_exception_justification: "Policy to come; feature not yet "
+                                          "complete."
+        })");
 
-  return {adult, std::move(results)};
-}
+  auto url_loader = network::SimpleURLLoader::Create(
+      std::move(resource_request), traffic_annotation);
 
-// Returns the integer status code for this engine, or -1 if no status can be
-// extracted.
-int ExtractStatusCode(const base::Value* const status_dict) {
-  if (!status_dict || !status_dict->is_dict())
-    return -1;
-
-  const base::Value* const code_value = status_dict->FindKey("code");
-
-  // A missing code is the same as a default (i.e. OK) code.
-  if (!code_value)
-    return 0;
-
-  if (!code_value->is_int())
-    return -1;
-  const int code = code_value->GetInt();
-
-#ifndef NDEBUG
-  // Also log error status messages (which are helpful for debugging).
-  const base::Value* const message = status_dict->FindKey("message");
-  if (code != 0 && message && message->is_string())
-    DVLOG(1) << "Engine failed with status " << code << " and message '"
-             << message->GetString() << "'";
-#endif
+  url_loader->AttachStringForUpload(
+      FormatJsonOcrRequest(source_id, image_bytes), "application/json");
 
-  return code;
+  return url_loader;
 }
 
-// Attempts to extract annotation results from the server response, returning a
-// map from each source ID to its annotations (if successfully extracted).
-std::map<std::string, mojom::AnnotateImageResultPtr> UnpackJsonResponse(
-    const base::Value& json_data,
-    const double min_ocr_confidence) {
-  if (!json_data.is_dict())
-    return {};
-
-  const base::Value* const results = json_data.FindKey("results");
-  if (!results || !results->is_list())
-    return {};
-
-  std::map<std::string, mojom::AnnotateImageResultPtr> out;
-  for (const base::Value& result : results->GetList()) {
-    if (!result.is_dict())
-      continue;
+// Attempts to extract OCR results from the server response, returning true and
+// setting |out| to these results if successful.
+base::Optional<std::string> ParseJsonOcrResponse(
+    const std::string* const json_response) {
+  if (!json_response)
+    return base::nullopt;
+
+  const std::unique_ptr<base::Value> response =
+      base::JSONReader::Read(*json_response);
+  if (!response || !response->is_dict())
+    return base::nullopt;
+
+  const base::Value* const results = response->FindKey("results");
+  if (!results || !results->is_list() || results->GetList().size() != 1 ||
+      !results->GetList()[0].is_dict())
+    return base::nullopt;
+
+  const base::Value* const annotations =
+      results->GetList()[0].FindKey("annotations");
+  if (!annotations || !annotations->is_dict())
+    return base::nullopt;
+
+  const base::Value* const ocr_list = annotations->FindKey("ocr");
+  if (!ocr_list || !ocr_list->is_list())
+    return base::nullopt;
+
+  // The server returns separate OCR results for each region of the image; we
+  // naively concatenate these into one response string.
+  std::string out;
+  for (const base::Value& ocr : ocr_list->GetList()) {
+    if (!ocr.is_dict())
+      return base::nullopt;
 
-    const base::Value* const image_id = result.FindKey("imageId");
-    if (!image_id || !image_id->is_string())
-      continue;
+    const base::Value* const detected_text = ocr.FindKey("detected_text");
+    if (!detected_text || !detected_text->is_string())
+      return base::nullopt;
 
-    const base::Value* const engine_results = result.FindKey("engineResults");
-    if (!engine_results || !engine_results->is_list())
-      continue;
+    const base::Value* const confidence = ocr.FindKey("confidence_score");
+    if (!confidence || !confidence->is_double())
+      return base::nullopt;
 
-    // We expect the engine result list to have exactly two results: one for OCR
-    // and one for image descriptions. However, we "robustly" handle missing
-    // engines, unknown engines (by skipping them) and repetitions (by
-    // overwriting data).
-    bool adult = false;
-    std::vector<mojom::AnnotationPtr> annotations;
-    mojom::AnnotationPtr ocr_annotation;
-    for (const base::Value& engine_result : engine_results->GetList()) {
-      if (!engine_result.is_dict())
+    if (confidence->GetDouble() < kMinOcrConfidence)
         continue;
 
-      // A non-zero status code means the following:
-      //  -1:                       The status dict could not be parsed. We
-      //                            still try to parse an engine result in this
-      //                            case to be robust.
-      //  any other non-zero value: The status dict was parsed and contains a
-      //                            known failure. We always report an error
-      //                            in this case.
-      const int status_code =
-          ExtractStatusCode(engine_result.FindKey("status"));
-
-      const base::Value* const desc_engine =
-          engine_result.FindKey("descriptionEngine");
-      const base::Value* const ocr_engine = engine_result.FindKey("ocrEngine");
-
-      if (desc_engine) {
-        // Add description annotations and update the adult image flag.
-        ReportDescStatus(status_code);
-
-        if (status_code <= 0) {
-          std::tie(adult, annotations) = ParseJsonDescAnnotations(*desc_engine);
-        }
-      } else if (ocr_engine) {
-        // Update the specialized OCR annotations.
-        ReportOcrStatus(status_code);
-
-        if (status_code <= 0) {
-          ocr_annotation =
-              ParseJsonOcrAnnotation(*ocr_engine, min_ocr_confidence);
-        }
-      }
-
-      ReportEngineKnown(ocr_engine || desc_engine);
-    }
-
-    // Remove any description OCR data (which is lower quality) if we have
-    // specialized OCR results.
-    if (!ocr_annotation.is_null()) {
-      base::EraseIf(annotations, [](const mojom::AnnotationPtr& a) {
-        return a->type == mojom::AnnotationType::kOcr;
-      });
-      annotations.push_back(std::move(ocr_annotation));
-    }
+    const std::string& detected_text_str = detected_text->GetString();
 
-    if (adult) {
-      out[image_id->GetString()] = mojom::AnnotateImageResult::NewErrorCode(
-          mojom::AnnotateImageError::kAdult);
-    } else if (!annotations.empty()) {
-      out[image_id->GetString()] =
-          mojom::AnnotateImageResult::NewAnnotations(std::move(annotations));
-    }
+    if (!out.empty() && !detected_text_str.empty())
+      out += "\n";
+    out += detected_text_str;
   }
 
   return out;
@@ -294,39 +171,13 @@
 
 }  // namespace
 
-constexpr char Annotator::kGoogApiKeyHeader[];
-
 Annotator::Annotator(
     GURL server_url,
-    std::string api_key,
-    const base::TimeDelta throttle,
-    const int batch_size,
-    const double min_ocr_confidence,
-    scoped_refptr<network::SharedURLLoaderFactory> url_loader_factory,
-    service_manager::Connector* const connector)
+    scoped_refptr<network::SharedURLLoaderFactory> url_loader_factory)
     : url_loader_factory_(std::move(url_loader_factory)),
-      connector_(connector),
-      http_request_timer_(
-          FROM_HERE,
-          throttle,
-          base::BindRepeating(&Annotator::SendRequestBatchToServer,
-                              base::Unretained(this))),
-      server_url_(std::move(server_url)),
-      api_key_(std::move(api_key)),
-      batch_size_(batch_size),
-      min_ocr_confidence_(min_ocr_confidence) {
-  DCHECK(connector_);
-}
+      server_url_(std::move(server_url)) {}
 
-Annotator::~Annotator() {
-  // Report any clients still connected at service shutdown.
-  for (const auto& request_info_kv : request_infos_) {
-    for (const auto& unused : request_info_kv.second) {
-      ReportClientResult(ClientResult::kShutdown);
-      ANALYZER_ALLOW_UNUSED(unused);
-    }
-  }
-}
+Annotator::~Annotator() {}
 
 void Annotator::BindRequest(mojom::AnnotatorRequest request) {
   bindings_.AddBinding(this, std::move(request));
@@ -337,9 +188,9 @@
                               AnnotateImageCallback callback) {
   // Return cached results if they exist.
   const auto cache_lookup = cached_results_.find(source_id);
-  ReportCacheHit(cache_lookup != cached_results_.end());
   if (cache_lookup != cached_results_.end()) {
-    std::move(callback).Run(cache_lookup->second.Clone());
+    std::move(callback).Run(
+        mojom::AnnotateImageResult::NewOcrText(cache_lookup->second));
     return;
   }
 
@@ -353,12 +204,12 @@
   // processor was responsible for some ongoing work.
   request_info_list.back().first.set_connection_error_handler(base::BindOnce(
       &Annotator::RemoveRequestInfo, base::Unretained(this), source_id,
-      --request_info_list.end(), true /* canceled */));
+      --request_info_list.end(), mojom::AnnotateImageError::kCanceled));
 
   // Don't start local work if it would duplicate some ongoing or already-
   // completed work.
   if (base::ContainsKey(local_processors_, source_id) ||
-      base::ContainsKey(pending_source_ids_, source_id))
+      base::ContainsKey(url_loaders_, source_id))
     return;
 
   local_processors_.insert(
@@ -372,274 +223,68 @@
                      source_id, --request_info_list.end()));
 }
 
-// static
-std::string Annotator::FormatJsonRequest(
-    const HttpRequestQueue::iterator begin_it,
-    const HttpRequestQueue::iterator end_it) {
-  base::Value image_request_list(base::Value::Type::LIST);
-  for (HttpRequestQueue::iterator it = begin_it; it != end_it; ++it) {
-    // Re-encode image bytes into base64, which can be represented in JSON.
-    std::string base64_data;
-    Base64Encode(
-        base::StringPiece(reinterpret_cast<const char*>(it->second.data()),
-                          it->second.size()),
-        &base64_data);
-
-    // TODO(crbug.com/916420): accept and propagate page language info to
-    //                         improve OCR accuracy.
-    base::Value ocr_engine_params(base::Value::Type::DICTIONARY);
-    ocr_engine_params.SetKey("ocrParameters",
-                             base::Value(base::Value::Type::DICTIONARY));
-    base::Value desc_engine_params(base::Value::Type::DICTIONARY);
-    desc_engine_params.SetKey("descriptionParameters",
-                              base::Value(base::Value::Type::DICTIONARY));
-
-    base::Value engine_params_list(base::Value::Type::LIST);
-    engine_params_list.GetList().push_back(std::move(ocr_engine_params));
-    engine_params_list.GetList().push_back(std::move(desc_engine_params));
-
-    base::Value image_request(base::Value::Type::DICTIONARY);
-    image_request.SetKey("imageId", base::Value(it->first));
-    image_request.SetKey("imageBytes", base::Value(std::move(base64_data)));
-    image_request.SetKey("engineParameters", std::move(engine_params_list));
-
-    image_request_list.GetList().push_back(std::move(image_request));
-  }
-
-  base::Value request(base::Value::Type::DICTIONARY);
-  request.SetKey("imageRequests", std::move(image_request_list));
-
-  std::string json_request;
-  base::JSONWriter::Write(request, &json_request);
-
-  ReportServerRequestSizeKB(json_request.size() / 1024);
-
-  return json_request;
-}
-
-// static
-std::unique_ptr<network::SimpleURLLoader> Annotator::MakeRequestLoader(
-    const GURL& server_url,
-    const std::string& api_key,
-    const HttpRequestQueue::iterator begin_it,
-    const HttpRequestQueue::iterator end_it) {
-  auto resource_request = std::make_unique<network::ResourceRequest>();
-  resource_request->method = "POST";
-
-  // TODO(crbug.com/916420): accept and pass API key when the server is
-  //                         configured to require it.
-  resource_request->url = server_url;
-
-  resource_request->load_flags = net::LOAD_DO_NOT_SAVE_COOKIES |
-                                 net::LOAD_DO_NOT_SEND_COOKIES |
-                                 net::LOAD_DO_NOT_SEND_AUTH_DATA;
-
-  // Put API key in request's header if a key exists, and the endpoint is
-  // trusted by Google.
-  if (!api_key.empty() && server_url.SchemeIs(url::kHttpsScheme) &&
-      google_util::IsGoogleAssociatedDomainUrl(server_url)) {
-    resource_request->headers.SetHeader(kGoogApiKeyHeader, api_key);
-  }
-
-  // TODO(crbug.com/916420): update this annotation to be more general and to
-  //                         reflect specfics of the UI when it is implemented.
-  const net::NetworkTrafficAnnotationTag traffic_annotation =
-      net::DefineNetworkTrafficAnnotation("image_annotation", R"(
-        semantics {
-          sender: "Image Annotation"
-          description:
-            "Chrome can provide image labels (which include detected objects, "
-            "extracted text and generated captions) to screen readers (for "
-            "visually-impaired users) by sending images to Google's servers. "
-            "If image labeling is enabled for a page, Chrome will send the "
-            "URLs and pixels of all images on the page to Google's servers, "
-            "which will return labels for content identified inside the "
-            "images. This content is made accessible to screen reading "
-            "software."
-          trigger: "A page containing images is loaded for a user who has "
-                   "automatic image labeling enabled."
-          data: "Image pixels and URLs. No user identifier is sent along with "
-                "the data."
-          destination: GOOGLE_OWNED_SERVICE
-        }
-        policy {
-          cookies_allowed: NO
-          setting:
-            "You can enable or disable this feature via the context menu "
-            "for images, or via 'Image Labeling' in Chrome's settings under "
-            "Accessibility. This feature is disabled by default."
-          policy_exception_justification: "Policy to come; feature not yet "
-                                          "complete."
-        })");
-
-  auto url_loader = network::SimpleURLLoader::Create(
-      std::move(resource_request), traffic_annotation);
-
-  url_loader->AttachStringForUpload(FormatJsonRequest(begin_it, end_it),
-                                    "application/json");
-
-  return url_loader;
-}
-
 void Annotator::OnJpgImageDataReceived(
     const std::string& source_id,
     const RequestInfoList::iterator request_info_it,
     const std::vector<uint8_t>& image_bytes) {
-  ReportPixelFetchSuccess(!image_bytes.empty());
-
   // Failed to retrieve bytes from local processor; remove dead processor and
   // reschedule processing.
   if (image_bytes.empty()) {
-    RemoveRequestInfo(source_id, request_info_it, false /* canceled */);
+    RemoveRequestInfo(source_id, request_info_it,
+                      mojom::AnnotateImageError::kFailure);
     return;
   }
 
   // Local processing is no longer ongoing.
   local_processors_.erase(source_id);
 
-  // Schedule an HTTP request for this image.
-  http_request_queue_.push_front({source_id, image_bytes});
-  pending_source_ids_.insert(source_id);
-
-  // Start sending batches to the server.
-  if (!http_request_timer_.IsRunning())
-    http_request_timer_.Reset();
-}
-
-void Annotator::SendRequestBatchToServer() {
-  if (http_request_queue_.empty()) {
-    http_request_timer_.Stop();
-    return;
-  }
-
-  // Take last n elements (or all elements if there are less than n).
-  const auto begin_it =
-      http_request_queue_.end() -
-      std::min<size_t>(http_request_queue_.size(), batch_size_);
-  const auto end_it = http_request_queue_.end();
-
-  // The set of source IDs relevant for this request.
-  std::set<std::string> source_ids;
-  for (HttpRequestQueue::iterator it = begin_it; it != end_it; it++) {
-    source_ids.insert(it->first);
-  }
-
   // Kick off server communication.
-  http_requests_.push_back(
-      MakeRequestLoader(server_url_, api_key_, begin_it, end_it));
-  http_requests_.back()->DownloadToString(
+  // TODO(crbug.com/916420): add request to a queue here and batch them up
+  //                         to limit number of concurrent HTTP requests made.
+  std::unique_ptr<network::SimpleURLLoader> url_loader =
+      MakeOcrRequestLoader(server_url_, source_id, image_bytes);
+  const auto url_loader_it =
+      url_loaders_.insert({source_id, std::move(url_loader)}).first;
+  url_loader_it->second->DownloadToString(
       url_loader_factory_.get(),
       base::BindOnce(&Annotator::OnServerResponseReceived,
-                     base::Unretained(this), source_ids,
-                     --http_requests_.end()),
+                     base::Unretained(this), source_id, url_loader_it),
       kMaxResponseSize);
-
-  http_request_queue_.erase(begin_it, end_it);
 }
 
 void Annotator::OnServerResponseReceived(
-    const std::set<std::string>& source_ids,
-    const UrlLoaderList::iterator http_request_it,
+    const std::string& source_id,
+    const URLLoaderMap::iterator url_loader_it,
     const std::unique_ptr<std::string> json_response) {
-  ReportServerNetError(http_request_it->get()->NetError());
-
-  if (const network::ResourceResponseInfo* const response_info =
-          http_request_it->get()->ResponseInfo()) {
-    ReportServerResponseCode(response_info->headers->response_code());
-    ReportServerLatency(response_info->response_time -
-                        response_info->request_time);
-  }
-
-  http_requests_.erase(http_request_it);
-
-  if (!json_response) {
-    DVLOG(1) << "HTTP request to image annotation server failed.";
-    ProcessResults(source_ids, {});
-    return;
-  }
-
-  ReportServerResponseSizeBytes(json_response->size());
-
-  // Send JSON string to a dedicated service for safe parsing.
-  GetJsonParser().Parse(*json_response,
-                        base::BindOnce(&Annotator::OnResponseJsonParsed,
-                                       base::Unretained(this), source_ids));
-}
+  url_loaders_.erase(url_loader_it);
 
-void Annotator::OnResponseJsonParsed(
-    const std::set<std::string>& source_ids,
-    const base::Optional<base::Value> json_data,
-    const base::Optional<std::string>& error) {
-  const bool success = json_data.has_value() && !error.has_value();
-  ReportJsonParseSuccess(success);
-
-  // Extract annotation results for each source ID with valid results.
-  if (success) {
-    ProcessResults(source_ids,
-                   UnpackJsonResponse(*json_data, min_ocr_confidence_));
-  } else {
-    DVLOG(1) << "Parsing server response JSON failed with error: "
-             << error.value_or("No reason reported.");
-    ProcessResults(source_ids, {});
-  }
-}
+  // Extract OCR results into a string.
+  const base::Optional<std::string> ocr_text =
+      ParseJsonOcrResponse(json_response.get());
 
-void Annotator::ProcessResults(
-    const std::set<std::string>& source_ids,
-    const std::map<std::string, mojom::AnnotateImageResultPtr>& results) {
-  // Process each source ID for which we expect to have results.
-  for (const std::string& source_id : source_ids) {
-    pending_source_ids_.erase(source_id);
-
-    // The lookup will be successful if there is a valid result (i.e. not an
-    // error and not a malformed result) for this source ID.
-    const auto result_lookup = results.find(source_id);
-
-    // Populate the result struct for this image and copy it into the cache if
-    // necessary.
-    if (result_lookup != results.end())
-      cached_results_.insert({source_id, result_lookup->second.Clone()});
+  if (ocr_text.has_value())
+    cached_results_.insert({source_id, *ocr_text});
 
-    // This should not happen, since only this method removes entries of
-    // |request_infos_|, and this method should only execute once per source ID.
     const auto request_info_it = request_infos_.find(source_id);
     if (request_info_it == request_infos_.end())
-      continue;
-
-    const auto image_result = result_lookup != results.end()
-                                  ? result_lookup->second.Clone()
-                                  : mojom::AnnotateImageResult::NewErrorCode(
-                                        mojom::AnnotateImageError::kFailure);
-    const auto client_result = result_lookup != results.end()
-                                   ? ClientResult::kSucceeded
-                                   : ClientResult::kFailed;
+    return;
 
     // Notify clients of success or failure.
     // TODO(crbug.com/916420): explore server retry strategies.
     for (auto& info : request_info_it->second) {
-      std::move(info.second).Run(image_result.Clone());
-      ReportClientResult(client_result);
+    auto result = ocr_text.has_value()
+                      ? mojom::AnnotateImageResult::NewOcrText(*ocr_text)
+                      : mojom::AnnotateImageResult::NewErrorCode(
+                            mojom::AnnotateImageError::kFailure);
+    std::move(info.second).Run(std::move(result));
     }
     request_infos_.erase(request_info_it);
-  }
-}
-
-data_decoder::mojom::JsonParser& Annotator::GetJsonParser() {
-  if (!json_parser_) {
-    connector_->BindInterface(data_decoder::mojom::kServiceName,
-                              mojo::MakeRequest(&json_parser_));
-    json_parser_.set_connection_error_handler(base::BindOnce(
-        [](Annotator* const annotator) { annotator->json_parser_.reset(); },
-        base::Unretained(this)));
-  }
-
-  return *json_parser_;
 }
 
 void Annotator::RemoveRequestInfo(
     const std::string& source_id,
     const RequestInfoList::iterator request_info_it,
-    const bool canceled) {
+    const mojom::AnnotateImageError error) {
   // Check whether we are deleting the ImageProcessor responsible for current
   // local processing.
   auto lookup = local_processors_.find(source_id);
@@ -647,12 +292,8 @@
                                lookup->second == &request_info_it->first;
 
   // Notify client of cancellation / failure.
-  ReportClientResult(canceled ? ClientResult::kCanceled
-                              : ClientResult::kFailed);
   std::move(request_info_it->second)
-      .Run(mojom::AnnotateImageResult::NewErrorCode(
-          canceled ? mojom::AnnotateImageError::kCanceled
-                   : mojom::AnnotateImageError::kFailure));
+      .Run(mojom::AnnotateImageResult::NewErrorCode(error));
 
   // Delete the specified ImageProcessor.
   RequestInfoList& request_info_list = request_infos_[source_id];
--- a/services/image_annotation/annotator.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/image_annotation/annotator.h	2019-05-17 18:53:37.868000000 +0300
@@ -5,29 +5,18 @@
 #ifndef SERVICES_IMAGE_ANNOTATION_ANNOTATOR_H_
 #define SERVICES_IMAGE_ANNOTATION_ANNOTATOR_H_
 
-#include <deque>
 #include <list>
 #include <map>
 #include <memory>
-#include <set>
-#include <string>
-#include <utility>
 
 #include "base/macros.h"
 #include "base/memory/scoped_refptr.h"
-#include "base/time/time.h"
-#include "base/timer/timer.h"
 #include "mojo/public/cpp/bindings/binding_set.h"
-#include "services/data_decoder/public/mojom/json_parser.mojom.h"
 #include "services/image_annotation/public/mojom/image_annotation.mojom.h"
 #include "services/network/public/cpp/shared_url_loader_factory.h"
 #include "services/network/public/cpp/simple_url_loader.h"
 #include "url/gurl.h"
 
-namespace service_manager {
-class Connector;
-}  // namespace service_manager
-
 namespace image_annotation {
 
 // The annotator communicates with the external image annotation server to
@@ -43,31 +32,8 @@
 // images) or image pixels to the external server.
 class Annotator : public mojom::Annotator {
  public:
-  // The HTTP request header in which the API key should be transmitted.
-  static constexpr char kGoogApiKeyHeader[] = "X-Goog-Api-Key";
-
-  // Constructs an annotator.
-  //  |server_url|        : the URL of the server with which the annotator
-  //                        communicates. The annotator gracefully handles (i.e.
-  //                        returns errors when constructed with) an empty
-  //                        server URL.
-  //  |api_key|           : the Google API key used to authenticate
-  //                        communication with the image annotation server. If
-  //                        empty, no API key header will be sent.
-  //  |throttle|          : the miminum amount of time to wait between sending
-  //                        new HTTP requests to the image annotation server.
-  //  |batch_size|        : The maximum number of image annotation requests that
-  //                        should be batched into a single request to the
-  //                        server.
-  //  |min_ocr_confidence|: The minimum confidence value needed to return an OCR
-  //                        result.
   Annotator(GURL server_url,
-            std::string api_key,
-            base::TimeDelta throttle,
-            int batch_size,
-            double min_ocr_confidence,
-            scoped_refptr<network::SharedURLLoaderFactory> url_loader_factory,
-            service_manager::Connector* connector);
+            scoped_refptr<network::SharedURLLoaderFactory> url_loader_factory);
   ~Annotator() override;
 
   // Start providing behavior for the given Mojo request.
@@ -86,36 +52,15 @@
   using RequestInfoList =
       std::list<std::pair<mojom::ImageProcessorPtr, AnnotateImageCallback>>;
 
-  // List of URL loader objects.
-  using UrlLoaderList = std::list<std::unique_ptr<network::SimpleURLLoader>>;
-
-  // A queue of the data needed to make HTTP requests to the image annotation
-  // server. Each entry is a (source ID, image bytes) pair.
-  using HttpRequestQueue =
-      std::deque<std::pair<std::string, std::vector<uint8_t>>>;
-
-  // Constructs and returns a JSON object containing an request for the
-  // given images.
-  static std::string FormatJsonRequest(HttpRequestQueue::iterator begin_it,
-                                       HttpRequestQueue::iterator end_it);
-
-  // Creates a URL loader that calls the image annotation server with an
-  // annotation request for the given images.
-  static std::unique_ptr<network::SimpleURLLoader> MakeRequestLoader(
-      const GURL& server_url,
-      const std::string& api_key,
-      HttpRequestQueue::iterator begin_it,
-      HttpRequestQueue::iterator end_it);
-
-  // Create or reuse a connection to the data decoder service for safe JSON
-  // parsing.
-  data_decoder::mojom::JsonParser& GetJsonParser();
+  // A map from source ID to URL loader.
+  using URLLoaderMap =
+      std::map<std::string, std::unique_ptr<network::SimpleURLLoader>>;
 
   // Removes the given request, reassigning local processing if its associated
   // image processor had some ongoing.
   void RemoveRequestInfo(const std::string& source_id,
                          RequestInfoList::iterator request_info_it,
-                         bool canceled);
+                         mojom::AnnotateImageError error);
 
   // Called when a local handler returns compressed image data for the given
   // source ID.
@@ -123,30 +68,15 @@
                               RequestInfoList::iterator request_info_it,
                               const std::vector<uint8_t>& image_bytes);
 
-  // Called periodically to send the next batch of requests to the image
-  // annotation server.
-  void SendRequestBatchToServer();
-
   // Called when the image annotation server responds with annotations for the
-  // given source IDs.
-  void OnServerResponseReceived(const std::set<std::string>& source_ids,
-                                UrlLoaderList::iterator http_request_it,
+  // given source ID.
+  void OnServerResponseReceived(const std::string& source_id,
+                                URLLoaderMap::iterator url_loader_it,
                                 std::unique_ptr<std::string> json_response);
 
-  // Called when the data decoder service provides parsed JSON data for a server
-  // response.
-  void OnResponseJsonParsed(const std::set<std::string>& source_ids,
-                            base::Optional<base::Value> json_data,
-                            const base::Optional<std::string>& error);
-
-  // Adds the given results to the cache (if successful) and notifies clients.
-  void ProcessResults(
-      const std::set<std::string>& source_ids,
-      const std::map<std::string, mojom::AnnotateImageResultPtr>& results);
-
-  // Maps from source ID to previously-obtained annotation results.
+  // Maps from source ID to previously-obtained OCR result.
   // TODO(crbug.com/916420): periodically clear entries from this cache.
-  std::map<std::string, mojom::AnnotateImageResultPtr> cached_results_;
+  std::map<std::string, std::string> cached_results_;
 
   // Maps from source ID to the list of request info (i.e. info of clients that
   // have made requests) for that source.
@@ -159,36 +89,16 @@
   // given source.
   std::map<std::string, mojom::ImageProcessorPtr*> local_processors_;
 
-  // A list of currently-ongoing HTTP requests to the image annotation server.
-  UrlLoaderList http_requests_;
-
-  // A queue of HTTP requests waiting to be made.
-  HttpRequestQueue http_request_queue_;
-
-  // The set of source IDs for which an HTTP request is either queued or
-  // currently ongoing.
-  std::set<std::string> pending_source_ids_;
+  // A map from source ID to the currently-ongoing HTTP request to the image
+  // annotation server (if any) for that source.
+  URLLoaderMap url_loaders_;
 
   scoped_refptr<network::SharedURLLoaderFactory> url_loader_factory_;
 
-  service_manager::Connector* const connector_;
-
   mojo::BindingSet<mojom::Annotator> bindings_;
 
-  // Should not be used directly; GetJsonParser() should be called instead.
-  data_decoder::mojom::JsonParserPtr json_parser_;
-
-  // A timer used to throttle HTTP request frequency.
-  base::RepeatingTimer http_request_timer_;
-
   const GURL server_url_;
 
-  const std::string api_key_;
-
-  const int batch_size_;
-
-  const double min_ocr_confidence_;
-
   DISALLOW_COPY_AND_ASSIGN(Annotator);
 };
 
--- a/services/image_annotation/annotator_unittest.cc	2019-05-17 17:45:42.524000000 +0300
+++ b/services/image_annotation/annotator_unittest.cc	2019-05-17 18:53:37.868000000 +0300
@@ -4,30 +4,18 @@
 
 #include "services/image_annotation/annotator.h"
 
-#include <cstring>
-
 #include "base/bind.h"
-#include "base/bind_helpers.h"
 #include "base/json/json_reader.h"
 #include "base/json/json_writer.h"
 #include "base/optional.h"
 #include "base/strings/stringprintf.h"
-#include "base/test/metrics/histogram_tester.h"
 #include "base/test/scoped_task_environment.h"
-#include "base/time/time.h"
 #include "mojo/public/cpp/bindings/binding_set.h"
-#include "net/base/net_errors.h"
 #include "net/http/http_status_code.h"
-#include "services/data_decoder/public/cpp/test_data_decoder_service.h"
-#include "services/data_decoder/public/mojom/constants.mojom.h"
-#include "services/data_decoder/public/mojom/json_parser.mojom.h"
-#include "services/image_annotation/image_annotation_metrics.h"
 #include "services/image_annotation/public/mojom/image_annotation.mojom.h"
 #include "services/network/public/cpp/weak_wrapper_shared_url_loader_factory.h"
 #include "services/network/public/mojom/url_loader.mojom-shared.h"
 #include "services/network/test/test_url_loader_factory.h"
-#include "services/service_manager/public/cpp/connector.h"
-#include "services/service_manager/public/mojom/service.mojom.h"
 #include "testing/gmock/include/gmock/gmock.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
@@ -35,181 +23,65 @@
 
 namespace {
 
-using base::Bucket;
 using testing::ElementsAre;
 using testing::Eq;
 using testing::IsEmpty;
 using testing::SizeIs;
-using testing::UnorderedElementsAre;
-
-constexpr char kTestServerUrl[] = "https://ia-pa.9oo91eapis.qjz9zk/v1/annotation";
 
-// Example image URLs.
-
-constexpr char kImage1Url[] = "https://www.example.com/image1.jpg";
-constexpr char kImage2Url[] = "https://www.example.com/image2.jpg";
-constexpr char kImage3Url[] = "https://www.example.com/image3.jpg";
+constexpr char kTestServerUrl[] = "https://test_ia_server.com/v1:ocr";
 
 // Example server requests / responses.
 
-// Template for a request for a single image.
-constexpr char kTemplateRequest[] = R"(
-{
-  "imageRequests": [{
-    "imageId": "%s",
-    "imageBytes": "%s",
-    "engineParameters": [
-      {"ocrParameters": {}},
-      {"descriptionParameters": {}}
-    ]
-  }]
-}
-)";
-
-// Batch request for |kImage1Url|, |kImage2Url| and |kImage3Url|.
-constexpr char kBatchRequest[] = R"(
+constexpr char kRequestTemplate[] = R"(
 {
-  "imageRequests": [
-    {
-      "imageId": "https://www.example.com/image3.jpg",
-      "imageBytes": "BwgJ",
-      "engineParameters": [
-        {"ocrParameters": {}},
-        {"descriptionParameters": {}}
-      ]
-    },
+  "image_requests": [
     {
-      "imageId": "https://www.example.com/image2.jpg",
-      "imageBytes": "BAUG",
-      "engineParameters": [
-        {"ocrParameters": {}},
-        {"descriptionParameters": {}}
-      ]
-    },
-    {
-      "imageId": "https://www.example.com/image1.jpg",
-      "imageBytes": "AQID",
-      "engineParameters": [
-        {"ocrParameters": {}},
-        {"descriptionParameters": {}}
-      ]
+      "image_id": "%s",
+      "image_bytes": "%s"
     }
-  ]
-})";
+  ],
 
-// Successful text extraction for |kImage1Url|.
-constexpr char kSuccessResponse[] = R"(
-{
-  "results": [
-    {
-      "imageId": "https://www.example.com/image1.jpg",
-      "engineResults": [{
-        "status": {},
-        "ocrEngine": {
-          "ocrRegions": [
-            {
-              "words": [
-                 {
-                   "detectedText": "Region",
-                   "confidenceScore": 1.0
-                 },
-                 {
-                   "detectedText": "1",
-                   "confidenceScore": 1.0
+  "feature_request": {
+    "ocr_feature": {}
                  }
-              ]
-            },
-            {
-              "words": [
+}
+)";
+
+constexpr char kSuccessResponseTemplate[] = R"(
                  {
-                   "detectedText": "Region",
-                   "confidenceScore": 1.0
-                 },
+    "results": [
                  {
-                   "detectedText": "2",
-                   "confidenceScore": 1.0
+        "image_id": "%s",
+        "annotations": {
+          "ocr": [%s]
                  }
-              ]
             }
           ]
         }
-      }]
-    }
-  ]
-}
 )";
 
-// Failed text extraction for |kImage1Url|.
-constexpr char kErrorResponse[] = R"(
-{
-  "results": [{
-    "imageId": "https://www.example.com/image1.jpg",
-    "engineResults": [{
-      "status": {
-        "code": 8,
-        "message": "Resource exhaused"
-      },
-      "ocrEngine": {}
-    }]
-  }]
-}
-)";
-
-// Batch response containing successful annotations for |kImage1Url| and
-// |kImage2Url|, and a failure for |kImage3Url|.
-//
-// The results also appear "out of order" (i.e. image 2 comes before image 1).
-constexpr char kBatchResponse[] = R"(
-{
-  "results": [
+constexpr char kErrorResponseTemplate[] = R"(
     {
-      "imageId": "https://www.example.com/image2.jpg",
-      "engineResults": [{
-        "status": {},
-        "ocrEngine": {
-          "ocrRegions": [{
-            "words": [{
-              "detectedText": "2",
-              "confidenceScore": 1.0
-            }]
-          }]
-        }
-      }]
-    },
-    {
-      "imageId": "https://www.example.com/image1.jpg",
-      "engineResults": [{
-        "status": {},
-        "ocrEngine": {
-          "ocrRegions": [{
-            "words": [{
-              "detectedText": "1",
-              "confidenceScore": 1.0
-            }]
-          }]
-        }
-      }]
-    },
+    "results": [
     {
-      "imageId": "https://www.example.com/image3.jpg",
-      "engineResults": [{
+        "image_id": "%s",
         "status": {
           "code": 8,
           "message": "Resource exhaused"
-        },
-        "ocrEngine": {}
-      }]
+        }
     }
   ]
-})";
+  }
+)";
 
-constexpr base::TimeDelta kThrottle = base::TimeDelta::FromSeconds(1);
+// Example image URLs.
+
+constexpr char kImage1Url[] = "https://www.example.com/image1.jpg";
+constexpr char kImage2Url[] = "https://www.example.com/image2.jpg";
 
 // An image processor that holds and exposes the callbacks it is passed.
 class TestImageProcessor : public mojom::ImageProcessor {
  public:
-  TestImageProcessor() = default;
-
   mojom::ImageProcessorPtr GetPtr() {
     mojom::ImageProcessorPtr ptr;
     bindings_.AddBinding(this, mojo::MakeRequest(&ptr));
@@ -231,8 +103,6 @@
   std::vector<GetJpgImageDataCallback> callbacks_;
 
   mojo::BindingSet<mojom::ImageProcessor> bindings_;
-
-  DISALLOW_COPY_AND_ASSIGN(TestImageProcessor);
 };
 
 // A class that supports test URL loading for the "server" use case: where
@@ -246,24 +116,13 @@
             base::MakeRefCounted<network::WeakWrapperSharedURLLoaderFactory>(
                 &loader_factory_)) {}
 
-  const std::vector<network::TestURLLoaderFactory::PendingRequest>& requests() {
-    return *loader_factory_.pending_requests();
-  }
-
-  // Expects that the earliest received request has the given URL, headers and
-  // body, and replies with the given response.
-  //
-  // |expected_headers| is a map from header key string to either:
-  //   a) a null optional, if the given header should not be present, or
-  //   b) a non-null optional, if the given header should be present and match
-  //      the optional value.
+  // Expects that the earliest received request has the given URL and body, and
+  // replies with the given response.
   //
   // Consumes the earliest received request (i.e. a subsequent call will apply
   // to the second-earliest received request and so on).
   void ExpectRequestAndSimulateResponse(
       const std::string& expected_url_suffix,
-      const std::map<std::string, base::Optional<std::string>>&
-          expected_headers,
       const std::string& expected_body,
       const std::string& response,
       const net::HttpStatusCode response_code) {
@@ -278,18 +137,6 @@
     // Assert that the earliest request is for the given URL.
     CHECK_EQ(request.url, GURL(expected_url));
 
-    // Expect that specified headers are accurate.
-    for (const auto& kv : expected_headers) {
-      if (kv.second.has_value()) {
-        std::string actual_value;
-        EXPECT_THAT(request.headers.GetHeader(kv.first, &actual_value),
-                    Eq(true));
-        EXPECT_THAT(actual_value, Eq(*kv.second));
-      } else {
-        EXPECT_THAT(request.headers.HasHeader(kv.first), Eq(false));
-      }
-    }
-
     // Extract request body.
     std::string actual_body;
     if (request.request_body) {
@@ -319,15 +166,12 @@
   const std::string server_url_prefix_;
   network::TestURLLoaderFactory loader_factory_;
   scoped_refptr<network::SharedURLLoaderFactory> shared_loader_factory_;
-
-  DISALLOW_COPY_AND_ASSIGN(TestServerURLLoaderFactory);
 };
 
 // Returns a "canonically" formatted version of a JSON string by parsing and
 // then rewriting it.
 std::string ReformatJson(const std::string& in) {
-  const std::unique_ptr<base::Value> json =
-      base::JSONReader::ReadDeprecated(in);
+  const std::unique_ptr<base::Value> json = base::JSONReader::Read(in);
   CHECK(json);
 
   std::string out;
@@ -344,27 +188,19 @@
   if (result->which() == mojom::AnnotateImageResult::Tag::ERROR_CODE) {
     *error = result->get_error_code();
   } else {
-    CHECK_EQ(result->get_annotations().size(), 1u);
-    CHECK_EQ(result->get_annotations()[0]->type, mojom::AnnotationType::kOcr);
-    *ocr_text = std::move(result->get_annotations()[0]->text);
+    *ocr_text = std::move(result->get_ocr_text());
   }
 }
 
 }  // namespace
 
-// Test that annotation works for one client, and that the cache is populated.
+// Test that OCR works for one client, and that the cache is populated.
 TEST(AnnotatorTest, SuccessAndCache) {
-  base::test::ScopedTaskEnvironment test_task_env(
-      base::test::ScopedTaskEnvironment::MainThreadType::MOCK_TIME);
-  TestServerURLLoaderFactory test_url_factory(
-      "https://ia-pa.9oo91eapis.qjz9zk/v1/");
-  data_decoder::TestDataDecoderService test_dd_service;
-  base::HistogramTester histogram_tester;
-
-  Annotator annotator(
-      GURL(kTestServerUrl), std::string() /* api_key */, kThrottle,
-      1 /* batch_size */, 1.0 /* min_ocr_confidence */,
-      test_url_factory.AsSharedURLLoaderFactory(), test_dd_service.connector());
+  base::test::ScopedTaskEnvironment test_task_env;
+  TestServerURLLoaderFactory test_url_factory("https://test_ia_server.com/v1:");
+
+  Annotator annotator(GURL(kTestServerUrl),
+                      test_url_factory.AsSharedURLLoaderFactory());
   TestImageProcessor processor;
 
   // First call performs original image annotation.
@@ -384,47 +220,25 @@
     processor.callbacks().pop_back();
     test_task_env.RunUntilIdle();
 
-    // No request should be sent yet (because service is waiting to batch up
-    // multiple requests).
-    EXPECT_THAT(test_url_factory.requests(), IsEmpty());
-    test_task_env.FastForwardBy(base::TimeDelta::FromSeconds(1));
-    test_task_env.RunUntilIdle();
-
     // HTTP request should have been made.
-    const std::string request =
-        ReformatJson(base::StringPrintf(kTemplateRequest, kImage1Url, "AQID"));
     test_url_factory.ExpectRequestAndSimulateResponse(
-        "annotation", {} /* expected_headers */, request, kSuccessResponse,
+        "ocr",
+        ReformatJson(base::StringPrintf(kRequestTemplate, kImage1Url, "AQID")),
+        base::StringPrintf(kSuccessResponseTemplate, kImage1Url,
+                           R"({
+                                "detected_text": "Text 1",
+                                "confidence_score": 1.0
+                              },
+                              {
+                                "detected_text": "Text 2",
+                                "confidence_score": 1.0
+                              })"),
         net::HTTP_OK);
     test_task_env.RunUntilIdle();
 
     // HTTP response should have completed and callback should have been called.
     ASSERT_THAT(error, Eq(base::nullopt));
-    EXPECT_THAT(ocr_text, Eq("Region 1\nRegion 2"));
-
-    // Metrics should have been logged for the major actions of the service.
-    histogram_tester.ExpectUniqueSample(metrics_internal::kCacheHit, false, 1);
-    histogram_tester.ExpectUniqueSample(metrics_internal::kPixelFetchSuccess,
-                                        true, 1);
-    histogram_tester.ExpectUniqueSample(metrics_internal::kPixelFetchSuccess,
-                                        true, 1);
-    histogram_tester.ExpectUniqueSample(metrics_internal::kServerRequestSize,
-                                        request.size() / 1024, 1);
-    histogram_tester.ExpectUniqueSample(metrics_internal::kServerNetError,
-                                        net::Error::OK, 1);
-    histogram_tester.ExpectUniqueSample(
-        metrics_internal::kServerHttpResponseCode, net::HTTP_OK, 1);
-    histogram_tester.ExpectUniqueSample(metrics_internal::kServerResponseSize,
-                                        std::strlen(kSuccessResponse), 1);
-    histogram_tester.ExpectUniqueSample(
-        base::StringPrintf(metrics_internal::kAnnotationStatus, "Ocr"),
-        0 /* OK RPC status */, 1);
-    histogram_tester.ExpectUniqueSample(
-        base::StringPrintf(metrics_internal::kAnnotationConfidence, "Ocr"), 100,
-        1);
-    histogram_tester.ExpectUniqueSample(
-        base::StringPrintf(metrics_internal::kAnnotationEmpty, "Ocr"), false,
-        1);
+    EXPECT_THAT(ocr_text, Eq("Text 1\nText 2"));
   }
 
   // Second call uses cached results.
@@ -441,27 +255,17 @@
 
     // Results should have been directly returned without any server call.
     ASSERT_THAT(error, Eq(base::nullopt));
-    EXPECT_THAT(ocr_text, Eq("Region 1\nRegion 2"));
-
-    // Metrics should have been logged for a cache hit.
-    EXPECT_THAT(histogram_tester.GetAllSamples(metrics_internal::kCacheHit),
-                UnorderedElementsAre(Bucket(false, 1), Bucket(true, 1)));
+    EXPECT_THAT(ocr_text, Eq("Text 1\nText 2"));
   }
 }
 
 // Test that HTTP failure is gracefully handled.
 TEST(AnnotatorTest, HttpError) {
-  base::test::ScopedTaskEnvironment test_task_env(
-      base::test::ScopedTaskEnvironment::MainThreadType::MOCK_TIME);
-  TestServerURLLoaderFactory test_url_factory(
-      "https://ia-pa.9oo91eapis.qjz9zk/v1/");
-  data_decoder::TestDataDecoderService test_dd_service;
-  base::HistogramTester histogram_tester;
-
-  Annotator annotator(
-      GURL(kTestServerUrl), std::string() /* api_key */, kThrottle,
-      1 /* batch_size */, 1.0 /* min_ocr_confidence */,
-      test_url_factory.AsSharedURLLoaderFactory(), test_dd_service.connector());
+  base::test::ScopedTaskEnvironment test_task_env;
+  TestServerURLLoaderFactory test_url_factory("https://test_ia_server.com/v1:");
+
+  Annotator annotator(GURL(kTestServerUrl),
+                      test_url_factory.AsSharedURLLoaderFactory());
 
   TestImageProcessor processor;
   base::Optional<mojom::AnnotateImageError> error;
@@ -479,44 +283,25 @@
   processor.callbacks().pop_back();
   test_task_env.RunUntilIdle();
 
-  // No request should be sent yet (because service is waiting to batch up
-  // multiple requests).
-  EXPECT_THAT(test_url_factory.requests(), IsEmpty());
-  test_task_env.FastForwardBy(base::TimeDelta::FromSeconds(1));
-
   // HTTP request should have been made.
   test_url_factory.ExpectRequestAndSimulateResponse(
-      "annotation", {} /* expected_headers */,
-      ReformatJson(base::StringPrintf(kTemplateRequest, kImage1Url, "AQID")),
+      "ocr",
+      ReformatJson(base::StringPrintf(kRequestTemplate, kImage1Url, "AQID")),
       "", net::HTTP_INTERNAL_SERVER_ERROR);
   test_task_env.RunUntilIdle();
 
   // HTTP response should have completed and callback should have been called.
   EXPECT_THAT(error, Eq(mojom::AnnotateImageError::kFailure));
   EXPECT_THAT(ocr_text, Eq(base::nullopt));
-
-  // Metrics about the HTTP request failure should have been logged.
-  histogram_tester.ExpectUniqueSample(metrics_internal::kServerNetError,
-                                      net::Error::ERR_FAILED, 1);
-  histogram_tester.ExpectUniqueSample(metrics_internal::kServerHttpResponseCode,
-                                      net::HTTP_INTERNAL_SERVER_ERROR, 1);
-  histogram_tester.ExpectUniqueSample(metrics_internal::kClientResult,
-                                      ClientResult::kFailed, 1);
 }
 
 // Test that backend failure is gracefully handled.
 TEST(AnnotatorTest, BackendError) {
-  base::test::ScopedTaskEnvironment test_task_env(
-      base::test::ScopedTaskEnvironment::MainThreadType::MOCK_TIME);
-  TestServerURLLoaderFactory test_url_factory(
-      "https://ia-pa.9oo91eapis.qjz9zk/v1/");
-  data_decoder::TestDataDecoderService test_dd_service;
-  base::HistogramTester histogram_tester;
-
-  Annotator annotator(
-      GURL(kTestServerUrl), std::string() /* api_key */, kThrottle,
-      1 /* batch_size */, 1.0 /* min_ocr_confidence */,
-      test_url_factory.AsSharedURLLoaderFactory(), test_dd_service.connector());
+  base::test::ScopedTaskEnvironment test_task_env;
+  TestServerURLLoaderFactory test_url_factory("https://test_ia_server.com/v1:");
+
+  Annotator annotator(GURL(kTestServerUrl),
+                      test_url_factory.AsSharedURLLoaderFactory());
 
   TestImageProcessor processor;
   base::Optional<mojom::AnnotateImageError> error;
@@ -534,48 +319,26 @@
   processor.callbacks().pop_back();
   test_task_env.RunUntilIdle();
 
-  // No request should be sent yet (because service is waiting to batch up
-  // multiple requests).
-  EXPECT_THAT(test_url_factory.requests(), IsEmpty());
-  test_task_env.FastForwardBy(base::TimeDelta::FromSeconds(1));
-
   // HTTP request should have been made.
   test_url_factory.ExpectRequestAndSimulateResponse(
-      "annotation", {} /* expected_headers */,
-      ReformatJson(base::StringPrintf(kTemplateRequest, kImage1Url, "AQID")),
-      kErrorResponse, net::HTTP_OK);
+      "ocr",
+      ReformatJson(base::StringPrintf(kRequestTemplate, kImage1Url, "AQID")),
+      base::StringPrintf(kErrorResponseTemplate, kImage1Url), net::HTTP_OK);
   test_task_env.RunUntilIdle();
 
   // HTTP response should have completed and callback should have been called
   // with an error status.
   EXPECT_THAT(error, Eq(mojom::AnnotateImageError::kFailure));
   EXPECT_THAT(ocr_text, Eq(base::nullopt));
-
-  // Metrics about the backend failure should have been logged.
-  histogram_tester.ExpectUniqueSample(metrics_internal::kServerNetError,
-                                      net::Error::OK, 1);
-  histogram_tester.ExpectUniqueSample(metrics_internal::kServerHttpResponseCode,
-                                      net::HTTP_OK, 1);
-  histogram_tester.ExpectUniqueSample(
-      base::StringPrintf(metrics_internal::kAnnotationStatus, "Ocr"),
-      8 /* Failed RPC status */, 1);
-  histogram_tester.ExpectUniqueSample(metrics_internal::kClientResult,
-                                      ClientResult::kFailed, 1);
 }
 
 // Test that server failure (i.e. nonsense response) is gracefully handled.
 TEST(AnnotatorTest, ServerError) {
-  base::test::ScopedTaskEnvironment test_task_env(
-      base::test::ScopedTaskEnvironment::MainThreadType::MOCK_TIME);
-  TestServerURLLoaderFactory test_url_factory(
-      "https://ia-pa.9oo91eapis.qjz9zk/v1/");
-  data_decoder::TestDataDecoderService test_dd_service;
-  base::HistogramTester histogram_tester;
-
-  Annotator annotator(
-      GURL(kTestServerUrl), std::string() /* api_key */, kThrottle,
-      1 /* batch_size */, 1.0 /* min_ocr_confidence */,
-      test_url_factory.AsSharedURLLoaderFactory(), test_dd_service.connector());
+  base::test::ScopedTaskEnvironment test_task_env;
+  TestServerURLLoaderFactory test_url_factory("https://test_ia_server.com/v1:");
+
+  Annotator annotator(GURL(kTestServerUrl),
+                      test_url_factory.AsSharedURLLoaderFactory());
 
   TestImageProcessor processor;
   base::Optional<mojom::AnnotateImageError> error;
@@ -593,15 +356,10 @@
   processor.callbacks().pop_back();
   test_task_env.RunUntilIdle();
 
-  // No request should be sent yet (because service is waiting to batch up
-  // multiple requests).
-  EXPECT_THAT(test_url_factory.requests(), IsEmpty());
-  test_task_env.FastForwardBy(base::TimeDelta::FromSeconds(1));
-
   // HTTP request should have been made; respond with nonsense string.
   test_url_factory.ExpectRequestAndSimulateResponse(
-      "annotation", {} /* expected_headers */,
-      ReformatJson(base::StringPrintf(kTemplateRequest, kImage1Url, "AQID")),
+      "ocr",
+      ReformatJson(base::StringPrintf(kRequestTemplate, kImage1Url, "AQID")),
       "Hello, world!", net::HTTP_OK);
   test_task_env.RunUntilIdle();
 
@@ -609,31 +367,15 @@
   // with an error status.
   EXPECT_THAT(error, Eq(mojom::AnnotateImageError::kFailure));
   EXPECT_THAT(ocr_text, Eq(base::nullopt));
-
-  // Metrics about the invalid response format should have been logged.
-  histogram_tester.ExpectUniqueSample(metrics_internal::kServerNetError,
-                                      net::Error::OK, 1);
-  histogram_tester.ExpectUniqueSample(metrics_internal::kServerHttpResponseCode,
-                                      net::HTTP_OK, 1);
-  histogram_tester.ExpectUniqueSample(metrics_internal::kJsonParseSuccess,
-                                      false, 1);
-  histogram_tester.ExpectUniqueSample(metrics_internal::kClientResult,
-                                      ClientResult::kFailed, 1);
 }
 
 // Test that work is reassigned if a processor fails.
 TEST(AnnotatorTest, ProcessorFails) {
-  base::test::ScopedTaskEnvironment test_task_env(
-      base::test::ScopedTaskEnvironment::MainThreadType::MOCK_TIME);
-  TestServerURLLoaderFactory test_url_factory(
-      "https://ia-pa.9oo91eapis.qjz9zk/v1/");
-  data_decoder::TestDataDecoderService test_dd_service;
-  base::HistogramTester histogram_tester;
-
-  Annotator annotator(
-      GURL(kTestServerUrl), std::string() /* api_key */, kThrottle,
-      1 /* batch_size */, 1.0 /* min_ocr_confidence */,
-      test_url_factory.AsSharedURLLoaderFactory(), test_dd_service.connector());
+  base::test::ScopedTaskEnvironment test_task_env;
+  TestServerURLLoaderFactory test_url_factory("https://test_ia_server.com/v1:");
+
+  Annotator annotator(GURL(kTestServerUrl),
+                      test_url_factory.AsSharedURLLoaderFactory());
 
   TestImageProcessor processor[3];
   base::Optional<mojom::AnnotateImageError> error[3];
@@ -666,48 +408,32 @@
   processor[1].callbacks().pop_back();
   test_task_env.RunUntilIdle();
 
-  // No request should be sent yet (because service is waiting to batch up
-  // multiple requests).
-  EXPECT_THAT(test_url_factory.requests(), IsEmpty());
-  test_task_env.FastForwardBy(base::TimeDelta::FromSeconds(1));
-
   // HTTP request for image 1 should have been made.
   test_url_factory.ExpectRequestAndSimulateResponse(
-      "annotation", {} /* expected_headers */,
-      ReformatJson(base::StringPrintf(kTemplateRequest, kImage1Url, "AQID")),
-      kSuccessResponse, net::HTTP_OK);
+      "ocr",
+      ReformatJson(base::StringPrintf(kRequestTemplate, kImage1Url, "AQID")),
+      base::StringPrintf(kSuccessResponseTemplate, kImage1Url,
+                         R"({
+                              "detected_text": "Some text",
+                              "confidence_score": 1.0
+                            })"),
+      net::HTTP_OK);
   test_task_env.RunUntilIdle();
 
   // Annotator should have called all callbacks, but request 1 received an error
   // when we returned empty bytes.
   ASSERT_THAT(error, ElementsAre(mojom::AnnotateImageError::kFailure,
                                  base::nullopt, base::nullopt));
-  EXPECT_THAT(ocr_text, ElementsAre(base::nullopt, "Region 1\nRegion 2",
-                                    "Region 1\nRegion 2"));
-
-  // Metrics about the pixel fetch failure should have been logged.
-  EXPECT_THAT(
-      histogram_tester.GetAllSamples(metrics_internal::kPixelFetchSuccess),
-      UnorderedElementsAre(Bucket(false, 1), Bucket(true, 1)));
-  EXPECT_THAT(histogram_tester.GetAllSamples(metrics_internal::kClientResult),
-              UnorderedElementsAre(
-                  Bucket(static_cast<int32_t>(ClientResult::kFailed), 1),
-                  Bucket(static_cast<int32_t>(ClientResult::kSucceeded), 2)));
+  EXPECT_THAT(ocr_text, ElementsAre(base::nullopt, "Some text", "Some text"));
 }
 
 // Test that work is reassigned if processor dies.
 TEST(AnnotatorTest, ProcessorDies) {
-  base::test::ScopedTaskEnvironment test_task_env(
-      base::test::ScopedTaskEnvironment::MainThreadType::MOCK_TIME);
-  TestServerURLLoaderFactory test_url_factory(
-      "https://ia-pa.9oo91eapis.qjz9zk/v1/");
-  data_decoder::TestDataDecoderService test_dd_service;
-  base::HistogramTester histogram_tester;
-
-  Annotator annotator(
-      GURL(kTestServerUrl), std::string() /* api_key */, kThrottle,
-      1 /* batch_size */, 1.0 /* min_ocr_confidence */,
-      test_url_factory.AsSharedURLLoaderFactory(), test_dd_service.connector());
+  base::test::ScopedTaskEnvironment test_task_env;
+  TestServerURLLoaderFactory test_url_factory("https://test_ia_server.com/v1:");
+
+  Annotator annotator(GURL(kTestServerUrl),
+                      test_url_factory.AsSharedURLLoaderFactory());
 
   TestImageProcessor processor[3];
   base::Optional<mojom::AnnotateImageError> error[3];
@@ -739,440 +465,153 @@
   processor[1].callbacks().pop_back();
   test_task_env.RunUntilIdle();
 
-  // No request should be sent yet (because service is waiting to batch up
-  // multiple requests).
-  EXPECT_THAT(test_url_factory.requests(), IsEmpty());
-  test_task_env.FastForwardBy(base::TimeDelta::FromSeconds(1));
-
   // HTTP request for image 1 should have been made.
   test_url_factory.ExpectRequestAndSimulateResponse(
-      "annotation", {} /* expected_headers */,
-      ReformatJson(base::StringPrintf(kTemplateRequest, kImage1Url, "AQID")),
-      kSuccessResponse, net::HTTP_OK);
+      "ocr",
+      ReformatJson(base::StringPrintf(kRequestTemplate, kImage1Url, "AQID")),
+      base::StringPrintf(kSuccessResponseTemplate, kImage1Url,
+                         R"({
+                              "detected_text": "Some text",
+                              "confidence_score": 1.0
+                            })"),
+      net::HTTP_OK);
   test_task_env.RunUntilIdle();
 
   // Annotator should have called all callbacks, but request 1 was canceled when
   // we reset processor 1.
   ASSERT_THAT(error, ElementsAre(mojom::AnnotateImageError::kCanceled,
                                  base::nullopt, base::nullopt));
-  EXPECT_THAT(ocr_text, ElementsAre(base::nullopt, "Region 1\nRegion 2",
-                                    "Region 1\nRegion 2"));
-
-  // Metrics about the client cancelation should have been logged.
-  EXPECT_THAT(histogram_tester.GetAllSamples(metrics_internal::kClientResult),
-              UnorderedElementsAre(
-                  Bucket(static_cast<int32_t>(ClientResult::kCanceled), 1),
-                  Bucket(static_cast<int32_t>(ClientResult::kSucceeded), 2)));
+  EXPECT_THAT(ocr_text, ElementsAre(base::nullopt, "Some text", "Some text"));
 }
 
-// Test that multiple concurrent requests are handled in the same batch.
-TEST(AnnotatorTest, ConcurrentSameBatch) {
-  base::test::ScopedTaskEnvironment test_task_env(
-      base::test::ScopedTaskEnvironment::MainThreadType::MOCK_TIME);
-  TestServerURLLoaderFactory test_url_factory(
-      "https://ia-pa.9oo91eapis.qjz9zk/v1/");
-  data_decoder::TestDataDecoderService test_dd_service;
-  base::HistogramTester histogram_tester;
-
-  Annotator annotator(
-      GURL(kTestServerUrl), std::string() /* api_key */, kThrottle,
-      3 /* batch_size */, 1.0 /* min_ocr_confidence */,
-      test_url_factory.AsSharedURLLoaderFactory(), test_dd_service.connector());
+// Test that multiple concurrent requests are handled.
+TEST(AnnotatorTest, Concurrent) {
+  base::test::ScopedTaskEnvironment test_task_env;
+  TestServerURLLoaderFactory test_url_factory("https://test_ia_server.com/v1:");
 
-  TestImageProcessor processor[3];
-  base::Optional<mojom::AnnotateImageError> error[3];
-  base::Optional<std::string> ocr_text[3];
-
-  // Request OCR for images 1, 2 and 3.
-  annotator.AnnotateImage(
-      kImage1Url, processor[0].GetPtr(),
-      base::BindOnce(&ReportResult, &error[0], &ocr_text[0]));
-  annotator.AnnotateImage(
-      kImage2Url, processor[1].GetPtr(),
-      base::BindOnce(&ReportResult, &error[1], &ocr_text[1]));
-  annotator.AnnotateImage(
-      kImage3Url, processor[2].GetPtr(),
-      base::BindOnce(&ReportResult, &error[2], &ocr_text[2]));
-  test_task_env.RunUntilIdle();
-
-  // Annotator should have asked processor 1 for image 1's pixels, processor
-  // 2 for image 2's pixels and processor 3 for image 3's pixels.
-  ASSERT_THAT(processor[0].callbacks(), SizeIs(1));
-  ASSERT_THAT(processor[1].callbacks(), SizeIs(1));
-  ASSERT_THAT(processor[2].callbacks(), SizeIs(1));
-
-  // Send back image data.
-  std::move(processor[0].callbacks()[0]).Run({1, 2, 3});
-  processor[0].callbacks().pop_back();
-  std::move(processor[1].callbacks()[0]).Run({4, 5, 6});
-  processor[1].callbacks().pop_back();
-  std::move(processor[2].callbacks()[0]).Run({7, 8, 9});
-  processor[2].callbacks().pop_back();
-  test_task_env.RunUntilIdle();
-
-  // No request should be sent yet (because service is waiting to batch up
-  // multiple requests).
-  EXPECT_THAT(test_url_factory.requests(), IsEmpty());
-  test_task_env.FastForwardBy(base::TimeDelta::FromSeconds(1));
-
-  // A single HTTP request for all images should have been sent.
-  test_url_factory.ExpectRequestAndSimulateResponse(
-      "annotation", {} /* expected_headers */, ReformatJson(kBatchRequest),
-      kBatchResponse, net::HTTP_OK);
-  test_task_env.RunUntilIdle();
-
-  // Annotator should have called each callback with its corresponding text or
-  // failure.
-  ASSERT_THAT(error, ElementsAre(base::nullopt, base::nullopt,
-                                 mojom::AnnotateImageError::kFailure));
-  EXPECT_THAT(ocr_text, ElementsAre("1", "2", base::nullopt));
-
-  // Metrics should have been logged for a single server response with multiple
-  // results included.
-  histogram_tester.ExpectUniqueSample(metrics_internal::kServerNetError,
-                                      net::Error::OK, 1);
-  histogram_tester.ExpectUniqueSample(metrics_internal::kServerHttpResponseCode,
-                                      net::HTTP_OK, 1);
-  EXPECT_THAT(histogram_tester.GetAllSamples(base::StringPrintf(
-                  metrics_internal::kAnnotationStatus, "Ocr")),
-              UnorderedElementsAre(Bucket(8 /* Failed RPC status */, 1),
-                                   Bucket(0 /* OK RPC status */, 2)));
-  histogram_tester.ExpectUniqueSample(
-      base::StringPrintf(metrics_internal::kAnnotationConfidence, "Ocr"), 100,
-      2);
-  histogram_tester.ExpectUniqueSample(
-      base::StringPrintf(metrics_internal::kAnnotationEmpty, "Ocr"), false, 2);
-  EXPECT_THAT(histogram_tester.GetAllSamples(metrics_internal::kClientResult),
-              UnorderedElementsAre(
-                  Bucket(static_cast<int32_t>(ClientResult::kFailed), 1),
-                  Bucket(static_cast<int32_t>(ClientResult::kSucceeded), 2)));
-}
-
-// Test that multiple concurrent requests are handled in separate batches.
-TEST(AnnotatorTest, ConcurrentSeparateBatches) {
-  base::test::ScopedTaskEnvironment test_task_env(
-      base::test::ScopedTaskEnvironment::MainThreadType::MOCK_TIME);
-  TestServerURLLoaderFactory test_url_factory(
-      "https://ia-pa.9oo91eapis.qjz9zk/v1/");
-  data_decoder::TestDataDecoderService test_dd_service;
-  base::HistogramTester histogram_tester;
-
-  Annotator annotator(
-      GURL(kTestServerUrl), std::string() /* api_key */, kThrottle,
-      3 /* batch_size */, 1.0 /* min_ocr_confidence */,
-      test_url_factory.AsSharedURLLoaderFactory(), test_dd_service.connector());
+  Annotator annotator(GURL(kTestServerUrl),
+                      test_url_factory.AsSharedURLLoaderFactory());
 
   TestImageProcessor processor[2];
   base::Optional<mojom::AnnotateImageError> error[2];
   base::Optional<std::string> ocr_text[2];
 
-  // Request OCR for image 1.
+  // Requests for images 1 and 2.
   annotator.AnnotateImage(
       kImage1Url, processor[0].GetPtr(),
       base::BindOnce(&ReportResult, &error[0], &ocr_text[0]));
-  test_task_env.RunUntilIdle();
-
-  // Annotator should have asked processor 1 for image 1's pixels.
-  ASSERT_THAT(processor[0].callbacks(), SizeIs(1));
-  ASSERT_THAT(processor[1].callbacks(), IsEmpty());
-
-  // Send back image 1 data.
-  std::move(processor[0].callbacks()[0]).Run({1, 2, 3});
-  processor[0].callbacks().pop_back();
-  test_task_env.RunUntilIdle();
-
-  // No request should be sent yet (because service is waiting to batch up
-  // multiple requests).
-  EXPECT_THAT(test_url_factory.requests(), IsEmpty());
-  test_task_env.FastForwardBy(base::TimeDelta::FromSeconds(1));
-
-  // Request OCR for image 2.
   annotator.AnnotateImage(
       kImage2Url, processor[1].GetPtr(),
       base::BindOnce(&ReportResult, &error[1], &ocr_text[1]));
   test_task_env.RunUntilIdle();
 
-  // Annotator should have asked processor 2 for image 2's pixels.
-  ASSERT_THAT(processor[0].callbacks(), IsEmpty());
+  // Annotator should have asked processor 1 for image 1's pixels and processor
+  // 2 for image 2's pixels.
+  ASSERT_THAT(processor[0].callbacks(), SizeIs(1));
   ASSERT_THAT(processor[1].callbacks(), SizeIs(1));
 
-  // Send back image 2 data.
+  // Send back image data.
+  std::move(processor[0].callbacks()[0]).Run({1, 2, 3});
+  processor[0].callbacks().pop_back();
   std::move(processor[1].callbacks()[0]).Run({4, 5, 6});
   processor[1].callbacks().pop_back();
   test_task_env.RunUntilIdle();
 
-  // Only the HTTP request for image 1 should have been made (the service is
-  // still waiting to make the batch that will include the request for image
-  // 2).
+  // HTTP request for image 1 should have been made first, then request for
+  // image 2.
   test_url_factory.ExpectRequestAndSimulateResponse(
-      "annotation", {} /* expected_headers */,
-      ReformatJson(base::StringPrintf(kTemplateRequest, kImage1Url, "AQID")),
+      "ocr",
+      ReformatJson(base::StringPrintf(kRequestTemplate, kImage1Url, "AQID")),
+      base::StringPrintf(kSuccessResponseTemplate, kImage1Url,
       R"({
-           "results": [{
-             "imageId": "https://www.example.com/image1.jpg",
-             "engineResults": [{
-               "status": {},
-               "ocrEngine": {
-                 "ocrRegions": [{
-                   "words": [{
-                     "detectedText": "1",
-                     "confidenceScore": 1.0
-                   }]
-                 }]
-               }
-             }]
-           }]
-         })",
+                              "detected_text": "Text 1",
+                              "confidence_score": 1.0
+                            })"),
       net::HTTP_OK);
-  EXPECT_THAT(test_url_factory.requests(), IsEmpty());
-
-  test_task_env.FastForwardBy(base::TimeDelta::FromSeconds(1));
-
-  // Now the HTTP request for image 2 should have been made.
   test_url_factory.ExpectRequestAndSimulateResponse(
-      "annotation", {} /* expected_headers */,
-      ReformatJson(base::StringPrintf(kTemplateRequest, kImage2Url, "BAUG")),
+      "ocr",
+      ReformatJson(base::StringPrintf(kRequestTemplate, kImage2Url, "BAUG")),
+      base::StringPrintf(kSuccessResponseTemplate, kImage1Url,
       R"({
-           "results": [{
-             "imageId": "https://www.example.com/image2.jpg",
-             "engineResults": [{
-               "status": {},
-               "ocrEngine": {
-                 "ocrRegions": [{
-                   "words": [{
-                     "detectedText": "2",
-                     "confidenceScore": 1.0
-                   }]
-                 }]
-               }
-             }]
-           }]
-         })",
+                              "detected_text": "Text 2",
+                              "confidence_score": 1.0
+                            })"),
       net::HTTP_OK);
-
   test_task_env.RunUntilIdle();
 
   // Annotator should have called each callback with its corresponding text.
   ASSERT_THAT(error, ElementsAre(base::nullopt, base::nullopt));
-  EXPECT_THAT(ocr_text, ElementsAre("1", "2"));
-
-  // Metrics should have been logged for two server responses.
-  histogram_tester.ExpectUniqueSample(metrics_internal::kServerNetError,
-                                      net::Error::OK, 2);
-  histogram_tester.ExpectUniqueSample(metrics_internal::kServerHttpResponseCode,
-                                      net::HTTP_OK, 2);
-  histogram_tester.ExpectUniqueSample(
-      base::StringPrintf(metrics_internal::kAnnotationStatus, "Ocr"),
-      0 /* OK RPC status */, 2);
-  histogram_tester.ExpectUniqueSample(
-      base::StringPrintf(metrics_internal::kAnnotationConfidence, "Ocr"), 100,
-      2);
-  histogram_tester.ExpectUniqueSample(
-      base::StringPrintf(metrics_internal::kAnnotationEmpty, "Ocr"), false, 2);
-  histogram_tester.ExpectUniqueSample(metrics_internal::kClientResult,
-                                      ClientResult::kSucceeded, 2);
+  EXPECT_THAT(ocr_text, ElementsAre("Text 1", "Text 2"));
 }
 
 // Test that work is not duplicated if it is already ongoing.
 TEST(AnnotatorTest, DuplicateWork) {
-  base::test::ScopedTaskEnvironment test_task_env(
-      base::test::ScopedTaskEnvironment::MainThreadType::MOCK_TIME);
-  TestServerURLLoaderFactory test_url_factory(
-      "https://ia-pa.9oo91eapis.qjz9zk/v1/");
-  data_decoder::TestDataDecoderService test_dd_service;
-  base::HistogramTester histogram_tester;
-
-  Annotator annotator(
-      GURL(kTestServerUrl), std::string() /* api_key */, kThrottle,
-      1 /* batch_size */, 1.0 /* min_ocr_confidence */,
-      test_url_factory.AsSharedURLLoaderFactory(), test_dd_service.connector());
-
-  TestImageProcessor processor[4];
-  base::Optional<mojom::AnnotateImageError> error[4];
-  base::Optional<std::string> ocr_text[4];
+  base::test::ScopedTaskEnvironment test_task_env;
+  TestServerURLLoaderFactory test_url_factory("https://test_ia_server.com/v1:");
+
+  Annotator annotator(GURL(kTestServerUrl),
+                      test_url_factory.AsSharedURLLoaderFactory());
 
-  // First request annotation of the image with processor 1.
+  TestImageProcessor processor[3];
+  base::Optional<mojom::AnnotateImageError> error[3];
+  base::Optional<std::string> ocr_text[3];
+
+  // First request annotation of image 1 with processor 1.
   annotator.AnnotateImage(
       kImage1Url, processor[0].GetPtr(),
       base::BindOnce(&ReportResult, &error[0], &ocr_text[0]));
   test_task_env.RunUntilIdle();
 
-  // Annotator should have asked processor 1 for the image's pixels.
+  // Annotator should have asked processor 1 for image 1's pixels.
   ASSERT_THAT(processor[0].callbacks(), SizeIs(1));
   ASSERT_THAT(processor[1].callbacks(), IsEmpty());
   ASSERT_THAT(processor[2].callbacks(), IsEmpty());
-  ASSERT_THAT(processor[3].callbacks(), IsEmpty());
 
-  // Now request annotation of the image with processor 2.
+  // Now request annotation of image 1 with processor 2.
   annotator.AnnotateImage(
       kImage1Url, processor[1].GetPtr(),
       base::BindOnce(&ReportResult, &error[1], &ocr_text[1]));
   test_task_env.RunUntilIdle();
 
-  // Annotator *should not* have asked processor 2 for the image's pixels (since
+  // Annotator *should not* have asked processor 2 for image 1's pixels (since
   // processor 1 is already handling that).
   ASSERT_THAT(processor[0].callbacks(), SizeIs(1));
   ASSERT_THAT(processor[1].callbacks(), IsEmpty());
   ASSERT_THAT(processor[2].callbacks(), IsEmpty());
-  ASSERT_THAT(processor[3].callbacks(), IsEmpty());
 
-  // Get processor 1 to reply with bytes for the image.
+  // Get processor 1 to reply with bytes for image 1.
   std::move(processor[0].callbacks()[0]).Run({1, 2, 3});
   processor[0].callbacks().pop_back();
   test_task_env.RunUntilIdle();
 
-  // Now request annotation of the image with processor 3.
+  // Now request annotation of image 1 with processor 3.
   annotator.AnnotateImage(
       kImage1Url, processor[2].GetPtr(),
       base::BindOnce(&ReportResult, &error[2], &ocr_text[2]));
   test_task_env.RunUntilIdle();
 
-  // Annotator *should not* have asked processor 3 for the image's pixels (since
-  // it has already has the pixels in the HTTP request queue).
+  // Annotator *should not* have asked processor 3 for image 1's pixels (since
+  // it has already sent image 1's pixels to the server).
   ASSERT_THAT(processor[0].callbacks(), IsEmpty());
   ASSERT_THAT(processor[1].callbacks(), IsEmpty());
   ASSERT_THAT(processor[2].callbacks(), IsEmpty());
-  ASSERT_THAT(processor[3].callbacks(), IsEmpty());
-  EXPECT_THAT(test_url_factory.requests(), IsEmpty());
 
-  // Allow batch HTTP request to be sent off and then request annotation of the
-  // image with processor 4.
-  test_task_env.FastForwardBy(base::TimeDelta::FromSeconds(1));
-  EXPECT_THAT(test_url_factory.requests(), SizeIs(1));
-  annotator.AnnotateImage(
-      kImage1Url, processor[3].GetPtr(),
-      base::BindOnce(&ReportResult, &error[3], &ocr_text[3]));
-  test_task_env.RunUntilIdle();
-
-  // Annotator *should not* have asked processor 4 for the image's pixels (since
-  // an HTTP request for the image is already in process).
-  ASSERT_THAT(processor[0].callbacks(), IsEmpty());
-  ASSERT_THAT(processor[1].callbacks(), IsEmpty());
-  ASSERT_THAT(processor[2].callbacks(), IsEmpty());
-  ASSERT_THAT(processor[3].callbacks(), IsEmpty());
-
-  // HTTP request for the image should have been made (with bytes obtained from
+  // HTTP request for image 1 should have been made (with bytes obtained from
   // processor 1).
   test_url_factory.ExpectRequestAndSimulateResponse(
-      "annotation", {} /* expected_headers */,
-      ReformatJson(base::StringPrintf(kTemplateRequest, kImage1Url, "AQID")),
-      kSuccessResponse, net::HTTP_OK);
+      "ocr",
+      ReformatJson(base::StringPrintf(kRequestTemplate, kImage1Url, "AQID")),
+      base::StringPrintf(kSuccessResponseTemplate, kImage1Url,
+                         R"({
+                              "detected_text": "Some text",
+                              "confidence_score": 1.0
+                            })"),
+      net::HTTP_OK);
   test_task_env.RunUntilIdle();
 
   // Annotator should have called all callbacks with annotation results.
-  ASSERT_THAT(error, ElementsAre(base::nullopt, base::nullopt, base::nullopt,
-                                 base::nullopt));
-  EXPECT_THAT(ocr_text,
-              ElementsAre("Region 1\nRegion 2", "Region 1\nRegion 2",
-                          "Region 1\nRegion 2", "Region 1\nRegion 2"));
-
-  // Metrics should have been logged for a single pixel fetch.
-  histogram_tester.ExpectUniqueSample(metrics_internal::kPixelFetchSuccess,
-                                      true, 1);
-}
-
-// Test that the specified API key is sent, but only to Google-associated server
-// domains.
-TEST(AnnotatorTest, ApiKey) {
-  base::test::ScopedTaskEnvironment test_task_env(
-      base::test::ScopedTaskEnvironment::MainThreadType::MOCK_TIME);
-  data_decoder::TestDataDecoderService test_dd_service;
-
-  // A call to a secure Google-owner server URL should include the specified API
-  // key.
-  {
-    TestServerURLLoaderFactory test_url_factory(
-        "https://ia-pa.9oo91eapis.qjz9zk/v1/");
-
-    Annotator annotator(GURL(kTestServerUrl), "my_api_key", kThrottle,
-                        1 /* batch_size */, 1.0 /* min_ocr_confidence */,
-                        test_url_factory.AsSharedURLLoaderFactory(),
-                        test_dd_service.connector());
-    TestImageProcessor processor;
-
-    annotator.AnnotateImage(kImage1Url, processor.GetPtr(), base::DoNothing());
-    test_task_env.RunUntilIdle();
-
-    // Annotator should have asked processor for pixels.
-    ASSERT_THAT(processor.callbacks(), SizeIs(1));
-
-    // Send back image data.
-    std::move(processor.callbacks()[0]).Run({1, 2, 3});
-    processor.callbacks().pop_back();
-    test_task_env.FastForwardBy(base::TimeDelta::FromSeconds(1));
-    test_task_env.RunUntilIdle();
-
-    // HTTP request should have been made with the API key included.
-    test_url_factory.ExpectRequestAndSimulateResponse(
-        "annotation", {{Annotator::kGoogApiKeyHeader, "my_api_key"}},
-        ReformatJson(base::StringPrintf(kTemplateRequest, kImage1Url, "AQID")),
-        kSuccessResponse, net::HTTP_OK);
-  }
-
-  // A call to a Google-owned server URL should not include the API key if the
-  // requests are made insecurely.
-  {
-    // Note: not HTTPS.
-    TestServerURLLoaderFactory test_url_factory(
-        "http://ia-pa.9oo91eapis.qjz9zk/v1/");
-
-    Annotator annotator(GURL("http://ia-pa.9oo91eapis.qjz9zk/v1/annotation"),
-                        "my_api_key", kThrottle, 1 /* batch_size */,
-                        1.0 /* min_ocr_confidence */,
-                        test_url_factory.AsSharedURLLoaderFactory(),
-                        test_dd_service.connector());
-    TestImageProcessor processor;
-
-    annotator.AnnotateImage(kImage1Url, processor.GetPtr(), base::DoNothing());
-    test_task_env.RunUntilIdle();
-
-    // Annotator should have asked processor for pixels.
-    ASSERT_THAT(processor.callbacks(), SizeIs(1));
-
-    // Send back image data.
-    std::move(processor.callbacks()[0]).Run({1, 2, 3});
-    processor.callbacks().pop_back();
-    test_task_env.FastForwardBy(base::TimeDelta::FromSeconds(1));
-    test_task_env.RunUntilIdle();
-
-    // HTTP request should have been made without the API key included.
-    test_url_factory.ExpectRequestAndSimulateResponse(
-        "annotation", {{Annotator::kGoogApiKeyHeader, base::nullopt}},
-        ReformatJson(base::StringPrintf(kTemplateRequest, kImage1Url, "AQID")),
-        kSuccessResponse, net::HTTP_OK);
-  }
-
-  // A call to a non-Google-owned URL should not include the API key.
-  {
-    TestServerURLLoaderFactory test_url_factory("https://datascraper.com/");
-
-    Annotator annotator(GURL("https://datascraper.com/annotation"),
-                        "my_api_key", kThrottle, 1 /* batch_size */,
-                        1.0 /* min_ocr_confidence */,
-                        test_url_factory.AsSharedURLLoaderFactory(),
-                        test_dd_service.connector());
-    TestImageProcessor processor;
-
-    annotator.AnnotateImage(kImage1Url, processor.GetPtr(), base::DoNothing());
-    test_task_env.RunUntilIdle();
-
-    // Annotator should have asked processor for pixels.
-    ASSERT_THAT(processor.callbacks(), SizeIs(1));
-
-    // Send back image data.
-    std::move(processor.callbacks()[0]).Run({1, 2, 3});
-    processor.callbacks().pop_back();
-    test_task_env.FastForwardBy(base::TimeDelta::FromSeconds(1));
-    test_task_env.RunUntilIdle();
-
-    // HTTP request should have been made without the API key included.
-    test_url_factory.ExpectRequestAndSimulateResponse(
-        "annotation", {{Annotator::kGoogApiKeyHeader, base::nullopt}},
-        ReformatJson(base::StringPrintf(kTemplateRequest, kImage1Url, "AQID")),
-        kSuccessResponse, net::HTTP_OK);
-  }
+  ASSERT_THAT(error, ElementsAre(base::nullopt, base::nullopt, base::nullopt));
+  EXPECT_THAT(ocr_text, ElementsAre("Some text", "Some text", "Some text"));
 }
 
-// TODO(crbug.com/916420): add unit tests for description annotations.
-
 }  // namespace image_annotation
--- a/services/image_annotation/BUILD.gn	2019-05-01 01:22:56.000000000 +0300
+++ b/services/image_annotation/BUILD.gn	2019-05-17 18:53:37.868000000 +0300
@@ -6,40 +6,15 @@
   sources = [
     "annotator.cc",
     "annotator.h",
-    "image_annotation_metrics.cc",
-    "image_annotation_metrics.h",
-    "image_annotation_utils.cc",
-    "image_annotation_utils.h",
   ]
 
-  visibility = [ "/*" ]
-
   deps = [
     "//base",
-    "//components/google/core/common",
     "//mojo/public/cpp/bindings",
     "//net",
-    "//services/data_decoder/public/mojom",
-    "//services/image_annotation/public/mojom",
-    "//services/network/public/cpp",
-    "//services/service_manager/public/cpp",
-    "//url",
-  ]
-}
-
-source_set("service") {
-  sources = [
-    "image_annotation_service.cc",
-    "image_annotation_service.h",
-  ]
-
-  deps = [
-    ":lib",
-    "//base",
+    "//services/image_annotation/public/cpp",
     "//services/image_annotation/public/mojom",
     "//services/network/public/cpp",
-    "//services/service_manager/public/cpp",
-    "//services/service_manager/public/mojom",
     "//url",
   ]
 }
@@ -57,14 +32,10 @@
     "//base/test:test_support",
     "//mojo/public/cpp/bindings",
     "//net",
-    "//services/data_decoder/public/cpp:test_support",
-    "//services/data_decoder/public/mojom",
     "//services/image_annotation/public/cpp",
     "//services/image_annotation/public/mojom",
     "//services/network:test_support",
     "//services/network/public/cpp",
-    "//services/service_manager/public/cpp",
-    "//services/service_manager/public/cpp/test:test_support",
     "//testing/gmock",
     "//testing/gtest",
     "//url",
--- a/services/image_annotation/DEPS	2019-05-01 01:22:56.000000000 +0300
+++ b/services/image_annotation/DEPS	2019-05-17 18:53:37.868000000 +0300
@@ -1,7 +1,5 @@
 include_rules = [
-  "+components/google",
   "+net",
-  "+services/data_decoder",
   "+services/network",
   "+third_party/skia",
   "+ui/gfx",
--- a/services/image_annotation/public/cpp/BUILD.gn	2019-05-01 01:22:56.000000000 +0300
+++ b/services/image_annotation/public/cpp/BUILD.gn	2019-05-17 18:53:37.868000000 +0300
@@ -10,27 +10,12 @@
 
   public_deps = [
     "//base",
-    "//services/image_annotation:lib",
     "//services/image_annotation/public/mojom",
     "//skia",
     "//ui/gfx/codec",
   ]
 }
 
-source_set("manifest") {
-  sources = [
-    "manifest.cc",
-    "manifest.h",
-  ]
-
-  public_deps = [
-    "//base",
-    "//services/data_decoder/public/mojom:constants",
-    "//services/image_annotation/public/mojom",
-    "//services/service_manager/public/cpp",
-  ]
-}
-
 source_set("tests") {
   testonly = true
 
@@ -42,7 +27,6 @@
     ":cpp",
     "//base",
     "//base/test:test_support",
-    "//services/image_annotation:lib",
     "//testing/gmock",
     "//testing/gtest",
     "//ui/gfx/codec",
--- a/services/image_annotation/public/cpp/image_processor.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/image_annotation/public/cpp/image_processor.cc	2019-05-17 18:53:37.868000000 +0300
@@ -4,11 +4,9 @@
 
 #include "services/image_annotation/public/cpp/image_processor.h"
 
-#include "base/bind.h"
 #include "base/task/post_task.h"
 #include "base/task_runner_util.h"
 #include "mojo/public/cpp/bindings/interface_request.h"
-#include "services/image_annotation/image_annotation_metrics.h"
 #include "third_party/skia/include/core/SkCanvas.h"
 #include "ui/gfx/codec/jpeg_codec.h"
 
@@ -38,11 +36,6 @@
                                          const int max_pixels,
                                          const int jpg_quality) {
   const int num_pixels = image.width() * image.height();
-  ReportSourcePixelCount(num_pixels);
-
-  if (num_pixels == 0)
-    return {};
-
   const SkBitmap scaled_image =
       num_pixels <= max_pixels
           ? image
@@ -51,7 +44,6 @@
   std::vector<uint8_t> encoded;
   if (!gfx::JPEGCodec::Encode(scaled_image, jpg_quality, &encoded))
     encoded.clear();
-  ReportEncodedJpegSize(encoded.size());
 
   return encoded;
 }
--- a/services/image_annotation/public/cpp/image_processor_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/image_annotation/public/cpp/image_processor_unittest.cc	2019-05-17 18:53:37.868000000 +0300
@@ -8,9 +8,7 @@
 #include <limits>
 
 #include "base/bind.h"
-#include "base/test/metrics/histogram_tester.h"
 #include "base/test/scoped_task_environment.h"
-#include "services/image_annotation/image_annotation_metrics.h"
 #include "testing/gmock/include/gmock/gmock.h"
 #include "testing/gtest/include/gtest/gtest.h"
 #include "third_party/skia/bcore/SkEndian.h"
@@ -89,7 +87,6 @@
 
 TEST(ImageProcessorTest, NullImage) {
   base::test::ScopedTaskEnvironment test_task_env;
-  base::HistogramTester histogram_tester;
 
   bool empty_bytes = false;
 
@@ -104,14 +101,10 @@
   test_task_env.RunUntilIdle();
 
   EXPECT_THAT(empty_bytes, Eq(true));
-
-  histogram_tester.ExpectUniqueSample(metrics_internal::kSourcePixelCount,
-                                      0 /* sample */, 1 /* count */);
 }
 
 TEST(ImageProcessorTest, ImageContent) {
   base::test::ScopedTaskEnvironment test_task_env;
-  base::HistogramTester histogram_tester;
 
   // Create one image that doesn't need scaling and one image that does.
   const int max_dim = static_cast<int>(std::sqrt(ImageProcessor::kMaxPixels));
@@ -135,14 +128,6 @@
           base::BindOnce(&OutputImageError, &scale_error, small_orig));
   test_task_env.RunUntilIdle();
   EXPECT_THAT(scale_error, Lt(kMaxError));
-
-  histogram_tester.ExpectBucketCount(metrics_internal::kSourcePixelCount,
-                                     max_dim * max_dim /* sample */,
-                                     1 /* count */);
-  histogram_tester.ExpectBucketCount(metrics_internal::kSourcePixelCount,
-                                     4 * max_dim * max_dim /* sample */,
-                                     1 /* count */);
-  histogram_tester.ExpectTotalCount(metrics_internal::kSourcePixelCount, 2);
 }
 
 }  // namespace image_annotation
--- a/services/image_annotation/public/mojom/BUILD.gn	2019-05-01 01:22:56.000000000 +0300
+++ b/services/image_annotation/public/mojom/BUILD.gn	2019-05-17 18:53:37.868000000 +0300
@@ -9,10 +9,6 @@
     "image_annotation.mojom",
   ]
 
-  public_deps = [
-    ":constants",
-  ]
-
   deps = [
     "//mojo/public/mojom/base",
   ]
--- a/services/image_annotation/public/mojom/constants.mojom	2019-05-01 01:22:56.000000000 +0300
+++ b/services/image_annotation/public/mojom/constants.mojom	2019-05-17 18:53:37.868000000 +0300
@@ -5,4 +5,3 @@
 module image_annotation.mojom;
 
 const string kServiceName = "image_annotation";
-const string kAnnotationCapability = "annotation";
--- a/services/image_annotation/public/mojom/image_annotation.mojom	2019-05-01 01:22:56.000000000 +0300
+++ b/services/image_annotation/public/mojom/image_annotation.mojom	2019-05-17 18:53:37.868000000 +0300
@@ -12,50 +12,30 @@
   GetJpgImageData() => (array<uint8> bytes);
 };
 
-// The ways in which an annotation request can fail.
 enum AnnotateImageError {
   kCanceled,
   kFailure,
-  kAdult,
-};
-
-// The types of annotations that can be returned.
-//
-// Logged in metrics - do not reuse or reassign values.
-enum AnnotationType {
-  kOcr = 1,
-  kLabel = 2,
-  kCaption = 3,
-};
-
-// One annotation for an image.
-struct Annotation {
-  AnnotationType type;
-  double score;
-  string text;
 };
 
 union AnnotateImageResult {
   AnnotateImageError error_code;
-
-  // If the union is of this type, |annotations| will be non-empty.
-  array<Annotation> annotations;
+  string ocr_text;
 };
 
 interface Annotator {
-  // Requests a11y annotations (i.e. OCR, labels) for the given image.
+  // Requests a11y annotations (i.e. OCR) for the given image.
   //
   // |source_id| is either the URL for an image, or some non-URL string that
   // uniquely identifies an image (e.g. a hash of image content for a data
   // URI). Source IDs are used to query local and remote caches.
   //
-  // |result| will contain either the error code specifying how annotation
-  // failed, or the annotations extracted from the image.
+  // |result| will contain either the |error_code| value specifying how
+  // annotation failed, or the text |ocr_text| extracted from the image (with
+  // an empty string denoting no image text).
   //
   // TODO(crbug.com/916420): expand this signature to include a request
   //                         argument when we support more than one type of
   //                         annotation.
-  // TODO(crbug.com/916420): add a language code as an arg / parameter.
   AnnotateImage(string source_id, ImageProcessor image_processor)
     => (AnnotateImageResult result);
 };
--- a/services/media_session/audio_focus_manager.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/media_session/audio_focus_manager.cc	2019-05-17 18:53:37.868000000 +0300
@@ -7,7 +7,6 @@
 #include <iterator>
 #include <utility>
 
-#include "base/bind.h"
 #include "base/containers/adapters.h"
 #include "base/threading/thread_task_runner_handle.h"
 #include "base/unguessable_token.h"
@@ -441,8 +440,6 @@
         if (!session->IsSuspended())
           state.should_duck = true;
         break;
-      case mojom::AudioFocusType::kAmbient:
-        break;
     }
   }
 }
--- a/services/media_session/audio_focus_manager_metrics_helper.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/media_session/audio_focus_manager_metrics_helper.cc	2019-05-17 18:53:37.868000000 +0300
@@ -88,8 +88,6 @@
       return AudioFocusType::kGainTransientMayDuck;
     case mojom::AudioFocusType::kGainTransient:
       return AudioFocusType::kGainTransient;
-    case mojom::AudioFocusType::kAmbient:
-      return AudioFocusType::kAmbient;
   }
 
   NOTREACHED();
--- a/services/media_session/audio_focus_manager_metrics_helper.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/media_session/audio_focus_manager_metrics_helper.h	2019-05-17 18:53:37.868000000 +0300
@@ -52,8 +52,7 @@
     kGain = 1,
     kGainTransientMayDuck = 2,
     kGainTransient = 3,
-    kAmbient = 4,
-    kMaxValue = kAmbient  // Leave at the end.
+    kMaxValue = kGainTransient  // Leave at the end.
   };
 
   void OnRequestAudioFocus(AudioFocusRequestSource, mojom::AudioFocusType);
--- a/services/media_session/audio_focus_manager_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/media_session/audio_focus_manager_unittest.cc	2019-05-17 18:53:37.868000000 +0300
@@ -8,7 +8,6 @@
 #include <utility>
 #include <vector>
 
-#include "base/bind.h"
 #include "base/callback.h"
 #include "base/run_loop.h"
 #include "base/test/metrics/histogram_tester.h"
@@ -78,10 +77,6 @@
     return GetCountForType(mojom::AudioFocusType::kGainTransientMayDuck);
   }
 
-  int GetAmbientCount() {
-    return GetCountForType(mojom::AudioFocusType::kAmbient);
-  }
-
   void AbandonAudioFocusNoReset(test::MockMediaSession* session) {
     session->audio_focus_request()->AbandonAudioFocus();
     session->FlushForTesting();
@@ -252,7 +247,7 @@
   DISALLOW_COPY_AND_ASSIGN(AudioFocusManagerTest);
 };
 
-INSTANTIATE_TEST_SUITE_P(
+INSTANTIATE_TEST_CASE_P(
     ,
     AudioFocusManagerTest,
     testing::Values(mojom::EnforcementMode::kDefault,
@@ -1486,30 +1481,4 @@
   }
 }
 
-TEST_P(AudioFocusManagerTest, AmbientFocusHasNoEffect) {
-  test::MockMediaSession media_session_1;
-  test::MockMediaSession media_session_2;
-
-  AudioFocusManager::RequestId request_id_1 =
-      RequestAudioFocus(&media_session_1, mojom::AudioFocusType::kGain);
-  EXPECT_EQ(request_id_1, GetAudioFocusedSession());
-  EXPECT_EQ(mojom::MediaSessionInfo::SessionState::kActive,
-            GetState(&media_session_1));
-
-  EXPECT_EQ(0, GetAmbientCount());
-  RequestAudioFocus(&media_session_2, mojom::AudioFocusType::kAmbient);
-
-  EXPECT_EQ(1, GetAmbientCount());
-  EXPECT_EQ(mojom::MediaSessionInfo::SessionState::kActive,
-            GetState(&media_session_1));
-  EXPECT_EQ(mojom::MediaSessionInfo::SessionState::kActive,
-            GetState(&media_session_2));
-
-  media_session_2.AbandonAudioFocusFromClient();
-
-  EXPECT_EQ(0, GetAmbientCount());
-  EXPECT_EQ(mojom::MediaSessionInfo::SessionState::kActive,
-            GetState(&media_session_1));
-}
-
 }  // namespace media_session
--- a/services/media_session/BUILD.gn	2019-05-01 01:22:56.000000000 +0300
+++ b/services/media_session/BUILD.gn	2019-05-17 18:53:37.868000000 +0300
@@ -2,6 +2,7 @@
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
+import("//services/service_manager/public/service_manifest.gni")
 import("//testing/test.gni")
 
 # There should be only one media session service. It is currently in the
@@ -25,7 +26,6 @@
     "//mojo/public/cpp/bindings",
     "//services/media_session/public/cpp",
     "//services/media_session/public/mojom",
-    "//skia",
   ]
 
   public_deps = [
@@ -34,6 +34,11 @@
   ]
 }
 
+service_manifest("manifest") {
+  name = "media_session"
+  source = "manifest.json"
+}
+
 source_set("tests") {
   testonly = true
   sources = [
--- a/services/media_session/controlling_media_playback.md	2019-05-01 01:22:56.000000000 +0300
+++ b/services/media_session/controlling_media_playback.md	2019-05-17 18:53:37.868000000 +0300
@@ -10,6 +10,12 @@
 
 # Audio Focus
 
+To get started the following flags should be enabled:
+
+* #enable-audio-focus - This enables audio focus on Chrome.
+* #enable-arc-unified-audio-focus - enables ARC++ integration. This means that
+  ARC++ apps will request audio focus from Chrome (Chrome OS only).
+
 When audio focus is enabled all the different media sessions will request audio
 focus. A media session can request three different types of audio focus:
 
@@ -57,16 +63,12 @@
 session changes. This can be used to determine whether there is any current
 media playback.
 
-# Media Controller Manager
+# Active Media Controller
 
-The media session service also exposes a [MediaControllerManager](https://cs.chromium.org/chromium/bservices/media_session/public/mojom/media_controller.mojom)
-mojo API. This can be used to create a [MediaController](https://cs.chromium.org/chromium/bservices/media_session/public/mojom/media_controller.mojom)
-instance. These can be used to control and observe a media session. This can
-be an individual media session or the active media session.
-
-If the controller is created using `CreateActiveMediaController` then it will
-follow the active media session. This means you do not need to create a new
-media controller if the active media session changes.
+The media session service also exposes a [MediaController](https://cs.chromium.org/chromium/bservices/media_session/public/mojom/media_controller.mojom)
+mojo API. This can be used to control the active media session. It will
+automatically route commands to the active media session, even if the media
+session changes.
 
 **There is also a MediaSession mojo API. This is used for session / service
 communication and should not be used for control.**.
@@ -90,13 +92,4 @@
 [//services/media_session/public/cpp/test](https://cs.chromium.org/chromium/bservices/media_session/public/cpp/test/)
 directory also contains a number of other useful test utilities.
 
-# Current Media Session service integrations
-
-The following clients are integrated with the media session service and expose
-a media session and request audio focus:
-
-* content::WebContents
-* ARC++ apps (requires Android Pie)
-* Assistant
-
 Questions? - Feel free to reach out to beccahughes@chromium.org.
--- a/services/media_session/DEPS	2019-05-01 01:22:56.000000000 +0300
+++ b/services/media_session/DEPS	2019-05-17 18:53:37.868000000 +0300
@@ -1,5 +1,4 @@
 include_rules = [
   "+jni",
   "+ui/gfx",
-  "+third_party/skia/include",
 ]
--- a/services/media_session/media_controller.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/media_session/media_controller.cc	2019-05-17 18:53:37.868000000 +0300
@@ -4,84 +4,8 @@
 
 #include "services/media_session/media_controller.h"
 
-#include <set>
-
-#include "services/media_session/public/cpp/media_image_manager.h"
-
 namespace media_session {
 
-// ImageObserverHolder will hold each mojo image observer with the image
-// size and type preferences it specified when the observer was added.
-class MediaController::ImageObserverHolder {
- public:
-  ImageObserverHolder(MediaController* owner,
-                      mojom::MediaSessionImageType type,
-                      int minimum_size_px,
-                      int desired_size_px,
-                      mojom::MediaControllerImageObserverPtr observer,
-                      const std::vector<MediaImage>& current_images)
-      : manager_(minimum_size_px, desired_size_px),
-        owner_(owner),
-        type_(type),
-        minimum_size_px_(minimum_size_px),
-        desired_size_px_(desired_size_px),
-        observer_(std::move(observer)) {
-    // Set a connection error handler so that we will remove observers that have
-    // had an error / been closed.
-    observer_.set_connection_error_handler(base::BindOnce(
-        &MediaController::CleanupImageObservers, base::Unretained(owner_)));
-
-    // Flush the observer with the latest state.
-    ImagesChanged(current_images);
-  }
-
-  ~ImageObserverHolder() = default;
-
-  bool is_valid() const { return !observer_.encountered_error(); }
-
-  mojom::MediaSessionImageType type() const { return type_; }
-
-  void ImagesChanged(const std::vector<MediaImage>& images) {
-    base::Optional<MediaImage> image = manager_.SelectImage(images);
-
-    // If we could not find an image then we should call with an empty image to
-    // flush the observer.
-    if (!image) {
-      ClearImage();
-      return;
-    }
-
-    DCHECK(owner_->session_);
-    owner_->session_->GetMediaImageBitmap(
-        *image, minimum_size_px_, desired_size_px_,
-        base::BindOnce(&MediaController::ImageObserverHolder::OnImage,
-                       base::Unretained(this)));
-  }
-
-  void ClearImage() {
-    observer_->MediaControllerImageChanged(type_, SkBitmap());
-  }
-
- private:
-  void OnImage(const SkBitmap& image) {
-    observer_->MediaControllerImageChanged(type_, image);
-  }
-
-  media_session::MediaImageManager manager_;
-
-  MediaController* const owner_;
-
-  mojom::MediaSessionImageType const type_;
-
-  int const minimum_size_px_;
-
-  int const desired_size_px_;
-
-  mojom::MediaControllerImageObserverPtr observer_;
-
-  DISALLOW_COPY_AND_ASSIGN(ImageObserverHolder);
-};
-
 MediaController::MediaController() {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
 }
@@ -125,10 +49,12 @@
   }
 }
 
-void MediaController::AddObserver(mojom::MediaControllerObserverPtr observer) {
+void MediaController::AddObserver(mojom::MediaSessionObserverPtr observer) {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
 
-  // Flush the new observer with the current state.
+  // Flush the new observer with the state. We always flush the metadata as that
+  // is optional so null is a valid value whereas the session info is required.
+  if (!session_info_.is_null())
   observer->MediaSessionInfoChanged(session_info_.Clone());
   observer->MediaSessionMetadataChanged(session_metadata_);
   observer->MediaSessionActionsChanged(session_actions_);
@@ -139,7 +65,7 @@
 void MediaController::MediaSessionInfoChanged(mojom::MediaSessionInfoPtr info) {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
 
-  observers_.ForAllPtrs([&info](mojom::MediaControllerObserver* observer) {
+  observers_.ForAllPtrs([&info](mojom::MediaSessionObserver* observer) {
     observer->MediaSessionInfoChanged(info.Clone());
   });
 
@@ -150,7 +76,7 @@
     const base::Optional<MediaMetadata>& metadata) {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
 
-  observers_.ForAllPtrs([&metadata](mojom::MediaControllerObserver* observer) {
+  observers_.ForAllPtrs([&metadata](mojom::MediaSessionObserver* observer) {
     observer->MediaSessionMetadataChanged(metadata);
   });
 
@@ -161,43 +87,13 @@
     const std::vector<mojom::MediaSessionAction>& actions) {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
 
-  observers_.ForAllPtrs([&actions](mojom::MediaControllerObserver* observer) {
+  observers_.ForAllPtrs([&actions](mojom::MediaSessionObserver* observer) {
     observer->MediaSessionActionsChanged(actions);
   });
 
   session_actions_ = actions;
 }
 
-void MediaController::MediaSessionImagesChanged(
-    const base::flat_map<mojom::MediaSessionImageType, std::vector<MediaImage>>&
-        images) {
-  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
-
-  // Work out which image types have changed.
-  std::set<mojom::MediaSessionImageType> types_changed;
-  for (const auto& entry : images) {
-    auto it = session_images_.find(entry.first);
-    if (it != session_images_.end() && entry.second == it->second)
-      continue;
-
-    types_changed.insert(entry.first);
-  }
-
-  session_images_ = images;
-
-  for (auto& holder : image_observers_) {
-    auto it = session_images_.find(holder->type());
-
-    if (it == session_images_.end()) {
-      // No image of this type is available from the session so we should clear
-      // any image the observers might have.
-      holder->ClearImage();
-    } else if (base::ContainsKey(types_changed, holder->type())) {
-      holder->ImagesChanged(it->second);
-    }
-  }
-}
-
 void MediaController::PreviousTrack() {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
 
@@ -219,20 +115,6 @@
     session_->Seek(seek_time);
 }
 
-void MediaController::ObserveImages(
-    mojom::MediaSessionImageType type,
-    int minimum_size_px,
-    int desired_size_px,
-    mojom::MediaControllerImageObserverPtr observer) {
-  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
-
-  auto it = session_images_.find(type);
-
-  image_observers_.push_back(std::make_unique<ImageObserverHolder>(
-      this, type, minimum_size_px, desired_size_px, std::move(observer),
-      it == session_images_.end() ? std::vector<MediaImage>() : it->second));
-}
-
 bool MediaController::SetMediaSession(mojom::MediaSession* session) {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
 
@@ -243,25 +125,12 @@
     session_info_.reset();
     session_metadata_.reset();
     session_actions_.clear();
-    session_images_.clear();
 
     if (session) {
       // Add |this| as an observer for |session|.
       mojom::MediaSessionObserverPtr observer;
       session_binding_.Bind(mojo::MakeRequest(&observer));
       session->AddObserver(std::move(observer));
-    } else {
-      // If we are no longer bound to a session we should flush the observers
-      // with empty data.
-      observers_.ForAllPtrs([](mojom::MediaControllerObserver* observer) {
-        observer->MediaSessionInfoChanged(nullptr);
-        observer->MediaSessionMetadataChanged(base::nullopt);
-        observer->MediaSessionActionsChanged(
-            std::vector<mojom::MediaSessionAction>());
-      });
-
-      for (auto& holder : image_observers_)
-        holder->ClearImage();
     }
   }
 
@@ -278,9 +147,4 @@
   bindings_.FlushForTesting();
 }
 
-void MediaController::CleanupImageObservers() {
-  base::EraseIf(image_observers_,
-                [](const auto& holder) { return !holder->is_valid(); });
-}
-
 }  // namespace media_session
--- a/services/media_session/media_controller.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/media_session/media_controller.h	2019-05-17 18:53:37.868000000 +0300
@@ -6,10 +6,7 @@
 #define SERVICES_MEDIA_SESSION_MEDIA_CONTROLLER_H_
 
 #include <memory>
-#include <utility>
-#include <vector>
 
-#include "base/containers/flat_map.h"
 #include "base/optional.h"
 #include "base/sequence_checker.h"
 #include "mojo/public/cpp/bindings/binding.h"
@@ -36,14 +33,10 @@
   void Resume() override;
   void Stop() override;
   void ToggleSuspendResume() override;
-  void AddObserver(mojom::MediaControllerObserverPtr observer) override;
+  void AddObserver(mojom::MediaSessionObserverPtr observer) override;
   void PreviousTrack() override;
   void NextTrack() override;
   void Seek(base::TimeDelta seek_time) override;
-  void ObserveImages(mojom::MediaSessionImageType type,
-                     int minimum_size_px,
-                     int desired_size_px,
-                     mojom::MediaControllerImageObserverPtr observer) override;
 
   // mojom::MediaSessionObserver overrides.
   void MediaSessionInfoChanged(
@@ -52,9 +45,6 @@
       const base::Optional<MediaMetadata>&) override;
   void MediaSessionActionsChanged(
       const std::vector<mojom::MediaSessionAction>& action) override;
-  void MediaSessionImagesChanged(
-      const base::flat_map<mojom::MediaSessionImageType,
-                           std::vector<MediaImage>>& images) override;
 
   // Sets the media session that the controller should be bound to. If the
   // session is already bound to the same session then we will return false.
@@ -64,13 +54,6 @@
   void FlushForTesting();
 
  private:
-  friend class MediaControllerTest;
-
-  class ImageObserverHolder;
-
-  // Removes unbound or faulty image observers.
-  void CleanupImageObservers();
-
   // Holds mojo bindings for mojom::MediaController.
   mojo::BindingSet<mojom::MediaController> bindings_;
 
@@ -83,23 +66,16 @@
   // The current actions for |session_|.
   std::vector<mojom::MediaSessionAction> session_actions_;
 
-  // The current images for |session_|.
-  base::flat_map<mojom::MediaSessionImageType, std::vector<MediaImage>>
-      session_images_;
-
   // Raw pointer to the local proxy. This is used for sending control events to
   // the underlying MediaSession.
   mojom::MediaSession* session_ = nullptr;
 
-  // Observers that are observing |this|.
-  mojo::InterfacePtrSet<mojom::MediaControllerObserver> observers_;
+  // Observers that are observing |session_|.
+  mojo::InterfacePtrSet<mojom::MediaSessionObserver> observers_;
 
   // Binding for |this| to act as an observer to |session_|.
   mojo::Binding<mojom::MediaSessionObserver> session_binding_{this};
 
-  // Manages individual image observers.
-  std::vector<std::unique_ptr<ImageObserverHolder>> image_observers_;
-
   // Protects |session_| as it is not thread safe.
   SEQUENCE_CHECKER(sequence_checker_);
 
--- a/services/media_session/media_controller_unittest.cc	2019-05-17 17:45:42.524000000 +0300
+++ b/services/media_session/media_controller_unittest.cc	2019-05-17 18:53:37.868000000 +0300
@@ -16,7 +16,6 @@
 #include "services/media_session/media_session_service.h"
 #include "services/media_session/public/cpp/media_metadata.h"
 #include "services/media_session/public/cpp/test/mock_media_session.h"
-#include "services/media_session/public/cpp/test/test_media_controller.h"
 #include "services/media_session/public/mojom/constants.mojom.h"
 #include "services/service_manager/public/cpp/test/test_connector_factory.h"
 #include "testing/gtest/include/gtest/gtest.h"
@@ -61,10 +60,6 @@
     return controller_manager_ptr_;
   }
 
-  static size_t GetImageObserverCount(const MediaController& controller) {
-    return controller.image_observers_.size();
-  }
-
  private:
   base::test::ScopedTaskEnvironment task_environment_;
   service_manager::TestConnectorFactory connector_factory_;
@@ -421,18 +416,18 @@
   }
 
   {
-    test::TestMediaControllerObserver observer(controller());
+    test::MockMediaSessionMojoObserver observer(controller());
     observer.WaitForState(mojom::MediaSessionInfo::SessionState::kActive);
   }
 
   {
-    test::TestMediaControllerObserver observer(controller());
+    test::MockMediaSessionMojoObserver observer(controller());
     controller()->Suspend();
     observer.WaitForState(mojom::MediaSessionInfo::SessionState::kSuspended);
   }
 
   {
-    test::TestMediaControllerObserver observer(controller());
+    test::MockMediaSessionMojoObserver observer(controller());
     RequestAudioFocus(media_session_2, mojom::AudioFocusType::kGain);
     observer.WaitForState(mojom::MediaSessionInfo::SessionState::kActive);
   }
@@ -444,7 +439,7 @@
   }
 
   {
-    test::TestMediaControllerObserver observer(controller());
+    test::MockMediaSessionMojoObserver observer(controller());
     observer.WaitForState(mojom::MediaSessionInfo::SessionState::kActive);
   }
 }
@@ -528,8 +523,8 @@
   media_session.AbandonAudioFocusFromClient();
 
   {
-    test::TestMediaControllerObserver observer(controller());
-    observer.WaitForEmptyMetadata();
+    test::MockMediaSessionMojoObserver observer(controller());
+    EXPECT_FALSE(observer.WaitForMetadata());
   }
 }
 
@@ -546,9 +541,9 @@
   }
 
   {
-    test::TestMediaControllerObserver observer(controller());
+    test::MockMediaSessionMojoObserver observer(controller());
     media_session.SimulateMetadataChanged(test_metadata);
-    observer.WaitForEmptyMetadata();
+    EXPECT_EQ(test_metadata, observer.WaitForMetadata());
   }
 }
 
@@ -570,9 +565,9 @@
   }
 
   {
-    test::TestMediaControllerObserver observer(controller());
+    test::MockMediaSessionMojoObserver observer(controller());
     media_session.SimulateMetadataChanged(test_metadata);
-    observer.WaitForExpectedMetadata(metadata);
+    EXPECT_EQ(metadata, observer.WaitForNonEmptyMetadata());
   }
 }
 
@@ -591,8 +586,8 @@
   media_session.SimulateMetadataChanged(test_metadata);
 
   {
-    test::TestMediaControllerObserver observer(controller());
-    observer.WaitForEmptyMetadata();
+    test::MockMediaSessionMojoObserver observer(controller());
+    EXPECT_EQ(test_metadata, observer.WaitForMetadata());
   }
 }
 
@@ -616,8 +611,8 @@
   media_session.SimulateMetadataChanged(test_metadata);
 
   {
-    test::TestMediaControllerObserver observer(controller());
-    observer.WaitForExpectedMetadata(metadata);
+    test::MockMediaSessionMojoObserver observer(controller());
+    EXPECT_EQ(metadata, *observer.WaitForMetadata());
   }
 }
 
@@ -745,8 +740,9 @@
   }
 
   {
-    test::TestMediaControllerObserver observer(controller());
-    observer.WaitForEmptyActions();
+    test::MockMediaSessionMojoObserver observer(controller());
+    observer.WaitForActions();
+    EXPECT_TRUE(observer.actions().empty());
   }
 }
 
@@ -763,11 +759,11 @@
   media_session.EnableAction(mojom::MediaSessionAction::kPlay);
 
   {
-    test::TestMediaControllerObserver observer(controller());
+    test::MockMediaSessionMojoObserver observer(controller());
+    observer.WaitForActions();
 
-    std::set<mojom::MediaSessionAction> expected_actions;
-    expected_actions.insert(mojom::MediaSessionAction::kPlay);
-    observer.WaitForExpectedActions(expected_actions);
+    EXPECT_EQ(1u, observer.actions().size());
+    EXPECT_EQ(mojom::MediaSessionAction::kPlay, observer.actions()[0]);
   }
 }
 
@@ -783,9 +779,13 @@
   }
 
   {
-    test::TestMediaControllerObserver observer(controller());
+    test::MockMediaSessionMojoObserver observer(controller());
+    observer.WaitForActions();
+
     media_session.DisableAction(mojom::MediaSessionAction::kPlay);
-    observer.WaitForEmptyActions();
+    observer.WaitForActions();
+
+    EXPECT_TRUE(observer.actions().empty());
   }
 }
 
@@ -800,12 +800,14 @@
   }
 
   {
-    test::TestMediaControllerObserver observer(controller());
+    test::MockMediaSessionMojoObserver observer(controller());
+    observer.WaitForActions();
+
     media_session.EnableAction(mojom::MediaSessionAction::kPlay);
+    observer.WaitForActions();
 
-    std::set<mojom::MediaSessionAction> expected_actions;
-    expected_actions.insert(mojom::MediaSessionAction::kPlay);
-    observer.WaitForExpectedActions(expected_actions);
+    EXPECT_EQ(1u, observer.actions().size());
+    EXPECT_EQ(mojom::MediaSessionAction::kPlay, observer.actions()[0]);
   }
 }
 
@@ -823,266 +825,9 @@
   media_session.AbandonAudioFocusFromClient();
 
   {
-    test::TestMediaControllerObserver observer(controller());
-    observer.WaitForEmptyActions();
-  }
-}
-
-TEST_F(MediaControllerTest, ActiveController_Observer_Abandoned) {
-  test::MockMediaSession media_session;
-  media_session.SetIsControllable(true);
-
-  {
-    test::MockMediaSessionMojoObserver observer(media_session);
-    RequestAudioFocus(media_session, mojom::AudioFocusType::kGain);
-    observer.WaitForState(mojom::MediaSessionInfo::SessionState::kActive);
-  }
-
-  {
-    test::TestMediaControllerObserver observer(controller());
-    media_session.AbandonAudioFocusFromClient();
-
-    // We should see empty info, metadata and actions flushed since the active
-    // controller is no longer bound to a media session.
-    observer.WaitForEmptyInfo();
-    observer.WaitForEmptyMetadata();
-    observer.WaitForEmptyActions();
-  }
-}
-
-TEST_F(MediaControllerTest, ActiveController_AddObserver_Abandoned) {
-  test::MockMediaSession media_session;
-  media_session.SetIsControllable(true);
-
-  {
-    test::MockMediaSessionMojoObserver observer(media_session);
-    RequestAudioFocus(media_session, mojom::AudioFocusType::kGain);
-    observer.WaitForState(mojom::MediaSessionInfo::SessionState::kActive);
-  }
-
-  media_session.AbandonAudioFocusFromClient();
-
-  {
-    test::TestMediaControllerObserver observer(controller());
-
-    // We should see empty info, metadata and actions since the active
-    // controller is no longer bound to a media session.
-    observer.WaitForEmptyInfo();
-    observer.WaitForEmptyMetadata();
-    observer.WaitForEmptyActions();
-  }
-}
-
-TEST_F(MediaControllerTest, ClearImageObserverOnError) {
-  MediaController controller;
-
-  mojom::MediaControllerPtr controller_ptr;
-  controller.BindToInterface(mojo::MakeRequest(&controller_ptr));
-  EXPECT_EQ(0u, GetImageObserverCount(controller));
-
-  {
-    test::TestMediaControllerImageObserver observer(controller_ptr, 0, 0);
-    EXPECT_EQ(1u, GetImageObserverCount(controller));
-  }
-
-  EXPECT_EQ(1u, GetImageObserverCount(controller));
-
-  base::RunLoop().RunUntilIdle();
-
-  EXPECT_EQ(0u, GetImageObserverCount(controller));
-}
-
-TEST_F(MediaControllerTest, ActiveController_SimulateImagesChanged) {
-  test::MockMediaSession media_session;
-  media_session.SetIsControllable(true);
-
-  {
-    test::MockMediaSessionMojoObserver observer(media_session);
-    RequestAudioFocus(media_session, mojom::AudioFocusType::kGain);
-    observer.WaitForState(mojom::MediaSessionInfo::SessionState::kActive);
-  }
-
-  std::vector<MediaImage> images;
-  MediaImage image;
-  image.src = GURL("https://www.9oo91e.qjz9zk");
-  images.push_back(image);
-
-  {
-    test::TestMediaControllerImageObserver observer(controller(), 0, 0);
-
-    // By default, we should receive an empty image.
-    observer.WaitForExpectedImageOfType(mojom::MediaSessionImageType::kArtwork,
-                                        true);
-    EXPECT_TRUE(media_session.last_image_src().is_empty());
-
-    // Check that we receive the correct image and that it was requested from
-    // |media_session| by the controller.
-    media_session.SetImagesOfType(mojom::MediaSessionImageType::kArtwork,
-                                  images);
-    observer.WaitForExpectedImageOfType(mojom::MediaSessionImageType::kArtwork,
-                                        false);
-    EXPECT_EQ(image.src, media_session.last_image_src());
-
-    // Check that we flush the observer with an empty image. Since the image is
-    // empty the last downloaded image by |media_session| should still be the
-    // previous image.
-    media_session.SetImagesOfType(mojom::MediaSessionImageType::kArtwork,
-                                  std::vector<MediaImage>());
-    observer.WaitForExpectedImageOfType(mojom::MediaSessionImageType::kArtwork,
-                                        true);
-    EXPECT_EQ(image.src, media_session.last_image_src());
-  }
-}
-
-TEST_F(MediaControllerTest,
-       ActiveController_SimulateImagesChanged_ToggleControllable) {
-  test::MockMediaSession media_session;
-  media_session.SetIsControllable(true);
-
-  {
-    test::MockMediaSessionMojoObserver observer(media_session);
-    RequestAudioFocus(media_session, mojom::AudioFocusType::kGain);
-    observer.WaitForState(mojom::MediaSessionInfo::SessionState::kActive);
-  }
-
-  std::vector<MediaImage> images;
-  MediaImage image;
-  image.src = GURL("https://www.9oo91e.qjz9zk");
-  images.push_back(image);
-  media_session.SetImagesOfType(mojom::MediaSessionImageType::kArtwork, images);
-
-  {
-    test::TestMediaControllerImageObserver observer(controller(), 0, 0);
-    observer.WaitForExpectedImageOfType(mojom::MediaSessionImageType::kArtwork,
-                                        false);
-    EXPECT_EQ(image.src, media_session.last_image_src());
-
-    // When the |media_session| becomes uncontrollable it is unbound from the
-    // media controller and we should flush the observer with an empty image.
-    media_session.SetIsControllable(false);
-    observer.WaitForExpectedImageOfType(mojom::MediaSessionImageType::kArtwork,
-                                        true);
-
-    // When the |media_session| becomes controllable again it will be bound to
-    // the media controller and we should flush the observer with the current
-    // images.
-    media_session.SetIsControllable(true);
-    observer.WaitForExpectedImageOfType(mojom::MediaSessionImageType::kArtwork,
-                                        false);
-    EXPECT_EQ(image.src, media_session.last_image_src());
-  }
-}
-
-TEST_F(MediaControllerTest,
-       ActiveController_SimulateImagesChanged_TypeChanged) {
-  test::MockMediaSession media_session;
-  media_session.SetIsControllable(true);
-
-  {
-    test::MockMediaSessionMojoObserver observer(media_session);
-    RequestAudioFocus(media_session, mojom::AudioFocusType::kGain);
-    observer.WaitForState(mojom::MediaSessionInfo::SessionState::kActive);
-  }
-
-  std::vector<MediaImage> images;
-  MediaImage image;
-  image.src = GURL("https://www.9oo91e.qjz9zk");
-  images.push_back(image);
-  media_session.SetImagesOfType(mojom::MediaSessionImageType::kArtwork, images);
-
-  {
-    test::TestMediaControllerImageObserver observer(controller(), 0, 0);
-    observer.WaitForExpectedImageOfType(mojom::MediaSessionImageType::kArtwork,
-                                        false);
-    EXPECT_EQ(image.src, media_session.last_image_src());
-
-    // If we clear all the images associated with the media session we should
-    // flush all the observers.
-    media_session.ClearAllImages();
-    observer.WaitForExpectedImageOfType(mojom::MediaSessionImageType::kArtwork,
-                                        true);
-    EXPECT_EQ(image.src, media_session.last_image_src());
-  }
-}
-
-TEST_F(MediaControllerTest,
-       ActiveController_SimulateImagesChanged_MinSizeCutoff) {
-  test::MockMediaSession media_session;
-  media_session.SetIsControllable(true);
-
-  {
-    test::MockMediaSessionMojoObserver observer(media_session);
-    RequestAudioFocus(media_session, mojom::AudioFocusType::kGain);
-    observer.WaitForState(mojom::MediaSessionInfo::SessionState::kActive);
-  }
-
-  std::vector<MediaImage> images;
-  MediaImage image1;
-  image1.src = GURL("https://www.9oo91e.qjz9zk");
-  image1.sizes.push_back(gfx::Size(1, 1));
-  images.push_back(image1);
-  media_session.SetImagesOfType(mojom::MediaSessionImageType::kArtwork, images);
-
-  {
-    test::TestMediaControllerImageObserver observer(controller(), 5, 10);
-
-    // The observer requires an image that is at least 5px but the only image
-    // we have is 1px so the observer will receive a null image.
-    observer.WaitForExpectedImageOfType(mojom::MediaSessionImageType::kArtwork,
-                                        true);
-    EXPECT_TRUE(media_session.last_image_src().is_empty());
-
-    MediaImage image2;
-    image2.src = GURL("https://www.example.com");
-    image2.sizes.push_back(gfx::Size(10, 10));
-    images.push_back(image2);
-
-    // Update the media session with two images, one that is too small and one
-    // that is the right size. We should receive the second image through the
-    // observer.
-    media_session.SetImagesOfType(mojom::MediaSessionImageType::kArtwork,
-                                  images);
-    observer.WaitForExpectedImageOfType(mojom::MediaSessionImageType::kArtwork,
-                                        false);
-    EXPECT_EQ(image2.src, media_session.last_image_src());
-  }
-}
-
-TEST_F(MediaControllerTest,
-       ActiveController_SimulateImagesChanged_DesiredSize) {
-  test::MockMediaSession media_session;
-  media_session.SetIsControllable(true);
-
-  {
-    test::MockMediaSessionMojoObserver observer(media_session);
-    RequestAudioFocus(media_session, mojom::AudioFocusType::kGain);
-    observer.WaitForState(mojom::MediaSessionInfo::SessionState::kActive);
-  }
-
-  std::vector<MediaImage> images;
-  MediaImage image1;
-  image1.src = GURL("https://www.9oo91e.qjz9zk");
-  image1.sizes.push_back(gfx::Size(10, 10));
-  images.push_back(image1);
-
-  MediaImage image2;
-  image2.src = GURL("https://www.example.com");
-  image2.sizes.push_back(gfx::Size(9, 9));
-  images.push_back(image2);
-
-  media_session.SetImagesOfType(mojom::MediaSessionImageType::kArtwork, images);
-
-  {
-    test::TestMediaControllerImageObserver observer(controller(), 5, 10);
-
-    // The media session has two images, but the first one is closer to the 10px
-    // desired size that the observer has specified. Therefore, the observer
-    // should receive that image.
-    media_session.SetImagesOfType(mojom::MediaSessionImageType::kArtwork,
-                                  images);
-    observer.WaitForExpectedImageOfType(mojom::MediaSessionImageType::kArtwork,
-                                        false);
-    EXPECT_EQ(image1.src, media_session.last_image_src());
+    test::MockMediaSessionMojoObserver observer(controller());
+    observer.WaitForActions();
+    EXPECT_TRUE(observer.actions().empty());
   }
 }
 
--- a/services/media_session/OWNERS	2019-05-01 01:22:56.000000000 +0300
+++ b/services/media_session/OWNERS	2019-05-17 18:53:37.868000000 +0300
@@ -1,6 +1,10 @@
 beccahughes@chromium.org
 mlamouri@chromium.org
 
+per-file manifest.json=set noparent
+per-file manifest.json=file://ipc/SECURITY_OWNERS
 
+per-file unittest_manifest.json=set noparent
+per-file unittest_manifest.json=file://ipc/SECURITY_OWNERS
 
 # Component: Internals>Media>Session
--- a/services/media_session/public/cpp/android/BUILD.gn	2019-05-01 01:22:56.000000000 +0300
+++ b/services/media_session/public/cpp/android/BUILD.gn	2019-05-17 18:53:37.872000000 +0300
@@ -4,10 +4,8 @@
 
 import("//build/config/android/rules.gni")
 
-_jni_sources = [
-  "java/borg/chromium/services/media_session/MediaImage.java",
-  "java/borg/chromium/services/media_session/MediaMetadata.java",
-]
+_jni_sources =
+    [ "java/borg/chromium/services/media_session/MediaMetadata.java" ]
 
 generate_jni("media_session_jni_headers") {
   sources = _jni_sources
--- a/services/media_session/public/cpp/android/java/borg/chromium/services/media_session/MediaMetadata.java	2019-05-01 01:22:56.000000000 +0300
+++ b/services/media_session/public/cpp/android/java/borg/chromium/services/media_session/MediaMetadata.java	2019-05-17 18:53:37.872000000 +0300
@@ -4,18 +4,110 @@
 
 package org.chromium.services.media_session;
 
+import android.graphics.Rect;
 import android.support.annotation.NonNull;
 import android.text.TextUtils;
 
 import org.chromium.base.annotations.CalledByNative;
 import org.chromium.base.annotations.JNINamespace;
 
+import java.util.ArrayList;
+import java.util.List;
+
 /**
  * The MediaMetadata class carries information related to a media session. It is
  * the Java counterpart of media_session::MediaMetadata.
  */
 @JNINamespace("media_session")
 public final class MediaMetadata {
+    /**
+     * The MediaImage class carries the artwork information in MediaMetadata. It is the Java
+     * counterpart of media_session::MediaMetadata::MediaImage.
+     */
+    public static final class MediaImage {
+        @NonNull
+        private String mSrc;
+
+        private String mType;
+
+        @NonNull
+        private List<Rect> mSizes = new ArrayList<Rect>();
+
+        /**
+         * Creates a new MediaImage.
+         */
+        public MediaImage(@NonNull String src, @NonNull String type, @NonNull List<Rect> sizes) {
+            mSrc = src;
+            mType = type;
+            mSizes = sizes;
+        }
+
+        /**
+         * @return The URL of this MediaImage.
+         */
+        @NonNull
+        public String getSrc() {
+            return mSrc;
+        }
+
+        /**
+         * @return The MIME type of this MediaImage.
+         */
+        public String getType() {
+            return mType;
+        }
+
+        /**
+         * @return The hinted sizes of this MediaImage.
+         */
+        public List<Rect> getSizes() {
+            return mSizes;
+        }
+
+        /**
+         * Sets the URL of this MediaImage.
+         */
+        public void setSrc(@NonNull String src) {
+            mSrc = src;
+        }
+
+        /**
+         * Sets the MIME type of this MediaImage.
+         */
+        public void setType(@NonNull String type) {
+            mType = type;
+        }
+
+        /**
+         * Sets the sizes of this MediaImage.
+         */
+        public void setSizes(@NonNull List<Rect> sizes) {
+            mSizes = sizes;
+        }
+
+        @Override
+        public boolean equals(Object obj) {
+            if (obj == this) return true;
+            if (!(obj instanceof MediaImage)) return false;
+
+            MediaImage other = (MediaImage) obj;
+            return TextUtils.equals(mSrc, other.mSrc) && TextUtils.equals(mType, other.mType)
+                    && mSizes.equals(other.mSizes);
+        }
+
+        /**
+         * @return The hash code of this {@link MediaImage}. The method uses the same algorithm in
+         * {@link java.util.List} for combinine hash values.
+         */
+        @Override
+        public int hashCode() {
+            int result = mSrc.hashCode();
+            result = 31 * result + mType.hashCode();
+            result = 31 * result + mSizes.hashCode();
+            return result;
+        }
+    }
+
     @NonNull
     private String mTitle;
 
@@ -25,6 +117,9 @@
     @NonNull
     private String mAlbum;
 
+    @NonNull
+    private List<MediaImage> mArtwork = new ArrayList<MediaImage>();
+
     /**
      * Returns the title associated with the media session.
      */
@@ -46,6 +141,10 @@
         return mAlbum;
     }
 
+    public List<MediaImage> getArtwork() {
+        return mArtwork;
+    }
+
     /**
      * Sets the title associated with the media session.
      * @param title The title to use for the media session.
@@ -71,6 +170,23 @@
     }
 
     /**
+     * Create a new {@link MediaImage} from the C++ code, and add it to the Metadata.
+     * @param src The URL of the image.
+     * @param type The MIME type of the image.
+     * @param flattenedSizes The flattened array of image sizes. In native code, it is of type
+     *         `std::vector<gfx::Size>` before flattening.
+     */
+    @CalledByNative
+    private void createAndAddMediaImage(String src, String type, int[] flattenedSizes) {
+        assert(flattenedSizes.length % 2) == 0;
+        List<Rect> sizes = new ArrayList<Rect>();
+        for (int i = 0; (i + 1) < flattenedSizes.length; i += 2) {
+            sizes.add(new Rect(0, 0, flattenedSizes[i], flattenedSizes[i + 1]));
+        }
+        mArtwork.add(new MediaImage(src, type, sizes));
+    }
+
+    /**
      * Creates a new MediaMetadata from the C++ code. This is exactly like the
      * constructor below apart that it can be called by native code.
      */
@@ -98,7 +214,7 @@
 
         MediaMetadata other = (MediaMetadata) obj;
         return TextUtils.equals(mTitle, other.mTitle) && TextUtils.equals(mArtist, other.mArtist)
-                && TextUtils.equals(mAlbum, other.mAlbum);
+                && TextUtils.equals(mAlbum, other.mAlbum) && mArtwork.equals(other.mArtwork);
     }
 
     /**
@@ -110,6 +226,7 @@
         int result = mTitle.hashCode();
         result = 31 * result + mArtist.hashCode();
         result = 31 * result + mAlbum.hashCode();
+        result = 31 * result + mArtwork.hashCode();
         return result;
     }
 }
--- a/services/media_session/public/cpp/BUILD.gn	2019-05-01 01:22:56.000000000 +0300
+++ b/services/media_session/public/cpp/BUILD.gn	2019-05-17 18:53:37.872000000 +0300
@@ -8,8 +8,6 @@
   sources = [
     "features.cc",
     "features.h",
-    "media_image.cc",
-    "media_image.h",
     "media_image_manager.cc",
     "media_image_manager.h",
     "media_metadata.cc",
@@ -25,10 +23,7 @@
   configs += [ "//build/config/compiler:wexit_time_destructors" ]
 
   if (is_android) {
-    sources += [
-      "media_image_android.cc",
-      "media_metadata_android.cc",
-    ]
+    sources += [ "media_metadata_android.cc" ]
     deps += [ "android:media_session_jni_headers" ]
   }
 
@@ -48,16 +43,3 @@
     "//testing/gtest",
   ]
 }
-
-source_set("manifest") {
-  sources = [
-    "manifest.cc",
-    "manifest.h",
-  ]
-
-  deps = [
-    "//base",
-    "//services/media_session/public/mojom",
-    "//services/service_manager/public/cpp",
-  ]
-}
--- a/services/media_session/public/cpp/media_image_manager.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/media_session/public/cpp/media_image_manager.cc	2019-05-17 18:53:37.872000000 +0300
@@ -37,43 +37,16 @@
   return base::ToLowerASCII(path.substr(pos));
 }
 
-double GetImageDominantSizeScore(int min_size,
-                                 int ideal_size,
-                                 const gfx::Size& size) {
-  int dominant_size = std::max(size.width(), size.height());
-
-  // If the size is "any".
-  if (dominant_size == 0)
-    return 0.8;
-
-  // Ignore images that are too small.
-  if (dominant_size < min_size)
-    return 0;
-
-  if (dominant_size <= ideal_size)
-    return 0.8 * (dominant_size - min_size) / (ideal_size - min_size) + 0.2;
-
-  return 1.0 * ideal_size / dominant_size;
-}
-
 }  // namespace
 
-// static
-double MediaImageManager::GetImageSizeScore(int min_size,
-                                            int ideal_size,
-                                            const gfx::Size& size) {
-  return GetImageDominantSizeScore(min_size, ideal_size, size) *
-         GetImageAspectRatioScore(size);
-}
-
 MediaImageManager::MediaImageManager(int min_size, int ideal_size)
     : min_size_(min_size), ideal_size_(ideal_size) {}
 
 MediaImageManager::~MediaImageManager() = default;
 
-base::Optional<MediaImage> MediaImageManager::SelectImage(
-    const std::vector<MediaImage>& images) {
-  base::Optional<MediaImage> selected;
+base::Optional<MediaMetadata::MediaImage> MediaImageManager::SelectImage(
+    const std::vector<MediaMetadata::MediaImage>& images) {
+  base::Optional<MediaMetadata::MediaImage> selected;
 
   double best_score = 0;
   for (auto& image : images) {
@@ -87,16 +60,15 @@
   return selected;
 }
 
-double MediaImageManager::GetImageScore(const MediaImage& image) const {
+double MediaImageManager::GetImageScore(
+    const MediaMetadata::MediaImage& image) const {
   double best_size_score = 0;
 
   if (image.sizes.empty()) {
     best_size_score = kDefaultImageSizeScore;
   } else {
-    for (auto& size : image.sizes) {
-      best_size_score = std::max(
-          best_size_score, GetImageSizeScore(min_size_, ideal_size_, size));
-    }
+    for (auto& size : image.sizes)
+      best_size_score = std::max(best_size_score, GetImageSizeScore(size));
   }
 
   double type_score = kDefaultTypeScore;
@@ -110,6 +82,28 @@
   return best_size_score * type_score;
 }
 
+double MediaImageManager::GetImageSizeScore(const gfx::Size& size) const {
+  return GetImageDominantSizeScore(size) * GetImageAspectRatioScore(size);
+}
+
+double MediaImageManager::GetImageDominantSizeScore(
+    const gfx::Size& size) const {
+  int dominant_size = std::max(size.width(), size.height());
+
+  // If the size is "any".
+  if (dominant_size == 0)
+    return 0.8;
+
+  // Ignore images that are too small.
+  if (dominant_size < min_size_)
+    return 0;
+
+  if (dominant_size <= ideal_size_)
+    return 0.8 * (dominant_size - min_size_) / (ideal_size_ - min_size_) + 0.2;
+
+  return 1.0 * ideal_size_ / dominant_size;
+}
+
 // static
 base::Optional<double> MediaImageManager::GetImageExtensionScore(
     const GURL& url) {
--- a/services/media_session/public/cpp/media_image_manager.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/media_session/public/cpp/media_image_manager.h	2019-05-17 18:53:37.872000000 +0300
@@ -11,7 +11,7 @@
 #include "base/gtest_prod_util.h"
 #include "base/macros.h"
 #include "base/optional.h"
-#include "services/media_session/public/cpp/media_image.h"
+#include "services/media_session/public/cpp/media_metadata.h"
 
 namespace gfx {
 class Size;
@@ -45,12 +45,6 @@
 //       the short edge length by the long edge.
 class COMPONENT_EXPORT(MEDIA_SESSION_CPP) MediaImageManager {
  public:
-  // Returns the image size score as a double between 0 and 1. The score will
-  // be calculated using the size scoring algorithm described above.
-  static double GetImageSizeScore(int min_size,
-                                  int ideal_size,
-                                  const gfx::Size& size);
-
   // The |min_size| is the min size of the images to select in px. The
   // |ideal_size| is the ideal size of the images to select in px.
   MediaImageManager(int min_size, int ideal_size);
@@ -59,14 +53,19 @@
 
   // Select the best image from the |images|. If an image could not be selected
   // then will return null.
-  base::Optional<MediaImage> SelectImage(const std::vector<MediaImage>& images);
+  base::Optional<MediaMetadata::MediaImage> SelectImage(
+      const std::vector<MediaMetadata::MediaImage>& images);
 
  private:
   FRIEND_TEST_ALL_PREFIXES(MediaImageManagerTest,
                            CheckExpectedImageExtensionHashes);
   FRIEND_TEST_ALL_PREFIXES(MediaImageManagerTest, CheckExpectedImageTypeHashes);
 
-  double GetImageScore(const MediaImage& image) const;
+  double GetImageScore(const MediaMetadata::MediaImage& image) const;
+
+  double GetImageSizeScore(const gfx::Size& size) const;
+
+  double GetImageDominantSizeScore(const gfx::Size& size) const;
 
   static base::Optional<double> GetImageExtensionScore(const GURL& url);
 
--- a/services/media_session/public/cpp/media_image_manager_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/media_session/public/cpp/media_image_manager_unittest.cc	2019-05-17 18:53:37.872000000 +0300
@@ -66,14 +66,14 @@
 }
 
 TEST_F(MediaImageManagerTest, PickImageFromMimeType) {
-  std::vector<MediaImage> images;
+  std::vector<MediaMetadata::MediaImage> images;
 
-  MediaImage image1;
+  media_session::MediaMetadata::MediaImage image1;
   image1.type = base::ASCIIToUTF16("image/bmp");
   image1.sizes.push_back(gfx::Size(kIdealSize, kIdealSize));
   images.push_back(image1);
 
-  MediaImage image2;
+  media_session::MediaMetadata::MediaImage image2;
   image2.type = base::ASCIIToUTF16("image/png");
   image2.sizes.push_back(gfx::Size(kIdealSize, kIdealSize));
   images.push_back(image2);
@@ -82,19 +82,19 @@
 }
 
 TEST_F(MediaImageManagerTest, PickImageFromExtension) {
-  std::vector<MediaImage> images;
+  std::vector<MediaMetadata::MediaImage> images;
 
-  MediaImage image1;
+  media_session::MediaMetadata::MediaImage image1;
   image1.src = GURL("https://www.example.com/test.bmp");
   image1.sizes.push_back(gfx::Size(kIdealSize, kIdealSize));
   images.push_back(image1);
 
-  MediaImage image2;
+  media_session::MediaMetadata::MediaImage image2;
   image2.src = GURL("https://www.example.com/test.PNG");
   image2.sizes.push_back(gfx::Size(kIdealSize, kIdealSize));
   images.push_back(image2);
 
-  MediaImage image3;
+  media_session::MediaMetadata::MediaImage image3;
   image3.src = GURL("https://www.example.com/test");
   image3.sizes.push_back(gfx::Size(kIdealSize, kIdealSize));
   images.push_back(image3);
@@ -103,9 +103,9 @@
 }
 
 TEST_F(MediaImageManagerTest, IgnoreImageTooSmall) {
-  std::vector<MediaImage> images;
+  std::vector<MediaMetadata::MediaImage> images;
 
-  MediaImage image;
+  media_session::MediaMetadata::MediaImage image;
   image.sizes.push_back(gfx::Size(1, 1));
   images.push_back(image);
 
@@ -113,14 +113,14 @@
 }
 
 TEST_F(MediaImageManagerTest, PickImageUseDefaultScoreIfNoSize) {
-  std::vector<MediaImage> images;
+  std::vector<MediaMetadata::MediaImage> images;
 
-  MediaImage image1;
+  media_session::MediaMetadata::MediaImage image1;
   image1.src = GURL("https://www.example.com/test.bmp");
   image1.sizes.push_back(gfx::Size(kIdealSize, kIdealSize));
   images.push_back(image1);
 
-  MediaImage image2;
+  media_session::MediaMetadata::MediaImage image2;
   image2.src = GURL("https://www.example.com/test.PNG");
   images.push_back(image2);
 
@@ -128,13 +128,13 @@
 }
 
 TEST_F(MediaImageManagerTest, PickImageCloserToIdeal) {
-  std::vector<MediaImage> images;
+  std::vector<MediaMetadata::MediaImage> images;
 
-  MediaImage image1;
+  media_session::MediaMetadata::MediaImage image1;
   image1.sizes.push_back(gfx::Size(kIdealSize, kIdealSize));
   images.push_back(image1);
 
-  MediaImage image2;
+  media_session::MediaMetadata::MediaImage image2;
   image2.sizes.push_back(gfx::Size(kMinSize, kMinSize));
   images.push_back(image2);
 
@@ -142,13 +142,13 @@
 }
 
 TEST_F(MediaImageManagerTest, PickImageWithMultipleSizes) {
-  std::vector<MediaImage> images;
+  std::vector<MediaMetadata::MediaImage> images;
 
-  MediaImage image1;
+  media_session::MediaMetadata::MediaImage image1;
   image1.sizes.push_back(gfx::Size(kIdealSize - 5, kIdealSize - 5));
   images.push_back(image1);
 
-  MediaImage image2;
+  media_session::MediaMetadata::MediaImage image2;
   image2.sizes.push_back(gfx::Size(kMinSize, kMinSize));
   image2.sizes.push_back(gfx::Size(kIdealSize, kIdealSize));
   images.push_back(image2);
@@ -157,13 +157,13 @@
 }
 
 TEST_F(MediaImageManagerTest, PickImageWithBetterAspectRatio) {
-  std::vector<MediaImage> images;
+  std::vector<MediaMetadata::MediaImage> images;
 
-  MediaImage image1;
+  media_session::MediaMetadata::MediaImage image1;
   image1.sizes.push_back(gfx::Size(kIdealSize, kIdealSize));
   images.push_back(image1);
 
-  MediaImage image2;
+  media_session::MediaMetadata::MediaImage image2;
   image2.sizes.push_back(gfx::Size(kIdealSize, kMinSize));
   images.push_back(image2);
 
--- a/services/media_session/public/cpp/media_metadata_android.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/media_session/public/cpp/media_metadata_android.cc	2019-05-17 18:53:37.872000000 +0300
@@ -4,15 +4,31 @@
 
 #include "services/media_session/public/cpp/media_metadata.h"
 
+#include <string>
+#include <vector>
+
 #include "base/android/jni_array.h"
 #include "base/android/jni_string.h"
 #include "jni/MediaMetadata_jni.h"
-#include "services/media_session/public/cpp/media_image.h"
 
 using base::android::ScopedJavaLocalRef;
 
 namespace media_session {
 
+namespace {
+
+std::vector<int> GetFlattenedSizeArray(const std::vector<gfx::Size>& sizes) {
+  std::vector<int> flattened_array;
+  flattened_array.reserve(2 * sizes.size());
+  for (const auto& size : sizes) {
+    flattened_array.push_back(size.width());
+    flattened_array.push_back(size.height());
+  }
+  return flattened_array;
+}
+
+}  // anonymous namespace
+
 base::android::ScopedJavaLocalRef<jobject> MediaMetadata::CreateJavaObject(
     JNIEnv* env) const {
   ScopedJavaLocalRef<jstring> j_title(
@@ -21,7 +37,24 @@
       base::android::ConvertUTF16ToJavaString(env, artist));
   ScopedJavaLocalRef<jstring> j_album(
       base::android::ConvertUTF16ToJavaString(env, album));
-  return Java_MediaMetadata_create(env, j_title, j_artist, j_album);
+
+  ScopedJavaLocalRef<jobject> j_metadata =
+      Java_MediaMetadata_create(env, j_title, j_artist, j_album);
+
+  for (const auto& image : artwork) {
+    std::string src = image.src.spec();
+    ScopedJavaLocalRef<jstring> j_src(
+        base::android::ConvertUTF8ToJavaString(env, src));
+    ScopedJavaLocalRef<jstring> j_type(
+        base::android::ConvertUTF16ToJavaString(env, image.type));
+    ScopedJavaLocalRef<jintArray> j_sizes(
+        base::android::ToJavaIntArray(env, GetFlattenedSizeArray(image.sizes)));
+
+    Java_MediaMetadata_createAndAddMediaImage(env, j_metadata, j_src, j_type,
+                                              j_sizes);
+  }
+
+  return j_metadata;
 }
 
 }  // namespace media_session
--- a/services/media_session/public/cpp/media_metadata.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/media_session/public/cpp/media_metadata.cc	2019-05-17 18:53:37.872000000 +0300
@@ -4,10 +4,22 @@
 
 #include "services/media_session/public/cpp/media_metadata.h"
 
-#include "services/media_session/public/cpp/media_image.h"
+#include <algorithm>
+#include <iterator>
 
 namespace media_session {
 
+MediaMetadata::MediaImage::MediaImage() = default;
+
+MediaMetadata::MediaImage::MediaImage(const MediaImage& other) = default;
+
+MediaMetadata::MediaImage::~MediaImage() = default;
+
+bool MediaMetadata::MediaImage::operator==(
+    const MediaMetadata::MediaImage& other) const {
+  return src == other.src && type == other.type && sizes == other.sizes;
+}
+
 MediaMetadata::MediaMetadata() = default;
 
 MediaMetadata::~MediaMetadata() = default;
@@ -16,16 +28,12 @@
 
 bool MediaMetadata::operator==(const MediaMetadata& other) const {
   return title == other.title && artist == other.artist &&
-         album == other.album && source_title == other.source_title;
+         album == other.album && artwork == other.artwork &&
+         source_title == other.source_title;
 }
 
 bool MediaMetadata::operator!=(const MediaMetadata& other) const {
   return !(*this == other);
 }
 
-bool MediaMetadata::IsEmpty() const {
-  return title.empty() && artist.empty() && album.empty() &&
-         source_title.empty();
-}
-
 }  // namespace media_session
--- a/services/media_session/public/cpp/media_metadata.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/media_session/public/cpp/media_metadata.h	2019-05-17 18:53:37.872000000 +0300
@@ -10,6 +10,7 @@
 #include "base/component_export.h"
 #include "base/strings/string16.h"
 #include "build/build_config.h"
+#include "ui/gfx/geometry/size.h"
 #include "url/gurl.h"
 
 #if defined(OS_ANDROID)
@@ -25,6 +26,30 @@
 // The MediaMetadata is a structure carrying information associated to a
 // MediaSession.
 struct COMPONENT_EXPORT(MEDIA_SESSION_CPP) MediaMetadata {
+  // Structure representing an MediaImage as per the MediaSession API, see:
+  // https://wicg.github.io/mediasession/#dictdef-mediaimage
+  struct COMPONENT_EXPORT(MEDIA_SESSION_CPP) MediaImage {
+    MediaImage();
+    MediaImage(const MediaImage& other);
+    ~MediaImage();
+
+    bool operator==(const MediaImage& other) const;
+
+    // MUST be a valid url. If an icon doesn't have a valid URL, it will not be
+    // successfully parsed, thus will not be represented in the Manifest.
+    GURL src;
+
+    // Empty if the parsing failed or the field was not present. The type can be
+    // any string and doesn't have to be a valid image MIME type at this point.
+    // It is up to the consumer of the object to check if the type matches a
+    // supported type.
+    base::string16 type;
+
+    // Empty if the parsing failed, the field was not present or empty.
+    // The special value "any" is represented by gfx::Size(0, 0).
+    std::vector<gfx::Size> sizes;
+  };
+
   MediaMetadata();
   ~MediaMetadata();
 
@@ -48,13 +73,13 @@
   // Album associated to the MediaSession.
   base::string16 album;
 
+  // Artwork associated to the MediaSession.
+  std::vector<MediaImage> artwork;
+
   // The |source_title| is a human readable title for the source of the media
   // session. This could be the name of the app or the name of the site playing
   // media.
   base::string16 source_title;
-
-  // Returns whether |this| contains no metadata.
-  bool IsEmpty() const;
 };
 
 }  // namespace media_session
--- a/services/media_session/public/cpp/media_session_mojom_traits.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/media_session/public/cpp/media_session_mojom_traits.cc	2019-05-17 18:53:37.872000000 +0300
@@ -5,7 +5,6 @@
 #include "services/media_session/public/cpp/media_session_mojom_traits.h"
 
 #include "mojo/public/cpp/base/string16_mojom_traits.h"
-#include "third_party/skia/include/core/SkBitmap.h"
 #include "ui/gfx/geometry/mojo/geometry_struct_traits.h"
 #include "url/mojom/url_gurl_mojom_traits.h"
 
@@ -13,9 +12,9 @@
 
 // static
 bool StructTraits<media_session::mojom::MediaImageDataView,
-                  media_session::MediaImage>::
+                  media_session::MediaMetadata::MediaImage>::
     Read(media_session::mojom::MediaImageDataView data,
-         media_session::MediaImage* out) {
+         media_session::MediaMetadata::MediaImage* out) {
   if (!data.ReadSrc(&out->src))
     return false;
   if (!data.ReadType(&out->type))
@@ -40,54 +39,13 @@
   if (!data.ReadAlbum(&out->album))
     return false;
 
+  if (!data.ReadArtwork(&out->artwork))
+    return false;
+
   if (!data.ReadSourceTitle(&out->source_title))
     return false;
 
   return true;
 }
 
-// static
-const base::span<const uint8_t>
-StructTraits<media_session::mojom::MediaImageBitmapDataView,
-             SkBitmap>::pixel_data(const SkBitmap& r) {
-  const SkImageInfo& info = r.info();
-  DCHECK_EQ(info.colorType(), kRGBA_8888_SkColorType);
-
-  return base::make_span(static_cast<uint8_t*>(r.getPixels()),
-                         r.computeByteSize());
-}
-
-// static
-bool StructTraits<media_session::mojom::MediaImageBitmapDataView, SkBitmap>::
-    Read(media_session::mojom::MediaImageBitmapDataView data, SkBitmap* out) {
-  mojo::ArrayDataView<uint8_t> pixel_data;
-  data.GetPixelDataDataView(&pixel_data);
-
-  SkImageInfo info = SkImageInfo::Make(
-      data.width(), data.height(), kRGBA_8888_SkColorType, kPremul_SkAlphaType);
-  if (info.computeByteSize(info.minRowBytes()) > pixel_data.size()) {
-    // Insufficient buffer size.
-    return false;
-  }
-
-  // Create the SkBitmap object which wraps the media image bitmap pixels.
-  // This doesn't copy and |data| and |bitmap| share the buffer.
-  SkBitmap bitmap;
-  if (!bitmap.installPixels(info, const_cast<uint8_t*>(pixel_data.data()),
-                            info.minRowBytes())) {
-    // Error in installing pixels.
-    return false;
-  }
-
-  // Copy the pixels into |out|.
-  return out->tryAllocPixels(info) &&
-         bitmap.readPixels(info, out->getPixels(), out->rowBytes(), 0, 0);
-}
-
-// static
-void StructTraits<media_session::mojom::MediaImageBitmapDataView,
-                  SkBitmap>::SetToNull(SkBitmap* out) {
-  out->reset();
-}
-
 }  // namespace mojo
--- a/services/media_session/public/cpp/media_session_mojom_traits.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/media_session/public/cpp/media_session_mojom_traits.h	2019-05-17 18:53:37.872000000 +0300
@@ -5,31 +5,30 @@
 #ifndef SERVICES_MEDIA_SESSION_PUBLIC_CPP_MEDIA_SESSION_MOJOM_TRAITS_H_
 #define SERVICES_MEDIA_SESSION_PUBLIC_CPP_MEDIA_SESSION_MOJOM_TRAITS_H_
 
-#include <vector>
-
-#include "base/containers/span.h"
 #include "services/media_session/public/mojom/media_session.mojom.h"
 
 namespace mojo {
 
 template <>
 struct StructTraits<media_session::mojom::MediaImageDataView,
-                    media_session::MediaImage> {
-  static const GURL& src(const media_session::MediaImage& image) {
+                    media_session::MediaMetadata::MediaImage> {
+  static const GURL& src(
+      const media_session::MediaMetadata::MediaImage& image) {
     return image.src;
   }
 
-  static const base::string16& type(const media_session::MediaImage& image) {
+  static const base::string16& type(
+      const media_session::MediaMetadata::MediaImage& image) {
     return image.type;
   }
 
   static const std::vector<gfx::Size>& sizes(
-      const media_session::MediaImage& image) {
+      const media_session::MediaMetadata::MediaImage& image) {
     return image.sizes;
   }
 
   static bool Read(media_session::mojom::MediaImageDataView data,
-                   media_session::MediaImage* out);
+                   media_session::MediaMetadata::MediaImage* out);
 };
 
 template <>
@@ -50,6 +49,11 @@
     return metadata.album;
   }
 
+  static const std::vector<media_session::MediaMetadata::MediaImage>& artwork(
+      const media_session::MediaMetadata& metadata) {
+    return metadata.artwork;
+  }
+
   static const base::string16& source_title(
       const media_session::MediaMetadata& metadata) {
     return metadata.source_title;
@@ -59,20 +63,6 @@
                    media_session::MediaMetadata* out);
 };
 
-// TODO(beccahughes): de-dupe this with ArcBitmap.
-template <>
-struct StructTraits<media_session::mojom::MediaImageBitmapDataView, SkBitmap> {
-  static const base::span<const uint8_t> pixel_data(const SkBitmap& r);
-  static int width(const SkBitmap& r) { return r.width(); }
-  static int height(const SkBitmap& r) { return r.height(); }
-
-  static bool Read(media_session::mojom::MediaImageBitmapDataView data,
-                   SkBitmap* out);
-
-  static bool IsNull(const SkBitmap& r) { return r.isNull(); }
-  static void SetToNull(SkBitmap* out);
-};
-
 }  // namespace mojo
 
 #endif  // SERVICES_MEDIA_SESSION_PUBLIC_CPP_MEDIA_SESSION_MOJOM_TRAITS_H_
--- a/services/media_session/public/cpp/media_session.typemap	2019-05-01 01:22:56.000000000 +0300
+++ b/services/media_session/public/cpp/media_session.typemap	2019-05-17 18:53:37.872000000 +0300
@@ -3,23 +3,17 @@
 # found in the LICENSE file.
 
 mojom = "//services/media_session/public/mojom/media_session.mojom"
-public_headers = [
-  "//services/media_session/public/cpp/media_image.h",
-  "//services/media_session/public/cpp/media_metadata.h",
-  "//third_party/skia/include/core/SkBitmap.h",
-]
+public_headers = [ "//services/media_session/public/cpp/media_metadata.h" ]
 traits_headers =
     [ "//services/media_session/public/cpp/media_session_mojom_traits.h" ]
 public_deps = [
   "//services/media_session/public/cpp",
-  "//skia",
 ]
 deps = [
   "//ui/gfx/geometry/mojo:struct_traits",
 ]
 type_mappings = [
-  "media_session.mojom.MediaImage=media_session::MediaImage",
-  "media_session.mojom.MediaImageBitmap=SkBitmap[nullable_is_same_type]",
+  "media_session.mojom.MediaImage=media_session::MediaMetadata::MediaImage",
   "media_session.mojom.MediaMetadata=media_session::MediaMetadata",
 ]
 sources = [
--- a/services/media_session/public/cpp/OWNERS	2019-05-01 01:22:56.000000000 +0300
+++ b/services/media_session/public/cpp/OWNERS	2019-05-17 18:53:37.872000000 +0300
@@ -2,7 +2,3 @@
 per-file *_mojom_traits*.*=file://ipc/SECURITY_OWNERS
 per-file *.typemap=set noparent
 per-file *.typemap=file://ipc/SECURITY_OWNERS
-per-file manifest.cc=set noparent
-per-file manifest.cc=file://ipc/SECURITY_OWNERS
-per-file manifest.h=set noparent
-per-file manifest.h=file://ipc/SECURITY_OWNERS
--- a/services/media_session/public/cpp/test/audio_focus_test_util.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/media_session/public/cpp/test/audio_focus_test_util.cc	2019-05-17 18:53:37.872000000 +0300
@@ -3,7 +3,6 @@
 // found in the LICENSE file.
 
 #include "services/media_session/public/cpp/test/audio_focus_test_util.h"
-#include "base/bind.h"
 
 namespace media_session {
 namespace test {
--- a/services/media_session/public/cpp/test/mock_media_session.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/media_session/public/cpp/test/mock_media_session.cc	2019-05-17 18:53:37.872000000 +0300
@@ -6,12 +6,24 @@
 
 #include <utility>
 
-#include "base/bind.h"
 #include "base/stl_util.h"
 
 namespace media_session {
 namespace test {
 
+namespace {
+
+bool IsMetadataNonEmpty(const base::Optional<MediaMetadata>& metadata) {
+  if (!metadata.has_value())
+    return false;
+
+  return !metadata->title.empty() || !metadata->artist.empty() ||
+         !metadata->album.empty() || !metadata->source_title.empty() ||
+         !metadata->artwork.empty();
+}
+
+}  // namespace
+
 MockMediaSessionMojoObserver::MockMediaSessionMojoObserver(
     mojom::MediaSession& media_session)
     : binding_(this) {
@@ -20,17 +32,21 @@
   media_session.AddObserver(std::move(observer));
 }
 
+MockMediaSessionMojoObserver::MockMediaSessionMojoObserver(
+    mojom::MediaControllerPtr& controller)
+    : binding_(this) {
+  mojom::MediaSessionObserverPtr observer;
+  binding_.Bind(mojo::MakeRequest(&observer));
+  controller->AddObserver(std::move(observer));
+}
+
 MockMediaSessionMojoObserver::~MockMediaSessionMojoObserver() = default;
 
 void MockMediaSessionMojoObserver::MediaSessionInfoChanged(
     mojom::MediaSessionInfoPtr session) {
   session_info_ = std::move(session);
 
-  if (expected_controllable_.has_value() &&
-      expected_controllable_ == session_info_->is_controllable) {
-    run_loop_->Quit();
-    expected_controllable_.reset();
-  } else if (wanted_state_ == session_info_->state ||
+  if (wanted_state_ == session_info_->state ||
              session_info_->playback_state == wanted_playback_state_) {
     run_loop_->Quit();
   }
@@ -40,41 +56,24 @@
     const base::Optional<MediaMetadata>& metadata) {
   session_metadata_ = metadata;
 
-  if (expected_metadata_.has_value() && expected_metadata_ == metadata) {
+  if (waiting_for_metadata_) {
     run_loop_->Quit();
-    expected_metadata_.reset();
-  } else if (waiting_for_empty_metadata_ &&
-             (!metadata.has_value() || metadata->IsEmpty())) {
+    waiting_for_metadata_ = false;
+  } else if (waiting_for_non_empty_metadata_ && IsMetadataNonEmpty(metadata)) {
     run_loop_->Quit();
-    waiting_for_empty_metadata_ = false;
+    waiting_for_non_empty_metadata_ = false;
   }
 }
 
 void MockMediaSessionMojoObserver::MediaSessionActionsChanged(
     const std::vector<mojom::MediaSessionAction>& actions) {
-  session_actions_ =
+  session_actions_ = actions;
+  session_actions_set_ =
       std::set<mojom::MediaSessionAction>(actions.begin(), actions.end());
 
-  if (expected_actions_.has_value() && expected_actions_ == session_actions_) {
+  if (waiting_for_actions_) {
     run_loop_->Quit();
-    expected_actions_.reset();
-  }
-}
-
-void MockMediaSessionMojoObserver::MediaSessionImagesChanged(
-    const base::flat_map<mojom::MediaSessionImageType, std::vector<MediaImage>>&
-        images) {
-  session_images_ = images;
-
-  if (expected_images_of_type_.has_value()) {
-    auto type = expected_images_of_type_->first;
-    auto images = expected_images_of_type_->second;
-    auto it = session_images_->find(type);
-
-    if (it != session_images_->end() && it->second == images) {
-      run_loop_->Quit();
-      expected_images_of_type_.reset();
-    }
+    waiting_for_actions_ = false;
   }
 }
 
@@ -96,54 +95,27 @@
   StartWaiting();
 }
 
-void MockMediaSessionMojoObserver::WaitForControllable(bool is_controllable) {
-  if (session_info_ && session_info_->is_controllable == is_controllable)
-    return;
-
-  expected_controllable_ = is_controllable;
+const base::Optional<MediaMetadata>&
+MockMediaSessionMojoObserver::WaitForMetadata() {
+  if (!session_metadata_.has_value()) {
+    waiting_for_metadata_ = true;
   StartWaiting();
-}
-
-void MockMediaSessionMojoObserver::WaitForEmptyMetadata() {
-  if (session_metadata_.has_value() || !session_metadata_->has_value())
-    return;
+  }
 
-  waiting_for_empty_metadata_ = true;
-  StartWaiting();
+  return session_metadata_.value();
 }
 
-void MockMediaSessionMojoObserver::WaitForExpectedMetadata(
-    const MediaMetadata& metadata) {
-  if (session_metadata_.has_value() && session_metadata_ == metadata)
-    return;
-
-  expected_metadata_ = metadata;
+const MediaMetadata& MockMediaSessionMojoObserver::WaitForNonEmptyMetadata() {
+  if (!session_metadata_.has_value() || !session_metadata_->has_value()) {
+    waiting_for_non_empty_metadata_ = true;
   StartWaiting();
-}
-
-void MockMediaSessionMojoObserver::WaitForEmptyActions() {
-  WaitForExpectedActions(std::set<mojom::MediaSessionAction>());
-}
-
-void MockMediaSessionMojoObserver::WaitForExpectedActions(
-    const std::set<mojom::MediaSessionAction>& actions) {
-  if (session_actions_.has_value() && session_actions_ == actions)
-    return;
+  }
 
-  expected_actions_ = actions;
-  StartWaiting();
+  return session_metadata_->value();
 }
 
-void MockMediaSessionMojoObserver::WaitForExpectedImagesOfType(
-    mojom::MediaSessionImageType type,
-    const std::vector<MediaImage>& images) {
-  if (session_images_.has_value()) {
-    auto it = session_images_->find(type);
-    if (it != session_images_->end() && it->second == images)
-      return;
-  }
-
-  expected_images_of_type_ = std::make_pair(type, images);
+void MockMediaSessionMojoObserver::WaitForActions() {
+  waiting_for_actions_ = true;
   StartWaiting();
 }
 
@@ -192,7 +164,6 @@
   std::vector<mojom::MediaSessionAction> actions(actions_.begin(),
                                                  actions_.end());
   observer->MediaSessionActionsChanged(actions);
-  observer->MediaSessionImagesChanged(images_);
 
   observers_.AddPtr(std::move(observer));
 }
@@ -224,20 +195,6 @@
   SetState(mojom::MediaSessionInfo::SessionState::kInactive);
 }
 
-void MockMediaSession::GetMediaImageBitmap(
-    const MediaImage& image,
-    int minimum_size_px,
-    int desired_size_px,
-    GetMediaImageBitmapCallback callback) {
-  last_image_src_ = image.src;
-
-  SkBitmap bitmap;
-  bitmap.allocPixels(
-      SkImageInfo::Make(10, 10, kRGBA_8888_SkColorType, kOpaque_SkAlphaType));
-
-  std::move(callback).Run(bitmap);
-}
-
 void MockMediaSession::SetIsControllable(bool value) {
   is_controllable_ = value;
   NotifyObservers();
@@ -347,23 +304,6 @@
   });
 }
 
-void MockMediaSession::ClearAllImages() {
-  images_.clear();
-
-  observers_.ForAllPtrs([this](mojom::MediaSessionObserver* observer) {
-    observer->MediaSessionImagesChanged(this->images_);
-  });
-}
-
-void MockMediaSession::SetImagesOfType(mojom::MediaSessionImageType type,
-                                       const std::vector<MediaImage>& images) {
-  images_.insert_or_assign(type, images);
-
-  observers_.ForAllPtrs([this](mojom::MediaSessionObserver* observer) {
-    observer->MediaSessionImagesChanged(this->images_);
-  });
-}
-
 void MockMediaSession::EnableAction(mojom::MediaSessionAction action) {
   if (base::ContainsKey(actions_, action))
     return;
--- a/services/media_session/public/cpp/test/mock_media_session.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/media_session/public/cpp/test/mock_media_session.h	2019-05-17 18:53:37.872000000 +0300
@@ -5,11 +5,7 @@
 #ifndef SERVICES_MEDIA_SESSION_PUBLIC_CPP_TEST_MOCK_MEDIA_SESSION_H_
 #define SERVICES_MEDIA_SESSION_PUBLIC_CPP_TEST_MOCK_MEDIA_SESSION_H_
 
-#include <utility>
-#include <vector>
-
 #include "base/component_export.h"
-#include "base/containers/flat_map.h"
 #include "base/optional.h"
 #include "base/run_loop.h"
 #include "mojo/public/cpp/bindings/binding.h"
@@ -31,7 +27,10 @@
 class COMPONENT_EXPORT(MEDIA_SESSION_TEST_SUPPORT_CPP)
     MockMediaSessionMojoObserver : public mojom::MediaSessionObserver {
  public:
+  // A MediaSessionObserver can observe a MediaSession directly or through a
+  // MediaController.
   explicit MockMediaSessionMojoObserver(mojom::MediaSession& media_session);
+  explicit MockMediaSessionMojoObserver(mojom::MediaControllerPtr& controller);
 
   ~MockMediaSessionMojoObserver() override;
 
@@ -41,23 +40,12 @@
       const base::Optional<MediaMetadata>& metadata) override;
   void MediaSessionActionsChanged(
       const std::vector<mojom::MediaSessionAction>& actions) override;
-  void MediaSessionImagesChanged(
-      const base::flat_map<mojom::MediaSessionImageType,
-                           std::vector<MediaImage>>& images) override;
 
   void WaitForState(mojom::MediaSessionInfo::SessionState wanted_state);
   void WaitForPlaybackState(mojom::MediaPlaybackState wanted_state);
-  void WaitForControllable(bool is_controllable);
-
-  void WaitForEmptyMetadata();
-  void WaitForExpectedMetadata(const MediaMetadata& metadata);
-
-  void WaitForEmptyActions();
-  void WaitForExpectedActions(
-      const std::set<mojom::MediaSessionAction>& actions);
-
-  void WaitForExpectedImagesOfType(mojom::MediaSessionImageType type,
-                                   const std::vector<MediaImage>& images);
+  const base::Optional<MediaMetadata>& WaitForMetadata();
+  const MediaMetadata& WaitForNonEmptyMetadata();
+  void WaitForActions();
 
   const mojom::MediaSessionInfoPtr& session_info() const {
     return session_info_;
@@ -68,8 +56,12 @@
     return session_metadata_;
   }
 
-  const std::set<mojom::MediaSessionAction>& actions() const {
-    return *session_actions_;
+  const std::vector<mojom::MediaSessionAction>& actions() const {
+    return session_actions_;
+  }
+
+  const std::set<mojom::MediaSessionAction>& actions_set() const {
+    return session_actions_set_;
   }
 
  private:
@@ -77,18 +69,12 @@
 
   mojom::MediaSessionInfoPtr session_info_;
   base::Optional<base::Optional<MediaMetadata>> session_metadata_;
-  base::Optional<std::set<mojom::MediaSessionAction>> session_actions_;
-  base::Optional<
-      base::flat_map<mojom::MediaSessionImageType, std::vector<MediaImage>>>
-      session_images_;
-
-  base::Optional<MediaMetadata> expected_metadata_;
-  base::Optional<std::set<mojom::MediaSessionAction>> expected_actions_;
-  base::Optional<bool> expected_controllable_;
-  base::Optional<
-      std::pair<mojom::MediaSessionImageType, std::vector<MediaImage>>>
-      expected_images_of_type_;
-  bool waiting_for_empty_metadata_ = false;
+  std::vector<mojom::MediaSessionAction> session_actions_;
+  std::set<mojom::MediaSessionAction> session_actions_set_;
+
+  bool waiting_for_metadata_ = false;
+  bool waiting_for_non_empty_metadata_ = false;
+  bool waiting_for_actions_ = false;
 
   base::Optional<mojom::MediaSessionInfo::SessionState> wanted_state_;
   base::Optional<mojom::MediaPlaybackState> wanted_playback_state_;
@@ -117,15 +103,12 @@
   void GetDebugInfo(GetDebugInfoCallback callback) override;
   void PreviousTrack() override;
   void NextTrack() override;
-  void SkipAd() override {}
+  void SkipAd() override{};
   void Seek(base::TimeDelta seek_time) override;
   void Stop(SuspendType type) override;
-  void GetMediaImageBitmap(const MediaImage& image,
-                           int minimum_size_px,
-                           int desired_size_px,
-                           GetMediaImageBitmapCallback callback) override;
 
   void SetIsControllable(bool value);
+
   void SetPreferStop(bool value) { prefer_stop_ = value; }
 
   void AbandonAudioFocusFromClient();
@@ -149,10 +132,6 @@
 
   void SimulateMetadataChanged(const base::Optional<MediaMetadata>& metadata);
 
-  void ClearAllImages();
-  void SetImagesOfType(mojom::MediaSessionImageType type,
-                       const std::vector<MediaImage>& images);
-
   void EnableAction(mojom::MediaSessionAction action);
   void DisableAction(mojom::MediaSessionAction action);
 
@@ -161,8 +140,6 @@
   int add_observer_count() const { return add_observer_count_; }
   int seek_count() const { return seek_count_; }
 
-  const GURL& last_image_src() const { return last_image_src_; }
-
  private:
   void SetState(mojom::MediaSessionInfo::SessionState);
   void NotifyObservers();
@@ -186,9 +163,6 @@
   mojom::MediaSessionInfo::SessionState state_ =
       mojom::MediaSessionInfo::SessionState::kInactive;
 
-  base::flat_map<mojom::MediaSessionImageType, std::vector<MediaImage>> images_;
-  GURL last_image_src_;
-
   mojo::BindingSet<mojom::MediaSession> bindings_;
 
   mojo::InterfacePtrSet<mojom::MediaSessionObserver> observers_;
--- a/services/media_session/public/cpp/test/test_media_controller.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/media_session/public/cpp/test/test_media_controller.cc	2019-05-17 18:53:37.872000000 +0300
@@ -7,163 +7,6 @@
 namespace media_session {
 namespace test {
 
-TestMediaControllerImageObserver::TestMediaControllerImageObserver(
-    mojom::MediaControllerPtr& controller,
-    int minimum_size_px,
-    int desired_size_px) {
-  mojom::MediaControllerImageObserverPtr ptr;
-  binding_.Bind(mojo::MakeRequest(&ptr));
-
-  controller->ObserveImages(mojom::MediaSessionImageType::kArtwork,
-                            minimum_size_px, desired_size_px, std::move(ptr));
-  controller.FlushForTesting();
-}
-
-TestMediaControllerImageObserver::~TestMediaControllerImageObserver() = default;
-
-void TestMediaControllerImageObserver::MediaControllerImageChanged(
-    mojom::MediaSessionImageType type,
-    const SkBitmap& bitmap) {
-  current_ = ImageTypePair(type, bitmap.isNull());
-
-  if (!expected_.has_value() || expected_ != current_)
-    return;
-
-  DCHECK(run_loop_);
-  run_loop_->Quit();
-  expected_.reset();
-}
-
-void TestMediaControllerImageObserver::WaitForExpectedImageOfType(
-    mojom::MediaSessionImageType type,
-    bool expect_null_image) {
-  ImageTypePair pair(type, expect_null_image);
-
-  if (current_ == pair)
-    return;
-
-  expected_ = pair;
-
-  DCHECK(!run_loop_);
-  run_loop_ = std::make_unique<base::RunLoop>();
-  run_loop_->Run();
-  run_loop_.reset();
-}
-
-TestMediaControllerObserver::TestMediaControllerObserver(
-    mojom::MediaControllerPtr& media_controller)
-    : binding_(this) {
-  mojom::MediaControllerObserverPtr observer;
-  binding_.Bind(mojo::MakeRequest(&observer));
-  media_controller->AddObserver(std::move(observer));
-}
-
-TestMediaControllerObserver::~TestMediaControllerObserver() = default;
-
-void TestMediaControllerObserver::MediaSessionInfoChanged(
-    mojom::MediaSessionInfoPtr session) {
-  session_info_ = std::move(session);
-
-  if (session_info_.has_value() && !session_info_->is_null()) {
-    if (wanted_state_ == session_info()->state ||
-        session_info()->playback_state == wanted_playback_state_) {
-      run_loop_->Quit();
-    }
-  } else if (waiting_for_empty_info_) {
-    waiting_for_empty_info_ = false;
-    run_loop_->Quit();
-  }
-}
-
-void TestMediaControllerObserver::MediaSessionMetadataChanged(
-    const base::Optional<MediaMetadata>& metadata) {
-  session_metadata_ = metadata;
-
-  if (expected_metadata_.has_value() && expected_metadata_ == metadata) {
-    run_loop_->Quit();
-    expected_metadata_.reset();
-  } else if (waiting_for_empty_metadata_ &&
-             (!metadata.has_value() || metadata->IsEmpty())) {
-    run_loop_->Quit();
-    waiting_for_empty_metadata_ = false;
-  }
-}
-
-void TestMediaControllerObserver::MediaSessionActionsChanged(
-    const std::vector<mojom::MediaSessionAction>& actions) {
-  session_actions_ =
-      std::set<mojom::MediaSessionAction>(actions.begin(), actions.end());
-
-  if (expected_actions_.has_value() && expected_actions_ == session_actions_) {
-    run_loop_->Quit();
-    expected_actions_.reset();
-  }
-}
-
-void TestMediaControllerObserver::WaitForState(
-    mojom::MediaSessionInfo::SessionState wanted_state) {
-  if (session_info_ && session_info()->state == wanted_state)
-    return;
-
-  wanted_state_ = wanted_state;
-  StartWaiting();
-}
-
-void TestMediaControllerObserver::WaitForPlaybackState(
-    mojom::MediaPlaybackState wanted_state) {
-  if (session_info_ && session_info()->playback_state == wanted_state)
-    return;
-
-  wanted_playback_state_ = wanted_state;
-  StartWaiting();
-}
-
-void TestMediaControllerObserver::WaitForEmptyInfo() {
-  if (session_info_.has_value() && session_info_->is_null())
-    return;
-
-  waiting_for_empty_info_ = true;
-  StartWaiting();
-}
-
-void TestMediaControllerObserver::WaitForEmptyMetadata() {
-  if (session_metadata_.has_value())
-    return;
-
-  waiting_for_empty_metadata_ = true;
-  StartWaiting();
-}
-
-void TestMediaControllerObserver::WaitForExpectedMetadata(
-    const MediaMetadata& metadata) {
-  if (session_metadata_.has_value() && session_metadata_ == metadata)
-    return;
-
-  expected_metadata_ = metadata;
-  StartWaiting();
-}
-
-void TestMediaControllerObserver::WaitForEmptyActions() {
-  WaitForExpectedActions(std::set<mojom::MediaSessionAction>());
-}
-
-void TestMediaControllerObserver::WaitForExpectedActions(
-    const std::set<mojom::MediaSessionAction>& actions) {
-  if (session_actions_.has_value() && session_actions_ == actions)
-    return;
-
-  expected_actions_ = actions;
-  StartWaiting();
-}
-
-void TestMediaControllerObserver::StartWaiting() {
-  DCHECK(!run_loop_);
-
-  run_loop_ = std::make_unique<base::RunLoop>();
-  run_loop_->Run();
-  run_loop_.reset();
-}
-
 TestMediaController::TestMediaController() = default;
 
 TestMediaController::~TestMediaController() = default;
@@ -186,8 +29,7 @@
   ++toggle_suspend_resume_count_;
 }
 
-void TestMediaController::AddObserver(
-    mojom::MediaControllerObserverPtr observer) {
+void TestMediaController::AddObserver(mojom::MediaSessionObserverPtr observer) {
   ++add_observer_count_;
   observers_.AddPtr(std::move(observer));
 }
@@ -210,17 +52,9 @@
   }
 }
 
-void TestMediaController::SimulateMediaSessionInfoChanged(
-    mojom::MediaSessionInfoPtr session_info) {
-  observers_.ForAllPtrs(
-      [&session_info](mojom::MediaControllerObserver* observer) {
-        observer->MediaSessionInfoChanged(session_info.Clone());
-      });
-}
-
 void TestMediaController::SimulateMediaSessionActionsChanged(
     const std::vector<mojom::MediaSessionAction>& actions) {
-  observers_.ForAllPtrs([&actions](mojom::MediaControllerObserver* observer) {
+  observers_.ForAllPtrs([&actions](mojom::MediaSessionObserver* observer) {
     observer->MediaSessionActionsChanged(actions);
   });
 }
--- a/services/media_session/public/cpp/test/test_media_controller.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/media_session/public/cpp/test/test_media_controller.h	2019-05-17 18:53:37.872000000 +0300
@@ -5,107 +5,14 @@
 #ifndef SERVICES_MEDIA_SESSION_PUBLIC_CPP_TEST_TEST_MEDIA_CONTROLLER_H_
 #define SERVICES_MEDIA_SESSION_PUBLIC_CPP_TEST_TEST_MEDIA_CONTROLLER_H_
 
-#include <utility>
-
 #include "base/component_export.h"
-#include "base/run_loop.h"
 #include "mojo/public/cpp/bindings/binding.h"
 #include "mojo/public/cpp/bindings/interface_ptr_set.h"
 #include "services/media_session/public/mojom/media_controller.mojom.h"
-#include "services/media_session/public/mojom/media_session.mojom.h"
 
 namespace media_session {
 namespace test {
 
-// A mock MediaControllerImageObserver than can be used for waiting for images.
-class COMPONENT_EXPORT(MEDIA_SESSION_TEST_SUPPORT_CPP)
-    TestMediaControllerImageObserver
-    : public mojom::MediaControllerImageObserver {
- public:
-  TestMediaControllerImageObserver(mojom::MediaControllerPtr& controller,
-                                   int minimum_size_px,
-                                   int desired_size_px);
-  ~TestMediaControllerImageObserver() override;
-
-  // mojom::MediaControllerImageObserver overrides.
-  void MediaControllerImageChanged(mojom::MediaSessionImageType type,
-                                   const SkBitmap& bitmap) override;
-
-  void WaitForExpectedImageOfType(mojom::MediaSessionImageType type,
-                                  bool expect_null_value);
-
- private:
-  // The bool is whether the image type should be a null value.
-  using ImageTypePair = std::pair<mojom::MediaSessionImageType, bool>;
-
-  std::unique_ptr<base::RunLoop> run_loop_;
-
-  base::Optional<ImageTypePair> expected_;
-  base::Optional<ImageTypePair> current_;
-
-  mojo::Binding<mojom::MediaControllerImageObserver> binding_{this};
-};
-
-// A mock MediaControllerObsever that can be used for waiting for state changes.
-class COMPONENT_EXPORT(MEDIA_SESSION_TEST_SUPPORT_CPP)
-    TestMediaControllerObserver : public mojom::MediaControllerObserver {
- public:
-  explicit TestMediaControllerObserver(
-      mojom::MediaControllerPtr& media_controller);
-
-  ~TestMediaControllerObserver() override;
-
-  // mojom::MediaControllerObserver overrides.
-  void MediaSessionInfoChanged(mojom::MediaSessionInfoPtr session) override;
-  void MediaSessionMetadataChanged(
-      const base::Optional<MediaMetadata>& metadata) override;
-  void MediaSessionActionsChanged(
-      const std::vector<mojom::MediaSessionAction>& actions) override;
-
-  void WaitForState(mojom::MediaSessionInfo::SessionState wanted_state);
-  void WaitForPlaybackState(mojom::MediaPlaybackState wanted_state);
-  void WaitForEmptyInfo();
-
-  void WaitForEmptyMetadata();
-  void WaitForExpectedMetadata(const MediaMetadata& metadata);
-
-  void WaitForEmptyActions();
-  void WaitForExpectedActions(
-      const std::set<mojom::MediaSessionAction>& actions);
-
-  const mojom::MediaSessionInfoPtr& session_info() const {
-    return *session_info_;
-  }
-
-  const base::Optional<base::Optional<MediaMetadata>>& session_metadata()
-      const {
-    return session_metadata_;
-  }
-
-  const std::set<mojom::MediaSessionAction>& actions() const {
-    return *session_actions_;
-  }
-
- private:
-  void StartWaiting();
-
-  base::Optional<mojom::MediaSessionInfoPtr> session_info_;
-  base::Optional<base::Optional<MediaMetadata>> session_metadata_;
-  base::Optional<std::set<mojom::MediaSessionAction>> session_actions_;
-
-  base::Optional<MediaMetadata> expected_metadata_;
-  base::Optional<std::set<mojom::MediaSessionAction>> expected_actions_;
-  bool waiting_for_empty_metadata_ = false;
-
-  bool waiting_for_empty_info_ = false;
-  base::Optional<mojom::MediaSessionInfo::SessionState> wanted_state_;
-  base::Optional<mojom::MediaPlaybackState> wanted_playback_state_;
-
-  std::unique_ptr<base::RunLoop> run_loop_;
-
-  mojo::Binding<mojom::MediaControllerObserver> binding_;
-};
-
 // Implements the MediaController mojo interface for tests.
 class COMPONENT_EXPORT(MEDIA_SESSION_TEST_SUPPORT_CPP) TestMediaController
     : public mojom::MediaController {
@@ -120,15 +27,10 @@
   void Resume() override;
   void Stop() override {}
   void ToggleSuspendResume() override;
-  void AddObserver(mojom::MediaControllerObserverPtr observer) override;
+  void AddObserver(mojom::MediaSessionObserverPtr observer) override;
   void PreviousTrack() override;
   void NextTrack() override;
   void Seek(base::TimeDelta seek_time) override;
-  void ObserveImages(mojom::MediaSessionImageType type,
-                     int minimum_size_px,
-                     int desired_size_px,
-                     mojom::MediaControllerImageObserverPtr observer) override {
-  }
 
   int toggle_suspend_resume_count() const {
     return toggle_suspend_resume_count_;
@@ -142,7 +44,6 @@
   int seek_backward_count() const { return seek_backward_count_; }
   int seek_forward_count() const { return seek_forward_count_; }
 
-  void SimulateMediaSessionInfoChanged(mojom::MediaSessionInfoPtr session_info);
   void SimulateMediaSessionActionsChanged(
       const std::vector<mojom::MediaSessionAction>& actions);
   void Flush();
@@ -157,7 +58,7 @@
   int seek_backward_count_ = 0;
   int seek_forward_count_ = 0;
 
-  mojo::InterfacePtrSet<mojom::MediaControllerObserver> observers_;
+  mojo::InterfacePtrSet<mojom::MediaSessionObserver> observers_;
 
   mojo::Binding<mojom::MediaController> binding_{this};
 
--- a/services/media_session/public/mojom/audio_focus.mojom	2019-05-01 01:22:56.000000000 +0300
+++ b/services/media_session/public/mojom/audio_focus.mojom	2019-05-17 18:53:37.872000000 +0300
@@ -47,10 +47,6 @@
   // Request transient focus when you expect to play audio for only a short
   // time and you expect the previous holder to pause playing.
   kGainTransient,
-
-  // Request audio focus for playback can be mixed with other types of audio.
-  // It has no effect on other holders of audio focus.
-  kAmbient,
 };
 
 // Contains information about |MediaSessions| that have requested audio focus
--- a/services/media_session/public/mojom/media_controller.mojom	2019-05-01 01:22:56.000000000 +0300
+++ b/services/media_session/public/mojom/media_controller.mojom	2019-05-17 18:53:37.872000000 +0300
@@ -40,7 +40,7 @@
   // Adds an observer that will forward events from the active media session.
   // If the active session changes then observers do not need to be readded.
   // Adding the observer will update the observer with the latest state.
-  AddObserver(MediaControllerObserver observer);
+  AddObserver(MediaSessionObserver observer);
 
   // Skip to the previous track. If there is no previous track then this will be
   // a no-op.
@@ -56,40 +56,4 @@
   // The |kDefaultSeekTimeSeconds| provides a default value for seeking by a
   // few seconds.
   Seek(mojo_base.mojom.TimeDelta seek_time);
-
-  // Creates an image observer that will be notified when the image of |type|
-  // for the underlying media session has changed. The image will be at least
-  // |minimum_size_pc| and closest to |desired_size_px|.
-  ObserveImages(
-      MediaSessionImageType type, int32 minimum_size_px, int32 desired_size_px,
-      MediaControllerImageObserver observer);
-};
-
-// The observer for observing media controller events. This is different to a
-// MediaSessionObserver because a media controller can have nullable session
-// info which will be null if it is not bound to a media session. This would
-// be invalid for a media session because it must always have some state.
-interface MediaControllerObserver {
-  // Called when the state of the bound media session changes. If |info| is
-  // empty then the controller is no longer bound to a media session.
-  MediaSessionInfoChanged(MediaSessionInfo? info);
-
-  // Called when the bound media session has changed metadata. If |metadata|
-  // is null then it can be reset, e.g. the media that ws being played has
-  // been stopped.
-  MediaSessionMetadataChanged(MediaMetadata? metadata);
-
-  // Called when the bound media session action list has changed. This tells
-  // the observer which actions can be used to control the session.
-  MediaSessionActionsChanged(array<MediaSessionAction> action);
-};
-
-// The observer for observing when images associated with a media controller
-// change. This is a separate observer because not all clients need to handle
-// images.
-interface MediaControllerImageObserver {
-  // Called when the observed media controller has a new image of |type|.
-  // It may be null if there is no image.
-  MediaControllerImageChanged(
-      MediaSessionImageType type, MediaImageBitmap? bitmap);
 };
--- a/services/media_session/public/mojom/media_session.mojom	2019-05-01 01:22:56.000000000 +0300
+++ b/services/media_session/public/mojom/media_session.mojom	2019-05-17 18:53:37.872000000 +0300
@@ -29,12 +29,6 @@
   kStop,
 };
 
-[Extensible]
-enum MediaSessionImageType {
-  // The artwork associated with the media session (e.g album art)
-  kArtwork,
-};
-
 // Album art in MediaMetadata
 // Spec: https://wicg.github.io/mediasession/
 struct MediaImage {
@@ -49,6 +43,7 @@
   mojo_base.mojom.String16 title;
   mojo_base.mojom.String16 artist;
   mojo_base.mojom.String16 album;
+  array<MediaImage> artwork;
 
   // The |source_title| is a human readable title for the source of the media
   // session. This could be the name of the app or the name of the site playing
@@ -56,15 +51,6 @@
   mojo_base.mojom.String16 source_title;
 };
 
-// A bitmap image. We use this instead of SkImage or skia.image.Bitmap so we can
-// use it in ARC and we do not use ArcBitmap because we need to use it in the
-// service.
-struct MediaImageBitmap {
-  int32 width;
-  int32 height;
-  array<uint8> pixel_data;  // Must be ARGB_8888
-};
-
 // Contains state information about a MediaSession.
 struct MediaSessionInfo {
   [Extensible]
@@ -115,7 +101,7 @@
 };
 
 // The observer for observing media session events.
-// Next Method ID: 4
+// Next Method ID: 1
 interface MediaSessionObserver {
   // Call when the info associated with the session changed.
   MediaSessionInfoChanged@0(MediaSessionInfo info);
@@ -128,17 +114,13 @@
   // Called when the media session action list has changed. This tells the
   // observer which actions can be used to control the session.
   MediaSessionActionsChanged@2(array<MediaSessionAction> action);
-
-  // Called when the images associated with a media session change.
-  MediaSessionImagesChanged@3(
-      map<MediaSessionImageType, array<MediaImage>> images);
 };
 
 // A MediaSession manages the media session and audio focus for a given
 // WebContents or ARC app.
 // TODO(https://crbug.com/875004): migrate media session from content/public
 // to mojo.
-// Next Method ID: 13
+// Next Method ID: 12
 interface MediaSession {
   [Extensible]
   enum SuspendType {
@@ -195,12 +177,4 @@
 
   // Skip ad.
   SkipAd@11();
-
-  // Gets/Downloads the bitmap version of a MediaImage at least
-  // |minimum_size_px| and closest to |desired_size_px|. If the download
-  // failed, was too small or the image did not come from the media session
-  // then returns a null image.
-  GetMediaImageBitmap@12(
-      MediaImage image, int32 minimum_size_px, int32 desired_size_px)
-          => (MediaImageBitmap? image);
 };
--- a/services/metrics/BUILD.gn	2019-05-01 01:22:56.000000000 +0300
+++ b/services/metrics/BUILD.gn	2019-05-17 18:53:37.872000000 +0300
@@ -2,6 +2,13 @@
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
+import("//services/service_manager/public/service_manifest.gni")
+
+service_manifest("manifest") {
+  name = "metrics"
+  source = "manifest.json"
+}
+
 source_set("metrics") {
   sources = [
     "metrics_mojo_service.cc",
--- a/services/metrics/metrics_mojo_service.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/metrics/metrics_mojo_service.cc	2019-05-17 18:53:37.872000000 +0300
@@ -4,7 +4,6 @@
 
 #include <memory>
 
-#include "base/bind.h"
 #include "base/callback.h"
 #include "base/macros.h"
 #include "services/metrics/public/cpp/ukm_recorder.h"
--- a/services/metrics/OWNERS	2019-05-01 01:22:56.000000000 +0300
+++ b/services/metrics/OWNERS	2019-05-17 18:53:37.872000000 +0300
@@ -1,4 +1,6 @@
 file://base/metrics/OWNERS
 
+per-file manifest.json=set noparent
+per-file manifest.json=file://ipc/SECURITY_OWNERS
 
 # COMPONENT: Internals>Metrics
--- a/services/metrics/public/cpp/BUILD.gn	2019-05-01 01:22:56.000000000 +0300
+++ b/services/metrics/public/cpp/BUILD.gn	2019-05-17 18:53:37.872000000 +0300
@@ -97,16 +97,3 @@
     "//base",
   ]
 }
-
-source_set("manifest") {
-  sources = [
-    "manifest.cc",
-    "manifest.h",
-  ]
-
-  deps = [
-    "//base",
-    "//services/metrics/public/mojom",
-    "//services/service_manager/public/cpp",
-  ]
-}
--- a/services/metrics/public/cpp/delegating_ukm_recorder.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/metrics/public/cpp/delegating_ukm_recorder.cc	2019-05-17 18:53:37.876000000 +0300
@@ -5,7 +5,6 @@
 #include "services/metrics/public/cpp/delegating_ukm_recorder.h"
 #include "services/metrics/public/cpp/ukm_source_id.h"
 
-#include "base/bind.h"
 #include "base/lazy_instance.h"
 
 namespace ukm {
--- a/services/metrics/public/cpp/metrics_utils_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/metrics/public/cpp/metrics_utils_unittest.cc	2019-05-17 18:53:37.876000000 +0300
@@ -61,31 +61,3 @@
         << " with bucket_size: " << test.bucket_size;
   }
 }
-
-TEST(MetricsUtilsTest, GetExponentialBucketMinForUserTiming) {
-  struct {
-    int64_t expected_result;
-    int64_t sample;
-  } int_test_cases[] = {
-      // Typical positive cases.
-      {1, 1},
-      {32, 38},
-      {32, 51},
-      {64, 99},
-      {16, 25},
-      {512, 1023},
-      {1024, 1024},
-      {1024, 1025},
-      // Negative samples.
-      {0, -45},
-      // Zero samples.
-      {0, 0},
-  };
-
-  // Test int64_t sample cases.
-  for (const auto& test : int_test_cases) {
-    EXPECT_EQ(test.expected_result,
-              ukm::GetExponentialBucketMinForUserTiming(test.sample))
-        << "For sample: " << test.sample;
-  }
-}
--- a/services/metrics/public/cpp/ukm_recorder.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/metrics/public/cpp/ukm_recorder.h	2019-05-17 18:53:37.876000000 +0300
@@ -14,7 +14,7 @@
 #include "services/metrics/public/cpp/metrics_export.h"
 #include "services/metrics/public/cpp/ukm_source.h"
 #include "services/metrics/public/cpp/ukm_source_id.h"
-#include "services/metrics/public/mojom/ukm_interface.mojom-forward.h"
+#include "services/metrics/public/mojom/ukm_interface.mojom.h"
 #include "url/gurl.h"
 
 class BackgroundFetchDelegateImpl;
@@ -95,7 +95,7 @@
   virtual void AddEntry(mojom::UkmEntryPtr entry) = 0;
 
   // Disables sampling for testing purposes.
-  virtual void DisableSamplingForTesting() {}
+  virtual void DisableSamplingForTesting(){};
 
  protected:
   // Type-safe wrappers for Update<X> functions.
--- a/services/metrics/public/cpp/ukm_source.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/metrics/public/cpp/ukm_source.cc	2019-05-17 18:53:37.876000000 +0300
@@ -58,12 +58,8 @@
   NavigationData sanitized_navigation_data;
   sanitized_navigation_data.urls = std::move(sanitized_urls);
   sanitized_navigation_data.previous_source_id = previous_source_id;
-  sanitized_navigation_data.previous_same_document_source_id =
-      previous_same_document_source_id;
   sanitized_navigation_data.opener_source_id = opener_source_id;
   sanitized_navigation_data.tab_id = tab_id;
-  sanitized_navigation_data.is_same_document_navigation =
-      is_same_document_navigation;
   return sanitized_navigation_data;
 }
 
@@ -114,11 +110,6 @@
   if (navigation_data_.previous_source_id != kInvalidSourceId)
     proto_source->set_previous_source_id(navigation_data_.previous_source_id);
 
-  if (navigation_data_.previous_same_document_source_id != kInvalidSourceId) {
-    proto_source->set_previous_same_document_source_id(
-        navigation_data_.previous_same_document_source_id);
-  }
-
   if (navigation_data_.opener_source_id != kInvalidSourceId)
     proto_source->set_opener_source_id(navigation_data_.opener_source_id);
 
@@ -126,9 +117,6 @@
   // source_url_recorder.cc
   if (navigation_data_.tab_id != 0)
     proto_source->set_tab_id(navigation_data_.tab_id);
-
-  if (navigation_data_.is_same_document_navigation)
-    proto_source->set_is_same_document_navigation(true);
 }
 
 }  // namespace ukm
--- a/services/metrics/public/cpp/ukm_source.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/metrics/public/cpp/ukm_source.h	2019-05-17 18:53:37.876000000 +0300
@@ -61,12 +61,6 @@
     // The previous source id for this tab.
     SourceId previous_source_id = kInvalidSourceId;
 
-    // The source id for the previous same document navigation, if the
-    // previously committed source was a same document navigation. If
-    // the previously committed source was not a same document
-    // navigation, this field will be set to kInvalidSourceId.
-    SourceId previous_same_document_source_id = kInvalidSourceId;
-
     // The source id for the source which opened this tab. This should be set to
     // kInvalidSourceId for all but the first navigation in the tab.
     SourceId opener_source_id = kInvalidSourceId;
@@ -74,11 +68,6 @@
     // A unique identifier for the tab the source navigated in. Tab ids should
     // be increasing over time within a session.
     int64_t tab_id = 0;
-
-    // Whether this source is for a same document navigation. Examples of same
-    // document navigations are fragment navigations, pushState/replaceState,
-    // and same page history navigation.
-    bool is_same_document_navigation = false;
   };
 
   UkmSource(SourceId id, const GURL& url);
--- a/services/metrics/ukm_api.md	2019-05-01 01:22:56.000000000 +0300
+++ b/services/metrics/ukm_api.md	2019-05-17 18:53:37.876000000 +0300
@@ -34,89 +34,6 @@
 </event>
 ```
 
-### Controlling the Aggregation of Metrics
-
-Control of which metrics are included in the History table is done via the same
-[`tools/metrics/ukm/ukm.xml`](https://cs.chromium.org/chromium/btools/metrics/ukm/ukm.xml)
-file in the Chromium codebase. To have a metric aggregated, `<aggregation>` and
-`<history>` tags need to be added.
-
-```
-<event name="Goat.Teleported">
-  <metric name="Duration">
-    ...
-    <aggregation>
-      <history>
-        <index fields="profile.country"/>
-        <statistics>
-          <quantiles type="std-percentiles"/>
-        </statistics>
-      </history>
-    </aggregation>
-    ...
-  </metric>
-</event>
-```
-
-Supported statistic types are:
-
-*   `<quantiles type="std-percentiles"/>`: Calculates the "standard percentiles"
-    for the values which are 1, 5, 10, 25, 50, 75, 90, 95, and 99%ile.
-*   `<enumeration/>`: Calculates the proportions of all values individually. The
-    proportions indicate the relative frequency of each bucket and are
-    calculated independently for each metric over each aggregation. (Details
-    below.)
-
-There can also be one or more `index` tags which define additional aggregation
-keys. These are a comma-separated list of keys that is appended to the standard
-set. These additional keys are optional but, if present, are always present
-together. In other words, "fields=profile.county,profile.form_factory" will
-cause all the standard aggregations plus each with *both* country *and*
-form_factor but **not** with all the standard aggregations (see above) plus only
-one of them. If individual and combined versions are desired, use multiple index
-tags.
-
-Currently supported additional index fields are:
-
-*   `profile.country`
-*   `profile.form_factor`
-
-## Enumeration Proportions
-
-Porportions are calculated against the number of "page loads" (meaning per
-"source" which is usually but not always the same as a browser page load) that
-emitted one or more values for the enumeration.  The proportions will sum to 1.0
-for an enumeration that emits only one result per page-load if it emits anything
-at all. An enumeration emitted more than once per source will result in
-proportions that total greater than 1.0 but are still relative to the total
-number of loads.
-
-For example, `Security.SiteEngagement` emits one value (either 4 or 2) per source:
-
-*   https://www.google.com/ : 4
-*   https://www.facebook.com/ : 2
-*   https://www.wikipedia.com/ : 4
-
-A proportion calculated over all sources would sum to 1.0:
-
-*   2 (0.3333)
-*   4 (0.6667)
-
-In contrast, `Blink.UseCounter.Feature` emits multiple values per source:
-
-*   https://www.google.com/ : 1, 2, 4, 6
-*   https://www.facebook.com/ : 2, 4, 5
-*   https://www.wikipedia.com/ : 1, 2, 4
-
-A proportion calculated over all sources would be:
-
-*   1 (0.6667)
-*   2 (1.0000)
-*   3 (absent)
-*   4 (1.0000)
-*   5 (0.3333)
-*   6 (0.3333)
-
 ## Get UkmRecorder instance
 
 In order to record UKM events, your code needs a UkmRecorder object, defined by [//services/metrics/public/cpp/ukm_recorder.h](https://cs.chromium.org/chromium/bservices/metrics/public/cpp/ukm_recorder.h)
--- a/services/network/BUILD.gn	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/BUILD.gn	2019-05-17 18:53:37.876000000 +0300
@@ -6,6 +6,7 @@
 import("//mojo/public/tools/bindings/mojom.gni")
 import("//net/features.gni")
 import("//services/network/public/cpp/features.gni")
+import("//services/service_manager/public/service_manifest.gni")
 
 jumbo_component("network_service") {
   sources = [
@@ -17,8 +18,6 @@
     "conditional_cache_deletion_helper.h",
     "cookie_manager.cc",
     "cookie_manager.h",
-    "cookie_managers_shared.cc",
-    "cookie_managers_shared.h",
     "cookie_settings.cc",
     "cookie_settings.h",
     "cors/cors_url_loader.cc",
@@ -270,13 +269,6 @@
   if (is_chromecast) {
     defines += [ "IS_CHROMECAST" ]
   }
-
-  if (trial_comparison_cert_verifier_supported) {
-    sources += [
-      "trial_comparison_cert_verifier_mojo.cc",
-      "trial_comparison_cert_verifier_mojo.h",
-    ]
-  }
 }
 
 source_set("tests") {
@@ -402,8 +394,6 @@
   sources = [
     "mojo_socket_test_util.cc",
     "mojo_socket_test_util.h",
-    "test/test_cookie_manager.cc",
-    "test/test_cookie_manager.h",
     "test/test_data_pipe_getter.cc",
     "test/test_data_pipe_getter.h",
     "test/test_network_connection_tracker.cc",
@@ -440,3 +430,8 @@
     "//testing/gtest",
   ]
 }
+
+service_manifest("manifest") {
+  name = "network"
+  source = "manifest.json"
+}
--- a/services/network/cert_verify_proc_chromeos.cc	2019-05-17 17:45:42.528000000 +0300
+++ b/services/network/cert_verify_proc_chromeos.cc	2019-05-17 18:53:37.876000000 +0300
@@ -11,7 +11,7 @@
 #include "net/cert/x509_util_nss.h"
 
 // NSS doesn't currently define CERT_LIST_TAIL.
-// See https://bugzilla.m0z111a.qjz9zk/show_bug.cgi?id=962413
+// See https://bugzilla.mozilla.org/show_bug.cgi?id=962413
 // Can be removed once chrome requires NSS version 3.16 to build.
 #ifndef CERT_LIST_TAIL
 #define CERT_LIST_TAIL(l) ((CERTCertListNode*)PR_LIST_TAIL(&l->list))
--- a/services/network/cert_verify_proc_chromeos_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/cert_verify_proc_chromeos_unittest.cc	2019-05-17 18:53:37.876000000 +0300
@@ -11,7 +11,6 @@
 #include "net/base/net_errors.h"
 #include "net/cert/cert_verify_proc.h"
 #include "net/cert/cert_verify_result.h"
-#include "net/cert/crl_set.h"
 #include "net/cert/nss_cert_database_chromeos.h"
 #include "net/cert/x509_util.h"
 #include "net/cert/x509_util_nss.h"
@@ -107,8 +106,8 @@
       std::string* root_subject_name) {
     int flags = 0;
     net::CertVerifyResult verify_result;
-    int error = verify_proc->Verify(cert, "127.0.0.1", std::string(), flags,
-                                    net::CRLSet::BuiltinCRLSet().get(),
+    int error =
+        verify_proc->Verify(cert, "127.0.0.1", std::string(), flags, NULL,
                                     additional_trust_anchors, &verify_result);
     if (!verify_result.verified_cert->intermediate_buffers().empty()) {
       root_subject_name->assign(GetSubjectCN(
@@ -377,7 +376,7 @@
   }
 }
 
-INSTANTIATE_TEST_SUITE_P(
+INSTANTIATE_TEST_CASE_P(
     Variations,
     CertVerifyProcChromeOSOrderingTest,
     ::testing::Combine(
--- a/services/network/conditional_cache_deletion_helper.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/conditional_cache_deletion_helper.cc	2019-05-17 18:53:37.880000000 +0300
@@ -4,7 +4,6 @@
 
 #include "services/network/conditional_cache_deletion_helper.h"
 
-#include "base/bind.h"
 #include "base/callback.h"
 #include "base/location.h"
 #include "base/single_thread_task_runner.h"
--- a/services/network/cookie_manager.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/cookie_manager.cc	2019-05-17 18:53:37.880000000 +0300
@@ -6,7 +6,6 @@
 
 #include <utility>
 
-#include "base/bind.h"
 #include "components/content_settings/core/common/content_settings_pattern.h"
 #include "net/base/registry_controlled_domains/registry_controlled_domain.h"
 #include "net/cookies/canonical_cookie.h"
@@ -14,7 +13,6 @@
 #include "net/cookies/cookie_options.h"
 #include "net/cookies/cookie_store.h"
 #include "net/cookies/cookie_util.h"
-#include "services/network/cookie_managers_shared.h"
 #include "services/network/session_cleanup_channel_id_store.h"
 #include "services/network/session_cleanup_cookie_store.h"
 #include "url/gurl.h"
@@ -26,17 +24,26 @@
 
 namespace {
 
-// Converts the one-argument callbacks to two-argument callback that ignores
-// the second arument for the cookie_store
-net::CookieStore::GetCookieListCallback IgnoreSecondArg(
-    base::OnceCallback<void(const net::CookieList&)> callback) {
-  return base::BindOnce(
-      [](base::OnceCallback<void(const net::CookieList&)> callback,
-         const net::CookieList& cookies,
-         const net::CookieStatusList& excluded_list) {
-        std::move(callback).Run(cookies);
-      },
-      std::move(callback));
+mojom::CookieChangeCause ChangeCauseTranslation(
+    net::CookieChangeCause net_cause) {
+  switch (net_cause) {
+    case net::CookieChangeCause::INSERTED:
+      return mojom::CookieChangeCause::INSERTED;
+    case net::CookieChangeCause::EXPLICIT:
+      return mojom::CookieChangeCause::EXPLICIT;
+    case net::CookieChangeCause::UNKNOWN_DELETION:
+      return mojom::CookieChangeCause::UNKNOWN_DELETION;
+    case net::CookieChangeCause::OVERWRITE:
+      return mojom::CookieChangeCause::OVERWRITE;
+    case net::CookieChangeCause::EXPIRED:
+      return mojom::CookieChangeCause::EXPIRED;
+    case net::CookieChangeCause::EVICTED:
+      return mojom::CookieChangeCause::EVICTED;
+    case net::CookieChangeCause::EXPIRED_OVERWRITE:
+      return mojom::CookieChangeCause::EXPIRED_OVERWRITE;
+  }
+  NOTREACHED();
+  return mojom::CookieChangeCause::EXPLICIT;
 }
 
 }  // namespace
@@ -48,7 +55,7 @@
 void CookieManager::ListenerRegistration::DispatchCookieStoreChange(
     const net::CanonicalCookie& cookie,
     net::CookieChangeCause cause) {
-  listener->OnCookieChange(cookie, ToCookieChangeCause(cause));
+  listener->OnCookieChange(cookie, ChangeCauseTranslation(cause));
 }
 
 CookieManager::CookieManager(
@@ -91,23 +98,23 @@
 }
 
 void CookieManager::GetAllCookies(GetAllCookiesCallback callback) {
-  cookie_store_->GetAllCookiesAsync(IgnoreSecondArg(std::move(callback)));
+  cookie_store_->GetAllCookiesAsync(std::move(callback));
 }
 
 void CookieManager::GetCookieList(const GURL& url,
                                   const net::CookieOptions& cookie_options,
                                   GetCookieListCallback callback) {
-  cookie_store_->GetCookieListWithOptionsAsync(
-      url, cookie_options, IgnoreSecondArg(std::move(callback)));
+  cookie_store_->GetCookieListWithOptionsAsync(url, cookie_options,
+                                               std::move(callback));
 }
 
 void CookieManager::SetCanonicalCookie(const net::CanonicalCookie& cookie,
-                                       const std::string& source_scheme,
+                                       bool secure_source,
                                        bool modify_http_only,
                                        SetCanonicalCookieCallback callback) {
   cookie_store_->SetCanonicalCookieAsync(
-      std::make_unique<net::CanonicalCookie>(cookie), source_scheme,
-      modify_http_only, AdaptCookieInclusionStatusToBool(std::move(callback)));
+      std::make_unique<net::CanonicalCookie>(cookie), secure_source,
+      modify_http_only, std::move(callback));
 }
 
 void CookieManager::DeleteCanonicalCookie(
--- a/services/network/cookie_manager.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/cookie_manager.h	2019-05-17 18:53:37.880000000 +0300
@@ -62,7 +62,7 @@
                      const net::CookieOptions& cookie_options,
                      GetCookieListCallback callback) override;
   void SetCanonicalCookie(const net::CanonicalCookie& cookie,
-                          const std::string& source_scheme,
+                          bool secure_source,
                           bool modify_http_only,
                           SetCanonicalCookieCallback callback) override;
   void DeleteCanonicalCookie(const net::CanonicalCookie& cookie,
@@ -114,7 +114,6 @@
   scoped_refptr<SessionCleanupChannelIDStore> session_cleanup_channel_id_store_;
   mojo::BindingSet<mojom::CookieManager> bindings_;
   std::vector<std::unique_ptr<ListenerRegistration>> listener_registrations_;
-  // Note: RestrictedCookieManager stores pointers to |cookie_settings_|.
   CookieSettings cookie_settings_;
 
   DISALLOW_COPY_AND_ASSIGN(CookieManager);
--- a/services/network/cookie_manager_unittest.cc	2019-05-17 17:45:42.532000000 +0300
+++ b/services/network/cookie_manager_unittest.cc	2019-05-17 18:53:37.880000000 +0300
@@ -6,7 +6,6 @@
 
 #include <algorithm>
 
-#include "base/bind.h"
 #include "base/files/scoped_temp_dir.h"
 #include "base/message_loop/message_loop.h"
 #include "base/run_loop.h"
@@ -92,12 +91,12 @@
   }
 
   bool SetCanonicalCookie(const net::CanonicalCookie& cookie,
-                          std::string source_scheme,
+                          bool secure_source,
                           bool modify_http_only) {
     base::RunLoop run_loop;
     bool result = false;
     cookie_service_->SetCanonicalCookie(
-        cookie, std::move(source_scheme), modify_http_only,
+        cookie, secure_source, modify_http_only,
         base::BindOnce(&SynchronousCookieManager::SetCookieCallback, &run_loop,
                        &result));
     run_loop.Run();
@@ -181,19 +180,16 @@
 
   // Set a canonical cookie directly into the store.
   bool SetCanonicalCookie(const net::CanonicalCookie& cookie,
-                          std::string source_scheme,
+                          bool secure_source,
                           bool can_modify_httponly) {
-    net::ResultSavingCookieCallback<net::CanonicalCookie::CookieInclusionStatus>
-        callback;
+    net::ResultSavingCookieCallback<bool> callback;
     cookie_monster_->SetCanonicalCookieAsync(
-        std::make_unique<net::CanonicalCookie>(cookie),
-        std::move(source_scheme), can_modify_httponly,
-        base::BindOnce(&net::ResultSavingCookieCallback<
-                           net::CanonicalCookie::CookieInclusionStatus>::Run,
+        std::make_unique<net::CanonicalCookie>(cookie), secure_source,
+        can_modify_httponly,
+        base::BindOnce(&net::ResultSavingCookieCallback<bool>::Run,
                        base::Unretained(&callback)));
     callback.WaitUntilDone();
-    return callback.result() ==
-           net::CanonicalCookie::CookieInclusionStatus::INCLUDE;
+    return callback.result();
   }
 
   std::string DumpAllCookies() {
@@ -289,27 +285,27 @@
                            /*secure=*/false, /*httponly=*/false,
                            net::CookieSameSite::NO_RESTRICTION,
                            net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
   EXPECT_TRUE(SetCanonicalCookie(
       net::CanonicalCookie(
           "C", "D", "foo_host2", "/with/path", base::Time(), base::Time(),
           base::Time(), /*secure=*/false, /*httponly=*/false,
           net::CookieSameSite::NO_RESTRICTION, net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
   EXPECT_TRUE(SetCanonicalCookie(
       net::CanonicalCookie(
           "Secure", "E", kCookieDomain, "/with/path", base::Time(),
           base::Time(), base::Time(), /*secure=*/true,
           /*httponly=*/false, net::CookieSameSite::NO_RESTRICTION,
           net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
   EXPECT_TRUE(SetCanonicalCookie(
       net::CanonicalCookie(
           "HttpOnly", "F", kCookieDomain, "/with/path", base::Time(),
           base::Time(), base::Time(), /*secure=*/false,
           /*httponly=*/true, net::CookieSameSite::NO_RESTRICTION,
           net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
 
   base::Time after_creation(base::Time::Now());
 
@@ -384,27 +380,27 @@
                            /*secure=*/false, /*httponly=*/false,
                            net::CookieSameSite::NO_RESTRICTION,
                            net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
   EXPECT_TRUE(SetCanonicalCookie(
       net::CanonicalCookie(
           "C", "D", "foo_host2", "/with/path", base::Time(), base::Time(),
           base::Time(), /*secure=*/false, /*httponly=*/false,
           net::CookieSameSite::NO_RESTRICTION, net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
   EXPECT_TRUE(SetCanonicalCookie(
       net::CanonicalCookie(
           "Secure", "E", kCookieDomain, "/with/path", base::Time(),
           base::Time(), base::Time(), /*secure=*/true,
           /*httponly=*/false, net::CookieSameSite::NO_RESTRICTION,
           net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
   EXPECT_TRUE(SetCanonicalCookie(
       net::CanonicalCookie(
           "HttpOnly", "F", kCookieDomain, "/with/path", base::Time(),
           base::Time(), base::Time(), /*secure=*/false,
           /*httponly=*/true, net::CookieSameSite::NO_RESTRICTION,
           net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
 
   std::vector<net::CanonicalCookie> cookies = service_wrapper()->GetCookieList(
       GURL("https://foo_host.com/with/path"), net::CookieOptions());
@@ -428,7 +424,7 @@
                            /*secure=*/false, /*httponly=*/true,
                            net::CookieSameSite::NO_RESTRICTION,
                            net::COOKIE_PRIORITY_MEDIUM),
-      "https", true);
+      true, true);
   ASSERT_TRUE(result);
   result = SetCanonicalCookie(
       net::CanonicalCookie("C", "D", kCookieDomain, "/", base::Time(),
@@ -436,7 +432,7 @@
                            /*secure=*/false, /*httponly=*/false,
                            net::CookieSameSite::NO_RESTRICTION,
                            net::COOKIE_PRIORITY_MEDIUM),
-      "https", true);
+      true, true);
   ASSERT_TRUE(result);
 
   // Retrieve without httponly cookies (default)
@@ -467,35 +463,35 @@
                            /*secure=*/false, /*httponly=*/false,
                            net::CookieSameSite::NO_RESTRICTION,
                            net::COOKIE_PRIORITY_MEDIUM),
-      "https", true);
+      true, true);
   ASSERT_TRUE(result);
   result = SetCanonicalCookie(
       net::CanonicalCookie("C", "D", kCookieDomain, "/", base::Time(),
                            base::Time(), base::Time(), /*secure=*/false,
                            /*httponly=*/false, net::CookieSameSite::LAX_MODE,
                            net::COOKIE_PRIORITY_MEDIUM),
-      "https", true);
+      true, true);
   ASSERT_TRUE(result);
   result = SetCanonicalCookie(
       net::CanonicalCookie("E", "F", kCookieDomain, "/", base::Time(),
                            base::Time(), base::Time(), /*secure=*/false,
                            /*httponly=*/false, net::CookieSameSite::STRICT_MODE,
                            net::COOKIE_PRIORITY_MEDIUM),
-      "https", true);
+      true, true);
   ASSERT_TRUE(result);
 
   // Retrieve only unrestricted cookies.
   net::CookieOptions options;
-  EXPECT_EQ(net::CookieOptions::SameSiteCookieContext::CROSS_SITE,
-            options.same_site_cookie_context());
+  EXPECT_EQ(net::CookieOptions::SameSiteCookieMode::DO_NOT_INCLUDE,
+            options.same_site_cookie_mode());
   std::vector<net::CanonicalCookie> cookies = service_wrapper()->GetCookieList(
       GURL("https://foo_host.com/with/path"), options);
   ASSERT_EQ(1u, cookies.size());
   EXPECT_EQ("A", cookies[0].Name());
 
   // Retrieve unrestricted and lax cookies.
-  options.set_same_site_cookie_context(
-      net::CookieOptions::SameSiteCookieContext::SAME_SITE_LAX);
+  options.set_same_site_cookie_mode(
+      net::CookieOptions::SameSiteCookieMode::INCLUDE_LAX);
   cookies = service_wrapper()->GetCookieList(
       GURL("https://foo_host.com/with/path"), options);
   ASSERT_EQ(2u, cookies.size());
@@ -504,8 +500,8 @@
   EXPECT_EQ("C", cookies[1].Name());
 
   // Retrieve everything.
-  options.set_same_site_cookie_context(
-      net::CookieOptions::SameSiteCookieContext::SAME_SITE_STRICT);
+  options.set_same_site_cookie_mode(
+      net::CookieOptions::SameSiteCookieMode::INCLUDE_STRICT_AND_LAX);
   cookies = service_wrapper()->GetCookieList(
       GURL("https://foo_host.com/with/path"), options);
   ASSERT_EQ(3u, cookies.size());
@@ -522,7 +518,7 @@
                            /*secure=*/false, /*httponly=*/false,
                            net::CookieSameSite::NO_RESTRICTION,
                            net::COOKIE_PRIORITY_MEDIUM),
-      "https", true);
+      true, true);
   ASSERT_TRUE(result);
 
   // Get the cookie without updating the access time and check
@@ -554,7 +550,7 @@
           "A", "B", "foo_host", "/", base::Time(), base::Time(), base::Time(),
           /*secure=*/false, /*httponly=*/false,
           net::CookieSameSite::NO_RESTRICTION, net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
   std::vector<net::CanonicalCookie> cookies =
       service_wrapper()->GetAllCookies();
   ASSERT_EQ(1U, cookies.size());
@@ -570,27 +566,27 @@
                            /*secure=*/false, /*httponly=*/false,
                            net::CookieSameSite::NO_RESTRICTION,
                            net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
   EXPECT_TRUE(SetCanonicalCookie(
       net::CanonicalCookie(
           "C", "D", "foo_host2", "/with/path", base::Time(), base::Time(),
           base::Time(), /*secure=*/false, /*httponly=*/false,
           net::CookieSameSite::NO_RESTRICTION, net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
   EXPECT_TRUE(SetCanonicalCookie(
       net::CanonicalCookie(
           "Secure", "E", kCookieDomain, "/with/path", base::Time(),
           base::Time(), base::Time(), /*secure=*/true,
           /*httponly=*/false, net::CookieSameSite::NO_RESTRICTION,
           net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
   EXPECT_TRUE(SetCanonicalCookie(
       net::CanonicalCookie(
           "HttpOnly", "F", kCookieDomain, "/with/path", base::Time(),
           base::Time(), base::Time(), /*secure=*/false,
           /*httponly=*/true, net::CookieSameSite::NO_RESTRICTION,
           net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
 
   base::Time yesterday = base::Time::Now() - base::TimeDelta::FromDays(1);
   EXPECT_TRUE(service_wrapper()->SetCanonicalCookie(
@@ -598,7 +594,7 @@
           "A", "E", kCookieDomain, "/", base::Time(), yesterday, base::Time(),
           /*secure=*/false, /*httponly=*/false,
           net::CookieSameSite::NO_RESTRICTION, net::COOKIE_PRIORITY_MEDIUM),
-      "http", false));
+      false, false));
 
   std::vector<net::CanonicalCookie> cookies =
       service_wrapper()->GetAllCookies();
@@ -623,7 +619,7 @@
                            /*secure=*/true, /*httponly=*/false,
                            net::CookieSameSite::NO_RESTRICTION,
                            net::COOKIE_PRIORITY_MEDIUM),
-      "http", false));
+      false, false));
   std::vector<net::CanonicalCookie> cookies =
       service_wrapper()->GetAllCookies();
 
@@ -637,7 +633,7 @@
                            /*secure=*/false, /*httponly=*/true,
                            net::CookieSameSite::NO_RESTRICTION,
                            net::COOKIE_PRIORITY_MEDIUM),
-      "http", false));
+      false, false));
   std::vector<net::CanonicalCookie> cookies =
       service_wrapper()->GetAllCookies();
 
@@ -651,7 +647,7 @@
           base::Time(), base::Time(), /*secure=*/false,
           /*httponly=*/true, net::CookieSameSite::NO_RESTRICTION,
           net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
 
   EXPECT_FALSE(service_wrapper()->SetCanonicalCookie(
       net::CanonicalCookie(
@@ -659,7 +655,7 @@
           base::Time(), base::Time(), /*secure=*/false,
           /*httponly=*/true, net::CookieSameSite::NO_RESTRICTION,
           net::COOKIE_PRIORITY_MEDIUM),
-      "http", false));
+      false, false));
 
   std::vector<net::CanonicalCookie> cookies =
       service_wrapper()->GetAllCookies();
@@ -677,27 +673,27 @@
                            /*secure=*/false, /*httponly=*/false,
                            net::CookieSameSite::NO_RESTRICTION,
                            net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
   EXPECT_TRUE(SetCanonicalCookie(
       net::CanonicalCookie(
           "C", "D", "foo_host2", "/with/path", base::Time(), base::Time(),
           base::Time(), /*secure=*/false, /*httponly=*/false,
           net::CookieSameSite::NO_RESTRICTION, net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
   EXPECT_TRUE(SetCanonicalCookie(
       net::CanonicalCookie(
           "Secure", "E", kCookieDomain, "/with/path", base::Time(),
           base::Time(), base::Time(), /*secure=*/true,
           /*httponly=*/false, net::CookieSameSite::NO_RESTRICTION,
           net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
   EXPECT_TRUE(SetCanonicalCookie(
       net::CanonicalCookie(
           "HttpOnly", "F", kCookieDomain, "/with/path", base::Time(),
           base::Time(), base::Time(), /*secure=*/false,
           /*httponly=*/true, net::CookieSameSite::NO_RESTRICTION,
           net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
 
   mojom::CookieDeletionFilter filter;
   EXPECT_EQ(4u, service_wrapper()->DeleteCookies(filter));
@@ -717,7 +713,7 @@
                            base::Time(), /*secure=*/false, /*httponly=*/false,
                            net::CookieSameSite::NO_RESTRICTION,
                            net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
 
   EXPECT_TRUE(SetCanonicalCookie(
       net::CanonicalCookie(
@@ -725,7 +721,7 @@
           now - base::TimeDelta::FromMinutes(120), base::Time(), base::Time(),
           /*secure=*/false, /*httponly=*/false,
           net::CookieSameSite::NO_RESTRICTION, net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
 
   EXPECT_TRUE(SetCanonicalCookie(
       net::CanonicalCookie(
@@ -733,7 +729,7 @@
           now - base::TimeDelta::FromMinutes(180), base::Time(), base::Time(),
           /*secure=*/false, /*httponly=*/false,
           net::CookieSameSite::NO_RESTRICTION, net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
 
   mojom::CookieDeletionFilter filter;
   filter.created_after_time = now - base::TimeDelta::FromMinutes(150);
@@ -754,21 +750,21 @@
           "A1", "val", "foo_host1", "/", base::Time(), base::Time(),
           base::Time(), /*secure=*/false, /*httponly=*/false,
           net::CookieSameSite::NO_RESTRICTION, net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
 
   EXPECT_TRUE(SetCanonicalCookie(
       net::CanonicalCookie(
           "A2", "val", "foo_host2", "/", base::Time(), base::Time(),
           base::Time(), /*secure=*/false, /*httponly=*/false,
           net::CookieSameSite::NO_RESTRICTION, net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
 
   EXPECT_TRUE(SetCanonicalCookie(
       net::CanonicalCookie(
           "A3", "val", "foo_host3", "/", base::Time(), base::Time(),
           base::Time(), /*secure=*/false, /*httponly=*/false,
           net::CookieSameSite::NO_RESTRICTION, net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
 
   mojom::CookieDeletionFilter filter;
   filter.excluding_domains = std::vector<std::string>();
@@ -787,21 +783,21 @@
           "A1", "val", "foo_host1", "/", base::Time(), base::Time(),
           base::Time(), /*secure=*/false, /*httponly=*/false,
           net::CookieSameSite::NO_RESTRICTION, net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
 
   EXPECT_TRUE(SetCanonicalCookie(
       net::CanonicalCookie(
           "A2", "val", "foo_host2", "/", base::Time(), base::Time(),
           base::Time(), /*secure=*/false, /*httponly=*/false,
           net::CookieSameSite::NO_RESTRICTION, net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
 
   EXPECT_TRUE(SetCanonicalCookie(
       net::CanonicalCookie(
           "A3", "val", "foo_host3", "/", base::Time(), base::Time(),
           base::Time(), /*secure=*/false, /*httponly=*/false,
           net::CookieSameSite::NO_RESTRICTION, net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
 
   mojom::CookieDeletionFilter filter;
   filter.including_domains = std::vector<std::string>();
@@ -822,19 +818,19 @@
           "A1", "val", "example.com", "/", base::Time(), base::Time(),
           base::Time(), /*secure=*/false, /*httponly=*/false,
           net::CookieSameSite::NO_RESTRICTION, net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
   EXPECT_TRUE(SetCanonicalCookie(
       net::CanonicalCookie(
           "A2", "val", "www.example.com", "/", base::Time(), base::Time(),
           base::Time(), /*secure=*/false, /*httponly=*/false,
           net::CookieSameSite::NO_RESTRICTION, net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
   EXPECT_TRUE(SetCanonicalCookie(
       net::CanonicalCookie(
           "A3", "val", "www.nonexample.com", "/", base::Time(), base::Time(),
           base::Time(), /*secure=*/false, /*httponly=*/false,
           net::CookieSameSite::NO_RESTRICTION, net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
 
   mojom::CookieDeletionFilter filter;
   filter.including_domains = std::vector<std::string>();
@@ -853,19 +849,19 @@
           "A1", "val", "example.co.uk", "/", base::Time(), base::Time(),
           base::Time(), /*secure=*/false, /*httponly=*/false,
           net::CookieSameSite::NO_RESTRICTION, net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
   EXPECT_TRUE(SetCanonicalCookie(
       net::CanonicalCookie(
           "A2", "val", "www.example.co.uk", "/", base::Time(), base::Time(),
           base::Time(), /*secure=*/false, /*httponly=*/false,
           net::CookieSameSite::NO_RESTRICTION, net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
   EXPECT_TRUE(SetCanonicalCookie(
       net::CanonicalCookie(
           "A3", "val", "www.nonexample.co.uk", "/", base::Time(), base::Time(),
           base::Time(), /*secure=*/false, /*httponly=*/false,
           net::CookieSameSite::NO_RESTRICTION, net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
   filter.including_domains = std::vector<std::string>();
   filter.including_domains->push_back("example.co.uk");
   EXPECT_EQ(2u, service_wrapper()->DeleteCookies(filter));
@@ -882,19 +878,19 @@
           "A1", "val", "example.co.uk", "/", base::Time(), base::Time(),
           base::Time(), /*secure=*/false, /*httponly=*/false,
           net::CookieSameSite::NO_RESTRICTION, net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
   EXPECT_TRUE(SetCanonicalCookie(
       net::CanonicalCookie(
           "A2", "val", "www.example.co.uk", "/", base::Time(), base::Time(),
           base::Time(), /*secure=*/false, /*httponly=*/false,
           net::CookieSameSite::NO_RESTRICTION, net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
   EXPECT_TRUE(SetCanonicalCookie(
       net::CanonicalCookie(
           "A3", "val", "www.nonexample.co.uk", "/", base::Time(), base::Time(),
           base::Time(), /*secure=*/false, /*httponly=*/false,
           net::CookieSameSite::NO_RESTRICTION, net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
   filter.including_domains = std::vector<std::string>();
   filter.including_domains->push_back("co.uk");
   EXPECT_EQ(0u, service_wrapper()->DeleteCookies(filter));
@@ -915,25 +911,25 @@
           "A1", "val", "foo_host.com", "/", base::Time(), base::Time(),
           base::Time(), /*secure=*/false, /*httponly=*/false,
           net::CookieSameSite::NO_RESTRICTION, net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
   EXPECT_TRUE(SetCanonicalCookie(
       net::CanonicalCookie(
           "A2", "val", ".foo_host.com", "/", base::Time(), base::Time(),
           base::Time(), /*secure=*/false, /*httponly=*/false,
           net::CookieSameSite::NO_RESTRICTION, net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
   EXPECT_TRUE(SetCanonicalCookie(
       net::CanonicalCookie(
           "A3", "val", "bar.host.com", "/", base::Time(), base::Time(),
           base::Time(), /*secure=*/false, /*httponly=*/false,
           net::CookieSameSite::NO_RESTRICTION, net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
   EXPECT_TRUE(SetCanonicalCookie(
       net::CanonicalCookie(
           "A4", "val", ".bar.host.com", "/", base::Time(), base::Time(),
           base::Time(), /*secure=*/false, /*httponly=*/false,
           net::CookieSameSite::NO_RESTRICTION, net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
 
   mojom::CookieDeletionFilter filter;
   filter.including_domains = std::vector<std::string>();
@@ -953,31 +949,31 @@
           "A1", "val", "random.co.uk", "/", base::Time(), base::Time(),
           base::Time(), /*secure=*/false, /*httponly=*/false,
           net::CookieSameSite::NO_RESTRICTION, net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
   EXPECT_TRUE(SetCanonicalCookie(
       net::CanonicalCookie(
           "A2", "val", "sub.domain.random.co.uk", "/", base::Time(),
           base::Time(), base::Time(), /*secure=*/false, /*httponly=*/false,
           net::CookieSameSite::NO_RESTRICTION, net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
   EXPECT_TRUE(SetCanonicalCookie(
       net::CanonicalCookie(
           "A3", "val", "random.com", "/", base::Time(), base::Time(),
           base::Time(), /*secure=*/false, /*httponly=*/false,
           net::CookieSameSite::NO_RESTRICTION, net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
   EXPECT_TRUE(SetCanonicalCookie(
       net::CanonicalCookie(
           "A4", "val", "random", "/", base::Time(), base::Time(), base::Time(),
           /*secure=*/false, /*httponly=*/false,
           net::CookieSameSite::NO_RESTRICTION, net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
   EXPECT_TRUE(SetCanonicalCookie(
       net::CanonicalCookie(
           "A5", "val", "normal.co.uk", "/", base::Time(), base::Time(),
           base::Time(), /*secure=*/false, /*httponly=*/false,
           net::CookieSameSite::NO_RESTRICTION, net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
 
   mojom::CookieDeletionFilter filter;
   filter.including_domains = std::vector<std::string>();
@@ -998,7 +994,7 @@
           "A1", "val", "privatedomain", "/", base::Time(), base::Time(),
           base::Time(), /*secure=*/false, /*httponly=*/false,
           net::CookieSameSite::NO_RESTRICTION, net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
 
   EXPECT_TRUE(SetCanonicalCookie(
       net::CanonicalCookie(
@@ -1007,7 +1003,7 @@
           "A2", "val", "privatedomain.com", "/", base::Time(), base::Time(),
           base::Time(), /*secure=*/false, /*httponly=*/false,
           net::CookieSameSite::NO_RESTRICTION, net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
 
   EXPECT_TRUE(SetCanonicalCookie(
       net::CanonicalCookie(
@@ -1016,7 +1012,7 @@
           "A3", "val", "subdomain.privatedomain", "/", base::Time(),
           base::Time(), base::Time(), /*secure=*/false, /*httponly=*/false,
           net::CookieSameSite::NO_RESTRICTION, net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
 
   mojom::CookieDeletionFilter filter;
   filter.including_domains = std::vector<std::string>();
@@ -1050,13 +1046,13 @@
           "A01", "RandomValue", "example.com", "/", base::Time(), base::Time(),
           base::Time(), /*secure=*/false, /*httponly=*/false,
           net::CookieSameSite::NO_RESTRICTION, net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
   EXPECT_TRUE(SetCanonicalCookie(
       net::CanonicalCookie(
           "A02", "RandomValue", "canonical.com", "/", base::Time(),
           base::Time(), base::Time(), /*secure=*/false, /*httponly=*/false,
           net::CookieSameSite::NO_RESTRICTION, net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
 
   // Path
   EXPECT_TRUE(SetCanonicalCookie(
@@ -1064,13 +1060,13 @@
           "A03", "val", "example.com", "/this/is/a/long/path", base::Time(),
           base::Time(), base::Time(), /*secure=*/false, /*httponly=*/false,
           net::CookieSameSite::NO_RESTRICTION, net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
   EXPECT_TRUE(SetCanonicalCookie(
       net::CanonicalCookie(
           "A04", "val", "canonical.com", "/this/is/a/long/path", base::Time(),
           base::Time(), base::Time(), /*secure=*/false, /*httponly=*/false,
           net::CookieSameSite::NO_RESTRICTION, net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
 
   // Last_access
   EXPECT_TRUE(SetCanonicalCookie(
@@ -1080,7 +1076,7 @@
           base::Time::Now() - base::TimeDelta::FromDays(3), /*secure=*/false,
           /*httponly=*/false, net::CookieSameSite::NO_RESTRICTION,
           net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
   EXPECT_TRUE(SetCanonicalCookie(
       net::CanonicalCookie(
           "A06", "val", "canonical.com", "/",
@@ -1088,7 +1084,7 @@
           base::Time::Now() - base::TimeDelta::FromDays(3), /*secure=*/false,
           /*httponly=*/false, net::CookieSameSite::NO_RESTRICTION,
           net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
 
   // Same_site
   EXPECT_TRUE(SetCanonicalCookie(
@@ -1096,13 +1092,13 @@
                            base::Time(), base::Time(), /*secure=*/false,
                            /*httponly=*/false, net::CookieSameSite::STRICT_MODE,
                            net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
   EXPECT_TRUE(SetCanonicalCookie(
       net::CanonicalCookie("A08", "val", "canonical.com", "/", base::Time(),
                            base::Time(), base::Time(), /*secure=*/false,
                            /*httponly=*/false, net::CookieSameSite::STRICT_MODE,
                            net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
 
   // Priority
   EXPECT_TRUE(SetCanonicalCookie(
@@ -1110,13 +1106,13 @@
           "A09", "val", "example.com", "/", base::Time(), base::Time(),
           base::Time(), /*secure=*/false, /*httponly=*/false,
           net::CookieSameSite::NO_RESTRICTION, net::COOKIE_PRIORITY_HIGH),
-      "https", true));
+      true, true));
   EXPECT_TRUE(SetCanonicalCookie(
       net::CanonicalCookie(
           "A10", "val", "canonical.com", "/", base::Time(), base::Time(),
           base::Time(), /*secure=*/false, /*httponly=*/false,
           net::CookieSameSite::NO_RESTRICTION, net::COOKIE_PRIORITY_HIGH),
-      "https", true));
+      true, true));
 
   // Use the filter and make sure the result is the expected set.
   EXPECT_EQ(5u, service_wrapper()->DeleteCookies(filter));
@@ -1135,10 +1131,10 @@
 // (BrowsingDataFilterBuilderImpl).
 TEST_F(CookieManagerTest, DeleteDetails_Consumer) {
   const char* filter_domains[] = {
-      "9oo91e.qjz9zk",
+      "google.com",
 
       // sp.nom.br is an eTLD, so this is a regular valid registrable domain,
-      // just like 9oo91e.qjz9zk.
+      // just like google.com.
       "website.sp.nom.br",
 
       // This domain will also not be found in registries, and since it has only
@@ -1165,10 +1161,10 @@
     bool expect_delete;
   } test_cases[] = {
       // We match any URL on the specified domains.
-      {"www.9oo91e.qjz9zk", "/foo/bar", true},
-      {"www.sub.9oo91e.qjz9zk", "/foo/bar", true},
-      {"sub.9oo91e.qjz9zk", "/", true},
-      {"www.sub.9oo91e.qjz9zk", "/foo/bar", true},
+      {"www.google.com", "/foo/bar", true},
+      {"www.sub.google.com", "/foo/bar", true},
+      {"sub.google.com", "/", true},
+      {"www.sub.google.com", "/foo/bar", true},
       {"website.sp.nom.br", "/", true},
       {"www.website.sp.nom.br", "/", true},
       {"192.168.1.1", "/", true},
@@ -1184,7 +1180,7 @@
       {"www.second-level-domain.fileserver", "/index.html", true},
 
       // Different domains.
-      {"www.y0u1ub3.qjz9zk", "/", false},
+      {"www.youtube.com", "/", false},
       {"www.google.net", "/", false},
       {"192.168.1.2", "/", false},
 
@@ -1210,7 +1206,7 @@
             "A1", "val", test_cases[i].domain, test_cases[i].path, base::Time(),
             base::Time(), base::Time(), /*secure=*/false, /*httponly=*/false,
             net::CookieSameSite::NO_RESTRICTION, net::COOKIE_PRIORITY_MEDIUM),
-        "https", true));
+        true, true));
 
     if (!exclude_domain_cookie) {
       // Host cookie
@@ -1220,7 +1216,7 @@
               base::Time(), base::Time(), base::Time(), /*secure=*/false,
               /*httponly=*/false, net::CookieSameSite::NO_RESTRICTION,
               net::COOKIE_PRIORITY_MEDIUM),
-          "https", true));
+          true, true));
     }
 
     // Httponly cookie
@@ -1229,7 +1225,7 @@
             "A3", "val", test_cases[i].domain, test_cases[i].path, base::Time(),
             base::Time(), base::Time(), /*secure=*/false, /*httponly=*/true,
             net::CookieSameSite::NO_RESTRICTION, net::COOKIE_PRIORITY_MEDIUM),
-        "https", true));
+        true, true));
 
     // Httponly and secure cookie
     EXPECT_TRUE(SetCanonicalCookie(
@@ -1237,7 +1233,7 @@
             "A4", "val", test_cases[i].domain, test_cases[i].path, base::Time(),
             base::Time(), base::Time(), /*secure=*/false, /*httponly=*/true,
             net::CookieSameSite::NO_RESTRICTION, net::COOKIE_PRIORITY_MEDIUM),
-        "https", true));
+        true, true));
 
     const uint32_t number_cookies = exclude_domain_cookie ? 3u : 4u;
     EXPECT_EQ(number_cookies, service_wrapper()->GetAllCookies().size());
@@ -1258,28 +1254,28 @@
           "A1", "val", kCookieDomain, "/", base::Time(), base::Time(),
           base::Time(), /*secure=*/false, /*httponly=*/false,
           net::CookieSameSite::NO_RESTRICTION, net::COOKIE_PRIORITY_MEDIUM),
-      "https", true /*modify_httponly*/));
+      true /*secure_source*/, true /*modify_httponly*/));
 
   EXPECT_TRUE(SetCanonicalCookie(
       net::CanonicalCookie(
           "A1", "val", "bar_host", "/", base::Time(), base::Time(),
           base::Time(), /*secure=*/false, /*httponly=*/false,
           net::CookieSameSite::NO_RESTRICTION, net::COOKIE_PRIORITY_MEDIUM),
-      "https", true /*modify_httponly*/));
+      true /*secure_source*/, true /*modify_httponly*/));
 
   EXPECT_TRUE(SetCanonicalCookie(
       net::CanonicalCookie(
           "A2", "val", kCookieDomain, "/", base::Time(), base::Time(),
           base::Time(), /*secure=*/false, /*httponly=*/false,
           net::CookieSameSite::NO_RESTRICTION, net::COOKIE_PRIORITY_MEDIUM),
-      "https", true /*modify_httponly*/));
+      true /*secure_source*/, true /*modify_httponly*/));
 
   EXPECT_TRUE(SetCanonicalCookie(
       net::CanonicalCookie(
           "A3", "val", "bar_host", "/", base::Time(), base::Time(),
           base::Time(), /*secure=*/false, /*httponly=*/false,
           net::CookieSameSite::NO_RESTRICTION, net::COOKIE_PRIORITY_MEDIUM),
-      "https", true /*modify_httponly*/));
+      true /*secure_source*/, true /*modify_httponly*/));
 
   mojom::CookieDeletionFilter filter;
   filter.cookie_name = std::string("A1");
@@ -1302,7 +1298,7 @@
           "A01", "val", "www.example.com", "/path", base::Time(), base::Time(),
           base::Time(), /*secure=*/true, /*httponly=*/false,
           net::CookieSameSite::NO_RESTRICTION, net::COOKIE_PRIORITY_MEDIUM),
-      "https", true /*modify_httponly*/));
+      true /*secure_source*/, true /*modify_httponly*/));
 
   // Cookie that should not be deleted because it's a host cookie in a
   // subdomain that doesn't exactly match the passed URL.
@@ -1311,7 +1307,7 @@
           "A02", "val", "sub.www.example.com", "/path", base::Time(),
           base::Time(), base::Time(), /*secure=*/false, /*httponly=*/false,
           net::CookieSameSite::NO_RESTRICTION, net::COOKIE_PRIORITY_MEDIUM),
-      "https", true /*modify_httponly*/));
+      true /*secure_source*/, true /*modify_httponly*/));
 
   // Cookie that shouldn't be deleted because the path doesn't match.
   EXPECT_TRUE(SetCanonicalCookie(
@@ -1319,7 +1315,7 @@
           "A03", "val", "www.example.com", "/otherpath", base::Time(),
           base::Time(), base::Time(), /*secure=*/false, /*httponly=*/false,
           net::CookieSameSite::NO_RESTRICTION, net::COOKIE_PRIORITY_MEDIUM),
-      "https", true /*modify_httponly*/));
+      true /*secure_source*/, true /*modify_httponly*/));
 
   // Cookie that shouldn't be deleted because the path is more specific
   // than the URL.
@@ -1328,7 +1324,7 @@
           "A04", "val", "www.example.com", "/path/path2", base::Time(),
           base::Time(), base::Time(), /*secure=*/false, /*httponly=*/false,
           net::CookieSameSite::NO_RESTRICTION, net::COOKIE_PRIORITY_MEDIUM),
-      "https", true /*modify_httponly*/));
+      true /*secure_source*/, true /*modify_httponly*/));
 
   // Cookie that shouldn't be deleted because it's at a host cookie domain that
   // doesn't exactly match the url's host.
@@ -1337,7 +1333,7 @@
           "A05", "val", "example.com", "/path", base::Time(), base::Time(),
           base::Time(), /*secure=*/false, /*httponly=*/false,
           net::CookieSameSite::NO_RESTRICTION, net::COOKIE_PRIORITY_MEDIUM),
-      "https", true /*modify_httponly*/));
+      true /*secure_source*/, true /*modify_httponly*/));
 
   // Cookie that should not be deleted because it's not a host cookie and
   // has a domain that's more specific than the URL
@@ -1346,7 +1342,7 @@
           "A06", "val", ".sub.www.example.com", "/path", base::Time(),
           base::Time(), base::Time(), /*secure=*/false, /*httponly=*/false,
           net::CookieSameSite::NO_RESTRICTION, net::COOKIE_PRIORITY_MEDIUM),
-      "https", true /*modify_httponly*/));
+      true /*secure_source*/, true /*modify_httponly*/));
 
   // Cookie that should be deleted because it's not a host cookie and has a
   // domain that matches the URL
@@ -1355,7 +1351,7 @@
           "A07", "val", ".www.example.com", "/path", base::Time(), base::Time(),
           base::Time(), /*secure=*/false, /*httponly=*/false,
           net::CookieSameSite::NO_RESTRICTION, net::COOKIE_PRIORITY_MEDIUM),
-      "https", true /*modify_httponly*/));
+      true /*secure_source*/, true /*modify_httponly*/));
 
   // Cookie that should be deleted because it's not a host cookie and has a
   // domain that domain matches the URL.
@@ -1364,7 +1360,7 @@
           "A08", "val", ".example.com", "/path", base::Time(), base::Time(),
           base::Time(), /*secure=*/false, /*httponly=*/false,
           net::CookieSameSite::NO_RESTRICTION, net::COOKIE_PRIORITY_MEDIUM),
-      "https", true /*modify_httponly*/));
+      true /*secure_source*/, true /*modify_httponly*/));
 
   // Cookie that should be deleted because it matches exactly.
   EXPECT_TRUE(SetCanonicalCookie(
@@ -1372,7 +1368,7 @@
           "A09", "val", "www.example.com", "/path", base::Time(), base::Time(),
           base::Time(), /*secure=*/false, /*httponly=*/false,
           net::CookieSameSite::NO_RESTRICTION, net::COOKIE_PRIORITY_MEDIUM),
-      "https", true /*modify_httponly*/));
+      true /*secure_source*/, true /*modify_httponly*/));
 
   // Cookie that should be deleted because it applies to a larger set
   // of paths than the URL path.
@@ -1381,7 +1377,7 @@
           "A10", "val", "www.example.com", "/", base::Time(), base::Time(),
           base::Time(), /*secure=*/false, /*httponly=*/false,
           net::CookieSameSite::NO_RESTRICTION, net::COOKIE_PRIORITY_MEDIUM),
-      "https", true /*modify_httponly*/));
+      true /*secure_source*/, true /*modify_httponly*/));
 
   mojom::CookieDeletionFilter filter;
   filter.url = filter_url;
@@ -1408,7 +1404,7 @@
           "A1", "val", kCookieDomain, "/", base::Time(), base::Time(),
           base::Time(), /*secure=*/false, /*httponly=*/false,
           net::CookieSameSite::NO_RESTRICTION, net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
 
   EXPECT_TRUE(SetCanonicalCookie(
       net::CanonicalCookie("A2", "val", kCookieDomain, "/", base::Time(),
@@ -1416,14 +1412,14 @@
                            /*secure=*/false, /*httponly=*/false,
                            net::CookieSameSite::NO_RESTRICTION,
                            net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
 
   EXPECT_TRUE(SetCanonicalCookie(
       net::CanonicalCookie(
           "A3", "val", kCookieDomain, "/", base::Time(), base::Time(),
           base::Time(), /*secure=*/false, /*httponly=*/false,
           net::CookieSameSite::NO_RESTRICTION, net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
 
   mojom::CookieDeletionFilter filter;
   filter.session_control =
@@ -1476,7 +1472,7 @@
           now + base::TimeDelta::FromDays(3), base::Time(), /*secure=*/false,
           /*httponly=*/false, net::CookieSameSite::NO_RESTRICTION,
           net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
 
   // Too old cookie.
   EXPECT_TRUE(SetCanonicalCookie(
@@ -1485,7 +1481,7 @@
           now + base::TimeDelta::FromDays(3), base::Time(), /*secure=*/false,
           /*httponly=*/false, net::CookieSameSite::NO_RESTRICTION,
           net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
 
   // Too young cookie.
   EXPECT_TRUE(SetCanonicalCookie(
@@ -1494,7 +1490,7 @@
           now + base::TimeDelta::FromDays(3), base::Time(), /*secure=*/false,
           /*httponly=*/false, net::CookieSameSite::NO_RESTRICTION,
           net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
 
   // Not in domains_and_ips_to_delete.
   EXPECT_TRUE(SetCanonicalCookie(
@@ -1504,7 +1500,7 @@
           now + base::TimeDelta::FromDays(3), base::Time(), /*secure=*/false,
           /*httponly=*/false, net::CookieSameSite::NO_RESTRICTION,
           net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
 
   // In domains_and_ips_to_ignore.
   EXPECT_TRUE(SetCanonicalCookie(
@@ -1513,7 +1509,7 @@
           now + base::TimeDelta::FromDays(3), base::Time(), /*secure=*/false,
           /*httponly=*/false, net::CookieSameSite::NO_RESTRICTION,
           net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
 
   // Doesn't match URL (by path).
   EXPECT_TRUE(SetCanonicalCookie(
@@ -1523,7 +1519,7 @@
           now + base::TimeDelta::FromDays(3), base::Time(), /*secure=*/false,
           /*httponly=*/false, net::CookieSameSite::NO_RESTRICTION,
           net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
 
   // Session
   EXPECT_TRUE(SetCanonicalCookie(
@@ -1531,7 +1527,7 @@
           "A7", "val7", "nope.com", "/path", now - base::TimeDelta::FromDays(3),
           base::Time(), base::Time(), /*secure=*/false, /*httponly=*/false,
           net::CookieSameSite::NO_RESTRICTION, net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
 
   EXPECT_EQ(1u, service_wrapper()->DeleteCookies(filter));
   std::vector<net::CanonicalCookie> cookies =
@@ -1619,7 +1615,7 @@
           base::Time(), base::Time(), /*secure=*/false,
           /*httponly=*/false, net::CookieSameSite::NO_RESTRICTION,
           net::COOKIE_PRIORITY_MEDIUM),
-      "https", true);
+      true, true);
   base::RunLoop().RunUntilIdle();
   EXPECT_EQ(0u, listener.observed_changes().size());
 
@@ -1631,7 +1627,7 @@
           base::Time(), base::Time(), /*secure=*/false,
           /*httponly=*/false, net::CookieSameSite::NO_RESTRICTION,
           net::COOKIE_PRIORITY_MEDIUM),
-      "https", true);
+      true, true);
 
   base::RunLoop().RunUntilIdle();
   EXPECT_EQ(0u, listener.observed_changes().size());
@@ -1643,7 +1639,7 @@
           base::Time(), base::Time(), /*secure=*/false,
           /*httponly=*/false, net::CookieSameSite::NO_RESTRICTION,
           net::COOKIE_PRIORITY_MEDIUM),
-      "https", true);
+      true, true);
 
   // Expect asynchrony
   EXPECT_EQ(0u, listener.observed_changes().size());
@@ -1699,7 +1695,7 @@
                            /*httponly=*/false,
                            net::CookieSameSite::NO_RESTRICTION,
                            net::COOKIE_PRIORITY_MEDIUM),
-      "https", true);
+      true, true);
 
   // Expect asynchrony
   EXPECT_EQ(0u, listener.observed_changes().size());
@@ -1723,14 +1719,14 @@
                            /*httponly=*/false,
                            net::CookieSameSite::NO_RESTRICTION,
                            net::COOKIE_PRIORITY_MEDIUM),
-      "https", true);
+      true, true);
   service_wrapper()->SetCanonicalCookie(
       net::CanonicalCookie("Thing2", "val", kThatHost, "/", base::Time(),
                            base::Time(), base::Time(), /*secure=*/false,
                            /*httponly=*/false,
                            net::CookieSameSite::NO_RESTRICTION,
                            net::COOKIE_PRIORITY_MEDIUM),
-      "https", true);
+      true, true);
 
   base::RunLoop().RunUntilIdle();
   observed_changes = listener.observed_changes();
@@ -1788,7 +1784,7 @@
           base::Time(), base::Time(), /*secure=*/false,
           /*httponly=*/false, net::CookieSameSite::NO_RESTRICTION,
           net::COOKIE_PRIORITY_MEDIUM),
-      "https", true);
+      true, true);
 
   EXPECT_EQ(0u, listener1->observed_changes().size());
   EXPECT_EQ(0u, listener2->observed_changes().size());
@@ -1840,7 +1836,7 @@
           "X", "Y", "www.other.host", "/", base::Time(), base::Time(),
           base::Time(), /*secure=*/false, /*httponly=*/false,
           net::CookieSameSite::NO_RESTRICTION, net::COOKIE_PRIORITY_MEDIUM),
-      "https", true));
+      true, true));
 
   std::vector<net::CanonicalCookie> cookies = service_wrapper()->GetCookieList(
       GURL("http://www.other.host/"), net::CookieOptions());
@@ -2015,7 +2011,7 @@
 };
 
 TEST_F(SessionCleanupCookieManagerTest, PersistSessionCookies) {
-  EXPECT_TRUE(SetCanonicalCookie(CreateCookie(), "https", true));
+  EXPECT_TRUE(SetCanonicalCookie(CreateCookie(), true, true));
 
   EXPECT_EQ(1u, service_wrapper()->GetAllCookies().size());
 
@@ -2027,7 +2023,7 @@
 }
 
 TEST_F(SessionCleanupCookieManagerTest, DeleteSessionCookies) {
-  EXPECT_TRUE(SetCanonicalCookie(CreateCookie(), "https", true));
+  EXPECT_TRUE(SetCanonicalCookie(CreateCookie(), true, true));
 
   EXPECT_EQ(1u, service_wrapper()->GetAllCookies().size());
 
@@ -2042,7 +2038,7 @@
 }
 
 TEST_F(SessionCleanupCookieManagerTest, SettingMustMatchDomain) {
-  EXPECT_TRUE(SetCanonicalCookie(CreateCookie(), "https", true));
+  EXPECT_TRUE(SetCanonicalCookie(CreateCookie(), true, true));
 
   EXPECT_EQ(1u, service_wrapper()->GetAllCookies().size());
 
@@ -2057,7 +2053,7 @@
 }
 
 TEST_F(SessionCleanupCookieManagerTest, FirstSettingTakesPrecedence) {
-  EXPECT_TRUE(SetCanonicalCookie(CreateCookie(), "https", true));
+  EXPECT_TRUE(SetCanonicalCookie(CreateCookie(), true, true));
 
   EXPECT_EQ(1u, service_wrapper()->GetAllCookies().size());
 
@@ -2075,7 +2071,7 @@
 }
 
 TEST_F(SessionCleanupCookieManagerTest, ForceKeepSessionState) {
-  EXPECT_TRUE(SetCanonicalCookie(CreateCookie(), "https", true));
+  EXPECT_TRUE(SetCanonicalCookie(CreateCookie(), true, true));
 
   EXPECT_EQ(1u, service_wrapper()->GetAllCookies().size());
 
@@ -2092,7 +2088,7 @@
 
 TEST_F(SessionCleanupCookieManagerTest, HttpCookieAllowedOnHttps) {
   EXPECT_TRUE(SetCanonicalCookie(CreateCookie(StrCat({"www.", kCookieDomain})),
-                                 "https", true));
+                                 true, true));
 
   EXPECT_EQ(1u, service_wrapper()->GetAllCookies().size());
 
--- a/services/network/cookie_settings.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/cookie_settings.cc	2019-05-17 18:53:37.880000000 +0300
@@ -3,9 +3,6 @@
 // found in the LICENSE file.
 
 #include "services/network/cookie_settings.h"
-
-#include <functional>
-
 #include "base/bind.h"
 #include "net/base/net_errors.h"
 #include "net/base/static_cookie_policy.h"
@@ -27,7 +24,7 @@
     return SessionCleanupCookieStore::DeleteCookiePredicate();
   return base::BindRepeating(&CookieSettings::ShouldDeleteCookieOnExit,
                              base::Unretained(this),
-                             std::cref(content_settings_));
+                             base::ConstRef(content_settings_));
 }
 
 void CookieSettings::GetCookieSetting(const GURL& url,
--- a/services/network/cors/cors_url_loader.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/cors/cors_url_loader.cc	2019-05-17 18:53:37.880000000 +0300
@@ -4,7 +4,6 @@
 
 #include "services/network/cors/cors_url_loader.h"
 
-#include "base/bind.h"
 #include "base/stl_util.h"
 #include "net/base/load_flags.h"
 #include "services/network/cors/preflight_controller.h"
@@ -57,7 +56,6 @@
     mojom::URLLoaderFactory* network_loader_factory,
     const base::RepeatingCallback<void(int)>& request_finalizer,
     const OriginAccessList* origin_access_list,
-    const OriginAccessList* factory_bound_origin_access_list,
     PreflightController* preflight_controller)
     : binding_(this, std::move(loader_request)),
       routing_id_(routing_id),
@@ -71,7 +69,6 @@
       request_finalizer_(request_finalizer),
       traffic_annotation_(traffic_annotation),
       origin_access_list_(origin_access_list),
-      factory_bound_origin_access_list_(factory_bound_origin_access_list),
       preflight_controller_(preflight_controller),
       weak_factory_(this) {
   binding_.set_connection_error_handler(base::BindOnce(
@@ -346,11 +343,7 @@
 void CorsURLLoader::OnComplete(const URLLoaderCompletionStatus& status) {
   DCHECK(network_loader_);
   DCHECK(forwarding_client_);
-
-  // |network_loader_| will call OnComplete at anytime when a problem happens
-  // inside the URLLoader, e.g. on URLLoader::OnConnectionError call. We need
-  // to expect it also happens even during redirect handling.
-  DCHECK(!deferred_redirect_url_ || status.error_code != net::OK);
+  DCHECK(!deferred_redirect_url_);
 
   URLLoaderCompletionStatus modified_status(status);
   if (status.error_code == net::OK)
@@ -475,19 +468,9 @@
   DCHECK(request_.request_initiator);
 
   // The source origin and destination URL pair may be in the allow list.
-  switch (origin_access_list_->CheckAccessState(*request_.request_initiator,
+  if (origin_access_list_->IsAllowed(*request_.request_initiator,
                                                 request_.url)) {
-    case OriginAccessList::AccessState::kAllowed:
       return;
-    case OriginAccessList::AccessState::kBlocked:
-      break;
-    case OriginAccessList::AccessState::kNotListed:
-      if (factory_bound_origin_access_list_->CheckAccessState(
-              *request_.request_initiator, request_.url) ==
-          OriginAccessList::AccessState::kAllowed) {
-        return;
-      }
-      break;
   }
 
   // When a request is initiated in a unique opaque origin (e.g., in a sandboxed
@@ -542,8 +525,7 @@
   if (request_mode == mojom::FetchRequestMode::kNoCors) {
     if (tainted_origin ||
         (!origin->IsSameOriginWith(url::Origin::Create(url)) &&
-         origin_access_list->CheckAccessState(*origin, url) !=
-             OriginAccessList::AccessState::kAllowed)) {
+         !origin_access_list->IsAllowed(*origin, url))) {
       return mojom::FetchResponseType::kOpaque;
     }
   }
--- a/services/network/cors/cors_url_loader_factory.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/cors/cors_url_loader_factory.cc	2019-05-17 18:53:37.880000000 +0300
@@ -4,7 +4,6 @@
 
 #include "services/network/cors/cors_url_loader_factory.h"
 
-#include "base/bind.h"
 #include "base/logging.h"
 #include "net/base/load_flags.h"
 #include "services/network/cors/cors_url_loader.h"
@@ -25,28 +24,18 @@
     mojom::URLLoaderFactoryParamsPtr params,
     scoped_refptr<ResourceSchedulerClient> resource_scheduler_client,
     mojom::URLLoaderFactoryRequest request,
-    const OriginAccessList* origin_access_list,
-    std::unique_ptr<mojom::URLLoaderFactory> network_loader_factory_for_testing)
+    const OriginAccessList* origin_access_list)
     : context_(context),
       disable_web_security_(params->disable_web_security),
       process_id_(params->process_id),
+      network_loader_factory_(std::make_unique<network::URLLoaderFactory>(
+          context,
+          std::move(params),
+          std::move(resource_scheduler_client),
+          this)),
       origin_access_list_(origin_access_list) {
   DCHECK(context_);
   DCHECK(origin_access_list_);
-  factory_bound_origin_access_list_ = std::make_unique<OriginAccessList>();
-  if (params->factory_bound_allow_patterns.size()) {
-    DCHECK(params->request_initiator_site_lock);
-    factory_bound_origin_access_list_->SetAllowListForOrigin(
-        *params->request_initiator_site_lock,
-        params->factory_bound_allow_patterns);
-  }
-  network_loader_factory_ =
-      network_loader_factory_for_testing
-          ? std::move(network_loader_factory_for_testing)
-          : std::make_unique<network::URLLoaderFactory>(
-                context, std::move(params),
-                std::move(resource_scheduler_client), this);
-
   bindings_.AddBinding(this, std::move(request));
   bindings_.set_connection_error_handler(base::BindRepeating(
       &CorsURLLoaderFactory::DeleteIfNeeded, base::Unretained(this)));
@@ -65,7 +54,6 @@
       preflight_finalizer_(preflight_finalizer),
       origin_access_list_(origin_access_list) {
   DCHECK(origin_access_list_);
-  factory_bound_origin_access_list_ = std::make_unique<OriginAccessList>();
   // Ideally this should be per-profile, but per-factory would be enough for
   // this code path that is eventually removed.
   owned_preflight_controller_ = std::make_unique<PreflightController>();
@@ -104,15 +92,15 @@
     return;
   }
 
-  if (features::ShouldEnableOutOfBlinkCors() && !disable_web_security_) {
+  if (base::FeatureList::IsEnabled(features::kOutOfBlinkCors) &&
+      !disable_web_security_) {
     auto loader = std::make_unique<CorsURLLoader>(
         std::move(request), routing_id, request_id, options,
         base::BindOnce(&CorsURLLoaderFactory::DestroyURLLoader,
                        base::Unretained(this)),
         resource_request, std::move(client), traffic_annotation,
         network_loader_factory_.get(), preflight_finalizer_,
-        origin_access_list_, factory_bound_origin_access_list_.get(),
-        preflight_controller_);
+        origin_access_list_, preflight_controller_);
     auto* raw_loader = loader.get();
     OnLoaderCreated(std::move(loader));
     raw_loader->Start();
--- a/services/network/cors/cors_url_loader_factory.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/cors/cors_url_loader_factory.h	2019-05-17 18:53:37.880000000 +0300
@@ -34,17 +34,13 @@
     : public mojom::URLLoaderFactory {
  public:
   // |origin_access_list| should always outlive this factory instance.
-  // Used by network::NetworkContext. |network_loader_factory_for_testing|
-  // should be nullptr unless you need to overwrite the default factory for
-  // testing.
+  // Used by network::NetworkContext.
   CorsURLLoaderFactory(
       NetworkContext* context,
       mojom::URLLoaderFactoryParamsPtr params,
       scoped_refptr<ResourceSchedulerClient> resource_scheduler_client,
       mojom::URLLoaderFactoryRequest request,
-      const OriginAccessList* origin_access_list,
-      std::unique_ptr<mojom::URLLoaderFactory>
-          network_loader_factory_for_testing);
+      const OriginAccessList* origin_access_list);
   // Used by content::ResourceMessageFilter.
   // TODO(yhirano): Remove this once when the network service is fully enabled.
   CorsURLLoaderFactory(
@@ -103,10 +99,6 @@
   // it's safe.
   const OriginAccessList* const origin_access_list_;
 
-  // Owns factory bound OriginAccessList that to have factory specific
-  // additional allowed access list.
-  std::unique_ptr<OriginAccessList> factory_bound_origin_access_list_;
-
   // Usually |preflight_controoler_| is owned by NetworkContext, but we create
   // own one if NetworkContext is not provided, e.g. for legacy code path.
   // TODO(toyoshim): Remove owned controller once the network service is fully
--- a/services/network/cors/cors_url_loader_factory_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/cors/cors_url_loader_factory_unittest.cc	2019-05-17 18:53:37.880000000 +0300
@@ -72,8 +72,7 @@
     cors_url_loader_factory_ = std::make_unique<CorsURLLoaderFactory>(
         network_context_.get(), std::move(factory_params),
         resource_scheduler_client,
-        mojo::MakeRequest(&cors_url_loader_factory_ptr_), &origin_access_list_,
-        nullptr);
+        mojo::MakeRequest(&cors_url_loader_factory_ptr_), &origin_access_list_);
   }
 
   void CreateLoaderAndStart(const ResourceRequest& request) {
--- a/services/network/cors/cors_url_loader.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/cors/cors_url_loader.h	2019-05-17 18:53:37.880000000 +0300
@@ -13,7 +13,6 @@
 #include "services/network/public/cpp/cors/cors_error_status.h"
 #include "services/network/public/cpp/cors/preflight_timing_info.h"
 #include "services/network/public/mojom/fetch_api.mojom.h"
-#include "services/network/public/mojom/url_loader.mojom.h"
 #include "services/network/public/mojom/url_loader_factory.mojom.h"
 #include "url/gurl.h"
 #include "url/origin.h"
@@ -50,7 +49,6 @@
       mojom::URLLoaderFactory* network_loader_factory,
       const base::RepeatingCallback<void(int)>& request_finalizer,
       const OriginAccessList* origin_access_list,
-      const OriginAccessList* factory_bound_origin_access_list,
       PreflightController* preflight_controller);
 
   ~CorsURLLoader() override;
@@ -176,7 +174,6 @@
 
   // Outlives |this|.
   const OriginAccessList* const origin_access_list_;
-  const OriginAccessList* const factory_bound_origin_access_list_;
   PreflightController* preflight_controller_;
 
   // Used to run asynchronous class instance bound callbacks safely.
--- a/services/network/cors/cors_url_loader_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/cors/cors_url_loader_unittest.cc	2019-05-17 18:53:37.880000000 +0300
@@ -4,35 +4,23 @@
 
 #include "services/network/cors/cors_url_loader.h"
 
-#include <utility>
-#include <vector>
-
 #include "base/logging.h"
 #include "base/macros.h"
 #include "base/memory/weak_ptr.h"
 #include "base/message_loop/message_loop.h"
-#include "base/optional.h"
 #include "base/run_loop.h"
 #include "base/strings/string_piece.h"
 #include "base/strings/stringprintf.h"
 #include "base/test/scoped_feature_list.h"
-#include "base/test/scoped_task_environment.h"
 #include "net/base/load_flags.h"
 #include "net/http/http_request_headers.h"
 #include "net/traffic_annotation/network_traffic_annotation_test_helper.h"
 #include "net/url_request/url_request.h"
-#include "net/url_request/url_request_context.h"
-#include "net/url_request/url_request_context_builder.h"
 #include "services/network/cors/cors_url_loader_factory.h"
-#include "services/network/network_context.h"
-#include "services/network/network_service.h"
 #include "services/network/public/cpp/features.h"
 #include "services/network/public/mojom/cors.mojom.h"
-#include "services/network/public/mojom/network_context.mojom.h"
 #include "services/network/public/mojom/url_loader.mojom.h"
 #include "services/network/public/mojom/url_loader_factory.mojom.h"
-#include "services/network/resource_scheduler.h"
-#include "services/network/resource_scheduler_client.h"
 #include "services/network/test/test_url_loader_client.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
@@ -130,32 +118,19 @@
  public:
   using ReferrerPolicy = net::URLRequest::ReferrerPolicy;
 
-  CorsURLLoaderTest()
-      : scoped_task_environment_(
-            base::test::ScopedTaskEnvironment::MainThreadType::IO),
-        resource_scheduler_(true) {
-    net::URLRequestContextBuilder context_builder;
-    context_builder.set_proxy_resolution_service(
-        net::ProxyResolutionService::CreateDirect());
-    url_request_context_ = context_builder.Build();
+  CorsURLLoaderTest() {
+    std::unique_ptr<TestURLLoaderFactory> factory =
+        std::make_unique<TestURLLoaderFactory>();
+    test_url_loader_factory_ = factory->GetWeakPtr();
+    cors_url_loader_factory_ = std::make_unique<CorsURLLoaderFactory>(
+        false, std::move(factory), base::RepeatingCallback<void(int)>(),
+        &origin_access_list_, 0);
   }
 
  protected:
   // testing::Test implementation.
   void SetUp() override {
-    feature_list_.InitWithFeatures(
-        {features::kOutOfBlinkCors, features::kNetworkService}, {});
-
-    network_service_ = NetworkService::CreateForTesting();
-
-    auto context_params = mojom::NetworkContextParams::New();
-    context_params->initial_proxy_config =
-        net::ProxyConfigWithAnnotation::CreateDirect();
-    network_context_ = std::make_unique<NetworkContext>(
-        network_service_.get(), mojo::MakeRequest(&network_context_ptr_),
-        std::move(context_params));
-
-    ResetFactory(base::nullopt);
+    feature_list_.InitAndEnableFeature(features::kOutOfBlinkCors);
   }
 
   void CreateLoaderAndStart(const GURL& origin,
@@ -262,26 +237,6 @@
         mojom::CorsOriginAccessMatchPriority::kDefaultPriority);
   }
 
-  void AddBlockListEntryForOrigin(const url::Origin& source_origin,
-                                  const std::string& protocol,
-                                  const std::string& domain,
-                                  const mojom::CorsOriginAccessMatchMode mode) {
-    origin_access_list_.AddBlockListEntryForOrigin(
-        source_origin, protocol, domain, mode,
-        mojom::CorsOriginAccessMatchPriority::kHighPriority);
-  }
-
-  void AddFactoryBoundAllowListEntryForOrigin(
-      const url::Origin& source_origin,
-      const std::string& protocol,
-      const std::string& domain,
-      const mojom::CorsOriginAccessMatchMode mode) {
-    factory_bound_allow_patterns_.push_back(mojom::CorsOriginPattern::New(
-        protocol, domain, mode,
-        mojom::CorsOriginAccessMatchPriority::kDefaultPriority));
-    ResetFactory(source_origin);
-  }
-
   static net::RedirectInfo CreateRedirectInfo(
       int status_code,
       base::StringPiece method,
@@ -298,50 +253,14 @@
   }
 
  private:
-  void ResetFactory(base::Optional<url::Origin> initiator) {
-    std::unique_ptr<TestURLLoaderFactory> factory =
-        std::make_unique<TestURLLoaderFactory>();
-    test_url_loader_factory_ = factory->GetWeakPtr();
-
-    auto factory_params = network::mojom::URLLoaderFactoryParams::New();
-    if (initiator) {
-      factory_params->request_initiator_site_lock = *initiator;
-      std::vector<network::mojom::CorsOriginPatternPtr> cloned_patterns;
-      for (const auto& item : factory_bound_allow_patterns_)
-        cloned_patterns.push_back(item.Clone());
-      factory_params->factory_bound_allow_patterns = std::move(cloned_patterns);
-    }
-    constexpr int kProcessId = 573;
-    factory_params->process_id = kProcessId;
-    constexpr int kRouteId = 765;
-    auto resource_scheduler_client =
-        base::MakeRefCounted<ResourceSchedulerClient>(
-            kProcessId, kRouteId, &resource_scheduler_,
-            url_request_context_->network_quality_estimator());
-    cors_url_loader_factory_ = std::make_unique<CorsURLLoaderFactory>(
-        network_context_.get(), std::move(factory_params),
-        resource_scheduler_client,
-        mojo::MakeRequest(&cors_url_loader_factory_ptr_), &origin_access_list_,
-        std::move(factory));
-  }
+  // Be the first member so it is destroyed last.
+  base::MessageLoop message_loop_;
 
   // Testing instance to enable kOutOfBlinkCors feature.
   base::test::ScopedFeatureList feature_list_;
 
-  // Test environment.
-  base::test::ScopedTaskEnvironment scoped_task_environment_;
-  std::unique_ptr<net::URLRequestContext> url_request_context_;
-  ResourceScheduler resource_scheduler_;
-  std::unique_ptr<NetworkService> network_service_;
-  std::unique_ptr<NetworkContext> network_context_;
-  mojom::NetworkContextPtr network_context_ptr_;
-
   // CorsURLLoaderFactory instance under tests.
   std::unique_ptr<mojom::URLLoaderFactory> cors_url_loader_factory_;
-  mojom::URLLoaderFactoryPtr cors_url_loader_factory_ptr_;
-
-  // Factory bound origin access list for testing.
-  std::vector<mojom::CorsOriginPatternPtr> factory_bound_allow_patterns_;
 
   // TestURLLoaderFactory instance owned by CorsURLLoaderFactory.
   base::WeakPtr<TestURLLoaderFactory> test_url_loader_factory_;
@@ -696,32 +615,6 @@
             mojom::CorsError::kMissingAllowOriginHeader);
 }
 
-TEST_F(CorsURLLoaderTest, NetworkLoaderErrorDuringRedirect) {
-  const GURL origin("https://example.com");
-  const GURL url("https://other.example.com/foo.png");
-  const GURL new_url("https://other2.example.com/bar.png");
-
-  CreateLoaderAndStart(origin, url, mojom::FetchRequestMode::kCors);
-
-  EXPECT_EQ(1, num_created_loaders());
-  EXPECT_EQ(GetRequest().url, url);
-  EXPECT_EQ(GetRequest().method, "GET");
-
-  NotifyLoaderClientOnReceiveRedirect(
-      CreateRedirectInfo(301, "GET", new_url),
-      {"Access-Control-Allow-Origin: https://example.com"});
-  RunUntilRedirectReceived();
-
-  // Underlying network::URLLoader may call OnComplete with an error at anytime.
-  NotifyLoaderClientOnComplete(net::ERR_FAILED);
-  base::RunLoop().RunUntilIdle();
-
-  EXPECT_TRUE(IsNetworkLoaderStarted());
-  EXPECT_TRUE(client().has_received_completion());
-  EXPECT_FALSE(client().has_received_response());
-  EXPECT_TRUE(client().has_received_redirect());
-}
-
 TEST_F(CorsURLLoaderTest, SameOriginToSameOriginRedirect) {
   const GURL origin("https://example.com");
   const GURL url("https://example.com/foo.png");
@@ -1114,10 +1007,9 @@
 }
 
 // Tests if OriginAccessList is actually used to decide the cors flag.
-// Details for the OriginAccessList behaviors are verified in
-// OriginAccessListTest, but this test intends to verify if CorsURlLoader calls
-// the list properly.
-TEST_F(CorsURLLoaderTest, OriginAccessList_Allowed) {
+// Does not verify detailed functionalities that are verified in
+// OriginAccessListTest.
+TEST_F(CorsURLLoaderTest, OriginAccessList) {
   const GURL origin("http://example.com");
   const GURL url("http://other.com/foo.png");
 
@@ -1143,83 +1035,6 @@
   EXPECT_EQ(net::OK, client().completion_status().error_code);
 }
 
-// Check if higher-priority block list wins.
-TEST_F(CorsURLLoaderTest, OriginAccessList_Blocked) {
-  const GURL origin("http://example.com");
-  const GURL url("http://other.com/foo.png");
-
-  AddAllowListEntryForOrigin(
-      url::Origin::Create(origin), url.scheme(), url.host(),
-      mojom::CorsOriginAccessMatchMode::kDisallowSubdomains);
-  AddBlockListEntryForOrigin(
-      url::Origin::Create(origin), url.scheme(), url.host(),
-      mojom::CorsOriginAccessMatchMode::kDisallowSubdomains);
-
-  CreateLoaderAndStart(origin, url, mojom::FetchRequestMode::kCors);
-
-  NotifyLoaderClientOnReceiveResponse();
-
-  RunUntilComplete();
-
-  EXPECT_TRUE(IsNetworkLoaderStarted());
-  EXPECT_FALSE(client().has_received_redirect());
-  EXPECT_FALSE(client().has_received_response());
-  EXPECT_TRUE(client().has_received_completion());
-  EXPECT_EQ(net::ERR_FAILED, client().completion_status().error_code);
-}
-
-// CorsURLLoader manages two lists, per-NetworkContext list and
-// per-URLLoaderFactory list. This test verifies if per-URLLoaderFactory list
-// works.
-TEST_F(CorsURLLoaderTest, OriginAccessList_AllowedByFactoryList) {
-  const GURL origin("http://example.com");
-  const GURL url("http://other.com/foo.png");
-
-  AddFactoryBoundAllowListEntryForOrigin(
-      url::Origin::Create(origin), url.scheme(), url.host(),
-      mojom::CorsOriginAccessMatchMode::kDisallowSubdomains);
-
-  CreateLoaderAndStart(origin, url, mojom::FetchRequestMode::kCors);
-
-  NotifyLoaderClientOnReceiveResponse();
-  NotifyLoaderClientOnComplete(net::OK);
-
-  RunUntilComplete();
-
-  EXPECT_TRUE(IsNetworkLoaderStarted());
-  EXPECT_FALSE(client().has_received_redirect());
-  EXPECT_TRUE(client().has_received_response());
-  EXPECT_EQ(network::mojom::FetchResponseType::kBasic,
-            client().response_head().response_type);
-  EXPECT_TRUE(client().has_received_completion());
-  EXPECT_EQ(net::OK, client().completion_status().error_code);
-}
-
-// Checks if CorsURLLoader can respect the per-NetworkContext block list.
-TEST_F(CorsURLLoaderTest, OriginAccessList_AllowedByFactoryListButBlocked) {
-  const GURL origin("http://example.com");
-  const GURL url("http://other.com/foo.png");
-
-  AddFactoryBoundAllowListEntryForOrigin(
-      url::Origin::Create(origin), url.scheme(), url.host(),
-      mojom::CorsOriginAccessMatchMode::kDisallowSubdomains);
-  AddBlockListEntryForOrigin(
-      url::Origin::Create(origin), url.scheme(), url.host(),
-      mojom::CorsOriginAccessMatchMode::kDisallowSubdomains);
-
-  CreateLoaderAndStart(origin, url, mojom::FetchRequestMode::kCors);
-
-  NotifyLoaderClientOnReceiveResponse();
-
-  RunUntilComplete();
-
-  EXPECT_TRUE(IsNetworkLoaderStarted());
-  EXPECT_FALSE(client().has_received_redirect());
-  EXPECT_FALSE(client().has_received_response());
-  EXPECT_TRUE(client().has_received_completion());
-  EXPECT_EQ(net::ERR_FAILED, client().completion_status().error_code);
-}
-
 // Tests if OriginAccessList is actually used to decide response tainting.
 TEST_F(CorsURLLoaderTest, OriginAccessList_NoCors) {
   const GURL origin("http://example.com");
--- a/services/network/cors/preflight_controller.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/cors/preflight_controller.cc	2019-05-17 18:53:37.880000000 +0300
@@ -18,7 +18,6 @@
 #include "services/network/public/cpp/cors/cors_error_status.h"
 #include "services/network/public/cpp/resource_request.h"
 #include "services/network/public/cpp/simple_url_loader.h"
-#include "services/network/public/mojom/url_loader.mojom.h"
 #include "url/gurl.h"
 
 namespace network {
@@ -84,8 +83,6 @@
   preflight_request->load_flags |= net::LOAD_DO_NOT_SAVE_COOKIES;
   preflight_request->load_flags |= net::LOAD_DO_NOT_SEND_COOKIES;
   preflight_request->load_flags |= net::LOAD_DO_NOT_SEND_AUTH_DATA;
-  preflight_request->fetch_window_id = request.fetch_window_id;
-  preflight_request->render_frame_id = request.render_frame_id;
 
   preflight_request->headers.SetHeader(
       header_names::kAccessControlRequestMethod, request.method);
@@ -127,9 +124,8 @@
     base::Optional<CorsErrorStatus>* detected_error_status) {
   DCHECK(detected_error_status);
 
-  const int response_code = head.headers ? head.headers->response_code() : 0;
   *detected_error_status = CheckPreflightAccess(
-      final_url, response_code,
+      final_url, head.headers->response_code(),
       GetHeaderString(head.headers, header_names::kAccessControlAllowOrigin),
       GetHeaderString(head.headers,
                       header_names::kAccessControlAllowCredentials),
@@ -139,7 +135,7 @@
     return nullptr;
 
   base::Optional<mojom::CorsError> error;
-  error = CheckPreflight(response_code);
+  error = CheckPreflight(head.headers->response_code());
   if (error) {
     *detected_error_status = CorsErrorStatus(*error);
     return nullptr;
@@ -288,7 +284,7 @@
     FinalizeLoader();
 
     timing_info_.start_time = head.request_start;
-    timing_info_.response_end = base::TimeTicks::Now();
+    timing_info_.finish_time = base::TimeTicks::Now();
     timing_info_.alpn_negotiated_protocol = head.alpn_negotiated_protocol;
     timing_info_.connection_info = head.connection_info;
     auto timing_allow_origin =
@@ -380,18 +376,6 @@
   return CreatePreflightRequest(request, tainted);
 }
 
-// static
-std::unique_ptr<PreflightResult>
-PreflightController::CreatePreflightResultForTesting(
-    const GURL& final_url,
-    const ResourceResponseHead& head,
-    const ResourceRequest& original_request,
-    bool tainted,
-    base::Optional<CorsErrorStatus>* detected_error_status) {
-  return CreatePreflightResult(final_url, head, original_request, tainted,
-                               detected_error_status);
-}
-
 PreflightController::PreflightController() = default;
 
 PreflightController::~PreflightController() = default;
--- a/services/network/cors/preflight_controller.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/cors/preflight_controller.h	2019-05-17 18:53:37.880000000 +0300
@@ -43,13 +43,6 @@
   static std::unique_ptr<ResourceRequest> CreatePreflightRequestForTesting(
       const ResourceRequest& request,
       bool tainted = false);
-  // Creates a PreflightResult for a specified response parameters for testing.
-  static std::unique_ptr<PreflightResult> CreatePreflightResultForTesting(
-      const GURL& final_url,
-      const ResourceResponseHead& head,
-      const ResourceRequest& original_request,
-      bool tainted,
-      base::Optional<CorsErrorStatus>* detected_error_status);
 
   PreflightController();
   ~PreflightController();
--- a/services/network/cors/preflight_controller_unittest.cc	2019-05-17 17:45:42.532000000 +0300
+++ b/services/network/cors/preflight_controller_unittest.cc	2019-05-17 18:53:37.880000000 +0300
@@ -7,7 +7,6 @@
 #include <memory>
 #include <utility>
 
-#include "base/bind.h"
 #include "base/run_loop.h"
 #include "base/test/scoped_task_environment.h"
 #include "net/base/load_flags.h"
@@ -152,7 +151,7 @@
   request.fetch_request_mode = mojom::FetchRequestMode::kCors;
   request.fetch_credentials_mode = mojom::FetchCredentialsMode::kOmit;
   request.request_initiator = url::Origin();
-  request.headers.SetHeader("referer", "https://www.9oo91e.qjz9zk/");
+  request.headers.SetHeader("referer", "https://www.google.com/");
 
   std::unique_ptr<ResourceRequest> preflight =
       PreflightController::CreatePreflightRequestForTesting(request);
@@ -177,36 +176,6 @@
   EXPECT_EQ(header, "null");
 }
 
-TEST(PreflightControllerCreatePreflightRequestTest, FetchWindowId) {
-  ResourceRequest request;
-  request.fetch_request_mode = mojom::FetchRequestMode::kCors;
-  request.fetch_credentials_mode = mojom::FetchCredentialsMode::kOmit;
-  request.request_initiator = url::Origin();
-  request.headers.SetHeader(net::HttpRequestHeaders::kContentType,
-                            "application/octet-stream");
-  request.fetch_window_id = base::UnguessableToken::Create();
-
-  std::unique_ptr<ResourceRequest> preflight =
-      PreflightController::CreatePreflightRequestForTesting(request);
-
-  EXPECT_EQ(request.fetch_window_id, preflight->fetch_window_id);
-}
-
-TEST(PreflightControllerCreatePreflightRequestTest, RenderFrameId) {
-  ResourceRequest request;
-  request.fetch_request_mode = mojom::FetchRequestMode::kCors;
-  request.fetch_credentials_mode = mojom::FetchCredentialsMode::kOmit;
-  request.request_initiator = url::Origin();
-  request.headers.SetHeader(net::HttpRequestHeaders::kContentType,
-                            "application/octet-stream");
-  request.render_frame_id = 99;
-
-  std::unique_ptr<ResourceRequest> preflight =
-      PreflightController::CreatePreflightRequestForTesting(request);
-
-  EXPECT_EQ(request.render_frame_id, preflight->render_frame_id);
-}
-
 class PreflightControllerTest : public testing::Test {
  public:
   PreflightControllerTest()
@@ -382,24 +351,6 @@
   EXPECT_EQ(1u, access_count());
 }
 
-TEST_F(PreflightControllerTest, CheckResponseWithNullHeaders) {
-  GURL url = GURL("https://9oo91e.qjz9zk/finullurl");
-  const ResourceResponseHead response_head;
-  ResourceRequest request;
-  request.url = url;
-  request.request_initiator = url::Origin::Create(request.url);
-  const bool tainted = false;
-  base::Optional<CorsErrorStatus> detected_error_status;
-
-  EXPECT_FALSE(response_head.headers);
-
-  std::unique_ptr<PreflightResult> result =
-      PreflightController::CreatePreflightResultForTesting(
-          url, response_head, request, tainted, &detected_error_status);
-
-  EXPECT_FALSE(result);
-}
-
 }  // namespace
 
 }  // namespace cors
--- a/services/network/cross_origin_read_blocking.cc	2019-05-17 17:45:42.536000000 +0300
+++ b/services/network/cross_origin_read_blocking.cc	2019-05-17 18:53:37.884000000 +0300
@@ -428,7 +428,7 @@
       // Built into the Java Spring framework (followed by a comma and a space):
       //   https://goo.gl/xP7FWn
       //
-      // Observed on 9oo91e.qjz9zk (without a comma, followed by a newline).
+      // Observed on google.com (without a comma, followed by a newline).
       StringPiece(")]}'"),
 
       // Apache struts: https://struts.apache.org/plugins/json/#prefix
@@ -438,7 +438,7 @@
       StringPiece("{} &&"),
 
       // Infinite loops.
-      StringPiece("for(;;);"),  // observed on f8c3b00k.qjz9zk
+      StringPiece("for(;;);"),  // observed on facebook.com
       StringPiece("while(1);"), StringPiece("for (;;);"),
       StringPiece("while (1);"),
   };
@@ -568,12 +568,6 @@
     const ResourceResponse& response,
     base::Optional<url::Origin> request_initiator_site_lock,
     mojom::FetchRequestMode fetch_request_mode) {
-  // TODO(lukasza): Remove |initiator_compatibility_| field once the UMAs
-  // depending on it are expired (e.g. see
-  // SiteIsolation.XSD.NetworkService.InitiatorLockCompatibility).
-  initiator_compatibility_ = VerifyRequestInitiatorLock(
-      request_initiator_site_lock, request.initiator());
-
   content_length_ = response.head.content_length;
   http_response_code_ =
       response.head.headers ? response.head.headers->response_code() : 0;
@@ -606,14 +600,16 @@
     return kAllow;
   }
 
-  // Compute the |initiator| of the request, falling back to a unique origin if
-  // there was no initiator or if it was incompatible with the lock. Using a
-  // unique origin makes CORB treat the response as cross-origin and thus
-  // considers it eligible for blocking (based on content-type, sniffing, etc.).
-  url::Origin initiator = GetTrustworthyInitiator(
-      ShouldEnforceInitiatorLock() ? request_initiator_site_lock_
-                                   : base::nullopt,
-      request);
+  // Treat a missing initiator as an empty origin to be safe, though we don't
+  // expect this to happen.  Unfortunately, this requires a copy.
+  url::Origin initiator;
+  initiator_compatibility_ = VerifyRequestInitiatorLock(
+      request_initiator_site_lock_, request.initiator());
+  bool block_untrustworthy_initiator =
+      ShouldEnforceInitiatorLock() &&
+      initiator_compatibility_ == InitiatorLockCompatibility::kIncorrectLock;
+  if (request.initiator().has_value() && !block_untrustworthy_initiator)
+    initiator = request.initiator().value();
 
   // Don't block same-origin documents.
   if (initiator.IsSameOriginWith(target_origin))
--- a/services/network/cross_origin_read_blocking.h	2019-05-17 17:45:42.536000000 +0300
+++ b/services/network/cross_origin_read_blocking.h	2019-05-17 18:53:37.884000000 +0300
@@ -226,7 +226,7 @@
   //
   // TODO(lukasza, laforge): https://crbug.com/702995: Remove the static
   // ...ForPlugin methods once Flash support is removed from Chromium (probably
-  // around 2020 - see https://www.ch40m1um.qjz9zk/flash-roadmap).
+  // around 2020 - see https://www.chromium.org/flash-roadmap).
   static void AddExceptionForPlugin(int process_id);
 
   // Returns true if CORB should ignore a request initiated by a universal
--- a/services/network/cross_origin_read_blocking_unittest.cc	2019-05-17 17:45:42.540000000 +0300
+++ b/services/network/cross_origin_read_blocking_unittest.cc	2019-05-17 18:53:37.884000000 +0300
@@ -17,11 +17,11 @@
 
 TEST(CrossOriginReadBlockingTest, IsBlockableScheme) {
   GURL data_url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA==");
-  GURL ftp_url("ftp://9oo91e.qjz9zk");
-  GURL mailto_url("mailto:google@9oo91e.qjz9zk");
+  GURL ftp_url("ftp://google.com");
+  GURL mailto_url("mailto:google@google.com");
   GURL about_url("about:chrome");
-  GURL http_url("http://9oo91e.qjz9zk");
-  GURL https_url("https://9oo91e.qjz9zk");
+  GURL http_url("http://google.com");
+  GURL https_url("https://google.com");
 
   EXPECT_FALSE(CrossOriginReadBlocking::IsBlockableScheme(data_url));
   EXPECT_FALSE(CrossOriginReadBlocking::IsBlockableScheme(ftp_url));
@@ -32,21 +32,21 @@
 }
 
 TEST(CrossOriginReadBlockingTest, IsValidCorsHeaderSet) {
-  url::Origin frame_origin = url::Origin::Create(GURL("http://www.9oo91e.qjz9zk"));
+  url::Origin frame_origin = url::Origin::Create(GURL("http://www.google.com"));
 
   EXPECT_TRUE(CrossOriginReadBlocking::IsValidCorsHeaderSet(frame_origin, "*"));
   EXPECT_FALSE(
       CrossOriginReadBlocking::IsValidCorsHeaderSet(frame_origin, "\"*\""));
   EXPECT_FALSE(CrossOriginReadBlocking::IsValidCorsHeaderSet(
-      frame_origin, "http://mail.9oo91e.qjz9zk"));
+      frame_origin, "http://mail.google.com"));
   EXPECT_TRUE(CrossOriginReadBlocking::IsValidCorsHeaderSet(
-      frame_origin, "http://www.9oo91e.qjz9zk"));
+      frame_origin, "http://www.google.com"));
   EXPECT_FALSE(CrossOriginReadBlocking::IsValidCorsHeaderSet(
-      frame_origin, "https://www.9oo91e.qjz9zk"));
+      frame_origin, "https://www.google.com"));
   EXPECT_FALSE(CrossOriginReadBlocking::IsValidCorsHeaderSet(
       frame_origin, "http://yahoo.com"));
   EXPECT_FALSE(CrossOriginReadBlocking::IsValidCorsHeaderSet(frame_origin,
-                                                             "www.9oo91e.qjz9zk"));
+                                                             "www.google.com"));
 }
 
 TEST(CrossOriginReadBlockingTest, SniffForHTML) {
--- a/services/network/cross_origin_resource_policy.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/cross_origin_resource_policy.cc	2019-05-17 18:53:37.884000000 +0300
@@ -124,12 +124,22 @@
     return kAllow;
   }
 
+  // Compute |target_origin| and |initiator|.  Initial, opaque |initiator| will
+  // be used unless request.initiator() has a value that is compatible with the
+  // |request_initiator_site_lock|.
+  url::Origin target_origin = url::Origin::Create(request.url());
+  url::Origin initiator;
+  InitiatorLockCompatibility initiator_compatibility =
+      VerifyRequestInitiatorLock(request_initiator_site_lock,
+                                 request.initiator());
+  if (request.initiator().has_value() &&
+      initiator_compatibility != InitiatorLockCompatibility::kIncorrectLock) {
+    initiator = request.initiator().value();
+  }
+
   // From https://fetch.spec.whatwg.org/#cross-origin-resource-policy-header:
   // > 2. If request’s origin is same origin with request’s current URL’s
   //      origin, then return allowed.
-  url::Origin target_origin = url::Origin::Create(request.url());
-  url::Origin initiator =
-      GetTrustworthyInitiator(request_initiator_site_lock, request);
   if (initiator == target_origin)
     return kAllow;
 
--- a/services/network/expect_ct_reporter.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/expect_ct_reporter.cc	2019-05-17 18:53:37.884000000 +0300
@@ -8,7 +8,6 @@
 #include <string>
 
 #include "base/base64.h"
-#include "base/bind.h"
 #include "base/command_line.h"
 #include "base/feature_list.h"
 #include "base/json/json_writer.h"
@@ -79,7 +78,7 @@
   return "";
 }
 
-bool AddSCT(const net::SignedCertificateTimestampAndStatus& sct,
+void AddSCT(const net::SignedCertificateTimestampAndStatus& sct,
             base::ListValue* list) {
   std::unique_ptr<base::DictionaryValue> list_item(new base::DictionaryValue());
   // Chrome implements RFC6962, not 6962-bis, so the reports contain v1 SCTs.
@@ -102,13 +101,11 @@
   list_item->SetString("status", status);
   list_item->SetString("source", SCTOriginToString(sct.sct->origin));
   std::string serialized_sct;
-  if (!net::ct::EncodeSignedCertificateTimestamp(sct.sct, &serialized_sct))
-    return false;
+  net::ct::EncodeSignedCertificateTimestamp(sct.sct, &serialized_sct);
   std::string encoded_serialized_sct;
   base::Base64Encode(serialized_sct, &encoded_serialized_sct);
   list_item->SetString("serialized_sct", encoded_serialized_sct);
   list->Append(std::move(list_item));
-  return true;
 }
 
 constexpr net::NetworkTrafficAnnotationTag kExpectCTReporterTrafficAnnotation =
@@ -178,8 +175,7 @@
 
   std::unique_ptr<base::ListValue> scts(new base::ListValue());
   for (const auto& sct_and_status : signed_certificate_timestamps) {
-    if (!AddSCT(sct_and_status, scts.get()))
-      LOG(ERROR) << "Failed to add signed certificate timestamp to list";
+    AddSCT(sct_and_status, scts.get());
   }
   report->Set("scts", std::move(scts));
 
--- a/services/network/expect_ct_reporter_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/expect_ct_reporter_unittest.cc	2019-05-17 18:53:37.884000000 +0300
@@ -7,7 +7,6 @@
 #include <string>
 
 #include "base/base64.h"
-#include "base/bind.h"
 #include "base/command_line.h"
 #include "base/json/json_reader.h"
 #include "base/run_loop.h"
@@ -150,10 +149,8 @@
     net::ct::SCTVerifyStatus expected_status,
     const base::ListValue& report_list) {
   std::string expected_serialized_sct;
-  if (!net::ct::EncodeSignedCertificateTimestamp(expected_sct,
-                                                 &expected_serialized_sct)) {
-    return ::testing::AssertionFailure() << "Failed to serialize SCT";
-  }
+  net::ct::EncodeSignedCertificateTimestamp(expected_sct,
+                                            &expected_serialized_sct);
 
   for (size_t i = 0; i < report_list.GetSize(); i++) {
     const base::DictionaryValue* report_sct;
@@ -217,8 +214,7 @@
                          const net::HostPortPair& host_port,
                          const std::string& expiration,
                          const net::SSLInfo& ssl_info) {
-  std::unique_ptr<base::Value> value(
-      base::JSONReader::ReadDeprecated(serialized_report));
+  std::unique_ptr<base::Value> value(base::JSONReader::Read(serialized_report));
   ASSERT_TRUE(value);
   ASSERT_TRUE(value->is_dict());
 
--- a/services/network/host_resolver.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/host_resolver.cc	2019-05-17 18:53:37.884000000 +0300
@@ -34,10 +34,7 @@
   parameters.dns_query_type = mojo_parameters->dns_query_type;
   parameters.initial_priority = mojo_parameters->initial_priority;
   parameters.source = mojo_parameters->source;
-  parameters.cache_usage =
-      mojo_parameters->allow_cached_response
-          ? net::HostResolver::ResolveHostParameters::CacheUsage::ALLOWED
-          : net::HostResolver::ResolveHostParameters::CacheUsage::DISALLOWED;
+  parameters.allow_cached_response = mojo_parameters->allow_cached_response;
   parameters.include_canonical_name = mojo_parameters->include_canonical_name;
   parameters.loopback_only = mojo_parameters->loopback_only;
   parameters.is_speculative = mojo_parameters->is_speculative;
--- a/services/network/host_resolver_mdns_listener.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/host_resolver_mdns_listener.cc	2019-05-17 18:53:37.884000000 +0300
@@ -6,7 +6,6 @@
 
 #include <utility>
 
-#include "base/bind.h"
 #include "base/callback.h"
 #include "net/base/host_port_pair.h"
 
--- a/services/network/host_resolver_unittest.cc	2019-05-17 17:45:42.540000000 +0300
+++ b/services/network/host_resolver_unittest.cc	2019-05-17 18:53:37.884000000 +0300
@@ -20,10 +20,10 @@
 #include "net/base/ip_address.h"
 #include "net/base/ip_endpoint.h"
 #include "net/base/net_errors.h"
-#include "net/dns/context_host_resolver.h"
 #include "net/dns/dns_config.h"
 #include "net/dns/dns_test_util.h"
 #include "net/dns/host_resolver.h"
+#include "net/dns/host_resolver_impl.h"
 #include "net/dns/mock_host_resolver.h"
 #include "net/dns/public/dns_protocol.h"
 #include "net/log/net_log.h"
@@ -1136,7 +1136,7 @@
   static const char* kTextRecords[] = {"foo", "bar", "more text"};
   net::MockDnsClientRuleList rules;
   rules.emplace_back(
-      "example.com", net::dns_protocol::kTypeTXT, net::SecureDnsMode::AUTOMATIC,
+      "example.com", net::dns_protocol::kTypeTXT,
       net::MockDnsClientRule::Result(net::BuildTestDnsResponse(
           "example.com", {std::vector<std::string>(std::begin(kTextRecords),
                                                    std::end(kTextRecords))})),
@@ -1145,9 +1145,9 @@
       std::make_unique<net::MockDnsClient>(net::DnsConfig(), std::move(rules));
 
   net::NetLog net_log;
-  std::unique_ptr<net::ContextHostResolver> inner_resolver =
+  std::unique_ptr<net::HostResolverImpl> inner_resolver =
       net::HostResolver::CreateDefaultResolverImpl(&net_log);
-  inner_resolver->SetDnsClientForTesting(std::move(dns_client));
+  inner_resolver->SetDnsClient(std::move(dns_client));
   inner_resolver->SetBaseDnsConfigForTesting(CreateValidDnsConfig());
 
   HostResolver resolver(inner_resolver.get(), &net_log);
@@ -1175,17 +1175,17 @@
 TEST_F(HostResolverTest, HostResults) {
   net::MockDnsClientRuleList rules;
   rules.emplace_back(
-      "example.com", net::dns_protocol::kTypePTR, net::SecureDnsMode::AUTOMATIC,
+      "example.com", net::dns_protocol::kTypePTR,
       net::MockDnsClientRule::Result(net::BuildTestDnsPointerResponse(
-          "example.com", {"9oo91e.qjz9zk", "ch40m1um.qjz9zk"})),
+          "example.com", {"google.com", "chromium.org"})),
       false /* delay */);
   auto dns_client =
       std::make_unique<net::MockDnsClient>(net::DnsConfig(), std::move(rules));
 
   net::NetLog net_log;
-  std::unique_ptr<net::ContextHostResolver> inner_resolver =
+  std::unique_ptr<net::HostResolverImpl> inner_resolver =
       net::HostResolver::CreateDefaultResolverImpl(&net_log);
-  inner_resolver->SetDnsClientForTesting(std::move(dns_client));
+  inner_resolver->SetDnsClient(std::move(dns_client));
   inner_resolver->SetBaseDnsConfigForTesting(CreateValidDnsConfig());
 
   HostResolver resolver(inner_resolver.get(), &net_log);
@@ -1207,8 +1207,8 @@
   EXPECT_FALSE(response_client.result_text());
   EXPECT_THAT(response_client.result_hosts(),
               testing::Optional(testing::UnorderedElementsAre(
-                  net::HostPortPair("9oo91e.qjz9zk", 160),
-                  net::HostPortPair("ch40m1um.qjz9zk", 160))));
+                  net::HostPortPair("google.com", 160),
+                  net::HostPortPair("chromium.org", 160))));
   EXPECT_EQ(0u, resolver.GetNumOutstandingRequestsForTesting());
 }
 
--- a/services/network/http_cache_data_counter.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/http_cache_data_counter.cc	2019-05-17 18:53:37.884000000 +0300
@@ -6,7 +6,6 @@
 
 #include <utility>
 
-#include "base/bind.h"
 #include "base/callback.h"
 #include "base/location.h"
 #include "base/threading/sequenced_task_runner_handle.h"
--- a/services/network/http_cache_data_counter_unittest.cc	2019-05-17 17:45:42.544000000 +0300
+++ b/services/network/http_cache_data_counter_unittest.cc	2019-05-17 18:53:37.888000000 +0300
@@ -41,8 +41,8 @@
 };
 
 constexpr CacheTestEntry kCacheEntries[] = {
-    {"http://www.9oo91e.qjz9zk", "15 Jun 1975", 1024},
-    {"https://www.9oo91e.qjz9zk", "15 Jun 1985", 2048},
+    {"http://www.google.com", "15 Jun 1975", 1024},
+    {"https://www.google.com", "15 Jun 1985", 2048},
     {"http://www.wikipedia.com", "15 Jun 1995", 4096},
     {"https://www.wikipedia.com", "15 Jun 2005", 8192},
     {"http://localhost:1234/mysite", "15 Jun 2015", 16384},
--- a/services/network/http_cache_data_remover.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/http_cache_data_remover.cc	2019-05-17 18:53:37.888000000 +0300
@@ -7,7 +7,6 @@
 #include <set>
 #include <string>
 
-#include "base/bind.h"
 #include "base/location.h"
 #include "base/threading/sequenced_task_runner_handle.h"
 #include "net/base/registry_controlled_domains/registry_controlled_domain.h"
--- a/services/network/http_cache_data_remover_unittest.cc	2019-05-17 17:45:42.544000000 +0300
+++ b/services/network/http_cache_data_remover_unittest.cc	2019-05-17 18:53:37.888000000 +0300
@@ -47,8 +47,8 @@
 }
 
 constexpr CacheTestEntry kCacheEntries[] = {
-    {"http://www.9oo91e.qjz9zk", "15 Jun 1975"},
-    {"https://www.9oo91e.qjz9zk", "15 Jun 1985"},
+    {"http://www.google.com", "15 Jun 1975"},
+    {"https://www.google.com", "15 Jun 1985"},
     {"http://www.wikipedia.com", "15 Jun 1995"},
     {"https://www.wikipedia.com", "15 Jun 2005"},
     {"http://localhost:1234/mysite", "15 Jun 2015"},
@@ -159,7 +159,7 @@
   mojom::ClearDataFilterPtr filter = mojom::ClearDataFilter::New();
   filter->type = mojom::ClearDataFilter_Type::DELETE_MATCHES;
   filter->domains.push_back("wikipedia.com");
-  filter->domains.push_back("9oo91e.qjz9zk");
+  filter->domains.push_back("google.com");
   RemoveData(std::move(filter), base::Time(), base::Time());
   EXPECT_FALSE(HasEntry(kCacheEntries[0].url));
   EXPECT_FALSE(HasEntry(kCacheEntries[1].url));
@@ -172,7 +172,7 @@
   mojom::ClearDataFilterPtr filter = mojom::ClearDataFilter::New();
   filter->type = mojom::ClearDataFilter_Type::KEEP_MATCHES;
   filter->domains.push_back("wikipedia.com");
-  filter->domains.push_back("9oo91e.qjz9zk");
+  filter->domains.push_back("google.com");
   RemoveData(std::move(filter), base::Time(), base::Time());
   EXPECT_TRUE(HasEntry(kCacheEntries[0].url));
   EXPECT_TRUE(HasEntry(kCacheEntries[1].url));
@@ -184,7 +184,7 @@
 TEST_F(HttpCacheDataRemoverTest, FilterDeleteByOrigin) {
   mojom::ClearDataFilterPtr filter = mojom::ClearDataFilter::New();
   filter->type = mojom::ClearDataFilter_Type::DELETE_MATCHES;
-  filter->origins.push_back(url::Origin::Create(GURL("http://www.9oo91e.qjz9zk")));
+  filter->origins.push_back(url::Origin::Create(GURL("http://www.google.com")));
   filter->origins.push_back(url::Origin::Create(GURL("http://localhost:1234")));
   RemoveData(std::move(filter), base::Time(), base::Time());
   EXPECT_FALSE(HasEntry(kCacheEntries[0].url));
@@ -195,7 +195,7 @@
 TEST_F(HttpCacheDataRemoverTest, FilterKeepByOrigin) {
   mojom::ClearDataFilterPtr filter = mojom::ClearDataFilter::New();
   filter->type = mojom::ClearDataFilter_Type::KEEP_MATCHES;
-  filter->origins.push_back(url::Origin::Create(GURL("http://www.9oo91e.qjz9zk")));
+  filter->origins.push_back(url::Origin::Create(GURL("http://www.google.com")));
   filter->origins.push_back(url::Origin::Create(GURL("http://localhost:1234")));
   RemoveData(std::move(filter), base::Time(), base::Time());
   EXPECT_TRUE(HasEntry(kCacheEntries[0].url));
@@ -264,7 +264,7 @@
 TEST_F(HttpCacheDataRemoverTest, FilterDeleteByDomainAndDate) {
   mojom::ClearDataFilterPtr filter = mojom::ClearDataFilter::New();
   filter->type = mojom::ClearDataFilter_Type::DELETE_MATCHES;
-  filter->domains.push_back("9oo91e.qjz9zk");
+  filter->domains.push_back("google.com");
   filter->domains.push_back("wikipedia.com");
 
   base::Time start_time;
@@ -282,7 +282,7 @@
 TEST_F(HttpCacheDataRemoverTest, FilterKeepByDomainAndDate) {
   mojom::ClearDataFilterPtr filter = mojom::ClearDataFilter::New();
   filter->type = mojom::ClearDataFilter_Type::KEEP_MATCHES;
-  filter->domains.push_back("9oo91e.qjz9zk");
+  filter->domains.push_back("google.com");
   filter->domains.push_back("wikipedia.com");
 
   base::Time start_time;
--- a/services/network/ignore_errors_cert_verifier_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/ignore_errors_cert_verifier_unittest.cc	2019-05-17 18:53:37.888000000 +0300
@@ -76,7 +76,7 @@
   void SetUp() override {
     verifier_.set_whitelist(
         IgnoreErrorsCertVerifier::MakeWhitelist(MakeWhitelist()));
-  }
+  };
 
   // The wrapped CertVerifier. Defaults to returning ERR_CERT_INVALID. Owned by
   // |verifier_|.
@@ -190,7 +190,7 @@
   }
 }
 
-INSTANTIATE_TEST_SUITE_P(WithUserDataDirSwitchPresent,
+INSTANTIATE_TEST_CASE_P(WithUserDataDirSwitchPresent,
                          IgnoreCertificateErrorsSPKIListFlagTest,
                          ::testing::Bool());
 
--- a/services/network/initiator_lock_compatibility.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/initiator_lock_compatibility.cc	2019-05-17 18:53:37.888000000 +0300
@@ -68,24 +68,4 @@
                                     request.request_initiator);
 }
 
-url::Origin GetTrustworthyInitiator(
-    const base::Optional<url::Origin>& request_initiator_site_lock,
-    const net::URLRequest& request) {
-  // Returning a unique origin as a fallback should be safe - such origin will
-  // be considered cross-origin from all other origins.
-  url::Origin unique_origin_fallback;
-
-  if (!request.initiator().has_value())
-    return unique_origin_fallback;
-
-  InitiatorLockCompatibility initiator_compatibility =
-      VerifyRequestInitiatorLock(request_initiator_site_lock,
-                                 request.initiator());
-  if (initiator_compatibility == InitiatorLockCompatibility::kIncorrectLock)
-    return unique_origin_fallback;
-
-  // If all the checks above passed, then |request.initiator()| is trustworthy.
-  return request.initiator().value();
-}
-
 }  // namespace network
--- a/services/network/initiator_lock_compatibility.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/initiator_lock_compatibility.h	2019-05-17 18:53:37.888000000 +0300
@@ -9,10 +9,6 @@
 #include "base/optional.h"
 #include "url/origin.h"
 
-namespace net {
-class URLRequest;
-}  // namespace net
-
 namespace network {
 
 struct ResourceRequest;
@@ -63,16 +59,6 @@
     const base::Optional<url::Origin>& request_initiator_site_lock,
     const base::Optional<url::Origin>& request_initiator);
 
-// Gets initiator of |request|, falling back to a unique origin if
-// 1) |request.initiator()| is missing or
-// 2) |request.initiator()| is incompatible with |request_initiator_site_lock|.
-//
-// |request_initiator_site_lock| should come from
-// URLLoaderFactoryParams::request_initiator_site_lock.
-url::Origin GetTrustworthyInitiator(
-    const base::Optional<url::Origin>& request_initiator_site_lock,
-    const net::URLRequest& request);
-
 }  // namespace network
 
 #endif  // SERVICES_NETWORK_INITIATOR_LOCK_COMPATIBILITY_H_
--- a/services/network/mdns_responder_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/mdns_responder_unittest.cc	2019-05-17 18:53:37.888000000 +0300
@@ -11,7 +11,6 @@
 #include "services/network/mdns_responder.h"
 
 #include "base/bind.h"
-#include "base/bind_helpers.h"
 #include "base/logging.h"
 #include "base/memory/scoped_refptr.h"
 #include "base/strings/string_piece.h"
--- a/services/network/mojo_host_resolver_impl.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/mojo_host_resolver_impl.cc	2019-05-17 18:53:37.888000000 +0300
@@ -5,15 +5,11 @@
 #include "services/network/mojo_host_resolver_impl.h"
 
 #include <utility>
-#include <vector>
 
-#include "base/bind.h"
-#include "base/logging.h"
-#include "net/base/host_port_pair.h"
-#include "net/base/ip_address.h"
+#include "net/base/address_list.h"
 #include "net/base/net_errors.h"
+#include "net/base/network_interfaces.h"
 #include "net/dns/host_resolver.h"
-#include "net/dns/public/dns_query_type.h"
 
 namespace network {
 
@@ -24,8 +20,7 @@
  public:
   Job(MojoHostResolverImpl* resolver_service,
       net::HostResolver* resolver,
-      const std::string& hostname,
-      bool is_ex,
+      const net::HostResolver::RequestInfo& request_info,
       const net::NetLogWithSource& net_log,
       proxy_resolver::mojom::HostResolverRequestClientPtr client);
   ~Job();
@@ -45,9 +40,12 @@
   // This Job's iterator in |resolver_service_|, so the Job may be removed on
   // completion.
   std::list<Job>::iterator iter_;
+  net::HostResolver* resolver_;
+  net::HostResolver::RequestInfo request_info_;
+  const net::NetLogWithSource net_log_;
   proxy_resolver::mojom::HostResolverRequestClientPtr client_;
-  const std::string hostname_;
-  std::unique_ptr<net::HostResolver::ResolveHostRequest> request_;
+  std::unique_ptr<net::HostResolver::Request> request_;
+  net::AddressList result_;
   base::ThreadChecker thread_checker_;
 };
 
@@ -60,12 +58,17 @@
 }
 
 void MojoHostResolverImpl::Resolve(
-    const std::string& hostname,
-    bool is_ex,
+    std::unique_ptr<net::HostResolver::RequestInfo> request_info,
     proxy_resolver::mojom::HostResolverRequestClientPtr client) {
   DCHECK(thread_checker_.CalledOnValidThread());
+  if (request_info->is_my_ip_address()) {
+    // The proxy resolver running inside a sandbox may not be able to get the
+    // correct host name. Instead, fill it ourself if the request is for our own
+    // IP address.
+    request_info->set_host_port_pair(net::HostPortPair(net::GetHostName(), 80));
+  }
 
-  pending_jobs_.emplace_front(this, resolver_, hostname, is_ex, net_log_,
+  pending_jobs_.emplace_front(this, resolver_, *request_info, net_log_,
                               std::move(client));
   auto job = pending_jobs_.begin();
   job->set_iter(job);
@@ -80,30 +83,28 @@
 MojoHostResolverImpl::Job::Job(
     MojoHostResolverImpl* resolver_service,
     net::HostResolver* resolver,
-    const std::string& hostname,
-    bool is_ex,
+    const net::HostResolver::RequestInfo& request_info,
     const net::NetLogWithSource& net_log,
     proxy_resolver::mojom::HostResolverRequestClientPtr client)
     : resolver_service_(resolver_service),
-      client_(std::move(client)),
-      hostname_(hostname) {
+      resolver_(resolver),
+      request_info_(request_info),
+      net_log_(net_log),
+      client_(std::move(client)) {
   client_.set_connection_error_handler(base::Bind(
       &MojoHostResolverImpl::Job::OnConnectionError, base::Unretained(this)));
-
-  net::HostResolver::ResolveHostParameters parameters;
-  if (!is_ex)
-    parameters.dns_query_type = net::DnsQueryType::A;
-  request_ = resolver->CreateRequest(net::HostPortPair(hostname_, 0), net_log,
-                                     parameters);
 }
 
 void MojoHostResolverImpl::Job::Start() {
   // The caller is responsible for setting up |iter_|.
   DCHECK_EQ(this, &*iter_);
 
-  DVLOG(1) << "Resolve " << hostname_;
-  int result = request_->Start(base::BindOnce(
-      &MojoHostResolverImpl::Job::OnResolveDone, base::Unretained(this)));
+  DVLOG(1) << "Resolve " << request_info_.host_port_pair().ToString();
+  int result =
+      resolver_->Resolve(request_info_, net::DEFAULT_PRIORITY, &result_,
+                         base::Bind(&MojoHostResolverImpl::Job::OnResolveDone,
+                                    base::Unretained(this)),
+                         &request_, net_log_);
 
   if (result != net::ERR_IO_PENDING)
     OnResolveDone(result);
@@ -113,23 +114,14 @@
 
 void MojoHostResolverImpl::Job::OnResolveDone(int result) {
   DCHECK(thread_checker_.CalledOnValidThread());
-
-  std::vector<net::IPAddress> result_addresses;
-  if (request_->GetAddressResults()) {
-    for (const auto& endpoint :
-         request_->GetAddressResults().value().endpoints()) {
-      result_addresses.push_back(endpoint.address());
-    }
-  }
-
   request_.reset();
-  DVLOG(1) << "Resolved " << hostname_ << " with error " << result << " and "
-           << result_addresses.size() << " results!";
-  for (const auto& address : result_addresses) {
+  DVLOG(1) << "Resolved " << request_info_.host_port_pair().ToString()
+           << " with error " << result << " and " << result_.size()
+           << " results!";
+  for (const auto& address : result_) {
     DVLOG(1) << address.ToString();
   }
-  client_->ReportResult(result, result_addresses);
-
+  client_->ReportResult(result, result_);
   resolver_service_->DeleteJob(iter_);
 }
 
@@ -137,7 +129,8 @@
   DCHECK(thread_checker_.CalledOnValidThread());
   // |resolver_service_| should always outlive us.
   DCHECK(resolver_service_);
-  DVLOG(1) << "Connection error on request for " << hostname_;
+  DVLOG(1) << "Connection error on request for "
+           << request_info_.host_port_pair().ToString();
   resolver_service_->DeleteJob(iter_);
 }
 
--- a/services/network/mojo_host_resolver_impl.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/mojo_host_resolver_impl.h	2019-05-17 18:53:37.888000000 +0300
@@ -7,7 +7,6 @@
 
 #include <list>
 #include <memory>
-#include <string>
 
 #include "base/component_export.h"
 #include "base/macros.h"
@@ -37,8 +36,7 @@
                        const net::NetLogWithSource& net_log);
   ~MojoHostResolverImpl();
 
-  void Resolve(const std::string& hostname,
-               bool is_ex,
+  void Resolve(std::unique_ptr<net::HostResolver::RequestInfo> request_info,
                proxy_resolver::mojom::HostResolverRequestClientPtr client);
 
   bool request_in_progress() { return !pending_jobs_.empty(); }
--- a/services/network/mojo_host_resolver_impl_unittest.cc	2019-05-17 17:45:42.544000000 +0300
+++ b/services/network/mojo_host_resolver_impl_unittest.cc	2019-05-17 18:53:37.888000000 +0300
@@ -6,17 +6,14 @@
 
 #include <string>
 #include <utility>
-#include <vector>
 
-#include "base/bind.h"
 #include "base/callback_helpers.h"
 #include "base/run_loop.h"
 #include "base/test/scoped_task_environment.h"
 #include "base/time/time.h"
 #include "mojo/public/cpp/bindings/binding.h"
 #include "mojo/public/cpp/bindings/interface_request.h"
-#include "net/base/address_family.h"
-#include "net/base/ip_address.h"
+#include "net/base/address_list.h"
 #include "net/base/net_errors.h"
 #include "net/dns/mock_host_resolver.h"
 #include "net/test/gtest_util.h"
@@ -45,12 +42,11 @@
   void WaitForConnectionError();
 
   int32_t error_;
-  std::vector<net::IPAddress> results_;
+  net::AddressList results_;
 
  private:
   // Overridden from proxy_resolver::mojom::HostResolverRequestClient.
-  void ReportResult(int32_t error,
-                    const std::vector<net::IPAddress>& results) override;
+  void ReportResult(int32_t error, const net::AddressList& results) override;
 
   // Mojo error handler.
   void OnConnectionError();
@@ -78,9 +74,8 @@
   run_loop.Run();
 }
 
-void TestRequestClient::ReportResult(
-    int32_t error,
-    const std::vector<net::IPAddress>& results) {
+void TestRequestClient::ReportResult(int32_t error,
+                                     const net::AddressList& results) {
   if (!run_loop_quit_closure_.is_null()) {
     run_loop_quit_closure_.Run();
   }
@@ -95,39 +90,78 @@
     connection_error_quit_closure_.Run();
 }
 
+class CallbackMockHostResolver : public net::MockHostResolver {
+ public:
+  CallbackMockHostResolver() = default;
+  ~CallbackMockHostResolver() override = default;
+
+  // Set a callback to run whenever Resolve is called. Callback is cleared after
+  // every run.
+  void SetResolveCallback(base::Closure callback) {
+    resolve_callback_ = callback;
+  }
+
+  // Overridden from MockHostResolver.
+  int Resolve(const RequestInfo& info,
+              net::RequestPriority priority,
+              net::AddressList* addresses,
+              net::CompletionOnceCallback callback,
+              std::unique_ptr<Request>* request,
+              const net::NetLogWithSource& net_log) override;
+
+ private:
+  base::Closure resolve_callback_;
+};
+
+int CallbackMockHostResolver::Resolve(const RequestInfo& info,
+                                      net::RequestPriority priority,
+                                      net::AddressList* addresses,
+                                      net::CompletionOnceCallback callback,
+                                      std::unique_ptr<Request>* request,
+                                      const net::NetLogWithSource& net_log) {
+  int result = MockHostResolver::Resolve(info, priority, addresses,
+                                         std::move(callback), request, net_log);
+  if (!resolve_callback_.is_null()) {
+    std::move(resolve_callback_).Run();
+  }
+  return result;
+}
+
 }  // namespace
 
 class MojoHostResolverImplTest : public testing::Test {
  protected:
-  const net::IPAddress kExampleComAddress{1, 2, 3, 4};
-  const net::IPAddress kExampleComAddressIpv6{1, 2,  3,  4,  5,  6,  7,  8,
-                                              9, 10, 11, 12, 13, 14, 15, 16};
-  const net::IPAddress kChromiumOrgAddress{8, 8, 8, 8};
-
   void SetUp() override {
-    mock_host_resolver_.rules()->AddRuleForAddressFamily(
-        "example.com", net::ADDRESS_FAMILY_IPV4, kExampleComAddress.ToString());
-    mock_host_resolver_.rules()->AddRule("example.com",
-                                         kExampleComAddressIpv6.ToString());
-    mock_host_resolver_.rules()->AddRule("ch40m1um.qjz9zk",
-                                         kChromiumOrgAddress.ToString());
+    mock_host_resolver_.rules()->AddRule("example.com", "1.2.3.4");
+    mock_host_resolver_.rules()->AddRule("chromium.org", "8.8.8.8");
     mock_host_resolver_.rules()->AddSimulatedFailure("failure.fail");
 
     resolver_service_.reset(new MojoHostResolverImpl(&mock_host_resolver_,
                                                      net::NetLogWithSource()));
   }
 
+  std::unique_ptr<net::HostResolver::RequestInfo>
+  CreateRequest(const std::string& host, uint16_t port, bool is_my_ip_address) {
+    std::unique_ptr<net::HostResolver::RequestInfo> request =
+        std::make_unique<net::HostResolver::RequestInfo>(
+            net::HostPortPair(host, port));
+    request->set_is_my_ip_address(is_my_ip_address);
+    request->set_address_family(net::ADDRESS_FAMILY_IPV4);
+    return request;
+  }
+
   // Wait until the mock resolver has received |num| resolve requests.
   void WaitForRequests(size_t num) {
     while (mock_host_resolver_.num_resolve() < num) {
       base::RunLoop run_loop;
-      run_loop.RunUntilIdle();
+      mock_host_resolver_.SetResolveCallback(run_loop.QuitClosure());
+      run_loop.Run();
     }
   }
 
   base::test::ScopedTaskEnvironment scoped_task_environment_;
 
-  net::MockHostResolver mock_host_resolver_;
+  CallbackMockHostResolver mock_host_resolver_;
   std::unique_ptr<MojoHostResolverImpl> resolver_service_;
 };
 
@@ -135,12 +169,14 @@
   proxy_resolver::mojom::HostResolverRequestClientPtr client_ptr;
   TestRequestClient client(mojo::MakeRequest(&client_ptr));
 
-  resolver_service_->Resolve("example.com", false /* is_ex */,
+  resolver_service_->Resolve(CreateRequest("example.com", 80, false),
                              std::move(client_ptr));
   client.WaitForResult();
 
   EXPECT_THAT(client.error_, IsOk());
-  EXPECT_THAT(client.results_, testing::ElementsAre(kExampleComAddress));
+  net::AddressList& address_list = client.results_;
+  EXPECT_EQ(1U, address_list.size());
+  EXPECT_EQ("1.2.3.4:80", address_list[0].ToString());
 }
 
 TEST_F(MojoHostResolverImplTest, ResolveSynchronous) {
@@ -149,12 +185,14 @@
 
   mock_host_resolver_.set_synchronous_mode(true);
 
-  resolver_service_->Resolve("example.com", false /* is_ex */,
+  resolver_service_->Resolve(CreateRequest("example.com", 80, false),
                              std::move(client_ptr));
   client.WaitForResult();
 
   EXPECT_THAT(client.error_, IsOk());
-  EXPECT_THAT(client.results_, testing::ElementsAre(kExampleComAddress));
+  net::AddressList& address_list = client.results_;
+  EXPECT_EQ(1U, address_list.size());
+  EXPECT_EQ("1.2.3.4:80", address_list[0].ToString());
 }
 
 TEST_F(MojoHostResolverImplTest, ResolveMultiple) {
@@ -165,9 +203,9 @@
 
   mock_host_resolver_.set_ondemand_mode(true);
 
-  resolver_service_->Resolve("example.com", false /* is_ex */,
+  resolver_service_->Resolve(CreateRequest("example.com", 80, false),
                              std::move(client1_ptr));
-  resolver_service_->Resolve("ch40m1um.qjz9zk", false /* is_ex */,
+  resolver_service_->Resolve(CreateRequest("chromium.org", 80, false),
                              std::move(client2_ptr));
   WaitForRequests(2);
   mock_host_resolver_.ResolveAllPending();
@@ -176,9 +214,13 @@
   client2.WaitForResult();
 
   EXPECT_THAT(client1.error_, IsOk());
-  EXPECT_THAT(client1.results_, testing::ElementsAre(kExampleComAddress));
+  net::AddressList& address_list1 = client1.results_;
+  EXPECT_EQ(1U, address_list1.size());
+  EXPECT_EQ("1.2.3.4:80", address_list1[0].ToString());
   EXPECT_THAT(client2.error_, IsOk());
-  EXPECT_THAT(client2.results_, testing::ElementsAre(kChromiumOrgAddress));
+  net::AddressList& address_list2 = client2.results_;
+  EXPECT_EQ(1U, address_list2.size());
+  EXPECT_EQ("8.8.8.8:80", address_list2[0].ToString());
 }
 
 TEST_F(MojoHostResolverImplTest, ResolveDuplicate) {
@@ -189,9 +231,9 @@
 
   mock_host_resolver_.set_ondemand_mode(true);
 
-  resolver_service_->Resolve("example.com", false /* is_ex */,
+  resolver_service_->Resolve(CreateRequest("example.com", 80, false),
                              std::move(client1_ptr));
-  resolver_service_->Resolve("example.com", false /* is_ex */,
+  resolver_service_->Resolve(CreateRequest("example.com", 80, false),
                              std::move(client2_ptr));
   WaitForRequests(2);
   mock_host_resolver_.ResolveAllPending();
@@ -200,16 +242,20 @@
   client2.WaitForResult();
 
   EXPECT_THAT(client1.error_, IsOk());
-  EXPECT_THAT(client1.results_, testing::ElementsAre(kExampleComAddress));
+  net::AddressList& address_list1 = client1.results_;
+  EXPECT_EQ(1U, address_list1.size());
+  EXPECT_EQ("1.2.3.4:80", address_list1[0].ToString());
   EXPECT_THAT(client2.error_, IsOk());
-  EXPECT_THAT(client2.results_, testing::ElementsAre(kExampleComAddress));
+  net::AddressList& address_list2 = client2.results_;
+  EXPECT_EQ(1U, address_list2.size());
+  EXPECT_EQ("1.2.3.4:80", address_list2[0].ToString());
 }
 
 TEST_F(MojoHostResolverImplTest, ResolveFailure) {
   proxy_resolver::mojom::HostResolverRequestClientPtr client_ptr;
   TestRequestClient client(mojo::MakeRequest(&client_ptr));
 
-  resolver_service_->Resolve("failure.fail", false /* is_ex */,
+  resolver_service_->Resolve(CreateRequest("failure.fail", 80, false),
                              std::move(client_ptr));
   client.WaitForResult();
 
@@ -217,18 +263,6 @@
   EXPECT_TRUE(client.results_.empty());
 }
 
-TEST_F(MojoHostResolverImplTest, ResolveEx) {
-  proxy_resolver::mojom::HostResolverRequestClientPtr client_ptr;
-  TestRequestClient client(mojo::MakeRequest(&client_ptr));
-
-  resolver_service_->Resolve("example.com", true /* is_ex */,
-                             std::move(client_ptr));
-  client.WaitForResult();
-
-  EXPECT_THAT(client.error_, IsOk());
-  EXPECT_THAT(client.results_, testing::ElementsAre(kExampleComAddressIpv6));
-}
-
 TEST_F(MojoHostResolverImplTest, DestroyClient) {
   proxy_resolver::mojom::HostResolverRequestClientPtr client_ptr;
   std::unique_ptr<TestRequestClient> client(
@@ -236,7 +270,7 @@
 
   mock_host_resolver_.set_ondemand_mode(true);
 
-  resolver_service_->Resolve("example.com", false /* is_ex */,
+  resolver_service_->Resolve(CreateRequest("example.com", 80, false),
                              std::move(client_ptr));
   WaitForRequests(1);
 
--- a/services/network/net_log_exporter.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/net_log_exporter.cc	2019-05-17 18:53:37.892000000 +0300
@@ -4,7 +4,6 @@
 
 #include "services/network/net_log_exporter.h"
 
-#include "base/bind.h"
 #include "base/callback.h"
 #include "base/command_line.h"
 #include "base/files/file_path.h"
--- a/services/network/network_change_manager.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/network_change_manager.cc	2019-05-17 18:53:37.892000000 +0300
@@ -7,7 +7,6 @@
 #include <algorithm>
 #include <utility>
 
-#include "base/bind.h"
 #include "base/logging.h"
 #include "net/base/network_change_notifier.h"
 #include "net/base/network_change_notifier_posix.h"
--- a/services/network/network_context.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/network_context.cc	2019-05-17 18:53:37.892000000 +0300
@@ -9,7 +9,6 @@
 
 #include "base/barrier_closure.h"
 #include "base/base64.h"
-#include "base/bind.h"
 #include "base/command_line.h"
 #include "base/containers/unique_ptr_adapters.h"
 #include "base/debug/dump_without_crashing.h"
@@ -142,13 +141,6 @@
 #include "base/android/application_status_listener.h"
 #endif
 
-#if BUILDFLAG(TRIAL_COMPARISON_CERT_VERIFIER_SUPPORTED)
-#include "net/cert/caching_cert_verifier.h"
-#include "net/cert/cert_verify_proc.h"
-#include "net/cert/cert_verify_proc_builtin.h"
-#include "services/network/trial_comparison_cert_verifier_mojo.h"
-#endif
-
 namespace network {
 
 namespace {
@@ -687,7 +679,7 @@
     scoped_refptr<ResourceSchedulerClient> resource_scheduler_client) {
   url_loader_factories_.emplace(std::make_unique<cors::CorsURLLoaderFactory>(
       this, std::move(params), std::move(resource_scheduler_client),
-      std::move(request), &cors_origin_access_list_, nullptr));
+      std::move(request), &cors_origin_access_list_));
 }
 
 void NetworkContext::SetClient(mojom::NetworkContextClientPtr client) {
@@ -724,8 +716,7 @@
     const url::Origin& origin) {
   restricted_cookie_manager_bindings_.AddBinding(
       std::make_unique<RestrictedCookieManager>(
-          url_request_context_->cookie_store(),
-          &cookie_manager_->cookie_settings(), origin),
+          url_request_context_->cookie_store(), origin),
       std::move(request));
 }
 
@@ -951,34 +942,6 @@
                                  base::Value::ToUniquePtrValue(std::move(body)),
                                  0 /* depth */);
 }
-
-void NetworkContext::QueueSignedExchangeReport(
-    mojom::SignedExchangeReportPtr report) {
-  net::URLRequestContext* request_context = url_request_context();
-  net::NetworkErrorLoggingService* logging_service =
-      request_context->network_error_logging_service();
-  if (!logging_service)
-    return;
-  std::string user_agent;
-  if (request_context->http_user_agent_settings() != nullptr) {
-    user_agent = request_context->http_user_agent_settings()->GetUserAgent();
-  }
-  net::NetworkErrorLoggingService::SignedExchangeReportDetails details;
-  details.success = report->success;
-  details.type = std::move(report->type);
-  details.outer_url = std::move(report->outer_url);
-  details.inner_url = std::move(report->inner_url);
-  details.cert_url = std::move(report->cert_url);
-  details.referrer = std::move(report->referrer);
-  details.server_ip_address = std::move(report->server_ip_address);
-  details.protocol = std::move(report->protocol);
-  details.method = std::move(report->method);
-  details.status_code = report->status_code;
-  details.elapsed_time = report->elapsed_time;
-  details.user_agent = std::move(user_agent);
-  logging_service->QueueSignedExchangeReport(details);
-}
-
 #else   // BUILDFLAG(ENABLE_REPORTING)
 void NetworkContext::ClearReportingCacheReports(
     mojom::ClearDataFilterPtr filter,
@@ -1005,11 +968,6 @@
                                  base::Value body) {
   NOTREACHED();
 }
-
-void NetworkContext::QueueSignedExchangeReport(
-    mojom::SignedExchangeReportPtr report) {
-  NOTREACHED();
-}
 #endif  // BUILDFLAG(ENABLE_REPORTING)
 
 void NetworkContext::ClearDomainReliability(
@@ -1095,10 +1053,6 @@
 #if defined(OS_CHROMEOS)
 void NetworkContext::UpdateAdditionalCertificates(
     mojom::AdditionalCertificatesPtr additional_certificates) {
-  if (!cert_verifier_with_trust_anchors_) {
-    CHECK(g_cert_verifier_for_testing || params_->username_hash.empty());
-    return;
-  }
   if (!additional_certificates) {
     nss_temp_certs_cache_.reset();
     cert_verifier_with_trust_anchors_->SetTrustAnchors(net::CertificateList());
@@ -1308,14 +1262,13 @@
     int32_t process_id,
     int32_t render_frame_id,
     const url::Origin& origin,
-    mojom::AuthenticationHandlerPtr auth_handler,
-    mojom::TrustedHeaderClientPtr header_client) {
+    mojom::AuthenticationHandlerPtr auth_handler) {
 #if !defined(OS_IOS)
   if (!websocket_factory_)
     websocket_factory_ = std::make_unique<WebSocketFactory>(this);
-  websocket_factory_->CreateWebSocket(
-      std::move(request), std::move(auth_handler), std::move(header_client),
-      process_id, render_frame_id, origin);
+  websocket_factory_->CreateWebSocket(std::move(request),
+                                      std::move(auth_handler), process_id,
+                                      render_frame_id, origin);
 #endif  // !defined(OS_IOS)
 }
 
@@ -1911,8 +1864,6 @@
 
   session_params.http_09_on_non_default_ports_enabled =
       params_->http_09_on_non_default_ports_enabled;
-  session_params.disable_idle_sockets_close_on_memory_pressure =
-      params_->disable_idle_sockets_close_on_memory_pressure;
 
   builder->set_http_network_session_params(session_params);
 
@@ -2014,11 +1965,6 @@
         certificate_report_sender_.get());
   }
 
-#if defined(OS_ANDROID)
-  result.url_request_context->set_check_cleartext_permitted(
-      params_->check_clear_text_permitted);
-#endif  // defined(OS_ANDROID)
-
 #if BUILDFLAG(IS_CT_SUPPORTED)
   if (params_->enable_expect_ct_reporting) {
     LazyCreateExpectCTReporter(result.url_request_context.get());
@@ -2031,7 +1977,7 @@
     net::URLRequestContext* context = result.url_request_context.get();
     ct_tree_tracker_ =
         std::make_unique<certificate_transparency::TreeStateTracker>(
-            ct_logs, context->host_resolver(), context, net_log);
+            ct_logs, context->host_resolver(), net_log);
     context->cert_transparency_verifier()->SetObserver(ct_tree_tracker_.get());
     network_service_->sth_reporter()->RegisterObserver(ct_tree_tracker_.get());
   }
@@ -2151,21 +2097,9 @@
       cert_verifier_with_trust_anchors_->InitializeOnIOThread(verify_proc);
       cert_verifier = base::WrapUnique(cert_verifier_with_trust_anchors_);
     }
-#elif BUILDFLAG(TRIAL_COMPARISON_CERT_VERIFIER_SUPPORTED)
-    if (params_->trial_comparison_cert_verifier_params) {
-      cert_verifier = std::make_unique<net::CachingCertVerifier>(
-          std::make_unique<TrialComparisonCertVerifierMojo>(
-              params_->trial_comparison_cert_verifier_params->initial_allowed,
-              std::move(params_->trial_comparison_cert_verifier_params
-                            ->config_client_request),
-              std::move(params_->trial_comparison_cert_verifier_params
-                            ->report_client),
-              net::CertVerifyProc::CreateDefault(),
-              net::CreateCertVerifyProcBuiltin()));
-    }
-#endif
-    if (!cert_verifier)
+#else
       cert_verifier = net::CertVerifier::CreateDefault();
+#endif
   }
 
   builder.SetCertVerifier(IgnoreErrorsCertVerifier::MaybeWrapCertVerifier(
--- a/services/network/network_context.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/network_context.h	2019-05-17 18:53:37.892000000 +0300
@@ -271,8 +271,7 @@
                        int32_t process_id,
                        int32_t render_frame_id,
                        const url::Origin& origin,
-                       mojom::AuthenticationHandlerPtr auth_handler,
-                       mojom::TrustedHeaderClientPtr header_client) override;
+                       mojom::AuthenticationHandlerPtr auth_handler) override;
   void CreateNetLogExporter(mojom::NetLogExporterRequest request) override;
   void ResolveHost(const net::HostPortPair& host,
                    mojom::ResolveHostParametersPtr optional_parameters,
@@ -327,9 +326,6 @@
                    const GURL& url,
                    const base::Optional<std::string>& user_agent,
                    base::Value body) override;
-  void QueueSignedExchangeReport(
-      mojom::SignedExchangeReportPtr report) override;
-
   void AddDomainReliabilityContextForTesting(
       const GURL& origin,
       const GURL& upload_url,
@@ -509,8 +505,6 @@
 
   mojo::StrongBindingSet<mojom::NetLogExporter> net_log_exporter_bindings_;
 
-  // Ordering: this must be after |cookie_manager_| since it points to its
-  // CookieSettings object.
   mojo::StrongBindingSet<mojom::RestrictedCookieManager>
       restricted_cookie_manager_bindings_;
 
--- a/services/network/network_context_unittest.cc	2019-05-17 17:45:42.552000000 +0300
+++ b/services/network/network_context_unittest.cc	2019-05-17 18:53:37.892000000 +0300
@@ -11,7 +11,6 @@
 #include "base/barrier_closure.h"
 #include "base/bind.h"
 #include "base/command_line.h"
-#include "base/containers/span.h"
 #include "base/files/file.h"
 #include "base/files/file_path.h"
 #include "base/files/file_util.h"
@@ -19,8 +18,6 @@
 #include "base/location.h"
 #include "base/metrics/field_trial.h"
 #include "base/optional.h"
-#include "base/power_monitor/power_monitor.h"
-#include "base/power_monitor/power_monitor_source.h"
 #include "base/run_loop.h"
 #include "base/stl_util.h"
 #include "base/strings/strcat.h"
@@ -52,7 +49,6 @@
 #include "net/base/ip_endpoint.h"
 #include "net/base/net_errors.h"
 #include "net/base/network_change_notifier.h"
-#include "net/base/proxy_server.h"
 #include "net/base/test_completion_callback.h"
 #include "net/cert/cert_verify_result.h"
 #include "net/cert/mock_cert_verifier.h"
@@ -60,8 +56,8 @@
 #include "net/cookies/cookie_options.h"
 #include "net/cookies/cookie_store.h"
 #include "net/disk_cache/disk_cache.h"
-#include "net/dns/context_host_resolver.h"
 #include "net/dns/dns_test_util.h"
+#include "net/dns/host_resolver_impl.h"
 #include "net/dns/host_resolver_source.h"
 #include "net/dns/mock_host_resolver.h"
 #include "net/dns/public/dns_query_type.h"
@@ -77,6 +73,7 @@
 #include "net/proxy_resolution/proxy_config.h"
 #include "net/proxy_resolution/proxy_info.h"
 #include "net/proxy_resolution/proxy_resolution_service.h"
+#include "net/socket/ssl_client_socket_pool.h"
 #include "net/socket/transport_client_socket_pool.h"
 #include "net/ssl/channel_id_service.h"
 #include "net/ssl/channel_id_store.h"
@@ -86,7 +83,6 @@
 #include "net/test/embedded_test_server/embedded_test_server.h"
 #include "net/test/embedded_test_server/embedded_test_server_connection_listener.h"
 #include "net/test/gtest_util.h"
-#include "net/test/spawned_test_server/spawned_test_server.h"
 #include "net/test/test_data_directory.h"
 #include "net/traffic_annotation/network_traffic_annotation_test_helper.h"
 #include "net/url_request/http_user_agent_settings.h"
@@ -298,45 +294,37 @@
     context->url_request_context()
         ->http_transaction_factory()
         ->GetSession()
-        ->GetSocketPool(
-            net::HttpNetworkSession::SocketPoolType::NORMAL_SOCKET_POOL,
-            net::ProxyServer::Direct())
-        ->GetInfoAsValue("", "")
+        ->GetTransportSocketPool(
+            net::HttpNetworkSession::SocketPoolType::NORMAL_SOCKET_POOL)
+        ->GetInfoAsValue("", "", false)
         ->GetInteger(name, &value);
     return value;
   }
 
-  int GetSocketCountForGroup(NetworkContext* context,
-                             const std::string& group_name) {
-    std::unique_ptr<base::Value> pool_info =
+  // Looks up a value with the given name from the NetworkContext's
+  // SSLSocketPool info dictionary.
+  int GetSSLSocketPoolInfo(NetworkContext* context, base::StringPiece name) {
+    int value;
         context->url_request_context()
             ->http_transaction_factory()
             ->GetSession()
-            ->GetSocketPool(
-                net::HttpNetworkSession::SocketPoolType::NORMAL_SOCKET_POOL,
-                net::ProxyServer::Direct())
-            ->GetInfoAsValue("", "");
-
-    int count = 0;
-    base::Value* active_socket_count = pool_info->FindPathOfType(
-        base::span<const base::StringPiece>{
-            {"groups", group_name, "active_socket_count"}},
-        base::Value::Type::INTEGER);
-    if (active_socket_count)
-      count += active_socket_count->GetInt();
-    base::Value* idle_sockets = pool_info->FindPathOfType(
-        base::span<const base::StringPiece>{
-            {"groups", group_name, "idle_sockets"}},
-        base::Value::Type::LIST);
-    if (idle_sockets)
-      count += idle_sockets->GetList().size();
-    base::Value* connect_jobs = pool_info->FindPathOfType(
-        base::span<const base::StringPiece>{
-            {"groups", group_name, "connect_jobs"}},
-        base::Value::Type::LIST);
-    if (connect_jobs)
-      count += connect_jobs->GetList().size();
-    return count;
+        ->GetSSLSocketPool(
+            net::HttpNetworkSession::SocketPoolType::NORMAL_SOCKET_POOL)
+        ->GetInfoAsValue("", "", false)
+        ->GetInteger(name, &value);
+    return value;
+  }
+
+  int GetSocketCount(NetworkContext* network_context) {
+    return GetSocketPoolInfo(network_context, "idle_socket_count") +
+           GetSocketPoolInfo(network_context, "connecting_socket_count") +
+           GetSocketPoolInfo(network_context, "handed_out_socket_count");
+  }
+
+  int GetSSLSocketCount(NetworkContext* network_context) {
+    return GetSSLSocketPoolInfo(network_context, "idle_socket_count") +
+           GetSSLSocketPoolInfo(network_context, "connecting_socket_count") +
+           GetSSLSocketPoolInfo(network_context, "handed_out_socket_count");
   }
 
   GURL GetHttpUrlFromHttps(const GURL& https_url) {
@@ -1244,7 +1232,7 @@
                               ->GetCache();
 
   std::vector<std::string> entry_urls = {
-      "http://www.9oo91e.qjz9zk",    "https://www.9oo91e.qjz9zk",
+      "http://www.google.com",    "https://www.google.com",
       "http://www.wikipedia.com", "https://www.wikipedia.com",
       "http://localhost:1234",    "https://localhost:1234",
   };
@@ -1314,7 +1302,7 @@
       mock_cache.http_cache());
 
   std::vector<std::string> entry_urls = {
-      "http://www.9oo91e.qjz9zk",    "https://www.9oo91e.qjz9zk",
+      "http://www.google.com",    "https://www.google.com",
       "http://www.wikipedia.com", "https://www.wikipedia.com",
       "http://localhost:1234",    "https://localhost:1234",
   };
@@ -1352,7 +1340,7 @@
       mock_cache.http_cache());
 
   std::vector<std::string> entry_urls = {
-      "http://www.9oo91e.qjz9zk",    "https://www.9oo91e.qjz9zk",
+      "http://www.google.com",    "https://www.google.com",
       "http://www.wikipedia.com", "https://www.wikipedia.com",
       "http://localhost:1234",    "https://localhost:1234",
   };
@@ -1504,16 +1492,15 @@
     for (size_t i = 0; i < base::size(kDomains); ++i) {
       bool expect_domain_cached =
           ((test_case.expected_cached_domains & (1 << i)) != 0);
-      EXPECT_EQ(
-          expect_domain_cached,
-          (host_cache->GetMatchingKey(kDomains[i], nullptr /* source_out */,
-                                      nullptr /* stale_out */) != nullptr));
+      EXPECT_EQ(expect_domain_cached,
+                host_cache->HasEntry(kDomains[i], nullptr /* source_out */,
+                                     nullptr /* stale_out */));
     }
   }
 }
 
 TEST_F(NetworkContextTest, ClearHttpAuthCache) {
-  GURL origin("http://9oo91e.qjz9zk");
+  GURL origin("http://google.com");
   std::unique_ptr<NetworkContext> network_context =
       CreateContextWithParams(CreateContextParams());
   net::HttpAuthCache* cache = network_context->url_request_context()
@@ -1556,7 +1543,7 @@
 }
 
 TEST_F(NetworkContextTest, ClearAllHttpAuthCache) {
-  GURL origin("http://9oo91e.qjz9zk");
+  GURL origin("http://google.com");
   std::unique_ptr<NetworkContext> network_context =
       CreateContextWithParams(CreateContextParams());
   net::HttpAuthCache* cache = network_context->url_request_context()
@@ -1615,7 +1602,7 @@
 }
 
 TEST_F(NetworkContextTest, LookupBasicAuthCredentials) {
-  GURL origin("http://9oo91e.qjz9zk");
+  GURL origin("http://google.com");
   std::unique_ptr<NetworkContext> network_context =
       CreateContextWithParams(CreateContextParams());
   net::HttpAuthCache* cache = network_context->url_request_context()
@@ -1657,19 +1644,19 @@
 
 #if BUILDFLAG(ENABLE_REPORTING)
 TEST_F(NetworkContextTest, ClearReportingCacheReports) {
+  std::unique_ptr<NetworkContext> network_context =
+      CreateContextWithParams(CreateContextParams());
+
   auto reporting_context = std::make_unique<net::TestReportingContext>(
       base::DefaultClock::GetInstance(), base::DefaultTickClock::GetInstance(),
       net::ReportingPolicy());
   net::ReportingCache* reporting_cache = reporting_context->cache();
   std::unique_ptr<net::ReportingService> reporting_service =
       net::ReportingService::CreateForTesting(std::move(reporting_context));
-
-  std::unique_ptr<NetworkContext> network_context =
-      CreateContextWithParams(CreateContextParams());
   network_context->url_request_context()->set_reporting_service(
       reporting_service.get());
 
-  GURL domain("http://9oo91e.qjz9zk");
+  GURL domain("http://google.com");
   reporting_service->QueueReport(domain, "Mozilla/1.0", "group", "type",
                                  nullptr, 0);
 
@@ -1687,22 +1674,22 @@
 }
 
 TEST_F(NetworkContextTest, ClearReportingCacheReportsWithFilter) {
+  std::unique_ptr<NetworkContext> network_context =
+      CreateContextWithParams(CreateContextParams());
+
   auto reporting_context = std::make_unique<net::TestReportingContext>(
       base::DefaultClock::GetInstance(), base::DefaultTickClock::GetInstance(),
       net::ReportingPolicy());
   net::ReportingCache* reporting_cache = reporting_context->cache();
   std::unique_ptr<net::ReportingService> reporting_service =
       net::ReportingService::CreateForTesting(std::move(reporting_context));
-
-  std::unique_ptr<NetworkContext> network_context =
-      CreateContextWithParams(CreateContextParams());
   network_context->url_request_context()->set_reporting_service(
       reporting_service.get());
 
-  GURL domain1("http://9oo91e.qjz9zk");
+  GURL domain1("http://google.com");
   reporting_service->QueueReport(domain1, "Mozilla/1.0", "group", "type",
                                  nullptr, 0);
-  GURL domain2("http://ch40m1um.qjz9zk");
+  GURL domain2("http://chromium.org");
   reporting_service->QueueReport(domain2, "Mozilla/1.0", "group", "type",
                                  nullptr, 0);
 
@@ -1712,7 +1699,7 @@
 
   mojom::ClearDataFilterPtr filter = mojom::ClearDataFilter::New();
   filter->type = mojom::ClearDataFilter_Type::KEEP_MATCHES;
-  filter->domains.push_back("ch40m1um.qjz9zk");
+  filter->domains.push_back("chromium.org");
 
   base::RunLoop run_loop;
   network_context->ClearReportingCacheReports(std::move(filter),
@@ -1726,15 +1713,15 @@
 
 TEST_F(NetworkContextTest,
        ClearReportingCacheReportsWithNonRegisterableFilter) {
+  std::unique_ptr<NetworkContext> network_context =
+      CreateContextWithParams(CreateContextParams());
+
   auto reporting_context = std::make_unique<net::TestReportingContext>(
       base::DefaultClock::GetInstance(), base::DefaultTickClock::GetInstance(),
       net::ReportingPolicy());
   net::ReportingCache* reporting_cache = reporting_context->cache();
   std::unique_ptr<net::ReportingService> reporting_service =
       net::ReportingService::CreateForTesting(std::move(reporting_context));
-
-  std::unique_ptr<NetworkContext> network_context =
-      CreateContextWithParams(CreateContextParams());
   network_context->url_request_context()->set_reporting_service(
       reporting_service.get());
 
@@ -1764,15 +1751,15 @@
 }
 
 TEST_F(NetworkContextTest, ClearEmptyReportingCacheReports) {
+  std::unique_ptr<NetworkContext> network_context =
+      CreateContextWithParams(CreateContextParams());
+
   auto reporting_context = std::make_unique<net::TestReportingContext>(
       base::DefaultClock::GetInstance(), base::DefaultTickClock::GetInstance(),
       net::ReportingPolicy());
   net::ReportingCache* reporting_cache = reporting_context->cache();
   std::unique_ptr<net::ReportingService> reporting_service =
       net::ReportingService::CreateForTesting(std::move(reporting_context));
-
-  std::unique_ptr<NetworkContext> network_context =
-      CreateContextWithParams(CreateContextParams());
   network_context->url_request_context()->set_reporting_service(
       reporting_service.get());
 
@@ -1805,19 +1792,19 @@
 }
 
 TEST_F(NetworkContextTest, ClearReportingCacheClients) {
+  std::unique_ptr<NetworkContext> network_context =
+      CreateContextWithParams(CreateContextParams());
+
   auto reporting_context = std::make_unique<net::TestReportingContext>(
       base::DefaultClock::GetInstance(), base::DefaultTickClock::GetInstance(),
       net::ReportingPolicy());
   net::ReportingCache* reporting_cache = reporting_context->cache();
   std::unique_ptr<net::ReportingService> reporting_service =
       net::ReportingService::CreateForTesting(std::move(reporting_context));
-
-  std::unique_ptr<NetworkContext> network_context =
-      CreateContextWithParams(CreateContextParams());
   network_context->url_request_context()->set_reporting_service(
       reporting_service.get());
 
-  GURL domain("https://9oo91e.qjz9zk");
+  GURL domain("https://google.com");
   reporting_cache->SetClient(url::Origin::Create(domain), domain,
                              net::ReportingClient::Subdomains::EXCLUDE, "group",
                              base::TimeTicks::Max(), 0, 1);
@@ -1836,23 +1823,23 @@
 }
 
 TEST_F(NetworkContextTest, ClearReportingCacheClientsWithFilter) {
+  std::unique_ptr<NetworkContext> network_context =
+      CreateContextWithParams(CreateContextParams());
+
   auto reporting_context = std::make_unique<net::TestReportingContext>(
       base::DefaultClock::GetInstance(), base::DefaultTickClock::GetInstance(),
       net::ReportingPolicy());
   net::ReportingCache* reporting_cache = reporting_context->cache();
   std::unique_ptr<net::ReportingService> reporting_service =
       net::ReportingService::CreateForTesting(std::move(reporting_context));
-
-  std::unique_ptr<NetworkContext> network_context =
-      CreateContextWithParams(CreateContextParams());
   network_context->url_request_context()->set_reporting_service(
       reporting_service.get());
 
-  GURL domain1("https://9oo91e.qjz9zk");
+  GURL domain1("https://google.com");
   reporting_cache->SetClient(url::Origin::Create(domain1), domain1,
                              net::ReportingClient::Subdomains::EXCLUDE, "group",
                              base::TimeTicks::Max(), 0, 1);
-  GURL domain2("https://ch40m1um.qjz9zk");
+  GURL domain2("https://chromium.org");
   reporting_cache->SetClient(url::Origin::Create(domain2), domain2,
                              net::ReportingClient::Subdomains::EXCLUDE, "group",
                              base::TimeTicks::Max(), 0, 1);
@@ -1863,7 +1850,7 @@
 
   mojom::ClearDataFilterPtr filter = mojom::ClearDataFilter::New();
   filter->type = mojom::ClearDataFilter_Type::KEEP_MATCHES;
-  filter->domains.push_back("ch40m1um.qjz9zk");
+  filter->domains.push_back("chromium.org");
 
   base::RunLoop run_loop;
   network_context->ClearReportingCacheClients(std::move(filter),
@@ -1876,15 +1863,15 @@
 }
 
 TEST_F(NetworkContextTest, ClearEmptyReportingCacheClients) {
+  std::unique_ptr<NetworkContext> network_context =
+      CreateContextWithParams(CreateContextParams());
+
   auto reporting_context = std::make_unique<net::TestReportingContext>(
       base::DefaultClock::GetInstance(), base::DefaultTickClock::GetInstance(),
       net::ReportingPolicy());
   net::ReportingCache* reporting_cache = reporting_context->cache();
   std::unique_ptr<net::ReportingService> reporting_service =
       net::ReportingService::CreateForTesting(std::move(reporting_context));
-
-  std::unique_ptr<NetworkContext> network_context =
-      CreateContextWithParams(CreateContextParams());
   network_context->url_request_context()->set_reporting_service(
       reporting_service.get());
 
@@ -1926,7 +1913,7 @@
       network_context->url_request_context()->network_error_logging_service();
   ASSERT_TRUE(logging_service);
 
-  GURL domain("https://9oo91e.qjz9zk");
+  GURL domain("https://google.com");
   logging_service->OnHeader(url::Origin::Create(domain),
                             net::IPAddress(192, 168, 0, 1),
                             "{\"report_to\":\"group\",\"max_age\":86400}");
@@ -1951,11 +1938,11 @@
       network_context->url_request_context()->network_error_logging_service();
   ASSERT_TRUE(logging_service);
 
-  GURL domain1("https://9oo91e.qjz9zk");
+  GURL domain1("https://google.com");
   logging_service->OnHeader(url::Origin::Create(domain1),
                             net::IPAddress(192, 168, 0, 1),
                             "{\"report_to\":\"group\",\"max_age\":86400}");
-  GURL domain2("https://ch40m1um.qjz9zk");
+  GURL domain2("https://chromium.org");
   logging_service->OnHeader(url::Origin::Create(domain2),
                             net::IPAddress(192, 168, 0, 1),
                             "{\"report_to\":\"group\",\"max_age\":86400}");
@@ -1964,7 +1951,7 @@
 
   mojom::ClearDataFilterPtr filter = mojom::ClearDataFilter::New();
   filter->type = mojom::ClearDataFilter_Type::KEEP_MATCHES;
-  filter->domains.push_back("ch40m1um.qjz9zk");
+  filter->domains.push_back("chromium.org");
 
   base::RunLoop run_loop;
   network_context->ClearNetworkErrorLogging(std::move(filter),
@@ -2021,8 +2008,7 @@
 
 void GetCookieListCallback(base::RunLoop* run_loop,
                            net::CookieList* result_out,
-                           const net::CookieList& result,
-                           const net::CookieStatusList& excluded_cookies) {
+                           const net::CookieList& result) {
   *result_out = result;
   run_loop->Quit();
 }
@@ -2044,7 +2030,7 @@
                            base::Time(), base::Time(), false, false,
                            net::CookieSameSite::NO_RESTRICTION,
                            net::COOKIE_PRIORITY_LOW),
-      "https", true, base::BindOnce(&SetCookieCallback, &run_loop1, &result));
+      true, true, base::BindOnce(&SetCookieCallback, &run_loop1, &result));
   run_loop1.Run();
   EXPECT_TRUE(result);
 
@@ -2920,8 +2906,8 @@
             network_context->GetNumOutstandingResolveHostRequestsForTesting());
 }
 
-// Test factory of net::HostResolvers. Creates standard
-// net::ContextHostResolver. Keeps pointers to all created resolvers.
+// Test factory of net::HostResolvers. Creates standard net::HostResolverImpl.
+// Keeps pointers to all created resolvers.
 class TestResolverFactory : public net::HostResolver::Factory {
  public:
   static TestResolverFactory* CreateAndSetFactory(NetworkContext* context) {
@@ -2934,18 +2920,18 @@
   std::unique_ptr<net::HostResolver> CreateResolver(
       const net::HostResolver::Options& options,
       net::NetLog* net_log) override {
-    std::unique_ptr<net::ContextHostResolver> resolver =
+    std::unique_ptr<net::HostResolverImpl> resolver =
         net::HostResolver::CreateSystemResolverImpl(options, net_log);
     resolvers_.push_back(resolver.get());
     return resolver;
   }
 
-  const std::vector<net::ContextHostResolver*>& resolvers() const {
+  const std::vector<net::HostResolverImpl*>& resolvers() const {
     return resolvers_;
   }
 
  private:
-  std::vector<net::ContextHostResolver*> resolvers_;
+  std::vector<net::HostResolverImpl*> resolvers_;
 };
 
 TEST_F(NetworkContextTest, CreateHostResolver) {
@@ -3094,7 +3080,7 @@
   // Should create 1 private resolver with a DnsClient (if DnsClient is
   // enablable for the build config).
   ASSERT_EQ(1u, factory->resolvers().size());
-  net::ContextHostResolver* internal_resolver = factory->resolvers().front();
+  net::HostResolverImpl* internal_resolver = factory->resolvers().front();
 #if defined(ENABLE_BUILT_IN_DNS)
   EXPECT_TRUE(internal_resolver->GetDnsConfigAsValue());
 #endif
@@ -3106,19 +3092,17 @@
   CHECK(result.AssignFromIPLiteral(kResult));
   net::MockDnsClientRuleList rules;
   rules.emplace_back(kQueryHostname, net::dns_protocol::kTypeA,
-                     net::SecureDnsMode::AUTOMATIC,
                      net::MockDnsClientRule::Result(
                          net::BuildTestDnsResponse(kQueryHostname, result)),
-                     false /* delay */);
+                     false);
   rules.emplace_back(
       kQueryHostname, net::dns_protocol::kTypeAAAA,
-      net::SecureDnsMode::AUTOMATIC,
       net::MockDnsClientRule::Result(net::MockDnsClientRule::ResultType::EMPTY),
-      false /* delay */);
+      false);
   auto mock_dns_client =
       std::make_unique<net::MockDnsClient>(net::DnsConfig(), std::move(rules));
   auto* mock_dns_client_ptr = mock_dns_client.get();
-  internal_resolver->SetDnsClientForTesting(std::move(mock_dns_client));
+  internal_resolver->SetDnsClient(std::move(mock_dns_client));
 
   // Force the base configuration to ensure consistent overriding.
   net::DnsConfig base_configuration;
@@ -3421,10 +3405,10 @@
                                      true);
   connection_listener.WaitForAcceptedConnections(1u);
 
-  int num_sockets = GetSocketCountForGroup(
-      network_context.get(),
-      "pm/" + net::HostPortPair::FromURL(server_http_url).ToString());
+  int num_sockets = GetSocketCount(network_context.get());
   EXPECT_EQ(num_sockets, 1);
+  int num_ssl_sockets = GetSSLSocketCount(network_context.get());
+  EXPECT_EQ(num_ssl_sockets, 0);
 
   const base::Time expiry =
       base::Time::Now() + base::TimeDelta::FromSeconds(1000);
@@ -3434,11 +3418,10 @@
                                      true);
   connection_listener.WaitForAcceptedConnections(1u);
 
-  // If HSTS weren't respected, the initial connection would have been reused.
-  num_sockets = GetSocketCountForGroup(
-      network_context.get(),
-      "pm/ssl/" + net::HostPortPair::FromURL(server_http_url).ToString());
-  EXPECT_EQ(num_sockets, 1);
+  num_sockets = GetSocketCount(network_context.get());
+  EXPECT_EQ(num_sockets, 2);
+  num_ssl_sockets = GetSSLSocketCount(network_context.get());
+  EXPECT_EQ(num_ssl_sockets, 1);
 }
 
 TEST_F(NetworkContextTest, PreconnectZero) {
@@ -4449,572 +4432,6 @@
   }
 }
 
-class HangingTestURLLoaderHeaderClient
-    : public mojom::TrustedURLLoaderHeaderClient {
- public:
-  class TestHeaderClient : public mojom::TrustedHeaderClient {
-   public:
-    TestHeaderClient() : binding_(this) {}
-
-    // network::mojom::TrustedHeaderClient:
-    void OnBeforeSendHeaders(const net::HttpRequestHeaders& headers,
-                             OnBeforeSendHeadersCallback callback) override {
-      saved_request_headers_ = headers;
-      saved_on_before_send_headers_callback_ = std::move(callback);
-      on_before_send_headers_loop_.Quit();
-    }
-
-    void OnHeadersReceived(const std::string& headers,
-                           OnHeadersReceivedCallback callback) override {
-      saved_received_headers_ = headers;
-      saved_on_headers_received_callback_ = std::move(callback);
-      on_headers_received_loop_.Quit();
-    }
-
-    void CallOnBeforeSendHeadersCallback() {
-      net::HttpRequestHeaders new_headers = std::move(saved_request_headers_);
-      new_headers.SetHeader("foo", "bar");
-      std::move(saved_on_before_send_headers_callback_)
-          .Run(net::OK, new_headers);
-    }
-
-    void WaitForOnBeforeSendHeaders() { on_before_send_headers_loop_.Run(); }
-
-    void CallOnHeadersReceivedCallback() {
-      auto new_headers = base::MakeRefCounted<net::HttpResponseHeaders>(
-          saved_received_headers_);
-      new_headers->AddHeader("baz: qux");
-      std::move(saved_on_headers_received_callback_)
-          .Run(net::OK, new_headers->raw_headers(), GURL());
-    }
-
-    void WaitForOnHeadersReceived() { on_headers_received_loop_.Run(); }
-
-    void Bind(network::mojom::TrustedHeaderClientRequest request) {
-      binding_.Bind(std::move(request));
-    }
-
-   private:
-    base::RunLoop on_before_send_headers_loop_;
-    net::HttpRequestHeaders saved_request_headers_;
-    OnBeforeSendHeadersCallback saved_on_before_send_headers_callback_;
-
-    base::RunLoop on_headers_received_loop_;
-    std::string saved_received_headers_;
-    OnHeadersReceivedCallback saved_on_headers_received_callback_;
-    mojo::Binding<mojom::TrustedHeaderClient> binding_;
-
-    DISALLOW_COPY_AND_ASSIGN(TestHeaderClient);
-  };
-
-  HangingTestURLLoaderHeaderClient(
-      mojom::TrustedURLLoaderHeaderClientRequest request)
-      : binding_(this, std::move(request)) {}
-
-  // network::mojom::TrustedURLLoaderHeaderClient:
-  void OnLoaderCreated(
-      int32_t request_id,
-      network::mojom::TrustedHeaderClientRequest request) override {
-    header_client_.Bind(std::move(request));
-  }
-
-  void CallOnBeforeSendHeadersCallback() {
-    header_client_.CallOnBeforeSendHeadersCallback();
-  }
-
-  void WaitForOnBeforeSendHeaders() {
-    header_client_.WaitForOnBeforeSendHeaders();
-  }
-
-  void CallOnHeadersReceivedCallback() {
-    header_client_.CallOnHeadersReceivedCallback();
-  }
-
-  void WaitForOnHeadersReceived() { header_client_.WaitForOnHeadersReceived(); }
-
- private:
-  TestHeaderClient header_client_;
-  mojo::Binding<mojom::TrustedURLLoaderHeaderClient> binding_;
-
-  DISALLOW_COPY_AND_ASSIGN(HangingTestURLLoaderHeaderClient);
-};
-
-// Test waiting on the OnHeadersReceived event, then proceeding to call the
-// OnHeadersReceivedCallback asynchronously. This mostly just verifies that
-// HangingTestURLLoaderHeaderClient works.
-TEST_F(NetworkContextTest, HangingHeaderClientModifiesHeadersAsynchronously) {
-  net::EmbeddedTestServer test_server;
-  net::test_server::RegisterDefaultHandlers(&test_server);
-  ASSERT_TRUE(test_server.Start());
-
-  std::unique_ptr<NetworkContext> network_context =
-      CreateContextWithParams(CreateContextParams());
-
-  ResourceRequest request;
-  request.url = test_server.GetURL("/echoheader?foo");
-
-  mojom::URLLoaderFactoryPtr loader_factory;
-  mojom::URLLoaderFactoryParamsPtr params =
-      mojom::URLLoaderFactoryParams::New();
-  params->process_id = mojom::kBrowserProcessId;
-  params->is_corb_enabled = false;
-  HangingTestURLLoaderHeaderClient header_client(
-      mojo::MakeRequest(&params->header_client));
-  network_context->CreateURLLoaderFactory(mojo::MakeRequest(&loader_factory),
-                                          std::move(params));
-
-  mojom::URLLoaderPtr loader;
-  TestURLLoaderClient client;
-  loader_factory->CreateLoaderAndStart(
-      mojo::MakeRequest(&loader), 0 /* routing_id */, 0 /* request_id */,
-      mojom::kURLLoadOptionUseHeaderClient, request,
-      client.CreateInterfacePtr(),
-      net::MutableNetworkTrafficAnnotationTag(TRAFFIC_ANNOTATION_FOR_TESTS));
-
-  header_client.WaitForOnBeforeSendHeaders();
-  header_client.CallOnBeforeSendHeadersCallback();
-
-  header_client.WaitForOnHeadersReceived();
-  header_client.CallOnHeadersReceivedCallback();
-
-  client.RunUntilComplete();
-
-  EXPECT_EQ(client.completion_status().error_code, net::OK);
-  // Make sure request header was modified. The value will be in the body
-  // since we used the /echoheader endpoint.
-  std::string response;
-  EXPECT_TRUE(
-      mojo::BlockingCopyToString(client.response_body_release(), &response));
-  EXPECT_EQ(response, "bar");
-
-  // Make sure response header was modified.
-  EXPECT_TRUE(client.response_head().headers->HasHeaderValue("baz", "qux"));
-}
-
-// Test destroying the mojom::URLLoader after the OnBeforeSendHeaders event and
-// then calling the OnBeforeSendHeadersCallback.
-TEST_F(NetworkContextTest, HangingHeaderClientAbortDuringOnBeforeSendHeaders) {
-  net::EmbeddedTestServer test_server;
-  net::test_server::RegisterDefaultHandlers(&test_server);
-  ASSERT_TRUE(test_server.Start());
-
-  std::unique_ptr<NetworkContext> network_context =
-      CreateContextWithParams(CreateContextParams());
-
-  ResourceRequest request;
-  request.url = test_server.GetURL("/echoheader?foo");
-
-  mojom::URLLoaderFactoryPtr loader_factory;
-  mojom::URLLoaderFactoryParamsPtr params =
-      mojom::URLLoaderFactoryParams::New();
-  params->process_id = mojom::kBrowserProcessId;
-  params->is_corb_enabled = false;
-  HangingTestURLLoaderHeaderClient header_client(
-      mojo::MakeRequest(&params->header_client));
-  network_context->CreateURLLoaderFactory(mojo::MakeRequest(&loader_factory),
-                                          std::move(params));
-
-  mojom::URLLoaderPtr loader;
-  TestURLLoaderClient client;
-  loader_factory->CreateLoaderAndStart(
-      mojo::MakeRequest(&loader), 0 /* routing_id */, 0 /* request_id */,
-      mojom::kURLLoadOptionUseHeaderClient, request,
-      client.CreateInterfacePtr(),
-      net::MutableNetworkTrafficAnnotationTag(TRAFFIC_ANNOTATION_FOR_TESTS));
-
-  header_client.WaitForOnBeforeSendHeaders();
-
-  loader.reset();
-
-  // Ensure the loader is destroyed before the callback is run.
-  base::RunLoop().RunUntilIdle();
-
-  header_client.CallOnBeforeSendHeadersCallback();
-
-  client.RunUntilComplete();
-
-  EXPECT_EQ(client.completion_status().error_code, net::ERR_FAILED);
-}
-
-// Test destroying the mojom::URLLoader after the OnHeadersReceived event and
-// then calling the OnHeadersReceivedCallback.
-TEST_F(NetworkContextTest, HangingHeaderClientAbortDuringOnHeadersReceived) {
-  net::EmbeddedTestServer test_server;
-  net::test_server::RegisterDefaultHandlers(&test_server);
-  ASSERT_TRUE(test_server.Start());
-
-  std::unique_ptr<NetworkContext> network_context =
-      CreateContextWithParams(CreateContextParams());
-
-  ResourceRequest request;
-  request.url = test_server.GetURL("/echoheader?foo");
-
-  mojom::URLLoaderFactoryPtr loader_factory;
-  mojom::URLLoaderFactoryParamsPtr params =
-      mojom::URLLoaderFactoryParams::New();
-  params->process_id = mojom::kBrowserProcessId;
-  params->is_corb_enabled = false;
-  HangingTestURLLoaderHeaderClient header_client(
-      mojo::MakeRequest(&params->header_client));
-  network_context->CreateURLLoaderFactory(mojo::MakeRequest(&loader_factory),
-                                          std::move(params));
-
-  mojom::URLLoaderPtr loader;
-  TestURLLoaderClient client;
-  loader_factory->CreateLoaderAndStart(
-      mojo::MakeRequest(&loader), 0 /* routing_id */, 0 /* request_id */,
-      mojom::kURLLoadOptionUseHeaderClient, request,
-      client.CreateInterfacePtr(),
-      net::MutableNetworkTrafficAnnotationTag(TRAFFIC_ANNOTATION_FOR_TESTS));
-
-  header_client.WaitForOnBeforeSendHeaders();
-  header_client.CallOnBeforeSendHeadersCallback();
-
-  header_client.WaitForOnHeadersReceived();
-
-  loader.reset();
-
-  // Ensure the loader is destroyed before the callback is run.
-  base::RunLoop().RunUntilIdle();
-
-  header_client.CallOnHeadersReceivedCallback();
-
-  client.RunUntilComplete();
-
-  EXPECT_EQ(client.completion_status().error_code, net::ERR_FAILED);
-}
-
-// Test power monitor source that can simulate entering suspend mode. Can't use
-// the one in base/ because it insists on bringing its own MessageLoop.
-class TestPowerMonitorSource : public base::PowerMonitorSource {
- public:
-  TestPowerMonitorSource() = default;
-  ~TestPowerMonitorSource() override = default;
-
-  void Shutdown() override {}
-
-  void Suspend() { ProcessPowerEvent(SUSPEND_EVENT); }
-
-  void Resume() { ProcessPowerEvent(RESUME_EVENT); }
-
-  bool IsOnBatteryPowerImpl() override { return false; }
-
- private:
-  DISALLOW_COPY_AND_ASSIGN(TestPowerMonitorSource);
-};
-
-// If the OnBeforeSendHeadersCallback is called immediately after a Suspend
-// event (|runloop_after_suspend|==false), the URLRequest will not have been
-// destroyed yet, but the URLRequestHttpJob will have been cancelled. This test
-// ensures the URLRequestHttpJob doesn't attempt to start the transaction on a
-// cancelled request.
-//
-// If a Suspend event occurs and the message loop is allowed to run afterwards
-// (|runloop_after_suspend|==true), the URLLoader and URLRequest will be
-// destroyed. Attempting to call the OnBeforeSendHeadersCallback should do
-// nothing as URLLoader bound it to a weakptr.
-TEST_F(NetworkContextTest,
-       HangingHeaderClientSuspendDuringOnBeforeSendHeadersThenCallback) {
-  net::EmbeddedTestServer test_server;
-  net::test_server::RegisterDefaultHandlers(&test_server);
-  ASSERT_TRUE(test_server.Start());
-
-  for (bool runloop_after_suspend : {false, true}) {
-    SCOPED_TRACE(testing::Message()
-                 << "runloop_after_suspend=" << runloop_after_suspend);
-
-    std::unique_ptr<TestPowerMonitorSource> power_monitor_source =
-        std::make_unique<TestPowerMonitorSource>();
-    TestPowerMonitorSource* unowned_power_monitor_source =
-        power_monitor_source.get();
-    base::PowerMonitor power_monitor(std::move(power_monitor_source));
-
-    std::unique_ptr<NetworkContext> network_context =
-        CreateContextWithParams(CreateContextParams());
-
-    ResourceRequest request;
-    request.url = test_server.GetURL("/echoheader?foo");
-
-    mojom::URLLoaderFactoryPtr loader_factory;
-    mojom::URLLoaderFactoryParamsPtr params =
-        mojom::URLLoaderFactoryParams::New();
-    params->process_id = mojom::kBrowserProcessId;
-    params->is_corb_enabled = false;
-    HangingTestURLLoaderHeaderClient header_client(
-        mojo::MakeRequest(&params->header_client));
-    network_context->CreateURLLoaderFactory(mojo::MakeRequest(&loader_factory),
-                                            std::move(params));
-
-    mojom::URLLoaderPtr loader;
-    TestURLLoaderClient client;
-    loader_factory->CreateLoaderAndStart(
-        mojo::MakeRequest(&loader), 0 /* routing_id */, 0 /* request_id */,
-        mojom::kURLLoadOptionUseHeaderClient, request,
-        client.CreateInterfacePtr(),
-        net::MutableNetworkTrafficAnnotationTag(TRAFFIC_ANNOTATION_FOR_TESTS));
-
-    header_client.WaitForOnBeforeSendHeaders();
-
-    unowned_power_monitor_source->Suspend();
-    if (runloop_after_suspend)
-      base::RunLoop().RunUntilIdle();
-
-    header_client.CallOnBeforeSendHeadersCallback();
-
-    client.RunUntilComplete();
-
-    EXPECT_EQ(client.completion_status().error_code, net::ERR_ABORTED);
-
-    unowned_power_monitor_source->Resume();
-  }
-}
-
-// If the OnHeadersReceivedCallback is called immediately after a Suspend event
-// (|runloop_after_suspend|==false), the URLRequest will not have been destroyed
-// yet, but the URLRequestHttpJob will have destroyed the transaction_. This
-// test ensures that URLRequestHttpJob does not attempt to dereference the
-// transaction_.
-//
-// If a Suspend event occurs and the message loop is allowed to run afterwards
-// (|runloop_after_suspend|==true), the URLLoader and URLRequest will be
-// destroyed. Attempting to call the OnHeadersReceivedCallback should do nothing
-// as URLLoader bound it to a weakptr.
-TEST_F(NetworkContextTest,
-       HangingHeaderClientSuspendDuringOnHeadersReceivedThenCallback) {
-  net::EmbeddedTestServer test_server;
-  net::test_server::RegisterDefaultHandlers(&test_server);
-  ASSERT_TRUE(test_server.Start());
-
-  for (bool runloop_after_suspend : {false, true}) {
-    SCOPED_TRACE(testing::Message()
-                 << "runloop_after_suspend=" << runloop_after_suspend);
-
-    std::unique_ptr<TestPowerMonitorSource> power_monitor_source =
-        std::make_unique<TestPowerMonitorSource>();
-    TestPowerMonitorSource* unowned_power_monitor_source =
-        power_monitor_source.get();
-    base::PowerMonitor power_monitor(std::move(power_monitor_source));
-
-    std::unique_ptr<NetworkContext> network_context =
-        CreateContextWithParams(CreateContextParams());
-
-    ResourceRequest request;
-    request.url = test_server.GetURL("/echoheader?foo");
-
-    mojom::URLLoaderFactoryPtr loader_factory;
-    mojom::URLLoaderFactoryParamsPtr params =
-        mojom::URLLoaderFactoryParams::New();
-    params->process_id = mojom::kBrowserProcessId;
-    params->is_corb_enabled = false;
-    HangingTestURLLoaderHeaderClient header_client(
-        mojo::MakeRequest(&params->header_client));
-    network_context->CreateURLLoaderFactory(mojo::MakeRequest(&loader_factory),
-                                            std::move(params));
-
-    mojom::URLLoaderPtr loader;
-    TestURLLoaderClient client;
-    loader_factory->CreateLoaderAndStart(
-        mojo::MakeRequest(&loader), 0 /* routing_id */, 0 /* request_id */,
-        mojom::kURLLoadOptionUseHeaderClient, request,
-        client.CreateInterfacePtr(),
-        net::MutableNetworkTrafficAnnotationTag(TRAFFIC_ANNOTATION_FOR_TESTS));
-
-    header_client.WaitForOnBeforeSendHeaders();
-    header_client.CallOnBeforeSendHeadersCallback();
-
-    header_client.WaitForOnHeadersReceived();
-
-    unowned_power_monitor_source->Suspend();
-    if (runloop_after_suspend)
-      base::RunLoop().RunUntilIdle();
-
-    header_client.CallOnHeadersReceivedCallback();
-
-    client.RunUntilComplete();
-
-    EXPECT_EQ(client.completion_status().error_code, net::ERR_ABORTED);
-
-    unowned_power_monitor_source->Resume();
-  }
-}
-
-#if !defined(OS_IOS)
-class TestWebSocketClient : public mojom::WebSocketClient {
- public:
-  TestWebSocketClient() : binding_(this) {}
-
-  // mojom::WebSocketClient methods:
-  void OnFailChannel(const std::string& reason) override {
-    fail_channel_run_loop_.Quit();
-  }
-  void OnStartOpeningHandshake(
-      mojom::WebSocketHandshakeRequestPtr request) override {}
-  void OnFinishOpeningHandshake(
-      mojom::WebSocketHandshakeResponsePtr response) override {}
-  void OnAddChannelResponse(const std::string& selected_protocol,
-                            const std::string& extensions) override {}
-  void OnDataFrame(bool fin,
-                   mojom::WebSocketMessageType type,
-                   const std::vector<uint8_t>& data) override {}
-  void OnFlowControl(int64_t quota) override {}
-  void OnDropChannel(bool was_clean,
-                     uint16_t code,
-                     const std::string& reason) override {}
-  void OnClosingHandshake() override {}
-
-  mojom::WebSocketClientPtr CreateInterfacePtr() {
-    mojom::WebSocketClientPtr client_ptr;
-    binding_.Bind(mojo::MakeRequest(&client_ptr));
-    return client_ptr;
-  }
-
-  void WaitForFailChannel() { fail_channel_run_loop_.Run(); }
-
- private:
-  base::RunLoop fail_channel_run_loop_;
-  mojo::Binding<mojom::WebSocketClient> binding_;
-};
-
-// If the OnBeforeSendHeadersCallback is called immediately after a Suspend
-// event (|runloop_after_suspend|==false), the URLRequest will not have been
-// destroyed yet, but the URLRequestHttpJob will have been cancelled. This test
-// ensures the URLRequestHttpJob doesn't attempt to start the transaction on a
-// cancelled request.
-//
-// If a Suspend event occurs and the message loop is allowed to run afterwards
-// (|runloop_after_suspend|==true), the WebSocketChannel and URLRequest will be
-// destroyed. Attempting to call the OnBeforeSendHeadersCallback should do
-// nothing as WebSocket::OnBeforeSendHeadersComplete checks that the |channel_|
-// hasn't been destroyed.
-TEST_F(NetworkContextTest,
-       WebSocketHangingHeaderClientSuspendDuringOnOnBeforeSendHeaders) {
-  net::SpawnedTestServer ws_server(net::SpawnedTestServer::TYPE_WS,
-                                   net::GetWebSocketTestDataDirectory());
-  ASSERT_TRUE(ws_server.Start());
-
-  for (bool runloop_after_suspend : {false, true}) {
-    SCOPED_TRACE(testing::Message()
-                 << "runloop_after_suspend=" << runloop_after_suspend);
-
-    std::unique_ptr<TestPowerMonitorSource> power_monitor_source =
-        std::make_unique<TestPowerMonitorSource>();
-    TestPowerMonitorSource* unowned_power_monitor_source =
-        power_monitor_source.get();
-    base::PowerMonitor power_monitor(std::move(power_monitor_source));
-
-    std::unique_ptr<NetworkContext> network_context =
-        CreateContextWithParams(CreateContextParams());
-
-    mojom::TrustedURLLoaderHeaderClientPtr url_loader_header_client_ptr;
-    HangingTestURLLoaderHeaderClient header_client(
-        mojo::MakeRequest(&url_loader_header_client_ptr));
-    mojom::TrustedHeaderClientPtr header_client_ptr;
-    header_client.OnLoaderCreated(0, mojo::MakeRequest(&header_client_ptr));
-    network::mojom::WebSocketPtr web_socket;
-    network::mojom::AuthenticationHandlerPtr auth_handler;
-    network_context->CreateWebSocket(
-        mojo::MakeRequest(&web_socket), network::mojom::kBrowserProcessId,
-        1 /* render_frame_id */, url::Origin::Create(ws_server.GetURL("/")),
-        network::mojom::kWebSocketOptionNone, std::move(auth_handler),
-        std::move(header_client_ptr));
-
-    TestWebSocketClient client;
-    web_socket->AddChannelRequest(
-        ws_server.GetURL("close-immediately"), {} /* requested_protocols */,
-        ws_server.GetURL("close-immediately"), {} /* additional_headers */,
-        client.CreateInterfacePtr());
-
-    header_client.WaitForOnBeforeSendHeaders();
-
-    unowned_power_monitor_source->Suspend();
-    if (runloop_after_suspend)
-      base::RunLoop().RunUntilIdle();
-
-    header_client.CallOnBeforeSendHeadersCallback();
-
-    client.WaitForFailChannel();
-
-    // WebSocketClient::OnFailChannel gets called before the
-    // WebSocket::OnBeforeSendHeadersComplete callback. Run the loops to ensure
-    // OnBeforeSendHeadersComplete has a chance to run.
-    base::RunLoop().RunUntilIdle();
-
-    unowned_power_monitor_source->Resume();
-  }
-}
-
-// If the OnHeadersReceivedCallback is called immediately after a Suspend event
-// (|runloop_after_suspend|==false), the URLRequest will not have been destroyed
-// yet, but the URLRequestHttpJob will have destroyed the transaction_. This
-// test ensures that URLRequestHttpJob does not attempt to dereference the
-// transaction_.
-//
-// If a Suspend event occurs and the message loop is allowed to run afterwards
-// (|runloop_after_suspend|==true), the WebSocketChannel and URLRequest will be
-// destroyed. Attempting to call the OnHeadersReceivedCallback should do nothing
-// as  WebSocket::OnHeadersReceivedComplete checks that the |channel_|
-// hasn't been destroyed.
-TEST_F(NetworkContextTest,
-       WebSocketHangingHeaderClientSuspendDuringOnHeadersReceived) {
-  net::SpawnedTestServer ws_server(net::SpawnedTestServer::TYPE_WS,
-                                   net::GetWebSocketTestDataDirectory());
-  ASSERT_TRUE(ws_server.Start());
-
-  for (bool runloop_after_suspend : {false, true}) {
-    SCOPED_TRACE(testing::Message()
-                 << "runloop_after_suspend=" << runloop_after_suspend);
-
-    std::unique_ptr<TestPowerMonitorSource> power_monitor_source =
-        std::make_unique<TestPowerMonitorSource>();
-    TestPowerMonitorSource* unowned_power_monitor_source =
-        power_monitor_source.get();
-    base::PowerMonitor power_monitor(std::move(power_monitor_source));
-
-    std::unique_ptr<NetworkContext> network_context =
-        CreateContextWithParams(CreateContextParams());
-
-    mojom::TrustedURLLoaderHeaderClientPtr url_loader_header_client_ptr;
-    HangingTestURLLoaderHeaderClient header_client(
-        mojo::MakeRequest(&url_loader_header_client_ptr));
-    mojom::TrustedHeaderClientPtr header_client_ptr;
-    header_client.OnLoaderCreated(0, mojo::MakeRequest(&header_client_ptr));
-    network::mojom::WebSocketPtr web_socket;
-    network::mojom::AuthenticationHandlerPtr auth_handler;
-    network_context->CreateWebSocket(
-        mojo::MakeRequest(&web_socket), network::mojom::kBrowserProcessId,
-        1 /* render_frame_id */, url::Origin::Create(ws_server.GetURL("/")),
-        network::mojom::kWebSocketOptionNone, std::move(auth_handler),
-        std::move(header_client_ptr));
-
-    TestWebSocketClient client;
-    web_socket->AddChannelRequest(
-        ws_server.GetURL("close-immediately"), {} /* requested_protocols */,
-        ws_server.GetURL("close-immediately"), {} /* additional_headers */,
-        client.CreateInterfacePtr());
-
-    header_client.WaitForOnBeforeSendHeaders();
-    header_client.CallOnBeforeSendHeadersCallback();
-
-    header_client.WaitForOnHeadersReceived();
-
-    unowned_power_monitor_source->Suspend();
-    if (runloop_after_suspend)
-      base::RunLoop().RunUntilIdle();
-
-    header_client.CallOnHeadersReceivedCallback();
-
-    client.WaitForFailChannel();
-
-    // WebSocketClient::OnFailChannel gets called before the
-    // WebSocket::OnHeadersReceivedComplete callback. Run the loops to ensure
-    // OnHeadersReceivedComplete has a chance to run.
-    base::RunLoop().RunUntilIdle();
-
-    unowned_power_monitor_source->Resume();
-  }
-}
-#endif  // !defined(OS_IOS)
-
 // Custom proxy does not apply to localhost, so resolve kMockHost to localhost,
 // and use that instead.
 class NetworkContextMockHostTest : public NetworkContextTest {
--- a/services/network/network_sandbox_win.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/network_sandbox_win.cc	2019-05-17 18:53:37.896000000 +0300
@@ -4,24 +4,159 @@
 
 #include "services/network/network_sandbox_win.h"
 
-#include "sandbox/win/bsandbox_types.h"
-#include "services/service_manager/sandbox/win/sandbox_win.h"
+#include "base/files/file_path.h"
+#include "base/files/file_util.h"
+#include "base/path_service.h"
 
 // NOTE: changes to this code need to be reviewed by the security team.
+
 namespace network {
 
-// Right now, this policy is essentially unsandboxed, but with default process
-// mitigations applied. This will be tighted up in future releases.
-bool NetworkPreSpawnTarget(sandbox::TargetPolicy* policy,
-                           const base::CommandLine& cmd_line) {
-  sandbox::ResultCode result = policy->SetTokenLevel(sandbox::USER_UNPROTECTED,
-                                                     sandbox::USER_UNPROTECTED);
-  if (result != sandbox::ResultCode::SBOX_ALL_OK)
+namespace {
+
+bool EnumHardDrives(std::vector<std::wstring>* drive_paths) {
+  drive_paths->clear();
+  wchar_t volume_name[MAX_PATH];
+
+  // INVALID_HANDLE_VALUE alert!
+  HANDLE volume = ::FindFirstVolumeW(volume_name, ARRAYSIZE(volume_name));
+  if (volume == INVALID_HANDLE_VALUE) {
+    // This should never happen.  Unexpected failure, no volumes found.
+    NOTREACHED();
     return false;
-  result = service_manager::SandboxWin::SetJobLevel(
-      cmd_line, sandbox::JOB_UNPROTECTED, 0, policy);
-  if (result != sandbox::ResultCode::SBOX_ALL_OK)
+  }
+
+  wchar_t device_name[MAX_PATH];
+  do {
+    // Example volume name returned:
+    // "\\?\Volume{4c1b02c1-d990-11dc-99ae-806e6f6e6963}\"
+    size_t length = ::wcsnlen(volume_name, ARRAYSIZE(volume_name));
+    if (length < 5 || volume_name[0] != L'\\' || volume_name[1] != L'\\' ||
+        volume_name[2] != L'?' || volume_name[3] != L'\\' ||
+        volume_name[length - 1] != L'\\') {
+      // Bad path returned.  Very unexpected.
+      continue;
+    }
+
+    // QueryDosDevice doesn't take a trailing backslash.
+    volume_name[length - 1] = L'\0';
+    DWORD device_name_length =
+        ::QueryDosDeviceW(&volume_name[4], device_name, ARRAYSIZE(device_name));
+    volume_name[length - 1] = L'\\';
+    if (!device_name_length)
+      continue;
+
+    // Example device name returned: "\Device\HarddiskVolume2"
+    // Ignore any volumes that aren't hard disks (e.g. CdRom, etc).
+    if (::wcsncmp(device_name, L"\\Device\\Harddisk",
+                  ::wcslen(L"\\Device\\Harddisk"))) {
+      continue;
+    }
+
+    // Now get the path(s) for the given hard disk volume.
+    bool success = false;
+    DWORD char_count = MAX_PATH;
+    std::vector<wchar_t> path_names_buffer;
+    while (!success) {
+      path_names_buffer.resize(char_count * sizeof(wchar_t));
+      success = ::GetVolumePathNamesForVolumeNameW(
+          volume_name, path_names_buffer.data(), char_count, &char_count);
+      if (!success && ::GetLastError() != ERROR_MORE_DATA)
+        break;
+    }
+    if (!success)
+      continue;
+
+    // |buffer| is filled with a list of strings, separated by null
+    // characters.  Double null ends list.
+    // Note: usually the very first string will be the drive letter sought,
+    //       and is often the only string in the list.  Some volumes have
+    //       no drive letter assigned at all - not interested here.
+    size_t volume_path_index = 0;
+    size_t path_length = ::wcslen(&path_names_buffer[volume_path_index]);
+    while (path_length > 0) {
+      // Only collect drive letters, not mounted folder paths.
+      // Do dumb check instead of calls to GetFileAttributes().
+      if (path_length == 3 &&
+          path_names_buffer[volume_path_index + 1] == L':' &&
+          path_names_buffer[volume_path_index + 2] == L'\\') {
+        drive_paths->emplace_back(&path_names_buffer[volume_path_index]);
+      }
+      volume_path_index += path_length + 1;
+      path_length = ::wcslen(&path_names_buffer[volume_path_index]);
+    }
+  } while (::FindNextVolumeW(volume, volume_name, ARRAYSIZE(volume_name)));
+
+  ::FindVolumeClose(volume);
+
+  return true;
+}
+
+}  // namespace
+
+//------------------------------------------------------------------------------
+// Public network service sandbox configuration extension functions.
+//------------------------------------------------------------------------------
+
+/*
+  Default policy:
+
+  lockdown_level_(sandbox::USER_LOCKDOWN),
+  initial_level_(sandbox::USER_RESTRICTED_SAME_ACCESS),
+
+  job_level_(sandbox::JOB_LOCKDOWN),
+
+  integrity_level_(sandbox::INTEGRITY_LEVEL_LOW),
+  delayed_integrity_level_(sandbox::INTEGRITY_LEVEL_UNTRUSTED),
+*/
+
+/*
+  Network cache: %UserDataDir%\\Default\\*
+  (E.g. c:\Temp\UserDataDir\Default\Cache to
+   c:\Temp\UserDataDir\Default\old_Cache_000)
+
+  DNS config registry access:
+  ---------------------------
+  HKEY_LOCAL_MACHINE
+  kTcpipPath = L"SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters";
+  kTcpip6Path = L"SYSTEM\\CurrentControlSet\\Services\\Tcpip6\\Parameters";
+  kDnscachePath = L"SYSTEM\\CurrentControlSet\\Services\\Dnscache\\Parameters";
+  kPolicyPath = L"SOFTWARE\\Policies\\Microsoft\\Windows NT\\DNSClient";
+  kPrimaryDnsSuffixPath = L"SOFTWARE\\Policies\\Microsoft\\System\\DNSClient";
+  kNRPTPath = L"SOFTWARE\\Policies\\Microsoft\\Windows
+  NT\\DNSClient\\DnsPolicyConfig";
+
+  Priviliged API GetAdaptorsAddresses()
+*/
+bool NetworkPreSpawnTarget(sandbox::TargetPolicy* policy) {
+  // Token Level (affects system network APIs)
+  policy->SetTokenLevel(sandbox::USER_RESTRICTED_SAME_ACCESS,
+                        sandbox::USER_LIMITED);
+
+  // File
+  std::vector<std::wstring> drives;
+  if (!EnumHardDrives(&drives))
+    return false;
+
+  for (auto path : drives) {
+    path.append(L"*");
+    if (policy->AddRule(sandbox::TargetPolicy::SUBSYS_FILES,
+                        sandbox::TargetPolicy::FILES_ALLOW_ANY,
+                        path.c_str()) != sandbox::SBOX_ALL_OK) {
     return false;
+    }
+  }
+
+  // Registry
+  if (policy->AddRule(sandbox::TargetPolicy::SUBSYS_REGISTRY,
+                      sandbox::TargetPolicy::REG_ALLOW_READONLY,
+                      L"HKEY_LOCAL_MACHINE\\*") != sandbox::SBOX_ALL_OK ||
+      policy->AddRule(sandbox::TargetPolicy::SUBSYS_REGISTRY,
+                      sandbox::TargetPolicy::REG_ALLOW_READONLY,
+                      L"HKEY_CURRENT_USER\\*") != sandbox::SBOX_ALL_OK) {
+    return false;
+  }
+
   return true;
 }
 
--- a/services/network/network_sandbox_win.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/network_sandbox_win.h	2019-05-17 18:53:37.896000000 +0300
@@ -19,8 +19,7 @@
 
 // PreSpawnTarget extension.
 COMPONENT_EXPORT(NETWORK_SERVICE)
-bool NetworkPreSpawnTarget(sandbox::TargetPolicy* policy,
-                           const base::CommandLine& cmd_line);
+bool NetworkPreSpawnTarget(sandbox::TargetPolicy* policy);
 
 }  // namespace network
 
--- a/services/network/network_service.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/network_service.cc	2019-05-17 18:53:37.896000000 +0300
@@ -10,7 +10,6 @@
 
 #include "base/bind.h"
 #include "base/command_line.h"
-#include "base/environment.h"
 #include "base/logging.h"
 #include "base/memory/ptr_util.h"
 #include "base/metrics/histogram_macros.h"
@@ -96,9 +95,9 @@
     // browser process.
     return std::make_unique<net::NetworkChangeNotifierPosix>(
         initial_connection_type, initial_connection_subtype);
-#elif defined(OS_IOS)
-    // iOS doesn't embed //content.
-    // TODO(xunjieli): Figure out what to do for iOS.
+#elif defined(OS_IOS) || defined(OS_FUCHSIA)
+    // iOS doesn't embed //content. Fuchsia doesn't have an implementation yet.
+    // TODO(xunjieli): Figure out what to do for these 2 platforms.
     NOTIMPLEMENTED();
     return nullptr;
 #endif
@@ -142,16 +141,6 @@
   return a.load_state > b.load_state;
 }
 
-void OnGetNetworkList(std::unique_ptr<net::NetworkInterfaceList> networks,
-                      mojom::NetworkService::GetNetworkListCallback callback,
-                      bool success) {
-  if (success) {
-    std::move(callback).Run(*networks);
-  } else {
-    std::move(callback).Run(base::nullopt);
-  }
-}
-
 #if defined(OS_ANDROID) && BUILDFLAG(USE_KERBEROS)
 // Used for Negotiate authentication on Android, which needs to generate tokens
 // in the browser process.
@@ -192,9 +181,7 @@
     return net::ERR_IO_PENDING;
   }
 
-  void SetDelegation(net::HttpAuth::DelegationType delegation_type) override {
-    auth_negotiate_.SetDelegation(delegation_type);
-  }
+  void Delegate() override { auth_negotiate_.Delegate(); }
 
  private:
   void Finish(std::string* auth_token_out,
@@ -274,9 +261,6 @@
                         CRYPTO_needs_hwcap2_workaround());
 #endif
 
-  if (!params->environment.empty())
-    SetEnvironment(std::move(params->environment));
-
   base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();
 
   // Set-up the global port overrides.
@@ -507,7 +491,8 @@
   DCHECK(!http_auth_handler_factory_);
 
   http_auth_handler_factory_ = net::HttpAuthHandlerRegistryFactory::Create(
-      &http_auth_preferences_, http_auth_static_params->supported_schemes
+      host_resolver_.get(), &http_auth_preferences_,
+      http_auth_static_params->supported_schemes
 #if defined(OS_CHROMEOS)
       ,
       http_auth_static_params->allow_gssapi_library_load
@@ -528,8 +513,6 @@
       http_auth_dynamic_params->server_whitelist);
   http_auth_preferences_.SetDelegateWhitelist(
       http_auth_dynamic_params->delegate_whitelist);
-  http_auth_preferences_.set_delegate_by_kdc_policy(
-      http_auth_dynamic_params->delegate_by_kdc_policy);
   http_auth_preferences_.set_negotiate_disable_cname_lookup(
       http_auth_dynamic_params->negotiate_disable_cname_lookup);
   http_auth_preferences_.set_negotiate_enable_port(
@@ -596,14 +579,12 @@
 void NetworkService::GetNetworkList(
     uint32_t policy,
     mojom::NetworkService::GetNetworkListCallback callback) {
-  auto networks = std::make_unique<net::NetworkInterfaceList>();
-  auto* raw_networks = networks.get();
-  // net::GetNetworkList may block depending on platform.
-  base::PostTaskWithTraitsAndReplyWithResult(
-      FROM_HERE, {base::MayBlock()},
-      base::BindOnce(&net::GetNetworkList, raw_networks, policy),
-      base::BindOnce(&OnGetNetworkList, std::move(networks),
-                     std::move(callback)));
+  net::NetworkInterfaceList networks;
+  if (net::GetNetworkList(&networks, policy)) {
+    std::move(callback).Run(networks);
+  } else {
+    std::move(callback).Run(base::nullopt);
+  }
 }
 
 #if BUILDFLAG(IS_CT_SUPPORTED)
@@ -665,17 +646,10 @@
 }
 #endif
 
-void NetworkService::SetEnvironment(
-    std::vector<mojom::EnvironmentVariablePtr> environment) {
-  std::unique_ptr<base::Environment> env(base::Environment::Create());
-  for (const auto& variable : environment)
-    env->SetVar(variable->name, variable->value);
-}
-
 net::HttpAuthHandlerFactory* NetworkService::GetHttpAuthHandlerFactory() {
   if (!http_auth_handler_factory_) {
     http_auth_handler_factory_ = net::HttpAuthHandlerFactory::CreateDefault(
-        &http_auth_preferences_
+        host_resolver_.get(), &http_auth_preferences_
 #if defined(OS_ANDROID) && BUILDFLAG(USE_KERBEROS)
         ,
         base::BindRepeating(&CreateAuthSystem, this)
--- a/services/network/network_service.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/network_service.h	2019-05-17 18:53:37.896000000 +0300
@@ -19,7 +19,6 @@
 #include "base/memory/scoped_refptr.h"
 #include "base/optional.h"
 #include "base/time/time.h"
-#include "base/timer/timer.h"
 #include "build/build_config.h"
 #include "mojo/public/cpp/bindings/binding.h"
 #include "net/http/http_auth_preferences.h"
@@ -200,8 +199,6 @@
 #if defined(OS_ANDROID)
   void OnApplicationStateChange(base::android::ApplicationState state) override;
 #endif
-  void SetEnvironment(
-      std::vector<mojom::EnvironmentVariablePtr> environment) override;
 
   // Returns the shared HttpAuthHandlerFactory for the NetworkService, creating
   // one if needed.
--- a/services/network/network_service_network_delegate.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/network_service_network_delegate.cc	2019-05-17 18:53:37.896000000 +0300
@@ -4,8 +4,6 @@
 
 #include "services/network/network_service_network_delegate.h"
 
-#include "base/bind.h"
-#include "build/build_config.h"
 #include "services/network/cookie_manager.h"
 #include "services/network/network_context.h"
 #include "services/network/network_service.h"
@@ -14,10 +12,6 @@
 #include "services/network/public/cpp/features.h"
 #include "services/network/url_loader.h"
 
-#if !defined(OS_IOS)
-#include "services/network/websocket.h"
-#endif
-
 namespace network {
 
 namespace {
@@ -43,13 +37,6 @@
   URLLoader* url_loader = URLLoader::ForRequest(*request);
   if (url_loader)
     return url_loader->OnBeforeStartTransaction(std::move(callback), headers);
-
-#if !defined(OS_IOS)
-  WebSocket* web_socket = WebSocket::ForRequest(*request);
-  if (web_socket)
-    return web_socket->OnBeforeStartTransaction(std::move(callback), headers);
-#endif  // !defined(OS_IOS)
-
   return net::OK;
 }
 
@@ -78,15 +65,6 @@
         override_response_headers, allowed_unsafe_redirect_url));
   }
 
-#if !defined(OS_IOS)
-  WebSocket* web_socket = WebSocket::ForRequest(*request);
-  if (web_socket) {
-    chain->AddResult(web_socket->OnHeadersReceived(
-        chain->CreateCallback(), original_response_headers,
-        override_response_headers, allowed_unsafe_redirect_url));
-  }
-#endif  // !defined(OS_IOS)
-
   // Clear-Site-Data header will be handled by |ResourceDispatcherHost| if
   // network service is disabled.
   if (base::FeatureList::IsEnabled(network::features::kNetworkService)) {
--- a/services/network/network_service_proxy_delegate.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/network_service_proxy_delegate.cc	2019-05-17 18:53:37.896000000 +0300
@@ -165,11 +165,11 @@
 void NetworkServiceProxyDelegate::OnFallback(const net::ProxyServer& bad_proxy,
                                              int net_error) {}
 
-void NetworkServiceProxyDelegate::OnBeforeHttp1TunnelRequest(
+void NetworkServiceProxyDelegate::OnBeforeTunnelRequest(
     const net::ProxyServer& proxy_server,
     net::HttpRequestHeaders* extra_headers) {}
 
-net::Error NetworkServiceProxyDelegate::OnHttp1TunnelHeadersReceived(
+net::Error NetworkServiceProxyDelegate::OnTunnelHeadersReceived(
     const net::ProxyServer& proxy_server,
     const net::HttpResponseHeaders& response_headers) {
   return net::OK;
@@ -255,9 +255,7 @@
     const GURL& url,
     const std::string& method) const {
   return proxy_info.is_direct() && proxy_info.proxy_list().size() == 1 &&
-         MayProxyURL(url) &&
-         (proxy_config_->allow_non_idempotent_methods ||
-          net::HttpUtil::IsMethodIdempotent(method));
+         MayProxyURL(url) && net::HttpUtil::IsMethodIdempotent(method);
 }
 
 net::ProxyConfig::ProxyRules NetworkServiceProxyDelegate::GetProxyRulesForURL(
--- a/services/network/network_service_proxy_delegate.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/network_service_proxy_delegate.h	2019-05-17 18:53:37.896000000 +0300
@@ -52,10 +52,9 @@
                       const net::ProxyRetryInfoMap& proxy_retry_info,
                       net::ProxyInfo* result) override;
   void OnFallback(const net::ProxyServer& bad_proxy, int net_error) override;
-  void OnBeforeHttp1TunnelRequest(
-      const net::ProxyServer& proxy_server,
+  void OnBeforeTunnelRequest(const net::ProxyServer& proxy_server,
       net::HttpRequestHeaders* extra_headers) override;
-  net::Error OnHttp1TunnelHeadersReceived(
+  net::Error OnTunnelHeadersReceived(
       const net::ProxyServer& proxy_server,
       const net::HttpResponseHeaders& response_headers) override;
 
--- a/services/network/network_service_proxy_delegate_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/network_service_proxy_delegate_unittest.cc	2019-05-17 18:53:37.896000000 +0300
@@ -336,24 +336,6 @@
   EXPECT_FALSE(result.alternative_proxy().is_valid());
 }
 
-TEST_F(NetworkServiceProxyDelegateTest,
-       OnResolveProxyNonIdempotentMethodAllowed) {
-  auto config = mojom::CustomProxyConfig::New();
-  config->rules.ParseFromString("http=foo");
-  config->allow_non_idempotent_methods = true;
-  auto delegate = CreateDelegate(std::move(config));
-
-  net::ProxyInfo result;
-  result.UseDirect();
-  delegate->OnResolveProxy(GURL(kHttpUrl), "POST", net::ProxyRetryInfoMap(),
-                           &result);
-
-  net::ProxyList expected_proxy_list;
-  expected_proxy_list.AddProxyServer(
-      net::ProxyServer::FromPacString("PROXY foo"));
-  EXPECT_TRUE(result.proxy_list().Equals(expected_proxy_list));
-}
-
 TEST_F(NetworkServiceProxyDelegateTest, OnResolveProxyWebsocketScheme) {
   auto config = mojom::CustomProxyConfig::New();
   config->rules.ParseFromString("http=foo");
--- a/services/network/network_service_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/network_service_unittest.cc	2019-05-17 18:53:37.896000000 +0300
@@ -5,7 +5,6 @@
 #include <memory>
 #include <utility>
 
-#include "base/bind.h"
 #include "base/containers/span.h"
 #include "base/files/file_util.h"
 #include "base/files/scoped_temp_dir.h"
@@ -317,8 +316,6 @@
 }
 
 TEST_F(NetworkServiceTest, AuthDelegateWhitelist) {
-  using DelegationType = net::HttpAuth::DelegationType;
-
   // Add one server to the whitelist before creating any NetworkContexts.
   mojom::HttpAuthDynamicParamsPtr auth_params =
       mojom::HttpAuthDynamicParams::New();
@@ -333,56 +330,31 @@
   net::HttpAuthHandlerFactory* auth_handler_factory =
       network_context.url_request_context()->http_auth_handler_factory();
   ASSERT_TRUE(auth_handler_factory);
-  const net::HttpAuthPreferences* auth_prefs =
-      auth_handler_factory->http_auth_preferences();
-  ASSERT_TRUE(auth_prefs);
-  EXPECT_EQ(DelegationType::kUnconstrained,
-            auth_prefs->GetDelegationType(GURL("https://server1/")));
-  EXPECT_EQ(DelegationType::kNone,
-            auth_prefs->GetDelegationType(GURL("https://server2/")));
+  ASSERT_TRUE(auth_handler_factory->http_auth_preferences());
+  EXPECT_TRUE(auth_handler_factory->http_auth_preferences()->CanDelegate(
+      GURL("https://server1/")));
+  EXPECT_FALSE(auth_handler_factory->http_auth_preferences()->CanDelegate(
+      GURL("https://server2/")));
 
   // Change whitelist to only have a different server on it. The pre-existing
   // NetworkContext should be using the new list.
   auth_params = mojom::HttpAuthDynamicParams::New();
   auth_params->delegate_whitelist = "server2";
   service()->ConfigureHttpAuthPrefs(std::move(auth_params));
-  EXPECT_EQ(DelegationType::kNone,
-            auth_prefs->GetDelegationType(GURL("https://server1/")));
-  EXPECT_EQ(DelegationType::kUnconstrained,
-            auth_prefs->GetDelegationType(GURL("https://server2/")));
+  EXPECT_FALSE(auth_handler_factory->http_auth_preferences()->CanDelegate(
+      GURL("https://server1/")));
+  EXPECT_TRUE(auth_handler_factory->http_auth_preferences()->CanDelegate(
+      GURL("https://server2/")));
 
   // Change whitelist to have multiple servers. The pre-existing NetworkContext
   // should be using the new list.
   auth_params = mojom::HttpAuthDynamicParams::New();
   auth_params->delegate_whitelist = "server1,server2";
   service()->ConfigureHttpAuthPrefs(std::move(auth_params));
-  EXPECT_EQ(DelegationType::kUnconstrained,
-            auth_prefs->GetDelegationType(GURL("https://server1/")));
-  EXPECT_EQ(DelegationType::kUnconstrained,
-            auth_prefs->GetDelegationType(GURL("https://server2/")));
-}
-
-TEST_F(NetworkServiceTest, DelegateByKdcPolicy) {
-  // Create a network context, which should use default value.
-  mojom::NetworkContextPtr network_context_ptr;
-  NetworkContext network_context(service(),
-                                 mojo::MakeRequest(&network_context_ptr),
-                                 CreateContextParams());
-  net::HttpAuthHandlerFactory* auth_handler_factory =
-      network_context.url_request_context()->http_auth_handler_factory();
-  ASSERT_TRUE(auth_handler_factory);
-  ASSERT_TRUE(auth_handler_factory->http_auth_preferences());
-  EXPECT_FALSE(
-      auth_handler_factory->http_auth_preferences()->delegate_by_kdc_policy());
-
-  // Change whitelist to only have a different server on it. The pre-existing
-  // NetworkContext should be using the new list.
-  mojom::HttpAuthDynamicParamsPtr auth_params =
-      mojom::HttpAuthDynamicParams::New();
-  auth_params->delegate_by_kdc_policy = true;
-  service()->ConfigureHttpAuthPrefs(std::move(auth_params));
-  EXPECT_TRUE(
-      auth_handler_factory->http_auth_preferences()->delegate_by_kdc_policy());
+  EXPECT_TRUE(auth_handler_factory->http_auth_preferences()->CanDelegate(
+      GURL("https://server1/")));
+  EXPECT_TRUE(auth_handler_factory->http_auth_preferences()->CanDelegate(
+      GURL("https://server2/")));
 }
 
 TEST_F(NetworkServiceTest, AuthNegotiateCnameLookup) {
--- a/services/network/OWNERS	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/OWNERS	2019-05-17 18:53:37.876000000 +0300
@@ -21,10 +21,10 @@
 per-file cert_verifier_with_trust_anchors*=file://chromeos/policy/OWNERS
 per-file cert_verify_proc_chromeos*=file://chromeos/policy/OWNERS
 
+per-file manifest.json=set noparent
+per-file manifest.json=file://ipc/SECURITY_OWNERS
 per-file *_type_converter*.*=set noparent
 per-file *_type_converter*.*=file://ipc/SECURITY_OWNERS
 
 per-file network_sandbox_hook_linux.*.cc=file://sandbox/OWNERS
 per-file network_sandbox_win.*=file://sandbox/win/OWNERS
-
-per-file resource_scheduler*=tbansal@chromium.org
--- a/services/network/p2p/socket.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/p2p/socket.cc	2019-05-17 18:53:37.896000000 +0300
@@ -6,7 +6,6 @@
 
 #include <utility>
 
-#include "base/bind.h"
 #include "base/metrics/histogram_macros.h"
 #include "base/sys_byteorder.h"
 #include "net/base/net_errors.h"
--- a/services/network/p2p/socket_tcp.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/p2p/socket_tcp.cc	2019-05-17 18:53:37.900000000 +0300
@@ -7,7 +7,6 @@
 #include <stddef.h>
 #include <utility>
 
-#include "base/bind.h"
 #include "base/sys_byteorder.h"
 #include "base/threading/thread_task_runner_handle.h"
 #include "jingle/glue/fake_ssl_client_socket.h"
--- a/services/network/p2p/socket_tcp_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/p2p/socket_tcp_unittest.cc	2019-05-17 18:53:37.900000000 +0300
@@ -515,7 +515,7 @@
 class P2PSocketTcpWithTlsTest
     : public testing::TestWithParam<std::tuple<net::IoMode, P2PSocketType>> {};
 
-INSTANTIATE_TEST_SUITE_P(
+INSTANTIATE_TEST_CASE_P(
     /* no prefix */,
     P2PSocketTcpWithTlsTest,
     ::testing::Combine(::testing::Values(net::SYNCHRONOUS, net::ASYNC),
--- a/services/network/p2p/socket_test_utils.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/p2p/socket_test_utils.cc	2019-05-17 18:53:37.900000000 +0300
@@ -6,7 +6,6 @@
 
 #include <stddef.h>
 
-#include "base/bind.h"
 #include "base/logging.h"
 #include "base/sys_byteorder.h"
 #include "base/test/bind_test_util.h"
--- a/services/network/p2p/socket_udp_unittest.cc	2019-05-17 17:45:42.556000000 +0300
+++ b/services/network/p2p/socket_udp_unittest.cc	2019-05-17 18:53:37.900000000 +0300
@@ -8,7 +8,6 @@
 #include <utility>
 #include <vector>
 
-#include "base/bind.h"
 #include "base/containers/circular_deque.h"
 #include "base/logging.h"
 #include "base/run_loop.h"
@@ -463,7 +462,7 @@
 }
 
 // The fake clock mechanism used for this test doesn't work in component builds.
-// See: https://bugs.ch40m1um.qjz9zk/p/webrtc/issues/detail?id=6490
+// See: https://bugs.chromium.org/p/webrtc/issues/detail?id=6490
 #if defined(COMPONENT_BUILD)
 #define MAYBE_ThrottlingStopsAtExpectedTimes \
   DISABLED_ThrottlingStopsAtExpectedTimes
--- a/services/network/pending_callback_chain.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/pending_callback_chain.cc	2019-05-17 18:53:37.900000000 +0300
@@ -3,7 +3,6 @@
 // found in the LICENSE file.
 
 #include "services/network/pending_callback_chain.h"
-#include "base/bind.h"
 
 namespace network {
 
--- a/services/network/proxy_resolver_factory_mojo.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/proxy_resolver_factory_mojo.cc	2019-05-17 18:53:37.900000000 +0300
@@ -5,9 +5,7 @@
 #include "services/network/proxy_resolver_factory_mojo.h"
 
 #include <set>
-#include <string>
 #include <utility>
-#include <vector>
 
 #include "base/bind.h"
 #include "base/callback.h"
@@ -20,7 +18,6 @@
 #include "base/task_runner.h"
 #include "base/values.h"
 #include "mojo/public/cpp/bindings/binding.h"
-#include "net/base/ip_address.h"
 #include "net/base/load_states.h"
 #include "net/base/net_errors.h"
 #include "net/log/net_log.h"
@@ -30,7 +27,6 @@
 #include "net/proxy_resolution/pac_file_data.h"
 #include "net/proxy_resolution/pac_library.h"
 #include "net/proxy_resolution/proxy_info.h"
-#include "net/proxy_resolution/proxy_resolve_dns_operation.h"
 #include "net/proxy_resolution/proxy_resolver.h"
 #include "net/proxy_resolution/proxy_resolver_error_observer.h"
 #include "services/network/mojo_host_resolver_impl.h"
@@ -56,7 +52,7 @@
     bool is_ex,
     proxy_resolver::mojom::HostResolverRequestClientPtrInfo client_info) {
   // Resolve the list of IP addresses.
-  std::vector<net::IPAddress> my_ip_addresses =
+  net::IPAddressList my_ip_addresses =
       is_ex ? net::PacMyIpAddressEx() : net::PacMyIpAddress();
 
   proxy_resolver::mojom::HostResolverRequestClientPtr client;
@@ -72,7 +68,11 @@
   if (my_ip_addresses.empty())
     my_ip_addresses.push_back(net::IPAddress::IPv4Localhost());
 
-  client->ReportResult(net::OK, my_ip_addresses);
+  // Convert to a net::AddressList.
+  net::AddressList list;
+  for (const auto& ip : my_ip_addresses)
+    list.push_back(net::IPEndPoint(ip, 80));
+  client->ReportResult(net::OK, list);
 }
 
 // A mixin that forwards logging to (Bound)NetLog and ProxyResolverErrorObserver
@@ -116,20 +116,18 @@
   // TODO(eroman): Split the client interfaces so ResolveDns() does not also
   // carry the myIpAddress(Ex) requests.
   void ResolveDns(
-      const std::string& hostname,
-      net::ProxyResolveDnsOperation operation,
+      std::unique_ptr<net::HostResolver::RequestInfo> request_info,
       proxy_resolver::mojom::HostResolverRequestClientPtr client) override {
-    bool is_ex = operation == net::ProxyResolveDnsOperation::DNS_RESOLVE_EX ||
-                 operation == net::ProxyResolveDnsOperation::MY_IP_ADDRESS_EX;
+    if (request_info->is_my_ip_address()) {
+      bool is_ex =
+          request_info->address_family() == net::ADDRESS_FAMILY_UNSPECIFIED;
 
-    if (operation == net::ProxyResolveDnsOperation::MY_IP_ADDRESS ||
-        operation == net::ProxyResolveDnsOperation::MY_IP_ADDRESS_EX) {
       GetMyIpAddressTaskRuner()->PostTask(
           FROM_HERE, base::BindOnce(&DoMyIpAddressOnWorker, is_ex,
                                     client.PassInterface()));
     } else {
       // Request was for dnsResolve() or dnsResolveEx().
-      host_resolver_.Resolve(hostname, is_ex, std::move(client));
+      host_resolver_.Resolve(std::move(request_info), std::move(client));
     }
   }
 
--- a/services/network/proxy_resolver_factory_mojo_unittest.cc	2019-05-17 17:45:42.556000000 +0300
+++ b/services/network/proxy_resolver_factory_mojo_unittest.cc	2019-05-17 18:53:37.900000000 +0300
@@ -21,13 +21,12 @@
 #include "net/base/load_states.h"
 #include "net/base/net_errors.h"
 #include "net/base/test_completion_callback.h"
-#include "net/dns/mock_host_resolver.h"
+#include "net/dns/host_resolver.h"
 #include "net/log/net_log_event_type.h"
 #include "net/log/net_log_with_source.h"
 #include "net/log/test_net_log.h"
 #include "net/proxy_resolution/pac_file_data.h"
 #include "net/proxy_resolution/proxy_info.h"
-#include "net/proxy_resolution/proxy_resolve_dns_operation.h"
 #include "net/proxy_resolution/proxy_resolver.h"
 #include "net/proxy_resolution/proxy_resolver_error_observer.h"
 #include "net/proxy_resolution/proxy_resolver_factory.h"
@@ -276,11 +275,11 @@
       break;
     }
     case GetProxyForUrlAction::MAKE_DNS_REQUEST: {
+      auto request = std::make_unique<net::HostResolver::RequestInfo>(
+          net::HostPortPair(url.spec(), 12345));
       proxy_resolver::mojom::HostResolverRequestClientPtr dns_client;
       mojo::MakeRequest(&dns_client);
-      client->ResolveDns(url.host(),
-                         net::ProxyResolveDnsOperation::DNS_RESOLVE_EX,
-                         std::move(dns_client));
+      client->ResolveDns(std::move(request), std::move(dns_client));
       blocked_clients_.push_back(
           std::make_unique<
               proxy_resolver::mojom::ProxyResolverRequestClientPtr>(
@@ -456,11 +455,11 @@
       break;
     }
     case CreateProxyResolverAction::MAKE_DNS_REQUEST: {
+      auto request = std::make_unique<net::HostResolver::RequestInfo>(
+          net::HostPortPair(pac_script, 12345));
       proxy_resolver::mojom::HostResolverRequestClientPtr dns_client;
       mojo::MakeRequest(&dns_client);
-      client->ResolveDns(pac_script,
-                         net::ProxyResolveDnsOperation::DNS_RESOLVE_EX,
-                         std::move(dns_client));
+      client->ResolveDns(std::move(request), std::move(dns_client));
       blocked_clients_.push_back(
           std::make_unique<
               proxy_resolver::mojom::ProxyResolverFactoryRequestClientPtr>(
@@ -481,6 +480,61 @@
   std::move(callback).Run(result);
 }
 
+class MockHostResolver : public net::HostResolver {
+ public:
+  enum Event {
+    DNS_REQUEST,
+  };
+
+  // net::HostResolver overrides.
+  std::unique_ptr<HostResolver::ResolveHostRequest> CreateRequest(
+      const net::HostPortPair& host,
+      const net::NetLogWithSource& source_net_log,
+      const base::Optional<ResolveHostParameters>& optional_parameters)
+      override {
+    // TODO(crbug.com/821021): Implement.
+    NOTIMPLEMENTED();
+    return nullptr;
+  }
+
+  int Resolve(const RequestInfo& info,
+              net::RequestPriority priority,
+              net::AddressList* addresses,
+              net::CompletionOnceCallback callback,
+              std::unique_ptr<Request>* request,
+              const net::NetLogWithSource& source_net_log) override {
+    waiter_.NotifyEvent(DNS_REQUEST);
+    return net::ERR_IO_PENDING;
+  }
+
+  int ResolveFromCache(const RequestInfo& info,
+                       net::AddressList* addresses,
+                       const net::NetLogWithSource& source_net_log) override {
+    return net::ERR_DNS_CACHE_MISS;
+  }
+
+  int ResolveStaleFromCache(
+      const RequestInfo& info,
+      net::AddressList* addresses,
+      net::HostCache::EntryStaleness* stale_info,
+      const net::NetLogWithSource& source_net_log) override {
+    return net::ERR_DNS_CACHE_MISS;
+  }
+
+  net::HostCache* GetHostCache() override { return nullptr; }
+
+  bool HasCached(base::StringPiece hostname,
+                 net::HostCache::Entry::Source* source_out,
+                 net::HostCache::EntryStaleness* stale_out) const override {
+    return false;
+  }
+
+  net::EventWaiter<Event>& waiter() { return waiter_; }
+
+ private:
+  net::EventWaiter<Event> waiter_;
+};
+
 void CheckCapturedNetLogEntries(const std::string& expected_string,
                                 const net::TestNetLogEntry::List& entries) {
   ASSERT_EQ(2u, entries.size());
@@ -544,7 +598,7 @@
   }
 
   base::test::ScopedTaskEnvironment task_environment_;
-  net::HangingHostResolver host_resolver_;
+  MockHostResolver host_resolver_;
   net::TestNetLog net_log_;
   std::unique_ptr<MockMojoProxyResolverFactory> mock_proxy_resolver_factory_;
   std::unique_ptr<net::ProxyResolverFactory> proxy_resolver_factory_mojo_;
@@ -750,13 +804,9 @@
       proxy_resolver_factory_mojo_->CreateProxyResolver(
           pac_script, &proxy_resolver_mojo_, callback.callback(), &request));
   ASSERT_TRUE(request);
-
-  base::RunLoop run_loop;
-  run_loop.RunUntilIdle();
-
+  host_resolver_.waiter().WaitForEvent(MockHostResolver::DNS_REQUEST);
   mock_proxy_resolver_factory_->ClearBlockedClients();
   callback.WaitForResult();
-  EXPECT_EQ(1, host_resolver_.num_cancellations());
 }
 
 TEST_F(ProxyResolverFactoryMojoTest, GetProxyForURL) {
@@ -825,14 +875,14 @@
   mock_proxy_resolver_.AddGetProxyAction(GetProxyForUrlAction::ReturnServers(
       GURL(kExampleUrl), ProxyServersFromPacString("DIRECT")));
   mock_proxy_resolver_.AddGetProxyAction(GetProxyForUrlAction::ReturnServers(
-      GURL("https://www.ch40m1um.qjz9zk"),
+      GURL("https://www.chromium.org"),
       ProxyServersFromPacString("HTTPS foo:443")));
   CreateProxyResolver();
 
   std::unique_ptr<Request> request1(MakeRequest(GURL(kExampleUrl)));
   EXPECT_THAT(request1->Resolve(), IsError(net::ERR_IO_PENDING));
   std::unique_ptr<Request> request2(
-      MakeRequest(GURL("https://www.ch40m1um.qjz9zk")));
+      MakeRequest(GURL("https://www.chromium.org")));
   EXPECT_THAT(request2->Resolve(), IsError(net::ERR_IO_PENDING));
 
   EXPECT_THAT(request1->WaitForResult(), IsOk());
@@ -922,12 +972,10 @@
   EXPECT_THAT(request->Resolve(), IsError(net::ERR_IO_PENDING));
   EXPECT_EQ(net::LOAD_STATE_RESOLVING_PROXY_FOR_URL, request->load_state());
 
-  base::RunLoop run_loop;
-  run_loop.RunUntilIdle();
-
+  host_resolver_.waiter().WaitForEvent(MockHostResolver::DNS_REQUEST);
+  EXPECT_EQ(net::LOAD_STATE_RESOLVING_HOST_IN_PAC_FILE, request->load_state());
   mock_proxy_resolver_.ClearBlockedClients();
   request->WaitForResult();
-  EXPECT_EQ(1, host_resolver_.num_cancellations());
 }
 
 TEST_F(ProxyResolverFactoryMojoTest, DeleteResolver) {
--- a/services/network/proxy_resolving_client_socket.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/proxy_resolving_client_socket.cc	2019-05-17 18:53:37.900000000 +0300
@@ -231,6 +231,12 @@
       case STATE_INIT_CONNECTION_COMPLETE:
         rv = DoInitConnectionComplete(rv);
         break;
+      case STATE_RESTART_TUNNEL_AUTH:
+        rv = DoRestartTunnelAuth(rv);
+        break;
+      case STATE_RESTART_TUNNEL_AUTH_COMPLETE:
+        rv = DoRestartTunnelAuthComplete(rv);
+        break;
       default:
         NOTREACHED() << "bad state";
         rv = net::ERR_FAILED;
@@ -292,22 +298,32 @@
         host_port_pair, network_session_, request_load_flags, request_priority,
         proxy_info_, ssl_config_, ssl_config_, net::PRIVACY_MODE_DISABLED,
         net_log_, socket_handle_.get(),
-        base::BindOnce(&ProxyResolvingClientSocket::OnIOComplete,
-                       base::Unretained(this)),
-        base::BindRepeating(&ProxyResolvingClientSocket::OnProxyAuth,
+        base::BindRepeating(&ProxyResolvingClientSocket::OnIOComplete,
                             base::Unretained(this)));
   }
   return net::InitSocketHandleForRawConnect(
       host_port_pair, network_session_, request_load_flags, request_priority,
       proxy_info_, ssl_config_, ssl_config_, net::PRIVACY_MODE_DISABLED,
       net_log_, socket_handle_.get(),
-      base::BindOnce(&ProxyResolvingClientSocket::OnIOComplete,
-                     base::Unretained(this)),
-      base::BindRepeating(&ProxyResolvingClientSocket::OnProxyAuth,
+      base::BindRepeating(&ProxyResolvingClientSocket::OnIOComplete,
                           base::Unretained(this)));
 }
 
 int ProxyResolvingClientSocket::DoInitConnectionComplete(int result) {
+  if (result == net::ERR_PROXY_AUTH_REQUESTED) {
+    if (use_tls_) {
+      // Put the in-progress HttpProxyClientSocket into |socket_handle_| to
+      // do tunnel auth. After auth completes, it's important to reset
+      // |socket_handle_|, so it doesn't have a HttpProxyClientSocket when the
+      // code expects an SSLClientSocket. The tunnel restart code is careful to
+      // put it back to the socket pool before returning control to the rest of
+      // this class.
+      socket_handle_ = socket_handle_->release_pending_http_proxy_connection();
+    }
+    next_state_ = STATE_RESTART_TUNNEL_AUTH;
+    return result;
+  }
+
   if (result != net::OK) {
     // ReconsiderProxyAfterError either returns an error (in which case it is
     // not reconsidering a proxy) or returns ERR_IO_PENDING if it is considering
@@ -319,20 +335,42 @@
   return net::OK;
 }
 
-void ProxyResolvingClientSocket::OnProxyAuth(
-    const net::HttpResponseInfo& response,
-    net::HttpAuthController* auth_controller,
-    base::OnceClosure restart_with_auth_callback) {
-  DCHECK_EQ(next_state_, STATE_INIT_CONNECTION_COMPLETE);
-  // If there are credentials available to try and use, use them.
-  if (auth_controller->HaveAuth()) {
-    std::move(restart_with_auth_callback).Run();
-    return;
-  }
+int ProxyResolvingClientSocket::DoRestartTunnelAuth(int result) {
+  DCHECK_EQ(net::ERR_PROXY_AUTH_REQUESTED, result);
 
-  // Otherwise, cancel the socket request and continue.
-  CloseSocket(false /* close_connection */);
-  OnIOComplete(net::ERR_PROXY_AUTH_REQUESTED);
+  net::ProxyClientSocket* proxy_socket =
+      static_cast<net::ProxyClientSocket*>(socket_handle_->socket());
+
+  if (proxy_socket->GetAuthController() &&
+      proxy_socket->GetAuthController()->HaveAuth()) {
+    next_state_ = STATE_RESTART_TUNNEL_AUTH_COMPLETE;
+    // base::Unretained(this) is safe because |proxy_socket| is owned by this.
+    return proxy_socket->RestartWithAuth(base::BindRepeating(
+        &ProxyResolvingClientSocket::OnIOComplete, base::Unretained(this)));
+  }
+  // This socket is unusable if the underlying authentication handler doesn't
+  // already have credentials.  It is possible to overcome this hurdle and
+  // finish the handshake if this class exposes an interface for an embedder to
+  // supply credentials.
+  CloseSocket(true /*close_connection*/);
+  return result;
+}
+
+int ProxyResolvingClientSocket::DoRestartTunnelAuthComplete(int result) {
+  if (result == net::ERR_PROXY_AUTH_REQUESTED) {
+    // Handle multi-round auth challenge.
+    next_state_ = STATE_RESTART_TUNNEL_AUTH;
+    return result;
+  }
+  if (result == net::OK) {
+    CloseSocket(false /*close_connection*/);
+    // Now that the HttpProxyClientSocket is connected, release it as an idle
+    // socket into the pool and start the connection process from the beginning.
+    next_state_ = STATE_INIT_CONNECTION;
+    return net::OK;
+  }
+  CloseSocket(true /*close_connection*/);
+  return ReconsiderProxyAfterError(result);
 }
 
 void ProxyResolvingClientSocket::CloseSocket(bool close_connection) {
--- a/services/network/proxy_resolving_client_socket.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/proxy_resolving_client_socket.h	2019-05-17 18:53:37.900000000 +0300
@@ -28,8 +28,6 @@
 
 namespace net {
 class ClientSocketHandle;
-class HttpAuthController;
-class HttpResponseInfo;
 class HttpNetworkSession;
 }  // namespace net
 
@@ -98,6 +96,8 @@
     STATE_PROXY_RESOLVE_COMPLETE,
     STATE_INIT_CONNECTION,
     STATE_INIT_CONNECTION_COMPLETE,
+    STATE_RESTART_TUNNEL_AUTH,
+    STATE_RESTART_TUNNEL_AUTH_COMPLETE,
     STATE_DONE,
     STATE_NONE,
   };
@@ -114,10 +114,8 @@
   int DoProxyResolveComplete(int result);
   int DoInitConnection();
   int DoInitConnectionComplete(int result);
-
-  void OnProxyAuth(const net::HttpResponseInfo& response,
-                   net::HttpAuthController* auth_controller,
-                   base::OnceClosure restart_with_auth_callback);
+  int DoRestartTunnelAuth(int result);
+  int DoRestartTunnelAuthComplete(int result);
 
   void CloseSocket(bool close_connection);
 
--- a/services/network/proxy_resolving_client_socket_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/proxy_resolving_client_socket_unittest.cc	2019-05-17 18:53:37.900000000 +0300
@@ -76,7 +76,7 @@
   const bool use_tls_;
 };
 
-INSTANTIATE_TEST_SUITE_P(/* no prefix */,
+INSTANTIATE_TEST_CASE_P(/* no prefix */,
                          ProxyResolvingClientSocketTest,
                          ::testing::Bool());
 
@@ -817,7 +817,7 @@
                                     net::ERR_PROXY_CERTIFICATE_INVALID,
                                     net::ERR_SSL_PROTOCOL_ERROR};
 
-INSTANTIATE_TEST_SUITE_P(
+INSTANTIATE_TEST_CASE_P(
     /* no prefix */,
     ReconsiderProxyAfterErrorTest,
     testing::Combine(testing::Bool(),
--- a/services/network/proxy_resolving_socket_mojo.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/proxy_resolving_socket_mojo.cc	2019-05-17 18:53:37.904000000 +0300
@@ -6,7 +6,6 @@
 
 #include <utility>
 
-#include "base/bind.h"
 #include "base/logging.h"
 #include "base/optional.h"
 #include "net/base/net_errors.h"
--- a/services/network/proxy_resolving_socket_mojo_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/proxy_resolving_socket_mojo_unittest.cc	2019-05-17 18:53:37.904000000 +0300
@@ -176,7 +176,7 @@
   DISALLOW_COPY_AND_ASSIGN(ProxyResolvingSocketTest);
 };
 
-INSTANTIATE_TEST_SUITE_P(/* no prefix */,
+INSTANTIATE_TEST_CASE_P(/* no prefix */,
                          ProxyResolvingSocketTest,
                          ::testing::Bool());
 
--- a/services/network/proxy_service_mojo.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/proxy_service_mojo.cc	2019-05-17 18:53:37.904000000 +0300
@@ -7,7 +7,6 @@
 #include <memory>
 #include <utility>
 
-#include "base/bind.h"
 #include "base/logging.h"
 #include "base/threading/thread_task_runner_handle.h"
 #include "net/proxy_resolution/network_delegate_error_observer.h"
--- a/services/network/public/cpp/BUILD.gn	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/public/cpp/BUILD.gn	2019-05-17 18:53:37.904000000 +0300
@@ -85,10 +85,6 @@
   ]
 
   defines = [ "IS_NETWORK_CPP_IMPL" ]
-
-  if (is_chromecast) {
-    defines += [ "IS_CHROMECAST" ]
-  }
 }
 
 jumbo_component("cpp_base") {
@@ -220,16 +216,3 @@
     ":buildflags",
   ]
 }
-
-source_set("manifest") {
-  sources = [
-    "manifest.cc",
-    "manifest.h",
-  ]
-
-  deps = [
-    "//base",
-    "//services/network/public/mojom",
-    "//services/service_manager/public/cpp",
-  ]
-}
--- a/services/network/public/cpp/cookie_manager_mojom_traits.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/public/cpp/cookie_manager_mojom_traits.cc	2019-05-17 18:53:37.904000000 +0300
@@ -74,14 +74,14 @@
 
 network::mojom::CookieSameSiteFilter
 EnumTraits<network::mojom::CookieSameSiteFilter,
-           net::CookieOptions::SameSiteCookieContext>::
-    ToMojom(net::CookieOptions::SameSiteCookieContext input) {
+           net::CookieOptions::SameSiteCookieMode>::
+    ToMojom(net::CookieOptions::SameSiteCookieMode input) {
   switch (input) {
-    case net::CookieOptions::SameSiteCookieContext::SAME_SITE_STRICT:
+    case net::CookieOptions::SameSiteCookieMode::INCLUDE_STRICT_AND_LAX:
       return network::mojom::CookieSameSiteFilter::INCLUDE_STRICT_AND_LAX;
-    case net::CookieOptions::SameSiteCookieContext::SAME_SITE_LAX:
+    case net::CookieOptions::SameSiteCookieMode::INCLUDE_LAX:
       return network::mojom::CookieSameSiteFilter::INCLUDE_LAX;
-    case net::CookieOptions::SameSiteCookieContext::CROSS_SITE:
+    case net::CookieOptions::SameSiteCookieMode::DO_NOT_INCLUDE:
       return network::mojom::CookieSameSiteFilter::DO_NOT_INCLUDE;
   }
   NOTREACHED();
@@ -89,18 +89,18 @@
 }
 
 bool EnumTraits<network::mojom::CookieSameSiteFilter,
-                net::CookieOptions::SameSiteCookieContext>::
+                net::CookieOptions::SameSiteCookieMode>::
     FromMojom(network::mojom::CookieSameSiteFilter input,
-              net::CookieOptions::SameSiteCookieContext* output) {
+              net::CookieOptions::SameSiteCookieMode* output) {
   switch (input) {
     case network::mojom::CookieSameSiteFilter::INCLUDE_STRICT_AND_LAX:
-      *output = net::CookieOptions::SameSiteCookieContext::SAME_SITE_STRICT;
+      *output = net::CookieOptions::SameSiteCookieMode::INCLUDE_STRICT_AND_LAX;
       return true;
     case network::mojom::CookieSameSiteFilter::INCLUDE_LAX:
-      *output = net::CookieOptions::SameSiteCookieContext::SAME_SITE_LAX;
+      *output = net::CookieOptions::SameSiteCookieMode::INCLUDE_LAX;
       return true;
     case network::mojom::CookieSameSiteFilter::DO_NOT_INCLUDE:
-      *output = net::CookieOptions::SameSiteCookieContext::CROSS_SITE;
+      *output = net::CookieOptions::SameSiteCookieMode::DO_NOT_INCLUDE;
       return true;
   }
   return false;
@@ -114,10 +114,10 @@
   else
     cookie_options->set_include_httponly();
 
-  net::CookieOptions::SameSiteCookieContext same_site_cookie_context;
-  if (!mojo_options.ReadCookieSameSiteFilter(&same_site_cookie_context))
+  net::CookieOptions::SameSiteCookieMode same_site_cookie_mode;
+  if (!mojo_options.ReadCookieSameSiteFilter(&same_site_cookie_mode))
     return false;
-  cookie_options->set_same_site_cookie_context(same_site_cookie_context);
+  cookie_options->set_same_site_cookie_mode(same_site_cookie_mode);
 
   if (mojo_options.update_access_time())
     cookie_options->set_update_access_time();
--- a/services/network/public/cpp/cookie_manager_mojom_traits.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/public/cpp/cookie_manager_mojom_traits.h	2019-05-17 18:53:37.904000000 +0300
@@ -30,12 +30,12 @@
 
 template <>
 struct EnumTraits<network::mojom::CookieSameSiteFilter,
-                  net::CookieOptions::SameSiteCookieContext> {
+                  net::CookieOptions::SameSiteCookieMode> {
   static network::mojom::CookieSameSiteFilter ToMojom(
-      net::CookieOptions::SameSiteCookieContext input);
+      net::CookieOptions::SameSiteCookieMode input);
 
   static bool FromMojom(network::mojom::CookieSameSiteFilter input,
-                        net::CookieOptions::SameSiteCookieContext* output);
+                        net::CookieOptions::SameSiteCookieMode* output);
 };
 
 template <>
@@ -43,9 +43,9 @@
   static bool exclude_httponly(const net::CookieOptions& o) {
     return o.exclude_httponly();
   }
-  static net::CookieOptions::SameSiteCookieContext cookie_same_site_filter(
+  static net::CookieOptions::SameSiteCookieMode cookie_same_site_filter(
       const net::CookieOptions& o) {
-    return o.same_site_cookie_context();
+    return o.same_site_cookie_mode();
   }
   static bool update_access_time(const net::CookieOptions& o) {
     return o.update_access_time();
--- a/services/network/public/cpp/cookie_manager.typemap	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/public/cpp/cookie_manager.typemap	2019-05-17 18:53:37.904000000 +0300
@@ -16,7 +16,7 @@
 type_mappings = [
   "network.mojom.CookiePriority=net::CookiePriority",
   "network.mojom.CookieSameSite=net::CookieSameSite",
-  "network.mojom.CookieSameSiteFilter=net::CookieOptions::SameSiteCookieContext",
+  "network.mojom.CookieSameSiteFilter=net::CookieOptions::SameSiteCookieMode",
   "network.mojom.CookieOptions=net::CookieOptions",
   "network.mojom.CanonicalCookie=net::CanonicalCookie",
 ]
--- a/services/network/public/cpp/cors/cors.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/public/cpp/cors/cors.cc	2019-05-17 18:53:37.904000000 +0300
@@ -359,38 +359,15 @@
   // Treat 'Intervention' as a CORS-safelisted header, since it is added by
   // Chrome when an intervention is (or may be) applied.
   static const char* const safe_names[] = {
-      "accept",
-      "accept-language",
-      "content-language",
-      "intervention",
-      "content-type",
-      "save-data",
+      "accept", "accept-language", "content-language", "intervention",
+      "content-type", "save-data",
       // The Device Memory header field is a number that indicates the client’s
       // device memory i.e. approximate amount of ram in GiB. The header value
       // must satisfy ABNF  1*DIGIT [ "." 1*DIGIT ]
       // See
       // https://w3c.github.io/device-memory/#sec-device-memory-client-hint-header
       // for more details.
-      "device-memory",
-      "dpr",
-      "width",
-      "viewport-width",
-
-      // The `Sec-CH-Lang` header field is a proposed replacement for
-      // `Accept-Language`, using the Client Hints infrastructure.
-      //
-      // https://tools.ietf.org/html/draft-west-lang-client-hint
-      "sec-ch-lang",
-
-      // The `Sec-CH-UA-*` header fields are proposed replacements for
-      // `User-Agent`, using the Client Hints infrastructure.
-      //
-      // https://tools.ietf.org/html/draft-west-ua-client-hints
-      "sec-ch-ua",
-      "sec-ch-ua-platform",
-      "sec-ch-ua-arch",
-      "sec-ch-ua-model",
-  };
+      "device-memory", "dpr", "width", "viewport-width"};
   const std::string lower_name = base::ToLowerASCII(name);
   if (std::find(std::begin(safe_names), std::end(safe_names), lower_name) ==
       std::end(safe_names))
@@ -398,8 +375,7 @@
 
   // Client hints are device specific, and not origin specific. As such all
   // client hint headers are considered as safe.
-  // See
-  // third_party/blink/public/mojom/web_client_hints/web_client_hints_types.mojom.
+  // See third_party/WebKit/public/platform/web_client_hints_types.mojom.
   // Client hint headers can be added by Chrome automatically or via JavaScript.
   if (lower_name == "device-memory" || lower_name == "dpr")
     return IsSimilarToDoubleABNF(value);
--- a/services/network/public/cpp/cors/cors_unittest.cc	2019-05-17 17:45:42.560000000 +0300
+++ b/services/network/public/cpp/cors/cors_unittest.cc	2019-05-17 18:53:37.904000000 +0300
@@ -29,7 +29,7 @@
 // Tests if CheckAccess detects kWildcardOriginNotAllowed error correctly.
 TEST_F(CorsTest, CheckAccessDetectsWildcardOriginNotAllowed) {
   const GURL response_url("http://example.com/data");
-  const url::Origin origin = url::Origin::Create(GURL("http://9oo91e.qjz9zk"));
+  const url::Origin origin = url::Origin::Create(GURL("http://google.com"));
   const int response_status_code = 200;
   const std::string allow_all_header("*");
 
@@ -55,7 +55,7 @@
 // Tests if CheckAccess detects kMissingAllowOriginHeader error correctly.
 TEST_F(CorsTest, CheckAccessDetectsMissingAllowOriginHeader) {
   const GURL response_url("http://example.com/data");
-  const url::Origin origin = url::Origin::Create(GURL("http://9oo91e.qjz9zk"));
+  const url::Origin origin = url::Origin::Create(GURL("http://google.com"));
   const int response_status_code = 200;
 
   // Access-Control-Allow-Origin is missed.
@@ -72,7 +72,7 @@
 // correctly.
 TEST_F(CorsTest, CheckAccessDetectsMultipleAllowOriginValues) {
   const GURL response_url("http://example.com/data");
-  const url::Origin origin = url::Origin::Create(GURL("http://9oo91e.qjz9zk"));
+  const url::Origin origin = url::Origin::Create(GURL("http://google.com"));
   const int response_status_code = 200;
 
   const std::string space_separated_multiple_origins(
@@ -99,7 +99,7 @@
 // Tests if CheckAccess detects kInvalidAllowOriginValue error correctly.
 TEST_F(CorsTest, CheckAccessDetectsInvalidAllowOriginValue) {
   const GURL response_url("http://example.com/data");
-  const url::Origin origin = url::Origin::Create(GURL("http://9oo91e.qjz9zk"));
+  const url::Origin origin = url::Origin::Create(GURL("http://google.com"));
   const int response_status_code = 200;
 
   base::Optional<CorsErrorStatus> error =
@@ -115,7 +115,7 @@
 // Tests if CheckAccess detects kAllowOriginMismatch error correctly.
 TEST_F(CorsTest, CheckAccessDetectsAllowOriginMismatch) {
   const GURL response_url("http://example.com/data");
-  const url::Origin origin = url::Origin::Create(GURL("http://9oo91e.qjz9zk"));
+  const url::Origin origin = url::Origin::Create(GURL("http://google.com"));
   const int response_status_code = 200;
 
   base::Optional<CorsErrorStatus> error1 =
@@ -127,12 +127,12 @@
 
   base::Optional<CorsErrorStatus> error2 = CheckAccess(
       response_url, response_status_code,
-      std::string("http://not.9oo91e.qjz9zk") /* allow_origin_header */,
+      std::string("http://not.google.com") /* allow_origin_header */,
       base::nullopt /* allow_credentials_header */,
       network::mojom::FetchCredentialsMode::kOmit, origin);
   ASSERT_TRUE(error2);
   EXPECT_EQ(mojom::CorsError::kAllowOriginMismatch, error2->cors_error);
-  EXPECT_EQ("http://not.9oo91e.qjz9zk", error2->failed_parameter);
+  EXPECT_EQ("http://not.google.com", error2->failed_parameter);
 
   // Allow "null" value to match serialized unique origins.
   const std::string null_string("null");
@@ -149,7 +149,7 @@
 // Tests if CheckAccess detects kInvalidAllowCredentials error correctly.
 TEST_F(CorsTest, CheckAccessDetectsInvalidAllowCredential) {
   const GURL response_url("http://example.com/data");
-  const url::Origin origin = url::Origin::Create(GURL("http://9oo91e.qjz9zk"));
+  const url::Origin origin = url::Origin::Create(GURL("http://google.com"));
   const int response_status_code = 200;
 
   base::Optional<CorsErrorStatus> error1 =
@@ -379,23 +379,6 @@
       IsCorsSafelistedHeader("aCcEPT-lAngUAge", std::string(129, 'a')));
 }
 
-TEST_F(CorsTest, SafelistedSecCHLang) {
-  EXPECT_TRUE(IsCorsSafelistedHeader("Sec-CH-Lang", "\"en\", \"de\""));
-
-  // TODO(mkwst): Validate that `Sec-CH-Lang` is a structured header.
-  // https://crbug.com/924969
-}
-
-TEST_F(CorsTest, SafelistedSecCHUA) {
-  EXPECT_TRUE(IsCorsSafelistedHeader("Sec-CH-UA", "\"User Agent!\""));
-  EXPECT_TRUE(IsCorsSafelistedHeader("Sec-CH-UA-Platform", "\"Platform!\""));
-  EXPECT_TRUE(IsCorsSafelistedHeader("Sec-CH-UA-Arch", "\"Architecture!\""));
-  EXPECT_TRUE(IsCorsSafelistedHeader("Sec-CH-UA-Model", "\"Model!\""));
-
-  // TODO(mkwst): Validate that `Sec-CH-UA-*` is a structured header.
-  // https://crbug.com/924969
-}
-
 TEST_F(CorsTest, SafelistedContentLanguage) {
   EXPECT_TRUE(IsCorsSafelistedHeader("content-language", "en,ja"));
   EXPECT_TRUE(IsCorsSafelistedHeader("cONTent-LANguaGe", "en,ja"));
--- a/services/network/public/cpp/cors/origin_access_entry_unittest.cc	2019-05-17 17:45:42.560000000 +0300
+++ b/services/network/public/cpp/cors/origin_access_entry_unittest.cc	2019-05-17 18:53:37.904000000 +0300
@@ -16,9 +16,9 @@
 namespace {
 
 TEST(OriginAccessEntryTest, PublicSuffixListTest) {
-  url::Origin origin = url::Origin::Create(GURL("http://www.9oo91e.qjz9zk"));
+  url::Origin origin = url::Origin::Create(GURL("http://www.google.com"));
   OriginAccessEntry entry1(
-      "http", "9oo91e.qjz9zk", mojom::CorsOriginAccessMatchMode::kAllowSubdomains,
+      "http", "google.com", mojom::CorsOriginAccessMatchMode::kAllowSubdomains,
       mojom::CorsOriginAccessMatchPriority::kDefaultPriority);
   OriginAccessEntry entry2(
       "http", "hamster.com", mojom::CorsOriginAccessMatchMode::kAllowSubdomains,
@@ -160,33 +160,33 @@
     const std::string origin;
     OriginAccessEntry::MatchResult expected;
   } inputs[] = {
-      {"http", "example.8pp2p8t.qjz9zk", "http://example.8pp2p8t.qjz9zk/",
+      {"http", "example.appspot.com", "http://example.appspot.com/",
        OriginAccessEntry::kMatchesOrigin},
-      {"http", "example.8pp2p8t.qjz9zk", "http://www.example.8pp2p8t.qjz9zk/",
+      {"http", "example.appspot.com", "http://www.example.appspot.com/",
        OriginAccessEntry::kMatchesOrigin},
-      {"http", "example.8pp2p8t.qjz9zk", "http://www.www.example.8pp2p8t.qjz9zk/",
+      {"http", "example.appspot.com", "http://www.www.example.appspot.com/",
        OriginAccessEntry::kMatchesOrigin},
-      {"http", "www.example.8pp2p8t.qjz9zk", "http://example.8pp2p8t.qjz9zk/",
+      {"http", "www.example.appspot.com", "http://example.appspot.com/",
        OriginAccessEntry::kMatchesOrigin},
-      {"http", "www.example.8pp2p8t.qjz9zk", "http://www.example.8pp2p8t.qjz9zk/",
+      {"http", "www.example.appspot.com", "http://www.example.appspot.com/",
        OriginAccessEntry::kMatchesOrigin},
-      {"http", "www.example.8pp2p8t.qjz9zk", "http://www.www.example.8pp2p8t.qjz9zk/",
+      {"http", "www.example.appspot.com", "http://www.www.example.appspot.com/",
        OriginAccessEntry::kMatchesOrigin},
-      {"http", "8pp2p8t.qjz9zk", "http://example.8pp2p8t.qjz9zk/",
+      {"http", "appspot.com", "http://example.appspot.com/",
        OriginAccessEntry::kMatchesOriginButIsPublicSuffix},
-      {"http", "8pp2p8t.qjz9zk", "http://www.example.8pp2p8t.qjz9zk/",
+      {"http", "appspot.com", "http://www.example.appspot.com/",
        OriginAccessEntry::kMatchesOriginButIsPublicSuffix},
-      {"http", "8pp2p8t.qjz9zk", "http://www.www.example.8pp2p8t.qjz9zk/",
+      {"http", "appspot.com", "http://www.www.example.appspot.com/",
        OriginAccessEntry::kMatchesOriginButIsPublicSuffix},
-      {"https", "example.8pp2p8t.qjz9zk", "http://example.8pp2p8t.qjz9zk/",
+      {"https", "example.appspot.com", "http://example.appspot.com/",
        OriginAccessEntry::kDoesNotMatchOrigin},
-      {"https", "example.8pp2p8t.qjz9zk", "http://www.example.8pp2p8t.qjz9zk/",
+      {"https", "example.appspot.com", "http://www.example.appspot.com/",
        OriginAccessEntry::kDoesNotMatchOrigin},
-      {"https", "example.8pp2p8t.qjz9zk", "http://www.www.example.8pp2p8t.qjz9zk/",
+      {"https", "example.appspot.com", "http://www.www.example.appspot.com/",
        OriginAccessEntry::kDoesNotMatchOrigin},
-      {"http", "example.8pp2p8t.qjz9zk", "http://beispiel.de/",
+      {"http", "example.appspot.com", "http://beispiel.de/",
        OriginAccessEntry::kDoesNotMatchOrigin},
-      {"http", "", "http://example.8pp2p8t.qjz9zk/",
+      {"http", "", "http://example.appspot.com/",
        OriginAccessEntry::kMatchesOrigin},
       {"http", "", "http://beispiel.de/", OriginAccessEntry::kMatchesOrigin},
       {"https", "", "http://beispiel.de/",
@@ -318,7 +318,7 @@
 
 TEST(OriginAccessEntryTest, CreateCorsOriginPattern) {
   const std::string kProtocol = "https";
-  const std::string kDomain = "9oo91e.qjz9zk";
+  const std::string kDomain = "google.com";
   const auto kMode = mojom::CorsOriginAccessMatchMode::kAllowSubdomains;
   const auto kPriority = mojom::CorsOriginAccessMatchPriority::kDefaultPriority;
 
--- a/services/network/public/cpp/cors/origin_access_list.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/public/cpp/cors/origin_access_list.cc	2019-05-17 18:53:37.904000000 +0300
@@ -67,36 +67,25 @@
   block_list_.clear();
 }
 
-OriginAccessList::AccessState OriginAccessList::CheckAccessState(
-    const url::Origin& source_origin,
+bool OriginAccessList::IsAllowed(const url::Origin& source_origin,
     const GURL& destination) const {
   if (source_origin.opaque())
-    return AccessState::kBlocked;
-
+    return false;
   std::string source = source_origin.Serialize();
   url::Origin destination_origin = url::Origin::Create(destination);
   network::mojom::CorsOriginAccessMatchPriority allow_list_priority =
       GetHighestPriorityOfRuleForOrigin(source, destination_origin,
                                         allow_list_);
+  if (allow_list_priority ==
+      network::mojom::CorsOriginAccessMatchPriority::kNoMatchingOrigin)
+    return false;
   network::mojom::CorsOriginAccessMatchPriority block_list_priority =
       GetHighestPriorityOfRuleForOrigin(source, destination_origin,
                                         block_list_);
-
-  if (allow_list_priority ==
-      network::mojom::CorsOriginAccessMatchPriority::kNoMatchingOrigin) {
-    return block_list_priority ==
-                   network::mojom::CorsOriginAccessMatchPriority::
-                       kNoMatchingOrigin
-               ? AccessState::kNotListed
-               : AccessState::kBlocked;
-  }
-
   if (block_list_priority ==
       network::mojom::CorsOriginAccessMatchPriority::kNoMatchingOrigin)
-    return AccessState::kAllowed;
-
-  return (allow_list_priority > block_list_priority) ? AccessState::kAllowed
-                                                     : AccessState::kBlocked;
+    return true;
+  return allow_list_priority > block_list_priority;
 }
 
 std::vector<mojo::StructPtr<mojom::CorsOriginAccessPatterns>>
--- a/services/network/public/cpp/cors/origin_access_list.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/public/cpp/cors/origin_access_list.h	2019-05-17 18:53:37.904000000 +0300
@@ -30,14 +30,6 @@
  public:
   using CorsOriginPatternPtr = mojo::InlinedStructPtr<mojom::CorsOriginPattern>;
 
-  // Represents if a queried conditions are is allowed, blocked, or not listed
-  // in the access list.
-  enum class AccessState {
-    kAllowed,
-    kBlocked,
-    kNotListed,
-  };
-
   OriginAccessList();
   ~OriginAccessList();
 
@@ -83,8 +75,9 @@
   // Clears the old block list.
   void ClearBlockList();
 
-  // Returns |destination|'s AccessState in the list for |source_origin|.
-  AccessState CheckAccessState(const url::Origin& source_origin,
+  // Returns true if |destination| is in the allow list, and not in the block
+  // list of the |source_origin|.
+  bool IsAllowed(const url::Origin& source_origin,
                                const GURL& destination) const;
 
   // Creates mojom::CorsPriginAccessPatterns instance vector that represents
--- a/services/network/public/cpp/cors/origin_access_list_unittest.cc	2019-05-17 17:45:42.564000000 +0300
+++ b/services/network/public/cpp/cors/origin_access_list_unittest.cc	2019-05-17 18:53:37.904000000 +0300
@@ -33,8 +33,8 @@
         https_sub_example_origin_(
             url::Origin::Create(GURL("https://sub.example.com"))),
         http_example_origin_(url::Origin::Create(GURL("http://example.com"))),
-        https_google_origin_(url::Origin::Create(GURL("https://9oo91e.qjz9zk"))),
-        source_origin_(url::Origin::Create(GURL("https://ch40m1um.qjz9zk"))) {}
+        https_google_origin_(url::Origin::Create(GURL("https://google.com"))),
+        source_origin_(url::Origin::Create(GURL("https://chromium.org"))) {}
 
   ~OriginAccessListTest() override = default;
 
@@ -52,9 +52,7 @@
     return https_google_origin_;
   }
   bool IsAllowed(const url::Origin& destination_origin) const {
-    return list_.CheckAccessState(source_origin_,
-                                  destination_origin.GetURL()) ==
-           OriginAccessList::AccessState::kAllowed;
+    return list_.IsAllowed(source_origin_, destination_origin.GetURL());
   }
   void SetAllowListEntry(const std::string& protocol,
                          const std::string& host,
@@ -154,7 +152,7 @@
 
 TEST_F(OriginAccessListTest, IsAccessAllowedWildcardWithBlockListEntry) {
   SetAllowListEntry("https", "", kAllowSubdomains);
-  AddBlockListEntry("https", "9oo91e.qjz9zk", kDisallowSubdomains,
+  AddBlockListEntry("https", "google.com", kDisallowSubdomains,
                     mojom::CorsOriginAccessMatchPriority::kDefaultPriority);
 
   EXPECT_TRUE(IsAllowed(https_example_origin()));
@@ -198,9 +196,9 @@
 
 TEST_F(OriginAccessListTest, CreateCorsOriginAccessPatternsList) {
   const url::Origin kOrigin1 =
-      url::Origin::Create(GURL("https://foo.9oo91e.qjz9zk"));
+      url::Origin::Create(GURL("https://foo.google.com"));
   const url::Origin kOrigin2 =
-      url::Origin::Create(GURL("https://bar.9oo91e.qjz9zk"));
+      url::Origin::Create(GURL("https://bar.google.com"));
   const std::string kProtocol = "https";
   const std::string kDomain1 = "foo.example.com";
   const std::string kDomain2 = "bar.example.com";
--- a/services/network/public/cpp/cors/preflight_result_unittest.cc	2019-05-17 17:45:42.564000000 +0300
+++ b/services/network/public/cpp/cors/preflight_result_unittest.cc	2019-05-17 18:53:37.904000000 +0300
@@ -129,7 +129,7 @@
 
     // Forbidden headers can pass.
     {"GET", "", mojom::FetchCredentialsMode::kOmit, "GET",
-     "Host: www.9oo91e.qjz9zk", mojom::FetchCredentialsMode::kOmit, base::nullopt},
+     "Host: www.google.com", mojom::FetchCredentialsMode::kOmit, base::nullopt},
 
     // Not found in the preflight response and the safe list.
     {"GET", "", mojom::FetchCredentialsMode::kOmit, "GET", "X-MY-HEADER:t",
@@ -166,7 +166,7 @@
   EXPECT_EQ(base::TimeTicks(), result2->absolute_expiry_time());
 
   PreflightResult::SetTickClockForTesting(nullptr);
-}
+};
 
 TEST_F(PreflightResultTest, EnsureMethods) {
   for (const auto& test : method_cases) {
--- a/services/network/public/cpp/cors/preflight_timing_info.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/public/cpp/cors/preflight_timing_info.cc	2019-05-17 18:53:37.904000000 +0300
@@ -14,7 +14,7 @@
 PreflightTimingInfo::~PreflightTimingInfo() = default;
 
 bool PreflightTimingInfo::operator==(const PreflightTimingInfo& rhs) const {
-  return start_time == rhs.start_time && response_end == rhs.response_end &&
+  return start_time == rhs.start_time && finish_time == rhs.finish_time &&
          alpn_negotiated_protocol == rhs.alpn_negotiated_protocol &&
          connection_info == rhs.connection_info &&
          timing_allow_origin == rhs.timing_allow_origin &&
--- a/services/network/public/cpp/cors/preflight_timing_info.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/public/cpp/cors/preflight_timing_info.h	2019-05-17 18:53:37.904000000 +0300
@@ -26,7 +26,7 @@
   ~PreflightTimingInfo();
 
   base::TimeTicks start_time;
-  base::TimeTicks response_end;
+  base::TimeTicks finish_time;
   std::string alpn_negotiated_protocol;
   net::HttpResponseInfo::ConnectionInfo connection_info =
       net::HttpResponseInfo::CONNECTION_INFO_UNKNOWN;
--- a/services/network/public/cpp/cross_thread_shared_url_loader_factory_info.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/public/cpp/cross_thread_shared_url_loader_factory_info.cc	2019-05-17 18:53:37.908000000 +0300
@@ -6,13 +6,11 @@
 
 #include <utility>
 
-#include "base/bind.h"
 #include "base/callback.h"
 #include "base/sequenced_task_runner.h"
 #include "base/threading/sequenced_task_runner_handle.h"
 #include "net/traffic_annotation/network_traffic_annotation.h"
 #include "services/network/public/cpp/resource_request.h"
-#include "services/network/public/mojom/url_loader.mojom.h"
 #include "services/network/public/mojom/url_loader_factory.mojom.h"
 
 namespace network {
--- a/services/network/public/cpp/data_element.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/public/cpp/data_element.cc	2019-05-17 18:53:37.908000000 +0300
@@ -10,8 +10,6 @@
 #include <algorithm>
 
 #include "base/strings/string_number_conversions.h"
-#include "services/network/public/mojom/chunked_data_pipe_getter.mojom.h"
-#include "services/network/public/mojom/data_pipe_getter.mojom.h"
 
 namespace network {
 
--- a/services/network/public/cpp/data_element.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/public/cpp/data_element.h	2019-05-17 18:53:37.908000000 +0300
@@ -20,10 +20,9 @@
 #include "base/gtest_prod_util.h"
 #include "base/logging.h"
 #include "base/time/time.h"
-#include "mojo/public/cpp/bindings/enum_traits.h"
 #include "mojo/public/cpp/system/data_pipe.h"
-#include "services/network/public/mojom/chunked_data_pipe_getter.mojom-forward.h"
-#include "services/network/public/mojom/data_pipe_getter.mojom-forward.h"
+#include "services/network/public/mojom/chunked_data_pipe_getter.mojom.h"
+#include "services/network/public/mojom/data_pipe_getter.mojom.h"
 #include "services/network/public/mojom/url_loader.mojom-shared.h"
 #include "url/gurl.h"
 
@@ -172,13 +171,9 @@
  private:
   FRIEND_TEST_ALL_PREFIXES(BlobAsyncTransportStrategyTest, TestInvalidParams);
   friend void PrintTo(const DataElement& x, ::std::ostream* os);
-  friend struct mojo::StructTraits<network::mojom::DataElementDataView,
-                                   network::DataElement>;
   mojom::DataElementType type_;
-  // TODO(Richard): Use uint8_t instead of char to align with mojom type
   // For TYPE_BYTES.
   std::vector<char> buf_;
-  // TODO(Richard): Use uint8_t instead of char to align with mojom type
   // For TYPE_BYTES.
   const char* bytes_;
   // For TYPE_FILE and TYPE_RAW_FILE.
--- a/services/network/public/cpp/features.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/public/cpp/features.cc	2019-05-17 18:53:37.908000000 +0300
@@ -4,8 +4,6 @@
 
 #include "services/network/public/cpp/features.h"
 
-#include "build/build_config.h"
-
 namespace network {
 namespace features {
 
@@ -17,16 +15,8 @@
 const base::Feature kNetworkErrorLogging{"NetworkErrorLogging",
                                          base::FEATURE_ENABLED_BY_DEFAULT};
 // Enables the network service.
-const base::Feature kNetworkService {
-  "NetworkService",
-#if defined(OS_WIN) || defined(OS_MACOSX) || \
-    (defined(OS_LINUX) && !defined(IS_CHROMECAST))
-      base::FEATURE_ENABLED_BY_DEFAULT
-};
-#else
-      base::FEATURE_DISABLED_BY_DEFAULT
-};
-#endif
+const base::Feature kNetworkService{"NetworkService",
+                                    base::FEATURE_DISABLED_BY_DEFAULT};
 
 // Out of Blink CORS
 const base::Feature kOutOfBlinkCors{"OutOfBlinkCors",
@@ -52,6 +42,14 @@
 const base::Feature kDelayRequestsOnMultiplexedConnections{
     "DelayRequestsOnMultiplexedConnections", base::FEATURE_ENABLED_BY_DEFAULT};
 
+// When kUnthrottleRequestsAfterLongQueuingDelay is enabled, an upper bound
+// is placed on how long the resource scheduler can queue any given request.
+// Once a request is queued for more than the specified duration, the request
+// is dispatched to the network.
+const base::Feature kUnthrottleRequestsAfterLongQueuingDelay{
+    "UnthrottleRequestsAfterLongQueuingDelay",
+    base::FEATURE_DISABLED_BY_DEFAULT};
+
 // Kill switch for enforcing
 // URLLoaderFactoryParams::request_initiator_origin_lock for Cross-Origin Read
 // Blocking.  When enabled, then CORB treats |request_initiator| as opaque
@@ -59,13 +57,5 @@
 const base::Feature kEnforceRequestInitiatorLockForCorb{
     "EnforceRequestInitiatorLockForCorb", base::FEATURE_ENABLED_BY_DEFAULT};
 
-bool ShouldEnableOutOfBlinkCors() {
-  // OOR-CORS requires NetworkService.
-  if (!base::FeatureList::IsEnabled(features::kNetworkService))
-    return false;
-
-  return base::FeatureList::IsEnabled(features::kOutOfBlinkCors);
-}
-
 }  // namespace features
 }  // namespace network
--- a/services/network/public/cpp/features.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/public/cpp/features.h	2019-05-17 18:53:37.908000000 +0300
@@ -26,10 +26,10 @@
 COMPONENT_EXPORT(NETWORK_CPP)
 extern const base::Feature kDelayRequestsOnMultiplexedConnections;
 COMPONENT_EXPORT(NETWORK_CPP)
+extern const base::Feature kUnthrottleRequestsAfterLongQueuingDelay;
+COMPONENT_EXPORT(NETWORK_CPP)
 extern const base::Feature kEnforceRequestInitiatorLockForCorb;
 
-COMPONENT_EXPORT(NETWORK_CPP) bool ShouldEnableOutOfBlinkCors();
-
 }  // namespace features
 }  // namespace network
 
--- a/services/network/public/cpp/host_resolver_mojom_traits.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/public/cpp/host_resolver_mojom_traits.cc	2019-05-17 18:53:37.908000000 +0300
@@ -274,8 +274,6 @@
       return ResolveHostParameters::Source::DNS;
     case net::HostResolverSource::MULTICAST_DNS:
       return ResolveHostParameters::Source::MULTICAST_DNS;
-    case net::HostResolverSource::LOCAL_ONLY:
-      return ResolveHostParameters::Source::LOCAL_ONLY;
   }
 }
 
@@ -296,9 +294,6 @@
     case ResolveHostParameters::Source::MULTICAST_DNS:
       *output = net::HostResolverSource::MULTICAST_DNS;
       return true;
-    case ResolveHostParameters::Source::LOCAL_ONLY:
-      *output = net::HostResolverSource::LOCAL_ONLY;
-      return true;
   }
 }
 
--- a/services/network/public/cpp/net_ipc_param_traits.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/public/cpp/net_ipc_param_traits.cc	2019-05-17 18:53:37.912000000 +0300
@@ -164,50 +164,6 @@
   l->append(p.ToString());
 }
 
-void ParamTraits<net::IPEndPoint>::Write(base::Pickle* m, const param_type& p) {
-  WriteParam(m, p.address());
-  WriteParam(m, p.port());
-}
-
-bool ParamTraits<net::IPEndPoint>::Read(const base::Pickle* m,
-                                        base::PickleIterator* iter,
-                                        param_type* p) {
-  net::IPAddress address;
-  uint16_t port;
-  if (!ReadParam(m, iter, &address) || !ReadParam(m, iter, &port))
-    return false;
-
-  *p = net::IPEndPoint(address, port);
-  return true;
-}
-
-void ParamTraits<net::IPEndPoint>::Log(const param_type& p, std::string* l) {
-  LogParam("IPEndPoint:" + p.ToString(), l);
-}
-
-void ParamTraits<net::IPAddress>::Write(base::Pickle* m, const param_type& p) {
-  base::StackVector<uint8_t, 16> bytes;
-  for (uint8_t byte : p.bytes())
-    bytes->push_back(byte);
-  WriteParam(m, bytes);
-}
-
-bool ParamTraits<net::IPAddress>::Read(const base::Pickle* m,
-                                       base::PickleIterator* iter,
-                                       param_type* p) {
-  base::StackVector<uint8_t, 16> bytes;
-  if (!ReadParam(m, iter, &bytes))
-    return false;
-  if (bytes->size() > 16)
-    return false;
-  *p = net::IPAddress(bytes->data(), bytes->size());
-  return true;
-}
-
-void ParamTraits<net::IPAddress>::Log(const param_type& p, std::string* l) {
-  LogParam("IPAddress:" + (p.empty() ? "(empty)" : p.ToString()), l);
-}
-
 void ParamTraits<net::HttpRequestHeaders>::Write(base::Pickle* m,
                                                  const param_type& p) {
   WriteParam(m, static_cast<int>(p.GetHeaderVector().size()));
--- a/services/network/public/cpp/net_ipc_param_traits.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/public/cpp/net_ipc_param_traits.h	2019-05-17 18:53:37.912000000 +0300
@@ -13,8 +13,6 @@
 #include "ipc/param_traits_macros.h"
 #include "net/base/auth.h"
 #include "net/base/host_port_pair.h"
-#include "net/base/ip_address.h"
-#include "net/base/ip_endpoint.h"
 #include "net/base/proxy_server.h"
 #include "net/base/request_priority.h"
 #include "net/cert/cert_verify_result.h"
@@ -106,26 +104,6 @@
 };
 
 template <>
-struct COMPONENT_EXPORT(NETWORK_CPP_BASE) ParamTraits<net::IPEndPoint> {
-  typedef net::IPEndPoint param_type;
-  static void Write(base::Pickle* m, const param_type& p);
-  static bool Read(const base::Pickle* m,
-                   base::PickleIterator* iter,
-                   param_type* p);
-  static void Log(const param_type& p, std::string* l);
-};
-
-template <>
-struct COMPONENT_EXPORT(NETWORK_CPP_BASE) ParamTraits<net::IPAddress> {
-  typedef net::IPAddress param_type;
-  static void Write(base::Pickle* m, const param_type& p);
-  static bool Read(const base::Pickle* m,
-                   base::PickleIterator* iter,
-                   param_type* p);
-  static void Log(const param_type& p, std::string* l);
-};
-
-template <>
 struct COMPONENT_EXPORT(NETWORK_CPP_BASE) ParamTraits<net::HttpRequestHeaders> {
   typedef net::HttpRequestHeaders param_type;
   static void Write(base::Pickle* m, const param_type& p);
@@ -237,7 +215,7 @@
     net::ct::CTPolicyCompliance,
     net::ct::CTPolicyCompliance::CT_POLICY_COMPLIANCE_DETAILS_NOT_AVAILABLE)
 
-IPC_ENUM_TRAITS(net::ProxyServer::Scheme)  // BitMask.
+IPC_ENUM_TRAITS(net::ProxyServer::Scheme);  // BitMask.
 
 IPC_ENUM_TRAITS_MAX_VALUE(net::OCSPVerifyResult::ResponseStatus,
                           net::OCSPVerifyResult::PARSE_RESPONSE_DATA_ERROR)
--- a/services/network/public/cpp/network_connection_tracker.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/public/cpp/network_connection_tracker.cc	2019-05-17 18:53:37.912000000 +0300
@@ -6,7 +6,6 @@
 
 #include <utility>
 
-#include "base/bind.h"
 #include "base/task_runner.h"
 #include "base/threading/thread_task_runner_handle.h"
 #include "services/network/public/mojom/network_change_manager.mojom.h"
--- a/services/network/public/cpp/network_connection_tracker_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/public/cpp/network_connection_tracker_unittest.cc	2019-05-17 18:53:37.912000000 +0300
@@ -4,8 +4,6 @@
 
 #include "services/network/public/cpp/network_connection_tracker.h"
 
-#include "base/bind.h"
-#include "base/bind_helpers.h"
 #include "base/macros.h"
 #include "base/run_loop.h"
 #include "base/test/scoped_task_environment.h"
--- a/services/network/public/cpp/network_ipc_param_traits.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/public/cpp/network_ipc_param_traits.cc	2019-05-17 18:53:37.912000000 +0300
@@ -9,8 +9,6 @@
 #include "ipc/ipc_platform_file.h"
 #include "net/http/http_util.h"
 #include "services/network/public/cpp/http_raw_request_response_info.h"
-#include "services/network/public/mojom/chunked_data_pipe_getter.mojom.h"
-#include "services/network/public/mojom/data_pipe_getter.mojom.h"
 #include "services/network/public/mojom/url_loader.mojom-shared.h"
 
 namespace IPC {
--- a/services/network/public/cpp/network_ipc_param_traits.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/public/cpp/network_ipc_param_traits.h	2019-05-17 18:53:37.912000000 +0300
@@ -12,7 +12,7 @@
 #include "ipc/ipc_param_traits.h"
 #include "ipc/param_traits_macros.h"
 #include "net/base/auth.h"
-#include "net/base/ip_endpoint.h"
+#include "net/base/host_port_pair.h"
 #include "net/base/proxy_server.h"
 #include "net/base/request_priority.h"
 #include "net/cert/cert_verify_result.h"
@@ -63,8 +63,6 @@
   static void Log(const param_type& p, std::string* l);
 };
 
-// TODO(Richard): Remove this traits after usage of FrameHostMsg_OpenURL_Params
-// disappears.
 template <>
 struct COMPONENT_EXPORT(NETWORK_CPP_BASE) ParamTraits<network::DataElement> {
   typedef network::DataElement param_type;
@@ -75,8 +73,6 @@
   static void Log(const param_type& p, std::string* l);
 };
 
-// TODO(Richard): Remove this traits after usage of FrameHostMsg_OpenURL_Params
-// disappears.
 template <>
 struct COMPONENT_EXPORT(NETWORK_CPP_BASE)
     ParamTraits<scoped_refptr<network::ResourceRequestBody>> {
@@ -117,7 +113,7 @@
 
 IPC_STRUCT_TRAITS_BEGIN(network::cors::PreflightTimingInfo)
   IPC_STRUCT_TRAITS_MEMBER(start_time)
-  IPC_STRUCT_TRAITS_MEMBER(response_end)
+  IPC_STRUCT_TRAITS_MEMBER(finish_time)
   IPC_STRUCT_TRAITS_MEMBER(alpn_negotiated_protocol)
   IPC_STRUCT_TRAITS_MEMBER(connection_info)
   IPC_STRUCT_TRAITS_MEMBER(timing_allow_origin)
@@ -146,6 +142,7 @@
   IPC_STRUCT_TRAITS_MEMBER(mime_type)
   IPC_STRUCT_TRAITS_MEMBER(charset)
   IPC_STRUCT_TRAITS_MEMBER(ct_policy_compliance)
+  IPC_STRUCT_TRAITS_MEMBER(is_legacy_symantec_cert)
   IPC_STRUCT_TRAITS_MEMBER(content_length)
   IPC_STRUCT_TRAITS_MEMBER(network_accessed)
   IPC_STRUCT_TRAITS_MEMBER(encoded_data_length)
@@ -159,7 +156,7 @@
   IPC_STRUCT_TRAITS_MEMBER(was_alternate_protocol_available)
   IPC_STRUCT_TRAITS_MEMBER(connection_info)
   IPC_STRUCT_TRAITS_MEMBER(alpn_negotiated_protocol)
-  IPC_STRUCT_TRAITS_MEMBER(remote_endpoint)
+  IPC_STRUCT_TRAITS_MEMBER(socket_address)
   IPC_STRUCT_TRAITS_MEMBER(was_fetched_via_cache)
   IPC_STRUCT_TRAITS_MEMBER(proxy_server)
   IPC_STRUCT_TRAITS_MEMBER(was_fetched_via_service_worker)
--- a/services/network/public/cpp/network_quality_tracker.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/public/cpp/network_quality_tracker.cc	2019-05-17 18:53:37.912000000 +0300
@@ -7,9 +7,7 @@
 #include <limits>
 #include <utility>
 
-#include "base/bind.h"
 #include "base/logging.h"
-#include "services/network/public/mojom/network_service.mojom.h"
 
 namespace network {
 
--- a/services/network/public/cpp/network_quality_tracker.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/public/cpp/network_quality_tracker.h	2019-05-17 18:53:37.912000000 +0300
@@ -16,7 +16,7 @@
 #include "mojo/public/cpp/bindings/binding_set.h"
 #include "net/nqe/effective_connection_type.h"
 #include "services/network/public/mojom/network_quality_estimator_manager.mojom.h"
-#include "services/network/public/mojom/network_service.mojom-forward.h"
+#include "services/network/public/mojom/network_service.mojom.h"
 
 namespace network {
 
--- a/services/network/public/cpp/network_quality_tracker_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/public/cpp/network_quality_tracker_unittest.cc	2019-05-17 18:53:37.912000000 +0300
@@ -6,7 +6,6 @@
 
 #include <limits>
 
-#include "base/bind.h"
 #include "base/macros.h"
 #include "base/run_loop.h"
 #include "base/test/scoped_task_environment.h"
--- a/services/network/public/cpp/network_switches.cc	2019-05-17 17:45:42.564000000 +0300
+++ b/services/network/public/cpp/network_switches.cc	2019-05-17 18:53:37.912000000 +0300
@@ -42,7 +42,7 @@
 
 // Causes SSL key material to be logged to the specified file for debugging
 // purposes. See
-// https://developer.m0z111a.qjz9zk/en-US/docs/Mozilla/Projects/NSS/Key_Log_Format
+// https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/Key_Log_Format
 // for the format.
 const char kSSLKeyLogFile[] = "ssl-key-log-file";
 
--- a/services/network/public/cpp/OWNERS	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/public/cpp/OWNERS	2019-05-17 18:53:37.904000000 +0300
@@ -6,7 +6,3 @@
 per-file *_mojom_traits*.*=file://ipc/SECURITY_OWNERS
 per-file *.typemap=set noparent
 per-file *.typemap=file://ipc/SECURITY_OWNERS
-per-file manifest.cc=set noparent
-per-file manifest.cc=file://ipc/SECURITY_OWNERS
-per-file manifest.h=set noparent
-per-file manifest.h=file://ipc/SECURITY_OWNERS
--- a/services/network/public/cpp/p2p_param_traits.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/public/cpp/p2p_param_traits.cc	2019-05-17 18:53:37.912000000 +0300
@@ -5,7 +5,60 @@
 #include "services/network/public/cpp/p2p_param_traits.h"
 
 #include "ipc/ipc_message_utils.h"
-#include "services/network/public/cpp/net_ipc_param_traits.h"
+#include "net/base/ip_address.h"
+#include "net/base/ip_endpoint.h"
+
+namespace IPC {
+
+void ParamTraits<net::IPEndPoint>::Write(base::Pickle* m, const param_type& p) {
+  WriteParam(m, p.address());
+  WriteParam(m, p.port());
+}
+
+bool ParamTraits<net::IPEndPoint>::Read(const base::Pickle* m,
+                                        base::PickleIterator* iter,
+                                        param_type* p) {
+  net::IPAddress address;
+  uint16_t port;
+  if (!ReadParam(m, iter, &address) || !ReadParam(m, iter, &port))
+    return false;
+  if (!address.empty() && !address.IsValid())
+    return false;
+
+  *p = net::IPEndPoint(address, port);
+  return true;
+}
+
+void ParamTraits<net::IPEndPoint>::Log(const param_type& p, std::string* l) {
+  LogParam("IPEndPoint:" + p.ToString(), l);
+}
+
+void ParamTraits<net::IPAddress>::Write(base::Pickle* m, const param_type& p) {
+  base::StackVector<uint8_t, 16> bytes;
+  for (uint8_t byte : p.bytes())
+    bytes->push_back(byte);
+  WriteParam(m, bytes);
+}
+
+bool ParamTraits<net::IPAddress>::Read(const base::Pickle* m,
+                                       base::PickleIterator* iter,
+                                       param_type* p) {
+  base::StackVector<uint8_t, 16> bytes;
+  if (!ReadParam(m, iter, &bytes))
+    return false;
+  if (bytes->size() && bytes->size() != net::IPAddress::kIPv4AddressSize &&
+      bytes->size() != net::IPAddress::kIPv6AddressSize) {
+    return false;
+  }
+  *p = net::IPAddress(bytes->data(), bytes->size());
+  return true;
+}
+
+void ParamTraits<net::IPAddress>::Log(const param_type& p, std::string* l) {
+  LogParam("IPAddress:" + (p.empty() ? "(empty)" : p.ToString()), l);
+}
+
+}  // namespace IPC
 
 // Generation of IPC definitions.
 
--- a/services/network/public/cpp/p2p_param_traits.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/public/cpp/p2p_param_traits.h	2019-05-17 18:53:37.912000000 +0300
@@ -25,6 +25,35 @@
 #undef IPC_MESSAGE_EXPORT
 #define IPC_MESSAGE_EXPORT COMPONENT_EXPORT(NETWORK_CPP_BASE)
 
+namespace net {
+class IPAddress;
+class IPEndPoint;
+}  // namespace net
+
+namespace IPC {
+
+template <>
+struct COMPONENT_EXPORT(NETWORK_CPP_BASE) ParamTraits<net::IPEndPoint> {
+  typedef net::IPEndPoint param_type;
+  static void Write(base::Pickle* m, const param_type& p);
+  static bool Read(const base::Pickle* m,
+                   base::PickleIterator* iter,
+                   param_type* p);
+  static void Log(const param_type& p, std::string* l);
+};
+
+template <>
+struct COMPONENT_EXPORT(NETWORK_CPP_BASE) ParamTraits<net::IPAddress> {
+  typedef net::IPAddress param_type;
+  static void Write(base::Pickle* m, const param_type& p);
+  static bool Read(const base::Pickle* m,
+                   base::PickleIterator* iter,
+                   param_type* p);
+  static void Log(const param_type& p, std::string* l);
+};
+
+}  // namespace IPC
+
 #endif  // INTERNAL_SERVICES_NETWORK_PUBLIC_CPP_P2P_PARAM_TRAITS_H_
 
 IPC_ENUM_TRAITS_MAX_VALUE(network::P2PSocketType, network::P2P_SOCKET_TYPE_LAST)
--- a/services/network/public/cpp/resource_request_body.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/public/cpp/resource_request_body.cc	2019-05-17 18:53:37.916000000 +0300
@@ -4,9 +4,6 @@
 
 #include "services/network/public/cpp/resource_request_body.h"
 
-#include "services/network/public/mojom/chunked_data_pipe_getter.mojom.h"
-#include "services/network/public/mojom/data_pipe_getter.mojom.h"
-
 namespace network {
 
 ResourceRequestBody::ResourceRequestBody()
--- a/services/network/public/cpp/resource_response.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/public/cpp/resource_response.cc	2019-05-17 18:53:37.916000000 +0300
@@ -19,6 +19,7 @@
   new_response->head.mime_type = head.mime_type;
   new_response->head.charset = head.charset;
   new_response->head.ct_policy_compliance = head.ct_policy_compliance;
+  new_response->head.is_legacy_symantec_cert = head.is_legacy_symantec_cert;
   new_response->head.content_length = head.content_length;
   new_response->head.network_accessed = head.network_accessed;
   new_response->head.encoded_data_length = head.encoded_data_length;
@@ -36,7 +37,7 @@
       head.was_alternate_protocol_available;
   new_response->head.connection_info = head.connection_info;
   new_response->head.alpn_negotiated_protocol = head.alpn_negotiated_protocol;
-  new_response->head.remote_endpoint = head.remote_endpoint;
+  new_response->head.socket_address = head.socket_address;
   new_response->head.was_fetched_via_cache = head.was_fetched_via_cache;
   new_response->head.proxy_server = head.proxy_server;
   new_response->head.was_fetched_via_service_worker =
--- a/services/network/public/cpp/resource_response.h	2019-05-17 17:45:42.564000000 +0300
+++ b/services/network/public/cpp/resource_response.h	2019-05-17 18:53:37.916000000 +0300
@@ -3,7 +3,7 @@
 // found in the LICENSE file.
 
 // See
-// http://dev.ch40m1um.qjz9zk/developers/design-documents/multi-process-resource-loading
+// http://dev.chromium.org/developers/design-documents/multi-process-resource-loading
 
 #ifndef SERVICES_NETWORK_PUBLIC_CPP_RESOURCE_RESPONSE_H_
 #define SERVICES_NETWORK_PUBLIC_CPP_RESOURCE_RESPONSE_H_
--- a/services/network/public/cpp/resource_response_info.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/public/cpp/resource_response_info.cc	2019-05-17 18:53:37.916000000 +0300
@@ -11,6 +11,7 @@
 ResourceResponseInfo::ResourceResponseInfo()
     : ct_policy_compliance(net::ct::CTPolicyCompliance::
                                CT_POLICY_COMPLIANCE_DETAILS_NOT_AVAILABLE),
+      is_legacy_symantec_cert(false),
       content_length(-1),
       encoded_data_length(-1),
       encoded_body_length(-1),
--- a/services/network/public/cpp/resource_response_info.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/public/cpp/resource_response_info.h	2019-05-17 18:53:37.916000000 +0300
@@ -13,7 +13,7 @@
 #include "base/files/file_path.h"
 #include "base/memory/ref_counted.h"
 #include "base/time/time.h"
-#include "net/base/ip_endpoint.h"
+#include "net/base/host_port_pair.h"
 #include "net/base/load_timing_info.h"
 #include "net/base/proxy_server.h"
 #include "net/cert/ct_policy_status.h"
@@ -55,6 +55,10 @@
   // The resource's compliance with the Certificate Transparency policy.
   net::ct::CTPolicyCompliance ct_policy_compliance;
 
+  // True if the resource was loaded with an otherwise-valid legacy Symantec
+  // certificate which will be distrusted in future.
+  bool is_legacy_symantec_cert;
+
   // Content length if available. -1 if not available
   int64_t content_length;
 
@@ -103,7 +107,7 @@
   std::string alpn_negotiated_protocol;
 
   // Remote address of the socket which fetched this resource.
-  net::IPEndPoint remote_endpoint;
+  net::HostPortPair socket_address;
 
   // True if the response came from cache.
   bool was_fetched_via_cache = false;
--- a/services/network/public/cpp/server/http_server_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/public/cpp/server/http_server_unittest.cc	2019-05-17 18:53:37.916000000 +0300
@@ -130,9 +130,9 @@
  private:
   bool IsCompleteResponse(const std::string& response) {
     // Check end of headers first.
-    size_t end_of_headers =
+    int end_of_headers =
         net::HttpUtil::LocateEndOfHeaders(response.data(), response.size());
-    if (end_of_headers == std::string::npos)
+    if (end_of_headers < 0)
       return false;
 
     // Return true if response has data equal to or more than content length.
--- a/services/network/public/cpp/simple_url_loader_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/public/cpp/simple_url_loader_unittest.cc	2019-05-17 18:53:37.920000000 +0300
@@ -2787,7 +2787,7 @@
   EXPECT_EQ(url, test_helper->simple_url_loader()->GetFinalURL());
 }
 
-INSTANTIATE_TEST_SUITE_P(
+INSTANTIATE_TEST_CASE_P(
     /* No prefix */,
     SimpleURLLoaderTest,
     testing::Values(SimpleLoaderTestHelper::DownloadType::TO_STRING,
--- a/services/network/public/cpp/url_request_mojom_traits.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/public/cpp/url_request_mojom_traits.cc	2019-05-17 18:53:37.920000000 +0300
@@ -4,17 +4,11 @@
 
 #include "services/network/public/cpp/url_request_mojom_traits.h"
 
-#include <vector>
-
 #include "base/logging.h"
-#include "mojo/public/cpp/base/file_mojom_traits.h"
-#include "mojo/public/cpp/base/file_path_mojom_traits.h"
-#include "mojo/public/cpp/base/time_mojom_traits.h"
 #include "mojo/public/cpp/base/unguessable_token_mojom_traits.h"
 #include "services/network/public/cpp/http_request_headers_mojom_traits.h"
 #include "services/network/public/cpp/network_ipc_param_traits.h"
 #include "services/network/public/cpp/resource_request_body.h"
-#include "services/network/public/mojom/chunked_data_pipe_getter.mojom.h"
 #include "services/network/public/mojom/url_loader.mojom-shared.h"
 #include "url/mojom/origin_mojom_traits.h"
 #include "url/mojom/url_gurl_mojom_traits.h"
@@ -228,29 +222,4 @@
   return true;
 }
 
-bool StructTraits<network::mojom::DataElementDataView, network::DataElement>::
-    Read(network::mojom::DataElementDataView data, network::DataElement* out) {
-  if (!data.ReadPath(&out->path_) || !data.ReadFile(&out->file_) ||
-      !data.ReadBlobUuid(&out->blob_uuid_) ||
-      !data.ReadExpectedModificationTime(&out->expected_modification_time_)) {
-    return false;
-  }
-  // TODO(Richard): Fix this workaround once |buf_| becomes vector<uint8_t>
-  if (data.type() == network::mojom::DataElementType::kBytes) {
-    out->buf_.resize(data.length());
-    auto buf = base::make_span(reinterpret_cast<uint8_t*>(out->buf_.data()),
-                               out->buf_.size());
-    if (!data.ReadBuf(&buf))
-      return false;
-  }
-  out->type_ = data.type();
-  out->data_pipe_getter_ =
-      data.TakeDataPipeGetter<network::mojom::DataPipeGetterPtrInfo>();
-  out->chunked_data_pipe_getter_ = data.TakeChunkedDataPipeGetter<
-      network::mojom::ChunkedDataPipeGetterPtrInfo>();
-  out->offset_ = data.offset();
-  out->length_ = data.length();
-  return true;
-}
-
 }  // namespace mojo
--- a/services/network/public/cpp/url_request_mojom_traits.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/public/cpp/url_request_mojom_traits.h	2019-05-17 18:53:37.920000000 +0300
@@ -5,22 +5,13 @@
 #ifndef SERVICES_NETWORK_PUBLIC_CPP_URL_REQUEST_MOJOM_TRAITS_H_
 #define SERVICES_NETWORK_PUBLIC_CPP_URL_REQUEST_MOJOM_TRAITS_H_
 
-#include <string>
-#include <utility>
-
 #include "base/component_export.h"
 #include "base/memory/scoped_refptr.h"
-#include "mojo/public/cpp/base/file_mojom_traits.h"
-#include "mojo/public/cpp/base/file_path_mojom_traits.h"
-#include "mojo/public/cpp/base/time_mojom_traits.h"
 #include "mojo/public/cpp/bindings/enum_traits.h"
 #include "mojo/public/cpp/bindings/struct_traits.h"
 #include "net/base/request_priority.h"
-#include "services/network/public/cpp/data_element.h"
 #include "services/network/public/cpp/resource_request.h"
 #include "services/network/public/cpp/resource_request_body.h"
-#include "services/network/public/mojom/chunked_data_pipe_getter.mojom-shared.h"
-#include "services/network/public/mojom/data_pipe_getter.mojom.h"
 #include "services/network/public/mojom/url_loader.mojom-shared.h"
 
 namespace mojo {
@@ -260,59 +251,6 @@
                    scoped_refptr<network::ResourceRequestBody>* out);
 };
 
-template <>
-struct COMPONENT_EXPORT(NETWORK_CPP_BASE)
-    StructTraits<network::mojom::DataElementDataView, network::DataElement> {
-  static const network::mojom::DataElementType& type(
-      const network::DataElement& element) {
-    return element.type_;
-  }
-  static base::span<const uint8_t> buf(const network::DataElement& element) {
-    if (element.bytes_) {
-      return base::make_span(reinterpret_cast<const uint8_t*>(element.bytes_),
-                             element.length_);
-    }
-    return base::make_span(
-        reinterpret_cast<const uint8_t*>(element.buf_.data()),
-        element.buf_.size());
-  }
-  static const base::FilePath& path(const network::DataElement& element) {
-    return element.path_;
-  }
-  static base::File file(const network::DataElement& element) {
-    return std::move(const_cast<network::DataElement&>(element).file_);
-  }
-  static const std::string& blob_uuid(const network::DataElement& element) {
-    return element.blob_uuid_;
-  }
-  static network::mojom::DataPipeGetterPtrInfo data_pipe_getter(
-      const network::DataElement& element) {
-    if (element.type_ != network::mojom::DataElementType::kDataPipe)
-      return nullptr;
-    return element.CloneDataPipeGetter().PassInterface();
-  }
-  static network::mojom::ChunkedDataPipeGetterPtrInfo chunked_data_pipe_getter(
-      const network::DataElement& element) {
-    if (element.type_ != network::mojom::DataElementType::kChunkedDataPipe)
-      return nullptr;
-    return const_cast<network::DataElement&>(element)
-        .ReleaseChunkedDataPipeGetter();
-  }
-  static uint64_t offset(const network::DataElement& element) {
-    return element.offset_;
-  }
-  static uint64_t length(const network::DataElement& element) {
-    return element.length_;
-  }
-  static const base::Time& expected_modification_time(
-      const network::DataElement& element) {
-    return element.expected_modification_time_;
-  }
-
-  static bool Read(network::mojom::DataElementDataView data,
-                   network::DataElement* out);
-};
-
 }  // namespace mojo
 
 #endif  // SERVICES_NETWORK_PUBLIC_CPP_URL_REQUEST_MOJOM_TRAITS_H_
--- a/services/network/public/cpp/url_request.typemap	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/public/cpp/url_request.typemap	2019-05-17 18:53:37.920000000 +0300
@@ -5,7 +5,6 @@
 mojom = "//services/network/public/mojom/url_loader.mojom"
 public_headers = [
   "//base/memory/scoped_refptr.h",
-  "//services/network/public/cpp/data_element.h",
   "//services/network/public/cpp/resource_request.h",
   "//services/network/public/cpp/resource_request_body.h",
 ]
--- a/services/network/public/cpp/weak_wrapper_shared_url_loader_factory.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/public/cpp/weak_wrapper_shared_url_loader_factory.h	2019-05-17 18:53:37.920000000 +0300
@@ -8,7 +8,7 @@
 #include "base/callback.h"
 #include "base/component_export.h"
 #include "services/network/public/cpp/shared_url_loader_factory.h"
-#include "services/network/public/mojom/url_loader_factory.mojom-forward.h"
+#include "services/network/public/mojom/url_loader_factory.mojom.h"
 
 namespace network {
 
--- a/services/network/public/cpp/wrapper_shared_url_loader_factory.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/public/cpp/wrapper_shared_url_loader_factory.h	2019-05-17 18:53:37.920000000 +0300
@@ -7,7 +7,6 @@
 
 #include "base/component_export.h"
 #include "services/network/public/cpp/shared_url_loader_factory.h"
-#include "services/network/public/mojom/url_loader.mojom.h"
 #include "services/network/public/mojom/url_loader_factory.mojom.h"
 
 namespace network {
--- a/services/network/public/mojom/BUILD.gn	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/public/mojom/BUILD.gn	2019-05-17 18:53:37.920000000 +0300
@@ -3,7 +3,6 @@
 # found in the LICENSE file.
 
 import("//mojo/public/tools/bindings/mojom.gni")
-import("//net/features.gni")
 import("//services/network/public/cpp/features.gni")
 
 # These interfaces are put in their own target to avoid a circular dependency,
@@ -58,7 +57,6 @@
   ]
 
   public_deps = [
-    ":mojom_ip_address",
     "//url/mojom:url_mojom_gurl",
     "//url/mojom:url_mojom_origin",
   ]
@@ -147,9 +145,4 @@
   if (is_android || is_chromeos) {
     enabled_features += [ "network_change_notifier_in_browser" ]
   }
-
-  if (trial_comparison_cert_verifier_supported) {
-    enabled_features += [ "is_trial_comparison_cert_verifier_supported" ]
-    sources += [ "trial_comparison_cert_verifier.mojom" ]
-  }
 }
--- a/services/network/public/mojom/cookie_manager.mojom	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/public/mojom/cookie_manager.mojom	2019-05-17 18:53:37.920000000 +0300
@@ -181,13 +181,12 @@
   GetCookieList(url.mojom.Url url, CookieOptions cookie_options) =>
       (array<CanonicalCookie> cookies);
 
-  // Set a cookie.  |source_scheme| is used to check whether existing secure
+  // Set a cookie.  |secure_source| indicates whether existing secure
   // cookies can be overwritten (secure cookies may be created from a
-  // non-secure source), and whether the scheme is permitted to use cookies in
-  // the first place.  |modify_http_only| indicates whether http_only
+  // non-secure source).  |modify_http_only| indicates whether http_only
   // cookies may be overwritten.
   SetCanonicalCookie(
-      CanonicalCookie cookie, string source_scheme, bool modify_http_only) =>
+      CanonicalCookie cookie, bool secure_source, bool modify_http_only) =>
       (bool success);
 
   // Delete a cookie. Returns true if a cookie was deleted.
--- a/services/network/public/mojom/host_resolver.mojom	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/public/mojom/host_resolver.mojom	2019-05-17 18:53:37.920000000 +0300
@@ -156,11 +156,6 @@
 
     // Results will only come from Multicast DNS queries.
     MULTICAST_DNS,
-
-    // No external sources will be used. Results will only come from fast local
-    // sources that are available no matter the source setting, e.g. cache,
-    // hosts file, IP literal resolution, etc.
-    LOCAL_ONLY,
   };
 
   // The source to use for resolved addresses. Default allows the resolver to
@@ -240,6 +235,9 @@
   // All outstanding requests are cancelled if the HostResolver or parent
   // NetworkContext are destroyed. Such requests will receive ERR_FAILED via
   // |response_client|.
+  //
+  // TODO(crbug.com/821021): Implement more complex functionality to meet full
+  // capabilities of Resolve() and DnsClient/MDnsClient functionality.
   ResolveHost(HostPortPair host,
               ResolveHostParameters? optional_parameters,
               ResolveHostClient response_client);
--- a/services/network/public/mojom/network_context.mojom	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/public/mojom/network_context.mojom	2019-05-17 18:53:37.920000000 +0300
@@ -13,7 +13,6 @@
 import "services/network/public/mojom/cors_origin_pattern.mojom";
 import "services/network/public/mojom/host_resolver.mojom";
 import "services/network/public/mojom/http_request_headers.mojom";
-import "services/network/public/mojom/ip_address.mojom";
 import "services/network/public/mojom/ip_endpoint.mojom";
 import "services/network/public/mojom/mdns_responder.mojom";
 import "services/network/public/mojom/mutable_network_traffic_annotation_tag.mojom";
@@ -39,9 +38,6 @@
 [EnableIf=is_ct_supported]
 import "services/network/public/mojom/ct_log_info.mojom";
 
-[EnableIf=is_trial_comparison_cert_verifier_supported]
-import "services/network/public/mojom/trial_comparison_cert_verifier.mojom";
-
 // Config for setting a custom proxy config that will be used if a request
 // matches the proxy rules and would otherwise be direct. This config allows
 // headers to be set on requests to the proxies from the config before and/or
@@ -55,11 +51,6 @@
   // ResourceRequest::custom_proxy_use_alternate_proxy_list is set.
   ProxyList alternate_proxy_list;
 
-  // Whether the custom proxy config should apply to requests using
-  // non-idempotent methods. Can be true if the proxy is known to handle this
-  // case properly.
-  bool allow_non_idempotent_methods = false;
-
   // The custom proxy can set these headers in this config which will be added
   // to all requests using the proxy. This allows setting headers that may be
   // privacy/security sensitive which we don't want to send to the renderer.
@@ -171,6 +162,10 @@
   // cookies. Otherwise it should be false.
   bool persist_session_cookies = false;
 
+  // Points to the channel ID file. If a cookie file is specified, this must be
+  // specified as well. Otherwise an in-memory store is used.
+  mojo_base.mojom.FilePath? channel_id_path;
+
   // True if an HTTP cache should be used.
   bool http_cache_enabled = true;
   // Maximum size of the HTTP cache. 0 means to use the default size.
@@ -202,12 +197,6 @@
   // Must be false if built without FTP support.
   bool enable_ftp_url_support = false;
 
-  // Whether or not to check the Android platform's cleartext policy for
-  // requests. Under some conditions, Android may advise us to block cleartext
-  // traffic.
-  [EnableIf=is_android]
-  bool check_clear_text_permitted = false;
-
   // True if the "Certificate Transparency in Chrome" policy (see
   // https://github.com/chromium/ct-policy/blob/master/ct_policy.md) should
   // be enforced for certificates and connections.
@@ -220,9 +209,6 @@
   // Enables HTTP/0.9 on ports other than 80 for HTTP and 443 for HTTPS.
   bool http_09_on_non_default_ports_enabled = false;
 
-  // If true, idle sockets won't be closed when memory pressure happens.
-  bool disable_idle_sockets_close_on_memory_pressure = false;
-
   // SSL configuration. |initial_proxy_config| is the initial SSL configuration
   // to use. If nullptr, uses the default configuration. Updated SSL
   // configurations can be passed in via |ssl_config_client_request|.
@@ -299,12 +285,6 @@
   [EnableIf=is_chromeos]
   AdditionalCertificates? initial_additional_certificates;
 
-  // Parameters for the cert verifier comparison trial. This is a temporary
-  // interface and embedders should not use it.
-  // See https://crbug.com/649026
-  [EnableIf=is_trial_comparison_cert_verifier_supported]
-  TrialComparisonCertVerifierParams? trial_comparison_cert_verifier_params;
-
   // Parameters for constructing the cookie manager.
   CookieManagerParams? cookie_manager_params;
 
@@ -401,22 +381,6 @@
   int64 total_bytes_sent;
 };
 
-// Represents a signed exchange report.
-// Spec: https://wicg.github.io/webpackage/loading.html#queue-report
-struct SignedExchangeReport {
-  bool success;
-  string type;
-  url.mojom.Url outer_url;
-  url.mojom.Url inner_url;
-  url.mojom.Url cert_url;
-  string referrer;
-  IPAddress server_ip_address;
-  string protocol;
-  string method;
-  int32 status_code;
-  mojo_base.mojom.TimeDelta elapsed_time;
-};
-
 const uint32 kBrowserProcessId = 0;
 const uint32 kInvalidProcessId = 0xffffffff;
 
@@ -458,14 +422,6 @@
   // headers and Cookie response headers to be modified. This has a performance
   // impact because of the extra process hops, so use should be minimized.
   TrustedURLLoaderHeaderClient? header_client;
-
-  // If non-empty array is given, |factory_bound_allow_patterns| is used for
-  // CORS checks in addition to the per-context allow patterns that is managed
-  // via NetworkContext interface. This still respects the per-context block
-  // lists. To use this feature, caller should set |request_initiator_site_lock|
-  // in order to bind the allow patterns to the factory specific initiator
-  // origin.
-  array<CorsOriginPattern> factory_bound_allow_patterns;
 };
 
 // Callback interface for NetworkContext when routing identifiers aren't
@@ -628,9 +584,6 @@
               string? user_agent,
               mojo_base.mojom.DictionaryValue body);
 
-  // Queues a signed exchange report.
-  QueueSignedExchangeReport(SignedExchangeReport report);
-
   // Closes all open connections within this context.
   CloseAllConnections() => ();
 
@@ -767,17 +720,11 @@
   ClearBadProxiesCache() => ();
 
   // Creates a WebSocket connection.
-  // If |header_client| is set, requests with the kURLLoadOptionUseHeaderClient
-  // option will callback to the |header_client|, allowing the Cookie/Referrer
-  // request headers and Cookie response headers to be modified. This has a
-  // performance impact because of the extra process hops, so use should be
-  // minimized.
   CreateWebSocket(WebSocket& request,
                   int32 process_id,
                   int32 render_frame_id,
                   url.mojom.Origin origin,
-                  AuthenticationHandler? auth_handler,
-                  TrustedHeaderClient? header_client);
+                  AuthenticationHandler? auth_handler);
 
   // Create a NetLogExporter, which helps export NetLog to an existing file.
   // Note that the log is generally global, including all NetworkContexts
@@ -811,6 +758,10 @@
   //
   // All outstanding requests are cancelled if the NetworkContext is destroyed.
   // Such requests will receive ERR_FAILED via |response_client|.
+  //
+  // TODO(crbug.com/821021): Consider deleting this if most/all usage goes
+  // through CreateHostResolver, but most likely most usage except proxy
+  // resolver will directly use this method.
   ResolveHost(HostPortPair host,
               ResolveHostParameters? optional_parameters,
               ResolveHostClient response_client);
@@ -860,9 +811,6 @@
   // |source_origin|. The passed |patterns| will be set instead. If an empty
   // array is given for |allow_patterns| and/or |block_patterns|, the
   // |source_origin|'s origin list for each is set to empty respectively.
-  // TODO(crbug.com/936310): Eventually, we want to stop using per-context
-  // access lists, and use only per-factory access lists, or stop managing the
-  // list in the NetworkService completely.
   SetCorsOriginAccessListsForOrigin(
       url.mojom.Origin source_origin, array<CorsOriginPattern> allow_patterns,
       array<CorsOriginPattern> block_patterns) => ();
--- a/services/network/public/mojom/network_service.mojom	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/public/mojom/network_service.mojom	2019-05-17 18:53:37.924000000 +0300
@@ -204,10 +204,6 @@
   // delegation is allowed for NTLM or Negotiate authentication.
   string delegate_whitelist;
 
-  // True if OK-AS-DELEGATE flag from KDC should be used to allow delegation for
-  // Negotiate authentication along with delegate_whitelist;
-  bool delegate_by_kdc_policy = false;
-
   // True if canonical hostnames should be resolved when using Negotiate.
   bool negotiate_disable_cname_lookup = false;
 
@@ -239,20 +235,10 @@
   mojo_base.mojom.FilePath user_data_path;
 };
 
-// Represents the value of a single environment variable.
-struct EnvironmentVariable {
-  string name;
-  string value;
-};
-
 // Parameters needed to initialize the network service.
 struct NetworkServiceParams {
   ConnectionType initial_connection_type = CONNECTION_UNKNOWN;
   ConnectionSubtype initial_connection_subtype = SUBTYPE_UNKNOWN;
-
-  // A set of environment variables that should be set in the network
-  // service when starting up.
-  array<EnvironmentVariable> environment;
 };
 
 // Browser interface to the network service.
@@ -395,9 +381,4 @@
   // Called on state changes of the Android application.
   [EnableIf=is_android]
   OnApplicationStateChange(mojo_base.mojom.ApplicationState state);
-
-  // Sets the given environment variables in the network service's process.
-  // This method won't modify variables that aren't present in the
-  // |environment| array.
-  SetEnvironment(array<EnvironmentVariable> environment);
 };
--- a/services/network/public/mojom/url_loader.mojom	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/public/mojom/url_loader.mojom	2019-05-17 18:53:37.924000000 +0300
@@ -4,19 +4,31 @@
 
 module network.mojom;
 
-import "mojo/public/mojom/base/file.mojom";
-import "mojo/public/mojom/base/file_path.mojom";
-import "mojo/public/mojom/base/time.mojom";
 import "mojo/public/mojom/base/unguessable_token.mojom";
 import "services/network/public/mojom/cors.mojom";
-import "services/network/public/mojom/chunked_data_pipe_getter.mojom";
-import "services/network/public/mojom/data_pipe_getter.mojom";
 import "services/network/public/mojom/fetch_api.mojom";
 import "services/network/public/mojom/http_request_headers.mojom";
 import "services/network/public/mojom/network_param.mojom";
 import "services/network/public/mojom/request_context_frame_type.mojom";
-import "url/mojom/origin.mojom";
 import "url/mojom/url.mojom";
+import "url/mojom/origin.mojom";
+
+// Typemapped to network::ResourceRequestBody
+struct URLRequestBody {
+  // Store upload bodies
+  array<DataElement> elements;
+
+  // Identifies a particular upload instance, which is used by the cache to
+  // formulate a cache key.
+  uint64 identifier;
+
+  // Indicates whether the post data contains sensitive information like
+  // passwords.
+  bool contains_sensitive_info;
+};
+
+[Native]
+struct DataElement;
 
 [Native]
 struct URLResponseHead;
@@ -312,46 +324,6 @@
   mojo_base.mojom.UnguessableToken? fetch_window_id;
 };
 
-// URLRequestBody represents body (i.e. upload data) of a HTTP request.
-// Typemapped to network::ResourceRequestBody
-struct URLRequestBody {
-  // Store upload bodies
-  array<DataElement> elements;
-
-  // Identifies a particular upload instance, which is used by the cache to
-  // formulate a cache key.
-  uint64 identifier;
-
-  // Indicates whether the post data contains sensitive information like
-  // passwords.
-  bool contains_sensitive_info;
-};
-
-// Represents part of an upload body. This could be either one of bytes, file or
-// a data pipe.
-// Typemapped to network::DataElement
-struct DataElement {
-  DataElementType type;
-
-  // For kBytes.
-  array<uint8> buf;
-  // For kFile and kRawFile
-  mojo_base.mojom.FilePath path;
-  // For kRawFile
-  mojo_base.mojom.File? file;
-  // For kBlob
-  // TODO(Richard): Deprecate this once NetworkService is fully shipped.
-  string blob_uuid;
-  // For kDataPipe
-  network.mojom.DataPipeGetter? data_pipe_getter;
-  // For kChunkedDataPipe
-  network.mojom.ChunkedDataPipeGetter? chunked_data_pipe_getter;
-
-  uint64 offset;
-  uint64 length;
-  mojo_base.mojom.Time expected_modification_time;
-};
-
 // Destroying a URLLoader will cancel the associated request.
 interface URLLoader {
   // If a disconnection is initiated by the client side, it may send the
--- a/services/network/public/mojom/websocket.mojom	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/public/mojom/websocket.mojom	2019-05-17 18:53:37.924000000 +0300
@@ -6,7 +6,6 @@
 
 import "url/mojom/url.mojom";
 import "services/network/public/mojom/network_param.mojom";
-import "services/network/public/mojom/ip_endpoint.mojom";
 
 enum WebSocketMessageType {
   CONTINUATION,
@@ -34,7 +33,7 @@
   HttpVersion http_version;
   int32 status_code;
   string status_text;
-  IPEndPoint remote_endpoint;
+  HostPortPair socket_address;
   array<HttpHeader> headers;
   string headers_text;
 };
@@ -46,7 +45,7 @@
   // authentication.
   OnAuthRequired(AuthChallengeInfo info,
                  HttpResponseHeaders headers,
-                 IPEndPoint remote_endpoint) => (AuthCredentials? credentials);
+                 HostPortPair socket_address) => (AuthCredentials? credentials);
 };
 
 interface WebSocketClient {
--- a/services/network/resolve_host_request.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/resolve_host_request.cc	2019-05-17 18:53:37.924000000 +0300
@@ -6,7 +6,6 @@
 
 #include <utility>
 
-#include "base/bind.h"
 #include "base/logging.h"
 #include "base/no_destructor.h"
 #include "base/optional.h"
--- a/services/network/resource_scheduler.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/resource_scheduler.cc	2019-05-17 18:53:37.924000000 +0300
@@ -20,7 +20,6 @@
 #include "base/stl_util.h"
 #include "base/strings/string_number_conversions.h"
 #include "base/supports_user_data.h"
-#include "base/threading/thread_task_runner_handle.h"
 #include "base/time/default_tick_clock.h"
 #include "base/time/tick_clock.h"
 #include "base/trace_event/trace_event.h"
@@ -401,10 +400,6 @@
       pending_requests_.Erase(request);
       DCHECK(!base::ContainsKey(in_flight_requests_, request));
     } else {
-      // Record metrics.
-      if (!RequestAttributesAreSet(request->attributes(), kAttributeDelayable))
-        last_non_delayable_request_end_ = tick_clock_->NowTicks();
-      RecordNetworkContentionMetrics(*request);
       EraseInFlightRequest(request);
 
       // Removing this request may have freed up another to load.
@@ -669,55 +664,9 @@
     return false;
   }
 
-  void RecordMetricsOnStartRequest(const ScheduledResourceRequestImpl& request,
-                                   base::TimeTicks ticks_now) const {
-    // Record the number of delayable requests in-flight when a non-delayable
-    // request starts.
-    if (!RequestAttributesAreSet(request.attributes(), kAttributeDelayable)) {
-      UMA_HISTOGRAM_COUNTS_100(
-          "ResourceScheduler.NumDelayableRequestsInFlightAtStart.NonDelayable",
-          in_flight_delayable_count_);
-      if (last_non_delayable_request_start_.has_value()) {
-        UMA_HISTOGRAM_MEDIUM_TIMES(
-            "ResourceScheduler.NonDelayableLastStartToNonDelayableStart",
-            ticks_now - last_non_delayable_request_start_.value());
-      }
-      if (last_non_delayable_request_end_.has_value()) {
-        UMA_HISTOGRAM_MEDIUM_TIMES(
-            "ResourceScheduler.NonDelayableLastEndToNonDelayableStart",
-            ticks_now - last_non_delayable_request_end_.value());
-      }
-
-      // Record time since last non-delayable request start or end, whichever
-      // happened later.
-      base::Optional<base::TimeTicks> last_non_delayable_request_start_or_end;
-      if (last_non_delayable_request_start_.has_value() &&
-          !last_non_delayable_request_end_.has_value()) {
-        last_non_delayable_request_start_or_end =
-            last_non_delayable_request_start_;
-      } else if (!last_non_delayable_request_start_.has_value() &&
-                 last_non_delayable_request_end_.has_value()) {
-        last_non_delayable_request_start_or_end =
-            last_non_delayable_request_end_;
-      } else if (last_non_delayable_request_start_.has_value() &&
-                 last_non_delayable_request_end_.has_value()) {
-        last_non_delayable_request_start_or_end =
-            std::max(last_non_delayable_request_start_.value(),
-                     last_non_delayable_request_end_.value());
-      }
-
-      if (last_non_delayable_request_start_or_end) {
-        UMA_HISTOGRAM_MEDIUM_TIMES(
-            "ResourceScheduler.NonDelayableLastStartOrEndToNonDelayableStart",
-            ticks_now - last_non_delayable_request_start_or_end.value());
-      }
-    }
-  }
-
   void StartRequest(ScheduledResourceRequestImpl* request,
                     StartMode start_mode,
                     RequestStartTrigger trigger) {
-    const base::TimeTicks ticks_now = tick_clock_->NowTicks();
     // Only log on requests that were blocked by the ResourceScheduler.
     if (start_mode == START_ASYNC) {
       DCHECK_NE(RequestStartTrigger::NONE, trigger);
@@ -726,22 +675,22 @@
           net::NetLog::StringCallback("trigger",
                                       RequestStartTriggerString(trigger)));
     }
-    if (request)
-      RecordMetricsOnStartRequest(*request, ticks_now);
+    // Record the number of delayable requests in-flight when a non-delayable
+    // request starts.
+    if (!RequestAttributesAreSet(request->attributes(), kAttributeDelayable)) {
+      UMA_HISTOGRAM_COUNTS_100(
+          "ResourceScheduler.NumDelayableRequestsInFlightAtStart.NonDelayable",
+          in_flight_delayable_count_);
+    }
 
     DCHECK(!request->url_request()->creation_time().is_null());
     base::TimeDelta queuing_duration =
-        ticks_now - request->url_request()->creation_time();
+        base::TimeTicks::Now() - request->url_request()->creation_time();
     base::UmaHistogramMediumTimes(
         "ResourceScheduler.RequestQueuingDuration.Priority" +
-            base::NumberToString(
-                request->get_request_priority_params().priority),
+            base::IntToString(request->get_request_priority_params().priority),
         queuing_duration);
 
-    // Update the start time of the non-delayble request.
-    if (!RequestAttributesAreSet(request->attributes(), kAttributeDelayable))
-      last_non_delayable_request_start_ = ticks_now;
-
     InsertInFlightRequest(request);
     request->Start(start_mode);
   }
@@ -929,41 +878,6 @@
     }
   }
 
-  // If |request| was delayable, this method records how long after |request|
-  // started, a non-delayable request also started. This is the duration of time
-  // that |request| should have been queued for so as to avoid any network
-  // contention with all later-arriving non-delayable requests. Must be called
-  // after |request| is finished.
-  void RecordNetworkContentionMetrics(
-      const ScheduledResourceRequestImpl& request) const {
-    if (!RequestAttributesAreSet(request.attributes(), kAttributeDelayable))
-      return;
-
-    base::TimeDelta ideal_duration_to_wait;
-    if (!last_non_delayable_request_start_) {
-      // No non-delayable request has been started in this client so far.
-      // |request| did not have to wait at all to avoid network contention.
-      ideal_duration_to_wait = base::TimeDelta();
-    } else if (request.url_request()->creation_time() >
-               last_non_delayable_request_start_) {
-      // Last non-delayable request in this client started before |request|
-      // was created. |request| did not have to wait at all to avoid network
-      // contention with non-delayable requests.
-      ideal_duration_to_wait = base::TimeDelta();
-    } else {
-      // The latest non-delayable request started at
-      // |last_non_delayable_request_start_| which happened after the
-      // creation of |request|.
-      ideal_duration_to_wait = last_non_delayable_request_start_.value() -
-                               request.url_request()->creation_time();
-    }
-
-    UMA_HISTOGRAM_MEDIUM_TIMES(
-        "ResourceScheduler.DelayableRequests."
-        "WaitTimeToAvoidContentionWithNonDelayableRequest",
-        ideal_duration_to_wait);
-  }
-
   // Tracks if the main HTML parser has reached the body which marks the end of
   // layout-blocking resources.
   // This is disabled and the is always true when kRendererSideResourceScheduler
@@ -995,12 +909,6 @@
   // Guaranteed to be non-null.
   const base::TickClock* tick_clock_;
 
-  // Time when the last non-delayble request started in this client.
-  base::Optional<base::TimeTicks> last_non_delayable_request_start_;
-
-  // Time when the last non-delayble request ended in this client.
-  base::Optional<base::TimeTicks> last_non_delayable_request_end_;
-
   base::WeakPtrFactory<ResourceScheduler::Client> weak_ptr_factory_;
 };
 
@@ -1092,7 +1000,9 @@
   Client* client = it->second.get();
   // TODO(crbug.com/873959): Remove this CHECK once the investigation is done.
   CHECK(client);
-  DCHECK(client->HasNoPendingRequests() ||
+  DCHECK(!base::FeatureList::IsEnabled(
+             features::kUnthrottleRequestsAfterLongQueuingDelay) ||
+         client->HasNoPendingRequests() ||
          IsLongQueuedRequestsDispatchTimerRunning());
   // ResourceDispatcherHost cancels all requests except for cross-renderer
   // navigations, async revalidations and detachable requests after
@@ -1116,6 +1026,11 @@
 }
 
 void ResourceScheduler::StartLongQueuedRequestsDispatchTimerIfNeeded() {
+  if (!base::FeatureList::IsEnabled(
+          features::kUnthrottleRequestsAfterLongQueuingDelay)) {
+    return;
+  }
+
   bool pending_request_found = false;
   for (const auto& client : client_map_) {
     if (!client.second->HasNoPendingRequests()) {
--- a/services/network/resource_scheduler_params_manager.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/resource_scheduler_params_manager.cc	2019-05-17 18:53:37.924000000 +0300
@@ -19,11 +19,7 @@
 
 // The maximum number of delayable requests to allow to be in-flight at any
 // point in time (across all hosts).
-constexpr size_t kDefaultMaxNumDelayableRequestsPerClient = 10;
-
-// Value by which HTTP RTT estimate is multiplied to get the maximum queuing
-// duration.
-constexpr int kHttpRttMultiplierForQueuingDuration = 30;
+static const size_t kDefaultMaxNumDelayableRequestsPerClient = 10;
 
 // Reads experiment parameters and returns them.
 ResourceSchedulerParamsManager::ParamsForNetworkQualityContainer
@@ -69,7 +65,7 @@
     if (!base::StringToSizeT(base::GetFieldTrialParamValueByFeature(
                                  features::kThrottleDelayable,
                                  kMaxDelayableRequestsBase +
-                                     base::NumberToString(config_param_index)),
+                                     base::IntToString(config_param_index)),
                              &max_delayable_requests)) {
       break;
     }
@@ -79,13 +75,12 @@
             base::GetFieldTrialParamValueByFeature(
                 features::kThrottleDelayable,
                 kEffectiveConnectionTypeBase +
-                    base::NumberToString(config_param_index)));
+                    base::IntToString(config_param_index)));
     DCHECK(effective_connection_type.has_value());
 
     double non_delayable_weight = base::GetFieldTrialParamByFeatureAsDouble(
         features::kThrottleDelayable,
-        kNonDelayableWeightBase + base::NumberToString(config_param_index),
-        0.0);
+        kNonDelayableWeightBase + base::IntToString(config_param_index), 0.0);
 
     // Check if the entry is already present. This will happen if the default
     // params are being overridden by the field trial.
@@ -137,31 +132,28 @@
     }
   }
 
-  for (int ect = net::EFFECTIVE_CONNECTION_TYPE_UNKNOWN;
+  if (base::FeatureList::IsEnabled(
+          features::kUnthrottleRequestsAfterLongQueuingDelay)) {
+    int http_rtt_multiplier = base::GetFieldTrialParamByFeatureAsInt(
+        features::kUnthrottleRequestsAfterLongQueuingDelay,
+        "http_rtt_multiplier", -1);
+
+    if (http_rtt_multiplier > 0) {
+      for (int ect = net::EFFECTIVE_CONNECTION_TYPE_SLOW_2G;
        ect <= net::EFFECTIVE_CONNECTION_TYPE_4G; ++ect) {
     net::EffectiveConnectionType effective_connection_type =
         static_cast<net::EffectiveConnectionType>(ect);
     base::TimeDelta http_rtt =
         net::NetworkQualityEstimatorParams::GetDefaultTypicalHttpRtt(
             effective_connection_type);
-    base::TimeDelta max_queuing_time =
-        http_rtt * kHttpRttMultiplierForQueuingDuration;
-
-    // If GetDefaultTypicalHttpRtt returns a null value, set
-    // |max_queuing_time| to kUpperBoundQueuingDuration, This may happen
-    // when |ect| is UNKNOWN or OFFLINE. Both these cases are very rare, but
-    // it's important to handle them to ensure that |max_queuing_time|
-    // is set to some non-zero value in all cases. This ensures that the
-    // requests that are queued for too long are always unthrottled.
-    if (http_rtt.is_zero())
-      max_queuing_time = kUpperBoundQueuingDuration;
+        base::TimeDelta max_queuing_time = http_rtt * http_rtt_multiplier;
     if (max_queuing_time < kLowerBoundQueuingDuration)
       max_queuing_time = kLowerBoundQueuingDuration;
     if (max_queuing_time > kUpperBoundQueuingDuration)
       max_queuing_time = kUpperBoundQueuingDuration;
 
-    ResourceSchedulerParamsManager::ParamsForNetworkQualityContainer::iterator
-        iter = result.find(effective_connection_type);
+        ResourceSchedulerParamsManager::ParamsForNetworkQualityContainer::
+            iterator iter = result.find(effective_connection_type);
     if (iter != result.end()) {
       iter->second.max_queuing_time = max_queuing_time;
     } else {
@@ -172,6 +164,8 @@
               max_queuing_time)));
     }
   }
+    }
+  }
 
   return result;
 }
--- a/services/network/resource_scheduler_params_manager_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/resource_scheduler_params_manager_unittest.cc	2019-05-17 18:53:37.924000000 +0300
@@ -20,13 +20,8 @@
 
 namespace {
 
-// Should remain synchronized with the values in
-// resouce_scheduler_params_manager.cc.
-constexpr base::TimeDelta kLowerBoundQueuingDuration =
+static constexpr base::TimeDelta kLowerBoundQueuingDuration =
     base::TimeDelta::FromSeconds(15);
-constexpr base::TimeDelta kUpperBoundQueuingDuration =
-    base::TimeDelta::FromSeconds(120);
-constexpr int kHttpRttMultiplierForQueuingDuration = 30;
 
 class ResourceSchedulerParamsManagerTest : public testing::Test {
  public:
@@ -109,7 +104,7 @@
             resource_scheduler_params_manager
                 .GetParamsForEffectiveConnectionType(effective_connection_type)
                 .delay_requests_on_multiplexed_connections);
-        EXPECT_TRUE(
+        EXPECT_FALSE(
             resource_scheduler_params_manager
                 .GetParamsForEffectiveConnectionType(effective_connection_type)
                 .max_queuing_time.has_value());
@@ -128,7 +123,7 @@
             resource_scheduler_params_manager
                 .GetParamsForEffectiveConnectionType(effective_connection_type)
                 .delay_requests_on_multiplexed_connections);
-        EXPECT_TRUE(
+        EXPECT_FALSE(
             resource_scheduler_params_manager
                 .GetParamsForEffectiveConnectionType(effective_connection_type)
                 .max_queuing_time.has_value());
@@ -148,7 +143,7 @@
             resource_scheduler_params_manager
                 .GetParamsForEffectiveConnectionType(effective_connection_type)
                 .delay_requests_on_multiplexed_connections);
-        EXPECT_TRUE(
+        EXPECT_FALSE(
             resource_scheduler_params_manager
                 .GetParamsForEffectiveConnectionType(effective_connection_type)
                 .max_queuing_time.has_value());
@@ -219,7 +214,7 @@
       EXPECT_TRUE(resource_scheduler_params_manager
                       .GetParamsForEffectiveConnectionType(ect)
                       .delay_requests_on_multiplexed_connections);
-      EXPECT_TRUE(resource_scheduler_params_manager
+      EXPECT_FALSE(resource_scheduler_params_manager
                       .GetParamsForEffectiveConnectionType(ect)
                       .max_queuing_time.has_value());
 
@@ -233,7 +228,7 @@
       EXPECT_FALSE(resource_scheduler_params_manager
                        .GetParamsForEffectiveConnectionType(ect)
                        .delay_requests_on_multiplexed_connections);
-      EXPECT_TRUE(resource_scheduler_params_manager
+      EXPECT_FALSE(resource_scheduler_params_manager
                       .GetParamsForEffectiveConnectionType(ect)
                       .max_queuing_time.has_value());
 
@@ -254,6 +249,18 @@
   scoped_refptr<base::FieldTrial> trial =
       base::FieldTrialList::CreateFieldTrial(kTrialName, kGroupName);
 
+  std::map<std::string, std::string> params;
+  params["http_rtt_multiplier"] = "20";
+  ASSERT_TRUE(
+      base::FieldTrialParamAssociator::GetInstance()->AssociateFieldTrialParams(
+          kTrialName, kGroupName, params));
+
+  std::unique_ptr<base::FeatureList> feature_list(new base::FeatureList);
+  feature_list->RegisterFieldTrialOverride(
+      features::kUnthrottleRequestsAfterLongQueuingDelay.name,
+      base::FeatureList::OVERRIDE_ENABLE_FEATURE, trial.get());
+  scoped_feature_list.InitWithFeatureList(std::move(feature_list));
+
   ResourceSchedulerParamsManager resource_scheduler_params_manager;
 
   for (int effective_connection_type = net::EFFECTIVE_CONNECTION_TYPE_UNKNOWN;
@@ -275,7 +282,7 @@
       EXPECT_TRUE(resource_scheduler_params_manager
                       .GetParamsForEffectiveConnectionType(ect)
                       .delay_requests_on_multiplexed_connections);
-      EXPECT_EQ(typical_http_rtt * kHttpRttMultiplierForQueuingDuration,
+      EXPECT_EQ(typical_http_rtt * 20,
                 resource_scheduler_params_manager
                     .GetParamsForEffectiveConnectionType(ect)
                     .max_queuing_time);
@@ -319,10 +326,9 @@
       EXPECT_FALSE(resource_scheduler_params_manager
                        .GetParamsForEffectiveConnectionType(ect)
                        .delay_requests_on_multiplexed_connections);
-      EXPECT_EQ(kUpperBoundQueuingDuration,
-                resource_scheduler_params_manager
+      EXPECT_FALSE(resource_scheduler_params_manager
                     .GetParamsForEffectiveConnectionType(ect)
-                    .max_queuing_time);
+                       .max_queuing_time.has_value());
     }
   }
 }
@@ -387,7 +393,7 @@
       EXPECT_TRUE(resource_scheduler_params_manager
                       .GetParamsForEffectiveConnectionType(ect)
                       .delay_requests_on_multiplexed_connections);
-      EXPECT_TRUE(resource_scheduler_params_manager
+      EXPECT_FALSE(resource_scheduler_params_manager
                       .GetParamsForEffectiveConnectionType(ect)
                       .max_queuing_time.has_value());
 
@@ -401,7 +407,7 @@
       EXPECT_TRUE(resource_scheduler_params_manager
                       .GetParamsForEffectiveConnectionType(ect)
                       .delay_requests_on_multiplexed_connections);
-      EXPECT_TRUE(resource_scheduler_params_manager
+      EXPECT_FALSE(resource_scheduler_params_manager
                       .GetParamsForEffectiveConnectionType(ect)
                       .max_queuing_time.has_value());
 
@@ -415,7 +421,7 @@
       EXPECT_FALSE(resource_scheduler_params_manager
                        .GetParamsForEffectiveConnectionType(ect)
                        .delay_requests_on_multiplexed_connections);
-      EXPECT_TRUE(resource_scheduler_params_manager
+      EXPECT_FALSE(resource_scheduler_params_manager
                       .GetParamsForEffectiveConnectionType(ect)
                       .max_queuing_time.has_value());
 
@@ -438,7 +444,7 @@
   // Skip configuration parameters for index 2 to test that the parser stops
   // when it cannot find the parameters for an index.
   for (int range_index : {1, 3, 4}) {
-    std::string index_str = base::NumberToString(range_index);
+    std::string index_str = base::IntToString(range_index);
     params["EffectiveConnectionType" + index_str] = "Slow-2G";
     params["MaxDelayableRequests" + index_str] = index_str + "0";
     params["NonDelayableWeight" + index_str] = "0";
@@ -570,7 +576,7 @@
                 .GetParamsForEffectiveConnectionType(
                     net::EFFECTIVE_CONNECTION_TYPE_SLOW_2G)
                 .non_delayable_weight);
-  EXPECT_TRUE(resource_scheduler_params_manager
+  EXPECT_FALSE(resource_scheduler_params_manager
                   .GetParamsForEffectiveConnectionType(
                       net::EFFECTIVE_CONNECTION_TYPE_SLOW_2G)
                   .max_queuing_time.has_value());
@@ -587,7 +593,7 @@
                                          .GetParamsForEffectiveConnectionType(
                                              net::EFFECTIVE_CONNECTION_TYPE_3G)
                                          .non_delayable_weight);
-  EXPECT_TRUE(resource_scheduler_params_manager
+  EXPECT_FALSE(resource_scheduler_params_manager
                   .GetParamsForEffectiveConnectionType(
                       net::EFFECTIVE_CONNECTION_TYPE_3G)
                   .max_queuing_time.has_value());
--- a/services/network/resource_scheduler_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/resource_scheduler_unittest.cc	2019-05-17 18:53:37.924000000 +0300
@@ -11,7 +11,6 @@
 #include <utility>
 #include <vector>
 
-#include "base/bind.h"
 #include "base/memory/ref_counted.h"
 #include "base/message_loop/message_loop.h"
 #include "base/metrics/field_trial.h"
@@ -47,36 +46,6 @@
 
 namespace {
 
-// Verifies that (i) Exactly one sample is recorded in |histogram_name|; and,
-// (ii) The sample value is at least |min_value|.
-void ExpectSampleIsAtLeastSpecifiedValue(
-    const base::HistogramTester& histogram_tester,
-    const std::string& histogram_name,
-    int min_value) {
-  histogram_tester.ExpectTotalCount(histogram_name, 1);
-
-  // Verify if the recorded unique sample is in the same bucket to which
-  // |min_value| belongs to.
-  if (histogram_tester.GetBucketCount(histogram_name, min_value) == 1) {
-    return;
-  }
-
-  // Verify if the recorded unique sample is in a bucket that contains samples
-  // larger than |min_value|.
-  const std::vector<base::Bucket> buckets =
-      histogram_tester.GetAllSamples(histogram_name);
-  EXPECT_EQ(1u, buckets.size());
-  bool sample_found = false;
-  for (const auto& bucket : buckets) {
-    if (bucket.count > 0) {
-      // Verify that the sample is at least |min_value|.
-      EXPECT_GE(bucket.min, min_value);
-      sample_found = true;
-    }
-  }
-  EXPECT_TRUE(sample_found);
-}
-
 class TestRequestFactory;
 
 const int kChildId = 30;
@@ -319,7 +288,7 @@
     // Queue the maximum number of delayable requests that should be started
     // before the resource scheduler starts throttling delayable requests.
     for (int i = 0; i < kOverriddenNumRequests; ++i) {
-      std::string url = "http://host/low" + base::NumberToString(i);
+      std::string url = "http://host/low" + base::IntToString(i);
       lows_singlehost.push_back(NewRequest(url.c_str(), net::LOWEST));
       EXPECT_TRUE(lows_singlehost[i]->started());
     }
@@ -486,11 +455,11 @@
 
   histogram_tester.ExpectTotalCount(
       "ResourceScheduler.RequestQueuingDuration.Priority" +
-          base::NumberToString(net::HIGHEST),
+          base::IntToString(net::HIGHEST),
       1);
   histogram_tester.ExpectTotalCount(
       "ResourceScheduler.RequestQueuingDuration.Priority" +
-          base::NumberToString(net::LOWEST),
+          base::IntToString(net::LOWEST),
       2);
 }
 
@@ -565,7 +534,7 @@
   std::vector<std::unique_ptr<TestRequest>> lows_singlehost;
   // Queue up to the per-host limit (we subtract the current high-pri request).
   for (int i = 0; i < kMaxNumDelayableRequestsPerHost - 1; ++i) {
-    string url = "http://host/low" + base::NumberToString(i);
+    string url = "http://host/low" + base::IntToString(i);
     lows_singlehost.push_back(NewRequest(url.c_str(), net::LOWEST));
     EXPECT_TRUE(lows_singlehost[i]->started());
   }
@@ -593,7 +562,7 @@
   std::vector<std::unique_ptr<TestRequest>> lows_different_host;
   base::RunLoop().RunUntilIdle();
   for (int i = 0; i < expected_slots_left; ++i) {
-    string url = "http://host" + base::NumberToString(i) + "/low";
+    string url = "http://host" + base::IntToString(i) + "/low";
     lows_different_host.push_back(NewRequest(url.c_str(), net::LOWEST));
     EXPECT_TRUE(lows_different_host[i]->started());
   }
@@ -640,7 +609,7 @@
   const int kDefaultMaxNumDelayableRequestsPerClient = 10;
   std::vector<std::unique_ptr<TestRequest>> lows;
   for (int i = 0; i < kDefaultMaxNumDelayableRequestsPerClient - 1; ++i) {
-    string url = "http://host/low" + base::NumberToString(i);
+    string url = "http://host/low" + base::IntToString(i);
     lows.push_back(NewRequest(url.c_str(), net::LOWEST));
   }
 
@@ -677,7 +646,7 @@
   const int kNumFillerRequests = kDefaultMaxNumDelayableRequestsPerClient - 2;
   std::vector<std::unique_ptr<TestRequest>> lows;
   for (int i = 0; i < kNumFillerRequests; ++i) {
-    string url = "http://host" + base::NumberToString(i) + "/low";
+    string url = "http://host" + base::IntToString(i) + "/low";
     lows.push_back(NewRequest(url.c_str(), net::LOWEST));
   }
 
@@ -705,7 +674,7 @@
   const int kDefaultMaxNumDelayableRequestsPerClient = 0;
   std::vector<std::unique_ptr<TestRequest>> lows;
   for (int i = 0; i < kDefaultMaxNumDelayableRequestsPerClient; ++i) {
-    string url = "http://host/low" + base::NumberToString(i);
+    string url = "http://host/low" + base::IntToString(i);
     lows.push_back(NewRequest(url.c_str(), net::LOWEST));
   }
 
@@ -734,7 +703,7 @@
       10;  // Should match the .cc.
   std::vector<std::unique_ptr<TestRequest>> lows;
   for (int i = 0; i < kDefaultMaxNumDelayableRequestsPerClient; ++i) {
-    string url = "http://host/low" + base::NumberToString(i);
+    string url = "http://host/low" + base::IntToString(i);
     lows.push_back(NewRequest(url.c_str(), net::IDLE));
   }
 
@@ -794,7 +763,7 @@
   // Cancel a request after we learn the server supports SPDY.
   std::vector<std::unique_ptr<TestRequest>> lows;
   for (int i = 0; i < kDefaultMaxNumDelayableRequestsPerClient - 1; ++i) {
-    string url = "http://host" + base::NumberToString(i) + "/low";
+    string url = "http://host" + base::IntToString(i) + "/low";
     lows.push_back(NewRequest(url.c_str(), net::LOWEST));
   }
   std::unique_ptr<TestRequest> low1(NewRequest("http://host/low", net::LOWEST));
@@ -838,7 +807,7 @@
   // Cancel a request after we learn the server supports SPDY.
   std::vector<std::unique_ptr<TestRequest>> lows;
   for (int i = 0; i < max_delayable_requests_per_client_ect_2g - 1; ++i) {
-    string url = "http://host" + base::NumberToString(i) + "/low";
+    string url = "http://host" + base::IntToString(i) + "/low";
     lows.push_back(NewRequest(url.c_str(), net::LOWEST));
     EXPECT_TRUE(lows.back()->started());
   }
@@ -958,7 +927,7 @@
     // per host limit from kicking in.
     for (int i = 0; i < kDefaultMaxNumDelayableRequestsPerClient; ++i) {
       // Keep unique hostnames to prevent the per host limit from kicking in.
-      std::string url = "http://host" + base::NumberToString(i) + "/low";
+      std::string url = "http://host" + base::IntToString(i) + "/low";
       lows_singlehost.push_back(NewRequest(url.c_str(), net::LOWEST));
       EXPECT_TRUE(lows_singlehost[i]->started());
     }
@@ -996,7 +965,7 @@
   // Queue up to the overridden limit.
   for (int i = 0; i < kOverriddenNumRequests; ++i) {
     // Keep unique hostnames to prevent the per host limit from kicking in.
-    std::string url = "http://host" + base::NumberToString(i) + "/low";
+    std::string url = "http://host" + base::IntToString(i) + "/low";
     lows_singlehost.push_back(NewRequest(url.c_str(), net::LOWEST));
     EXPECT_TRUE(lows_singlehost[i]->started());
   }
@@ -1050,7 +1019,7 @@
   // Queue up to the overridden limit.
   for (int i = 0; i < kNumDelayableHigh; ++i) {
     // Keep unique hostnames to prevent the per host limit from kicking in.
-    std::string url = "http://host" + base::NumberToString(i) + "/low1";
+    std::string url = "http://host" + base::IntToString(i) + "/low1";
     delayable_first_page.push_back(NewRequest(url.c_str(), net::LOWEST));
     EXPECT_TRUE(delayable_first_page[i]->started());
   }
@@ -1071,7 +1040,7 @@
   std::vector<std::unique_ptr<TestRequest>> delayable_second_page;
   for (int i = 0; i < kNumDelayableLow; ++i) {
     // Keep unique hostnames to prevent the per host limit from kicking in.
-    std::string url = "http://host" + base::NumberToString(i) + "/low2";
+    std::string url = "http://host" + base::IntToString(i) + "/low2";
     delayable_second_page.push_back(NewRequest(url.c_str(), net::LOWEST));
     EXPECT_FALSE(delayable_second_page[i]->started());
   }
@@ -1101,7 +1070,7 @@
   // No new delayable request should start since there are already
   // |kNumDelayableLow| requests in flight.
   std::string url =
-      "http://host" + base::NumberToString(kNumDelayableLow) + "/low3";
+      "http://host" + base::IntToString(kNumDelayableLow) + "/low3";
   delayable_second_page.push_back(NewRequest(url.c_str(), net::LOWEST));
   EXPECT_FALSE(delayable_second_page.back()->started());
 }
@@ -1474,7 +1443,7 @@
   // per host limit from kicking in.
   for (int i = 0; i < max_low_priority_requests_allowed; ++i) {
     // Keep unique hostnames to prevent the per host limit from kicking in.
-    std::string url = "http://host" + base::NumberToString(i) + "/low";
+    std::string url = "http://host" + base::IntToString(i) + "/low";
     lows_singlehost.push_back(NewRequest(url.c_str(), net::LOWEST));
     EXPECT_TRUE(lows_singlehost[i]->started()) << i;
   }
@@ -1490,7 +1459,6 @@
 // Verify that when |max_queuing_time| is set, requests queued for too long
 // duration are dispatched to the network.
 TEST_F(ResourceSchedulerTest, MaxQueuingDelaySet) {
-  base::HistogramTester histogram_tester;
   base::TimeDelta max_queuing_time = base::TimeDelta::FromSeconds(15);
   InitializeMaxQueuingDelayExperiment(max_queuing_time);
   network_quality_estimator_.SetAndNotifyObserversOfEffectiveConnectionType(
@@ -1515,7 +1483,7 @@
   // per host limit from kicking in.
   for (int i = 0; i < max_low_priority_requests_allowed + 10; ++i) {
     // Keep unique hostnames to prevent the per host limit from kicking in.
-    std::string url = "http://host" + base::NumberToString(i) + "/low";
+    std::string url = "http://host" + base::IntToString(i) + "/low";
     lows_singlehost.push_back(NewRequest(url.c_str(), net::LOWEST));
     EXPECT_EQ(i < max_low_priority_requests_allowed,
               lows_singlehost[i]->started());
@@ -1534,23 +1502,6 @@
   for (int i = 1; i < max_low_priority_requests_allowed + 10; ++i) {
     EXPECT_TRUE(lows_singlehost[i]->started());
   }
-
-  histogram_tester.ExpectUniqueSample(
-      "ResourceScheduler.DelayableRequests."
-      "WaitTimeToAvoidContentionWithNonDelayableRequest",
-      0, 1);
-
-  // Delete the requests. This should trigger the end of the requests which in
-  // turn would trigger recording of the metrics.
-  for (int i = 1; i < max_low_priority_requests_allowed + 10; ++i)
-    lows_singlehost[i].reset();
-
-  // No non-delayable request started after the start of the delayable request.
-  // Metric should be recorded as 0 milliseconds.
-  histogram_tester.ExpectUniqueSample(
-      "ResourceScheduler.DelayableRequests."
-      "WaitTimeToAvoidContentionWithNonDelayableRequest",
-      0, max_low_priority_requests_allowed + 10);
 }
 
 // Verify that when |max_queuing_time| is not set, requests queued for too long
@@ -1579,7 +1530,7 @@
   // per host limit from kicking in.
   for (int i = 0; i < max_low_priority_requests_allowed + 10; ++i) {
     // Keep unique hostnames to prevent the per host limit from kicking in.
-    std::string url = "http://host" + base::NumberToString(i) + "/low";
+    std::string url = "http://host" + base::IntToString(i) + "/low";
     lows_singlehost.push_back(NewRequest(url.c_str(), net::LOWEST));
     EXPECT_EQ(i < max_low_priority_requests_allowed,
               lows_singlehost[i]->started());
@@ -1628,7 +1579,7 @@
   // per host limit from kicking in.
   for (int i = 0; i < max_low_priority_requests_allowed + 10; ++i) {
     // Keep unique hostnames to prevent the per host limit from kicking in.
-    std::string url = "http://host" + base::NumberToString(i) + "/low";
+    std::string url = "http://host" + base::IntToString(i) + "/low";
     lows_singlehost.push_back(NewRequest(url.c_str(), net::LOWEST));
     EXPECT_EQ(i < max_low_priority_requests_allowed,
               lows_singlehost[i]->started());
@@ -1676,7 +1627,7 @@
   // per host limit from kicking in.
   for (int i = 0; i < max_low_priority_requests_allowed + 10; ++i) {
     // Keep unique hostnames to prevent the per host limit from kicking in.
-    std::string url = "http://host" + base::NumberToString(i) + "/low";
+    std::string url = "http://host" + base::IntToString(i) + "/low";
     lows_singlehost.push_back(NewRequest(url.c_str(), net::LOWEST));
     EXPECT_EQ(i < max_low_priority_requests_allowed,
               lows_singlehost[i]->started());
@@ -1700,6 +1651,9 @@
 // Verify that the timer to dispatch long queued requests starts only when there
 // are requests in-flight.
 TEST_F(ResourceSchedulerTest, MaxQueuingDelayTimerRunsOnRequestSchedule) {
+  base::test::ScopedFeatureList scoped_feature_list;
+  scoped_feature_list.InitFromCommandLine(
+      features::kUnthrottleRequestsAfterLongQueuingDelay.name, "");
   base::TimeDelta max_queuing_time = base::TimeDelta::FromSeconds(15);
   InitializeMaxQueuingDelayExperiment(max_queuing_time);
   network_quality_estimator_.SetAndNotifyObserversOfEffectiveConnectionType(
@@ -1723,7 +1677,7 @@
 
   for (int i = 0; i < max_low_priority_requests_allowed + 10; ++i) {
     // Keep unique hostnames to prevent the per host limit from kicking in.
-    std::string url = "http://host" + base::NumberToString(i) + "/low";
+    std::string url = "http://host" + base::IntToString(i) + "/low";
     lows_singlehost.push_back(NewRequest(url.c_str(), net::LOWEST));
     EXPECT_EQ(i < max_low_priority_requests_allowed,
               lows_singlehost[i]->started());
@@ -1755,123 +1709,12 @@
   // Start some requests which end up pending.
   for (int i = 0; i < max_low_priority_requests_allowed + 10; ++i) {
     // Keep unique hostnames to prevent the per host limit from kicking in.
-    std::string url = "http://host" + base::NumberToString(i) + "/low";
+    std::string url = "http://host" + base::IntToString(i) + "/low";
     lows_singlehost.push_back(NewRequest(url.c_str(), net::LOWEST));
   }
   EXPECT_TRUE(scheduler()->IsLongQueuedRequestsDispatchTimerRunning());
 }
 
-// Starts a delayable request followed by a non-delayable request. The delayable
-// request finishes after the start of the non-delayable request. Verifies that
-// the histogram that records the time difference between the start of delayable
-// requests and the start of non-delayable requests is recorded properly.
-TEST_F(ResourceSchedulerTest, NonDelayableRequestArrivesAfterDelayableStarts) {
-  base::HistogramTester histogram_tester;
-
-  base::TimeDelta max_queuing_time = base::TimeDelta::FromSeconds(15);
-  InitializeMaxQueuingDelayExperiment(max_queuing_time);
-
-  InitializeScheduler();
-
-  // Throw in one low priority request. When the request finishes histograms
-  // should be recorded.
-  std::unique_ptr<TestRequest> low(NewRequest("http://host/low", net::LOWEST));
-  EXPECT_TRUE(low->started());
-
-  const base::TimeDelta delay = base::TimeDelta::FromSeconds(5);
-  tick_clock_.SetNowTicks(base::TimeTicks::Now() + delay);
-
-  // Start a high priority request before |low| finishes.
-  std::unique_ptr<TestRequest> high(
-      NewRequest("http://host/high", net::HIGHEST));
-  EXPECT_TRUE(high->started());
-
-  histogram_tester.ExpectTotalCount(
-      "ResourceScheduler.DelayableRequests."
-      "WaitTimeToAvoidContentionWithNonDelayableRequest",
-      0);
-
-  // When the delayable request finishes, metrics should be recorded.
-  low.reset();
-
-  ExpectSampleIsAtLeastSpecifiedValue(
-      histogram_tester,
-      "ResourceScheduler.DelayableRequests."
-      "WaitTimeToAvoidContentionWithNonDelayableRequest",
-      delay.InMilliseconds());
-}
-
-// Starts and ends non-delayable requests to verify that the duration between
-// non-delayable requests is recorded correctly.
-TEST_F(ResourceSchedulerTest, NonDelayableToNonDelayableMetrics) {
-  base::HistogramTester histogram_tester_1;
-
-  base::TimeDelta max_queuing_time = base::TimeDelta::FromSeconds(15);
-  InitializeMaxQueuingDelayExperiment(max_queuing_time);
-
-  InitializeScheduler();
-
-  // Throw in one low priority request. When the request finishes histograms
-  // should be recorded.
-  std::unique_ptr<TestRequest> high_1(
-      NewRequest("http://host/high_1", net::HIGHEST));
-  EXPECT_TRUE(high_1->started());
-
-  const base::TimeDelta high1_start_to_high2_start =
-      base::TimeDelta::FromSeconds(5);
-  tick_clock_.SetNowTicks(base::TimeTicks::Now() + high1_start_to_high2_start);
-
-  // Start a high priority request before |high_1| finishes.
-  std::unique_ptr<TestRequest> high_2(
-      NewRequest("http://host/high_2", net::HIGHEST));
-  EXPECT_TRUE(high_2->started());
-
-  ExpectSampleIsAtLeastSpecifiedValue(
-      histogram_tester_1,
-      "ResourceScheduler.NonDelayableLastStartToNonDelayableStart",
-      high1_start_to_high2_start.InMilliseconds());
-
-  ExpectSampleIsAtLeastSpecifiedValue(
-      histogram_tester_1,
-      "ResourceScheduler.NonDelayableLastStartOrEndToNonDelayableStart",
-      high1_start_to_high2_start.InMilliseconds());
-
-  // No non-delayable request has ended yet.
-  histogram_tester_1.ExpectTotalCount(
-      "ResourceScheduler.NonDelayableLastEndToNonDelayableStart", 0);
-
-  const base::TimeDelta high2_start_to_high2_end =
-      base::TimeDelta::FromSeconds(7);
-  tick_clock_.Advance(high2_start_to_high2_end);
-
-  high_1.reset();
-  high_2.reset();
-
-  base::HistogramTester histogram_tester_2;
-
-  const base::TimeDelta high2_end_to_high3_start =
-      base::TimeDelta::FromSeconds(2);
-  tick_clock_.Advance(high2_end_to_high3_start);
-  // Start a high priority request after |high_1| and |high_2| finishes.
-  std::unique_ptr<TestRequest> high_3(
-      NewRequest("http://host/high_3", net::HIGHEST));
-  EXPECT_TRUE(high_3->started());
-  ExpectSampleIsAtLeastSpecifiedValue(
-      histogram_tester_2,
-      "ResourceScheduler.NonDelayableLastStartToNonDelayableStart",
-      (high2_start_to_high2_end + high2_end_to_high3_start).InMilliseconds());
-
-  ExpectSampleIsAtLeastSpecifiedValue(
-      histogram_tester_2,
-      "ResourceScheduler.NonDelayableLastEndToNonDelayableStart",
-      high2_end_to_high3_start.InMilliseconds());
-
-  ExpectSampleIsAtLeastSpecifiedValue(
-      histogram_tester_2,
-      "ResourceScheduler.NonDelayableLastStartOrEndToNonDelayableStart",
-      high2_end_to_high3_start.InMilliseconds());
-}
-
 }  // unnamed namespace
 
 }  // namespace network
--- a/services/network/restricted_cookie_manager.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/restricted_cookie_manager.cc	2019-05-17 18:53:37.928000000 +0300
@@ -14,15 +14,39 @@
 #include "base/strings/string_util.h"
 #include "base/threading/sequenced_task_runner_handle.h"
 #include "mojo/public/cpp/bindings/message.h"
+#include "net/base/registry_controlled_domains/registry_controlled_domain.h"
 #include "net/cookies/cookie_constants.h"
 #include "net/cookies/cookie_options.h"
 #include "net/cookies/cookie_store.h"
-#include "net/cookies/cookie_util.h"
-#include "services/network/cookie_managers_shared.h"
-#include "services/network/cookie_settings.h"
 
 namespace network {
 
+namespace {
+
+// TODO(pwnall): De-duplicate from cookie_manager.cc
+mojom::CookieChangeCause ToCookieChangeCause(net::CookieChangeCause net_cause) {
+  switch (net_cause) {
+    case net::CookieChangeCause::INSERTED:
+      return mojom::CookieChangeCause::INSERTED;
+    case net::CookieChangeCause::EXPLICIT:
+      return mojom::CookieChangeCause::EXPLICIT;
+    case net::CookieChangeCause::UNKNOWN_DELETION:
+      return mojom::CookieChangeCause::UNKNOWN_DELETION;
+    case net::CookieChangeCause::OVERWRITE:
+      return mojom::CookieChangeCause::OVERWRITE;
+    case net::CookieChangeCause::EXPIRED:
+      return mojom::CookieChangeCause::EXPIRED;
+    case net::CookieChangeCause::EVICTED:
+      return mojom::CookieChangeCause::EVICTED;
+    case net::CookieChangeCause::EXPIRED_OVERWRITE:
+      return mojom::CookieChangeCause::EXPIRED_OVERWRITE;
+  }
+  NOTREACHED();
+  return mojom::CookieChangeCause::EXPLICIT;
+}
+
+}  // anonymous namespace
+
 class RestrictedCookieManager::Listener : public base::LinkNode<Listener> {
  public:
   Listener(net::CookieStore* cookie_store,
@@ -76,14 +100,9 @@
   DISALLOW_COPY_AND_ASSIGN(Listener);
 };
 
-RestrictedCookieManager::RestrictedCookieManager(
-    net::CookieStore* cookie_store,
-    const CookieSettings* cookie_settings,
+RestrictedCookieManager::RestrictedCookieManager(net::CookieStore* cookie_store,
     const url::Origin& origin)
-    : cookie_store_(cookie_store),
-      cookie_settings_(cookie_settings),
-      origin_(origin),
-      weak_ptr_factory_(this) {
+    : cookie_store_(cookie_store), origin_(origin), weak_ptr_factory_(this) {
   DCHECK(cookie_store);
 }
 
@@ -111,18 +130,18 @@
     return;
   }
 
-  // TODO(morlovich): Try to validate site_for_cookies as well.
-
-  if (!cookie_settings_->IsCookieAccessAllowed(url, site_for_cookies)) {
-    std::move(callback).Run({});
-    return;
-  }
-
-  // TODO(https://crbug.com/925311): Wire initiator here.
   net::CookieOptions net_options;
-  net_options.set_same_site_cookie_context(
-      net::cookie_util::ComputeSameSiteContext(url, site_for_cookies,
-                                               base::nullopt /*initiator*/));
+  if (net::registry_controlled_domains::SameDomainOrHost(
+          url, site_for_cookies,
+          net::registry_controlled_domains::INCLUDE_PRIVATE_REGISTRIES)) {
+    // TODO(mkwst): This check ought to further distinguish between frames
+    // initiated in a strict or lax same-site context.
+    net_options.set_same_site_cookie_mode(
+        net::CookieOptions::SameSiteCookieMode::INCLUDE_STRICT_AND_LAX);
+  } else {
+    net_options.set_same_site_cookie_mode(
+        net::CookieOptions::SameSiteCookieMode::DO_NOT_INCLUDE);
+  }
 
   cookie_store_->GetCookieListWithOptionsAsync(
       url, net_options,
@@ -136,10 +155,12 @@
     const GURL& site_for_cookies,
     mojom::CookieManagerGetOptionsPtr options,
     GetAllForUrlCallback callback,
-    const net::CookieList& cookie_list,
-    const net::CookieStatusList& excluded_cookies) {
+    const net::CookieList& cookie_list) {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
 
+  // TODO(pwnall): Call NetworkDelegate::CanGetCookies() on a NetworkDelegate
+  //               associated with the NetworkContext.
+
   std::vector<net::CanonicalCookie> result;
   result.reserve(cookie_list.size());
   mojom::CookieMatchType match_type = options->match_type;
@@ -175,25 +196,23 @@
     return;
   }
 
-  // TODO(morlovich): Try to validate site_for_cookies as well.
-  if (!cookie_settings_->IsCookieAccessAllowed(url, site_for_cookies)) {
-    std::move(callback).Run(false);
-    return;
-  }
-
   // TODO(pwnall): Validate the CanonicalCookie fields.
 
+  // TODO(pwnall): Call NetworkDelegate::CanSetCookie() on a NetworkDelegate
+  //               associated with the NetworkContext.
   base::Time now = base::Time::NowFromSystemTime();
   auto sanitized_cookie = std::make_unique<net::CanonicalCookie>(
       cookie.Name(), cookie.Value(), cookie.Domain(), cookie.Path(), now,
       cookie.ExpiryDate(), now, cookie.IsSecure(), cookie.IsHttpOnly(),
       cookie.SameSite(), cookie.Priority());
 
-  // TODO(pwnall): source_scheme might depend on the renderer.
+  // TODO(pwnall): secure_source should depend on url, and might depend on the
+  //               renderer.
+  bool secure_source = true;
   bool modify_http_only = false;
-  cookie_store_->SetCanonicalCookieAsync(
-      std::move(sanitized_cookie), origin_.scheme(), modify_http_only,
-      AdaptCookieInclusionStatusToBool(std::move(callback)));
+  cookie_store_->SetCanonicalCookieAsync(std::move(sanitized_cookie),
+                                         secure_source, modify_http_only,
+                                         std::move(callback));
 }
 
 void RestrictedCookieManager::AddChangeListener(
@@ -207,11 +226,18 @@
     return;
   }
 
-  // TODO(https://crbug.com/925311): Wire initiator here.
   net::CookieOptions net_options;
-  net_options.set_same_site_cookie_context(
-      net::cookie_util::ComputeSameSiteContext(url, site_for_cookies,
-                                               base::nullopt /*initiator*/));
+  if (net::registry_controlled_domains::SameDomainOrHost(
+          url, site_for_cookies,
+          net::registry_controlled_domains::INCLUDE_PRIVATE_REGISTRIES)) {
+    // TODO(mkwst): This check ought to further distinguish between frames
+    // initiated in a strict or lax same-site context.
+    net_options.set_same_site_cookie_mode(
+        net::CookieOptions::SameSiteCookieMode::INCLUDE_STRICT_AND_LAX);
+  } else {
+    net_options.set_same_site_cookie_mode(
+        net::CookieOptions::SameSiteCookieMode::DO_NOT_INCLUDE);
+  }
 
   auto listener = std::make_unique<Listener>(cookie_store_, url, net_options,
                                              std::move(mojo_listener));
--- a/services/network/restricted_cookie_manager.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/restricted_cookie_manager.h	2019-05-17 18:53:37.928000000 +0300
@@ -16,7 +16,6 @@
 #include "mojo/public/cpp/bindings/binding.h"
 #include "net/cookies/canonical_cookie.h"
 #include "net/cookies/cookie_change_dispatcher.h"
-#include "net/cookies/cookie_store.h"
 #include "services/network/public/mojom/restricted_cookie_manager.mojom.h"
 #include "url/gurl.h"
 #include "url/origin.h"
@@ -27,8 +26,6 @@
 
 namespace network {
 
-class CookieSettings;
-
 // RestrictedCookieManager implementation.
 //
 // Instances of this class must be created and used on the sequence that hosts
@@ -36,9 +33,7 @@
 class COMPONENT_EXPORT(NETWORK_SERVICE) RestrictedCookieManager
     : public mojom::RestrictedCookieManager {
  public:
-  // |*cookie_store|, |*cookie_settings| must outlive this.
   RestrictedCookieManager(net::CookieStore* cookie_store,
-                          const CookieSettings* cookie_settings,
                           const url::Origin& origin);
   ~RestrictedCookieManager() override;
 
@@ -67,8 +62,7 @@
       const GURL& site_for_cookies,
       mojom::CookieManagerGetOptionsPtr options,
       GetAllForUrlCallback callback,
-      const net::CookieList& cookie_list,
-      const net::CookieStatusList& excluded_cookies);
+      const net::CookieList& cookie_list);
 
   // Called when the Mojo pipe associated with a listener is closed.
   void RemoveChangeListener(Listener* listener);
@@ -83,7 +77,6 @@
   bool ValidateAccessToCookiesAt(const GURL& url);
 
   net::CookieStore* const cookie_store_;
-  const CookieSettings* const cookie_settings_;
   const url::Origin origin_;
 
   base::LinkedList<Listener> listeners_;
--- a/services/network/restricted_cookie_manager_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/restricted_cookie_manager_unittest.cc	2019-05-17 18:53:37.928000000 +0300
@@ -6,7 +6,6 @@
 
 #include <algorithm>
 
-#include "base/bind.h"
 #include "base/message_loop/message_loop.h"
 #include "base/run_loop.h"
 #include "base/test/bind_test_util.h"
@@ -16,7 +15,6 @@
 #include "net/cookies/cookie_monster.h"
 #include "net/cookies/cookie_store.h"
 #include "net/cookies/cookie_store_test_callbacks.h"
-#include "services/network/cookie_settings.h"
 #include "services/network/public/mojom/cookie_manager.mojom.h"
 #include "testing/gmock/include/gmock/gmock-matchers.h"
 #include "testing/gtest/include/gtest/gtest.h"
@@ -87,7 +85,6 @@
       : cookie_monster_(nullptr, nullptr, nullptr /* netlog */),
         service_(std::make_unique<RestrictedCookieManager>(
             &cookie_monster_,
-            &cookie_settings_,
             url::Origin::Create(GURL("http://example.com")))),
         binding_(service_.get(), mojo::MakeRequest(&service_ptr_)) {
     sync_service_ =
@@ -107,19 +104,16 @@
 
   // Set a canonical cookie directly into the store.
   bool SetCanonicalCookie(const net::CanonicalCookie& cookie,
-                          std::string source_scheme,
+                          bool secure_source,
                           bool can_modify_httponly) {
-    net::ResultSavingCookieCallback<net::CanonicalCookie::CookieInclusionStatus>
-        callback;
+    net::ResultSavingCookieCallback<bool> callback;
     cookie_monster_.SetCanonicalCookieAsync(
-        std::make_unique<net::CanonicalCookie>(cookie),
-        std::move(source_scheme), can_modify_httponly,
-        base::BindOnce(&net::ResultSavingCookieCallback<
-                           net::CanonicalCookie::CookieInclusionStatus>::Run,
+        std::make_unique<net::CanonicalCookie>(cookie), secure_source,
+        can_modify_httponly,
+        base::BindOnce(&net::ResultSavingCookieCallback<bool>::Run,
                        base::Unretained(&callback)));
     callback.WaitUntilDone();
-    return callback.result() ==
-           net::CanonicalCookie::CookieInclusionStatus::INCLUDE;
+    return callback.result();
   }
 
   // Simplified helper for SetCanonicalCookie.
@@ -136,7 +130,7 @@
                              /* httponly = */ false,
                              net::CookieSameSite::NO_RESTRICTION,
                              net::COOKIE_PRIORITY_DEFAULT),
-        "https", /* can_modify_httponly = */ true));
+        /* secure_source = */ true, /* can_modify_httponly = */ true));
   }
 
   void ExpectBadMessage() { expecting_bad_message_ = true; }
@@ -151,7 +145,6 @@
 
   base::MessageLoopForIO message_loop_;
   net::CookieMonster cookie_monster_;
-  CookieSettings cookie_settings_;
   std::unique_ptr<RestrictedCookieManager> service_;
   mojom::RestrictedCookieManagerPtr service_ptr_;
   mojo::Binding<mojom::RestrictedCookieManager> binding_;
@@ -263,37 +256,6 @@
   ASSERT_THAT(cookies, testing::SizeIs(0));
 }
 
-TEST_F(RestrictedCookieManagerTest, GetAllForUrlPolicy) {
-  SetSessionCookie("cookie-name", "cookie-value", "example.com", "/");
-
-  // With default policy, should be able to get all cookies, even third-party.
-  {
-    auto options = mojom::CookieManagerGetOptions::New();
-    options->name = "cookie-name";
-    options->match_type = mojom::CookieMatchType::STARTS_WITH;
-
-    std::vector<net::CanonicalCookie> cookies = sync_service_->GetAllForUrl(
-        GURL("http://example.com/test/"), GURL("http://notexample.com"),
-        std::move(options));
-    ASSERT_THAT(cookies, testing::SizeIs(1));
-    EXPECT_EQ("cookie-name", cookies[0].Name());
-    EXPECT_EQ("cookie-value", cookies[0].Value());
-  }
-
-  // Disabing getting third-party cookies works correctly.
-  cookie_settings_.set_block_third_party_cookies(true);
-  {
-    auto options = mojom::CookieManagerGetOptions::New();
-    options->name = "cookie-name";
-    options->match_type = mojom::CookieMatchType::STARTS_WITH;
-
-    std::vector<net::CanonicalCookie> cookies = sync_service_->GetAllForUrl(
-        GURL("http://example.com/test/"), GURL("http://notexample.com"),
-        std::move(options));
-    ASSERT_THAT(cookies, testing::SizeIs(0));
-  }
-}
-
 TEST_F(RestrictedCookieManagerTest, SetCanonicalCookie) {
   EXPECT_TRUE(sync_service_->SetCanonicalCookie(
       net::CanonicalCookie(
@@ -328,39 +290,6 @@
   ASSERT_TRUE(received_bad_message());
 }
 
-TEST_F(RestrictedCookieManagerTest, SetCanonicalCookiePolicy) {
-  {
-    // With default settings object, setting a third-party cookie is OK.
-    auto cookie =
-        net::CanonicalCookie::Create(GURL("http://example.com"), "A=B",
-                                     base::Time::Now(), net::CookieOptions());
-    EXPECT_TRUE(sync_service_->SetCanonicalCookie(
-        *cookie, GURL("http://example.com"), GURL("http://notexample.com")));
-  }
-
-  {
-    // Not if third-party cookies are disabled, though.
-    cookie_settings_.set_block_third_party_cookies(true);
-    auto cookie =
-        net::CanonicalCookie::Create(GURL("http://example.com"), "A2=B2",
-                                     base::Time::Now(), net::CookieOptions());
-    EXPECT_FALSE(sync_service_->SetCanonicalCookie(
-        *cookie, GURL("http://example.com"), GURL("http://notexample.com")));
-  }
-
-  // Read back, in first-part context
-  auto options = mojom::CookieManagerGetOptions::New();
-  options->name = "A";
-  options->match_type = mojom::CookieMatchType::STARTS_WITH;
-
-  std::vector<net::CanonicalCookie> cookies = sync_service_->GetAllForUrl(
-      GURL("http://example.com/test/"), GURL("http://example.com/"),
-      std::move(options));
-  ASSERT_THAT(cookies, testing::SizeIs(1));
-  EXPECT_EQ("A", cookies[0].Name());
-  EXPECT_EQ("B", cookies[0].Value());
-}
-
 namespace {
 
 // Stashes the cookie changes it receives, for testing.
--- a/services/network/session_cleanup_channel_id_store_unittest.cc	2019-05-17 17:45:42.568000000 +0300
+++ b/services/network/session_cleanup_channel_id_store_unittest.cc	2019-05-17 18:53:37.928000000 +0300
@@ -77,7 +77,7 @@
       crypto::ECPrivateKey::Create());
   std::unique_ptr<crypto::ECPrivateKey> foo_key(crypto::ECPrivateKey::Create());
   store_->AddChannelID(net::DefaultChannelIDStore::ChannelID(
-      "9oo91e.qjz9zk", base::Time::FromDoubleT(1), goog_key->Copy()));
+      "google.com", base::Time::FromDoubleT(1), goog_key->Copy()));
   store_->AddChannelID(net::DefaultChannelIDStore::ChannelID(
       "foo.com", base::Time::FromDoubleT(3), foo_key->Copy()));
 
@@ -93,14 +93,14 @@
   ASSERT_EQ(2u, channel_ids.size());
   net::DefaultChannelIDStore::ChannelID* goog_channel_id;
   net::DefaultChannelIDStore::ChannelID* foo_channel_id;
-  if (channel_ids[0]->server_identifier() == "9oo91e.qjz9zk") {
+  if (channel_ids[0]->server_identifier() == "google.com") {
     goog_channel_id = channel_ids[0].get();
     foo_channel_id = channel_ids[1].get();
   } else {
     goog_channel_id = channel_ids[1].get();
     foo_channel_id = channel_ids[0].get();
   }
-  EXPECT_EQ("9oo91e.qjz9zk", goog_channel_id->server_identifier());
+  EXPECT_EQ("google.com", goog_channel_id->server_identifier());
   EXPECT_TRUE(net::KeysEqual(goog_key.get(), goog_channel_id->key()));
   EXPECT_EQ(1, goog_channel_id->creation_time().ToDoubleT());
   EXPECT_EQ("foo.com", foo_channel_id->server_identifier());
@@ -121,7 +121,7 @@
 
 TEST_F(SessionCleanupChannelIDStoreTest, TestDeleteSessionChannelIDs) {
   store_->AddChannelID(net::DefaultChannelIDStore::ChannelID(
-      "9oo91e.qjz9zk", base::Time::FromDoubleT(1),
+      "google.com", base::Time::FromDoubleT(1),
       crypto::ECPrivateKey::Create()));
   store_->AddChannelID(net::DefaultChannelIDStore::ChannelID(
       "nonpersistent.com", base::Time::FromDoubleT(3),
@@ -163,7 +163,7 @@
 
 TEST_F(SessionCleanupChannelIDStoreTest, TestForceKeepSessionState) {
   store_->AddChannelID(net::DefaultChannelIDStore::ChannelID(
-      "9oo91e.qjz9zk", base::Time::FromDoubleT(1),
+      "google.com", base::Time::FromDoubleT(1),
       crypto::ECPrivateKey::Create()));
   store_->AddChannelID(net::DefaultChannelIDStore::ChannelID(
       "nonpersistent.com", base::Time::FromDoubleT(3),
--- a/services/network/socket_data_pump.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/socket_data_pump.cc	2019-05-17 18:53:37.928000000 +0300
@@ -6,7 +6,6 @@
 
 #include <utility>
 
-#include "base/bind.h"
 #include "base/logging.h"
 #include "base/memory/ptr_util.h"
 #include "base/memory/scoped_refptr.h"
--- a/services/network/socket_data_pump_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/socket_data_pump_unittest.cc	2019-05-17 18:53:37.928000000 +0300
@@ -139,7 +139,7 @@
   DISALLOW_COPY_AND_ASSIGN(SocketDataPumpTest);
 };
 
-INSTANTIATE_TEST_SUITE_P(/* no prefix */,
+INSTANTIATE_TEST_CASE_P(/* no prefix */,
                          SocketDataPumpTest,
                          testing::Values(net::SYNCHRONOUS, net::ASYNC));
 
--- a/services/network/tcp_connected_socket.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/tcp_connected_socket.cc	2019-05-17 18:53:37.928000000 +0300
@@ -6,7 +6,6 @@
 
 #include <utility>
 
-#include "base/bind.h"
 #include "base/logging.h"
 #include "base/numerics/ranges.h"
 #include "base/numerics/safe_conversions.h"
--- a/services/network/tcp_server_socket.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/tcp_server_socket.cc	2019-05-17 18:53:37.928000000 +0300
@@ -6,7 +6,6 @@
 
 #include <utility>
 
-#include "base/bind.h"
 #include "base/logging.h"
 #include "base/memory/ptr_util.h"
 #include "base/numerics/safe_conversions.h"
--- a/services/network/tcp_socket_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/tcp_socket_unittest.cc	2019-05-17 18:53:37.928000000 +0300
@@ -7,8 +7,6 @@
 #include <utility>
 #include <vector>
 
-#include "base/bind.h"
-#include "base/bind_helpers.h"
 #include "base/callback_helpers.h"
 #include "base/location.h"
 #include "base/logging.h"
@@ -668,7 +666,7 @@
   net::MockClientSocketFactory mock_client_socket_factory_;
 };
 
-INSTANTIATE_TEST_SUITE_P(/* no prefix */,
+INSTANTIATE_TEST_CASE_P(/* no prefix */,
                          TCPSocketWithMockSocketTest,
                          testing::Values(net::SYNCHRONOUS, net::ASYNC));
 
--- a/services/network/test/test_data_pipe_getter.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/test/test_data_pipe_getter.cc	2019-05-17 18:53:37.928000000 +0300
@@ -3,7 +3,6 @@
 // found in the LICENSE file.
 
 #include "services/network/test/test_data_pipe_getter.h"
-#include "base/bind.h"
 
 #include <algorithm>
 #include <utility>
--- a/services/network/test/test_network_connection_tracker.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/test/test_network_connection_tracker.cc	2019-05-17 18:53:37.928000000 +0300
@@ -7,7 +7,6 @@
 #include <utility>
 
 #include "base/bind.h"
-#include "base/bind_helpers.h"
 #include "base/callback.h"
 #include "base/logging.h"
 #include "base/memory/ptr_util.h"
--- a/services/network/test/test_network_context.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/test/test_network_context.h	2019-05-17 18:53:37.932000000 +0300
@@ -82,8 +82,6 @@
                    const GURL& url,
                    const base::Optional<std::string>& user_agent,
                    base::Value body) override {}
-  void QueueSignedExchangeReport(
-      mojom::SignedExchangeReportPtr report) override {}
   void CloseAllConnections(CloseAllConnectionsCallback callback) override {}
   void CloseIdleConnections(CloseIdleConnectionsCallback callback) override {}
   void SetNetworkConditions(const base::UnguessableToken& throttling_profile_id,
@@ -137,8 +135,7 @@
                        int32_t process_id,
                        int32_t render_frame_id,
                        const url::Origin& origin,
-                       mojom::AuthenticationHandlerPtr auth_handler,
-                       mojom::TrustedHeaderClientPtr header_client) override {}
+                       mojom::AuthenticationHandlerPtr auth_handler) override {}
   void LookUpProxyForURL(
       const GURL& url,
       ::network::mojom::ProxyLookupClientPtr proxy_lookup_client) override {}
--- a/services/network/test/test_url_loader_client.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/test/test_url_loader_client.cc	2019-05-17 18:53:37.932000000 +0300
@@ -4,7 +4,6 @@
 
 #include "services/network/test/test_url_loader_client.h"
 
-#include "base/bind.h"
 #include "base/memory/ref_counted.h"
 #include "base/run_loop.h"
 #include "testing/gtest/include/gtest/gtest.h"
--- a/services/network/test/test_url_loader_factory.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/test/test_url_loader_factory.cc	2019-05-17 18:53:37.932000000 +0300
@@ -10,8 +10,6 @@
 #include "net/http/http_status_code.h"
 #include "services/network/public/cpp/resource_request.h"
 #include "services/network/public/cpp/resource_request_body.h"
-#include "services/network/public/cpp/weak_wrapper_shared_url_loader_factory.h"
-#include "services/network/public/mojom/url_loader.mojom.h"
 #include "services/network/test/test_utils.h"
 
 namespace network {
@@ -28,14 +26,9 @@
 TestURLLoaderFactory::Response::~Response() = default;
 TestURLLoaderFactory::Response::Response(const Response&) = default;
 
-TestURLLoaderFactory::TestURLLoaderFactory()
-    : weak_wrapper_(
-          base::MakeRefCounted<network::WeakWrapperSharedURLLoaderFactory>(
-              this)) {}
+TestURLLoaderFactory::TestURLLoaderFactory() {}
 
-TestURLLoaderFactory::~TestURLLoaderFactory() {
-  weak_wrapper_->Detach();
-}
+TestURLLoaderFactory::~TestURLLoaderFactory() {}
 
 void TestURLLoaderFactory::AddResponse(const GURL& url,
                                        const ResourceResponseHead& head,
@@ -135,11 +128,6 @@
   bindings_.AddBinding(this, std::move(request));
 }
 
-scoped_refptr<network::WeakWrapperSharedURLLoaderFactory>
-TestURLLoaderFactory::GetSafeWeakWrapper() {
-  return weak_wrapper_;
-}
-
 bool TestURLLoaderFactory::CreateLoaderAndStartInternal(
     const GURL& url,
     mojom::URLLoaderClient* client) {
--- a/services/network/test/test_url_loader_factory.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/test/test_url_loader_factory.h	2019-05-17 18:53:37.932000000 +0300
@@ -10,15 +10,12 @@
 #include <vector>
 
 #include "base/macros.h"
-#include "base/memory/ref_counted.h"
 #include "mojo/public/cpp/bindings/binding_set.h"
 #include "net/http/http_status_code.h"
 #include "services/network/public/cpp/resource_request.h"
-#include "services/network/public/mojom/url_loader.mojom.h"
 #include "services/network/public/mojom/url_loader_factory.mojom.h"
 
 namespace network {
-class WeakWrapperSharedURLLoaderFactory;
 
 // A helper class to ease testing code that uses URLLoader interface. A test
 // would pass this factory instead of the production factory to code, and
@@ -148,19 +145,6 @@
                                 traffic_annotation) override;
   void Clone(mojom::URLLoaderFactoryRequest request) override;
 
-  // Returns a 'safe' ref-counted weak wrapper around this TestURLLoaderFactory
-  // instance.
-  //
-  // Because this is a weak wrapper, it is possible for the underlying
-  // TestURLLoaderFactory instance to be destroyed while other code still holds
-  // a reference to it.
-  //
-  // The weak wrapper returned by this method is guaranteed to have had
-  // Detach() called before this is destructed, so that any future calls become
-  // no-ops, rather than a crash.
-  scoped_refptr<network::WeakWrapperSharedURLLoaderFactory>
-  GetSafeWeakWrapper();
-
  private:
   bool CreateLoaderAndStartInternal(const GURL& url,
                                     mojom::URLLoaderClient* client);
@@ -187,8 +171,6 @@
 
   std::vector<PendingRequest> pending_requests_;
 
-  scoped_refptr<network::WeakWrapperSharedURLLoaderFactory> weak_wrapper_;
-
   Interceptor interceptor_;
   mojo::BindingSet<network::mojom::URLLoaderFactory> bindings_;
 
--- a/services/network/throttling/throttling_network_interceptor.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/throttling/throttling_network_interceptor.cc	2019-05-17 18:53:37.932000000 +0300
@@ -9,7 +9,6 @@
 #include <limits>
 #include <utility>
 
-#include "base/bind.h"
 #include "base/time/time.h"
 #include "net/base/net_errors.h"
 #include "services/network/throttling/network_conditions.h"
--- a/services/network/throttling/throttling_network_transaction.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/throttling/throttling_network_transaction.cc	2019-05-17 18:53:37.932000000 +0300
@@ -6,7 +6,6 @@
 
 #include <utility>
 
-#include "base/bind.h"
 #include "base/callback_helpers.h"
 #include "net/base/load_timing_info.h"
 #include "net/base/net_errors.h"
--- a/services/network/throttling/throttling_upload_data_stream.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/throttling/throttling_upload_data_stream.cc	2019-05-17 18:53:37.932000000 +0300
@@ -4,7 +4,6 @@
 
 #include "services/network/throttling/throttling_upload_data_stream.h"
 
-#include "base/bind.h"
 #include "net/base/net_errors.h"
 
 namespace network {
--- a/services/network/tls_client_socket.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/tls_client_socket.cc	2019-05-17 18:53:37.932000000 +0300
@@ -6,13 +6,12 @@
 
 #include <utility>
 
-#include "base/bind.h"
 #include "base/logging.h"
 #include "base/memory/ptr_util.h"
 #include "net/base/net_errors.h"
 #include "net/socket/client_socket_factory.h"
+#include "net/socket/client_socket_handle.h"
 #include "net/socket/ssl_client_socket.h"
-#include "net/socket/stream_socket.h"
 #include "net/ssl/ssl_config.h"
 #include "net/ssl/ssl_config_service.h"
 
@@ -29,7 +28,7 @@
 void TLSClientSocket::Connect(
     const net::HostPortPair& host_port_pair,
     const net::SSLConfig& ssl_config,
-    std::unique_ptr<net::StreamSocket> tcp_socket,
+    std::unique_ptr<net::ClientSocketHandle> tcp_socket,
     const net::SSLClientSocketContext& ssl_client_socket_context,
     net::ClientSocketFactory* socket_factory,
     mojom::TCPConnectedSocket::UpgradeToTLSCallback callback,
--- a/services/network/tls_client_socket.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/tls_client_socket.h	2019-05-17 18:53:37.932000000 +0300
@@ -19,9 +19,9 @@
 #include "services/network/socket_data_pump.h"
 
 namespace net {
-class ClientSocketFactory;
 class SSLClientSocket;
-class StreamSocket;
+class ClientSocketHandle;
+class ClientSocketFactory;
 }  // namespace net
 
 namespace network {
@@ -37,7 +37,7 @@
 
   void Connect(const net::HostPortPair& host_port_pair,
                const net::SSLConfig& ssl_config,
-               std::unique_ptr<net::StreamSocket> tcp_socket,
+               std::unique_ptr<net::ClientSocketHandle> tcp_socket,
                const net::SSLClientSocketContext& ssl_client_socket_context,
                net::ClientSocketFactory* socket_factory,
                mojom::TCPConnectedSocket::UpgradeToTLSCallback callback,
--- a/services/network/tls_client_socket_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/tls_client_socket_unittest.cc	2019-05-17 18:53:37.936000000 +0300
@@ -8,7 +8,6 @@
 #include <utility>
 #include <vector>
 
-#include "base/bind.h"
 #include "base/logging.h"
 #include "base/macros.h"
 #include "base/run_loop.h"
@@ -871,7 +870,7 @@
   EXPECT_TRUE(data_provider.AllWriteDataConsumed());
 }
 
-INSTANTIATE_TEST_SUITE_P(
+INSTANTIATE_TEST_CASE_P(
     /* no prefix */,
     TLSClientSocketTest,
     ::testing::Values(TLSClientSocketTestBase::kDirect,
@@ -951,7 +950,7 @@
   DISALLOW_COPY_AND_ASSIGN(TLSClientSocketIoModeTest);
 };
 
-INSTANTIATE_TEST_SUITE_P(/* no prefix */,
+INSTANTIATE_TEST_CASE_P(/* no prefix */,
                          TLSClientSocketIoModeTest,
                          testing::Values(net::SYNCHRONOUS, net::ASYNC));
 
@@ -1178,7 +1177,7 @@
   EXPECT_FALSE(post_tls_send_handle()->is_valid());
 }
 
-INSTANTIATE_TEST_SUITE_P(
+INSTANTIATE_TEST_CASE_P(
     /* no prefix */,
     TLSClientSocketTestWithEmbeddedTestServer,
     ::testing::Values(TLSClientSocketTestBase::kDirect,
--- a/services/network/tls_socket_factory.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/tls_socket_factory.cc	2019-05-17 18:53:37.936000000 +0300
@@ -16,7 +16,7 @@
 #include "net/cert/ct_policy_enforcer.h"
 #include "net/cert/multi_log_ct_verifier.h"
 #include "net/socket/client_socket_factory.h"
-#include "net/socket/stream_socket.h"
+#include "net/socket/client_socket_handle.h"
 #include "net/ssl/ssl_config.h"
 #include "net/ssl/ssl_config_service.h"
 #include "net/url_request/url_request_context.h"
@@ -53,7 +53,7 @@
           url_request_context->transport_security_state(),
           url_request_context->cert_transparency_verifier(),
           url_request_context->ct_policy_enforcer(),
-          nullptr /* Disables SSL session caching */),
+          std::string() /* TODO(rsleevi): Ensure a proper unique shard. */),
       client_socket_factory_(nullptr),
       ssl_config_service_(url_request_context->ssl_config_service()) {
   if (http_context) {
@@ -86,9 +86,11 @@
         mojo::ScopedDataPipeProducerHandle(), base::nullopt);
     return;
   }
+  auto socket_handle = std::make_unique<net::ClientSocketHandle>();
+  socket_handle->SetSocket(socket_delegate->TakeSocket());
   CreateTLSClientSocket(
       host_port_pair, std::move(socket_options), std::move(request),
-      socket_delegate->TakeSocket(), std::move(observer),
+      std::move(socket_handle), std::move(observer),
       static_cast<net::NetworkTrafficAnnotationTag>(traffic_annotation),
       std::move(callback));
 }
@@ -97,7 +99,7 @@
     const net::HostPortPair& host_port_pair,
     mojom::TLSClientSocketOptionsPtr socket_options,
     mojom::TLSClientSocketRequest request,
-    std::unique_ptr<net::StreamSocket> underlying_socket,
+    std::unique_ptr<net::ClientSocketHandle> underlying_socket,
     mojom::SocketObserverPtr observer,
     const net::NetworkTrafficAnnotationTag& traffic_annotation,
     mojom::TCPConnectedSocket::UpgradeToTLSCallback callback) {
--- a/services/network/tls_socket_factory.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/tls_socket_factory.h	2019-05-17 18:53:37.936000000 +0300
@@ -18,9 +18,9 @@
 #include "services/network/public/mojom/tls_socket.mojom.h"
 
 namespace net {
+class ClientSocketHandle;
 class ClientSocketFactory;
 class SSLConfigService;
-class StreamSocket;
 }  // namespace net
 
 namespace network {
@@ -69,7 +69,7 @@
       const net::HostPortPair& host_port_pair,
       mojom::TLSClientSocketOptionsPtr socket_options,
       mojom::TLSClientSocketRequest request,
-      std::unique_ptr<net::StreamSocket> underlying_socket,
+      std::unique_ptr<net::ClientSocketHandle> socket,
       mojom::SocketObserverPtr observer,
       const net::NetworkTrafficAnnotationTag& traffic_annotation,
       mojom::TCPConnectedSocket::UpgradeToTLSCallback callback);
--- a/services/network/transitional_url_loader_factory_owner.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/transitional_url_loader_factory_owner.cc	2019-05-17 18:53:37.936000000 +0300
@@ -4,7 +4,6 @@
 
 #include "services/network/transitional_url_loader_factory_owner.h"
 
-#include "base/bind.h"
 #include "base/memory/ptr_util.h"
 #include "base/memory/ref_counted.h"
 #include "base/memory/ref_counted_delete_on_sequence.h"
--- a/services/network/udp_socket.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/udp_socket.cc	2019-05-17 18:53:37.936000000 +0300
@@ -7,7 +7,6 @@
 #include <algorithm>
 #include <utility>
 
-#include "base/bind.h"
 #include "base/logging.h"
 #include "base/numerics/checked_math.h"
 #include "base/numerics/ranges.h"
--- a/services/network/udp_socket_unittest.cc	2019-05-17 17:45:42.568000000 +0300
+++ b/services/network/udp_socket_unittest.cc	2019-05-17 18:53:37.936000000 +0300
@@ -10,7 +10,6 @@
 
 #include "services/network/udp_socket.h"
 
-#include "base/bind.h"
 #include "base/logging.h"
 #include "base/macros.h"
 #include "base/run_loop.h"
@@ -662,7 +661,7 @@
 #if defined(OS_ANDROID)
 // Some Android devices do not support multicast socket.
 // The ones supporting multicast need WifiManager.MulticastLock to enable it.
-// https://developer.8n6r01d.qjz9zk/reference/android/net/wifi/WifiManager.MulticastLock.html
+// https://developer.android.com/reference/android/net/wifi/WifiManager.MulticastLock.html
 #define MAYBE_JoinMulticastGroup DISABLED_JoinMulticastGroup
 #else
 #define MAYBE_JoinMulticastGroup JoinMulticastGroup
--- a/services/network/url_loader.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/url_loader.cc	2019-05-17 18:53:37.936000000 +0300
@@ -4,15 +4,14 @@
 
 #include "services/network/url_loader.h"
 
-#include <algorithm>
 #include <limits>
 #include <string>
 #include <utility>
 #include <vector>
 
-#include "base/bind.h"
-#include "base/bind_helpers.h"
 #include "base/command_line.h"
+#include "base/debug/alias.h"
+#include "base/debug/dump_without_crashing.h"
 #include "base/files/file.h"
 #include "base/logging.h"
 #include "base/memory/weak_ptr.h"
@@ -23,10 +22,10 @@
 #include "base/time/time.h"
 #include "mojo/public/cpp/system/simple_watcher.h"
 #include "net/base/elements_upload_data_stream.h"
-#include "net/base/ip_endpoint.h"
 #include "net/base/mime_sniffer.h"
 #include "net/base/upload_bytes_element_reader.h"
 #include "net/base/upload_file_element_reader.h"
+#include "net/cert/symantec_certs.h"
 #include "net/ssl/client_cert_store.h"
 #include "net/ssl/ssl_connection_status_flags.h"
 #include "net/ssl/ssl_private_key.h"
@@ -51,13 +50,15 @@
 namespace network {
 
 namespace {
+
 constexpr size_t kDefaultAllocationSize = 512 * 1024;
 
 // Cannot use 0, because this means "default" in
 // mojo::core::Core::CreateDataPipe
 constexpr size_t kBlockedBodyAllocationSize = 1;
 
-constexpr size_t kMaxFileUploadRequestsPerBatch = 64;
+// Used to dump when we get too many requests, once.
+bool g_reported_too_many_requests = false;
 
 // TODO: this duplicates some of PopulateResourceResponse in
 // content/browser/loader/resource_loader.cc
@@ -77,7 +78,7 @@
   response->head.alpn_negotiated_protocol =
       response_info.alpn_negotiated_protocol;
   response->head.connection_info = response_info.connection_info;
-  response->head.remote_endpoint = response_info.remote_endpoint;
+  response->head.socket_address = response_info.socket_address;
   response->head.was_fetched_via_cache = request->was_cached();
   response->head.proxy_server = request->proxy_server();
   response->head.network_accessed = response_info.network_accessed;
@@ -93,6 +94,10 @@
   if (request->ssl_info().cert.get()) {
     response->head.ct_policy_compliance =
         request->ssl_info().ct_policy_compliance;
+    response->head.is_legacy_symantec_cert =
+        (!net::IsCertStatusError(response->head.cert_status) ||
+         net::IsCertStatusMinorError(response->head.cert_status)) &&
+        net::IsLegacySymantecCert(request->ssl_info().public_key_hashes);
     response->head.cert_status = request->ssl_info().cert_status;
     net::SSLVersion ssl_version = net::SSLConnectionStatusToVersion(
         request->ssl_info().connection_status);
@@ -446,6 +451,18 @@
   if (keepalive_ && keepalive_statistics_recorder_)
     keepalive_statistics_recorder_->OnLoadStarted(factory_params_->process_id);
 
+  // Record some debug info in hope of tracing down leaks.
+  int32_t annotation_hash =
+      url_request_->traffic_annotation().unique_id_hash_code;
+  size_t num_running_requests = url_request_context_->url_requests()->size();
+  base::debug::Alias(&annotation_hash);
+  base::debug::Alias(&num_running_requests);
+  DEBUG_ALIAS_FOR_GURL(url_buf, url_request_->url());
+  if (!g_reported_too_many_requests && num_running_requests > 10000) {
+    g_reported_too_many_requests = true;
+    base::debug::DumpWithoutCrashing();
+  }
+
   // Resolve elements from request_body and prepare upload data.
   if (request.request_body.get()) {
     OpenFilesForUpload(request);
@@ -454,109 +471,6 @@
   ScheduleStart();
 }
 
-// This class is used to manage the queue of pending file upload operations
-// initiated by the URLLoader::OpenFilesForUpload().
-class URLLoader::FileOpenerForUpload {
- public:
-  typedef base::OnceCallback<void(int, std::vector<base::File>)>
-      SetUpUploadCallback;
-
-  FileOpenerForUpload(std::vector<base::FilePath> paths,
-                      URLLoader* url_loader,
-                      uint32_t process_id,
-                      mojom::NetworkServiceClient* network_service_client,
-                      SetUpUploadCallback set_up_upload_callback)
-      : paths_(std::move(paths)),
-        url_loader_(url_loader),
-        process_id_(process_id),
-        network_service_client_(network_service_client),
-        set_up_upload_callback_(std::move(set_up_upload_callback)),
-        weak_ptr_factory_(this) {
-    StartOpeningNextBatch();
-  }
-
-  ~FileOpenerForUpload() {
-    if (!opened_files_.empty())
-      PostCloseFiles(std::move(opened_files_));
-  }
-
- private:
-  static void OnFilesForUploadOpened(
-      base::WeakPtr<FileOpenerForUpload> file_opener,
-      size_t num_files_requested,
-      int error_code,
-      std::vector<base::File> opened_files) {
-    if (!file_opener) {
-      PostCloseFiles(std::move(opened_files));
-      return;
-    }
-
-    if (error_code == net::OK && num_files_requested != opened_files.size())
-      error_code = net::ERR_FAILED;
-
-    if (error_code != net::OK) {
-      PostCloseFiles(std::move(opened_files));
-      file_opener->FilesForUploadOpenedDone(error_code);
-      return;
-    }
-
-    for (base::File& file : opened_files)
-      file_opener->opened_files_.push_back(std::move(file));
-
-    if (file_opener->opened_files_.size() < file_opener->paths_.size()) {
-      file_opener->StartOpeningNextBatch();
-      return;
-    }
-
-    file_opener->FilesForUploadOpenedDone(net::OK);
-  }
-
-  // |opened_files| need to be closed on a blocking task runner, so move
-  // the |opened_files| vector onto a sequence that can block so it gets
-  // destroyed there.
-  static void PostCloseFiles(std::vector<base::File> opened_files) {
-    base::PostTaskWithTraits(
-        FROM_HERE, {base::MayBlock(), base::TaskPriority::USER_BLOCKING},
-        base::BindOnce(base::DoNothing::Once<std::vector<base::File>>(),
-                       std::move(opened_files)));
-  }
-
-  void StartOpeningNextBatch() {
-    size_t num_files_to_request = std::min(paths_.size() - opened_files_.size(),
-                                           kMaxFileUploadRequestsPerBatch);
-    std::vector<base::FilePath> batch_paths(
-        paths_.begin() + opened_files_.size(),
-        paths_.begin() + opened_files_.size() + num_files_to_request);
-
-    network_service_client_->OnFileUploadRequested(
-        process_id_, /*async=*/true, batch_paths,
-        base::BindOnce(&FileOpenerForUpload::OnFilesForUploadOpened,
-                       weak_ptr_factory_.GetWeakPtr(), num_files_to_request));
-  }
-
-  void FilesForUploadOpenedDone(int error_code) {
-    url_loader_->url_request_->LogUnblocked();
-
-    if (error_code == net::OK)
-      std::move(set_up_upload_callback_).Run(net::OK, std::move(opened_files_));
-    else
-      std::move(set_up_upload_callback_).Run(error_code, {});
-  }
-
-  // The paths of files for upload
-  const std::vector<base::FilePath> paths_;
-  URLLoader* const url_loader_;
-  const uint32_t process_id_;
-  mojom::NetworkServiceClient* const network_service_client_;
-  SetUpUploadCallback set_up_upload_callback_;
-  // The files opened so far.
-  std::vector<base::File> opened_files_;
-
-  base::WeakPtrFactory<FileOpenerForUpload> weak_ptr_factory_;
-
-  DISALLOW_COPY_AND_ASSIGN(FileOpenerForUpload);
-};
-
 void URLLoader::OpenFilesForUpload(const ResourceRequest& request) {
   std::vector<base::FilePath> paths;
   for (const auto& element : *request.request_body.get()->elements()) {
@@ -577,10 +491,28 @@
     return;
   }
   url_request_->LogBlockedBy("Opening Files");
-  file_opener_for_upload_ = std::make_unique<FileOpenerForUpload>(
-      std::move(paths), this, factory_params_->process_id,
-      network_service_client_,
-      base::BindOnce(&URLLoader::SetUpUpload, base::Unretained(this), request));
+  network_service_client_->OnFileUploadRequested(
+      factory_params_->process_id, true /* async */, paths,
+      base::BindOnce(&OnFilesForUploadOpened, weak_ptr_factory_.GetWeakPtr(),
+                     request));
+}
+
+// static
+void URLLoader::OnFilesForUploadOpened(base::WeakPtr<URLLoader> self,
+                                       const ResourceRequest& request,
+                                       int error_code,
+                                       std::vector<base::File> opened_files) {
+  // If the URLLoader was already deleted, move the opened_files vector onto a
+  // sequence that can block so it gets destroyed there.
+  if (self) {
+    self->url_request_->LogUnblocked();
+    self->SetUpUpload(request, error_code, std::move(opened_files));
+  } else {
+    base::PostTaskWithTraits(
+        FROM_HERE, {base::MayBlock(), base::TaskPriority::USER_BLOCKING},
+        base::BindOnce(base::DoNothing::Once<std::vector<base::File>>(),
+                       std::move(opened_files)));
+  }
 }
 
 void URLLoader::SetUpUpload(const ResourceRequest& request,
@@ -1140,10 +1072,6 @@
   report_raw_headers_ = want_raw_headers_ && allow;
 }
 
-uint32_t URLLoader::GetResourceType() const {
-  return resource_type_;
-}
-
 // static
 URLLoader* URLLoader::ForRequest(const net::URLRequest& request) {
   auto* pointer =
--- a/services/network/url_loader_factory.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/url_loader_factory.cc	2019-05-17 18:53:37.936000000 +0300
@@ -8,7 +8,6 @@
 #include <string>
 #include <utility>
 
-#include "base/bind.h"
 #include "base/logging.h"
 #include "base/metrics/histogram_macros.h"
 #include "base/optional.h"
--- a/services/network/url_loader.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/url_loader.h	2019-05-17 18:53:37.936000000 +0300
@@ -114,7 +114,6 @@
 
   uint32_t GetRenderFrameId() const;
   uint32_t GetProcessId() const;
-  uint32_t GetResourceType() const;
 
   const net::HttpRequestHeaders& custom_proxy_pre_cache_headers() const {
     return custom_proxy_pre_cache_headers_;
@@ -156,9 +155,10 @@
     DISALLOW_COPY_AND_ASSIGN(UnownedPointer);
   };
 
-  class FileOpenerForUpload;
-  friend class FileOpenerForUpload;
-
+  static void OnFilesForUploadOpened(base::WeakPtr<URLLoader> self,
+                                     const ResourceRequest& request,
+                                     int error_code,
+                                     std::vector<base::File> opened_files);
   void OpenFilesForUpload(const ResourceRequest& request);
   void SetUpUpload(const ResourceRequest& request,
                    int error_code,
@@ -321,8 +321,6 @@
 
   mojom::TrustedHeaderClientPtr header_client_;
 
-  std::unique_ptr<FileOpenerForUpload> file_opener_for_upload_;
-
   base::WeakPtrFactory<URLLoader> weak_ptr_factory_;
 
   DISALLOW_COPY_AND_ASSIGN(URLLoader);
--- a/services/network/url_loader_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/url_loader_unittest.cc	2019-05-17 18:53:37.936000000 +0300
@@ -11,8 +11,6 @@
 #include <utility>
 #include <vector>
 
-#include "base/bind.h"
-#include "base/bind_helpers.h"
 #include "base/compiler_specific.h"
 #include "base/files/file.h"
 #include "base/files/file_path.h"
--- a/services/network/websocket.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/websocket.cc	2019-05-17 18:53:37.936000000 +0300
@@ -20,7 +20,6 @@
 #include "base/threading/thread_task_runner_handle.h"
 #include "net/base/auth.h"
 #include "net/base/io_buffer.h"
-#include "net/base/ip_endpoint.h"
 #include "net/base/net_errors.h"
 #include "net/http/http_request_headers.h"
 #include "net/http/http_response_headers.h"
@@ -105,7 +104,7 @@
   int OnAuthRequired(
       scoped_refptr<net::AuthChallengeInfo> auth_info,
       scoped_refptr<net::HttpResponseHeaders> response_headers,
-      const net::IPEndPoint& remote_endpoint,
+      const net::HostPortPair& host_port_pair,
       base::OnceCallback<void(const net::AuthCredentials*)> callback,
       base::Optional<net::AuthCredentials>* credentials) override;
 
@@ -128,8 +127,6 @@
 
 void WebSocket::WebSocketEventHandler::OnCreateURLRequest(
     net::URLRequest* url_request) {
-  url_request->SetUserData(WebSocket::kUserDataKey,
-                           std::make_unique<UnownedPointer>(impl_));
   impl_->delegate_->OnCreateURLRequest(impl_->child_id_, impl_->frame_id_,
                                        url_request);
 }
@@ -253,7 +250,7 @@
   response_to_pass->status_code = response->headers->response_code();
   response_to_pass->status_text = response->headers->GetStatusText();
   response_to_pass->http_version = response->headers->GetHttpVersion();
-  response_to_pass->remote_endpoint = response->remote_endpoint;
+  response_to_pass->socket_address = response->socket_address;
   size_t iter = 0;
   std::string name, value;
   std::string headers_text =
@@ -289,7 +286,7 @@
 int WebSocket::WebSocketEventHandler::OnAuthRequired(
     scoped_refptr<net::AuthChallengeInfo> auth_info,
     scoped_refptr<net::HttpResponseHeaders> response_headers,
-    const net::IPEndPoint& remote_endpoint,
+    const net::HostPortPair& host_port_pair,
     base::OnceCallback<void(const net::AuthCredentials*)> callback,
     base::Optional<net::AuthCredentials>* credentials) {
   DVLOG(3) << "WebSocketEventHandler::OnAuthRequired"
@@ -300,7 +297,7 @@
   }
 
   impl_->auth_handler_->OnAuthRequired(
-      std::move(auth_info), std::move(response_headers), remote_endpoint,
+      std::move(auth_info), std::move(response_headers), host_port_pair,
       base::BindOnce(&WebSocket::OnAuthRequiredComplete,
                      impl_->weak_ptr_factory_.GetWeakPtr(),
                      std::move(callback)));
@@ -311,7 +308,6 @@
     std::unique_ptr<Delegate> delegate,
     mojom::WebSocketRequest request,
     mojom::AuthenticationHandlerPtr auth_handler,
-    mojom::TrustedHeaderClientPtr header_client,
     WebSocketThrottler::PendingConnection pending_connection_tracker,
     int child_id,
     int frame_id,
@@ -320,7 +316,6 @@
     : delegate_(std::move(delegate)),
       binding_(this, std::move(request)),
       auth_handler_(std::move(auth_handler)),
-      header_client_(std::move(header_client)),
       pending_connection_tracker_(std::move(pending_connection_tracker)),
       delay_(delay),
       pending_flow_control_quota_(0),
@@ -331,20 +326,10 @@
       weak_ptr_factory_(this) {
   binding_.set_connection_error_handler(
       base::BindOnce(&WebSocket::OnConnectionError, base::Unretained(this)));
-
-  if (header_client_) {
-    // Make sure the request dies if |header_client_| has an error, otherwise
-    // requests can hang.
-    header_client_.set_connection_error_handler(
-        base::BindOnce(&WebSocket::OnConnectionError, base::Unretained(this)));
-  }
 }
 
 WebSocket::~WebSocket() {}
 
-// static
-const void* const WebSocket::kUserDataKey = &WebSocket::kUserDataKey;
-
 void WebSocket::GoAway() {
   StartClosingHandshake(static_cast<uint16_t>(net::kWebSocketErrorGoingAway),
                         "");
@@ -449,43 +434,6 @@
   ignore_result(channel_->StartClosingHandshake(code, reason));
 }
 
-int WebSocket::OnBeforeStartTransaction(net::CompletionOnceCallback callback,
-                                        net::HttpRequestHeaders* headers) {
-  if (header_client_) {
-    header_client_->OnBeforeSendHeaders(
-        *headers, base::BindOnce(&WebSocket::OnBeforeSendHeadersComplete,
-                                 weak_ptr_factory_.GetWeakPtr(),
-                                 std::move(callback), headers));
-    return net::ERR_IO_PENDING;
-  }
-  return net::OK;
-}
-
-int WebSocket::OnHeadersReceived(
-    net::CompletionOnceCallback callback,
-    const net::HttpResponseHeaders* original_response_headers,
-    scoped_refptr<net::HttpResponseHeaders>* override_response_headers,
-    GURL* allowed_unsafe_redirect_url) {
-  if (header_client_) {
-    header_client_->OnHeadersReceived(
-        original_response_headers->raw_headers(),
-        base::BindOnce(&WebSocket::OnHeadersReceivedComplete,
-                       weak_ptr_factory_.GetWeakPtr(), std::move(callback),
-                       override_response_headers, allowed_unsafe_redirect_url));
-    return net::ERR_IO_PENDING;
-  }
-  return net::OK;
-}
-
-// static
-WebSocket* WebSocket::ForRequest(const net::URLRequest& request) {
-  auto* pointer =
-      static_cast<UnownedPointer*>(request.GetUserData(kUserDataKey));
-  if (!pointer)
-    return nullptr;
-  return pointer->get();
-}
-
 void WebSocket::OnConnectionError() {
   DVLOG(3) << "WebSocket::OnConnectionError @" << reinterpret_cast<void*>(this);
 
@@ -543,36 +491,4 @@
   std::move(callback).Run(credentials ? &*credentials : nullptr);
 }
 
-void WebSocket::OnBeforeSendHeadersComplete(
-    net::CompletionOnceCallback callback,
-    net::HttpRequestHeaders* out_headers,
-    int result,
-    const base::Optional<net::HttpRequestHeaders>& headers) {
-  if (!channel_) {
-    // Something happened before the OnBeforeSendHeaders response arrives.
-    return;
-  }
-  if (headers)
-    *out_headers = headers.value();
-  std::move(callback).Run(result);
-}
-
-void WebSocket::OnHeadersReceivedComplete(
-    net::CompletionOnceCallback callback,
-    scoped_refptr<net::HttpResponseHeaders>* out_headers,
-    GURL* out_allowed_unsafe_redirect_url,
-    int result,
-    const base::Optional<std::string>& headers,
-    const GURL& allowed_unsafe_redirect_url) {
-  if (!channel_) {
-    // Something happened before the OnHeadersReceived response arrives.
-    return;
-  }
-  if (headers) {
-    *out_headers =
-        base::MakeRefCounted<net::HttpResponseHeaders>(headers.value());
-  }
-  std::move(callback).Run(result);
-}
-
 }  // namespace network
--- a/services/network/websocket_factory.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/websocket_factory.cc	2019-05-17 18:53:37.940000000 +0300
@@ -4,10 +4,8 @@
 
 #include "services/network/websocket_factory.h"
 
-#include "base/bind.h"
 #include "base/memory/weak_ptr.h"
 #include "mojo/public/cpp/bindings/strong_binding.h"
-#include "net/base/url_util.h"
 #include "services/network/network_context.h"
 #include "services/network/network_service.h"
 #include "services/network/public/mojom/network_service.mojom.h"
@@ -64,7 +62,10 @@
 
   bool CanReadRawCookies(const GURL& url) override {
     DCHECK(url.SchemeIsWSOrWSS());
-    GURL url_to_check = net::ChangeWebSocketSchemeToHttpScheme(url);
+    GURL::Replacements replace_scheme;
+    replace_scheme.SetSchemeStr(
+        url.SchemeIs(url::kWssScheme) ? url::kHttpsScheme : url::kHttpScheme);
+    GURL url_to_check = url.ReplaceComponents(replace_scheme);
     return factory_->context_->network_service()->HasRawHeadersAccess(
         process_id_, url_to_check);
   }
@@ -102,7 +103,6 @@
 void WebSocketFactory::CreateWebSocket(
     mojom::WebSocketRequest request,
     mojom::AuthenticationHandlerPtr auth_handler,
-    mojom::TrustedHeaderClientPtr header_client,
     int32_t process_id,
     int32_t render_frame_id,
     const url::Origin& origin) {
@@ -115,7 +115,7 @@
   }
   connections_.insert(std::make_unique<WebSocket>(
       std::make_unique<Delegate>(this, process_id), std::move(request),
-      std::move(auth_handler), std::move(header_client),
+      std::move(auth_handler),
       throttler_.IssuePendingConnectionTracker(process_id), process_id,
       render_frame_id, origin, throttler_.CalculateDelay(process_id)));
 }
--- a/services/network/websocket_factory.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/websocket_factory.h	2019-05-17 18:53:37.940000000 +0300
@@ -9,7 +9,6 @@
 
 #include "base/containers/unique_ptr_adapters.h"
 #include "mojo/public/cpp/bindings/binding.h"
-#include "services/network/public/mojom/network_context.mojom.h"
 #include "services/network/public/mojom/websocket.mojom.h"
 #include "services/network/websocket.h"
 #include "services/network/websocket_throttler.h"
@@ -29,7 +28,6 @@
 
   void CreateWebSocket(mojom::WebSocketRequest request,
                        mojom::AuthenticationHandlerPtr auth_handler,
-                       mojom::TrustedHeaderClientPtr header_client,
                        int32_t process_id,
                        int32_t render_frame_id,
                        const url::Origin& origin);
--- a/services/network/websocket.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/network/websocket.h	2019-05-17 18:53:37.940000000 +0300
@@ -17,7 +17,6 @@
 #include "base/time/time.h"
 #include "mojo/public/cpp/bindings/binding.h"
 #include "net/websockets/websocket_event_interface.h"
-#include "services/network/public/mojom/network_context.mojom.h"
 #include "services/network/public/mojom/websocket.mojom.h"
 #include "services/network/websocket_throttler.h"
 #include "url/origin.h"
@@ -65,7 +64,6 @@
   WebSocket(std::unique_ptr<Delegate> delegate,
             mojom::WebSocketRequest request,
             mojom::AuthenticationHandlerPtr auth_handler,
-            mojom::TrustedHeaderClientPtr header_client,
             WebSocketThrottler::PendingConnection pending_connection_tracker,
             int child_id,
             int frame_id,
@@ -91,40 +89,9 @@
 
   bool handshake_succeeded() const { return handshake_succeeded_; }
 
-  // These methods are called by the network delegate to forward these events to
-  // the |header_client_|.
-  int OnBeforeStartTransaction(net::CompletionOnceCallback callback,
-                               net::HttpRequestHeaders* headers);
-  int OnHeadersReceived(
-      net::CompletionOnceCallback callback,
-      const net::HttpResponseHeaders* original_response_headers,
-      scoped_refptr<net::HttpResponseHeaders>* override_response_headers,
-      GURL* allowed_unsafe_redirect_url);
-
-  // Gets the WebSocket associated with this request.
-  static WebSocket* ForRequest(const net::URLRequest& request);
-
-  static const void* const kUserDataKey;
-
  protected:
   class WebSocketEventHandler;
 
-  // This class is used to set the WebSocket as user data on a URLRequest. This
-  // is used instead of WebSocket directly because SetUserData requires a
-  // std::unique_ptr. This is safe because WebSocket owns the URLRequest, so is
-  // guaranteed to outlive it.
-  class UnownedPointer : public base::SupportsUserData::Data {
-   public:
-    explicit UnownedPointer(WebSocket* pointer) : pointer_(pointer) {}
-
-    WebSocket* get() const { return pointer_; }
-
-   private:
-    WebSocket* const pointer_;
-
-    DISALLOW_COPY_AND_ASSIGN(UnownedPointer);
-  };
-
   void OnConnectionError();
   void AddChannel(const GURL& socket_url,
                   const std::vector<std::string>& requested_protocols,
@@ -133,25 +100,12 @@
   void OnAuthRequiredComplete(
       base::OnceCallback<void(const net::AuthCredentials*)> callback,
       const base::Optional<net::AuthCredentials>& credential);
-  void OnBeforeSendHeadersComplete(
-      net::CompletionOnceCallback callback,
-      net::HttpRequestHeaders* out_headers,
-      int result,
-      const base::Optional<net::HttpRequestHeaders>& headers);
-  void OnHeadersReceivedComplete(
-      net::CompletionOnceCallback callback,
-      scoped_refptr<net::HttpResponseHeaders>* out_headers,
-      GURL* out_allowed_unsafe_redirect_url,
-      int result,
-      const base::Optional<std::string>& headers,
-      const GURL& allowed_unsafe_redirect_url);
 
   std::unique_ptr<Delegate> delegate_;
   mojo::Binding<mojom::WebSocket> binding_;
 
   mojom::WebSocketClientPtr client_;
   mojom::AuthenticationHandlerPtr auth_handler_;
-  mojom::TrustedHeaderClientPtr header_client_;
 
   WebSocketThrottler::PendingConnection pending_connection_tracker_;
 
--- a/services/preferences/BUILD.gn	2019-05-01 01:22:56.000000000 +0300
+++ b/services/preferences/BUILD.gn	2019-05-17 18:53:37.940000000 +0300
@@ -2,8 +2,20 @@
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
+import("//services/catalog/public/tools/catalog.gni")
+import("//services/service_manager/public/service_manifest.gni")
 import("//testing/test.gni")
 
+service_manifest("manifest") {
+  name = "preferences"
+  source = "manifest.json"
+}
+
+service_manifest("local_state_manifest") {
+  name = "local_state"
+  source = "local_state_manifest.json"
+}
+
 source_set("preferences") {
   visibility = [
     ":*",
@@ -58,9 +70,33 @@
   if (!is_ios) {
     sources += [ "pref_service_factory_unittest.cc" ]
     deps += [
-      "//services/preferences/public/cpp:manifest",
+      ":tests_catalog_source",
       "//services/service_manager/public/cpp/test:test_support",
-      "//services/service_manager/public/mojom",
     ]
   }
 }
+
+service_manifest("unittest_manifest") {
+  name = "prefs_unittests"
+  source = "unittest_manifest.json"
+  packaged_services = [
+    ":manifest",
+    ":unittest_helper_manifest",
+  ]
+}
+
+service_manifest("unittest_helper_manifest") {
+  name = "prefs_unittest_helper"
+  source = "unittest_helper_manifest.json"
+}
+
+catalog("tests_catalog") {
+  testonly = true
+  embedded_services = [ ":unittest_manifest" ]
+}
+
+catalog_cpp_source("tests_catalog_source") {
+  testonly = true
+  catalog = ":tests_catalog"
+  generated_function_name = "prefs::CreateServiceTestCatalog"
+}
--- a/services/preferences/OWNERS	2019-05-01 01:22:56.000000000 +0300
+++ b/services/preferences/OWNERS	2019-05-17 18:53:37.940000000 +0300
@@ -1,3 +1,15 @@
 jonross@chromium.org
 sammc@chromium.org
+tibell@chromium.org
 
+per-file local_state_manifest.json=set noparent
+per-file local_state_manifest.json=file://ipc/SECURITY_OWNERS
+
+per-file manifest.json=set noparent
+per-file manifest.json=file://ipc/SECURITY_OWNERS
+
+per-file unittest_helper_manifest.json=set noparent
+per-file unittest_helper_manifest.json=file://ipc/SECURITY_OWNERS
+
+per-file unittest_manifest.json=set noparent
+per-file unittest_manifest.json=file://ipc/SECURITY_OWNERS
--- a/services/preferences/persistent_pref_store_impl.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/preferences/persistent_pref_store_impl.cc	2019-05-17 18:53:37.940000000 +0300
@@ -7,7 +7,6 @@
 #include <utility>
 
 #include "base/auto_reset.h"
-#include "base/bind.h"
 #include "base/stl_util.h"
 #include "base/values.h"
 #include "components/prefs/persistent_pref_store.h"
--- a/services/preferences/pref_service_factory_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/preferences/pref_service_factory_unittest.cc	2019-05-17 18:53:37.940000000 +0300
@@ -5,7 +5,6 @@
 #include "services/preferences/public/cpp/pref_service_factory.h"
 
 #include "base/barrier_closure.h"
-#include "base/bind.h"
 #include "base/files/scoped_temp_dir.h"
 #include "base/macros.h"
 #include "base/run_loop.h"
@@ -23,15 +22,13 @@
 #include "services/preferences/pref_store_impl.h"
 #include "services/preferences/public/cpp/dictionary_value_update.h"
 #include "services/preferences/public/cpp/in_process_service_factory.h"
-#include "services/preferences/public/cpp/manifest.h"
 #include "services/preferences/public/cpp/pref_service_main.h"
 #include "services/preferences/public/cpp/scoped_pref_update.h"
 #include "services/preferences/public/mojom/preferences.mojom.h"
+#include "services/preferences/tests_catalog_source.h"
 #include "services/preferences/unittest_common.h"
-#include "services/service_manager/public/cpp/manifest_builder.h"
 #include "services/service_manager/public/cpp/service_binding.h"
 #include "services/service_manager/public/cpp/test/test_service_manager.h"
-#include "services/service_manager/public/mojom/constants.mojom.h"
 #include "services/service_manager/public/mojom/service_factory.mojom.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
@@ -105,22 +102,7 @@
 class PrefServiceFactoryTest : public testing::Test {
  public:
   PrefServiceFactoryTest()
-      : test_service_manager_(
-            {service_manager::ManifestBuilder()
-                 .WithServiceName(kTestServiceName)
-                 .ExposeCapability(
-                     "service_manager:service_factory",
-                     service_manager::Manifest::InterfaceList<
-                         service_manager::mojom::ServiceFactory>())
-                 .RequireCapability(mojom::kServiceName, "pref_client")
-                 .RequireCapability(kTestHelperServiceName, "")
-                 .PackageService(GetManifest())
-                 .PackageService(
-                     service_manager::ManifestBuilder()
-                         .WithServiceName(kTestHelperServiceName)
-                         .RequireCapability(mojom::kServiceName, "pref_client")
-                         .Build())
-                 .Build()}) {}
+      : test_service_manager_(CreateServiceTestCatalog()) {}
 
  protected:
   void SetUp() override {
@@ -689,7 +671,7 @@
   EXPECT_EQ(kUpdatedValue, pref_service2->GetInteger(kKey));
 }
 
-INSTANTIATE_TEST_SUITE_P(UnderlayOrOverlayPref,
+INSTANTIATE_TEST_CASE_P(UnderlayOrOverlayPref,
                          IncognitoPrefServiceFactoryTest,
                          testing::Bool());
 
--- a/services/preferences/pref_store_consistency_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/preferences/pref_store_consistency_unittest.cc	2019-05-17 18:53:37.940000000 +0300
@@ -5,7 +5,6 @@
 #include <memory>
 #include <utility>
 
-#include "base/bind_helpers.h"
 #include "base/containers/circular_deque.h"
 #include "base/macros.h"
 #include "base/message_loop/message_loop.h"
--- a/services/preferences/pref_store_manager_impl.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/preferences/pref_store_manager_impl.cc	2019-05-17 18:53:37.940000000 +0300
@@ -7,7 +7,6 @@
 #include <algorithm>
 #include <utility>
 
-#include "base/bind.h"
 #include "base/memory/ref_counted.h"
 #include "base/stl_util.h"
 #include "components/prefs/pref_registry.h"
--- a/services/preferences/public/cpp/BUILD.gn	2019-05-01 01:22:56.000000000 +0300
+++ b/services/preferences/public/cpp/BUILD.gn	2019-05-17 18:53:37.940000000 +0300
@@ -35,30 +35,6 @@
   ]
 }
 
-source_set("manifest") {
-  sources = [
-    "manifest.cc",
-    "manifest.h",
-  ]
-  deps = [
-    "//base",
-    "//services/preferences/public/mojom",
-    "//services/service_manager/public/cpp",
-  ]
-}
-
-source_set("local_state_manifest") {
-  sources = [
-    "local_state_manifest.cc",
-    "local_state_manifest.h",
-  ]
-  deps = [
-    "//base",
-    "//services/preferences/public/mojom",
-    "//services/service_manager/public/cpp",
-  ]
-}
-
 source_set("service_main") {
   deps = [
     "//base",
--- a/services/preferences/public/cpp/in_process_service_factory.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/preferences/public/cpp/in_process_service_factory.h	2019-05-17 18:53:37.940000000 +0300
@@ -14,7 +14,7 @@
 #include "components/keyed_service/core/keyed_service.h"
 #include "components/prefs/pref_value_store.h"
 #include "services/service_manager/public/cpp/service.h"
-#include "services/service_manager/public/mojom/service.mojom-forward.h"
+#include "services/service_manager/public/mojom/service.mojom.h"
 
 class PersistentPrefStore;
 class PrefRegistry;
--- a/services/preferences/public/cpp/OWNERS	2019-05-01 01:22:56.000000000 +0300
+++ b/services/preferences/public/cpp/OWNERS	2019-05-17 18:53:37.940000000 +0300
@@ -1,12 +1,3 @@
-per-file local_state_manifest.cc=set noparent
-per-file local_state_manifest.cc=file://ipc/SECURITY_OWNERS
-per-file local_state_manifest.h=set noparent
-per-file local_state_manifest.h=file://ipc/SECURITY_OWNERS
-per-file manifest.cc=set noparent
-per-file manifest.cc=file://ipc/SECURITY_OWNERS
-per-file manifest.h=set noparent
-per-file manifest.h=file://ipc/SECURITY_OWNERS
-
 per-file *_mojom_traits*.*=set noparent
 per-file *_mojom_traits*.*=file://ipc/SECURITY_OWNERS
 per-file *.typemap=set noparent
--- a/services/preferences/public/cpp/persistent_pref_store_client.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/preferences/public/cpp/persistent_pref_store_client.cc	2019-05-17 18:53:37.944000000 +0300
@@ -4,7 +4,6 @@
 
 #include "services/preferences/public/cpp/persistent_pref_store_client.h"
 
-#include "base/bind.h"
 #include "base/values.h"
 #include "components/prefs/pref_registry.h"
 #include "mojo/public/cpp/bindings/sync_call_restrictions.h"
@@ -271,8 +270,7 @@
     // |this|. Instead, the destruction of |this| will flush any pending
     // writes.
     base::ThreadTaskRunnerHandle::Get()->PostTask(
-        FROM_HERE,
-        base::BindOnce(&PersistentPrefStoreClient::FlushPendingWrites,
+        FROM_HERE, base::Bind(&PersistentPrefStoreClient::FlushPendingWrites,
                        weak_factory_.GetWeakPtr()));
   }
   RemoveRedundantPaths(&path_components);
--- a/services/preferences/public/cpp/pref_service_factory.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/preferences/public/cpp/pref_service_factory.cc	2019-05-17 18:53:37.944000000 +0300
@@ -7,8 +7,6 @@
 #include <memory>
 #include <utility>
 
-#include "base/bind.h"
-#include "base/bind_helpers.h"
 #include "base/callback_helpers.h"
 #include "components/prefs/overlay_user_pref_store.h"
 #include "components/prefs/persistent_pref_store.h"
@@ -68,7 +66,8 @@
                             std::vector<mojom::PrefRegistrationPtr> defaults) {
   for (auto& registration : defaults) {
     pref_registry->SetDefaultForeignPrefValue(
-        registration->key, std::move(registration->default_value),
+        registration->key,
+        base::Value::ToUniquePtrValue(std::move(registration->default_value)),
         registration->flags);
   }
 }
--- a/services/preferences/public/cpp/tests/persistent_pref_store_client_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/preferences/public/cpp/tests/persistent_pref_store_client_unittest.cc	2019-05-17 18:53:37.944000000 +0300
@@ -7,7 +7,6 @@
 #include <memory>
 #include <utility>
 
-#include "base/bind_helpers.h"
 #include "base/macros.h"
 #include "base/message_loop/message_loop.h"
 #include "base/run_loop.h"
--- a/services/preferences/shared_pref_registry.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/preferences/shared_pref_registry.cc	2019-05-17 18:53:37.944000000 +0300
@@ -146,7 +146,8 @@
                        << key << "\"";
 #endif
       registry_->RegisterForeignPref(key);
-      registry_->SetDefaultForeignPrefValue(key, std::move(default_value),
+      registry_->SetDefaultForeignPrefValue(
+          key, base::Value::ToUniquePtrValue(std::move(default_value)),
                                             registration->flags);
 
       observed_prefs->push_back(key);
--- a/services/preferences/tracked/device_id_unittest.cc	2019-05-17 17:45:42.568000000 +0300
+++ b/services/preferences/tracked/device_id_unittest.cc	2019-05-17 18:53:37.948000000 +0300
@@ -27,8 +27,8 @@
   // with two arguments is a compiler bug in gcc that results in a "converting
   // 'false' to pointer type" error when the first argument to |EXPECT_EQ| is a
   // compile-time const false value. See also the following bug reports:
-  // https://code.9oo91e.qjz9zk/p/googletest/issues/detail?id=322
-  // https://code.9oo91e.qjz9zk/p/googletest/issues/detail?id=458
+  // https://code.google.com/p/googletest/issues/detail?id=322
+  // https://code.google.com/p/googletest/issues/detail?id=458
   EXPECT_TRUE((kExpectedStatus == MachineIdStatus::SUCCESS) ==
               !first_machine_id.empty());
   EXPECT_EQ(first_machine_id, second_machine_id);
--- a/services/preferences/tracked/pref_hash_filter.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/preferences/tracked/pref_hash_filter.cc	2019-05-17 18:53:37.948000000 +0300
@@ -112,7 +112,7 @@
   // See GetResetTime for why this is a StringPref and not Int64Pref.
   registry->RegisterStringPref(
       user_prefs::kPreferenceResetTime,
-      base::NumberToString(base::Time().ToInternalValue()));
+      base::Int64ToString(base::Time().ToInternalValue()));
 }
 
 // static
@@ -254,7 +254,7 @@
   if (did_reset) {
     pref_store_contents->SetString(
         user_prefs::kPreferenceResetTime,
-        base::NumberToString(base::Time::Now().ToInternalValue()));
+        base::Int64ToString(base::Time::Now().ToInternalValue()));
     FilterUpdate(user_prefs::kPreferenceResetTime);
 
     if (reset_on_load_observer_)
--- a/services/preferences/tracked/pref_hash_filter_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/preferences/tracked/pref_hash_filter_unittest.cc	2019-05-17 18:53:37.948000000 +0300
@@ -245,7 +245,7 @@
 std::string MockPrefHashStore::ComputeMac(const std::string& path,
                                           const base::Value* new_value) {
   return "atomic mac for: " + path;
-}
+};
 
 std::unique_ptr<base::DictionaryValue> MockPrefHashStore::ComputeSplitMacs(
     const std::string& path,
@@ -259,7 +259,7 @@
                       base::Value("split mac for: " + path + "/" + it.key()));
   }
   return macs_dict;
-}
+};
 
 ValueState MockPrefHashStore::RecordCheckValue(const std::string& path,
                                                const base::Value* value,
@@ -364,7 +364,7 @@
 
 class MockHashStoreContents : public HashStoreContents {
  public:
-  MockHashStoreContents() {}
+  MockHashStoreContents(){};
 
   // Returns the number of hashes stored.
   size_t stored_hashes_count() const { return dictionary_.size(); }
@@ -1364,7 +1364,7 @@
                 ValueState::UNCHANGED));
 }
 
-INSTANTIATE_TEST_SUITE_P(PrefHashFilterTestInstance,
+INSTANTIATE_TEST_CASE_P(PrefHashFilterTestInstance,
                          PrefHashFilterTest,
                          testing::Values(EnforcementLevel::NO_ENFORCEMENT,
                                          EnforcementLevel::ENFORCE_ON_LOAD));
--- a/services/preferences/tracked/segregated_pref_store_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/preferences/tracked/segregated_pref_store_unittest.cc	2019-05-17 18:53:37.952000000 +0300
@@ -340,15 +340,15 @@
   EXPECT_TRUE(base::Value(kValue1).Equals(value));
 }
 
-INSTANTIATE_TEST_SUITE_P(
+INSTANTIATE_TEST_CASE_P(
     WithoutCallback,
     SegregatedPrefStoreTest,
     ::testing::Values(CommitPendingWriteMode::WITHOUT_CALLBACK));
-INSTANTIATE_TEST_SUITE_P(
+INSTANTIATE_TEST_CASE_P(
     WithCallback,
     SegregatedPrefStoreTest,
     ::testing::Values(CommitPendingWriteMode::WITH_CALLBACK));
-INSTANTIATE_TEST_SUITE_P(
+INSTANTIATE_TEST_CASE_P(
     WithSynchronousCallback,
     SegregatedPrefStoreTest,
     ::testing::Values(CommitPendingWriteMode::WITH_SYNCHRONOUS_CALLBACK));
--- a/services/preferences/tracked/temp_scoped_dir_cleaner.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/preferences/tracked/temp_scoped_dir_cleaner.h	2019-05-17 18:53:37.952000000 +0300
@@ -12,7 +12,7 @@
     : public base::RefCountedThreadSafe<TempScopedDirCleaner> {
  protected:
   friend class base::RefCountedThreadSafe<TempScopedDirCleaner>;
-  virtual ~TempScopedDirCleaner() {}
+  virtual ~TempScopedDirCleaner(){};
 };
 
 #endif  // SERVICES_PREFERENCES_TRACKED_TEMP_SCOPED_DIR_CLEANER_H_
--- a/services/preferences/tracked/tracked_persistent_pref_store_factory.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/preferences/tracked/tracked_persistent_pref_store_factory.cc	2019-05-17 18:53:37.952000000 +0300
@@ -10,7 +10,6 @@
 #include <utility>
 #include <vector>
 
-#include "base/bind.h"
 #include "components/prefs/json_pref_store.h"
 #include "components/prefs/pref_filter.h"
 #include "services/preferences/public/mojom/tracked_preference_validation_delegate.mojom.h"
--- a/services/proxy_resolver/BUILD.gn	2019-05-01 01:22:56.000000000 +0300
+++ b/services/proxy_resolver/BUILD.gn	2019-05-17 18:53:37.952000000 +0300
@@ -2,6 +2,8 @@
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
+import("//services/service_manager/public/service_manifest.gni")
+
 source_set("lib") {
   sources = [
     "host_resolver_mojo.cc",
@@ -55,3 +57,8 @@
 
   configs += [ "//v8:external_startup_data" ]
 }
+
+service_manifest("proxy_resolver_manifest") {
+  name = "proxy_resolver"
+  source = "manifest.json"
+}
--- a/services/proxy_resolver/host_resolver_mojo.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/proxy_resolver/host_resolver_mojo.cc	2019-05-17 18:53:37.952000000 +0300
@@ -6,155 +6,192 @@
 
 #include <memory>
 #include <utility>
-#include <vector>
 
-#include "base/bind.h"
 #include "base/callback_helpers.h"
-#include "base/time/time.h"
 #include "mojo/public/cpp/bindings/binding.h"
-#include "net/base/address_family.h"
 #include "net/base/address_list.h"
-#include "net/base/completion_once_callback.h"
-#include "net/base/ip_address.h"
 #include "net/base/net_errors.h"
 
 namespace proxy_resolver {
 namespace {
 
 // Default TTL for successful host resolutions.
-constexpr auto kCacheEntryTTL = base::TimeDelta::FromSeconds(5);
+const int kCacheEntryTTLSeconds = 5;
 
 // Default TTL for unsuccessful host resolutions.
-constexpr auto kNegativeCacheEntryTTL = base::TimeDelta();
+const int kNegativeCacheEntryTTLSeconds = 0;
 
 net::HostCache::Key CacheKeyForRequest(
-    const std::string& hostname,
-    net::ProxyResolveDnsOperation operation) {
-  net::AddressFamily address_family = net::ADDRESS_FAMILY_UNSPECIFIED;
-  if (operation == net::ProxyResolveDnsOperation::MY_IP_ADDRESS ||
-      operation == net::ProxyResolveDnsOperation::DNS_RESOLVE) {
-    address_family = net::ADDRESS_FAMILY_IPV4;
-  }
-
-  return net::HostCache::Key(hostname, address_family,
-                             0 /* host_resolver_flags */);
+    const net::HostResolver::RequestInfo& info) {
+  return net::HostCache::Key(info.hostname(), info.address_family(),
+                             info.host_resolver_flags());
 }
 
 }  // namespace
 
-class HostResolverMojo::RequestImpl : public ProxyHostResolver::Request,
-                                      public mojom::HostResolverRequestClient {
+class HostResolverMojo::Job : public mojom::HostResolverRequestClient {
  public:
-  RequestImpl(const std::string& hostname,
-              net::ProxyResolveDnsOperation operation,
-              base::WeakPtr<net::HostCache> host_cache,
-              Impl* impl)
-      : hostname_(hostname),
-        operation_(operation),
-        binding_(this),
-        host_cache_(std::move(host_cache)),
-        impl_(impl) {}
+  Job(const net::HostCache::Key& key,
+      net::AddressList* addresses,
+      net::CompletionOnceCallback callback,
+      mojo::InterfaceRequest<mojom::HostResolverRequestClient> request,
+      base::WeakPtr<net::HostCache> host_cache);
 
-  ~RequestImpl() override = default;
+ private:
+  // mojom::HostResolverRequestClient override.
+  void ReportResult(int32_t error,
+                    const net::AddressList& address_list) override;
 
-  // ProxyHostResolver::Request override
-  int Start(net::CompletionOnceCallback callback) override {
-    DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
-    DVLOG(1) << "Resolve " << hostname_;
+  // Mojo error handler.
+  void OnConnectionError();
 
-    int cached_result = ResolveFromCacheInternal();
-    if (cached_result != net::ERR_DNS_CACHE_MISS) {
-      DVLOG(1) << "Resolved " << hostname_ << " from cache";
-      return cached_result;
-    }
+  const net::HostCache::Key key_;
+  net::AddressList* addresses_;
+  net::CompletionOnceCallback callback_;
+  mojo::Binding<mojom::HostResolverRequestClient> binding_;
+  base::WeakPtr<net::HostCache> host_cache_;
+};
 
-    callback_ = std::move(callback);
+class HostResolverMojo::RequestImpl : public HostResolver::Request {
+ public:
+  explicit RequestImpl(std::unique_ptr<Job> job) : job_(std::move(job)) {}
 
-    mojom::HostResolverRequestClientPtr handle;
-    binding_.Bind(mojo::MakeRequest(&handle));
-    binding_.set_connection_error_handler(base::BindOnce(
-        &RequestImpl::OnConnectionError, base::Unretained(this)));
+  ~RequestImpl() override = default;
 
-    impl_->ResolveDns(hostname_, operation_, std::move(handle));
-    return net::ERR_IO_PENDING;
-  }
+  void ChangeRequestPriority(net::RequestPriority priority) override {}
 
-  const std::vector<net::IPAddress>& GetResults() const override {
-    return results_;
-  }
+ private:
+  std::unique_ptr<Job> job_;
+};
 
-  // mojom::HostResolverRequestClient override
-  void ReportResult(int32_t error,
-                    const std::vector<net::IPAddress>& result) override {
-    DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
+HostResolverMojo::HostResolverMojo(Impl* impl)
+    : impl_(impl),
+      host_cache_(net::HostCache::CreateDefaultCache()),
+      host_cache_weak_factory_(host_cache_.get()) {}
 
-    if (error == net::OK)
-      results_ = result;
-    if (host_cache_) {
-      base::TimeDelta ttl =
-          error == net::OK ? kCacheEntryTTL : kNegativeCacheEntryTTL;
-      net::HostCache::Entry entry(
-          error, net::AddressList::CreateFromIPAddressList(result, ""),
-          net::HostCache::Entry::SOURCE_UNKNOWN, ttl);
-      host_cache_->Set(CacheKeyForRequest(hostname_, operation_), entry,
-                       base::TimeTicks::Now(), ttl);
-    }
-    if (binding_.is_bound())
-      binding_.Close();
-    std::move(callback_).Run(error);
-  }
+HostResolverMojo::~HostResolverMojo() = default;
 
- private:
-  int ResolveFromCacheInternal() {
-    DCHECK(host_cache_);
+std::unique_ptr<net::HostResolver::ResolveHostRequest>
+HostResolverMojo::CreateRequest(
+    const net::HostPortPair& host,
+    const net::NetLogWithSource& source_net_log,
+    const base::Optional<ResolveHostParameters>& optional_parameters) {
+  // TODO(crbug.com/821021): Implement.
+  NOTIMPLEMENTED();
+  return nullptr;
+}
 
-    net::HostCache::Key key = CacheKeyForRequest(hostname_, operation_);
-    const std::pair<const net::HostCache::Key, net::HostCache::Entry>*
-        cache_result = host_cache_->Lookup(key, base::TimeTicks::Now());
-    if (!cache_result)
-      return net::ERR_DNS_CACHE_MISS;
+int HostResolverMojo::Resolve(const RequestInfo& info,
+                              net::RequestPriority priority,
+                              net::AddressList* addresses,
+                              net::CompletionOnceCallback callback,
+                              std::unique_ptr<Request>* request,
+                              const net::NetLogWithSource& source_net_log) {
+  DCHECK(thread_checker_.CalledOnValidThread());
+  DCHECK(request);
+  DVLOG(1) << "Resolve " << info.host_port_pair().ToString();
 
-    results_ = AddressListToAddresses(cache_result->second.addresses().value());
-    return cache_result->second.error();
+  net::HostCache::Key key = CacheKeyForRequest(info);
+  int cached_result = ResolveFromCacheInternal(info, key, addresses);
+  if (cached_result != net::ERR_DNS_CACHE_MISS) {
+    DVLOG(1) << "Resolved " << info.host_port_pair().ToString()
+             << " from cache";
+    return cached_result;
   }
 
-  void OnConnectionError() { ReportResult(net::ERR_FAILED, {} /* result */); }
+  mojom::HostResolverRequestClientPtr handle;
+  std::unique_ptr<Job> job(new Job(key, addresses, std::move(callback),
+                                   mojo::MakeRequest(&handle),
+                                   host_cache_weak_factory_.GetWeakPtr()));
+  request->reset(new RequestImpl(std::move(job)));
 
-  static std::vector<net::IPAddress> AddressListToAddresses(
-      net::AddressList address_list) {
-    std::vector<net::IPAddress> result;
-    for (net::IPEndPoint endpoint : address_list.endpoints()) {
-      result.push_back(endpoint.address());
-    }
-    return result;
-  }
+  impl_->ResolveDns(std::make_unique<HostResolver::RequestInfo>(info),
+                    std::move(handle));
+  return net::ERR_IO_PENDING;
+}
 
-  const std::string hostname_;
-  const net::ProxyResolveDnsOperation operation_;
+int HostResolverMojo::ResolveFromCache(
+    const RequestInfo& info,
+    net::AddressList* addresses,
+    const net::NetLogWithSource& source_net_log) {
+  DCHECK(thread_checker_.CalledOnValidThread());
+  DVLOG(1) << "ResolveFromCache " << info.host_port_pair().ToString();
+  return ResolveFromCacheInternal(info, CacheKeyForRequest(info), addresses);
+}
 
-  mojo::Binding<mojom::HostResolverRequestClient> binding_;
-  net::CompletionOnceCallback callback_;
+int HostResolverMojo::ResolveStaleFromCache(
+    const RequestInfo& info,
+    net::AddressList* addresses,
+    net::HostCache::EntryStaleness* stale_info,
+    const net::NetLogWithSource& net_log) {
+  NOTREACHED();
+  return net::ERR_UNEXPECTED;
+}
 
-  base::WeakPtr<net::HostCache> host_cache_;
-  Impl* const impl_;
-  std::vector<net::IPAddress> results_;
+net::HostCache* HostResolverMojo::GetHostCache() {
+  return host_cache_.get();
+}
 
-  THREAD_CHECKER(thread_checker_);
-};
+bool HostResolverMojo::HasCached(
+    base::StringPiece hostname,
+    net::HostCache::Entry::Source* source_out,
+    net::HostCache::EntryStaleness* stale_out) const {
+  if (!host_cache_)
+    return false;
 
-HostResolverMojo::HostResolverMojo(Impl* impl)
-    : impl_(impl),
-      host_cache_(net::HostCache::CreateDefaultCache()),
-      host_cache_weak_factory_(host_cache_.get()) {}
+  return host_cache_->HasEntry(hostname, source_out, stale_out);
+}
 
-HostResolverMojo::~HostResolverMojo() = default;
+int HostResolverMojo::ResolveFromCacheInternal(const RequestInfo& info,
+                                               const net::HostCache::Key& key,
+                                               net::AddressList* addresses) {
+  if (!info.allow_cached_response())
+    return net::ERR_DNS_CACHE_MISS;
 
-std::unique_ptr<net::ProxyHostResolver::Request>
-HostResolverMojo::CreateRequest(const std::string& hostname,
-                                net::ProxyResolveDnsOperation operation) {
-  DCHECK(thread_checker_.CalledOnValidThread());
-  return std::make_unique<RequestImpl>(
-      hostname, operation, host_cache_weak_factory_.GetWeakPtr(), impl_);
+  const net::HostCache::Entry* entry =
+      host_cache_->Lookup(key, base::TimeTicks::Now());
+  if (!entry)
+    return net::ERR_DNS_CACHE_MISS;
+
+  *addresses =
+      net::AddressList::CopyWithPort(entry->addresses().value(), info.port());
+  return entry->error();
+}
+
+HostResolverMojo::Job::Job(
+    const net::HostCache::Key& key,
+    net::AddressList* addresses,
+    net::CompletionOnceCallback callback,
+    mojo::InterfaceRequest<mojom::HostResolverRequestClient> request,
+    base::WeakPtr<net::HostCache> host_cache)
+    : key_(key),
+      addresses_(addresses),
+      callback_(std::move(callback)),
+      binding_(this, std::move(request)),
+      host_cache_(host_cache) {
+  binding_.set_connection_error_handler(base::Bind(
+      &HostResolverMojo::Job::OnConnectionError, base::Unretained(this)));
+}
+
+void HostResolverMojo::Job::ReportResult(int32_t error,
+                                         const net::AddressList& address_list) {
+  if (error == net::OK)
+    *addresses_ = address_list;
+  if (host_cache_) {
+    base::TimeDelta ttl = base::TimeDelta::FromSeconds(
+        error == net::OK ? kCacheEntryTTLSeconds
+                         : kNegativeCacheEntryTTLSeconds);
+    net::HostCache::Entry entry(error, *addresses_,
+                                net::HostCache::Entry::SOURCE_UNKNOWN, ttl);
+    host_cache_->Set(key_, entry, base::TimeTicks::Now(), ttl);
+  }
+  if (binding_.is_bound())
+    binding_.Close();
+  std::move(callback_).Run(error);
+}
+
+void HostResolverMojo::Job::OnConnectionError() {
+  ReportResult(net::ERR_FAILED, net::AddressList());
 }
 
 }  // namespace proxy_resolver
--- a/services/proxy_resolver/host_resolver_mojo.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/proxy_resolver/host_resolver_mojo.h	2019-05-17 18:53:37.952000000 +0300
@@ -6,27 +6,31 @@
 #define SERVICES_PROXY_RESOLVER_HOST_RESOLVER_MOJO_H_
 
 #include <memory>
-#include <string>
 
 #include "base/macros.h"
 #include "base/memory/weak_ptr.h"
 #include "base/threading/thread_checker.h"
+#include "net/base/completion_once_callback.h"
 #include "net/dns/host_cache.h"
-#include "net/proxy_resolution/proxy_host_resolver.h"
-#include "net/proxy_resolution/proxy_resolve_dns_operation.h"
+#include "net/dns/host_resolver.h"
 #include "services/proxy_resolver/public/mojom/proxy_resolver.mojom.h"
 
+namespace net {
+class AddressList;
+class NetLogWithSource;
+}  // namespace net
+
 namespace proxy_resolver {
 
-// A ProxyHostResolver implementation that converts requests to mojo types and
+// A HostResolver implementation that converts requests to mojo types and
 // forwards them to a mojo Impl interface.
-class HostResolverMojo : public net::ProxyHostResolver {
+class HostResolverMojo : public net::HostResolver {
  public:
   class Impl {
    public:
     virtual ~Impl() = default;
-    virtual void ResolveDns(const std::string& hostname,
-                            net::ProxyResolveDnsOperation operation,
+    virtual void ResolveDns(
+        std::unique_ptr<net::HostResolver::RequestInfo> request_info,
                             mojom::HostResolverRequestClientPtr) = 0;
   };
 
@@ -34,15 +38,40 @@
   explicit HostResolverMojo(Impl* impl);
   ~HostResolverMojo() override;
 
-  // ProxyHostResolver overrides.
-  std::unique_ptr<Request> CreateRequest(
-      const std::string& hostname,
-      net::ProxyResolveDnsOperation operation) override;
+  // HostResolver overrides.
+  std::unique_ptr<ResolveHostRequest> CreateRequest(
+      const net::HostPortPair& host,
+      const net::NetLogWithSource& net_log,
+      const base::Optional<ResolveHostParameters>& optional_parameters)
+      override;
+  // Note: |Resolve()| currently ignores |priority|.
+  int Resolve(const RequestInfo& info,
+              net::RequestPriority priority,
+              net::AddressList* addresses,
+              net::CompletionOnceCallback callback,
+              std::unique_ptr<Request>* request,
+              const net::NetLogWithSource& source_net_log) override;
+  int ResolveFromCache(const RequestInfo& info,
+                       net::AddressList* addresses,
+                       const net::NetLogWithSource& source_net_log) override;
+  int ResolveStaleFromCache(
+      const RequestInfo& info,
+      net::AddressList* addresses,
+      net::HostCache::EntryStaleness* stale_info,
+      const net::NetLogWithSource& source_net_log) override;
+  net::HostCache* GetHostCache() override;
+  bool HasCached(base::StringPiece hostname,
+                 net::HostCache::Entry::Source* source_out,
+                 net::HostCache::EntryStaleness* stale_out) const override;
 
  private:
   class Job;
   class RequestImpl;
 
+  int ResolveFromCacheInternal(const RequestInfo& info,
+                               const net::HostCache::Key& key,
+                               net::AddressList* addresses);
+
   Impl* const impl_;
 
   std::unique_ptr<net::HostCache> host_cache_;
--- a/services/proxy_resolver/host_resolver_mojo_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/proxy_resolver/host_resolver_mojo_unittest.cc	2019-05-17 18:53:37.952000000 +0300
@@ -7,11 +7,10 @@
 #include <memory>
 #include <string>
 #include <utility>
-#include <vector>
 
-#include "base/bind.h"
 #include "base/test/scoped_task_environment.h"
 #include "mojo/public/cpp/bindings/binding.h"
+#include "net/base/address_list.h"
 #include "net/base/ip_address.h"
 #include "net/base/net_errors.h"
 #include "net/base/request_priority.h"
@@ -68,10 +67,9 @@
     return result;
   }
 
-  static HostResolverAction ReturnResult(
-      std::vector<net::IPAddress> addresses) {
+  static HostResolverAction ReturnResult(const net::AddressList& address_list) {
     HostResolverAction result;
-    result.addresses = std::move(addresses);
+    result.addresses = address_list;
     return result;
   }
 
@@ -88,7 +86,7 @@
   }
 
   Action action = COMPLETE;
-  std::vector<net::IPAddress> addresses;
+  net::AddressList addresses;
   net::Error error = net::OK;
 };
 
@@ -100,16 +98,17 @@
 
   void AddAction(HostResolverAction action);
 
-  const std::vector<std::string>& requests() { return requests_received_; }
+  const std::vector<net::HostResolver::RequestInfo>& requests() {
+    return requests_received_;
+  }
 
-  void ResolveDns(const std::string& hostname,
-                  net::ProxyResolveDnsOperation operation,
-                  mojom::HostResolverRequestClientPtr) override;
+  void ResolveDns(std::unique_ptr<net::HostResolver::RequestInfo> request_info,
+                  mojom::HostResolverRequestClientPtr client) override;
 
  private:
   std::vector<HostResolverAction> actions_;
   size_t results_returned_ = 0;
-  std::vector<std::string> requests_received_;
+  std::vector<net::HostResolver::RequestInfo> requests_received_;
   const base::Closure request_connection_error_callback_;
   std::vector<std::unique_ptr<MockMojoHostResolverRequest>> requests_;
 };
@@ -127,15 +126,14 @@
 }
 
 void MockMojoHostResolver::ResolveDns(
-    const std::string& hostname,
-    net::ProxyResolveDnsOperation operation,
+    std::unique_ptr<net::HostResolver::RequestInfo> request_info,
     mojom::HostResolverRequestClientPtr client) {
-  requests_received_.push_back(hostname);
+  requests_received_.push_back(std::move(*request_info));
   ASSERT_LE(results_returned_, actions_.size());
   switch (actions_[results_returned_].action) {
     case HostResolverAction::COMPLETE:
       client->ReportResult(actions_[results_returned_].error,
-                           actions_[results_returned_].addresses);
+                           std::move(actions_[results_returned_].addresses));
       break;
     case HostResolverAction::RETAIN:
       requests_.push_back(std::make_unique<MockMojoHostResolverRequest>(
@@ -164,17 +162,12 @@
     resolver_.reset(new HostResolverMojo(mock_resolver_.get()));
   }
 
-  int Resolve(const std::string& hostname,
-              std::vector<net::IPAddress>* out_addresses) {
-    std::unique_ptr<net::ProxyHostResolver::Request> request =
-        resolver_->CreateRequest(hostname,
-                                 net::ProxyResolveDnsOperation::DNS_RESOLVE_EX);
-
+  int Resolve(const net::HostResolver::RequestInfo& request_info,
+              net::AddressList* result) {
     net::TestCompletionCallback callback;
-    int result = callback.GetResult(request->Start(callback.callback()));
-
-    *out_addresses = request->GetResults();
-    return result;
+    return callback.GetResult(resolver_->Resolve(
+        request_info, net::DEFAULT_PRIORITY, result, callback.callback(),
+        &request_, net::NetLogWithSource()));
   }
 
   base::test::ScopedTaskEnvironment scoped_task_environment_;
@@ -183,89 +176,143 @@
 
   std::unique_ptr<HostResolverMojo> resolver_;
 
+  std::unique_ptr<net::HostResolver::Request> request_;
+
   Waiter waiter_;
 };
 
 TEST_F(HostResolverMojoTest, Basic) {
-  std::vector<net::IPAddress> addresses;
+  net::AddressList address_list;
   net::IPAddress address(1, 2, 3, 4);
-  addresses.push_back(address);
-  addresses.push_back(ConvertIPv4ToIPv4MappedIPv6(address));
-  mock_resolver_->AddAction(HostResolverAction::ReturnResult(addresses));
-
-  std::vector<net::IPAddress> result;
-  EXPECT_THAT(Resolve("example.com", &result), IsOk());
-  EXPECT_EQ(addresses, result);
+  address_list.push_back(net::IPEndPoint(address, 12345));
+  address_list.push_back(
+      net::IPEndPoint(ConvertIPv4ToIPv4MappedIPv6(address), 12345));
+  mock_resolver_->AddAction(HostResolverAction::ReturnResult(address_list));
+  net::HostResolver::RequestInfo request_info(
+      net::HostPortPair::FromString("example.com:12345"));
+  net::AddressList result;
+  EXPECT_THAT(Resolve(request_info, &result), IsOk());
+  ASSERT_EQ(2u, result.size());
+  EXPECT_EQ(address_list[0], result[0]);
+  EXPECT_EQ(address_list[1], result[1]);
 
   ASSERT_EQ(1u, mock_resolver_->requests().size());
-  EXPECT_EQ("example.com", mock_resolver_->requests()[0]);
+  const net::HostResolver::RequestInfo& request = mock_resolver_->requests()[0];
+  EXPECT_EQ("example.com", request.hostname());
+  EXPECT_EQ(12345, request.port());
+  EXPECT_EQ(net::ADDRESS_FAMILY_UNSPECIFIED, request.address_family());
+  EXPECT_FALSE(request.is_my_ip_address());
 }
 
 TEST_F(HostResolverMojoTest, ResolveCachedResult) {
-  std::vector<net::IPAddress> addresses;
+  net::AddressList address_list;
   net::IPAddress address(1, 2, 3, 4);
-  addresses.push_back(address);
-  addresses.push_back(ConvertIPv4ToIPv4MappedIPv6(address));
-  mock_resolver_->AddAction(HostResolverAction::ReturnResult(addresses));
-
-  // Load results into cache.
-  std::vector<net::IPAddress> result;
-  ASSERT_THAT(Resolve("example.com", &result), IsOk());
+  address_list.push_back(net::IPEndPoint(address, 12345));
+  address_list.push_back(
+      net::IPEndPoint(ConvertIPv4ToIPv4MappedIPv6(address), 12345));
+  mock_resolver_->AddAction(HostResolverAction::ReturnResult(address_list));
+  net::HostResolver::RequestInfo request_info(
+      net::HostPortPair::FromString("example.com:12345"));
+  net::AddressList result;
+  ASSERT_THAT(Resolve(request_info, &result), IsOk());
   ASSERT_EQ(1u, mock_resolver_->requests().size());
 
-  // Expect results from cache.
   result.clear();
-  EXPECT_THAT(Resolve("example.com", &result), IsOk());
-  EXPECT_EQ(addresses, result);
+  request_info.set_host_port_pair(
+      net::HostPortPair::FromString("example.com:6789"));
+  EXPECT_THAT(Resolve(request_info, &result), IsOk());
+  ASSERT_EQ(2u, result.size());
+  address_list.clear();
+  address_list.push_back(net::IPEndPoint(address, 6789));
+  address_list.push_back(
+      net::IPEndPoint(ConvertIPv4ToIPv4MappedIPv6(address), 6789));
+  EXPECT_EQ(address_list[0], result[0]);
+  EXPECT_EQ(address_list[1], result[1]);
   EXPECT_EQ(1u, mock_resolver_->requests().size());
+
+  mock_resolver_->AddAction(HostResolverAction::ReturnResult(address_list));
+  result.clear();
+  request_info.set_allow_cached_response(false);
+  EXPECT_THAT(Resolve(request_info, &result), IsOk());
+  ASSERT_EQ(2u, result.size());
+  EXPECT_EQ(address_list[0], result[0]);
+  EXPECT_EQ(address_list[1], result[1]);
+  EXPECT_EQ(2u, mock_resolver_->requests().size());
 }
 
 TEST_F(HostResolverMojoTest, Multiple) {
-  std::vector<net::IPAddress> addresses;
-  addresses.emplace_back(1, 2, 3, 4);
-  mock_resolver_->AddAction(HostResolverAction::ReturnResult(addresses));
+  net::AddressList address_list;
+  net::IPAddress address(1, 2, 3, 4);
+  address_list.push_back(net::IPEndPoint(address, 12345));
+  mock_resolver_->AddAction(HostResolverAction::ReturnResult(address_list));
   mock_resolver_->AddAction(
       HostResolverAction::ReturnError(net::ERR_NAME_NOT_RESOLVED));
-
-  std::unique_ptr<net::ProxyHostResolver::Request> request1 =
-      resolver_->CreateRequest("example.com",
-                               net::ProxyResolveDnsOperation::DNS_RESOLVE_EX);
-  std::unique_ptr<net::ProxyHostResolver::Request> request2 =
-      resolver_->CreateRequest("example.org",
-                               net::ProxyResolveDnsOperation::DNS_RESOLVE_EX);
+  net::HostResolver::RequestInfo request_info1(
+      net::HostPortPair::FromString("example.com:12345"));
+  request_info1.set_address_family(net::ADDRESS_FAMILY_IPV4);
+  request_info1.set_is_my_ip_address(true);
+  net::HostResolver::RequestInfo request_info2(
+      net::HostPortPair::FromString("example.org:80"));
+  request_info2.set_address_family(net::ADDRESS_FAMILY_IPV6);
+  net::AddressList result1;
+  net::AddressList result2;
+  std::unique_ptr<net::HostResolver::Request> request1;
+  std::unique_ptr<net::HostResolver::Request> request2;
   net::TestCompletionCallback callback1;
   net::TestCompletionCallback callback2;
-  ASSERT_EQ(net::ERR_IO_PENDING, request1->Start(callback1.callback()));
-  ASSERT_EQ(net::ERR_IO_PENDING, request2->Start(callback2.callback()));
-
+  ASSERT_EQ(net::ERR_IO_PENDING,
+            resolver_->Resolve(request_info1, net::DEFAULT_PRIORITY, &result1,
+                               callback1.callback(), &request1,
+                               net::NetLogWithSource()));
+  ASSERT_EQ(net::ERR_IO_PENDING,
+            resolver_->Resolve(request_info2, net::DEFAULT_PRIORITY, &result2,
+                               callback2.callback(), &request2,
+                               net::NetLogWithSource()));
   EXPECT_THAT(callback1.GetResult(net::ERR_IO_PENDING), IsOk());
   EXPECT_THAT(callback2.GetResult(net::ERR_IO_PENDING),
               IsError(net::ERR_NAME_NOT_RESOLVED));
-  EXPECT_EQ(addresses, request1->GetResults());
-  ASSERT_EQ(0u, request2->GetResults().size());
-
-  EXPECT_THAT(mock_resolver_->requests(),
-              testing::ElementsAre("example.com", "example.org"));
+  ASSERT_EQ(1u, result1.size());
+  EXPECT_EQ(address_list[0], result1[0]);
+  ASSERT_EQ(0u, result2.size());
+
+  ASSERT_EQ(2u, mock_resolver_->requests().size());
+  const net::HostResolver::RequestInfo& info1 = mock_resolver_->requests()[0];
+  EXPECT_EQ("example.com", info1.hostname());
+  EXPECT_EQ(12345, info1.port());
+  EXPECT_EQ(net::ADDRESS_FAMILY_IPV4, info1.address_family());
+  EXPECT_TRUE(info1.is_my_ip_address());
+  const net::HostResolver::RequestInfo& info2 = mock_resolver_->requests()[1];
+  EXPECT_EQ("example.org", info2.hostname());
+  EXPECT_EQ(80, info2.port());
+  EXPECT_EQ(net::ADDRESS_FAMILY_IPV6, info2.address_family());
+  EXPECT_FALSE(info2.is_my_ip_address());
 }
 
 TEST_F(HostResolverMojoTest, Error) {
   mock_resolver_->AddAction(
       HostResolverAction::ReturnError(net::ERR_NAME_NOT_RESOLVED));
-
-  std::vector<net::IPAddress> result;
-  EXPECT_THAT(Resolve("example.com", &result),
+  net::HostResolver::RequestInfo request_info(
+      net::HostPortPair::FromString("example.com:8080"));
+  request_info.set_address_family(net::ADDRESS_FAMILY_IPV4);
+  net::AddressList result;
+  EXPECT_THAT(Resolve(request_info, &result),
               IsError(net::ERR_NAME_NOT_RESOLVED));
   EXPECT_TRUE(result.empty());
 
   ASSERT_EQ(1u, mock_resolver_->requests().size());
-  EXPECT_EQ("example.com", mock_resolver_->requests()[0]);
+  const net::HostResolver::RequestInfo& request = mock_resolver_->requests()[0];
+  EXPECT_EQ("example.com", request.hostname());
+  EXPECT_EQ(8080, request.port());
+  EXPECT_EQ(net::ADDRESS_FAMILY_IPV4, request.address_family());
+  EXPECT_FALSE(request.is_my_ip_address());
 }
 
 TEST_F(HostResolverMojoTest, EmptyResult) {
   mock_resolver_->AddAction(HostResolverAction::ReturnError(net::OK));
-
-  std::vector<net::IPAddress> result;
-  EXPECT_THAT(Resolve("example.com", &result), IsOk());
+  net::HostResolver::RequestInfo request_info(
+      net::HostPortPair::FromString("example.com:8080"));
+  net::AddressList result;
+  EXPECT_THAT(Resolve(request_info, &result), IsOk());
   EXPECT_TRUE(result.empty());
 
   ASSERT_EQ(1u, mock_resolver_->requests().size());
@@ -273,28 +320,96 @@
 
 TEST_F(HostResolverMojoTest, Cancel) {
   mock_resolver_->AddAction(HostResolverAction::RetainRequest());
-
-  std::unique_ptr<net::ProxyHostResolver::Request> request =
-      resolver_->CreateRequest("example.com",
-                               net::ProxyResolveDnsOperation::DNS_RESOLVE_EX);
-  request->Start(base::BindOnce(&Fail));
-
+  net::HostResolver::RequestInfo request_info(
+      net::HostPortPair::FromString("example.com:80"));
+  request_info.set_address_family(net::ADDRESS_FAMILY_IPV6);
+  net::AddressList result;
+  std::unique_ptr<net::HostResolver::Request> request;
+  resolver_->Resolve(request_info, net::DEFAULT_PRIORITY, &result,
+                     base::Bind(&Fail), &request, net::NetLogWithSource());
   request.reset();
   waiter_.WaitForEvent(ConnectionErrorSource::REQUEST);
+  EXPECT_TRUE(result.empty());
 
   ASSERT_EQ(1u, mock_resolver_->requests().size());
-  EXPECT_EQ("example.com", mock_resolver_->requests()[0]);
+  const net::HostResolver::RequestInfo& info1 = mock_resolver_->requests()[0];
+  EXPECT_EQ("example.com", info1.hostname());
+  EXPECT_EQ(80, info1.port());
+  EXPECT_EQ(net::ADDRESS_FAMILY_IPV6, info1.address_family());
+  EXPECT_FALSE(info1.is_my_ip_address());
 }
 
 TEST_F(HostResolverMojoTest, ImplDropsClientConnection) {
   mock_resolver_->AddAction(HostResolverAction::DropRequest());
-
-  std::vector<net::IPAddress> result;
-  EXPECT_THAT(Resolve("example.com", &result), IsError(net::ERR_FAILED));
+  net::HostResolver::RequestInfo request_info(
+      net::HostPortPair::FromString("example.com:1"));
+  net::AddressList result;
+  EXPECT_THAT(Resolve(request_info, &result), IsError(net::ERR_FAILED));
   EXPECT_TRUE(result.empty());
 
   ASSERT_EQ(1u, mock_resolver_->requests().size());
-  EXPECT_EQ("example.com", mock_resolver_->requests()[0]);
+  const net::HostResolver::RequestInfo& info2 = mock_resolver_->requests()[0];
+  EXPECT_EQ("example.com", info2.hostname());
+  EXPECT_EQ(1, info2.port());
+  EXPECT_EQ(net::ADDRESS_FAMILY_UNSPECIFIED, info2.address_family());
+  EXPECT_FALSE(info2.is_my_ip_address());
+}
+
+TEST_F(HostResolverMojoTest, ResolveFromCache_Miss) {
+  net::HostResolver::RequestInfo request_info(
+      net::HostPortPair::FromString("example.com:8080"));
+  net::AddressList result;
+  EXPECT_EQ(net::ERR_DNS_CACHE_MISS,
+            resolver_->ResolveFromCache(request_info, &result,
+                                        net::NetLogWithSource()));
+  EXPECT_TRUE(result.empty());
+}
+
+TEST_F(HostResolverMojoTest, ResolveFromCache_Hit) {
+  net::AddressList address_list;
+  net::IPAddress address(1, 2, 3, 4);
+  address_list.push_back(net::IPEndPoint(address, 12345));
+  address_list.push_back(
+      net::IPEndPoint(ConvertIPv4ToIPv4MappedIPv6(address), 12345));
+  mock_resolver_->AddAction(HostResolverAction::ReturnResult(address_list));
+  net::HostResolver::RequestInfo request_info(
+      net::HostPortPair::FromString("example.com:12345"));
+  net::AddressList result;
+  ASSERT_THAT(Resolve(request_info, &result), IsOk());
+  EXPECT_EQ(1u, mock_resolver_->requests().size());
+
+  result.clear();
+  EXPECT_EQ(net::OK, resolver_->ResolveFromCache(request_info, &result,
+                                                 net::NetLogWithSource()));
+  ASSERT_EQ(2u, result.size());
+  EXPECT_EQ(address_list[0], result[0]);
+  EXPECT_EQ(address_list[1], result[1]);
+  EXPECT_EQ(1u, mock_resolver_->requests().size());
+}
+
+TEST_F(HostResolverMojoTest, ResolveFromCache_CacheNotAllowed) {
+  net::AddressList address_list;
+  net::IPAddress address(1, 2, 3, 4);
+  address_list.push_back(net::IPEndPoint(address, 12345));
+  address_list.push_back(
+      net::IPEndPoint(ConvertIPv4ToIPv4MappedIPv6(address), 12345));
+  mock_resolver_->AddAction(HostResolverAction::ReturnResult(address_list));
+  net::HostResolver::RequestInfo request_info(
+      net::HostPortPair::FromString("example.com:12345"));
+  net::AddressList result;
+  ASSERT_THAT(Resolve(request_info, &result), IsOk());
+  EXPECT_EQ(1u, mock_resolver_->requests().size());
+
+  result.clear();
+  request_info.set_allow_cached_response(false);
+  EXPECT_EQ(net::ERR_DNS_CACHE_MISS,
+            resolver_->ResolveFromCache(request_info, &result,
+                                        net::NetLogWithSource()));
+  EXPECT_TRUE(result.empty());
+}
+
+TEST_F(HostResolverMojoTest, GetHostCache) {
+  EXPECT_TRUE(resolver_->GetHostCache());
 }
 
 }  // namespace proxy_resolver
--- a/services/proxy_resolver/mojo_proxy_resolver_v8_tracing_bindings.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/proxy_resolver/mojo_proxy_resolver_v8_tracing_bindings.h	2019-05-17 18:53:37.952000000 +0300
@@ -5,22 +5,13 @@
 #ifndef SERVICES_PROXY_RESOLVER_MOJO_PROXY_RESOLVER_V8_TRACING_BINDINGS_H_
 #define SERVICES_PROXY_RESOLVER_MOJO_PROXY_RESOLVER_V8_TRACING_BINDINGS_H_
 
-#include <memory>
-#include <string>
 #include <utility>
 
-#include "base/logging.h"
 #include "base/strings/utf_string_conversions.h"
 #include "base/threading/thread_checker.h"
-#include "net/base/address_family.h"
-#include "net/base/host_port_pair.h"
-#include "net/dns/host_resolver.h"
 #include "net/log/net_log_with_source.h"
-#include "net/proxy_resolution/proxy_host_resolver.h"
-#include "net/proxy_resolution/proxy_resolve_dns_operation.h"
 #include "net/proxy_resolution/proxy_resolver_v8_tracing.h"
 #include "services/proxy_resolver/host_resolver_mojo.h"
-#include "services/proxy_resolver/public/mojom/proxy_resolver.mojom.h"
 
 namespace proxy_resolver {
 
@@ -50,7 +41,7 @@
     client_->OnError(line_number, base::UTF16ToUTF8(message));
   }
 
-  net::ProxyHostResolver* GetHostResolver() override {
+  net::HostResolver* GetHostResolver() override {
     DCHECK(thread_checker_.CalledOnValidThread());
     return &host_resolver_;
   }
@@ -62,11 +53,10 @@
 
  private:
   // HostResolverMojo::Impl override.
-  void ResolveDns(const std::string& hostname,
-                  net::ProxyResolveDnsOperation operation,
+  void ResolveDns(std::unique_ptr<net::HostResolver::RequestInfo> request_info,
                   mojom::HostResolverRequestClientPtr client) override {
     DCHECK(thread_checker_.CalledOnValidThread());
-    client_->ResolveDns(hostname, operation, std::move(client));
+    client_->ResolveDns(std::move(request_info), std::move(client));
   }
 
   base::ThreadChecker thread_checker_;
--- a/services/proxy_resolver/mojo_proxy_resolver_v8_tracing_bindings_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/proxy_resolver/mojo_proxy_resolver_v8_tracing_bindings_unittest.cc	2019-05-17 18:53:37.952000000 +0300
@@ -29,8 +29,7 @@
     errors_.push_back(std::make_pair(line_number, message));
   }
 
-  void ResolveDns(const std::string& hostname,
-                  net::ProxyResolveDnsOperation operation,
+  void ResolveDns(std::unique_ptr<net::HostResolver::RequestInfo> request_info,
                   mojom::HostResolverRequestClientPtr client) {}
 
  protected:
--- a/services/proxy_resolver/OWNERS	2019-05-01 01:22:56.000000000 +0300
+++ b/services/proxy_resolver/OWNERS	2019-05-17 18:53:37.952000000 +0300
@@ -1 +1,4 @@
 file://services/network/OWNERS
+
+per-file manifest.json=set noparent
+per-file manifest.json=file://ipc/SECURITY_OWNERS
--- a/services/proxy_resolver/proxy_resolver_factory_impl.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/proxy_resolver/proxy_resolver_factory_impl.cc	2019-05-17 18:53:37.952000000 +0300
@@ -7,7 +7,6 @@
 #include <string>
 #include <utility>
 
-#include "base/bind.h"
 #include "base/macros.h"
 #include "mojo/public/cpp/bindings/strong_binding.h"
 #include "net/base/net_errors.h"
--- a/services/proxy_resolver/proxy_resolver_factory_impl_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/proxy_resolver/proxy_resolver_factory_impl_unittest.cc	2019-05-17 18:53:37.952000000 +0300
@@ -6,7 +6,6 @@
 
 #include <utility>
 
-#include "base/bind.h"
 #include "base/run_loop.h"
 #include "base/strings/utf_string_conversions.h"
 #include "base/test/scoped_task_environment.h"
@@ -15,7 +14,6 @@
 #include "net/base/completion_once_callback.h"
 #include "net/base/test_completion_callback.h"
 #include "net/proxy_resolution/mock_proxy_resolver.h"
-#include "net/proxy_resolution/proxy_resolve_dns_operation.h"
 #include "net/proxy_resolution/proxy_resolver_v8_tracing.h"
 #include "net/test/event_waiter.h"
 #include "net/test/gtest_util.h"
@@ -146,8 +144,7 @@
 
   void OnError(int32_t line_number, const std::string& message) override {}
 
-  void ResolveDns(const std::string& hostname,
-                  net::ProxyResolveDnsOperation operation,
+  void ResolveDns(std::unique_ptr<net::HostResolver::RequestInfo> request_info,
                   mojom::HostResolverRequestClientPtr client) override {}
 
   void WaitForNoServiceRefs() {
--- a/services/proxy_resolver/proxy_resolver_impl.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/proxy_resolver/proxy_resolver_impl.cc	2019-05-17 18:53:37.952000000 +0300
@@ -6,7 +6,6 @@
 
 #include <utility>
 
-#include "base/bind.h"
 #include "base/macros.h"
 #include "net/base/net_errors.h"
 #include "net/proxy_resolution/pac_file_data.h"
--- a/services/proxy_resolver/proxy_resolver_impl_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/proxy_resolver/proxy_resolver_impl_unittest.cc	2019-05-17 18:53:37.952000000 +0300
@@ -8,7 +8,6 @@
 #include <utility>
 #include <vector>
 
-#include "base/bind.h"
 #include "base/memory/ptr_util.h"
 #include "base/run_loop.h"
 #include "base/test/scoped_task_environment.h"
@@ -18,7 +17,6 @@
 #include "net/base/proxy_server.h"
 #include "net/proxy_resolution/mock_proxy_resolver.h"
 #include "net/proxy_resolution/proxy_info.h"
-#include "net/proxy_resolution/proxy_resolve_dns_operation.h"
 #include "net/proxy_resolution/proxy_resolver_v8_tracing.h"
 #include "net/test/event_waiter.h"
 #include "net/test/gtest_util.h"
@@ -53,8 +51,7 @@
   void ReportResult(int32_t error, const net::ProxyInfo& results) override;
   void Alert(const std::string& message) override;
   void OnError(int32_t line_number, const std::string& message) override;
-  void ResolveDns(const std::string& hostname,
-                  net::ProxyResolveDnsOperation operation,
+  void ResolveDns(std::unique_ptr<net::HostResolver::RequestInfo> request_info,
                   mojom::HostResolverRequestClientPtr client) override;
 
   // Mojo error handler.
@@ -98,10 +95,9 @@
 void TestRequestClient::OnError(int32_t line_number,
                                 const std::string& message) {}
 
-void TestRequestClient::ResolveDns(const std::string& hostname,
-                                   net::ProxyResolveDnsOperation operation,
-                                   mojom::HostResolverRequestClientPtr client) {
-}
+void TestRequestClient::ResolveDns(
+    std::unique_ptr<net::HostResolver::RequestInfo> request_info,
+    mojom::HostResolverRequestClientPtr client) {}
 
 void TestRequestClient::OnConnectionError() {
   event_waiter_.NotifyEvent(CONNECTION_ERROR);
--- a/services/proxy_resolver/proxy_resolver_service.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/proxy_resolver/proxy_resolver_service.cc	2019-05-17 18:53:37.952000000 +0300
@@ -6,7 +6,6 @@
 
 #include <utility>
 
-#include "base/bind.h"
 #include "build/build_config.h"
 #include "mojo/public/cpp/bindings/strong_binding.h"
 
--- a/services/proxy_resolver/public/cpp/mojo_host_struct_traits.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/proxy_resolver/public/cpp/mojo_host_struct_traits.cc	2019-05-17 18:53:37.952000000 +0300
@@ -12,47 +12,24 @@
 namespace mojo {
 
 // static
-proxy_resolver::mojom::HostResolveOperation
-EnumTraits<proxy_resolver::mojom::HostResolveOperation,
-           net::ProxyResolveDnsOperation>::ToMojom(net::ProxyResolveDnsOperation
-                                                       input) {
-  switch (input) {
-    case net::ProxyResolveDnsOperation::DNS_RESOLVE:
-      return proxy_resolver::mojom::HostResolveOperation::DNS_RESOLVE;
-    case net::ProxyResolveDnsOperation::DNS_RESOLVE_EX:
-      return proxy_resolver::mojom::HostResolveOperation::DNS_RESOLVE_EX;
-    case net::ProxyResolveDnsOperation::MY_IP_ADDRESS:
-      return proxy_resolver::mojom::HostResolveOperation::MY_IP_ADDRESS;
-    case net::ProxyResolveDnsOperation::MY_IP_ADDRESS_EX:
-      return proxy_resolver::mojom::HostResolveOperation::MY_IP_ADDRESS_EX;
-  }
+bool StructTraits<proxy_resolver::mojom::HostResolverRequestInfoDataView,
+                  std::unique_ptr<net::HostResolver::RequestInfo>>::
+    Read(proxy_resolver::mojom::HostResolverRequestInfoDataView data,
+         std::unique_ptr<net::HostResolver::RequestInfo>* out) {
+  base::StringPiece host;
+  if (!data.ReadHost(&host))
+    return false;
 
-  NOTREACHED();
-  return proxy_resolver::mojom::HostResolveOperation::kMinValue;
-}
+  net::AddressFamily address_family;
+  if (!data.ReadAddressFamily(&address_family))
+    return false;
 
-// static
-bool EnumTraits<proxy_resolver::mojom::HostResolveOperation,
-                net::ProxyResolveDnsOperation>::
-    FromMojom(proxy_resolver::mojom::HostResolveOperation input,
-              net::ProxyResolveDnsOperation* output) {
-  switch (input) {
-    case proxy_resolver::mojom::HostResolveOperation::DNS_RESOLVE:
-      *output = net::ProxyResolveDnsOperation::DNS_RESOLVE;
-      return true;
-    case proxy_resolver::mojom::HostResolveOperation::DNS_RESOLVE_EX:
-      *output = net::ProxyResolveDnsOperation::DNS_RESOLVE_EX;
+  *out = std::make_unique<net::HostResolver::RequestInfo>(
+      net::HostPortPair(host.as_string(), data.port()));
+  net::HostResolver::RequestInfo& request = **out;
+  request.set_address_family(address_family);
+  request.set_is_my_ip_address(data.is_my_ip_address());
       return true;
-    case proxy_resolver::mojom::HostResolveOperation::MY_IP_ADDRESS:
-      *output = net::ProxyResolveDnsOperation::MY_IP_ADDRESS;
-      return true;
-    case proxy_resolver::mojom::HostResolveOperation::MY_IP_ADDRESS_EX:
-      *output = net::ProxyResolveDnsOperation::MY_IP_ADDRESS_EX;
-      return true;
-  }
-
-  NOTREACHED();
-  return false;
 }
 
 }  // namespace mojo
--- a/services/proxy_resolver/public/cpp/mojo_host_struct_traits.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/proxy_resolver/public/cpp/mojo_host_struct_traits.h	2019-05-17 18:53:37.956000000 +0300
@@ -7,19 +7,38 @@
 
 #include "base/strings/string_piece.h"
 #include "mojo/public/cpp/bindings/enum_traits.h"
-#include "net/proxy_resolution/proxy_resolve_dns_operation.h"
+#include "mojo/public/cpp/bindings/struct_traits.h"
+#include "net/dns/host_resolver.h"
+#include "services/network/public/mojom/address_family.mojom.h"
 #include "services/proxy_resolver/public/mojom/proxy_resolver.mojom.h"
 
 namespace mojo {
 
 template <>
-struct EnumTraits<proxy_resolver::mojom::HostResolveOperation,
-                  net::ProxyResolveDnsOperation> {
-  static proxy_resolver::mojom::HostResolveOperation ToMojom(
-      net::ProxyResolveDnsOperation input);
+struct StructTraits<proxy_resolver::mojom::HostResolverRequestInfoDataView,
+                    std::unique_ptr<net::HostResolver::RequestInfo>> {
+  static base::StringPiece host(
+      const std::unique_ptr<net::HostResolver::RequestInfo>& obj) {
+    return obj->hostname();
+  }
 
-  static bool FromMojom(proxy_resolver::mojom::HostResolveOperation input,
-                        net::ProxyResolveDnsOperation* output);
+  static uint16_t port(
+      const std::unique_ptr<net::HostResolver::RequestInfo>& obj) {
+    return obj->port();
+  }
+
+  static net::AddressFamily address_family(
+      const std::unique_ptr<net::HostResolver::RequestInfo>& obj) {
+    return obj->address_family();
+  }
+
+  static bool is_my_ip_address(
+      const std::unique_ptr<net::HostResolver::RequestInfo>& obj) {
+    return obj->is_my_ip_address();
+  }
+
+  static bool Read(proxy_resolver::mojom::HostResolverRequestInfoDataView obj,
+                   std::unique_ptr<net::HostResolver::RequestInfo>* output);
 };
 
 }  // namespace mojo
--- a/services/proxy_resolver/public/cpp/OWNERS	2019-05-01 01:22:56.000000000 +0300
+++ b/services/proxy_resolver/public/cpp/OWNERS	2019-05-17 18:53:37.952000000 +0300
@@ -4,7 +4,3 @@
 per-file *_struct_traits*.*=file://ipc/SECURITY_OWNERS
 per-file *.typemap=set noparent
 per-file *.typemap=file://ipc/SECURITY_OWNERS
-per-file manifest.cc=set noparent
-per-file manifest.cc=file://ipc/SECURITY_OWNERS
-per-file manifest.h=set noparent
-per-file manifest.h=file://ipc/SECURITY_OWNERS
--- a/services/proxy_resolver/public/cpp/proxy_resolver.typemap	2019-05-01 01:22:56.000000000 +0300
+++ b/services/proxy_resolver/public/cpp/proxy_resolver.typemap	2019-05-17 18:53:37.956000000 +0300
@@ -5,8 +5,8 @@
 mojom = "//services/proxy_resolver/public/mojom/proxy_resolver.mojom"
 public_headers = [
   "//net/base/proxy_server.h",
+  "//net/dns/host_resolver.h",
   "//net/proxy_resolution/proxy_info.h",
-  "//net/proxy_resolution/proxy_resolve_dns_operation.h",
 ]
 traits_headers = [
   "//services/proxy_resolver/public/cpp/mojo_host_struct_traits.h",
@@ -17,7 +17,7 @@
   "//services/proxy_resolver/public/cpp/proxy_resolver_mojom_traits.cc",
 ]
 type_mappings = [
-  "proxy_resolver.mojom.HostResolveOperation=net::ProxyResolveDnsOperation",
+  "proxy_resolver.mojom.HostResolverRequestInfo=std::unique_ptr<net::HostResolver::RequestInfo>[move_only]",
   "proxy_resolver.mojom.ProxyInfo=net::ProxyInfo",
   "proxy_resolver.mojom.ProxyServer=net::ProxyServer",
   "proxy_resolver.mojom.ProxyServer::Scheme=net::ProxyScheme",
--- a/services/proxy_resolver/public/mojom/proxy_resolver.mojom	2019-05-01 01:22:56.000000000 +0300
+++ b/services/proxy_resolver/public/mojom/proxy_resolver.mojom	2019-05-17 18:53:37.956000000 +0300
@@ -7,24 +7,26 @@
 // TODO(amistry): Resolve the conflict between these two sets of definitions.
 module proxy_resolver.mojom;
 
-import "services/network/public/mojom/ip_address.mojom";
+import "services/network/public/mojom/address_family.mojom";
+import "services/network/public/mojom/address_list.mojom";
 import "url/mojom/url.mojom";
 
 const string kProxyResolverServiceName = "proxy_resolver";
 
-// Mirror of net::ProxyResolveDnsOperation.
-enum HostResolveOperation {
-  DNS_RESOLVE,
-  DNS_RESOLVE_EX,
-  MY_IP_ADDRESS,
-  MY_IP_ADDRESS_EX,
+// Mirror of net::HostResolver::RequestInfo.
+// TODO(mmenke): Remove this struct, in favor of passing values directly.
+struct HostResolverRequestInfo {
+  string host;
+  uint16 port;
+  network.mojom.AddressFamily address_family;
+  bool is_my_ip_address;
 };
 
 // Interface for waiting for the result of a HostResolver query.
-// TODO(mmenke): Remove this interface, in favor of callbacks.
+// TODO(mmenke): Remove this struct, in favor of callbacks.
 interface HostResolverRequestClient {
   // |error| is a value in net::Error.
-  ReportResult(int32 error, array<network.mojom.IPAddress> result);
+  ReportResult(int32 error, network.mojom.AddressList result);
 };
 
 // Mirror of net::ProxyServer::Scheme.
@@ -63,8 +65,7 @@
   Alert(string error);
   OnError(int32 line_number, string error);
 
-  ResolveDns(string host,
-             HostResolveOperation operation,
+  ResolveDns(HostResolverRequestInfo request_info,
              HostResolverRequestClient client);
 };
 
@@ -85,7 +86,6 @@
   Alert(string error);
   OnError(int32 line_number, string error);
 
-  ResolveDns(string host,
-             HostResolveOperation operation,
+  ResolveDns(HostResolverRequestInfo request_info,
              HostResolverRequestClient client);
 };
--- a/services/README.md	2019-05-01 01:22:56.000000000 +0300
+++ b/services/README.md	2019-05-17 18:53:37.772000000 +0300
@@ -1,256 +1,84 @@
-# Service Development Guidelines
+# Chrome Foundation Services
 
 [TOC]
 
 ## Overview
 
-If you're looking for general documentation on the Service Manager, what a
-"service" is, and how to build one, see the
-[Service Manager &amp; Services](/services/service_manager/README.md)
-documentation instead of this document.
-
-The top-level `//services` directory contains the sources, public Mojo interface
-definitions, and public client libraries for a number of essential services,
-designated as **Chrome Foundation Services**. If you think of Chrome as a
-"portable OS," Chrome Foundation Services can be thought of as the core system
-services of that OS.
-
-Each subdirectory here corresponds to a service that:
-
-- implements
-  [`Service`](https://cs.chromium.org/chromium/bservices/service_manager/public/cpp/service.h?rcl=ebec02bcca6e327b2e01855ce43ab1bec0aeef27&l=21)
-  and is thus a client of the Service Manager
-- generally focuses on a subset of functionality or features which are
-  thematically or functionally related in a way that makes sense given the name
-  of the service
-- could logically run in an isolated process for security or performance
-  isolation, depending on the constraints of the host OS
-
-*** aside
-Note that there are other parts of the tree which aggregate
-slightly-less-than-foundational service definitions, such as services specific
-to the Chrome browser, defined in `//chrome/services`. The motivations, advice,
-and standards discussed in this document apply to all service definitions in the
-Chromium tree.
-***
-
-The `//services/service_manager` directory contains the implementation and
-public APIs of the Service Manager itself, including an embedder API with which
-software applications (such as Chrome) can embed the Service Manager to manage
-their own multiprocess service architecture.
-
-One of the main motivations for expressing Chromium as a collection of services
-is long-term maintainability and code health. Because service API boundaries are
-strictly limited to Mojo interfaces, state owned and managed by each service is
-strongly isolated from other components in the system.
-
-Another key motivation is general modularity and reusability: in the past there
-have been a number of missed opportunities for potential new features or
-Chromium-based products due to the browser's generally monolothic and inflexible
-system design. With the Service Manager &amp; services providing scaffolding for
-system components, it becomes progressively easier to build out newer use cases
-with *e.g.* a smaller resource footprint, or a different process model, or even
-a more granular binary distribution.
-
-## Service Standards
-
-As outlined above, individual services are intended for graceful reusability
-across a broad variety of use cases. To enable this goal, we have rigorous
-standards on services' structure and public API design. Before doing significant
-work in `//services` (or other places where services are defined), please
-internalize these standards. All Chromium developers are responsible for
-upholding them!
-
-### Public Service APIs
-
-In creating and maintaining a service's public API, please respect the following
-principles:
-
-- The purpose of a service should be readily apparent.
-- The supported client use cases of the service should be easy for a new
-  consumer to understand.
-- The service should use idioms and design patterns consistent with other
-  services.
-- From the service's public API documentation and tests, it should be feasible
-  to develop a new implementation of the service which satisfies existing
-  clients and doesn't require mimicking internal implementation details of the
-  existing service.
-- Perhaps most important of all, a service's public API should be designed with
-  multiple hypothetical clients in mind, *not* focused on supporting only a
-  single narrow use known at development time. **Always be thinking about the
-  future!**
-
-If you're working on a new service and have concerns or doubts about API design,
-please post to
-[services-dev@chromium.org](https://groups.google.com/a/chromium.org/forum#!forum/services-dev)
-and ask for help. The list is generally quite responsive, and it's loaded with
-people who have done a lot of work on services.
-
-### Service API Design Tips
-
-#### Using Interface Factories to Establish Context
-
-One common pitfall when designing service APIs is to write something like:
-
-``` cpp
-interface GoatTeleporter {
-  // Sets the client interface pipe for this teleporter. Must be called before
-  // other interface methods.
-  SetClient(GoatTeleporterClient client);
-
-  TeleportGoat(string name);
-};
-
-interface GoatTeleporterClient {
-  TeleporterReady();
-};
-```
-
-The problem with this approach is that a client may easily fail to call
-`SetClient` before calling `TeleportGoat`. When such ordering requirements are
-necessary, the service can benefit clients by designing an API that is harder
-to fail at. For example:
-
-``` cpp
-interface GoatTeleporterFactory {
-  GetGoatTeleporter(GoatTeleporter& request, GoatTeleporterClient client);
-};
-
-interface GoatTeleporter {
-  TeleportGoat(string name);
-};
-```
-
-Instead of exposing `GoatTeleporter` directly to other services, the service can
-expose `GoatTeleporterFactory` instead. Now it's impossible for a client to
-acquire a functioning `GoatTeleporter` pipe without also providing a
-corresponding client pipe to complement it.
-
-### Service &amp; Interface Naming
-
-Just some basic tips for service and interface naming:
-
-- Strive to give your service a name that makes it immediately obvious what the
-  service is for (*e.g.*, `"network"`, `"metrics"`) rather than a meaningless
-  codename like `"cromulator_3000"`.
-- Avoid the usage of `"Service"` in interface names. While the term "service"
-  is overloaded in Chromium and certainly has plenty of valid interpretations,
-  in the context of Service Manager services it has a very specific meaning
-  and should not be overloaded further if possible. An interface which exposes a
-  control API for a goat teleporter can just be called `GoatTeleporter`, not
-  `GoatTeleporterService`.
-
-- Strive to avoid conceptual layering violations in naming and documentation --
-  *e.g.*, avoid referencing Blink or Content concepts like "renderers" or
-  "frame hosts".
-
-- Use the names `FooClient` and `FooObserver` consistently in interfaces. If
-  there is an expected 1:1 correspondence between a Foo and its client interface
-  counterpart, that counterpart should most likely be called `FooClient`. If
-  there is expected to be 1-to-many correspondence between a Foo and its
-  counterpart clients, the client interface may be better named `FooObserver`.
-
-### Service Directory &amp; Dependency Structure
-
-Services typically follow a canonical directory structure:
+This directory contains Chrome Foundation Services. If you think of Chrome as a
+"portable OS," Chrome Foundation Services can be thought of as that OS'
+foundational "system services" layer.
 
-```
-//services/service_name/               # Private implementation
-                        public/
-                               mojom/  # Mojom interfaces
-                               cpp/    # C++ client libraries (optional)
-                               java/   # Java client libararies (optional, rare)
-                               js/     # JS client libraries (optional, rare)
-```
-
-As a general rule, **nothing below `/public` can depend on the private service
-implementation** (*i.e.* things above `/public`). Enforcing this principle makes
-it much easier to keep the service's state well-isolated from the rest of the
-system.
+Roughly each subdirectory here corresponds to a service that:
 
-Generally the language-specific client libraries are built against only the
-public mojom API of the service (and usually few other common dependencies like
-`//base` and `//mojo`), and they bootstrap connections to those interfaces by
-using public Service Manager APIs like
-[`Connector`](/services/service_manager/README.md#Connectors).
+  * is a client of `//services/service_manager` with its own unique Identity.
+  * could logically run a standalone process for security/performance isolation
+    benefits depending on the constraints of the host OS.
 
-Even in the private service implementation, services should not depend on very
-large components like Content, Chrome, or Blink.
+## API Standards
 
-*** aside
-NOTE: Exceptions to the above rule are made in rare cases where Blink or V8 is
-actually required as part of the service implementation. For example
-`"data_decoder"` uses Blink implementation to decode common image formats, and
-`"proxy_resolver"` uses V8 to execute proxy autoconfig scripts.
-***
+As illustrated above, the individual services in //services are intended for
+graceful reusability across a broad variety of use cases. To enable this goal,
+we have rigorous [standards](/services/api_standards.md) on services'
+public APIs. Before doing significant work in //services (and especially before
+becoming an owner of a service), please internalize these standards -- you are
+responsible for upholding them.
 
-### Service Documentation
+## Service Directory Structure
 
-- Every service should have a top-level `README.md` that explains the purpose and
-  supported usage models of the service.
+Individual services are structured like so:
 
-- Every public interface should be documented within its Mojom file at both the
-  interface level and indivudal message level.
-
-- Interface documentation should be complete enough to serve as test
-  specifications. If the method returns information of a user's accounts, what
-  should happen if the user is not signed in? If the method makes a request for
-  an access token, what happens if a client makes a second method call before
-  the first one has completed? If the method returns a nullable object, under
-  which conditions will it be null?
+```
+//services/foo/                   <-- Implementation code, may have subdirs.
+              /public/
+                     /cpp/        <-- C++ client libraries (optional)
+                     /mojom/      <-- Mojom interfaces
+```
 
-- Avoid writing interface documentation which is unnecessarily prescriptive
-  about implementation details. Keep in mind that these are **interface**
-  definitions, not implementations thereof.
+## Dependencies
 
-- Avoid writing documentation which is tailored to a specific client.
+Code within `//services` may only depend on each other via each other's
+`/public/` directories, *i.e.* implementation code may not be shared directly.
 
-### Service Testing
+Service code should also take care to tightly limit the dependencies on static
+libraries from outside of `//services`. Dependencies to large platform
+layers like `//content`, `//chrome` or `//third_party/WebKit` must be avoided.
 
-- Try to cover service implementation details with unit tests tied as closely
-  as possible to the private implementation object or method being tested,
-  rather than exercising implementation details through public API surface.
+## Physical Packaging
 
-- For integration tests, try to have tests cover as much of the public API
-  surface as possible while mocking out as little of the underlying service as
-  possible.
+Note that while it may be possible to build a discrete physical package (DSO)
+for each service, products consuming these services may package them
+differently, e.g. by combining them into a single package.
 
-- Treat the public API tests as "conformance tests" which clearly demonstrate
-  what expectations and guarantees are supposed to be upheld by *any*
-  implementation of the service's APIs.
+## Additional Documentation
 
-- Take advantage of the
-  [test support library](https://cs.chromium.org/chromium/bservices/service_manager/public/cpp/test/)
-  provided by the Service Manager. In particular, `TestConnectorFactory` is
-  useful for driving public API tests with the service running inside the test
-  process, and `TestServiceManager` makes it possible to easily cover
-  out-of-process testing scenarios while faking out as little of the system as
-  possible.
+[High-level Design Doc](https://docs.google.com/document/d/15I7sQyQo6zsqXVNAlVd520tdGaS8FCicZHrN0yRu-oU)
 
-## Adding a New Service
+[Servicification Homepage](https://sites.google.com/a/chromium.org/dev/servicification)
 
-See the [Service Manager documentation](/services/service_manager/README.md) for
-more details regarding how to define a service and expose or consume interfaces
-to and from it, as well as how to make the service available to an application's
-runtime environment.
+[Servicification Strategies](/docs/servicification.md)
 
-Please start a thread on
-[services-dev@chromium.org](https://groups.google.com/a/chromium.org/forum/#!forum/services-dev)
-if you want to propose the introduction of a new service.
+## Relationship To Other Top-Level Directories
 
-If you are servicifying an existing Chromium feature, please check out
-[Servicifying Chromium Features](/docs/servicification.md).
+Services can be thought of as integrators of library code from across the
+Chromium repository, most commonly `//base` and `//mojo` (obviously) but for
+each service also `//components`, `//ui`, *etc.* in accordance with the
+functionality they provide.
 
-## Other Docs
+Not everything in `//components` is automatically a service in its own right.
+Think of `//components` as sort of like a `//lib`. Individual `//components` can
+define, implement and use Mojom interfaces, but only `//services` have unique
+identities with the Service Manager and so only `//services` make it possible
+for Mojom interfaces to be acquired.
 
-Here are some other external documents that aren't quite fully captured by any
-documents in the Chromium tree. Beware of obsolete information:
+## Adding a new service
 
-- [High-level Design Doc](https://docs.google.com/document/d/15I7sQyQo6zsqXVNAlVd520tdGaS8FCicZHrN0yRu-oU)
-- [Servicification Homepage](https://sites.google.com/a/chromium.org/dev/servicification)
+See the [Service Manager documentation](/services/service_manager) for more
+details regarding how to define a service and expose or consume interfaces to
+and from other services.
 
-## Additional Support
+Please start a thread on [services-dev@chromium.org](https://groups.google.com/a/chromium.org/forum/#!forum/services-dev)
+if you want to introduce a new service.
 
-You can always post to
-[services-dev@chromium.org](https://groups.google.com/a/chromium.org/forum#!forum/services-dev)
-with questions or concerns about anything related to service development.
+If you are servicifying existing Chromium code: Please first read the
+[servicification strategies documentation](/docs/servicification.md), which
+contains information that will hopefully make your task easier.
--- a/services/resource_coordinator/BUILD.gn	2019-05-01 01:22:56.000000000 +0300
+++ b/services/resource_coordinator/BUILD.gn	2019-05-17 18:53:37.956000000 +0300
@@ -2,11 +2,29 @@
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
+import("//services/service_manager/public/service_manifest.gni")
+
 # There should be only one resource coordinator. It is currently
 # in the browser process. So, only //content/browser should link to this target.
 # Others modules should only need the public targets.
 source_set("lib") {
   sources = [
+    "coordination_unit/coordination_unit_base.cc",
+    "coordination_unit/coordination_unit_base.h",
+    "coordination_unit/coordination_unit_graph.cc",
+    "coordination_unit/coordination_unit_graph.h",
+    "coordination_unit/coordination_unit_introspector_impl.cc",
+    "coordination_unit/coordination_unit_introspector_impl.h",
+    "coordination_unit/coordination_unit_provider_impl.cc",
+    "coordination_unit/coordination_unit_provider_impl.h",
+    "coordination_unit/frame_coordination_unit_impl.cc",
+    "coordination_unit/frame_coordination_unit_impl.h",
+    "coordination_unit/page_coordination_unit_impl.cc",
+    "coordination_unit/page_coordination_unit_impl.h",
+    "coordination_unit/process_coordination_unit_impl.cc",
+    "coordination_unit/process_coordination_unit_impl.h",
+    "coordination_unit/system_coordination_unit_impl.cc",
+    "coordination_unit/system_coordination_unit_impl.h",
     "memory_instrumentation/coordinator_impl.cc",
     "memory_instrumentation/coordinator_impl.h",
     "memory_instrumentation/graph.cc",
@@ -21,8 +39,21 @@
     "memory_instrumentation/queued_request_dispatcher.h",
     "memory_instrumentation/switches.cc",
     "memory_instrumentation/switches.h",
+    "observers/background_metrics_reporter.h",
+    "observers/coordination_unit_graph_observer.cc",
+    "observers/coordination_unit_graph_observer.h",
+    "observers/metrics_collector.cc",
+    "observers/metrics_collector.h",
+    "observers/page_signal_generator_impl.cc",
+    "observers/page_signal_generator_impl.h",
+    "observers/working_set_trimmer_win.cc",
+    "observers/working_set_trimmer_win.h",
+    "resource_coordinator_clock.cc",
+    "resource_coordinator_clock.h",
     "resource_coordinator_service.cc",
     "resource_coordinator_service.h",
+    "webui_graph_dump_impl.cc",
+    "webui_graph_dump_impl.h",
   ]
 
   configs += [ "//build/config/compiler:wexit_time_destructors" ]
@@ -37,19 +68,43 @@
   ]
 }
 
+service_manifest("manifest") {
+  name = "resource_coordinator"
+  source = "manifest.json"
+}
+
 source_set("tests") {
   testonly = true
 
   sources = [
+    "coordination_unit/coordination_unit_base_unittest.cc",
+    "coordination_unit/coordination_unit_graph_unittest.cc",
+    "coordination_unit/coordination_unit_test_harness.cc",
+    "coordination_unit/coordination_unit_test_harness.h",
+    "coordination_unit/frame_coordination_unit_impl_unittest.cc",
+    "coordination_unit/mock_coordination_unit_graphs.cc",
+    "coordination_unit/mock_coordination_unit_graphs.h",
+    "coordination_unit/page_coordination_unit_impl_unittest.cc",
+    "coordination_unit/process_coordination_unit_impl_unittest.cc",
+    "coordination_unit/system_coordination_unit_impl_unittest.cc",
     "memory_instrumentation/coordinator_impl_unittest.cc",
     "memory_instrumentation/graph_processor_unittest.cc",
     "memory_instrumentation/graph_unittest.cc",
     "memory_instrumentation/process_map_unittest.cc",
+    "observers/coordination_unit_graph_observer_unittest.cc",
+    "observers/metrics_collector_unittest.cc",
+    "observers/page_signal_generator_impl_unittest.cc",
+    "observers/working_set_trimmer_win_unittest.cc",
     "public/cpp/memory_instrumentation/memory_instrumentation_mojom_traits_unittest.cc",
     "public/cpp/memory_instrumentation/os_metrics_unittest.cc",
     "public/cpp/memory_instrumentation/tracing_integration_unittest.cc",
+    "webui_graph_dump_impl_unittest.cc",
   ]
 
+  if (!is_android) {
+    sources += [ "resource_coordinator_service_unittest.cc" ]
+  }
+
   deps = [
     ":lib",
     "//base",
@@ -57,7 +112,6 @@
     "//components/ukm:test_support",
     "//mojo/public/cpp/bindings",
     "//services/resource_coordinator/public/cpp:resource_coordinator_cpp",
-    "//services/resource_coordinator/public/cpp/memory_instrumentation:memory_instrumentation",
     "//services/service_manager/public/cpp",
     "//services/service_manager/public/cpp/test:test_support",
     "//services/service_manager/public/mojom",
--- a/services/resource_coordinator/memory_instrumentation/coordinator_impl_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/resource_coordinator/memory_instrumentation/coordinator_impl_unittest.cc	2019-05-17 18:53:37.960000000 +0300
@@ -276,7 +276,7 @@
     raw_os_dump->memory_maps.push_back(std::move(vm_region));
   }
   return raw_os_dump;
-}
+};
 
 // Tests that the global dump is acked even in absence of clients.
 TEST_F(CoordinatorImplTest, NoClients) {
--- a/services/resource_coordinator/memory_instrumentation/queued_request_dispatcher.cc	2019-05-17 17:45:42.568000000 +0300
+++ b/services/resource_coordinator/memory_instrumentation/queued_request_dispatcher.cc	2019-05-17 18:53:37.960000000 +0300
@@ -6,13 +6,9 @@
 
 #include <inttypes.h>
 
-#include "base/android/library_loader/anchor_functions_buildflags.h"
-#include "base/bind.h"
 #include "base/command_line.h"
-#include "base/format_macros.h"
 #include "base/logging.h"
 #include "base/metrics/histogram_macros.h"
-#include "base/process/process_metrics.h"
 #include "base/strings/pattern.h"
 #include "base/strings/stringprintf.h"
 #include "base/trace_event/trace_event.h"
@@ -71,69 +67,6 @@
 #endif
 }
 
-#if BUILDFLAG(SUPPORTS_CODE_ORDERING)
-void LogNativeCodeResidentPages(const std::set<size_t>& accessed_pages_set) {
-  // |SUPPORTS_CODE_ORDERING| can only be enabled on Android.
-  const auto kResidentPagesPath = base::FilePath(
-      "/data/local/tmp/chrome/native-library-resident-pages.txt");
-
-  auto file = base::File(kResidentPagesPath, base::File::FLAG_CREATE_ALWAYS |
-                                                 base::File::FLAG_WRITE);
-
-  if (!file.IsValid()) {
-    DLOG(ERROR) << "Could not open " << kResidentPagesPath;
-    return;
-  }
-
-  for (size_t page : accessed_pages_set) {
-    std::string page_str = base::StringPrintf("%" PRIuS "\n", page);
-
-    if (file.WriteAtCurrentPos(page_str.c_str(),
-                               static_cast<int>(page_str.size())) < 0) {
-      DLOG(WARNING) << "Error while dumping Resident pages";
-      return;
-    }
-  }
-}
-
-size_t ReportGlobalNativeCodeResidentMemoryKb(
-    const std::map<base::ProcessId, mojom::RawOSMemDump*>& pid_to_pmd) {
-  std::vector<uint8_t> common_map;
-
-  for (const auto& pmd : pid_to_pmd) {
-    if (!pmd.second || pmd.second->native_library_pages_bitmap.empty()) {
-      DLOG(WARNING) << "No process pagemap entry for " << pmd.first;
-      return 0;
-    }
-
-    if (common_map.size() < pmd.second->native_library_pages_bitmap.size()) {
-      common_map.resize(pmd.second->native_library_pages_bitmap.size());
-    }
-    for (size_t i = 0; i < pmd.second->native_library_pages_bitmap.size();
-         ++i) {
-      common_map[i] |= pmd.second->native_library_pages_bitmap[i];
-    }
-  }
-
-  // |accessed_pages_set| will be ~40kB on 32 bit mode and ~80kB on 64 bit mode.
-  std::set<size_t> accessed_pages_set;
-  for (size_t i = 0; i < common_map.size(); i++) {
-    for (int j = 0; j < 8; j++) {
-      if (common_map[i] & (1 << j))
-        accessed_pages_set.insert(i * 8 + j);
-    }
-  }
-
-  if (base::CommandLine::ForCurrentProcess()->HasSwitch(
-          "log-native-library-residency")) {
-    LogNativeCodeResidentPages(accessed_pages_set);
-  }
-
-  const size_t kPageSize = base::GetPageSize();
-  return accessed_pages_set.size() * kPageSize / 1024;
-}
-#endif  // #if BUILDFLAG(SUPPORTS_CODE_ORDERING)
-
 memory_instrumentation::mojom::OSMemDumpPtr CreatePublicOSDump(
     const mojom::RawOSMemDump& internal_os_dump,
     uint32_t shared_resident_kb) {
@@ -290,7 +223,7 @@
     // This must occur before the call to RequestOSMemoryDump, as
     // ClientProcessImpl will [for macOS], delay the calculations for the
     // OSMemoryDump until the Chrome memory dump is finished. See
-    // https://bugs.ch40m1um.qjz9zk/p/chromium/issues/detail?id=812346#c16 for more
+    // https://bugs.chromium.org/p/chromium/issues/detail?id=812346#c16 for more
     // details.
     if (!request->args.memory_footprint_only) {
       request->pending_responses.insert({client, ResponseType::kChromeDump});
@@ -509,7 +442,6 @@
   mojom::GlobalMemoryDumpPtr global_dump(mojom::GlobalMemoryDump::New());
   global_dump->start_time = request->start_time;
   global_dump->process_dumps.reserve(request->responses.size());
-  global_dump->aggregated_metrics = mojom::AggregatedMetrics::New();
   for (const auto& response : request->responses) {
     base::ProcessId pid = response.second.process_id;
 
@@ -613,13 +545,6 @@
     global_dump->process_dumps.push_back(std::move(pmd));
   }
 
-#if BUILDFLAG(SUPPORTS_CODE_ORDERING)
-  size_t native_resident_kb =
-      ReportGlobalNativeCodeResidentMemoryKb(pid_to_os_dump);
-  global_dump->aggregated_metrics->native_library_resident_kb =
-      native_resident_kb;
-#endif  // BUILDFLAG(SUPPORTS_CODE_ORDERING)
-
   const bool global_success = request->failed_memory_dump_count == 0;
 
   // In the single process-case, we want to ensure that global_success
--- a/services/resource_coordinator/OWNERS	2019-05-01 01:22:56.000000000 +0300
+++ b/services/resource_coordinator/OWNERS	2019-05-17 18:53:37.956000000 +0300
@@ -1,10 +1,11 @@
 chrisha@chromium.org
 fdoray@chromium.org
-
-# Emeritus:
 haraken@chromium.org
 lpy@chromium.org
 oysteine@chromium.org
 zhenw@chromium.org
 
 per-file BUILD.gn=file://services/resource_coordinator/memory_instrumentation/OWNERS
+
+per-file manifest.json=set noparent
+per-file manifest.json=file://ipc/SECURITY_OWNERS
--- a/services/resource_coordinator/public/cpp/BUILD.gn	2019-05-01 01:22:56.000000000 +0300
+++ b/services/resource_coordinator/public/cpp/BUILD.gn	2019-05-17 18:53:37.964000000 +0300
@@ -32,8 +32,23 @@
   ]
 }
 
-# TODO(siggi): Remove this target and redirect users to specific dependencies.
-source_set("resource_coordinator_cpp") {
+component("resource_coordinator_cpp") {
+  sources = [
+    "frame_resource_coordinator.cc",
+    "frame_resource_coordinator.h",
+    "page_resource_coordinator.cc",
+    "page_resource_coordinator.h",
+    "process_resource_coordinator.cc",
+    "process_resource_coordinator.h",
+    "resource_coordinator_interface.h",
+    "system_resource_coordinator.cc",
+    "system_resource_coordinator.h",
+  ]
+
+  configs += [ "//build/config/compiler:wexit_time_destructors" ]
+
+  defines = [ "IS_SERVICES_RESOURCE_COORDINATOR_PUBLIC_CPP_IMPL" ]
+
   public_deps = [
     ":resource_coordinator_cpp_base",
     ":resource_coordinator_cpp_features",
@@ -44,18 +59,3 @@
     "//services/service_manager/public/cpp",
   ]
 }
-
-source_set("manifest") {
-  sources = [
-    "manifest.cc",
-    "manifest.h",
-  ]
-
-  deps = [
-    "//base",
-    "//services/metrics/public/mojom",
-    "//services/resource_coordinator/public/mojom",
-    "//services/service_manager/public/cpp",
-    "//services/service_manager/public/mojom",
-  ]
-}
--- a/services/resource_coordinator/public/cpp/memory_instrumentation/client_process_impl.h	2019-05-17 17:45:42.572000000 +0300
+++ b/services/resource_coordinator/public/cpp/memory_instrumentation/client_process_impl.h	2019-05-17 18:53:37.964000000 +0300
@@ -94,7 +94,7 @@
   // to complete before running the OS calculations. The key to this map is the
   // dump_guid of that RequestChromeMemoryDumpCallback, the value a vector of
   // callbacks to calculate and run. For more details, see
-  // https://bugs.ch40m1um.qjz9zk/p/chromium/issues/detail?id=812346#c16.
+  // https://bugs.chromium.org/p/chromium/issues/detail?id=812346#c16.
   std::map<uint64_t, std::vector<OSMemoryDumpArgs>>
       delayed_os_memory_dump_callbacks_;
   base::Optional<uint64_t> most_recent_chrome_memory_dump_guid_;
--- a/services/resource_coordinator/public/cpp/memory_instrumentation/global_memory_dump.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/resource_coordinator/public/cpp/memory_instrumentation/global_memory_dump.cc	2019-05-17 18:53:37.964000000 +0300
@@ -4,14 +4,10 @@
 
 #include "services/resource_coordinator/public/cpp/memory_instrumentation/global_memory_dump.h"
 
-#include <vector>
-
 namespace memory_instrumentation {
 
 GlobalMemoryDump::GlobalMemoryDump(
-    std::vector<mojom::ProcessMemoryDumpPtr> process_dumps,
-    mojom::AggregatedMetricsPtr aggregated_metrics)
-    : aggregated_metrics_(std::move(aggregated_metrics)) {
+    std::vector<mojom::ProcessMemoryDumpPtr> process_dumps) {
   auto it = process_dumps_.before_begin();
   for (mojom::ProcessMemoryDumpPtr& process_dump : process_dumps) {
     it = process_dumps_.emplace_after(it, std::move(process_dump));
@@ -22,8 +18,7 @@
 std::unique_ptr<GlobalMemoryDump> GlobalMemoryDump::MoveFrom(
     mojom::GlobalMemoryDumpPtr ptr) {
   return ptr ? std::unique_ptr<GlobalMemoryDump>(
-                   new GlobalMemoryDump(std::move(ptr->process_dumps),
-                                        std::move(ptr->aggregated_metrics)))
+                   new GlobalMemoryDump(std::move(ptr->process_dumps)))
              : nullptr;
 }
 
@@ -46,10 +41,4 @@
   return base::Optional<uint64_t>(metric_it->second);
 }
 
-GlobalMemoryDump::AggregatedMetrics::AggregatedMetrics(
-    mojom::AggregatedMetricsPtr aggregated_metrics)
-    : aggregated_metrics_(std::move(aggregated_metrics)) {}
-
-GlobalMemoryDump::AggregatedMetrics::~AggregatedMetrics() = default;
-
 }  // namespace memory_instrumentation
--- a/services/resource_coordinator/public/cpp/memory_instrumentation/global_memory_dump.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/resource_coordinator/public/cpp/memory_instrumentation/global_memory_dump.h	2019-05-17 18:53:37.964000000 +0300
@@ -5,9 +5,6 @@
 #ifndef SERVICES_RESOURCE_COORDINATOR_PUBLIC_CPP_MEMORY_INSTRUMENTATION_GLOBAL_MEMORY_DUMP_H_
 #define SERVICES_RESOURCE_COORDINATOR_PUBLIC_CPP_MEMORY_INSTRUMENTATION_GLOBAL_MEMORY_DUMP_H_
 
-#include <utility>
-#include <vector>
-
 #include "base/component_export.h"
 #include "base/optional.h"
 #include "services/resource_coordinator/public/mojom/memory_instrumentation/memory_instrumentation.mojom.h"
@@ -42,25 +39,6 @@
     DISALLOW_COPY_AND_ASSIGN(ProcessDump);
   };
 
- public:
-  class COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MEMORY_INSTRUMENTATION)
-      AggregatedMetrics {
-   public:
-    AggregatedMetrics(mojom::AggregatedMetricsPtr aggregated_metrics);
-    ~AggregatedMetrics();
-
-    size_t native_library_resident_kb() const {
-      if (!aggregated_metrics_)
-        return 0;
-      return aggregated_metrics_->native_library_resident_kb;
-    }
-
-   private:
-    mojom::AggregatedMetricsPtr aggregated_metrics_;
-
-    DISALLOW_COPY_AND_ASSIGN(AggregatedMetrics);
-  };
-
   ~GlobalMemoryDump();
 
   // Creates an owned instance of this class wrapping the given mojo struct.
@@ -71,14 +49,10 @@
     return process_dumps_;
   }
 
-  const AggregatedMetrics& aggregated_metrics() { return aggregated_metrics_; }
-
  private:
-  GlobalMemoryDump(std::vector<mojom::ProcessMemoryDumpPtr> process_dumps,
-                   mojom::AggregatedMetricsPtr aggregated_metrics);
+  GlobalMemoryDump(std::vector<mojom::ProcessMemoryDumpPtr> process_dumps);
 
   std::forward_list<ProcessDump> process_dumps_;
-  AggregatedMetrics aggregated_metrics_;
 
   DISALLOW_COPY_AND_ASSIGN(GlobalMemoryDump);
 };
--- a/services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.cc	2019-05-17 18:53:37.964000000 +0300
@@ -4,7 +4,6 @@
 
 #include "services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.h"
 
-#include "base/bind.h"
 #include "base/single_thread_task_runner.h"
 #include "base/threading/thread_task_runner_handle.h"
 
--- a/services/resource_coordinator/public/cpp/memory_instrumentation/os_metrics.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/resource_coordinator/public/cpp/memory_instrumentation/os_metrics.h	2019-05-17 18:53:37.964000000 +0300
@@ -4,8 +4,6 @@
 #ifndef SERVICES_RESOURCE_COORDINATOR_PUBLIC_CPP_MEMORY_INSTRUMENTATION_OS_METRICS_H_
 #define SERVICES_RESOURCE_COORDINATOR_PUBLIC_CPP_MEMORY_INSTRUMENTATION_OS_METRICS_H_
 
-#include <vector>
-
 #include "base/component_export.h"
 #include "base/gtest_prod_util.h"
 #include "base/process/process_handle.h"
@@ -15,7 +13,7 @@
 
 namespace heap_profiling {
 FORWARD_DECLARE_TEST(ProfilingJsonExporterTest, MemoryMaps);
-}
+};
 
 namespace memory_instrumentation {
 
@@ -36,7 +34,6 @@
   FRIEND_TEST_ALL_PREFIXES(OSMetricsTest, ParseProcSmaps);
   FRIEND_TEST_ALL_PREFIXES(OSMetricsTest, TestWinModuleReading);
   FRIEND_TEST_ALL_PREFIXES(OSMetricsTest, TestMachOReading);
-  FRIEND_TEST_ALL_PREFIXES(OSMetricsTest, GetMappedAndResidentPages);
   FRIEND_TEST_ALL_PREFIXES(heap_profiling::ProfilingJsonExporterTest,
                            MemoryMaps);
 
@@ -44,28 +41,6 @@
   static std::vector<mojom::VmRegionPtr> GetProcessModules(base::ProcessId);
 #endif
 
-#if defined(OS_LINUX) || defined(OS_ANDROID)
-  // Provides information on the dump state of resident pages.
-  enum class MappedAndResidentPagesDumpState {
-    // Access to /proc/<pid>/pagemap can be denied for android devices running
-    // a kernel version < 4.4.
-    kAccessPagemapDenied,
-    kFailure,
-    kSuccess
-  };
-
-  // Depends on /proc/self/pagemap to determine mapped and resident pages
-  // within bounds (start_address inclusive and end_address exclusive).
-  // It does not use mincore() because it only checks to see
-  // if the page is in the cache and up to date.
-  // mincore() has no guarantee a page has been mapped by the current process.
-  // Guaranteed to work on Android.
-  static MappedAndResidentPagesDumpState GetMappedAndResidentPages(
-      const size_t start_address,
-      const size_t end_address,
-      std::vector<uint8_t>* accessed_pages_bitmap);
-
-#endif  // defined(OS_LINUX) || defined(OS_ANDROID)
 };
 
 }  // namespace memory_instrumentation
--- a/services/resource_coordinator/public/cpp/memory_instrumentation/os_metrics_linux.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/resource_coordinator/public/cpp/memory_instrumentation/os_metrics_linux.cc	2019-05-17 18:53:37.964000000 +0300
@@ -7,9 +7,7 @@
 #include <stdint.h>
 #include <memory>
 
-#include "base/android/library_loader/anchor_functions.h"
-#include "base/android/library_loader/anchor_functions_buildflags.h"
-#include "base/debug/elf_reader.h"
+#include "base/debug/elf_reader_linux.h"
 #include "base/files/file_util.h"
 #include "base/files/scoped_file.h"
 #include "base/format_macros.h"
@@ -34,7 +32,7 @@
 base::ScopedFD OpenStatm(base::ProcessId pid) {
   std::string name =
       "/proc/" +
-      (pid == base::kNullProcessId ? "self" : base::NumberToString(pid)) +
+      (pid == base::kNullProcessId ? "self" : base::IntToString(pid)) +
       "/statm";
   base::ScopedFD fd = base::ScopedFD(open(name.c_str(), O_RDONLY));
   return fd;
@@ -71,12 +69,11 @@
   ModuleData module_data;
   Dl_info dl_info;
   if (dladdr(&__ehdr_start, &dl_info)) {
-    base::debug::ElfBuildIdBuffer build_id;
-    size_t build_id_length =
-        base::debug::ReadElfBuildId(&__ehdr_start, true, build_id);
-    if (build_id_length) {
+    base::Optional<std::string> build_id =
+        base::debug::ReadElfBuildId(&__ehdr_start);
+    if (build_id) {
       module_data.path = dl_info.dli_fname;
-      module_data.build_id = std::string(build_id, build_id_length);
+      module_data.build_id = *build_id;
     }
   }
   return module_data;
@@ -244,28 +241,6 @@
   dump->platform_private_footprint->vm_swap_bytes = vm_swap_bytes;
   dump->resident_set_kb = process_metrics->GetResidentSetSize() / 1024;
 
-#if defined(OS_ANDROID)
-#if BUILDFLAG(SUPPORTS_CODE_ORDERING)
-  if (!base::android::AreAnchorsSane()) {
-    DLOG(WARNING) << "Incorrect code ordering";
-    return false;
-  }
-
-  std::vector<uint8_t> accessed_pages_bitmap;
-  OSMetrics::MappedAndResidentPagesDumpState state =
-      OSMetrics::GetMappedAndResidentPages(base::android::kStartOfText,
-                                           base::android::kEndOfText,
-                                           &accessed_pages_bitmap);
-
-  // MappedAndResidentPagesDumpState |state| can be |kAccessPagemapDenied|
-  // for Android devices running a kernel version < 4.4.
-  if (state != OSMetrics::MappedAndResidentPagesDumpState::kSuccess)
-    return state != OSMetrics::MappedAndResidentPagesDumpState::kFailure;
-
-  dump->native_library_pages_bitmap = std::move(accessed_pages_bitmap);
-#endif  // BUILDFLAG(SUPPORTS_CODE_ORDERING)
-#endif  //  defined(OS_ANDROID)
-
   return true;
 }
 
@@ -278,7 +253,7 @@
   } else {
     std::string file_name =
         "/proc/" +
-        (pid == base::kNullProcessId ? "self" : base::NumberToString(pid)) +
+        (pid == base::kNullProcessId ? "self" : base::IntToString(pid)) +
         "/smaps";
     base::ScopedFILE smaps_file(fopen(file_name.c_str(), "r"));
     res = ReadLinuxProcSmapsFile(smaps_file.get(), &maps);
@@ -290,52 +265,4 @@
   return maps;
 }
 
-// static
-OSMetrics::MappedAndResidentPagesDumpState OSMetrics::GetMappedAndResidentPages(
-    const size_t start_address,
-    const size_t end_address,
-    std::vector<uint8_t>* accessed_pages_bitmap) {
-  const char* kPagemap = "/proc/self/pagemap";
-
-  base::ScopedFILE pagemap_file(fopen(kPagemap, "r"));
-  if (!pagemap_file.get()) {
-    DLOG(WARNING) << "Could not open " << kPagemap;
-    return OSMetrics::MappedAndResidentPagesDumpState::kAccessPagemapDenied;
-  }
-
-  const size_t kPageSize = base::GetPageSize();
-  const size_t start_page = start_address / kPageSize;
-  // |end_address| is exclusive.
-  const size_t end_page = (end_address - 1) / kPageSize;
-  const size_t total_pages = end_page - start_page + 1;
-
-  // The pagemap has one 64 bit entry per page or 8 bytes.
-  auto offset = static_cast<long>(start_page * 8);
-  if (fseek(pagemap_file.get(), offset, SEEK_SET) != 0) {
-    DLOG(ERROR) << "Error in fseek " << kPagemap;
-    return OSMetrics::MappedAndResidentPagesDumpState::kFailure;
-  }
-
-  // |entries| will be 2kB/MB (if |kPageSize| = 4096),
-  // that would only be ~80kB on Android, and up to 200kB on Linux (for 100MB)
-  std::vector<uint64_t> entries(total_pages);
-  if (fread(&entries[0], sizeof(uint64_t), total_pages, pagemap_file.get()) !=
-      total_pages) {
-    return OSMetrics::MappedAndResidentPagesDumpState::kFailure;
-  }
-
-  accessed_pages_bitmap->resize(1 + (total_pages - 1) / 8);
-  for (size_t page = 0; page < total_pages; page++) {
-    // Bit 63 is "page present" according to
-    // https://www.kernel.org/doc/Documentation/vm/pagemap.txt.
-    if (entries[page] & (1LL << 63)) {
-      auto byte = page / 8;
-      auto bit = page & 0x7;
-      CHECK_LT(byte, accessed_pages_bitmap->size());
-      (*accessed_pages_bitmap)[byte] |= 1 << bit;
-    }
-  }
-  return OSMetrics::MappedAndResidentPagesDumpState::kSuccess;
-}
-
 }  // namespace memory_instrumentation
--- a/services/resource_coordinator/public/cpp/memory_instrumentation/os_metrics_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/resource_coordinator/public/cpp/memory_instrumentation/os_metrics_unittest.cc	2019-05-17 18:53:37.964000000 +0300
@@ -3,12 +3,8 @@
 // found in the LICENSE file.
 #include "services/resource_coordinator/public/cpp/memory_instrumentation/os_metrics.h"
 
-#include <set>
-#include <vector>
-
 #include "base/files/file_util.h"
 #include "base/process/process_handle.h"
-#include "base/process/process_metrics.h"
 #include "build/build_config.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
@@ -22,10 +18,6 @@
 #include <windows.h>
 #endif
 
-#if defined(OS_LINUX) || defined(OS_ANDROID)
-#include <sys/mman.h>
-#endif
-
 namespace memory_instrumentation {
 
 #if defined(OS_LINUX) || defined(OS_ANDROID)
@@ -205,51 +197,6 @@
   EXPECT_EQ(4 * 1024UL, maps_2[0]->byte_stats_private_dirty_resident);
   EXPECT_EQ(0 * 1024UL, maps_2[0]->byte_stats_swapped);
 }
-
-TEST(OSMetricsTest, GetMappedAndResidentPages) {
-  const size_t kPages = 16;
-  const size_t kPageSize = base::GetPageSize();
-  const size_t kLength = kPages * kPageSize;
-
-  // mmap guarantees addr is aligned with kPagesize.
-  void* addr = mmap(NULL, kLength, PROT_READ | PROT_WRITE,
-                    MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
-
-  ASSERT_NE(MAP_FAILED, addr) << "mmap() failed";
-
-  std::set<size_t> pages;
-  uint8_t* array = static_cast<uint8_t*>(addr);
-  for (unsigned int i = 0; i < kPages / 2; ++i) {
-    int page = rand() % kPages;
-    int offset = rand() % kPageSize;
-    *static_cast<volatile uint8_t*>(array + page * kPageSize + offset) =
-        rand() % 256;
-    pages.insert(page);
-  }
-
-  size_t start_address = reinterpret_cast<size_t>(addr);
-
-  std::vector<uint8_t> accessed_pages_bitmap;
-  OSMetrics::MappedAndResidentPagesDumpState state =
-      OSMetrics::GetMappedAndResidentPages(
-          start_address, start_address + kLength, &accessed_pages_bitmap);
-
-  ASSERT_EQ(munmap(addr, kLength), 0);
-  if (state == OSMetrics::MappedAndResidentPagesDumpState::kAccessPagemapDenied)
-    return;
-
-  EXPECT_EQ(state == OSMetrics::MappedAndResidentPagesDumpState::kSuccess,
-            true);
-  std::set<size_t> accessed_pages_set;
-  for (size_t i = 0; i < accessed_pages_bitmap.size(); i++) {
-    for (int j = 0; j < 8; j++)
-      if (accessed_pages_bitmap[i] & (1 << j))
-        accessed_pages_set.insert(i * 8 + j);
-  }
-
-  EXPECT_EQ(pages == accessed_pages_set, true);
-}
-
 #endif  // defined(OS_LINUX) || defined(OS_ANDROID)
 
 #if defined(OS_WIN)
--- a/services/resource_coordinator/public/cpp/memory_instrumentation/tracing_observer.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/resource_coordinator/public/cpp/memory_instrumentation/tracing_observer.cc	2019-05-17 18:53:37.968000000 +0300
@@ -42,7 +42,7 @@
   return file;
 }
 
-}  // namespace
+};  // namespace
 
 TracingObserver::TracingObserver(
     base::trace_event::TraceLog* trace_log,
--- a/services/resource_coordinator/public/cpp/OWNERS	2019-05-01 01:22:56.000000000 +0300
+++ b/services/resource_coordinator/public/cpp/OWNERS	2019-05-17 18:53:37.964000000 +0300
@@ -5,7 +5,3 @@
 
 per-file *_mojom_traits*.*=set noparent
 per-file *_mojom_traits*.*=file://ipc/SECURITY_OWNERS
-per-file manifest.cc=set noparent
-per-file manifest.cc=file://ipc/SECURITY_OWNERS
-per-file manifest.h=set noparent
-per-file manifest.h=file://ipc/SECURITY_OWNERS
--- a/services/resource_coordinator/public/mojom/memory_instrumentation/memory_instrumentation.mojom	2019-05-01 01:22:56.000000000 +0300
+++ b/services/resource_coordinator/public/mojom/memory_instrumentation/memory_instrumentation.mojom	2019-05-17 18:53:37.968000000 +0300
@@ -140,10 +140,6 @@
   uint32 resident_set_kb = 0;
   PlatformPrivateFootprint platform_private_footprint;
   array<VmRegion> memory_maps;
-
-  // Each bit corresponds to a page. The bit is set if the page
-  // is mapped and resident in memory.
-  array<uint8> native_library_pages_bitmap;
 };
 
 // These structs are public:
@@ -191,10 +187,6 @@
   mojo_base.mojom.ProcessId pid;
 };
 
-// Metrics aggregated across all processes.
-struct AggregatedMetrics {
-  uint32 native_library_resident_kb = 0;
-};
 
 // This struct is returned by the public-facing API
 // Coordinator::RequestGlobalMemoryDump().
@@ -204,7 +196,6 @@
   // start time of a global dump may lag the request time substantially.
   mojo_base.mojom.TimeTicks start_time;
   array<ProcessMemoryDump> process_dumps;
-  AggregatedMetrics aggregated_metrics;
 };
 
 // This is the interface implemented by the per-process client library. This
--- a/services/resource_coordinator/public/mojom/signals.mojom	2019-05-01 01:22:56.000000000 +0300
+++ b/services/resource_coordinator/public/mojom/signals.mojom	2019-05-17 18:53:37.968000000 +0300
@@ -33,5 +33,7 @@
   kPID,
   kVisible,
   kUKMSourceId,
+  // Used by Page CUs to store current loading state.
+  kIsLoading,
   kLifecycleState,
 };
--- a/services/resource_coordinator/resource_coordinator_service.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/resource_coordinator/resource_coordinator_service.cc	2019-05-17 18:53:37.968000000 +0300
@@ -7,22 +7,55 @@
 #include <utility>
 
 #include "base/feature_list.h"
-#include "base/timer/timer.h"
 #include "build/build_config.h"
 #include "services/metrics/public/cpp/mojo_ukm_recorder.h"
 #include "services/resource_coordinator/memory_instrumentation/coordinator_impl.h"
+#include "services/resource_coordinator/observers/metrics_collector.h"
+#include "services/resource_coordinator/observers/page_signal_generator_impl.h"
 #include "services/resource_coordinator/public/cpp/resource_coordinator_features.h"
 
+#if defined(OS_WIN)
+#include "services/resource_coordinator/observers/working_set_trimmer_win.h"
+#endif
+
 namespace resource_coordinator {
 
 ResourceCoordinatorService::ResourceCoordinatorService(
     service_manager::mojom::ServiceRequest request)
     : service_binding_(this, std::move(request)),
-      service_keepalive_(&service_binding_, base::nullopt /* idle_timeout */) {}
+      service_keepalive_(&service_binding_, base::nullopt /* idle_timeout */),
+      introspector_(&coordination_unit_graph_) {}
 
 ResourceCoordinatorService::~ResourceCoordinatorService() = default;
 
 void ResourceCoordinatorService::OnStart() {
+  ukm_recorder_ = ukm::MojoUkmRecorder::Create(service_binding_.GetConnector());
+
+  registry_.AddInterface(
+      base::Bind(&CoordinationUnitIntrospectorImpl::BindToInterface,
+                 base::Unretained(&introspector_)));
+
+  // Register new |CoordinationUnitGraphObserver| implementations here.
+  auto page_signal_generator_impl = std::make_unique<PageSignalGeneratorImpl>();
+  registry_.AddInterface(
+      base::Bind(&PageSignalGeneratorImpl::BindToInterface,
+                 base::Unretained(page_signal_generator_impl.get())));
+  coordination_unit_graph_.RegisterObserver(
+      std::move(page_signal_generator_impl));
+
+  coordination_unit_graph_.RegisterObserver(
+      std::make_unique<MetricsCollector>());
+
+#if defined(OS_WIN)
+  if (base::FeatureList::IsEnabled(features::kEmptyWorkingSet)) {
+    coordination_unit_graph_.RegisterObserver(
+        std::make_unique<WorkingSetTrimmer>());
+  }
+#endif
+
+  coordination_unit_graph_.OnStart(&registry_, &service_keepalive_);
+  coordination_unit_graph_.set_ukm_recorder(ukm_recorder_.get());
+
   // TODO(chiniforooshan): The abstract class Coordinator in the
   // public/cpp/memory_instrumentation directory should not be needed anymore.
   // We should be able to delete that and rename
@@ -37,6 +70,8 @@
   registry_.AddInterface(base::BindRepeating(
       &memory_instrumentation::CoordinatorImpl::BindHeapProfilerHelperRequest,
       base::Unretained(memory_instrumentation_coordinator_.get())));
+  registry_.AddInterface(base::BindRepeating(
+      &ResourceCoordinatorService::BindWebUIGraphDump, base::Unretained(this)));
 }
 
 void ResourceCoordinatorService::OnBindInterface(
@@ -47,4 +82,31 @@
                           source_info);
 }
 
+void ResourceCoordinatorService::BindWebUIGraphDump(
+    mojom::WebUIGraphDumpRequest request,
+    const service_manager::BindSourceInfo& source_info) {
+  std::unique_ptr<WebUIGraphDumpImpl> graph_dump =
+      std::make_unique<WebUIGraphDumpImpl>(&coordination_unit_graph_);
+
+  auto error_callback =
+      base::BindOnce(&ResourceCoordinatorService::OnGraphDumpConnectionError,
+                     base::Unretained(this), graph_dump.get());
+  graph_dump->Bind(std::move(request), std::move(error_callback));
+
+  graph_dumps_.push_back(std::move(graph_dump));
+}
+
+void ResourceCoordinatorService::OnGraphDumpConnectionError(
+    WebUIGraphDumpImpl* graph_dump) {
+  const auto it = std::find_if(
+      graph_dumps_.begin(), graph_dumps_.end(),
+      [graph_dump](const std::unique_ptr<WebUIGraphDumpImpl>& graph_dump_ptr) {
+        return graph_dump_ptr.get() == graph_dump;
+      });
+
+  DCHECK(it != graph_dumps_.end());
+
+  graph_dumps_.erase(it);
+}
+
 }  // namespace resource_coordinator
--- a/services/resource_coordinator/resource_coordinator_service.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/resource_coordinator/resource_coordinator_service.h	2019-05-17 18:53:37.968000000 +0300
@@ -13,9 +13,10 @@
 #include "base/macros.h"
 #include "base/memory/weak_ptr.h"
 #include "services/metrics/public/cpp/mojo_ukm_recorder.h"
-
+#include "services/resource_coordinator/coordination_unit/coordination_unit_graph.h"
+#include "services/resource_coordinator/coordination_unit/coordination_unit_introspector_impl.h"
 #include "services/resource_coordinator/memory_instrumentation/coordinator_impl.h"
-
+#include "services/resource_coordinator/webui_graph_dump_impl.h"
 #include "services/service_manager/public/cpp/binder_registry.h"
 #include "services/service_manager/public/cpp/service.h"
 #include "services/service_manager/public/cpp/service_binding.h"
@@ -36,16 +37,31 @@
                        const std::string& interface_name,
                        mojo::ScopedMessagePipeHandle interface_pipe) override;
 
+  ukm::MojoUkmRecorder* ukm_recorder() { return ukm_recorder_.get(); }
+  CoordinationUnitGraph* coordination_unit_graph() {
+    return &coordination_unit_graph_;
+  }
+
  private:
+  void BindWebUIGraphDump(mojom::WebUIGraphDumpRequest request,
+                          const service_manager::BindSourceInfo& source_info);
+  void OnGraphDumpConnectionError(WebUIGraphDumpImpl* graph_dump);
+
   service_manager::ServiceBinding service_binding_;
   service_manager::ServiceKeepalive service_keepalive_;
 
   service_manager::BinderRegistryWithArgs<
       const service_manager::BindSourceInfo&>
       registry_;
+  CoordinationUnitGraph coordination_unit_graph_;
+  CoordinationUnitIntrospectorImpl introspector_;
+  std::unique_ptr<ukm::MojoUkmRecorder> ukm_recorder_;
   std::unique_ptr<memory_instrumentation::CoordinatorImpl>
       memory_instrumentation_coordinator_;
 
+  // Current graph dump instances.
+  std::vector<std::unique_ptr<WebUIGraphDumpImpl>> graph_dumps_;
+
   // WeakPtrFactory members should always come last so WeakPtrs are destructed
   // before other members.
   base::WeakPtrFactory<ResourceCoordinatorService> weak_factory_{this};
--- a/services/service_manager/BUILD.gn	2019-05-01 01:22:56.000000000 +0300
+++ b/services/service_manager/BUILD.gn	2019-05-17 18:53:37.968000000 +0300
@@ -2,12 +2,15 @@
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
+import("//mojo/public/tools/bindings/mojom.gni")
 import("//testing/test.gni")
 
 group("all") {
   testonly = true
   deps = [
     ":service_manager",
+    "//services/service_manager/background",
+    "//services/service_manager/standalone",
   ]
 
   if (!is_ios) {
@@ -21,16 +24,10 @@
 
 source_set("service_manager") {
   sources = [
-    "background_service_manager.cc",
-    "background_service_manager.h",
-    "catalog.cc",
-    "catalog.h",
     "connect_params.cc",
     "connect_params.h",
     "service_manager.cc",
     "service_manager.h",
-    "service_process_launcher_delegate.h",
-    "service_process_launcher_factory.h",
     "switches.cc",
     "switches.h",
   ]
@@ -39,31 +36,16 @@
 
   deps = [
     "//base/third_party/dynamic_annotations",
-    "//components/services/filesystem:lib",
-    "//components/services/filesystem/public/interfaces",
   ]
 
   public_deps = [
     "//base",
     "//mojo/public/cpp/bindings",
+    "//services/catalog:lib",
+    "//services/catalog/public/mojom:constants",
     "//services/service_manager/public/cpp",
     "//services/service_manager/public/mojom",
+    "//services/service_manager/runner/host:lib",
     "//services/service_manager/sandbox",
   ]
-
-  if (!is_ios) {
-    sources += [
-      "service_process_launcher.cc",
-      "service_process_launcher.h",
-    ]
-
-    deps += [
-      "//mojo/core/embedder",
-      "//services/service_manager/public/cpp/service_executable:switches",
-    ]
-  }
-
-  if (is_linux) {
-    deps += [ "//sandbox/linux:sandbox_services" ]
-  }
 }
--- a/services/service_manager/connect_params.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/service_manager/connect_params.h	2019-05-17 18:53:37.972000000 +0300
@@ -74,11 +74,6 @@
     return std::move(interface_pipe_);
   }
 
-  void set_priority(mojom::BindInterfacePriority priority) {
-    priority_ = priority;
-  }
-  mojom::BindInterfacePriority priority() const { return priority_; }
-
   void set_connection_callback(ConnectionCallback callback) {
     connection_callback_ = std::move(callback);
   }
@@ -105,8 +100,6 @@
   mojom::PIDReceiverRequest pid_receiver_request_;
   std::string interface_name_;
   mojo::ScopedMessagePipeHandle interface_pipe_;
-  mojom::BindInterfacePriority priority_ =
-      mojom::BindInterfacePriority::kImportant;
   ConnectionCallback connection_callback_;
 
   // These values are supplied to the response callback for WarmService()/
--- a/services/service_manager/DEPS	2019-05-01 01:22:56.000000000 +0300
+++ b/services/service_manager/DEPS	2019-05-17 18:53:37.968000000 +0300
@@ -1,3 +1,3 @@
 include_rules = [
-  "+sandbox",
+  "+services/catalog",
 ]
--- a/services/service_manager/embedder/BUILD.gn	2019-05-01 01:22:56.000000000 +0300
+++ b/services/service_manager/embedder/BUILD.gn	2019-05-17 18:53:37.972000000 +0300
@@ -45,11 +45,12 @@
       ":embedder_switches",
       "//base",
       "//mojo/core/embedder",
-      "//services/service_manager",
+      "//services/service_manager/background:lib",
       "//services/service_manager/public/cpp",
       "//services/service_manager/public/cpp/service_executable:support",
-      "//services/service_manager/public/cpp/service_executable:switches",
       "//services/service_manager/public/mojom",
+      "//services/service_manager/runner:init",
+      "//services/service_manager/runner/common",
     ]
 
     if (!is_nacl) {
--- a/services/service_manager/embedder/descriptors.h	2019-05-17 17:45:42.572000000 +0300
+++ b/services/service_manager/embedder/descriptors.h	2019-05-17 18:53:37.972000000 +0300
@@ -11,7 +11,7 @@
 // base::GlobalDescriptors object (see base/posix/global_descriptors.h)
 enum {
   kCrashDumpSignal = 0,
-  kSandboxIPCChannel,  // https://chromium.9oo91esource.qjz9zk/chromium/b+/master/docs/linux_sandbox_ipc.md
+  kSandboxIPCChannel,  // https://chromium.googlesource.com/chromium/b+/master/docs/linux_sandbox_ipc.md
   kMojoIPCChannel,
   kFieldTrialDescriptor,
 
--- a/services/service_manager/embedder/main.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/service_manager/embedder/main.cc	2019-05-17 18:53:37.972000000 +0300
@@ -37,7 +37,9 @@
 #include "services/service_manager/embedder/switches.h"
 #include "services/service_manager/public/cpp/service.h"
 #include "services/service_manager/public/cpp/service_executable/service_executable_environment.h"
-#include "services/service_manager/public/cpp/service_executable/switches.h"
+#include "services/service_manager/runner/common/client_util.h"
+#include "services/service_manager/runner/common/switches.h"
+#include "services/service_manager/runner/init.h"
 #include "ui/base/resource/resource_bundle.h"
 #include "ui/base/ui_base_paths.h"
 #include "ui/base/ui_base_switches.h"
@@ -74,6 +76,34 @@
 // service manager embedder process.
 constexpr size_t kMaximumMojoMessageSize = 128 * 1024 * 1024;
 
+class ServiceProcessLauncherDelegateImpl
+    : public service_manager::ServiceProcessLauncherDelegate {
+ public:
+  explicit ServiceProcessLauncherDelegateImpl(MainDelegate* main_delegate)
+      : main_delegate_(main_delegate) {}
+  ~ServiceProcessLauncherDelegateImpl() override {}
+
+ private:
+  // service_manager::ServiceProcessLauncherDelegate:
+  void AdjustCommandLineArgumentsForTarget(
+      const service_manager::Identity& target,
+      base::CommandLine* command_line) override {
+    if (main_delegate_->ShouldLaunchAsServiceProcess(target)) {
+      command_line->AppendSwitchASCII(switches::kProcessType,
+                                      switches::kProcessTypeService);
+#if defined(OS_WIN)
+      command_line->AppendArg(switches::kDefaultServicePrefetchArgument);
+#endif
+    }
+
+    main_delegate_->AdjustServiceProcessCommandLine(target, command_line);
+  }
+
+  MainDelegate* const main_delegate_;
+
+  DISALLOW_COPY_AND_ASSIGN(ServiceProcessLauncherDelegateImpl);
+};
+
 #if defined(OS_POSIX) && !defined(OS_ANDROID)
 
 // Setup signal-handling state: resanitize most signals, ignore SIGPIPE.
@@ -155,14 +185,7 @@
 }
 
 void NonEmbedderProcessInit() {
-  logging::LoggingSettings settings;
-  settings.logging_dest = logging::LOG_TO_SYSTEM_DEBUG_LOG;
-  logging::InitLogging(settings);
-  // To view log output with IDs and timestamps use "adb logcat -v threadtime".
-  logging::SetLogItems(true,   // Process ID
-                       true,   // Thread ID
-                       true,   // Timestamp
-                       true);  // Tick count
+  service_manager::InitializeLogging();
 
 #if !defined(OFFICIAL_BUILD)
   // Initialize stack dumping before initializing sandbox to make sure symbol
@@ -178,6 +201,25 @@
   base::TaskScheduler::CreateAndStartWithDefaultParams("ServiceManagerProcess");
 }
 
+void WaitForDebuggerIfNecessary() {
+  if (!ServiceManagerIsRemote())
+    return;
+
+  const auto& command_line = *base::CommandLine::ForCurrentProcess();
+  const std::string service_name =
+      command_line.GetSwitchValueASCII(switches::kServiceName);
+  if (service_name !=
+      command_line.GetSwitchValueASCII(::switches::kWaitForDebugger)) {
+    return;
+  }
+
+  // Include the pid as logging may not have been initialized yet (the pid
+  // printed out by logging is wrong).
+  LOG(WARNING) << "waiting for debugger to attach for service " << service_name
+               << " pid=" << base::Process::Current().Pid();
+  base::debug::WaitForDebugger(120, true);
+}
+
 int RunServiceManager(MainDelegate* delegate) {
   NonEmbedderProcessInit();
 
@@ -190,8 +232,10 @@
       ipc_thread.task_runner(),
       mojo::core::ScopedIPCSupport::ShutdownPolicy::FAST);
 
+  ServiceProcessLauncherDelegateImpl service_process_launcher_delegate(
+      delegate);
   service_manager::BackgroundServiceManager background_service_manager(
-      delegate->GetServiceManifests());
+      &service_process_launcher_delegate, delegate->GetServiceManifests());
 
   base::RunLoop run_loop;
   delegate->OnServiceManagerInitialized(run_loop.QuitClosure(),
@@ -216,6 +260,7 @@
 
 int RunService(MainDelegate* delegate) {
   NonEmbedderProcessInit();
+  WaitForDebuggerIfNecessary();
 
   InitializeResources();
 
--- a/services/service_manager/embedder/main_delegate.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/service_manager/embedder/main_delegate.h	2019-05-17 18:53:37.972000000 +0300
@@ -13,7 +13,7 @@
 #include "base/memory/scoped_refptr.h"
 #include "base/single_thread_task_runner.h"
 #include "mojo/core/embedder/configuration.h"
-#include "services/service_manager/background_service_manager.h"
+#include "services/service_manager/background/background_service_manager.h"
 #include "services/service_manager/embedder/process_type.h"
 #include "services/service_manager/public/cpp/identity.h"
 #include "services/service_manager/public/cpp/manifest.h"
--- a/services/service_manager/embedder/shared_file_util.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/service_manager/embedder/shared_file_util.cc	2019-05-17 18:53:37.972000000 +0300
@@ -15,7 +15,7 @@
     switch_value_ += ",";
   }
   switch_value_ += key_str, switch_value_ += ":";
-  switch_value_ += base::NumberToString(key_id);
+  switch_value_ += base::IntToString(key_id);
 }
 
 base::Optional<std::map<int, std::string>> ParseSharedFileSwitchValue(
--- a/services/service_manager/public/cpp/connector.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/service_manager/public/cpp/connector.cc	2019-05-17 18:53:37.972000000 +0300
@@ -4,9 +4,7 @@
 
 #include "services/service_manager/public/cpp/connector.h"
 
-#include "base/bind.h"
 #include "services/service_manager/public/cpp/identity.h"
-#include "services/service_manager/public/mojom/service.mojom.h"
 
 namespace service_manager {
 
@@ -62,7 +60,6 @@
 void Connector::BindInterface(const ServiceFilter& filter,
                               const std::string& interface_name,
                               mojo::ScopedMessagePipeHandle interface_pipe,
-                              mojom::BindInterfacePriority priority,
                               BindInterfaceCallback callback) {
   auto service_overrides_iter = local_binder_overrides_.find(filter);
   if (service_overrides_iter != local_binder_overrides_.end()) {
@@ -77,7 +74,7 @@
     return;
 
   connector_->BindInterface(filter, interface_name, std::move(interface_pipe),
-                            priority, std::move(callback));
+                            std::move(callback));
 }
 
 std::unique_ptr<Connector> Connector::Clone() {
--- a/services/service_manager/public/cpp/connector.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/service_manager/public/cpp/connector.h	2019-05-17 18:53:37.976000000 +0300
@@ -7,7 +7,6 @@
 
 #include <map>
 #include <memory>
-#include <utility>
 
 #include "base/callback.h"
 #include "base/optional.h"
@@ -15,8 +14,8 @@
 #include "services/service_manager/public/cpp/export.h"
 #include "services/service_manager/public/cpp/identity.h"
 #include "services/service_manager/public/mojom/connector.mojom.h"
-#include "services/service_manager/public/mojom/service.mojom-forward.h"
-#include "services/service_manager/public/mojom/service_manager.mojom-forward.h"
+#include "services/service_manager/public/mojom/service.mojom.h"
+#include "services/service_manager/public/mojom/service_manager.mojom.h"
 
 namespace service_manager {
 
@@ -144,7 +143,6 @@
                      mojo::InterfaceRequest<Interface> request,
                      BindInterfaceCallback callback = {}) {
     BindInterface(filter, Interface::Name_, request.PassMessagePipe(),
-                  mojom::BindInterfacePriority::kImportant,
                   std::move(callback));
   }
 
@@ -168,28 +166,10 @@
                          std::move(request));
   }
 
-  template <typename Interface>
-  void BindInterface(const ServiceFilter& filter,
-                     mojo::InterfaceRequest<Interface> request,
-                     mojom::BindInterfacePriority priority) {
-    return BindInterface(filter, Interface::Name_, request.PassMessagePipe(),
-                         priority, {});
-  }
-
-  void BindInterface(const ServiceFilter& filter,
-                     const std::string& interface_name,
-                     mojo::ScopedMessagePipeHandle interface_pipe,
-                     BindInterfaceCallback callback = {}) {
-    BindInterface(filter, interface_name, std::move(interface_pipe),
-                  mojom::BindInterfacePriority::kImportant,
-                  std::move(callback));
-  }
-
   void BindInterface(const ServiceFilter& filter,
                      const std::string& interface_name,
                      mojo::ScopedMessagePipeHandle interface_pipe,
-                     mojom::BindInterfacePriority priority,
-                     BindInterfaceCallback callback);
+                     BindInterfaceCallback callback = {});
 
   // Creates a new instance of this class which may be passed to another thread.
   // The returned object may be passed across sequences until any of its public
--- a/services/service_manager/public/cpp/interface_binder.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/service_manager/public/cpp/interface_binder.h	2019-05-17 18:53:37.976000000 +0300
@@ -100,8 +100,8 @@
     if (task_runner_) {
       task_runner_->PostTask(
           FROM_HERE,
-          base::BindOnce(&GenericCallbackBinder::RunCallback, callback_,
-                         interface_name, std::move(handle), args...));
+          base::Bind(&GenericCallbackBinder::RunCallback, callback_,
+                     interface_name, base::Passed(&handle), args...));
       return;
     }
     RunCallback(callback_, interface_name, std::move(handle), args...);
--- a/services/service_manager/public/cpp/manifest_builder.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/service_manager/public/cpp/manifest_builder.h	2019-05-17 18:53:37.976000000 +0300
@@ -5,28 +5,11 @@
 #ifndef SERVICES_SERVICE_MANAGER_PUBLIC_CPP_MANIFEST_BUILDER_H_
 #define SERVICES_SERVICE_MANAGER_PUBLIC_CPP_MANIFEST_BUILDER_H_
 
-#include <set>
-#include <utility>
-
 #include "base/component_export.h"
 #include "services/service_manager/public/cpp/manifest.h"
 
 namespace service_manager {
 
-namespace internal {
-
-template <typename InterfaceType>
-const char* GetInterfaceName() {
-  return InterfaceType::Name_;
-}
-
-template <typename... InterfaceTypes>
-Manifest::InterfaceNameSet GetInterfaceNames() {
-  return Manifest::InterfaceNameSet({GetInterfaceName<InterfaceTypes>()...});
-}
-
-}  // namespace internal
-
 // Helper for building Manifest structures in a more readable and writable
 // manner than direct construction.
 class COMPONENT_EXPORT(SERVICE_MANAGER_CPP) ManifestBuilder {
@@ -53,22 +36,21 @@
   ManifestBuilder& ExposeCapability(
       const char* name,
       Manifest::InterfaceList<InterfaceTypes...> interfaces) {
-    manifest_.exposed_capabilities[name] =
-        internal::GetInterfaceNames<InterfaceTypes...>();
+    manifest_.exposed_capabilities.emplace_back(name, std::move(interfaces));
     return *this;
   }
 
   // Prefer the above override. This one exists to support generated code.
   ManifestBuilder& ExposeCapability(const char* name,
                                     std::set<const char*> interface_names) {
-    manifest_.exposed_capabilities[name].insert(interface_names.begin(),
-                                                interface_names.end());
+    manifest_.exposed_capabilities.emplace_back(name,
+                                                std::move(interface_names));
     return *this;
   }
 
   ManifestBuilder& RequireCapability(const char* service_name,
                                      const char* capability_name) {
-    manifest_.required_capabilities[service_name].insert(capability_name);
+    manifest_.required_capabilities.push_back({service_name, capability_name});
     return *this;
   }
 
@@ -77,9 +59,8 @@
       const char* filter_name,
       const char* capability_name,
       Manifest::InterfaceList<InterfaceTypes...> interfaces) {
-    manifest_
-        .exposed_interface_filter_capabilities[filter_name][capability_name] =
-        internal::GetInterfaceNames<InterfaceTypes...>();
+    manifest_.exposed_interface_filter_capabilities.emplace_back(
+        filter_name, capability_name, std::move(interfaces));
     return *this;
   }
 
@@ -89,9 +70,8 @@
       const char* filter_name,
       const char* capability_name,
       std::set<const char*> interface_names) {
-    manifest_
-        .exposed_interface_filter_capabilities[filter_name][capability_name]
-        .insert(interface_names.begin(), interface_names.end());
+    manifest_.exposed_interface_filter_capabilities.emplace_back(
+        filter_name, capability_name, std::move(interface_names));
     return *this;
   }
 
@@ -99,8 +79,8 @@
       const char* service_name,
       const char* filter_name,
       const char* capability_name) {
-    manifest_.required_interface_filter_capabilities[filter_name][service_name]
-        .insert(capability_name);
+    manifest_.required_interface_filter_capabilities.push_back(
+        {service_name, filter_name, capability_name});
     return *this;
   }
 
--- a/services/service_manager/public/cpp/manifest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/service_manager/public/cpp/manifest.cc	2019-05-17 18:53:37.976000000 +0300
@@ -4,8 +4,6 @@
 
 #include "services/service_manager/public/cpp/manifest.h"
 
-#include <utility>
-
 #include "build/build_config.h"
 
 namespace service_manager {
@@ -24,48 +22,81 @@
 Manifest::Options& Manifest::Options::operator=(Options&&) = default;
 Manifest::Options& Manifest::Options::operator=(const Options&) = default;
 
-Manifest& Manifest::Amend(Manifest other) {
-  for (const auto& capability_entry : other.exposed_capabilities) {
-    const auto& capability_name = capability_entry.first;
-    const auto& interface_names = capability_entry.second;
-    for (const auto& interface_name : interface_names)
-      exposed_capabilities[capability_name].insert(interface_name);
-  }
+Manifest::ExposedCapability::ExposedCapability() = default;
+Manifest::ExposedCapability::ExposedCapability(const ExposedCapability&) =
+    default;
+Manifest::ExposedCapability::ExposedCapability(ExposedCapability&&) = default;
+Manifest::ExposedCapability::ExposedCapability(
+    const std::string& capability_name,
+    std::set<const char*> interface_names)
+    : capability_name(capability_name),
+      interface_names(interface_names.begin(), interface_names.end()) {}
+Manifest::ExposedCapability::~ExposedCapability() = default;
+Manifest::ExposedCapability& Manifest::ExposedCapability::operator=(
+    const ExposedCapability&) = default;
+Manifest::ExposedCapability& Manifest::ExposedCapability::operator=(
+    ExposedCapability&&) = default;
+
+Manifest::ExposedInterfaceFilterCapability::ExposedInterfaceFilterCapability() =
+    default;
+Manifest::ExposedInterfaceFilterCapability::ExposedInterfaceFilterCapability(
+    ExposedInterfaceFilterCapability&&) = default;
+Manifest::ExposedInterfaceFilterCapability::ExposedInterfaceFilterCapability(
+    const ExposedInterfaceFilterCapability&) = default;
+Manifest::ExposedInterfaceFilterCapability::ExposedInterfaceFilterCapability(
+    const std::string& filter_name,
+    const std::string& capability_name,
+    std::set<const char*> interface_names)
+    : filter_name(filter_name),
+      capability_name(capability_name),
+      interface_names(interface_names.begin(), interface_names.end()) {}
+Manifest::ExposedInterfaceFilterCapability::
+    ~ExposedInterfaceFilterCapability() = default;
+Manifest::ExposedInterfaceFilterCapability&
+Manifest::ExposedInterfaceFilterCapability::operator=(
+    const ExposedInterfaceFilterCapability&) = default;
+Manifest::ExposedInterfaceFilterCapability&
+Manifest::ExposedInterfaceFilterCapability::operator=(
+    ExposedInterfaceFilterCapability&&) = default;
 
-  for (const auto& filter_entry : other.exposed_interface_filter_capabilities) {
-    const auto& filter_name = filter_entry.first;
-    const auto& capabilities_map = filter_entry.second;
-    for (const auto& capability_entry : capabilities_map) {
-      const auto& capability_name = capability_entry.first;
-      const auto& interface_names = capability_entry.second;
-      auto& exposed_capability =
-          exposed_interface_filter_capabilities[filter_name][capability_name];
-      for (const auto& interface_name : interface_names)
-        exposed_capability.insert(interface_name);
-    }
+Manifest& Manifest::Amend(Manifest other) {
+  for (auto& other_capability : other.exposed_capabilities) {
+    auto it = std::find_if(
+        exposed_capabilities.begin(), exposed_capabilities.end(),
+        [&other_capability](const ExposedCapability& capability) {
+          return capability.capability_name == other_capability.capability_name;
+        });
+    if (it != exposed_capabilities.end()) {
+      for (auto& name : other_capability.interface_names)
+        it->interface_names.emplace(std::move(name));
+    } else {
+      exposed_capabilities.emplace_back(std::move(other_capability));
   }
-
-  for (const auto& capability_entry : other.required_capabilities) {
-    const auto& service_name = capability_entry.first;
-    const auto& capability_names = capability_entry.second;
-    for (const auto& capability_name : capability_names)
-      required_capabilities[service_name].insert(capability_name);
   }
 
-  for (const auto& filter_entry :
-       other.required_interface_filter_capabilities) {
-    const auto& filter_name = filter_entry.first;
-    const auto& capability_maps = filter_entry.second;
-    for (const auto& capability_entry : capability_maps) {
-      const auto& service_name = capability_entry.first;
-      const auto& capability_names = capability_entry.second;
-      auto& required_capabilities =
-          required_interface_filter_capabilities[filter_name][service_name];
-      for (const auto& capability_name : capability_names)
-        required_capabilities.insert(capability_name);
+  for (auto& other_capability : other.exposed_interface_filter_capabilities) {
+    auto it = std::find_if(
+        exposed_interface_filter_capabilities.begin(),
+        exposed_interface_filter_capabilities.end(),
+        [&other_capability](
+            const ExposedInterfaceFilterCapability& capability) {
+          return capability.capability_name ==
+                     other_capability.capability_name &&
+                 capability.filter_name == other_capability.filter_name;
+        });
+    if (it != exposed_interface_filter_capabilities.end()) {
+      for (auto& name : other_capability.interface_names)
+        it->interface_names.emplace(std::move(name));
+    } else {
+      exposed_interface_filter_capabilities.emplace_back(
+          std::move(other_capability));
     }
   }
 
+  for (auto& capability : other.required_capabilities)
+    required_capabilities.emplace_back(std::move(capability));
+  for (auto& capability : other.required_interface_filter_capabilities)
+    required_interface_filter_capabilities.emplace_back(std::move(capability));
   for (auto& manifest : other.packaged_services)
     packaged_services.emplace_back(std::move(manifest));
   for (auto& file_info : other.preloaded_files)
--- a/services/service_manager/public/cpp/manifest.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/service_manager/public/cpp/manifest.h	2019-05-17 18:53:37.976000000 +0300
@@ -5,7 +5,6 @@
 #ifndef SERVICES_SERVICE_MANAGER_PUBLIC_CPP_MANIFEST_H_
 #define SERVICES_SERVICE_MANAGER_PUBLIC_CPP_MANIFEST_H_
 
-#include <map>
 #include <set>
 #include <string>
 #include <vector>
@@ -15,6 +14,20 @@
 
 namespace service_manager {
 
+namespace internal {
+
+template <typename InterfaceType>
+const char* GetInterfaceName() {
+  return InterfaceType::Name_;
+}
+
+template <typename... InterfaceTypes>
+std::set<std::string> GetInterfaceNames() {
+  return std::set<std::string>({GetInterfaceName<InterfaceTypes>()...});
+}
+
+}  // namespace internal
+
 // Represents metadata about a service that the Service Manager needs in order
 // to start and control instances of that given service. This data is provided
 // to the Service Manager at initialization time for every known service in the
@@ -30,15 +43,6 @@
 // defined in manifest_builder.h for more readable and maintainable manifest
 // definitions.
 struct COMPONENT_EXPORT(SERVICE_MANAGER_CPP) Manifest {
- public:
-  using ServiceName = std::string;
-  using CapabilityName = std::string;
-  using InterfaceName = std::string;
-  using InterfaceNameSet = std::set<InterfaceName>;
-  using CapabilityNameSet = std::set<CapabilityName>;
-  using ExposedCapabilityMap = std::map<CapabilityName, InterfaceNameSet>;
-  using RequiredCapabilityMap = std::map<ServiceName, CapabilityNameSet>;
-
   // Represents the display name of this service (in e.g. a task manager).
   //
   // TODO(https://crbug.com/915806): Extend this to support resource IDs in
@@ -129,45 +133,62 @@
   template <typename... InterfaceTypes>
   struct InterfaceList {};
 
-  Manifest();
-  Manifest(const Manifest&);
-  Manifest(Manifest&&);
+  // Represents a capability exposed by a service. Every exposed capability
+  // consists of a name (implicitly scoped to the service) and a list of
+  // interfaces the service is willing to bind on behalf of clients who have
+  // been granted the capability.
+  //
+  // See RequiredCapability for more details on how exposed capabilities are
+  // used by the system.
+  struct COMPONENT_EXPORT(SERVICE_MANAGER_CPP) ExposedCapability {
+    ExposedCapability();
+    ExposedCapability(const ExposedCapability&);
+    ExposedCapability(ExposedCapability&&);
 
-  ~Manifest();
+    template <typename... InterfaceTypes>
+    ExposedCapability(const std::string& capability_name,
+                      InterfaceList<InterfaceTypes...> interfaces)
+        : capability_name(capability_name),
+          interface_names(internal::GetInterfaceNames<InterfaceTypes...>()) {}
 
-  Manifest& operator=(const Manifest&);
-  Manifest& operator=(Manifest&&);
+    // Prefer the above constructor. This exists to support genenerated code.
+    ExposedCapability(const std::string& capability_name,
+                      std::set<const char*> interface_names);
 
-  // Amends this Manifest with a subset of |other|. Namely, exposed and required
-  // capabilities, exposed and required interface filter capabilities, packaged
-  // services, and preloaded files are all added from |other| if present.
-  Manifest& Amend(Manifest other);
+    ~ExposedCapability();
 
-  ServiceName service_name;
-  DisplayName display_name;
-  Options options;
+    ExposedCapability& operator=(const ExposedCapability&);
+    ExposedCapability& operator=(ExposedCapability&&);
 
-  // All capabilities exposed by this service. The key is the name of the
-  // capability, which is an arbitrary string value chosen by and scoped to the
-  // service. The value is a set of mojom interface names, conveying the set of
-  // interfaces to which this capability grants access via the Service Manager.
-  // See |required_capabilities| for information on how another service can have
-  // that access granted to them.
-  ExposedCapabilityMap exposed_capabilities;
-
-  // All capabilities required by this service. The key is the name of another
-  // service, and the corresponding value is the set of (names of) capabilities
-  // required from that service.
-  //
-  // If a service A declares in its manifest that it requires a capability X
-  // from service B, then A will be allowed to request any interface exposed
-  // through X (i.e. through the capability in the |exposed_capabilities| field
-  // of B's manifest), using |BindInterface()| on A's Connector.
-  RequiredCapabilityMap required_capabilities;
+    // The name of this capability.
+    std::string capability_name;
+
+    // The list of interfaces accessible to clients granted this capability.
+    std::set<std::string> interface_names;
+  };
+
+  // Represents a capability required by a service. Every required capability
+  // is a simple pairwise combination of service name and capability name, where
+  // the capability name corresponds to a capability exposed by the named
+  // service.
+  //
+  // A service which requires a specific capability is implicitly granted that
+  // capability by the Service Manager. If a service requests an interface from
+  // another service but has not been granted any capability which includes that
+  // interface, the Service Manager will block the request without ever routing
+  // it to an instance of the target service.
+  struct RequiredCapability {
+    // The name of the service which exposes this required capability.
+    std::string service_name;
+
+    // The name of the capability to require. This must match the name of a
+    // capability exposed by |service_name|'s own Manifest.
+    std::string capability_name;
+  };
 
   // DEPRECATED: This will be removed soon. Don't add new uses of interface
   // filters. Instead prefer to define explicit broker interfaces and expose
-  // them through |exposed_capabilities|.
+  // them through a top-level ExposedCapability.
   //
   // Services may define capabilities to be scoped within a named interface
   // filter. These capabilities do not apply to normal interface binding
@@ -182,27 +203,81 @@
   //
   // If this all sounds very confusing, that's because it is very confusing.
   // Hence the "DEPRECATED" bit.
-  using FilterName = std::string;
-  std::map<FilterName, ExposedCapabilityMap>
-      exposed_interface_filter_capabilities;
+  struct COMPONENT_EXPORT(SERVICE_MANAGER_CPP)
+      ExposedInterfaceFilterCapability {
+    ExposedInterfaceFilterCapability();
+    ExposedInterfaceFilterCapability(ExposedInterfaceFilterCapability&&);
+    ExposedInterfaceFilterCapability(const ExposedInterfaceFilterCapability&);
+
+    template <typename... InterfaceTypes>
+    ExposedInterfaceFilterCapability(
+        const std::string& filter_name,
+        const std::string& capability_name,
+        InterfaceList<InterfaceTypes...> interfaces)
+        : filter_name(filter_name),
+          capability_name(capability_name),
+          interface_names(internal::GetInterfaceNames<InterfaceTypes...>()) {}
+
+    // Prefer the above constructor. This exists to support genenerated code.
+    ExposedInterfaceFilterCapability(const std::string& filter_name,
+                                     const std::string& capability_name,
+                                     std::set<const char*> interface_names);
+
+    ~ExposedInterfaceFilterCapability();
+
+    ExposedInterfaceFilterCapability& operator=(
+        const ExposedInterfaceFilterCapability&);
+    ExposedInterfaceFilterCapability& operator=(
+        ExposedInterfaceFilterCapability&&);
+
+    std::string filter_name;
+    std::string capability_name;
+    std::set<std::string> interface_names;
+  };
 
   // DEPRECATED: This will be removed soon. Don't add new uses of interface
   // filters.
   //
-  // This is like |required_capabilities|, except that it only grants the
-  // requiring/ service access to a set of interfaces on a specific
-  // InterfaceProvider, filtered by the exposing service according to an
-  // |exposed_interface_filter_capabilities| in that service's manifest. See
-  // notes on that field above.
-  std::map<FilterName, RequiredCapabilityMap>
-      required_interface_filter_capabilities;
+  // This is like RequiredCapability, except that it only grants the requiring
+  // service access to a set of interfaces on a specific InterfaceProvider,
+  // filtered by the exposing service according to an
+  // ExposedInterfaceFilterCapability in that service's manifest. See notes on
+  // ExposedInterfaceFilterCapability.
+  struct RequiredInterfaceFilterCapability {
+    std::string service_name;
+    std::string filter_name;
+    std::string capability_name;
+  };
+
+  Manifest();
+  Manifest(const Manifest&);
+  Manifest(Manifest&&);
 
+  ~Manifest();
+
+  Manifest& operator=(const Manifest&);
+  Manifest& operator=(Manifest&&);
+
+  // Amends this Manifest with a subset of |other|. Namely, exposed and required
+  // capabilities, exposed and required interface filter capabilities, packaged
+  // services, and preloaded files are all added from |other| if present.
+  Manifest& Amend(Manifest other);
+
+  std::string service_name;
+  DisplayName display_name;
+  Options options;
+  std::vector<ExposedCapability> exposed_capabilities;
+  std::vector<RequiredCapability> required_capabilities;
+  std::vector<ExposedInterfaceFilterCapability>
+      exposed_interface_filter_capabilities;
+  std::vector<RequiredInterfaceFilterCapability>
+      required_interface_filter_capabilities;
   std::vector<Manifest> packaged_services;
   std::vector<PreloadedFileInfo> preloaded_files;
 
   // The list of interfaces that this service are allowed to connect to
   // unconditionally on any service.
-  InterfaceNameSet interfaces_bindable_on_any_service;
+  std::set<std::string> interfaces_bindable_on_any_service;
 };
 
 }  // namespace service_manager
--- a/services/service_manager/public/cpp/manifest_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/service_manager/public/cpp/manifest_unittest.cc	2019-05-17 18:53:37.976000000 +0300
@@ -37,7 +37,7 @@
   return *manifest;
 }
 
-Manifest CreateTestManifest() {
+const Manifest& GetManifest() {
   static base::NoDestructor<Manifest> manifest{
       ManifestBuilder()
           .WithServiceName(kTestServiceName)
@@ -77,7 +77,7 @@
 }
 
 TEST(ManifestTest, BasicBuilder) {
-  auto manifest = CreateTestManifest();
+  const auto& manifest = GetManifest();
   EXPECT_EQ(kTestServiceName, manifest.service_name);
   EXPECT_EQ("none", manifest.options.sandbox_type);
   EXPECT_TRUE(manifest.options.can_connect_to_instances_in_any_group);
@@ -85,31 +85,10 @@
   EXPECT_FALSE(manifest.options.can_register_other_service_instances);
   EXPECT_EQ(Manifest::InstanceSharingPolicy::kSharedAcrossGroups,
             manifest.options.instance_sharing_policy);
-
   EXPECT_EQ(2u, manifest.exposed_capabilities.size());
-  EXPECT_THAT(manifest.exposed_capabilities["capability_1"],
-              ElementsAre(mojom::Connector::Name_, mojom::PIDReceiver::Name_));
-  EXPECT_THAT(manifest.exposed_capabilities["capability_2"],
-              ElementsAre(mojom::Connector::Name_));
-
   EXPECT_EQ(2u, manifest.required_capabilities.size());
-  EXPECT_THAT(manifest.required_capabilities["service_42"],
-              ElementsAre("computation"));
-  EXPECT_THAT(manifest.required_capabilities["frobinator"],
-              ElementsAre("frobination"));
-
   EXPECT_EQ(1u, manifest.exposed_interface_filter_capabilities.size());
-  EXPECT_THAT(
-      manifest.exposed_interface_filter_capabilities["navigation:frame"]
-                                                    ["filter_capability_1"],
-      ElementsAre(mojom::Connector::Name_));
-
-  EXPECT_EQ(1u, manifest.required_interface_filter_capabilities.size());
-  EXPECT_THAT(
-      manifest.required_interface_filter_capabilities["navigation:frame"]
-                                                     ["browser"],
-      ElementsAre("another_filter_capability", "some_filter_capability"));
-
+  EXPECT_EQ(2u, manifest.required_interface_filter_capabilities.size());
   EXPECT_EQ(2u, manifest.packaged_services.size());
   EXPECT_EQ(manifest.packaged_services[0].service_name,
             GetPackagedService1Manifest().service_name);
@@ -144,31 +123,41 @@
 
   manifest.Amend(std::move(overlay));
 
-  auto& exposed_capabilities = manifest.exposed_capabilities;
+  const auto& exposed_capabilities = manifest.exposed_capabilities;
   ASSERT_EQ(2u, exposed_capabilities.size());
-  EXPECT_THAT(exposed_capabilities["cap1"],
+  EXPECT_EQ("cap1", exposed_capabilities[0].capability_name);
+  EXPECT_THAT(exposed_capabilities[0].interface_names,
               ElementsAre("interface1", "interface2", "xinterface1"));
-  EXPECT_THAT(exposed_capabilities["xcap1"], ElementsAre("xinterface2"));
 
-  auto& required_capabilities = manifest.required_capabilities;
+  const auto& required_capabilities = manifest.required_capabilities;
   ASSERT_EQ(3u, required_capabilities.size());
-  EXPECT_THAT(required_capabilities["service1"], ElementsAre("cap2"));
-  EXPECT_THAT(required_capabilities["service2"], ElementsAre("cap3"));
-  EXPECT_THAT(required_capabilities["xservice1"], ElementsAre("xcap2"));
+  EXPECT_EQ("service1", required_capabilities[0].service_name);
+  EXPECT_EQ("cap2", required_capabilities[0].capability_name);
+  EXPECT_EQ("service2", required_capabilities[1].service_name);
+  EXPECT_EQ("cap3", required_capabilities[1].capability_name);
+  EXPECT_EQ("xservice1", required_capabilities[2].service_name);
+  EXPECT_EQ("xcap2", required_capabilities[2].capability_name);
 
-  auto& exposed_filters = manifest.exposed_interface_filter_capabilities;
+  const auto& exposed_filters = manifest.exposed_interface_filter_capabilities;
   ASSERT_EQ(2u, exposed_filters.size());
-  EXPECT_THAT(exposed_filters["filter1"]["filtercap1"],
+  EXPECT_EQ("filter1", exposed_filters[0].filter_name);
+  EXPECT_EQ("filtercap1", exposed_filters[0].capability_name);
+  EXPECT_THAT(exposed_filters[0].interface_names,
               ElementsAre("interface3", "interface4", "xinterface3"));
-  EXPECT_THAT(exposed_filters["xfilter1"]["xfiltercap1"],
-              ElementsAre("xinterface4"));
 
-  auto& required_filters = manifest.required_interface_filter_capabilities;
+  EXPECT_EQ("xfilter1", exposed_filters[1].filter_name);
+  EXPECT_EQ("xfiltercap1", exposed_filters[1].capability_name);
+  EXPECT_THAT(exposed_filters[1].interface_names, ElementsAre("xinterface4"));
+
+  const auto& required_filters =
+      manifest.required_interface_filter_capabilities;
   ASSERT_EQ(2u, required_filters.size());
-  EXPECT_THAT(required_filters["filter2"]["service3"],
-              ElementsAre("filtercap2"));
-  EXPECT_THAT(required_filters["xfilter2"]["xservice2"],
-              ElementsAre("xfiltercap2"));
+  EXPECT_EQ("service3", required_filters[0].service_name);
+  EXPECT_EQ("filter2", required_filters[0].filter_name);
+  EXPECT_EQ("filtercap2", required_filters[0].capability_name);
+  EXPECT_EQ("xservice2", required_filters[1].service_name);
+  EXPECT_EQ("xfilter2", required_filters[1].filter_name);
+  EXPECT_EQ("xfiltercap2", required_filters[1].capability_name);
 }
 
 }  // namespace service_manager
--- a/services/service_manager/public/cpp/service_binding.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/service_manager/public/cpp/service_binding.cc	2019-05-17 18:53:37.976000000 +0300
@@ -11,7 +11,7 @@
 #include "base/synchronization/lock.h"
 #include "services/service_manager/public/cpp/service.h"
 #include "services/tracing/public/cpp/traced_process.h"
-#include "services/tracing/public/mojom/traced_process.mojom.h"
+#include "services/tracing/public/mojom/tracing.mojom.h"
 
 namespace service_manager {
 
--- a/services/service_manager/public/cpp/service_binding.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/service_manager/public/cpp/service_binding.h	2019-05-17 18:53:37.976000000 +0300
@@ -7,7 +7,6 @@
 
 #include <memory>
 
-#include "base/bind.h"
 #include "base/callback.h"
 #include "base/component_export.h"
 #include "base/macros.h"
--- a/services/service_manager/public/cpp/service_executable/BUILD.gn	2019-05-01 01:22:56.000000000 +0300
+++ b/services/service_manager/public/cpp/service_executable/BUILD.gn	2019-05-17 18:53:37.976000000 +0300
@@ -9,11 +9,12 @@
   ]
 
   deps = [
-    ":switches",
     "//mojo/core/embedder",
     "//mojo/public/cpp/platform",
     "//mojo/public/cpp/system",
     "//services/service_manager/public/cpp",
+    "//services/service_manager/runner:init",
+    "//services/service_manager/runner/common",
     "//services/service_manager/sandbox",
   ]
 
@@ -31,13 +32,6 @@
   }
 }
 
-source_set("switches") {
-  sources = [
-    "switches.cc",
-    "switches.h",
-  ]
-}
-
 # Service executable targets should link against this to get a boilerplate entry
 # point which accepts canonical command-line arguments to establish a connection
 # to the Service Manager. In order to link properly, dependents must ensure that
@@ -55,14 +49,10 @@
     "main.cc",
   ]
 
-  public_deps = [
-    "//services/service_manager/public/mojom",
-  ]
-
   deps = [
     ":support",
     "//base",
-    "//base:base_static",
     "//base:i18n",
+    "//services/service_manager/runner:init",
   ]
 }
--- a/services/service_manager/public/cpp/service_executable/main.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/service_manager/public/cpp/service_executable/main.cc	2019-05-17 18:53:37.976000000 +0300
@@ -5,62 +5,23 @@
 #include "base/at_exit.h"
 #include "base/base_switches.h"
 #include "base/command_line.h"
-#include "base/debug/debugger.h"
 #include "base/debug/stack_trace.h"
 #include "base/feature_list.h"
-#include "base/files/file_path.h"
 #include "base/i18n/icu_util.h"
 #include "base/logging.h"
 #include "base/macros.h"
 #include "base/process/launch.h"
-#include "base/stl_util.h"
-#include "base/strings/string_split.h"
-#include "base/strings/stringprintf.h"
-#include "base/strings/utf_string_conversions.h"
 #include "base/task/task_scheduler/task_scheduler.h"
 #include "build/build_config.h"
 #include "services/service_manager/public/cpp/service_executable/service_executable_environment.h"
 #include "services/service_manager/public/cpp/service_executable/service_main.h"
 #include "services/service_manager/public/mojom/service.mojom.h"
+#include "services/service_manager/runner/init.h"
 
 #if defined(OS_MACOSX)
 #include "base/mac/bundle_locations.h"
 #endif
 
-namespace {
-
-void WaitForDebuggerIfNecessary() {
-  const base::CommandLine* command_line =
-      base::CommandLine::ForCurrentProcess();
-  if (command_line->HasSwitch(::switches::kWaitForDebugger)) {
-    std::vector<std::string> apps_to_debug = base::SplitString(
-        command_line->GetSwitchValueASCII(::switches::kWaitForDebugger), ",",
-        base::TRIM_WHITESPACE, base::SPLIT_WANT_ALL);
-    std::string app = "launcher";
-    base::FilePath exe_path =
-        command_line->GetProgram().BaseName().RemoveExtension();
-    for (const auto& app_name : apps_to_debug) {
-      if (base::FilePath().AppendASCII(app_name) == exe_path) {
-        app = app_name;
-        break;
-      }
-    }
-    if (apps_to_debug.empty() || base::ContainsValue(apps_to_debug, app)) {
-#if defined(OS_WIN)
-      base::string16 appw = base::UTF8ToUTF16(app);
-      base::string16 message = base::UTF8ToUTF16(
-          base::StringPrintf("%s - %ld", app.c_str(), GetCurrentProcessId()));
-      MessageBox(NULL, message.c_str(), appw.c_str(), MB_OK | MB_SETFOREGROUND);
-#else
-      LOG(ERROR) << app << " waiting for GDB. pid: " << getpid();
-      base::debug::WaitForDebugger(60, true);
-#endif
-    }
-  }
-}
-
-}  // namespace
-
 int main(int argc, char** argv) {
   base::AtExitManager at_exit;
   base::CommandLine::Init(argc, argv);
@@ -69,14 +30,7 @@
   base::RouteStdioToConsole(false);
 #endif
 
-  logging::LoggingSettings settings;
-  settings.logging_dest = logging::LOG_TO_SYSTEM_DEBUG_LOG;
-  logging::InitLogging(settings);
-  // To view log output with IDs and timestamps use "adb logcat -v threadtime".
-  logging::SetLogItems(true,   // Process ID
-                       true,   // Thread ID
-                       true,   // Timestamp
-                       true);  // Tick count
+  service_manager::InitializeLogging();
 
   base::i18n::InitializeICU();
 
@@ -91,7 +45,7 @@
       command_line->GetSwitchValueASCII(switches::kEnableFeatures),
       command_line->GetSwitchValueASCII(switches::kDisableFeatures));
 
-  WaitForDebuggerIfNecessary();
+  service_manager::WaitForDebuggerIfNecessary();
   service_manager::ServiceExecutableEnvironment environment;
   ServiceMain(environment.TakeServiceRequestFromCommandLine());
   base::TaskScheduler::GetInstance()->Shutdown();
--- a/services/service_manager/public/cpp/service_executable/service_executable_environment.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/service_manager/public/cpp/service_executable/service_executable_environment.cc	2019-05-17 18:53:37.976000000 +0300
@@ -5,6 +5,7 @@
 #include "services/service_manager/public/cpp/service_executable/service_executable_environment.h"
 
 #include "base/command_line.h"
+#include "base/debug/stack_trace.h"
 #include "base/logging.h"
 #include "base/message_loop/message_loop.h"
 #include "base/message_loop/message_loop_current.h"
@@ -15,7 +16,8 @@
 #include "mojo/public/cpp/platform/platform_channel.h"
 #include "mojo/public/cpp/system/invitation.h"
 #include "mojo/public/cpp/system/message_pipe.h"
-#include "services/service_manager/public/cpp/service_executable/switches.h"
+#include "services/service_manager/runner/common/client_util.h"
+#include "services/service_manager/runner/common/switches.h"
 #include "services/service_manager/sandbox/sandbox.h"
 #include "services/service_manager/sandbox/switches.h"
 
@@ -77,9 +79,7 @@
   auto invitation = mojo::IncomingInvitation::Accept(
       mojo::PlatformChannel::RecoverPassedEndpointFromCommandLine(
           *base::CommandLine::ForCurrentProcess()));
-  return mojom::ServiceRequest(invitation.ExtractMessagePipe(
-      base::CommandLine::ForCurrentProcess()->GetSwitchValueASCII(
-          switches::kServiceRequestAttachmentName)));
+  return GetServiceRequestFromCommandLine(&invitation);
 }
 
 }  // namespace service_manager
--- a/services/service_manager/public/cpp/test/BUILD.gn	2019-05-01 01:22:56.000000000 +0300
+++ b/services/service_manager/public/cpp/test/BUILD.gn	2019-05-17 18:53:37.980000000 +0300
@@ -17,6 +17,7 @@
   public_deps = [
     "//base",
     "//services/service_manager",
+    "//services/service_manager/background:lib",
     "//services/service_manager/public/cpp",
     "//services/service_manager/public/mojom",
   ]
--- a/services/service_manager/public/cpp/test/test_connector_factory.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/service_manager/public/cpp/test/test_connector_factory.cc	2019-05-17 18:53:37.980000000 +0300
@@ -6,15 +6,12 @@
 
 #include <vector>
 
-#include "base/bind.h"
-#include "base/bind_helpers.h"
 #include "base/guid.h"
 #include "base/macros.h"
 #include "mojo/public/cpp/bindings/associated_binding.h"
 #include "mojo/public/cpp/bindings/binding_set.h"
 #include "services/service_manager/public/cpp/service.h"
 #include "services/service_manager/public/mojom/connector.mojom.h"
-#include "services/service_manager/public/mojom/service.mojom.h"
 
 namespace service_manager {
 
@@ -46,7 +43,6 @@
   void BindInterface(const ServiceFilter& service_filter,
                      const std::string& interface_name,
                      mojo::ScopedMessagePipeHandle interface_pipe,
-                     mojom::BindInterfacePriority priority,
                      BindInterfaceCallback callback) override {
     auto* proxy = GetServiceProxy(service_filter.service_name());
     if (!proxy && factory_->ignore_unknown_service_requests()) {
--- a/services/service_manager/public/cpp/test/test_service_manager.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/service_manager/public/cpp/test/test_service_manager.cc	2019-05-17 18:53:37.980000000 +0300
@@ -4,7 +4,8 @@
 
 #include "services/service_manager/public/cpp/test/test_service_manager.h"
 
-#include "services/service_manager/background_service_manager.h"
+#include "services/service_manager/background/background_service_manager.h"
+#include "services/service_manager/service_manager.h"
 
 namespace service_manager {
 
@@ -13,7 +14,7 @@
 
 TestServiceManager::TestServiceManager(const std::vector<Manifest>& manifests)
     : background_service_manager_(
-          std::make_unique<BackgroundServiceManager>(manifests)) {}
+          std::make_unique<BackgroundServiceManager>(nullptr, manifests)) {}
 
 TestServiceManager::~TestServiceManager() = default;
 
--- a/services/service_manager/public/java/borg/chromium/services/service_manager/Connector.java	2019-05-01 01:22:56.000000000 +0300
+++ b/services/service_manager/public/java/borg/chromium/services/service_manager/Connector.java	2019-05-17 18:53:37.980000000 +0300
@@ -43,8 +43,7 @@
 
         org.chromium.service_manager.mojom.Connector.BindInterfaceResponse callback =
                 new ConnectorBindInterfaceResponseImpl();
-        mConnector.bindInterface(filter, interfaceName, request.passHandle(),
-                org.chromium.service_manager.mojom.BindInterfacePriority.IMPORTANT, callback);
+        mConnector.bindInterface(filter, interfaceName, request.passHandle(), callback);
     }
 
     @Override
--- a/services/service_manager/public/mojom/connector.mojom	2019-05-01 01:22:56.000000000 +0300
+++ b/services/service_manager/public/mojom/connector.mojom	2019-05-17 18:53:37.980000000 +0300
@@ -25,22 +25,6 @@
   ACCESS_DENIED
 };
 
-// Used with BindInterface to indicate how the Service Manager should treat an
-// individual interface request.
-enum BindInterfacePriority {
-  // The request is important and the Service Manager should try to keep the
-  // destination service instance alive until it receives the request. This is
-  // generally the default mode of operation that clients want.
-  kImportant,
-
-  // Allows the Service Manager to route the request to a service instance which
-  // may die by the time the request arrives. BindInterface calls which use this
-  // priority may be inherently flaky, but this behavior can be desirable in
-  // cases where a service manages its lifetime independent of whether the given
-  // interface is in use (e.g. for shared client support like tracing).
-  kBestEffort,
-};
-
 // A collection of metadata that disambiguates instances in the service manager.
 struct Identity {
   // A name identifying a service.
@@ -121,8 +105,7 @@
   // request.
   BindInterface(ServiceFilter filter,
                 string interface_name,
-                handle<message_pipe> interface_pipe,
-                BindInterfacePriority priority)
+                handle<message_pipe> interface_pipe)
       => (ConnectResult result, Identity? identity);
 
   // Asks the Service Manager for details about the service named
--- a/services/service_manager/README.md	2019-05-01 01:22:56.000000000 +0300
+++ b/services/service_manager/README.md	2019-05-17 18:53:37.972000000 +0300
@@ -1,928 +1,535 @@
-# The Service Manager &amp; Services
+# Service Manager User Guide
 
 [TOC]
 
-## Overview
+## What is the Service Manager?
 
-The Service Manager is a component which large applications like Chromium can
-use support a cross-platform, multi-process, service-oriented,
-hyphenated-adjective-laden architecture.
-
-This document covers how to embed
-the Service Manager into an application as well as how to define and register
-services for it to manage. If you just want to read about defining services and
-using common service APIs, skip to the main [Services](#Services) section.
-
-## Embedding the Service Manager
-
-To embed the Service Manager, an application should link against the code in
-`//services/service_manager/embedder`. This defines a main entry point for
-most platforms, with a relatively small
-[`service_manager::MainDelegate`](https://cs.chromium.org/chromium/bservices/service_manager/embedder/main_delegate.h)
-interface for the application to implement. In particular, the application
-should at least implement
-[`GetServiceManifests`](https://cs.chromium.org/chromium/bservices/service_manager/embedder/main_delegate.h?rcl=734122d6a01196706dfc1c252fa09ed933778f8f&l=80) to provide
-metadata about the full set of services comprising the application.
-
-*** aside
-Note that Chromium does not currently implement `GetServiceManifests` for
-production use of the Service Manager. This is because a bunch of process
-launching and management logic still lives at the Content layer. As more of this
-code moves into Service Manager internals, Chromium will start to look more like
-any other Service Manager embedder.
-***
+The **Service Manager** is a tool that brokers connections and capabilities
+between --  and manages instances of -- system components referred to henceforth
+as **services**.
+
+The Service Manager performs the following functions:
+
+* Brokers interface requests between service instances, enforcing static
+  capability policies declared by the services involved.
+* Launches and manages the lifecycle of services and processes.
+* Isolates service instances and interface requests among them.
+* Tracks running service instances and exposes privileged APIs for querying
+  system state.
+
+The Service Manager presents a series of Mojo
+[interfaces](https://cs.chromium.org/chromium/bservices/service_manager/public/mojom/)
+to services, though in practice most interaction with the Service Manager is
+made simpler by using its corresponding
+[C++ client library](https://cs.chromium.org/chromium/bservices/service_manager/public/cpp/).
+
+## Mojo Recap
+
+The Mojo system provides two key components of interest here - a lightweight
+message pipe concept allowing two endpoints to communicate, and a bindings layer
+that allows interfaces to be described to bind to those endpoints, with
+ergonomic bindings for languages used in Chrome.
+
+Mojo message pipes are designed to be lightweight and may be read from/written
+to and passed around from one process to another. In most situations a developer
+won't interact with the pipes directly, but rather with bindings types generated
+to encapsulate a bound interface. To use the bindings, a developer defines their
+interface in the [Mojom IDL format](/mojo/public/tools/bindings). With some
+build magic, the generated definitions can then be referenced from C++,
+JavaScript and Java code.
 
-*TODO: Improve embedder documentation here, and include support for in-process
-service launching once MainDelegate supports it.*
+See the [Mojo documentation](/mojo) for a complete overview, detailed
+explanations, and API references.
 
 ## Services
 
-A **service** in this context can be defined as any self-contained body of
-application logic which satisfies *all* of the following constraints:
+A **service** is a collection of one or more private implementations of public
+Mojo interfaces which are reachable via the Service Manager. Every service is
+comprised of the following pieces:
+
+* A set of public Mojo interface definitions
+* A **service manifest** declarating arbitrarily named capabilities which are
+  each comprised of one or more exposed Mojo interfaces.
+* Private implementation code which responds to lifecycle events and incoming
+  interface requests, all driven by the Service Manager.
+
+The Service Manager is responsible for starting new service instances on-demand,
+and a given service may have any number of concurrently running instances. The
+Service Manager disambiguates service instances by their unique **identity**. A
+service's identity is represented by the 3-tuple of its **service name**, **user
+ID**, and **instance qualifier**:
+
+* The service name is a free-form -- typically short -- string identifying the
+  the specific service being run in the instance.
+* The user ID is a GUID string representing the identity of a user in the system.
+  Every running service instance is associated with a specific user ID.
+* Finally, the instance qualifier is an arbitrary free-form string used to
+  disambiguate multiple instances of a service for the same user.
+
+As long as a service instance is running it must maintain an implementation of
+the
+[`service_manager.mojom.Service`](https://cs.chromium.org/chromium/bservices/service_manager/public/mojom/service.mojom)
+interface. Typically this is done in C++ code by implementing the C++ client
+library's
+[`service_manager::Service`](https://cs.chromium.org/chromium/bservices/service_manager/public/cpp/service.h)
+interface. This interface is driven by messages from the Service Manager and is
+used to receive incoming interface requests the Service Manager brokers from
+other services.
+
+Every service instance also has an outgoing link back to the Service Manager
+which it can use to make interface requests to other services in the system.
+This is the
+[`service_manager.mojom.Connector`](https://cs.chromium.org/chromium/bservices/service_manager/public/mojom/connector.mojom)
+interface, and it's commonly used via the C++ client library's
+[`service_manager::Connector`](https://cs.chromium.org/chromium/bservices/service_manager/public/cpp/connector.h)
+class.
+
+## A Simple Service Example
+
+This section walks through the creation of a simple skeleton service.
+
+### Private Implementation
 
-- It defines a single [implementation](#Implementation) of
-  [`Service`](https://cs.chromium.org/chromium/bservices/service_manager/public/cpp/service.h)
-  to receive interface requests brokered by the
-  Service Manager, and it maintains a connection between this object and the
-  Service Manager using a
-  [`ServiceBinding`](https://cs.chromium.org/chromium/bservices/service_manager/public/cpp/service_binding.h).
-- Its API surface in from or out to other services is restricted exclusively to
-  [Mojo](/mojo/README.md) interfaces and self-contained client libraries built
-  on those Mojo interfaces. This means no link-time or run-time exposure of
-  the service implementation's internal heap or global state.
-- It defines a [service manifest](#Manifests) to declare how the Service Manager
-  should identify and manage instances of the service, as well as what
-  interfaces are exposed to or required from other services in the system.
-
-The Service Manager is responsible for managing the creation and interconnection
-of individual service instances, whether they are embedded within an existing
-process or each isolated within dedicated processes. Managed service processes
-may be sandboxed with any of various supported
-[sandbox configurations](#Sandbox-Configurations).
-
-This section walks through important concepts and APIs throughout service
-development, and builds up a small working example service in the process.
-
-### A Brief Note About Service Granularity
-
-Many developers fret over what the right "size" or granularity is for a service
-or set of services. This makes sense, and there is always going to be some
-design tension between choosing a simpler and potentially more efficient,
-monolithic implementation, versus choosing a more modular but often more complex
-one.
-
-One classic example of this tension is in the origins of Chromium's
-`device` service. The service hosts a number of independent device interfacing
-subsystems for things like USB, Bluetooth, HID, battery status, etc. You could
-easily imagine justifying separate services for each of these features, but it
-was ultimately decided keep them merged together as one service thematically
-related to hardware device capabilities. Some factors which played into this
-decision:
-
-- There was no clear **security** benefit to keeping the features isolated from
-  each other.
-- There was no clear **code size** benefit to keeping the features isolated from
-  each other -- environments supporting any one of the device capabilities are
-  fairly likely to support several others and would thus likely include all or
-  most of the smaller services anyway.
-- There isn't really any coupling between the different features in the service,
-  so there would be few **code health** benefits to building separate services.
-
-Given all of the above conditions, opting for a smaller overall number of
-services seems likely to have been the right decision.
-
-When making these kinds of decisions yourself, use your best judgment. When in
-doubt, start a bike-shedding centithread on
-[services-dev@chromium.org](https://groups.google.com/a/chromium.org/forum#!forum/services-dev).
-
-### Implementation
-
-The central fixture in any service implementation is, well, its
-[`Service`](https://cs.chromium.org/chromium/bservices/service_manager/public/cpp/service.h)
-implementation. This is a small interface with really only three virtual methods
-of practical interest, all optional to implement:
+Consider this implementation of the `service_manager::Service` interface:
 
+**`//services/my_service/my_service.h`**
 ``` cpp
-class Service {
+#include "base/macros.h"
+#include "services/service_manager/public/cpp/service.h"
+
+namespace my_service {
+
+class MyService : public service_manager::Service {
  public:
-  virtual void OnStart();
-  virtual void OnBindInterface(const BindSourceInfo& source,
+  MyService();
+  ~MyService() override;
+
+  // service_manager::Service:
+  void OnStart() override;
+  void OnBindInterface(const service_manager::BindSourceInfo& source_info,
                                const std::string& interface_name,
-                               mojo::ScopedMessagePipeHandle interface_pipe);
-  virtual void OnDisconnected();
+                       mojo::ScopedMessagePipeHandle handle) override;
+ private:
+  DISALLOW_COPY_AND_ASSIGN(MyService);
 };
-```
 
-Services implement a subclass of this to work in conjunction with a
-[`ServiceBinding`](https://cs.chromium.org/chromium/bservices/service_manager/public/cpp/service_binding.h)
-so the Service Manager can call into the service with lifecycle events and
-interface requests from other services.
-
-*** aside
-NOTE: As discussed in [Instance Sharing](#Instance-Sharing) below, your service
-configuration may allow for the Service Manager to manage many concurrent
-instances of your service. Whether these instances run in the same shared
-process or in separate processes, each instance is comprised of exactly one
-dedicated instance of your actual `Service` subclass.
-***
-
-Through the rest of this document we'll build out a basic working service
-implementation, complete with a manifest and simple tests. We'll call it the
-`storage` service, and it will provide the basis for all persistent storage
-capabilities in our crappy operating system hobby project that is doomed to
-languish forever in an unfinished state.
-
-*** aside
-NOTE: Sheerly for the sake of brevity, example code written here is inlined in
-headers where it would typically be moved out-of-line.
-***
-
-The first step is usually to imagine and define some mojom API surface to start
-with. We'll limit this example to two mojom files. It's conventional to keep
-important constants defined in a separate `constants.mojom` file:
+}  // namespace my_service
+```
 
+**`//services/my_service/my_service.cc`**
 ``` cpp
-// bservices/storage/public/mojom/constants.mojom
-module storage.mojom;
-
-// This string will identify our service to the Service Manager. It will be used
-// in our manifest when registering the service, and clients can use it when
-// sending interface requests to the Service Manager if they want to reach our
-// service.
-const string kServiceName = "storage";
+#include "services/my_service/my_service.h"
 
-// We'll use this later, in service manifest definitions.
-const string kAllocationCapability = "allocation";
-```
+namespace my_service {
 
-And some useful interface definitions:
+MyService::MyService() = default;
 
-``` cpp
-// bservices/storage/public/mojom/block.mojom
-module storage.mojom;
+MyService::~MyService() = default;
 
-interface BlockAllocator {
-  // Allocates a new block of persistent storage for the client. If allocation
-  // fails, |request| is discarded.
-  Allocate(uint64 num_bytes, Block& request);
-};
+void MyService::OnStart() {
+}
 
-interface Block {
-  // Reads and returns a small range of bytes from the block.
-  Read(uint64 byte_offset, uint16 num_bytes) => (array<uint8> bytes);
+void MyService::OnBindInterface(const service_manager::ServiceInfo& remote_info,
+                                const std::string& interface_name,
+                                mojo::ScopedMessagePipeHandle handle) {
+}
 
-  // Writes a small range of bytes to the block.
-  Write(uint64 byte_offset, array<uint8> bytes);
-};
+}  // namespace my_service
 ```
 
-And finally we'll define our basic `Service` subclass:
+### Main Entry Point
 
+While services do not need to define a main entry point -- *e.g.* they may only
+intend to be embedded in other running processes -- for the sake of completeness
+we also define a `ServiceMain` definition so that the service can be run in its
+own process:
+
+**`//services/my_service/my_service_main.cc`**
 ``` cpp
-// bservices/storage/storage_service.h
+#include "services/my_service/my_service.h"
+#include "services/service_manager/public/c/main.h"
+#include "services/service_manager/public/cpp/service_runner.h"
 
-#include "base/macros.h"
-#include "services/service_manager/public/cpp/service.h"
-#include "services/service_manager/public/cpp/service_binding.h"
-#include "services/storage/public/mojom/block.mojom.h"
+MojoResult ServiceMain(MojoHandle service_request_handle) {
+  return service_manager::ServiceRunner(new MyService).Run(
+      service_request_handle);
+}
+```
 
-namespace storage {
+### Manifest
 
-class StorageService : public service_manager::Service,
-                       public mojom::BlockAllocator {
- public:
-  explicit StorageService(service_manager::mojom::ServiceRequest request)
-      : service_binding_(this, std::move(request)) {}
-  ~StorageService() override = default;
+A static manifest is provided to the Service Manager by each service to declare
+the capabilities exposed and required by the service:
 
- private:
-  // service_manager::Service:
-  void OnBindInterface(const service_mangaer::BindSourceInfo& source,
-                       const std::string& interface_name,
-                       mojo::ScopedMessagePipeHandle interface_pipe) override {
-    if (interface_name == mojom::BlockAllocator::Name_) {
-      // If the Service Manager sends us a request with BlockAllocator's
-      // interface name, we should treat |interface_pipe| as a
-      // BlockAllocatorRequest that we can bind.
-      allocator_bindings_.AddBinding(
-          this, mojom::BlockAllocatorRequest(std::move(interface_pipe)));
-    }
+**`//services/my_service/manifest.json`**
+``` json
+{
+  "name": "my_service",
+  "display_name": "My Service",
+  "interface_provider_specs": {
+    "service_manager:connector": {}
   }
+}
+```
 
-  // mojom::BlockAllocator:
-  void Allocate(uint64_t num_bytes, mojom::BlockRequest request) override {
-    // This space intentionally left blank.
-  }
+See [Service Manifests](#Service-Manifests) for more information.
 
-  service_manager::ServiceBinding service_binding_;
-  mojo::BindingSet<mojom::BlockAllocator> allocator_bindings_;
+### Build Targets
 
-  DISALLOW_COPY_AND_ASSIGN(StorageService);
-};
+Finally some build targets corresponding to the above things:
 
-}  // namespace storage
-```
+**`//services/my_service/BUILD.gn`**
+``` python
+import("//services/service_manager/public/cpp/service_executable.gni")
+import("//services/service_manager/public/service_manifest.gni")
 
-Great. This is a basic service implementation. It does nothing useful, but we
-can come back and fix that some other time.
+source_set("lib") {
+  public = [ "my_service.h" ]
+  sources = [ "my_service.cc" ]
 
-First, notice that the `StorageService` constructor takes a
-`service_manager::mojom::ServiceRequest` and immediately passes it to the
-`service_binding_` constructor. This is a nearly universal convention among
-service implementations, and your service will probably do it too. The
-`ServiceRequest` is an interface pipe that the Service Manager uses to drive
-your service, and the `ServiceBinding` is a helper class which translates
-messages from the Service Manager into the simpler interface methods of the
-`Service` class you've implemented.
-
-`StorageService` also implements `OnBindInterface`, which is what the Service
-Manager invokes (via your `ServiceBinding`) when it has decided to route another
-service's interface request to your service instance. Note that because this is
-a generic API intended to support arbitrary interfaces, the request comes in the
-form of an interface name and a raw message pipe handle. It is the service's
-responsibility to inspect the name and decide how (or even if) to bind the pipe.
-Here we recognize only incoming `BlockAllocator` requests and drop anything
-else.
-
-*** aside
-NOTE: Because interface requests are just strongly-type message pipe endpoint
-wrappers, you can freely construct any kind of interface request over a raw
-message pipe handle. If you're planning to pass the endpoint around, it's good
-to do this as early as possible (i.e. as soon as you know the intended interface
-type) to benefit from your compiler's type-checking and avoid having to pass
-around both a name and a pipe.
-***
-
-The last piece of our service that we need to lay down is its manifest.
-
-### Manifests
-
-A service's manifest is a simple static data structure provided to the Service
-Manager early during its initialization process. The Service Manager combines
-all of the manifest data it has in order to form a complete picture of the
-system it's coordinating. It uses all of this information to make decisions
-like:
-
-- When service X requests interface Q from service Y, should it be allowed?
-- Were all of the constraints specified in X's request valid, and is X allowed
-  to specify them as such?
-- Do I need to spawn a new instance of Y to satisfy this request or can I re-use
-  an existing one (assuming there are any)?
-- If I have to spawn a new process for a new Y instance, how should I configure
-  its sandbox, if at all?
+  public_deps = [
+    "//base",
+    "//services/service_manager/public/cpp",
+  ]
+}
 
-All of this metadata is contained within different instances of the
-[`Manifest`](https://cs.chromium.org/chromium/bservices/service_manager/public/cpp/manifest.h)
-class.
+service("my_service") {
+  sources = [
+    "my_service_main.cc",
+  ]
+  deps = [
+    ":lib",
+    "//services/service_manager/public/c",
+  ]
+}
 
-#### A Basic Manifest
+service_manifest("manifest") {
+  name = "my_service"
+  source = "manifest.json"
+}
+```
 
-The most common way to define a service's manifest is to place it in its own
-source target within the service's C++ client library. To combine the
-convenience of inline one-time initialization with the avoidance of static
-initializers, typically this means using a function-local static with
-`base::NoDestructor` and `service_manager::ManifestBuilder` as below. First the
-header:
+Building the `my_service` target produces a `my_service.service` (or on Windows,
+`my_service.service.exe`) binary in the output directory. This can be run as
+a standalone executable, but it will exit immediately without doing anything
+interesting, because it won't have a `Service` pipe to drive it. The Service
+Manager knows how to provide such a pipe when launching a service executable.
+
+This service doesn't do much of anything. It will simply run forever (or at
+least until the Service Manager itself shuts down), ignoring all incoming
+messages. Before we expand on the definition of this service, let's look at some
+of the details of the `service_manager::Service` interface.
+
+### OnStart
+
+The `Service` implementation is guaranteed to receive a single `OnStart()`
+invocation from the Service Manager before anything else hapens. Once this
+method is called, the implementation can access its
+`service_manager::ServiceContext` via `context()`. This object itself exposes a
+few values:
+
+* `service_info()` is a `service_manager::ServiceInfo` structure describing the
+  running service from the Service Manager's perspective. This includes the
+  `service_manager::Identity` which uniquely identifies the running instance,
+  as well as the `service_manager::InterfaceProviderSpec` describing the
+  capability specifications outlined in the service's manifest.
+* `identity()` is a shortcut to the `Identity` stored in the
+  `ServiceInfo`.
+* `connector()` is a `service_manager::Connector` which can be used to make
+  outgoing interface requests to other services.
+
+For example, we could modify `MyService` to connect out to logger service on
+startup:
+
+``` cpp
+void MyService::OnStart() {
+  logger::mojom::LoggerPtr logger;
+  context()->connector()->BindInterface("logger", &logger);
+  logger->Log("Started MyService!");
+}
+```
 
-``` cpp
-// bservices/storage/public/cpp/manifest.h
+### OnBindInterface
 
-#include "services/service_manager/public/cpp/manifest.h"
+The `OnBindInterface` method on `service_manager::Service` is invoked by the
+Service Manager any time another service instance uses its own `Connector` to
+request an interface from this `my_service` instance. The Service Manager only
+invokes this method once it has already validated that the request meets the
+mutual constraints specified in each involved service's manifest.
+
+The arguments to `OnBindInterface` are as follows:
+
+* `remote_info` is the `service_manager::ServiceInfo` corresponding to the
+  remote service which is requesting this interface. The information in this
+  structure is provided authoritatively by the Service Manager and can be
+  trusted in any context.
+* `interface_name` is the (`std::string`) name of the interface being requested
+  by the remote service. The Service Manager has already validated that the
+  remote service requires at least one capability which exposes this interface
+  from the local service.
+* `handle` is the `mojo::ScopedMessagePipeHandle` of an interface pipe which
+  the remote service expects us to bind to a concrete implementation of
+  the requested interface.
+
+The Service Manager client library provides a `service_manager::BinderRegistry`
+class definition which can make it easier for services to bind incoming
+interface requests. Typesafe binding callbacks are added to an `BinderRegistry`
+ahead of time, and the incoming arguments to `OnBindInterface` can be forwarded
+to the registry, which will bind the message pipe if it knows how. For example,
+we could modify our `MyService` implementation as follows:
+
+``` cpp
+namespace {
+
+void BindDatabase(my_service::mojom::DatabaseRequest request) {
+  mojo::MakeStrongBinding(std::make_unique<my_service::DatabaseImpl>(),
+                          std::move(request));
+}
 
-namespace storage {
+}  // namespace
 
-const service_manager::Manifest& GetManifest();
+MyService::MyService() {
+  // Imagine |registry_| is added as a member of MyService, with type
+  // service_manager::BinderRegistry.
+
+  // The |my_service::mojom::Database| interface type is inferred by the
+  // compiler in the AddInterface call, and this effectively adds the bound
+  // function to an internal map keyed on the interface name, i.e.
+  // "my_service::mojom::Database" in this case.
+  registry_.AddInterface(base::Bind(&BindDatabase));
+}
 
-}  // namespace storage
+void MyService::OnBindInterface(const service_manager::ServiceInfo& remote_info,
+                                const std::string& interface_name,
+                                mojo::ScopedMessagePipeHandle handle) {
+  registry_.BindInterface(interface_name, std::move(handle));
+}
 ```
 
-And for the actual implementation:
-
-``` cpp
-// bservices/storage/public/cpp/manifest.cc
+For more details regarding the definition of Mojom interfaces, implementing them
+in C++, and working with C++ types like `InterfaceRequest`, see the
+[Mojom IDL and Bindings Generator](/mojo/public/tools/bindings) and
+[Mojo C++ Bindings API](/mojo/public/cpp/bindings) documentation.
+
+## Service Manifests
+
+If some service were to come along and attempt to connect to `my_service` and
+bind the `my_service::mojom::Database` interface, we might see the Service
+Manager spit out an error log complaining that `InterfaceProviderSpec` prevented
+a connection to `my_service`.
+
+In order for the interface to be reachable by other services, we must first fix
+its manifest's **interface provider spec**. The interface provider spec is
+a dictionary keyed by **interface provider name**, with each value representing
+the **capability spec** for that provider.
+
+Each capability spec defines an optional `"provides"` key and an optional
+`"requires"` key.
+
+The `provides` key value is a dictionary which is itself keyed by arbitrary
+free-form strings (capability names, implicitly scoped to the manifest's own
+service) whose values are lists of Mojom interface names exposed as part of that
+capability.
+
+The `requires` key value is also a dictionary, but it's one which is keyed by
+remote service name. Each value is a list of capabilities required from the
+corresponding remote service.
+
+Finally, every interface provider spec (often exclusively) contains one standard
+capability spec named "service_manager:connector". This is the capability spec
+enforced when inter-service connections are made from a service's `Connector`
+interface.
+
+Let's update the `my_service` manifest as follows:
+
+**`//services/my_service/manifest.json`**
+``` json
+{
+  "name": "my_service",
+  "display_name": "My Service",
+  "interface_provider_specs": {
+    "service_manager:connector": {
+      "provides": {
+        "database": [
+          "my_service::mojom::Database"
+        ]
+      }
+    }
+  }
+}
+```
 
-#include "services/storage/public/cpp/manifest.h"
+This means that `my_service` has defined a `database` capability comprised
+solely of the `my_service::mojom::Database` interface. Any service which
+requires this capability can bind that interface from `my_service`.
+
+For the sake of this example, let's define another service manifest:
+
+**`//services/other_service/manifest.json`**
+``` json
+{
+  "name": "other_service",
+  "display_name": "Other Service",
+  "interface_provider_specs": {
+    "service_manager:connector": {
+      "requires": {
+        "my_service": [ "database" ]
+      }
+    }
+  }
+}
+```
 
-#include "base/no_destructor.h"
-#include "services/storage/public/mojom/constants.mojom.h"
-#include "services/service_manager/public/cpp/manifest_builder.h"
-
-namespace storage {
-
-const service_manager::Manifest& GetManifest() {
-  static base::NoDestructor<service_manager::Manifest> manifest{
-      service_manager::ManifestBuilder()
-          .WithServiceName(mojom::kServiceName)
-          .Build()};
-  return *manifest;
-};
+Now if `other_service` attempts to bind the database interface:
 
-}  // namespace storage
+``` cpp
+void OtherService::OnStart() {
+  my_service::mojom::DatabasePtr database;
+  context()->connector()->BindInterface("my_service", &database);
+  database->AddTable(...);
+}
 ```
 
-Here we've specified only the **service name**, matching the constant defined
-in `constants.mojom` so that other services can easily locate us without a
-hard-coded string.
+The Service Manager will approve of the request and forward it on to the
+`my_service` instance's `OnBindInterface` method.
 
-With this manifest definition there is no way for our service to reach other
-services, and there's no way for other services to reach us; this is because
-we neither **expose** nor **require** any capabilities, thus the Service Manager
-will always block any interface request from us or targeting us.
+## Testing
 
-#### Exposing Interfaces
+Now that we've built a simple service it's time to write a test for it.
+The Service Manager client library provides a test fixture base class in
+[`service_manager::test::ServiceTest`](https://cs.chromium.org/chromium/bservices/service_manager/public/cpp/service_test.h) that makes writing service integration tests straightforward. This test fixture
+runs an in-process Service Manager on a background thread which allows test
+service instances to be injected at runtime.
 
-Let's expose an "allocator" capability that grants permission to bind a
-`BlockAllocator` pipe. We can augment the above manifest definition as follows:
+Let's look at a simple test of our service:
 
+**`//services/my_service/my_service_unittest.cc`**
 ``` cpp
-...
-#include "services/storage/public/mojom/block.mojom.h"
-...
-
-...
-          .WithServiceName(mojom::kServiceName)
-          .ExposeCapability(
-              mojom::kAllocatorCapability,
-              service_manager::Manifest::InterfaceList<mojom::BlockAllocator>())
-          .Build()
-...
-```
-
-This declares the existence of an `"allocator"` capability exposed by our
-service, and specifies that granting a client this capability means granting it
-the privilege to send our service `storage.mojom.BlockAllocator` interface
-requests.
-
-You can list as many interfaces as you like for each exposed capability, and
-multiple capabilities may list the same interface.
-
-**NOTE**: You only need to expose an interface through a capability if you want
-other services to be able to be able to request it *through the Service
-Manager* (see [Connectors](#Connectors)) -- that is, if you handle requests for
-it in your `Service::OnBindInterface` implementation.
-
-Contrast this with interfaces acquired transitively, like `Block` above. The
-Service Manager does not mediate the behavior of existing interface connections,
-so once a client has a `BlockAllocator` they can use `BlockAllocator.Allocate`
-to send as many `Block` requests as they like. Such requests go directly to
-the service-side implementation of `BlockAllocator` to which the pipe is bound,
-and so manifest contents are irrelevant to their behavior.
-
-#### Getting Access to Interfaces
-
-We don't need to add anything else to our `storage` manifest, but if another
-service wanted to enjoy access to our amazing storage block allocation
-facilities, they would need to declare in their manifest that they **require**
-our `"allocation"` capability. For ease of maintenance they would utilitize our
-publicly defined constants to do this. It's pretty straightforward:
+#include "base/bind.h"
+#include "base/run_loop.h"
+#include "services/service_manager/public/cpp/service_test.h"
+#include "path/to/some_interface.mojom.h"
 
-``` cpp
-// bservices/some_other_pretty_cool_service/public/cpp/manifest.cc
-
-...       // Somewhere along the chain of ManifestBuilder calls...
-          .RequireCapability(storage::mojom::kServiceName,
-                             storage::mojom::kAllocationCapability)
-...
-```
+class MyServiceTest : public service_manager::test::ServiceTest {
+ public:
+  // Our tests run as service instances themselves. In this case each instance
+  // identifies as the service named "my_service_unittests".
+  MyServiceTest() : service_manager::test::ServiceTest("my_service_unittests") {
+  }
 
-Now `some_other_pretty_cool_service` can use its [Connector](#Connectors) to ask
-the Service Manager for a `BlockAllocator` from us, like so:
+  ~MyServiceTest() override {}
+}
 
-``` cpp
-storage::mojom::BlockAllocatorPtr allocator;
-connector->BindInterface(storage::mojom::kServiceName,
-                         mojo::MakeRequest(&allocator));
-
-storage::mojom::BlockPtr block;
-allocator->Allocate(42, mojo::MakeRequest(&block));
-
-// etc..
-```
-
-#### Other Manifest Elements
-
-There are a handful of other optional elements in a `Manifest` structure which
-can affect how your service behaves at runtime. See the current
-[`Manifest`](https://cs.chromium.org/chromium/bservices/service_manager/public/cpp/manifest.h)
-definition and comments as well as
-[`ManifestBuilder`](https://cs.chromium.org/chromium/bservices/service_manager/public/cpp/manifest_builder.h)
-for the most complete and current information, but some of the more common
-properties specified by manifests are:
-
-- **Display Name** - This is the string the Service Manager will use to name
-  any new process created to run your service. This string would appear in the
-  Windows Task Manager to identify the service process, for example.
-- **Options** - A few miscellaneous options are stuffed into a `ManifestOptions`
-  field. These include sandbox type (see
-  [Sandbox Configurations](#Sandbox-Configurations)),
-  [instance sharing policy](#Instance-Sharing), and various behavioral flags to
-  control a few [special capabilities](#Additional-Capabilities).
-- **Preloaded Files** - On Android and Linux platforms, the Service Manager can
-  open specified files on the service's behalf and pass the corresponding open
-  file descriptor(s) to each new service process on launch.
-- **Packaged Services** - A service may declare that it **packages** another
-  service by including a copy of that service's own manifest. See
-  [Packaging](#Packaging) for details.
-
-### Running the Service
-
-Hooking the service up so that it can be run in a production environment is
-actually outside the scope of this document at the moment, only because it still
-depends heavily on the environment in which the Service Manager is embedded. For
-now, if you want to get your great little service hooked up in Chromium for
-example, you should check out the sections on this in the very Chromium-centric
-[Intro to Mojo &amp; Services](/docs/mojo_and_services.md#Hooking-Up-the-Service-Implementation)
-and/or
-[Servicifying Chromium Features](/docs/servicification.md#Putting-It-All-Together)
-documents.
-
-For the sake of this document, we'll focus on running the service in test
-environments with the service both in-process and out-of-process.
-
-### Testing
-
-There are three primary approaches used when testing services, applied in
-varying combinations:
-
-#### Standard Unit-testing
-This is ideal for covering details of your service's internal components and
-making sure they operate as expected. There is nothing special here regarding
-services. Code is code, you can unit-test it.
-
-#### Out-of-process End-to-end Tests
-These are good for emulating a production environment as closely as possible,
-with your service implementation isolated in a separate process from the test
-(client) code.
-
-The main drawback to this approach is that it limits your test's ability to poke
-at or observe internal service state, which can sometimes be useful in test
-environments (for *e.g.* faking out some behavior in a predictable manner). In
-general, supporting such controls means adding test-only interfaces to your
-service.
-
-The
-[`TestServiceManager`](https://cs.chromium.org/chromium/bservices/service_manager/public/cpp/test/test_service_manager.h)
-helper and
-[`service_executable`](https://cs.chromium.org/chromium/bservices/service_manager/public/cpp/service_executable.gni)
-GN target type make this fairly easy to accomplish. You simply define a new
-entry point for your service:
+TEST_F(MyServiceTest, Basic) {
+  my_service::mojom::DatabasePtr database;
+  connector()->BindInterface("my_service", &database);
 
-``` cpp
-// bservices/storage/service_main.cc
+  base::RunLoop loop;
 
-#include "base/message_loop.h"
-#include "services/service_manager/public/cpp/service_executable/main.h"
-#include "services/storage/storage_service.h"
+  // This assumes DropTable expects a response with no arguments. When the
+  // response is received, the RunLoop is quit.
+  database->DropTable("foo", loop.QuitClosure());
 
-void ServiceMain(service_manager::ServiceRequest request) {
-  base::MessageLoop message_loop;
-  storage::StorageService(std::move(request)).RunUntilTermination();
+  loop.Run();
 }
 ```
 
-and a GN target for this:
+If adding a new test binary for these tests, we can augment our `BUILD.gn` to
+use the `service_test` GN template like so:
 
-``` python
-import "services/service_manager/public/cpp/service_executable.gni"
+**`//services/my_service/BUILD.gn`**
+``` cpp
+import("//services/catalog/public/tools/catalog.gni")
+import("//services/service_manager/public/tools/test/service_test.gni")
 
-service_executable("storage") {
+service_test("my_service_unittests") {
   sources = [
-    "service_main.cc",
+    "my_service_unittest.cc",
   ]
-
   deps = [
-    # The ":impl" target would be the target that defines our StorageService
-    # implementation.
-    ":impl",
-    "//base",
-    "//services/service_manager/public/cpp",
+    "//services/my_service/public/interfaces",
   ]
+  catalog = ":my_service_unittests_catalog"
 }
 
-test("whatever_unittests") {
-  ...
-
-  # Include the executable target as data_deps for your test target
-  data_deps = [ ":storage" ]
+service_manifest("my_service_unittests_manifest") {
+  name = "my_service_unittests"
+  manifest = "my_service_unittests_manifest.json"
 }
-```
 
-And finally in your test code, use `TestServiceManager` to create a real
-Service Manager instance within your test environment, configured to know about
-your `storage` service.
-
-`TestServiceManager` allows you to inject an artificial service instance to
-treat your test suite as an actual service instance. You can provide a manifest
-for your test to simulate requiring (or failing to require) various capabilities
-and get a `Connector` with which to reach your service-under-test. This looks
-something like:
-
-``` cpp
-#include "services/service_manager/public/cpp/manifest_builder.h"
-#include "services/service_manager/public/cpp/test/test_service.h"
-#include "services/service_manager/public/cpp/test/test_service_manager.h"
-#include "services/storage/public/cpp/manifest.h"
-#include "services/storage/public/mojom/constants.mojom.h"
-#include "services/storage/public/mojom/block.mojom.h"
-...
-
-TEST(StorageServiceTest, AllocateBlock) {
-  const char kTestServiceName[] = "my_inconsequentially_named_test_service";
-  service_manager::TestServiceManager service_manager(
-      // Make sure the Service Manager knows about the storage service.
-      {storage::GetManifest,
-
-       // Also make sure it has a manifest for our test service, which this
-       // test will effectively act as an instance of.
-       service_manager::ManifestBuilder()
-           .WithServiceName(kTestServiceName)
-           .RequireCapability(storage::mojom::kServiceName,
-                              storage::mojom::kAllocationCapability)
-           .Build()});
-  service_manager::TestService test_service(
-      service_manager.RegisterTestInstance(kTestServiceName));
-
-  storage::mojom::BlockAllocatorPtr allocator;
-
-  // This Connector belongs to the test service instance and can reach the
-  // storage service through the Service Manager by virtue of the required
-  // capability above.
-  test_service.connector()->BindInterface(storage::mojom::kServiceName,
-                                          mojo::MakeRequest(&allocator));
-
-  // Verify that we can request a small block of storage.
-  storage::mojom::BlockPtr block;
-  allocator->Allocate(64, mojo::MakeRequest(&block));
-
-  // Do some stuff with the block, etc...
+catalog("my_service_unittests_catalog") {
+  testonly = true
+  embedded_services = [ ":my_service_unittests_manifest" ]
+  standalone_services = [ ":manifest" ]
 }
 ```
 
-#### In-Process Service API Tests
-
-Sometimes you want to poke at your service primarily through its client API,
-but you also want to be able to -- either for convenience or out of necessity --
-observe or manipulate its internal state within the test code. Running the
-service in-process is ideal in this case, and in that case there's not much use
-in involving the Service Manager or dealing with manifests.
-
-Instead you can use a
-[`TestConnectorFactory`](https://cs.chromium.org/chromium/bservices/service_manager/public/cpp/test/test_connector_factory.h)
-to give yourself a working `Connector` object which routes interface requests
-directly to specific service instances which you wire up directly. For a quick
-example, suppose we had some client library helper function for allocating a
-block of storage when given a `Connector`:
-
-``` cpp
-// bservices/storage/public/cpp/allocate_block.h
-
-namespace storage {
-
-// This helper function can be used by any service which is granted the
-// |kAllocationCapability| capability.
-mojom::BlockPtr AllocateBlock(service_manager::Connector* connector,
-                              uint64_t size) {
-  mojom::BlockAllocatorPtr allocator;
-  connector->BindInterface(mojom::kServiceName, mojo::MakeRequest(&allocator));
-
-  mojom::BlockPtr block;
-  allocator->Allocate(size, mojo::MakeRequest(block));
-  return block;
-}
-
-}  // namespace storage
-```
-
-Our test could look something like:
-
-``` cpp
-TEST(StorageTest, AllocateBlock) {
-  service_manager::TestConnectorFactory test_connector_factory;
-  storage::StorageService service(
-      test_connector_factory.RegisterInstance(storage::mojom::kServiceName));
-
-  constexpr uint64_t kTestBlockSize = 64;
-  storage::mojom::BlockPtr block = storage::AllocateBlock(
-      test_connector_factory.GetDefaultConnector(), kTestBlockSize);
-  block.FlushForTesting();
-
-  // Verify that we have the expected number of bytes allocated within the
-  // service implementation.
-  EXPECT_EQ(kTestBlockSize, service.GetTotalAllocationSizeForTesting());
+Alright, there's a lot going on here. First we also have to create a service
+manifest for the test service itself, as the Service Manager needs to be able
+to reason about the test's own required capabilities with respect to the
+service-under-test.
+
+We can do something like:
+
+**`//services/my_service/my_service_unittests_manifest.json`**
+``` json
+{
+  "name": "my_service_unittests",
+  "display_name": "my_service tests",
+  "interface_provider_specs": {
+    "service_manager:connector": {
+      "requires": {
+        "my_service": [ "database" ]
+      }
+    }
+  }
 }
 ```
 
-### Connectors
-
-While the
-[`Service`](https://cs.chromium.org/chromium/bservices/service_manager/public/cpp/service.h)
-interface is what the Service Manager uses to drive a service instance's
-behavior, a
-[`Connector`](https://cs.chromium.org/chromium/bservices/service_manager/public/cpp/connector.h)
-is what the service instance uses to send requests to the Service Manager. This
-interface is connected when your instance is launched, and `ServiceBinding`
-maintains and
-[exposes](https://cs.chromium.org/chromium/bservices/service_manager/public/cpp/service_binding.h?rcl=887b934e0d979f3da81c41cadc396b4ef587257a&l=66)
-it on your behalf.
-
-#### Sending Interface Requests
-
-By far the most common and useful method on `Connector` is `BindInterface`,
-which allows your service to send an interface request to another service in the
-system, configuration permitting.
-
-Supposing the `storage` service actually depended on an even lower-level storage
-service to get at its disk, you could imagine its block allocation code doing
-something like:
+You may also notice that we have suddenly introduced a **catalog** in the
+`service_test` target incantation. Any runtime environment which hosts a
+Service Manager must provide the Service Manager implementation with a catalog
+of service manifests. This catalog defines the complete set of services
+recognized by the Service Manager instance and can be used in all kinds of
+interesting ways to control how various services are started in the system. See
+[Service Manager Catalogs](#Service-Manager-Catalogs) for more information.
 
-``` cpp
-  real_storage::mojom::ReallyRealStoragePtr storage;
-  service_binding_.GetConnector()->BindInterface(
-      real_storage::mojom::kServiceName, mojo::MakeRequest(&storage));
-  storage->AllocateBytes(...);
-```
+For now let's just accept that we have to create a `catalog` rule for our test
+suite and plug it into the `service_test` target.
 
-Note that the first argument to this particular overload of `BindInterface` is
-a string, but the more generalized form of `BindInterface` takes a
-`ServiceFilter`. See more about these in the section on
-[Service Filters](#Service-Filters).
+In practice, we typically try to avoid introducing new unittest binaries for
+individual services. Instead we have an aggregate `service_unittests` target
+defined in [`//services/BUILD.gn`](https://cs.chromium.org/chromium/bservices/BUILD.gn).
+There are several examples of other services adding their service tests to this
+suite.
 
-#### Registering Service Instances
+## Service Manager Catalogs
 
-One of the superpowers services can be granted is the ability to forcibly inject
-new service instances into the Service Manager's universe. This is done via
-[`Connector::ServiceInstance`](https://cs.chromium.org/chromium/bservices/service_manager/public/cpp/connector.h?rcl=ec509adfa3ac85fab3cd51422b8aaf9cbb6b43cb&l=108) and is still
-used pretty heavily by Chromium's browser process. Most services don't need to
-touch this API.
+A **catalog** is an aggregation of service manifests which comprises a complete
+runtime configuration of the Service Manager.
 
-#### Usage in Multithreaded Environments
+The GN `catalog` target template defined in
+[`//services/catalog/public/tools/catalog.gni`](https://cs.chromium.org/chromium/bservices/catalog/public/tools/catalog.gni).
+provides a simple means of aggregating service manifests into a single build
+artifact. See the comments on the template for detailed documentation.
 
-Connectors are **not** thread-safe, but they do support **cloning**. There are
-two useful ways you can associate a new Connector with an existing one on a
-different thread.
+This GNI also defines a `catalog_cpp_source` target which can generate a static
+C++ representation of an aggregated catalog manifest so that it can be passed
+the Service Manager at runtime.
 
-You can `Clone` the `Connector` on its own thread and then pass the clone to
-another thread:
+In general, service developers should never be concerned with creating new
+catalogs or instantiating the Service Manager, but it's important to be aware
+of these concepts. When introducing a new service into any runtime environment
+-- including Chrome, Content, or various unit test suites such as
+`service_unittests` discussed in the previous section -- your service manifest
+must be added to the catalog used in that environment.
 
-``` cpp
-std::unique_ptr<service_manager::Connector> new_connector = connector->Clone();
-base::PostTaskWithTraits(...[elsewhere]...,
-                         base::BindOnce(..., std::move(new_connector)));
-```
+TODO - expand on this
 
-Or you can fabricate a brand new `Connector` right from where you're standing,
-and asynchronously associate it with one on another thread:
+## Packaging Services
 
-``` cpp
-service_manager::mojom::ConnectorRequest request;
-std::unique_ptr<service_manager::Connector> new_connector =
-    service_manager::Connector::Create(&request);
-
-// |new_connector| can be used to start issuing calls immediately, despite not
-// yet being associated with the establshed Connector. The calls will queue as
-// long as necessary.
-
-base::PostTaskWithTraits(
-    ...[over to the correct thread]...,
-    base::BindOnce([](service_manager::ConnectorRequest request) {
-      service_manager::Connector* connector = GetMyConnectorForThisThread();
-      connector->BindConnectorRequest(std::move(request));
-    }));
-```
-
-### Identity
-
-Every service instance started by the Service Manager is assigned a globally
-unique (across space *and* time) identity, encapsulated by the
-[`Identity`](https://cs.chromium.org/chromium/bservices/service_manager/public/cpp/identity.h)
-type. This value is communicated to the service and retained and
-[exposed](https://cs.chromium.org/chromium/bservices/service_manager/public/cpp/service_binding.h?rcl=b8bc0ab281f2cb5cd567dc994692c6022845fb89&l=62)
-by `ServiceBinding` immediately before `Service::OnStart` is invoked.
-
-There are *four* components to an `Identity`:
-
-- Service name
-- Instance ID
-- Instance group ID
-- Globally unique ID
-
-You're already quite familiar with the **service name**: this is whatever the
-service declared in its manifest, *e.g.*, `"storage"`.
-
-#### Instance ID
-
-**Instance ID** is a `base::Token` qualifier which is simply used to
-differentiate multiple instances of the service if multiple instances are
-desired for whatever arbitrary reason. By default instances get an instance ID
-of zero when started unless a connecting client *explicitly* requests a specific
-instance ID. Doing so requires a special manifest-declared capability covered by
-[Additional Capabilities](#Additional-Capabilities).
-
-*** aside
-A good example of how instance ID can be useful: the `"unzip"` service in
-Chrome is used to safely unpack untrusted Chrome extensions (CRX) archives, but
-we don't want multiple extensions being unpacked by the same process. To support
-this, Chrome generates a random `base::Token` for the instance ID it uses when
-connecting to the `"unzip"` service, and this elicits the creation of a new
-service instance in a new isolated process for each such connection. See
-[Service Filters](#Service-Filters) for how this can be done.
-***
-
-#### Instance Group ID
-
-All created service instances implicitly belong to an **instance group**, which
-is also identified by a `base::Token`. Unless either specially privileged by
-[Additional Capabilities](#Additional-Capabilities), or the target service is
-a [singleton or shared across groups](#Instance-Sharing), the service sending out
-an interface request can only reach other service instances in the same instance
-group. See [Instance Groups](#Instance-Groups) for more information.
-
-#### Globally Unique ID
-
-Finally, the **globally unique ID** is a cryptographically secure, unguessably
-random `base::Token` value which can be considered unique across all time and
-space. This can never be controlled by an instance or even by a highly
-privileged service, and its sole purpose is to ensure that `Identity` itself
-can be treated as unique across time and space. See
-[Service Filters](#Service-Filters) and
-[Observing Service Instances](#Observing-Service-Instances) for why this
-property of uniqueness is useful and sometimes necessary.
-
-### Instance Sharing
-
-Assuming the Service Manager has decided to allow an interface request due to
-sufficient capability requirements, it must consider a number of factors to
-decide where exactly to route the request. The first factor is the **instance
-sharing policy** of the target service, declared in its manifest. There are
-three supported policies:
-
-- **No sharing** - This means the precise identity of the target instance
-  depends on both the instance ID provided by the request's `ServiceFilter`,
-  as well as the instance group either provided by the `ServiceFilter` or
-  inherited from the source instance's group.
-- **Shared across groups** - This means the precise identity of the target
-  instance still depends on the instance ID provided by the request's
-  `ServiceFilter`, but the instance group of both the `ServiceFilter` and the
-  source instance are completely ignored.
-- **Singleton** - This means there can be only one instance of the service at
-  a time, no matter what. Instance ID and group are always ignored when
-  connecting to the service.
-
-Based on one of the policies above, the Service Manager determines whether or
-not an existing service instance matches the parameters specified by the given
-`ServiceFilter` in conjunction with the source instance's own identity. If so,
-that Service Manager will forward the interface request to that instance via
-`Service::OnBindInterface`. Otherwise, it will spawn a new instance which
-sufficiently matches the constraints, and it will forward the request to that
-new instance.
-
-### Instance Groups
-
-Service instances are organized into **instance groups**. These are arbitrary
-partitions of instances which can be used by the host application to impose
-various kinds of security boundaries.
-
-Most services in the system do not have the privilege of specifying the
-instance group they want to connect into when passing a `ServiceFilter` to
-`Connector::BindInterface` (see
-[Additional Capabilities](#Additional-Capabilities)). As such, most
-`BindInterface` calls implicitly inherit the group ID of the caller and only
-cross outside of the caller's instance group when targeting a service which
-adopts either a singleton or shared-across-groups
-[sharing policy](#Instance-Sharing) in its manifest.
-
-Singleton and shared-across-groups services are themselves always run in their
-own isolated groups.
-
-### Service Filters
-
-The most common form of `BindInterface` calls passes a simple string as the
-first argument. This is essentially telling the Service Manager that the caller
-doesn't care about any details regarding the target instance's identity -- it
-only cares about talking to *some* instance of the named service.
-
-When a client *does* care about other details, they can explicitly construct and
-pass a `ServiceFilter` object, which essentially provides some subset of the
-desired target instance's total `Identity`.
-
-Specifying an instance group or instance ID in a `ServiceFilter` requires a
-service to declare [additional capabilities](#Additional-Capabilities) in its
-manifest options.
-
-A `ServiceFilter` can also wrap a complete `Identity` value, including the
-globally unique ID. This filter always *only* matches a specific instance unique
-in space and time. So if the identified instance has died and been replaced by
-a new instance with the same service name, same instance ID, and same instance
-group, the request will still *fail*, because the globally unique ID component
-will *never* match this or any future instance.
-
-One useful property of targeting a specific `Identity` is that the client can
-connect without any risk of eliciting new target instance creation: either
-the target exists and the request can be routed, or the target doesn't exist
-and the request will be dropped.
-
-### Additional Capabilities
-
-Service manifests can use `ManifestOptionsBuilder` to set a few additional
-boolean options controlling their Service Manager privileges:
-
-- `CanRegisterOtherServiceInstances` - If this is `true` the service can call
-  `RegisterServiceInstance` on its `Connector` to forcibly introduce new service
-  instances into the environment.
-- `CanConnectToInstancesWithAnyId` - If this is `true` the service can specify
-  an instance ID in any `ServiceFilter` it passes to `BindInterface`.
-- `CanConnectToInstancesInAnyGroup` - If this is `true` the service can specify
-  an instance group ID in any `ServiceFilter` it passes to `BindInterface`.
-
-### Packaging
-
-A service can declare that it **packages** another service by
-[nesting](https://cs.chromium.org/chromium/bservices/service_manager/public/cpp/manifest_builder.h?rcl=7839843db1ccdf13c3f1b8cb90a763989dde83a8&l=87) that
-service's manifest within its own.
-
-This signals to the Service Manager that it should defer to the packaging
-service when it needs a new instance of the packaged service. For example, if
-we offered up the manifest:
+TODO
 
-``` cpp
-    service_manager::ManifestBuilder()
-        .WithServiceName("fruit_vendor")
-        ...
-        .PackageService(service_manager::ManifestBuilder()
-                            .WithServiceName("banana_stand")
-                            .Build())
-        .Build()
-```
-
-And someone wanted to connect to a new instance of the `"banana_stand"` service
-(there's always money in the banana stand), the Service Manager would ask an
-appropriate `"fruit_vendor"` instance to do this on its behalf.
-
-*** aside
-NOTE: If an appropriate instance of `"fruit_vendor"` wasn't already running --
-as determined by the rules described in [Instance Sharing](#Instance-Sharing)
-above -- one would first be spawned by the Service Manager.
-***
-
-In order to support this operation, the `fruit_vendor` must expose a capability
-named exactly `"service_manager:service_factory"` which includes the
-`"service_manager.mojom.ServiceFactory"` interface. Then it must handle requests
-for the `service_manager.mojom.ServiceFactory` interface in its implementation
-of `Service::OnBindInterface`. The implementation of `ServiceFactory` provided
-by the service must then handle the `CreateService` that will be sent by
-the Service Manager. This call will include the name of the service and the
-`ServiceRequest` the new service instance will need to bind.
-
-*** aside
-NOTE: It is this complicated for historical reasons. Expect it to be less
-complicated soon.
-***
-
-Services can use this for example if, in certain runtime environments, they want
-to share their process with another service.
-
-*** aside
-FUN FACT: This is actually how Chromium manages *all* services today, because
-the Content layer still owns much of the production-ready process launching
-logic. We have a singleton `content_packaged_services` service which packages
-nearly all other registered services in the system, and so the Service Manager
-defers (via `ServiceFactory`) nearly all service instance creation operations
-to Content.
-***
-
-### Sandbox Configurations
-
-Service manifests support specifying a fixed sandbox configuration for the
-service to be launched with when run out-of-process. Currently these values
-are strings which must match one of the defined constants
-[here](https://cs.chromium.org/chromium/bservices/service_manager/sandbox/switches.cc?rcl=2e6a3bddac0aff89c5ff415e9c1cd4da804280ef&l=23).
-
-The most common and default value is `"utility"`, which is a restrictive sandbox
-configuration and generally a safe choice. For services which must run
-unsandboxed, use the value `"none"`. Use of other sandbox configurations should
-be done under the advisory of Chrome's security reviewers.
-
-### Observing Service Instances
-
-Services which require the `"service_manager:service_manager`" capability from
-the `"service_manager"` service can connect to the `"service_manager"` service
-to request a
-[`ServiceManager`](https://cs.chromium.org/chromium/bservices/service_manager/public/mojom/service_manager.mojom?rcl=765c18ee7c317535594ba37520a23c11f0cef008&l=82)
-interface. This can in turn be used to register a new
-[`ServiceManagerListener`](https://cs.chromium.org/chromium/bservices/service_manager/public/mojom/service_manager.mojom?rcl=765c18ee7c317535594ba37520a23c11f0cef008&l=44) to
-observe lifecycle events pertaining to all service instances hosted by the
-Service Manager.
-
-There are several
-[examples](https://cs.chromium.org/search/?q=mojo::Binding%3Cservice_manager::mojom::ServiceManagerListener%3E&type=cs)
-of this throughout the tree.
-
-## Additional Support
-
-If this document was not helpful in some way, please post a message to your
-friendly
-[services-dev@chromium.org](https://groups.google.com/a/chromium.org/forum/#!forum/services-dev)
-mailing list.
+## Chrome and Chrome OS Service Manager Integration
 
-Also don't forget to take a look at other
-[Mojo &amp; Services](/docs/README.md#Mojo-Services) documentation in the tree.
+TODO
--- a/services/service_manager/sandbox/fuchsia/sandbox_policy_fuchsia.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/service_manager/sandbox/fuchsia/sandbox_policy_fuchsia.cc	2019-05-17 18:53:37.984000000 +0300
@@ -18,8 +18,8 @@
 #include "base/command_line.h"
 #include "base/containers/span.h"
 #include "base/files/file_util.h"
+#include "base/fuchsia/component_context.h"
 #include "base/fuchsia/filtered_service_directory.h"
-#include "base/fuchsia/service_directory_client.h"
 #include "base/path_service.h"
 #include "base/process/launch.h"
 #include "base/process/process.h"
@@ -121,23 +121,24 @@
     service_directory_task_runner_ = base::ThreadTaskRunnerHandle::Get();
     service_directory_ =
         std::make_unique<base::fuchsia::FilteredServiceDirectory>(
-            base::fuchsia::ServiceDirectoryClient::ForCurrentProcess());
+            base::fuchsia::ComponentContext::GetDefault());
     for (const char* service_name : config.services)
       service_directory_->AddService(service_name);
 
     // Bind the service directory and store the client channel for
     // UpdateLaunchOptionsForSandbox()'s use.
-    service_directory_client_ = service_directory_->ConnectClient();
-    CHECK(service_directory_client_);
+    service_directory_client_channel_ = service_directory_->ConnectClient();
+    CHECK(service_directory_client_channel_);
   }
 }
 
 void SandboxPolicyFuchsia::SetServiceDirectory(
-    fidl::InterfaceHandle<::fuchsia::io::Directory> service_directory_client) {
+    zx::channel service_directory_client_channel) {
   DCHECK_EQ(type_, SANDBOX_TYPE_WEB_CONTEXT);
-  DCHECK(!service_directory_client_);
+  DCHECK(!service_directory_client_channel_);
 
-  service_directory_client_ = std::move(service_directory_client);
+  service_directory_client_channel_ =
+      std::move(service_directory_client_channel);
 }
 
 void SandboxPolicyFuchsia::UpdateLaunchOptionsForSandbox(
@@ -184,12 +185,10 @@
       options->paths_to_clone.push_back(vulkan_icd_path);
   }
 
-  // If the process needs access to any services then transfer the
-  // |service_directory_client_| handle for it to mount at "/svc".
-  if (service_directory_client_) {
+  if (service_directory_client_channel_) {
+    // Provide the child process with a restricted set of services.
     options->paths_to_transfer.push_back(base::PathToTransfer{
-        base::FilePath("/svc"),
-        service_directory_client_.TakeChannel().release()});
+        base::FilePath("/svc"), service_directory_client_channel_.release()});
   }
 }
 
--- a/services/service_manager/sandbox/fuchsia/sandbox_policy_fuchsia.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/service_manager/sandbox/fuchsia/sandbox_policy_fuchsia.h	2019-05-17 18:53:37.984000000 +0300
@@ -5,8 +5,7 @@
 #ifndef SERVICES_SERVICE_MANAGER_SANDBOX_FUCHSIA_SANDBOX_POLICY_FUCHSIA_H_
 #define SERVICES_SERVICE_MANAGER_SANDBOX_FUCHSIA_SANDBOX_POLICY_FUCHSIA_H_
 
-#include <fuchsia/io/cpp/fidl.h>
-#include <lib/fidl/cpp/interface_handle.h>
+#include <lib/zx/channel.h>
 
 #include "base/memory/ref_counted.h"
 #include "services/service_manager/sandbox/export.h"
@@ -33,11 +32,9 @@
   // IO thread.
   void Initialize(service_manager::SandboxType type);
 
-  // Sets the service directory to pass to the child process when launching it.
-  // This is only supported for SANDBOX_TYPE_WEB_CONTEXT processes.  If this is
-  // not called for a WEB_CONTEXT process then it will receive no services.
-  void SetServiceDirectory(
-      fidl::InterfaceHandle<::fuchsia::io::Directory> service_directory_client);
+  // Sets the service directory that's passed to the child process as /svc. Must
+  // be used only for the web context process.
+  void SetServiceDirectory(zx::channel service_directory_client_channel);
 
   // Modifies the process launch |options| to achieve  the level of
   // isolation appropriate for current the sandbox type. The caller may then add
@@ -50,7 +47,7 @@
 
   // Services directory used for the /svc namespace of the child process.
   std::unique_ptr<base::fuchsia::FilteredServiceDirectory> service_directory_;
-  fidl::InterfaceHandle<::fuchsia::io::Directory> service_directory_client_;
+  zx::channel service_directory_client_channel_;
   scoped_refptr<base::SequencedTaskRunner> service_directory_task_runner_;
 
   DISALLOW_COPY_AND_ASSIGN(SandboxPolicyFuchsia);
--- a/services/service_manager/sandbox/linux/bpf_audio_policy_linux.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/service_manager/sandbox/linux/bpf_audio_policy_linux.cc	2019-05-17 18:53:37.984000000 +0300
@@ -7,10 +7,8 @@
 #include <sys/socket.h>
 
 #include "sandbox/linux/bpf_dsl/bpf_dsl.h"
-#include "sandbox/linux/seccomp-bpf-helpers/sigsys_handlers.h"
 #include "sandbox/linux/seccomp-bpf-helpers/syscall_parameters_restrictions.h"
 #include "sandbox/linux/seccomp-bpf-helpers/syscall_sets.h"
-#include "sandbox/linux/services/syscall_wrappers.h"
 #include "sandbox/linux/syscall_broker/broker_process.h"
 #include "sandbox/linux/system_headers/linux_futex.h"
 #include "sandbox/linux/system_headers/linux_syscalls.h"
@@ -90,23 +88,6 @@
 #endif
     }
 #endif
-#if defined(__NR_kill)
-    case __NR_kill: {
-      // man kill says:
-      // "If sig is 0, then no signal is sent, but existence and permission
-      //  checks are still performed; this can be used to check for the
-      //  existence of a process ID or process group ID that the caller is
-      //  permitted to signal."
-      //
-      // This seems to be tripping up at least ESET's NOD32 anti-virus, causing
-      // an unnecessary crash in the audio process. See: http://crbug.com/904787
-      const Arg<pid_t> pid(0);
-      const Arg<int> sig(1);
-      return If(pid == sandbox::sys_getpid(), Allow())
-          .ElseIf(sig == 0, Error(EPERM))
-          .Else(sandbox::CrashSIGSYSKill());
-    }
-#endif
 #if defined(__NR_socket)
     case __NR_socket: {
       const Arg<int> domain(0);
--- a/services/service_manager/sandbox/linux/bpf_gpu_policy_linux.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/service_manager/sandbox/linux/bpf_gpu_policy_linux.cc	2019-05-17 18:53:37.988000000 +0300
@@ -58,8 +58,6 @@
     case __NR_sched_getaffinity:
     case __NR_sched_setaffinity:
       return sandbox::RestrictSchedTarget(GetPolicyPid(), sysno);
-    case __NR_prlimit64:
-      return sandbox::RestrictPrlimit64(GetPolicyPid());
     default:
       if (SyscallSets::IsEventFd(sysno))
         return Allow();
--- a/services/service_manager/sandbox/linux/sandbox_linux.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/service_manager/sandbox/linux/sandbox_linux.cc	2019-05-17 18:53:37.988000000 +0300
@@ -21,6 +21,7 @@
 #include "base/bind.h"
 #include "base/callback_helpers.h"
 #include "base/command_line.h"
+#include "base/debug/stack_trace.h"
 #include "base/feature_list.h"
 #include "base/files/scoped_file.h"
 #include "base/logging.h"
@@ -106,15 +107,10 @@
   base::CommandLine::ForCurrentProcess()->InitFromArgv(exec);
 
   base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();
-  std::string new_process_type =
-      command_line->GetSwitchValueASCII(switches::kProcessType);
-  if (!new_process_type.empty()) {
-    new_process_type.append("-broker");
-  } else {
-    new_process_type = "broker";
-  }
-
-  command_line->AppendSwitchASCII(switches::kProcessType, new_process_type);
+  command_line->AppendSwitchASCII(
+      switches::kProcessType,
+      command_line->GetSwitchValueASCII(switches::kProcessType)
+          .append("-broker"));
 
   if (broker_side_hook)
     CHECK(std::move(broker_side_hook).Run(options));
--- a/services/service_manager/sandbox/linux/sandbox_linux.h	2019-05-17 17:45:42.572000000 +0300
+++ b/services/service_manager/sandbox/linux/sandbox_linux.h	2019-05-17 18:53:37.988000000 +0300
@@ -52,7 +52,7 @@
  public:
   // This is a list of sandbox IPC methods which the renderer may send to the
   // sandbox host. See
-  // https://chromium.9oo91esource.qjz9zk/chromium/b+/master/docs/linux_sandbox_ipc.md
+  // https://chromium.googlesource.com/chromium/b+/master/docs/linux_sandbox_ipc.md
   // This isn't the full list, values < 32 are reserved for methods called from
   // Skia, and values < 64 are reserved for libc_interceptor.cc.
   enum LinuxSandboxIPCMethods {
@@ -198,7 +198,7 @@
 #if BUILDFLAG(USING_SANITIZER)
   __sanitizer_sandbox_arguments* sanitizer_args() const {
     return sanitizer_args_.get();
-  }
+  };
 #endif
 
   // A BrokerProcess is a helper that is started before the sandbox is engaged,
--- a/services/service_manager/sandbox/mac/common.sb	2019-05-01 01:22:56.000000000 +0300
+++ b/services/service_manager/sandbox/mac/common.sb	2019-05-17 18:53:37.988000000 +0300
@@ -68,13 +68,10 @@
 ; https://crbug.com/850021
 (define (allow-cvms-blobs)
   (if (>= os-version 1014)
-    (begin
-      (allow file-read* file-write-unlink
-        (prefix "/private/tmp/cvmsCodeSignObj"))
       (allow file-read*
         (extension "com.apple.cvms.kernel")
-        (prefix "/private/var/db/CVMS/cvmsCodeSignObj"))
-)))
+      (subpath "/private/var/db/CVMS")
+    )))
 
 ; Allow logging for all processes.
 (allow file-write*
@@ -97,7 +94,7 @@
                               (param browser-pid))))
 
 (allow mach-lookup
-  (browser-service-name "MachPortRendezvousServer")
+  (browser-service-name "FieldTrialMemoryServer")
   (browser-service-name "rohitfork")
 )
 
@@ -194,8 +191,3 @@
   (sysctl-name "sysctl.proc_cputype")
   (sysctl-name (string-append "kern.proc.pid." (param current-pid)))
 )
-
-(allow network-outbound
-  (literal "/private/var/run/asl_input")
-  (literal "/private/var/run/syslog")
-)
--- a/services/service_manager/sandbox/mac/gpu_v2.sb	2019-05-01 01:22:56.000000000 +0300
+++ b/services/service_manager/sandbox/mac/gpu_v2.sb	2019-05-17 18:53:37.988000000 +0300
@@ -14,7 +14,6 @@
   (global-name "com.apple.CoreServices.coreservicesd")
   (global-name "com.apple.coreservices.launchservicesd")
   (global-name "com.apple.cvmsServ")
-  (global-name "com.apple.gpumemd.source")
   (global-name "com.apple.system.notification_center")
   (global-name "com.apple.tsm.uiserver")
   (global-name "com.apple.windowserver.active")
@@ -25,10 +24,7 @@
   (iokit-connection "IOAccelerator")
   (iokit-user-client-class "AGPMClient")
   (iokit-user-client-class "AppleGraphicsControlClient")
-  (iokit-user-client-class "AppleGraphicsPolicyClient")
-  (iokit-user-client-class "AppleIntelMEUserClient")
   (iokit-user-client-class "AppleMGPUPowerControlClient")
-  (iokit-user-client-class "AppleSNBFBUserClient")
   (iokit-user-client-class "IOAccelerationUserClient")
   (iokit-user-client-class "IOFramebufferSharedUserClient")
   (iokit-user-client-class "IOHIDParamUserClient")
@@ -37,16 +33,6 @@
   (iokit-user-client-class "RootDomainUserClient")
 )
 
-(allow iokit-set-properties
-  (require-all (iokit-connection "IODisplay")
-    (require-any (iokit-property "brightness")
-      (iokit-property "linear-brightness")
-      (iokit-property "commit")
-      (iokit-property "rgcs")
-      (iokit-property "ggcs")
-      (iokit-property "bgcs")
-)))
-
 (allow ipc-posix-shm-read-data
   (ipc-posix-name "apple.shm.notification_center"))
 
@@ -56,22 +42,14 @@
 
 ; Needed for VideoToolbox usage - https://crbug.com/767037
 (if (>= os-version 1013)
-  (allow mach-lookup
-    (xpc-service-name "com.apple.coremedia.videodecoder")
-    (xpc-service-name "com.apple.coremedia.videoencoder")
-    (xpc-service-name-regex #"\.apple-extension-service$")
-))
+  (allow mach-lookup (global-name "com.apple.coremedia.videodecoder"))
+  (allow mach-lookup (global-name "com.apple.coremedia.videoencoder"))
+)
 
 (allow sysctl-read
   (sysctl-name "hw.logicalcpu_max")
   (sysctl-name "hw.model")
-  (sysctl-name "kern.osvariant_status")
 )
 
 (allow file-read-data
-  (regex (user-homedir-path #"/Library/Preferences/ByHost/com.apple.AppleGVA.*"))
-)
-
-(allow file-read*
-  (subpath "/Library/GPUBundles")
-)
+  (regex (user-homedir-path #"/Library/Preferences/ByHost/com.apple.AppleGVA.*")))
--- a/services/service_manager/sandbox/mac/sandbox_mac.mm	2019-05-01 01:22:56.000000000 +0300
+++ b/services/service_manager/sandbox/mac/sandbox_mac.mm	2019-05-17 18:53:37.988000000 +0300
@@ -24,10 +24,10 @@
 #include "base/mac/bundle_locations.h"
 #include "base/mac/foundation_util.h"
 #include "base/mac/mac_util.h"
-#include "base/mac/mach_port_rendezvous.h"
 #include "base/mac/scoped_cftyperef.h"
 #include "base/mac/scoped_nsautorelease_pool.h"
 #include "base/mac/scoped_nsobject.h"
+#include "base/metrics/field_trial_memory_mac.h"
 #include "base/rand_util.h"
 #include "base/stl_util.h"
 #include "base/strings/string16.h"
@@ -173,7 +173,7 @@
 
   if (!compiler.InsertStringParam(
           kSandboxFieldTrialSeverName,
-          base::MachPortRendezvousClient::GetBootstrapName())) {
+          base::FieldTrialMemoryClient::GetBootstrapName())) {
     return false;
   }
 
--- a/services/service_manager/sandbox/win/sandbox_win.cc	2019-05-17 17:45:42.576000000 +0300
+++ b/services/service_manager/sandbox/win/sandbox_win.cc	2019-05-17 18:53:37.992000000 +0300
@@ -62,7 +62,7 @@
 // versions of the dll name only if the dll has an extension.
 // For more information about how this list is generated, and how to get off
 // of it, see:
-// https://sites.9oo91e.qjz9zk/a/ch40m1um.qjz9zk/dev/Home/third-party-developers
+// https://sites.google.com/a/chromium.org/dev/Home/third-party-developers
 const wchar_t* const kTroublesomeDlls[] = {
     L"adialhk.dll",                // Kaspersky Internet Security.
     L"acpiz.dll",                  // Unknown.
@@ -293,7 +293,7 @@
   // Chrome in remote sessions we do this check explicitly here.
   // According to MS this flag can be false for a remote session only on Windows
   // Server 2012 and newer so if we do the check last we should be on the safe
-  // side. See: https://msdn.m1cr050ft.qjz9zk/en-us/library/aa380798.aspx.
+  // side. See: https://msdn.microsoft.com/en-us/library/aa380798.aspx.
   if (!::GetSystemMetrics(SM_REMOTESESSION)) {
     // Measure how often we would have decided to apply the sandbox but the
     // user actually wanted to avoid it.
@@ -465,7 +465,7 @@
 
 static const char* kDuplicateHandleWarning =
     "You are attempting to duplicate a privileged handle into a sandboxed"
-    " process.\n Please contact security@ch40m1um.qjz9zk for assistance.";
+    " process.\n Please contact security@chromium.org for assistance.";
 
 void CheckDuplicateHandle(HANDLE handle) {
   // Get the object type (32 characters is safe; current max is 14).
@@ -952,7 +952,7 @@
   if (process_type != service_manager::switches::kRendererProcess) {
     // Hack for Google Desktop crash. Trick GD into not injecting its DLL into
     // this subprocess. See
-    // http://code.9oo91e.qjz9zk/p/chromium/issues/detail?id=25580
+    // http://code.google.com/p/chromium/issues/detail?id=25580
     cmd_line->AppendSwitchASCII("ignored", " --type=renderer ");
   }
 
--- a/services/service_manager/service_manager.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/service_manager/service_manager.cc	2019-05-17 18:53:37.992000000 +0300
@@ -7,20 +7,16 @@
 #include <stdint.h>
 
 #include <algorithm>
-#include <set>
-#include <string>
+#include <tuple>
 #include <utility>
 
-#include "base/base_paths.h"
 #include "base/bind.h"
 #include "base/command_line.h"
-#include "base/files/file_path.h"
 #include "base/logging.h"
 #include "base/macros.h"
 #include "base/memory/ptr_util.h"
 #include "base/no_destructor.h"
 #include "base/optional.h"
-#include "base/path_service.h"
 #include "base/process/process.h"
 #include "base/process/process_handle.h"
 #include "base/stl_util.h"
@@ -32,9 +28,11 @@
 #include "mojo/public/cpp/bindings/binding.h"
 #include "mojo/public/cpp/bindings/binding_set.h"
 #include "mojo/public/cpp/bindings/strong_binding.h"
+#include "services/catalog/entry.h"
+#include "services/catalog/instance.h"
+#include "services/catalog/public/mojom/constants.mojom.h"
 #include "services/service_manager/public/cpp/connector.h"
 #include "services/service_manager/public/cpp/constants.h"
-#include "services/service_manager/public/cpp/manifest_builder.h"
 #include "services/service_manager/public/cpp/service.h"
 #include "services/service_manager/public/mojom/connector.mojom.h"
 #include "services/service_manager/public/mojom/service.mojom.h"
@@ -43,7 +41,7 @@
 #include "services/service_manager/sandbox/sandbox_type.h"
 
 #if !defined(OS_IOS)
-#include "services/service_manager/service_process_launcher.h"
+#include "services/service_manager/runner/host/service_process_launcher.h"
 #endif
 
 namespace service_manager {
@@ -52,28 +50,21 @@
 
 const char kCapability_ServiceManager[] = "service_manager:service_manager";
 
-#if defined(OS_WIN)
-const char kServiceExecutableExtension[] = ".service.exe";
-#else
-const char kServiceExecutableExtension[] = ".service";
-#endif
-
-// Returns the set of capabilities required from the target by the source.
-std::set<std::string> GetRequiredCapabilities(
-    const Manifest::RequiredCapabilityMap& source_requirements,
-    const std::string& target_service) {
-  std::set<std::string> capabilities;
-
-  // Start by looking for requirements specific to the target identity.
-  auto it = source_requirements.find(target_service);
-  if (it != source_requirements.end()) {
+// Returns the set of capabilities required from the target.
+CapabilitySet GetRequestedCapabilities(const InterfaceProviderSpec& source_spec,
+                                       const Identity& target) {
+  CapabilitySet capabilities;
+
+  // Start by looking for specs specific to the supplied identity.
+  auto it = source_spec.requires.find(target.name());
+  if (it != source_spec.requires.end()) {
     std::copy(it->second.begin(), it->second.end(),
               std::inserter(capabilities, capabilities.begin()));
   }
 
   // Apply wild card rules too.
-  it = source_requirements.find("*");
-  if (it != source_requirements.end()) {
+  it = source_spec.requires.find("*");
+  if (it != source_spec.requires.end()) {
     std::copy(it->second.begin(), it->second.end(),
               std::inserter(capabilities, capabilities.begin()));
   }
@@ -89,8 +80,39 @@
 #endif
 }
 
-void ReportBlockedInterface(const Manifest::ServiceName& source_service_name,
-                            const Manifest::ServiceName& target_service_name,
+// Generates a single set of interfaces that is the union of all interfaces
+// exposed by the target for the capabilities requested by the source.
+InterfaceSet GetInterfacesToExpose(const InterfaceProviderSpec& source_spec,
+                                   const Identity& target,
+                                   const InterfaceProviderSpec& target_spec) {
+  DCHECK(target.IsValid());
+  InterfaceSet exposed_interfaces;
+  CapabilitySet capabilities = GetRequestedCapabilities(source_spec, target);
+  for (const auto& capability : capabilities) {
+    auto it = target_spec.provides.find(capability);
+    if (it != target_spec.provides.end()) {
+      for (const auto& interface_name : it->second)
+        exposed_interfaces.insert(interface_name);
+    }
+  }
+  return exposed_interfaces;
+}
+
+const InterfaceProviderSpec& GetEmptyInterfaceProviderSpec() {
+  static base::NoDestructor<InterfaceProviderSpec> spec;
+  return *spec;
+}
+
+bool HasCapability(const InterfaceProviderSpec& spec,
+                   const std::string& capability) {
+  auto it = spec.requires.find(service_manager::mojom::kServiceName);
+  if (it == spec.requires.end())
+    return false;
+  return it->second.find(capability) != it->second.end();
+}
+
+void ReportBlockedInterface(const std::string& source_service_name,
+                            const std::string& target_service_name,
                             const std::string& target_interface_name) {
 #if DCHECK_IS_ON()
   // While it would not be correct to assert that this never happens (e.g. a
@@ -126,26 +148,22 @@
       << "services' manifests in order to remedy this situation.";
 }
 
-bool AllowsInterface(const Manifest::RequiredCapabilityMap& source_requirements,
-                     const std::string& target_name,
-                     const Manifest::ExposedCapabilityMap& target_capabilities,
+bool AllowsInterface(const Identity& source,
+                     const InterfaceProviderSpec& source_spec,
+                     const Identity& target,
+                     const InterfaceProviderSpec& target_spec,
                      const std::string& interface_name) {
-  std::set<std::string> allowed_interfaces;
-  std::set<std::string> required_capabilities =
-      GetRequiredCapabilities(source_requirements, target_name);
-  for (const auto& capability : required_capabilities) {
-    auto it = target_capabilities.find(capability);
-    if (it != target_capabilities.end()) {
-      for (const auto& interface_name : it->second)
-        allowed_interfaces.insert(interface_name);
-    }
-  }
-
-  bool allowed =
-      allowed_interfaces.count("*") || allowed_interfaces.count(interface_name);
+  InterfaceSet exposed =
+      GetInterfacesToExpose(source_spec, target, target_spec);
+  bool allowed = (exposed.size() == 1 && exposed.count("*") == 1) ||
+                 exposed.count(interface_name) > 0;
+  if (!allowed)
+    ReportBlockedInterface(source.name(), target.name(), interface_name);
   return allowed;
 }
 
+}  // namespace
+
 const Identity& GetServiceManagerInstanceIdentity() {
   static base::NoDestructor<Identity> id{service_manager::mojom::kServiceName,
                                          kSystemInstanceGroup, base::Token{},
@@ -153,30 +171,32 @@
   return *id;
 }
 
-}  // namespace
-
 // Encapsulates a connection to an instance of a service, tracked by the
 // Service Manager.
 class ServiceManager::Instance
     : public mojom::Connector,
       public mojom::PIDReceiver,
+      public Service,
       public mojom::ServiceManager,
       public mojom::ServiceControl {
  public:
   Instance(service_manager::ServiceManager* service_manager,
            const Identity& identity,
-           const Manifest& manifest)
+           const InterfaceProviderSpecMap& interface_provider_specs,
+           const catalog::ServiceOptions& options)
       : service_manager_(service_manager),
         identity_(identity),
-        manifest_(manifest),
-        can_contact_all_services_(manifest_.required_capabilities.count("*") ==
-                                  1),
+        interface_provider_specs_(interface_provider_specs),
+        options_(options),
+        allow_any_application_(GetConnectionSpec().requires.count("*") == 1),
         pid_receiver_binding_(this),
         control_binding_(this),
         state_(mojom::InstanceState::kCreated),
         weak_factory_(this) {
-    if (identity_.name() == service_manager::mojom::kServiceName)
+    if (identity_.name() == service_manager::mojom::kServiceName ||
+        identity_.name() == catalog::mojom::kServiceName) {
       pid_ = GetCurrentPid();
+    }
     DCHECK(identity_.IsValid());
   }
 
@@ -218,41 +238,32 @@
     }
 
     std::unique_ptr<ConnectParams> params(std::move(*in_params));
+
     Instance* source =
         service_manager_->GetExistingInstance(params->source());
     if (!source)
       return false;
 
-    const Manifest& source_manifest = source->manifest();
+    const InterfaceProviderSpec& source_spec = source->GetConnectionSpec();
     bool bindable_on_any_service =
-        source->manifest_.interfaces_bindable_on_any_service.count(
+        source->options_.interfaces_bindable_on_any_service.count(
             params->interface_name()) > 0;
-    bool allowed_by_capabilities = AllowsInterface(
-        source_manifest.required_capabilities, identity_.name(),
-        manifest_.exposed_capabilities, params->interface_name());
-    if (!bindable_on_any_service && !allowed_by_capabilities) {
-      ReportBlockedInterface(params->source().name(), identity_.name(),
-                             params->interface_name());
+
+    if (!bindable_on_any_service &&
+        !AllowsInterface(params->source(), source_spec, identity_,
+                         GetConnectionSpec(), params->interface_name())) {
       params->set_response_data(mojom::ConnectResult::ACCESS_DENIED, identity_);
       return false;
     }
 
     params->set_response_data(mojom::ConnectResult::SUCCEEDED, identity_);
 
-    base::OnceClosure on_bind_interface_complete;
-    if (params->priority() == mojom::BindInterfacePriority::kImportant) {
       pending_service_connections_++;
-      on_bind_interface_complete =
-          base::BindOnce(&Instance::OnConnectComplete, base::Unretained(this));
-    }
-
     service_->OnBindInterface(
-        BindSourceInfo(
-            params->source(),
-            GetRequiredCapabilities(source_manifest.required_capabilities,
-                                    identity_.name())),
+        BindSourceInfo(params->source(),
+                       GetRequestedCapabilities(source_spec, identity_)),
         params->interface_name(), params->TakeInterfaceRequestPipe(),
-        std::move(on_bind_interface_complete));
+        base::BindOnce(&Instance::OnConnectComplete, base::Unretained(this)));
     return true;
   }
 
@@ -305,7 +316,19 @@
     return info;
   }
 
-  const Manifest& manifest() const { return manifest_; }
+  const InterfaceProviderSpec& GetConnectionSpec() const {
+    return GetSpec(mojom::kServiceManager_ConnectorSpec);
+  }
+  bool HasSpec(const std::string& spec) const {
+    auto it = interface_provider_specs_.find(spec);
+    return it != interface_provider_specs_.end();
+  }
+  const InterfaceProviderSpec& GetSpec(const std::string& spec) const {
+    auto it = interface_provider_specs_.find(spec);
+    return it != interface_provider_specs_.end()
+               ? it->second
+               : GetEmptyInterfaceProviderSpec();
+  }
 
   const Identity& identity() const { return identity_; }
 
@@ -314,22 +337,34 @@
     identity_ = identity;
   }
 
-  void BindServiceManager(mojom::ServiceManagerRequest request) {
+  // Service:
+  void OnBindInterface(const BindSourceInfo& source_info,
+                       const std::string& interface_name,
+                       mojo::ScopedMessagePipeHandle interface_pipe) override {
+    Instance* source =
+        service_manager_->GetExistingInstance(source_info.identity);
+    DCHECK(source);
+    if (interface_name == mojom::ServiceManager::Name_ &&
+        HasCapability(source->GetConnectionSpec(),
+                      kCapability_ServiceManager)) {
+      mojom::ServiceManagerRequest request =
+          mojom::ServiceManagerRequest(std::move(interface_pipe));
     service_manager_bindings_.AddBinding(this, std::move(request));
   }
+  }
 
  private:
   class InterfaceProviderImpl : public mojom::InterfaceProvider {
    public:
     InterfaceProviderImpl(Instance* instance,
-                          const std::string& filter_name,
+                          const std::string& spec,
                           const Identity& source_identity,
                           const Identity& target_identity,
                           service_manager::ServiceManager* service_manager,
                           mojom::InterfaceProviderPtr target,
                           mojom::InterfaceProviderRequest source_request)
         : instance_(instance),
-          filter_name_(filter_name),
+          spec_(spec),
           source_identity_(source_identity),
           target_identity_(target_identity),
           service_manager_(service_manager),
@@ -355,35 +390,23 @@
           service_manager_->GetExistingInstance(target_identity_);
       if (!source || !target)
         return;
-
-      const auto& source_filters =
-          source->manifest().required_interface_filter_capabilities;
-      const auto& target_filters =
-          target->manifest().exposed_interface_filter_capabilities;
-
-      auto source_iter = source_filters.find(filter_name_);
-      if (source_iter == source_filters.end()) {
-        DLOG(ERROR) << source_identity_.name() << " does not specify any "
-                    << "requirements for a filter named '" << filter_name_
-                    << "'";
+      if (!ValidateSpec(source) || !ValidateSpec(target))
         return;
-      }
 
-      auto target_iter = target_filters.find(filter_name_);
-      if (target_iter == target_filters.end()) {
-        DLOG(ERROR) << target_identity_.name() << " does not expose any "
-                    << "capabilities for a filter named '" << filter_name_
-                    << "'";
-        return;
+      if (AllowsInterface(source_identity_, source->GetSpec(spec_),
+                          target_identity_, target->GetSpec(spec_),
+                          interface_name)) {
+        target_->GetInterface(interface_name, std::move(interface_pipe));
+      }
       }
 
-      if (AllowsInterface(source_iter->second, target_identity_.name(),
-                          target_iter->second, interface_name)) {
-        target_->GetInterface(interface_name, std::move(interface_pipe));
-      } else {
-        ReportBlockedInterface(source_identity_.name(), target_identity_.name(),
-                               interface_name);
+    bool ValidateSpec(Instance* instance) const {
+      if (!instance->HasSpec(spec_)) {
+        LOG(ERROR) << "Instance for: " << instance->identity().name()
+                   << " did not have spec named: " << spec_;
+        return false;
       }
+      return true;
     }
 
     void OnConnectionError() {
@@ -392,7 +415,7 @@
     }
 
     Instance* const instance_;
-    const std::string filter_name_;
+    const std::string spec_;
     const Identity source_identity_;
     const Identity target_identity_;
     const service_manager::ServiceManager* service_manager_;
@@ -422,7 +445,6 @@
   void BindInterface(const service_manager::ServiceFilter& target_filter,
                      const std::string& interface_name,
                      mojo::ScopedMessagePipeHandle interface_pipe,
-                     mojom::BindInterfacePriority priority,
                      BindInterfaceCallback callback) override {
     mojom::ConnectResult result =
         ValidateConnectParams(target_filter, interface_name);
@@ -436,7 +458,6 @@
     params->set_target(target_filter);
     params->set_interface_request_info(interface_name,
                                        std::move(interface_pipe));
-    params->set_priority(priority);
     params->set_connection_callback(std::move(callback));
     service_manager_->Connect(std::move(params));
   }
@@ -478,7 +499,7 @@
     mojom::ServicePtr service(
         mojom::ServicePtrInfo(std::move(service_handle), 0));
 
-    if (!manifest_.options.can_register_other_service_instances) {
+    if (!options_.can_create_other_service_instances) {
       LOG(ERROR) << "Instance: " << identity_.name() << " attempting "
                  << "to register an instance for a process it created for "
                  << "target: " << identity.name() << " without "
@@ -520,13 +541,13 @@
     connectors_.AddBinding(this, std::move(request));
   }
 
-  void FilterInterfaces(const std::string& filter_name,
+  void FilterInterfaces(const std::string& spec,
                         const Identity& source,
                         mojom::InterfaceProviderRequest source_request,
                         mojom::InterfaceProviderPtr target) override {
     auto* filter = new InterfaceProviderImpl(
-        this, filter_name, source, identity_, service_manager_,
-        std::move(target), std::move(source_request));
+        this, spec, source, identity_, service_manager_, std::move(target),
+        std::move(source_request));
     filters_[filter] = base::WrapUnique(filter);
   }
 
@@ -550,12 +571,18 @@
       return mojom::ConnectResult::INVALID_ARGUMENT;
     }
 
+    const InterfaceProviderSpec& connection_spec = GetConnectionSpec();
+
+    // TODO(beng): Need to do the following additional policy validation of
+    // whether this instance is allowed to connect using:
+    // - non-null client process info.
     bool skip_instance_group_check =
-        manifest_.options.instance_sharing_policy ==
-            Manifest::InstanceSharingPolicy::kSingleton ||
-        manifest_.options.instance_sharing_policy ==
-            Manifest::InstanceSharingPolicy::kSharedAcrossGroups ||
-        manifest_.options.can_connect_to_instances_in_any_group;
+        options_.instance_sharing ==
+            catalog::ServiceOptions::InstanceSharingType::SINGLETON ||
+        options_.instance_sharing ==
+            catalog::ServiceOptions::InstanceSharingType::
+                SHARED_ACROSS_INSTANCE_GROUPS ||
+        options_.can_connect_to_instances_in_any_group;
 
     if (!skip_instance_group_check && target_filter.instance_group() &&
         target_filter.instance_group() != identity_.instance_group() &&
@@ -563,25 +590,25 @@
       LOG(ERROR) << "Instance " << identity_.ToString() << " attempting to "
                  << "connect to " << target_filter.service_name() << " in "
                  << "group " << target_filter.instance_group()->ToString()
-                 << " without |can_connect_to_instances_in_any_group| set to "
-                 << "|true|.";
+                 << " without the 'can_connect_to_instances_in_any_group' "
+                 << "option.";
       return mojom::ConnectResult::ACCESS_DENIED;
     }
     if (target_filter.instance_id() &&
         !target_filter.instance_id()->is_zero() &&
-        !manifest_.options.can_connect_to_instances_with_any_id) {
-      LOG(ERROR) << "Instance " << identity_.ToString()
-                 << " attempting to connect to " << target_filter.service_name()
-                 << " with instance ID "
-                 << target_filter.instance_id()->ToString() << " without "
-                 << "|can_connect_to_instances_with_any_id| set to |true|.";
+        !options_.can_connect_to_other_services_with_any_instance_name) {
+      LOG(ERROR)
+          << "Instance " << identity_.ToString() << " attempting to connect to "
+          << target_filter.service_name() << " with instance ID "
+          << target_filter.instance_id()->ToString() << " without the "
+          << "'can_connect_to_other_services_with_any_instance_name' option.";
       return mojom::ConnectResult::ACCESS_DENIED;
     }
 
-    if (can_contact_all_services_ ||
-        !manifest_.interfaces_bindable_on_any_service.empty() ||
-        manifest_.required_capabilities.find(target_filter.service_name()) !=
-            manifest_.required_capabilities.end()) {
+    if (allow_any_application_ ||
+        !options_.interfaces_bindable_on_any_service.empty() ||
+        connection_spec.requires.find(target_filter.service_name()) !=
+            connection_spec.requires.end()) {
       return mojom::ConnectResult::SUCCEEDED;
     }
 
@@ -657,18 +684,13 @@
 
   service_manager::ServiceManager* const service_manager_;
 
-  // An id that identifies this instance. Distinct from PID, as a single process
-  // may host multiple service instances. Globally unique across time and space.
+  // An id that identifies this instance. Distinct from pid, as a single process
+  // may vend multiple application instances, and this object may exist before a
+  // process is launched.
   Identity identity_;
-
-  // The static service manifest provided for this service at system
-  // initialization.
-  const Manifest manifest_;
-
-  // Indicates if this instance requires at least one capability from the
-  // wildcard '*' service.
-  const bool can_contact_all_services_;
-
+  const InterfaceProviderSpecMap interface_provider_specs_;
+  const catalog::ServiceOptions options_;
+  const bool allow_any_application_;
 #if !defined(OS_IOS)
   std::unique_ptr<ServiceProcessLauncher> runner_;
 #endif
@@ -935,19 +957,37 @@
       identity_to_instance_(std::make_unique<IdentityToInstanceMap>()),
       service_process_launcher_factory_(
           std::move(service_process_launcher_factory)) {
-  Manifest service_manager_manifest =
-      ManifestBuilder()
-          .ExposeCapability(kCapability_ServiceManager,
-                            Manifest::InterfaceList<mojom::ServiceManager>())
-          .RequireCapability("*", "service_manager:service_factory")
-          .Build();
-  service_manager_instance_ =
-      CreateInstance(GetServiceManagerInstanceIdentity(),
-                     InstanceType::kSingleton, service_manager_manifest);
+  InterfaceProviderSpec spec;
+  spec.provides[kCapability_ServiceManager].insert(
+      "service_manager.mojom.ServiceManager");
+  spec.requires["*"].insert("service_manager:service_factory");
+  InterfaceProviderSpecMap specs;
+  specs[mojom::kServiceManager_ConnectorSpec] = std::move(spec);
+
+  service_manager_instance_ = CreateInstance(
+      GetServiceManagerInstanceIdentity(), InstanceType::kSingleton,
+      std::move(specs), catalog::ServiceOptions());
 
   mojom::ServicePtr service;
   service_binding_.Bind(mojo::MakeRequest(&service));
   service_manager_instance_->StartWithService(std::move(service));
+
+  InterfaceProviderSpec catalog_spec;
+  catalog_spec.provides["directory"].insert("filesystem.mojom.Directory");
+  catalog_spec.provides["catalog:catalog"].insert("catalog.mojom.Catalog");
+  catalog_spec.provides["control"].insert("catalog.mojom.CatalogControl");
+  InterfaceProviderSpecMap catalog_specs;
+  catalog_specs[mojom::kServiceManager_ConnectorSpec] = std::move(catalog_spec);
+
+  Identity id{catalog::mojom::kServiceName, kSystemInstanceGroup, base::Token{},
+              base::Token::CreateRandom()};
+  Instance* instance =
+      CreateInstance(id, InstanceType::kSingleton, std::move(catalog_specs),
+                     catalog::ServiceOptions());
+
+  mojom::ServicePtr catalog_service;
+  catalog_.BindServiceRequest(mojo::MakeRequest(&catalog_service));
+  instance->StartWithService(std::move(catalog_service));
 }
 
 ServiceManager::~ServiceManager() {
@@ -1021,9 +1061,10 @@
   // Beyond this point, in order to fulfill the connection request we need to
   // start a new instance of the target service.
 
-  const service_manager::Manifest* manifest =
-      catalog_.GetManifest(target_filter.service_name());
-  if (!manifest) {
+  const catalog::Entry* entry =
+      catalog_.GetInstanceForGroup(*target_filter.instance_group())
+          ->Resolve(target_filter.service_name());
+  if (!entry) {
     LOG(ERROR) << "Failed to resolve service name: "
                << target_filter.service_name();
     params->set_response_data(mojom::ConnectResult::INVALID_ARGUMENT,
@@ -1031,10 +1072,17 @@
     return;
   }
 
-  bool all_user_instance = manifest->options.instance_sharing_policy ==
-                           Manifest::InstanceSharingPolicy::kSharedAcrossGroups;
-  bool singleton_instance = manifest->options.instance_sharing_policy ==
-                            Manifest::InstanceSharingPolicy::kSingleton;
+  const InterfaceProviderSpecMap& interface_provider_specs =
+      entry->interface_provider_specs();
+
+  const catalog::ServiceOptions& options = entry->options();
+
+  bool all_user_instance = entry->options().instance_sharing ==
+                           catalog::ServiceOptions::InstanceSharingType::
+                               SHARED_ACROSS_INSTANCE_GROUPS;
+  bool singleton_instance =
+      entry->options().instance_sharing ==
+      catalog::ServiceOptions::InstanceSharingType::SINGLETON;
 
   // Services that have "shared_across_instance_groups" value of
   // "instance_sharing" option are allowed to field connection requests from
@@ -1083,8 +1131,19 @@
                  *target_filter.instance_id(), base::Token::CreateRandom());
   }
 
-  Instance* instance =
-      CreateInstance(new_instance_identity, instance_type, *manifest);
+  // The catalog was unable to read a manifest for this service. We can't do
+  // anything more.
+  if (interface_provider_specs.empty()) {
+    LOG(ERROR)
+        << "Error: The catalog was unable to read a manifest for service \""
+        << entry->name() << "\".";
+    params->set_response_data(mojom::ConnectResult::ACCESS_DENIED,
+                              base::nullopt);
+    return;
+  }
+
+  Instance* instance = CreateInstance(new_instance_identity, instance_type,
+                                      interface_provider_specs, options);
 
   // Below are various paths through which a new Instance can be bound to a
   // Service proxy.
@@ -1096,9 +1155,7 @@
     return;
   }
 
-  const service_manager::Manifest* parent_manifest =
-      catalog_.GetParentManifest(manifest->service_name);
-  if (parent_manifest) {
+  if (entry->parent()) {
     // This service is provided by another service via a ServiceFactory.
     //
     // We normally ignore the target instance group and generate a unique
@@ -1116,7 +1173,7 @@
                  new_instance_identity.globally_unique_id()));
 
     auto factory_filter = ServiceFilter::ByNameWithIdInGroup(
-        parent_manifest->service_name, *target_filter.instance_id(),
+        entry->parent()->name(), *target_filter.instance_id(),
         *target_filter.instance_group());
 
     mojom::PIDReceiverPtr pid_receiver;
@@ -1128,12 +1185,11 @@
                              std::move(pid_receiver));
     instance->StartWithService(std::move(service));
   } else {
-    base::FilePath service_exe_root;
-    CHECK(base::PathService::Get(base::DIR_ASSETS, &service_exe_root));
+    base::FilePath package_path = entry->path();
+    DCHECK(!package_path.empty());
     if (!instance->StartWithFilePath(
-            service_exe_root.AppendASCII(manifest->service_name +
-                                         kServiceExecutableExtension),
-            UtilitySandboxTypeFromString(manifest->options.sandbox_type))) {
+            package_path,
+            UtilitySandboxTypeFromString(entry->sandbox_type()))) {
       OnInstanceError(instance);
       params->set_response_data(mojom::ConnectResult::INVALID_ARGUMENT,
                                 base::nullopt);
@@ -1158,10 +1214,11 @@
 bool ServiceManager::QueryCatalog(const std::string& service_name,
                                   const base::Token& instance_group,
                                   std::string* sandbox_type) {
-  const Manifest* manifest = catalog_.GetManifest(service_name);
-  if (!manifest)
+  const catalog::Entry* entry =
+      catalog_.GetInstanceForGroup(instance_group)->Resolve(service_name);
+  if (!entry)
     return false;
-  *sandbox_type = manifest->options.sandbox_type;
+  *sandbox_type = entry->sandbox_type();
   return true;
 }
 
@@ -1254,10 +1311,11 @@
 ServiceManager::Instance* ServiceManager::CreateInstance(
     const Identity& identity,
     InstanceType instance_type,
-    const Manifest& manifest) {
+    const InterfaceProviderSpecMap& specs,
+    const catalog::ServiceOptions& options) {
   DCHECK(identity.IsValid());
 
-  auto instance = std::make_unique<Instance>(this, identity, manifest);
+  auto instance = std::make_unique<Instance>(this, identity, specs, options);
   Instance* raw_instance = instance.get();
 
   instances_.insert(std::make_pair(raw_instance, std::move(instance)));
@@ -1325,12 +1383,14 @@
     const BindSourceInfo& source_info,
     const std::string& interface_name,
     mojo::ScopedMessagePipeHandle interface_pipe) {
+  // The only interface ServiceManager exposes is mojom::ServiceManager, and
+  // access to this interface is brokered by a policy specific to each caller,
+  // managed by the caller's instance. Here we look to see who's calling,
+  // and forward to the caller's instance to continue.
   Instance* instance = GetExistingInstance(source_info.identity);
   DCHECK(instance);
-  if (interface_name == mojom::ServiceManager::Name_) {
-    instance->BindServiceManager(
-        mojom::ServiceManagerRequest(std::move(interface_pipe)));
-  }
+  instance->OnBindInterface(source_info, interface_name,
+                            std::move(interface_pipe));
 }
 
 }  // namespace service_manager
--- a/services/service_manager/service_manager.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/service_manager/service_manager.h	2019-05-17 18:53:37.992000000 +0300
@@ -14,9 +14,11 @@
 #include "base/process/process.h"
 #include "mojo/public/cpp/bindings/binding_set.h"
 #include "mojo/public/cpp/bindings/interface_ptr_set.h"
-#include "services/service_manager/catalog.h"
+#include "services/catalog/catalog.h"
+#include "services/catalog/service_options.h"
 #include "services/service_manager/connect_params.h"
 #include "services/service_manager/public/cpp/identity.h"
+#include "services/service_manager/public/cpp/interface_provider_spec.h"
 #include "services/service_manager/public/cpp/manifest.h"
 #include "services/service_manager/public/cpp/service.h"
 #include "services/service_manager/public/cpp/service_binding.h"
@@ -25,10 +27,14 @@
 #include "services/service_manager/public/mojom/service.mojom.h"
 #include "services/service_manager/public/mojom/service_factory.mojom.h"
 #include "services/service_manager/public/mojom/service_manager.mojom.h"
-#include "services/service_manager/service_process_launcher_factory.h"
+#include "services/service_manager/runner/host/service_process_launcher_factory.h"
 
 namespace service_manager {
 
+// Creates an identity for the singular Service Manager instance which is always
+// present in the system.
+const Identity& GetServiceManagerInstanceIdentity();
+
 class ServiceManager : public Service {
  public:
   // Constructs a new ServiceManager instance which exclusively uses |manifests|
@@ -125,7 +131,8 @@
 
   Instance* CreateInstance(const Identity& identity,
                            InstanceType instance_type,
-                           const Manifest& manifest);
+                           const InterfaceProviderSpecMap& specs,
+                           const catalog::ServiceOptions& options);
 
   // Called from the instance implementing mojom::ServiceManager.
   void AddListener(mojom::ServiceManagerListenerPtr listener);
@@ -153,7 +160,7 @@
   using InstanceMap = std::map<Instance*, std::unique_ptr<Instance>>;
   InstanceMap instances_;
 
-  Catalog catalog_;
+  catalog::Catalog catalog_;
 
   // Maps service identities to reachable instances. Note that the Instance
   // values stored in that map are NOT owned by this map.
--- a/services/service_manager/switches.h	2019-05-01 01:22:56.000000000 +0300
+++ b/services/service_manager/switches.h	2019-05-17 18:53:37.992000000 +0300
@@ -11,7 +11,6 @@
 // All switches in alphabetical order. The switches should be documented
 // alongside the definition of their values in the .cc file.
 extern const char kEnableTracing[];
-extern const char kServiceRequestAttachmentName[];
 
 }  // namespace switches
 }  // namespace service_manager
--- a/services/service_manager/tests/BUILD.gn	2019-05-01 01:22:56.000000000 +0300
+++ b/services/service_manager/tests/BUILD.gn	2019-05-17 18:53:37.992000000 +0300
@@ -15,7 +15,6 @@
 
 test("service_manager_unittests") {
   sources = [
-    "background_service_manager_unittest.cc",
     "test_support_unittest.cc",
   ]
 
@@ -26,11 +25,15 @@
     "//mojo/core/test:run_all_unittests",
     "//mojo/public/cpp/bindings",
     "//mojo/public/cpp/system",
+    "//services/catalog:lib",
     "//services/service_manager",
+    "//services/service_manager/background:lib",
+    "//services/service_manager/background/tests:unittests",
     "//services/service_manager/public/cpp",
     "//services/service_manager/public/cpp:unittests",
     "//services/service_manager/public/cpp/test:test_support",
     "//services/service_manager/public/mojom",
+    "//services/service_manager/runner/host:unittests",
     "//services/service_manager/tests/connect",
     "//services/service_manager/tests/lifecycle",
     "//services/service_manager/tests/sandbox",
@@ -38,23 +41,11 @@
     "//services/service_manager/tests/shutdown",
     "//testing/gtest",
   ]
-
-  data_deps = [
-    ":background_service_manager_test_service",
-  ]
-
-  if (!is_ios) {
-    sources += [ "service_process_launcher_unittest.cc" ]
-
-    data_deps += [ ":service_process_launcher_test_service" ]
-  }
 }
 
 mojom("interfaces") {
-  testonly = true
   sources = [
-    "background.test-mojom",
-    "test_support.test-mojom",
+    "test.mojom",
   ]
 }
 
@@ -69,31 +60,7 @@
     "//mojo/public/cpp/platform",
     "//mojo/public/cpp/system",
     "//services/service_manager/public/cpp",
-    "//services/service_manager/public/cpp/service_executable:switches",
-    "//services/service_manager/public/mojom",
-  ]
-}
-
-service_executable("background_service_manager_test_service") {
-  testonly = true
-
-  sources = [
-    "background_service_manager_test_service_main.cc",
-  ]
-
-  deps = [
-    ":interfaces",
-    "//base",
-    "//mojo/public/cpp/bindings",
-    "//services/service_manager/public/cpp",
     "//services/service_manager/public/mojom",
-  ]
-}
-
-service_executable("service_process_launcher_test_service") {
-  testonly = true
-
-  sources = [
-    "service_process_launcher_test_service_main.cc",
+    "//services/service_manager/runner/common",
   ]
 }
--- a/services/service_manager/tests/connect/connect_test_exe.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/service_manager/tests/connect/connect_test_exe.cc	2019-05-17 18:53:37.992000000 +0300
@@ -4,7 +4,6 @@
 
 #include <memory>
 
-#include "base/bind.h"
 #include "base/macros.h"
 #include "base/message_loop/message_loop.h"
 #include "mojo/public/cpp/bindings/binding_set.h"
--- a/services/service_manager/tests/DEPS	2019-05-01 01:22:56.000000000 +0300
+++ b/services/service_manager/tests/DEPS	2019-05-17 18:53:37.992000000 +0300
@@ -1,3 +1,4 @@
 include_rules = [
+  "+services/catalog",
   "+sandbox/win/src",
 ]
--- a/services/service_manager/tests/lifecycle/BUILD.gn	2019-05-01 01:22:56.000000000 +0300
+++ b/services/service_manager/tests/lifecycle/BUILD.gn	2019-05-17 18:53:37.992000000 +0300
@@ -18,6 +18,7 @@
     "//services/service_manager/public/cpp",
     "//services/service_manager/public/cpp/test:test_support",
     "//services/service_manager/public/mojom",
+    "//services/service_manager/runner/common",
     "//testing/gtest",
   ]
 
--- a/services/service_manager/tests/service_manager/BUILD.gn	2019-05-01 01:22:56.000000000 +0300
+++ b/services/service_manager/tests/service_manager/BUILD.gn	2019-05-17 18:53:37.996000000 +0300
@@ -25,6 +25,7 @@
     "//services/service_manager/public/cpp",
     "//services/service_manager/public/cpp/test:test_support",
     "//services/service_manager/public/mojom",
+    "//services/service_manager/runner/common",
     "//testing/gtest",
   ]
 
@@ -89,5 +90,7 @@
     "//build/win:default_exe_manifest",
     "//services/service_manager/public/cpp",
     "//services/service_manager/public/mojom",
+    "//services/service_manager/runner:init",
+    "//services/service_manager/runner/common",
   ]
 }
--- a/services/service_manager/tests/service_manager/embedder.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/service_manager/tests/service_manager/embedder.cc	2019-05-17 18:53:37.996000000 +0300
@@ -4,7 +4,6 @@
 
 #include <memory>
 
-#include "base/bind.h"
 #include "base/macros.h"
 #include "base/message_loop/message_loop.h"
 #include "mojo/public/cpp/bindings/binding_set.h"
--- a/services/service_manager/tests/service_manager/service_manager_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/service_manager/tests/service_manager/service_manager_unittest.cc	2019-05-17 18:53:37.996000000 +0300
@@ -33,7 +33,7 @@
 #include "services/service_manager/public/cpp/service_binding.h"
 #include "services/service_manager/public/cpp/test/test_service_manager.h"
 #include "services/service_manager/public/mojom/service_manager.mojom.h"
-#include "services/service_manager/service_process_launcher.h"
+#include "services/service_manager/runner/common/client_util.h"
 #include "services/service_manager/tests/service_manager/service_manager.test-mojom.h"
 #include "services/service_manager/tests/service_manager/test_manifests.h"
 #include "testing/gtest/include/gtest/gtest.h"
@@ -265,8 +265,8 @@
 
     mojo::OutgoingInvitation invitation;
     service_manager::mojom::ServicePtr client =
-        ServiceProcessLauncher::PassServiceRequestOnCommandLine(
-            &invitation, &child_command_line);
+        service_manager::PassServiceRequestOnCommandLine(&invitation,
+                                                         &child_command_line);
     service_manager::mojom::PIDReceiverPtr receiver;
     connector()->RegisterServiceInstance(
         service_manager::Identity(kTestTargetName, kSystemInstanceGroup,
--- a/services/service_manager/tests/shutdown/shutdown_client_app.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/service_manager/tests/shutdown/shutdown_client_app.cc	2019-05-17 18:53:37.996000000 +0300
@@ -2,7 +2,6 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "base/bind.h"
 #include "base/macros.h"
 #include "base/message_loop/message_loop.h"
 #include "mojo/public/cpp/bindings/binding_set.h"
--- a/services/service_manager/tests/shutdown/shutdown_service_app.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/service_manager/tests/shutdown/shutdown_service_app.cc	2019-05-17 18:53:37.996000000 +0300
@@ -2,7 +2,6 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "base/bind.h"
 #include "base/macros.h"
 #include "base/message_loop/message_loop.h"
 #include "mojo/public/cpp/bindings/binding_set.h"
--- a/services/service_manager/tests/test_support_unittest.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/service_manager/tests/test_support_unittest.cc	2019-05-17 18:53:37.996000000 +0300
@@ -15,7 +15,7 @@
 #include "services/service_manager/public/cpp/service.h"
 #include "services/service_manager/public/cpp/service_binding.h"
 #include "services/service_manager/public/cpp/test/test_connector_factory.h"
-#include "services/service_manager/tests/test_support.test-mojom.h"
+#include "services/service_manager/tests/test.mojom.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
 namespace service_manager {
@@ -24,7 +24,7 @@
 
 // TestBImpl and TestCImpl are simple test interfaces whose methods invokes
 // their callback when called without doing anything.
-class TestBImpl : public mojom::TestB {
+class TestBImpl : public TestB {
  public:
   TestBImpl() = default;
   ~TestBImpl() override = default;
@@ -37,7 +37,7 @@
   DISALLOW_COPY_AND_ASSIGN(TestBImpl);
 };
 
-class TestCImpl : public mojom::TestC {
+class TestCImpl : public TestC {
  public:
   TestCImpl() = default;
   ~TestCImpl() override = default;
@@ -49,11 +49,11 @@
   DISALLOW_COPY_AND_ASSIGN(TestCImpl);
 };
 
-void OnTestBRequest(mojom::TestBRequest request) {
+void OnTestBRequest(TestBRequest request) {
   mojo::MakeStrongBinding(std::make_unique<TestBImpl>(), std::move(request));
 }
 
-void OnTestCRequest(mojom::TestCRequest request) {
+void OnTestCRequest(TestCRequest request) {
   mojo::MakeStrongBinding(std::make_unique<TestCImpl>(), std::move(request));
 }
 
@@ -115,7 +115,7 @@
   TestCServiceImpl c_service(factory.RegisterInstance(kServiceCName));
   auto* connector = factory.GetDefaultConnector();
 
-  mojom::TestCPtr c;
+  TestCPtr c;
   connector->BindInterface(kServiceCName, &c);
   base::RunLoop loop;
   c->C(loop.QuitClosure());
@@ -131,7 +131,7 @@
   auto* connector = factory.GetDefaultConnector();
 
   {
-    mojom::TestBPtr b;
+    TestBPtr b;
     connector->BindInterface(kServiceBName, &b);
     base::RunLoop loop;
     b->B(loop.QuitClosure());
@@ -139,7 +139,7 @@
   }
 
   {
-    mojom::TestCPtr c;
+    TestCPtr c;
     connector->BindInterface(kServiceCName, &c);
     base::RunLoop loop;
     c->C(loop.QuitClosure());
--- a/services/service_manager/tests/util.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/service_manager/tests/util.cc	2019-05-17 18:53:37.996000000 +0300
@@ -20,10 +20,9 @@
 #include "mojo/public/cpp/platform/platform_channel.h"
 #include "mojo/public/cpp/system/invitation.h"
 #include "services/service_manager/public/cpp/connector.h"
-#include "services/service_manager/public/cpp/service_executable/switches.h"
 #include "services/service_manager/public/mojom/connector.mojom.h"
-#include "services/service_manager/public/mojom/service.mojom.h"
 #include "services/service_manager/public/mojom/service_factory.mojom.h"
+#include "services/service_manager/runner/common/switches.h"
 
 namespace service_manager {
 namespace test {
@@ -66,8 +65,7 @@
   mojo::OutgoingInvitation invitation;
   auto pipe_name = base::NumberToString(base::RandUint64());
   mojo::ScopedMessagePipeHandle pipe = invitation.AttachMessagePipe(pipe_name);
-  child_command_line.AppendSwitchASCII(switches::kServiceRequestAttachmentName,
-                                       pipe_name);
+  child_command_line.AppendSwitchASCII(switches::kServicePipeToken, pipe_name);
 
   service_manager::mojom::ServicePtr client;
   client.Bind(mojo::InterfacePtrInfo<service_manager::mojom::Service>(
--- a/services/service_manager/zygote/host/zygote_communication_linux.h	2019-05-17 17:45:42.580000000 +0300
+++ b/services/service_manager/zygote/host/zygote_communication_linux.h	2019-05-17 18:53:38.000000000 +0300
@@ -28,7 +28,7 @@
 
 // Handles interprocess communication with the Linux zygote process. The zygote
 // does not use standard Chrome IPC or mojo, see:
-// https://chromium.9oo91esource.qjz9zk/chromium/b+/master/docs/linux_sandbox_ipc.md
+// https://chromium.googlesource.com/chromium/b+/master/docs/linux_sandbox_ipc.md
 class COMPONENT_EXPORT(SERVICE_MANAGER_ZYGOTE) ZygoteCommunication {
  public:
   ZygoteCommunication();
--- a/services/service_manager/zygote/host/zygote_host_impl_linux.cc	2019-05-17 17:45:42.580000000 +0300
+++ b/services/service_manager/zygote/host/zygote_host_impl_linux.cc	2019-05-17 18:53:38.000000000 +0300
@@ -115,7 +115,7 @@
   } else {
     LOG(FATAL)
         << "No usable sandbox! Update your kernel or see "
-           "https://chromium.9oo91esource.qjz9zk/chromium/b+/master/"
+           "https://chromium.googlesource.com/chromium/b+/master/"
            "docs/linux_suid_sandbox_development.md for more information on "
            "developing with the SUID sandbox. "
            "If you want to live dangerously and need an immediate workaround, "
@@ -272,8 +272,8 @@
   std::vector<std::string> adj_oom_score_cmdline;
   adj_oom_score_cmdline.push_back(sandbox_binary_);
   adj_oom_score_cmdline.push_back(sandbox::kAdjustOOMScoreSwitch);
-  adj_oom_score_cmdline.push_back(base::NumberToString(pid));
-  adj_oom_score_cmdline.push_back(base::NumberToString(score));
+  adj_oom_score_cmdline.push_back(base::Int64ToString(pid));
+  adj_oom_score_cmdline.push_back(base::IntToString(score));
 
   // sandbox_helper_process is a setuid binary.
   base::LaunchOptions options;
--- a/services/service_manager/zygote/zygote_host_linux.h	2019-05-17 17:45:42.580000000 +0300
+++ b/services/service_manager/zygote/zygote_host_linux.h	2019-05-17 18:53:38.000000000 +0300
@@ -12,7 +12,7 @@
 
 namespace service_manager {
 
-// https://chromium.9oo91esource.qjz9zk/chromium/b+/master/docs/linux_zygote.md
+// https://chromium.googlesource.com/chromium/b+/master/docs/linux_zygote.md
 
 // The zygote host is an interface, in the browser process, to the zygote
 // process.
--- a/services/service_manager/zygote/zygote_linux.cc	2019-05-17 17:45:42.584000000 +0300
+++ b/services/service_manager/zygote/zygote_linux.cc	2019-05-17 18:53:38.000000000 +0300
@@ -47,7 +47,7 @@
 #include "third_party/icu/source/i18n/unicode/timezone.h"
 
 // See
-// https://chromium.9oo91esource.qjz9zk/chromium/b+/master/docs/linux_zygote.md
+// https://chromium.googlesource.com/chromium/b+/master/docs/linux_zygote.md
 
 namespace service_manager {
 
@@ -106,7 +106,7 @@
   // browser on it.
   // A SOCK_DGRAM is installed in fd 5. This is the sandbox IPC channel.
   // See
-  // https://chromium.9oo91esource.qjz9zk/chromium/b+/master/docs/linux_sandbox_ipc.md
+  // https://chromium.googlesource.com/chromium/b+/master/docs/linux_sandbox_ipc.md
 
   // We need to accept SIGCHLD, even though our handler is a no-op because
   // otherwise we cannot wait on children. (According to POSIX 2001.)
--- a/services/service_manager/zygote/zygote_linux.h	2019-05-17 17:45:42.584000000 +0300
+++ b/services/service_manager/zygote/zygote_linux.h	2019-05-17 18:53:38.000000000 +0300
@@ -143,7 +143,7 @@
   std::vector<ZygoteProcessInfo> to_reap_;
 
   // Sandbox IPC channel for renderers to invoke services from the browser. See
-  // https://chromium.9oo91esource.qjz9zk/chromium/b+/master/docs/linux_sandbox_ipc.md
+  // https://chromium.googlesource.com/chromium/b+/master/docs/linux_sandbox_ipc.md
   base::GlobalDescriptors::Descriptor ipc_backchannel_;
 };
 
--- a/services/service_manager/zygote/zygote_main_linux.cc	2019-05-17 17:45:42.584000000 +0300
+++ b/services/service_manager/zygote/zygote_main_linux.cc	2019-05-17 18:53:38.000000000 +0300
@@ -110,7 +110,7 @@
   if (!setuid_sandbox->IsSuidSandboxUpToDate()) {
     LOG(WARNING) << "You are using a wrong version of the setuid binary!\n"
                     "Please read "
-                    "https://chromium.9oo91esource.qjz9zk/chromium/b+/master/"
+                    "https://chromium.googlesource.com/chromium/b+/master/"
                     "docs/linux_suid_sandbox_development.md."
                     "\n\n";
   }
--- a/services/shape_detection/android/java/borg/chromium/shape_detection/FaceDetectionImpl.java	2019-05-01 01:22:56.000000000 +0300
+++ b/services/shape_detection/android/java/borg/chromium/shape_detection/FaceDetectionImpl.java	2019-05-17 18:53:38.000000000 +0300
@@ -11,8 +11,7 @@
 import android.media.FaceDetector.Face;
 
 import org.chromium.base.Log;
-import org.chromium.base.task.PostTask;
-import org.chromium.base.task.TaskTraits;
+import org.chromium.base.task.AsyncTask;
 import org.chromium.gfx.mojom.RectF;
 import org.chromium.mojo.system.MojoException;
 import org.chromium.shape_detection.mojom.FaceDetection;
@@ -71,7 +70,9 @@
 
         // FaceDetector creation and findFaces() might take a long time and trigger a
         // "StrictMode policy violation": they should happen in a background thread.
-        PostTask.postTask(TaskTraits.BEST_EFFORT_MAY_BLOCK, () -> {
+        AsyncTask.THREAD_POOL_EXECUTOR.execute(new Runnable() {
+            @Override
+            public void run() {
             final FaceDetector detector = new FaceDetector(width, height, mMaxFaces);
             Face[] detectedFaces = new Face[mMaxFaces];
             // findFaces() will stop at |mMaxFaces|.
@@ -98,6 +99,7 @@
             }
 
             callback.call(faceArray);
+            }
         });
     }
 
--- a/services/shape_detection/barcode_detection_impl_mac_unittest.mm	2019-05-17 17:45:42.584000000 +0300
+++ b/services/shape_detection/barcode_detection_impl_mac_unittest.mm	2019-05-17 18:53:38.004000000 +0300
@@ -57,7 +57,7 @@
     base::Callback<std::unique_ptr<mojom::BarcodeDetection>(
         mojom::BarcodeDetectorOptionsPtr)>;
 
-const std::string kInfoString = "https://www.ch40m1um.qjz9zk";
+const std::string kInfoString = "https://www.chromium.org";
 
 struct TestParams {
   size_t num_barcodes;
@@ -168,6 +168,6 @@
   run_loop.Run();
 }
 
-INSTANTIATE_TEST_SUITE_P(, BarcodeDetectionImplMacTest, ValuesIn(kTestParams));
+INSTANTIATE_TEST_CASE_P(, BarcodeDetectionImplMacTest, ValuesIn(kTestParams));
 
 }  // shape_detection namespace
--- a/services/shape_detection/barcode_detection_impl_mac_vision.mm	2019-05-01 01:22:56.000000000 +0300
+++ b/services/shape_detection/barcode_detection_impl_mac_vision.mm	2019-05-17 18:53:38.004000000 +0300
@@ -73,21 +73,6 @@
                    observation.boundingBox.size.height * image_size_.height),
         image_size_.height);
 
-    // Enumerate corner points starting from top-left in clockwise fashion:
-    // https://wicg.github.io/shape-detection-api/#dom-detectedbarcode-cornerpoints
-    barcode->corner_points.emplace_back(
-        observation.topLeft.x * image_size_.width,
-        (1 - observation.topLeft.y) * image_size_.height);
-    barcode->corner_points.emplace_back(
-        observation.topRight.x * image_size_.width,
-        (1 - observation.topRight.y) * image_size_.height);
-    barcode->corner_points.emplace_back(
-        observation.bottomRight.x * image_size_.width,
-        (1 - observation.bottomRight.y) * image_size_.height);
-    barcode->corner_points.emplace_back(
-        observation.bottomLeft.x * image_size_.width,
-        (1 - observation.bottomLeft.y) * image_size_.height);
-
     barcode->raw_value =
         base::SysNSStringToUTF8(observation.payloadStringValue);
 
--- a/services/shape_detection/barcode_detection_provider_mac.mm	2019-05-01 01:22:56.000000000 +0300
+++ b/services/shape_detection/barcode_detection_provider_mac.mm	2019-05-17 18:53:38.004000000 +0300
@@ -28,8 +28,15 @@
 void BarcodeDetectionProviderMac::CreateBarcodeDetection(
     mojom::BarcodeDetectionRequest request,
     mojom::BarcodeDetectorOptionsPtr options) {
-  // Vision Framework needs at least MAC OS X 10.13. Stay vigilant: past OS
-  // upgrades (e.g. to 10.14, see crbug.com/921968) have broken it.
+  // SDK 10.14 has troubles using the Vision Framework, fall back to CIDetector.
+  // TODO(crbug.com/921968) remove this extra case and use the Vision Framework.
+  if (@available(macOS 10.14, *)) {
+    mojo::MakeStrongBinding(std::make_unique<BarcodeDetectionImplMac>(),
+                            std::move(request));
+    return;
+  }
+
+  // Vision Framework needs at least MAC OS X 10.13.
   if (@available(macOS 10.13, *)) {
     auto impl =
         std::make_unique<BarcodeDetectionImplMacVision>(std::move(options));
--- a/services/shape_detection/BUILD.gn	2019-05-01 01:22:56.000000000 +0300
+++ b/services/shape_detection/BUILD.gn	2019-05-17 18:53:38.000000000 +0300
@@ -2,6 +2,7 @@
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
+import("//services/service_manager/public/service_manifest.gni")
 import("//testing/test.gni")
 
 source_set("lib") {
@@ -113,6 +114,11 @@
   }
 }
 
+service_manifest("manifest") {
+  name = "shape_detection"
+  source = "manifest.json"
+}
+
 source_set("tests") {
   testonly = true
   sources = [
--- a/services/shape_detection/face_detection_impl_mac_unittest.mm	2019-05-01 01:22:56.000000000 +0300
+++ b/services/shape_detection/face_detection_impl_mac_unittest.mm	2019-05-17 18:53:38.004000000 +0300
@@ -177,6 +177,6 @@
   run_loop.Run();
 }
 
-INSTANTIATE_TEST_SUITE_P(, FaceDetectionImplMacTest, ValuesIn(kTestParams));
+INSTANTIATE_TEST_CASE_P(, FaceDetectionImplMacTest, ValuesIn(kTestParams));
 
 }  // shape_detection namespace
--- a/services/shape_detection/face_detection_provider_impl.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/shape_detection/face_detection_provider_impl.cc	2019-05-17 18:53:38.004000000 +0300
@@ -4,8 +4,6 @@
 
 #include "services/shape_detection/face_detection_provider_impl.h"
 
-#include "services/shape_detection/public/mojom/facedetection.mojom.h"
-
 namespace shape_detection {
 
 void FaceDetectionProviderImpl::CreateFaceDetection(
--- a/services/shape_detection/OWNERS	2019-05-01 01:22:56.000000000 +0300
+++ b/services/shape_detection/OWNERS	2019-05-17 18:53:38.000000000 +0300
@@ -3,3 +3,6 @@
 
 mcasas@chromium.org
 reillyg@chromium.org
+
+per-file manifest.json=set noparent
+per-file manifest.json=file://ipc/SECURITY_OWNERS
--- a/services/shape_detection/text_detection_impl_mac_unittest.mm	2019-05-17 17:45:42.584000000 +0300
+++ b/services/shape_detection/text_detection_impl_mac_unittest.mm	2019-05-17 18:53:38.008000000 +0300
@@ -4,7 +4,6 @@
 
 #include "services/shape_detection/text_detection_impl_mac.h"
 
-#include "base/bind.h"
 #include "base/command_line.h"
 #include "base/mac/mac_util.h"
 #include "base/mac/scoped_cftyperef.h"
@@ -71,7 +70,7 @@
         dictionaryWithObjectsAndKeys:helvetica, kCTFontAttributeName, nil];
 
     base::scoped_nsobject<NSAttributedString> info([[NSAttributedString alloc]
-        initWithString:@"https://www.ch40m1um.qjz9zk"
+        initWithString:@"https://www.chromium.org"
             attributes:attributes]);
 
     base::ScopedCFTypeRef<CTLineRef> line(
--- a/services/shape_detection/text_detection_impl_win.cc	2019-05-17 17:45:42.588000000 +0300
+++ b/services/shape_detection/text_detection_impl_win.cc	2019-05-17 18:53:38.008000000 +0300
@@ -9,7 +9,6 @@
 #include <memory>
 #include <string>
 
-#include "base/bind.h"
 #include "base/logging.h"
 #include "base/win/core_winrt_util.h"
 #include "base/win/post_async_results.h"
@@ -43,7 +42,7 @@
 void TextDetectionImpl::Create(mojom::TextDetectionRequest request) {
   // OcrEngine class is only available in Win 10 onwards (v10.0.10240.0) that
   // documents in
-  // https://docs.m1cr050ft.qjz9zk/en-us/uwp/api/windows.media.ocr.ocrengine.
+  // https://docs.microsoft.com/en-us/uwp/api/windows.media.ocr.ocrengine.
   if (base::win::GetVersion() < base::win::VERSION_WIN10) {
     DVLOG(1) << "Optical character recognition not supported before Windows 10";
     return;
--- a/services/shape_detection/text_detection_impl_win_unittest.cc	2019-05-17 17:45:42.588000000 +0300
+++ b/services/shape_detection/text_detection_impl_win_unittest.cc	2019-05-17 18:53:38.008000000 +0300
@@ -90,7 +90,7 @@
   ASSERT_EQ(2u, results.size());
   EXPECT_EQ("The Chromium Project website is:", results[0]->raw_value);
   EXPECT_EQ(gfx::RectF(51, 38, 272, 17), results[0]->bounding_box);
-  EXPECT_EQ("https://www.ch40m1um.qjz9zk", results[1]->raw_value);
+  EXPECT_EQ("https://www.chromium.org", results[1]->raw_value);
   EXPECT_EQ(gfx::RectF(51, 63, 209, 17), results[1]->bounding_box);
 }
 
--- a/services/test/echo/BUILD.gn	2019-05-01 01:22:56.000000000 +0300
+++ b/services/test/echo/BUILD.gn	2019-05-17 18:53:38.008000000 +0300
@@ -2,6 +2,8 @@
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
+import("//services/service_manager/public/service_manifest.gni")
+
 source_set("lib") {
   sources = [
     "echo_service.cc",
@@ -15,3 +17,8 @@
     "//services/test/echo/public/mojom",
   ]
 }
+
+service_manifest("manifest") {
+  name = "echo"
+  source = "manifest.json"
+}
--- a/services/test/echo/echo_service.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/test/echo/echo_service.cc	2019-05-17 18:53:38.008000000 +0300
@@ -3,7 +3,6 @@
 // found in the LICENSE file.
 
 #include "services/test/echo/echo_service.h"
-#include "base/bind.h"
 
 namespace echo {
 
--- a/services/test/echo/OWNERS	2019-05-01 01:22:56.000000000 +0300
+++ b/services/test/echo/OWNERS	2019-05-17 18:53:38.008000000 +0300
@@ -0,0 +1,2 @@
+per-file manifest.json=set noparent
+per-file manifest.json=file://ipc/SECURITY_OWNERS
--- a/services/test/user_id/BUILD.gn	2019-05-01 01:22:56.000000000 +0300
+++ b/services/test/user_id/BUILD.gn	2019-05-17 18:53:38.008000000 +0300
@@ -2,6 +2,8 @@
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
+import("//services/service_manager/public/service_manifest.gni")
+
 source_set("lib") {
   sources = [
     "user_id_service.cc",
@@ -15,3 +17,8 @@
     "//services/test/user_id/public/mojom",
   ]
 }
+
+service_manifest("manifest") {
+  name = "user_id"
+  source = "manifest.json"
+}
--- a/services/test/user_id/OWNERS	2019-05-01 01:22:56.000000000 +0300
+++ b/services/test/user_id/OWNERS	2019-05-17 18:53:38.008000000 +0300
@@ -0,0 +1,2 @@
+per-file manifest.json=set noparent
+per-file manifest.json=file://ipc/SECURITY_OWNERS
--- a/services/test/user_id/user_id_service.cc	2019-05-01 01:22:56.000000000 +0300
+++ b/services/test/user_id/user_id_service.cc	2019-05-17 18:53:38.012000000 +0300
@@ -3,7 +3,6 @@
 // found in the LICENSE file.
 
 #include "services/test/user_id/user_id_service.h"
-#include "base/bind.h"
 
 namespace user_id {
 
--- a/services/tracing/agent_registry.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/tracing/agent_registry.cc	2019-05-17 18:53:38.012000000 +0300
@@ -7,7 +7,6 @@
 #include <string>
 #include <utility>
 
-#include "base/bind.h"
 #include "base/callback_forward.h"
 #include "base/logging.h"
 #include "base/threading/thread_checker.h"
@@ -16,8 +15,6 @@
 
 namespace tracing {
 
-const int32_t kAgentResponseTimeoutInSeconds = 10;
-
 AgentRegistry::AgentEntry::AgentEntry(size_t id,
                                       AgentRegistry* agent_registry,
                                       mojom::AgentPtr agent,
@@ -42,17 +39,10 @@
     base::OnceClosure closure) {
   DCHECK_EQ(0u, closures_.count(closure_name));
   closures_[closure_name] = std::move(closure);
-
-  // Adding a disconnect closure means we're waiting for a response from the
-  // agent. If the client becomes unresponsive, we disconnect it.
-  timer_.Start(FROM_HERE,
-               base::TimeDelta::FromSeconds(kAgentResponseTimeoutInSeconds),
-               this, &AgentRegistry::AgentEntry::OnConnectionError);
 }
 
 bool AgentRegistry::AgentEntry::RemoveDisconnectClosure(
     const void* closure_name) {
-  timer_.Stop();
   return closures_.erase(closure_name) > 0;
 }
 
@@ -76,22 +66,37 @@
   agent_registry_->UnregisterAgent(id_);
 }
 
-AgentRegistry::AgentRegistry() = default;
+AgentRegistry::AgentRegistry() {
+  DETACH_FROM_SEQUENCE(sequence_checker_);
+}
 
-AgentRegistry::~AgentRegistry() = default;
+AgentRegistry::~AgentRegistry() {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+}
 
 void AgentRegistry::DisconnectAllAgents() {
   bindings_.CloseAllBindings();
 }
 
 void AgentRegistry::BindAgentRegistryRequest(
+    scoped_refptr<base::SequencedTaskRunner> task_runner,
+    mojom::AgentRegistryRequest request) {
+  task_runner->PostTask(
+      FROM_HERE,
+      base::BindOnce(&AgentRegistry::BindAgentRegistryRequestOnSequence,
+                     base::Unretained(this), std::move(request)));
+}
+
+void AgentRegistry::BindAgentRegistryRequestOnSequence(
     mojom::AgentRegistryRequest request) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
   bindings_.AddBinding(this, std::move(request));
 }
 
 size_t AgentRegistry::SetAgentInitializationCallback(
     const AgentInitializationCallback& callback,
     bool call_on_new_agents_only) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
   agent_initialization_callback_ = callback;
   size_t num_initialized_agents = 0;
   if (!call_on_new_agents_only) {
@@ -104,6 +109,7 @@
 }
 
 bool AgentRegistry::HasDisconnectClosure(const void* closure_name) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
   for (const auto& key_value : agents_) {
     if (key_value.second->HasDisconnectClosure(closure_name))
       return true;
@@ -115,6 +121,7 @@
                                   const std::string& label,
                                   mojom::TraceDataType type,
                                   base::ProcessId pid) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
   auto id = next_agent_id_++;
   auto entry = std::make_unique<AgentEntry>(id, this, std::move(agent), label,
                                             type, pid);
@@ -125,6 +132,7 @@
 }
 
 void AgentRegistry::UnregisterAgent(size_t agent_id) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
   size_t num_deleted = agents_.erase(agent_id);
   DCHECK_EQ(1u, num_deleted);
 }
--- a/services/tracing/agent_registry.h	2019-05-01 01:22:57.000000000 +0300
+++ b/services/tracing/agent_registry.h	2019-05-17 18:53:38.012000000 +0300
@@ -12,7 +12,7 @@
 #include "base/callback_forward.h"
 #include "base/macros.h"
 #include "base/memory/weak_ptr.h"
-#include "base/timer/timer.h"
+#include "base/sequence_checker.h"
 #include "mojo/public/cpp/bindings/binding_set.h"
 #include "services/service_manager/public/cpp/identity.h"
 #include "services/tracing/public/mojom/tracing.mojom.h"
@@ -54,7 +54,6 @@
     const mojom::TraceDataType type_;
     const base::ProcessId pid_;
     std::map<const void*, base::OnceClosure> closures_;
-    base::RepeatingTimer timer_;
 
     DISALLOW_COPY_AND_ASSIGN(AgentEntry);
   };
@@ -69,6 +68,7 @@
   void DisconnectAllAgents();
 
   void BindAgentRegistryRequest(
+      scoped_refptr<base::SequencedTaskRunner> task_runner,
       mojom::AgentRegistryRequest request);
 
   // Returns the number of existing agents that the callback was run on.
@@ -79,6 +79,7 @@
 
   template <typename FunctionType>
   void ForAllAgents(FunctionType function) {
+    DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
     for (const auto& key_value : agents_) {
       function(key_value.second.get());
     }
@@ -86,7 +87,9 @@
 
  private:
   friend class AgentRegistryTest;  // For testing.
-  friend class CoordinatorTestUtil;  // For testing.
+  friend class CoordinatorTest;    // For testing.
+
+  void BindAgentRegistryRequestOnSequence(mojom::AgentRegistryRequest request);
 
   // mojom::AgentRegistry
   void RegisterAgent(mojom::AgentPtr agent,
@@ -101,6 +104,8 @@
   std::map<size_t, std::unique_ptr<AgentEntry>> agents_;
   AgentInitializationCallback agent_initialization_callback_;
 
+  SEQUENCE_CHECKER(sequence_checker_);
+
   DISALLOW_COPY_AND_ASSIGN(AgentRegistry);
 };
 
--- a/services/tracing/agent_registry_unittest.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/tracing/agent_registry_unittest.cc	2019-05-17 18:53:38.012000000 +0300
@@ -8,7 +8,6 @@
 #include <string>
 #include <utility>
 
-#include "base/bind.h"
 #include "base/message_loop/message_loop.h"
 #include "base/run_loop.h"
 #include "services/service_manager/public/cpp/service_context_ref.h"
--- a/services/tracing/BUILD.gn	2019-05-01 01:22:56.000000000 +0300
+++ b/services/tracing/BUILD.gn	2019-05-17 18:53:38.012000000 +0300
@@ -3,6 +3,7 @@
 # found in the LICENSE file.
 
 import("//build/config/chromecast_build.gni")
+import("//services/service_manager/public/service_manifest.gni")
 
 # There should be only one tracing service. It is currently
 # in the browser process. So, only //content/browser should link to this target.
@@ -13,10 +14,6 @@
     "agent_registry.h",
     "coordinator.cc",
     "coordinator.h",
-    "perfetto/chrome_event_bundle_json_exporter.cc",
-    "perfetto/chrome_event_bundle_json_exporter.h",
-    "perfetto/consumer_host.cc",
-    "perfetto/consumer_host.h",
     "perfetto/json_trace_exporter.cc",
     "perfetto/json_trace_exporter.h",
     "perfetto/perfetto_service.cc",
@@ -39,7 +36,6 @@
     "//services/service_manager/public/cpp",
     "//services/tracing/public/cpp",
     "//third_party/perfetto:libperfetto",
-    "//third_party/perfetto/protos/perfetto/config:lite",
   ]
 
   deps = [
@@ -69,8 +65,6 @@
 
   sources = [
     "agent_registry_unittest.cc",
-    "coordinator_test_util.cc",
-    "coordinator_test_util.h",
     "coordinator_unittest.cc",
     "public/cpp/trace_event_agent_unittest.cc",
     "recorder_unittest.cc",
@@ -104,11 +98,8 @@
 
   if (is_mac || is_linux || is_android || is_fuchsia) {
     sources += [
-      "perfetto/chrome_event_bundle_json_exporter_unittest.cc",
-      "perfetto/consumer_host_unittest.cc",
       "perfetto/json_trace_exporter_unittest.cc",
       "perfetto/perfetto_integration_unittest.cc",
-      "perfetto/perfetto_tracing_coordinator_unittest.cc",
       "perfetto/test_utils.cc",
       "perfetto/test_utils.h",
     ]
@@ -118,8 +109,6 @@
       "//third_party/perfetto/protos/perfetto/common:lite",
       "//third_party/perfetto/protos/perfetto/trace:lite",
       "//third_party/perfetto/protos/perfetto/trace/chrome:lite",
-      "//third_party/perfetto/protos/perfetto/trace/interned_data:lite",
-      "//third_party/perfetto/protos/perfetto/trace/track_event:lite",
     ]
   }
 
--- a/services/tracing/coordinator.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/tracing/coordinator.cc	2019-05-17 18:53:38.012000000 +0300
@@ -37,18 +37,11 @@
 const char kMetadataTraceLabel[] = "metadata";
 
 const char kRequestBufferUsageClosureName[] = "RequestBufferUsageClosure";
-const char kStartTracingClosureName[] = "StartTracingClosure";
-const int32_t kBeginTracingTimeoutInSeconds = 10;
 
 }  // namespace
 
 namespace tracing {
 
-// static
-const void* Coordinator::GetStartTracingClosureName() {
-  return &kStartTracingClosureName;
-}
-
 class Coordinator::TraceStreamer : public base::SupportsWeakPtr<TraceStreamer> {
  public:
   // Constructed on |main_task_runner_|.
@@ -276,10 +269,9 @@
 
 Coordinator::Coordinator(AgentRegistry* agent_registry,
                          const base::RepeatingClosure& on_disconnect_callback)
-    : task_runner_(base::SequencedTaskRunnerHandle::Get()),
-      agent_registry_(agent_registry),
-      on_disconnect_callback_(std::move(on_disconnect_callback)),
+    : on_disconnect_callback_(std::move(on_disconnect_callback)),
       binding_(this),
+      task_runner_(base::ThreadTaskRunnerHandle::Get()),
       // USER_VISIBLE because the task posted from StopAndFlushInternal() is
       // required to stop tracing from the UI.
       // TODO(fdoray): Once we have support for dynamic priorities
@@ -288,6 +280,7 @@
       backend_task_runner_(base::CreateSequencedTaskRunnerWithTraits(
           {base::TaskPriority::USER_VISIBLE, base::MayBlock(),
            base::WithBaseSyncPrimitives()})),
+      agent_registry_(agent_registry),
       weak_ptr_factory_(this) {
   DCHECK(agent_registry_);
 }
@@ -301,14 +294,10 @@
 }
 
 void Coordinator::Reset() {
-  start_tracing_callback_timer_.Stop();
-
   if (!stop_and_flush_callback_.is_null()) {
     base::ResetAndReturn(&stop_and_flush_callback_)
         .Run(base::Value(base::Value::Type::DICTIONARY));
   }
-  if (!start_tracing_callback_.is_null())
-    base::ResetAndReturn(&start_tracing_callback_).Run(false);
   if (!request_buffer_usage_callback_.is_null())
     base::ResetAndReturn(&request_buffer_usage_callback_).Run(false, 0, 0);
 
@@ -337,11 +326,8 @@
       &Coordinator::OnClientConnectionError, base::Unretained(this)));
 }
 
-void Coordinator::StartTracing(const std::string& config,
-                               StartTracingCallback callback) {
-  bool is_initializing = !start_tracing_callback_.is_null();
-  if (is_initializing || (is_tracing_ && config == config_)) {
-    std::move(callback).Run(config == config_);
+void Coordinator::StartTracing(const std::string& config) {
+  if ((is_tracing_ && config == config_)) {
     return;
   }
 
@@ -352,113 +338,13 @@
       base::BindRepeating(&Coordinator::SendStartTracingToAgent,
                           weak_ptr_factory_.GetWeakPtr()),
       false /* call_on_new_agents_only */);
-
-  SetStartTracingCallback(std::move(callback));
-}
-
-void Coordinator::SetStartTracingCallback(StartTracingCallback callback) {
-  start_tracing_callback_ = std::move(callback);
-  CallStartTracingCallbackIfNeeded();
-
-  if (!start_tracing_callback_)
-    return;
-
-  // We can't know for sure whether all processses we request
-  // to connect to the tracing service will connect back, or
-  // if all the connected services will ACK our BeginTracing
-  // request eventually, so we'll add a timeout for that case.
-  start_tracing_callback_timer_.Start(
-      FROM_HERE, base::TimeDelta::FromSeconds(kBeginTracingTimeoutInSeconds),
-      this, &Coordinator::OnBeginTracingTimeout);
-}
-
-void Coordinator::OnBeginTracingTimeout() {
-  if (start_tracing_callback_)
-    std::move(start_tracing_callback_).Run(true);
-}
-
-void Coordinator::CallStartTracingCallbackIfNeeded() {
-  // We still have processes we've asked to begin tracing and
-  // need ACKs from.
-  if (agent_registry_->HasDisconnectClosure(&kStartTracingClosureName))
-    return;
-
-  // We're still waiting for the list of PIDs of the currently
-  // running services.
-  if (pending_currently_running_pids_)
-    return;
-
-  // We're still waiting for processes to connect to the
-  // service.
-  for (auto& pid : pending_connected_pids_) {
-    if (parsed_config_.process_filter_config().IsEnabled(pid))
-      return;
-  }
-
-  if (start_tracing_callback_)
-    std::move(start_tracing_callback_).Run(true);
-
-  start_tracing_callback_timer_.Stop();
-}
-
-void Coordinator::AddExpectedPID(base::ProcessId pid) {
-  if (!pid)
-    return;
-
-  bool pid_is_connected = false;
-  agent_registry_->ForAllAgents(
-      [&pid_is_connected, pid](AgentRegistry::AgentEntry* agent_entry) {
-        if (pid == agent_entry->pid())
-          pid_is_connected = true;
-      });
-
-  if (!pid_is_connected)
-    pending_connected_pids_.insert(pid);
-}
-
-void Coordinator::RemoveExpectedPID(base::ProcessId pid) {
-  pending_connected_pids_.erase(pid);
-  CallStartTracingCallbackIfNeeded();
-}
-
-void Coordinator::FinishedReceivingRunningPIDs() {
-  pending_currently_running_pids_ = false;
-  CallStartTracingCallbackIfNeeded();
-}
-
-void Coordinator::ClearConnectedPIDs() {
-  if (!pending_connected_pids_.empty()) {
-    pending_connected_pids_.clear();
-    CallStartTracingCallbackIfNeeded();
-  }
 }
 
 void Coordinator::SendStartTracingToAgent(
     AgentRegistry::AgentEntry* agent_entry) {
-  if (agent_entry->HasDisconnectClosure(&kStartTracingClosureName))
-    return;
   if (!parsed_config_.process_filter_config().IsEnabled(agent_entry->pid()))
     return;
-  agent_entry->AddDisconnectClosure(
-      &kStartTracingClosureName,
-      base::BindOnce(&Coordinator::OnTracingStarted,
-                     weak_ptr_factory_.GetWeakPtr(),
-                     base::Unretained(agent_entry), false));
-  RemoveExpectedPID(agent_entry->pid());
-
-  agent_entry->agent()->StartTracing(
-      config_, TRACE_TIME_TICKS_NOW(),
-      base::BindRepeating(&Coordinator::OnTracingStarted,
-                          weak_ptr_factory_.GetWeakPtr(),
-                          base::Unretained(agent_entry)));
-}
-
-void Coordinator::OnTracingStarted(AgentRegistry::AgentEntry* agent_entry,
-                                   bool success) {
-  bool removed =
-      agent_entry->RemoveDisconnectClosure(&kStartTracingClosureName);
-  DCHECK(removed);
-  CallStartTracingCallbackIfNeeded();
+  agent_entry->agent()->StartTracing(config_, TRACE_TIME_TICKS_NOW());
 }
 
 void Coordinator::StopAndFlush(mojo::ScopedDataPipeProducerHandle stream,
@@ -477,12 +363,6 @@
   DCHECK(!trace_streamer_);
   DCHECK(stream.is_valid());
   is_tracing_ = false;
-  // If we get a Stop call and this is non-empty, it means we either
-  // hit a timeout waiting for processes to connect, or the trace
-  // client sent a stop without waiting for the BeginTracing callback
-  // to happen. In either case, we don't want/need to wait for additional
-  // processes to connect anymore.
-  ClearConnectedPIDs();
 
   trace_streamer_.reset(new Coordinator::TraceStreamer(
       std::move(stream), agent_label, task_runner_,
@@ -492,18 +372,6 @@
 }
 
 void Coordinator::StopAndFlushInternal() {
-  if (start_tracing_callback_) {
-    // We received a |StopAndFlush| command before receiving |StartTracing| acks
-    // from all agents. Let's retry after a delay.
-    task_runner_->PostDelayedTask(
-        FROM_HERE,
-        base::BindRepeating(&Coordinator::StopAndFlushInternal,
-                            weak_ptr_factory_.GetWeakPtr()),
-        base::TimeDelta::FromMilliseconds(
-            mojom::kStopTracingRetryTimeMilliseconds));
-    return;
-  }
-
   size_t num_initialized_agents =
       agent_registry_->SetAgentInitializationCallback(
           base::BindRepeating(&Coordinator::SendStopTracingToAgent,
--- a/services/tracing/coordinator.h	2019-05-01 01:22:57.000000000 +0300
+++ b/services/tracing/coordinator.h	2019-05-17 18:53:38.012000000 +0300
@@ -14,7 +14,6 @@
 #include "base/memory/weak_ptr.h"
 #include "base/sequenced_task_runner.h"
 #include "base/single_thread_task_runner.h"
-#include "base/timer/timer.h"
 #include "base/trace_event/trace_config.h"
 #include "base/values.h"
 #include "mojo/public/cpp/system/data_pipe.h"
@@ -51,37 +50,21 @@
 
   bool IsConnected();
 
-  void AddExpectedPID(base::ProcessId pid);
-  void RemoveExpectedPID(base::ProcessId pid);
-  void FinishedReceivingRunningPIDs();
-
  protected:
   ~Coordinator() override;
 
-  static const void* GetStartTracingClosureName();
-
   virtual void OnClientConnectionError();
-  void CallStartTracingCallbackIfNeeded();
-  void OnBeginTracingTimeout();
-  void SetStartTracingCallback(StartTracingCallback callback);
-  void ClearConnectedPIDs();
-
-  base::trace_event::TraceConfig parsed_config_;
-  StartTracingCallback start_tracing_callback_;
-  const scoped_refptr<base::SequencedTaskRunner> task_runner_;
-  AgentRegistry* agent_registry_;
 
  private:
   friend std::default_delete<Coordinator>;
-  friend class CoordinatorTestUtil;  // For testing.
+  friend class CoordinatorTest;  // For testing.
 
   class TraceStreamer;
 
   void Reset();
 
   // mojom::Coordinator
-  void StartTracing(const std::string& config,
-                    StartTracingCallback callback) override;
+  void StartTracing(const std::string& config) override;
   void StopAndFlush(mojo::ScopedDataPipeProducerHandle stream,
                     StopAndFlushCallback callback) override;
   void StopAndFlushAgent(mojo::ScopedDataPipeProducerHandle stream,
@@ -92,7 +75,6 @@
 
   // Internal methods for collecting events from agents.
   void SendStartTracingToAgent(AgentRegistry::AgentEntry* agent_entry);
-  void OnTracingStarted(AgentRegistry::AgentEntry* agent_entry, bool success);
   void StopAndFlushInternal();
   void SendStopTracingToAgent(AgentRegistry::AgentEntry* agent_entry);
   void SendStopTracingWithNoOpRecorderToAgent(
@@ -107,14 +89,14 @@
 
   base::RepeatingClosure on_disconnect_callback_;
   mojo::Binding<mojom::Coordinator> binding_;
+  const scoped_refptr<base::SingleThreadTaskRunner> task_runner_;
   const scoped_refptr<base::SequencedTaskRunner> backend_task_runner_;
+  AgentRegistry* agent_registry_;
   std::string config_;
+  base::trace_event::TraceConfig parsed_config_;
   bool is_tracing_ = false;
 
   std::unique_ptr<TraceStreamer> trace_streamer_;
-  std::set<base::ProcessId> pending_connected_pids_;
-  bool pending_currently_running_pids_ = true;
-  base::OneShotTimer start_tracing_callback_timer_;
   StopAndFlushCallback stop_and_flush_callback_;
 
   // For computing trace buffer usage.
--- a/services/tracing/coordinator_unittest.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/tracing/coordinator_unittest.cc	2019-05-17 18:53:38.012000000 +0300
@@ -4,30 +4,132 @@
 
 #include "services/tracing/coordinator.h"
 
+#include <algorithm>
 #include <memory>
+#include <set>
+#include <string>
+#include <utility>
+#include <vector>
 
 #include "base/run_loop.h"
-#include "services/tracing/coordinator_test_util.h"
+#include "base/strings/string_split.h"
+#include "base/test/scoped_task_environment.h"
+#include "mojo/public/cpp/system/data_pipe.h"
+#include "mojo/public/cpp/system/data_pipe_drainer.h"
+#include "services/service_manager/public/cpp/service_context_ref.h"
+#include "services/tracing/public/mojom/tracing.mojom.h"
 #include "services/tracing/test_util.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
 namespace tracing {
 
-class CoordinatorTest : public testing::Test, public CoordinatorTestUtil {
+class CoordinatorTest : public testing::Test,
+                        public mojo::DataPipeDrainer::Client {
  public:
+  // testing::Test
   void SetUp() override {
-    CoordinatorTestUtil::SetUp();
-    coordinator_ = std::make_unique<Coordinator>(agent_registry(),
+    agent_registry_ = std::make_unique<AgentRegistry>();
+    coordinator_ = std::make_unique<Coordinator>(agent_registry_.get(),
                                                  base::RepeatingClosure());
-    coordinator_->FinishedReceivingRunningPIDs();
+    output_ = "";
   }
-  void TearDown() override { CoordinatorTestUtil::TearDown(); }
+
+  // testing::Test
+  void TearDown() override {
+    agents_.clear();
+    coordinator_.reset();
+    agent_registry_.reset();
+  }
+
+  // mojo::DataPipeDrainer::Client
+  void OnDataAvailable(const void* data, size_t num_bytes) override {
+    output_.append(static_cast<const char*>(data), num_bytes);
+  }
+
+  // mojo::DataPipeDrainer::Client
+  void OnDataComplete() override { std::move(quit_closure_).Run(); }
+
+  MockAgent* AddArrayAgent(base::ProcessId pid) {
+    auto agent = std::make_unique<MockAgent>();
+    agent_registry_->RegisterAgent(agent->CreateAgentPtr(), "traceEvents",
+                                   mojom::TraceDataType::ARRAY, pid);
+    agents_.push_back(std::move(agent));
+    return agents_.back().get();
+  }
+
+  MockAgent* AddArrayAgent() { return AddArrayAgent(base::kNullProcessId); }
+
+  MockAgent* AddObjectAgent() {
+    auto agent = std::make_unique<MockAgent>();
+    agent_registry_->RegisterAgent(agent->CreateAgentPtr(), "systemTraceEvents",
+                                   mojom::TraceDataType::OBJECT,
+                                   base::kNullProcessId);
+    agents_.push_back(std::move(agent));
+    return agents_.back().get();
+  }
+
+  MockAgent* AddStringAgent() {
+    auto agent = std::make_unique<MockAgent>();
+    agent_registry_->RegisterAgent(agent->CreateAgentPtr(), "power",
+                                   mojom::TraceDataType::STRING,
+                                   base::kNullProcessId);
+    agents_.push_back(std::move(agent));
+    return agents_.back().get();
+  }
+
+  void StartTracing(std::string config) { coordinator_->StartTracing(config); }
+
+  void StopAndFlush() {
+    mojo::DataPipe data_pipe;
+    auto dummy_callback = [](base::Value metadata) {};
+    coordinator_->StopAndFlush(std::move(data_pipe.producer_handle),
+                               base::BindRepeating(dummy_callback));
+    drainer_.reset(
+        new mojo::DataPipeDrainer(this, std::move(data_pipe.consumer_handle)));
+  }
+
+  void IsTracing(bool expected_response) {
+    coordinator_->IsTracing(base::BindRepeating(
+        [](bool expected, bool actual) { EXPECT_EQ(expected, actual); },
+        expected_response));
+  }
+
+  void RequestBufferUsage(float expected_usage, uint32_t expected_count) {
+    coordinator_->RequestBufferUsage(base::BindRepeating(
+        [](float expected_usage, uint32_t expected_count, bool success,
+           float usage, uint32_t count) {
+          EXPECT_TRUE(success);
+          EXPECT_EQ(expected_usage, usage);
+          EXPECT_EQ(expected_count, count);
+        },
+        expected_usage, expected_count));
+  }
+
+  void CheckDisconnectClosures(size_t num_agents) {
+    // Verify that all disconnect closures are cleared up. This means that, for
+    // each agent, either the tracing service is notified that the agent is
+    // disconnected or the agent has answered to all requests.
+    size_t count = 0;
+    agent_registry_->ForAllAgents([&count](AgentRegistry::AgentEntry* entry) {
+      count++;
+      EXPECT_EQ(0u, entry->num_disconnect_closures_for_testing());
+    });
+    EXPECT_EQ(num_agents, count);
+  }
+
+  base::test::ScopedTaskEnvironment scoped_task_environment_;
+  std::unique_ptr<AgentRegistry> agent_registry_;
+  std::unique_ptr<Coordinator> coordinator_;
+  std::vector<std::unique_ptr<MockAgent>> agents_;
+  std::unique_ptr<mojo::DataPipeDrainer> drainer_;
+  base::RepeatingClosure quit_closure_;
+  std::string output_;
 };
 
 TEST_F(CoordinatorTest, StartTracingSimple) {
   base::RunLoop run_loop;
   auto* agent = AddArrayAgent();
-  StartTracing("*", true);
+  StartTracing("*");
   run_loop.RunUntilIdle();
 
   // The agent should have received exactly one call from the coordinator.
@@ -38,7 +140,7 @@
 TEST_F(CoordinatorTest, StartTracingTwoAgents) {
   base::RunLoop run_loop;
   auto* agent1 = AddArrayAgent();
-  StartTracing("*", true);
+  StartTracing("*");
   auto* agent2 = AddStringAgent();
   run_loop.RunUntilIdle();
 
@@ -53,13 +155,13 @@
   base::RunLoop run_loop1;
   auto* agent1 = AddArrayAgent(static_cast<base::ProcessId>(1));
   auto* agent2 = AddArrayAgent(static_cast<base::ProcessId>(2));
-  StartTracing("{\"included_process_ids\":[2,4]}", true);
+  StartTracing("{\"included_process_ids\":[2,4]}");
   run_loop1.RunUntilIdle();
 
   base::RunLoop run_loop2;
   auto* agent3 = AddArrayAgent(static_cast<base::ProcessId>(3));
   auto* agent4 = AddArrayAgent(static_cast<base::ProcessId>(4));
-  StartTracing("{\"included_process_ids\":[4,6]}", true);
+  StartTracing("{\"included_process_ids\":[4,6]}");
   run_loop2.RunUntilIdle();
 
   base::RunLoop run_loop3;
@@ -68,38 +170,27 @@
   run_loop3.RunUntilIdle();
 
   // StartTracing should only be received by agents 2, 4, and 6.
+  // Agent 4 should receive StartTracing twice, as it's
+  // included in both configs.
   EXPECT_EQ(0u, agent1->call_stat().size());
   EXPECT_EQ(1u, agent2->call_stat().size());
   EXPECT_EQ("StartTracing", agent2->call_stat()[0]);
   EXPECT_EQ(0u, agent3->call_stat().size());
-  EXPECT_EQ(1u, agent4->call_stat().size());
+  EXPECT_EQ(2u, agent4->call_stat().size());
   EXPECT_EQ("StartTracing", agent4->call_stat()[0]);
+  EXPECT_EQ("StartTracing", agent4->call_stat()[1]);
   EXPECT_EQ(0u, agent5->call_stat().size());
   EXPECT_EQ(1u, agent6->call_stat().size());
   EXPECT_EQ("StartTracing", agent6->call_stat()[0]);
 }
 
-TEST_F(CoordinatorTest, StartTracingWithDifferentConfigs) {
-  base::RunLoop run_loop;
-  auto* agent = AddArrayAgent();
-  StartTracing("config 1", true);
-  // The 2nd |StartTracing| should return false.
-  StartTracing("config 2", false);
-  run_loop.RunUntilIdle();
-
-  // The agent should have received exactly one call from the coordinator
-  // because the 2nd |StartTracing| was aborted.
-  EXPECT_EQ(1u, agent->call_stat().size());
-  EXPECT_EQ("StartTracing", agent->call_stat()[0]);
-}
-
 TEST_F(CoordinatorTest, StartTracingWithSameConfigs) {
   base::RunLoop run_loop;
   auto* agent = AddArrayAgent();
-  StartTracing("config", true);
-  // The 2nd |StartTracing| should return true when we are not trying to change
+  StartTracing("config");
+  // The 2nd |StartTracing| should succeed when we are not trying to change
   // the config.
-  StartTracing("config", true);
+  StartTracing("config");
   run_loop.RunUntilIdle();
 
   // The agent should have received exactly one call from the coordinator
@@ -109,15 +200,20 @@
 }
 
 TEST_F(CoordinatorTest, StopAndFlushObjectAgent) {
+  base::RunLoop run_loop;
+  quit_closure_ = run_loop.QuitClosure();
+
   auto* agent = AddObjectAgent();
   agent->data_.push_back("\"content\":{\"a\":1}");
   agent->data_.push_back("\"name\":\"etw\"");
 
-  StartTracing("config", true);
-  std::string output = StopAndFlush();
+  StartTracing("config");
+  StopAndFlush();
+  if (!quit_closure_.is_null())
+    run_loop.Run();
 
   EXPECT_EQ("{\"systemTraceEvents\":{\"content\":{\"a\":1},\"name\":\"etw\"}}",
-            output);
+            output_);
 
   // Each agent should have received exactly two calls.
   EXPECT_EQ(2u, agent->call_stat().size());
@@ -126,6 +222,9 @@
 }
 
 TEST_F(CoordinatorTest, StopAndFlushTwoArrayAgents) {
+  base::RunLoop run_loop;
+  quit_closure_ = run_loop.QuitClosure();
+
   auto* agent1 = AddArrayAgent();
   agent1->data_.push_back("e1");
   agent1->data_.push_back("e2");
@@ -134,20 +233,22 @@
   agent2->data_.push_back("e3");
   agent2->data_.push_back("e4");
 
-  StartTracing("config", true);
-  std::string output = StopAndFlush();
+  StartTracing("config");
+  StopAndFlush();
+  if (!quit_closure_.is_null())
+    run_loop.Run();
 
-  // |output| should be of the form {"traceEvents":[ei,ej,ek,el]}, where
+  // |output_| should be of the form {"traceEvents":[ei,ej,ek,el]}, where
   // ei,ej,ek,el is a permutation of e1,e2,e3,e4 such that e1 is before e2 and
   // e3 is before e4 since e1 and 2 come from the same agent and their order
   // should be preserved and, similarly, the order of e3 and e4 should be
   // preserved, too.
-  EXPECT_TRUE(output == "{\"traceEvents\":[e1,e2,e3,e4]}" ||
-              output == "{\"traceEvents\":[e1,e3,e2,e4]}" ||
-              output == "{\"traceEvents\":[e1,e3,e4,e2]}" ||
-              output == "{\"traceEvents\":[e3,e1,e2,e4]}" ||
-              output == "{\"traceEvents\":[e3,e1,e4,e2]}" ||
-              output == "{\"traceEvents\":[e3,e4,e1,e2]}");
+  EXPECT_TRUE(output_ == "{\"traceEvents\":[e1,e2,e3,e4]}" ||
+              output_ == "{\"traceEvents\":[e1,e3,e2,e4]}" ||
+              output_ == "{\"traceEvents\":[e1,e3,e4,e2]}" ||
+              output_ == "{\"traceEvents\":[e3,e1,e2,e4]}" ||
+              output_ == "{\"traceEvents\":[e3,e1,e4,e2]}" ||
+              output_ == "{\"traceEvents\":[e3,e4,e1,e2]}");
 
   // Each agent should have received exactly two calls.
   EXPECT_EQ(2u, agent1->call_stat().size());
@@ -160,6 +261,9 @@
 }
 
 TEST_F(CoordinatorTest, StopAndFlushDifferentTypeAgents) {
+  base::RunLoop run_loop;
+  quit_closure_ = run_loop.QuitClosure();
+
   auto* agent1 = AddArrayAgent();
   agent1->data_.push_back("e1");
   agent1->data_.push_back("e2");
@@ -168,11 +272,13 @@
   agent2->data_.push_back("e3");
   agent2->data_.push_back("e4");
 
-  StartTracing("config", true);
-  std::string output = StopAndFlush();
+  StartTracing("config");
+  StopAndFlush();
+  if (!quit_closure_.is_null())
+    run_loop.Run();
 
-  EXPECT_TRUE(output == "{\"traceEvents\":[e1,e2],\"power\":\"e3e4\"}" ||
-              output == "{\"power\":\"e3e4\",\"traceEvents\":[e1,e2]}");
+  EXPECT_TRUE(output_ == "{\"traceEvents\":[e1,e2],\"power\":\"e3e4\"}" ||
+              output_ == "{\"power\":\"e3e4\",\"traceEvents\":[e1,e2]}");
 
   // Each agent should have received exactly two calls.
   EXPECT_EQ(2u, agent1->call_stat().size());
@@ -185,16 +291,21 @@
 }
 
 TEST_F(CoordinatorTest, StopAndFlushWithMetadata) {
+  base::RunLoop run_loop;
+  quit_closure_ = run_loop.QuitClosure();
+
   auto* agent = AddArrayAgent();
   agent->data_.push_back("event");
   agent->metadata_.SetString("key", "value");
 
-  StartTracing("config", true);
-  std::string output = StopAndFlush();
+  StartTracing("config");
+  StopAndFlush();
+  if (!quit_closure_.is_null())
+    run_loop.Run();
 
   // Metadata is written at after trace data.
   EXPECT_EQ("{\"traceEvents\":[event],\"metadata\":{\"key\":\"value\"}}",
-            output);
+            output_);
   EXPECT_EQ(2u, agent->call_stat().size());
   EXPECT_EQ("StartTracing", agent->call_stat()[0]);
   EXPECT_EQ("StopAndFlush", agent->call_stat()[1]);
@@ -203,7 +314,7 @@
 TEST_F(CoordinatorTest, IsTracing) {
   base::RunLoop run_loop;
   AddArrayAgent();
-  StartTracing("config", true);
+  StartTracing("config");
   IsTracing(true);
   run_loop.RunUntilIdle();
 }
@@ -249,15 +360,18 @@
 }
 
 TEST_F(CoordinatorTest, LateAgents) {
+  base::RunLoop run_loop1;
+  quit_closure_ = run_loop1.QuitClosure();
   auto* agent1 = AddArrayAgent();
-
-  StartTracing("config", true);
+  StartTracing("config");
   StopAndFlush();
+  if (!quit_closure_.is_null())
+    run_loop1.Run();
 
-  base::RunLoop run_loop;
+  base::RunLoop run_loop2;
   auto* agent2 = AddArrayAgent();
   agent2->data_.push_back("discarded data");
-  run_loop.RunUntilIdle();
+  run_loop2.RunUntilIdle();
 
   EXPECT_EQ(2u, agent1->call_stat().size());
   EXPECT_EQ("StartTracing", agent1->call_stat()[0]);
@@ -269,31 +383,4 @@
   EXPECT_EQ("StopAndFlush", agent2->call_stat()[0]);
 }
 
-TEST_F(CoordinatorTest, WaitForSpecificPIDs) {
-  coordinator_->AddExpectedPID(42);
-  coordinator_->AddExpectedPID(4242);
-
-  auto* agent1 = AddArrayAgent(42);
-  StartTracing("config", true);
-  base::RunLoop().RunUntilIdle();
-
-  EXPECT_FALSE(tracing_begin_callback_received());
-
-  auto* agent2 = AddArrayAgent(4242);
-  base::RunLoop().RunUntilIdle();
-
-  EXPECT_TRUE(tracing_begin_callback_received());
-
-  StopAndFlush();
-  base::RunLoop().RunUntilIdle();
-
-  EXPECT_EQ(2u, agent1->call_stat().size());
-  EXPECT_EQ("StartTracing", agent1->call_stat()[0]);
-  EXPECT_EQ("StopAndFlush", agent1->call_stat()[1]);
-
-  EXPECT_EQ(2u, agent2->call_stat().size());
-  EXPECT_EQ("StartTracing", agent2->call_stat()[0]);
-  EXPECT_EQ("StopAndFlush", agent2->call_stat()[1]);
-}
-
 }  // namespace tracing
--- a/services/tracing/DEPS	2019-05-01 01:22:56.000000000 +0300
+++ b/services/tracing/DEPS	2019-05-17 18:53:38.012000000 +0300
@@ -1,5 +1,4 @@
 include_rules = [
-  "+components/tracing/common",
   "+services/service_manager/public",
   "+third_party/perfetto/include",
   "+third_party/perfetto/protos/perfetto",
--- a/services/tracing/manifest.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/tracing/manifest.cc	2019-05-17 18:53:38.012000000 +0300
@@ -8,7 +8,6 @@
 #include "services/service_manager/public/cpp/manifest_builder.h"
 #include "services/tracing/public/mojom/constants.mojom.h"
 #include "services/tracing/public/mojom/perfetto_service.mojom.h"
-#include "services/tracing/public/mojom/traced_process.mojom.h"
 #include "services/tracing/public/mojom/tracing.mojom.h"
 
 namespace tracing {
@@ -26,8 +25,7 @@
                            .Build())
           .ExposeCapability(
               "tracing",
-              service_manager::Manifest::InterfaceList<mojom::Coordinator,
-                                                       mojom::ConsumerHost>())
+              service_manager::Manifest::InterfaceList<mojom::Coordinator>())
           .RequireCapability("service_manager",
                              "service_manager:service_manager")
           .WithInterfacesBindableOnAnyService(
--- a/services/tracing/perfetto/json_trace_exporter.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/tracing/perfetto/json_trace_exporter.cc	2019-05-17 18:53:38.012000000 +0300
@@ -4,478 +4,482 @@
 
 #include "services/tracing/perfetto/json_trace_exporter.h"
 
+#include <unordered_map>
 #include <utility>
 
 #include "base/format_macros.h"
 #include "base/json/json_reader.h"
 #include "base/json/json_writer.h"
 #include "base/json/string_escape.h"
+#include "base/logging.h"
+#include "base/strings/stringprintf.h"
 #include "base/trace_event/trace_event.h"
-#include "services/tracing/public/cpp/trace_event_args_whitelist.h"
+#include "build/build_config.h"
+#include "services/tracing/public/mojom/perfetto_service.mojom.h"
+#include "third_party/perfetto/include/perfetto/tracing/core/trace_config.h"
 #include "third_party/perfetto/include/perfetto/tracing/core/trace_packet.h"
 #include "third_party/perfetto/protos/perfetto/trace/chrome/chrome_trace_event.pbzero.h"
 #include "third_party/perfetto/protos/perfetto/trace/chrome/chrome_trace_packet.pb.h"
 
+using TraceEvent = base::trace_event::TraceEvent;
+
 namespace tracing {
 
 namespace {
 
-constexpr size_t kTraceEventBufferSizeInBytes = 100 * 1024;
-
-}  // namespace
-
-JSONTraceExporter::JSONTraceExporter(bool filter_args,
-                                     OnTraceEventJSONCallback callback)
-    : out_(callback),
-      metadata_(std::make_unique<base::DictionaryValue>()),
-      filter_args_(filter_args) {}
+const size_t kTraceEventBufferSizeInBytes = 100 * 1024;
 
-JSONTraceExporter::~JSONTraceExporter() = default;
-
-void JSONTraceExporter::OnTraceData(std::vector<perfetto::TracePacket> packets,
-                                    bool has_more) {
-  DCHECK(!packets.empty() || !has_more);
-
-  // TODO(eseckler): |label_filter_| seems broken for anything but
-  // "traceEvents" (e.g. "systemTraceEvents" will output invalid JSON).
-  if (label_filter_.empty() && !has_output_json_preamble_) {
-    out_ += "{\"traceEvents\":[";
-    has_output_json_preamble_ = true;
-  }
-
-  // Delegate to the subclasses to parse the packets. It will create
-  // ScopedJSONTraceEventAppenders to write the contained events along with
-  // other trace fields.
-  ProcessPackets(packets);
-
-  if (!has_more) {
-    if (label_filter_.empty()) {
-      // We are done adding events so now we close the traceEvents array and
-      // append the rest of the fields. The rest of the fields aren't very large
-      // so we don't need to check if we need to run the callback.
-      out_ += "]";
-    }
+void AppendProtoArrayAsJSON(std::string* out,
+                            const perfetto::protos::ChromeTracedValue& array);
 
-    if ((label_filter_.empty() || label_filter_ == "systemTraceEvents") &&
-        (!legacy_system_ftrace_output_.empty() ||
-         !legacy_system_trace_events_.empty())) {
-      DCHECK(legacy_system_ftrace_output_.empty() ||
-             legacy_system_trace_events_.empty());
-      out_ += ",\"systemTraceEvents\":";
-      if (!legacy_system_ftrace_output_.empty()) {
-        std::string escaped;
-        base::EscapeJSONString(legacy_system_ftrace_output_,
-                               true /* put_in_quotes */, &escaped);
-        out_ += escaped;
+void AppendProtoValueAsJSON(std::string* out,
+                            const perfetto::protos::ChromeTracedValue& value) {
+  base::trace_event::TraceEvent::TraceValue json_value;
+  if (value.has_int_value()) {
+    json_value.as_int = value.int_value();
+    TraceEvent::AppendValueAsJSON(TRACE_VALUE_TYPE_INT, json_value, out);
+  } else if (value.has_double_value()) {
+    json_value.as_double = value.double_value();
+    TraceEvent::AppendValueAsJSON(TRACE_VALUE_TYPE_DOUBLE, json_value, out);
+  } else if (value.has_bool_value()) {
+    json_value.as_bool = value.bool_value();
+    TraceEvent::AppendValueAsJSON(TRACE_VALUE_TYPE_BOOL, json_value, out);
+  } else if (value.has_string_value()) {
+    json_value.as_string = value.string_value().c_str();
+    TraceEvent::AppendValueAsJSON(TRACE_VALUE_TYPE_STRING, json_value, out);
+  } else if (value.has_nested_type()) {
+    if (value.nested_type() == perfetto::protos::ChromeTracedValue::ARRAY) {
+      AppendProtoArrayAsJSON(out, value);
+      return;
+    } else if (value.nested_type() ==
+               perfetto::protos::ChromeTracedValue::DICT) {
+      AppendProtoDictAsJSON(out, value);
       } else {
-        out_ += legacy_system_trace_events_ + "}";
+      NOTREACHED();
       }
+  } else {
+    NOTREACHED();
     }
+}
 
-    if (label_filter_.empty()) {
-      if (!metadata_->empty()) {
-        out_ += ",\"metadata\":";
-        std::string json_value;
-        base::JSONWriter::Write(*metadata_, &json_value);
-        out_ += json_value;
+void AppendProtoArrayAsJSON(std::string* out,
+                            const perfetto::protos::ChromeTracedValue& array) {
+  out->append("[");
+
+  bool is_first_entry = true;
+  for (auto& value : array.array_values()) {
+    if (!is_first_entry) {
+      out->append(",");
+    } else {
+      is_first_entry = false;
       }
 
-      // Finish the json object we started in the preamble.
-      out_ += "}";
-    }
+    AppendProtoValueAsJSON(out, value);
   }
 
-  // Send any remaining data. There is no harm issuing the callback with an
-  // empty string, so we do it unconditionally.
-  out_.Flush(metadata_.get(), has_more);
+  out->append("]");
 }
 
-bool JSONTraceExporter::ShouldOutputTraceEvents() const {
-  return label_filter_.empty() || label_filter_ == "traceEvents";
+const char* GetStringFromStringTable(
+    const std::unordered_map<int, std::string>& string_table,
+    int index) {
+  auto it = string_table.find(index);
+  DCHECK(it != string_table.end());
+
+  return it->second.c_str();
 }
 
-void JSONTraceExporter::AddChromeLegacyJSONTrace(
-    const perfetto::protos::ChromeLegacyJsonTrace& json_trace) {
-  // Tracing agents should only add this field when there is some data.
-  DCHECK(!json_trace.data().empty());
-  switch (json_trace.type()) {
-    case perfetto::protos::ChromeLegacyJsonTrace::USER_TRACE:
-      *AddJSONTraceEvent() += json_trace.data();
-      return;
-    case perfetto::protos::ChromeLegacyJsonTrace::SYSTEM_TRACE:
-      if (!ShouldOutputTraceEvents()) {
-        return;
+void OutputJSONFromTraceEventProto(
+    const perfetto::protos::ChromeTraceEvent& event,
+    std::string* out,
+    const std::unordered_map<int, std::string>& string_table) {
+  char phase = static_cast<char>(event.phase());
+  const char* name =
+      event.has_name_index()
+          ? GetStringFromStringTable(string_table, event.name_index())
+          : event.name().c_str();
+  const char* category_group_name =
+      event.has_category_group_name_index()
+          ? GetStringFromStringTable(string_table,
+                                     event.category_group_name_index())
+          : event.category_group_name().c_str();
+
+  base::StringAppendF(out,
+                      "{\"pid\":%i,\"tid\":%i,\"ts\":%" PRId64
+                      ",\"ph\":\"%c\",\"cat\":\"%s\",\"name\":",
+                      event.process_id(), event.thread_id(), event.timestamp(),
+                      phase, category_group_name);
+  base::EscapeJSONString(name, true, out);
+
+  if (event.has_duration()) {
+    base::StringAppendF(out, ",\"dur\":%" PRId64, event.duration());
       }
-      if (legacy_system_trace_events_.empty()) {
-        legacy_system_trace_events_ = "{";
-      } else {
-        legacy_system_trace_events_ += ",";
+
+  if (event.has_thread_duration()) {
+    base::StringAppendF(out, ",\"tdur\":%" PRId64, event.thread_duration());
       }
-      legacy_system_trace_events_ += json_trace.data();
-      return;
-    default:
-      NOTREACHED();
+
+  if (event.has_thread_timestamp()) {
+    base::StringAppendF(out, ",\"tts\":%" PRId64, event.thread_timestamp());
   }
-}
 
-void JSONTraceExporter::AddLegacyFtrace(
-    const std::string& legacy_ftrace_output) {
-  legacy_system_ftrace_output_ += legacy_ftrace_output;
-}
+  // Output async tts marker field if flag is set.
+  if (event.flags() & TRACE_EVENT_FLAG_ASYNC_TTS) {
+    base::StringAppendF(out, ", \"use_async_tts\":1");
+  }
 
-void JSONTraceExporter::AddChromeMetadata(
-    const perfetto::protos::ChromeMetadata& metadata) {
-  if (metadata.has_string_value()) {
-    metadata_->SetString(metadata.name(), metadata.string_value());
-  } else if (metadata.has_int_value()) {
-    metadata_->SetInteger(metadata.name(), metadata.int_value());
-  } else if (metadata.has_bool_value()) {
-    metadata_->SetBoolean(metadata.name(), metadata.bool_value());
-  } else if (metadata.has_json_value()) {
-    std::unique_ptr<base::Value> value(
-        base::JSONReader::ReadDeprecated(metadata.json_value()));
-    metadata_->Set(metadata.name(), std::move(value));
-  } else {
-    NOTREACHED();
+  // If id_ is set, print it out as a hex string so we don't loose any
+  // bits (it might be a 64-bit pointer).
+  unsigned int id_flags =
+      event.flags() & (TRACE_EVENT_FLAG_HAS_ID | TRACE_EVENT_FLAG_HAS_LOCAL_ID |
+                       TRACE_EVENT_FLAG_HAS_GLOBAL_ID);
+  if (id_flags) {
+    if (event.has_scope()) {
+      base::StringAppendF(out, ",\"scope\":\"%s\"", event.scope().c_str());
   }
-}
 
-void JSONTraceExporter::SetTraceStatsMetadata(
-    const perfetto::protos::TraceStats& trace_stats) {
-  auto dict = std::make_unique<base::DictionaryValue>();
-  dict->SetInteger("producers_connected", trace_stats.producers_connected());
-  dict->SetInteger("producers_seen", trace_stats.producers_seen());
-  dict->SetInteger("data_sources_registered",
-                   trace_stats.data_sources_registered());
-  dict->SetInteger("data_sources_seen", trace_stats.data_sources_seen());
-  dict->SetInteger("tracing_sessions", trace_stats.tracing_sessions());
-  dict->SetInteger("total_buffers", trace_stats.total_buffers());
-  dict->SetInteger("chunks_discarded", trace_stats.chunks_discarded());
-  dict->SetInteger("patches_discarded", trace_stats.patches_discarded());
-  auto buf_list = std::make_unique<base::ListValue>();
-  for (const auto& buf_stats : trace_stats.buffer_stats()) {
-    base::Value buf_value(base::Value::Type::DICTIONARY);
-    base::DictionaryValue* buf_dict;
-    buf_value.GetAsDictionary(&buf_dict);
-    buf_dict->SetInteger("buffer_size", buf_stats.buffer_size());
-    buf_dict->SetInteger("bytes_written", buf_stats.bytes_written());
-    buf_dict->SetInteger("bytes_overwritten", buf_stats.bytes_overwritten());
-    buf_dict->SetInteger("bytes_read", buf_stats.bytes_read());
-    buf_dict->SetInteger("padding_bytes_written",
-                         buf_stats.padding_bytes_written());
-    buf_dict->SetInteger("padding_bytes_cleared",
-                         buf_stats.padding_bytes_cleared());
-    buf_dict->SetInteger("chunks_written", buf_stats.chunks_written());
-    buf_dict->SetInteger("chunks_rewritten", buf_stats.chunks_rewritten());
-    buf_dict->SetInteger("chunks_overwritten", buf_stats.chunks_overwritten());
-    buf_dict->SetInteger("chunks_discarded", buf_stats.chunks_discarded());
-    buf_dict->SetInteger("chunks_read", buf_stats.chunks_read());
-    buf_dict->SetInteger("chunks_committed_out_of_order",
-                         buf_stats.chunks_committed_out_of_order());
-    buf_dict->SetInteger("write_wrap_count", buf_stats.write_wrap_count());
-    buf_dict->SetInteger("patches_succeeded", buf_stats.patches_succeeded());
-    buf_dict->SetInteger("patches_failed", buf_stats.patches_failed());
-    buf_dict->SetInteger("readaheads_succeeded",
-                         buf_stats.readaheads_succeeded());
-    buf_dict->SetInteger("readaheads_failed", buf_stats.readaheads_failed());
-    buf_dict->SetInteger("abi_violations", buf_stats.abi_violations());
-    buf_list->GetList().push_back(std::move(buf_value));
-  }
-  dict->SetList("buffer_stats", std::move(buf_list));
-  metadata_->SetDictionary("perfetto_trace_stats", std::move(dict));
-}
-
-JSONTraceExporter::ScopedJSONTraceEventAppender
-JSONTraceExporter::AddTraceEvent(const char* name,
-                                 const char* categories,
-                                 int32_t phase,
-                                 int64_t timestamp,
-                                 int32_t pid,
-                                 int32_t tid) {
-  DCHECK(ShouldOutputTraceEvents());
-  return JSONTraceExporter::ScopedJSONTraceEventAppender(
-      AddJSONTraceEvent(), filter_args_, name, categories, phase, timestamp,
-      pid, tid);
-}
-
-JSONTraceExporter::StringBuffer* JSONTraceExporter::AddJSONTraceEvent() {
-  // If we've already added the first value in the TraceEvent array then we need
-  // a comma and add a newline for readability. Otherwise we're fine but update
-  // so in future we know we've finished the first event.
-  if (has_output_first_event_) {
-    out_ += ",\n";
-  } else {
-    has_output_first_event_ = true;
+    DCHECK(event.has_id());
+    switch (id_flags) {
+      case TRACE_EVENT_FLAG_HAS_ID:
+        base::StringAppendF(out, ",\"id\":\"0x%" PRIx64 "\"",
+                            static_cast<uint64_t>(event.id()));
+        break;
+
+      case TRACE_EVENT_FLAG_HAS_LOCAL_ID:
+        base::StringAppendF(out, ",\"id2\":{\"local\":\"0x%" PRIx64 "\"}",
+                            static_cast<uint64_t>(event.id()));
+        break;
+
+      case TRACE_EVENT_FLAG_HAS_GLOBAL_ID:
+        base::StringAppendF(out, ",\"id2\":{\"global\":\"0x%" PRIx64 "\"}",
+                            static_cast<uint64_t>(event.id()));
+        break;
+
+      default:
+        NOTREACHED() << "More than one of the ID flags are set";
+        break;
+    }
   }
-  return &out_;
-}
 
-JSONTraceExporter::StringBuffer::StringBuffer(
-    JSONTraceExporter::OnTraceEventJSONCallback callback)
-    : callback_(std::move(callback)) {
-  // Since we write each string before checking the limit, we'll
-  // always go slightly over and hence we reserve some extra space
-  // to avoid most reallocs.
-  const size_t kReserveCapacity = kTraceEventBufferSizeInBytes * 5 / 4;
-  out_.reserve(kReserveCapacity);
-}
+  if (event.flags() & TRACE_EVENT_FLAG_BIND_TO_ENCLOSING)
+    base::StringAppendF(out, ",\"bp\":\"e\"");
 
-JSONTraceExporter::StringBuffer::~StringBuffer() {}
+  if (event.has_bind_id()) {
+    base::StringAppendF(out, ",\"bind_id\":\"0x%" PRIx64 "\"",
+                        static_cast<uint64_t>(event.bind_id()));
+  }
 
-JSONTraceExporter::StringBuffer& JSONTraceExporter::StringBuffer::operator+=(
-    const std::string& input) {
-  MaybeRunCallback();
-  out_ += input;
-  return *this;
-}
+  if (event.flags() & TRACE_EVENT_FLAG_FLOW_IN)
+    base::StringAppendF(out, ",\"flow_in\":true");
+  if (event.flags() & TRACE_EVENT_FLAG_FLOW_OUT)
+    base::StringAppendF(out, ",\"flow_out\":true");
 
-JSONTraceExporter::StringBuffer& JSONTraceExporter::StringBuffer::operator+=(
-    std::string&& input) {
-  MaybeRunCallback();
-  out_ += std::move(input);
-  return *this;
-}
+  // Instant events also output their scope.
+  if (phase == TRACE_EVENT_PHASE_INSTANT) {
+    char scope = '?';
+    switch (event.flags() & TRACE_EVENT_FLAG_SCOPE_MASK) {
+      case TRACE_EVENT_SCOPE_GLOBAL:
+        scope = TRACE_EVENT_SCOPE_NAME_GLOBAL;
+        break;
 
-JSONTraceExporter::StringBuffer& JSONTraceExporter::StringBuffer::operator+=(
-    const char* input) {
-  MaybeRunCallback();
-  out_ += input;
-  return *this;
-}
+      case TRACE_EVENT_SCOPE_PROCESS:
+        scope = TRACE_EVENT_SCOPE_NAME_PROCESS;
+        break;
 
-std::string* JSONTraceExporter::StringBuffer::mutable_out() {
-  return &out_;
-}
+      case TRACE_EVENT_SCOPE_THREAD:
+        scope = TRACE_EVENT_SCOPE_NAME_THREAD;
+        break;
+    }
+    base::StringAppendF(out, ",\"s\":\"%c\"", scope);
+  }
 
-const std::string& JSONTraceExporter::StringBuffer::out() {
-  return out_;
-}
+  *out += ",\"args\":{";
+  for (int i = 0; i < event.args_size(); ++i) {
+    auto& arg = event.args(i);
 
-void JSONTraceExporter::StringBuffer::EscapeJSONAndAppend(
-    const std::string& unescaped) {
-  MaybeRunCallback();
-  base::EscapeJSONString(unescaped, true, &out_);
-}
+    if (i > 0) {
+      *out += ",";
+    }
 
-void JSONTraceExporter::StringBuffer::Flush(base::DictionaryValue* metadata,
-                                            bool has_more) {
-  callback_.Run(out_, metadata, has_more);
-  if (has_more) {
-    // We clear |out_| because we've processed all the current data in |out_|
-    // and we don't want any data to be repeated. We have to protect this by
-    // checking |has_more| because the callback could have deleted |this| in
-    // which cause |out_| is a destroyed as well.
-    out_.clear();
+    *out += "\"";
+    *out += arg.has_name_index()
+                ? GetStringFromStringTable(string_table, arg.name_index())
+                : arg.name();
+    *out += "\":";
+
+    TraceEvent::TraceValue value;
+    if (arg.has_bool_value()) {
+      value.as_bool = arg.bool_value();
+      TraceEvent::AppendValueAsJSON(TRACE_VALUE_TYPE_BOOL, value, out);
+      continue;
   }
-}
 
-void JSONTraceExporter::StringBuffer::MaybeRunCallback() {
-  // If the string has exceeded the threshold we send the current part back
-  // through the callback and clear the string to prevent it from getting to
-  // large.
-  if (out_.size() > kTraceEventBufferSizeInBytes) {
-    Flush(nullptr, true);
+    if (arg.has_uint_value()) {
+      value.as_uint = arg.uint_value();
+      TraceEvent::AppendValueAsJSON(TRACE_VALUE_TYPE_UINT, value, out);
+      continue;
   }
-}
 
-JSONTraceExporter::ArgumentBuilder::ArgumentBuilder(
-    bool filter_args,
-    const char* name,
-    const char* category_group_name,
-    StringBuffer* out)
-    : out_(out) {
-  strip_args_ = filter_args &&
-                !IsTraceEventArgsWhitelisted(category_group_name, name,
-                                             &argument_name_filter_predicate_);
-  *out_ += ",\"args\":";
-}
-
-JSONTraceExporter::ArgumentBuilder::~ArgumentBuilder() {
-  if (strip_args_ && has_args_) {
-    *out_ += "\"__stripped__\"";
-  } else if (!has_args_) {
-    *out_ += "{}";
-  } else {
-    *out_ += "}";
+    if (arg.has_int_value()) {
+      value.as_int = arg.int_value();
+      TraceEvent::AppendValueAsJSON(TRACE_VALUE_TYPE_INT, value, out);
+      continue;
   }
-}
 
-JSONTraceExporter::StringBuffer*
-JSONTraceExporter::ArgumentBuilder::MaybeAddArg(const std::string& name) {
-  if (SkipBecauseStripped(name)) {
-    return nullptr;
+    if (arg.has_double_value()) {
+      value.as_double = arg.double_value();
+      TraceEvent::AppendValueAsJSON(TRACE_VALUE_TYPE_DOUBLE, value, out);
+      continue;
   }
-  auto* buffer = AddArg();
-  buffer->AppendF("\"%s\":", name.c_str());
-  return buffer;
-}
 
-JSONTraceExporter::StringBuffer* JSONTraceExporter::ArgumentBuilder::AddArg() {
-  if (has_args_) {
-    *out_ += ",";
-  } else {
-    *out_ += "{";
-    has_args_ = true;
+    if (arg.has_pointer_value()) {
+      value.as_pointer = reinterpret_cast<void*>(arg.pointer_value());
+      TraceEvent::AppendValueAsJSON(TRACE_VALUE_TYPE_POINTER, value, out);
+      continue;
   }
-  return out_;
-}
 
-bool JSONTraceExporter::ArgumentBuilder::ArgumentNameIsStripped(
-    const std::string& name) {
-  return !argument_name_filter_predicate_.is_null() &&
-         !argument_name_filter_predicate_.Run(name.c_str());
-}
-
-bool JSONTraceExporter::ArgumentBuilder::SkipBecauseStripped(
-    const std::string& name) {
-  if (strip_args_) {
-    has_args_ = true;
-    return true;
-  }
-  if (ArgumentNameIsStripped(name)) {
-    AddArg()->AppendF("\"%s\":\"__stripped__\"", name.c_str());
-    return true;
-  }
-  return false;
-}
-
-JSONTraceExporter::ScopedJSONTraceEventAppender::ScopedJSONTraceEventAppender(
-    JSONTraceExporter::StringBuffer* out,
-    bool filter_args,
-    const char* name,
-    const char* categories,
-    int32_t phase,
-    int64_t timestamp,
-    int32_t pid,
-    int32_t tid)
-    : phase_(static_cast<char>(phase)),
-      added_args_(false),
-      out_(out),
-      event_name_(name),
-      category_group_name_(categories),
-      filter_args_(filter_args) {
-  out_->AppendF("{\"pid\":%i,\"tid\":%i,\"ts\":%" PRId64
-                ",\"ph\":\"%c\",\"cat\":\"%s\",\"name\":",
-                pid, tid, timestamp, phase_, categories);
-  out_->EscapeJSONAndAppend(name);
-}
+    if (arg.has_string_value()) {
+      std::string str = arg.string_value();
+      value.as_string = &str[0];
+      TraceEvent::AppendValueAsJSON(TRACE_VALUE_TYPE_STRING, value, out);
+      continue;
+    }
 
-JSONTraceExporter::ScopedJSONTraceEventAppender::ScopedJSONTraceEventAppender(
-    JSONTraceExporter::ScopedJSONTraceEventAppender&& move) {
-  out_ = move.out_;
-  phase_ = move.phase_;
-  filter_args_ = move.filter_args_;
-  // We null out the string so that the destructor knows not to append the
-  // closing brace for the json.
-  move.out_ = nullptr;
-}
+    if (arg.has_json_value()) {
+      *out += arg.json_value();
+      continue;
+    }
 
-JSONTraceExporter::ScopedJSONTraceEventAppender::
-    ~ScopedJSONTraceEventAppender() {
-  if (out_) {
-    // TraceEventAnalyzer expects |args| to exist even if it's empty.
-    if (!added_args_) {
-      *out_ += ",\"args\":{}";
+    if (arg.has_traced_value()) {
+      AppendProtoDictAsJSON(out, arg.traced_value());
+      continue;
     }
-    // Close out the starting bracket.
-    *out_ += "}";
+
+    NOTREACHED();
   }
-}
 
-void JSONTraceExporter::ScopedJSONTraceEventAppender::AddDuration(
-    int64_t duration) {
-  out_->AppendF(",\"dur\":%" PRId64, duration);
+  *out += "}}";
 }
 
-void JSONTraceExporter::ScopedJSONTraceEventAppender::AddThreadDuration(
-    int64_t thread_duration) {
-  out_->AppendF(",\"tdur\":%" PRId64, thread_duration);
+}  // namespace
+
+void AppendProtoDictAsJSON(std::string* out,
+                           const perfetto::protos::ChromeTracedValue& dict) {
+  out->append("{");
+
+  DCHECK_EQ(dict.dict_keys_size(), dict.dict_values_size());
+  for (int i = 0; i < dict.dict_keys_size(); ++i) {
+    if (i != 0) {
+      out->append(",");
+    }
+
+    base::EscapeJSONString(dict.dict_keys(i), true, out);
+    out->append(":");
+
+    AppendProtoValueAsJSON(out, dict.dict_values(i));
+  }
+
+  out->append("}");
+}
+
+JSONTraceExporter::JSONTraceExporter(const std::string& config,
+                                     perfetto::TracingService* service)
+    : config_(config), metadata_(std::make_unique<base::DictionaryValue>()) {
+  consumer_endpoint_ = service->ConnectConsumer(this, /*uid=*/0);
+
+  // Start tracing.
+  perfetto::TraceConfig trace_config;
+  trace_config.add_buffers()->set_size_kb(4096 * 100);
+
+  auto* trace_event_config = trace_config.add_data_sources()->mutable_config();
+  trace_event_config->set_name(mojom::kTraceEventDataSourceName);
+  trace_event_config->set_target_buffer(0);
+  auto* chrome_config = trace_event_config->mutable_chrome_config();
+  chrome_config->set_trace_config(config_);
+
+// Only CrOS and Cast support system tracing.
+#if defined(OS_CHROMEOS) || (defined(IS_CHROMECAST) && defined(OS_LINUX))
+  auto* system_trace_config = trace_config.add_data_sources()->mutable_config();
+  system_trace_config->set_name(mojom::kSystemTraceDataSourceName);
+  system_trace_config->set_target_buffer(0);
+  auto* system_chrome_config = system_trace_config->mutable_chrome_config();
+  system_chrome_config->set_trace_config(config_);
+#endif
+
+#if defined(OS_CHROMEOS)
+  auto* arc_trace_config = trace_config.add_data_sources()->mutable_config();
+  arc_trace_config->set_name(mojom::kArcTraceDataSourceName);
+  arc_trace_config->set_target_buffer(0);
+  auto* arc_chrome_config = arc_trace_config->mutable_chrome_config();
+  arc_chrome_config->set_trace_config(config_);
+#endif
+
+  auto* trace_metadata_config =
+      trace_config.add_data_sources()->mutable_config();
+  trace_metadata_config->set_name(mojom::kMetaDataSourceName);
+  trace_metadata_config->set_target_buffer(0);
+
+  consumer_endpoint_->EnableTracing(trace_config);
 }
 
-void JSONTraceExporter::ScopedJSONTraceEventAppender::AddThreadTimestamp(
-    int64_t thread_timestamp) {
-  out_->AppendF(",\"tts\":%" PRId64, thread_timestamp);
+JSONTraceExporter::~JSONTraceExporter() = default;
+
+void JSONTraceExporter::OnConnect() {}
+
+void JSONTraceExporter::OnDisconnect() {}
+
+void JSONTraceExporter::OnTracingDisabled() {
+  consumer_endpoint_->ReadBuffers();
 }
 
-void JSONTraceExporter::ScopedJSONTraceEventAppender::AddBindId(
-    uint64_t bind_id) {
-  out_->AppendF(",\"bind_id\":\"0x%" PRIx64 "\"",
-                static_cast<uint64_t>(bind_id));
+// This is called by the Coordinator interface, mainly used by the
+// TracingController which in turn is used by the tracing UI etc
+// to start/stop tracing.
+void JSONTraceExporter::StopAndFlush(OnTraceEventJSONCallback callback) {
+  DCHECK(!json_callback_ && callback);
+  json_callback_ = callback;
+
+  consumer_endpoint_->DisableTracing();
 }
 
-void JSONTraceExporter::ScopedJSONTraceEventAppender::AddFlags(
-    uint32_t flags,
-    base::Optional<uint64_t> id,
-    const std::string& scope) {
-  if (flags & TRACE_EVENT_FLAG_ASYNC_TTS) {
-    *out_ += ",\"use_async_tts\":1";
+void JSONTraceExporter::OnTraceData(std::vector<perfetto::TracePacket> packets,
+                                    bool has_more) {
+  DCHECK(json_callback_);
+  DCHECK(!packets.empty() || !has_more);
+
+  // Since we write each event before checking the limit, we'll
+  // always go slightly over and hence we reserve some extra space
+  // to avoid most reallocs.
+  const size_t kReserveCapacity = kTraceEventBufferSizeInBytes * 5 / 4;
+  std::string out;
+  out.reserve(kReserveCapacity);
+
+  if (!has_output_json_preamble_) {
+    out = "{\"traceEvents\":[";
+    has_output_json_preamble_ = true;
   }
 
-  // If |id| is set, print it out as a hex string so we don't loose any
-  // bits (it might be a 64-bit pointer).
-  unsigned int id_flags =
-      flags & (TRACE_EVENT_FLAG_HAS_ID | TRACE_EVENT_FLAG_HAS_LOCAL_ID |
-               TRACE_EVENT_FLAG_HAS_GLOBAL_ID);
-  if (id_flags) {
-    if (!scope.empty()) {
-      out_->AppendF(",\"scope\":\"%s\"", scope.c_str());
+  for (auto& encoded_packet : packets) {
+    perfetto::protos::ChromeTracePacket packet;
+    bool decoded = encoded_packet.Decode(&packet);
+    DCHECK(decoded);
+
+    if (!packet.has_chrome_events()) {
+      continue;
     }
 
-    DCHECK(id);
-    switch (id_flags) {
-      case TRACE_EVENT_FLAG_HAS_ID:
-        out_->AppendF(",\"id\":\"0x%" PRIx64 "\"", static_cast<uint64_t>(*id));
-        break;
+    auto& bundle = packet.chrome_events();
 
-      case TRACE_EVENT_FLAG_HAS_LOCAL_ID:
-        out_->AppendF(",\"id2\":{\"local\":\"0x%" PRIx64 "\"}",
-                      static_cast<uint64_t>(*id));
-        break;
+    std::unordered_map<int, std::string> string_table;
+    for (auto& string_table_entry : bundle.string_table()) {
+      string_table[string_table_entry.index()] = string_table_entry.value();
+    }
 
-      case TRACE_EVENT_FLAG_HAS_GLOBAL_ID:
-        out_->AppendF(",\"id2\":{\"global\":\"0x%" PRIx64 "\"}",
-                      static_cast<uint64_t>(*id));
-        break;
+    for (auto& event : bundle.trace_events()) {
+      if (out.size() > kTraceEventBufferSizeInBytes) {
+        json_callback_.Run(out, nullptr, true);
+        out.clear();
+      }
 
-      default:
-        NOTREACHED() << "More than one of the ID flags are set";
-        break;
+      if (has_output_first_event_) {
+        out += ",\n";
+      } else {
+        has_output_first_event_ = true;
     }
+
+      OutputJSONFromTraceEventProto(event, &out, string_table);
   }
 
-  if (flags & TRACE_EVENT_FLAG_BIND_TO_ENCLOSING)
-    *out_ += ",\"bp\":\"e\"";
+    for (auto& metadata : bundle.metadata()) {
+      if (metadata.has_string_value()) {
+        metadata_->SetString(metadata.name(), metadata.string_value());
+      } else if (metadata.has_int_value()) {
+        metadata_->SetInteger(metadata.name(), metadata.int_value());
+      } else if (metadata.has_bool_value()) {
+        metadata_->SetBoolean(metadata.name(), metadata.bool_value());
+      } else if (metadata.has_json_value()) {
+        std::unique_ptr<base::Value> value(
+            base::JSONReader::Read(metadata.json_value()));
+        metadata_->Set(metadata.name(), std::move(value));
+      } else {
+        NOTREACHED();
+      }
+    }
 
-  if (flags & TRACE_EVENT_FLAG_FLOW_IN)
-    *out_ += ",\"flow_in\":true";
-  if (flags & TRACE_EVENT_FLAG_FLOW_OUT)
-    *out_ += ",\"flow_out\":true";
+    for (auto& legacy_ftrace_output : bundle.legacy_ftrace_output()) {
+      legacy_system_ftrace_output_ += legacy_ftrace_output;
+    }
 
-  // Instant events also output their scope.
-  if (phase_ == TRACE_EVENT_PHASE_INSTANT) {
-    char scope = '?';
-    switch (flags & TRACE_EVENT_FLAG_SCOPE_MASK) {
-      case TRACE_EVENT_SCOPE_GLOBAL:
-        scope = TRACE_EVENT_SCOPE_NAME_GLOBAL;
+    for (auto& legacy_json_trace : bundle.legacy_json_trace()) {
+      // Tracing agents should only add this field when there is some data.
+      DCHECK(!legacy_json_trace.data().empty());
+      switch (legacy_json_trace.type()) {
+        case perfetto::protos::ChromeLegacyJsonTrace::USER_TRACE:
+          if (has_output_first_event_) {
+            out += ",\n";
+          } else {
+            has_output_first_event_ = true;
+          }
+          out += legacy_json_trace.data();
         break;
-
-      case TRACE_EVENT_SCOPE_PROCESS:
-        scope = TRACE_EVENT_SCOPE_NAME_PROCESS;
+        case perfetto::protos::ChromeLegacyJsonTrace::SYSTEM_TRACE:
+          if (legacy_system_trace_events_.empty()) {
+            legacy_system_trace_events_ = "{";
+          } else {
+            legacy_system_trace_events_ += ",";
+          }
+          legacy_system_trace_events_ += legacy_json_trace.data();
         break;
+        default:
+          NOTREACHED();
+      }
+    }
+  }
 
-      case TRACE_EVENT_SCOPE_THREAD:
-        scope = TRACE_EVENT_SCOPE_NAME_THREAD;
-        break;
+  if (!has_more) {
+    out += "]";
+
+    if (!legacy_system_ftrace_output_.empty() ||
+        !legacy_system_trace_events_.empty()) {
+      // Should only have system events (e.g. ETW) or system ftrace output.
+      DCHECK(legacy_system_ftrace_output_.empty() ||
+             legacy_system_trace_events_.empty());
+      out += ",\"systemTraceEvents\":";
+      if (!legacy_system_ftrace_output_.empty()) {
+        std::string escaped;
+        base::EscapeJSONString(legacy_system_ftrace_output_,
+                               true /* put_in_quotes */, &escaped);
+        out += escaped;
+      } else {
+        out += legacy_system_trace_events_ + "}";
     }
-    out_->AppendF(",\"s\":\"%c\"", scope);
   }
+
+    if (!metadata_->empty()) {
+      out += ",\"metadata\":";
+      std::string json_value;
+      base::JSONWriter::Write(*metadata_, &json_value);
+      out += json_value;
+    }
+
+    out += "}";
+  }
+
+  json_callback_.Run(out, metadata_.get(), has_more);
+}
+
+// Consumer Detach / Attach is not used in Chrome.
+void JSONTraceExporter::OnDetach(bool) {
+  NOTREACHED();
 }
 
-std::unique_ptr<JSONTraceExporter::ArgumentBuilder>
-JSONTraceExporter::ScopedJSONTraceEventAppender::BuildArgs() {
-  DCHECK(!added_args_);
-  added_args_ = true;
-  return std::make_unique<ArgumentBuilder>(filter_args_, event_name_,
-                                           category_group_name_, out_);
+void JSONTraceExporter::OnAttach(bool, const perfetto::TraceConfig&) {
+  NOTREACHED();
 }
+
+void JSONTraceExporter::OnTraceStats(bool, const perfetto::TraceStats&) {
+  // We don't currently use GetTraceStats().
+  NOTREACHED();
+}
+
 }  // namespace tracing
--- a/services/tracing/perfetto/json_trace_exporter.h	2019-05-01 01:22:57.000000000 +0300
+++ b/services/tracing/perfetto/json_trace_exporter.h	2019-05-17 18:53:38.012000000 +0300
@@ -7,238 +7,70 @@
 
 #include <memory>
 #include <string>
-#include <unordered_map>
-#include <utility>
 #include <vector>
 
 #include "base/callback.h"
 #include "base/macros.h"
-#include "base/strings/stringprintf.h"
 #include "base/values.h"
-#include "third_party/perfetto/include/perfetto/tracing/core/trace_packet.h"
+#include "third_party/perfetto/include/perfetto/tracing/core/consumer.h"
+#include "third_party/perfetto/include/perfetto/tracing/core/tracing_service.h"
 
 namespace perfetto {
 namespace protos {
-class ChromeLegacyJsonTrace;
-class ChromeMetadata;
-class TraceStats;
+class ChromeTracedValue;
 }  // namespace protos
 }  // namespace perfetto
 
 namespace tracing {
 
-// Converts proto-encoded trace data into the legacy JSON trace format.
-// Conversion happens on-the-fly as new trace packets are received.
-class JSONTraceExporter {
+// Serializes the supplied proto into JSON, using the same
+// format as TracedValue::AppendAsTraceFormat.
+void AppendProtoDictAsJSON(std::string* out,
+                           const perfetto::protos::ChromeTracedValue& dict);
+
+// This is a Perfetto consumer which will enable Perfetto tracing
+// and subscribe to ChromeTraceEvent data sources. Any received
+// protos will be converted to the legacy JSON Chrome Tracing
+// format.
+class JSONTraceExporter : public perfetto::Consumer {
  public:
-  // Given argument name for the trace event, returns if the argument should be
-  // filtered or not.
-  using ArgumentNameFilterPredicate =
-      base::RepeatingCallback<bool(const char* arg_name)>;
+  // The owner of JSONTraceExporter should make sure to destroy
+  // |service| before destroying this.
+  JSONTraceExporter(const std::string& config,
+                    perfetto::TracingService* service);
+
+  ~JSONTraceExporter() override;
 
   using OnTraceEventJSONCallback =
       base::RepeatingCallback<void(const std::string& json,
                                    base::DictionaryValue* metadata,
                                    bool has_more)>;
+  void StopAndFlush(OnTraceEventJSONCallback callback);
 
-  JSONTraceExporter(bool filter_args, OnTraceEventJSONCallback callback);
-  virtual ~JSONTraceExporter();
-
-  // Called to notify the exporter of new trace packets. Will call the
-  // |json_callback| passed in the constructor with the converted trace data.
-  void OnTraceData(std::vector<perfetto::TracePacket> packets, bool has_more);
-
-  void set_filter_args_for_testing(bool value) { filter_args_ = value; }
-
-  void set_label_filter(const std::string& label_filter) {
-    label_filter_ = label_filter;
-  }
-
- protected:
-  class StringBuffer {
-   public:
-    StringBuffer(OnTraceEventJSONCallback callback);
-    StringBuffer(const StringBuffer& copy) = delete;
-    StringBuffer(StringBuffer&& move);
-    ~StringBuffer();
-
-    StringBuffer& operator+=(const std::string& input);
-
-    StringBuffer& operator+=(std::string&& input);
-
-    StringBuffer& operator+=(const char* input);
-
-    std::string* mutable_out();
-    const std::string& out();
-
-    template <typename... Args>
-    void AppendF(const char* format, Args&&... args) {
-      MaybeRunCallback();
-      base::StringAppendF(&out_, format, std::forward<Args>(args)...);
-    }
-
-    void EscapeJSONAndAppend(const std::string& unescaped);
-
-    void Flush(base::DictionaryValue* metadata, bool has_more);
+  // perfetto::Consumer implementation.
+  // This gets called by the Perfetto service as control signals,
+  // and to send finished protobufs over.
+  void OnConnect() override;
+  void OnDisconnect() override;
+  void OnTracingDisabled() override;
+  void OnTraceData(std::vector<perfetto::TracePacket> packets,
+                   bool has_more) override;
+  void OnDetach(bool success) override;
+  void OnAttach(bool success, const perfetto::TraceConfig&) override;
+  void OnTraceStats(bool success, const perfetto::TraceStats&) override;
 
    private:
-    // Depending on the size of the current output we might need to send a part
-    // of it back.
-    void MaybeRunCallback();
-
-    std::string out_;
-    OnTraceEventJSONCallback callback_;
-  };
-
-  class ArgumentBuilder {
-   public:
-    ArgumentBuilder(bool filter_args,
-                    const char* name,
-                    const char* category_group_name,
-                    StringBuffer* out);
-    ~ArgumentBuilder();
-
-    // Takes an arg name, and returns nullptr if
-    //
-    // a) all args are being stripped
-    // b) if this arg name was stripped.
-    //
-    // If the StringBuffer pointer is valid then you should append a string that
-    // is properly formatted json for this arg value.
-    StringBuffer* MaybeAddArg(const std::string& name);
-
-   private:
-    StringBuffer* AddArg();
-    bool ArgumentNameIsStripped(const std::string& name);
-    bool SkipBecauseStripped(const std::string& name);
-
-    StringBuffer* out_;
-    bool strip_args_ = false;
-    bool has_args_ = false;
-    ArgumentNameFilterPredicate argument_name_filter_predicate_;
-  };
-
-  // Adds all required fields to |out| in proper JSON format. Only one
-  // ScopedJSONTraceEventAppender should exist per |out| string at a time,
-  // since the TraceEvent will not be finished until the
-  // ScopedJSONTraceEventAppender goes out of scope.
-  class ScopedJSONTraceEventAppender {
-   public:
-    // Only one reference should exist at a time. So moving is okay but copying
-    // is disallowed.
-    ScopedJSONTraceEventAppender(ScopedJSONTraceEventAppender&& move);
-    ScopedJSONTraceEventAppender(const ScopedJSONTraceEventAppender& copy) =
-        delete;
-
-    // Ensures that the JSON object is properly closed.
-    ~ScopedJSONTraceEventAppender();
-
-    // Optional traceEvent fields can also be set with the methods below. All
-    // methods should only be called once.
-
-    void AddDuration(int64_t duration);
-    void AddThreadDuration(int64_t thread_duration);
-    void AddThreadTimestamp(int64_t thread_timestamp);
-    void AddBindId(uint64_t bind_id);
-    // A set of bit flags for this trace event, along with a |scope|. |scope| is
-    // ignored if empty.
-    void AddFlags(uint32_t flags,
-                  base::Optional<uint64_t> id,
-                  const std::string& scope);
-
-    // Begins constructing the args sections, and finishes when ArgumentBuilder
-    // is destroyed. No other Add* function should be called until
-    // ArgumentBuilder goes out of scope.
-    //
-    // This should be used as follows.
-    // {
-    //   auto arg_builder = scoped_appender.BuildArgs();
-    //   for (const auto& arg : args) {
-    //     JSONTraceExporter::StringBuffer* maybe_arg =
-    //         arg_builder->MaybeAddArg(arg.name);
-    //     if (maybe_arg) {
-    //       // Then one of the following to add the value in |arg|.
-    //       *maybe_arg += "\"json_formatted_raw_value\"";
-    //       maybe_arg->AppendF("\"%d\"", arg.integer);
-    //       maybe_arg->EscapeJSONAndAppend("json_that will be : escaped");
-    //     }
-    //   }
-    // }
-    //
-    // IMPORTANT: ArgumentBuilder must be deconstructed before the
-    // ScopedJSONTraceEventAppender that created it is.
-    std::unique_ptr<ArgumentBuilder> BuildArgs();
-
-   private:
-    // Subclasses of JSONTraceExporter can create a new instance by calling
-    // AddTraceEvent().
-    ScopedJSONTraceEventAppender(StringBuffer* out,
-                                 bool filter_args,
-                                 const char* name,
-                                 const char* categories,
-                                 int32_t phase,
-                                 int64_t timestamp,
-                                 int32_t pid,
-                                 int32_t tid);
-    friend class JSONTraceExporter;
-
-    char phase_;
-    bool added_args_;
-    StringBuffer* out_;
-    const char* event_name_;
-    const char* category_group_name_;
-    bool filter_args_;
-  };
-
-  // Subclasses implement this to add data from |packets| to the JSON output.
-  // For example they can add traceEvents through AddTraceEvent(), or add
-  // metadata through AddChromeMetadata().
-  virtual void ProcessPackets(
-      const std::vector<perfetto::TracePacket>& packets) = 0;
-
-  // If true then all trace events should be skipped. AddTraceEvent should not
-  // be called.
-  bool ShouldOutputTraceEvents() const;
-
-  // Used for passing legacy JSON traces. This will update either the
-  // traceEvents directly if needed by calling AddJSONTraceEvent or will store
-  // the system trace information to be appended after the packets have been
-  // processed.
-  void AddChromeLegacyJSONTrace(
-      const perfetto::protos::ChromeLegacyJsonTrace& json_trace);
-  // Adds system Ftrace data to be appended to the trace JSON after all the
-  // traceEvents have been processed.
-  void AddLegacyFtrace(const std::string& legacy_ftrace_output);
-  // Used to append ChromeMetadata to the trace. Can be called at any point.
-  // Metadata is always appended after all packets have been processed.
-  void AddChromeMetadata(const perfetto::protos::ChromeMetadata& metadata);
-  // Writes (overwriting if already set) the perfetto trace stats to the
-  // metadata that will be appended after all packets have been processed.
-  void SetTraceStatsMetadata(const perfetto::protos::TraceStats& stats);
-
-  // Used when sub-classes are adding a new trace event to the traceEvents
-  // array. This will ensure that only proper json is appended.
-  ScopedJSONTraceEventAppender AddTraceEvent(const char* name,
-                                             const char* categories,
-                                             int32_t phase,
-                                             int64_t timestamp,
-                                             int32_t pid,
-                                             int32_t tid);
-
- private:
-  // Used by the implementation to ensure the proper separators exist between
-  // trace events in the array.
-  StringBuffer* AddJSONTraceEvent();
-
-  StringBuffer out_;
-  bool has_output_first_event_ = false;
+  OnTraceEventJSONCallback json_callback_;
   bool has_output_json_preamble_ = false;
-  std::string legacy_system_trace_events_;
-  std::string label_filter_;
-  std::string legacy_system_ftrace_output_;
+  bool has_output_first_event_ = false;
+  std::string config_;
   std::unique_ptr<base::DictionaryValue> metadata_;
-  bool filter_args_;
+  std::string legacy_system_ftrace_output_;
+  std::string legacy_system_trace_events_;
 
+  // Keep last to avoid edge-cases where its callbacks come in mid-destruction.
+  std::unique_ptr<perfetto::TracingService::ConsumerEndpoint>
+      consumer_endpoint_;
   DISALLOW_COPY_AND_ASSIGN(JSONTraceExporter);
 };
 
--- a/services/tracing/perfetto/json_trace_exporter_unittest.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/tracing/perfetto/json_trace_exporter_unittest.cc	2019-05-17 18:53:38.012000000 +0300
@@ -13,193 +13,159 @@
 #include "base/logging.h"
 #include "base/message_loop/message_loop.h"
 #include "base/run_loop.h"
-#include "base/strings/pattern.h"
-#include "base/strings/stringprintf.h"
 #include "base/test/trace_event_analyzer.h"
 #include "base/trace_event/trace_event.h"
 #include "base/values.h"
-#include "services/tracing/public/mojom/perfetto_service.mojom.h"
 #include "testing/gtest/include/gtest/gtest.h"
+
+#include "services/tracing/public/mojom/perfetto_service.mojom.h"
 #include "third_party/perfetto/include/perfetto/tracing/core/trace_config.h"
 #include "third_party/perfetto/include/perfetto/tracing/core/trace_packet.h"
-#include "third_party/perfetto/protos/perfetto/trace/chrome/chrome_trace_event.pb.h"
+#include "third_party/perfetto/protos/perfetto/trace/chrome/chrome_trace_event.pbzero.h"
 #include "third_party/perfetto/protos/perfetto/trace/trace_packet.pb.h"
 
-using base::trace_event::TraceLog;
-
 namespace tracing {
 
-namespace {
+class MockService : public perfetto::TracingService {
+ public:
+  explicit MockService(base::MessageLoop* message_loop);
 
-struct ArgValue {
-  ArgValue(int64_t val) : int_val(val), type(ArgType::kInt) {}
-  ArgValue(uint64_t val) : uint_val(val), type(ArgType::kUint) {}
-  ArgValue(double val) : double_val(val), type(ArgType::kDouble) {}
-  ArgValue(std::string val) : string_val(val), type(ArgType::kString) {}
-  ArgValue(bool val) : bool_val(val), type(ArgType::kBool) {}
-  ArgValue(base::Value* val) : value_val(val), type(ArgType::kValue) {}
-
-  int64_t int_val;
-  uint64_t uint_val;
-  double double_val;
-  std::string string_val;
-  bool bool_val;
-  base::Value* value_val;
-  enum class ArgType { kInt, kUint, kDouble, kString, kBool, kValue };
-  ArgType type;
-};
+  void OnTracingEnabled(const std::string& config);
+  void WaitForTracingEnabled();
 
-struct FakeTraceInfo {
-  FakeTraceInfo(const std::string& e,
-                const std::string& c,
-                char p,
-                int64_t t,
-                int32_t pi,
-                int32_t ti)
-      : event_name(e),
-        category_group_names(c),
-        phase(p),
-        timestamp(t),
-        pid(pi),
-        tid(ti) {}
-
-  // Required values.
-  std::string event_name;
-  std::string category_group_names;
-  char phase;
-  int64_t timestamp;
-  int32_t pid;
-  int32_t tid;
-
-  // Optional values.
-  base::Optional<int64_t> duration;
-  base::Optional<int64_t> thread_duration;
-  base::Optional<int64_t> thread_timestamp;
-  base::Optional<int64_t> bind_id;
-  base::Optional<int32_t> flags;
-  base::Optional<int64_t> id;
-  base::Optional<std::string> scope;
-  std::vector<std::pair<std::string, ArgValue>> args;
-};
+  void OnTracingDisabled();
+  void WaitForTracingDisabled();
 
-class TestJSONTraceExporter : public JSONTraceExporter {
- public:
-  TestJSONTraceExporter(bool filter_args, OnTraceEventJSONCallback callback)
-      : JSONTraceExporter(filter_args, std::move(callback)) {}
-  ~TestJSONTraceExporter() override = default;
-
-  int process_packets_calls() const { return process_packets_calls_; }
-
-  void SetFakeTraceEvents(const std::vector<FakeTraceInfo>& values) {
-    infos_ = values;
-  }
-
-  std::vector<perfetto::protos::ChromeLegacyJsonTrace> json_traces;
-  std::vector<std::string> legacy_ftrace_output;
-  std::vector<perfetto::protos::ChromeMetadata> metadata;
-  std::vector<perfetto::protos::TraceStats> stats;
-
- protected:
-  void ProcessPackets(
-      const std::vector<perfetto::TracePacket>& packets) override {
-    ++process_packets_calls_;
-    DCHECK(packets.size() == infos_.size())
-        << " different sizes of packets versus expected behaviour test set up "
-        << "error.";
-    for (const auto& event : infos_) {
-      auto scoped_builder = AddTraceEvent(
-          event.event_name.c_str(), event.category_group_names.c_str(),
-          event.phase, event.timestamp, event.pid, event.tid);
-      if (event.duration) {
-        scoped_builder.AddDuration(*event.duration);
-      }
-      if (event.thread_duration) {
-        scoped_builder.AddThreadDuration(*event.thread_duration);
-      }
-      if (event.thread_timestamp) {
-        scoped_builder.AddThreadTimestamp(*event.thread_timestamp);
-      }
-      if (event.bind_id) {
-        scoped_builder.AddBindId(*event.bind_id);
-      }
-      if (event.flags) {
-        scoped_builder.AddFlags(*event.flags, event.id.value_or(0),
-                                event.scope.value_or(""));
-      }
-      if (!event.args.empty()) {
-        auto args_builder = scoped_builder.BuildArgs();
-        for (const auto& arg : event.args) {
-          const std::string& name = std::get<0>(arg);
-          const ArgValue val = std::get<1>(arg);
-          auto* maybe_arg = args_builder->MaybeAddArg(name);
-          std::string temp;
-          if (maybe_arg) {
-            switch (val.type) {
-              case ArgValue::ArgType::kInt:
-                *maybe_arg += std::to_string(val.int_val);
-                break;
-              case ArgValue::ArgType::kUint:
-                *maybe_arg += std::to_string(val.uint_val);
-                break;
-              case ArgValue::ArgType::kDouble:
-                *maybe_arg += std::to_string(val.double_val);
-                break;
-              case ArgValue::ArgType::kString:
-                *maybe_arg += val.string_val;
-                break;
-              case ArgValue::ArgType::kBool:
-                *maybe_arg += val.bool_val ? "true" : "false";
-                break;
-              case ArgValue::ArgType::kValue:
-                temp.clear();
-                base::JSONWriter::Write(*val.value_val, &temp);
-                *maybe_arg += temp;
-                break;
-            }
-          }
-        }
-      }
+  const std::string& tracing_enabled_with_config() const {
+    return tracing_enabled_with_config_;
     }
 
-    for (const auto& value : json_traces) {
-      AddChromeLegacyJSONTrace(value);
-    }
-    for (const auto& value : legacy_ftrace_output) {
-      AddLegacyFtrace(value);
-    }
-    for (const auto& value : metadata) {
-      AddChromeMetadata(value);
-    }
-    for (const auto& value : stats) {
-      SetTraceStatsMetadata(value);
-    }
-  }
+  // perfetto::TracingService implementation.
+  std::unique_ptr<ProducerEndpoint> ConnectProducer(
+      perfetto::Producer*,
+      uid_t uid,
+      const std::string& name,
+      size_t shared_buffer_size_hint_bytes = 0) override;
+
+  std::unique_ptr<ConsumerEndpoint> ConnectConsumer(perfetto::Consumer*,
+                                                    uid_t) override;
+
+  void SetSMBScrapingEnabled(bool enabled) override;
+
+ private:
+  base::MessageLoop* message_loop_;
+
+  base::RunLoop wait_for_tracing_enabled_;
+  base::RunLoop wait_for_tracing_disabled_;
+  std::string tracing_enabled_with_config_;
+};
+
+class MockConsumerEndpoint : public perfetto::TracingService::ConsumerEndpoint {
+ public:
+  explicit MockConsumerEndpoint(MockService* mock_service)
+      : mock_service_(mock_service) {
+    CHECK(mock_service);
+  }
+
+  void EnableTracing(
+      const perfetto::TraceConfig& config,
+      perfetto::base::ScopedFile = perfetto::base::ScopedFile()) override {
+    EXPECT_EQ(mojom::kTraceEventDataSourceName,
+              config.data_sources()[0].config().name());
+    mock_service_->OnTracingEnabled(
+        config.data_sources()[0].config().chrome_config().trace_config());
+  }
+  void DisableTracing() override { mock_service_->OnTracingDisabled(); }
+  void ReadBuffers() override {}
+  void FreeBuffers() override {}
+  void Flush(uint32_t timeout_ms, FlushCallback callback) override {
+    callback(true);
+  }
+
+  // Unused in chrome, only meaningful when using TraceConfig.deferred_start.
+  void StartTracing() override {}
+
+  // Unused in chrome.
+  void Detach(const std::string& /*key*/) override {}
+  void Attach(const std::string& /*key*/) override {}
+  void GetTraceStats() override {}
 
  private:
-  int process_packets_calls_ = 0;
-  std::vector<FakeTraceInfo> infos_;
+  MockService* mock_service_;
 };
 
-}  // namespace
+MockService::MockService(base::MessageLoop* message_loop)
+    : message_loop_(message_loop) {
+  DCHECK(message_loop);
+}
+
+void MockService::OnTracingEnabled(const std::string& config) {
+  tracing_enabled_with_config_ = config;
+  wait_for_tracing_enabled_.Quit();
+}
+
+void MockService::WaitForTracingEnabled() {
+  wait_for_tracing_enabled_.Run();
+}
+
+void MockService::OnTracingDisabled() {
+  wait_for_tracing_disabled_.Quit();
+}
 
-class JsonTraceExporterTest : public testing::Test {
+void MockService::WaitForTracingDisabled() {
+  wait_for_tracing_disabled_.Run();
+}
+
+void MockService::SetSMBScrapingEnabled(bool enabled) {}
+
+// perfetto::TracingService implementation.
+std::unique_ptr<perfetto::TracingService::ProducerEndpoint>
+MockService::ConnectProducer(perfetto::Producer*,
+                             uid_t uid,
+                             const std::string& name,
+                             size_t shared_buffer_size_hint_bytes) {
+  NOTREACHED();
+  return nullptr;
+}
+
+std::unique_ptr<perfetto::TracingService::ConsumerEndpoint>
+MockService::ConnectConsumer(perfetto::Consumer* consumer, uid_t) {
+  message_loop_->task_runner()->PostTask(
+      FROM_HERE, base::BindOnce(&perfetto::Consumer::OnConnect,
+                                base::Unretained(consumer)));
+
+  return std::make_unique<MockConsumerEndpoint>(this);
+}
+
+class JSONTraceExporterTest : public testing::Test {
  public:
-  JsonTraceExporterTest()
-      : json_trace_exporter_(new TestJSONTraceExporter(
-            /* filter_args =*/false,
-            base::BindRepeating(&JsonTraceExporterTest::OnTraceEventJSON,
-                                base::Unretained(this)))) {}
+  void SetUp() override {
+    message_loop_ = std::make_unique<base::MessageLoop>();
+    service_ = std::make_unique<MockService>(message_loop_.get());
+  }
+
+  void TearDown() override {
+    service_.reset();
+    json_trace_exporter_.reset();
+    message_loop_.reset();
+  }
+
+  void CreateJSONTraceExporter(const std::string& config) {
+    json_trace_exporter_.reset(new JSONTraceExporter(config, service_.get()));
+  }
+
+  void StopAndFlush() {
+    json_trace_exporter_->StopAndFlush(base::BindRepeating(
+        &JSONTraceExporterTest::OnTraceEventJSON, base::Unretained(this)));
+  }
 
   void OnTraceEventJSON(const std::string& json,
                         base::DictionaryValue* metadata,
                         bool has_more) {
-    unparsed_trace_data_ += json;
-    unparsed_trace_data_sequence_.push_back(json);
-    if (has_more) {
-      return;
-    }
-    parsed_trace_data_ = base::DictionaryValue::From(
-        base::JSONReader::ReadDeprecated(unparsed_trace_data_));
+    CHECK(!has_more);
+
+    parsed_trace_data_ =
+        base::DictionaryValue::From(base::JSONReader::Read(json));
     EXPECT_TRUE(parsed_trace_data_);
     if (!parsed_trace_data_) {
       LOG(ERROR) << "Couldn't parse json: \n" << json;
@@ -213,429 +179,625 @@
     base::JSONWriter::Write(*events_value, &raw_events);
 
     trace_analyzer_.reset(trace_analyzer::TraceAnalyzer::Create(raw_events));
-    EXPECT_TRUE(trace_analyzer_);
   }
 
-  std::string unparsed_trace_data_;
-  std::vector<std::string> unparsed_trace_data_sequence_;
-  std::unique_ptr<TestJSONTraceExporter> json_trace_exporter_;
-  std::unique_ptr<trace_analyzer::TraceAnalyzer> trace_analyzer_;
-  std::unique_ptr<base::DictionaryValue> parsed_trace_data_;
-};
+  void SetTestPacketBasicData(
+      perfetto::protos::ChromeTraceEvent* new_trace_event) {
+    new_trace_event->set_name("foo_name");
+    new_trace_event->set_timestamp(42);
+    new_trace_event->set_flags(TRACE_EVENT_FLAG_HAS_GLOBAL_ID |
+                               TRACE_EVENT_FLAG_FLOW_OUT);
+
+    new_trace_event->set_process_id(2);
+    new_trace_event->set_thread_id(3);
+    new_trace_event->set_category_group_name("cat_name");
+    new_trace_event->set_phase(TRACE_EVENT_PHASE_COMPLETE);
+    new_trace_event->set_duration(4);
+    new_trace_event->set_thread_duration(5);
+    new_trace_event->set_thread_timestamp(6);
+    new_trace_event->set_id(7);
+    new_trace_event->set_bind_id(8);
+
+    std::string scope;
+    scope += TRACE_EVENT_SCOPE_NAME_GLOBAL;
+    new_trace_event->set_scope(scope);
+  }
+
+  void FinalizePacket(const perfetto::protos::TracePacket& trace_packet_proto) {
+    perfetto::TracePacket trace_packet;
+    std::string ser_buf = trace_packet_proto.SerializeAsString();
+    trace_packet.AddSlice(&ser_buf[0], ser_buf.size());
 
-TEST_F(JsonTraceExporterTest, TestNoTraceEvents) {
-  json_trace_exporter_->OnTraceData(std::vector<perfetto::TracePacket>(),
-                                    false);
-  EXPECT_EQ("{\"traceEvents\":[]}", unparsed_trace_data_);
-}
+    std::vector<perfetto::TracePacket> packets;
+    packets.emplace_back(std::move(trace_packet));
 
-TEST_F(JsonTraceExporterTest, TestBasic) {
-  std::vector<FakeTraceInfo> infos = {FakeTraceInfo(
-      "name", "cat", 'B', /* timestamp = */ 1, /* pid = */ 2, /* tid = */ 3)};
-  json_trace_exporter_->SetFakeTraceEvents(infos);
-  json_trace_exporter_->OnTraceData(
-      std::vector<perfetto::TracePacket>(infos.size()), false);
-  EXPECT_EQ(
-      "{\"traceEvents\":[{\"pid\":2,\"tid\":3,\"ts\":1,\"ph\":\"B\","
-      "\"cat\":\"cat\",\"name\":\"name\",\"args\":{}}]}",
-      unparsed_trace_data_);
-  const trace_analyzer::TraceEvent* trace_event = trace_analyzer_->FindFirstOf(
-      trace_analyzer::Query(trace_analyzer::Query::EVENT_NAME) ==
-      trace_analyzer::Query::String("name"));
-  EXPECT_TRUE(trace_event);
-  EXPECT_EQ(2, trace_event->thread.process_id);
-  EXPECT_EQ(3, trace_event->thread.thread_id);
-  EXPECT_EQ(1, trace_event->timestamp);
-  EXPECT_EQ('B', trace_event->phase);
-  EXPECT_EQ("name", trace_event->name);
-  EXPECT_EQ("cat", trace_event->category);
-}
-
-TEST_F(JsonTraceExporterTest, TestAllTraceEventButFlagsAndArgs) {
-  // Duration is only parsed if the phase is correct in this case 'X'.
-  std::vector<FakeTraceInfo> infos = {FakeTraceInfo("name_all", "cat_all", 'X',
-                                                    /* timestamp = */ 1,
-                                                    /* pid = */ 2,
-                                                    /* tid = */ 3)};
-  infos[0].duration = 4;
-  infos[0].thread_duration = 5;
-  infos[0].thread_timestamp = 6;
-  infos[0].bind_id = 7;
-  json_trace_exporter_->SetFakeTraceEvents(infos);
-  json_trace_exporter_->OnTraceData(
-      std::vector<perfetto::TracePacket>(infos.size()), false);
-  EXPECT_EQ(
-      "{\"traceEvents\":[{\"pid\":2,\"tid\":3,\"ts\":1,\"ph\":\"X\","
-      "\"cat\":\"cat_all\",\"name\":\"name_all\",\"dur\":4,\"tdur\":5,"
-      "\"tts\":6,\"bind_id\":\"0x7\",\"args\":{}}]}",
-      unparsed_trace_data_);
-  const trace_analyzer::TraceEvent* trace_event = trace_analyzer_->FindFirstOf(
+    json_trace_exporter_->OnTraceData(std::move(packets), false);
+  }
+
+  const trace_analyzer::TraceEvent* ValidateAndGetBasicTestPacket() {
+    const trace_analyzer::TraceEvent* trace_event =
+        trace_analyzer_->FindFirstOf(
       trace_analyzer::Query(trace_analyzer::Query::EVENT_NAME) ==
-      trace_analyzer::Query::String("name_all"));
+            trace_analyzer::Query::String("foo_name"));
   EXPECT_TRUE(trace_event);
+
   EXPECT_EQ(2, trace_event->thread.process_id);
   EXPECT_EQ(3, trace_event->thread.thread_id);
-  EXPECT_EQ(1, trace_event->timestamp);
+    EXPECT_EQ(42, trace_event->timestamp);
   EXPECT_EQ('X', trace_event->phase);
-  EXPECT_EQ("name_all", trace_event->name);
-  EXPECT_EQ("cat_all", trace_event->category);
+    EXPECT_EQ("foo_name", trace_event->name);
+    EXPECT_EQ("cat_name", trace_event->category);
   EXPECT_EQ(4, trace_event->duration);
   EXPECT_EQ(5, trace_event->thread_duration);
   EXPECT_EQ(6, trace_event->thread_timestamp);
-  EXPECT_EQ("0x7", trace_event->bind_id);
+    EXPECT_EQ("g", trace_event->scope);
+    EXPECT_EQ("0x7", trace_event->global_id2);
+    EXPECT_EQ("0x8", trace_event->bind_id);
+    EXPECT_TRUE(trace_event->flow_out);
+
+    return trace_event;
+  }
+
+  trace_analyzer::TraceAnalyzer* trace_analyzer() {
+    return trace_analyzer_.get();
+  }
+
+  MockService* service() { return service_.get(); }
+  const base::DictionaryValue* parsed_trace_data() const {
+    return parsed_trace_data_.get();
+  }
+
+ private:
+  std::unique_ptr<MockService> service_;
+  std::unique_ptr<JSONTraceExporter> json_trace_exporter_;
+  std::unique_ptr<base::MessageLoop> message_loop_;
+  std::unique_ptr<trace_analyzer::TraceAnalyzer> trace_analyzer_;
+  std::unique_ptr<base::DictionaryValue> parsed_trace_data_;
+};
+
+TEST_F(JSONTraceExporterTest, EnableTracingWithGivenConfig) {
+  const char kDummyTraceConfig[] = "trace_all_the_things";
+  CreateJSONTraceExporter(kDummyTraceConfig);
+  service()->WaitForTracingEnabled();
+  EXPECT_EQ(kDummyTraceConfig, service()->tracing_enabled_with_config());
 }
 
-TEST_F(JsonTraceExporterTest, TestAddFlagsAllButIdFlagsAndPhaseScope) {
-  std::vector<FakeTraceInfo> infos = {FakeTraceInfo(
-      "name", "cat", 'I', /* timestamp = */ 1, /* pid = */ 2, /* tid = */ 3)};
-  infos[0].flags = TRACE_EVENT_FLAG_ASYNC_TTS |
-                   TRACE_EVENT_FLAG_BIND_TO_ENCLOSING |
-                   TRACE_EVENT_FLAG_FLOW_IN | TRACE_EVENT_FLAG_FLOW_OUT |
-                   TRACE_EVENT_SCOPE_GLOBAL;
-  json_trace_exporter_->SetFakeTraceEvents(infos);
-  json_trace_exporter_->OnTraceData(
-      std::vector<perfetto::TracePacket>(infos.size()), false);
+TEST_F(JSONTraceExporterTest, TestMetadata) {
+  CreateJSONTraceExporter("foo");
+  service()->WaitForTracingEnabled();
+  StopAndFlush();
+
+  perfetto::protos::TracePacket trace_packet_proto;
+
+  {
+    auto* new_metadata =
+        trace_packet_proto.mutable_chrome_events()->add_metadata();
+    new_metadata->set_name("int_metadata");
+    new_metadata->set_int_value(42);
+  }
+
+  {
+    auto* new_metadata =
+        trace_packet_proto.mutable_chrome_events()->add_metadata();
+    new_metadata->set_name("string_metadata");
+    new_metadata->set_string_value("met_val");
+  }
+
+  {
+    auto* new_metadata =
+        trace_packet_proto.mutable_chrome_events()->add_metadata();
+    new_metadata->set_name("bool_metadata");
+    new_metadata->set_bool_value(true);
+  }
+
+  {
+    auto* new_metadata =
+        trace_packet_proto.mutable_chrome_events()->add_metadata();
+    new_metadata->set_name("dict_metadata");
+    new_metadata->set_json_value("{\"child_dict\": \"foo\"}");
+  }
+
+  FinalizePacket(trace_packet_proto);
+
+  service()->WaitForTracingDisabled();
+  auto* metadata = parsed_trace_data()->FindKey("metadata");
+  EXPECT_TRUE(metadata);
+  EXPECT_EQ(metadata->FindKey("int_metadata")->GetInt(), 42);
+  EXPECT_EQ(metadata->FindKey("string_metadata")->GetString(), "met_val");
+  EXPECT_EQ(metadata->FindKey("bool_metadata")->GetBool(), true);
   EXPECT_EQ(
-      "{\"traceEvents\":[{\"pid\":2,\"tid\":3,\"ts\":1,\"ph\":\"I\","
-      "\"cat\":\"cat\",\"name\":\"name\",\"use_async_tts\":1,\"bp\":\"e\","
-      "\"flow_in\":true,\"flow_out\":true,\"s\":\"g\",\"args\":{}}]}",
-      unparsed_trace_data_);
-  const trace_analyzer::TraceEvent* trace_event = trace_analyzer_->FindFirstOf(
-      trace_analyzer::Query(trace_analyzer::Query::EVENT_NAME) ==
-      trace_analyzer::Query::String("name"));
-  EXPECT_TRUE(trace_event);
-  EXPECT_TRUE(trace_event->flow_in);
-  EXPECT_TRUE(trace_event->flow_out);
+      metadata->FindKey("dict_metadata")->FindKey("child_dict")->GetString(),
+      "foo");
 }
 
-TEST_F(JsonTraceExporterTest, TestAddFlagsJustIdFlags) {
-  std::vector<FakeTraceInfo> infos = {
-      // TRACE_EVENT_FLAG_HAS_ID is only parsed if it is required by the phase
-      // like 'S'.
-      FakeTraceInfo("name_1", "cat", 'S', /* timestamp = */ 1, /* pid = */ 2,
-                    /* tid = */ 3),
-      FakeTraceInfo("name_2", "cat", 'B', /* timestamp = */ 1, /* pid = */ 2,
-                    /* tid = */ 3),
-      FakeTraceInfo("name_3", "cat", 'B', /* timestamp = */ 1, /* pid = */ 2,
-                    /* tid = */ 3),
-  };
-  infos[0].flags = TRACE_EVENT_FLAG_HAS_ID;
-  infos[0].id = 1;
-  infos[1].flags = TRACE_EVENT_FLAG_HAS_LOCAL_ID;
-  infos[1].id = 2;
-  infos[1].scope = "id2";
-  infos[2].flags = TRACE_EVENT_FLAG_HAS_GLOBAL_ID;
-  infos[2].id = 3;
-  infos[2].scope = "id3";
-  json_trace_exporter_->SetFakeTraceEvents(infos);
-  json_trace_exporter_->OnTraceData(
-      std::vector<perfetto::TracePacket>(infos.size()), false);
-  EXPECT_EQ(
-      "{\"traceEvents\":[{\"pid\":2,\"tid\":3,\"ts\":1,\"ph\":\"S\","
-      "\"cat\":\"cat\",\"name\":\"name_1\",\"id\":\"0x1\",\"args\":{}},\n"
-      "{\"pid\":2,\"tid\":3,\"ts\":1,\"ph\":\"B\",\"cat\":\"cat\","
-      "\"name\":\"name_2\",\"scope\":\"id2\",\"id2\":{\"local\":\"0x2\"},"
-      "\"args\":{}},\n"
-      "{\"pid\":2,\"tid\":3,\"ts\":1,\"ph\":\"B\",\"cat\":\"cat\","
-      "\"name\":\"name_3\",\"scope\":\"id3\",\"id2\":{\"global\":\"0x3\"},"
-      "\"args\":{}}]}",
-      unparsed_trace_data_);
-  const trace_analyzer::TraceEvent* trace_event = trace_analyzer_->FindFirstOf(
-      trace_analyzer::Query(trace_analyzer::Query::EVENT_NAME) ==
-      trace_analyzer::Query::String("name_1"));
-  ASSERT_TRUE(trace_event);
-  EXPECT_EQ("0x1", trace_event->id);
-  EXPECT_EQ("", trace_event->global_id2);
-  EXPECT_EQ("", trace_event->local_id2);
-  EXPECT_EQ("", trace_event->scope);
-  const trace_analyzer::TraceEvent* trace_event_2 =
-      trace_analyzer_->FindFirstOf(
-          trace_analyzer::Query(trace_analyzer::Query::EVENT_NAME) ==
-          trace_analyzer::Query::String("name_2"));
-  EXPECT_EQ("", trace_event_2->id);
-  EXPECT_EQ("0x2", trace_event_2->local_id2);
-  EXPECT_EQ("", trace_event_2->global_id2);
-  EXPECT_EQ("id2", trace_event_2->scope);
-  ASSERT_TRUE(trace_event);
-  const trace_analyzer::TraceEvent* trace_event_3 =
-      trace_analyzer_->FindFirstOf(
-          trace_analyzer::Query(trace_analyzer::Query::EVENT_NAME) ==
-          trace_analyzer::Query::String("name_3"));
-  ASSERT_TRUE(trace_event);
-  EXPECT_EQ("", trace_event_3->id);
-  EXPECT_EQ("", trace_event_3->local_id2);
-  EXPECT_EQ("0x3", trace_event_3->global_id2);
-  EXPECT_EQ("id3", trace_event_3->scope);
-}
-
-TEST_F(JsonTraceExporterTest, TestAddFlagsJustPhaseScope) {
-  std::vector<FakeTraceInfo> infos = {
-      FakeTraceInfo("name_1", "cat", 'I', /* timestamp = */ 1, /* pid = */ 2,
-                    /* tid = */ 3),
-      FakeTraceInfo("name_2", "cat", 'I', /* timestamp = */ 1, /* pid = */ 2,
-                    /* tid = */ 3),
-      FakeTraceInfo("name_3", "cat", 'I', /* timestamp = */ 1, /* pid = */ 2,
-                    /* tid = */ 3),
-  };
-  infos[0].flags = TRACE_EVENT_SCOPE_GLOBAL;
-  infos[1].flags = TRACE_EVENT_SCOPE_PROCESS;
-  infos[2].flags = TRACE_EVENT_SCOPE_THREAD;
-  json_trace_exporter_->SetFakeTraceEvents(infos);
-  json_trace_exporter_->OnTraceData(
-      std::vector<perfetto::TracePacket>(infos.size()), false);
-  EXPECT_EQ(
-      "{\"traceEvents\":[{\"pid\":2,\"tid\":3,\"ts\":1,\"ph\":\"I\","
-      "\"cat\":\"cat\",\"name\":\"name_1\",\"s\":\"g\",\"args\":{}},\n"
-      "{\"pid\":2,\"tid\":3,\"ts\":1,\"ph\":\"I\",\"cat\":\"cat\","
-      "\"name\":\"name_2\",\"s\":\"p\",\"args\":{}},\n"
-      "{\"pid\":2,\"tid\":3,\"ts\":1,\"ph\":\"I\",\"cat\":\"cat\","
-      "\"name\":\"name_3\",\"s\":\"t\",\"args\":{}}]}",
-      unparsed_trace_data_);
-  const trace_analyzer::TraceEvent* trace_event = trace_analyzer_->FindFirstOf(
-      trace_analyzer::Query(trace_analyzer::Query::EVENT_NAME) ==
-      trace_analyzer::Query::String("name_1"));
-  EXPECT_TRUE(trace_event);
-  EXPECT_EQ(2, trace_event->thread.process_id);
-  EXPECT_EQ(3, trace_event->thread.thread_id);
-  EXPECT_EQ(1, trace_event->timestamp);
-  EXPECT_EQ('I', trace_event->phase);
-  EXPECT_EQ("name_1", trace_event->name);
-  EXPECT_EQ("cat", trace_event->category);
+TEST_F(JSONTraceExporterTest, TestBasicEvent) {
+  CreateJSONTraceExporter("foo");
+  service()->WaitForTracingEnabled();
+  StopAndFlush();
+
+  perfetto::protos::TracePacket trace_packet_proto;
+  auto* new_trace_event =
+      trace_packet_proto.mutable_chrome_events()->add_trace_events();
+  SetTestPacketBasicData(new_trace_event);
+  FinalizePacket(trace_packet_proto);
+
+  service()->WaitForTracingDisabled();
+  ValidateAndGetBasicTestPacket();
 }
 
-TEST_F(JsonTraceExporterTest, TestAddArgs) {
-  std::vector<FakeTraceInfo> infos = {FakeTraceInfo(
-      "name", "cat", 'B', /* timestamp = */ 1, /* pid = */ 2, /* tid = */ 3)};
-  infos[0].args.emplace_back("bool", bool(true));
-  infos[0].args.emplace_back("double", double(8.0));
-  base::Value dict(base::Value::Type::DICTIONARY);
-  dict.SetKey("key", base::Value("value"));
-  infos[0].args.emplace_back("dict", &dict);
-
-  // We will set up this dictionary below so that all the args are easily
-  // visible together.
-  infos[0].args.emplace_back("json", std::string("{\"json_dict\":\"val\"}"));
-
-  json_trace_exporter_->SetFakeTraceEvents(infos);
-  json_trace_exporter_->OnTraceData(
-      std::vector<perfetto::TracePacket>(infos.size()), false);
-  EXPECT_EQ(
-      "{\"traceEvents\":[{\"pid\":2,\"tid\":3,\"ts\":1,\"ph\":\"B\","
-      "\"cat\":\"cat\",\"name\":\"name\",\"args\":{\"bool\":true"
-      ",\"double\":8.000000,\"dict\":{\"key\":\"value\"}"
-      ",\"json\":{\"json_dict\":\"val\"}}}]}",
-      unparsed_trace_data_);
-  const trace_analyzer::TraceEvent* trace_event = trace_analyzer_->FindFirstOf(
-      trace_analyzer::Query(trace_analyzer::Query::EVENT_NAME) ==
-      trace_analyzer::Query::String("name"));
-  EXPECT_TRUE(trace_event);
-  EXPECT_EQ(true, trace_event->GetKnownArgAsBool("bool"));
-  EXPECT_TRUE(trace_event);
-  EXPECT_EQ(8.0, trace_event->GetKnownArgAsDouble("double"));
-  auto value = trace_event->GetKnownArgAsValue("json");
-  ASSERT_TRUE(value);
-  EXPECT_TRUE(value->is_dict());
-  EXPECT_EQ("val", value->FindKey("json_dict")->GetString());
-}
-
-TEST_F(JsonTraceExporterTest, TestAddArgsArgumentStripping) {
-  std::vector<FakeTraceInfo> infos = {
-      FakeTraceInfo("event1", "base", 'B', /* timestamp = */ 1,
-                    /* pid = */ 2,
-                    /* tid = */ 3),
-      FakeTraceInfo("whitewashed", "base", 'B', /* timestamp = */ 1,
-                    /* pid = */ 2, /* tid = */ 3),
-      FakeTraceInfo("ScopedBlockingCallTest", "base", 'B',
-                    /* timestamp = */ 1, /* pid = */ 2, /* tid = */ 3)};
-  infos[0].args.emplace_back("int_one", int64_t(1));
-
-  infos[1].args.emplace_back("int_two", uint64_t(2));
-
-  // Third arg only has index into the string table.
-  infos[2].args.emplace_back("file_name", std::string("\"whitelisted_value\""));
-  infos[2].args.emplace_back("file_number",
-                             std::string("\"blacklisted_value\""));
-
-  json_trace_exporter_->set_filter_args_for_testing(true);
-
-  json_trace_exporter_->SetFakeTraceEvents(infos);
-  json_trace_exporter_->OnTraceData(
-      std::vector<perfetto::TracePacket>(infos.size()), false);
-  EXPECT_EQ(
-      "{\"traceEvents\":[{\"pid\":2,\"tid\":3,\"ts\":1,\"ph\":\"B\","
-      "\"cat\":\"base\",\"name\":\"event1\",\"args\":\"__stripped__\"},\n"
-      "{\"pid\":2,\"tid\":3,\"ts\":1,\"ph\":\"B\",\"cat\":\"base\","
-      "\"name\":\"whitewashed\",\"args\":\"__stripped__\"},\n"
-      "{\"pid\":2,\"tid\":3,\"ts\":1,\"ph\":\"B\","
-      "\"cat\":\"base\",\"name\":\"ScopedBlockingCallTest\","
-      "\"args\":{\"file_name\":\"whitelisted_value\","
-      "\"file_number\":\"__stripped__\"}}]}",
-      unparsed_trace_data_);
+TEST_F(JSONTraceExporterTest, TestStringTable) {
+  CreateJSONTraceExporter("foo");
+  service()->WaitForTracingEnabled();
+  StopAndFlush();
+
+  perfetto::protos::TracePacket trace_packet_proto;
+  auto* new_trace_event =
+      trace_packet_proto.mutable_chrome_events()->add_trace_events();
 
-  const trace_analyzer::TraceEvent* trace_event = trace_analyzer_->FindFirstOf(
+  {
+    auto* string_table_entry =
+        trace_packet_proto.mutable_chrome_events()->add_string_table();
+    string_table_entry->set_index(1);
+    string_table_entry->set_value("foo_name");
+  }
+
+  {
+    auto* string_table_entry =
+        trace_packet_proto.mutable_chrome_events()->add_string_table();
+    string_table_entry->set_index(2);
+    string_table_entry->set_value("foo_cat");
+  }
+
+  {
+    auto* string_table_entry =
+        trace_packet_proto.mutable_chrome_events()->add_string_table();
+    string_table_entry->set_index(3);
+    string_table_entry->set_value("foo_arg");
+  }
+
+  new_trace_event->set_name_index(1);
+  new_trace_event->set_category_group_name_index(2);
+
+  auto* new_arg = new_trace_event->add_args();
+  new_arg->set_name_index(3);
+  new_arg->set_bool_value(true);
+
+  FinalizePacket(trace_packet_proto);
+
+  service()->WaitForTracingDisabled();
+
+  auto* trace_event = trace_analyzer()->FindFirstOf(
       trace_analyzer::Query(trace_analyzer::Query::EVENT_NAME) ==
-      trace_analyzer::Query::String("event1"));
-  EXPECT_FALSE(trace_event->HasArg("int_one"));
+      trace_analyzer::Query::String("foo_name"));
   EXPECT_TRUE(trace_event);
-  trace_event = trace_analyzer_->FindFirstOf(
-      trace_analyzer::Query(trace_analyzer::Query::EVENT_NAME) ==
-      trace_analyzer::Query::String("whitewashed"));
-  EXPECT_FALSE(trace_event->HasArg("int_two"));
-  trace_event = trace_analyzer_->FindFirstOf(
-      trace_analyzer::Query(trace_analyzer::Query::EVENT_NAME) ==
-      trace_analyzer::Query::String("ScopedBlockingCallTest"));
-  EXPECT_EQ("whitelisted_value",
-            trace_event->GetKnownArgAsString(("file_name")));
-  EXPECT_EQ("__stripped__", trace_event->GetKnownArgAsString(("file_number")));
+
+  EXPECT_EQ("foo_name", trace_event->name);
+  EXPECT_EQ("foo_cat", trace_event->category);
+
+  EXPECT_TRUE(trace_event->GetKnownArgAsBool("foo_arg"));
 }
 
-TEST_F(JsonTraceExporterTest, TestFtraceLegacyOutput) {
-  json_trace_exporter_->legacy_ftrace_output.push_back("legacy_trace_data1");
-  json_trace_exporter_->legacy_ftrace_output.push_back(",legacy\"_trace_data2");
-  json_trace_exporter_->OnTraceData(std::vector<perfetto::TracePacket>(),
-                                    false);
-  EXPECT_EQ(
-      "{\"traceEvents\":[],"
-      "\"systemTraceEvents\":\"legacy_trace_data1,legacy\\\"_trace_data2\"}",
-      unparsed_trace_data_);
+TEST_F(JSONTraceExporterTest, TestEventWithBoolArgs) {
+  CreateJSONTraceExporter("foo");
+  service()->WaitForTracingEnabled();
+  StopAndFlush();
+
+  perfetto::protos::TracePacket trace_packet_proto;
+  auto* new_trace_event =
+      trace_packet_proto.mutable_chrome_events()->add_trace_events();
+  SetTestPacketBasicData(new_trace_event);
+
+  {
+    auto* new_arg = new_trace_event->add_args();
+    new_arg->set_name("foo1");
+    new_arg->set_bool_value(true);
+  }
+
+  {
+    auto* new_arg = new_trace_event->add_args();
+    new_arg->set_name("foo2");
+    new_arg->set_bool_value(false);
+  }
+
+  FinalizePacket(trace_packet_proto);
+
+  service()->WaitForTracingDisabled();
+  auto* trace_event = ValidateAndGetBasicTestPacket();
+
+  EXPECT_TRUE(trace_event->GetKnownArgAsBool("foo1"));
+  EXPECT_FALSE(trace_event->GetKnownArgAsBool("foo2"));
 }
 
-TEST_F(JsonTraceExporterTest, TestLegacySystemTrace) {
-  json_trace_exporter_->json_traces.emplace_back();
-  auto& trace = json_trace_exporter_->json_traces.back();
-  trace.set_type(perfetto::protos::ChromeLegacyJsonTrace::SYSTEM_TRACE);
-  trace.set_data("\"bool\":true");
-  json_trace_exporter_->json_traces.push_back(trace);
-  json_trace_exporter_->json_traces.back().set_data("\"double\":8.0");
-  json_trace_exporter_->OnTraceData(std::vector<perfetto::TracePacket>(),
-                                    false);
-  EXPECT_EQ(
-      "{\"traceEvents\":[],"
-      "\"systemTraceEvents\":{\"bool\":true,\"double\":8.0}}",
-      unparsed_trace_data_);
-}
-
-TEST_F(JsonTraceExporterTest, TestLegacyJsonTrace) {
-  json_trace_exporter_->json_traces.emplace_back();
-  auto& trace = json_trace_exporter_->json_traces.back();
-  trace.set_type(perfetto::protos::ChromeLegacyJsonTrace::USER_TRACE);
-  trace.set_data(
-      "{\"pid\":2,\"tid\":3,\"ts\":1,\"ph\":\"B\","
-      "\"cat\":\"cat\",\"name\":\"name_1\",\"args\":{}}");
-  json_trace_exporter_->json_traces.push_back(trace);
-  json_trace_exporter_->json_traces.back().set_data(
-      "{\"pid\":2,\"tid\":3,\"ts\":1,\"ph\":\"B\","
-      "\"cat\":\"cat\",\"name\":\"name_2\",\"args\":{}}");
-  json_trace_exporter_->OnTraceData(std::vector<perfetto::TracePacket>(),
-                                    false);
+TEST_F(JSONTraceExporterTest, TestEventWithUintArgs) {
+  CreateJSONTraceExporter("foo");
+  service()->WaitForTracingEnabled();
+  StopAndFlush();
+
+  perfetto::protos::TracePacket trace_packet_proto;
+  auto* new_trace_event =
+      trace_packet_proto.mutable_chrome_events()->add_trace_events();
+  SetTestPacketBasicData(new_trace_event);
+
+  {
+    auto* new_arg = new_trace_event->add_args();
+    new_arg->set_name("foo1");
+    new_arg->set_uint_value(1);
+  }
+
+  {
+    auto* new_arg = new_trace_event->add_args();
+    new_arg->set_name("foo2");
+    new_arg->set_uint_value(2);
+  }
+
+  FinalizePacket(trace_packet_proto);
+
+  service()->WaitForTracingDisabled();
+  auto* trace_event = ValidateAndGetBasicTestPacket();
+
+  EXPECT_EQ(1, trace_event->GetKnownArgAsDouble("foo1"));
+  EXPECT_EQ(2, trace_event->GetKnownArgAsDouble("foo2"));
+}
+
+TEST_F(JSONTraceExporterTest, TestEventWithIntArgs) {
+  CreateJSONTraceExporter("foo");
+  service()->WaitForTracingEnabled();
+  StopAndFlush();
+
+  perfetto::protos::TracePacket trace_packet_proto;
+  auto* new_trace_event =
+      trace_packet_proto.mutable_chrome_events()->add_trace_events();
+  SetTestPacketBasicData(new_trace_event);
+
+  {
+    auto* new_arg = new_trace_event->add_args();
+    new_arg->set_name("foo1");
+    new_arg->set_int_value(1);
+  }
+
+  {
+    auto* new_arg = new_trace_event->add_args();
+    new_arg->set_name("foo2");
+    new_arg->set_int_value(2);
+  }
+
+  FinalizePacket(trace_packet_proto);
+
+  service()->WaitForTracingDisabled();
+  auto* trace_event = ValidateAndGetBasicTestPacket();
+
+  EXPECT_EQ(1, trace_event->GetKnownArgAsDouble("foo1"));
+  EXPECT_EQ(2, trace_event->GetKnownArgAsDouble("foo2"));
+}
+
+TEST_F(JSONTraceExporterTest, TestEventWithDoubleArgs) {
+  CreateJSONTraceExporter("foo");
+  service()->WaitForTracingEnabled();
+  StopAndFlush();
+
+  perfetto::protos::TracePacket trace_packet_proto;
+  auto* new_trace_event =
+      trace_packet_proto.mutable_chrome_events()->add_trace_events();
+  SetTestPacketBasicData(new_trace_event);
+
+  {
+    auto* new_arg = new_trace_event->add_args();
+    new_arg->set_name("foo1");
+    new_arg->set_double_value(1.0);
+  }
+
+  {
+    auto* new_arg = new_trace_event->add_args();
+    new_arg->set_name("foo2");
+    new_arg->set_double_value(2.0);
+  }
+
+  FinalizePacket(trace_packet_proto);
+
+  service()->WaitForTracingDisabled();
+  auto* trace_event = ValidateAndGetBasicTestPacket();
+
+  EXPECT_EQ(1.0, trace_event->GetKnownArgAsDouble("foo1"));
+  EXPECT_EQ(2.0, trace_event->GetKnownArgAsDouble("foo2"));
+}
+
+TEST_F(JSONTraceExporterTest, TestEventWithStringArgs) {
+  CreateJSONTraceExporter("foo");
+  service()->WaitForTracingEnabled();
+  StopAndFlush();
+
+  perfetto::protos::TracePacket trace_packet_proto;
+  auto* new_trace_event =
+      trace_packet_proto.mutable_chrome_events()->add_trace_events();
+  SetTestPacketBasicData(new_trace_event);
+
+  {
+    auto* new_arg = new_trace_event->add_args();
+    new_arg->set_name("foo1");
+    new_arg->set_string_value("bar1");
+  }
+
+  {
+    auto* new_arg = new_trace_event->add_args();
+    new_arg->set_name("foo2");
+    new_arg->set_string_value("bar2");
+  }
+
+  FinalizePacket(trace_packet_proto);
+
+  service()->WaitForTracingDisabled();
+  auto* trace_event = ValidateAndGetBasicTestPacket();
+
+  EXPECT_EQ("bar1", trace_event->GetKnownArgAsString("foo1"));
+  EXPECT_EQ("bar2", trace_event->GetKnownArgAsString("foo2"));
+}
+
+TEST_F(JSONTraceExporterTest, TestEventWithPointerArgs) {
+  CreateJSONTraceExporter("foo");
+  service()->WaitForTracingEnabled();
+  StopAndFlush();
+
+  perfetto::protos::TracePacket trace_packet_proto;
+  auto* new_trace_event =
+      trace_packet_proto.mutable_chrome_events()->add_trace_events();
+  SetTestPacketBasicData(new_trace_event);
+
+  {
+    auto* new_arg = new_trace_event->add_args();
+    new_arg->set_name("foo1");
+    new_arg->set_pointer_value(0x1);
+  }
+
+  {
+    auto* new_arg = new_trace_event->add_args();
+    new_arg->set_name("foo2");
+    new_arg->set_pointer_value(0x2);
+  }
+
+  FinalizePacket(trace_packet_proto);
+
+  service()->WaitForTracingDisabled();
+  auto* trace_event = ValidateAndGetBasicTestPacket();
+
+  EXPECT_EQ("0x1", trace_event->GetKnownArgAsString("foo1"));
+  EXPECT_EQ("0x2", trace_event->GetKnownArgAsString("foo2"));
+}
+
+TEST_F(JSONTraceExporterTest, TestEventWithConvertableArgs) {
+  CreateJSONTraceExporter("foo");
+  service()->WaitForTracingEnabled();
+  StopAndFlush();
+
+  perfetto::protos::TracePacket trace_packet_proto;
+  auto* new_trace_event =
+      trace_packet_proto.mutable_chrome_events()->add_trace_events();
+  SetTestPacketBasicData(new_trace_event);
+
+  {
+    auto* new_arg = new_trace_event->add_args();
+    new_arg->set_name("foo1");
+    new_arg->set_json_value("\"conv_value1\"");
+  }
+
+  {
+    auto* new_arg = new_trace_event->add_args();
+    new_arg->set_name("foo2");
+    new_arg->set_json_value("\"conv_value2\"");
+  }
+
+  FinalizePacket(trace_packet_proto);
+
+  service()->WaitForTracingDisabled();
+  auto* trace_event = ValidateAndGetBasicTestPacket();
+
+  EXPECT_EQ("conv_value1", trace_event->GetKnownArgAsString("foo1"));
+  EXPECT_EQ("conv_value2", trace_event->GetKnownArgAsString("foo2"));
+}
+
+TEST_F(JSONTraceExporterTest, TestEventWithTracedValueArg) {
+  CreateJSONTraceExporter("foo");
+  service()->WaitForTracingEnabled();
+  StopAndFlush();
+
+  perfetto::protos::TracePacket trace_packet_proto;
+  auto* new_trace_event =
+      trace_packet_proto.mutable_chrome_events()->add_trace_events();
+  SetTestPacketBasicData(new_trace_event);
+
+  auto* new_arg = new_trace_event->add_args();
+  new_arg->set_name("foo1");
+  auto* traced_value = new_arg->mutable_traced_value();
+  traced_value->add_dict_keys("bool");
+  traced_value->add_dict_values()->set_bool_value(true);
+
+  FinalizePacket(trace_packet_proto);
+
+  service()->WaitForTracingDisabled();
+  auto* trace_event = ValidateAndGetBasicTestPacket();
+
+  auto arg_value = trace_event->GetKnownArgAsValue("foo1");
+  EXPECT_EQ(true, arg_value->FindKey("bool")->GetBool());
+}
+
+TEST_F(JSONTraceExporterTest, TracedValueFlatDictionary) {
+  perfetto::protos::ChromeTracedValue traced_value;
+
+  {
+    traced_value.add_dict_keys("bool");
+    traced_value.add_dict_values()->set_bool_value(true);
+  }
+
+  {
+    traced_value.add_dict_keys("double");
+    traced_value.add_dict_values()->set_double_value(8.0);
+  }
+
+  {
+    traced_value.add_dict_keys("int");
+    traced_value.add_dict_values()->set_int_value(2014);
+  }
+
+  {
+    traced_value.add_dict_keys("string");
+    traced_value.add_dict_values()->set_string_value("bar");
+  }
+
+  std::string json;
+  AppendProtoDictAsJSON(&json, traced_value);
+
+  EXPECT_EQ("{\"bool\":true,\"double\":8.0,\"int\":2014,\"string\":\"bar\"}",
+            json);
+}
+
+TEST_F(JSONTraceExporterTest, TracedValueHierarchy) {
+  perfetto::protos::ChromeTracedValue traced_value;
+
+  {
+    traced_value.add_dict_keys("a1");
+    auto* a1_array = traced_value.add_dict_values();
+    a1_array->set_nested_type(perfetto::protos::ChromeTracedValue::ARRAY);
+
+    a1_array->add_array_values()->set_int_value(1);
+    a1_array->add_array_values()->set_bool_value(true);
+
+    auto* sub_dict = a1_array->add_array_values();
+    sub_dict->set_nested_type(perfetto::protos::ChromeTracedValue::DICT);
+    sub_dict->add_dict_keys("i2");
+    sub_dict->add_dict_values()->set_int_value(3);
+  }
+
+  {
+    traced_value.add_dict_keys("b0");
+    traced_value.add_dict_values()->set_bool_value(true);
+  }
+
+  {
+    traced_value.add_dict_keys("d0");
+    traced_value.add_dict_values()->set_double_value(6.0);
+  }
+
+  {
+    traced_value.add_dict_keys("a1");
+    auto* dict1_subdict = traced_value.add_dict_values();
+    dict1_subdict->set_nested_type(perfetto::protos::ChromeTracedValue::DICT);
+
+    dict1_subdict->add_dict_keys("dict2");
+    auto* dict2_sub_sub_dict = dict1_subdict->add_dict_values();
+    dict2_sub_sub_dict->set_nested_type(
+        perfetto::protos::ChromeTracedValue::DICT);
+
+    dict2_sub_sub_dict->add_dict_keys("b2");
+    dict2_sub_sub_dict->add_dict_values()->set_bool_value(true);
+
+    dict1_subdict->add_dict_keys("i1");
+    dict1_subdict->add_dict_values()->set_int_value(2014);
+
+    dict1_subdict->add_dict_keys("s1");
+    dict1_subdict->add_dict_values()->set_string_value("foo");
+  }
+
+  {
+    traced_value.add_dict_keys("i0");
+    traced_value.add_dict_values()->set_int_value(2014);
+  }
+
+  {
+    traced_value.add_dict_keys("s0");
+    traced_value.add_dict_values()->set_string_value("foo");
+  }
+
+  std::string json;
+  AppendProtoDictAsJSON(&json, traced_value);
+
   EXPECT_EQ(
-      "{\"traceEvents\":[{\"pid\":2,\"tid\":3,\"ts\":1,\"ph\":\"B\","
-      "\"cat\":\"cat\",\"name\":\"name_1\",\"args\":{}},\n{\"pid\":2,"
-      "\"tid\":3,\"ts\":1,\"ph\":\"B\",\"cat\":\"cat\","
-      "\"name\":\"name_2\",\"args\":{}}]}",
-      unparsed_trace_data_);
-  const trace_analyzer::TraceEvent* trace_event = trace_analyzer_->FindFirstOf(
-      trace_analyzer::Query(trace_analyzer::Query::EVENT_NAME) ==
-      trace_analyzer::Query::String("name_1"));
-  EXPECT_TRUE(trace_event);
-  EXPECT_EQ(2, trace_event->thread.process_id);
-  EXPECT_EQ(3, trace_event->thread.thread_id);
-  EXPECT_EQ(1, trace_event->timestamp);
-  EXPECT_EQ('B', trace_event->phase);
-  EXPECT_EQ("name_1", trace_event->name);
-  EXPECT_EQ("cat", trace_event->category);
-  trace_event = trace_analyzer_->FindFirstOf(
+      "{\"a1\":[1,true,{\"i2\":3}],\"b0\":true,\"d0\":6.0,\"a1\":{\"dict2\":{"
+      "\"b2\":true},\"i1\":2014,\"s1\":\"foo\"},\"i0\":2014,\"s0\":\"foo\"}",
+      json);
+}
+
+TEST_F(JSONTraceExporterTest, TestLegacyUserTrace) {
+  CreateJSONTraceExporter("foo");
+  service()->WaitForTracingEnabled();
+  StopAndFlush();
+
+  perfetto::protos::TracePacket trace_packet_proto;
+
+  auto* new_trace_event =
+      trace_packet_proto.mutable_chrome_events()->add_trace_events();
+  SetTestPacketBasicData(new_trace_event);
+
+  auto* json_trace =
+      trace_packet_proto.mutable_chrome_events()->add_legacy_json_trace();
+  json_trace->set_type(perfetto::protos::ChromeLegacyJsonTrace::USER_TRACE);
+  json_trace->set_data(
+      "{\"pid\":10,\"tid\":11,\"ts\":23,\"ph\":\"I\""
+      ",\"cat\":\"cat_name2\",\"name\":\"bar_name\""
+      ",\"id2\":{\"global\":\"0x5\"},\"args\":{}}");
+
+  FinalizePacket(trace_packet_proto);
+
+  service()->WaitForTracingDisabled();
+  ValidateAndGetBasicTestPacket();
+
+  const trace_analyzer::TraceEvent* trace_event = trace_analyzer()->FindFirstOf(
       trace_analyzer::Query(trace_analyzer::Query::EVENT_NAME) ==
-      trace_analyzer::Query::String("name_2"));
+      trace_analyzer::Query::String("bar_name"));
   EXPECT_TRUE(trace_event);
-  EXPECT_EQ("name_2", trace_event->name);
-}
 
-TEST_F(JsonTraceExporterTest, TestTraceStats) {
-  // Only the last trace stats matters.
-  json_trace_exporter_->stats.emplace_back();
-  json_trace_exporter_->stats.back().set_producers_connected(2);
-  json_trace_exporter_->stats.emplace_back();
-  auto& stats = json_trace_exporter_->stats.back();
-  stats.set_producers_connected(4);
-  auto* buf_stats = stats.add_buffer_stats();
-  buf_stats->set_buffer_size(1024);
-  json_trace_exporter_->OnTraceData(std::vector<perfetto::TracePacket>(),
-                                    false);
-
-  // To avoid making a brittle test we don't check all fields are outputted in
-  // the trace stats just the ones we explicitly set.
-  EXPECT_EQ(std::string::npos,
-            unparsed_trace_data_.find("\"producers_connected\":2"));
-  EXPECT_NE(std::string::npos,
-            unparsed_trace_data_.find("\"producers_connected\":4"));
-  EXPECT_NE(std::string::npos,
-            unparsed_trace_data_.find("\"buffer_size\":1024"));
-  EXPECT_TRUE(base::StartsWith(unparsed_trace_data_,
-                               "{\"traceEvents\":[],"
-                               "\"metadata\":{\"perfetto_trace_stats\":{\"",
-                               base::CompareCase::SENSITIVE));
-  EXPECT_TRUE(
-      base::EndsWith(unparsed_trace_data_, "}}", base::CompareCase::SENSITIVE));
-}
-
-TEST_F(JsonTraceExporterTest, TestMetadata) {
-  json_trace_exporter_->metadata.emplace_back();
-  auto& m1 = json_trace_exporter_->metadata.back();
-  m1.set_name("metadata_1");
-  m1.set_bool_value(true);
-  json_trace_exporter_->metadata.emplace_back();
-  auto& m2 = json_trace_exporter_->metadata.back();
-  m2.set_name("metadata_2");
-  m2.set_json_value("{\"dict\":{\"bool\":true}}");
-  json_trace_exporter_->OnTraceData(std::vector<perfetto::TracePacket>(),
-                                    false);
-  EXPECT_EQ(unparsed_trace_data_,
-            "{\"traceEvents\":[],"
-            "\"metadata\":{\"metadata_1\":true,"
-            "\"metadata_2\":{\"dict\":{\"bool\":true}}}}");
-}
-
-TEST_F(JsonTraceExporterTest, ComplexMultipleCallback) {
-  // Allocate a string that will cause the buffer to be flushed after this
-  // event.
-  constexpr size_t kTraceEventBufferSizeInBytes = 100 * 1024;
-  std::string big_string(kTraceEventBufferSizeInBytes, 'a');
-  std::vector<FakeTraceInfo> infos = {
-      FakeTraceInfo(big_string, "cat", 'B',
-                    /* timestamp = */ 1, /* pid = */ 2,
-                    /* tid = */ 3),
-      FakeTraceInfo("name", "cat", 'B',
-                    /* timestamp = */ 1, /* pid = */ 2,
-                    /* tid = */ 3)};
-  json_trace_exporter_->SetFakeTraceEvents(infos);
-  json_trace_exporter_->OnTraceData(
-      std::vector<perfetto::TracePacket>(infos.size()), true);
-  json_trace_exporter_->SetFakeTraceEvents({infos[1]});
-  json_trace_exporter_->OnTraceData(std::vector<perfetto::TracePacket>(1),
-                                    false);
-  ASSERT_EQ(static_cast<std::size_t>(3), unparsed_trace_data_sequence_.size());
-  EXPECT_EQ(base::StringPrintf(
-                "{\"traceEvents\":[{\"pid\":2,\"tid\":3,\"ts\":1,\"ph\":\"B\","
-                "\"cat\":\"cat\",\"name\":\"%s\"",
-                big_string.c_str()),
-            unparsed_trace_data_sequence_[0]);
-  EXPECT_EQ(
-      ",\"args\":{}},\n{\"pid\":2,\"tid\":3,\"ts\":1,\"ph\":\"B\","
-      "\"cat\":\"cat\",\"name\":\"name\",\"args\":{}}",
-      unparsed_trace_data_sequence_[1]);
-  EXPECT_EQ(
-      ",\n{\"pid\":2,\"tid\":3,\"ts\":1,\"ph\":\"B\","
-      "\"cat\":\"cat\",\"name\":\"name\",\"args\":{}}]}",
-      unparsed_trace_data_sequence_[2]);
-  EXPECT_EQ(base::StringPrintf(
-                "{\"traceEvents\":[{\"pid\":2,\"tid\":3,\"ts\":1,\"ph\":\"B\","
-                "\"cat\":\"cat\",\"name\":\"%s\",\"args\":{}}"
-                ",\n{\"pid\":2,\"tid\":3,\"ts\":1,\"ph\":\"B\","
-                "\"cat\":\"cat\",\"name\":\"name\",\"args\":{}}"
-                ",\n{\"pid\":2,\"tid\":3,\"ts\":1,\"ph\":\"B\","
-                "\"cat\":\"cat\",\"name\":\"name\",\"args\":{}}]}",
-                big_string.c_str()),
-            unparsed_trace_data_);
+  EXPECT_EQ(10, trace_event->thread.process_id);
+  EXPECT_EQ(11, trace_event->thread.thread_id);
+  EXPECT_EQ(23, trace_event->timestamp);
+  EXPECT_EQ('I', trace_event->phase);
+  EXPECT_EQ("bar_name", trace_event->name);
+  EXPECT_EQ("cat_name2", trace_event->category);
+  EXPECT_EQ("0x5", trace_event->global_id2);
+}
+
+TEST_F(JSONTraceExporterTest, TestLegacySystemFtrace) {
+  CreateJSONTraceExporter("foo");
+  service()->WaitForTracingEnabled();
+  StopAndFlush();
+
+  std::string ftrace = "#dummy data";
+
+  perfetto::protos::TracePacket trace_packet_proto;
+  trace_packet_proto.mutable_chrome_events()->add_legacy_ftrace_output(ftrace);
+  FinalizePacket(trace_packet_proto);
+
+  service()->WaitForTracingDisabled();
+  auto* sys_trace = parsed_trace_data()->FindKey("systemTraceEvents");
+  EXPECT_TRUE(sys_trace);
+  EXPECT_EQ(sys_trace->GetString(), ftrace);
+}
+
+TEST_F(JSONTraceExporterTest, TestLegacySystemTraceEvents) {
+  CreateJSONTraceExporter("foo");
+  service()->WaitForTracingEnabled();
+  StopAndFlush();
+
+  perfetto::protos::TracePacket trace_packet_proto;
+
+  auto* json_trace =
+      trace_packet_proto.mutable_chrome_events()->add_legacy_json_trace();
+  json_trace->set_type(perfetto::protos::ChromeLegacyJsonTrace::SYSTEM_TRACE);
+  json_trace->set_data(
+      "\"name\":\"MySysTrace\",\"content\":["
+      "{\"pid\":10,\"tid\":11,\"ts\":23,\"ph\":\"I\""
+      ",\"cat\":\"cat_name2\",\"name\":\"bar_name\""
+      ",\"id2\":{\"global\":\"0x5\"},\"args\":{}}]");
+
+  FinalizePacket(trace_packet_proto);
+
+  service()->WaitForTracingDisabled();
+
+  auto* sys_trace = parsed_trace_data()->FindKey("systemTraceEvents");
+  EXPECT_TRUE(sys_trace);
+  EXPECT_EQ(sys_trace->FindKey("name")->GetString(), "MySysTrace");
+  auto* content = sys_trace->FindKey("content");
+  EXPECT_EQ(content->GetList().size(), 1u);
+  EXPECT_EQ(content->GetList()[0].FindKey("pid")->GetInt(), 10);
+  EXPECT_EQ(content->GetList()[0].FindKey("tid")->GetInt(), 11);
+  EXPECT_EQ(content->GetList()[0].FindKey("name")->GetString(), "bar_name");
 }
+
 }  // namespace tracing
--- a/services/tracing/perfetto/perfetto_integration_unittest.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/tracing/perfetto/perfetto_integration_unittest.cc	2019-05-17 18:53:38.012000000 +0300
@@ -6,7 +6,6 @@
 #include <string>
 #include <utility>
 
-#include "base/bind.h"
 #include "base/run_loop.h"
 #include "base/test/scoped_task_environment.h"
 #include "mojo/public/cpp/bindings/binding.h"
@@ -23,7 +22,10 @@
 class PerfettoIntegrationTest : public testing::Test {
  public:
   void SetUp() override {
-    perfetto_service_ = std::make_unique<PerfettoService>();
+    perfetto_service_ = std::make_unique<PerfettoService>(
+        base::SequencedTaskRunnerHandle::Get());
+    // The actual Perfetto service is created async on the given task_runner;
+    // wait until that's done.
     RunUntilIdle();
     ProducerClient::ResetTaskRunnerForTesting();
   }
--- a/services/tracing/perfetto/perfetto_service.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/tracing/perfetto/perfetto_service.cc	2019-05-17 18:53:38.012000000 +0300
@@ -6,10 +6,7 @@
 
 #include <utility>
 
-#include "base/bind.h"
 #include "base/no_destructor.h"
-#include "base/strings/strcat.h"
-#include "base/strings/string_number_conversions.h"
 #include "base/task/post_task.h"
 #include "services/service_manager/public/cpp/bind_source_info.h"
 #include "services/tracing/perfetto/producer_host.h"
@@ -18,6 +15,31 @@
 
 namespace tracing {
 
+namespace {
+
+const char kPerfettoProducerName[] = "org.chromium.perfetto_producer";
+
+}  // namespace
+
+/*
+TODO(oysteine): Right now the Perfetto service runs on a dedicated
+thread for a couple of reasons:
+* The sequence needs to be locked to a specific thread, or Perfetto's
+  thread-checker will barf.
+* The PerfettoTracingCoordinator uses
+  mojo::BlockingCopyFromString to pass the string to the tracing
+  controller, which requires the WithBaseSyncPrimitives task trait and
+  SingleThreadTaskRunners which use this trait need to be running on a
+  dedicated trait to avoid blocking other sequences.
+* If a client fills up its Shared Memory Buffer when writing a Perfetto
+  event proto, it'll stall until the Perfetto service clears up space.
+  This won't happen if the client and the service happens to run on the same
+  thread (the Mojo calls will never be executed).
+
+The above should be resolved before we move the Perfetto usage out from the
+flag so we can run this on non-thread-bound sequence.
+*/
+
 // static
 PerfettoService* PerfettoService::GetInstance() {
   static base::NoDestructor<PerfettoService> perfetto_service;
@@ -26,9 +48,27 @@
 
 PerfettoService::PerfettoService(
     scoped_refptr<base::SequencedTaskRunner> task_runner_for_testing)
-    : perfetto_task_runner_(task_runner_for_testing
-                                ? std::move(task_runner_for_testing)
-                                : base::SequencedTaskRunnerHandle::Get()) {
+    : perfetto_task_runner_(
+          task_runner_for_testing
+              ? task_runner_for_testing
+              : base::CreateSingleThreadTaskRunnerWithTraits(
+                    {base::MayBlock(),
+                     base::TaskShutdownBehavior::CONTINUE_ON_SHUTDOWN,
+                     base::WithBaseSyncPrimitives(),
+                     base::TaskPriority::BEST_EFFORT},
+                    base::SingleThreadTaskRunnerThreadMode::DEDICATED)) {
+  DETACH_FROM_SEQUENCE(sequence_checker_);
+  perfetto_task_runner_.task_runner()->PostTask(
+      FROM_HERE, base::BindOnce(&PerfettoService::CreateServiceOnSequence,
+                                base::Unretained(this)));
+}
+
+PerfettoService::~PerfettoService() {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+}
+
+void PerfettoService::CreateServiceOnSequence() {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
   service_ = perfetto::TracingService::CreateInstance(
       std::make_unique<MojoSharedMemory::Factory>(), &perfetto_task_runner_);
   // Chromium uses scraping of the shared memory chunks to ensure that data
@@ -37,25 +77,29 @@
   DCHECK(service_);
 }
 
-PerfettoService::~PerfettoService() = default;
-
 perfetto::TracingService* PerfettoService::GetService() const {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
   return service_.get();
 }
 
-void PerfettoService::BindRequest(mojom::PerfettoServiceRequest request,
-                                  uint32_t pid) {
-  bindings_.AddBinding(this, std::move(request), pid);
+void PerfettoService::BindRequest(mojom::PerfettoServiceRequest request) {
+  perfetto_task_runner_.task_runner()->PostTask(
+      FROM_HERE, base::BindOnce(&PerfettoService::BindOnSequence,
+                                base::Unretained(this), std::move(request)));
+}
+
+void PerfettoService::BindOnSequence(mojom::PerfettoServiceRequest request) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  bindings_.AddBinding(this, std::move(request));
 }
 
 void PerfettoService::ConnectToProducerHost(
     mojom::ProducerClientPtr producer_client,
     mojom::ProducerHostRequest producer_host_request) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
   auto new_producer = std::make_unique<ProducerHost>();
-  uint32_t producer_pid = bindings_.dispatch_context();
   new_producer->Initialize(std::move(producer_client), service_.get(),
-                           base::StrCat({mojom::kPerfettoProducerName, ".",
-                                         base::NumberToString(producer_pid)}));
+                           kPerfettoProducerName);
   producer_bindings_.AddBinding(std::move(new_producer),
                                 std::move(producer_host_request));
 }
--- a/services/tracing/perfetto/perfetto_service.h	2019-05-01 01:22:57.000000000 +0300
+++ b/services/tracing/perfetto/perfetto_service.h	2019-05-17 18:53:38.012000000 +0300
@@ -9,6 +9,8 @@
 #include <set>
 
 #include "base/macros.h"
+#include "base/sequence_checker.h"
+#include "base/sequenced_task_runner.h"
 #include "mojo/public/cpp/bindings/binding_set.h"
 #include "mojo/public/cpp/bindings/strong_binding_set.h"
 #include "services/service_manager/public/cpp/identity.h"
@@ -33,13 +35,16 @@
 
   static PerfettoService* GetInstance();
 
-  void BindRequest(mojom::PerfettoServiceRequest request, uint32_t pid);
+  void BindRequest(mojom::PerfettoServiceRequest request);
 
   // mojom::PerfettoService implementation.
   void ConnectToProducerHost(mojom::ProducerClientPtr producer_client,
                              mojom::ProducerHostRequest producer_host) override;
 
   perfetto::TracingService* GetService() const;
+  scoped_refptr<base::SequencedTaskRunner> task_runner() {
+    return perfetto_task_runner_.task_runner();
+  }
 
  private:
   void BindOnSequence(mojom::PerfettoServiceRequest request);
@@ -47,8 +52,9 @@
 
   PerfettoTaskRunner perfetto_task_runner_;
   std::unique_ptr<perfetto::TracingService> service_;
-  mojo::BindingSet<mojom::PerfettoService, uint32_t> bindings_;
+  mojo::BindingSet<mojom::PerfettoService> bindings_;
   mojo::StrongBindingSet<mojom::ProducerHost> producer_bindings_;
+  SEQUENCE_CHECKER(sequence_checker_);
 
   DISALLOW_COPY_AND_ASSIGN(PerfettoService);
 };
--- a/services/tracing/perfetto/perfetto_tracing_coordinator.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/tracing/perfetto/perfetto_tracing_coordinator.cc	2019-05-17 18:53:38.012000000 +0300
@@ -4,51 +4,27 @@
 
 #include "services/tracing/perfetto/perfetto_tracing_coordinator.h"
 
-#include <algorithm>
 #include <utility>
-#include <vector>
 
-#include "base/bind.h"
-#include "base/strings/strcat.h"
-#include "base/strings/string_number_conversions.h"
-#include "build/build_config.h"
 #include "mojo/public/cpp/system/data_pipe_utils.h"
-#include "services/tracing/perfetto/chrome_event_bundle_json_exporter.h"
+#include "services/tracing/perfetto/json_trace_exporter.h"
 #include "services/tracing/perfetto/perfetto_service.h"
-#include "services/tracing/public/mojom/constants.mojom.h"
-#include "services/tracing/public/mojom/perfetto_service.mojom.h"
-#include "third_party/perfetto/include/perfetto/tracing/core/consumer.h"
-#include "third_party/perfetto/include/perfetto/tracing/core/trace_config.h"
-#include "third_party/perfetto/include/perfetto/tracing/core/trace_stats.h"
-#include "third_party/perfetto/include/perfetto/tracing/core/tracing_service.h"
 
 namespace tracing {
 
-// A TracingSession acts as a perfetto consumer and is used to wrap all the
-// associated state of an on-going tracing session, for easy setup and cleanup.
-//
-// TODO(eseckler): Make it possible to have multiple active sessions
-// concurrently. Also support configuring the output format of a session (JSON
-// vs. proto).
-class PerfettoTracingCoordinator::TracingSession : public perfetto::Consumer {
+// A TracingSession is used to wrap all the associated
+// state of an on-going tracing session, for easy setup
+// and cleanup.
+class PerfettoTracingCoordinator::TracingSession {
  public:
-  TracingSession(const base::trace_event::TraceConfig& chrome_config,
+  TracingSession(const std::string& config,
                  base::OnceClosure tracing_over_callback)
       : tracing_over_callback_(std::move(tracing_over_callback)) {
-    json_trace_exporter_ = std::make_unique<ChromeEventBundleJsonExporter>(
-        chrome_config.IsArgumentFilterEnabled(),
-        base::BindRepeating(&TracingSession::OnJSONTraceEventCallback,
-                            base::Unretained(this)));
-    perfetto::TracingService* service =
-        PerfettoService::GetInstance()->GetService();
-    consumer_endpoint_ = service->ConnectConsumer(this, /*uid=*/0);
-
-    // Start tracing.
-    auto perfetto_config = CreatePerfettoConfiguration(chrome_config);
-    consumer_endpoint_->EnableTracing(perfetto_config);
+    json_trace_exporter_ = std::make_unique<JSONTraceExporter>(
+        config, PerfettoService::GetInstance()->GetService());
   }
 
-  ~TracingSession() override {
+  ~TracingSession() {
     if (!stop_and_flush_callback_.is_null()) {
       base::ResetAndReturn(&stop_and_flush_callback_)
           .Run(base::Value(base::Value::Type::DICTIONARY));
@@ -57,93 +33,13 @@
     stream_.reset();
   }
 
-  void ChangeTraceConfig(const base::trace_event::TraceConfig& chrome_config) {
-    auto perfetto_config = CreatePerfettoConfiguration(chrome_config);
-    consumer_endpoint_->ChangeTraceConfig(perfetto_config);
-  }
-
-  perfetto::TraceConfig CreatePerfettoConfiguration(
-      const base::trace_event::TraceConfig& chrome_config) {
-    perfetto::TraceConfig perfetto_config;
-    size_t size_limit = chrome_config.GetTraceBufferSizeInKb();
-    if (size_limit == 0) {
-      size_limit = 100 * 1024;
-    }
-    perfetto_config.add_buffers()->set_size_kb(size_limit);
-
-    // Perfetto uses clock_gettime for its internal snapshotting, which gets
-    // blocked by the sandboxed and isn't needed for Chrome regardless.
-    perfetto_config.set_disable_clock_snapshotting(true);
-
-    auto* trace_event_data_source = perfetto_config.add_data_sources();
-    for (auto& enabled_pid :
-         chrome_config.process_filter_config().included_process_ids()) {
-      *trace_event_data_source->add_producer_name_filter() =
-          base::StrCat({mojom::kPerfettoProducerName, ".",
-                        base::NumberToString(enabled_pid)});
-    }
-
-    // We strip the process filter from the config string we send to Perfetto,
-    // so perfetto doesn't reject it from a future
-    // TracingService::ChangeTraceConfig call due to being an unsupported
-    // update.
-    base::trace_event::TraceConfig processfilter_stripped_config(chrome_config);
-    processfilter_stripped_config.SetProcessFilterConfig(
-        base::trace_event::TraceConfig::ProcessFilterConfig());
-
-#if DCHECK_IS_ON()
-    // Ensure that the process filter is the only thing that gets changed
-    // in a configuration during a tracing session.
-    DCHECK((last_config_for_perfetto_.ToString() ==
-            base::trace_event::TraceConfig().ToString()) ||
-           (last_config_for_perfetto_.ToString() ==
-            processfilter_stripped_config.ToString()));
-    last_config_for_perfetto_ = processfilter_stripped_config;
-#endif
-
-    auto* trace_event_config = trace_event_data_source->mutable_config();
-    trace_event_config->set_name(mojom::kTraceEventDataSourceName);
-    trace_event_config->set_target_buffer(0);
-    auto* chrome_proto_config = trace_event_config->mutable_chrome_config();
-    chrome_proto_config->set_trace_config(
-        processfilter_stripped_config.ToString());
-
-// Only CrOS and Cast support system tracing.
-#if defined(OS_CHROMEOS) || (defined(IS_CHROMECAST) && defined(OS_LINUX))
-    auto* system_trace_config =
-        perfetto_config.add_data_sources()->mutable_config();
-    system_trace_config->set_name(mojom::kSystemTraceDataSourceName);
-    system_trace_config->set_target_buffer(0);
-    auto* system_chrome_config = system_trace_config->mutable_chrome_config();
-    system_chrome_config->set_trace_config(
-        processfilter_stripped_config.ToString());
-#endif
-
-#if defined(OS_CHROMEOS)
-    auto* arc_trace_config =
-        perfetto_config.add_data_sources()->mutable_config();
-    arc_trace_config->set_name(mojom::kArcTraceDataSourceName);
-    arc_trace_config->set_target_buffer(0);
-    auto* arc_chrome_config = arc_trace_config->mutable_chrome_config();
-    arc_chrome_config->set_trace_config(
-        processfilter_stripped_config.ToString());
-#endif
-
-    auto* trace_metadata_config =
-        perfetto_config.add_data_sources()->mutable_config();
-    trace_metadata_config->set_name(mojom::kMetaDataSourceName);
-    trace_metadata_config->set_target_buffer(0);
-
-    return perfetto_config;
-  }
-
   void StopAndFlush(mojo::ScopedDataPipeProducerHandle stream,
-                    const std::string& agent_label,
                     StopAndFlushCallback callback) {
     stream_ = std::move(stream);
     stop_and_flush_callback_ = std::move(callback);
-    json_trace_exporter_->set_label_filter(agent_label);
-    consumer_endpoint_->DisableTracing();
+
+    json_trace_exporter_->StopAndFlush(base::BindRepeating(
+        &TracingSession::OnJSONTraceEventCallback, base::Unretained(this)));
   }
 
   void OnJSONTraceEventCallback(const std::string& json,
@@ -163,73 +59,11 @@
     }
   }
 
-  void RequestBufferUsage(RequestBufferUsageCallback callback) {
-    if (!request_buffer_usage_callback_.is_null()) {
-      // TODO(eseckler): Reconsider whether we can DCHECK here after refactoring
-      // of content's TracingController.
-      std::move(callback).Run(false, 0, 0);
-      return;
-    }
-    request_buffer_usage_callback_ = std::move(callback);
-    consumer_endpoint_->GetTraceStats();
-  }
-
-  // perfetto::Consumer implementation.
-  // This gets called by the Perfetto service as control signals,
-  // and to send finished protobufs over.
-  void OnConnect() override {}
-
-  void OnDisconnect() override {}
-
-  void OnTracingDisabled() override { consumer_endpoint_->ReadBuffers(); }
-
-  void OnTraceData(std::vector<perfetto::TracePacket> packets,
-                   bool has_more) override {
-    json_trace_exporter_->OnTraceData(std::move(packets), has_more);
-  }
-
-  // Consumer Detach / Attach is not used in Chrome.
-  void OnDetach(bool success) override { NOTREACHED(); }
-
-  void OnAttach(bool success, const perfetto::TraceConfig&) override {
-    NOTREACHED();
-  }
-
-  void OnTraceStats(bool success, const perfetto::TraceStats& stats) override {
-    DCHECK(request_buffer_usage_callback_);
-    if (!success) {
-      std::move(request_buffer_usage_callback_).Run(false, 0.0f, 0);
-      return;
-    }
-    DCHECK_EQ(1, stats.buffer_stats_size());
-    const perfetto::TraceStats::BufferStats& buf_stats =
-        stats.buffer_stats()[0];
-    size_t bytes_in_buffer =
-        buf_stats.bytes_written() - buf_stats.bytes_read() -
-        buf_stats.bytes_overwritten() + buf_stats.padding_bytes_written() -
-        buf_stats.padding_bytes_cleared();
-    double percent_full =
-        bytes_in_buffer / static_cast<double>(buf_stats.buffer_size());
-    percent_full = std::min(std::max(0.0, percent_full), 1.0);
-    // We know the size of data in the buffer, but not the number of events.
-    std::move(request_buffer_usage_callback_)
-        .Run(true, percent_full, 0 /*approx_event_count*/);
-  }
-
  private:
   mojo::ScopedDataPipeProducerHandle stream_;
   std::unique_ptr<JSONTraceExporter> json_trace_exporter_;
   StopAndFlushCallback stop_and_flush_callback_;
   base::OnceClosure tracing_over_callback_;
-  RequestBufferUsageCallback request_buffer_usage_callback_;
-
-#if DCHECK_IS_ON()
-  base::trace_event::TraceConfig last_config_for_perfetto_;
-#endif
-
-  // Keep last to avoid edge-cases where its callbacks come in mid-destruction.
-  std::unique_ptr<perfetto::TracingService::ConsumerEndpoint>
-      consumer_endpoint_;
 
   DISALLOW_COPY_AND_ASSIGN(TracingSession);
 };
@@ -257,65 +91,25 @@
 void PerfettoTracingCoordinator::BindCoordinatorRequest(
     mojom::CoordinatorRequest request,
     const service_manager::BindSourceInfo& source_info) {
+  PerfettoService::GetInstance()->task_runner()->PostTask(
+      FROM_HERE, base::BindOnce(&PerfettoTracingCoordinator::BindOnSequence,
+                                base::Unretained(this), std::move(request)));
+}
+
+void PerfettoTracingCoordinator::BindOnSequence(
+    mojom::CoordinatorRequest request) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
   binding_.Bind(std::move(request));
   binding_.set_connection_error_handler(
       base::BindOnce(&PerfettoTracingCoordinator::OnClientConnectionError,
                      base::Unretained(this)));
 }
 
-void PerfettoTracingCoordinator::StartTracing(const std::string& config,
-                                              StartTracingCallback callback) {
+void PerfettoTracingCoordinator::StartTracing(const std::string& config) {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
-  parsed_config_ = base::trace_event::TraceConfig(config);
-  if (!tracing_session_) {
     tracing_session_ = std::make_unique<TracingSession>(
-        parsed_config_,
-        base::BindOnce(&PerfettoTracingCoordinator::OnTracingOverCallback,
+      config, base::BindOnce(&PerfettoTracingCoordinator::OnTracingOverCallback,
                        weak_factory_.GetWeakPtr()));
-  } else {
-    tracing_session_->ChangeTraceConfig(parsed_config_);
-  }
-
-  agent_registry_->SetAgentInitializationCallback(
-      base::BindRepeating(&PerfettoTracingCoordinator::PingAgent,
-                          weak_factory_.GetWeakPtr()),
-      false /* call_on_new_agents_only */);
-
-  SetStartTracingCallback(std::move(callback));
-}
-
-void PerfettoTracingCoordinator::PingAgent(
-    AgentRegistry::AgentEntry* agent_entry) {
-  if (!parsed_config_.process_filter_config().IsEnabled(agent_entry->pid()))
-    return;
-
-  // TODO(oysteine): While we're still using the Agent
-  // system as a fallback when using Perfetto, rather than
-  // the browser directly using a Consumer interface, we have to
-  // attempt to linearize with newly connected agents so we only
-  // call the BeginTracing callback when we can be sure
-  // that all current agents have registered with Perfetto and
-  // started tracing if requested. We do this linearization
-  // explicitly using WaitForTracingEnabled() which will wait
-  // for the TraceLog to be enabled before calling its provided
-  // callback.
-  auto closure = base::BindRepeating(
-      [](base::WeakPtr<PerfettoTracingCoordinator> coordinator,
-         AgentRegistry::AgentEntry* agent_entry) {
-        bool removed =
-            agent_entry->RemoveDisconnectClosure(GetStartTracingClosureName());
-        DCHECK(removed);
-
-        if (coordinator) {
-          coordinator->CallStartTracingCallbackIfNeeded();
-        }
-      },
-      weak_factory_.GetWeakPtr(), base::Unretained(agent_entry));
-
-  agent_entry->AddDisconnectClosure(GetStartTracingClosureName(), closure);
-
-  agent_entry->agent()->WaitForTracingEnabled(closure);
-  RemoveExpectedPID(agent_entry->pid());
 }
 
 void PerfettoTracingCoordinator::OnTracingOverCallback() {
@@ -327,56 +121,20 @@
 void PerfettoTracingCoordinator::StopAndFlush(
     mojo::ScopedDataPipeProducerHandle stream,
     StopAndFlushCallback callback) {
-  StopAndFlushAgent(std::move(stream), "", std::move(callback));
-}
-
-void PerfettoTracingCoordinator::StopAndFlushInternal(
-    mojo::ScopedDataPipeProducerHandle stream,
-    const std::string& agent_label,
-    StopAndFlushCallback callback) {
-  if (start_tracing_callback_) {
-    // We received a |StopAndFlush| command before receiving |StartTracing| acks
-    // from all agents. Let's retry after a delay.
-    task_runner_->PostDelayedTask(
-        FROM_HERE,
-        base::BindOnce(&PerfettoTracingCoordinator::StopAndFlushInternal,
-                       weak_factory_.GetWeakPtr(), std::move(stream),
-                       agent_label, std::move(callback)),
-        base::TimeDelta::FromMilliseconds(
-            mojom::kStopTracingRetryTimeMilliseconds));
-    return;
-  }
-
-  agent_registry_->SetAgentInitializationCallback(
-      base::DoNothing(), true /* call_on_new_agents_only */);
-  tracing_session_->StopAndFlush(std::move(stream), agent_label,
-                                 std::move(callback));
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  DCHECK(tracing_session_);
+  tracing_session_->StopAndFlush(std::move(stream), std::move(callback));
 }
 
 void PerfettoTracingCoordinator::StopAndFlushAgent(
     mojo::ScopedDataPipeProducerHandle stream,
     const std::string& agent_label,
     StopAndFlushCallback callback) {
-  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
-  DCHECK(tracing_session_);
-
-  ClearConnectedPIDs();
-  StopAndFlushInternal(std::move(stream), agent_label, std::move(callback));
+  NOTREACHED();
 }
 
 void PerfettoTracingCoordinator::IsTracing(IsTracingCallback callback) {
-  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
   std::move(callback).Run(tracing_session_ != nullptr);
 }
 
-void PerfettoTracingCoordinator::RequestBufferUsage(
-    RequestBufferUsageCallback callback) {
-  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
-  if (!tracing_session_) {
-    std::move(callback).Run(false, 0, 0);
-    return;
-  }
-  tracing_session_->RequestBufferUsage(std::move(callback));
-}
-
 }  // namespace tracing
--- a/services/tracing/perfetto/perfetto_tracing_coordinator.h	2019-05-01 01:22:57.000000000 +0300
+++ b/services/tracing/perfetto/perfetto_tracing_coordinator.h	2019-05-17 18:53:38.012000000 +0300
@@ -37,23 +37,18 @@
 
   // mojom::Coordinator implementation.
   // Called by the tracing controller.
-  void StartTracing(const std::string& config,
-                    StartTracingCallback callback) override;
+  void StartTracing(const std::string& config) override;
   void StopAndFlush(mojo::ScopedDataPipeProducerHandle stream,
                     StopAndFlushCallback callback) override;
   void StopAndFlushAgent(mojo::ScopedDataPipeProducerHandle stream,
                          const std::string& agent_label,
                          StopAndFlushCallback callback) override;
   void IsTracing(IsTracingCallback callback) override;
-  void RequestBufferUsage(RequestBufferUsageCallback callback) override;
 
  private:
+  void BindOnSequence(mojom::CoordinatorRequest request);
   void OnTracingOverCallback();
   void OnClientConnectionError() override;
-  void PingAgent(AgentRegistry::AgentEntry* agent_entry);
-  void StopAndFlushInternal(mojo::ScopedDataPipeProducerHandle stream,
-                            const std::string& agent_label,
-                            StopAndFlushCallback callback);
 
   mojo::Binding<mojom::Coordinator> binding_;
 
--- a/services/tracing/perfetto/producer_host.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/tracing/perfetto/producer_host.cc	2019-05-17 18:53:38.012000000 +0300
@@ -6,7 +6,6 @@
 
 #include <utility>
 
-#include "base/bind.h"
 #include "services/tracing/public/cpp/perfetto/shared_memory.h"
 #include "third_party/perfetto/include/perfetto/tracing/core/commit_data_request.h"
 #include "third_party/perfetto/include/perfetto/tracing/core/data_source_descriptor.h"
@@ -68,9 +67,14 @@
 
 void ProducerHost::StartDataSource(perfetto::DataSourceInstanceID id,
                                    const perfetto::DataSourceConfig& config) {
-  // The type traits will send the base fields in the DataSourceConfig and also
-  // the ChromeConfig other configs are dropped.
-  producer_client_->StartDataSource(id, config);
+  // TODO(oysteine): Send full DataSourceConfig, not just the name/target_buffer
+  // and Chrome Tracing string.
+  auto data_source_config = mojom::DataSourceConfig::New();
+  data_source_config->name = config.name();
+  data_source_config->target_buffer = config.target_buffer();
+
+  data_source_config->trace_config = config.chrome_config().trace_config();
+  producer_client_->StartDataSource(id, std::move(data_source_config));
 }
 
 void ProducerHost::StopDataSource(perfetto::DataSourceInstanceID id) {
@@ -100,16 +104,49 @@
 // sanitization here because ProducerEndpoint::CommitData() (And any other
 // ProducerEndpoint methods) are designed to deal with malformed / malicious
 // inputs.
-void ProducerHost::CommitData(const perfetto::CommitDataRequest& data_request) {
+void ProducerHost::CommitData(mojom::CommitDataRequestPtr data_request) {
+  perfetto::CommitDataRequest native_data_request;
+
+  // TODO(oysteine): Set up a TypeTrait for this instead of manual conversion.
+  native_data_request.set_flush_request_id(data_request->flush_request_id);
+
+  for (auto& chunk : data_request->chunks_to_move) {
+    auto* new_chunk = native_data_request.add_chunks_to_move();
+    new_chunk->set_page(chunk->page);
+    new_chunk->set_chunk(chunk->chunk);
+    new_chunk->set_target_buffer(chunk->target_buffer);
+  }
+
+  for (auto& chunk_patch : data_request->chunks_to_patch) {
+    auto* new_chunk_patch = native_data_request.add_chunks_to_patch();
+    new_chunk_patch->set_target_buffer(chunk_patch->target_buffer);
+    new_chunk_patch->set_writer_id(chunk_patch->writer_id);
+    new_chunk_patch->set_chunk_id(chunk_patch->chunk_id);
+
+    for (auto& patch : chunk_patch->patches) {
+      auto* new_patch = new_chunk_patch->add_patches();
+      new_patch->set_offset(patch->offset);
+      new_patch->set_data(patch->data);
+    }
+
+    new_chunk_patch->set_has_more_patches(chunk_patch->has_more_patches);
+  }
+
   if (on_commit_callback_for_testing_) {
-    on_commit_callback_for_testing_.Run(data_request);
+    on_commit_callback_for_testing_.Run(native_data_request);
   }
-  producer_endpoint_->CommitData(data_request);
+
+  // TODO(oysteine): Pass through an optional callback for
+  // tests to know when a commit is completed.
+  producer_endpoint_->CommitData(native_data_request);
 }
 
 void ProducerHost::RegisterDataSource(
-    const perfetto::DataSourceDescriptor& registration_info) {
-  producer_endpoint_->RegisterDataSource(registration_info);
+    mojom::DataSourceRegistrationPtr registration_info) {
+  perfetto::DataSourceDescriptor descriptor;
+  descriptor.set_name(registration_info->name);
+  descriptor.set_will_notify_on_stop(registration_info->will_notify_on_stop);
+  producer_endpoint_->RegisterDataSource(descriptor);
 }
 
 void ProducerHost::NotifyFlushComplete(uint64_t flush_request_id) {
--- a/services/tracing/perfetto/producer_host.h	2019-05-01 01:22:57.000000000 +0300
+++ b/services/tracing/perfetto/producer_host.h	2019-05-17 18:53:38.012000000 +0300
@@ -66,12 +66,12 @@
   // This interface gets called by the per-process ProducerClients
   // to signal that there's changes to be committed to the
   // Shared Memory buffer (like finished chunks).
-  void CommitData(const perfetto::CommitDataRequest& data_request) override;
+  void CommitData(mojom::CommitDataRequestPtr data_request) override;
 
   // Called by the ProducerClient to signal the Host that it can
   // provide a specific data source.
   void RegisterDataSource(
-      const perfetto::DataSourceDescriptor& registration_info) override;
+      mojom::DataSourceRegistrationPtr registration_info) override;
 
   // Called to signal the Host that a specific flush request
   // is finished.
--- a/services/tracing/perfetto/test_utils.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/tracing/perfetto/test_utils.cc	2019-05-17 18:53:38.012000000 +0300
@@ -3,7 +3,6 @@
 // found in the LICENSE file.
 #include <utility>
 
-#include "base/bind.h"
 #include "base/run_loop.h"
 #include "services/tracing/perfetto/test_utils.h"
 #include "testing/gtest/include/gtest/gtest.h"
@@ -39,9 +38,9 @@
 
 void TestDataSource::StartTracing(
     ProducerClient* producer_client,
-    const perfetto::DataSourceConfig& data_source_config) {
+    const mojom::DataSourceConfig& data_source_config) {
   producer_client_ = producer_client;
-  target_buffer_ = data_source_config.target_buffer();
+  target_buffer_ = data_source_config.target_buffer;
 
   if (send_packet_count_ > 0) {
     std::unique_ptr<perfetto::TraceWriter> writer =
@@ -82,7 +81,7 @@
 
 void MockProducerClient::StartDataSource(
     uint64_t id,
-    const perfetto::DataSourceConfig& data_source_config) {
+    mojom::DataSourceConfigPtr data_source_config) {
   ProducerClient::StartDataSource(id, std::move(data_source_config));
 
   if (client_enabled_callback_) {
@@ -208,8 +207,8 @@
 MockProducerHost::~MockProducerHost() = default;
 
 void MockProducerHost::RegisterDataSource(
-    const perfetto::DataSourceDescriptor& registration_info) {
-  ProducerHost::RegisterDataSource(registration_info);
+    mojom::DataSourceRegistrationPtr registration_info) {
+  ProducerHost::RegisterDataSource(std::move(registration_info));
 
   on_commit_callback_for_testing_ =
       base::BindRepeating(&MockProducerHost::OnCommit, base::Unretained(this));
--- a/services/tracing/perfetto/test_utils.h	2019-05-01 01:22:57.000000000 +0300
+++ b/services/tracing/perfetto/test_utils.h	2019-05-17 18:53:38.012000000 +0300
@@ -29,9 +29,8 @@
   void WritePacketBigly();
 
   // DataSourceBase implementation
-  void StartTracing(
-      ProducerClient* producer_client,
-      const perfetto::DataSourceConfig& data_source_config) override;
+  void StartTracing(ProducerClient* producer_client,
+                    const mojom::DataSourceConfig& data_source_config) override;
   void StopTracing(
       base::OnceClosure stop_complete_callback = base::OnceClosure()) override;
   void Flush(base::RepeatingClosure flush_complete_callback) override;
@@ -52,9 +51,8 @@
 
   void SetupDataSource(const std::string& data_source_name);
 
-  void StartDataSource(
-      uint64_t id,
-      const perfetto::DataSourceConfig& data_source_config) override;
+  void StartDataSource(uint64_t id,
+                       mojom::DataSourceConfigPtr data_source_config) override;
 
   void StopDataSource(uint64_t id, StopDataSourceCallback callback) override;
 
@@ -126,7 +124,7 @@
   ~MockProducerHost() override;
 
   void RegisterDataSource(
-      const perfetto::DataSourceDescriptor& registration_info) override;
+      mojom::DataSourceRegistrationPtr registration_info) override;
 
   void OnConnect() override;
 
--- a/services/tracing/public/cpp/base_agent.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/tracing/public/cpp/base_agent.cc	2019-05-17 18:53:38.012000000 +0300
@@ -6,7 +6,6 @@
 
 #include <utility>
 
-#include "base/bind.h"
 #include "services/tracing/public/cpp/traced_process_impl.h"
 #include "services/tracing/public/mojom/constants.mojom.h"
 
@@ -39,10 +38,7 @@
 }
 
 void BaseAgent::StartTracing(const std::string& config,
-                             base::TimeTicks coordinator_time,
-                             Agent::StartTracingCallback callback) {
-  std::move(callback).Run(true /* success */);
-}
+                             base::TimeTicks coordinator_time) {}
 
 void BaseAgent::StopAndFlush(tracing::mojom::RecorderPtr recorder) {}
 
@@ -51,13 +47,4 @@
   std::move(callback).Run(0 /* capacity */, 0 /* count */);
 }
 
-void BaseAgent::WaitForTracingEnabled(
-    Agent::WaitForTracingEnabledCallback callback) {
-  std::move(callback).Run();
-}
-
-bool BaseAgent::IsBoundForTesting() const {
-  return binding_.is_bound();
-}
-
 }  // namespace tracing
--- a/services/tracing/public/cpp/base_agent.h	2019-05-01 01:22:57.000000000 +0300
+++ b/services/tracing/public/cpp/base_agent.h	2019-05-17 18:53:38.012000000 +0300
@@ -30,20 +30,15 @@
             mojom::TraceDataType type,
             base::ProcessId pid);
 
-  bool IsBoundForTesting() const;
-
  private:
   void Disconnect();
 
   // tracing::mojom::Agent:
   void StartTracing(const std::string& config,
-                    base::TimeTicks coordinator_time,
-                    Agent::StartTracingCallback callback) override;
+                    base::TimeTicks coordinator_time) override;
   void StopAndFlush(tracing::mojom::RecorderPtr recorder) override;
   void RequestBufferStatus(
       Agent::RequestBufferStatusCallback callback) override;
-  void WaitForTracingEnabled(
-      Agent::WaitForTracingEnabledCallback callback) override;
 
   mojo::Binding<tracing::mojom::Agent> binding_;
 
--- a/services/tracing/public/cpp/BUILD.gn	2019-05-01 01:22:57.000000000 +0300
+++ b/services/tracing/public/cpp/BUILD.gn	2019-05-17 18:53:38.012000000 +0300
@@ -24,29 +24,18 @@
     sources = [
       "base_agent.cc",
       "base_agent.h",
-      "perfetto/chrome_bundle_thread_local_event_sink.cc",
-      "perfetto/chrome_bundle_thread_local_event_sink.h",
-      "perfetto/interning_index.h",
       "perfetto/producer_client.cc",
       "perfetto/producer_client.h",
       "perfetto/shared_memory.cc",
       "perfetto/shared_memory.h",
       "perfetto/task_runner.cc",
       "perfetto/task_runner.h",
-      "perfetto/thread_local_event_sink.cc",
-      "perfetto/thread_local_event_sink.h",
       "perfetto/trace_event_data_source.cc",
       "perfetto/trace_event_data_source.h",
       "perfetto/traced_value_proto_writer.cc",
       "perfetto/traced_value_proto_writer.h",
-      "perfetto/track_event_thread_local_event_sink.cc",
-      "perfetto/track_event_thread_local_event_sink.h",
       "trace_event_agent.cc",
       "trace_event_agent.h",
-      "trace_event_args_whitelist.cc",
-      "trace_event_args_whitelist.h",
-      "trace_startup.cc",
-      "trace_startup.h",
       "traced_process_impl.cc",
       "traced_process_impl.h",
       "tracing_features.cc",
@@ -60,7 +49,6 @@
 
     public_deps = [
       "//base",
-      "//components/tracing:startup_tracing",
       "//mojo/public/cpp/bindings",
       "//services/tracing/public/mojom",
       "//third_party/perfetto:libperfetto",
--- a/services/tracing/public/cpp/perfetto/producer_client.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/tracing/public/cpp/perfetto/producer_client.cc	2019-05-17 18:53:38.012000000 +0300
@@ -6,14 +6,12 @@
 
 #include <utility>
 
-#include "base/bind.h"
 #include "base/no_destructor.h"
 #include "base/task/post_task.h"
 #include "services/tracing/public/cpp/perfetto/shared_memory.h"
 #include "services/tracing/public/mojom/constants.mojom.h"
 #include "third_party/perfetto/include/perfetto/tracing/core/commit_data_request.h"
 #include "third_party/perfetto/include/perfetto/tracing/core/shared_memory_arbiter.h"
-#include "third_party/perfetto/include/perfetto/tracing/core/startup_trace_writer_registry.h"
 #include "third_party/perfetto/include/perfetto/tracing/core/trace_writer.h"
 
 namespace tracing {
@@ -22,7 +20,7 @@
 
 scoped_refptr<base::SequencedTaskRunner> CreateTaskRunner() {
   return base::CreateSequencedTaskRunnerWithTraits(
-      {base::MayBlock(), base::TaskPriority::USER_BLOCKING});
+      {base::MayBlock(), base::TaskPriority::BEST_EFFORT});
 }
 
 // We never destroy the taskrunner as we may need it for cleanup
@@ -45,7 +43,7 @@
 void ProducerClient::DataSourceBase::StartTracingWithID(
     uint64_t data_source_id,
     ProducerClient* producer_client,
-    const perfetto::DataSourceConfig& data_source_config) {
+    const mojom::DataSourceConfig& data_source_config) {
   data_source_id_ = data_source_id;
   StartTracing(producer_client, data_source_config);
 }
@@ -79,7 +77,6 @@
 
 // static
 void ProducerClient::ResetTaskRunnerForTesting() {
-  DETACH_FROM_SEQUENCE(ProducerClient::Get()->sequence_checker_);
   GetPerfettoTaskRunner()->ResetTaskRunnerForTesting(CreateTaskRunner());
 }
 
@@ -107,13 +104,6 @@
                      std::move(producer_client)));
 }
 
-void ProducerClient::BindStartupTraceWriterRegistry(
-    std::unique_ptr<perfetto::StartupTraceWriterRegistry> registry,
-    perfetto::BufferID target_buffer) {
-  shared_memory_arbiter_->BindStartupTraceWriterRegistry(std::move(registry),
-                                                         target_buffer);
-}
-
 // The Mojo binding should run on the same sequence as the one we get
 // callbacks from Perfetto on, to avoid additional PostTasks.
 void ProducerClient::CreateMojoMessagepipesOnSequence(
@@ -152,9 +142,9 @@
 }
 
 void ProducerClient::RegisterDataSourceWithHost(DataSourceBase* data_source) {
-  perfetto::DataSourceDescriptor new_registration;
-  new_registration.set_name(data_source->name());
-  new_registration.set_will_notify_on_stop(true);
+  auto new_registration = mojom::DataSourceRegistration::New();
+  new_registration->name = data_source->name();
+  new_registration->will_notify_on_stop = true;
   producer_host_->RegisterDataSource(std::move(new_registration));
 }
 
@@ -181,13 +171,14 @@
 
 void ProducerClient::StartDataSource(
     uint64_t id,
-    const perfetto::DataSourceConfig& data_source_config) {
+    mojom::DataSourceConfigPtr data_source_config) {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  DCHECK(data_source_config);
 
   // TODO(oysteine): Support concurrent tracing sessions.
   for (auto* data_source : data_sources_) {
-    if (data_source->name() == data_source_config.name()) {
-      data_source->StartTracingWithID(id, this, data_source_config);
+    if (data_source->name() == data_source_config->name) {
+      data_source->StartTracingWithID(id, this, *data_source_config);
       return;
     }
   }
@@ -242,13 +233,58 @@
 
 void ProducerClient::CommitData(const perfetto::CommitDataRequest& commit,
                                 CommitDataCallback callback) {
-  producer_host_->CommitData(commit);
+  // The CommitDataRequest which the SharedMemoryArbiter uses to
+  // signal Perfetto that individual chunks have finished being
+  // written and is ready for consumption, needs to be serialized
+  // into the corresponding Mojo class and sent over to the
+  // service-side.
+  auto new_data_request = mojom::CommitDataRequest::New();
+
+  new_data_request->flush_request_id = commit.flush_request_id();
+  for (auto& chunk : commit.chunks_to_move()) {
+    auto new_chunk = mojom::ChunksToMove::New();
+    new_chunk->page = chunk.page();
+    new_chunk->chunk = chunk.chunk();
+    new_chunk->target_buffer = chunk.target_buffer();
+    new_data_request->chunks_to_move.push_back(std::move(new_chunk));
+  }
+
+  for (auto& chunk_patch : commit.chunks_to_patch()) {
+    auto new_chunk_patch = mojom::ChunksToPatch::New();
+    new_chunk_patch->target_buffer = chunk_patch.target_buffer();
+    new_chunk_patch->writer_id = chunk_patch.writer_id();
+    new_chunk_patch->chunk_id = chunk_patch.chunk_id();
+
+    for (auto& patch : chunk_patch.patches()) {
+      auto new_patch = mojom::ChunkPatch::New();
+      new_patch->offset = patch.offset();
+      new_patch->data = patch.data();
+      new_chunk_patch->patches.push_back(std::move(new_patch));
+    }
+
+    new_chunk_patch->has_more_patches = chunk_patch.has_more_patches();
+    new_data_request->chunks_to_patch.push_back(std::move(new_chunk_patch));
+  }
+
+  // TODO(oysteine): Remove the PostTask once Perfetto is fixed to always call
+  // CommitData on its provided TaskRunner, right now it'll call it on whatever
+  // thread is requesting a new chunk when the SharedMemoryBuffer is full. Until
+  // then this is technically not threadsafe on shutdown (when the
+  // ProducerClient gets destroyed) but should be okay while the Perfetto
+  // integration is behind a flag.
+  if (GetTaskRunner()->RunsTasksInCurrentSequence()) {
+    producer_host_->CommitData(std::move(new_data_request));
+  } else {
+    GetTaskRunner()->PostTask(
+        FROM_HERE,
+        base::BindOnce(&ProducerClient::CommitDataOnSequence,
+                       base::Unretained(this), std::move(new_data_request)));
+  }
 }
 
-void ProducerClient::CommitDataOnSequence(
-    const perfetto::CommitDataRequest& request) {
+void ProducerClient::CommitDataOnSequence(mojom::CommitDataRequestPtr request) {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
-  producer_host_->CommitData(request);
+  producer_host_->CommitData(std::move(request));
 }
 
 perfetto::SharedMemory* ProducerClient::shared_memory() const {
@@ -275,6 +311,7 @@
 
 std::unique_ptr<perfetto::TraceWriter> ProducerClient::CreateTraceWriter(
     perfetto::BufferID target_buffer) {
+  DCHECK(shared_memory_arbiter_);
   return shared_memory_arbiter_->CreateTraceWriter(target_buffer);
 }
 
--- a/services/tracing/public/cpp/perfetto/producer_client.h	2019-05-01 01:22:57.000000000 +0300
+++ b/services/tracing/public/cpp/perfetto/producer_client.h	2019-05-17 18:53:38.016000000 +0300
@@ -23,7 +23,6 @@
 
 namespace perfetto {
 class SharedMemoryArbiter;
-class StartupTraceWriterRegistry;
 }  // namespace perfetto
 
 namespace tracing {
@@ -50,14 +49,13 @@
     explicit DataSourceBase(const std::string& name);
     virtual ~DataSourceBase();
 
-    void StartTracingWithID(
-        uint64_t data_source_id,
+    void StartTracingWithID(uint64_t data_source_id,
         ProducerClient* producer_client,
-        const perfetto::DataSourceConfig& data_source_config);
+                            const mojom::DataSourceConfig& data_source_config);
 
     virtual void StartTracing(
         ProducerClient* producer_client,
-        const perfetto::DataSourceConfig& data_source_config) = 0;
+        const mojom::DataSourceConfig& data_source_config) = 0;
     virtual void StopTracing(
         base::OnceClosure stop_complete_callback = base::OnceClosure()) = 0;
 
@@ -93,13 +91,6 @@
                               mojom::ProducerHostRequest)>;
   void CreateMojoMessagepipes(MessagepipesReadyCallback);
 
-  // Binds the registry and its trace writers to the ProducerClient's SMB, to
-  // write into the given target buffer. The ownership of |registry| is
-  // transferred to ProducerClient (and its SharedMemoryArbiter).
-  void BindStartupTraceWriterRegistry(
-      std::unique_ptr<perfetto::StartupTraceWriterRegistry> registry,
-      perfetto::BufferID target_buffer);
-
   // Add a new data source to the ProducerClient; the caller
   // retains ownership and is responsible for making sure
   // the data source outlives the ProducerClient.
@@ -109,9 +100,8 @@
   // Called through Mojo by the ProducerHost on the service-side to control
   // tracing and toggle specific DataSources.
   void OnTracingStart(mojo::ScopedSharedBufferHandle shared_memory) override;
-  void StartDataSource(
-      uint64_t id,
-      const perfetto::DataSourceConfig& data_source_config) override;
+  void StartDataSource(uint64_t id,
+                       mojom::DataSourceConfigPtr data_source_config) override;
 
   void StopDataSource(uint64_t id, StopDataSourceCallback callback) override;
   void Flush(uint64_t flush_request_id,
@@ -148,7 +138,7 @@
  private:
   friend class base::NoDestructor<ProducerClient>;
 
-  void CommitDataOnSequence(const perfetto::CommitDataRequest& request);
+  void CommitDataOnSequence(mojom::CommitDataRequestPtr request);
   void AddDataSourceOnSequence(DataSourceBase*);
   void RegisterDataSourceWithHost(DataSourceBase* data_source);
 
--- a/services/tracing/public/cpp/perfetto/task_runner.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/tracing/public/cpp/perfetto/task_runner.cc	2019-05-17 18:53:38.016000000 +0300
@@ -7,7 +7,6 @@
 #include <memory>
 #include <utility>
 
-#include "base/bind.h"
 #include "base/threading/sequenced_task_runner_handle.h"
 
 namespace tracing {
@@ -32,10 +31,6 @@
       base::TimeDelta::FromMilliseconds(delay_ms));
 }
 
-bool PerfettoTaskRunner::RunsTasksOnCurrentThread() const {
-  return task_runner_->RunsTasksInCurrentSequence();
-}
-
 void PerfettoTaskRunner::AddFileDescriptorWatch(int fd, std::function<void()>) {
   NOTREACHED();
 }
--- a/services/tracing/public/cpp/perfetto/task_runner.h	2019-05-01 01:22:57.000000000 +0300
+++ b/services/tracing/public/cpp/perfetto/task_runner.h	2019-05-17 18:53:38.016000000 +0300
@@ -26,11 +26,6 @@
   // the Perfetto implementation itself.
   void PostTask(std::function<void()> task) override;
   void PostDelayedTask(std::function<void()> task, uint32_t delay_ms) override;
-  // This in Chrome would more correctly be called "RunsTasksInCurrentSequence".
-  // Perfetto calls this to determine wheather CommitData requests should be
-  // flushed synchronously. RunsTasksInCurrentSequence is sufficient for that
-  // use case.
-  bool RunsTasksOnCurrentThread() const override;
 
   // Not used in Chrome.
   void AddFileDescriptorWatch(int fd, std::function<void()>) override;
--- a/services/tracing/public/cpp/perfetto/traced_value_proto_writer.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/tracing/public/cpp/perfetto/traced_value_proto_writer.cc	2019-05-17 18:53:38.016000000 +0300
@@ -3,7 +3,6 @@
 // found in the LICENSE file.
 #include "services/tracing/public/cpp/perfetto/traced_value_proto_writer.h"
 
-#include <memory>
 #include <stack>
 
 #include "base/hash.h"
@@ -15,21 +14,18 @@
 #include "third_party/perfetto/include/perfetto/protozero/scattered_heap_buffer.h"
 #include "third_party/perfetto/include/perfetto/protozero/scattered_stream_writer.h"
 #include "third_party/perfetto/protos/perfetto/trace/chrome/chrome_trace_event.pbzero.h"
-#include "third_party/perfetto/protos/perfetto/trace/track_event/debug_annotation.pbzero.h"
 
-using ChromeTracedValue = perfetto::protos::pbzero::ChromeTracedValue;
-using DebugAnnotation = perfetto::protos::pbzero::DebugAnnotation;
 using TracedValue = base::trace_event::TracedValue;
+using ChromeTracedValue = perfetto::protos::pbzero::ChromeTracedValue;
+using TracedValueHandle =
+    protozero::MessageHandle<perfetto::protos::pbzero::ChromeTracedValue>;
 using TraceEvent = base::trace_event::TraceEvent;
 
 namespace tracing {
 
 PerfettoProtoAppender::PerfettoProtoAppender(
     perfetto::protos::pbzero::ChromeTraceEvent_Arg* proto)
-    : arg_proto_(proto), annotation_proto_(nullptr) {}
-
-PerfettoProtoAppender::PerfettoProtoAppender(DebugAnnotation* proto)
-    : arg_proto_(nullptr), annotation_proto_(proto) {}
+    : proto_(proto) {}
 
 PerfettoProtoAppender::~PerfettoProtoAppender() = default;
 
@@ -40,31 +36,23 @@
 }
 
 size_t PerfettoProtoAppender::Finalize(uint32_t field_id) {
-  if (arg_proto_) {
-    return arg_proto_->AppendScatteredBytes(field_id, ranges_.data(),
-                                            ranges_.size());
-  }
-  return annotation_proto_->AppendScatteredBytes(field_id, ranges_.data(),
-                                                 ranges_.size());
+  return proto_->AppendScatteredBytes(field_id, ranges_.data(), ranges_.size());
 }
 
 namespace {
 
 constexpr size_t kDefaultSliceSize = 128;
 
-template <typename ProtoValue, int FieldNumber>
 class ProtoWriter final : public TracedValue::Writer {
  public:
-  using ProtoValueHandle = protozero::MessageHandle<ProtoValue>;
-
   explicit ProtoWriter(size_t initial_slice_size_bytes)
       : buffer_(initial_slice_size_bytes ? initial_slice_size_bytes
                                          : kDefaultSliceSize),
         stream_(&buffer_) {
     proto_.Reset(&stream_);
     buffer_.set_writer(&stream_);
-    node_stack_.emplace(ProtoValueHandle(&proto_));
-    proto_.set_nested_type(ProtoValue::DICT);
+    node_stack_.emplace(TracedValueHandle(&proto_));
+    proto_.set_nested_type(perfetto::protos::pbzero::ChromeTracedValue::DICT);
   }
 
   ~ProtoWriter() override {
@@ -129,7 +117,8 @@
     }
 
     size_t appended_size = node_stack_.top()->AppendScatteredBytes(
-        ProtoValue::kDictValuesFieldNumber, ranges.data(), ranges.size());
+        perfetto::protos::pbzero::ChromeTracedValue::kDictValuesFieldNumber,
+        ranges.data(), ranges.size());
     DCHECK_EQ(full_child_size, appended_size);
   }
 
@@ -138,33 +127,39 @@
   }
 
   void BeginArray() override {
-    node_stack_.emplace(ProtoValueHandle(AddArrayEntry()));
-    node_stack_.top()->set_nested_type(ProtoValue::ARRAY);
+    node_stack_.emplace(TracedValueHandle(AddArrayEntry()));
+    node_stack_.top()->set_nested_type(
+        perfetto::protos::pbzero::ChromeTracedValue::ARRAY);
   }
 
   void BeginDictionary() override {
-    node_stack_.emplace(ProtoValueHandle(AddArrayEntry()));
-    node_stack_.top()->set_nested_type(ProtoValue::DICT);
+    node_stack_.emplace(TracedValueHandle(AddArrayEntry()));
+    node_stack_.top()->set_nested_type(
+        perfetto::protos::pbzero::ChromeTracedValue::DICT);
   }
 
   void BeginDictionary(const char* name) override {
-    node_stack_.emplace(ProtoValueHandle(AddDictEntry(name)));
-    node_stack_.top()->set_nested_type(ProtoValue::DICT);
+    node_stack_.emplace(TracedValueHandle(AddDictEntry(name)));
+    node_stack_.top()->set_nested_type(
+        perfetto::protos::pbzero::ChromeTracedValue::DICT);
   }
 
   void BeginDictionaryWithCopiedName(base::StringPiece name) override {
-    node_stack_.emplace(ProtoValueHandle(AddDictEntry(name)));
-    node_stack_.top()->set_nested_type(ProtoValue::DICT);
+    node_stack_.emplace(TracedValueHandle(AddDictEntry(name)));
+    node_stack_.top()->set_nested_type(
+        perfetto::protos::pbzero::ChromeTracedValue::DICT);
   }
 
   void BeginArray(const char* name) override {
-    node_stack_.emplace(ProtoValueHandle(AddDictEntry(name)));
-    node_stack_.top()->set_nested_type(ProtoValue::ARRAY);
+    node_stack_.emplace(TracedValueHandle(AddDictEntry(name)));
+    node_stack_.top()->set_nested_type(
+        perfetto::protos::pbzero::ChromeTracedValue::ARRAY);
   }
 
   void BeginArrayWithCopiedName(base::StringPiece name) override {
-    node_stack_.emplace(ProtoValueHandle(AddDictEntry(name)));
-    node_stack_.top()->set_nested_type(ProtoValue::ARRAY);
+    node_stack_.emplace(TracedValueHandle(AddDictEntry(name)));
+    node_stack_.top()->set_nested_type(
+        perfetto::protos::pbzero::ChromeTracedValue::ARRAY);
   }
 
   void EndDictionary() override {
@@ -216,7 +211,9 @@
                           slice.start() + slice.size() - slice.unused_bytes());
     }
 
-    size_t appended_size = appender->Finalize(FieldNumber);
+    size_t appended_size =
+        appender->Finalize(perfetto::protos::pbzero::ChromeTraceEvent_Arg::
+                               kTracedValueFieldNumber);
     DCHECK_EQ(full_size, appended_size);
     return true;
   }
@@ -236,55 +233,39 @@
   }
 
  private:
-  ProtoValue* AddDictEntry(const char* name) {
+  ChromeTracedValue* AddDictEntry(const char* name) {
     DCHECK(!node_stack_.empty() && !node_stack_.top()->is_finalized());
     node_stack_.top()->add_dict_keys(name);
     return node_stack_.top()->add_dict_values();
   }
 
-  ProtoValue* AddDictEntry(base::StringPiece name) {
+  ChromeTracedValue* AddDictEntry(base::StringPiece name) {
     DCHECK(!node_stack_.empty() && !node_stack_.top()->is_finalized());
     node_stack_.top()->add_dict_keys(name.data(), name.length());
     return node_stack_.top()->add_dict_values();
   }
 
-  ProtoValue* AddArrayEntry() {
+  ChromeTracedValue* AddArrayEntry() {
     DCHECK(!node_stack_.empty() && !node_stack_.top()->is_finalized());
     return node_stack_.top()->add_array_values();
   }
 
-  std::stack<ProtoValueHandle> node_stack_;
+  std::stack<TracedValueHandle> node_stack_;
 
-  ProtoValue proto_;
+  perfetto::protos::pbzero::ChromeTracedValue proto_;
   protozero::ScatteredHeapBuffer buffer_;
   protozero::ScatteredStreamWriter stream_;
 };
 
-std::unique_ptr<TracedValue::Writer> CreateChromeProtoWriter(
-    size_t initial_slice_size_bytes) {
-  return std::make_unique<ProtoWriter<
-      perfetto::protos::pbzero::ChromeTracedValue,
-      perfetto::protos::pbzero::ChromeTraceEvent_Arg::kTracedValueFieldNumber>>(
-      initial_slice_size_bytes);
-}
-
-std::unique_ptr<TracedValue::Writer> CreateNestedValueProtoWriter(
+std::unique_ptr<TracedValue::Writer> CreateProtoWriter(
     size_t initial_slice_size_bytes) {
-  return std::make_unique<ProtoWriter<
-      DebugAnnotation::NestedValue, DebugAnnotation::kNestedValueFieldNumber>>(
-      initial_slice_size_bytes);
+  return std::make_unique<ProtoWriter>(initial_slice_size_bytes);
 }
 
 }  // namespace
 
-void RegisterTracedValueProtoWriter(bool enable, bool use_chrome_proto) {
-  if (!enable) {
-    TracedValue::SetWriterFactoryCallback(nullptr);
-    return;
-  }
-  TracedValue::SetWriterFactoryCallback(use_chrome_proto
-                                            ? &CreateChromeProtoWriter
-                                            : &CreateNestedValueProtoWriter);
+void RegisterTracedValueProtoWriter(bool enable) {
+  TracedValue::SetWriterFactoryCallback(enable ? &CreateProtoWriter : nullptr);
 }
 
 }  // namespace tracing
--- a/services/tracing/public/cpp/perfetto/traced_value_proto_writer.h	2019-05-01 01:22:57.000000000 +0300
+++ b/services/tracing/public/cpp/perfetto/traced_value_proto_writer.h	2019-05-17 18:53:38.016000000 +0300
@@ -13,7 +13,6 @@
 namespace protos {
 namespace pbzero {
 class ChromeTraceEvent_Arg;
-class DebugAnnotation;
 }  // namespace pbzero
 }  // namespace protos
 }  // namespace perfetto
@@ -25,8 +24,6 @@
  public:
   explicit PerfettoProtoAppender(
       perfetto::protos::pbzero::ChromeTraceEvent_Arg* proto);
-  explicit PerfettoProtoAppender(
-      perfetto::protos::pbzero::DebugAnnotation* proto);
   ~PerfettoProtoAppender() override;
 
   // ProtoAppender implementation
@@ -35,13 +32,10 @@
 
  private:
   std::vector<protozero::ContiguousMemoryRange> ranges_;
-  perfetto::protos::pbzero::ChromeTraceEvent_Arg* arg_proto_;
-  perfetto::protos::pbzero::DebugAnnotation* annotation_proto_;
+  perfetto::protos::pbzero::ChromeTraceEvent_Arg* proto_;
 };
 
-void COMPONENT_EXPORT(TRACING_CPP)
-    RegisterTracedValueProtoWriter(bool enable, bool use_chrome_proto = true);
-
+void COMPONENT_EXPORT(TRACING_CPP) RegisterTracedValueProtoWriter(bool enable);
 }  // namespace tracing
 
 #endif  // SERVICES_TRACING_PUBLIC_CPP_PERFETTO_TRACED_VALUE_PROTO_WRITER_H_
--- a/services/tracing/public/cpp/perfetto/traced_value_proto_writer_unittest.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/tracing/public/cpp/perfetto/traced_value_proto_writer_unittest.cc	2019-05-17 18:53:38.016000000 +0300
@@ -13,8 +13,6 @@
 #include "third_party/perfetto/include/perfetto/protozero/scattered_stream_writer.h"
 #include "third_party/perfetto/protos/perfetto/trace/chrome/chrome_trace_event.pb.h"
 #include "third_party/perfetto/protos/perfetto/trace/chrome/chrome_trace_event.pbzero.h"
-#include "third_party/perfetto/protos/perfetto/trace/track_event/debug_annotation.pb.h"
-#include "third_party/perfetto/protos/perfetto/trace/track_event/debug_annotation.pbzero.h"
 #include "third_party/protobuf/bgoogle/protobuf/io/zero_copy_stream.h"
 
 using TracedValue = base::trace_event::TracedValue;
@@ -23,10 +21,6 @@
 
 namespace {
 
-using perfetto::protos::ChromeTracedValue;
-using perfetto::protos::DebugAnnotation;
-using NestedValue = perfetto::protos::DebugAnnotation::NestedValue;
-
 class ProtoInputStream : public google::protobuf::io::ZeroCopyInputStream {
  public:
   explicit ProtoInputStream(protozero::ScatteredHeapBuffer* buffer)
@@ -73,30 +67,16 @@
   bool has_backed_up_ = false;
 };
 
-// Tests are run with the ChromeTracedValue proto when the param is true, and
-// with TrackEvent's NestedValue otherwise.
-class TracedValueProtoWriterTest : public testing::TestWithParam<bool> {
+class TracedValueProtoWriterTest : public testing::Test {
  public:
-  void SetUp() override {
-    RegisterTracedValueProtoWriter(true, /*use_chrome_proto=*/GetParam());
-  }
+  void SetUp() override { RegisterTracedValueProtoWriter(true); }
 
-  void TearDown() override {
-    RegisterTracedValueProtoWriter(false, /*use_chrome_proto=*/GetParam());
-  }
+  void TearDown() override { RegisterTracedValueProtoWriter(false); }
 };
 
-#define TRACED_VALUE_PROTO_WRITER_TEST_P(test_name) \
-  TEST_P(TracedValueProtoWriterTest, test_name) {   \
-    if (GetParam()) {                               \
-      Test##test_name<ChromeTracedValue>();         \
-    } else {                                        \
-      Test##test_name<NestedValue>();               \
-    }                                               \
-  }
-
-template <typename ValueClass>
-const ValueClass* FindDictEntry(const ValueClass* dict, const char* name) {
+const perfetto::protos::ChromeTracedValue* FindDictEntry(
+    const perfetto::protos::ChromeTracedValue* dict,
+    const char* name) {
   EXPECT_EQ(dict->dict_values_size(), dict->dict_keys_size());
 
   for (int i = 0; i < dict->dict_keys_size(); ++i) {
@@ -109,33 +89,30 @@
   return nullptr;
 }
 
-template <typename ValueClass>
-bool IsValue(const ValueClass* proto_value, bool value) {
+bool IsValue(const perfetto::protos::ChromeTracedValue* proto_value,
+             bool value) {
   return proto_value->has_bool_value() && (proto_value->bool_value() == value);
 }
 
-template <typename ValueClass>
-bool IsValue(const ValueClass* proto_value, double value) {
+bool IsValue(const perfetto::protos::ChromeTracedValue* proto_value,
+             double value) {
   return proto_value->has_double_value() &&
          (proto_value->double_value() == value);
 }
 
-template <typename ValueClass>
-bool IsValue(const ValueClass* proto_value, int value) {
+bool IsValue(const perfetto::protos::ChromeTracedValue* proto_value,
+             int value) {
   return proto_value->has_int_value() && (proto_value->int_value() == value);
 }
 
-template <typename ValueClass>
-bool IsValue(const ValueClass* proto_value, const char* value) {
+bool IsValue(const perfetto::protos::ChromeTracedValue* proto_value,
+             const char* value) {
   return proto_value->has_string_value() &&
          (proto_value->string_value() == value);
 }
 
-template <typename ValueClass>
-ValueClass GetProtoFromTracedValue(TracedValue* traced_value);
-
-template <>
-ChromeTracedValue GetProtoFromTracedValue(TracedValue* traced_value) {
+perfetto::protos::ChromeTracedValue GetProtoFromTracedValue(
+    TracedValue* traced_value) {
   protozero::ScatteredHeapBuffer buffer(100);
   protozero::ScatteredStreamWriter stream(&buffer);
   perfetto::protos::pbzero::ChromeTraceEvent_Arg proto;
@@ -154,62 +131,35 @@
   return full_proto.traced_value();
 }
 
-template <>
-NestedValue GetProtoFromTracedValue(TracedValue* traced_value) {
-  protozero::ScatteredHeapBuffer buffer(100);
-  protozero::ScatteredStreamWriter stream(&buffer);
-  perfetto::protos::pbzero::DebugAnnotation proto;
-  proto.Reset(&stream);
-  buffer.set_writer(&stream);
-
-  PerfettoProtoAppender proto_appender(&proto);
-  EXPECT_TRUE(traced_value->AppendToProto(&proto_appender));
-  uint32_t size = proto.Finalize();
-  ProtoInputStream proto_stream(&buffer);
-
-  DebugAnnotation full_proto;
-  EXPECT_TRUE(full_proto.ParseFromBoundedZeroCopyStream(&proto_stream, size));
-  EXPECT_TRUE(full_proto.has_nested_value());
-
-  return full_proto.nested_value();
-}
-
-template <typename ValueClass>
-void TestFlatDictionary() {
+TEST_F(TracedValueProtoWriterTest, FlatDictionary) {
   std::unique_ptr<TracedValue> value(new TracedValue());
   value->SetBoolean("bool", true);
   value->SetDouble("double", 0.0);
   value->SetInteger("int", 2014);
   value->SetString("string", "string");
 
-  auto full_proto = GetProtoFromTracedValue<ValueClass>(value.get());
+  auto full_proto = GetProtoFromTracedValue(value.get());
   EXPECT_TRUE(IsValue(FindDictEntry(&full_proto, "bool"), true));
   EXPECT_TRUE(IsValue(FindDictEntry(&full_proto, "double"), 0.0));
   EXPECT_TRUE(IsValue(FindDictEntry(&full_proto, "int"), 2014));
   EXPECT_TRUE(IsValue(FindDictEntry(&full_proto, "string"), "string"));
 }
 
-TRACED_VALUE_PROTO_WRITER_TEST_P(FlatDictionary)
-
-template <typename ValueClass>
-void TestNoDotPathExpansion() {
+TEST_F(TracedValueProtoWriterTest, NoDotPathExpansion) {
   std::unique_ptr<TracedValue> value(new TracedValue());
-  value->SetBoolean("bool", true);
-  value->SetDouble("double", 0.0);
-  value->SetInteger("int", 2014);
-  value->SetString("string", "string");
-
-  auto full_proto = GetProtoFromTracedValue<ValueClass>(value.get());
-  EXPECT_TRUE(IsValue(FindDictEntry(&full_proto, "bool"), true));
-  EXPECT_TRUE(IsValue(FindDictEntry(&full_proto, "double"), 0.0));
-  EXPECT_TRUE(IsValue(FindDictEntry(&full_proto, "int"), 2014));
-  EXPECT_TRUE(IsValue(FindDictEntry(&full_proto, "string"), "string"));
+  value->SetBoolean("bo.ol", true);
+  value->SetDouble("doub.le", 0.0);
+  value->SetInteger("in.t", 2014);
+  value->SetString("str.ing", "str.ing");
+
+  auto full_proto = GetProtoFromTracedValue(value.get());
+  EXPECT_TRUE(IsValue(FindDictEntry(&full_proto, "bo.ol"), true));
+  EXPECT_TRUE(IsValue(FindDictEntry(&full_proto, "doub.le"), 0.0));
+  EXPECT_TRUE(IsValue(FindDictEntry(&full_proto, "in.t"), 2014));
+  EXPECT_TRUE(IsValue(FindDictEntry(&full_proto, "str.ing"), "str.ing"));
 }
 
-TRACED_VALUE_PROTO_WRITER_TEST_P(NoDotPathExpansion)
-
-template <typename ValueClass>
-void TestHierarchy() {
+TEST_F(TracedValueProtoWriterTest, Hierarchy) {
   std::unique_ptr<TracedValue> value(new TracedValue());
   value->BeginArray("a1");
   value->AppendInteger(1);
@@ -230,17 +180,19 @@
   value->SetInteger("i0", 2014);
   value->SetString("s0", "foo");
 
-  auto full_proto = GetProtoFromTracedValue<ValueClass>(value.get());
+  auto full_proto = GetProtoFromTracedValue(value.get());
 
   auto* a1_array = FindDictEntry(&full_proto, "a1");
   EXPECT_TRUE(a1_array);
-  EXPECT_EQ(a1_array->nested_type(), ValueClass::ARRAY);
+  EXPECT_EQ(a1_array->nested_type(),
+            perfetto::protos::ChromeTracedValue::ARRAY);
   EXPECT_EQ(a1_array->array_values_size(), 3);
   EXPECT_TRUE(IsValue(&a1_array->array_values(0), 1));
   EXPECT_TRUE(IsValue(&a1_array->array_values(1), true));
   auto* a1_subdict = &a1_array->array_values(2);
   EXPECT_TRUE(a1_subdict);
-  EXPECT_EQ(a1_subdict->nested_type(), ValueClass::DICT);
+  EXPECT_EQ(a1_subdict->nested_type(),
+            perfetto::protos::ChromeTracedValue::DICT);
   EXPECT_EQ(a1_subdict->dict_values_size(), 1);
   EXPECT_TRUE(IsValue(FindDictEntry(a1_subdict, "i2"), 3));
   EXPECT_TRUE(IsValue(FindDictEntry(&full_proto, "b0"), true));
@@ -248,11 +200,11 @@
   auto* dict1 = FindDictEntry(&full_proto, "dict1");
   EXPECT_TRUE(dict1);
   EXPECT_EQ(dict1->dict_values_size(), 3);
-  EXPECT_EQ(dict1->nested_type(), ValueClass::DICT);
+  EXPECT_EQ(dict1->nested_type(), perfetto::protos::ChromeTracedValue::DICT);
   auto* dict2 = FindDictEntry(dict1, "dict2");
   EXPECT_TRUE(dict2);
   EXPECT_EQ(dict2->dict_values_size(), 1);
-  EXPECT_EQ(dict2->nested_type(), ValueClass::DICT);
+  EXPECT_EQ(dict2->nested_type(), perfetto::protos::ChromeTracedValue::DICT);
   EXPECT_TRUE(IsValue(FindDictEntry(dict2, "b2"), false));
   EXPECT_TRUE(IsValue(FindDictEntry(dict1, "i1"), 2014));
   EXPECT_TRUE(IsValue(FindDictEntry(dict1, "s1"), "foo"));
@@ -260,10 +212,7 @@
   EXPECT_TRUE(IsValue(FindDictEntry(&full_proto, "s0"), "foo"));
 }
 
-TRACED_VALUE_PROTO_WRITER_TEST_P(Hierarchy)
-
-template <typename ValueClass>
-void TestLongStrings() {
+TEST_F(TracedValueProtoWriterTest, LongStrings) {
   std::string kLongString = "supercalifragilisticexpialidocious";
   std::string kLongString2 = "0123456789012345678901234567890123456789";
   char kLongString3[4096];
@@ -282,33 +231,31 @@
   value->EndDictionary();
   value->EndArray();
 
-  auto full_proto = GetProtoFromTracedValue<ValueClass>(value.get());
+  auto full_proto = GetProtoFromTracedValue(value.get());
 
   EXPECT_TRUE(IsValue(FindDictEntry(&full_proto, "a"), "short"));
   EXPECT_TRUE(IsValue(FindDictEntry(&full_proto, "b"), kLongString.c_str()));
   auto* c_array = FindDictEntry(&full_proto, "c");
   EXPECT_TRUE(c_array);
   EXPECT_EQ(c_array->array_values_size(), 3);
-  EXPECT_EQ(c_array->nested_type(), ValueClass::ARRAY);
+  EXPECT_EQ(c_array->nested_type(), perfetto::protos::ChromeTracedValue::ARRAY);
   EXPECT_TRUE(IsValue(&c_array->array_values(0), kLongString2.c_str()));
   EXPECT_TRUE(IsValue(&c_array->array_values(1), ""));
   auto* c_subdict = &c_array->array_values(2);
   EXPECT_TRUE(c_subdict);
   EXPECT_EQ(c_subdict->dict_values_size(), 1);
-  EXPECT_EQ(c_subdict->nested_type(), ValueClass::DICT);
+  EXPECT_EQ(c_subdict->nested_type(),
+            perfetto::protos::ChromeTracedValue::DICT);
   EXPECT_TRUE(IsValue(FindDictEntry(c_subdict, "a"), kLongString3));
 }
 
-TRACED_VALUE_PROTO_WRITER_TEST_P(LongStrings)
-
 // Test that the proto which results from the TracedValue is still
 // valid regardless of the size of the buffer chunks we provide to
 // the allocator, as some buffer sizes will leave unused bytes
 // at the end where there isn't enough space for, say, a size field.
 // 10-140 bytes tests both buffers being smaller and larger than
 // the actual size of the proto.
-template <typename ValueClass>
-void TestProtoMessageBoundaries() {
+TEST_F(TracedValueProtoWriterTest, ProtoMessageBoundaries) {
   for (int i = 10; i < 140; ++i) {
     std::unique_ptr<TracedValue> value(new TracedValue(i));
 
@@ -316,7 +263,7 @@
     value->SetString("thread", "RendererCompositor");
     value->SetString("compile_target", "Chromium");
 
-    auto full_proto = GetProtoFromTracedValue<ValueClass>(value.get());
+    auto full_proto = GetProtoFromTracedValue(value.get());
 
     EXPECT_TRUE(
         IsValue(FindDictEntry(&full_proto, "source"), "RendererCompositor"));
@@ -327,10 +274,7 @@
   }
 }
 
-TRACED_VALUE_PROTO_WRITER_TEST_P(ProtoMessageBoundaries)
-
-template <typename ValueClass>
-void TestPassTracedValue() {
+TEST_F(TracedValueProtoWriterTest, PassTracedValue) {
   auto dict_value = std::make_unique<TracedValue>();
   dict_value->SetInteger("a", 1);
 
@@ -344,7 +288,7 @@
 
   {
     // Check the merged result.
-    auto parent_proto = GetProtoFromTracedValue<ValueClass>(dict_value.get());
+    auto parent_proto = GetProtoFromTracedValue(dict_value.get());
 
     EXPECT_TRUE(IsValue(FindDictEntry(&parent_proto, "a"), 1));
 
@@ -360,8 +304,7 @@
 
   {
     // Check that the passed nested dict was left untouched.
-    auto child_proto =
-        GetProtoFromTracedValue<ValueClass>(nested_dict_value.get());
+    auto child_proto = GetProtoFromTracedValue(nested_dict_value.get());
     EXPECT_TRUE(IsValue(FindDictEntry(&child_proto, "b"), 2));
     auto* c_array = FindDictEntry(&child_proto, "c");
     EXPECT_TRUE(c_array);
@@ -370,11 +313,6 @@
   }
 }
 
-TRACED_VALUE_PROTO_WRITER_TEST_P(PassTracedValue)
-
-// Run tests both for the ChromeEventBundle and the new TraceEvent protos.
-INSTANTIATE_TEST_SUITE_P(, TracedValueProtoWriterTest, ::testing::Bool());
-
 }  // namespace
 
 }  // namespace tracing
--- a/services/tracing/public/cpp/perfetto/trace_event_data_source.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/tracing/public/cpp/perfetto/trace_event_data_source.cc	2019-05-17 18:53:38.016000000 +0300
@@ -8,26 +8,16 @@
 #include <map>
 #include <utility>
 
-#include "base/base64.h"
-#include "base/bind.h"
-#include "base/bind_helpers.h"
-#include "base/command_line.h"
 #include "base/json/json_writer.h"
 #include "base/memory/ref_counted_memory.h"
-#include "base/metrics/histogram_samples.h"
-#include "base/metrics/statistics_recorder.h"
 #include "base/no_destructor.h"
-#include "base/pickle.h"
+#include "base/process/process_handle.h"
+#include "base/trace_event/trace_buffer.h"
 #include "base/trace_event/trace_event.h"
-#include "components/tracing/common/tracing_switches.h"
-#include "services/tracing/public/cpp/perfetto/chrome_bundle_thread_local_event_sink.h"
-#include "services/tracing/public/cpp/perfetto/thread_local_event_sink.h"
+#include "build/build_config.h"
 #include "services/tracing/public/cpp/perfetto/traced_value_proto_writer.h"
-#include "services/tracing/public/cpp/perfetto/track_event_thread_local_event_sink.h"
 #include "services/tracing/public/mojom/constants.mojom.h"
 #include "third_party/perfetto/include/perfetto/tracing/core/shared_memory_arbiter.h"
-#include "third_party/perfetto/include/perfetto/tracing/core/startup_trace_writer.h"
-#include "third_party/perfetto/include/perfetto/tracing/core/startup_trace_writer_registry.h"
 #include "third_party/perfetto/include/perfetto/tracing/core/trace_writer.h"
 #include "third_party/perfetto/protos/perfetto/trace/chrome/chrome_trace_event.pbzero.h"
 #include "third_party/perfetto/protos/perfetto/trace/trace_packet.pbzero.h"
@@ -36,6 +26,18 @@
 using TraceEvent = base::trace_event::TraceEvent;
 using TraceConfig = base::trace_event::TraceConfig;
 
+namespace {
+static const size_t kMaxEventsPerMessage = 100;
+static const size_t kMaxCompleteEventDepth = 20;
+
+// To mark TraceEvent handles that have been added by Perfetto,
+// we use the chunk index so high that TraceLog would've asserted
+// at this point anyway.
+static const uint32_t kMagicChunkIndex =
+    base::trace_event::TraceBufferChunk::kMaxChunkIndex;
+
+}  // namespace
+
 namespace tracing {
 
 using ChromeEventBundleHandle =
@@ -50,6 +52,7 @@
 void TraceEventMetadataSource::AddGeneratorFunction(
     MetadataGeneratorFunction generator) {
   DCHECK(origin_task_runner_->RunsTasksInCurrentSequence());
+  base::AutoLock lock(lock_);
   generator_functions_.push_back(generator);
 }
 
@@ -60,6 +63,7 @@
   auto trace_packet = trace_writer->NewTracePacket();
   ChromeEventBundleHandle event_bundle(trace_packet->set_chrome_events());
 
+  base::AutoLock lock(lock_);
   for (auto& generator : generator_functions_) {
     std::unique_ptr<base::DictionaryValue> metadata_dict = generator.Run();
     if (!metadata_dict) {
@@ -87,23 +91,25 @@
 
 void TraceEventMetadataSource::StartTracing(
     ProducerClient* producer_client,
-    const perfetto::DataSourceConfig& data_source_config) {
+    const mojom::DataSourceConfig& data_source_config) {
   // TODO(eseckler): Once we support streaming of trace data, it would make
   // sense to emit the metadata on startup, so the UI can display it right away.
-  trace_writer_ =
-      producer_client->CreateTraceWriter(data_source_config.target_buffer());
+  producer_client_ = producer_client;
+  target_buffer_ = data_source_config.target_buffer;
 }
 
 void TraceEventMetadataSource::StopTracing(
     base::OnceClosure stop_complete_callback) {
-  if (trace_writer_) {
+  if (producer_client_) {
     // Write metadata at the end of tracing to make it less likely that it is
     // overridden by other trace data in perfetto's ring buffer.
     origin_task_runner_->PostTaskAndReply(
         FROM_HERE,
         base::BindOnce(&TraceEventMetadataSource::GenerateMetadata,
-                       base::Unretained(this), std::move(trace_writer_)),
+                       base::Unretained(this),
+                       producer_client_->CreateTraceWriter(target_buffer_)),
         std::move(stop_complete_callback));
+    producer_client_ = nullptr;
   } else {
     std::move(stop_complete_callback).Run();
   }
@@ -115,19 +121,337 @@
                                         std::move(flush_complete_callback));
 }
 
+class TraceEventDataSource::ThreadLocalEventSink {
+ public:
+  ThreadLocalEventSink(std::unique_ptr<perfetto::TraceWriter> trace_writer,
+                       bool thread_will_flush)
+      : trace_writer_(std::move(trace_writer)),
+        thread_will_flush_(thread_will_flush) {
+#if DCHECK_IS_ON()
+    static std::atomic<int32_t> id_counter(1);
+    sink_id_ = id_counter.fetch_add(1, std::memory_order_relaxed);
+#endif  // DCHECK_IS_ON()
+  }
+
+  ~ThreadLocalEventSink() {
+    // Finalize the current message before posting the |trace_writer_| for
+    // destruction, to avoid data races.
+    event_bundle_ = ChromeEventBundleHandle();
+    trace_packet_handle_ = perfetto::TraceWriter::TracePacketHandle();
+
+    // Delete the TraceWriter on the sequence that Perfetto runs on, needed
+    // as the ThreadLocalEventSink gets deleted on thread
+    // shutdown and we can't safely call TaskRunnerHandle::Get() at that point
+    // (which can happen as the TraceWriter destructor might make a Mojo call
+    // and trigger it).
+    ProducerClient::GetTaskRunner()->DeleteSoon(FROM_HERE,
+                                                std::move(trace_writer_));
+  }
+
+  void EnsureValidHandles() {
+    if (trace_packet_handle_) {
+      return;
+    }
+
+    trace_packet_handle_ = trace_writer_->NewTracePacket();
+    event_bundle_ =
+        ChromeEventBundleHandle(trace_packet_handle_->set_chrome_events());
+    string_table_.clear();
+    next_string_table_index_ = 0;
+    current_eventcount_for_message_ = 0;
+  }
+
+  int GetStringTableIndexForString(const char* str_value) {
+    EnsureValidHandles();
+
+    auto it = string_table_.find(reinterpret_cast<intptr_t>(str_value));
+    if (it != string_table_.end()) {
+      CHECK_EQ(std::string(reinterpret_cast<const char*>(it->first)),
+               std::string(str_value));
+
+      return it->second;
+    }
+
+    int string_table_index = ++next_string_table_index_;
+    string_table_[reinterpret_cast<intptr_t>(str_value)] = string_table_index;
+
+    auto* new_string_table_entry = event_bundle_->add_string_table();
+    new_string_table_entry->set_value(str_value);
+    new_string_table_entry->set_index(string_table_index);
+
+    return string_table_index;
+  }
+
+  void AddConvertableToTraceFormat(
+      base::trace_event::ConvertableToTraceFormat* value,
+      perfetto::protos::pbzero::ChromeTraceEvent_Arg* arg) {
+    PerfettoProtoAppender proto_appender(arg);
+    if (value->AppendToProto(&proto_appender)) {
+      return;
+    }
+
+    std::string json = value->ToString();
+    arg->set_json_value(json.c_str());
+  }
+
+  void AddTraceEvent(TraceEvent* trace_event,
+                     base::trace_event::TraceEventHandle* handle) {
+    // TODO(oysteine): Adding trace events to Perfetto will
+    // stall in some situations, specifically when we overflow
+    // the buffer and need to make a sync call to flush it, and we're
+    // running on the same thread as the service. The short-term fix (while
+    // we're behind a flag) is to run the service on its own thread, the longer
+    // term fix is most likely to not go via Mojo in that specific case.
+
+    // TODO(oysteine): Temporary workaround for a specific trace event
+    // which is added while a scheduler lock is held, and will deadlock
+    // if Perfetto does a PostTask to commit a finished chunk.
+    if (strcmp(trace_event->name(), "RealTimeDomain::DelayTillNextTask") == 0) {
+      return;
+    }
+
+    if (handle && trace_event->phase() == TRACE_EVENT_PHASE_COMPLETE) {
+      // 'X' phase events are added through a scoped object and
+      // will have its duration updated when said object drops off
+      // the stack; keep a copy of the event around instead of
+      // writing it into SHM, until we have the duration.
+      // We can't keep the TraceEvent around in the scoped object
+      // itself as that causes a lot more codegen in the callsites
+      // and bloats the binary size too much (due to the increased
+      // sizeof() of the scoped object itself).
+      DCHECK_LT(current_stack_depth_, kMaxCompleteEventDepth);
+      if (current_stack_depth_ >= kMaxCompleteEventDepth) {
+        return;
+      }
+
+#if DCHECK_IS_ON()
+      handle->chunk_seq = sink_id_;
+#endif  // DCHECK_IS_ON()
+
+      complete_event_stack_[current_stack_depth_] = std::move(*trace_event);
+      handle->event_index = ++current_stack_depth_;
+      handle->chunk_index = kMagicChunkIndex;
+      return;
+    }
+
+    EnsureValidHandles();
+
+    uint32_t name_index = 0;
+    uint32_t category_name_index = 0;
+    const size_t kMaxSize = base::trace_event::TraceArguments::kMaxSize;
+    uint32_t arg_name_indices[kMaxSize] = {0};
+
+    // Populate any new string table parts first; has to be done before
+    // the add_trace_events() call (as the string table is part of the outer
+    // proto message).
+    // If the TRACE_EVENT_FLAG_COPY flag is set, the char* pointers aren't
+    // necessarily valid after the TRACE_EVENT* call, and so we need to store
+    // the string every time.
+    bool string_table_enabled =
+        !(trace_event->flags() & TRACE_EVENT_FLAG_COPY) && thread_will_flush_;
+    if (string_table_enabled) {
+      name_index = GetStringTableIndexForString(trace_event->name());
+      category_name_index =
+          GetStringTableIndexForString(TraceLog::GetCategoryGroupName(
+              trace_event->category_group_enabled()));
+
+      for (size_t i = 0;
+           i < trace_event->arg_size() && trace_event->arg_name(i); ++i) {
+        arg_name_indices[i] =
+            GetStringTableIndexForString(trace_event->arg_name(i));
+      }
+    }
+
+    auto* new_trace_event = event_bundle_->add_trace_events();
+
+    if (name_index) {
+      new_trace_event->set_name_index(name_index);
+    } else {
+      new_trace_event->set_name(trace_event->name());
+    }
+
+    if (category_name_index) {
+      new_trace_event->set_category_group_name_index(category_name_index);
+    } else {
+      new_trace_event->set_category_group_name(TraceLog::GetCategoryGroupName(
+          trace_event->category_group_enabled()));
+    }
+
+    new_trace_event->set_timestamp(
+        trace_event->timestamp().since_origin().InMicroseconds());
+
+    uint32_t flags = trace_event->flags();
+    new_trace_event->set_flags(flags);
+
+    int process_id;
+    int thread_id;
+    if ((flags & TRACE_EVENT_FLAG_HAS_PROCESS_ID) &&
+        trace_event->process_id() != base::kNullProcessId) {
+      process_id = trace_event->process_id();
+      thread_id = -1;
+    } else {
+      process_id = TraceLog::GetInstance()->process_id();
+      thread_id = trace_event->thread_id();
+    }
+
+    new_trace_event->set_process_id(process_id);
+    new_trace_event->set_thread_id(thread_id);
+
+    char phase = trace_event->phase();
+    new_trace_event->set_phase(phase);
+
+    for (size_t i = 0; i < trace_event->arg_size() && trace_event->arg_name(i);
+         ++i) {
+      auto type = trace_event->arg_type(i);
+      auto* new_arg = new_trace_event->add_args();
+
+      if (arg_name_indices[i]) {
+        new_arg->set_name_index(arg_name_indices[i]);
+      } else {
+        new_arg->set_name(trace_event->arg_name(i));
+      }
+
+      if (type == TRACE_VALUE_TYPE_CONVERTABLE) {
+        AddConvertableToTraceFormat(trace_event->arg_convertible_value(i),
+                                    new_arg);
+        continue;
+      }
+
+      auto& value = trace_event->arg_value(i);
+      switch (type) {
+        case TRACE_VALUE_TYPE_BOOL:
+          new_arg->set_bool_value(value.as_bool);
+          break;
+        case TRACE_VALUE_TYPE_UINT:
+          new_arg->set_uint_value(value.as_uint);
+          break;
+        case TRACE_VALUE_TYPE_INT:
+          new_arg->set_int_value(value.as_int);
+          break;
+        case TRACE_VALUE_TYPE_DOUBLE:
+          new_arg->set_double_value(value.as_double);
+          break;
+        case TRACE_VALUE_TYPE_POINTER:
+          new_arg->set_pointer_value(static_cast<uint64_t>(
+              reinterpret_cast<uintptr_t>(value.as_pointer)));
+          break;
+        case TRACE_VALUE_TYPE_STRING:
+        case TRACE_VALUE_TYPE_COPY_STRING:
+          new_arg->set_string_value(value.as_string ? value.as_string : "NULL");
+          break;
+        default:
+          NOTREACHED() << "Don't know how to print this value";
+          break;
+      }
+    }
+
+    if (phase == TRACE_EVENT_PHASE_COMPLETE) {
+      new_trace_event->set_duration(trace_event->duration().InMicroseconds());
+
+      if (!trace_event->thread_timestamp().is_null()) {
+        int64_t thread_duration =
+            trace_event->thread_duration().InMicroseconds();
+        if (thread_duration != -1) {
+          new_trace_event->set_thread_duration(thread_duration);
+        }
+      }
+    }
+
+    if (!trace_event->thread_timestamp().is_null()) {
+      int64_t thread_time_int64 =
+          trace_event->thread_timestamp().since_origin().InMicroseconds();
+      new_trace_event->set_thread_timestamp(thread_time_int64);
+    }
+
+    if (trace_event->scope() != trace_event_internal::kGlobalScope) {
+      new_trace_event->set_scope(trace_event->scope());
+    }
+
+    if (flags & (TRACE_EVENT_FLAG_HAS_ID | TRACE_EVENT_FLAG_HAS_LOCAL_ID |
+                 TRACE_EVENT_FLAG_HAS_GLOBAL_ID)) {
+      new_trace_event->set_id(trace_event->id());
+    }
+
+    if ((flags & TRACE_EVENT_FLAG_FLOW_OUT) ||
+        (flags & TRACE_EVENT_FLAG_FLOW_IN)) {
+      new_trace_event->set_bind_id(trace_event->bind_id());
+    }
+
+    // If we know that the current thread will never send a Flush message
+    // (meaning it's a thread without a messageloop that TraceLog knows about),
+    // we need to finalize the packet right away so Perfetto can recover it.
+    // We also enforce an upper bound on how many submessages we'll add
+    // for a given TracePacket so they won't grow infinitely.
+    if (!thread_will_flush_ ||
+        current_eventcount_for_message_++ > kMaxEventsPerMessage) {
+      event_bundle_ = ChromeEventBundleHandle();
+      trace_packet_handle_ = perfetto::TraceWriter::TracePacketHandle();
+    }
+  }
+
+  void UpdateDuration(base::trace_event::TraceEventHandle handle,
+                      const base::TimeTicks& now,
+                      const base::ThreadTicks& thread_now) {
+    if (!handle.event_index || handle.chunk_index != kMagicChunkIndex) {
+      return;
+    }
+
+#if DCHECK_IS_ON()
+    DCHECK_EQ(handle.chunk_seq, sink_id_);
+#endif  // DCHECK_IS_ON()
+
+    DCHECK_EQ(handle.event_index, current_stack_depth_);
+    DCHECK_GE(current_stack_depth_, 1u);
+    current_stack_depth_--;
+    complete_event_stack_[current_stack_depth_].UpdateDuration(now, thread_now);
+    AddTraceEvent(&complete_event_stack_[current_stack_depth_], nullptr);
+
+#if defined(OS_ANDROID)
+    complete_event_stack_[current_stack_depth_].SendToATrace();
+#endif
+  }
+
+  void Flush() {
+    // TODO(oysteine): This will break events if we flush
+    // while recording. This can't be done on destruction
+    // as this can trigger PostTasks which may not be possible
+    // if the thread is being shut down.
+    while (current_stack_depth_--) {
+      AddTraceEvent(&complete_event_stack_[current_stack_depth_], nullptr);
+    }
+
+    event_bundle_ = ChromeEventBundleHandle();
+    trace_packet_handle_ = perfetto::TraceWriter::TracePacketHandle();
+    trace_writer_->Flush();
+  }
+
+ private:
+  std::unique_ptr<perfetto::TraceWriter> trace_writer_;
+  const bool thread_will_flush_;
+  ChromeEventBundleHandle event_bundle_;
+  perfetto::TraceWriter::TracePacketHandle trace_packet_handle_;
+  std::map<intptr_t, int> string_table_;
+  int next_string_table_index_ = 0;
+  size_t current_eventcount_for_message_ = 0;
+  TraceEvent complete_event_stack_[kMaxCompleteEventDepth];
+  uint32_t current_stack_depth_ = 0;
+#if DCHECK_IS_ON()
+  uint32_t sink_id_;
+#endif  // DCHECK_IS_ON()
+};
+
 namespace {
 
 base::ThreadLocalStorage::Slot* ThreadLocalEventSinkSlot() {
   static base::NoDestructor<base::ThreadLocalStorage::Slot>
       thread_local_event_sink_tls([](void* event_sink) {
-        delete static_cast<ThreadLocalEventSink*>(event_sink);
+        delete static_cast<TraceEventDataSource::ThreadLocalEventSink*>(
+            event_sink);
       });
 
   return thread_local_event_sink_tls.get();
 }
 
-TraceEventDataSource* g_trace_event_data_source_for_testing = nullptr;
-
 }  // namespace
 
 // static
@@ -136,80 +460,36 @@
   return instance.get();
 }
 
-// static
-void TraceEventDataSource::ResetForTesting() {
-  if (!g_trace_event_data_source_for_testing)
-    return;
-  g_trace_event_data_source_for_testing->~TraceEventDataSource();
-  new (g_trace_event_data_source_for_testing) TraceEventDataSource;
-}
-
 TraceEventDataSource::TraceEventDataSource()
-    : DataSourceBase(mojom::kTraceEventDataSourceName),
-      use_chrome_proto_(!base::CommandLine::ForCurrentProcess()->HasSwitch(
-          switches::kPerfettoUseNewProtos)),
-      disable_interning_(base::CommandLine::ForCurrentProcess()->HasSwitch(
-          switches::kPerfettoDisableInterning)) {
-  g_trace_event_data_source_for_testing = this;
+    : DataSourceBase(mojom::kTraceEventDataSourceName) {
 }
 
 TraceEventDataSource::~TraceEventDataSource() = default;
 
-void TraceEventDataSource::RegisterWithTraceLog() {
-  RegisterTracedValueProtoWriter(true, use_chrome_proto_);
-  TraceLog::GetInstance()->SetAddTraceEventOverrides(
-      &TraceEventDataSource::OnAddTraceEvent,
-      &TraceEventDataSource::FlushCurrentThread,
-      &TraceEventDataSource::OnUpdateDuration);
-}
-
-void TraceEventDataSource::UnregisterFromTraceLog() {
-  RegisterTracedValueProtoWriter(false, use_chrome_proto_);
-  TraceLog::GetInstance()->SetAddTraceEventOverrides(nullptr, nullptr, nullptr);
-}
-
-void TraceEventDataSource::SetupStartupTracing() {
-  {
-    base::AutoLock lock(lock_);
-    DCHECK(!startup_writer_registry_ && !producer_client_);
-    startup_writer_registry_ =
-        std::make_unique<perfetto::StartupTraceWriterRegistry>();
-  }
-  RegisterWithTraceLog();
-}
-
 void TraceEventDataSource::StartTracing(
     ProducerClient* producer_client,
-    const perfetto::DataSourceConfig& data_source_config) {
-  std::unique_ptr<perfetto::StartupTraceWriterRegistry> unbound_writer_registry;
+    const mojom::DataSourceConfig& data_source_config) {
   {
     base::AutoLock lock(lock_);
 
     DCHECK(!producer_client_);
     producer_client_ = producer_client;
-    target_buffer_ = data_source_config.target_buffer();
-    // Reduce lock contention by binding the registry without holding the lock.
-    unbound_writer_registry = std::move(startup_writer_registry_);
+    target_buffer_ = data_source_config.target_buffer;
   }
 
-  session_id_.fetch_add(1u, std::memory_order_relaxed);
+  RegisterTracedValueProtoWriter(true);
 
-  if (unbound_writer_registry) {
-    producer_client->BindStartupTraceWriterRegistry(
-        std::move(unbound_writer_registry), data_source_config.target_buffer());
-  } else {
-    RegisterWithTraceLog();
-  }
+  TraceLog::GetInstance()->SetAddTraceEventOverrides(
+      &TraceEventDataSource::OnAddTraceEvent,
+      &TraceEventDataSource::FlushCurrentThread,
+      &TraceEventDataSource::OnUpdateDuration);
 
-  auto trace_config =
-      TraceConfig(data_source_config.chrome_config().trace_config());
-  TraceLog::GetInstance()->SetEnabled(trace_config, TraceLog::RECORDING_MODE);
-  ResetHistograms(trace_config);
+  TraceLog::GetInstance()->SetEnabled(
+      TraceConfig(data_source_config.trace_config), TraceLog::RECORDING_MODE);
 }
 
 void TraceEventDataSource::StopTracing(
     base::OnceClosure stop_complete_callback) {
-  LogHistograms();
   stop_complete_callback_ = std::move(stop_complete_callback);
 
   auto on_tracing_stopped_callback =
@@ -219,7 +499,9 @@
           return;
         }
 
-        data_source->UnregisterFromTraceLog();
+        RegisterTracedValueProtoWriter(false);
+        TraceLog::GetInstance()->SetAddTraceEventOverrides(nullptr, nullptr,
+                                                           nullptr);
 
         if (data_source->stop_complete_callback_) {
           std::move(data_source->stop_complete_callback_).Run();
@@ -260,36 +542,6 @@
   }
 }
 
-void TraceEventDataSource::LogHistogram(base::HistogramBase* histogram) {
-  if (!histogram) {
-    return;
-  }
-  auto samples = histogram->SnapshotSamples();
-  base::Pickle pickle;
-  samples->Serialize(&pickle);
-  std::string buckets;
-  base::Base64Encode(
-      std::string(static_cast<const char*>(pickle.data()), pickle.size()),
-      &buckets);
-  TRACE_EVENT_INSTANT2("benchmark", "UMAHistogramSamples",
-                       TRACE_EVENT_SCOPE_PROCESS, "name",
-                       histogram->histogram_name(), "buckets", buckets);
-}
-
-void TraceEventDataSource::ResetHistograms(const TraceConfig& trace_config) {
-  histograms_.clear();
-  for (const std::string& histogram_name : trace_config.histogram_names()) {
-    histograms_.push_back(histogram_name);
-    LogHistogram(base::StatisticsRecorder::FindHistogram(histogram_name));
-  }
-}
-
-void TraceEventDataSource::LogHistograms() {
-  for (const std::string& histogram_name : histograms_) {
-    LogHistogram(base::StatisticsRecorder::FindHistogram(histogram_name));
-  }
-}
-
 void TraceEventDataSource::Flush(
     base::RepeatingClosure flush_complete_callback) {
   DCHECK(TraceLog::GetInstance()->IsEnabled());
@@ -305,39 +557,16 @@
       std::move(flush_complete_callback)));
 }
 
-void TraceEventDataSource::ResetIncrementalStateForTesting() {
-  auto* thread_local_event_sink =
-      static_cast<ThreadLocalEventSink*>(ThreadLocalEventSinkSlot()->Get());
-  if (thread_local_event_sink)
-    thread_local_event_sink->ResetIncrementalState();
-}
-
-ThreadLocalEventSink* TraceEventDataSource::CreateThreadLocalEventSink(
-    bool thread_will_flush) {
+TraceEventDataSource::ThreadLocalEventSink*
+TraceEventDataSource::CreateThreadLocalEventSink(bool thread_will_flush) {
   base::AutoLock lock(lock_);
-  // |startup_writer_registry_| only exists during startup tracing before we
-  // connect to the service. |producer_client_| is reset when tracing is
-  // stopped.
-  std::unique_ptr<perfetto::StartupTraceWriter> trace_writer;
-  uint32_t session_id = session_id_.load(std::memory_order_relaxed);
-  if (startup_writer_registry_) {
-    trace_writer = startup_writer_registry_->CreateUnboundTraceWriter();
-  } else if (producer_client_) {
-    trace_writer = std::make_unique<perfetto::StartupTraceWriter>(
-        producer_client_->CreateTraceWriter(target_buffer_));
-  }
 
-  if (!trace_writer) {
+  if (producer_client_) {
+    return new ThreadLocalEventSink(
+        producer_client_->CreateTraceWriter(target_buffer_), thread_will_flush);
+  } else {
     return nullptr;
   }
-
-  if (use_chrome_proto_) {
-    return new ChromeBundleThreadLocalEventSink(std::move(trace_writer),
-                                                session_id, disable_interning_,
-                                                thread_will_flush);
-  }
-  return new TrackEventThreadLocalEventSink(std::move(trace_writer), session_id,
-                                            disable_interning_);
 }
 
 // static
@@ -348,32 +577,6 @@
   auto* thread_local_event_sink =
       static_cast<ThreadLocalEventSink*>(ThreadLocalEventSinkSlot()->Get());
 
-  // Make sure the sink was reset since the last tracing session. Normally, it
-  // is reset on Flush after the session is disabled. However, it may not have
-  // been reset if the current thread doesn't support flushing. In that case, we
-  // need to check here that it writes to the right buffer.
-  //
-  // Because we want to avoid locking for each event, we access |session_id_|
-  // racily. It's OK if we don't see it change to the session immediately. In
-  // that case, the first few trace events may get lost, but we will eventually
-  // notice that we are writing to the wrong buffer once the change to
-  // |session_id_| has propagated, and reset the sink. Note we will still
-  // acquire the |lock_| to safely recreate the sink in
-  // CreateThreadLocalEventSink().
-  if (!thread_will_flush && thread_local_event_sink) {
-    uint32_t new_session_id =
-        GetInstance()->session_id_.load(std::memory_order_relaxed);
-    // Ignore the first session to avoid resetting the sink during startup
-    // tracing, where the sink is created with kInvalidSessionID. Resetting the
-    // sink during startup might cause data buffered in its potentially still
-    // unbound StartupTraceWriter to be lost.
-    if (new_session_id > kFirstSessionID &&
-        new_session_id != thread_local_event_sink->session_id()) {
-      delete thread_local_event_sink;
-      thread_local_event_sink = nullptr;
-    }
-  }
-
   if (!thread_local_event_sink) {
     thread_local_event_sink =
         GetInstance()->CreateThreadLocalEventSink(thread_will_flush);
@@ -411,23 +614,4 @@
   }
 }
 
-void TraceEventDataSource::ReturnTraceWriter(
-    std::unique_ptr<perfetto::StartupTraceWriter> trace_writer) {
-  base::AutoLock lock(lock_);
-  if (startup_writer_registry_) {
-    // If the writer is still unbound, the registry will keep it alive until it
-    // was bound and its buffered data was copied. This ensures that we don't
-    // lose data from threads that are shut down during startup.
-    startup_writer_registry_->ReturnUnboundTraceWriter(std::move(trace_writer));
-  } else {
-    // Delete the TraceWriter on the sequence that Perfetto runs on, needed
-    // as the ThreadLocalEventSink gets deleted on thread
-    // shutdown and we can't safely call TaskRunnerHandle::Get() at that point
-    // (which can happen as the TraceWriter destructor might make a Mojo call
-    // and trigger it).
-    ProducerClient::GetTaskRunner()->DeleteSoon(FROM_HERE,
-                                                std::move(trace_writer));
-  }
-}
-
 }  // namespace tracing
--- a/services/tracing/public/cpp/perfetto/trace_event_data_source.h	2019-05-01 01:22:57.000000000 +0300
+++ b/services/tracing/public/cpp/perfetto/trace_event_data_source.h	2019-05-17 18:53:38.016000000 +0300
@@ -5,29 +5,21 @@
 #ifndef SERVICES_TRACING_PUBLIC_CPP_PERFETTO_TRACE_EVENT_DATA_SOURCE_H_
 #define SERVICES_TRACING_PUBLIC_CPP_PERFETTO_TRACE_EVENT_DATA_SOURCE_H_
 
-#include <atomic>
 #include <memory>
 #include <string>
 #include <vector>
 
 #include "base/component_export.h"
 #include "base/macros.h"
-#include "base/metrics/histogram_base.h"
 #include "base/threading/thread_local.h"
-#include "base/time/time.h"
-#include "base/trace_event/trace_config.h"
 #include "services/tracing/public/cpp/perfetto/producer_client.h"
 
 namespace perfetto {
-class StartupTraceWriter;
-class StartupTraceWriterRegistry;
 class TraceWriter;
 }
 
 namespace tracing {
 
-class ThreadLocalEventSink;
-
 // This class is a data source that clients can use to provide
 // global metadata in dictionary form, by registering callbacks.
 class COMPONENT_EXPORT(TRACING_CPP) TraceEventMetadataSource
@@ -43,9 +35,8 @@
 
   // ProducerClient::DataSourceBase implementation, called by
   // ProducerClent.
-  void StartTracing(
-      ProducerClient* producer_client,
-      const perfetto::DataSourceConfig& data_source_config) override;
+  void StartTracing(ProducerClient* producer_client,
+                    const mojom::DataSourceConfig& data_source_config) override;
   void StopTracing(base::OnceClosure stop_complete_callback) override;
   void Flush(base::RepeatingClosure flush_complete_callback) override;
 
@@ -54,7 +45,9 @@
 
   std::vector<MetadataGeneratorFunction> generator_functions_;
   scoped_refptr<base::SequencedTaskRunner> origin_task_runner_;
-  std::unique_ptr<perfetto::TraceWriter> trace_writer_;
+  base::Lock lock_;
+  ProducerClient* producer_client_ = nullptr;
+  uint32_t target_buffer_ = 0;
 
   DISALLOW_COPY_AND_ASSIGN(TraceEventMetadataSource);
 };
@@ -66,50 +59,30 @@
 class COMPONENT_EXPORT(TRACING_CPP) TraceEventDataSource
     : public ProducerClient::DataSourceBase {
  public:
-  static TraceEventDataSource* GetInstance();
+  class ThreadLocalEventSink;
 
-  // Destroys and recreates the global instance for testing.
-  static void ResetForTesting();
+  static TraceEventDataSource* GetInstance();
 
   // Flushes and deletes the TraceWriter for the current thread, if any.
   static void FlushCurrentThread();
 
-  // Installs TraceLog overrides for tracing during Chrome startup. Trace data
-  // is locally buffered until connection to the perfetto service is
-  // established. Expects a later call to StartTracing() to bind to the perfetto
-  // service. Should only be called once.
-  void SetupStartupTracing();
-
   // The ProducerClient is responsible for calling StopTracing
   // which will clear the stored pointer to it, before it
   // gets destroyed. ProducerClient::CreateTraceWriter can be
   // called by the TraceEventDataSource on any thread.
-  void StartTracing(
-      ProducerClient* producer_client,
-      const perfetto::DataSourceConfig& data_source_config) override;
+  void StartTracing(ProducerClient* producer_client,
+                    const mojom::DataSourceConfig& data_source_config) override;
 
   // Called from the ProducerClient.
   void StopTracing(base::OnceClosure stop_complete_callback) override;
   void Flush(base::RepeatingClosure flush_complete_callback) override;
 
-  // Resets emitted incremental state on the current thread and causes
-  // incremental data (e.g. interning index entries and a ThreadDescriptor) to
-  // be emitted again.
-  void ResetIncrementalStateForTesting();
-
-  // Deletes TraceWriter safely on behalf of a ThreadLocalEventSink.
-  void ReturnTraceWriter(
-      std::unique_ptr<perfetto::StartupTraceWriter> trace_writer);
-
  private:
   friend class base::NoDestructor<TraceEventDataSource>;
 
   TraceEventDataSource();
   ~TraceEventDataSource() override;
 
-  void RegisterWithTraceLog();
-  void UnregisterFromTraceLog();
-
   ThreadLocalEventSink* CreateThreadLocalEventSink(bool thread_will_flush);
 
   // Callback from TraceLog, can be called from any thread.
@@ -120,33 +93,10 @@
                                const base::TimeTicks& now,
                                const base::ThreadTicks& thread_now);
 
-  // Extracts UMA histogram names that should be logged in traces and logs their
-  // starting values.
-  void ResetHistograms(const base::trace_event::TraceConfig& trace_config);
-  // Logs selected UMA histogram.
-  void LogHistograms();
-  // Logs a given histogram in traces.
-  void LogHistogram(base::HistogramBase* histogram);
-
-  bool use_chrome_proto_;
-  bool disable_interning_;
-  base::OnceClosure stop_complete_callback_;
-
-  // Incremented and accessed atomically but without memory order guarantees.
-  // This ID is incremented whenever a new tracing session is started.
-  static constexpr uint32_t kInvalidSessionID = 0;
-  static constexpr uint32_t kFirstSessionID = 1;
-  std::atomic<uint32_t> session_id_{kInvalidSessionID};
-
-  base::Lock lock_;  // Protects subsequent members.
+  base::Lock lock_;
   uint32_t target_buffer_ = 0;
   ProducerClient* producer_client_ = nullptr;
-  // We own the registry during startup, but transfer its ownership to the
-  // ProducerClient once the perfetto service is available. Only set if
-  // SetupStartupTracing() is called.
-  std::unique_ptr<perfetto::StartupTraceWriterRegistry>
-      startup_writer_registry_;
-  std::vector<std::string> histograms_;
+  base::OnceClosure stop_complete_callback_;
 
   DISALLOW_COPY_AND_ASSIGN(TraceEventDataSource);
 };
--- a/services/tracing/public/cpp/perfetto/trace_event_data_source_unittest.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/tracing/public/cpp/perfetto/trace_event_data_source_unittest.cc	2019-05-17 18:53:38.016000000 +0300
@@ -10,14 +10,12 @@
 
 #include "base/bind.h"
 #include "base/callback.h"
-#include "base/command_line.h"
 #include "base/debug/leak_annotations.h"
 #include "base/json/json_reader.h"
 #include "base/message_loop/message_loop.h"
 #include "base/run_loop.h"
 #include "base/test/scoped_task_environment.h"
 #include "base/trace_event/trace_event.h"
-#include "components/tracing/common/tracing_switches.h"
 #include "services/tracing/public/mojom/perfetto_service.mojom.h"
 #include "testing/gtest/include/gtest/gtest.h"
 #include "third_party/perfetto/include/perfetto/protozero/scattered_stream_null_delegate.h"
@@ -26,8 +24,6 @@
 #include "third_party/perfetto/protos/perfetto/trace/trace_packet.pb.h"
 #include "third_party/perfetto/protos/perfetto/trace/trace_packet.pbzero.h"
 
-using TrackEvent = perfetto::protos::TrackEvent;
-
 namespace tracing {
 
 namespace {
@@ -65,8 +61,6 @@
       } else if (proto->has_chrome_events() &&
                  proto->chrome_events().metadata().size() > 0) {
         metadata_packets_.push_back(std::move(proto));
-      } else {
-        new_protos_packets_.push_back(std::move(proto));
       }
     }
 
@@ -95,18 +89,6 @@
     return event_bundle.trace_events();
   }
 
-  size_t GetNewProtosPacketCount() {
-    FlushPacketIfPossible();
-    return new_protos_packets_.size();
-  }
-
-  const perfetto::protos::TracePacket* GetNewProtosPacket(
-      size_t packet_index = 0) {
-    FlushPacketIfPossible();
-    EXPECT_GT(new_protos_packets_.size(), packet_index);
-    return new_protos_packets_[packet_index].get();
-  }
-
   const google::protobuf::RepeatedPtrField<perfetto::protos::ChromeMetadata>
   GetChromeMetadata(size_t packet_index = 0) {
     FlushPacketIfPossible();
@@ -137,8 +119,6 @@
   std::map<int, std::string> string_table_;
   std::vector<std::unique_ptr<perfetto::protos::TracePacket>>
       finalized_packets_;
-  std::vector<std::unique_ptr<perfetto::protos::TracePacket>>
-      new_protos_packets_;
   std::vector<std::unique_ptr<perfetto::protos::TracePacket>> metadata_packets_;
   perfetto::protos::pbzero::TracePacket trace_packet_;
   protozero::ScatteredStreamWriterNullDelegate delegate_;
@@ -166,7 +146,9 @@
     return perfetto::WriterID(0);
   }
 
-  uint64_t written() const override { return 0u; }
+  uint64_t written() const override {
+    return 0u;
+  }
 
  private:
   perfetto::protos::pbzero::TracePacket trace_packet_;
@@ -190,7 +172,9 @@
     return perfetto::WriterID(0);
   }
 
-  uint64_t written() const override { return 0u; }
+  uint64_t written() const override {
+    return 0u;
+  }
 
  private:
   MockProducerClient* producer_client_;
@@ -212,7 +196,9 @@
 
 class TraceEventDataSourceTest : public testing::Test {
  public:
-  void SetUp() override { ProducerClient::ResetTaskRunnerForTesting(); }
+  void SetUp() override {
+    ProducerClient::ResetTaskRunnerForTesting();
+  }
 
   void TearDown() override {
     if (base::trace_event::TraceLog::GetInstance()->IsEnabled()) {
@@ -238,9 +224,9 @@
     producer_client_ = std::make_unique<MockProducerClient>(
         scoped_task_environment_.GetMainThreadTaskRunner());
 
-    TraceEventDataSource::ResetForTesting();
-    TraceEventDataSource::GetInstance()->StartTracing(
-        producer_client(), perfetto::DataSourceConfig());
+    auto data_source_config = mojom::DataSourceConfig::New();
+    TraceEventDataSource::GetInstance()->StartTracing(producer_client(),
+                                                      *data_source_config);
   }
 
   MockProducerClient* producer_client() { return producer_client_.get(); }
@@ -273,7 +259,7 @@
   EXPECT_TRUE(entry.has_json_value());
 
   std::unique_ptr<base::Value> child_dict =
-      base::JSONReader::ReadDeprecated(entry.json_value());
+      base::JSONReader::Read(entry.json_value());
   EXPECT_EQ(*child_dict, value);
 }
 
@@ -309,8 +295,8 @@
 
   CreateTraceEventDataSource();
 
-  metadata_source->StartTracing(producer_client(),
-                                perfetto::DataSourceConfig());
+  auto data_source_config = mojom::DataSourceConfig::New();
+  metadata_source->StartTracing(producer_client(), *data_source_config);
 
   base::RunLoop wait_for_stop;
   metadata_source->StopTracing(wait_for_stop.QuitClosure());
@@ -618,615 +604,6 @@
   EXPECT_EQ(new_events.size(), 1);
 }
 
-class TraceEventDataSourceNewProtosTest : public TraceEventDataSourceTest {
- public:
-  void SetUp() override {
-    TraceEventDataSourceTest::SetUp();
-    base::CommandLine::ForCurrentProcess()->AppendSwitch(
-        switches::kPerfettoUseNewProtos);
-
-    CreateTraceEventDataSource();
-  }
-
-  void ExpectThreadDescriptor(const perfetto::protos::TracePacket* packet,
-                              int64_t min_timestamp = 1u,
-                              int64_t min_thread_time = 1u) {
-    EXPECT_TRUE(packet->has_thread_descriptor());
-    EXPECT_NE(packet->thread_descriptor().pid(), 0);
-    EXPECT_NE(packet->thread_descriptor().tid(), 0);
-    EXPECT_GE(packet->thread_descriptor().reference_timestamp_us(),
-              last_timestamp_);
-    EXPECT_GE(packet->thread_descriptor().reference_thread_time_us(),
-              last_thread_time_);
-    EXPECT_LE(packet->thread_descriptor().reference_timestamp_us(),
-              TRACE_TIME_TICKS_NOW().since_origin().InMicroseconds());
-    if (base::ThreadTicks::IsSupported()) {
-      EXPECT_LE(packet->thread_descriptor().reference_thread_time_us(),
-                base::ThreadTicks::Now().since_origin().InMicroseconds());
-    }
-
-    last_timestamp_ = packet->thread_descriptor().reference_timestamp_us();
-    last_thread_time_ = packet->thread_descriptor().reference_thread_time_us();
-
-    EXPECT_EQ(packet->interned_data().event_categories_size(), 0);
-    EXPECT_EQ(packet->interned_data().legacy_event_names_size(), 0);
-
-    // ThreadDescriptor is only emitted when incremental state was reset, and
-    // thus also always serves as indicator for the state reset to the consumer.
-    EXPECT_TRUE(packet->incremental_state_cleared());
-  }
-
-  void ExpectTraceEvent(const perfetto::protos::TracePacket* packet,
-                        uint32_t category_iid,
-                        uint32_t name_iid,
-                        char phase,
-                        uint32_t flags = 0,
-                        uint64_t id = 0,
-                        int64_t absolute_timestamp = 0,
-                        int32_t tid_override = 0,
-                        int32_t pid_override = 0,
-                        int64_t duration = 0) {
-    EXPECT_TRUE(packet->has_track_event());
-
-    if (absolute_timestamp > 0) {
-      EXPECT_TRUE(packet->track_event().has_timestamp_absolute_us());
-      EXPECT_EQ(packet->track_event().timestamp_absolute_us(),
-                absolute_timestamp);
-    } else {
-      EXPECT_TRUE(packet->track_event().has_timestamp_delta_us());
-      EXPECT_GE(packet->track_event().timestamp_delta_us(), 0);
-      EXPECT_LE(last_timestamp_ + packet->track_event().timestamp_delta_us(),
-                TRACE_TIME_TICKS_NOW().since_origin().InMicroseconds());
-      last_timestamp_ += packet->track_event().timestamp_delta_us();
-    }
-    if (packet->track_event().has_thread_time_delta_us()) {
-      EXPECT_LE(
-          last_thread_time_ + packet->track_event().thread_time_delta_us(),
-          TRACE_TIME_TICKS_NOW().since_origin().InMicroseconds());
-      last_thread_time_ += packet->track_event().thread_time_delta_us();
-    }
-
-    EXPECT_EQ(packet->track_event().category_iids_size(), 1);
-    EXPECT_EQ(packet->track_event().category_iids(0), category_iid);
-    EXPECT_TRUE(packet->track_event().has_legacy_event());
-
-    const auto& legacy_event = packet->track_event().legacy_event();
-    EXPECT_EQ(legacy_event.name_iid(), name_iid);
-    EXPECT_EQ(legacy_event.phase(), phase);
-    EXPECT_EQ(legacy_event.duration_us(), duration);
-
-    if (phase == TRACE_EVENT_PHASE_INSTANT) {
-      switch (flags & TRACE_EVENT_FLAG_SCOPE_MASK) {
-        case TRACE_EVENT_SCOPE_GLOBAL:
-          EXPECT_EQ(legacy_event.instant_event_scope(),
-                    TrackEvent::LegacyEvent::SCOPE_GLOBAL);
-          break;
-
-        case TRACE_EVENT_SCOPE_PROCESS:
-          EXPECT_EQ(legacy_event.instant_event_scope(),
-                    TrackEvent::LegacyEvent::SCOPE_PROCESS);
-          break;
-
-        case TRACE_EVENT_SCOPE_THREAD:
-          EXPECT_EQ(legacy_event.instant_event_scope(),
-                    TrackEvent::LegacyEvent::SCOPE_THREAD);
-          break;
-      }
-    } else {
-      EXPECT_EQ(legacy_event.instant_event_scope(),
-                TrackEvent::LegacyEvent::SCOPE_UNSPECIFIED);
-    }
-
-    switch (flags & (TRACE_EVENT_FLAG_HAS_ID | TRACE_EVENT_FLAG_HAS_LOCAL_ID |
-                     TRACE_EVENT_FLAG_HAS_GLOBAL_ID)) {
-      case TRACE_EVENT_FLAG_HAS_ID:
-        EXPECT_EQ(legacy_event.unscoped_id(), id);
-        EXPECT_EQ(legacy_event.local_id(), 0u);
-        EXPECT_EQ(legacy_event.global_id(), 0u);
-        break;
-      case TRACE_EVENT_FLAG_HAS_LOCAL_ID:
-        EXPECT_EQ(legacy_event.unscoped_id(), 0u);
-        EXPECT_EQ(legacy_event.local_id(), id);
-        EXPECT_EQ(legacy_event.global_id(), 0u);
-        break;
-      case TRACE_EVENT_FLAG_HAS_GLOBAL_ID:
-        EXPECT_EQ(legacy_event.unscoped_id(), 0u);
-        EXPECT_EQ(legacy_event.local_id(), 0u);
-        EXPECT_EQ(legacy_event.global_id(), id);
-        break;
-      default:
-        EXPECT_EQ(legacy_event.unscoped_id(), 0u);
-        EXPECT_EQ(legacy_event.local_id(), 0u);
-        EXPECT_EQ(legacy_event.global_id(), 0u);
-        break;
-    }
-
-    EXPECT_EQ(legacy_event.use_async_tts(), flags & TRACE_EVENT_FLAG_ASYNC_TTS);
-
-    switch (flags & (TRACE_EVENT_FLAG_FLOW_OUT | TRACE_EVENT_FLAG_FLOW_IN)) {
-      case TRACE_EVENT_FLAG_FLOW_OUT | TRACE_EVENT_FLAG_FLOW_IN:
-        EXPECT_EQ(legacy_event.flow_direction(),
-                  TrackEvent::LegacyEvent::FLOW_INOUT);
-        break;
-      case TRACE_EVENT_FLAG_FLOW_OUT:
-        EXPECT_EQ(legacy_event.flow_direction(),
-                  TrackEvent::LegacyEvent::FLOW_OUT);
-        break;
-      case TRACE_EVENT_FLAG_FLOW_IN:
-        EXPECT_EQ(legacy_event.flow_direction(),
-                  TrackEvent::LegacyEvent::FLOW_IN);
-        break;
-      default:
-        EXPECT_EQ(legacy_event.flow_direction(),
-                  TrackEvent::LegacyEvent::FLOW_UNSPECIFIED);
-        break;
-    }
-
-    EXPECT_EQ(legacy_event.bind_to_enclosing(),
-              flags & TRACE_EVENT_FLAG_BIND_TO_ENCLOSING);
-
-    EXPECT_EQ(legacy_event.tid_override(), tid_override);
-    EXPECT_EQ(legacy_event.pid_override(), pid_override);
-  }
-
-  void ExpectEventCategories(
-      const perfetto::protos::TracePacket* packet,
-      std::initializer_list<std::pair<uint32_t, std::string>> entries) {
-    ExpectInternedNames(packet->interned_data().event_categories(), entries);
-  }
-
-  void ExpectEventNames(
-      const perfetto::protos::TracePacket* packet,
-      std::initializer_list<std::pair<uint32_t, std::string>> entries) {
-    ExpectInternedNames(packet->interned_data().legacy_event_names(), entries);
-  }
-
-  void ExpectDebugAnnotationNames(
-      const perfetto::protos::TracePacket* packet,
-      std::initializer_list<std::pair<uint32_t, std::string>> entries) {
-    ExpectInternedNames(packet->interned_data().debug_annotation_names(),
-                        entries);
-  }
-
-  template <typename T>
-  void ExpectInternedNames(
-      const google::protobuf::RepeatedPtrField<T>& field,
-      std::initializer_list<std::pair<uint32_t, std::string>> entries) {
-    EXPECT_EQ(field.size(), static_cast<int>(entries.size()));
-    int i = 0;
-    for (const auto& entry : entries) {
-      EXPECT_EQ(field[i].iid(), entry.first);
-      EXPECT_EQ(field[i].name(), entry.second);
-      i++;
-    }
-  }
-
- protected:
-  int64_t last_timestamp_ = 0;
-  int64_t last_thread_time_ = 0;
-};
-
-TEST_F(TraceEventDataSourceNewProtosTest, BasicTraceEvent) {
-  TRACE_EVENT_BEGIN0(kCategoryGroup, "bar");
-
-  EXPECT_EQ(producer_client()->GetNewProtosPacketCount(), 2u);
-
-  auto* td_packet = producer_client()->GetNewProtosPacket();
-  ExpectThreadDescriptor(td_packet);
-
-  auto* e_packet = producer_client()->GetNewProtosPacket(1);
-  ExpectTraceEvent(e_packet, /*category_iid=*/1u, /*name_iid=*/1u,
-                   TRACE_EVENT_PHASE_BEGIN);
-
-  ExpectEventCategories(e_packet, {{1u, kCategoryGroup}});
-  ExpectEventNames(e_packet, {{1u, "bar"}});
-}
-
-TEST_F(TraceEventDataSourceNewProtosTest, TraceLogMetadataEvents) {
-  base::RunLoop wait_for_flush;
-  TraceEventDataSource::GetInstance()->StopTracing(
-      wait_for_flush.QuitClosure());
-  wait_for_flush.Run();
-
-  bool has_process_uptime_event = false;
-  for (size_t i = 0; i < producer_client()->GetNewProtosPacketCount(); ++i) {
-    auto* packet = producer_client()->GetNewProtosPacket(i);
-    for (auto& event_name : packet->interned_data().legacy_event_names()) {
-      if (event_name.name() == "process_uptime_seconds") {
-        has_process_uptime_event = true;
-        break;
-      }
-    }
-  }
-
-  EXPECT_TRUE(has_process_uptime_event);
-}
-
-TEST_F(TraceEventDataSourceNewProtosTest, TimestampedTraceEvent) {
-  TRACE_EVENT_BEGIN_WITH_ID_TID_AND_TIMESTAMP0(
-      kCategoryGroup, "bar", 42, 4242,
-      base::TimeTicks() + base::TimeDelta::FromMicroseconds(424242));
-
-  EXPECT_EQ(producer_client()->GetNewProtosPacketCount(), 2u);
-
-  auto* td_packet = producer_client()->GetNewProtosPacket();
-  ExpectThreadDescriptor(td_packet);
-
-  auto* e_packet = producer_client()->GetNewProtosPacket(1);
-  ExpectTraceEvent(
-      e_packet, /*category_iid=*/1u, /*name_iid=*/1u,
-      TRACE_EVENT_PHASE_ASYNC_BEGIN,
-      TRACE_EVENT_FLAG_EXPLICIT_TIMESTAMP | TRACE_EVENT_FLAG_HAS_ID, /*id=*/42u,
-      /*absolute_timestamp=*/424242, /*tid_override=*/4242);
-
-  ExpectEventCategories(e_packet, {{1u, kCategoryGroup}});
-  ExpectEventNames(e_packet, {{1u, "bar"}});
-}
-
-TEST_F(TraceEventDataSourceNewProtosTest, InstantTraceEvent) {
-  TRACE_EVENT_INSTANT0(kCategoryGroup, "bar", TRACE_EVENT_SCOPE_THREAD);
-
-  EXPECT_EQ(producer_client()->GetNewProtosPacketCount(), 2u);
-
-  auto* td_packet = producer_client()->GetNewProtosPacket();
-  ExpectThreadDescriptor(td_packet);
-
-  auto* e_packet = producer_client()->GetNewProtosPacket(1);
-  ExpectTraceEvent(e_packet, /*category_iid=*/1u, /*name_iid=*/1u,
-                   TRACE_EVENT_PHASE_INSTANT, TRACE_EVENT_SCOPE_THREAD);
-
-  ExpectEventCategories(e_packet, {{1u, kCategoryGroup}});
-  ExpectEventNames(e_packet, {{1u, "bar"}});
-}
-
-TEST_F(TraceEventDataSourceNewProtosTest, EventWithStringArgs) {
-  TRACE_EVENT_INSTANT2(kCategoryGroup, "bar", TRACE_EVENT_SCOPE_THREAD,
-                       "arg1_name", "arg1_val", "arg2_name", "arg2_val");
-
-  EXPECT_EQ(producer_client()->GetNewProtosPacketCount(), 2u);
-
-  auto* td_packet = producer_client()->GetNewProtosPacket();
-  ExpectThreadDescriptor(td_packet);
-
-  auto* e_packet = producer_client()->GetNewProtosPacket(1);
-  ExpectTraceEvent(e_packet, /*category_iid=*/1u, /*name_iid=*/1u,
-                   TRACE_EVENT_PHASE_INSTANT, TRACE_EVENT_SCOPE_THREAD);
-
-  const auto& annotations = e_packet->track_event().debug_annotations();
-  EXPECT_EQ(annotations.size(), 2);
-  EXPECT_EQ(annotations[0].name_iid(), 1u);
-  EXPECT_EQ(annotations[0].string_value(), "arg1_val");
-  EXPECT_EQ(annotations[1].name_iid(), 2u);
-  EXPECT_EQ(annotations[1].string_value(), "arg2_val");
-
-  ExpectEventCategories(e_packet, {{1u, kCategoryGroup}});
-  ExpectEventNames(e_packet, {{1u, "bar"}});
-  ExpectDebugAnnotationNames(e_packet, {{1u, "arg1_name"}, {2u, "arg2_name"}});
-}
-
-TEST_F(TraceEventDataSourceNewProtosTest, EventWithCopiedStrings) {
-  TRACE_EVENT_INSTANT2(kCategoryGroup, "bar",
-                       TRACE_EVENT_SCOPE_THREAD | TRACE_EVENT_FLAG_COPY,
-                       "arg1_name", "arg1_val", "arg2_name", "arg2_val");
-
-  EXPECT_EQ(producer_client()->GetNewProtosPacketCount(), 2u);
-
-  auto* td_packet = producer_client()->GetNewProtosPacket();
-  ExpectThreadDescriptor(td_packet);
-
-  auto* e_packet = producer_client()->GetNewProtosPacket(1);
-  ExpectTraceEvent(e_packet, /*category_iid=*/1u, /*name_iid=*/1u,
-                   TRACE_EVENT_PHASE_INSTANT,
-                   TRACE_EVENT_SCOPE_THREAD | TRACE_EVENT_FLAG_COPY);
-
-  const auto& annotations = e_packet->track_event().debug_annotations();
-  EXPECT_EQ(annotations.size(), 2);
-  EXPECT_EQ(annotations[0].name_iid(), 1u);
-  EXPECT_EQ(annotations[0].string_value(), "arg1_val");
-  EXPECT_EQ(annotations[1].name_iid(), 2u);
-  EXPECT_EQ(annotations[1].string_value(), "arg2_val");
-
-  ExpectEventCategories(e_packet, {{1u, kCategoryGroup}});
-  ExpectEventNames(e_packet, {{1u, "bar"}});
-  ExpectDebugAnnotationNames(e_packet, {{1u, "arg1_name"}, {2u, "arg2_name"}});
-}
-
-TEST_F(TraceEventDataSourceNewProtosTest, EventWithUIntArgs) {
-  TRACE_EVENT_INSTANT2(kCategoryGroup, "bar", TRACE_EVENT_SCOPE_THREAD, "foo",
-                       42u, "bar", 4242u);
-
-  EXPECT_EQ(producer_client()->GetNewProtosPacketCount(), 2u);
-  auto* e_packet = producer_client()->GetNewProtosPacket(1);
-  ExpectTraceEvent(e_packet, /*category_iid=*/1u, /*name_iid=*/1u,
-                   TRACE_EVENT_PHASE_INSTANT, TRACE_EVENT_SCOPE_THREAD);
-
-  const auto& annotations = e_packet->track_event().debug_annotations();
-  EXPECT_EQ(annotations.size(), 2);
-  EXPECT_EQ(annotations[0].uint_value(), 42u);
-  EXPECT_EQ(annotations[1].uint_value(), 4242u);
-}
-
-TEST_F(TraceEventDataSourceNewProtosTest, EventWithIntArgs) {
-  TRACE_EVENT_INSTANT2(kCategoryGroup, "bar", TRACE_EVENT_SCOPE_THREAD, "foo",
-                       42, "bar", 4242);
-
-  EXPECT_EQ(producer_client()->GetNewProtosPacketCount(), 2u);
-  auto* e_packet = producer_client()->GetNewProtosPacket(1);
-  ExpectTraceEvent(e_packet, /*category_iid=*/1u, /*name_iid=*/1u,
-                   TRACE_EVENT_PHASE_INSTANT, TRACE_EVENT_SCOPE_THREAD);
-
-  const auto& annotations = e_packet->track_event().debug_annotations();
-  EXPECT_EQ(annotations.size(), 2);
-  EXPECT_EQ(annotations[0].int_value(), 42);
-  EXPECT_EQ(annotations[1].int_value(), 4242);
-}
-
-TEST_F(TraceEventDataSourceNewProtosTest, EventWithBoolArgs) {
-  TRACE_EVENT_INSTANT2(kCategoryGroup, "bar", TRACE_EVENT_SCOPE_THREAD, "foo",
-                       true, "bar", false);
-
-  EXPECT_EQ(producer_client()->GetNewProtosPacketCount(), 2u);
-  auto* e_packet = producer_client()->GetNewProtosPacket(1);
-  ExpectTraceEvent(e_packet, /*category_iid=*/1u, /*name_iid=*/1u,
-                   TRACE_EVENT_PHASE_INSTANT, TRACE_EVENT_SCOPE_THREAD);
-
-  const auto& annotations = e_packet->track_event().debug_annotations();
-  EXPECT_EQ(annotations.size(), 2);
-  EXPECT_TRUE(annotations[0].has_bool_value());
-  EXPECT_EQ(annotations[0].bool_value(), true);
-  EXPECT_TRUE(annotations[1].has_bool_value());
-  EXPECT_EQ(annotations[1].int_value(), false);
-}
-
-TEST_F(TraceEventDataSourceNewProtosTest, EventWithDoubleArgs) {
-  TRACE_EVENT_INSTANT2(kCategoryGroup, "bar", TRACE_EVENT_SCOPE_THREAD, "foo",
-                       42.42, "bar", 4242.42);
-
-  EXPECT_EQ(producer_client()->GetNewProtosPacketCount(), 2u);
-  auto* e_packet = producer_client()->GetNewProtosPacket(1);
-  ExpectTraceEvent(e_packet, /*category_iid=*/1u, /*name_iid=*/1u,
-                   TRACE_EVENT_PHASE_INSTANT, TRACE_EVENT_SCOPE_THREAD);
-
-  const auto& annotations = e_packet->track_event().debug_annotations();
-  EXPECT_EQ(annotations.size(), 2);
-  EXPECT_EQ(annotations[0].double_value(), 42.42);
-  EXPECT_EQ(annotations[1].double_value(), 4242.42);
-}
-
-TEST_F(TraceEventDataSourceNewProtosTest, EventWithPointerArgs) {
-  TRACE_EVENT_INSTANT2(kCategoryGroup, "bar", TRACE_EVENT_SCOPE_THREAD, "foo",
-                       reinterpret_cast<void*>(0xBEEF), "bar",
-                       reinterpret_cast<void*>(0xF00D));
-
-  EXPECT_EQ(producer_client()->GetNewProtosPacketCount(), 2u);
-  auto* e_packet = producer_client()->GetNewProtosPacket(1);
-  ExpectTraceEvent(e_packet, /*category_iid=*/1u, /*name_iid=*/1u,
-                   TRACE_EVENT_PHASE_INSTANT, TRACE_EVENT_SCOPE_THREAD);
-
-  const auto& annotations = e_packet->track_event().debug_annotations();
-  EXPECT_EQ(annotations.size(), 2);
-  EXPECT_EQ(annotations[0].pointer_value(), static_cast<uintptr_t>(0xBEEF));
-  EXPECT_EQ(annotations[1].pointer_value(), static_cast<uintptr_t>(0xF00D));
-}
-
-TEST_F(TraceEventDataSourceNewProtosTest, EventWithConvertableArgs) {
-  static const char kArgValue1[] = "\"conv_value1\"";
-  static const char kArgValue2[] = "\"conv_value2\"";
-
-  int num_calls = 0;
-
-  class Convertable : public base::trace_event::ConvertableToTraceFormat {
-   public:
-    explicit Convertable(int* num_calls, const char* arg_value)
-        : num_calls_(num_calls), arg_value_(arg_value) {}
-    ~Convertable() override = default;
-
-    void AppendAsTraceFormat(std::string* out) const override {
-      (*num_calls_)++;
-      out->append(arg_value_);
-    }
-
-   private:
-    int* num_calls_;
-    const char* arg_value_;
-  };
-
-  std::unique_ptr<Convertable> conv1(new Convertable(&num_calls, kArgValue1));
-  std::unique_ptr<Convertable> conv2(new Convertable(&num_calls, kArgValue2));
-
-  TRACE_EVENT_INSTANT2(kCategoryGroup, "bar", TRACE_EVENT_SCOPE_THREAD,
-                       "foo_arg1", std::move(conv1), "foo_arg2",
-                       std::move(conv2));
-
-  EXPECT_EQ(2, num_calls);
-
-  EXPECT_EQ(producer_client()->GetNewProtosPacketCount(), 2u);
-  auto* e_packet = producer_client()->GetNewProtosPacket(1);
-  ExpectTraceEvent(e_packet, /*category_iid=*/1u, /*name_iid=*/1u,
-                   TRACE_EVENT_PHASE_INSTANT, TRACE_EVENT_SCOPE_THREAD);
-
-  const auto& annotations = e_packet->track_event().debug_annotations();
-  EXPECT_EQ(annotations.size(), 2);
-  EXPECT_EQ(annotations[0].legacy_json_value(), kArgValue1);
-  EXPECT_EQ(annotations[1].legacy_json_value(), kArgValue2);
-}
-
-TEST_F(TraceEventDataSourceNewProtosTest, UpdateDurationOfCompleteEvent) {
-  static const char kEventName[] = "bar";
-
-  auto* category_group_enabled =
-      TRACE_EVENT_API_GET_CATEGORY_GROUP_ENABLED(kCategoryGroup);
-
-  trace_event_internal::TraceID trace_event_trace_id =
-      trace_event_internal::kNoId;
-
-  auto handle = trace_event_internal::AddTraceEventWithThreadIdAndTimestamp(
-      TRACE_EVENT_PHASE_COMPLETE, category_group_enabled, kEventName,
-      trace_event_trace_id.scope(), trace_event_trace_id.raw_id(),
-      1 /* thread_id */,
-      base::TimeTicks() + base::TimeDelta::FromMicroseconds(10),
-      trace_event_trace_id.id_flags() | TRACE_EVENT_FLAG_EXPLICIT_TIMESTAMP,
-      trace_event_internal::kNoId);
-
-  base::trace_event::TraceLog::GetInstance()->UpdateTraceEventDurationExplicit(
-      category_group_enabled, kEventName, handle,
-      base::TimeTicks() + base::TimeDelta::FromMicroseconds(30),
-      base::ThreadTicks() + base::TimeDelta::FromMicroseconds(50));
-
-  // The call to UpdateTraceEventDurationExplicit should have successfully
-  // updated the duration of the event which was added in the
-  // AddTraceEventWithThreadIdAndTimestamp call.
-  EXPECT_EQ(producer_client()->GetNewProtosPacketCount(), 2u);
-  auto* e_packet = producer_client()->GetNewProtosPacket(1);
-  ExpectTraceEvent(
-      e_packet, /*category_iid=*/1u, /*name_iid=*/1u,
-      TRACE_EVENT_PHASE_COMPLETE,
-      TRACE_EVENT_FLAG_EXPLICIT_TIMESTAMP | TRACE_EVENT_FLAG_HAS_ID, /*id=*/0u,
-      /*absolute_timestamp=*/10, /*tid_override=*/1, /*pid_override=*/0,
-      /*duration=*/20);
-
-  // Updating the duration of an invalid event should cause no further events to
-  // be emitted.
-  handle.event_index = 0;
-
-  base::trace_event::TraceLog::GetInstance()->UpdateTraceEventDurationExplicit(
-      category_group_enabled, kEventName, handle,
-      base::TimeTicks() + base::TimeDelta::FromMicroseconds(30),
-      base::ThreadTicks() + base::TimeDelta::FromMicroseconds(50));
-
-  // No further packets should have been emitted.
-  EXPECT_EQ(producer_client()->GetNewProtosPacketCount(), 2u);
-}
-
-// TODO(eseckler): Add a test with multiple events + same strings (cat, name,
-// arg names).
-
-// TODO(eseckler): Add a test with multiple events + same strings with reset.
-
-TEST_F(TraceEventDataSourceNewProtosTest, InternedStrings) {
-  for (size_t i = 0; i < 2; i++) {
-    TRACE_EVENT_INSTANT1("cat1", "e1", TRACE_EVENT_SCOPE_THREAD, "arg1", 4);
-    TRACE_EVENT_INSTANT1("cat1", "e1", TRACE_EVENT_SCOPE_THREAD, "arg1", 2);
-    TRACE_EVENT_INSTANT1("cat2", "e2", TRACE_EVENT_SCOPE_THREAD, "arg2", 1);
-
-    EXPECT_EQ(producer_client()->GetNewProtosPacketCount(), 4u * (i + 1));
-
-    auto* td_packet = producer_client()->GetNewProtosPacket(4 * i);
-    ExpectThreadDescriptor(td_packet);
-
-    // First packet needs to emit new interning entries
-    auto* e_packet1 = producer_client()->GetNewProtosPacket(1 + (4 * i));
-    ExpectTraceEvent(e_packet1, /*category_iid=*/1u, /*name_iid=*/1u,
-                     TRACE_EVENT_PHASE_INSTANT, TRACE_EVENT_SCOPE_THREAD);
-
-    const auto& annotations1 = e_packet1->track_event().debug_annotations();
-    EXPECT_EQ(annotations1.size(), 1);
-    EXPECT_EQ(annotations1[0].name_iid(), 1u);
-    EXPECT_EQ(annotations1[0].int_value(), 4);
-
-    ExpectEventCategories(e_packet1, {{1u, "cat1"}});
-    ExpectEventNames(e_packet1, {{1u, "e1"}});
-    ExpectDebugAnnotationNames(e_packet1, {{1u, "arg1"}});
-
-    // Second packet refers to the interning entries from packet 1.
-    auto* e_packet2 = producer_client()->GetNewProtosPacket(2 + (4 * i));
-    ExpectTraceEvent(e_packet2, /*category_iid=*/1u, /*name_iid=*/1u,
-                     TRACE_EVENT_PHASE_INSTANT, TRACE_EVENT_SCOPE_THREAD);
-
-    const auto& annotations2 = e_packet2->track_event().debug_annotations();
-    EXPECT_EQ(annotations2.size(), 1);
-    EXPECT_EQ(annotations2[0].name_iid(), 1u);
-    EXPECT_EQ(annotations2[0].int_value(), 2);
-
-    ExpectEventCategories(e_packet2, {});
-    ExpectEventNames(e_packet2, {});
-    ExpectDebugAnnotationNames(e_packet2, {});
-
-    // Third packet uses different names, so emits new entries.
-    auto* e_packet3 = producer_client()->GetNewProtosPacket(3 + (4 * i));
-    ExpectTraceEvent(e_packet3, /*category_iid=*/2u, /*name_iid=*/2u,
-                     TRACE_EVENT_PHASE_INSTANT, TRACE_EVENT_SCOPE_THREAD);
-
-    const auto& annotations3 = e_packet3->track_event().debug_annotations();
-    EXPECT_EQ(annotations3.size(), 1);
-    EXPECT_EQ(annotations3[0].name_iid(), 2u);
-    EXPECT_EQ(annotations3[0].int_value(), 1);
-
-    ExpectEventCategories(e_packet3, {{2u, "cat2"}});
-    ExpectEventNames(e_packet3, {{2u, "e2"}});
-    ExpectDebugAnnotationNames(e_packet3, {{2u, "arg2"}});
-
-    // Resetting the interning state causes ThreadDescriptor and interning
-    // entries to be emitted again, with the same interning IDs.
-    TraceEventDataSource::GetInstance()->ResetIncrementalStateForTesting();
-  }
-}
-
-class TraceEventDataSourceNewProtosNoInterningTest
-    : public TraceEventDataSourceNewProtosTest {
- public:
-  void SetUp() override {
-    base::CommandLine::ForCurrentProcess()->AppendSwitch(
-        switches::kPerfettoDisableInterning);
-    TraceEventDataSourceNewProtosTest::SetUp();
-  }
-};
-
-TEST_F(TraceEventDataSourceNewProtosNoInterningTest, InterningScopedToPackets) {
-  TRACE_EVENT_INSTANT1("cat1", "e1", TRACE_EVENT_SCOPE_THREAD, "arg1", 4);
-  TRACE_EVENT_INSTANT1("cat1", "e1", TRACE_EVENT_SCOPE_THREAD, "arg1", 2);
-  TRACE_EVENT_INSTANT1("cat2", "e2", TRACE_EVENT_SCOPE_THREAD, "arg2", 1);
-
-  EXPECT_EQ(producer_client()->GetNewProtosPacketCount(), 4u);
-
-  auto* td_packet = producer_client()->GetNewProtosPacket(0);
-  ExpectThreadDescriptor(td_packet);
-
-  // First packet needs to emit new interning entries
-  auto* e_packet1 = producer_client()->GetNewProtosPacket(1);
-  ExpectTraceEvent(e_packet1, /*category_iid=*/1u, /*name_iid=*/1u,
-                   TRACE_EVENT_PHASE_INSTANT, TRACE_EVENT_SCOPE_THREAD);
-
-  const auto& annotations1 = e_packet1->track_event().debug_annotations();
-  EXPECT_EQ(annotations1.size(), 1);
-  EXPECT_EQ(annotations1[0].name_iid(), 1u);
-  EXPECT_EQ(annotations1[0].int_value(), 4);
-
-  ExpectEventCategories(e_packet1, {{1u, "cat1"}});
-  ExpectEventNames(e_packet1, {{1u, "e1"}});
-  ExpectDebugAnnotationNames(e_packet1, {{1u, "arg1"}});
-
-  // Second packet reemits the entries the same way.
-  auto* e_packet2 = producer_client()->GetNewProtosPacket(2);
-  ExpectTraceEvent(e_packet2, /*category_iid=*/1u, /*name_iid=*/1u,
-                   TRACE_EVENT_PHASE_INSTANT, TRACE_EVENT_SCOPE_THREAD);
-
-  const auto& annotations2 = e_packet2->track_event().debug_annotations();
-  EXPECT_EQ(annotations2.size(), 1);
-  EXPECT_EQ(annotations2[0].name_iid(), 1u);
-  EXPECT_EQ(annotations2[0].int_value(), 2);
-
-  ExpectEventCategories(e_packet1, {{1u, "cat1"}});
-  ExpectEventNames(e_packet1, {{1u, "e1"}});
-  ExpectDebugAnnotationNames(e_packet1, {{1u, "arg1"}});
-
-  // Third packet emits entries with the same IDs but different strings.
-  auto* e_packet3 = producer_client()->GetNewProtosPacket(3);
-  ExpectTraceEvent(e_packet3, /*category_iid=*/1u, /*name_iid=*/1u,
-                   TRACE_EVENT_PHASE_INSTANT, TRACE_EVENT_SCOPE_THREAD);
-
-  const auto& annotations3 = e_packet3->track_event().debug_annotations();
-  EXPECT_EQ(annotations3.size(), 1);
-  EXPECT_EQ(annotations3[0].name_iid(), 1u);
-  EXPECT_EQ(annotations3[0].int_value(), 1);
-
-  ExpectEventCategories(e_packet3, {{1u, "cat2"}});
-  ExpectEventNames(e_packet3, {{1u, "e2"}});
-  ExpectDebugAnnotationNames(e_packet3, {{1u, "arg2"}});
-}
-
-// TODO(eseckler): Add startup tracing unittests.
-
 }  // namespace
 
 }  // namespace tracing
--- a/services/tracing/public/cpp/traced_process.h	2019-05-01 01:22:57.000000000 +0300
+++ b/services/tracing/public/cpp/traced_process.h	2019-05-17 18:53:38.016000000 +0300
@@ -5,7 +5,7 @@
 #ifndef SERVICES_TRACING_PUBLIC_CPP_TRACED_PROCESS_H_
 #define SERVICES_TRACING_PUBLIC_CPP_TRACED_PROCESS_H_
 
-#include "services/tracing/public/mojom/traced_process.mojom.h"
+#include "services/tracing/public/mojom/tracing.mojom.h"
 
 namespace tracing {
 
--- a/services/tracing/public/cpp/traced_process_impl.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/tracing/public/cpp/traced_process_impl.cc	2019-05-17 18:53:38.016000000 +0300
@@ -6,7 +6,6 @@
 
 #include <utility>
 
-#include "base/bind.h"
 #include "base/no_destructor.h"
 #include "base/task/task_scheduler/task_scheduler.h"
 #include "services/tracing/public/cpp/base_agent.h"
@@ -106,10 +105,4 @@
       tracing::mojom::PerfettoServicePtr(std::move(request->perfetto_service)));
 }
 
-void TracedProcessImpl::GetCategories(std::set<std::string>* category_set) {
-  for (auto* agent : agents_) {
-    agent->GetCategories(category_set);
-  }
-}
-
 }  // namespace tracing
--- a/services/tracing/public/cpp/traced_process_impl.h	2019-05-01 01:22:57.000000000 +0300
+++ b/services/tracing/public/cpp/traced_process_impl.h	2019-05-17 18:53:38.016000000 +0300
@@ -12,7 +12,6 @@
 #include "base/sequence_checker.h"
 #include "base/synchronization/lock.h"
 #include "mojo/public/cpp/bindings/binding.h"
-#include "services/tracing/public/mojom/traced_process.mojom.h"
 #include "services/tracing/public/mojom/tracing.mojom.h"
 
 namespace tracing {
@@ -36,9 +35,6 @@
   void RegisterAgent(BaseAgent* agent);
   void UnregisterAgent(BaseAgent* agent);
 
-  // Populate categories from all of the registered agents.
-  void GetCategories(std::set<std::string>* category_set);
-
  private:
   friend class base::NoDestructor<TracedProcessImpl>;
   TracedProcessImpl();
--- a/services/tracing/public/cpp/trace_event_agent.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/tracing/public/cpp/trace_event_agent.cc	2019-05-17 18:53:38.016000000 +0300
@@ -20,7 +20,6 @@
 #include "build/build_config.h"
 #include "services/tracing/public/cpp/perfetto/producer_client.h"
 #include "services/tracing/public/cpp/perfetto/trace_event_data_source.h"
-#include "services/tracing/public/cpp/trace_event_args_whitelist.h"
 #include "services/tracing/public/cpp/tracing_features.h"
 
 namespace {
@@ -41,30 +40,13 @@
     : BaseAgent(kTraceEventLabel,
                 mojom::TraceDataType::ARRAY,
                 base::trace_event::TraceLog::GetInstance()->process_id()),
-      enabled_tracing_modes_(0),
-      weak_ptr_factory_(this) {
+      enabled_tracing_modes_(0) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
 
-  // These filters are used by TraceLog in the legacy tracing system and JSON
-  // exporter (only in tracing service) in perfetto bcakend.
-  if (base::trace_event::TraceLog::GetInstance()
-          ->GetArgumentFilterPredicate()
-          .is_null()) {
-    base::trace_event::TraceLog::GetInstance()->SetArgumentFilterPredicate(
-        base::BindRepeating(&IsTraceEventArgsWhitelisted));
-    base::trace_event::TraceLog::GetInstance()->SetMetadataFilterPredicate(
-        base::BindRepeating(&IsMetadataWhitelisted));
-  }
-
-  base::trace_event::TraceLog::GetInstance()->AddAsyncEnabledStateObserver(
-      weak_ptr_factory_.GetWeakPtr());
-
   ProducerClient::Get()->AddDataSource(TraceEventDataSource::GetInstance());
 }
 
-TraceEventAgent::~TraceEventAgent() {
-  DCHECK(!tracing_enabled_callback_);
-}
+TraceEventAgent::~TraceEventAgent() = default;
 
 void TraceEventAgent::GetCategories(std::set<std::string>* category_set) {
   for (size_t i = base::trace_event::BuiltinCategories::kVisibleCategoryStart;
@@ -90,11 +72,8 @@
 }
 
 void TraceEventAgent::StartTracing(const std::string& config,
-                                   base::TimeTicks coordinator_time,
-                                   StartTracingCallback callback) {
-  DCHECK(!IsBoundForTesting() || !TracingUsesPerfettoBackend());
+                                   base::TimeTicks coordinator_time) {
   DCHECK(!recorder_);
-  DCHECK(!tracing_enabled_callback_);
 #if defined(__native_client__)
   // NaCl and system times are offset by a bit, so subtract some time from
   // the captured timestamps. The value might be off by a bit due to messaging
@@ -108,11 +87,9 @@
     enabled_tracing_modes_ |= base::trace_event::TraceLog::FILTERING_MODE;
   base::trace_event::TraceLog::GetInstance()->SetEnabled(
       trace_config, enabled_tracing_modes_);
-  std::move(callback).Run(true);
 }
 
 void TraceEventAgent::StopAndFlush(mojom::RecorderPtr recorder) {
-  DCHECK(!IsBoundForTesting() || !TracingUsesPerfettoBackend());
   DCHECK(!recorder_);
 
   recorder_ = std::move(recorder);
@@ -131,36 +108,11 @@
 
 void TraceEventAgent::RequestBufferStatus(
     RequestBufferStatusCallback callback) {
-  DCHECK(!IsBoundForTesting() || !TracingUsesPerfettoBackend());
   base::trace_event::TraceLogStatus status =
       base::trace_event::TraceLog::GetInstance()->GetStatus();
   std::move(callback).Run(status.event_capacity, status.event_count);
 }
 
-void TraceEventAgent::WaitForTracingEnabled(
-    Agent::WaitForTracingEnabledCallback callback) {
-  DCHECK(TracingUsesPerfettoBackend());
-  DCHECK(!tracing_enabled_callback_);
-  if (base::trace_event::TraceLog::GetInstance()->IsEnabled()) {
-    std::move(callback).Run();
-    return;
-  }
-
-  tracing_enabled_callback_ = std::move(callback);
-}
-
-// This callback will always come on the same sequence
-// that TraceLog::AddAsyncEnabledStateObserver was called
-// on to begin with, i.e. the same as any WaitForTracingEnabled()
-// calls are run on.
-void TraceEventAgent::OnTraceLogEnabled() {
-  if (tracing_enabled_callback_) {
-    std::move(tracing_enabled_callback_).Run();
-  }
-}
-
-void TraceEventAgent::OnTraceLogDisabled() {}
-
 void TraceEventAgent::OnTraceLogFlush(
     const scoped_refptr<base::RefCountedString>& events_str,
     bool has_more_events) {
--- a/services/tracing/public/cpp/trace_event_agent.h	2019-05-01 01:22:57.000000000 +0300
+++ b/services/tracing/public/cpp/trace_event_agent.h	2019-05-17 18:53:38.016000000 +0300
@@ -13,9 +13,7 @@
 #include "base/component_export.h"
 #include "base/memory/ref_counted.h"
 #include "base/memory/ref_counted_memory.h"
-#include "base/memory/weak_ptr.h"
 #include "base/threading/thread_checker.h"
-#include "base/trace_event/trace_log.h"
 #include "base/values.h"
 #include "services/tracing/public/cpp/base_agent.h"
 #include "services/tracing/public/mojom/tracing.mojom.h"
@@ -31,9 +29,7 @@
 // most of the mojom::Agent functions will never be used
 // as the control signals will go through the Perfetto
 // interface instead.
-class COMPONENT_EXPORT(TRACING_CPP) TraceEventAgent
-    : public BaseAgent,
-      public base::trace_event::TraceLog::AsyncEnabledStateObserver {
+class COMPONENT_EXPORT(TRACING_CPP) TraceEventAgent : public BaseAgent {
  public:
   static TraceEventAgent* GetInstance();
 
@@ -53,28 +49,20 @@
 
   // mojom::Agent
   void StartTracing(const std::string& config,
-                    base::TimeTicks coordinator_time,
-                    StartTracingCallback callback) override;
+                    base::TimeTicks coordinator_time) override;
   void StopAndFlush(mojom::RecorderPtr recorder) override;
 
   void RequestBufferStatus(RequestBufferStatusCallback callback) override;
 
   void OnTraceLogFlush(const scoped_refptr<base::RefCountedString>& events_str,
                        bool has_more_events);
-  void WaitForTracingEnabled(
-      Agent::WaitForTracingEnabledCallback callback) override;
-
-  // base::trace_event::TraceLog::AsyncEnabledStateObserver
-  void OnTraceLogEnabled() override;
-  void OnTraceLogDisabled() override;
 
   uint8_t enabled_tracing_modes_;
   mojom::RecorderPtr recorder_;
   std::vector<MetadataGeneratorFunction> metadata_generator_functions_;
-  Agent::WaitForTracingEnabledCallback tracing_enabled_callback_;
 
   THREAD_CHECKER(thread_checker_);
-  base::WeakPtrFactory<TraceEventAgent> weak_ptr_factory_;
+
   DISALLOW_COPY_AND_ASSIGN(TraceEventAgent);
 };
 
--- a/services/tracing/public/cpp/trace_event_agent_unittest.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/tracing/public/cpp/trace_event_agent_unittest.cc	2019-05-17 18:53:38.016000000 +0300
@@ -17,7 +17,6 @@
 #include "base/trace_event/trace_event.h"
 #include "base/trace_event/trace_log.h"
 #include "base/values.h"
-#include "services/tracing/public/cpp/perfetto/producer_client.h"
 #include "services/tracing/public/mojom/tracing.mojom.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
@@ -83,8 +82,6 @@
 
 class TraceEventAgentTest : public testing::Test {
  public:
-  void SetUp() override { ProducerClient::ResetTaskRunnerForTesting(); }
-
   void TearDown() override {
     base::trace_event::TraceLog::GetInstance()->SetDisabled();
     recorder_.reset();
@@ -93,8 +90,7 @@
   void StartTracing(const std::string& categories) {
     TraceEventAgent::GetInstance()->StartTracing(
         base::trace_event::TraceConfig(categories, "").ToString(),
-        base::TimeTicks::Now(),
-        base::BindRepeating([](bool success) { EXPECT_TRUE(success); }));
+        base::TimeTicks::Now());
   }
 
   void StopAndFlush(base::Closure quit_closure) {
--- a/services/tracing/public/cpp/tracing_features.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/tracing/public/cpp/tracing_features.cc	2019-05-17 18:53:38.016000000 +0300
@@ -6,37 +6,19 @@
 
 #include <string>
 
-#include "base/command_line.h"
 #include "base/metrics/field_trial_params.h"
 #include "base/strings/string_number_conversions.h"
-#include "build/build_config.h"
-#include "components/tracing/common/tracing_switches.h"
 
 namespace features {
 
-// Enables the perfetto tracing backend. For startup tracing, pass the
-// --enable-perfetto flag instead.
 const base::Feature kTracingPerfettoBackend{"TracingPerfettoBackend",
                                             base::FEATURE_DISABLED_BY_DEFAULT};
-
-// Runs the tracing service as an in-process browser service.
-const base::Feature kTracingServiceInProcess {
-  "TracingServiceInProcess",
-#if defined(OS_ANDROID)
-      base::FEATURE_ENABLED_BY_DEFAULT
-#else
-      base::FEATURE_DISABLED_BY_DEFAULT
-#endif
-};
-
 }  // namespace features
 
 namespace tracing {
 
 bool TracingUsesPerfettoBackend() {
-  return base::CommandLine::ForCurrentProcess()->HasSwitch(
-             switches::kEnablePerfetto) ||
-         base::FeatureList::IsEnabled(features::kTracingPerfettoBackend);
+  return base::FeatureList::IsEnabled(features::kTracingPerfettoBackend);
 }
 
 }  // namespace tracing
--- a/services/tracing/public/cpp/tracing_features.h	2019-05-01 01:22:57.000000000 +0300
+++ b/services/tracing/public/cpp/tracing_features.h	2019-05-17 18:53:38.016000000 +0300
@@ -18,9 +18,6 @@
 extern const COMPONENT_EXPORT(TRACING_CPP) base::Feature
     kTracingPerfettoBackend;
 
-extern const COMPONENT_EXPORT(TRACING_CPP) base::Feature
-    kTracingServiceInProcess;
-
 }  // namespace features
 
 namespace tracing {
--- a/services/tracing/public/mojom/BUILD.gn	2019-05-01 01:22:57.000000000 +0300
+++ b/services/tracing/public/mojom/BUILD.gn	2019-05-17 18:53:38.016000000 +0300
@@ -9,17 +9,10 @@
   macro_prefix = "TRACING_MOJOM"
 
   sources = [
-    "traced_process.mojom",
-  ]
-
-  if (!is_nacl && !is_ios) {
-    enabled_features = [ "is_perfetto_supported_os" ]
-    sources += [
       "constants.mojom",
       "perfetto_service.mojom",
       "tracing.mojom",
     ]
-  }
 
   public_deps = [
     "//mojo/public/mojom/base",
--- a/services/tracing/public/mojom/constants.mojom	2019-05-01 01:22:57.000000000 +0300
+++ b/services/tracing/public/mojom/constants.mojom	2019-05-17 18:53:38.016000000 +0300
@@ -4,8 +4,6 @@
 
 module tracing.mojom;
 
-const uint32 kStopTracingRetryTimeMilliseconds = 100;
-
 const string kServiceName = "tracing";
 
 // The label of agents that provide trace data of the format explained in
--- a/services/tracing/public/mojom/OWNERS	2019-05-01 01:22:57.000000000 +0300
+++ b/services/tracing/public/mojom/OWNERS	2019-05-17 18:53:38.016000000 +0300
@@ -1,6 +1,2 @@
 per-file *.mojom=set noparent
 per-file *.mojom=file://ipc/SECURITY_OWNERS
-per-file *_mojom_traits*.*=set noparent
-per-file *_mojom_traits*.*=file://ipc/SECURITY_OWNERS
-per-file *.typemap=set noparent
-per-file *.typemap=file://ipc/SECURITY_OWNERS
--- a/services/tracing/public/mojom/perfetto_service.mojom	2019-05-01 01:22:57.000000000 +0300
+++ b/services/tracing/public/mojom/perfetto_service.mojom	2019-05-17 18:53:38.016000000 +0300
@@ -4,7 +4,6 @@
 
 module tracing.mojom;
 
-const string kPerfettoProducerName = "org.chromium.perfetto_producer";
 const string kTraceEventDataSourceName = "org.chromium.trace_event";
 const string kMetaDataSourceName = "org.chromium.trace_metadata";
 const string kSystemTraceDataSourceName = "org.chromium.trace_system";
@@ -64,22 +63,10 @@
   uint64 flush_request_id;
 };
 
-// Passed as part of DataSourceConfig
-struct ChromeConfig {
-  // TODO(crbug/928687): Once we've completed removing the old IPC layer we
-  // should convert this into a struct that represents a
-  // base::trace_event::TraceConfig object rather then the json encoded string
-  // used currently.
-  string trace_config;
-};
-
 struct DataSourceConfig {
   string name;
+  string trace_config;
   uint32 target_buffer;
-  uint32 trace_duration_ms;
-  uint64 tracing_session_id;
-  ChromeConfig chrome_config;
-  string legacy_config;
 };
 
 struct DataSourceRegistration {
@@ -87,8 +74,6 @@
   bool will_notify_on_stop;
 };
 
-// This is implemented by the tracing service and represents the service-
-// side instance for each ProducerClient.
 interface ProducerHost {
   // Called by a ProducerClient to ask the service to:
   // 1) Move data from the shared memory buffer into the final tracing buffer
@@ -112,12 +97,10 @@
   UnregisterTraceWriter(uint32 writer_id);
 };
 
-// Any client wishing to provide tracing data to Perfetto, can implement
-// this interface and use the PerfettoService interface within the tracing
-// service to register itself.
 interface ProducerClient {
     OnTracingStart(handle<shared_buffer> shared_memory);
 
+    // TODO(oysteine): Make a TypeTrait for sending the full DataSourceConfig.
     // Called by Perfetto (via ProducerHost) to request a data source to start
     // logging.
     StartDataSource(uint64 id, DataSourceConfig data_source_config);
@@ -127,56 +110,7 @@
     Flush(uint64 flush_request_id, array<uint64> data_source_ids);
 };
 
-// This is implemented by the tracing service, and is essentially a singleton
-// factory for establishing bi-directional communication with the Perfetto
-// tracing system. A client that wishes to provide tracing data when requested,
-// should implement ProducerClient for callbacks and pass along.
 interface PerfettoService {
   ConnectToProducerHost(ProducerClient producer_client,
                         ProducerHost& producer_host);
 };
-
-// The size of a buffer that the Consumer can request Perfetto to allocate
-// and then configure specific data sources to be written into.
-struct BufferConfig {
-  uint32 size_kb;
-};
-
-struct DataSource {
-  DataSourceConfig config;
-};
-
-// The configuration provided by a Consumer to the Perfetto service which
-// primarily configures which named data sources it would like to enable and
-// receive tracing data from, and how large the destination buffers should be.
-struct TraceConfig {
-  array<DataSource> data_sources;
-  array<BufferConfig> buffers;
-
-  uint32 duration_ms;
-};
-
-// The ConsumerHost interface is a privileged interface which is implemented
-// within the tracing service, and connected to by privileged services
-// (i.e. content_browser) to receive tracing data.
-interface ConsumerHost {
-  // Enable Perfetto tracing with the given TracingSession interface for
-  // signaling lifespan of the tracing session, and any future callbacks.
-  EnableTracing(TracingSession tracing_session, TraceConfig config);
-  // Tell Perfetto we're ready to receive data, over the given data pipe.
-  // The result callback will be called when there's no more data currently
-  // available. If the TracingSession is still active after the callback,
-  // another call to ReadBuffers() needs to be made to receive any new
-  // tracing data.
-  ReadBuffers(handle<data_pipe_producer> stream) => ();
-};
-
-// Any client connecting to ConsumerHost should implement this
-// interface which represents the lifetime of an active tracing
-// session. The ConsumerHost will disconnect it when tracing
-// is stopped, at which point the client can know that one
-// more ReadBuffers() call will receive any remaining tracing
-// data from the session (in addition to any calls it may have
-// made while the session is active, to stream out data).
-interface TracingSession {
-};
--- a/services/tracing/public/mojom/tracing.mojom	2019-05-01 01:22:57.000000000 +0300
+++ b/services/tracing/public/mojom/tracing.mojom	2019-05-17 18:53:38.016000000 +0300
@@ -9,6 +9,18 @@
 import "mojo/public/mojom/base/values.mojom";
 import "services/tracing/public/mojom/perfetto_service.mojom";
 
+struct ConnectToTracingRequest {
+  PerfettoService perfetto_service;
+  AgentRegistry agent_registry;
+};
+
+// The tracing service will bind this interface on every other service,
+// and pass it pointers to the interfaces within the tracing service
+// that the other services should register themselves with.
+interface TracedProcess {
+  ConnectToTracingService(ConnectToTracingRequest request);
+};
+
 // The JSON type of data coming from a tracing agents.
 //
 // - All agents with the same label should have the same type.
@@ -39,20 +51,9 @@
 // close the recorder connection to signal the tracing service that no more data
 // will be sent.
 interface Agent {
-  StartTracing(string config, mojo_base.mojom.TimeTicks coordinator_time)
-      => (bool success);
+  StartTracing(string config, mojo_base.mojom.TimeTicks coordinator_time);
   StopAndFlush(Recorder recorder);
   RequestBufferStatus() => (uint32 capacity, uint32 count);
-  // This is only ever needed when the legacy Coordinator uses Perfetto to
-  // start tracing, rather than calling StartTracing on each agent through
-  // this interface. In that case, the Coordinator still needs a way of
-  // deferring the success callback until we know that tracing has started
-  // in each relevant process. This is a temporary thing until all clients
-  // of the TracingController in the browser (which uses the
-  // Coordinator interface) have been migrated to use the Perfetto
-  // Consumer interface directly instead, and the Coordinator/Agent
-  // interfaces can be removed.
-  WaitForTracingEnabled() => ();
 };
 
 // An agent can make several calls to |AddChunk|. Chunks will be concatenated
@@ -71,7 +72,7 @@
   // The return value is false if tracing is already enabled with a different
   // config. Otherwise, true is returned as soon as the service receives acks
   // from all existing agents and agents that connect during |StartTracing|.
-  StartTracing(string config) => (bool success);
+  StartTracing(string config);
   StopAndFlush(handle<data_pipe_producer> stream)
       => (mojo_base.mojom.DictionaryValue metadata);
   // Same as |StopAndFlush| but only write data from a certain |agent_label| to
--- a/services/tracing/recorder.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/tracing/recorder.cc	2019-05-17 18:53:38.016000000 +0300
@@ -6,7 +6,6 @@
 
 #include <utility>
 
-#include "base/bind.h"
 #include "base/callback_forward.h"
 #include "base/memory/ref_counted.h"
 #include "services/tracing/public/mojom/tracing.mojom.h"
--- a/services/tracing/test_util.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/tracing/test_util.cc	2019-05-17 18:53:38.016000000 +0300
@@ -5,7 +5,6 @@
 #include "services/tracing/test_util.h"
 
 #include <string>
-#include <utility>
 
 #include "services/tracing/public/mojom/tracing.mojom.h"
 
@@ -22,10 +21,8 @@
 }
 
 void MockAgent::StartTracing(const std::string& config,
-                             base::TimeTicks coordinator_time,
-                             StartTracingCallback cb) {
+                             base::TimeTicks coordinator_time) {
   call_stat_.push_back("StartTracing");
-  std::move(cb).Run(true);
 }
 
 void MockAgent::StopAndFlush(mojom::RecorderPtr recorder) {
@@ -43,9 +40,4 @@
                     trace_log_status_.event_count);
 }
 
-void MockAgent::WaitForTracingEnabled(
-    Agent::WaitForTracingEnabledCallback callback) {
-  std::move(callback).Run();
-}
-
 }  // namespace tracing
--- a/services/tracing/test_util.h	2019-05-01 01:22:57.000000000 +0300
+++ b/services/tracing/test_util.h	2019-05-17 18:53:38.016000000 +0300
@@ -37,12 +37,9 @@
  private:
   // mojom::Agent
   void StartTracing(const std::string& config,
-                    base::TimeTicks coordinator_time,
-                    StartTracingCallback cb) override;
+                    base::TimeTicks coordinator_time) override;
   void StopAndFlush(mojom::RecorderPtr recorder) override;
   void RequestBufferStatus(RequestBufferStatusCallback cb) override;
-  void WaitForTracingEnabled(
-      Agent::WaitForTracingEnabledCallback callback) override;
 
   mojo::Binding<mojom::Agent> binding_;
   std::vector<std::string> call_stat_;
--- a/services/tracing/tracing_service.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/tracing/tracing_service.cc	2019-05-17 18:53:38.016000000 +0300
@@ -4,20 +4,16 @@
 
 #include "services/tracing/tracing_service.h"
 
-#include <map>
 #include <utility>
 #include <vector>
 
-#include "base/bind.h"
 #include "base/timer/timer.h"
 #include "services/service_manager/public/mojom/service_manager.mojom.h"
 #include "services/tracing/agent_registry.h"
 #include "services/tracing/coordinator.h"
-#include "services/tracing/perfetto/consumer_host.h"
 #include "services/tracing/perfetto/perfetto_service.h"
 #include "services/tracing/perfetto/perfetto_tracing_coordinator.h"
 #include "services/tracing/public/cpp/tracing_features.h"
-#include "services/tracing/public/mojom/traced_process.mojom.h"
 
 namespace tracing {
 
@@ -27,12 +23,12 @@
 class ServiceListener : public service_manager::mojom::ServiceManagerListener {
  public:
   ServiceListener(service_manager::Connector* connector,
-                  AgentRegistry* agent_registry,
-                  Coordinator* coordinator)
+                  scoped_refptr<base::SequencedTaskRunner> task_runner,
+                  AgentRegistry* agent_registry)
       : binding_(this),
         connector_(connector),
-        agent_registry_(agent_registry),
-        coordinator_(coordinator) {
+        task_runner_(task_runner),
+        agent_registry_(agent_registry) {
     service_manager::mojom::ServiceManagerPtr service_manager;
     connector_->BindInterface(service_manager::mojom::kServiceName,
                               &service_manager);
@@ -43,101 +39,65 @@
     binding_.Bind(std::move(request));
   }
 
-  size_t CountServicesWithPID(uint32_t pid) {
-    return std::count_if(service_pid_map_.begin(), service_pid_map_.end(),
-                         [pid](decltype(service_pid_map_)::value_type p) {
-                           return p.second == pid;
-                         });
-  }
-
-  void ServiceAddedWithPID(const service_manager::Identity& identity,
-                           uint32_t pid) {
-    service_pid_map_[identity] = pid;
-    // Not the first service added, so we're already sent it a connection
-    // request.
-    if (CountServicesWithPID(pid) > 1) {
-      return;
-    }
-
-    // Let the Coordinator know it should be expecting a connection
-    // from this process.
-    coordinator_->AddExpectedPID(pid);
-
+  void ConnectProcessToTracingService(
+      const service_manager::Identity& identity) {
     mojom::TracedProcessPtr traced_process;
     connector_->BindInterface(
         service_manager::ServiceFilter::ForExactIdentity(identity),
-        mojo::MakeRequest(&traced_process),
-        service_manager::mojom::BindInterfacePriority::kBestEffort);
+        &traced_process);
 
     auto new_connection_request = mojom::ConnectToTracingRequest::New();
 
     PerfettoService::GetInstance()->BindRequest(
-        mojo::MakeRequest(&new_connection_request->perfetto_service), pid);
+        mojo::MakeRequest(&new_connection_request->perfetto_service));
 
     agent_registry_->BindAgentRegistryRequest(
+        task_runner_,
         mojo::MakeRequest(&new_connection_request->agent_registry));
 
     traced_process->ConnectToTracingService(std::move(new_connection_request));
   }
 
-  void ServiceRemoved(const service_manager::Identity& identity) {
-    auto entry = service_pid_map_.find(identity);
-    if (entry != service_pid_map_.end()) {
-      uint32_t pid = entry->second;
-      service_pid_map_.erase(entry);
-      // Last entry with this PID removed; stop expecting it
-      // to connect to the tracing service.
-      if (CountServicesWithPID(pid) == 0) {
-        coordinator_->RemoveExpectedPID(pid);
-      }
-    }
-  }
-
   // service_manager::mojom::ServiceManagerListener implementation.
   void OnInit(std::vector<service_manager::mojom::RunningServiceInfoPtr>
                   running_services) override {
     for (auto& service : running_services) {
-      if (service->pid) {
-        ServiceAddedWithPID(service->identity, service->pid);
-      }
-    }
-
-    coordinator_->FinishedReceivingRunningPIDs();
-  }
-
-  void OnServicePIDReceived(const service_manager::Identity& identity,
-                            uint32_t pid) override {
-    ServiceAddedWithPID(identity, pid);
-  }
-
-  void OnServiceFailedToStart(
-      const service_manager::Identity& identity) override {
-    ServiceRemoved(identity);
+      ConnectProcessToTracingService(service->identity);
   }
-
-  void OnServiceStopped(const service_manager::Identity& identity) override {
-    ServiceRemoved(identity);
   }
 
   void OnServiceStarted(const service_manager::Identity& identity,
                         uint32_t pid) override {
+    ConnectProcessToTracingService(identity);
   }
 
   void OnServiceCreated(
       service_manager::mojom::RunningServiceInfoPtr service) override {}
+  void OnServicePIDReceived(const service_manager::Identity& identity,
+                            uint32_t pid) override {}
+  void OnServiceFailedToStart(
+      const service_manager::Identity& identity) override {}
+  void OnServiceStopped(const service_manager::Identity& identity) override {}
 
  private:
   mojo::Binding<service_manager::mojom::ServiceManagerListener> binding_;
   service_manager::Connector* connector_;
+  scoped_refptr<base::SequencedTaskRunner> task_runner_;
   AgentRegistry* agent_registry_;
-  Coordinator* coordinator_;
-  std::map<service_manager::Identity, uint32_t> service_pid_map_;
 };
 
 TracingService::TracingService(service_manager::mojom::ServiceRequest request)
-    : service_binding_(this, std::move(request)) {}
+    : service_binding_(this, std::move(request)),
+      task_runner_(base::SequencedTaskRunnerHandle::Get()) {}
+
+TracingService::~TracingService() {
+  task_runner_->DeleteSoon(FROM_HERE, std::move(tracing_agent_registry_));
 
-TracingService::~TracingService() = default;
+  if (perfetto_tracing_coordinator_) {
+    task_runner_->DeleteSoon(FROM_HERE,
+                             std::move(perfetto_tracing_coordinator_));
+  }
+}
 
 void TracingService::OnDisconnected() {
   CloseAgentConnectionsAndTerminate();
@@ -147,32 +107,31 @@
   tracing_agent_registry_ = std::make_unique<AgentRegistry>();
 
   if (TracingUsesPerfettoBackend()) {
+    task_runner_ = tracing::PerfettoService::GetInstance()->task_runner();
+
     auto perfetto_coordinator = std::make_unique<PerfettoTracingCoordinator>(
         tracing_agent_registry_.get(),
         base::BindRepeating(&TracingService::OnCoordinatorConnectionClosed,
-                            base::Unretained(this)));
+                            base::Unretained(this),
+                            base::SequencedTaskRunnerHandle::Get()));
     registry_.AddInterface(
         base::BindRepeating(&PerfettoTracingCoordinator::BindCoordinatorRequest,
                             base::Unretained(perfetto_coordinator.get())));
-    tracing_coordinator_ = std::move(perfetto_coordinator);
+    perfetto_tracing_coordinator_ = std::move(perfetto_coordinator);
   } else {
     auto tracing_coordinator = std::make_unique<Coordinator>(
         tracing_agent_registry_.get(),
         base::BindRepeating(&TracingService::OnCoordinatorConnectionClosed,
-                            base::Unretained(this)));
+                            base::Unretained(this), nullptr));
     registry_.AddInterface(
         base::BindRepeating(&Coordinator::BindCoordinatorRequest,
                             base::Unretained(tracing_coordinator.get())));
     tracing_coordinator_ = std::move(tracing_coordinator);
   }
 
-  registry_.AddInterface(
-      base::BindRepeating(&ConsumerHost::BindConsumerRequest,
-                          base::Unretained(PerfettoService::GetInstance())));
-
   service_listener_ = std::make_unique<ServiceListener>(
-      service_binding_.GetConnector(), tracing_agent_registry_.get(),
-      tracing_coordinator_.get());
+      service_binding_.GetConnector(), task_runner_,
+      tracing_agent_registry_.get());
 }
 
 void TracingService::OnBindInterface(
@@ -183,13 +142,29 @@
                           source_info);
 }
 
-void TracingService::OnCoordinatorConnectionClosed() {
+void TracingService::OnCoordinatorConnectionClosed(
+    scoped_refptr<base::SequencedTaskRunner> task_runner) {
+  // TODO(oysteine): Running TracingService and Perfetto on different
+  // sequences is getting messy; refactor so that the service manager
+  // runs the tracing service on a single threaded taskrunner so
+  // Perfetto can use the same.
+  if (task_runner && !task_runner->RunsTasksInCurrentSequence()) {
+    task_runner->PostTask(
+        FROM_HERE,
+        base::BindOnce(&TracingService::OnCoordinatorConnectionClosed,
+                       base::Unretained(this), nullptr));
+    return;
+  }
+
   service_binding_.RequestClose();
 }
 
 void TracingService::CloseAgentConnectionsAndTerminate() {
-  tracing_agent_registry_->DisconnectAllAgents();
-  Terminate();
+  task_runner_->PostTaskAndReply(
+      FROM_HERE,
+      base::BindOnce(&AgentRegistry::DisconnectAllAgents,
+                     base::Unretained(tracing_agent_registry_.get())),
+      base::BindOnce(&TracingService::Terminate, base::Unretained(this)));
 }
 
 }  // namespace tracing
--- a/services/tracing/tracing_service.h	2019-05-01 01:22:57.000000000 +0300
+++ b/services/tracing/tracing_service.h	2019-05-17 18:53:38.016000000 +0300
@@ -22,6 +22,7 @@
 namespace tracing {
 
 class ServiceListener;
+class PerfettoTracingCoordinator;
 
 class TracingService : public service_manager::Service {
  public:
@@ -36,7 +37,8 @@
                        mojo::ScopedMessagePipeHandle interface_pipe) override;
 
  private:
-  void OnCoordinatorConnectionClosed();
+  void OnCoordinatorConnectionClosed(
+      scoped_refptr<base::SequencedTaskRunner> task_runner);
   void CloseAgentConnectionsAndTerminate();
 
   service_manager::ServiceBinding service_binding_;
@@ -46,6 +48,8 @@
       registry_;
   std::unique_ptr<tracing::AgentRegistry> tracing_agent_registry_;
   std::unique_ptr<Coordinator> tracing_coordinator_;
+  scoped_refptr<base::SequencedTaskRunner> task_runner_;
+  std::unique_ptr<PerfettoTracingCoordinator> perfetto_tracing_coordinator_;
 
   std::unique_ptr<ServiceListener> service_listener_;
 
--- a/services/tracing/tracing_service_unittest.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/tracing/tracing_service_unittest.cc	2019-05-17 18:53:38.016000000 +0300
@@ -5,7 +5,6 @@
 #include <memory>
 #include <utility>
 
-#include "base/bind.h"
 #include "base/macros.h"
 #include "base/run_loop.h"
 #include "base/test/scoped_task_environment.h"
--- a/services/video_capture/broadcasting_receiver.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/video_capture/broadcasting_receiver.cc	2019-05-17 18:53:38.016000000 +0300
@@ -4,11 +4,7 @@
 
 #include "services/video_capture/broadcasting_receiver.h"
 
-#include "base/bind.h"
-#include "build/build_config.h"
-#include "media/capture/video/shared_memory_handle_provider.h"
 #include "mojo/public/cpp/bindings/strong_binding.h"
-#include "services/video_capture/public/mojom/scoped_access_permission.mojom.h"
 
 namespace video_capture {
 
@@ -24,82 +20,14 @@
   base::OnceClosure destruction_cb_;
 };
 
-void CloneSharedBufferHandle(const mojo::ScopedSharedBufferHandle& source,
-                             media::mojom::VideoBufferHandlePtr* target) {
-  // Special behavior here: If the handle was already read-only, the
-  // Clone() call here will maintain that read-only permission. If it was
-  // read-write, the cloned handle will have read-write permission.
-  //
-  // TODO(crbug.com/797470): We should be able to demote read-write to
-  // read-only permissions when Clone()'ing handles. Currently, this
-  // causes a crash.
-  (*target)->set_shared_buffer_handle(
-      source->Clone(mojo::SharedBufferHandle::AccessMode::READ_WRITE));
-}
-
-void CloneSharedBufferToRawFileDescriptorHandle(
-    const mojo::ScopedSharedBufferHandle& source,
-    media::mojom::VideoBufferHandlePtr* target) {
-#if defined(OS_LINUX)
-  media::SharedMemoryHandleProvider provider;
-  provider.InitFromMojoHandle(
-      source->Clone(mojo::SharedBufferHandle::AccessMode::READ_WRITE));
-  auto sub_struct = media::mojom::SharedMemoryViaRawFileDescriptor::New();
-  sub_struct->shared_memory_size_in_bytes = provider.GetMemorySizeInBytes();
-  sub_struct->file_descriptor_handle = mojo::WrapPlatformFile(
-      base::SharedMemory::DuplicateHandle(
-          provider.GetNonOwnedSharedMemoryHandleForLegacyIPC())
-          .GetHandle());
-  (*target)->set_shared_memory_via_raw_file_descriptor(std::move(sub_struct));
-#else
-  NOTREACHED() << "Cannot convert buffer handle to "
-                  "kSharedMemoryViaRawFileDescriptor on non-Linux platform.";
-#endif
-}
-
 }  // anonymous namespace
 
-BroadcastingReceiver::ClientContext::ClientContext(
-    mojom::ReceiverPtr client,
-    media::VideoCaptureBufferType target_buffer_type)
-    : client_(std::move(client)),
-      target_buffer_type_(target_buffer_type),
-      is_suspended_(false),
-      on_started_has_been_called_(false),
-      on_started_using_gpu_decode_has_been_called_(false) {}
-
-BroadcastingReceiver::ClientContext::~ClientContext() = default;
-
-BroadcastingReceiver::ClientContext::ClientContext(
-    BroadcastingReceiver::ClientContext&& other) = default;
-
-BroadcastingReceiver::ClientContext& BroadcastingReceiver::ClientContext::
-operator=(BroadcastingReceiver::ClientContext&& other) = default;
-
-void BroadcastingReceiver::ClientContext::OnStarted() {
-  if (on_started_has_been_called_)
-    return;
-  on_started_has_been_called_ = true;
-  client_->OnStarted();
-}
-
-void BroadcastingReceiver::ClientContext::OnStartedUsingGpuDecode() {
-  if (on_started_using_gpu_decode_has_been_called_)
-    return;
-  on_started_using_gpu_decode_has_been_called_ = true;
-  client_->OnStartedUsingGpuDecode();
-}
-
 BroadcastingReceiver::BufferContext::BufferContext(
     int buffer_id,
     media::mojom::VideoBufferHandlePtr buffer_handle)
     : buffer_id_(buffer_id),
       buffer_handle_(std::move(buffer_handle)),
-      consumer_hold_count_(0),
-      is_retired_(false) {
-  static int next_buffer_context_id = 0;
-  buffer_context_id_ = next_buffer_context_id++;
-}
+      consumer_hold_count_(0) {}
 
 BroadcastingReceiver::BufferContext::~BufferContext() = default;
 
@@ -125,70 +53,39 @@
 }
 
 media::mojom::VideoBufferHandlePtr
-BroadcastingReceiver::BufferContext::CloneBufferHandle(
-    media::VideoCaptureBufferType target_buffer_type) {
+BroadcastingReceiver::BufferContext::CloneBufferHandle() {
+  // Unable to use buffer_handle_->Clone(), because shared_buffer does not
+  // support the copy constructor.
   media::mojom::VideoBufferHandlePtr result =
       media::mojom::VideoBufferHandle::New();
-
-  // If the source uses mailbox hanldes, i.e. textures, we pass those through
-  // without conversion, no matter what clients requested.
-  if (buffer_handle_->is_mailbox_handles()) {
-    result->set_mailbox_handles(buffer_handle_->get_mailbox_handles()->Clone());
-    return result;
-  }
-
-  switch (target_buffer_type) {
-    case media::VideoCaptureBufferType::kMailboxHolder:
-      NOTREACHED() << "Cannot convert buffer type to kMailboxHolder from "
-                      "handle type other than mailbox handles.";
-      break;
-    case media::VideoCaptureBufferType::kSharedMemory:
       if (buffer_handle_->is_shared_buffer_handle()) {
-        CloneSharedBufferHandle(buffer_handle_->get_shared_buffer_handle(),
-                                &result);
-      } else if (buffer_handle_->is_shared_memory_via_raw_file_descriptor()) {
-        ConvertRawFileDescriptorToSharedBuffer();
-        CloneSharedBufferHandle(buffer_handle_->get_shared_buffer_handle(),
-                                &result);
-      } else {
-        NOTREACHED() << "Unexpected video buffer handle type";
-      }
-      break;
-    case media::VideoCaptureBufferType::kSharedMemoryViaRawFileDescriptor:
-      if (buffer_handle_->is_shared_buffer_handle()) {
-        CloneSharedBufferToRawFileDescriptorHandle(
-            buffer_handle_->get_shared_buffer_handle(), &result);
+    // Special behavior here: If the handle was already read-only, the Clone()
+    // call here will maintain that read-only permission. If it was read-write,
+    // the cloned handle will have read-write permission.
+    //
+    // TODO(crbug.com/797470): We should be able to demote read-write to
+    // read-only permissions when Clone()'ing handles. Currently, this causes a
+    // crash.
+    result->set_shared_buffer_handle(
+        buffer_handle_->get_shared_buffer_handle()->Clone(
+            mojo::SharedBufferHandle::AccessMode::READ_WRITE));
+  } else if (buffer_handle_->is_mailbox_handles()) {
+    result->set_mailbox_handles(buffer_handle_->get_mailbox_handles()->Clone());
       } else if (buffer_handle_->is_shared_memory_via_raw_file_descriptor()) {
-        ConvertRawFileDescriptorToSharedBuffer();
-        CloneSharedBufferToRawFileDescriptorHandle(
-            buffer_handle_->get_shared_buffer_handle(), &result);
+    auto sub_struct = media::mojom::SharedMemoryViaRawFileDescriptor::New();
+    sub_struct->shared_memory_size_in_bytes =
+        buffer_handle_->get_shared_memory_via_raw_file_descriptor()
+            ->shared_memory_size_in_bytes;
+    sub_struct->file_descriptor_handle = mojo::ScopedHandle(
+        buffer_handle_->get_shared_memory_via_raw_file_descriptor()
+            ->file_descriptor_handle.get());
+    result->set_shared_memory_via_raw_file_descriptor(std::move(sub_struct));
       } else {
         NOTREACHED() << "Unexpected video buffer handle type";
       }
-      break;
-  }
   return result;
 }
 
-void BroadcastingReceiver::BufferContext::
-    ConvertRawFileDescriptorToSharedBuffer() {
-  DCHECK(buffer_handle_->is_shared_memory_via_raw_file_descriptor());
-
-#if defined(OS_LINUX)
-  media::SharedMemoryHandleProvider provider;
-  provider.InitAsReadOnlyFromRawFileDescriptor(
-      std::move(buffer_handle_->get_shared_memory_via_raw_file_descriptor()
-                    ->file_descriptor_handle),
-      buffer_handle_->get_shared_memory_via_raw_file_descriptor()
-          ->shared_memory_size_in_bytes);
-  buffer_handle_->set_shared_buffer_handle(
-      provider.GetHandleForInterProcessTransit(true /*read_only*/));
-#else
-  NOTREACHED() << "Unable to consume buffer handle of type "
-                  "kSharedMemoryViaRawFileDescriptor on non-Linux platform.";
-#endif
-}
-
 BroadcastingReceiver::BroadcastingReceiver()
     : status_(Status::kOnStartedHasNotYetBeenCalled),
       error_(media::VideoCaptureError::kNone),
@@ -199,81 +96,46 @@
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
 }
 
-void BroadcastingReceiver::HideSourceRestartFromClients(
-    base::OnceClosure on_stopped_handler) {
-  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
-  on_stopped_handler_ = std::move(on_stopped_handler);
-  status_ = Status::kDeviceIsRestarting;
-}
-
-void BroadcastingReceiver::SetOnStoppedHandler(
-    base::OnceClosure on_stopped_handler) {
-  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
-  on_stopped_handler_ = std::move(on_stopped_handler);
-}
-
-int32_t BroadcastingReceiver::AddClient(
-    mojom::ReceiverPtr client,
-    media::VideoCaptureBufferType target_buffer_type) {
+int32_t BroadcastingReceiver::AddClient(mojom::ReceiverPtr client) {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
   auto client_id = next_client_id_++;
-  ClientContext context(std::move(client), target_buffer_type);
-  auto& added_client_context =
-      clients_.insert(std::make_pair(client_id, std::move(context)))
-          .first->second;
-  added_client_context.client().set_connection_error_handler(
+  clients_.insert(std::make_pair(client_id, std::move(client)));
+  auto& added_client = clients_[client_id];
+  added_client.set_connection_error_handler(
       base::BindOnce(&BroadcastingReceiver::OnClientDisconnected,
                      weak_factory_.GetWeakPtr(), client_id));
   if (status_ == Status::kOnErrorHasBeenCalled) {
-    added_client_context.client()->OnError(error_);
+    added_client->OnError(error_);
     return client_id;
   }
-  if (status_ == Status::kOnStartedHasBeenCalled) {
-    added_client_context.OnStarted();
-  }
-  if (status_ == Status::kOnStartedUsingGpuDecodeHasBeenCalled) {
-    added_client_context.OnStarted();
-    added_client_context.OnStartedUsingGpuDecode();
-  }
+  if (status_ == Status::kOnStartedHasBeenCalled)
+    added_client->OnStarted();
+  if (status_ == Status::kOnStartedUsingGpuDecodeHasBeenCalled)
+    added_client->OnStartedUsingGpuDecode();
 
   for (auto& buffer_context : buffer_contexts_) {
-    if (buffer_context.is_retired())
-      continue;
-    added_client_context.client()->OnNewBuffer(
-        buffer_context.buffer_context_id(),
-        buffer_context.CloneBufferHandle(
-            added_client_context.target_buffer_type()));
+    added_client->OnNewBuffer(buffer_context.buffer_id(),
+                              buffer_context.CloneBufferHandle());
   }
   return client_id;
 }
 
-void BroadcastingReceiver::SuspendClient(int32_t client_id) {
-  clients_.at(client_id).set_is_suspended(true);
-}
-
-void BroadcastingReceiver::ResumeClient(int32_t client_id) {
-  clients_.at(client_id).set_is_suspended(false);
-}
-
 mojom::ReceiverPtr BroadcastingReceiver::RemoveClient(int32_t client_id) {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
-  auto client = std::move(clients_.at(client_id));
+  auto client = std::move(clients_[client_id]);
   clients_.erase(client_id);
-  return std::move(client.client());
+  return client;
 }
 
 void BroadcastingReceiver::OnNewBuffer(
     int32_t buffer_id,
     media::mojom::VideoBufferHandlePtr buffer_handle) {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
-  CHECK(FindUnretiredBufferContextFromBufferId(buffer_id) ==
-        buffer_contexts_.end());
   buffer_contexts_.emplace_back(buffer_id, std::move(buffer_handle));
   auto& buffer_context = buffer_contexts_.back();
   for (auto& client : clients_) {
-    client.second.client()->OnNewBuffer(
-        buffer_context.buffer_context_id(),
-        buffer_context.CloneBufferHandle(client.second.target_buffer_type()));
+    client.second->OnNewBuffer(buffer_context.buffer_id(),
+                               buffer_context.CloneBufferHandle());
   }
 }
 
@@ -285,22 +147,17 @@
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
   if (clients_.empty())
     return;
-  auto buffer_context_iter = FindUnretiredBufferContextFromBufferId(buffer_id);
-  CHECK(buffer_context_iter != buffer_contexts_.end());
-  auto& buffer_context = *buffer_context_iter;
-  for (auto& client : clients_) {
-    if (client.second.is_suspended())
-      continue;
-    if (access_permission)
+  auto& buffer_context = LookupBufferContextFromBufferId(buffer_id);
       buffer_context.set_access_permission(std::move(access_permission));
+  for (auto& client : clients_) {
     mojom::ScopedAccessPermissionPtr consumer_access_permission;
     mojo::MakeStrongBinding(
         std::make_unique<ConsumerAccessPermission>(base::BindOnce(
             &BroadcastingReceiver::OnClientFinishedConsumingFrame,
-            weak_factory_.GetWeakPtr(), buffer_context.buffer_context_id())),
+            weak_factory_.GetWeakPtr(), buffer_context.buffer_id())),
         mojo::MakeRequest(&consumer_access_permission));
-    client.second.client()->OnFrameReadyInBuffer(
-        buffer_context.buffer_context_id(), frame_feedback_id,
+    client.second->OnFrameReadyInBuffer(
+        buffer_context.buffer_id(), frame_feedback_id,
         std::move(consumer_access_permission), frame_info.Clone());
     buffer_context.IncreaseConsumerCount();
   }
@@ -308,25 +165,17 @@
 
 void BroadcastingReceiver::OnBufferRetired(int32_t buffer_id) {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
-  auto buffer_context_iter = FindUnretiredBufferContextFromBufferId(buffer_id);
-  CHECK(buffer_context_iter != buffer_contexts_.end());
-  const auto context_id = buffer_context_iter->buffer_context_id();
-  if (buffer_context_iter->IsStillBeingConsumed())
-    // Mark the buffer context as retired but keep holding on to it until the
-    // last client finished consuming it, because it contains the
-    // |access_permission| required during consumption.
-    buffer_context_iter->set_retired();
-  else
-    buffer_contexts_.erase(buffer_context_iter);
+  auto& buffer_context = LookupBufferContextFromBufferId(buffer_id);
+  CHECK(!buffer_context.IsStillBeingConsumed());
   for (auto& client : clients_) {
-    client.second.client()->OnBufferRetired(context_id);
+    client.second->OnBufferRetired(buffer_id);
   }
 }
 
 void BroadcastingReceiver::OnError(media::VideoCaptureError error) {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
   for (auto& client : clients_) {
-    client.second.client()->OnError(error);
+    client.second->OnError(error);
   }
   status_ = Status::kOnErrorHasBeenCalled;
   error_ = error;
@@ -336,23 +185,21 @@
     media::VideoCaptureFrameDropReason reason) {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
   for (auto& client : clients_) {
-    if (client.second.is_suspended())
-      continue;
-    client.second.client()->OnFrameDropped(reason);
+    client.second->OnFrameDropped(reason);
   }
 }
 
 void BroadcastingReceiver::OnLog(const std::string& message) {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
   for (auto& client : clients_) {
-    client.second.client()->OnLog(message);
+    client.second->OnLog(message);
   }
 }
 
 void BroadcastingReceiver::OnStarted() {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
   for (auto& client : clients_) {
-    client.second.OnStarted();
+    client.second->OnStarted();
   }
   status_ = Status::kOnStartedHasBeenCalled;
 }
@@ -360,40 +207,15 @@
 void BroadcastingReceiver::OnStartedUsingGpuDecode() {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
   for (auto& client : clients_) {
-    client.second.OnStartedUsingGpuDecode();
+    client.second->OnStartedUsingGpuDecode();
   }
   status_ = Status::kOnStartedUsingGpuDecodeHasBeenCalled;
 }
 
-void BroadcastingReceiver::OnStopped() {
+void BroadcastingReceiver::OnClientFinishedConsumingFrame(int32_t buffer_id) {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
-  if (status_ == Status::kDeviceIsRestarting) {
-    status_ = Status::kOnStartedHasNotYetBeenCalled;
-    std::move(on_stopped_handler_).Run();
-  } else {
-    for (auto& client : clients_) {
-      client.second.client()->OnStopped();
-    }
-    status_ = Status::kOnStoppedHasBeenCalled;
-    if (on_stopped_handler_)
-      std::move(on_stopped_handler_).Run();
-  }
-}
-
-void BroadcastingReceiver::OnClientFinishedConsumingFrame(
-    int32_t buffer_context_id) {
-  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
-  auto buffer_context_iter =
-      std::find_if(buffer_contexts_.begin(), buffer_contexts_.end(),
-                   [buffer_context_id](const BufferContext& entry) {
-                     return entry.buffer_context_id() == buffer_context_id;
-                   });
-  CHECK(buffer_context_iter != buffer_contexts_.end());
-  buffer_context_iter->DecreaseConsumerCount();
-  if (buffer_context_iter->is_retired() &&
-      !buffer_context_iter->IsStillBeingConsumed()) {
-    buffer_contexts_.erase(buffer_context_iter);
-  }
+  auto& buffer_context = LookupBufferContextFromBufferId(buffer_id);
+  buffer_context.DecreaseConsumerCount();
 }
 
 void BroadcastingReceiver::OnClientDisconnected(int32_t client_id) {
@@ -401,15 +223,15 @@
   clients_.erase(client_id);
 }
 
-std::vector<BroadcastingReceiver::BufferContext>::iterator
-BroadcastingReceiver::FindUnretiredBufferContextFromBufferId(
-    int32_t buffer_id) {
+BroadcastingReceiver::BufferContext&
+BroadcastingReceiver::LookupBufferContextFromBufferId(int32_t buffer_id) {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
-  return std::find_if(buffer_contexts_.begin(), buffer_contexts_.end(),
+  auto context_iter =
+      std::find_if(buffer_contexts_.begin(), buffer_contexts_.end(),
                       [buffer_id](const BufferContext& entry) {
-                        return !entry.is_retired() &&
-                               entry.buffer_id() == buffer_id;
+                     return entry.buffer_id() == buffer_id;
                       });
+  return *context_iter;
 }
 
 }  // namespace video_capture
--- a/services/video_capture/broadcasting_receiver.h	2019-05-01 01:22:57.000000000 +0300
+++ b/services/video_capture/broadcasting_receiver.h	2019-05-17 18:53:38.016000000 +0300
@@ -10,9 +10,7 @@
 #include "base/memory/weak_ptr.h"
 #include "base/sequence_checker.h"
 #include "media/capture/video/video_frame_receiver.h"
-#include "media/capture/video_capture_types.h"
 #include "services/video_capture/public/mojom/receiver.mojom.h"
-#include "services/video_capture/public/mojom/scoped_access_permission.mojom.h"
 
 namespace video_capture {
 
@@ -23,22 +21,8 @@
   BroadcastingReceiver();
   ~BroadcastingReceiver() override;
 
-  // Indicates to the BroadcastingReceiver that we want to restart the source
-  // without letting connected clients know about the restart. The
-  // BroadcastingReceiver will hide the OnStopped() event sent by the source
-  // from the connected clients and instead invoke the given
-  // |on_stopped_handler|. It will also not forward the subsequent
-  // OnStarted() and possibly OnStartedUsingGpuDecode() events to clients who
-  // have already received these events.
-  void HideSourceRestartFromClients(base::OnceClosure on_stopped_handler);
-
-  void SetOnStoppedHandler(base::OnceClosure on_stopped_handler);
-
-  // Returns a client_id that can be used for a call to Suspend/Resume/Remove.
-  int32_t AddClient(mojom::ReceiverPtr client,
-                    media::VideoCaptureBufferType target_buffer_type);
-  void SuspendClient(int32_t client_id);
-  void ResumeClient(int32_t client_id);
+  // Returns a client_id that can be used for a call to RemoveClient().
+  int32_t AddClient(mojom::ReceiverPtr client);
   // Returns ownership of the client back to the caller.
   mojom::ReceiverPtr RemoveClient(int32_t client_id);
 
@@ -56,46 +40,18 @@
   void OnLog(const std::string& message) override;
   void OnStarted() override;
   void OnStartedUsingGpuDecode() override;
-  void OnStopped() override;
 
  private:
   enum class Status {
     kOnStartedHasNotYetBeenCalled,
     kOnStartedHasBeenCalled,
     kOnStartedUsingGpuDecodeHasBeenCalled,
-    kDeviceIsRestarting,
     kOnErrorHasBeenCalled,
-    kOnStoppedHasBeenCalled
-  };
-
-  // Wrapper that suppresses calls to OnStarted() and OnStartedUsingGpuDecode()
-  // after they have already been called once. Keeps track of whether or not
-  // a client is suspended.
-  class ClientContext {
-   public:
-    ClientContext(mojom::ReceiverPtr client,
-                  media::VideoCaptureBufferType target_buffer_type);
-    ~ClientContext();
-    ClientContext(ClientContext&& other);
-    ClientContext& operator=(ClientContext&& other);
-    void OnStarted();
-    void OnStartedUsingGpuDecode();
-
-    mojom::ReceiverPtr& client() { return client_; }
-    media::VideoCaptureBufferType target_buffer_type() {
-      return target_buffer_type_;
-    }
-    void set_is_suspended(bool suspended) { is_suspended_ = suspended; }
-    bool is_suspended() const { return is_suspended_; }
-
-   private:
-    mojom::ReceiverPtr client_;
-    media::VideoCaptureBufferType target_buffer_type_;
-    bool is_suspended_;
-    bool on_started_has_been_called_;
-    bool on_started_using_gpu_decode_has_been_called_;
   };
 
+  // Combines ownership of a media::mojom::VideoBufferHandlePtr with context
+  // needed for sharing the buffer as well as temporary access permission to
+  // its contents with potentially multiple consumers.
   class BufferContext {
    public:
     BufferContext(int32_t buffer_id,
@@ -103,7 +59,6 @@
     ~BufferContext();
     BufferContext(BufferContext&& other);
     BufferContext& operator=(BufferContext&& other);
-    int32_t buffer_context_id() const { return buffer_context_id_; }
     int32_t buffer_id() const { return buffer_id_; }
     void set_access_permission(
         mojom::ScopedAccessPermissionPtr access_permission) {
@@ -112,38 +67,25 @@
     void IncreaseConsumerCount();
     void DecreaseConsumerCount();
     bool IsStillBeingConsumed() const;
-    bool is_retired() const { return is_retired_; }
-    void set_retired() { is_retired_ = true; }
-    media::mojom::VideoBufferHandlePtr CloneBufferHandle(
-        media::VideoCaptureBufferType target_buffer_type);
+    media::mojom::VideoBufferHandlePtr CloneBufferHandle();
 
    private:
-    // If the source handle is shared_memory_via_raw_file_descriptor, we first
-    // have to unwrap it before we can clone it. Instead of unwrapping, cloning,
-    // and than wrapping back each time we need to clone it, we convert it to
-    // a regular shared memory and keep it in this form.
-    void ConvertRawFileDescriptorToSharedBuffer();
-
-    int32_t buffer_context_id_;
     int32_t buffer_id_;
     media::mojom::VideoBufferHandlePtr buffer_handle_;
     // Indicates how many consumers are currently relying on
     // |access_permission_|.
     int32_t consumer_hold_count_;
-    bool is_retired_;
     mojom::ScopedAccessPermissionPtr access_permission_;
   };
 
-  void OnClientFinishedConsumingFrame(int32_t buffer_context_id);
+  void OnClientFinishedConsumingFrame(int32_t buffer_id);
   void OnClientDisconnected(int32_t client_id);
-  std::vector<BufferContext>::iterator FindUnretiredBufferContextFromBufferId(
-      int32_t buffer_id);
+  BufferContext& LookupBufferContextFromBufferId(int32_t buffer_id);
 
   SEQUENCE_CHECKER(sequence_checker_);
-  std::map<int32_t /*client_id*/, ClientContext> clients_;
+  std::map<int32_t /*client_id*/, mojom::ReceiverPtr> clients_;
   std::vector<BufferContext> buffer_contexts_;
   Status status_;
-  base::OnceClosure on_stopped_handler_;
 
   // Keeps track of the last VideoCaptureError that arrived via OnError().
   // This is used for relaying the error event to clients that connect after the
--- a/services/video_capture/BUILD.gn	2019-05-01 01:22:57.000000000 +0300
+++ b/services/video_capture/BUILD.gn	2019-05-17 18:53:38.016000000 +0300
@@ -2,7 +2,9 @@
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
+import("//services/catalog/public/tools/catalog.gni")
 import("//services/service_manager/public/cpp/service_executable.gni")
+import("//services/service_manager/public/service_manifest.gni")
 import("//testing/test.gni")
 
 service_executable("video_capture") {
@@ -18,6 +20,11 @@
   ]
 }
 
+service_manifest("manifest") {
+  name = "video_capture"
+  source = "service_manifest.json"
+}
+
 source_set("lib") {
   sources = [
     "broadcasting_receiver.cc",
@@ -66,17 +73,12 @@
     "//services/video_capture/public/uma",
     "//services/ws/public/cpp/gpu:gpu",
   ]
-
-  if (is_chromeos) {
-    public_deps += [ "//media/capture/video/chromeos/mojo:cros_camera" ]
-  }
 }
 
 source_set("tests") {
   testonly = true
 
   sources = [
-    "broadcasting_receiver_unittest.cc",
     "device_media_to_mojo_adapter_unittest.cc",
     "test/device_factory_provider_connectortest.cc",
     "test/device_factory_provider_test.cc",
@@ -100,13 +102,13 @@
 
   deps = [
     ":lib",
+    ":tests_catalog_source",
     ":video_capture",
     "//base/test:test_support",
     "//media/capture:test_support",
     "//media/capture/mojom:video_capture",
     "//services/service_manager/public/cpp",
     "//services/service_manager/public/cpp/test:test_support",
-    "//services/video_capture/public/cpp:manifest",
     "//services/video_capture/public/cpp:mocks",
     "//testing/gmock",
     "//testing/gtest",
@@ -117,3 +119,20 @@
     ":video_capture",
   ]
 }
+
+service_manifest("unittest_manifest") {
+  name = "video_capture_unittests"
+  source = "test/service_unittest_manifest.json"
+}
+
+catalog("tests_catalog") {
+  testonly = true
+  embedded_services = [ ":unittest_manifest" ]
+  standalone_services = [ ":manifest" ]
+}
+
+catalog_cpp_source("tests_catalog_source") {
+  testonly = true
+  catalog = ":tests_catalog"
+  generated_function_name = "video_capture::CreateTestCatalog"
+}
--- a/services/video_capture/device_factory.h	2019-05-01 01:22:57.000000000 +0300
+++ b/services/video_capture/device_factory.h	2019-05-17 18:53:38.016000000 +0300
@@ -8,20 +8,12 @@
 #include "services/service_manager/public/cpp/service_context_ref.h"
 #include "services/video_capture/public/mojom/device_factory.mojom.h"
 
-#if defined(OS_CHROMEOS)
-#include "media/capture/video/chromeos/mojo/cros_image_capture.mojom.h"
-#endif  // defined(OS_CHROMEOS)
-
 namespace video_capture {
 
 class DeviceFactory : public mojom::DeviceFactory {
  public:
   virtual void SetServiceRef(
       std::unique_ptr<service_manager::ServiceContextRef> service_ref) = 0;
-#if defined(OS_CHROMEOS)
-  virtual void BindCrosImageCaptureRequest(
-      cros::mojom::CrosImageCaptureRequest request) = 0;
-#endif  // defined(OS_CHROMEOS)
 };
 
 }  // namespace video_capture
--- a/services/video_capture/device_factory_media_to_mojo_adapter.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/video_capture/device_factory_media_to_mojo_adapter.cc	2019-05-17 18:53:38.020000000 +0300
@@ -5,9 +5,7 @@
 #include "services/video_capture/device_factory_media_to_mojo_adapter.h"
 
 #include <sstream>
-#include <utility>
 
-#include "base/bind.h"
 #include "base/logging.h"
 #include "base/stl_util.h"
 #include "base/strings/stringprintf.h"
@@ -15,7 +13,6 @@
 #include "media/capture/video/video_capture_device_info.h"
 #include "mojo/public/cpp/bindings/strong_binding.h"
 #include "services/video_capture/device_media_to_mojo_adapter.h"
-#include "services/video_capture/public/mojom/producer.mojom.h"
 #include "services/video_capture/public/uma/video_capture_service_event.h"
 
 namespace {
@@ -195,13 +192,4 @@
   active_devices_by_id_.erase(device_id);
 }
 
-#if defined(OS_CHROMEOS)
-void DeviceFactoryMediaToMojoAdapter::BindCrosImageCaptureRequest(
-    cros::mojom::CrosImageCaptureRequest request) {
-  CHECK(capture_system_);
-
-  capture_system_->BindCrosImageCaptureRequest(std::move(request));
-}
-#endif  // defined(OS_CHROMEOS)
-
 }  // namespace video_capture
--- a/services/video_capture/device_factory_media_to_mojo_adapter.h	2019-05-01 01:22:57.000000000 +0300
+++ b/services/video_capture/device_factory_media_to_mojo_adapter.h	2019-05-17 18:53:38.020000000 +0300
@@ -12,11 +12,6 @@
 #include "mojo/public/cpp/bindings/binding.h"
 #include "services/service_manager/public/cpp/service_context_ref.h"
 #include "services/video_capture/device_factory.h"
-#include "services/video_capture/public/mojom/devices_changed_observer.mojom.h"
-
-#if defined(OS_CHROMEOS)
-#include "media/capture/video/chromeos/mojo/cros_image_capture.mojom.h"
-#endif  // defined(OS_CHROMEOS)
 
 namespace video_capture {
 
@@ -53,11 +48,6 @@
       mojom::DevicesChangedObserverPtr observer,
       bool raise_event_if_virtual_devices_already_present) override;
 
-#if defined(OS_CHROMEOS)
-  void BindCrosImageCaptureRequest(
-      cros::mojom::CrosImageCaptureRequest request) override;
-#endif  // defined(OS_CHROMEOS)
-
  private:
   struct ActiveDeviceEntry {
     ActiveDeviceEntry();
--- a/services/video_capture/device_factory_provider_impl.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/video_capture/device_factory_provider_impl.cc	2019-05-17 18:53:38.020000000 +0300
@@ -4,9 +4,6 @@
 
 #include "services/video_capture/device_factory_provider_impl.h"
 
-#include <utility>
-
-#include "base/bind.h"
 #include "base/task/post_task.h"
 #include "gpu/command_buffer/client/gpu_memory_buffer_manager.h"
 #include "media/capture/video/create_video_capture_device_factory.h"
@@ -72,14 +69,12 @@
 };
 
 DeviceFactoryProviderImpl::DeviceFactoryProviderImpl(
-    scoped_refptr<base::SingleThreadTaskRunner> ui_task_runner,
-    base::OnceClosure request_service_quit_asap_cb)
-    : ui_task_runner_(std::move(ui_task_runner)),
-      request_service_quit_asap_cb_(std::move(request_service_quit_asap_cb)) {
+    scoped_refptr<base::SingleThreadTaskRunner> ui_task_runner)
+    : ui_task_runner_(std::move(ui_task_runner)) {
   // Unretained |this| is safe because |factory_bindings_| is owned by
   // |this|.
   factory_bindings_.set_connection_error_handler(base::BindRepeating(
-      &DeviceFactoryProviderImpl::OnFactoryOrSourceProviderClientDisconnected,
+      &DeviceFactoryProviderImpl::OnFactoryClientDisconnected,
       base::Unretained(this)));
 }
 
@@ -110,18 +105,16 @@
     mojom::DeviceFactoryRequest request) {
   DCHECK(service_ref_);
   LazyInitializeDeviceFactory();
+  if (factory_bindings_.empty())
+    device_factory_->SetServiceRef(service_ref_->Clone());
   factory_bindings_.AddBinding(device_factory_.get(), std::move(request));
 }
 
 void DeviceFactoryProviderImpl::ConnectToVideoSourceProvider(
     mojom::VideoSourceProviderRequest request) {
   LazyInitializeVideoSourceProvider();
-  video_source_provider_->AddClient(std::move(request));
-}
-
-void DeviceFactoryProviderImpl::ShutdownServiceAsap() {
-  if (request_service_quit_asap_cb_)
-    std::move(request_service_quit_asap_cb_).Run();
+  video_source_provider_bindings_.AddBinding(video_source_provider_.get(),
+                                             std::move(request));
 }
 
 void DeviceFactoryProviderImpl::LazyInitializeGpuDependenciesContext() {
@@ -130,15 +123,8 @@
 }
 
 void DeviceFactoryProviderImpl::LazyInitializeDeviceFactory() {
-  DCHECK(service_ref_);
-
-  // Factory may already exist but if no client was connected it will not have a
-  // ServiceRef.
-  if (device_factory_) {
-    if (factory_bindings_.empty())
-      device_factory_->SetServiceRef(service_ref_->Clone());
+  if (device_factory_)
     return;
-  }
 
   LazyInitializeGpuDependenciesContext();
 
@@ -160,7 +146,6 @@
               &GpuDependenciesContext::CreateJpegDecodeAccelerator,
               gpu_dependencies_context_->GetWeakPtr()),
           gpu_dependencies_context_->GetTaskRunner()));
-  device_factory_->SetServiceRef(service_ref_->Clone());
 }
 
 void DeviceFactoryProviderImpl::LazyInitializeVideoSourceProvider() {
@@ -166,44 +151,21 @@
 void DeviceFactoryProviderImpl::LazyInitializeVideoSourceProvider() {
   if (video_source_provider_)
     return;
+
   LazyInitializeDeviceFactory();
-  video_source_provider_ = std::make_unique<VideoSourceProviderImpl>(
-      device_factory_.get(),
-      // Unretained(this) is safe, because |this| owns |video_source_provider_|.
-      base::BindRepeating(
-          &DeviceFactoryProviderImpl::OnLastSourceProviderClientDisconnected,
-          base::Unretained(this)));
-}
 
-void DeviceFactoryProviderImpl::OnLastSourceProviderClientDisconnected() {
-  video_source_provider_.reset();
-  OnFactoryOrSourceProviderClientDisconnected();
+  video_source_provider_ =
+      std::make_unique<VideoSourceProviderImpl>(device_factory_.get());
 }
 
-void DeviceFactoryProviderImpl::OnFactoryOrSourceProviderClientDisconnected() {
-  // If |video_source_provider_| still exists, it means there is still a client
-  // connected to it, in which case we also still need |device_factory_| to
-  // stay operational.
-  if (video_source_provider_)
-    return;
-
-  // If neither |device_factory_| nor |video_source_provider_| have clients
-  // connected, release service ref so that service shutdown timeout can start
-  // if no other references are still alive. We keep the |device_factory_|
-  // instance alive in order to avoid losing state that would be expensive to
-  // reinitialize, e.g. having already enumerated the available devices.
-  if (factory_bindings_.empty()) {
+void DeviceFactoryProviderImpl::OnFactoryClientDisconnected() {
+  // If last client has disconnected, release service ref so that service
+  // shutdown timeout starts if no other references are still alive.
+  // We keep the |device_factory_| instance alive in order to avoid
+  // losing state that would be expensive to reinitialize, e.g. having
+  // already enumerated the available devices.
+  if (factory_bindings_.empty())
     device_factory_->SetServiceRef(nullptr);
-  }
-}
-
-#if defined(OS_CHROMEOS)
-void DeviceFactoryProviderImpl::BindCrosImageCaptureRequest(
-    cros::mojom::CrosImageCaptureRequest request) {
-  CHECK(device_factory_);
-
-  device_factory_->BindCrosImageCaptureRequest(std::move(request));
 }
-#endif  // defined(OS_CHROMEOS)
 
 }  // namespace video_capture
--- a/services/video_capture/device_factory_provider_impl.h	2019-05-01 01:22:57.000000000 +0300
+++ b/services/video_capture/device_factory_provider_impl.h	2019-05-17 18:53:38.020000000 +0300
@@ -14,23 +14,16 @@
 #include "services/service_manager/public/cpp/connector.h"
 #include "services/service_manager/public/cpp/service.h"
 #include "services/service_manager/public/cpp/service_context_ref.h"
-#include "services/video_capture/public/mojom/device_factory.mojom.h"
 #include "services/video_capture/public/mojom/device_factory_provider.mojom.h"
 
-#if defined(OS_CHROMEOS)
-#include "media/capture/video/chromeos/mojo/cros_image_capture.mojom.h"
-#endif  // defined(OS_CHROMEOS)
-
 namespace video_capture {
 
 class VirtualDeviceEnabledDeviceFactory;
-class VideoSourceProviderImpl;
 
 class DeviceFactoryProviderImpl : public mojom::DeviceFactoryProvider {
  public:
   explicit DeviceFactoryProviderImpl(
-      scoped_refptr<base::SingleThreadTaskRunner> ui_task_runner,
-      base::OnceClosure request_service_quit_asap_cb);
+      scoped_refptr<base::SingleThreadTaskRunner> ui_task_runner);
   ~DeviceFactoryProviderImpl() override;
 
   void SetServiceRef(
@@ -42,12 +35,6 @@
   void ConnectToDeviceFactory(mojom::DeviceFactoryRequest request) override;
   void ConnectToVideoSourceProvider(
       mojom::VideoSourceProviderRequest request) override;
-  void ShutdownServiceAsap() override;
-
-#if defined(OS_CHROMEOS)
-  void BindCrosImageCaptureRequest(
-      cros::mojom::CrosImageCaptureRequest request);
-#endif  // defined(OS_CHROMEOS)
 
  private:
   class GpuDependenciesContext;
@@ -55,17 +42,16 @@
   void LazyInitializeGpuDependenciesContext();
   void LazyInitializeDeviceFactory();
   void LazyInitializeVideoSourceProvider();
-  void OnLastSourceProviderClientDisconnected();
-  void OnFactoryOrSourceProviderClientDisconnected();
+  void OnFactoryClientDisconnected();
 
   mojo::BindingSet<mojom::DeviceFactory> factory_bindings_;
   std::unique_ptr<VirtualDeviceEnabledDeviceFactory> device_factory_;
-  std::unique_ptr<VideoSourceProviderImpl> video_source_provider_;
+  mojo::BindingSet<mojom::VideoSourceProvider> video_source_provider_bindings_;
+  std::unique_ptr<mojom::VideoSourceProvider> video_source_provider_;
   std::unique_ptr<service_manager::ServiceContextRef> service_ref_;
   std::unique_ptr<GpuDependenciesContext> gpu_dependencies_context_;
 
   scoped_refptr<base::SingleThreadTaskRunner> ui_task_runner_;
-  base::OnceClosure request_service_quit_asap_cb_;
 
   DISALLOW_COPY_AND_ASSIGN(DeviceFactoryProviderImpl);
 };
--- a/services/video_capture/device_media_to_mojo_adapter.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/video_capture/device_media_to_mojo_adapter.cc	2019-05-17 18:53:38.020000000 +0300
@@ -4,7 +4,6 @@
 
 #include "services/video_capture/device_media_to_mojo_adapter.h"
 
-#include "base/bind.h"
 #include "base/logging.h"
 #include "media/base/bind_to_current_loop.h"
 #include "media/capture/video/scoped_video_capture_jpeg_decoder.h"
@@ -96,6 +95,19 @@
   device_started_ = true;
 }
 
+void DeviceMediaToMojoAdapter::OnReceiverReportingUtilization(
+    int32_t frame_feedback_id,
+    double utilization) {
+  DCHECK(thread_checker_.CalledOnValidThread());
+  device_->OnUtilizationReport(frame_feedback_id, utilization);
+}
+
+void DeviceMediaToMojoAdapter::RequestRefreshFrame() {
+  if (!device_started_)
+    return;
+  device_->RequestRefreshFrame();
+}
+
 void DeviceMediaToMojoAdapter::MaybeSuspend() {
   if (!device_started_)
     return;
@@ -133,7 +145,7 @@
 
 void DeviceMediaToMojoAdapter::Stop() {
   DCHECK(thread_checker_.CalledOnValidThread());
-  if (!device_started_)
+  if (device_started_ == false)
     return;
   device_started_ = false;
   weak_factory_.InvalidateWeakPtrs();
--- a/services/video_capture/device_media_to_mojo_adapter.h	2019-05-01 01:22:57.000000000 +0300
+++ b/services/video_capture/device_media_to_mojo_adapter.h	2019-05-17 18:53:38.020000000 +0300
@@ -32,6 +32,9 @@
   // mojom::Device implementation.
   void Start(const media::VideoCaptureParams& requested_settings,
              mojom::ReceiverPtr receiver) override;
+  void OnReceiverReportingUtilization(int32_t frame_feedback_id,
+                                      double utilization) override;
+  void RequestRefreshFrame() override;
   void MaybeSuspend() override;
   void Resume() override;
   void GetPhotoState(GetPhotoStateCallback callback) override;
--- a/services/video_capture/device_media_to_mojo_adapter_unittest.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/video_capture/device_media_to_mojo_adapter_unittest.cc	2019-05-17 18:53:38.020000000 +0300
@@ -4,7 +4,6 @@
 
 #include "services/video_capture/device_media_to_mojo_adapter.h"
 
-#include "base/bind_helpers.h"
 #include "base/run_loop.h"
 #include "base/test/scoped_task_environment.h"
 #include "media/capture/video/mock_device.h"
--- a/services/video_capture/OWNERS	2019-05-01 01:22:57.000000000 +0300
+++ b/services/video_capture/OWNERS	2019-05-17 18:53:38.016000000 +0300
@@ -4,3 +4,6 @@
 chfremer@chromium.org
 emircan@chromium.org
 mcasas@chromium.org
+
+per-file service_manifest.json=set noparent
+per-file service_manifest.json=file://ipc/SECURITY_OWNERS
--- a/services/video_capture/public/cpp/BUILD.gn	2019-05-01 01:22:57.000000000 +0300
+++ b/services/video_capture/public/cpp/BUILD.gn	2019-05-17 18:53:38.020000000 +0300
@@ -4,6 +4,8 @@
 
 source_set("cpp") {
   sources = [
+    "device_to_feedback_observer_adapter.cc",
+    "device_to_feedback_observer_adapter.h",
     "receiver_media_to_mojo_adapter.cc",
     "receiver_media_to_mojo_adapter.h",
   ]
@@ -23,22 +25,6 @@
   ]
 }
 
-source_set("manifest") {
-  sources = [
-    "manifest.cc",
-    "manifest.h",
-  ]
-  deps = [
-    "//base",
-    "//services/service_manager/public/cpp",
-    "//services/video_capture/public/mojom",
-    "//services/video_capture/public/mojom:constants",
-  ]
-  if (is_chromeos) {
-    deps += [ "//media/capture/video/chromeos/mojo:cros_camera" ]
-  }
-}
-
 source_set("mocks") {
   testonly = true
 
--- a/services/video_capture/public/cpp/mock_device_factory.h	2019-05-01 01:22:57.000000000 +0300
+++ b/services/video_capture/public/cpp/mock_device_factory.h	2019-05-17 18:53:38.020000000 +0300
@@ -6,8 +6,6 @@
 #define SERVICES_VIDEO_CAPTURE_PUBLIC_CPP_MOCK_DEVICE_FACTORY_H_
 
 #include "services/video_capture/public/mojom/device_factory.mojom.h"
-#include "services/video_capture/public/mojom/devices_changed_observer.mojom.h"
-#include "services/video_capture/public/mojom/producer.mojom.h"
 #include "testing/gmock/include/gmock/gmock.h"
 
 namespace video_capture {
--- a/services/video_capture/public/cpp/mock_device_factory_provider.h	2019-05-01 01:22:57.000000000 +0300
+++ b/services/video_capture/public/cpp/mock_device_factory_provider.h	2019-05-17 18:53:38.020000000 +0300
@@ -33,7 +33,6 @@
                void(video_capture::mojom::DeviceFactoryRequest& request));
   MOCK_METHOD1(DoConnectToVideoSourceProvider,
                void(video_capture::mojom::VideoSourceProviderRequest& request));
-  MOCK_METHOD0(ShutdownServiceAsap, void());
 };
 
 }  // namespace video_capture
--- a/services/video_capture/public/cpp/mock_producer.h	2019-05-01 01:22:57.000000000 +0300
+++ b/services/video_capture/public/cpp/mock_producer.h	2019-05-17 18:53:38.020000000 +0300
@@ -5,7 +5,6 @@
 #ifndef SERVICES_VIDEO_CAPTURE_PUBLIC_CPP_MOCK_PRODUCER_H_
 #define SERVICES_VIDEO_CAPTURE_PUBLIC_CPP_MOCK_PRODUCER_H_
 
-#include "media/capture/mojom/video_capture_types.mojom.h"
 #include "media/mojo/interfaces/media_types.mojom.h"
 #include "mojo/public/cpp/bindings/binding.h"
 #include "services/video_capture/public/mojom/producer.mojom.h"
--- a/services/video_capture/public/cpp/mock_push_subscription.h	2019-05-01 01:22:57.000000000 +0300
+++ b/services/video_capture/public/cpp/mock_push_subscription.h	2019-05-17 18:53:38.020000000 +0300
@@ -5,7 +5,6 @@
 #ifndef SERVICES_VIDEO_CAPTURE_PUBLIC_CPP_MOCK_PUSH_SUBSCRIPTION_H_
 #define SERVICES_VIDEO_CAPTURE_PUBLIC_CPP_MOCK_PUSH_SUBSCRIPTION_H_
 
-#include "media/capture/mojom/image_capture.mojom.h"
 #include "services/video_capture/public/mojom/video_source.mojom.h"
 #include "testing/gmock/include/gmock/gmock.h"
 
--- a/services/video_capture/public/cpp/mock_receiver.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/video_capture/public/cpp/mock_receiver.cc	2019-05-17 18:53:38.020000000 +0300
@@ -4,34 +4,18 @@
 
 #include "services/video_capture/public/cpp/mock_receiver.h"
 
-#include "base/stl_util.h"
-#include "services/video_capture/public/mojom/scoped_access_permission.mojom.h"
-
 namespace video_capture {
 
-MockReceiver::MockReceiver()
-    : binding_(this), should_store_access_permissions_(false) {}
+MockReceiver::MockReceiver() : binding_(this) {}
 
 MockReceiver::MockReceiver(mojom::ReceiverRequest request)
-    : binding_(this, std::move(request)),
-      should_store_access_permissions_(false) {}
+    : binding_(this, std::move(request)) {}
 
 MockReceiver::~MockReceiver() = default;
 
-void MockReceiver::HoldAccessPermissions() {
-  should_store_access_permissions_ = true;
-}
-
-void MockReceiver::ReleaseAccessPermissions() {
-  should_store_access_permissions_ = false;
-  access_permissions_.clear();
-}
-
 void MockReceiver::OnNewBuffer(
     int32_t buffer_id,
     media::mojom::VideoBufferHandlePtr buffer_handle) {
-  CHECK(!base::ContainsValue(known_buffer_ids_, buffer_id));
-  known_buffer_ids_.push_back(buffer_id);
   DoOnNewBuffer(buffer_id, &buffer_handle);
 }
 
@@ -42,16 +26,6 @@
     media::mojom::VideoFrameInfoPtr frame_info) {
   DoOnFrameReadyInBuffer(buffer_id, frame_feedback_id, &access_permission,
                          &frame_info);
-  if (should_store_access_permissions_)
-    access_permissions_.emplace_back(std::move(access_permission));
-}
-
-void MockReceiver::OnBufferRetired(int32_t buffer_id) {
-  auto iter =
-      std::find(known_buffer_ids_.begin(), known_buffer_ids_.end(), buffer_id);
-  CHECK(iter != known_buffer_ids_.end());
-  known_buffer_ids_.erase(iter);
-  DoOnBufferRetired(buffer_id);
 }
 
 }  // namespace video_capture
--- a/services/video_capture/public/cpp/mock_receiver.h	2019-05-01 01:22:57.000000000 +0300
+++ b/services/video_capture/public/cpp/mock_receiver.h	2019-05-17 18:53:38.020000000 +0300
@@ -5,13 +5,9 @@
 #ifndef SERVICES_VIDEO_CAPTURE_PUBLIC_CPP_MOCK_RECEIVER_H_
 #define SERVICES_VIDEO_CAPTURE_PUBLIC_CPP_MOCK_RECEIVER_H_
 
-#include <vector>
-
-#include "media/capture/mojom/video_capture_types.mojom.h"
 #include "media/mojo/interfaces/media_types.mojom.h"
 #include "mojo/public/cpp/bindings/binding.h"
 #include "services/video_capture/public/mojom/receiver.mojom.h"
-#include "services/video_capture/public/mojom/scoped_access_permission.mojom.h"
 #include "testing/gmock/include/gmock/gmock.h"
 
 namespace video_capture {
@@ -22,9 +18,6 @@
   explicit MockReceiver(mojom::ReceiverRequest request);
   ~MockReceiver() override;
 
-  void HoldAccessPermissions();
-  void ReleaseAccessPermissions();
-
   // Use forwarding method to work around gmock not supporting move-only types.
   void OnNewBuffer(int32_t buffer_id,
                    media::mojom::VideoBufferHandlePtr buffer_handle) override;
@@ -33,7 +26,6 @@
       int32_t frame_feedback_id,
       mojom::ScopedAccessPermissionPtr access_permission,
       media::mojom::VideoFrameInfoPtr frame_info) override;
-  void OnBufferRetired(int32_t buffer_id) override;
 
   MOCK_METHOD2(DoOnNewBuffer,
                void(int32_t, media::mojom::VideoBufferHandlePtr*));
@@ -42,19 +34,15 @@
                     int32_t frame_feedback_id,
                     mojom::ScopedAccessPermissionPtr*,
                     media::mojom::VideoFrameInfoPtr*));
-  MOCK_METHOD1(DoOnBufferRetired, void(int32_t));
+  MOCK_METHOD1(OnBufferRetired, void(int32_t));
   MOCK_METHOD1(OnError, void(media::VideoCaptureError));
   MOCK_METHOD1(OnFrameDropped, void(media::VideoCaptureFrameDropReason));
   MOCK_METHOD1(OnLog, void(const std::string&));
   MOCK_METHOD0(OnStarted, void());
   MOCK_METHOD0(OnStartedUsingGpuDecode, void());
-  MOCK_METHOD0(OnStopped, void());
 
  private:
   const mojo::Binding<mojom::Receiver> binding_;
-  std::vector<int32_t> known_buffer_ids_;
-  bool should_store_access_permissions_;
-  std::vector<mojom::ScopedAccessPermissionPtr> access_permissions_;
 };
 
 }  // namespace video_capture
--- a/services/video_capture/public/cpp/mock_video_source.h	2019-05-01 01:22:57.000000000 +0300
+++ b/services/video_capture/public/cpp/mock_video_source.h	2019-05-17 18:53:38.020000000 +0300
@@ -5,7 +5,6 @@
 #ifndef SERVICES_VIDEO_CAPTURE_PUBLIC_CPP_MOCK_VIDEO_SOURCE_H_
 #define SERVICES_VIDEO_CAPTURE_PUBLIC_CPP_MOCK_VIDEO_SOURCE_H_
 
-#include "services/video_capture/public/mojom/receiver.mojom.h"
 #include "services/video_capture/public/mojom/video_source.mojom.h"
 #include "testing/gmock/include/gmock/gmock.h"
 
--- a/services/video_capture/public/cpp/mock_video_source_provider.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/video_capture/public/cpp/mock_video_source_provider.cc	2019-05-17 18:53:38.020000000 +0300
@@ -34,8 +34,4 @@
   DoAddTextureVirtualDevice(device_info, &virtual_device);
 }
 
-void MockVideoSourceProvider::Close(CloseCallback callback) {
-  DoClose(callback);
-}
-
 }  // namespace video_capture
--- a/services/video_capture/public/cpp/mock_video_source_provider.h	2019-05-01 01:22:57.000000000 +0300
+++ b/services/video_capture/public/cpp/mock_video_source_provider.h	2019-05-17 18:53:38.020000000 +0300
@@ -5,8 +5,6 @@
 #ifndef SERVICES_VIDEO_CAPTURE_PUBLIC_CPP_MOCK_VIDEO_SOURCE_PROVIDER_H_
 #define SERVICES_VIDEO_CAPTURE_PUBLIC_CPP_MOCK_VIDEO_SOURCE_PROVIDER_H_
 
-#include "services/video_capture/public/mojom/devices_changed_observer.mojom.h"
-#include "services/video_capture/public/mojom/producer.mojom.h"
 #include "services/video_capture/public/mojom/video_source_provider.mojom.h"
 #include "testing/gmock/include/gmock/gmock.h"
 
@@ -34,13 +32,6 @@
   void AddTextureVirtualDevice(const media::VideoCaptureDeviceInfo& device_info,
                                video_capture::mojom::TextureVirtualDeviceRequest
                                    virtual_device) override;
-  void RegisterVirtualDevicesChangedObserver(
-      video_capture::mojom::DevicesChangedObserverPtr observer,
-      bool raise_event_if_virtual_devices_already_present) override {
-    NOTIMPLEMENTED();
-  }
-
-  void Close(CloseCallback callback) override;
 
   MOCK_METHOD1(DoGetSourceInfos, void(GetSourceInfosCallback& callback));
   MOCK_METHOD2(DoGetVideoSource,
@@ -55,7 +46,6 @@
       DoAddTextureVirtualDevice,
       void(const media::VideoCaptureDeviceInfo& device_info,
            video_capture::mojom::TextureVirtualDeviceRequest* virtual_device));
-  MOCK_METHOD1(DoClose, void(CloseCallback& callback));
 };
 
 }  // namespace video_capture
--- a/services/video_capture/public/cpp/receiver_media_to_mojo_adapter.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/video_capture/public/cpp/receiver_media_to_mojo_adapter.cc	2019-05-17 18:53:38.020000000 +0300
@@ -6,7 +6,6 @@
 
 #include "media/capture/video/shared_memory_handle_provider.h"
 #include "mojo/public/cpp/system/platform_handle.h"
-#include "services/video_capture/public/mojom/scoped_access_permission.mojom.h"
 
 namespace {
 
@@ -74,8 +73,4 @@
   receiver_->OnStartedUsingGpuDecode();
 }
 
-void ReceiverMediaToMojoAdapter::OnStopped() {
-  receiver_->OnStopped();
-}
-
 }  // namespace video_capture
--- a/services/video_capture/public/cpp/receiver_media_to_mojo_adapter.h	2019-05-01 01:22:57.000000000 +0300
+++ b/services/video_capture/public/cpp/receiver_media_to_mojo_adapter.h	2019-05-17 18:53:38.020000000 +0300
@@ -32,7 +32,6 @@
   void OnLog(const std::string& message) override;
   void OnStarted() override;
   void OnStartedUsingGpuDecode() override;
-  void OnStopped() override;
 
  private:
   std::unique_ptr<media::VideoFrameReceiver> receiver_;
--- a/services/video_capture/public/mojom/BUILD.gn	2019-05-01 01:22:57.000000000 +0300
+++ b/services/video_capture/public/mojom/BUILD.gn	2019-05-17 18:53:38.020000000 +0300
@@ -9,7 +9,6 @@
     "device.mojom",
     "device_factory.mojom",
     "device_factory_provider.mojom",
-    "devices_changed_observer.mojom",
     "producer.mojom",
     "receiver.mojom",
     "scoped_access_permission.mojom",
--- a/services/video_capture/public/mojom/device_factory.mojom	2019-05-01 01:22:57.000000000 +0300
+++ b/services/video_capture/public/mojom/device_factory.mojom	2019-05-17 18:53:38.020000000 +0300
@@ -6,7 +6,6 @@
 
 import "media/capture/mojom/video_capture_types.mojom";
 import "services/video_capture/public/mojom/device.mojom";
-import "services/video_capture/public/mojom/devices_changed_observer.mojom";
 import "services/video_capture/public/mojom/producer.mojom";
 import "services/video_capture/public/mojom/virtual_device.mojom";
 
@@ -16,6 +15,10 @@
   ERROR_DEVICE_NOT_FOUND
 };
 
+interface DevicesChangedObserver {
+  OnDevicesChanged();
+};
+
 // Enables access to a set of video capture devices.
 // Typical operation is to first call GetDeviceInfos() to obtain
 // information about available devices. The |device_id| of the infos can
--- a/services/video_capture/public/mojom/device_factory_provider.mojom	2019-05-01 01:22:57.000000000 +0300
+++ b/services/video_capture/public/mojom/device_factory_provider.mojom	2019-05-17 18:53:38.020000000 +0300
@@ -31,8 +31,4 @@
 
   // Current API. Supports multiple clients per source.
   ConnectToVideoSourceProvider(VideoSourceProvider& request);
-
-  // Lets the service to close all connections and ask the service_manager to be
-  // shut down.
-  ShutdownServiceAsap();
 };
--- a/services/video_capture/public/mojom/device.mojom	2019-05-01 01:22:57.000000000 +0300
+++ b/services/video_capture/public/mojom/device.mojom	2019-05-17 18:53:38.020000000 +0300
@@ -9,14 +9,14 @@
 import "services/video_capture/public/mojom/receiver.mojom";
 
 // Represents access to a video capture device available on the machine.
-// The device is stopped automatically when the message pipe corresponding to
-// either the Device or the given |receiver| is closed. Note that as a response
-// to stopping the device, the service may still need to send out events such as
-// Receiver.OnBufferRetired() to |receiver|. The service will send a final event
-// Receiver.OnStopped() to indicate that stopping has completed and no further
-// events are going to be sent to |receiver|.
+// Note: Instead of offering an explicit Stop() method, the device
+// is stopped automatically when the message pipe corresponding to either the
+// Device or the given |receiver| is closed.
 interface Device {
   Start(media.mojom.VideoCaptureParams requested_settings, Receiver receiver);
+  OnReceiverReportingUtilization(int32 frame_feedback_id,
+                                 double utilization);
+  RequestRefreshFrame();
   MaybeSuspend();
   Resume();
   GetPhotoState()
--- a/services/video_capture/public/mojom/receiver.mojom	2019-05-01 01:22:57.000000000 +0300
+++ b/services/video_capture/public/mojom/receiver.mojom	2019-05-17 18:53:38.020000000 +0300
@@ -20,5 +20,4 @@
   OnLog(string message);
   OnStarted();
   OnStartedUsingGpuDecode();
-  OnStopped();
 };
--- a/services/video_capture/public/mojom/video_source.mojom	2019-05-01 01:22:57.000000000 +0300
+++ b/services/video_capture/public/mojom/video_source.mojom	2019-05-17 18:53:38.020000000 +0300
@@ -24,11 +24,7 @@
   // pushed to |subscriber| in case the obtained settings are unacceptable.
   Activate();
 
-  // When suspended, the subscriber will no longer receive any calls to
-  // OnFrameReadyInBuffer() and OnFrameDropped(), but will still receive any
-  // other calls, e.g. OnNewBuffer() and OnBufferRetired().
-  // Callers may wait for the empty callback event to get notified when it is
-  // guaranteed that no more frames will be pushed.
+  // The callback event indicates that no more frames will be pushed.
   Suspend() => ();
 
   Resume();
--- a/services/video_capture/public/mojom/video_source_provider.mojom	2019-05-01 01:22:57.000000000 +0300
+++ b/services/video_capture/public/mojom/video_source_provider.mojom	2019-05-17 18:53:38.020000000 +0300
@@ -5,7 +5,6 @@
 module video_capture.mojom;
 
 import "media/capture/mojom/video_capture_types.mojom";
-import "services/video_capture/public/mojom/devices_changed_observer.mojom";
 import "services/video_capture/public/mojom/producer.mojom";
 import "services/video_capture/public/mojom/video_source.mojom";
 import "services/video_capture/public/mojom/virtual_device.mojom";
@@ -42,16 +41,4 @@
   AddTextureVirtualDevice(
       media.mojom.VideoCaptureDeviceInfo device_info,
       TextureVirtualDevice& virtual_device);
-
-  // Registered observers will get notified whenever a virtual device is added
-  // or removed. Note: Changes to non-virtual devices are currently being
-  // monitored outside the video capture service, and therefore the service
-  // does not offer such monitoring.
-  RegisterVirtualDevicesChangedObserver(
-      DevicesChangedObserver observer,
-      bool raise_event_if_virtual_devices_already_present);
-
-  // Closes the connection and allows clients to wait until the disconnect has
-  // arrived at the service.
-  Close() => ();
 };
--- a/services/video_capture/push_video_stream_subscription_impl.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/video_capture/push_video_stream_subscription_impl.cc	2019-05-17 18:53:38.020000000 +0300
@@ -4,8 +4,6 @@
 
 #include "services/video_capture/push_video_stream_subscription_impl.h"
 
-#include "base/bind.h"
-#include "base/bind_helpers.h"
 #include "services/video_capture/broadcasting_receiver.h"
 
 namespace video_capture {
@@ -40,12 +38,11 @@
                      weak_factory_.GetWeakPtr()));
 }
 
-void PushVideoStreamSubscriptionImpl::OnDeviceStartSucceededWithSettings(
+void PushVideoStreamSubscriptionImpl::
+    NotifySubscriberCreateSubscriptionSucceededWithSettings(
     const media::VideoCaptureParams& settings) {
-  if (status_ != Status::kCreationCallbackNotYetRun) {
-    // Creation callback has already been run from a previous device start.
-    return;
-  }
+  DCHECK_EQ(Status::kCreationCallbackNotYetRun, status_)
+      << "Illegal call in current state.";
   mojom::CreatePushSubscriptionResultCode result_code =
       settings == requested_settings_
           ? mojom::CreatePushSubscriptionResultCode::
@@ -56,11 +53,10 @@
   status_ = Status::kNotYetActivated;
 }
 
-void PushVideoStreamSubscriptionImpl::OnDeviceStartFailed() {
-  if (status_ != Status::kCreationCallbackNotYetRun) {
-    // Creation callback has already been run from a previous device start.
-    return;
-  }
+void PushVideoStreamSubscriptionImpl::
+    NotifySubscriberCreateSubscriptionFailed() {
+  DCHECK_EQ(Status::kCreationCallbackNotYetRun, status_)
+      << "Illegal call in current state.";
   std::move(creation_callback_)
       .Run(mojom::CreatePushSubscriptionResultCode::kFailed,
            requested_settings_);
@@ -70,8 +66,7 @@
 void PushVideoStreamSubscriptionImpl::Activate() {
   if (status_ != Status::kNotYetActivated)
     return;
-  broadcaster_client_id_ = broadcaster_->AddClient(
-      std::move(subscriber_), requested_settings_.buffer_type);
+  broadcaster_client_id_ = broadcaster_->AddClient(std::move(subscriber_));
   status_ = Status::kActive;
 }
 
@@ -79,7 +74,7 @@
   if (status_ != Status::kActive)
     return;
 
-  broadcaster_->SuspendClient(broadcaster_client_id_);
+  subscriber_ = broadcaster_->RemoveClient(broadcaster_client_id_);
   status_ = Status::kSuspended;
   std::move(callback).Run();
 }
@@ -87,7 +82,7 @@
 void PushVideoStreamSubscriptionImpl::Resume() {
   if (status_ != Status::kSuspended)
     return;
-  broadcaster_->ResumeClient(broadcaster_client_id_);
+  broadcaster_client_id_ = broadcaster_->AddClient(std::move(subscriber_));
   status_ = Status::kActive;
 }
 
@@ -142,14 +137,14 @@
     case Status::kClosed:
       std::move(callback).Run();
       return;
-    case Status::kActive:  // Fall through.
-    case Status::kSuspended:
+    case Status::kActive:
       broadcaster_->RemoveClient(broadcaster_client_id_);
       status_ = Status::kClosed;
       if (on_closed_handler_)
         std::move(on_closed_handler_).Run(std::move(callback));
       return;
-    case Status::kNotYetActivated:
+    case Status::kNotYetActivated:  // Fall through.
+    case Status::kSuspended:
       status_ = Status::kClosed;
       if (on_closed_handler_)
         std::move(on_closed_handler_).Run(std::move(callback));
--- a/services/video_capture/push_video_stream_subscription_impl.h	2019-05-01 01:22:57.000000000 +0300
+++ b/services/video_capture/push_video_stream_subscription_impl.h	2019-05-17 18:53:38.020000000 +0300
@@ -7,7 +7,6 @@
 
 #include "mojo/public/cpp/bindings/binding.h"
 #include "services/video_capture/public/mojom/device.mojom.h"
-#include "services/video_capture/public/mojom/receiver.mojom.h"
 #include "services/video_capture/public/mojom/video_source.mojom.h"
 
 namespace video_capture {
@@ -29,9 +28,9 @@
   void SetOnClosedHandler(
       base::OnceCallback<void(base::OnceClosure done_cb)> handler);
 
-  void OnDeviceStartSucceededWithSettings(
+  void NotifySubscriberCreateSubscriptionSucceededWithSettings(
       const media::VideoCaptureParams& settings);
-  void OnDeviceStartFailed();
+  void NotifySubscriberCreateSubscriptionFailed();
 
   // mojom::PushVideoStreamSubscription implementation.
   void Activate() override;
--- a/services/video_capture/receiver_mojo_to_media_adapter.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/video_capture/receiver_mojo_to_media_adapter.cc	2019-05-17 18:53:38.024000000 +0300
@@ -68,8 +68,4 @@
   receiver_->OnStartedUsingGpuDecode();
 }
 
-void ReceiverMojoToMediaAdapter::OnStopped() {
-  receiver_->OnStopped();
-}
-
 }  // namespace video_capture
--- a/services/video_capture/receiver_mojo_to_media_adapter.h	2019-05-01 01:22:57.000000000 +0300
+++ b/services/video_capture/receiver_mojo_to_media_adapter.h	2019-05-17 18:53:38.024000000 +0300
@@ -36,7 +36,6 @@
   void OnLog(const std::string& message) override;
   void OnStarted() override;
   void OnStartedUsingGpuDecode() override;
-  void OnStopped() override;
 
  private:
   mojom::ReceiverPtr receiver_;
--- a/services/video_capture/scoped_access_permission_media_to_mojo_adapter.h	2019-05-01 01:22:57.000000000 +0300
+++ b/services/video_capture/scoped_access_permission_media_to_mojo_adapter.h	2019-05-17 18:53:38.024000000 +0300
@@ -7,7 +7,6 @@
 
 #include "media/capture/video/video_capture_device_client.h"
 #include "services/video_capture/public/mojom/receiver.mojom.h"
-#include "services/video_capture/public/mojom/scoped_access_permission.mojom.h"
 
 namespace video_capture {
 
--- a/services/video_capture/service_impl.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/video_capture/service_impl.cc	2019-05-17 18:53:38.024000000 +0300
@@ -4,9 +4,6 @@
 
 #include "services/video_capture/service_impl.h"
 
-#include <utility>
-
-#include "base/bind.h"
 #include "build/build_config.h"
 #include "mojo/public/cpp/bindings/strong_binding.h"
 #include "services/video_capture/device_factory_provider_impl.h"
@@ -14,10 +11,6 @@
 #include "services/video_capture/public/uma/video_capture_service_event.h"
 #include "services/video_capture/testing_controls_impl.h"
 
-#if defined(OS_CHROMEOS)
-#include "media/capture/video/chromeos/mojo/cros_image_capture.mojom.h"
-#endif  // defined(OS_CHROMEOS)
-
 namespace video_capture {
 
 namespace {
@@ -79,10 +72,6 @@
   return keepalive_.HasNoRefs();
 }
 
-void ServiceImpl::ShutdownServiceAsap() {
-  binding_.RequestClose();
-}
-
 void ServiceImpl::OnStart() {
   DCHECK(thread_checker_.CalledOnValidThread());
 
@@ -98,11 +87,6 @@
       base::BindRepeating(&ServiceImpl::OnTestingControlsRequest,
                           base::Unretained(this)));
 
-#if defined(OS_CHROMEOS)
-  registry_.AddInterface<cros::mojom::CrosImageCapture>(base::BindRepeating(
-      &ServiceImpl::OnCrosImageCaptureRequest, base::Unretained(this)));
-#endif  // defined(OS_CHROMEOS)
-
   // Unretained |this| is safe because |factory_provider_bindings_| is owned by
   // |this|.
   factory_provider_bindings_.set_connection_error_handler(base::BindRepeating(
@@ -156,23 +140,12 @@
       std::move(request));
 }
 
-#if defined(OS_CHROMEOS)
-void ServiceImpl::OnCrosImageCaptureRequest(
-    cros::mojom::CrosImageCaptureRequest request) {
-  LazyInitializeDeviceFactoryProvider();
-  device_factory_provider_->BindCrosImageCaptureRequest(std::move(request));
-}
-#endif  // defined(OS_CHROMEOS)
-
 void ServiceImpl::LazyInitializeDeviceFactoryProvider() {
   if (device_factory_provider_)
     return;
 
-  // Use of base::Unretained() is safe because |this| owns, and therefore
-  // outlives |device_factory_provider_|
-  device_factory_provider_ = std::make_unique<DeviceFactoryProviderImpl>(
-      ui_task_runner_, base::BindOnce(&ServiceImpl::ShutdownServiceAsap,
-                                      base::Unretained(this)));
+  device_factory_provider_ =
+      std::make_unique<DeviceFactoryProviderImpl>(ui_task_runner_);
 }
 
 void ServiceImpl::OnProviderClientDisconnected() {
--- a/services/video_capture/service_impl.h	2019-05-01 01:22:57.000000000 +0300
+++ b/services/video_capture/service_impl.h	2019-05-17 18:53:38.024000000 +0300
@@ -24,10 +24,6 @@
 #include "base/win/scoped_com_initializer.h"
 #endif
 
-#if defined(OS_CHROMEOS)
-#include "media/capture/video/chromeos/mojo/cros_image_capture.mojom.h"
-#endif  // defined(OS_CHROMEOS)
-
 namespace base {
 class SingleThreadTaskRunner;
 }
@@ -55,8 +51,6 @@
   void SetShutdownTimeoutCancelledObserver(base::RepeatingClosure observer_cb);
   bool HasNoContextRefs();
 
-  void ShutdownServiceAsap();
-
   // service_manager::Service implementation.
   void OnStart() override;
   void OnBindInterface(const service_manager::BindSourceInfo& source_info,
@@ -72,9 +66,6 @@
   void OnDeviceFactoryProviderRequest(
       mojom::DeviceFactoryProviderRequest request);
   void OnTestingControlsRequest(mojom::TestingControlsRequest request);
-#if defined(OS_CHROMEOS)
-  void OnCrosImageCaptureRequest(cros::mojom::CrosImageCaptureRequest request);
-#endif  // defined(OS_CHROMEOS)
   void MaybeRequestQuitDelayed();
   void MaybeRequestQuit();
   void LazyInitializeDeviceFactoryProvider();
--- a/services/video_capture/shared_memory_virtual_device_mojo_adapter.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/video_capture/shared_memory_virtual_device_mojo_adapter.cc	2019-05-17 18:53:38.024000000 +0300
@@ -4,7 +4,6 @@
 
 #include "services/video_capture/shared_memory_virtual_device_mojo_adapter.h"
 
-#include "base/bind.h"
 #include "base/logging.h"
 #include "media/base/bind_to_current_loop.h"
 #include "media/capture/video/scoped_buffer_pool_reservation.h"
@@ -169,6 +168,16 @@
   }
 }
 
+void SharedMemoryVirtualDeviceMojoAdapter::OnReceiverReportingUtilization(
+    int32_t frame_feedback_id,
+    double utilization) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+}
+
+void SharedMemoryVirtualDeviceMojoAdapter::RequestRefreshFrame() {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+}
+
 void SharedMemoryVirtualDeviceMojoAdapter::MaybeSuspend() {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
 }
@@ -200,10 +209,6 @@
     return;
   // Unsubscribe from connection error callbacks.
   receiver_.set_connection_error_handler(base::OnceClosure());
-  // Send out OnBufferRetired events and OnStopped.
-  for (auto buffer_id : known_buffer_ids_)
-    receiver_->OnBufferRetired(buffer_id);
-  receiver_->OnStopped();
   receiver_.reset();
 }
 
--- a/services/video_capture/shared_memory_virtual_device_mojo_adapter.h	2019-05-01 01:22:57.000000000 +0300
+++ b/services/video_capture/shared_memory_virtual_device_mojo_adapter.h	2019-05-17 18:53:38.024000000 +0300
@@ -11,7 +11,6 @@
 #include "services/service_manager/public/cpp/service_context_ref.h"
 #include "services/video_capture/public/mojom/device.mojom.h"
 #include "services/video_capture/public/mojom/producer.mojom.h"
-#include "services/video_capture/public/mojom/receiver.mojom.h"
 #include "services/video_capture/public/mojom/virtual_device.mojom.h"
 
 namespace video_capture {
@@ -38,6 +37,9 @@
   // mojom::Device implementation.
   void Start(const media::VideoCaptureParams& requested_settings,
              mojom::ReceiverPtr receiver) override;
+  void OnReceiverReportingUtilization(int32_t frame_feedback_id,
+                                      double utilization) override;
+  void RequestRefreshFrame() override;
   void MaybeSuspend() override;
   void Resume() override;
   void GetPhotoState(GetPhotoStateCallback callback) override;
--- a/services/video_capture/test/device_factory_provider_connectortest.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/video_capture/test/device_factory_provider_connectortest.cc	2019-05-17 18:53:38.024000000 +0300
@@ -2,19 +2,15 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "base/bind.h"
 #include "base/command_line.h"
 #include "base/run_loop.h"
 #include "base/test/mock_callback.h"
 #include "base/test/scoped_task_environment.h"
-#include "base/timer/timer.h"
 #include "media/base/media_switches.h"
 #include "services/service_manager/public/cpp/test/test_connector_factory.h"
 #include "services/video_capture/public/cpp/mock_receiver.h"
 #include "services/video_capture/public/mojom/constants.mojom.h"
-#include "services/video_capture/public/mojom/device.mojom.h"
 #include "services/video_capture/public/mojom/device_factory_provider.mojom.h"
-#include "services/video_capture/public/mojom/video_source_provider.mojom.h"
 #include "services/video_capture/service_impl.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
@@ -128,9 +124,10 @@
 }
 
 // Tests that the service quits when the only client disconnects after not
-// having done anything other than obtaining a connection to the device factory.
+// having done anything other than obtaining a connection to the fake device
+// factory.
 TEST_F(ShortShutdownDelayDeviceFactoryProviderConnectorTest,
-       ServiceQuitsWhenSingleDeviceFactoryClientDisconnected) {
+       ServiceQuitsWhenSingleClientDisconnected) {
   mojom::DeviceFactoryPtr factory;
   factory_provider_->ConnectToDeviceFactory(mojo::MakeRequest(&factory));
   factory.reset();
@@ -139,84 +136,6 @@
   service_destroyed_wait_loop_.Run();
 }
 
-// Tests that the service quits when the only client disconnects after not
-// having done anything other than obtaining a connection to the video source
-// provider.
-TEST_F(ShortShutdownDelayDeviceFactoryProviderConnectorTest,
-       ServiceQuitsWhenSingleVideoSourceProviderClientDisconnected) {
-  mojom::VideoSourceProviderPtr source_provider;
-  factory_provider_->ConnectToVideoSourceProvider(
-      mojo::MakeRequest(&source_provider));
-  source_provider.reset();
-  factory_provider_.reset();
-
-  service_destroyed_wait_loop_.Run();
-}
-
-// Tests that the service quits when the only client disconnects after
-// enumerating devices via the video source provider.
-TEST_F(ShortShutdownDelayDeviceFactoryProviderConnectorTest,
-       ServiceQuitsAfterEnumeratingDevices) {
-  mojom::VideoSourceProviderPtr source_provider;
-  factory_provider_->ConnectToVideoSourceProvider(
-      mojo::MakeRequest(&source_provider));
-
-  base::RunLoop wait_loop;
-  EXPECT_CALL(device_info_receiver_, Run(_))
-      .WillOnce(
-          Invoke([&wait_loop](
-                     const std::vector<media::VideoCaptureDeviceInfo>& infos) {
-            wait_loop.Quit();
-          }));
-  source_provider->GetSourceInfos(device_info_receiver_.Get());
-  wait_loop.Run();
-
-  source_provider.reset();
-  factory_provider_.reset();
-
-  service_destroyed_wait_loop_.Run();
-}
-
-// Tests that enumerating devices works after the only client disconnects and
-// reconnects via the video source provider.
-TEST_F(ShortShutdownDelayDeviceFactoryProviderConnectorTest,
-       EnumerateDevicesAfterReconnect) {
-  // Connect |source_provider|.
-  mojom::VideoSourceProviderPtr source_provider;
-  factory_provider_->ConnectToVideoSourceProvider(
-      mojo::MakeRequest(&source_provider));
-
-  // Disconnect |source_provider| and wait for the disconnect to propagate to
-  // the service.
-  {
-    base::RunLoop wait_loop;
-    source_provider->Close(base::BindOnce(
-        [](base::RunLoop* wait_loop) { wait_loop->Quit(); }, &wait_loop));
-    wait_loop.Run();
-    source_provider.reset();
-  }
-
-  // Reconnect |source_provider|.
-  factory_provider_->ConnectToVideoSourceProvider(
-      mojo::MakeRequest(&source_provider));
-
-  // Enumerate devices.
-  base::RunLoop wait_loop;
-  EXPECT_CALL(device_info_receiver_, Run(_))
-      .WillOnce(
-          Invoke([&wait_loop](
-                     const std::vector<media::VideoCaptureDeviceInfo>& infos) {
-            wait_loop.Quit();
-          }));
-  source_provider->GetSourceInfos(device_info_receiver_.Get());
-  wait_loop.Run();
-
-  source_provider.reset();
-  factory_provider_.reset();
-
-  service_destroyed_wait_loop_.Run();
-}
-
 // Tests that the service quits when both of two clients disconnect.
 TEST_F(ShortShutdownDelayDeviceFactoryProviderConnectorTest,
        ServiceQuitsWhenAllClientsDisconnected) {
@@ -256,6 +175,8 @@
   factory_provider_->ConnectToDeviceFactory(mojo::MakeRequest(&factory));
 
   // Connect to and start first device (in this case a fake camera).
+  base::MockCallback<mojom::DeviceFactory::GetDeviceInfosCallback>
+      device_info_receiver_;
   media::VideoCaptureDeviceInfo fake_device_info;
   {
     base::RunLoop wait_loop;
@@ -328,40 +249,6 @@
     wait_loop.Run();
   }
 }
-
-// Tests that the service does not quit when the only client discards the
-// DeviceFactoryProvider but holds on to a VideoSourceProvider.
-TEST_F(ShortShutdownDelayDeviceFactoryProviderConnectorTest,
-       VideoSourceProviderCanStillBeUsedAfterReleaseingDeviceFactoryProvider) {
-  mojom::VideoSourceProviderPtr source_provider;
-  factory_provider_->ConnectToVideoSourceProvider(
-      mojo::MakeRequest(&source_provider));
-
-  // Exercise: Disconnect DeviceFactoryProvider
-  {
-    base::RunLoop wait_loop;
-    service_impl_->SetFactoryProviderClientDisconnectedObserver(
-        wait_loop.QuitClosure());
-    factory_provider_.reset();
-    wait_loop.Run();
-  }
-
-  EXPECT_FALSE(service_impl_->HasNoContextRefs());
-
-  // Verify that |source_provider| is still functional by calling
-  // GetDeviceInfos().
-  {
-    base::RunLoop wait_loop;
-    EXPECT_CALL(device_info_receiver_, Run(_))
-        .WillOnce(Invoke(
-            [&wait_loop](
-                const std::vector<media::VideoCaptureDeviceInfo>& infos) {
-              wait_loop.Quit();
-            }));
-    source_provider->GetSourceInfos(device_info_receiver_.Get());
-    wait_loop.Run();
-  }
-}
 
 struct NoAutomaticShutdownDeviceFactoryProviderConnectorTestTraits {
   static base::Optional<base::TimeDelta> shutdown_delay() {
--- a/services/video_capture/test/device_factory_provider_test.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/video_capture/test/device_factory_provider_test.cc	2019-05-17 18:53:38.024000000 +0300
@@ -6,17 +6,14 @@
 
 #include "base/command_line.h"
 #include "media/base/media_switches.h"
-#include "services/service_manager/public/cpp/manifest_builder.h"
 #include "services/service_manager/public/mojom/constants.mojom.h"
 #include "services/service_manager/public/mojom/service_manager.mojom.h"
-#include "services/video_capture/public/cpp/manifest.h"
 #include "services/video_capture/public/cpp/mock_producer.h"
 #include "services/video_capture/public/mojom/constants.mojom.h"
+#include "services/video_capture/tests_catalog_source.h"
 
 namespace video_capture {
 
-const char kTestServiceName[] = "video_capture_unittests";
-
 DeviceFactoryProviderTest::SharedMemoryVirtualDeviceContext::
     SharedMemoryVirtualDeviceContext(mojom::ProducerRequest producer_request)
     : mock_producer(
@@ -26,17 +23,10 @@
     ~SharedMemoryVirtualDeviceContext() = default;
 
 DeviceFactoryProviderTest::DeviceFactoryProviderTest()
-    : test_service_manager_(
-          {GetManifest(),
-           service_manager::ManifestBuilder()
-               .WithServiceName(kTestServiceName)
-               .RequireCapability(mojom::kServiceName, "tests")
-               .RequireCapability(service_manager::mojom::kServiceName,
-                                  "service_manager:service_manager")
-               .Build()}),
-      test_service_binding_(
-          &test_service_,
-          test_service_manager_.RegisterTestInstance(kTestServiceName)) {}
+    : test_service_manager_(CreateTestCatalog()),
+      test_service_binding_(&test_service_,
+                            test_service_manager_.RegisterTestInstance(
+                                "video_capture_unittests")) {}
 
 DeviceFactoryProviderTest::~DeviceFactoryProviderTest() = default;
 
--- a/services/video_capture/test/device_factory_provider_test.h	2019-05-01 01:22:57.000000000 +0300
+++ b/services/video_capture/test/device_factory_provider_test.h	2019-05-17 18:53:38.024000000 +0300
@@ -12,9 +12,7 @@
 #include "services/service_manager/public/cpp/service.h"
 #include "services/service_manager/public/cpp/service_binding.h"
 #include "services/service_manager/public/cpp/test/test_service_manager.h"
-#include "services/video_capture/public/mojom/device_factory.mojom.h"
 #include "services/video_capture/public/mojom/device_factory_provider.mojom.h"
-#include "services/video_capture/public/mojom/virtual_device.mojom.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
 namespace video_capture {
--- a/services/video_capture/test/device_factory_provider_unittest.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/video_capture/test/device_factory_provider_unittest.cc	2019-05-17 18:53:38.024000000 +0300
@@ -8,9 +8,7 @@
 #include "mojo/public/cpp/bindings/binding.h"
 #include "services/video_capture/public/cpp/mock_producer.h"
 #include "services/video_capture/public/mojom/constants.mojom.h"
-#include "services/video_capture/public/mojom/device.mojom.h"
 #include "services/video_capture/public/mojom/device_factory.mojom.h"
-#include "services/video_capture/public/mojom/virtual_device.mojom.h"
 #include "services/video_capture/test/device_factory_provider_test.h"
 #include "services/video_capture/test/mock_devices_changed_observer.h"
 
--- a/services/video_capture/test/fake_device_descriptor_unittest.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/video_capture/test/fake_device_descriptor_unittest.cc	2019-05-17 18:53:38.024000000 +0300
@@ -2,11 +2,9 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "base/bind.h"
 #include "base/bind_helpers.h"
 #include "base/run_loop.h"
 #include "services/video_capture/public/cpp/mock_receiver.h"
-#include "services/video_capture/public/mojom/device.mojom.h"
 #include "services/video_capture/test/fake_device_descriptor_test.h"
 
 using testing::_;
--- a/services/video_capture/test/fake_device_test.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/video_capture/test/fake_device_test.cc	2019-05-17 18:53:38.024000000 +0300
@@ -4,7 +4,6 @@
 
 #include "services/video_capture/test/fake_device_test.h"
 
-#include "base/bind.h"
 #include "base/run_loop.h"
 
 using testing::_;
--- a/services/video_capture/test/fake_device_test.h	2019-05-01 01:22:57.000000000 +0300
+++ b/services/video_capture/test/fake_device_test.h	2019-05-17 18:53:38.024000000 +0300
@@ -6,7 +6,6 @@
 #define SERVICES_VIDEO_CAPTURE_TEST_FAKE_DEVICE_TEST_H_
 
 #include "media/capture/video_capture_types.h"
-#include "services/video_capture/public/mojom/device.mojom.h"
 #include "services/video_capture/test/fake_device_descriptor_test.h"
 #include "testing/gmock/include/gmock/gmock.h"
 
--- a/services/video_capture/test/fake_device_unittest.cc	2019-05-17 17:45:42.588000000 +0300
+++ b/services/video_capture/test/fake_device_unittest.cc	2019-05-17 18:53:38.024000000 +0300
@@ -29,7 +29,7 @@
   base::RunLoop wait_loop;
   // Constants must be static as a workaround
   // for a MSVC++ bug about lambda captures, see the discussion at
-  // https://social.msdn.m1cr050ft.qjz9zk/Forums/SqlServer/4abf18bd-4ae4-4c72-ba3e-3b13e7909d5f
+  // https://social.msdn.microsoft.com/Forums/SqlServer/4abf18bd-4ae4-4c72-ba3e-3b13e7909d5f
   static const int kNumFramesToWaitFor = 3;
   int num_frames_arrived = 0;
   mojom::ReceiverPtr receiver_proxy;
@@ -54,7 +54,7 @@
   base::RunLoop wait_loop;
   // Constants must be static as a workaround
   // for a MSVC++ bug about lambda captures, see the discussion at
-  // https://social.msdn.m1cr050ft.qjz9zk/Forums/SqlServer/4abf18bd-4ae4-4c72-ba3e-3b13e7909d5f
+  // https://social.msdn.microsoft.com/Forums/SqlServer/4abf18bd-4ae4-4c72-ba3e-3b13e7909d5f
   static const int kNumFramesToWaitFor = 3;
   int num_frames_arrived = 0;
   mojom::ReceiverPtr receiver_proxy;
@@ -82,7 +82,7 @@
       DeviceMediaToMojoAdapter::max_buffer_pool_buffer_count();
   // Constants must be static as a workaround
   // for a MSVC++ bug about lambda captures, see the discussion at
-  // https://social.msdn.m1cr050ft.qjz9zk/Forums/SqlServer/4abf18bd-4ae4-4c72-ba3e-3b13e7909d5f
+  // https://social.msdn.microsoft.com/Forums/SqlServer/4abf18bd-4ae4-4c72-ba3e-3b13e7909d5f
   static const int kNumFramesToWaitFor = kMaxBufferPoolBuffers + 3;
   int num_buffers_created = 0;
   int num_frames_arrived = 0;
@@ -106,20 +106,20 @@
   ASSERT_LE(num_buffers_created, kMaxBufferPoolBuffers);
 }
 
-// Tests that when the device is stopped OnBufferRetired() events get sent out
-// to the receiver followed by OnStopped().
+// Tests that OnBufferRetired() events get sent out to the receiver when the
+// device is stopped.
 TEST_F(FakeVideoCaptureDeviceTest, BuffersGetRetiredWhenDeviceIsStopped) {
   base::RunLoop wait_for_frames_loop;
   static const int kNumFramesToWaitFor = 2;
-  std::vector<int32_t> known_buffer_ids;
+  std::vector<int32_t> received_buffer_ids;
   int num_frames_arrived = 0;
   mojom::ReceiverPtr receiver_proxy;
   MockReceiver receiver(mojo::MakeRequest(&receiver_proxy));
   EXPECT_CALL(receiver, DoOnNewBuffer(_, _))
       .WillRepeatedly(
-          Invoke([&known_buffer_ids](int32_t buffer_id,
+          Invoke([&received_buffer_ids](int32_t buffer_id,
                                      media::mojom::VideoBufferHandlePtr*) {
-            known_buffer_ids.push_back(buffer_id);
+            received_buffer_ids.push_back(buffer_id);
           }));
   EXPECT_CALL(receiver, DoOnFrameReadyInBuffer(_, _, _, _))
       .WillRepeatedly(
@@ -133,22 +133,23 @@
                                  std::move(receiver_proxy));
   wait_for_frames_loop.Run();
 
-  base::RunLoop wait_for_on_stopped_loop;
-  EXPECT_CALL(receiver, DoOnBufferRetired(_))
-      .WillRepeatedly(Invoke([&known_buffer_ids](int32_t buffer_id) {
-        auto iter = std::find(known_buffer_ids.begin(), known_buffer_ids.end(),
-                              buffer_id);
-        ASSERT_TRUE(iter != known_buffer_ids.end());
-        known_buffer_ids.erase(iter);
-      }));
-  EXPECT_CALL(receiver, OnStopped())
-      .WillOnce(Invoke(
-          [&wait_for_on_stopped_loop]() { wait_for_on_stopped_loop.Quit(); }));
+  base::RunLoop wait_for_buffers_retired_loop;
+  EXPECT_CALL(receiver, OnBufferRetired(_))
+      .WillRepeatedly(
+          Invoke([&received_buffer_ids,
+                  &wait_for_buffers_retired_loop](int32_t buffer_id) {
+            auto iter = std::find(received_buffer_ids.begin(),
+                                  received_buffer_ids.end(), buffer_id);
+            ASSERT_TRUE(iter != received_buffer_ids.end());
+            received_buffer_ids.erase(iter);
+            if (received_buffer_ids.empty()) {
+              wait_for_buffers_retired_loop.Quit();
+            }
+          }));
 
   // Stop the device
   i420_fake_device_proxy_.reset();
-  wait_for_on_stopped_loop.Run();
-  ASSERT_TRUE(known_buffer_ids.empty());
+  wait_for_buffers_retired_loop.Run();
 }
 
 // This requires platforms where base::SharedMemoryHandle is backed by a
--- a/services/video_capture/test/mock_devices_changed_observer.h	2019-05-01 01:22:57.000000000 +0300
+++ b/services/video_capture/test/mock_devices_changed_observer.h	2019-05-17 18:53:38.024000000 +0300
@@ -6,7 +6,6 @@
 #define SERVICES_VIDEO_CAPTURE_TEST_MOCK_DEVICES_CHANGED_OBSERVER_H_
 
 #include "services/video_capture/public/mojom/device_factory.mojom.h"
-#include "services/video_capture/public/mojom/devices_changed_observer.mojom.h"
 #include "testing/gmock/include/gmock/gmock.h"
 
 namespace video_capture {
--- a/services/video_capture/test/mock_device_shared_access_unittest.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/video_capture/test/mock_device_shared_access_unittest.cc	2019-05-17 18:53:38.024000000 +0300
@@ -2,8 +2,6 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "base/bind.h"
-#include "base/bind_helpers.h"
 #include "base/run_loop.h"
 #include "base/test/mock_callback.h"
 #include "base/test/scoped_task_environment.h"
@@ -14,10 +12,8 @@
 #include "media/capture/video/video_capture_system_impl.h"
 #include "services/service_manager/public/cpp/service_keepalive.h"
 #include "services/video_capture/device_factory_media_to_mojo_adapter.h"
-#include "services/video_capture/device_media_to_mojo_adapter.h"
 #include "services/video_capture/public/cpp/mock_receiver.h"
 #include "services/video_capture/public/mojom/device_factory_provider.mojom.h"
-#include "services/video_capture/public/mojom/video_source.mojom.h"
 #include "services/video_capture/video_source_provider_impl.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
@@ -25,7 +21,6 @@
 using testing::Invoke;
 using testing::InvokeWithoutArgs;
 using testing::Mock;
-using testing::SaveArg;
 
 namespace video_capture {
 
@@ -34,27 +29,26 @@
   MockDeviceSharedAccessTest()
       : mock_receiver_1_(mojo::MakeRequest(&receiver_1_)),
         mock_receiver_2_(mojo::MakeRequest(&receiver_2_)),
-        next_arbitrary_frame_feedback_id_(123),
-        service_keepalive_(nullptr, base::nullopt) {}
+        service_keepalive_(nullptr, base::nullopt),
+        next_arbitrary_frame_feedback_id_(123) {}
   ~MockDeviceSharedAccessTest() override {}
 
   void SetUp() override {
     auto mock_device_factory = std::make_unique<media::MockDeviceFactory>();
-    mock_device_factory_ = mock_device_factory.get();
     media::VideoCaptureDeviceDescriptor mock_descriptor;
     mock_descriptor.device_id = "MockDeviceId";
     mock_device_factory->AddMockDevice(&mock_device_, mock_descriptor);
 
     auto video_capture_system = std::make_unique<media::VideoCaptureSystemImpl>(
         std::move(mock_device_factory));
-    service_device_factory_ = std::make_unique<DeviceFactoryMediaToMojoAdapter>(
+    mock_device_factory_ = std::make_unique<DeviceFactoryMediaToMojoAdapter>(
         std::move(video_capture_system), base::DoNothing(),
         base::ThreadTaskRunnerHandle::Get());
-    service_device_factory_->SetServiceRef(service_keepalive_.CreateRef());
-    source_provider_ = std::make_unique<VideoSourceProviderImpl>(
-        service_device_factory_.get(), base::DoNothing());
+    source_provider_ =
+        std::make_unique<VideoSourceProviderImpl>(mock_device_factory_.get());
+    source_provider_->SetServiceRef(service_keepalive_.CreateRef());
 
-    // Obtain the mock device backed source from |source_provider_|.
+    // Obtain the mock device backed source from |sourcr_provider_|.
     base::MockCallback<mojom::DeviceFactory::GetDeviceInfosCallback>
         device_infos_receiver;
     base::RunLoop wait_loop;
@@ -100,40 +94,24 @@
   }
 
   void LetClient2ConnectWithRequestableSettingsAndExpectToGetThem() {
-    LetClient2ConnectWithRequestableSettings(
-        false /*force_reopen_with_new_settings*/,
-        mojom::CreatePushSubscriptionResultCode::kCreatedWithRequestedSettings);
-  }
-
-  void LetClient2ConnectWithRequestableSettings(
-      bool force_reopen_with_new_settings,
-      mojom::CreatePushSubscriptionResultCode expected_result_code) {
     base::RunLoop run_loop;
     source_->CreatePushSubscription(
         std::move(receiver_2_), requestable_settings_,
-        force_reopen_with_new_settings, mojo::MakeRequest(&subscription_2_),
+        false /*force_reopen_with_new_settings*/,
+        mojo::MakeRequest(&subscription_2_),
         base::BindOnce(
             [](base::RunLoop* run_loop,
                media::VideoCaptureParams* requested_settings,
-               mojom::CreatePushSubscriptionResultCode expected_result_code,
                mojom::CreatePushSubscriptionResultCode result_code,
                const media::VideoCaptureParams&
                    settings_source_was_opened_with) {
-              ASSERT_EQ(expected_result_code, result_code);
-              if (expected_result_code ==
-                  mojom::CreatePushSubscriptionResultCode::
-                      kCreatedWithRequestedSettings) {
+              ASSERT_EQ(mojom::CreatePushSubscriptionResultCode::
+                            kCreatedWithRequestedSettings,
+                        result_code);
                 ASSERT_EQ(*requested_settings, settings_source_was_opened_with);
-              }
-              if (expected_result_code ==
-                  mojom::CreatePushSubscriptionResultCode::
-                      kCreatedWithDifferentSettings) {
-                ASSERT_FALSE(*requested_settings ==
-                             settings_source_was_opened_with);
-              }
               run_loop->Quit();
             },
-            &run_loop, &requestable_settings_, expected_result_code));
+            &run_loop, &requestable_settings_));
     run_loop.Run();
   }
 
@@ -165,7 +143,7 @@
 
     auto different_settings = requestable_settings_;
     // Change something arbitrary
-    different_settings.requested_format.frame_size = gfx::Size(124, 456);
+    different_settings.requested_format.frame_size = gfx::Size(123, 456);
     ASSERT_FALSE(requestable_settings_ == different_settings);
 
     source_->CreatePushSubscription(
@@ -210,23 +188,6 @@
     Mock::VerifyAndClearExpectations(&mock_receiver_2_);
   }
 
-  void SendFrameAndExpectToArriveOnlyAtSubscriber1() {
-    const int32_t kArbitraryFrameFeedbackId =
-        next_arbitrary_frame_feedback_id_++;
-    const int32_t kArbitraryRotation = 0;
-
-    base::RunLoop wait_loop;
-    EXPECT_CALL(mock_receiver_1_,
-                DoOnFrameReadyInBuffer(_, kArbitraryFrameFeedbackId, _, _))
-        .WillOnce(InvokeWithoutArgs([&wait_loop]() { wait_loop.Quit(); }));
-    EXPECT_CALL(mock_receiver_2_, DoOnFrameReadyInBuffer(_, _, _, _)).Times(0);
-    mock_device_.SendStubFrame(requestable_settings_.requested_format,
-                               kArbitraryRotation, kArbitraryFrameFeedbackId);
-    wait_loop.Run();
-    Mock::VerifyAndClearExpectations(&mock_receiver_1_);
-    Mock::VerifyAndClearExpectations(&mock_receiver_2_);
-  }
-
   void SendFrameAndExpectToArriveOnlyAtSubscriber2() {
     const int32_t kArbitraryFrameFeedbackId =
         next_arbitrary_frame_feedback_id_++;
@@ -247,8 +208,7 @@
  protected:
   base::test::ScopedTaskEnvironment task_environment_;
   media::MockDevice mock_device_;
-  media::MockDeviceFactory* mock_device_factory_;
-  std::unique_ptr<DeviceFactoryMediaToMojoAdapter> service_device_factory_;
+  std::unique_ptr<DeviceFactoryMediaToMojoAdapter> mock_device_factory_;
   std::unique_ptr<VideoSourceProviderImpl> source_provider_;
   mojom::VideoSourcePtr source_;
   media::VideoCaptureParams requestable_settings_;
@@ -260,10 +220,9 @@
   mojom::ReceiverPtr receiver_2_;
   MockReceiver mock_receiver_2_;
 
-  int32_t next_arbitrary_frame_feedback_id_;
-
  private:
   service_manager::ServiceKeepalive service_keepalive_;
+  int32_t next_arbitrary_frame_feedback_id_;
 };
 
 // This alias ensures test output is easily attributed to this service's tests.
@@ -281,80 +240,6 @@
 }
 
 TEST_F(MockVideoCaptureDeviceSharedAccessTest,
-       SecondClientForcesReopenWithDifferentSettings) {
-  LetClient1ConnectWithRequestableSettingsAndExpectToGetThem();
-  subscription_1_->Activate();
-
-  auto previously_requested_settings = requestable_settings_;
-  // Change something arbitrary
-  requestable_settings_.requested_format.frame_size = gfx::Size(124, 456);
-  ASSERT_FALSE(requestable_settings_ == previously_requested_settings);
-
-  LetClient2ConnectWithRequestableSettings(
-      true /*force_reopen_with_new_settings*/,
-      mojom::CreatePushSubscriptionResultCode::kCreatedWithRequestedSettings);
-  subscription_2_->Activate();
-  SendFrameAndExpectToArriveAtBothSubscribers();
-}
-
-TEST_F(MockVideoCaptureDeviceSharedAccessTest,
-       SecondClientsForcesReopenWithSameSettings) {
-  LetClient1ConnectWithRequestableSettingsAndExpectToGetThem();
-  LetClient2ConnectWithRequestableSettings(
-      true /*force_reopen_with_new_settings*/,
-      mojom::CreatePushSubscriptionResultCode::kCreatedWithRequestedSettings);
-  subscription_1_->Activate();
-  subscription_2_->Activate();
-  SendFrameAndExpectToArriveAtBothSubscribers();
-}
-
-// Tests that existing buffers are retired but no OnStopped() and OnStarted()
-// event is sent to existing client when the device internally restarts because
-// a new client connects with |force_reopen_with_new_settings| set to true.
-TEST_F(MockVideoCaptureDeviceSharedAccessTest,
-       InternalDeviceRestartIsTransparentToExistingSubscribers) {
-  LetClient1ConnectWithRequestableSettingsAndExpectToGetThem();
-  EXPECT_CALL(mock_receiver_1_, DoOnNewBuffer(_, _)).Times(1);
-  EXPECT_CALL(mock_receiver_1_, OnStarted()).Times(1);
-  subscription_1_->Activate();
-  mock_device_.SendOnStarted();
-  SendFrameAndExpectToArriveOnlyAtSubscriber1();
-  Mock::VerifyAndClearExpectations(&mock_receiver_1_);
-
-  auto previously_requested_settings = requestable_settings_;
-  // Change something arbitrary
-  requestable_settings_.requested_format.frame_size = gfx::Size(124, 456);
-  ASSERT_FALSE(requestable_settings_ == previously_requested_settings);
-
-  {
-    testing::InSequence s;
-    EXPECT_CALL(mock_receiver_1_, DoOnBufferRetired(_)).Times(1);
-    EXPECT_CALL(mock_receiver_1_, DoOnNewBuffer(_, _)).Times(1);
-  }
-  EXPECT_CALL(mock_receiver_1_, OnStopped()).Times(0);
-  EXPECT_CALL(mock_receiver_1_, OnStarted()).Times(0);
-
-  LetClient2ConnectWithRequestableSettings(
-      true /*force_reopen_with_new_settings*/,
-      mojom::CreatePushSubscriptionResultCode::kCreatedWithRequestedSettings);
-  subscription_2_->Activate();
-
-  mock_device_.SendOnStarted();
-  SendFrameAndExpectToArriveAtBothSubscribers();
-  Mock::VerifyAndClearExpectations(&mock_receiver_1_);
-}
-
-TEST_F(MockVideoCaptureDeviceSharedAccessTest,
-       CreatingSubscriptionFailsWhenCreatingDeviceFails) {
-  // Make it so that attempts to open the mock device will fail.
-  mock_device_factory_->RemoveAllDevices();
-
-  LetClient2ConnectWithRequestableSettings(
-      false /*force_reopen_with_new_settings*/,
-      mojom::CreatePushSubscriptionResultCode::kFailed);
-}
-
-TEST_F(MockVideoCaptureDeviceSharedAccessTest,
        NoFramesArePushedUntilSubscriptionIsActivated) {
   LetTwoClientsConnectWithSameSettingsOneByOne();
 
@@ -431,38 +316,6 @@
   SendFrameAndExpectToArriveAtBothSubscribers();
 }
 
-TEST_F(MockVideoCaptureDeviceSharedAccessTest, SuspendAndResumeSingleClient) {
-  LetClient1ConnectWithRequestableSettingsAndExpectToGetThem();
-  subscription_1_->Activate();
-  {
-    base::RunLoop wait_loop;
-    subscription_1_->Suspend(base::BindOnce(
-        [](base::RunLoop* wait_loop) { wait_loop->Quit(); }, &wait_loop));
-    wait_loop.Run();
-  }
-  EXPECT_CALL(mock_receiver_1_, DoOnFrameReadyInBuffer(_, _, _, _)).Times(0);
-
-  // Send a couple of frames. We want to send at least as many frames as
-  // the maximum buffer count in the video frame pool to make sure that
-  // buffers are properly released and reused.
-  mock_device_.SendOnStarted();
-  for (int i = 0; i < DeviceMediaToMojoAdapter::max_buffer_pool_buffer_count();
-       i++) {
-    const int32_t kArbitraryRotation = 0;
-    const int32_t kArbitraryFrameFeedbackId =
-        next_arbitrary_frame_feedback_id_++;
-    mock_device_.SendStubFrame(requestable_settings_.requested_format,
-                               kArbitraryRotation, kArbitraryFrameFeedbackId);
-    // We need to wait until the frame has arrived at BroadcastingReceiver
-    base::RunLoop().RunUntilIdle();
-  }
-  Mock::VerifyAndClearExpectations(&mock_receiver_1_);
-
-  subscription_1_->Resume();
-  subscription_1_.FlushForTesting();
-  SendFrameAndExpectToArriveOnlyAtSubscriber1();
-}
-
 TEST_F(MockVideoCaptureDeviceSharedAccessTest,
        CreateNewSubscriptionAfterClosingExistingOneUsesNewSettings) {
   LetClient1ConnectWithRequestableSettingsAndExpectToGetThem();
--- a/services/video_capture/test/mock_device_test.h	2019-05-01 01:22:57.000000000 +0300
+++ b/services/video_capture/test/mock_device_test.h	2019-05-17 18:53:38.024000000 +0300
@@ -12,7 +12,6 @@
 #include "services/service_manager/public/cpp/service_keepalive.h"
 #include "services/video_capture/device_factory_media_to_mojo_adapter.h"
 #include "services/video_capture/public/cpp/mock_receiver.h"
-#include "services/video_capture/public/mojom/device.mojom.h"
 #include "services/video_capture/public/mojom/device_factory_provider.mojom.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
--- a/services/video_capture/test/mock_device_unittest.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/video_capture/test/mock_device_unittest.cc	2019-05-17 18:53:38.024000000 +0300
@@ -59,4 +59,43 @@
   }
 }
 
+// Tests that a utilization reported to a video_capture.mojom.Device via
+// OnReceiverReportingUtilization() arrives at the corresponding
+// media::VideoCaptureDevice.
+TEST_F(MockVideoCaptureDeviceTest, ReceiverUtilizationIsForwardedToDevice) {
+  base::RunLoop run_loop;
+  const media::VideoCaptureFormat stub_frame_format(gfx::Size(320, 200), 25.0f,
+                                                    media::PIXEL_FORMAT_I420);
+  const int arbitrary_rotation = 0;
+  const int arbitrary_frame_feedback_id = 654;
+  const double arbitrary_utilization = 0.12345;
+
+  EXPECT_CALL(*mock_receiver_, DoOnFrameReadyInBuffer(_, _, _, _))
+      .WillOnce(Invoke([this, &arbitrary_utilization](
+                           int32_t buffer_id, int32_t frame_feedback_id,
+                           mojom::ScopedAccessPermissionPtr*,
+                           media::mojom::VideoFrameInfoPtr*) {
+        device_proxy_->OnReceiverReportingUtilization(frame_feedback_id,
+                                                      arbitrary_utilization);
+      }));
+
+  EXPECT_CALL(mock_device_, OnUtilizationReport(arbitrary_frame_feedback_id,
+                                                arbitrary_utilization))
+      .Times(1);
+
+  device_proxy_->Start(requested_settings_, std::move(mock_receiver_proxy_));
+  run_loop.RunUntilIdle();
+
+  // Simulate device sending a frame, which should trigger |mock_receiver|
+  // DoOnFrameReadyInBuffer() getting called.
+  base::RunLoop run_loop_2;
+  mock_device_.SendStubFrame(stub_frame_format, arbitrary_rotation,
+                             arbitrary_frame_feedback_id);
+  run_loop_2.RunUntilIdle();
+
+  base::RunLoop run_loop_3;
+  mock_receiver_.reset();
+  run_loop_3.RunUntilIdle();
+}
+
 }  // namespace video_capture
--- a/services/video_capture/test/virtual_device_unittest.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/video_capture/test/virtual_device_unittest.cc	2019-05-17 18:53:38.024000000 +0300
@@ -2,7 +2,6 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "base/bind.h"
 #include "base/memory/ref_counted.h"
 #include "base/message_loop/message_loop.h"
 #include "base/run_loop.h"
@@ -165,21 +164,6 @@
   device_adapter_->RequestFrameBuffer(kTestFrameSize, kTestPixelFormat, nullptr,
                                       request_frame_buffer_callback.Get());
   wait_loop2.RunUntilIdle();
-
-  // Verify that when stopping the device, the receiver receives calls to
-  // OnBufferRetired() followed by a single call to OnStopped().
-  base::RunLoop wait_for_stopped_loop;
-  {
-    testing::InSequence s;
-    EXPECT_CALL(receiver, DoOnBufferRetired(_))
-        .Times(SharedMemoryVirtualDeviceMojoAdapter::
-                   max_buffer_pool_buffer_count());
-    EXPECT_CALL(receiver, OnStopped())
-        .WillOnce(Invoke(
-            [&wait_for_stopped_loop]() { wait_for_stopped_loop.Quit(); }));
-  }
-  device_adapter_->Stop();
-  wait_for_stopped_loop.Run();
 }
 
 }  // namespace video_capture
--- a/services/video_capture/texture_virtual_device_mojo_adapter.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/video_capture/texture_virtual_device_mojo_adapter.cc	2019-05-17 18:53:38.024000000 +0300
@@ -4,14 +4,12 @@
 
 #include "services/video_capture/texture_virtual_device_mojo_adapter.h"
 
-#include "base/bind.h"
 #include "base/logging.h"
 #include "base/memory/ptr_util.h"
 #include "media/base/bind_to_current_loop.h"
 #include "mojo/public/cpp/bindings/callback_helpers.h"
 #include "mojo/public/cpp/bindings/strong_binding.h"
 #include "services/video_capture/public/mojom/constants.mojom.h"
-#include "services/video_capture/public/mojom/scoped_access_permission.mojom.h"
 
 namespace video_capture {
 
@@ -85,6 +83,16 @@
   }
 }
 
+void TextureVirtualDeviceMojoAdapter::OnReceiverReportingUtilization(
+    int32_t frame_feedback_id,
+    double utilization) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+}
+
+void TextureVirtualDeviceMojoAdapter::RequestRefreshFrame() {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+}
+
 void TextureVirtualDeviceMojoAdapter::MaybeSuspend() {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
 }
@@ -115,10 +123,6 @@
     return;
   // Unsubscribe from connection error callbacks.
   receiver_.set_connection_error_handler(base::OnceClosure());
-  // Send out OnBufferRetired events and OnStopped.
-  for (const auto& entry : known_buffer_handles_)
-    receiver_->OnBufferRetired(entry.first);
-  receiver_->OnStopped();
   receiver_.reset();
 }
 
--- a/services/video_capture/texture_virtual_device_mojo_adapter.h	2019-05-01 01:22:57.000000000 +0300
+++ b/services/video_capture/texture_virtual_device_mojo_adapter.h	2019-05-17 18:53:38.024000000 +0300
@@ -11,7 +11,6 @@
 #include "services/service_manager/public/cpp/service_context_ref.h"
 #include "services/video_capture/public/mojom/device.mojom.h"
 #include "services/video_capture/public/mojom/producer.mojom.h"
-#include "services/video_capture/public/mojom/receiver.mojom.h"
 #include "services/video_capture/public/mojom/virtual_device.mojom.h"
 
 namespace video_capture {
@@ -38,6 +37,9 @@
   // mojom::Device implementation.
   void Start(const media::VideoCaptureParams& requested_settings,
              mojom::ReceiverPtr receiver) override;
+  void OnReceiverReportingUtilization(int32_t frame_feedback_id,
+                                      double utilization) override;
+  void RequestRefreshFrame() override;
   void MaybeSuspend() override;
   void Resume() override;
   void GetPhotoState(GetPhotoStateCallback callback) override;
--- a/services/video_capture/video_source_impl.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/video_capture/video_source_impl.cc	2019-05-17 18:53:38.024000000 +0300
@@ -4,8 +4,6 @@
 
 #include "services/video_capture/video_source_impl.h"
 
-#include "base/bind.h"
-#include "base/bind_helpers.h"
 #include "services/video_capture/push_video_stream_subscription_impl.h"
 
 namespace video_capture {
@@ -18,20 +16,16 @@
       device_id_(device_id),
       on_last_binding_closed_cb_(std::move(on_last_binding_closed_cb)),
       device_status_(DeviceStatus::kNotStarted),
-      restart_device_once_when_stop_complete_(false),
       weak_factory_(this) {
-  // Unretained(this) is safe because |this| owns |bindings_|.
   bindings_.set_connection_error_handler(base::BindRepeating(
       &VideoSourceImpl::OnClientDisconnected, base::Unretained(this)));
 }
 
 VideoSourceImpl::~VideoSourceImpl() {
-  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
   bindings_.set_connection_error_handler(base::DoNothing());
 }
 
 void VideoSourceImpl::AddToBindingSet(mojom::VideoSourceRequest request) {
-  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
   bindings_.AddBinding(this, std::move(request));
 }
 
@@ -41,7 +35,10 @@
     bool force_reopen_with_new_settings,
     mojom::PushVideoStreamSubscriptionRequest subscription_request,
     CreatePushSubscriptionCallback callback) {
-  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  if (force_reopen_with_new_settings) {
+    NOTIMPLEMENTED();
+    return;
+  }
   auto subscription = std::make_unique<PushVideoStreamSubscriptionImpl>(
       std::move(subscription_request), std::move(subscriber),
       requested_settings, std::move(callback), &broadcaster_, &device_);
@@ -53,34 +50,25 @@
       std::make_pair(subscription.get(), std::move(subscription)));
   switch (device_status_) {
     case DeviceStatus::kNotStarted:
-      StartDeviceWithSettings(requested_settings);
+      device_start_settings_ = requested_settings;
+      device_status_ = DeviceStatus::kStartingAsynchronously;
+      device_factory_->CreateDevice(
+          device_id_, mojo::MakeRequest(&device_),
+          base::BindOnce(&VideoSourceImpl::OnCreateDeviceResponse,
+                         weak_factory_.GetWeakPtr()));
       return;
     case DeviceStatus::kStartingAsynchronously:
-      if (force_reopen_with_new_settings)
-        device_start_settings_ = requested_settings;
-      // No need to do anything else. Response will be sent when
+      // No need to do anything. Response will be sent when
       // OnCreateDeviceResponse() gets called.
       return;
     case DeviceStatus::kStarted:
-      if (!force_reopen_with_new_settings ||
-          requested_settings == device_start_settings_) {
-        subscription_ptr->OnDeviceStartSucceededWithSettings(
+      subscription_ptr->NotifySubscriberCreateSubscriptionSucceededWithSettings(
             device_start_settings_);
         return;
       }
-      restart_device_once_when_stop_complete_ = true;
-      device_start_settings_ = requested_settings;
-      StopDeviceAsynchronously();
-      return;
-    case DeviceStatus::kStoppingAsynchronously:
-      restart_device_once_when_stop_complete_ = true;
-      device_start_settings_ = requested_settings;
-      return;
-  }
 }
 
 void VideoSourceImpl::OnClientDisconnected() {
-  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
   if (bindings_.empty()) {
     // Note: Invoking this callback may synchronously trigger the destruction of
     // |this|, so no more member access should be done after it.
@@ -88,20 +76,8 @@
   }
 }
 
-void VideoSourceImpl::StartDeviceWithSettings(
-    const media::VideoCaptureParams& requested_settings) {
-  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
-  device_start_settings_ = requested_settings;
-  device_status_ = DeviceStatus::kStartingAsynchronously;
-  device_factory_->CreateDevice(
-      device_id_, mojo::MakeRequest(&device_),
-      base::BindOnce(&VideoSourceImpl::OnCreateDeviceResponse,
-                     weak_factory_.GetWeakPtr()));
-}
-
 void VideoSourceImpl::OnCreateDeviceResponse(
     mojom::DeviceAccessResultCode result_code) {
-  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
   switch (result_code) {
     case mojom::DeviceAccessResultCode::SUCCESS: {
       mojom::ReceiverPtr broadcaster_as_receiver;
@@ -111,12 +87,12 @@
                      std::move(broadcaster_as_receiver));
       device_status_ = DeviceStatus::kStarted;
       if (push_subscriptions_.empty()) {
-        StopDeviceAsynchronously();
+        StopDevice();
         return;
       }
       for (auto& entry : push_subscriptions_) {
         auto& subscription = entry.second;
-        subscription->OnDeviceStartSucceededWithSettings(
+        subscription->NotifySubscriberCreateSubscriptionSucceededWithSettings(
             device_start_settings_);
       }
       return;
@@ -125,7 +101,7 @@
     case mojom::DeviceAccessResultCode::NOT_INITIALIZED:
       for (auto& entry : push_subscriptions_) {
         auto& subscription = entry.second;
-        subscription->OnDeviceStartFailed();
+        subscription->NotifySubscriberCreateSubscriptionFailed();
       }
       push_subscriptions_.clear();
       device_status_ = DeviceStatus::kNotStarted;
@@ -136,7 +112,6 @@
 void VideoSourceImpl::OnPushSubscriptionClosedOrDisconnectedOrDiscarded(
     PushVideoStreamSubscriptionImpl* subscription,
     base::OnceClosure done_cb) {
-  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
   // We keep the subscription instance alive until after having called |done_cb|
   // in order to allow it to send out a callback before being destroyed.
   auto subscription_ownership = std::move(push_subscriptions_[subscription]);
@@ -151,45 +126,16 @@
         // are any subscriptions.
         break;
       case DeviceStatus::kStarted:
-        StopDeviceAsynchronously();
-        break;
-      case DeviceStatus::kStoppingAsynchronously:
-        // Nothing to do here.
+        StopDevice();
         break;
     }
   }
   std::move(done_cb).Run();
 }
 
-void VideoSourceImpl::StopDeviceAsynchronously() {
-  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
-  if (restart_device_once_when_stop_complete_) {
-    // We do not want to send out OnStopped() or OnStarted() to already
-    // connected clients, to make this internal restart transparent to them.
-    // The broadcaster already drops additional OnStarted() events for clients
-    // who already received one. But for OnStopped() we need to explicitly tell
-    // it to.
-    // Unretained(this) is safe because |this| owns |broadcaster_|.
-    broadcaster_.HideSourceRestartFromClients(base::BindOnce(
-        &VideoSourceImpl::OnStopDeviceComplete, base::Unretained(this)));
-  } else {
-    broadcaster_.SetOnStoppedHandler(base::BindOnce(
-        &VideoSourceImpl::OnStopDeviceComplete, base::Unretained(this)));
-  }
-
-  // Stop the device by closing the connection to it. Stopping is complete when
-  // OnStopDeviceComplete() gets invoked.
+void VideoSourceImpl::StopDevice() {
   device_.reset();
-  device_status_ = DeviceStatus::kStoppingAsynchronously;
-}
-
-void VideoSourceImpl::OnStopDeviceComplete() {
-  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
   device_status_ = DeviceStatus::kNotStarted;
-  if (!restart_device_once_when_stop_complete_)
-    return;
-  restart_device_once_when_stop_complete_ = false;
-  StartDeviceWithSettings(device_start_settings_);
 }
 
 }  // namespace video_capture
--- a/services/video_capture/video_source_impl.h	2019-05-01 01:22:57.000000000 +0300
+++ b/services/video_capture/video_source_impl.h	2019-05-17 18:53:38.024000000 +0300
@@ -12,8 +12,6 @@
 #include "mojo/public/cpp/bindings/binding_set.h"
 #include "services/video_capture/broadcasting_receiver.h"
 #include "services/video_capture/device_factory_media_to_mojo_adapter.h"
-#include "services/video_capture/public/mojom/device.mojom.h"
-#include "services/video_capture/public/mojom/video_source.mojom.h"
 #include "services/video_capture/public/mojom/video_source_provider.mojom.h"
 
 namespace video_capture {
@@ -42,18 +40,14 @@
     kNotStarted,
     kStartingAsynchronously,
     kStarted,
-    kStoppingAsynchronously
   };
 
   void OnClientDisconnected();
-  void StartDeviceWithSettings(
-      const media::VideoCaptureParams& requested_settings);
   void OnCreateDeviceResponse(mojom::DeviceAccessResultCode result_code);
   void OnPushSubscriptionClosedOrDisconnectedOrDiscarded(
       PushVideoStreamSubscriptionImpl* subscription,
       base::OnceClosure done_cb);
-  void StopDeviceAsynchronously();
-  void OnStopDeviceComplete();
+  void StopDevice();
 
   mojom::DeviceFactory* const device_factory_;
   const std::string device_id_;
@@ -69,9 +63,6 @@
   DeviceStatus device_status_;
   mojom::DevicePtr device_;
   media::VideoCaptureParams device_start_settings_;
-  bool restart_device_once_when_stop_complete_;
-
-  SEQUENCE_CHECKER(sequence_checker_);
 
   base::WeakPtrFactory<VideoSourceImpl> weak_factory_;
 
--- a/services/video_capture/video_source_provider_impl.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/video_capture/video_source_provider_impl.cc	2019-05-17 18:53:38.024000000 +0300
@@ -4,30 +4,23 @@
 
 #include "services/video_capture/video_source_provider_impl.h"
 
-#include "base/bind.h"
-#include "services/video_capture/public/mojom/producer.mojom.h"
 #include "services/video_capture/video_source_impl.h"
 #include "services/video_capture/virtual_device_enabled_device_factory.h"
 
 namespace video_capture {
 
-VideoSourceProviderImpl::VideoSourceProviderImpl(
-    DeviceFactory* device_factory,
-    base::RepeatingClosure on_last_client_disconnected_cb)
-    : device_factory_(device_factory),
-      on_last_client_disconnected_cb_(
-          std::move(on_last_client_disconnected_cb)) {
-  // Unretained |this| is safe because |bindings_| is owned by |this|.
-  bindings_.set_connection_error_handler(base::BindRepeating(
-      &VideoSourceProviderImpl::OnClientDisconnected, base::Unretained(this)));
-}
+VideoSourceProviderImpl::VideoSourceProviderImpl(DeviceFactory* device_factory)
+    : device_factory_(device_factory) {}
 
 VideoSourceProviderImpl::~VideoSourceProviderImpl() = default;
 
-void VideoSourceProviderImpl::AddClient(
-    mojom::VideoSourceProviderRequest request) {
-  bindings_.AddBinding(this, std::move(request));
-  client_count_++;
+void VideoSourceProviderImpl::SetServiceRef(
+    std::unique_ptr<service_manager::ServiceContextRef> service_ref) {
+  if (service_ref)
+    device_factory_->SetServiceRef(service_ref->Clone());
+  else
+    device_factory_->SetServiceRef(nullptr);
+  service_ref_ = std::move(service_ref);
 }
 
 void VideoSourceProviderImpl::GetSourceInfos(GetSourceInfosCallback callback) {
@@ -69,39 +62,6 @@
                                            std::move(virtual_device));
 }
 
-void VideoSourceProviderImpl::RegisterVirtualDevicesChangedObserver(
-    mojom::DevicesChangedObserverPtr observer,
-    bool raise_event_if_virtual_devices_already_present) {
-  device_factory_->RegisterVirtualDevicesChangedObserver(
-      std::move(observer), raise_event_if_virtual_devices_already_present);
-}
-
-void VideoSourceProviderImpl::Close(CloseCallback callback) {
-  closed_but_not_yet_disconnected_client_count_++;
-  // |callback must be run before OnClientDisconnectedOrClosed(), because if the
-  // latter leads to the destruction of |this|, the message pipe to the client
-  // gets severed, and the callback never makes it through.
-  std::move(callback).Run();
-  OnClientDisconnectedOrClosed();
-}
-
-void VideoSourceProviderImpl::OnClientDisconnected() {
-  if (closed_but_not_yet_disconnected_client_count_ > 0) {
-    closed_but_not_yet_disconnected_client_count_--;
-    return;
-  }
-  OnClientDisconnectedOrClosed();
-}
-
-void VideoSourceProviderImpl::OnClientDisconnectedOrClosed() {
-  client_count_--;
-  if (client_count_ == 0) {
-    // No member access allowed after this call, because it may lead to the
-    // destruction of |this|.
-    on_last_client_disconnected_cb_.Run();
-  }
-}
-
 void VideoSourceProviderImpl::OnVideoSourceLastClientDisconnected(
     const std::string& device_id) {
   sources_.erase(device_id);
--- a/services/video_capture/video_source_provider_impl.h	2019-05-01 01:22:57.000000000 +0300
+++ b/services/video_capture/video_source_provider_impl.h	2019-05-17 18:53:38.024000000 +0300
@@ -7,7 +7,6 @@
 
 #include <map>
 
-#include "mojo/public/cpp/bindings/binding_set.h"
 #include "services/video_capture/device_factory.h"
 #include "services/video_capture/public/mojom/video_source_provider.mojom.h"
 
@@ -17,12 +16,11 @@
 
 class VideoSourceProviderImpl : public mojom::VideoSourceProvider {
  public:
-  VideoSourceProviderImpl(
-      DeviceFactory* device_factory,
-      base::RepeatingClosure on_last_client_disconnected_cb);
+  explicit VideoSourceProviderImpl(DeviceFactory* device_factory);
   ~VideoSourceProviderImpl() override;
 
-  void AddClient(mojom::VideoSourceProviderRequest request);
+  void SetServiceRef(
+      std::unique_ptr<service_manager::ServiceContextRef> service_ref);
 
   // mojom::VideoSourceProvider implementation.
   void GetSourceInfos(GetSourceInfosCallback callback) override;
@@ -36,21 +34,11 @@
   void AddTextureVirtualDevice(
       const media::VideoCaptureDeviceInfo& device_info,
       mojom::TextureVirtualDeviceRequest virtual_device) override;
-  void RegisterVirtualDevicesChangedObserver(
-      mojom::DevicesChangedObserverPtr observer,
-      bool raise_event_if_virtual_devices_already_present) override;
-  void Close(CloseCallback callback) override;
 
  private:
-  void OnClientDisconnected();
-  void OnClientDisconnectedOrClosed();
   void OnVideoSourceLastClientDisconnected(const std::string& device_id);
 
   DeviceFactory* const device_factory_;
-  base::RepeatingClosure on_last_client_disconnected_cb_;
-  int client_count_ = 0;
-  int closed_but_not_yet_disconnected_client_count_ = 0;
-  mojo::BindingSet<mojom::VideoSourceProvider> bindings_;
   std::unique_ptr<service_manager::ServiceContextRef> service_ref_;
   std::map<std::string, std::unique_ptr<VideoSourceImpl>> sources_;
   DISALLOW_COPY_AND_ASSIGN(VideoSourceProviderImpl);
--- a/services/video_capture/virtual_device_enabled_device_factory.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/video_capture/virtual_device_enabled_device_factory.cc	2019-05-17 18:53:38.024000000 +0300
@@ -4,7 +4,6 @@
 
 #include "services/video_capture/virtual_device_enabled_device_factory.h"
 
-#include "base/bind.h"
 #include "base/logging.h"
 #include "media/capture/video/video_capture_device_info.h"
 #include "services/video_capture/device_factory.h"
@@ -253,13 +252,4 @@
   devices_changed_observers_.erase(iter);
 }
 
-#if defined(OS_CHROMEOS)
-void VirtualDeviceEnabledDeviceFactory::BindCrosImageCaptureRequest(
-    cros::mojom::CrosImageCaptureRequest request) {
-  CHECK(device_factory_);
-
-  device_factory_->BindCrosImageCaptureRequest(std::move(request));
-}
-#endif  // defined(OS_CHROMEOS)
-
 }  // namespace video_capture
--- a/services/video_capture/virtual_device_enabled_device_factory.h	2019-05-01 01:22:57.000000000 +0300
+++ b/services/video_capture/virtual_device_enabled_device_factory.h	2019-05-17 18:53:38.024000000 +0300
@@ -6,19 +6,13 @@
 #define SERVICES_VIDEO_CAPTURE_VIRTUAL_DEVICE_ENABLED_DEVICE_FACTORY_H_
 
 #include <map>
-#include <utility>
 
 #include "mojo/public/cpp/bindings/binding.h"
 #include "services/service_manager/public/cpp/service_context_ref.h"
 #include "services/video_capture/device_factory.h"
 #include "services/video_capture/public/mojom/device.mojom.h"
-#include "services/video_capture/public/mojom/devices_changed_observer.mojom.h"
 #include "services/video_capture/public/mojom/virtual_device.mojom.h"
 
-#if defined(OS_CHROMEOS)
-#include "media/capture/video/chromeos/mojo/cros_image_capture.mojom.h"
-#endif  // defined(OS_CHROMEOS)
-
 namespace video_capture {
 
 // Decorator that adds support for virtual devices to a given DeviceFactory.
@@ -47,11 +41,6 @@
       mojom::DevicesChangedObserverPtr observer,
       bool raise_event_if_virtual_devices_already_present) override;
 
-#if defined(OS_CHROMEOS)
-  void BindCrosImageCaptureRequest(
-      cros::mojom::CrosImageCaptureRequest request) override;
-#endif  // defined(OS_CHROMEOS)
-
  private:
   class VirtualDeviceEntry;
 
--- a/services/viz/BUILD.gn	2019-05-01 01:22:57.000000000 +0300
+++ b/services/viz/BUILD.gn	2019-05-17 18:53:38.024000000 +0300
@@ -3,6 +3,7 @@
 # found in the LICENSE file.
 
 import("//services/service_manager/public/cpp/service_executable.gni")
+import("//services/service_manager/public/service_manifest.gni")
 
 service_executable("viz") {
   sources = [
@@ -36,3 +37,8 @@
     "//components/viz/service/main",
   ]
 }
+
+service_manifest("manifest") {
+  name = "viz"
+  source = "manifest.json"
+}
--- a/services/viz/OWNERS	2019-05-01 01:22:57.000000000 +0300
+++ b/services/viz/OWNERS	2019-05-17 18:53:38.024000000 +0300
@@ -1 +1,5 @@
 file://components/viz/OWNERS
+per-file manifest.json=set noparent
+per-file manifest.json=file://ipc/SECURITY_OWNERS
+per-file test_manifest.json=set noparent
+per-file test_manifest.json=file://ipc/SECURITY_OWNERS
--- a/services/viz/privileged/interfaces/compositing/display_private.mojom	2019-05-01 01:22:57.000000000 +0300
+++ b/services/viz/privileged/interfaces/compositing/display_private.mojom	2019-05-17 18:53:38.028000000 +0300
@@ -51,10 +51,6 @@
   // Notifies the display to pause VSync signals. Used for VR.
   [EnableIf=is_android]
   SetVSyncPaused(bool paused);
-
-  // Updates the refresh rate of the associated Display.
-  [EnableIf=is_android]
-  UpdateRefreshRate(float refresh_rate);
 };
 
 interface DisplayClient {
--- a/services/viz/privileged/interfaces/compositing/frame_sink_manager.mojom	2019-05-01 01:22:57.000000000 +0300
+++ b/services/viz/privileged/interfaces/compositing/frame_sink_manager.mojom	2019-05-17 18:53:38.028000000 +0300
@@ -30,9 +30,6 @@
   // Disables begin frame rate limiting for the display compositor.
   bool disable_frame_rate_limit = false;
 
-  [EnableIf=is_android]
-  float refresh_rate;
-
   associated CompositorFrameSink& compositor_frame_sink;
   CompositorFrameSinkClient compositor_frame_sink_client;
 
--- a/services/viz/privileged/interfaces/compositing/frame_sink_video_capture.mojom	2019-05-01 01:22:57.000000000 +0300
+++ b/services/viz/privileged/interfaces/compositing/frame_sink_video_capture.mojom	2019-05-17 18:53:38.028000000 +0300
@@ -38,13 +38,14 @@
   // the service that it is Done(). |info| is used to interpret the
   // format/layout of the data, and also contains the frame timestamps and other
   // metadata (the following media::VideoFrameMetadata keys are set:
-  // CAPTURE_BEGIN_TIME, CAPTURE_END_TIME, CAPTURE_COUNTER, CAPTURE_UPDATE_RECT,
-  // COLOR_SPACE, FRAME_DURATION, INTERACTIVE_CONTENT, REFERENCE_TIME).
-  // |content_rect| is the region of the frame that contains the captured
-  // content, with the rest of the frame having been letterboxed to adhere to
-  // resolution constraints.
+  // CAPTURE_BEGIN_TIME, CAPTURE_END_TIME, COLOR_SPACE, FRAME_DURATION,
+  // INTERACTIVE_CONTENT, REFERENCE_TIME). |update_rect| is the region of the
+  // frame that has changed since the last frame. |content_rect| is the region
+  // of the frame that contains the captured content, with the rest of the frame
+  // having been letterboxed to adhere to resolution constraints.
   OnFrameCaptured(mojo_base.mojom.ReadOnlySharedMemoryRegion data,
                   media.mojom.VideoFrameInfo info,
+                  gfx.mojom.Rect update_rect,
                   gfx.mojom.Rect content_rect,
                   FrameSinkVideoConsumerFrameCallbacks callbacks);
 
--- a/services/viz/privileged/interfaces/compositing/renderer_settings.mojom	2019-05-01 01:22:57.000000000 +0300
+++ b/services/viz/privileged/interfaces/compositing/renderer_settings.mojom	2019-05-17 18:53:38.028000000 +0300
@@ -18,9 +18,9 @@
   bool release_overlay_resources_after_gpu_query;
   bool should_clear_root_render_pass;
   bool show_overdraw_feedback;
+  bool enable_draw_occlusion;
   int32 slow_down_compositing_scale_factor;
   bool use_skia_renderer;
-  bool use_skia_renderer_non_ddl;
   bool record_sk_picture;
   bool allow_overlays;
   bool requires_alpha_channel;
@@ -30,7 +30,4 @@
 
   [EnableIf=is_android]
   gfx.mojom.ColorSpace color_space;
-
-  [EnableIf=is_android]
-  bool backed_by_surface_texture;
 };
--- a/services/viz/privileged/interfaces/compositing/renderer_settings_struct_traits.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/viz/privileged/interfaces/compositing/renderer_settings_struct_traits.cc	2019-05-17 18:53:38.028000000 +0300
@@ -23,11 +23,11 @@
       data.release_overlay_resources_after_gpu_query();
   out->tint_gl_composited_content = data.tint_gl_composited_content();
   out->show_overdraw_feedback = data.show_overdraw_feedback();
+  out->enable_draw_occlusion = data.enable_draw_occlusion();
   out->highp_threshold_min = data.highp_threshold_min();
   out->slow_down_compositing_scale_factor =
       data.slow_down_compositing_scale_factor();
   out->use_skia_renderer = data.use_skia_renderer();
-  out->use_skia_renderer_non_ddl = data.use_skia_renderer_non_ddl();
   out->record_sk_picture = data.record_sk_picture();
   out->allow_overlays = data.allow_overlays();
   out->requires_alpha_channel = data.requires_alpha_channel();
@@ -35,7 +35,6 @@
 #if defined(OS_ANDROID)
   success = data.ReadInitialScreenSize(&out->initial_screen_size);
   success = data.ReadColorSpace(&out->color_space);
-  out->backed_by_surface_texture = data.backed_by_surface_texture();
 #endif
 
   return success;
--- a/services/viz/privileged/interfaces/compositing/renderer_settings_struct_traits.h	2019-05-01 01:22:57.000000000 +0300
+++ b/services/viz/privileged/interfaces/compositing/renderer_settings_struct_traits.h	2019-05-17 18:53:38.028000000 +0300
@@ -53,6 +53,10 @@
     return input.show_overdraw_feedback;
   }
 
+  static bool enable_draw_occlusion(const viz::RendererSettings& input) {
+    return input.enable_draw_occlusion;
+  }
+
   static int highp_threshold_min(const viz::RendererSettings& input) {
     return input.highp_threshold_min;
   }
@@ -66,10 +70,6 @@
     return input.use_skia_renderer;
   }
 
-  static bool use_skia_renderer_non_ddl(const viz::RendererSettings& input) {
-    return input.use_skia_renderer_non_ddl;
-  }
-
   static bool record_sk_picture(const viz::RendererSettings& input) {
     return input.record_sk_picture;
   }
@@ -90,10 +90,6 @@
   static gfx::ColorSpace color_space(const viz::RendererSettings& input) {
     return input.color_space;
   }
-
-  static bool backed_by_surface_texture(const viz::RendererSettings& input) {
-    return input.backed_by_surface_texture;
-  }
 #endif
 
   static bool Read(viz::mojom::RendererSettingsDataView data,
--- a/services/viz/privileged/interfaces/struct_traits_unittest.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/viz/privileged/interfaces/struct_traits_unittest.cc	2019-05-17 18:53:38.028000000 +0300
@@ -27,9 +27,9 @@
   input.should_clear_root_render_pass = false;
   input.release_overlay_resources_after_gpu_query = true;
   input.show_overdraw_feedback = true;
+  input.enable_draw_occlusion = true;
   input.highp_threshold_min = -1;
   input.use_skia_renderer = true;
-  input.use_skia_renderer_non_ddl = true;
 
   RendererSettings output;
   mojom::RendererSettings::Deserialize(
@@ -48,9 +48,9 @@
   EXPECT_EQ(input.tint_gl_composited_content,
             output.tint_gl_composited_content);
   EXPECT_EQ(input.show_overdraw_feedback, output.show_overdraw_feedback);
+  EXPECT_EQ(input.enable_draw_occlusion, output.enable_draw_occlusion);
   EXPECT_EQ(input.highp_threshold_min, output.highp_threshold_min);
   EXPECT_EQ(input.use_skia_renderer, output.use_skia_renderer);
-  EXPECT_EQ(input.use_skia_renderer_non_ddl, output.use_skia_renderer_non_ddl);
 }
 
 }  // namespace
--- a/services/viz/public/cpp/compositing/copy_output_result_struct_traits.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/viz/public/cpp/compositing/copy_output_result_struct_traits.cc	2019-05-17 18:53:38.032000000 +0300
@@ -4,7 +4,6 @@
 
 #include "services/viz/public/cpp/compositing/copy_output_result_struct_traits.h"
 
-#include "base/bind.h"
 #include "mojo/public/cpp/bindings/strong_binding.h"
 
 namespace {
--- a/services/viz/public/cpp/compositing/quads_struct_traits.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/viz/public/cpp/compositing/quads_struct_traits.cc	2019-05-17 18:53:38.032000000 +0300
@@ -41,10 +41,6 @@
       quad = list->AllocateAndConstruct<viz::TileDrawQuad>();
       quad->material = viz::DrawQuad::TILED_CONTENT;
       return quad;
-    case viz::mojom::DrawQuadStateDataView::Tag::VIDEO_HOLE_QUAD_STATE:
-      quad = list->AllocateAndConstruct<viz::VideoHoleDrawQuad>();
-      quad->material = viz::DrawQuad::VIDEO_HOLE;
-      return quad;
     case viz::mojom::DrawQuadStateDataView::Tag::YUV_VIDEO_QUAD_STATE:
       quad = list->AllocateAndConstruct<viz::YUVVideoDrawQuad>();
       quad->material = viz::DrawQuad::YUV_VIDEO_CONTENT;
@@ -107,8 +103,7 @@
   return data.ReadResourceSizeInPixels(
              &quad->overlay_resources.size_in_pixels
                   [viz::StreamVideoDrawQuad::kResourceIdIndex]) &&
-         data.ReadUvTopLeft(&quad->uv_top_left) &&
-         data.ReadUvBottomRight(&quad->uv_bottom_right);
+         data.ReadMatrix(&quad->matrix);
 }
 
 // static
@@ -173,15 +168,6 @@
 }
 
 // static
-bool StructTraits<viz::mojom::VideoHoleQuadStateDataView, viz::DrawQuad>::Read(
-    viz::mojom::VideoHoleQuadStateDataView data,
-    viz::DrawQuad* out) {
-  viz::VideoHoleDrawQuad* video_hole_quad =
-      static_cast<viz::VideoHoleDrawQuad*>(out);
-  return data.ReadOverlayPlaneId(&video_hole_quad->overlay_plane_id);
-}
-
-// static
 bool StructTraits<viz::mojom::YUVVideoQuadStateDataView, viz::DrawQuad>::Read(
     viz::mojom::YUVVideoQuadStateDataView data,
     viz::DrawQuad* out) {
--- a/services/viz/public/cpp/compositing/quads_struct_traits.h	2019-05-01 01:22:57.000000000 +0300
+++ b/services/viz/public/cpp/compositing/quads_struct_traits.h	2019-05-17 18:53:38.032000000 +0300
@@ -7,7 +7,6 @@
 
 #include "base/containers/span.h"
 #include "base/logging.h"
-#include "base/unguessable_token.h"
 #include "components/viz/common/quads/debug_border_draw_quad.h"
 #include "components/viz/common/quads/picture_draw_quad.h"
 #include "components/viz/common/quads/render_pass_draw_quad.h"
@@ -16,7 +15,6 @@
 #include "components/viz/common/quads/surface_draw_quad.h"
 #include "components/viz/common/quads/texture_draw_quad.h"
 #include "components/viz/common/quads/tile_draw_quad.h"
-#include "components/viz/common/quads/video_hole_draw_quad.h"
 #include "components/viz/common/quads/yuv_video_draw_quad.h"
 #include "services/viz/public/cpp/compositing/filter_operation_struct_traits.h"
 #include "services/viz/public/cpp/compositing/filter_operations_struct_traits.h"
@@ -88,8 +86,6 @@
         return viz::mojom::DrawQuadStateDataView::Tag::TEXTURE_QUAD_STATE;
       case viz::DrawQuad::TILED_CONTENT:
         return viz::mojom::DrawQuadStateDataView::Tag::TILE_QUAD_STATE;
-      case viz::DrawQuad::VIDEO_HOLE:
-        return viz::mojom::DrawQuadStateDataView::Tag::VIDEO_HOLE_QUAD_STATE;
       case viz::DrawQuad::YUV_VIDEO_CONTENT:
         return viz::mojom::DrawQuadStateDataView::Tag::YUV_VIDEO_QUAD_STATE;
     }
@@ -129,10 +125,6 @@
     return quad;
   }
 
-  static const viz::DrawQuad& video_hole_quad_state(const viz::DrawQuad& quad) {
-    return quad;
-  }
-
   static const viz::DrawQuad& yuv_video_quad_state(const viz::DrawQuad& quad) {
     return quad;
   }
@@ -153,8 +145,6 @@
         return data.ReadTileQuadState(out);
       case viz::mojom::DrawQuadStateDataView::Tag::STREAM_VIDEO_QUAD_STATE:
         return data.ReadStreamVideoQuadState(out);
-      case viz::mojom::DrawQuadStateDataView::Tag::VIDEO_HOLE_QUAD_STATE:
-        return data.ReadVideoHoleQuadState(out);
       case viz::mojom::DrawQuadStateDataView::Tag::YUV_VIDEO_QUAD_STATE:
         return data.ReadYuvVideoQuadState(out);
     }
@@ -164,19 +154,6 @@
 };
 
 template <>
-struct StructTraits<viz::mojom::VideoHoleQuadStateDataView, viz::DrawQuad> {
-  static const base::UnguessableToken& overlay_plane_id(
-      const viz::DrawQuad& input) {
-    const viz::VideoHoleDrawQuad* quad =
-        viz::VideoHoleDrawQuad::MaterialCast(&input);
-    return quad->overlay_plane_id;
-  }
-
-  static bool Read(viz::mojom::VideoHoleQuadStateDataView data,
-                   viz::DrawQuad* out);
-};
-
-template <>
 struct StructTraits<viz::mojom::DebugBorderQuadStateDataView, viz::DrawQuad> {
   static uint32_t color(const viz::DrawQuad& input) {
     const viz::DebugBorderDrawQuad* quad =
@@ -288,16 +265,10 @@
         .size_in_pixels[viz::StreamVideoDrawQuad::kResourceIdIndex];
   }
 
-  static const gfx::PointF& uv_top_left(const viz::DrawQuad& input) {
-    const viz::StreamVideoDrawQuad* quad =
-        viz::StreamVideoDrawQuad::MaterialCast(&input);
-    return quad->uv_top_left;
-  }
-
-  static const gfx::PointF& uv_bottom_right(const viz::DrawQuad& input) {
+  static const gfx::Transform& matrix(const viz::DrawQuad& input) {
     const viz::StreamVideoDrawQuad* quad =
         viz::StreamVideoDrawQuad::MaterialCast(&input);
-    return quad->uv_bottom_right;
+    return quad->matrix;
   }
 
   static bool Read(viz::mojom::StreamVideoQuadStateDataView data,
--- a/services/viz/public/cpp/compositing/render_pass_struct_traits.h	2019-05-01 01:22:57.000000000 +0300
+++ b/services/viz/public/cpp/compositing/render_pass_struct_traits.h	2019-05-17 18:53:38.032000000 +0300
@@ -13,7 +13,6 @@
 #include "services/viz/public/cpp/compositing/quads_struct_traits.h"
 #include "services/viz/public/interfaces/compositing/render_pass.mojom-shared.h"
 #include "ui/gfx/ipc/color/gfx_param_traits.h"
-#include "ui/gfx/mojo/rrect_f_struct_traits.h"
 #include "ui/gfx/mojo/transform_struct_traits.h"
 
 namespace mojo {
@@ -51,7 +50,7 @@
     return input->backdrop_filters;
   }
 
-  static const gfx::RRectF& backdrop_filter_bounds(
+  static const gfx::RectF& backdrop_filter_bounds(
       const std::unique_ptr<viz::RenderPass>& input) {
     return input->backdrop_filter_bounds;
   }
--- a/services/viz/public/cpp/compositing/struct_traits_perftest.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/viz/public/cpp/compositing/struct_traits_perftest.cc	2019-05-17 18:53:38.032000000 +0300
@@ -155,8 +155,6 @@
     gfx::Size arbitrary_size1(15, 19);
     gfx::Size arbitrary_size2(3, 99);
     gfx::RectF arbitrary_rectf1(4.2f, -922.1f, 15.6f, 29.5f);
-    gfx::RRectF arbitrary_rrectf1(4.2f, -922.1f, 15.6f, 29.5f, 1.2f, 2.3f, 3.4f,
-                                  4.5f, 5.6f, 6.7f, 7.8f, 8.9f);
     gfx::PointF arbitrary_pointf1(31.4f, 15.9f);
     gfx::PointF arbitrary_pointf2(26.5f, -35.8f);
     float arbitrary_float1 = 0.7f;
@@ -201,7 +199,7 @@
     std::unique_ptr<RenderPass> pass_in = RenderPass::Create();
     pass_in->SetAll(root_id, arbitrary_rect1, arbitrary_rect2,
                     arbitrary_matrix1, arbitrary_filters2, arbitrary_filters1,
-                    arbitrary_rrectf1, arbitrary_color_space, arbitrary_bool1,
+                    arbitrary_rectf1, arbitrary_color_space, arbitrary_bool1,
                     arbitrary_bool1, arbitrary_bool1, arbitrary_bool1);
 
     // Texture quads
--- a/services/viz/public/cpp/compositing/struct_traits_unittest.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/viz/public/cpp/compositing/struct_traits_unittest.cc	2019-05-17 18:53:38.032000000 +0300
@@ -4,7 +4,6 @@
 
 #include <utility>
 
-#include "base/bind.h"
 #include "base/run_loop.h"
 #include "base/test/scoped_task_environment.h"
 #include "build/build_config.h"
@@ -741,8 +740,7 @@
   backdrop_filters.Append(cc::FilterOperation::CreateSaturateFilter(4.f));
   backdrop_filters.Append(cc::FilterOperation::CreateZoomFilter(2.0f, 1));
   backdrop_filters.Append(cc::FilterOperation::CreateSaturateFilter(2.f));
-  gfx::RRectF backdrop_filter_bounds =
-      gfx::RRectF(10, 20, 130, 140, 1, 2, 3, 4, 5, 6, 7, 8);
+  gfx::RectF backdrop_filter_bounds = gfx::RectF(10, 20, 130, 140);
   gfx::ColorSpace color_space = gfx::ColorSpace::CreateXYZD50();
   const bool has_transparent_background = true;
   const bool cache_render_pass = true;
@@ -812,7 +810,8 @@
   EXPECT_EQ(has_transparent_background, output->has_transparent_background);
   EXPECT_EQ(filters, output->filters);
   EXPECT_EQ(backdrop_filters, output->backdrop_filters);
-  EXPECT_EQ(backdrop_filter_bounds, output->backdrop_filter_bounds);
+  EXPECT_EQ(gfx::ToNearestRect(backdrop_filter_bounds),
+            gfx::ToNearestRect(output->backdrop_filter_bounds));
   EXPECT_EQ(cache_render_pass, output->cache_render_pass);
   EXPECT_EQ(has_damage_from_contributing_content,
             output->has_damage_from_contributing_content);
@@ -880,7 +879,7 @@
       gfx::Transform(1.0, 0.5, 0.5, -0.5, -1.0, 0.0);
   const gfx::Rect damage_rect(56, 123, 19, 43);
   skcms_Matrix3x3 to_XYZD50 = SkNamedGamut::kXYZ;
-  skcms_TransferFunction fn = {1, 0, 1, 0, 0, 0, 1};
+  SkColorSpaceTransferFn fn = {1, 0, 1, 0, 0, 0, 1};
   gfx::ColorSpace color_space = gfx::ColorSpace::CreateCustom(to_XYZD50, fn);
   const bool has_transparent_background = true;
   const bool cache_render_pass = false;
@@ -888,7 +887,7 @@
   const bool generate_mipmap = false;
   std::unique_ptr<RenderPass> input = RenderPass::Create();
   input->SetAll(render_pass_id, output_rect, damage_rect, transform_to_root,
-                cc::FilterOperations(), cc::FilterOperations(), gfx::RRectF(),
+                cc::FilterOperations(), cc::FilterOperations(), gfx::RectF(),
                 color_space, has_transparent_background, cache_render_pass,
                 has_damage_from_contributing_content, generate_mipmap);
 
@@ -984,11 +983,13 @@
   const bool needs_blending6 = false;
   const ResourceId resource_id6(1234);
   const gfx::Size resource_size_in_pixels(1234, 5678);
+  const gfx::Transform matrix(16.1f, 15.3f, 14.3f, 13.7f, 12.2f, 11.4f, 10.4f,
+                              9.8f, 8.1f, 7.3f, 6.3f, 5.7f, 4.8f, 3.4f, 2.4f,
+                              1.2f);
   StreamVideoDrawQuad* stream_video_draw_quad =
       render_pass->CreateAndAppendDrawQuad<StreamVideoDrawQuad>();
   stream_video_draw_quad->SetNew(sqs, rect6, rect6, needs_blending6,
-                                 resource_id6, resource_size_in_pixels,
-                                 uv_top_left, uv_bottom_right);
+                                 resource_id6, resource_size_in_pixels, matrix);
 
   std::unique_ptr<RenderPass> output;
   mojo::test::SerializeAndDeserialize<mojom::RenderPass>(&render_pass, &output);
@@ -1063,8 +1064,7 @@
   EXPECT_EQ(resource_id6, out_stream_video_draw_quad->resource_id());
   EXPECT_EQ(resource_size_in_pixels,
             out_stream_video_draw_quad->resource_size_in_pixels());
-  EXPECT_EQ(uv_top_left, out_stream_video_draw_quad->uv_top_left);
-  EXPECT_EQ(uv_bottom_right, out_stream_video_draw_quad->uv_bottom_right);
+  EXPECT_EQ(matrix, out_stream_video_draw_quad->matrix);
 }
 
 TEST_F(StructTraitsTest, SurfaceId) {
--- a/services/viz/public/interfaces/BUILD.gn	2019-05-01 01:22:57.000000000 +0300
+++ b/services/viz/public/interfaces/BUILD.gn	2019-05-17 18:53:38.036000000 +0300
@@ -32,13 +32,13 @@
     "compositing/texture_releaser.mojom",
     "compositing/transferable_resource.mojom",
     "compositing/video_detector_observer.mojom",
+    "constants.mojom",
     "hit_test/aggregated_hit_test_region.mojom",
     "hit_test/hit_test_region_list.mojom",
     "hit_test/input_target_client.mojom",
   ]
 
   public_deps = [
-    ":constants",
     "//gpu/ipc/common:interfaces",
     "//mojo/public/mojom/base",
     "//skia/public/interfaces",
@@ -47,9 +47,3 @@
     "//ui/latency/mojo:interfaces",
   ]
 }
-
-mojom("constants") {
-  sources = [
-    "constants.mojom",
-  ]
-}
--- a/services/viz/public/interfaces/compositing/quads.mojom	2019-05-01 01:22:57.000000000 +0300
+++ b/services/viz/public/interfaces/compositing/quads.mojom	2019-05-17 18:53:38.036000000 +0300
@@ -4,7 +4,6 @@
 
 module viz.mojom;
 
-import "mojo/public/mojom/base/unguessable_token.mojom";
 import "services/viz/public/interfaces/compositing/surface_range.mojom";
 import "services/viz/public/interfaces/compositing/shared_quad_state.mojom";
 import "ui/gfx/geometry/mojo/geometry.mojom";
@@ -59,8 +58,7 @@
 struct StreamVideoQuadState {
   uint32 resource_id;
   gfx.mojom.Size resource_size_in_pixels;
-  gfx.mojom.PointF uv_top_left;
-  gfx.mojom.PointF uv_bottom_right;
+  gfx.mojom.Transform matrix;
 };
 
 struct SurfaceQuadState {
@@ -109,10 +107,6 @@
   ProtectedVideoState protected_video_type;
 };
 
-struct VideoHoleQuadState {
-  mojo_base.mojom.UnguessableToken overlay_plane_id;
-};
-
 union DrawQuadState {
   DebugBorderQuadState debug_border_quad_state;
   RenderPassQuadState render_pass_quad_state;
@@ -122,7 +116,6 @@
   TextureQuadState texture_quad_state;
   TileQuadState tile_quad_state;
   YUVVideoQuadState yuv_video_quad_state;
-  VideoHoleQuadState video_hole_quad_state;
 };
 
 struct DrawQuad {
--- a/services/viz/public/interfaces/compositing/render_pass.mojom	2019-05-01 01:22:57.000000000 +0300
+++ b/services/viz/public/interfaces/compositing/render_pass.mojom	2019-05-17 18:53:38.036000000 +0300
@@ -9,7 +9,6 @@
 import "services/viz/public/interfaces/compositing/quads.mojom";
 import "ui/gfx/geometry/mojo/geometry.mojom";
 import "ui/gfx/mojo/color_space.mojom";
-import "ui/gfx/mojo/rrect_f.mojom";
 import "ui/gfx/mojo/transform.mojom";
 
 // See components/viz/common/quads/render_pass.h.
@@ -20,7 +19,7 @@
   gfx.mojom.Transform transform_to_root_target;
   FilterOperations filters;
   FilterOperations backdrop_filters;
-  gfx.mojom.RRectF backdrop_filter_bounds;
+  gfx.mojom.RectF backdrop_filter_bounds;
   gfx.mojom.ColorSpace color_space;
   bool has_transparent_background;
   bool cache_render_pass = false;
--- a/services/viz/service.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/viz/service.cc	2019-05-17 18:53:38.036000000 +0300
@@ -4,7 +4,6 @@
 
 #include "services/viz/service.h"
 
-#include "base/bind.h"
 #include "base/command_line.h"
 #include "components/viz/service/main/viz_main_impl.h"
 #include "gpu/config/gpu_preferences.h"
@@ -51,13 +50,7 @@
 void Service::OnBindInterface(const service_manager::BindSourceInfo& info,
                               const std::string& interface_name,
                               mojo::ScopedMessagePipeHandle interface_pipe) {
-  if (registry_.TryBindInterface(interface_name, &interface_pipe))
-    return;
-#if defined(USE_OZONE)
-  viz_main_->BindInterface(interface_name, std::move(interface_pipe));
-#else
-  NOTREACHED();
-#endif
+  registry_.BindInterface(interface_name, std::move(interface_pipe));
 }
 
 void Service::BindVizMainRequest(mojom::VizMainRequest request) {
--- a/services/ws/BUILD.gn	2019-05-01 01:22:57.000000000 +0300
+++ b/services/ws/BUILD.gn	2019-05-17 18:53:38.040000000 +0300
@@ -4,6 +4,8 @@
 
 import("//build/config/ui.gni")
 import("//mojo/public/tools/bindings/mojom.gni")
+import("//services/catalog/public/tools/catalog.gni")
+import("//services/service_manager/public/service_manifest.gni")
 import("//testing/test.gni")
 
 component("lib") {
@@ -17,7 +19,6 @@
   public = [
     "event_queue.h",
     "ids.h",
-    "top_level_proxy_window.h",
     "window_delegate_impl.h",
     "window_manager_interface.h",
     "window_properties.h",
@@ -55,8 +56,6 @@
     "remoting_event_injector.h",
     "screen_provider.cc",
     "screen_provider.h",
-    "top_level_proxy_window_impl.cc",
-    "top_level_proxy_window_impl.h",
     "topmost_window_observer.cc",
     "topmost_window_observer.h",
     "user_activity_monitor.cc",
@@ -163,6 +162,7 @@
 
   deps = [
     ":lib",
+    ":tests_catalog_source",
     "//base",
     "//base/test:test_support",
     "//components/viz/test:test_support",
@@ -173,7 +173,6 @@
     "//services/ws/public/cpp",
     "//services/ws/public/cpp/host",
     "//services/ws/public/mojom",
-    "//services/ws/test_ws:manifest",
     "//testing/gtest",
     "//ui/aura",
     "//ui/aura:test_support",
@@ -191,6 +190,23 @@
   ]
 }
 
+service_manifest("unittests_manifest") {
+  name = "ui_ws2_service_unittests"
+  source = "test_manifest.json"
+}
+
+catalog("tests_catalog") {
+  testonly = true
+  embedded_services = [ ":unittests_manifest" ]
+  standalone_services = [ "//services/ws/test_ws:manifest" ]
+}
+
+catalog_cpp_source("tests_catalog_source") {
+  testonly = true
+  catalog = ":tests_catalog"
+  generated_function_name = "ws::test::CreateTestCatalog"
+}
+
 source_set("tests") {
   testonly = true
 
@@ -246,6 +262,11 @@
   }
 }
 
+service_manifest("manifest") {
+  name = "ui"
+  source = "manifest.json"
+}
+
 mojom("test_mojom") {
   testonly = true
 
--- a/services/ws/client_root.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/ws/client_root.cc	2019-05-17 18:53:38.040000000 +0300
@@ -6,90 +6,38 @@
 
 #include "base/bind.h"
 #include "base/callback_forward.h"
-#include "base/command_line.h"
-#include "base/memory/ptr_util.h"
 #include "components/viz/common/surfaces/surface_info.h"
 #include "components/viz/host/host_frame_sink_manager.h"
 #include "services/ws/client_change.h"
 #include "services/ws/client_change_tracker.h"
-#include "services/ws/common/switches.h"
 #include "services/ws/proxy_window.h"
-#include "services/ws/top_level_proxy_window.h"
 #include "services/ws/window_service.h"
 #include "services/ws/window_tree.h"
+#include "ui/aura/client/screen_position_client.h"
 #include "ui/aura/env.h"
 #include "ui/aura/mus/client_surface_embedder.h"
 #include "ui/aura/mus/property_converter.h"
 #include "ui/aura/window.h"
 #include "ui/aura/window_tree_host.h"
 #include "ui/aura_extra/window_position_in_root_monitor.h"
-#include "ui/base/layout.h"
 #include "ui/compositor/compositor.h"
 #include "ui/compositor/dip_util.h"
 #include "ui/compositor/property_change_reason.h"
-#include "ui/display/display.h"
-#include "ui/display/screen.h"
-#include "ui/gfx/geometry/point_conversions.h"
 #include "ui/wm/core/coordinate_conversion.h"
 
 namespace ws {
-namespace {
-
-bool ShouldAssignLocalSurfaceIdImpl(aura::Window* window, bool is_top_level) {
-  // The window service assigns LocalSurfaceIds in two cases:
-  // . Top-levels. This is because the window service is the one creating the
-  //   Window, and effectively embedding the client.
-  // . An embedding created by a WindowTree that was not itself embedded. This
-  //   scenario is similar to top-levels, where the Window is not itself
-  //   embedded in another window. An example of this is the app-list embedding
-  //   a Window that contains a WebContents, where the app-list runs in process
-  //   (not using the window-service APIs).
-  if (is_top_level)
-    return true;
-  ProxyWindow* proxy_window = ProxyWindow::GetMayBeNull(window);
-  return proxy_window->owning_window_tree() == nullptr;
-}
-
-// Returns the bounds of the |window| in screen coordinate, without affect of
-// the gfx::Transform. aura::Window::GetBoundsInScreen() is affected by
-// Transform and may return wrong origin on overview mode, which may confuse
-// locations of transient clients or tooltip windows. See
-// https://crbug.com/931161.
-gfx::Rect GetBoundsToSend(aura::Window* window) {
-  gfx::Rect bounds = window->bounds();
-  // Window may not have the root window in some tests, so use the topmost
-  // window in the hierarchy for root window.
-  aura::Window* root = window;
-  for (auto* w = window->parent(); w; w = w->parent()) {
-    bounds += w->bounds().OffsetFromOrigin();
-    root = w;
-  }
-  // Typically root window bounds should be (0, 0), but it's not on some tests.
-  bounds += (root->GetBoundsInScreen().origin() - root->bounds().origin());
-  return bounds;
-}
-
-}  // namespace
 
 ClientRoot::ClientRoot(WindowTree* window_tree,
                        aura::Window* window,
                        bool is_top_level)
-    : window_tree_(window_tree),
-      window_(window),
-      is_top_level_(is_top_level),
-      last_bounds_(GetBoundsToSend(window)),
-      last_visible_(!is_top_level && window->IsVisible()),
-      last_display_id_(display::kInvalidDisplayId) {
+    : window_tree_(window_tree), window_(window), is_top_level_(is_top_level) {
   window_->AddObserver(this);
   if (window_->GetHost())
     window->GetHost()->AddObserver(this);
-  display::Screen::GetScreen()->AddObserver(this);
-  client_surface_embedder_ =
-      std::make_unique<aura::ClientSurfaceEmbedder>(window_);
-  if (ShouldAssignLocalSurfaceIdImpl(window, is_top_level_))
-    parent_local_surface_id_allocator_.emplace();
+  client_surface_embedder_ = std::make_unique<aura::ClientSurfaceEmbedder>(
+      window_, is_top_level, gfx::Insets());
   // Ensure there is a valid LocalSurfaceId (if necessary).
-  GenerateLocalSurfaceIdIfNecessary();
+  UpdateLocalSurfaceIdIfNecessary();
   if (!is_top_level) {
     root_position_monitor_ =
         std::make_unique<aura_extra::WindowPositionInRootMonitor>(
@@ -99,45 +47,46 @@
 }
 
 ClientRoot::~ClientRoot() {
-  if (force_visible_)
-    force_visible_->OnClientRootDestroyed();
-
   ProxyWindow* proxy_window = ProxyWindow::GetMayBeNull(window_);
   window_->RemoveObserver(this);
   if (window_->GetHost())
     window_->GetHost()->RemoveObserver(this);
-  display::Screen::GetScreen()->RemoveObserver(this);
 
   viz::HostFrameSinkManager* host_frame_sink_manager =
       window_->env()->context_factory_private()->GetHostFrameSinkManager();
   host_frame_sink_manager->InvalidateFrameSinkId(proxy_window->frame_sink_id());
 }
 
+void ClientRoot::SetClientAreaInsets(const gfx::Insets& client_area_insets) {
+  if (!is_top_level_)
+    return;
+
+  client_surface_embedder_->SetClientAreaInsets(client_area_insets);
+}
+
 void ClientRoot::RegisterVizEmbeddingSupport() {
   // This function should only be called once.
   viz::HostFrameSinkManager* host_frame_sink_manager =
       window_->env()->context_factory_private()->GetHostFrameSinkManager();
   viz::FrameSinkId frame_sink_id =
       ProxyWindow::GetMayBeNull(window_)->frame_sink_id();
-  // This code only needs first-surface-activation for tests.
-  const bool wants_first_surface_activation =
-      base::CommandLine::ForCurrentProcess()->HasSwitch(
-          switches::kUseTestConfig);
   host_frame_sink_manager->RegisterFrameSinkId(
-      frame_sink_id, this,
-      wants_first_surface_activation ? viz::ReportFirstSurfaceActivation::kYes
-                                     : viz::ReportFirstSurfaceActivation::kNo);
+      frame_sink_id, this, viz::ReportFirstSurfaceActivation::kYes);
   window_->SetEmbedFrameSinkId(frame_sink_id);
 
-  UpdateLocalSurfaceIdAndClientSurfaceEmbedder();
+  UpdatePrimarySurfaceId();
 }
 
-void ClientRoot::OnForceVisibleDestroyed() {
-  force_visible_ = nullptr;
-  NotifyClientOfVisibilityChange();
+bool ClientRoot::ShouldAssignLocalSurfaceId() {
+  // First level embeddings have their LocalSurfaceId assigned by the
+  // WindowService. First level embeddings have no embeddings above them.
+  if (is_top_level_)
+    return true;
+  ProxyWindow* proxy_window = ProxyWindow::GetMayBeNull(window_);
+  return proxy_window->owning_window_tree() == nullptr;
 }
 
-void ClientRoot::GenerateLocalSurfaceIdIfNecessary() {
+void ClientRoot::UpdateLocalSurfaceIdIfNecessary() {
   if (!ShouldAssignLocalSurfaceId())
     return;
 
@@ -147,82 +96,22 @@
   // It's expected by cc code that any time the size changes a new
   // LocalSurfaceId is used.
   if (last_surface_size_in_pixels_ != size_in_pixels ||
-      !proxy_window->local_surface_id_allocation().has_value() ||
+      !proxy_window->local_surface_id().has_value() ||
       last_device_scale_factor_ != window_->layer()->device_scale_factor()) {
-    parent_local_surface_id_allocator_->GenerateId();
-    UpdateSurfacePropertiesCache();
-  }
-}
-
-void ClientRoot::UpdateSurfacePropertiesCache() {
-  ProxyWindow::GetMayBeNull(window_)->set_local_surface_id_allocation(
-      parent_local_surface_id_allocator_->GetCurrentLocalSurfaceIdAllocation());
-  last_surface_size_in_pixels_ =
-      ui::ConvertSizeToPixel(window_->layer(), window_->bounds().size());
+    window_->AllocateLocalSurfaceId();
+    proxy_window->set_local_surface_id(
+        window_->GetLocalSurfaceIdAllocation().local_surface_id());
+    last_surface_size_in_pixels_ = size_in_pixels;
   last_device_scale_factor_ = window_->layer()->device_scale_factor();
-}
-
-bool ClientRoot::SetBoundsInScreenFromClient(
-    const gfx::Rect& bounds,
-    const base::Optional<viz::LocalSurfaceIdAllocation>& allocation) {
-  ProxyWindow* proxy_window = ProxyWindow::GetMayBeNull(window_);
-  const base::Optional<viz::LocalSurfaceIdAllocation> starting_allocation =
-      proxy_window->local_surface_id_allocation();
-  {
-    base::AutoReset<bool> resetter(&setting_bounds_from_client_, true);
-    display::Display dst_display =
-        display::Screen::GetScreen()->GetDisplayMatching(bounds);
-    window_->SetBoundsInScreen(bounds, dst_display);
-  }
-  if (allocation)
-    parent_local_surface_id_allocator_->UpdateFromChild(*allocation);
-
-  const bool needs_new_surface_id =
-      !allocation || bounds.size() != window_->bounds().size();
-  if (needs_new_surface_id)
-    parent_local_surface_id_allocator_->GenerateId();
-  UpdateSurfacePropertiesCache();
-
-  if (starting_allocation != proxy_window->local_surface_id_allocation())
-    UpdateLocalSurfaceIdAndClientSurfaceEmbedder();
-
-  const bool succeeded = bounds == GetBoundsToSend(window_);
-  // The bounds and id form a unique pair, so that if either differ from what
-  // the client requested, the client needs to be notified by way of
-  // NotifyClientOfNewBounds().
-  if (!succeeded || needs_new_surface_id)
-    NotifyClientOfNewBounds();
-  return succeeded;
-}
-
-void ClientRoot::UpdateLocalSurfaceIdFromChild(
-    const viz::LocalSurfaceIdAllocation& local_surface_id_allocation) {
-  if (!parent_local_surface_id_allocator_->UpdateFromChild(
-          local_surface_id_allocation)) {
-    return;
   }
-
-  UpdateSurfacePropertiesCache();
-
-  UpdateLocalSurfaceIdAndClientSurfaceEmbedder();
 }
 
 void ClientRoot::OnLocalSurfaceIdChanged() {
   if (ShouldAssignLocalSurfaceId())
     return;
 
-  HandleBoundsOrScaleFactorChange();
-}
-
-void ClientRoot::AllocateLocalSurfaceIdAndNotifyClient() {
-  if (!ShouldAssignLocalSurfaceId())
-    return;
-
-  // Setting a null LocalSurfaceIdAllocation forces allocating a new one.
-  ProxyWindow::GetMayBeNull(window_)->set_local_surface_id_allocation(
-      base::nullopt);
-  UpdateLocalSurfaceIdAndClientSurfaceEmbedder();
-  NotifyClientOfNewBounds();
+  HandleBoundsOrScaleFactorChange(is_top_level_ ? window_->GetBoundsInScreen()
+                                                : window_->bounds());
 }
 
 void ClientRoot::AttachChildFrameSinkId(ProxyWindow* proxy_window) {
@@ -276,39 +165,17 @@
   }
 }
 
-std::unique_ptr<ScopedForceVisible> ClientRoot::ForceWindowVisible() {
-  // At this time there is only a need for a single force visible.
-  DCHECK(!force_visible_);
-  // Use WrapUnique() as constructor is private.
-  std::unique_ptr<ScopedForceVisible> force_visible =
-      base::WrapUnique(new ScopedForceVisible(this));
-  force_visible_ = force_visible.get();
-  NotifyClientOfVisibilityChange();
-  return force_visible;
-}
-
-void ClientRoot::OnWindowTreeHostDisplayIdChanged() {
-  if (last_display_id_ != window_->GetHost()->GetDisplayId())
-    NotifyClientOfDisplayIdChange();
-}
-
-void ClientRoot::UpdateLocalSurfaceIdAndClientSurfaceEmbedder() {
-  GenerateLocalSurfaceIdIfNecessary();
+void ClientRoot::UpdatePrimarySurfaceId() {
+  UpdateLocalSurfaceIdIfNecessary();
   ProxyWindow* proxy_window = ProxyWindow::GetMayBeNull(window_);
-  if (!proxy_window->local_surface_id_allocation().has_value())
-    return;
-
-  const viz::SurfaceId surface_id(
-      window_->GetFrameSinkId(),
-      proxy_window->local_surface_id_allocation()->local_surface_id());
-  const bool surface_id_changed =
-      surface_id != client_surface_embedder_->GetSurfaceId();
-  client_surface_embedder_->SetSurfaceId(surface_id);
-
-  // This triggers holding events until the frame has been activated. This
-  // ensures smooth resizes.
-  if (surface_id_changed && ShouldAssignLocalSurfaceId() && window_->GetHost())
-    window_->GetHost()->compositor()->OnChildResizing();
+  if (proxy_window->local_surface_id().has_value()) {
+    client_surface_embedder_->SetSurfaceId(viz::SurfaceId(
+        window_->GetFrameSinkId(), *proxy_window->local_surface_id()));
+    if (fallback_surface_info_) {
+      client_surface_embedder_->SetFallbackSurfaceInfo(*fallback_surface_info_);
+      fallback_surface_info_.reset();
+    }
+  }
 }
 
 void ClientRoot::CheckForScaleFactorChange() {
@@ -317,56 +184,30 @@
     return;
   }
 
-  HandleBoundsOrScaleFactorChange();
+  HandleBoundsOrScaleFactorChange(is_top_level_ ? window_->GetBoundsInScreen()
+                                                : window_->bounds());
 }
 
-void ClientRoot::HandleBoundsOrScaleFactorChange() {
-  if (setting_bounds_from_client_)
-    return;
-
-  UpdateLocalSurfaceIdAndClientSurfaceEmbedder();
-  NotifyClientOfNewBounds();
+void ClientRoot::HandleBoundsOrScaleFactorChange(const gfx::Rect& old_bounds) {
+  UpdatePrimarySurfaceId();
+  client_surface_embedder_->UpdateSizeAndGutters();
+  // See comments in WindowTree::SetWindowBoundsImpl() for details on
+  // why this always notifies the client.
+  NotifyClientOfNewBounds(old_bounds);
 }
 
-void ClientRoot::NotifyClientOfNewBounds() {
-  last_bounds_ = GetBoundsToSend(window_);
-  auto id = ProxyWindow::GetMayBeNull(window_)->local_surface_id_allocation();
+void ClientRoot::NotifyClientOfNewBounds(const gfx::Rect& old_bounds) {
+  last_bounds_ = window_->GetBoundsInScreen();
   window_tree_->window_tree_client_->OnWindowBoundsChanged(
-      window_tree_->TransportIdForWindow(window_), last_bounds_,
-      ProxyWindow::GetMayBeNull(window_)->local_surface_id_allocation());
-}
-
-void ClientRoot::NotifyClientOfVisibilityChange(base::Optional<bool> visible) {
-  const bool new_value = visible.has_value() ? *visible : IsWindowVisible();
-  if (last_visible_ == new_value)
-    return;
-
-  last_visible_ = new_value;
-  if (!window_tree_->property_change_tracker_->IsProcessingChangeForWindow(
-          window_, ClientChangeType::kVisibility)) {
-    window_tree_->window_tree_client_->OnWindowVisibilityChanged(
-        window_tree_->TransportIdForWindow(window_), last_visible_);
-  }
-}
-
-void ClientRoot::NotifyClientOfDisplayIdChange() {
-  last_display_id_ = window_->GetHost()->GetDisplayId();
-  window_tree_->window_tree_client_->OnWindowDisplayChanged(
-      window_tree_->TransportIdForWindow(window_), last_display_id_);
+      window_tree_->TransportIdForWindow(window_), old_bounds, last_bounds_,
+      ProxyWindow::GetMayBeNull(window_)->local_surface_id());
 }
 
 void ClientRoot::OnPositionInRootChanged() {
   DCHECK(!is_top_level_);
-  gfx::Rect bounds_in_screen = GetBoundsToSend(window_);
+  gfx::Rect bounds_in_screen = window_->GetBoundsInScreen();
   if (bounds_in_screen.origin() != last_bounds_.origin())
-    NotifyClientOfNewBounds();
-}
-
-bool ClientRoot::IsWindowVisible() {
-  if (force_visible_)
-    return true;
-
-  return is_top_level_ ? window_->TargetVisibility() : window_->IsVisible();
+    NotifyClientOfNewBounds(last_bounds_);
 }
 
 void ClientRoot::OnWindowPropertyChanged(aura::Window* window,
@@ -396,34 +237,38 @@
                                        const gfx::Rect& old_bounds,
                                        const gfx::Rect& new_bounds,
                                        ui::PropertyChangeReason reason) {
-  if (setting_bounds_from_client_)
-    return;
   if (!is_top_level_) {
-    HandleBoundsOrScaleFactorChange();
+    HandleBoundsOrScaleFactorChange(old_bounds);
     return;
   }
+  gfx::Rect old_bounds_in_screen = old_bounds;
+  aura::Window* root = window->GetRootWindow();
+  if (root && aura::client::GetScreenPositionClient(root))
+    ::wm::ConvertRectToScreen(window->parent(), &old_bounds_in_screen);
   if (is_moving_across_displays_) {
-    display_move_changed_bounds_ = true;
+    if (!scheduled_change_old_bounds_)
+      scheduled_change_old_bounds_ = old_bounds_in_screen;
     return;
   }
-  HandleBoundsOrScaleFactorChange();
+  DCHECK(!scheduled_change_old_bounds_);
+  HandleBoundsOrScaleFactorChange(old_bounds_in_screen);
 }
 
 void ClientRoot::OnWindowAddedToRootWindow(aura::Window* window) {
   DCHECK_EQ(window, window_);
   DCHECK(window->GetHost());
   window->GetHost()->AddObserver(this);
-  NotifyClientOfDisplayIdChange();
+  window_tree_->window_tree_client_->OnWindowDisplayChanged(
+      window_tree_->TransportIdForWindow(window),
+      window->GetHost()->GetDisplayId());
 
   // When the addition to a new root window isn't the result of moving across
   // displays (e.g. destruction of the current display), the window bounds in
   // screen change even though its bounds in the root window remain the same.
   if (is_top_level_ && !is_moving_across_displays_)
-    HandleBoundsOrScaleFactorChange();
+    HandleBoundsOrScaleFactorChange(window->GetBoundsInScreen());
   else
     CheckForScaleFactorChange();
-
-  NotifyClientOfVisibilityChange();
 }
 
 void ClientRoot::OnWindowRemovingFromRootWindow(aura::Window* window,
@@ -431,8 +276,6 @@
   DCHECK_EQ(window, window_);
   DCHECK(window->GetHost());
   window->GetHost()->RemoveObserver(this);
-  if (!new_root)
-    NotifyClientOfVisibilityChange(false);
 }
 
 void ClientRoot::OnWillMoveWindowToDisplay(aura::Window* window,
@@ -444,56 +287,35 @@
 void ClientRoot::OnDidMoveWindowToDisplay(aura::Window* window) {
   DCHECK(is_moving_across_displays_);
   is_moving_across_displays_ = false;
-  if (display_move_changed_bounds_) {
-    HandleBoundsOrScaleFactorChange();
-    display_move_changed_bounds_ = false;
+  if (scheduled_change_old_bounds_) {
+    HandleBoundsOrScaleFactorChange(scheduled_change_old_bounds_.value());
+    scheduled_change_old_bounds_.reset();
   }
 }
 
-void ClientRoot::OnWindowVisibilityChanged(aura::Window* window, bool visible) {
-  NotifyClientOfVisibilityChange();
-}
-
 void ClientRoot::OnHostResized(aura::WindowTreeHost* host) {
   // This function is also called when the device-scale-factor changes too.
   CheckForScaleFactorChange();
 }
 
-void ClientRoot::OnDisplayMetricsChanged(const display::Display& display,
-                                         uint32_t changed_metrics) {
-  // WindowTreeHost display id should be updated before OnDisplayMetricsChanged.
-  // Early out if the changed display is not relevant.
-  if (!window_->GetHost() || window_->GetHost()->GetDisplayId() != display.id())
-    return;
-
-  // Only handle changes that could change the origin of the ClientRoot.
-  if (!(changed_metrics & (DISPLAY_METRIC_BOUNDS | DISPLAY_METRIC_ROTATION)))
-    return;
-
-  // Size or device-scale-factor change is handled in OnHostResized.
-  const gfx::Rect new_bounds = GetBoundsToSend(window_);
-  if (last_bounds_.size() != new_bounds.size() ||
-      last_device_scale_factor_ != ui::GetScaleFactorForNativeView(window_)) {
-    return;
-  }
-
-  if (last_bounds_ != new_bounds)
-    NotifyClientOfNewBounds();
-}
-
 void ClientRoot::OnFirstSurfaceActivation(
     const viz::SurfaceInfo& surface_info) {
-  // NOTE: this function is only called if kUseTestConfig is supplied. See
-  // call to RegisterFrameSinkId().
-  if (window_tree_->client_name().empty())
-    return;
-
   ProxyWindow* proxy_window = ProxyWindow::GetMayBeNull(window_);
+  if (proxy_window->local_surface_id().has_value()) {
+    DCHECK(!fallback_surface_info_);
+    if (!client_surface_embedder_->HasPrimarySurfaceId())
+      UpdatePrimarySurfaceId();
+    client_surface_embedder_->SetFallbackSurfaceInfo(surface_info);
+  } else {
+    fallback_surface_info_ = std::make_unique<viz::SurfaceInfo>(surface_info);
+  }
+  if (!window_tree_->client_name().empty()) {
   // OnFirstSurfaceActivation() should only be called after
   // AttachCompositorFrameSink().
   DCHECK(proxy_window->attached_compositor_frame_sink());
   window_tree_->window_service()->OnFirstSurfaceActivation(
       window_tree_->client_name());
+  }
 }
 
 void ClientRoot::OnFrameTokenChanged(uint32_t frame_token) {
--- a/services/ws/client_root.h	2019-05-01 01:22:57.000000000 +0300
+++ b/services/ws/client_root.h	2019-05-17 18:53:38.040000000 +0300
@@ -11,11 +11,9 @@
 #include "base/macros.h"
 #include "base/optional.h"
 #include "components/viz/common/surfaces/local_surface_id.h"
-#include "components/viz/common/surfaces/parent_local_surface_id_allocator.h"
 #include "components/viz/host/host_frame_sink_client.h"
 #include "ui/aura/window_observer.h"
 #include "ui/aura/window_tree_host_observer.h"
-#include "ui/display/display_observer.h"
 #include "ui/gfx/geometry/rect.h"
 #include "ui/gfx/geometry/size.h"
 
@@ -28,15 +26,17 @@
 class WindowPositionInRootMonitor;
 }
 
+namespace gfx {
+class Insets;
+}
+
 namespace viz {
-class LocalSurfaceIdAllocation;
 class SurfaceInfo;
 }
 
 namespace ws {
 
 class ProxyWindow;
-class ScopedForceVisible;
 class WindowTree;
 
 // WindowTree creates a ClientRoot for each window the client is embedded in. A
@@ -47,12 +47,16 @@
 class COMPONENT_EXPORT(WINDOW_SERVICE) ClientRoot
     : public aura::WindowObserver,
       public aura::WindowTreeHostObserver,
-      public display::DisplayObserver,
       public viz::HostFrameSinkClient {
  public:
   ClientRoot(WindowTree* window_tree, aura::Window* window, bool is_top_level);
   ~ClientRoot() override;
 
+  // Called when the client area of the window changes. If the window is a
+  // top-level window, then this propagates the insets to the
+  // ClientSurfaceEmbedder.
+  void SetClientAreaInsets(const gfx::Insets& client_area_insets);
+
   // Registers the necessary state needed for embedding in viz.
   void RegisterVizEmbeddingSupport();
 
@@ -60,20 +64,9 @@
 
   bool is_top_level() const { return is_top_level_; }
 
-  // Sets the bounds from a client.
-  bool SetBoundsInScreenFromClient(
-      const gfx::Rect& bounds,
-      const base::Optional<viz::LocalSurfaceIdAllocation>& allocation);
-
-  // Updates the LocalSurfaceIdAllocation from the client.
-  void UpdateLocalSurfaceIdFromChild(
-      const viz::LocalSurfaceIdAllocation& local_surface_id_allocation);
-
   // Called when the LocalSurfaceId of the embedder changes.
   void OnLocalSurfaceIdChanged();
 
-  void AllocateLocalSurfaceIdAndNotifyClient();
-
   // Attaches/unattaches proxy_window->attached_frame_sink_id() to the
   // HostFrameSinkManager.
   void AttachChildFrameSinkId(ProxyWindow* proxy_window);
@@ -84,61 +77,31 @@
   void AttachChildFrameSinkIdRecursive(ProxyWindow* proxy_window);
   void UnattachChildFrameSinkIdRecursive(ProxyWindow* proxy_window);
 
-  // Returns true if the WindowService should assign the LocalSurfaceId. A value
-  // of false means the client is expected to providate the LocalSurfaceId.
-  bool ShouldAssignLocalSurfaceId() const {
-    return parent_local_surface_id_allocator_.has_value();
-  }
-
-  // See TopLevelProxyWindow::ForceWindowVisible() for details.
-  std::unique_ptr<ScopedForceVisible> ForceWindowVisible();
-
-  // Called when the WindowTreeHost containing this ClientRoot has changed its
-  // display id.
-  void OnWindowTreeHostDisplayIdChanged();
-
  private:
   friend class ClientRootTestHelper;
-  friend class ScopedForceVisible;
 
-  void OnForceVisibleDestroyed();
+  void UpdatePrimarySurfaceId();
 
-  // If necessary, this generates a new LocalSurfaceId. Generally you should
-  // call UpdateLocalSurfaceIdAndClientSurfaceEmbedder(), not this. If you call
-  // this, you need to ensure the ClientSurfaceEmbedder is updated.
-  void GenerateLocalSurfaceIdIfNecessary();
-
-  // Updates cached state specific to the current LocalSurfaceId. This is called
-  // any time |parent_local_surface_id_allocator_| has a new id.
-  void UpdateSurfacePropertiesCache();
-
-  // Calls GenerateLocalSurfaceIdIfNecessary() and if the current LocalSurfaceId
-  // is valid, updates ClientSurfaceEmbedder.
-  void UpdateLocalSurfaceIdAndClientSurfaceEmbedder();
+  // Returns true if the WindowService should assign the LocalSurfaceId. A value
+  // of false means the client is expected to providate the LocalSurfaceId.
+  bool ShouldAssignLocalSurfaceId();
+
+  // If necessary, this updates the LocalSurfaceId.
+  void UpdateLocalSurfaceIdIfNecessary();
 
   // Calls HandleBoundsOrScaleFactorChange() it the scale factor has changed.
   void CheckForScaleFactorChange();
 
-  // Called when the bounds or scale factor changes.
-  void HandleBoundsOrScaleFactorChange();
-
-  void NotifyClientOfNewBounds();
-
-  // If necessary, notifies the client that the visibility changes. If |visible|
-  // has a value, it is used as the visibility, otherwise IsWindowVisible() is
-  // used.
-  void NotifyClientOfVisibilityChange(
-      base::Optional<bool> visible = base::nullopt);
+  // Called when the bounds or scale factor changes. |old_bounds| is the
+  // previous bounds, which may not have changed if the scale factor changes.
+  void HandleBoundsOrScaleFactorChange(const gfx::Rect& old_bounds);
 
-  // Called when the display id changes.
-  void NotifyClientOfDisplayIdChange();
+  void NotifyClientOfNewBounds(const gfx::Rect& old_bounds);
 
   // Callback when the position of |window_|, relative to the root, changes.
   // This is *only* called for non-top-levels.
   void OnPositionInRootChanged();
 
-  bool IsWindowVisible();
-
   // aura::WindowObserver:
   void OnWindowPropertyChanged(aura::Window* window,
                                const void* key,
@@ -153,15 +116,10 @@
   void OnWillMoveWindowToDisplay(aura::Window* window,
                                  int64_t new_display_id) override;
   void OnDidMoveWindowToDisplay(aura::Window* window) override;
-  void OnWindowVisibilityChanged(aura::Window* window, bool visible) override;
 
   // aura::WindowTreeHostObserver:
   void OnHostResized(aura::WindowTreeHost* host) override;
 
-  // display::DisplayObsever:
-  void OnDisplayMetricsChanged(const display::Display& display,
-                               uint32_t changed_metrics) override;
-
   // viz::HostFrameSinkClient:
   void OnFirstSurfaceActivation(const viz::SurfaceInfo& surface_info) override;
   void OnFrameTokenChanged(uint32_t frame_token) override;
@@ -178,14 +136,13 @@
 
   std::unique_ptr<aura::ClientSurfaceEmbedder> client_surface_embedder_;
 
-  // Set to true in OnWillMoveWindowToDisplay() and false in
-  // OnDidMoveWindowToDisplay().
   bool is_moving_across_displays_ = false;
+  base::Optional<gfx::Rect> scheduled_change_old_bounds_;
 
-  // Set to true if the bounds changes between the time
-  // OnWillMoveWindowToDisplay() is called and OnDidMoveWindowToDisplay() is
-  // called.
-  bool display_move_changed_bounds_ = false;
+  // If non-null then the fallback SurfaceInfo was supplied before the primary
+  // surface. This will be pushed to the Layer once the primary surface is
+  // supplied.
+  std::unique_ptr<viz::SurfaceInfo> fallback_surface_info_;
 
   // Used for non-top-levels to watch for changes in screen coordinates.
   std::unique_ptr<aura_extra::WindowPositionInRootMonitor>
@@ -194,27 +151,6 @@
   // Last bounds sent to the client.
   gfx::Rect last_bounds_;
 
-  // Last visibility value sent to the client. This is not used for top-levels.
-  bool last_visible_;
-
-  // Last display id sent to the client.
-  int64_t last_display_id_;
-
-  // If true, SetBoundsInScreenFromClient() is setting the window bounds.
-  bool setting_bounds_from_client_ = false;
-
-  // Only used if ShouldAssignLocalSurfaceId() returns true. This is used
-  // instead of the ParentLocalSurfaceIdAllocator maintained by
-  // WindowPortLocal as ClientRoot needs to control when the allocations happen,
-  // and avoid allocations in the case of resizes and clients supplying their
-  // own LocalSurfaceId.
-  base::Optional<viz::ParentLocalSurfaceIdAllocator>
-      parent_local_surface_id_allocator_;
-
-  // If non-null the client is told the window is visible, regardless of
-  // whether the window is actually visible.
-  ScopedForceVisible* force_visible_ = nullptr;
-
   DISALLOW_COPY_AND_ASSIGN(ClientRoot);
 };
 
--- a/services/ws/client_root_test_helper.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/ws/client_root_test_helper.cc	2019-05-17 18:53:38.040000000 +0300
@@ -17,8 +17,4 @@
   return client_root_->client_surface_embedder_.get();
 }
 
-bool ClientRootTestHelper::IsWindowForcedVisible() {
-  return client_root_->force_visible_ != nullptr;
-}
-
 }  // namespace ws
--- a/services/ws/client_root_test_helper.h	2019-05-01 01:22:57.000000000 +0300
+++ b/services/ws/client_root_test_helper.h	2019-05-17 18:53:38.040000000 +0300
@@ -24,8 +24,6 @@
 
   aura::ClientSurfaceEmbedder* GetClientSurfaceEmbedder();
 
-  bool IsWindowForcedVisible();
-
  private:
   ClientRoot* client_root_;
 
--- a/services/ws/client_root_unittest.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/ws/client_root_unittest.cc	2019-05-17 18:53:38.040000000 +0300
@@ -5,11 +5,9 @@
 #include "services/ws/client_root.h"
 
 #include <string>
-#include <vector>
 
 #include "services/ws/public/cpp/property_type_converters.h"
 #include "services/ws/public/mojom/window_manager.mojom.h"
-#include "services/ws/top_level_proxy_window.h"
 #include "services/ws/window_service.h"
 #include "services/ws/window_service_test_setup.h"
 #include "services/ws/window_tree_test_helper.h"
@@ -19,8 +17,6 @@
 #include "ui/aura/window.h"
 #include "ui/aura/window_observer.h"
 #include "ui/aura/window_tracker.h"
-#include "ui/gfx/geometry/vector2d_conversions.h"
-#include "ui/gfx/transform.h"
 
 namespace ws {
 namespace {
@@ -56,7 +52,7 @@
 
 // Verifies a property change that occurs while servicing a property change from
 // the client results in notifying the client of the new property.
-TEST(ClientRootTest, CascadingPropertyChange) {
+TEST(ClientRoot, CascadingPropertyChange) {
   WindowServiceTestSetup setup;
   aura::Window* top_level =
       setup.window_tree_test_helper()->NewTopLevelWindow();
@@ -90,7 +86,7 @@
 }
 
 // Verifies embedded clients are notified of changes in screen bounds.
-TEST(ClientRootTest, EmbedBoundsInScreen) {
+TEST(ClientRoot, EmbedBoundsInScreen) {
   WindowServiceTestSetup setup;
   aura::Window* embed_window = setup.window_tree_test_helper()->NewWindow();
   embed_window->SetBounds(gfx::Rect(1, 2, 3, 4));
@@ -106,200 +102,22 @@
   EXPECT_TRUE(embedding_helper->changes()->empty());
   top_level->AddChild(window);
   std::vector<Change>* embedding_changes = embedding_helper->changes();
-  // Screen bounds of |embed_window| is the same as its initial bounds. Hence
-  // no bounds change fired.
-  embedding_changes->clear();
-
-  window->SetBounds(gfx::Rect(11, 12, 100, 100));
   auto iter =
       FirstChangeOfType(*embedding_changes, CHANGE_TYPE_NODE_BOUNDS_CHANGED);
   ASSERT_NE(iter, embedding_changes->end());
-  EXPECT_EQ(gfx::Rect(12, 14, 3, 4), iter->bounds);
+  EXPECT_EQ(gfx::Rect(1, 2, 3, 4), iter->bounds2);
   embedding_changes->clear();
 
-  top_level->SetBounds(gfx::Rect(100, 50, 100, 100));
+  window->SetBounds(gfx::Rect(11, 12, 100, 100));
   iter = FirstChangeOfType(*embedding_changes, CHANGE_TYPE_NODE_BOUNDS_CHANGED);
   ASSERT_NE(iter, embedding_changes->end());
-  EXPECT_EQ(gfx::Rect(112, 64, 3, 4), iter->bounds);
-}
-
-TEST(ClientRootTest, EmbedWindowServerVisibilityChanges) {
-  WindowServiceTestSetup setup;
-  aura::Window* embed_window = setup.window_tree_test_helper()->NewWindow();
-  embed_window->SetBounds(gfx::Rect(1, 2, 3, 4));
-  aura::Window* window = setup.window_tree_test_helper()->NewWindow();
-  aura::Window* top_level =
-      setup.window_tree_test_helper()->NewTopLevelWindow();
-  std::unique_ptr<EmbeddingHelper> embedding_helper =
-      setup.CreateEmbedding(embed_window);
-  ASSERT_TRUE(embedding_helper);
-  window->AddChild(embed_window);
-  top_level->AddChild(window);
-  std::vector<Change>* embedding_changes = embedding_helper->changes();
-  embedding_changes->clear();
-  embed_window->Show();
-  // As |top_level| isn't shown, no change yet.
-  EXPECT_TRUE(embedding_changes->empty());
-  top_level->Show();
-  EXPECT_TRUE(embedding_changes->empty());
-
-  // As all ancestor are visible, showing the window should notify the client.
-  window->Show();
-  ASSERT_EQ(1u, embedding_changes->size());
-  {
-    const Change& show_change = (*embedding_changes)[0];
-    EXPECT_EQ(CHANGE_TYPE_NODE_VISIBILITY_CHANGED, show_change.type);
-    EXPECT_TRUE(show_change.bool_value);
-    EXPECT_EQ(embedding_helper->window_tree_test_helper->TransportIdForWindow(
-                  embed_window),
-              show_change.window_id);
-  }
-  embedding_changes->clear();
-
-  // Hiding an ancestor should trigger hiding the window.
-  top_level->Hide();
-  ASSERT_EQ(1u, embedding_changes->size());
-  {
-    const Change& hide_change = (*embedding_changes)[0];
-    EXPECT_EQ(CHANGE_TYPE_NODE_VISIBILITY_CHANGED, hide_change.type);
-    EXPECT_FALSE(hide_change.bool_value);
-    EXPECT_EQ(embedding_helper->window_tree_test_helper->TransportIdForWindow(
-                  embed_window),
-              hide_change.window_id);
-  }
-  embedding_changes->clear();
-
-  // Showing an ancestor should trigger showing the window.
-  top_level->Show();
-  ASSERT_EQ(1u, embedding_changes->size());
-  {
-    const Change& show_change = (*embedding_changes)[0];
-    EXPECT_EQ(CHANGE_TYPE_NODE_VISIBILITY_CHANGED, show_change.type);
-    EXPECT_TRUE(show_change.bool_value);
-    EXPECT_EQ(embedding_helper->window_tree_test_helper->TransportIdForWindow(
-                  embed_window),
-              show_change.window_id);
-  }
-  embedding_changes->clear();
-
-  // Removing an ancestor from the WindowTreeHost implicitly hides the window.
-  top_level->RemoveChild(window);
-  ASSERT_EQ(1u, embedding_changes->size());
-  {
-    const Change& hide_change = (*embedding_changes)[0];
-    EXPECT_EQ(CHANGE_TYPE_NODE_VISIBILITY_CHANGED, hide_change.type);
-    EXPECT_FALSE(hide_change.bool_value);
-    EXPECT_EQ(embedding_helper->window_tree_test_helper->TransportIdForWindow(
-                  embed_window),
-              hide_change.window_id);
-  }
+  EXPECT_EQ(gfx::Rect(12, 14, 3, 4), iter->bounds2);
   embedding_changes->clear();
 
-  // Adding an ancestor to the WindowTreeHost implicitly shows the window.
-  top_level->AddChild(window);
-  {
-    auto iter = FirstChangeOfType(*embedding_changes,
-                                  CHANGE_TYPE_NODE_VISIBILITY_CHANGED);
+  top_level->SetBounds(gfx::Rect(100, 50, 100, 100));
+  iter = FirstChangeOfType(*embedding_changes, CHANGE_TYPE_NODE_BOUNDS_CHANGED);
     ASSERT_NE(iter, embedding_changes->end());
-    const Change& show_change = *iter;
-    EXPECT_EQ(CHANGE_TYPE_NODE_VISIBILITY_CHANGED, show_change.type);
-    EXPECT_TRUE(show_change.bool_value);
-    EXPECT_EQ(embedding_helper->window_tree_test_helper->TransportIdForWindow(
-                  embed_window),
-              show_change.window_id);
-  }
-  embedding_changes->clear();
-
-  embed_window->Hide();
-  ASSERT_EQ(1u, embedding_changes->size());
-  {
-    const Change& hide_change = (*embedding_changes)[0];
-    EXPECT_EQ(CHANGE_TYPE_NODE_VISIBILITY_CHANGED, hide_change.type);
-    EXPECT_FALSE(hide_change.bool_value);
-    EXPECT_EQ(embedding_helper->window_tree_test_helper->TransportIdForWindow(
-                  embed_window),
-              hide_change.window_id);
-  }
-}
-
-TEST(ClientRootTest, EmbedWindowClientVisibilityChanges) {
-  WindowServiceTestSetup setup;
-  aura::Window* embed_window = setup.window_tree_test_helper()->NewWindow();
-  embed_window->SetBounds(gfx::Rect(1, 2, 3, 4));
-  aura::Window* window = setup.window_tree_test_helper()->NewWindow();
-  aura::Window* top_level =
-      setup.window_tree_test_helper()->NewTopLevelWindow();
-  std::unique_ptr<EmbeddingHelper> embedding_helper =
-      setup.CreateEmbedding(embed_window);
-  ASSERT_TRUE(embedding_helper);
-  window->AddChild(embed_window);
-  top_level->AddChild(window);
-  std::vector<Change>* embedding_changes = embedding_helper->changes();
-  embedding_changes->clear();
-
-  // Changes initiated by the client should not callback to the client.
-  embedding_helper->window_tree_test_helper->SetWindowVisibility(embed_window,
-                                                                 true);
-  EXPECT_TRUE(embed_window->TargetVisibility());
-  EXPECT_TRUE(embedding_changes->empty());
-
-  embedding_helper->window_tree_test_helper->SetWindowVisibility(embed_window,
-                                                                 false);
-  EXPECT_FALSE(embed_window->TargetVisibility());
-  EXPECT_TRUE(embedding_changes->empty());
-}
-
-TEST(ClientRootTest, ForceVisible) {
-  WindowServiceTestSetup setup;
-  aura::Window* window = setup.window_tree_test_helper()->NewTopLevelWindow();
-  setup.changes()->clear();
-  EXPECT_FALSE(window->IsVisible());
-
-  {
-    // Verify calling ForceWindowVisible() results in notifying the client the
-    // window is visible (even though the underlying aura::Window is not).
-    auto force = setup.window_tree()
-                     ->GetClientRootForWindow(window)
-                     ->ForceWindowVisible();
-    EXPECT_FALSE(window->IsVisible());
-    EXPECT_EQ("VisibilityChanged window=0,1 visible=true",
-              SingleChangeToDescription(*setup.changes()));
-    setup.changes()->clear();
-  }
-
-  // Destroying |force| should notify the client the window is hidden.
-  EXPECT_FALSE(window->IsVisible());
-  EXPECT_EQ("VisibilityChanged window=0,1 visible=false",
-            SingleChangeToDescription(*setup.changes()));
-}
-
-TEST(ClientRootTest, TransformShouldntAffectBounds) {
-  WindowServiceTestSetup setup;
-  aura::Window* top_level =
-      setup.window_tree_test_helper()->NewTopLevelWindow();
-  top_level->SetBounds(gfx::Rect(50, 60, 100, 200));
-  gfx::Transform transform;
-  gfx::Vector2dF translate(20, 30);
-  transform.Translate(translate);
-  top_level->SetTransform(transform);
-  top_level->Show();
-
-  setup.changes()->clear();
-  gfx::Rect new_bounds(100, 120, 100, 200);
-  top_level->SetBounds(new_bounds);
-  EXPECT_EQ(new_bounds + gfx::ToFlooredVector2d(translate),
-            top_level->GetBoundsInScreen());
-  auto iter =
-      FirstChangeOfType(*setup.changes(), CHANGE_TYPE_NODE_BOUNDS_CHANGED);
-  ASSERT_NE(iter, setup.changes()->end());
-  EXPECT_EQ(new_bounds, iter->bounds);
-  setup.changes()->clear();
-
-  top_level->SetTransform(gfx::Transform());
-  EXPECT_EQ(new_bounds, top_level->GetBoundsInScreen());
-  EXPECT_EQ(
-      setup.changes()->end(),
-      FirstChangeOfType(*setup.changes(), CHANGE_TYPE_NODE_BOUNDS_CHANGED));
+  EXPECT_EQ(gfx::Rect(112, 64, 3, 4), iter->bounds2);
 }
 
 }  // namespace
--- a/services/ws/drag_drop_delegate.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/ws/drag_drop_delegate.cc	2019-05-17 18:53:38.040000000 +0300
@@ -5,7 +5,6 @@
 #include "services/ws/drag_drop_delegate.h"
 
 #include "base/bind.h"
-#include "base/bind_helpers.h"
 #include "base/strings/string16.h"
 #include "mojo/public/cpp/bindings/map.h"
 #include "services/ws/window_tree.h"
--- a/services/ws/event_injector.cc	2019-05-17 17:45:42.588000000 +0300
+++ b/services/ws/event_injector.cc	2019-05-17 18:53:38.040000000 +0300
@@ -84,7 +84,7 @@
     // NOTE: this does not correctly account for coordinates with capture
     // across displays. If needed, the implementation should match something
     // like:
-    // https://chromium.9oo91esource.qjz9zk/chromium/b+/ae087c53f5ce4557bfb0b92a13651342336fe18a/services/ws/event_injector.cc#22
+    // https://chromium.googlesource.com/chromium/b+/ae087c53f5ce4557bfb0b92a13651342336fe18a/services/ws/event_injector.cc#22
   }
 
   event_and_host.event = std::move(event);
--- a/services/ws/gpu_host/BUILD.gn	2019-05-01 01:22:57.000000000 +0300
+++ b/services/ws/gpu_host/BUILD.gn	2019-05-17 18:53:38.040000000 +0300
@@ -40,8 +40,8 @@
 
   if (is_chromeos) {
     sources += [
-      "arc_gpu_client.cc",
-      "arc_gpu_client.h",
+      "arc_client.cc",
+      "arc_client.h",
     ]
   }
 
--- a/services/ws/gpu_host/gpu_host.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/ws/gpu_host/gpu_host.cc	2019-05-17 18:53:38.044000000 +0300
@@ -4,7 +4,6 @@
 
 #include "services/ws/gpu_host/gpu_host.h"
 
-#include "base/bind.h"
 #include "base/command_line.h"
 #include "base/memory/shared_memory.h"
 #include "base/run_loop.h"
@@ -39,7 +38,7 @@
 #endif
 
 #if defined(OS_CHROMEOS)
-#include "services/ws/gpu_host/arc_gpu_client.h"
+#include "services/ws/gpu_host/arc_client.h"
 #endif
 
 #if defined(OS_CHROMEOS) && BUILDFLAG(USE_VAAPI)
@@ -175,8 +174,9 @@
 }
 
 void GpuHost::Shutdown() {
-  gpu_clients_.clear();
   gpu_host_impl_.reset();
+
+  gpu_clients_.clear();
 }
 
 void GpuHost::Add(mojom::GpuRequest request) {
@@ -191,9 +191,9 @@
 }
 
 #if defined(OS_CHROMEOS)
-void GpuHost::AddArcGpu(mojom::ArcGpuRequest request) {
-  arc_gpu_bindings_.AddBinding(
-      std::make_unique<ArcGpuClient>(gpu_host_impl_->gpu_service()),
+void GpuHost::AddArc(mojom::ArcRequest request) {
+  arc_bindings_.AddBinding(
+      std::make_unique<ArcClient>(gpu_host_impl_->gpu_service()),
       std::move(request));
 }
 #endif  // defined(OS_CHROMEOS)
--- a/services/ws/gpu_host/gpu_host.h	2019-05-01 01:22:57.000000000 +0300
+++ b/services/ws/gpu_host/gpu_host.h	2019-05-17 18:53:38.044000000 +0300
@@ -14,7 +14,7 @@
 #include "services/ws/public/mojom/gpu.mojom.h"
 
 #if defined(OS_CHROMEOS)
-#include "services/ws/public/mojom/arc_gpu.mojom.h"
+#include "services/ws/public/mojom/arc.mojom.h"
 #endif  // defined(OS_CHROMEOS)
 
 namespace base {
@@ -62,7 +62,7 @@
   void Add(mojom::GpuRequest request);
 
 #if defined(OS_CHROMEOS)
-  void AddArcGpu(mojom::ArcGpuRequest request);
+  void AddArc(mojom::ArcRequest request);
 #endif  // defined(OS_CHROMEOS)
 
 #if defined(USE_OZONE)
@@ -127,7 +127,7 @@
   std::unique_ptr<viz::VizMainImpl> viz_main_impl_;
 
 #if defined(OS_CHROMEOS)
-  mojo::StrongBindingSet<mojom::ArcGpu> arc_gpu_bindings_;
+  mojo::StrongBindingSet<mojom::Arc> arc_bindings_;
 #endif  // defined(OS_CHROMEOS)
 
   DISALLOW_COPY_AND_ASSIGN(GpuHost);
--- a/services/ws/gpu_host/gpu_host_unittest.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/ws/gpu_host/gpu_host_unittest.cc	2019-05-17 18:53:38.044000000 +0300
@@ -4,10 +4,6 @@
 
 #include "services/ws/gpu_host/gpu_host.h"
 
-#include <utility>
-
-#include "base/bind.h"
-#include "base/bind_helpers.h"
 #include "base/macros.h"
 #include "base/memory/weak_ptr.h"
 #include "base/message_loop/message_loop.h"
@@ -50,18 +46,7 @@
       scoped_refptr<base::SingleThreadTaskRunner> io_runner);
   ~TestGpuService() override {}
 
-  // viz::GpuServiceImpl:
-  void EstablishGpuChannel(int32_t client_id,
-                           uint64_t client_tracing_id,
-                           bool is_gpu_host,
-                           bool cache_shaders_on_disk,
-                           EstablishGpuChannelCallback callback) override;
-
-  int channel_requests() const { return channel_requests_; }
-
  private:
-  int channel_requests_ = 0;
-
   DISALLOW_COPY_AND_ASSIGN(TestGpuService);
 };
 
@@ -77,17 +62,6 @@
                      nullptr /* vulkan_implementation */,
                      /*exit_callback=*/base::DoNothing()) {}
 
-void TestGpuService::EstablishGpuChannel(int32_t client_id,
-                                         uint64_t client_tracing_id,
-                                         bool is_gpu_host,
-                                         bool cache_shaders_on_disk,
-                                         EstablishGpuChannelCallback callback) {
-  channel_requests_++;
-  viz::GpuServiceImpl::EstablishGpuChannel(client_id, client_tracing_id,
-                                           is_gpu_host, cache_shaders_on_disk,
-                                           std::move(callback));
-}
-
 }  // namespace
 
 class GpuHostTest : public testing::Test {
@@ -103,15 +77,11 @@
 
   base::WeakPtr<viz::GpuClient> AddGpuClient();
   void DestroyHost();
-  void ShutdownHost();
 
   // testing::Test
   void SetUp() override;
   void TearDown() override;
 
-  // Flushes |io_thread_| tasks and returns the number of channel requests.
-  int GetChannelRequests();
-
  private:
   base::MessageLoop message_loop_;
 
@@ -120,6 +90,7 @@
   discardable_memory::DiscardableSharedMemoryManager
       discardable_memory_manager_;
   std::unique_ptr<TestGpuService> gpu_service_;
+  viz::mojom::GpuServicePtr gpu_service_ptr_;
   std::unique_ptr<GpuHost> gpu_host_;
 
   DISALLOW_COPY_AND_ASSIGN(GpuHostTest);
@@ -134,17 +105,12 @@
   gpu_host_.reset();
 }
 
-void GpuHostTest::ShutdownHost() {
-  gpu_host_->Shutdown();
-}
-
 void GpuHostTest::SetUp() {
   testing::Test::SetUp();
   gpu_host_ = std::make_unique<GpuHost>(&gpu_host_delegate_, nullptr,
                                         &discardable_memory_manager_);
-  viz::mojom::GpuServicePtr gpu_service_ptr;
-  gpu_service_->Bind(mojo::MakeRequest(&gpu_service_ptr));
-  GpuHostTestApi(gpu_host_.get()).SetGpuService(std::move(gpu_service_ptr));
+  gpu_service_->Bind(mojo::MakeRequest(&gpu_service_ptr_));
+  GpuHostTestApi(gpu_host_.get()).SetGpuService(std::move(gpu_service_ptr_));
 }
 
 void GpuHostTest::TearDown() {
@@ -153,11 +119,6 @@
   testing::Test::TearDown();
 }
 
-int GpuHostTest::GetChannelRequests() {
-  io_thread_.FlushForTesting();
-  return gpu_service_->channel_requests();
-}
-
 // Tests to verify, that if a GpuHost is deleted before viz::GpuClient receives
 // a callback, that viz::GpuClient is torn down and does not attempt to use
 // GpuInfo after deletion. This should not crash on asan-builds.
@@ -182,24 +143,6 @@
   EXPECT_TRUE(callback_called);
 }
 
-// Verifies that shutting down GpuHost while a channel request is in flight does
-// not retry that request.
-TEST_F(GpuHostTest, GpuHostShutdownWhileChannelRequestInFlight) {
-  base::WeakPtr<viz::GpuClient> client_ref = AddGpuClient();
-  mojom::Gpu* gpu = client_ref.get();
-
-  // Initially, there should be no channel requests.
-  EXPECT_EQ(0, GetChannelRequests());
-
-  // Send a channel request and verfiy it is received by gpu service.
-  gpu->EstablishGpuChannel(base::DoNothing());
-  EXPECT_EQ(1, GetChannelRequests());
-
-  // Shutting down host should not retry the pending channel request.
-  ShutdownHost();
-  EXPECT_EQ(1, GetChannelRequests());
-}
-
 }  // namespace test
 }  // namespace gpu_host
 }  // namespace ws
--- a/services/ws/ime/BUILD.gn	2019-05-01 01:22:57.000000000 +0300
+++ b/services/ws/ime/BUILD.gn	2019-05-17 18:53:38.044000000 +0300
@@ -2,6 +2,8 @@
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
+import("//services/catalog/public/tools/catalog.gni")
+import("//services/service_manager/public/service_manifest.gni")
 import("//testing/test.gni")
 
 source_set("lib") {
@@ -28,19 +30,38 @@
   ]
 
   deps = [
+    ":tests_catalog_source",
     "//base",
     "//base/test:test_support",
     "//services/service_manager/public/cpp",
     "//services/service_manager/public/cpp/test:test_support",
-    "//services/ws/ime/test_ime_driver/public/cpp:manifest",
     "//services/ws/ime/test_ime_driver/public/mojom",
     "//services/ws/public/mojom",
-    "//services/ws/test_ws:manifest",
     "//testing/gtest",
   ]
 
   data_deps = [
+    ":lib",
     "//services/ws/ime/test_ime_driver",
-    "//services/ws/test_ws",
   ]
 }
+
+service_manifest("unittest_manifest") {
+  name = "ime_unittests"
+  source = "test_manifest.json"
+}
+
+catalog("tests_catalog") {
+  testonly = true
+  embedded_services = [ ":unittest_manifest" ]
+  standalone_services = [
+    "//services/ws/ime/test_ime_driver:manifest",
+    "//services/ws/test_ws:manifest",
+  ]
+}
+
+catalog_cpp_source("tests_catalog_source") {
+  testonly = true
+  catalog = ":tests_catalog"
+  generated_function_name = "ws::test::CreateImeTestCatalog"
+}
--- a/services/ws/ime/ime_unittest.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/ws/ime/ime_unittest.cc	2019-05-17 18:53:38.044000000 +0300
@@ -9,15 +9,13 @@
 #include "base/run_loop.h"
 #include "base/test/scoped_task_environment.h"
 #include "mojo/public/cpp/bindings/interface_request.h"
-#include "services/service_manager/public/cpp/manifest_builder.h"
 #include "services/service_manager/public/cpp/service.h"
 #include "services/service_manager/public/cpp/service_binding.h"
 #include "services/service_manager/public/cpp/test/test_service_manager.h"
-#include "services/ws/ime/test_ime_driver/public/cpp/manifest.h"
 #include "services/ws/ime/test_ime_driver/public/mojom/constants.mojom.h"
+#include "services/ws/ime/tests_catalog_source.h"
 #include "services/ws/public/mojom/constants.mojom.h"
 #include "services/ws/public/mojom/ime/ime.mojom.h"
-#include "services/ws/test_ws/test_manifest.h"
 #include "testing/gtest/include/gtest/gtest.h"
 #include "ui/events/event.h"
 #include "ui/events/keycodes/dom/dom_code.h"
@@ -50,15 +48,9 @@
   void DispatchKeyEventPostIME(
       std::unique_ptr<ui::Event> event,
       DispatchKeyEventPostIMECallback callback) override {
-    std::move(callback).Run(false, false);
+    std::move(callback).Run(false);
   }
   void EnsureCaretNotInRect(const gfx::Rect& rect) override {}
-  void SetEditableSelectionRange(const gfx::Range& range) override {}
-  void DeleteRange(const gfx::Range& range) override {}
-  void OnInputMethodChanged() override {}
-  void ChangeTextDirectionAndLayoutAlignment(
-      base::i18n::TextDirection direction) override {}
-  void ExtendSelectionAndDelete(uint32_t before, uint32_t after) override {}
 
   mojo::Binding<ws::mojom::TextInputClient> binding_;
   std::unique_ptr<base::RunLoop> run_loop_;
@@ -67,21 +59,13 @@
   DISALLOW_COPY_AND_ASSIGN(TestTextInputClient);
 };
 
-const char kTestServiceName[] = "ime_unittests";
-
 class IMEAppTest : public testing::Test {
  public:
   IMEAppTest()
-      : test_service_manager_(
-            {test_ws::GetManifest(), test_ime_driver::GetManifest(),
-             service_manager::ManifestBuilder()
-                 .WithServiceName(kTestServiceName)
-                 .RequireCapability(ws::mojom::kServiceName, "app")
-                 .RequireCapability(test_ime_driver::mojom::kServiceName, "")
-                 .Build()}),
+      : test_service_manager_(ws::test::CreateImeTestCatalog()),
         test_service_binding_(
             &test_service_,
-            test_service_manager_.RegisterTestInstance(kTestServiceName)) {
+            test_service_manager_.RegisterTestInstance("ime_unittests")) {
     // test_ime_driver will register itself as the current IMEDriver.
     // TODO(https://crbug.com/904148): This should not use |WarmService()|.
     connector()->WarmService(service_manager::ServiceFilter::ByName(
@@ -134,7 +118,6 @@
   details->state = ws::mojom::TextInputState::New(ui::TEXT_INPUT_TYPE_TEXT,
                                                   ui::TEXT_INPUT_MODE_DEFAULT,
                                                   base::i18n::LEFT_TO_RIGHT, 0);
-  details->data = ws::mojom::TextInputClientData::New();
   ws::mojom::TextInputClientPtr client_ptr;
   TestTextInputClient client(MakeRequest(&client_ptr));
   ime_driver_->StartSession(MakeRequest(&input_method), std::move(client_ptr),
--- a/services/ws/ime/test_ime_driver/BUILD.gn	2019-05-01 01:22:57.000000000 +0300
+++ b/services/ws/ime/test_ime_driver/BUILD.gn	2019-05-17 18:53:38.044000000 +0300
@@ -3,6 +3,7 @@
 # found in the LICENSE file.
 
 import("//services/service_manager/public/cpp/service_executable.gni")
+import("//services/service_manager/public/service_manifest.gni")
 import("//testing/test.gni")
 
 source_set("lib") {
@@ -32,3 +33,8 @@
     "//services/ws/public/mojom",
   ]
 }
+
+service_manifest("manifest") {
+  name = "test_ime_driver"
+  source = "manifest.json"
+}
--- a/services/ws/ime/test_ime_driver/OWNERS	2019-05-01 01:22:57.000000000 +0300
+++ b/services/ws/ime/test_ime_driver/OWNERS	2019-05-17 18:53:38.044000000 +0300
@@ -0,0 +1,2 @@
+per-file manifest.json=set noparent
+per-file manifest.json=file://ipc/SECURITY_OWNERS
--- a/services/ws/ime/test_ime_driver/test_ime_driver.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/ws/ime/test_ime_driver/test_ime_driver.cc	2019-05-17 18:53:38.044000000 +0300
@@ -6,7 +6,6 @@
 
 #include <utility>
 
-#include "base/bind.h"
 #include "mojo/public/cpp/bindings/strong_binding.h"
 #include "services/ws/public/mojom/ime/ime.mojom.h"
 
@@ -28,10 +27,6 @@
   void OnCaretBoundsChanged(const gfx::Rect& caret_bounds) override {
     NOTIMPLEMENTED_LOG_ONCE();
   }
-  void OnTextInputClientDataChanged(
-      ws::mojom::TextInputClientDataPtr data) override {
-    NOTIMPLEMENTED();
-  }
   void ProcessKeyEvent(std::unique_ptr<ui::Event> key_event,
                        ProcessKeyEventCallback callback) override {
     DCHECK(key_event->IsKeyEvent());
@@ -41,16 +36,15 @@
     // Using base::Unretained is safe because |client_| is owned by this class.
     client_->DispatchKeyEventPostIME(
         std::move(key_event),
-        base::BindOnce(&TestInputMethod::PostProcessKeyEvent,
+        base::BindOnce(&TestInputMethod::PostProcssKeyEvent,
                        base::Unretained(this), std::move(cloned_event),
                        std::move(callback)));
   }
   void CancelComposition() override { NOTIMPLEMENTED_LOG_ONCE(); }
   void ShowVirtualKeyboardIfEnabled() override { NOTIMPLEMENTED_LOG_ONCE(); }
 
-  void PostProcessKeyEvent(std::unique_ptr<ui::Event> key_event,
+  void PostProcssKeyEvent(std::unique_ptr<ui::Event> key_event,
                            ProcessKeyEventCallback callback,
-                           bool handled,
                            bool stopped_propagation) {
     // Ignore any events with modifiers set. This is useful for running things
     // like ash_shell_with_content and having accelerators (such as control-n)
--- a/services/ws/injected_event_handler_unittest.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/ws/injected_event_handler_unittest.cc	2019-05-17 18:53:38.044000000 +0300
@@ -5,7 +5,6 @@
 #include "services/ws/injected_event_handler.h"
 
 #include <memory>
-#include <utility>
 
 #include "base/bind.h"
 #include "services/service_manager/public/cpp/connector.h"
@@ -155,11 +154,16 @@
   bool got_rewrite_event() const { return got_rewrite_event_; }
 
   // ui::EventRewriter:
-  ui::EventDispatchDetails RewriteEvent(
+  ui::EventRewriteStatus RewriteEvent(
       const ui::Event& event,
-      const Continuation continuation) override {
+      std::unique_ptr<ui::Event>* new_event) override {
     got_rewrite_event_ = true;
-    return DiscardEvent(continuation);
+    return ui::EVENT_REWRITE_DISCARD;
+  }
+  ui::EventRewriteStatus NextDispatchEvent(
+      const ui::Event& last_event,
+      std::unique_ptr<ui::Event>* new_event) override {
+    return ui::EVENT_REWRITE_DISPATCH_ANOTHER;
   }
 
  private:
--- a/services/ws/OWNERS	2019-05-01 01:22:57.000000000 +0300
+++ b/services/ws/OWNERS	2019-05-17 18:53:38.040000000 +0300
@@ -9,6 +9,11 @@
 per-file *_type_converter*.*=set noparent
 per-file *_type_converter*.*=file://ipc/SECURITY_OWNERS
 
+per-file manifest.json=set noparent
+per-file manifest.json=file://ipc/SECURITY_OWNERS
+
+per-file test_manifest.json=set noparent
+per-file test_manifest.json=file://ipc/SECURITY_OWNERS
 
 per-file *.mojom=set noparent
 per-file *.mojom=file://ipc/SECURITY_OWNERS
--- a/services/ws/proxy_window.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/ws/proxy_window.cc	2019-05-17 18:53:38.044000000 +0300
@@ -11,7 +11,6 @@
 #include "services/ws/client_root.h"
 #include "services/ws/drag_drop_delegate.h"
 #include "services/ws/embedding.h"
-#include "services/ws/top_level_proxy_window_impl.h"
 #include "services/ws/window_tree.h"
 #include "services/ws/window_utils.h"
 #include "ui/aura/client/capture_client_observer.h"
@@ -24,11 +23,11 @@
 #include "ui/wm/core/capture_controller.h"
 #include "ui/wm/core/window_modality_controller.h"
 
-DEFINE_UI_CLASS_PROPERTY_TYPE(ws::ProxyWindow*)
+DEFINE_UI_CLASS_PROPERTY_TYPE(ws::ProxyWindow*);
 
 namespace ws {
 namespace {
-DEFINE_OWNED_UI_CLASS_PROPERTY_KEY(ProxyWindow, kProxyWindowKey, nullptr)
+DEFINE_OWNED_UI_CLASS_PROPERTY_KEY(ProxyWindow, kProxyWindowKey, nullptr);
 
 bool IsPointerPressedEvent(const ui::Event& event) {
   return event.type() == ui::ET_MOUSE_PRESSED ||
@@ -57,6 +56,59 @@
   return event.AsTouchEvent()->pointer_details().id;
 }
 
+// WindowTargeter used for ProxyWindows. This is used for two purposes:
+// . If the location is in the non-client area, then child Windows are not
+//   considered. This is done to ensure the delegate of the window (which is
+//   local) sees the event.
+// . To ensure |WindowTree::intercepts_events_| is honored.
+class ProxyWindowTargeter : public aura::WindowTargeter {
+ public:
+  explicit ProxyWindowTargeter(ProxyWindow* proxy_window)
+      : proxy_window_(proxy_window) {}
+  ~ProxyWindowTargeter() override = default;
+
+  // aura::WindowTargeter:
+  bool SubtreeShouldBeExploredForEvent(aura::Window* window,
+                                       const ui::LocatedEvent& event) override {
+    // If the top-level does not have insets, then forward the call to the
+    // parent's WindowTargeter. This is necessary for targeters such as
+    // EasyResizeWindowTargeter to work correctly.
+    if (mouse_extend().IsEmpty() && touch_extend().IsEmpty() &&
+        proxy_window_->IsTopLevel() && window->parent()) {
+      aura::WindowTargeter* parent_targeter =
+          static_cast<WindowTargeter*>(window->parent()->targeter());
+      if (parent_targeter)
+        return parent_targeter->SubtreeShouldBeExploredForEvent(window, event);
+    }
+    return aura::WindowTargeter::SubtreeShouldBeExploredForEvent(window, event);
+  }
+
+  ui::EventTarget* FindTargetForEvent(ui::EventTarget* event_target,
+                                      ui::Event* event) override {
+    aura::Window* window = static_cast<aura::Window*>(event_target);
+    DCHECK_EQ(window, proxy_window_->window());
+    if (proxy_window_->DoesOwnerInterceptEvents()) {
+      // If the owner intercepts events, then don't recurse (otherwise events
+      // would go to a descendant).
+      return event_target->CanAcceptEvent(*event) ? window : nullptr;
+    }
+
+    // Ensure events in the non-client area target the top-level window.
+    // TopLevelEventHandler will ensure these are routed correctly.
+    if (event->IsLocatedEvent() &&
+        IsLocationInNonClientArea(window,
+                                  event->AsLocatedEvent()->location())) {
+      return window;
+    }
+    return aura::WindowTargeter::FindTargetForEvent(event_target, event);
+  }
+
+ private:
+  ProxyWindow* const proxy_window_;
+
+  DISALLOW_COPY_AND_ASSIGN(ProxyWindowTargeter);
+};
+
 // ProxyWindowEventHandler is used to forward events to the client.
 // ProxyWindowEventHandler adds itself to the pre-phase to ensure it's
 // considered before the Window's delegate (or other EventHandlers).
@@ -105,13 +157,6 @@
       target_client = !embedded ? owning : embedded;
     }
     DCHECK(target_client);
-
-    // Don't send located events to the client during a move loop. Normally
-    // the client shouldn't be the target at this point, but it's entirely
-    // possible for held events to be released, triggering a spurious call.
-    if (event->IsLocatedEvent() && target_client->IsMovingWindow())
-      return;
-
     target_client->SendEventToClient(window(), *event);
 
     // The event was forwarded to the remote client. We don't want it handled
@@ -121,20 +166,11 @@
   }
 
  protected:
-  // Returns true if the event is a pinch event generated from the touchpad.
-  bool IsPinchEventOnTouchpad(const ui::Event& event) {
-    return event.IsPinchEvent() &&
-           event.AsGestureEvent()->details().device_type() ==
-               ui::GestureDeviceType::DEVICE_TOUCHPAD;
-  }
-
   // Returns true if the event should be ignored (not forwarded to the client).
   bool ShouldIgnoreEvent(const ui::Event& event) {
     // It's assumed clients do their own gesture recognizition, which means
-    // GestureEvents should not be forwarded to clients. Pinch events are
-    // exceptional since they aren't created through gesture recognition but
-    // from the touchpad directly. See https://crbug.com/933985.
-    if (event.IsGestureEvent() && !IsPinchEventOnTouchpad(event))
+    // GestureEvents should not be forwarded to clients.
+    if (event.IsGestureEvent())
       return true;
 
     if (static_cast<aura::Window*>(event.target()) != window()) {
@@ -272,14 +308,6 @@
       return;
     }
 
-    // When the gesture-end happens in the server side, the gesture state
-    // is cleaned up there; this state should be synchronized with the client.
-    if (event->type() == ui::ET_GESTURE_END &&
-        event->AsGestureEvent()->details().touch_points() == 1) {
-      proxy_window()->owning_window_tree()->CleanupGestureState(window());
-      return;
-    }
-
     if (ShouldIgnoreEvent(*event))
       return;
 
@@ -372,84 +400,6 @@
 
 }  // namespace
 
-// WindowTargeter used for ProxyWindows. This is used for three purposes:
-// . If the location is in the non-client area, then child Windows are not
-//   considered. This is done to ensure the delegate of the window (which is
-//   local) sees the event.
-// . To ensure |WindowTree::intercepts_events_| is honored.
-// . To support custom shaped windows through SetShape().
-class ProxyWindow::ProxyWindowTargeter : public aura::WindowTargeter {
- public:
-  explicit ProxyWindowTargeter(ProxyWindow* proxy_window)
-      : proxy_window_(proxy_window) {}
-  ~ProxyWindowTargeter() override = default;
-
-  void SetShape(const std::vector<gfx::Rect>& shape) { shape_ = shape; }
-
-  // aura::WindowTargeter:
-  bool SubtreeShouldBeExploredForEvent(aura::Window* window,
-                                       const ui::LocatedEvent& event) override {
-    // It's okay to check only when the window is the proxy_window. Any
-    // descendants should pass this condition once it passes with proxy_window.
-    if (window == proxy_window_->window() && !IsLocationInShape(event))
-      return false;
-
-    // If the top-level does not have insets, then forward the call to the
-    // parent's WindowTargeter. This is necessary for targeters such as
-    // EasyResizeWindowTargeter to work correctly.
-    if (mouse_extend().IsEmpty() && touch_extend().IsEmpty() &&
-        proxy_window_->IsTopLevel() && window->parent()) {
-      aura::WindowTargeter* parent_targeter =
-          static_cast<WindowTargeter*>(window->parent()->targeter());
-      if (parent_targeter)
-        return parent_targeter->SubtreeShouldBeExploredForEvent(window, event);
-    }
-    return aura::WindowTargeter::SubtreeShouldBeExploredForEvent(window, event);
-  }
-
-  ui::EventTarget* FindTargetForEvent(ui::EventTarget* event_target,
-                                      ui::Event* event) override {
-    aura::Window* window = static_cast<aura::Window*>(event_target);
-    DCHECK_EQ(window, proxy_window_->window());
-    if (proxy_window_->DoesOwnerInterceptEvents()) {
-      // If the owner intercepts events, then don't recurse (otherwise events
-      // would go to a descendant).
-      return event_target->CanAcceptEvent(*event) ? window : nullptr;
-    }
-
-    // Ensure events in the non-client area target the top-level window.
-    // TopLevelEventHandler will ensure these are routed correctly.
-    if (event->IsLocatedEvent() &&
-        IsLocationInNonClientArea(window,
-                                  event->AsLocatedEvent()->location())) {
-      return window;
-    }
-    return aura::WindowTargeter::FindTargetForEvent(event_target, event);
-  }
-
- private:
-  bool IsLocationInShape(const ui::LocatedEvent& event) {
-    // If |shape_| is empty, the handling of custom shapes are not used. Always
-    // return true.
-    if (shape_.empty())
-      return true;
-
-    gfx::Point location = event.root_location();
-    aura::Window::ConvertPointToTarget(proxy_window_->window()->GetRootWindow(),
-                                       proxy_window_->window(), &location);
-    for (const auto& rect : shape_) {
-      if (rect.Contains(location))
-        return true;
-    }
-    return false;
-  }
-
-  ProxyWindow* const proxy_window_;
-  std::vector<gfx::Rect> shape_;
-
-  DISALLOW_COPY_AND_ASSIGN(ProxyWindowTargeter);
-};
-
 ProxyWindow::~ProxyWindow() {
   // WindowTree/ClientRoot should have reset |attached_frame_sink_id_| before
   // the Window is destroyed.
@@ -500,6 +450,11 @@
 
   additional_client_areas_ = additional_client_areas;
   client_area_ = insets;
+  ClientRoot* client_root =
+      owning_window_tree_ ? owning_window_tree_->GetClientRootForWindow(window_)
+                          : nullptr;
+  if (client_root)
+    client_root->SetClientAreaInsets(insets);
 }
 
 void ProxyWindow::SetHitTestInsets(const gfx::Insets& mouse,
@@ -507,10 +462,6 @@
   window_targeter_->SetInsets(mouse, touch);
 }
 
-void ProxyWindow::SetShape(const std::vector<gfx::Rect>& shape) {
-  window_targeter_->SetShape(shape);
-}
-
 void ProxyWindow::SetCaptureOwner(WindowTree* owner) {
   capture_owner_ = owner;
   if (!IsTopLevel())
@@ -556,11 +507,6 @@
   drag_drop_delegate_ = std::move(drag_drop_delegate);
 }
 
-void ProxyWindow::SetTopLevelProxyWindow(
-    std::unique_ptr<TopLevelProxyWindowImpl> window) {
-  top_level_proxy_window_ = std::move(window);
-}
-
 std::string ProxyWindow::GetIdForDebugging() {
   return owning_window_tree_
              ? owning_window_tree_->ClientWindowIdForWindow(window_).ToString()
--- a/services/ws/proxy_window.h	2019-05-01 01:22:57.000000000 +0300
+++ b/services/ws/proxy_window.h	2019-05-17 18:53:38.048000000 +0300
@@ -5,7 +5,6 @@
 #ifndef SERVICES_WS_PROXY_WINDOW_H_
 #define SERVICES_WS_PROXY_WINDOW_H_
 
-#include <memory>
 #include <string>
 #include <vector>
 
@@ -13,7 +12,6 @@
 #include "base/macros.h"
 #include "base/optional.h"
 #include "components/viz/common/surfaces/frame_sink_id.h"
-#include "components/viz/common/surfaces/local_surface_id_allocation.h"
 #include "services/viz/public/interfaces/compositing/compositor_frame_sink.mojom.h"
 #include "services/ws/ids.h"
 #include "ui/base/cursor/cursor.h"
@@ -23,6 +21,7 @@
 
 namespace aura {
 class Window;
+class WindowTargeter;
 }  // namespace aura
 
 namespace ui {
@@ -33,7 +33,6 @@
 
 class DragDropDelegate;
 class Embedding;
-class TopLevelProxyWindowImpl;
 class WindowTree;
 
 // Tracks any state associated with an aura::Window for the WindowService.
@@ -85,8 +84,6 @@
 
   void SetHitTestInsets(const gfx::Insets& mouse, const gfx::Insets& touch);
 
-  void SetShape(const std::vector<gfx::Rect>& shape);
-
   void set_attached_frame_sink_id(const viz::FrameSinkId& id) {
     attached_frame_sink_id_ = id;
   }
@@ -127,14 +124,12 @@
     return attached_compositor_frame_sink_;
   }
 
-  void set_local_surface_id_allocation(
-      const base::Optional<viz::LocalSurfaceIdAllocation>&
-          local_surface_id_allocation) {
-    local_surface_id_allocation_ = local_surface_id_allocation;
-  }
-  const base::Optional<viz::LocalSurfaceIdAllocation>&
-  local_surface_id_allocation() const {
-    return local_surface_id_allocation_;
+  void set_local_surface_id(
+      const base::Optional<viz::LocalSurfaceId>& local_surface_id) {
+    local_surface_id_ = local_surface_id;
+  }
+  const base::Optional<viz::LocalSurfaceId>& local_surface_id() const {
+    return local_surface_id_;
   }
 
   bool HasDragDropDelegate() const {
@@ -143,18 +138,12 @@
   void SetDragDropDelegate(
       std::unique_ptr<DragDropDelegate> drag_drop_delegate);
 
-  void SetTopLevelProxyWindow(std::unique_ptr<TopLevelProxyWindowImpl> window);
-  TopLevelProxyWindowImpl* top_level_proxy_window() {
-    return top_level_proxy_window_.get();
-  }
-
   // Returns an id useful for debugging. This returns the id from the client
   // that created the window, otherwise |frame_sink_id_|.
   std::string GetIdForDebugging();
 
  private:
   friend class ProxyWindowTestHelper;
-  class ProxyWindowTargeter;
 
   ProxyWindow(aura::Window*,
               WindowTree* tree,
@@ -189,7 +178,7 @@
   gfx::Insets client_area_;
   std::vector<gfx::Rect> additional_client_areas_;
 
-  ProxyWindowTargeter* window_targeter_ = nullptr;
+  aura::WindowTargeter* window_targeter_ = nullptr;
 
   std::unique_ptr<ui::EventHandler> event_handler_;
 
@@ -206,7 +195,7 @@
   // See |capture_owner_| for details.
   WindowTree* focus_owner_ = nullptr;
 
-  base::Optional<viz::LocalSurfaceIdAllocation> local_surface_id_allocation_;
+  base::Optional<viz::LocalSurfaceId> local_surface_id_;
 
   std::unique_ptr<DragDropDelegate> drag_drop_delegate_;
 
@@ -220,8 +209,6 @@
   // FrameSinkId set by way of mojom::WindowTree::AttachFrameSinkId().
   viz::FrameSinkId attached_frame_sink_id_;
 
-  std::unique_ptr<TopLevelProxyWindowImpl> top_level_proxy_window_;
-
   DISALLOW_COPY_AND_ASSIGN(ProxyWindow);
 };
 
--- a/services/ws/proxy_window_unittest.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/ws/proxy_window_unittest.cc	2019-05-17 18:53:38.048000000 +0300
@@ -5,7 +5,6 @@
 #include "services/ws/proxy_window.h"
 
 #include <memory>
-#include <utility>
 
 #include "base/run_loop.h"
 #include "services/ws/client_root_test_helper.h"
@@ -17,62 +16,52 @@
 #include "ui/aura/mus/client_surface_embedder.h"
 #include "ui/events/event.h"
 #include "ui/events/event_constants.h"
-#include "ui/events/test/event_generator.h"
 #include "ui/wm/core/easy_resize_window_targeter.h"
 
 namespace ws {
 
-class ProxyWindowTest : public testing::Test {
- public:
-  ProxyWindowTest() = default;
-  ~ProxyWindowTest() override = default;
-
- protected:
-  WindowServiceTestSetup* setup() { return &setup_; }
-  WindowTreeTestHelper* helper() { return setup_.window_tree_test_helper(); }
-
-  ui::EventTarget* FindTargetFor(const gfx::Point& location) {
-    ui::MouseEvent mouse_event(ui::ET_MOUSE_PRESSED, location, location,
-                               base::TimeTicks::Now(),
-                               /* flags */ 0,
-                               /* changed_button_flags_ */ 0);
-    return setup_.root()->targeter()->FindTargetForEvent(setup_.root(),
-                                                         &mouse_event);
-  }
-
- private:
-  WindowServiceTestSetup setup_;
-
-  DISALLOW_COPY_AND_ASSIGN(ProxyWindowTest);
-};
-
-TEST_F(ProxyWindowTest, FindTargetForWindowWithEasyResizeTargeter) {
+TEST(ProxyWindow, FindTargetForWindowWithEasyResizeTargeter) {
+  WindowServiceTestSetup setup;
   std::unique_ptr<wm::EasyResizeWindowTargeter> easy_resize_window_targeter =
       std::make_unique<wm::EasyResizeWindowTargeter>(
           gfx::Insets(-10, -10, -10, -10), gfx::Insets(-10, -10, -10, -10));
-  setup()->root()->SetEventTargeter(std::move(easy_resize_window_targeter));
-  aura::Window* top_level = helper()->NewTopLevelWindow();
+  setup.root()->SetEventTargeter(std::move(easy_resize_window_targeter));
+  aura::Window* top_level =
+      setup.window_tree_test_helper()->NewTopLevelWindow();
   ASSERT_TRUE(top_level);
   top_level->SetBounds(gfx::Rect(100, 200, 200, 200));
   top_level->Show();
+  ui::MouseEvent mouse_event(ui::ET_MOUSE_PRESSED, gfx::Point(105, 195),
+                             gfx::Point(105, 195), base::TimeTicks::Now(),
+                             /* flags */ 0,
+                             /* changed_button_flags_ */ 0);
 
   // Even though the mouse is not over |top_level| it should be returned as the
   // target because EasyResizeWindowTargeter enlarges the hit area.
-  EXPECT_EQ(top_level, FindTargetFor(gfx::Point(105, 195)));
+  EXPECT_EQ(top_level, setup.root()->targeter()->FindTargetForEvent(
+                           setup.root(), &mouse_event));
 
   // Repeat with a location outside the extended hit region and ensure
   // |top_level| is not returned.
-  EXPECT_NE(top_level, FindTargetFor(gfx::Point(5, 5)));
+  ui::MouseEvent mouse_event2(ui::ET_MOUSE_PRESSED, gfx::Point(5, 5),
+                              gfx::Point(5, 5), base::TimeTicks::Now(),
+                              /* flags */ 0,
+                              /* changed_button_flags_ */ 0);
+  EXPECT_NE(top_level, setup.root()->targeter()->FindTargetForEvent(
+                           setup.root(), &mouse_event2));
 }
 
-TEST_F(ProxyWindowTest, FindTargetForWindowWithResizeInset) {
-  aura::Window* top_level = helper()->NewTopLevelWindow();
+TEST(ProxyWindow, FindTargetForWindowWithResizeInset) {
+  WindowServiceTestSetup setup;
+
+  aura::Window* top_level =
+      setup.window_tree_test_helper()->NewTopLevelWindow();
   ASSERT_TRUE(top_level);
   const gfx::Rect top_level_bounds(100, 200, 200, 200);
   top_level->SetBounds(top_level_bounds);
   top_level->Show();
 
-  aura::Window* child_window = helper()->NewWindow();
+  aura::Window* child_window = setup.window_tree_test_helper()->NewWindow();
   ASSERT_TRUE(child_window);
   top_level->AddChild(child_window);
   child_window->SetBounds(gfx::Rect(top_level_bounds.size()));
@@ -83,95 +72,39 @@
   gfx::Point click_point =
       top_level_bounds.left_center() + gfx::Vector2d(kInset / 2, 0);
   // With no resize inset set yet, the event should go to the child window.
-  EXPECT_EQ(child_window, FindTargetFor(click_point));
+  ui::MouseEvent mouse_event(ui::ET_MOUSE_PRESSED, click_point, click_point,
+                             base::TimeTicks::Now(),
+                             /* flags */ 0,
+                             /* changed_button_flags_ */ 0);
+  EXPECT_EQ(child_window, setup.root()->targeter()->FindTargetForEvent(
+                              setup.root(), &mouse_event));
 
   // With the resize inset, the event should go to the toplevel.
   top_level->SetProperty(aura::client::kResizeHandleInset, kInset);
-  EXPECT_EQ(top_level, FindTargetFor(click_point));
+  ui::MouseEvent mouse_event_2(ui::ET_MOUSE_PRESSED, click_point, click_point,
+                               base::TimeTicks::Now(),
+                               /* flags */ 0,
+                               /* changed_button_flags_ */ 0);
+  EXPECT_EQ(top_level, setup.root()->targeter()->FindTargetForEvent(
+                           setup.root(), &mouse_event_2));
 }
 
-TEST_F(ProxyWindowTest, SetShapeShouldLimitWindowTargeting) {
-  aura::Window* top_level = helper()->NewTopLevelWindow();
-  ASSERT_TRUE(top_level);
-  const gfx::Rect top_level_bounds(100, 200, 200, 200);
-  top_level->SetBounds(top_level_bounds);
-  top_level->Show();
-
-  aura::Window* child_window = helper()->NewWindow();
-  ASSERT_TRUE(child_window);
-  top_level->AddChild(child_window);
-  child_window->SetBounds(gfx::Rect(top_level_bounds.size()));
-  child_window->Show();
-
-  EXPECT_EQ(child_window, FindTargetFor(gfx::Point(110, 210)));
-  EXPECT_EQ(child_window, FindTargetFor(gfx::Point(200, 300)));
-  EXPECT_EQ(child_window, FindTargetFor(gfx::Point(290, 210)));
-  EXPECT_EQ(child_window, FindTargetFor(gfx::Point(290, 390)));
-
-  std::vector<gfx::Rect> shape = {
-      gfx::Rect(50, 50, 100, 100),
-      gfx::Rect(150, 150, 50, 50),
-  };
-  helper()->SetShape(top_level, shape);
-
-  EXPECT_NE(child_window, FindTargetFor(gfx::Point(110, 210)));
-  EXPECT_NE(top_level, FindTargetFor(gfx::Point(110, 210)));
-  EXPECT_EQ(child_window, FindTargetFor(gfx::Point(200, 300)));
-  EXPECT_NE(child_window, FindTargetFor(gfx::Point(290, 210)));
-  EXPECT_NE(top_level, FindTargetFor(gfx::Point(290, 210)));
-  EXPECT_EQ(child_window, FindTargetFor(gfx::Point(290, 390)));
-
-  // Empty cleas the shape API.
-  shape.clear();
-  helper()->SetShape(top_level, shape);
-  EXPECT_EQ(child_window, FindTargetFor(gfx::Point(110, 210)));
-  EXPECT_EQ(child_window, FindTargetFor(gfx::Point(200, 300)));
-  EXPECT_EQ(child_window, FindTargetFor(gfx::Point(290, 210)));
-  EXPECT_EQ(child_window, FindTargetFor(gfx::Point(290, 390)));
-}
+TEST(ProxyWindow, SetClientAreaPropagatesToClientSurfaceEmbedder) {
+  WindowServiceTestSetup setup;
 
-TEST_F(ProxyWindowTest, ShouldSendPinchEventFromTouchpads) {
-  aura::Window* top_level = helper()->NewTopLevelWindow();
+  aura::Window* top_level =
+      setup.window_tree_test_helper()->NewTopLevelWindow();
   ASSERT_TRUE(top_level);
   const gfx::Rect top_level_bounds(100, 200, 200, 200);
   top_level->SetBounds(top_level_bounds);
-  top_level->Show();
-
-  setup()->changes()->clear();
-
-  ui::test::EventGenerator event_generator(top_level->GetRootWindow());
-
-  // The pinch zoom from touchscreen -- that shouldn't be sent; the gesture
-  // recognition in the client will create them.
-  const gfx::Point points[] = {gfx::Point(110, 210), gfx::Point(190, 290)};
-  const gfx::Vector2d deltas[] = {gfx::Vector2d(20, 20),
-                                  gfx::Vector2d(-20, -20)};
-  const int delay_fingers[] = {0, 10};
-  event_generator.GestureMultiFingerScrollWithDelays(
-      2, points, deltas, delay_fingers, delay_fingers, 0, 10);
-  bool has_input_event = false;
-  for (auto& c : *setup()->changes()) {
-    if (c.type != CHANGE_TYPE_INPUT_EVENT)
-      continue;
-    has_input_event = true;
-    EXPECT_LE(ui::ET_TOUCH_RELEASED, c.event_action);
-    EXPECT_GE(ui::ET_TOUCH_CANCELLED, c.event_action);
-  }
-  EXPECT_TRUE(has_input_event);
-
-  setup()->changes()->clear();
-
-  // The pinch event from touchpad, this should be sent since the gesture
-  // recognition isn't involved.
-  ui::GestureEventDetails details(ui::ET_GESTURE_PINCH_BEGIN);
-  details.set_device_type(ui::GestureDeviceType::DEVICE_TOUCHPAD);
-  ui::GestureEvent pinch_event(110, 220, 0 /* flags */, base::TimeTicks::Now(),
-                               details);
-  ignore_result(setup()->aura_test_helper()->event_sink()->OnEventFromSource(
-      &pinch_event));
-  auto iter = FirstChangeOfType(*setup()->changes(), CHANGE_TYPE_INPUT_EVENT);
-  ASSERT_NE(iter, setup()->changes()->end());
-  EXPECT_EQ(ui::ET_GESTURE_PINCH_BEGIN, iter->event_action);
+  const gfx::Insets top_level_insets(1, 2, 11, 12);
+  setup.window_tree_test_helper()->SetClientArea(top_level, top_level_insets);
+  aura::ClientSurfaceEmbedder* client_surface_embedder =
+      ClientRootTestHelper(
+          setup.window_tree()->GetClientRootForWindow(top_level))
+          .GetClientSurfaceEmbedder();
+  ASSERT_TRUE(client_surface_embedder);
+  EXPECT_EQ(top_level_insets, client_surface_embedder->client_area_insets());
 }
 
 }  // namespace ws
--- a/services/ws/public/cpp/BUILD.gn	2019-05-01 01:22:57.000000000 +0300
+++ b/services/ws/public/cpp/BUILD.gn	2019-05-17 18:53:38.048000000 +0300
@@ -75,24 +75,3 @@
     deps += [ "//ui/ozone" ]
   }
 }
-
-source_set("manifest") {
-  sources = [
-    "manifest.cc",
-    "manifest.h",
-  ]
-
-  deps = [
-    "//base",
-    "//components/discardable_memory/public/interfaces",
-    "//services/service_manager/public/cpp",
-    "//services/ws/public/mojom",
-    "//services/ws/public/mojom/ime",
-    "//services/ws/public/mojom/input_devices",
-    "//ui/base/mojo",
-  ]
-
-  if (use_ozone) {
-    deps += [ "//ui/ozone/public/interfaces" ]
-  }
-}
--- a/services/ws/public/cpp/gpu/client_gpu_memory_buffer_manager.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/ws/public/cpp/gpu/client_gpu_memory_buffer_manager.cc	2019-05-17 18:53:38.048000000 +0300
@@ -4,8 +4,6 @@
 
 #include "services/ws/public/cpp/gpu/client_gpu_memory_buffer_manager.h"
 
-#include <utility>
-
 #include "base/bind.h"
 #include "base/logging.h"
 #include "base/memory/shared_memory.h"
@@ -19,15 +17,21 @@
 #include "services/ws/public/mojom/constants.mojom.h"
 #include "ui/gfx/buffer_format_util.h"
 
+using DestructionCallback = base::Callback<void(const gpu::SyncToken& sync)>;
+
+namespace gpu {
+class GpuMemoryBufferSupport;
+}
+
 namespace ws {
+
 namespace {
 
 void NotifyDestructionOnCorrectThread(
     scoped_refptr<base::SingleThreadTaskRunner> task_runner,
-    gpu::GpuMemoryBufferImpl::DestructionCallback callback,
+    const DestructionCallback& callback,
     const gpu::SyncToken& sync_token) {
-  task_runner->PostTask(FROM_HERE,
-                        base::BindOnce(std::move(callback), sync_token));
+  task_runner->PostTask(FROM_HERE, base::Bind(callback, sync_token));
 }
 
 }  // namespace
@@ -42,13 +46,14 @@
   // The thread is owned by this object. Which means the task will not run if
   // the object has been destroyed. So Unretained() is safe.
   thread_.task_runner()->PostTask(
-      FROM_HERE, base::BindOnce(&ClientGpuMemoryBufferManager::InitThread,
-                                base::Unretained(this), gpu.PassInterface()));
+      FROM_HERE,
+      base::Bind(&ClientGpuMemoryBufferManager::InitThread,
+                 base::Unretained(this), base::Passed(gpu.PassInterface())));
 }
 
 ClientGpuMemoryBufferManager::~ClientGpuMemoryBufferManager() {
   thread_.task_runner()->PostTask(
-      FROM_HERE, base::BindOnce(&ClientGpuMemoryBufferManager::TearDownThread,
+      FROM_HERE, base::Bind(&ClientGpuMemoryBufferManager::TearDownThread,
                                 base::Unretained(this)));
   thread_.Stop();
 }
@@ -57,7 +62,7 @@
     mojom::GpuMemoryBufferFactoryPtrInfo gpu_info) {
   gpu_.Bind(std::move(gpu_info));
   gpu_.set_connection_error_handler(
-      base::BindOnce(&ClientGpuMemoryBufferManager::DisconnectGpuOnThread,
+      base::Bind(&ClientGpuMemoryBufferManager::DisconnectGpuOnThread,
                      base::Unretained(this)));
   weak_ptr_ = weak_ptr_factory_.GetWeakPtr();
 }
@@ -97,7 +102,7 @@
   pending_allocation_waiters_.insert(wait);
   gpu_->CreateGpuMemoryBuffer(
       gfx::GpuMemoryBufferId(++counter_), size, format, usage,
-      base::BindOnce(
+      base::Bind(
           &ClientGpuMemoryBufferManager::OnGpuMemoryBufferAllocatedOnThread,
           base::Unretained(this), handle, wait));
 }
@@ -120,7 +125,7 @@
   if (!thread_.task_runner()->BelongsToCurrentThread()) {
     thread_.task_runner()->PostTask(
         FROM_HERE,
-        base::BindOnce(&ClientGpuMemoryBufferManager::DeletedGpuMemoryBuffer,
+        base::Bind(&ClientGpuMemoryBufferManager::DeletedGpuMemoryBuffer,
                        base::Unretained(this), id, sync_token));
     return;
   }
@@ -144,22 +149,22 @@
                            base::WaitableEvent::InitialState::NOT_SIGNALED);
   thread_.task_runner()->PostTask(
       FROM_HERE,
-      base::BindOnce(
-          &ClientGpuMemoryBufferManager::AllocateGpuMemoryBufferOnThread,
-          base::Unretained(this), size, format, usage, &gmb_handle, &wait));
+      base::Bind(&ClientGpuMemoryBufferManager::AllocateGpuMemoryBufferOnThread,
+                 base::Unretained(this), size, format, usage, &gmb_handle,
+                 &wait));
   wait.Wait();
   if (gmb_handle.is_null())
     return nullptr;
 
   auto gmb_handle_id = gmb_handle.id;
-  auto callback =
-      base::BindOnce(&ClientGpuMemoryBufferManager::DeletedGpuMemoryBuffer,
+  DestructionCallback callback =
+      base::Bind(&ClientGpuMemoryBufferManager::DeletedGpuMemoryBuffer,
                      weak_ptr_, gmb_handle_id);
-  std::unique_ptr<gpu::GpuMemoryBufferImpl> buffer =
+  std::unique_ptr<gpu::GpuMemoryBufferImpl> buffer(
       gpu_memory_buffer_support_->CreateGpuMemoryBufferImplFromHandle(
           std::move(gmb_handle), size, format, usage,
-          base::BindOnce(&NotifyDestructionOnCorrectThread,
-                         thread_.task_runner(), std::move(callback)));
+          base::Bind(&NotifyDestructionOnCorrectThread, thread_.task_runner(),
+                     callback)));
   if (!buffer) {
     DeletedGpuMemoryBuffer(gmb_handle_id, gpu::SyncToken());
     return nullptr;
--- a/services/ws/public/cpp/gpu/context_provider_command_buffer.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/ws/public/cpp/gpu/context_provider_command_buffer.cc	2019-05-17 18:53:38.048000000 +0300
@@ -12,7 +12,6 @@
 #include <utility>
 #include <vector>
 
-#include "base/bind.h"
 #include "base/callback_helpers.h"
 #include "base/command_line.h"
 #include "base/no_destructor.h"
@@ -20,7 +19,6 @@
 #include "base/strings/stringprintf.h"
 #include "base/threading/thread_task_runner_handle.h"
 #include "base/trace_event/memory_dump_manager.h"
-#include "build/build_config.h"
 #include "components/viz/common/gpu/context_cache_controller.h"
 #include "gpu/command_buffer/client/gles2_cmd_helper.h"
 #include "gpu/command_buffer/client/gles2_trace_implementation.h"
@@ -146,18 +144,10 @@
     return bind_result_;
   }
 
-  // TODO(enne): remove the kEnablePassthroughRasterDecoder flag and
-  // assume it is always available.
-  bool enable_passthrough_raster_decoder =
-      base::CommandLine::ForCurrentProcess()->HasSwitch(
-          switches::kEnablePassthroughRasterDecoder);
-#if defined(OS_WIN)
-  enable_passthrough_raster_decoder = true;
-#endif
-
   bool allow_raster_decoder =
       !command_buffer_->channel()->gpu_info().passthrough_cmd_decoder ||
-      enable_passthrough_raster_decoder;
+      base::CommandLine::ForCurrentProcess()->HasSwitch(
+          switches::kEnablePassthroughRasterDecoder);
   if (attributes_.context_type == gpu::CONTEXT_TYPE_WEBGPU) {
     DCHECK(!attributes_.enable_raster_interface);
     DCHECK(!attributes_.enable_gles2_interface);
@@ -172,14 +162,10 @@
       return bind_result_;
     }
 
-    // The transfer buffer is used to serialize Dawn commands
-    transfer_buffer_ =
-        std::make_unique<gpu::TransferBuffer>(webgpu_helper.get());
-
     // The WebGPUImplementation exposes the WebGPUInterface, as well as the
     // gpu::ContextSupport interface.
     auto webgpu_impl = std::make_unique<gpu::webgpu::WebGPUImplementation>(
-        webgpu_helper.get(), transfer_buffer_.get(), command_buffer_.get());
+        webgpu_helper.get());
 
     std::string type_name =
         command_buffer_metrics::ContextTypeToString(context_type_);
--- a/services/ws/public/cpp/gpu/gpu.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/ws/public/cpp/gpu/gpu.cc	2019-05-17 18:53:38.048000000 +0300
@@ -8,7 +8,7 @@
 #include <string>
 #include <utility>
 
-#include "base/bind.h"
+#include "base/debug/stack_trace.h"
 #include "base/memory/ptr_util.h"
 #include "base/synchronization/waitable_event.h"
 #include "base/threading/thread_task_runner_handle.h"
--- a/services/ws/public/cpp/OWNERS	2019-05-01 01:22:57.000000000 +0300
+++ b/services/ws/public/cpp/OWNERS	2019-05-17 18:53:38.048000000 +0300
@@ -1,7 +1,3 @@
 per-file *_type_converter*.*=set noparent
 per-file *_type_converter*.*=file://ipc/SECURITY_OWNERS
 per-file *compositor_frame_sink*.*=fsamuel@chromium.org
-per-file manifest.cc=set noparent
-per-file manifest.cc=file://ipc/SECURITY_OWNERS
-per-file manifest.h=set noparent
-per-file manifest.h=file://ipc/SECURITY_OWNERS
--- a/services/ws/public/cpp/tests/gpu_unittest.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/ws/public/cpp/tests/gpu_unittest.cc	2019-05-17 18:53:38.048000000 +0300
@@ -4,7 +4,6 @@
 
 #include "services/ws/public/cpp/gpu/gpu.h"
 
-#include "base/bind.h"
 #include "base/callback_helpers.h"
 #include "base/message_loop/message_loop.h"
 #include "base/run_loop.h"
@@ -134,8 +133,8 @@
   mojom::GpuPtr GetPtr() {
     mojom::GpuPtr ptr;
     io_thread_.task_runner()->PostTask(
-        FROM_HERE, base::BindOnce(&TestGpuImpl::BindRequest,
-                                  base::Unretained(gpu_impl_.get()),
+        FROM_HERE,
+        base::Bind(&TestGpuImpl::BindRequest, base::Unretained(gpu_impl_.get()),
                                   base::Passed(MakeRequest(&ptr))));
     return ptr;
   }
@@ -144,7 +143,7 @@
     base::WaitableEvent event(base::WaitableEvent::ResetPolicy::AUTOMATIC,
                               base::WaitableEvent::InitialState::NOT_SIGNALED);
     io_thread_.task_runner()->PostTask(
-        FROM_HERE, base::BindOnce(
+        FROM_HERE, base::Bind(
                        [](std::unique_ptr<TestGpuImpl> gpu_impl,
                           base::WaitableEvent* event) {
                          gpu_impl.reset();
--- a/services/ws/public/mojom/BUILD.gn	2019-05-01 01:22:57.000000000 +0300
+++ b/services/ws/public/mojom/BUILD.gn	2019-05-17 18:53:38.048000000 +0300
@@ -41,7 +41,7 @@
   ]
 
   if (is_chromeos) {
-    sources += [ "arc_gpu.mojom" ]
+    sources += [ "arc.mojom" ]
     public_deps += [ "//components/arc/common:media" ]
   }
 }
--- a/services/ws/public/mojom/ime/ime.mojom	2019-05-01 01:22:57.000000000 +0300
+++ b/services/ws/public/mojom/ime/ime.mojom	2019-05-17 18:53:38.052000000 +0300
@@ -120,21 +120,6 @@
   int32 text_input_flags;  // A bitfield of ui::TextInputFlags.
 };
 
-// Cached input context information so that RemoteTextInputClient could support
-// synchronous getters.
-struct TextInputClientData {
-  gfx.mojom.Range? text_range;
-  mojo_base.mojom.String16? text;
-  bool has_composition_text;
-  gfx.mojom.Range? composition_text_range;
-  gfx.mojom.Range? editable_selection_range;
-  // Contains a boolean indicating the enabled state of each of the
-  // ui::TextEditCommands, where the index is the command. For example,
-  // edit_command_enabled[TextCommand::DELETE_BACKWARD] gives the enabled
-  // state of TextCommand::DELETE_BACKWARD.
-  array<bool>? edit_command_enabled;
-};
-
 // Represents how a text client gets focused. Corresponds to
 // ui::TextInputClient::FocusReason.
 enum FocusReason {
@@ -153,9 +138,6 @@
   // Caret bounds of the text input client.
   gfx.mojom.Rect caret_bounds;
 
-  // Data of the text input client.
-  TextInputClientData data;
-
   // How the text input client was focused.
   FocusReason focus_reason;
 
@@ -194,9 +176,6 @@
   // Mus translates it to global coordinates and sends it to IME app.
   OnCaretBoundsChanged(gfx.mojom.Rect caret_bounds);
 
-  // Update the cached text input client data.
-  OnTextInputClientDataChanged(TextInputClientData data);
-
   // Called to process a key event. The callback function will be called to
   // notify the client if the event was handled or not. A handled event may
   // generate zero or more composition events which will be sent to the client
@@ -235,38 +214,13 @@
   // for more details.
   InsertChar(ui.mojom.Event event);
 
-  // Dispatch a key event after minimal processing by the IME. The results of
-  // the callback indicated whether the event was handled, and whether any
-  // further processing should be performed. That is, if |stopped_propagation|
-  // is true, IME does no further processing.
-  DispatchKeyEventPostIME(ui.mojom.Event event) => (
-      bool handled,
-      bool stopped_propagation);
+  // Dispatch a key event skipping IME. Returns true if event was consumed.
+  DispatchKeyEventPostIME(ui.mojom.Event event) => (bool stopped_propagation);
 
   // Ensure the caret is not in |rect|.  |rect| is in dip screen coordinates
   // and may extend beyond the bounds of this TextInputClient.
   EnsureCaretNotInRect(gfx.mojom.Rect rect);
 
-  // Selects the given UTF-16 based character range. Current composition text
-  // will be confirmed before selecting the range.
-  SetEditableSelectionRange(gfx.mojom.Range range);
-
-  // Deletes contents in the given UTF-16 based character range. Current
-  // composition text will be confirmed before deleting the range.
-  DeleteRange(gfx.mojom.Range range);
-
-  // Called whenever current keyboard layout or input method is changed.
-  OnInputMethodChanged();
-
-  // Called whenever the user requests to change the text direction and layout
-  // alignment of the current text box.
-  ChangeTextDirectionAndLayoutAlignment(
-      mojo_base.mojom.TextDirection direction);
-
-  // Deletes the current selection plus the specified number of characters
-  // before and after the selection or caret.
-  ExtendSelectionAndDelete(uint32 before, uint32 after);
-
   // TODO(moshayedi): Add functions corresponding to ui::TextInputClient for:
   // - Input context information
   // - Document content operations
--- a/services/ws/public/mojom/ime/ime_struct_traits_unittest.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/ws/public/mojom/ime/ime_struct_traits_unittest.cc	2019-05-17 18:53:38.052000000 +0300
@@ -11,7 +11,6 @@
 #include "base/strings/utf_string_conversions.h"
 #include "mojo/public/cpp/base/string16_mojom_traits.h"
 #include "mojo/public/cpp/bindings/binding_set.h"
-#include "services/ws/public/mojom/ime/ime.mojom.h"
 #include "services/ws/public/mojom/ime/ime_struct_traits_test.mojom.h"
 #include "testing/gtest/include/gtest/gtest.h"
 #include "ui/base/ime/composition_text.h"
--- a/services/ws/public/mojom/window_manager.mojom	2019-05-01 01:22:57.000000000 +0300
+++ b/services/ws/public/mojom/window_manager.mojom	2019-05-17 18:53:38.052000000 +0300
@@ -63,14 +63,8 @@
   // A boolean determining whether animations are disabled for the window.
   const string kAnimationsDisabled_Property = "prop:animations-disabled";
 
-  // A large version of the application icon. Type: SkBitmap
-  const string kAppIconLarge_Property = "prop:app-icon-large";
-
-  // A small version of the application icon. Type: SkBitmap
-  const string kAppIconSmall_Property = "prop:app-icon-small";
-
-  // The avatar icon to display in the frame header, if any. Type: SkBitmap
-  const string kAvatarIcon_Property = "prop:avatar-icon";
+  // The application icon; typically larger for shelf icons, etc. Type: SkBitmap
+  const string kAppIcon_Property = "prop:app-icon";
 
   // The Android Java-style package name for an ARC++ window, such as
   // "com.google.Photos". Type: mojom::String.
@@ -159,6 +153,9 @@
   // aura::client::kWindowCornerRadiusKey. Type: int.
   const string kWindowCornerRadius_Property = "prop:window-corner-radius";
 
+  // The window icon; typically 16x16 for titlebars. Type: SkBitmap
+  const string kWindowIcon_Property = "prop:window-icon";
+
   // The window's title. Maps to aura::client::kTitleKey. Type: mojom::String
   const string kWindowTitle_Property = "prop:window-title";
 
--- a/services/ws/public/mojom/window_tree.mojom	2019-05-01 01:22:57.000000000 +0300
+++ b/services/ws/public/mojom/window_tree.mojom	2019-05-17 18:53:38.052000000 +0300
@@ -7,7 +7,7 @@
 import "mojo/public/mojom/base/unguessable_token.mojom";
 import "services/viz/public/interfaces/compositing/compositor_frame_sink.mojom";
 import "services/viz/public/interfaces/compositing/frame_sink_id.mojom";
-import "services/viz/public/interfaces/compositing/local_surface_id_allocation.mojom";
+import "services/viz/public/interfaces/compositing/local_surface_id.mojom";
 import "services/viz/public/interfaces/compositing/surface_info.mojom";
 import "services/ws/public/mojom/window_manager.mojom";
 import "services/ws/public/mojom/screen_provider_observer.mojom";
@@ -66,6 +66,7 @@
   // Requests the WindowManager to create a new top level window. On success
   // OnTopLevelCreated() is called with the WindowData for the new window. On
   // failure OnChangeCompleted() is called.
+  // TODO(sky): this likely needs context, maybe in |properties|.
   NewTopLevelWindow(uint32 change_id,
                     uint64 window_id,
                     map<string, array<uint8>> properties);
@@ -104,32 +105,10 @@
 
   // Sets the specified bounds of the specified window. The window will paint
   // the frame in the provided |local_frame_id|, if any.
-  // |local_surface_id_allocation| need only be supplied for roots.
-  // For top-levels, clients may supply a null LocalSurfaceIdAllocation, before
-  // OnTopLevelCreated() is called (clients receive the initial
-  // LocalSurfaceIdAllocation in OnTopLevelCreated()). While clients may supply
-  // a LocalSurfaceIdAllocation for top-levels, they are only allowed to
-  // change the child-sequence number portion of the id. Supplying a different
-  // embed token results in failure, and changes to the parent sequence number
-  // are ignored.
-  // |bounds| are in DIPs.
-  SetWindowBounds(
-      uint32 change_id,
+  SetWindowBounds(uint32 change_id,
       uint64 window_id,
       gfx.mojom.Rect bounds,
-      viz.mojom.LocalSurfaceIdAllocation? local_surface_id_allocation);
-
-  // Updates the LocalSurfaceIdAllocation for a window from the child. Does
-  // nothing if |window_id| does not identify a top-level. See comment in
-  // SetWindowBounds() for allowable values of |local_surface_id_allocation|.
-  UpdateLocalSurfaceIdFromChild(
-      uint64 window_id,
-      viz.mojom.LocalSurfaceIdAllocation local_surface_id_allocation);
-
-  // Asks the server to generate a new LocalSurfaceId for a window. The server
-  // responds with the new LocalSurfaceId by way of OnWindowBoundsChanged().
-  // This is only useful for top-levels.
-  AllocateLocalSurfaceId(uint64 window_id);
+                  viz.mojom.LocalSurfaceId? local_surface_id);
 
   SetWindowTransform(uint32 change_id,
                      uint64 window_id,
@@ -150,13 +129,6 @@
                    gfx.mojom.Insets mouse,
                    gfx.mojom.Insets touch);
 
-  // Specifies the shape of the window. The region outside of the shape becomes
-  // transparent and should be considered to be outside of the widget, so
-  // underlying window will be targeted. Each element of |shape| is relative to
-  // the window's coordinate. Empty means to reset the settings, so the normal
-  // rectangular region will be used.
-  SetShape(uint64 window_id, array<gfx.mojom.Rect> shape);
-
   // Called by clients that want to accept drag and drops. Windows default to
   // this being disabled; a window must actively opt-in to receiving OnDrag*()
   // calls.
@@ -367,14 +339,12 @@
   // where the location is (x << 16) | y.
   GetCursorLocationMemory() => (handle<shared_buffer> cursor_buffer);
 
-  // Tells the window manager to start moving or resizing the window.
-  // OnChangeCompleted is called on whether the move was canceled. Because
-  // there's a delay between when a client sends this message and when the
-  // window manager starts acting on it, pass the cursor location at the start
-  // of the move. |hit_test| specifies the type of the session; kCaption for
-  // moving.
+  // Tells the window manager to start moving the window. OnChangeCompleted is
+  // called on whether the move was canceled. Because there's a delay between
+  // when a client sends this message and when the window manager starts acting
+  // on it, pass the cursor location at the start of the move.
   PerformWindowMove(uint32 change_id, uint64 window_id, MoveLoopSource source,
-                    gfx.mojom.Point cursor, ui.mojom.HitTest hit_test);
+                    gfx.mojom.Point cursor);
 
   // Tells the window manager to cancel any in progress window move started with
   // StartWindowMove() and to revert the window bounds to how they were.
@@ -411,10 +381,6 @@
   // the topmost window under the cursor.
   StopObservingTopmostWindow();
 
-  // Sets the resize shadow for |hit_test| to the specified window. It hides
-  // the shadow when kNowhere is set.
-  SetWindowResizeShadow(uint64 window_id, ui.mojom.HitTest hit_test);
-
   // Called by the client to cancel active touch events. not_cancelled_window_id
   // is a window ID, and that window is excluded from cancelling. When
   // not_cancelled_window_id is invalid, active touch events should be cancelled
@@ -469,15 +435,14 @@
           int64 display_id,
           uint64 focused_window,
           bool parent_drawn,
-          viz.mojom.LocalSurfaceIdAllocation? local_surface_id_allocation);
+          viz.mojom.LocalSurfaceId? local_surface_id);
 
   // See description in ScheduleEmbedForExistingClient() for details on this.
   // Supplied arguments match that of OnEmbed().
-  OnEmbedFromToken(
-      mojo_base.mojom.UnguessableToken token,
+  OnEmbedFromToken(mojo_base.mojom.UnguessableToken token,
       WindowData root,
       int64 display_id,
-      viz.mojom.LocalSurfaceIdAllocation? local_surface_id_allocation);
+                   viz.mojom.LocalSurfaceId? local_surface_id);
 
   // Invoked when the application embedded at |window| is disconnected. In other
   // words the embedded app closes the connection to the server. This is called
@@ -501,22 +466,23 @@
   // Called in response to NewTopLevelWindow() successfully completing.
   // |parent_drawn| is true if the parent of the window is drawn, see
   // OnDrawnStateChanged() for details. |display_id| identifies the display this
-  // window is on.
-  OnTopLevelCreated(
-      uint32 change_id,
+  // window is on. If the top level window has a size, |local_surface_id|
+  // identifies the ID to use to submit CompositorFrames.
+  OnTopLevelCreated(uint32 change_id,
       WindowData data,
       int64 display_id,
       bool parent_drawn,
-      viz.mojom.LocalSurfaceIdAllocation local_surface_id_allocation);
+                    viz.mojom.LocalSurfaceId? local_surface_id);
 
-  // Invoked when a window's bounds have changed. |local_surface_id_allocation|
-  // is only supplied for roots.
-  OnWindowBoundsChanged(
-      uint64 window,
+  // Invoked when a window's bounds have changed. Only the client embedded in
+  // |window| gets a non_empty |local_surface_id|.
+  OnWindowBoundsChanged(uint64 window,
+                        gfx.mojom.Rect old_bounds,
       gfx.mojom.Rect new_bounds,
-      viz.mojom.LocalSurfaceIdAllocation? local_surface_id_allocation);
+                        viz.mojom.LocalSurfaceId? local_surface_id);
 
   OnWindowTransformChanged(uint64 window,
+                           gfx.mojom.Transform old_transform,
                            gfx.mojom.Transform new_transform);
 
   OnTransientWindowAdded(uint64 window_id,
@@ -552,7 +518,7 @@
   OnWindowVisibilityChanged(uint64 window, bool visible);
 
   // Invoked when the opacity of the specified window has changed.
-  OnWindowOpacityChanged(uint64 window, float new_opacity);
+  OnWindowOpacityChanged(uint64 window, float old_opacity, float new_opacity);
 
   // Invoked when the window moves to a new display. This is only called on
   // a top-level window or an embedded root.
@@ -676,19 +642,6 @@
   // the changed info, with window id as its key and new occlusion state as its
   // data. See also TrackOcclusionState on WindowTree.
   OnOcclusionStatesChanged(map<uint64, OcclusionState> occlusion_changes);
-
-  // Cancels the ongoing touch gesture recognitions and clears related gesture
-  // recognition state of the window of |window_id| in the client.
-  CleanupGestureState(uint64 window_id);
-
-  // Called when the window manager may start resizing a window by a user
-  // gesture. For example, if the user clicks on a window-resize handle this may
-  // be called. This is followed by OnWindowResizeLoopEnded() when the loop is
-  // done. This function is only called for top-levels.
-  // OnWindowResizeLoopEnded() may not be called if the window is destroyed
-  // during the loop.
-  OnWindowResizeLoopStarted(uint64 window_id);
-  OnWindowResizeLoopEnded(uint64 window_id);
 };
 
 // Mus provides this interface as a way for clients to connect and obtain a
--- a/services/ws/remote_view_host/server_remote_view_host_unittest.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/ws/remote_view_host/server_remote_view_host_unittest.cc	2019-05-17 18:53:38.052000000 +0300
@@ -6,7 +6,6 @@
 
 #include <memory>
 
-#include "base/bind.h"
 #include "services/ws/window_service_test_setup.h"
 #include "services/ws/window_tree.h"
 #include "services/ws/window_tree_test_helper.h"
--- a/services/ws/test_change_tracker.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/ws/test_change_tracker.cc	2019-05-17 18:53:38.052000000 +0300
@@ -13,7 +13,6 @@
 #include "mojo/public/cpp/bindings/map.h"
 #include "services/ws/common/util.h"
 #include "services/ws/ids.h"
-#include "services/ws/public/mojom/window_tree_constants.mojom.h"
 #include "ui/base/cursor/cursor.h"
 #include "ui/gfx/geometry/point_conversions.h"
 
@@ -109,14 +108,11 @@
 
     case CHANGE_TYPE_NODE_BOUNDS_CHANGED:
       return base::StringPrintf(
-          "BoundsChanged window=%s bounds=%s "
+          "BoundsChanged window=%s old_bounds=%s new_bounds=%s "
           "local_surface_id=%s",
           WindowIdToString(change.window_id).c_str(),
-          change.bounds.ToString().c_str(),
-          change.local_surface_id_allocation
-              ? change.local_surface_id_allocation->local_surface_id()
-                    .ToString()
-                    .c_str()
+          change.bounds.ToString().c_str(), change.bounds2.ToString().c_str(),
+          change.local_surface_id ? change.local_surface_id->ToString().c_str()
               : "(none)");
 
     case CHANGE_TYPE_NODE_HIERARCHY_CHANGED:
@@ -359,14 +355,15 @@
 
 void TestChangeTracker::OnWindowBoundsChanged(
     Id window_id,
+    const gfx::Rect& old_bounds,
     const gfx::Rect& new_bounds,
-    const base::Optional<viz::LocalSurfaceIdAllocation>&
-        local_surface_id_allocation) {
+    const base::Optional<viz::LocalSurfaceId>& local_surface_id) {
   Change change;
   change.type = CHANGE_TYPE_NODE_BOUNDS_CHANGED;
   change.window_id = window_id;
-  change.bounds = new_bounds;
-  change.local_surface_id_allocation = local_surface_id_allocation;
+  change.bounds = old_bounds;
+  change.bounds2 = new_bounds;
+  change.local_surface_id = local_surface_id;
   AddChange(change);
 }
 
@@ -550,19 +547,14 @@
   AddChange(change);
 }
 
-void TestChangeTracker::OnTopLevelCreated(
-    uint32_t change_id,
+void TestChangeTracker::OnTopLevelCreated(uint32_t change_id,
     mojom::WindowDataPtr window_data,
-    int64_t display_id,
-    bool drawn,
-    const viz::LocalSurfaceIdAllocation& local_surface_id_allocation) {
+                                          bool drawn) {
   Change change;
   change.type = CHANGE_TYPE_ON_TOP_LEVEL_CREATED;
   change.change_id = change_id;
   change.window_id = window_data->window_id;
-  change.display_id = display_id;
   change.bool_value = drawn;
-  change.local_surface_id_allocation = local_surface_id_allocation;
   AddChange(change);
 }
 
--- a/services/ws/test_change_tracker.h	2019-05-01 01:22:57.000000000 +0300
+++ b/services/ws/test_change_tracker.h	2019-05-17 18:53:38.052000000 +0300
@@ -91,8 +91,9 @@
   Id window_id2 = 0;
   Id window_id3 = 0;
   gfx::Rect bounds;
+  gfx::Rect bounds2;
   viz::FrameSinkId frame_sink_id;
-  base::Optional<viz::LocalSurfaceIdAllocation> local_surface_id_allocation;
+  base::Optional<viz::LocalSurfaceId> local_surface_id;
   int32_t event_action = 0;
   bool matches_event_observer = false;
   std::string embed_url;
@@ -191,9 +192,9 @@
   void OnTransientWindowRemoved(Id window_id, Id transient_window_id);
   void OnWindowBoundsChanged(
       Id window_id,
+      const gfx::Rect& old_bounds,
       const gfx::Rect& new_bounds,
-      const base::Optional<viz::LocalSurfaceIdAllocation>&
-          local_surface_id_allocation);
+      const base::Optional<viz::LocalSurfaceId>& local_surface_id);
   void OnWindowTransformChanged(Id window_id);
   void OnWindowHierarchyChanged(Id window_id,
                                 Id old_parent_id,
@@ -220,12 +221,9 @@
   void OnWindowFocused(Id window_id);
   void OnWindowCursorChanged(Id window_id, const ui::Cursor& cursor);
   void OnChangeCompleted(uint32_t change_id, bool success);
-  void OnTopLevelCreated(
-      uint32_t change_id,
+  void OnTopLevelCreated(uint32_t change_id,
       mojom::WindowDataPtr window_data,
-      int64_t display_id,
-      bool drawn,
-      const viz::LocalSurfaceIdAllocation& local_surface_id_allocation);
+                         bool drawn);
   void OnDragDropStart(
       const base::flat_map<std::string, std::vector<uint8_t>>& drag_data);
   void OnDragEnter(Id window_id);
--- a/services/ws/test_window_service_delegate.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/ws/test_window_service_delegate.cc	2019-05-17 18:53:38.052000000 +0300
@@ -27,7 +27,6 @@
 }
 
 std::unique_ptr<aura::Window> TestWindowServiceDelegate::NewTopLevel(
-    TopLevelProxyWindow* top_level_proxy_window,
     aura::PropertyConverter* property_converter,
     const base::flat_map<std::string, std::vector<uint8_t>>& properties) {
   std::unique_ptr<aura::Window> window =
@@ -51,7 +50,6 @@
 void TestWindowServiceDelegate::RunWindowMoveLoop(aura::Window* window,
                                                   mojom::MoveLoopSource source,
                                                   const gfx::Point& cursor,
-                                                  int window_component,
                                                   DoneCallback callback) {
   move_loop_callback_ = std::move(callback);
 }
--- a/services/ws/test_window_service_delegate.h	2019-05-01 01:22:57.000000000 +0300
+++ b/services/ws/test_window_service_delegate.h	2019-05-17 18:53:38.052000000 +0300
@@ -51,7 +51,6 @@
 
   // WindowServiceDelegate:
   std::unique_ptr<aura::Window> NewTopLevel(
-      TopLevelProxyWindow* top_level_proxy_window,
       aura::PropertyConverter* property_converter,
       const base::flat_map<std::string, std::vector<uint8_t>>& properties)
       override;
@@ -59,7 +58,6 @@
   void RunWindowMoveLoop(aura::Window* window,
                          mojom::MoveLoopSource source,
                          const gfx::Point& cursor,
-                         int window_component,
                          DoneCallback callback) override;
   void CancelWindowMoveLoop() override;
   void RunDragLoop(aura::Window* window,
--- a/services/ws/test_window_tree_client.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/ws/test_window_tree_client.cc	2019-05-17 18:53:38.056000000 +0300
@@ -72,8 +72,7 @@
     int64_t display_id,
     Id focused_window_id,
     bool drawn,
-    const base::Optional<viz::LocalSurfaceIdAllocation>&
-        local_surface_id_allocation) {
+    const base::Optional<viz::LocalSurfaceId>& local_surface_id) {
   root_window_id_ = root->window_id;
   tree_ = std::move(tree);
   tracker_.OnEmbed(std::move(root), drawn);
@@ -83,13 +82,8 @@
     const base::UnguessableToken& token,
     mojom::WindowDataPtr root,
     int64_t display_id,
-    const base::Optional<viz::LocalSurfaceIdAllocation>&
-        local_surface_id_allocation) {
-  tracker_.OnEmbedFromToken(
-      std::move(root), display_id,
-      local_surface_id_allocation
-          ? local_surface_id_allocation->local_surface_id()
-          : viz::LocalSurfaceId());
+    const base::Optional<viz::LocalSurfaceId>& local_surface_id) {
+  tracker_.OnEmbedFromToken(std::move(root), display_id, local_surface_id);
 }
 
 void TestWindowTreeClient::OnEmbeddedAppDisconnected(Id window_id) {
@@ -116,27 +110,27 @@
     mojom::WindowDataPtr data,
     int64_t display_id,
     bool drawn,
-    const viz::LocalSurfaceIdAllocation& local_surface_id_allocation) {
-  tracker_.OnTopLevelCreated(change_id, std::move(data), display_id, drawn,
-                             local_surface_id_allocation);
+    const base::Optional<viz::LocalSurfaceId>& local_surface_id) {
+  tracker_.OnTopLevelCreated(change_id, std::move(data), drawn);
 }
 
 void TestWindowTreeClient::OnWindowBoundsChanged(
     Id window_id,
+    const gfx::Rect& old_bounds,
     const gfx::Rect& new_bounds,
-    const base::Optional<viz::LocalSurfaceIdAllocation>&
-        local_surface_id_allocation) {
+    const base::Optional<viz::LocalSurfaceId>& local_surface_id) {
   // The bounds of the root may change during startup on Android at random
   // times. As this doesn't matter, and shouldn't impact test exepctations,
   // it is ignored.
   if (window_id == root_window_id_ && !track_root_bounds_changes_)
     return;
-  tracker_.OnWindowBoundsChanged(window_id, new_bounds,
-                                 local_surface_id_allocation);
+  tracker_.OnWindowBoundsChanged(window_id, old_bounds, new_bounds,
+                                 local_surface_id);
 }
 
 void TestWindowTreeClient::OnWindowTransformChanged(
     Id window_id,
+    const gfx::Transform& old_transform,
     const gfx::Transform& new_transform) {
   tracker_.OnWindowTransformChanged(window_id);
 }
@@ -175,6 +169,7 @@
 }
 
 void TestWindowTreeClient::OnWindowOpacityChanged(Id window,
+                                                  float old_opacity,
                                                   float new_opacity) {
   tracker_.OnWindowOpacityChanged(window, new_opacity);
 }
@@ -300,6 +295,4 @@
   tracker_.OnOcclusionStatesChanged(occlusion_changes);
 }
 
-void TestWindowTreeClient::CleanupGestureState(Id window_id) {}
-
 }  // namespace ws
--- a/services/ws/test_window_tree_client.h	2019-05-01 01:22:57.000000000 +0300
+++ b/services/ws/test_window_tree_client.h	2019-05-17 18:53:38.056000000 +0300
@@ -84,36 +84,37 @@
 
   // mojom::WindowTreeClient:
   void OnClientId(uint32_t client_id) override;
-  void OnEmbed(mojom::WindowDataPtr root,
+  void OnEmbed(
+      mojom::WindowDataPtr root,
                mojom::WindowTreePtr tree,
                int64_t display_id,
                Id focused_window_id,
                bool drawn,
-               const base::Optional<viz::LocalSurfaceIdAllocation>&
-                   local_surface_id_allocation) override;
-  void OnEmbedFromToken(const base::UnguessableToken& token,
+      const base::Optional<viz::LocalSurfaceId>& local_surface_id) override;
+  void OnEmbedFromToken(
+      const base::UnguessableToken& token,
                         mojom::WindowDataPtr root,
                         int64_t display_id,
-                        const base::Optional<viz::LocalSurfaceIdAllocation>&
-                            local_surface_id_allocation) override;
+      const base::Optional<viz::LocalSurfaceId>& local_surface_id) override;
   void OnEmbeddedAppDisconnected(Id window_id) override;
   void OnUnembed(Id window_id) override;
   void OnCaptureChanged(Id new_capture_window_id,
                         Id old_capture_window_id) override;
   void OnFrameSinkIdAllocated(Id window_id,
                               const viz::FrameSinkId& frame_sink_id) override;
-  void OnTopLevelCreated(uint32_t change_id,
+  void OnTopLevelCreated(
+      uint32_t change_id,
                          mojom::WindowDataPtr data,
                          int64_t display_id,
                          bool drawn,
-                         const viz::LocalSurfaceIdAllocation&
-                             local_surface_id_allocation) override;
+      const base::Optional<viz::LocalSurfaceId>& local_surface_id) override;
   void OnWindowBoundsChanged(
       Id window_id,
+      const gfx::Rect& old_bounds,
       const gfx::Rect& new_bounds,
-      const base::Optional<viz::LocalSurfaceIdAllocation>&
-          local_surface_id_allocation) override;
+      const base::Optional<viz::LocalSurfaceId>& local_surface_id) override;
   void OnWindowTransformChanged(Id window_id,
+                                const gfx::Transform& old_transform,
                                 const gfx::Transform& new_transform) override;
   void OnTransientWindowAdded(Id window_id, Id transient_window_id) override;
   void OnTransientWindowRemoved(Id window_id, Id transient_window_id) override;
@@ -128,6 +129,7 @@
   void OnWindowDeleted(Id window) override;
   void OnWindowVisibilityChanged(Id window, bool visible) override;
   void OnWindowOpacityChanged(Id window,
+                              float old_opacity,
                               float new_opacity) override;
   void OnWindowDisplayChanged(Id window_id, int64_t display_id) override;
   void OnWindowParentDrawnStateChanged(Id window, bool drawn) override;
@@ -175,9 +177,6 @@
       mojom::ScreenProviderObserverAssociatedRequest observer) override;
   void OnOcclusionStatesChanged(const base::flat_map<Id, mojom::OcclusionState>&
                                     occlusion_changes) override;
-  void CleanupGestureState(Id window_id) override;
-  void OnWindowResizeLoopStarted(uint64_t window_id) override {}
-  void OnWindowResizeLoopEnded(uint64_t window_id) override {}
 
  protected:
   TestChangeTracker tracker_;
--- a/services/ws/test_ws/BUILD.gn	2019-05-01 01:22:57.000000000 +0300
+++ b/services/ws/test_ws/BUILD.gn	2019-05-17 18:53:38.056000000 +0300
@@ -4,6 +4,7 @@
 
 import("//mojo/public/tools/bindings/mojom.gni")
 import("//services/service_manager/public/cpp/service_executable.gni")
+import("//services/service_manager/public/service_manifest.gni")
 
 service_executable("test_ws") {
   testonly = true
@@ -53,19 +54,12 @@
   ]
 }
 
-source_set("manifest") {
+service_manifest("manifest") {
   testonly = true
-  sources = [
-    "test_manifest.cc",
-    "test_manifest.h",
-  ]
-  deps = [
-    ":mojom",
-    "//base",
-    "//services/service_manager/public/cpp",
-    "//services/service_manager/public/mojom",
-    "//services/ws/public/cpp:manifest",
-  ]
+
+  name = "test_ws"
+  source = "manifest.json"
+  packaged_services = [ "//services/ws:manifest" ]
 }
 
 mojom("mojom") {
--- a/services/ws/test_ws/test_window_service.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/ws/test_ws/test_window_service.cc	2019-05-17 18:53:38.056000000 +0300
@@ -88,7 +88,6 @@
 }
 
 std::unique_ptr<aura::Window> TestWindowService::NewTopLevel(
-    TopLevelProxyWindow* top_level_proxy_window,
     aura::PropertyConverter* property_converter,
     const base::flat_map<std::string, std::vector<uint8_t>>& properties) {
   std::unique_ptr<aura::Window> top_level = std::make_unique<aura::Window>(
@@ -113,7 +112,6 @@
 void TestWindowService::RunWindowMoveLoop(aura::Window* window,
                                           mojom::MoveLoopSource source,
                                           const gfx::Point& cursor,
-                                          int window_component,
                                           DoneCallback callback) {
   window_move_done_callback_ = std::move(callback);
 }
--- a/services/ws/test_ws/test_window_service.h	2019-05-01 01:22:57.000000000 +0300
+++ b/services/ws/test_ws/test_window_service.h	2019-05-17 18:53:38.056000000 +0300
@@ -61,14 +61,12 @@
 
   // WindowServiceDelegate:
   std::unique_ptr<aura::Window> NewTopLevel(
-      TopLevelProxyWindow* top_level_proxy_window,
       aura::PropertyConverter* property_converter,
       const base::flat_map<std::string, std::vector<uint8_t>>& properties)
       override;
   void RunWindowMoveLoop(aura::Window* window,
                          mojom::MoveLoopSource source,
                          const gfx::Point& cursor,
-                         int window_component,
                          DoneCallback callback) override;
   void CancelWindowMoveLoop() override;
   void RunDragLoop(aura::Window* window,
--- a/services/ws/window_properties.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/ws/window_properties.cc	2019-05-17 18:53:38.056000000 +0300
@@ -8,6 +8,6 @@
 
 namespace ws {
 
-DEFINE_UI_CLASS_PROPERTY_KEY(bool, kCanFocus, true)
+DEFINE_UI_CLASS_PROPERTY_KEY(bool, kCanFocus, true);
 
 }  // namespace ws
--- a/services/ws/window_server_service_test_base.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/ws/window_server_service_test_base.cc	2019-05-17 18:53:38.056000000 +0300
@@ -8,11 +8,8 @@
 
 #include "base/command_line.h"
 #include "base/memory/ptr_util.h"
-#include "services/service_manager/public/cpp/manifest_builder.h"
 #include "services/ws/common/switches.h"
-#include "services/ws/public/mojom/constants.mojom.h"
-#include "services/ws/public/mojom/window_tree.mojom.h"
-#include "services/ws/test_ws/test_manifest.h"
+#include "services/ws/tests_catalog_source.h"
 #include "ui/gl/gl_switches.h"
 
 namespace ws {
@@ -30,17 +27,7 @@
 }  // namespace
 
 WindowServerServiceTestBase::WindowServerServiceTestBase()
-    : test_service_manager_(
-          {test_ws::GetManifest(),
-           service_manager::ManifestBuilder()
-               .WithServiceName(kTestAppName)
-               .ExposeCapability("ui:window_tree_client",
-                                 service_manager::Manifest::InterfaceList<
-                                     ws::mojom::WindowTreeClient>())
-               .RequireCapability(kTestAppName, "ui:window_tree_client")
-               .RequireCapability(ws::mojom::kServiceName, "app")
-               .RequireCapability("viz", "viz_host")
-               .Build()}),
+    : test_service_manager_(test::CreateTestCatalog()),
       test_service_binding_(
           this,
           test_service_manager_.RegisterTestInstance(kTestAppName)) {
--- a/services/ws/window_server_test_impl.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/ws/window_server_test_impl.cc	2019-05-17 18:53:38.056000000 +0300
@@ -7,7 +7,6 @@
 #include <set>
 #include <utility>
 
-#include "base/bind.h"
 #include "base/threading/thread_task_runner_handle.h"
 #include "components/viz/common/frame_sinks/copy_output_request.h"
 #include "services/ws/client_root.h"
--- a/services/ws/window_service.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/ws/window_service.cc	2019-05-17 18:53:38.056000000 +0300
@@ -258,12 +258,6 @@
   screen_provider_->DisplayMetricsChanged(display, changed_metrics);
 }
 
-void WindowService::OnWindowTreeHostsDisplayIdChanged(
-    const std::set<aura::Window*>& root_windows) {
-  for (WindowTree* tree : window_trees_)
-    tree->OnWindowTreeHostsDisplayIdChanged(root_windows);
-}
-
 std::string WindowService::GetIdForDebugging(aura::Window* window) {
   ProxyWindow* proxy_window = ProxyWindow::GetMayBeNull(window);
   if (!proxy_window)
--- a/services/ws/window_service_delegate.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/ws/window_service_delegate.cc	2019-05-17 18:53:38.056000000 +0300
@@ -16,7 +16,6 @@
 void WindowServiceDelegate::RunWindowMoveLoop(aura::Window* window,
                                               mojom::MoveLoopSource source,
                                               const gfx::Point& cursor,
-                                              int window_component,
                                               DoneCallback callback) {
   std::move(callback).Run(false);
 }
--- a/services/ws/window_service_delegate.h	2019-05-01 01:22:57.000000000 +0300
+++ b/services/ws/window_service_delegate.h	2019-05-17 18:53:38.060000000 +0300
@@ -42,7 +42,6 @@
 
 namespace ws {
 
-class TopLevelProxyWindow;
 class WindowManagerInterface;
 class WindowTree;
 
@@ -52,15 +51,11 @@
   // A client requested a new top-level window. Implementations should create a
   // new window, parenting it in the appropriate container. Return null to
   // reject the request.
-  // |top_level_proxy_window| is owned by the WindowService and may be used by
-  // the delegate to perform operations specific to the window. See
-  // TopLevelProxyWindow for details.
   // NOTE: it is recommended that when clients create a new window they use
   // WindowDelegateImpl as the WindowDelegate of the Window (this must be done
   // by the WindowServiceDelegate, as the Window's delegate can not be changed
   // after creation).
   virtual std::unique_ptr<aura::Window> NewTopLevel(
-      TopLevelProxyWindow* top_level_proxy_window,
       aura::PropertyConverter* property_converter,
       const base::flat_map<std::string, std::vector<uint8_t>>& properties) = 0;
 
@@ -80,7 +75,6 @@
   virtual void RunWindowMoveLoop(aura::Window* window,
                                  mojom::MoveLoopSource source,
                                  const gfx::Point& cursor,
-                                 int window_component,
                                  DoneCallback callback);
 
   // Called to cancel an in-progress window move loop that was started by
@@ -104,10 +98,6 @@
   // Called to cancel an in-progress drag loop that was started by RunDragLoop.
   virtual void CancelDragLoop(aura::Window* window) {}
 
-  // Called to update resize shadow for the window.
-  virtual void SetWindowResizeShadow(aura::Window* window,
-                                     int window_component) {}
-
   // Called to update the text input state of the PlatformWindow associated with
   // |window|. It is a no-op if |window| is not focused.
   virtual void UpdateTextInputState(aura::Window* window,
--- a/services/ws/window_service.h	2019-05-01 01:22:57.000000000 +0300
+++ b/services/ws/window_service.h	2019-05-17 18:53:38.056000000 +0300
@@ -170,13 +170,6 @@
   void OnDisplayMetricsChanged(const display::Display& display,
                                uint32_t changed_metrics);
 
-  // Called after WindowTreeHosts have changed display ids. |root_windows| is
-  // the set of root windows of the changed WindowTreeHosts. Clients that have
-  // windows contained by the root windows needs to be updated with the new
-  // display ids.
-  void OnWindowTreeHostsDisplayIdChanged(
-      const std::set<aura::Window*>& root_windows);
-
   // Returns an id useful for debugging. See ProxyWindow::GetIdForDebugging()
   // for details.
   std::string GetIdForDebugging(aura::Window* window);
--- a/services/ws/window_service_test_setup.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/ws/window_service_test_setup.cc	2019-05-17 18:53:38.060000000 +0300
@@ -4,7 +4,6 @@
 
 #include "services/ws/window_service_test_setup.h"
 
-#include "base/bind.h"
 #include "services/ws/embedding.h"
 #include "services/ws/event_queue.h"
 #include "services/ws/event_queue_test_helper.h"
@@ -140,9 +139,6 @@
   ui::InitializeContextFactoryForTests(enable_pixel_output, &context_factory,
                                        &context_factory_private);
   aura_test_helper_.SetUp(context_factory, context_factory_private);
-  // The resize throttle may interfere with tests, so disable it. If specific
-  // tests want the throttle, they can enable it.
-  aura::Env::GetInstance()->set_throttle_input_on_resize_for_testing(false);
   scoped_capture_client_ = std::make_unique<wm::ScopedCaptureClient>(
       aura_test_helper_.root_window());
   service_ =
--- a/services/ws/window_service_unittest.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/ws/window_service_unittest.cc	2019-05-17 18:53:38.060000000 +0300
@@ -6,7 +6,6 @@
 
 #include <memory>
 
-#include "base/bind.h"
 #include "base/run_loop.h"
 #include "services/service_manager/public/cpp/connector.h"
 #include "services/service_manager/public/cpp/test/test_connector_factory.h"
--- a/services/ws/window_tree.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/ws/window_tree.cc	2019-05-17 18:53:38.060000000 +0300
@@ -9,7 +9,6 @@
 #include "base/auto_reset.h"
 #include "base/bind.h"
 #include "base/threading/thread_task_runner_handle.h"
-#include "base/trace_event/trace_event.h"
 #include "base/unguessable_token.h"
 #include "components/viz/common/surfaces/parent_local_surface_id_allocator.h"
 #include "components/viz/common/surfaces/surface_info.h"
@@ -24,7 +23,6 @@
 #include "services/ws/event_observer_helper.h"
 #include "services/ws/proxy_window.h"
 #include "services/ws/public/cpp/property_type_converters.h"
-#include "services/ws/top_level_proxy_window_impl.h"
 #include "services/ws/topmost_window_observer.h"
 #include "services/ws/window_delegate_impl.h"
 #include "services/ws/window_manager_interface.h"
@@ -33,7 +31,6 @@
 #include "services/ws/window_service_observer.h"
 #include "ui/aura/client/aura_constants.h"
 #include "ui/aura/client/transient_window_client.h"
-#include "ui/aura/client/window_parenting_client.h"
 #include "ui/aura/env.h"
 #include "ui/aura/mus/os_exchange_data_provider_mus.h"
 #include "ui/aura/mus/property_converter.h"
@@ -44,7 +41,6 @@
 #include "ui/base/cursor/cursor.h"
 #include "ui/base/dragdrop/drag_drop_types.h"
 #include "ui/base/dragdrop/os_exchange_data.h"
-#include "ui/base/hit_test.h"
 #include "ui/compositor/layer.h"
 #include "ui/compositor/layer_type.h"
 #include "ui/display/display.h"
@@ -149,10 +145,10 @@
   const ClientWindowId focused_window_id =
       root->HasFocus() ? ClientWindowIdForWindow(root) : ClientWindowId();
   const bool drawn = root->IsVisible() && root->GetHost();
-  window_tree_client_->OnEmbed(
-      WindowToWindowData(root), std::move(window_tree_ptr), display_id,
-      ClientWindowIdToTransportId(focused_window_id), drawn,
-      proxy_window->local_surface_id_allocation());
+  window_tree_client_->OnEmbed(WindowToWindowData(root),
+                               std::move(window_tree_ptr), display_id,
+                               ClientWindowIdToTransportId(focused_window_id),
+                               drawn, proxy_window->local_surface_id());
 
   // Reset the frame sink id locally (after calling OnEmbed()). This is
   // needed so that the id used by the client matches the id used locally.
@@ -169,8 +165,8 @@
                                    const ui::Event& event) {
   // As gesture recognition runs in the client, GestureEvents should not be
   // forwarded. ProxyWindow's event processing should ensure no GestureEvents
-  // are sent. Some pinch events are allowed.
-  DCHECK(!event.IsGestureEvent() || event.IsPinchEvent());
+  // are sent.
+  DCHECK(!event.IsGestureEvent());
 
   const uint32_t event_id = GenerateEventAckId();
   auto* in_flight_event_queue =
@@ -216,9 +212,6 @@
            << ProxyWindow::GetMayBeNull(window)->GetIdForDebugging()
            << " event_type=" << ui::EventTypeName(event.type())
            << " event_id=" << event_id;
-  TRACE_EVENT_ASYNC_BEGIN1("ui", "WindowTree::SendEventToClient", event_id,
-                           "event_type",
-                           ui::EventTypeName(event_to_send->type()));
   window_tree_client_->OnWindowInputEvent(
       event_id, TransportIdForWindow(window), display_id,
       std::move(event_to_send), matches_event_observer);
@@ -299,9 +292,9 @@
 
   const int64_t display_id =
       display::Screen::GetScreen()->GetDisplayNearestWindow(window).id();
-  window_tree_client_->OnEmbedFromToken(
-      token, WindowToWindowData(window), display_id,
-      proxy_window->local_surface_id_allocation());
+  window_tree_client_->OnEmbedFromToken(token, WindowToWindowData(window),
+                                        display_id,
+                                        proxy_window->local_surface_id());
 
   // Reset the frame sink id locally (after calling OnEmbedFromToken()). This is
   // needed so that the id used by the client matches the id used locally.
@@ -353,11 +346,6 @@
   return client_root_location;
 }
 
-void WindowTree::CleanupGestureState(aura::Window* window) {
-  DCHECK(IsWindowKnown(window));
-  window_tree_client_->CleanupGestureState(TransportIdForWindow(window));
-}
-
 ClientRoot* WindowTree::CreateClientRoot(aura::Window* window,
                                          bool is_top_level) {
   DCHECK(window);
@@ -674,6 +662,10 @@
                         ClientWindowIdFromTransportId(transport_window_id));
 }
 
+bool WindowTree::IsLocalSurfaceIdAssignedByClient(aura::Window* window) {
+  return !IsTopLevel(window) && IsClientCreatedWindow(window);
+}
+
 std::vector<mojom::WindowDataPtr> WindowTree::WindowsToWindowDatas(
     const std::vector<aura::Window*>& windows) {
   std::vector<mojom::WindowDataPtr> array(windows.size());
@@ -693,7 +685,6 @@
     parent = nullptr;
   if (!IsWindowKnown(transient_parent))
     transient_parent = nullptr;
-  const bool is_top_level = IsTopLevel(window);
   mojom::WindowDataPtr window_data(mojom::WindowData::New());
   window_data->parent_id =
       parent ? TransportIdForWindow(parent) : kInvalidTransportId;
@@ -703,12 +694,10 @@
       transient_parent ? TransportIdForWindow(transient_parent)
                        : kInvalidTransportId;
   window_data->bounds =
-      is_top_level ? window->GetBoundsInScreen() : window->bounds();
+      IsTopLevel(window) ? window->GetBoundsInScreen() : window->bounds();
   window_data->properties =
       window_service_->property_converter()->GetTransportProperties(window);
-  window_data->visible = (!IsClientRootWindow(window) || is_top_level)
-                             ? window->TargetVisibility()
-                             : window->IsVisible();
+  window_data->visible = window->TargetVisibility();
   return window_data;
 }
 
@@ -764,17 +753,6 @@
   window_tree_client_->OnOcclusionStatesChanged(occlusion_changes);
 }
 
-void WindowTree::OnWindowTreeHostsDisplayIdChanged(
-    const std::set<aura::Window*>& root_windows) {
-  for (auto& client_root : client_roots_) {
-    aura::Window* root_window = client_root->window()->GetRootWindow();
-    if (root_windows.find(root_window) == root_windows.end())
-      continue;
-
-    client_root->OnWindowTreeHostDisplayIdChanged();
-  }
-}
-
 bool WindowTree::NewWindowImpl(
     const ClientWindowId& client_window_id,
     const std::map<std::string, std::vector<uint8_t>>& properties) {
@@ -1002,19 +980,6 @@
   }
 
   ::wm::AddTransientChild(parent, transient);
-
-  // Transients are placed in a container by way of the WindowParentingClient.
-  // This code is simular to NativeWidgetAura, where it calls to
-  // ParentWindowWithContext().
-  if (IsTopLevel(parent) && parent->GetRootWindow() && IsTopLevel(transient) &&
-      transient->GetRootWindow()) {
-    aura::client::WindowParentingClient* client =
-        aura::client::GetWindowParentingClient(parent);
-    aura::Window* default_parent =
-        client->GetDefaultParent(transient, transient->GetBoundsInScreen());
-    if (default_parent && transient->parent() != default_parent)
-      default_parent->AddChild(transient);
-  }
   return true;
 }
 
@@ -1106,8 +1071,7 @@
     const base::Optional<std::vector<uint8_t>>& value) {
   aura::Window* window = GetWindowByClientId(window_id);
   DVLOG(3) << "SetWindowProperty client=" << client_id_
-           << " client window_id=" << window_id.ToString()
-           << " property=" << name;
+           << " client window_id=" << window_id.ToString();
   if (!window) {
     DVLOG(1) << "SetWindowProperty failed (no window)";
     return false;
@@ -1200,15 +1164,12 @@
 bool WindowTree::SetWindowBoundsImpl(
     const ClientWindowId& window_id,
     const gfx::Rect& bounds,
-    const base::Optional<viz::LocalSurfaceIdAllocation>&
-        local_surface_id_allocation) {
+    const base::Optional<viz::LocalSurfaceId>& local_surface_id) {
   aura::Window* window = GetWindowByClientId(window_id);
 
   DVLOG(3) << "SetWindowBounds window_id=" << window_id
            << " bounds=" << bounds.ToString() << " local_surface_id="
-           << (local_surface_id_allocation
-                   ? local_surface_id_allocation->ToString()
-                   : "null");
+           << (local_surface_id ? local_surface_id->ToString() : "null");
 
   if (!window) {
     DVLOG(1) << "SetWindowBounds failed (invalid window id)";
@@ -1222,13 +1183,10 @@
   }
 
   ProxyWindow* proxy_window = ProxyWindow::GetMayBeNull(window);
-  DCHECK(proxy_window);  // Earlier checks mean this should be true.
-  const bool local_surface_id_changed =
-      proxy_window->local_surface_id_allocation() !=
-      local_surface_id_allocation;
-
   const gfx::Rect original_bounds =
       IsTopLevel(window) ? window->GetBoundsInScreen() : window->bounds();
+  const bool local_surface_id_changed =
+      proxy_window->local_surface_id() != local_surface_id;
 
   if (original_bounds == bounds && !local_surface_id_changed)
     return true;
@@ -1236,27 +1194,28 @@
   ClientChange change(property_change_tracker_.get(), window,
                       ClientChangeType::kBounds);
 
-  ClientRoot* client_root = GetClientRootForWindow(window);
+  if (IsLocalSurfaceIdAssignedByClient(window))
+    proxy_window->set_local_surface_id(local_surface_id);
+
   if (IsTopLevel(window)) {
-    // If IsTopLevel() returns true, there should be a ClientRoot.
-    DCHECK(client_root);
-    if (local_surface_id_allocation &&
-        local_surface_id_allocation->local_surface_id().embed_token() !=
-            proxy_window->local_surface_id_allocation()
-                ->local_surface_id()
-                .embed_token()) {
-      DVLOG(1) << "SetWindowBounds failed (embed token changed)";
-      return false;
-    }
-    return client_root->SetBoundsInScreenFromClient(
-        bounds, local_surface_id_allocation);
-  }
-  proxy_window->set_local_surface_id_allocation(local_surface_id_allocation);
+    display::Display dst_display =
+        display::Screen::GetScreen()->GetDisplayMatching(bounds);
+    window->SetBoundsInScreen(bounds, dst_display);
+  } else {
   window->SetBounds(bounds);
-
+  }
   if (!change.window())
     return true;  // Return value doesn't matter if window destroyed.
 
+  if (IsClientRootWindow(window)) {
+    // ClientRoot handles notification in this case. Note that this
+    // unconditionally returns false, because the LocalSurfaceId changes with
+    // the bounds. Returning false ensures the client applies the LocalSurfaceId
+    // assigned by ClientRoot and sent to the client in
+    // ClientRoot::OnWindowBoundsChanged().
+    return false;
+  }
+
   if (window->bounds() == original_bounds) {
     if (local_surface_id_changed) {
       // If the bounds didn't change, but the LocalSurfaceId did, then the
@@ -1274,8 +1233,7 @@
   }
 
   if (window->bounds() == bounds &&
-      proxy_window->local_surface_id_allocation() ==
-          local_surface_id_allocation) {
+      proxy_window->local_surface_id() == local_surface_id) {
     return true;
   }
 
@@ -1283,24 +1241,9 @@
   // Tell the client the new value, and return false, which triggers the client
   // to use the value supplied to OnWindowBoundsChanged().
   window_tree_client_->OnWindowBoundsChanged(TransportIdForWindow(window),
-                                             window->bounds(),
-                                             local_surface_id_allocation);
-  return false;
-}
-
-bool WindowTree::SetWindowTransformImpl(const ClientWindowId& window_id,
-                                        const gfx::Transform& transform) {
-  DVLOG(3) << "SetWindowTransform window_id=" << window_id;
-  aura::Window* window = GetWindowByClientId(window_id);
-  // This doesn't allow setting the transform on top-levels as that may conflict
-  // with top-level animations done by the window-manager. Additionally the
-  // window-manager is really the one that should be animating top-levels.
-  if (!window || !IsClientCreatedWindow(window) || IsTopLevel(window)) {
-    DVLOG(1) << "SetWindowTransform failed (invalid window)";
+                                             original_bounds, window->bounds(),
+                                             local_surface_id);
     return false;
-  }
-  window->SetTransform(transform);
-  return true;
 }
 
 bool WindowTree::ReorderWindowImpl(const ClientWindowId& window_id,
@@ -1463,9 +1406,7 @@
 
 void WindowTree::OnWindowVisibilityChanging(aura::Window* window,
                                             bool visible) {
-  // Visibility changes for top-levels are handled by ClientRoot.
-  if (IsTopLevel(window) ||
-      property_change_tracker_->IsProcessingChangeForWindow(
+  if (property_change_tracker_->IsProcessingChangeForWindow(
           window, ClientChangeType::kVisibility)) {
     return;
   }
@@ -1541,13 +1482,9 @@
     window_tree_client_->OnChangeCompleted(change_id, false);
     return;
   }
-  std::unique_ptr<TopLevelProxyWindowImpl> top_level_proxy_window =
-      std::make_unique<TopLevelProxyWindowImpl>(window_tree_client_,
-                                                transport_window_id);
   std::unique_ptr<aura::Window> top_level_ptr =
       window_service_->delegate()->NewTopLevel(
-          top_level_proxy_window.get(), window_service_->property_converter(),
-          properties);
+          window_service_->property_converter(), properties);
   if (!top_level_ptr) {
     DVLOG(1) << "NewTopLevelWindow failed (delegate window creation failed)";
     window_tree_client_->OnChangeCompleted(change_id, false);
@@ -1557,22 +1494,17 @@
   const bool is_top_level = true;
   aura::Window* top_level = AddClientCreatedWindow(
       client_window_id, is_top_level, std::move(top_level_ptr));
-  ProxyWindow* proxy_window = ProxyWindow::GetMayBeNull(top_level);
-  proxy_window->SetTopLevelProxyWindow(std::move(top_level_proxy_window));
-  proxy_window->set_frame_sink_id(client_window_id);
+  ProxyWindow* top_level_proxy_window = ProxyWindow::GetMayBeNull(top_level);
+  top_level_proxy_window->set_frame_sink_id(client_window_id);
   const int64_t display_id =
       display::Screen::GetScreen()->GetDisplayNearestWindow(top_level).id();
   // This passes null for the mojom::WindowTreePtr because the client has
   // already been given the mojom::WindowTreePtr that is backed by this
   // WindowTree.
-  ClientRoot* client_root = CreateClientRoot(top_level, is_top_level);
-  client_root->RegisterVizEmbeddingSupport();
-  proxy_window->top_level_proxy_window()->set_client_root(client_root);
-  // Creating the ClientRoot should trigger setting a LocalSurfaceIdAllocation.
-  DCHECK(proxy_window->local_surface_id_allocation());
+  CreateClientRoot(top_level, is_top_level)->RegisterVizEmbeddingSupport();
   window_tree_client_->OnTopLevelCreated(
       change_id, WindowToWindowData(top_level), display_id,
-      top_level->IsVisible(), *(proxy_window->local_surface_id_allocation()));
+      top_level->IsVisible(), top_level_proxy_window->local_surface_id());
 }
 
 void WindowTree::DeleteWindow(uint32_t change_id, Id transport_window_id) {
@@ -1608,66 +1540,19 @@
     uint32_t change_id,
     Id window_id,
     const gfx::Rect& bounds,
-    const base::Optional<viz::LocalSurfaceIdAllocation>&
-        local_surface_id_allocation) {
+    const base::Optional<viz::LocalSurfaceId>& local_surface_id) {
   window_tree_client_->OnChangeCompleted(
       change_id, SetWindowBoundsImpl(MakeClientWindowId(window_id), bounds,
-                                     local_surface_id_allocation));
-}
-
-void WindowTree::UpdateLocalSurfaceIdFromChild(
-    Id transport_window_id,
-    const viz::LocalSurfaceIdAllocation& local_surface_id_allocation) {
-  const ClientWindowId window_id = MakeClientWindowId(transport_window_id);
-  aura::Window* window = GetWindowByClientId(window_id);
-
-  DVLOG(3) << "UpdateLocalSurfaceIdFromChild window_id=" << window_id
-           << " local_surface_id=" << local_surface_id_allocation.ToString();
-
-  ClientRoot* client_root = GetClientRootForWindow(window);
-  if (!client_root || !client_root->ShouldAssignLocalSurfaceId()) {
-    DVLOG(1) << "UpdateLocalSurfaceIdFromChild failed (invalid window id)";
-    return;
-  }
-
-  ProxyWindow* proxy_window = ProxyWindow::GetMayBeNull(window);
-  DCHECK(window);  // Earlier checks ensure this is non-null.
-  if (local_surface_id_allocation.local_surface_id().embed_token() !=
-      proxy_window->local_surface_id_allocation()
-          ->local_surface_id()
-          .embed_token()) {
-    DVLOG(1) << "UpdateLocalSurfaceIdFromChild failed (embed token changed)";
-    return;
-  }
-  client_root->UpdateLocalSurfaceIdFromChild(local_surface_id_allocation);
-}
-
-void WindowTree::AllocateLocalSurfaceId(Id transport_window_id) {
-  const ClientWindowId window_id = MakeClientWindowId(transport_window_id);
-  aura::Window* window = GetWindowByClientId(window_id);
-  DVLOG(3) << "AllocateLocalSurfaceId client window_id="
-           << window_id.ToString();
-  if (!window) {
-    DVLOG(1) << "AllocateLocalSurfaceId failed (invalid window id)";
-    return;
-  }
-  if (!IsTopLevel(window) &&
-      (!IsClientRootWindow(window) ||
-       ProxyWindow::GetMayBeNull(window)->owning_window_tree() != nullptr)) {
-    DVLOG(1) << "AllocateLocalSurfaceId failed (must be root or top-level)";
-    return;
-  }
-  ClientRoot* client_root = GetClientRootForWindow(window);
-  DCHECK(client_root);
-  client_root->AllocateLocalSurfaceIdAndNotifyClient();
+                                     local_surface_id));
 }
 
 void WindowTree::SetWindowTransform(uint32_t change_id,
-                                    Id transport_window_id,
+                                    Id window_id,
                                     const gfx::Transform& transform) {
-  window_tree_client_->OnChangeCompleted(
-      change_id, SetWindowTransformImpl(MakeClientWindowId(transport_window_id),
-                                        transform));
+  // NOTE: Tests may time out if they trigger this NOTIMPLEMENTED because
+  // the change is not ack'd. The code under test may need to change to
+  // avoid triggering window transforms outside the window manager.
+  NOTIMPLEMENTED_LOG_ONCE();
 }
 
 void WindowTree::SetClientArea(
@@ -1715,27 +1600,6 @@
                                  MakeInsetsPositive(touch));
 }
 
-void WindowTree::SetShape(Id transport_window_id,
-                          const std::vector<gfx::Rect>& shape) {
-  const ClientWindowId window_id = MakeClientWindowId(transport_window_id);
-  DVLOG(3) << "SetShape client_window_id=" << window_id.ToString()
-           << " #shape=" << shape.size();
-  aura::Window* window = GetWindowByClientId(window_id);
-  if (!window) {
-    DVLOG(1) << "SetShape failed (invalid window id)";
-    return;
-  }
-  if (!IsClientCreatedWindow(window)) {
-    DVLOG(1) << "SetShape failed (access denied)";
-    return;
-  }
-  window->layer()->SetAlphaShape(
-      shape.empty() ? nullptr
-                    : std::make_unique<std::vector<gfx::Rect>>(shape));
-  ProxyWindow* proxy_window = ProxyWindow::GetMayBeNull(window);
-  proxy_window->SetShape(shape);
-}
-
 void WindowTree::AttachFrameSinkId(Id transport_window_id,
                                    const viz::FrameSinkId& f) {
   if (!f.is_valid()) {
@@ -2084,7 +1948,6 @@
 
   for (WindowServiceObserver& observer : window_service_->observers())
     observer.OnClientAckedEvent(client_id_, event_id);
-  TRACE_EVENT_ASYNC_END0("ui", "WindowTree::SendEventToClient", event_id);
 }
 
 void WindowTree::DeactivateWindow(Id transport_window_id) {
@@ -2148,12 +2011,9 @@
 void WindowTree::PerformWindowMove(uint32_t change_id,
                                    Id transport_window_id,
                                    mojom::MoveLoopSource source,
-                                   const gfx::Point& cursor,
-                                   int hit_test) {
+                                   const gfx::Point& cursor) {
   DVLOG(3) << "PerformWindowMove id="
-           << MakeClientWindowId(transport_window_id).ToString()
-           << " source=" << source << " cursor=" << cursor.ToString()
-           << " hit_test=" << hit_test;
+           << MakeClientWindowId(transport_window_id).ToString();
   aura::Window* window = GetWindowByTransportId(transport_window_id);
   if (!IsClientCreatedWindow(window) || !IsTopLevel(window) ||
       !window->IsVisible() || window_moving_) {
@@ -2171,7 +2031,7 @@
 
   window_moving_ = window;
   window_service_->delegate()->RunWindowMoveLoop(
-      window, source, cursor, hit_test,
+      window, source, cursor,
       base::BindOnce(&WindowTree::OnPerformWindowMoveDone,
                      weak_factory_.GetWeakPtr(), change_id));
 }
@@ -2229,19 +2089,9 @@
   // Clear |pending_drag_source_window_id_| to cancel posted drag loop task.
   pending_drag_source_window_id_ = kInvalidTransportId;
 
-  aura::Window* window = GetWindowByTransportId(window_id);
-  if (!window) {
-    DVLOG(1) << "CancelDragDrop failed (no window)";
-    return;
-  }
-
-  if (!IsClientCreatedWindow(window)) {
-    DVLOG(1) << "CancelDragDrop failed (access denied)";
-    return;
-  }
-
   // Cancel the current drag loop if it is running.
-  window_service_->delegate()->CancelDragLoop(window);
+  window_service_->delegate()->CancelDragLoop(
+      GetWindowByTransportId(window_id));
 }
 
 void WindowTree::ObserveTopmostWindow(mojom::MoveLoopSource source,
@@ -2275,23 +2125,6 @@
   topmost_window_observer_.reset();
 }
 
-void WindowTree::SetWindowResizeShadow(Id window_id, int hit_test) {
-  DVLOG(3) << "SetWindowResizeShadow id="
-           << MakeClientWindowId(window_id).ToString()
-           << " hit_test=" << hit_test;
-  aura::Window* window = GetWindowByTransportId(window_id);
-  if (!IsClientCreatedWindow(window) || !IsTopLevel(window) ||
-      !window->IsVisible()) {
-    DVLOG(1) << "SetWindowResizeShadow failed (invalid window)";
-    return;
-  }
-  if (hit_test != HTNOWHERE && !ui::IsResizingComponent(hit_test)) {
-    DVLOG(1) << "SetWindowResizeShadow failed (invalid hit_test)";
-    return;
-  }
-  window_service_->delegate()->SetWindowResizeShadow(window, hit_test);
-}
-
 void WindowTree::CancelActiveTouchesExcept(Id not_cancelled_window_id) {
   if (connection_type_ == ConnectionType::kEmbedding) {
     DVLOG(1) << "CancelActiveTouchesExcept failed (access denied)";
--- a/services/ws/window_tree_client_unittest.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/ws/window_tree_client_unittest.cc	2019-05-17 18:53:38.060000000 +0300
@@ -285,24 +285,23 @@
       wait_state_->run_loop.Quit();
     }
   }
-  void OnEmbed(WindowDataPtr root,
+  void OnEmbed(
+      WindowDataPtr root,
                mojom::WindowTreePtr tree,
                int64_t display_id,
                Id focused_window_id,
                bool drawn,
-               const base::Optional<viz::LocalSurfaceIdAllocation>&
-                   local_surface_id_allocation) override {
+      const base::Optional<viz::LocalSurfaceId>& local_surface_id) override {
     TestWindowTreeClient::OnEmbed(std::move(root), std::move(tree), display_id,
-                                  focused_window_id, drawn,
-                                  local_surface_id_allocation);
+                                  focused_window_id, drawn, local_surface_id);
     if (embed_run_loop_)
       embed_run_loop_->Quit();
   }
-  void OnEmbedFromToken(const base::UnguessableToken& token,
+  void OnEmbedFromToken(
+      const base::UnguessableToken& token,
                         mojom::WindowDataPtr root,
                         int64_t display_id,
-                        const base::Optional<viz::LocalSurfaceIdAllocation>&
-                            local_surface_id_allocation) override {}
+      const base::Optional<viz::LocalSurfaceId>& local_surface_id) override {}
   void OnEmbeddedAppDisconnected(Id window_id) override {
     tracker()->OnEmbeddedAppDisconnected(window_id);
   }
@@ -313,29 +312,29 @@
   }
   void OnFrameSinkIdAllocated(Id window_id,
                               const viz::FrameSinkId& frame_sink_id) override {}
-  void OnTopLevelCreated(uint32_t change_id,
+  void OnTopLevelCreated(
+      uint32_t change_id,
                          mojom::WindowDataPtr data,
                          int64_t display_id,
                          bool drawn,
-                         const viz::LocalSurfaceIdAllocation&
-                             local_surface_id_allocation) override {
-    tracker()->OnTopLevelCreated(change_id, std::move(data), display_id, drawn,
-                                 local_surface_id_allocation);
+      const base::Optional<viz::LocalSurfaceId>& local_surface_id) override {
+    tracker()->OnTopLevelCreated(change_id, std::move(data), drawn);
   }
   void OnWindowBoundsChanged(
       Id window_id,
+      const gfx::Rect& old_bounds,
       const gfx::Rect& new_bounds,
-      const base::Optional<viz::LocalSurfaceIdAllocation>&
-          local_surface_id_allocation) override {
+      const base::Optional<viz::LocalSurfaceId>& local_surface_id) override {
     // The bounds of the root may change during startup on Android at random
     // times. As this doesn't matter, and shouldn't impact test exepctations,
     // it is ignored.
     if (window_id == root_window_id_ && !track_root_bounds_changes_)
       return;
-    tracker()->OnWindowBoundsChanged(window_id, new_bounds,
-                                     local_surface_id_allocation);
+    tracker()->OnWindowBoundsChanged(window_id, old_bounds, new_bounds,
+                                     local_surface_id);
   }
   void OnWindowTransformChanged(Id window_id,
+                                const gfx::Transform& old_transform,
                                 const gfx::Transform& new_transform) override {
     tracker()->OnWindowTransformChanged(window_id);
   }
@@ -364,6 +363,7 @@
     tracker()->OnWindowVisibilityChanged(window, visible);
   }
   void OnWindowOpacityChanged(Id window,
+                              float old_opacity,
                               float new_opacity) override {
     tracker()->OnWindowOpacityChanged(window, new_opacity);
   }
@@ -1226,10 +1226,10 @@
 
   viz::ParentLocalSurfaceIdAllocator allocator;
   allocator.GenerateId();
-  viz::LocalSurfaceIdAllocation local_surface_id_allocation =
-      allocator.GetCurrentLocalSurfaceIdAllocation();
+  viz::LocalSurfaceId local_surface_id =
+      allocator.GetCurrentLocalSurfaceIdAllocation().local_surface_id();
   wt1()->SetWindowBounds(10, window_1_1, gfx::Rect(0, 0, 100, 100),
-                         local_surface_id_allocation);
+                         local_surface_id);
   ASSERT_TRUE(wt_client1()->WaitForChangeCompleted(10));
 
   wt_client2_->WaitForChangeCount(1);
@@ -1238,7 +1238,7 @@
       BuildWindowId(client_id_1(), ClientWindowIdFromTransportId(window_1_1));
   EXPECT_EQ("BoundsChanged window=" + IdToString(window11_in_wt2) +
                 " old_bounds=0,0 0x0 new_bounds=0,0 100x100 local_surface_id=" +
-                local_surface_id_allocation.ToString(),
+                local_surface_id.ToString(),
             SingleChangeToDescription(*changes2()));
 
   // Should not be possible to change the bounds of a window created by another
--- a/services/ws/window_tree.h	2019-05-01 01:22:57.000000000 +0300
+++ b/services/ws/window_tree.h	2019-05-17 18:53:38.060000000 +0300
@@ -125,11 +125,6 @@
   // Notifies the client that the occlusion state of |windows| have changed.
   void SendOcclusionStates(const std::set<aura::Window*>& windows);
 
-  // Called from WindowService to update display id of ClientRoots contained by
-  // the root windows.
-  void OnWindowTreeHostsDisplayIdChanged(
-      const std::set<aura::Window*>& root_windows);
-
   WindowService* window_service() { return window_service_; }
 
   // Returns the ClientWindowId for the window the client previously supplied
@@ -171,11 +166,6 @@
   gfx::PointF ConvertRootLocationForClient(aura::Window* window,
                                            const gfx::PointF& root_location);
 
-  // Sends CleanupGestureState mojo call for |window| to the window tree client.
-  void CleanupGestureState(aura::Window* window);
-
-  bool IsMovingWindow() const { return window_moving_ != nullptr; }
-
  private:
   friend class ClientRoot;
   // TODO(sky): WindowTree should be refactored such that it is not
@@ -309,6 +299,11 @@
   // mapping, there may not be a window with the returned id.
   ClientWindowId MakeClientWindowId(Id transport_window_id) const;
 
+  // Returns true if the local-surface id for |window| is assigned by this
+  // client. A return value of false means the LocalSurfaceId is assigned by
+  // either another client, or by the WindowService itself.
+  bool IsLocalSurfaceIdAssignedByClient(aura::Window* window);
+
   std::vector<mojom::WindowDataPtr> WindowsToWindowDatas(
       const std::vector<aura::Window*>& windows);
   mojom::WindowDataPtr WindowToWindowData(aura::Window* window);
@@ -350,12 +345,10 @@
                  mojom::WindowTreeClient* window_tree_client,
                  uint32_t flags);
   bool SetWindowOpacityImpl(const ClientWindowId& window_id, float opacity);
-  bool SetWindowBoundsImpl(const ClientWindowId& window_id,
+  bool SetWindowBoundsImpl(
+      const ClientWindowId& window_id,
                            const gfx::Rect& bounds,
-                           const base::Optional<viz::LocalSurfaceIdAllocation>&
-                               local_surface_id_allocation);
-  bool SetWindowTransformImpl(const ClientWindowId& window_id,
-                              const gfx::Transform& transform);
+      const base::Optional<viz::LocalSurfaceId>& local_surface_id);
   bool ReorderWindowImpl(const ClientWindowId& window_id,
                          const ClientWindowId& relative_window_id,
                          mojom::OrderDirection direction);
@@ -398,17 +391,13 @@
   void ReleaseCapture(uint32_t change_id, Id transport_window_id) override;
   void ObserveEventTypes(
       const std::vector<ui::mojom::EventType>& types) override;
-  void SetWindowBounds(uint32_t change_id,
+  void SetWindowBounds(
+      uint32_t change_id,
                        Id window_id,
                        const gfx::Rect& bounds,
-                       const base::Optional<viz::LocalSurfaceIdAllocation>&
-                           local_surface_id_allocation) override;
-  void UpdateLocalSurfaceIdFromChild(Id transport_window_id,
-                                     const viz::LocalSurfaceIdAllocation&
-                                         local_surface_id_allocation) override;
-  void AllocateLocalSurfaceId(Id transport_window_id) override;
+      const base::Optional<viz::LocalSurfaceId>& local_surface_id) override;
   void SetWindowTransform(uint32_t change_id,
-                          Id transport_window_id,
+                          Id window_id,
                           const gfx::Transform& transform) override;
   void SetClientArea(Id transport_window_id,
                      const gfx::Insets& insets,
@@ -417,8 +406,6 @@
   void SetHitTestInsets(Id transport_window_id,
                         const gfx::Insets& mouse,
                         const gfx::Insets& touch) override;
-  void SetShape(Id transport_window_id,
-                const std::vector<gfx::Rect>& shape) override;
   void AttachFrameSinkId(Id transport_window_id,
                          const viz::FrameSinkId& f) override;
   void UnattachFrameSinkId(Id transport_window_id) override;
@@ -491,8 +478,7 @@
   void PerformWindowMove(uint32_t change_id,
                          Id transport_window_id,
                          mojom::MoveLoopSource source,
-                         const gfx::Point& cursor,
-                         int hit_test) override;
+                         const gfx::Point& cursor) override;
   void CancelWindowMove(Id transport_window_id) override;
   void PerformDragDrop(
       uint32_t change_id,
@@ -507,7 +493,6 @@
   void ObserveTopmostWindow(mojom::MoveLoopSource source,
                             Id window_id) override;
   void StopObservingTopmostWindow() override;
-  void SetWindowResizeShadow(Id window_id, int hit_test) override;
   void CancelActiveTouchesExcept(Id not_cancelled_window_id) override;
   void CancelActiveTouches(Id window_id) override;
   void TransferGestureEventsTo(Id current_id,
--- a/services/ws/window_tree_test_helper.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/ws/window_tree_test_helper.cc	2019-05-17 18:53:38.060000000 +0300
@@ -71,29 +71,20 @@
       direction);
 }
 
-bool WindowTreeTestHelper::SetTransform(aura::Window* window,
-                                        const gfx::Transform& transform) {
-  return window_tree_->SetWindowTransformImpl(ClientWindowIdForWindow(window),
-                                              transform);
-}
-
 bool WindowTreeTestHelper::SetWindowBounds(
     aura::Window* window,
     const gfx::Rect& bounds,
-    const base::Optional<viz::LocalSurfaceIdAllocation>&
-        local_surface_id_allocation) {
+    const base::Optional<viz::LocalSurfaceId>& local_surface_id) {
   return window_tree_->SetWindowBoundsImpl(ClientWindowIdForWindow(window),
-                                           bounds, local_surface_id_allocation);
+                                           bounds, local_surface_id);
 }
 
-void WindowTreeTestHelper::SetWindowBoundsWithAck(
-    aura::Window* window,
+void WindowTreeTestHelper::SetWindowBoundsWithAck(aura::Window* window,
     const gfx::Rect& bounds,
-    const base::Optional<viz::LocalSurfaceIdAllocation>&
-        local_surface_id_allocation,
     uint32_t change_id) {
+  base::Optional<viz::LocalSurfaceId> local_surface_id;
   window_tree_->SetWindowBounds(change_id, TransportIdForWindow(window), bounds,
-                                local_surface_id_allocation);
+                                local_surface_id);
 }
 
 void WindowTreeTestHelper::SetClientArea(
@@ -110,11 +101,6 @@
   window_tree_->SetHitTestInsets(TransportIdForWindow(window), mouse, touch);
 }
 
-void WindowTreeTestHelper::SetShape(aura::Window* window,
-                                    const std::vector<gfx::Rect>& shape) {
-  window_tree_->SetShape(TransportIdForWindow(window), shape);
-}
-
 bool WindowTreeTestHelper::SetWindowVisibility(aura::Window* window,
                                                bool visible) {
   return window_tree_->SetWindowVisibilityImpl(ClientWindowIdForWindow(window),
--- a/services/ws/window_tree_test_helper.h	2019-05-01 01:22:57.000000000 +0300
+++ b/services/ws/window_tree_test_helper.h	2019-05-17 18:53:38.060000000 +0300
@@ -23,7 +23,6 @@
 
 namespace gfx {
 class Insets;
-class Transform;
 }
 
 namespace ui {
@@ -66,20 +65,15 @@
   bool ReorderWindow(aura::Window* window,
                      aura::Window* relative_window,
                      mojom::OrderDirection direction);
-  bool SetTransform(aura::Window* window, const gfx::Transform& transform);
-  bool SetWindowBounds(aura::Window* window,
+  bool SetWindowBounds(
+      aura::Window* window,
                        const gfx::Rect& bounds,
-                       const base::Optional<viz::LocalSurfaceIdAllocation>&
-                           local_surface_id_allocation =
-                               base::Optional<viz::LocalSurfaceIdAllocation>());
+      const base::Optional<viz::LocalSurfaceId>& local_surface_id =
+          base::Optional<viz::LocalSurfaceId>());
   // Same as SetWindowBounds(), but called in such a way that the ack
   // (OnChangeCompleted()) is called on the client.
-  void SetWindowBoundsWithAck(
-      aura::Window* window,
+  void SetWindowBoundsWithAck(aura::Window* window,
       const gfx::Rect& bounds,
-      const base::Optional<viz::LocalSurfaceIdAllocation>&
-          local_surface_id_allocation =
-              base::Optional<viz::LocalSurfaceIdAllocation>(),
       uint32_t change_id = 1);
   void SetClientArea(
       aura::Window* window,
@@ -89,7 +83,6 @@
   void SetHitTestInsets(aura::Window* window,
                         const gfx::Insets& mouse,
                         const gfx::Insets& touch);
-  void SetShape(aura::Window* window, const std::vector<gfx::Rect>& shape);
   bool SetWindowVisibility(aura::Window* window, bool visible);
   void SetWindowProperty(aura::Window* window,
                          const std::string& name,
--- a/services/ws/window_tree_unittest.cc	2019-05-01 01:22:57.000000000 +0300
+++ b/services/ws/window_tree_unittest.cc	2019-05-17 18:53:38.060000000 +0300
@@ -10,14 +10,10 @@
 #include <memory>
 #include <queue>
 
-#include "base/bind.h"
 #include "base/run_loop.h"
 #include "base/unguessable_token.h"
-#include "components/viz/common/surfaces/child_local_surface_id_allocator.h"
-#include "components/viz/common/surfaces/parent_local_surface_id_allocator.h"
 #include "components/viz/host/host_frame_sink_manager.h"
 #include "components/viz/test/fake_host_frame_sink_client.h"
-#include "services/ws/client_root_test_helper.h"
 #include "services/ws/event_test_utils.h"
 #include "services/ws/proxy_window.h"
 #include "services/ws/proxy_window_test_helper.h"
@@ -30,18 +26,14 @@
 #include "ui/aura/client/aura_constants.h"
 #include "ui/aura/env.h"
 #include "ui/aura/layout_manager.h"
-#include "ui/aura/mus/client_surface_embedder.h"
 #include "ui/aura/test/aura_test_helper.h"
 #include "ui/aura/test/test_screen.h"
 #include "ui/aura/test/test_window_delegate.h"
-#include "ui/aura/test/test_window_parenting_client.h"
 #include "ui/aura/test/window_occlusion_tracker_test_api.h"
 #include "ui/aura/window.h"
 #include "ui/aura/window_tracker.h"
-#include "ui/base/hit_test.h"
 #include "ui/events/mojo/event_constants.mojom.h"
 #include "ui/events/test/event_generator.h"
-#include "ui/gfx/transform.h"
 #include "ui/wm/core/capture_controller.h"
 #include "ui/wm/core/default_screen_position_client.h"
 #include "ui/wm/core/focus_controller.h"
@@ -50,7 +42,7 @@
 namespace ws {
 namespace {
 
-DEFINE_UI_CLASS_PROPERTY_KEY(aura::Window*, kTestPropertyKey, nullptr)
+DEFINE_UI_CLASS_PROPERTY_KEY(aura::Window*, kTestPropertyKey, nullptr);
 const char kTestPropertyServerKey[] = "test-property-server";
 
 // Passed to Embed() to give the default behavior (see kEmbedFlag* in mojom for
@@ -163,10 +155,6 @@
   ASSERT_TRUE(top_level);
   EXPECT_EQ("TopLevelCreated id=1 window_id=0,1 drawn=false",
             SingleChangeToDescription(*setup.changes()));
-  ASSERT_TRUE((*setup.changes())[0].local_surface_id_allocation);
-  EXPECT_TRUE((*setup.changes())[0].local_surface_id_allocation->IsValid());
-  EXPECT_EQ(ProxyWindow::GetMayBeNull(top_level)->local_surface_id_allocation(),
-            (*setup.changes())[0].local_surface_id_allocation);
 }
 
 TEST(WindowTreeTest, NewTopLevelWindowWithProperties) {
@@ -187,18 +175,21 @@
   aura::Window* top_level =
       setup.window_tree_test_helper()->NewTopLevelWindow();
   setup.changes()->clear();
-  ProxyWindow* top_level_proxy = ProxyWindow::GetMayBeNull(top_level);
 
   const gfx::Rect bounds_from_client = gfx::Rect(100, 200, 300, 400);
-  viz::ChildLocalSurfaceIdAllocator child_allocator;
-  child_allocator.UpdateFromParent(
-      *top_level_proxy->local_surface_id_allocation());
-  child_allocator.GenerateId();
   setup.window_tree_test_helper()->SetWindowBoundsWithAck(
-      top_level, bounds_from_client,
-      child_allocator.GetCurrentLocalSurfaceIdAllocation(), 2);
+      top_level, bounds_from_client, 2);
   EXPECT_EQ(bounds_from_client, top_level->GetBoundsInScreen());
-  EXPECT_EQ("ChangeCompleted id=2 success=true",
+  ASSERT_EQ(2u, setup.changes()->size());
+  {
+    const Change& change = (*setup.changes())[0];
+    EXPECT_EQ(CHANGE_TYPE_NODE_BOUNDS_CHANGED, change.type);
+    EXPECT_EQ(top_level->GetBoundsInScreen(), change.bounds2);
+    EXPECT_TRUE(change.local_surface_id);
+    setup.changes()->erase(setup.changes()->begin());
+  }
+  // See comments in WindowTree::SetBoundsImpl() for why this returns false.
+  EXPECT_EQ("ChangeCompleted id=2 success=false",
             SingleChangeToDescription(*setup.changes()));
   setup.changes()->clear();
 
@@ -206,12 +197,7 @@
   top_level->SetBounds(bounds_from_server);
   ASSERT_EQ(1u, setup.changes()->size());
   EXPECT_EQ(CHANGE_TYPE_NODE_BOUNDS_CHANGED, (*setup.changes())[0].type);
-  EXPECT_EQ(bounds_from_server, (*setup.changes())[0].bounds);
-  ASSERT_TRUE((*setup.changes())[0].local_surface_id_allocation);
-  EXPECT_NE((*setup.changes())[0].local_surface_id_allocation,
-            child_allocator.GetCurrentLocalSurfaceIdAllocation());
-  EXPECT_EQ(top_level_proxy->local_surface_id_allocation(),
-            (*setup.changes())[0].local_surface_id_allocation);
+  EXPECT_EQ(bounds_from_server, (*setup.changes())[0].bounds2);
   setup.changes()->clear();
 
   // Set a LayoutManager so that when the client requests a bounds change the
@@ -221,16 +207,14 @@
   const gfx::Rect restricted_bounds = gfx::Rect(401, 405, 406, 407);
   layout_manager->set_next_bounds(restricted_bounds);
   top_level->parent()->SetLayoutManager(layout_manager);
-  child_allocator.GenerateId();
   setup.window_tree_test_helper()->SetWindowBoundsWithAck(
-      top_level, bounds_from_client,
-      child_allocator.GetCurrentLocalSurfaceIdAllocation(), 3);
+      top_level, bounds_from_client, 3);
   ASSERT_EQ(2u, setup.changes()->size());
   // The layout manager changes the bounds to a different value than the client
   // requested, so the client should get OnWindowBoundsChanged() with
   // |restricted_bounds|.
   EXPECT_EQ(CHANGE_TYPE_NODE_BOUNDS_CHANGED, (*setup.changes())[0].type);
-  EXPECT_EQ(restricted_bounds, (*setup.changes())[0].bounds);
+  EXPECT_EQ(restricted_bounds, (*setup.changes())[0].bounds2);
 
   // And because the layout manager changed the bounds the result is false.
   EXPECT_EQ("ChangeCompleted id=3 success=false",
@@ -244,44 +228,27 @@
                                         &screen_position_client);
 
   // Tests that top-level window bounds are set in screen coordinates.
-  child_allocator.GenerateId();
   setup.window_tree_test_helper()->SetWindowBoundsWithAck(
-      top_level, bounds_from_client,
-      child_allocator.GetCurrentLocalSurfaceIdAllocation(), 4);
+      top_level, bounds_from_client, 4);
   EXPECT_EQ(bounds_from_client, top_level->GetBoundsInScreen());
   EXPECT_EQ(bounds_from_client - screen_offset, top_level->bounds());
-  EXPECT_EQ("ChangeCompleted id=4 success=true",
+  ASSERT_EQ(2u, setup.changes()->size());
+  {
+    const Change& change = (*setup.changes())[0];
+    EXPECT_EQ(CHANGE_TYPE_NODE_BOUNDS_CHANGED, change.type);
+    EXPECT_EQ(top_level->GetBoundsInScreen(), change.bounds2);
+    EXPECT_TRUE(change.local_surface_id);
+    setup.changes()->erase(setup.changes()->begin());
+  }
+  // See comments in WindowTree::SetBoundsImpl() for why this returns false.
+  EXPECT_EQ("ChangeCompleted id=4 success=false",
             SingleChangeToDescription(*setup.changes()));
 
   aura::client::SetScreenPositionClient(setup.aura_test_helper()->root_window(),
                                         nullptr);
 }
 
-TEST(WindowTreeTest, SetTopLevelWindowBoundsSameSize) {
-  WindowServiceTestSetup setup;
-  aura::Window* top_level =
-      setup.window_tree_test_helper()->NewTopLevelWindow();
-  setup.changes()->clear();
-  const gfx::Rect bounds = gfx::Rect(1, 2, 300, 400);
-  top_level->SetBounds(bounds);
-  setup.changes()->clear();
-  ProxyWindow* top_level_proxy = ProxyWindow::GetMayBeNull(top_level);
-  ASSERT_TRUE(top_level_proxy);
-  ASSERT_TRUE(top_level_proxy->local_surface_id_allocation().has_value());
-  viz::ChildLocalSurfaceIdAllocator child_allocator;
-  child_allocator.UpdateFromParent(
-      *top_level_proxy->local_surface_id_allocation());
-  child_allocator.GenerateId();
-  // WindowTreeTestHelper::SetWindowBounds() with same bounds should succeed.
-  EXPECT_TRUE(setup.window_tree_test_helper()->SetWindowBounds(
-      top_level, bounds, child_allocator.GetCurrentLocalSurfaceIdAllocation()));
-  EXPECT_TRUE(setup.changes()->empty());
-  ASSERT_TRUE(top_level_proxy->local_surface_id_allocation().has_value());
-  EXPECT_EQ(child_allocator.GetCurrentLocalSurfaceIdAllocation(),
-            *top_level_proxy->local_surface_id_allocation());
-}
-
-TEST(WindowTreeTest, SetTopLevelWindowBoundsBadEmbedToken) {
+TEST(WindowTreeTest, SetTopLevelWindowBoundsFailsForSameSize) {
   WindowServiceTestSetup setup;
   aura::Window* top_level =
       setup.window_tree_test_helper()->NewTopLevelWindow();
@@ -289,110 +256,12 @@
   const gfx::Rect bounds = gfx::Rect(1, 2, 300, 400);
   top_level->SetBounds(bounds);
   setup.changes()->clear();
-  ProxyWindow* top_level_proxy = ProxyWindow::GetMayBeNull(top_level);
-  ASSERT_TRUE(top_level_proxy);
-  ASSERT_TRUE(top_level_proxy->local_surface_id_allocation().has_value());
-  const viz::LocalSurfaceId initial_lsia =
-      top_level_proxy->local_surface_id_allocation()->local_surface_id();
-  viz::LocalSurfaceIdAllocation lsia_with_different_embed_token(
-      viz::LocalSurfaceId(initial_lsia.parent_sequence_number(),
-                          initial_lsia.child_sequence_number(),
-                          base::UnguessableToken::Create()),
-      base::TimeTicks::Now());
-  // Clients are not allowed to change the embed token.
-  EXPECT_FALSE(setup.window_tree_test_helper()->SetWindowBounds(
-      top_level, gfx::Rect(1, 2, 3, 4), lsia_with_different_embed_token));
-  EXPECT_EQ(initial_lsia,
-            top_level_proxy->local_surface_id_allocation()->local_surface_id());
-  EXPECT_EQ(bounds, top_level->bounds());
-  EXPECT_TRUE(setup.changes()->empty());
-}
-
-TEST(WindowTreeTest, UpdateLocalSurfaceIdFromChildBadEmbedToken) {
-  WindowServiceTestSetup setup;
-  aura::Window* top_level =
-      setup.window_tree_test_helper()->NewTopLevelWindow();
-  setup.changes()->clear();
-  const gfx::Rect bounds = gfx::Rect(1, 2, 300, 400);
-  top_level->SetBounds(bounds);
-  setup.changes()->clear();
-  ProxyWindow* top_level_proxy = ProxyWindow::GetMayBeNull(top_level);
-  ASSERT_TRUE(top_level_proxy);
-  ASSERT_TRUE(top_level_proxy->local_surface_id_allocation().has_value());
-  const viz::LocalSurfaceId initial_lsia =
-      top_level_proxy->local_surface_id_allocation()->local_surface_id();
-  viz::LocalSurfaceIdAllocation lsia_with_different_embed_token(
-      viz::LocalSurfaceId(initial_lsia.parent_sequence_number(),
-                          initial_lsia.child_sequence_number(),
-                          base::UnguessableToken::Create()),
-      base::TimeTicks::Now());
-  // Clients are not allowed to change the embed token.
-  setup.window_tree_test_helper()->window_tree()->UpdateLocalSurfaceIdFromChild(
-      setup.window_tree_test_helper()->TransportIdForWindow(top_level),
-      lsia_with_different_embed_token);
-  EXPECT_EQ(initial_lsia,
-            top_level_proxy->local_surface_id_allocation()->local_surface_id());
-  EXPECT_EQ(bounds, top_level->bounds());
-  EXPECT_TRUE(setup.changes()->empty());
-}
-
-TEST(WindowTreeTest, UpdateLocalSurfaceIdFromScheduleEmbedWindow) {
-  WindowServiceTestSetup setup;
-  // Schedule an embed in the tree created by |setup|.
-  base::UnguessableToken token;
-  const uint32_t window_id_in_child = 149;
-  setup.window_tree_test_helper()
-      ->window_tree()
-      ->ScheduleEmbedForExistingClient(
-          window_id_in_child, base::BindOnce(&ScheduleEmbedCallback, &token));
-  EXPECT_FALSE(token.is_empty());
-
-  // Create a window that will serve as the parent for the remote window and
-  // complete the embedding.
-  aura::Window local_window(nullptr);
-  local_window.Init(ui::LAYER_NOT_DRAWN);
-  local_window.SetBounds(gfx::Rect(1, 2, 3, 4));
-  ASSERT_TRUE(setup.service()->CompleteScheduleEmbedForExistingClient(
-      &local_window, token, /* embed_flags */ 0));
-  EXPECT_TRUE(WindowService::IsProxyWindow(&local_window));
-
-  // Call UpdateLocalSurfaceIdFromScheduleEmbedWindow() for the embedded window
-  // and ensure the value is updated.
-  ProxyWindow* local_window_proxy = ProxyWindow::GetMayBeNull(&local_window);
-  ASSERT_TRUE(local_window_proxy);
-  ASSERT_TRUE(local_window_proxy->local_surface_id_allocation().has_value());
-  viz::ChildLocalSurfaceIdAllocator child_allocator;
-  child_allocator.UpdateFromParent(
-      *local_window_proxy->local_surface_id_allocation());
-  child_allocator.GenerateId();
-  setup.window_tree_test_helper()->window_tree()->UpdateLocalSurfaceIdFromChild(
-      setup.window_tree_test_helper()->TransportIdForWindow(&local_window),
-      child_allocator.GetCurrentLocalSurfaceIdAllocation());
-  EXPECT_EQ(child_allocator.GetCurrentLocalSurfaceIdAllocation(),
-            local_window_proxy->local_surface_id_allocation());
-}
-
-TEST(WindowTreeTest, SetTopLevelWindowBoundsNullSurfaceId) {
-  WindowServiceTestSetup setup;
-  aura::Window* top_level =
-      setup.window_tree_test_helper()->NewTopLevelWindow();
-  setup.changes()->clear();
-  const gfx::Rect bounds = gfx::Rect(1, 2, 300, 400);
-  top_level->SetBounds(bounds);
-  setup.changes()->clear();
-  // Server allows null LocalSurfaceIds, which is used on the initial resize
-  // from the client.
-  EXPECT_TRUE(
+  // WindowTreeTestHelper::SetWindowBounds() uses a null LocalSurfaceId, which
+  // differs from the current LocalSurfaceId (assigned by ClientRoot). Because
+  // of this, the LocalSurfaceIds differ and the call returns false.
+  EXPECT_FALSE(
       setup.window_tree_test_helper()->SetWindowBounds(top_level, bounds));
-  // The server always responds with a bounds change when the client changes the
-  // bounds and does not supply a LocalSurfaceId.
-  ASSERT_FALSE(setup.changes()->empty());
-  const auto& change = (*setup.changes())[0];
-  EXPECT_EQ(CHANGE_TYPE_NODE_BOUNDS_CHANGED, change.type);
-  EXPECT_EQ(setup.window_tree_test_helper()->TransportIdForWindow(top_level),
-            change.window_id);
-  EXPECT_TRUE(change.local_surface_id_allocation);
-  EXPECT_EQ(bounds, change.bounds);
+  EXPECT_TRUE(setup.changes()->empty());
 }
 
 TEST(WindowTreeTest, SetChildWindowBounds) {
@@ -431,46 +300,40 @@
 
   // Set the bounds from the parent and ensure client is notified.
   const gfx::Rect bounds2 = gfx::Rect(1, 2, 300, 401);
-  base::Optional<viz::LocalSurfaceIdAllocation> local_surface_id_allocation(
-      viz::LocalSurfaceIdAllocation(
-          viz::LocalSurfaceId(1, 2, base::UnguessableToken::Create()),
-          base::TimeTicks::Now()));
+  base::Optional<viz::LocalSurfaceId> local_surface_id(
+      viz::LocalSurfaceId(1, 2, base::UnguessableToken::Create()));
   EXPECT_TRUE(setup.window_tree_test_helper()->SetWindowBounds(
-      window, bounds2, local_surface_id_allocation));
+      window, bounds2, local_surface_id));
   EXPECT_EQ(bounds2, window->bounds());
   ASSERT_EQ(1u,
             embedding_helper->window_tree_client.tracker()->changes()->size());
   const Change bounds_change =
       (*(embedding_helper->window_tree_client.tracker()->changes()))[0];
   EXPECT_EQ(CHANGE_TYPE_NODE_BOUNDS_CHANGED, bounds_change.type);
-  EXPECT_EQ(bounds2, bounds_change.bounds);
-  EXPECT_EQ(local_surface_id_allocation,
-            bounds_change.local_surface_id_allocation);
+  EXPECT_EQ(bounds2, bounds_change.bounds2);
+  EXPECT_EQ(local_surface_id, bounds_change.local_surface_id);
   embedding_helper->window_tree_client.tracker()->changes()->clear();
 
   // Set the bounds from the parent, only updating the LocalSurfaceId (bounds
   // remains the same). The client should be notified.
-  base::Optional<viz::LocalSurfaceIdAllocation> local_surface_id_allocation2(
-      viz::LocalSurfaceIdAllocation(
-          viz::LocalSurfaceId(1, 3, base::UnguessableToken::Create()),
-          base::TimeTicks::Now()));
+  base::Optional<viz::LocalSurfaceId> local_surface_id2(
+      viz::LocalSurfaceId(1, 3, base::UnguessableToken::Create()));
   EXPECT_TRUE(setup.window_tree_test_helper()->SetWindowBounds(
-      window, bounds2, local_surface_id_allocation2));
+      window, bounds2, local_surface_id2));
   EXPECT_EQ(bounds2, window->bounds());
   ASSERT_EQ(1u,
             embedding_helper->window_tree_client.tracker()->changes()->size());
   const Change bounds_change2 =
       (*(embedding_helper->window_tree_client.tracker()->changes()))[0];
   EXPECT_EQ(CHANGE_TYPE_NODE_BOUNDS_CHANGED, bounds_change2.type);
-  EXPECT_EQ(bounds2, bounds_change2.bounds);
-  EXPECT_EQ(local_surface_id_allocation2,
-            bounds_change2.local_surface_id_allocation);
+  EXPECT_EQ(bounds2, bounds_change2.bounds2);
+  EXPECT_EQ(local_surface_id2, bounds_change2.local_surface_id);
   embedding_helper->window_tree_client.tracker()->changes()->clear();
 
   // Try again with the same values. This should succeed, but not notify the
   // client.
   EXPECT_TRUE(setup.window_tree_test_helper()->SetWindowBounds(
-      window, bounds2, local_surface_id_allocation2));
+      window, bounds2, local_surface_id2));
   EXPECT_TRUE(
       embedding_helper->window_tree_client.tracker()->changes()->empty());
 }
@@ -1880,7 +1743,7 @@
       setup.window_tree_test_helper()->TransportIdForWindow(top_level);
   setup.changes()->clear();
   setup.window_tree_test_helper()->window_tree()->PerformWindowMove(
-      12, top_level_id, mojom::MoveLoopSource::TOUCH, gfx::Point(), HTCAPTION);
+      12, top_level_id, mojom::MoveLoopSource::TOUCH, gfx::Point());
   // |top_level| isn't visible, so should fail immediately.
   EXPECT_EQ("ChangeCompleted id=12 success=false",
             SingleChangeToDescription(*setup.changes()));
@@ -1890,7 +1753,7 @@
   top_level->Show();
   setup.changes()->clear();
   setup.window_tree_test_helper()->window_tree()->PerformWindowMove(
-      13, top_level_id, mojom::MoveLoopSource::TOUCH, gfx::Point(), HTCAPTION);
+      13, top_level_id, mojom::MoveLoopSource::TOUCH, gfx::Point());
   // WindowServiceDelegate should be asked to do the move.
   WindowServiceDelegate::DoneCallback move_loop_callback =
       setup.delegate()->TakeMoveLoopCallback();
@@ -1912,7 +1775,7 @@
       14,
       setup.window_tree_test_helper()->TransportIdForWindow(
           non_top_level_window),
-      mojom::MoveLoopSource::TOUCH, gfx::Point(), HTCAPTION);
+      mojom::MoveLoopSource::TOUCH, gfx::Point());
   EXPECT_EQ("ChangeCompleted id=14 success=false",
             SingleChangeToDescription(*setup.changes()));
 }
@@ -1927,7 +1790,7 @@
       setup.window_tree_test_helper()->TransportIdForWindow(top_level);
   setup.changes()->clear();
   setup.window_tree_test_helper()->window_tree()->PerformWindowMove(
-      12, top_level_id, mojom::MoveLoopSource::MOUSE, gfx::Point(), HTCAPTION);
+      12, top_level_id, mojom::MoveLoopSource::MOUSE, gfx::Point());
   // The mouse isn't down, so this should fail.
   EXPECT_EQ("ChangeCompleted id=12 success=false",
             SingleChangeToDescription(*setup.changes()));
@@ -1937,7 +1800,7 @@
   ui::test::EventGenerator event_generator(setup.root());
   event_generator.PressLeftButton();
   setup.window_tree_test_helper()->window_tree()->PerformWindowMove(
-      13, top_level_id, mojom::MoveLoopSource::MOUSE, gfx::Point(), HTCAPTION);
+      13, top_level_id, mojom::MoveLoopSource::MOUSE, gfx::Point());
   // WindowServiceDelegate should be asked to do the move.
   WindowServiceDelegate::DoneCallback move_loop_callback =
       setup.delegate()->TakeMoveLoopCallback();
@@ -1962,7 +1825,7 @@
       setup.window_tree_test_helper()->TransportIdForWindow(top_level);
   setup.changes()->clear();
   setup.window_tree_test_helper()->window_tree()->PerformWindowMove(
-      12, top_level_id, mojom::MoveLoopSource::TOUCH, gfx::Point(), HTCAPTION);
+      12, top_level_id, mojom::MoveLoopSource::TOUCH, gfx::Point());
 
   // WindowServiceDelegate should be asked to do the move.
   WindowServiceDelegate::DoneCallback move_loop_callback =
@@ -2179,16 +2042,14 @@
   ASSERT_TRUE(top_level);
   top_level->Show();
   ProxyWindow* top_level_proxy_window = ProxyWindow::GetMayBeNull(top_level);
-  const base::Optional<viz::LocalSurfaceIdAllocation>
-      initial_surface_id_allocation =
-          top_level_proxy_window->local_surface_id_allocation();
-  EXPECT_TRUE(initial_surface_id_allocation);
+  const base::Optional<viz::LocalSurfaceId> initial_surface_id =
+      top_level_proxy_window->local_surface_id();
+  EXPECT_TRUE(initial_surface_id);
 
   // Changing the scale factor should change the LocalSurfaceId.
   setup.aura_test_helper()->test_screen()->SetDeviceScaleFactor(2.0f);
-  EXPECT_TRUE(top_level_proxy_window->local_surface_id_allocation());
-  EXPECT_NE(*top_level_proxy_window->local_surface_id_allocation(),
-            *initial_surface_id_allocation);
+  EXPECT_TRUE(top_level_proxy_window->local_surface_id());
+  EXPECT_NE(*top_level_proxy_window->local_surface_id(), *initial_surface_id);
 }
 
 TEST(WindowTreeTest, DontSendGestures) {
@@ -2581,48 +2442,5 @@
   EXPECT_TRUE(setup.changes()->empty());
 }
 
-TEST(WindowTreeTest, SetWindowTransform) {
-  WindowServiceTestSetup setup;
-  aura::Window* top_level =
-      setup.window_tree_test_helper()->NewTopLevelWindow();
-  setup.changes()->clear();
-  gfx::Transform scaled;
-  scaled.Scale(2, 2);
-  EXPECT_FALSE(
-      setup.window_tree_test_helper()->SetTransform(top_level, scaled));
-  EXPECT_EQ(gfx::Transform(), top_level->transform());
-
-  aura::Window* child_window = setup.window_tree_test_helper()->NewWindow();
-  EXPECT_TRUE(
-      setup.window_tree_test_helper()->SetTransform(child_window, scaled));
-  EXPECT_EQ(scaled, child_window->transform());
-}
-
-TEST(WindowTreeTest, AddingTransientGoesThroughParentingClient) {
-  WindowServiceTestSetup setup;
-  aura::test::TestWindowParentingClient test_window_parenting_client(
-      setup.aura_test_helper()->root_window());
-  WindowTreeTestHelper* helper = setup.window_tree_test_helper();
-  aura::Window* top_level = helper->NewTopLevelWindow();
-  ASSERT_TRUE(top_level);
-  aura::Window* transient = helper->NewTopLevelWindow();
-  ASSERT_TRUE(transient);
-
-  // Put |top_level| in |container|.
-  aura::Window container(nullptr);
-  container.Init(ui::LAYER_NOT_DRAWN);
-  top_level->parent()->AddChild(&container);
-  container.AddChild(top_level);
-  test_window_parenting_client.set_default_parent(&container);
-  EXPECT_NE(&container, transient->parent());
-
-  // AddTransientWindow() should trigger calling into the WindowParentingClient,
-  // which will result in adding |transient| as a child of |container|.
-  helper->window_tree()->AddTransientWindow(
-      10, helper->TransportIdForWindow(top_level),
-      helper->TransportIdForWindow(transient));
-  EXPECT_EQ(&container, transient->parent());
-}
-
 }  // namespace
 }  // namespace ws
--- a/services/api_standards.md	1970-01-01 03:00:00.000000000 +0300
+++ b/services/api_standards.md	2019-05-17 18:53:37.772000000 +0300
@@ -0,0 +1,116 @@
+# API Standards for Foundation Services
+
+In creating and maintaining the public-facing structure of a foundation service,
+you should hold yourself to several first-order goals:
+
+* The purpose of the service should be readily apparent.
+* The supported usage models of the service should be easy for a new
+  consumer to understand.
+* The service should be consistent with other foundation services.
+* From the API documentation and tests, it should be feasible
+  to develop a distinct implementation of the service (i.e., without having to
+  delve into the internals of the current implementation).
+
+Below we outline concrete standards that aid in achieving the above goals.
+
+## Naming
+
+* Strive to give your service a name that makes it immediately obvious what the
+  service is for ("network", "metrics").
+
+* Avoid the usage of "Service" in interface names. While the term "Service" is
+  overloaded in Chromium, in the context of //services it has a very specific
+  meaning and should not be overloaded.
+
+* Strive to avoid conceptual layering violations in naming -- e.g., references
+  to Blink or //content.
+
+* Use the names "FooClient" and "FooObserver" consistently in interfaces. If
+  there is an expected 1:1 correspondence between Foo and its counterpart, that
+  counterpart should be called FooClient. If there is an expected 1:many
+  correspondence between Foo and its counterparts, those counterparts should be
+  called FooObservers.
+
+## Documentation
+
+* Every service should have a top-level README.md that explains the purpose and
+  supported usage models of the service.
+
+* Every public interface should be documented at the interface (class) level and
+  at the method level.
+
+* Interface documentation should be complete enough to serve as test
+  specifications. If the method returns information of a user's accounts, what
+  happens if the user is not signed in? If the method makes a request for an
+  access token, what happens if a client makes a second method call before a
+  first one has completed? If the method returns a nullable object, under which
+  conditions will it be null?
+
+* Strive to avoid your documentation being too specific to a given client.
+
+## API Shape
+
+* Strive to avoid molding your API shape too specifically to the needs of a
+  given client. Most foundational services should make sense even in a
+  Chrome-less system environment. A good test is: Would your service's APIs seem
+  sensible to users who don't have knowledge of Chrome's specific needs?
+
+* If a given interface Foo requires "construction parameters" (e.g., the client
+  must give it a FooClient before calling any methods), provide a FooProvider
+  interface with a GetFoo() method that takes in the relevant construction
+  parameters. This approach eliminates the possibility of a badly-written (or
+  malevolent) client calling methods on a partially-constructed Foo. To be
+  concrete:
+
+    ````
+    // NO: Client will have access to partially-constructed Foo.
+    interface Foo {
+      SetClient(FooClient client);
+      ...
+    };
+
+    // YES: Foo will be completely constructed before client has access.
+    interface FooProvider {
+      GetFoo(Foo& request, FooClient client);
+    };
+    interface Foo { ... };
+    ````
+
+* In the absence of specific guidance, strive for consistency with surrounding
+  interfaces and with interfaces in other services.
+
+## Testing
+
+* Use service tests to test the public interfaces exposed by your service.
+
+* Every public method should be covered by at least one service test. Strive
+  to have your tests enforce your documentation (corollary: if you can enforce
+  your documentation without any tests, improve your documentation :).
+
+* Think of these tests as a form of "compliance tests": They should be written
+  in such a way that engineers with a distinct implementation of your
+  APIs should trivially be able to run your tests against their implementation.
+  Notably, try to avoid relying on implementation details of the service in its
+  tests.
+
+* Related to the above, aim for a high degree of coverage with these tests. If a
+  reimplementation passes your tests, you should have a high degree of
+  confidence that it will be usable by your consumers.
+
+## Appendix: Responsibility for Upholding These Standards
+
+The responsibility for holding these standards is shared across
+//services/OWNERS, individual service OWNERS, and services developers:
+
+* //services/OWNERS own the standards themselves and are responsible for
+  ensuring that quality and consistency are maintained across //services.
+* Individual service OWNERS are responsible for ensuring that their service
+  adheres to these standards.
+* Service developers are responsible for ensuring that their CLs adhere to
+  these standards (and thus making life easier for the OWNERS that must review
+  these CLs :).
+
+We expect that these standards will evolve over time. If you encounter a tricky
+situation not covered here, please send an email to services-dev@. Similarly, if
+you see inconsistency or violations of the standards, please file a bug and CC
+relevant OWNERS (i.e., of the service in question and/or //services/OWNERS).
--- a/services/audio/manifest.json	1970-01-01 03:00:00.000000000 +0300
+++ b/services/audio/manifest.json	2019-05-17 18:53:37.776000000 +0300
@@ -0,0 +1,20 @@
+{
+  "name": "audio",
+  "display_name": "Audio",
+  "sandbox_type": "audio",
+  "options" : {
+    "instance_sharing" : "shared_instance_across_users"
+  },
+  "interface_provider_specs": {
+    "service_manager:connector": {
+      "provides": {
+        "info": [ "audio.mojom.SystemInfo" ],
+        "debug_recording": [ "audio.mojom.DebugRecording" ],
+        "stream_factory": [ "audio.mojom.StreamFactory" ],
+        "device_notifier": [ "audio.mojom.DeviceNotifier" ],
+        "log_factory_manager": [ "audio.mojom.LogFactoryManager" ],
+        "testing_api": [ "audio.mojom.TestingApi" ]
+      }
+    }
+  }
+}
--- a/services/audio/test/OWNERS	1970-01-01 03:00:00.000000000 +0300
+++ b/services/audio/test/OWNERS	2019-05-17 18:53:37.788000000 +0300
@@ -0,0 +1,2 @@
+per-file service_unittest_manifest.json=set noparent
+per-file service_unittest_manifest.json=file://ipc/SECURITY_OWNERS
--- a/services/audio/test/service_unittest_manifest.json	1970-01-01 03:00:00.000000000 +0300
+++ b/services/audio/test/service_unittest_manifest.json	2019-05-17 18:53:37.788000000 +0300
@@ -0,0 +1,17 @@
+{
+  "name": "audio_unittests",
+  "display_name": "Audio Unittests",
+  "interface_provider_specs": {
+    "service_manager:connector": {
+      "provides": {
+        "service_manager:service_factory": [
+          "service_manager.mojom.ServiceFactory"
+        ]
+      },
+      "requires": {
+        "audio": [ "info" ],
+        "service_manager": [ "service_manager:service_manager" ]
+      }
+    }
+  }
+}
diff -BbuN a/services/catalog/BUILD.gn b/services/catalog/BUILD.gn
--- a/services/catalog/BUILD.gn	1970-01-01 03:00:00.000000000 +0300
+++ b/services/catalog/BUILD.gn	2019-05-17 18:53:37.788000000 +0300
@@ -0,0 +1,56 @@
+# Copyright 2016 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+import("//testing/test.gni")
+
+group("catalog") {
+  testonly = true
+  deps = [
+    ":lib",
+  ]
+}
+
+source_set("constants") {
+  sources = [
+    "store.cc",
+    "store.h",
+  ]
+}
+
+component("lib") {
+  sources = [
+    "catalog.cc",
+    "catalog.h",
+    "constants.cc",
+    "constants.h",
+    "entry.cc",
+    "entry.h",
+    "entry_cache.cc",
+    "entry_cache.h",
+    "instance.cc",
+    "instance.h",
+    "service_options.cc",
+    "service_options.h",
+  ]
+
+  configs += [ "//build/config/compiler:wexit_time_destructors" ]
+
+  deps = [
+    ":constants",
+    "//base",
+    "//components/services/filesystem:lib",
+    "//services/catalog/public/cpp",
+    "//services/catalog/public/mojom",
+    "//services/service_manager/public/cpp",
+  ]
+
+  public_deps = [
+    # directory.mojom.h is #included by catalog.h
+    "//components/services/filesystem/public/interfaces",
+  ]
+
+  output_name = "catalog_lib"
+
+  defines = [ "IS_CATALOG_IMPL" ]
+}
diff -BbuN a/services/catalog/catalog.cc b/services/catalog/catalog.cc
--- a/services/catalog/catalog.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/services/catalog/catalog.cc	2019-05-17 18:53:37.792000000 +0300
@@ -0,0 +1,155 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "services/catalog/catalog.h"
+
+#include <memory>
+#include <string>
+
+#include "base/base_paths.h"
+#include "base/command_line.h"
+#include "base/files/file_path.h"
+#include "base/files/file_util.h"
+#include "base/lazy_instance.h"
+#include "base/macros.h"
+#include "base/memory/ref_counted_delete_on_sequence.h"
+#include "base/no_destructor.h"
+#include "base/path_service.h"
+#include "base/sequenced_task_runner.h"
+#include "base/strings/string_util.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/task/post_task.h"
+#include "components/services/filesystem/directory_impl.h"
+#include "components/services/filesystem/lock_table.h"
+#include "components/services/filesystem/public/interfaces/types.mojom.h"
+#include "mojo/public/cpp/bindings/strong_binding.h"
+#include "services/catalog/constants.h"
+#include "services/catalog/entry_cache.h"
+#include "services/catalog/instance.h"
+
+namespace catalog {
+
+namespace {
+
+std::vector<service_manager::Manifest>& GetDefaultManifests() {
+  static base::NoDestructor<std::vector<service_manager::Manifest>> manifests;
+  return *manifests;
+}
+
+}  // namespace
+
+// Wraps state needed for servicing directory requests on a separate thread.
+// filesystem::LockTable is not thread safe, so it's wrapped in
+// DirectoryThreadState.
+class Catalog::DirectoryThreadState
+    : public base::RefCountedDeleteOnSequence<DirectoryThreadState> {
+ public:
+  explicit DirectoryThreadState(
+      scoped_refptr<base::SequencedTaskRunner> task_runner)
+      : base::RefCountedDeleteOnSequence<DirectoryThreadState>(
+            std::move(task_runner)) {}
+
+  scoped_refptr<filesystem::LockTable> lock_table() {
+    if (!lock_table_)
+      lock_table_ = new filesystem::LockTable;
+    return lock_table_;
+  }
+
+ private:
+  friend class base::DeleteHelper<DirectoryThreadState>;
+  friend class base::RefCountedDeleteOnSequence<DirectoryThreadState>;
+
+  ~DirectoryThreadState() = default;
+
+  scoped_refptr<filesystem::LockTable> lock_table_;
+
+  DISALLOW_COPY_AND_ASSIGN(DirectoryThreadState);
+};
+
+Catalog::Catalog(const std::vector<service_manager::Manifest>& manifests) {
+  if (!manifests.empty()) {
+    for (const auto& manifest : manifests)
+      system_cache_.AddRootEntryFromManifest(manifest);
+  } else {
+    for (const auto& manifest : GetDefaultManifests())
+      system_cache_.AddRootEntryFromManifest(manifest);
+  }
+
+  registry_.AddInterface<mojom::Catalog>(base::BindRepeating(
+      &Catalog::BindCatalogRequest, base::Unretained(this)));
+  registry_.AddInterface<filesystem::mojom::Directory>(base::BindRepeating(
+      &Catalog::BindDirectoryRequest, base::Unretained(this)));
+}
+
+Catalog::~Catalog() = default;
+
+void Catalog::BindServiceRequest(
+    service_manager::mojom::ServiceRequest request) {
+  service_binding_.Bind(std::move(request));
+}
+
+// static
+void Catalog::SetDefaultCatalogManifest(
+    const std::vector<service_manager::Manifest>& manifests) {
+  GetDefaultManifests() = manifests;
+}
+
+Instance* Catalog::GetInstanceForGroup(const base::Token& instance_group) {
+  auto it = instances_.find(instance_group);
+  if (it != instances_.end())
+    return it->second.get();
+
+  auto result = instances_.emplace(instance_group,
+                                   std::make_unique<Instance>(&system_cache_));
+  return result.first->second.get();
+}
+
+void Catalog::BindCatalogRequest(
+    mojom::CatalogRequest request,
+    const service_manager::BindSourceInfo& source_info) {
+  Instance* instance =
+      GetInstanceForGroup(source_info.identity.instance_group());
+  instance->BindCatalog(std::move(request));
+}
+
+void Catalog::BindDirectoryRequest(
+    filesystem::mojom::DirectoryRequest request,
+    const service_manager::BindSourceInfo& source_info) {
+  if (!directory_task_runner_) {
+    directory_task_runner_ = base::CreateSequencedTaskRunnerWithTraits(
+        {base::MayBlock(),
+         // Use USER_BLOCKING as this gates showing UI during startup.
+         base::TaskPriority::USER_BLOCKING,
+         base::TaskShutdownBehavior::SKIP_ON_SHUTDOWN});
+    directory_thread_state_ = new DirectoryThreadState(directory_task_runner_);
+  }
+  directory_task_runner_->PostTask(
+      FROM_HERE,
+      base::BindOnce(&Catalog::BindDirectoryRequestOnBackgroundThread,
+                     directory_thread_state_, std::move(request), source_info));
+}
+
+// static
+void Catalog::BindDirectoryRequestOnBackgroundThread(
+    scoped_refptr<DirectoryThreadState> thread_state,
+    filesystem::mojom::DirectoryRequest request,
+    const service_manager::BindSourceInfo& source_info) {
+  base::FilePath resources_path;
+  base::PathService::Get(base::DIR_MODULE, &resources_path);
+  mojo::MakeStrongBinding(
+      std::make_unique<filesystem::DirectoryImpl>(
+          resources_path, scoped_refptr<filesystem::SharedTempDir>(),
+          thread_state->lock_table()),
+      std::move(request));
+}
+
+void Catalog::OnBindInterface(
+    const service_manager::BindSourceInfo& source_info,
+    const std::string& interface_name,
+    mojo::ScopedMessagePipeHandle interface_pipe) {
+  registry_.BindInterface(interface_name, std::move(interface_pipe),
+                          source_info);
+}
+
+}  // namespace catalog
diff -BbuN a/services/catalog/catalog.h b/services/catalog/catalog.h
--- a/services/catalog/catalog.h	1970-01-01 03:00:00.000000000 +0300
+++ b/services/catalog/catalog.h	2019-05-17 18:53:37.792000000 +0300
@@ -0,0 +1,92 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef SERVICES_CATALOG_CATALOG_H_
+#define SERVICES_CATALOG_CATALOG_H_
+
+#include <map>
+#include <memory>
+#include <string>
+
+#include "base/component_export.h"
+#include "base/macros.h"
+#include "base/memory/ref_counted.h"
+#include "base/token.h"
+#include "components/services/filesystem/public/interfaces/directory.mojom.h"
+#include "mojo/public/cpp/bindings/binding.h"
+#include "mojo/public/cpp/bindings/binding_set.h"
+#include "services/catalog/entry_cache.h"
+#include "services/catalog/public/mojom/catalog.mojom.h"
+#include "services/service_manager/public/cpp/binder_registry.h"
+#include "services/service_manager/public/cpp/manifest.h"
+#include "services/service_manager/public/cpp/service.h"
+#include "services/service_manager/public/cpp/service_binding.h"
+#include "services/service_manager/public/mojom/service.mojom.h"
+
+namespace base {
+class SequencedTaskRunner;
+}
+
+namespace catalog {
+
+class Instance;
+
+// Creates and owns an instance of the catalog. Exposes a ServicePtr that
+// can be passed to the service manager, potentially in a different process.
+class COMPONENT_EXPORT(CATALOG) Catalog : public service_manager::Service {
+ public:
+  // Constructs a catalog over a set of Manifests to use for lookup.
+  explicit Catalog(const std::vector<service_manager::Manifest>& manifests);
+  ~Catalog() override;
+
+  void BindServiceRequest(service_manager::mojom::ServiceRequest request);
+
+  // Allows an embedder to override the default static manifest contents for
+  // Catalog instances which are constructed with an empty set of manifests.
+  static void SetDefaultCatalogManifest(
+      const std::vector<service_manager::Manifest>& default_manifests);
+
+  Instance* GetInstanceForGroup(const base::Token& instance_group);
+
+ private:
+  class DirectoryThreadState;
+  class ServiceImpl;
+
+  void BindCatalogRequest(mojom::CatalogRequest request,
+                          const service_manager::BindSourceInfo& source_info);
+
+  void BindDirectoryRequest(filesystem::mojom::DirectoryRequest request,
+                            const service_manager::BindSourceInfo& source_info);
+
+  static void BindDirectoryRequestOnBackgroundThread(
+      scoped_refptr<DirectoryThreadState> thread_state,
+      filesystem::mojom::DirectoryRequest request,
+      const service_manager::BindSourceInfo& source_info);
+
+  // service_manager::Service:
+  void OnBindInterface(const service_manager::BindSourceInfo& source_info,
+                       const std::string& interface_name,
+                       mojo::ScopedMessagePipeHandle interface_pipe) override;
+
+  service_manager::ServiceBinding service_binding_{this};
+  service_manager::BinderRegistryWithArgs<
+      const service_manager::BindSourceInfo&>
+      registry_;
+
+  EntryCache system_cache_;
+  std::map<base::Token, std::unique_ptr<Instance>> instances_;
+
+  // The TaskRunner used for directory requests. Directory requests run on a
+  // separate thread as they run file io, which is not allowed on the thread the
+  // service manager runs on. Additionally we shouldn't block the service
+  // manager while doing file io.
+  scoped_refptr<base::SequencedTaskRunner> directory_task_runner_;
+  scoped_refptr<DirectoryThreadState> directory_thread_state_;
+
+  DISALLOW_COPY_AND_ASSIGN(Catalog);
+};
+
+}  // namespace catalog
+
+#endif  // SERVICES_CATALOG_CATALOG_H_
diff -BbuN a/services/catalog/constants.cc b/services/catalog/constants.cc
--- a/services/catalog/constants.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/services/catalog/constants.cc	2019-05-17 18:53:37.792000000 +0300
@@ -0,0 +1,11 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "services/catalog/constants.h"
+
+namespace catalog {
+
+const char kPackagesDirName[] = "Packages";
+
+}  // namespace catalog
diff -BbuN a/services/catalog/constants.h b/services/catalog/constants.h
--- a/services/catalog/constants.h	1970-01-01 03:00:00.000000000 +0300
+++ b/services/catalog/constants.h	2019-05-17 18:53:37.792000000 +0300
@@ -0,0 +1,16 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef SERVICES_CATALOG_CONSTANTS_H_
+#define SERVICES_CATALOG_CONSTANTS_H_
+
+#include "base/component_export.h"
+
+namespace catalog {
+
+COMPONENT_EXPORT(CATALOG) extern const char kPackagesDirName[];
+
+}  // namespace catalog
+
+#endif  // SERVICES_CATALOG_CONSTANTS_H_
diff -BbuN a/services/catalog/DEPS b/services/catalog/DEPS
--- a/services/catalog/DEPS	1970-01-01 03:00:00.000000000 +0300
+++ b/services/catalog/DEPS	2019-05-17 18:53:37.792000000 +0300
@@ -0,0 +1,3 @@
+include_rules = [
+  "+components/services/filesystem"
+]
diff -BbuN a/services/catalog/entry_cache.cc b/services/catalog/entry_cache.cc
--- a/services/catalog/entry_cache.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/services/catalog/entry_cache.cc	2019-05-17 18:53:37.792000000 +0300
@@ -0,0 +1,158 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "services/catalog/entry_cache.h"
+
+#include <map>
+#include <set>
+#include <string>
+
+#include "base/base_paths.h"
+#include "base/files/file_path.h"
+#include "base/path_service.h"
+#include "build/build_config.h"
+#include "services/catalog/entry.h"
+#include "services/service_manager/public/cpp/interface_provider_spec.h"
+#include "services/service_manager/public/mojom/interface_provider_spec.mojom.h"
+
+namespace catalog {
+
+namespace {
+
+#if defined(OS_WIN)
+const char kServiceExecutableExtension[] = ".service.exe";
+#else
+const char kServiceExecutableExtension[] = ".service";
+#endif
+
+// Temporary helper to create a cache Entry from a Manifest object. This can
+// disappear once the Service Manager just uses Manifest objects directly.
+std::unique_ptr<Entry> MakeEntryFromManifest(
+    const service_manager::Manifest& manifest) {
+  auto entry = std::make_unique<Entry>();
+  entry->set_name(manifest.service_name);
+  entry->set_display_name(manifest.display_name.raw_string);
+
+  base::FilePath service_exe_root;
+  CHECK(base::PathService::Get(base::DIR_ASSETS, &service_exe_root));
+  entry->set_path(service_exe_root.AppendASCII(entry->name() +
+                                               kServiceExecutableExtension));
+
+  entry->set_sandbox_type(manifest.options.sandbox_type);
+
+  ServiceOptions options;
+  switch (manifest.options.instance_sharing_policy) {
+    case service_manager::Manifest::InstanceSharingPolicy::kNoSharing:
+      options.instance_sharing = ServiceOptions::InstanceSharingType::NONE;
+      break;
+    case service_manager::Manifest::InstanceSharingPolicy::kSingleton:
+      options.instance_sharing = ServiceOptions::InstanceSharingType::SINGLETON;
+      break;
+    case service_manager::Manifest::InstanceSharingPolicy::kSharedAcrossGroups:
+      options.instance_sharing =
+          ServiceOptions::InstanceSharingType::SHARED_ACROSS_INSTANCE_GROUPS;
+      break;
+  }
+  options.can_connect_to_instances_in_any_group =
+      manifest.options.can_connect_to_instances_in_any_group;
+  options.can_connect_to_other_services_with_any_instance_name =
+      manifest.options.can_connect_to_instances_with_any_id;
+  options.can_create_other_service_instances =
+      manifest.options.can_register_other_service_instances;
+  options.interfaces_bindable_on_any_service =
+      manifest.interfaces_bindable_on_any_service;
+  entry->AddOptions(options);
+
+  service_manager::InterfaceProviderSpec main_spec;
+  for (const auto& entry : manifest.exposed_capabilities)
+    main_spec.provides.emplace(entry.capability_name, entry.interface_names);
+  for (const auto& entry : manifest.required_capabilities) {
+    main_spec.requires[entry.service_name].insert(entry.capability_name);
+  }
+
+  entry->AddInterfaceProviderSpec(
+      service_manager::mojom::kServiceManager_ConnectorSpec,
+      std::move(main_spec));
+
+  std::map<std::string, service_manager::InterfaceProviderSpec> other_specs;
+  for (const auto& entry : manifest.exposed_interface_filter_capabilities) {
+    other_specs[entry.filter_name].provides.emplace(entry.capability_name,
+                                                    entry.interface_names);
+  }
+
+  for (const auto& entry : manifest.required_interface_filter_capabilities) {
+    other_specs[entry.filter_name].requires[entry.service_name].insert(
+        entry.capability_name);
+  }
+
+  for (auto& spec : other_specs)
+    entry->AddInterfaceProviderSpec(spec.first, std::move(spec.second));
+
+  for (const auto& file : manifest.preloaded_files)
+    entry->AddRequiredFilePath(file.key, file.path);
+
+  for (const auto& packaged_service_manifest : manifest.packaged_services) {
+    auto child = MakeEntryFromManifest(packaged_service_manifest);
+    child->set_parent(entry.get());
+    entry->children().emplace_back(std::move(child));
+  }
+
+  return entry;
+}
+
+}  // namespace
+
+EntryCache::EntryCache() {}
+
+EntryCache::~EntryCache() {}
+
+bool EntryCache::AddRootEntry(std::unique_ptr<Entry> entry) {
+  DCHECK(entry);
+  const std::string& name = entry->name();
+  if (!AddEntry(entry.get()))
+    return false;
+  root_entries_.insert(std::make_pair(name, std::move(entry)));
+  return true;
+}
+
+bool EntryCache::AddRootEntryFromManifest(
+    const service_manager::Manifest& manifest) {
+  return AddRootEntry(MakeEntryFromManifest(manifest));
+}
+
+const Entry* EntryCache::GetEntry(const std::string& name) {
+  auto iter = entries_.find(name);
+  if (iter == entries_.end())
+    return nullptr;
+  return iter->second;
+}
+
+bool EntryCache::AddEntry(const Entry* entry) {
+  auto root_iter = root_entries_.find(entry->name());
+  if (root_iter != root_entries_.end()) {
+    RemoveEntry(root_iter->second.get());
+    root_entries_.erase(root_iter);
+  } else {
+    auto entry_iter = entries_.find(entry->name());
+    if (entry_iter != entries_.end()) {
+      // There's already a non-root entry for this name, so we change nothing.
+      return false;
+    }
+  }
+
+  entries_.insert({ entry->name(), entry });
+  for (const auto& child : entry->children())
+    AddEntry(child.get());
+  return true;
+}
+
+void EntryCache::RemoveEntry(const Entry* entry) {
+  auto iter = entries_.find(entry->name());
+  if (iter->second == entry)
+    entries_.erase(iter);
+  for (const auto& child : entry->children())
+    RemoveEntry(child.get());
+}
+
+}  // namespace catalog
diff -BbuN a/services/catalog/entry_cache.h b/services/catalog/entry_cache.h
--- a/services/catalog/entry_cache.h	1970-01-01 03:00:00.000000000 +0300
+++ b/services/catalog/entry_cache.h	2019-05-17 18:53:37.792000000 +0300
@@ -0,0 +1,75 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef SERVICES_CATALOG_ENTRY_CACHE_H_
+#define SERVICES_CATALOG_ENTRY_CACHE_H_
+
+#include <map>
+#include <memory>
+#include <string>
+
+#include "base/component_export.h"
+#include "base/macros.h"
+#include "services/service_manager/public/cpp/manifest.h"
+
+namespace catalog {
+
+class Entry;
+
+// Indexed storage for all existing service catalog entries.
+class COMPONENT_EXPORT(CATALOG) EntryCache {
+ public:
+  EntryCache();
+  ~EntryCache();
+
+  // All entries in the cache, including non-root entries.
+  const std::map<std::string, const Entry*>& entries() const {
+    return entries_;
+  }
+
+  // Adds a new root entry to the cache. If a root entry already exists
+  // corresponding to the new entry's name, the old root entry is removed first,
+  // along with its children.
+  //
+  // If a non-root entry already exists corresponding to the new entry's name,
+  // the new entry is ignored.
+  //
+  // Returns |true| if the entry was added and |false| otherwise.
+  //
+  // TODO(rockot): Duplicate entries should be treated as an error, but for now
+  // we tolerate them because of some remaining dependency on Package directory
+  // scanning, which in turn has some unpredictable behavior with respect to
+  // Entry registration.
+  bool AddRootEntry(std::unique_ptr<Entry> entry);
+
+  // Adds a new root entry to the cache given a Manifest.
+  bool AddRootEntryFromManifest(const service_manager::Manifest& manifest);
+
+  // Queries the cache for an entry corresponding to |name|. Returns null if
+  // such an entry is not found.
+  const Entry* GetEntry(const std::string& name);
+
+ private:
+  // Adds and entry and its children to |entries_|. Returns |true| if the Entry
+  // was successfully added and |false| otherwise.
+  bool AddEntry(const Entry* entry);
+
+  // Removes an entry and its children from |entries_|.
+  void RemoveEntry(const Entry* entry);
+
+  // Map of top-level service entries. This transitively owns all existing
+  // Entry objects.
+  std::map<std::string, std::unique_ptr<Entry>> root_entries_;
+
+  // Map of service name to Entry. Each value points to an Entry owned either
+  // directly or indirectly by |entries_| above. This is essentially a flattened
+  // version of |entries_| with no ownership.
+  std::map<std::string, const Entry*> entries_;
+
+  DISALLOW_COPY_AND_ASSIGN(EntryCache);
+};
+
+}  // namespace catalog
+
+#endif  // SERVICES_CATALOG_ENTRY_CACHE_H_
diff -BbuN a/services/catalog/entry.cc b/services/catalog/entry.cc
--- a/services/catalog/entry.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/services/catalog/entry.cc	2019-05-17 18:53:37.792000000 +0300
@@ -0,0 +1,64 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "services/catalog/entry.h"
+
+#include "base/files/file_path.h"
+#include "services/catalog/store.h"
+#include "services/service_manager/public/mojom/interface_provider_spec.mojom.h"
+
+namespace catalog {
+
+Entry::Entry() {}
+Entry::Entry(const std::string& name)
+    : name_(name),
+      display_name_(name) {}
+Entry::~Entry() {}
+
+bool Entry::ProvidesCapability(const std::string& capability) const {
+  auto it = interface_provider_specs_.find(
+      service_manager::mojom::kServiceManager_ConnectorSpec);
+  if (it == interface_provider_specs_.end())
+    return false;
+
+  const auto& connection_spec = it->second;
+  return connection_spec.provides.find(capability) !=
+      connection_spec.provides.end();
+}
+
+bool Entry::operator==(const Entry& other) const {
+  return other.name_ == name_ && other.display_name_ == display_name_ &&
+         other.sandbox_type_ == sandbox_type_ &&
+         other.interface_provider_specs_ == interface_provider_specs_;
+}
+
+void Entry::AddOptions(ServiceOptions options) {
+  options_ = std::move(options);
+}
+
+void Entry::AddInterfaceProviderSpec(
+    const std::string& name,
+    service_manager::InterfaceProviderSpec spec) {
+  interface_provider_specs_[name] = std::move(spec);
+}
+
+void Entry::AddRequiredFilePath(const std::string& name, base::FilePath path) {
+  required_file_paths_[name] = std::move(path);
+}
+
+}  // catalog
+
+namespace mojo {
+
+// static
+catalog::mojom::EntryPtr
+    TypeConverter<catalog::mojom::EntryPtr, catalog::Entry>::Convert(
+        const catalog::Entry& input) {
+  catalog::mojom::EntryPtr result(catalog::mojom::Entry::New());
+  result->name = input.name();
+  result->display_name = input.display_name();
+  return result;
+}
+
+}  // namespace mojo
diff -BbuN a/services/catalog/entry.h b/services/catalog/entry.h
--- a/services/catalog/entry.h	1970-01-01 03:00:00.000000000 +0300
+++ b/services/catalog/entry.h	2019-05-17 18:53:37.792000000 +0300
@@ -0,0 +1,100 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef SERVICES_CATALOG_ENTRY_H_
+#define SERVICES_CATALOG_ENTRY_H_
+
+#include <memory>
+#include <string>
+#include <vector>
+
+#include "base/component_export.h"
+#include "base/files/file_path.h"
+#include "base/macros.h"
+#include "services/catalog/public/mojom/catalog.mojom.h"
+#include "services/catalog/service_options.h"
+#include "services/service_manager/public/cpp/interface_provider_spec.h"
+
+namespace catalog {
+
+// Static information about a service package known to the Catalog.
+class COMPONENT_EXPORT(CATALOG) Entry {
+ public:
+  Entry();
+  explicit Entry(const std::string& name);
+  ~Entry();
+
+  bool ProvidesCapability(const std::string& capability) const;
+
+  bool operator==(const Entry& other) const;
+
+  const std::string& name() const { return name_; }
+  void set_name(std::string name) { name_ = std::move(name); }
+
+  const base::FilePath& path() const { return path_; }
+  void set_path(base::FilePath path) { path_ = std::move(path); }
+
+  const std::string& display_name() const { return display_name_; }
+  void set_display_name(std::string display_name) {
+    display_name_ = std::move(display_name);
+  }
+
+  const std::string& sandbox_type() const { return sandbox_type_; }
+  void set_sandbox_type(std::string sandbox_type) {
+    sandbox_type_ = std::move(sandbox_type);
+  }
+
+  const Entry* parent() const { return parent_; }
+  void set_parent(const Entry* parent) { parent_ = parent; }
+
+  const std::vector<std::unique_ptr<Entry>>& children() const {
+    return children_;
+  }
+  std::vector<std::unique_ptr<Entry>>& children() { return children_; }
+  void set_children(std::vector<std::unique_ptr<Entry>> children) {
+    children_ = std::move(children);
+  }
+
+  void AddOptions(ServiceOptions options);
+  const ServiceOptions& options() const { return options_; }
+
+  void AddInterfaceProviderSpec(const std::string& name,
+                                service_manager::InterfaceProviderSpec spec);
+  const service_manager::InterfaceProviderSpecMap&
+      interface_provider_specs() const {
+    return interface_provider_specs_;
+  }
+
+  void AddRequiredFilePath(const std::string& name, base::FilePath path);
+  const std::map<std::string, base::FilePath>& required_file_paths() const {
+    return required_file_paths_;
+  }
+
+ private:
+  std::string name_;
+  base::FilePath path_;
+  std::string display_name_;
+  std::string sandbox_type_;
+  ServiceOptions options_;
+
+  service_manager::InterfaceProviderSpecMap interface_provider_specs_;
+  std::map<std::string, base::FilePath> required_file_paths_;
+  const Entry* parent_ = nullptr;
+  std::vector<std::unique_ptr<Entry>> children_;
+
+  DISALLOW_COPY_AND_ASSIGN(Entry);
+};
+
+}  // namespace catalog
+
+namespace mojo {
+
+template<>
+struct TypeConverter<catalog::mojom::EntryPtr, catalog::Entry> {
+  static catalog::mojom::EntryPtr Convert(const catalog::Entry& input);
+};
+
+}  // namespace mojo
+
+#endif  // SERVICES_CATALOG_ENTRY_H_
diff -BbuN a/services/catalog/instance.cc b/services/catalog/instance.cc
--- a/services/catalog/instance.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/services/catalog/instance.cc	2019-05-17 18:53:37.792000000 +0300
@@ -0,0 +1,74 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "services/catalog/instance.h"
+
+#include <memory>
+
+#include "base/bind.h"
+#include "base/values.h"
+#include "services/catalog/entry.h"
+#include "services/catalog/entry_cache.h"
+
+namespace catalog {
+namespace {
+
+void AddEntry(const Entry& entry, std::vector<mojom::EntryPtr>* ary) {
+  mojom::EntryPtr entry_ptr(mojom::Entry::New());
+  entry_ptr->name = entry.name();
+  entry_ptr->display_name = entry.display_name();
+  ary->push_back(std::move(entry_ptr));
+}
+
+}  // namespace
+
+Instance::Instance(EntryCache* system_cache) : system_cache_(system_cache) {}
+
+Instance::~Instance() = default;
+
+void Instance::BindCatalog(mojom::CatalogRequest request) {
+  catalog_bindings_.AddBinding(this, std::move(request));
+}
+
+const Entry* Instance::Resolve(const std::string& service_name) {
+  DCHECK(system_cache_);
+  const Entry* cached_entry = system_cache_->GetEntry(service_name);
+  if (cached_entry)
+    return cached_entry;
+
+  LOG(ERROR) << "Unable to locate service manifest for " << service_name;
+  return nullptr;
+}
+
+void Instance::GetEntries(const base::Optional<std::vector<std::string>>& names,
+                          GetEntriesCallback callback) {
+  DCHECK(system_cache_);
+
+  std::vector<mojom::EntryPtr> entries;
+  if (!names.has_value()) {
+    // TODO(beng): user catalog.
+    for (const auto& entry : system_cache_->entries())
+      AddEntry(*entry.second, &entries);
+  } else {
+    for (const std::string& name : names.value()) {
+      const Entry* entry = system_cache_->GetEntry(name);
+      // TODO(beng): user catalog.
+      if (entry)
+        AddEntry(*entry, &entries);
+    }
+  }
+  std::move(callback).Run(std::move(entries));
+}
+
+void Instance::GetEntriesProvidingCapability(
+    const std::string& capability,
+    GetEntriesProvidingCapabilityCallback callback) {
+  std::vector<mojom::EntryPtr> entries;
+  for (const auto& entry : system_cache_->entries())
+    if (entry.second->ProvidesCapability(capability))
+      entries.push_back(mojom::Entry::From(*entry.second));
+  std::move(callback).Run(std::move(entries));
+}
+
+}  // namespace catalog
diff -BbuN a/services/catalog/instance.h b/services/catalog/instance.h
--- a/services/catalog/instance.h	1970-01-01 03:00:00.000000000 +0300
+++ b/services/catalog/instance.h	2019-05-17 18:53:37.792000000 +0300
@@ -0,0 +1,51 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef SERVICES_CATALOG_INSTANCE_H_
+#define SERVICES_CATALOG_INSTANCE_H_
+
+#include "base/component_export.h"
+#include "base/files/file_path.h"
+#include "base/path_service.h"
+#include "base/values.h"
+#include "mojo/public/cpp/bindings/binding_set.h"
+#include "services/catalog/entry.h"
+#include "services/catalog/public/mojom/catalog.mojom.h"
+#include "services/catalog/store.h"
+
+namespace catalog {
+
+class EntryCache;
+
+class COMPONENT_EXPORT(CATALOG) Instance : public mojom::Catalog {
+ public:
+  // |system_cache| is not owned.
+  explicit Instance(EntryCache* system_cache);
+  ~Instance() override;
+
+  void BindCatalog(mojom::CatalogRequest request);
+
+  const Entry* Resolve(const std::string& service_name);
+
+ private:
+  // mojom::Catalog:
+  void GetEntries(const base::Optional<std::vector<std::string>>& names,
+                  GetEntriesCallback callback) override;
+  void GetEntriesProvidingCapability(
+      const std::string& capability,
+      GetEntriesProvidingCapabilityCallback callback) override;
+
+  mojo::BindingSet<mojom::Catalog> catalog_bindings_;
+
+  // A map of name -> Entry data structure for system-level packages (i.e. those
+  // that are visible to all users).
+  // TODO(beng): eventually add per-user applications.
+  EntryCache* const system_cache_;
+
+  DISALLOW_COPY_AND_ASSIGN(Instance);
+};
+
+}  // namespace catalog
+
+#endif  // SERVICES_CATALOG_INSTANCE_H_
diff -BbuN a/services/catalog/OWNERS b/services/catalog/OWNERS
--- a/services/catalog/OWNERS	1970-01-01 03:00:00.000000000 +0300
+++ b/services/catalog/OWNERS	2019-05-17 18:53:37.792000000 +0300
@@ -0,0 +1,5 @@
+ben@chromium.org
+rockot@google.com
+
+per-file manifest.json=set noparent
+per-file manifest.json=file://ipc/SECURITY_OWNERS
Общие подкаталоги: a/services/catalog/public и b/services/catalog/public
diff -BbuN a/services/catalog/service_options.cc b/services/catalog/service_options.cc
--- a/services/catalog/service_options.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/services/catalog/service_options.cc	2019-05-17 18:53:37.792000000 +0300
@@ -0,0 +1,15 @@
+// Copyright 2019 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "services/catalog/service_options.h"
+
+namespace catalog {
+
+ServiceOptions::ServiceOptions() = default;
+
+ServiceOptions::ServiceOptions(const ServiceOptions& other) = default;
+
+ServiceOptions::~ServiceOptions() = default;
+
+}  // namespace catalog
diff -BbuN a/services/catalog/service_options.h b/services/catalog/service_options.h
--- a/services/catalog/service_options.h	1970-01-01 03:00:00.000000000 +0300
+++ b/services/catalog/service_options.h	2019-05-17 18:53:37.792000000 +0300
@@ -0,0 +1,36 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef SERVICES_CATALOG_SERVICE_OPTIONS_H_
+#define SERVICES_CATALOG_SERVICE_OPTIONS_H_
+
+#include <set>
+#include <string>
+
+#include "base/component_export.h"
+#include "base/macros.h"
+
+namespace catalog {
+
+struct COMPONENT_EXPORT(CATALOG) ServiceOptions {
+  enum class InstanceSharingType {
+    NONE,
+    SINGLETON,
+    SHARED_ACROSS_INSTANCE_GROUPS,
+  };
+
+  ServiceOptions();
+  ServiceOptions(const ServiceOptions& other);
+  ~ServiceOptions();
+
+  InstanceSharingType instance_sharing = InstanceSharingType::NONE;
+  bool can_connect_to_instances_in_any_group = false;
+  bool can_connect_to_other_services_with_any_instance_name = false;
+  bool can_create_other_service_instances = false;
+  std::set<std::string> interfaces_bindable_on_any_service;
+};
+
+}  // namespace catalog
+
+#endif  // SERVICES_CATALOG_SERVICE_OPTIONS_H_
diff -BbuN a/services/catalog/store.cc b/services/catalog/store.cc
--- a/services/catalog/store.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/services/catalog/store.cc	2019-05-17 18:53:37.792000000 +0300
@@ -0,0 +1,42 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "services/catalog/store.h"
+
+namespace catalog {
+
+// static
+const char Store::kNameKey[] = "name";
+// static
+const char Store::kDisplayNameKey[] = "display_name";
+// static
+const char Store::kSandboxTypeKey[] = "sandbox_type";
+// static
+const char Store::kOptionsKey[] = "options";
+// static
+const char Store::kInterfaceProviderSpecsKey[] = "interface_provider_specs";
+// static
+const char Store::kInterfaceProviderSpecs_ProvidesKey[] = "provides";
+// static
+const char Store::kInterfaceProviderSpecs_RequiresKey[] = "requires";
+// static
+const char Store::kServicesKey[] = "services";
+// static
+const char Store::kRequiredFilesKey[] = "required_files";
+// static
+const char Store::kRequiredFilesKey_PathKey[] = "path";
+// static
+const char Store::kRequiredFilesKey_PlatformKey[] = "platform";
+// static
+const char Store::kRequiredFilesKey_PlatformValue_Windows[] = "windows";
+// static
+const char Store::kRequiredFilesKey_PlatformValue_Linux[] = "linux";
+// static
+const char Store::kRequiredFilesKey_PlatformValue_MacOSX[] = "macosx";
+// static
+const char Store::kRequiredFilesKey_PlatformValue_Android[] = "android";
+// static
+const char Store::kRequiredFilesKey_PlatformValue_Fuchsia[] = "fuchsia";
+
+}  // namespace catalog
diff -BbuN a/services/catalog/store.h b/services/catalog/store.h
--- a/services/catalog/store.h	1970-01-01 03:00:00.000000000 +0300
+++ b/services/catalog/store.h	2019-05-17 18:53:37.792000000 +0300
@@ -0,0 +1,45 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef SERVICES_CATALOG_STORE_H_
+#define SERVICES_CATALOG_STORE_H_
+
+namespace catalog {
+
+// TODO(rockot): Clean this up now that it's only a namespace for constants.
+// Alternatively, re-introduce a Store interface once it makes sense to do so.
+class Store {
+ public:
+  // Value is a string.
+  static const char kNameKey[];
+  // Value is a string.
+  static const char kDisplayNameKey[];
+  // Value is a string.
+  static const char kSandboxTypeKey[];
+  // Value is a dictionary.
+  static const char kOptionsKey[];
+  // Value is a dictionary.
+  static const char kInterfaceProviderSpecsKey[];
+  // Value is a dictionary.
+  static const char kInterfaceProviderSpecs_ProvidesKey[];
+  // Value is a dictionary.
+  static const char kInterfaceProviderSpecs_RequiresKey[];
+  // Value is a list.
+  static const char kServicesKey[];
+  // Value is a dictionary.
+  static const char kRequiredFilesKey[];
+  // Value is a string.
+  static const char kRequiredFilesKey_PathKey[];
+  // Value is a string.
+  static const char kRequiredFilesKey_PlatformKey[];
+  static const char kRequiredFilesKey_PlatformValue_Windows[];
+  static const char kRequiredFilesKey_PlatformValue_Linux[];
+  static const char kRequiredFilesKey_PlatformValue_MacOSX[];
+  static const char kRequiredFilesKey_PlatformValue_Android[];
+  static const char kRequiredFilesKey_PlatformValue_Fuchsia[];
+};
+
+}  // namespace catalog
+
+#endif  // SERVICES_CATALOG_STORE_H_
--- a/services/content/manifest.json	1970-01-01 03:00:00.000000000 +0300
+++ b/services/content/manifest.json	2019-05-17 18:53:37.792000000 +0300
@@ -0,0 +1,17 @@
+{
+  "name": "content",
+  "display_name": "Content Service",
+  "interface_provider_specs": {
+    "service_manager:connector": {
+      "provides": {
+        // The |navigation| capability allows a service to acquire embeddable,
+        // navigable contents. for now, access to this capability should be
+        // restricted only to services which are at least as trusted as the
+        // Chrome browser process (e.g., Ash).
+        "navigation": [
+          "content.mojom.NavigableContentsFactory"
+        ]
+      }
+    }
+  }
+}
--- a/services/content/simple_browser/manifest.json	1970-01-01 03:00:00.000000000 +0300
+++ b/services/content/simple_browser/manifest.json	2019-05-17 18:53:37.796000000 +0300
@@ -0,0 +1,18 @@
+{
+  "name": "simple_browser",
+  "display_name": "Simple Browser",
+  "sandbox_type": "utility",
+  "interface_provider_specs": {
+    "service_manager:connector": {
+      "provides": {
+        // Dummy capability so someone can start/connect.
+        "app": []
+      },
+      "requires": {
+        "content": [ "navigation" ],
+        "font_service": [ "font_service" ],
+        "ui": [ "app" ]
+      }
+    }
+  }
+}
--- a/services/data_decoder/manifest.json	1970-01-01 03:00:00.000000000 +0300
+++ b/services/data_decoder/manifest.json	2019-05-17 18:53:37.796000000 +0300
@@ -0,0 +1,16 @@
+{
+  "name": "data_decoder",
+  "display_name": "Data Decoder Service",
+  "options" : {
+    "instance_sharing" : "shared_instance_across_users"
+  },
+  "interface_provider_specs": {
+    "service_manager:connector": {
+      "provides": {
+        "image_decoder": [ "data_decoder.mojom.ImageDecoder" ],
+        "json_parser": [ "data_decoder.mojom.JsonParser" ],
+        "xml_parser": [ "data_decoder.mojom.XmlParser" ]
+      }
+    }
+  }
+}
Двоичные файлы a/services/device/hid/fuzz_corpus/report0 и b/services/device/hid/fuzz_corpus/report0 различаются
Двоичные файлы a/services/device/hid/fuzz_corpus/report1 и b/services/device/hid/fuzz_corpus/report1 различаются
Двоичные файлы a/services/device/hid/fuzz_corpus/report2 и b/services/device/hid/fuzz_corpus/report2 различаются
Двоичные файлы a/services/device/hid/fuzz_corpus/report3 и b/services/device/hid/fuzz_corpus/report3 различаются
Двоичные файлы a/services/device/hid/fuzz_corpus/report4 и b/services/device/hid/fuzz_corpus/report4 различаются
--- a/services/device/manifest.json	1970-01-01 03:00:00.000000000 +0300
+++ b/services/device/manifest.json	2019-05-17 18:53:37.832000000 +0300
@@ -0,0 +1,33 @@
+{
+  "name": "device",
+  "display_name": "Device Service",
+  "options" : {
+    "instance_sharing" : "shared_instance_across_users"
+  },
+  "interface_provider_specs": {
+    "service_manager:connector": {
+      "provides": {
+        "device:battery_monitor": [ "device.mojom.BatteryMonitor" ],
+        "device:bluetooth_system": [ "device.mojom.BluetoothSystemFactory" ],
+        "device:fingerprint": [ "device.mojom.Fingerprint" ],
+        "device:generic_sensor": [ "device.mojom.SensorProvider" ],
+        "device:geolocation": [ "device.mojom.GeolocationContext" ],
+        "device:geolocation_config": [ "device.mojom.GeolocationConfig" ],
+        "device:geolocation_control": [ "device.mojom.GeolocationControl" ],
+        "device:hid": [ "device.mojom.HidManager" ],
+        "device:input_service": [ "device.mojom.InputDeviceManager" ],
+        "device:ip_geolocator": [ "device.mojom.PublicIpAddressGeolocationProvider" ],
+        "device:mtp": [ "device.mojom.MtpManager" ],
+        "device:nfc": [ "device.mojom.NFCProvider" ],
+        "device:power_monitor": [ "device.mojom.PowerMonitor" ],
+        "device:screen_orientation": [ "device.mojom.ScreenOrientationListener" ],
+        "device:serial": [ "device.mojom.SerialPortManager" ],
+        "device:time_zone_monitor": [ "device.mojom.TimeZoneMonitor" ],
+        "device:usb": [ "device.mojom.UsbDeviceManager" ],
+        "device:usb_test": [ "device.mojom.UsbDeviceManagerTest" ],
+        "device:vibration": [ "device.mojom.VibrationManager" ],
+        "device:wake_lock": [ "device.mojom.WakeLockProvider" ]
+      }
+    }
+  }
+}
--- a/services/device/nfc/android/java/borg/chromium/device/nfc/InvalidNfcMessageException.java	1970-01-01 03:00:00.000000000 +0300
+++ b/services/device/nfc/android/java/borg/chromium/device/nfc/InvalidNfcMessageException.java	2019-05-17 18:53:37.836000000 +0300
@@ -0,0 +1,10 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+package org.chromium.device.nfc;
+
+/**
+ * Exception that raised when NfcMessage is found to be invalid during conversion to NdefMessage.
+ */
+public final class InvalidNfcMessageException extends Exception {}
\ В конце файла нет новой строки
--- a/services/device/nfc/android/java/borg/chromium/device/nfc/NfcMessageValidator.java	1970-01-01 03:00:00.000000000 +0300
+++ b/services/device/nfc/android/java/borg/chromium/device/nfc/NfcMessageValidator.java	2019-05-17 18:53:37.836000000 +0300
@@ -0,0 +1,41 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+package org.chromium.device.nfc;
+
+import org.chromium.device.mojom.NfcMessage;
+import org.chromium.device.mojom.NfcRecord;
+import org.chromium.device.mojom.NfcRecordType;
+
+/**
+ * Utility class that provides validation of NfcMessage.
+ */
+public final class NfcMessageValidator {
+    /**
+     * Validates NfcMessage.
+     *
+     * @param message to be validated.
+     * @return true if message is valid, false otherwise.
+     */
+    public static boolean isValid(NfcMessage message) {
+        if (message == null || message.data == null || message.data.length == 0) {
+            return false;
+        }
+
+        for (int i = 0; i < message.data.length; ++i) {
+            if (!isValid(message.data[i])) return false;
+        }
+        return true;
+    }
+
+    /**
+     * Checks that NfcRecord#data and NfcRecord#mediaType fields are valid. NfcRecord#data and
+     * NfcRecord#mediaType fields are omitted for the record with EMPTY type.
+     */
+    private static boolean isValid(NfcRecord record) {
+        if (record == null) return false;
+        if (record.recordType == NfcRecordType.EMPTY) return true;
+        return record.data != null && record.mediaType != null && !record.mediaType.isEmpty();
+    }
+}
--- a/services/file/manifest.json	1970-01-01 03:00:00.000000000 +0300
+++ b/services/file/manifest.json	2019-05-17 18:53:37.856000000 +0300
@@ -0,0 +1,15 @@
+{
+  "name": "file",
+  "display_name": "File Service",
+  "interface_provider_specs": {
+    "service_manager:connector": {
+      "provides": {
+        "file:filesystem": [ "file.mojom.FileSystem" ],
+        "file:leveldb": [ "leveldb.mojom.LevelDBService" ]
+      },
+      "requires": {
+        "*": [ "app" ]
+      }
+    }
+  }
+}
--- a/services/identity/identity_manager_impl.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/services/identity/identity_manager_impl.cc	2019-05-17 18:53:37.860000000 +0300
@@ -0,0 +1,215 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "services/identity/identity_manager_impl.h"
+
+#include <utility>
+
+#include "base/time/time.h"
+#include "components/signin/core/browser/account_tracker_service.h"
+#include "google_apis/gaia/google_service_auth_error.h"
+#include "services/identity/public/mojom/account.mojom.h"
+
+namespace identity {
+
+IdentityManagerImpl::AccessTokenRequest::AccessTokenRequest(
+    const std::string& account_id,
+    const ScopeSet& scopes,
+    const std::string& consumer_id,
+    GetAccessTokenCallback consumer_callback,
+    ProfileOAuth2TokenService* token_service,
+    IdentityManagerImpl* manager)
+    : OAuth2TokenService::Consumer(consumer_id),
+      token_service_(token_service),
+      consumer_callback_(std::move(consumer_callback)),
+      manager_(manager) {
+  token_service_request_ =
+      token_service_->StartRequest(account_id, scopes, this);
+}
+
+IdentityManagerImpl::AccessTokenRequest::~AccessTokenRequest() = default;
+
+void IdentityManagerImpl::AccessTokenRequest::OnGetTokenSuccess(
+    const OAuth2TokenService::Request* request,
+    const OAuth2AccessTokenConsumer::TokenResponse& token_response) {
+  OnRequestCompleted(request, token_response.access_token,
+                     token_response.expiration_time,
+                     GoogleServiceAuthError::AuthErrorNone());
+}
+
+void IdentityManagerImpl::AccessTokenRequest::OnGetTokenFailure(
+    const OAuth2TokenService::Request* request,
+    const GoogleServiceAuthError& error) {
+  OnRequestCompleted(request, base::nullopt, base::Time(), error);
+}
+
+void IdentityManagerImpl::AccessTokenRequest::OnRequestCompleted(
+    const OAuth2TokenService::Request* request,
+    const base::Optional<std::string>& access_token,
+    base::Time expiration_time,
+    const GoogleServiceAuthError& error) {
+  std::move(consumer_callback_).Run(access_token, expiration_time, error);
+
+  // Causes |this| to be deleted.
+  manager_->AccessTokenRequestCompleted(this);
+}
+
+// static
+void IdentityManagerImpl::Create(mojom::IdentityManagerRequest request,
+                                 AccountTrackerService* account_tracker,
+                                 SigninManagerBase* signin_manager,
+                                 ProfileOAuth2TokenService* token_service) {
+  new IdentityManagerImpl(std::move(request), account_tracker, signin_manager,
+                          token_service);
+}
+
+IdentityManagerImpl::IdentityManagerImpl(
+    mojom::IdentityManagerRequest request,
+    AccountTrackerService* account_tracker,
+    SigninManagerBase* signin_manager,
+    ProfileOAuth2TokenService* token_service)
+    : binding_(this, std::move(request)),
+      account_tracker_(account_tracker),
+      signin_manager_(signin_manager),
+      token_service_(token_service) {
+  signin_manager_shutdown_subscription_ =
+      signin_manager_->RegisterOnShutdownCallback(
+          base::BindRepeating(&IdentityManagerImpl::OnSigninManagerShutdown,
+                              base::Unretained(this)));
+  binding_.set_connection_error_handler(base::BindRepeating(
+      &IdentityManagerImpl::OnConnectionError, base::Unretained(this)));
+
+  token_service_->AddObserver(this);
+  signin_manager_->AddObserver(this);
+}
+
+IdentityManagerImpl::~IdentityManagerImpl() {
+  token_service_->RemoveObserver(this);
+  signin_manager_->RemoveObserver(this);
+  binding_.Close();
+}
+
+void IdentityManagerImpl::GetPrimaryAccountInfo(
+    GetPrimaryAccountInfoCallback callback) {
+  // It's annoying that this can't be trivially implemented in terms of
+  // GetAccountInfoFromGaiaId(), but there's no SigninManagerBase method that
+  // directly returns the authenticated GAIA ID. We can of course get it from
+  // the AccountInfo but once we have the AccountInfo we ... have the
+  // AccountInfo.
+  AccountInfo account_info = signin_manager_->GetAuthenticatedAccountInfo();
+  AccountState account_state = GetStateOfAccount(account_info);
+  std::move(callback).Run(account_info, account_state);
+}
+
+void IdentityManagerImpl::GetPrimaryAccountWhenAvailable(
+    GetPrimaryAccountWhenAvailableCallback callback) {
+  AccountInfo account_info = signin_manager_->GetAuthenticatedAccountInfo();
+  AccountState account_state = GetStateOfAccount(account_info);
+
+  if (!account_state.has_refresh_token ||
+      token_service_->RefreshTokenHasError(account_info.account_id)) {
+    primary_account_available_callbacks_.push_back(std::move(callback));
+    return;
+  }
+
+  DCHECK(!account_info.account_id.empty());
+  DCHECK(!account_info.email.empty());
+  DCHECK(!account_info.gaia.empty());
+  std::move(callback).Run(account_info, account_state);
+}
+
+void IdentityManagerImpl::GetAccountInfoFromGaiaId(
+    const std::string& gaia_id,
+    GetAccountInfoFromGaiaIdCallback callback) {
+  AccountInfo account_info = account_tracker_->FindAccountInfoByGaiaId(gaia_id);
+  AccountState account_state = GetStateOfAccount(account_info);
+  std::move(callback).Run(account_info, account_state);
+}
+
+void IdentityManagerImpl::GetAccounts(GetAccountsCallback callback) {
+  std::vector<mojom::AccountPtr> accounts;
+
+  for (const std::string& account_id : token_service_->GetAccounts()) {
+    AccountInfo account_info = account_tracker_->GetAccountInfo(account_id);
+    AccountState account_state = GetStateOfAccount(account_info);
+
+    mojom::AccountPtr account =
+        mojom::Account::New(account_info, account_state);
+
+    if (account->state.is_primary_account) {
+      accounts.insert(accounts.begin(), std::move(account));
+    } else {
+      accounts.push_back(std::move(account));
+    }
+  }
+
+  std::move(callback).Run(std::move(accounts));
+}
+
+void IdentityManagerImpl::GetAccessToken(const std::string& account_id,
+                                         const ScopeSet& scopes,
+                                         const std::string& consumer_id,
+                                         GetAccessTokenCallback callback) {
+  std::unique_ptr<AccessTokenRequest> access_token_request =
+      std::make_unique<AccessTokenRequest>(account_id, scopes, consumer_id,
+                                           std::move(callback), token_service_,
+                                           this);
+
+  access_token_requests_[access_token_request.get()] =
+      std::move(access_token_request);
+}
+
+void IdentityManagerImpl::OnRefreshTokenAvailable(
+    const std::string& account_id) {
+  OnAccountStateChange(account_id);
+}
+
+void IdentityManagerImpl::GoogleSigninSucceeded(
+    const AccountInfo& account_info) {
+  OnAccountStateChange(account_info.account_id);
+}
+
+void IdentityManagerImpl::OnAccountStateChange(const std::string& account_id) {
+  AccountInfo account_info = account_tracker_->GetAccountInfo(account_id);
+  AccountState account_state = GetStateOfAccount(account_info);
+
+  // Check whether the primary account is available and notify any waiting
+  // consumers if so.
+  if (account_state.is_primary_account && account_state.has_refresh_token &&
+      !token_service_->RefreshTokenHasError(account_info.account_id)) {
+    DCHECK(!account_info.account_id.empty());
+    DCHECK(!account_info.email.empty());
+    DCHECK(!account_info.gaia.empty());
+
+    for (auto&& callback : primary_account_available_callbacks_) {
+      std::move(callback).Run(account_info, account_state);
+    }
+    primary_account_available_callbacks_.clear();
+  }
+}
+
+void IdentityManagerImpl::AccessTokenRequestCompleted(
+    AccessTokenRequest* request) {
+  access_token_requests_.erase(request);
+}
+
+AccountState IdentityManagerImpl::GetStateOfAccount(
+    const AccountInfo& account_info) {
+  AccountState account_state;
+  account_state.has_refresh_token =
+      token_service_->RefreshTokenIsAvailable(account_info.account_id);
+  account_state.is_primary_account =
+      (account_info.account_id == signin_manager_->GetAuthenticatedAccountId());
+  return account_state;
+}
+
+void IdentityManagerImpl::OnSigninManagerShutdown() {
+  delete this;
+}
+
+void IdentityManagerImpl::OnConnectionError() {
+  delete this;
+}
+
+}  // namespace identity
--- a/services/identity/identity_manager_impl.h	1970-01-01 03:00:00.000000000 +0300
+++ b/services/identity/identity_manager_impl.h	2019-05-17 18:53:37.860000000 +0300
@@ -0,0 +1,129 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef SERVICES_IDENTITY_IDENTITY_MANAGER_IMPL_H_
+#define SERVICES_IDENTITY_IDENTITY_MANAGER_IMPL_H_
+
+#include "base/callback_list.h"
+#include "components/signin/core/browser/account_info.h"
+#include "components/signin/core/browser/profile_oauth2_token_service.h"
+#include "components/signin/core/browser/signin_manager_base.h"
+#include "mojo/public/cpp/bindings/binding.h"
+#include "services/identity/public/cpp/account_state.h"
+#include "services/identity/public/cpp/scope_set.h"
+#include "services/identity/public/mojom/identity_manager.mojom.h"
+
+class AccountTrackerService;
+
+namespace identity {
+
+class IdentityManagerImpl : public mojom::IdentityManager,
+                            public OAuth2TokenService::Observer,
+                            public SigninManagerBase::Observer {
+ public:
+  static void Create(mojom::IdentityManagerRequest request,
+                     AccountTrackerService* account_tracker,
+                     SigninManagerBase* signin_manager,
+                     ProfileOAuth2TokenService* token_service);
+
+  IdentityManagerImpl(mojom::IdentityManagerRequest request,
+                      AccountTrackerService* account_tracker,
+                      SigninManagerBase* signin_manager,
+                      ProfileOAuth2TokenService* token_service);
+  ~IdentityManagerImpl() override;
+
+ private:
+  // Makes an access token request to the OAuth2TokenService on behalf of a
+  // given consumer that has made the request to the Identity Service.
+  class AccessTokenRequest : public OAuth2TokenService::Consumer {
+   public:
+    AccessTokenRequest(const std::string& account_id,
+                       const ScopeSet& scopes,
+                       const std::string& consumer_id,
+                       GetAccessTokenCallback consumer_callback,
+                       ProfileOAuth2TokenService* token_service,
+                       IdentityManagerImpl* manager);
+    ~AccessTokenRequest() override;
+
+   private:
+    // OAuth2TokenService::Consumer:
+    void OnGetTokenSuccess(const OAuth2TokenService::Request* request,
+                           const OAuth2AccessTokenConsumer::TokenResponse&
+                               token_response) override;
+    void OnGetTokenFailure(const OAuth2TokenService::Request* request,
+                           const GoogleServiceAuthError& error) override;
+
+    // Completes the pending access token request by calling back the consumer.
+    void OnRequestCompleted(const OAuth2TokenService::Request* request,
+                            const base::Optional<std::string>& access_token,
+                            base::Time expiration_time,
+                            const GoogleServiceAuthError& error);
+
+    ProfileOAuth2TokenService* token_service_;
+    std::unique_ptr<OAuth2TokenService::Request> token_service_request_;
+    GetAccessTokenCallback consumer_callback_;
+    IdentityManagerImpl* manager_;
+  };
+  using AccessTokenRequests =
+      std::map<AccessTokenRequest*, std::unique_ptr<AccessTokenRequest>>;
+
+  // mojom::IdentityManager:
+  void GetPrimaryAccountInfo(GetPrimaryAccountInfoCallback callback) override;
+  void GetPrimaryAccountWhenAvailable(
+      GetPrimaryAccountWhenAvailableCallback callback) override;
+  void GetAccountInfoFromGaiaId(
+      const std::string& gaia_id,
+      GetAccountInfoFromGaiaIdCallback callback) override;
+  void GetAccounts(GetAccountsCallback callback) override;
+  void GetAccessToken(const std::string& account_id,
+                      const ScopeSet& scopes,
+                      const std::string& consumer_id,
+                      GetAccessTokenCallback callback) override;
+
+  // OAuth2TokenService::Observer:
+  void OnRefreshTokenAvailable(const std::string& account_id) override;
+
+  // SigninManagerBase::Observer:
+  void GoogleSigninSucceeded(const AccountInfo& account_info) override;
+
+  // Notified when there is a change in the state of the account
+  // corresponding to |account_id|.
+  void OnAccountStateChange(const std::string& account_id);
+
+  // Deletes |request|.
+  void AccessTokenRequestCompleted(AccessTokenRequest* request);
+
+  // Gets the current state of the account represented by |account_info|.
+  AccountState GetStateOfAccount(const AccountInfo& account_info);
+
+  // Called when |signin_manager_| is shutting down. Destroys this instance,
+  // since this instance can't outlive the signin classes that it is depending
+  // on. Note that once IdentityManagerImpl manages the lifetime of its
+  // dependencies internally, this will no longer be necessary.
+  void OnSigninManagerShutdown();
+
+  // Called when |binding_| hits a connection error. Destroys this instance,
+  // since it's no longer needed.
+  void OnConnectionError();
+
+  mojo::Binding<mojom::IdentityManager> binding_;
+  AccountTrackerService* account_tracker_;
+  SigninManagerBase* signin_manager_;
+  ProfileOAuth2TokenService* token_service_;
+
+  std::unique_ptr<base::CallbackList<void()>::Subscription>
+      signin_manager_shutdown_subscription_;
+
+  // The set of pending requests for access tokens.
+  AccessTokenRequests access_token_requests_;
+
+  // List of callbacks that will be notified when the primary account is
+  // available.
+  std::vector<GetPrimaryAccountWhenAvailableCallback>
+      primary_account_available_callbacks_;
+};
+
+}  // namespace identity
+
+#endif  // SERVICES_IDENTITY_IDENTITY_MANAGER_IMPL_H_
--- a/services/identity/identity_manager_impl_unittest.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/services/identity/identity_manager_impl_unittest.cc	2019-05-17 18:53:37.860000000 +0300
@@ -0,0 +1,733 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "base/run_loop.h"
+#include "base/test/scoped_task_environment.h"
+#include "build/build_config.h"
+#include "components/signin/core/browser/account_info.h"
+#include "components/signin/core/browser/account_tracker_service.h"
+#include "components/signin/core/browser/fake_profile_oauth2_token_service.h"
+#include "components/signin/core/browser/fake_signin_manager.h"
+#include "components/signin/core/browser/test_signin_client.h"
+#include "components/sync_preferences/testing_pref_service_syncable.h"
+#include "services/identity/identity_service.h"
+#include "services/identity/public/cpp/account_state.h"
+#include "services/identity/public/cpp/scope_set.h"
+#include "services/identity/public/mojom/constants.mojom.h"
+#include "services/identity/public/mojom/identity_manager.mojom.h"
+#include "services/service_manager/public/cpp/binder_registry.h"
+#include "services/service_manager/public/cpp/test/test_connector_factory.h"
+#include "testing/gtest/include/gtest/gtest.h"
+
+namespace identity {
+namespace {
+
+#if defined(OS_CHROMEOS)
+using SigninManagerForTest = FakeSigninManagerBase;
+#else
+using SigninManagerForTest = FakeSigninManager;
+#endif  // OS_CHROMEOS
+
+const char kTestGaiaId[] = "dummyId";
+const char kTestEmail[] = "me@dummy.com";
+const char kSecondaryTestGaiaId[] = "secondaryDummyId";
+const char kSecondaryTestEmail[] = "metoo@dummy.com";
+const char kTestRefreshToken[] = "dummy-refresh-token";
+const char kTestAccessToken[] = "access_token";
+
+class IdentityManagerImplTest : public testing::Test {
+ public:
+  IdentityManagerImplTest()
+      : signin_client_(&pref_service_),
+        token_service_(&pref_service_),
+#if defined(OS_CHROMEOS)
+        signin_manager_(&signin_client_, &token_service_, &account_tracker_),
+#else
+        signin_manager_(&signin_client_,
+                        &token_service_,
+                        &account_tracker_,
+                        nullptr),
+#endif
+        service_(
+            &account_tracker_,
+            &signin_manager_,
+            &token_service_,
+            test_connector_factory_.RegisterInstance(mojom::kServiceName)) {
+    AccountTrackerService::RegisterPrefs(pref_service_.registry());
+    ProfileOAuth2TokenService::RegisterProfilePrefs(pref_service_.registry());
+    SigninManagerBase::RegisterProfilePrefs(pref_service_.registry());
+    SigninManagerBase::RegisterPrefs(pref_service_.registry());
+
+    account_tracker_.Initialize(&pref_service_, base::FilePath());
+  }
+
+  void TearDown() override {
+    // Shut down the SigninManager so that the IdentityManagerImpl doesn't end
+    // up outliving it.
+    signin_manager_.Shutdown();
+  }
+
+  void OnReceivedPrimaryAccountInfo(
+      base::RepeatingClosure quit_closure,
+      const base::Optional<AccountInfo>& account_info,
+      const AccountState& account_state) {
+    primary_account_info_ = account_info;
+    primary_account_state_ = account_state;
+    quit_closure.Run();
+  }
+
+  void OnPrimaryAccountAvailable(base::RepeatingClosure quit_closure,
+                                 AccountInfo* caller_account_info,
+                                 AccountState* caller_account_state,
+                                 const AccountInfo& account_info,
+                                 const AccountState& account_state) {
+    *caller_account_info = account_info;
+    *caller_account_state = account_state;
+    quit_closure.Run();
+  }
+
+  void OnReceivedAccountInfoFromGaiaId(
+      base::RepeatingClosure quit_closure,
+      const base::Optional<AccountInfo>& account_info,
+      const AccountState& account_state) {
+    account_info_from_gaia_id_ = account_info;
+    account_state_from_gaia_id_ = account_state;
+    quit_closure.Run();
+  }
+
+  void OnGotAccounts(base::RepeatingClosure quit_closure,
+                     std::vector<mojom::AccountPtr>* output,
+                     std::vector<mojom::AccountPtr> accounts) {
+    *output = std::move(accounts);
+    quit_closure.Run();
+  }
+
+  void OnReceivedAccessToken(base::RepeatingClosure quit_closure,
+                             const base::Optional<std::string>& access_token,
+                             base::Time expiration_time,
+                             const GoogleServiceAuthError& error) {
+    access_token_ = access_token;
+    access_token_error_ = error;
+    quit_closure.Run();
+  }
+
+ protected:
+  mojom::IdentityManager* GetIdentityManagerImpl() {
+    if (!identity_manager_) {
+      test_connector_factory_.GetDefaultConnector()->BindInterface(
+          mojom::kServiceName, &identity_manager_);
+    }
+    return identity_manager_.get();
+  }
+
+  void ResetIdentityManagerImpl() { identity_manager_.reset(); }
+
+  void FlushIdentityManagerImplForTesting() {
+    GetIdentityManagerImpl();
+    identity_manager_.FlushForTesting();
+  }
+
+  void SetIdentityManagerImplConnectionErrorHandler(
+      base::RepeatingClosure handler) {
+    GetIdentityManagerImpl();
+    identity_manager_.set_connection_error_handler(handler);
+  }
+
+  base::test::ScopedTaskEnvironment task_environemnt_;
+
+  mojom::IdentityManagerPtr identity_manager_;
+  base::Optional<AccountInfo> primary_account_info_;
+  AccountState primary_account_state_;
+  base::Optional<AccountInfo> account_info_from_gaia_id_;
+  AccountState account_state_from_gaia_id_;
+  base::Optional<std::string> access_token_;
+  GoogleServiceAuthError access_token_error_;
+
+  AccountTrackerService* account_tracker() { return &account_tracker_; }
+  SigninManagerBase* signin_manager() { return &signin_manager_; }
+  FakeProfileOAuth2TokenService* token_service() { return &token_service_; }
+
+ private:
+  sync_preferences::TestingPrefServiceSyncable pref_service_;
+  AccountTrackerService account_tracker_;
+  TestSigninClient signin_client_;
+  FakeProfileOAuth2TokenService token_service_;
+  SigninManagerForTest signin_manager_;
+
+  service_manager::TestConnectorFactory test_connector_factory_;
+  IdentityService service_;
+
+  DISALLOW_COPY_AND_ASSIGN(IdentityManagerImplTest);
+};
+
+// Tests that it is not possible to connect to the Identity Manager if
+// initiated after SigninManager shutdown.
+TEST_F(IdentityManagerImplTest, SigninManagerShutdownBeforeConnection) {
+  AccountInfo sentinel;
+  sentinel.account_id = "sentinel";
+  primary_account_info_ = sentinel;
+
+  // Ensure that the Identity Service has actually been created before
+  // invoking SigninManagerBase::Shutdown(), since otherwise this test will
+  // spin forever. Then reset the Identity Manager so that the next request
+  // makes a fresh connection.
+  FlushIdentityManagerImplForTesting();
+  ResetIdentityManagerImpl();
+
+  // Make a call to connect to the IdentityManagerImpl *after* SigninManager
+  // shutdown; it should get notified of an error when the Identity Service
+  // drops the connection.
+  signin_manager()->Shutdown();
+  base::RunLoop run_loop;
+  SetIdentityManagerImplConnectionErrorHandler(run_loop.QuitClosure());
+
+  GetIdentityManagerImpl()->GetPrimaryAccountInfo(base::BindRepeating(
+      &IdentityManagerImplTest::OnReceivedPrimaryAccountInfo,
+      base::Unretained(this), run_loop.QuitClosure()));
+  run_loop.Run();
+
+  // Verify that the callback to GetPrimaryAccountInfo() was not invoked.
+  EXPECT_TRUE(primary_account_info_);
+  EXPECT_EQ("sentinel", primary_account_info_->account_id);
+}
+
+// Tests that the Identity Manager destroys itself on SigninManager shutdown.
+TEST_F(IdentityManagerImplTest, SigninManagerShutdownAfterConnection) {
+  base::RunLoop run_loop;
+  SetIdentityManagerImplConnectionErrorHandler(run_loop.QuitClosure());
+
+  // Ensure that the IdentityManagerImpl instance has actually been created
+  // before invoking SigninManagerBase::Shutdown(), since otherwise this test
+  // will spin forever.
+  FlushIdentityManagerImplForTesting();
+  signin_manager()->Shutdown();
+  run_loop.Run();
+}
+
+// Tests that the Identity Manager properly handles its own destruction in the
+// case where there is an active consumer request (i.e., a pending callback from
+// a Mojo call). In particular, this flow should not cause a DCHECK to fire in
+// debug mode.
+TEST_F(IdentityManagerImplTest, IdentityManagerImplShutdownWithActiveRequest) {
+  base::RunLoop run_loop;
+  SetIdentityManagerImplConnectionErrorHandler(run_loop.QuitClosure());
+
+  // Call a method on the IdentityManagerImpl that will cause it to store a
+  // pending callback. This callback will never be invoked, so just pass dummy
+  // arguments to it.
+  GetIdentityManagerImpl()->GetPrimaryAccountWhenAvailable(base::BindRepeating(
+      &IdentityManagerImplTest::OnPrimaryAccountAvailable,
+      base::Unretained(this), base::RepeatingClosure(), nullptr, nullptr));
+
+  // Ensure that the IdentityManagerImpl has received the above call before
+  // invoking SigninManagerBase::Shutdown(), as otherwise this test is
+  // pointless.
+  FlushIdentityManagerImplForTesting();
+
+  // This flow is what would cause a DCHECK to fire if IdentityManagerImpl is
+  // not properly closing its binding on shutdown.
+  signin_manager()->Shutdown();
+  run_loop.Run();
+}
+
+// Check that the primary account info is null if not signed in.
+TEST_F(IdentityManagerImplTest, GetPrimaryAccountInfoNotSignedIn) {
+  base::RunLoop run_loop;
+  GetIdentityManagerImpl()->GetPrimaryAccountInfo(base::BindRepeating(
+      &IdentityManagerImplTest::OnReceivedPrimaryAccountInfo,
+      base::Unretained(this), run_loop.QuitClosure()));
+  run_loop.Run();
+  EXPECT_FALSE(primary_account_info_);
+}
+
+// Check that the primary account info has expected values if signed in without
+// a refresh token available.
+TEST_F(IdentityManagerImplTest, GetPrimaryAccountInfoSignedInNoRefreshToken) {
+  signin_manager()->SetAuthenticatedAccountInfo(kTestGaiaId, kTestEmail);
+  base::RunLoop run_loop;
+  GetIdentityManagerImpl()->GetPrimaryAccountInfo(base::BindRepeating(
+      &IdentityManagerImplTest::OnReceivedPrimaryAccountInfo,
+      base::Unretained(this), run_loop.QuitClosure()));
+  run_loop.Run();
+  EXPECT_TRUE(primary_account_info_);
+  EXPECT_EQ(signin_manager()->GetAuthenticatedAccountId(),
+            primary_account_info_->account_id);
+  EXPECT_EQ(kTestGaiaId, primary_account_info_->gaia);
+  EXPECT_EQ(kTestEmail, primary_account_info_->email);
+  EXPECT_FALSE(primary_account_state_.has_refresh_token);
+  EXPECT_TRUE(primary_account_state_.is_primary_account);
+}
+
+// Check that the primary account info has expected values if signed in with a
+// refresh token available.
+TEST_F(IdentityManagerImplTest, GetPrimaryAccountInfoSignedInRefreshToken) {
+  signin_manager()->SetAuthenticatedAccountInfo(kTestGaiaId, kTestEmail);
+  token_service()->UpdateCredentials(
+      signin_manager()->GetAuthenticatedAccountId(), kTestRefreshToken);
+  base::RunLoop run_loop;
+  GetIdentityManagerImpl()->GetPrimaryAccountInfo(base::BindRepeating(
+      &IdentityManagerImplTest::OnReceivedPrimaryAccountInfo,
+      base::Unretained(this), run_loop.QuitClosure()));
+  run_loop.Run();
+  EXPECT_TRUE(primary_account_info_);
+  EXPECT_EQ(signin_manager()->GetAuthenticatedAccountId(),
+            primary_account_info_->account_id);
+  EXPECT_EQ(kTestGaiaId, primary_account_info_->gaia);
+  EXPECT_EQ(kTestEmail, primary_account_info_->email);
+  EXPECT_TRUE(primary_account_state_.has_refresh_token);
+  EXPECT_TRUE(primary_account_state_.is_primary_account);
+}
+
+// Check that GetPrimaryAccountWhenAvailable() returns immediately in the
+// case where the primary account is available when the call is received.
+TEST_F(IdentityManagerImplTest, GetPrimaryAccountWhenAvailableSignedIn) {
+  signin_manager()->SetAuthenticatedAccountInfo(kTestGaiaId, kTestEmail);
+  token_service()->UpdateCredentials(
+      signin_manager()->GetAuthenticatedAccountId(), kTestRefreshToken);
+
+  AccountInfo account_info;
+  AccountState account_state;
+  base::RunLoop run_loop;
+  GetIdentityManagerImpl()->GetPrimaryAccountWhenAvailable(base::BindRepeating(
+      &IdentityManagerImplTest::OnPrimaryAccountAvailable,
+      base::Unretained(this), run_loop.QuitClosure(),
+      base::Unretained(&account_info), base::Unretained(&account_state)));
+  run_loop.Run();
+
+  EXPECT_EQ(signin_manager()->GetAuthenticatedAccountId(),
+            account_info.account_id);
+  EXPECT_EQ(kTestGaiaId, account_info.gaia);
+  EXPECT_EQ(kTestEmail, account_info.email);
+  EXPECT_TRUE(account_state.has_refresh_token);
+  EXPECT_TRUE(account_state.is_primary_account);
+}
+
+// Check that GetPrimaryAccountWhenAvailable() returns the expected account
+// info in the case where the primary account is made available *after* the
+// call is received.
+TEST_F(IdentityManagerImplTest, GetPrimaryAccountWhenAvailableSignInLater) {
+  AccountInfo account_info;
+  AccountState account_state;
+
+  base::RunLoop run_loop;
+  GetIdentityManagerImpl()->GetPrimaryAccountWhenAvailable(base::BindRepeating(
+      &IdentityManagerImplTest::OnPrimaryAccountAvailable,
+      base::Unretained(this), run_loop.QuitClosure(),
+      base::Unretained(&account_info), base::Unretained(&account_state)));
+
+  // Verify that the primary account info is not currently available (this also
+  // serves to ensure that the preceding call has been received by the Identity
+  // Manager before proceeding).
+  base::RunLoop run_loop2;
+  GetIdentityManagerImpl()->GetPrimaryAccountInfo(base::BindRepeating(
+      &IdentityManagerImplTest::OnReceivedPrimaryAccountInfo,
+      base::Unretained(this), run_loop2.QuitClosure()));
+  run_loop2.Run();
+  EXPECT_FALSE(primary_account_info_);
+
+  // Make the primary account available and check that the callback is invoked
+  // as expected.
+  signin_manager()->SetAuthenticatedAccountInfo(kTestGaiaId, kTestEmail);
+  token_service()->UpdateCredentials(
+      signin_manager()->GetAuthenticatedAccountId(), kTestRefreshToken);
+  run_loop.Run();
+
+  EXPECT_EQ(signin_manager()->GetAuthenticatedAccountId(),
+            account_info.account_id);
+  EXPECT_EQ(kTestGaiaId, account_info.gaia);
+  EXPECT_EQ(kTestEmail, account_info.email);
+  EXPECT_TRUE(account_state.has_refresh_token);
+  EXPECT_TRUE(account_state.is_primary_account);
+}
+
+// Check that GetPrimaryAccountWhenAvailable() returns the expected account
+// info in the case where signin is done before the call is received but the
+// refresh token is made available only *after* the call is received.
+TEST_F(IdentityManagerImplTest,
+       GetPrimaryAccountWhenAvailableTokenAvailableLater) {
+  AccountInfo account_info;
+  AccountState account_state;
+
+  // Sign in, but don't set the refresh token yet.
+  signin_manager()->SetAuthenticatedAccountInfo(kTestGaiaId, kTestEmail);
+  base::RunLoop run_loop;
+  GetIdentityManagerImpl()->GetPrimaryAccountWhenAvailable(base::BindRepeating(
+      &IdentityManagerImplTest::OnPrimaryAccountAvailable,
+      base::Unretained(this), run_loop.QuitClosure(),
+      base::Unretained(&account_info), base::Unretained(&account_state)));
+
+  // Verify that the primary account info is present, but that the primary
+  // account is not yet considered available (this also
+  // serves to ensure that the preceding call has been received by the Identity
+  // Manager before proceeding).
+  base::RunLoop run_loop2;
+  GetIdentityManagerImpl()->GetPrimaryAccountInfo(base::BindRepeating(
+      &IdentityManagerImplTest::OnReceivedPrimaryAccountInfo,
+      base::Unretained(this), run_loop2.QuitClosure()));
+  run_loop2.Run();
+
+  EXPECT_TRUE(primary_account_info_);
+  EXPECT_EQ(signin_manager()->GetAuthenticatedAccountId(),
+            primary_account_info_->account_id);
+  EXPECT_TRUE(account_info.account_id.empty());
+
+  // Set the refresh token and check that the callback is invoked as expected
+  // (i.e., the primary account is now considered available).
+  token_service()->UpdateCredentials(
+      signin_manager()->GetAuthenticatedAccountId(), kTestRefreshToken);
+  run_loop.Run();
+
+  EXPECT_EQ(signin_manager()->GetAuthenticatedAccountId(),
+            account_info.account_id);
+  EXPECT_EQ(kTestGaiaId, account_info.gaia);
+  EXPECT_EQ(kTestEmail, account_info.email);
+  EXPECT_TRUE(account_state.has_refresh_token);
+  EXPECT_TRUE(account_state.is_primary_account);
+}
+
+// Check that GetPrimaryAccountWhenAvailable() returns the expected account info
+// in the case where the token is available before the call is received but the
+// account is made authenticated only *after* the call is received. This test is
+// relevant only on non-ChromeOS platforms, as the flow being tested here is not
+// possible on ChromeOS.
+#if !defined(OS_CHROMEOS)
+TEST_F(IdentityManagerImplTest,
+       GetPrimaryAccountWhenAvailableAuthenticationAvailableLater) {
+  AccountInfo account_info;
+  AccountState account_state;
+
+  // Set the refresh token, but don't sign in yet.
+  std::string account_id_to_use =
+      account_tracker()->SeedAccountInfo(kTestGaiaId, kTestEmail);
+  token_service()->UpdateCredentials(account_id_to_use, kTestRefreshToken);
+  base::RunLoop run_loop;
+  GetIdentityManagerImpl()->GetPrimaryAccountWhenAvailable(base::BindRepeating(
+      &IdentityManagerImplTest::OnPrimaryAccountAvailable,
+      base::Unretained(this), run_loop.QuitClosure(),
+      base::Unretained(&account_info), base::Unretained(&account_state)));
+
+  // Verify that the account is present and has a refresh token, but that the
+  // primary account is not yet considered available (this also serves to ensure
+  // that the preceding call has been received by the Identity Manager before
+  // proceeding).
+  base::RunLoop run_loop2;
+  GetIdentityManagerImpl()->GetAccountInfoFromGaiaId(
+      kTestGaiaId,
+      base::BindRepeating(
+          &IdentityManagerImplTest::OnReceivedAccountInfoFromGaiaId,
+          base::Unretained(this), run_loop2.QuitClosure()));
+  run_loop2.Run();
+
+  EXPECT_TRUE(account_info_from_gaia_id_);
+  EXPECT_EQ(account_id_to_use, account_info_from_gaia_id_->account_id);
+  EXPECT_EQ(kTestGaiaId, account_info_from_gaia_id_->gaia);
+  EXPECT_EQ(kTestEmail, account_info_from_gaia_id_->email);
+  EXPECT_TRUE(account_state_from_gaia_id_.has_refresh_token);
+  EXPECT_FALSE(account_state_from_gaia_id_.is_primary_account);
+
+  EXPECT_TRUE(account_info.account_id.empty());
+
+  // Sign the user in and check that the callback is invoked as expected (i.e.,
+  // the primary account is now considered available). Note that it is necessary
+  // to call SignIn() here to ensure that GoogleSigninSucceeded() is fired by
+  // the fake signin manager.
+  static_cast<FakeSigninManager*>(signin_manager())
+      ->SignIn(kTestGaiaId, kTestEmail, "password");
+
+  run_loop.Run();
+
+  EXPECT_EQ(signin_manager()->GetAuthenticatedAccountId(),
+            account_info.account_id);
+  EXPECT_EQ(kTestGaiaId, account_info.gaia);
+  EXPECT_EQ(kTestEmail, account_info.email);
+  EXPECT_TRUE(account_state.has_refresh_token);
+  EXPECT_TRUE(account_state.is_primary_account);
+}
+#endif
+
+// Check that GetPrimaryAccountWhenAvailable() returns the expected account
+// info to all callers in the case where the primary account is made available
+// after multiple overlapping calls have been received.
+TEST_F(IdentityManagerImplTest,
+       GetPrimaryAccountWhenAvailableOverlappingCalls) {
+  AccountInfo account_info1;
+  AccountState account_state1;
+  base::RunLoop run_loop;
+  GetIdentityManagerImpl()->GetPrimaryAccountWhenAvailable(base::BindRepeating(
+      &IdentityManagerImplTest::OnPrimaryAccountAvailable,
+      base::Unretained(this), run_loop.QuitClosure(),
+      base::Unretained(&account_info1), base::Unretained(&account_state1)));
+
+  AccountInfo account_info2;
+  AccountState account_state2;
+  base::RunLoop run_loop2;
+  GetIdentityManagerImpl()->GetPrimaryAccountWhenAvailable(base::BindRepeating(
+      &IdentityManagerImplTest::OnPrimaryAccountAvailable,
+      base::Unretained(this), run_loop2.QuitClosure(),
+      base::Unretained(&account_info2), base::Unretained(&account_state2)));
+
+  // Verify that the primary account info is not currently available (this also
+  // serves to ensure that the preceding call has been received by the Identity
+  // Manager before proceeding).
+  base::RunLoop run_loop3;
+  GetIdentityManagerImpl()->GetPrimaryAccountInfo(base::BindRepeating(
+      &IdentityManagerImplTest::OnReceivedPrimaryAccountInfo,
+      base::Unretained(this), run_loop3.QuitClosure()));
+  run_loop3.Run();
+  EXPECT_FALSE(primary_account_info_);
+
+  // Make the primary account available and check that the callbacks are invoked
+  // as expected.
+  signin_manager()->SetAuthenticatedAccountInfo(kTestGaiaId, kTestEmail);
+  token_service()->UpdateCredentials(
+      signin_manager()->GetAuthenticatedAccountId(), kTestRefreshToken);
+  run_loop.Run();
+  run_loop2.Run();
+
+  EXPECT_EQ(signin_manager()->GetAuthenticatedAccountId(),
+            account_info1.account_id);
+  EXPECT_EQ(kTestGaiaId, account_info1.gaia);
+  EXPECT_EQ(kTestEmail, account_info1.email);
+  EXPECT_TRUE(account_state1.has_refresh_token);
+  EXPECT_TRUE(account_state1.is_primary_account);
+
+  EXPECT_EQ(signin_manager()->GetAuthenticatedAccountId(),
+            account_info2.account_id);
+  EXPECT_EQ(kTestGaiaId, account_info2.gaia);
+  EXPECT_EQ(kTestEmail, account_info2.email);
+  EXPECT_TRUE(account_state2.has_refresh_token);
+  EXPECT_TRUE(account_state2.is_primary_account);
+}
+
+// Check that GetPrimaryAccountWhenAvailable() doesn't return the account as
+// available if the refresh token has an auth error.
+TEST_F(IdentityManagerImplTest,
+       GetPrimaryAccountWhenAvailableRefreshTokenHasAuthError) {
+  signin_manager()->SetAuthenticatedAccountInfo(kTestGaiaId, kTestEmail);
+  token_service()->UpdateCredentials(
+      signin_manager()->GetAuthenticatedAccountId(), kTestRefreshToken);
+  token_service()->UpdateAuthErrorForTesting(
+      signin_manager()->GetAuthenticatedAccountId(),
+      GoogleServiceAuthError(
+          GoogleServiceAuthError::State::INVALID_GAIA_CREDENTIALS));
+
+  AccountInfo account_info;
+  AccountState account_state;
+  base::RunLoop run_loop;
+  GetIdentityManagerImpl()->GetPrimaryAccountWhenAvailable(base::BindRepeating(
+      &IdentityManagerImplTest::OnPrimaryAccountAvailable,
+      base::Unretained(this), run_loop.QuitClosure(),
+      base::Unretained(&account_info), base::Unretained(&account_state)));
+
+  // Flush the Identity Manager and check that the callback didn't fire.
+  FlushIdentityManagerImplForTesting();
+  EXPECT_TRUE(account_info.account_id.empty());
+
+  // Clear the auth error, update credentials, and check that the callback
+  // fires.
+  token_service()->UpdateAuthErrorForTesting(
+      signin_manager()->GetAuthenticatedAccountId(), GoogleServiceAuthError());
+  token_service()->UpdateCredentials(
+      signin_manager()->GetAuthenticatedAccountId(), kTestRefreshToken);
+  run_loop.Run();
+
+  EXPECT_EQ(signin_manager()->GetAuthenticatedAccountId(),
+            account_info.account_id);
+  EXPECT_EQ(kTestGaiaId, account_info.gaia);
+  EXPECT_EQ(kTestEmail, account_info.email);
+  EXPECT_TRUE(account_state.has_refresh_token);
+  EXPECT_TRUE(account_state.is_primary_account);
+}
+
+// Check that the account info for a given GAIA ID is null if that GAIA ID is
+// unknown.
+TEST_F(IdentityManagerImplTest, GetAccountInfoForUnknownGaiaID) {
+  base::RunLoop run_loop;
+  GetIdentityManagerImpl()->GetAccountInfoFromGaiaId(
+      kTestGaiaId,
+      base::BindRepeating(
+          &IdentityManagerImplTest::OnReceivedAccountInfoFromGaiaId,
+          base::Unretained(this), run_loop.QuitClosure()));
+  run_loop.Run();
+  EXPECT_FALSE(account_info_from_gaia_id_);
+}
+
+// Check that the account info for a given GAIA ID has expected values if that
+// GAIA ID is known and there is no refresh token available for it.
+TEST_F(IdentityManagerImplTest, GetAccountInfoForKnownGaiaIdNoRefreshToken) {
+  std::string account_id =
+      account_tracker()->SeedAccountInfo(kTestGaiaId, kTestEmail);
+  base::RunLoop run_loop;
+  GetIdentityManagerImpl()->GetAccountInfoFromGaiaId(
+      kTestGaiaId,
+      base::BindRepeating(
+          &IdentityManagerImplTest::OnReceivedAccountInfoFromGaiaId,
+          base::Unretained(this), run_loop.QuitClosure()));
+  run_loop.Run();
+  EXPECT_TRUE(account_info_from_gaia_id_);
+  EXPECT_EQ(account_id, account_info_from_gaia_id_->account_id);
+  EXPECT_EQ(kTestGaiaId, account_info_from_gaia_id_->gaia);
+  EXPECT_EQ(kTestEmail, account_info_from_gaia_id_->email);
+  EXPECT_FALSE(account_state_from_gaia_id_.has_refresh_token);
+  EXPECT_FALSE(account_state_from_gaia_id_.is_primary_account);
+}
+
+// Check that the account info for a given GAIA ID has expected values if that
+// GAIA ID is known and has a refresh token available.
+TEST_F(IdentityManagerImplTest, GetAccountInfoForKnownGaiaIdRefreshToken) {
+  std::string account_id =
+      account_tracker()->SeedAccountInfo(kTestGaiaId, kTestEmail);
+  token_service()->UpdateCredentials(account_id, kTestRefreshToken);
+  base::RunLoop run_loop;
+  GetIdentityManagerImpl()->GetAccountInfoFromGaiaId(
+      kTestGaiaId,
+      base::BindRepeating(
+          &IdentityManagerImplTest::OnReceivedAccountInfoFromGaiaId,
+          base::Unretained(this), run_loop.QuitClosure()));
+  run_loop.Run();
+  EXPECT_TRUE(account_info_from_gaia_id_);
+  EXPECT_EQ(account_id, account_info_from_gaia_id_->account_id);
+  EXPECT_EQ(kTestGaiaId, account_info_from_gaia_id_->gaia);
+  EXPECT_EQ(kTestEmail, account_info_from_gaia_id_->email);
+  EXPECT_TRUE(account_state_from_gaia_id_.has_refresh_token);
+  EXPECT_FALSE(account_state_from_gaia_id_.is_primary_account);
+}
+
+// Check the implementation of GetAccounts() when there are no accounts.
+TEST_F(IdentityManagerImplTest, GetAccountsNoAccount) {
+  token_service()->LoadCredentials("dummy");
+
+  std::vector<mojom::AccountPtr> accounts;
+
+  // Check that an empty list is returned when there are no accounts.
+  base::RunLoop run_loop;
+  GetIdentityManagerImpl()->GetAccounts(base::BindRepeating(
+      &IdentityManagerImplTest::OnGotAccounts, base::Unretained(this),
+      run_loop.QuitClosure(), &accounts));
+  run_loop.Run();
+  EXPECT_EQ(0u, accounts.size());
+}
+
+// Check the implementation of GetAccounts() when there is a single account,
+// which is the primary account.
+TEST_F(IdentityManagerImplTest, GetAccountsPrimaryAccount) {
+  token_service()->LoadCredentials("dummy");
+  std::vector<mojom::AccountPtr> accounts;
+
+  // Add a primary account.
+  signin_manager()->SetAuthenticatedAccountInfo(kTestGaiaId, kTestEmail);
+  token_service()->UpdateCredentials(
+      signin_manager()->GetAuthenticatedAccountId(), kTestRefreshToken);
+
+  base::RunLoop run_loop;
+  GetIdentityManagerImpl()->GetAccounts(base::BindRepeating(
+      &IdentityManagerImplTest::OnGotAccounts, base::Unretained(this),
+      run_loop.QuitClosure(), &accounts));
+  run_loop.Run();
+
+  // Verify that |accounts| contains the primary account.
+  EXPECT_EQ(1u, accounts.size());
+  const mojom::AccountPtr& primary_account = accounts[0];
+  EXPECT_EQ(signin_manager()->GetAuthenticatedAccountId(),
+            primary_account->info.account_id);
+  EXPECT_EQ(kTestGaiaId, primary_account->info.gaia);
+  EXPECT_EQ(kTestEmail, primary_account->info.email);
+  EXPECT_TRUE(primary_account->state.has_refresh_token);
+  EXPECT_TRUE(primary_account->state.is_primary_account);
+}
+
+// Check the implementation of GetAccounts() when there are multiple accounts,
+// in particular that ProfileOAuth2TokenService is the source of truth for
+// whether an account is present.
+TEST_F(IdentityManagerImplTest, GetAccountsMultipleAccounts) {
+  token_service()->LoadCredentials("dummy");
+  std::vector<mojom::AccountPtr> accounts;
+
+  // Add a primary account.
+  signin_manager()->SetAuthenticatedAccountInfo(kTestGaiaId, kTestEmail);
+  token_service()->UpdateCredentials(
+      signin_manager()->GetAuthenticatedAccountId(), kTestRefreshToken);
+
+  // Add a secondary account with AccountTrackerService, but don't yet make
+  // ProfileOAuth2TokenService aware of it.
+  std::string secondary_account_id = account_tracker()->SeedAccountInfo(
+      kSecondaryTestGaiaId, kSecondaryTestEmail);
+  base::RunLoop run_loop;
+  GetIdentityManagerImpl()->GetAccounts(base::BindRepeating(
+      &IdentityManagerImplTest::OnGotAccounts, base::Unretained(this),
+      run_loop.QuitClosure(), &accounts));
+  run_loop.Run();
+
+  // Verify that |accounts| contains only the primary account at this time.
+  EXPECT_EQ(1u, accounts.size());
+  const mojom::AccountPtr& primary_account = accounts[0];
+  EXPECT_EQ(signin_manager()->GetAuthenticatedAccountId(),
+            primary_account->info.account_id);
+  EXPECT_EQ(kTestGaiaId, primary_account->info.gaia);
+  EXPECT_EQ(kTestEmail, primary_account->info.email);
+  EXPECT_TRUE(primary_account->state.has_refresh_token);
+  EXPECT_TRUE(primary_account->state.is_primary_account);
+
+  // Make PO2TS aware of the secondary account.
+  token_service()->UpdateCredentials(secondary_account_id, kTestRefreshToken);
+  base::RunLoop run_loop2;
+  GetIdentityManagerImpl()->GetAccounts(base::BindRepeating(
+      &IdentityManagerImplTest::OnGotAccounts, base::Unretained(this),
+      run_loop2.QuitClosure(), &accounts));
+  run_loop2.Run();
+
+  // Verify that |accounts| contains both accounts, with the primary account
+  // being first and having the same information as previously.
+  EXPECT_EQ(2u, accounts.size());
+  const mojom::AccountPtr& primary_account_redux = accounts[0];
+  EXPECT_EQ(signin_manager()->GetAuthenticatedAccountId(),
+            primary_account_redux->info.account_id);
+  EXPECT_EQ(kTestGaiaId, primary_account_redux->info.gaia);
+  EXPECT_EQ(kTestEmail, primary_account_redux->info.email);
+  EXPECT_TRUE(primary_account_redux->state.has_refresh_token);
+  EXPECT_TRUE(primary_account_redux->state.is_primary_account);
+
+  const mojom::AccountPtr& secondary_account = accounts[1];
+  EXPECT_EQ(secondary_account_id, secondary_account->info.account_id);
+  EXPECT_EQ(kSecondaryTestGaiaId, secondary_account->info.gaia);
+  EXPECT_EQ(kSecondaryTestEmail, secondary_account->info.email);
+  EXPECT_TRUE(secondary_account->state.has_refresh_token);
+  EXPECT_FALSE(secondary_account->state.is_primary_account);
+}
+
+// Check that the expected error is received if requesting an access token when
+// not signed in.
+TEST_F(IdentityManagerImplTest, GetAccessTokenNotSignedIn) {
+  base::RunLoop run_loop;
+  GetIdentityManagerImpl()->GetAccessToken(
+      kTestGaiaId, ScopeSet(), "dummy_consumer",
+      base::BindRepeating(&IdentityManagerImplTest::OnReceivedAccessToken,
+                          base::Unretained(this), run_loop.QuitClosure()));
+  run_loop.Run();
+  EXPECT_FALSE(access_token_);
+  EXPECT_EQ(GoogleServiceAuthError::State::USER_NOT_SIGNED_UP,
+            access_token_error_.state());
+}
+
+// Check that the expected access token is received if requesting an access
+// token when signed in.
+TEST_F(IdentityManagerImplTest, GetAccessTokenSignedIn) {
+  signin_manager()->SetAuthenticatedAccountInfo(kTestGaiaId, kTestEmail);
+  std::string account_id = signin_manager()->GetAuthenticatedAccountId();
+  token_service()->UpdateCredentials(account_id, kTestRefreshToken);
+  token_service()->set_auto_post_fetch_response_on_message_loop(true);
+  base::RunLoop run_loop;
+
+  GetIdentityManagerImpl()->GetAccessToken(
+      account_id, ScopeSet(), "dummy_consumer",
+      base::BindRepeating(&IdentityManagerImplTest::OnReceivedAccessToken,
+                          base::Unretained(this), run_loop.QuitClosure()));
+  run_loop.Run();
+  EXPECT_TRUE(access_token_);
+  EXPECT_EQ(kTestAccessToken, access_token_.value());
+  EXPECT_EQ(GoogleServiceAuthError::State::NONE, access_token_error_.state());
+}
+
+}  // namespace
+}  // namespace identity
--- a/services/identity/manifest.json	1970-01-01 03:00:00.000000000 +0300
+++ b/services/identity/manifest.json	2019-05-17 18:53:37.860000000 +0300
@@ -0,0 +1,11 @@
+{
+  "name": "identity",
+  "display_name": "Identity Service",
+  "interface_provider_specs": {
+    "service_manager:connector": {
+      "provides": {
+        "identity_manager" : [ "identity.mojom.IdentityManager" ]
+      }
+    }
+  }
+}
--- a/services/identity/public/mojom/identity_manager.mojom	1970-01-01 03:00:00.000000000 +0300
+++ b/services/identity/public/mojom/identity_manager.mojom	2019-05-17 18:53:37.868000000 +0300
@@ -0,0 +1,55 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+module identity.mojom;
+
+import "mojo/public/mojom/base/time.mojom";
+import "services/identity/public/mojom/account.mojom";
+import "services/identity/public/mojom/account_info.mojom";
+import "services/identity/public/mojom/account_state.mojom";
+import "services/identity/public/mojom/google_service_auth_error.mojom";
+import "services/identity/public/mojom/scope_set.mojom";
+
+// Gives access to information about the user's Google accounts.
+interface IdentityManager {
+  // Returns the AccountInfo for the Google account that serves as the user's
+  // primary account, or null if the user has no primary account (e.g., if they
+  // are not signed in). |account_state| gives the current state of the account
+  // (relevant only if |account_info| is non-null).
+  GetPrimaryAccountInfo() => (AccountInfo? account_info,
+                              AccountState account_state);
+
+  // Returns the AccountInfo for the Google account that serves as the user's
+  // primary account once this account is available (i.e., the user is signed
+  // in, a refresh token is available, and the refresh token is in a non-error
+  // state). |account_state| gives the current state of the account.
+  // Overlapping requests are permitted; all pending requests will be called
+  // back when the primary account is available.
+  GetPrimaryAccountWhenAvailable() => (AccountInfo account_info,
+                                       AccountState account_state);
+
+  // Returns the AccountInfo for the user's Google account corresponding to
+  // |gaia_id|, or null if the user has such corresponding account.
+  // |account_state| gives the current state of the account (relevant only if
+  // |account_info| is non-null).
+  GetAccountInfoFromGaiaId(string gaia_id) => (AccountInfo? account_info,
+                                               AccountState account_state);
+
+  // Returns a list of all known accounts. The primary account (if any exists)
+  // will be first, after which the order is undefined.
+  GetAccounts() => (array<Account> accounts);
+
+  // Returns an access token with the requested scopes for the given
+  // |account_id|, or null if it is not possible to obtain such a token (e.g.,
+  // because the user is not signed in with that account). |expiration_time|
+  // gives the time until the returned token expires.  In the case of failure,
+  // |error| will give information detailing the reason for the failure, and
+  // |expiration_time| is undefined. |consumer_id| is an arbitrary string used
+  // to identity the consumer (e.g., in about:://signin-internals).
+  // NOTE: |account_id| corresponds to that used by OAuth2TokenService.
+  GetAccessToken(string account_id, ScopeSet scopes, string consumer_id) =>
+     (string? token,
+      mojo_base.mojom.Time expiration_time,
+      GoogleServiceAuthError error);
+};
--- a/services/media_session/manifest.json	1970-01-01 03:00:00.000000000 +0300
+++ b/services/media_session/manifest.json	2019-05-17 18:53:37.868000000 +0300
@@ -0,0 +1,19 @@
+{
+  "name": "media_session",
+  "display_name": "Media Session Service",
+  "options" : {
+    "instance_sharing" : "shared_instance_across_users"
+  },
+  "interface_provider_specs": {
+    "service_manager:connector": {
+      "provides": {
+        "app": [
+          "media_session.mojom.AudioFocusManager",
+          "media_session.mojom.AudioFocusManagerDebug",
+          "media_session.mojom.MediaControllerManager"
+        ],
+        "tests": [ "*" ]
+      }
+    }
+  }
+}
--- a/services/metrics/manifest.json	1970-01-01 03:00:00.000000000 +0300
+++ b/services/metrics/manifest.json	2019-05-17 18:53:37.872000000 +0300
@@ -0,0 +1,16 @@
+{
+  "name": "metrics",
+  "display_name": "Metrics Service",
+  "options" : {
+    "instance_sharing" : "shared_instance_across_users"
+  },
+  "interface_provider_specs": {
+    "service_manager:connector": {
+      "provides": {
+        "url_keyed_metrics": [
+          "ukm.mojom.UkmRecorderInterface"
+        ]
+      }
+    }
+  }
+}
--- a/services/network/manifest.json	1970-01-01 03:00:00.000000000 +0300
+++ b/services/network/manifest.json	2019-05-17 18:53:37.888000000 +0300
@@ -0,0 +1,23 @@
+{
+  "name": "network",
+  "display_name": "Network Service",
+  "sandbox_type": "network",
+  "options" : {
+    "instance_sharing" : "shared_instance_across_users"
+  },
+  "interface_provider_specs": {
+    "service_manager:connector": {
+      "provides": {
+        "network_service": [
+          "network.mojom.NetworkService"
+        ],
+        "test": [
+          "network.mojom.NetworkServiceTest"
+        ],
+        "url_loader": [
+          "network.mojom.URLLoaderFactory"
+        ]
+      }
+    }
+  }
+}
--- a/services/preferences/local_state_manifest.json	1970-01-01 03:00:00.000000000 +0300
+++ b/services/preferences/local_state_manifest.json	2019-05-17 18:53:37.940000000 +0300
@@ -0,0 +1,15 @@
+{
+  "name": "local_state",
+  "display_name": "Local state preferences",
+  "interface_provider_specs": {
+    "service_manager:connector": {
+      "provides": {
+        "pref_client": [
+          "prefs.mojom.PrefStoreConnector"
+        ]
+      },
+      "requires": {
+      }
+    }
+  }
+}
--- a/services/preferences/manifest.json	1970-01-01 03:00:00.000000000 +0300
+++ b/services/preferences/manifest.json	2019-05-17 18:53:37.940000000 +0300
@@ -0,0 +1,15 @@
+{
+  "name": "preferences",
+  "display_name": "Preferences",
+  "interface_provider_specs": {
+    "service_manager:connector": {
+      "provides": {
+        "pref_client": [
+          "prefs.mojom.PrefStoreConnector"
+        ]
+      },
+      "requires": {
+      }
+    }
+  }
+}
--- a/services/proxy_resolver/manifest.json	1970-01-01 03:00:00.000000000 +0300
+++ b/services/proxy_resolver/manifest.json	2019-05-17 18:53:37.952000000 +0300
@@ -0,0 +1,14 @@
+{
+  "name": "proxy_resolver",
+  "display_name": "Proxy resolver",
+  "options" : {
+    "instance_sharing" : "shared_instance_across_users"
+  },
+  "interface_provider_specs": {
+    "service_manager:connector": {
+      "provides": {
+        "factory": [ "proxy_resolver.mojom.ProxyResolverFactory" ]
+       }
+     }
+  }
+}
\ В конце файла нет новой строки
diff -BbuN a/services/resource_coordinator/coordination_unit/coordination_unit_base.cc b/services/resource_coordinator/coordination_unit/coordination_unit_base.cc
--- a/services/resource_coordinator/coordination_unit/coordination_unit_base.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/services/resource_coordinator/coordination_unit/coordination_unit_base.cc	2019-05-17 18:53:37.956000000 +0300
@@ -0,0 +1,87 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "services/resource_coordinator/coordination_unit/coordination_unit_base.h"
+
+#include "services/resource_coordinator/coordination_unit/coordination_unit_graph.h"
+#include "services/resource_coordinator/observers/coordination_unit_graph_observer.h"
+#include "services/resource_coordinator/public/cpp/coordination_unit_id.h"
+
+namespace resource_coordinator {
+
+CoordinationUnitBase::CoordinationUnitBase(const CoordinationUnitID& id,
+                                           CoordinationUnitGraph* graph)
+    : graph_(graph), id_(id.type, id.id) {}
+
+CoordinationUnitBase::~CoordinationUnitBase() = default;
+
+void CoordinationUnitBase::Destruct() {
+  graph_->DestroyCoordinationUnit(this);
+}
+
+void CoordinationUnitBase::BeforeDestroyed() {
+  for (auto& observer : observers_)
+    observer.OnBeforeCoordinationUnitDestroyed(this);
+}
+
+void CoordinationUnitBase::AddObserver(
+    CoordinationUnitGraphObserver* observer) {
+  observers_.AddObserver(observer);
+}
+
+void CoordinationUnitBase::RemoveObserver(
+    CoordinationUnitGraphObserver* observer) {
+  observers_.RemoveObserver(observer);
+}
+
+bool CoordinationUnitBase::GetProperty(const mojom::PropertyType property_type,
+                                       int64_t* result) const {
+  auto value_it = properties_.find(property_type);
+  if (value_it != properties_.end()) {
+    *result = value_it->second;
+    return true;
+  }
+  return false;
+}
+
+int64_t CoordinationUnitBase::GetPropertyOrDefault(
+    const mojom::PropertyType property_type, int64_t default_value) const {
+  int64_t value = 0;
+  if (GetProperty(property_type, &value))
+    return value;
+  return default_value;
+}
+
+void CoordinationUnitBase::OnEventReceived(mojom::Event event) {
+  for (auto& observer : observers())
+    observer.OnEventReceived(this, event);
+}
+
+void CoordinationUnitBase::OnPropertyChanged(mojom::PropertyType property_type,
+                                             int64_t value) {
+  for (auto& observer : observers())
+    observer.OnPropertyChanged(this, property_type, value);
+}
+
+void CoordinationUnitBase::SendEvent(mojom::Event event) {
+  OnEventReceived(event);
+}
+
+void CoordinationUnitBase::SetProperty(mojom::PropertyType property_type,
+                                       int64_t value) {
+  // The |CoordinationUnitGraphObserver| API specification dictates that
+  // the property is guarranteed to be set on the |CoordinationUnitBase|
+  // and propagated to the appropriate associated |CoordianationUnitBase|
+  // before |OnPropertyChanged| is invoked on all of the registered observers.
+  properties_[property_type] = value;
+  OnPropertyChanged(property_type, value);
+}
+
+// static
+CoordinationUnitBase* CoordinationUnitBase::PassOwnershipToGraph(
+    std::unique_ptr<CoordinationUnitBase> new_cu) {
+  return new_cu->graph()->AddNewCoordinationUnit(std::move(new_cu));
+}
+
+}  // namespace resource_coordinator
diff -BbuN a/services/resource_coordinator/coordination_unit/coordination_unit_base.h b/services/resource_coordinator/coordination_unit/coordination_unit_base.h
--- a/services/resource_coordinator/coordination_unit/coordination_unit_base.h	1970-01-01 03:00:00.000000000 +0300
+++ b/services/resource_coordinator/coordination_unit/coordination_unit_base.h	2019-05-17 18:53:37.956000000 +0300
@@ -0,0 +1,156 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef SERVICES_RESOURCE_COORDINATOR_COORDINATION_UNIT_COORDINATION_UNIT_BASE_H_
+#define SERVICES_RESOURCE_COORDINATOR_COORDINATION_UNIT_COORDINATION_UNIT_BASE_H_
+
+#include <memory>
+
+#include "base/callback.h"
+#include "base/macros.h"
+#include "base/observer_list.h"
+#include "mojo/public/cpp/bindings/binding_set.h"
+#include "mojo/public/cpp/bindings/interface_request.h"
+#include "mojo/public/cpp/bindings/strong_binding.h"
+#include "services/resource_coordinator/coordination_unit/coordination_unit_graph.h"
+#include "services/resource_coordinator/observers/coordination_unit_graph_observer.h"
+#include "services/resource_coordinator/public/cpp/coordination_unit_types.h"
+#include "services/resource_coordinator/public/mojom/coordination_unit.mojom.h"
+#include "services/resource_coordinator/public/mojom/coordination_unit_provider.mojom.h"
+#include "services/service_manager/public/cpp/service_keepalive.h"
+
+namespace resource_coordinator {
+
+class CoordinationUnitGraph;
+
+// CoordinationUnitBase implements shared functionality among different types of
+// coordination units. A specific type of coordination unit will derive from
+// this class and can override shared funtionality when needed.
+class CoordinationUnitBase {
+ public:
+  CoordinationUnitBase(const CoordinationUnitID& id,
+                       CoordinationUnitGraph* graph);
+  virtual ~CoordinationUnitBase();
+
+  void Destruct();
+  void BeforeDestroyed();
+  void AddObserver(CoordinationUnitGraphObserver* observer);
+  void RemoveObserver(CoordinationUnitGraphObserver* observer);
+  bool GetProperty(const mojom::PropertyType property_type,
+                   int64_t* result) const;
+  int64_t GetPropertyOrDefault(const mojom::PropertyType property_type,
+                               int64_t default_value) const;
+
+  const CoordinationUnitID& id() const { return id_; }
+  CoordinationUnitGraph* graph() const { return graph_; }
+
+  const base::ObserverList<CoordinationUnitGraphObserver>::Unchecked&
+  observers() const {
+    return observers_;
+  }
+
+  void SetPropertyForTesting(int64_t value) {
+    SetProperty(mojom::PropertyType::kTest, value);
+  }
+
+  const std::map<mojom::PropertyType, int64_t>& properties_for_testing() const {
+    return properties_;
+  }
+
+ protected:
+  virtual void OnEventReceived(mojom::Event event);
+  virtual void OnPropertyChanged(mojom::PropertyType property_type,
+                                 int64_t value);
+
+  void SendEvent(mojom::Event event);
+  void SetProperty(mojom::PropertyType property_type, int64_t value);
+
+  // Passes the ownership of the newly created |new_cu| to its graph.
+  static CoordinationUnitBase* PassOwnershipToGraph(
+      std::unique_ptr<CoordinationUnitBase> new_cu);
+
+  CoordinationUnitGraph* const graph_;
+  const CoordinationUnitID id_;
+
+ private:
+  base::ObserverList<CoordinationUnitGraphObserver>::Unchecked observers_;
+  std::map<mojom::PropertyType, int64_t> properties_;
+
+  DISALLOW_COPY_AND_ASSIGN(CoordinationUnitBase);
+};
+
+template <class CoordinationUnitClass,
+          class MojoInterfaceClass,
+          class MojoRequestClass>
+class CoordinationUnitInterface : public CoordinationUnitBase,
+                                  public MojoInterfaceClass {
+ public:
+  static CoordinationUnitClass* Create(
+      const CoordinationUnitID& id,
+      CoordinationUnitGraph* graph,
+      std::unique_ptr<service_manager::ServiceKeepaliveRef> keepalive_ref) {
+    std::unique_ptr<CoordinationUnitClass> new_cu =
+        std::make_unique<CoordinationUnitClass>(id, graph,
+                                                std::move(keepalive_ref));
+    return static_cast<CoordinationUnitClass*>(
+        PassOwnershipToGraph(std::move(new_cu)));
+  }
+
+  static const CoordinationUnitClass* FromCoordinationUnitBase(
+      const CoordinationUnitBase* cu) {
+    DCHECK(cu->id().type == CoordinationUnitClass::Type());
+    return static_cast<const CoordinationUnitClass*>(cu);
+  }
+
+  static CoordinationUnitClass* FromCoordinationUnitBase(
+      CoordinationUnitBase* cu) {
+    DCHECK(cu->id().type == CoordinationUnitClass::Type());
+    return static_cast<CoordinationUnitClass*>(cu);
+  }
+
+  CoordinationUnitInterface(
+      const CoordinationUnitID& id,
+      CoordinationUnitGraph* graph,
+
+      std::unique_ptr<service_manager::ServiceKeepaliveRef> keepalive_ref)
+      : CoordinationUnitBase(id, graph), binding_(this) {
+    keepalive_ref_ = std::move(keepalive_ref);
+  }
+
+  ~CoordinationUnitInterface() override = default;
+
+  void Bind(MojoRequestClass request) { binding_.Bind(std::move(request)); }
+
+  void GetID(typename MojoInterfaceClass::GetIDCallback callback) override {
+    std::move(callback).Run(id_);
+  }
+  void AddBinding(MojoRequestClass request) override {
+    bindings_.AddBinding(this, std::move(request));
+  }
+
+  mojo::Binding<MojoInterfaceClass>& binding() { return binding_; }
+
+  static CoordinationUnitClass* GetCoordinationUnitByID(
+      CoordinationUnitGraph* graph,
+      const CoordinationUnitID cu_id) {
+    DCHECK(cu_id.type == CoordinationUnitClass::Type());
+    auto* cu = graph->GetCoordinationUnitByID(cu_id);
+    if (!cu)
+      return nullptr;
+
+    CHECK_EQ(cu->id().type, CoordinationUnitClass::Type());
+    return static_cast<CoordinationUnitClass*>(cu);
+  }
+
+ private:
+  mojo::BindingSet<MojoInterfaceClass> bindings_;
+  mojo::Binding<MojoInterfaceClass> binding_;
+  std::unique_ptr<service_manager::ServiceKeepaliveRef> keepalive_ref_;
+
+  DISALLOW_COPY_AND_ASSIGN(CoordinationUnitInterface);
+};
+
+}  // namespace resource_coordinator
+
+#endif  // SERVICES_RESOURCE_COORDINATOR_COORDINATION_UNIT_COORDINATION_UNIT_BASE_H_
diff -BbuN a/services/resource_coordinator/coordination_unit/coordination_unit_base_unittest.cc b/services/resource_coordinator/coordination_unit/coordination_unit_base_unittest.cc
--- a/services/resource_coordinator/coordination_unit/coordination_unit_base_unittest.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/services/resource_coordinator/coordination_unit/coordination_unit_base_unittest.cc	2019-05-17 18:53:37.956000000 +0300
@@ -0,0 +1,132 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "services/resource_coordinator/coordination_unit/coordination_unit_base.h"
+#include "services/resource_coordinator/coordination_unit/coordination_unit_provider_impl.h"
+#include "services/resource_coordinator/coordination_unit/coordination_unit_test_harness.h"
+#include "services/resource_coordinator/coordination_unit/mock_coordination_unit_graphs.h"
+#include "services/resource_coordinator/coordination_unit/page_coordination_unit_impl.h"
+#include "services/resource_coordinator/coordination_unit/process_coordination_unit_impl.h"
+#include "services/resource_coordinator/public/mojom/coordination_unit.mojom.h"
+#include "testing/gtest/include/gtest/gtest.h"
+
+namespace resource_coordinator {
+
+namespace {
+
+class CoordinationUnitBaseTest : public CoordinationUnitTestHarness {};
+
+using CoordinationUnitBaseDeathTest = CoordinationUnitBaseTest;
+
+}  // namespace
+
+TEST_F(CoordinationUnitBaseTest, GetSetProperty) {
+  auto coordination_unit = CreateCoordinationUnit<PageCoordinationUnitImpl>();
+
+  // An empty value should be returned if property is not found
+  int64_t test_value;
+  EXPECT_FALSE(
+      coordination_unit->GetProperty(mojom::PropertyType::kTest, &test_value));
+
+  // Perform a valid storage property set
+  coordination_unit->SetPropertyForTesting(41);
+  EXPECT_EQ(1u, coordination_unit->properties_for_testing().size());
+  EXPECT_TRUE(
+      coordination_unit->GetProperty(mojom::PropertyType::kTest, &test_value));
+  EXPECT_EQ(41, test_value);
+}
+
+TEST_F(CoordinationUnitBaseTest,
+       GetAssociatedCoordinationUnitsForSinglePageInSingleProcess) {
+  MockSinglePageInSingleProcessCoordinationUnitGraph cu_graph(
+      coordination_unit_graph());
+
+  auto pages_associated_with_process =
+      cu_graph.process->GetAssociatedPageCoordinationUnits();
+  EXPECT_EQ(1u, pages_associated_with_process.size());
+  EXPECT_EQ(1u, pages_associated_with_process.count(cu_graph.page.get()));
+
+  auto processes_associated_with_page =
+      cu_graph.page->GetAssociatedProcessCoordinationUnits();
+  EXPECT_EQ(1u, processes_associated_with_page.size());
+  EXPECT_EQ(1u, processes_associated_with_page.count(cu_graph.process.get()));
+}
+
+TEST_F(CoordinationUnitBaseTest,
+       GetAssociatedCoordinationUnitsForMultiplePagesInSingleProcess) {
+  MockMultiplePagesInSingleProcessCoordinationUnitGraph cu_graph(
+      coordination_unit_graph());
+
+  auto pages_associated_with_process =
+      cu_graph.process->GetAssociatedPageCoordinationUnits();
+  EXPECT_EQ(2u, pages_associated_with_process.size());
+  EXPECT_EQ(1u, pages_associated_with_process.count(cu_graph.page.get()));
+  EXPECT_EQ(1u, pages_associated_with_process.count(cu_graph.other_page.get()));
+
+  auto processes_associated_with_page =
+      cu_graph.page->GetAssociatedProcessCoordinationUnits();
+  EXPECT_EQ(1u, processes_associated_with_page.size());
+  EXPECT_EQ(1u, processes_associated_with_page.count(cu_graph.process.get()));
+
+  auto processes_associated_with_other_page =
+      cu_graph.other_page->GetAssociatedProcessCoordinationUnits();
+  EXPECT_EQ(1u, processes_associated_with_other_page.size());
+  EXPECT_EQ(1u, processes_associated_with_page.count(cu_graph.process.get()));
+}
+
+TEST_F(CoordinationUnitBaseTest,
+       GetAssociatedCoordinationUnitsForSinglePageWithMultipleProcesses) {
+  MockSinglePageWithMultipleProcessesCoordinationUnitGraph cu_graph(
+      coordination_unit_graph());
+
+  auto pages_associated_with_process =
+      cu_graph.process->GetAssociatedPageCoordinationUnits();
+  EXPECT_EQ(1u, pages_associated_with_process.size());
+  EXPECT_EQ(1u, pages_associated_with_process.count(cu_graph.page.get()));
+
+  auto pages_associated_with_other_process =
+      cu_graph.other_process->GetAssociatedPageCoordinationUnits();
+  EXPECT_EQ(1u, pages_associated_with_other_process.size());
+  EXPECT_EQ(1u, pages_associated_with_other_process.count(cu_graph.page.get()));
+
+  auto processes_associated_with_page =
+      cu_graph.page->GetAssociatedProcessCoordinationUnits();
+  EXPECT_EQ(2u, processes_associated_with_page.size());
+  EXPECT_EQ(1u, processes_associated_with_page.count(cu_graph.process.get()));
+  EXPECT_EQ(1u,
+            processes_associated_with_page.count(cu_graph.other_process.get()));
+}
+
+TEST_F(CoordinationUnitBaseTest,
+       GetAssociatedCoordinationUnitsForMultiplePagesWithMultipleProcesses) {
+  MockMultiplePagesWithMultipleProcessesCoordinationUnitGraph cu_graph(
+      coordination_unit_graph());
+
+  auto pages_associated_with_process =
+      cu_graph.process->GetAssociatedPageCoordinationUnits();
+  EXPECT_EQ(2u, pages_associated_with_process.size());
+  EXPECT_EQ(1u, pages_associated_with_process.count(cu_graph.page.get()));
+  EXPECT_EQ(1u, pages_associated_with_process.count(cu_graph.other_page.get()));
+
+  auto pages_associated_with_other_process =
+      cu_graph.other_process->GetAssociatedPageCoordinationUnits();
+  EXPECT_EQ(1u, pages_associated_with_other_process.size());
+  EXPECT_EQ(
+      1u, pages_associated_with_other_process.count(cu_graph.other_page.get()));
+
+  auto processes_associated_with_page =
+      cu_graph.page->GetAssociatedProcessCoordinationUnits();
+  EXPECT_EQ(1u, processes_associated_with_page.size());
+  EXPECT_EQ(1u, processes_associated_with_page.count(cu_graph.process.get()));
+
+  auto processes_associated_with_other_page =
+      cu_graph.other_page->GetAssociatedProcessCoordinationUnits();
+  EXPECT_EQ(2u, processes_associated_with_other_page.size());
+  EXPECT_EQ(1u,
+            processes_associated_with_other_page.count(cu_graph.process.get()));
+  EXPECT_EQ(1u, processes_associated_with_other_page.count(
+                    cu_graph.other_process.get()));
+}
+
+}  // namespace resource_coordinator
diff -BbuN a/services/resource_coordinator/coordination_unit/coordination_unit_graph.cc b/services/resource_coordinator/coordination_unit/coordination_unit_graph.cc
--- a/services/resource_coordinator/coordination_unit/coordination_unit_graph.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/services/resource_coordinator/coordination_unit/coordination_unit_graph.cc	2019-05-17 18:53:37.956000000 +0300
@@ -0,0 +1,190 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "services/resource_coordinator/coordination_unit/coordination_unit_graph.h"
+
+#include <utility>
+
+#include "base/bind.h"
+#include "base/bind_helpers.h"
+#include "base/macros.h"
+#include "services/resource_coordinator/coordination_unit/coordination_unit_base.h"
+#include "services/resource_coordinator/coordination_unit/coordination_unit_provider_impl.h"
+#include "services/resource_coordinator/coordination_unit/frame_coordination_unit_impl.h"
+#include "services/resource_coordinator/coordination_unit/page_coordination_unit_impl.h"
+#include "services/resource_coordinator/coordination_unit/process_coordination_unit_impl.h"
+#include "services/resource_coordinator/coordination_unit/system_coordination_unit_impl.h"
+#include "services/resource_coordinator/observers/coordination_unit_graph_observer.h"
+#include "services/resource_coordinator/public/cpp/coordination_unit_types.h"
+#include "services/service_manager/public/cpp/bind_source_info.h"
+#include "services/service_manager/public/cpp/binder_registry.h"
+
+namespace ukm {
+class UkmEntryBuilder;
+}  // namespace ukm
+
+namespace resource_coordinator {
+
+CoordinationUnitGraph::CoordinationUnitGraph()
+    : system_coordination_unit_id_(CoordinationUnitType::kSystem,
+                                   CoordinationUnitID::RANDOM_ID) {}
+
+CoordinationUnitGraph::~CoordinationUnitGraph() {
+  // Because the graph has ownership of the CUs, and because the process CUs
+  // unregister on destruction, there is reentrancy to this class on
+  // destruction. The order of operations here is optimized to minimize the work
+  // done on destruction, as well as to make sure the cleanup is independent of
+  // the declaration order of member variables.
+
+  // Kill all the observers first.
+  observers_.clear();
+  // Then clear up the CUs to ensure this happens before the PID map is
+  // destructed.
+  coordination_units_.clear();
+
+  DCHECK_EQ(0u, processes_by_pid_.size());
+}
+
+void CoordinationUnitGraph::OnStart(
+    service_manager::BinderRegistryWithArgs<
+        const service_manager::BindSourceInfo&>* registry,
+    service_manager::ServiceKeepalive* keepalive) {
+  // Create the singleton CoordinationUnitProvider.
+  provider_ = std::make_unique<CoordinationUnitProviderImpl>(keepalive, this);
+  registry->AddInterface(base::BindRepeating(
+      &CoordinationUnitProviderImpl::Bind, base::Unretained(provider_.get())));
+}
+
+void CoordinationUnitGraph::RegisterObserver(
+    std::unique_ptr<CoordinationUnitGraphObserver> observer) {
+  observer->set_coordination_unit_graph(this);
+  observers_.push_back(std::move(observer));
+}
+
+void CoordinationUnitGraph::OnCoordinationUnitCreated(
+    CoordinationUnitBase* coordination_unit) {
+  for (auto& observer : observers_) {
+    if (observer->ShouldObserve(coordination_unit)) {
+      coordination_unit->AddObserver(observer.get());
+      observer->OnCoordinationUnitCreated(coordination_unit);
+    }
+  }
+}
+
+void CoordinationUnitGraph::OnBeforeCoordinationUnitDestroyed(
+    CoordinationUnitBase* coordination_unit) {
+  coordination_unit->BeforeDestroyed();
+}
+
+FrameCoordinationUnitImpl* CoordinationUnitGraph::CreateFrameCoordinationUnit(
+    const CoordinationUnitID& id,
+    std::unique_ptr<service_manager::ServiceKeepaliveRef> service_ref) {
+  return FrameCoordinationUnitImpl::Create(id, this, std::move(service_ref));
+}
+
+PageCoordinationUnitImpl* CoordinationUnitGraph::CreatePageCoordinationUnit(
+    const CoordinationUnitID& id,
+    std::unique_ptr<service_manager::ServiceKeepaliveRef> service_ref) {
+  return PageCoordinationUnitImpl::Create(id, this, std::move(service_ref));
+}
+
+ProcessCoordinationUnitImpl*
+CoordinationUnitGraph::CreateProcessCoordinationUnit(
+    const CoordinationUnitID& id,
+    std::unique_ptr<service_manager::ServiceKeepaliveRef> service_ref) {
+  return ProcessCoordinationUnitImpl::Create(id, this, std::move(service_ref));
+}
+
+SystemCoordinationUnitImpl*
+CoordinationUnitGraph::FindOrCreateSystemCoordinationUnit(
+    std::unique_ptr<service_manager::ServiceKeepaliveRef> service_ref) {
+  CoordinationUnitBase* system_cu =
+      GetCoordinationUnitByID(system_coordination_unit_id_);
+  if (system_cu)
+    return SystemCoordinationUnitImpl::FromCoordinationUnitBase(system_cu);
+
+  // Create the singleton SystemCU instance. Ownership is taken by the graph.
+  return SystemCoordinationUnitImpl::Create(system_coordination_unit_id_, this,
+                                            std::move(service_ref));
+}
+
+CoordinationUnitBase* CoordinationUnitGraph::GetCoordinationUnitByID(
+    const CoordinationUnitID cu_id) {
+  const auto& it = coordination_units_.find(cu_id);
+  if (it == coordination_units_.end())
+    return nullptr;
+  return it->second.get();
+}
+
+ProcessCoordinationUnitImpl*
+CoordinationUnitGraph::GetProcessCoordinationUnitByPid(base::ProcessId pid) {
+  auto it = processes_by_pid_.find(pid);
+  if (it == processes_by_pid_.end())
+    return nullptr;
+
+  return ProcessCoordinationUnitImpl::FromCoordinationUnitBase(it->second);
+}
+
+std::vector<ProcessCoordinationUnitImpl*>
+CoordinationUnitGraph::GetAllProcessCoordinationUnits() {
+  return GetAllCoordinationUnitsOfType<ProcessCoordinationUnitImpl>();
+}
+
+std::vector<FrameCoordinationUnitImpl*>
+CoordinationUnitGraph::GetAllFrameCoordinationUnits() {
+  return GetAllCoordinationUnitsOfType<FrameCoordinationUnitImpl>();
+}
+
+std::vector<PageCoordinationUnitImpl*>
+CoordinationUnitGraph::GetAllPageCoordinationUnits() {
+  return GetAllCoordinationUnitsOfType<PageCoordinationUnitImpl>();
+}
+
+CoordinationUnitBase* CoordinationUnitGraph::AddNewCoordinationUnit(
+    std::unique_ptr<CoordinationUnitBase> new_cu) {
+  auto it = coordination_units_.emplace(new_cu->id(), std::move(new_cu));
+  DCHECK(it.second);  // Inserted successfully
+
+  CoordinationUnitBase* added_cu = it.first->second.get();
+  OnCoordinationUnitCreated(added_cu);
+
+  return added_cu;
+}
+
+void CoordinationUnitGraph::DestroyCoordinationUnit(CoordinationUnitBase* cu) {
+  OnBeforeCoordinationUnitDestroyed(cu);
+
+  size_t erased = coordination_units_.erase(cu->id());
+  DCHECK_EQ(1u, erased);
+}
+
+void CoordinationUnitGraph::BeforeProcessPidChange(
+    ProcessCoordinationUnitImpl* process,
+    base::ProcessId new_pid) {
+  // On Windows, PIDs are agressively reused, and because not all process
+  // creation/death notifications are synchronized, it's possible for more than
+  // one CU to have the same PID. To handle this, the second and subsequent
+  // registration override earlier registrations, while unregistration will only
+  // unregister the current holder of the PID.
+  if (process->process_id() != base::kNullProcessId) {
+    auto it = processes_by_pid_.find(process->process_id());
+    if (it != processes_by_pid_.end() && it->second == process)
+      processes_by_pid_.erase(it);
+  }
+  if (new_pid != base::kNullProcessId)
+    processes_by_pid_[new_pid] = process;
+}
+
+template <typename CUType>
+std::vector<CUType*> CoordinationUnitGraph::GetAllCoordinationUnitsOfType() {
+  const auto type = CUType::Type();
+  std::vector<CUType*> ret;
+  for (const auto& el : coordination_units_) {
+    if (el.first.type == type)
+      ret.push_back(CUType::FromCoordinationUnitBase(el.second.get()));
+  }
+  return ret;
+}
+
+}  // namespace resource_coordinator
diff -BbuN a/services/resource_coordinator/coordination_unit/coordination_unit_graph.h b/services/resource_coordinator/coordination_unit/coordination_unit_graph.h
--- a/services/resource_coordinator/coordination_unit/coordination_unit_graph.h	1970-01-01 03:00:00.000000000 +0300
+++ b/services/resource_coordinator/coordination_unit/coordination_unit_graph.h	2019-05-17 18:53:37.956000000 +0300
@@ -0,0 +1,121 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef SERVICES_RESOURCE_COORDINATOR_COORDINATION_UNIT_COORDINATION_UNIT_GRAPH_H_
+#define SERVICES_RESOURCE_COORDINATOR_COORDINATION_UNIT_COORDINATION_UNIT_GRAPH_H_
+
+#include <stdint.h>
+
+#include <memory>
+#include <unordered_map>
+#include <vector>
+
+#include "base/macros.h"
+#include "base/process/process_handle.h"
+#include "services/metrics/public/cpp/mojo_ukm_recorder.h"
+#include "services/metrics/public/cpp/ukm_recorder.h"
+#include "services/resource_coordinator/public/cpp/coordination_unit_id.h"
+#include "services/resource_coordinator/public/cpp/coordination_unit_types.h"
+#include "services/service_manager/public/cpp/service_keepalive.h"
+
+namespace service_manager {
+template <typename... BinderArgs>
+class BinderRegistryWithArgs;
+struct BindSourceInfo;
+}  // namespace service_manager
+
+namespace resource_coordinator {
+
+class CoordinationUnitBase;
+class CoordinationUnitGraphObserver;
+class CoordinationUnitProviderImpl;
+class FrameCoordinationUnitImpl;
+class PageCoordinationUnitImpl;
+class ProcessCoordinationUnitImpl;
+class SystemCoordinationUnitImpl;
+
+// The CoordinationUnitGraph represents a graph of the coordination units
+// representing a single system. It vends out new instances of coordination
+// units and indexes them by ID. It also fires the creation and pre-destruction
+// notifications for all coordination units.
+class CoordinationUnitGraph {
+ public:
+  CoordinationUnitGraph();
+  ~CoordinationUnitGraph();
+
+  void set_ukm_recorder(ukm::UkmRecorder* ukm_recorder) {
+    ukm_recorder_ = ukm_recorder;
+  }
+  ukm::UkmRecorder* ukm_recorder() const { return ukm_recorder_; }
+
+  void OnStart(service_manager::BinderRegistryWithArgs<
+                   const service_manager::BindSourceInfo&>* registry,
+               service_manager::ServiceKeepalive* keepalive);
+  void RegisterObserver(
+      std::unique_ptr<CoordinationUnitGraphObserver> observer);
+  void OnCoordinationUnitCreated(CoordinationUnitBase* coordination_unit);
+  void OnBeforeCoordinationUnitDestroyed(
+      CoordinationUnitBase* coordination_unit);
+
+  FrameCoordinationUnitImpl* CreateFrameCoordinationUnit(
+      const CoordinationUnitID& id,
+      std::unique_ptr<service_manager::ServiceKeepaliveRef> service_ref);
+  PageCoordinationUnitImpl* CreatePageCoordinationUnit(
+      const CoordinationUnitID& id,
+      std::unique_ptr<service_manager::ServiceKeepaliveRef> service_ref);
+  ProcessCoordinationUnitImpl* CreateProcessCoordinationUnit(
+      const CoordinationUnitID& id,
+      std::unique_ptr<service_manager::ServiceKeepaliveRef> service_ref);
+  SystemCoordinationUnitImpl* FindOrCreateSystemCoordinationUnit(
+      std::unique_ptr<service_manager::ServiceKeepaliveRef> service_ref);
+
+  std::vector<ProcessCoordinationUnitImpl*> GetAllProcessCoordinationUnits();
+  std::vector<FrameCoordinationUnitImpl*> GetAllFrameCoordinationUnits();
+  std::vector<PageCoordinationUnitImpl*> GetAllPageCoordinationUnits();
+
+  // Retrieves the process CU with PID |pid|, if any.
+  ProcessCoordinationUnitImpl* GetProcessCoordinationUnitByPid(
+      base::ProcessId pid);
+  CoordinationUnitBase* GetCoordinationUnitByID(const CoordinationUnitID cu_id);
+
+  std::vector<std::unique_ptr<CoordinationUnitGraphObserver>>&
+  observers_for_testing() {
+    return observers_;
+  }
+
+ private:
+  using CUIDMap = std::unordered_map<CoordinationUnitID,
+                                     std::unique_ptr<CoordinationUnitBase>>;
+  using ProcessByPidMap =
+      std::unordered_map<base::ProcessId, ProcessCoordinationUnitImpl*>;
+
+  // Lifetime management functions for CoordinationUnitBase.
+  friend class CoordinationUnitBase;
+  CoordinationUnitBase* AddNewCoordinationUnit(
+      std::unique_ptr<CoordinationUnitBase> new_cu);
+  void DestroyCoordinationUnit(CoordinationUnitBase* cu);
+
+  // Process PID map for use by ProcessCoordinationUnitImpl.
+  friend class ProcessCoordinationUnitImpl;
+  void BeforeProcessPidChange(ProcessCoordinationUnitImpl* process,
+                              base::ProcessId new_pid);
+
+  template <typename CUType>
+  std::vector<CUType*> GetAllCoordinationUnitsOfType();
+
+  CoordinationUnitID system_coordination_unit_id_;
+  CUIDMap coordination_units_;
+  ProcessByPidMap processes_by_pid_;
+  std::vector<std::unique_ptr<CoordinationUnitGraphObserver>> observers_;
+  ukm::UkmRecorder* ukm_recorder_ = nullptr;
+  std::unique_ptr<CoordinationUnitProviderImpl> provider_;
+
+  static void Create(service_manager::ServiceKeepalive* keepalive);
+
+  DISALLOW_COPY_AND_ASSIGN(CoordinationUnitGraph);
+};
+
+}  // namespace resource_coordinator
+
+#endif  // SERVICES_RESOURCE_COORDINATOR_COORDINATION_UNIT_COORDINATION_UNIT_GRAPH_H_
diff -BbuN a/services/resource_coordinator/coordination_unit/coordination_unit_graph_unittest.cc b/services/resource_coordinator/coordination_unit/coordination_unit_graph_unittest.cc
--- a/services/resource_coordinator/coordination_unit/coordination_unit_graph_unittest.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/services/resource_coordinator/coordination_unit/coordination_unit_graph_unittest.cc	2019-05-17 18:53:37.956000000 +0300
@@ -0,0 +1,120 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "services/resource_coordinator/coordination_unit/coordination_unit_graph.h"
+
+#include "services/resource_coordinator/coordination_unit/frame_coordination_unit_impl.h"
+#include "services/resource_coordinator/coordination_unit/mock_coordination_unit_graphs.h"
+#include "services/resource_coordinator/coordination_unit/process_coordination_unit_impl.h"
+#include "services/resource_coordinator/coordination_unit/system_coordination_unit_impl.h"
+#include "testing/gtest/include/gtest/gtest.h"
+
+namespace resource_coordinator {
+namespace {
+
+ProcessCoordinationUnitImpl* CreateProcessCU(CoordinationUnitGraph* graph) {
+  return graph->CreateProcessCoordinationUnit(
+      CoordinationUnitID(CoordinationUnitType::kProcess,
+                         CoordinationUnitID::RANDOM_ID),
+      nullptr);
+}
+
+}  // namespace
+
+TEST(CoordinationUnitGraphTest, DestructionWhileCUSOutstanding) {
+  std::unique_ptr<CoordinationUnitGraph> graph(new CoordinationUnitGraph());
+
+  for (size_t i = 0; i < 10; ++i) {
+    ProcessCoordinationUnitImpl* process = CreateProcessCU(graph.get());
+    EXPECT_NE(nullptr, process);
+
+    process->SetPID(i + 100);
+  }
+
+  EXPECT_NE(nullptr, graph->FindOrCreateSystemCoordinationUnit(nullptr));
+
+  // This should destroy all the CUs without incident.
+  graph.reset();
+}
+
+TEST(CoordinationUnitGraphTest, FindOrCreateSystemCoordinationUnit) {
+  CoordinationUnitGraph graph;
+
+  SystemCoordinationUnitImpl* system_cu =
+      graph.FindOrCreateSystemCoordinationUnit(nullptr);
+
+  // A second request should return the same instance.
+  EXPECT_EQ(system_cu, graph.FindOrCreateSystemCoordinationUnit(nullptr));
+
+  // Destructing the system CU should be allowed.
+  system_cu->Destruct();
+
+  system_cu = graph.FindOrCreateSystemCoordinationUnit(nullptr);
+  EXPECT_NE(nullptr, system_cu);
+}
+
+TEST(CoordinationUnitGraphTest, GetProcessCoordinationUnitByPid) {
+  CoordinationUnitGraph graph;
+
+  ProcessCoordinationUnitImpl* process = CreateProcessCU(&graph);
+  EXPECT_EQ(base::kNullProcessId, process->process_id());
+
+  static constexpr base::ProcessId kPid = 10;
+
+  EXPECT_EQ(nullptr, graph.GetProcessCoordinationUnitByPid(kPid));
+  process->SetPID(kPid);
+  EXPECT_EQ(process, graph.GetProcessCoordinationUnitByPid(kPid));
+
+  process->Destruct();
+
+  EXPECT_EQ(nullptr, graph.GetProcessCoordinationUnitByPid(12));
+}
+
+TEST(CoordinationUnitGraphTest, PIDReuse) {
+  // This test emulates what happens on Windows under aggressive PID reuse,
+  // where a process termination notification can be delayed until after the
+  // PID has been reused for a new process.
+  CoordinationUnitGraph graph;
+
+  static constexpr base::ProcessId kPid = 10;
+
+  ProcessCoordinationUnitImpl* process1 = CreateProcessCU(&graph);
+  ProcessCoordinationUnitImpl* process2 = CreateProcessCU(&graph);
+
+  process1->SetPID(kPid);
+  EXPECT_EQ(process1, graph.GetProcessCoordinationUnitByPid(kPid));
+
+  // The second registration for the same PID should override the first one.
+  process2->SetPID(kPid);
+  EXPECT_EQ(process2, graph.GetProcessCoordinationUnitByPid(kPid));
+
+  // The destruction of the first process CU shouldn't clear the PID
+  // registration.
+  process1->Destruct();
+  EXPECT_EQ(process2, graph.GetProcessCoordinationUnitByPid(kPid));
+}
+
+TEST(CoordinationUnitGraphTest, GetAllCUsByType) {
+  CoordinationUnitGraph graph;
+  MockMultiplePagesInSingleProcessCoordinationUnitGraph cu_graph(&graph);
+
+  std::vector<ProcessCoordinationUnitImpl*> processes =
+      graph.GetAllProcessCoordinationUnits();
+  ASSERT_EQ(1u, processes.size());
+  EXPECT_NE(nullptr, processes[0]);
+
+  std::vector<FrameCoordinationUnitImpl*> frames =
+      graph.GetAllFrameCoordinationUnits();
+  ASSERT_EQ(2u, frames.size());
+  EXPECT_NE(nullptr, frames[0]);
+  EXPECT_NE(nullptr, frames[1]);
+
+  std::vector<PageCoordinationUnitImpl*> pages =
+      graph.GetAllPageCoordinationUnits();
+  ASSERT_EQ(2u, pages.size());
+  EXPECT_NE(nullptr, pages[0]);
+  EXPECT_NE(nullptr, pages[1]);
+}
+
+}  // namespace resource_coordinator
diff -BbuN a/services/resource_coordinator/coordination_unit/coordination_unit_introspector_impl.cc b/services/resource_coordinator/coordination_unit/coordination_unit_introspector_impl.cc
--- a/services/resource_coordinator/coordination_unit/coordination_unit_introspector_impl.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/services/resource_coordinator/coordination_unit/coordination_unit_introspector_impl.cc	2019-05-17 18:53:37.956000000 +0300
@@ -0,0 +1,93 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "services/resource_coordinator/coordination_unit/coordination_unit_introspector_impl.h"
+
+#include <set>
+#include <utility>
+#include <vector>
+
+#include "base/process/process_handle.h"
+#include "base/time/time.h"
+#include "services/resource_coordinator/coordination_unit/coordination_unit_graph.h"
+#include "services/resource_coordinator/coordination_unit/frame_coordination_unit_impl.h"
+#include "services/resource_coordinator/coordination_unit/page_coordination_unit_impl.h"
+#include "services/resource_coordinator/coordination_unit/process_coordination_unit_impl.h"
+#include "services/service_manager/public/cpp/bind_source_info.h"
+
+namespace {
+
+using resource_coordinator::ProcessCoordinationUnitImpl;
+using resource_coordinator::PageCoordinationUnitImpl;
+using resource_coordinator::FrameCoordinationUnitImpl;
+
+// Returns true iff the given |process| is responsible for hosting the
+// main-frame of the given |page|.
+bool HostsMainFrame(ProcessCoordinationUnitImpl* process,
+                    PageCoordinationUnitImpl* page) {
+  FrameCoordinationUnitImpl* main_frame = page->GetMainFrameCoordinationUnit();
+  if (main_frame == nullptr) {
+    // |process| can't host a frame that doesn't exist.
+    return false;
+  }
+
+  return main_frame->GetProcessCoordinationUnit() == process;
+}
+
+}  // namespace
+
+namespace resource_coordinator {
+
+CoordinationUnitIntrospectorImpl::CoordinationUnitIntrospectorImpl(
+    CoordinationUnitGraph* graph)
+    : graph_(graph) {}
+
+CoordinationUnitIntrospectorImpl::~CoordinationUnitIntrospectorImpl() = default;
+
+void CoordinationUnitIntrospectorImpl::GetProcessToURLMap(
+    GetProcessToURLMapCallback callback) {
+  std::vector<resource_coordinator::mojom::ProcessInfoPtr> process_infos;
+  std::vector<ProcessCoordinationUnitImpl*> process_cus =
+      graph_->GetAllProcessCoordinationUnits();
+  for (auto* process_cu : process_cus) {
+    int64_t pid;
+    if (!process_cu->GetProperty(mojom::PropertyType::kPID, &pid))
+      continue;
+
+    mojom::ProcessInfoPtr process_info(mojom::ProcessInfo::New());
+    process_info->pid = base::checked_cast<base::ProcessId>(pid);
+    DCHECK_NE(base::kNullProcessId, process_info->pid);
+    process_info->launch_time = process_cu->launch_time();
+
+    std::set<PageCoordinationUnitImpl*> page_cus =
+        process_cu->GetAssociatedPageCoordinationUnits();
+    for (PageCoordinationUnitImpl* page_cu : page_cus) {
+      int64_t ukm_source_id;
+      if (page_cu->GetProperty(
+              resource_coordinator::mojom::PropertyType::kUKMSourceId,
+              &ukm_source_id)) {
+        mojom::PageInfoPtr page_info(mojom::PageInfo::New());
+        page_info->ukm_source_id = ukm_source_id;
+        page_info->tab_id = page_cu->id().id;
+        page_info->hosts_main_frame = HostsMainFrame(process_cu, page_cu);
+        page_info->is_visible = page_cu->IsVisible();
+        page_info->time_since_last_visibility_change =
+            page_cu->TimeSinceLastVisibilityChange();
+        page_info->time_since_last_navigation =
+            page_cu->TimeSinceLastNavigation();
+        process_info->page_infos.push_back(std::move(page_info));
+      }
+    }
+    process_infos.push_back(std::move(process_info));
+  }
+  std::move(callback).Run(std::move(process_infos));
+}
+
+void CoordinationUnitIntrospectorImpl::BindToInterface(
+    resource_coordinator::mojom::CoordinationUnitIntrospectorRequest request,
+    const service_manager::BindSourceInfo& source_info) {
+  bindings_.AddBinding(this, std::move(request));
+}
+
+}  // namespace resource_coordinator
diff -BbuN a/services/resource_coordinator/coordination_unit/coordination_unit_introspector_impl.h b/services/resource_coordinator/coordination_unit/coordination_unit_introspector_impl.h
--- a/services/resource_coordinator/coordination_unit/coordination_unit_introspector_impl.h	1970-01-01 03:00:00.000000000 +0300
+++ b/services/resource_coordinator/coordination_unit/coordination_unit_introspector_impl.h	2019-05-17 18:53:37.956000000 +0300
@@ -0,0 +1,42 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef SERVICES_RESOURCE_COORDINATOR_COORDINATION_UNIT_COORDINATION_UNIT_INTROSPECTOR_IMPL_H_
+#define SERVICES_RESOURCE_COORDINATOR_COORDINATION_UNIT_COORDINATION_UNIT_INTROSPECTOR_IMPL_H_
+
+#include "mojo/public/cpp/bindings/binding_set.h"
+#include "services/resource_coordinator/public/mojom/coordination_unit_introspector.mojom.h"
+#include "services/service_manager/public/cpp/bind_source_info.h"
+
+namespace service_manager {
+struct BindSourceInfo;
+}  // namespace service_manager
+
+namespace resource_coordinator {
+
+class CoordinationUnitGraph;
+
+class CoordinationUnitIntrospectorImpl
+    : public mojom::CoordinationUnitIntrospector {
+ public:
+  explicit CoordinationUnitIntrospectorImpl(CoordinationUnitGraph* graph);
+  ~CoordinationUnitIntrospectorImpl() override;
+
+  void BindToInterface(
+      resource_coordinator::mojom::CoordinationUnitIntrospectorRequest request,
+      const service_manager::BindSourceInfo& source_info);
+
+  // Overridden from mojom::CoordinationUnitIntrospector:
+  void GetProcessToURLMap(GetProcessToURLMapCallback callback) override;
+
+ private:
+  CoordinationUnitGraph* const graph_;
+  mojo::BindingSet<mojom::CoordinationUnitIntrospector> bindings_;
+
+  DISALLOW_COPY_AND_ASSIGN(CoordinationUnitIntrospectorImpl);
+};
+
+}  // namespace resource_coordinator
+
+#endif  // SERVICES_RESOURCE_COORDINATOR_COORDINATION_UNIT_COORDINATION_UNIT_INTROSPECTOR_IMPL_H_
diff -BbuN a/services/resource_coordinator/coordination_unit/coordination_unit_provider_impl.cc b/services/resource_coordinator/coordination_unit/coordination_unit_provider_impl.cc
--- a/services/resource_coordinator/coordination_unit/coordination_unit_provider_impl.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/services/resource_coordinator/coordination_unit/coordination_unit_provider_impl.cc	2019-05-17 18:53:37.956000000 +0300
@@ -0,0 +1,94 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "services/resource_coordinator/coordination_unit/coordination_unit_provider_impl.h"
+
+#include <memory>
+#include <utility>
+
+#include "base/macros.h"
+#include "services/resource_coordinator/coordination_unit/frame_coordination_unit_impl.h"
+#include "services/resource_coordinator/coordination_unit/page_coordination_unit_impl.h"
+#include "services/resource_coordinator/coordination_unit/process_coordination_unit_impl.h"
+#include "services/resource_coordinator/coordination_unit/system_coordination_unit_impl.h"
+#include "services/service_manager/public/cpp/bind_source_info.h"
+
+namespace resource_coordinator {
+
+CoordinationUnitProviderImpl::CoordinationUnitProviderImpl(
+    service_manager::ServiceKeepalive* service_keepalive,
+    CoordinationUnitGraph* coordination_unit_graph)
+    : service_keepalive_(service_keepalive),
+      coordination_unit_graph_(coordination_unit_graph) {
+  DCHECK(service_keepalive_);
+  keepalive_ref_ = service_keepalive_->CreateRef();
+}
+
+CoordinationUnitProviderImpl::~CoordinationUnitProviderImpl() = default;
+
+void CoordinationUnitProviderImpl::OnConnectionError(
+    CoordinationUnitBase* coordination_unit) {
+  coordination_unit->Destruct();
+}
+
+void CoordinationUnitProviderImpl::CreateFrameCoordinationUnit(
+    mojom::FrameCoordinationUnitRequest request,
+    const CoordinationUnitID& id) {
+  FrameCoordinationUnitImpl* frame_cu =
+      coordination_unit_graph_->CreateFrameCoordinationUnit(
+          id, service_keepalive_->CreateRef());
+
+  frame_cu->Bind(std::move(request));
+  auto& frame_cu_binding = frame_cu->binding();
+
+  frame_cu_binding.set_connection_error_handler(
+      base::BindOnce(&CoordinationUnitProviderImpl::OnConnectionError,
+                     base::Unretained(this), frame_cu));
+}
+
+void CoordinationUnitProviderImpl::CreatePageCoordinationUnit(
+    mojom::PageCoordinationUnitRequest request,
+    const CoordinationUnitID& id) {
+  PageCoordinationUnitImpl* page_cu =
+      coordination_unit_graph_->CreatePageCoordinationUnit(
+          id, service_keepalive_->CreateRef());
+
+  page_cu->Bind(std::move(request));
+  auto& page_cu_binding = page_cu->binding();
+
+  page_cu_binding.set_connection_error_handler(
+      base::BindOnce(&CoordinationUnitProviderImpl::OnConnectionError,
+                     base::Unretained(this), page_cu));
+}
+
+void CoordinationUnitProviderImpl::CreateProcessCoordinationUnit(
+    mojom::ProcessCoordinationUnitRequest request,
+    const CoordinationUnitID& id) {
+  ProcessCoordinationUnitImpl* process_cu =
+      coordination_unit_graph_->CreateProcessCoordinationUnit(
+          id, service_keepalive_->CreateRef());
+
+  process_cu->Bind(std::move(request));
+  auto& process_cu_binding = process_cu->binding();
+
+  process_cu_binding.set_connection_error_handler(
+      base::BindOnce(&CoordinationUnitProviderImpl::OnConnectionError,
+                     base::Unretained(this), process_cu));
+}
+
+void CoordinationUnitProviderImpl::GetSystemCoordinationUnit(
+    resource_coordinator::mojom::SystemCoordinationUnitRequest request) {
+  // Simply fetch the existing SystemCU and add an additional binding to it.
+  coordination_unit_graph_
+      ->FindOrCreateSystemCoordinationUnit(service_keepalive_->CreateRef())
+      ->AddBinding(std::move(request));
+}
+
+void CoordinationUnitProviderImpl::Bind(
+    resource_coordinator::mojom::CoordinationUnitProviderRequest request,
+    const service_manager::BindSourceInfo& source_info) {
+  bindings_.AddBinding(this, std::move(request));
+}
+
+}  // namespace resource_coordinator
diff -BbuN a/services/resource_coordinator/coordination_unit/coordination_unit_provider_impl.h b/services/resource_coordinator/coordination_unit/coordination_unit_provider_impl.h
--- a/services/resource_coordinator/coordination_unit/coordination_unit_provider_impl.h	1970-01-01 03:00:00.000000000 +0300
+++ b/services/resource_coordinator/coordination_unit/coordination_unit_provider_impl.h	2019-05-17 18:53:37.956000000 +0300
@@ -0,0 +1,61 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef SERVICES_RESOURCE_COORDINATOR_COORDINATION_UNIT_COORDINATION_UNIT_PROVIDER_IMPL_H_
+#define SERVICES_RESOURCE_COORDINATOR_COORDINATION_UNIT_COORDINATION_UNIT_PROVIDER_IMPL_H_
+
+#include <memory>
+#include <vector>
+
+#include "mojo/public/cpp/bindings/binding_set.h"
+#include "mojo/public/cpp/bindings/interface_request.h"
+#include "services/resource_coordinator/coordination_unit/coordination_unit_graph.h"
+#include "services/resource_coordinator/public/mojom/coordination_unit_provider.mojom.h"
+#include "services/service_manager/public/cpp/service_keepalive.h"
+
+namespace service_manager {
+struct BindSourceInfo;
+}  // service_manager
+
+namespace resource_coordinator {
+
+class CoordinationUnitProviderImpl : public mojom::CoordinationUnitProvider {
+ public:
+  CoordinationUnitProviderImpl(
+      service_manager::ServiceKeepalive* service_keepalive,
+      CoordinationUnitGraph* coordination_unit_graph);
+  ~CoordinationUnitProviderImpl() override;
+
+  void Bind(
+      resource_coordinator::mojom::CoordinationUnitProviderRequest request,
+      const service_manager::BindSourceInfo& source_info);
+
+  void OnConnectionError(CoordinationUnitBase* coordination_unit);
+
+  // Overridden from mojom::CoordinationUnitProvider:
+  void CreateFrameCoordinationUnit(
+      resource_coordinator::mojom::FrameCoordinationUnitRequest request,
+      const CoordinationUnitID& id) override;
+  void CreatePageCoordinationUnit(
+      resource_coordinator::mojom::PageCoordinationUnitRequest request,
+      const CoordinationUnitID& id) override;
+  void CreateProcessCoordinationUnit(
+      resource_coordinator::mojom::ProcessCoordinationUnitRequest request,
+      const CoordinationUnitID& id) override;
+  void GetSystemCoordinationUnit(
+      resource_coordinator::mojom::SystemCoordinationUnitRequest request)
+      override;
+
+ private:
+  service_manager::ServiceKeepalive* const service_keepalive_;
+  std::unique_ptr<service_manager::ServiceKeepaliveRef> keepalive_ref_;
+  CoordinationUnitGraph* coordination_unit_graph_;
+  mojo::BindingSet<mojom::CoordinationUnitProvider> bindings_;
+
+  DISALLOW_COPY_AND_ASSIGN(CoordinationUnitProviderImpl);
+};
+
+}  // namespace resource_coordinator
+
+#endif  // SERVICES_RESOURCE_COORDINATOR_COORDINATION_UNIT_COORDINATION_UNIT_PROVIDER_IMPL_H_
diff -BbuN a/services/resource_coordinator/coordination_unit/coordination_unit_test_harness.cc b/services/resource_coordinator/coordination_unit/coordination_unit_test_harness.cc
--- a/services/resource_coordinator/coordination_unit/coordination_unit_test_harness.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/services/resource_coordinator/coordination_unit/coordination_unit_test_harness.cc	2019-05-17 18:53:37.956000000 +0300
@@ -0,0 +1,25 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "services/resource_coordinator/coordination_unit/coordination_unit_test_harness.h"
+
+#include "base/bind.h"
+#include "base/run_loop.h"
+
+namespace resource_coordinator {
+
+CoordinationUnitTestHarness::CoordinationUnitTestHarness()
+    : task_env_(base::test::ScopedTaskEnvironment::MainThreadType::MOCK_TIME,
+                base::test::ScopedTaskEnvironment::ExecutionMode::QUEUED),
+      service_keepalive_(static_cast<service_manager::ServiceBinding*>(nullptr),
+                         base::nullopt /* idle_timeout */),
+      provider_(&service_keepalive_, &coordination_unit_graph_) {}
+
+CoordinationUnitTestHarness::~CoordinationUnitTestHarness() = default;
+
+void CoordinationUnitTestHarness::TearDown() {
+  base::RunLoop().RunUntilIdle();
+}
+
+}  // namespace resource_coordinator
diff -BbuN a/services/resource_coordinator/coordination_unit/coordination_unit_test_harness.h b/services/resource_coordinator/coordination_unit/coordination_unit_test_harness.h
--- a/services/resource_coordinator/coordination_unit/coordination_unit_test_harness.h	1970-01-01 03:00:00.000000000 +0300
+++ b/services/resource_coordinator/coordination_unit/coordination_unit_test_harness.h	2019-05-17 18:53:37.956000000 +0300
@@ -0,0 +1,108 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef SERVICES_RESOURCE_COORDINATOR_COORDINATION_UNIT_COORDINATION_UNIT_TEST_HARNESS_H_
+#define SERVICES_RESOURCE_COORDINATOR_COORDINATION_UNIT_COORDINATION_UNIT_TEST_HARNESS_H_
+
+#include <stdint.h>
+#include <string>
+
+#include "base/test/scoped_task_environment.h"
+#include "services/resource_coordinator/coordination_unit/coordination_unit_base.h"
+#include "services/resource_coordinator/coordination_unit/coordination_unit_graph.h"
+#include "services/resource_coordinator/coordination_unit/coordination_unit_provider_impl.h"
+#include "services/resource_coordinator/coordination_unit/system_coordination_unit_impl.h"
+#include "services/service_manager/public/cpp/service_keepalive.h"
+#include "testing/gtest/include/gtest/gtest.h"
+
+namespace resource_coordinator {
+
+struct CoordinationUnitID;
+class SystemCoordinationUnitImpl;
+
+template <class CoordinationUnitClass>
+class TestCoordinationUnitWrapper {
+ public:
+  static TestCoordinationUnitWrapper<CoordinationUnitClass> Create(
+      CoordinationUnitGraph* graph) {
+    CoordinationUnitID cu_id(CoordinationUnitClass::Type(),
+                             CoordinationUnitID::RANDOM_ID);
+    return TestCoordinationUnitWrapper<CoordinationUnitClass>(
+        CoordinationUnitClass::Create(cu_id, graph, nullptr));
+  }
+
+  TestCoordinationUnitWrapper(CoordinationUnitClass* impl) : impl_(impl) {
+    DCHECK(impl);
+  }
+  ~TestCoordinationUnitWrapper() { reset(); }
+
+  CoordinationUnitClass* operator->() const { return impl_; }
+
+  TestCoordinationUnitWrapper(TestCoordinationUnitWrapper&& other)
+      : impl_(other.impl_) {}
+
+  CoordinationUnitClass* get() const { return impl_; }
+
+  void reset() {
+    if (impl_) {
+      impl_->Destruct();
+      impl_ = nullptr;
+    }
+  }
+
+ private:
+  CoordinationUnitClass* impl_;
+
+  DISALLOW_COPY_AND_ASSIGN(TestCoordinationUnitWrapper);
+};
+
+class CoordinationUnitTestHarness : public testing::Test {
+ public:
+  CoordinationUnitTestHarness();
+  ~CoordinationUnitTestHarness() override;
+
+  template <class CoordinationUnitClass>
+  TestCoordinationUnitWrapper<CoordinationUnitClass> CreateCoordinationUnit(
+      CoordinationUnitID cu_id) {
+    return TestCoordinationUnitWrapper<CoordinationUnitClass>(
+        CoordinationUnitClass::Create(cu_id, coordination_unit_graph(),
+                                      service_keepalive_.CreateRef()));
+  }
+
+  template <class CoordinationUnitClass>
+  TestCoordinationUnitWrapper<CoordinationUnitClass> CreateCoordinationUnit() {
+    CoordinationUnitID cu_id(CoordinationUnitClass::Type(),
+                             CoordinationUnitID::RANDOM_ID);
+    return CreateCoordinationUnit<CoordinationUnitClass>(cu_id);
+  }
+
+  TestCoordinationUnitWrapper<SystemCoordinationUnitImpl>
+  GetSystemCoordinationUnit() {
+    return TestCoordinationUnitWrapper<SystemCoordinationUnitImpl>(
+        coordination_unit_graph()->FindOrCreateSystemCoordinationUnit(
+            service_keepalive_.CreateRef()));
+  }
+
+  // testing::Test:
+  void TearDown() override;
+
+ protected:
+  base::test::ScopedTaskEnvironment& task_env() {
+    return task_env_;
+  }
+  CoordinationUnitGraph* coordination_unit_graph() {
+    return &coordination_unit_graph_;
+  }
+  CoordinationUnitProviderImpl* provider() { return &provider_; }
+
+ private:
+  base::test::ScopedTaskEnvironment task_env_;
+  service_manager::ServiceKeepalive service_keepalive_;
+  CoordinationUnitGraph coordination_unit_graph_;
+  CoordinationUnitProviderImpl provider_;
+};
+
+}  // namespace resource_coordinator
+
+#endif  // SERVICES_RESOURCE_COORDINATOR_COORDINATION_UNIT_COORDINATION_UNIT_TEST_HARNESS_H_
diff -BbuN a/services/resource_coordinator/coordination_unit/frame_coordination_unit_impl.cc b/services/resource_coordinator/coordination_unit/frame_coordination_unit_impl.cc
--- a/services/resource_coordinator/coordination_unit/frame_coordination_unit_impl.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/services/resource_coordinator/coordination_unit/frame_coordination_unit_impl.cc	2019-05-17 18:53:37.956000000 +0300
@@ -0,0 +1,252 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "services/resource_coordinator/coordination_unit/frame_coordination_unit_impl.h"
+
+#include "services/resource_coordinator/coordination_unit/page_coordination_unit_impl.h"
+#include "services/resource_coordinator/coordination_unit/process_coordination_unit_impl.h"
+#include "services/resource_coordinator/observers/coordination_unit_graph_observer.h"
+#include "services/resource_coordinator/resource_coordinator_clock.h"
+
+namespace resource_coordinator {
+
+FrameCoordinationUnitImpl::FrameCoordinationUnitImpl(
+    const CoordinationUnitID& id,
+    CoordinationUnitGraph* graph,
+    std::unique_ptr<service_manager::ServiceKeepaliveRef> keepalive_ref)
+    : CoordinationUnitInterface(id, graph, std::move(keepalive_ref)),
+      parent_frame_coordination_unit_(nullptr),
+      page_coordination_unit_(nullptr),
+      process_coordination_unit_(nullptr) {
+  for (size_t i = 0; i < base::size(intervention_policy_); ++i)
+    intervention_policy_[i] = mojom::InterventionPolicy::kUnknown;
+}
+
+FrameCoordinationUnitImpl::~FrameCoordinationUnitImpl() {
+  if (parent_frame_coordination_unit_)
+    parent_frame_coordination_unit_->RemoveChildFrame(this);
+  if (page_coordination_unit_)
+    page_coordination_unit_->RemoveFrame(this);
+  if (process_coordination_unit_)
+    process_coordination_unit_->RemoveFrame(this);
+  for (auto* child_frame : child_frame_coordination_units_)
+    child_frame->RemoveParentFrame(this);
+}
+
+void FrameCoordinationUnitImpl::SetProcess(const CoordinationUnitID& cu_id) {
+  ProcessCoordinationUnitImpl* process_cu =
+      ProcessCoordinationUnitImpl::GetCoordinationUnitByID(graph_, cu_id);
+  if (!process_cu)
+    return;
+  DCHECK(!process_coordination_unit_);
+  process_coordination_unit_ = process_cu;
+  process_cu->AddFrame(this);
+}
+
+void FrameCoordinationUnitImpl::AddChildFrame(const CoordinationUnitID& cu_id) {
+  DCHECK(cu_id != id());
+  FrameCoordinationUnitImpl* frame_cu =
+      FrameCoordinationUnitImpl::GetCoordinationUnitByID(graph_, cu_id);
+  if (!frame_cu)
+    return;
+  if (HasFrameCoordinationUnitInAncestors(frame_cu) ||
+      frame_cu->HasFrameCoordinationUnitInDescendants(this)) {
+    DCHECK(false) << "Cyclic reference in frame coordination units detected!";
+    return;
+  }
+  if (AddChildFrame(frame_cu)) {
+    frame_cu->AddParentFrame(this);
+  }
+}
+
+void FrameCoordinationUnitImpl::RemoveChildFrame(
+    const CoordinationUnitID& cu_id) {
+  DCHECK(cu_id != id());
+  FrameCoordinationUnitImpl* frame_cu =
+      FrameCoordinationUnitImpl::GetCoordinationUnitByID(graph_, cu_id);
+  if (!frame_cu)
+    return;
+  if (RemoveChildFrame(frame_cu)) {
+    frame_cu->RemoveParentFrame(this);
+  }
+}
+
+void FrameCoordinationUnitImpl::SetNetworkAlmostIdle(bool idle) {
+  SetProperty(mojom::PropertyType::kNetworkAlmostIdle, idle);
+}
+
+void FrameCoordinationUnitImpl::SetLifecycleState(mojom::LifecycleState state) {
+  if (state == lifecycle_state_)
+    return;
+
+  mojom::LifecycleState old_state = lifecycle_state_;
+  lifecycle_state_ = state;
+
+  // Notify parents of this change.
+  if (process_coordination_unit_)
+    process_coordination_unit_->OnFrameLifecycleStateChanged(this, old_state);
+  if (page_coordination_unit_)
+    page_coordination_unit_->OnFrameLifecycleStateChanged(this, old_state);
+}
+
+void FrameCoordinationUnitImpl::SetHasNonEmptyBeforeUnload(
+    bool has_nonempty_beforeunload) {
+  has_nonempty_beforeunload_ = has_nonempty_beforeunload;
+}
+
+void FrameCoordinationUnitImpl::SetInterventionPolicy(
+    mojom::PolicyControlledIntervention intervention,
+    mojom::InterventionPolicy policy) {
+  size_t i = static_cast<size_t>(intervention);
+  DCHECK_LT(i, base::size(intervention_policy_));
+
+  // This can only be called to set a policy, but not to revert a policy to the
+  // unset state.
+  DCHECK_NE(mojom::InterventionPolicy::kUnknown, policy);
+
+  // We expect intervention policies to be initially set in order, and rely on
+  // that as a synchronization primitive. Ensure this is the case.
+  DCHECK(i == 0 ||
+         intervention_policy_[i - 1] != mojom::InterventionPolicy::kUnknown);
+
+  if (policy == intervention_policy_[i])
+    return;
+  // Only notify of actual changes.
+  mojom::InterventionPolicy old_policy = intervention_policy_[i];
+  intervention_policy_[i] = policy;
+  if (auto* page_cu = GetPageCoordinationUnit()) {
+    page_cu->OnFrameInterventionPolicyChanged(this, intervention, old_policy,
+                                              policy);
+  }
+}
+
+void FrameCoordinationUnitImpl::OnNonPersistentNotificationCreated() {
+  SendEvent(mojom::Event::kNonPersistentNotificationCreated);
+}
+
+FrameCoordinationUnitImpl*
+FrameCoordinationUnitImpl::GetParentFrameCoordinationUnit() const {
+  return parent_frame_coordination_unit_;
+}
+
+PageCoordinationUnitImpl* FrameCoordinationUnitImpl::GetPageCoordinationUnit()
+    const {
+  return page_coordination_unit_;
+}
+
+ProcessCoordinationUnitImpl*
+FrameCoordinationUnitImpl::GetProcessCoordinationUnit() const {
+  return process_coordination_unit_;
+}
+
+bool FrameCoordinationUnitImpl::IsMainFrame() const {
+  return !parent_frame_coordination_unit_;
+}
+
+bool FrameCoordinationUnitImpl::AreAllInterventionPoliciesSet() const {
+  // The convention is that policies are first set en masse, in order. So if
+  // the last policy is set then they are all considered to be set. Check this
+  // in DEBUG builds.
+#if DCHECK_IS_ON()
+  bool seen_unset_policy = false;
+  for (size_t i = 0; i < base::size(intervention_policy_); ++i) {
+    if (!seen_unset_policy) {
+      seen_unset_policy =
+          intervention_policy_[i] != mojom::InterventionPolicy::kUnknown;
+    } else {
+      // Once a first unset policy is seen, all subsequent policies must be
+      // unset.
+      DCHECK_NE(mojom::InterventionPolicy::kUnknown, intervention_policy_[i]);
+    }
+  }
+#endif
+
+  return intervention_policy_[base::size(intervention_policy_) - 1] !=
+         mojom::InterventionPolicy::kUnknown;
+}  // namespace resource_coordinator
+
+void FrameCoordinationUnitImpl::SetAllInterventionPoliciesForTesting(
+    mojom::InterventionPolicy policy) {
+  for (size_t i = 0; i < base::size(intervention_policy_); ++i) {
+    SetInterventionPolicy(static_cast<mojom::PolicyControlledIntervention>(i),
+                          policy);
+  }
+}
+
+void FrameCoordinationUnitImpl::OnEventReceived(mojom::Event event) {
+  for (auto& observer : observers())
+    observer.OnFrameEventReceived(this, event);
+}
+
+void FrameCoordinationUnitImpl::OnPropertyChanged(
+    mojom::PropertyType property_type,
+    int64_t value) {
+  for (auto& observer : observers())
+    observer.OnFramePropertyChanged(this, property_type, value);
+}
+
+bool FrameCoordinationUnitImpl::HasFrameCoordinationUnitInAncestors(
+    FrameCoordinationUnitImpl* frame_cu) const {
+  if (parent_frame_coordination_unit_ == frame_cu ||
+      (parent_frame_coordination_unit_ &&
+       parent_frame_coordination_unit_->HasFrameCoordinationUnitInAncestors(
+           frame_cu))) {
+    return true;
+  }
+  return false;
+}
+
+bool FrameCoordinationUnitImpl::HasFrameCoordinationUnitInDescendants(
+    FrameCoordinationUnitImpl* frame_cu) const {
+  for (FrameCoordinationUnitImpl* child : child_frame_coordination_units_) {
+    if (child == frame_cu ||
+        child->HasFrameCoordinationUnitInDescendants(frame_cu)) {
+      return true;
+    }
+  }
+  return false;
+}
+
+void FrameCoordinationUnitImpl::AddParentFrame(
+    FrameCoordinationUnitImpl* parent_frame_cu) {
+  parent_frame_coordination_unit_ = parent_frame_cu;
+}
+
+bool FrameCoordinationUnitImpl::AddChildFrame(
+    FrameCoordinationUnitImpl* child_frame_cu) {
+  return child_frame_coordination_units_.count(child_frame_cu)
+             ? false
+             : child_frame_coordination_units_.insert(child_frame_cu).second;
+}
+
+void FrameCoordinationUnitImpl::RemoveParentFrame(
+    FrameCoordinationUnitImpl* parent_frame_cu) {
+  DCHECK(parent_frame_coordination_unit_ == parent_frame_cu);
+  parent_frame_coordination_unit_ = nullptr;
+}
+
+bool FrameCoordinationUnitImpl::RemoveChildFrame(
+    FrameCoordinationUnitImpl* child_frame_cu) {
+  return child_frame_coordination_units_.erase(child_frame_cu) > 0;
+}
+
+void FrameCoordinationUnitImpl::AddPageCoordinationUnit(
+    PageCoordinationUnitImpl* page_coordination_unit) {
+  DCHECK(!page_coordination_unit_);
+  page_coordination_unit_ = page_coordination_unit;
+}
+
+void FrameCoordinationUnitImpl::RemovePageCoordinationUnit(
+    PageCoordinationUnitImpl* page_coordination_unit) {
+  DCHECK(page_coordination_unit == page_coordination_unit_);
+  page_coordination_unit_ = nullptr;
+}
+
+void FrameCoordinationUnitImpl::RemoveProcessCoordinationUnit(
+    ProcessCoordinationUnitImpl* process_coordination_unit) {
+  DCHECK(process_coordination_unit == process_coordination_unit_);
+  process_coordination_unit_ = nullptr;
+}
+
+}  // namespace resource_coordinator
diff -BbuN a/services/resource_coordinator/coordination_unit/frame_coordination_unit_impl.h b/services/resource_coordinator/coordination_unit/frame_coordination_unit_impl.h
--- a/services/resource_coordinator/coordination_unit/frame_coordination_unit_impl.h	1970-01-01 03:00:00.000000000 +0300
+++ b/services/resource_coordinator/coordination_unit/frame_coordination_unit_impl.h	2019-05-17 18:53:37.956000000 +0300
@@ -0,0 +1,107 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef SERVICES_RESOURCE_COORDINATOR_COORDINATION_UNIT_FRAME_COORDINATION_UNIT_IMPL_H_
+#define SERVICES_RESOURCE_COORDINATOR_COORDINATION_UNIT_FRAME_COORDINATION_UNIT_IMPL_H_
+
+#include "base/macros.h"
+#include "services/resource_coordinator/coordination_unit/coordination_unit_base.h"
+
+namespace resource_coordinator {
+
+class PageCoordinationUnitImpl;
+class ProcessCoordinationUnitImpl;
+
+// Frame Coordination Units form a tree structure, each FrameCoordinationUnit at
+// most has one parent that is a FrameCoordinationUnit.
+// A Frame Coordination Unit will have parents only if navigation committed.
+class FrameCoordinationUnitImpl
+    : public CoordinationUnitInterface<FrameCoordinationUnitImpl,
+                                       mojom::FrameCoordinationUnit,
+                                       mojom::FrameCoordinationUnitRequest> {
+ public:
+  static CoordinationUnitType Type() { return CoordinationUnitType::kFrame; }
+
+  FrameCoordinationUnitImpl(
+      const CoordinationUnitID& id,
+      CoordinationUnitGraph* graph,
+      std::unique_ptr<service_manager::ServiceKeepaliveRef> keepalive_ref);
+  ~FrameCoordinationUnitImpl() override;
+
+  // FrameCoordinationUnit implementation.
+  void SetProcess(const CoordinationUnitID& cu_id) override;
+  void AddChildFrame(const CoordinationUnitID& cu_id) override;
+  void RemoveChildFrame(const CoordinationUnitID& cu_id) override;
+  void SetNetworkAlmostIdle(bool idle) override;
+  void SetLifecycleState(mojom::LifecycleState state) override;
+  void SetHasNonEmptyBeforeUnload(bool has_nonempty_beforeunload) override;
+  void SetInterventionPolicy(mojom::PolicyControlledIntervention intervention,
+                             mojom::InterventionPolicy policy) override;
+  void OnNonPersistentNotificationCreated() override;
+
+  FrameCoordinationUnitImpl* GetParentFrameCoordinationUnit() const;
+  PageCoordinationUnitImpl* GetPageCoordinationUnit() const;
+  ProcessCoordinationUnitImpl* GetProcessCoordinationUnit() const;
+  bool IsMainFrame() const;
+
+  mojom::LifecycleState lifecycle_state() const { return lifecycle_state_; }
+  bool has_nonempty_beforeunload() const { return has_nonempty_beforeunload_; }
+
+  // Returns true if all intervention policies have been set for this frame.
+  bool AreAllInterventionPoliciesSet() const;
+
+  const std::set<FrameCoordinationUnitImpl*>&
+  child_frame_coordination_units_for_testing() const {
+    return child_frame_coordination_units_;
+  }
+
+  // Sets the same policy for all intervention types in this frame. Causes
+  // Page::OnFrameInterventionPolicyChanged to be invoked.
+  void SetAllInterventionPoliciesForTesting(mojom::InterventionPolicy policy);
+
+ private:
+  friend class PageCoordinationUnitImpl;
+  friend class ProcessCoordinationUnitImpl;
+
+  // CoordinationUnitInterface implementation.
+  void OnEventReceived(mojom::Event event) override;
+  void OnPropertyChanged(mojom::PropertyType property_type,
+                         int64_t value) override;
+
+  bool HasFrameCoordinationUnitInAncestors(
+      FrameCoordinationUnitImpl* frame_cu) const;
+  bool HasFrameCoordinationUnitInDescendants(
+      FrameCoordinationUnitImpl* frame_cu) const;
+
+  // The following methods will be called by other FrameCoordinationUnitImpl,
+  // PageCoordinationUnitImpl and ProcessCoordinationUnitImpl respectively to
+  // manipulate their relationship.
+  void AddParentFrame(FrameCoordinationUnitImpl* parent_frame_cu);
+  bool AddChildFrame(FrameCoordinationUnitImpl* child_frame_cu);
+  void RemoveParentFrame(FrameCoordinationUnitImpl* parent_frame_cu);
+  bool RemoveChildFrame(FrameCoordinationUnitImpl* child_frame_cu);
+  void AddPageCoordinationUnit(PageCoordinationUnitImpl* page_cu);
+  void AddProcessCoordinationUnit(ProcessCoordinationUnitImpl* process_cu);
+  void RemovePageCoordinationUnit(PageCoordinationUnitImpl* page_cu);
+  void RemoveProcessCoordinationUnit(ProcessCoordinationUnitImpl* process_cu);
+
+  FrameCoordinationUnitImpl* parent_frame_coordination_unit_;
+  PageCoordinationUnitImpl* page_coordination_unit_;
+  ProcessCoordinationUnitImpl* process_coordination_unit_;
+  std::set<FrameCoordinationUnitImpl*> child_frame_coordination_units_;
+
+  mojom::LifecycleState lifecycle_state_ = mojom::LifecycleState::kRunning;
+  bool has_nonempty_beforeunload_ = false;
+
+  // Intervention policy for this frame. These are communicated from the
+  // renderer process and are controlled by origin trials.
+  mojom::InterventionPolicy intervention_policy_
+      [static_cast<size_t>(mojom::PolicyControlledIntervention::kMaxValue) + 1];
+
+  DISALLOW_COPY_AND_ASSIGN(FrameCoordinationUnitImpl);
+};
+
+}  // namespace resource_coordinator
+
+#endif  // SERVICES_RESOURCE_COORDINATOR_COORDINATION_UNIT_FRAME_COORDINATION_UNIT_IMPL_H_
diff -BbuN a/services/resource_coordinator/coordination_unit/frame_coordination_unit_impl_unittest.cc b/services/resource_coordinator/coordination_unit/frame_coordination_unit_impl_unittest.cc
--- a/services/resource_coordinator/coordination_unit/frame_coordination_unit_impl_unittest.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/services/resource_coordinator/coordination_unit/frame_coordination_unit_impl_unittest.cc	2019-05-17 18:53:37.956000000 +0300
@@ -0,0 +1,187 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "services/resource_coordinator/coordination_unit/frame_coordination_unit_impl.h"
+
+#include "base/test/simple_test_tick_clock.h"
+#include "services/resource_coordinator/coordination_unit/coordination_unit_test_harness.h"
+#include "services/resource_coordinator/coordination_unit/mock_coordination_unit_graphs.h"
+#include "services/resource_coordinator/coordination_unit/page_coordination_unit_impl.h"
+#include "services/resource_coordinator/coordination_unit/process_coordination_unit_impl.h"
+#include "services/resource_coordinator/resource_coordinator_clock.h"
+#include "testing/gtest/include/gtest/gtest.h"
+
+namespace resource_coordinator {
+
+namespace {
+
+class FrameCoordinationUnitImplTest : public CoordinationUnitTestHarness {
+ public:
+  void SetUp() override {
+    ResourceCoordinatorClock::SetClockForTesting(&clock_);
+
+    // Sets a valid starting time.
+    clock_.SetNowTicks(base::TimeTicks::Now());
+  }
+
+  void TearDown() override {
+    ResourceCoordinatorClock::ResetClockForTesting();
+  }
+
+ protected:
+  void AdvanceClock(base::TimeDelta delta) { clock_.Advance(delta); }
+
+ private:
+  base::SimpleTestTickClock clock_;
+};
+
+using FrameCoordinationUnitImplDeathTest = FrameCoordinationUnitImplTest;
+
+}  // namespace
+
+TEST_F(FrameCoordinationUnitImplTest, AddChildFrameBasic) {
+  auto frame1_cu = CreateCoordinationUnit<FrameCoordinationUnitImpl>();
+  auto frame2_cu = CreateCoordinationUnit<FrameCoordinationUnitImpl>();
+  auto frame3_cu = CreateCoordinationUnit<FrameCoordinationUnitImpl>();
+
+  frame1_cu->AddChildFrame(frame2_cu->id());
+  frame1_cu->AddChildFrame(frame3_cu->id());
+  EXPECT_EQ(nullptr, frame1_cu->GetParentFrameCoordinationUnit());
+  EXPECT_EQ(2u, frame1_cu->child_frame_coordination_units_for_testing().size());
+  EXPECT_EQ(frame1_cu.get(), frame2_cu->GetParentFrameCoordinationUnit());
+  EXPECT_EQ(frame1_cu.get(), frame3_cu->GetParentFrameCoordinationUnit());
+}
+
+TEST_F(FrameCoordinationUnitImplDeathTest, AddChildFrameOnCyclicReference) {
+  ::testing::FLAGS_gtest_death_test_style = "threadsafe";
+
+  auto frame1_cu = CreateCoordinationUnit<FrameCoordinationUnitImpl>();
+  auto frame2_cu = CreateCoordinationUnit<FrameCoordinationUnitImpl>();
+  auto frame3_cu = CreateCoordinationUnit<FrameCoordinationUnitImpl>();
+
+  frame1_cu->AddChildFrame(frame2_cu->id());
+  frame2_cu->AddChildFrame(frame3_cu->id());
+// |frame3_cu| can't add |frame1_cu| because |frame1_cu| is an ancestor of
+// |frame3_cu|, and this will hit a DCHECK because of cyclic reference.
+#if !defined(NDEBUG) || defined(DCHECK_ALWAYS_ON)
+  EXPECT_DEATH_IF_SUPPORTED(frame3_cu->AddChildFrame(frame1_cu->id()), "");
+#else
+  frame3_cu->AddChildFrame(frame1_cu->id());
+#endif  // !defined(NDEBUG) || defined(DCHECK_ALWAYS_ON)
+
+  EXPECT_EQ(1u, frame1_cu->child_frame_coordination_units_for_testing().count(
+                    frame2_cu.get()));
+  EXPECT_EQ(1u, frame2_cu->child_frame_coordination_units_for_testing().count(
+                    frame3_cu.get()));
+  // |frame1_cu| was not added successfully because |frame1_cu| is one of the
+  // ancestors of |frame3_cu|.
+  EXPECT_EQ(0u, frame3_cu->child_frame_coordination_units_for_testing().count(
+                    frame1_cu.get()));
+}
+
+TEST_F(FrameCoordinationUnitImplTest, RemoveChildFrame) {
+  auto parent_frame_cu = CreateCoordinationUnit<FrameCoordinationUnitImpl>();
+  auto child_frame_cu = CreateCoordinationUnit<FrameCoordinationUnitImpl>();
+
+  // Parent-child relationships have not been established yet.
+  EXPECT_EQ(
+      0u, parent_frame_cu->child_frame_coordination_units_for_testing().size());
+  EXPECT_TRUE(!parent_frame_cu->GetParentFrameCoordinationUnit());
+  EXPECT_EQ(
+      0u, child_frame_cu->child_frame_coordination_units_for_testing().size());
+  EXPECT_TRUE(!child_frame_cu->GetParentFrameCoordinationUnit());
+
+  parent_frame_cu->AddChildFrame(child_frame_cu->id());
+
+  // Ensure correct Parent-child relationships have been established.
+  EXPECT_EQ(
+      1u, parent_frame_cu->child_frame_coordination_units_for_testing().size());
+  EXPECT_TRUE(!parent_frame_cu->GetParentFrameCoordinationUnit());
+  EXPECT_EQ(
+      0u, child_frame_cu->child_frame_coordination_units_for_testing().size());
+  EXPECT_EQ(parent_frame_cu.get(),
+            child_frame_cu->GetParentFrameCoordinationUnit());
+
+  parent_frame_cu->RemoveChildFrame(child_frame_cu->id());
+
+  // Parent-child relationships should no longer exist.
+  EXPECT_EQ(
+      0u, parent_frame_cu->child_frame_coordination_units_for_testing().size());
+  EXPECT_TRUE(!parent_frame_cu->GetParentFrameCoordinationUnit());
+  EXPECT_EQ(
+      0u, child_frame_cu->child_frame_coordination_units_for_testing().size());
+  EXPECT_TRUE(!child_frame_cu->GetParentFrameCoordinationUnit());
+}
+
+int64_t GetLifecycleState(PageCoordinationUnitImpl* cu) {
+  int64_t value;
+  if (cu->GetProperty(mojom::PropertyType::kLifecycleState, &value))
+    return value;
+  // Initial state is running.
+  return static_cast<int64_t>(mojom::LifecycleState::kRunning);
+}
+
+#define EXPECT_FROZEN(cu)                                         \
+  EXPECT_EQ(static_cast<int64_t>(mojom::LifecycleState::kFrozen), \
+            GetLifecycleState(cu.get()))
+#define EXPECT_RUNNING(cu)                                         \
+  EXPECT_EQ(static_cast<int64_t>(mojom::LifecycleState::kRunning), \
+            GetLifecycleState(cu.get()))
+
+TEST_F(FrameCoordinationUnitImplTest, LifecycleStatesTransitions) {
+  MockMultiplePagesWithMultipleProcessesCoordinationUnitGraph cu_graph(
+      coordination_unit_graph());
+  // Verifying the model.
+  ASSERT_TRUE(cu_graph.frame->IsMainFrame());
+  ASSERT_TRUE(cu_graph.other_frame->IsMainFrame());
+  ASSERT_FALSE(cu_graph.child_frame->IsMainFrame());
+  ASSERT_EQ(cu_graph.child_frame->GetParentFrameCoordinationUnit(),
+            cu_graph.other_frame.get());
+  ASSERT_EQ(cu_graph.frame->GetPageCoordinationUnit(), cu_graph.page.get());
+  ASSERT_EQ(cu_graph.other_frame->GetPageCoordinationUnit(),
+            cu_graph.other_page.get());
+
+  // Freezing a child frame should not affect the page state.
+  cu_graph.child_frame->SetLifecycleState(mojom::LifecycleState::kFrozen);
+  EXPECT_RUNNING(cu_graph.page);
+  EXPECT_RUNNING(cu_graph.other_page);
+
+  // Freezing the only frame in a page should freeze that page.
+  cu_graph.frame->SetLifecycleState(mojom::LifecycleState::kFrozen);
+  EXPECT_FROZEN(cu_graph.page);
+  EXPECT_RUNNING(cu_graph.other_page);
+
+  // Unfreeze the child frame in the other page.
+  cu_graph.child_frame->SetLifecycleState(mojom::LifecycleState::kRunning);
+  EXPECT_FROZEN(cu_graph.page);
+  EXPECT_RUNNING(cu_graph.other_page);
+
+  // Freezing the main frame in the other page should not alter that pages
+  // state, as there is still a child frame that is running.
+  cu_graph.other_frame->SetLifecycleState(mojom::LifecycleState::kFrozen);
+  EXPECT_FROZEN(cu_graph.page);
+  EXPECT_RUNNING(cu_graph.other_page);
+
+  // Refreezing the child frame should freeze the page.
+  cu_graph.child_frame->SetLifecycleState(mojom::LifecycleState::kFrozen);
+  EXPECT_FROZEN(cu_graph.page);
+  EXPECT_FROZEN(cu_graph.other_page);
+
+  // Unfreezing a main frame should unfreeze the associated page.
+  cu_graph.frame->SetLifecycleState(mojom::LifecycleState::kRunning);
+  EXPECT_RUNNING(cu_graph.page);
+  EXPECT_FROZEN(cu_graph.other_page);
+
+  // Unfreezing the child frame should unfreeze the associated page.
+  cu_graph.child_frame->SetLifecycleState(mojom::LifecycleState::kRunning);
+  EXPECT_RUNNING(cu_graph.page);
+  EXPECT_RUNNING(cu_graph.other_page);
+
+  // Unfreezing the main frame shouldn't change anything.
+  cu_graph.other_frame->SetLifecycleState(mojom::LifecycleState::kRunning);
+  EXPECT_RUNNING(cu_graph.page);
+  EXPECT_RUNNING(cu_graph.other_page);
+}
+
+}  // namespace resource_coordinator
diff -BbuN a/services/resource_coordinator/coordination_unit/mock_coordination_unit_graphs.cc b/services/resource_coordinator/coordination_unit/mock_coordination_unit_graphs.cc
--- a/services/resource_coordinator/coordination_unit/mock_coordination_unit_graphs.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/services/resource_coordinator/coordination_unit/mock_coordination_unit_graphs.cc	2019-05-17 18:53:37.956000000 +0300
@@ -0,0 +1,100 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "services/resource_coordinator/coordination_unit/mock_coordination_unit_graphs.h"
+
+#include <string>
+
+#include "services/resource_coordinator/coordination_unit/coordination_unit_base.h"
+#include "services/resource_coordinator/coordination_unit/frame_coordination_unit_impl.h"
+#include "services/resource_coordinator/coordination_unit/page_coordination_unit_impl.h"
+#include "services/resource_coordinator/coordination_unit/process_coordination_unit_impl.h"
+#include "services/resource_coordinator/coordination_unit/system_coordination_unit_impl.h"
+#include "services/resource_coordinator/public/cpp/coordination_unit_id.h"
+#include "services/resource_coordinator/public/cpp/coordination_unit_types.h"
+
+namespace resource_coordinator {
+
+MockSinglePageInSingleProcessCoordinationUnitGraph::
+    MockSinglePageInSingleProcessCoordinationUnitGraph(
+        CoordinationUnitGraph* graph)
+    : system(TestCoordinationUnitWrapper<SystemCoordinationUnitImpl>::Create(
+          graph)),
+      frame(TestCoordinationUnitWrapper<FrameCoordinationUnitImpl>::Create(
+          graph)),
+      process(TestCoordinationUnitWrapper<ProcessCoordinationUnitImpl>::Create(
+          graph)),
+      page(TestCoordinationUnitWrapper<PageCoordinationUnitImpl>::Create(
+          graph)) {
+  frame->SetAllInterventionPoliciesForTesting(
+      mojom::InterventionPolicy::kDefault);
+  page->AddFrame(frame->id());
+  frame->SetProcess(process->id());
+  process->SetPID(1);
+}
+
+MockSinglePageInSingleProcessCoordinationUnitGraph::
+    ~MockSinglePageInSingleProcessCoordinationUnitGraph() = default;
+
+MockMultiplePagesInSingleProcessCoordinationUnitGraph::
+    MockMultiplePagesInSingleProcessCoordinationUnitGraph(
+        CoordinationUnitGraph* graph)
+    : MockSinglePageInSingleProcessCoordinationUnitGraph(graph),
+      other_frame(
+          TestCoordinationUnitWrapper<FrameCoordinationUnitImpl>::Create(
+              graph)),
+      other_page(TestCoordinationUnitWrapper<PageCoordinationUnitImpl>::Create(
+          graph)) {
+  other_frame->SetAllInterventionPoliciesForTesting(
+      mojom::InterventionPolicy::kDefault);
+  other_page->AddFrame(other_frame->id());
+  other_frame->SetProcess(process->id());
+}
+
+MockMultiplePagesInSingleProcessCoordinationUnitGraph::
+    ~MockMultiplePagesInSingleProcessCoordinationUnitGraph() = default;
+
+MockSinglePageWithMultipleProcessesCoordinationUnitGraph::
+    MockSinglePageWithMultipleProcessesCoordinationUnitGraph(
+        CoordinationUnitGraph* graph)
+    : MockSinglePageInSingleProcessCoordinationUnitGraph(graph),
+      child_frame(
+          TestCoordinationUnitWrapper<FrameCoordinationUnitImpl>::Create(
+              graph)),
+      other_process(
+          TestCoordinationUnitWrapper<ProcessCoordinationUnitImpl>::Create(
+              graph)) {
+  child_frame->SetAllInterventionPoliciesForTesting(
+      mojom::InterventionPolicy::kDefault);
+  frame->AddChildFrame(child_frame->id());
+  page->AddFrame(child_frame->id());
+  child_frame->SetProcess(other_process->id());
+  other_process->SetPID(2);
+}
+
+MockSinglePageWithMultipleProcessesCoordinationUnitGraph::
+    ~MockSinglePageWithMultipleProcessesCoordinationUnitGraph() = default;
+
+MockMultiplePagesWithMultipleProcessesCoordinationUnitGraph::
+    MockMultiplePagesWithMultipleProcessesCoordinationUnitGraph(
+        CoordinationUnitGraph* graph)
+    : MockMultiplePagesInSingleProcessCoordinationUnitGraph(graph),
+      child_frame(
+          TestCoordinationUnitWrapper<FrameCoordinationUnitImpl>::Create(
+              graph)),
+      other_process(
+          TestCoordinationUnitWrapper<ProcessCoordinationUnitImpl>::Create(
+              graph)) {
+  child_frame->SetAllInterventionPoliciesForTesting(
+      mojom::InterventionPolicy::kDefault);
+  other_frame->AddChildFrame(child_frame->id());
+  other_page->AddFrame(child_frame->id());
+  child_frame->SetProcess(other_process->id());
+  other_process->SetPID(2);
+}
+
+MockMultiplePagesWithMultipleProcessesCoordinationUnitGraph::
+    ~MockMultiplePagesWithMultipleProcessesCoordinationUnitGraph() = default;
+
+}  // namespace resource_coordinator
diff -BbuN a/services/resource_coordinator/coordination_unit/mock_coordination_unit_graphs.h b/services/resource_coordinator/coordination_unit/mock_coordination_unit_graphs.h
--- a/services/resource_coordinator/coordination_unit/mock_coordination_unit_graphs.h	1970-01-01 03:00:00.000000000 +0300
+++ b/services/resource_coordinator/coordination_unit/mock_coordination_unit_graphs.h	2019-05-17 18:53:37.956000000 +0300
@@ -0,0 +1,115 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef SERVICES_RESOURCE_COORDINATOR_COORDINATION_UNIT_MOCK_COORDINATION_UNIT_GRAPHS_H_
+#define SERVICES_RESOURCE_COORDINATOR_COORDINATION_UNIT_MOCK_COORDINATION_UNIT_GRAPHS_H_
+
+#include "services/resource_coordinator/coordination_unit/coordination_unit_test_harness.h"
+
+namespace resource_coordinator {
+
+class CoordinationUnitGraph;
+class FrameCoordinationUnitImpl;
+class PageCoordinationUnitImpl;
+class ProcessCoordinationUnitImpl;
+class SystemCoordinationUnitImpl;
+
+// The following coordination unit graph topology is created to emulate a
+// scenario when a single page executes in a single process:
+//
+// Pr  Pg
+//  \ /
+//   F
+//
+// Where:
+// F: frame
+// Pr: process(pid:1)
+// Pg: page
+struct MockSinglePageInSingleProcessCoordinationUnitGraph {
+  MockSinglePageInSingleProcessCoordinationUnitGraph(
+      CoordinationUnitGraph* graph);
+  ~MockSinglePageInSingleProcessCoordinationUnitGraph();
+  TestCoordinationUnitWrapper<SystemCoordinationUnitImpl> system;
+  TestCoordinationUnitWrapper<FrameCoordinationUnitImpl> frame;
+  TestCoordinationUnitWrapper<ProcessCoordinationUnitImpl> process;
+  TestCoordinationUnitWrapper<PageCoordinationUnitImpl> page;
+};
+
+// The following coordination unit graph topology is created to emulate a
+// scenario where multiple pages are executing in a single process:
+//
+// Pg  Pr OPg
+//  \ / \ /
+//   F  OF
+//
+// Where:
+// F: frame
+// OF: other_frame
+// Pg: page
+// OPg: other_page
+// Pr: process(pid:1)
+struct MockMultiplePagesInSingleProcessCoordinationUnitGraph
+    : public MockSinglePageInSingleProcessCoordinationUnitGraph {
+  MockMultiplePagesInSingleProcessCoordinationUnitGraph(
+      CoordinationUnitGraph* graph);
+  ~MockMultiplePagesInSingleProcessCoordinationUnitGraph();
+  TestCoordinationUnitWrapper<FrameCoordinationUnitImpl> other_frame;
+  TestCoordinationUnitWrapper<PageCoordinationUnitImpl> other_page;
+};
+
+// The following coordination unit graph topology is created to emulate a
+// scenario where a single page that has frames is executing in different
+// processes (e.g. out-of-process iFrames):
+//
+// Pg  Pr
+// |\ /
+// | F  OPr
+// |  \ /
+// |__CF
+//
+// Where:
+// F: frame
+// CF: child_frame
+// Pg: page
+// Pr: process(pid:1)
+// OPr: other_process(pid:2)
+struct MockSinglePageWithMultipleProcessesCoordinationUnitGraph
+    : public MockSinglePageInSingleProcessCoordinationUnitGraph {
+  MockSinglePageWithMultipleProcessesCoordinationUnitGraph(
+      CoordinationUnitGraph* graph);
+  ~MockSinglePageWithMultipleProcessesCoordinationUnitGraph();
+  TestCoordinationUnitWrapper<FrameCoordinationUnitImpl> child_frame;
+  TestCoordinationUnitWrapper<ProcessCoordinationUnitImpl> other_process;
+};
+
+// The following coordination unit graph topology is created to emulate a
+// scenario where multiple pages are utilizing multiple processes (e.g.
+// out-of-process iFrames and multiple pages in a process):
+//
+// Pg  Pr OPg___
+//  \ / \ /     |
+//   F   OF OPr |
+//        \ /   |
+//         CF___|
+//
+// Where:
+// F: frame
+// OF: other_frame
+// CF: another_frame
+// Pg: page
+// OPg: other_page
+// Pr: process(pid:1)
+// OPr: other_process(pid:2)
+struct MockMultiplePagesWithMultipleProcessesCoordinationUnitGraph
+    : public MockMultiplePagesInSingleProcessCoordinationUnitGraph {
+  MockMultiplePagesWithMultipleProcessesCoordinationUnitGraph(
+      CoordinationUnitGraph* graph);
+  ~MockMultiplePagesWithMultipleProcessesCoordinationUnitGraph();
+  TestCoordinationUnitWrapper<FrameCoordinationUnitImpl> child_frame;
+  TestCoordinationUnitWrapper<ProcessCoordinationUnitImpl> other_process;
+};
+
+}  // namespace resource_coordinator
+
+#endif  // SERVICES_RESOURCE_COORDINATOR_COORDINATION_UNIT_MOCK_COORDINATION_UNIT_GRAPHS_H_
diff -BbuN a/services/resource_coordinator/coordination_unit/page_coordination_unit_impl.cc b/services/resource_coordinator/coordination_unit/page_coordination_unit_impl.cc
--- a/services/resource_coordinator/coordination_unit/page_coordination_unit_impl.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/services/resource_coordinator/coordination_unit/page_coordination_unit_impl.cc	2019-05-17 18:53:37.956000000 +0300
@@ -0,0 +1,364 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "services/resource_coordinator/coordination_unit/page_coordination_unit_impl.h"
+
+#include "base/logging.h"
+#include "base/time/default_tick_clock.h"
+#include "services/resource_coordinator/coordination_unit/frame_coordination_unit_impl.h"
+#include "services/resource_coordinator/coordination_unit/process_coordination_unit_impl.h"
+#include "services/resource_coordinator/observers/coordination_unit_graph_observer.h"
+#include "services/resource_coordinator/resource_coordinator_clock.h"
+
+namespace resource_coordinator {
+
+namespace {
+
+constexpr size_t kMaxInterventionIndex =
+    static_cast<size_t>(mojom::PolicyControlledIntervention::kMaxValue);
+
+size_t ToIndex(mojom::PolicyControlledIntervention intervention) {
+  const size_t kIndex = static_cast<size_t>(intervention);
+  DCHECK(kIndex <= kMaxInterventionIndex);
+  return kIndex;
+}
+
+}  // namespace
+
+PageCoordinationUnitImpl::PageCoordinationUnitImpl(
+    const CoordinationUnitID& id,
+    CoordinationUnitGraph* graph,
+    std::unique_ptr<service_manager::ServiceKeepaliveRef> keepalive_ref)
+    : CoordinationUnitInterface(id, graph, std::move(keepalive_ref)) {
+  InvalidateAllInterventionPolicies();
+}
+
+PageCoordinationUnitImpl::~PageCoordinationUnitImpl() {
+  for (auto* child_frame : frame_coordination_units_)
+    child_frame->RemovePageCoordinationUnit(this);
+}
+
+void PageCoordinationUnitImpl::AddFrame(const CoordinationUnitID& cu_id) {
+  DCHECK(cu_id.type == CoordinationUnitType::kFrame);
+  FrameCoordinationUnitImpl* frame_cu =
+      FrameCoordinationUnitImpl::GetCoordinationUnitByID(graph_, cu_id);
+  if (!frame_cu)
+    return;
+  if (AddFrame(frame_cu))
+    frame_cu->AddPageCoordinationUnit(this);
+}
+
+void PageCoordinationUnitImpl::RemoveFrame(const CoordinationUnitID& cu_id) {
+  DCHECK(cu_id != id());
+  FrameCoordinationUnitImpl* frame_cu =
+      FrameCoordinationUnitImpl::GetCoordinationUnitByID(graph_, cu_id);
+  if (!frame_cu)
+    return;
+  if (RemoveFrame(frame_cu))
+    frame_cu->RemovePageCoordinationUnit(this);
+}
+
+void PageCoordinationUnitImpl::SetIsLoading(bool is_loading) {
+  SetProperty(mojom::PropertyType::kIsLoading, is_loading);
+}
+
+void PageCoordinationUnitImpl::SetVisibility(bool visible) {
+  SetProperty(mojom::PropertyType::kVisible, visible);
+}
+
+void PageCoordinationUnitImpl::SetUKMSourceId(int64_t ukm_source_id) {
+  SetProperty(mojom::PropertyType::kUKMSourceId, ukm_source_id);
+}
+
+void PageCoordinationUnitImpl::OnFaviconUpdated() {
+  SendEvent(mojom::Event::kFaviconUpdated);
+}
+
+void PageCoordinationUnitImpl::OnTitleUpdated() {
+  SendEvent(mojom::Event::kTitleUpdated);
+}
+
+void PageCoordinationUnitImpl::OnMainFrameNavigationCommitted(
+    base::TimeTicks navigation_committed_time,
+    int64_t navigation_id,
+    const std::string& url) {
+  navigation_committed_time_ = navigation_committed_time;
+  main_frame_url_ = url;
+  navigation_id_ = navigation_id;
+  SendEvent(mojom::Event::kNavigationCommitted);
+}
+
+std::set<ProcessCoordinationUnitImpl*>
+PageCoordinationUnitImpl::GetAssociatedProcessCoordinationUnits() const {
+  std::set<ProcessCoordinationUnitImpl*> process_cus;
+
+  for (auto* frame_cu : frame_coordination_units_) {
+    if (auto* process_cu = frame_cu->GetProcessCoordinationUnit()) {
+      process_cus.insert(process_cu);
+    }
+  }
+  return process_cus;
+}
+
+bool PageCoordinationUnitImpl::IsVisible() const {
+  int64_t is_visible = 0;
+  bool has_property = GetProperty(mojom::PropertyType::kVisible, &is_visible);
+  DCHECK(has_property && (is_visible == 0 || is_visible == 1));
+  return is_visible;
+}
+
+double PageCoordinationUnitImpl::GetCPUUsage() const {
+  double cpu_usage = 0.0;
+
+  for (auto* process_cu : GetAssociatedProcessCoordinationUnits()) {
+    size_t pages_in_process =
+        process_cu->GetAssociatedPageCoordinationUnits().size();
+    DCHECK_LE(1u, pages_in_process);
+
+    int64_t process_cpu_usage = 0;
+    if (process_cu->GetProperty(mojom::PropertyType::kCPUUsage,
+                                &process_cpu_usage)) {
+      cpu_usage += static_cast<double>(process_cpu_usage) / pages_in_process;
+    }
+  }
+
+  return cpu_usage / 1000;
+}
+
+bool PageCoordinationUnitImpl::GetExpectedTaskQueueingDuration(
+    int64_t* output) {
+  // Calculate the EQT for the process of the main frame only because
+  // the smoothness of the main frame may affect the users the most.
+  FrameCoordinationUnitImpl* main_frame_cu = GetMainFrameCoordinationUnit();
+  if (!main_frame_cu)
+    return false;
+  auto* process_cu = main_frame_cu->GetProcessCoordinationUnit();
+  if (!process_cu)
+    return false;
+  return process_cu->GetProperty(
+      mojom::PropertyType::kExpectedTaskQueueingDuration, output);
+}
+
+base::TimeDelta PageCoordinationUnitImpl::TimeSinceLastNavigation() const {
+  if (navigation_committed_time_.is_null())
+    return base::TimeDelta();
+  return ResourceCoordinatorClock::NowTicks() - navigation_committed_time_;
+}
+
+base::TimeDelta PageCoordinationUnitImpl::TimeSinceLastVisibilityChange()
+    const {
+  return ResourceCoordinatorClock::NowTicks() - visibility_change_time_;
+}
+
+FrameCoordinationUnitImpl*
+PageCoordinationUnitImpl::GetMainFrameCoordinationUnit() const {
+  for (auto* frame_cu : frame_coordination_units_) {
+    if (frame_cu->IsMainFrame())
+      return frame_cu;
+  }
+  return nullptr;
+}
+
+void PageCoordinationUnitImpl::OnFrameLifecycleStateChanged(
+    FrameCoordinationUnitImpl* frame_cu,
+    mojom::LifecycleState old_state) {
+  DCHECK(base::ContainsKey(frame_coordination_units_, frame_cu));
+  DCHECK_NE(old_state, frame_cu->lifecycle_state());
+
+  int delta = 0;
+  if (old_state == mojom::LifecycleState::kFrozen)
+    delta = -1;
+  else if (frame_cu->lifecycle_state() == mojom::LifecycleState::kFrozen)
+    delta = 1;
+  if (delta != 0)
+    OnNumFrozenFramesStateChange(delta);
+}
+
+void PageCoordinationUnitImpl::OnFrameInterventionPolicyChanged(
+    FrameCoordinationUnitImpl* frame,
+    mojom::PolicyControlledIntervention intervention,
+    mojom::InterventionPolicy old_policy,
+    mojom::InterventionPolicy new_policy) {
+  const size_t kIndex = ToIndex(intervention);
+
+  // Invalidate the local policy aggregation for this intervention. It will be
+  // recomputed on the next query to GetInterventionPolicy.
+  intervention_policy_[kIndex] = mojom::InterventionPolicy::kUnknown;
+
+  // The first time a frame transitions away from kUnknown for the last policy,
+  // then that frame is considered to have checked in. Frames always provide
+  // initial policy values in order, ensuring this works.
+  if (old_policy == mojom::InterventionPolicy::kUnknown &&
+      new_policy != mojom::InterventionPolicy::kUnknown &&
+      intervention == mojom::PolicyControlledIntervention::kMaxValue) {
+    ++intervention_policy_frames_reported_;
+    DCHECK_LE(intervention_policy_frames_reported_,
+              frame_coordination_units_.size());
+  }
+}
+
+mojom::InterventionPolicy PageCoordinationUnitImpl::GetInterventionPolicy(
+    mojom::PolicyControlledIntervention intervention) {
+  // If there are no frames, or they've not all reported, then return kUnknown.
+  if (frame_coordination_units_.empty() ||
+      intervention_policy_frames_reported_ !=
+          frame_coordination_units_.size()) {
+    return mojom::InterventionPolicy::kUnknown;
+  }
+
+  // Recompute the policy if it is currently invalid.
+  const size_t kIndex = ToIndex(intervention);
+  DCHECK_LE(kIndex, kMaxInterventionIndex);
+  if (intervention_policy_[kIndex] == mojom::InterventionPolicy::kUnknown) {
+    RecomputeInterventionPolicy(intervention);
+    DCHECK_NE(mojom::InterventionPolicy::kUnknown,
+              intervention_policy_[kIndex]);
+  }
+
+  return intervention_policy_[kIndex];
+}
+
+void PageCoordinationUnitImpl::OnEventReceived(mojom::Event event) {
+  for (auto& observer : observers())
+    observer.OnPageEventReceived(this, event);
+}
+
+void PageCoordinationUnitImpl::OnPropertyChanged(
+    const mojom::PropertyType property_type,
+    int64_t value) {
+  if (property_type == mojom::PropertyType::kVisible)
+    visibility_change_time_ = ResourceCoordinatorClock::NowTicks();
+  for (auto& observer : observers())
+    observer.OnPagePropertyChanged(this, property_type, value);
+}
+
+bool PageCoordinationUnitImpl::AddFrame(FrameCoordinationUnitImpl* frame_cu) {
+  const bool inserted = frame_coordination_units_.insert(frame_cu).second;
+  if (inserted) {
+    OnNumFrozenFramesStateChange(
+        frame_cu->lifecycle_state() == mojom::LifecycleState::kFrozen ? 1 : 0);
+    MaybeInvalidateInterventionPolicies(frame_cu, true /* adding_frame */);
+  }
+  return inserted;
+}
+
+bool PageCoordinationUnitImpl::RemoveFrame(
+    FrameCoordinationUnitImpl* frame_cu) {
+  bool removed = frame_coordination_units_.erase(frame_cu) > 0;
+  if (removed) {
+    OnNumFrozenFramesStateChange(
+        frame_cu->lifecycle_state() == mojom::LifecycleState::kFrozen ? -1 : 0);
+    MaybeInvalidateInterventionPolicies(frame_cu, false /* adding_frame */);
+  }
+
+  return removed;
+}
+
+void PageCoordinationUnitImpl::OnNumFrozenFramesStateChange(
+    int num_frozen_frames_delta) {
+  num_frozen_frames_ += num_frozen_frames_delta;
+  DCHECK_LE(num_frozen_frames_, frame_coordination_units_.size());
+
+  const int64_t kRunning =
+      static_cast<int64_t>(mojom::LifecycleState::kRunning);
+  const int64_t kFrozen = static_cast<int64_t>(mojom::LifecycleState::kFrozen);
+
+  // We are interested in knowing when we have transitioned to or from
+  // "fully frozen". A page with no frames is considered to be running by
+  // default.
+  bool was_fully_frozen =
+      GetPropertyOrDefault(mojom::PropertyType::kLifecycleState, kRunning) ==
+      kFrozen;
+  bool is_fully_frozen = frame_coordination_units_.size() > 0 &&
+                         num_frozen_frames_ == frame_coordination_units_.size();
+  if (was_fully_frozen == is_fully_frozen)
+    return;
+
+  if (is_fully_frozen) {
+    // Aggregate the beforeunload handler information from the entire frame
+    // tree.
+    bool has_nonempty_beforeunload = false;
+    for (auto* frame : frame_coordination_units_) {
+      if (frame->has_nonempty_beforeunload()) {
+        has_nonempty_beforeunload = true;
+        break;
+      }
+    }
+    set_has_nonempty_beforeunload(has_nonempty_beforeunload);
+  }
+
+  // TODO(fdoray): Store the lifecycle state as a member on the
+  // PageCoordinationUnit rather than as a non-typed property.
+  SetProperty(mojom::PropertyType::kLifecycleState,
+              is_fully_frozen ? kFrozen : kRunning);
+}
+
+void PageCoordinationUnitImpl::InvalidateAllInterventionPolicies() {
+  for (size_t i = 0; i <= kMaxInterventionIndex; ++i)
+    intervention_policy_[i] = mojom::InterventionPolicy::kUnknown;
+}
+
+void PageCoordinationUnitImpl::MaybeInvalidateInterventionPolicies(
+    FrameCoordinationUnitImpl* frame_cu,
+    bool adding_frame) {
+  // Ensure that the frame was already added or removed as expected.
+  DCHECK(adding_frame == frame_coordination_units_.count(frame_cu));
+
+  // Determine whether or not the frames had all reported prior to this change.
+  const size_t prior_frame_count =
+      frame_coordination_units_.size() + (adding_frame ? -1 : 1);
+  const bool frames_all_reported_prior =
+      prior_frame_count > 0 &&
+      intervention_policy_frames_reported_ == prior_frame_count;
+
+  // If the previous state was considered fully reported, then aggregation may
+  // have occurred. Adding or removing a frame (even one that is fully reported)
+  // needs to invalidate that aggregation. Invalidation could happen on every
+  // single frame addition and removal, but only doing this when the previous
+  // state was fully reported reduces unnecessary invalidations.
+  if (frames_all_reported_prior)
+    InvalidateAllInterventionPolicies();
+
+  // Update the reporting frame count.
+  const bool frame_reported = frame_cu->AreAllInterventionPoliciesSet();
+  if (frame_reported)
+    intervention_policy_frames_reported_ += adding_frame ? 1 : -1;
+
+  DCHECK_LE(intervention_policy_frames_reported_,
+            frame_coordination_units_.size());
+}
+
+void PageCoordinationUnitImpl::RecomputeInterventionPolicy(
+    mojom::PolicyControlledIntervention intervention) {
+  const size_t kIndex = ToIndex(intervention);
+
+  // This should never be called with an empty frame tree.
+  DCHECK(!frame_coordination_units_.empty());
+
+  mojom::InterventionPolicy policy = mojom::InterventionPolicy::kDefault;
+  for (auto* frame : frame_coordination_units_) {
+    // No frame should have an unknown policy, as aggregation should only be
+    // invoked after all frames have checked in.
+    DCHECK_NE(mojom::InterventionPolicy::kUnknown,
+              frame->intervention_policy_[kIndex]);
+
+    // If any frame opts out then the whole frame tree opts out, even if other
+    // frames have opted in.
+    if (frame->intervention_policy_[kIndex] ==
+        mojom::InterventionPolicy::kOptOut) {
+      intervention_policy_[kIndex] = mojom::InterventionPolicy::kOptOut;
+      return;
+    }
+
+    // If any frame opts in and none opt out, then the whole tree opts in.
+    if (frame->intervention_policy_[kIndex] ==
+        mojom::InterventionPolicy::kOptIn) {
+      policy = mojom::InterventionPolicy::kOptIn;
+    }
+  }
+
+  intervention_policy_[kIndex] = policy;
+}
+
+}  // namespace resource_coordinator
diff -BbuN a/services/resource_coordinator/coordination_unit/page_coordination_unit_impl.h b/services/resource_coordinator/coordination_unit/page_coordination_unit_impl.h
--- a/services/resource_coordinator/coordination_unit/page_coordination_unit_impl.h	1970-01-01 03:00:00.000000000 +0300
+++ b/services/resource_coordinator/coordination_unit/page_coordination_unit_impl.h	2019-05-17 18:53:37.956000000 +0300
@@ -0,0 +1,209 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef SERVICES_RESOURCE_COORDINATOR_COORDINATION_UNIT_PAGE_COORDINATION_UNIT_IMPL_H_
+#define SERVICES_RESOURCE_COORDINATOR_COORDINATION_UNIT_PAGE_COORDINATION_UNIT_IMPL_H_
+
+#include "base/macros.h"
+#include "base/time/time.h"
+#include "services/resource_coordinator/coordination_unit/coordination_unit_base.h"
+
+namespace resource_coordinator {
+
+class FrameCoordinationUnitImpl;
+class ProcessCoordinationUnitImpl;
+
+class PageCoordinationUnitImpl
+    : public CoordinationUnitInterface<PageCoordinationUnitImpl,
+                                       mojom::PageCoordinationUnit,
+                                       mojom::PageCoordinationUnitRequest> {
+ public:
+  static CoordinationUnitType Type() { return CoordinationUnitType::kPage; }
+
+  PageCoordinationUnitImpl(
+      const CoordinationUnitID& id,
+      CoordinationUnitGraph* graph,
+      std::unique_ptr<service_manager::ServiceKeepaliveRef> keepalive_ref);
+  ~PageCoordinationUnitImpl() override;
+
+  // mojom::PageCoordinationUnit implementation.
+  void AddFrame(const CoordinationUnitID& cu_id) override;
+  void RemoveFrame(const CoordinationUnitID& cu_id) override;
+  void SetIsLoading(bool is_loading) override;
+  void SetVisibility(bool visible) override;
+  void SetUKMSourceId(int64_t ukm_source_id) override;
+  void OnFaviconUpdated() override;
+  void OnTitleUpdated() override;
+  void OnMainFrameNavigationCommitted(base::TimeTicks navigation_committed_time,
+                                      int64_t navigation_id,
+                                      const std::string& url) override;
+
+  // There is no direct relationship between processes and pages. However,
+  // frames are accessible by both processes and frames, so we find all of the
+  // processes that are reachable from the pages's accessible frames.
+  std::set<ProcessCoordinationUnitImpl*> GetAssociatedProcessCoordinationUnits()
+      const;
+  bool IsVisible() const;
+  double GetCPUUsage() const;
+
+  // Returns false if can't get an expected task queueing duration successfully.
+  bool GetExpectedTaskQueueingDuration(int64_t* duration);
+
+  // Returns 0 if no navigation has happened, otherwise returns the time since
+  // the last navigation commit.
+  base::TimeDelta TimeSinceLastNavigation() const;
+
+  // Returns the time since the last visibility change, it should always have a
+  // value since we set the visibility property when we create a
+  // PageCoordinationUnit.
+  base::TimeDelta TimeSinceLastVisibilityChange() const;
+
+  const std::set<FrameCoordinationUnitImpl*>& GetFrameCoordinationUnits()
+      const {
+    return frame_coordination_units_;
+  }
+
+  // Returns the main frame CU or nullptr if this page has no main frame.
+  FrameCoordinationUnitImpl* GetMainFrameCoordinationUnit() const;
+
+  // Accessors.
+  base::TimeTicks usage_estimate_time() const { return usage_estimate_time_; }
+  void set_usage_estimate_time(base::TimeTicks usage_estimate_time) {
+    usage_estimate_time_ = usage_estimate_time;
+  }
+  base::TimeDelta cumulative_cpu_usage_estimate() const {
+    return cumulative_cpu_usage_estimate_;
+  }
+  void set_cumulative_cpu_usage_estimate(
+      base::TimeDelta cumulative_cpu_usage_estimate) {
+    cumulative_cpu_usage_estimate_ = cumulative_cpu_usage_estimate;
+  }
+  uint64_t private_footprint_kb_estimate() const {
+    return private_footprint_kb_estimate_;
+  }
+  void set_private_footprint_kb_estimate(
+      uint64_t private_footprint_kb_estimate) {
+    private_footprint_kb_estimate_ = private_footprint_kb_estimate;
+  }
+  void set_has_nonempty_beforeunload(bool has_nonempty_beforeunload) {
+    has_nonempty_beforeunload_ = has_nonempty_beforeunload;
+  }
+
+  const std::string& main_frame_url() const { return main_frame_url_; }
+  int64_t navigation_id() const { return navigation_id_; }
+
+  // Invoked when the state of a frame in this page changes.
+  void OnFrameLifecycleStateChanged(FrameCoordinationUnitImpl* frame_cu,
+                                    mojom::LifecycleState old_state);
+
+  void OnFrameInterventionPolicyChanged(
+      FrameCoordinationUnitImpl* frame,
+      mojom::PolicyControlledIntervention intervention,
+      mojom::InterventionPolicy old_policy,
+      mojom::InterventionPolicy new_policy);
+
+  // Gets the current policy for the specified |intervention|, recomputing it
+  // from individual frame policies if necessary. Returns kUnknown until there
+  // are 1 or more frames, and they have all computed their local policy
+  // settings.
+  mojom::InterventionPolicy GetInterventionPolicy(
+      mojom::PolicyControlledIntervention intervention);
+
+  // Similar to GetInterventionPolicy, but doesn't trigger recomputes.
+  mojom::InterventionPolicy GetRawInterventionPolicyForTesting(
+      mojom::PolicyControlledIntervention intervention) const {
+    return intervention_policy_[static_cast<size_t>(intervention)];
+  }
+
+  size_t GetInterventionPolicyFramesReportedForTesting() const {
+    return intervention_policy_frames_reported_;
+  }
+
+ private:
+  friend class FrameCoordinationUnitImpl;
+
+  // CoordinationUnitInterface implementation.
+  void OnEventReceived(mojom::Event event) override;
+  void OnPropertyChanged(mojom::PropertyType property_type,
+                         int64_t value) override;
+
+  bool AddFrame(FrameCoordinationUnitImpl* frame_cu);
+  bool RemoveFrame(FrameCoordinationUnitImpl* frame_cu);
+
+  // This is called whenever |num_frozen_frames_| changes, or whenever
+  // |frame_coordination_units_.size()| changes. It is used to synthesize the
+  // value of |has_nonempty_beforeunload| and to update the LifecycleState of
+  // the page. Calling this with |num_frozen_frames_delta == 0| implies that the
+  // number of frames itself has changed.
+  void OnNumFrozenFramesStateChange(int num_frozen_frames_delta);
+
+  // Invalidates all currently aggregated intervention policies.
+  void InvalidateAllInterventionPolicies();
+
+  // Invoked when adding or removing a frame. This will update
+  // |intervention_policy_frames_reported_| if necessary and potentially
+  // invalidate the aggregated intervention policies. This should be called
+  // after the frame has already been added or removed from
+  // |frame_coordination_units_|.
+  void MaybeInvalidateInterventionPolicies(FrameCoordinationUnitImpl* frame_cu,
+                                           bool adding_frame);
+
+  // Recomputes intervention policy aggregation. This is invoked on demand when
+  // a policy is queried.
+  void RecomputeInterventionPolicy(
+      mojom::PolicyControlledIntervention intervention);
+
+  std::set<FrameCoordinationUnitImpl*> frame_coordination_units_;
+
+  base::TimeTicks visibility_change_time_;
+  // Main frame navigation committed time.
+  base::TimeTicks navigation_committed_time_;
+
+  // The time the most recent resource usage estimate applies to.
+  base::TimeTicks usage_estimate_time_;
+
+  // The most current CPU usage estimate. Note that this estimate is most
+  // generously described as "piecewise linear", as it attributes the CPU
+  // cost incurred since the last measurement was made equally to pages
+  // hosted by a process. If, e.g. a frame has come into existence and vanished
+  // from a given process between measurements, the entire cost to that frame
+  // will be mis-attributed to other frames hosted in that process.
+  base::TimeDelta cumulative_cpu_usage_estimate_;
+  // The most current memory footprint estimate.
+  uint64_t private_footprint_kb_estimate_ = 0;
+
+  // Counts the number of frames in a page that are frozen.
+  size_t num_frozen_frames_ = 0;
+
+  // Indicates whether or not this page has a non-empty beforeunload handler.
+  // This is an aggregation of the same value on each frame in the page's frame
+  // tree. The aggregation is made at the moment all frames associated with a
+  // page have transition to frozen.
+  bool has_nonempty_beforeunload_ = false;
+
+  // The URL the main frame last committed a navigation to and the unique ID of
+  // the associated navigation handle.
+  std::string main_frame_url_;
+  int64_t navigation_id_ = 0;
+
+  // The aggregate intervention policy states for this page. These are
+  // aggregated from the corresponding per-frame values. If an individual value
+  // is kUnknown then a frame in the frame tree has changed values and
+  // a new aggregation is required.
+  mojom::InterventionPolicy intervention_policy_
+      [static_cast<size_t>(mojom::PolicyControlledIntervention::kMaxValue) + 1];
+
+  // The number of child frames that have checked in with initial intervention
+  // policy values. If this doesn't match the number of known child frames, then
+  // aggregation isn't possible. Child frames check in with all properties once
+  // immediately after document parsing, and the *last* value being set
+  // is used as a signal that the frame has reported.
+  size_t intervention_policy_frames_reported_ = 0;
+
+  DISALLOW_COPY_AND_ASSIGN(PageCoordinationUnitImpl);
+};
+
+}  // namespace resource_coordinator
+
+#endif  // SERVICES_RESOURCE_COORDINATOR_COORDINATION_UNIT_PAGE_COORDINATION_UNIT_IMPL_H_
diff -BbuN a/services/resource_coordinator/coordination_unit/page_coordination_unit_impl_unittest.cc b/services/resource_coordinator/coordination_unit/page_coordination_unit_impl_unittest.cc
--- a/services/resource_coordinator/coordination_unit/page_coordination_unit_impl_unittest.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/services/resource_coordinator/coordination_unit/page_coordination_unit_impl_unittest.cc	2019-05-17 18:53:37.956000000 +0300
@@ -0,0 +1,426 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "services/resource_coordinator/coordination_unit/page_coordination_unit_impl.h"
+
+#include "base/test/simple_test_tick_clock.h"
+#include "services/resource_coordinator/coordination_unit/coordination_unit_test_harness.h"
+#include "services/resource_coordinator/coordination_unit/frame_coordination_unit_impl.h"
+#include "services/resource_coordinator/coordination_unit/mock_coordination_unit_graphs.h"
+#include "services/resource_coordinator/coordination_unit/page_coordination_unit_impl.h"
+#include "services/resource_coordinator/coordination_unit/process_coordination_unit_impl.h"
+#include "services/resource_coordinator/resource_coordinator_clock.h"
+#include "testing/gtest/include/gtest/gtest.h"
+
+namespace resource_coordinator {
+
+namespace {
+
+class PageCoordinationUnitImplTest : public CoordinationUnitTestHarness {
+ public:
+  void SetUp() override {
+    ResourceCoordinatorClock::SetClockForTesting(&clock_);
+
+    // Sets a valid starting time.
+    clock_.SetNowTicks(base::TimeTicks::Now());
+  }
+
+  void TearDown() override {
+    ResourceCoordinatorClock::ResetClockForTesting();
+  }
+
+ protected:
+  void AdvanceClock(base::TimeDelta delta) { clock_.Advance(delta); }
+
+ private:
+  base::SimpleTestTickClock clock_;
+};
+
+}  // namespace
+
+TEST_F(PageCoordinationUnitImplTest, AddFrameBasic) {
+  auto page_cu = CreateCoordinationUnit<PageCoordinationUnitImpl>();
+  auto frame1_cu = CreateCoordinationUnit<FrameCoordinationUnitImpl>();
+  auto frame2_cu = CreateCoordinationUnit<FrameCoordinationUnitImpl>();
+  auto frame3_cu = CreateCoordinationUnit<FrameCoordinationUnitImpl>();
+
+  page_cu->AddFrame(frame1_cu->id());
+  page_cu->AddFrame(frame2_cu->id());
+  page_cu->AddFrame(frame3_cu->id());
+  EXPECT_EQ(3u, page_cu->GetFrameCoordinationUnits().size());
+}
+
+TEST_F(PageCoordinationUnitImplTest, AddReduplicativeFrame) {
+  auto page_cu = CreateCoordinationUnit<PageCoordinationUnitImpl>();
+  auto frame1_cu = CreateCoordinationUnit<FrameCoordinationUnitImpl>();
+  auto frame2_cu = CreateCoordinationUnit<FrameCoordinationUnitImpl>();
+
+  page_cu->AddFrame(frame1_cu->id());
+  page_cu->AddFrame(frame2_cu->id());
+  page_cu->AddFrame(frame1_cu->id());
+  EXPECT_EQ(2u, page_cu->GetFrameCoordinationUnits().size());
+}
+
+TEST_F(PageCoordinationUnitImplTest, RemoveFrame) {
+  auto page_cu = CreateCoordinationUnit<PageCoordinationUnitImpl>();
+  auto frame_cu = CreateCoordinationUnit<FrameCoordinationUnitImpl>();
+
+  // Parent-child relationships have not been established yet.
+  EXPECT_EQ(0u, page_cu->GetFrameCoordinationUnits().size());
+  EXPECT_FALSE(frame_cu->GetPageCoordinationUnit());
+
+  page_cu->AddFrame(frame_cu->id());
+
+  // Ensure correct Parent-child relationships have been established.
+  EXPECT_EQ(1u, page_cu->GetFrameCoordinationUnits().size());
+  EXPECT_EQ(1u, page_cu->GetFrameCoordinationUnits().count(frame_cu.get()));
+  EXPECT_EQ(page_cu.get(), frame_cu->GetPageCoordinationUnit());
+
+  page_cu->RemoveFrame(frame_cu->id());
+
+  // Parent-child relationships should no longer exist.
+  EXPECT_EQ(0u, page_cu->GetFrameCoordinationUnits().size());
+  EXPECT_FALSE(frame_cu->GetPageCoordinationUnit());
+}
+
+TEST_F(PageCoordinationUnitImplTest,
+       CalculatePageCPUUsageForSinglePageInSingleProcess) {
+  MockSinglePageInSingleProcessCoordinationUnitGraph cu_graph(
+      coordination_unit_graph());
+  cu_graph.process->SetCPUUsage(40);
+  EXPECT_EQ(40, cu_graph.page->GetCPUUsage());
+}
+
+TEST_F(PageCoordinationUnitImplTest,
+       CalculatePageCPUUsageForMultiplePagesInSingleProcess) {
+  MockMultiplePagesInSingleProcessCoordinationUnitGraph cu_graph(
+      coordination_unit_graph());
+  cu_graph.process->SetCPUUsage(40);
+  EXPECT_EQ(20, cu_graph.page->GetCPUUsage());
+  EXPECT_EQ(20, cu_graph.other_page->GetCPUUsage());
+}
+
+TEST_F(PageCoordinationUnitImplTest,
+       CalculatePageCPUUsageForSinglePageWithMultipleProcesses) {
+  MockSinglePageWithMultipleProcessesCoordinationUnitGraph cu_graph(
+      coordination_unit_graph());
+  cu_graph.process->SetCPUUsage(40);
+  cu_graph.other_process->SetCPUUsage(30);
+  EXPECT_EQ(70, cu_graph.page->GetCPUUsage());
+}
+
+TEST_F(PageCoordinationUnitImplTest,
+       CalculatePageCPUUsageForMultiplePagesWithMultipleProcesses) {
+  MockMultiplePagesWithMultipleProcessesCoordinationUnitGraph cu_graph(
+      coordination_unit_graph());
+  cu_graph.process->SetCPUUsage(40);
+  cu_graph.other_process->SetCPUUsage(30);
+  EXPECT_EQ(20, cu_graph.page->GetCPUUsage());
+  EXPECT_EQ(50, cu_graph.other_page->GetCPUUsage());
+}
+
+TEST_F(PageCoordinationUnitImplTest,
+       CalculatePageEQTForSinglePageInSingleProcess) {
+  MockSinglePageInSingleProcessCoordinationUnitGraph cu_graph(
+      coordination_unit_graph());
+
+  cu_graph.process->SetExpectedTaskQueueingDuration(
+      base::TimeDelta::FromMilliseconds(1));
+
+  int64_t eqt;
+  EXPECT_TRUE(cu_graph.page->GetExpectedTaskQueueingDuration(&eqt));
+  EXPECT_EQ(1, eqt);
+}
+
+TEST_F(PageCoordinationUnitImplTest,
+       CalculatePageEQTForMultiplePagesInSingleProcess) {
+  MockMultiplePagesInSingleProcessCoordinationUnitGraph cu_graph(
+      coordination_unit_graph());
+
+  cu_graph.process->SetExpectedTaskQueueingDuration(
+      base::TimeDelta::FromMilliseconds(1));
+
+  int64_t eqt;
+  EXPECT_TRUE(cu_graph.page->GetExpectedTaskQueueingDuration(&eqt));
+  EXPECT_EQ(1, eqt);
+  eqt = 0;
+  EXPECT_TRUE(cu_graph.other_page->GetExpectedTaskQueueingDuration(&eqt));
+  EXPECT_EQ(1, eqt);
+}
+
+TEST_F(PageCoordinationUnitImplTest, TimeSinceLastVisibilityChange) {
+  MockSinglePageInSingleProcessCoordinationUnitGraph cu_graph(
+      coordination_unit_graph());
+
+  cu_graph.page->SetVisibility(true);
+  EXPECT_TRUE(cu_graph.page->IsVisible());
+  AdvanceClock(base::TimeDelta::FromSeconds(42));
+  EXPECT_EQ(base::TimeDelta::FromSeconds(42),
+            cu_graph.page->TimeSinceLastVisibilityChange());
+
+  cu_graph.page->SetVisibility(false);
+  AdvanceClock(base::TimeDelta::FromSeconds(23));
+  EXPECT_EQ(base::TimeDelta::FromSeconds(23),
+            cu_graph.page->TimeSinceLastVisibilityChange());
+  EXPECT_FALSE(cu_graph.page->IsVisible());
+}
+
+TEST_F(PageCoordinationUnitImplTest, TimeSinceLastNavigation) {
+  MockSinglePageInSingleProcessCoordinationUnitGraph cu_graph(
+      coordination_unit_graph());
+  // Before any commit events, timedelta should be 0.
+  EXPECT_TRUE(cu_graph.page->TimeSinceLastNavigation().is_zero());
+
+  // 1st navigation.
+  cu_graph.page->OnMainFrameNavigationCommitted(
+      ResourceCoordinatorClock::NowTicks(), 10u, "http://www.example.org");
+  EXPECT_EQ("http://www.example.org", cu_graph.page->main_frame_url());
+  EXPECT_EQ(10u, cu_graph.page->navigation_id());
+  AdvanceClock(base::TimeDelta::FromSeconds(11));
+  EXPECT_EQ(base::TimeDelta::FromSeconds(11),
+            cu_graph.page->TimeSinceLastNavigation());
+
+  // 2nd navigation.
+  cu_graph.page->OnMainFrameNavigationCommitted(
+      ResourceCoordinatorClock::NowTicks(), 20u,
+      "http://www.example.org/bobcat");
+  EXPECT_EQ("http://www.example.org/bobcat", cu_graph.page->main_frame_url());
+  EXPECT_EQ(20u, cu_graph.page->navigation_id());
+  AdvanceClock(base::TimeDelta::FromSeconds(17));
+  EXPECT_EQ(base::TimeDelta::FromSeconds(17),
+            cu_graph.page->TimeSinceLastNavigation());
+}
+
+TEST_F(PageCoordinationUnitImplTest, IsLoading) {
+  MockSinglePageInSingleProcessCoordinationUnitGraph cu_graph(
+      coordination_unit_graph());
+  auto* page_cu = cu_graph.page.get();
+
+  // First attempt should fail, as the property is unset.
+  int64_t loading = 0;
+  EXPECT_FALSE(page_cu->GetProperty(mojom::PropertyType::kIsLoading, &loading));
+
+  // Set to false and the property should read false.
+  page_cu->SetIsLoading(false);
+  EXPECT_TRUE(page_cu->GetProperty(mojom::PropertyType::kIsLoading, &loading));
+  EXPECT_EQ(0u, loading);
+
+  // Set to true and the property should read true.
+  page_cu->SetIsLoading(true);
+  EXPECT_TRUE(page_cu->GetProperty(mojom::PropertyType::kIsLoading, &loading));
+  EXPECT_EQ(1u, loading);
+
+  // Set to false and the property should read false again.
+  page_cu->SetIsLoading(false);
+  EXPECT_TRUE(page_cu->GetProperty(mojom::PropertyType::kIsLoading, &loading));
+  EXPECT_EQ(0u, loading);
+}
+
+TEST_F(PageCoordinationUnitImplTest, OnAllFramesInPageFrozen) {
+  const int64_t kRunning =
+      static_cast<int64_t>(mojom::LifecycleState::kRunning);
+  const int64_t kFrozen = static_cast<int64_t>(mojom::LifecycleState::kFrozen);
+
+  MockSinglePageWithMultipleProcessesCoordinationUnitGraph cu_graph(
+      coordination_unit_graph());
+
+  EXPECT_EQ(kRunning, cu_graph.page->GetPropertyOrDefault(
+                          mojom::PropertyType::kLifecycleState, kRunning));
+
+  // 1/2 frames in the page is frozen. Expect the page to still be running.
+  cu_graph.frame->SetLifecycleState(mojom::LifecycleState::kFrozen);
+  EXPECT_EQ(kRunning, cu_graph.page->GetPropertyOrDefault(
+                          mojom::PropertyType::kLifecycleState, kRunning));
+
+  // 2/2 frames in the process are frozen. We expect the page to be frozen.
+  cu_graph.child_frame->SetLifecycleState(mojom::LifecycleState::kFrozen);
+  EXPECT_EQ(kFrozen, cu_graph.page->GetPropertyOrDefault(
+                         mojom::PropertyType::kLifecycleState, kRunning));
+
+  // Unfreeze a frame and expect the page to be running again.
+  cu_graph.frame->SetLifecycleState(mojom::LifecycleState::kRunning);
+  EXPECT_EQ(kRunning, cu_graph.page->GetPropertyOrDefault(
+                          mojom::PropertyType::kLifecycleState, kRunning));
+
+  // Refreeze that frame and expect the page to be frozen again.
+  cu_graph.frame->SetLifecycleState(mojom::LifecycleState::kFrozen);
+  EXPECT_EQ(kFrozen, cu_graph.page->GetPropertyOrDefault(
+                         mojom::PropertyType::kLifecycleState, kRunning));
+}
+
+namespace {
+
+const size_t kInterventionCount =
+    static_cast<size_t>(mojom::PolicyControlledIntervention::kMaxValue) + 1;
+
+void ExpectRawInterventionPolicy(mojom::InterventionPolicy policy,
+                                 const PageCoordinationUnitImpl* page_cu) {
+  for (size_t i = 0; i < kInterventionCount; ++i) {
+    EXPECT_EQ(policy, page_cu->GetRawInterventionPolicyForTesting(
+                          static_cast<mojom::PolicyControlledIntervention>(i)));
+  }
+}
+
+void ExpectInterventionPolicy(mojom::InterventionPolicy policy,
+                              PageCoordinationUnitImpl* page_cu) {
+  for (size_t i = 0; i < kInterventionCount; ++i) {
+    EXPECT_EQ(policy, page_cu->GetInterventionPolicy(
+                          static_cast<mojom::PolicyControlledIntervention>(i)));
+  }
+}
+
+void ExpectInitialInterventionPolicyAggregationWorks(
+    CoordinationUnitGraph* cu_graph,
+    mojom::InterventionPolicy f0_policy,
+    mojom::InterventionPolicy f1_policy,
+    mojom::InterventionPolicy f0_policy_aggregated,
+    mojom::InterventionPolicy f0f1_policy_aggregated) {
+  // Create two frames not tied to any page.
+  TestCoordinationUnitWrapper<FrameCoordinationUnitImpl> f0 =
+      TestCoordinationUnitWrapper<FrameCoordinationUnitImpl>::Create(cu_graph);
+  TestCoordinationUnitWrapper<FrameCoordinationUnitImpl> f1 =
+      TestCoordinationUnitWrapper<FrameCoordinationUnitImpl>::Create(cu_graph);
+
+  // Set frame policies before attaching to a page CU.
+  f0->SetAllInterventionPoliciesForTesting(f0_policy);
+  f1->SetAllInterventionPoliciesForTesting(f1_policy);
+
+  // Check the initial values before any frames are added.
+  TestCoordinationUnitWrapper<PageCoordinationUnitImpl> page =
+      TestCoordinationUnitWrapper<PageCoordinationUnitImpl>::Create(cu_graph);
+  EXPECT_EQ(0u, page->GetInterventionPolicyFramesReportedForTesting());
+  ExpectRawInterventionPolicy(mojom::InterventionPolicy::kUnknown, page.get());
+  ExpectInterventionPolicy(mojom::InterventionPolicy::kUnknown, page.get());
+
+  // Add a frame and expect the values to be invalidated. Reaggregate and
+  // ensure the appropriate value results.
+  page->AddFrame(f0->id());
+  EXPECT_EQ(1u, page->GetInterventionPolicyFramesReportedForTesting());
+  ExpectRawInterventionPolicy(mojom::InterventionPolicy::kUnknown, page.get());
+  ExpectInterventionPolicy(f0_policy_aggregated, page.get());
+
+  // Do it again. This time the raw values should be the same as the
+  // aggregated values above.
+  page->AddFrame(f1->id());
+  EXPECT_EQ(2u, page->GetInterventionPolicyFramesReportedForTesting());
+  ExpectRawInterventionPolicy(mojom::InterventionPolicy::kUnknown, page.get());
+  ExpectInterventionPolicy(f0f1_policy_aggregated, page.get());
+
+  // Remove a frame and expect the values to be invalidated again.
+  f1.reset();
+  EXPECT_EQ(1u, page->GetInterventionPolicyFramesReportedForTesting());
+  ExpectRawInterventionPolicy(mojom::InterventionPolicy::kUnknown, page.get());
+  ExpectInterventionPolicy(f0_policy_aggregated, page.get());
+}
+
+}  // namespace
+
+TEST_F(PageCoordinationUnitImplTest, InitialInterventionPolicy) {
+  auto* cu_graph = coordination_unit_graph();
+
+  // Tests all possible transitions where the frame CU has its policy values
+  // set before being attached to the page CU. This affectively tests the
+  // aggregation logic in isolation.
+
+  // Default x [Default, OptIn, OptOut]
+
+  ExpectInitialInterventionPolicyAggregationWorks(
+      cu_graph, mojom::InterventionPolicy::kDefault /* f0_policy */,
+      mojom::InterventionPolicy::kDefault /* f1_policy */,
+      mojom::InterventionPolicy::kDefault /* f0_policy_aggregated */,
+      mojom::InterventionPolicy::kDefault /* f0f1_policy_aggregated */);
+
+  ExpectInitialInterventionPolicyAggregationWorks(
+      cu_graph, mojom::InterventionPolicy::kDefault /* f0_policy */,
+      mojom::InterventionPolicy::kOptIn /* f1_policy */,
+      mojom::InterventionPolicy::kDefault /* f0_policy_aggregated */,
+      mojom::InterventionPolicy::kOptIn /* f0f1_policy_aggregated */);
+
+  ExpectInitialInterventionPolicyAggregationWorks(
+      cu_graph, mojom::InterventionPolicy::kDefault /* f0_policy */,
+      mojom::InterventionPolicy::kOptOut /* f1_policy */,
+      mojom::InterventionPolicy::kDefault /* f0_policy_aggregated */,
+      mojom::InterventionPolicy::kOptOut /* f0f1_policy_aggregated */);
+
+  // OptIn x [Default, OptIn, OptOut]
+
+  ExpectInitialInterventionPolicyAggregationWorks(
+      cu_graph, mojom::InterventionPolicy::kOptIn /* f0_policy */,
+      mojom::InterventionPolicy::kDefault /* f1_policy */,
+      mojom::InterventionPolicy::kOptIn /* f0_policy_aggregated */,
+      mojom::InterventionPolicy::kOptIn /* f0f1_policy_aggregated */);
+
+  ExpectInitialInterventionPolicyAggregationWorks(
+      cu_graph, mojom::InterventionPolicy::kOptIn /* f0_policy */,
+      mojom::InterventionPolicy::kOptIn /* f1_policy */,
+      mojom::InterventionPolicy::kOptIn /* f0_policy_aggregated */,
+      mojom::InterventionPolicy::kOptIn /* f0f1_policy_aggregated */);
+
+  ExpectInitialInterventionPolicyAggregationWorks(
+      cu_graph, mojom::InterventionPolicy::kOptIn /* f0_policy */,
+      mojom::InterventionPolicy::kOptOut /* f1_policy */,
+      mojom::InterventionPolicy::kOptIn /* f0_policy_aggregated */,
+      mojom::InterventionPolicy::kOptOut /* f0f1_policy_aggregated */);
+
+  // OptOut x [Default, OptIn, OptOut]
+
+  ExpectInitialInterventionPolicyAggregationWorks(
+      cu_graph, mojom::InterventionPolicy::kOptOut /* f0_policy */,
+      mojom::InterventionPolicy::kDefault /* f1_policy */,
+      mojom::InterventionPolicy::kOptOut /* f0_policy_aggregated */,
+      mojom::InterventionPolicy::kOptOut /* f0f1_policy_aggregated */);
+
+  ExpectInitialInterventionPolicyAggregationWorks(
+      cu_graph, mojom::InterventionPolicy::kOptOut /* f0_policy */,
+      mojom::InterventionPolicy::kOptIn /* f1_policy */,
+      mojom::InterventionPolicy::kOptOut /* f0_policy_aggregated */,
+      mojom::InterventionPolicy::kOptOut /* f0f1_policy_aggregated */);
+
+  ExpectInitialInterventionPolicyAggregationWorks(
+      cu_graph, mojom::InterventionPolicy::kOptOut /* f0_policy */,
+      mojom::InterventionPolicy::kOptOut /* f1_policy */,
+      mojom::InterventionPolicy::kOptOut /* f0_policy_aggregated */,
+      mojom::InterventionPolicy::kOptOut /* f0f1_policy_aggregated */);
+}
+
+TEST_F(PageCoordinationUnitImplTest, IncrementalInterventionPolicy) {
+  auto* cu_graph = coordination_unit_graph();
+
+  TestCoordinationUnitWrapper<PageCoordinationUnitImpl> page =
+      TestCoordinationUnitWrapper<PageCoordinationUnitImpl>::Create(cu_graph);
+
+  // Create two frames and immediately attach them to the page.
+  TestCoordinationUnitWrapper<FrameCoordinationUnitImpl> f0 =
+      TestCoordinationUnitWrapper<FrameCoordinationUnitImpl>::Create(cu_graph);
+  TestCoordinationUnitWrapper<FrameCoordinationUnitImpl> f1 =
+      TestCoordinationUnitWrapper<FrameCoordinationUnitImpl>::Create(cu_graph);
+  EXPECT_EQ(0u, page->GetInterventionPolicyFramesReportedForTesting());
+  page->AddFrame(f0->id());
+  EXPECT_EQ(0u, page->GetInterventionPolicyFramesReportedForTesting());
+  page->AddFrame(f1->id());
+  EXPECT_EQ(0u, page->GetInterventionPolicyFramesReportedForTesting());
+
+  // Set the policies on the first frame. This should be observed by the page
+  // CU, but aggregation should still not be possible.
+  f0->SetAllInterventionPoliciesForTesting(mojom::InterventionPolicy::kDefault);
+  EXPECT_EQ(1u, page->GetInterventionPolicyFramesReportedForTesting());
+  ExpectRawInterventionPolicy(mojom::InterventionPolicy::kUnknown, page.get());
+  ExpectInterventionPolicy(mojom::InterventionPolicy::kUnknown, page.get());
+
+  // Now set the policy on the second frame. This should be observed and an
+  // aggregated page policy value should now be available.
+  f1->SetAllInterventionPoliciesForTesting(mojom::InterventionPolicy::kDefault);
+  EXPECT_EQ(2u, page->GetInterventionPolicyFramesReportedForTesting());
+  ExpectRawInterventionPolicy(mojom::InterventionPolicy::kUnknown, page.get());
+  ExpectInterventionPolicy(mojom::InterventionPolicy::kDefault, page.get());
+
+  // Change the policy value on a frame and expect a new aggregation to be
+  // required.
+  f1->SetAllInterventionPoliciesForTesting(mojom::InterventionPolicy::kOptIn);
+  EXPECT_EQ(2u, page->GetInterventionPolicyFramesReportedForTesting());
+  ExpectRawInterventionPolicy(mojom::InterventionPolicy::kUnknown, page.get());
+  ExpectInterventionPolicy(mojom::InterventionPolicy::kOptIn, page.get());
+}
+
+}  // namespace resource_coordinator
diff -BbuN a/services/resource_coordinator/coordination_unit/process_coordination_unit_impl.cc b/services/resource_coordinator/coordination_unit/process_coordination_unit_impl.cc
--- a/services/resource_coordinator/coordination_unit/process_coordination_unit_impl.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/services/resource_coordinator/coordination_unit/process_coordination_unit_impl.cc	2019-05-17 18:53:37.956000000 +0300
@@ -0,0 +1,157 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "services/resource_coordinator/coordination_unit/process_coordination_unit_impl.h"
+
+#include "base/logging.h"
+#include "services/resource_coordinator/coordination_unit/frame_coordination_unit_impl.h"
+#include "services/resource_coordinator/coordination_unit/page_coordination_unit_impl.h"
+
+namespace resource_coordinator {
+
+ProcessCoordinationUnitImpl::ProcessCoordinationUnitImpl(
+    const CoordinationUnitID& id,
+    CoordinationUnitGraph* graph,
+    std::unique_ptr<service_manager::ServiceKeepaliveRef> keepalive_ref)
+    : CoordinationUnitInterface(id, graph, std::move(keepalive_ref)) {}
+
+ProcessCoordinationUnitImpl::~ProcessCoordinationUnitImpl() {
+  // Make as if we're transitioning to the null PID before we die to clear this
+  // instance from the PID map.
+  if (process_id_ != base::kNullProcessId)
+    graph()->BeforeProcessPidChange(this, base::kNullProcessId);
+
+  for (auto* child_frame : frame_coordination_units_)
+    child_frame->RemoveProcessCoordinationUnit(this);
+}
+
+void ProcessCoordinationUnitImpl::AddFrame(
+    FrameCoordinationUnitImpl* frame_cu) {
+  const bool inserted = frame_coordination_units_.insert(frame_cu).second;
+  DCHECK(inserted);
+  if (frame_cu->lifecycle_state() == mojom::LifecycleState::kFrozen)
+    IncrementNumFrozenFrames();
+}
+
+void ProcessCoordinationUnitImpl::SetCPUUsage(double cpu_usage) {
+  SetProperty(mojom::PropertyType::kCPUUsage, cpu_usage * 1000);
+}
+
+void ProcessCoordinationUnitImpl::SetExpectedTaskQueueingDuration(
+    base::TimeDelta duration) {
+  SetProperty(mojom::PropertyType::kExpectedTaskQueueingDuration,
+              duration.InMilliseconds());
+}
+
+void ProcessCoordinationUnitImpl::SetLaunchTime(base::Time launch_time) {
+  DCHECK(launch_time_.is_null());
+  launch_time_ = launch_time;
+}
+
+void ProcessCoordinationUnitImpl::SetMainThreadTaskLoadIsLow(
+    bool main_thread_task_load_is_low) {
+  SetProperty(mojom::PropertyType::kMainThreadTaskLoadIsLow,
+              main_thread_task_load_is_low);
+}
+
+void ProcessCoordinationUnitImpl::SetPID(base::ProcessId pid) {
+  // Either this is the initial process associated with this process CU,
+  // or it's a subsequent process. In the latter case, there must have been
+  // an exit status associated with the previous process.
+  DCHECK(process_id_ == base::kNullProcessId || exit_status_.has_value());
+
+  graph()->BeforeProcessPidChange(this, pid);
+
+  process_id_ = pid;
+
+  // Clear launch time and exit status for the previous process (if any).
+  launch_time_ = base::Time();
+  exit_status_.reset();
+
+  // Also clear the measurement data (if any), as it references the previous
+  // process.
+  private_footprint_kb_ = 0;
+  cumulative_cpu_usage_ = base::TimeDelta();
+
+  SetProperty(mojom::PropertyType::kPID, pid);
+}
+
+void ProcessCoordinationUnitImpl::SetProcessExitStatus(int32_t exit_status) {
+  exit_status_ = exit_status;
+}
+
+void ProcessCoordinationUnitImpl::OnRendererIsBloated() {
+  SendEvent(mojom::Event::kRendererIsBloated);
+}
+
+const std::set<FrameCoordinationUnitImpl*>&
+ProcessCoordinationUnitImpl::GetFrameCoordinationUnits() const {
+  return frame_coordination_units_;
+}
+
+// There is currently not a direct relationship between processes and
+// pages. However, frames are children of both processes and frames, so we
+// find all of the pages that are reachable from the process's child
+// frames.
+std::set<PageCoordinationUnitImpl*>
+ProcessCoordinationUnitImpl::GetAssociatedPageCoordinationUnits() const {
+  std::set<PageCoordinationUnitImpl*> page_cus;
+  for (auto* frame_cu : frame_coordination_units_) {
+    if (auto* page_cu = frame_cu->GetPageCoordinationUnit())
+      page_cus.insert(page_cu);
+  }
+  return page_cus;
+}
+
+void ProcessCoordinationUnitImpl::OnFrameLifecycleStateChanged(
+    FrameCoordinationUnitImpl* frame_cu,
+    mojom::LifecycleState old_state) {
+  DCHECK(base::ContainsKey(frame_coordination_units_, frame_cu));
+  DCHECK_NE(old_state, frame_cu->lifecycle_state());
+
+  if (old_state == mojom::LifecycleState::kFrozen)
+    DecrementNumFrozenFrames();
+  else if (frame_cu->lifecycle_state() == mojom::LifecycleState::kFrozen)
+    IncrementNumFrozenFrames();
+}
+
+void ProcessCoordinationUnitImpl::OnEventReceived(mojom::Event event) {
+  for (auto& observer : observers())
+    observer.OnProcessEventReceived(this, event);
+}
+
+void ProcessCoordinationUnitImpl::OnPropertyChanged(
+    const mojom::PropertyType property_type,
+    int64_t value) {
+  for (auto& observer : observers())
+    observer.OnProcessPropertyChanged(this, property_type, value);
+}
+
+void ProcessCoordinationUnitImpl::RemoveFrame(
+    FrameCoordinationUnitImpl* frame_cu) {
+  DCHECK(base::ContainsKey(frame_coordination_units_, frame_cu));
+  frame_coordination_units_.erase(frame_cu);
+
+  if (frame_cu->lifecycle_state() == mojom::LifecycleState::kFrozen)
+    DecrementNumFrozenFrames();
+}
+
+void ProcessCoordinationUnitImpl::DecrementNumFrozenFrames() {
+  --num_frozen_frames_;
+  DCHECK_GE(num_frozen_frames_, 0);
+}
+
+void ProcessCoordinationUnitImpl::IncrementNumFrozenFrames() {
+  ++num_frozen_frames_;
+  DCHECK_LE(num_frozen_frames_,
+            static_cast<int>(frame_coordination_units_.size()));
+
+  if (num_frozen_frames_ ==
+      static_cast<int>(frame_coordination_units_.size())) {
+    for (auto& observer : observers())
+      observer.OnAllFramesInProcessFrozen(this);
+  }
+}
+
+}  // namespace resource_coordinator
diff -BbuN a/services/resource_coordinator/coordination_unit/process_coordination_unit_impl.h b/services/resource_coordinator/coordination_unit/process_coordination_unit_impl.h
--- a/services/resource_coordinator/coordination_unit/process_coordination_unit_impl.h	1970-01-01 03:00:00.000000000 +0300
+++ b/services/resource_coordinator/coordination_unit/process_coordination_unit_impl.h	2019-05-17 18:53:37.956000000 +0300
@@ -0,0 +1,104 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef SERVICES_RESOURCE_COORDINATOR_COORDINATION_UNIT_PROCESS_COORDINATION_UNIT_IMPL_H_
+#define SERVICES_RESOURCE_COORDINATOR_COORDINATION_UNIT_PROCESS_COORDINATION_UNIT_IMPL_H_
+
+#include "base/macros.h"
+#include "base/optional.h"
+#include "base/process/process_handle.h"
+#include "base/time/time.h"
+#include "services/resource_coordinator/coordination_unit/coordination_unit_base.h"
+
+namespace resource_coordinator {
+
+class FrameCoordinationUnitImpl;
+
+// A process coordination unit follows the lifetime of a RenderProcessHost.
+// It may reference zero or one processes at a time, but during its lifetime, it
+// may reference more than one process. This can happen if the associated
+// renderer crashes, and an associated frame is then reloaded or re-navigated.
+// The state of the process CU goes through:
+// 1. Created, no PID.
+// 2. Process started, have PID - in the case where the associated render
+//    process fails to start, this state may not occur.
+// 3. Process died or falied to start, have exit status.
+// 4. Back to 2.
+class ProcessCoordinationUnitImpl
+    : public CoordinationUnitInterface<ProcessCoordinationUnitImpl,
+                                       mojom::ProcessCoordinationUnit,
+                                       mojom::ProcessCoordinationUnitRequest> {
+ public:
+  static CoordinationUnitType Type() { return CoordinationUnitType::kProcess; }
+
+  ProcessCoordinationUnitImpl(
+      const CoordinationUnitID& id,
+      CoordinationUnitGraph* graph,
+      std::unique_ptr<service_manager::ServiceKeepaliveRef> keepalive_ref);
+  ~ProcessCoordinationUnitImpl() override;
+
+  // mojom::ProcessCoordinationUnit implementation.
+  void SetCPUUsage(double cpu_usage) override;
+  void SetExpectedTaskQueueingDuration(base::TimeDelta duration) override;
+  void SetLaunchTime(base::Time launch_time) override;
+  void SetMainThreadTaskLoadIsLow(bool main_thread_task_load_is_low) override;
+  void SetPID(base::ProcessId pid) override;
+  void SetProcessExitStatus(int32_t exit_status) override;
+  void OnRendererIsBloated() override;
+
+  // Private implementation properties.
+  void set_private_footprint_kb(uint64_t private_footprint_kb) {
+    private_footprint_kb_ = private_footprint_kb;
+  }
+  uint64_t private_footprint_kb() const { return private_footprint_kb_; }
+  void set_cumulative_cpu_usage(base::TimeDelta cumulative_cpu_usage) {
+    cumulative_cpu_usage_ = cumulative_cpu_usage;
+  }
+  base::TimeDelta cumulative_cpu_usage() const { return cumulative_cpu_usage_; }
+
+  const std::set<FrameCoordinationUnitImpl*>& GetFrameCoordinationUnits() const;
+  std::set<PageCoordinationUnitImpl*> GetAssociatedPageCoordinationUnits()
+      const;
+
+  base::ProcessId process_id() const { return process_id_; }
+  base::Time launch_time() const { return launch_time_; }
+  base::Optional<int32_t> exit_status() const { return exit_status_; }
+
+  // Add |frame_cu| to this process.
+  void AddFrame(FrameCoordinationUnitImpl* frame_cu);
+  // Removes |frame_cu| from the set of frames hosted by this process. Invoked
+  // from the destructor of FrameCoordinationUnitImpl.
+  void RemoveFrame(FrameCoordinationUnitImpl* frame_cu);
+
+  // Invoked when the state of a frame hosted by this process changes.
+  void OnFrameLifecycleStateChanged(FrameCoordinationUnitImpl* frame_cu,
+                                    mojom::LifecycleState old_state);
+
+ private:
+  // CoordinationUnitInterface implementation.
+  void OnEventReceived(mojom::Event event) override;
+  void OnPropertyChanged(mojom::PropertyType property_type,
+                         int64_t value) override;
+
+  void DecrementNumFrozenFrames();
+  void IncrementNumFrozenFrames();
+
+  base::TimeDelta cumulative_cpu_usage_;
+  uint64_t private_footprint_kb_ = 0u;
+
+  base::ProcessId process_id_ = base::kNullProcessId;
+  base::Time launch_time_;
+  base::Optional<int32_t> exit_status_;
+
+  std::set<FrameCoordinationUnitImpl*> frame_coordination_units_;
+
+  // The number of frames hosted by this process that are frozen.
+  int num_frozen_frames_ = 0;
+
+  DISALLOW_COPY_AND_ASSIGN(ProcessCoordinationUnitImpl);
+};
+
+}  // namespace resource_coordinator
+
+#endif  // SERVICES_RESOURCE_COORDINATOR_COORDINATION_UNIT_PROCESS_COORDINATION_UNIT_IMPL_H_
diff -BbuN a/services/resource_coordinator/coordination_unit/process_coordination_unit_impl_unittest.cc b/services/resource_coordinator/coordination_unit/process_coordination_unit_impl_unittest.cc
--- a/services/resource_coordinator/coordination_unit/process_coordination_unit_impl_unittest.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/services/resource_coordinator/coordination_unit/process_coordination_unit_impl_unittest.cc	2019-05-17 18:53:37.956000000 +0300
@@ -0,0 +1,115 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "services/resource_coordinator/coordination_unit/process_coordination_unit_impl.h"
+
+#include "services/resource_coordinator/coordination_unit/coordination_unit_test_harness.h"
+#include "services/resource_coordinator/coordination_unit/frame_coordination_unit_impl.h"
+#include "services/resource_coordinator/coordination_unit/mock_coordination_unit_graphs.h"
+#include "testing/gmock/include/gmock/gmock.h"
+#include "testing/gtest/include/gtest/gtest.h"
+
+namespace resource_coordinator {
+
+namespace {
+
+class ProcessCoordinationUnitImplTest : public CoordinationUnitTestHarness {};
+
+class MockCoordinationUnitGraphObserver : public CoordinationUnitGraphObserver {
+ public:
+  MockCoordinationUnitGraphObserver() = default;
+  virtual ~MockCoordinationUnitGraphObserver() = default;
+
+  bool ShouldObserve(const CoordinationUnitBase* coordination_unit) override {
+    return true;
+  }
+
+  MOCK_METHOD1(OnAllFramesInProcessFrozen,
+               void(const ProcessCoordinationUnitImpl*));
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(MockCoordinationUnitGraphObserver);
+};
+
+}  // namespace
+
+TEST_F(ProcessCoordinationUnitImplTest, MeasureCPUUsage) {
+  auto process_cu = CreateCoordinationUnit<ProcessCoordinationUnitImpl>();
+  process_cu->SetCPUUsage(1);
+  int64_t cpu_usage;
+  EXPECT_TRUE(
+      process_cu->GetProperty(mojom::PropertyType::kCPUUsage, &cpu_usage));
+  EXPECT_EQ(1, cpu_usage / 1000.0);
+}
+
+TEST_F(ProcessCoordinationUnitImplTest, OnAllFramesInProcessFrozen) {
+  auto owned_observer = std::make_unique<
+      testing::StrictMock<MockCoordinationUnitGraphObserver>>();
+  auto* observer = owned_observer.get();
+  coordination_unit_graph()->RegisterObserver(std::move(owned_observer));
+  MockMultiplePagesInSingleProcessCoordinationUnitGraph cu_graph(
+      coordination_unit_graph());
+
+  // 1/2 frame in the process is frozen.
+  // No call to OnAllFramesInProcessFrozen() is expected.
+  cu_graph.frame->SetLifecycleState(mojom::LifecycleState::kFrozen);
+
+  // 2/2 frames in the process are frozen.
+  EXPECT_CALL(*observer, OnAllFramesInProcessFrozen(cu_graph.process.get()));
+  cu_graph.other_frame->SetLifecycleState(mojom::LifecycleState::kFrozen);
+  testing::Mock::VerifyAndClear(observer);
+
+  // A frame is unfrozen and frozen.
+  cu_graph.frame->SetLifecycleState(mojom::LifecycleState::kRunning);
+  EXPECT_CALL(*observer, OnAllFramesInProcessFrozen(cu_graph.process.get()));
+  cu_graph.frame->SetLifecycleState(mojom::LifecycleState::kFrozen);
+  testing::Mock::VerifyAndClear(observer);
+
+  // A frozen frame is frozen again.
+  // No call to OnAllFramesInProcessFrozen() is expected.
+  cu_graph.frame->SetLifecycleState(mojom::LifecycleState::kFrozen);
+}
+
+TEST_F(ProcessCoordinationUnitImplTest, ProcessLifeCycle) {
+  auto process_cu = CreateCoordinationUnit<ProcessCoordinationUnitImpl>();
+
+  // Test the potential lifecycles of a process CU.
+  // First go to exited without an intervening PID, as would happen
+  // in the case the process fails to start.
+  EXPECT_FALSE(process_cu->exit_status());
+  constexpr int32_t kExitStatus = 0xF00;
+  process_cu->SetProcessExitStatus(kExitStatus);
+  EXPECT_TRUE(process_cu->exit_status());
+  EXPECT_EQ(kExitStatus, process_cu->exit_status().value());
+
+  // Next go through PID->exit status.
+  constexpr base::ProcessId kTestPid = 0xCAFE;
+  process_cu->SetPID(kTestPid);
+  // Resurrection should clear the exit status.
+  EXPECT_FALSE(process_cu->exit_status());
+
+  EXPECT_EQ(base::Time(), process_cu->launch_time());
+  EXPECT_EQ(0U, process_cu->private_footprint_kb());
+  EXPECT_EQ(base::TimeDelta(), process_cu->cumulative_cpu_usage());
+
+  process_cu->SetLaunchTime(base::Time::Now());
+  process_cu->set_private_footprint_kb(10U);
+  process_cu->set_cumulative_cpu_usage(base::TimeDelta::FromMicroseconds(1));
+
+  // Kill it again and verify the properties above stick around.
+  process_cu->SetProcessExitStatus(kExitStatus);
+
+  EXPECT_NE(base::Time(), process_cu->launch_time());
+  EXPECT_NE(0U, process_cu->private_footprint_kb());
+  EXPECT_NE(base::TimeDelta(), process_cu->cumulative_cpu_usage());
+
+  // Resurrect again and verify the launch time and measurements
+  // are cleared.
+  process_cu->SetPID(kTestPid);
+  EXPECT_EQ(base::Time(), process_cu->launch_time());
+  EXPECT_EQ(0U, process_cu->private_footprint_kb());
+  EXPECT_EQ(base::TimeDelta(), process_cu->cumulative_cpu_usage());
+}
+
+}  // namespace resource_coordinator
diff -BbuN a/services/resource_coordinator/coordination_unit/system_coordination_unit_impl.cc b/services/resource_coordinator/coordination_unit/system_coordination_unit_impl.cc
--- a/services/resource_coordinator/coordination_unit/system_coordination_unit_impl.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/services/resource_coordinator/coordination_unit/system_coordination_unit_impl.cc	2019-05-17 18:53:37.956000000 +0300
@@ -0,0 +1,174 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "services/resource_coordinator/coordination_unit/system_coordination_unit_impl.h"
+
+#include "services/resource_coordinator/coordination_unit/frame_coordination_unit_impl.h"
+#include "services/resource_coordinator/coordination_unit/page_coordination_unit_impl.h"
+#include "services/resource_coordinator/coordination_unit/process_coordination_unit_impl.h"
+
+#include <algorithm>
+#include <iterator>
+
+#include "base/macros.h"
+#include "base/process/process_handle.h"
+
+namespace resource_coordinator {
+
+SystemCoordinationUnitImpl::SystemCoordinationUnitImpl(
+    const CoordinationUnitID& id,
+    CoordinationUnitGraph* graph,
+    std::unique_ptr<service_manager::ServiceKeepaliveRef> keepalive_ref)
+    : CoordinationUnitInterface(id, graph, std::move(keepalive_ref)) {}
+
+SystemCoordinationUnitImpl::~SystemCoordinationUnitImpl() = default;
+
+void SystemCoordinationUnitImpl::OnProcessCPUUsageReady() {
+  SendEvent(mojom::Event::kProcessCPUUsageReady);
+}
+
+void SystemCoordinationUnitImpl::DistributeMeasurementBatch(
+    mojom::ProcessResourceMeasurementBatchPtr measurement_batch) {
+  base::TimeDelta time_since_last_measurement;
+  if (!last_measurement_end_time_.is_null()) {
+    // Use the end of the measurement batch as a proxy for when every
+    // measurement was acquired. For the purpose of estimating CPU usage
+    // over the duration from last measurement, it'll be near enough. The error
+    // will average out, and there's an inherent race in knowing when a
+    // measurement was actually acquired in any case.
+    time_since_last_measurement =
+        measurement_batch->batch_ended_time - last_measurement_end_time_;
+    DCHECK_LE(base::TimeDelta(), time_since_last_measurement);
+  }
+
+  // TODO(siggi): Need to decide what to do with measurements that span an
+  //    absurd length of time, or which are missing a significant portion of the
+  //    data wanted/required. Maybe there should be a filtering step here, or
+  //    perhaps this should be up to the consumers, who can perhaps better
+  //    assess whether the gaps affect them. This would require propagating more
+  //    information through the graph. Perhaps each page could maintain the
+  //    min/max span for all the data that went into the current estimates.
+  last_measurement_start_time_ = measurement_batch->batch_started_time;
+  last_measurement_end_time_ = measurement_batch->batch_ended_time;
+
+  // Keep track of the pages updated with CPU cost for the second pass,
+  // where their memory usage is updated.
+  std::set<PageCoordinationUnitImpl*> pages;
+  std::vector<ProcessCoordinationUnitImpl*> found_processes;
+  for (const auto& measurement : measurement_batch->measurements) {
+    ProcessCoordinationUnitImpl* process =
+        graph()->GetProcessCoordinationUnitByPid(measurement->pid);
+    if (process) {
+      base::TimeDelta cumulative_cpu_delta =
+          measurement->cpu_usage - process->cumulative_cpu_usage();
+      DCHECK_LE(base::TimeDelta(), cumulative_cpu_delta);
+
+      // Distribute the CPU delta to the pages that own the frames in this
+      // process.
+      std::set<FrameCoordinationUnitImpl*> frames =
+          process->GetFrameCoordinationUnits();
+      if (!frames.empty()) {
+        // To make sure we don't systemically truncate the remainder of the
+        // delta, simply subtract the remainder and "hold it back" from the
+        // measurement. Since our measurement is cumulative, we'll see that
+        // CPU time again in the next measurement.
+        cumulative_cpu_delta -=
+            cumulative_cpu_delta %
+            base::TimeDelta::FromMicroseconds(frames.size());
+
+        for (FrameCoordinationUnitImpl* frame : frames) {
+          PageCoordinationUnitImpl* page = frame->GetPageCoordinationUnit();
+          if (page) {
+            page->set_usage_estimate_time(last_measurement_end_time_);
+            page->set_cumulative_cpu_usage_estimate(
+                page->cumulative_cpu_usage_estimate() +
+                cumulative_cpu_delta / frames.size());
+
+            pages.insert(page);
+          }
+        }
+      } else {
+        // TODO(siggi): The process has zero frames, maybe this is a newly
+        //    started renderer and if so, this might be a good place to
+        //    estimate the process overhead. Alternatively perhaps the first
+        //    measurement for each process, or a lower bound thereof will
+        //    converge to a decent estimate.
+      }
+
+      if (process->cumulative_cpu_usage().is_zero() ||
+          time_since_last_measurement.is_zero()) {
+        // Imitate the behavior of GetPlatformIndependentCPUUsage, which
+        // yields zero for the initial measurement of each process.
+        process->SetCPUUsage(0.0);
+      } else {
+        double cpu_usage = 100.0 * cumulative_cpu_delta.InMicrosecondsF() /
+                           time_since_last_measurement.InMicrosecondsF();
+        process->SetCPUUsage(cpu_usage);
+      }
+      process->set_cumulative_cpu_usage(process->cumulative_cpu_usage() +
+                                        cumulative_cpu_delta);
+      process->set_private_footprint_kb(measurement->private_footprint_kb);
+
+      // Note the found processes.
+      found_processes.push_back(process);
+    }
+  }
+
+  // Grab all the processes to see if there were any we didn't get data for.
+  std::vector<ProcessCoordinationUnitImpl*> processes =
+      graph_->GetAllProcessCoordinationUnits();
+
+  if (found_processes.size() != processes.size()) {
+    // We didn't find them all, compute the difference and clear the data for
+    // the processes we didn't find.
+    std::sort(processes.begin(), processes.end());
+    std::sort(found_processes.begin(), found_processes.end());
+    std::vector<ProcessCoordinationUnitImpl*> not_found_processes;
+    std::set_difference(
+        processes.begin(), processes.end(), found_processes.begin(),
+        found_processes.end(),
+        std::inserter(not_found_processes, not_found_processes.begin()));
+
+    // Clear processes we didn't get data for.
+    for (ProcessCoordinationUnitImpl* process : not_found_processes) {
+      process->SetCPUUsage(0.0);
+      process->set_private_footprint_kb(0);
+    }
+  }
+
+  // Iterate through the pages involved to distribute the memory to them.
+  for (PageCoordinationUnitImpl* page : pages) {
+    uint64_t private_footprint_kb_sum = 0;
+    const auto& frames = page->GetFrameCoordinationUnits();
+    for (FrameCoordinationUnitImpl* frame : frames) {
+      ProcessCoordinationUnitImpl* process =
+          frame->GetProcessCoordinationUnit();
+      if (process) {
+        private_footprint_kb_sum += process->private_footprint_kb() /
+                                    process->GetFrameCoordinationUnits().size();
+      }
+    }
+
+    page->set_private_footprint_kb_estimate(private_footprint_kb_sum);
+
+    DCHECK_EQ(last_measurement_end_time_, page->usage_estimate_time());
+  }
+
+  // Fire the end update signal.
+  OnProcessCPUUsageReady();
+}
+
+void SystemCoordinationUnitImpl::OnEventReceived(mojom::Event event) {
+  for (auto& observer : observers())
+    observer.OnSystemEventReceived(this, event);
+}
+
+void SystemCoordinationUnitImpl::OnPropertyChanged(
+    mojom::PropertyType property_type,
+    int64_t value) {
+  for (auto& observer : observers())
+    observer.OnSystemPropertyChanged(this, property_type, value);
+}
+
+}  // namespace resource_coordinator
diff -BbuN a/services/resource_coordinator/coordination_unit/system_coordination_unit_impl.h b/services/resource_coordinator/coordination_unit/system_coordination_unit_impl.h
--- a/services/resource_coordinator/coordination_unit/system_coordination_unit_impl.h	1970-01-01 03:00:00.000000000 +0300
+++ b/services/resource_coordinator/coordination_unit/system_coordination_unit_impl.h	2019-05-17 18:53:37.956000000 +0300
@@ -0,0 +1,55 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef SERVICES_RESOURCE_COORDINATOR_COORDINATION_UNIT_SYSTEM_COORDINATION_UNIT_IMPL_H_
+#define SERVICES_RESOURCE_COORDINATOR_COORDINATION_UNIT_SYSTEM_COORDINATION_UNIT_IMPL_H_
+
+#include "base/macros.h"
+#include "base/time/time.h"
+#include "services/resource_coordinator/coordination_unit/coordination_unit_base.h"
+
+namespace resource_coordinator {
+
+class SystemCoordinationUnitImpl
+    : public CoordinationUnitInterface<SystemCoordinationUnitImpl,
+                                       mojom::SystemCoordinationUnit,
+                                       mojom::SystemCoordinationUnitRequest> {
+ public:
+  static CoordinationUnitType Type() { return CoordinationUnitType::kSystem; }
+
+  SystemCoordinationUnitImpl(
+      const CoordinationUnitID& id,
+      CoordinationUnitGraph* graph,
+      std::unique_ptr<service_manager::ServiceKeepaliveRef> keepalive_ref);
+  ~SystemCoordinationUnitImpl() override;
+
+  // mojom::SystemCoordinationUnit implementation:
+  void OnProcessCPUUsageReady() override;
+  void DistributeMeasurementBatch(
+      mojom::ProcessResourceMeasurementBatchPtr measurement_batch) override;
+
+  // Accessors for the start/end times bracketing when the last performance
+  // measurement occurred.
+  base::TimeTicks last_measurement_start_time() const {
+    return last_measurement_start_time_;
+  }
+  base::TimeTicks last_measurement_end_time() const {
+    return last_measurement_end_time_;
+  }
+
+ private:
+  base::TimeTicks last_measurement_start_time_;
+  base::TimeTicks last_measurement_end_time_;
+
+  // CoordinationUnitInterface implementation:
+  void OnEventReceived(mojom::Event event) override;
+  void OnPropertyChanged(mojom::PropertyType property_type,
+                         int64_t value) override;
+
+  DISALLOW_COPY_AND_ASSIGN(SystemCoordinationUnitImpl);
+};
+
+}  // namespace resource_coordinator
+
+#endif  // SERVICES_RESOURCE_COORDINATOR_COORDINATION_UNIT_SYSTEM_COORDINATION_UNIT_IMPL_H_
diff -BbuN a/services/resource_coordinator/coordination_unit/system_coordination_unit_impl_unittest.cc b/services/resource_coordinator/coordination_unit/system_coordination_unit_impl_unittest.cc
--- a/services/resource_coordinator/coordination_unit/system_coordination_unit_impl_unittest.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/services/resource_coordinator/coordination_unit/system_coordination_unit_impl_unittest.cc	2019-05-17 18:53:37.960000000 +0300
@@ -0,0 +1,205 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "services/resource_coordinator/coordination_unit/system_coordination_unit_impl.h"
+
+#include "base/test/simple_test_tick_clock.h"
+#include "services/resource_coordinator/coordination_unit/coordination_unit_test_harness.h"
+#include "services/resource_coordinator/coordination_unit/frame_coordination_unit_impl.h"
+#include "services/resource_coordinator/coordination_unit/mock_coordination_unit_graphs.h"
+#include "services/resource_coordinator/coordination_unit/page_coordination_unit_impl.h"
+#include "services/resource_coordinator/coordination_unit/process_coordination_unit_impl.h"
+#include "services/resource_coordinator/coordination_unit/system_coordination_unit_impl.h"
+#include "services/resource_coordinator/observers/coordination_unit_graph_observer.h"
+#include "services/resource_coordinator/resource_coordinator_clock.h"
+#include "testing/gtest/include/gtest/gtest.h"
+
+namespace resource_coordinator {
+
+namespace {
+
+// Observer used to make sure that signals are dispatched correctly.
+class SystemAndProcessObserver : public CoordinationUnitGraphObserver {
+ public:
+  // CoordinationUnitGraphObserver implementation:
+  bool ShouldObserve(const CoordinationUnitBase* coordination_unit) override {
+    auto cu_type = coordination_unit->id().type;
+    return cu_type == CoordinationUnitType::kSystem;
+  }
+
+  void OnSystemEventReceived(const SystemCoordinationUnitImpl* system_cu,
+                             const mojom::Event event) override {
+    EXPECT_EQ(mojom::Event::kProcessCPUUsageReady, event);
+    ++system_event_seen_count_;
+  }
+
+  void OnProcessPropertyChanged(const ProcessCoordinationUnitImpl* process_cu,
+                                const mojom::PropertyType property,
+                                int64_t value) override {
+    ++process_property_change_seen_count_;
+  }
+
+  size_t system_event_seen_count() const { return system_event_seen_count_; }
+  size_t process_property_change_seen_count() const {
+    return process_property_change_seen_count_;
+  }
+
+ private:
+  size_t system_event_seen_count_ = 0;
+  size_t process_property_change_seen_count_ = 0;
+};
+
+class SystemCoordinationUnitImplTest : public CoordinationUnitTestHarness {
+ public:
+  void SetUp() override {
+    ResourceCoordinatorClock::SetClockForTesting(&clock_);
+
+    // Sets a valid starting time.
+    clock_.SetNowTicks(base::TimeTicks::Now());
+  }
+
+  void TearDown() override { ResourceCoordinatorClock::ResetClockForTesting(); }
+
+ protected:
+  void AdvanceClock(base::TimeDelta delta) { clock_.Advance(delta); }
+
+ private:
+  base::SimpleTestTickClock clock_;
+};
+
+mojom::ProcessResourceMeasurementBatchPtr CreateMeasurementBatch(
+    base::TimeTicks start_end_time,
+    size_t num_processes,
+    base::TimeDelta additional_cpu_time) {
+  mojom::ProcessResourceMeasurementBatchPtr batch =
+      mojom::ProcessResourceMeasurementBatch::New();
+  batch->batch_started_time = start_end_time;
+  batch->batch_ended_time = start_end_time;
+
+  for (size_t i = 1; i <= num_processes; ++i) {
+    mojom::ProcessResourceMeasurementPtr measurement =
+        mojom::ProcessResourceMeasurement::New();
+    measurement->pid = i;
+    measurement->cpu_usage =
+        base::TimeDelta::FromMicroseconds(i * 10) + additional_cpu_time;
+    measurement->private_footprint_kb = static_cast<uint32_t>(i * 100);
+
+    batch->measurements.push_back(std::move(measurement));
+  }
+
+  return batch;
+}
+
+}  // namespace
+
+TEST_F(SystemCoordinationUnitImplTest, OnProcessCPUUsageReady) {
+  SystemAndProcessObserver observer;
+  MockMultiplePagesWithMultipleProcessesCoordinationUnitGraph cu_graph(
+      coordination_unit_graph());
+  cu_graph.system->AddObserver(&observer);
+  EXPECT_EQ(0u, observer.system_event_seen_count());
+  cu_graph.system->OnProcessCPUUsageReady();
+  EXPECT_EQ(1u, observer.system_event_seen_count());
+}
+
+TEST_F(SystemCoordinationUnitImplTest, DistributeMeasurementBatch) {
+  SystemAndProcessObserver observer;
+  MockMultiplePagesWithMultipleProcessesCoordinationUnitGraph cu_graph(
+      coordination_unit_graph());
+  cu_graph.system->AddObserver(&observer);
+  cu_graph.process->AddObserver(&observer);
+  cu_graph.other_process->AddObserver(&observer);
+
+  EXPECT_EQ(0u, observer.system_event_seen_count());
+
+  // Build and dispatch a measurement batch.
+  base::TimeTicks start_time = base::TimeTicks::Now();
+  EXPECT_EQ(0U, observer.process_property_change_seen_count());
+  cu_graph.system->DistributeMeasurementBatch(
+      CreateMeasurementBatch(start_time, 3, base::TimeDelta()));
+
+  EXPECT_EQ(start_time, cu_graph.system->last_measurement_start_time());
+  EXPECT_EQ(start_time, cu_graph.system->last_measurement_end_time());
+
+  EXPECT_EQ(2U, observer.process_property_change_seen_count());
+  EXPECT_EQ(1u, observer.system_event_seen_count());
+
+  // The first measurement batch results in a zero CPU usage for the processes.
+  int64_t cpu_usage;
+  EXPECT_TRUE(cu_graph.process->GetProperty(mojom::PropertyType::kCPUUsage,
+                                            &cpu_usage));
+  EXPECT_EQ(0, cpu_usage);
+  EXPECT_EQ(100u, cu_graph.process->private_footprint_kb());
+  EXPECT_EQ(base::TimeDelta::FromMicroseconds(10u),
+            cu_graph.process->cumulative_cpu_usage());
+
+  EXPECT_TRUE(cu_graph.other_process->GetProperty(
+      mojom::PropertyType::kCPUUsage, &cpu_usage));
+  EXPECT_EQ(0, cpu_usage);
+  EXPECT_EQ(200u, cu_graph.other_process->private_footprint_kb());
+  EXPECT_EQ(base::TimeDelta::FromMicroseconds(20u),
+            cu_graph.other_process->cumulative_cpu_usage());
+
+  EXPECT_EQ(base::TimeDelta::FromMicroseconds(5),
+            cu_graph.page->cumulative_cpu_usage_estimate());
+  EXPECT_EQ(50u, cu_graph.page->private_footprint_kb_estimate());
+
+  EXPECT_EQ(base::TimeDelta::FromMicroseconds(25),
+            cu_graph.other_page->cumulative_cpu_usage_estimate());
+  EXPECT_EQ(250u, cu_graph.other_page->private_footprint_kb_estimate());
+
+  // Dispatch another batch, and verify the CPUUsage is appropriately updated.
+  cu_graph.system->DistributeMeasurementBatch(
+      CreateMeasurementBatch(start_time + base::TimeDelta::FromMicroseconds(10),
+                             3, base::TimeDelta::FromMicroseconds(10)));
+  EXPECT_TRUE(cu_graph.process->GetProperty(mojom::PropertyType::kCPUUsage,
+                                            &cpu_usage));
+  EXPECT_EQ(100000, cpu_usage);
+  EXPECT_EQ(base::TimeDelta::FromMicroseconds(20u),
+            cu_graph.process->cumulative_cpu_usage());
+  EXPECT_TRUE(cu_graph.other_process->GetProperty(
+      mojom::PropertyType::kCPUUsage, &cpu_usage));
+  EXPECT_EQ(100000, cpu_usage);
+  EXPECT_EQ(base::TimeDelta::FromMicroseconds(30u),
+            cu_graph.other_process->cumulative_cpu_usage());
+
+  EXPECT_EQ(base::TimeDelta::FromMicroseconds(10),
+            cu_graph.page->cumulative_cpu_usage_estimate());
+  EXPECT_EQ(50u, cu_graph.page->private_footprint_kb_estimate());
+
+  EXPECT_EQ(base::TimeDelta::FromMicroseconds(40),
+            cu_graph.other_page->cumulative_cpu_usage_estimate());
+  EXPECT_EQ(250u, cu_graph.other_page->private_footprint_kb_estimate());
+
+  // Now test that a measurement batch that leaves out a process clears the
+  // properties of that process - except for cumulative CPU, which can only
+  // go forwards.
+  cu_graph.system->DistributeMeasurementBatch(
+      CreateMeasurementBatch(start_time + base::TimeDelta::FromMicroseconds(20),
+                             1, base::TimeDelta::FromMicroseconds(310)));
+
+  EXPECT_TRUE(cu_graph.process->GetProperty(mojom::PropertyType::kCPUUsage,
+                                            &cpu_usage));
+  EXPECT_EQ(3000000, cpu_usage);
+  EXPECT_EQ(100u, cu_graph.process->private_footprint_kb());
+  EXPECT_EQ(base::TimeDelta::FromMicroseconds(320u),
+            cu_graph.process->cumulative_cpu_usage());
+
+  EXPECT_TRUE(cu_graph.other_process->GetProperty(
+      mojom::PropertyType::kCPUUsage, &cpu_usage));
+  EXPECT_EQ(0, cpu_usage);
+  EXPECT_EQ(0u, cu_graph.other_process->private_footprint_kb());
+  EXPECT_EQ(base::TimeDelta::FromMicroseconds(30u),
+            cu_graph.other_process->cumulative_cpu_usage());
+
+  EXPECT_EQ(base::TimeDelta::FromMicroseconds(160),
+            cu_graph.page->cumulative_cpu_usage_estimate());
+  EXPECT_EQ(50u, cu_graph.page->private_footprint_kb_estimate());
+
+  EXPECT_EQ(base::TimeDelta::FromMicroseconds(190),
+            cu_graph.other_page->cumulative_cpu_usage_estimate());
+  EXPECT_EQ(50u, cu_graph.other_page->private_footprint_kb_estimate());
+}
+
+}  // namespace resource_coordinator
--- a/services/resource_coordinator/manifest.json	1970-01-01 03:00:00.000000000 +0300
+++ b/services/resource_coordinator/manifest.json	2019-05-17 18:53:37.960000000 +0300
@@ -0,0 +1,32 @@
+{
+  "name": "resource_coordinator",
+  "display_name": "Global Resource Coordinator",
+  "options" : {
+    "instance_sharing" : "shared_instance_across_users"
+  },
+  "interface_provider_specs": {
+    "service_manager:connector": {
+      "provides": {
+        "app": [
+          "memory_instrumentation.mojom.Coordinator"
+        ],
+        "coordination_unit_introspector": [
+          "resource_coordinator.mojom.CoordinationUnitIntrospector"
+        ],
+        "coordination_unit": [ "resource_coordinator.mojom.CoordinationUnitProvider" ],
+        "heap_profiler_helper": [ "memory_instrumentation.mojom.HeapProfilerHelper" ],
+        "page_signal": [ "resource_coordinator.mojom.PageSignalGenerator" ],
+        "webui_graph_dump": [ "resource_coordinator.mojom.WebUIGraphDump" ],
+        "tests": [ "*" ]
+      },
+      "requires": {
+        "service_manager": [
+          "service_manager:service_manager"
+        ],
+        "metrics": [
+          "url_keyed_metrics"
+        ]
+      }
+    }
+  }
+}
diff -BbuN a/services/resource_coordinator/observers/background_metrics_reporter.h b/services/resource_coordinator/observers/background_metrics_reporter.h
--- a/services/resource_coordinator/observers/background_metrics_reporter.h	1970-01-01 03:00:00.000000000 +0300
+++ b/services/resource_coordinator/observers/background_metrics_reporter.h	2019-05-17 18:53:37.960000000 +0300
@@ -0,0 +1,133 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef SERVICES_RESOURCE_COORDINATOR_OBSERVER_BACKGROUND_METRICS_REPORTER_H_
+#define SERVICES_RESOURCE_COORDINATOR_OBSERVER_BACKGROUND_METRICS_REPORTER_H_
+
+#include "base/macros.h"
+#include "base/metrics/histogram_macros.h"
+#include "base/time/time.h"
+#include "services/metrics/public/cpp/ukm_builders.h"
+#include "services/metrics/public/cpp/ukm_source_id.h"
+
+// Pages can be kept in the background for a long time, metrics show 75th
+// percentile of time spent in background is 2.5 hours, and the 95th is 24 hour.
+// In order to guide the selection of an appropriate observation window we are
+// proposing using a CUSTOM_TIMES histogram from 1s to 48h, with 100 buckets.
+#define HEURISTICS_HISTOGRAM(name, sample)                                  \
+  UMA_HISTOGRAM_CUSTOM_TIMES(name, sample, base::TimeDelta::FromSeconds(1), \
+                             base::TimeDelta::FromHours(48), 100)
+
+namespace resource_coordinator {
+
+namespace internal {
+
+enum UKMFrameReportType : uint8_t {
+  kMainFrameOnly = 0,
+  kMainFrameAndChildFrame
+};
+
+template <class UKMBuilderClass,
+          internal::UKMFrameReportType kShouldReportChildFrameUkm>
+class UKMReportDelegate {};
+
+template <class UKMBuilderClass>
+class UKMReportDelegate<UKMBuilderClass, internal::kMainFrameOnly> {
+ public:
+  void ReportUKM(int64_t ukm_source_id,
+                 bool is_main_frame,
+                 int64_t duration_in_ms,
+                 ukm::UkmRecorder* ukm_recorder) {
+    UKMBuilderClass ukm_builder(ukm_source_id);
+    ukm_builder.SetTimeFromBackgrounded(duration_in_ms).Record(ukm_recorder);
+  }
+};
+
+template <class UKMBuilderClass>
+class UKMReportDelegate<UKMBuilderClass, internal::kMainFrameAndChildFrame> {
+ public:
+  void ReportUKM(int64_t ukm_source_id,
+                 bool is_main_frame,
+                 int64_t duration_in_ms,
+                 ukm::UkmRecorder* ukm_recorder) {
+    UKMBuilderClass ukm_builder(ukm_source_id);
+    ukm_builder.SetIsMainFrame(is_main_frame)
+        .SetTimeFromBackgrounded(duration_in_ms)
+        .Record(ukm_recorder);
+  }
+};
+
+}  // namespace internal
+
+template <class UKMBuilderClass,
+          const char* kMetricName,
+          internal::UKMFrameReportType kShouldReportChildFrameUkm>
+class BackgroundMetricsReporter {
+ public:
+  BackgroundMetricsReporter()
+      : ukm_source_id_(ukm::kInvalidSourceId),
+        uma_reported_(false),
+        ukm_reported_(false),
+        child_frame_ukm_reported_(false) {}
+
+  void Reset() {
+    uma_reported_ = false;
+    ukm_reported_ = false;
+    child_frame_ukm_reported_ = false;
+  }
+
+  void SetUKMSourceID(int64_t ukm_source_id) { ukm_source_id_ = ukm_source_id; }
+
+  void OnSignalReceived(bool is_main_frame,
+                        base::TimeDelta duration,
+                        ukm::UkmRecorder* ukm_recorder) {
+    if (!uma_reported_) {
+      uma_reported_ = true;
+      HEURISTICS_HISTOGRAM(kMetricName, duration);
+    }
+
+    ReportUKMIfNeeded(is_main_frame, duration, ukm_recorder);
+  }
+
+ private:
+  void ReportUKMIfNeeded(bool is_main_frame,
+                         base::TimeDelta duration,
+                         ukm::UkmRecorder* ukm_recorder) {
+    if (ukm_source_id_ == ukm::kInvalidSourceId ||
+        (!kShouldReportChildFrameUkm && ukm_reported_) ||
+        (kShouldReportChildFrameUkm &&
+         !ShouldReportMainFrameUKM(is_main_frame) &&
+         !ShouldReportChildFrameUKM(is_main_frame))) {
+      return;
+    }
+
+    ukm_reporter_.ReportUKM(ukm_source_id_, is_main_frame,
+                            duration.InMilliseconds(), ukm_recorder);
+
+    if (is_main_frame) {
+      ukm_reported_ = true;
+    } else {
+      child_frame_ukm_reported_ = true;
+    }
+  }
+
+  bool ShouldReportMainFrameUKM(bool is_main_frame) const {
+    return is_main_frame && !ukm_reported_;
+  }
+
+  bool ShouldReportChildFrameUKM(bool is_main_frame) const {
+    return !is_main_frame && !child_frame_ukm_reported_;
+  }
+
+  int64_t ukm_source_id_;
+  bool uma_reported_;
+  bool ukm_reported_;
+  bool child_frame_ukm_reported_;
+  internal::UKMReportDelegate<UKMBuilderClass, kShouldReportChildFrameUkm>
+      ukm_reporter_;
+};
+
+}  // namespace resource_coordinator
+
+#endif  // SERVICES_RESOURCE_COORDINATOR_OBSERVER_BACKGROUND_METRICS_REPORTER_H_
diff -BbuN a/services/resource_coordinator/observers/coordination_unit_graph_observer.cc b/services/resource_coordinator/observers/coordination_unit_graph_observer.cc
--- a/services/resource_coordinator/observers/coordination_unit_graph_observer.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/services/resource_coordinator/observers/coordination_unit_graph_observer.cc	2019-05-17 18:53:37.960000000 +0300
@@ -0,0 +1,13 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "services/resource_coordinator/observers/coordination_unit_graph_observer.h"
+
+namespace resource_coordinator {
+
+CoordinationUnitGraphObserver::CoordinationUnitGraphObserver() = default;
+
+CoordinationUnitGraphObserver::~CoordinationUnitGraphObserver() = default;
+
+}  // namespace resource_coordinator
diff -BbuN a/services/resource_coordinator/observers/coordination_unit_graph_observer.h b/services/resource_coordinator/observers/coordination_unit_graph_observer.h
--- a/services/resource_coordinator/observers/coordination_unit_graph_observer.h	1970-01-01 03:00:00.000000000 +0300
+++ b/services/resource_coordinator/observers/coordination_unit_graph_observer.h	2019-05-17 18:53:37.960000000 +0300
@@ -0,0 +1,115 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef SERVICES_RESOURCE_COORDINATOR_COORDINATION_UNIT_COORDINATION_UNIT_GRAPH_OBSERVER_H_
+#define SERVICES_RESOURCE_COORDINATOR_COORDINATION_UNIT_COORDINATION_UNIT_GRAPH_OBSERVER_H_
+
+#include "base/macros.h"
+#include "services/resource_coordinator/public/mojom/coordination_unit.mojom.h"
+
+namespace resource_coordinator {
+
+class CoordinationUnitBase;
+class CoordinationUnitGraph;
+class FrameCoordinationUnitImpl;
+class PageCoordinationUnitImpl;
+class ProcessCoordinationUnitImpl;
+class SystemCoordinationUnitImpl;
+
+// An observer API for the coordination unit graph maintained by GRC.
+//
+// Observers are instantiated when the resource_coordinator service
+// is created and are destroyed when the resource_coordinator service
+// is destroyed. Therefore observers are guaranteed to be alive before
+// any coordination unit is created and will be alive after any
+// coordination unit is destroyed. Additionally, any
+// Coordination Unit reachable within a callback will always be
+// initialized and valid.
+//
+// To create and install a new observer:
+//   (1) Derive from this class.
+//   (2) Register by calling on |coordination_unit_graph().RegisterObserver|
+//       inside of the ResourceCoordinatorService::Create.
+class CoordinationUnitGraphObserver {
+ public:
+  CoordinationUnitGraphObserver();
+  virtual ~CoordinationUnitGraphObserver();
+
+  // Determines whether or not the observer should be registered with, and
+  // invoked for, the |coordination_unit|.
+  virtual bool ShouldObserve(const CoordinationUnitBase* coordination_unit) = 0;
+
+  // Called whenever a CoordinationUnit is created.
+  virtual void OnCoordinationUnitCreated(
+      const CoordinationUnitBase* coordination_unit) {}
+
+  // Called when the |coordination_unit| is about to be destroyed.
+  virtual void OnBeforeCoordinationUnitDestroyed(
+      const CoordinationUnitBase* coordination_unit) {}
+
+  // Called whenever a property of the |coordination_unit| is changed if the
+  // |coordination_unit| doesn't implement its own PropertyChanged handler.
+  virtual void OnPropertyChanged(const CoordinationUnitBase* coordination_unit,
+                                 const mojom::PropertyType property_type,
+                                 int64_t value) {}
+
+  // Called whenever a property of the FrameCoordinationUnit is changed.
+  virtual void OnFramePropertyChanged(const FrameCoordinationUnitImpl* frame_cu,
+                                      const mojom::PropertyType property_type,
+                                      int64_t value) {}
+
+  // Called whenever a property of the PageCoordinationUnit is changed.
+  virtual void OnPagePropertyChanged(const PageCoordinationUnitImpl* page_cu,
+                                     const mojom::PropertyType property_type,
+                                     int64_t value) {}
+
+  // Called whenever a property of the ProcessCoordinationUnit is changed.
+  virtual void OnProcessPropertyChanged(
+      const ProcessCoordinationUnitImpl* process_cu,
+      const mojom::PropertyType property_type,
+      int64_t value) {}
+
+  // Called whenever a property of the SystemCoordinationUnit is changed.
+  virtual void OnSystemPropertyChanged(
+      const SystemCoordinationUnitImpl* system_cu,
+      const mojom::PropertyType property_type,
+      int64_t value) {}
+
+  // Called whenever an event is received in |coordination_unit| if the
+  // |coordination_unit| doesn't implement its own EventReceived handler.
+  virtual void OnEventReceived(const CoordinationUnitBase* coordination_unit,
+                               const mojom::Event event) {}
+  virtual void OnFrameEventReceived(const FrameCoordinationUnitImpl* frame_cu,
+                                    const mojom::Event event) {}
+  virtual void OnPageEventReceived(const PageCoordinationUnitImpl* page_cu,
+                                   const mojom::Event event) {}
+  virtual void OnProcessEventReceived(
+      const ProcessCoordinationUnitImpl* process_cu,
+      const mojom::Event event) {}
+  virtual void OnSystemEventReceived(
+      const SystemCoordinationUnitImpl* system_cu,
+      const mojom::Event event) {}
+
+  // Called when all the frames in a process become frozen.
+  virtual void OnAllFramesInProcessFrozen(
+      const ProcessCoordinationUnitImpl* process_cu) {}
+
+  void set_coordination_unit_graph(
+      CoordinationUnitGraph* coordination_unit_graph) {
+    coordination_unit_graph_ = coordination_unit_graph;
+  }
+
+  const CoordinationUnitGraph& coordination_unit_graph() const {
+    return *coordination_unit_graph_;
+  }
+
+ private:
+  CoordinationUnitGraph* coordination_unit_graph_ = nullptr;
+
+  DISALLOW_COPY_AND_ASSIGN(CoordinationUnitGraphObserver);
+};
+
+}  // namespace resource_coordinator
+
+#endif  // SERVICES_RESOURCE_COORDINATOR_COORDINATION_UNIT_COORDINATION_UNIT_GRAPH_OBSERVER_H_
diff -BbuN a/services/resource_coordinator/observers/coordination_unit_graph_observer_unittest.cc b/services/resource_coordinator/observers/coordination_unit_graph_observer_unittest.cc
--- a/services/resource_coordinator/observers/coordination_unit_graph_observer_unittest.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/services/resource_coordinator/observers/coordination_unit_graph_observer_unittest.cc	2019-05-17 18:53:37.960000000 +0300
@@ -0,0 +1,94 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "services/resource_coordinator/observers/coordination_unit_graph_observer.h"
+
+#include "base/process/process_handle.h"
+#include "services/resource_coordinator/coordination_unit/coordination_unit_graph.h"
+#include "services/resource_coordinator/coordination_unit/coordination_unit_test_harness.h"
+#include "services/resource_coordinator/coordination_unit/frame_coordination_unit_impl.h"
+#include "services/resource_coordinator/coordination_unit/process_coordination_unit_impl.h"
+#include "services/resource_coordinator/public/cpp/coordination_unit_id.h"
+#include "services/resource_coordinator/public/cpp/coordination_unit_types.h"
+#include "services/resource_coordinator/public/mojom/coordination_unit.mojom.h"
+#include "testing/gtest/include/gtest/gtest.h"
+
+namespace resource_coordinator {
+
+namespace {
+
+class CoordinationUnitGraphObserverTest : public CoordinationUnitTestHarness {};
+
+class TestCoordinationUnitGraphObserver : public CoordinationUnitGraphObserver {
+ public:
+  TestCoordinationUnitGraphObserver()
+      : coordination_unit_created_count_(0u),
+        coordination_unit_destroyed_count_(0u),
+        property_changed_count_(0u) {}
+
+  size_t coordination_unit_created_count() {
+    return coordination_unit_created_count_;
+  }
+  size_t coordination_unit_destroyed_count() {
+    return coordination_unit_destroyed_count_;
+  }
+  size_t property_changed_count() { return property_changed_count_; }
+
+  // Overridden from CoordinationUnitGraphObserver.
+  bool ShouldObserve(const CoordinationUnitBase* coordination_unit) override {
+    return coordination_unit->id().type == CoordinationUnitType::kFrame;
+  }
+  void OnCoordinationUnitCreated(
+      const CoordinationUnitBase* coordination_unit) override {
+    ++coordination_unit_created_count_;
+  }
+  void OnBeforeCoordinationUnitDestroyed(
+      const CoordinationUnitBase* coordination_unit) override {
+    ++coordination_unit_destroyed_count_;
+  }
+  void OnFramePropertyChanged(
+      const FrameCoordinationUnitImpl* frame_coordination_unit,
+      const mojom::PropertyType property_type,
+      int64_t value) override {
+    ++property_changed_count_;
+  }
+
+ private:
+  size_t coordination_unit_created_count_;
+  size_t coordination_unit_destroyed_count_;
+  size_t property_changed_count_;
+};
+
+}  // namespace
+
+TEST_F(CoordinationUnitGraphObserverTest, CallbacksInvoked) {
+  EXPECT_TRUE(coordination_unit_graph()->observers_for_testing().empty());
+  coordination_unit_graph()->RegisterObserver(
+      std::make_unique<TestCoordinationUnitGraphObserver>());
+  EXPECT_EQ(1u, coordination_unit_graph()->observers_for_testing().size());
+
+  TestCoordinationUnitGraphObserver* observer =
+      static_cast<TestCoordinationUnitGraphObserver*>(
+          coordination_unit_graph()->observers_for_testing()[0].get());
+
+  {
+    auto process_cu = CreateCoordinationUnit<ProcessCoordinationUnitImpl>();
+    auto root_frame_cu = CreateCoordinationUnit<FrameCoordinationUnitImpl>();
+    auto frame_cu = CreateCoordinationUnit<FrameCoordinationUnitImpl>();
+
+    EXPECT_EQ(2u, observer->coordination_unit_created_count());
+
+    // The registered observer will only observe the events that happen to
+    // |root_frame_coordination_unit| and |frame_coordination_unit| because
+    // they are CoordinationUnitType::kFrame, so OnPropertyChanged
+    // will only be called for |root_frame_coordination_unit|.
+    root_frame_cu->SetPropertyForTesting(42);
+    process_cu->SetPropertyForTesting(42);
+    EXPECT_EQ(1u, observer->property_changed_count());
+  }
+
+  EXPECT_EQ(2u, observer->coordination_unit_destroyed_count());
+}
+
+}  // namespace resource_coordinator
diff -BbuN a/services/resource_coordinator/observers/metrics_collector.cc b/services/resource_coordinator/observers/metrics_collector.cc
--- a/services/resource_coordinator/observers/metrics_collector.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/services/resource_coordinator/observers/metrics_collector.cc	2019-05-17 18:53:37.960000000 +0300
@@ -0,0 +1,218 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "services/resource_coordinator/observers/metrics_collector.h"
+
+#include "base/metrics/field_trial_params.h"
+#include "base/metrics/histogram_macros.h"
+#include "services/resource_coordinator/coordination_unit/coordination_unit_graph.h"
+#include "services/resource_coordinator/coordination_unit/frame_coordination_unit_impl.h"
+#include "services/resource_coordinator/coordination_unit/page_coordination_unit_impl.h"
+#include "services/resource_coordinator/coordination_unit/process_coordination_unit_impl.h"
+#include "services/resource_coordinator/public/cpp/coordination_unit_id.h"
+#include "services/resource_coordinator/public/cpp/resource_coordinator_features.h"
+#include "services/resource_coordinator/resource_coordinator_clock.h"
+
+namespace resource_coordinator {
+
+// Delay the metrics report from GRC to UMA/UKM for 5 minutes from when the main
+// frame navigation is committed.
+const base::TimeDelta kMetricsReportDelayTimeout =
+    base::TimeDelta::FromMinutes(5);
+
+const char kTabFromBackgroundedToFirstFaviconUpdatedUMA[] =
+    "TabManager.Heuristics.FromBackgroundedToFirstFaviconUpdated";
+const char kTabFromBackgroundedToFirstTitleUpdatedUMA[] =
+    "TabManager.Heuristics.FromBackgroundedToFirstTitleUpdated";
+const char kTabFromBackgroundedToFirstNonPersistentNotificationCreatedUMA[] =
+    "TabManager.Heuristics."
+    "FromBackgroundedToFirstNonPersistentNotificationCreated";
+
+const int kDefaultFrequencyUkmEQTReported = 5u;
+
+// Gets the number of tabs that are co-resident in all of the render processes
+// associated with a |CoordinationUnitType::kPage| coordination unit.
+size_t GetNumCoresidentTabs(const PageCoordinationUnitImpl* page_cu) {
+  std::set<CoordinationUnitBase*> coresident_tabs;
+  for (auto* process_cu : page_cu->GetAssociatedProcessCoordinationUnits()) {
+    for (auto* associated_page_cu :
+         process_cu->GetAssociatedPageCoordinationUnits()) {
+      coresident_tabs.insert(associated_page_cu);
+    }
+  }
+  // A tab cannot be co-resident with itself.
+  return coresident_tabs.size() - 1;
+}
+
+MetricsCollector::MetricsCollector() {
+  UpdateWithFieldTrialParams();
+}
+
+MetricsCollector::~MetricsCollector() = default;
+
+bool MetricsCollector::ShouldObserve(
+    const CoordinationUnitBase* coordination_unit) {
+  return coordination_unit->id().type == CoordinationUnitType::kFrame ||
+         coordination_unit->id().type == CoordinationUnitType::kPage ||
+         coordination_unit->id().type == CoordinationUnitType::kProcess;
+}
+
+void MetricsCollector::OnCoordinationUnitCreated(
+    const CoordinationUnitBase* coordination_unit) {
+  if (coordination_unit->id().type == CoordinationUnitType::kPage) {
+    metrics_report_record_map_.emplace(coordination_unit->id(),
+                                       MetricsReportRecord());
+  }
+}
+
+void MetricsCollector::OnBeforeCoordinationUnitDestroyed(
+    const CoordinationUnitBase* coordination_unit) {
+  if (coordination_unit->id().type == CoordinationUnitType::kPage) {
+    metrics_report_record_map_.erase(coordination_unit->id());
+    ukm_collection_state_map_.erase(coordination_unit->id());
+  }
+}
+
+void MetricsCollector::OnPagePropertyChanged(
+    const PageCoordinationUnitImpl* page_cu,
+    const mojom::PropertyType property_type,
+    int64_t value) {
+  const auto page_cu_id = page_cu->id();
+  if (property_type == mojom::PropertyType::kVisible) {
+    if (value) {
+      // The page becomes visible again, clear all records in order to
+      // report metrics when page becomes invisible next time.
+      ResetMetricsReportRecord(page_cu_id);
+      return;
+    }
+  } else if (property_type == mojom::PropertyType::kUKMSourceId) {
+    ukm::SourceId ukm_source_id = value;
+    UpdateUkmSourceIdForPage(page_cu_id, ukm_source_id);
+    MetricsReportRecord& record =
+        metrics_report_record_map_.find(page_cu_id)->second;
+    record.UpdateUKMSourceID(ukm_source_id);
+  }
+}
+
+void MetricsCollector::OnProcessPropertyChanged(
+    const ProcessCoordinationUnitImpl* process_cu,
+    const mojom::PropertyType property_type,
+    int64_t value) {
+  if (property_type == mojom::PropertyType::kExpectedTaskQueueingDuration) {
+    for (auto* page_cu : process_cu->GetAssociatedPageCoordinationUnits()) {
+      if (IsCollectingExpectedQueueingTimeForUkm(page_cu->id())) {
+        int64_t expected_queueing_time;
+        if (!page_cu->GetExpectedTaskQueueingDuration(&expected_queueing_time))
+          continue;
+
+        RecordExpectedQueueingTimeForUkm(page_cu->id(), expected_queueing_time);
+      }
+    }
+  }
+}
+
+void MetricsCollector::OnFrameEventReceived(
+    const FrameCoordinationUnitImpl* frame_cu,
+    const mojom::Event event) {
+  if (event == mojom::Event::kNonPersistentNotificationCreated) {
+    auto* page_cu = frame_cu->GetPageCoordinationUnit();
+    // Only record metrics while it is backgrounded.
+    if (!page_cu || page_cu->IsVisible() || !ShouldReportMetrics(page_cu)) {
+      return;
+    }
+    MetricsReportRecord& record =
+        metrics_report_record_map_.find(page_cu->id())->second;
+    record.first_non_persistent_notification_created.OnSignalReceived(
+        frame_cu->IsMainFrame(), page_cu->TimeSinceLastVisibilityChange(),
+        coordination_unit_graph().ukm_recorder());
+  }
+}
+
+void MetricsCollector::OnPageEventReceived(
+    const PageCoordinationUnitImpl* page_cu,
+    const mojom::Event event) {
+  if (event == mojom::Event::kTitleUpdated) {
+    // Only record metrics while it is backgrounded.
+    if (page_cu->IsVisible() || !ShouldReportMetrics(page_cu))
+      return;
+    MetricsReportRecord& record =
+        metrics_report_record_map_.find(page_cu->id())->second;
+    record.first_title_updated.OnSignalReceived(
+        true, page_cu->TimeSinceLastVisibilityChange(),
+        coordination_unit_graph().ukm_recorder());
+  } else if (event == mojom::Event::kFaviconUpdated) {
+    // Only record metrics while it is backgrounded.
+    if (page_cu->IsVisible() || !ShouldReportMetrics(page_cu))
+      return;
+    MetricsReportRecord& record =
+        metrics_report_record_map_.find(page_cu->id())->second;
+    record.first_favicon_updated.OnSignalReceived(
+        true, page_cu->TimeSinceLastVisibilityChange(),
+        coordination_unit_graph().ukm_recorder());
+  }
+}
+
+bool MetricsCollector::ShouldReportMetrics(
+    const PageCoordinationUnitImpl* page_cu) {
+  return page_cu->TimeSinceLastNavigation() > kMetricsReportDelayTimeout;
+}
+
+bool MetricsCollector::IsCollectingExpectedQueueingTimeForUkm(
+    const CoordinationUnitID& page_cu_id) {
+  UkmCollectionState& state = ukm_collection_state_map_[page_cu_id];
+  return state.ukm_source_id != ukm::kInvalidSourceId &&
+         ++state.num_unreported_eqt_measurements >= frequency_ukm_eqt_reported_;
+}
+
+void MetricsCollector::RecordExpectedQueueingTimeForUkm(
+    const CoordinationUnitID& page_cu_id,
+    int64_t expected_queueing_time) {
+  UkmCollectionState& state = ukm_collection_state_map_[page_cu_id];
+  state.num_unreported_eqt_measurements = 0u;
+  ukm::builders::ResponsivenessMeasurement(state.ukm_source_id)
+      .SetExpectedTaskQueueingDuration(expected_queueing_time)
+      .Record(coordination_unit_graph().ukm_recorder());
+}
+
+void MetricsCollector::UpdateUkmSourceIdForPage(
+    const CoordinationUnitID& page_cu_id,
+    ukm::SourceId ukm_source_id) {
+  UkmCollectionState& state = ukm_collection_state_map_[page_cu_id];
+
+  state.ukm_source_id = ukm_source_id;
+  // Updating the |ukm_source_id| restarts usage collection.
+  state.num_unreported_eqt_measurements = 0u;
+}
+
+void MetricsCollector::UpdateWithFieldTrialParams() {
+  frequency_ukm_eqt_reported_ = base::GetFieldTrialParamByFeatureAsInt(
+      ukm::kUkmFeature, "FrequencyUKMExpectedQueueingTime",
+      kDefaultFrequencyUkmEQTReported);
+}
+
+void MetricsCollector::ResetMetricsReportRecord(CoordinationUnitID cu_id) {
+  DCHECK(metrics_report_record_map_.find(cu_id) !=
+         metrics_report_record_map_.end());
+  metrics_report_record_map_.find(cu_id)->second.Reset();
+}
+
+MetricsCollector::MetricsReportRecord::MetricsReportRecord() = default;
+
+MetricsCollector::MetricsReportRecord::MetricsReportRecord(
+    const MetricsReportRecord& other) = default;
+
+void MetricsCollector::MetricsReportRecord::UpdateUKMSourceID(
+    int64_t ukm_source_id) {
+  first_favicon_updated.SetUKMSourceID(ukm_source_id);
+  first_non_persistent_notification_created.SetUKMSourceID(ukm_source_id);
+  first_title_updated.SetUKMSourceID(ukm_source_id);
+}
+
+void MetricsCollector::MetricsReportRecord::Reset() {
+  first_favicon_updated.Reset();
+  first_non_persistent_notification_created.Reset();
+  first_title_updated.Reset();
+}
+
+}  // namespace resource_coordinator
diff -BbuN a/services/resource_coordinator/observers/metrics_collector.h b/services/resource_coordinator/observers/metrics_collector.h
--- a/services/resource_coordinator/observers/metrics_collector.h	1970-01-01 03:00:00.000000000 +0300
+++ b/services/resource_coordinator/observers/metrics_collector.h	2019-05-17 18:53:37.960000000 +0300
@@ -0,0 +1,105 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef SERVICES_RESOURCE_COORDINATOR_COORDINATION_UNIT_METRICS_COLLECTOR_H_
+#define SERVICES_RESOURCE_COORDINATOR_COORDINATION_UNIT_METRICS_COLLECTOR_H_
+
+#include "base/macros.h"
+#include "base/metrics/histogram_macros.h"
+#include "base/time/time.h"
+#include "services/metrics/public/cpp/ukm_builders.h"
+#include "services/metrics/public/cpp/ukm_source_id.h"
+#include "services/resource_coordinator/observers/background_metrics_reporter.h"
+#include "services/resource_coordinator/observers/coordination_unit_graph_observer.h"
+
+namespace resource_coordinator {
+
+class CoordinationUnitBase;
+class FrameCoordinationUnitImpl;
+class PageCoordinationUnitImpl;
+
+extern const char kTabFromBackgroundedToFirstFaviconUpdatedUMA[];
+extern const char kTabFromBackgroundedToFirstTitleUpdatedUMA[];
+extern const char
+    kTabFromBackgroundedToFirstNonPersistentNotificationCreatedUMA[];
+extern const base::TimeDelta kMetricsReportDelayTimeout;
+extern const int kDefaultFrequencyUkmEQTReported;
+
+// A MetricsCollector observes changes happened inside CoordinationUnit Graph,
+// and reports UMA/UKM.
+class MetricsCollector : public CoordinationUnitGraphObserver {
+ public:
+  MetricsCollector();
+  ~MetricsCollector() override;
+
+  // CoordinationUnitGraphObserver implementation.
+  bool ShouldObserve(const CoordinationUnitBase* coordination_unit) override;
+  void OnCoordinationUnitCreated(
+      const CoordinationUnitBase* coordination_unit) override;
+  void OnBeforeCoordinationUnitDestroyed(
+      const CoordinationUnitBase* coordination_unit) override;
+  void OnPagePropertyChanged(const PageCoordinationUnitImpl* page_cu,
+                             const mojom::PropertyType property_type,
+                             int64_t value) override;
+  void OnProcessPropertyChanged(const ProcessCoordinationUnitImpl* process_cu,
+                                const mojom::PropertyType property_type,
+                                int64_t value) override;
+  void OnFrameEventReceived(const FrameCoordinationUnitImpl* frame_cu,
+                            const mojom::Event event) override;
+  void OnPageEventReceived(const PageCoordinationUnitImpl* page_cu,
+                           const mojom::Event event) override;
+
+ private:
+  struct MetricsReportRecord {
+    MetricsReportRecord();
+    MetricsReportRecord(const MetricsReportRecord& other);
+    void UpdateUKMSourceID(int64_t ukm_source_id);
+    void Reset();
+    BackgroundMetricsReporter<
+        ukm::builders::TabManager_Background_FirstFaviconUpdated,
+        kTabFromBackgroundedToFirstFaviconUpdatedUMA,
+        internal::UKMFrameReportType::kMainFrameOnly>
+        first_favicon_updated;
+    BackgroundMetricsReporter<
+        ukm::builders::
+            TabManager_Background_FirstNonPersistentNotificationCreated,
+        kTabFromBackgroundedToFirstNonPersistentNotificationCreatedUMA,
+        internal::UKMFrameReportType::kMainFrameAndChildFrame>
+        first_non_persistent_notification_created;
+    BackgroundMetricsReporter<
+        ukm::builders::TabManager_Background_FirstTitleUpdated,
+        kTabFromBackgroundedToFirstTitleUpdatedUMA,
+        internal::UKMFrameReportType::kMainFrameOnly>
+        first_title_updated;
+  };
+
+  struct UkmCollectionState {
+    int num_unreported_eqt_measurements = 0u;
+    ukm::SourceId ukm_source_id = ukm::kInvalidSourceId;
+  };
+
+  bool ShouldReportMetrics(const PageCoordinationUnitImpl* page_cu);
+  bool IsCollectingExpectedQueueingTimeForUkm(
+      const CoordinationUnitID& page_cu_id);
+  void RecordExpectedQueueingTimeForUkm(const CoordinationUnitID& page_cu_id,
+                                        int64_t expected_queueing_time);
+  void UpdateUkmSourceIdForPage(const CoordinationUnitID& page_cu_id,
+                                ukm::SourceId ukm_source_id);
+  void UpdateWithFieldTrialParams();
+  void ResetMetricsReportRecord(CoordinationUnitID cu_id);
+
+  // The metrics_report_record_map_ is used to record whether a metric was
+  // already reported to avoid reporting multiple metrics.
+  std::map<CoordinationUnitID, MetricsReportRecord> metrics_report_record_map_;
+  std::map<CoordinationUnitID, UkmCollectionState> ukm_collection_state_map_;
+  // The number of reports to wait before reporting ExpectedQueueingTime. For
+  // example, if |frequency_ukm_eqt_reported_| is 2, then the first value is not
+  // reported, the second one is, the third one isn't, etc.
+  int frequency_ukm_eqt_reported_;
+  DISALLOW_COPY_AND_ASSIGN(MetricsCollector);
+};
+
+}  // namespace resource_coordinator
+
+#endif  // SERVICES_RESOURCE_COORDINATOR_COORDINATION_UNIT_METRICS_COLLECTOR_H_
diff -BbuN a/services/resource_coordinator/observers/metrics_collector_unittest.cc b/services/resource_coordinator/observers/metrics_collector_unittest.cc
--- a/services/resource_coordinator/observers/metrics_collector_unittest.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/services/resource_coordinator/observers/metrics_collector_unittest.cc	2019-05-17 18:53:37.960000000 +0300
@@ -0,0 +1,268 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "services/resource_coordinator/observers/metrics_collector.h"
+
+#include "base/test/metrics/histogram_tester.h"
+#include "base/test/simple_test_tick_clock.h"
+#include "build/build_config.h"
+#include "components/ukm/test_ukm_recorder.h"
+#include "services/resource_coordinator/coordination_unit/coordination_unit_test_harness.h"
+#include "services/resource_coordinator/coordination_unit/frame_coordination_unit_impl.h"
+#include "services/resource_coordinator/coordination_unit/page_coordination_unit_impl.h"
+#include "services/resource_coordinator/coordination_unit/process_coordination_unit_impl.h"
+#include "services/resource_coordinator/resource_coordinator_clock.h"
+
+namespace resource_coordinator {
+
+const char kResponsivenessMeasurement[] = "ResponsivenessMeasurement";
+const char kExpectedQueueingTime[] = "ExpectedTaskQueueingDuration";
+const base::TimeDelta kTestMetricsReportDelayTimeout =
+    kMetricsReportDelayTimeout + base::TimeDelta::FromSeconds(1);
+
+// TODO(crbug.com/759905) Enable on Windows once this bug is fixed.
+#if defined(OS_WIN)
+#define MAYBE_MetricsCollectorTest DISABLED_MetricsCollectorTest
+#else
+#define MAYBE_MetricsCollectorTest MetricsCollectorTest
+#endif
+class MAYBE_MetricsCollectorTest : public CoordinationUnitTestHarness {
+ public:
+  MAYBE_MetricsCollectorTest() : CoordinationUnitTestHarness() {}
+
+  void SetUp() override {
+    MetricsCollector* metrics_collector = new MetricsCollector();
+    ResourceCoordinatorClock::SetClockForTesting(&clock_);
+
+    // Sets a valid starting time.
+    clock_.SetNowTicks(base::TimeTicks::Now());
+    coordination_unit_graph()->RegisterObserver(
+        base::WrapUnique(metrics_collector));
+  }
+
+  void TearDown() override {
+    ResourceCoordinatorClock::ResetClockForTesting();
+  }
+
+ protected:
+  static constexpr char kDummyUrl[] = "http://www.example.org";
+  static constexpr uint64_t kDummyID = 1u;
+
+  void AdvanceClock(base::TimeDelta delta) { clock_.Advance(delta); }
+
+  base::HistogramTester histogram_tester_;
+  base::SimpleTestTickClock clock_;
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(MAYBE_MetricsCollectorTest);
+};
+
+constexpr char MAYBE_MetricsCollectorTest::kDummyUrl[];
+
+TEST_F(MAYBE_MetricsCollectorTest, FromBackgroundedToFirstTitleUpdatedUMA) {
+  auto page_cu = CreateCoordinationUnit<PageCoordinationUnitImpl>();
+
+  page_cu->OnMainFrameNavigationCommitted(ResourceCoordinatorClock::NowTicks(),
+                                          kDummyID, kDummyUrl);
+  AdvanceClock(kTestMetricsReportDelayTimeout);
+
+  page_cu->SetVisibility(true);
+  page_cu->OnTitleUpdated();
+  // The page is not backgrounded, thus no metrics recorded.
+  histogram_tester_.ExpectTotalCount(kTabFromBackgroundedToFirstTitleUpdatedUMA,
+                                     0);
+
+  page_cu->SetVisibility(false);
+  page_cu->OnTitleUpdated();
+  // The page is backgrounded, thus metrics recorded.
+  histogram_tester_.ExpectTotalCount(kTabFromBackgroundedToFirstTitleUpdatedUMA,
+                                     1);
+  page_cu->OnTitleUpdated();
+  // Metrics should only be recorded once per background period, thus metrics
+  // not recorded.
+  histogram_tester_.ExpectTotalCount(kTabFromBackgroundedToFirstTitleUpdatedUMA,
+                                     1);
+
+  page_cu->SetVisibility(true);
+  page_cu->SetVisibility(false);
+  page_cu->OnTitleUpdated();
+  // The page is backgrounded from foregrounded, thus metrics recorded.
+  histogram_tester_.ExpectTotalCount(kTabFromBackgroundedToFirstTitleUpdatedUMA,
+                                     2);
+}
+
+TEST_F(MAYBE_MetricsCollectorTest,
+       FromBackgroundedToFirstTitleUpdatedUMA5MinutesTimeout) {
+  auto page_cu = CreateCoordinationUnit<PageCoordinationUnitImpl>();
+
+  page_cu->OnMainFrameNavigationCommitted(ResourceCoordinatorClock::NowTicks(),
+                                          kDummyID, kDummyUrl);
+  page_cu->SetVisibility(false);
+  page_cu->OnTitleUpdated();
+  // The page is within 5 minutes after main frame navigation was committed,
+  // thus no metrics recorded.
+  histogram_tester_.ExpectTotalCount(kTabFromBackgroundedToFirstTitleUpdatedUMA,
+                                     0);
+  AdvanceClock(kTestMetricsReportDelayTimeout);
+  page_cu->OnTitleUpdated();
+  histogram_tester_.ExpectTotalCount(kTabFromBackgroundedToFirstTitleUpdatedUMA,
+                                     1);
+}
+
+TEST_F(MAYBE_MetricsCollectorTest,
+       FromBackgroundedToFirstNonPersistentNotificationCreatedUMA) {
+  auto page_cu = CreateCoordinationUnit<PageCoordinationUnitImpl>();
+  auto frame_cu = CreateCoordinationUnit<FrameCoordinationUnitImpl>();
+  page_cu->AddFrame(frame_cu->id());
+
+  page_cu->OnMainFrameNavigationCommitted(ResourceCoordinatorClock::NowTicks(),
+                                          kDummyID, kDummyUrl);
+  AdvanceClock(kTestMetricsReportDelayTimeout);
+
+  page_cu->SetVisibility(true);
+  frame_cu->OnNonPersistentNotificationCreated();
+  // The page is not backgrounded, thus no metrics recorded.
+  histogram_tester_.ExpectTotalCount(
+      kTabFromBackgroundedToFirstNonPersistentNotificationCreatedUMA, 0);
+
+  page_cu->SetVisibility(false);
+  frame_cu->OnNonPersistentNotificationCreated();
+  // The page is backgrounded, thus metrics recorded.
+  histogram_tester_.ExpectTotalCount(
+      kTabFromBackgroundedToFirstNonPersistentNotificationCreatedUMA, 1);
+  frame_cu->OnNonPersistentNotificationCreated();
+  // Metrics should only be recorded once per background period, thus metrics
+  // not recorded.
+  histogram_tester_.ExpectTotalCount(
+      kTabFromBackgroundedToFirstNonPersistentNotificationCreatedUMA, 1);
+
+  page_cu->SetVisibility(true);
+  page_cu->SetVisibility(false);
+  frame_cu->OnNonPersistentNotificationCreated();
+  // The page is backgrounded from foregrounded, thus metrics recorded.
+  histogram_tester_.ExpectTotalCount(
+      kTabFromBackgroundedToFirstNonPersistentNotificationCreatedUMA, 2);
+}
+
+TEST_F(
+    MAYBE_MetricsCollectorTest,
+    FromBackgroundedToFirstNonPersistentNotificationCreatedUMA5MinutesTimeout) {
+  auto page_cu = CreateCoordinationUnit<PageCoordinationUnitImpl>();
+  auto frame_cu = CreateCoordinationUnit<FrameCoordinationUnitImpl>();
+  page_cu->AddFrame(frame_cu->id());
+
+  page_cu->OnMainFrameNavigationCommitted(ResourceCoordinatorClock::NowTicks(),
+                                          kDummyID, kDummyUrl);
+  page_cu->SetVisibility(false);
+  frame_cu->OnNonPersistentNotificationCreated();
+  // The page is within 5 minutes after main frame navigation was committed,
+  // thus no metrics recorded.
+  histogram_tester_.ExpectTotalCount(
+      kTabFromBackgroundedToFirstNonPersistentNotificationCreatedUMA, 0);
+  AdvanceClock(kTestMetricsReportDelayTimeout);
+  frame_cu->OnNonPersistentNotificationCreated();
+  histogram_tester_.ExpectTotalCount(
+      kTabFromBackgroundedToFirstNonPersistentNotificationCreatedUMA, 1);
+}
+
+TEST_F(MAYBE_MetricsCollectorTest, FromBackgroundedToFirstFaviconUpdatedUMA) {
+  auto page_cu = CreateCoordinationUnit<PageCoordinationUnitImpl>();
+
+  page_cu->OnMainFrameNavigationCommitted(ResourceCoordinatorClock::NowTicks(),
+                                          kDummyID, kDummyUrl);
+  AdvanceClock(kTestMetricsReportDelayTimeout);
+
+  page_cu->SetVisibility(true);
+  page_cu->OnFaviconUpdated();
+  // The page is not backgrounded, thus no metrics recorded.
+  histogram_tester_.ExpectTotalCount(
+      kTabFromBackgroundedToFirstFaviconUpdatedUMA, 0);
+
+  page_cu->SetVisibility(false);
+  page_cu->OnFaviconUpdated();
+  // The page is backgrounded, thus metrics recorded.
+  histogram_tester_.ExpectTotalCount(
+      kTabFromBackgroundedToFirstFaviconUpdatedUMA, 1);
+  page_cu->OnFaviconUpdated();
+  // Metrics should only be recorded once per background period, thus metrics
+  // not recorded.
+  histogram_tester_.ExpectTotalCount(
+      kTabFromBackgroundedToFirstFaviconUpdatedUMA, 1);
+
+  page_cu->SetVisibility(true);
+  page_cu->SetVisibility(false);
+  page_cu->OnFaviconUpdated();
+  // The page is backgrounded from foregrounded, thus metrics recorded.
+  histogram_tester_.ExpectTotalCount(
+      kTabFromBackgroundedToFirstFaviconUpdatedUMA, 2);
+}
+
+TEST_F(MAYBE_MetricsCollectorTest,
+       FromBackgroundedToFirstFaviconUpdatedUMA5MinutesTimeout) {
+  auto page_cu = CreateCoordinationUnit<PageCoordinationUnitImpl>();
+
+  page_cu->OnMainFrameNavigationCommitted(ResourceCoordinatorClock::NowTicks(),
+                                          kDummyID, kDummyUrl);
+  page_cu->SetVisibility(false);
+  page_cu->OnFaviconUpdated();
+  // The page is within 5 minutes after main frame navigation was committed,
+  // thus no metrics recorded.
+  histogram_tester_.ExpectTotalCount(
+      kTabFromBackgroundedToFirstFaviconUpdatedUMA, 0);
+  AdvanceClock(kTestMetricsReportDelayTimeout);
+  page_cu->OnFaviconUpdated();
+  histogram_tester_.ExpectTotalCount(
+      kTabFromBackgroundedToFirstFaviconUpdatedUMA, 1);
+}
+
+// Flaky test: https://crbug.com/833028
+TEST_F(MAYBE_MetricsCollectorTest, ResponsivenessMetric) {
+  auto page_cu = CreateCoordinationUnit<PageCoordinationUnitImpl>();
+  auto process_cu = CreateCoordinationUnit<ProcessCoordinationUnitImpl>();
+
+  auto frame_cu = CreateCoordinationUnit<FrameCoordinationUnitImpl>();
+  page_cu->AddFrame(frame_cu->id());
+  frame_cu->SetProcess(process_cu->id());
+
+  ukm::TestUkmRecorder ukm_recorder;
+  coordination_unit_graph()->set_ukm_recorder(&ukm_recorder);
+
+  ukm::SourceId id = ukm_recorder.GetNewSourceID();
+  GURL url = GURL("https://google.com/foobar");
+  ukm_recorder.UpdateSourceURL(id, url);
+  page_cu->SetUKMSourceId(id);
+  page_cu->OnMainFrameNavigationCommitted(ResourceCoordinatorClock::NowTicks(),
+                                          kDummyID, kDummyUrl);
+
+  for (int count = 1; count < kDefaultFrequencyUkmEQTReported; ++count) {
+    process_cu->SetExpectedTaskQueueingDuration(
+        base::TimeDelta::FromMilliseconds(3));
+    EXPECT_EQ(0U, ukm_recorder.entries_count());
+    EXPECT_EQ(1U, ukm_recorder.sources_count());
+  }
+  process_cu->SetExpectedTaskQueueingDuration(
+      base::TimeDelta::FromMilliseconds(4));
+  EXPECT_EQ(1U, ukm_recorder.sources_count());
+  EXPECT_EQ(1U, ukm_recorder.entries_count());
+  for (int count = 1; count < kDefaultFrequencyUkmEQTReported; ++count) {
+    process_cu->SetExpectedTaskQueueingDuration(
+        base::TimeDelta::FromMilliseconds(3));
+    EXPECT_EQ(1U, ukm_recorder.entries_count());
+    EXPECT_EQ(1U, ukm_recorder.sources_count());
+  }
+  process_cu->SetExpectedTaskQueueingDuration(
+      base::TimeDelta::FromMilliseconds(4));
+  EXPECT_EQ(1U, ukm_recorder.sources_count());
+  EXPECT_EQ(2U, ukm_recorder.entries_count());
+
+  const auto& entries =
+      ukm_recorder.GetEntriesByName(kResponsivenessMeasurement);
+  EXPECT_EQ(2U, entries.size());
+  for (const auto* entry : entries) {
+    ukm_recorder.ExpectEntrySourceHasUrl(entry, url);
+    ukm_recorder.ExpectEntryMetric(entry, kExpectedQueueingTime, 4);
+  }
+}
+
+}  // namespace resource_coordinator
diff -BbuN a/services/resource_coordinator/observers/page_signal_generator_impl.cc b/services/resource_coordinator/observers/page_signal_generator_impl.cc
--- a/services/resource_coordinator/observers/page_signal_generator_impl.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/services/resource_coordinator/observers/page_signal_generator_impl.cc	2019-05-17 18:53:37.960000000 +0300
@@ -0,0 +1,456 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "services/resource_coordinator/observers/page_signal_generator_impl.h"
+
+#include <utility>
+
+#include "base/metrics/histogram_macros.h"
+#include "services/resource_coordinator/coordination_unit/frame_coordination_unit_impl.h"
+#include "services/resource_coordinator/coordination_unit/page_coordination_unit_impl.h"
+#include "services/resource_coordinator/coordination_unit/process_coordination_unit_impl.h"
+#include "services/resource_coordinator/coordination_unit/system_coordination_unit_impl.h"
+#include "services/resource_coordinator/public/cpp/resource_coordinator_features.h"
+#include "services/resource_coordinator/resource_coordinator_clock.h"
+#include "services/service_manager/public/cpp/bind_source_info.h"
+
+namespace resource_coordinator {
+
+namespace {
+
+// These values are persisted to logs. Entries should not be renumbered and
+// numeric values should never be reused.
+enum class BloatedRendererHandlingInResourceCoordinator {
+  kForwardedToBrowser = 0,
+  kIgnoredDueToMultiplePages = 1,
+  kMaxValue = kIgnoredDueToMultiplePages
+};
+
+void RecordBloatedRendererHandling(
+    BloatedRendererHandlingInResourceCoordinator handling) {
+  UMA_HISTOGRAM_ENUMERATION("BloatedRenderer.HandlingInResourceCoordinator",
+                            handling);
+}
+
+}  // anonymous namespace
+
+// static
+constexpr base::TimeDelta PageSignalGeneratorImpl::kLoadedAndIdlingTimeout =
+    base::TimeDelta::FromSeconds(1);
+
+// This is taken as the 95th percentile of tab loading times on the Windows
+// platform (see SessionRestore.ForegroundTabFirstLoaded). This ensures that
+// all tabs eventually transition to loaded, even if they keep the main task
+// queue busy, or continue loading content.
+// static
+constexpr base::TimeDelta PageSignalGeneratorImpl::kWaitingForIdleTimeout =
+    base::TimeDelta::FromMinutes(1);
+
+PageSignalGeneratorImpl::PageSignalGeneratorImpl() {
+  // Ensure the timeouts make sense relative to each other.
+  static_assert(PageSignalGeneratorImpl::kWaitingForIdleTimeout >
+                    PageSignalGeneratorImpl::kLoadedAndIdlingTimeout,
+                "timeouts must be well ordered");
+}
+
+PageSignalGeneratorImpl::~PageSignalGeneratorImpl() = default;
+
+void PageSignalGeneratorImpl::AddReceiver(
+    mojom::PageSignalReceiverPtr receiver) {
+  receivers_.AddPtr(std::move(receiver));
+}
+
+// Frame CUs should be observed for:
+// 1- kNetworkAlmostIdle property changes used for PageAlmostIdle detection
+// Page CUs should be observed for:
+// 1- kLoading property changes used for PageAlmostIdle detection
+// 2- kLifecycleState property changes used to update the Tab lifecycle state
+// 3- kNavigationCommitted events for PageAlmostIdle detection
+// Process CUs should be observed for:
+// 1- kExpectedTaskQueueingDuration property for reporting EQT
+// 2- kMainThreadTaskLoadIsLow property changes for PageAlmostIdle detection
+// 3- kRendererIsBloated event for reloading bloated pages.
+// The system CU is observed for the kProcessCPUUsageReady event.
+bool PageSignalGeneratorImpl::ShouldObserve(
+    const CoordinationUnitBase* coordination_unit) {
+  auto cu_type = coordination_unit->id().type;
+  switch (cu_type) {
+    case CoordinationUnitType::kPage:
+    case CoordinationUnitType::kProcess:
+    case CoordinationUnitType::kSystem:
+      return true;
+
+    case CoordinationUnitType::kFrame:
+      return resource_coordinator::IsPageAlmostIdleSignalEnabled();
+
+    default:
+      NOTREACHED();
+      return false;
+  }
+}
+
+void PageSignalGeneratorImpl::OnCoordinationUnitCreated(
+    const CoordinationUnitBase* cu) {
+  auto cu_type = cu->id().type;
+  if (cu_type != CoordinationUnitType::kPage)
+    return;
+
+  if (!resource_coordinator::IsPageAlmostIdleSignalEnabled())
+    return;
+
+  // Create page data exists for this Page CU.
+  auto* page_cu = PageCoordinationUnitImpl::FromCoordinationUnitBase(cu);
+  DCHECK(!base::ContainsKey(page_data_, page_cu));  // No data should exist yet.
+  page_data_[page_cu].SetLoadIdleState(kLoadingNotStarted,
+                                       base::TimeTicks::Now());
+}
+
+void PageSignalGeneratorImpl::OnBeforeCoordinationUnitDestroyed(
+    const CoordinationUnitBase* cu) {
+  auto cu_type = cu->id().type;
+  if (cu_type != CoordinationUnitType::kPage)
+    return;
+
+  if (!resource_coordinator::IsPageAlmostIdleSignalEnabled())
+    return;
+
+  auto* page_cu = PageCoordinationUnitImpl::FromCoordinationUnitBase(cu);
+  size_t count = page_data_.erase(page_cu);
+  DCHECK_EQ(1u, count);  // This should always erase exactly one CU.
+}
+
+void PageSignalGeneratorImpl::OnFramePropertyChanged(
+    const FrameCoordinationUnitImpl* frame_cu,
+    const mojom::PropertyType property_type,
+    int64_t value) {
+  DCHECK(resource_coordinator::IsPageAlmostIdleSignalEnabled());
+
+  // Only the network idle state of a frame is of interest.
+  if (property_type != mojom::PropertyType::kNetworkAlmostIdle)
+    return;
+  UpdateLoadIdleStateFrame(frame_cu);
+}
+
+void PageSignalGeneratorImpl::OnPagePropertyChanged(
+    const PageCoordinationUnitImpl* page_cu,
+    const mojom::PropertyType property_type,
+    int64_t value) {
+  if (resource_coordinator::IsPageAlmostIdleSignalEnabled() &&
+      property_type == mojom::PropertyType::kIsLoading) {
+    UpdateLoadIdleStatePage(page_cu);
+  } else if (property_type == mojom::PropertyType::kLifecycleState) {
+    UpdateLifecycleState(page_cu, static_cast<mojom::LifecycleState>(value));
+  }
+}
+
+void PageSignalGeneratorImpl::OnProcessPropertyChanged(
+    const ProcessCoordinationUnitImpl* process_cu,
+    const mojom::PropertyType property_type,
+    int64_t value) {
+  if (property_type == mojom::PropertyType::kExpectedTaskQueueingDuration) {
+    for (auto* frame_cu : process_cu->GetFrameCoordinationUnits()) {
+      if (!frame_cu->IsMainFrame())
+        continue;
+      auto* page_cu = frame_cu->GetPageCoordinationUnit();
+      int64_t duration;
+      if (!page_cu || !page_cu->GetExpectedTaskQueueingDuration(&duration))
+        continue;
+      DispatchPageSignal(
+          page_cu, &mojom::PageSignalReceiver::SetExpectedTaskQueueingDuration,
+          base::TimeDelta::FromMilliseconds(duration));
+    }
+  } else {
+    if (resource_coordinator::IsPageAlmostIdleSignalEnabled() &&
+        property_type == mojom::PropertyType::kMainThreadTaskLoadIsLow) {
+      UpdateLoadIdleStateProcess(process_cu);
+    }
+  }
+}
+
+void PageSignalGeneratorImpl::OnFrameEventReceived(
+    const FrameCoordinationUnitImpl* frame_cu,
+    const mojom::Event event) {
+  if (event != mojom::Event::kNonPersistentNotificationCreated)
+    return;
+
+  auto* page_cu = frame_cu->GetPageCoordinationUnit();
+  if (!page_cu)
+    return;
+
+  DispatchPageSignal(
+      page_cu,
+      &mojom::PageSignalReceiver::NotifyNonPersistentNotificationCreated);
+}
+
+void PageSignalGeneratorImpl::OnPageEventReceived(
+    const PageCoordinationUnitImpl* page_cu,
+    const mojom::Event event) {
+  // We only care about the events if network idle signal is enabled.
+  if (!resource_coordinator::IsPageAlmostIdleSignalEnabled())
+    return;
+
+  // Only the navigation committed event is of interest.
+  if (event != mojom::Event::kNavigationCommitted)
+    return;
+
+  // Reset the load-idle state associated with this page as a new navigation has
+  // started.
+  auto* page_data = GetPageData(page_cu);
+  page_data->SetLoadIdleState(kLoadingNotStarted, base::TimeTicks::Now());
+  UpdateLoadIdleStatePage(page_cu);
+}
+
+void PageSignalGeneratorImpl::OnProcessEventReceived(
+    const ProcessCoordinationUnitImpl* process_cu,
+    const mojom::Event event) {
+  if (event == mojom::Event::kRendererIsBloated) {
+    std::set<PageCoordinationUnitImpl*> page_cus =
+        process_cu->GetAssociatedPageCoordinationUnits();
+    // Currently bloated renderer handling supports only a single page.
+    if (page_cus.size() == 1u) {
+      auto* page_cu = *page_cus.begin();
+      DispatchPageSignal(page_cu,
+                         &mojom::PageSignalReceiver::NotifyRendererIsBloated);
+      RecordBloatedRendererHandling(
+          BloatedRendererHandlingInResourceCoordinator::kForwardedToBrowser);
+    } else {
+      RecordBloatedRendererHandling(
+          BloatedRendererHandlingInResourceCoordinator::
+              kIgnoredDueToMultiplePages);
+    }
+  }
+}
+
+void PageSignalGeneratorImpl::OnSystemEventReceived(
+    const SystemCoordinationUnitImpl* system_cu,
+    const mojom::Event event) {
+  if (event == mojom::Event::kProcessCPUUsageReady) {
+    base::TimeTicks measurement_start =
+        system_cu->last_measurement_start_time();
+
+    for (auto& entry : page_data_) {
+      const PageCoordinationUnitImpl* page = entry.first;
+      PageData* data = &entry.second;
+      // TODO(siggi): Figure "recency" here, to avoid firing a measurement event
+      //     for state transitions that happened "too long" before a
+      //     measurement started. Alternatively perhaps this bit of policy is
+      //     better done in the observer, in which case it needs the time stamps
+      //     involved.
+      if (data->GetLoadIdleState() == kLoadedAndIdle &&
+          !data->performance_estimate_issued &&
+          data->last_state_change < measurement_start) {
+        DispatchPageSignal(
+            page, &mojom::PageSignalReceiver::OnLoadTimePerformanceEstimate,
+            page->TimeSinceLastNavigation(),
+            page->cumulative_cpu_usage_estimate(),
+            page->private_footprint_kb_estimate());
+        data->performance_estimate_issued = true;
+      }
+    }
+  }
+}
+
+void PageSignalGeneratorImpl::BindToInterface(
+    resource_coordinator::mojom::PageSignalGeneratorRequest request,
+    const service_manager::BindSourceInfo& source_info) {
+  bindings_.AddBinding(this, std::move(request));
+}
+
+void PageSignalGeneratorImpl::UpdateLoadIdleStateFrame(
+    const FrameCoordinationUnitImpl* frame_cu) {
+  DCHECK(resource_coordinator::IsPageAlmostIdleSignalEnabled());
+
+  // Only main frames are relevant in the load idle state.
+  if (!frame_cu->IsMainFrame())
+    return;
+
+  // Update the load idle state of the page associated with this frame.
+  auto* page_cu = frame_cu->GetPageCoordinationUnit();
+  if (!page_cu)
+    return;
+  UpdateLoadIdleStatePage(page_cu);
+}
+
+void PageSignalGeneratorImpl::UpdateLoadIdleStatePage(
+    const PageCoordinationUnitImpl* page_cu) {
+  DCHECK(resource_coordinator::IsPageAlmostIdleSignalEnabled());
+
+  auto* page_data = GetPageData(page_cu);
+
+  // Once the cycle is complete state transitions are no longer tracked for this
+  // page.
+  if (page_data->GetLoadIdleState() == kLoadedAndIdle)
+    return;
+
+  // Cancel any ongoing timers. A new timer will be set if necessary.
+  page_data->idling_timer.Stop();
+  base::TimeTicks now = ResourceCoordinatorClock::NowTicks();
+
+  // Determine if the overall timeout has fired.
+  if ((page_data->GetLoadIdleState() == kLoadedNotIdling ||
+       page_data->GetLoadIdleState() == kLoadedAndIdling) &&
+      (now - page_data->loading_stopped) >= kWaitingForIdleTimeout) {
+    TransitionToLoadedAndIdle(page_cu, now);
+    return;
+  }
+
+  // Otherwise do normal state transitions.
+  switch (page_data->GetLoadIdleState()) {
+    case kLoadingNotStarted: {
+      if (!IsLoading(page_cu))
+        return;
+      page_data->SetLoadIdleState(kLoading, now);
+      return;
+    }
+
+    case kLoading: {
+      if (IsLoading(page_cu))
+        return;
+      page_data->SetLoadIdleState(kLoadedNotIdling, now);
+      page_data->loading_stopped = now;
+      // Let the kLoadedNotIdling state transition evaluate, allowing an
+      // effective transition directly from kLoading to kLoadedAndIdling.
+      FALLTHROUGH;
+    }
+
+    case kLoadedNotIdling: {
+      if (IsIdling(page_cu)) {
+        page_data->SetLoadIdleState(kLoadedAndIdling, now);
+        page_data->idling_started = now;
+      }
+      // Break out of the switch statement and set a timer to check for the
+      // next state transition.
+      break;
+    }
+
+    case kLoadedAndIdling: {
+      // If the page is not still idling then transition back a state.
+      if (!IsIdling(page_cu)) {
+        page_data->SetLoadIdleState(kLoadedNotIdling, now);
+      } else {
+        // Idling has been happening long enough so make the last state
+        // transition.
+        if (now - page_data->idling_started >= kLoadedAndIdlingTimeout) {
+          TransitionToLoadedAndIdle(page_cu, now);
+          return;
+        }
+      }
+      // Break out of the switch statement and set a timer to check for the
+      // next state transition.
+      break;
+    }
+
+    // This should never occur.
+    case kLoadedAndIdle:
+      NOTREACHED();
+  }
+
+  // Getting here means a new timer needs to be set. Use the nearer of the two
+  // applicable timeouts.
+  base::TimeDelta timeout =
+      (page_data->loading_stopped + kWaitingForIdleTimeout) - now;
+  if (page_data->GetLoadIdleState() == kLoadedAndIdling) {
+    timeout = std::min(
+        timeout, (page_data->idling_started + kLoadedAndIdlingTimeout) - now);
+  }
+  page_data->idling_timer.Start(
+      FROM_HERE, timeout,
+      base::Bind(&PageSignalGeneratorImpl::UpdateLoadIdleStatePage,
+                 base::Unretained(this), page_cu));
+}
+
+void PageSignalGeneratorImpl::UpdateLoadIdleStateProcess(
+    const ProcessCoordinationUnitImpl* process_cu) {
+  DCHECK(resource_coordinator::IsPageAlmostIdleSignalEnabled());
+  for (auto* frame_cu : process_cu->GetFrameCoordinationUnits())
+    UpdateLoadIdleStateFrame(frame_cu);
+}
+
+void PageSignalGeneratorImpl::UpdateLifecycleState(
+    const PageCoordinationUnitImpl* page_cu,
+    const mojom::LifecycleState state) {
+  DispatchPageSignal(page_cu, &mojom::PageSignalReceiver::SetLifecycleState,
+                     state);
+}
+
+void PageSignalGeneratorImpl::TransitionToLoadedAndIdle(
+    const PageCoordinationUnitImpl* page_cu,
+    base::TimeTicks now) {
+  DCHECK(resource_coordinator::IsPageAlmostIdleSignalEnabled());
+  auto* page_data = GetPageData(page_cu);
+  page_data->SetLoadIdleState(kLoadedAndIdle, now);
+  // Notify observers that the page is loaded and idle.
+  DispatchPageSignal(page_cu, &mojom::PageSignalReceiver::NotifyPageAlmostIdle);
+}
+
+PageSignalGeneratorImpl::PageData* PageSignalGeneratorImpl::GetPageData(
+    const PageCoordinationUnitImpl* page_cu) {
+  DCHECK(resource_coordinator::IsPageAlmostIdleSignalEnabled());
+  // There are two ways to enter this function:
+  // 1. Via On*PropertyChange calls. The backing PageData is guaranteed to
+  //    exist in this case as the lifetimes are managed by the CU graph.
+  // 2. Via a timer stored in a PageData. The backing PageData will be
+  //    guaranteed to exist in this case as well, as otherwise the timer will
+  //    have been canceled.
+  DCHECK(base::ContainsKey(page_data_, page_cu));
+  return &page_data_[page_cu];
+}
+
+bool PageSignalGeneratorImpl::IsLoading(
+    const PageCoordinationUnitImpl* page_cu) {
+  DCHECK(resource_coordinator::IsPageAlmostIdleSignalEnabled());
+  int64_t is_loading = 0;
+  if (!page_cu->GetProperty(mojom::PropertyType::kIsLoading, &is_loading))
+    return false;
+  return is_loading;
+}
+
+bool PageSignalGeneratorImpl::IsIdling(
+    const PageCoordinationUnitImpl* page_cu) {
+  DCHECK(resource_coordinator::IsPageAlmostIdleSignalEnabled());
+  // Get the Frame CU for the main frame associated with this page.
+  const FrameCoordinationUnitImpl* main_frame_cu =
+      page_cu->GetMainFrameCoordinationUnit();
+  if (!main_frame_cu)
+    return false;
+
+  // Get the process CU associated with this main frame.
+  const auto* process_cu = main_frame_cu->GetProcessCoordinationUnit();
+  if (!process_cu)
+    return false;
+
+  // Note that it's possible for one misbehaving frame hosted in the same
+  // process as this page's main frame to keep the main thread task low high.
+  // In this case the IsIdling signal will be delayed, despite the task load
+  // associated with this page's main frame actually being low. In the case
+  // of session restore this is mitigated by having a timeout while waiting for
+  // this signal.
+  return main_frame_cu->GetPropertyOrDefault(
+             mojom::PropertyType::kNetworkAlmostIdle, 0u) &&
+         process_cu->GetPropertyOrDefault(
+             mojom::PropertyType::kMainThreadTaskLoadIsLow, 0u);
+}
+
+void PageSignalGeneratorImpl::PageData::SetLoadIdleState(
+    LoadIdleState new_state,
+    base::TimeTicks now) {
+  last_state_change = now;
+  load_idle_state = new_state;
+  performance_estimate_issued = false;
+}
+
+template <typename Method, typename... Params>
+void PageSignalGeneratorImpl::DispatchPageSignal(
+    const PageCoordinationUnitImpl* page_cu,
+    Method m,
+    Params... params) {
+  receivers_.ForAllPtrs([&](mojom::PageSignalReceiver* receiver) {
+    (receiver->*m)(
+        PageNavigationIdentity{page_cu->id(), page_cu->navigation_id(),
+                               page_cu->main_frame_url()},
+        std::forward<Params>(params)...);
+  });
+}
+
+}  // namespace resource_coordinator
diff -BbuN a/services/resource_coordinator/observers/page_signal_generator_impl.h b/services/resource_coordinator/observers/page_signal_generator_impl.h
--- a/services/resource_coordinator/observers/page_signal_generator_impl.h	1970-01-01 03:00:00.000000000 +0300
+++ b/services/resource_coordinator/observers/page_signal_generator_impl.h	2019-05-17 18:53:37.960000000 +0300
@@ -0,0 +1,181 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef SERVICES_RESOURCE_COORDINATOR_COORDINATION_UNIT_PAGE_SIGNAL_GENERATOR_IMPL_H_
+#define SERVICES_RESOURCE_COORDINATOR_COORDINATION_UNIT_PAGE_SIGNAL_GENERATOR_IMPL_H_
+
+#include <map>
+
+#include "base/gtest_prod_util.h"
+#include "base/macros.h"
+#include "base/timer/timer.h"
+#include "mojo/public/cpp/bindings/binding_set.h"
+#include "mojo/public/cpp/bindings/interface_ptr_set.h"
+#include "services/resource_coordinator/observers/coordination_unit_graph_observer.h"
+#include "services/resource_coordinator/public/mojom/page_signal.mojom.h"
+
+namespace service_manager {
+struct BindSourceInfo;
+}  // namespace service_manager
+
+namespace resource_coordinator {
+
+// The PageSignalGenerator is a dedicated |CoordinationUnitGraphObserver| for
+// calculating and emitting page-scoped signals. This observer observes
+// PageCoordinationUnits, ProcessCoordinationUnits and FrameCoordinationUnits,
+// combining information from the graph to generate page level signals.
+class PageSignalGeneratorImpl : public CoordinationUnitGraphObserver,
+                                public mojom::PageSignalGenerator {
+ public:
+  PageSignalGeneratorImpl();
+  ~PageSignalGeneratorImpl() override;
+
+  // mojom::PageSignalGenerator implementation.
+  void AddReceiver(mojom::PageSignalReceiverPtr receiver) override;
+
+  // CoordinationUnitGraphObserver implementation.
+  bool ShouldObserve(const CoordinationUnitBase* coordination_unit) override;
+  void OnCoordinationUnitCreated(const CoordinationUnitBase* cu) override;
+  void OnBeforeCoordinationUnitDestroyed(
+      const CoordinationUnitBase* cu) override;
+  void OnFramePropertyChanged(const FrameCoordinationUnitImpl* frame_cu,
+                              const mojom::PropertyType property_type,
+                              int64_t value) override;
+  void OnPagePropertyChanged(const PageCoordinationUnitImpl* page_cu,
+                             const mojom::PropertyType property_type,
+                             int64_t value) override;
+  void OnProcessPropertyChanged(const ProcessCoordinationUnitImpl* process_cu,
+                                const mojom::PropertyType property_type,
+                                int64_t value) override;
+  void OnFrameEventReceived(const FrameCoordinationUnitImpl* frame_cu,
+                            const mojom::Event event) override;
+  void OnPageEventReceived(const PageCoordinationUnitImpl* page_cu,
+                           const mojom::Event event) override;
+  void OnProcessEventReceived(const ProcessCoordinationUnitImpl* page_cu,
+                              const mojom::Event event) override;
+  void OnSystemEventReceived(const SystemCoordinationUnitImpl* system_cu,
+                             const mojom::Event event) override;
+
+  void BindToInterface(
+      resource_coordinator::mojom::PageSignalGeneratorRequest request,
+      const service_manager::BindSourceInfo& source_info);
+
+ private:
+  // The amount of time a page has to be idle post-loading in order for it to be
+  // considered loaded and idle. This is used in UpdateLoadIdleState
+  // transitions.
+  static const base::TimeDelta kLoadedAndIdlingTimeout;
+
+  // The maximum amount of time post-DidStopLoading a page can be waiting for
+  // an idle state to occur before the page is simply considered loaded anyways.
+  // Since PageAlmostIdle is intended as an "initial loading complete" signal,
+  // it needs to eventually terminate. This is strictly greater than the
+  // kLoadedAndIdlingTimeout.
+  static const base::TimeDelta kWaitingForIdleTimeout;
+
+  friend class PageSignalGeneratorImplTest;
+  FRIEND_TEST_ALL_PREFIXES(PageSignalGeneratorImplTest, IsLoading);
+  FRIEND_TEST_ALL_PREFIXES(PageSignalGeneratorImplTest, IsIdling);
+  FRIEND_TEST_ALL_PREFIXES(PageSignalGeneratorImplTest,
+                           NonPersistentNotificationCreatedEvent);
+  FRIEND_TEST_ALL_PREFIXES(PageSignalGeneratorImplTest,
+                           PageDataCorrectlyManaged);
+  FRIEND_TEST_ALL_PREFIXES(PageSignalGeneratorImplTest,
+                           PageAlmostIdleTransitionsNoTimeout);
+  FRIEND_TEST_ALL_PREFIXES(PageSignalGeneratorImplTest,
+                           PageAlmostIdleTransitionsWithTimeout);
+  FRIEND_TEST_ALL_PREFIXES(PageSignalGeneratorImplTest,
+                           OnLoadTimePerformanceEstimate);
+
+  // The state transitions for the PageAlmostIdle signal. In general a page
+  // transitions through these states from top to bottom.
+  enum LoadIdleState {
+    // The initial state. Can only transition to kLoading from here.
+    kLoadingNotStarted,
+    // Loading has started. Almost idle signals are ignored in this state.
+    // Can transition to kLoadedNotIdling and kLoadedAndIdling from here.
+    kLoading,
+    // Loading has completed, but the page has not started idling. Can only
+    // transition to kLoadedAndIdling from here.
+    kLoadedNotIdling,
+    // Loading has completed, and the page is idling. Can transition to
+    // kLoadedNotIdling or kLoadedAndIdle from here.
+    kLoadedAndIdling,
+    // Loading has completed and the page has been idling for sufficiently long.
+    // This is the final state. Once this state has been reached a signal will
+    // be emitted and no further state transitions will be tracked. Committing a
+    // new non-same document navigation can start the cycle over again.
+    kLoadedAndIdle
+  };
+
+  // Holds state per page CU. These are created via OnCoordinationUnitCreated
+  // and destroyed via OnBeforeCoordinationUnitDestroyed.
+  struct PageData {
+    // Set the load idle state and the time of change. Also clears the
+    // |performance_estimate_issued| flag.
+    void SetLoadIdleState(LoadIdleState new_state, base::TimeTicks now);
+    LoadIdleState GetLoadIdleState() const { return load_idle_state; }
+
+    // Marks the point in time when the DidStopLoading signal was received,
+    // transitioning to kLoadedAndNotIdling or kLoadedAndIdling. This is used as
+    // the basis for the kWaitingForIdleTimeout.
+    base::TimeTicks loading_stopped;
+    // Marks the point in time when the last transition to kLoadedAndIdling
+    // occurred. Used for gating the transition to kLoadedAndIdle.
+    base::TimeTicks idling_started;
+    // Notes the time of the last state change.
+    base::TimeTicks last_state_change;
+    // True iff a performance estimate has been issued for this page.
+    bool performance_estimate_issued = false;
+    // A one-shot timer used for transitioning between kLoadedAndIdling and
+    // kLoadedAndIdle.
+    base::OneShotTimer idling_timer;
+
+   private:
+    // Initially at kLoadingNotStarted. Transitions through the states via calls
+    // to UpdateLoadIdleState. Is reset to kLoadingNotStarted when a non-same
+    // document navigation is committed.
+    LoadIdleState load_idle_state;
+  };
+
+  // These are called when properties/events affecting the load-idle state are
+  // observed. Frame and Process variants will eventually all redirect to the
+  // appropriate Page variant, where the real work is done.
+  void UpdateLoadIdleStateFrame(const FrameCoordinationUnitImpl* frame_cu);
+  void UpdateLoadIdleStatePage(const PageCoordinationUnitImpl* page_cu);
+  void UpdateLoadIdleStateProcess(
+      const ProcessCoordinationUnitImpl* process_cu);
+
+  // This method is called when a property affecting the lifecycle state is
+  // observed.
+  void UpdateLifecycleState(const PageCoordinationUnitImpl* page_cu,
+                            mojom::LifecycleState state);
+
+  // Helper function for transitioning to the final state.
+  void TransitionToLoadedAndIdle(const PageCoordinationUnitImpl* page_cu,
+                                 base::TimeTicks now);
+
+  // Convenience accessors for state associated with a |page_cu|.
+  PageData* GetPageData(const PageCoordinationUnitImpl* page_cu);
+  bool IsLoading(const PageCoordinationUnitImpl* page_cu);
+  bool IsIdling(const PageCoordinationUnitImpl* page_cu);
+
+  template <typename Method, typename... Params>
+  void DispatchPageSignal(const PageCoordinationUnitImpl* page_cu,
+                          Method m,
+                          Params... params);
+
+  mojo::BindingSet<mojom::PageSignalGenerator> bindings_;
+  mojo::InterfacePtrSet<mojom::PageSignalReceiver> receivers_;
+
+  // Stores per Page CU data. This set is maintained by
+  // OnCoordinationUnitCreated and OnBeforeCoordinationUnitDestroyed.
+  std::map<const PageCoordinationUnitImpl*, PageData> page_data_;
+
+  DISALLOW_COPY_AND_ASSIGN(PageSignalGeneratorImpl);
+};
+
+}  // namespace resource_coordinator
+
+#endif  // SERVICES_RESOURCE_COORDINATOR_COORDINATION_UNIT_PAGE_SIGNAL_GENERATOR_IMPL_H_
diff -BbuN a/services/resource_coordinator/observers/page_signal_generator_impl_unittest.cc b/services/resource_coordinator/observers/page_signal_generator_impl_unittest.cc
--- a/services/resource_coordinator/observers/page_signal_generator_impl_unittest.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/services/resource_coordinator/observers/page_signal_generator_impl_unittest.cc	2019-05-17 18:53:37.964000000 +0300
@@ -0,0 +1,499 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "services/resource_coordinator/observers/page_signal_generator_impl.h"
+
+#include "base/run_loop.h"
+#include "base/test/scoped_feature_list.h"
+#include "base/test/simple_test_tick_clock.h"
+#include "mojo/public/cpp/bindings/interface_request.h"
+#include "mojo/public/cpp/bindings/strong_binding.h"
+#include "services/resource_coordinator/coordination_unit/coordination_unit_test_harness.h"
+#include "services/resource_coordinator/coordination_unit/frame_coordination_unit_impl.h"
+#include "services/resource_coordinator/coordination_unit/mock_coordination_unit_graphs.h"
+#include "services/resource_coordinator/coordination_unit/page_coordination_unit_impl.h"
+#include "services/resource_coordinator/coordination_unit/process_coordination_unit_impl.h"
+#include "services/resource_coordinator/public/cpp/resource_coordinator_features.h"
+#include "services/resource_coordinator/resource_coordinator_clock.h"
+
+#include "testing/gmock/include/gmock/gmock.h"
+#include "testing/gtest/include/gtest/gtest.h"
+
+using ::testing::_;
+
+namespace resource_coordinator {
+
+MATCHER_P3(IdentityMatches, cu_id, navigation_id, url, "") {
+  return arg.page_cu_id == cu_id && arg.navigation_id == navigation_id &&
+         arg.url == url;
+}
+
+class MockPageSignalGeneratorImpl : public PageSignalGeneratorImpl {
+ public:
+  // Overridden from PageSignalGeneratorImpl.
+  void OnProcessPropertyChanged(const ProcessCoordinationUnitImpl* process_cu,
+                                const mojom::PropertyType property_type,
+                                int64_t value) override {
+    if (property_type == mojom::PropertyType::kExpectedTaskQueueingDuration)
+      ++eqt_change_count_;
+  }
+
+  size_t eqt_change_count() const { return eqt_change_count_; }
+
+ private:
+  size_t eqt_change_count_ = 0;
+};
+
+class MockPageSignalReceiverImpl : public mojom::PageSignalReceiver {
+ public:
+  MockPageSignalReceiverImpl(mojom::PageSignalReceiverRequest request)
+      : binding_(this, std::move(request)) {}
+  ~MockPageSignalReceiverImpl() override = default;
+
+  // mojom::PageSignalReceiver implementation.
+  void NotifyPageAlmostIdle(
+      const PageNavigationIdentity& page_navigation_id) override {}
+  void SetExpectedTaskQueueingDuration(
+      const PageNavigationIdentity& page_navigation_id,
+      base::TimeDelta duration) override {}
+  void SetLifecycleState(const PageNavigationIdentity& page_navigation_id,
+                         mojom::LifecycleState) override {}
+  MOCK_METHOD1(NotifyNonPersistentNotificationCreated,
+               void(const PageNavigationIdentity& page_navigation_id));
+  MOCK_METHOD1(NotifyRendererIsBloated,
+               void(const PageNavigationIdentity& page_navigation_id));
+  MOCK_METHOD4(OnLoadTimePerformanceEstimate,
+               void(const PageNavigationIdentity& page_navigation_id,
+                    base::TimeDelta load_duration,
+                    base::TimeDelta cpu_usage_estimate,
+                    uint64_t private_footprint_kb_estimate));
+
+ private:
+  mojo::Binding<mojom::PageSignalReceiver> binding_;
+
+  DISALLOW_COPY_AND_ASSIGN(MockPageSignalReceiverImpl);
+};
+
+using MockPageSignalReceiver = testing::StrictMock<MockPageSignalReceiverImpl>;
+
+class PageSignalGeneratorImplTest : public CoordinationUnitTestHarness {
+ protected:
+  // Aliasing these here makes this unittest much more legible.
+  using LIS = PageSignalGeneratorImpl::LoadIdleState;
+
+  void SetUp() override {
+    std::unique_ptr<MockPageSignalGeneratorImpl> psg(
+        std::make_unique<MockPageSignalGeneratorImpl>());
+
+    page_signal_generator_ = psg.get();
+
+    // The graph takes ownership of the psg.
+    coordination_unit_graph()->RegisterObserver(std::move(psg));
+  }
+  void TearDown() override { ResourceCoordinatorClock::ResetClockForTesting(); }
+
+  MockPageSignalGeneratorImpl* page_signal_generator() {
+    return page_signal_generator_;
+  }
+
+  void DrivePageToLoadedAndIdle(
+      MockSinglePageInSingleProcessCoordinationUnitGraph* graph);
+
+  void EnablePAI() {
+    feature_list_ = std::make_unique<base::test::ScopedFeatureList>();
+    feature_list_->InitAndEnableFeature(features::kPageAlmostIdle);
+    ASSERT_TRUE(resource_coordinator::IsPageAlmostIdleSignalEnabled());
+  }
+
+  void TestPageAlmostIdleTransitions(bool timeout);
+
+ private:
+  MockPageSignalGeneratorImpl* page_signal_generator_ = nullptr;
+  std::unique_ptr<base::test::ScopedFeatureList> feature_list_;
+};
+
+void PageSignalGeneratorImplTest::DrivePageToLoadedAndIdle(
+    MockSinglePageInSingleProcessCoordinationUnitGraph* graph) {
+  // Drive the state machine forward through to LoadedAndIdle.
+  graph->page->SetIsLoading(true);
+  graph->frame->SetNetworkAlmostIdle(true);
+  graph->process->SetMainThreadTaskLoadIsLow(true);
+  graph->page->SetIsLoading(false);
+  task_env().FastForwardUntilNoTasksRemain();
+
+  PageSignalGeneratorImpl::PageData* page_data =
+      page_signal_generator()->GetPageData(graph->page.get());
+  EXPECT_EQ(LIS::kLoadedAndIdle, page_data->GetLoadIdleState());
+}
+
+TEST_F(PageSignalGeneratorImplTest,
+       CalculatePageEQTForSinglePageWithMultipleProcesses) {
+  MockSinglePageWithMultipleProcessesCoordinationUnitGraph cu_graph(
+      coordination_unit_graph());
+
+  cu_graph.process->SetExpectedTaskQueueingDuration(
+      base::TimeDelta::FromMilliseconds(1));
+  cu_graph.other_process->SetExpectedTaskQueueingDuration(
+      base::TimeDelta::FromMilliseconds(10));
+
+  EXPECT_EQ(2u, page_signal_generator()->eqt_change_count());
+  // The |other_process| is not for the main frame so its EQT values does not
+  // propagate to the page.
+  int64_t eqt;
+  EXPECT_TRUE(cu_graph.page->GetExpectedTaskQueueingDuration(&eqt));
+  EXPECT_EQ(1, eqt);
+}
+
+TEST_F(PageSignalGeneratorImplTest, IsLoading) {
+  EnablePAI();
+  MockSinglePageInSingleProcessCoordinationUnitGraph cu_graph(
+      coordination_unit_graph());
+  auto* page_cu = cu_graph.page.get();
+  auto* psg = page_signal_generator();
+  // The observer relationship isn't required for testing IsLoading.
+
+  // The loading property hasn't yet been set. Then IsLoading should return
+  // false as the default value.
+  EXPECT_FALSE(psg->IsLoading(page_cu));
+
+  // Once the loading property has been set it should return that value.
+  page_cu->SetIsLoading(false);
+  EXPECT_FALSE(psg->IsLoading(page_cu));
+  page_cu->SetIsLoading(true);
+  EXPECT_TRUE(psg->IsLoading(page_cu));
+  page_cu->SetIsLoading(false);
+  EXPECT_FALSE(psg->IsLoading(page_cu));
+}
+
+TEST_F(PageSignalGeneratorImplTest, IsIdling) {
+  EnablePAI();
+  MockSinglePageInSingleProcessCoordinationUnitGraph cu_graph(
+      coordination_unit_graph());
+  auto* frame_cu = cu_graph.frame.get();
+  auto* page_cu = cu_graph.page.get();
+  auto* proc_cu = cu_graph.process.get();
+  auto* psg = page_signal_generator();
+  // The observer relationship isn't required for testing IsIdling.
+
+  // Neither of the idling properties are set, so IsIdling should return false.
+  EXPECT_FALSE(psg->IsIdling(page_cu));
+
+  // Should still return false after main thread task is low.
+  proc_cu->SetMainThreadTaskLoadIsLow(true);
+  EXPECT_FALSE(psg->IsIdling(page_cu));
+
+  // Should return true when network is idle.
+  frame_cu->SetNetworkAlmostIdle(true);
+  EXPECT_TRUE(psg->IsIdling(page_cu));
+
+  // Should toggle with main thread task low.
+  proc_cu->SetMainThreadTaskLoadIsLow(false);
+  EXPECT_FALSE(psg->IsIdling(page_cu));
+  proc_cu->SetMainThreadTaskLoadIsLow(true);
+  EXPECT_TRUE(psg->IsIdling(page_cu));
+
+  // Should return false when network is no longer idle.
+  frame_cu->SetNetworkAlmostIdle(false);
+  EXPECT_FALSE(psg->IsIdling(page_cu));
+
+  // And should stay false if main thread task also goes low again.
+  proc_cu->SetMainThreadTaskLoadIsLow(false);
+  EXPECT_FALSE(psg->IsIdling(page_cu));
+}
+
+TEST_F(PageSignalGeneratorImplTest, PageDataCorrectlyManaged) {
+  EnablePAI();
+  auto* psg = page_signal_generator();
+
+  // The observer relationship isn't required for testing GetPageData.
+  EXPECT_EQ(0u, psg->page_data_.size());
+
+  {
+    MockSinglePageInSingleProcessCoordinationUnitGraph cu_graph(
+        coordination_unit_graph());
+
+    auto* page_cu = cu_graph.page.get();
+    EXPECT_EQ(1u, psg->page_data_.count(page_cu));
+    EXPECT_TRUE(psg->GetPageData(page_cu));
+  }
+  EXPECT_EQ(0u, psg->page_data_.size());
+}
+
+void PageSignalGeneratorImplTest::TestPageAlmostIdleTransitions(bool timeout) {
+  EnablePAI();
+  ResourceCoordinatorClock::SetClockForTesting(task_env().GetMockTickClock());
+  task_env().FastForwardBy(base::TimeDelta::FromSeconds(1));
+
+  MockSinglePageInSingleProcessCoordinationUnitGraph cu_graph(
+      coordination_unit_graph());
+  auto* frame_cu = cu_graph.frame.get();
+  auto* page_cu = cu_graph.page.get();
+  auto* proc_cu = cu_graph.process.get();
+  auto* psg = page_signal_generator();
+
+  // Ensure the page_cu creation is witnessed and get the associated
+  // page data for testing, then bind the timer to the test task runner.
+  PageSignalGeneratorImpl::PageData* page_data = psg->GetPageData(page_cu);
+  page_data->idling_timer.SetTaskRunner(task_env().GetMainThreadTaskRunner());
+
+  // Initially the page should be in a loading not started state.
+  EXPECT_EQ(LIS::kLoadingNotStarted, page_data->GetLoadIdleState());
+  EXPECT_FALSE(page_data->idling_timer.IsRunning());
+
+  // The state should not transition when a not loading state is explicitly
+  // set.
+  page_cu->SetIsLoading(false);
+  EXPECT_EQ(LIS::kLoadingNotStarted, page_data->GetLoadIdleState());
+  EXPECT_FALSE(page_data->idling_timer.IsRunning());
+
+  // The state should transition to loading when loading starts.
+  page_cu->SetIsLoading(true);
+  EXPECT_EQ(LIS::kLoading, page_data->GetLoadIdleState());
+  EXPECT_FALSE(page_data->idling_timer.IsRunning());
+
+  // Mark the page as idling. It should transition from kLoading directly
+  // to kLoadedAndIdling after this.
+  frame_cu->SetNetworkAlmostIdle(true);
+  proc_cu->SetMainThreadTaskLoadIsLow(true);
+  page_cu->SetIsLoading(false);
+  EXPECT_EQ(LIS::kLoadedAndIdling, page_data->GetLoadIdleState());
+  EXPECT_TRUE(page_data->idling_timer.IsRunning());
+
+  // Indicate loading is happening again. This should be ignored.
+  page_cu->SetIsLoading(true);
+  EXPECT_EQ(LIS::kLoadedAndIdling, page_data->GetLoadIdleState());
+  EXPECT_TRUE(page_data->idling_timer.IsRunning());
+  page_cu->SetIsLoading(false);
+  EXPECT_EQ(LIS::kLoadedAndIdling, page_data->GetLoadIdleState());
+  EXPECT_TRUE(page_data->idling_timer.IsRunning());
+
+  // Go back to not idling. We should transition back to kLoadedNotIdling, and
+  // a timer should still be running.
+  frame_cu->SetNetworkAlmostIdle(false);
+  EXPECT_EQ(LIS::kLoadedNotIdling, page_data->GetLoadIdleState());
+  EXPECT_TRUE(page_data->idling_timer.IsRunning());
+
+  base::TimeTicks start = ResourceCoordinatorClock::NowTicks();
+  if (timeout) {
+    // Let the timeout run down. The final state transition should occur.
+    task_env().FastForwardUntilNoTasksRemain();
+    base::TimeTicks end = ResourceCoordinatorClock::NowTicks();
+    base::TimeDelta elapsed = end - start;
+    EXPECT_LE(PageSignalGeneratorImpl::kLoadedAndIdlingTimeout, elapsed);
+    EXPECT_LE(PageSignalGeneratorImpl::kWaitingForIdleTimeout, elapsed);
+    EXPECT_EQ(LIS::kLoadedAndIdle, page_data->GetLoadIdleState());
+    EXPECT_FALSE(page_data->idling_timer.IsRunning());
+  } else {
+    // Go back to idling.
+    frame_cu->SetNetworkAlmostIdle(true);
+    EXPECT_EQ(LIS::kLoadedAndIdling, page_data->GetLoadIdleState());
+    EXPECT_TRUE(page_data->idling_timer.IsRunning());
+
+    // Let the idle timer evaluate. The final state transition should occur.
+    task_env().FastForwardUntilNoTasksRemain();
+    base::TimeTicks end = ResourceCoordinatorClock::NowTicks();
+    base::TimeDelta elapsed = end - start;
+    EXPECT_LE(PageSignalGeneratorImpl::kLoadedAndIdlingTimeout, elapsed);
+    EXPECT_GT(PageSignalGeneratorImpl::kWaitingForIdleTimeout, elapsed);
+    EXPECT_EQ(LIS::kLoadedAndIdle, page_data->GetLoadIdleState());
+    EXPECT_FALSE(page_data->idling_timer.IsRunning());
+  }
+
+  // Firing other signals should not change the state at all.
+  proc_cu->SetMainThreadTaskLoadIsLow(false);
+  EXPECT_EQ(LIS::kLoadedAndIdle, page_data->GetLoadIdleState());
+  EXPECT_FALSE(page_data->idling_timer.IsRunning());
+  frame_cu->SetNetworkAlmostIdle(false);
+  EXPECT_EQ(LIS::kLoadedAndIdle, page_data->GetLoadIdleState());
+  EXPECT_FALSE(page_data->idling_timer.IsRunning());
+
+  // Post a navigation. The state should reset.
+  page_cu->OnMainFrameNavigationCommitted(ResourceCoordinatorClock::NowTicks(),
+                                          1, "https://www.example.org");
+  EXPECT_EQ(LIS::kLoadingNotStarted, page_data->GetLoadIdleState());
+  EXPECT_FALSE(page_data->idling_timer.IsRunning());
+}
+
+TEST_F(PageSignalGeneratorImplTest, PageAlmostIdleTransitionsNoTimeout) {
+  TestPageAlmostIdleTransitions(false);
+}
+
+TEST_F(PageSignalGeneratorImplTest, PageAlmostIdleTransitionsWithTimeout) {
+  TestPageAlmostIdleTransitions(true);
+}
+
+TEST_F(PageSignalGeneratorImplTest, NonPersistentNotificationCreatedEvent) {
+  MockSinglePageInSingleProcessCoordinationUnitGraph cu_graph(
+      coordination_unit_graph());
+  auto* frame_cu = cu_graph.frame.get();
+
+  // Create a mock receiver and register it against the psg.
+  mojom::PageSignalReceiverPtr mock_receiver_ptr;
+  MockPageSignalReceiver mock_receiver(mojo::MakeRequest(&mock_receiver_ptr));
+  page_signal_generator()->AddReceiver(std::move(mock_receiver_ptr));
+
+  base::RunLoop run_loop;
+  EXPECT_CALL(mock_receiver, NotifyNonPersistentNotificationCreated(
+                                 IdentityMatches(cu_graph.page->id(), 0u, "")))
+      .WillOnce(::testing::InvokeWithoutArgs(&run_loop, &base::RunLoop::Quit));
+
+  // Send a mojom::Event::kNonPersistentNotificationCreated event and wait for
+  // the receiver to get it.
+  page_signal_generator()->OnFrameEventReceived(
+      frame_cu, mojom::Event::kNonPersistentNotificationCreated);
+  run_loop.Run();
+
+  ::testing::Mock::VerifyAndClear(&mock_receiver);
+}
+
+TEST_F(PageSignalGeneratorImplTest, NotifyRendererIsBloatedSinglePage) {
+  MockSinglePageInSingleProcessCoordinationUnitGraph cu_graph(
+      coordination_unit_graph());
+  auto* process = cu_graph.process.get();
+  auto* psg = page_signal_generator();
+
+  // Create a mock receiver and register it against the psg.
+  mojom::PageSignalReceiverPtr mock_receiver_ptr;
+  MockPageSignalReceiver mock_receiver(mojo::MakeRequest(&mock_receiver_ptr));
+  psg->AddReceiver(std::move(mock_receiver_ptr));
+
+  base::RunLoop run_loop;
+  EXPECT_CALL(mock_receiver, NotifyRendererIsBloated(_));
+  process->OnRendererIsBloated();
+  run_loop.RunUntilIdle();
+  ::testing::Mock::VerifyAndClear(&mock_receiver);
+}
+
+TEST_F(PageSignalGeneratorImplTest, NotifyRendererIsBloatedMultiplePages) {
+  MockMultiplePagesInSingleProcessCoordinationUnitGraph cu_graph(
+      coordination_unit_graph());
+  auto* process = cu_graph.process.get();
+  auto* psg = page_signal_generator();
+
+  // Create a mock receiver and register it against the psg.
+  mojom::PageSignalReceiverPtr mock_receiver_ptr;
+  MockPageSignalReceiver mock_receiver(mojo::MakeRequest(&mock_receiver_ptr));
+  psg->AddReceiver(std::move(mock_receiver_ptr));
+
+  base::RunLoop run_loop;
+  EXPECT_CALL(mock_receiver, NotifyRendererIsBloated(_)).Times(0);
+  process->OnRendererIsBloated();
+  run_loop.RunUntilIdle();
+  ::testing::Mock::VerifyAndClear(&mock_receiver);
+}
+
+namespace {
+
+mojom::ProcessResourceMeasurementBatchPtr CreateMeasurementBatch(
+    base::TimeTicks start_time,
+    size_t cpu_time_us,
+    size_t private_fp_kb) {
+  mojom::ProcessResourceMeasurementBatchPtr batch =
+      mojom::ProcessResourceMeasurementBatch::New();
+  batch->batch_started_time = start_time;
+  batch->batch_ended_time = start_time + base::TimeDelta::FromMicroseconds(10);
+
+  mojom::ProcessResourceMeasurementPtr measurement =
+      mojom::ProcessResourceMeasurement::New();
+  measurement->pid = 1;
+  measurement->cpu_usage = base::TimeDelta::FromMicroseconds(cpu_time_us);
+  measurement->private_footprint_kb = static_cast<uint32_t>(private_fp_kb);
+  batch->measurements.push_back(std::move(measurement));
+
+  return batch;
+}
+
+}  // namespace
+
+TEST_F(PageSignalGeneratorImplTest, OnLoadTimePerformanceEstimate) {
+  EnablePAI();
+
+  MockSinglePageInSingleProcessCoordinationUnitGraph cu_graph(
+      coordination_unit_graph());
+
+  // Create a mock receiver and register it against the psg.
+  mojom::PageSignalReceiverPtr mock_receiver_ptr;
+  MockPageSignalReceiver mock_receiver(mojo::MakeRequest(&mock_receiver_ptr));
+  page_signal_generator()->AddReceiver(std::move(mock_receiver_ptr));
+
+  ResourceCoordinatorClock::SetClockForTesting(task_env().GetMockTickClock());
+  task_env().FastForwardBy(base::TimeDelta::FromSeconds(1));
+
+  auto* page_cu = cu_graph.page.get();
+  auto* psg = page_signal_generator();
+
+  // Ensure the page_cu creation is witnessed and get the associated
+  // page data for testing, then bind the timer to the test task runner.
+  PageSignalGeneratorImpl::PageData* page_data = psg->GetPageData(page_cu);
+  page_data->idling_timer.SetTaskRunner(task_env().GetMainThreadTaskRunner());
+
+  base::TimeTicks navigation_committed_time =
+      ResourceCoordinatorClock::NowTicks();
+  page_cu->OnMainFrameNavigationCommitted(navigation_committed_time, 1,
+                                          "https://www.google.com/");
+  DrivePageToLoadedAndIdle(&cu_graph);
+
+  base::TimeTicks event_time = ResourceCoordinatorClock::NowTicks();
+
+  // A measurement that starts before an initiating state change should not
+  // result in a notification.
+  cu_graph.system->DistributeMeasurementBatch(CreateMeasurementBatch(
+      event_time - base::TimeDelta::FromMicroseconds(2), 10, 100));
+
+  cu_graph.system->DistributeMeasurementBatch(CreateMeasurementBatch(
+      event_time + base::TimeDelta::FromMicroseconds(2), 15, 150));
+
+  // A second measurement after a notification has been generated shouldn't
+  // generate a second notification.
+  cu_graph.system->DistributeMeasurementBatch(CreateMeasurementBatch(
+      event_time + base::TimeDelta::FromMicroseconds(4), 20, 200));
+
+  {
+    base::RunLoop run_loop;
+    EXPECT_CALL(mock_receiver, OnLoadTimePerformanceEstimate(
+                                   IdentityMatches(cu_graph.page->id(), 1u,
+                                                   "https://www.google.com/"),
+                                   event_time - navigation_committed_time,
+                                   base::TimeDelta::FromMicroseconds(15), 150))
+        .WillOnce(
+            ::testing::InvokeWithoutArgs(&run_loop, &base::RunLoop::Quit));
+
+    run_loop.Run();
+  }
+
+  ::testing::Mock::VerifyAndClear(&mock_receiver);
+
+  // Make sure a second run around the state machine generates a second event.
+  navigation_committed_time = ResourceCoordinatorClock::NowTicks();
+  page_cu->OnMainFrameNavigationCommitted(navigation_committed_time, 2,
+                                          "https://example.org/bobcat");
+  task_env().FastForwardUntilNoTasksRemain();
+  EXPECT_NE(LIS::kLoadedAndIdle, page_data->GetLoadIdleState());
+
+  DrivePageToLoadedAndIdle(&cu_graph);
+
+  event_time = ResourceCoordinatorClock::NowTicks();
+
+  // Dispatch another measurement and verify another notification is fired.
+  cu_graph.system->DistributeMeasurementBatch(CreateMeasurementBatch(
+      event_time + base::TimeDelta::FromMicroseconds(2), 25, 250));
+
+  {
+    base::RunLoop run_loop;
+    EXPECT_CALL(mock_receiver,
+                OnLoadTimePerformanceEstimate(
+                    IdentityMatches(cu_graph.page->id(), 2u,
+                                    "https://example.org/bobcat"),
+                    event_time - navigation_committed_time,
+                    base::TimeDelta::FromMicroseconds(25), 250))
+        .WillOnce(
+            ::testing::InvokeWithoutArgs(&run_loop, &base::RunLoop::Quit));
+
+    run_loop.Run();
+  }
+
+  ::testing::Mock::VerifyAndClear(&mock_receiver);
+}
+
+}  // namespace resource_coordinator
diff -BbuN a/services/resource_coordinator/observers/working_set_trimmer_win.cc b/services/resource_coordinator/observers/working_set_trimmer_win.cc
--- a/services/resource_coordinator/observers/working_set_trimmer_win.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/services/resource_coordinator/observers/working_set_trimmer_win.cc	2019-05-17 18:53:37.964000000 +0300
@@ -0,0 +1,67 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "services/resource_coordinator/observers/working_set_trimmer_win.h"
+
+#include <windows.h>  // Must be in front of other Windows header files.
+
+#include <psapi.h>
+
+#include "base/logging.h"
+#include "base/process/process.h"
+#include "base/time/time.h"
+#include "services/resource_coordinator/coordination_unit/coordination_unit_base.h"
+#include "services/resource_coordinator/coordination_unit/process_coordination_unit_impl.h"
+
+namespace resource_coordinator {
+
+namespace {
+
+// Empties the working set of a process with id |process_id| and creation time
+// |process_creation_time|. The creation time is verified to ensure that we
+// don't empty the working set of the wrong process if the target process exits
+// and its id is reused.
+void EmptyWorkingSet(base::ProcessId process_id,
+                     base::Time process_creation_time) {
+  base::Process process = base::Process::OpenWithAccess(
+      process_id, PROCESS_QUERY_LIMITED_INFORMATION | PROCESS_SET_QUOTA);
+  if (!process.IsValid()) {
+    DPLOG(ERROR) << "Working set not emptied because process handle could not "
+                    "be obtained.";
+    return;
+  }
+
+  if (process.CreationTime() != process_creation_time) {
+    DLOG(ERROR) << "Working set not emptied because actual process creation "
+                   "time does not match expected process creation time";
+    return;
+  }
+
+#if DCHECK_IS_ON()
+  BOOL empty_working_set_success =
+#endif
+      ::EmptyWorkingSet(process.Handle());
+  DPLOG_IF(ERROR, !empty_working_set_success)
+      << "Working set not emptied because EmptyWorkingSet() failed";
+}
+
+}  // namespace
+
+WorkingSetTrimmer::WorkingSetTrimmer() = default;
+WorkingSetTrimmer::~WorkingSetTrimmer() = default;
+
+bool WorkingSetTrimmer::ShouldObserve(
+    const CoordinationUnitBase* coordination_unit) {
+  return coordination_unit->id().type == CoordinationUnitType::kProcess;
+}
+
+void WorkingSetTrimmer::OnAllFramesInProcessFrozen(
+    const ProcessCoordinationUnitImpl* process_cu) {
+  const base::ProcessId process_id = process_cu->process_id();
+  if (process_id != base::kNullProcessId) {
+    EmptyWorkingSet(process_id, process_cu->launch_time());
+  }
+}
+
+}  // namespace resource_coordinator
diff -BbuN a/services/resource_coordinator/observers/working_set_trimmer_win.h b/services/resource_coordinator/observers/working_set_trimmer_win.h
--- a/services/resource_coordinator/observers/working_set_trimmer_win.h	1970-01-01 03:00:00.000000000 +0300
+++ b/services/resource_coordinator/observers/working_set_trimmer_win.h	2019-05-17 18:53:37.964000000 +0300
@@ -0,0 +1,45 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef SERVICES_RESOURCE_COORDINATOR_OBSERVERS_WORKING_SET_TRIMMER_WIN_H_
+#define SERVICES_RESOURCE_COORDINATOR_OBSERVERS_WORKING_SET_TRIMMER_WIN_H_
+
+#include "base/macros.h"
+#include "services/resource_coordinator/observers/coordination_unit_graph_observer.h"
+
+namespace resource_coordinator {
+
+// Empties the working set of processes in which all frames are frozen.
+//
+// Objective #1: Track working set growth rate.
+//   Swap trashing occurs when a lot of pages are accessed in a short period of
+//   time. Swap trashing can be reduced by reducing the number of pages accessed
+//   by processes in which all frames are frozen. To track efforts towards this
+//   goal, we empty the working set of processes when all their frames become
+//   frozen and record the size of their working set after x minutes.
+//   TODO(fdoray): Record the working set size x minutes after emptying it.
+//   https://crbug.com/885293
+//
+// Objective #2: Improve performance.
+//   We hypothesize that emptying the working set of a process causes its pages
+//   to be compressed and/or written to disk preemptively, which makes more
+//   memory available quickly for foreground processes and improves global
+//   browser performance.
+class WorkingSetTrimmer : public CoordinationUnitGraphObserver {
+ public:
+  WorkingSetTrimmer();
+  ~WorkingSetTrimmer() override;
+
+  // CoordinationUnitGraphObserver:
+  bool ShouldObserve(const CoordinationUnitBase* coordination_unit) override;
+  void OnAllFramesInProcessFrozen(
+      const ProcessCoordinationUnitImpl* process_cu) override;
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(WorkingSetTrimmer);
+};
+
+}  // namespace resource_coordinator
+
+#endif  // SERVICES_RESOURCE_COORDINATOR_OBSERVERS_WORKING_SET_TRIMMER_WIN_H_
diff -BbuN a/services/resource_coordinator/observers/working_set_trimmer_win_unittest.cc b/services/resource_coordinator/observers/working_set_trimmer_win_unittest.cc
--- a/services/resource_coordinator/observers/working_set_trimmer_win_unittest.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/services/resource_coordinator/observers/working_set_trimmer_win_unittest.cc	2019-05-17 18:53:37.964000000 +0300
@@ -0,0 +1,138 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "services/resource_coordinator/observers/working_set_trimmer_win.h"
+
+#include <windows.h>  // Must be in front of other Windows header files.
+
+#include <psapi.h>
+
+#include <cstring>
+#include <vector>
+
+#include "base/command_line.h"
+#include "base/process/process_handle.h"
+#include "base/strings/string16.h"
+#include "base/strings/string_number_conversions.h"
+#include "base/synchronization/waitable_event.h"
+#include "base/test/multiprocess_test.h"
+#include "services/resource_coordinator/coordination_unit/coordination_unit_test_harness.h"
+#include "services/resource_coordinator/coordination_unit/process_coordination_unit_impl.h"
+#include "testing/gtest/include/gtest/gtest.h"
+#include "testing/multiprocess_func_list.h"
+
+namespace resource_coordinator {
+
+namespace {
+
+constexpr char kTestProcessIdSwitchName[] = "test_test_process_id";
+constexpr base::char16 kBufferInitializedEventName[] =
+    L"RCEmptyWorkingSetTestBufferInitialized";
+constexpr base::char16 kChildProcessExitEventName[] =
+    L"RCEmptyWorkingSetTestChildProcessExit";
+
+base::win::ScopedHandle CreateEvent(const base::string16& name,
+                                    const base::string16& test_process_id) {
+  base::win::ScopedHandle event(::CreateEvent(
+      nullptr, TRUE, FALSE, (L"Local\\" + name + test_process_id).c_str()));
+  DCHECK(event.IsValid());
+  return event;
+}
+
+SIZE_T GetWorkingSetSizeMb(base::ProcessHandle handle) {
+  PROCESS_MEMORY_COUNTERS_EX pmc;
+  if (::GetProcessMemoryInfo(handle,
+                             reinterpret_cast<PROCESS_MEMORY_COUNTERS*>(&pmc),
+                             sizeof(pmc))) {
+    return pmc.WorkingSetSize / 1024 / 1024;
+  }
+
+  ADD_FAILURE() << "GetProcessMemoryInfo failed";
+  return 0;
+}
+
+MULTIPROCESS_TEST_MAIN(ProcessWithLargeWorkingSet) {
+  const base::string16 test_process_id =
+      base::CommandLine::ForCurrentProcess()->GetSwitchValueNative(
+          kTestProcessIdSwitchName);
+
+  constexpr int k10MbInBytes = 10 * 1024 * 1024;
+  std::vector<char> buffer(k10MbInBytes);
+  std::memset(buffer.data(), 0x80, buffer.size());
+
+  base::WaitableEvent buffer_initialized_event(
+      CreateEvent(kBufferInitializedEventName, test_process_id));
+  buffer_initialized_event.Signal();
+
+  base::WaitableEvent child_process_exit_event(
+      CreateEvent(kChildProcessExitEventName, test_process_id));
+  child_process_exit_event.Wait();
+
+  return 0;
+}
+
+class WorkingSetTrimmerTest : public CoordinationUnitTestHarness {
+ protected:
+  WorkingSetTrimmerTest() {
+    // Create a child process and wait until it allocates a 10 MB buffer.
+    base::CommandLine command_line(
+        base::GetMultiProcessTestChildBaseCommandLine());
+    command_line.AppendSwitchNative(kTestProcessIdSwitchName, test_process_id_);
+
+    child_process_ = base::SpawnMultiProcessTestChild(
+        "ProcessWithLargeWorkingSet", command_line, base::LaunchOptions());
+
+    base::WaitableEvent buffer_initialized_event(
+        CreateEvent(kBufferInitializedEventName, test_process_id_));
+    buffer_initialized_event.Wait();
+
+    process_cu_->SetPID(child_process_.Pid());
+
+    EXPECT_GE(GetWorkingSetSizeMb(child_process_.Handle()), 10U);
+  }
+
+  ~WorkingSetTrimmerTest() override {
+    // Wait for the child process to exit.
+    base::WaitableEvent child_process_exit_event(
+        CreateEvent(kChildProcessExitEventName, test_process_id_));
+    child_process_exit_event.Signal();
+
+    child_process_.WaitForExit(nullptr);
+  }
+
+  const base::string16 test_process_id_ =
+      base::NumberToString16(base::GetCurrentProcId());
+  base::Process child_process_;
+  TestCoordinationUnitWrapper<ProcessCoordinationUnitImpl> process_cu_ =
+      CreateCoordinationUnit<ProcessCoordinationUnitImpl>();
+  WorkingSetTrimmer working_set_trimmer_;
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(WorkingSetTrimmerTest);
+};
+
+}  // namespace
+
+TEST_F(WorkingSetTrimmerTest, EmptyWorkingSet) {
+  // Set the launch time of the process CU to match |child_process_|.
+  process_cu_->SetLaunchTime(child_process_.CreationTime());
+
+  // When all frames in the Process CU are frozen, the working set of
+  // |child_process_| should be emptied.
+  working_set_trimmer_.OnAllFramesInProcessFrozen(process_cu_.get());
+  EXPECT_EQ(GetWorkingSetSizeMb(child_process_.Handle()), 0U);
+}
+
+TEST_F(WorkingSetTrimmerTest, EmptyWorkingSetInconsistentLaunchTime) {
+  // Set the launch time on the process CU to a dummy time.
+  process_cu_->SetLaunchTime(base::Time::Now() + base::TimeDelta::FromDays(1));
+
+  // When all frames in the Process CU are frozen, the working set of
+  // |child_process_| should not be emptied because its creation time is after
+  // |process_cu_->launch_time()|.
+  working_set_trimmer_.OnAllFramesInProcessFrozen(process_cu_.get());
+  EXPECT_GE(GetWorkingSetSizeMb(child_process_.Handle()), 10U);
+}
+
+}  // namespace resource_coordinator
--- a/services/resource_coordinator/public/cpp/frame_resource_coordinator.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/services/resource_coordinator/public/cpp/frame_resource_coordinator.cc	2019-05-17 18:53:37.964000000 +0300
@@ -0,0 +1,79 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "services/resource_coordinator/public/cpp/frame_resource_coordinator.h"
+
+#include "services/resource_coordinator/public/cpp/process_resource_coordinator.h"
+
+namespace resource_coordinator {
+
+FrameResourceCoordinator::FrameResourceCoordinator(
+    service_manager::Connector* connector)
+    : ResourceCoordinatorInterface(), weak_ptr_factory_(this) {
+  CoordinationUnitID new_cu_id(CoordinationUnitType::kFrame,
+                               CoordinationUnitID::RANDOM_ID);
+  ResourceCoordinatorInterface::ConnectToService(connector, new_cu_id);
+}
+
+FrameResourceCoordinator::~FrameResourceCoordinator() = default;
+
+void FrameResourceCoordinator::SetProcess(
+    const ProcessResourceCoordinator& process) {
+  if (!service_ || !process.service())
+    return;
+  process.service()->GetID(
+      base::BindOnce(&FrameResourceCoordinator::SetProcessByID,
+                     weak_ptr_factory_.GetWeakPtr()));
+}
+
+void FrameResourceCoordinator::AddChildFrame(
+    const FrameResourceCoordinator& child) {
+  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
+  if (!service_ || !child.service())
+    return;
+  // We could keep the ID around ourselves, but this hop ensures that the child
+  // has been created on the service-side.
+  child.service()->GetID(
+      base::BindOnce(&FrameResourceCoordinator::AddChildFrameByID,
+                     weak_ptr_factory_.GetWeakPtr()));
+}
+
+void FrameResourceCoordinator::RemoveChildFrame(
+    const FrameResourceCoordinator& child) {
+  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
+  if (!service_ || !child.service())
+    return;
+  child.service()->GetID(
+      base::BindOnce(&FrameResourceCoordinator::RemoveChildFrameByID,
+                     weak_ptr_factory_.GetWeakPtr()));
+}
+
+void FrameResourceCoordinator::ConnectToService(
+    mojom::CoordinationUnitProviderPtr& provider,
+    const CoordinationUnitID& cu_id) {
+  provider->CreateFrameCoordinationUnit(mojo::MakeRequest(&service_), cu_id);
+}
+
+void FrameResourceCoordinator::SetProcessByID(
+    const CoordinationUnitID& process_id) {
+  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
+  if (service_)
+    service_->SetProcess(process_id);
+}
+
+void FrameResourceCoordinator::AddChildFrameByID(
+    const CoordinationUnitID& child_id) {
+  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
+  if (service_)
+    service_->AddChildFrame(child_id);
+}
+
+void FrameResourceCoordinator::RemoveChildFrameByID(
+    const CoordinationUnitID& child_id) {
+  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
+  if (service_)
+    service_->RemoveChildFrame(child_id);
+}
+
+}  // namespace resource_coordinator
--- a/services/resource_coordinator/public/cpp/frame_resource_coordinator.h	1970-01-01 03:00:00.000000000 +0300
+++ b/services/resource_coordinator/public/cpp/frame_resource_coordinator.h	2019-05-17 18:53:37.964000000 +0300
@@ -0,0 +1,51 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef SERVICES_RESOURCE_COORDINATOR_PUBLIC_CPP_FRAME_RESOURCE_COORDINATOR_H_
+#define SERVICES_RESOURCE_COORDINATOR_PUBLIC_CPP_FRAME_RESOURCE_COORDINATOR_H_
+
+#include "base/memory/weak_ptr.h"
+#include "base/threading/thread_checker.h"
+#include "services/resource_coordinator/public/cpp/resource_coordinator_interface.h"
+#include "services/resource_coordinator/public/mojom/coordination_unit.mojom.h"
+
+namespace resource_coordinator {
+
+class ProcessResourceCoordinator;
+
+class COMPONENT_EXPORT(SERVICES_RESOURCE_COORDINATOR_PUBLIC_CPP)
+    FrameResourceCoordinator
+    : public ResourceCoordinatorInterface<mojom::FrameCoordinationUnitPtr,
+                                          mojom::FrameCoordinationUnitRequest> {
+ public:
+  FrameResourceCoordinator(service_manager::Connector* connector);
+  ~FrameResourceCoordinator() override;
+
+  void SetProcess(const ProcessResourceCoordinator& process);
+  void AddChildFrame(const FrameResourceCoordinator& child);
+  void RemoveChildFrame(const FrameResourceCoordinator& child);
+
+  // Closes the connection to the service.
+  void reset() { service_.reset(); }
+
+ private:
+  void ConnectToService(mojom::CoordinationUnitProviderPtr& provider,
+                        const CoordinationUnitID& cu_id) override;
+
+  void SetProcessByID(const CoordinationUnitID& process_id);
+  void AddChildFrameByID(const CoordinationUnitID& child_id);
+  void RemoveChildFrameByID(const CoordinationUnitID& child_id);
+
+  THREAD_CHECKER(thread_checker_);
+
+  // The WeakPtrFactory should come last so the weak ptrs are invalidated
+  // before the rest of the member variables.
+  base::WeakPtrFactory<FrameResourceCoordinator> weak_ptr_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(FrameResourceCoordinator);
+};
+
+}  // namespace resource_coordinator
+
+#endif  // SERVICES_RESOURCE_COORDINATOR_PUBLIC_CPP_FRAME_RESOURCE_COORDINATOR_H_
--- a/services/resource_coordinator/public/cpp/page_resource_coordinator.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/services/resource_coordinator/public/cpp/page_resource_coordinator.cc	2019-05-17 18:53:37.968000000 +0300
@@ -0,0 +1,95 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "services/resource_coordinator/public/cpp/page_resource_coordinator.h"
+
+namespace resource_coordinator {
+
+PageResourceCoordinator::PageResourceCoordinator(
+    service_manager::Connector* connector)
+    : ResourceCoordinatorInterface(), weak_ptr_factory_(this) {
+  CoordinationUnitID new_cu_id(CoordinationUnitType::kPage,
+                               CoordinationUnitID::RANDOM_ID);
+  ResourceCoordinatorInterface::ConnectToService(connector, new_cu_id);
+}
+
+PageResourceCoordinator::~PageResourceCoordinator() = default;
+
+void PageResourceCoordinator::SetIsLoading(bool is_loading) {
+  if (!service_)
+    return;
+  service_->SetIsLoading(is_loading);
+}
+
+void PageResourceCoordinator::SetVisibility(bool visible) {
+  if (!service_)
+    return;
+  service_->SetVisibility(visible);
+}
+
+void PageResourceCoordinator::SetUKMSourceId(int64_t ukm_source_id) {
+  if (!service_)
+    return;
+  service_->SetUKMSourceId(ukm_source_id);
+}
+
+void PageResourceCoordinator::OnFaviconUpdated() {
+  if (!service_)
+    return;
+  service_->OnFaviconUpdated();
+}
+
+void PageResourceCoordinator::OnTitleUpdated() {
+  if (!service_)
+    return;
+  service_->OnTitleUpdated();
+}
+
+void PageResourceCoordinator::OnMainFrameNavigationCommitted(
+    base::TimeTicks navigation_committed_time,
+    uint64_t navigation_id,
+    const std::string& url) {
+  if (!service_)
+    return;
+  service_->OnMainFrameNavigationCommitted(navigation_committed_time,
+                                           navigation_id, url);
+}
+
+void PageResourceCoordinator::AddFrame(const FrameResourceCoordinator& frame) {
+  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
+  if (!service_ || !frame.service())
+    return;
+  // We could keep the ID around ourselves, but this hop ensures that the child
+  // has been created on the service-side.
+  frame.service()->GetID(base::BindOnce(&PageResourceCoordinator::AddFrameByID,
+                                        weak_ptr_factory_.GetWeakPtr()));
+}
+
+void PageResourceCoordinator::RemoveFrame(
+    const FrameResourceCoordinator& frame) {
+  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
+  if (!service_ || !frame.service())
+    return;
+  frame.service()->GetID(
+      base::BindOnce(&PageResourceCoordinator::RemoveFrameByID,
+                     weak_ptr_factory_.GetWeakPtr()));
+}
+
+void PageResourceCoordinator::ConnectToService(
+    mojom::CoordinationUnitProviderPtr& provider,
+    const CoordinationUnitID& cu_id) {
+  provider->CreatePageCoordinationUnit(mojo::MakeRequest(&service_), cu_id);
+}
+
+void PageResourceCoordinator::AddFrameByID(const CoordinationUnitID& cu_id) {
+  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
+  service_->AddFrame(cu_id);
+}
+
+void PageResourceCoordinator::RemoveFrameByID(const CoordinationUnitID& cu_id) {
+  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
+  service_->RemoveFrame(cu_id);
+}
+
+}  // namespace resource_coordinator
--- a/services/resource_coordinator/public/cpp/page_resource_coordinator.h	1970-01-01 03:00:00.000000000 +0300
+++ b/services/resource_coordinator/public/cpp/page_resource_coordinator.h	2019-05-17 18:53:37.968000000 +0300
@@ -0,0 +1,55 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef SERVICES_RESOURCE_COORDINATOR_PUBLIC_CPP_PAGE_RESOURCE_COORDINATOR_H_
+#define SERVICES_RESOURCE_COORDINATOR_PUBLIC_CPP_PAGE_RESOURCE_COORDINATOR_H_
+
+#include "base/memory/weak_ptr.h"
+#include "base/threading/thread_checker.h"
+#include "base/time/time.h"
+#include "services/resource_coordinator/public/cpp/frame_resource_coordinator.h"
+#include "services/resource_coordinator/public/cpp/resource_coordinator_interface.h"
+#include "services/resource_coordinator/public/mojom/coordination_unit.mojom.h"
+
+namespace resource_coordinator {
+
+class COMPONENT_EXPORT(SERVICES_RESOURCE_COORDINATOR_PUBLIC_CPP)
+    PageResourceCoordinator
+    : public ResourceCoordinatorInterface<mojom::PageCoordinationUnitPtr,
+                                          mojom::PageCoordinationUnitRequest> {
+ public:
+  PageResourceCoordinator(service_manager::Connector* connector);
+  ~PageResourceCoordinator() override;
+
+  void SetIsLoading(bool is_loading);
+  void SetVisibility(bool visible);
+  void SetUKMSourceId(int64_t ukm_source_id);
+  void OnFaviconUpdated();
+  void OnTitleUpdated();
+  void OnMainFrameNavigationCommitted(base::TimeTicks navigation_committed_time,
+                                      uint64_t navigation_id,
+                                      const std::string& url);
+
+  void AddFrame(const FrameResourceCoordinator& frame);
+  void RemoveFrame(const FrameResourceCoordinator& frame);
+
+ private:
+  void ConnectToService(mojom::CoordinationUnitProviderPtr& provider,
+                        const CoordinationUnitID& cu_id) override;
+
+  void AddFrameByID(const CoordinationUnitID& cu_id);
+  void RemoveFrameByID(const CoordinationUnitID& cu_id);
+
+  THREAD_CHECKER(thread_checker_);
+
+  // The WeakPtrFactory should come last so the weak ptrs are invalidated
+  // before the rest of the member variables.
+  base::WeakPtrFactory<PageResourceCoordinator> weak_ptr_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(PageResourceCoordinator);
+};
+
+}  // namespace resource_coordinator
+
+#endif  // SERVICES_RESOURCE_COORDINATOR_PUBLIC_CPP_PAGE_RESOURCE_COORDINATOR_H_
--- a/services/resource_coordinator/public/cpp/process_resource_coordinator.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/services/resource_coordinator/public/cpp/process_resource_coordinator.cc	2019-05-17 18:53:37.968000000 +0300
@@ -0,0 +1,61 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "services/resource_coordinator/public/cpp/process_resource_coordinator.h"
+
+#include "base/time/time.h"
+#include "build/build_config.h"
+
+namespace resource_coordinator {
+
+ProcessResourceCoordinator::ProcessResourceCoordinator(
+    service_manager::Connector* connector)
+    : ResourceCoordinatorInterface(), weak_ptr_factory_(this) {
+  CoordinationUnitID new_cu_id(CoordinationUnitType::kProcess,
+                               CoordinationUnitID::RANDOM_ID);
+  ResourceCoordinatorInterface::ConnectToService(connector, new_cu_id);
+}
+
+ProcessResourceCoordinator::~ProcessResourceCoordinator() = default;
+
+void ProcessResourceCoordinator::OnProcessLaunched(
+    const base::Process& process) {
+  if (!service_)
+    return;
+
+  // TODO(fdoray): Merge ProcessCoordinationUnit::SetPID/SetLaunchTime().
+  service_->SetPID(process.Pid());
+  service_->SetLaunchTime(
+#if defined(OS_ANDROID)
+      // Process::CreationTime() is not available on Android. Since this method
+      // is called immediately after the process is launched, the process launch
+      // time can be approximated with the current time.
+      base::Time::Now()
+#else
+      process.CreationTime()
+#endif
+          );
+}
+
+void ProcessResourceCoordinator::SetCPUUsage(double cpu_usage) {
+  if (!service_)
+    return;
+
+  service_->SetCPUUsage(cpu_usage);
+}
+
+void ProcessResourceCoordinator::SetProcessExitStatus(int32_t exit_status) {
+  if (!service_)
+    return;
+
+  service_->SetProcessExitStatus(exit_status);
+}
+
+void ProcessResourceCoordinator::ConnectToService(
+    mojom::CoordinationUnitProviderPtr& provider,
+    const CoordinationUnitID& cu_id) {
+  provider->CreateProcessCoordinationUnit(mojo::MakeRequest(&service_), cu_id);
+}
+
+}  // namespace resource_coordinator
--- a/services/resource_coordinator/public/cpp/process_resource_coordinator.h	1970-01-01 03:00:00.000000000 +0300
+++ b/services/resource_coordinator/public/cpp/process_resource_coordinator.h	2019-05-17 18:53:37.968000000 +0300
@@ -0,0 +1,46 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef SERVICES_RESOURCE_COORDINATOR_PUBLIC_CPP_PROCESS_RESOURCE_COORDINATOR_H_
+#define SERVICES_RESOURCE_COORDINATOR_PUBLIC_CPP_PROCESS_RESOURCE_COORDINATOR_H_
+
+#include "base/memory/weak_ptr.h"
+#include "base/process/process.h"
+#include "base/threading/thread_checker.h"
+#include "services/resource_coordinator/public/cpp/frame_resource_coordinator.h"
+#include "services/resource_coordinator/public/cpp/resource_coordinator_interface.h"
+#include "services/resource_coordinator/public/mojom/coordination_unit.mojom.h"
+
+namespace resource_coordinator {
+
+class COMPONENT_EXPORT(SERVICES_RESOURCE_COORDINATOR_PUBLIC_CPP)
+    ProcessResourceCoordinator : public ResourceCoordinatorInterface<
+                                     mojom::ProcessCoordinationUnitPtr,
+                                     mojom::ProcessCoordinationUnitRequest> {
+ public:
+  ProcessResourceCoordinator(service_manager::Connector* connector);
+  ~ProcessResourceCoordinator() override;
+
+  // Must be called immediately after the process is launched.
+  void OnProcessLaunched(const base::Process& process);
+
+  void SetCPUUsage(double usage);
+  void SetProcessExitStatus(int32_t exit_status);
+
+ private:
+  void ConnectToService(mojom::CoordinationUnitProviderPtr& provider,
+                        const CoordinationUnitID& cu_id) override;
+
+  THREAD_CHECKER(thread_checker_);
+
+  // The WeakPtrFactory should come last so the weak ptrs are invalidated
+  // before the rest of the member variables.
+  base::WeakPtrFactory<ProcessResourceCoordinator> weak_ptr_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(ProcessResourceCoordinator);
+};
+
+}  // namespace resource_coordinator
+
+#endif  // SERVICES_RESOURCE_COORDINATOR_PUBLIC_CPP_PROCESS_RESOURCE_COORDINATOR_H_
--- a/services/resource_coordinator/public/cpp/resource_coordinator_interface.h	1970-01-01 03:00:00.000000000 +0300
+++ b/services/resource_coordinator/public/cpp/resource_coordinator_interface.h	2019-05-17 18:53:37.968000000 +0300
@@ -0,0 +1,69 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef SERVICES_RESOURCE_COORDINATOR_PUBLIC_CPP_RESOURCE_COORDINATOR_INTERFACE_H_
+#define SERVICES_RESOURCE_COORDINATOR_PUBLIC_CPP_RESOURCE_COORDINATOR_INTERFACE_H_
+
+#include <stdint.h>
+
+#include "base/component_export.h"
+#include "base/macros.h"
+#include "services/resource_coordinator/public/cpp/coordination_unit_id.h"
+#include "services/resource_coordinator/public/mojom/coordination_unit_provider.mojom.h"
+#include "services/resource_coordinator/public/mojom/service_constants.mojom.h"
+#include "services/service_manager/public/cpp/connector.h"
+
+namespace resource_coordinator {
+
+template <class CoordinationUnitMojoPtr, class CoordinationUnitMojoRequest>
+class ResourceCoordinatorInterface {
+ public:
+  ResourceCoordinatorInterface() = default;
+  virtual ~ResourceCoordinatorInterface() = default;
+
+  void AddBinding(CoordinationUnitMojoRequest request) {
+    if (!service_)
+      return;
+    service_->AddBinding(std::move(request));
+  }
+
+  // Returns the ID. Note that this is meaningless for a singleton CU.
+  CoordinationUnitID id() const { return cu_id_; }
+
+  // Returns the remote endpoint interface.
+  const CoordinationUnitMojoPtr& service() const { return service_; }
+
+  // Expose the GetID function for testing.
+  using CoordinationUnitMojo = typename CoordinationUnitMojoPtr::InterfaceType;
+  using GetIDCallback = typename CoordinationUnitMojo::GetIDCallback;
+  void GetID(GetIDCallback callback) {
+    if (!service_)
+      std::move(callback).Run(cu_id_);
+    service_->GetID(std::move(callback));
+  }
+
+ protected:
+  virtual void ConnectToService(mojom::CoordinationUnitProviderPtr& provider,
+                                const CoordinationUnitID& cu_id) = 0;
+
+  void ConnectToService(service_manager::Connector* connector,
+                        const CoordinationUnitID& cu_id) {
+    if (!connector)
+      return;
+    cu_id_ = cu_id;
+    mojom::CoordinationUnitProviderPtr provider;
+    connector->BindInterface(mojom::kServiceName, mojo::MakeRequest(&provider));
+    ConnectToService(provider, cu_id);
+  }
+
+  CoordinationUnitMojoPtr service_;
+  CoordinationUnitID cu_id_;
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(ResourceCoordinatorInterface);
+};
+
+}  // namespace resource_coordinator
+
+#endif  // SERVICES_RESOURCE_COORDINATOR_PUBLIC_CPP_RESOURCE_COORDINATOR_INTERFACE_H_
--- a/services/resource_coordinator/public/cpp/system_resource_coordinator.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/services/resource_coordinator/public/cpp/system_resource_coordinator.cc	2019-05-17 18:53:37.968000000 +0300
@@ -0,0 +1,32 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "services/resource_coordinator/public/cpp/system_resource_coordinator.h"
+
+namespace resource_coordinator {
+
+SystemResourceCoordinator::SystemResourceCoordinator(
+    service_manager::Connector* connector)
+    : ResourceCoordinatorInterface() {
+  CoordinationUnitID new_cu_id(CoordinationUnitType::kSystem,
+                               CoordinationUnitID::RANDOM_ID);
+  ResourceCoordinatorInterface::ConnectToService(connector, new_cu_id);
+}
+
+SystemResourceCoordinator::~SystemResourceCoordinator() = default;
+
+void SystemResourceCoordinator::DistributeMeasurementBatch(
+    mojom::ProcessResourceMeasurementBatchPtr batch) {
+  if (!service_)
+    return;
+  service_->DistributeMeasurementBatch(std::move(batch));
+}
+
+void SystemResourceCoordinator::ConnectToService(
+    mojom::CoordinationUnitProviderPtr& provider,
+    const CoordinationUnitID& cu_id) {
+  provider->GetSystemCoordinationUnit(mojo::MakeRequest(&service_));
+}
+
+}  // namespace resource_coordinator
--- a/services/resource_coordinator/public/cpp/system_resource_coordinator.h	1970-01-01 03:00:00.000000000 +0300
+++ b/services/resource_coordinator/public/cpp/system_resource_coordinator.h	2019-05-17 18:53:37.968000000 +0300
@@ -0,0 +1,33 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef SERVICES_RESOURCE_COORDINATOR_PUBLIC_CPP_SYSTEM_RESOURCE_COORDINATOR_H_
+#define SERVICES_RESOURCE_COORDINATOR_PUBLIC_CPP_SYSTEM_RESOURCE_COORDINATOR_H_
+
+#include "services/resource_coordinator/public/cpp/resource_coordinator_interface.h"
+#include "services/resource_coordinator/public/mojom/coordination_unit.mojom.h"
+
+namespace resource_coordinator {
+
+class COMPONENT_EXPORT(SERVICES_RESOURCE_COORDINATOR_PUBLIC_CPP)
+    SystemResourceCoordinator : public ResourceCoordinatorInterface<
+                                    mojom::SystemCoordinationUnitPtr,
+                                    mojom::SystemCoordinationUnitRequest> {
+ public:
+  SystemResourceCoordinator(service_manager::Connector* connector);
+  ~SystemResourceCoordinator() override;
+
+  void DistributeMeasurementBatch(
+      mojom::ProcessResourceMeasurementBatchPtr batch);
+
+ private:
+  void ConnectToService(mojom::CoordinationUnitProviderPtr& provider,
+                        const CoordinationUnitID& cu_id) override;
+
+  DISALLOW_COPY_AND_ASSIGN(SystemResourceCoordinator);
+};
+
+}  // namespace resource_coordinator
+
+#endif  // SERVICES_RESOURCE_COORDINATOR_PUBLIC_CPP_SYSTEM_RESOURCE_COORDINATOR_H_
--- a/services/resource_coordinator/resource_coordinator_clock.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/services/resource_coordinator/resource_coordinator_clock.cc	2019-05-17 18:53:37.968000000 +0300
@@ -0,0 +1,39 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "services/resource_coordinator/resource_coordinator_clock.h"
+
+#include "base/time/tick_clock.h"
+
+namespace resource_coordinator {
+
+namespace {
+
+const base::TickClock*& g_tick_clock_for_testing() {
+  static const base::TickClock* tick_clock_for_testing = nullptr;
+  return tick_clock_for_testing;
+}
+
+}  // namespace
+
+base::TimeTicks ResourceCoordinatorClock::NowTicks() {
+  return g_tick_clock_for_testing() ? g_tick_clock_for_testing()->NowTicks()
+                                    : base::TimeTicks::Now();
+}
+
+const base::TickClock* ResourceCoordinatorClock::GetClockForTesting() {
+  return g_tick_clock_for_testing();
+}
+
+void ResourceCoordinatorClock::ResetClockForTesting() {
+  g_tick_clock_for_testing() = nullptr;
+}
+
+void ResourceCoordinatorClock::SetClockForTesting(
+    const base::TickClock* tick_clock) {
+  DCHECK(!g_tick_clock_for_testing());
+  g_tick_clock_for_testing() = tick_clock;
+}
+
+}  // namespace resource_coordinator
--- a/services/resource_coordinator/resource_coordinator_clock.h	1970-01-01 03:00:00.000000000 +0300
+++ b/services/resource_coordinator/resource_coordinator_clock.h	2019-05-17 18:53:37.968000000 +0300
@@ -0,0 +1,41 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef SERVICES_RESOURCE_COORDINATOR_RESOURCE_COORDINATOR_CLOCK_H_
+#define SERVICES_RESOURCE_COORDINATOR_RESOURCE_COORDINATOR_CLOCK_H_
+
+#include <memory>
+
+#include "base/macros.h"
+#include "base/time/time.h"
+
+namespace base {
+class TickClock;
+}
+
+namespace resource_coordinator {
+
+// ResourceCoordinatorClock provides timing methods that resource_coordinator/
+// needs at a central place, and facilitates testing across components when
+// clock manipulation is needed.
+class ResourceCoordinatorClock {
+ public:
+  // Returns time from the testing TickClock if set; otherwise returns time from
+  // TimeTicks::Now().
+  static base::TimeTicks NowTicks();
+
+  static const base::TickClock* GetClockForTesting();
+
+  // Sets a TickClock for testing.
+  static void SetClockForTesting(const base::TickClock* tick_clock);
+
+  static void ResetClockForTesting();
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(ResourceCoordinatorClock);
+};
+
+}  // namespace resource_coordinator
+
+#endif  // SERVICES_RESOURCE_COORDINATOR_RESOURCE_COORDINATOR_CLOCK_H_
--- a/services/resource_coordinator/resource_coordinator_service_unittest.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/services/resource_coordinator/resource_coordinator_service_unittest.cc	2019-05-17 18:53:37.968000000 +0300
@@ -0,0 +1,123 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include <memory>
+
+#include "base/macros.h"
+#include "base/run_loop.h"
+#include "base/test/scoped_task_environment.h"
+#include "mojo/public/cpp/bindings/binding.h"
+#include "services/resource_coordinator/public/cpp/frame_resource_coordinator.h"
+#include "services/resource_coordinator/public/cpp/page_resource_coordinator.h"
+#include "services/resource_coordinator/public/cpp/process_resource_coordinator.h"
+#include "services/resource_coordinator/public/cpp/system_resource_coordinator.h"
+#include "services/resource_coordinator/public/mojom/coordination_unit_provider.mojom.h"
+#include "services/resource_coordinator/public/mojom/service_constants.mojom.h"
+#include "services/resource_coordinator/resource_coordinator_service.h"
+#include "services/service_manager/public/cpp/test/test_connector_factory.h"
+#include "testing/gtest/include/gtest/gtest.h"
+
+namespace resource_coordinator {
+
+class ResourceCoordinatorTest : public testing::Test {
+ public:
+  ResourceCoordinatorTest()
+      : service_(
+            test_connector_factory_.RegisterInstance(mojom::kServiceName)) {
+    // The resource_coordinator service may attempt to connect to the metrics
+    // service. Allow these requests to be silently ignored rather than
+    // bringing up or simulating the metrics service just for unit tests.
+    test_connector_factory_.set_ignore_unknown_service_requests(true);
+  }
+
+  ~ResourceCoordinatorTest() override {}
+
+  void GetIDCallback(const CoordinationUnitID& cu_id) {
+    loop_->Quit();
+  }
+
+  // Given a CU, tests that it works by invoking GetID and waiting for the
+  // response. This test will hang (and eventually fail) if the response does
+  // not come back from the remote endpoint.
+  template <typename CoordinationUnitPtrType>
+  void TestCUImpl(CoordinationUnitPtrType cu) {
+    base::RunLoop loop;
+    loop_ = &loop;
+    cu->GetID(base::BindOnce(&ResourceCoordinatorTest::GetIDCallback,
+                             base::Unretained(this)));
+    loop.Run();
+    loop_ = nullptr;
+  }
+
+  // Variant that works with mojo interface pointers.
+  template <typename CoordinationUnitPtrType>
+  void TestCU(CoordinationUnitPtrType& cu) {
+    TestCUImpl<CoordinationUnitPtrType&>(cu);
+  }
+
+  // Variant that works with pointers to FooResourceCoordinator wrappers.
+  template <typename CoordinationUnitPtrType>
+  void TestCU(CoordinationUnitPtrType* cu) {
+    TestCUImpl<CoordinationUnitPtrType*>(cu);
+  }
+
+ protected:
+  service_manager::Connector* connector() {
+    return test_connector_factory_.GetDefaultConnector();
+  }
+
+ private:
+  base::test::ScopedTaskEnvironment task_environment_;
+  service_manager::TestConnectorFactory test_connector_factory_;
+  ResourceCoordinatorService service_;
+
+  base::RunLoop* loop_ = nullptr;
+
+  DISALLOW_COPY_AND_ASSIGN(ResourceCoordinatorTest);
+};
+
+TEST_F(ResourceCoordinatorTest, ResourceCoordinatorInstantiate) {
+  // Get the CU provider interface.
+  mojom::CoordinationUnitProviderPtr provider;
+  connector()->BindInterface(mojom::kServiceName, mojo::MakeRequest(&provider));
+
+  // Create and test a dummy FrameCU.
+  CoordinationUnitID frame_id(CoordinationUnitType::kFrame,
+                              CoordinationUnitID::RANDOM_ID);
+  mojom::FrameCoordinationUnitPtr frame_cu;
+  provider->CreateFrameCoordinationUnit(mojo::MakeRequest(&frame_cu), frame_id);
+  TestCU(frame_cu);
+
+  // Create and test a dummy PageCU.
+  CoordinationUnitID page_id(CoordinationUnitType::kPage,
+                             CoordinationUnitID::RANDOM_ID);
+  mojom::PageCoordinationUnitPtr page_cu;
+  provider->CreatePageCoordinationUnit(mojo::MakeRequest(&page_cu), page_id);
+  TestCU(page_cu);
+
+  // Create and test a dummy SystemCU.
+  mojom::SystemCoordinationUnitPtr system_cu;
+  provider->GetSystemCoordinationUnit(mojo::MakeRequest(&system_cu));
+  TestCU(system_cu);
+
+  // Create and test a dummy ProcessCU.
+  CoordinationUnitID process_id(CoordinationUnitType::kProcess,
+                                CoordinationUnitID::RANDOM_ID);
+  mojom::ProcessCoordinationUnitPtr process_cu;
+  provider->CreateProcessCoordinationUnit(mojo::MakeRequest(&process_cu),
+                                          process_id);
+  TestCU(process_cu);
+
+  // Also test the convenience headers for creating and communicating with CUs.
+  FrameResourceCoordinator frame_rc(connector());
+  TestCU(&frame_rc);
+  PageResourceCoordinator page_rc(connector());
+  TestCU(&page_rc);
+  ProcessResourceCoordinator process_rc(connector());
+  TestCU(&process_rc);
+  SystemResourceCoordinator system_rc(connector());
+  TestCU(&system_rc);
+}
+
+}  // namespace resource_coordinator
--- a/services/resource_coordinator/webui_graph_dump_impl.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/services/resource_coordinator/webui_graph_dump_impl.cc	2019-05-17 18:53:37.968000000 +0300
@@ -0,0 +1,82 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "services/resource_coordinator/webui_graph_dump_impl.h"
+
+#include "base/macros.h"
+#include "services/resource_coordinator/coordination_unit/coordination_unit_graph.h"
+#include "services/resource_coordinator/coordination_unit/frame_coordination_unit_impl.h"
+#include "services/resource_coordinator/coordination_unit/page_coordination_unit_impl.h"
+#include "services/resource_coordinator/coordination_unit/process_coordination_unit_impl.h"
+
+namespace resource_coordinator {
+
+WebUIGraphDumpImpl::WebUIGraphDumpImpl(CoordinationUnitGraph* graph)
+    : graph_(graph), binding_(this) {
+  DCHECK(graph);
+}
+
+WebUIGraphDumpImpl::~WebUIGraphDumpImpl() {}
+
+void WebUIGraphDumpImpl::Bind(mojom::WebUIGraphDumpRequest request,
+                              base::OnceClosure error_handler) {
+  binding_.Bind(std::move(request));
+  binding_.set_connection_error_handler(std::move(error_handler));
+}
+
+void WebUIGraphDumpImpl::GetCurrentGraph(GetCurrentGraphCallback callback) {
+  mojom::WebUIGraphPtr graph = mojom::WebUIGraph::New();
+
+  {
+    auto processes = graph_->GetAllProcessCoordinationUnits();
+    graph->processes.reserve(processes.size());
+    for (auto* process : processes) {
+      mojom::WebUIProcessInfoPtr process_info = mojom::WebUIProcessInfo::New();
+
+      process_info->id = process->id().id;
+      process_info->pid = process->process_id();
+      process_info->cumulative_cpu_usage = process->cumulative_cpu_usage();
+      process_info->private_footprint_kb = process->private_footprint_kb();
+
+      graph->processes.push_back(std::move(process_info));
+    }
+  }
+
+  {
+    auto frames = graph_->GetAllFrameCoordinationUnits();
+    graph->frames.reserve(frames.size());
+    for (auto* frame : frames) {
+      mojom::WebUIFrameInfoPtr frame_info = mojom::WebUIFrameInfo::New();
+
+      frame_info->id = frame->id().id;
+
+      auto* parent_frame = frame->GetParentFrameCoordinationUnit();
+      frame_info->parent_frame_id = parent_frame ? parent_frame->id().id : 0;
+
+      auto* process = frame->GetProcessCoordinationUnit();
+      frame_info->process_id = process ? process->id().id : 0;
+
+      graph->frames.push_back(std::move(frame_info));
+    }
+  }
+
+  {
+    auto pages = graph_->GetAllPageCoordinationUnits();
+    graph->pages.reserve(pages.size());
+    for (auto* page : pages) {
+      mojom::WebUIPageInfoPtr page_info = mojom::WebUIPageInfo::New();
+
+      page_info->id = page->id().id;
+      page_info->main_frame_url = page->main_frame_url();
+
+      auto* main_frame = page->GetMainFrameCoordinationUnit();
+      page_info->main_frame_id = main_frame ? main_frame->id().id : 0;
+
+      graph->pages.push_back(std::move(page_info));
+    }
+  }
+  std::move(callback).Run(std::move(graph));
+}
+
+}  // namespace resource_coordinator
--- a/services/resource_coordinator/webui_graph_dump_impl.h	1970-01-01 03:00:00.000000000 +0300
+++ b/services/resource_coordinator/webui_graph_dump_impl.h	2019-05-17 18:53:37.968000000 +0300
@@ -0,0 +1,36 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef SERVICES_RESOURCE_COORDINATOR_WEBUI_GRAPH_DUMP_IMPL_H_
+#define SERVICES_RESOURCE_COORDINATOR_WEBUI_GRAPH_DUMP_IMPL_H_
+
+#include "mojo/public/cpp/bindings/binding.h"
+#include "services/resource_coordinator/public/mojom/webui_graph_dump.mojom.h"
+
+namespace resource_coordinator {
+
+class CoordinationUnitGraph;
+
+class WebUIGraphDumpImpl : public mojom::WebUIGraphDump {
+ public:
+  explicit WebUIGraphDumpImpl(CoordinationUnitGraph* graph);
+  ~WebUIGraphDumpImpl() override;
+
+  // WebUIGraphDump implementation.
+  void GetCurrentGraph(GetCurrentGraphCallback callback) override;
+
+  // Bind this instance to |request| with the |error_handler|.
+  void Bind(mojom::WebUIGraphDumpRequest request,
+            base::OnceClosure error_handler);
+
+ private:
+  CoordinationUnitGraph* graph_;
+  mojo::Binding<mojom::WebUIGraphDump> binding_;
+
+  DISALLOW_COPY_AND_ASSIGN(WebUIGraphDumpImpl);
+};
+
+}  // namespace resource_coordinator
+
+#endif  // SERVICES_RESOURCE_COORDINATOR_WEBUI_GRAPH_DUMP_IMPL_H_
--- a/services/resource_coordinator/webui_graph_dump_impl_unittest.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/services/resource_coordinator/webui_graph_dump_impl_unittest.cc	2019-05-17 18:53:37.968000000 +0300
@@ -0,0 +1,67 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "services/resource_coordinator/webui_graph_dump_impl.h"
+
+#include "base/test/bind_test_util.h"
+#include "base/time/time.h"
+#include "services/resource_coordinator/coordination_unit/coordination_unit_test_harness.h"
+#include "services/resource_coordinator/coordination_unit/mock_coordination_unit_graphs.h"
+#include "services/resource_coordinator/coordination_unit/page_coordination_unit_impl.h"
+#include "services/resource_coordinator/resource_coordinator_clock.h"
+#include "testing/gtest/include/gtest/gtest.h"
+
+namespace resource_coordinator {
+
+class WebUIGraphDumpImplTest : public CoordinationUnitTestHarness {};
+
+TEST_F(WebUIGraphDumpImplTest, Create) {
+  CoordinationUnitGraph graph;
+  MockMultiplePagesWithMultipleProcessesCoordinationUnitGraph cu_graph(&graph);
+
+  base::TimeTicks now = ResourceCoordinatorClock::NowTicks();
+
+  constexpr char kExampleUrl[] = "http://www.example.org";
+  cu_graph.page->OnMainFrameNavigationCommitted(now, 1, kExampleUrl);
+  cu_graph.other_page->OnMainFrameNavigationCommitted(now, 2, kExampleUrl);
+
+  WebUIGraphDumpImpl impl(&graph);
+
+  mojom::WebUIGraphPtr returned_graph;
+  WebUIGraphDumpImpl::GetCurrentGraphCallback callback =
+      base::BindLambdaForTesting([&returned_graph](mojom::WebUIGraphPtr graph) {
+        returned_graph = std::move(graph);
+      });
+  impl.GetCurrentGraph(std::move(callback));
+
+  task_env().RunUntilIdle();
+
+  ASSERT_NE(nullptr, returned_graph.get());
+  EXPECT_EQ(2u, returned_graph->pages.size());
+  for (const auto& page : returned_graph->pages) {
+    EXPECT_NE(0u, page->id);
+    EXPECT_NE(0u, page->main_frame_id);
+  }
+
+  EXPECT_EQ(3u, returned_graph->frames.size());
+  // Count the top-level frames as we go.
+  size_t top_level_frames = 0;
+  for (const auto& frame : returned_graph->frames) {
+    if (frame->parent_frame_id == 0)
+      ++top_level_frames;
+    EXPECT_NE(0u, frame->id);
+    EXPECT_NE(0u, frame->process_id);
+  }
+  // Make sure we have one top-level frame per page.
+  EXPECT_EQ(returned_graph->pages.size(), top_level_frames);
+
+  EXPECT_EQ(2u, returned_graph->processes.size());
+  for (const auto& page : returned_graph->pages) {
+    EXPECT_NE(0u, page->id);
+    EXPECT_NE(0u, page->main_frame_id);
+    EXPECT_EQ(kExampleUrl, page->main_frame_url);
+  }
+}
+
+}  // namespace resource_coordinator
diff -BbuN a/services/service_manager/background/background_service_manager.cc b/services/service_manager/background/background_service_manager.cc
--- a/services/service_manager/background/background_service_manager.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/services/service_manager/background/background_service_manager.cc	2019-05-17 18:53:37.972000000 +0300
@@ -0,0 +1,84 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "services/service_manager/background/background_service_manager.h"
+
+#include "base/bind.h"
+#include "base/bind_helpers.h"
+#include "base/command_line.h"
+#include "base/logging.h"
+#include "base/memory/ref_counted.h"
+#include "base/message_loop/message_pump_default.h"
+#include "base/path_service.h"
+#include "base/run_loop.h"
+#include "base/sequenced_task_runner.h"
+#include "base/single_thread_task_runner.h"
+#include "base/synchronization/waitable_event.h"
+#include "base/threading/simple_thread.h"
+#include "services/catalog/store.h"
+#include "services/service_manager/connect_params.h"
+#include "services/service_manager/public/cpp/service.h"
+#include "services/service_manager/service_manager.h"
+#include "services/service_manager/standalone/context.h"
+
+namespace service_manager {
+
+BackgroundServiceManager::BackgroundServiceManager(
+    ServiceProcessLauncherDelegate* launcher_delegate,
+    const std::vector<Manifest>& manifests)
+    : background_thread_("service_manager") {
+  background_thread_.Start();
+  background_thread_.task_runner()->PostTask(
+      FROM_HERE,
+      base::BindOnce(&BackgroundServiceManager::InitializeOnBackgroundThread,
+                     base::Unretained(this), launcher_delegate, manifests));
+}
+
+BackgroundServiceManager::~BackgroundServiceManager() {
+  base::WaitableEvent done_event(
+      base::WaitableEvent::ResetPolicy::MANUAL,
+      base::WaitableEvent::InitialState::NOT_SIGNALED);
+  background_thread_.task_runner()->PostTask(
+      FROM_HERE,
+      base::Bind(&BackgroundServiceManager::ShutDownOnBackgroundThread,
+                 base::Unretained(this), &done_event));
+  done_event.Wait();
+  DCHECK(!context_);
+}
+
+void BackgroundServiceManager::RegisterService(
+    const Identity& identity,
+    mojom::ServicePtr service,
+    mojom::PIDReceiverRequest pid_receiver_request) {
+  mojom::ServicePtrInfo service_info = service.PassInterface();
+  background_thread_.task_runner()->PostTask(
+      FROM_HERE,
+      base::Bind(&BackgroundServiceManager::RegisterServiceOnBackgroundThread,
+                 base::Unretained(this), identity, base::Passed(&service_info),
+                 base::Passed(&pid_receiver_request)));
+}
+
+void BackgroundServiceManager::InitializeOnBackgroundThread(
+    ServiceProcessLauncherDelegate* launcher_delegate,
+    const std::vector<Manifest>& manifests) {
+  context_ = std::make_unique<Context>(launcher_delegate, manifests);
+}
+
+void BackgroundServiceManager::ShutDownOnBackgroundThread(
+    base::WaitableEvent* done_event) {
+  context_.reset();
+  done_event->Signal();
+}
+
+void BackgroundServiceManager::RegisterServiceOnBackgroundThread(
+    const Identity& identity,
+    mojom::ServicePtrInfo service_info,
+    mojom::PIDReceiverRequest pid_receiver_request) {
+  mojom::ServicePtr service;
+  service.Bind(std::move(service_info));
+  context_->service_manager()->RegisterService(
+      identity, std::move(service), std::move(pid_receiver_request));
+}
+
+}  // namespace service_manager
diff -BbuN a/services/service_manager/background/background_service_manager.h b/services/service_manager/background/background_service_manager.h
--- a/services/service_manager/background/background_service_manager.h	1970-01-01 03:00:00.000000000 +0300
+++ b/services/service_manager/background/background_service_manager.h	2019-05-17 18:53:37.972000000 +0300
@@ -0,0 +1,67 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef SERVICES_SERVICE_MANAGER_BACKGROUND_BACKGROUND_SERVICE_MANAGER_H_
+#define SERVICES_SERVICE_MANAGER_BACKGROUND_BACKGROUND_SERVICE_MANAGER_H_
+
+#include <memory>
+#include <vector>
+
+#include "base/macros.h"
+#include "base/threading/thread.h"
+#include "build/build_config.h"
+#include "services/service_manager/public/cpp/manifest.h"
+#include "services/service_manager/public/mojom/connector.mojom.h"
+#include "services/service_manager/public/mojom/service.mojom.h"
+#include "services/service_manager/runner/host/service_process_launcher_delegate.h"
+
+namespace base {
+class WaitableEvent;
+}
+
+namespace service_manager {
+
+class Context;
+class Identity;
+class ServiceManager;
+
+// BackgroundServiceManager runs a Service Manager on a dedicated background
+// thread.
+class BackgroundServiceManager {
+ public:
+  BackgroundServiceManager(ServiceProcessLauncherDelegate* launcher_delegate,
+                           const std::vector<Manifest>& manifests);
+  ~BackgroundServiceManager();
+
+  // Creates a service instance for |identity|. This is intended for use by the
+  // Service Manager's embedder to register instances directly, without
+  // requiring a Connector.
+  //
+  // |pid_receiver_request| may be null, in which case the service manager
+  // assumes the new service is running in this process.
+  void RegisterService(const Identity& identity,
+                       mojom::ServicePtr service,
+                       mojom::PIDReceiverRequest pid_receiver_request);
+
+ private:
+  void InitializeOnBackgroundThread(
+      ServiceProcessLauncherDelegate* launcher_delegate,
+      const std::vector<Manifest>& manifests);
+  void ShutDownOnBackgroundThread(base::WaitableEvent* done_event);
+  void RegisterServiceOnBackgroundThread(
+      const Identity& identity,
+      mojom::ServicePtrInfo service_info,
+      mojom::PIDReceiverRequest pid_receiver_request);
+
+  base::Thread background_thread_;
+
+  // The ServiceManager context. Must only be used on the background thread.
+  std::unique_ptr<Context> context_;
+
+  DISALLOW_COPY_AND_ASSIGN(BackgroundServiceManager);
+};
+
+}  // namespace service_manager
+
+#endif  // SERVICES_SERVICE_MANAGER_BACKGROUND_BACKGROUND_SERVICE_MANAGER_H_
diff -BbuN a/services/service_manager/background/BUILD.gn b/services/service_manager/background/BUILD.gn
--- a/services/service_manager/background/BUILD.gn	1970-01-01 03:00:00.000000000 +0300
+++ b/services/service_manager/background/BUILD.gn	2019-05-17 18:53:37.972000000 +0300
@@ -0,0 +1,27 @@
+# Copyright 2016 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+group("background") {
+  testonly = true
+  deps = [
+    ":lib",
+  ]
+}
+
+source_set("lib") {
+  sources = [
+    "background_service_manager.cc",
+    "background_service_manager.h",
+  ]
+  deps = [
+    "//base",
+    "//services/catalog:constants",
+    "//services/catalog:lib",
+    "//services/service_manager",
+    "//services/service_manager/public/cpp",
+    "//services/service_manager/runner:init",
+    "//services/service_manager/runner/host:lib",
+    "//services/service_manager/standalone",
+  ]
+}
diff -BbuN a/services/service_manager/background/DEPS b/services/service_manager/background/DEPS
--- a/services/service_manager/background/DEPS	1970-01-01 03:00:00.000000000 +0300
+++ b/services/service_manager/background/DEPS	2019-05-17 18:53:37.972000000 +0300
@@ -0,0 +1,3 @@
+include_rules = [
+  "+services/catalog",
+]
Общие подкаталоги: a/services/service_manager/background/tests и b/services/service_manager/background/tests
--- a/services/service_manager/public/cpp/test/DEPS	1970-01-01 03:00:00.000000000 +0300
+++ b/services/service_manager/public/cpp/test/DEPS	2019-05-17 18:53:37.980000000 +0300
@@ -0,0 +1,5 @@
+specific_include_rules = {
+  "run_all_service_tests.cc": [
+    "+services/catalog",
+  ]
+}
--- a/services/service_manager/public/service_manifest.gni	1970-01-01 03:00:00.000000000 +0300
+++ b/services/service_manager/public/service_manifest.gni	2019-05-17 18:53:37.980000000 +0300
@@ -0,0 +1,209 @@
+# Copyright 2016 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+import("//build/config/dcheck_always_on.gni")
+
+# Generates code to produce a compiled service_manager::Manifest from a JSON
+# description at build time.
+#
+# This is a temporary helper for the transition away from JSON manifests. Do not
+# introduce new service_manifest targets.
+#
+# This template yields a source_set target which defines a symbol named
+# "${name}::GetManifest()" where ${name} is the service name given in the
+# target.
+#
+# All service_manifest targets should be replaced with in-tree C++ sources.
+template("service_manifest") {
+  assert(defined(invoker.source),
+         "\"source\" must be defined for the $target_name target")
+
+  generator_target_name = "${target_name}__generator"
+  generated_sources = [
+    "$target_gen_dir/${target_name}.cc",
+    "$target_gen_dir/${target_name}.h",
+  ]
+
+  # We prefer to use |name| for the generated function's namespace if a
+  # |generated_namespace| isn't explicitly defined. It turns out that we also
+  # have a few targets which don't specify a |name| though; they all have unique
+  # target names, so we fall back on that if necessary. The important detail is
+  # that all generated GetManifest() functions should live in their own
+  # namespace, and with the current (and final) set of service_manifest targets
+  # in the tree, these rules accomplish that.
+  if (defined(invoker.generated_namespace)) {
+    output_namespace = invoker.generated_namespace
+  } else if (defined(invoker.name)) {
+    output_namespace = invoker.name
+  } else {
+    output_namespace = invoker.target_name
+  }
+
+  write_file("$target_gen_dir/${target_name}.namespace", output_namespace)
+
+  source_set(target_name) {
+    testonly = defined(invoker.testonly) && invoker.testonly
+    sources = generated_sources
+    public_deps = [
+      ":$generator_target_name",
+    ]
+
+    deps = []
+    if (defined(invoker.packaged_services)) {
+      deps += invoker.packaged_services
+    }
+    if (defined(invoker.overlays)) {
+      deps += invoker.overlays
+    }
+  }
+
+  collator_target_name = "${target_name}__collator"
+
+  action(generator_target_name) {
+    testonly = defined(invoker.testonly) && invoker.testonly
+    script = "//services/catalog/public/tools/sourcify_manifest.py"
+
+    inputs = [
+      "//services/catalog/public/tools/catalog.cc.tmpl",
+      "//services/catalog/public/tools/catalog.h.tmpl",
+      invoker.source,
+    ]
+    outputs = generated_sources
+
+    submanifest_info = []
+    if (defined(invoker.packaged_services)) {
+      foreach(submanifest, invoker.packaged_services) {
+        manifest_dir = get_label_info(submanifest, "target_gen_dir")
+        manifest_target_name = get_label_info(submanifest, "name")
+        manifest_namespace_input =
+            "$manifest_dir/${manifest_target_name}.namespace"
+        manifest_namespace_path =
+            rebase_path(manifest_namespace_input, root_build_dir)
+        manifest_header_base =
+            rebase_path(manifest_dir, root_gen_dir) + "/${manifest_target_name}"
+        submanifest_info +=
+            [ "packaged@$manifest_namespace_path@$manifest_header_base" ]
+      }
+    }
+    if (defined(invoker.overlays)) {
+      foreach(submanifest, invoker.overlays) {
+        manifest_dir = get_label_info(submanifest, "target_gen_dir")
+        manifest_target_name = get_label_info(submanifest, "name")
+        manifest_namespace_input =
+            "$manifest_dir/${manifest_target_name}.namespace"
+        manifest_namespace_path =
+            rebase_path(manifest_namespace_input, root_build_dir)
+        manifest_header_base =
+            rebase_path(manifest_dir, root_gen_dir) + "/${manifest_target_name}"
+        submanifest_info +=
+            [ "overlay@$manifest_namespace_path@$manifest_header_base" ]
+      }
+    }
+
+    submanifest_info_file =
+        "${target_gen_dir}/${invoker.target_name}.submanifest_info"
+    write_file(submanifest_info_file, submanifest_info)
+
+    args = [
+      "--root-manifest=" + rebase_path(invoker.source, root_build_dir),
+      "--submanifest-info=" +
+          rebase_path(submanifest_info_file, root_build_dir),
+      "--output-function-name=${output_namespace}::GetManifest",
+      "--output-filename-base=" +
+          rebase_path("$target_gen_dir/${invoker.target_name}", root_build_dir),
+      "--module-path=" +
+          rebase_path("$target_gen_dir/${invoker.target_name}", root_gen_dir),
+    ]
+
+    # We inherit a public dependency on the collator because service_manifest
+    # dependents still expect to use its generated JSON output. We don't
+    # actually depend on the collated JSON at all here, since packaged services
+    # and overlays are added in the generated C++ code by referring to other
+    # generated C++ code.
+    public_deps = [
+      ":$collator_target_name",
+    ]
+  }
+
+  action(collator_target_name) {
+    testonly = defined(invoker.testonly) && invoker.testonly
+
+    script =
+        "//services/service_manager/public/tools/manifest/manifest_collator.py"
+
+    deps = []
+    if (defined(invoker.deps)) {
+      deps += invoker.deps
+    }
+
+    inputs = [
+      invoker.source,
+    ]
+
+    output = "$target_gen_dir/${invoker.target_name}.json"
+    outputs = [
+      output,
+    ]
+
+    rebase_parent = rebase_path(invoker.source, root_build_dir)
+    rebase_output = rebase_path(output, root_build_dir)
+
+    args = [
+      "--parent=$rebase_parent",
+      "--output=$rebase_output",
+    ]
+
+    if (defined(invoker.name)) {
+      args += [
+        "--name",
+        invoker.name,
+      ]
+    }
+
+    if (is_debug || dcheck_always_on) {
+      args += [ "--pretty" ]
+    }
+
+    if (defined(invoker.overlays) && invoker.overlays != []) {
+      args += [ "--overlays" ]
+      foreach(manifest_target, invoker.overlays) {
+        manifest_target_dir = get_label_info(manifest_target, "target_gen_dir")
+        manifest_target_name = get_label_info(manifest_target, "name")
+        manifest_filename = "$manifest_target_dir/${manifest_target_name}.json"
+
+        inputs += [ manifest_filename ]
+        deps += [ manifest_target ]
+        args += [ rebase_path(manifest_filename, root_build_dir) ]
+
+        # Ensure that each entry does in fact reference a manifest rule.
+        label_no_toolchain =
+            get_label_info(manifest_target, "label_no_toolchain")
+        toolchain = get_label_info(manifest_target, "toolchain")
+        deps += [ "${label_no_toolchain}__is_service_manifest(${toolchain})" ]
+      }
+    }
+
+    if (defined(invoker.packaged_services)) {
+      args += [ "--packaged-services" ]
+      foreach(manifest_target, invoker.packaged_services) {
+        manifest_target_dir = get_label_info(manifest_target, "target_gen_dir")
+        manifest_target_name = get_label_info(manifest_target, "name")
+        manifest_filename = "$manifest_target_dir/${manifest_target_name}.json"
+
+        inputs += [ manifest_filename ]
+        deps += [ manifest_target ]
+        args += [ rebase_path(manifest_filename, root_build_dir) ]
+
+        # Ensure that each entry does in fact reference a manifest rule.
+        label_no_toolchain =
+            get_label_info(manifest_target, "label_no_toolchain")
+        toolchain = get_label_info(manifest_target, "toolchain")
+        deps += [ "${label_no_toolchain}__is_service_manifest(${toolchain})" ]
+      }
+    }
+  }
+
+  group("${target_name}__is_service_manifest") {
+  }
+}
Общие подкаталоги: a/services/service_manager/public/tools/manifest и b/services/service_manager/public/tools/manifest
diff -BbuN a/services/service_manager/runner/BUILD.gn b/services/service_manager/runner/BUILD.gn
--- a/services/service_manager/runner/BUILD.gn	1970-01-01 03:00:00.000000000 +0300
+++ b/services/service_manager/runner/BUILD.gn	2019-05-17 18:53:37.980000000 +0300
@@ -0,0 +1,17 @@
+# Copyright 2016 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+source_set("init") {
+  sources = [
+    "init.cc",
+    "init.h",
+  ]
+
+  deps = [
+    "//base",
+    "//base:base_static",
+    "//base:i18n",
+    "//services/service_manager/runner/common",
+  ]
+}
Общие подкаталоги: a/services/service_manager/runner/common и b/services/service_manager/runner/common
Общие подкаталоги: a/services/service_manager/runner/host и b/services/service_manager/runner/host
diff -BbuN a/services/service_manager/runner/init.cc b/services/service_manager/runner/init.cc
--- a/services/service_manager/runner/init.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/services/service_manager/runner/init.cc	2019-05-17 18:53:37.984000000 +0300
@@ -0,0 +1,91 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "services/service_manager/runner/init.h"
+
+#include <stdint.h>
+
+#include "base/base_switches.h"
+#include "base/command_line.h"
+#include "base/debug/debugger.h"
+#include "base/files/file_path.h"
+#include "base/i18n/icu_util.h"
+#include "base/logging.h"
+#include "base/stl_util.h"
+#include "base/strings/string_split.h"
+#include "base/strings/stringprintf.h"
+#include "base/strings/utf_string_conversions.h"
+#include "services/service_manager/runner/common/switches.h"
+
+#if defined(OS_WIN)
+#include <windows.h>
+#elif (OS_POSIX)
+#include <unistd.h>
+#endif
+
+namespace service_manager {
+
+void InitializeLogging() {
+  logging::LoggingSettings settings;
+  settings.logging_dest = logging::LOG_TO_SYSTEM_DEBUG_LOG;
+  logging::InitLogging(settings);
+  // To view log output with IDs and timestamps use "adb logcat -v threadtime".
+  logging::SetLogItems(true,   // Process ID
+                       true,   // Thread ID
+                       true,   // Timestamp
+                       true);  // Tick count
+}
+
+void WaitForDebuggerIfNecessary() {
+  const base::CommandLine* command_line =
+      base::CommandLine::ForCurrentProcess();
+  if (command_line->HasSwitch(::switches::kWaitForDebugger)) {
+    std::vector<std::string> apps_to_debug = base::SplitString(
+        command_line->GetSwitchValueASCII(::switches::kWaitForDebugger), ",",
+        base::TRIM_WHITESPACE, base::SPLIT_WANT_ALL);
+    std::string app = "launcher";
+    base::FilePath exe_path =
+        command_line->GetProgram().BaseName().RemoveExtension();
+    for (const auto& app_name : apps_to_debug) {
+      if (base::FilePath().AppendASCII(app_name) == exe_path) {
+        app = app_name;
+        break;
+      }
+    }
+    if (apps_to_debug.empty() || base::ContainsValue(apps_to_debug, app)) {
+#if defined(OS_WIN)
+      base::string16 appw = base::UTF8ToUTF16(app);
+      base::string16 message = base::UTF8ToUTF16(
+          base::StringPrintf("%s - %ld", app.c_str(), GetCurrentProcessId()));
+      MessageBox(NULL, message.c_str(), appw.c_str(), MB_OK | MB_SETFOREGROUND);
+#else
+      LOG(ERROR) << app << " waiting for GDB. pid: " << getpid();
+      base::debug::WaitForDebugger(60, true);
+#endif
+    }
+  }
+}
+
+NO_SANITIZE("cfi-icall")
+void CallLibraryEarlyInitialization(base::NativeLibrary app_library) {
+  // Do whatever warming that the service wants.
+
+#if ICU_UTIL_DATA_IMPL == ICU_UTIL_DATA_FILE
+  typedef void (*LibraryEarlyInitFunction)(const uint8_t*);
+  LibraryEarlyInitFunction init_function =
+      reinterpret_cast<LibraryEarlyInitFunction>(
+          base::GetFunctionPointerFromNativeLibrary(app_library,
+                                                    "InitializeBase"));
+  CHECK(init_function);
+  // Get the ICU data that we prewarmed in the runner and then pass it to
+  // the copy of icu in the mojo binary that we're running.
+  const uint8_t* icu_data = base::i18n::GetRawIcuMemory();
+  init_function(icu_data);
+#endif  // ICU_UTIL_DATA_IMPL == ICU_UTIL_DATA_FILE
+
+  // TODO(erg): All chromium binaries load base. We might want to make a
+  // general system for other people.
+}
+
+}  // namespace service_manager
diff -BbuN a/services/service_manager/runner/init.h b/services/service_manager/runner/init.h
--- a/services/service_manager/runner/init.h	1970-01-01 03:00:00.000000000 +0300
+++ b/services/service_manager/runner/init.h	2019-05-17 18:53:37.984000000 +0300
@@ -0,0 +1,23 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef SERVICES_SERVICE_MANAGER_RUNNER_INIT_H_
+#define SERVICES_SERVICE_MANAGER_RUNNER_INIT_H_
+
+#include "base/native_library.h"
+
+namespace service_manager {
+
+// Initialization routines shared by desktop and Android main functions.
+void InitializeLogging();
+
+void WaitForDebuggerIfNecessary();
+
+// Calls "LibraryEarlyInitialization" in |app_library| if it exists. We do
+// common initialization there now.
+void CallLibraryEarlyInitialization(base::NativeLibrary app_library);
+
+}  // namespace service_manager
+
+#endif  // SERVICES_SERVICE_MANAGER_RUNNER_INIT_H_
--- a/services/service_manager/service_manifests.md	1970-01-01 03:00:00.000000000 +0300
+++ b/services/service_manager/service_manifests.md	2019-05-17 18:53:37.992000000 +0300
@@ -0,0 +1,315 @@
+# Service Manifests
+
+[TOC]
+
+## Overview
+
+Manifest files are used to configure security properties and
+permissions for services, such as listing allowed sets of interfaces or
+specifying a sandbox type. The files use JSON format and are usually
+placed in the same directory as the service source files, but the path
+is configurable in the BUILD.gn file for the service
+(see [README.md](README.md#build-targets) for an example).
+
+## Terminology
+
+The Service Manager is responsible for starting new service instances on-demand,
+and a given service may have any number of concurrently running instances.
+The Service Manager disambiguates service instances by their unique identity.
+A service's **identity** is represented by the 4-tuple of its service name,
+instance group, instance ID, and a globally unique ID:
+
+### Service name
+
+A free-form -- typically short -- string identifying the the specific service
+being run in the instance.
+
+### Instance Group
+
+Service instances started by the Service Manager are organized into
+*instance groups*. Typically a service instance can only connect to other
+service instances in its own group. Exceptions are made for targeted services
+which are designed to be accessible cross-group (such as singleton services), as
+well as for connecting services which are sufficiently privileged to connect to
+any service instance in the system.
+
+Instance group is represented by a `base::Token` in `service_manager::Identity`.
+When instance group is omitted from an Identity passed with an interface request
+to the Service Manager, the Service Manager assumes that the request should be
+routed to a service instance in the requestor's same instance group.
+
+In Chrome, every `BrowserContext` has a randomly generated instance group ID
+associated with it, and this is used to isolate the service instances which run
+on behalf of specific profiles, including renderers.
+
+### Instance ID
+
+Another `base::Token` in `service_manager::Identity`, used to disambiguate
+multiple instances of a service for the same user. Every instance has an
+instance ID, but it typically takes on the default value of a zero-token.
+
+### Globally Unique ID
+
+Every service instance started by the Service Manager is assigned a randomly
+generated `base::Token` value designated as the instance's
+**globally unique ID**. This value is always unique to a single instance across
+time and space.
+
+### Connections
+
+Every service instance has a Connector API it can use to issue requests to the
+Service Manager. One such request is `BindInterface`, which allows the service
+to bind an interface within another service instance.
+
+When binding an interface, the **source identity** refers to the service
+initiating the bind request, and the **target identity** refers to the
+destination service instance. Based on both the source and target identities,
+the Service Manager may choose to start a new service instance, reuse an
+existing instance as the destination for the bind request or deny the request.
+
+### Interface provider
+
+InterfaceProvider is a Mojo
+[interface](https://cs.chromium.org/chromium/bservices/service_manager/public/mojom/interface_provider.mojom)
+for providing an implementation of an interface by name. It is implemented by
+different hosts (for frames and workers) in the browser, and the manifest
+allows to specify different sets of capabilities exposed by these hosts.
+
+## File structure
+
+### name (string)
+
+A unique identifier that is used to refer to the service.
+
+### display\_name (string)
+
+A human-readable name which can have any descriptive value. Not user-visible.
+
+### sandbox\_type (string)
+
+An optional field that provides access to several types of sandboxes.
+Inside a sandbox, by default the service is essentially restricted to CPU and
+memory access only. Common values are:
+
+* `utility` (default) -  also allows full access to one configurable directory;
+* `none` - no sandboxing is applied;
+* `none_and_elevated` - under Windows, no sandboxing is applied and privileges
+are elevated.
+
+If the service cannot run with a sandbox type of utility, elevated, or none,
+please reach out to the security team.
+
+### options (dictionary)
+
+This field can be used to specify values for any of the following options:
+
+#### instance\_sharing (string)
+
+Determines which parameters result in the creation of a new service
+instance on an incoming service start/interface bind request.
+
+Possible values:
+
+##### none (default)
+
+When one service is connecting to another, checks are performed to either find
+an existing instance that matches the target identity or create a new one if
+no match is found.
+
+By default, all four identity components (service name, instance group, instance
+ID, and globally unique ID) are used to find a match.
+
+See
+[advice](https://chromium.googlesource.com/chromium/b+/master/docs/servicification.md#is-your-service-global-or-per_browsercontext)
+on using this option.
+
+Example:
+[identity](https://cs.chromium.org/chromium/bservices/identity/manifest.json)
+
+##### shared\_across\_instance\_groups
+
+In this case, the instance group parameter is ignored when looking for a
+matching target instance, so an existing instance can be reused regardless of
+which instance group the connecting service belongs to.
+
+Example:
+[data_decoder](https://cs.chromium.org/chromium/bservices/data_decoder/manifest.json)
+
+##### singleton
+
+In this case, both instance group and instance ID parameters are ignored when
+an interface request is targeting the service. Only one service instance is
+created, and all interface requests targeting the service will be routed to that
+instance.
+
+Example:
+[download_manager](https://cs.chromium.org/chromium/bchrome/browser/android/download/manifest.json)
+
+#### can\_connect\_to\_instances\_in\_any\_group (bool)
+
+This option allows a service to make outgoing requests with a target instance
+group other than its own.
+
+**Note:** this privilege must only be granted to services that are trusted
+at the same level as the browser process itself.
+
+Example:
+[content_browser](https://cs.chromium.org/chromium/bcontent/public/app/mojo/content_browser_manifest.json)
+
+The browser process manages all `BrowserContexts`, so it needs this privilege
+to act on behalf of different users.
+
+#### can\_connect\_to\_other\_services\_with\_any\_instance\_name (bool)
+
+This option allows a service to specify an instance ID that is
+different from the service name when connecting.
+
+**Note:** this privilege must only be granted to services that are trusted
+at the same level as the browser process itself.
+
+Example:
+[chrome_browser](https://cs.chromium.org/chromium/bchrome/app/chrome_manifest.json)
+
+Code in chrome_browser calls an XML parsing library function, which generates a
+random instance ID to
+[isolate unrelated decode operations](https://cs.chromium.org/chromium/bservices/data_decoder/public/cpp/safe_xml_parser.cc?l=50).
+
+#### can\_create\_other\_service\_instances (bool)
+
+This option allows a service to register arbitrary new service instances it
+creates on its own.
+
+**Note:** this privilege must only be granted to services that are trusted
+at least at the same level as the Service Manager itself.
+
+Example:
+[content_browser](https://cs.chromium.org/chromium/bcontent/public/app/mojo/content_browser_manifest.json)
+
+The browser manages render processes, and thus needs this privilege to manage
+the content_renderer instances on behalf of the service manager.
+
+### interface\_provider\_specs (dictionary)
+
+The interface provider spec is a dictionary keyed by interface provider
+name, with each value representing the capability spec for that
+provider.
+Each capability spec defines an optional "provides" key and an optional
+"requires" key.
+
+Every interface provider spec (often exclusively) contains one standard
+capability spec named “service_manager:connector”. This is the
+capability spec enforced when inter-service connections are made from a
+service's `Connector` interface.
+
+Some other examples of capability specs are things like "navigation:frame",
+which enforces capability specs for interfaces retrieved through a
+frame's `InterfaceProvider`.
+
+See [README.md](README.md#service-manifests) for some examples.
+
+**Note:** Since multiple interface provider support makes the manifest files
+harder to understand, there is a plan to simplify this section
+(see https://crbug.com/718652 for more details).
+
+#### provides (dictionary)
+
+This optional section specifies a set of capabilities provided by the service.
+A capability is a set of accessible interfaces.
+
+For example, suppose we have the following capabilities:
+
+* useful_capability
+  * useful\_interface\_1
+  * useful\_interface\_2
+* better\_capability
+  * better\_interface
+
+The `provides` section would be:
+``` json
+  "provides": {
+    "useful_capability": [
+      "useful_interface_1",
+      "useful_interface_2" ],
+    "better_capability": [
+      "better_interface" ],
+  }
+```
+
+#### requires (dictionary)
+
+This optional section is also a dictionary, keyed by remote service
+names (the service name must match the "name" value in the remote service's
+manifest). Each value is a list of capabilities required by this service
+from the listed remote service. This section does not name interfaces,
+only capabilities.
+
+For example, if our capability requires service "some_capability" from
+service "another_service", the "requires" section will look like this:
+
+``` json
+"requires": {
+  "another_service": [ "some_capability" ]
+```
+
+An asterisk is a wildcard which means that any listed capabilities are
+required of any service that provides them. For example:
+
+``` json
+"requires": {
+  "*": [ "some_capability" ]
+```
+
+In the above example, this service can access any interface provided as part
+of a capability named "some_capability" in any service on the system.
+
+While generally discouraged, there are use cases for wildcards.
+Consider building something like a UI shell with a launcher that wants to
+tell any service "please launch with some default UI". The services providing
+a "launch" capability would be expected to include access to an
+"`app_launcher.mojom.Launcher`" interface as part of that capability, with an
+implementation that does something useful like open some default UI for the
+service:
+
+``` json
+"provides": {
+  "launch": [ "app_launcher.mojom.Launcher" ]
+}
+```
+
+Then our app launcher service would expect to be able to bind
+`app_launcher.mojom.Launcher` in any service that provides that capability:
+
+
+``` json
+"requires": {
+   "*" : [ "launch" ]
+}
+```
+
+### required\_files (dictionary)
+
+Allows the (sandboxed) service to specify a list of platform-specific files it
+needs to access from disk while running. Each file is keyed by an arbitrary
+name chosen by the service, and references a file path relative to the Service
+Manager embedder (e.g. the Chrome binary) at runtime.
+
+Files specified here will be opened by the Service Manager before launching a
+new instance of this service, and their opened file descriptors will be passed
+to the new sandboxed process. The file descriptors may be accessed via
+`base::FileDescriptorStore` using the corresponding key string from the
+manifest.
+
+**Note:** This is currently only supported on Android and Linux-based desktop
+builds.
+
+#### path (string)
+
+Path to the file relative to the executable location at runtime.
+
+#### platform (string)
+
+The platform this file is required on.
+Possible values:
+
+* `linux`
+* `android`
diff -BbuN a/services/service_manager/standalone/BUILD.gn b/services/service_manager/standalone/BUILD.gn
--- a/services/service_manager/standalone/BUILD.gn	1970-01-01 03:00:00.000000000 +0300
+++ b/services/service_manager/standalone/BUILD.gn	2019-05-17 18:53:37.992000000 +0300
@@ -0,0 +1,25 @@
+# Copyright 2014 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+import("//mojo/public/tools/bindings/mojom.gni")
+import("//testing/test.gni")
+
+source_set("standalone") {
+  sources = [
+    "context.cc",
+    "context.h",
+  ]
+
+  deps = [
+    "//base",
+    "//base/third_party/dynamic_annotations",
+    "//mojo/public/cpp/system",
+    "//services/catalog:lib",
+    "//services/service_manager",
+    "//services/service_manager/public/cpp",
+    "//services/service_manager/runner/common",
+    "//services/service_manager/runner/host:lib",
+    "//url",
+  ]
+}
diff -BbuN a/services/service_manager/standalone/context.cc b/services/service_manager/standalone/context.cc
--- a/services/service_manager/standalone/context.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/services/service_manager/standalone/context.cc	2019-05-17 18:53:37.992000000 +0300
@@ -0,0 +1,110 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "services/service_manager/standalone/context.h"
+
+#include <stddef.h>
+#include <stdint.h>
+
+#include <utility>
+#include <vector>
+
+#include "base/bind.h"
+#include "base/command_line.h"
+#include "base/files/file_path.h"
+#include "base/json/json_file_value_serializer.h"
+#include "base/macros.h"
+#include "base/path_service.h"
+#include "base/process/process_info.h"
+#include "base/run_loop.h"
+#include "base/strings/string_number_conversions.h"
+#include "base/strings/string_split.h"
+#include "base/strings/string_util.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/trace_event/trace_event.h"
+#include "build/build_config.h"
+#include "services/catalog/catalog.h"
+#include "services/service_manager/connect_params.h"
+#include "services/service_manager/public/cpp/constants.h"
+#include "services/service_manager/public/cpp/service_filter.h"
+#include "services/service_manager/runner/common/switches.h"
+#include "services/service_manager/runner/host/service_process_launcher_factory.h"
+#include "services/service_manager/service_manager.h"
+#include "services/service_manager/switches.h"
+
+#if !defined(OS_IOS)
+#include "services/service_manager/runner/host/service_process_launcher.h"
+#endif
+
+namespace service_manager {
+namespace {
+
+#if !defined(OS_IOS)
+// Used to ensure we only init once.
+class ServiceProcessLauncherFactoryImpl : public ServiceProcessLauncherFactory {
+ public:
+  ServiceProcessLauncherFactoryImpl(ServiceProcessLauncherDelegate* delegate)
+      : delegate_(delegate) {}
+
+ private:
+   std::unique_ptr<ServiceProcessLauncher> Create(
+      const base::FilePath& service_path) override {
+     return std::make_unique<ServiceProcessLauncher>(delegate_, service_path);
+  }
+
+  ServiceProcessLauncherDelegate* delegate_;
+};
+#endif  // !defined(OS_IOS)
+
+void OnInstanceQuit(const std::string& name,
+                    base::RepeatingClosure on_quit,
+                    const Identity& identity) {
+  if (name == identity.name())
+    on_quit.Run();
+}
+
+const char kService[] = "service";
+
+}  // namespace
+
+Context::Context(
+    ServiceProcessLauncherDelegate* service_process_launcher_delegate,
+    const std::vector<Manifest>& manifests) {
+  TRACE_EVENT0("service_manager", "Context::Context");
+
+  std::unique_ptr<ServiceProcessLauncherFactory>
+      service_process_launcher_factory;
+
+// iOS does not support launching services in their own processes (and does
+// not build ServiceProcessLauncher).
+#if !defined(OS_IOS)
+  service_process_launcher_factory =
+      std::make_unique<ServiceProcessLauncherFactoryImpl>(
+          service_process_launcher_delegate);
+#endif
+  service_manager_ = std::make_unique<ServiceManager>(
+      std::move(service_process_launcher_factory), manifests);
+}
+
+Context::~Context() = default;
+
+void Context::RunCommandLineApplication(base::RepeatingClosure on_quit) {
+  base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();
+  if (command_line->HasSwitch(kService))
+    Run(command_line->GetSwitchValueASCII(kService), std::move(on_quit));
+  else
+    std::move(on_quit).Run();
+}
+
+void Context::Run(const std::string& name, base::RepeatingClosure on_quit) {
+  service_manager_->SetInstanceQuitCallback(
+      base::BindRepeating(&OnInstanceQuit, name, std::move(on_quit)));
+
+  auto params = std::make_unique<ConnectParams>();
+  params->set_source(GetServiceManagerInstanceIdentity());
+  params->set_target(ServiceFilter::ByNameInGroup(name, kSystemInstanceGroup));
+  service_manager_->Connect(std::move(params));
+}
+
+}  // namespace service_manager
diff -BbuN a/services/service_manager/standalone/context.h b/services/service_manager/standalone/context.h
--- a/services/service_manager/standalone/context.h	1970-01-01 03:00:00.000000000 +0300
+++ b/services/service_manager/standalone/context.h	2019-05-17 18:53:37.992000000 +0300
@@ -0,0 +1,46 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef SERVICES_SERVICE_MANAGER_STANDALONE_CONTEXT_H_
+#define SERVICES_SERVICE_MANAGER_STANDALONE_CONTEXT_H_
+
+#include <memory>
+#include <vector>
+
+#include "base/callback.h"
+#include "base/macros.h"
+#include "base/time/time.h"
+#include "services/service_manager/public/cpp/manifest.h"
+#include "services/service_manager/runner/host/service_process_launcher_delegate.h"
+
+namespace service_manager {
+
+class ServiceManager;
+
+// The "global" context for the service manager's main process.
+class Context {
+ public:
+  Context(ServiceProcessLauncherDelegate* launcher_delegate,
+          const std::vector<Manifest>& manifests);
+  ~Context();
+
+  // Run the application specified on the command line, and run |on_quit| when
+  // the application instance quits.
+  void RunCommandLineApplication(base::RepeatingClosure on_quit);
+
+  ServiceManager* service_manager() { return service_manager_.get(); }
+
+ private:
+  // Runs the app specified by |name|.
+  void Run(const std::string& name, base::RepeatingClosure on_quit);
+
+  std::unique_ptr<ServiceManager> service_manager_;
+  base::Time main_entry_time_;
+
+  DISALLOW_COPY_AND_ASSIGN(Context);
+};
+
+}  // namespace service_manager
+
+#endif  // SERVICES_SERVICE_MANAGER_STANDALONE_CONTEXT_H_
diff -BbuN a/services/service_manager/standalone/DEPS b/services/service_manager/standalone/DEPS
--- a/services/service_manager/standalone/DEPS	1970-01-01 03:00:00.000000000 +0300
+++ b/services/service_manager/standalone/DEPS	2019-05-17 18:53:37.992000000 +0300
@@ -0,0 +1,3 @@
+include_rules = [
+  "+services/catalog",
+]
--- a/services/service_manager/tests/test.mojom	1970-01-01 03:00:00.000000000 +0300
+++ b/services/service_manager/tests/test.mojom	2019-05-17 18:53:37.996000000 +0300
@@ -0,0 +1,23 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+module service_manager;
+
+interface TestService {
+  Test(string test_string) => ();
+};
+
+interface TestA {
+  CallB();
+  CallCFromB();
+};
+
+interface TestB {
+  B() => ();
+  CallC() => ();
+};
+
+interface TestC {
+  C() => ();
+};
--- a/services/shape_detection/manifest.json	1970-01-01 03:00:00.000000000 +0300
+++ b/services/shape_detection/manifest.json	2019-05-17 18:53:38.004000000 +0300
@@ -0,0 +1,16 @@
+{
+  "name": "shape_detection",
+  "display_name": "Shape Detection Service",
+  "options" : {
+    "instance_sharing" : "shared_instance_across_users"
+  },
+  "interface_provider_specs": {
+    "service_manager:connector": {
+      "provides": {
+        "face_detection": [ "shape_detection.mojom.FaceDetectionProvider" ],
+        "barcode_detection": [ "shape_detection.mojom.BarcodeDetectionProvider" ],
+        "text_detection": [ "shape_detection.mojom.TextDetection" ]
+      }
+    }
+  }
+}
--- a/services/test/echo/manifest.json	1970-01-01 03:00:00.000000000 +0300
+++ b/services/test/echo/manifest.json	2019-05-17 18:53:38.008000000 +0300
@@ -0,0 +1,14 @@
+{
+  "name": "echo",
+  "display_name": "Echo Service",
+  "options" : {
+    "instance_sharing" : "shared_instance_across_users"
+  },
+  "interface_provider_specs": {
+    "service_manager:connector": {
+      "provides": {
+        "echo" : [ "echo.mojom.Echo" ]
+      }
+    }
+  }
+}
--- a/services/test/user_id/manifest.json	1970-01-01 03:00:00.000000000 +0300
+++ b/services/test/user_id/manifest.json	2019-05-17 18:53:38.008000000 +0300
@@ -0,0 +1,11 @@
+{
+  "name": "user_id",
+  "display_name": "User ID Service",
+  "interface_provider_specs": {
+    "service_manager:connector": {
+      "provides": {
+        "user_id" : [ "user_id.mojom.UserId" ]
+      }
+    }
+  }
+}
--- a/services/video_capture/public/cpp/device_to_feedback_observer_adapter.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/services/video_capture/public/cpp/device_to_feedback_observer_adapter.cc	2019-05-17 18:53:38.020000000 +0300
@@ -0,0 +1,20 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "services/video_capture/public/cpp/device_to_feedback_observer_adapter.h"
+
+namespace video_capture {
+
+DeviceToFeedbackObserverAdapter::DeviceToFeedbackObserverAdapter(
+    mojom::DevicePtr device)
+    : device_(std::move(device)) {}
+
+DeviceToFeedbackObserverAdapter::~DeviceToFeedbackObserverAdapter() = default;
+
+void DeviceToFeedbackObserverAdapter::OnUtilizationReport(int frame_feedback_id,
+                                                          double utilization) {
+  device_->OnReceiverReportingUtilization(frame_feedback_id, utilization);
+}
+
+}  // namespace video_capture
--- a/services/video_capture/public/cpp/device_to_feedback_observer_adapter.h	1970-01-01 03:00:00.000000000 +0300
+++ b/services/video_capture/public/cpp/device_to_feedback_observer_adapter.h	2019-05-17 18:53:38.020000000 +0300
@@ -0,0 +1,30 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef SERVICES_VIDEO_CAPTURE_PUBLIC_CPP_DEVICE_TO_FEEDBACK_OBSERVER_ADAPTER_H_
+#define SERVICES_VIDEO_CAPTURE_PUBLIC_CPP_DEVICE_TO_FEEDBACK_OBSERVER_ADAPTER_H_
+
+#include "media/capture/video/video_capture_device.h"
+#include "services/video_capture/public/mojom/device.mojom.h"
+
+namespace video_capture {
+
+// Adapter that allows a video_capture::mojom::Device to be used in place of
+// a media::VideoFrameConsumerFeedbackObserver
+class DeviceToFeedbackObserverAdapter
+    : public media::VideoFrameConsumerFeedbackObserver {
+ public:
+  DeviceToFeedbackObserverAdapter(mojom::DevicePtr device);
+  ~DeviceToFeedbackObserverAdapter() override;
+
+  // media::VideoFrameConsumerFeedbackObserver:
+  void OnUtilizationReport(int frame_feedback_id, double utilization) override;
+
+ private:
+  mojom::DevicePtr device_;
+};
+
+}  // namespace video_capture
+
+#endif  // SERVICES_VIDEO_CAPTURE_PUBLIC_CPP_DEVICE_TO_FEEDBACK_OBSERVER_ADAPTER_H_
--- a/services/video_capture/service_manifest.json	1970-01-01 03:00:00.000000000 +0300
+++ b/services/video_capture/service_manifest.json	2019-05-17 18:53:38.024000000 +0300
@@ -0,0 +1,19 @@
+{
+  "name": "video_capture",
+  "display_name": "Video Capture",
+  "sandbox_type": "none",
+  "options" : {
+    "instance_sharing" : "shared_instance_across_users"
+  },
+  "interface_provider_specs": {
+    "service_manager:connector": {
+      "provides" : {
+        "capture" : ["video_capture.mojom.DeviceFactoryProvider"],
+        "tests" : [
+          "video_capture.mojom.DeviceFactoryProvider",
+          "video_capture.mojom.TestingControls"
+        ]
+      }
+    }
+  }
+}
--- a/services/video_capture/test/OWNERS	1970-01-01 03:00:00.000000000 +0300
+++ b/services/video_capture/test/OWNERS	2019-05-17 18:53:38.024000000 +0300
@@ -0,0 +1,2 @@
+per-file service_unittest_manifest.json=set noparent
+per-file service_unittest_manifest.json=file://ipc/SECURITY_OWNERS
--- a/services/video_capture/test/service_unittest_manifest.json	1970-01-01 03:00:00.000000000 +0300
+++ b/services/video_capture/test/service_unittest_manifest.json	2019-05-17 18:53:38.024000000 +0300
@@ -0,0 +1,12 @@
+{
+  "name": "video_capture_unittests",
+  "display_name": "Video Capture Unittests",
+  "interface_provider_specs": {
+    "service_manager:connector": {
+      "requires": {
+        "video_capture": [ "tests" ],
+        "service_manager": [ "service_manager:service_manager" ]
+      }
+    }
+  }
+}
--- a/services/viz/manifest.json	1970-01-01 03:00:00.000000000 +0300
+++ b/services/viz/manifest.json	2019-05-17 18:53:38.028000000 +0300
@@ -0,0 +1,29 @@
+{
+  "name": "viz",
+  // The viz service sometimes needs to do some additional work before entering
+  // the sandbox. So set sandbox_type to 'none', so that the service manager
+  // does not enter the sandbox. The viz service itself enters the sandbox at
+  // the right time. See code in GpuSandboxHelper for more details.
+  // TODO(crbug.com/708738): Revisit the implementation once sandboxing is
+  // fixed.
+  "sandbox_type": "none",
+  "display_name": "Visuals Service",
+  "options" : {
+    "instance_sharing" : "shared_instance_across_users"
+  },
+  "interface_provider_specs": {
+    "service_manager:connector": {
+      "provides": {
+        "viz_host": [
+          "viz.mojom.VizMain"
+        ]
+      },
+      "requires": {
+        "*": [ "app" ],
+        "catalog": [ "directory" ],
+        "ui": [ "ozone" ],
+        "metrics": [ "url_keyed_metrics" ]
+      }
+    }
+  }
+}
--- a/services/ws/gpu_host/arc_client.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/services/ws/gpu_host/arc_client.cc	2019-05-17 18:53:38.044000000 +0300
@@ -0,0 +1,38 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "services/ws/gpu_host/arc_client.h"
+
+#include "services/viz/privileged/interfaces/gl/gpu_service.mojom.h"
+
+namespace ws {
+namespace gpu_host {
+
+ArcClient::ArcClient(viz::mojom::GpuService* gpu_service)
+    : gpu_service_(gpu_service) {}
+
+ArcClient::~ArcClient() {}
+
+void ArcClient::CreateVideoDecodeAccelerator(
+    arc::mojom::VideoDecodeAcceleratorRequest vda_request) {
+  gpu_service_->CreateArcVideoDecodeAccelerator(std::move(vda_request));
+}
+
+void ArcClient::CreateVideoEncodeAccelerator(
+    arc::mojom::VideoEncodeAcceleratorRequest vea_request) {
+  gpu_service_->CreateArcVideoEncodeAccelerator(std::move(vea_request));
+}
+
+void ArcClient::CreateVideoProtectedBufferAllocator(
+    arc::mojom::VideoProtectedBufferAllocatorRequest pba_request) {
+  gpu_service_->CreateArcVideoProtectedBufferAllocator(std::move(pba_request));
+}
+
+void ArcClient::CreateProtectedBufferManager(
+    arc::mojom::ProtectedBufferManagerRequest pbm_request) {
+  gpu_service_->CreateArcProtectedBufferManager(std::move(pbm_request));
+}
+
+}  // namespace gpu_host
+}  // namespace ws
--- a/services/ws/gpu_host/arc_client.h	1970-01-01 03:00:00.000000000 +0300
+++ b/services/ws/gpu_host/arc_client.h	2019-05-17 18:53:38.044000000 +0300
@@ -0,0 +1,49 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef SERVICES_WS_GPU_HOST_ARC_CLIENT_H_
+#define SERVICES_WS_GPU_HOST_ARC_CLIENT_H_
+
+#include "services/ws/public/mojom/arc.mojom.h"
+
+namespace viz {
+namespace mojom {
+class GpuService;
+}  // namespace mojom
+}  // namespace viz
+
+namespace ws {
+namespace gpu_host {
+
+// The implementation that relays requests from clients to the real
+// service implementation in the GPU process over mojom.GpuService.
+class ArcClient : public mojom::Arc {
+ public:
+  explicit ArcClient(viz::mojom::GpuService* gpu_service);
+  ~ArcClient() override;
+
+ private:
+  // mojom::Arc overrides:
+  void CreateVideoDecodeAccelerator(
+      arc::mojom::VideoDecodeAcceleratorRequest vda_request) override;
+
+  void CreateVideoEncodeAccelerator(
+      arc::mojom::VideoEncodeAcceleratorRequest vea_request) override;
+
+  void CreateVideoProtectedBufferAllocator(
+      arc::mojom::VideoProtectedBufferAllocatorRequest pba_request) override;
+
+  void CreateProtectedBufferManager(
+      arc::mojom::ProtectedBufferManagerRequest pbm_request) override;
+
+  // The objects these pointers refer to are owned by the GpuHost object.
+  viz::mojom::GpuService* gpu_service_;
+
+  DISALLOW_COPY_AND_ASSIGN(ArcClient);
+};
+
+}  // namespace gpu_host
+}  // namespace ws
+
+#endif  // SERVICES_WS_GPU_HOST_ARC_CLIENT_H_
--- a/services/ws/ime/OWNERS	1970-01-01 03:00:00.000000000 +0300
+++ b/services/ws/ime/OWNERS	2019-05-17 18:53:38.044000000 +0300
@@ -0,0 +1,2 @@
+per-file test_manifest.json=set noparent
+per-file test_manifest.json=file://ipc/SECURITY_OWNERS
--- a/services/ws/ime/test_ime_driver/manifest.json	1970-01-01 03:00:00.000000000 +0300
+++ b/services/ws/ime/test_ime_driver/manifest.json	2019-05-17 18:53:38.044000000 +0300
@@ -0,0 +1,12 @@
+{
+  "name": "test_ime_driver",
+  "display_name": "Test IME Driver",
+  "interface_provider_specs": {
+    "service_manager:connector": {
+      "provides": { "ime:test_ime_driver": [] },
+      "requires": {
+        "ui": [ "ime_registrar" ]
+      }
+    }
+  }
+}
--- a/services/ws/ime/test_manifest.json	1970-01-01 03:00:00.000000000 +0300
+++ b/services/ws/ime/test_manifest.json	2019-05-17 18:53:38.044000000 +0300
@@ -0,0 +1,12 @@
+{
+  "name": "ime_unittests",
+  "display_name": "IME Service Unittests",
+  "interface_provider_specs": {
+    "service_manager:connector": {
+      "requires": {
+        "ui": [ "app" ],
+        "test_ime_driver": [ ]
+      }
+    }
+  }
+}
--- a/services/ws/manifest.json	1970-01-01 03:00:00.000000000 +0300
+++ b/services/ws/manifest.json	2019-05-17 18:53:38.044000000 +0300
@@ -0,0 +1,70 @@
+{
+  "name": "ui",
+  "sandbox_type": "none",
+  "display_name": "UI Service",
+  "options" : {
+    "instance_sharing" : "singleton"
+  },
+  "interface_provider_specs": {
+    "service_manager:connector": {
+      "provides": {
+        // A collection of interfaces needed by a generic client of mus.
+        // Additional interfaces may be requested a-la-carte.
+        // NOTE: when adding a new interface chances are you will want to add it
+        // to window_manager as well.
+        "app": [
+          "discardable_memory.mojom.DiscardableSharedMemoryManager",
+          "ui.mojom.ClipboardHost",
+          "ws.mojom.Gpu",
+          "ws.mojom.IMEDriver",
+          "ws.mojom.InputDeviceServer",
+          "ws.mojom.WindowTreeFactory"
+        ],
+        "arc_manager" : [
+          "ws.mojom.Arc"
+        ],
+        // Interfaces provided by mus-gpu for mus-ws.
+        "ozone": [
+          "ui.ozone.mojom.DeviceCursor",
+          "ui.ozone.mojom.DrmDevice"
+        ],
+        "test": [
+          "ws.mojom.EventInjector",
+          "ws.mojom.WindowServerTest"
+        ],
+        "discardable_memory": [
+          "discardable_memory.mojom.DiscardableSharedMemoryManager"
+        ],
+        "gpu_client": [
+          "ws.mojom.Gpu"
+        ],
+        "ime_registrar": [
+          "ws.mojom.IMERegistrar"
+        ],
+        "input_device_controller": [
+          "ws.mojom.InputDeviceController"
+        ],
+        "privileged": [
+          // Injecting events is security-sensitive.
+          "ws.mojom.EventInjector",
+          "ws.mojom.RemotingEventInjector"
+        ],
+        "window_manager": [
+          "discardable_memory.mojom.DiscardableSharedMemoryManager",
+          "ws.mojom.EventInjector",
+          "ws.mojom.Gpu",
+          "ws.mojom.IMEDriver",
+          "ws.mojom.InputDeviceController",
+          "ws.mojom.InputDeviceServer",
+          "ws.mojom.UserActivityMonitor"
+        ]
+      },
+      "requires": {
+        "*": [ "app" ],
+        "catalog": [ "directory" ],
+        "ui": [ "ozone" ],
+        "viz": [ "viz_host" ]
+      }
+    }
+  }
+}
--- a/services/ws/public/mojom/arc.mojom	1970-01-01 03:00:00.000000000 +0300
+++ b/services/ws/public/mojom/arc.mojom	2019-05-17 18:53:38.052000000 +0300
@@ -0,0 +1,25 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+module ws.mojom;
+
+import "components/arc/common/protected_buffer_manager.mojom";
+import "components/arc/common/video_decode_accelerator.mojom";
+import "components/arc/common/video_encode_accelerator.mojom";
+import "components/arc/common/video_protected_buffer_allocator.mojom";
+
+interface Arc {
+  // Create a new VideoDecodeAccelerator and binds it to |vda|.
+  CreateVideoDecodeAccelerator(arc.mojom.VideoDecodeAccelerator& vda);
+
+  // Create a new VideoEncodeAccelerator and binds it to |vea|.
+  CreateVideoEncodeAccelerator(arc.mojom.VideoEncodeAccelerator& vea);
+
+  // Create a new VideoProtectedBufferAllocator and binds it to |pba|.
+  CreateVideoProtectedBufferAllocator(
+      arc.mojom.VideoProtectedBufferAllocator& pba);
+
+  // Create a new ProtectedBufferManager and binds it to |pbm|.
+  CreateProtectedBufferManager(arc.mojom.ProtectedBufferManager& pbm);
+};
--- a/services/ws/test_manifest.json	1970-01-01 03:00:00.000000000 +0300
+++ b/services/ws/test_manifest.json	2019-05-17 18:53:38.052000000 +0300
@@ -0,0 +1,18 @@
+{
+  "name": "ui_ws2_service_unittests",
+  "display_name": "Window Service Unittests",
+  "interface_provider_specs": {
+    "service_manager:connector": {
+      "provides": {
+        "ui:window_tree_client": [
+          "ws.mojom.WindowTreeClient"
+        ]
+      },
+      "requires": {
+        "*": [ "app" ],
+        "ui_ws2_service_unittests": [ "ui:window_tree_client" ],
+        "viz": [ "viz_host" ]
+      }
+    }
+  }
+}
--- a/services/ws/test_ws/manifest.json	1970-01-01 03:00:00.000000000 +0300
+++ b/services/ws/test_ws/manifest.json	2019-05-17 18:53:38.056000000 +0300
@@ -0,0 +1,17 @@
+{
+  "name": "test_ws",
+  "sandbox_type": "none",
+  "display_name": "Test Window Service",
+  "interface_provider_specs": {
+    "service_manager:connector": {
+      "provides": {
+        "service_manager:service_factory": [
+          "service_manager.mojom.ServiceFactory"
+        ],
+        "test": [
+          "test_ws.mojom.TestWs"
+        ]
+      }
+    }
+  }
+}
