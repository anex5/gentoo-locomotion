--- a/gpu/BUILD.gn	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/BUILD.gn	2019-05-17 18:53:32.932000000 +0300
@@ -159,6 +159,8 @@
     "command_buffer/service/error_state_mock.h",
     "command_buffer/service/gles2_cmd_decoder_mock.cc",
     "command_buffer/service/gles2_cmd_decoder_mock.h",
+    "command_buffer/service/raster_decoder_mock.cc",
+    "command_buffer/service/raster_decoder_mock.h",
     "ipc/raster_in_process_context.cc",
     "ipc/raster_in_process_context.h",
     "ipc/service/gpu_memory_buffer_factory_test_template.h",
@@ -292,7 +294,6 @@
     sources += [ "command_buffer/service/shared_image_backing_factory_ahardwarebuffer_unittest.cc" ]
   } else if (is_mac) {
     libs += [ "IOSurface.framework" ]
-    sources += [ "command_buffer/service/shared_image_backing_factory_iosurface_unittest.cc" ]
   } else if (is_win) {
     deps += [
       "//ui/platform_window",
@@ -389,7 +390,6 @@
     "command_buffer/service/memory_program_cache_unittest.cc",
     "command_buffer/service/mocks.cc",
     "command_buffer/service/mocks.h",
-    "command_buffer/service/multi_draw_manager_unittest.cc",
     "command_buffer/service/passthrough_program_cache_unittest.cc",
     "command_buffer/service/path_manager_unittest.cc",
     "command_buffer/service/program_cache_unittest.cc",
@@ -696,30 +696,6 @@
 
     deps = [
       ":gles2",
-      ":gpu",
-      "//base",
-      "//base/third_party/dynamic_annotations",
-      "//ui/gfx/geometry",
-      "//ui/gl",
-      "//ui/gl:test_support",
-    ]
-
-    libfuzzer_options = [ "max_len=16384" ]
-  }
-
-  fuzzer_test("gpu_raster_passthrough_fuzzer") {
-    sources = [
-      "command_buffer/tests/fuzzer_main.cc",
-    ]
-
-    defines = [
-      "GPU_FUZZER_USE_ANGLE",
-      "GPU_FUZZER_USE_RASTER_DECODER",
-      "GPU_FUZZER_USE_PASSTHROUGH_CMD_DECODER",
-    ]
-
-    deps = [
-      ":gles2",
       ":gpu",
       "//base",
       "//base/third_party/dynamic_annotations",
--- a/gpu/command_buffer/build_cmd_buffer_lib.py	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/build_cmd_buffer_lib.py	2019-05-17 18:53:32.940000000 +0300
@@ -7010,7 +7010,7 @@
           if capability_es3:
             continue
           if 'extension_flag' in capability:
-            f.write("  if (feature_info()->feature_flags().%s) {\n" %
+            f.write("  if (group_->feature_info()->feature_flags().%s) {\n" %
                      capability['extension_flag'])
             f.write("  ")
           f.write("  ExpectEnableDisable(GL_%s, %s);\n" %
@@ -7030,7 +7030,7 @@
 """)
       f.write("""
 void %sDecoderTestBase::SetupInitStateExpectations(bool es3_capable) {
-  auto* feature_info_ = feature_info();
+  auto* feature_info_ = group_->feature_info();
 """ % _prefix)
       # We need to sort the keys so the expectations match
       for state_name in sorted(_STATE_INFO.keys()):
@@ -7072,7 +7072,7 @@
             f.write(guarded_operation)
         elif 'no_init' not in state:
           if 'extension_flag' in state:
-            f.write("  if (feature_info()->feature_flags().%s) {\n" %
+            f.write("  if (group_->feature_info()->feature_flags().%s) {\n" %
                        state['extension_flag'])
             f.write("  ")
           args = []
--- a/gpu/command_buffer/build_gles2_cmd_buffer.py	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/build_gles2_cmd_buffer.py	2019-05-17 18:53:32.940000000 +0300
@@ -2526,60 +2526,6 @@
     'type': 'STRn',
     'expectation': False,
   },
-  'GetProgramInterfaceiv': {
-    'type': 'GETn',
-    'decoder_func': 'DoGetProgramInterfaceiv',
-    'result': ['SizedResult<GLint>'],
-    'unit_test': False,
-    'trace_level': 2,
-    'es31': True,
-  },
-  'GetProgramResourceiv': {
-    'type': 'Custom',
-    'data_transfer_methods': ['shm'],
-    'cmd_args':
-        'GLidProgram program, GLenum program_interface, GLuint index, '
-        'uint32_t props_bucket_id, GLint* params',
-    'result': ['SizedResult<GLint>'],
-    'unit_test': False,
-    'trace_level': 2,
-    'es31': True,
-  },
-  'GetProgramResourceIndex': {
-    'type': 'Custom',
-    'data_transfer_methods': ['shm'],
-    'cmd_args':
-        'GLidProgram program, GLenum program_interface, '
-        'uint32_t name_bucket_id, GLuint* index',
-    'result': ['GLuint'],
-    'error_return': 'GL_INVALID_INDEX',
-    'unit_test': False,
-    'trace_level': 2,
-    'es31': True,
-  },
-  'GetProgramResourceLocation': {
-    'type': 'Custom',
-    'data_transfer_methods': ['shm'],
-    'cmd_args':
-        'GLidProgram program, GLenum program_interface, '
-        'uint32_t name_bucket_id, GLint* location',
-    'result': ['GLint'],
-    'error_return': -1,
-    'unit_test': False,
-    'trace_level': 2,
-    'es31': True,
-  },
-  'GetProgramResourceName': {
-    'type': 'Custom',
-    'data_transfer_methods': ['shm'],
-    'cmd_args':
-        'GLidProgram program, GLenum program_interface, GLuint index, '
-        'uint32_t name_bucket_id, void* result',
-    'result': ['int32_t'],
-    'unit_test': False,
-    'trace_level': 2,
-    'es31': True,
-  },
   'GetRenderbufferParameteriv': {
     'type': 'GETn',
     'decoder_func': 'DoGetRenderbufferParameteriv',
@@ -3073,16 +3019,6 @@
     'pepper_name': 'RenderbufferStorageMultisampleEXT',
     'trace_level': 1,
   },
-  'RenderbufferStorageMultisampleAdvancedAMD': {
-    'cmd_comment':
-        '// GL_AMD_framebuffer_multisample_advanced\n',
-    'decoder_func': 'DoRenderbufferStorageMultisampleAdvancedAMD',
-    'gl_test_func': 'glRenderbufferStorageMultisampleAdvancedAMD',
-    'unit_test': False,
-    'extension': 'amd_framebuffer_multisample_advanced',
-    'extension_flag': 'amd_framebuffer_multisample_advanced',
-    'trace_level': 1,
-  },
   'RenderbufferStorageMultisampleEXT': {
     'cmd_comment':
         '// GL_EXT_multisampled_render_to_texture\n',
@@ -4303,11 +4239,6 @@
     'type': 'NoCommand',
     'extension': "CHROMIUM_shared_image",
     'trace_level': 2,
-  },
-  'CreateAndTexStorage2DSharedImageWithInternalFormatCHROMIUM': {
-    'type': 'NoCommand',
-    'extension': "CHROMIUM_shared_image",
-    'trace_level': 2,
   },
   'CreateAndTexStorage2DSharedImageINTERNAL': {
     'decoder_func': 'DoCreateAndTexStorage2DSharedImageINTERNAL',
--- a/gpu/command_buffer/client/client_discardable_manager_unittest.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/client/client_discardable_manager_unittest.cc	2019-05-17 18:53:32.944000000 +0300
@@ -16,7 +16,7 @@
   State GetLastState() override {
     NOTREACHED();
     return State();
-  }
+  };
   void Flush(int32_t put_offset) override { NOTREACHED(); }
   void OrderingBarrier(int32_t put_offset) override { NOTREACHED(); }
   State WaitForTokenInRange(int32_t start, int32_t end) override {
--- a/gpu/command_buffer/client/client_transfer_cache.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/client/client_transfer_cache.cc	2019-05-17 18:53:32.944000000 +0300
@@ -41,13 +41,8 @@
 
   base::AutoLock hold(lock_);
   auto handle = CreateDiscardableHandle(key);
-  if (!handle.IsValid()) {
-    // Release any data pointers. Keeping these alive longer can lead to issues
-    // with transfer buffer reallocation.
-    mapped_ptr_ = base::nullopt;
-    transfer_buffer_ptr_ = base::nullopt;
+  if (!handle.IsValid())
     return;
-  }
 
   if (mapped_ptr_) {
     DCHECK(!transfer_buffer_ptr_);
--- a/gpu/command_buffer/client/cmd_buffer_helper_test.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/client/cmd_buffer_helper_test.cc	2019-05-17 18:53:32.944000000 +0300
@@ -18,6 +18,7 @@
 #include "gpu/command_buffer/client/cmd_buffer_helper.h"
 #include "gpu/command_buffer/client/command_buffer_direct_locked.h"
 #include "gpu/command_buffer/service/mocks.h"
+#include "gpu/command_buffer/service/transfer_buffer_manager.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
 namespace gpu {
@@ -41,7 +42,9 @@
 class CommandBufferHelperTest : public testing::Test {
  protected:
   void SetUp() override {
-    command_buffer_.reset(new CommandBufferDirectLocked());
+    transfer_buffer_manager_ = std::make_unique<TransferBufferManager>(nullptr);
+    command_buffer_.reset(
+        new CommandBufferDirectLocked(transfer_buffer_manager_.get()));
     api_mock_.reset(new AsyncAPIMock(true, command_buffer_->service()));
     command_buffer_->set_handler(api_mock_.get());
 
@@ -196,6 +199,7 @@
     helper_->WaitForGetOffsetInRange(start, end);
   }
 
+  std::unique_ptr<TransferBufferManager> transfer_buffer_manager_;
   std::unique_ptr<CommandBufferDirectLocked> command_buffer_;
   std::unique_ptr<AsyncAPIMock> api_mock_;
   std::unique_ptr<CommandBufferHelper> helper_;
--- a/gpu/command_buffer/client/command_buffer_direct_locked.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/client/command_buffer_direct_locked.h	2019-05-17 18:53:32.944000000 +0300
@@ -13,7 +13,9 @@
 // until either it gets unlocked or the client waits for progress.
 class CommandBufferDirectLocked : public CommandBufferDirect {
  public:
-  CommandBufferDirectLocked() = default;
+  explicit CommandBufferDirectLocked(
+      TransferBufferManager* transfer_buffer_manager)
+      : CommandBufferDirect(transfer_buffer_manager) {}
   ~CommandBufferDirectLocked() override = default;
 
   // Overridden from CommandBufferDirect
--- a/gpu/command_buffer/client/fenced_allocator.h	2019-05-17 17:45:41.008000000 +0300
+++ b/gpu/command_buffer/client/fenced_allocator.h	2019-05-17 18:53:32.944000000 +0300
@@ -29,7 +29,7 @@
 // NOTE: Although this class is intended to be used in the command buffer
 // environment which is multi-process, this class isn't "thread safe", because
 // it isn't meant to be shared across modules. It is thread-compatible though
-// (see http://www.corp.9oo91e.qjz9zk/eng/doc/cpp_primer.html#thread_safety).
+// (see http://www.corp.google.com/eng/doc/cpp_primer.html#thread_safety).
 class GPU_EXPORT FencedAllocator {
  public:
   typedef uint32_t Offset;
--- a/gpu/command_buffer/client/fenced_allocator_test.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/client/fenced_allocator_test.cc	2019-05-17 18:53:32.944000000 +0300
@@ -17,6 +17,7 @@
 #include "gpu/command_buffer/client/fenced_allocator.h"
 #include "gpu/command_buffer/service/command_buffer_direct.h"
 #include "gpu/command_buffer/service/mocks.h"
+#include "gpu/command_buffer/service/transfer_buffer_manager.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
 namespace gpu {
@@ -36,7 +37,9 @@
   static const int kAllocAlignment = 16;
 
   void SetUp() override {
-    command_buffer_.reset(new CommandBufferDirect());
+    transfer_buffer_manager_ = std::make_unique<TransferBufferManager>(nullptr);
+    command_buffer_.reset(
+        new CommandBufferDirect(transfer_buffer_manager_.get()));
     api_mock_.reset(new AsyncAPIMock(true, command_buffer_->service()));
     command_buffer_->set_handler(api_mock_.get());
 
@@ -55,6 +58,7 @@
 
   int32_t GetToken() { return command_buffer_->GetLastState().token; }
 
+  std::unique_ptr<TransferBufferManager> transfer_buffer_manager_;
   std::unique_ptr<CommandBufferDirect> command_buffer_;
   std::unique_ptr<AsyncAPIMock> api_mock_;
   std::unique_ptr<CommandBufferHelper> helper_;
--- a/gpu/command_buffer/client/gles2_c_lib_autogen.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/client/gles2_c_lib_autogen.h	2019-05-17 18:53:32.948000000 +0300
@@ -1142,16 +1142,6 @@
   gles2::GetGLContext()->RenderbufferStorageMultisampleCHROMIUM(
       target, samples, internalformat, width, height);
 }
-void GL_APIENTRY
-GLES2RenderbufferStorageMultisampleAdvancedAMD(GLenum target,
-                                               GLsizei samples,
-                                               GLsizei storageSamples,
-                                               GLenum internalformat,
-                                               GLsizei width,
-                                               GLsizei height) {
-  gles2::GetGLContext()->RenderbufferStorageMultisampleAdvancedAMD(
-      target, samples, storageSamples, internalformat, width, height);
-}
 void GL_APIENTRY GLES2RenderbufferStorageMultisampleEXT(GLenum target,
                                                         GLsizei samples,
                                                         GLenum internalformat,
@@ -1272,46 +1262,6 @@
   gles2::GetGLContext()->DispatchCompute(num_groups_x, num_groups_y,
                                          num_groups_z);
 }
-void GL_APIENTRY GLES2GetProgramInterfaceiv(GLuint program,
-                                            GLenum program_interface,
-                                            GLenum pname,
-                                            GLint* params) {
-  gles2::GetGLContext()->GetProgramInterfaceiv(program, program_interface,
-                                               pname, params);
-}
-GLuint GL_APIENTRY GLES2GetProgramResourceIndex(GLuint program,
-                                                GLenum program_interface,
-                                                const char* name) {
-  return gles2::GetGLContext()->GetProgramResourceIndex(
-      program, program_interface, name);
-}
-void GL_APIENTRY GLES2GetProgramResourceName(GLuint program,
-                                             GLenum program_interface,
-                                             GLuint index,
-                                             GLsizei bufsize,
-                                             GLsizei* length,
-                                             char* name) {
-  gles2::GetGLContext()->GetProgramResourceName(program, program_interface,
-                                                index, bufsize, length, name);
-}
-void GL_APIENTRY GLES2GetProgramResourceiv(GLuint program,
-                                           GLenum program_interface,
-                                           GLuint index,
-                                           GLsizei prop_count,
-                                           const GLenum* props,
-                                           GLsizei bufsize,
-                                           GLsizei* length,
-                                           GLint* params) {
-  gles2::GetGLContext()->GetProgramResourceiv(program, program_interface, index,
-                                              prop_count, props, bufsize,
-                                              length, params);
-}
-GLint GL_APIENTRY GLES2GetProgramResourceLocation(GLuint program,
-                                                  GLenum program_interface,
-                                                  const char* name) {
-  return gles2::GetGLContext()->GetProgramResourceLocation(
-      program, program_interface, name);
-}
 void GL_APIENTRY GLES2MemoryBarrierEXT(GLbitfield barriers) {
   gles2::GetGLContext()->MemoryBarrierEXT(barriers);
 }
@@ -1931,14 +1881,6 @@
   return gles2::GetGLContext()->CreateAndTexStorage2DSharedImageCHROMIUM(
       mailbox);
 }
-GLuint GL_APIENTRY
-GLES2CreateAndTexStorage2DSharedImageWithInternalFormatCHROMIUM(
-    const GLbyte* mailbox,
-    GLenum internalformat) {
-  return gles2::GetGLContext()
-      ->CreateAndTexStorage2DSharedImageWithInternalFormatCHROMIUM(
-          mailbox, internalformat);
-}
 void GL_APIENTRY GLES2BeginSharedImageAccessDirectCHROMIUM(GLuint texture,
                                                            GLenum mode) {
   gles2::GetGLContext()->BeginSharedImageAccessDirectCHROMIUM(texture, mode);
@@ -2866,11 +2808,6 @@
             glRenderbufferStorageMultisampleCHROMIUM),
     },
     {
-        "glRenderbufferStorageMultisampleAdvancedAMD",
-        reinterpret_cast<GLES2FunctionPointer>(
-            glRenderbufferStorageMultisampleAdvancedAMD),
-    },
-    {
         "glRenderbufferStorageMultisampleEXT",
         reinterpret_cast<GLES2FunctionPointer>(
             glRenderbufferStorageMultisampleEXT),
@@ -2981,26 +2918,6 @@
         reinterpret_cast<GLES2FunctionPointer>(glDispatchCompute),
     },
     {
-        "glGetProgramInterfaceiv",
-        reinterpret_cast<GLES2FunctionPointer>(glGetProgramInterfaceiv),
-    },
-    {
-        "glGetProgramResourceIndex",
-        reinterpret_cast<GLES2FunctionPointer>(glGetProgramResourceIndex),
-    },
-    {
-        "glGetProgramResourceName",
-        reinterpret_cast<GLES2FunctionPointer>(glGetProgramResourceName),
-    },
-    {
-        "glGetProgramResourceiv",
-        reinterpret_cast<GLES2FunctionPointer>(glGetProgramResourceiv),
-    },
-    {
-        "glGetProgramResourceLocation",
-        reinterpret_cast<GLES2FunctionPointer>(glGetProgramResourceLocation),
-    },
-    {
         "glMemoryBarrierEXT",
         reinterpret_cast<GLES2FunctionPointer>(glMemoryBarrierEXT),
     },
@@ -3454,11 +3371,6 @@
             glCreateAndTexStorage2DSharedImageCHROMIUM),
     },
     {
-        "glCreateAndTexStorage2DSharedImageWithInternalFormatCHROMIUM",
-        reinterpret_cast<GLES2FunctionPointer>(
-            glCreateAndTexStorage2DSharedImageWithInternalFormatCHROMIUM),
-    },
-    {
         "glBeginSharedImageAccessDirectCHROMIUM",
         reinterpret_cast<GLES2FunctionPointer>(
             glBeginSharedImageAccessDirectCHROMIUM),
--- a/gpu/command_buffer/client/gles2_cmd_helper_autogen.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/client/gles2_cmd_helper_autogen.h	2019-05-17 18:53:32.948000000 +0300
@@ -2270,19 +2270,6 @@
   }
 }
 
-void RenderbufferStorageMultisampleAdvancedAMD(GLenum target,
-                                               GLsizei samples,
-                                               GLsizei storageSamples,
-                                               GLenum internalformat,
-                                               GLsizei width,
-                                               GLsizei height) {
-  gles2::cmds::RenderbufferStorageMultisampleAdvancedAMD* c =
-      GetCmdSpace<gles2::cmds::RenderbufferStorageMultisampleAdvancedAMD>();
-  if (c) {
-    c->Init(target, samples, storageSamples, internalformat, width, height);
-  }
-}
-
 void RenderbufferStorageMultisampleEXT(GLenum target,
                                        GLsizei samples,
                                        GLenum internalformat,
@@ -2486,73 +2473,6 @@
   }
 }
 
-void GetProgramInterfaceiv(GLuint program,
-                           GLenum program_interface,
-                           GLenum pname,
-                           uint32_t params_shm_id,
-                           uint32_t params_shm_offset) {
-  gles2::cmds::GetProgramInterfaceiv* c =
-      GetCmdSpace<gles2::cmds::GetProgramInterfaceiv>();
-  if (c) {
-    c->Init(program, program_interface, pname, params_shm_id,
-            params_shm_offset);
-  }
-}
-
-void GetProgramResourceIndex(GLuint program,
-                             GLenum program_interface,
-                             uint32_t name_bucket_id,
-                             uint32_t index_shm_id,
-                             uint32_t index_shm_offset) {
-  gles2::cmds::GetProgramResourceIndex* c =
-      GetCmdSpace<gles2::cmds::GetProgramResourceIndex>();
-  if (c) {
-    c->Init(program, program_interface, name_bucket_id, index_shm_id,
-            index_shm_offset);
-  }
-}
-
-void GetProgramResourceName(GLuint program,
-                            GLenum program_interface,
-                            GLuint index,
-                            uint32_t name_bucket_id,
-                            uint32_t result_shm_id,
-                            uint32_t result_shm_offset) {
-  gles2::cmds::GetProgramResourceName* c =
-      GetCmdSpace<gles2::cmds::GetProgramResourceName>();
-  if (c) {
-    c->Init(program, program_interface, index, name_bucket_id, result_shm_id,
-            result_shm_offset);
-  }
-}
-
-void GetProgramResourceiv(GLuint program,
-                          GLenum program_interface,
-                          GLuint index,
-                          uint32_t props_bucket_id,
-                          uint32_t params_shm_id,
-                          uint32_t params_shm_offset) {
-  gles2::cmds::GetProgramResourceiv* c =
-      GetCmdSpace<gles2::cmds::GetProgramResourceiv>();
-  if (c) {
-    c->Init(program, program_interface, index, props_bucket_id, params_shm_id,
-            params_shm_offset);
-  }
-}
-
-void GetProgramResourceLocation(GLuint program,
-                                GLenum program_interface,
-                                uint32_t name_bucket_id,
-                                uint32_t location_shm_id,
-                                uint32_t location_shm_offset) {
-  gles2::cmds::GetProgramResourceLocation* c =
-      GetCmdSpace<gles2::cmds::GetProgramResourceLocation>();
-  if (c) {
-    c->Init(program, program_interface, name_bucket_id, location_shm_id,
-            location_shm_offset);
-  }
-}
-
 void MemoryBarrierEXT(GLbitfield barriers) {
   gles2::cmds::MemoryBarrierEXT* c =
       GetCmdSpace<gles2::cmds::MemoryBarrierEXT>();
@@ -3554,15 +3474,14 @@
 }
 
 void CreateAndTexStorage2DSharedImageINTERNALImmediate(GLuint texture,
-                                                       const GLbyte* mailbox,
-                                                       GLenum internalformat) {
+                                                       const GLbyte* mailbox) {
   const uint32_t size = gles2::cmds::
       CreateAndTexStorage2DSharedImageINTERNALImmediate::ComputeSize();
   gles2::cmds::CreateAndTexStorage2DSharedImageINTERNALImmediate* c =
       GetImmediateCmdSpaceTotalSize<
           gles2::cmds::CreateAndTexStorage2DSharedImageINTERNALImmediate>(size);
   if (c) {
-    c->Init(texture, mailbox, internalformat);
+    c->Init(texture, mailbox);
   }
 }
 
--- a/gpu/command_buffer/client/gles2_implementation_autogen.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/client/gles2_implementation_autogen.h	2019-05-17 18:53:32.948000000 +0300
@@ -808,13 +808,6 @@
                                             GLsizei width,
                                             GLsizei height) override;
 
-void RenderbufferStorageMultisampleAdvancedAMD(GLenum target,
-                                               GLsizei samples,
-                                               GLsizei storageSamples,
-                                               GLenum internalformat,
-                                               GLsizei width,
-                                               GLsizei height) override;
-
 void RenderbufferStorageMultisampleEXT(GLenum target,
                                        GLsizei samples,
                                        GLenum internalformat,
@@ -890,35 +883,6 @@
                      GLuint num_groups_y,
                      GLuint num_groups_z) override;
 
-void GetProgramInterfaceiv(GLuint program,
-                           GLenum program_interface,
-                           GLenum pname,
-                           GLint* params) override;
-
-GLuint GetProgramResourceIndex(GLuint program,
-                               GLenum program_interface,
-                               const char* name) override;
-
-void GetProgramResourceName(GLuint program,
-                            GLenum program_interface,
-                            GLuint index,
-                            GLsizei bufsize,
-                            GLsizei* length,
-                            char* name) override;
-
-void GetProgramResourceiv(GLuint program,
-                          GLenum program_interface,
-                          GLuint index,
-                          GLsizei prop_count,
-                          const GLenum* props,
-                          GLsizei bufsize,
-                          GLsizei* length,
-                          GLint* params) override;
-
-GLint GetProgramResourceLocation(GLuint program,
-                                 GLenum program_interface,
-                                 const char* name) override;
-
 void MemoryBarrierEXT(GLbitfield barriers) override;
 
 void MemoryBarrierByRegion(GLbitfield barriers) override;
@@ -1358,10 +1322,6 @@
 
 GLuint CreateAndTexStorage2DSharedImageCHROMIUM(const GLbyte* mailbox) override;
 
-GLuint CreateAndTexStorage2DSharedImageWithInternalFormatCHROMIUM(
-    const GLbyte* mailbox,
-    GLenum internalformat) override;
-
 void BeginSharedImageAccessDirectCHROMIUM(GLuint texture, GLenum mode) override;
 
 void EndSharedImageAccessDirectCHROMIUM(GLuint texture) override;
--- a/gpu/command_buffer/client/gles2_implementation.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/client/gles2_implementation.cc	2019-05-17 18:53:32.948000000 +0300
@@ -21,7 +21,6 @@
 #include <string>
 
 #include "base/atomic_sequence_num.h"
-#include "base/bind.h"
 #include "base/bits.h"
 #include "base/compiler_specific.h"
 #include "base/containers/span.h"
@@ -420,11 +419,6 @@
   pending_presentation_callbacks_.erase(found);
 }
 
-void GLES2Implementation::OnGpuControlReturnData(
-    base::span<const uint8_t> data) {
-  NOTIMPLEMENTED();
-}
-
 void GLES2Implementation::FreeSharedMemory(void* mem) {
   mapped_memory_->FreePendingToken(mem, helper_->InsertToken());
 }
@@ -1814,231 +1808,6 @@
   return index;
 }
 
-bool GLES2Implementation::GetProgramInterfaceivHelper(GLuint program,
-                                                      GLenum program_interface,
-                                                      GLenum pname,
-                                                      GLint* params) {
-  bool success = share_group_->program_info_manager()->GetProgramInterfaceiv(
-      this, program, program_interface, pname, params);
-  GPU_CLIENT_LOG_CODE_BLOCK({
-    if (success) {
-      GPU_CLIENT_LOG("  0: " << *params);
-    }
-  });
-  return success;
-}
-
-GLuint GLES2Implementation::GetProgramResourceIndexHelper(
-    GLuint program,
-    GLenum program_interface,
-    const char* name) {
-  typedef cmds::GetProgramResourceIndex::Result Result;
-  SetBucketAsCString(kResultBucketId, name);
-  auto result = GetResultAs<Result>();
-  if (!result) {
-    return GL_INVALID_INDEX;
-  }
-  *result = GL_INVALID_INDEX;
-  helper_->GetProgramResourceIndex(program, program_interface, kResultBucketId,
-                                   GetResultShmId(), result.offset());
-  WaitForCmd();
-  helper_->SetBucketSize(kResultBucketId, 0);
-  return *result;
-}
-
-GLuint GLES2Implementation::GetProgramResourceIndex(
-    GLuint program,
-    GLenum program_interface,
-    const char* name) {
-  GPU_CLIENT_SINGLE_THREAD_CHECK();
-  GPU_CLIENT_LOG("[" << GetLogPrefix() << "] glGetProgramResourceIndex("
-                     << program << ", " << program_interface << ", " << name
-                     << ")");
-  TRACE_EVENT0("gpu", "GLES2::GetProgramResourceIndex");
-  GLuint index = share_group_->program_info_manager()->GetProgramResourceIndex(
-      this, program, program_interface, name);
-  GPU_CLIENT_LOG("returned " << index);
-  CheckGLError();
-  return index;
-}
-
-bool GLES2Implementation::GetProgramResourceNameHelper(GLuint program,
-                                                       GLenum program_interface,
-                                                       GLuint index,
-                                                       GLsizei bufsize,
-                                                       GLsizei* length,
-                                                       char* name) {
-  DCHECK_LE(0, bufsize);
-  // Clear the bucket so if the command fails nothing will be in it.
-  helper_->SetBucketSize(kResultBucketId, 0);
-  bool success = false;
-  {
-    // The Result pointer must be scoped to this block because it can be
-    // invalidated below if getting result name causes the transfer buffer to be
-    // reallocated.
-    typedef cmds::GetProgramResourceName::Result Result;
-    auto result = GetResultAs<Result>();
-    if (!result) {
-      return false;
-    }
-    // Set as failed so if the command fails we'll recover.
-    *result = 0;
-    helper_->GetProgramResourceName(program, program_interface, index,
-                                    kResultBucketId, GetResultShmId(),
-                                    result.offset());
-    WaitForCmd();
-    success = !!*result;
-  }
-  if (success) {
-    GetResultNameHelper(bufsize, length, name);
-  }
-  return success;
-}
-
-void GLES2Implementation::GetProgramResourceName(GLuint program,
-                                                 GLenum program_interface,
-                                                 GLuint index,
-                                                 GLsizei bufsize,
-                                                 GLsizei* length,
-                                                 char* name) {
-  GPU_CLIENT_SINGLE_THREAD_CHECK();
-  GPU_CLIENT_LOG("[" << GetLogPrefix() << "] glGetProgramResourceName("
-                     << program << ", " << program_interface << ", " << index
-                     << ", " << bufsize << ", " << static_cast<void*>(length)
-                     << ", " << static_cast<void*>(name) << ")");
-  if (bufsize < 0) {
-    SetGLError(GL_INVALID_VALUE, "glGetProgramResourceName", "bufsize < 0");
-    return;
-  }
-  TRACE_EVENT0("gpu", "GLES2::GetProgramResourceName");
-  bool success = share_group_->program_info_manager()->GetProgramResourceName(
-      this, program, program_interface, index, bufsize, length, name);
-  if (success && name) {
-    GPU_CLIENT_LOG("  name: " << name);
-  }
-  CheckGLError();
-}
-
-bool GLES2Implementation::GetProgramResourceivHelper(GLuint program,
-                                                     GLenum program_interface,
-                                                     GLuint index,
-                                                     GLsizei prop_count,
-                                                     const GLenum* props,
-                                                     GLsizei bufsize,
-                                                     GLsizei* length,
-                                                     GLint* params) {
-  DCHECK_LE(0, prop_count);
-  DCHECK_LE(0, bufsize);
-  base::CheckedNumeric<uint32_t> bytes = prop_count;
-  bytes *= sizeof(GLenum);
-  if (!bytes.IsValid()) {
-    SetGLError(GL_INVALID_VALUE, "glGetProgramResourceiv", "count overflow");
-    return false;
-  }
-  SetBucketContents(kResultBucketId, props, bytes.ValueOrDefault(0));
-  typedef cmds::GetProgramResourceiv::Result Result;
-  auto result = GetResultAs<Result>();
-  if (!result) {
-    return false;
-  }
-  result->SetNumResults(0);
-  helper_->GetProgramResourceiv(program, program_interface, index,
-                                kResultBucketId, GetResultShmId(),
-                                result.offset());
-  WaitForCmd();
-  if (length) {
-    *length = result->GetNumResults();
-  }
-  if (result->GetNumResults() > 0) {
-    if (params) {
-      result->CopyResult(params);
-    }
-    GPU_CLIENT_LOG_CODE_BLOCK({
-      for (int32_t i = 0; i < result->GetNumResults(); ++i) {
-        GPU_CLIENT_LOG("  " << i << ": " << result->GetData()[i]);
-      }
-    });
-    return true;
-  }
-  return false;
-}
-
-void GLES2Implementation::GetProgramResourceiv(GLuint program,
-                                               GLenum program_interface,
-                                               GLuint index,
-                                               GLsizei prop_count,
-                                               const GLenum* props,
-                                               GLsizei bufsize,
-                                               GLsizei* length,
-                                               GLint* params) {
-  GPU_CLIENT_SINGLE_THREAD_CHECK();
-  GPU_CLIENT_LOG("[" << GetLogPrefix() << "] glGetProgramResourceiv(" << program
-                     << ", " << program_interface << ", " << index << ", "
-                     << prop_count << ", " << static_cast<const void*>(props)
-                     << ", " << bufsize << ", " << static_cast<void*>(length)
-                     << ", " << static_cast<void*>(params) << ")");
-  if (prop_count < 0) {
-    SetGLError(GL_INVALID_VALUE, "glGetProgramResourceiv", "prop_count < 0");
-    return;
-  }
-  if (bufsize < 0) {
-    SetGLError(GL_INVALID_VALUE, "glGetProgramResourceiv", "bufsize < 0");
-    return;
-  }
-  TRACE_EVENT0("gpu", "GLES2::GetProgramResourceiv");
-  GLsizei param_count = 0;
-  bool success = share_group_->program_info_manager()->GetProgramResourceiv(
-      this, program, program_interface, index, prop_count, props, bufsize,
-      &param_count, params);
-  if (length) {
-    *length = param_count;
-  }
-  if (success && params) {
-    GPU_CLIENT_LOG_CODE_BLOCK({
-      for (GLsizei ii = 0; ii < param_count; ++ii) {
-        GPU_CLIENT_LOG("  " << ii << ": " << params[ii]);
-      }
-    });
-  }
-  CheckGLError();
-}
-
-GLint GLES2Implementation::GetProgramResourceLocationHelper(
-    GLuint program,
-    GLenum program_interface,
-    const char* name) {
-  typedef cmds::GetProgramResourceLocation::Result Result;
-  SetBucketAsCString(kResultBucketId, name);
-  auto result = GetResultAs<Result>();
-  if (!result) {
-    return -1;
-  }
-  *result = -1;
-  helper_->GetProgramResourceLocation(program, program_interface,
-                                      kResultBucketId, GetResultShmId(),
-                                      result.offset());
-  WaitForCmd();
-  helper_->SetBucketSize(kResultBucketId, 0);
-  return *result;
-}
-
-GLint GLES2Implementation::GetProgramResourceLocation(
-    GLuint program,
-    GLenum program_interface,
-    const char* name) {
-  GPU_CLIENT_SINGLE_THREAD_CHECK();
-  GPU_CLIENT_LOG("[" << GetLogPrefix() << "] glGetProgramResourceLocation("
-                     << program << ", " << program_interface << ", " << name
-                     << ")");
-  TRACE_EVENT0("gpu", "GLES2::GetProgramResourceLocation");
-  GLint location =
-      share_group_->program_info_manager()->GetProgramResourceLocation(
-          this, program, program_interface, name);
-  GPU_CLIENT_LOG("returned " << location);
-  CheckGLError();
-  return location;
-}
-
 void GLES2Implementation::LinkProgram(GLuint program) {
   GPU_CLIENT_SINGLE_THREAD_CHECK();
   GPU_CLIENT_LOG("[" << GetLogPrefix() << "] glLinkProgram(" << program << ")");
@@ -6366,25 +6135,29 @@
                "count less than 0.");
     return;
   }
+  if (count == 0) {
+    return;
+  }
   if (primcount < 0) {
     SetGLError(GL_INVALID_VALUE, "glDrawElementsInstancedANGLE",
                "primcount < 0");
     return;
   }
-  GLuint offset = 0;
-  bool simulated = false;
-  if (count > 0 && primcount > 0) {
+  if (primcount == 0) {
+    return;
+  }
     if (vertex_array_object_manager_->bound_element_array_buffer() != 0 &&
         !ValidateOffset("glDrawElementsInstancedANGLE",
                         reinterpret_cast<GLintptr>(indices))) {
       return;
     }
+  GLuint offset = 0;
+  bool simulated = false;
     if (!vertex_array_object_manager_->SetupSimulatedIndexAndClientSideBuffers(
-            "glDrawElementsInstancedANGLE", this, helper_, count, type,
-            primcount, indices, &offset, &simulated)) {
+          "glDrawElementsInstancedANGLE", this, helper_, count, type, primcount,
+          indices, &offset, &simulated)) {
       return;
     }
-  }
   helper_->DrawElementsInstancedANGLE(mode, count, type, offset, primcount);
   RestoreElementAndArrayBuffers(simulated);
   CheckGLError();
@@ -6432,31 +6205,7 @@
                               "passed an invalid mailbox.";
   GLuint client_id;
   GetIdHandler(SharedIdNamespaces::kTextures)->MakeIds(this, 0, 1, &client_id);
-  helper_->CreateAndTexStorage2DSharedImageINTERNALImmediate(client_id, data,
-                                                             GL_NONE);
-  if (share_group_->bind_generates_resource())
-    helper_->CommandBufferHelper::OrderingBarrier();
-  CheckGLError();
-  return client_id;
-}
-
-GLuint
-GLES2Implementation::CreateAndTexStorage2DSharedImageWithInternalFormatCHROMIUM(
-    const GLbyte* data,
-    GLenum internalformat) {
-  GPU_CLIENT_SINGLE_THREAD_CHECK();
-  GPU_CLIENT_LOG(
-      "[" << GetLogPrefix()
-          << "] CreateAndTexStorage2DSharedImageWithInternalFormatCHROMIUM("
-          << static_cast<const void*>(data) << ", " << internalformat << ")");
-  const Mailbox& mailbox = *reinterpret_cast<const Mailbox*>(data);
-  DCHECK(mailbox.Verify())
-      << "CreateAndTexStorage2DSharedImageWithInternalFormatCHROMIUM was "
-         "passed an invalid mailbox.";
-  GLuint client_id;
-  GetIdHandler(SharedIdNamespaces::kTextures)->MakeIds(this, 0, 1, &client_id);
-  helper_->CreateAndTexStorage2DSharedImageINTERNALImmediate(client_id, data,
-                                                             internalformat);
+  helper_->CreateAndTexStorage2DSharedImageINTERNALImmediate(client_id, data);
   if (share_group_->bind_generates_resource())
     helper_->CommandBufferHelper::OrderingBarrier();
   CheckGLError();
--- a/gpu/command_buffer/client/gles2_implementation.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/client/gles2_implementation.h	2019-05-17 18:53:32.948000000 +0300
@@ -186,19 +186,6 @@
       GLint* values);
   bool GetQueryObjectValueHelper(
       const char* function_name, GLuint id, GLenum pname, GLuint64* params);
-  bool GetProgramInterfaceivHelper(
-      GLuint program, GLenum program_interface, GLenum pname, GLint* params);
-  GLuint GetProgramResourceIndexHelper(
-      GLuint program, GLenum program_interface, const char* name);
-  bool GetProgramResourceNameHelper(
-      GLuint program, GLenum program_interface, GLuint index, GLsizei bufsize,
-      GLsizei* length, char* name);
-  bool GetProgramResourceivHelper(
-      GLuint program, GLenum program_interface, GLuint index,
-      GLsizei prop_count, const GLenum* props, GLsizei bufsize, GLsizei* length,
-      GLint* params);
-  GLint GetProgramResourceLocationHelper(
-      GLuint program, GLenum program_interface, const char* name);
 
   const scoped_refptr<ShareGroup>& share_group() const { return share_group_; }
 
@@ -390,7 +377,6 @@
       const SwapBuffersCompleteParams& params) final;
   void OnSwapBufferPresented(uint64_t swap_id,
                              const gfx::PresentationFeedback& feedback) final;
-  void OnGpuControlReturnData(base::span<const uint8_t> data) final;
 
   void SendErrorMessage(std::string message, int32_t id);
   void CallDeferredErrorCallbacks();
--- a/gpu/command_buffer/client/gles2_implementation_impl_autogen.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/client/gles2_implementation_impl_autogen.h	2019-05-17 18:53:32.952000000 +0300
@@ -2818,45 +2818,6 @@
   CheckGLError();
 }
 
-void GLES2Implementation::RenderbufferStorageMultisampleAdvancedAMD(
-    GLenum target,
-    GLsizei samples,
-    GLsizei storageSamples,
-    GLenum internalformat,
-    GLsizei width,
-    GLsizei height) {
-  GPU_CLIENT_SINGLE_THREAD_CHECK();
-  GPU_CLIENT_LOG("[" << GetLogPrefix()
-                     << "] glRenderbufferStorageMultisampleAdvancedAMD("
-                     << GLES2Util::GetStringRenderBufferTarget(target) << ", "
-                     << samples << ", " << storageSamples << ", "
-                     << GLES2Util::GetStringRenderBufferFormat(internalformat)
-                     << ", " << width << ", " << height << ")");
-  if (samples < 0) {
-    SetGLError(GL_INVALID_VALUE, "glRenderbufferStorageMultisampleAdvancedAMD",
-               "samples < 0");
-    return;
-  }
-  if (storageSamples < 0) {
-    SetGLError(GL_INVALID_VALUE, "glRenderbufferStorageMultisampleAdvancedAMD",
-               "storageSamples < 0");
-    return;
-  }
-  if (width < 0) {
-    SetGLError(GL_INVALID_VALUE, "glRenderbufferStorageMultisampleAdvancedAMD",
-               "width < 0");
-    return;
-  }
-  if (height < 0) {
-    SetGLError(GL_INVALID_VALUE, "glRenderbufferStorageMultisampleAdvancedAMD",
-               "height < 0");
-    return;
-  }
-  helper_->RenderbufferStorageMultisampleAdvancedAMD(
-      target, samples, storageSamples, internalformat, width, height);
-  CheckGLError();
-}
-
 void GLES2Implementation::RenderbufferStorageMultisampleEXT(
     GLenum target,
     GLsizei samples,
@@ -3116,38 +3077,6 @@
   CheckGLError();
 }
 
-void GLES2Implementation::GetProgramInterfaceiv(GLuint program,
-                                                GLenum program_interface,
-                                                GLenum pname,
-                                                GLint* params) {
-  GPU_CLIENT_SINGLE_THREAD_CHECK();
-  GPU_CLIENT_VALIDATE_DESTINATION_INITALIZATION(GLint, params);
-  GPU_CLIENT_LOG("[" << GetLogPrefix() << "] glGetProgramInterfaceiv("
-                     << program << ", "
-                     << GLES2Util::GetStringEnum(program_interface) << ", "
-                     << GLES2Util::GetStringEnum(pname) << ", "
-                     << static_cast<const void*>(params) << ")");
-  TRACE_EVENT0("gpu", "GLES2Implementation::GetProgramInterfaceiv");
-  if (GetProgramInterfaceivHelper(program, program_interface, pname, params)) {
-    return;
-  }
-  typedef cmds::GetProgramInterfaceiv::Result Result;
-  ScopedResultPtr<Result> result = GetResultAs<Result>();
-  if (!result) {
-    return;
-  }
-  result->SetNumResults(0);
-  helper_->GetProgramInterfaceiv(program, program_interface, pname,
-                                 GetResultShmId(), result.offset());
-  WaitForCmd();
-  result->CopyResult(params);
-  GPU_CLIENT_LOG_CODE_BLOCK({
-    for (int32_t i = 0; i < result->GetNumResults(); ++i) {
-      GPU_CLIENT_LOG("  " << i << ": " << result->GetData()[i]);
-    }
-  });
-  CheckGLError();
-}
 void GLES2Implementation::MemoryBarrierEXT(GLbitfield barriers) {
   GPU_CLIENT_SINGLE_THREAD_CHECK();
   GPU_CLIENT_LOG("[" << GetLogPrefix() << "] glMemoryBarrierEXT(" << barriers
--- a/gpu/command_buffer/client/gles2_implementation_unittest_autogen.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/client/gles2_implementation_unittest_autogen.h	2019-05-17 18:53:32.952000000 +0300
@@ -2528,18 +2528,6 @@
   EXPECT_EQ(0, memcmp(&expected, commands_, sizeof(expected)));
 }
 
-TEST_F(GLES2ImplementationTest, RenderbufferStorageMultisampleAdvancedAMD) {
-  struct Cmds {
-    cmds::RenderbufferStorageMultisampleAdvancedAMD cmd;
-  };
-  Cmds expected;
-  expected.cmd.Init(GL_RENDERBUFFER, 2, 3, GL_RGBA4, 5, 6);
-
-  gl_->RenderbufferStorageMultisampleAdvancedAMD(GL_RENDERBUFFER, 2, 3,
-                                                 GL_RGBA4, 5, 6);
-  EXPECT_EQ(0, memcmp(&expected, commands_, sizeof(expected)));
-}
-
 TEST_F(GLES2ImplementationTest, RenderbufferStorageMultisampleEXT) {
   struct Cmds {
     cmds::RenderbufferStorageMultisampleEXT cmd;
@@ -2724,24 +2712,6 @@
   EXPECT_EQ(0, memcmp(&expected, commands_, sizeof(expected)));
 }
 
-TEST_F(GLES2ImplementationTest, GetProgramInterfaceiv) {
-  struct Cmds {
-    cmds::GetProgramInterfaceiv cmd;
-  };
-  typedef cmds::GetProgramInterfaceiv::Result::Type ResultType;
-  ResultType result = 0;
-  Cmds expected;
-  ExpectedMemoryInfo result1 =
-      GetExpectedResultMemory(sizeof(uint32_t) + sizeof(ResultType));
-  expected.cmd.Init(123, 2, 3, result1.id, result1.offset);
-  EXPECT_CALL(*command_buffer(), OnFlush())
-      .WillOnce(SetMemory(result1.ptr, SizedResultHelper<ResultType>(1)))
-      .RetiresOnSaturation();
-  gl_->GetProgramInterfaceiv(123, 2, 3, &result);
-  EXPECT_EQ(0, memcmp(&expected, commands_, sizeof(expected)));
-  EXPECT_EQ(static_cast<ResultType>(1), result);
-}
-
 TEST_F(GLES2ImplementationTest, MemoryBarrierEXT) {
   struct Cmds {
     cmds::MemoryBarrierEXT cmd;
--- a/gpu/command_buffer/client/gles2_implementation_unittest.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/client/gles2_implementation_unittest.cc	2019-05-17 18:53:32.952000000 +0300
@@ -16,7 +16,6 @@
 
 #include <memory>
 
-#include "base/bind.h"
 #include "base/compiler_specific.h"
 #include "base/stl_util.h"
 #include "gpu/command_buffer/client/client_test_helper.h"
@@ -3588,28 +3587,11 @@
 
   Mailbox mailbox = Mailbox::Generate();
   Cmds expected;
-  expected.cmd.Init(kTexturesStartId, mailbox.name, GL_NONE);
+  expected.cmd.Init(kTexturesStartId, mailbox.name);
   GLuint id = gl_->CreateAndTexStorage2DSharedImageCHROMIUM(mailbox.name);
   EXPECT_EQ(0, memcmp(&expected, commands_, sizeof(expected)));
   EXPECT_EQ(kTexturesStartId, id);
 }
-
-TEST_F(GLES2ImplementationTest,
-       CreateAndTexStorage2DSharedImageWithInternalFormatCHROMIUM) {
-  struct Cmds {
-    cmds::CreateAndTexStorage2DSharedImageINTERNALImmediate cmd;
-    GLbyte data[GL_MAILBOX_SIZE_CHROMIUM];
-  };
-
-  Mailbox mailbox = Mailbox::Generate();
-  const GLenum kFormat = GL_RGBA;
-  Cmds expected;
-  expected.cmd.Init(kTexturesStartId, mailbox.name, kFormat);
-  GLuint id = gl_->CreateAndTexStorage2DSharedImageWithInternalFormatCHROMIUM(
-      mailbox.name, kFormat);
-  EXPECT_EQ(0, memcmp(&expected, commands_, sizeof(expected)));
-  EXPECT_EQ(kTexturesStartId, id);
-}
 
 TEST_F(GLES2ImplementationTest, ProduceTextureDirectCHROMIUM) {
   struct Cmds {
--- a/gpu/command_buffer/client/gles2_interface_autogen.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/client/gles2_interface_autogen.h	2019-05-17 18:53:32.952000000 +0300
@@ -596,12 +596,6 @@
                                                     GLenum internalformat,
                                                     GLsizei width,
                                                     GLsizei height) = 0;
-virtual void RenderbufferStorageMultisampleAdvancedAMD(GLenum target,
-                                                       GLsizei samples,
-                                                       GLsizei storageSamples,
-                                                       GLenum internalformat,
-                                                       GLsizei width,
-                                                       GLsizei height) = 0;
 virtual void RenderbufferStorageMultisampleEXT(GLenum target,
                                                GLsizei samples,
                                                GLenum internalformat,
@@ -656,30 +650,6 @@
 virtual void DispatchCompute(GLuint num_groups_x,
                              GLuint num_groups_y,
                              GLuint num_groups_z) = 0;
-virtual void GetProgramInterfaceiv(GLuint program,
-                                   GLenum program_interface,
-                                   GLenum pname,
-                                   GLint* params) = 0;
-virtual GLuint GetProgramResourceIndex(GLuint program,
-                                       GLenum program_interface,
-                                       const char* name) = 0;
-virtual void GetProgramResourceName(GLuint program,
-                                    GLenum program_interface,
-                                    GLuint index,
-                                    GLsizei bufsize,
-                                    GLsizei* length,
-                                    char* name) = 0;
-virtual void GetProgramResourceiv(GLuint program,
-                                  GLenum program_interface,
-                                  GLuint index,
-                                  GLsizei prop_count,
-                                  const GLenum* props,
-                                  GLsizei bufsize,
-                                  GLsizei* length,
-                                  GLint* params) = 0;
-virtual GLint GetProgramResourceLocation(GLuint program,
-                                         GLenum program_interface,
-                                         const char* name) = 0;
 virtual void MemoryBarrierEXT(GLbitfield barriers) = 0;
 virtual void MemoryBarrierByRegion(GLbitfield barriers) = 0;
 virtual void SwapBuffers(GLuint64 swap_id, GLbitfield flags = 0) = 0;
@@ -1020,9 +990,6 @@
 virtual void MaxShaderCompilerThreadsKHR(GLuint count) = 0;
 virtual GLuint CreateAndTexStorage2DSharedImageCHROMIUM(
     const GLbyte* mailbox) = 0;
-virtual GLuint CreateAndTexStorage2DSharedImageWithInternalFormatCHROMIUM(
-    const GLbyte* mailbox,
-    GLenum internalformat) = 0;
 virtual void BeginSharedImageAccessDirectCHROMIUM(GLuint texture,
                                                   GLenum mode) = 0;
 virtual void EndSharedImageAccessDirectCHROMIUM(GLuint texture) = 0;
--- a/gpu/command_buffer/client/gles2_interface.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/client/gles2_interface.h	2019-05-17 18:53:32.952000000 +0300
@@ -34,7 +34,7 @@
   GLES2Interface() = default;
   virtual ~GLES2Interface() = default;
 
-  virtual void FreeSharedMemory(void*) {}
+  virtual void FreeSharedMemory(void*) {};
 
   // Include the auto-generated part of this class. We split this because
   // it means we can easily edit the non-auto generated parts right here in
--- a/gpu/command_buffer/client/gles2_interface_stub_autogen.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/client/gles2_interface_stub_autogen.h	2019-05-17 18:53:32.952000000 +0300
@@ -579,12 +579,6 @@
                                             GLenum internalformat,
                                             GLsizei width,
                                             GLsizei height) override;
-void RenderbufferStorageMultisampleAdvancedAMD(GLenum target,
-                                               GLsizei samples,
-                                               GLsizei storageSamples,
-                                               GLenum internalformat,
-                                               GLsizei width,
-                                               GLsizei height) override;
 void RenderbufferStorageMultisampleEXT(GLenum target,
                                        GLsizei samples,
                                        GLenum internalformat,
@@ -633,30 +627,6 @@
 void DispatchCompute(GLuint num_groups_x,
                      GLuint num_groups_y,
                      GLuint num_groups_z) override;
-void GetProgramInterfaceiv(GLuint program,
-                           GLenum program_interface,
-                           GLenum pname,
-                           GLint* params) override;
-GLuint GetProgramResourceIndex(GLuint program,
-                               GLenum program_interface,
-                               const char* name) override;
-void GetProgramResourceName(GLuint program,
-                            GLenum program_interface,
-                            GLuint index,
-                            GLsizei bufsize,
-                            GLsizei* length,
-                            char* name) override;
-void GetProgramResourceiv(GLuint program,
-                          GLenum program_interface,
-                          GLuint index,
-                          GLsizei prop_count,
-                          const GLenum* props,
-                          GLsizei bufsize,
-                          GLsizei* length,
-                          GLint* params) override;
-GLint GetProgramResourceLocation(GLuint program,
-                                 GLenum program_interface,
-                                 const char* name) override;
 void MemoryBarrierEXT(GLbitfield barriers) override;
 void MemoryBarrierByRegion(GLbitfield barriers) override;
 void SwapBuffers(GLuint64 swap_id, GLbitfield flags) override;
@@ -989,9 +959,6 @@
                                              GLsizei numViews) override;
 void MaxShaderCompilerThreadsKHR(GLuint count) override;
 GLuint CreateAndTexStorage2DSharedImageCHROMIUM(const GLbyte* mailbox) override;
-GLuint CreateAndTexStorage2DSharedImageWithInternalFormatCHROMIUM(
-    const GLbyte* mailbox,
-    GLenum internalformat) override;
 void BeginSharedImageAccessDirectCHROMIUM(GLuint texture, GLenum mode) override;
 void EndSharedImageAccessDirectCHROMIUM(GLuint texture) override;
 #endif  // GPU_COMMAND_BUFFER_CLIENT_GLES2_INTERFACE_STUB_AUTOGEN_H_
--- a/gpu/command_buffer/client/gles2_interface_stub_impl_autogen.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/client/gles2_interface_stub_impl_autogen.h	2019-05-17 18:53:32.952000000 +0300
@@ -779,13 +779,6 @@
     GLenum /* internalformat */,
     GLsizei /* width */,
     GLsizei /* height */) {}
-void GLES2InterfaceStub::RenderbufferStorageMultisampleAdvancedAMD(
-    GLenum /* target */,
-    GLsizei /* samples */,
-    GLsizei /* storageSamples */,
-    GLenum /* internalformat */,
-    GLsizei /* width */,
-    GLsizei /* height */) {}
 void GLES2InterfaceStub::RenderbufferStorageMultisampleEXT(
     GLenum /* target */,
     GLsizei /* samples */,
@@ -859,36 +852,6 @@
 void GLES2InterfaceStub::DispatchCompute(GLuint /* num_groups_x */,
                                          GLuint /* num_groups_y */,
                                          GLuint /* num_groups_z */) {}
-void GLES2InterfaceStub::GetProgramInterfaceiv(GLuint /* program */,
-                                               GLenum /* program_interface */,
-                                               GLenum /* pname */,
-                                               GLint* /* params */) {}
-GLuint GLES2InterfaceStub::GetProgramResourceIndex(
-    GLuint /* program */,
-    GLenum /* program_interface */,
-    const char* /* name */) {
-  return 0;
-}
-void GLES2InterfaceStub::GetProgramResourceName(GLuint /* program */,
-                                                GLenum /* program_interface */,
-                                                GLuint /* index */,
-                                                GLsizei /* bufsize */,
-                                                GLsizei* /* length */,
-                                                char* /* name */) {}
-void GLES2InterfaceStub::GetProgramResourceiv(GLuint /* program */,
-                                              GLenum /* program_interface */,
-                                              GLuint /* index */,
-                                              GLsizei /* prop_count */,
-                                              const GLenum* /* props */,
-                                              GLsizei /* bufsize */,
-                                              GLsizei* /* length */,
-                                              GLint* /* params */) {}
-GLint GLES2InterfaceStub::GetProgramResourceLocation(
-    GLuint /* program */,
-    GLenum /* program_interface */,
-    const char* /* name */) {
-  return 0;
-}
 void GLES2InterfaceStub::MemoryBarrierEXT(GLbitfield /* barriers */) {}
 void GLES2InterfaceStub::MemoryBarrierByRegion(GLbitfield /* barriers */) {}
 void GLES2InterfaceStub::SwapBuffers(GLuint64 /* swap_id */,
@@ -1317,12 +1280,6 @@
     const GLbyte* /* mailbox */) {
   return 0;
 }
-GLuint
-GLES2InterfaceStub::CreateAndTexStorage2DSharedImageWithInternalFormatCHROMIUM(
-    const GLbyte* /* mailbox */,
-    GLenum /* internalformat */) {
-  return 0;
-}
 void GLES2InterfaceStub::BeginSharedImageAccessDirectCHROMIUM(
     GLuint /* texture */,
     GLenum /* mode */) {}
--- a/gpu/command_buffer/client/gles2_trace_implementation_autogen.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/client/gles2_trace_implementation_autogen.h	2019-05-17 18:53:32.956000000 +0300
@@ -579,12 +579,6 @@
                                             GLenum internalformat,
                                             GLsizei width,
                                             GLsizei height) override;
-void RenderbufferStorageMultisampleAdvancedAMD(GLenum target,
-                                               GLsizei samples,
-                                               GLsizei storageSamples,
-                                               GLenum internalformat,
-                                               GLsizei width,
-                                               GLsizei height) override;
 void RenderbufferStorageMultisampleEXT(GLenum target,
                                        GLsizei samples,
                                        GLenum internalformat,
@@ -633,30 +627,6 @@
 void DispatchCompute(GLuint num_groups_x,
                      GLuint num_groups_y,
                      GLuint num_groups_z) override;
-void GetProgramInterfaceiv(GLuint program,
-                           GLenum program_interface,
-                           GLenum pname,
-                           GLint* params) override;
-GLuint GetProgramResourceIndex(GLuint program,
-                               GLenum program_interface,
-                               const char* name) override;
-void GetProgramResourceName(GLuint program,
-                            GLenum program_interface,
-                            GLuint index,
-                            GLsizei bufsize,
-                            GLsizei* length,
-                            char* name) override;
-void GetProgramResourceiv(GLuint program,
-                          GLenum program_interface,
-                          GLuint index,
-                          GLsizei prop_count,
-                          const GLenum* props,
-                          GLsizei bufsize,
-                          GLsizei* length,
-                          GLint* params) override;
-GLint GetProgramResourceLocation(GLuint program,
-                                 GLenum program_interface,
-                                 const char* name) override;
 void MemoryBarrierEXT(GLbitfield barriers) override;
 void MemoryBarrierByRegion(GLbitfield barriers) override;
 void SwapBuffers(GLuint64 swap_id, GLbitfield flags) override;
@@ -989,9 +959,6 @@
                                              GLsizei numViews) override;
 void MaxShaderCompilerThreadsKHR(GLuint count) override;
 GLuint CreateAndTexStorage2DSharedImageCHROMIUM(const GLbyte* mailbox) override;
-GLuint CreateAndTexStorage2DSharedImageWithInternalFormatCHROMIUM(
-    const GLbyte* mailbox,
-    GLenum internalformat) override;
 void BeginSharedImageAccessDirectCHROMIUM(GLuint texture, GLenum mode) override;
 void EndSharedImageAccessDirectCHROMIUM(GLuint texture) override;
 #endif  // GPU_COMMAND_BUFFER_CLIENT_GLES2_TRACE_IMPLEMENTATION_AUTOGEN_H_
--- a/gpu/command_buffer/client/gles2_trace_implementation_impl_autogen.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/client/gles2_trace_implementation_impl_autogen.h	2019-05-17 18:53:32.956000000 +0300
@@ -1651,19 +1651,6 @@
                                               width, height);
 }
 
-void GLES2TraceImplementation::RenderbufferStorageMultisampleAdvancedAMD(
-    GLenum target,
-    GLsizei samples,
-    GLsizei storageSamples,
-    GLenum internalformat,
-    GLsizei width,
-    GLsizei height) {
-  TRACE_EVENT_BINARY_EFFICIENT0(
-      "gpu", "GLES2Trace::RenderbufferStorageMultisampleAdvancedAMD");
-  gl_->RenderbufferStorageMultisampleAdvancedAMD(
-      target, samples, storageSamples, internalformat, width, height);
-}
-
 void GLES2TraceImplementation::RenderbufferStorageMultisampleEXT(
     GLenum target,
     GLsizei samples,
@@ -1843,55 +1830,6 @@
   gl_->DispatchCompute(num_groups_x, num_groups_y, num_groups_z);
 }
 
-void GLES2TraceImplementation::GetProgramInterfaceiv(GLuint program,
-                                                     GLenum program_interface,
-                                                     GLenum pname,
-                                                     GLint* params) {
-  TRACE_EVENT_BINARY_EFFICIENT0("gpu", "GLES2Trace::GetProgramInterfaceiv");
-  gl_->GetProgramInterfaceiv(program, program_interface, pname, params);
-}
-
-GLuint GLES2TraceImplementation::GetProgramResourceIndex(
-    GLuint program,
-    GLenum program_interface,
-    const char* name) {
-  TRACE_EVENT_BINARY_EFFICIENT0("gpu", "GLES2Trace::GetProgramResourceIndex");
-  return gl_->GetProgramResourceIndex(program, program_interface, name);
-}
-
-void GLES2TraceImplementation::GetProgramResourceName(GLuint program,
-                                                      GLenum program_interface,
-                                                      GLuint index,
-                                                      GLsizei bufsize,
-                                                      GLsizei* length,
-                                                      char* name) {
-  TRACE_EVENT_BINARY_EFFICIENT0("gpu", "GLES2Trace::GetProgramResourceName");
-  gl_->GetProgramResourceName(program, program_interface, index, bufsize,
-                              length, name);
-}
-
-void GLES2TraceImplementation::GetProgramResourceiv(GLuint program,
-                                                    GLenum program_interface,
-                                                    GLuint index,
-                                                    GLsizei prop_count,
-                                                    const GLenum* props,
-                                                    GLsizei bufsize,
-                                                    GLsizei* length,
-                                                    GLint* params) {
-  TRACE_EVENT_BINARY_EFFICIENT0("gpu", "GLES2Trace::GetProgramResourceiv");
-  gl_->GetProgramResourceiv(program, program_interface, index, prop_count,
-                            props, bufsize, length, params);
-}
-
-GLint GLES2TraceImplementation::GetProgramResourceLocation(
-    GLuint program,
-    GLenum program_interface,
-    const char* name) {
-  TRACE_EVENT_BINARY_EFFICIENT0("gpu",
-                                "GLES2Trace::GetProgramResourceLocation");
-  return gl_->GetProgramResourceLocation(program, program_interface, name);
-}
-
 void GLES2TraceImplementation::MemoryBarrierEXT(GLbitfield barriers) {
   TRACE_EVENT_BINARY_EFFICIENT0("gpu", "GLES2Trace::MemoryBarrierEXT");
   gl_->MemoryBarrierEXT(barriers);
@@ -2780,17 +2718,6 @@
   return gl_->CreateAndTexStorage2DSharedImageCHROMIUM(mailbox);
 }
 
-GLuint GLES2TraceImplementation::
-    CreateAndTexStorage2DSharedImageWithInternalFormatCHROMIUM(
-        const GLbyte* mailbox,
-        GLenum internalformat) {
-  TRACE_EVENT_BINARY_EFFICIENT0(
-      "gpu",
-      "GLES2Trace::CreateAndTexStorage2DSharedImageWithInternalFormatCHROMIUM");
-  return gl_->CreateAndTexStorage2DSharedImageWithInternalFormatCHROMIUM(
-      mailbox, internalformat);
-}
-
 void GLES2TraceImplementation::BeginSharedImageAccessDirectCHROMIUM(
     GLuint texture,
     GLenum mode) {
--- a/gpu/command_buffer/client/gpu_control_client.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/client/gpu_control_client.h	2019-05-17 18:53:32.956000000 +0300
@@ -7,7 +7,6 @@
 
 #include <cstdint>
 
-#include "base/containers/span.h"
 #include "ui/gfx/presentation_feedback.h"
 
 namespace gpu {
@@ -31,8 +30,6 @@
   virtual void OnSwapBufferPresented(
       uint64_t swap_id,
       const gfx::PresentationFeedback& feedback) = 0;
-  // Sent by the WebGPUDecoder
-  virtual void OnGpuControlReturnData(base::span<const uint8_t> data) = 0;
 };
 
 }  // namespace gpu
--- a/gpu/command_buffer/client/image_decode_accelerator_interface.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/client/image_decode_accelerator_interface.h	2019-05-17 18:53:32.956000000 +0300
@@ -5,8 +5,6 @@
 #ifndef GPU_COMMAND_BUFFER_CLIENT_IMAGE_DECODE_ACCELERATOR_INTERFACE_H_
 #define GPU_COMMAND_BUFFER_CLIENT_IMAGE_DECODE_ACCELERATOR_INTERFACE_H_
 
-#include <stdint.h>
-
 #include "base/containers/span.h"
 #include "gpu/command_buffer/common/command_buffer_id.h"
 #include "gpu/command_buffer/common/sync_token.h"
@@ -24,9 +22,6 @@
  public:
   virtual ~ImageDecodeAcceleratorInterface() {}
 
-  virtual bool IsImageSupported(
-      base::span<const uint8_t> encoded_data) const = 0;
-
   virtual SyncToken ScheduleImageDecode(
       base::span<const uint8_t> encoded_data,
       const gfx::Size& output_size,
@@ -34,7 +29,6 @@
       uint32_t transfer_cache_entry_id,
       int32_t discardable_handle_shm_id,
       uint32_t discardable_handle_shm_offset,
-      uint64_t discardable_handle_release_count,
       const gfx::ColorSpace& target_color_space,
       bool needs_mips) = 0;
 };
--- a/gpu/command_buffer/client/implementation_base.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/client/implementation_base.cc	2019-05-17 18:53:32.956000000 +0300
@@ -6,7 +6,6 @@
 
 #include <algorithm>
 
-#include "base/bind.h"
 #include "base/strings/stringprintf.h"
 #include "base/trace_event/memory_dump_manager.h"
 #include "base/trace_event/trace_event.h"
--- a/gpu/command_buffer/client/mapped_memory_unittest.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/client/mapped_memory_unittest.cc	2019-05-17 18:53:32.956000000 +0300
@@ -16,6 +16,7 @@
 #include "gpu/command_buffer/client/cmd_buffer_helper.h"
 #include "gpu/command_buffer/client/command_buffer_direct_locked.h"
 #include "gpu/command_buffer/service/mocks.h"
+#include "gpu/command_buffer/service/transfer_buffer_manager.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
 namespace gpu {
@@ -33,7 +34,9 @@
   static const unsigned int kBufferSize = 1024;
 
   void SetUp() override {
-    command_buffer_.reset(new CommandBufferDirectLocked());
+    transfer_buffer_manager_ = std::make_unique<TransferBufferManager>(nullptr);
+    command_buffer_.reset(
+        new CommandBufferDirectLocked(transfer_buffer_manager_.get()));
     api_mock_.reset(new AsyncAPIMock(true, command_buffer_->service()));
     command_buffer_->set_handler(api_mock_.get());
 
@@ -52,6 +55,7 @@
 
   int32_t GetToken() { return command_buffer_->GetLastState().token; }
 
+  std::unique_ptr<TransferBufferManager> transfer_buffer_manager_;
   std::unique_ptr<CommandBufferDirectLocked> command_buffer_;
   std::unique_ptr<AsyncAPIMock> api_mock_;
   std::unique_ptr<CommandBufferHelper> helper_;
--- a/gpu/command_buffer/client/mock_transfer_buffer.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/client/mock_transfer_buffer.cc	2019-05-17 18:53:32.956000000 +0300
@@ -48,7 +48,7 @@
   // Just check they match.
   return size_ == starting_buffer_size && result_size_ == result_size &&
          alignment_ == alignment && !initialize_fail_;
-}
+};
 
 int MockTransferBuffer::GetShmId() {
   return buffer_ids_[actual_buffer_index_];
@@ -134,10 +134,6 @@
   return 0;
 }
 
-unsigned int MockTransferBuffer::GetMaxSize() const {
-  return 0;
-}
-
 void MockTransferBuffer::ShrinkLastBlock(unsigned int new_size) {}
 
 uint32_t MockTransferBuffer::MaxTransferBufferSize() {
--- a/gpu/command_buffer/client/mock_transfer_buffer.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/client/mock_transfer_buffer.h	2019-05-17 18:53:32.956000000 +0300
@@ -50,7 +50,6 @@
   unsigned int GetFreeSize() const override;
   unsigned int GetFragmentedFreeSize() const override;
   void ShrinkLastBlock(unsigned int new_size) override;
-  unsigned int GetMaxSize() const override;
 
   uint32_t MaxTransferBufferSize();
   unsigned int RoundToAlignment(unsigned int size);
--- a/gpu/command_buffer/client/program_info_manager.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/client/program_info_manager.cc	2019-05-17 18:53:32.956000000 +0300
@@ -1015,50 +1015,6 @@
   return gl->GetUniformIndicesHelper(program, count, names, indices);
 }
 
-bool ProgramInfoManager::GetProgramInterfaceiv(
-    GLES2Implementation* gl, GLuint program, GLenum program_interface,
-    GLenum pname, GLint* params) {
-  // TODO(jiajie.hu@intel.com): The info is not cached for now, so always
-  // fallback to the IPC path.
-  return false;
-}
-
-GLuint ProgramInfoManager::GetProgramResourceIndex(
-    GLES2Implementation* gl, GLuint program, GLenum program_interface,
-    const char* name) {
-  // TODO(jiajie.hu@intel.com): The info is not cached for now, so always
-  // fallback to the IPC path.
-  return gl->GetProgramResourceIndexHelper(program, program_interface, name);
-}
-
-bool ProgramInfoManager::GetProgramResourceName(
-    GLES2Implementation* gl, GLuint program, GLenum program_interface,
-    GLuint index, GLsizei bufsize, GLsizei* length, char* name) {
-  // TODO(jiajie.hu@intel.com): The info is not cached for now, so always
-  // fallback to the IPC path.
-  return gl->GetProgramResourceNameHelper(
-      program, program_interface, index, bufsize, length, name);
-}
-
-bool ProgramInfoManager::GetProgramResourceiv(
-    GLES2Implementation* gl, GLuint program, GLenum program_interface,
-    GLuint index, GLsizei prop_count, const GLenum* props, GLsizei bufsize,
-    GLsizei* length, GLint* params) {
-  // TODO(jiajie.hu@intel.com): The info is not cached for now, so always
-  // fallback to the IPC path.
-  return gl->GetProgramResourceivHelper(
-      program, program_interface, index, prop_count, props, bufsize, length,
-      params);
-}
-
-GLint ProgramInfoManager::GetProgramResourceLocation(
-    GLES2Implementation* gl, GLuint program, GLenum program_interface,
-    const char* name) {
-  // TODO(jiajie.hu@intel.com): The info is not cached for now, so always
-  // fallback to the IPC path.
-  return gl->GetProgramResourceLocationHelper(program, program_interface, name);
-}
-
 }  // namespace gles2
 }  // namespace gpu
 
--- a/gpu/command_buffer/client/program_info_manager.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/client/program_info_manager.h	2019-05-17 18:53:32.956000000 +0300
@@ -83,27 +83,6 @@
       GLES2Implementation* gl, GLuint program, GLsizei count,
       const GLuint* indices, GLenum pname, GLint* params);
 
-  bool GetProgramInterfaceiv(
-      GLES2Implementation* gl, GLuint program, GLenum program_interface,
-      GLenum pname, GLint* params);
-
-  GLuint GetProgramResourceIndex(
-      GLES2Implementation* gl, GLuint program, GLenum program_interface,
-      const char* name);
-
-  bool GetProgramResourceName(
-      GLES2Implementation* gl, GLuint program, GLenum program_interface,
-      GLuint index, GLsizei bufsize, GLsizei* length, char* name);
-
-  bool GetProgramResourceiv(
-      GLES2Implementation* gl, GLuint program, GLenum program_interface,
-      GLuint index, GLsizei prop_count, const GLenum* props, GLsizei bufsize,
-      GLsizei* length, GLint* params);
-
-  GLint GetProgramResourceLocation(
-      GLES2Implementation* gl, GLuint program, GLenum program_interface,
-      const char* name);
-
  private:
   friend class ProgramInfoManagerTest;
 
--- a/gpu/command_buffer/client/raster_cmd_helper_autogen.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/client/raster_cmd_helper_autogen.h	2019-05-17 18:53:32.960000000 +0300
@@ -87,6 +87,7 @@
 void BeginRasterCHROMIUMImmediate(GLuint sk_color,
                                   GLuint msaa_sample_count,
                                   GLboolean can_use_lcd_text,
+                                  GLuint color_space_transfer_cache_id,
                                   const GLbyte* mailbox) {
   const uint32_t size =
       raster::cmds::BeginRasterCHROMIUMImmediate::ComputeSize();
@@ -94,7 +95,8 @@
       GetImmediateCmdSpaceTotalSize<raster::cmds::BeginRasterCHROMIUMImmediate>(
           size);
   if (c) {
-    c->Init(sk_color, msaa_sample_count, can_use_lcd_text, mailbox);
+    c->Init(sk_color, msaa_sample_count, can_use_lcd_text,
+            color_space_transfer_cache_id, mailbox);
   }
 }
 
--- a/gpu/command_buffer/client/raster_implementation.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/client/raster_implementation.cc	2019-05-17 18:53:32.960000000 +0300
@@ -21,7 +21,6 @@
 #include "base/bind.h"
 #include "base/bits.h"
 #include "base/compiler_specific.h"
-#include "base/metrics/histogram_macros.h"
 #include "base/no_destructor.h"
 #include "base/numerics/safe_math.h"
 #include "base/strings/stringprintf.h"
@@ -30,6 +29,7 @@
 #include "base/trace_event/process_memory_dump.h"
 #include "base/trace_event/trace_event.h"
 #include "build/build_config.h"
+#include "cc/paint/color_space_transfer_cache_entry.h"
 #include "cc/paint/decode_stashing_image_provider.h"
 #include "cc/paint/display_item_list.h"
 #include "cc/paint/paint_cache.h"
@@ -91,21 +91,6 @@
 
 const uint32_t kMaxTransferCacheEntrySizeForTransferBuffer = 1024;
 
-void RecordPaintOpSize(size_t size) {
-  constexpr size_t kMinPaintOpSize = 512 * 1024;
-  constexpr size_t kMaxPaintOpSize = 16 * 1024 * 1024;
-
-  // Serialization failure, record max size.
-  if (size == 0u)
-    size = kMaxPaintOpSize;
-
-  if (size < kMinPaintOpSize)
-    return;
-
-  UMA_HISTOGRAM_CUSTOM_COUNTS("GPU.OopRaster.PaintOpSerializationSize", size,
-                              kMinPaintOpSize, kMaxPaintOpSize, 50);
-}
-
 }  // namespace
 
 // Helper to copy data to the GPU service over the transfer cache.
@@ -204,13 +189,11 @@
                     RasterImplementation* ri,
                     cc::DecodeStashingImageProvider* stashing_image_provider,
                     TransferCacheSerializeHelperImpl* transfer_cache_helper,
-                    ClientFontManager* font_manager,
-                    size_t* max_op_size_hint)
+                    ClientFontManager* font_manager)
       : ri_(ri),
         stashing_image_provider_(stashing_image_provider),
         transfer_cache_helper_(transfer_cache_helper),
-        font_manager_(font_manager),
-        max_op_size_hint_(max_op_size_hint) {
+        font_manager_(font_manager) {
     buffer_ =
         static_cast<char*>(ri_->MapRasterCHROMIUM(initial_size, &free_bytes_));
   }
@@ -224,21 +207,15 @@
                    const cc::PaintOp::SerializeOptions& options) {
     if (!valid())
       return 0;
-
     size_t size = op->Serialize(buffer_ + written_bytes_, free_bytes_, options);
-    size_t block_size = *max_op_size_hint_;
-
     if (!size) {
       // The entries serialized for |op| above will not be transferred since the
       // op will be re-serialized once the buffer is remapped.
       ri_->paint_cache_->AbortPendingEntries();
-      SendSerializedData();
 
-      const unsigned int max_size = ri_->transfer_buffer_->GetMaxSize();
-      DCHECK_LE(block_size, max_size);
-      while (true) {
-        buffer_ = static_cast<char*>(
-            ri_->MapRasterCHROMIUM(block_size, &free_bytes_));
+      SendSerializedData();
+      buffer_ =
+          static_cast<char*>(ri_->MapRasterCHROMIUM(kBlockAlloc, &free_bytes_));
         if (!buffer_) {
           return 0;
         }
@@ -242,29 +219,8 @@
         if (!buffer_) {
           return 0;
         }
-
         size = op->Serialize(buffer_ + written_bytes_, free_bytes_, options);
-        if (size) {
-          *max_op_size_hint_ = std::max(size, *max_op_size_hint_);
-          break;
-        }
-
-        ri_->paint_cache_->AbortPendingEntries();
-        ri_->UnmapRasterCHROMIUM(0u, 0u);
-
-        if (block_size == max_size)
-          break;
-        block_size = std::min(block_size * 2, static_cast<size_t>(max_size));
       }
-
-      if (!size) {
-        RecordPaintOpSize(0u);
-        LOG(ERROR) << "Failed to serialize op in " << block_size << " bytes.";
-        return 0u;
-      }
-    }
-
-    RecordPaintOpSize(size);
     DCHECK_LE(size, free_bytes_);
     DCHECK(base::CheckAdd<uint32_t>(written_bytes_, size).IsValid());
 
@@ -305,6 +261,8 @@
   bool valid() const { return !!buffer_; }
 
  private:
+  static constexpr GLsizeiptr kBlockAlloc = 512 * 1024;
+
   RasterImplementation* const ri_;
   char* buffer_;
   cc::DecodeStashingImageProvider* const stashing_image_provider_;
@@ -314,8 +272,6 @@
   uint32_t written_bytes_ = 0;
   uint32_t free_bytes_ = 0;
 
-  size_t* max_op_size_hint_;
-
   DISALLOW_COPY_AND_ASSIGN(PaintOpSerializer);
 };
 
@@ -428,11 +384,6 @@
   NOTREACHED();
 }
 
-void RasterImplementation::OnGpuControlReturnData(
-    base::span<const uint8_t> data) {
-  NOTIMPLEMENTED();
-}
-
 void RasterImplementation::SetAggressivelyFreeResources(
     bool aggressively_free_resources) {
   TRACE_EVENT1("gpu", "RasterImplementation::SetAggressivelyFreeResources",
@@ -1094,15 +1045,28 @@
     GLuint sk_color,
     GLuint msaa_sample_count,
     GLboolean can_use_lcd_text,
-    const gfx::ColorSpace& color_space,
+    const cc::RasterColorSpace& raster_color_space,
     const GLbyte* mailbox) {
   DCHECK(!raster_properties_);
 
-  helper_->BeginRasterCHROMIUMImmediate(sk_color, msaa_sample_count,
-                                        can_use_lcd_text, mailbox);
+  TransferCacheSerializeHelperImpl transfer_cache_serialize_helper(this);
+  if (!transfer_cache_serialize_helper.LockEntry(
+          cc::TransferCacheEntryType::kColorSpace,
+          raster_color_space.color_space_id)) {
+    transfer_cache_serialize_helper.CreateEntry(
+        cc::ClientColorSpaceTransferCacheEntry(raster_color_space), nullptr);
+  }
+  transfer_cache_serialize_helper.AssertLocked(
+      cc::TransferCacheEntryType::kColorSpace,
+      raster_color_space.color_space_id);
+
+  helper_->BeginRasterCHROMIUMImmediate(
+      sk_color, msaa_sample_count, can_use_lcd_text,
+      raster_color_space.color_space_id, mailbox);
+  transfer_cache_serialize_helper.FlushEntries();
 
   raster_properties_.emplace(sk_color, can_use_lcd_text,
-                             color_space.ToSkColorSpace());
+                             raster_color_space.color_space.ToSkColorSpace());
 }
 
 void RasterImplementation::RasterCHROMIUM(const cc::DisplayItemList* list,
@@ -1112,11 +1076,9 @@
                                           const gfx::Rect& playback_rect,
                                           const gfx::Vector2dF& post_translate,
                                           GLfloat post_scale,
-                                          bool requires_clear,
-                                          size_t* max_op_size_hint) {
+                                          bool requires_clear) {
   TRACE_EVENT1("gpu", "RasterImplementation::RasterCHROMIUM",
                "raster_chromium_id", ++raster_chromium_id_);
-  DCHECK(max_op_size_hint);
 
   if (std::abs(post_scale) < std::numeric_limits<float>::epsilon())
     return;
@@ -1153,7 +1115,7 @@
   TransferCacheSerializeHelperImpl transfer_cache_serialize_helper(this);
   PaintOpSerializer op_serializer(free_size, this, &stashing_image_provider,
                                   &transfer_cache_serialize_helper,
-                                  &font_manager_, max_op_size_hint);
+                                  &font_manager_);
   cc::PaintOpBufferSerializer::SerializeCallback serialize_cb =
       base::BindRepeating(&PaintOpSerializer::Serialize,
                           base::Unretained(&op_serializer));
@@ -1161,7 +1123,8 @@
   cc::PaintOpBufferSerializer serializer(
       serialize_cb, &stashing_image_provider, &transfer_cache_serialize_helper,
       GetOrCreatePaintCache(), font_manager_.strike_server(),
-      raster_properties_->color_space, raster_properties_->can_use_lcd_text,
+      raster_properties_->color_space.get(),
+      raster_properties_->can_use_lcd_text,
       capabilities().context_supports_distance_field_text,
       capabilities().max_texture_size,
       capabilities().glyph_cache_max_texture_bytes);
@@ -1183,11 +1146,6 @@
     FlushPaintCachePurgedEntries();
 }
 
-bool RasterImplementation::CanDecodeWithHardwareAcceleration(
-    base::span<const uint8_t> encoded_data) {
-  return image_decode_accelerator_->IsImageSupported(encoded_data);
-}
-
 SyncToken RasterImplementation::ScheduleImageDecode(
     base::span<const uint8_t> encoded_data,
     const gfx::Size& output_size,
@@ -1219,15 +1177,11 @@
   DCHECK(image_decode_accelerator_);
   DCHECK(handle.IsValid());
 
-  // Insert a sync token to signal that |handle|'s buffer has been registered.
-  SyncToken sync_token;
-  GenUnverifiedSyncTokenCHROMIUM(sync_token.GetData());
-
   // Send the decode request to the service.
   *decode_sync_token = image_decode_accelerator_->ScheduleImageDecode(
       encoded_data, output_size, gpu_control_->GetCommandBufferID(),
       transfer_cache_entry_id, handle.shm_id(), handle.byte_offset(),
-      sync_token.release_count(), target_color_space, needs_mips);
+      target_color_space, needs_mips);
 }
 
 GLuint RasterImplementation::CreateAndConsumeForGpuRaster(
--- a/gpu/command_buffer/client/raster_implementation_gles.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/client/raster_implementation_gles.cc	2019-05-17 18:53:32.960000000 +0300
@@ -12,6 +12,7 @@
 #include <vector>
 
 #include "base/logging.h"
+#include "cc/paint/color_space_transfer_cache_entry.h"
 #include "cc/paint/decode_stashing_image_provider.h"
 #include "cc/paint/display_item_list.h"  // nogncheck
 #include "cc/paint/paint_op_buffer_serializer.h"
@@ -127,7 +128,7 @@
     GLuint sk_color,
     GLuint msaa_sample_count,
     GLboolean can_use_lcd_text,
-    const gfx::ColorSpace& color_space,
+    const cc::RasterColorSpace& raster_color_space,
     const GLbyte* mailbox) {
   NOTREACHED();
 }
@@ -140,8 +141,7 @@
     const gfx::Rect& playback_rect,
     const gfx::Vector2dF& post_translate,
     GLfloat post_scale,
-    bool requires_clear,
-    size_t* max_op_size_hint) {
+    bool requires_clear) {
   NOTREACHED();
 }
 
@@ -153,12 +153,6 @@
   NOTREACHED();
 }
 
-bool RasterImplementationGLES::CanDecodeWithHardwareAcceleration(
-    base::span<const uint8_t> encoded_data) {
-  NOTREACHED();
-  return false;
-}
-
 SyncToken RasterImplementationGLES::ScheduleImageDecode(
     base::span<const uint8_t> encoded_data,
     const gfx::Size& output_size,
--- a/gpu/command_buffer/client/raster_implementation_gles.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/client/raster_implementation_gles.h	2019-05-17 18:53:32.960000000 +0300
@@ -65,7 +65,7 @@
   void BeginRasterCHROMIUM(GLuint sk_color,
                            GLuint msaa_sample_count,
                            GLboolean can_use_lcd_text,
-                           const gfx::ColorSpace& color_space,
+                           const cc::RasterColorSpace& raster_color_space,
                            const GLbyte* mailbox) override;
   void RasterCHROMIUM(const cc::DisplayItemList* list,
                       cc::ImageProvider* provider,
@@ -74,13 +74,10 @@
                       const gfx::Rect& playback_rect,
                       const gfx::Vector2dF& post_translate,
                       GLfloat post_scale,
-                      bool requires_clear,
-                      size_t* max_op_size_hint) override;
+                      bool requires_clear) override;
   void EndRasterCHROMIUM() override;
 
   // Image decode acceleration.
-  bool CanDecodeWithHardwareAcceleration(
-      base::span<const uint8_t> encoded_data) override;
   SyncToken ScheduleImageDecode(base::span<const uint8_t> encoded_data,
                                 const gfx::Size& output_size,
                                 uint32_t transfer_cache_entry_id,
--- a/gpu/command_buffer/client/raster_implementation_gles_unittest.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/client/raster_implementation_gles_unittest.cc	2019-05-17 18:53:32.960000000 +0300
@@ -13,6 +13,7 @@
 #include <vector>
 
 #include "base/containers/flat_map.h"
+#include "cc/paint/color_space_transfer_cache_entry.h"
 #include "cc/paint/display_item_list.h"
 #include "cc/paint/image_provider.h"
 #include "components/viz/common/resources/resource_format_utils.h"
@@ -232,8 +233,9 @@
 class ImageProviderStub : public cc::ImageProvider {
  public:
   ~ImageProviderStub() override {}
-  ScopedResult GetRasterContent(const cc::DrawImage& draw_image) override {
-    return ScopedResult();
+  ScopedDecodedDrawImage GetDecodedDrawImage(
+      const cc::DrawImage& draw_image) override {
+    return ScopedDecodedDrawImage();
   }
 };
 
--- a/gpu/command_buffer/client/raster_implementation.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/client/raster_implementation.h	2019-05-17 18:53:32.960000000 +0300
@@ -124,7 +124,7 @@
   void BeginRasterCHROMIUM(GLuint sk_color,
                            GLuint msaa_sample_count,
                            GLboolean can_use_lcd_text,
-                           const gfx::ColorSpace& color_space,
+                           const cc::RasterColorSpace& raster_color_space,
                            const GLbyte* mailbox) override;
   void RasterCHROMIUM(const cc::DisplayItemList* list,
                       cc::ImageProvider* provider,
@@ -133,10 +133,7 @@
                       const gfx::Rect& playback_rect,
                       const gfx::Vector2dF& post_translate,
                       GLfloat post_scale,
-                      bool requires_clear,
-                      size_t* max_op_size_hint) override;
-  bool CanDecodeWithHardwareAcceleration(
-      base::span<const uint8_t> encoded_data) override;
+                      bool requires_clear) override;
   SyncToken ScheduleImageDecode(base::span<const uint8_t> encoded_data,
                                 const gfx::Size& output_size,
                                 uint32_t transfer_cache_entry_id,
@@ -236,7 +233,6 @@
       const SwapBuffersCompleteParams& params) final;
   void OnSwapBufferPresented(uint64_t swap_id,
                              const gfx::PresentationFeedback& feedback) final;
-  void OnGpuControlReturnData(base::span<const uint8_t> data) final;
 
   // Gets the GLError through our wrapper.
   GLenum GetGLError();
--- a/gpu/command_buffer/client/raster_implementation_unittest.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/client/raster_implementation_unittest.cc	2019-05-17 18:53:32.960000000 +0300
@@ -14,7 +14,6 @@
 
 #include <memory>
 
-#include "base/bind.h"
 #include "base/compiler_specific.h"
 #include "base/stl_util.h"
 #include "cc/paint/raw_memory_transfer_cache_entry.h"
--- a/gpu/command_buffer/client/raster_interface.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/client/raster_interface.h	2019-05-17 18:53:32.960000000 +0300
@@ -14,6 +14,7 @@
 namespace cc {
 class DisplayItemList;
 class ImageProvider;
+struct RasterColorSpace;
 }  // namespace cc
 
 namespace gfx {
@@ -50,13 +51,12 @@
                               GLsizei width,
                               GLsizei height) = 0;
   // OOP-Raster
-  virtual void BeginRasterCHROMIUM(GLuint sk_color,
+  virtual void BeginRasterCHROMIUM(
+      GLuint sk_color,
                                    GLuint msaa_sample_count,
                                    GLboolean can_use_lcd_text,
-                                   const gfx::ColorSpace& color_space,
+      const cc::RasterColorSpace& raster_color_space,
                                    const GLbyte* mailbox) = 0;
-
-  static constexpr size_t kDefaultMaxOpSizeHint = 512 * 1024;
   virtual void RasterCHROMIUM(const cc::DisplayItemList* list,
                               cc::ImageProvider* provider,
                               const gfx::Size& content_size,
@@ -64,14 +64,7 @@
                               const gfx::Rect& playback_rect,
                               const gfx::Vector2dF& post_translate,
                               GLfloat post_scale,
-                              bool requires_clear,
-                              size_t* max_op_size_hint) = 0;
-
-  // Determines if an encoded image can be decoded using hardware decode
-  // acceleration. If this method returns true, then the client can be confident
-  // that a call to ScheduleImageDecode() will succeed.
-  virtual bool CanDecodeWithHardwareAcceleration(
-      base::span<const uint8_t> encoded_data) = 0;
+                              bool requires_clear) = 0;
 
   // Schedules a hardware-accelerated image decode and a sync token that's
   // released when the image decode is complete. If the decode could not be
--- a/gpu/command_buffer/client/ring_buffer_test.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/client/ring_buffer_test.cc	2019-05-17 18:53:32.964000000 +0300
@@ -17,6 +17,7 @@
 #include "gpu/command_buffer/client/cmd_buffer_helper.h"
 #include "gpu/command_buffer/service/command_buffer_direct.h"
 #include "gpu/command_buffer/service/mocks.h"
+#include "gpu/command_buffer/service/transfer_buffer_manager.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
 namespace gpu {
@@ -58,7 +59,9 @@
 
   void SetUp() override {
     delay_set_token_ = false;
-    command_buffer_.reset(new CommandBufferDirect());
+    transfer_buffer_manager_ = std::make_unique<TransferBufferManager>(nullptr);
+    command_buffer_.reset(
+        new CommandBufferDirect(transfer_buffer_manager_.get()));
     api_mock_.reset(new AsyncAPIMock(true, command_buffer_->service()));
     command_buffer_->set_handler(api_mock_.get());
 
@@ -77,6 +80,7 @@
 
   int32_t GetToken() { return command_buffer_->GetLastState().token; }
 
+  std::unique_ptr<TransferBufferManager> transfer_buffer_manager_;
   std::unique_ptr<CommandBufferDirect> command_buffer_;
   std::unique_ptr<AsyncAPIMock> api_mock_;
   std::unique_ptr<CommandBufferHelper> helper_;
--- a/gpu/command_buffer/client/transfer_buffer.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/client/transfer_buffer.cc	2019-05-17 18:53:32.964000000 +0300
@@ -105,10 +105,6 @@
   ring_buffer_->ShrinkLastBlock(new_size);
 }
 
-unsigned int TransferBuffer::GetMaxSize() const {
-  return max_buffer_size_ - result_size_;
-}
-
 void TransferBuffer::AllocateRingBuffer(unsigned int size) {
   for (;size >= min_buffer_size_; size /= 2) {
     int32_t id = -1;
@@ -275,6 +271,10 @@
   return HaveBuffer() ? ring_buffer_->GetLargestFreeOrPendingSize() : 0;
 }
 
+unsigned int TransferBuffer::GetMaxAllocation() const {
+  return HaveBuffer() ? max_buffer_size_ - result_size_ : 0;
+}
+
 ScopedTransferBufferPtr::ScopedTransferBufferPtr(
     ScopedTransferBufferPtr&& other)
     : buffer_(other.buffer_),
--- a/gpu/command_buffer/client/transfer_buffer.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/client/transfer_buffer.h	2019-05-17 18:53:32.964000000 +0300
@@ -67,8 +67,6 @@
 
   virtual void ShrinkLastBlock(unsigned int new_size) = 0;
 
-  virtual unsigned int GetMaxSize() const = 0;
-
  protected:
   template <typename>
   friend class ScopedResultPtr;
@@ -109,10 +107,10 @@
   unsigned int GetFreeSize() const override;
   unsigned int GetFragmentedFreeSize() const override;
   void ShrinkLastBlock(unsigned int new_size) override;
-  unsigned int GetMaxSize() const override;
 
   // These are for testing.
   unsigned int GetCurrentMaxAllocationWithoutRealloc() const;
+  unsigned int GetMaxAllocation() const;
 
   // We will attempt to shrink the ring buffer once the number of bytes
   // allocated reaches this threshold times the high water mark.
@@ -286,7 +284,7 @@
     other.result_ = nullptr;
     other.transfer_buffer_ = nullptr;
     return *this;
-  }
+  };
 
   // Dereferencing behaviors
   T& operator*() const { return *result_; }
--- a/gpu/command_buffer/client/webgpu_implementation.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/client/webgpu_implementation.cc	2019-05-17 18:53:32.968000000 +0300
@@ -4,11 +4,6 @@
 
 #include "gpu/command_buffer/client/webgpu_implementation.h"
 
-#include <vector>
-
-#include "gpu/command_buffer/client/gpu_control.h"
-#include "gpu/command_buffer/client/shared_memory_limits.h"
-
 #define GPU_CLIENT_SINGLE_THREAD_CHECK()
 
 namespace gpu {
@@ -19,140 +14,6 @@
 // instead of having to edit some template or the code generator.
 #include "gpu/command_buffer/client/webgpu_implementation_impl_autogen.h"
 
-WebGPUImplementation::WebGPUImplementation(
-    WebGPUCmdHelper* helper,
-    TransferBufferInterface* transfer_buffer,
-    GpuControl* gpu_control)
-    : ImplementationBase(helper, transfer_buffer, gpu_control),
-      helper_(helper) {}
-
-WebGPUImplementation::~WebGPUImplementation() {}
-
-gpu::ContextResult WebGPUImplementation::Initialize(
-    const SharedMemoryLimits& limits) {
-  TRACE_EVENT0("gpu", "WebGPUImplementation::Initialize");
-  return ImplementationBase::Initialize(limits);
-}
-
-// ContextSupport implementation.
-void WebGPUImplementation::SetAggressivelyFreeResources(
-    bool aggressively_free_resources) {
-  NOTIMPLEMENTED();
-}
-void WebGPUImplementation::Swap(uint32_t flags,
-                                SwapCompletedCallback complete_callback,
-                                PresentationCallback presentation_callback) {
-  NOTIMPLEMENTED();
-}
-void WebGPUImplementation::SwapWithBounds(
-    const std::vector<gfx::Rect>& rects,
-    uint32_t flags,
-    SwapCompletedCallback swap_completed,
-    PresentationCallback presentation_callback) {
-  NOTIMPLEMENTED();
-}
-void WebGPUImplementation::PartialSwapBuffers(
-    const gfx::Rect& sub_buffer,
-    uint32_t flags,
-    SwapCompletedCallback swap_completed,
-    PresentationCallback presentation_callback) {
-  NOTIMPLEMENTED();
-}
-void WebGPUImplementation::CommitOverlayPlanes(
-    uint32_t flags,
-    SwapCompletedCallback swap_completed,
-    PresentationCallback presentation_callback) {
-  NOTREACHED();
-}
-void WebGPUImplementation::ScheduleOverlayPlane(
-    int plane_z_order,
-    gfx::OverlayTransform plane_transform,
-    unsigned overlay_texture_id,
-    const gfx::Rect& display_bounds,
-    const gfx::RectF& uv_rect,
-    bool enable_blend,
-    unsigned gpu_fence_id) {
-  NOTREACHED();
-}
-uint64_t WebGPUImplementation::ShareGroupTracingGUID() const {
-  NOTIMPLEMENTED();
-  return 0;
-}
-void WebGPUImplementation::SetErrorMessageCallback(
-    base::RepeatingCallback<void(const char*, int32_t)> callback) {
-  NOTIMPLEMENTED();
-}
-bool WebGPUImplementation::ThreadSafeShallowLockDiscardableTexture(
-    uint32_t texture_id) {
-  NOTREACHED();
-  return false;
-}
-void WebGPUImplementation::CompleteLockDiscardableTexureOnContextThread(
-    uint32_t texture_id) {
-  NOTREACHED();
-}
-bool WebGPUImplementation::ThreadsafeDiscardableTextureIsDeletedForTracing(
-    uint32_t texture_id) {
-  NOTREACHED();
-  return false;
-}
-void* WebGPUImplementation::MapTransferCacheEntry(uint32_t serialized_size) {
-  NOTREACHED();
-  return nullptr;
-}
-void WebGPUImplementation::UnmapAndCreateTransferCacheEntry(uint32_t type,
-                                                            uint32_t id) {
-  NOTREACHED();
-}
-bool WebGPUImplementation::ThreadsafeLockTransferCacheEntry(uint32_t type,
-                                                            uint32_t id) {
-  NOTREACHED();
-  return false;
-}
-void WebGPUImplementation::UnlockTransferCacheEntries(
-    const std::vector<std::pair<uint32_t, uint32_t>>& entries) {
-  NOTREACHED();
-}
-void WebGPUImplementation::DeleteTransferCacheEntry(uint32_t type,
-                                                    uint32_t id) {
-  NOTREACHED();
-}
-unsigned int WebGPUImplementation::GetTransferBufferFreeSize() const {
-  NOTREACHED();
-  return 0;
-}
-
-// ImplementationBase implementation.
-void WebGPUImplementation::IssueShallowFlush() {
-  NOTIMPLEMENTED();
-}
-
-// GpuControlClient implementation.
-void WebGPUImplementation::OnGpuControlLostContext() {
-  NOTIMPLEMENTED();
-}
-void WebGPUImplementation::OnGpuControlLostContextMaybeReentrant() {
-  NOTIMPLEMENTED();
-}
-void WebGPUImplementation::OnGpuControlErrorMessage(const char* message,
-                                                    int32_t id) {
-  NOTIMPLEMENTED();
-}
-void WebGPUImplementation::OnGpuControlSwapBuffersCompleted(
-    const SwapBuffersCompleteParams& params) {
-  NOTIMPLEMENTED();
-}
-void WebGPUImplementation::OnSwapBufferPresented(
-    uint64_t swap_id,
-    const gfx::PresentationFeedback& feedback) {
-  NOTIMPLEMENTED();
-}
-void WebGPUImplementation::OnGpuControlReturnData(
-    base::span<const uint8_t> data) {
-  // TODO: Handle return commands
-  NOTIMPLEMENTED();
-}
-
 void WebGPUImplementation::Dummy() {
   GPU_CLIENT_SINGLE_THREAD_CHECK();
   GPU_CLIENT_LOG("[" << GetLogPrefix() << "] wgDummy()");
--- a/gpu/command_buffer/client/webgpu_implementation.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/client/webgpu_implementation.h	2019-05-17 18:53:32.968000000 +0300
@@ -5,13 +5,8 @@
 #ifndef GPU_COMMAND_BUFFER_CLIENT_WEBGPU_IMPLEMENTATION_H_
 #define GPU_COMMAND_BUFFER_CLIENT_WEBGPU_IMPLEMENTATION_H_
 
-#include <utility>
-#include <vector>
-
-#include "gpu/command_buffer/client/gpu_control_client.h"
 #include "gpu/command_buffer/client/implementation_base.h"
 #include "gpu/command_buffer/client/logging.h"
-#include "gpu/command_buffer/client/transfer_buffer.h"
 #include "gpu/command_buffer/client/webgpu_cmd_helper.h"
 #include "gpu/command_buffer/client/webgpu_export.h"
 #include "gpu/command_buffer/client/webgpu_interface.h"
@@ -19,73 +14,16 @@
 namespace gpu {
 namespace webgpu {
 
-class WEBGPU_EXPORT WebGPUImplementation final : public WebGPUInterface,
-                                                 public ImplementationBase {
+class WEBGPU_EXPORT WebGPUImplementation final : public WebGPUInterface {
  public:
-  explicit WebGPUImplementation(WebGPUCmdHelper* helper,
-                                TransferBufferInterface* transfer_buffer,
-                                GpuControl* gpu_control);
-  ~WebGPUImplementation() override;
-
-  gpu::ContextResult Initialize(const SharedMemoryLimits& limits);
+  explicit WebGPUImplementation(WebGPUCmdHelper* helper) : helper_(helper) {}
+  ~WebGPUImplementation() override {}
 
 // Include the auto-generated part of this class. We split this because
 // it means we can easily edit the non-auto generated parts right here in
 // this file instead of having to edit some template or the code generator.
 #include "gpu/command_buffer/client/webgpu_implementation_autogen.h"
 
-  // ContextSupport implementation.
-  void SetAggressivelyFreeResources(bool aggressively_free_resources) override;
-  void Swap(uint32_t flags,
-            SwapCompletedCallback complete_callback,
-            PresentationCallback presentation_callback) override;
-  void SwapWithBounds(const std::vector<gfx::Rect>& rects,
-                      uint32_t flags,
-                      SwapCompletedCallback swap_completed,
-                      PresentationCallback presentation_callback) override;
-  void PartialSwapBuffers(const gfx::Rect& sub_buffer,
-                          uint32_t flags,
-                          SwapCompletedCallback swap_completed,
-                          PresentationCallback presentation_callback) override;
-  void CommitOverlayPlanes(uint32_t flags,
-                           SwapCompletedCallback swap_completed,
-                           PresentationCallback presentation_callback) override;
-  void ScheduleOverlayPlane(int plane_z_order,
-                            gfx::OverlayTransform plane_transform,
-                            unsigned overlay_texture_id,
-                            const gfx::Rect& display_bounds,
-                            const gfx::RectF& uv_rect,
-                            bool enable_blend,
-                            unsigned gpu_fence_id) override;
-  uint64_t ShareGroupTracingGUID() const override;
-  void SetErrorMessageCallback(
-      base::RepeatingCallback<void(const char*, int32_t)> callback) override;
-  bool ThreadSafeShallowLockDiscardableTexture(uint32_t texture_id) override;
-  void CompleteLockDiscardableTexureOnContextThread(
-      uint32_t texture_id) override;
-  bool ThreadsafeDiscardableTextureIsDeletedForTracing(
-      uint32_t texture_id) override;
-  void* MapTransferCacheEntry(uint32_t serialized_size) override;
-  void UnmapAndCreateTransferCacheEntry(uint32_t type, uint32_t id) override;
-  bool ThreadsafeLockTransferCacheEntry(uint32_t type, uint32_t id) override;
-  void UnlockTransferCacheEntries(
-      const std::vector<std::pair<uint32_t, uint32_t>>& entries) override;
-  void DeleteTransferCacheEntry(uint32_t type, uint32_t id) override;
-  unsigned int GetTransferBufferFreeSize() const override;
-
-  // ImplementationBase implementation.
-  void IssueShallowFlush() override;
-
-  // GpuControlClient implementation.
-  void OnGpuControlLostContext() final;
-  void OnGpuControlLostContextMaybeReentrant() final;
-  void OnGpuControlErrorMessage(const char* message, int32_t id) final;
-  void OnGpuControlSwapBuffersCompleted(
-      const SwapBuffersCompleteParams& params) final;
-  void OnSwapBufferPresented(uint64_t swap_id,
-                             const gfx::PresentationFeedback& feedback) final;
-  void OnGpuControlReturnData(base::span<const uint8_t> data) final;
-
  private:
   const char* GetLogPrefix() const { return "webgpu"; }
 
--- a/gpu/command_buffer/client/webgpu_implementation_unittest.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/client/webgpu_implementation_unittest.cc	2019-05-17 18:53:32.968000000 +0300
@@ -54,24 +54,13 @@
 
     helper_.reset(new WebGPUCmdHelper(command_buffer_.get()));
     helper_->Initialize(limits.command_buffer_size);
-    gpu_control_.reset(new StrictMock<MockClientGpuControl>());
-
-    EXPECT_CALL(*gpu_control_, GetCapabilities())
-        .WillOnce(ReturnRef(capabilities_));
 
     {
       InSequence sequence;
 
-      gl_.reset(new WebGPUImplementation(helper_.get(), transfer_buffer_.get(),
-                                         gpu_control_.get()));
+      gl_.reset(new WebGPUImplementation(helper_.get()));
     }
 
-    // The client should be set to something non-null.
-    EXPECT_CALL(*gpu_control_, SetGpuControlClient(gl_.get())).Times(1);
-
-    if (gl_->Initialize(limits) != gpu::ContextResult::kSuccess)
-      return false;
-
     helper_->CommandBufferHelper::Finish();
     Mock::VerifyAndClearExpectations(gl_.get());
 
@@ -98,7 +87,6 @@
     // For command buffer.
     EXPECT_CALL(*command_buffer_, DestroyTransferBuffer(_)).Times(AtLeast(1));
     // The client should be unset.
-    EXPECT_CALL(*gpu_control_, SetGpuControlClient(nullptr)).Times(1);
     gl_.reset();
   }
 
@@ -113,12 +101,10 @@
   }
 
   std::unique_ptr<MockClientCommandBuffer> command_buffer_;
-  std::unique_ptr<MockClientGpuControl> gpu_control_;
   std::unique_ptr<WebGPUCmdHelper> helper_;
   std::unique_ptr<MockTransferBuffer> transfer_buffer_;
   std::unique_ptr<WebGPUImplementation> gl_;
   CommandBufferEntry* commands_ = nullptr;
-  Capabilities capabilities_;
 };
 
 #include "base/macros.h"
--- a/gpu/command_buffer/common/constants.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/common/constants.h	2019-05-17 18:53:32.968000000 +0300
@@ -76,8 +76,7 @@
 
   GPU_IO,
   IN_PROCESS,
-  VIZ_SKIA_OUTPUT_SURFACE,
-  VIZ_SKIA_OUTPUT_SURFACE_NON_DDL,
+  VIZ_OUTPUT_SURFACE,
 
   NUM_COMMAND_BUFFER_NAMESPACES
 };
--- a/gpu/command_buffer/common/context_creation_attribs.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/common/context_creation_attribs.h	2019-05-17 18:53:32.968000000 +0300
@@ -65,7 +65,6 @@
   bool enable_raster_interface = false;
   bool enable_oop_rasterization = false;
   bool enable_swap_timestamps_if_supported = false;
-  bool backed_by_surface_texture = false;
 
   ContextType context_type = CONTEXT_TYPE_OPENGLES2;
   ColorSpace color_space = COLOR_SPACE_UNSPECIFIED;
--- a/gpu/command_buffer/common/gles2_cmd_format_autogen.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/common/gles2_cmd_format_autogen.h	2019-05-17 18:53:32.972000000 +0300
@@ -11349,81 +11349,6 @@
     offsetof(RenderbufferStorageMultisampleCHROMIUM, height) == 20,
     "offset of RenderbufferStorageMultisampleCHROMIUM height should be 20");
 
-// GL_AMD_framebuffer_multisample_advanced
-struct RenderbufferStorageMultisampleAdvancedAMD {
-  typedef RenderbufferStorageMultisampleAdvancedAMD ValueType;
-  static const CommandId kCmdId = kRenderbufferStorageMultisampleAdvancedAMD;
-  static const cmd::ArgFlags kArgFlags = cmd::kFixed;
-  static const uint8_t cmd_flags = CMD_FLAG_SET_TRACE_LEVEL(1);
-
-  static uint32_t ComputeSize() {
-    return static_cast<uint32_t>(sizeof(ValueType));  // NOLINT
-  }
-
-  void SetHeader() { header.SetCmd<ValueType>(); }
-
-  void Init(GLenum _target,
-            GLsizei _samples,
-            GLsizei _storageSamples,
-            GLenum _internalformat,
-            GLsizei _width,
-            GLsizei _height) {
-    SetHeader();
-    target = _target;
-    samples = _samples;
-    storageSamples = _storageSamples;
-    internalformat = _internalformat;
-    width = _width;
-    height = _height;
-  }
-
-  void* Set(void* cmd,
-            GLenum _target,
-            GLsizei _samples,
-            GLsizei _storageSamples,
-            GLenum _internalformat,
-            GLsizei _width,
-            GLsizei _height) {
-    static_cast<ValueType*>(cmd)->Init(_target, _samples, _storageSamples,
-                                       _internalformat, _width, _height);
-    return NextCmdAddress<ValueType>(cmd);
-  }
-
-  gpu::CommandHeader header;
-  uint32_t target;
-  int32_t samples;
-  int32_t storageSamples;
-  uint32_t internalformat;
-  int32_t width;
-  int32_t height;
-};
-
-static_assert(sizeof(RenderbufferStorageMultisampleAdvancedAMD) == 28,
-              "size of RenderbufferStorageMultisampleAdvancedAMD should be 28");
-static_assert(
-    offsetof(RenderbufferStorageMultisampleAdvancedAMD, header) == 0,
-    "offset of RenderbufferStorageMultisampleAdvancedAMD header should be 0");
-static_assert(
-    offsetof(RenderbufferStorageMultisampleAdvancedAMD, target) == 4,
-    "offset of RenderbufferStorageMultisampleAdvancedAMD target should be 4");
-static_assert(
-    offsetof(RenderbufferStorageMultisampleAdvancedAMD, samples) == 8,
-    "offset of RenderbufferStorageMultisampleAdvancedAMD samples should be 8");
-static_assert(offsetof(RenderbufferStorageMultisampleAdvancedAMD,
-                       storageSamples) == 12,
-              "offset of RenderbufferStorageMultisampleAdvancedAMD "
-              "storageSamples should be 12");
-static_assert(offsetof(RenderbufferStorageMultisampleAdvancedAMD,
-                       internalformat) == 16,
-              "offset of RenderbufferStorageMultisampleAdvancedAMD "
-              "internalformat should be 16");
-static_assert(
-    offsetof(RenderbufferStorageMultisampleAdvancedAMD, width) == 20,
-    "offset of RenderbufferStorageMultisampleAdvancedAMD width should be 20");
-static_assert(
-    offsetof(RenderbufferStorageMultisampleAdvancedAMD, height) == 24,
-    "offset of RenderbufferStorageMultisampleAdvancedAMD height should be 24");
-
 // GL_EXT_multisampled_render_to_texture
 struct RenderbufferStorageMultisampleEXT {
   typedef RenderbufferStorageMultisampleEXT ValueType;
@@ -12368,334 +12293,6 @@
 static_assert(offsetof(DispatchCompute, num_groups_z) == 12,
               "offset of DispatchCompute num_groups_z should be 12");
 
-struct GetProgramInterfaceiv {
-  typedef GetProgramInterfaceiv ValueType;
-  static const CommandId kCmdId = kGetProgramInterfaceiv;
-  static const cmd::ArgFlags kArgFlags = cmd::kFixed;
-  static const uint8_t cmd_flags = CMD_FLAG_SET_TRACE_LEVEL(2);
-
-  typedef SizedResult<GLint> Result;
-
-  static uint32_t ComputeSize() {
-    return static_cast<uint32_t>(sizeof(ValueType));  // NOLINT
-  }
-
-  void SetHeader() { header.SetCmd<ValueType>(); }
-
-  void Init(GLuint _program,
-            GLenum _program_interface,
-            GLenum _pname,
-            uint32_t _params_shm_id,
-            uint32_t _params_shm_offset) {
-    SetHeader();
-    program = _program;
-    program_interface = _program_interface;
-    pname = _pname;
-    params_shm_id = _params_shm_id;
-    params_shm_offset = _params_shm_offset;
-  }
-
-  void* Set(void* cmd,
-            GLuint _program,
-            GLenum _program_interface,
-            GLenum _pname,
-            uint32_t _params_shm_id,
-            uint32_t _params_shm_offset) {
-    static_cast<ValueType*>(cmd)->Init(_program, _program_interface, _pname,
-                                       _params_shm_id, _params_shm_offset);
-    return NextCmdAddress<ValueType>(cmd);
-  }
-
-  gpu::CommandHeader header;
-  uint32_t program;
-  uint32_t program_interface;
-  uint32_t pname;
-  uint32_t params_shm_id;
-  uint32_t params_shm_offset;
-};
-
-static_assert(sizeof(GetProgramInterfaceiv) == 24,
-              "size of GetProgramInterfaceiv should be 24");
-static_assert(offsetof(GetProgramInterfaceiv, header) == 0,
-              "offset of GetProgramInterfaceiv header should be 0");
-static_assert(offsetof(GetProgramInterfaceiv, program) == 4,
-              "offset of GetProgramInterfaceiv program should be 4");
-static_assert(offsetof(GetProgramInterfaceiv, program_interface) == 8,
-              "offset of GetProgramInterfaceiv program_interface should be 8");
-static_assert(offsetof(GetProgramInterfaceiv, pname) == 12,
-              "offset of GetProgramInterfaceiv pname should be 12");
-static_assert(offsetof(GetProgramInterfaceiv, params_shm_id) == 16,
-              "offset of GetProgramInterfaceiv params_shm_id should be 16");
-static_assert(offsetof(GetProgramInterfaceiv, params_shm_offset) == 20,
-              "offset of GetProgramInterfaceiv params_shm_offset should be 20");
-
-struct GetProgramResourceIndex {
-  typedef GetProgramResourceIndex ValueType;
-  static const CommandId kCmdId = kGetProgramResourceIndex;
-  static const cmd::ArgFlags kArgFlags = cmd::kFixed;
-  static const uint8_t cmd_flags = CMD_FLAG_SET_TRACE_LEVEL(2);
-
-  typedef GLuint Result;
-
-  static uint32_t ComputeSize() {
-    return static_cast<uint32_t>(sizeof(ValueType));  // NOLINT
-  }
-
-  void SetHeader() { header.SetCmd<ValueType>(); }
-
-  void Init(GLuint _program,
-            GLenum _program_interface,
-            uint32_t _name_bucket_id,
-            uint32_t _index_shm_id,
-            uint32_t _index_shm_offset) {
-    SetHeader();
-    program = _program;
-    program_interface = _program_interface;
-    name_bucket_id = _name_bucket_id;
-    index_shm_id = _index_shm_id;
-    index_shm_offset = _index_shm_offset;
-  }
-
-  void* Set(void* cmd,
-            GLuint _program,
-            GLenum _program_interface,
-            uint32_t _name_bucket_id,
-            uint32_t _index_shm_id,
-            uint32_t _index_shm_offset) {
-    static_cast<ValueType*>(cmd)->Init(_program, _program_interface,
-                                       _name_bucket_id, _index_shm_id,
-                                       _index_shm_offset);
-    return NextCmdAddress<ValueType>(cmd);
-  }
-
-  gpu::CommandHeader header;
-  uint32_t program;
-  uint32_t program_interface;
-  uint32_t name_bucket_id;
-  uint32_t index_shm_id;
-  uint32_t index_shm_offset;
-};
-
-static_assert(sizeof(GetProgramResourceIndex) == 24,
-              "size of GetProgramResourceIndex should be 24");
-static_assert(offsetof(GetProgramResourceIndex, header) == 0,
-              "offset of GetProgramResourceIndex header should be 0");
-static_assert(offsetof(GetProgramResourceIndex, program) == 4,
-              "offset of GetProgramResourceIndex program should be 4");
-static_assert(
-    offsetof(GetProgramResourceIndex, program_interface) == 8,
-    "offset of GetProgramResourceIndex program_interface should be 8");
-static_assert(offsetof(GetProgramResourceIndex, name_bucket_id) == 12,
-              "offset of GetProgramResourceIndex name_bucket_id should be 12");
-static_assert(offsetof(GetProgramResourceIndex, index_shm_id) == 16,
-              "offset of GetProgramResourceIndex index_shm_id should be 16");
-static_assert(
-    offsetof(GetProgramResourceIndex, index_shm_offset) == 20,
-    "offset of GetProgramResourceIndex index_shm_offset should be 20");
-
-struct GetProgramResourceName {
-  typedef GetProgramResourceName ValueType;
-  static const CommandId kCmdId = kGetProgramResourceName;
-  static const cmd::ArgFlags kArgFlags = cmd::kFixed;
-  static const uint8_t cmd_flags = CMD_FLAG_SET_TRACE_LEVEL(2);
-
-  typedef int32_t Result;
-
-  static uint32_t ComputeSize() {
-    return static_cast<uint32_t>(sizeof(ValueType));  // NOLINT
-  }
-
-  void SetHeader() { header.SetCmd<ValueType>(); }
-
-  void Init(GLuint _program,
-            GLenum _program_interface,
-            GLuint _index,
-            uint32_t _name_bucket_id,
-            uint32_t _result_shm_id,
-            uint32_t _result_shm_offset) {
-    SetHeader();
-    program = _program;
-    program_interface = _program_interface;
-    index = _index;
-    name_bucket_id = _name_bucket_id;
-    result_shm_id = _result_shm_id;
-    result_shm_offset = _result_shm_offset;
-  }
-
-  void* Set(void* cmd,
-            GLuint _program,
-            GLenum _program_interface,
-            GLuint _index,
-            uint32_t _name_bucket_id,
-            uint32_t _result_shm_id,
-            uint32_t _result_shm_offset) {
-    static_cast<ValueType*>(cmd)->Init(_program, _program_interface, _index,
-                                       _name_bucket_id, _result_shm_id,
-                                       _result_shm_offset);
-    return NextCmdAddress<ValueType>(cmd);
-  }
-
-  gpu::CommandHeader header;
-  uint32_t program;
-  uint32_t program_interface;
-  uint32_t index;
-  uint32_t name_bucket_id;
-  uint32_t result_shm_id;
-  uint32_t result_shm_offset;
-};
-
-static_assert(sizeof(GetProgramResourceName) == 28,
-              "size of GetProgramResourceName should be 28");
-static_assert(offsetof(GetProgramResourceName, header) == 0,
-              "offset of GetProgramResourceName header should be 0");
-static_assert(offsetof(GetProgramResourceName, program) == 4,
-              "offset of GetProgramResourceName program should be 4");
-static_assert(offsetof(GetProgramResourceName, program_interface) == 8,
-              "offset of GetProgramResourceName program_interface should be 8");
-static_assert(offsetof(GetProgramResourceName, index) == 12,
-              "offset of GetProgramResourceName index should be 12");
-static_assert(offsetof(GetProgramResourceName, name_bucket_id) == 16,
-              "offset of GetProgramResourceName name_bucket_id should be 16");
-static_assert(offsetof(GetProgramResourceName, result_shm_id) == 20,
-              "offset of GetProgramResourceName result_shm_id should be 20");
-static_assert(
-    offsetof(GetProgramResourceName, result_shm_offset) == 24,
-    "offset of GetProgramResourceName result_shm_offset should be 24");
-
-struct GetProgramResourceiv {
-  typedef GetProgramResourceiv ValueType;
-  static const CommandId kCmdId = kGetProgramResourceiv;
-  static const cmd::ArgFlags kArgFlags = cmd::kFixed;
-  static const uint8_t cmd_flags = CMD_FLAG_SET_TRACE_LEVEL(2);
-
-  typedef SizedResult<GLint> Result;
-
-  static uint32_t ComputeSize() {
-    return static_cast<uint32_t>(sizeof(ValueType));  // NOLINT
-  }
-
-  void SetHeader() { header.SetCmd<ValueType>(); }
-
-  void Init(GLuint _program,
-            GLenum _program_interface,
-            GLuint _index,
-            uint32_t _props_bucket_id,
-            uint32_t _params_shm_id,
-            uint32_t _params_shm_offset) {
-    SetHeader();
-    program = _program;
-    program_interface = _program_interface;
-    index = _index;
-    props_bucket_id = _props_bucket_id;
-    params_shm_id = _params_shm_id;
-    params_shm_offset = _params_shm_offset;
-  }
-
-  void* Set(void* cmd,
-            GLuint _program,
-            GLenum _program_interface,
-            GLuint _index,
-            uint32_t _props_bucket_id,
-            uint32_t _params_shm_id,
-            uint32_t _params_shm_offset) {
-    static_cast<ValueType*>(cmd)->Init(_program, _program_interface, _index,
-                                       _props_bucket_id, _params_shm_id,
-                                       _params_shm_offset);
-    return NextCmdAddress<ValueType>(cmd);
-  }
-
-  gpu::CommandHeader header;
-  uint32_t program;
-  uint32_t program_interface;
-  uint32_t index;
-  uint32_t props_bucket_id;
-  uint32_t params_shm_id;
-  uint32_t params_shm_offset;
-};
-
-static_assert(sizeof(GetProgramResourceiv) == 28,
-              "size of GetProgramResourceiv should be 28");
-static_assert(offsetof(GetProgramResourceiv, header) == 0,
-              "offset of GetProgramResourceiv header should be 0");
-static_assert(offsetof(GetProgramResourceiv, program) == 4,
-              "offset of GetProgramResourceiv program should be 4");
-static_assert(offsetof(GetProgramResourceiv, program_interface) == 8,
-              "offset of GetProgramResourceiv program_interface should be 8");
-static_assert(offsetof(GetProgramResourceiv, index) == 12,
-              "offset of GetProgramResourceiv index should be 12");
-static_assert(offsetof(GetProgramResourceiv, props_bucket_id) == 16,
-              "offset of GetProgramResourceiv props_bucket_id should be 16");
-static_assert(offsetof(GetProgramResourceiv, params_shm_id) == 20,
-              "offset of GetProgramResourceiv params_shm_id should be 20");
-static_assert(offsetof(GetProgramResourceiv, params_shm_offset) == 24,
-              "offset of GetProgramResourceiv params_shm_offset should be 24");
-
-struct GetProgramResourceLocation {
-  typedef GetProgramResourceLocation ValueType;
-  static const CommandId kCmdId = kGetProgramResourceLocation;
-  static const cmd::ArgFlags kArgFlags = cmd::kFixed;
-  static const uint8_t cmd_flags = CMD_FLAG_SET_TRACE_LEVEL(2);
-
-  typedef GLint Result;
-
-  static uint32_t ComputeSize() {
-    return static_cast<uint32_t>(sizeof(ValueType));  // NOLINT
-  }
-
-  void SetHeader() { header.SetCmd<ValueType>(); }
-
-  void Init(GLuint _program,
-            GLenum _program_interface,
-            uint32_t _name_bucket_id,
-            uint32_t _location_shm_id,
-            uint32_t _location_shm_offset) {
-    SetHeader();
-    program = _program;
-    program_interface = _program_interface;
-    name_bucket_id = _name_bucket_id;
-    location_shm_id = _location_shm_id;
-    location_shm_offset = _location_shm_offset;
-  }
-
-  void* Set(void* cmd,
-            GLuint _program,
-            GLenum _program_interface,
-            uint32_t _name_bucket_id,
-            uint32_t _location_shm_id,
-            uint32_t _location_shm_offset) {
-    static_cast<ValueType*>(cmd)->Init(_program, _program_interface,
-                                       _name_bucket_id, _location_shm_id,
-                                       _location_shm_offset);
-    return NextCmdAddress<ValueType>(cmd);
-  }
-
-  gpu::CommandHeader header;
-  uint32_t program;
-  uint32_t program_interface;
-  uint32_t name_bucket_id;
-  uint32_t location_shm_id;
-  uint32_t location_shm_offset;
-};
-
-static_assert(sizeof(GetProgramResourceLocation) == 24,
-              "size of GetProgramResourceLocation should be 24");
-static_assert(offsetof(GetProgramResourceLocation, header) == 0,
-              "offset of GetProgramResourceLocation header should be 0");
-static_assert(offsetof(GetProgramResourceLocation, program) == 4,
-              "offset of GetProgramResourceLocation program should be 4");
-static_assert(
-    offsetof(GetProgramResourceLocation, program_interface) == 8,
-    "offset of GetProgramResourceLocation program_interface should be 8");
-static_assert(
-    offsetof(GetProgramResourceLocation, name_bucket_id) == 12,
-    "offset of GetProgramResourceLocation name_bucket_id should be 12");
-static_assert(
-    offsetof(GetProgramResourceLocation, location_shm_id) == 16,
-    "offset of GetProgramResourceLocation location_shm_id should be 16");
-static_assert(
-    offsetof(GetProgramResourceLocation, location_shm_offset) == 20,
-    "offset of GetProgramResourceLocation location_shm_offset should be 20");
-
 struct MemoryBarrierEXT {
   typedef MemoryBarrierEXT ValueType;
   static const CommandId kCmdId = kMemoryBarrierEXT;
@@ -17518,30 +17115,25 @@
 
   void SetHeader() { header.SetCmdByTotalSize<ValueType>(ComputeSize()); }
 
-  void Init(GLuint _texture, const GLbyte* _mailbox, GLenum _internalformat) {
+  void Init(GLuint _texture, const GLbyte* _mailbox) {
     SetHeader();
     texture = _texture;
-    internalformat = _internalformat;
     memcpy(ImmediateDataAddress(this), _mailbox, ComputeDataSize());
   }
 
-  void* Set(void* cmd,
-            GLuint _texture,
-            const GLbyte* _mailbox,
-            GLenum _internalformat) {
-    static_cast<ValueType*>(cmd)->Init(_texture, _mailbox, _internalformat);
+  void* Set(void* cmd, GLuint _texture, const GLbyte* _mailbox) {
+    static_cast<ValueType*>(cmd)->Init(_texture, _mailbox);
     const uint32_t size = ComputeSize();
     return NextImmediateCmdAddressTotalSize<ValueType>(cmd, size);
   }
 
   gpu::CommandHeader header;
   uint32_t texture;
-  uint32_t internalformat;
 };
 
 static_assert(
-    sizeof(CreateAndTexStorage2DSharedImageINTERNALImmediate) == 12,
-    "size of CreateAndTexStorage2DSharedImageINTERNALImmediate should be 12");
+    sizeof(CreateAndTexStorage2DSharedImageINTERNALImmediate) == 8,
+    "size of CreateAndTexStorage2DSharedImageINTERNALImmediate should be 8");
 static_assert(offsetof(CreateAndTexStorage2DSharedImageINTERNALImmediate,
                        header) == 0,
               "offset of CreateAndTexStorage2DSharedImageINTERNALImmediate "
@@ -17550,10 +17142,6 @@
                        texture) == 4,
               "offset of CreateAndTexStorage2DSharedImageINTERNALImmediate "
               "texture should be 4");
-static_assert(offsetof(CreateAndTexStorage2DSharedImageINTERNALImmediate,
-                       internalformat) == 8,
-              "offset of CreateAndTexStorage2DSharedImageINTERNALImmediate "
-              "internalformat should be 8");
 
 struct BeginSharedImageAccessDirectCHROMIUM {
   typedef BeginSharedImageAccessDirectCHROMIUM ValueType;
--- a/gpu/command_buffer/common/gles2_cmd_format_test_autogen.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/common/gles2_cmd_format_test_autogen.h	2019-05-17 18:53:32.976000000 +0300
@@ -3813,26 +3813,6 @@
   CheckBytesWrittenMatchesExpectedSize(next_cmd, sizeof(cmd));
 }
 
-TEST_F(GLES2FormatTest, RenderbufferStorageMultisampleAdvancedAMD) {
-  cmds::RenderbufferStorageMultisampleAdvancedAMD& cmd =
-      *GetBufferAs<cmds::RenderbufferStorageMultisampleAdvancedAMD>();
-  void* next_cmd =
-      cmd.Set(&cmd, static_cast<GLenum>(11), static_cast<GLsizei>(12),
-              static_cast<GLsizei>(13), static_cast<GLenum>(14),
-              static_cast<GLsizei>(15), static_cast<GLsizei>(16));
-  EXPECT_EQ(static_cast<uint32_t>(
-                cmds::RenderbufferStorageMultisampleAdvancedAMD::kCmdId),
-            cmd.header.command);
-  EXPECT_EQ(sizeof(cmd), cmd.header.size * 4u);
-  EXPECT_EQ(static_cast<GLenum>(11), cmd.target);
-  EXPECT_EQ(static_cast<GLsizei>(12), cmd.samples);
-  EXPECT_EQ(static_cast<GLsizei>(13), cmd.storageSamples);
-  EXPECT_EQ(static_cast<GLenum>(14), cmd.internalformat);
-  EXPECT_EQ(static_cast<GLsizei>(15), cmd.width);
-  EXPECT_EQ(static_cast<GLsizei>(16), cmd.height);
-  CheckBytesWrittenMatchesExpectedSize(next_cmd, sizeof(cmd));
-}
-
 TEST_F(GLES2FormatTest, RenderbufferStorageMultisampleEXT) {
   cmds::RenderbufferStorageMultisampleEXT& cmd =
       *GetBufferAs<cmds::RenderbufferStorageMultisampleEXT>();
@@ -4142,97 +4122,6 @@
   CheckBytesWrittenMatchesExpectedSize(next_cmd, sizeof(cmd));
 }
 
-TEST_F(GLES2FormatTest, GetProgramInterfaceiv) {
-  cmds::GetProgramInterfaceiv& cmd =
-      *GetBufferAs<cmds::GetProgramInterfaceiv>();
-  void* next_cmd =
-      cmd.Set(&cmd, static_cast<GLuint>(11), static_cast<GLenum>(12),
-              static_cast<GLenum>(13), static_cast<uint32_t>(14),
-              static_cast<uint32_t>(15));
-  EXPECT_EQ(static_cast<uint32_t>(cmds::GetProgramInterfaceiv::kCmdId),
-            cmd.header.command);
-  EXPECT_EQ(sizeof(cmd), cmd.header.size * 4u);
-  EXPECT_EQ(static_cast<GLuint>(11), cmd.program);
-  EXPECT_EQ(static_cast<GLenum>(12), cmd.program_interface);
-  EXPECT_EQ(static_cast<GLenum>(13), cmd.pname);
-  EXPECT_EQ(static_cast<uint32_t>(14), cmd.params_shm_id);
-  EXPECT_EQ(static_cast<uint32_t>(15), cmd.params_shm_offset);
-  CheckBytesWrittenMatchesExpectedSize(next_cmd, sizeof(cmd));
-}
-
-TEST_F(GLES2FormatTest, GetProgramResourceIndex) {
-  cmds::GetProgramResourceIndex& cmd =
-      *GetBufferAs<cmds::GetProgramResourceIndex>();
-  void* next_cmd =
-      cmd.Set(&cmd, static_cast<GLuint>(11), static_cast<GLenum>(12),
-              static_cast<uint32_t>(13), static_cast<uint32_t>(14),
-              static_cast<uint32_t>(15));
-  EXPECT_EQ(static_cast<uint32_t>(cmds::GetProgramResourceIndex::kCmdId),
-            cmd.header.command);
-  EXPECT_EQ(sizeof(cmd), cmd.header.size * 4u);
-  EXPECT_EQ(static_cast<GLuint>(11), cmd.program);
-  EXPECT_EQ(static_cast<GLenum>(12), cmd.program_interface);
-  EXPECT_EQ(static_cast<uint32_t>(13), cmd.name_bucket_id);
-  EXPECT_EQ(static_cast<uint32_t>(14), cmd.index_shm_id);
-  EXPECT_EQ(static_cast<uint32_t>(15), cmd.index_shm_offset);
-  CheckBytesWrittenMatchesExpectedSize(next_cmd, sizeof(cmd));
-}
-
-TEST_F(GLES2FormatTest, GetProgramResourceName) {
-  cmds::GetProgramResourceName& cmd =
-      *GetBufferAs<cmds::GetProgramResourceName>();
-  void* next_cmd =
-      cmd.Set(&cmd, static_cast<GLuint>(11), static_cast<GLenum>(12),
-              static_cast<GLuint>(13), static_cast<uint32_t>(14),
-              static_cast<uint32_t>(15), static_cast<uint32_t>(16));
-  EXPECT_EQ(static_cast<uint32_t>(cmds::GetProgramResourceName::kCmdId),
-            cmd.header.command);
-  EXPECT_EQ(sizeof(cmd), cmd.header.size * 4u);
-  EXPECT_EQ(static_cast<GLuint>(11), cmd.program);
-  EXPECT_EQ(static_cast<GLenum>(12), cmd.program_interface);
-  EXPECT_EQ(static_cast<GLuint>(13), cmd.index);
-  EXPECT_EQ(static_cast<uint32_t>(14), cmd.name_bucket_id);
-  EXPECT_EQ(static_cast<uint32_t>(15), cmd.result_shm_id);
-  EXPECT_EQ(static_cast<uint32_t>(16), cmd.result_shm_offset);
-  CheckBytesWrittenMatchesExpectedSize(next_cmd, sizeof(cmd));
-}
-
-TEST_F(GLES2FormatTest, GetProgramResourceiv) {
-  cmds::GetProgramResourceiv& cmd = *GetBufferAs<cmds::GetProgramResourceiv>();
-  void* next_cmd =
-      cmd.Set(&cmd, static_cast<GLuint>(11), static_cast<GLenum>(12),
-              static_cast<GLuint>(13), static_cast<uint32_t>(14),
-              static_cast<uint32_t>(15), static_cast<uint32_t>(16));
-  EXPECT_EQ(static_cast<uint32_t>(cmds::GetProgramResourceiv::kCmdId),
-            cmd.header.command);
-  EXPECT_EQ(sizeof(cmd), cmd.header.size * 4u);
-  EXPECT_EQ(static_cast<GLuint>(11), cmd.program);
-  EXPECT_EQ(static_cast<GLenum>(12), cmd.program_interface);
-  EXPECT_EQ(static_cast<GLuint>(13), cmd.index);
-  EXPECT_EQ(static_cast<uint32_t>(14), cmd.props_bucket_id);
-  EXPECT_EQ(static_cast<uint32_t>(15), cmd.params_shm_id);
-  EXPECT_EQ(static_cast<uint32_t>(16), cmd.params_shm_offset);
-  CheckBytesWrittenMatchesExpectedSize(next_cmd, sizeof(cmd));
-}
-
-TEST_F(GLES2FormatTest, GetProgramResourceLocation) {
-  cmds::GetProgramResourceLocation& cmd =
-      *GetBufferAs<cmds::GetProgramResourceLocation>();
-  void* next_cmd =
-      cmd.Set(&cmd, static_cast<GLuint>(11), static_cast<GLenum>(12),
-              static_cast<uint32_t>(13), static_cast<uint32_t>(14),
-              static_cast<uint32_t>(15));
-  EXPECT_EQ(static_cast<uint32_t>(cmds::GetProgramResourceLocation::kCmdId),
-            cmd.header.command);
-  EXPECT_EQ(sizeof(cmd), cmd.header.size * 4u);
-  EXPECT_EQ(static_cast<GLuint>(11), cmd.program);
-  EXPECT_EQ(static_cast<GLenum>(12), cmd.program_interface);
-  EXPECT_EQ(static_cast<uint32_t>(13), cmd.name_bucket_id);
-  EXPECT_EQ(static_cast<uint32_t>(14), cmd.location_shm_id);
-  EXPECT_EQ(static_cast<uint32_t>(15), cmd.location_shm_offset);
-  CheckBytesWrittenMatchesExpectedSize(next_cmd, sizeof(cmd));
-}
-
 TEST_F(GLES2FormatTest, MemoryBarrierEXT) {
   cmds::MemoryBarrierEXT& cmd = *GetBufferAs<cmds::MemoryBarrierEXT>();
   void* next_cmd = cmd.Set(&cmd, static_cast<GLbitfield>(11));
@@ -5791,8 +5680,7 @@
   };
   cmds::CreateAndTexStorage2DSharedImageINTERNALImmediate& cmd =
       *GetBufferAs<cmds::CreateAndTexStorage2DSharedImageINTERNALImmediate>();
-  void* next_cmd =
-      cmd.Set(&cmd, static_cast<GLuint>(11), data, static_cast<GLenum>(12));
+  void* next_cmd = cmd.Set(&cmd, static_cast<GLuint>(11), data);
   EXPECT_EQ(
       static_cast<uint32_t>(
           cmds::CreateAndTexStorage2DSharedImageINTERNALImmediate::kCmdId),
@@ -5800,7 +5688,6 @@
   EXPECT_EQ(sizeof(cmd) + RoundSizeToMultipleOfEntries(sizeof(data)),
             cmd.header.size * 4u);
   EXPECT_EQ(static_cast<GLuint>(11), cmd.texture);
-  EXPECT_EQ(static_cast<GLenum>(12), cmd.internalformat);
   CheckBytesWrittenMatchesExpectedSize(
       next_cmd, sizeof(cmd) + RoundSizeToMultipleOfEntries(sizeof(data)));
 }
--- a/gpu/command_buffer/common/gles2_cmd_ids_autogen.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/common/gles2_cmd_ids_autogen.h	2019-05-17 18:53:32.976000000 +0300
@@ -241,127 +241,121 @@
   OP(WaitSync)                                             /* 482 */ \
   OP(BlitFramebufferCHROMIUM)                              /* 483 */ \
   OP(RenderbufferStorageMultisampleCHROMIUM)               /* 484 */ \
-  OP(RenderbufferStorageMultisampleAdvancedAMD)            /* 485 */ \
-  OP(RenderbufferStorageMultisampleEXT)                    /* 486 */ \
-  OP(FramebufferTexture2DMultisampleEXT)                   /* 487 */ \
-  OP(TexStorage2DEXT)                                      /* 488 */ \
-  OP(GenQueriesEXTImmediate)                               /* 489 */ \
-  OP(DeleteQueriesEXTImmediate)                            /* 490 */ \
-  OP(QueryCounterEXT)                                      /* 491 */ \
-  OP(BeginQueryEXT)                                        /* 492 */ \
-  OP(BeginTransformFeedback)                               /* 493 */ \
-  OP(EndQueryEXT)                                          /* 494 */ \
-  OP(EndTransformFeedback)                                 /* 495 */ \
-  OP(SetDisjointValueSyncCHROMIUM)                         /* 496 */ \
-  OP(InsertEventMarkerEXT)                                 /* 497 */ \
-  OP(PushGroupMarkerEXT)                                   /* 498 */ \
-  OP(PopGroupMarkerEXT)                                    /* 499 */ \
-  OP(GenVertexArraysOESImmediate)                          /* 500 */ \
-  OP(DeleteVertexArraysOESImmediate)                       /* 501 */ \
-  OP(IsVertexArrayOES)                                     /* 502 */ \
-  OP(BindVertexArrayOES)                                   /* 503 */ \
-  OP(FramebufferParameteri)                                /* 504 */ \
-  OP(BindImageTexture)                                     /* 505 */ \
-  OP(DispatchCompute)                                      /* 506 */ \
-  OP(GetProgramInterfaceiv)                                /* 507 */ \
-  OP(GetProgramResourceIndex)                              /* 508 */ \
-  OP(GetProgramResourceName)                               /* 509 */ \
-  OP(GetProgramResourceiv)                                 /* 510 */ \
-  OP(GetProgramResourceLocation)                           /* 511 */ \
-  OP(MemoryBarrierEXT)                                     /* 512 */ \
-  OP(MemoryBarrierByRegion)                                /* 513 */ \
-  OP(SwapBuffers)                                          /* 514 */ \
-  OP(GetMaxValueInBufferCHROMIUM)                          /* 515 */ \
-  OP(EnableFeatureCHROMIUM)                                /* 516 */ \
-  OP(MapBufferRange)                                       /* 517 */ \
-  OP(UnmapBuffer)                                          /* 518 */ \
-  OP(FlushMappedBufferRange)                               /* 519 */ \
-  OP(ResizeCHROMIUM)                                       /* 520 */ \
-  OP(GetRequestableExtensionsCHROMIUM)                     /* 521 */ \
-  OP(RequestExtensionCHROMIUM)                             /* 522 */ \
-  OP(GetProgramInfoCHROMIUM)                               /* 523 */ \
-  OP(GetUniformBlocksCHROMIUM)                             /* 524 */ \
-  OP(GetTransformFeedbackVaryingsCHROMIUM)                 /* 525 */ \
-  OP(GetUniformsES3CHROMIUM)                               /* 526 */ \
-  OP(DescheduleUntilFinishedCHROMIUM)                      /* 527 */ \
-  OP(GetTranslatedShaderSourceANGLE)                       /* 528 */ \
-  OP(PostSubBufferCHROMIUM)                                /* 529 */ \
-  OP(CopyTextureCHROMIUM)                                  /* 530 */ \
-  OP(CopySubTextureCHROMIUM)                               /* 531 */ \
-  OP(DrawArraysInstancedANGLE)                             /* 532 */ \
-  OP(DrawElementsInstancedANGLE)                           /* 533 */ \
-  OP(VertexAttribDivisorANGLE)                             /* 534 */ \
-  OP(ProduceTextureDirectCHROMIUMImmediate)                /* 535 */ \
-  OP(CreateAndConsumeTextureINTERNALImmediate)             /* 536 */ \
-  OP(BindUniformLocationCHROMIUMBucket)                    /* 537 */ \
-  OP(BindTexImage2DCHROMIUM)                               /* 538 */ \
-  OP(BindTexImage2DWithInternalformatCHROMIUM)             /* 539 */ \
-  OP(ReleaseTexImage2DCHROMIUM)                            /* 540 */ \
-  OP(TraceBeginCHROMIUM)                                   /* 541 */ \
-  OP(TraceEndCHROMIUM)                                     /* 542 */ \
-  OP(DiscardFramebufferEXTImmediate)                       /* 543 */ \
-  OP(LoseContextCHROMIUM)                                  /* 544 */ \
-  OP(InsertFenceSyncCHROMIUM)                              /* 545 */ \
-  OP(UnpremultiplyAndDitherCopyCHROMIUM)                   /* 546 */ \
-  OP(DrawBuffersEXTImmediate)                              /* 547 */ \
-  OP(DiscardBackbufferCHROMIUM)                            /* 548 */ \
-  OP(ScheduleOverlayPlaneCHROMIUM)                         /* 549 */ \
-  OP(ScheduleCALayerSharedStateCHROMIUM)                   /* 550 */ \
-  OP(ScheduleCALayerCHROMIUM)                              /* 551 */ \
-  OP(ScheduleCALayerInUseQueryCHROMIUMImmediate)           /* 552 */ \
-  OP(CommitOverlayPlanesCHROMIUM)                          /* 553 */ \
-  OP(FlushDriverCachesCHROMIUM)                            /* 554 */ \
-  OP(ScheduleDCLayerCHROMIUM)                              /* 555 */ \
-  OP(SetActiveURLCHROMIUM)                                 /* 556 */ \
-  OP(MatrixLoadfCHROMIUMImmediate)                         /* 557 */ \
-  OP(MatrixLoadIdentityCHROMIUM)                           /* 558 */ \
-  OP(GenPathsCHROMIUM)                                     /* 559 */ \
-  OP(DeletePathsCHROMIUM)                                  /* 560 */ \
-  OP(IsPathCHROMIUM)                                       /* 561 */ \
-  OP(PathCommandsCHROMIUM)                                 /* 562 */ \
-  OP(PathParameterfCHROMIUM)                               /* 563 */ \
-  OP(PathParameteriCHROMIUM)                               /* 564 */ \
-  OP(PathStencilFuncCHROMIUM)                              /* 565 */ \
-  OP(StencilFillPathCHROMIUM)                              /* 566 */ \
-  OP(StencilStrokePathCHROMIUM)                            /* 567 */ \
-  OP(CoverFillPathCHROMIUM)                                /* 568 */ \
-  OP(CoverStrokePathCHROMIUM)                              /* 569 */ \
-  OP(StencilThenCoverFillPathCHROMIUM)                     /* 570 */ \
-  OP(StencilThenCoverStrokePathCHROMIUM)                   /* 571 */ \
-  OP(StencilFillPathInstancedCHROMIUM)                     /* 572 */ \
-  OP(StencilStrokePathInstancedCHROMIUM)                   /* 573 */ \
-  OP(CoverFillPathInstancedCHROMIUM)                       /* 574 */ \
-  OP(CoverStrokePathInstancedCHROMIUM)                     /* 575 */ \
-  OP(StencilThenCoverFillPathInstancedCHROMIUM)            /* 576 */ \
-  OP(StencilThenCoverStrokePathInstancedCHROMIUM)          /* 577 */ \
-  OP(BindFragmentInputLocationCHROMIUMBucket)              /* 578 */ \
-  OP(ProgramPathFragmentInputGenCHROMIUM)                  /* 579 */ \
-  OP(CoverageModulationCHROMIUM)                           /* 580 */ \
-  OP(BlendBarrierKHR)                                      /* 581 */ \
-  OP(ApplyScreenSpaceAntialiasingCHROMIUM)                 /* 582 */ \
-  OP(BindFragDataLocationIndexedEXTBucket)                 /* 583 */ \
-  OP(BindFragDataLocationEXTBucket)                        /* 584 */ \
-  OP(GetFragDataIndexEXT)                                  /* 585 */ \
-  OP(UniformMatrix4fvStreamTextureMatrixCHROMIUMImmediate) /* 586 */ \
-  OP(OverlayPromotionHintCHROMIUM)                         /* 587 */ \
-  OP(SwapBuffersWithBoundsCHROMIUMImmediate)               /* 588 */ \
-  OP(SetDrawRectangleCHROMIUM)                             /* 589 */ \
-  OP(SetEnableDCLayersCHROMIUM)                            /* 590 */ \
-  OP(InitializeDiscardableTextureCHROMIUM)                 /* 591 */ \
-  OP(UnlockDiscardableTextureCHROMIUM)                     /* 592 */ \
-  OP(LockDiscardableTextureCHROMIUM)                       /* 593 */ \
-  OP(TexStorage2DImageCHROMIUM)                            /* 594 */ \
-  OP(SetColorSpaceMetadataCHROMIUM)                        /* 595 */ \
-  OP(WindowRectanglesEXTImmediate)                         /* 596 */ \
-  OP(CreateGpuFenceINTERNAL)                               /* 597 */ \
-  OP(WaitGpuFenceCHROMIUM)                                 /* 598 */ \
-  OP(DestroyGpuFenceCHROMIUM)                              /* 599 */ \
-  OP(SetReadbackBufferShadowAllocationINTERNAL)            /* 600 */ \
-  OP(FramebufferTextureMultiviewLayeredANGLE)              /* 601 */ \
-  OP(MaxShaderCompilerThreadsKHR)                          /* 602 */ \
-  OP(CreateAndTexStorage2DSharedImageINTERNALImmediate)    /* 603 */ \
-  OP(BeginSharedImageAccessDirectCHROMIUM)                 /* 604 */ \
-  OP(EndSharedImageAccessDirectCHROMIUM)                   /* 605 */
+  OP(RenderbufferStorageMultisampleEXT)                    /* 485 */ \
+  OP(FramebufferTexture2DMultisampleEXT)                   /* 486 */ \
+  OP(TexStorage2DEXT)                                      /* 487 */ \
+  OP(GenQueriesEXTImmediate)                               /* 488 */ \
+  OP(DeleteQueriesEXTImmediate)                            /* 489 */ \
+  OP(QueryCounterEXT)                                      /* 490 */ \
+  OP(BeginQueryEXT)                                        /* 491 */ \
+  OP(BeginTransformFeedback)                               /* 492 */ \
+  OP(EndQueryEXT)                                          /* 493 */ \
+  OP(EndTransformFeedback)                                 /* 494 */ \
+  OP(SetDisjointValueSyncCHROMIUM)                         /* 495 */ \
+  OP(InsertEventMarkerEXT)                                 /* 496 */ \
+  OP(PushGroupMarkerEXT)                                   /* 497 */ \
+  OP(PopGroupMarkerEXT)                                    /* 498 */ \
+  OP(GenVertexArraysOESImmediate)                          /* 499 */ \
+  OP(DeleteVertexArraysOESImmediate)                       /* 500 */ \
+  OP(IsVertexArrayOES)                                     /* 501 */ \
+  OP(BindVertexArrayOES)                                   /* 502 */ \
+  OP(FramebufferParameteri)                                /* 503 */ \
+  OP(BindImageTexture)                                     /* 504 */ \
+  OP(DispatchCompute)                                      /* 505 */ \
+  OP(MemoryBarrierEXT)                                     /* 506 */ \
+  OP(MemoryBarrierByRegion)                                /* 507 */ \
+  OP(SwapBuffers)                                          /* 508 */ \
+  OP(GetMaxValueInBufferCHROMIUM)                          /* 509 */ \
+  OP(EnableFeatureCHROMIUM)                                /* 510 */ \
+  OP(MapBufferRange)                                       /* 511 */ \
+  OP(UnmapBuffer)                                          /* 512 */ \
+  OP(FlushMappedBufferRange)                               /* 513 */ \
+  OP(ResizeCHROMIUM)                                       /* 514 */ \
+  OP(GetRequestableExtensionsCHROMIUM)                     /* 515 */ \
+  OP(RequestExtensionCHROMIUM)                             /* 516 */ \
+  OP(GetProgramInfoCHROMIUM)                               /* 517 */ \
+  OP(GetUniformBlocksCHROMIUM)                             /* 518 */ \
+  OP(GetTransformFeedbackVaryingsCHROMIUM)                 /* 519 */ \
+  OP(GetUniformsES3CHROMIUM)                               /* 520 */ \
+  OP(DescheduleUntilFinishedCHROMIUM)                      /* 521 */ \
+  OP(GetTranslatedShaderSourceANGLE)                       /* 522 */ \
+  OP(PostSubBufferCHROMIUM)                                /* 523 */ \
+  OP(CopyTextureCHROMIUM)                                  /* 524 */ \
+  OP(CopySubTextureCHROMIUM)                               /* 525 */ \
+  OP(DrawArraysInstancedANGLE)                             /* 526 */ \
+  OP(DrawElementsInstancedANGLE)                           /* 527 */ \
+  OP(VertexAttribDivisorANGLE)                             /* 528 */ \
+  OP(ProduceTextureDirectCHROMIUMImmediate)                /* 529 */ \
+  OP(CreateAndConsumeTextureINTERNALImmediate)             /* 530 */ \
+  OP(BindUniformLocationCHROMIUMBucket)                    /* 531 */ \
+  OP(BindTexImage2DCHROMIUM)                               /* 532 */ \
+  OP(BindTexImage2DWithInternalformatCHROMIUM)             /* 533 */ \
+  OP(ReleaseTexImage2DCHROMIUM)                            /* 534 */ \
+  OP(TraceBeginCHROMIUM)                                   /* 535 */ \
+  OP(TraceEndCHROMIUM)                                     /* 536 */ \
+  OP(DiscardFramebufferEXTImmediate)                       /* 537 */ \
+  OP(LoseContextCHROMIUM)                                  /* 538 */ \
+  OP(InsertFenceSyncCHROMIUM)                              /* 539 */ \
+  OP(UnpremultiplyAndDitherCopyCHROMIUM)                   /* 540 */ \
+  OP(DrawBuffersEXTImmediate)                              /* 541 */ \
+  OP(DiscardBackbufferCHROMIUM)                            /* 542 */ \
+  OP(ScheduleOverlayPlaneCHROMIUM)                         /* 543 */ \
+  OP(ScheduleCALayerSharedStateCHROMIUM)                   /* 544 */ \
+  OP(ScheduleCALayerCHROMIUM)                              /* 545 */ \
+  OP(ScheduleCALayerInUseQueryCHROMIUMImmediate)           /* 546 */ \
+  OP(CommitOverlayPlanesCHROMIUM)                          /* 547 */ \
+  OP(FlushDriverCachesCHROMIUM)                            /* 548 */ \
+  OP(ScheduleDCLayerCHROMIUM)                              /* 549 */ \
+  OP(SetActiveURLCHROMIUM)                                 /* 550 */ \
+  OP(MatrixLoadfCHROMIUMImmediate)                         /* 551 */ \
+  OP(MatrixLoadIdentityCHROMIUM)                           /* 552 */ \
+  OP(GenPathsCHROMIUM)                                     /* 553 */ \
+  OP(DeletePathsCHROMIUM)                                  /* 554 */ \
+  OP(IsPathCHROMIUM)                                       /* 555 */ \
+  OP(PathCommandsCHROMIUM)                                 /* 556 */ \
+  OP(PathParameterfCHROMIUM)                               /* 557 */ \
+  OP(PathParameteriCHROMIUM)                               /* 558 */ \
+  OP(PathStencilFuncCHROMIUM)                              /* 559 */ \
+  OP(StencilFillPathCHROMIUM)                              /* 560 */ \
+  OP(StencilStrokePathCHROMIUM)                            /* 561 */ \
+  OP(CoverFillPathCHROMIUM)                                /* 562 */ \
+  OP(CoverStrokePathCHROMIUM)                              /* 563 */ \
+  OP(StencilThenCoverFillPathCHROMIUM)                     /* 564 */ \
+  OP(StencilThenCoverStrokePathCHROMIUM)                   /* 565 */ \
+  OP(StencilFillPathInstancedCHROMIUM)                     /* 566 */ \
+  OP(StencilStrokePathInstancedCHROMIUM)                   /* 567 */ \
+  OP(CoverFillPathInstancedCHROMIUM)                       /* 568 */ \
+  OP(CoverStrokePathInstancedCHROMIUM)                     /* 569 */ \
+  OP(StencilThenCoverFillPathInstancedCHROMIUM)            /* 570 */ \
+  OP(StencilThenCoverStrokePathInstancedCHROMIUM)          /* 571 */ \
+  OP(BindFragmentInputLocationCHROMIUMBucket)              /* 572 */ \
+  OP(ProgramPathFragmentInputGenCHROMIUM)                  /* 573 */ \
+  OP(CoverageModulationCHROMIUM)                           /* 574 */ \
+  OP(BlendBarrierKHR)                                      /* 575 */ \
+  OP(ApplyScreenSpaceAntialiasingCHROMIUM)                 /* 576 */ \
+  OP(BindFragDataLocationIndexedEXTBucket)                 /* 577 */ \
+  OP(BindFragDataLocationEXTBucket)                        /* 578 */ \
+  OP(GetFragDataIndexEXT)                                  /* 579 */ \
+  OP(UniformMatrix4fvStreamTextureMatrixCHROMIUMImmediate) /* 580 */ \
+  OP(OverlayPromotionHintCHROMIUM)                         /* 581 */ \
+  OP(SwapBuffersWithBoundsCHROMIUMImmediate)               /* 582 */ \
+  OP(SetDrawRectangleCHROMIUM)                             /* 583 */ \
+  OP(SetEnableDCLayersCHROMIUM)                            /* 584 */ \
+  OP(InitializeDiscardableTextureCHROMIUM)                 /* 585 */ \
+  OP(UnlockDiscardableTextureCHROMIUM)                     /* 586 */ \
+  OP(LockDiscardableTextureCHROMIUM)                       /* 587 */ \
+  OP(TexStorage2DImageCHROMIUM)                            /* 588 */ \
+  OP(SetColorSpaceMetadataCHROMIUM)                        /* 589 */ \
+  OP(WindowRectanglesEXTImmediate)                         /* 590 */ \
+  OP(CreateGpuFenceINTERNAL)                               /* 591 */ \
+  OP(WaitGpuFenceCHROMIUM)                                 /* 592 */ \
+  OP(DestroyGpuFenceCHROMIUM)                              /* 593 */ \
+  OP(SetReadbackBufferShadowAllocationINTERNAL)            /* 594 */ \
+  OP(FramebufferTextureMultiviewLayeredANGLE)              /* 595 */ \
+  OP(MaxShaderCompilerThreadsKHR)                          /* 596 */ \
+  OP(CreateAndTexStorage2DSharedImageINTERNALImmediate)    /* 597 */ \
+  OP(BeginSharedImageAccessDirectCHROMIUM)                 /* 598 */ \
+  OP(EndSharedImageAccessDirectCHROMIUM)                   /* 599 */
 
 enum CommandId {
   kOneBeforeStartPoint =
--- a/gpu/command_buffer/common/gles2_cmd_utils.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/common/gles2_cmd_utils.cc	2019-05-17 18:53:32.976000000 +0300
@@ -1759,19 +1759,6 @@
 }
 
 // static
-bool GLES2Util::IsFloat32Format(uint32_t internal_format) {
-  switch (internal_format) {
-    case GL_R32F:
-    case GL_RG32F:
-    case GL_RGB32F:
-    case GL_RGBA32F:
-      return true;
-    default:
-      return false;
-  }
-}
-
-// static
 uint32_t GLES2Util::ConvertToSizedFormat(uint32_t format, uint32_t type) {
   switch (format) {
     case GL_RGB:
--- a/gpu/command_buffer/common/gles2_cmd_utils.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/common/gles2_cmd_utils.h	2019-05-17 18:53:32.976000000 +0300
@@ -218,7 +218,6 @@
   static bool IsSignedIntegerFormat(uint32_t internal_format);
   static bool IsIntegerFormat(uint32_t internal_format);
   static bool IsFloatFormat(uint32_t internal_format);
-  static bool IsFloat32Format(uint32_t internal_format);
   static uint32_t ConvertToSizedFormat(uint32_t format, uint32_t type);
   static bool IsSizedColorFormat(uint32_t internal_format);
 
--- a/gpu/command_buffer/common/gpu_memory_buffer_support.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/common/gpu_memory_buffer_support.cc	2019-05-17 18:53:32.976000000 +0300
@@ -106,19 +106,4 @@
   return found ? gpu::GetPlatformSpecificTextureTarget() : GL_TEXTURE_2D;
 }
 
-GPU_EXPORT bool NativeBufferNeedsPlatformSpecificTextureTarget(
-    gfx::BufferFormat format) {
-#if defined(USE_OZONE)
-  // Always use GL_TEXTURE_2D as the target for RGB textures.
-  // https://crbug.com/916728
-  if (format == gfx::BufferFormat::R_8 || format == gfx::BufferFormat::RG_88 ||
-      format == gfx::BufferFormat::RGBA_8888 ||
-      format == gfx::BufferFormat::RGBX_8888 ||
-      format == gfx::BufferFormat::BGRX_8888) {
-    return false;
-  }
-#endif
-  return true;
-}
-
 }  // namespace gpu
--- a/gpu/command_buffer/common/gpu_memory_buffer_support.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/common/gpu_memory_buffer_support.h	2019-05-17 18:53:32.976000000 +0300
@@ -63,11 +63,6 @@
                                            gfx::BufferFormat format,
                                            const Capabilities& capabilities);
 
-// Returns whether a native GMB with the given format needs to be bound to the
-// platform-specfic texture target or GL_TEXTURE_2D.
-GPU_EXPORT bool NativeBufferNeedsPlatformSpecificTextureTarget(
-    gfx::BufferFormat format);
-
 }  // namespace gpu
 
 #endif  // GPU_COMMAND_BUFFER_COMMON_GPU_MEMORY_BUFFER_SUPPORT_H_
--- a/gpu/command_buffer/common/id_type_unittest.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/common/id_type_unittest.cc	2019-05-17 18:53:32.976000000 +0300
@@ -188,7 +188,7 @@
   EXPECT_EQ(map[other_id()], "other_id");
 }
 
-INSTANTIATE_TEST_SUITE_P(,
+INSTANTIATE_TEST_CASE_P(,
                          IdTypeSpecificValueTest,
                          ::testing::Values(std::numeric_limits<int>::min(),
                                            -1,
--- a/gpu/command_buffer/common/raster_cmd_format_autogen.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/common/raster_cmd_format_autogen.h	2019-05-17 18:53:32.980000000 +0300
@@ -375,11 +375,13 @@
   void Init(GLuint _sk_color,
             GLuint _msaa_sample_count,
             GLboolean _can_use_lcd_text,
+            GLuint _color_space_transfer_cache_id,
             const GLbyte* _mailbox) {
     SetHeader();
     sk_color = _sk_color;
     msaa_sample_count = _msaa_sample_count;
     can_use_lcd_text = _can_use_lcd_text;
+    color_space_transfer_cache_id = _color_space_transfer_cache_id;
     memcpy(ImmediateDataAddress(this), _mailbox, ComputeDataSize());
   }
 
@@ -387,9 +389,11 @@
             GLuint _sk_color,
             GLuint _msaa_sample_count,
             GLboolean _can_use_lcd_text,
+            GLuint _color_space_transfer_cache_id,
             const GLbyte* _mailbox) {
-    static_cast<ValueType*>(cmd)->Init(_sk_color, _msaa_sample_count,
-                                       _can_use_lcd_text, _mailbox);
+    static_cast<ValueType*>(cmd)->Init(
+        _sk_color, _msaa_sample_count, _can_use_lcd_text,
+        _color_space_transfer_cache_id, _mailbox);
     const uint32_t size = ComputeSize();
     return NextImmediateCmdAddressTotalSize<ValueType>(cmd, size);
   }
@@ -398,10 +402,11 @@
   uint32_t sk_color;
   uint32_t msaa_sample_count;
   uint32_t can_use_lcd_text;
+  uint32_t color_space_transfer_cache_id;
 };
 
-static_assert(sizeof(BeginRasterCHROMIUMImmediate) == 16,
-              "size of BeginRasterCHROMIUMImmediate should be 16");
+static_assert(sizeof(BeginRasterCHROMIUMImmediate) == 20,
+              "size of BeginRasterCHROMIUMImmediate should be 20");
 static_assert(offsetof(BeginRasterCHROMIUMImmediate, header) == 0,
               "offset of BeginRasterCHROMIUMImmediate header should be 0");
 static_assert(offsetof(BeginRasterCHROMIUMImmediate, sk_color) == 4,
@@ -412,6 +417,10 @@
 static_assert(
     offsetof(BeginRasterCHROMIUMImmediate, can_use_lcd_text) == 12,
     "offset of BeginRasterCHROMIUMImmediate can_use_lcd_text should be 12");
+static_assert(offsetof(BeginRasterCHROMIUMImmediate,
+                       color_space_transfer_cache_id) == 16,
+              "offset of BeginRasterCHROMIUMImmediate "
+              "color_space_transfer_cache_id should be 16");
 
 struct RasterCHROMIUM {
   typedef RasterCHROMIUM ValueType;
--- a/gpu/command_buffer/common/raster_cmd_format_test_autogen.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/common/raster_cmd_format_test_autogen.h	2019-05-17 18:53:32.980000000 +0300
@@ -155,7 +155,7 @@
       *GetBufferAs<cmds::BeginRasterCHROMIUMImmediate>();
   void* next_cmd =
       cmd.Set(&cmd, static_cast<GLuint>(11), static_cast<GLuint>(12),
-              static_cast<GLboolean>(13), data);
+              static_cast<GLboolean>(13), static_cast<GLuint>(14), data);
   EXPECT_EQ(static_cast<uint32_t>(cmds::BeginRasterCHROMIUMImmediate::kCmdId),
             cmd.header.command);
   EXPECT_EQ(sizeof(cmd) + RoundSizeToMultipleOfEntries(sizeof(data)),
@@ -163,6 +163,7 @@
   EXPECT_EQ(static_cast<GLuint>(11), cmd.sk_color);
   EXPECT_EQ(static_cast<GLuint>(12), cmd.msaa_sample_count);
   EXPECT_EQ(static_cast<GLboolean>(13), cmd.can_use_lcd_text);
+  EXPECT_EQ(static_cast<GLuint>(14), cmd.color_space_transfer_cache_id);
   CheckBytesWrittenMatchesExpectedSize(
       next_cmd, sizeof(cmd) + RoundSizeToMultipleOfEntries(sizeof(data)));
 }
--- a/gpu/command_buffer/common/shared_image_usage.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/common/shared_image_usage.h	2019-05-17 18:53:32.980000000 +0300
@@ -24,8 +24,6 @@
   // TODO(backer): Fold back into SHARED_IMAGE_USAGE_RASTER once RasterInterface
   // can CPU raster (CopySubImage?) to SkImage.
   SHARED_IMAGE_USAGE_OOP_RASTERIZATION = 1 << 5,
-  // Image will be used for RGB emulation in WebGL on Mac.
-  SHARED_IMAGE_USAGE_RGB_EMULATION = 1 << 6,
 };
 
 }  // namespace gpu
--- a/gpu/command_buffer/gles2_cmd_buffer_functions.txt	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/gles2_cmd_buffer_functions.txt	2019-05-17 18:53:32.984000000 +0300
@@ -242,7 +242,6 @@
 GL_APICALL void         GL_APIENTRY glWaitSync (GLsync sync, GLbitfieldSyncFlushFlags flags, GLuint64 timeout);
 GL_APICALL void         GL_APIENTRY glBlitFramebufferCHROMIUM (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenumBlitFilter filter);
 GL_APICALL void         GL_APIENTRY glRenderbufferStorageMultisampleCHROMIUM (GLenumRenderBufferTarget target, GLsizei samples, GLenumRenderBufferFormat internalformat, GLsizei width, GLsizei height);
-GL_APICALL void         GL_APIENTRY glRenderbufferStorageMultisampleAdvancedAMD (GLenumRenderBufferTarget target, GLsizei samples, GLsizei storageSamples, GLenumRenderBufferFormat internalformat, GLsizei width, GLsizei height);
 GL_APICALL void         GL_APIENTRY glRenderbufferStorageMultisampleEXT (GLenumRenderBufferTarget target, GLsizei samples, GLenumRenderBufferFormat internalformat, GLsizei width, GLsizei height);
 GL_APICALL void         GL_APIENTRY glFramebufferTexture2DMultisampleEXT (GLenumFramebufferTarget target, GLenumAttachment attachment, GLenumTextureTarget textarget, GLidTexture texture, GLint level, GLsizei samples);
 GL_APICALL void         GL_APIENTRY glTexStorage2DEXT (GLenumTextureBindTarget target, GLsizei levels, GLenumTextureInternalFormatStorage internalFormat, GLsizei width, GLsizei height);
@@ -272,13 +271,6 @@
 
 GL_APICALL void         GL_APIENTRY glBindImageTexture (GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format);
 GL_APICALL void         GL_APIENTRY glDispatchCompute (GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z);
-
-GL_APICALL void         GL_APIENTRY glGetProgramInterfaceiv (GLidProgram program, GLenum program_interface, GLenum pname, GLint* params);
-GL_APICALL GLuint       GL_APIENTRY glGetProgramResourceIndex (GLidProgram program, GLenum program_interface, const char* name);
-GL_APICALL void         GL_APIENTRY glGetProgramResourceName (GLidProgram program, GLenum program_interface, GLuint index, GLsizeiNotNegative bufsize, GLsizeiOptional* length, char* name);
-GL_APICALL void         GL_APIENTRY glGetProgramResourceiv (GLidProgram program, GLenum program_interface, GLuint index, GLsizeiNotNegative prop_count, const GLenum* props, GLsizeiNotNegative bufsize, GLsizeiOptional* length, GLint* params);
-GL_APICALL GLint        GL_APIENTRY glGetProgramResourceLocation (GLidProgram program, GLenum program_interface, const char* name);
-
 GL_APICALL void         GL_APIENTRY glMemoryBarrierEXT (GLbitfield barriers);
 GL_APICALL void         GL_APIENTRY glMemoryBarrierByRegion (GLbitfield barriers);
 
@@ -430,7 +422,6 @@
 
 // Extension CHROMIUM_shared_image
 GL_APICALL GLuint       GL_APIENTRY glCreateAndTexStorage2DSharedImageCHROMIUM (const GLbyte* mailbox);
-GL_APICALL GLuint       GL_APIENTRY glCreateAndTexStorage2DSharedImageWithInternalFormatCHROMIUM (const GLbyte* mailbox, GLenum internalformat);
-GL_APICALL void         GL_APIENTRY glCreateAndTexStorage2DSharedImageINTERNAL (GLuint texture, const GLbyte* mailbox, GLenum internalformat);
+GL_APICALL void         GL_APIENTRY glCreateAndTexStorage2DSharedImageINTERNAL (GLuint texture, const GLbyte* mailbox);
 GL_APICALL void         GL_APIENTRY glBeginSharedImageAccessDirectCHROMIUM (GLuint texture, GLenumSharedImageAccessMode mode);
 GL_APICALL void         GL_APIENTRY glEndSharedImageAccessDirectCHROMIUM (GLuint texture);
--- a/gpu/command_buffer/raster_cmd_buffer_functions.txt	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/raster_cmd_buffer_functions.txt	2019-05-17 18:53:32.984000000 +0300
@@ -26,7 +26,7 @@
 GL_APICALL GLenum	GL_APIENTRY glGetGraphicsResetStatusKHR (void);
 
 // Extension CHROMIUM_raster_transport
-GL_APICALL void         GL_APIENTRY glBeginRasterCHROMIUM (GLuint sk_color, GLuint msaa_sample_count, GLboolean can_use_lcd_text, const GLbyte* mailbox);
+GL_APICALL void         GL_APIENTRY glBeginRasterCHROMIUM (GLuint sk_color, GLuint msaa_sample_count, GLboolean can_use_lcd_text, GLuint color_space_transfer_cache_id, const GLbyte* mailbox);
 GL_APICALL void         GL_APIENTRY glRasterCHROMIUM (GLuint raster_shm_id, GLuint raster_shm_offset, GLuint raster_shm_size, GLuint font_shm_id, GLuint font_shm_offset, GLuint font_shm_size);
 GL_APICALL void         GL_APIENTRY glEndRasterCHROMIUM (void);
 GL_APICALL void         GL_APIENTRY glCreateTransferCacheEntryINTERNAL (GLuint entry_type, GLuint entry_id, GLuint handle_shm_id, GLuint handle_shm_offset, GLuint data_shm_id, GLuint data_shm_offset, GLuint data_size);
--- a/gpu/command_buffer/service/buffer_manager.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/buffer_manager.h	2019-05-17 18:53:32.984000000 +0300
@@ -14,6 +14,7 @@
 #include <unordered_map>
 #include <vector>
 
+#include "base/debug/stack_trace.h"
 #include "base/logging.h"
 #include "base/macros.h"
 #include "base/memory/ref_counted.h"
--- a/gpu/command_buffer/service/BUILD.gn	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/BUILD.gn	2019-05-17 18:53:32.984000000 +0300
@@ -6,7 +6,6 @@
 import("//build/config/ui.gni")
 import("//gpu/vulkan/features.gni")
 import("//third_party/protobuf/proto_library.gni")
-import("//ui/gl/features.gni")
 
 group("service") {
   if (is_component_build) {
@@ -257,8 +256,6 @@
     "webgpu_cmd_validation_implementation_autogen.h",
     "webgpu_decoder.cc",
     "webgpu_decoder.h",
-    "webgpu_decoder_impl.cc",
-    "webgpu_decoder_impl.h",
     "wrapped_sk_image.cc",
     "wrapped_sk_image.h",
   ]
@@ -275,18 +272,17 @@
   include_dirs = [ "//third_party/mesa_headers" ]
 
   public_deps = [
-    "//cc/paint",
     "//gpu/command_buffer/common",
     "//gpu/command_buffer/common:gles2_sources",
     "//gpu/command_buffer/common:raster_sources",
     "//gpu/command_buffer/common:webgpu_sources",
-    "//skia",
   ]
   deps = [
     ":disk_cache_proto",
     ":service",
     "//base",
     "//base/third_party/dynamic_annotations",
+    "//cc/paint",
     "//components/viz/common:resource_format_utils",
     "//gpu/command_buffer/client",
     "//gpu/command_buffer/common:gles2_utils",
@@ -308,38 +304,12 @@
   ]
 
   if (enable_vulkan) {
-    deps += [
-      "//components/viz/common:vulkan_context_provider",
-      "//gpu/vulkan",
-    ]
-
-    if (is_linux) {
-      sources += [
-        "external_vk_image_backing.cc",
-        "external_vk_image_backing.h",
-        "external_vk_image_factory.cc",
-        "external_vk_image_factory.h",
-        "external_vk_image_gl_representation.cc",
-        "external_vk_image_gl_representation.h",
-        "external_vk_image_skia_representation.cc",
-        "external_vk_image_skia_representation.h",
-      ]
-    }
-  }
-
-  if (use_dawn) {
-    deps += [ "//third_party/dawn:libdawn_native" ]
+    deps += [ "//components/viz/common:vulkan_context_provider" ]
   }
 
   if (is_mac) {
-    sources += [
-      "shared_image_backing_factory_iosurface.h",
-      "shared_image_backing_factory_iosurface.mm",
-    ]
-
     # Required by gles2_cmd_decoder.cc on Mac.
     libs = [
-      "Cocoa.framework",
       "IOSurface.framework",
       "OpenGL.framework",
     ]
--- a/gpu/command_buffer/service/command_buffer_direct.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/command_buffer_direct.cc	2019-05-17 18:53:32.988000000 +0300
@@ -16,8 +16,9 @@
 
 }  // anonymous namespace
 
-CommandBufferDirect::CommandBufferDirect()
-    : service_(this, nullptr),
+CommandBufferDirect::CommandBufferDirect(
+    TransferBufferManager* transfer_buffer_manager)
+    : service_(this, transfer_buffer_manager),
       command_buffer_id_(
           CommandBufferId::FromUnsafeValue(g_next_command_buffer_id++)) {}
 
@@ -48,8 +49,6 @@
 
 void CommandBufferDirect::Flush(int32_t put_offset) {
   DCHECK(handler_);
-  if (GetLastState().error != gpu::error::kNoError)
-    return;
   service_.Flush(put_offset, handler_);
 }
 
@@ -103,8 +102,4 @@
   return service_.CreateTransferBufferWithId(size, id);
 }
 
-void CommandBufferDirect::HandleReturnData(base::span<const uint8_t> data) {
-  NOTIMPLEMENTED();
-}
-
 }  // namespace gpu
--- a/gpu/command_buffer/service/command_buffer_direct.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/command_buffer_direct.h	2019-05-17 18:53:32.988000000 +0300
@@ -15,16 +15,17 @@
 namespace gpu {
 
 class AsyncAPIInterface;
+class TransferBufferManager;
 
 class GPU_EXPORT CommandBufferDirect : public CommandBuffer,
                                        public CommandBufferServiceClient,
                                        public DecoderClient {
  public:
-  CommandBufferDirect();
+  explicit CommandBufferDirect(TransferBufferManager* transfer_buffer_manager);
   ~CommandBufferDirect() override;
 
   void set_handler(AsyncAPIInterface* handler) { handler_ = handler; }
-  CommandBufferService* service() { return &service_; }
+  CommandBufferServiceBase* service() { return &service_; }
 
   // CommandBuffer implementation:
   CommandBuffer::State GetLastState() override;
@@ -39,7 +40,7 @@
                                              int32_t* id) override;
   void DestroyTransferBuffer(int32_t id) override;
 
-  // CommandBufferServiceClient implementation:
+  // CommandBufferServiceBase implementation:
   CommandBatchProcessedResult OnCommandBatchProcessed() override;
   void OnParseError() override;
 
@@ -51,7 +52,6 @@
   void OnRescheduleAfterFinished() override;
   void OnSwapBuffers(uint64_t swap_id, uint32_t flags) override;
   void ScheduleGrContextCleanup() override {}
-  void HandleReturnData(base::span<const uint8_t> data) override;
 
   scoped_refptr<Buffer> CreateTransferBufferWithId(uint32_t size, int32_t id);
 
--- a/gpu/command_buffer/service/command_buffer_service.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/command_buffer_service.cc	2019-05-17 18:53:32.988000000 +0300
@@ -18,12 +18,12 @@
 
 namespace gpu {
 
-CommandBufferService::CommandBufferService(CommandBufferServiceClient* client,
-                                           MemoryTracker* memory_tracker)
-    : client_(client),
-      transfer_buffer_manager_(
-          std::make_unique<TransferBufferManager>(memory_tracker)) {
+CommandBufferService::CommandBufferService(
+    CommandBufferServiceClient* client,
+    TransferBufferManager* transfer_buffer_manager)
+    : client_(client), transfer_buffer_manager_(transfer_buffer_manager) {
   DCHECK(client_);
+  DCHECK(transfer_buffer_manager_);
   state_.token = 0;
 }
 
@@ -204,8 +204,4 @@
   scheduled_ = scheduled;
 }
 
-size_t CommandBufferService::GetSharedMemoryBytesAllocated() const {
-  return transfer_buffer_manager_->shared_memory_bytes_allocated();
-}
-
 }  // namespace gpu
--- a/gpu/command_buffer/service/command_buffer_service.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/command_buffer_service.h	2019-05-17 18:53:32.988000000 +0300
@@ -18,7 +18,6 @@
 
 namespace gpu {
 
-class MemoryTracker;
 class TransferBufferManager;
 
 class GPU_EXPORT CommandBufferServiceBase {
@@ -74,7 +73,7 @@
   static const int kParseCommandsSlice = 20;
 
   CommandBufferService(CommandBufferServiceClient* client,
-                       MemoryTracker* memory_tracker);
+                       TransferBufferManager* transfer_buffer_manager);
   ~CommandBufferService() override;
 
   // CommandBufferServiceBase implementation:
@@ -124,11 +123,9 @@
     state_.get_offset = get_offset;
   }
 
-  size_t GetSharedMemoryBytesAllocated() const;
-
  private:
   CommandBufferServiceClient* client_;
-  std::unique_ptr<TransferBufferManager> transfer_buffer_manager_;
+  TransferBufferManager* transfer_buffer_manager_;
 
   CommandBuffer::State state_;
   int32_t put_offset_ = 0;
--- a/gpu/command_buffer/service/command_buffer_service_unittest.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/command_buffer_service_unittest.cc	2019-05-17 18:53:32.988000000 +0300
@@ -12,6 +12,7 @@
 #include "gpu/command_buffer/client/client_test_helper.h"
 #include "gpu/command_buffer/service/command_buffer_service.h"
 #include "gpu/command_buffer/service/mocks.h"
+#include "gpu/command_buffer/service/transfer_buffer_manager.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
 namespace gpu {
@@ -42,8 +43,9 @@
   // Creates a CommandBufferService, with a buffer of the specified size (in
   // entries).
   void MakeService(unsigned int entry_count) {
-    command_buffer_service_ =
-        std::make_unique<CommandBufferService>(this, nullptr);
+    transfer_buffer_manager_ = std::make_unique<TransferBufferManager>(nullptr);
+    command_buffer_service_ = std::make_unique<CommandBufferService>(
+        this, transfer_buffer_manager_.get());
     api_mock_.reset(new AsyncAPIMock(false, command_buffer_service_.get()));
     SetNewGetBuffer(entry_count * sizeof(CommandBufferEntry));
   }
@@ -93,6 +95,7 @@
   MOCK_METHOD0(OnParseError, void());
 
  private:
+  std::unique_ptr<TransferBufferManager> transfer_buffer_manager_;
   std::unique_ptr<CommandBufferService> command_buffer_service_;
   std::unique_ptr<AsyncAPIMock> api_mock_;
   scoped_refptr<Buffer> buffer_;
--- a/gpu/command_buffer/service/context_group.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/context_group.cc	2019-05-17 18:53:32.988000000 +0300
@@ -24,6 +24,7 @@
 #include "gpu/command_buffer/service/shader_manager.h"
 #include "gpu/command_buffer/service/shared_image_factory.h"
 #include "gpu/command_buffer/service/texture_manager.h"
+#include "gpu/command_buffer/service/transfer_buffer_manager.h"
 #include "gpu/config/gpu_preferences.h"
 #include "ui/gl/gl_bindings.h"
 #include "ui/gl/gl_version_info.h"
@@ -56,7 +57,6 @@
     adjusted_disallowed_features.oes_texture_float_linear = true;
     adjusted_disallowed_features.ext_color_buffer_half_float = true;
     adjusted_disallowed_features.oes_texture_half_float_linear = true;
-    adjusted_disallowed_features.ext_float_blend = true;
   }
   return adjusted_disallowed_features;
 }
@@ -128,6 +128,8 @@
   DCHECK(discardable_manager);
   DCHECK(feature_info_);
   DCHECK(mailbox_manager_);
+  transfer_buffer_manager_ =
+      std::make_unique<TransferBufferManager>(memory_tracker_.get());
   use_passthrough_cmd_decoder_ = supports_passthrough_command_decoders &&
                                  gpu_preferences_.use_passthrough_cmd_decoder;
 }
@@ -172,15 +174,6 @@
   feature_info_->Initialize(context_type, use_passthrough_cmd_decoder_,
                             adjusted_disallowed_features);
 
-  // Fail early if ES3 is requested and driver does not support it.
-  if ((context_type == CONTEXT_TYPE_WEBGL2 ||
-       context_type == CONTEXT_TYPE_OPENGLES3) &&
-      !feature_info_->IsES3Capable()) {
-    LOG(ERROR) << "ContextResult::kFatalFailure: "
-               << "ES3 is blacklisted/disabled/unsupported by driver.";
-    return gpu::ContextResult::kFatalFailure;
-  }
-
   const GLint kMinRenderbufferSize = 512;  // GL says 1 pixel!
   GLint max_renderbuffer_size = 0;
   if (!QueryGLFeature(
--- a/gpu/command_buffer/service/context_group.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/context_group.h	2019-05-17 18:53:32.988000000 +0300
@@ -33,6 +33,7 @@
 class ImageFactory;
 struct GpuPreferences;
 class MailboxManager;
+class TransferBufferManager;
 class SharedImageManager;
 class SharedImageRepresentationFactory;
 class ServiceDiscardableManager;
@@ -198,6 +199,10 @@
     return shader_manager_.get();
   }
 
+  TransferBufferManager* transfer_buffer_manager() const {
+    return transfer_buffer_manager_.get();
+  }
+
   SamplerManager* sampler_manager() const {
     return sampler_manager_.get();
   }
@@ -269,6 +274,7 @@
   std::unique_ptr<MemoryTracker> memory_tracker_;
   ShaderTranslatorCache* shader_translator_cache_;
   FramebufferCompletenessCache* framebuffer_completeness_cache_;
+  std::unique_ptr<TransferBufferManager> transfer_buffer_manager_;
 
   bool enforce_gl_minimums_;
   bool bind_generates_resource_;
--- a/gpu/command_buffer/service/copy_texture_chromium_mock.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/copy_texture_chromium_mock.h	2019-05-17 18:53:32.988000000 +0300
@@ -54,7 +54,7 @@
       GLsizei width,
       GLsizei height,
       GLuint source_framebuffer,
-      GLenum source_framebuffer_internal_format) override {}
+      GLenum source_framebuffer_internal_format) override{};
 
  private:
   DISALLOW_COPY_AND_ASSIGN(MockCopyTexImageResourceManager);
@@ -141,7 +141,7 @@
       bool unpremultiply_alpha,
       bool dither,
       const GLfloat transform_matrix[16],
-      CopyTexImageResourceManager* luma_emulation_blitter) override {}
+      CopyTexImageResourceManager* luma_emulation_blitter) override{};
   void DoCopyTextureWithTransform(
       DecoderContext* decoder,
       GLenum source_target,
@@ -160,7 +160,7 @@
       bool dither,
       const GLfloat transform_matrix[16],
       CopyTextureMethod method,
-      CopyTexImageResourceManager* luma_emulation_blitter) override {}
+      CopyTexImageResourceManager* luma_emulation_blitter) override{};
 
  private:
   DISALLOW_COPY_AND_ASSIGN(MockCopyTextureResourceManager);
--- a/gpu/command_buffer/service/decoder_client.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/decoder_client.h	2019-05-17 18:53:32.988000000 +0300
@@ -9,7 +9,6 @@
 
 #include <string>
 
-#include "base/containers/span.h"
 #include "gpu/gpu_export.h"
 #include "url/gurl.h"
 
@@ -49,9 +48,6 @@
   virtual void ScheduleGrContextCleanup() = 0;
 
   virtual void SetActiveURL(GURL url) {}
-
-  // Called by the decoder to pass a variable-size block of data to the client.
-  virtual void HandleReturnData(base::span<const uint8_t> data) = 0;
 };
 
 }  // namespace gpu
--- a/gpu/command_buffer/service/decoder_context.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/decoder_context.h	2019-05-17 18:53:32.988000000 +0300
@@ -154,7 +154,6 @@
 
   //
   // Methods required by GLES2DecoderHelper.
-  // Only functional for GLES2 Decoders.
   //
   virtual gles2::ContextGroup* GetContextGroup() = 0;
   virtual gles2::ErrorState* GetErrorState() = 0;
@@ -220,13 +219,6 @@
 
   // Restores texture states for a given service id.
   virtual void RestoreTextureState(unsigned service_id) = 0;
-
-  //
-  // Methods required by ImageDecodeAcceleratorStub
-  //
-  // Returns the ID of a RasterDecoder. This is not applicable to other
-  // implementations and it returns a negative number in that case.
-  virtual int GetRasterDecoderId() const = 0;
 };
 
 }  // namespace gpu
--- a/gpu/command_buffer/service/error_state.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/error_state.cc	2019-05-17 18:53:32.988000000 +0300
@@ -172,9 +172,9 @@
   } else {
     SetGLError(
         filename, line, error, function_name,
-        (std::string("trying to set ") + GLES2Util::GetStringEnum(pname) +
-         " to " + base::NumberToString(param))
-            .c_str());
+        (std::string("trying to set ") +
+         GLES2Util::GetStringEnum(pname) + " to " +
+         base::IntToString(param)).c_str());
   }
 }
 
--- a/gpu/command_buffer/service/feature_info.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/feature_info.cc	2019-05-17 18:53:32.992000000 +0300
@@ -262,6 +262,15 @@
   disallowed_features_ = disallowed_features;
   context_type_ = context_type;
   is_passthrough_cmd_decoder_ = is_passthrough_cmd_decoder;
+  switch (context_type) {
+    case CONTEXT_TYPE_WEBGL1:
+    case CONTEXT_TYPE_OPENGLES2:
+      break;
+    default:
+      // https://crbug.com/826509
+      workarounds_.use_client_side_arrays_for_stream_buffers = false;
+      break;
+  }
   InitializeFeatures();
   initialized_ = true;
 }
@@ -326,13 +335,6 @@
   }
 }
 
-void FeatureInfo::EnableEXTFloatBlend() {
-  if (!feature_flags_.ext_float_blend) {
-    AddExtensionString("GL_EXT_float_blend");
-    feature_flags_.ext_float_blend = true;
-  }
-}
-
 void FeatureInfo::EnableEXTColorBufferFloat() {
   if (!ext_color_buffer_float_available_)
     return;
@@ -1560,16 +1562,6 @@
       AddExtensionString("GL_WEBGL_multi_draw_instanced");
     }
   }
-
-  if (gfx::HasExtension(extensions, "GL_NV_internalformat_sample_query")) {
-    feature_flags_.nv_internalformat_sample_query = true;
-  }
-
-  if (gfx::HasExtension(extensions,
-                        "GL_AMD_framebuffer_multisample_advanced")) {
-    feature_flags_.amd_framebuffer_multisample_advanced = true;
-    AddExtensionString("GL_AMD_framebuffer_multisample_advanced");
-  }
 }
 
 void FeatureInfo::InitializeFloatAndHalfFloatFeatures(
@@ -1673,14 +1665,6 @@
     }
   }
 
-  // Assume all desktop (!gl_version_info_->is_es) supports float blend
-  if (!gl_version_info_->is_es ||
-      gfx::HasExtension(extensions, "GL_EXT_float_blend")) {
-    if (!disallowed_features_.ext_float_blend) {
-      EnableEXTFloatBlend();
-    }
-  }
-
   if (may_enable_chromium_color_buffer_float &&
       !had_native_chromium_color_buffer_float_ext) {
     static_assert(GL_RGBA32F_ARB == GL_RGBA32F &&
--- a/gpu/command_buffer/service/feature_info.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/feature_info.h	2019-05-17 18:53:32.992000000 +0300
@@ -143,9 +143,6 @@
     bool khr_robust_buffer_access_behavior = false;
     bool webgl_multi_draw = false;
     bool webgl_multi_draw_instanced = false;
-    bool nv_internalformat_sample_query = false;
-    bool amd_framebuffer_multisample_advanced = false;
-    bool ext_float_blend = false;
   };
 
   FeatureInfo();
@@ -204,7 +201,6 @@
   void EnableCHROMIUMTextureStorageImage();
   void EnableCHROMIUMColorBufferFloatRGBA();
   void EnableCHROMIUMColorBufferFloatRGB();
-  void EnableEXTFloatBlend();
   void EnableEXTColorBufferFloat();
   void EnableEXTColorBufferHalfFloat();
   void EnableOESTextureFloatLinear();
--- a/gpu/command_buffer/service/feature_info_unittest.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/feature_info_unittest.cc	2019-05-17 18:53:32.992000000 +0300
@@ -173,7 +173,7 @@
   ES3_on_Version3_2Compatibility
 };
 
-INSTANTIATE_TEST_SUITE_P(Service,
+INSTANTIATE_TEST_CASE_P(Service,
                          FeatureInfoTest,
                          ::testing::ValuesIn(kGLVersionKinds));
 
@@ -1440,6 +1440,23 @@
   EXPECT_TRUE(info_->validators()->index_type.IsValid(GL_UNSIGNED_INT));
 }
 
+TEST_P(FeatureInfoTest, InitializeVAOsWithClientSideArrays) {
+  gpu::GpuDriverBugWorkarounds workarounds;
+  workarounds.use_client_side_arrays_for_stream_buffers = true;
+  SetupInitExpectationsWithWorkarounds("GL_OES_vertex_array_object",
+                                       workarounds);
+  if (GetContextType() == CONTEXT_TYPE_OPENGLES2) {
+    EXPECT_TRUE(info_->workarounds().use_client_side_arrays_for_stream_buffers);
+    EXPECT_FALSE(info_->feature_flags().native_vertex_array_object);
+  } else {  // CONTEXT_TYPE_OPENGLES3
+    // We only turn on use_client_side_arrays_for_stream_buffers on ES2
+    // contexts. See https://crbug.com/826509.
+    EXPECT_FALSE(
+        info_->workarounds().use_client_side_arrays_for_stream_buffers);
+    EXPECT_TRUE(info_->feature_flags().native_vertex_array_object);
+  }
+}
+
 TEST_P(FeatureInfoTest, InitializeEXT_blend_minmax) {
   SetupInitExpectations("GL_EXT_blend_minmax");
   EXPECT_TRUE(gfx::HasExtension(info_->extensions(), "GL_EXT_blend_minmax"));
--- a/gpu/command_buffer/service/framebuffer_manager.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/framebuffer_manager.cc	2019-05-17 18:53:32.992000000 +0300
@@ -375,14 +375,14 @@
   DCHECK(result.second);
 }
 
-Framebuffer::Framebuffer(FramebufferManager* manager, GLuint service_id)
+Framebuffer::Framebuffer(
+    FramebufferManager* manager, GLuint service_id)
     : manager_(manager),
       deleted_(false),
       service_id_(service_id),
       has_been_bound_(false),
       framebuffer_complete_state_count_id_(0),
       draw_buffer_type_mask_(0u),
-      draw_buffer_float32_mask_(0u),
       draw_buffer_bound_mask_(0u),
       adjusted_draw_buffer_bound_mask_(0u),
       read_buffer_(GL_COLOR_ATTACHMENT0) {
@@ -639,10 +639,6 @@
   return attachments_.find(GL_STENCIL_ATTACHMENT) != attachments_.end();
 }
 
-bool Framebuffer::HasActiveFloat32ColorAttachment() const {
-  return draw_buffer_float32_mask_ != 0u;
-}
-
 GLenum Framebuffer::GetReadBufferInternalFormat() const {
   if (read_buffer_ == GL_NONE)
     return 0;
@@ -947,7 +943,6 @@
 
 void Framebuffer::UpdateDrawBufferMasks() {
   draw_buffer_type_mask_ = 0u;
-  draw_buffer_float32_mask_ = 0u;
   draw_buffer_bound_mask_ = 0u;
   for (uint32_t index = 0; index < manager_->max_color_attachments_; ++index) {
     GLenum draw_buffer = draw_buffers_[index];
@@ -969,10 +964,6 @@
     size_t shift_bits = index * 2;
     draw_buffer_type_mask_ |= base_type << shift_bits;
     draw_buffer_bound_mask_ |= 0x3 << shift_bits;
-
-    if (GLES2Util::IsFloat32Format(internal_format)) {
-      draw_buffer_float32_mask_ |= 0x3 << shift_bits;
-    }
   }
 }
 
--- a/gpu/command_buffer/service/framebuffer_manager.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/framebuffer_manager.h	2019-05-17 18:53:32.992000000 +0300
@@ -155,7 +155,6 @@
   bool HasColorAttachment(int index) const;
   bool HasDepthAttachment() const;
   bool HasStencilAttachment() const;
-  bool HasActiveFloat32ColorAttachment() const;
   GLenum GetDepthFormat() const;
   GLenum GetStencilFormat() const;
   GLenum GetDrawBufferInternalFormat() const;
@@ -296,9 +295,6 @@
   // We have up to 16 draw buffers, each is encoded into 2 bits, total 32 bits:
   // the lowest 2 bits for draw buffer 0, the highest 2 bits for draw buffer 15.
   uint32_t draw_buffer_type_mask_;
-  // Same layout as above, 0x03 if it's 32bit float color attachment, 0x00 if
-  // not
-  uint32_t draw_buffer_float32_mask_;
   // Same layout as above, 2 bits per draw buffer, 0x03 if a draw buffer has a
   // bound image, 0x00 if not.
   uint32_t draw_buffer_bound_mask_;
--- a/gpu/command_buffer/service/gles2_cmd_copy_texture_chromium.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/gles2_cmd_copy_texture_chromium.cc	2019-05-17 18:53:32.996000000 +0300
@@ -43,7 +43,6 @@
   S_FORMAT_RGB_YCBCR_420V_CHROMIUM,
   S_FORMAT_RGB_YCBCR_422_CHROMIUM,
   S_FORMAT_COMPRESSED,
-  S_FORMAT_RGB10_A2,
   NUM_S_FORMAT
 };
 
@@ -186,12 +185,8 @@
     case GL_ETC1_RGB8_OES:
       sourceFormatIndex = S_FORMAT_COMPRESSED;
       break;
-    case GL_RGB10_A2:
-      sourceFormatIndex = S_FORMAT_RGB10_A2;
-      break;
     default:
-      NOTREACHED() << "Invalid source format "
-                   << gl::GLEnums::GetStringEnum(source_format);
+      NOTREACHED();
       break;
   }
 
--- a/gpu/command_buffer/service/gles2_cmd_decoder_autogen.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/gles2_cmd_decoder_autogen.h	2019-05-17 18:53:33.004000000 +0300
@@ -4313,62 +4313,6 @@
   return error::kNoError;
 }
 
-error::Error GLES2DecoderImpl::HandleRenderbufferStorageMultisampleAdvancedAMD(
-    uint32_t immediate_data_size,
-    const volatile void* cmd_data) {
-  const volatile gles2::cmds::RenderbufferStorageMultisampleAdvancedAMD& c =
-      *static_cast<const volatile gles2::cmds::
-                       RenderbufferStorageMultisampleAdvancedAMD*>(cmd_data);
-  if (!features().amd_framebuffer_multisample_advanced) {
-    return error::kUnknownCommand;
-  }
-
-  GLenum target = static_cast<GLenum>(c.target);
-  GLsizei samples = static_cast<GLsizei>(c.samples);
-  GLsizei storageSamples = static_cast<GLsizei>(c.storageSamples);
-  GLenum internalformat = static_cast<GLenum>(c.internalformat);
-  GLsizei width = static_cast<GLsizei>(c.width);
-  GLsizei height = static_cast<GLsizei>(c.height);
-  if (!validators_->render_buffer_target.IsValid(target)) {
-    LOCAL_SET_GL_ERROR_INVALID_ENUM(
-        "glRenderbufferStorageMultisampleAdvancedAMD", target, "target");
-    return error::kNoError;
-  }
-  if (samples < 0) {
-    LOCAL_SET_GL_ERROR(GL_INVALID_VALUE,
-                       "glRenderbufferStorageMultisampleAdvancedAMD",
-                       "samples < 0");
-    return error::kNoError;
-  }
-  if (storageSamples < 0) {
-    LOCAL_SET_GL_ERROR(GL_INVALID_VALUE,
-                       "glRenderbufferStorageMultisampleAdvancedAMD",
-                       "storageSamples < 0");
-    return error::kNoError;
-  }
-  if (!validators_->render_buffer_format.IsValid(internalformat)) {
-    LOCAL_SET_GL_ERROR_INVALID_ENUM(
-        "glRenderbufferStorageMultisampleAdvancedAMD", internalformat,
-        "internalformat");
-    return error::kNoError;
-  }
-  if (width < 0) {
-    LOCAL_SET_GL_ERROR(GL_INVALID_VALUE,
-                       "glRenderbufferStorageMultisampleAdvancedAMD",
-                       "width < 0");
-    return error::kNoError;
-  }
-  if (height < 0) {
-    LOCAL_SET_GL_ERROR(GL_INVALID_VALUE,
-                       "glRenderbufferStorageMultisampleAdvancedAMD",
-                       "height < 0");
-    return error::kNoError;
-  }
-  DoRenderbufferStorageMultisampleAdvancedAMD(target, samples, storageSamples,
-                                              internalformat, width, height);
-  return error::kNoError;
-}
-
 error::Error GLES2DecoderImpl::HandleRenderbufferStorageMultisampleEXT(
     uint32_t immediate_data_size,
     const volatile void* cmd_data) {
@@ -4724,12 +4668,6 @@
   return error::kUnknownCommand;
 }
 
-error::Error GLES2DecoderImpl::HandleGetProgramInterfaceiv(
-    uint32_t immediate_data_size,
-    const volatile void* cmd_data) {
-  return error::kUnknownCommand;
-}
-
 error::Error GLES2DecoderImpl::HandleMemoryBarrierEXT(
     uint32_t immediate_data_size,
     const volatile void* cmd_data) {
@@ -5624,11 +5562,10 @@
   }
   volatile const GLbyte* mailbox = GetImmediateDataAs<volatile const GLbyte*>(
       c, mailbox_size, immediate_data_size);
-  GLenum internalformat = static_cast<GLenum>(c.internalformat);
   if (mailbox == nullptr) {
     return error::kOutOfBounds;
   }
-  DoCreateAndTexStorage2DSharedImageINTERNAL(texture, mailbox, internalformat);
+  DoCreateAndTexStorage2DSharedImageINTERNAL(texture, mailbox);
   return error::kNoError;
 }
 
--- a/gpu/command_buffer/service/gles2_cmd_decoder.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/gles2_cmd_decoder.cc	2019-05-17 18:53:33.000000000 +0300
@@ -19,8 +19,6 @@
 #include <unordered_map>
 #include <utility>
 
-#include "base/bind.h"
-#include "base/bind_helpers.h"
 #include "base/callback.h"
 #include "base/callback_helpers.h"
 #include "base/containers/flat_set.h"
@@ -605,11 +603,6 @@
   return outputter_;
 }
 
-int GLES2Decoder::GetRasterDecoderId() const {
-  NOTREACHED();
-  return -1;
-}
-
 // This class implements GLES2Decoder so we don't have to expose all the GLES2
 // cmd stuff to outside this class.
 class GLES2DecoderImpl : public GLES2Decoder, public ErrorStateClient {
@@ -792,13 +785,6 @@
                                             GLsizei width,
                                             GLsizei height,
                                             ForcedMultisampleMode mode);
-  void RenderbufferStorageMultisampleHelperAMD(GLenum target,
-                                               GLsizei samples,
-                                               GLsizei storageSamples,
-                                               GLenum internal_format,
-                                               GLsizei width,
-                                               GLsizei height,
-                                               ForcedMultisampleMode mode);
   bool RegenerateRenderbufferIfNeeded(Renderbuffer* renderbuffer);
 
   PathManager* path_manager() { return group_->path_manager(); }
@@ -842,7 +828,6 @@
   bool InitializeShaderTranslator();
   void DestroyShaderTranslator();
 
-  GLint ComputeMaxSamples();
   void UpdateCapabilities();
 
   // Helpers for the glGen and glDelete functions.
@@ -989,7 +974,6 @@
   // Get the size (in pixels) of the currently bound frame buffer (either FBO
   // or regular back buffer).
   gfx::Size GetBoundReadFramebufferSize();
-  gfx::Size GetBoundDrawFramebufferSize();
 
   // Get the service side ID for the bound read framebuffer.
   // If it's back buffer, 0 is returned.
@@ -1180,8 +1164,7 @@
   void DoCreateAndConsumeTextureINTERNAL(GLuint client_id,
                                          const volatile GLbyte* key);
   void DoCreateAndTexStorage2DSharedImageINTERNAL(GLuint client_id,
-                                                  const volatile GLbyte* data,
-                                                  GLenum internal_format);
+                                                  const volatile GLbyte* data);
   void DoBeginSharedImageAccessDirectCHROMIUM(GLuint client_id, GLenum mode);
   void DoEndSharedImageAccessDirectCHROMIUM(GLuint client_id);
   void DoApplyScreenSpaceAntialiasingCHROMIUM();
@@ -1515,8 +1498,7 @@
       GLenum gl_error,
       const char* func_name);
 
-  bool CheckBoundDrawFramebufferValid(const char* func_name,
-                                      bool check_float_blending = false);
+  bool CheckBoundDrawFramebufferValid(const char* func_name);
   // Generates |gl_error| if the bound read fbo is incomplete.
   bool CheckBoundReadFramebufferValid(const char* func_name, GLenum gl_error);
   // This is only used by DoBlitFramebufferCHROMIUM which operates read/draw
@@ -1939,14 +1921,6 @@
       GLenum target, GLsizei samples, GLenum internalformat,
       GLsizei width, GLsizei height);
 
-  // Handler for glRenderbufferStorageMultisampleAdvancedAMD.
-  void DoRenderbufferStorageMultisampleAdvancedAMD(GLenum target,
-                                                   GLsizei samples,
-                                                   GLsizei storageSamples,
-                                                   GLenum internalformat,
-                                                   GLsizei width,
-                                                   GLsizei height);
-
   // Handler for glRenderbufferStorageMultisampleEXT
   // (multisampled_render_to_texture).
   void DoRenderbufferStorageMultisampleEXT(
@@ -1956,23 +1930,12 @@
   // Wrapper for glFenceSync.
   GLsync DoFenceSync(GLenum condition, GLbitfield flags);
 
-  GLsizei InternalFormatSampleCountsHelper(
-      GLenum target,
-      GLenum format,
-      std::vector<GLint>* out_sample_counts);
-
   // Common validation for multisample extensions.
   bool ValidateRenderbufferStorageMultisample(GLsizei samples,
                                               GLenum internalformat,
                                               GLsizei width,
                                               GLsizei height);
 
-  // validation for multisample AMD extension.
-  bool ValidateRenderbufferStorageMultisampleAMD(GLsizei samples,
-                                                 GLsizei storageSamples,
-                                                 GLenum internalformat,
-                                                 GLsizei width,
-                                                 GLsizei height);
   // Verifies that the currently bound multisample renderbuffer is valid
   // Very slow! Only done on platforms with driver bugs that return invalid
   // buffers under memory pressure
@@ -3625,8 +3588,12 @@
       group_->max_transform_feedback_separate_attribs(), needs_emulation));
 
   if (feature_info_->IsWebGL2OrES3Context()) {
-    // Verified in ContextGroup.
-    DCHECK(feature_info_->IsES3Capable());
+    if (!feature_info_->IsES3Capable()) {
+      Destroy(true);
+      LOG(ERROR) << "ContextResult::kFatalFailure: "
+                    "ES3 is blacklisted/disabled/unsupported by driver.";
+      return gpu::ContextResult::kFatalFailure;
+    }
     feature_info_->EnableES3Validators();
 
     frag_depth_explicitly_enabled_ = true;
@@ -3647,8 +3614,7 @@
   state_.indexed_uniform_buffer_bindings =
       base::MakeRefCounted<gles2::IndexedBufferBindingHost>(
           group_->max_uniform_buffer_bindings(), GL_UNIFORM_BUFFER,
-          needs_emulation,
-          workarounds().round_down_uniform_bind_buffer_range_size);
+          needs_emulation);
   state_.indexed_uniform_buffer_bindings->SetIsBound(true);
 
   state_.InitGenericAttribs(group_->max_vertex_attribs());
@@ -4188,7 +4154,7 @@
   if (feature_info_->feature_flags().multisampled_render_to_texture ||
       feature_info_->feature_flags().chromium_framebuffer_multisample ||
       feature_info_->IsWebGL2OrES3Context()) {
-    caps.max_samples = ComputeMaxSamples();
+    DoGetIntegerv(GL_MAX_SAMPLES, &caps.max_samples, 1);
   }
 
   caps.num_stencil_bits = num_stencil_bits_;
@@ -4305,40 +4271,6 @@
   return caps;
 }
 
-GLint GLES2DecoderImpl::ComputeMaxSamples() {
-  GLint max_samples = 0;
-  DoGetIntegerv(GL_MAX_SAMPLES, &max_samples, 1);
-
-  if (feature_info_->IsWebGLContext() &&
-      feature_info_->feature_flags().nv_internalformat_sample_query) {
-    std::vector<GLint> temp;
-
-    auto minWithSamplesForFormat = [&](GLenum internalformat) {
-      temp.clear();
-      InternalFormatSampleCountsHelper(GL_RENDERBUFFER, internalformat, &temp);
-      max_samples = std::min(max_samples, temp[0]);
-    };
-
-    // OpenGL ES 3.0.5, section 4.4.2.2: "Implementations must support creation
-    // of renderbuffers in these required formats with up to the value of
-    // MAX_SAMPLES multisamples, with the exception of signed and unsigned
-    // integer formats."
-
-    // OpenGL ES 3.0.5, section 3.8.3.1
-    minWithSamplesForFormat(GL_RGBA8);
-    minWithSamplesForFormat(GL_SRGB8_ALPHA8);
-    minWithSamplesForFormat(GL_RGB10_A2);
-    minWithSamplesForFormat(GL_RGBA4);
-    minWithSamplesForFormat(GL_RGB5_A1);
-    minWithSamplesForFormat(GL_RGB8);
-    minWithSamplesForFormat(GL_RGB565);
-    minWithSamplesForFormat(GL_RG8);
-    minWithSamplesForFormat(GL_R8);
-  }
-
-  return max_samples;
-}
-
 void GLES2DecoderImpl::UpdateCapabilities() {
   util_.set_num_compressed_texture_formats(
       validators_->compressed_texture_format.GetValues().size());
@@ -4945,9 +4877,7 @@
   return true;
 }
 
-bool GLES2DecoderImpl::CheckBoundDrawFramebufferValid(
-    const char* func_name,
-    bool check_float_blending) {
+bool GLES2DecoderImpl::CheckBoundDrawFramebufferValid(const char* func_name) {
   Framebuffer* framebuffer = GetBoundDrawFramebuffer();
   bool valid = CheckFramebufferValid(
       framebuffer, GetDrawFramebufferTarget(),
@@ -4955,19 +4885,6 @@
   if (!valid)
     return false;
 
-  if (check_float_blending) {
-    // only is true when called by DoMultiDrawArrays or DoMultiDrawElements
-    if (framebuffer && state_.GetEnabled(GL_BLEND) &&
-        !features().ext_float_blend) {
-      if (framebuffer->HasActiveFloat32ColorAttachment()) {
-        LOCAL_SET_GL_ERROR(GL_INVALID_OPERATION, func_name,
-                           "GL_BLEND with floating-point color attachments "
-                           "requires the EXT_float_blend extension");
-        return false;
-      }
-    }
-  }
-
   if (!SupportsSeparateFramebufferBinds())
     OnUseFramebuffer();
 
@@ -5041,17 +4958,6 @@
   }
 }
 
-gfx::Size GLES2DecoderImpl::GetBoundDrawFramebufferSize() {
-  Framebuffer* framebuffer = GetBoundDrawFramebuffer();
-  if (framebuffer) {
-    return framebuffer->GetFramebufferValidSize();
-  } else if (offscreen_target_frame_buffer_.get()) {
-    return offscreen_size_;
-  } else {
-    return surface_->GetSize();
-  }
-}
-
 GLuint GLES2DecoderImpl::GetBoundReadFramebufferServiceId() {
   Framebuffer* framebuffer = GetBoundReadFramebuffer();
   if (framebuffer) {
@@ -8752,21 +8658,7 @@
   const char* func_name = "glBlitFramebufferCHROMIUM";
   DCHECK(!ShouldDeferReads() && !ShouldDeferDraws());
 
-  if (!CheckFramebufferValid(GetBoundDrawFramebuffer(),
-                             GetDrawFramebufferTarget(),
-                             GL_INVALID_FRAMEBUFFER_OPERATION, func_name)) {
-    return;
-  }
-
-  // We need to get this before checking if the read framebuffer is valid.
-  // Checking the read framebuffer may clear attachments which would mark the
-  // draw framebuffer as incomplete. Framebuffer::GetFramebufferValidSize()
-  // requires the framebuffer to be complete.
-  gfx::Size draw_size = GetBoundDrawFramebufferSize();
-
-  if (!CheckFramebufferValid(GetBoundReadFramebuffer(),
-                             GetReadFramebufferTarget(),
-                             GL_INVALID_FRAMEBUFFER_OPERATION, func_name)) {
+  if (!CheckBoundFramebufferValid(func_name)) {
     return;
   }
 
@@ -8983,161 +8875,52 @@
 
   if (workarounds().adjust_src_dst_region_for_blitframebuffer) {
     gfx::Size read_size = GetBoundReadFramebufferSize();
+    gfx::Rect src_bounds(0, 0, read_size.width(), read_size.height());
     GLint src_x = srcX1 > srcX0 ? srcX0 : srcX1;
     GLint src_y = srcY1 > srcY0 ? srcY0 : srcY1;
-    unsigned int src_width = base::checked_cast<unsigned int>(
-        src_width_temp.Abs().ValueOrDefault(0));
-    unsigned int src_height = base::checked_cast<unsigned int>(
-        src_height_temp.Abs().ValueOrDefault(0));
+    GLuint src_width = 0, src_height = 0;
+    if (!src_width_temp.Abs().AssignIfValid(&src_width))
+      src_width = 0;
+    if (!src_height_temp.Abs().AssignIfValid(&src_height))
+      src_height = 0;
 
-    GLint dst_x = dstX1 > dstX0 ? dstX0 : dstX1;
-    GLint dst_y = dstY1 > dstY0 ? dstY0 : dstY1;
-    unsigned int dst_width = base::checked_cast<unsigned int>(
-        dst_width_temp.Abs().ValueOrDefault(0));
-    unsigned int dst_height = base::checked_cast<unsigned int>(
-        dst_height_temp.Abs().ValueOrDefault(0));
-
-    if (dst_width == 0 || src_width == 0 || dst_height == 0 ||
-        src_height == 0) {
-      return;
-    }
-
-    gfx::Rect src_bounds(0, 0, read_size.width(), read_size.height());
     gfx::Rect src_region(src_x, src_y, src_width, src_height);
-
-    gfx::Rect dst_bounds(0, 0, draw_size.width(), draw_size.height());
-    gfx::Rect dst_region(dst_x, dst_y, dst_width, dst_height);
-
-    if (gfx::IntersectRects(dst_bounds, dst_region).IsEmpty()) {
-      return;
-    }
-
-    bool x_flipped = ((srcX1 > srcX0) && (dstX1 < dstX0)) ||
-                     ((srcX1 < srcX0) && (dstX1 > dstX0));
-    bool y_flipped = ((srcY1 > srcY0) && (dstY1 < dstY0)) ||
-                     ((srcY1 < srcY0) && (dstY1 > dstY0));
-
-    if (!dst_bounds.Contains(dst_region)) {
-      // dst_region is not within dst_bounds. We want to adjust it to a
-      // reasonable size. This is done by halving the dst_region until it is at
-      // most twice the size of the framebuffer. We cut it in half instead
-      // of arbitrarily shrinking it to fit so that we don't end up with
-      // non-power-of-two scale factors which could mess up pixel interpolation.
-      // Naively clipping the dst rect and then proportionally sizing the
-      // src rect yields incorrect results.
-
-      unsigned int dst_x_halvings = 0;
-      unsigned int dst_y_halvings = 0;
-      int dst_origin_x = dst_x;
-      int dst_origin_y = dst_y;
-
-      int dst_clipped_width = dst_region.width();
-      while (dst_clipped_width > 2 * dst_bounds.width()) {
-        dst_clipped_width = dst_clipped_width >> 1;
-        dst_x_halvings++;
-      }
-
-      int dst_clipped_height = dst_region.height();
-      while (dst_clipped_height > 2 * dst_bounds.height()) {
-        dst_clipped_height = dst_clipped_height >> 1;
-        dst_y_halvings++;
-      }
-
-      // Before this block, we check that the two rectangles intersect.
-      // Now, compute the location of a new region origin such that we use the
-      // scaled dimensions but the new region has the same intersection as the
-      // original region.
-
-      int left = dst_region.x();
-      int right = dst_region.right();
-      int top = dst_region.y();
-      int bottom = dst_region.bottom();
-
-      if (left >= 0 && left < dst_bounds.width()) {
-        // Left edge is in-bounds
-        dst_origin_x = dst_x;
-      } else if (right > 0 && right <= dst_bounds.width()) {
-        // Right edge is in-bounds
-        dst_origin_x = right - dst_clipped_width;
-      } else {
-        // Region completely spans bounds
-        dst_origin_x = dst_x;
-      }
-
-      if (top >= 0 && top < dst_bounds.height()) {
-        // Top edge is in-bounds
-        dst_origin_y = dst_y;
-      } else if (bottom > 0 && bottom <= dst_bounds.height()) {
-        // Bottom edge is in-bounds
-        dst_origin_y = bottom - dst_clipped_height;
-      } else {
-        // Region completely spans bounds
-        dst_origin_y = dst_y;
-      }
-
-      dst_region.SetRect(dst_origin_x, dst_origin_y, dst_clipped_width,
-                         dst_clipped_height);
-
-      // Offsets from the bottom left corner of the original region to
-      // the bottom left corner of the clipped region.
-      // This value (after it is scaled) is the respective offset we will apply
-      // to the src origin.
-      base::CheckedNumeric<unsigned int> checked_xoffset(dst_region.x() -
-                                                         dst_x);
-      base::CheckedNumeric<unsigned int> checked_yoffset(dst_region.y() -
-                                                         dst_y);
-
-      // if X/Y is reversed, use the top/right out-of-bounds region to compute
-      // the origin offset instead of the left/bottom out-of-bounds region
-      if (x_flipped) {
-        checked_xoffset = (dst_x + dst_width - dst_region.right());
-      }
-      if (y_flipped) {
-        checked_yoffset = (dst_y + dst_height - dst_region.bottom());
-      }
-
-      // These offsets should never overflow.
-      unsigned int xoffset, yoffset;
-      if (!checked_xoffset.AssignIfValid(&xoffset) ||
-          !checked_yoffset.AssignIfValid(&yoffset)) {
-        NOTREACHED();
-        LOCAL_SET_GL_ERROR(
-            GL_INVALID_VALUE, func_name,
-            "the width or height of src or dst region overflowed");
-        return;
-      }
-
-      // Adjust the src region by the same factor
-      src_region.SetRect(src_x + (xoffset >> dst_x_halvings),
-                         src_y + (yoffset >> dst_y_halvings),
-                         src_region.width() >> dst_x_halvings,
-                         src_region.height() >> dst_y_halvings);
-
-      // If the src was scaled to 0, set it to 1 so the src is non-empty.
-      if (src_region.width() == 0) {
-        src_region.set_width(1);
-      }
-      if (src_region.height() == 0) {
-        src_region.set_height(1);
-      }
-    }
-
-    if (!src_bounds.Contains(src_region)) {
+    if (!src_bounds.Contains(src_region) &&
+        (src_width != 0) && (src_height != 0)) {
       // If pixels lying outside the read framebuffer, adjust src region
       // and dst region to appropriate in-bounds regions respectively.
-      src_region.Intersect(src_bounds);
-      GLuint src_real_width = src_region.width();
-      GLuint src_real_height = src_region.height();
-      GLuint xoffset = src_region.x() - src_x;
-      GLuint yoffset = src_region.y() - src_y;
+      src_bounds.Intersect(src_region);
+      GLuint src_real_width = src_bounds.width();
+      GLuint src_real_height = src_bounds.height();
+      GLuint xoffset = src_bounds.x() - src_x;
+      GLuint yoffset = src_bounds.y() - src_y;
       // if X/Y is reversed, use the top/right out-of-bounds region for mapping
       // to dst region, instead of left/bottom out-of-bounds region for mapping.
-      if (x_flipped) {
-        xoffset = src_x + src_width - src_region.x() - src_region.width();
+      if (((srcX1 > srcX0) && (dstX1 < dstX0)) ||
+          ((srcX1 < srcX0) && (dstX1 > dstX0))) {
+        xoffset = src_x + src_width - src_bounds.x() - src_bounds.width();
+      }
+      if (((srcY1 > srcY0) && (dstY1 < dstY0)) ||
+          ((srcY1 < srcY0) && (dstY1 > dstY0))) {
+        yoffset = src_y + src_height - src_bounds.y() - src_bounds.height();
       }
-      if (y_flipped) {
-        yoffset = src_y + src_height - src_region.y() - src_region.height();
+
+      GLint dst_x = dstX1 > dstX0 ? dstX0 : dstX1;
+      GLint dst_y = dstY1 > dstY0 ? dstY0 : dstY1;
+      base::CheckedNumeric<GLint> dst_width_temp = dstX1;
+      dst_width_temp -= dstX0;
+      base::CheckedNumeric<GLint> dst_height_temp = dstY1;
+      dst_height_temp -= dstY0;
+      GLuint dst_width = 0, dst_height = 0;
+      if (!dst_width_temp.IsValid() || !dst_height_temp.IsValid()) {
+        LOCAL_SET_GL_ERROR(GL_INVALID_OPERATION, func_name,
+                           "the width or height of dst region overflow");
+        return;
       }
+      if (!dst_width_temp.Abs().AssignIfValid(&dst_width))
+        dst_width = 0;
+      if (!dst_height_temp.Abs().AssignIfValid(&dst_height))
+        dst_height = 0;
 
       GLfloat dst_mapping_width =
           static_cast<GLfloat>(src_real_width) * dst_width / src_width;
@@ -9158,22 +8941,21 @@
       GLuint dst_mapping_y1 =
           std::round(dst_y + dst_mapping_yoffset + dst_mapping_height);
 
-      dst_region.SetRect(dst_mapping_x0, dst_mapping_y0,
-                         dst_mapping_x1 - dst_mapping_x0,
-                         dst_mapping_y1 - dst_mapping_y0);
-    }
-
-    // Set the src and dst endpoints. If they were previously flipped,
-    // set them as flipped.
-    srcX0 = srcX0 < srcX1 ? src_region.x() : src_region.right();
-    srcY0 = srcY0 < srcY1 ? src_region.y() : src_region.bottom();
-    srcX1 = srcX0 < srcX1 ? src_region.right() : src_region.x();
-    srcY1 = srcY0 < srcY1 ? src_region.bottom() : src_region.y();
-
-    dstX0 = dstX0 < dstX1 ? dst_region.x() : dst_region.right();
-    dstY0 = dstY0 < dstY1 ? dst_region.y() : dst_region.bottom();
-    dstX1 = dstX0 < dstX1 ? dst_region.right() : dst_region.x();
-    dstY1 = dstY0 < dstY1 ? dst_region.bottom() : dst_region.y();
+      // adjust the src region and dst region to fit the read framebuffer
+      srcX0 = srcX0 < srcX1 ?
+          src_bounds.x() : src_bounds.x() + src_bounds.width();
+      srcY0 = srcY0 < srcY1 ?
+          src_bounds.y() : src_bounds.y() + src_bounds.height();
+      srcX1 = srcX0 < srcX1 ?
+          src_bounds.x() + src_bounds.width() : src_bounds.x();
+      srcY1 = srcY0 < srcY1 ?
+          src_bounds.y() + src_bounds.height() : src_bounds.y();
+
+      dstX0 = dstX0 < dstX1 ? dst_mapping_x0 : dst_mapping_x1;
+      dstY0 = dstY0 < dstY1 ? dst_mapping_y0 : dst_mapping_y1;
+      dstX1 = dstX0 < dstX1 ? dst_mapping_x1 : dst_mapping_x0;
+      dstY1 = dstY0 < dstY1 ? dst_mapping_y1 : dst_mapping_y0;
+    }
   }
 
   bool enable_srgb =
@@ -9309,18 +9091,6 @@
   }
 }
 
-void GLES2DecoderImpl::RenderbufferStorageMultisampleHelperAMD(
-    GLenum target,
-    GLsizei samples,
-    GLsizei storageSamples,
-    GLenum internal_format,
-    GLsizei width,
-    GLsizei height,
-    ForcedMultisampleMode mode) {
-  api()->glRenderbufferStorageMultisampleAdvancedAMDFn(
-      target, samples, storageSamples, internal_format, width, height);
-}
-
 bool GLES2DecoderImpl::RegenerateRenderbufferIfNeeded(
     Renderbuffer* renderbuffer) {
   if (!renderbuffer->RegenerateAndBindBackingObjectIfNeeded(workarounds())) {
@@ -9369,36 +9139,6 @@
   return true;
 }
 
-bool GLES2DecoderImpl::ValidateRenderbufferStorageMultisampleAMD(
-    GLsizei samples,
-    GLsizei storageSamples,
-    GLenum internalformat,
-    GLsizei width,
-    GLsizei height) {
-  if (samples > renderbuffer_manager()->max_samples()) {
-    LOCAL_SET_GL_ERROR(GL_INVALID_VALUE, "glRenderbufferStorageMultisample",
-                       "samples too large");
-    return false;
-  }
-
-  if (width > renderbuffer_manager()->max_renderbuffer_size() ||
-      height > renderbuffer_manager()->max_renderbuffer_size()) {
-    LOCAL_SET_GL_ERROR(GL_INVALID_VALUE, "glRenderbufferStorageMultisample",
-                       "dimensions too large");
-    return false;
-  }
-
-  uint32_t estimated_size = 0;
-  if (!renderbuffer_manager()->ComputeEstimatedRenderbufferSize(
-          width, height, samples, internalformat, &estimated_size)) {
-    LOCAL_SET_GL_ERROR(GL_OUT_OF_MEMORY, "glRenderbufferStorageMultisample",
-                       "dimensions too large");
-    return false;
-  }
-
-  return true;
-}
-
 void GLES2DecoderImpl::DoRenderbufferStorageMultisampleCHROMIUM(
     GLenum target, GLsizei samples, GLenum internalformat,
     GLsizei width, GLsizei height) {
@@ -9440,51 +9180,6 @@
   }
 }
 
-void GLES2DecoderImpl::DoRenderbufferStorageMultisampleAdvancedAMD(
-    GLenum target,
-    GLsizei samples,
-    GLsizei storageSamples,
-    GLenum internalformat,
-    GLsizei width,
-    GLsizei height) {
-  Renderbuffer* renderbuffer = GetRenderbufferInfoForTarget(GL_RENDERBUFFER);
-  if (!renderbuffer) {
-    LOCAL_SET_GL_ERROR(GL_INVALID_OPERATION,
-                       "glRenderbufferStorageMultisampleAdvancedAMD",
-                       "no renderbuffer bound");
-    return;
-  }
-
-  if (!ValidateRenderbufferStorageMultisampleAMD(
-          samples, storageSamples, internalformat, width, height)) {
-    return;
-  }
-
-  GLenum impl_format =
-      renderbuffer_manager()->InternalRenderbufferFormatToImplFormat(
-          internalformat);
-  LOCAL_COPY_REAL_GL_ERRORS_TO_WRAPPER(
-      "glRenderbufferStorageMultisampleAdvancedAMD");
-  RenderbufferStorageMultisampleHelperAMD(
-      target, samples, storageSamples, impl_format, width, height, kDoNotForce);
-  GLenum error =
-      LOCAL_PEEK_GL_ERROR("glRenderbufferStorageMultisampleAdvancedAMD");
-  if (error == GL_NO_ERROR) {
-    if (workarounds().validate_multisample_buffer_allocation) {
-      if (!VerifyMultisampleRenderbufferIntegrity(renderbuffer->service_id(),
-                                                  impl_format)) {
-        LOCAL_SET_GL_ERROR(GL_OUT_OF_MEMORY,
-                           "glRenderbufferStorageMultisampleAdvancedAMD",
-                           "out of memory");
-        return;
-      }
-    }
-
-    renderbuffer_manager()->SetInfoAndInvalidate(renderbuffer, samples,
-                                                 internalformat, width, height);
-  }
-}
-
 // This is the handler for multisampled_render_to_texture extensions.
 void GLES2DecoderImpl::DoRenderbufferStorageMultisampleEXT(
     GLenum target, GLsizei samples, GLenum internalformat,
@@ -10643,9 +10338,7 @@
       if (texture_unit)
         api()->glActiveTextureFn(texture_unit);
       api()->glBindTextureFn(textarget, texture->service_id());
-      if (image->ShouldBindOrCopy() == gl::GLImage::BIND) {
-        bool rv = image->BindTexImage(textarget);
-        DCHECK(rv) << "BindTexImage() failed";
+      if (image->BindTexImage(textarget)) {
         image_state = Texture::BOUND;
       } else {
         DoCopyTexImage(texture, textarget, image);
@@ -10701,15 +10394,28 @@
           if (!texture_ref) {
             LOCAL_RENDER_WARNING(
                 std::string("there is no texture bound to the unit ") +
-                base::NumberToString(texture_unit_index));
+                base::UintToString(texture_unit_index));
           } else {
             LOCAL_RENDER_WARNING(
                 std::string("texture bound to texture unit ") +
-                base::NumberToString(texture_unit_index) +
+                base::UintToString(texture_unit_index) +
                 " is not renderable. It maybe non-power-of-2 and have"
                 " incompatible texture filtering.");
           }
           continue;
+        } else if (!texture_ref->texture()->CompatibleWithSamplerUniformType(
+                       uniform_info->type)) {
+          LOCAL_SET_GL_ERROR(
+              GL_INVALID_OPERATION, function_name,
+              (std::string("Texture bound to texture unit ") +
+               base::UintToString(texture_unit_index) +
+               " with internal format " +
+               GLES2Util::GetStringEnum(
+                   texture_ref->texture()->GetInternalFormatOfBaseLevel()) +
+               " is not compatible with sampler type " +
+               GLES2Util::GetStringEnum(uniform_info->type))
+                  .c_str());
+          return false;
         }
 
         if (textarget != GL_TEXTURE_CUBE_MAP) {
@@ -11266,7 +10972,7 @@
     return error::kNoError;
   }
 
-  if (!CheckBoundDrawFramebufferValid(function_name, true)) {
+  if (!CheckBoundDrawFramebufferValid(function_name)) {
     return error::kNoError;
   }
 
@@ -11473,7 +11179,7 @@
     return error::kNoError;
   }
 
-  if (!CheckBoundDrawFramebufferValid(function_name, true)) {
+  if (!CheckBoundDrawFramebufferValid(function_name)) {
     return error::kNoError;
   }
 
@@ -11483,14 +11189,6 @@
     return error::kNoError;
   }
 
-  if (state_.bound_transform_feedback.get() &&
-      state_.bound_transform_feedback->active() &&
-      !state_.bound_transform_feedback->paused()) {
-    LOCAL_SET_GL_ERROR(GL_INVALID_OPERATION, function_name,
-                       "transformfeedback is active and not paused");
-    return error::kNoError;
-  }
-
   GLuint total_max_vertex_accessed = 0;
   GLsizei total_max_primcount = 0;
   if (!CheckMultiDrawElementsVertices(
@@ -11504,6 +11202,14 @@
     return error::kNoError;
   }
 
+  if (state_.bound_transform_feedback.get() &&
+      state_.bound_transform_feedback->active() &&
+      !state_.bound_transform_feedback->paused()) {
+    LOCAL_SET_GL_ERROR(GL_INVALID_OPERATION, function_name,
+                       "transformfeedback is active and not paused");
+    return error::kNoError;
+  }
+
   if (feature_info_->IsWebGL2OrES3Context()) {
     if (!AttribsTypeMatch()) {
       LOCAL_SET_GL_ERROR(GL_INVALID_OPERATION, function_name,
@@ -11603,9 +11309,9 @@
       *static_cast<const volatile gles2::cmds::DrawElements*>(cmd_data);
   GLsizei count = static_cast<GLsizei>(c.count);
   int32_t offset = static_cast<int32_t>(c.index_offset);
-  return DoMultiDrawElements("glDrawElements", false,
-                             static_cast<GLenum>(c.mode), &count,
-                             static_cast<GLenum>(c.type), &offset, nullptr, 1);
+  return DoMultiDrawElements("glDrawArrays", false, static_cast<GLenum>(c.mode),
+                             &count, static_cast<GLenum>(c.type), &offset,
+                             nullptr, 1);
 }
 
 error::Error GLES2DecoderImpl::HandleDrawElementsInstancedANGLE(
@@ -12034,34 +11740,6 @@
   return error::kNoError;
 }
 
-error::Error GLES2DecoderImpl::HandleGetProgramResourceiv(
-    uint32_t immediate_data_size,
-    const volatile void* cmd_data) {
-  // Unimplemented for WebGL 2.0 Compute context.
-  return error::kUnknownCommand;
-}
-
-error::Error GLES2DecoderImpl::HandleGetProgramResourceIndex(
-    uint32_t immediate_data_size,
-    const volatile void* cmd_data) {
-  // Unimplemented for WebGL 2.0 Compute context.
-  return error::kUnknownCommand;
-}
-
-error::Error GLES2DecoderImpl::HandleGetProgramResourceLocation(
-    uint32_t immediate_data_size,
-    const volatile void* cmd_data) {
-  // Unimplemented for WebGL 2.0 Compute context.
-  return error::kUnknownCommand;
-}
-
-error::Error GLES2DecoderImpl::HandleGetProgramResourceName(
-    uint32_t immediate_data_size,
-    const volatile void* cmd_data) {
-  // Unimplemented for WebGL 2.0 Compute context.
-  return error::kUnknownCommand;
-}
-
 error::Error GLES2DecoderImpl::HandleGetShaderInfoLog(
     uint32_t immediate_data_size,
     const volatile void* cmd_data) {
@@ -13353,7 +13031,7 @@
     client_->OnSwapBuffers(c.swap_id(), c.flags);
     surface_->PostSubBufferAsync(
         c.x, c.y, c.width, c.height,
-        base::BindOnce(&GLES2DecoderImpl::FinishAsyncSwapBuffers,
+        base::Bind(&GLES2DecoderImpl::FinishAsyncSwapBuffers,
                        weak_ptr_factory_.GetWeakPtr(), c.swap_id()),
         base::DoNothing());
   } else {
@@ -16573,7 +16251,7 @@
 
     client_->OnSwapBuffers(swap_id, flags);
     surface_->SwapBuffersAsync(
-        base::BindOnce(&GLES2DecoderImpl::FinishAsyncSwapBuffers,
+        base::Bind(&GLES2DecoderImpl::FinishAsyncSwapBuffers,
                        weak_ptr_factory_.GetWeakPtr(), swap_id),
         base::DoNothing());
   } else {
@@ -16626,7 +16304,7 @@
   if (supports_async_swap_) {
     client_->OnSwapBuffers(swap_id, flags);
     surface_->CommitOverlayPlanesAsync(
-        base::BindOnce(&GLES2DecoderImpl::FinishAsyncSwapBuffers,
+        base::Bind(&GLES2DecoderImpl::FinishAsyncSwapBuffers,
                        weak_ptr_factory_.GetWeakPtr(), swap_id),
         base::DoNothing());
   } else {
@@ -16776,9 +16454,6 @@
       std::string::npos) {
     feature_info_->EnableOESTextureHalfFloatLinear();
   }
-  if (feature_str.find("GL_EXT_float_blend ") != std::string::npos) {
-    feature_info_->EnableEXTFloatBlend();
-  }
 
   UpdateCapabilities();
 
@@ -17766,11 +17441,9 @@
   if (image && internal_format == source_internal_format && dest_level == 0 &&
       !unpack_flip_y && !unpack_premultiply_alpha_change) {
     api()->glBindTextureFn(dest_binding_target, dest_texture->service_id());
-    if (image->ShouldBindOrCopy() == gl::GLImage::COPY &&
-        image->CopyTexImage(dest_target)) {
+    if (image->CopyTexImage(dest_target))
       return;
     }
-  }
 
   DoBindOrCopyTexImageIfNeeded(source_texture, source_target, 0);
 
@@ -18437,9 +18110,7 @@
 
 void GLES2DecoderImpl::DoCreateAndTexStorage2DSharedImageINTERNAL(
     GLuint client_id,
-    const volatile GLbyte* data,
-    GLenum internal_format) {
-  // TODO(https://crbug.com/924198): Implement support for internal format.
+    const volatile GLbyte* data) {
   TRACE_EVENT2("gpu",
                "GLES2DecoderImpl::DoCreateAndTexStorage2DSharedImageCHROMIUM",
                "context", logger_.GetLogPrefix(), "mailbox[0]",
@@ -18464,21 +18135,8 @@
     return;
   }
 
-  std::unique_ptr<SharedImageRepresentationGLTexture> shared_image;
-  if (internal_format == GL_RGB) {
-    shared_image = group_->shared_image_representation_factory()
-                       ->ProduceRGBEmulationGLTexture(mailbox);
-  } else if (internal_format == GL_NONE) {
-    shared_image =
-        group_->shared_image_representation_factory()->ProduceGLTexture(
-            mailbox);
-  } else {
-    LOCAL_SET_GL_ERROR(GL_INVALID_ENUM,
-                       "DoCreateAndTexStorage2DSharedImageINTERNAL",
-                       "invalid internal format");
-    return;
-  }
-
+  std::unique_ptr<SharedImageRepresentationGLTexture> shared_image =
+      group_->shared_image_representation_factory()->ProduceGLTexture(mailbox);
   if (!shared_image) {
     // Mailbox missing, generate a texture.
     bool result = GenTexturesHelper(1, &client_id);
@@ -18674,7 +18332,7 @@
 
   Texture::ImageState image_state = Texture::UNBOUND;
 
-  if (image->ShouldBindOrCopy() == gl::GLImage::BIND) {
+  {
     ScopedGLErrorSuppressor suppressor(
         "GLES2DecoderImpl::DoBindTexImage2DCHROMIUM", error_state_.get());
 
@@ -18994,80 +18652,6 @@
   return api()->glFenceSyncFn(condition, flags);
 }
 
-GLsizei GLES2DecoderImpl::InternalFormatSampleCountsHelper(
-    GLenum target,
-    GLenum internalformat,
-    std::vector<GLint>* out_sample_counts) {
-  DCHECK(out_sample_counts == nullptr || out_sample_counts->size() == 0);
-
-  GLint num_sample_counts = 0;
-  if (gl_version_info().IsLowerThanGL(4, 2)) {
-    // No multisampling for integer formats.
-    if (GLES2Util::IsIntegerFormat(internalformat)) {
-      return 0;
-    }
-
-    GLint max_samples = renderbuffer_manager()->max_samples();
-    num_sample_counts = max_samples;
-
-    if (out_sample_counts != nullptr) {
-      out_sample_counts->reserve(num_sample_counts);
-      for (GLint sample_count = max_samples; sample_count > 0; --sample_count) {
-        out_sample_counts->push_back(sample_count);
-      }
-    }
-  } else {
-    api()->glGetInternalformativFn(target, internalformat, GL_NUM_SAMPLE_COUNTS,
-                                   1, &num_sample_counts);
-
-    bool remove_nonconformant_sample_counts =
-        feature_info_->IsWebGLContext() &&
-        feature_info_->feature_flags().nv_internalformat_sample_query;
-
-    if (out_sample_counts != nullptr || remove_nonconformant_sample_counts) {
-      std::vector<GLint> sample_counts(num_sample_counts);
-      api()->glGetInternalformativFn(target, internalformat, GL_SAMPLES,
-                                     num_sample_counts, sample_counts.data());
-
-      if (remove_nonconformant_sample_counts) {
-        ScopedGLErrorSuppressor suppressor(
-            "GLES2DecoderImpl::InternalFormatSampleCountsHelper",
-            error_state_.get());
-
-        auto is_nonconformant = [this, target,
-                                 internalformat](GLint sample_count) {
-          GLint conformant = GL_FALSE;
-          api()->glGetInternalformatSampleivNVFn(target, internalformat,
-                                                 sample_count, GL_CONFORMANT_NV,
-                                                 1, &conformant);
-
-          // getInternalformatSampleivNV does not work for all formats on NVIDIA
-          // Shield TV drivers. Assume that formats with large sample counts are
-          // non-conformant in case the query generates an error.
-          if (api()->glGetErrorFn() != GL_NO_ERROR) {
-            return sample_count > 8;
-          }
-          return conformant == GL_FALSE;
-        };
-
-        sample_counts.erase(
-            std::remove_if(sample_counts.begin(), sample_counts.end(),
-                           is_nonconformant),
-            sample_counts.end());
-        num_sample_counts = sample_counts.size();
-      }
-
-      if (out_sample_counts != nullptr) {
-        *out_sample_counts = std::move(sample_counts);
-      }
-    }
-  }
-
-  DCHECK(out_sample_counts == nullptr ||
-         out_sample_counts->size() == static_cast<size_t>(num_sample_counts));
-  return num_sample_counts;
-}
-
 error::Error GLES2DecoderImpl::HandleGetInternalformativ(
     uint32_t immediate_data_size,
     const volatile void* cmd_data) {
@@ -19093,30 +18677,46 @@
   }
 
   typedef cmds::GetInternalformativ::Result Result;
-
-  GLsizei num_sample_counts = 0;
-  std::vector<GLint> sample_counts;
-
   GLsizei num_values = 0;
-  GLint* values = nullptr;
+  std::vector<GLint> samples;
+  if (gl_version_info().IsLowerThanGL(4, 2)) {
+    if (!GLES2Util::IsIntegerFormat(format)) {
+      // No multisampling for integer formats.
+      GLint max_samples = renderbuffer_manager()->max_samples();
+      while (max_samples > 0) {
+        samples.push_back(max_samples);
+        --max_samples;
+      }
+    }
   switch (pname) {
     case GL_NUM_SAMPLE_COUNTS:
-      num_sample_counts =
-          InternalFormatSampleCountsHelper(target, format, nullptr);
       num_values = 1;
-      values = &num_sample_counts;
       break;
     case GL_SAMPLES:
-      num_sample_counts =
-          InternalFormatSampleCountsHelper(target, format, &sample_counts);
-      num_values = num_sample_counts;
-      values = sample_counts.data();
+        num_values = static_cast<GLsizei>(samples.size());
       break;
     default:
       NOTREACHED();
       break;
   }
-
+  } else {
+    switch (pname) {
+      case GL_NUM_SAMPLE_COUNTS:
+        num_values = 1;
+        break;
+      case GL_SAMPLES:
+        {
+          GLint value = 0;
+          api()->glGetInternalformativFn(target, format, GL_NUM_SAMPLE_COUNTS,
+                                         1, &value);
+          num_values = static_cast<GLsizei>(value);
+        }
+        break;
+      default:
+        NOTREACHED();
+        break;
+    }
+  }
   uint32_t checked_size = 0;
   if (!Result::ComputeSize(num_values).AssignIfValid(&checked_size)) {
     return error::kOutOfBounds;
@@ -19132,8 +18731,23 @@
   if (result->size != 0) {
     return error::kInvalidArguments;
   }
-
-  std::copy(values, &values[num_values], params);
+  if (gl_version_info().IsLowerThanGL(4, 2)) {
+    switch (pname) {
+      case GL_NUM_SAMPLE_COUNTS:
+        params[0] = static_cast<GLint>(samples.size());
+        break;
+      case GL_SAMPLES:
+        for (size_t ii = 0; ii < samples.size(); ++ii) {
+          params[ii] = samples[ii];
+        }
+        break;
+      default:
+        NOTREACHED();
+        break;
+    }
+  } else {
+    api()->glGetInternalformativFn(target, format, pname, num_values, params);
+  }
   result->SetNumResults(num_values);
   return error::kNoError;
 }
--- a/gpu/command_buffer/service/gles2_cmd_decoder.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/gles2_cmd_decoder.h	2019-05-17 18:53:33.000000000 +0300
@@ -63,7 +63,6 @@
     ext_color_buffer_half_float = false;
     oes_texture_float_linear = false;
     oes_texture_half_float_linear = false;
-    ext_float_blend = false;
   }
 
   bool operator==(const DisallowedFeatures& other) const {
@@ -77,7 +76,6 @@
   bool ext_color_buffer_half_float = false;
   bool oes_texture_float_linear = false;
   bool oes_texture_half_float_linear = false;
-  bool ext_float_blend = false;
 };
 
 // This class implements the DecoderContext interface, decoding GLES2
@@ -138,8 +136,6 @@
 
   Outputter* outputter() const override;
 
-  int GetRasterDecoderId() const override;
-
   // Set the surface associated with the default FBO.
   virtual void SetSurface(const scoped_refptr<gl::GLSurface>& surface) = 0;
   // Releases the surface associated with the GL context.
--- a/gpu/command_buffer/service/gles2_cmd_decoder_passthrough.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/gles2_cmd_decoder_passthrough.cc	2019-05-17 18:53:33.004000000 +0300
@@ -7,7 +7,6 @@
 #include <string>
 #include <utility>
 
-#include "base/bind.h"
 #include "base/callback.h"
 #include "base/stl_util.h"
 #include "base/strings/string_split.h"
@@ -1686,9 +1685,7 @@
     return;
 
   // TODO: internalformat?
-  if (image->ShouldBindOrCopy() == gl::GLImage::BIND)
-    image->BindTexImage(target);
-  else
+  if (!image->BindTexImage(target))
     image->CopyTexImage(target);
 
   // If copy / bind fail, then we could keep the bind state the same.
@@ -2178,22 +2175,10 @@
 
 void GLES2DecoderPassthroughImpl::ReadBackBuffersIntoShadowCopies(
     const BufferShadowUpdateMap& updates) {
-  if (updates.empty()) {
-    return;
-  }
-
   GLint old_binding = 0;
   api()->glGetIntegervFn(GL_ARRAY_BUFFER_BINDING, &old_binding);
   for (const auto& u : updates) {
-    GLuint client_id = u.first;
-    GLuint service_id = 0;
-    if (!resources_->buffer_id_map.GetServiceID(client_id, &service_id)) {
-      // Buffer no longer exists, this shadow update should have been removed by
-      // DoDeleteBuffers
-      DCHECK(false);
-      continue;
-    }
-
+    GLuint service_id = u.first;
     const auto& update = u.second;
 
     void* shadow = update.shm->GetDataAddress(update.shm_offset, update.size);
@@ -2451,14 +2436,15 @@
     return error::kNoError;
   }
 
-  if (image->ShouldBindOrCopy() == gl::GLImage::BIND) {
-    if (internalformat)
-      image->BindTexImageWithInternalformat(target, internalformat);
-    else
-      image->BindTexImage(target);
+  if (internalformat) {
+    if (!image->BindTexImageWithInternalformat(target, internalformat)) {
+      image->CopyTexImage(target);
+    }
   } else {
+    if (!image->BindTexImage(target)) {
     image->CopyTexImage(target);
   }
+  }
 
   // Target is already validated
   UpdateTextureSizeFromTarget(target);
--- a/gpu/command_buffer/service/gles2_cmd_decoder_passthrough_doer_prototypes.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/gles2_cmd_decoder_passthrough_doer_prototypes.h	2019-05-17 18:53:33.004000000 +0300
@@ -305,32 +305,6 @@
                             GLsizei* length,
                             GLint* params);
 error::Error DoGetProgramInfoLog(GLuint program, std::string* infolog);
-error::Error DoGetProgramInterfaceiv(GLuint program,
-                                     GLenum program_interface,
-                                     GLenum pname,
-                                     GLsizei bufsize,
-                                     GLsizei* length,
-                                     GLint* params);
-error::Error DoGetProgramResourceiv(GLuint program,
-                                    GLenum program_interface,
-                                    GLuint index,
-                                    GLsizei prop_count,
-                                    const GLenum* props,
-                                    GLsizei bufsize,
-                                    GLsizei* length,
-                                    GLint* params);
-error::Error DoGetProgramResourceIndex(GLuint program,
-                                       GLenum program_interface,
-                                       const char* name,
-                                       GLuint* index);
-error::Error DoGetProgramResourceLocation(GLuint program,
-                                          GLenum program_interface,
-                                          const char* name,
-                                          GLint* location);
-error::Error DoGetProgramResourceName(GLuint program,
-                                      GLenum program_interface,
-                                      GLuint index,
-                                      std::string* name);
 error::Error DoGetRenderbufferParameteriv(GLenum target,
                                           GLenum pname,
                                           GLsizei bufsize,
@@ -736,12 +710,6 @@
                                                       GLenum internalformat,
                                                       GLsizei width,
                                                       GLsizei height);
-error::Error DoRenderbufferStorageMultisampleAdvancedAMD(GLenum target,
-                                                         GLsizei samples,
-                                                         GLsizei storageSamples,
-                                                         GLenum internalformat,
-                                                         GLsizei width,
-                                                         GLsizei height);
 error::Error DoRenderbufferStorageMultisampleEXT(GLenum target,
                                                  GLsizei samples,
                                                  GLenum internalformat,
@@ -1072,7 +1040,8 @@
                                    GLuint sk_color,
                                    GLuint msaa_sample_count,
                                    GLboolean can_use_lcd_text,
-                                   GLint color_type);
+                                   GLint color_type,
+                                   GLuint color_space_transfer_cache_id);
 error::Error DoRasterCHROMIUM(GLuint raster_shm_id,
                               GLuint raster_shm_offset,
                               GLsizeiptr raster_shm_size,
@@ -1115,8 +1084,7 @@
 error::Error DoLockDiscardableTextureCHROMIUM(GLuint texture_id);
 error::Error DoCreateAndTexStorage2DSharedImageINTERNAL(
     GLuint client_id,
-    const volatile GLbyte* mailbox,
-    GLenum internalformat);
+    const volatile GLbyte* mailbox);
 error::Error DoBeginSharedImageAccessDirectCHROMIUM(GLuint client_id,
                                                     GLenum mode);
 error::Error DoEndSharedImageAccessDirectCHROMIUM(GLuint client_id);
--- a/gpu/command_buffer/service/gles2_cmd_decoder_passthrough_doers.cc	2019-05-17 17:45:41.012000000 +0300
+++ b/gpu/command_buffer/service/gles2_cmd_decoder_passthrough_doers.cc	2019-05-17 18:53:33.004000000 +0300
@@ -237,7 +237,7 @@
 // not needed when uploading from a PBO and for compressed formats which the
 // client sends untouched. This class handles resetting and restoring the unpack
 // state.
-// TODO(cwallez@ch40m1um.qjz9zk) it would be nicer to handle the resetting /
+// TODO(cwallez@chromium.org) it would be nicer to handle the resetting /
 // restoring on the client side.
 class ScopedUnpackStateButAlignmentReset {
  public:
@@ -926,9 +926,6 @@
       return update.first == client_id;
     };
     base::EraseIf(buffer_shadow_updates_, is_the_deleted_buffer);
-    for (PendingQuery& pending_query : pending_queries_) {
-      base::EraseIf(pending_query.buffer_shadow_updates, is_the_deleted_buffer);
-    }
   }
   api()->glDeleteBuffersARBFn(n, service_ids.data());
 
@@ -1708,82 +1705,6 @@
   return error::kNoError;
 }
 
-error::Error GLES2DecoderPassthroughImpl::DoGetProgramInterfaceiv(
-    GLuint program,
-    GLenum program_interface,
-    GLenum pname,
-    GLsizei bufsize,
-    GLsizei* length,
-    GLint* params) {
-  // glGetProgramInterfaceivRobustANGLE remains to be implemented in ANGLE.
-  if (bufsize < 1) {
-    return error::kOutOfBounds;
-  }
-  *length = 1;
-  api()->glGetProgramInterfaceivFn(GetProgramServiceID(program, resources_),
-                                   program_interface, pname, params);
-  return error::kNoError;
-}
-
-error::Error GLES2DecoderPassthroughImpl::DoGetProgramResourceiv(
-    GLuint program,
-    GLenum program_interface,
-    GLuint index,
-    GLsizei prop_count,
-    const GLenum* props,
-    GLsizei bufsize,
-    GLsizei* length,
-    GLint* params) {
-  api()->glGetProgramResourceivFn(GetProgramServiceID(program, resources_),
-                                  program_interface, index, prop_count, props,
-                                  bufsize, length, params);
-  return error::kNoError;
-}
-
-error::Error GLES2DecoderPassthroughImpl::DoGetProgramResourceIndex(
-    GLuint program,
-    GLenum program_interface,
-    const char* name,
-    GLuint* index) {
-  *index = api()->glGetProgramResourceIndexFn(
-      GetProgramServiceID(program, resources_), program_interface, name);
-  return error::kNoError;
-}
-
-error::Error GLES2DecoderPassthroughImpl::DoGetProgramResourceLocation(
-    GLuint program,
-    GLenum program_interface,
-    const char* name,
-    GLint* location) {
-  *location = api()->glGetProgramResourceLocationFn(
-      GetProgramServiceID(program, resources_), program_interface, name);
-  return error::kNoError;
-}
-
-error::Error GLES2DecoderPassthroughImpl::DoGetProgramResourceName(
-    GLuint program,
-    GLenum program_interface,
-    GLuint index,
-    std::string* name) {
-  CheckErrorCallbackState();
-
-  GLuint service_id = GetProgramServiceID(program, resources_);
-  GLint max_name_length = 0;
-  api()->glGetProgramInterfaceivFn(service_id, program_interface,
-                                   GL_MAX_NAME_LENGTH, &max_name_length);
-  if (CheckErrorCallbackState()) {
-    return error::kNoError;
-  }
-
-  std::vector<GLchar> buffer(max_name_length, 0);
-  GLsizei length = 0;
-  api()->glGetProgramResourceNameFn(service_id, program_interface, index,
-                                    max_name_length, &length, buffer.data());
-  DCHECK_LE(length, max_name_length);
-  *name = length > 0 ? std::string(buffer.data(), length) : std::string();
-  return error::kNoError;
-}
-
 error::Error GLES2DecoderPassthroughImpl::DoGetRenderbufferParameteriv(
     GLenum target,
     GLenum pname,
@@ -3185,20 +3106,6 @@
   return error::kNoError;
 }
 
-error::Error
-GLES2DecoderPassthroughImpl::DoRenderbufferStorageMultisampleAdvancedAMD(
-    GLenum target,
-    GLsizei samples,
-    GLsizei storageSamples,
-    GLenum internalformat,
-    GLsizei width,
-    GLsizei height) {
-  DCHECK(feature_info_->feature_flags().amd_framebuffer_multisample_advanced);
-  api()->glRenderbufferStorageMultisampleAdvancedAMDFn(
-      target, samples, storageSamples, internalformat, width, height);
-  return error::kNoError;
-}
-
 error::Error GLES2DecoderPassthroughImpl::DoRenderbufferStorageMultisampleEXT(
     GLenum target,
     GLsizei samples,
@@ -3867,7 +3774,7 @@
     if (size > 1 || parsed_service_name.IsArrayName()) {
       for (GLint location_index = 1; location_index < size; location_index++) {
         std::string array_element_name = parsed_service_name.base_name() + "[" +
-                                         base::NumberToString(location_index) +
+                                         base::IntToString(location_index) +
                                          "]";
         int32_t element_location = api()->glGetUniformLocationFn(
             service_program, array_element_name.c_str());
@@ -4970,7 +4877,8 @@
     GLuint sk_color,
     GLuint msaa_sample_count,
     GLboolean can_use_lcd_text,
-    GLint color_type) {
+    GLint color_type,
+    GLuint color_space_transfer_cache_id) {
   NOTIMPLEMENTED();
   return error::kNoError;
 }
@@ -5077,12 +4985,6 @@
   update.shm_offset = shm_offset;
   update.size = size;
 
-  GLuint buffer_service_id = 0;
-  if (!resources_->buffer_id_map.GetServiceID(buffer_id, &buffer_service_id)) {
-    InsertError(GL_INVALID_OPERATION, "Invalid buffer ID");
-    return error::kNoError;
-  }
-
   if (!update.shm) {
     return error::kInvalidArguments;
   }
@@ -5149,14 +5051,7 @@
 error::Error
 GLES2DecoderPassthroughImpl::DoCreateAndTexStorage2DSharedImageINTERNAL(
     GLuint texture_client_id,
-    const volatile GLbyte* mailbox,
-    GLenum internalformat) {
-  // RGB emulation is not needed here.
-  if (internalformat != GL_NONE) {
-    InsertError(GL_INVALID_ENUM, "internal format not supported.");
-    return error::kNoError;
-  }
-
+    const volatile GLbyte* mailbox) {
   if (!texture_client_id ||
       resources_->texture_id_map.HasClientID(texture_client_id)) {
     InsertError(GL_INVALID_OPERATION, "invalid client ID");
--- a/gpu/command_buffer/service/gles2_cmd_decoder_passthrough_handlers_autogen.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/gles2_cmd_decoder_passthrough_handlers_autogen.cc	2019-05-17 18:53:33.004000000 +0300
@@ -3701,31 +3701,6 @@
 }
 
 error::Error
-GLES2DecoderPassthroughImpl::HandleRenderbufferStorageMultisampleAdvancedAMD(
-    uint32_t immediate_data_size,
-    const volatile void* cmd_data) {
-  const volatile gles2::cmds::RenderbufferStorageMultisampleAdvancedAMD& c =
-      *static_cast<const volatile gles2::cmds::
-                       RenderbufferStorageMultisampleAdvancedAMD*>(cmd_data);
-  if (!features().amd_framebuffer_multisample_advanced) {
-    return error::kUnknownCommand;
-  }
-
-  GLenum target = static_cast<GLenum>(c.target);
-  GLsizei samples = static_cast<GLsizei>(c.samples);
-  GLsizei storageSamples = static_cast<GLsizei>(c.storageSamples);
-  GLenum internalformat = static_cast<GLenum>(c.internalformat);
-  GLsizei width = static_cast<GLsizei>(c.width);
-  GLsizei height = static_cast<GLsizei>(c.height);
-  error::Error error = DoRenderbufferStorageMultisampleAdvancedAMD(
-      target, samples, storageSamples, internalformat, width, height);
-  if (error != error::kNoError) {
-    return error;
-  }
-  return error::kNoError;
-}
-
-error::Error
 GLES2DecoderPassthroughImpl::HandleRenderbufferStorageMultisampleEXT(
     uint32_t immediate_data_size,
     const volatile void* cmd_data) {
@@ -4020,40 +3995,6 @@
   return error::kNoError;
 }
 
-error::Error GLES2DecoderPassthroughImpl::HandleGetProgramInterfaceiv(
-    uint32_t immediate_data_size,
-    const volatile void* cmd_data) {
-  if (!feature_info_->IsWebGL2ComputeContext())
-    return error::kUnknownCommand;
-  const volatile gles2::cmds::GetProgramInterfaceiv& c =
-      *static_cast<const volatile gles2::cmds::GetProgramInterfaceiv*>(
-          cmd_data);
-  GLuint program = c.program;
-  GLenum program_interface = static_cast<GLenum>(c.program_interface);
-  GLenum pname = static_cast<GLenum>(c.pname);
-  unsigned int buffer_size = 0;
-  typedef cmds::GetProgramInterfaceiv::Result Result;
-  Result* result = GetSharedMemoryAndSizeAs<Result*>(
-      c.params_shm_id, c.params_shm_offset, sizeof(Result), &buffer_size);
-  GLint* params = result ? result->GetData() : nullptr;
-  if (params == nullptr) {
-    return error::kOutOfBounds;
-  }
-  GLsizei bufsize = Result::ComputeMaxResults(buffer_size);
-  GLsizei written_values = 0;
-  GLsizei* length = &written_values;
-  error::Error error = DoGetProgramInterfaceiv(program, program_interface,
-                                               pname, bufsize, length, params);
-  if (error != error::kNoError) {
-    return error;
-  }
-  if (written_values > bufsize) {
-    return error::kOutOfBounds;
-  }
-  result->SetNumResults(written_values);
-  return error::kNoError;
-}
-
 error::Error GLES2DecoderPassthroughImpl::HandleMemoryBarrierEXT(
     uint32_t immediate_data_size,
     const volatile void* cmd_data) {
@@ -4899,12 +4840,11 @@
   }
   volatile const GLbyte* mailbox = GetImmediateDataAs<volatile const GLbyte*>(
       c, mailbox_size, immediate_data_size);
-  GLenum internalformat = static_cast<GLenum>(c.internalformat);
   if (mailbox == nullptr) {
     return error::kOutOfBounds;
   }
-  error::Error error = DoCreateAndTexStorage2DSharedImageINTERNAL(
-      texture, mailbox, internalformat);
+  error::Error error =
+      DoCreateAndTexStorage2DSharedImageINTERNAL(texture, mailbox);
   if (error != error::kNoError) {
     return error;
   }
--- a/gpu/command_buffer/service/gles2_cmd_decoder_passthrough_handlers.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/gles2_cmd_decoder_passthrough_handlers.cc	2019-05-17 18:53:33.004000000 +0300
@@ -483,162 +483,6 @@
   return error::kNoError;
 }
 
-error::Error GLES2DecoderPassthroughImpl::HandleGetProgramResourceiv(
-    uint32_t immediate_data_size,
-    const volatile void* cmd_data) {
-  if (!feature_info_->IsWebGL2ComputeContext()) {
-    return error::kUnknownCommand;
-  }
-  const volatile gles2::cmds::GetProgramResourceiv& c =
-      *static_cast<const volatile gles2::cmds::GetProgramResourceiv*>(cmd_data);
-  GLuint program = static_cast<GLuint>(c.program);
-  GLenum program_interface = static_cast<GLenum>(c.program_interface);
-  GLuint index = static_cast<GLuint>(c.index);
-  uint32_t props_bucket_id = c.props_bucket_id;
-  uint32_t params_shm_id = c.params_shm_id;
-  uint32_t params_shm_offset = c.params_shm_offset;
-
-  Bucket* bucket = GetBucket(props_bucket_id);
-  if (!bucket) {
-    return error::kInvalidArguments;
-  }
-  GLsizei prop_count = static_cast<GLsizei>(bucket->size() / sizeof(GLenum));
-  const GLenum* props = bucket->GetDataAs<const GLenum*>(0, bucket->size());
-  unsigned int buffer_size = 0;
-  typedef cmds::GetProgramResourceiv::Result Result;
-  Result* result = GetSharedMemoryAndSizeAs<Result*>(
-      params_shm_id, params_shm_offset, sizeof(Result), &buffer_size);
-  GLint* params = result ? result->GetData() : nullptr;
-  if (params == nullptr) {
-    return error::kOutOfBounds;
-  }
-  // Check that the client initialized the result.
-  if (result->size != 0) {
-    return error::kInvalidArguments;
-  }
-  GLsizei bufsize = Result::ComputeMaxResults(buffer_size);
-  GLsizei length = 0;
-  error::Error error = DoGetProgramResourceiv(
-      program, program_interface, index, prop_count, props, bufsize, &length,
-      params);
-  if (error != error::kNoError) {
-    return error;
-  }
-  if (length > bufsize) {
-    return error::kOutOfBounds;
-  }
-  result->SetNumResults(length);
-  return error::kNoError;
-}
-
-error::Error GLES2DecoderPassthroughImpl::HandleGetProgramResourceIndex(
-    uint32_t immediate_data_size,
-    const volatile void* cmd_data) {
-  if (!feature_info_->IsWebGL2ComputeContext()) {
-    return error::kUnknownCommand;
-  }
-  const volatile gles2::cmds::GetProgramResourceIndex& c =
-      *static_cast<const volatile gles2::cmds::GetProgramResourceIndex*>(
-          cmd_data);
-  GLuint program = static_cast<GLuint>(c.program);
-  GLenum program_interface = static_cast<GLenum>(c.program_interface);
-  uint32_t name_bucket_id = c.name_bucket_id;
-  uint32_t index_shm_id = c.index_shm_id;
-  uint32_t index_shm_offset = c.index_shm_offset;
-
-  Bucket* bucket = GetBucket(name_bucket_id);
-  if (!bucket) {
-    return error::kInvalidArguments;
-  }
-  std::string name_str;
-  if (!bucket->GetAsString(&name_str)) {
-    return error::kInvalidArguments;
-  }
-  GLuint* index = GetSharedMemoryAs<GLuint*>(
-      index_shm_id, index_shm_offset, sizeof(GLuint));
-  if (!index) {
-    return error::kOutOfBounds;
-  }
-  if (*index != GL_INVALID_INDEX) {
-    return error::kInvalidArguments;
-  }
-  return DoGetProgramResourceIndex(
-      program, program_interface, name_str.c_str(), index);
-}
-
-error::Error GLES2DecoderPassthroughImpl::HandleGetProgramResourceLocation(
-    uint32_t immediate_data_size,
-    const volatile void* cmd_data) {
-  if (!feature_info_->IsWebGL2ComputeContext()) {
-    return error::kUnknownCommand;
-  }
-  const volatile gles2::cmds::GetProgramResourceLocation& c =
-      *static_cast<const volatile gles2::cmds::GetProgramResourceLocation*>(
-          cmd_data);
-  GLuint program = static_cast<GLuint>(c.program);
-  GLenum program_interface = static_cast<GLenum>(c.program_interface);
-  uint32_t name_bucket_id = c.name_bucket_id;
-  uint32_t location_shm_id = c.location_shm_id;
-  uint32_t location_shm_offset = c.location_shm_offset;
-
-  Bucket* bucket = GetBucket(name_bucket_id);
-  if (!bucket) {
-    return error::kInvalidArguments;
-  }
-  std::string name_str;
-  if (!bucket->GetAsString(&name_str)) {
-    return error::kInvalidArguments;
-  }
-  GLint* location = GetSharedMemoryAs<GLint*>(
-      location_shm_id, location_shm_offset, sizeof(GLint));
-  if (!location) {
-    return error::kOutOfBounds;
-  }
-  if (*location != -1) {
-    return error::kInvalidArguments;
-  }
-  return DoGetProgramResourceLocation(
-      program, program_interface, name_str.c_str(), location);
-}
-
-error::Error GLES2DecoderPassthroughImpl::HandleGetProgramResourceName(
-    uint32_t immediate_data_size,
-    const volatile void* cmd_data) {
-  if (!feature_info_->IsWebGL2ComputeContext()) {
-    return error::kUnknownCommand;
-  }
-  const volatile gles2::cmds::GetProgramResourceName& c =
-      *static_cast<const volatile gles2::cmds::GetProgramResourceName*>(
-          cmd_data);
-  GLuint program = static_cast<GLuint>(c.program);
-  GLenum program_interface = static_cast<GLenum>(c.program_interface);
-  GLuint index = static_cast<GLuint>(c.index);
-  uint32_t name_bucket_id = c.name_bucket_id;
-  uint32_t result_shm_id = c.result_shm_id;
-  uint32_t result_shm_offset = c.result_shm_offset;
-
-  typedef cmds::GetProgramResourceName::Result Result;
-  Result* result = GetSharedMemoryAs<Result*>(
-      result_shm_id, result_shm_offset, sizeof(*result));
-  if (!result) {
-    return error::kOutOfBounds;
-  }
-  // Check that the client initialized the result.
-  if (*result != 0) {
-    return error::kInvalidArguments;
-  }
-  std::string name;
-  error::Error error =
-      DoGetProgramResourceName(program, program_interface, index, &name);
-  if (error != error::kNoError) {
-    return error;
-  }
-  *result = 1;
-  Bucket* bucket = CreateBucket(name_bucket_id);
-  bucket->SetFromString(name.c_str());
-  return error::kNoError;
-}
-
 error::Error GLES2DecoderPassthroughImpl::HandleGetShaderInfoLog(
     uint32_t immediate_data_size,
     const volatile void* cmd_data) {
--- a/gpu/command_buffer/service/gles2_cmd_decoder_passthrough_unittest_commands.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/gles2_cmd_decoder_passthrough_unittest_commands.cc	2019-05-17 18:53:33.004000000 +0300
@@ -15,33 +15,33 @@
 template <typename T>
 class GLES2DecoderPassthroughFixedCommandTest
     : public GLES2DecoderPassthroughTest {};
-TYPED_TEST_SUITE_P(GLES2DecoderPassthroughFixedCommandTest);
+TYPED_TEST_CASE_P(GLES2DecoderPassthroughFixedCommandTest);
 
 TYPED_TEST_P(GLES2DecoderPassthroughFixedCommandTest, InvalidCommand) {
   TypeParam cmd;
   cmd.SetHeader();
   EXPECT_EQ(error::kUnknownCommand, this->ExecuteCmd(cmd));
 }
-REGISTER_TYPED_TEST_SUITE_P(GLES2DecoderPassthroughFixedCommandTest,
+REGISTER_TYPED_TEST_CASE_P(GLES2DecoderPassthroughFixedCommandTest,
                             InvalidCommand);
 
 template <typename T>
 class GLES2DecoderPassthroughImmediateNoArgCommandTest
     : public GLES2DecoderPassthroughTest {};
-TYPED_TEST_SUITE_P(GLES2DecoderPassthroughImmediateNoArgCommandTest);
+TYPED_TEST_CASE_P(GLES2DecoderPassthroughImmediateNoArgCommandTest);
 
 TYPED_TEST_P(GLES2DecoderPassthroughImmediateNoArgCommandTest, InvalidCommand) {
   TypeParam& cmd = *(this->template GetImmediateAs<TypeParam>());
   cmd.SetHeader();
   EXPECT_EQ(error::kUnknownCommand, this->ExecuteImmediateCmd(cmd, 64));
 }
-REGISTER_TYPED_TEST_SUITE_P(GLES2DecoderPassthroughImmediateNoArgCommandTest,
+REGISTER_TYPED_TEST_CASE_P(GLES2DecoderPassthroughImmediateNoArgCommandTest,
                             InvalidCommand);
 
 template <typename T>
 class GLES2DecoderPassthroughImmediateSizeArgCommandTest
     : public GLES2DecoderPassthroughTest {};
-TYPED_TEST_SUITE_P(GLES2DecoderPassthroughImmediateSizeArgCommandTest);
+TYPED_TEST_CASE_P(GLES2DecoderPassthroughImmediateSizeArgCommandTest);
 
 TYPED_TEST_P(GLES2DecoderPassthroughImmediateSizeArgCommandTest,
              InvalidCommand) {
@@ -49,7 +49,7 @@
   cmd.SetHeader(0);
   EXPECT_EQ(error::kUnknownCommand, this->ExecuteImmediateCmd(cmd, 0));
 }
-REGISTER_TYPED_TEST_SUITE_P(GLES2DecoderPassthroughImmediateSizeArgCommandTest,
+REGISTER_TYPED_TEST_CASE_P(GLES2DecoderPassthroughImmediateSizeArgCommandTest,
                             InvalidCommand);
 
 using ES3FixedCommandTypes0 =
@@ -143,16 +143,16 @@
                      UniformMatrix4x2fvImmediate,
                      UniformMatrix4x3fvImmediate>;
 
-INSTANTIATE_TYPED_TEST_SUITE_P(0,
+INSTANTIATE_TYPED_TEST_CASE_P(0,
                                GLES2DecoderPassthroughFixedCommandTest,
                                ES3FixedCommandTypes0);
-INSTANTIATE_TYPED_TEST_SUITE_P(1,
+INSTANTIATE_TYPED_TEST_CASE_P(1,
                                GLES2DecoderPassthroughFixedCommandTest,
                                ES3FixedCommandTypes1);
-INSTANTIATE_TYPED_TEST_SUITE_P(0,
+INSTANTIATE_TYPED_TEST_CASE_P(0,
                                GLES2DecoderPassthroughImmediateNoArgCommandTest,
                                ES3ImmediateNoArgCommandTypes0);
-INSTANTIATE_TYPED_TEST_SUITE_P(
+INSTANTIATE_TYPED_TEST_CASE_P(
     0,
     GLES2DecoderPassthroughImmediateSizeArgCommandTest,
     ES3ImmediateSizeArgCommandTypes0);
--- a/gpu/command_buffer/service/gles2_cmd_decoder_passthrough_unittest_textures.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/gles2_cmd_decoder_passthrough_unittest_textures.cc	2019-05-17 18:53:33.008000000 +0300
@@ -101,9 +101,8 @@
 
   CreateAndTexStorage2DSharedImageINTERNALImmediate& cmd =
       *GetImmediateAs<CreateAndTexStorage2DSharedImageINTERNALImmediate>();
-  cmd.Init(kNewClientId, mailbox.name, GL_NONE);
-  EXPECT_EQ(error::kNoError,
-            ExecuteImmediateCmd(cmd, sizeof(mailbox.name) + sizeof(GLenum)));
+  cmd.Init(kNewClientId, mailbox.name);
+  EXPECT_EQ(error::kNoError, ExecuteImmediateCmd(cmd, sizeof(mailbox.name)));
   EXPECT_EQ(GL_NO_ERROR, GetGLError());
 
   // Make sure the new client ID is associated with the provided service ID.
@@ -137,9 +136,8 @@
   Mailbox mailbox;
   CreateAndTexStorage2DSharedImageINTERNALImmediate& cmd =
       *GetImmediateAs<CreateAndTexStorage2DSharedImageINTERNALImmediate>();
-  cmd.Init(kNewClientId, mailbox.name, GL_NONE);
-  EXPECT_EQ(error::kNoError,
-            ExecuteImmediateCmd(cmd, sizeof(mailbox.name) + sizeof(GLenum)));
+  cmd.Init(kNewClientId, mailbox.name);
+  EXPECT_EQ(error::kNoError, ExecuteImmediateCmd(cmd, sizeof(mailbox.name)));
 
   // CreateAndTexStorage2DSharedImage should fail if the mailbox is invalid.
   EXPECT_EQ(GL_INVALID_OPERATION, GetGLError());
@@ -167,9 +165,8 @@
   {
     CreateAndTexStorage2DSharedImageINTERNALImmediate& cmd =
         *GetImmediateAs<CreateAndTexStorage2DSharedImageINTERNALImmediate>();
-    cmd.Init(kNewClientId, mailbox.name, GL_NONE);
-    EXPECT_EQ(error::kNoError,
-              ExecuteImmediateCmd(cmd, sizeof(mailbox.name) + sizeof(GLenum)));
+    cmd.Init(kNewClientId, mailbox.name);
+    EXPECT_EQ(error::kNoError, ExecuteImmediateCmd(cmd, sizeof(mailbox.name)));
     EXPECT_EQ(GL_NO_ERROR, GetGLError());
   }
 
@@ -178,9 +175,8 @@
   {
     CreateAndTexStorage2DSharedImageINTERNALImmediate& cmd =
         *GetImmediateAs<CreateAndTexStorage2DSharedImageINTERNALImmediate>();
-    cmd.Init(kNewClientId, mailbox.name, GL_NONE);
-    EXPECT_EQ(error::kNoError,
-              ExecuteImmediateCmd(cmd, sizeof(mailbox.name) + sizeof(GLenum)));
+    cmd.Init(kNewClientId, mailbox.name);
+    EXPECT_EQ(error::kNoError, ExecuteImmediateCmd(cmd, sizeof(mailbox.name)));
     EXPECT_EQ(GL_INVALID_OPERATION, GetGLError());
   }
 
@@ -200,9 +196,8 @@
 
   CreateAndTexStorage2DSharedImageINTERNALImmediate& cmd =
       *GetImmediateAs<CreateAndTexStorage2DSharedImageINTERNALImmediate>();
-  cmd.Init(kNewClientId, mailbox.name, GL_NONE);
-  EXPECT_EQ(error::kNoError,
-            ExecuteImmediateCmd(cmd, sizeof(mailbox.name) + sizeof(GLenum)));
+  cmd.Init(kNewClientId, mailbox.name);
+  EXPECT_EQ(error::kNoError, ExecuteImmediateCmd(cmd, sizeof(mailbox.name)));
   EXPECT_EQ(GL_NO_ERROR, GetGLError());
 
   // Begin/end read access for the created image.
@@ -264,9 +259,8 @@
 
   CreateAndTexStorage2DSharedImageINTERNALImmediate& cmd =
       *GetImmediateAs<CreateAndTexStorage2DSharedImageINTERNALImmediate>();
-  cmd.Init(kNewClientId, mailbox.name, GL_NONE);
-  EXPECT_EQ(error::kNoError,
-            ExecuteImmediateCmd(cmd, sizeof(mailbox.name) + sizeof(GLenum)));
+  cmd.Init(kNewClientId, mailbox.name);
+  EXPECT_EQ(error::kNoError, ExecuteImmediateCmd(cmd, sizeof(mailbox.name)));
   EXPECT_EQ(GL_NO_ERROR, GetGLError());
 
   // Try to begin access with a shared image representation that fails
--- a/gpu/command_buffer/service/gles2_cmd_decoder_unittest_0_autogen.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/gles2_cmd_decoder_unittest_0_autogen.h	2019-05-17 18:53:33.008000000 +0300
@@ -22,10 +22,10 @@
   ExpectEnableDisable(GL_SAMPLE_COVERAGE, false);
   ExpectEnableDisable(GL_SCISSOR_TEST, false);
   ExpectEnableDisable(GL_STENCIL_TEST, false);
-  if (feature_info()->feature_flags().ext_multisample_compatibility) {
+  if (group_->feature_info()->feature_flags().ext_multisample_compatibility) {
     ExpectEnableDisable(GL_MULTISAMPLE_EXT, true);
   }
-  if (feature_info()->feature_flags().ext_multisample_compatibility) {
+  if (group_->feature_info()->feature_flags().ext_multisample_compatibility) {
     ExpectEnableDisable(GL_SAMPLE_ALPHA_TO_ONE_EXT, false);
   }
   if (es3_capable) {
@@ -35,7 +35,7 @@
 }
 
 void GLES2DecoderTestBase::SetupInitStateExpectations(bool es3_capable) {
-  auto* feature_info_ = feature_info();
+  auto* feature_info_ = group_->feature_info();
   EXPECT_CALL(*gl_, BlendColor(0.0f, 0.0f, 0.0f, 0.0f))
       .Times(1)
       .RetiresOnSaturation();
@@ -53,7 +53,9 @@
   EXPECT_CALL(*gl_, ColorMask(true, true, true, true))
       .Times(1)
       .RetiresOnSaturation();
-  if (feature_info()->feature_flags().chromium_framebuffer_mixed_samples) {
+  if (group_->feature_info()
+          ->feature_flags()
+          .chromium_framebuffer_mixed_samples) {
     EXPECT_CALL(*gl_, CoverageModulationNV(GL_NONE))
         .Times(1)
         .RetiresOnSaturation();
@@ -90,7 +92,7 @@
         .Times(1)
         .RetiresOnSaturation();
   }
-  if (feature_info()->feature_flags().chromium_path_rendering) {
+  if (group_->feature_info()->feature_flags().chromium_path_rendering) {
     EXPECT_CALL(*gl_, PathStencilFuncNV(GL_ALWAYS, 0, 0xFFFFFFFFU))
         .Times(1)
         .RetiresOnSaturation();
--- a/gpu/command_buffer/service/gles2_cmd_decoder_unittest_1.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/gles2_cmd_decoder_unittest_1.cc	2019-05-17 18:53:33.008000000 +0300
@@ -46,8 +46,8 @@
   }
 };
 
-INSTANTIATE_TEST_SUITE_P(Service, GLES2DecoderTest1, ::testing::Bool());
-INSTANTIATE_TEST_SUITE_P(Service, GLES3DecoderTest1, ::testing::Bool());
+INSTANTIATE_TEST_CASE_P(Service, GLES2DecoderTest1, ::testing::Bool());
+INSTANTIATE_TEST_CASE_P(Service, GLES3DecoderTest1, ::testing::Bool());
 
 template <>
 void GLES2DecoderTestBase::SpecializedSetup<cmds::GenerateMipmap, 0>(
@@ -61,7 +61,7 @@
         .WillOnce(Return(GL_NO_ERROR))
         .RetiresOnSaturation();
   }
-}
+};
 
 template <>
 void GLES2DecoderTestBase::SpecializedSetup<cmds::CheckFramebufferStatus, 0>(
@@ -76,14 +76,14 @@
   DoFramebufferRenderbuffer(
       GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER,
       client_renderbuffer_id_, kServiceRenderbufferId, GL_NO_ERROR);
-}
+};
 
 template <>
 void GLES2DecoderTestBase::SpecializedSetup<cmds::Clear, 0>(bool valid) {
   if (valid) {
     SetupExpectationsForApplyingDefaultDirtyState();
   }
-}
+};
 
 template <>
 void GLES2DecoderTestBase::SpecializedSetup<cmds::ColorMask, 0>(
@@ -92,7 +92,7 @@
   // will be considered RGB.
   DoBindFramebuffer(GL_FRAMEBUFFER, client_framebuffer_id_,
                     kServiceFramebufferId);
-}
+};
 
 template <>
 void GLES2DecoderTestBase::SpecializedSetup<cmds::CopyTexImage2D, 0>(
@@ -103,7 +103,7 @@
         .WillOnce(Return(GL_NO_ERROR))
         .RetiresOnSaturation();
   }
-}
+};
 
 template <>
 void GLES2DecoderTestBase::SpecializedSetup<cmds::CopyTexSubImage2D, 0>(
@@ -113,7 +113,7 @@
     DoTexImage2D(GL_TEXTURE_2D, 2, GL_RGBA, 16, 16, 0, GL_RGBA,
                  GL_UNSIGNED_BYTE, shared_memory_id_, kSharedMemoryOffset);
   }
-}
+};
 
 template <>
 void GLES2DecoderTestBase::SpecializedSetup<cmds::DetachShader, 0>(bool valid) {
@@ -126,7 +126,7 @@
     attach_cmd.Init(client_program_id_, client_shader_id_);
     EXPECT_EQ(error::kNoError, ExecuteCmd(attach_cmd));
   }
-}
+};
 
 template <>
 void GLES2DecoderTestBase::SpecializedSetup<cmds::FramebufferRenderbuffer, 0>(
@@ -141,7 +141,7 @@
         .WillOnce(Return(GL_NO_ERROR))
         .RetiresOnSaturation();
   }
-}
+};
 
 template <>
 void GLES2DecoderTestBase::SpecializedSetup<cmds::FramebufferTextureLayer, 0>(
@@ -154,26 +154,26 @@
         .WillOnce(Return(GL_NO_ERROR))
         .RetiresOnSaturation();
   }
-}
+};
 
 template <>
 void GLES2DecoderTestBase::SpecializedSetup<
     cmds::GetBufferParameteri64v, 0>(bool /* valid */) {
   DoBindBuffer(GL_ARRAY_BUFFER, client_buffer_id_, kServiceBufferId);
-}
+};
 
 template <>
 void GLES2DecoderTestBase::SpecializedSetup<
     cmds::GetBufferParameteriv, 0>(bool /* valid */) {
   DoBindBuffer(GL_ARRAY_BUFFER, client_buffer_id_, kServiceBufferId);
-}
+};
 
 template <>
 void GLES2DecoderTestBase::SpecializedSetup<
     cmds::GetFramebufferAttachmentParameteriv, 0>(bool /* valid */) {
   DoBindFramebuffer(GL_FRAMEBUFFER, client_framebuffer_id_,
                     kServiceFramebufferId);
-}
+};
 
 template <>
 void GLES2DecoderTestBase::SpecializedSetup<cmds::GetProgramiv, 0>(
--- a/gpu/command_buffer/service/gles2_cmd_decoder_unittest_2.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/gles2_cmd_decoder_unittest_2.cc	2019-05-17 18:53:33.008000000 +0300
@@ -574,8 +574,8 @@
   }
 };
 
-INSTANTIATE_TEST_SUITE_P(Service, GLES2DecoderTest2, ::testing::Bool());
-INSTANTIATE_TEST_SUITE_P(Service, GLES3DecoderTest2, ::testing::Bool());
+INSTANTIATE_TEST_CASE_P(Service, GLES2DecoderTest2, ::testing::Bool());
+INSTANTIATE_TEST_CASE_P(Service, GLES3DecoderTest2, ::testing::Bool());
 
 template <>
 void GLES2DecoderTestBase::SpecializedSetup<cmds::GetProgramInfoLog, 0>(
@@ -635,7 +635,7 @@
   EXPECT_EQ(error::kNoError, ExecuteCmd(attach_cmd));
 
   program->Link(nullptr, Program::kCountOnlyStaticallyUsed, this);
-}
+};
 
 template <>
 void GLES2DecoderTestBase::SpecializedSetup<
@@ -643,7 +643,7 @@
         bool /* valid */) {
   DoBindRenderbuffer(GL_RENDERBUFFER, client_renderbuffer_id_,
                     kServiceRenderbufferId);
-}
+};
 
 template <>
 void GLES2DecoderTestBase::SpecializedSetup<cmds::RenderbufferStorage, 0>(
@@ -677,7 +677,7 @@
     EXPECT_EQ(error::kNoError,
               ExecuteImmediateCmd(cmd, sizeof(client_query_id_)));
   }
-}
+};
 
 template <>
 void GLES2DecoderTestBase::SpecializedSetup<cmds::DeleteQueriesEXTImmediate, 0>(
@@ -690,7 +690,7 @@
     EXPECT_EQ(error::kNoError,
               ExecuteImmediateCmd(cmd, sizeof(client_query_id_)));
   }
-}
+};
 
 template <>
 void GLES2DecoderTestBase::SpecializedSetup<cmds::LinkProgram, 0>(
@@ -737,121 +737,121 @@
 
   attach_cmd.Init(client_program_id_, kClientFragmentShaderId);
   EXPECT_EQ(error::kNoError, ExecuteCmd(attach_cmd));
-}
+};
 
 template <>
 void GLES2DecoderTestBase::SpecializedSetup<cmds::Uniform1f, 0>(
     bool /* valid */) {
   SetupShaderForUniform(GL_FLOAT);
-}
+};
 
 template <>
 void GLES2DecoderTestBase::SpecializedSetup<cmds::Uniform1fvImmediate, 0>(
     bool /* valid */) {
   SetupShaderForUniform(GL_FLOAT);
-}
+};
 
 template <>
 void GLES2DecoderTestBase::SpecializedSetup<cmds::Uniform1ivImmediate, 0>(
     bool /* valid */) {
   SetupShaderForUniform(GL_INT);
-}
+};
 
 template <>
 void GLES2DecoderTestBase::SpecializedSetup<cmds::Uniform2f, 0>(
     bool /* valid */) {
   SetupShaderForUniform(GL_FLOAT_VEC2);
-}
+};
 
 template <>
 void GLES2DecoderTestBase::SpecializedSetup<cmds::Uniform2i, 0>(
     bool /* valid */) {
   SetupShaderForUniform(GL_INT_VEC2);
-}
+};
 
 template <>
 void GLES2DecoderTestBase::SpecializedSetup<cmds::Uniform2fvImmediate, 0>(
     bool /* valid */) {
   SetupShaderForUniform(GL_FLOAT_VEC2);
-}
+};
 
 template <>
 void GLES2DecoderTestBase::SpecializedSetup<cmds::Uniform2ivImmediate, 0>(
     bool /* valid */) {
   SetupShaderForUniform(GL_INT_VEC2);
-}
+};
 
 template <>
 void GLES2DecoderTestBase::SpecializedSetup<cmds::Uniform3f, 0>(
     bool /* valid */) {
   SetupShaderForUniform(GL_FLOAT_VEC3);
-}
+};
 
 template <>
 void GLES2DecoderTestBase::SpecializedSetup<cmds::Uniform3i, 0>(
     bool /* valid */) {
   SetupShaderForUniform(GL_INT_VEC3);
-}
+};
 
 template <>
 void GLES2DecoderTestBase::SpecializedSetup<cmds::Uniform3fvImmediate, 0>(
     bool /* valid */) {
   SetupShaderForUniform(GL_FLOAT_VEC3);
-}
+};
 
 template <>
 void GLES2DecoderTestBase::SpecializedSetup<cmds::Uniform3ivImmediate, 0>(
     bool /* valid */) {
   SetupShaderForUniform(GL_INT_VEC3);
-}
+};
 
 template <>
 void GLES2DecoderTestBase::SpecializedSetup<cmds::Uniform4f, 0>(
     bool /* valid */) {
   SetupShaderForUniform(GL_FLOAT_VEC4);
-}
+};
 
 template <>
 void GLES2DecoderTestBase::SpecializedSetup<cmds::Uniform4i, 0>(
     bool /* valid */) {
   SetupShaderForUniform(GL_INT_VEC4);
-}
+};
 
 template <>
 void GLES2DecoderTestBase::SpecializedSetup<cmds::Uniform4fvImmediate, 0>(
     bool /* valid */) {
   SetupShaderForUniform(GL_FLOAT_VEC4);
-}
+};
 
 template <>
 void GLES2DecoderTestBase::SpecializedSetup<cmds::UniformMatrix2fvImmediate, 0>(
     bool /* valid */) {
   SetupShaderForUniform(GL_FLOAT_MAT2);
-}
+};
 
 template <>
 void GLES2DecoderTestBase::SpecializedSetup<cmds::TexParameterf, 0>(
     bool /* valid */) {
   DoBindTexture(GL_TEXTURE_2D, client_texture_id_, kServiceTextureId);
-}
+};
 
 template <>
 void GLES2DecoderTestBase::SpecializedSetup<cmds::TexParameteri, 0>(
     bool /* valid */) {
   DoBindTexture(GL_TEXTURE_2D, client_texture_id_, kServiceTextureId);
-}
+};
 
 template <>
 void GLES2DecoderTestBase::SpecializedSetup<cmds::TexParameterfvImmediate, 0>(
     bool /* valid */) {
   DoBindTexture(GL_TEXTURE_2D, client_texture_id_, kServiceTextureId);
-}
+};
 
 template <>
 void GLES2DecoderTestBase::SpecializedSetup<cmds::TexParameterivImmediate, 0>(
     bool /* valid */) {
   DoBindTexture(GL_TEXTURE_2D, client_texture_id_, kServiceTextureId);
-}
+};
 
 template <>
 void GLES2DecoderTestBase::SpecializedSetup<cmds::GetVertexAttribiv, 0>(
@@ -864,7 +864,7 @@
         .WillOnce(Return(GL_NO_ERROR))
         .RetiresOnSaturation();
   }
-}
+};
 
 template <>
 void GLES2DecoderTestBase::SpecializedSetup<cmds::GetVertexAttribfv, 0>(
@@ -877,7 +877,7 @@
         .WillOnce(Return(GL_NO_ERROR))
         .RetiresOnSaturation();
   }
-}
+};
 
 template <>
 void GLES2DecoderTestBase::SpecializedSetup<cmds::GetVertexAttribIiv, 0>(
@@ -890,7 +890,7 @@
         .WillOnce(Return(GL_NO_ERROR))
         .RetiresOnSaturation();
   }
-}
+};
 
 template <>
 void GLES2DecoderTestBase::SpecializedSetup<cmds::GetVertexAttribIuiv, 0>(
@@ -903,7 +903,8 @@
         .WillOnce(Return(GL_NO_ERROR))
         .RetiresOnSaturation();
   }
-}
+};
+
 
 #include "gpu/command_buffer/service/gles2_cmd_decoder_unittest_2_autogen.h"
 
--- a/gpu/command_buffer/service/gles2_cmd_decoder_unittest_3.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/gles2_cmd_decoder_unittest_3.cc	2019-05-17 18:53:33.008000000 +0300
@@ -49,62 +49,62 @@
   }
 };
 
-INSTANTIATE_TEST_SUITE_P(Service, GLES2DecoderTest3, ::testing::Bool());
-INSTANTIATE_TEST_SUITE_P(Service, GLES3DecoderTest3, ::testing::Bool());
+INSTANTIATE_TEST_CASE_P(Service, GLES2DecoderTest3, ::testing::Bool());
+INSTANTIATE_TEST_CASE_P(Service, GLES3DecoderTest3, ::testing::Bool());
 
 template <>
 void GLES2DecoderTestBase::SpecializedSetup<cmds::Uniform4ivImmediate, 0>(
     bool /* valid */) {
   SetupShaderForUniform(GL_INT_VEC4);
-}
+};
 
 template <>
 void GLES2DecoderTestBase::SpecializedSetup<UniformMatrix3fvImmediate, 0>(
     bool /* valid */) {
   SetupShaderForUniform(GL_FLOAT_MAT3);
-}
+};
 
 template <>
 void GLES2DecoderTestBase::SpecializedSetup<UniformMatrix4fvImmediate, 0>(
     bool /* valid */) {
   SetupShaderForUniform(GL_FLOAT_MAT4);
-}
+};
 
 template <>
 void GLES2DecoderTestBase::SpecializedSetup<UniformMatrix2x3fvImmediate, 0>(
     bool /* valid */) {
   SetupShaderForUniform(GL_FLOAT_MAT2x3);
-}
+};
 
 template <>
 void GLES2DecoderTestBase::SpecializedSetup<
     UniformMatrix2x4fvImmediate, 0>(bool /* valid */) {
   SetupShaderForUniform(GL_FLOAT_MAT2x4);
-}
+};
 
 template <>
 void GLES2DecoderTestBase::SpecializedSetup<
     UniformMatrix3x2fvImmediate, 0>(bool /* valid */) {
   SetupShaderForUniform(GL_FLOAT_MAT3x2);
-}
+};
 
 template <>
 void GLES2DecoderTestBase::SpecializedSetup<
     UniformMatrix3x4fvImmediate, 0>(bool /* valid */) {
   SetupShaderForUniform(GL_FLOAT_MAT3x4);
-}
+};
 
 template <>
 void GLES2DecoderTestBase::SpecializedSetup<
     UniformMatrix4x2fvImmediate, 0>(bool /* valid */) {
   SetupShaderForUniform(GL_FLOAT_MAT4x2);
-}
+};
 
 template <>
 void GLES2DecoderTestBase::SpecializedSetup<
     UniformMatrix4x3fvImmediate, 0>(bool /* valid */) {
   SetupShaderForUniform(GL_FLOAT_MAT4x3);
-}
+};
 
 template <>
 void GLES2DecoderTestBase::SpecializedSetup<UseProgram, 0>(
@@ -119,7 +119,7 @@
   LinkProgram link_cmd;
   link_cmd.Init(client_program_id_);
   EXPECT_EQ(error::kNoError, ExecuteCmd(link_cmd));
-}
+};
 
 template <>
 void GLES2DecoderTestBase::SpecializedSetup<ValidateProgram, 0>(
@@ -138,7 +138,7 @@
   EXPECT_CALL(*gl_, GetProgramiv(kServiceProgramId, GL_INFO_LOG_LENGTH, _))
       .WillOnce(SetArgPointee<2>(0))
       .RetiresOnSaturation();
-}
+};
 
 TEST_P(GLES2DecoderTest3, TraceBeginCHROMIUM) {
   const uint32_t kCategoryBucketId = 123;
--- a/gpu/command_buffer/service/gles2_cmd_decoder_unittest_4.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/gles2_cmd_decoder_unittest_4.cc	2019-05-17 18:53:33.008000000 +0300
@@ -50,8 +50,8 @@
   }
 };
 
-INSTANTIATE_TEST_SUITE_P(Service, GLES2DecoderTest4, ::testing::Bool());
-INSTANTIATE_TEST_SUITE_P(Service, GLES3DecoderTest4, ::testing::Bool());
+INSTANTIATE_TEST_CASE_P(Service, GLES2DecoderTest4, ::testing::Bool());
+INSTANTIATE_TEST_CASE_P(Service, GLES3DecoderTest4, ::testing::Bool());
 
 #include "gpu/command_buffer/service/gles2_cmd_decoder_unittest_4_autogen.h"
 
--- a/gpu/command_buffer/service/gles2_cmd_decoder_unittest_attribs.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/gles2_cmd_decoder_unittest_attribs.cc	2019-05-17 18:53:33.008000000 +0300
@@ -407,7 +407,7 @@
   }
 };
 
-INSTANTIATE_TEST_SUITE_P(Service,
+INSTANTIATE_TEST_CASE_P(Service,
                          GLES2DecoderVertexArraysOESTest,
                          ::testing::Bool());
 
@@ -430,7 +430,7 @@
   }
 };
 
-INSTANTIATE_TEST_SUITE_P(Service,
+INSTANTIATE_TEST_CASE_P(Service,
                          GLES2DecoderEmulatedVertexArraysOESTest,
                          ::testing::Bool());
 
--- a/gpu/command_buffer/service/gles2_cmd_decoder_unittest_base.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/gles2_cmd_decoder_unittest_base.cc	2019-05-17 18:53:33.008000000 +0300
@@ -1407,7 +1407,6 @@
   cmds::BindTexImage2DCHROMIUM bind_tex_image_2d_cmd;
   bind_tex_image_2d_cmd.Init(target, image_id);
   EXPECT_CALL(*gl_, GetError())
-      .Times(AtMost(2))
       .WillOnce(Return(GL_NO_ERROR))
       .WillOnce(Return(GL_NO_ERROR))
       .RetiresOnSaturation();
--- a/gpu/command_buffer/service/gles2_cmd_decoder_unittest_base.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/gles2_cmd_decoder_unittest_base.h	2019-05-17 18:53:33.012000000 +0300
@@ -65,7 +65,6 @@
   void OnRescheduleAfterFinished() override;
   void OnSwapBuffers(uint64_t swap_id, uint32_t flags) override;
   void ScheduleGrContextCleanup() override {}
-  void HandleReturnData(base::span<const uint8_t> data) override {}
 
   // Template to call glGenXXX functions.
   template <typename T>
@@ -855,7 +854,6 @@
   void OnRescheduleAfterFinished() override;
   void OnSwapBuffers(uint64_t swap_id, uint32_t flags) override;
   void ScheduleGrContextCleanup() override {}
-  void HandleReturnData(base::span<const uint8_t> data) override {}
 
   void SetUp() override;
   void TearDown() override;
@@ -1001,7 +999,6 @@
     return &passthrough_discardable_manager_;
   }
   ContextGroup* group() { return group_.get(); }
-  FeatureInfo* feature_info() { return group_->feature_info(); }
 
   static const size_t kSharedBufferSize = 2048;
   static const uint32_t kSharedMemoryOffset = 132;
--- a/gpu/command_buffer/service/gles2_cmd_decoder_unittest.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/gles2_cmd_decoder_unittest.cc	2019-05-17 18:53:33.008000000 +0300
@@ -7,7 +7,6 @@
 #include <stddef.h>
 #include <stdint.h>
 
-#include "base/bind.h"
 #include "base/command_line.h"
 #include "base/stl_util.h"
 #include "base/strings/string_number_conversions.h"
@@ -466,8 +465,9 @@
                                         GL_NUM_SAMPLE_COUNTS, 1, _))
       .WillOnce(SetArgPointee<4>(kNumSampleCounts))
       .RetiresOnSaturation();
-  EXPECT_CALL(*gl_, GetInternalformativ(GL_RENDERBUFFER, GL_RGBA8, GL_SAMPLES,
-                                        kNumSampleCounts, _))
+  EXPECT_CALL(*gl_, GetInternalformativ(GL_RENDERBUFFER, GL_RGBA8,
+                                        GL_SAMPLES, kNumSampleCounts,
+                                        result->GetData()))
       .Times(1)
       .RetiresOnSaturation();
   result->size = 0;
@@ -1852,41 +1852,29 @@
   SetupDefaultProgram();
 }
 
-INSTANTIATE_TEST_SUITE_P(Service, GLES2DecoderTest, ::testing::Bool());
+INSTANTIATE_TEST_CASE_P(Service, GLES2DecoderTest, ::testing::Bool());
 
-INSTANTIATE_TEST_SUITE_P(Service,
-                         GLES2DecoderWithShaderTest,
-                         ::testing::Bool());
+INSTANTIATE_TEST_CASE_P(Service, GLES2DecoderWithShaderTest, ::testing::Bool());
 
-INSTANTIATE_TEST_SUITE_P(Service,
-                         GLES2DecoderManualInitTest,
-                         ::testing::Bool());
+INSTANTIATE_TEST_CASE_P(Service, GLES2DecoderManualInitTest, ::testing::Bool());
 
-INSTANTIATE_TEST_SUITE_P(Service,
+INSTANTIATE_TEST_CASE_P(Service,
                          GLES2DecoderRGBBackbufferTest,
                          ::testing::Bool());
 
-INSTANTIATE_TEST_SUITE_P(Service,
-                         GLES2DecoderDoCommandsTest,
-                         ::testing::Bool());
+INSTANTIATE_TEST_CASE_P(Service, GLES2DecoderDoCommandsTest, ::testing::Bool());
 
-INSTANTIATE_TEST_SUITE_P(Service,
+INSTANTIATE_TEST_CASE_P(Service,
                          GLES2DecoderDescheduleUntilFinishedTest,
                          ::testing::Bool());
 
-INSTANTIATE_TEST_SUITE_P(Service, GLES3DecoderTest, ::testing::Bool());
+INSTANTIATE_TEST_CASE_P(Service, GLES3DecoderTest, ::testing::Bool());
 
-INSTANTIATE_TEST_SUITE_P(Service, WebGL2DecoderTest, ::testing::Bool());
+INSTANTIATE_TEST_CASE_P(Service, GLES3DecoderWithShaderTest, ::testing::Bool());
 
-INSTANTIATE_TEST_SUITE_P(Service,
-                         GLES3DecoderWithShaderTest,
-                         ::testing::Bool());
-
-INSTANTIATE_TEST_SUITE_P(Service,
-                         GLES3DecoderManualInitTest,
-                         ::testing::Bool());
+INSTANTIATE_TEST_CASE_P(Service, GLES3DecoderManualInitTest, ::testing::Bool());
 
-INSTANTIATE_TEST_SUITE_P(Service,
+INSTANTIATE_TEST_CASE_P(Service,
                          GLES3DecoderRGBBackbufferTest,
                          ::testing::Bool());
 
--- a/gpu/command_buffer/service/gles2_cmd_decoder_unittest_context_lost.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/gles2_cmd_decoder_unittest_context_lost.cc	2019-05-17 18:53:33.012000000 +0300
@@ -96,7 +96,7 @@
   EXPECT_EQ(error::kUnknown, GetContextLostReason());
 }
 
-INSTANTIATE_TEST_SUITE_P(Service, GLES2DecoderDrawOOMTest, ::testing::Bool());
+INSTANTIATE_TEST_CASE_P(Service, GLES2DecoderDrawOOMTest, ::testing::Bool());
 
 class GLES2DecoderLostContextTest : public GLES2DecoderManualInitTest {
  protected:
@@ -339,7 +339,7 @@
   ClearCurrentDecoderError();
 }
 
-INSTANTIATE_TEST_SUITE_P(Service,
+INSTANTIATE_TEST_CASE_P(Service,
                          GLES2DecoderLostContextTest,
                          ::testing::Bool());
 
--- a/gpu/command_buffer/service/gles2_cmd_decoder_unittest_context_state.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/gles2_cmd_decoder_unittest_context_state.cc	2019-05-17 18:53:33.012000000 +0300
@@ -82,7 +82,7 @@
   void AddExpectationsForBindSampler(GLuint unit, GLuint id);
 };
 
-INSTANTIATE_TEST_SUITE_P(Service,
+INSTANTIATE_TEST_CASE_P(Service,
                          GLES2DecoderRestoreStateTest,
                          ::testing::Bool());
 
--- a/gpu/command_buffer/service/gles2_cmd_decoder_unittest_drawing.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/gles2_cmd_decoder_unittest_drawing.cc	2019-05-17 18:53:33.012000000 +0300
@@ -72,7 +72,7 @@
   }
 };
 
-INSTANTIATE_TEST_SUITE_P(Service,
+INSTANTIATE_TEST_CASE_P(Service,
                          GLES2DecoderGeometryInstancingTest,
                          ::testing::Bool());
 
--- a/gpu/command_buffer/service/gles2_cmd_decoder_unittest_extensions.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/gles2_cmd_decoder_unittest_extensions.cc	2019-05-17 18:53:33.012000000 +0300
@@ -30,7 +30,7 @@
  public:
   GLES2DecoderTestDisabledExtensions() = default;
 };
-INSTANTIATE_TEST_SUITE_P(Service,
+INSTANTIATE_TEST_CASE_P(Service,
                          GLES2DecoderTestDisabledExtensions,
                          ::testing::Bool());
 
@@ -477,7 +477,7 @@
   static const GLuint kServicePathId = 311;
 };
 
-INSTANTIATE_TEST_SUITE_P(Service,
+INSTANTIATE_TEST_CASE_P(Service,
                          GLES2DecoderTestWithCHROMIUMPathRendering,
                          ::testing::Bool());
 
@@ -497,7 +497,7 @@
   }
 };
 
-INSTANTIATE_TEST_SUITE_P(Service,
+INSTANTIATE_TEST_CASE_P(Service,
                          GLES2DecoderTestWithBlendEquationAdvanced,
                          ::testing::Bool());
 
@@ -518,7 +518,7 @@
     InitDecoder(init);
   }
 };
-INSTANTIATE_TEST_SUITE_P(Service,
+INSTANTIATE_TEST_CASE_P(Service,
                          GLES2DecoderTestWithEXTMultisampleCompatibility,
                          ::testing::Bool());
 
@@ -537,7 +537,7 @@
     InitDecoder(init);
   }
 };
-INSTANTIATE_TEST_SUITE_P(Service,
+INSTANTIATE_TEST_CASE_P(Service,
                          GLES2DecoderTestWithBlendFuncExtended,
                          ::testing::Bool());
 
@@ -558,7 +558,7 @@
   }
 };
 
-INSTANTIATE_TEST_SUITE_P(Service,
+INSTANTIATE_TEST_CASE_P(Service,
                          GLES2DecoderTestWithCHROMIUMFramebufferMixedSamples,
                          ::testing::Bool());
 
@@ -1742,7 +1742,7 @@
   }
 };
 
-INSTANTIATE_TEST_SUITE_P(Service,
+INSTANTIATE_TEST_CASE_P(Service,
                          GLES2DecoderTestWithCHROMIUMRasterTransport,
                          ::testing::Bool());
 
@@ -1763,7 +1763,7 @@
   }
 };
 
-INSTANTIATE_TEST_SUITE_P(Service,
+INSTANTIATE_TEST_CASE_P(Service,
                          GLES3DecoderTestWithEXTWindowRectangles,
                          ::testing::Bool());
 
--- a/gpu/command_buffer/service/gles2_cmd_decoder_unittest_framebuffers.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/gles2_cmd_decoder_unittest_framebuffers.cc	2019-05-17 18:53:33.012000000 +0300
@@ -1468,7 +1468,7 @@
   FinishReadPixelsAndCheckResult(kWidth, kHeight, pixels);
 }
 
-INSTANTIATE_TEST_SUITE_P(Service, GLES2ReadPixelsAsyncTest, ::testing::Bool());
+INSTANTIATE_TEST_CASE_P(Service, GLES2ReadPixelsAsyncTest, ::testing::Bool());
 
 // Check that if a renderbuffer is attached and GL returns
 // GL_FRAMEBUFFER_COMPLETE that the buffer is cleared and state is restored.
@@ -2389,7 +2389,7 @@
   }
 };
 
-INSTANTIATE_TEST_SUITE_P(Service,
+INSTANTIATE_TEST_CASE_P(Service,
                          GLES2DecoderMultisampledRenderToTextureTest,
                          ::testing::Bool());
 
@@ -4034,7 +4034,7 @@
   }
 }
 
-INSTANTIATE_TEST_SUITE_P(Service,
+INSTANTIATE_TEST_CASE_P(Service,
                          GLES2DecoderTestWithDrawRectangle,
                          ::testing::Bool());
 
--- a/gpu/command_buffer/service/gles2_cmd_decoder_unittest_programs.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/gles2_cmd_decoder_unittest_programs.cc	2019-05-17 18:53:33.012000000 +0300
@@ -295,7 +295,7 @@
   cmd.Init(client_program_id_, kUniform2FakeLocation, shared_memory_id_,
            kInvalidSharedMemoryOffset);
   EXPECT_NE(error::kNoError, ExecuteCmd(cmd));
-}
+};
 
 TEST_P(GLES3DecoderWithShaderTest, GetUniformuivSucceeds) {
   GetUniformuiv::Result* result =
@@ -389,7 +389,7 @@
   cmd.Init(client_program_id_, kUniform2FakeLocation, shared_memory_id_,
            kInvalidSharedMemoryOffset);
   EXPECT_NE(error::kNoError, ExecuteCmd(cmd));
-}
+};
 
 TEST_P(GLES2DecoderWithShaderTest, GetUniformfvSucceeds) {
   GetUniformfv::Result* result =
@@ -483,7 +483,7 @@
   cmd.Init(client_program_id_, kUniform2FakeLocation, shared_memory_id_,
            kInvalidSharedMemoryOffset);
   EXPECT_NE(error::kNoError, ExecuteCmd(cmd));
-}
+};
 
 TEST_P(GLES2DecoderWithShaderTest, GetAttachedShadersSucceeds) {
   GetAttachedShaders cmd;
--- a/gpu/command_buffer/service/gles2_cmd_decoder_unittest_textures.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/gles2_cmd_decoder_unittest_textures.cc	2019-05-17 18:53:33.012000000 +0300
@@ -3171,9 +3171,8 @@
   ProduceTextureDirectCHROMIUMImmediate& produce_cmd =
       *GetImmediateAs<ProduceTextureDirectCHROMIUMImmediate>();
   produce_cmd.Init(client_texture_id_, mailbox.name);
-  EXPECT_EQ(
-      error::kNoError,
-      ExecuteImmediateCmd(produce_cmd, sizeof(mailbox.name) + sizeof(GLenum)));
+  EXPECT_EQ(error::kNoError,
+            ExecuteImmediateCmd(produce_cmd, sizeof(mailbox.name)));
   EXPECT_EQ(GL_NO_ERROR, GetGLError());
 
   // Attempt to consume the mailbox with an invalid texture id.
@@ -3271,9 +3270,8 @@
 
   CreateAndTexStorage2DSharedImageINTERNALImmediate& cmd =
       *GetImmediateAs<CreateAndTexStorage2DSharedImageINTERNALImmediate>();
-  cmd.Init(kNewClientId, mailbox.name, GL_NONE);
-  EXPECT_EQ(error::kNoError,
-            ExecuteImmediateCmd(cmd, sizeof(mailbox.name) + sizeof(GLenum)));
+  cmd.Init(kNewClientId, mailbox.name);
+  EXPECT_EQ(error::kNoError, ExecuteImmediateCmd(cmd, sizeof(mailbox.name)));
   EXPECT_EQ(GL_NO_ERROR, GetGLError());
 
   // Make sure the new client ID is associated with the produced service ID.
@@ -3302,9 +3300,8 @@
 
   CreateAndTexStorage2DSharedImageINTERNALImmediate& cmd =
       *GetImmediateAs<CreateAndTexStorage2DSharedImageINTERNALImmediate>();
-  cmd.Init(kNewClientId, mailbox.name, GL_NONE);
-  EXPECT_EQ(error::kNoError,
-            ExecuteImmediateCmd(cmd, sizeof(mailbox.name) + sizeof(GLenum)));
+  cmd.Init(kNewClientId, mailbox.name);
+  EXPECT_EQ(error::kNoError, ExecuteImmediateCmd(cmd, sizeof(mailbox.name)));
 
   // CreateAndTexStorage2DSharedImage should fail if the mailbox is invalid.
   EXPECT_EQ(GL_INVALID_OPERATION, GetGLError());
@@ -3334,9 +3331,8 @@
 
   CreateAndTexStorage2DSharedImageINTERNALImmediate& cmd =
       *GetImmediateAs<CreateAndTexStorage2DSharedImageINTERNALImmediate>();
-  cmd.Init(client_texture_id_, mailbox.name, GL_NONE);
-  EXPECT_EQ(error::kNoError,
-            ExecuteImmediateCmd(cmd, sizeof(mailbox.name) + sizeof(GLenum)));
+  cmd.Init(client_texture_id_, mailbox.name);
+  EXPECT_EQ(error::kNoError, ExecuteImmediateCmd(cmd, sizeof(mailbox.name)));
 
   // CreateAndTexStorage2DSharedImage should fail.
   EXPECT_EQ(GL_INVALID_OPERATION, GetGLError());
@@ -3358,9 +3354,8 @@
 
   CreateAndTexStorage2DSharedImageINTERNALImmediate& cmd =
       *GetImmediateAs<CreateAndTexStorage2DSharedImageINTERNALImmediate>();
-  cmd.Init(kNewClientId, mailbox.name, GL_NONE);
-  EXPECT_EQ(error::kNoError,
-            ExecuteImmediateCmd(cmd, sizeof(mailbox.name) + sizeof(GLenum)));
+  cmd.Init(kNewClientId, mailbox.name);
+  EXPECT_EQ(error::kNoError, ExecuteImmediateCmd(cmd, sizeof(mailbox.name)));
   EXPECT_EQ(GL_NO_ERROR, GetGLError());
 
   // Begin/end read access for the created image.
@@ -3419,9 +3414,8 @@
 
   CreateAndTexStorage2DSharedImageINTERNALImmediate& cmd =
       *GetImmediateAs<CreateAndTexStorage2DSharedImageINTERNALImmediate>();
-  cmd.Init(kNewClientId, mailbox.name, GL_NONE);
-  EXPECT_EQ(error::kNoError,
-            ExecuteImmediateCmd(cmd, sizeof(mailbox.name) + sizeof(GLenum)));
+  cmd.Init(kNewClientId, mailbox.name);
+  EXPECT_EQ(error::kNoError, ExecuteImmediateCmd(cmd, sizeof(mailbox.name)));
   EXPECT_EQ(GL_NO_ERROR, GetGLError());
 
   // Try to begin access with a shared image representation that fails
@@ -3772,7 +3766,6 @@
   // Overridden from gl::GLImage:
   MOCK_METHOD0(GetSize, gfx::Size());
   MOCK_METHOD0(GetInternalFormat, unsigned());
-  MOCK_METHOD0(ShouldBindOrCopy, gl::GLImage::BindOrCopy());
   MOCK_METHOD1(BindTexImage, bool(unsigned));
   MOCK_METHOD1(ReleaseTexImage, void(unsigned));
   MOCK_METHOD1(CopyTexImage, bool(unsigned));
@@ -3813,10 +3806,9 @@
   GetImageManagerForTest()->AddImage(image.get(), kImageId);
 
   // Bind image to texture.
-  EXPECT_CALL(*image.get(), ShouldBindOrCopy())
-      .WillRepeatedly(Return(gl::GLImage::COPY));
   EXPECT_CALL(*image.get(), BindTexImage(GL_TEXTURE_2D))
-      .Times(0)
+      .Times(1)
+      .WillRepeatedly(Return(false))
       .RetiresOnSaturation();
   EXPECT_CALL(*image.get(), GetSize())
       .Times(1)
@@ -3853,7 +3845,8 @@
         .Times(1)
         .RetiresOnSaturation();
     EXPECT_CALL(*image.get(), BindTexImage(GL_TEXTURE_2D))
-        .Times(0)
+        .Times(1)
+        .WillRepeatedly(Return(false))
         .RetiresOnSaturation();
     EXPECT_CALL(*image.get(), CopyTexImage(GL_TEXTURE_2D))
         .Times(1)
@@ -3880,7 +3873,8 @@
   release_tex_image_2d_cmd.Init(GL_TEXTURE_2D, kImageId);
   EXPECT_EQ(error::kNoError, ExecuteCmd(release_tex_image_2d_cmd));
   EXPECT_CALL(*image.get(), BindTexImage(GL_TEXTURE_2D))
-      .Times(0)
+      .Times(2)
+      .WillRepeatedly(Return(false))
       .RetiresOnSaturation();
   EXPECT_CALL(*image.get(), GetSize())
       .Times(1)
@@ -4233,7 +4227,7 @@
   }
 };
 
-INSTANTIATE_TEST_SUITE_P(Service,
+INSTANTIATE_TEST_CASE_P(Service,
                          GLES2DecoderCompressedFormatsTest,
                          ::testing::Bool());
 
@@ -4412,7 +4406,7 @@
   }
 };
 
-INSTANTIATE_TEST_SUITE_P(Service,
+INSTANTIATE_TEST_CASE_P(Service,
                          GLES2DecoderTexStorageFormatAndTypeTest,
                          ::testing::Bool());
 
--- a/gpu/command_buffer/service/gl_stream_texture_image_stub.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/gl_stream_texture_image_stub.cc	2019-05-17 18:53:32.992000000 +0300
@@ -16,15 +16,10 @@
 unsigned GLStreamTextureImageStub::GetInternalFormat() {
   return 0;
 }
-GLStreamTextureImageStub::BindOrCopy
-GLStreamTextureImageStub::ShouldBindOrCopy() {
-  return BIND;
-}
 bool GLStreamTextureImageStub::BindTexImage(unsigned target) {
   return false;
 }
 bool GLStreamTextureImageStub::CopyTexImage(unsigned target) {
-  NOTREACHED();
   return false;
 }
 bool GLStreamTextureImageStub::CopyTexSubImage(unsigned target,
--- a/gpu/command_buffer/service/gl_stream_texture_image_stub.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/gl_stream_texture_image_stub.h	2019-05-17 18:53:32.992000000 +0300
@@ -17,7 +17,6 @@
   // Overridden from GLImage:
   gfx::Size GetSize() override;
   unsigned GetInternalFormat() override;
-  BindOrCopy ShouldBindOrCopy() override;
   bool BindTexImage(unsigned target) override;
   void ReleaseTexImage(unsigned target) override {}
   bool CopyTexImage(unsigned target) override;
--- a/gpu/command_buffer/service/gl_surface_mock.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/gl_surface_mock.h	2019-05-17 18:53:32.992000000 +0300
@@ -24,13 +24,14 @@
                     ColorSpace color_space,
                     bool alpha));
   MOCK_METHOD0(IsOffscreen, bool());
-  MOCK_METHOD1(SwapBuffers, gfx::SwapResult(PresentationCallback callback));
+  MOCK_METHOD1(SwapBuffers,
+               gfx::SwapResult(const PresentationCallback& callback));
   MOCK_METHOD5(PostSubBuffer,
                gfx::SwapResult(int x,
                                int y,
                                int width,
                                int height,
-                               PresentationCallback callback));
+                               const PresentationCallback& callback));
   MOCK_METHOD0(SupportsPostSubBuffer, bool());
   MOCK_METHOD0(GetSize, gfx::Size());
   MOCK_METHOD0(GetHandle, void*());
--- a/gpu/command_buffer/service/gl_utils.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/gl_utils.cc	2019-05-17 18:53:32.992000000 +0300
@@ -903,19 +903,6 @@
       break;
   }
 
-  // CopyTex{Sub}Image2D() from GL_RGB10_A2 has issues on some Android chipsets.
-  if (source_internal_format == GL_RGB10_A2) {
-    if (feature_info->workarounds().disable_copy_tex_image_2d_rgb10_a2_tegra) {
-      if (dest_internal_format == GL_RGBA4)
-        return CopyTextureMethod::DIRECT_DRAW;
-      return CopyTextureMethod::DRAW_AND_COPY;
-    }
-    if (feature_info->workarounds().disable_copy_tex_image_2d_rgb10_a2_adreno &&
-        dest_internal_format != GL_RGB10_A2) {
-      return CopyTextureMethod::DRAW_AND_COPY;
-    }
-  }
-
   // CopyTexImage* should not allow internalformat of GL_BGRA_EXT and
   // GL_BGRA8_EXT. https://crbug.com/663086.
   bool copy_tex_image_format_valid =
@@ -1031,8 +1018,7 @@
       source_internal_format == GL_BGRA8_EXT ||
       source_internal_format == GL_RGB_YCBCR_420V_CHROMIUM ||
       source_internal_format == GL_RGB_YCBCR_422_CHROMIUM ||
-      source_internal_format == GL_R16_EXT ||
-      source_internal_format == GL_RGB10_A2;
+      source_internal_format == GL_R16_EXT;
   if (!valid_source_format) {
     *output_error_msg = "invalid source internal format " +
                         GLES2Util::GetStringEnum(source_internal_format);
--- a/gpu/command_buffer/service/gpu_command_buffer_memory_tracker.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/gpu_command_buffer_memory_tracker.h	2019-05-17 18:53:33.016000000 +0300
@@ -8,7 +8,6 @@
 #include "base/macros.h"
 #include "base/memory/memory_pressure_listener.h"
 #include "base/single_thread_task_runner.h"
-#include "base/timer/timer.h"
 #include "gpu/command_buffer/common/command_buffer_id.h"
 #include "gpu/command_buffer/common/context_creation_attribs.h"
 #include "gpu/command_buffer/service/memory_tracking.h"
--- a/gpu/command_buffer/service/gpu_switches.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/gpu_switches.cc	2019-05-17 18:53:33.016000000 +0300
@@ -80,7 +80,4 @@
 const char kEnablePassthroughRasterDecoder[] =
     "enable-passthrough-raster-decoder";
 
-// Enable Vulkan support, must also have ENABLE_VULKAN defined.
-const char kEnableVulkan[] = "enable-vulkan";
-
 }  // namespace switches
--- a/gpu/command_buffer/service/gpu_switches.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/gpu_switches.h	2019-05-17 18:53:33.016000000 +0300
@@ -38,7 +38,6 @@
 GPU_EXPORT extern const char kUseCmdDecoder[];
 GPU_EXPORT extern const char kEnableRasterToSkImage[];
 GPU_EXPORT extern const char kEnablePassthroughRasterDecoder[];
-GPU_EXPORT extern const char kEnableVulkan[];
 
 }  // namespace switches
 
--- a/gpu/command_buffer/service/gpu_tracer_unittest.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/gpu_tracer_unittest.cc	2019-05-17 18:53:33.016000000 +0300
@@ -53,7 +53,7 @@
  public:
   explicit GPUTracerTester(GLES2Decoder* decoder)
       : GPUTracer(decoder), tracing_enabled_(0) {
-    gpu_timing_client_->SetCpuTimeForTesting(base::BindRepeating(&FakeCpuTime));
+    gpu_timing_client_->SetCpuTimeForTesting(base::Bind(&FakeCpuTime));
 
     // Force tracing to be dependent on our mock variable here.
     gpu_trace_srv_category = &tracing_enabled_;
@@ -100,7 +100,7 @@
       gl_fake_queries_.ExpectNoDisjointCalls(*gl_);
 
     gpu_timing_client_ = GetGLContext()->CreateGPUTimingClient();
-    gpu_timing_client_->SetCpuTimeForTesting(base::BindRepeating(&FakeCpuTime));
+    gpu_timing_client_->SetCpuTimeForTesting(base::Bind(&FakeCpuTime));
     gl_fake_queries_.Reset();
   }
 
--- a/gpu/command_buffer/service/gr_cache_controller.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/gr_cache_controller.cc	2019-05-17 18:53:33.016000000 +0300
@@ -6,7 +6,6 @@
 
 #include <chrono>
 
-#include "base/bind.h"
 #include "gpu/command_buffer/service/shared_context_state.h"
 #include "ui/gl/gl_context.h"
 
--- a/gpu/command_buffer/service/indexed_buffer_binding_host.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/indexed_buffer_binding_host.cc	2019-05-17 18:53:33.016000000 +0300
@@ -75,15 +75,11 @@
   effective_full_buffer_size = 0;
 }
 
-IndexedBufferBindingHost::IndexedBufferBindingHost(
-    uint32_t max_bindings,
+IndexedBufferBindingHost::IndexedBufferBindingHost(uint32_t max_bindings,
     GLenum target,
-    bool needs_emulation,
-    bool round_down_uniform_bind_buffer_range_size)
+                                                   bool needs_emulation)
     : is_bound_(false),
       needs_emulation_(needs_emulation),
-      round_down_uniform_bind_buffer_range_size_(
-          round_down_uniform_bind_buffer_range_size),
       max_non_null_binding_index_plus_one_(0u),
       target_(target) {
   DCHECK(needs_emulation);
@@ -117,8 +113,7 @@
   GLuint service_id = buffer ? buffer->service_id() : 0;
   if (buffer && needs_emulation_) {
     DoAdjustedBindBufferRange(target_, index, service_id, offset, size,
-                              buffer->size(),
-                              round_down_uniform_bind_buffer_range_size_);
+                              buffer->size());
   } else {
     glBindBufferRange(target_, index, service_id, offset, size);
   }
@@ -135,13 +130,8 @@
 
 // static
 void IndexedBufferBindingHost::DoAdjustedBindBufferRange(
-    GLenum target,
-    GLuint index,
-    GLuint service_id,
-    GLintptr offset,
-    GLsizeiptr size,
-    GLsizeiptr full_buffer_size,
-    bool round_down_uniform_bind_buffer_range_size) {
+    GLenum target, GLuint index, GLuint service_id, GLintptr offset,
+    GLsizeiptr size, GLsizeiptr full_buffer_size) {
   GLsizeiptr adjusted_size = size;
   if (offset >= full_buffer_size) {
     // Situation 1: We can't really call glBindBufferRange with reasonable
@@ -152,8 +142,7 @@
     // MacOSX with AMD/4.1.
     glBindBufferBase(target, index, service_id);
     return;
-  }
-  if (offset + size > full_buffer_size) {
+  } else if (offset + size > full_buffer_size) {
     adjusted_size = full_buffer_size - offset;
     // size needs to be a multiple of 4.
     adjusted_size = adjusted_size & ~3;
@@ -164,22 +153,6 @@
       return;
     }
   }
-  if (round_down_uniform_bind_buffer_range_size) {
-    adjusted_size = adjusted_size & ~3;
-    if (adjusted_size == 0) {
-      // This case is invalid and we shouldn't call the driver.
-      // Without rounding, this would generate INVALID_OPERATION
-      // at draw time because the size is not enough to fill the smallest
-      // possible uniform block (4 bytes).
-      // The size of the range is set in DoBindBufferRange and validated in
-      // BufferManager::RequestBuffersAccess. It is fine to not bind the buffer
-      // because any draw call with this buffer range binding will generate
-      // INVALID_OPERATION.
-      // Clear the buffer binding because it will not be used.
-      glBindBufferBase(target, index, 0);
-      return;
-    }
-  }
   glBindBufferRange(target, index, service_id, offset, adjusted_size);
 }
 
@@ -195,8 +168,7 @@
           buffer_bindings_[ii].effective_full_buffer_size != buffer->size()) {
         DoAdjustedBindBufferRange(target_, ii, buffer->service_id(),
                                   buffer_bindings_[ii].offset,
-                                  buffer_bindings_[ii].size, buffer->size(),
-                                  round_down_uniform_bind_buffer_range_size_);
+                                  buffer_bindings_[ii].size, buffer->size());
         buffer_bindings_[ii].effective_full_buffer_size = buffer->size();
       }
     }
@@ -234,8 +206,7 @@
           buffer_bindings_[ii].effective_full_buffer_size != buffer->size()) {
         DoAdjustedBindBufferRange(target_, ii, buffer->service_id(),
                                   buffer_bindings_[ii].offset,
-                                  buffer_bindings_[ii].size, buffer->size(),
-                                  round_down_uniform_bind_buffer_range_size_);
+                                  buffer_bindings_[ii].size, buffer->size());
         buffer_bindings_[ii].effective_full_buffer_size = buffer->size();
       }
     }
--- a/gpu/command_buffer/service/indexed_buffer_binding_host.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/indexed_buffer_binding_host.h	2019-05-17 18:53:33.016000000 +0300
@@ -27,8 +27,7 @@
   // out-of-bounds buffer accesses.
   IndexedBufferBindingHost(uint32_t max_bindings,
                            GLenum target,
-                           bool needs_emulation,
-                           bool round_down_uniform_bind_buffer_range_size);
+                           bool needs_emulation);
 
   // The following two functions do state update and call the underlying GL
   // function.  All validations have been done already and the GL function is
@@ -112,20 +111,14 @@
   // This is called when |needs_emulation_| is true, where the range
   // (offset + size) can't go beyond the buffer's size.
   static void DoAdjustedBindBufferRange(
-      GLenum target,
-      GLuint index,
-      GLuint service_id,
-      GLintptr offset,
-      GLsizeiptr size,
-      GLsizeiptr full_buffer_size,
-      bool round_down_uniform_bind_buffer_range_size);
+      GLenum target, GLuint index, GLuint service_id, GLintptr offset,
+      GLsizeiptr size, GLsizeiptr full_buffer_size);
 
   void UpdateMaxNonNullBindingIndex(size_t changed_index);
 
   std::vector<IndexedBufferBinding> buffer_bindings_;
 
   bool needs_emulation_;
-  bool round_down_uniform_bind_buffer_range_size_;
 
   // This is used for optimization purpose in context switching.
   size_t max_non_null_binding_index_plus_one_;
--- a/gpu/command_buffer/service/indexed_buffer_binding_host_unittest.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/indexed_buffer_binding_host_unittest.cc	2019-05-17 18:53:33.016000000 +0300
@@ -21,12 +21,10 @@
   IndexedBufferBindingHostTest()
       : uniform_host_(new IndexedBufferBindingHost(kMaxBindings,
                                                    GL_UNIFORM_BUFFER,
-                                                   true,
-                                                   false)),
+                                                   true)),
         tf_host_(new IndexedBufferBindingHost(kMaxBindings,
                                               GL_TRANSFORM_FEEDBACK_BUFFER,
-                                              true,
-                                              false)),
+                                              true)),
         buffer_manager_(new BufferManager(nullptr, nullptr)) {
     buffer_manager_->CreateBuffer(kBufferClientId, kBufferServiceId);
     buffer_ = buffer_manager_->GetBuffer(kBufferClientId);
@@ -142,7 +140,7 @@
   uniform_host_->DoBindBufferBase(kIndex, buffer_.get());
   // Set up the second host
   scoped_refptr<IndexedBufferBindingHost> other =
-      new IndexedBufferBindingHost(kMaxBindings, kTarget, true, false);
+      new IndexedBufferBindingHost(kMaxBindings, kTarget, true);
   EXPECT_CALL(*gl_, BindBufferRange(kTarget, kOtherIndex, kBufferServiceId,
                                     kOffset, clamped_size))
       .Times(1)
--- a/gpu/command_buffer/service/memory_program_cache.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/memory_program_cache.cc	2019-05-17 18:53:33.020000000 +0300
@@ -13,6 +13,7 @@
 #include "base/metrics/histogram_functions.h"
 #include "base/metrics/histogram_macros.h"
 #include "base/numerics/checked_math.h"
+#include "base/sha1.h"
 #include "base/strings/string_number_conversions.h"
 #include "base/system/sys_info.h"
 #include "build/build_config.h"
--- a/gpu/command_buffer/service/memory_program_cache_unittest.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/memory_program_cache_unittest.cc	2019-05-17 18:53:33.020000000 +0300
@@ -98,7 +98,6 @@
   void OnRescheduleAfterFinished() override {}
   void OnSwapBuffers(uint64_t swap_id, uint32_t flags) override {}
   void ScheduleGrContextCleanup() override {}
-  void HandleReturnData(base::span<const uint8_t> data) override {}
 
   int32_t shader_cache_count() { return shader_cache_count_; }
   const std::string& shader_cache_shader() { return shader_cache_shader_; }
--- a/gpu/command_buffer/service/multi_draw_manager.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/multi_draw_manager.cc	2019-05-17 18:53:33.020000000 +0300
@@ -12,8 +12,8 @@
 namespace gpu {
 namespace gles2 {
 
-MultiDrawManager::ResultData::ResultData() = default;
-MultiDrawManager::ResultData::~ResultData() = default;
+MultiDrawManager::ResultData::ResultData()
+    : draw_function(DrawFunction::None) {}
 
 MultiDrawManager::ResultData::ResultData(ResultData&& rhs)
     : draw_function(rhs.draw_function),
@@ -25,6 +25,7 @@
       offsets(std::move(rhs.offsets)),
       indices(std::move(rhs.indices)),
       instance_counts(std::move(rhs.instance_counts)) {
+  rhs.draw_function = DrawFunction::None;
 }
 
 MultiDrawManager::ResultData& MultiDrawManager::ResultData::operator=(
@@ -41,32 +42,33 @@
   std::swap(offsets, rhs.offsets);
   std::swap(indices, rhs.indices);
   std::swap(instance_counts, rhs.instance_counts);
+
+  rhs.draw_function = DrawFunction::None;
   return *this;
 }
 
+MultiDrawManager::ResultData::~ResultData() {}
+
 MultiDrawManager::MultiDrawManager(IndexStorageType index_type)
-    : draw_state_(DrawState::End),
-      current_draw_offset_(0),
-      index_type_(index_type),
-      result_() {}
+    : current_draw_offset_(0), index_type_(index_type), result_() {}
 
 bool MultiDrawManager::Begin(GLsizei drawcount) {
-  if (draw_state_ != DrawState::End) {
-    return false;
-  }
   result_.drawcount = drawcount;
   current_draw_offset_ = 0;
-  draw_state_ = DrawState::Begin;
+  if (result_.draw_function != DrawFunction::None) {
+    NOTREACHED();
+    return false;
+  }
   return true;
 }
 
 bool MultiDrawManager::End(ResultData* result) {
   DCHECK(result);
-  if (draw_state_ != DrawState::Draw ||
+
+  if (result_.draw_function == DrawFunction::None ||
       current_draw_offset_ != result_.drawcount) {
     return false;
   }
-  draw_state_ = DrawState::End;
   *result = std::move(result_);
   return true;
 }
@@ -75,7 +77,10 @@
                                        const GLint* firsts,
                                        const GLsizei* counts,
                                        GLsizei drawcount) {
-  if (!EnsureDrawArraysFunction(DrawFunction::DrawArrays, mode, drawcount)) {
+  if (!EnsureDrawArraysFunction(DrawFunction::DrawArrays, mode) ||
+      base::CheckAdd(current_draw_offset_, drawcount).ValueOrDie() >
+          result_.drawcount) {
+    NOTREACHED();
     return false;
   }
   std::copy(firsts, firsts + drawcount, &result_.firsts[current_draw_offset_]);
@@ -89,8 +94,10 @@
                                                 const GLsizei* counts,
                                                 const GLsizei* instance_counts,
                                                 GLsizei drawcount) {
-  if (!EnsureDrawArraysFunction(DrawFunction::DrawArraysInstanced, mode,
-                                drawcount)) {
+  if (!EnsureDrawArraysFunction(DrawFunction::DrawArraysInstanced, mode) ||
+      base::CheckAdd(current_draw_offset_, drawcount).ValueOrDie() >
+          result_.drawcount) {
+    NOTREACHED();
     return false;
   }
   std::copy(firsts, firsts + drawcount, &result_.firsts[current_draw_offset_]);
@@ -106,8 +113,10 @@
                                          GLenum type,
                                          const GLsizei* offsets,
                                          GLsizei drawcount) {
-  if (!EnsureDrawElementsFunction(DrawFunction::DrawElements, mode, type,
-                                  drawcount)) {
+  if (!EnsureDrawElementsFunction(DrawFunction::DrawElements, mode, type) ||
+      base::CheckAdd(current_draw_offset_, drawcount).ValueOrDie() >
+          result_.drawcount) {
+    NOTREACHED();
     return false;
   }
   std::copy(counts, counts + drawcount, &result_.counts[current_draw_offset_]);
@@ -136,7 +145,10 @@
     const GLsizei* instance_counts,
     GLsizei drawcount) {
   if (!EnsureDrawElementsFunction(DrawFunction::DrawElementsInstanced, mode,
-                                  type, drawcount)) {
+                                  type) ||
+      base::CheckAdd(current_draw_offset_, drawcount).ValueOrDie() >
+          result_.drawcount) {
+    NOTREACHED();
     return false;
   }
   std::copy(counts, counts + drawcount, &result_.counts[current_draw_offset_]);
@@ -187,65 +199,30 @@
   }
 }
 
-bool MultiDrawManager::ValidateDrawcount(GLsizei drawcount) const {
-  if (drawcount < 0) {
-    return false;
-  }
-  GLsizei new_offset;
-  if (!base::CheckAdd(current_draw_offset_, drawcount)
-           .AssignIfValid(&new_offset)) {
-    return false;
-  }
-  if (new_offset > result_.drawcount) {
-    return false;
-  }
-  return true;
-}
-
 bool MultiDrawManager::EnsureDrawArraysFunction(DrawFunction draw_function,
-                                                GLenum mode,
-                                                GLsizei drawcount) {
-  if (!ValidateDrawcount(drawcount)) {
-    return false;
-  }
-  bool invalid_draw_state = draw_state_ == DrawState::End;
-  bool first_call = draw_state_ == DrawState::Begin;
+                                                GLenum mode) {
+  bool first_call = result_.draw_function == DrawFunction::None;
   bool enums_match = result_.mode == mode;
-
-  if (invalid_draw_state || (!first_call && !enums_match)) {
-    return false;
-  }
   if (first_call) {
-    draw_state_ = DrawState::Draw;
     result_.draw_function = draw_function;
     result_.mode = mode;
     ResizeArrays();
   }
-  return true;
+  return first_call || enums_match;
 }
 
 bool MultiDrawManager::EnsureDrawElementsFunction(DrawFunction draw_function,
                                                   GLenum mode,
-                                                  GLenum type,
-                                                  GLsizei drawcount) {
-  if (!ValidateDrawcount(drawcount)) {
-    return false;
-  }
-  bool invalid_draw_state = draw_state_ == DrawState::End;
-  bool first_call = draw_state_ == DrawState::Begin;
+                                                  GLenum type) {
+  bool first_call = result_.draw_function == DrawFunction::None;
   bool enums_match = result_.mode == mode && result_.type == type;
-
-  if (invalid_draw_state || (!first_call && !enums_match)) {
-    return false;
-  }
   if (first_call) {
-    draw_state_ = DrawState::Draw;
     result_.draw_function = draw_function;
     result_.mode = mode;
     result_.type = type;
     ResizeArrays();
   }
-  return true;
+  return first_call || enums_match;
 }
 
 }  // namespace gles2
--- a/gpu/command_buffer/service/multi_draw_manager.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/multi_draw_manager.h	2019-05-17 18:53:33.020000000 +0300
@@ -20,17 +20,18 @@
 class GPU_GLES2_EXPORT MultiDrawManager {
  public:
   enum class DrawFunction {
+    None,
     DrawArrays,
     DrawArraysInstanced,
     DrawElements,
     DrawElementsInstanced,
   };
 
-  struct GPU_GLES2_EXPORT ResultData {
+  struct ResultData {
     DrawFunction draw_function;
-    GLsizei drawcount = 0;
-    GLenum mode = 0;
-    GLenum type = 0;
+    GLsizei drawcount;
+    GLenum mode;
+    GLenum type;
     std::vector<GLint> firsts;
     std::vector<GLsizei> counts;
     std::vector<GLsizei> offsets;
@@ -38,9 +39,9 @@
     std::vector<GLsizei> instance_counts;
 
     ResultData();
-    ~ResultData();
     ResultData(ResultData&& rhs);
     ResultData& operator=(ResultData&& rhs);
+    ~ResultData();
   };
 
   enum class IndexStorageType {
@@ -75,22 +76,11 @@
 
  private:
   void ResizeArrays();
-  bool ValidateDrawcount(GLsizei drawcount) const;
-  bool EnsureDrawArraysFunction(DrawFunction draw_function,
-                                GLenum mode,
-                                GLsizei drawcount);
+  bool EnsureDrawArraysFunction(DrawFunction draw_function, GLenum mode);
   bool EnsureDrawElementsFunction(DrawFunction draw_function,
                                   GLenum mode,
-                                  GLenum type,
-                                  GLsizei drawcount);
-
-  enum class DrawState {
-    Begin,
-    Draw,
-    End,
-  };
+                                  GLenum type);
 
-  DrawState draw_state_;
   GLsizei current_draw_offset_;
   IndexStorageType index_type_;
   ResultData result_;
--- a/gpu/command_buffer/service/passthrough_program_cache_unittest.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/passthrough_program_cache_unittest.cc	2019-05-17 18:53:33.020000000 +0300
@@ -48,7 +48,6 @@
   void OnRescheduleAfterFinished() override {}
   void OnSwapBuffers(uint64_t swap_id, uint32_t flags) override {}
   void ScheduleGrContextCleanup() override {}
-  void HandleReturnData(base::span<const uint8_t> data) override {}
 
   int32_t blob_count() { return blob_count_; }
 
--- a/gpu/command_buffer/service/program_manager.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/program_manager.cc	2019-05-17 18:53:33.024000000 +0300
@@ -987,7 +987,7 @@
     if (size > 1) {
       for (GLsizei ii = 1; ii < size; ++ii) {
         std::string element_name(service_base_name + "[" +
-                                 base::NumberToString(ii) + "]");
+                                 base::IntToString(ii) + "]");
         service_locations[ii] =
             glGetUniformLocation(service_id_, element_name.c_str());
       }
@@ -1111,7 +1111,7 @@
     }
 
     for (GLsizei jj = 1; jj < size; ++jj) {
-      std::string array_spec(std::string("[") + base::NumberToString(jj) + "]");
+      std::string array_spec(std::string("[") + base::IntToString(jj) + "]");
       std::string client_element_name =
           parsed_client_name.base_name() + array_spec;
 
@@ -1177,16 +1177,15 @@
       if (color_name >= 0) {
         GLint index = 0;
         for (size_t ii = 0; ii < output_var.getOutermostArraySize(); ++ii) {
-          std::string array_spec(std::string("[") + base::NumberToString(ii) +
-                                 "]");
+          std::string array_spec(
+              std::string("[") + base::IntToString(ii) + "]");
           program_output_infos_.push_back(ProgramOutputInfo(
               color_name + ii, index, client_name + array_spec));
         }
       }
     } else {
       for (size_t ii = 0; ii < output_var.getOutermostArraySize(); ++ii) {
-        std::string array_spec(std::string("[") + base::NumberToString(ii) +
-                               "]");
+        std::string array_spec(std::string("[") + base::IntToString(ii) + "]");
         std::string service_element_name(service_name + array_spec);
         GLint color_name =
             glGetFragDataLocation(service_id_, service_element_name.c_str());
@@ -1267,7 +1266,7 @@
         std::string name = output_var.name;
         std::string array_spec;
         if (is_array) {
-          array_spec = std::string("[") + base::NumberToString(jj) + "]";
+          array_spec = std::string("[") + base::IntToString(jj) + "]";
           name += array_spec;
         }
         auto it = bind_program_output_location_index_map_.find(name);
@@ -2083,7 +2082,7 @@
     for (size_t jj = 0; jj < count; ++jj) {
       std::string name = output_var.name;
       if (is_array)
-        name += std::string("[") + base::NumberToString(jj) + "]";
+        name += std::string("[") + base::IntToString(jj) + "]";
 
       auto it = bind_program_output_location_index_map_.find(name);
       if (it == bind_program_output_location_index_map_.end())
--- a/gpu/command_buffer/service/program_manager_unittest.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/program_manager_unittest.cc	2019-05-17 18:53:33.024000000 +0300
@@ -95,7 +95,6 @@
   void OnRescheduleAfterFinished() override {}
   void OnSwapBuffers(uint64_t swap_id, uint32_t flags) override {}
   void ScheduleGrContextCleanup() override {}
-  void HandleReturnData(base::span<const uint8_t> data) override {}
 
   std::unique_ptr<ProgramManager> manager_;
   GpuPreferences gpu_preferences_;
@@ -2546,7 +2545,7 @@
 }
 }
 
-INSTANTIATE_TEST_SUITE_P(
+INSTANTIATE_TEST_CASE_P(
     SupportedContexts,
     ProgramManagerWithPathRenderingTest,
     testing::Values(
@@ -2636,7 +2635,7 @@
   EXPECT_TRUE(LinkAsExpected(program, true));
 }
 
-INSTANTIATE_TEST_SUITE_P(
+INSTANTIATE_TEST_CASE_P(
     SupportedContexts,
     ProgramManagerDualSourceBlendingES2Test,
     testing::Values(
--- a/gpu/command_buffer/service/query_manager_unittest.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/query_manager_unittest.cc	2019-05-17 18:53:33.024000000 +0300
@@ -7,7 +7,6 @@
 
 #include <memory>
 
-#include "base/bind.h"
 #include "gpu/command_buffer/client/client_test_helper.h"
 #include "gpu/command_buffer/common/gles2_cmd_format.h"
 #include "gpu/command_buffer/service/error_state_mock.h"
@@ -562,7 +561,7 @@
   const base::subtle::Atomic32 kSubmitCount = 123;
   gl::GPUTimingFake fake_timing_queries;
   decoder_->GetGLContext()->CreateGPUTimingClient()->SetCpuTimeForTesting(
-      base::BindRepeating(&gl::GPUTimingFake::GetFakeCPUTime));
+      base::Bind(&gl::GPUTimingFake::GetFakeCPUTime));
 
   QueryManager::Query* query = CreateQuery(
       kTarget, kClient1Id, shared_memory_id_, kSharedMemoryOffset, 0);
@@ -594,7 +593,7 @@
   const base::subtle::Atomic32 kSubmitCount = 123;
   gl::GPUTimingFake fake_timing_queries;
   decoder_->GetGLContext()->CreateGPUTimingClient()->SetCpuTimeForTesting(
-      base::BindRepeating(&gl::GPUTimingFake::GetFakeCPUTime));
+      base::Bind(&gl::GPUTimingFake::GetFakeCPUTime));
 
   QueryManager::Query* query = CreateQuery(
       kTarget, kClient1Id, shared_memory_id_, kSharedMemoryOffset, 0);
@@ -699,7 +698,7 @@
   gl::GPUTimingFake fake_timing_queries;
 
   decoder_->GetGLContext()->CreateGPUTimingClient()->SetCpuTimeForTesting(
-      base::BindRepeating(&gl::GPUTimingFake::GetFakeCPUTime));
+      base::Bind(&gl::GPUTimingFake::GetFakeCPUTime));
 
   QueryManager::Query* query = CreateQuery(
       kTarget, kClient1Id, shared_memory_id_, kSharedMemoryOffset, 0);
@@ -726,7 +725,7 @@
   gl::GPUTimingFake fake_timing_queries;
 
   decoder_->GetGLContext()->CreateGPUTimingClient()->SetCpuTimeForTesting(
-      base::BindRepeating(&gl::GPUTimingFake::GetFakeCPUTime));
+      base::Bind(&gl::GPUTimingFake::GetFakeCPUTime));
 
   QueryManager::Query* query = CreateQuery(
       kTarget, kClient1Id, shared_memory_id_, kSharedMemoryOffset, 0);
--- a/gpu/command_buffer/service/raster_decoder_autogen.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/raster_decoder_autogen.h	2019-05-17 18:53:33.028000000 +0300
@@ -114,6 +114,8 @@
   GLuint sk_color = static_cast<GLuint>(c.sk_color);
   GLuint msaa_sample_count = static_cast<GLuint>(c.msaa_sample_count);
   GLboolean can_use_lcd_text = static_cast<GLboolean>(c.can_use_lcd_text);
+  GLuint color_space_transfer_cache_id =
+      static_cast<GLuint>(c.color_space_transfer_cache_id);
   uint32_t mailbox_size;
   if (!gles2::GLES2Util::ComputeDataSize<GLbyte, 16>(1, &mailbox_size)) {
     return error::kOutOfBounds;
@@ -127,7 +129,8 @@
   if (mailbox == nullptr) {
     return error::kOutOfBounds;
   }
-  DoBeginRasterCHROMIUM(sk_color, msaa_sample_count, can_use_lcd_text, mailbox);
+  DoBeginRasterCHROMIUM(sk_color, msaa_sample_count, can_use_lcd_text,
+                        color_space_transfer_cache_id, mailbox);
   return error::kNoError;
 }
 
--- a/gpu/command_buffer/service/raster_decoder.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/raster_decoder.cc	2019-05-17 18:53:33.024000000 +0300
@@ -9,11 +9,9 @@
 #include <algorithm>
 #include <memory>
 #include <string>
-#include <utility>
 #include <vector>
 
 #include "base/atomic_sequence_num.h"
-#include "base/bind.h"
 #include "base/containers/flat_map.h"
 #include "base/debug/crash_logging.h"
 #include "base/logging.h"
@@ -23,6 +21,7 @@
 #include "base/strings/stringprintf.h"
 #include "base/trace_event/trace_event.h"
 #include "build/build_config.h"
+#include "cc/paint/color_space_transfer_cache_entry.h"
 #include "cc/paint/paint_cache.h"
 #include "cc/paint/paint_op_buffer.h"
 #include "cc/paint/transfer_cache_entry.h"
@@ -37,6 +36,7 @@
 #include "gpu/command_buffer/common/raster_cmd_ids.h"
 #include "gpu/command_buffer/common/sync_token.h"
 #include "gpu/command_buffer/service/command_buffer_service.h"
+#include "gpu/command_buffer/service/context_group.h"
 #include "gpu/command_buffer/service/context_state.h"
 #include "gpu/command_buffer/service/decoder_client.h"
 #include "gpu/command_buffer/service/error_state.h"
@@ -52,13 +52,13 @@
 #include "gpu/command_buffer/service/raster_cmd_validation.h"
 #include "gpu/command_buffer/service/service_font_manager.h"
 #include "gpu/command_buffer/service/service_transfer_cache.h"
-#include "gpu/command_buffer/service/service_utils.h"
 #include "gpu/command_buffer/service/shared_context_state.h"
 #include "gpu/command_buffer/service/shared_image_factory.h"
 #include "gpu/command_buffer/service/shared_image_representation.h"
 #include "gpu/command_buffer/service/skia_utils.h"
 #include "gpu/command_buffer/service/wrapped_sk_image.h"
 #include "third_party/skia/include/core/SkCanvas.h"
+#include "third_party/skia/include/core/SkColorSpaceXformCanvas.h"
 #include "third_party/skia/include/core/SkDeferredDisplayListRecorder.h"
 #include "third_party/skia/include/core/SkSurface.h"
 #include "third_party/skia/include/core/SkSurfaceProps.h"
@@ -218,10 +218,7 @@
   RasterDecoderImpl(DecoderClient* client,
                     CommandBufferServiceBase* command_buffer_service,
                     gles2::Outputter* outputter,
-                    const GpuFeatureInfo& gpu_feature_info,
-                    const GpuPreferences& gpu_preferences,
-                    MemoryTracker* memory_tracker,
-                    SharedImageManager* shared_image_manager,
+                    gles2::ContextGroup* group,
                     scoped_refptr<SharedContextState> shared_context_state);
   ~RasterDecoderImpl() override;
 
@@ -240,7 +237,7 @@
   gl::GLContext* GetGLContext() override;
   gl::GLSurface* GetGLSurface() override;
   const gles2::FeatureInfo* GetFeatureInfo() const override {
-    return feature_info();
+    return feature_info_.get();
   }
   Capabilities GetCapabilities() override;
   const gles2::ContextState* GetContextState() override;
@@ -338,7 +335,6 @@
     NOTIMPLEMENTED();
     return false;
   }
-  int GetRasterDecoderId() const override;
   int DecoderIdForTest() override;
   ServiceTransferCache* GetTransferCacheForTest() override;
   void SetUpForRasterCHROMIUMForTest() override;
@@ -363,7 +359,7 @@
 
  private:
   gles2::ContextState* state() const {
-    if (use_passthrough_) {
+    if (use_passthrough()) {
       NOTREACHED();
       return nullptr;
     }
@@ -375,29 +371,12 @@
     return shared_context_state_->transfer_cache();
   }
 
-  const gles2::FeatureInfo* feature_info() const {
-    return shared_context_state_->feature_info();
-  }
-
   const gles2::FeatureInfo::FeatureFlags& features() const {
-    return feature_info()->feature_flags();
+    return feature_info_->feature_flags();
   }
 
   const GpuDriverBugWorkarounds& workarounds() const {
-    return feature_info()->workarounds();
-  }
-
-  void FlushToWorkAroundMacCrashes() {
-#if defined(OS_MACOSX)
-    // This function does aggressive flushes to work around crashes in the
-    // macOS OpenGL driver.
-    // https://crbug.com/906453
-    if (!flush_workaround_disabled_for_test_) {
-      if (gr_context())
-        gr_context()->flush();
-      api()->glFlushFn();
-    }
-#endif
+    return feature_info_->workarounds();
   }
 
   bool IsRobustnessSupported() {
@@ -407,9 +386,23 @@
   }
 
   const gl::GLVersionInfo& gl_version_info() {
-    return feature_info()->gl_version_info();
+    return feature_info_->gl_version_info();
+  }
+
+  MemoryTracker* memory_tracker() { return group_->memory_tracker(); }
+
+  bool use_passthrough() const { return group_->use_passthrough_cmd_decoder(); }
+
+  gles2::BufferManager* buffer_manager() { return group_->buffer_manager(); }
+
+  const gles2::TextureManager* texture_manager() const {
+    return group_->texture_manager();
   }
 
+  gles2::TextureManager* texture_manager() { return group_->texture_manager(); }
+
+  gles2::ImageManager* image_manager() { return group_->image_manager(); }
+
   // Set remaining commands to process to 0 to force DoCommands to return
   // and allow context preemption and GPU watchdog checks in
   // CommandExecutor().
@@ -436,10 +429,15 @@
                                 GLsizei width,
                                 GLsizei height,
                                 const volatile GLbyte* mailboxes);
+  // If the texture has an image but that image is not bound or copied to the
+  // texture, this will first attempt to bind it, and if that fails
+  // CopyTexImage on it.
+  void DoBindOrCopyTexImageIfNeeded(gles2::Texture* texture, GLenum textarget);
   void DoLoseContextCHROMIUM(GLenum current, GLenum other) { NOTIMPLEMENTED(); }
   void DoBeginRasterCHROMIUM(GLuint sk_color,
                              GLuint msaa_sample_count,
                              GLboolean can_use_lcd_text,
+                             GLuint color_space_transfer_cache_id,
                              const volatile GLbyte* key);
   void DoRasterCHROMIUM(GLuint raster_shm_id,
                         GLuint raster_shm_offset,
@@ -478,7 +476,7 @@
   void LogClientServiceMapping(const char* function_name,
                                GLuint client_id,
                                GLuint service_id) {
-    if (gpu_preferences_.enable_gpu_service_logging_gpu) {
+    if (service_logging_) {
       VLOG(1) << "[" << logger_.GetLogPrefix() << "] " << function_name
               << ": client_id = " << client_id
               << ", service_id = " << service_id;
@@ -522,9 +520,7 @@
   // Number of commands remaining to be processed in DoCommands().
   int commands_to_process_ = 0;
 
-  bool supports_gpu_raster_ = false;
   bool supports_oop_raster_ = false;
-  bool use_passthrough_ = false;
   bool use_ddl_ = false;
 
   bool has_robustness_extension_ = false;
@@ -539,24 +535,27 @@
 
   DecoderClient* client_;
 
-  GpuPreferences gpu_preferences_;
-
   gles2::DebugMarkerManager debug_marker_manager_;
   gles2::Logger logger_;
   std::unique_ptr<gles2::ErrorState> error_state_;
   bool context_lost_ = false;
 
+  // The ContextGroup for this decoder uses to track resources.
+  scoped_refptr<gles2::ContextGroup> group_;
   scoped_refptr<SharedContextState> shared_context_state_;
   std::unique_ptr<Validators> validators_;
+  scoped_refptr<gles2::FeatureInfo> feature_info_;
 
-  SharedImageRepresentationFactory shared_image_representation_factory_;
   std::unique_ptr<QueryManager> query_manager_;
 
   gles2::GLES2Util util_;
 
-  // An optional behaviour to lose the context when OOM.
+  // An optional behaviour to lose the context and group when OOM.
   bool lose_context_when_out_of_memory_ = false;
 
+  // Log extra info.
+  bool service_logging_;
+
   std::unique_ptr<gles2::CopyTexImageResourceManager> copy_tex_image_blit_;
   std::unique_ptr<gles2::CopyTextureCHROMIUMResourceManager>
       copy_texture_chromium_;
@@ -574,7 +573,8 @@
   std::unique_ptr<cc::ServicePaintCache> paint_cache_;
 
   std::unique_ptr<SkDeferredDisplayListRecorder> recorder_;
-  SkCanvas* raster_canvas_ = nullptr;  // ptr into recorder_ or sk_surface_
+  std::unique_ptr<SkCanvas> raster_canvas_;
+  uint32_t raster_color_space_id_;
   std::vector<SkDiscardableHandleId> locked_handles_;
 
   // Tracing helpers.
@@ -610,14 +610,9 @@
     DecoderClient* client,
     CommandBufferServiceBase* command_buffer_service,
     gles2::Outputter* outputter,
-    const GpuFeatureInfo& gpu_feature_info,
-    const GpuPreferences& gpu_preferences,
-    MemoryTracker* memory_tracker,
-    SharedImageManager* shared_image_manager,
+    gles2::ContextGroup* group,
     scoped_refptr<SharedContextState> shared_context_state) {
-  return new RasterDecoderImpl(client, command_buffer_service, outputter,
-                               gpu_feature_info, gpu_preferences,
-                               memory_tracker, shared_image_manager,
+  return new RasterDecoderImpl(client, command_buffer_service, outputter, group,
                                std::move(shared_context_state));
 }
 
@@ -665,30 +660,23 @@
     DecoderClient* client,
     CommandBufferServiceBase* command_buffer_service,
     gles2::Outputter* outputter,
-    const GpuFeatureInfo& gpu_feature_info,
-    const GpuPreferences& gpu_preferences,
-    MemoryTracker* memory_tracker,
-    SharedImageManager* shared_image_manager,
+    gles2::ContextGroup* group,
     scoped_refptr<SharedContextState> shared_context_state)
     : RasterDecoder(command_buffer_service, outputter),
       raster_decoder_id_(g_raster_decoder_id.GetNext() + 1),
-      supports_gpu_raster_(
-          gpu_feature_info.status_values[GPU_FEATURE_TYPE_GPU_RASTERIZATION] ==
-          kGpuFeatureStatusEnabled),
-      use_passthrough_(gles2::PassthroughCommandDecoderSupported() &&
-                       gpu_preferences.use_passthrough_cmd_decoder),
       client_(client),
-      gpu_preferences_(gpu_preferences),
       logger_(&debug_marker_manager_,
               base::BindRepeating(&DecoderClient::OnConsoleMessage,
                                   base::Unretained(client_),
                                   0),
-              gpu_preferences_.disable_gl_error_limit),
+              group->gpu_preferences().disable_gl_error_limit),
       error_state_(gles2::ErrorState::Create(this, &logger_)),
+      group_(group),
       shared_context_state_(std::move(shared_context_state)),
       validators_(new Validators),
-      shared_image_representation_factory_(shared_image_manager,
-                                           memory_tracker),
+      feature_info_(group_->feature_info()),
+      service_logging_(
+          group_->gpu_preferences().enable_gpu_service_logging_gpu),
       gpu_decoder_category_(TRACE_EVENT_API_GET_CATEGORY_GROUP_ENABLED(
           TRACE_DISABLED_BY_DEFAULT("gpu.decoder"))),
       font_manager_(base::MakeRefCounted<ServiceFontManager>(this)),
@@ -723,10 +711,10 @@
     return ContextResult::kFatalFailure;
   }
 
-  if (gpu_preferences_.enable_gpu_debugging)
+  if (group_->gpu_preferences().enable_gpu_debugging)
     set_debug(true);
 
-  if (gpu_preferences_.enable_gpu_command_logging)
+  if (group_->gpu_preferences().enable_gpu_command_logging)
     SetLogCommands(true);
 
   DCHECK_EQ(surface.get(), shared_context_state_->surface());
@@ -740,6 +728,15 @@
   lose_context_when_out_of_memory_ =
       attrib_helper.lose_context_when_out_of_memory;
 
+  auto result =
+      group_->Initialize(this, attrib_helper.context_type, disallowed_features);
+  if (result != ContextResult::kSuccess) {
+    group_ =
+        nullptr;  // Must not destroy ContextGroup if it is not initialized.
+    Destroy(true);
+    return result;
+  }
+
   CHECK_GL_ERROR();
 
   query_manager_ = std::make_unique<QueryManager>();
@@ -759,7 +756,7 @@
     supports_oop_raster_ = !!shared_context_state_->gr_context();
     if (supports_oop_raster_)
       paint_cache_ = std::make_unique<cc::ServicePaintCache>();
-    use_ddl_ = gpu_preferences_.enable_oop_rasterization_ddl;
+    use_ddl_ = group_->gpu_preferences().enable_oop_rasterization_ddl;
   }
 
   return ContextResult::kSuccess;
@@ -790,6 +787,10 @@
     if (gr_context()) {
       gr_context()->flush();
     }
+  } else {
+    if (group_ && group_->texture_manager()) {
+      group_->texture_manager()->MarkContextLost();
+    }
   }
 
   copy_tex_image_blit_.reset();
@@ -800,6 +801,11 @@
     query_manager_.reset();
   }
 
+  if (group_.get()) {
+    group_->Destroy(this, have_context);
+    group_ = nullptr;
+  }
+
   // Destroy the surface before the context, some surface destructors make GL
   // calls.
   if (context_.get()) {
@@ -828,6 +834,7 @@
       !shared_context_state_->MakeCurrent(nullptr)) {
     LOG(ERROR) << "  RasterDecoderImpl: Context lost during MakeCurrent.";
     MarkContextLost(error::kMakeCurrentFailed);
+    group_->LoseContexts(error::kUnknown);
     return false;
   }
 
@@ -836,6 +843,7 @@
   if (CheckResetStatus()) {
     LOG(ERROR)
         << "  RasterDecoderImpl: Context reset detected after MakeCurrent.";
+    group_->LoseContexts(error::kUnknown);
     return false;
   }
 
@@ -855,23 +863,22 @@
 
 Capabilities RasterDecoderImpl::GetCapabilities() {
   Capabilities caps;
-  caps.gpu_rasterization = supports_gpu_raster_;
+  caps.gpu_rasterization =
+      group_->gpu_feature_info()
+          .status_values[GPU_FEATURE_TYPE_GPU_RASTERIZATION] ==
+      kGpuFeatureStatusEnabled;
   caps.supports_oop_raster = supports_oop_raster_;
   caps.gpu_memory_buffer_formats =
-      feature_info()->feature_flags().gpu_memory_buffer_formats;
+      feature_info_->feature_flags().gpu_memory_buffer_formats;
   caps.texture_target_exception_list =
-      gpu_preferences_.texture_target_exception_list;
+      group_->gpu_preferences().texture_target_exception_list;
   caps.texture_format_bgra8888 =
-      feature_info()->feature_flags().ext_texture_format_bgra8888;
+      feature_info_->feature_flags().ext_texture_format_bgra8888;
   caps.texture_storage_image =
-      feature_info()->feature_flags().chromium_texture_storage_image;
-  caps.texture_storage = feature_info()->feature_flags().ext_texture_storage;
-  api()->glGetIntegervFn(GL_MAX_TEXTURE_SIZE, &caps.max_texture_size);
-  if (feature_info()->workarounds().max_texture_size) {
-    caps.max_texture_size = std::min(
-        caps.max_texture_size, feature_info()->workarounds().max_texture_size);
-  }
-  caps.sync_query = feature_info()->feature_flags().chromium_sync_query;
+      feature_info_->feature_flags().chromium_texture_storage_image;
+  caps.texture_storage = feature_info_->feature_flags().ext_texture_storage;
+  caps.max_texture_size = texture_manager()->MaxSizeForTarget(GL_TEXTURE_2D);
+  caps.sync_query = feature_info_->feature_flags().chromium_sync_query;
 
   if (gr_context()) {
     caps.context_supports_distance_field_text =
@@ -1079,14 +1086,13 @@
 }
 
 void RasterDecoderImpl::SetIgnoreCachedStateForTest(bool ignore) {
-  if (use_passthrough_)
+  if (use_passthrough())
     return;
   state()->SetIgnoreCachedStateForTest(ignore);
 }
 
 gles2::ImageManager* RasterDecoderImpl::GetImageManagerForTest() {
-  NOTREACHED();
-  return nullptr;
+  return group_->image_manager();
 }
 
 void RasterDecoderImpl::SetCopyTextureResourceManagerForTest(
@@ -1126,6 +1132,18 @@
   int process_pos = 0;
   CommandId command = static_cast<CommandId>(0);
 
+#if defined(OS_MACOSX)
+  if (!flush_workaround_disabled_for_test_) {
+    // Flush before and after decoding commands.
+    // TODO(ccameron): This is to determine if this high frequency flushing
+    // affects crash rates.
+    // https://crbug.com/906453
+    if (gr_context())
+      gr_context()->flush();
+    api()->glFlushFn();
+  }
+#endif
+
   while (process_pos < num_entries && result == error::kNoError &&
          commands_to_process_--) {
     const unsigned int size = cmd_data->value_header.size;
@@ -1206,11 +1224,6 @@
       process_pos += size;
       cmd_data += size;
     }
-
-    // Workaround for https://crbug.com/906453: Flush after every command that
-    // is not between a BeginRaster and EndRaster.
-    if (!sk_surface_)
-      FlushToWorkAroundMacCrashes();
   }
 
   *entries_processed = process_pos;
@@ -1223,6 +1236,14 @@
   if (supports_oop_raster_)
     client_->ScheduleGrContextCleanup();
 
+#if defined(OS_MACOSX)
+  if (!flush_workaround_disabled_for_test_) {
+    if (gr_context())
+      gr_context()->flush();
+    api()->glFlushFn();
+  }
+#endif
+
   return result;
 }
 
@@ -1251,7 +1272,7 @@
 }
 
 gles2::ContextGroup* RasterDecoderImpl::GetContextGroup() {
-  return nullptr;
+  return group_.get();
 }
 
 gles2::ErrorState* RasterDecoderImpl::GetErrorState() {
@@ -1271,8 +1292,7 @@
 }
 
 bool RasterDecoderImpl::IsCompressedTextureFormat(unsigned format) {
-  return feature_info()->validators()->compressed_texture_format.IsValid(
-      format);
+  return feature_info_->validators()->compressed_texture_format.IsValid(format);
 }
 
 bool RasterDecoderImpl::ClearLevel(gles2::Texture* texture,
@@ -1329,7 +1349,7 @@
                                texture->service_id(), gr_context());
     base::Optional<ScopedPixelUnpackState> pixel_unpack_state;
     if (shared_context_state_->need_context_state_reset()) {
-      pixel_unpack_state.emplace(state(), gr_context(), feature_info());
+      pixel_unpack_state.emplace(state(), gr_context(), group_->feature_info());
     }
     // Add extra scope to destroy zero and the object it owns right
     // after its usage.
@@ -1341,8 +1361,8 @@
       GLint h = y + tile_height > height ? height - y : tile_height;
       api()->glTexSubImage2DFn(
           target, level, xoffset, yoffset + y, width, h,
-          gles2::TextureManager::AdjustTexFormat(feature_info(), format), type,
-          zero.get());
+          gles2::TextureManager::AdjustTexFormat(feature_info_.get(), format),
+          type, zero.get());
       y += tile_height;
     }
   }
@@ -1360,10 +1380,6 @@
   return false;
 }
 
-int RasterDecoderImpl::GetRasterDecoderId() const {
-  return raster_decoder_id_;
-}
-
 int RasterDecoderImpl::DecoderIdForTest() {
   return raster_decoder_id_;
 }
@@ -1375,10 +1391,9 @@
 void RasterDecoderImpl::SetUpForRasterCHROMIUMForTest() {
   // Some tests use mock GL which doesn't work with skia. Just use a bitmap
   // backed surface for OOP raster commands.
-  auto info = SkImageInfo::MakeN32(10, 10, kPremul_SkAlphaType,
+  sk_surface_ = SkSurface::MakeRaster(SkImageInfo::MakeN32Premul(10, 10));
+  raster_canvas_ = SkCreateColorSpaceXformCanvas(sk_surface_->getCanvas(),
                                    SkColorSpace::MakeSRGB());
-  sk_surface_ = SkSurface::MakeRaster(info);
-  raster_canvas_ = sk_surface_->getCanvas();
 }
 
 void RasterDecoderImpl::SetOOMErrorForTest() {
@@ -1394,15 +1409,21 @@
   if (!WasContextLost()) {
     // Need to lose current context before broadcasting!
     CheckResetStatus();
+    group_->LoseContexts(error::kUnknown);
     reset_by_robustness_extension_ = true;
   }
 }
 
 void RasterDecoderImpl::OnOutOfMemoryError() {
   if (lose_context_when_out_of_memory_ && !WasContextLost()) {
-    if (!CheckResetStatus()) {
+    error::ContextLostReason other = error::kOutOfMemory;
+    if (CheckResetStatus()) {
+      other = error::kUnknown;
+    } else {
+      // Need to lose current context before broadcasting!
       MarkContextLost(error::kOutOfMemory);
     }
+    group_->LoseContexts(other);
   }
 }
 
@@ -1608,7 +1629,7 @@
   if (!copy_tex_image_blit_.get()) {
     LOCAL_COPY_REAL_GL_ERRORS_TO_WRAPPER("glCopySubTexture");
     copy_tex_image_blit_.reset(
-        new gles2::CopyTexImageResourceManager(feature_info()));
+        new gles2::CopyTexImageResourceManager(feature_info_.get()));
     copy_tex_image_blit_->Initialize(this);
     if (LOCAL_PEEK_GL_ERROR("glCopySubTexture") != GL_NO_ERROR)
       return false;
@@ -1631,7 +1652,7 @@
     // CopyTex{Sub}Image2D for luminance, alpha, and luminance_alpha
     // textures.
     if (gles2::CopyTexImageResourceManager::CopyTexImageRequiresBlit(
-            feature_info(), GL_LUMINANCE)) {
+            feature_info_.get(), GL_LUMINANCE)) {
       if (!InitializeCopyTexImageBlitter())
         return false;
     }
@@ -1656,50 +1677,31 @@
   DLOG_IF(ERROR, !dest_mailbox.Verify())
       << "CopySubTexture was passed an invalid mailbox";
 
-  if (source_mailbox == dest_mailbox) {
-    LOCAL_SET_GL_ERROR(GL_INVALID_OPERATION, "glCopySubTexture",
-                       "source and destination mailboxes are the same");
-    return;
-  }
-
-  if (use_passthrough_) {
-    std::unique_ptr<SharedImageRepresentationGLTexturePassthrough>
-        source_shared_image =
-            shared_image_representation_factory_.ProduceGLTexturePassthrough(
-                source_mailbox);
-    std::unique_ptr<SharedImageRepresentationGLTexturePassthrough>
-        dest_shared_image =
-            shared_image_representation_factory_.ProduceGLTexturePassthrough(
-                dest_mailbox);
-    if (!source_shared_image || !dest_shared_image) {
+  if (use_passthrough()) {
+    // TODO(piman): use shared image representations instead.
+    gles2::TexturePassthrough* source_texture =
+        gles2::TexturePassthrough::CheckedCast(
+            group_->mailbox_manager()->ConsumeTexture(source_mailbox));
+    gles2::TexturePassthrough* dest_texture =
+        gles2::TexturePassthrough::CheckedCast(
+            group_->mailbox_manager()->ConsumeTexture(dest_mailbox));
+    if (!source_texture || !dest_texture) {
       LOCAL_SET_GL_ERROR(GL_INVALID_VALUE, "glCopySubTexture",
                          "unknown mailbox");
       return;
     }
-
-    SharedImageRepresentationGLTexturePassthrough::ScopedAccess source_access(
-        source_shared_image.get(), GL_SHARED_IMAGE_ACCESS_MODE_READ_CHROMIUM);
-    if (!source_access.success()) {
-      LOCAL_SET_GL_ERROR(GL_INVALID_VALUE, "glCopySubTexture",
-                         "unable to access source for read");
-      return;
+    if (source_texture->is_bind_pending()) {
+      gl::GLImage* image =
+          source_texture->GetLevelImage(source_texture->target(), 0);
+      if (image) {
+        api()->glBindTextureFn(source_texture->target(),
+                               source_texture->service_id());
+        if (!image->BindTexImage(source_texture->target())) {
+          image->CopyTexImage(source_texture->target());
+        }
+        source_texture->set_is_bind_pending(false);
     }
-
-    SharedImageRepresentationGLTexturePassthrough::ScopedAccess dest_access(
-        dest_shared_image.get(),
-        GL_SHARED_IMAGE_ACCESS_MODE_READWRITE_CHROMIUM);
-    if (!dest_access.success()) {
-      LOCAL_SET_GL_ERROR(GL_INVALID_VALUE, "glCopySubTexture",
-                         "unable to access destination for write");
-      return;
     }
-
-    gles2::TexturePassthrough* source_texture =
-        source_shared_image->GetTexturePassthrough().get();
-    gles2::TexturePassthrough* dest_texture =
-        dest_shared_image->GetTexturePassthrough().get();
-    DCHECK(!source_texture->is_bind_pending());
-    DCHECK_NE(source_texture->service_id(), dest_texture->service_id());
 
     api()->glCopySubTextureCHROMIUMFn(
         source_texture->service_id(), /*source_level=*/0,
@@ -1710,70 +1712,116 @@
     return;
   }
 
-  std::unique_ptr<SharedImageRepresentationGLTexture> source_shared_image =
-      shared_image_representation_factory_.ProduceGLTexture(source_mailbox);
-  std::unique_ptr<SharedImageRepresentationGLTexture> dest_shared_image =
-      shared_image_representation_factory_.ProduceGLTexture(dest_mailbox);
-  if (!source_shared_image || !dest_shared_image) {
+  // TODO(piman): use shared image representations instead.
+  gles2::Texture* source_texture = gles2::Texture::CheckedCast(
+      group_->mailbox_manager()->ConsumeTexture(source_mailbox));
+  gles2::Texture* dest_texture = gles2::Texture::CheckedCast(
+      group_->mailbox_manager()->ConsumeTexture(dest_mailbox));
+  if (!source_texture || !dest_texture) {
     LOCAL_SET_GL_ERROR(GL_INVALID_VALUE, "glCopySubTexture", "unknown mailbox");
     return;
   }
+  if (source_texture == dest_texture) {
+    LOCAL_SET_GL_ERROR(GL_INVALID_OPERATION, "glCopySubTexture",
+                       "source and destination textures are the same");
+    return;
+  }
+  GLenum source_target = source_texture->target();
+  GLenum dest_target = dest_texture->target();
+  if (!source_target || !dest_target) {
+    LOCAL_SET_GL_ERROR(GL_INVALID_OPERATION, "glCopySubTexture",
+                       "textures not initialized");
+    return;
+  }
+
+  GLint source_level = 0;
+  GLint dest_level = 0;
+
+  ScopedTextureBinder binder(state(), dest_target, dest_texture->service_id(),
+                             gr_context());
+  base::Optional<ScopedPixelUnpackState> pixel_unpack_state;
 
-  SharedImageRepresentationGLTexture::ScopedAccess source_access(
-      source_shared_image.get(), GL_SHARED_IMAGE_ACCESS_MODE_READ_CHROMIUM);
-  if (!source_access.success()) {
+  int source_width = 0;
+  int source_height = 0;
+  gl::GLImage* image =
+      source_texture->GetLevelImage(source_target, 0 /* level */);
+  if (image) {
+    gfx::Size size = image->GetSize();
+    source_width = size.width();
+    source_height = size.height();
+    if (source_width <= 0 || source_height <= 0) {
     LOCAL_SET_GL_ERROR(GL_INVALID_VALUE, "glCopySubTexture",
-                       "unable to access source for read");
+                         "invalid image size");
     return;
   }
 
-  gles2::Texture* source_texture = source_shared_image->GetTexture();
-  GLenum source_target = source_texture->target();
-  DCHECK(source_target);
-  GLint source_level = 0;
-  gfx::Size source_size = source_shared_image->size();
-  gfx::Rect source_rect(x, y, width, height);
-  if (!gfx::Rect(source_size).Contains(source_rect)) {
+    // Ideally we should not need to check that the sub-texture copy rectangle
+    // is valid in two different ways, here and below. However currently there
+    // is no guarantee that a texture backed by a GLImage will have sensible
+    // level info. If this synchronization were to be enforced then this and
+    // other functions in this file could be cleaned up.
+    // See: https://crbug.com/586476
+    int32_t max_x;
+    int32_t max_y;
+    if (!base::CheckAdd(x, width).AssignIfValid(&max_x) ||
+        !base::CheckAdd(y, height).AssignIfValid(&max_y) || x < 0 || y < 0 ||
+        max_x > source_width || max_y > source_height) {
     LOCAL_SET_GL_ERROR(GL_INVALID_VALUE, "glCopySubTexture",
-                       "source texture bad dimensions.");
+                         "source texture bad dimensions");
     return;
   }
 
-  SharedImageRepresentationGLTexture::ScopedAccess dest_access(
-      dest_shared_image.get(), GL_SHARED_IMAGE_ACCESS_MODE_READWRITE_CHROMIUM);
-  if (!dest_access.success()) {
+    if (image->GetType() == gl::GLImage::Type::MEMORY &&
+        shared_context_state_->need_context_state_reset()) {
+      // If the image is in shared memory, we may need upload the pixel data
+      // with SubTexImage2D, so we need reset pixel unpack state if gl context
+      // state has been touched by skia.
+      pixel_unpack_state.emplace(state(), gr_context(), group_->feature_info());
+    }
+  } else {
+    if (!source_texture->GetLevelSize(source_target, 0 /* level */,
+                                      &source_width, &source_height, nullptr)) {
     LOCAL_SET_GL_ERROR(GL_INVALID_VALUE, "glCopySubTexture",
-                       "unable to access destination for write");
+                         "source texture has no data for level");
     return;
   }
 
-  gles2::Texture* dest_texture = dest_shared_image->GetTexture();
-  GLenum dest_target = dest_texture->target();
-  DCHECK(dest_target);
-  GLint dest_level = 0;
-  gfx::Size dest_size = dest_shared_image->size();
-  gfx::Rect dest_rect(xoffset, yoffset, width, height);
-  if (!gfx::Rect(dest_size).Contains(dest_rect)) {
+    // Check that this type of texture is allowed.
+    if (!texture_manager()->ValidForTarget(source_target, 0 /* level */,
+                                           source_width, source_height, 1)) {
     LOCAL_SET_GL_ERROR(GL_INVALID_VALUE, "glCopySubTexture",
-                       "destination texture bad dimensions.");
+                         "source texture bad dimensions");
     return;
   }
 
-  DCHECK_NE(source_texture->service_id(), dest_texture->service_id());
+    if (!source_texture->ValidForTexture(source_target, 0 /* level */, x, y, 0,
+                                         width, height, 1)) {
+      LOCAL_SET_GL_ERROR(GL_INVALID_VALUE, "glCopySubTexture",
+                         "source texture bad dimensions.");
+      return;
+    }
+  }
 
   GLenum source_type = 0;
   GLenum source_internal_format = 0;
-  source_texture->GetLevelType(source_target, source_level, &source_type,
+  source_texture->GetLevelType(source_target, 0 /* level */, &source_type,
                                &source_internal_format);
 
   GLenum dest_type = 0;
   GLenum dest_internal_format = 0;
   bool dest_level_defined = dest_texture->GetLevelType(
-      dest_target, dest_level, &dest_type, &dest_internal_format);
-  DCHECK(dest_level_defined);
-
-  // TODO(piman): Do we need this check? It might always be true by
-  // construction.
+      dest_target, 0 /* level */, &dest_type, &dest_internal_format);
+  if (!dest_level_defined) {
+    LOCAL_SET_GL_ERROR(GL_INVALID_OPERATION, "glCopySubTexture",
+                       "destination texture is not defined");
+    return;
+  }
+  if (!dest_texture->ValidForTexture(dest_target, 0 /* level */, xoffset,
+                                     yoffset, 0, width, height, 1)) {
+    LOCAL_SET_GL_ERROR(GL_INVALID_VALUE, "glCopySubTexture",
+                       "destination texture bad dimensions.");
+    return;
+  }
   std::string output_error_msg;
   if (!ValidateCopyTextureCHROMIUMInternalFormats(
           GetFeatureInfo(), source_internal_format, dest_internal_format,
@@ -1783,80 +1831,66 @@
     return;
   }
 
+  if (feature_info_->feature_flags().desktop_srgb_support) {
+    bool enable_framebuffer_srgb =
+        gles2::GLES2Util::GetColorEncodingFromInternalFormat(
+            source_internal_format) == GL_SRGB ||
+        gles2::GLES2Util::GetColorEncodingFromInternalFormat(
+            dest_internal_format) == GL_SRGB;
+    state()->EnableDisableFramebufferSRGB(enable_framebuffer_srgb);
+  }
+
   // Clear the source texture if necessary.
-  if (!gles2::TextureManager::ClearTextureLevel(this, source_texture,
-                                                source_target, 0 /* level */)) {
+  if (!texture_manager()->ClearTextureLevel(this, source_texture, source_target,
+                                            0 /* level */)) {
     LOCAL_SET_GL_ERROR(GL_OUT_OF_MEMORY, "glCopySubTexture",
                        "source texture dimensions too big");
     return;
   }
 
-  gfx::Rect new_cleared_rect;
-  gfx::Rect old_cleared_rect =
-      dest_texture->GetLevelClearedRect(dest_target, dest_level);
+  int dest_width = 0;
+  int dest_height = 0;
+  bool ok = dest_texture->GetLevelSize(dest_target, dest_level, &dest_width,
+                                       &dest_height, nullptr);
+  DCHECK(ok);
+  if (xoffset != 0 || yoffset != 0 || width != dest_width ||
+      height != dest_height) {
+    gfx::Rect cleared_rect;
   if (gles2::TextureManager::CombineAdjacentRects(
-          dest_texture->GetLevelClearedRect(dest_target, dest_level), dest_rect,
-          &new_cleared_rect)) {
-    DCHECK(old_cleared_rect.IsEmpty() ||
-           new_cleared_rect.Contains(old_cleared_rect));
+            dest_texture->GetLevelClearedRect(dest_target, dest_level),
+            gfx::Rect(xoffset, yoffset, width, height), &cleared_rect)) {
+      DCHECK_GE(cleared_rect.size().GetArea(),
+                dest_texture->GetLevelClearedRect(dest_target, dest_level)
+                    .size()
+                    .GetArea());
+      dest_texture->SetLevelClearedRect(dest_target, dest_level, cleared_rect);
   } else {
     // Otherwise clear part of texture level that is not already cleared.
-    if (!gles2::TextureManager::ClearTextureLevel(this, dest_texture,
-                                                  dest_target, dest_level)) {
+      if (!texture_manager()->ClearTextureLevel(this, dest_texture, dest_target,
+                                                dest_level)) {
       LOCAL_SET_GL_ERROR(GL_OUT_OF_MEMORY, "glCopySubTexture",
                          "destination texture dimensions too big");
       return;
     }
-    new_cleared_rect = gfx::Rect(dest_size);
   }
-
-  ScopedTextureBinder binder(state(), dest_target, dest_texture->service_id(),
-                             gr_context());
-
-  gles2::Texture::ImageState image_state;
-  gl::GLImage* image =
-      source_texture->GetLevelImage(source_target, 0, &image_state);
-  if (image) {
-    base::Optional<ScopedPixelUnpackState> pixel_unpack_state;
-    if (image->GetType() == gl::GLImage::Type::MEMORY &&
-        shared_context_state_->need_context_state_reset()) {
-      // If the image is in shared memory, we may need upload the pixel data
-      // with SubTexImage2D, so we need reset pixel unpack state if gl context
-      // state has been touched by skia.
-      pixel_unpack_state.emplace(state(), gr_context(), feature_info());
+  } else {
+    dest_texture->SetLevelCleared(dest_target, dest_level, true);
     }
 
-    // Try to copy by uploading to the destination texture.
-    if (dest_internal_format == source_internal_format) {
+  // TODO(qiankun.miao@intel.com): Support level > 0 for CopyTexSubImage.
+  if (image && dest_internal_format == source_internal_format &&
+      dest_level == 0) {
       if (image->CopyTexSubImage(dest_target, gfx::Point(xoffset, yoffset),
                                  gfx::Rect(x, y, width, height))) {
-        dest_texture->SetLevelClearedRect(dest_target, dest_level,
-                                          new_cleared_rect);
         return;
       }
     }
 
-    // Otherwise, update the source if needed.
-    if (image_state == gles2::Texture::UNBOUND) {
-      ScopedGLErrorSuppressor suppressor(
-          "RasterDecoderImpl::DoCopySubTextureINTERNAL", error_state_.get());
-      api()->glBindTextureFn(source_target, source_texture->service_id());
-      if (image->ShouldBindOrCopy() == gl::GLImage::BIND) {
-        bool rv = image->BindTexImage(source_target);
-        DCHECK(rv) << "BindTexImage() failed";
-        image_state = gles2::Texture::BOUND;
-      } else {
-        bool rv = image->CopyTexImage(source_target);
-        DCHECK(rv) << "CopyTexImage() failed";
-        image_state = gles2::Texture::COPIED;
-      }
-      source_texture->SetLevelImageState(source_target, 0, image_state);
-    }
-  }
-
   if (!InitializeCopyTextureCHROMIUM())
     return;
 
+  DoBindOrCopyTexImageIfNeeded(source_texture, source_target);
+
   // GL_TEXTURE_EXTERNAL_OES texture requires apply a transform matrix
   // before presenting.
   if (source_target == GL_TEXTURE_EXTERNAL_OES) {
@@ -1870,13 +1904,10 @@
           this, source_target, source_texture->service_id(), source_level,
           source_internal_format, dest_target, dest_texture->service_id(),
           dest_level, dest_internal_format, xoffset, yoffset, x, y, width,
-          height, dest_size.width(), dest_size.height(), source_size.width(),
-          source_size.height(), false /* unpack_flip_y */,
-          false /* unpack_premultiply_alpha */,
+          height, dest_width, dest_height, source_width, source_height,
+          false /* unpack_flip_y */, false /* unpack_premultiply_alpha */,
           false /* unpack_unmultiply_alpha */, false /* dither */,
           transform_matrix, copy_tex_image_blit_.get());
-      dest_texture->SetLevelClearedRect(dest_target, dest_level,
-                                        new_cleared_rect);
       return;
     }
   }
@@ -1904,11 +1935,10 @@
       this, source_target, source_texture->service_id(), source_level,
       source_internal_format, dest_target, dest_texture->service_id(),
       dest_level, dest_internal_format, xoffset, yoffset, x, y, width, height,
-      dest_size.width(), dest_size.height(), source_size.width(),
-      source_size.height(), false /* unpack_flip_y */,
-      false /* unpack_premultiply_alpha */, false /* unpack_unmultiply_alpha */,
-      false /* dither */, method, copy_tex_image_blit_.get());
-  dest_texture->SetLevelClearedRect(dest_target, dest_level, new_cleared_rect);
+      dest_width, dest_height, source_width, source_height,
+      false /* unpack_flip_y */, false /* unpack_premultiply_alpha */,
+      false /* unpack_unmultiply_alpha */, false /* dither */, method,
+      copy_tex_image_blit_.get());
   in_copy_sub_texture_ = false;
   if (reset_texture_state_) {
     reset_texture_state_ = false;
@@ -1926,6 +1956,30 @@
   }
 }
 
+void RasterDecoderImpl::DoBindOrCopyTexImageIfNeeded(gles2::Texture* texture,
+                                                     GLenum textarget) {
+  // Image is already in use if texture is attached to a framebuffer.
+  if (texture && !texture->IsAttachedToFramebuffer()) {
+    gles2::Texture::ImageState image_state;
+    gl::GLImage* image = texture->GetLevelImage(textarget, 0, &image_state);
+    if (image && image_state == gles2::Texture::UNBOUND) {
+      ScopedGLErrorSuppressor suppressor(
+          "RasterDecoderImpl::DoBindOrCopyTexImageIfNeeded",
+          error_state_.get());
+      api()->glBindTextureFn(textarget, texture->service_id());
+      if (!image->BindTexImage(textarget)) {
+        // Note: We update the state to COPIED prior to calling CopyTexImage()
+        // as that allows the GLImage implemenatation to set it back to
+        // UNBOUND and ensure that CopyTexImage() is called each time the
+        // texture is used.
+        texture->SetLevelImageState(textarget, 0, gles2::Texture::COPIED);
+        bool rv = image->CopyTexImage(textarget);
+        DCHECK(rv) << "CopyTexImage() failed";
+      }
+    }
+  }
+}
+
 namespace {
 
 // Helper to read client data from transfer cache.
@@ -2005,11 +2059,8 @@
     GLuint sk_color,
     GLuint msaa_sample_count,
     GLboolean can_use_lcd_text,
+    GLuint color_space_transfer_cache_id,
     const volatile GLbyte* key) {
-  // Workaround for https://crbug.com/906453: Flush before BeginRaster (the
-  // commands between BeginRaster and EndRaster will not flush).
-  FlushToWorkAroundMacCrashes();
-
   if (!gr_context()) {
     LOCAL_SET_GL_ERROR(GL_INVALID_OPERATION, "glBeginRasterCHROMIUM",
                        "chromium_raster_transport not enabled via attribs");
@@ -2028,7 +2079,8 @@
                                        "generated by ProduceTextureCHROMIUM.";
 
   DCHECK(!shared_image_);
-  shared_image_ = shared_image_representation_factory_.ProduceSkia(mailbox);
+  shared_image_ =
+      group_->shared_image_representation_factory()->ProduceSkia(mailbox);
   if (!shared_image_) {
     LOCAL_SET_GL_ERROR(GL_INVALID_VALUE, "glBeginRasterCHROMIUM",
                        "passed invalid mailbox.");
@@ -2065,17 +2117,36 @@
     return;
   }
 
+  TransferCacheDeserializeHelperImpl transfer_cache_deserializer(
+      raster_decoder_id_, transfer_cache());
+  auto* color_space_entry =
+      transfer_cache_deserializer
+          .GetEntryAs<cc::ServiceColorSpaceTransferCacheEntry>(
+              color_space_transfer_cache_id);
+  if (!color_space_entry || !color_space_entry->color_space().IsValid()) {
+    LOCAL_SET_GL_ERROR(GL_INVALID_OPERATION, "glBeginRasterCHROMIUM",
+                       "failed to find valid color space");
+    shared_image_->EndWriteAccess(std::move(sk_surface_));
+    shared_image_.reset();
+    return;
+  }
+
+  SkCanvas* canvas = nullptr;
   if (use_ddl_) {
     SkSurfaceCharacterization characterization;
     bool result = sk_surface_->characterize(&characterization);
     DCHECK(result) << "Failed to characterize raster SkSurface.";
     recorder_ =
         std::make_unique<SkDeferredDisplayListRecorder>(characterization);
-    raster_canvas_ = recorder_->getCanvas();
+    canvas = recorder_->getCanvas();
   } else {
-    raster_canvas_ = sk_surface_->getCanvas();
+    canvas = sk_surface_->getCanvas();
   }
 
+  raster_canvas_ = SkCreateColorSpaceXformCanvas(
+      canvas, color_space_entry->color_space().ToSkColorSpace());
+  raster_color_space_id_ = color_space_transfer_cache_id;
+
   // All or nothing clearing, as no way to validate the client's input on what
   // is the "used" part of the texture.
   // TODO(enne): This doesn't handle the case where the background color
@@ -2141,6 +2212,7 @@
   alignas(
       cc::PaintOpBuffer::PaintOpAlign) char data[sizeof(cc::LargestPaintOp)];
 
+  SkCanvas* canvas = raster_canvas_.get();
   cc::PlaybackParams playback_params(nullptr, SkMatrix::I());
   TransferCacheDeserializeHelperImpl impl(raster_decoder_id_, transfer_cache());
   cc::PaintOp::DeserializeOptions options(
@@ -2162,7 +2234,7 @@
       return;
     }
 
-    deserialized_op->Raster(raster_canvas_, playback_params);
+    deserialized_op->Raster(canvas, playback_params);
     deserialized_op->DestroyThis();
 
     paint_buffer_size -= skip;
@@ -2180,7 +2252,7 @@
 
   shared_context_state_->set_need_context_state_reset(true);
 
-  raster_canvas_ = nullptr;
+  raster_canvas_.reset();
 
   if (use_ddl_) {
     auto ddl = recorder_->detach();
--- a/gpu/command_buffer/service/raster_decoder.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/raster_decoder.h	2019-05-17 18:53:33.024000000 +0300
@@ -13,12 +13,8 @@
 namespace gpu {
 
 class DecoderClient;
-struct GpuFeatureInfo;
-struct GpuPreferences;
-class MemoryTracker;
-class ServiceTransferCache;
 class SharedContextState;
-class SharedImageManager;
+class ServiceTransferCache;
 
 namespace gles2 {
 class CopyTextureCHROMIUMResourceManager;
@@ -39,10 +35,7 @@
       DecoderClient* client,
       CommandBufferServiceBase* command_buffer_service,
       gles2::Outputter* outputter,
-      const GpuFeatureInfo& gpu_feature_info,
-      const GpuPreferences& gpu_preferences,
-      MemoryTracker* memory_tracker,
-      SharedImageManager* shared_image_manager,
+      gles2::ContextGroup* group,
       scoped_refptr<SharedContextState> shared_context_state);
 
   ~RasterDecoder() override;
--- a/gpu/command_buffer/service/raster_decoder_unittest_0_autogen.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/raster_decoder_unittest_0_autogen.h	2019-05-17 18:53:33.028000000 +0300
@@ -23,10 +23,10 @@
   ExpectEnableDisable(GL_SAMPLE_COVERAGE, false);
   ExpectEnableDisable(GL_SCISSOR_TEST, false);
   ExpectEnableDisable(GL_STENCIL_TEST, false);
-  if (feature_info()->feature_flags().ext_multisample_compatibility) {
+  if (group_->feature_info()->feature_flags().ext_multisample_compatibility) {
     ExpectEnableDisable(GL_MULTISAMPLE_EXT, true);
   }
-  if (feature_info()->feature_flags().ext_multisample_compatibility) {
+  if (group_->feature_info()->feature_flags().ext_multisample_compatibility) {
     ExpectEnableDisable(GL_SAMPLE_ALPHA_TO_ONE_EXT, false);
   }
   if (es3_capable) {
@@ -36,7 +36,7 @@
 }
 
 void RasterDecoderTestBase::SetupInitStateExpectations(bool es3_capable) {
-  auto* feature_info_ = feature_info();
+  auto* feature_info_ = group_->feature_info();
   EXPECT_CALL(*gl_, BlendColor(0.0f, 0.0f, 0.0f, 0.0f))
       .Times(1)
       .RetiresOnSaturation();
@@ -54,7 +54,9 @@
   EXPECT_CALL(*gl_, ColorMask(true, true, true, true))
       .Times(1)
       .RetiresOnSaturation();
-  if (feature_info()->feature_flags().chromium_framebuffer_mixed_samples) {
+  if (group_->feature_info()
+          ->feature_flags()
+          .chromium_framebuffer_mixed_samples) {
     EXPECT_CALL(*gl_, CoverageModulationNV(GL_NONE))
         .Times(1)
         .RetiresOnSaturation();
@@ -91,7 +93,7 @@
         .Times(1)
         .RetiresOnSaturation();
   }
-  if (feature_info()->feature_flags().chromium_path_rendering) {
+  if (group_->feature_info()->feature_flags().chromium_path_rendering) {
     EXPECT_CALL(*gl_, PathStencilFuncNV(GL_ALWAYS, 0, 0xFFFFFFFFU))
         .Times(1)
         .RetiresOnSaturation();
--- a/gpu/command_buffer/service/raster_decoder_unittest_1.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/raster_decoder_unittest_1.cc	2019-05-17 18:53:33.028000000 +0300
@@ -33,7 +33,7 @@
   RasterDecoderTest1() = default;
 };
 
-INSTANTIATE_TEST_SUITE_P(Service, RasterDecoderTest1, ::testing::Bool());
+INSTANTIATE_TEST_CASE_P(Service, RasterDecoderTest1, ::testing::Bool());
 
 #include "gpu/command_buffer/service/raster_decoder_unittest_1_autogen.h"
 
--- a/gpu/command_buffer/service/raster_decoder_unittest_base.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/raster_decoder_unittest_base.cc	2019-05-17 18:53:33.028000000 +0300
@@ -10,17 +10,14 @@
 #include <algorithm>
 #include <memory>
 #include <string>
-#include <utility>
 #include <vector>
 
-#include "base/bind_helpers.h"
 #include "base/command_line.h"
 #include "base/strings/string_number_conversions.h"
 #include "base/strings/string_split.h"
 #include "components/viz/common/resources/resource_format_utils.h"
 #include "gpu/command_buffer/common/gles2_cmd_utils.h"
 #include "gpu/command_buffer/common/raster_cmd_format.h"
-#include "gpu/command_buffer/common/shared_image_usage.h"
 #include "gpu/command_buffer/service/context_group.h"
 #include "gpu/command_buffer/service/copy_texture_chromium_mock.h"
 #include "gpu/command_buffer/service/gpu_switches.h"
@@ -29,7 +26,6 @@
 #include "gpu/command_buffer/service/program_manager.h"
 #include "gpu/command_buffer/service/service_utils.h"
 #include "gpu/command_buffer/service/shared_context_state.h"
-#include "gpu/command_buffer/service/shared_image_backing_factory_gl_texture.h"
 #include "gpu/command_buffer/service/test_helper.h"
 #include "gpu/command_buffer/service/vertex_attrib_manager.h"
 #include "testing/gtest/include/gtest/gtest.h"
@@ -63,7 +59,7 @@
       shared_memory_address_(nullptr),
       shared_memory_base_(nullptr),
       ignore_cached_state_for_test_(GetParam()),
-      memory_tracker_(nullptr),
+      shader_translator_cache_(gpu_preferences_),
       copy_texture_manager_(nullptr) {
   memset(immediate_buffer_, 0xEE, sizeof(immediate_buffer_));
 }
@@ -101,7 +97,7 @@
       .Times(1)
       .RetiresOnSaturation();
 
-  if (attrib != 0 || feature_info()->gl_version_info().is_es) {
+  if (attrib != 0 || group_->feature_info()->gl_version_info().is_es) {
     // TODO(bajones): Not sure if I can tell which of these will be called
     EXPECT_CALL(*gl_, EnableVertexAttribArray(attrib))
         .Times(testing::AtMost(1))
@@ -124,7 +120,7 @@
     EXPECT_CALL(*gl_, PixelStorei(GL_UNPACK_IMAGE_HEIGHT, 0))
         .Times(1)
         .RetiresOnSaturation();
-    if (feature_info()->feature_flags().ext_window_rectangles) {
+    if (group_->feature_info()->feature_flags().ext_window_rectangles) {
       EXPECT_CALL(*gl_, WindowRectanglesEXT(GL_EXCLUSIVE_EXT, 0, nullptr))
           .Times(1)
           .RetiresOnSaturation();
@@ -151,13 +147,19 @@
     GLsizei width,
     GLsizei height,
     bool cleared) {
-  gpu::Mailbox mailbox = gpu::Mailbox::GenerateForSharedImage();
-  std::unique_ptr<SharedImageBacking> backing =
-      SharedImageBackingFactoryGLTexture::CreateSharedImageForTest(
-          mailbox, GL_TEXTURE_2D, service_id, cleared, resource_format,
-          gfx::Size(width, height), SHARED_IMAGE_USAGE_RASTER);
-  shared_images_.push_back(
-      shared_image_manager_.Register(std::move(backing), &memory_tracker_));
+  // Create texture and temporary ref.
+  const GLuint kTempClientId = next_fake_texture_client_id_++;
+  auto* temp_ref =
+      group_->texture_manager()->CreateTexture(kTempClientId, service_id);
+  group_->texture_manager()->SetTarget(temp_ref, GL_TEXTURE_2D);
+  group_->texture_manager()->SetLevelInfo(
+      temp_ref, GL_TEXTURE_2D, 0, viz::GLInternalFormat(resource_format),
+      /*width=*/width, /*height=*/height, 1, 0,
+      viz::GLDataFormat(resource_format), viz::GLDataType(resource_format),
+      cleared ? gfx::Rect(width, height) : gfx::Rect());
+  gpu::Mailbox mailbox = gpu::Mailbox::Generate();
+  group_->mailbox_manager()->ProduceTexture(mailbox, temp_ref->texture());
+  EXPECT_EQ(GL_NO_ERROR, GetGLError());
   return mailbox;
 }
 
@@ -166,7 +168,8 @@
   for (const std::string& extension : init.extensions) {
     all_extensions += extension + " ";
   }
-  const ContextType context_type = CONTEXT_TYPE_OPENGLES2;
+  const bool bind_generates_resource(false);
+  const ContextType context_type(CONTEXT_TYPE_OPENGLES2);
 
   // For easier substring/extension matching
   gl::SetGLGetProcAddressProc(gl::MockGLInterface::GetGLProcAddress);
@@ -175,6 +178,17 @@
   gl_.reset(new StrictMock<MockGLInterface>());
   ::gl::MockGLInterface::SetGLInterface(gl_.get());
 
+  GpuFeatureInfo gpu_feature_info;
+  scoped_refptr<gles2::FeatureInfo> feature_info =
+      new gles2::FeatureInfo(init.workarounds, gpu_feature_info);
+
+  group_ = scoped_refptr<gles2::ContextGroup>(new gles2::ContextGroup(
+      gpu_preferences_, false, &mailbox_manager_, nullptr /* memory_tracker */,
+      &shader_translator_cache_, &framebuffer_completeness_cache_, feature_info,
+      bind_generates_resource, &image_manager_, nullptr /* image_factory */,
+      nullptr /* progress_reporter */, gpu_feature_info, &discardable_manager_,
+      nullptr /* passthrough_discardable_manager */, &shared_image_manager_));
+
   InSequence sequence;
 
   surface_ = new gl::GLSurfaceStub;
@@ -188,36 +202,53 @@
 
   context_->GLContextStub::MakeCurrent(surface_.get());
 
-  GpuFeatureInfo gpu_feature_info;
-  feature_info_ = base::MakeRefCounted<gles2::FeatureInfo>(init.workarounds,
-                                                           gpu_feature_info);
-  gles2::TestHelper::SetupFeatureInfoInitExpectationsWithGLVersion(
-      gl_.get(), all_extensions.c_str(), "", init.gl_version.c_str(),
-      context_type);
-  feature_info_->Initialize(gpu::CONTEXT_TYPE_OPENGLES2,
-                            gpu_preferences_.use_passthrough_cmd_decoder &&
-                                gles2::PassthroughCommandDecoderSupported(),
-                            gles2::DisallowedFeatures());
+  gles2::TestHelper::SetupContextGroupInitExpectations(
+      gl_.get(), gles2::DisallowedFeatures(), all_extensions.c_str(),
+      init.gl_version.c_str(), context_type, bind_generates_resource);
+
+  // We initialize the ContextGroup with a MockRasterDecoder so that
+  // we can use the ContextGroup to figure out how the real RasterDecoder
+  // will initialize itself.
+  command_buffer_service_.reset(new FakeCommandBufferServiceBase());
+  command_buffer_service_for_mock_decoder_.reset(
+      new FakeCommandBufferServiceBase());
+  mock_decoder_.reset(
+      new MockRasterDecoder(command_buffer_service_for_mock_decoder_.get()));
+
+  EXPECT_EQ(group_->Initialize(mock_decoder_.get(), context_type,
+                               gles2::DisallowedFeatures()),
+            gpu::ContextResult::kSuccess);
+
+  scoped_refptr<gpu::Buffer> buffer =
+      command_buffer_service_->CreateTransferBufferHelper(kSharedBufferSize,
+                                                          &shared_memory_id_);
+  shared_memory_offset_ = kSharedMemoryOffset;
+  shared_memory_address_ =
+      static_cast<int8_t*>(buffer->memory()) + shared_memory_offset_;
+  shared_memory_base_ = buffer->memory();
+  ClearSharedMemory();
+
+  ContextCreationAttribs attribs;
+  attribs.lose_context_when_out_of_memory =
+      init.lose_context_when_out_of_memory;
+  attribs.context_type = context_type;
 
   // Setup expectations for SharedContextState::InitializeGL().
   EXPECT_CALL(*gl_, GetIntegerv(GL_MAX_VERTEX_ATTRIBS, _))
       .WillOnce(SetArgPointee<1>(8u))
       .RetiresOnSaturation();
-  SetupInitCapabilitiesExpectations(feature_info()->IsES3Capable());
-  SetupInitStateExpectations(feature_info()->IsES3Capable());
+  SetupInitCapabilitiesExpectations(group_->feature_info()->IsES3Capable());
+  SetupInitStateExpectations(group_->feature_info()->IsES3Capable());
 
   shared_context_state_ = base::MakeRefCounted<SharedContextState>(
       new gl::GLShareGroup(), surface_, context_,
-      feature_info()->workarounds().use_virtualized_gl_contexts,
+      feature_info->workarounds().use_virtualized_gl_contexts,
       base::DoNothing());
 
-  shared_context_state_->InitializeGL(GpuPreferences(), feature_info_);
-
-  command_buffer_service_.reset(new FakeCommandBufferServiceBase());
+  shared_context_state_->InitializeGL(GpuPreferences(), feature_info);
 
-  decoder_.reset(RasterDecoder::Create(
-      this, command_buffer_service_.get(), &outputter_, gpu_feature_info,
-      gpu_preferences_, nullptr /* memory_tracker */, &shared_image_manager_,
+  decoder_.reset(RasterDecoder::Create(this, command_buffer_service_.get(),
+                                       &outputter_, group_.get(),
       shared_context_state_));
   decoder_->SetIgnoreCachedStateForTest(ignore_cached_state_for_test_);
   decoder_->DisableFlushWorkaroundForTest();
@@ -226,11 +257,6 @@
   copy_texture_manager_ = new gles2::MockCopyTextureResourceManager();
   decoder_->SetCopyTextureResourceManagerForTest(copy_texture_manager_);
 
-  ContextCreationAttribs attribs;
-  attribs.lose_context_when_out_of_memory =
-      init.lose_context_when_out_of_memory;
-  attribs.context_type = context_type;
-
   ASSERT_EQ(decoder_->Initialize(surface_, shared_context_state_->context(),
                                  true, gles2::DisallowedFeatures(), attribs),
             gpu::ContextResult::kSuccess);
@@ -243,15 +269,6 @@
   decoder_->MakeCurrent();
   decoder_->BeginDecoding();
 
-  scoped_refptr<gpu::Buffer> buffer =
-      command_buffer_service_->CreateTransferBufferHelper(kSharedBufferSize,
-                                                          &shared_memory_id_);
-  shared_memory_offset_ = kSharedMemoryOffset;
-  shared_memory_address_ =
-      static_cast<int8_t*>(buffer->memory()) + shared_memory_offset_;
-  shared_memory_base_ = buffer->memory();
-  ClearSharedMemory();
-
   client_texture_mailbox_ = CreateFakeTexture(
       kServiceTextureId, viz::ResourceFormat::RGBA_8888, /*width=*/2,
       /*height=*/2, /*cleared=*/false);
@@ -274,10 +291,9 @@
 
   decoder_->Destroy(!decoder_->WasContextLost());
   decoder_.reset();
+  group_->Destroy(mock_decoder_.get(), false);
   command_buffer_service_.reset();
-  for (auto& image : shared_images_)
-    image->OnContextLost();
-  shared_images_.clear();
+  command_buffer_service_for_mock_decoder_.reset();
   ::gl::MockGLInterface::SetGLInterface(nullptr);
   gl_.reset();
   gl::init::ShutdownGL(false);
--- a/gpu/command_buffer/service/raster_decoder_unittest_base.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/raster_decoder_unittest_base.h	2019-05-17 18:53:33.028000000 +0300
@@ -17,15 +17,23 @@
 #include "base/message_loop/message_loop.h"
 #include "components/viz/common/resources/resource_format.h"
 #include "gpu/command_buffer/client/client_test_helper.h"
+#include "gpu/command_buffer/common/gles2_cmd_utils.h"
 #include "gpu/command_buffer/common/raster_cmd_format.h"
+#include "gpu/command_buffer/service/buffer_manager.h"
+#include "gpu/command_buffer/service/context_group.h"
 #include "gpu/command_buffer/service/decoder_client.h"
+#include "gpu/command_buffer/service/framebuffer_manager.h"
 #include "gpu/command_buffer/service/gl_context_mock.h"
 #include "gpu/command_buffer/service/gpu_tracer.h"
-#include "gpu/command_buffer/service/memory_tracking.h"
+#include "gpu/command_buffer/service/image_manager.h"
+#include "gpu/command_buffer/service/mailbox_manager_impl.h"
 #include "gpu/command_buffer/service/raster_decoder.h"
+#include "gpu/command_buffer/service/raster_decoder_mock.h"
+#include "gpu/command_buffer/service/service_discardable_manager.h"
+#include "gpu/command_buffer/service/shader_manager.h"
 #include "gpu/command_buffer/service/shared_image_manager.h"
-#include "gpu/command_buffer/service/shared_image_representation.h"
 #include "gpu/command_buffer/service/test_helper.h"
+#include "gpu/command_buffer/service/texture_manager.h"
 #include "gpu/config/gpu_driver_bug_workarounds.h"
 #include "gpu/config/gpu_preferences.h"
 #include "testing/gtest/include/gtest/gtest.h"
@@ -36,6 +44,7 @@
 namespace gpu {
 
 namespace gles2 {
+class ImageManager;
 class MockCopyTextureResourceManager;
 }  // namespace gles2
 
@@ -54,7 +63,6 @@
   void OnRescheduleAfterFinished() override;
   void OnSwapBuffers(uint64_t swap_id, uint32_t flags) override;
   void ScheduleGrContextCleanup() override {}
-  void HandleReturnData(base::span<const uint8_t> data) override {}
 
   // Template to call glGenXXX functions.
   template <typename T>
@@ -113,6 +121,10 @@
     return reinterpret_cast<T>(ptr);
   }
 
+  gles2::TextureRef* GetTexture(GLuint client_id) {
+    return group_->texture_manager()->GetTexture(client_id);
+  }
+
   void SetBucketData(uint32_t bucket_id, const void* data, uint32_t data_size);
   void SetBucketAsCString(uint32_t bucket_id, const char* str);
   // If we want a valid bucket, just set |count_in_header| as |count|,
@@ -140,6 +152,12 @@
   void InitDecoder(const InitState& init);
   void ResetDecoder();
 
+  const gles2::ContextGroup& group() const { return *group_.get(); }
+
+  void LoseContexts(error::ContextLostReason reason) const {
+    group_->LoseContexts(reason);
+  }
+
   error::ContextLostReason GetContextLostReason() const {
     return command_buffer_service_->GetState().context_lost_reason;
   }
@@ -149,6 +167,9 @@
   }
 
   RasterDecoder* GetDecoder() const { return decoder_.get(); }
+  gles2::ImageManager* GetImageManagerForTest() {
+    return decoder_->GetImageManagerForTest();
+  }
 
   typedef gles2::TestHelper::AttribInfo AttribInfo;
   typedef gles2::TestHelper::UniformInfo UniformInfo;
@@ -173,6 +194,7 @@
   // EXPECT_EQ that expect both types to be the same.
   GLint GetGLError();
 
+  void DoBindTexture(GLenum target, GLuint client_id, GLuint service_id);
   void SetScopedTextureBinderExpectations(GLenum target);
 
   void SetupClearTextureExpectations(GLuint service_id,
@@ -190,9 +212,6 @@
 
   GLvoid* BufferOffset(unsigned i) { return reinterpret_cast<GLvoid*>(i); }
 
-  SharedImageManager* shared_image_manager() { return &shared_image_manager_; }
-  gles2::FeatureInfo* feature_info() { return feature_info_.get(); }
-
  protected:
   static const GLint kMaxTextureSize = 2048;
   static const GLint kNumTextureUnits = 8;
@@ -221,11 +240,13 @@
 
   // Use StrictMock to make 100% sure we know how GL will be called.
   std::unique_ptr<::testing::StrictMock<::gl::MockGLInterface>> gl_;
-  scoped_refptr<gles2::FeatureInfo> feature_info_;
   scoped_refptr<gl::GLSurfaceStub> surface_;
   scoped_refptr<GLContextMock> context_;
   std::unique_ptr<FakeCommandBufferServiceBase> command_buffer_service_;
   gles2::TraceOutputter outputter_;
+  std::unique_ptr<MockRasterDecoder> mock_decoder_;
+  std::unique_ptr<FakeCommandBufferServiceBase>
+      command_buffer_service_for_mock_decoder_;
   std::unique_ptr<RasterDecoder> decoder_;
 
   gpu::Mailbox client_texture_mailbox_;
@@ -242,10 +263,13 @@
 
  private:
   GpuPreferences gpu_preferences_;
+  gles2::MailboxManagerImpl mailbox_manager_;
+  gles2::ShaderTranslatorCache shader_translator_cache_;
+  gles2::FramebufferCompletenessCache framebuffer_completeness_cache_;
+  gles2::ImageManager image_manager_;
+  ServiceDiscardableManager discardable_manager_;
   SharedImageManager shared_image_manager_;
-  MemoryTypeTracker memory_tracker_;
-  std::vector<std::unique_ptr<SharedImageRepresentationFactoryRef>>
-      shared_images_;
+  scoped_refptr<gles2::ContextGroup> group_;
   base::MessageLoop message_loop_;
   gles2::MockCopyTextureResourceManager* copy_texture_manager_;  // not owned
   GLuint next_fake_texture_client_id_ = 271828;
--- a/gpu/command_buffer/service/raster_decoder_unittest.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/raster_decoder_unittest.cc	2019-05-17 18:53:33.028000000 +0300
@@ -5,20 +5,18 @@
 #include "gpu/command_buffer/service/raster_decoder.h"
 
 #include <limits>
-#include <memory>
-#include <string>
-#include <utility>
 
-#include "base/bind_helpers.h"
 #include "base/command_line.h"
 #include "base/memory/ptr_util.h"
 #include "gpu/command_buffer/common/gles2_cmd_utils.h"
 #include "gpu/command_buffer/common/mailbox.h"
 #include "gpu/command_buffer/common/raster_cmd_format.h"
+#include "gpu/command_buffer/service/context_group.h"
+#include "gpu/command_buffer/service/gles2_cmd_decoder.h"
+#include "gpu/command_buffer/service/program_manager.h"
 #include "gpu/command_buffer/service/query_manager.h"
 #include "gpu/command_buffer/service/raster_decoder_unittest_base.h"
 #include "gpu/command_buffer/service/shared_context_state.h"
-#include "gpu/command_buffer/service/shared_image_factory.h"
 #include "gpu/command_buffer/service/shared_image_manager.h"
 #include "gpu/command_buffer/service/test_helper.h"
 #include "testing/gtest/include/gtest/gtest.h"
@@ -53,8 +51,8 @@
   RasterDecoderTest() = default;
 };
 
-INSTANTIATE_TEST_SUITE_P(Service, RasterDecoderTest, ::testing::Bool());
-INSTANTIATE_TEST_SUITE_P(Service,
+INSTANTIATE_TEST_CASE_P(Service, RasterDecoderTest, ::testing::Bool());
+INSTANTIATE_TEST_CASE_P(Service,
                          RasterDecoderManualInitTest,
                          ::testing::Bool());
 
@@ -149,53 +147,6 @@
   EXPECT_FALSE(query->IsPending());
 }
 
-TEST_P(RasterDecoderTest, CopyTexSubImage2DSizeMismatch) {
-  shared_context_state_->set_need_context_state_reset(true);
-  // Create uninitialized source texture.
-  gpu::Mailbox source_texture_mailbox =
-      CreateFakeTexture(kNewServiceId, viz::ResourceFormat::RGBA_8888,
-                        /*width=*/1, /*height=*/1,
-                        /*cleared=*/true);
-  GLbyte mailboxes[sizeof(gpu::Mailbox) * 2];
-  CopyMailboxes(mailboxes, source_texture_mailbox, client_texture_mailbox_);
-
-  SharedImageRepresentationFactory repr_factory(shared_image_manager(),
-                                                nullptr);
-  auto representation = repr_factory.ProduceGLTexture(client_texture_mailbox_);
-  gles2::Texture* dest_texture = representation->GetTexture();
-
-  {
-    // This will initialize the bottom right corner of destination.
-    SetScopedTextureBinderExpectations(GL_TEXTURE_2D);
-    auto& cmd = *GetImmediateAs<CopySubTextureINTERNALImmediate>();
-    cmd.Init(1, 1, 0, 0, 1, 1, mailboxes);
-    EXPECT_EQ(error::kNoError, ExecuteImmediateCmd(cmd, sizeof(mailboxes)));
-    EXPECT_EQ(GL_NO_ERROR, GetGLError());
-    EXPECT_EQ(dest_texture->GetLevelClearedRect(GL_TEXTURE_2D, 0),
-              gfx::Rect(1, 1, 1, 1));
-  }
-
-  {
-    // Dest rect outside of dest bounds
-    auto& cmd = *GetImmediateAs<CopySubTextureINTERNALImmediate>();
-    cmd.Init(2, 2, 0, 0, 1, 1, mailboxes);
-    EXPECT_EQ(error::kNoError, ExecuteImmediateCmd(cmd, sizeof(mailboxes)));
-    EXPECT_EQ(GL_INVALID_VALUE, GetGLError());
-    EXPECT_EQ(dest_texture->GetLevelClearedRect(GL_TEXTURE_2D, 0),
-              gfx::Rect(1, 1, 1, 1));
-  }
-
-  {
-    // Source rect outside of source bounds
-    auto& cmd = *GetImmediateAs<CopySubTextureINTERNALImmediate>();
-    cmd.Init(0, 0, 0, 0, 2, 2, mailboxes);
-    EXPECT_EQ(error::kNoError, ExecuteImmediateCmd(cmd, sizeof(mailboxes)));
-    EXPECT_EQ(GL_INVALID_VALUE, GetGLError());
-    EXPECT_EQ(dest_texture->GetLevelClearedRect(GL_TEXTURE_2D, 0),
-              gfx::Rect(1, 1, 1, 1));
-  }
-}
-
 TEST_P(RasterDecoderTest, CopyTexSubImage2DTwiceClearsUnclearedTexture) {
   shared_context_state_->set_need_context_state_reset(true);
   // Create uninitialized source texture.
@@ -203,8 +154,6 @@
       CreateFakeTexture(kNewServiceId, viz::ResourceFormat::RGBA_8888,
                         /*width=*/2, /*height=*/2,
                         /*cleared=*/false);
-  GLbyte mailboxes[sizeof(gpu::Mailbox) * 2];
-  CopyMailboxes(mailboxes, source_texture_mailbox, client_texture_mailbox_);
 
   // This will initialize the top half of destination.
   {
@@ -215,6 +164,8 @@
                                   GL_UNSIGNED_BYTE, 0, 0, 2, 2, 0);
     SetScopedTextureBinderExpectations(GL_TEXTURE_2D);
     auto& cmd = *GetImmediateAs<CopySubTextureINTERNALImmediate>();
+    GLbyte mailboxes[sizeof(gpu::Mailbox) * 2];
+    CopyMailboxes(mailboxes, source_texture_mailbox, client_texture_mailbox_);
     cmd.Init(0, 0, 0, 0, 2, 1, mailboxes);
     EXPECT_EQ(error::kNoError, ExecuteImmediateCmd(cmd, sizeof(mailboxes)));
   }
@@ -228,14 +179,15 @@
                                   GL_UNSIGNED_BYTE, 0, 1, 2, 1, 0);
     SetScopedTextureBinderExpectations(GL_TEXTURE_2D);
     auto& cmd = *GetImmediateAs<CopySubTextureINTERNALImmediate>();
+    GLbyte mailboxes[sizeof(gpu::Mailbox) * 2];
+    CopyMailboxes(mailboxes, source_texture_mailbox, client_texture_mailbox_);
     cmd.Init(1, 1, 0, 0, 1, 1, mailboxes);
     EXPECT_EQ(error::kNoError, ExecuteImmediateCmd(cmd, sizeof(mailboxes)));
   }
 
-  SharedImageRepresentationFactory repr_factory(shared_image_manager(),
-                                                nullptr);
-  auto representation = repr_factory.ProduceGLTexture(client_texture_mailbox_);
-  EXPECT_TRUE(representation->GetTexture()->SafeToRenderFrom());
+  auto* texture = gles2::Texture::CheckedCast(
+      group().mailbox_manager()->ConsumeTexture(client_texture_mailbox_));
+  EXPECT_TRUE(texture->SafeToRenderFrom());
 }
 
 TEST_P(RasterDecoderManualInitTest, CopyTexSubImage2DValidateColorFormat) {
@@ -249,6 +201,7 @@
       CreateFakeTexture(kNewServiceId, viz::ResourceFormat::RED_8,
                         /*width=*/2, /*height=*/2, /*cleared=*/true);
 
+  SetScopedTextureBinderExpectations(GL_TEXTURE_2D);
   auto& copy_cmd = *GetImmediateAs<CopySubTextureINTERNALImmediate>();
   GLbyte mailboxes[sizeof(gpu::Mailbox) * 2];
   CopyMailboxes(mailboxes, client_texture_mailbox_, dest_texture_mailbox);
@@ -266,10 +219,16 @@
 
 class RasterDecoderOOPTest : public testing::Test, DecoderClient {
  public:
+  RasterDecoderOOPTest() : shader_translator_cache_(gpu_preferences_) {}
+
   void SetUp() override {
     gl::GLSurfaceTestSupport::InitializeOneOff();
     gpu::GpuDriverBugWorkarounds workarounds;
 
+    GpuFeatureInfo gpu_feature_info;
+    gpu_feature_info.status_values[GPU_FEATURE_TYPE_OOP_RASTERIZATION] =
+        kGpuFeatureStatusEnabled;
+
     scoped_refptr<gl::GLShareGroup> share_group = new gl::GLShareGroup();
     scoped_refptr<gl::GLSurface> surface =
         gl::init::CreateOffscreenGLSurface(gfx::Size());
@@ -277,16 +236,23 @@
         share_group.get(), surface.get(), gl::GLContextAttribs());
     ASSERT_TRUE(context->MakeCurrent(surface.get()));
 
-    gpu_feature_info_.status_values[GPU_FEATURE_TYPE_OOP_RASTERIZATION] =
-        kGpuFeatureStatusEnabled;
-    auto feature_info = base::MakeRefCounted<gles2::FeatureInfo>(
-        workarounds, gpu_feature_info_);
+    auto feature_info =
+        base::MakeRefCounted<gles2::FeatureInfo>(workarounds, gpu_feature_info);
 
     context_state_ = base::MakeRefCounted<SharedContextState>(
         std::move(share_group), std::move(surface), std::move(context),
         false /* use_virtualized_gl_contexts */, base::DoNothing());
     context_state_->InitializeGrContext(workarounds, nullptr);
     context_state_->InitializeGL(GpuPreferences(), feature_info);
+
+    group_ = new gles2::ContextGroup(
+        gpu_preferences_, false, &mailbox_manager_,
+        nullptr /* memory_tracker */, &shader_translator_cache_,
+        &framebuffer_completeness_cache_, feature_info,
+        false /* bind_generates_resource */, &image_manager_,
+        nullptr /* image_factory */, nullptr /* progress_reporter */,
+        gpu_feature_info, &discardable_manager_,
+        nullptr /* passthrough_discardable_manager */, &shared_image_manager_);
   }
   void TearDown() override {
     context_state_ = nullptr;
@@ -302,13 +268,11 @@
   void OnRescheduleAfterFinished() override {}
   void OnSwapBuffers(uint64_t swap_id, uint32_t flags) override {}
   void ScheduleGrContextCleanup() override {}
-  void HandleReturnData(base::span<const uint8_t> data) override {}
 
   std::unique_ptr<RasterDecoder> CreateDecoder() {
-    auto decoder = base::WrapUnique(RasterDecoder::Create(
-        this, &command_buffer_service_, &outputter_, gpu_feature_info_,
-        GpuPreferences(), nullptr /* memory_tracker */, &shared_image_manager_,
-        context_state_));
+    auto decoder = base::WrapUnique(
+        RasterDecoder::Create(this, &command_buffer_service_, &outputter_,
+                              group_.get(), context_state_));
     ContextCreationAttribs attribs;
     attribs.enable_oop_rasterization = true;
     attribs.enable_raster_interface = true;
@@ -330,12 +294,18 @@
   }
 
  protected:
-  GpuFeatureInfo gpu_feature_info_;
   gles2::TraceOutputter outputter_;
   FakeCommandBufferServiceBase command_buffer_service_;
   scoped_refptr<SharedContextState> context_state_;
 
+  GpuPreferences gpu_preferences_;
+  gles2::MailboxManagerImpl mailbox_manager_;
+  gles2::ShaderTranslatorCache shader_translator_cache_;
+  gles2::FramebufferCompletenessCache framebuffer_completeness_cache_;
+  gles2::ImageManager image_manager_;
+  ServiceDiscardableManager discardable_manager_;
   SharedImageManager shared_image_manager_;
+  scoped_refptr<gles2::ContextGroup> group_;
 };
 
 TEST_F(RasterDecoderOOPTest, StateRestoreAcrossDecoders) {
--- a/gpu/command_buffer/service/raster_decoder_unittest_context_lost.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/raster_decoder_unittest_context_lost.cc	2019-05-17 18:53:33.028000000 +0300
@@ -37,6 +37,10 @@
       EXPECT_CALL(*gl_, GetGraphicsResetStatusARB())
           .WillOnce(Return(reset_status));
     }
+    // Other contexts in the group should be lost also.
+    EXPECT_CALL(*mock_decoder_, MarkContextLost(expected_other_reason))
+        .Times(1)
+        .RetiresOnSaturation();
 
     // glGetError merges driver error state with decoder error state.  Return
     // GL_NO_ERROR from mock driver and GL_OUT_OF_MEMORY from decoder.
@@ -93,7 +97,7 @@
   EXPECT_EQ(error::kUnknown, GetContextLostReason());
 }
 
-INSTANTIATE_TEST_SUITE_P(Service, RasterDecoderOOMTest, ::testing::Bool());
+INSTANTIATE_TEST_CASE_P(Service, RasterDecoderOOMTest, ::testing::Bool());
 
 class RasterDecoderLostContextTest : public RasterDecoderManualInitTest {
  protected:
@@ -139,6 +143,8 @@
 TEST_P(RasterDecoderLostContextTest, LostFromMakeCurrent) {
   Init(/*has_robustness=*/false);
   EXPECT_CALL(*context_, MakeCurrent(surface_.get())).WillOnce(Return(false));
+  // Expect the group to be lost.
+  EXPECT_CALL(*mock_decoder_, MarkContextLost(error::kUnknown)).Times(1);
   EXPECT_FALSE(decoder_->WasContextLost());
   decoder_->MakeCurrent();
   EXPECT_TRUE(decoder_->WasContextLost());
@@ -155,6 +161,8 @@
   // extension.
   EXPECT_CALL(*gl_, GetGraphicsResetStatusARB()).Times(0);
   EXPECT_CALL(*context_, MakeCurrent(surface_.get())).WillOnce(Return(false));
+  // Expect the group to be lost.
+  EXPECT_CALL(*mock_decoder_, MarkContextLost(error::kUnknown)).Times(1);
   decoder_->MakeCurrent();
   EXPECT_TRUE(decoder_->WasContextLost());
   EXPECT_FALSE(decoder_->WasContextLostByRobustnessExtension());
@@ -165,6 +173,29 @@
   ClearCurrentDecoderError();
 }
 
+TEST_P(RasterDecoderLostContextTest, TextureDestroyAfterLostFromMakeCurrent) {
+  Init(/*has_robustness=*/true);
+
+  CreateFakeTexture(kNewServiceId, viz::ResourceFormat::RGBA_8888,
+                    /*width=*/2, /*height=*/2,
+                    /*cleared=*/false);
+
+  // The texture should never be deleted at the GL level.
+  EXPECT_CALL(*gl_, DeleteTextures(1, Pointee(kNewServiceId)))
+      .Times(0)
+      .RetiresOnSaturation();
+
+  // Force context lost for MakeCurrent().
+  EXPECT_CALL(*context_, MakeCurrent(surface_.get())).WillOnce(Return(false));
+  // Expect the group to be lost.
+  EXPECT_CALL(*mock_decoder_, MarkContextLost(error::kUnknown)).Times(1);
+
+  decoder_->MakeCurrent();
+  EXPECT_TRUE(decoder_->WasContextLost());
+  EXPECT_EQ(error::kMakeCurrentFailed, GetContextLostReason());
+  ClearCurrentDecoderError();
+}
+
 TEST_P(RasterDecoderLostContextTest, QueryDestroyAfterLostFromMakeCurrent) {
   Init(/*has_robustness=*/false);
 
@@ -205,6 +236,8 @@
 
   // Force context lost for MakeCurrent().
   EXPECT_CALL(*context_, MakeCurrent(surface_.get())).WillOnce(Return(false));
+  // Expect the group to be lost.
+  EXPECT_CALL(*mock_decoder_, MarkContextLost(error::kUnknown)).Times(1);
 
   decoder_->MakeCurrent();
   EXPECT_TRUE(decoder_->WasContextLost());
@@ -219,6 +252,8 @@
   EXPECT_CALL(*context_, MakeCurrent(surface_.get())).WillOnce(Return(true));
   EXPECT_CALL(*gl_, GetGraphicsResetStatusARB())
       .WillOnce(Return(GL_GUILTY_CONTEXT_RESET_KHR));
+  // Expect the group to be lost.
+  EXPECT_CALL(*mock_decoder_, MarkContextLost(error::kUnknown)).Times(1);
   decoder_->MakeCurrent();
   EXPECT_TRUE(decoder_->WasContextLost());
   EXPECT_TRUE(decoder_->WasContextLostByRobustnessExtension());
@@ -231,6 +266,9 @@
 
 TEST_P(RasterDecoderLostContextTest, LoseGuiltyFromGLError) {
   Init(/*has_robustness=*/true);
+  // Always expect other contexts to be signaled as 'kUnknown' since we can't
+  // query their status without making them current.
+  EXPECT_CALL(*mock_decoder_, MarkContextLost(error::kUnknown)).Times(1);
   DoGetErrorWithContextLost(GL_GUILTY_CONTEXT_RESET_KHR);
   EXPECT_TRUE(decoder_->WasContextLost());
   EXPECT_TRUE(decoder_->WasContextLostByRobustnessExtension());
@@ -239,13 +277,32 @@
 
 TEST_P(RasterDecoderLostContextTest, LoseInnocentFromGLError) {
   Init(/*has_robustness=*/true);
+  // Always expect other contexts to be signaled as 'kUnknown' since we can't
+  // query their status without making them current.
+  EXPECT_CALL(*mock_decoder_, MarkContextLost(error::kUnknown)).Times(1);
   DoGetErrorWithContextLost(GL_INNOCENT_CONTEXT_RESET_KHR);
   EXPECT_TRUE(decoder_->WasContextLost());
   EXPECT_TRUE(decoder_->WasContextLostByRobustnessExtension());
   EXPECT_EQ(error::kInnocent, GetContextLostReason());
 }
 
-INSTANTIATE_TEST_SUITE_P(Service,
+TEST_P(RasterDecoderLostContextTest, LoseGroupFromRobustness) {
+  // If one context in a group is lost through robustness,
+  // the other ones should also get lost and query the reset status.
+  Init(true);
+  EXPECT_CALL(*mock_decoder_, MarkContextLost(error::kUnknown)).Times(1);
+  // There should be no GL calls, since we might not have a current context.
+  EXPECT_CALL(*gl_, GetGraphicsResetStatusARB()).Times(0);
+  LoseContexts(error::kUnknown);
+  EXPECT_TRUE(decoder_->WasContextLost());
+  EXPECT_EQ(error::kUnknown, GetContextLostReason());
+
+  // We didn't process commands, so we need to clear the decoder error,
+  // so that we can shut down cleanly.
+  ClearCurrentDecoderError();
+}
+
+INSTANTIATE_TEST_CASE_P(Service,
                          RasterDecoderLostContextTest,
                          ::testing::Bool());
 
--- a/gpu/command_buffer/service/scheduler.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/scheduler.cc	2019-05-17 18:53:33.028000000 +0300
@@ -6,7 +6,6 @@
 
 #include <algorithm>
 
-#include "base/bind.h"
 #include "base/callback.h"
 #include "base/single_thread_task_runner.h"
 #include "base/stl_util.h"
--- a/gpu/command_buffer/service/service_transfer_cache.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/service_transfer_cache.cc	2019-05-17 18:53:33.032000000 +0300
@@ -6,8 +6,6 @@
 
 #include <inttypes.h>
 
-#include <utility>
-
 #include "base/bind.h"
 #include "base/strings/stringprintf.h"
 #include "base/system/sys_info.h"
@@ -15,7 +13,6 @@
 #include "base/trace_event/memory_dump_manager.h"
 #include "cc/paint/image_transfer_cache_entry.h"
 #include "gpu/command_buffer/service/service_discardable_manager.h"
-#include "third_party/skia/include/core/SkImage.h"
 #include "third_party/skia/include/gpu/GrBackendSurface.h"
 #include "ui/gl/trace_util.h"
 
@@ -207,37 +204,6 @@
   }
 }
 
-bool ServiceTransferCache::CreateLockedImageEntry(
-    int decoder_id,
-    uint32_t entry_id,
-    ServiceDiscardableHandle handle,
-    GrContext* context,
-    base::span<const uint8_t> decoded_image,
-    size_t row_bytes,
-    const SkImageInfo& image_info,
-    bool needs_mips,
-    sk_sp<SkColorSpace> target_color_space) {
-  EntryKey key(decoder_id, cc::TransferCacheEntryType::kImage, entry_id);
-  auto found = entries_.Peek(key);
-  if (found != entries_.end())
-    return false;
-
-  // Create the service-side image transfer cache entry. Note that this involves
-  // uploading the image if it fits in GPU memory.
-  auto entry = std::make_unique<cc::ServiceImageTransferCacheEntry>();
-  if (!entry->BuildFromDecodedData(context, decoded_image, row_bytes,
-                                   image_info, needs_mips,
-                                   target_color_space)) {
-    return false;
-  }
-
-  // Insert it in the transfer cache.
-  total_size_ += entry->CachedSize();
-  entries_.Put(key, CacheEntryInternal(handle, std::move(entry)));
-  EnforceLimits();
-  return true;
-}
-
 bool ServiceTransferCache::OnMemoryDump(
     const base::trace_event::MemoryDumpArgs& args,
     base::trace_event::ProcessMemoryDump* pmd) {
--- a/gpu/command_buffer/service/service_transfer_cache.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/service_transfer_cache.h	2019-05-17 18:53:33.032000000 +0300
@@ -5,10 +5,7 @@
 #ifndef GPU_COMMAND_BUFFER_SERVICE_SERVICE_TRANSFER_CACHE_H_
 #define GPU_COMMAND_BUFFER_SERVICE_SERVICE_TRANSFER_CACHE_H_
 
-#include <stddef.h>
-#include <stdint.h>
-
-#include <memory>
+#include <vector>
 
 #include "base/containers/mru_cache.h"
 #include "base/containers/span.h"
@@ -17,18 +14,12 @@
 #include "gpu/command_buffer/common/discardable_handle.h"
 #include "gpu/command_buffer/service/context_group.h"
 #include "gpu/gpu_gles2_export.h"
-#include "third_party/skia/include/core/SkRefCnt.h"
-
-class GrContext;
-class SkColorSpace;
-struct SkImageInfo;
 
 namespace gpu {
 
-// ServiceTransferCache is a GPU process interface for retrieving cached entries
+// ServiceTransferCache is a GPU process interface for retreiving cached entries
 // from the transfer cache. These entries are populated by client calls to the
-// ClientTransferCache or by an image decode accelerator task in the GPU
-// process.
+// ClientTransferCache.
 //
 // In addition to access, the ServiceTransferCache is also responsible for
 // unlocking and deleting entries when no longer needed, as well as enforcing
@@ -60,23 +51,6 @@
   cc::ServiceTransferCacheEntry* GetEntry(const EntryKey& key);
   void DeleteAllEntriesForDecoder(int decoder_id);
 
-  // Creates an image transfer cache entry using the decoded data in
-  // |decoded_image|. The |context| will be used to upload the image (if it's
-  // determined to fit in the GPU). |row_bytes| is the stride, and |image_info|
-  // describes the decoded data. |decoder_id| and |entry_id| are used for
-  // creating the ServiceTransferCache::EntryKey (assuming
-  // cc::TransferCacheEntryType:kImage for the type). Returns true if the entry
-  // could be created and inserted; false otherwise.
-  bool CreateLockedImageEntry(int decoder_id,
-                              uint32_t entry_id,
-                              ServiceDiscardableHandle handle,
-                              GrContext* context,
-                              base::span<const uint8_t> decoded_image,
-                              size_t row_bytes,
-                              const SkImageInfo& image_info,
-                              bool needs_mips,
-                              sk_sp<SkColorSpace> target_color_space);
-
   void PurgeMemory(
       base::MemoryPressureListener::MemoryPressureLevel memory_pressure_level);
 
--- a/gpu/command_buffer/service/service_utils.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/service_utils.cc	2019-05-17 18:53:33.032000000 +0300
@@ -169,8 +169,6 @@
       command_line->HasSwitch(switches::kEnableUnsafeWebGPU);
   gpu_preferences.enable_raster_to_sk_image =
       command_line->HasSwitch(switches::kEnableRasterToSkImage);
-  gpu_preferences.enable_vulkan =
-      command_line->HasSwitch(switches::kEnableVulkan);
   return gpu_preferences;
 }
 
--- a/gpu/command_buffer/service/shader_translator_unittest.cc	2019-05-17 17:45:41.016000000 +0300
+++ b/gpu/command_buffer/service/shader_translator_unittest.cc	2019-05-17 18:53:33.032000000 +0300
@@ -438,8 +438,8 @@
 };
 
 // crbug.com/540543
-// https://bugs.ch40m1um.qjz9zk/p/angleproject/issues/detail?id=1276
-// https://bugs.ch40m1um.qjz9zk/p/angleproject/issues/detail?id=1277
+// https://bugs.chromium.org/p/angleproject/issues/detail?id=1276
+// https://bugs.chromium.org/p/angleproject/issues/detail?id=1277
 TEST_F(ShaderTranslatorOutputVersionTest, DISABLED_CompatibilityOutput) {
   ShBuiltInResources resources;
   sh::InitBuiltInResources(&resources);
@@ -550,7 +550,7 @@
 // certain version of GLSL to be guaranteed to be supported. Test
 // that ShaderTranslator produces a GLSL shader with the exact
 // specified GLSL version for each known OpenGL version.
-INSTANTIATE_TEST_SUITE_P(
+INSTANTIATE_TEST_CASE_P(
     KnownOpenGLContexts,
     ShaderTranslatorOutputVersionTest,
     testing::Values(make_gl_glsl_tuple("4.5", "#version 450\n"),
@@ -570,7 +570,7 @@
 // similar shader. We do not expect that future 3.3+ specs contain
 // the "all eariler GLSL versions" clause, since 3.3 did not contain
 // it either.
-INSTANTIATE_TEST_SUITE_P(OldOrUnknownOpenGLContexts,
+INSTANTIATE_TEST_CASE_P(OldOrUnknownOpenGLContexts,
                          ShaderTranslatorOutputVersionTest,
                          testing::Values(make_gl_glsl_tuple("3.4", ""),
                                          make_gl_glsl_tuple("2.0", "")));
@@ -579,7 +579,7 @@
 // code assumes that the future OpenGL specs specify the clause that all
 // earlier GLSL versions are supported. We select the highest GLSL
 // version known at the time of writing.
-INSTANTIATE_TEST_SUITE_P(
+INSTANTIATE_TEST_CASE_P(
     BackwardsCompatibleFutureOpenGLContexts,
     ShaderTranslatorOutputVersionTest,
     testing::Values(make_gl_glsl_tuple("5.0", "#version 450\n"),
@@ -589,13 +589,13 @@
 // contexts, the shader is such that GLSL 1.0 is used. The translator
 // selects GLSL 1.0 by not output any version at the moment, though we
 // do not know if that would be correct for the future OpenGL ES specs.
-INSTANTIATE_TEST_SUITE_P(
-    OpenGLESContexts,
+INSTANTIATE_TEST_CASE_P(OpenGLESContexts,
     ShaderTranslatorOutputVersionTest,
     testing::Values(make_gl_glsl_tuple("opengl es 2.0", ""),
                     make_gl_glsl_tuple("opengl es 3.0", ""),
                     make_gl_glsl_tuple("opengl es 3.1", ""),
-                    make_gl_glsl_tuple("opengl es 3.2", "")));
+                                        make_gl_glsl_tuple("opengl es 3.2",
+                                                           "")));
 
 }  // namespace gles2
 }  // namespace gpu
--- a/gpu/command_buffer/service/shared_context_state.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/shared_context_state.cc	2019-05-17 18:53:33.032000000 +0300
@@ -113,7 +113,6 @@
     options.fGlyphCacheTextureMaximumBytes = glyph_cache_max_texture_bytes_;
     options.fPersistentCache = cache;
     options.fAvoidStencilBuffers = workarounds.avoid_stencil_buffers;
-    options.fDisallowGLSLBinaryCaching = workarounds.disable_program_disk_cache;
     owned_gr_context_ = GrContext::MakeGL(std::move(interface), options);
     gr_context_ = owned_gr_context_.get();
     if (!gr_context_) {
--- a/gpu/command_buffer/service/shared_image_backing.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/shared_image_backing.cc	2019-05-17 18:53:33.032000000 +0300
@@ -30,12 +30,6 @@
   return nullptr;
 }
 
-std::unique_ptr<SharedImageRepresentationGLTexture>
-SharedImageBacking::ProduceRGBEmulationGLTexture(SharedImageManager* manager,
-                                                 MemoryTypeTracker* tracker) {
-  return nullptr;
-}
-
 std::unique_ptr<SharedImageRepresentationGLTexturePassthrough>
 SharedImageBacking::ProduceGLTexturePassthrough(SharedImageManager* manager,
                                                 MemoryTypeTracker* tracker) {
--- a/gpu/command_buffer/service/shared_image_backing_factory_ahardwarebuffer.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/shared_image_backing_factory_ahardwarebuffer.cc	2019-05-17 18:53:33.032000000 +0300
@@ -5,12 +5,6 @@
 #include "gpu/command_buffer/service/shared_image_backing_factory_ahardwarebuffer.h"
 
 #include <sync/sync.h>
-#include <unistd.h>
-
-#include <algorithm>
-#include <memory>
-#include <utility>
-#include <vector>
 
 #include "base/android/android_hardware_buffer_compat.h"
 #include "base/android/scoped_hardware_buffer_handle.h"
@@ -45,38 +39,6 @@
 #include "ui/gl/gl_version_info.h"
 
 namespace gpu {
-namespace {
-
-bool InsertWriteFence(base::ScopedFD write_sync_fd) {
-  if (write_sync_fd.is_valid()) {
-    if (!InsertEglFenceAndWait(std::move(write_sync_fd)))
-      return false;
-  }
-
-  return true;
-}
-
-bool InsertReadFences(std::vector<base::ScopedFD> read_sync_fds) {
-  for (auto& fd : read_sync_fds) {
-    if (!InsertEglFenceAndWait(std::move(fd)))
-      return false;
-  }
-
-  return true;
-}
-
-bool InsertAllFencesForWriting(base::ScopedFD write_sync_fd,
-                               std::vector<base::ScopedFD> read_sync_fds) {
-  if (!InsertWriteFence(std::move(write_sync_fd)))
-    return false;
-
-  if (!InsertReadFences(std::move(read_sync_fds)))
-    return false;
-
-  return true;
-}
-
-}  // namespace
 
 // Implementation of SharedImageBacking that holds an AHardwareBuffer. This
 // can be used to create a GL texture or a VK Image from the AHardwareBuffer
@@ -100,12 +62,11 @@
   bool ProduceLegacyMailbox(MailboxManager* mailbox_manager) override;
   void Destroy() override;
   SharedContextState* GetContextState() const;
-  base::ScopedFD GetWriteSyncFd() const;
-  std::vector<base::ScopedFD> GetReadSyncFds() const;
-  void ClearReadSyncFds();
+  base::ScopedFD TakeGLWriteSyncFd();
+  base::ScopedFD TakeVkReadSyncFd();
   base::android::ScopedHardwareBufferHandle GetAhbHandle();
-  void SetWriteSyncFd(base::ScopedFD fd);
-  void AddReadSyncFd(base::ScopedFD fd);
+  void SetGLWriteSyncFd(base::ScopedFD fd);
+  void SetVkReadSyncFd(base::ScopedFD fd);
 
  protected:
   std::unique_ptr<SharedImageRepresentationGLTexture> ProduceGLTexture(
@@ -117,20 +78,25 @@
       MemoryTypeTracker* tracker) override;
 
  private:
-  gles2::Texture* GenGLTexture();
+  bool GenGLTexture();
   base::android::ScopedHardwareBufferHandle hardware_buffer_handle_;
 
-  gles2::Texture* legacy_texture_ = nullptr;
-
+  // This texture will be lazily initialised/created when ProduceGLTexture is
+  // called.
+  gles2::Texture* texture_ = nullptr;
+
+  // TODO(vikassoni): In future when we add begin/end write support, we will
+  // need to properly use this flag to pass the is_cleared_ information to
+  // the GL texture representation while begin write and back to this class from
+  // the GL texture represntation after end write. This is because this class
+  // will not know if SetCleared() arrives during begin write happening on GL
+  // texture representation.
   bool is_cleared_ = false;
   SharedContextState* context_state_ = nullptr;
+  base::ScopedFD gl_write_sync_fd_;
+  base::ScopedFD vk_read_sync_fd_;
 
-  // All reads and writes must wait for exiting writes to complete.
-  base::ScopedFD write_sync_fd_;
-
-  // All writes must wait for existing reads to complete.
-  std::vector<base::ScopedFD> read_sync_fds_;
-
+  sk_sp<SkPromiseImageTexture> cached_promise_texture_;
   DISALLOW_COPY_AND_ASSIGN(SharedImageBackingAHB);
 };
 
@@ -145,20 +111,21 @@
       : SharedImageRepresentationGLTexture(manager, backing, tracker),
         texture_(texture) {}
 
-  ~SharedImageRepresentationGLTextureAHB() override {
-    if (texture_)
-      texture_->RemoveLightweightRef(has_context());
-  }
-
   gles2::Texture* GetTexture() override { return texture_; }
 
   bool BeginAccess(GLenum mode) override {
-    if (mode == GL_SHARED_IMAGE_ACCESS_MODE_READ_CHROMIUM) {
-      if (!InsertWriteFence(ahb_backing()->GetWriteSyncFd()))
-        return false;
-    } else if (mode == GL_SHARED_IMAGE_ACCESS_MODE_READWRITE_CHROMIUM) {
-      if (!InsertAllFencesForWriting(ahb_backing()->GetWriteSyncFd(),
-                                     ahb_backing()->GetReadSyncFds()))
+    // TODO(vikassoni): Currently Skia Vk backing never does a write. So GL read
+    // do not need to wait for the Vk write to finish. Eventually when Vk starts
+    // writing, we will need to TakeVkWriteSyncFd() and wait on it for mode =
+    // GL_SHARED_IMAGE_ACCESS_MODE_READ_CHROMIUM.
+
+    // Wait on Vk read if GL is going to write.
+    // TODO(vikassoni): GL writes should wait on both Vk read and Vk writes.
+    if (mode == GL_SHARED_IMAGE_ACCESS_MODE_READWRITE_CHROMIUM) {
+      base::ScopedFD sync_fd = ahb_backing()->TakeVkReadSyncFd();
+
+      // Create an egl fence sync and do a server side wait.
+      if (!InsertEglFenceAndWait(std::move(sync_fd)))
         return false;
     }
     mode_ = mode;
@@ -166,22 +133,17 @@
   }
 
   void EndAccess() override {
-    if (mode_ == GL_SHARED_IMAGE_ACCESS_MODE_READ_CHROMIUM) {
-      InsertReadFences(ahb_backing()->GetReadSyncFds());
-    } else if (mode_ == GL_SHARED_IMAGE_ACCESS_MODE_READWRITE_CHROMIUM) {
+    // TODO(vikassoni): Currently Skia Vk backing never does a write. So Vk
+    // writes do not need to wait on GL to finish the read. Eventually when Vk
+    // starts writing, we will need to create and set a GLReadSyncFd for mode =
+    // GL_SHARED_IMAGE_ACCESS_MODE_READ_CHROMIUM for Vk to wait on it.
+    if (mode_ == GL_SHARED_IMAGE_ACCESS_MODE_READWRITE_CHROMIUM) {
       base::ScopedFD sync_fd = CreateEglFenceAndExportFd();
       if (!sync_fd.is_valid())
         return;
 
       // Pass this fd to its backing.
-      ahb_backing()->SetWriteSyncFd(std::move(sync_fd));
-
-      ahb_backing()->ClearReadSyncFds();
-
-      if (texture_) {
-        if (texture_->IsLevelCleared(texture_->target(), 0))
-          backing()->SetCleared();
-      }
+      ahb_backing()->SetGLWriteSyncFd(std::move(sync_fd));
     }
   }
 
@@ -205,20 +167,16 @@
       SharedImageBacking* backing,
       sk_sp<SkPromiseImageTexture> cached_promise_image_texture,
       MemoryTypeTracker* tracker,
-      gles2::Texture* texture)
+      GLenum target,
+      GLuint service_id)
       : SharedImageRepresentationSkia(manager, backing, tracker),
-        promise_texture_(cached_promise_image_texture),
-        texture_(std::move(texture)) {
+        promise_texture_(cached_promise_image_texture) {
 #if DCHECK_IS_ON()
     context_ = gl::GLContext::GetCurrent();
 #endif
   }
 
-  ~SharedImageRepresentationSkiaGLAHB() override {
-    DCHECK(!write_surface_);
-    if (texture_)
-      texture_->RemoveLightweightRef(has_context());
-  }
+  ~SharedImageRepresentationSkiaGLAHB() override { DCHECK(!write_surface_); }
 
   sk_sp<SkSurface> BeginWriteAccess(
       GrContext* gr_context,
@@ -230,8 +188,13 @@
     if (write_surface_)
       return nullptr;
 
-    InsertAllFencesForWriting(ahb_backing()->GetWriteSyncFd(),
-                              ahb_backing()->GetReadSyncFds());
+    // Synchronise this access with the Vk reads.
+    // TODO(vikassoni): SkiaGL writes should wait on both Vk read and Vk writes.
+    base::ScopedFD sync_fd = ahb_backing()->TakeVkReadSyncFd();
+
+    // Create an egl fence sync and do a server side wait.
+    if (!InsertEglFenceAndWait(std::move(sync_fd)))
+      return nullptr;
 
     if (!promise_texture_) {
       return nullptr;
@@ -241,8 +204,8 @@
         /*gpu_compositing=*/true, format());
     auto surface = SkSurface::MakeFromBackendTextureAsRenderTarget(
         gr_context, promise_texture_->backendTexture(),
-        kTopLeft_GrSurfaceOrigin, final_msaa_count, sk_color_type,
-        backing()->color_space().ToSkColorSpace(), &surface_props);
+        kTopLeft_GrSurfaceOrigin, final_msaa_count, sk_color_type, nullptr,
+        &surface_props);
     write_surface_ = surface.get();
     return surface;
   }
@@ -261,30 +224,23 @@
       return;
 
     // Pass this fd to its backing.
-    ahb_backing()->SetWriteSyncFd(std::move(sync_fd));
-
-    ahb_backing()->ClearReadSyncFds();
-
-    if (texture_) {
-      if (texture_->IsLevelCleared(texture_->target(), 0))
-        backing()->SetCleared();
-    }
+    ahb_backing()->SetGLWriteSyncFd(std::move(sync_fd));
   }
 
   sk_sp<SkPromiseImageTexture> BeginReadAccess(SkSurface* sk_surface) override {
     CheckContext();
-    if (!InsertWriteFence(ahb_backing()->GetWriteSyncFd()))
-      return nullptr;
+    // TODO(vikassoni): Currently Skia Vk backing never does a write. So this
+    // read do not need to wait for the Vk write to finish. Eventually when Vk
+    // starts writing, we might need to TakeVkWriteSyncFd() and wait on it.
     return promise_texture_;
   }
 
   void EndReadAccess() override {
     CheckContext();
-
-    base::ScopedFD sync_fd = CreateEglFenceAndExportFd();
-    if (!sync_fd.is_valid())
-      return;
-    ahb_backing()->AddReadSyncFd(std::move(sync_fd));
+    // TODO(vikassoni): Currently Skia Vk backing never does a write. So Vk
+    // writes do not need to wait on this read to finish. Eventually when Vk
+    // starts writing, we will need to create and set a SkiaGLReadSyncFd.
+    // TODO(ericrk): Handle begin/end correctness checks.
   }
 
  private:
@@ -299,7 +255,6 @@
   }
 
   sk_sp<SkPromiseImageTexture> promise_texture_;
-  gles2::Texture* texture_;
   SkSurface* write_surface_ = nullptr;
 #if DCHECK_IS_ON()
   gl::GLContext* context_;
@@ -316,9 +271,18 @@
     SharedImageBackingAHB* ahb_backing =
         static_cast<SharedImageBackingAHB*>(backing);
     DCHECK(ahb_backing);
-    context_state_ = ahb_backing->GetContextState();
-    DCHECK(context_state_);
-    DCHECK(context_state_->vk_context_provider());
+    SharedContextState* context_state = ahb_backing->GetContextState();
+    DCHECK(context_state);
+    DCHECK(context_state->vk_context_provider());
+
+    vk_device_ = context_state->vk_context_provider()
+                     ->GetDeviceQueue()
+                     ->GetVulkanDevice();
+    vk_phy_device_ = context_state->vk_context_provider()
+                         ->GetDeviceQueue()
+                         ->GetVulkanPhysicalDevice();
+    vk_implementation_ =
+        context_state->vk_context_provider()->GetVulkanImplementation();
   }
 
   ~SharedImageRepresentationSkiaVkAHB() override { DCHECK(!read_surface_); }
@@ -340,21 +304,18 @@
     DCHECK(sk_surface);
 
     // Synchronise the read access with the GL writes.
-    base::ScopedFD sync_fd = ahb_backing()->GetWriteSyncFd();
+    base::ScopedFD sync_fd = ahb_backing()->TakeGLWriteSyncFd();
 
-    VkSemaphore semaphore = VK_NULL_HANDLE;
     // We need to wait only if there is a valid fd.
     if (sync_fd.is_valid()) {
-      // Import the above sync fd into a semaphore.
-      if (!vk_implementation()->ImportSemaphoreFdKHR(
-              vk_device(), std::move(sync_fd), &semaphore)) {
-        return nullptr;
-      }
-
-      // Submit wait semaphore to the queue. Note that Skia uses the same queue
-      // exposed by vk_queue(), so this will work due to Vulkan queue ordering.
-      if (!vk_implementation()->SubmitWaitSemaphore(vk_queue(), semaphore)) {
-        vkDestroySemaphore(vk_device(), semaphore, nullptr);
+      // Do a client side wait for now.
+      // TODO(vikassoni): There seems to be a skia bug -
+      // https://bugs.chromium.org/p/chromium/issues/detail?id=916812 currently
+      // where wait() on the sk surface crashes. Remove the sync_wait() and
+      // apply CL mentioned in the bug when the issue is fixed.
+      static const int InfiniteSyncWaitTimeout = -1;
+      if (sync_wait(sync_fd.get(), InfiniteSyncWaitTimeout) < 0) {
+        LOG(ERROR) << "Failed while waiting on GL Write sync fd";
         return nullptr;
       }
     }
@@ -364,8 +325,8 @@
     VkImageCreateInfo vk_image_info;
     VkDeviceMemory vk_device_memory;
     VkDeviceSize mem_allocation_size;
-    if (!vk_implementation()->CreateVkImageAndImportAHB(
-            vk_device(), vk_phy_device(), size(), ahb_backing()->GetAhbHandle(),
+    if (!vk_implementation_->CreateVkImageAndImportAHB(
+            vk_device_, vk_phy_device_, size(), ahb_backing()->GetAhbHandle(),
             &vk_image, &vk_image_info, &vk_device_memory,
             &mem_allocation_size)) {
       return nullptr;
@@ -384,8 +345,8 @@
     auto promise_texture = SkPromiseImageTexture::Make(
         GrBackendTexture(size().width(), size().height(), vk_info));
     if (!promise_texture) {
-      vkDestroyImage(vk_device(), vk_image, nullptr);
-      vkFreeMemory(vk_device(), vk_device_memory, nullptr);
+      vkDestroyImage(vk_device_, vk_image, nullptr);
+      vkFreeMemory(vk_device_, vk_device_memory, nullptr);
       return nullptr;
     }
 
@@ -393,18 +354,6 @@
     // EndReadAccess. Also make sure previous read_surface_ have been consumed
     // by EndReadAccess() call.
     read_surface_ = sk_surface;
-
-    // TODO(vikassoni): Need to do better semaphore cleanup management. Waiting
-    // on device to be idle to delete the semaphore is costly. Instead use a
-    // fence to get signal when semaphore submission is done.
-    if (semaphore != VK_NULL_HANDLE) {
-      VkResult result = vkQueueWaitIdle(vk_queue());
-      if (result != VK_SUCCESS) {
-        LOG(ERROR) << "vkQueueWaitIdle failed: " << result;
-        return nullptr;
-      }
-      vkDestroySemaphore(vk_device(), semaphore, nullptr);
-    }
     return promise_texture;
   }
 
@@ -423,9 +372,10 @@
     sem_info.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;
     sem_info.pNext = &export_info;
     sem_info.flags = 0;
-    VkResult result =
-        vkCreateSemaphore(vk_device(), &sem_info, nullptr, &vk_semaphore);
+    bool result =
+        vkCreateSemaphore(vk_device_, &sem_info, nullptr, &vk_semaphore);
     if (result != VK_SUCCESS) {
+      // TODO(vikassoni): add more error handling rather than just return ?
       LOG(ERROR) << "vkCreateSemaphore failed";
       read_surface_ = nullptr;
       return;
@@ -438,7 +388,7 @@
     // instruct the GPU to wait on any of the semaphores.
     if (read_surface_->flushAndSignalSemaphores(1, &gr_semaphore) ==
         GrSemaphoresSubmitted::kNo) {
-      vkDestroySemaphore(vk_device(), vk_semaphore, nullptr);
+      vkDestroySemaphore(vk_device_, vk_semaphore, nullptr);
       read_surface_ = nullptr;
       return;
     }
@@ -450,10 +400,10 @@
     // GPU. The caller must delete the semaphores created.
     // Export a sync fd from the semaphore.
     base::ScopedFD sync_fd;
-    vk_implementation()->GetSemaphoreFdKHR(vk_device(), vk_semaphore, &sync_fd);
+    vk_implementation_->GetSemaphoreFdKHR(vk_device_, vk_semaphore, &sync_fd);
 
     // pass this sync fd to the backing.
-    ahb_backing()->AddReadSyncFd(std::move(sync_fd));
+    ahb_backing()->SetVkReadSyncFd(std::move(sync_fd));
 
     // TODO(vikassoni): We need to wait for the queue submission to complete
     // before we can destroy the semaphore. This will decrease the performance.
@@ -461,12 +411,8 @@
     // in a STL queue instead of destroying it. Later use a fence to check if
     // the batch that refers the semaphore has completed execution. Delete the
     // semaphore once the fence is signalled.
-    result = vkQueueWaitIdle(vk_queue());
-    if (result != VK_SUCCESS) {
-      LOG(ERROR) << "vkQueueWaitIdle failed: " << result;
-      return;
-    }
-    vkDestroySemaphore(vk_device(), vk_semaphore, nullptr);
+    vkDeviceWaitIdle(vk_device_);
+    vkDestroySemaphore(vk_device_, vk_semaphore, nullptr);
   }
 
  private:
@@ -474,30 +420,10 @@
     return static_cast<SharedImageBackingAHB*>(backing());
   }
 
-  gpu::VulkanImplementation* vk_implementation() {
-    return context_state_->vk_context_provider()->GetVulkanImplementation();
-  }
-
-  VkDevice vk_device() {
-    return context_state_->vk_context_provider()
-        ->GetDeviceQueue()
-        ->GetVulkanDevice();
-  }
-
-  VkPhysicalDevice vk_phy_device() {
-    return context_state_->vk_context_provider()
-        ->GetDeviceQueue()
-        ->GetVulkanPhysicalDevice();
-  }
-
-  VkQueue vk_queue() {
-    return context_state_->vk_context_provider()
-        ->GetDeviceQueue()
-        ->GetVulkanQueue();
-  }
-
   SkSurface* read_surface_ = nullptr;
-  SharedContextState* context_state_ = nullptr;
+  gpu::VulkanImplementation* vk_implementation_ = nullptr;
+  VkDevice vk_device_ = VK_NULL_HANDLE;
+  VkPhysicalDevice vk_phy_device_ = VK_NULL_HANDLE;
 };
 
 SharedImageBackingAHB::SharedImageBackingAHB(
@@ -524,15 +450,18 @@
   // Check to make sure buffer is explicitly destroyed using Destroy() api
   // before this destructor is called.
   DCHECK(!hardware_buffer_handle_.is_valid());
+  DCHECK(!texture_);
 }
 
 bool SharedImageBackingAHB::IsCleared() const {
+  if (texture_)
+    return texture_->IsLevelCleared(texture_->target(), 0);
   return is_cleared_;
 }
 
 void SharedImageBackingAHB::SetCleared() {
-  if (legacy_texture_)
-    legacy_texture_->SetLevelCleared(legacy_texture_->target(), 0, true);
+  if (texture_)
+    texture_->SetLevelCleared(texture_->target(), 0, true);
   is_cleared_ = true;
 }
 
@@ -541,18 +470,18 @@
 bool SharedImageBackingAHB::ProduceLegacyMailbox(
     MailboxManager* mailbox_manager) {
   DCHECK(hardware_buffer_handle_.is_valid());
-  legacy_texture_ = GenGLTexture();
-  if (!legacy_texture_)
+  if (!GenGLTexture())
     return false;
-  mailbox_manager->ProduceTexture(mailbox(), legacy_texture_);
+  DCHECK(texture_);
+  mailbox_manager->ProduceTexture(mailbox(), texture_);
   return true;
 }
 
 void SharedImageBackingAHB::Destroy() {
   DCHECK(hardware_buffer_handle_.is_valid());
-  if (legacy_texture_) {
-    legacy_texture_->RemoveLightweightRef(have_context());
-    legacy_texture_ = nullptr;
+  if (texture_) {
+    texture_->RemoveLightweightRef(have_context());
+    texture_ = nullptr;
   }
   hardware_buffer_handle_.reset();
 }
@@ -561,33 +490,20 @@
   return context_state_;
 }
 
-base::ScopedFD SharedImageBackingAHB::GetWriteSyncFd() const {
-  base::ScopedFD dup_fd =
-      base::ScopedFD(HANDLE_EINTR(dup(write_sync_fd_.get())));
-  return dup_fd;
+base::ScopedFD SharedImageBackingAHB::TakeGLWriteSyncFd() {
+  return std::move(gl_write_sync_fd_);
 }
 
-void SharedImageBackingAHB::SetWriteSyncFd(base::ScopedFD fd) {
-  write_sync_fd_ = std::move(fd);
+void SharedImageBackingAHB::SetGLWriteSyncFd(base::ScopedFD fd) {
+  gl_write_sync_fd_ = std::move(fd);
 }
 
-std::vector<base::ScopedFD> SharedImageBackingAHB::GetReadSyncFds() const {
-  std::vector<base::ScopedFD> dup_fds{read_sync_fds_.size()};
-  for (size_t i = 0; i < read_sync_fds_.size(); ++i) {
-    base::ScopedFD dup_fd =
-        base::ScopedFD(HANDLE_EINTR(dup(read_sync_fds_[i].get())));
-    dup_fds.emplace_back(std::move(dup_fd));
-  }
-  return dup_fds;
+base::ScopedFD SharedImageBackingAHB::TakeVkReadSyncFd() {
+  return std::move(vk_read_sync_fd_);
 }
 
-void SharedImageBackingAHB::AddReadSyncFd(base::ScopedFD fd) {
-  read_sync_fds_.emplace_back(std::move(fd));
-}
-
-void SharedImageBackingAHB::ClearReadSyncFds() {
-  // Swap with a new vector to release capacity.
-  std::vector<base::ScopedFD>().swap(read_sync_fds_);
+void SharedImageBackingAHB::SetVkReadSyncFd(base::ScopedFD fd) {
+  vk_read_sync_fd_ = std::move(fd);
 }
 
 base::android::ScopedHardwareBufferHandle
@@ -600,12 +516,12 @@
                                         MemoryTypeTracker* tracker) {
   // Use same texture for all the texture representations generated from same
   // backing.
-  auto* texture = GenGLTexture();
-  if (!texture)
+  if (!GenGLTexture())
     return nullptr;
 
+  DCHECK(texture_);
   return std::make_unique<SharedImageRepresentationGLTextureAHB>(
-      manager, this, tracker, std::move(texture));
+      manager, this, tracker, texture_);
 }
 
 std::unique_ptr<SharedImageRepresentationSkia>
@@ -619,21 +535,26 @@
     return std::make_unique<SharedImageRepresentationSkiaVkAHB>(manager, this);
   }
 
-  auto* texture = GenGLTexture();
-  if (!texture)
+  if (!GenGLTexture())
     return nullptr;
 
+  if (!cached_promise_texture_) {
   GrBackendTexture backend_texture;
   GetGrBackendTexture(gl::GLContext::GetCurrent()->GetVersionInfo(),
-                      texture->target(), size(), texture->service_id(),
+                        texture_->target(), size(), texture_->service_id(),
                       format(), &backend_texture);
-  sk_sp<SkPromiseImageTexture> promise_texture =
-      SkPromiseImageTexture::Make(backend_texture);
+    cached_promise_texture_ = SkPromiseImageTexture::Make(backend_texture);
+  }
+  DCHECK(texture_);
   return std::make_unique<SharedImageRepresentationSkiaGLAHB>(
-      manager, this, promise_texture, tracker, std::move(texture));
+      manager, this, cached_promise_texture_, tracker, texture_->target(),
+      texture_->service_id());
 }
 
-gles2::Texture* SharedImageBackingAHB::GenGLTexture() {
+bool SharedImageBackingAHB::GenGLTexture() {
+  if (texture_)
+    return true;
+
   DCHECK(hardware_buffer_handle_.is_valid());
 
   // Target for AHB backed egl images.
@@ -662,23 +583,23 @@
     LOG(ERROR) << "Failed to create EGL image ";
     api->glBindTextureFn(target, old_texture_binding);
     api->glDeleteTexturesFn(1, &service_id);
-    return nullptr;
+    return false;
   }
   if (!egl_image->BindTexImage(target)) {
     LOG(ERROR) << "Failed to bind egl image";
     api->glBindTextureFn(target, old_texture_binding);
     api->glDeleteTexturesFn(1, &service_id);
-    return nullptr;
+    return false;
   }
 
   // Create a gles2 Texture.
-  auto* texture = new gles2::Texture(service_id);
-  texture->SetLightweightRef();
-  texture->SetTarget(target, 1);
-  texture->sampler_state_.min_filter = GL_LINEAR;
-  texture->sampler_state_.mag_filter = GL_LINEAR;
-  texture->sampler_state_.wrap_t = GL_CLAMP_TO_EDGE;
-  texture->sampler_state_.wrap_s = GL_CLAMP_TO_EDGE;
+  texture_ = new gles2::Texture(service_id);
+  texture_->SetLightweightRef();
+  texture_->SetTarget(target, 1);
+  texture_->sampler_state_.min_filter = GL_LINEAR;
+  texture_->sampler_state_.mag_filter = GL_LINEAR;
+  texture_->sampler_state_.wrap_t = GL_CLAMP_TO_EDGE;
+  texture_->sampler_state_.wrap_s = GL_CLAMP_TO_EDGE;
 
   // If the backing is already cleared, no need to clear it again.
   gfx::Rect cleared_rect;
@@ -687,14 +608,14 @@
 
   GLenum gl_format = viz::GLDataFormat(format());
   GLenum gl_type = viz::GLDataType(format());
-  texture->SetLevelInfo(target, 0, egl_image->GetInternalFormat(),
+  texture_->SetLevelInfo(target, 0, egl_image->GetInternalFormat(),
                         size().width(), size().height(), 1, 0, gl_format,
                         gl_type, cleared_rect);
-  texture->SetLevelImage(target, 0, egl_image.get(), gles2::Texture::BOUND);
-  texture->SetImmutable(true);
+  texture_->SetLevelImage(target, 0, egl_image.get(), gles2::Texture::BOUND);
+  texture_->SetImmutable(true);
   api->glBindTextureFn(target, old_texture_binding);
   DCHECK_EQ(egl_image->GetInternalFormat(), gl_format);
-  return texture;
+  return true;
 }
 
 SharedImageBackingFactoryAHB::SharedImageBackingFactoryAHB(
@@ -767,10 +688,6 @@
     max_gl_texture_size_ =
         std::min(max_gl_texture_size_, workarounds.max_texture_size);
   }
-  // Ensure max_texture_size_ is less than INT_MAX so that gfx::Rect and friends
-  // can be used to accurately represent all valid sub-rects, with overflow
-  // cases, clamped to INT_MAX, always invalid.
-  max_gl_texture_size_ = std::min(max_gl_texture_size_, INT_MAX - 1);
 }
 
 SharedImageBackingFactoryAHB::~SharedImageBackingFactoryAHB() = default;
--- a/gpu/command_buffer/service/shared_image_backing_factory_gl_texture.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/shared_image_backing_factory_gl_texture.cc	2019-05-17 18:53:33.032000000 +0300
@@ -4,10 +4,6 @@
 
 #include "gpu/command_buffer/service/shared_image_backing_factory_gl_texture.h"
 
-#include <algorithm>
-#include <string>
-#include <utility>
-
 #include "base/feature_list.h"
 #include "base/trace_event/memory_dump_manager.h"
 #include "base/trace_event/trace_event.h"
@@ -38,16 +34,15 @@
 
 namespace {
 
-using UnpackStateAttribs =
-    SharedImageBackingFactoryGLTexture::UnpackStateAttribs;
-
 class ScopedResetAndRestoreUnpackState {
  public:
   ScopedResetAndRestoreUnpackState(gl::GLApi* api,
-                                   const UnpackStateAttribs& attribs,
+                                   bool es3_capable,
+                                   bool desktop_gl,
+                                   bool supports_unpack_subimage,
                                    bool uploading_data)
       : api_(api) {
-    if (attribs.es3_capable) {
+    if (es3_capable) {
       // Need to unbind any GL_PIXEL_UNPACK_BUFFER for the nullptr in
       // glTexImage2D to mean "no pixels" (as opposed to offset 0 in the
       // buffer).
@@ -60,7 +55,7 @@
       if (unpack_alignment_ != 4)
         api_->glPixelStoreiFn(GL_UNPACK_ALIGNMENT, 4);
 
-      if (attribs.es3_capable || attribs.supports_unpack_subimage) {
+      if (es3_capable || supports_unpack_subimage) {
         api_->glGetIntegervFn(GL_UNPACK_ROW_LENGTH, &unpack_row_length_);
         if (unpack_row_length_)
           api_->glPixelStoreiFn(GL_UNPACK_ROW_LENGTH, 0);
@@ -72,7 +67,7 @@
           api_->glPixelStoreiFn(GL_UNPACK_SKIP_PIXELS, 0);
       }
 
-      if (attribs.es3_capable) {
+      if (es3_capable) {
         api_->glGetIntegervFn(GL_UNPACK_SKIP_IMAGES, &unpack_skip_images_);
         if (unpack_skip_images_)
           api_->glPixelStoreiFn(GL_UNPACK_SKIP_IMAGES, 0);
@@ -81,7 +76,7 @@
           api_->glPixelStoreiFn(GL_UNPACK_IMAGE_HEIGHT, 0);
       }
 
-      if (attribs.desktop_gl) {
+      if (desktop_gl) {
         api->glGetBooleanvFn(GL_UNPACK_SWAP_BYTES, &unpack_swap_bytes_);
         if (unpack_swap_bytes_)
           api->glPixelStoreiFn(GL_UNPACK_SWAP_BYTES, GL_FALSE);
@@ -232,30 +227,11 @@
   scoped_refptr<gles2::TexturePassthrough> texture_passthrough_;
 };
 
-class SharedImageBackingWithReadAccess : public SharedImageBacking {
- public:
-  SharedImageBackingWithReadAccess(const Mailbox& mailbox,
-                                   viz::ResourceFormat format,
-                                   const gfx::Size& size,
-                                   const gfx::ColorSpace& color_space,
-                                   uint32_t usage,
-                                   size_t estimated_size)
-      : SharedImageBacking(mailbox,
-                           format,
-                           size,
-                           color_space,
-                           usage,
-                           estimated_size) {}
-  ~SharedImageBackingWithReadAccess() override = default;
-
-  virtual void BeginReadAccess() = 0;
-};
-
 class SharedImageRepresentationSkiaImpl : public SharedImageRepresentationSkia {
  public:
   SharedImageRepresentationSkiaImpl(
       SharedImageManager* manager,
-      SharedImageBackingWithReadAccess* backing,
+      SharedImageBacking* backing,
       sk_sp<SkPromiseImageTexture> cached_promise_texture,
       MemoryTypeTracker* tracker,
       GLenum target,
@@ -290,8 +266,8 @@
         /*gpu_compositing=*/true, format());
     auto surface = SkSurface::MakeFromBackendTextureAsRenderTarget(
         gr_context, promise_texture_->backendTexture(),
-        kTopLeft_GrSurfaceOrigin, final_msaa_count, sk_color_type,
-        backing()->color_space().ToSkColorSpace(), &surface_props);
+        kTopLeft_GrSurfaceOrigin, final_msaa_count, sk_color_type, nullptr,
+        &surface_props);
     write_surface_ = surface.get();
     return surface;
   }
@@ -306,8 +282,6 @@
 
   sk_sp<SkPromiseImageTexture> BeginReadAccess(SkSurface* sk_surface) override {
     CheckContext();
-    static_cast<SharedImageBackingWithReadAccess*>(backing())
-        ->BeginReadAccess();
     return promise_texture_;
   }
 
@@ -334,30 +308,25 @@
 
 // Implementation of SharedImageBacking that creates a GL Texture and stores it
 // as a gles2::Texture. Can be used with the legacy mailbox implementation.
-class SharedImageBackingGLTexture : public SharedImageBackingWithReadAccess {
+class SharedImageBackingGLTexture : public SharedImageBacking {
  public:
   SharedImageBackingGLTexture(const Mailbox& mailbox,
                               viz::ResourceFormat format,
                               const gfx::Size& size,
                               const gfx::ColorSpace& color_space,
                               uint32_t usage,
-                              gles2::Texture* texture,
-                              const UnpackStateAttribs& attribs)
-      : SharedImageBackingWithReadAccess(mailbox,
+                              gles2::Texture* texture)
+      : SharedImageBacking(mailbox,
                                          format,
                                          size,
                                          color_space,
                                          usage,
                                          texture->estimated_size()),
-        texture_(texture),
-        attribs_(attribs) {
+        texture_(texture) {
     DCHECK(texture_);
   }
 
-  ~SharedImageBackingGLTexture() override {
-    DCHECK(!texture_);
-    DCHECK(!rgb_emulation_texture_);
-  }
+  ~SharedImageBackingGLTexture() override { DCHECK(!texture_); }
 
   bool IsCleared() const override {
     return texture_->IsLevelCleared(texture_->target(), 0);
@@ -377,13 +346,10 @@
     gl::GLImage* image = texture_->GetLevelImage(target, 0, &old_state);
     if (!image)
       return;
-    if (old_state == gles2::Texture::BOUND)
       image->ReleaseTexImage(target);
     gles2::Texture::ImageState new_state = gles2::Texture::UNBOUND;
-    if (image->ShouldBindOrCopy() == gl::GLImage::BIND &&
-        image->BindTexImage(target)) {
+    if (image->BindTexImage(target))
       new_state = gles2::Texture::BOUND;
-    }
     if (old_state != new_state)
       texture_->SetLevelImage(target, 0, image, new_state);
   }
@@ -398,11 +364,6 @@
     DCHECK(texture_);
     texture_->RemoveLightweightRef(have_context());
     texture_ = nullptr;
-
-    if (rgb_emulation_texture_) {
-      rgb_emulation_texture_->RemoveLightweightRef(have_context());
-      rgb_emulation_texture_ = nullptr;
-    }
   }
 
   void OnMemoryDump(const std::string& dump_name,
@@ -425,29 +386,6 @@
     texture_->DumpLevelMemory(pmd, client_tracing_id, dump_name);
   }
 
-  void BeginReadAccess() override {
-    GLenum target = texture_->target();
-    gles2::Texture::ImageState old_state = gles2::Texture::UNBOUND;
-    gl::GLImage* image = texture_->GetLevelImage(target, 0, &old_state);
-    if (image && old_state == gpu::gles2::Texture::UNBOUND) {
-      gl::GLApi* api = gl::g_current_gl_context;
-      ScopedRestoreTexture scoped_restore(api, target);
-      api->glBindTextureFn(target, texture_->service_id());
-      gles2::Texture::ImageState new_state = gles2::Texture::UNBOUND;
-      if (image->ShouldBindOrCopy() == gl::GLImage::BIND) {
-        if (image->BindTexImage(target))
-          new_state = gles2::Texture::BOUND;
-      } else {
-        ScopedResetAndRestoreUnpackState scoped_unpack_state(api, attribs_,
-                                                             /*upload=*/true);
-        if (image->CopyTexImage(target))
-          new_state = gles2::Texture::COPIED;
-      }
-      if (old_state != new_state)
-        texture_->SetLevelImage(target, 0, image, new_state);
-    }
-  }
-
  protected:
   std::unique_ptr<SharedImageRepresentationGLTexture> ProduceGLTexture(
       SharedImageManager* manager,
@@ -455,57 +393,6 @@
     return std::make_unique<SharedImageRepresentationGLTextureImpl>(
         manager, this, tracker, texture_);
   }
-
-  std::unique_ptr<SharedImageRepresentationGLTexture>
-  ProduceRGBEmulationGLTexture(SharedImageManager* manager,
-                               MemoryTypeTracker* tracker) override {
-    if (!rgb_emulation_texture_) {
-      GLenum target = texture_->target();
-      gl::GLApi* api = gl::g_current_gl_context;
-      ScopedRestoreTexture scoped_restore(api, target);
-
-      bool framebuffer_attachment_angle =
-          (usage() & (SHARED_IMAGE_USAGE_RASTER |
-                      SHARED_IMAGE_USAGE_GLES2_FRAMEBUFFER_HINT)) != 0;
-      GLuint service_id = MakeTextureAndSetParameters(
-          api, target, framebuffer_attachment_angle);
-
-      gles2::Texture::ImageState image_state = gles2::Texture::BOUND;
-      gl::GLImage* image = texture_->GetLevelImage(target, 0, &image_state);
-      if (!image) {
-        LOG(ERROR) << "Texture is not bound to an image.";
-        return nullptr;
-      }
-
-      DCHECK(image->ShouldBindOrCopy() == gl::GLImage::BIND);
-      const GLenum internal_format = GL_RGB;
-      if (!image->BindTexImageWithInternalformat(target, internal_format)) {
-        LOG(ERROR) << "Failed to bind image to rgb texture.";
-        api->glDeleteTexturesFn(1, &service_id);
-        return nullptr;
-      }
-
-      rgb_emulation_texture_ = new gles2::Texture(service_id);
-      rgb_emulation_texture_->SetLightweightRef();
-      rgb_emulation_texture_->SetTarget(target, 1);
-      rgb_emulation_texture_->sampler_state_.min_filter = GL_LINEAR;
-      rgb_emulation_texture_->sampler_state_.mag_filter = GL_LINEAR;
-      rgb_emulation_texture_->sampler_state_.wrap_s = GL_CLAMP_TO_EDGE;
-      rgb_emulation_texture_->sampler_state_.wrap_t = GL_CLAMP_TO_EDGE;
-
-      const gles2::Texture::LevelInfo* info = texture_->GetLevelInfo(target, 0);
-      rgb_emulation_texture_->SetLevelInfo(
-          target, 0, internal_format, info->width, info->height, 1, 0,
-          info->format, info->type, info->cleared_rect);
-
-      rgb_emulation_texture_->SetLevelImage(target, 0, image, image_state);
-      rgb_emulation_texture_->SetImmutable(true);
-    }
-
-    return std::make_unique<SharedImageRepresentationGLTextureImpl>(
-        manager, this, tracker, rgb_emulation_texture_);
-  }
-
   std::unique_ptr<SharedImageRepresentationSkia> ProduceSkia(
       SharedImageManager* manager,
       MemoryTypeTracker* tracker) override {
@@ -518,16 +405,13 @@
 
  private:
   gles2::Texture* texture_ = nullptr;
-  gles2::Texture* rgb_emulation_texture_ = nullptr;
   sk_sp<SkPromiseImageTexture> cached_promise_texture_;
-  const UnpackStateAttribs attribs_;
 };
 
 // Implementation of SharedImageBacking that creates a GL Texture and stores it
 // as a gles2::TexturePassthrough. Can be used with the legacy mailbox
 // implementation.
-class SharedImageBackingPassthroughGLTexture
-    : public SharedImageBackingWithReadAccess {
+class SharedImageBackingPassthroughGLTexture : public SharedImageBacking {
  public:
   SharedImageBackingPassthroughGLTexture(
       const Mailbox& mailbox,
@@ -537,7 +421,7 @@
       uint32_t usage,
       scoped_refptr<gles2::TexturePassthrough> passthrough_texture,
       bool is_cleared)
-      : SharedImageBackingWithReadAccess(mailbox,
+      : SharedImageBacking(mailbox,
                                          format,
                                          size,
                                          color_space,
@@ -565,9 +449,7 @@
     if (!image)
       return;
     image->ReleaseTexImage(target);
-    if (image->ShouldBindOrCopy() == gl::GLImage::BIND)
-      image->BindTexImage(target);
-    else
+    if (!image->BindTexImage(target))
       image->CopyTexImage(target);
   }
 
@@ -604,8 +486,6 @@
       gl_image->OnMemoryDump(pmd, client_tracing_id, dump_name);
   }
 
-  void BeginReadAccess() override {}
-
  protected:
   std::unique_ptr<SharedImageRepresentationGLTexturePassthrough>
   ProduceGLTexturePassthrough(SharedImageManager* manager,
@@ -640,18 +520,10 @@
       image_factory_(image_factory) {
   gl::GLApi* api = gl::g_current_gl_context;
   api->glGetIntegervFn(GL_MAX_TEXTURE_SIZE, &max_texture_size_);
-  // When the passthrough command decoder is used, the max_texture_size
-  // workaround is implemented by ANGLE. Trying to adjust the max size here
-  // would cause discrepency between what we think the max size is and what
-  // ANGLE tells the clients.
-  if (!use_passthrough_ && workarounds.max_texture_size) {
+  if (workarounds.max_texture_size) {
     max_texture_size_ =
         std::min(max_texture_size_, workarounds.max_texture_size);
   }
-  // Ensure max_texture_size_ is less than INT_MAX so that gfx::Rect and friends
-  // can be used to accurately represent all valid sub-rects, with overflow
-  // cases, clamped to INT_MAX, always invalid.
-  max_texture_size_ = std::min(max_texture_size_, INT_MAX - 1);
 
   // TODO(piman): Can we extract the logic out of FeatureInfo?
   scoped_refptr<gles2::FeatureInfo> feature_info =
@@ -661,12 +533,12 @@
   gpu_memory_buffer_formats_ =
       feature_info->feature_flags().gpu_memory_buffer_formats;
   texture_usage_angle_ = feature_info->feature_flags().angle_texture_usage;
-  attribs.es3_capable = feature_info->IsES3Capable();
-  attribs.desktop_gl = !feature_info->gl_version_info().is_es;
+  es3_capable_ = feature_info->IsES3Capable();
+  desktop_gl_ = !feature_info->gl_version_info().is_es;
   // Can't use the value from feature_info, as we unconditionally enable this
   // extension, and assume it can't be used if PBOs are not used (which isn't
   // true for Skia used direclty against GL).
-  attribs.supports_unpack_subimage =
+  supports_unpack_subimage_ =
       gl::g_current_gl_driver->ext.b_GL_EXT_unpack_subimage;
   bool enable_texture_storage =
       feature_info->feature_flags().ext_texture_storage;
@@ -846,8 +718,6 @@
     image = image_factory_->CreateAnonymousImage(
         size, format_info.buffer_format, gfx::BufferUsage::SCANOUT,
         &is_cleared);
-    // A SCANOUT image should not require copy.
-    DCHECK(!image || image->ShouldBindOrCopy() == gl::GLImage::BIND);
     if (!image || !image->BindTexImage(target)) {
       LOG(ERROR) << "CreateSharedImage: Failed to create image";
       api->glDeleteTexturesFn(1, &service_id);
@@ -862,13 +732,15 @@
                              size.width(), size.height());
     needs_subimage_upload = !pixel_data.empty();
   } else if (format_info.is_compressed) {
-    ScopedResetAndRestoreUnpackState scoped_unpack_state(api, attribs,
+    ScopedResetAndRestoreUnpackState scoped_unpack_state(
+        api, es3_capable_, desktop_gl_, supports_unpack_subimage_,
                                                          !pixel_data.empty());
     api->glCompressedTexImage2DFn(target, 0, format_info.image_internal_format,
                                   size.width(), size.height(), 0,
                                   pixel_data.size(), pixel_data.data());
   } else {
-    ScopedResetAndRestoreUnpackState scoped_unpack_state(api, attribs,
+    ScopedResetAndRestoreUnpackState scoped_unpack_state(
+        api, es3_capable_, desktop_gl_, supports_unpack_subimage_,
                                                          !pixel_data.empty());
     api->glTexImage2DFn(target, 0, format_info.image_internal_format,
                         size.width(), size.height(), 0,
@@ -879,19 +751,19 @@
   // If we are using a buffer or TexStorage API but have data to upload, do so
   // now via TexSubImage2D.
   if (needs_subimage_upload) {
-    ScopedResetAndRestoreUnpackState scoped_unpack_state(api, attribs,
+    ScopedResetAndRestoreUnpackState scoped_unpack_state(
+        api, es3_capable_, desktop_gl_, supports_unpack_subimage_,
                                                          !pixel_data.empty());
     api->glTexSubImage2DFn(target, 0, 0, 0, size.width(), size.height(),
                            format_info.adjusted_format, format_info.gl_type,
                            pixel_data.data());
   }
 
-  return MakeBacking(use_passthrough_, mailbox, target, service_id, image,
-                     gles2::Texture::BOUND, level_info_internal_format,
-                     format_info.gl_format, format_info.gl_type,
-                     format_info.swizzle,
+  return MakeBacking(mailbox, target, service_id, image, gles2::Texture::BOUND,
+                     level_info_internal_format, format_info.gl_format,
+                     format_info.gl_type, format_info.swizzle,
                      pixel_data.empty() ? is_cleared : true, format, size,
-                     color_space, usage, attribs);
+                     color_space, usage);
 }
 
 std::unique_ptr<SharedImageBacking>
@@ -914,9 +786,7 @@
     return nullptr;
   }
 
-  GLenum target =
-      (handle.type == gfx::SHARED_MEMORY_BUFFER ||
-       !NativeBufferNeedsPlatformSpecificTextureTarget(buffer_format))
+  GLenum target = handle.type == gfx::SHARED_MEMORY_BUFFER
           ? GL_TEXTURE_2D
           : gpu::GetPlatformSpecificTextureTarget();
   scoped_refptr<gl::GLImage> image = MakeGLImage(
@@ -925,15 +795,6 @@
     LOG(ERROR) << "Failed to create image.";
     return nullptr;
   }
-  // If we decide to use GL_TEXTURE_2D at the target for a native buffer, we
-  // would like to verify that it will actually work. If the image expects to be
-  // copied, there is no way to do this verification here, because copying is
-  // done lazily after the SharedImage is created, so require that the image is
-  // bindable. Currently NativeBufferNeedsPlatformSpecificTextureTarget can
-  // only return false on Chrome OS where GLImageNativePixmap is used which is
-  // always bindable.
-  DCHECK(handle.type == gfx::SHARED_MEMORY_BUFFER || target != GL_TEXTURE_2D ||
-         image->ShouldBindOrCopy() == gl::GLImage::BIND);
   if (color_space.IsValid())
     image->SetColorSpace(color_space);
 
@@ -947,53 +808,25 @@
                 SHARED_IMAGE_USAGE_GLES2_FRAMEBUFFER_HINT)) != 0;
   GLuint service_id = MakeTextureAndSetParameters(
       api, target, for_framebuffer_attachment && texture_usage_angle_);
-  bool is_rgb_emulation = usage & SHARED_IMAGE_USAGE_RGB_EMULATION;
 
+  // TODO(piman): RGB emulation
   gles2::Texture::ImageState image_state = gles2::Texture::UNBOUND;
-  if (image->ShouldBindOrCopy() == gl::GLImage::BIND) {
-    bool is_bound = false;
-    if (is_rgb_emulation)
-      is_bound = image->BindTexImageWithInternalformat(target, GL_RGB);
-    else
-      is_bound = image->BindTexImage(target);
-    if (is_bound) {
+  if (image->BindTexImage(target)) {
       image_state = gles2::Texture::BOUND;
-    } else {
-      LOG(ERROR) << "Failed to bind image to target.";
-      api->glDeleteTexturesFn(1, &service_id);
-      return nullptr;
-    }
   } else if (use_passthrough_) {
     image->CopyTexImage(target);
     image_state = gles2::Texture::COPIED;
   }
 
-  GLuint internal_format =
-      is_rgb_emulation ? GL_RGB : image->GetInternalFormat();
+  GLuint internal_format = image->GetInternalFormat();
   GLenum gl_format =
       gles2::TextureManager::ExtractFormatFromStorageFormat(internal_format);
   GLenum gl_type =
       gles2::TextureManager::ExtractTypeFromStorageFormat(internal_format);
 
-  return MakeBacking(use_passthrough_, mailbox, target, service_id, image,
-                     image_state, internal_format, gl_format, gl_type, nullptr,
-                     true, format, size, color_space, usage, attribs);
-}
-
-std::unique_ptr<SharedImageBacking>
-SharedImageBackingFactoryGLTexture::CreateSharedImageForTest(
-    const Mailbox& mailbox,
-    GLenum target,
-    GLuint service_id,
-    bool is_cleared,
-    viz::ResourceFormat format,
-    const gfx::Size& size,
-    uint32_t usage) {
-  return MakeBacking(false, mailbox, target, service_id, nullptr,
-                     gles2::Texture::UNBOUND, viz::GLInternalFormat(format),
-                     viz::GLDataFormat(format), viz::GLDataType(format),
-                     nullptr, is_cleared, format, size, gfx::ColorSpace(),
-                     usage, UnpackStateAttribs());
+  return MakeBacking(mailbox, target, service_id, image, image_state,
+                     internal_format, gl_format, gl_type, nullptr, true, format,
+                     size, color_space, usage);
 }
 
 scoped_refptr<gl::GLImage> SharedImageBackingFactoryGLTexture::MakeGLImage(
@@ -1023,7 +856,6 @@
 
 std::unique_ptr<SharedImageBacking>
 SharedImageBackingFactoryGLTexture::MakeBacking(
-    bool passthrough,
     const Mailbox& mailbox,
     GLenum target,
     GLuint service_id,
@@ -1037,9 +869,8 @@
     viz::ResourceFormat format,
     const gfx::Size& size,
     const gfx::ColorSpace& color_space,
-    uint32_t usage,
-    const UnpackStateAttribs& attribs) {
-  if (passthrough) {
+    uint32_t usage) {
+  if (use_passthrough_) {
     scoped_refptr<gles2::TexturePassthrough> passthrough_texture =
         base::MakeRefCounted<gles2::TexturePassthrough>(service_id, target);
     if (image)
@@ -1073,7 +904,7 @@
     texture->SetImmutable(true);
 
     return std::make_unique<SharedImageBackingGLTexture>(
-        mailbox, format, size, color_space, usage, texture, attribs);
+        mailbox, format, size, color_space, usage, texture);
   }
 }
 
--- a/gpu/command_buffer/service/shared_image_backing_factory_gl_texture.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/shared_image_backing_factory_gl_texture.h	2019-05-17 18:53:33.036000000 +0300
@@ -35,12 +35,6 @@
 class GPU_GLES2_EXPORT SharedImageBackingFactoryGLTexture
     : public SharedImageBackingFactory {
  public:
-  struct UnpackStateAttribs {
-    bool es3_capable = false;
-    bool desktop_gl = false;
-    bool supports_unpack_subimage = false;
-  };
-
   SharedImageBackingFactoryGLTexture(const GpuPreferences& gpu_preferences,
                                      const GpuDriverBugWorkarounds& workarounds,
                                      const GpuFeatureInfo& gpu_feature_info,
@@ -71,23 +65,13 @@
       const gfx::ColorSpace& color_space,
       uint32_t usage) override;
 
-  static std::unique_ptr<SharedImageBacking> CreateSharedImageForTest(
-      const Mailbox& mailbox,
-      GLenum target,
-      GLuint service_id,
-      bool is_cleared,
-      viz::ResourceFormat format,
-      const gfx::Size& size,
-      uint32_t usage);
-
  private:
   scoped_refptr<gl::GLImage> MakeGLImage(int client_id,
                                          gfx::GpuMemoryBufferHandle handle,
                                          gfx::BufferFormat format,
                                          SurfaceHandle surface_handle,
                                          const gfx::Size& size);
-  static std::unique_ptr<SharedImageBacking> MakeBacking(
-      bool passthrough,
+  std::unique_ptr<SharedImageBacking> MakeBacking(
       const Mailbox& mailbox,
       GLenum target,
       GLuint service_id,
@@ -101,9 +85,7 @@
       viz::ResourceFormat format,
       const gfx::Size& size,
       const gfx::ColorSpace& color_space,
-      uint32_t usage,
-      const UnpackStateAttribs& attribs);
-
+      uint32_t usage);
   struct FormatInfo {
     FormatInfo();
     ~FormatInfo();
@@ -153,7 +135,9 @@
   GpuMemoryBufferFormatSet gpu_memory_buffer_formats_;
   int32_t max_texture_size_ = 0;
   bool texture_usage_angle_ = false;
-  UnpackStateAttribs attribs;
+  bool es3_capable_ = false;
+  bool desktop_gl_ = false;
+  bool supports_unpack_subimage_ = false;
 };
 
 }  // namespace gpu
--- a/gpu/command_buffer/service/shared_image_backing_factory_gl_texture_unittest.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/shared_image_backing_factory_gl_texture_unittest.cc	2019-05-17 18:53:33.036000000 +0300
@@ -248,17 +248,6 @@
     EXPECT_EQ(color_space, gl_representation->color_space());
     EXPECT_EQ(usage, gl_representation->usage());
     gl_representation.reset();
-
-    auto gl_representation_rgb =
-        shared_image_representation_factory_->ProduceRGBEmulationGLTexture(
-            mailbox);
-    EXPECT_TRUE(gl_representation_rgb);
-    EXPECT_TRUE(gl_representation_rgb->GetTexture()->service_id());
-    EXPECT_EQ(size, gl_representation_rgb->size());
-    EXPECT_EQ(format, gl_representation_rgb->format());
-    EXPECT_EQ(color_space, gl_representation_rgb->color_space());
-    EXPECT_EQ(usage, gl_representation_rgb->usage());
-    gl_representation_rgb.reset();
   }
 
   // Next, validate a SharedImageRepresentationGLTexturePassthrough.
@@ -299,8 +288,7 @@
   shared_image.reset();
   EXPECT_FALSE(mailbox_manager_.ConsumeTexture(mailbox));
 
-  if (!use_passthrough() &&
-      context_state_->feature_info()->feature_flags().ext_texture_rg) {
+  if (!use_passthrough()) {
     // Create a R-8 image texture, and check that the internal_format is that of
     // the image (GL_RGBA for TextureImageFactory). This only matters for the
     // validating decoder.
@@ -538,31 +526,18 @@
     return InternalFormatForGpuMemoryBufferFormat(format_);
   }
 
-  BindOrCopy ShouldBindOrCopy() override { return BIND; }
-
   bool BindTexImage(unsigned target) override {
     if (!bound_) {
       bound_ = true;
       ++update_counter_;
     }
     return true;
-  }
-
-  bool BindTexImageWithInternalformat(unsigned target,
-                                      unsigned internal_format) override {
-    internal_format_ = internal_format;
-    if (!bound_) {
-      bound_ = true;
-      ++update_counter_;
-    }
-    return true;
-  }
+  };
 
   void ReleaseTexImage(unsigned target) override { bound_ = false; }
 
   bool bound() const { return bound_; }
   int update_counter() const { return update_counter_; }
-  unsigned internal_format() const { return internal_format_; }
 
  private:
   ~StubImage() override = default;
@@ -571,7 +546,6 @@
   gfx::BufferFormat format_;
   bool bound_ = false;
   int update_counter_ = 0;
-  unsigned internal_format_ = GL_RGBA;
 };
 
 class SharedImageBackingFactoryGLTextureWithGMBTest
@@ -690,50 +664,10 @@
   EXPECT_EQ(format, shm_image->format());
 }
 
-TEST_P(SharedImageBackingFactoryGLTextureWithGMBTest,
-       GpuMemoryBufferImportNative_WithRGBEmulation) {
-  if (use_passthrough())
-    return;
-  auto mailbox = Mailbox::GenerateForSharedImage();
-  gfx::Size size(256, 256);
-  gfx::BufferFormat format = gfx::BufferFormat::RGBA_8888;
-  auto color_space = gfx::ColorSpace::CreateSRGB();
-  uint32_t usage = SHARED_IMAGE_USAGE_GLES2;
-
-  gfx::GpuMemoryBufferHandle handle;
-  handle.type = gfx::NATIVE_PIXMAP;
-  auto backing = backing_factory_->CreateSharedImage(
-      mailbox, kClientId, std::move(handle), format, kNullSurfaceHandle, size,
-      color_space, usage);
-  ASSERT_TRUE(backing);
-
-  std::unique_ptr<SharedImageRepresentationFactoryRef> ref =
-      shared_image_manager_.Register(std::move(backing),
-                                     memory_type_tracker_.get());
-
-  auto representation =
-      shared_image_representation_factory_->ProduceRGBEmulationGLTexture(
-          mailbox);
-  EXPECT_TRUE(representation);
-  EXPECT_TRUE(representation->GetTexture()->service_id());
-  EXPECT_EQ(size, representation->size());
-  EXPECT_EQ(viz::ResourceFormat::RGBA_8888, representation->format());
-  EXPECT_EQ(color_space, representation->color_space());
-  EXPECT_EQ(usage, representation->usage());
-
-  scoped_refptr<gl::GLImage> image =
-      representation->GetTexture()->GetLevelImage(GL_TEXTURE_2D, 0);
-  ASSERT_EQ(image->GetType(), gl::GLImage::Type::NONE);
-  auto* stub_image = static_cast<StubImage*>(image.get());
-  EXPECT_EQ(stub_image->internal_format(), (unsigned)GL_RGB);
-  EXPECT_TRUE(stub_image->bound());
-  EXPECT_EQ(stub_image->update_counter(), 1);
-}
-
-INSTANTIATE_TEST_SUITE_P(Service,
+INSTANTIATE_TEST_CASE_P(Service,
                          SharedImageBackingFactoryGLTextureTest,
                          ::testing::Bool());
-INSTANTIATE_TEST_SUITE_P(Service,
+INSTANTIATE_TEST_CASE_P(Service,
                          SharedImageBackingFactoryGLTextureWithGMBTest,
                          ::testing::Bool());
 
--- a/gpu/command_buffer/service/shared_image_backing.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/shared_image_backing.h	2019-05-17 18:53:33.032000000 +0300
@@ -85,9 +85,6 @@
   virtual std::unique_ptr<SharedImageRepresentationGLTexture> ProduceGLTexture(
       SharedImageManager* manager,
       MemoryTypeTracker* tracker);
-  virtual std::unique_ptr<SharedImageRepresentationGLTexture>
-  ProduceRGBEmulationGLTexture(SharedImageManager* manager,
-                               MemoryTypeTracker* tracker);
   virtual std::unique_ptr<SharedImageRepresentationGLTexturePassthrough>
   ProduceGLTexturePassthrough(SharedImageManager* manager,
                               MemoryTypeTracker* tracker);
--- a/gpu/command_buffer/service/shared_image_factory.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/shared_image_factory.cc	2019-05-17 18:53:33.036000000 +0300
@@ -8,7 +8,6 @@
 
 #include "base/strings/stringprintf.h"
 #include "base/trace_event/memory_dump_manager.h"
-#include "build/build_config.h"
 #include "components/viz/common/resources/resource_format_utils.h"
 #include "gpu/command_buffer/common/gpu_memory_buffer_support.h"
 #include "gpu/command_buffer/common/shared_image_trace_utils.h"
@@ -26,14 +25,6 @@
 #include "gpu/config/gpu_preferences.h"
 #include "ui/gl/trace_util.h"
 
-#if defined(USE_X11) && BUILDFLAG(ENABLE_VULKAN)
-#include "gpu/command_buffer/service/external_vk_image_factory.h"
-#elif defined(OS_ANDROID) && BUILDFLAG(ENABLE_VULKAN)
-#include "gpu/command_buffer/service/shared_image_backing_factory_ahardwarebuffer.h"
-#elif defined(OS_MACOSX)
-#include "gpu/command_buffer/service/shared_image_backing_factory_iosurface.h"
-#endif
-
 namespace gpu {
 // Overrides for flat_set lookups:
 bool operator<(
@@ -71,25 +62,10 @@
                                                                workarounds,
                                                                gpu_feature_info,
                                                                image_factory)),
-#if defined(USE_X11) && BUILDFLAG(ENABLE_VULKAN)
-      interop_backing_factory_(
-          std::make_unique<ExternalVkImageFactory>(context_state)),
-#elif defined(OS_ANDROID) && BUILDFLAG(ENABLE_VULKAN)
-      interop_backing_factory_(
-          std::make_unique<SharedImageBackingFactoryAHB>(workarounds,
-                                                         gpu_feature_info,
-                                                         context_state)),
-#elif defined(OS_MACOSX)
-      interop_backing_factory_(
-          std::make_unique<SharedImageBackingFactoryIOSurface>(
-              workarounds,
-              gpu_feature_info)),
-#endif
       wrapped_sk_image_factory_(
           gpu_preferences.enable_raster_to_sk_image
               ? std::make_unique<raster::WrappedSkImageFactory>(context_state)
-              : nullptr) {
-}
+              : nullptr) {}
 
 SharedImageFactory::~SharedImageFactory() {
   DCHECK(shared_images_.empty());
@@ -100,47 +76,18 @@
                                            const gfx::Size& size,
                                            const gfx::ColorSpace& color_space,
                                            uint32_t usage) {
-  if (using_vulkan_ && (usage & SHARED_IMAGE_USAGE_GLES2) &&
-      (usage & SHARED_IMAGE_USAGE_OOP_RASTERIZATION)) {
-    // TODO(crbug.com/932214): The interop backings don't currently support
-    // Vulkan writes so they cannot be used for OOP-R.
-    LOG(ERROR) << "Bad SharedImage usage combination: "
-               << "SHARED_IMAGE_USAGE_GLES2 | "
-               << "SHARED_IMAGE_USAGE_OOP_RASTERIZATION";
-    return false;
-  }
   std::unique_ptr<SharedImageBacking> backing;
   bool using_wrapped_sk_image = wrapped_sk_image_factory_ &&
                                 (usage & SHARED_IMAGE_USAGE_OOP_RASTERIZATION);
-  // If |shared_image_manager_| is thread safe, it means the display is running
-  // on a separate thread (which uses a separate GL context or VkDeviceQueue).
-  bool share_between_threads = shared_image_manager_->is_thread_safe() &&
-                               (usage & SHARED_IMAGE_USAGE_DISPLAY);
-  bool share_between_gl_vulkan = using_vulkan_ &&
-                                 (usage & SHARED_IMAGE_USAGE_GLES2) &&
-                                 (usage & SHARED_IMAGE_USAGE_DISPLAY);
-  bool using_interop_factory = share_between_threads || share_between_gl_vulkan;
-  // TODO(penghuang): make sure all shared image are created with correct usage.
-  // https://crbug.com/937480
-  // using_interop_factory = shared_image_manager_->is_thread_safe();
   if (using_wrapped_sk_image) {
     backing = wrapped_sk_image_factory_->CreateSharedImage(
         mailbox, format, size, color_space, usage);
-  } else if (using_interop_factory) {
-    if (!interop_backing_factory_) {
-      LOG(ERROR) << "Unable to create SharedImage backing: GL / Vulkan "
-                 << "interoperability is not supported on this platform";
-      return false;
-    }
-    backing = interop_backing_factory_->CreateSharedImage(mailbox, format, size,
-                                                          color_space, usage);
   } else {
     backing = backing_factory_->CreateSharedImage(mailbox, format, size,
                                                   color_space, usage);
   }
 
-  return RegisterBacking(std::move(backing),
-                         !using_wrapped_sk_image && !using_interop_factory);
+  return RegisterBacking(std::move(backing), !using_wrapped_sk_image);
 }
 
 bool SharedImageFactory::CreateSharedImage(const Mailbox& mailbox,
@@ -267,12 +214,6 @@
   return manager_->ProduceGLTexture(mailbox, tracker_.get());
 }
 
-std::unique_ptr<SharedImageRepresentationGLTexture>
-SharedImageRepresentationFactory::ProduceRGBEmulationGLTexture(
-    const Mailbox& mailbox) {
-  return manager_->ProduceRGBEmulationGLTexture(mailbox, tracker_.get());
-}
-
 std::unique_ptr<SharedImageRepresentationGLTexturePassthrough>
 SharedImageRepresentationFactory::ProduceGLTexturePassthrough(
     const Mailbox& mailbox) {
--- a/gpu/command_buffer/service/shared_image_factory.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/shared_image_factory.h	2019-05-17 18:53:33.036000000 +0300
@@ -92,8 +92,6 @@
   // eventually.
   std::unique_ptr<SharedImageBackingFactory> backing_factory_;
 
-  std::unique_ptr<SharedImageBackingFactory> interop_backing_factory_;
-
   // Non-null if gpu_preferences.enable_raster_to_sk_image.
   std::unique_ptr<raster::WrappedSkImageFactory> wrapped_sk_image_factory_;
 };
@@ -108,8 +106,6 @@
   // MemoryTypeTracker.
   std::unique_ptr<SharedImageRepresentationGLTexture> ProduceGLTexture(
       const Mailbox& mailbox);
-  std::unique_ptr<SharedImageRepresentationGLTexture>
-  ProduceRGBEmulationGLTexture(const Mailbox& mailbox);
   std::unique_ptr<SharedImageRepresentationGLTexturePassthrough>
   ProduceGLTexturePassthrough(const Mailbox& mailbox);
   std::unique_ptr<SharedImageRepresentationSkia> ProduceSkia(
--- a/gpu/command_buffer/service/shared_image_manager.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/shared_image_manager.cc	2019-05-17 18:53:33.036000000 +0300
@@ -3,30 +3,18 @@
 // found in the LICENSE file.
 
 #include "gpu/command_buffer/service/shared_image_manager.h"
+#include "gpu/command_buffer/service/shared_image_representation.h"
 
 #include <inttypes.h>
 
-#include <utility>
-
 #include "base/logging.h"
 #include "base/strings/stringprintf.h"
 #include "base/trace_event/memory_dump_manager.h"
 #include "base/trace_event/process_memory_dump.h"
 #include "base/trace_event/trace_event.h"
 #include "gpu/command_buffer/common/shared_image_trace_utils.h"
-#include "gpu/command_buffer/service/shared_image_representation.h"
 #include "ui/gl/trace_util.h"
 
-#if DCHECK_IS_ON()
-#define CALLED_ON_VALID_THREAD()                      \
-  do {                                                \
-    if (!this->is_thread_safe())                      \
-      DCHECK_CALLED_ON_VALID_THREAD(thread_checker_); \
-  } while (false)
-#else
-#define CALLED_ON_VALID_THREAD()
-#endif
-
 namespace gpu {
 // Overrides for flat_set lookups:
 bool operator<(const std::unique_ptr<SharedImageBacking>& lhs,
@@ -44,45 +32,18 @@
   return lhs->mailbox() < rhs;
 }
 
-class SharedImageManager::AutoLock {
- public:
-  explicit AutoLock(SharedImageManager* manager) {
-    if (manager->is_thread_safe())
-      auto_lock_.emplace(manager->lock_.value());
-  }
-  ~AutoLock() = default;
-
- private:
-  base::Optional<base::AutoLock> auto_lock_;
-
-  DISALLOW_COPY_AND_ASSIGN(AutoLock);
-};
-
-SharedImageManager::SharedImageManager(bool thread_safe) {
-  if (thread_safe)
-    lock_.emplace();
-  CALLED_ON_VALID_THREAD();
-}
+SharedImageManager::SharedImageManager() = default;
 
 SharedImageManager::~SharedImageManager() {
-  CALLED_ON_VALID_THREAD();
-#if DCHECK_IS_ON()
-  AutoLock auto_lock(this);
-#endif
   DCHECK(images_.empty());
 }
 
 std::unique_ptr<SharedImageRepresentationFactoryRef>
 SharedImageManager::Register(std::unique_ptr<SharedImageBacking> backing,
                              MemoryTypeTracker* tracker) {
-  CALLED_ON_VALID_THREAD();
   DCHECK(backing->mailbox().IsSharedImage());
-
-  AutoLock autolock(this);
-  const auto lower_bound = images_.lower_bound(backing->mailbox());
-  if (lower_bound != images_.end() &&
-      (*lower_bound)->mailbox() == backing->mailbox()) {
-    LOG(ERROR) << "SharedImageManager::Register: Trying to register an "
+  if (images_.find(backing->mailbox()) != images_.end()) {
+    LOG(ERROR) << "ShraedImageManager::Register: Trying to register an "
                   "already registered mailbox.";
     backing->Destroy();
     return nullptr;
@@ -87,17 +48,13 @@
     backing->Destroy();
     return nullptr;
   }
-
   auto factory_ref = std::make_unique<SharedImageRepresentationFactoryRef>(
       this, backing.get(), tracker);
-  images_.emplace_hint(lower_bound, std::move(backing));
+  images_.emplace(std::move(backing));
   return factory_ref;
 }
 
 void SharedImageManager::OnContextLost(const Mailbox& mailbox) {
-  CALLED_ON_VALID_THREAD();
-
-  AutoLock autolock(this);
   auto found = images_.find(mailbox);
   if (found == images_.end()) {
     LOG(ERROR) << "SharedImageManager::OnContextLost: Trying to mark constext "
@@ -104,15 +61,13 @@
                   "lost on a non existent mailbox.";
     return;
   }
+
   (*found)->OnContextLost();
 }
 
 std::unique_ptr<SharedImageRepresentationGLTexture>
 SharedImageManager::ProduceGLTexture(const Mailbox& mailbox,
                                      MemoryTypeTracker* tracker) {
-  CALLED_ON_VALID_THREAD();
-
-  AutoLock autolock(this);
   auto found = images_.find(mailbox);
   if (found == images_.end()) {
     LOG(ERROR) << "SharedImageManager::ProduceGLTexture: Trying to produce a "
@@ -130,32 +85,9 @@
   return representation;
 }
 
-std::unique_ptr<SharedImageRepresentationGLTexture>
-SharedImageManager::ProduceRGBEmulationGLTexture(const Mailbox& mailbox,
-                                                 MemoryTypeTracker* tracker) {
-  auto found = images_.find(mailbox);
-  if (found == images_.end()) {
-    LOG(ERROR) << "SharedImageManager::ProduceRGBEmulationGLTexture: Trying to "
-                  "produce a representation from a non-existent mailbox.";
-    return nullptr;
-  }
-
-  auto representation = (*found)->ProduceRGBEmulationGLTexture(this, tracker);
-  if (!representation) {
-    LOG(ERROR) << "SharedImageManager::ProduceRGBEmulationGLTexture: Trying to "
-                  "produce a representation from an incompatible mailbox.";
-    return nullptr;
-  }
-
-  return representation;
-}
-
 std::unique_ptr<SharedImageRepresentationGLTexturePassthrough>
 SharedImageManager::ProduceGLTexturePassthrough(const Mailbox& mailbox,
                                                 MemoryTypeTracker* tracker) {
-  CALLED_ON_VALID_THREAD();
-
-  AutoLock autolock(this);
   auto found = images_.find(mailbox);
   if (found == images_.end()) {
     LOG(ERROR) << "SharedImageManager::ProduceGLTexturePassthrough: Trying to "
@@ -176,9 +108,6 @@
 std::unique_ptr<SharedImageRepresentationSkia> SharedImageManager::ProduceSkia(
     const Mailbox& mailbox,
     MemoryTypeTracker* tracker) {
-  CALLED_ON_VALID_THREAD();
-
-  AutoLock autolock(this);
   auto found = images_.find(mailbox);
   if (found == images_.end()) {
     LOG(ERROR) << "SharedImageManager::ProduceSkia: Trying to Produce a "
@@ -199,9 +128,6 @@
 void SharedImageManager::OnRepresentationDestroyed(
     const Mailbox& mailbox,
     SharedImageRepresentation* representation) {
-  CALLED_ON_VALID_THREAD();
-
-  AutoLock autolock(this);
   auto found = images_.find(mailbox);
   if (found == images_.end()) {
     LOG(ERROR) << "SharedImageManager::OnRepresentationDestroyed: Trying to "
@@ -223,9 +149,6 @@
                                       base::trace_event::ProcessMemoryDump* pmd,
                                       int client_id,
                                       uint64_t client_tracing_id) {
-  CALLED_ON_VALID_THREAD();
-
-  AutoLock autolock(this);
   auto found = images_.find(mailbox);
   if (found == images_.end()) {
     LOG(ERROR) << "SharedImageManager::OnMemoryDump: Trying to dump memory for "
--- a/gpu/command_buffer/service/shared_image_manager.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/shared_image_manager.h	2019-05-17 18:53:33.036000000 +0300
@@ -6,9 +6,6 @@
 #define GPU_COMMAND_BUFFER_SERVICE_SHARED_IMAGE_MANAGER_H_
 
 #include "base/containers/flat_set.h"
-#include "base/optional.h"
-#include "base/synchronization/lock.h"
-#include "base/threading/thread_checker.h"
 #include "gpu/command_buffer/common/mailbox.h"
 #include "gpu/command_buffer/service/shared_image_backing.h"
 #include "gpu/gpu_gles2_export.h"
@@ -18,7 +15,7 @@
 
 class GPU_GLES2_EXPORT SharedImageManager {
  public:
-  explicit SharedImageManager(bool thread_safe = false);
+  SharedImageManager();
   ~SharedImageManager();
 
   // Registers a SharedImageBacking with the manager and returns a
@@ -37,8 +34,6 @@
   std::unique_ptr<SharedImageRepresentationGLTexture> ProduceGLTexture(
       const Mailbox& mailbox,
       MemoryTypeTracker* ref);
-  std::unique_ptr<SharedImageRepresentationGLTexture>
-  ProduceRGBEmulationGLTexture(const Mailbox& mailbox, MemoryTypeTracker* ref);
   std::unique_ptr<SharedImageRepresentationGLTexturePassthrough>
   ProduceGLTexturePassthrough(const Mailbox& mailbox, MemoryTypeTracker* ref);
   std::unique_ptr<SharedImageRepresentationSkia> ProduceSkia(
@@ -55,17 +50,9 @@
                     int client_id,
                     uint64_t client_tracing_id);
 
-  bool is_thread_safe() const { return !!lock_; }
-
  private:
-  class AutoLock;
-  // The lock for protecting |images_|.
-  base::Optional<base::Lock> lock_;
-
   base::flat_set<std::unique_ptr<SharedImageBacking>> images_;
 
-  THREAD_CHECKER(thread_checker_);
-
   DISALLOW_COPY_AND_ASSIGN(SharedImageManager);
 };
 
--- a/gpu/command_buffer/service/shared_image_representation.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/shared_image_representation.h	2019-05-17 18:53:33.036000000 +0300
@@ -43,20 +43,15 @@
 
   // Indicates that the underlying graphics context has been lost, and the
   // backing should be treated as destroyed.
-  void OnContextLost() {
-    has_context_ = false;
-    backing_->OnContextLost();
-  }
+  void OnContextLost() { backing_->OnContextLost(); }
 
  protected:
   SharedImageBacking* backing() const { return backing_; }
-  bool has_context() const { return has_context_; }
 
  private:
   SharedImageManager* manager_;
   SharedImageBacking* backing_;
   MemoryTypeTracker* tracker_;
-  bool has_context_ = true;
 };
 
 class SharedImageRepresentationFactoryRef : public SharedImageRepresentation {
@@ -76,24 +71,6 @@
 class GPU_GLES2_EXPORT SharedImageRepresentationGLTexture
     : public SharedImageRepresentation {
  public:
-  class ScopedAccess {
-   public:
-    ScopedAccess(SharedImageRepresentationGLTexture* representation,
-                 GLenum mode)
-        : representation_(representation),
-          success_(representation_->BeginAccess(mode)) {}
-    ~ScopedAccess() {
-      if (success_)
-        representation_->EndAccess();
-    }
-
-    bool success() const { return success_; }
-
-   private:
-    SharedImageRepresentationGLTexture* representation_;
-    bool success_;
-  };
-
   SharedImageRepresentationGLTexture(SharedImageManager* manager,
                                      SharedImageBacking* backing,
                                      MemoryTypeTracker* tracker)
@@ -110,24 +87,6 @@
 class GPU_GLES2_EXPORT SharedImageRepresentationGLTexturePassthrough
     : public SharedImageRepresentation {
  public:
-  class ScopedAccess {
-   public:
-    ScopedAccess(SharedImageRepresentationGLTexturePassthrough* representation,
-                 GLenum mode)
-        : representation_(representation),
-          success_(representation_->BeginAccess(mode)) {}
-    ~ScopedAccess() {
-      if (success_)
-        representation_->EndAccess();
-    }
-
-    bool success() const { return success_; }
-
-   private:
-    SharedImageRepresentationGLTexturePassthrough* representation_;
-    bool success_;
-  };
-
   SharedImageRepresentationGLTexturePassthrough(SharedImageManager* manager,
                                                 SharedImageBacking* backing,
                                                 MemoryTypeTracker* tracker)
--- a/gpu/command_buffer/service/test_helper.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/test_helper.cc	2019-05-17 18:53:33.036000000 +0300
@@ -919,7 +919,7 @@
         }
         for (GLsizei jj = 1; jj < info.size; ++jj) {
           std::string element_name(std::string(base_name) + "[" +
-                                   base::NumberToString(jj) + "]");
+                                   base::IntToString(jj) + "]");
           EXPECT_CALL(*gl, GetUniformLocation(service_id, StrEq(element_name)))
               .WillOnce(Return(info.real_location + jj * 2))
               .RetiresOnSaturation();
--- a/gpu/command_buffer/service/texture_definition.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/texture_definition.cc	2019-05-17 18:53:33.036000000 +0300
@@ -34,7 +34,6 @@
   // Implement GLImage.
   gfx::Size GetSize() override;
   unsigned GetInternalFormat() override;
-  BindOrCopy ShouldBindOrCopy() override;
   bool BindTexImage(unsigned target) override;
   void ReleaseTexImage(unsigned target) override;
   bool CopyTexImage(unsigned target) override;
@@ -84,10 +83,6 @@
   return GL_RGBA;
 }
 
-GLImageSync::BindOrCopy GLImageSync::ShouldBindOrCopy() {
-  return BIND;
-}
-
 bool GLImageSync::BindTexImage(unsigned target) {
   NOTREACHED();
   return false;
--- a/gpu/command_buffer/service/texture_manager.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/texture_manager.cc	2019-05-17 18:53:33.040000000 +0300
@@ -2068,7 +2068,6 @@
       GL_TEXTURE_CUBE_MAP, &black_texture_ids_[kCubeMap]);
 
   if (feature_info_->IsWebGL2OrES3Context()) {
-    DCHECK(feature_info_->IsES3Capable());
     default_textures_[kTexture3D] = CreateDefaultAndBlackTextures(
         GL_TEXTURE_3D, &black_texture_ids_[kTexture3D]);
     default_textures_[kTexture2DArray] = CreateDefaultAndBlackTextures(
@@ -2200,7 +2199,6 @@
   return ref->texture()->ClearRenderableLevels(decoder);
 }
 
-// static
 bool TextureManager::ClearTextureLevel(DecoderContext* decoder,
                                        TextureRef* ref,
                                        GLenum target,
@@ -2210,7 +2208,6 @@
   return ClearTextureLevel(decoder, texture, target, level);
 }
 
-// static
 bool TextureManager::ClearTextureLevel(DecoderContext* decoder,
                                        Texture* texture,
                                        GLenum target,
--- a/gpu/command_buffer/service/texture_manager.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/texture_manager.h	2019-05-17 18:53:33.040000000 +0300
@@ -34,18 +34,11 @@
 
 namespace gpu {
 class DecoderContext;
-class ExternalVkImageBacking;
-class ExternalVkImageGlRepresentation;
 class ServiceDiscardableManager;
 class SharedImageBackingGLTexture;
 class SharedImageBackingFactoryGLTexture;
 class SharedImageBackingAHB;
 class SharedImageRepresentationGLTexture;
-class SharedImageRepresentationGLTextureAHB;
-class SharedImageRepresentationSkiaGLAHB;
-class SharedImageBackingIOSurface;
-class SharedImageRepresentationGLTextureIOSurface;
-class SharedImageRepresentationSkiaIOSurface;
 
 namespace gles2 {
 class GLStreamTextureImage;
@@ -371,16 +364,9 @@
  private:
   friend class MailboxManagerSync;
   friend class MailboxManagerTest;
-  friend class gpu::ExternalVkImageBacking;
-  friend class gpu::ExternalVkImageGlRepresentation;
   friend class gpu::SharedImageBackingGLTexture;
   friend class gpu::SharedImageBackingFactoryGLTexture;
   friend class gpu::SharedImageBackingAHB;
-  friend class gpu::SharedImageRepresentationGLTextureAHB;
-  friend class gpu::SharedImageRepresentationSkiaGLAHB;
-  friend class gpu::SharedImageBackingIOSurface;
-  friend class gpu::SharedImageRepresentationGLTextureIOSurface;
-  friend class gpu::SharedImageRepresentationSkiaIOSurface;
   friend class TextureDefinition;
   friend class TextureManager;
   friend class TextureRef;
@@ -949,12 +935,12 @@
   bool ClearRenderableLevels(DecoderContext* decoder, TextureRef* ref);
 
   // Clear a specific level.
-  static bool ClearTextureLevel(DecoderContext* decoder,
+  bool ClearTextureLevel(DecoderContext* decoder,
                                 TextureRef* ref,
                                 GLenum target,
                                 GLint level);
 
-  static bool ClearTextureLevel(DecoderContext* decoder,
+  bool ClearTextureLevel(DecoderContext* decoder,
                                 Texture* texture,
                                 GLenum target,
                                 GLint level);
--- a/gpu/command_buffer/service/texture_manager_unittest.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/texture_manager_unittest.cc	2019-05-17 18:53:33.040000000 +0300
@@ -2134,7 +2134,7 @@
 static const GLenum kTextureTargets[] = {GL_TEXTURE_2D, GL_TEXTURE_EXTERNAL_OES,
                                          GL_TEXTURE_RECTANGLE_ARB, };
 
-INSTANTIATE_TEST_SUITE_P(Target,
+INSTANTIATE_TEST_CASE_P(Target,
                          ProduceConsumeTextureTest,
                          ::testing::ValuesIn(kTextureTargets));
 
--- a/gpu/command_buffer/service/transform_feedback_manager.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/transform_feedback_manager.cc	2019-05-17 18:53:33.040000000 +0300
@@ -17,8 +17,7 @@
     : IndexedBufferBindingHost(
           manager->max_transform_feedback_separate_attribs(),
           GL_TRANSFORM_FEEDBACK_BUFFER,
-          manager->needs_emulation(),
-          false),
+          manager->needs_emulation()),
       manager_(manager),
       client_id_(client_id),
       service_id_(service_id),
--- a/gpu/command_buffer/service/vertex_attrib_manager.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/vertex_attrib_manager.cc	2019-05-17 18:53:33.040000000 +0300
@@ -287,8 +287,7 @@
             error_state, GL_INVALID_OPERATION, function_name,
             (std::string(
                  "attempt to access out of range vertices in attribute ") +
-             base::NumberToString(attrib->index()))
-                .c_str());
+             base::UintToString(attrib->index())).c_str());
         return false;
       }
       if (use_client_side_arrays_for_stream_buffers) {
--- a/gpu/command_buffer/service/webgpu_decoder.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/webgpu_decoder.cc	2019-05-17 18:53:33.040000000 +0300
@@ -4,17 +4,251 @@
 
 #include "gpu/command_buffer/service/webgpu_decoder.h"
 
-#include "gpu/command_buffer/service/webgpu_decoder_impl.h"
+#include "base/macros.h"
+#include "gpu/command_buffer/common/webgpu_cmd_format.h"
+#include "gpu/command_buffer/common/webgpu_cmd_ids.h"
+#include "gpu/command_buffer/service/command_buffer_service.h"
 
 namespace gpu {
 namespace webgpu {
 
+class WebGPUDecoderImpl final : public WebGPUDecoder {
+ public:
+  WebGPUDecoderImpl(DecoderClient* client,
+                    CommandBufferServiceBase* command_buffer_service,
+                    gles2::Outputter* outputter);
+  ~WebGPUDecoderImpl() override;
+
+  // DecoderContext implementation.
+  base::WeakPtr<DecoderContext> AsWeakPtr() override {
+    NOTIMPLEMENTED();
+    return nullptr;
+  }
+  ContextResult Initialize(
+      const scoped_refptr<gl::GLSurface>& surface,
+      const scoped_refptr<gl::GLContext>& context,
+      bool offscreen,
+      const gles2::DisallowedFeatures& disallowed_features,
+      const ContextCreationAttribs& attrib_helper) override {
+    return ContextResult::kSuccess;
+  }
+  const gles2::ContextState* GetContextState() override {
+    NOTREACHED();
+    return nullptr;
+  }
+  void Destroy(bool have_context) override {}
+  bool MakeCurrent() override { return true; }
+  gl::GLContext* GetGLContext() override { return nullptr; }
+  gl::GLSurface* GetGLSurface() override {
+    NOTREACHED();
+    return nullptr;
+  }
+  const gles2::FeatureInfo* GetFeatureInfo() const override {
+    NOTREACHED();
+    return nullptr;
+  }
+  Capabilities GetCapabilities() override { return {}; }
+  void RestoreGlobalState() const override { NOTREACHED(); }
+  void ClearAllAttributes() const override { NOTREACHED(); }
+  void RestoreAllAttributes() const override { NOTREACHED(); }
+  void RestoreState(const gles2::ContextState* prev_state) override {
+    NOTREACHED();
+  }
+  void RestoreActiveTexture() const override { NOTREACHED(); }
+  void RestoreAllTextureUnitAndSamplerBindings(
+      const gles2::ContextState* prev_state) const override {
+    NOTREACHED();
+  }
+  void RestoreActiveTextureUnitBinding(unsigned int target) const override {
+    NOTREACHED();
+  }
+  void RestoreBufferBinding(unsigned int target) override { NOTREACHED(); }
+  void RestoreBufferBindings() const override { NOTREACHED(); }
+  void RestoreFramebufferBindings() const override { NOTREACHED(); }
+  void RestoreRenderbufferBindings() override { NOTREACHED(); }
+  void RestoreProgramBindings() const override { NOTREACHED(); }
+  void RestoreTextureState(unsigned service_id) override { NOTREACHED(); }
+  void RestoreTextureUnitBindings(unsigned unit) const override {
+    NOTREACHED();
+  }
+  void RestoreVertexAttribArray(unsigned index) override { NOTREACHED(); }
+  void RestoreAllExternalTextureBindingsIfNeeded() override { NOTREACHED(); }
+  QueryManager* GetQueryManager() override {
+    NOTREACHED();
+    return nullptr;
+  }
+  void SetQueryCallback(unsigned int query_client_id,
+                        base::OnceClosure callback) override {
+    NOTREACHED();
+  }
+  gles2::GpuFenceManager* GetGpuFenceManager() override {
+    NOTREACHED();
+    return nullptr;
+  }
+  bool HasPendingQueries() const override { return false; }
+  void ProcessPendingQueries(bool did_finish) override {}
+  bool HasMoreIdleWork() const override { return false; }
+  void PerformIdleWork() override { NOTREACHED(); }
+  bool HasPollingWork() const override { return false; }
+  void PerformPollingWork() override { NOTREACHED(); }
+  TextureBase* GetTextureBase(uint32_t client_id) override {
+    NOTREACHED();
+    return nullptr;
+  }
+  void SetLevelInfo(uint32_t client_id,
+                    int level,
+                    unsigned internal_format,
+                    unsigned width,
+                    unsigned height,
+                    unsigned depth,
+                    unsigned format,
+                    unsigned type,
+                    const gfx::Rect& cleared_rect) override {
+    NOTREACHED();
+  }
+  bool WasContextLost() const override {
+    NOTIMPLEMENTED();
+    return false;
+  }
+  bool WasContextLostByRobustnessExtension() const override {
+    NOTREACHED();
+    return false;
+  }
+  void MarkContextLost(error::ContextLostReason reason) override {
+    NOTIMPLEMENTED();
+  }
+  bool CheckResetStatus() override {
+    NOTREACHED();
+    return false;
+  }
+  void BeginDecoding() override {}
+  void EndDecoding() override {}
+  const char* GetCommandName(unsigned int command_id) const;
+  error::Error DoCommands(unsigned int num_commands,
+                          const volatile void* buffer,
+                          int num_entries,
+                          int* entries_processed) override;
+  base::StringPiece GetLogPrefix() override {
+    NOTIMPLEMENTED();
+    return "";
+  }
+  void BindImage(uint32_t client_texture_id,
+                 uint32_t texture_target,
+                 gl::GLImage* image,
+                 bool can_bind_to_sampler) override {
+    NOTREACHED();
+  }
+  gles2::ContextGroup* GetContextGroup() override {
+    NOTREACHED();
+    return nullptr;
+  }
+  gles2::ErrorState* GetErrorState() override {
+    NOTREACHED();
+    return nullptr;
+  }
+  std::unique_ptr<gles2::AbstractTexture> CreateAbstractTexture(
+      GLenum target,
+      GLenum internal_format,
+      GLsizei width,
+      GLsizei height,
+      GLsizei depth,
+      GLint border,
+      GLenum format,
+      GLenum type) override {
+    NOTREACHED();
+    return nullptr;
+  }
+  bool IsCompressedTextureFormat(unsigned format) override {
+    NOTREACHED();
+    return false;
+  }
+  bool ClearLevel(gles2::Texture* texture,
+                  unsigned target,
+                  int level,
+                  unsigned format,
+                  unsigned type,
+                  int xoffset,
+                  int yoffset,
+                  int width,
+                  int height) override {
+    NOTREACHED();
+    return false;
+  }
+  bool ClearCompressedTextureLevel(gles2::Texture* texture,
+                                   unsigned target,
+                                   int level,
+                                   unsigned format,
+                                   int width,
+                                   int height) override {
+    NOTREACHED();
+    return false;
+  }
+  bool ClearLevel3D(gles2::Texture* texture,
+                    unsigned target,
+                    int level,
+                    unsigned format,
+                    unsigned type,
+                    int width,
+                    int height,
+                    int depth) override {
+    NOTREACHED();
+    return false;
+  }
+  bool initialized() const override { return true; }
+  void SetLogCommands(bool log_commands) override { NOTIMPLEMENTED(); }
+  gles2::Outputter* outputter() const override {
+    NOTIMPLEMENTED();
+    return nullptr;
+  }
+
+ private:
+  typedef error::Error (WebGPUDecoderImpl::*CmdHandler)(
+      uint32_t immediate_data_size,
+      const volatile void* data);
+
+  // A struct to hold info about each command.
+  struct CommandInfo {
+    CmdHandler cmd_handler;
+    uint8_t arg_flags;   // How to handle the arguments for this command
+    uint8_t cmd_flags;   // How to handle this command
+    uint16_t arg_count;  // How many arguments are expected for this command.
+  };
+
+  // A table of CommandInfo for all the commands.
+  static const CommandInfo command_info[kNumCommands - kFirstWebGPUCommand];
+
+// Generate a member function prototype for each command in an automated and
+// typesafe way.
+#define WEBGPU_CMD_OP(name) \
+  Error Handle##name(uint32_t immediate_data_size, const volatile void* data);
+  WEBGPU_COMMAND_LIST(WEBGPU_CMD_OP)
+#undef WEBGPU_CMD_OP
+
+  // The current decoder error communicates the decoder error through command
+  // processing functions that do not return the error value. Should be set
+  // only if not returning an error.
+  error::Error current_decoder_error_ = error::kNoError;
+
+  DISALLOW_COPY_AND_ASSIGN(WebGPUDecoderImpl);
+};
+
+constexpr WebGPUDecoderImpl::CommandInfo WebGPUDecoderImpl::command_info[] = {
+#define WEBGPU_CMD_OP(name)                                    \
+  {                                                            \
+      &WebGPUDecoderImpl::Handle##name, cmds::name::kArgFlags, \
+      cmds::name::cmd_flags,                                   \
+      sizeof(cmds::name) / sizeof(CommandBufferEntry) - 1,     \
+  }, /* NOLINT */
+    WEBGPU_COMMAND_LIST(WEBGPU_CMD_OP)
+#undef WEBGPU_CMD_OP
+};
+
 // static
 WebGPUDecoder* WebGPUDecoder::Create(
     DecoderClient* client,
     CommandBufferServiceBase* command_buffer_service,
     gles2::Outputter* outputter) {
-  return CreateWebGPUDecoderImpl(client, command_buffer_service, outputter);
+  return new WebGPUDecoderImpl(client, command_buffer_service, outputter);
 }
 
 WebGPUDecoder::WebGPUDecoder(DecoderClient* client,
@@ -24,5 +258,92 @@
 
 WebGPUDecoder::~WebGPUDecoder() {}
 
+WebGPUDecoderImpl::WebGPUDecoderImpl(
+    DecoderClient* client,
+    CommandBufferServiceBase* command_buffer_service,
+    gles2::Outputter* outputter)
+    : WebGPUDecoder(client, command_buffer_service, outputter) {}
+
+WebGPUDecoderImpl::~WebGPUDecoderImpl() {}
+
+const char* WebGPUDecoderImpl::GetCommandName(unsigned int command_id) const {
+  if (command_id >= kFirstWebGPUCommand && command_id < kNumCommands) {
+    return webgpu::GetCommandName(static_cast<CommandId>(command_id));
+  }
+  return GetCommonCommandName(static_cast<cmd::CommandId>(command_id));
+}
+
+error::Error WebGPUDecoderImpl::DoCommands(unsigned int num_commands,
+                                           const volatile void* buffer,
+                                           int num_entries,
+                                           int* entries_processed) {
+  DCHECK(entries_processed);
+  int commands_to_process = num_commands;
+  error::Error result = error::kNoError;
+  const volatile CommandBufferEntry* cmd_data =
+      static_cast<const volatile CommandBufferEntry*>(buffer);
+  int process_pos = 0;
+  CommandId command = static_cast<CommandId>(0);
+
+  while (process_pos < num_entries && result == error::kNoError &&
+         commands_to_process--) {
+    const unsigned int size = cmd_data->value_header.size;
+    command = static_cast<CommandId>(cmd_data->value_header.command);
+
+    if (size == 0) {
+      result = error::kInvalidSize;
+      break;
+    }
+
+    if (static_cast<int>(size) + process_pos > num_entries) {
+      result = error::kOutOfBounds;
+      break;
+    }
+
+    const unsigned int arg_count = size - 1;
+    unsigned int command_index = command - kFirstWebGPUCommand;
+    if (command_index < base::size(command_info)) {
+      const CommandInfo& info = command_info[command_index];
+      unsigned int info_arg_count = static_cast<unsigned int>(info.arg_count);
+      if ((info.arg_flags == cmd::kFixed && arg_count == info_arg_count) ||
+          (info.arg_flags == cmd::kAtLeastN && arg_count >= info_arg_count)) {
+        uint32_t immediate_data_size = (arg_count - info_arg_count) *
+                                       sizeof(CommandBufferEntry);  // NOLINT
+        result = (this->*info.cmd_handler)(immediate_data_size, cmd_data);
+      } else {
+        result = error::kInvalidArguments;
+      }
+    } else {
+      result = DoCommonCommand(command, arg_count, cmd_data);
+    }
+
+    if (result == error::kNoError &&
+        current_decoder_error_ != error::kNoError) {
+      result = current_decoder_error_;
+      current_decoder_error_ = error::kNoError;
+    }
+
+    if (result != error::kDeferCommandUntilLater) {
+      process_pos += size;
+      cmd_data += size;
+    }
+  }
+
+  *entries_processed = process_pos;
+
+  if (error::IsError(result)) {
+    LOG(ERROR) << "Error: " << result << " for Command "
+               << GetCommandName(command);
+  }
+
+  return result;
+}
+
+error::Error WebGPUDecoderImpl::HandleDummy(uint32_t immediate_data_size,
+                                            const volatile void* cmd_data) {
+  DLOG(ERROR) << "WebGPUDecoderImpl::HandleDummy";
+  return error::kNoError;
+}
+
 }  // namespace webgpu
 }  // namespace gpu
--- a/gpu/command_buffer/service/wrapped_sk_image.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/service/wrapped_sk_image.cc	2019-05-17 18:53:33.040000000 +0300
@@ -70,7 +70,6 @@
 
   sk_sp<SkSurface> GetSkSurface(int final_msaa_count,
                                 SkColorType color_type,
-                                sk_sp<SkColorSpace> color_space,
                                 const SkSurfaceProps& surface_props) {
     if (context_state_->context_lost())
       return nullptr;
@@ -80,7 +79,7 @@
     DCHECK(gr_texture.isValid());
     return SkSurface::MakeFromBackendTextureAsRenderTarget(
         context_state_->gr_context(), gr_texture, kTopLeft_GrSurfaceOrigin,
-        final_msaa_count, color_type, color_space, &surface_props);
+        final_msaa_count, color_type, /*colorSpace=*/nullptr, &surface_props);
   }
 
   sk_sp<SkPromiseImageTexture> promise_texture() { return promise_texture_; }
@@ -195,8 +194,7 @@
         /*gpu_compositing=*/true, format());
 
     auto surface = wrapped_sk_image()->GetSkSurface(
-        final_msaa_count, sk_color_type,
-        backing()->color_space().ToSkColorSpace(), surface_props);
+        final_msaa_count, sk_color_type, surface_props);
     write_surface_ = surface.get();
     return surface;
   }
--- a/gpu/command_buffer/tests/compressed_texture_test.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/tests/compressed_texture_test.cc	2019-05-17 18:53:33.040000000 +0300
@@ -246,7 +246,7 @@
   GL_COMPRESSED_RGBA_S3TC_DXT3_EXT,
   GL_COMPRESSED_RGBA_S3TC_DXT5_EXT
 };
-INSTANTIATE_TEST_SUITE_P(Format,
+INSTANTIATE_TEST_CASE_P(Format,
                          CompressedTextureTest,
                          ::testing::ValuesIn(kFormats));
 
--- a/gpu/command_buffer/tests/decoder_perftest.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/tests/decoder_perftest.cc	2019-05-17 18:53:33.040000000 +0300
@@ -56,7 +56,10 @@
  public:
   enum Mode { kDirect, kRecord, kReplay };
 
-  RecordReplayCommandBuffer() = default;
+  explicit RecordReplayCommandBuffer(
+      TransferBufferManager* transfer_buffer_manager)
+      : CommandBufferDirect(transfer_buffer_manager) {}
+
   ~RecordReplayCommandBuffer() override = default;
 
   void AdvanceMode() {
@@ -180,7 +183,8 @@
         nullptr /* progress_reporter */, GpuFeatureInfo(),
         &discardable_manager_, &passthrough_discardable_manager_,
         &shared_image_manager_);
-    command_buffer_.reset(new RecordReplayCommandBuffer());
+    command_buffer_.reset(new RecordReplayCommandBuffer(
+        context_group->transfer_buffer_manager()));
 
     decoder_.reset(gles2::GLES2Decoder::Create(
         command_buffer_.get(), command_buffer_->service(), &outputter_,
--- a/gpu/command_buffer/tests/fuzzer_main.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/tests/fuzzer_main.cc	2019-05-17 18:53:33.044000000 +0300
@@ -21,7 +21,6 @@
 #include "build/build_config.h"
 #include "gpu/command_buffer/common/constants.h"
 #include "gpu/command_buffer/common/context_creation_attribs.h"
-#include "gpu/command_buffer/common/shared_image_usage.h"
 #include "gpu/command_buffer/service/buffer_manager.h"
 #include "gpu/command_buffer/service/command_buffer_direct.h"
 #include "gpu/command_buffer/service/context_group.h"
@@ -35,7 +34,6 @@
 #include "gpu/command_buffer/service/raster_decoder.h"
 #include "gpu/command_buffer/service/service_discardable_manager.h"
 #include "gpu/command_buffer/service/shared_context_state.h"
-#include "gpu/command_buffer/service/shared_image_factory.h"
 #include "gpu/command_buffer/service/shared_image_manager.h"
 #include "gpu/command_buffer/service/transfer_buffer_manager.h"
 #include "ui/gfx/geometry/size.h"
@@ -264,8 +262,7 @@
     GPU_DRIVER_BUG_WORKAROUNDS(GPU_OP)
 #undef GPU_OP
 
-#if defined(GPU_FUZZER_USE_PASSTHROUGH_CMD_DECODER) && \
-    !defined(GPU_FUZZER_USE_RASTER_DECODER)
+#if defined(GPU_FUZZER_USE_PASSTHROUGH_CMD_DECODER)
     gl_context_attribs.bind_generates_resource =
         attrib_helper.bind_generates_resource;
     gl_context_attribs.webgl_compatibility_context =
@@ -357,59 +354,31 @@
     gpu_feature_info.status_values[GPU_FEATURE_TYPE_OOP_RASTERIZATION] =
         kGpuFeatureStatusEnabled;
 #endif
-    auto feature_info = base::MakeRefCounted<gles2::FeatureInfo>(
-        config_.workarounds, gpu_feature_info);
-    command_buffer_.reset(new CommandBufferDirect());
+    scoped_refptr<gles2::FeatureInfo> feature_info =
+        new gles2::FeatureInfo(config_.workarounds, gpu_feature_info);
+    scoped_refptr<gles2::ContextGroup> context_group = new gles2::ContextGroup(
+        gpu_preferences_, true, &mailbox_manager_, nullptr /* memory_tracker */,
+        &translator_cache_, &completeness_cache_, feature_info,
+        config_.attrib_helper.bind_generates_resource, &image_manager_,
+        nullptr /* image_factory */, nullptr /* progress_reporter */,
+        gpu_feature_info, discardable_manager_.get(),
+        passthrough_discardable_manager_.get(), &shared_image_manager_);
+    command_buffer_.reset(
+        new CommandBufferDirect(context_group->transfer_buffer_manager()));
 
+#if defined(GPU_FUZZER_USE_RASTER_DECODER)
+    CHECK(feature_info->feature_flags().chromium_raster_transport);
     scoped_refptr<SharedContextState> context_state =
         base::MakeRefCounted<SharedContextState>(
             share_group_, surface_, context_,
             config_.workarounds.use_virtualized_gl_contexts, base::DoNothing());
     context_state->InitializeGrContext(config_.workarounds, nullptr);
     context_state->InitializeGL(gpu_preferences_, feature_info);
-
-    shared_image_manager_ = std::make_unique<SharedImageManager>();
-    shared_image_factory_ = std::make_unique<SharedImageFactory>(
-        gpu_preferences_, config_.workarounds, gpu_feature_info,
-        context_state.get(), &mailbox_manager_, shared_image_manager_.get(),
-        nullptr /* image_factory */, nullptr /* memory_tracker */);
-    for (uint32_t usage = SHARED_IMAGE_USAGE_GLES2;
-         usage <= SHARED_IMAGE_USAGE_RGB_EMULATION; usage <<= 1) {
-      Mailbox::Name name;
-      memset(name, 0, sizeof(name));
-      name[0] = usage;
-
-      // Mark this as a SharedImage mailbox.
-      constexpr size_t kSharedImageFlagIndex = GL_MAILBOX_SIZE_CHROMIUM - 1;
-      constexpr int8_t kSharedImageFlag = 0x1;
-      name[kSharedImageFlagIndex] |= kSharedImageFlag;
-
-      Mailbox mailbox;
-      mailbox.SetName(name);
-      shared_image_factory_->CreateSharedImage(
-          mailbox, viz::RGBA_8888, gfx::Size(256, 256),
-          gfx::ColorSpace::CreateSRGB(), usage);
-    }
-
-#if defined(GPU_FUZZER_USE_RASTER_DECODER)
-    CHECK(feature_info->feature_flags().chromium_raster_transport);
     auto* context = context_state->context();
     decoder_.reset(raster::RasterDecoder::Create(
         command_buffer_.get(), command_buffer_->service(), &outputter_,
-        gpu_feature_info, gpu_preferences_, nullptr /* memory_tracker */,
-        shared_image_manager_.get(), std::move(context_state)));
+        context_group.get(), std::move(context_state)));
 #else
-    // GLES2Decoder may Initialize feature_info differently than
-    // SharedContextState and should have its own.
-    auto decoder_feature_info = base::MakeRefCounted<gles2::FeatureInfo>(
-        config_.workarounds, gpu_feature_info);
-    scoped_refptr<gles2::ContextGroup> context_group = new gles2::ContextGroup(
-        gpu_preferences_, true, &mailbox_manager_, nullptr /* memory_tracker */,
-        &translator_cache_, &completeness_cache_, decoder_feature_info,
-        config_.attrib_helper.bind_generates_resource, &image_manager_,
-        nullptr /* image_factory */, nullptr /* progress_reporter */,
-        gpu_feature_info, discardable_manager_.get(),
-        passthrough_discardable_manager_.get(), shared_image_manager_.get());
     auto* context = context_.get();
     decoder_.reset(gles2::GLES2Decoder::Create(
         command_buffer_.get(), command_buffer_->service(), &outputter_,
@@ -428,10 +397,7 @@
     InitializeInitialCommandBuffer();
 
     decoder_->set_max_bucket_size(8 << 20);
-#if !defined(GPU_FUZZER_USE_RASTER_DECODER)
     context_group->buffer_manager()->set_max_buffer_size(8 << 20);
-#endif
-    decoder_initialized_ = true;
     return decoder_->MakeCurrent();
   }
 
@@ -450,14 +416,10 @@
       if (translator)
         translator->AddRef();
 #endif
-      bool reset_status = decoder_initialized_ && decoder_->CheckResetStatus();
-      context_lost = decoder_->WasContextLost() || !reset_status;
-      shared_image_factory_->DestroyAllSharedImages(!context_lost);
+      context_lost =
+          decoder_->WasContextLost() || !decoder_->CheckResetStatus();
       decoder_->Destroy(!context_lost);
       decoder_.reset();
-
-      shared_image_factory_.reset();
-      shared_image_manager_.reset();
     }
 
     if (context_) {
@@ -468,7 +430,6 @@
     }
 
     command_buffer_.reset();
-    decoder_initialized_ = false;
   }
 
   void RunCommandBuffer(const uint8_t* data, size_t size) {
@@ -577,8 +538,7 @@
   std::unique_ptr<ServiceDiscardableManager> discardable_manager_;
   std::unique_ptr<PassthroughDiscardableManager>
       passthrough_discardable_manager_;
-  std::unique_ptr<SharedImageManager> shared_image_manager_;
-  std::unique_ptr<SharedImageFactory> shared_image_factory_;
+  SharedImageManager shared_image_manager_;
 
   bool recreate_context_ = false;
   scoped_refptr<gl::GLSurface> surface_;
@@ -597,8 +557,6 @@
 
   scoped_refptr<Buffer> buffer_;
   int32_t buffer_id_ = 0;
-
-  bool decoder_initialized_ = false;
 };
 
 // Intentionally leaked because asan tries to exit cleanly after a crash, but
--- a/gpu/command_buffer/tests/gl_apply_screen_space_antialiasing_CHROMIUM_unittest.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/tests/gl_apply_screen_space_antialiasing_CHROMIUM_unittest.cc	2019-05-17 18:53:33.044000000 +0300
@@ -50,15 +50,6 @@
       return;
     }
 
-    // Antialiasing won't be enabled if framebuffer CMAA is disabled via GPU
-    // driver workarounds 'disable_framebuffer_cmaa'.
-    available_ = !gl_.workarounds().disable_framebuffer_cmaa;
-    if (!available_) {
-      LOG(INFO) << "'disable_framebuffer_cmaa' workaround applied. "
-                   "Skipping test...";
-      return;
-    }
-
     CreateAndBindDestinationTextureAndFBO(GL_TEXTURE_2D);
     glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, 1, 1, 0, GL_RGBA, GL_UNSIGNED_BYTE,
                  nullptr);
@@ -390,7 +381,7 @@
   }
 
   EXPECT_EQ(static_cast<GLenum>(GL_NO_ERROR), glGetError());
-}
+};
 
 // Verify that invocation of the extension does not modify the bound
 // texture state.
--- a/gpu/command_buffer/tests/gl_bind_uniform_location_unittest.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/tests/gl_bind_uniform_location_unittest.cc	2019-05-17 18:53:33.044000000 +0300
@@ -402,7 +402,7 @@
   EXPECT_EQ(static_cast<GLenum>(GL_NO_ERROR), glGetError());
 }
 
-INSTANTIATE_TEST_SUITE_P(WithAndWithoutShaderNameMapping,
+INSTANTIATE_TEST_CASE_P(WithAndWithoutShaderNameMapping,
                          BindUniformLocationTest,
                          ::testing::Bool());
 
--- a/gpu/command_buffer/tests/gl_chromium_path_rendering_unittest.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/tests/gl_chromium_path_rendering_unittest.cc	2019-05-17 18:53:33.044000000 +0300
@@ -1779,7 +1779,7 @@
   EXPECT_EQ(static_cast<GLenum>(GL_INVALID_OPERATION), glGetError());
 }
 
-INSTANTIATE_TEST_SUITE_P(WithAndWithoutShaderNameMapping,
+INSTANTIATE_TEST_CASE_P(WithAndWithoutShaderNameMapping,
                          CHROMIUMPathRenderingWithTexturingTest,
                          ::testing::Bool());
 
--- a/gpu/command_buffer/tests/gl_clear_framebuffer_unittest.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/tests/gl_clear_framebuffer_unittest.cc	2019-05-17 18:53:33.044000000 +0300
@@ -112,7 +112,7 @@
   glDrawArrays(GL_TRIANGLES, 0, 6);
 }
 
-INSTANTIATE_TEST_SUITE_P(GLClearFramebufferTestWithParam,
+INSTANTIATE_TEST_CASE_P(GLClearFramebufferTestWithParam,
                          GLClearFramebufferTest,
                          ::testing::Values(true, false));
 
@@ -295,6 +295,7 @@
   }
 
   void TearDown() override {
+    GLTestHelper::CheckGLError("no errors", __LINE__);
     gl_.Destroy();
   }
 
@@ -302,15 +303,11 @@
 };
 
 TEST_F(ES3ClearBufferTest, ClearBuffersuiv) {
-  if (ShouldSkipTest())
-    return;
-
   // This is a regression test for https://crbug.com/908749
   GLuint value[1] = {0u};
   glClearBufferuiv(GL_STENCIL, 0, value);
   // The above call should not crash in ASAN build.
   EXPECT_EQ(static_cast<GLenum>(GL_INVALID_ENUM), glGetError());
-  GLTestHelper::CheckGLError("no errors", __LINE__);
 }
 
 }  // namespace gpu
--- a/gpu/command_buffer/tests/gl_copy_tex_image_2d_workaround_unittest.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/tests/gl_copy_tex_image_2d_workaround_unittest.cc	2019-05-17 18:53:33.044000000 +0300
@@ -99,7 +99,7 @@
   GLManager gl_;
 };
 
-INSTANTIATE_TEST_SUITE_P(GLCopyTexImage2DWorkaroundTestWithParam,
+INSTANTIATE_TEST_CASE_P(GLCopyTexImage2DWorkaroundTestWithParam,
                          GLCopyTexImage2DWorkaroundTest,
                          ::testing::Values(GL_RGBA));
 
--- a/gpu/command_buffer/tests/gl_copy_texture_CHROMIUM_unittest.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/tests/gl_copy_texture_CHROMIUM_unittest.cc	2019-05-17 18:53:33.044000000 +0300
@@ -14,12 +14,10 @@
 #include <stdint.h>
 
 #include "base/stl_util.h"
-#include "build/build_config.h"
 #include "gpu/command_buffer/tests/gl_manager.h"
 #include "gpu/command_buffer/tests/gl_test_utils.h"
 #include "testing/gmock/include/gmock/gmock.h"
 #include "testing/gtest/include/gtest/gtest.h"
-#include "ui/gl/gl_enums.h"
 #include "ui/gl/gl_version_info.h"
 
 namespace gpu {
@@ -155,11 +153,11 @@
   color[3] = a;
 }
 
-void getExpectedColorAndMask(GLenum src_internal_format,
+void getExpectedColor(GLenum src_internal_format,
                              GLenum dest_internal_format,
-                             const uint8_t* color,
+                      uint8_t* color,
                              uint8_t* expected_color,
-                             uint8_t* expected_mask) {
+                      uint8_t* mask) {
   uint8_t adjusted_color[4];
   switch (src_internal_format) {
     case GL_ALPHA:
@@ -189,34 +187,37 @@
     case GL_BGRA8_EXT:
       setColor(color[2], color[1], color[0], color[3], adjusted_color);
       break;
-    case GL_RGB10_A2: {
-      // Map the source 2-bit Alpha to 8-bits.
-      const uint8_t alpha_value = (color[3] & 0x3) * 255 / 3;
-      setColor(color[0] >> 2, color[1] >> 2, color[2] >> 2, alpha_value,
-               adjusted_color);
-      break;
-    }
     default:
-      NOTREACHED() << gl::GLEnums::GetStringEnum(src_internal_format);
+      NOTREACHED();
       break;
   }
 
   switch (dest_internal_format) {
-    // TODO(crbug.com/577144): Enable GL_ALPHA, GL_LUMINANCE and
-    // GL_LUMINANCE_ALPHA.
+    case GL_ALPHA:
+      setColor(0, 0, 0, adjusted_color[3], expected_color);
+      setColor(0, 0, 0, 1, mask);
+      break;
     case GL_R8:
     case GL_R16F:
     case GL_R32F:
     case GL_R8UI:
       setColor(adjusted_color[0], 0, 0, 0, expected_color);
-      setColor(1, 0, 0, 0, expected_mask);
+      setColor(1, 0, 0, 0, mask);
+      break;
+    case GL_LUMINANCE:
+      setColor(adjusted_color[0], 0, 0, 0, expected_color);
+      setColor(1, 0, 0, 0, mask);
+      break;
+    case GL_LUMINANCE_ALPHA:
+      setColor(adjusted_color[0], 0, 0, adjusted_color[3], expected_color);
+      setColor(1, 0, 0, 1, mask);
       break;
     case GL_RG8:
     case GL_RG16F:
     case GL_RG32F:
     case GL_RG8UI:
       setColor(adjusted_color[0], adjusted_color[1], 0, 0, expected_color);
-      setColor(1, 1, 0, 0, expected_mask);
+      setColor(1, 1, 0, 0, mask);
       break;
     case GL_RGB:
     case GL_RGB8:
@@ -230,7 +231,7 @@
     case GL_RGB8UI:
       setColor(adjusted_color[0], adjusted_color[1], adjusted_color[2], 0,
                expected_color);
-      setColor(1, 1, 1, 0, expected_mask);
+      setColor(1, 1, 1, 0, mask);
       break;
     case GL_RGBA:
     case GL_RGBA8:
@@ -244,25 +245,8 @@
     case GL_RGBA8UI:
       setColor(adjusted_color[0], adjusted_color[1], adjusted_color[2],
                adjusted_color[3], expected_color);
-      setColor(1, 1, 1, 1, expected_mask);
-      break;
-    case GL_RGB10_A2: {
-      //  Map the 2-bit Alpha values back to full bytes.
-      constexpr uint8_t step = 0x55;
-      const uint8_t alpha_value = (adjusted_color[3] + step / 2) / step * step;
-
-      setColor(adjusted_color[0], adjusted_color[1], adjusted_color[2],
-               alpha_value, expected_color);
-#if defined(OS_MACOSX) || defined(OS_LINUX)
-      // The alpha channel values for LUMINANCE_ALPHA source don't work OK
-      // on Mac or Linux, so skip comparison of those, see crbug.com/926579
-      setColor(1, 1, 1, src_internal_format != GL_LUMINANCE_ALPHA,
-               expected_mask);
-#else
-      setColor(1, 1, 1, 1, expected_mask);
-#endif
+      setColor(1, 1, 1, 1, mask);
       break;
-    }
     case GL_RGB5_A1:
       setColor(adjusted_color[0], adjusted_color[1], adjusted_color[2],
                (adjusted_color[3] >> 7) ? 0xFF : 0x0, expected_color);
@@ -270,10 +254,10 @@
       // channel of expected color is the source alpha value other than 255.
       // This should be wrong. Skip the alpha channel check and revisit this in
       // future.
-      setColor(1, 1, 1, 0, expected_mask);
+      setColor(1, 1, 1, 0, mask);
       break;
     default:
-      NOTREACHED() << gl::GLEnums::GetStringEnum(dest_internal_format);
+      NOTREACHED();
       break;
   }
 }
@@ -287,51 +271,38 @@
     uint8_t* expected_mask) {
   const uint32_t src_channel_count = gles2::GLES2Util::ElementsPerGroup(
       src_format_type.format, src_format_type.type);
-  constexpr uint8_t color[4] = {1u, 63u, 127u, 255u};
-  getExpectedColorAndMask(src_format_type.internal_format,
-                          dest_format_type.internal_format, color,
-                          expected_color, expected_mask);
-  const size_t num_pixels = width * height;
-  // TODO(mcasas): use std::make_unique<uint8_t[]> in this function.
-
+  uint8_t color[4] = {1u, 63u, 127u, 255u};
+  getExpectedColor(src_format_type.internal_format,
+                   dest_format_type.internal_format, color, expected_color,
+                   expected_mask);
   if (src_format_type.type == GL_UNSIGNED_BYTE) {
     std::unique_ptr<uint8_t[]> pixels(
-        new uint8_t[num_pixels * src_channel_count]);
-    for (uint32_t i = 0; i < num_pixels * src_channel_count;
+        new uint8_t[width * height * src_channel_count]);
+    for (uint32_t i = 0; i < width * height * src_channel_count;
          i += src_channel_count) {
       for (uint32_t j = 0; j < src_channel_count; ++j)
         pixels[i + j] = color[j];
     }
     return pixels;
   } else if (src_format_type.type == GL_UNSIGNED_SHORT) {
-    constexpr uint16_t color_16bit[4] = {color[0] << 8, color[1] << 8,
-                                         color[2] << 8, color[3] << 8};
+    uint16_t color_16bit[4] = {1u << 8, 63u << 8, 127u << 8, 255u << 8};
     std::unique_ptr<uint8_t[]> data(
-        new uint8_t[num_pixels * src_channel_count * sizeof(uint16_t)]);
+        new uint8_t[width * height * src_channel_count * sizeof(uint16_t)]);
     uint16_t* pixels = reinterpret_cast<uint16_t*>(data.get());
     int16_t flip_sign = -1;
-    for (uint32_t i = 0; i < num_pixels * src_channel_count;
+    for (uint32_t i = 0; i < width * height * src_channel_count;
          i += src_channel_count) {
       for (uint32_t j = 0; j < src_channel_count; ++j) {
         // Introduce an offset to the value to check. Expected value should be
         // the same as without the offset.
         flip_sign *= -1;
         pixels[i + j] =
-            color_16bit[j] + flip_sign * (0x7F * (i + j)) / num_pixels;
+            color_16bit[j] + flip_sign * (0x7F * (i + j)) / (width * height);
       }
     }
     return data;
-  } else if (src_format_type.type == GL_UNSIGNED_INT_2_10_10_10_REV) {
-    DCHECK_EQ(src_channel_count, 1u);
-    constexpr uint32_t color_rgb10_a2 = ((color[3] & 0x3) << 30) +
-                                        (color[2] << 20) + (color[1] << 10) +
-                                        color[0];
-    std::unique_ptr<uint8_t[]> data(new uint8_t[num_pixels * sizeof(uint32_t)]);
-    uint32_t* pixels = reinterpret_cast<uint32_t*>(data.get());
-    std::fill(pixels, pixels + num_pixels, color_rgb10_a2);
-    return data;
   }
-  NOTREACHED() << gl::GLEnums::GetStringEnum(src_format_type.type);
+  NOTREACHED();
   return nullptr;
 }
 
@@ -506,9 +477,7 @@
                                textures_[1], dest_level, 0, 0, 0, 0, width_,
                                height_, false, false, false);
     }
-    const GLenum last_error = glGetError();
-    EXPECT_TRUE(last_error == GL_NO_ERROR)
-        << gl::GLEnums::GetStringError(last_error);
+    EXPECT_TRUE(glGetError() == GL_NO_ERROR);
 
     // Draw destination texture to a fbo with a TEXTURE_2D texture attachment
     // in RGBA format.
@@ -602,27 +571,13 @@
 #endif
     return !gl_.decoder()->GetFeatureInfo()->feature_flags().ext_texture_norm16;
   }
-
-  bool ShouldSkipRGB10A2() const {
-    DCHECK(!ShouldSkipTest());
-    const gl::GLVersionInfo& gl_version_info =
-        gl_.decoder()->GetFeatureInfo()->gl_version_info();
-    // XB30 support was introduced in GLES 3.0/ OpenGL 3.3, before that it was
-    // signalled via a specific extension.
-    const bool supports_rgb10_a2 =
-        gl_version_info.IsAtLeastGL(3, 3) ||
-        gl_version_info.IsAtLeastGLES(3, 0) ||
-        GLTestHelper::HasExtension("GL_EXT_texture_type_2_10_10_10_REV");
-    EXPECT_TRUE(supports_rgb10_a2);
-    return !supports_rgb10_a2;
-  }
 };
 
-INSTANTIATE_TEST_SUITE_P(CopyType,
+INSTANTIATE_TEST_CASE_P(CopyType,
                          GLCopyTextureCHROMIUMTest,
                          ::testing::ValuesIn(kCopyTypes));
 
-INSTANTIATE_TEST_SUITE_P(CopyType,
+INSTANTIATE_TEST_CASE_P(CopyType,
                          GLCopyTextureCHROMIUMES3Test,
                          ::testing::ValuesIn(kCopyTypes));
 
@@ -672,7 +627,7 @@
         << "Passthrough command decoder expected failure. Skipping test...";
     return;
   }
-  const CopyType copy_type = GetParam();
+  CopyType copy_type = GetParam();
 
   FormatType src_format_types[] = {
       {GL_LUMINANCE, GL_LUMINANCE, GL_UNSIGNED_BYTE},
@@ -684,7 +639,6 @@
       {GL_BGRA_EXT, GL_BGRA_EXT, GL_UNSIGNED_BYTE},
       {GL_BGRA8_EXT, GL_BGRA_EXT, GL_UNSIGNED_BYTE},
       {GL_R16_EXT, GL_RED, GL_UNSIGNED_SHORT},
-      {GL_RGB10_A2, GL_RGBA, GL_UNSIGNED_INT_2_10_10_10_REV},
   };
 
   FormatType dest_format_types[] = {
@@ -729,7 +683,6 @@
       {GL_RGBA16F, GL_RGBA, GL_FLOAT},
       {GL_RGBA32F, GL_RGBA, GL_FLOAT},
       {GL_RGBA8UI, GL_RGBA_INTEGER, GL_UNSIGNED_BYTE},
-      {GL_RGB10_A2, GL_RGBA, GL_UNSIGNED_INT_2_10_10_10_REV},
   };
 
   for (auto src_format_type : src_format_types) {
@@ -742,18 +695,14 @@
         continue;
       }
       if (gles2::GLES2Util::IsFloatFormat(dest_format_type.internal_format) &&
-          ShouldSkipFloatFormat()) {
+          ShouldSkipFloatFormat())
         continue;
-      }
       if ((dest_format_type.internal_format == GL_SRGB_EXT ||
            dest_format_type.internal_format == GL_SRGB_ALPHA_EXT) &&
-          ShouldSkipSRGBEXT()) {
+          ShouldSkipSRGBEXT())
         continue;
-      }
       if (src_format_type.internal_format == GL_R16_EXT && ShouldSkipNorm16())
         continue;
-      if (src_format_type.internal_format == GL_RGB10_A2 && ShouldSkipRGB10A2())
-        continue;
 
       RunCopyTexture(GL_TEXTURE_2D, copy_type, src_format_type, 0,
                      dest_format_type, 0, true);
@@ -1211,7 +1160,7 @@
   glDeleteFramebuffers(1, &framebuffer_id_);
 
   EXPECT_TRUE(GL_NO_ERROR == glGetError());
-}
+};
 
 // Verify that invocation of the extension does not modify the bound
 // texture state.
--- a/gpu/command_buffer/tests/gl_cube_map_texture_unittest.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/tests/gl_cube_map_texture_unittest.cc	2019-05-17 18:53:33.044000000 +0300
@@ -65,7 +65,7 @@
   GLuint framebuffer_id_;
 };
 
-INSTANTIATE_TEST_SUITE_P(GLCubeMapTextureTests,
+INSTANTIATE_TEST_CASE_P(GLCubeMapTextureTests,
                          GLCubeMapTextureTest,
                          ::testing::ValuesIn(kCubeMapTextureTargets));
 
--- a/gpu/command_buffer/tests/gl_ext_blend_func_extended_unittest.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/tests/gl_ext_blend_func_extended_unittest.cc	2019-05-17 18:53:33.044000000 +0300
@@ -684,11 +684,11 @@
   EXPECT_TRUE(LinkProgram());
 }
 
-INSTANTIATE_TEST_SUITE_P(TranslatorVariants,
+INSTANTIATE_TEST_CASE_P(TranslatorVariants,
                          EXTBlendFuncExtendedDrawTest,
                          ::testing::Bool());
 
-INSTANTIATE_TEST_SUITE_P(TranslatorVariants,
+INSTANTIATE_TEST_CASE_P(TranslatorVariants,
                          EXTBlendFuncExtendedES3DrawTest,
                          ::testing::Bool());
 
--- a/gpu/command_buffer/tests/gl_gpu_memory_buffer_unittest.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/tests/gl_gpu_memory_buffer_unittest.cc	2019-05-17 18:53:33.044000000 +0300
@@ -439,7 +439,7 @@
 }
 #endif  // defined(OS_LINUX)
 
-INSTANTIATE_TEST_SUITE_P(GpuMemoryBufferTests,
+INSTANTIATE_TEST_CASE_P(GpuMemoryBufferTests,
                          GpuMemoryBufferTest,
                          ::testing::Values(gfx::BufferFormat::R_8,
                                            gfx::BufferFormat::BGR_565,
--- a/gpu/command_buffer/tests/gl_manager.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/tests/gl_manager.cc	2019-05-17 18:53:33.044000000 +0300
@@ -195,8 +195,10 @@
 
 class CommandBufferCheckLostContext : public CommandBufferDirect {
  public:
-  explicit CommandBufferCheckLostContext(bool context_lost_allowed)
-      : context_lost_allowed_(context_lost_allowed) {}
+  CommandBufferCheckLostContext(TransferBufferManager* transfer_buffer_manager,
+                                bool context_lost_allowed)
+      : CommandBufferDirect(transfer_buffer_manager),
+        context_lost_allowed_(context_lost_allowed) {}
 
   ~CommandBufferCheckLostContext() override = default;
 
@@ -354,8 +356,8 @@
         &shared_image_manager_);
   }
 
-  command_buffer_.reset(
-      new CommandBufferCheckLostContext(options.context_lost_allowed));
+  command_buffer_.reset(new CommandBufferCheckLostContext(
+      context_group->transfer_buffer_manager(), options.context_lost_allowed));
 
   decoder_.reset(::gpu::gles2::GLES2Decoder::Create(
       command_buffer_.get(), command_buffer_->service(), &outputter_,
@@ -425,7 +427,9 @@
 }
 
 size_t GLManager::GetSharedMemoryBytesAllocated() const {
-  return command_buffer_->service()->GetSharedMemoryBytesAllocated();
+  return decoder_->GetContextGroup()
+      ->transfer_buffer_manager()
+      ->shared_memory_bytes_allocated();
 }
 
 void GLManager::SetupBaseContext() {
--- a/gpu/command_buffer/tests/gl_manager.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/tests/gl_manager.h	2019-05-17 18:53:33.048000000 +0300
@@ -47,7 +47,7 @@
 class GLES2CmdHelper;
 class GLES2Implementation;
 
-}  // namespace gles2
+};
 
 class GLManager : private GpuControl {
  public:
--- a/gpu/command_buffer/tests/gl_request_extension_unittest.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/tests/gl_request_extension_unittest.cc	2019-05-17 18:53:33.048000000 +0300
@@ -92,7 +92,7 @@
     EXPECT_GE(extensions.size(), extensions_size_before_request);
   }
 }
-INSTANTIATE_TEST_SUITE_P(WithContextTypes,
+INSTANTIATE_TEST_CASE_P(WithContextTypes,
                          RequestExtensionCHROMIUMTest,
                          ::testing::Values(CONTEXT_TYPE_WEBGL1,
                                            CONTEXT_TYPE_WEBGL2,
--- a/gpu/command_buffer/tests/gl_virtual_contexts_unittest.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/tests/gl_virtual_contexts_unittest.cc	2019-05-17 18:53:33.048000000 +0300
@@ -439,7 +439,7 @@
 
 };
 
-INSTANTIATE_TEST_SUITE_P(WithWorkarounds,
+INSTANTIATE_TEST_CASE_P(WithWorkarounds,
                          GLVirtualContextsTest,
                          ::testing::ValuesIn(workarounds_cases));
 
--- a/gpu/command_buffer/tests/texture_image_factory.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/command_buffer/tests/texture_image_factory.cc	2019-05-17 18:53:33.048000000 +0300
@@ -16,7 +16,6 @@
 
   gfx::Size GetSize() override { return size_; }
   unsigned GetInternalFormat() override { return GL_RGBA; }
-  BindOrCopy ShouldBindOrCopy() override { return BIND; }
   bool BindTexImage(unsigned target) override {
     glTexImage2D(target,
                  0,  // mip level
@@ -25,20 +24,8 @@
                  GetInternalFormat(), GL_UNSIGNED_BYTE, nullptr);
     return true;
   }
-  bool BindTexImageWithInternalformat(unsigned target,
-                                      unsigned internal_format) override {
-    glTexImage2D(target,
-                 0,  // mip level
-                 GetInternalFormat(), size_.width(), size_.height(),
-                 0,  // border
-                 GetInternalFormat(), GL_UNSIGNED_BYTE, nullptr);
-    return true;
-  }
   void ReleaseTexImage(unsigned target) override {}
-  bool CopyTexImage(unsigned target) override {
-    NOTREACHED();
-    return false;
-  }
+  bool CopyTexImage(unsigned target) override { return false; }
   bool CopyTexSubImage(unsigned target,
                        const gfx::Point& offset,
                        const gfx::Rect& rect) override {
--- a/gpu/config/gpu_driver_bug_list.json	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/config/gpu_driver_bug_list.json	2019-05-17 18:53:33.052000000 +0300
@@ -9,11 +9,6 @@
         "type": "android"
       },
       "gl_vendor": "Imagination.*",
-      "gl_type": "gles",
-      "gl_version": {
-        "op": "<",
-        "value": "3.0"
-      },
       "features": [
         "use_client_side_arrays_for_stream_buffers"
       ]
@@ -26,11 +21,6 @@
         "type": "android"
       },
       "gl_vendor": "ARM.*",
-      "gl_type": "gles",
-      "gl_version": {
-        "op": "<",
-        "value": "3.0"
-      },
       "features": [
         "use_client_side_arrays_for_stream_buffers"
       ]
@@ -1963,7 +1953,7 @@
     },
     {
       "id": 197,
-      "description": "adjust bdst region if blitting pixels outside framebuffer on Mac",
+      "description": "adjust bdst region if blitting pixels outside read framebuffer on Mac",
       "cr_bugs": [644740],
       "os": {
         "type": "macosx"
@@ -1974,7 +1964,7 @@
     },
     {
       "id": 198,
-      "description": "adjust bdst region if blitting pixels outside framebuffer on Linux Intel",
+      "description": "adjust bdst region if blitting pixels outside read framebuffer on Linux Intel",
       "cr_bugs": [664740],
       "os": {
         "type": "linux"
@@ -1986,7 +1976,7 @@
     },
     {
       "id": 199,
-      "description": "adjust bdst region if blitting pixels outside framebuffer on Linux AMD",
+      "description": "adjust bdst region if blitting pixels outside read framebuffer on Linux AMD",
       "cr_bugs": [664740],
       "os": {
         "type": "linux"
@@ -2655,16 +2645,15 @@
     },
     {
       "id": 254,
-      "description": "Limit MSAA quality samples to 4 and storage samples 2 on AMD Stoney",
-      "cr_bugs": [875471],
+      "description": "Limit MSAA samples to 4x on AMD Stoney",
+      "cr_bugs": [798936],
       "os": {
         "type" : "chromeos"
       },
       "vendor_id": "0x1002",
       "device_id": ["0x98e4"],
       "features": [
-        "max_msaa_sample_count_4",
-        "use_eqaa_storage_samples_2"
+        "max_msaa_sample_count_4"
       ]
     },
     {
@@ -3080,86 +3069,6 @@
       ]
     },
     {
-      "id": 287,
-      "description": "glCopyTexImage2D on Adreno fails if source is GL_RGB10_A2 and destination is not.",
-      "cr_bugs": [925986],
-      "os": {
-        "type": "android",
-        "version": {
-          "op": ">=",
-          "value": "5.0.0"
-        }
-      },
-      "gl_vendor": "Qualcomm.*",
-      "gl_renderer": ".*4\\d\\d",
-      "gl_renderer": "Adreno \\(TM\\) [345].*",
-      "features": [
-        "disable_copy_tex_image_2d_rgb10_a2_adreno"
-      ]
-    },
-    {
-      "id": 288,
-      "description": "glCopyTexImage2D on NVIDIA Tegra fails in certain cases if source is GL_RGB10_A2.",
-      "cr_bugs": [925986],
-      "os": {
-        "type": "android"
-      },
-      "gl_vendor": "NVIDIA.*",
-      "gl_type": "gles",
-      "gl_version": {
-        "op": ">=",
-        "value": "3.0"
-      },
-      "features": [
-        "disable_copy_tex_image_2d_rgb10_a2_tegra"
-      ]
-    },
-    {
-      "id": 289,
-      "description": "Fake entry for testing command buffer init failures on ES 2.0",
-      "cr_bugs": [923134],
-      "test_group": 3,
-      "features": [
-        "disable_es3_gl_context_for_testing"
-      ]
-    },
-    {
-      "id": 290,
-      "description": "Round down glBindBufferRange size to a multiple of 4 on Qualcomm Adreno GPUs for uniform buffers",
-      "cr_bugs": [906743],
-      "os": {
-        "type": "android"
-      },
-      "gl_renderer": "Adreno \\(TM\\) .*",
-      "features": [
-        "round_down_uniform_bind_buffer_range_size"
-      ]
-    },
-    {
-      "id": 291,
-      "description": "adjust bdst region if blitting pixels outside framebuffer on Linux NVIDIA",
-      "cr_bugs": [830046],
-      "os": {
-        "type": "linux"
-      },
-      "vendor_id": "0x10de",
-      "features": [
-        "adjust_src_dst_region_for_blitframebuffer"
-      ]
-    },
-    {
-      "id": 292,
-      "description": "adjust bdst region if blitting pixels outside framebuffer on Android NVIDIA",
-      "cr_bugs": [830046],
-      "os": {
-        "type": "android"
-      },
-      "gl_vendor": "NVIDIA.*",
-      "features": [
-        "adjust_src_dst_region_for_blitframebuffer"
-      ]
-    },
-    {
       "id": 293,
       "cr_bugs": [931527],
       "description": "Frequent crashes in glClear on Android N with driver 12.0.04rel0",
@@ -3217,47 +3126,6 @@
       "features": [
         "rely_on_implicit_sync_for_swap_buffers"
       ]
-    },
-    {
-      "id": 297,
-      "cr_bugs": [938678],
-      "description": "Needed to pass dEQP-EGL.functional.robustness.reset_context.shaders.infinite_loop.*",
-      "os": {
-        "type" : "chromeos"
-      },
-      "vendor_id": "0x1002",
-      "features": [
-        "exit_on_context_lost"
-      ]
-    },
-    {
-      "id": 298,
-      "cr_bugs": [941716],
-      "description": "AImageReader is very crashy on this driver version",
-      "os": {
-        "type" : "android"
-      },
-      "gl_vendor": "Qualcomm.*",
-      "driver_version": {
-        "op": "=",
-        "value": "269.0"
-      },
-      "features": [
-        "disable_aimagereader"
-      ]
-    },
-    {
-      "id": 299,
-      "description": "Context lost recovery often fails on PowerVR Rogue GE8* GPUs on Android.",
-      "cr_bugs": [942106],
-      "os": {
-        "type": "android"
-      },
-      "gl_vendor": "Imagination.*",
-      "gl_renderer": "PowerVR Rogue GE8.*",
-      "features": [
-        "exit_on_context_lost"
-      ]
     }
   ]
 }
--- a/gpu/config/gpu_driver_bug_list_unittest.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/config/gpu_driver_bug_list_unittest.cc	2019-05-17 18:53:33.052000000 +0300
@@ -24,7 +24,6 @@
   GPUInfo gpu_info;
   gpu_info.gl_vendor = "ARM";
   gpu_info.gl_renderer = "MALi_T604";
-  gpu_info.gl_version = "OpenGL ES 2.0";
   std::set<int> bugs = list->MakeDecision(
       GpuControlList::kOsAndroid, "4.1", gpu_info);
   EXPECT_EQ(1u, bugs.count(USE_CLIENT_SIDE_ARRAYS_FOR_STREAM_BUFFERS));
@@ -35,7 +34,6 @@
   GPUInfo gpu_info;
   gpu_info.gl_vendor = "Imagination Technologies";
   gpu_info.gl_renderer = "PowerVR SGX 540";
-  gpu_info.gl_version = "OpenGL ES 2.0";
   std::set<int> bugs = list->MakeDecision(
       GpuControlList::kOsAndroid, "4.1", gpu_info);
   EXPECT_EQ(1u, bugs.count(USE_CLIENT_SIDE_ARRAYS_FOR_STREAM_BUFFERS));
--- a/gpu/config/gpu_dx_diagnostics_win.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/config/gpu_dx_diagnostics_win.cc	2019-05-17 18:53:33.052000000 +0300
@@ -43,10 +43,10 @@
         if (SUCCEEDED(hr)) {
           switch (variant.vt) {
             case VT_UI4:
-              output->values[prop_name8] = base::NumberToString(variant.ulVal);
+              output->values[prop_name8] = base::UintToString(variant.ulVal);
               break;
             case VT_I4:
-              output->values[prop_name8] = base::NumberToString(variant.lVal);
+              output->values[prop_name8] = base::IntToString(variant.lVal);
               break;
             case VT_BOOL:
               output->values[prop_name8] = variant.boolVal ? "true" : "false";
--- a/gpu/config/gpu_feature_info.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/config/gpu_feature_info.h	2019-05-17 18:53:33.052000000 +0300
@@ -38,7 +38,6 @@
 struct GPU_EXPORT WebglPreferences {
   AntialiasingMode anti_aliasing_mode = kAntialiasingModeUnspecified;
   uint32_t msaa_sample_count = 8;
-  uint32_t eqaa_storage_sample_count = 4;
   // WebGL-specific numeric limits.
   uint32_t max_active_webgl_contexts = 0;
   uint32_t max_active_webgl_contexts_on_worker = 0;
--- a/gpu/config/gpu_finch_features.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/config/gpu_finch_features.cc	2019-05-17 18:53:33.052000000 +0300
@@ -3,31 +3,7 @@
 // found in the LICENSE file.
 #include "gpu/config/gpu_finch_features.h"
 
-#if defined(OS_ANDROID)
-#include "base/android/build_info.h"
-#include "base/metrics/field_trial_params.h"
-#include "base/strings/string_split.h"
-#include "ui/gl/android/android_surface_control_compat.h"
-#endif
-
 namespace features {
-namespace {
-
-#if defined(OS_ANDROID)
-bool FieldIsInBlacklist(const char* current_value, std::string blacklist_str) {
-  std::vector<std::string> blacklist = base::SplitString(
-      blacklist_str, ",", base::KEEP_WHITESPACE, base::SPLIT_WANT_NONEMPTY);
-  for (const std::string& value : blacklist) {
-    if (value == current_value)
-      return true;
-  }
-
-  return false;
-}
-#endif
-
-}  // namespace
-
 #if defined(OS_ANDROID)
 // Use android AImageReader when playing videos with MediaPlayer.
 const base::Feature kAImageReaderMediaPlayer{"AImageReaderMediaPlayer",
@@ -68,12 +44,6 @@
 const base::Feature kDirectCompositionPreferNV12Overlays{
     "DirectCompositionPreferNV12Overlays", base::FEATURE_ENABLED_BY_DEFAULT};
 
-// Allow putting a video swapchain underneath the main swapchain, so overlays
-// can be used even if there are controls on top of the video. It can be
-// enabled only when overlay is supported.
-const base::Feature kDirectCompositionUnderlays{
-    "DirectCompositionUnderlays", base::FEATURE_DISABLED_BY_DEFAULT};
-
 // Causes us to use the SharedImageManager, removing support for the old
 // mailbox system. Any consumers of the GPU process using the old mailbox
 // system will experience undefined results.
@@ -98,29 +68,4 @@
 const base::Feature kVaapiJpegImageDecodeAcceleration{
     "VaapiJpegImageDecodeAcceleration", base::FEATURE_DISABLED_BY_DEFAULT};
 
-#if defined(OS_ANDROID)
-bool IsAndroidSurfaceControlEnabled() {
-  if (!gl::SurfaceControl::IsSupported())
-    return false;
-
-  if (!base::FeatureList::IsEnabled(kAndroidSurfaceControl))
-    return false;
-
-  if (FieldIsInBlacklist(base::android::BuildInfo::GetInstance()->model(),
-                         base::GetFieldTrialParamValueByFeature(
-                             kAndroidSurfaceControl, "blacklisted_models"))) {
-    return false;
-  }
-
-  if (FieldIsInBlacklist(
-          base::android::BuildInfo::GetInstance()->android_build_id(),
-          base::GetFieldTrialParamValueByFeature(kAndroidSurfaceControl,
-                                                 "blacklisted_build_ids"))) {
-    return false;
-  }
-
-  return true;
-}
-#endif
-
 }  // namespace features
--- a/gpu/config/gpu_finch_features.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/config/gpu_finch_features.h	2019-05-17 18:53:33.052000000 +0300
@@ -29,8 +29,6 @@
 
 GPU_EXPORT extern const base::Feature kDirectCompositionPreferNV12Overlays;
 
-GPU_EXPORT extern const base::Feature kDirectCompositionUnderlays;
-
 GPU_EXPORT extern const base::Feature kSharedImageManager;
 
 GPU_EXPORT extern const base::Feature kUseDCOverlaysForSoftwareProtectedVideo;
@@ -39,10 +37,6 @@
 
 GPU_EXPORT extern const base::Feature kVaapiJpegImageDecodeAcceleration;
 
-#if defined(OS_ANDROID)
-GPU_EXPORT bool IsAndroidSurfaceControlEnabled();
-#endif
-
 }  // namespace features
 
 #endif  // GPU_CONFIG_GPU_FEATURES_H_
--- a/gpu/config/gpu_info.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/config/gpu_info.cc	2019-05-17 18:53:33.052000000 +0300
@@ -50,55 +50,12 @@
   enumerator->EndVideoEncodeAcceleratorSupportedProfile();
 }
 
-const char* ImageDecodeAcceleratorTypeToString(
-    gpu::ImageDecodeAcceleratorType type) {
-  switch (type) {
-    case gpu::ImageDecodeAcceleratorType::kJpeg:
-      return "JPEG";
-    case gpu::ImageDecodeAcceleratorType::kUnknown:
-      return "Unknown";
-  }
-}
-
-const char* ImageDecodeAcceleratorSubsamplingToString(
-    gpu::ImageDecodeAcceleratorSubsampling subsampling) {
-  switch (subsampling) {
-    case gpu::ImageDecodeAcceleratorSubsampling::k420:
-      return "4:2:0";
-    case gpu::ImageDecodeAcceleratorSubsampling::k422:
-      return "4:2:2";
-  }
-}
-
-void EnumerateImageDecodeAcceleratorSupportedProfile(
-    const gpu::ImageDecodeAcceleratorSupportedProfile& profile,
-    gpu::GPUInfo::Enumerator* enumerator) {
-  enumerator->BeginImageDecodeAcceleratorSupportedProfile();
-  enumerator->AddString("imageType",
-                        ImageDecodeAcceleratorTypeToString(profile.image_type));
-  enumerator->AddString("minEncodedDimensions",
-                        profile.min_encoded_dimensions.ToString());
-  enumerator->AddString("maxEncodedDimensions",
-                        profile.max_encoded_dimensions.ToString());
-  std::string subsamplings;
-  for (size_t i = 0; i < profile.subsamplings.size(); i++) {
-    if (i > 0)
-      subsamplings += ", ";
-    subsamplings +=
-        ImageDecodeAcceleratorSubsamplingToString(profile.subsamplings[i]);
-  }
-  enumerator->AddString("subsamplings", subsamplings);
-  enumerator->EndImageDecodeAcceleratorSupportedProfile();
-}
-
 #if defined(OS_WIN)
 void EnumerateOverlayCapability(const gpu::OverlayCapability& cap,
                                 gpu::GPUInfo::Enumerator* enumerator) {
-  std::string key_string = "overlayCap";
-  key_string += OverlayFormatToString(cap.format);
   enumerator->BeginOverlayCapability();
-  enumerator->AddString(key_string.c_str(),
-                        cap.is_scaling_supported ? "SCALING" : "DIRECT");
+  enumerator->AddInt("format", static_cast<int>(cap.format));
+  enumerator->AddInt("isScalingSupported", cap.is_scaling_supported);
   enumerator->EndOverlayCapability();
 }
 
@@ -145,24 +102,6 @@
 VideoDecodeAcceleratorCapabilities::~VideoDecodeAcceleratorCapabilities() =
     default;
 
-ImageDecodeAcceleratorSupportedProfile::ImageDecodeAcceleratorSupportedProfile()
-    : image_type(ImageDecodeAcceleratorType::kUnknown) {}
-
-ImageDecodeAcceleratorSupportedProfile::ImageDecodeAcceleratorSupportedProfile(
-    const ImageDecodeAcceleratorSupportedProfile& other) = default;
-
-ImageDecodeAcceleratorSupportedProfile::ImageDecodeAcceleratorSupportedProfile(
-    ImageDecodeAcceleratorSupportedProfile&& other) = default;
-
-ImageDecodeAcceleratorSupportedProfile::
-    ~ImageDecodeAcceleratorSupportedProfile() = default;
-
-ImageDecodeAcceleratorSupportedProfile& ImageDecodeAcceleratorSupportedProfile::
-operator=(const ImageDecodeAcceleratorSupportedProfile& other) = default;
-
-ImageDecodeAcceleratorSupportedProfile& ImageDecodeAcceleratorSupportedProfile::
-operator=(ImageDecodeAcceleratorSupportedProfile&& other) = default;
-
 GPUInfo::GPUDevice::GPUDevice()
     : vendor_id(0),
       device_id(0),
@@ -260,10 +199,6 @@
     VideoEncodeAcceleratorSupportedProfiles
         video_encode_accelerator_supported_profiles;
     bool jpeg_decode_accelerator_supported;
-
-    ImageDecodeAcceleratorSupportedProfiles
-        image_decode_accelerator_supported_profiles;
-
 #if defined(USE_X11)
     VisualID system_visual;
     VisualID rgba_visual;
@@ -329,8 +263,6 @@
     EnumerateVideoEncodeAcceleratorSupportedProfile(profile, enumerator);
   enumerator->AddBool("jpegDecodeAcceleratorSupported",
       jpeg_decode_accelerator_supported);
-  for (const auto& profile : image_decode_accelerator_supported_profiles)
-    EnumerateImageDecodeAcceleratorSupportedProfile(profile, enumerator);
 #if defined(USE_X11)
   enumerator->AddInt64("systemVisual", system_visual);
   enumerator->AddInt64("rgbaVisual", rgba_visual);
--- a/gpu/config/gpu_info_collector.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/config/gpu_info_collector.cc	2019-05-17 18:53:33.052000000 +0300
@@ -215,7 +215,7 @@
       gfx::HasExtension(extension_set, "GL_NV_framebuffer_multisample")) {
     glGetIntegerv(GL_MAX_SAMPLES, &max_samples);
   }
-  gpu_info->max_msaa_samples = base::NumberToString(max_samples);
+  gpu_info->max_msaa_samples = base::IntToString(max_samples);
   base::UmaHistogramSparse("GPU.MaxMSAASampleCount", max_samples);
 
 #if defined(OS_ANDROID)
--- a/gpu/config/gpu_info_collector_unittest.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/config/gpu_info_collector_unittest.cc	2019-05-17 18:53:33.056000000 +0300
@@ -196,7 +196,7 @@
   std::vector<std::string> split_extensions_;
 };
 
-INSTANTIATE_TEST_SUITE_P(GPUConfig,
+INSTANTIATE_TEST_CASE_P(GPUConfig,
                          GPUInfoCollectorTest,
                          ::testing::ValuesIn(kMockedOperatingSystemKinds));
 
--- a/gpu/config/gpu_info_collector_win.cc	2019-05-17 17:45:41.016000000 +0300
+++ b/gpu/config/gpu_info_collector_win.cc	2019-05-17 18:53:33.056000000 +0300
@@ -150,7 +150,7 @@
   TRACE_EVENT0("gpu", "CollectDriverInfoD3D");
 
   // Display adapter class GUID from
-  // https://msdn.m1cr050ft.qjz9zk/en-us/library/windows/hardware/ff553426%28v=vs.85%29.aspx
+  // https://msdn.microsoft.com/en-us/library/windows/hardware/ff553426%28v=vs.85%29.aspx
   GUID display_class = {0x4d36e968,
                         0xe325,
                         0x11ce,
@@ -320,17 +320,18 @@
   // 32-bit dll will be used to detect the AMD Vulkan driver.
   const base::FilePath kAmdDriver64(FILE_PATH_LITERAL("amdvlk64.dll"));
   const base::FilePath kAmdDriver32(FILE_PATH_LITERAL("amdvlk32.dll"));
-  std::unique_ptr<FileVersionInfoWin> file_version_info =
-      FileVersionInfoWin::CreateFileVersionInfoWin(kAmdDriver64);
+  auto file_version_info =
+      base::WrapUnique(FileVersionInfoWin::CreateFileVersionInfo(kAmdDriver64));
   if (!file_version_info) {
-    file_version_info =
-        FileVersionInfoWin::CreateFileVersionInfoWin(kAmdDriver32);
+    file_version_info.reset(
+        FileVersionInfoWin::CreateFileVersionInfo(kAmdDriver32));
     if (!file_version_info)
       return false;
   }
 
   const VS_FIXEDFILEINFO* fixed_file_info =
-      file_version_info->fixed_file_info();
+      static_cast<FileVersionInfoWin*>(file_version_info.get())
+          ->fixed_file_info();
   const int major = HIWORD(fixed_file_info->dwFileVersionMS);
   const int minor = LOWORD(fixed_file_info->dwFileVersionMS);
   const int minor_1 = HIWORD(fixed_file_info->dwFileVersionLS);
@@ -347,14 +348,17 @@
 }
 
 bool BadVulkanDllVersion() {
-  std::unique_ptr<FileVersionInfoWin> file_version_info =
-      FileVersionInfoWin::CreateFileVersionInfoWin(
-          base::FilePath(FILE_PATH_LITERAL("vulkan-1.dll")));
+  std::unique_ptr<FileVersionInfoWin> file_version_info(
+      static_cast<FileVersionInfoWin*>(
+          FileVersionInfoWin::CreateFileVersionInfo(
+              base::FilePath(FILE_PATH_LITERAL("vulkan-1.dll")))));
+
   if (!file_version_info)
     return false;
 
   const VS_FIXEDFILEINFO* fixed_file_info =
-      file_version_info->fixed_file_info();
+      static_cast<FileVersionInfoWin*>(file_version_info.get())
+          ->fixed_file_info();
   const int major = HIWORD(fixed_file_info->dwFileVersionMS);
   const int minor = LOWORD(fixed_file_info->dwFileVersionMS);
   const int build_1 = HIWORD(fixed_file_info->dwFileVersionLS);
--- a/gpu/config/gpu_info.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/config/gpu_info.h	2019-05-17 18:53:33.052000000 +0300
@@ -113,45 +113,6 @@
 using VideoEncodeAcceleratorSupportedProfiles =
     std::vector<VideoEncodeAcceleratorSupportedProfile>;
 
-enum class ImageDecodeAcceleratorType {
-  kJpeg = 0,
-  kUnknown = 1,
-  kMaxValue = kUnknown,
-};
-
-enum class ImageDecodeAcceleratorSubsampling {
-  k420 = 0,
-  k422 = 1,
-  kMaxValue = k422,
-};
-
-// Specification of an image decoding profile supported by a hardware decoder.
-struct GPU_EXPORT ImageDecodeAcceleratorSupportedProfile {
-  ImageDecodeAcceleratorSupportedProfile();
-  ImageDecodeAcceleratorSupportedProfile(
-      const ImageDecodeAcceleratorSupportedProfile& other);
-  ImageDecodeAcceleratorSupportedProfile(
-      ImageDecodeAcceleratorSupportedProfile&& other);
-  ~ImageDecodeAcceleratorSupportedProfile();
-  ImageDecodeAcceleratorSupportedProfile& operator=(
-      const ImageDecodeAcceleratorSupportedProfile& other);
-  ImageDecodeAcceleratorSupportedProfile& operator=(
-      ImageDecodeAcceleratorSupportedProfile&& other);
-
-  // Fields common to all image types.
-  // Type of image to which this profile applies, e.g., JPEG.
-  ImageDecodeAcceleratorType image_type;
-  // Minimum and maximum supported pixel dimensions of the encoded image.
-  gfx::Size min_encoded_dimensions;
-  gfx::Size max_encoded_dimensions;
-
-  // Fields specific to |image_type| == kJpeg.
-  // The supported chroma subsampling formats, e.g. 4:2:0.
-  std::vector<ImageDecodeAcceleratorSubsampling> subsamplings;
-};
-using ImageDecodeAcceleratorSupportedProfiles =
-    std::vector<ImageDecodeAcceleratorSupportedProfile>;
-
 #if defined(OS_WIN)
 // Common overlay formats that we're interested in. Must match the OverlayFormat
 // enum in //tools/metrics/histograms/enums.xml. Mapped to corresponding DXGI
@@ -333,9 +294,6 @@
       video_encode_accelerator_supported_profiles;
   bool jpeg_decode_accelerator_supported;
 
-  ImageDecodeAcceleratorSupportedProfiles
-      image_decode_accelerator_supported_profiles;
-
 #if defined(USE_X11)
   VisualID system_visual;
   VisualID rgba_visual;
@@ -377,11 +335,6 @@
     virtual void BeginVideoEncodeAcceleratorSupportedProfile() = 0;
     virtual void EndVideoEncodeAcceleratorSupportedProfile() = 0;
 
-    // Markers indicating that an ImageDecodeAcceleratorSupportedProfile is
-    // being described.
-    virtual void BeginImageDecodeAcceleratorSupportedProfile() = 0;
-    virtual void EndImageDecodeAcceleratorSupportedProfile() = 0;
-
     // Markers indicating that "auxiliary" attributes of the GPUInfo
     // (according to the DevTools protocol) are being described.
     virtual void BeginAuxAttributes() = 0;
--- a/gpu/config/gpu_preferences.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/config/gpu_preferences.h	2019-05-17 18:53:33.056000000 +0300
@@ -56,6 +56,12 @@
   // ===================================
   // Settings from //content/public/common/content_switches.h
 
+  // Runs the renderer and plugins in the same process as the browser.
+  bool single_process = false;
+
+  // Run the GPU process as a thread in the browser process.
+  bool in_process_gpu = false;
+
   // Disables hardware acceleration of video decode, where available.
   bool disable_accelerated_video_decode = false;
 
@@ -95,6 +101,9 @@
 
   bool log_gpu_control_list_decisions = false;
 
+  // Enable exporting of events to ETW (on Windows).
+  bool enable_trace_export_events_to_etw = false;
+
   // ===================================
   // Settings from //gpu/command_buffer/service/gpu_switches.cc
 
--- a/gpu/config/gpu_preferences_unittest.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/config/gpu_preferences_unittest.cc	2019-05-17 18:53:33.056000000 +0300
@@ -14,6 +14,8 @@
 namespace {
 
 void CheckGpuPreferencesEqual(GpuPreferences left, GpuPreferences right) {
+  EXPECT_EQ(left.single_process, right.single_process);
+  EXPECT_EQ(left.in_process_gpu, right.in_process_gpu);
   EXPECT_EQ(left.disable_accelerated_video_decode,
             right.disable_accelerated_video_decode);
   EXPECT_EQ(left.disable_accelerated_video_encode,
@@ -33,6 +35,8 @@
             right.disable_software_rasterizer);
   EXPECT_EQ(left.log_gpu_control_list_decisions,
             right.log_gpu_control_list_decisions);
+  EXPECT_EQ(left.enable_trace_export_events_to_etw,
+            right.enable_trace_export_events_to_etw);
   EXPECT_EQ(left.compile_shader_always_succeeds,
             right.compile_shader_always_succeeds);
   EXPECT_EQ(left.disable_gl_error_limit, right.disable_gl_error_limit);
@@ -108,6 +112,8 @@
   prefs_mojom.name = value;                        \
   EXPECT_EQ(input_prefs.name, prefs_mojom.name);
 
+    GPU_PREFERENCES_FIELD(single_process, true)
+    GPU_PREFERENCES_FIELD(in_process_gpu, true)
     GPU_PREFERENCES_FIELD(disable_accelerated_video_decode, true)
     GPU_PREFERENCES_FIELD(disable_accelerated_video_encode, true)
     GPU_PREFERENCES_FIELD(gpu_startup_dialog, true)
@@ -121,6 +127,7 @@
     GPU_PREFERENCES_FIELD(enable_media_foundation_vea_on_windows7, true)
     GPU_PREFERENCES_FIELD(disable_software_rasterizer, true)
     GPU_PREFERENCES_FIELD(log_gpu_control_list_decisions, true)
+    GPU_PREFERENCES_FIELD(enable_trace_export_events_to_etw, true)
     GPU_PREFERENCES_FIELD(compile_shader_always_succeeds, true)
     GPU_PREFERENCES_FIELD(disable_gl_error_limit, true)
     GPU_PREFERENCES_FIELD(disable_glsl_translator, true)
--- a/gpu/config/gpu_test_expectations_parser_unittest.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/config/gpu_test_expectations_parser_unittest.cc	2019-05-17 18:53:33.056000000 +0300
@@ -345,7 +345,7 @@
   EXPECT_NE(0u, parser.GetErrorMessages().size());
 }
 
-INSTANTIATE_TEST_SUITE_P(GPUTestExpectationsParser,
+INSTANTIATE_TEST_CASE_P(GPUTestExpectationsParser,
                          GPUTestExpectationsParserParamTest,
                          ::testing::ValuesIn(kOSVersionsWithFamily));
 
--- a/gpu/config/gpu_util.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/config/gpu_util.cc	2019-05-17 18:53:33.056000000 +0300
@@ -51,7 +51,9 @@
   if (!gpu_preferences.enable_android_surface_control)
     return kGpuFeatureStatusDisabled;
 
-  DCHECK(gl::SurfaceControl::IsSupported());
+  if (!gl::SurfaceControl::IsSupported())
+    return kGpuFeatureStatusDisabled;
+
   return kGpuFeatureStatusEnabled;
 #endif
 }
@@ -230,10 +232,6 @@
   if (gpu_feature_info.IsWorkaroundEnabled(DISABLE_ES3_GL_CONTEXT)) {
     command_line->AppendSwitch(switches::kDisableES3GLContext);
   }
-  if (gpu_feature_info.IsWorkaroundEnabled(
-          DISABLE_ES3_GL_CONTEXT_FOR_TESTING)) {
-    command_line->AppendSwitch(switches::kDisableES3GLContextForTesting);
-  }
 #if defined(OS_WIN)
   if (gpu_feature_info.IsWorkaroundEnabled(DISABLE_DIRECT_COMPOSITION)) {
     command_line->AppendSwitch(switches::kDisableDirectComposition);
--- a/gpu/config/gpu_workaround_list.txt	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/config/gpu_workaround_list.txt	2019-05-17 18:53:33.056000000 +0300
@@ -26,7 +26,6 @@
 disable_discard_framebuffer
 disable_dxgi_zero_copy_video
 disable_es3_gl_context
-disable_es3_gl_context_for_testing
 disable_ext_draw_buffers
 disable_framebuffer_cmaa
 disable_gl_rgb_format
@@ -88,7 +87,6 @@
 rewrite_do_while_loops
 rewrite_float_unary_minus_operator
 rewrite_texelfetchoffset_to_texelfetch
-round_down_uniform_bind_buffer_range_size
 scalarize_vec_and_mat_constructor_args
 set_zero_level_before_generating_mipmap
 simulate_out_of_memory_on_large_textures
@@ -109,6 +107,3 @@
 validate_multisample_buffer_allocation
 wake_up_gpu_before_drawing
 use_copyteximage2d_instead_of_readpixels_on_multisampled_textures
-disable_copy_tex_image_2d_rgb10_a2_adreno
-disable_copy_tex_image_2d_rgb10_a2_tegra
-use_eqaa_storage_samples_2
--- a/gpu/config/nvml_info.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/config/nvml_info.cc	2019-05-17 18:53:33.056000000 +0300
@@ -43,8 +43,10 @@
   }
   dll_path = dll_path.Append(L"NVIDIA Corporation\\NVSMI\\nvml.dll");
 
-  std::unique_ptr<FileVersionInfoWin> file_version_info =
-      FileVersionInfoWin::CreateFileVersionInfoWin(dll_path);
+  std::unique_ptr<FileVersionInfoWin> file_version_info(
+      static_cast<FileVersionInfoWin*>(
+          FileVersionInfoWin::CreateFileVersionInfo(dll_path)));
+
   if (!file_version_info) {
     return false;
   }
--- a/gpu/config/software_rendering_list.json	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/config/software_rendering_list.json	2019-05-17 18:53:33.060000000 +0300
@@ -1364,7 +1364,7 @@
     },
     {
       "id": 137,
-      "description": "GPU rasterization on CrOS is blacklisted on anything but Intel, Imagination, or AMD GPUs for now.",
+      "description": "GPU rasterization on CrOS is blacklisted on anything but Intel, Mali, Imagination, or AMD GPUs for now.",
       "cr_bugs": [684094],
       "os": {
         "type": "chromeos"
@@ -1374,6 +1374,7 @@
       ],
       "exceptions": [
         { "vendor_id": "0x8086" },
+        { "gl_renderer": "Mali-T.*" },
         { "gl_renderer": "PowerVR.*" },
         { "vendor_id": "0x1002" }
       ]
@@ -1689,6 +1690,15 @@
       ]
     },
     {
+      "id": 158,
+      "cr_bugs": [829435],
+      "description": "OOP rasterization on top of ANGLE not supported",
+      "gl_renderer": "ANGLE.*",
+      "features": [
+        "oop_rasterization"
+      ]
+    },
+    {
       "id": 159,
       "cr_bugs": [902247],
       "description": "Disallow OpenGL use on Mac with old NVIDIA GPUs",
@@ -1714,23 +1724,6 @@
       "features": [
         "all"
       ]
-    },
-    {
-      "id": 161,
-      "cr_bugs": [890688],
-      "description": "Newer Mesa drivers experience visual corruption on very old hardware",
-      "os": {
-        "type": "linux"
-      },
-      "vendor_id": "0x8086",
-      "device_id": ["0x2a42"],
-      "driver_version": {
-        "op": "=",
-        "value": "18.1.7"
-      },
-      "features": [
-        "all"
-      ]
     }
   ]
 }
--- a/gpu/dawn_end2end_tests_main.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/dawn_end2end_tests_main.cc	2019-05-17 18:53:33.060000000 +0300
@@ -19,15 +19,10 @@
 
 }  // namespace
 
-// Definition located in third_party/dawn/btests/DawnTest.h
-// Forward declared here to avoid pulling in the Dawn headers.
-void InitDawnEnd2EndTestEnvironment(int argc, char** argv);
-
 int main(int argc, char** argv) {
   base::CommandLine::Init(argc, argv);
   testing::InitGoogleMock(&argc, argv);
   base::TestSuite test_suite(argc, argv);
-  InitDawnEnd2EndTestEnvironment(argc, argv);
   int rt = base::LaunchUnitTestsWithOptions(
       argc, argv,
       1,     // Run tests serially.
--- a/gpu/GLES2/extensions/CHROMIUM/CHROMIUM_color_space_metadata.txt	2019-05-17 17:45:41.004000000 +0300
+++ b/gpu/GLES2/extensions/CHROMIUM/CHROMIUM_color_space_metadata.txt	2019-05-17 18:53:32.932000000 +0300
@@ -13,7 +13,7 @@
 
 Contact
 
-    Sunny Sachanandani, Google (sunnyps 'at' 9oo91e.qjz9zk)
+    Sunny Sachanandani, Google (sunnyps 'at' google.com)
 
 Status
 
--- a/gpu/GLES2/extensions/CHROMIUM/CHROMIUM_shared_image.txt	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/GLES2/extensions/CHROMIUM/CHROMIUM_shared_image.txt	2019-05-17 18:53:32.936000000 +0300
@@ -24,9 +24,14 @@
 
     The command
 
-      GLuint glCreateAndTexStorage2DSharedImageCHROMIUM (const GLbyte *mailbox)
+      GLuint glCreateAndTexStorage2DSharedImageCHROMIUM (GLenum internal_format,
+                                                         const GLbyte *mailbox)
 
-    takes one argument:
+    takes two arguments:
+
+    internal_format - Must match the internal format of the SharedImage at
+      creation time, with the exception that a caller may pass GL_RGB or
+      GL_RGBA for a SharedImage created as RGBA_8888.
 
     mailbox - the mailbox referring to the SharedImage to assign to the
       first level of the mailbox.
@@ -37,7 +42,7 @@
     3) Assigns the SharedImage represented by mailbox to the first level of
        the texture object.
 
-    Note that the texture created by this function is immutable.
+    Note that the texutre created by this function is immutable.
 
     On success, this function extends the lifetime of the SharedImage
     referenced by mailbox by taking a ref. The texture object is deleted and
@@ -54,24 +59,6 @@
 
     The command
 
-      GLuint glCreateAndTexStorage2DSharedImageWithInternalFormatCHROMIUM (
-                                                  const GLbyte *mailbox,
-                                                  GLenum internal_format)
-
-    takes two arguments:
-
-    internal_format - Must match the internal format of the SharedImage at
-      creation time, with the exception that a caller may pass GL_RGB or
-      GL_RGBA for a SharedImage created as RGBA_8888.
-
-    mailbox - the mailbox referring to the SharedImage to assign to the
-      first level of the mailbox.
-
-    This function works similar to glCreateAndTexStorage2DSharedImageCHROMIUM
-    in other respects.
-
-    The command
-
       void glBeginSharedImageAccessDirectCHROMIUM (GLuint texture,
                                                    GLenum mode)
 
--- a/gpu/GLES2/extensions/CHROMIUM/CHROMIUM_texture_storage_image.txt	2019-05-17 17:45:41.004000000 +0300
+++ b/gpu/GLES2/extensions/CHROMIUM/CHROMIUM_texture_storage_image.txt	2019-05-17 18:53:32.936000000 +0300
@@ -14,7 +14,7 @@
 
 Contact
 
-    Sunny Sachanandani, Google (sunnyps 'at' 9oo91e.qjz9zk)
+    Sunny Sachanandani, Google (sunnyps 'at' google.com)
 
 Status
 
--- a/gpu/GLES2/extensions/CHROMIUM/EGL_CHROMIUM_sync_control.txt	2019-05-17 17:45:41.004000000 +0300
+++ b/gpu/GLES2/extensions/CHROMIUM/EGL_CHROMIUM_sync_control.txt	2019-05-17 18:53:32.936000000 +0300
@@ -8,7 +8,7 @@
 
 Contact
 
-   Stéphane Marchesin, Google (marcheu 'at' 9oo91e.qjz9zk)
+   Stéphane Marchesin, Google (marcheu 'at' google.com)
 
 Status
 
--- a/gpu/GLES2/gl2chromium_autogen.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/GLES2/gl2chromium_autogen.h	2019-05-17 18:53:32.936000000 +0300
@@ -245,8 +245,6 @@
 #define glBlitFramebufferCHROMIUM GLES2_GET_FUN(BlitFramebufferCHROMIUM)
 #define glRenderbufferStorageMultisampleCHROMIUM \
   GLES2_GET_FUN(RenderbufferStorageMultisampleCHROMIUM)
-#define glRenderbufferStorageMultisampleAdvancedAMD \
-  GLES2_GET_FUN(RenderbufferStorageMultisampleAdvancedAMD)
 #define glRenderbufferStorageMultisampleEXT \
   GLES2_GET_FUN(RenderbufferStorageMultisampleEXT)
 #define glFramebufferTexture2DMultisampleEXT \
@@ -277,11 +275,6 @@
 #define glFramebufferParameteri GLES2_GET_FUN(FramebufferParameteri)
 #define glBindImageTexture GLES2_GET_FUN(BindImageTexture)
 #define glDispatchCompute GLES2_GET_FUN(DispatchCompute)
-#define glGetProgramInterfaceiv GLES2_GET_FUN(GetProgramInterfaceiv)
-#define glGetProgramResourceIndex GLES2_GET_FUN(GetProgramResourceIndex)
-#define glGetProgramResourceName GLES2_GET_FUN(GetProgramResourceName)
-#define glGetProgramResourceiv GLES2_GET_FUN(GetProgramResourceiv)
-#define glGetProgramResourceLocation GLES2_GET_FUN(GetProgramResourceLocation)
 #define glMemoryBarrierEXT GLES2_GET_FUN(MemoryBarrierEXT)
 #define glMemoryBarrierByRegion GLES2_GET_FUN(MemoryBarrierByRegion)
 #define glSwapBuffers GLES2_GET_FUN(SwapBuffers)
@@ -423,8 +416,6 @@
 #define glMaxShaderCompilerThreadsKHR GLES2_GET_FUN(MaxShaderCompilerThreadsKHR)
 #define glCreateAndTexStorage2DSharedImageCHROMIUM \
   GLES2_GET_FUN(CreateAndTexStorage2DSharedImageCHROMIUM)
-#define glCreateAndTexStorage2DSharedImageWithInternalFormatCHROMIUM \
-  GLES2_GET_FUN(CreateAndTexStorage2DSharedImageWithInternalFormatCHROMIUM)
 #define glBeginSharedImageAccessDirectCHROMIUM \
   GLES2_GET_FUN(BeginSharedImageAccessDirectCHROMIUM)
 #define glEndSharedImageAccessDirectCHROMIUM \
--- a/gpu/gles2_conform_support/BUILD.gn	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/gles2_conform_support/BUILD.gn	2019-05-17 18:53:33.060000000 +0300
@@ -390,10 +390,6 @@
     # Also compile the sources generated by this action.
     sources += get_target_outputs(":generate_gles2_conform_embedded_data")
 
-    # Do not apply Chromium code rules to this third-party code.
-    configs -= [ "//build/config/compiler:chromium_code" ]
-    configs += [ "//build/config/compiler:no_chromium_code" ]
-
     defines = [
       "GTF_API=GTF_GLES20",
       "HKEMBEDDEDFILESYSTEM",
--- a/gpu/gles2_conform_support/egl/context.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/gles2_conform_support/egl/context.cc	2019-05-17 18:53:33.060000000 +0300
@@ -16,6 +16,7 @@
 #include "gpu/command_buffer/service/memory_tracking.h"
 #include "gpu/command_buffer/service/service_discardable_manager.h"
 #include "gpu/command_buffer/service/shared_image_manager.h"
+#include "gpu/command_buffer/service/transfer_buffer_manager.h"
 #include "gpu/gles2_conform_support/egl/config.h"
 #include "gpu/gles2_conform_support/egl/display.h"
 #include "gpu/gles2_conform_support/egl/surface.h"
@@ -266,7 +267,10 @@
       nullptr /* progress_reporter */, gpu_feature_info, &discardable_manager_,
       &passthrough_discardable_manager_, &shared_image_manager_));
 
-  auto command_buffer = std::make_unique<gpu::CommandBufferDirect>();
+  transfer_buffer_manager_ =
+      std::make_unique<gpu::TransferBufferManager>(nullptr);
+  std::unique_ptr<gpu::CommandBufferDirect> command_buffer(
+      new gpu::CommandBufferDirect(transfer_buffer_manager_.get()));
 
   std::unique_ptr<gpu::gles2::GLES2Decoder> decoder(
       gpu::gles2::GLES2Decoder::Create(command_buffer.get(),
--- a/gpu/gles2_conform_support/egl/context.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/gles2_conform_support/egl/context.h	2019-05-17 18:53:33.060000000 +0300
@@ -111,6 +111,7 @@
   bool is_current_in_some_thread_;
   bool is_destroyed_;
   const gpu::GpuDriverBugWorkarounds gpu_driver_bug_workarounds_;
+  std::unique_ptr<gpu::TransferBufferManager> transfer_buffer_manager_;
   std::unique_ptr<gpu::CommandBufferDirect> command_buffer_;
   std::unique_ptr<gpu::gles2::GLES2CmdHelper> gles2_cmd_helper_;
 
--- a/gpu/gles2_conform_support/gles2_conform_test.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/gles2_conform_support/gles2_conform_test.cc	2019-05-17 18:53:33.060000000 +0300
@@ -10,7 +10,6 @@
 #include <string>
 
 #include "base/base_paths.h"
-#include "base/bind.h"
 #include "base/command_line.h"
 #include "base/files/file_path.h"
 #include "base/files/file_util.h"
--- a/gpu/ipc/client/BUILD.gn	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/client/BUILD.gn	2019-05-17 18:53:33.064000000 +0300
@@ -37,7 +37,6 @@
     "//gpu/command_buffer/common:common_sources",
     "//gpu/config:config_sources",
     "//gpu/ipc/common:ipc_common_sources",
-    "//media/filters:jpeg_parser",
     "//mojo/public/cpp/system",
     "//ui/gfx:color_space",
     "//ui/gfx/geometry",
--- a/gpu/ipc/client/command_buffer_proxy_impl.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/client/command_buffer_proxy_impl.cc	2019-05-17 18:53:33.064000000 +0300
@@ -8,7 +8,6 @@
 #include <utility>
 #include <vector>
 
-#include "base/bind.h"
 #include "base/callback.h"
 #include "base/command_line.h"
 #include "base/location.h"
@@ -150,7 +149,6 @@
     IPC_MESSAGE_HANDLER(GpuCommandBufferMsg_BufferPresented, OnBufferPresented);
     IPC_MESSAGE_HANDLER(GpuCommandBufferMsg_GetGpuFenceHandleComplete,
                         OnGetGpuFenceHandleComplete);
-    IPC_MESSAGE_HANDLER(GpuCommandBufferMsg_ReturnData, OnReturnData);
     IPC_MESSAGE_UNHANDLED(handled = false)
   IPC_END_MESSAGE_MAP()
 
@@ -633,22 +631,13 @@
   std::move(callback).Run(std::move(gpu_fence));
 }
 
-void CommandBufferProxyImpl::OnReturnData(const std::vector<uint8_t>& data) {
-  if (gpu_control_client_) {
-    gpu_control_client_->OnGpuControlReturnData(data);
-  }
-}
-
 void CommandBufferProxyImpl::TakeFrontBuffer(const gpu::Mailbox& mailbox) {
   CheckLock();
   base::AutoLock lock(last_state_lock_);
   if (last_state_.error != gpu::error::kNoError)
     return;
 
-  // TakeFrontBuffer should be a deferred message so that it's sequenced
-  // correctly with respect to preceding ReturnFrontBuffer messages.
-  last_flush_id_ = channel_->EnqueueDeferredMessage(
-      GpuCommandBufferMsg_TakeFrontBuffer(route_id_, mailbox));
+  Send(new GpuCommandBufferMsg_TakeFrontBuffer(route_id_, mailbox));
 }
 
 void CommandBufferProxyImpl::ReturnFrontBuffer(const gpu::Mailbox& mailbox,
--- a/gpu/ipc/client/command_buffer_proxy_impl.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/client/command_buffer_proxy_impl.h	2019-05-17 18:53:33.064000000 +0300
@@ -184,7 +184,6 @@
                          const gfx::PresentationFeedback& feedback);
   void OnGetGpuFenceHandleComplete(uint32_t gpu_fence_id,
                                    const gfx::GpuFenceHandle&);
-  void OnReturnData(const std::vector<uint8_t>& data);
 
   // Try to read an updated copy of the state from shared memory, and calls
   // OnGpuStateError() if the new state has an error.
--- a/gpu/ipc/client/DEPS	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/client/DEPS	2019-05-17 18:53:33.064000000 +0300
@@ -10,10 +10,8 @@
   "gpu_in_process_context_tests.cc": [
     "+components/viz/test/test_gpu_memory_buffer_manager.h",
   ],
-  "image_decode_accelerator_proxy.cc": [
-    "+media/filters/jpeg_parser.h",
-  ],
   "raster_in_process_context_tests.cc": [
+    "+cc/paint/color_space_transfer_cache_entry.h",
     "+components/viz/common/resources/resource_format.h",
     "+components/viz/common/resources/resource_format_utils.h",
     "+components/viz/test/test_gpu_memory_buffer_manager.h",
--- a/gpu/ipc/client/gpu_context_tests.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/client/gpu_context_tests.h	2019-05-17 18:53:33.064000000 +0300
@@ -50,7 +50,7 @@
   gl_->GenSyncTokenCHROMIUM(sync_token.GetData());
 
   TestSignalSyncToken(sync_token);
-}
+};
 
 CONTEXT_TEST_F(SignalTest, EmptySignalSyncTokenTest) {
 #if defined(OS_WIN)
@@ -64,7 +64,7 @@
   // immediately.
   gpu::SyncToken sync_token;
   TestSignalSyncToken(sync_token);
-}
+};
 
 CONTEXT_TEST_F(SignalTest, InvalidSignalSyncTokenTest) {
 #if defined(OS_WIN)
@@ -80,7 +80,7 @@
                             gpu::CommandBufferId::FromUnsafeValue(1297824234),
                             9123743439);
   TestSignalSyncToken(sync_token);
-}
+};
 
 CONTEXT_TEST_F(SignalTest, BasicSignalQueryTest) {
 #if defined(OS_WIN)
@@ -97,7 +97,7 @@
   gl_->EndQueryEXT(GL_COMMANDS_ISSUED_CHROMIUM);
   TestSignalQuery(query);
   gl_->DeleteQueriesEXT(1, &query);
-}
+};
 
 CONTEXT_TEST_F(SignalTest, SignalQueryUnboundTest) {
 #if defined(OS_WIN)
@@ -111,7 +111,7 @@
   gl_->GenQueriesEXT(1, &query);
   TestSignalQuery(query);
   gl_->DeleteQueriesEXT(1, &query);
-}
+};
 
 CONTEXT_TEST_F(SignalTest, InvalidSignalQueryUnboundTest) {
 #if defined(OS_WIN)
@@ -129,7 +129,7 @@
   TestSignalQuery(928729083);
   TestSignalQuery(928729082);
   TestSignalQuery(928729081);
-}
+};
 
 // The GpuFenceTest doesn't currently work on ChromeOS, apparently
 // due to inconsistent initialization of InProcessCommandBuffer which
@@ -191,6 +191,6 @@
 
 #endif  // defined(OS_ANDROID)
 
-}  // namespace
+};  // namespace
 
 #endif  // GPU_IPC_CLIENT_GPU_CONTEXT_TESTS_H_
--- a/gpu/ipc/client/image_decode_accelerator_proxy.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/client/image_decode_accelerator_proxy.cc	2019-05-17 18:53:33.064000000 +0300
@@ -4,160 +4,23 @@
 
 #include "gpu/ipc/client/image_decode_accelerator_proxy.h"
 
-#include <string.h>
-
-#include <algorithm>
-#include <utility>
 #include <vector>
 
-#include "base/logging.h"
-#include "base/numerics/safe_conversions.h"
 #include "gpu/command_buffer/common/constants.h"
-#include "gpu/config/gpu_info.h"
 #include "gpu/ipc/client/gpu_channel_host.h"
 #include "gpu/ipc/common/command_buffer_id.h"
 #include "gpu/ipc/common/gpu_messages.h"
-#include "media/filters/jpeg_parser.h"
 #include "ui/gfx/color_space.h"
 #include "ui/gfx/geometry/size.h"
 
 namespace gpu {
 
-namespace {
-
-bool IsJpegImage(base::span<const uint8_t> encoded_data) {
-  if (encoded_data.size() < 3u)
-    return false;
-  return memcmp("\xFF\xD8\xFF", encoded_data.data(), 3u) == 0;
-}
-
-ImageDecodeAcceleratorType GetImageType(
-    base::span<const uint8_t> encoded_data) {
-  static_assert(static_cast<int>(ImageDecodeAcceleratorType::kMaxValue) == 1,
-                "GetImageType() must be adapted to support all image types in "
-                "ImageDecodeAcceleratorType");
-
-  // Currently, only JPEG images are supported.
-  if (IsJpegImage(encoded_data))
-    return ImageDecodeAcceleratorType::kJpeg;
-
-  return ImageDecodeAcceleratorType::kUnknown;
-}
-
-bool GetJpegSubsampling(const media::JpegParseResult& parse_result,
-                        ImageDecodeAcceleratorSubsampling* subsampling) {
-  static_assert(
-      static_cast<int>(ImageDecodeAcceleratorSubsampling::kMaxValue) == 1,
-      "GetJpegSubsampling() must be adapted to support all "
-      "subsampling factors in ImageDecodeAcceleratorSubsampling");
-
-  // Currently, only 3 components are supported (this excludes, for example,
-  // grayscale and CMYK JPEGs).
-  if (parse_result.frame_header.num_components != 3u)
-    return false;
-
-  const uint8_t comp0_h =
-      parse_result.frame_header.components[0].horizontal_sampling_factor;
-  const uint8_t comp0_v =
-      parse_result.frame_header.components[0].vertical_sampling_factor;
-  const uint8_t comp1_h =
-      parse_result.frame_header.components[1].horizontal_sampling_factor;
-  const uint8_t comp1_v =
-      parse_result.frame_header.components[1].vertical_sampling_factor;
-  const uint8_t comp2_h =
-      parse_result.frame_header.components[2].horizontal_sampling_factor;
-  const uint8_t comp2_v =
-      parse_result.frame_header.components[2].vertical_sampling_factor;
-
-  if (comp0_h == 2u && (comp1_h == 1u && comp1_v == 1u) &&
-      (comp2_h == 1u && comp2_v == 1u)) {
-    if (comp0_v == 2u) {
-      *subsampling = ImageDecodeAcceleratorSubsampling::k420;
-      return true;
-    } else if (comp0_v == 1u) {
-      *subsampling = ImageDecodeAcceleratorSubsampling::k422;
-      return true;
-    }
-  }
-
-  return false;
-}
-
-bool IsSupportedJpegImage(
-    base::span<const uint8_t> encoded_data,
-    const ImageDecodeAcceleratorSupportedProfile& supported_profile) {
-  DCHECK(IsJpegImage(encoded_data));
-  DCHECK_EQ(ImageDecodeAcceleratorType::kJpeg, supported_profile.image_type);
-
-  // First, parse the JPEG file. This fails for progressive JPEGs (which we
-  // don't support anyway).
-  media::JpegParseResult parse_result;
-  if (!media::ParseJpegPicture(encoded_data.data(), encoded_data.size(),
-                               &parse_result)) {
-    return false;
-  }
-
-  // Now, check the chroma subsampling format.
-  ImageDecodeAcceleratorSubsampling subsampling;
-  if (!GetJpegSubsampling(parse_result, &subsampling))
-    return false;
-  if (std::find(supported_profile.subsamplings.cbegin(),
-                supported_profile.subsamplings.cend(),
-                subsampling) == supported_profile.subsamplings.cend()) {
-    return false;
-  }
-
-  // Now, check the dimensions.
-  const int encoded_width =
-      base::strict_cast<int>(parse_result.frame_header.coded_width);
-  const int encoded_height =
-      base::strict_cast<int>(parse_result.frame_header.coded_height);
-  if (encoded_width < supported_profile.min_encoded_dimensions.width() ||
-      encoded_height < supported_profile.min_encoded_dimensions.height() ||
-      encoded_width > supported_profile.max_encoded_dimensions.width() ||
-      encoded_height > supported_profile.max_encoded_dimensions.height()) {
-    return false;
-  }
-
-  return true;
-}
-
-}  // namespace
-
 ImageDecodeAcceleratorProxy::ImageDecodeAcceleratorProxy(GpuChannelHost* host,
                                                          int32_t route_id)
     : host_(host), route_id_(route_id) {}
 
 ImageDecodeAcceleratorProxy::~ImageDecodeAcceleratorProxy() {}
 
-bool ImageDecodeAcceleratorProxy::IsImageSupported(
-    base::span<const uint8_t> encoded_data) const {
-  DCHECK(host_);
-
-  const ImageDecodeAcceleratorType image_type = GetImageType(encoded_data);
-  if (image_type == ImageDecodeAcceleratorType::kUnknown)
-    return false;
-
-  // Find the image decode accelerator supported profile according to the type
-  // of the image.
-  const std::vector<ImageDecodeAcceleratorSupportedProfile>& profiles =
-      host_->gpu_info().image_decode_accelerator_supported_profiles;
-  auto profile_it = std::find_if(
-      profiles.cbegin(), profiles.cend(),
-      [image_type](const ImageDecodeAcceleratorSupportedProfile& profile) {
-        return profile.image_type == image_type;
-      });
-  if (profile_it == profiles.cend())
-    return false;
-
-  // Validate the image according to that profile.
-  if (image_type == ImageDecodeAcceleratorType::kJpeg)
-    return IsSupportedJpegImage(encoded_data, *profile_it);
-
-  NOTREACHED();
-  return false;
-}
-
 SyncToken ImageDecodeAcceleratorProxy::ScheduleImageDecode(
     base::span<const uint8_t> encoded_data,
     const gfx::Size& output_size,
@@ -165,13 +28,11 @@
     uint32_t transfer_cache_entry_id,
     int32_t discardable_handle_shm_id,
     uint32_t discardable_handle_shm_offset,
-    uint64_t discardable_handle_release_count,
     const gfx::ColorSpace& target_color_space,
     bool needs_mips) {
   DCHECK(host_);
   DCHECK_EQ(host_->channel_id(),
             ChannelIdFromCommandBufferId(raster_decoder_command_buffer_id));
-  DCHECK(IsImageSupported(encoded_data));
 
   GpuChannelMsg_ScheduleImageDecode_Params params;
   params.encoded_data =
@@ -182,18 +43,13 @@
   params.transfer_cache_entry_id = transfer_cache_entry_id;
   params.discardable_handle_shm_id = discardable_handle_shm_id;
   params.discardable_handle_shm_offset = discardable_handle_shm_offset;
-  params.discardable_handle_release_count = discardable_handle_release_count;
   params.target_color_space = target_color_space;
   params.needs_mips = needs_mips;
 
   base::AutoLock lock(lock_);
-  const uint64_t release_count = ++next_release_count_;
+  uint64_t release_count = ++next_release_count_;
   // Note: we send the message under the lock to guarantee monotonicity of the
   // release counts as seen by the service.
-  // The EnsureFlush() call makes sure that the sync token corresponding to
-  // |discardable_handle_release_count| is visible to the service before
-  // processing the image decode request.
-  host_->EnsureFlush(UINT32_MAX);
   host_->Send(new GpuChannelMsg_ScheduleImageDecode(
       route_id_, std::move(params), release_count));
   return SyncToken(
--- a/gpu/ipc/client/image_decode_accelerator_proxy.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/client/image_decode_accelerator_proxy.h	2019-05-17 18:53:33.064000000 +0300
@@ -29,18 +29,13 @@
 // (1) Create a locked ClientImageTransferCacheEntry without a backing
 //     SkPixmap. This entry should not be serialized over the command buffer.
 //
-// (2) Insert a sync token in the command buffer that is released after the
-//     discardable handle's buffer corresponding to the transfer cache entry has
-//     been registered.
+// (2) Call ScheduleImageDecode().
 //
-// (3) Call ScheduleImageDecode(). The release count of the sync token from the
-//     previous step is passed for the |discardable_handle_release_count|
-//     parameter.
-//
-// (4) Issue a server wait on the sync token returned in step (3).
+// (3) Issue a server wait on the sync token returned in step (2).
 //
 // When the service is done with the decode, a ServiceImageTransferCacheEntry
-// will be created/locked with the decoded data and the sync token is released.
+// will be created/locked with the decoded data and the sync token is
+// released.
 //
 // Objects of this class are thread-safe.
 //
@@ -50,25 +45,14 @@
   ImageDecodeAcceleratorProxy(GpuChannelHost* host, int32_t route_id);
   ~ImageDecodeAcceleratorProxy() override;
 
-  // Determines if an encoded image is supported by the hardware accelerator.
-  // The ScheduleImageDecode() method should only be called for images for which
-  // IsImageSupported() returns true. Otherwise, the client faces a GPU channel
-  // teardown if the decode fails.
-  bool IsImageSupported(base::span<const uint8_t> encoded_data) const override;
-
   // Schedules a hardware-accelerated image decode on the GPU process. The image
-  // in |encoded_data| is decoded and scaled to |output_size|. Upon completion
-  // and after the sync token corresponding to
-  // |discardable_handle_release_count| has been released, a service-side
-  // transfer cache entry will be created with the decoded data using
-  // |transfer_cache_entry_id|, |discardable_handle_shm_id|, and
+  // in |encoded_data| is decoded and scaled to |output_size|. Upon completion,
+  // a service-side transfer cache entry will be created with the decoded data
+  // using |transfer_cache_entry_id|, |discardable_handle_shm_id|, and
   // |discardable_handle_shm_offset|. The |raster_decoder_command_buffer_id| is
   // used to look up the appropriate command buffer and create the transfer
-  // cache entry correctly. Note that it is assumed that
-  // |discardable_handle_release_count| is associated to
-  // |raster_decoder_command_buffer_id|. Returns a sync token that will be
-  // released after the decode is done and the service-side transfer cache entry
-  // is created.
+  // cache entry correctly. Returns a sync token that will be released after the
+  // decode is done and the service-side transfer cache entry is created.
   SyncToken ScheduleImageDecode(
       base::span<const uint8_t> encoded_data,
       const gfx::Size& output_size,
@@ -76,7 +60,6 @@
       uint32_t transfer_cache_entry_id,
       int32_t discardable_handle_shm_id,
       uint32_t discardable_handle_shm_offset,
-      uint64_t discardable_handle_release_count,
       const gfx::ColorSpace& target_color_space,
       bool needs_mips) override;
 
--- a/gpu/ipc/client/raster_in_process_context_tests.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/client/raster_in_process_context_tests.cc	2019-05-17 18:53:33.064000000 +0300
@@ -5,6 +5,7 @@
 #include <memory>
 
 #include "build/build_config.h"
+#include "cc/paint/color_space_transfer_cache_entry.h"
 #include "components/viz/common/resources/resource_format.h"
 #include "components/viz/test/test_gpu_memory_buffer_manager.h"
 #include "gpu/command_buffer/client/raster_implementation.h"
@@ -104,9 +105,10 @@
   ri_->WaitSyncTokenCHROMIUM(sii->GenUnverifiedSyncToken().GetConstData());
 
   // Call BeginRasterCHROMIUM.
+  cc::RasterColorSpace raster_color_space(color_space, 0);
   ri_->BeginRasterCHROMIUM(/*sk_color=*/0, /*msaa_sample_count=*/0,
-                           /*can_use_lcd_text=*/false, color_space,
-                           mailbox.name);
+                           /*can_use_lcd_text=*/false,
+                           raster_color_space, mailbox.name);
   EXPECT_EQ(static_cast<GLenum>(GL_NO_ERROR), ri_->GetError());
 
   // Should flag an error this command is not allowed between a Begin and
--- a/gpu/ipc/common/gpu_command_buffer_traits_multi.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/common/gpu_command_buffer_traits_multi.h	2019-05-17 18:53:33.068000000 +0300
@@ -195,7 +195,6 @@
   IPC_STRUCT_TRAITS_MEMBER(enable_raster_interface)
   IPC_STRUCT_TRAITS_MEMBER(enable_oop_rasterization)
   IPC_STRUCT_TRAITS_MEMBER(enable_swap_timestamps_if_supported)
-  IPC_STRUCT_TRAITS_MEMBER(backed_by_surface_texture)
 IPC_STRUCT_TRAITS_END()
 
 IPC_STRUCT_TRAITS_BEGIN(gpu::GpuMemoryBufferFormatSet)
--- a/gpu/ipc/common/gpu_info.mojom	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/common/gpu_info.mojom	2019-05-17 18:53:33.068000000 +0300
@@ -76,26 +76,6 @@
   uint32 max_framerate_denominator;
 };
 
-// gpu::ImageDecodeAcceleratorType
-enum ImageDecodeAcceleratorType {
-  kJpeg,
-  kUnknown,
-};
-
-// gpu::ImageDecodeAcceleratorSubsampling
-enum ImageDecodeAcceleratorSubsampling {
-  k420,
-  k422,
-};
-
-// gpu::ImageDecodeAcceleratorSupportedProfile
-struct ImageDecodeAcceleratorSupportedProfile {
-  ImageDecodeAcceleratorType image_type;
-  gfx.mojom.Size min_encoded_dimensions;
-  gfx.mojom.Size max_encoded_dimensions;
-  array<ImageDecodeAcceleratorSubsampling> subsamplings;
-};
-
 // gpu::OverlayFormat
 [EnableIf=is_win]
 enum OverlayFormat {
@@ -162,10 +142,6 @@
   array<VideoEncodeAcceleratorSupportedProfile>
     video_encode_accelerator_supported_profiles;
   bool jpeg_decode_accelerator_supported;
-
-  array<ImageDecodeAcceleratorSupportedProfile>
-    image_decode_accelerator_supported_profiles;
-
   uint64 system_visual;
   uint64 rgba_visual;
   bool oop_rasterization_supported;
--- a/gpu/ipc/common/gpu_info_struct_traits.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/common/gpu_info_struct_traits.cc	2019-05-17 18:53:33.068000000 +0300
@@ -5,7 +5,6 @@
 #include "gpu/ipc/common/gpu_info_struct_traits.h"
 #include "build/build_config.h"
 
-#include "base/logging.h"
 #include "mojo/public/cpp/base/time_mojom_traits.h"
 
 namespace mojo {
@@ -219,77 +218,6 @@
          data.ReadMaxResolution(&out->max_resolution);
 }
 
-// static
-gpu::mojom::ImageDecodeAcceleratorType EnumTraits<
-    gpu::mojom::ImageDecodeAcceleratorType,
-    gpu::ImageDecodeAcceleratorType>::ToMojom(gpu::ImageDecodeAcceleratorType
-                                                  image_type) {
-  switch (image_type) {
-    case gpu::ImageDecodeAcceleratorType::kJpeg:
-      return gpu::mojom::ImageDecodeAcceleratorType::kJpeg;
-    case gpu::ImageDecodeAcceleratorType::kUnknown:
-      return gpu::mojom::ImageDecodeAcceleratorType::kUnknown;
-  }
-}
-
-// static
-bool EnumTraits<gpu::mojom::ImageDecodeAcceleratorType,
-                gpu::ImageDecodeAcceleratorType>::
-    FromMojom(gpu::mojom::ImageDecodeAcceleratorType input,
-              gpu::ImageDecodeAcceleratorType* out) {
-  switch (input) {
-    case gpu::mojom::ImageDecodeAcceleratorType::kJpeg:
-      *out = gpu::ImageDecodeAcceleratorType::kJpeg;
-      return true;
-    case gpu::mojom::ImageDecodeAcceleratorType::kUnknown:
-      *out = gpu::ImageDecodeAcceleratorType::kUnknown;
-      return true;
-  }
-  NOTREACHED() << "Invalid ImageDecodeAcceleratorType: " << input;
-  return false;
-}
-
-// static
-gpu::mojom::ImageDecodeAcceleratorSubsampling
-EnumTraits<gpu::mojom::ImageDecodeAcceleratorSubsampling,
-           gpu::ImageDecodeAcceleratorSubsampling>::
-    ToMojom(gpu::ImageDecodeAcceleratorSubsampling subsampling) {
-  switch (subsampling) {
-    case gpu::ImageDecodeAcceleratorSubsampling::k420:
-      return gpu::mojom::ImageDecodeAcceleratorSubsampling::k420;
-    case gpu::ImageDecodeAcceleratorSubsampling::k422:
-      return gpu::mojom::ImageDecodeAcceleratorSubsampling::k422;
-  }
-}
-
-// static
-bool EnumTraits<gpu::mojom::ImageDecodeAcceleratorSubsampling,
-                gpu::ImageDecodeAcceleratorSubsampling>::
-    FromMojom(gpu::mojom::ImageDecodeAcceleratorSubsampling input,
-              gpu::ImageDecodeAcceleratorSubsampling* out) {
-  switch (input) {
-    case gpu::mojom::ImageDecodeAcceleratorSubsampling::k420:
-      *out = gpu::ImageDecodeAcceleratorSubsampling::k420;
-      return true;
-    case gpu::mojom::ImageDecodeAcceleratorSubsampling::k422:
-      *out = gpu::ImageDecodeAcceleratorSubsampling::k422;
-      return true;
-  }
-  NOTREACHED() << "Invalid ImageDecodeAcceleratorSubsampling: " << input;
-  return false;
-}
-
-// static
-bool StructTraits<gpu::mojom::ImageDecodeAcceleratorSupportedProfileDataView,
-                  gpu::ImageDecodeAcceleratorSupportedProfile>::
-    Read(gpu::mojom::ImageDecodeAcceleratorSupportedProfileDataView data,
-         gpu::ImageDecodeAcceleratorSupportedProfile* out) {
-  return data.ReadImageType(&out->image_type) &&
-         data.ReadMinEncodedDimensions(&out->min_encoded_dimensions) &&
-         data.ReadMaxEncodedDimensions(&out->max_encoded_dimensions) &&
-         data.ReadSubsamplings(&out->subsamplings);
-}
-
 #if defined(OS_WIN)
 // static
 gpu::mojom::OverlayFormat
@@ -394,9 +322,7 @@
          data.ReadVideoDecodeAcceleratorCapabilities(
              &out->video_decode_accelerator_capabilities) &&
          data.ReadVideoEncodeAcceleratorSupportedProfiles(
-             &out->video_encode_accelerator_supported_profiles) &&
-         data.ReadImageDecodeAcceleratorSupportedProfiles(
-             &out->image_decode_accelerator_supported_profiles);
+             &out->video_encode_accelerator_supported_profiles);
 }
 
 }  // namespace mojo
--- a/gpu/ipc/common/gpu_info_struct_traits.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/common/gpu_info_struct_traits.h	2019-05-17 18:53:33.068000000 +0300
@@ -141,52 +141,6 @@
   }
 };
 
-template <>
-struct EnumTraits<gpu::mojom::ImageDecodeAcceleratorType,
-                  gpu::ImageDecodeAcceleratorType> {
-  static gpu::mojom::ImageDecodeAcceleratorType ToMojom(
-      gpu::ImageDecodeAcceleratorType image_type);
-  static bool FromMojom(gpu::mojom::ImageDecodeAcceleratorType input,
-                        gpu::ImageDecodeAcceleratorType* out);
-};
-
-template <>
-struct EnumTraits<gpu::mojom::ImageDecodeAcceleratorSubsampling,
-                  gpu::ImageDecodeAcceleratorSubsampling> {
-  static gpu::mojom::ImageDecodeAcceleratorSubsampling ToMojom(
-      gpu::ImageDecodeAcceleratorSubsampling subsampling);
-  static bool FromMojom(gpu::mojom::ImageDecodeAcceleratorSubsampling input,
-                        gpu::ImageDecodeAcceleratorSubsampling* out);
-};
-
-template <>
-struct StructTraits<gpu::mojom::ImageDecodeAcceleratorSupportedProfileDataView,
-                    gpu::ImageDecodeAcceleratorSupportedProfile> {
-  static bool Read(
-      gpu::mojom::ImageDecodeAcceleratorSupportedProfileDataView data,
-      gpu::ImageDecodeAcceleratorSupportedProfile* out);
-
-  static gpu::ImageDecodeAcceleratorType image_type(
-      const gpu::ImageDecodeAcceleratorSupportedProfile& input) {
-    return input.image_type;
-  }
-
-  static const gfx::Size& min_encoded_dimensions(
-      const gpu::ImageDecodeAcceleratorSupportedProfile& input) {
-    return input.min_encoded_dimensions;
-  }
-
-  static const gfx::Size& max_encoded_dimensions(
-      const gpu::ImageDecodeAcceleratorSupportedProfile& input) {
-    return input.max_encoded_dimensions;
-  }
-
-  static std::vector<gpu::ImageDecodeAcceleratorSubsampling> subsamplings(
-      const gpu::ImageDecodeAcceleratorSupportedProfile& input) {
-    return input.subsamplings;
-  }
-};
-
 #if defined(OS_WIN)
 template <>
 struct EnumTraits<gpu::mojom::OverlayFormat, gpu::OverlayFormat> {
@@ -369,11 +323,6 @@
     return input.jpeg_decode_accelerator_supported;
   }
 
-  static std::vector<gpu::ImageDecodeAcceleratorSupportedProfile>
-  image_decode_accelerator_supported_profiles(const gpu::GPUInfo& input) {
-    return input.image_decode_accelerator_supported_profiles;
-  }
-
   static uint64_t system_visual(const gpu::GPUInfo& input) {
 #if defined(USE_X11)
     return input.system_visual;
--- a/gpu/ipc/common/gpu_info.typemap	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/common/gpu_info.typemap	2019-05-17 18:53:33.068000000 +0300
@@ -21,5 +21,4 @@
   "gpu.mojom.VideoDecodeAcceleratorSupportedProfile=gpu::VideoDecodeAcceleratorSupportedProfile",
   "gpu.mojom.VideoDecodeAcceleratorCapabilities=gpu::VideoDecodeAcceleratorCapabilities",
   "gpu.mojom.VideoEncodeAcceleratorSupportedProfile=gpu::VideoEncodeAcceleratorSupportedProfile",
-  "gpu.mojom.ImageDecodeAcceleratorSupportedProfile=gpu::ImageDecodeAcceleratorSupportedProfile",
 ]
--- a/gpu/ipc/common/gpu_memory_buffer_impl_android_hardware_buffer.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/common/gpu_memory_buffer_impl_android_hardware_buffer.cc	2019-05-17 18:53:33.068000000 +0300
@@ -13,7 +13,6 @@
 #include "base/memory/ptr_util.h"
 #include "gpu/ipc/common/gpu_memory_buffer_support.h"
 #include "ui/gfx/geometry/size.h"
-#include "ui/gl/android/android_surface_control_compat.h"
 
 namespace gpu {
 
@@ -36,9 +35,6 @@
     case gfx::BufferFormat::RGBX_8888:
       desc.format = AHARDWAREBUFFER_FORMAT_R8G8B8X8_UNORM;
       break;
-    case gfx::BufferFormat::BGR_565:
-      desc.format = AHARDWAREBUFFER_FORMAT_R5G6B5_UNORM;
-      break;
     default:
       NOTREACHED();
   }
@@ -48,8 +44,6 @@
     case gfx::BufferUsage::SCANOUT:
       desc.usage = AHARDWAREBUFFER_USAGE_GPU_SAMPLED_IMAGE |
                    AHARDWAREBUFFER_USAGE_GPU_COLOR_OUTPUT;
-      if (usage == gfx::BufferUsage::SCANOUT)
-        desc.usage |= gl::SurfaceControl::RequiredUsage();
       break;
     default:
       NOTREACHED();
--- a/gpu/ipc/common/gpu_memory_buffer_impl_android_hardware_buffer_unittest.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/common/gpu_memory_buffer_impl_android_hardware_buffer_unittest.cc	2019-05-17 18:53:33.068000000 +0300
@@ -8,11 +8,11 @@
 namespace gpu {
 namespace {
 
-INSTANTIATE_TYPED_TEST_SUITE_P(GpuMemoryBufferImplAndroidHardwareBuffer,
+INSTANTIATE_TYPED_TEST_CASE_P(GpuMemoryBufferImplAndroidHardwareBuffer,
                                GpuMemoryBufferImplTest,
                                GpuMemoryBufferImplAndroidHardwareBuffer);
 
-INSTANTIATE_TYPED_TEST_SUITE_P(GpuMemoryBufferImplAndroidHardwareBuffer,
+INSTANTIATE_TYPED_TEST_CASE_P(GpuMemoryBufferImplAndroidHardwareBuffer,
                                GpuMemoryBufferImplCreateTest,
                                GpuMemoryBufferImplAndroidHardwareBuffer);
 
--- a/gpu/ipc/common/gpu_memory_buffer_impl_dxgi_unittest.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/common/gpu_memory_buffer_impl_dxgi_unittest.cc	2019-05-17 18:53:33.068000000 +0300
@@ -9,7 +9,7 @@
 namespace {
 
 // Disabled by default as it requires DX11.
-INSTANTIATE_TYPED_TEST_SUITE_P(DISABLED_GpuMemoryBufferImplDXGI,
+INSTANTIATE_TYPED_TEST_CASE_P(DISABLED_GpuMemoryBufferImplDXGI,
                                GpuMemoryBufferImplTest,
                                GpuMemoryBufferImplDXGI);
 }  // namespace
--- a/gpu/ipc/common/gpu_memory_buffer_impl_io_surface_unittest.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/common/gpu_memory_buffer_impl_io_surface_unittest.cc	2019-05-17 18:53:33.068000000 +0300
@@ -8,7 +8,7 @@
 namespace gpu {
 namespace {
 
-INSTANTIATE_TYPED_TEST_SUITE_P(GpuMemoryBufferImplIOSurface,
+INSTANTIATE_TYPED_TEST_CASE_P(GpuMemoryBufferImplIOSurface,
                                GpuMemoryBufferImplTest,
                                GpuMemoryBufferImplIOSurface);
 
--- a/gpu/ipc/common/gpu_memory_buffer_impl_native_pixmap.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/common/gpu_memory_buffer_impl_native_pixmap.cc	2019-05-17 18:53:33.068000000 +0300
@@ -6,7 +6,6 @@
 
 #include <utility>
 
-#include "base/bind.h"
 #include "base/memory/ptr_util.h"
 #include "gpu/ipc/common/gpu_memory_buffer_support.h"
 #include "ui/gfx/buffer_format_util.h"
@@ -36,11 +35,11 @@
     DestructionCallback callback,
     std::unique_ptr<gfx::ClientNativePixmap> pixmap,
     const std::vector<gfx::NativePixmapPlane>& planes,
-    std::vector<base::ScopedFD> fds)
+    base::ScopedFD fd)
     : GpuMemoryBufferImpl(id, size, format, std::move(callback)),
       pixmap_(std::move(pixmap)),
       planes_(planes),
-      fds_(std::move(fds)) {}
+      fd_(std::move(fd)) {}
 
 GpuMemoryBufferImplNativePixmap::~GpuMemoryBufferImplNativePixmap() = default;
 
@@ -53,33 +52,42 @@
     gfx::BufferFormat format,
     gfx::BufferUsage usage,
     DestructionCallback callback) {
-  std::vector<base::ScopedFD> fds;
-  std::vector<base::ScopedFD> dup_fds;
-  for (auto& fd : handle.native_pixmap_handle.fds) {
-    DCHECK(fd.auto_close);
-    // Take ownership of FD
-    fds.emplace_back(fd.fd);
+  // GpuMemoryBufferImpl needs the FD to implement GetHandle() but
+  // gfx::ClientNativePixmapFactory::ImportFromHandle is expected to take
+  // ownership of the FD passed in the handle so we have to dup it here in
+  // order to pass a valid FD to the GpuMemoryBufferImpl ctor.
+  base::ScopedFD scoped_native_pixmap_handle_fd;
+  base::ScopedFD scoped_fd;
+  if (!handle.native_pixmap_handle.fds.empty()) {
+    // Take ownership of FD at index 0.
+    scoped_native_pixmap_handle_fd.reset(handle.native_pixmap_handle.fds[0].fd);
+
+    // Close all remaining FDs.
+    for (size_t i = 1; i < handle.native_pixmap_handle.fds.size(); ++i)
+      base::ScopedFD scoped_fd(handle.native_pixmap_handle.fds[i].fd);
+
     // Duplicate FD for GpuMemoryBufferImplNativePixmap ctor.
-    dup_fds.emplace_back(HANDLE_EINTR(dup(fd.fd)));
-    if (!dup_fds.back().is_valid()) {
+    scoped_fd.reset(HANDLE_EINTR(dup(scoped_native_pixmap_handle_fd.get())));
+    if (!scoped_fd.is_valid()) {
       PLOG(ERROR) << "dup";
       return nullptr;
     }
   }
 
   gfx::NativePixmapHandle native_pixmap_handle;
-  for (auto& fd : dup_fds) {
-    native_pixmap_handle.fds.emplace_back(fd.release(), true /* auto_close */);
+  if (scoped_native_pixmap_handle_fd.is_valid()) {
+    native_pixmap_handle.fds.emplace_back(
+        scoped_native_pixmap_handle_fd.release(), true /* auto_close */);
   }
   native_pixmap_handle.planes = handle.native_pixmap_handle.planes;
   std::unique_ptr<gfx::ClientNativePixmap> native_pixmap =
-      client_native_pixmap_factory->ImportFromHandle(
-          std::move(native_pixmap_handle), size, usage);
+      client_native_pixmap_factory->ImportFromHandle(native_pixmap_handle, size,
+                                                     usage);
   DCHECK(native_pixmap);
 
   return base::WrapUnique(new GpuMemoryBufferImplNativePixmap(
       handle.id, size, format, std::move(callback), std::move(native_pixmap),
-      handle.native_pixmap_handle.planes, std::move(fds)));
+      handle.native_pixmap_handle.planes, std::move(scoped_fd)));
 }
 
 // static
@@ -136,9 +144,8 @@
   handle.type = gfx::NATIVE_PIXMAP;
   handle.id = id_;
   gfx::NativePixmapHandle native_pixmap_handle;
-  for (const auto& fd : fds_) {
-    native_pixmap_handle.fds.emplace_back(fd.get(), false /* auto_close */);
-  }
+  if (fd_.is_valid())
+    native_pixmap_handle.fds.emplace_back(fd_.get(), false /* auto_close */);
   native_pixmap_handle.planes = planes_;
   handle.native_pixmap_handle = gfx::CloneHandleForIPC(native_pixmap_handle);
   return handle;
--- a/gpu/ipc/common/gpu_memory_buffer_impl_native_pixmap.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/common/gpu_memory_buffer_impl_native_pixmap.h	2019-05-17 18:53:33.068000000 +0300
@@ -8,7 +8,6 @@
 #include <stddef.h>
 
 #include <memory>
-#include <vector>
 
 #include "base/macros.h"
 #include "gpu/gpu_export.h"
@@ -58,11 +57,11 @@
       DestructionCallback callback,
       std::unique_ptr<gfx::ClientNativePixmap> native_pixmap,
       const std::vector<gfx::NativePixmapPlane>& planes,
-      std::vector<base::ScopedFD> fds);
+      base::ScopedFD fd);
 
-  const std::unique_ptr<gfx::ClientNativePixmap> pixmap_;
+  std::unique_ptr<gfx::ClientNativePixmap> pixmap_;
   std::vector<gfx::NativePixmapPlane> planes_;
-  std::vector<base::ScopedFD> fds_;
+  base::ScopedFD fd_;
 
   DISALLOW_COPY_AND_ASSIGN(GpuMemoryBufferImplNativePixmap);
 };
--- a/gpu/ipc/common/gpu_memory_buffer_impl_native_pixmap_unittest.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/common/gpu_memory_buffer_impl_native_pixmap_unittest.cc	2019-05-17 18:53:33.068000000 +0300
@@ -8,7 +8,7 @@
 namespace gpu {
 namespace {
 
-INSTANTIATE_TYPED_TEST_SUITE_P(GpuMemoryBufferImplNativePixmap,
+INSTANTIATE_TYPED_TEST_CASE_P(GpuMemoryBufferImplNativePixmap,
                                GpuMemoryBufferImplTest,
                                GpuMemoryBufferImplNativePixmap);
 
--- a/gpu/ipc/common/gpu_memory_buffer_impl_shared_memory_unittest.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/common/gpu_memory_buffer_impl_shared_memory_unittest.cc	2019-05-17 18:53:33.068000000 +0300
@@ -10,11 +10,11 @@
 namespace gpu {
 namespace {
 
-INSTANTIATE_TYPED_TEST_SUITE_P(GpuMemoryBufferImplSharedMemory,
+INSTANTIATE_TYPED_TEST_CASE_P(GpuMemoryBufferImplSharedMemory,
                                GpuMemoryBufferImplTest,
                                GpuMemoryBufferImplSharedMemory);
 
-INSTANTIATE_TYPED_TEST_SUITE_P(GpuMemoryBufferImplSharedMemory,
+INSTANTIATE_TYPED_TEST_CASE_P(GpuMemoryBufferImplSharedMemory,
                                GpuMemoryBufferImplCreateTest,
                                GpuMemoryBufferImplSharedMemory);
 
--- a/gpu/ipc/common/gpu_memory_buffer_impl_test_template.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/common/gpu_memory_buffer_impl_test_template.h	2019-05-17 18:53:33.068000000 +0300
@@ -81,7 +81,7 @@
   GpuMemoryBufferSupport gpu_memory_buffer_support_;
 };
 
-TYPED_TEST_SUITE_P(GpuMemoryBufferImplTest);
+TYPED_TEST_CASE_P(GpuMemoryBufferImplTest);
 
 TYPED_TEST_P(GpuMemoryBufferImplTest, CreateFromHandle) {
   const gfx::Size kBufferSize(8, 8);
@@ -298,13 +298,13 @@
 
 // The GpuMemoryBufferImplTest test case verifies behavior that is expected
 // from a GpuMemoryBuffer implementation in order to be conformant.
-REGISTER_TYPED_TEST_SUITE_P(GpuMemoryBufferImplTest,
+REGISTER_TYPED_TEST_CASE_P(GpuMemoryBufferImplTest,
                             CreateFromHandle,
                             Map,
                             PersistentMap,
                             SerializeAndDeserialize);
 
-TYPED_TEST_SUITE_P(GpuMemoryBufferImplCreateTest);
+TYPED_TEST_CASE_P(GpuMemoryBufferImplCreateTest);
 
 TYPED_TEST_P(GpuMemoryBufferImplCreateTest, Create) {
   const gfx::GpuMemoryBufferId kBufferId(1);
@@ -332,7 +332,7 @@
 // The GpuMemoryBufferImplCreateTest test case verifies behavior that is
 // expected from a GpuMemoryBuffer Create() implementation in order to be
 // conformant.
-REGISTER_TYPED_TEST_SUITE_P(GpuMemoryBufferImplCreateTest, Create);
+REGISTER_TYPED_TEST_CASE_P(GpuMemoryBufferImplCreateTest, Create);
 
 }  // namespace gpu
 
--- a/gpu/ipc/common/gpu_messages.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/common/gpu_messages.h	2019-05-17 18:53:33.068000000 +0300
@@ -112,7 +112,6 @@
   IPC_STRUCT_MEMBER(uint32_t, transfer_cache_entry_id)
   IPC_STRUCT_MEMBER(int32_t, discardable_handle_shm_id)
   IPC_STRUCT_MEMBER(uint32_t, discardable_handle_shm_offset)
-  IPC_STRUCT_MEMBER(uint64_t, discardable_handle_release_count)
   IPC_STRUCT_MEMBER(gfx::ColorSpace, target_color_space)
   IPC_STRUCT_MEMBER(bool, needs_mips)
 IPC_STRUCT_END()
@@ -166,7 +165,7 @@
 IPC_MESSAGE_ROUTED2(
     GpuChannelMsg_ScheduleImageDecode,
     GpuChannelMsg_ScheduleImageDecode_Params /* decode_params */,
-    uint64_t /* decode_release_count */)
+    uint64_t /* release_count */)
 
 // Crash the GPU process in similar way to how chrome://gpucrash does.
 // This is only supported in testing environments, and is otherwise ignored.
@@ -312,10 +311,4 @@
                     uint32_t /* gpu_fence_id */,
                     gfx::GpuFenceHandle)
 
-// Returns a block of data from the GPU process to the renderer.
-// This contains server->client messages produced by dawn_wire and is used to
-// remote WebGPU.
-IPC_MESSAGE_ROUTED1(GpuCommandBufferMsg_ReturnData,
-                    std::vector<uint8_t> /* data */)
-
 #endif  // GPU_IPC_COMMON_GPU_MESSAGES_H_
--- a/gpu/ipc/common/gpu_param_traits_macros.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/common/gpu_param_traits_macros.h	2019-05-17 18:53:33.072000000 +0300
@@ -22,7 +22,7 @@
 IPC_ENUM_TRAITS_MAX_VALUE(gpu::SchedulingPriority,
                           gpu::SchedulingPriority::kLast)
 IPC_ENUM_TRAITS_MAX_VALUE(gpu::ContextResult,
-                          gpu::ContextResult::kLastContextResult)
+                          gpu::ContextResult::kLastContextResult);
 
 IPC_STRUCT_TRAITS_BEGIN(gpu::SwapBuffersCompleteParams)
   IPC_STRUCT_TRAITS_MEMBER(ca_layer_params)
@@ -30,6 +30,6 @@
   IPC_STRUCT_TRAITS_MEMBER(swap_response)
 IPC_STRUCT_TRAITS_END()
 
-IPC_ENUM_TRAITS_MAX_VALUE(viz::ResourceFormat, viz::RESOURCE_FORMAT_MAX)
+IPC_ENUM_TRAITS_MAX_VALUE(viz::ResourceFormat, viz::RESOURCE_FORMAT_MAX);
 
 #endif  // GPU_IPC_COMMON_GPU_PARAM_TRAITS_MACROS_H_
--- a/gpu/ipc/common/gpu_preferences.mojom	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/common/gpu_preferences.mojom	2019-05-17 18:53:33.072000000 +0300
@@ -17,6 +17,8 @@
 
 // gpu::GpuPreferences
 struct GpuPreferences {
+  bool single_process;
+  bool in_process_gpu;
   bool disable_accelerated_video_decode;
   bool disable_accelerated_video_encode;
   bool gpu_startup_dialog;
@@ -32,6 +34,7 @@
   bool enable_media_foundation_vea_on_windows7;
   bool disable_software_rasterizer;
   bool log_gpu_control_list_decisions;
+  bool enable_trace_export_events_to_etw;
 
   bool compile_shader_always_succeeds;
   bool disable_gl_error_limit;
--- a/gpu/ipc/common/gpu_preferences_struct_traits.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/common/gpu_preferences_struct_traits.h	2019-05-17 18:53:33.072000000 +0300
@@ -56,6 +56,8 @@
 struct StructTraits<gpu::mojom::GpuPreferencesDataView, gpu::GpuPreferences> {
   static bool Read(gpu::mojom::GpuPreferencesDataView prefs,
                    gpu::GpuPreferences* out) {
+    out->single_process = prefs.single_process();
+    out->in_process_gpu = prefs.in_process_gpu();
     out->disable_accelerated_video_decode =
         prefs.disable_accelerated_video_decode();
     out->disable_accelerated_video_encode =
@@ -74,6 +76,8 @@
     out->disable_software_rasterizer = prefs.disable_software_rasterizer();
     out->log_gpu_control_list_decisions =
         prefs.log_gpu_control_list_decisions();
+    out->enable_trace_export_events_to_etw =
+        prefs.enable_trace_export_events_to_etw();
     out->compile_shader_always_succeeds =
         prefs.compile_shader_always_succeeds();
     out->disable_gl_error_limit = prefs.disable_gl_error_limit();
@@ -130,6 +134,12 @@
     return true;
   }
 
+  static bool single_process(const gpu::GpuPreferences& prefs) {
+    return prefs.single_process;
+  }
+  static bool in_process_gpu(const gpu::GpuPreferences& prefs) {
+    return prefs.in_process_gpu;
+  }
   static bool disable_accelerated_video_decode(
       const gpu::GpuPreferences& prefs) {
     return prefs.disable_accelerated_video_decode;
@@ -171,6 +181,10 @@
   static bool log_gpu_control_list_decisions(const gpu::GpuPreferences& prefs) {
     return prefs.log_gpu_control_list_decisions;
   }
+  static bool enable_trace_export_events_to_etw(
+      const gpu::GpuPreferences& prefs) {
+    return prefs.enable_trace_export_events_to_etw;
+  }
   static bool compile_shader_always_succeeds(const gpu::GpuPreferences& prefs) {
     return prefs.compile_shader_always_succeeds;
   }
--- a/gpu/ipc/common/struct_traits_unittest.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/common/struct_traits_unittest.cc	2019-05-17 18:53:33.072000000 +0300
@@ -418,8 +418,8 @@
 
 TEST_F(StructTraitsTest, GpuPreferences) {
   GpuPreferences prefs;
-  prefs.gpu_startup_dialog = true;
-  prefs.disable_gpu_watchdog = true;
+  prefs.single_process = true;
+  prefs.in_process_gpu = true;
 #if defined(OS_WIN)
   const GpuPreferences::VpxDecodeVendors vendor =
       GpuPreferences::VPX_VENDOR_AMD;
@@ -430,8 +430,8 @@
   mojom::TraitsTestServicePtr proxy = GetTraitsTestProxy();
   GpuPreferences echo;
   proxy->EchoGpuPreferences(prefs, &echo);
-  EXPECT_TRUE(echo.gpu_startup_dialog);
-  EXPECT_TRUE(echo.disable_gpu_watchdog);
+  EXPECT_TRUE(echo.single_process);
+  EXPECT_TRUE(echo.in_process_gpu);
   EXPECT_TRUE(echo.enable_gpu_driver_debug_logging);
 #if defined(OS_WIN)
   EXPECT_EQ(vendor, echo.enable_accelerated_vpx_decode);
--- a/gpu/ipc/host/gpu_memory_buffer_support.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/host/gpu_memory_buffer_support.cc	2019-05-17 18:53:33.076000000 +0300
@@ -88,8 +88,6 @@
 
 bool GetImageNeedsPlatformSpecificTextureTarget(gfx::BufferFormat format,
                                                 gfx::BufferUsage usage) {
-  if (!NativeBufferNeedsPlatformSpecificTextureTarget(format))
-    return false;
 #if defined(USE_OZONE) || defined(OS_MACOSX) || defined(OS_WIN) || \
     defined(OS_ANDROID)
   GpuMemoryBufferSupport support;
--- a/gpu/ipc/host/shader_disk_cache.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/host/shader_disk_cache.cc	2019-05-17 18:53:33.076000000 +0300
@@ -4,10 +4,8 @@
 
 #include "gpu/ipc/host/shader_disk_cache.h"
 
-#include "base/bind.h"
 #include "base/command_line.h"
 #include "base/macros.h"
-#include "base/memory/ref_counted.h"
 #include "base/strings/string_number_conversions.h"
 #include "base/system/sys_info.h"
 #include "base/threading/thread_checker.h"
@@ -147,20 +145,19 @@
 };
 
 // When the cache is asked to open an entry an Entry** is passed to it. The
-// underlying Entry* must stay alive for the duration of the call, so it is ref
-// counted. If the underlying state machine is deleted before the callback runs,
-// close the entry.
+// underying Entry* must stay alive for the duration of the call, so it is
+// owned by the callback. If the underlying state machine is deleted before
+// the callback runs, close the entry.
 template <typename T>
-void OnEntryOpenComplete(
-    base::WeakPtr<T> state_machine,
-    scoped_refptr<base::RefCountedData<disk_cache::Entry*>> entry_ptr,
+void OnEntryOpenComplete(base::WeakPtr<T> state_machine,
+                         std::unique_ptr<disk_cache::Entry*> entry,
     int rv) {
   if (!state_machine) {
     if (rv == net::OK)
-      entry_ptr->data->Close();
+      (*entry)->Close();
     return;
   }
-  state_machine->set_entry(entry_ptr->data);
+  state_machine->set_entry(*entry);
   state_machine->OnOpComplete(rv);
 }
 
@@ -188,18 +185,19 @@
 void ShaderDiskCacheEntry::Cache() {
   DCHECK(CalledOnValidThread());
 
-  // The Entry* passed to the cache may be used after this class is deleted or
-  // after the callback is deleted, so make it ref counted.
-  auto entry_ptr =
-      base::MakeRefCounted<base::RefCountedData<disk_cache::Entry*>>();
-  auto callback = base::BindOnce(&OnEntryOpenComplete<ShaderDiskCacheEntry>,
-                                 weak_ptr_factory_.GetWeakPtr(), entry_ptr);
+  // The Entry* passed to the cache must stay alive even if this class is
+  // deleted, so store it in the callback.
+  auto entry = std::make_unique<disk_cache::Entry*>(nullptr);
+  disk_cache::Entry** closure_owned_entry_ptr = entry.get();
+  auto callback = base::Bind(&OnEntryOpenComplete<ShaderDiskCacheEntry>,
+                             weak_ptr_factory_.GetWeakPtr(),
+                             base::Passed(std::move(entry)));
 
-  int rv = cache_->backend()->OpenEntry(key_, net::HIGHEST, &entry_ptr->data,
-                                        std::move(callback));
+  int rv = cache_->backend()->OpenEntry(key_, net::HIGHEST,
+                                        closure_owned_entry_ptr, callback);
 
   if (rv != net::ERR_IO_PENDING) {
-    entry_ = entry_ptr->data;
+    entry_ = *closure_owned_entry_ptr;
     OnOpComplete(rv);
   }
 }
@@ -237,18 +235,19 @@
 
   op_type_ = CREATE_ENTRY;
 
-  // The Entry* passed to the cache may be used after this class is deleted or
-  // after the callback is deleted, so make it ref counted.
-  auto entry_ptr =
-      base::MakeRefCounted<base::RefCountedData<disk_cache::Entry*>>();
-  auto callback = base::BindOnce(&OnEntryOpenComplete<ShaderDiskCacheEntry>,
-                                 weak_ptr_factory_.GetWeakPtr(), entry_ptr);
+  // The Entry* passed to the cache must stay alive even if this class is
+  // deleted, so store it in the callback.
+  auto entry = std::make_unique<disk_cache::Entry*>(nullptr);
+  disk_cache::Entry** closure_owned_entry_ptr = entry.get();
+  auto callback = base::Bind(&OnEntryOpenComplete<ShaderDiskCacheEntry>,
+                             weak_ptr_factory_.GetWeakPtr(),
+                             base::Passed(std::move(entry)));
 
   int create_rv = cache_->backend()->CreateEntry(
-      key_, net::HIGHEST, &entry_ptr->data, std::move(callback));
+      key_, net::HIGHEST, closure_owned_entry_ptr, callback);
 
   if (create_rv != net::ERR_IO_PENDING)
-    entry_ = entry_ptr->data;
+    entry_ = *closure_owned_entry_ptr;
   return create_rv;
 }
 
@@ -263,7 +262,7 @@
   op_type_ = WRITE_DATA;
   auto io_buf = base::MakeRefCounted<net::StringIOBuffer>(shader_);
   return entry_->WriteData(1, 0, io_buf.get(), shader_.length(),
-                           base::BindOnce(&ShaderDiskCacheEntry::OnOpComplete,
+                           base::Bind(&ShaderDiskCacheEntry::OnOpComplete,
                                           weak_ptr_factory_.GetWeakPtr()),
                            false);
 }
@@ -328,17 +327,18 @@
   if (!iter_)
     iter_ = cache_->backend()->CreateIterator();
 
-  // The Entry* passed to the cache may be used after this class is deleted or
-  // after the callback is deleted, so make it ref counted.
-  auto entry_ptr =
-      base::MakeRefCounted<base::RefCountedData<disk_cache::Entry*>>();
-  auto callback = base::BindOnce(&OnEntryOpenComplete<ShaderDiskReadHelper>,
-                                 weak_ptr_factory_.GetWeakPtr(), entry_ptr);
+  // The Entry* passed to the cache must stay alive even if this class is
+  // deleted, so store it in the callback.
+  auto entry = std::make_unique<disk_cache::Entry*>(nullptr);
+  disk_cache::Entry** closure_owned_entry_ptr = entry.get();
+  auto callback = base::Bind(&OnEntryOpenComplete<ShaderDiskReadHelper>,
+                             weak_ptr_factory_.GetWeakPtr(),
+                             base::Passed(std::move(entry)));
 
-  int rv = iter_->OpenNextEntry(&entry_ptr->data, std::move(callback));
+  int rv = iter_->OpenNextEntry(closure_owned_entry_ptr, callback);
 
   if (rv != net::ERR_IO_PENDING)
-    entry_ = entry_ptr->data;
+    entry_ = *closure_owned_entry_ptr;
   return rv;
 }
 
@@ -356,7 +356,7 @@
   op_type_ = READ_COMPLETE;
   buf_ = base::MakeRefCounted<net::IOBufferWithSize>(entry_->GetDataSize(1));
   return entry_->ReadData(1, 0, buf_.get(), buf_->size(),
-                          base::BindOnce(&ShaderDiskReadHelper::OnOpComplete,
+                          base::Bind(&ShaderDiskReadHelper::OnOpComplete,
                                          weak_ptr_factory_.GetWeakPtr()));
 }
 
@@ -415,14 +415,13 @@
     switch (op_type_) {
       case VERIFY_CACHE_SETUP:
         rv = cache_->SetAvailableCallback(
-            base::BindRepeating(&ShaderClearHelper::DoClearShaderCache,
+            base::Bind(&ShaderClearHelper::DoClearShaderCache,
                                 weak_ptr_factory_.GetWeakPtr()));
         op_type_ = DELETE_CACHE;
         break;
       case DELETE_CACHE:
-        rv = cache_->Clear(
-            delete_begin_, delete_end_,
-            base::BindRepeating(&ShaderClearHelper::DoClearShaderCache,
+        rv = cache_->Clear(delete_begin_, delete_end_,
+                           base::Bind(&ShaderClearHelper::DoClearShaderCache,
                                 weak_ptr_factory_.GetWeakPtr()));
         op_type_ = TERMINATE;
         break;
@@ -575,7 +574,7 @@
   int rv = disk_cache::CreateCacheBackend(
       net::SHADER_CACHE, net::CACHE_BACKEND_DEFAULT,
       cache_path_.Append(kGpuCachePath), CacheSizeBytes(), true, nullptr,
-      &backend_, base::BindOnce(&ShaderDiskCache::CacheCreatedCallback, this));
+      &backend_, base::Bind(&ShaderDiskCache::CacheCreatedCallback, this));
 
   if (rv == net::OK)
     cache_available_ = true;
--- a/gpu/ipc/host/shader_disk_cache_unittest.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/host/shader_disk_cache_unittest.cc	2019-05-17 18:53:33.076000000 +0300
@@ -76,7 +76,7 @@
   rv = cache->Clear(time, time, clear_cb.callback());
   ASSERT_EQ(net::OK, clear_cb.GetResult(rv));
   EXPECT_EQ(0, cache->Size());
-}
+};
 
 // For https://crbug.com/663589.
 TEST_F(ShaderDiskCacheTest, SafeToDeleteCacheMidEntryOpen) {
@@ -103,7 +103,7 @@
   net::TestCompletionCallback available_cb2;
   int rv2 = cache->SetAvailableCallback(available_cb2.callback());
   ASSERT_EQ(net::OK, available_cb2.GetResult(rv2));
-}
+};
 
 TEST_F(ShaderDiskCacheTest, MultipleLoaderCallbacks) {
   InitCache();
@@ -138,6 +138,6 @@
   int rv2 = cache->SetAvailableCallback(available_cb2.callback());
   ASSERT_EQ(net::OK, available_cb2.GetResult(rv2));
   EXPECT_EQ(count, loaded_calls);
-}
+};
 
 }  // namespace gpu
--- a/gpu/ipc/in_process_command_buffer.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/in_process_command_buffer.cc	2019-05-17 18:53:33.076000000 +0300
@@ -54,6 +54,7 @@
 #include "gpu/command_buffer/service/shared_context_state.h"
 #include "gpu/command_buffer/service/shared_image_factory.h"
 #include "gpu/command_buffer/service/sync_point_manager.h"
+#include "gpu/command_buffer/service/transfer_buffer_manager.h"
 #include "gpu/command_buffer/service/webgpu_decoder.h"
 #include "gpu/config/gpu_crash_keys.h"
 #include "gpu/config/gpu_feature_info.h"
@@ -388,6 +389,10 @@
     return gpu::ContextResult::kTransientFailure;
   }
 
+  // TODO(crbug.com/832243): This could use the TransferBufferManager owned by
+  // |context_group_| instead.
+  transfer_buffer_manager_ = std::make_unique<TransferBufferManager>(nullptr);
+
   GpuDriverBugWorkarounds workarounds(
       task_executor_->gpu_feature_info().enabled_gpu_driver_bug_workarounds);
 
@@ -406,13 +411,8 @@
           base::ThreadTaskRunnerHandle::Get());
     }
 
-    gpu::GpuFeatureInfo gpu_feature_info = task_executor_->gpu_feature_info();
-    if (params.attribs.backed_by_surface_texture) {
-      gpu_feature_info.status_values[GPU_FEATURE_TYPE_ANDROID_SURFACE_CONTROL] =
-          kGpuFeatureStatusDisabled;
-    }
-    auto feature_info =
-        base::MakeRefCounted<gles2::FeatureInfo>(workarounds, gpu_feature_info);
+    auto feature_info = base::MakeRefCounted<gles2::FeatureInfo>(
+        workarounds, task_executor_->gpu_feature_info());
     context_group_ = base::MakeRefCounted<gles2::ContextGroup>(
         task_executor_->gpu_preferences(),
         gles2::PassthroughCommandDecoderSupported(),
@@ -448,7 +448,7 @@
                                                                         : "0");
 
   command_buffer_ = std::make_unique<CommandBufferService>(
-      this, context_group_->memory_tracker());
+      this, transfer_buffer_manager_.get());
 
   if (!surface_) {
     if (params.is_offscreen) {
@@ -604,9 +604,7 @@
 
       decoder_.reset(raster::RasterDecoder::Create(
           this, command_buffer_.get(), task_executor_->outputter(),
-          task_executor_->gpu_feature_info(), task_executor_->gpu_preferences(),
-          context_group_->memory_tracker(),
-          task_executor_->shared_image_manager(), context_state_));
+          context_group_.get(), context_state_));
     } else {
       decoder_.reset(gles2::GLES2Decoder::Create(this, command_buffer_.get(),
                                                  task_executor_->outputter(),
@@ -681,9 +679,6 @@
 
   image_factory_ = params.image_factory;
 
-  if (gpu_channel_manager_delegate_)
-    gpu_channel_manager_delegate_->DidCreateContextSuccessfully();
-
   return gpu::ContextResult::kSuccess;
 }
 
@@ -731,6 +726,7 @@
     decoder_.reset();
   }
   command_buffer_.reset();
+  transfer_buffer_manager_.reset();
   surface_ = nullptr;
 
   context_ = nullptr;
@@ -1200,14 +1196,6 @@
     gr_cache_controller_->ScheduleGrContextCleanup();
 }
 
-void InProcessCommandBuffer::HandleReturnData(base::span<const uint8_t> data) {
-  DCHECK_CALLED_ON_VALID_SEQUENCE(gpu_sequence_checker_);
-  std::vector<uint8_t> vec(data.data(), data.data() + data.size());
-  PostOrRunClientCallback(base::BindOnce(
-      &InProcessCommandBuffer::HandleReturnDataOnOriginThread,
-      client_thread_weak_ptr_factory_.GetWeakPtr(), std::move(vec)));
-}
-
 void InProcessCommandBuffer::PostOrRunClientCallback(
     base::OnceClosure callback) {
   DCHECK_CALLED_ON_VALID_SEQUENCE(gpu_sequence_checker_);
@@ -1566,14 +1554,6 @@
   }
 }
 
-void InProcessCommandBuffer::HandleReturnDataOnOriginThread(
-    std::vector<uint8_t> data) {
-  DCHECK_CALLED_ON_VALID_SEQUENCE(client_sequence_checker_);
-  if (gpu_control_client_) {
-    gpu_control_client_->OnGpuControlReturnData(data);
-  }
-}
-
 void InProcessCommandBuffer::SetUpdateVSyncParametersCallback(
     const UpdateVSyncParametersCallback& callback) {
   DCHECK_CALLED_ON_VALID_SEQUENCE(client_sequence_checker_);
--- a/gpu/ipc/in_process_command_buffer.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/in_process_command_buffer.h	2019-05-17 18:53:33.076000000 +0300
@@ -64,6 +64,7 @@
 class SharedImageFactory;
 class SharedImageInterface;
 class SyncPointClientState;
+class TransferBufferManager;
 struct ContextCreationAttribs;
 struct SwapBuffersCompleteParams;
 
@@ -156,7 +157,6 @@
   void OnRescheduleAfterFinished() override;
   void OnSwapBuffers(uint64_t swap_id, uint32_t flags) override;
   void ScheduleGrContextCleanup() override;
-  void HandleReturnData(base::span<const uint8_t> data) override;
 
 // ImageTransportSurfaceDelegate implementation:
 #if defined(OS_WIN)
@@ -309,8 +309,6 @@
                                      uint32_t flags,
                                      const gfx::PresentationFeedback& feedback);
 
-  void HandleReturnDataOnOriginThread(std::vector<uint8_t> data);
-
   const CommandBufferId command_buffer_id_;
 
   // Members accessed on the gpu thread (possibly with the exception of
@@ -318,6 +316,7 @@
   bool use_virtualized_gl_context_ = false;
   raster::GrShaderCache* gr_shader_cache_ = nullptr;
   scoped_refptr<base::SingleThreadTaskRunner> origin_task_runner_;
+  std::unique_ptr<TransferBufferManager> transfer_buffer_manager_;
   std::unique_ptr<CommandBufferService> command_buffer_;
   std::unique_ptr<DecoderContext> decoder_;
   base::Optional<raster::GrCacheController> gr_cache_controller_;
--- a/gpu/ipc/in_process_gpu_thread_holder.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/in_process_gpu_thread_holder.cc	2019-05-17 18:53:33.076000000 +0300
@@ -4,7 +4,6 @@
 
 #include "gpu/ipc/in_process_gpu_thread_holder.h"
 
-#include "base/bind.h"
 #include "base/command_line.h"
 #include "base/synchronization/waitable_event.h"
 #include "base/threading/thread_task_runner_handle.h"
@@ -83,7 +82,6 @@
   task_executor_.reset();
   scheduler_.reset();
   sync_point_manager_.reset();
-  shared_image_manager_.reset();
 }
 
 }  // namespace gpu
--- a/gpu/ipc/raster_in_process_context.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/raster_in_process_context.cc	2019-05-17 18:53:33.076000000 +0300
@@ -6,7 +6,6 @@
 
 #include <utility>
 
-#include "base/bind.h"
 #include "base/command_line.h"
 #include "base/logging.h"
 #include "base/test/test_simple_task_runner.h"
--- a/gpu/ipc/service/child_window_win.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/service/child_window_win.cc	2019-05-17 18:53:33.076000000 +0300
@@ -6,7 +6,6 @@
 
 #include <memory>
 
-#include "base/bind.h"
 #include "base/compiler_specific.h"
 #include "base/memory/weak_ptr.h"
 #include "base/message_loop/message_loop.h"
--- a/gpu/ipc/service/command_buffer_stub.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/service/command_buffer_stub.cc	2019-05-17 18:53:33.076000000 +0300
@@ -13,16 +13,20 @@
 #include "base/macros.h"
 #include "base/memory/ptr_util.h"
 #include "base/memory/shared_memory.h"
-#include "base/no_destructor.h"
 #include "base/single_thread_task_runner.h"
 #include "base/time/time.h"
 #include "base/trace_event/trace_event.h"
 #include "build/build_config.h"
 #include "gpu/command_buffer/common/constants.h"
 #include "gpu/command_buffer/common/gpu_memory_buffer_support.h"
+#include "gpu/command_buffer/common/mailbox.h"
 #include "gpu/command_buffer/common/sync_token.h"
 #include "gpu/command_buffer/service/decoder_context.h"
+#include "gpu/command_buffer/service/gl_context_virtual.h"
+#include "gpu/command_buffer/service/gl_state_restorer_impl.h"
 #include "gpu/command_buffer/service/gpu_command_buffer_memory_tracker.h"
+#include "gpu/command_buffer/service/gpu_fence_manager.h"
+#include "gpu/command_buffer/service/image_manager.h"
 #include "gpu/command_buffer/service/logger.h"
 #include "gpu/command_buffer/service/mailbox_manager.h"
 #include "gpu/command_buffer/service/memory_tracking.h"
@@ -30,13 +34,17 @@
 #include "gpu/command_buffer/service/scheduler.h"
 #include "gpu/command_buffer/service/service_utils.h"
 #include "gpu/command_buffer/service/sync_point_manager.h"
+#include "gpu/command_buffer/service/transfer_buffer_manager.h"
 #include "gpu/config/gpu_crash_keys.h"
 #include "gpu/ipc/common/gpu_messages.h"
 #include "gpu/ipc/service/gpu_channel.h"
 #include "gpu/ipc/service/gpu_channel_manager.h"
 #include "gpu/ipc/service/gpu_channel_manager_delegate.h"
+#include "gpu/ipc/service/gpu_memory_buffer_factory.h"
 #include "gpu/ipc/service/gpu_watchdog_thread.h"
 #include "gpu/ipc/service/image_transport_surface.h"
+#include "ui/gfx/gpu_fence.h"
+#include "ui/gfx/gpu_fence_handle.h"
 #include "ui/gl/gl_bindings.h"
 #include "ui/gl/gl_context.h"
 #include "ui/gl/gl_image.h"
@@ -132,7 +140,6 @@
     int32_t stream_id,
     int32_t route_id)
     : channel_(channel),
-      context_type_(init_params.attribs.context_type),
       active_url_(init_params.active_url),
       active_url_hash_(base::Hash(active_url_.possibly_invalid_spec())),
       initialized_(false),
@@ -177,30 +184,35 @@
     have_context = true;
   }
 
-  bool handled = HandleMessage(message);
-  if (!handled) {
-    handled = true;
-    // Always use IPC_MESSAGE_HANDLER_DELAY_REPLY for synchronous message
-    // handlers here. This is so the reply can be delayed if the scheduler is
-    // unscheduled.
+  // Always use IPC_MESSAGE_HANDLER_DELAY_REPLY for synchronous message handlers
+  // here. This is so the reply can be delayed if the scheduler is unscheduled.
+  bool handled = true;
     IPC_BEGIN_MESSAGE_MAP(CommandBufferStub, message)
       IPC_MESSAGE_HANDLER(GpuCommandBufferMsg_SetGetBuffer, OnSetGetBuffer);
+    IPC_MESSAGE_HANDLER(GpuCommandBufferMsg_TakeFrontBuffer, OnTakeFrontBuffer);
+    IPC_MESSAGE_HANDLER(GpuCommandBufferMsg_ReturnFrontBuffer,
+                        OnReturnFrontBuffer);
       IPC_MESSAGE_HANDLER_DELAY_REPLY(GpuCommandBufferMsg_WaitForTokenInRange,
                                       OnWaitForTokenInRange);
-      IPC_MESSAGE_HANDLER_DELAY_REPLY(
-          GpuCommandBufferMsg_WaitForGetOffsetInRange,
+    IPC_MESSAGE_HANDLER_DELAY_REPLY(GpuCommandBufferMsg_WaitForGetOffsetInRange,
           OnWaitForGetOffsetInRange);
       IPC_MESSAGE_HANDLER(GpuCommandBufferMsg_AsyncFlush, OnAsyncFlush);
       IPC_MESSAGE_HANDLER(GpuCommandBufferMsg_RegisterTransferBuffer,
                           OnRegisterTransferBuffer);
       IPC_MESSAGE_HANDLER(GpuCommandBufferMsg_DestroyTransferBuffer,
                           OnDestroyTransferBuffer);
-      IPC_MESSAGE_HANDLER(GpuCommandBufferMsg_SignalSyncToken,
-                          OnSignalSyncToken)
+    IPC_MESSAGE_HANDLER(GpuCommandBufferMsg_SignalSyncToken, OnSignalSyncToken)
       IPC_MESSAGE_HANDLER(GpuCommandBufferMsg_SignalQuery, OnSignalQuery)
+    IPC_MESSAGE_HANDLER(GpuCommandBufferMsg_CreateImage, OnCreateImage);
+    IPC_MESSAGE_HANDLER(GpuCommandBufferMsg_DestroyImage, OnDestroyImage);
+    IPC_MESSAGE_HANDLER(GpuCommandBufferMsg_CreateStreamTexture,
+                        OnCreateStreamTexture)
+    IPC_MESSAGE_HANDLER(GpuCommandBufferMsg_CreateGpuFenceFromHandle,
+                        OnCreateGpuFenceFromHandle)
+    IPC_MESSAGE_HANDLER(GpuCommandBufferMsg_GetGpuFenceHandle,
+                        OnGetGpuFenceHandle)
       IPC_MESSAGE_UNHANDLED(handled = false)
     IPC_END_MESSAGE_MAP()
-  }
 
   CheckCompleteWaits();
 
@@ -405,6 +417,16 @@
   command_buffer_.reset();
 }
 
+void CommandBufferStub::OnCreateStreamTexture(uint32_t texture_id,
+                                              int32_t stream_id,
+                                              bool* succeeded) {
+#if defined(OS_ANDROID)
+  *succeeded = StreamTexture::Create(this, texture_id, stream_id);
+#else
+  *succeeded = false;
+#endif
+}
+
 void CommandBufferStub::OnSetGetBuffer(int32_t shm_id) {
   TRACE_EVENT0("gpu", "CommandBufferStub::OnSetGetBuffer");
   if (command_buffer_)
@@ -528,8 +550,7 @@
   CommandBuffer::State pre_state = command_buffer_->GetState();
   FastSetActiveURL(active_url_, active_url_hash_, channel_);
 
-  MailboxManager* mailbox_manager =
-      channel_->gpu_channel_manager()->mailbox_manager();
+  MailboxManager* mailbox_manager = context_group_->mailbox_manager();
   if (mailbox_manager->UsesSync()) {
     for (const auto& sync_token : sync_token_fences)
       mailbox_manager->PullTextureUpdates(sync_token);
@@ -612,11 +633,54 @@
     OnSignalAck(id);
   }
 }
+
+void CommandBufferStub::OnCreateGpuFenceFromHandle(
+    uint32_t gpu_fence_id,
+    const gfx::GpuFenceHandle& handle) {
+  if (!context_group_->feature_info()->feature_flags().chromium_gpu_fence) {
+    DLOG(ERROR) << "CHROMIUM_gpu_fence unavailable";
+    command_buffer_->SetParseError(error::kLostContext);
+    return;
+  }
+
+  if (decoder_context_->GetGpuFenceManager()->CreateGpuFenceFromHandle(
+          gpu_fence_id, handle))
+    return;
+
+  // The insertion failed. This shouldn't happen, force context loss to avoid
+  // inconsistent state.
+  command_buffer_->SetParseError(error::kLostContext);
+  CheckContextLost();
+}
+
+void CommandBufferStub::OnGetGpuFenceHandle(uint32_t gpu_fence_id) {
+  if (!context_group_->feature_info()->feature_flags().chromium_gpu_fence) {
+    DLOG(ERROR) << "CHROMIUM_gpu_fence unavailable";
+    command_buffer_->SetParseError(error::kLostContext);
+    return;
+  }
+
+  auto* manager = decoder_context_->GetGpuFenceManager();
+  gfx::GpuFenceHandle handle;
+  if (manager->IsValidGpuFence(gpu_fence_id)) {
+    std::unique_ptr<gfx::GpuFence> gpu_fence =
+        manager->GetGpuFence(gpu_fence_id);
+    handle = gfx::CloneHandleForIPC(gpu_fence->GetGpuFenceHandle());
+  } else {
+    // Retrieval failed. This shouldn't happen, force context loss to avoid
+    // inconsistent state.
+    DLOG(ERROR) << "GpuFence not found";
+    command_buffer_->SetParseError(error::kLostContext);
+    CheckContextLost();
+  }
+  Send(new GpuCommandBufferMsg_GetGpuFenceHandleComplete(route_id_,
+                                                         gpu_fence_id, handle));
+}
+
 void CommandBufferStub::OnFenceSyncRelease(uint64_t release) {
   SyncToken sync_token(CommandBufferNamespace::GPU_IO, command_buffer_id_,
                        release);
-  MailboxManager* mailbox_manager =
-      channel_->gpu_channel_manager()->mailbox_manager();
+  MailboxManager* mailbox_manager = context_group_->mailbox_manager();
   if (mailbox_manager->UsesSync() && MakeCurrent())
     mailbox_manager->PushTextureUpdates(sync_token);
 
@@ -643,11 +707,53 @@
   channel_->gpu_channel_manager()->ScheduleGrContextCleanup();
 }
 
-void CommandBufferStub::HandleReturnData(base::span<const uint8_t> data) {
-  std::vector<uint8_t> vec(data.begin(), data.end());
-  IPC::Message* msg =
-      new GpuCommandBufferMsg_ReturnData(route_id_, std::move(vec));
-  Send(msg);
+void CommandBufferStub::OnCreateImage(
+    GpuCommandBufferMsg_CreateImage_Params params) {
+  TRACE_EVENT0("gpu", "CommandBufferStub::OnCreateImage");
+  const int32_t id = params.id;
+  const gfx::Size& size = params.size;
+  const gfx::BufferFormat& format = params.format;
+  const uint64_t image_release_count = params.image_release_count;
+
+  gles2::ImageManager* image_manager = channel_->image_manager();
+  DCHECK(image_manager);
+  if (image_manager->LookupImage(id)) {
+    LOG(ERROR) << "Image already exists with same ID.";
+    return;
+  }
+
+  if (!gpu::IsImageFromGpuMemoryBufferFormatSupported(
+          format, decoder_context_->GetCapabilities())) {
+    LOG(ERROR) << "Format is not supported.";
+    return;
+  }
+
+  if (!gpu::IsImageSizeValidForGpuMemoryBufferFormat(size, format)) {
+    LOG(ERROR) << "Invalid image size for format.";
+    return;
+  }
+
+  scoped_refptr<gl::GLImage> image = channel()->CreateImageForGpuMemoryBuffer(
+      std::move(params.gpu_memory_buffer), size, format, surface_handle_);
+  if (!image.get())
+    return;
+
+  image_manager->AddImage(image.get(), id);
+  if (image_release_count)
+    sync_point_client_state_->ReleaseFenceSync(image_release_count);
+}
+
+void CommandBufferStub::OnDestroyImage(int32_t id) {
+  TRACE_EVENT0("gpu", "CommandBufferStub::OnDestroyImage");
+
+  gles2::ImageManager* image_manager = channel_->image_manager();
+  DCHECK(image_manager);
+  if (!image_manager->LookupImage(id)) {
+    LOG(ERROR) << "Image with ID doesn't exist.";
+    return;
+  }
+
+  image_manager->RemoveImage(id);
 }
 
 void CommandBufferStub::OnConsoleMessage(int32_t id,
@@ -676,31 +782,15 @@
 }
 
 std::unique_ptr<MemoryTracker> CommandBufferStub::CreateMemoryTracker(
-    const GPUCreateCommandBufferConfig& init_params) const {
-  MemoryTrackerFactory current_factory = GetMemoryTrackerFactory();
-  if (current_factory)
-    return current_factory.Run(init_params);
-
+    const GPUCreateCommandBufferConfig init_params) const {
   return std::make_unique<GpuCommandBufferMemoryTracker>(
       channel_->client_id(), channel_->client_tracing_id(),
       command_buffer_id_.GetUnsafeValue(), init_params.attribs.context_type,
       channel_->task_runner());
 }
 
-// static
-void CommandBufferStub::SetMemoryTrackerFactoryForTesting(
-    MemoryTrackerFactory factory) {
-  SetOrGetMemoryTrackerFactory(factory);
-}
-
-scoped_refptr<Buffer> CommandBufferStub::GetTransferBuffer(int32_t id) {
-  return command_buffer_->GetTransferBuffer(id);
-}
-
-void CommandBufferStub::RegisterTransferBufferForTest(
-    int32_t id,
-    scoped_refptr<Buffer> buffer) {
-  command_buffer_->RegisterTransferBuffer(id, std::move(buffer));
+MemoryTracker* CommandBufferStub::GetMemoryTracker() const {
+  return context_group_->memory_tracker();
 }
 
 bool CommandBufferStub::CheckContextLost() {
@@ -730,20 +820,4 @@
   command_buffer_->SetParseError(error::kLostContext);
 }
 
-// static
-CommandBufferStub::MemoryTrackerFactory
-CommandBufferStub::GetMemoryTrackerFactory() {
-  return SetOrGetMemoryTrackerFactory(base::NullCallback());
-}
-
-// static
-CommandBufferStub::MemoryTrackerFactory
-CommandBufferStub::SetOrGetMemoryTrackerFactory(MemoryTrackerFactory factory) {
-  static base::NoDestructor<MemoryTrackerFactory> current_factory{
-      base::NullCallback()};
-  if (factory)
-    *current_factory = factory;
-  return *current_factory;
-}
-
 }  // namespace gpu
--- a/gpu/ipc/service/command_buffer_stub.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/service/command_buffer_stub.h	2019-05-17 18:53:33.076000000 +0300
@@ -12,7 +12,6 @@
 #include <string>
 #include <vector>
 
-#include "base/callback.h"
 #include "base/macros.h"
 #include "base/memory/weak_ptr.h"
 #include "base/observer_list.h"
@@ -31,6 +30,7 @@
 #include "ipc/ipc_listener.h"
 #include "ipc/ipc_sender.h"
 #include "ui/gfx/geometry/size.h"
+#include "ui/gfx/gpu_fence_handle.h"
 #include "ui/gfx/gpu_memory_buffer.h"
 #include "ui/gfx/swap_result.h"
 #include "ui/gl/gl_share_group.h"
@@ -39,10 +39,11 @@
 #include "url/gurl.h"
 
 struct GPUCreateCommandBufferConfig;
+struct GpuCommandBufferMsg_CreateImage_Params;
 
 namespace gpu {
 class DecoderContext;
-class MemoryTracker;
+struct Mailbox;
 struct SyncToken;
 struct WaitForCommandState;
 class GpuChannel;
@@ -83,8 +84,6 @@
       const GPUCreateCommandBufferConfig& init_params,
       base::UnsafeSharedMemoryRegion shared_state_shm) = 0;
 
-  virtual MemoryTracker* GetMemoryTracker() const = 0;
-
   // IPC::Listener implementation:
   bool OnMessageReceived(const IPC::Message& message) override;
 
@@ -102,18 +101,8 @@
   void OnDescheduleUntilFinished() override;
   void OnRescheduleAfterFinished() override;
   void ScheduleGrContextCleanup() override;
-  void HandleReturnData(base::span<const uint8_t> data) override;
-
-  using MemoryTrackerFactory =
-      base::RepeatingCallback<std::unique_ptr<MemoryTracker>(
-          const GPUCreateCommandBufferConfig&)>;
-
-  // Overrides the way CreateMemoryTracker() uses to create a MemoryTracker.
-  // This is intended for mocking the MemoryTracker in tests.
-  static void SetMemoryTrackerFactoryForTesting(MemoryTrackerFactory factory);
 
-  scoped_refptr<Buffer> GetTransferBuffer(int32_t id);
-  void RegisterTransferBufferForTest(int32_t id, scoped_refptr<Buffer> buffer);
+  MemoryTracker* GetMemoryTracker() const;
 
   // Whether this command buffer can currently handle IPC messages.
   bool IsScheduled();
@@ -133,17 +122,15 @@
 
   gl::GLSurface* surface() const { return surface_.get(); }
 
-  ContextType context_type() const { return context_type_; }
-
   void AddDestructionObserver(DestructionObserver* observer);
   void RemoveDestructionObserver(DestructionObserver* observer);
 
   void MarkContextLost();
 
+  scoped_refptr<gles2::ContextGroup> context_group() { return context_group_; }
   scoped_refptr<gl::GLShareGroup> share_group() { return share_group_; }
 
  protected:
-  virtual bool HandleMessage(const IPC::Message& message) = 0;
   // FastSetActiveURL will shortcut the expensive call to SetActiveURL when the
   // url_hash matches.
   static void FastSetActiveURL(const GURL& url,
@@ -151,24 +138,25 @@
                                GpuChannel* channel);
 
   std::unique_ptr<MemoryTracker> CreateMemoryTracker(
-      const GPUCreateCommandBufferConfig& init_params) const;
+      const GPUCreateCommandBufferConfig init_params) const;
 
   // Must be called during Initialize(). Takes ownership to co-ordinate
   // teardown in Destroy().
   void set_decoder_context(std::unique_ptr<DecoderContext> decoder_context) {
     decoder_context_ = std::move(decoder_context);
   }
-  bool CheckContextLost();
 
   // The lifetime of objects of this class is managed by a GpuChannel. The
   // GpuChannels destroy all the CommandBufferStubs that they own when
   // they are destroyed. So a raw pointer is safe.
   GpuChannel* const channel_;
 
-  ContextType context_type_;
   GURL active_url_;
   size_t active_url_hash_;
 
+  // The group of contexts that share namespaces with this context.
+  scoped_refptr<gles2::ContextGroup> context_group_;
+
   bool initialized_;
   const SurfaceHandle surface_handle_;
   bool use_virtualized_gl_context_;
@@ -193,6 +181,8 @@
 
   // Message handlers:
   void OnSetGetBuffer(int32_t shm_id);
+  virtual void OnTakeFrontBuffer(const Mailbox& mailbox) = 0;
+  virtual void OnReturnFrontBuffer(const Mailbox& mailbox, bool is_lost) = 0;
   void OnGetState(IPC::Message* reply_message);
   void OnWaitForTokenInRange(int32_t start,
                              int32_t end,
@@ -209,9 +199,20 @@
   void OnDestroyTransferBuffer(int32_t id);
   void OnGetTransferBuffer(int32_t id, IPC::Message* reply_message);
 
+  void OnEnsureBackbuffer();
+
   void OnSignalSyncToken(const SyncToken& sync_token, uint32_t id);
   void OnSignalAck(uint32_t id);
   void OnSignalQuery(uint32_t query, uint32_t id);
+  void OnCreateGpuFenceFromHandle(uint32_t gpu_fence_id,
+                                  const gfx::GpuFenceHandle& handle);
+  void OnGetGpuFenceHandle(uint32_t gpu_fence_id);
+
+  void OnCreateImage(GpuCommandBufferMsg_CreateImage_Params params);
+  void OnDestroyImage(int32_t id);
+  void OnCreateStreamTexture(uint32_t texture_id,
+                             int32_t stream_id,
+                             bool* succeeded);
 
   void ReportState();
 
@@ -225,22 +226,13 @@
   // of delayed work.
   void ScheduleDelayedWork(base::TimeDelta delay);
 
+  bool CheckContextLost();
   void CheckCompleteWaits();
 
   // Set driver bug workarounds and disabled GL extensions to the context.
   static void SetContextGpuFeatureInfo(gl::GLContext* context,
                                        const GpuFeatureInfo& gpu_feature_info);
 
-  static MemoryTrackerFactory GetMemoryTrackerFactory();
-
-  // Overrides the way CreateMemoryTracker() uses to create a MemoryTracker. If
-  // |factory| is base::NullCallback(), it returns the current
-  // MemoryTrackerFactory (initially base::NullCallback() which
-  // CreateMemoryTracker() should interpret as a signal to use the default).
-  // This is intended for mocking the MemoryTracker in tests.
-  static MemoryTrackerFactory SetOrGetMemoryTrackerFactory(
-      MemoryTrackerFactory factory);
-
   std::unique_ptr<DecoderContext> decoder_context_;
 
   uint32_t last_flush_id_;
--- a/gpu/ipc/service/DEPS	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/service/DEPS	2019-05-17 18:53:33.076000000 +0300
@@ -1,5 +1,4 @@
 include_rules = [
-  "+cc/paint",
   "+components/viz/common/features.h",
   "+components/viz/common/resources/resource_format.h",
   "+third_party/skia",
--- a/gpu/ipc/service/direct_composition_child_surface_win.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/service/direct_composition_child_surface_win.cc	2019-05-17 18:53:33.076000000 +0300
@@ -154,9 +154,7 @@
       params.DirtyRectsCount = 1;
       params.pDirtyRects = &dirty_rect;
       HRESULT hr = swap_chain_->Present1(interval, flags, &params);
-      // Ignore DXGI_STATUS_OCCLUDED since that's not an error but only
-      // indicates that the window is occluded and we can stop rendering.
-      if (FAILED(hr) && hr != DXGI_STATUS_OCCLUDED) {
+      if (FAILED(hr)) {
         DLOG(ERROR) << "Present1 failed with error " << std::hex << hr;
         return false;
       }
@@ -218,7 +216,7 @@
 }
 
 gfx::SwapResult DirectCompositionChildSurfaceWin::SwapBuffers(
-    PresentationCallback callback) {
+    const PresentationCallback& callback) {
   // PresentationCallback is handled by DirectCompositionSurfaceWin. The child
   // surface doesn't need provide presentation feedback.
   DCHECK(!callback);
@@ -264,19 +262,19 @@
 bool DirectCompositionChildSurfaceWin::SetDrawRectangle(
     const gfx::Rect& rectangle) {
   if (!gfx::Rect(size_).Contains(rectangle)) {
-    DLOG(ERROR) << "Draw rectangle must be contained within size of surface";
+    VLOG(1) << "Draw rectangle must be contained within size of surface";
     return false;
   }
 
   if (draw_texture_) {
-    DLOG(ERROR) << "SetDrawRectangle must be called only once per swap buffers";
+    VLOG(1) << "SetDrawRectangle must be called only once per swap buffers";
     return false;
   }
   DCHECK(!real_surface_);
   DCHECK(!g_current_surface);
 
   if (gfx::Rect(size_) != rectangle && !swap_chain_ && !dcomp_surface_) {
-    DLOG(ERROR) << "First draw to surface must draw to everything";
+    VLOG(1) << "First draw to surface must draw to everything";
     return false;
   }
 
@@ -296,7 +294,7 @@
         size_.width(), size_.height(), output_format,
         DXGI_ALPHA_MODE_PREMULTIPLIED, dcomp_surface_.GetAddressOf());
     if (FAILED(hr)) {
-      DLOG(ERROR) << "CreateSurface failed with error " << std::hex << hr;
+      VLOG(1) << "CreateSurface failed with error " << std::hex << hr;
       return false;
     }
   } else if (!enable_dc_layers_ && !swap_chain_) {
@@ -333,8 +331,8 @@
         d3d11_device_.Get(), &desc, nullptr, swap_chain_.GetAddressOf());
     first_swap_ = true;
     if (FAILED(hr)) {
-      DLOG(ERROR) << "CreateSwapChainForComposition failed with error "
-                  << std::hex << hr;
+      VLOG(1) << "CreateSwapChainForComposition failed with error " << std::hex
+              << hr;
       return false;
     }
   }
@@ -348,7 +346,7 @@
     HRESULT hr = dcomp_surface_->BeginDraw(
         &rect, IID_PPV_ARGS(draw_texture_.GetAddressOf()), &update_offset);
     if (FAILED(hr)) {
-      DLOG(ERROR) << "BeginDraw failed with error " << std::hex << hr;
+      VLOG(1) << "BeginDraw failed with error " << std::hex << hr;
       return false;
     }
     draw_offset_ = gfx::Point(update_offset) - rectangle.origin();
@@ -375,7 +373,7 @@
       eglCreatePbufferFromClientBuffer(GetDisplay(), EGL_D3D_TEXTURE_ANGLE,
                                        buffer, GetConfig(), pbuffer_attribs);
   if (!real_surface_) {
-    DLOG(ERROR) << "eglCreatePbufferFromClientBuffer failed with error "
+    VLOG(1) << "eglCreatePbufferFromClientBuffer failed with error "
                 << ui::GetLastEGLErrorString();
     return false;
   }
--- a/gpu/ipc/service/direct_composition_child_surface_win.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/service/direct_composition_child_surface_win.h	2019-05-17 18:53:33.076000000 +0300
@@ -26,7 +26,7 @@
   gfx::Size GetSize() override;
   bool IsOffscreen() override;
   void* GetHandle() override;
-  gfx::SwapResult SwapBuffers(PresentationCallback callback) override;
+  gfx::SwapResult SwapBuffers(const PresentationCallback& callback) override;
   bool FlipsVertically() const override;
   bool SupportsPostSubBuffer() override;
   bool OnMakeCurrent(gl::GLContext* context) override;
--- a/gpu/ipc/service/direct_composition_surface_win.cc	2019-05-17 17:45:41.020000000 +0300
+++ b/gpu/ipc/service/direct_composition_surface_win.cc	2019-05-17 18:53:33.076000000 +0300
@@ -8,8 +8,6 @@
 #include <dcomptypes.h>
 #include <dxgi1_6.h>
 
-#include <utility>
-
 #include "base/containers/circular_deque.h"
 #include "base/feature_list.h"
 #include "base/metrics/histogram_functions.h"
@@ -272,7 +270,7 @@
     // Early out after the first output that reports overlay support. All
     // outputs are expected to report the same overlay support according to
     // Microsoft's WDDM documentation:
-    // https://docs.m1cr050ft.qjz9zk/en-us/windows-hardware/drivers/display/multiplane-overlay-hardware-requirements
+    // https://docs.microsoft.com/en-us/windows-hardware/drivers/display/multiplane-overlay-hardware-requirements
     // TODO(sunnyps): If the above is true, then we can only look at first
     // output instead of iterating over all outputs.
     if (g_supports_overlays)
@@ -518,11 +516,6 @@
                                 const gfx::Size& swap_chain_size,
                                 bool* needs_commit);
 
-  // Records presentation statistics in UMA and traces (for pixel tests) for the
-  // current swap chain which could either be a regular flip swap chain or a
-  // decode swap chain.
-  void RecordPresentationStatistics();
-
   // Layer tree instance that owns this swap chain presenter.
   DCLayerTree* layer_tree_;
 
@@ -623,12 +616,6 @@
   dcomp_device_->CreateVisual(root_visual_.GetAddressOf());
   DCHECK(root_visual_);
   dcomp_target_->SetRoot(root_visual_.Get());
-  // A visual inherits the interpolation mode of the parent visual by default.
-  // If no visuals set the interpolation mode, the default for the entire visual
-  // tree is nearest neighbor interpolation.
-  // Set the interpolation mode to Linear to get a better upscaling quality.
-  root_visual_->SetBitmapInterpolationMode(
-      DCOMPOSITION_BITMAP_INTERPOLATION_MODE_LINEAR);
 
   return true;
 }
@@ -1064,9 +1051,7 @@
   HRESULT hr = decode_swap_chain_->PresentBuffer(image_dxgi->level(), 1, 0);
   base::UmaHistogramSparse("GPU.DirectComposition.DecodeSwapChainPresentResult",
                            hr);
-  // Ignore DXGI_STATUS_OCCLUDED since that's not an error but only indicates
-  // that the window is occluded and we can stop rendering.
-  if (FAILED(hr) && hr != DXGI_STATUS_OCCLUDED) {
+  if (FAILED(hr)) {
     DLOG(ERROR) << "PresentBuffer failed with error 0x" << std::hex << hr;
     return false;
   }
@@ -1083,7 +1068,6 @@
     frames_since_color_space_change_ = 0;
     is_yuv_swapchain_ = true;
   }
-  RecordPresentationStatistics();
   return true;
 }
 
@@ -1139,26 +1121,7 @@
         texture_desc.MiscFlags &
         (D3D11_RESOURCE_MISC_SHARED | D3D11_RESOURCE_MISC_SHARED_KEYEDMUTEX |
          D3D11_RESOURCE_MISC_SHARED_NTHANDLE);
-
-    // Rotated videos are not promoted to overlays.  We plan to implement
-    // rotation using video processor instead of via direct composition.  Also
-    // check for skew and any downscaling specified to direct composition.
-    bool is_overlay_supported_transform =
-        visual_info_.transform.IsPositiveScaleOrTranslation();
-
-    // Downscaled video isn't promoted to hardware overlays.  We prefer to blit
-    // into the smaller size so that it can be promoted to a hardware overlay.
-    float swap_chain_scale_x =
-        swap_chain_size.width() * 1.0f / params.content_rect.width();
-    float swap_chain_scale_y =
-        swap_chain_size.height() * 1.0f / params.content_rect.height();
-
-    is_overlay_supported_transform = is_overlay_supported_transform &&
-                                     (swap_chain_scale_x >= 1.0f) &&
-                                     (swap_chain_scale_y >= 1.0f);
-
-    if (is_decoder_texture && !is_shared_texture &&
-        is_overlay_supported_transform) {
+    if (is_decoder_texture && !is_shared_texture) {
       if (PresentToDecodeSwapChain(image_dxgi, params.content_rect,
                                    swap_chain_size, needs_commit)) {
         return true;
@@ -1232,9 +1195,7 @@
     first_present_ = false;
 
     HRESULT hr = swap_chain_->Present(0, 0);
-    // Ignore DXGI_STATUS_OCCLUDED since that's not an error but only indicates
-    // that the window is occluded and we can stop rendering.
-    if (FAILED(hr) && hr != DXGI_STATUS_OCCLUDED) {
+    if (FAILED(hr)) {
       DLOG(ERROR) << "Present failed with error 0x" << std::hex << hr;
       return false;
     }
@@ -1269,57 +1230,29 @@
     event.Wait();
   }
 
-  // Ignore DXGI_STATUS_OCCLUDED since that's not an error but only indicates
-  // that the window is occluded and we can stop rendering.
   HRESULT hr = swap_chain_->Present(1, 0);
-  if (FAILED(hr) && hr != DXGI_STATUS_OCCLUDED) {
+  if (FAILED(hr)) {
     DLOG(ERROR) << "Present failed with error 0x" << std::hex << hr;
     return false;
   }
+
+  UMA_HISTOGRAM_ENUMERATION(
+      "GPU.DirectComposition.SwapChainFormat2",
+      is_yuv_swapchain_ ? g_overlay_format_used : OverlayFormat::kBGRA);
+
   frames_since_color_space_change_++;
-  RecordPresentationStatistics();
-  return true;
-}
 
-void DCLayerTree::SwapChainPresenter::RecordPresentationStatistics() {
-  OverlayFormat swap_chain_format =
-      is_yuv_swapchain_ ? g_overlay_format_used : OverlayFormat::kBGRA;
-  UMA_HISTOGRAM_ENUMERATION("GPU.DirectComposition.SwapChainFormat2",
-                            swap_chain_format);
-  TRACE_EVENT_INSTANT2(TRACE_DISABLED_BY_DEFAULT("gpu.service"),
-                       "SwapChain::Present", TRACE_EVENT_SCOPE_THREAD,
-                       "PixelFormat", swap_chain_format, "ZeroCopy",
-                       !!decode_swap_chain_);
-  HRESULT hr = 0;
   Microsoft::WRL::ComPtr<IDXGISwapChainMedia> swap_chain_media;
-  if (decode_swap_chain_) {
-    hr = decode_swap_chain_.As(&swap_chain_media);
-  } else {
-    DCHECK(swap_chain_);
-    hr = swap_chain_.As(&swap_chain_media);
-  }
-  if (SUCCEEDED(hr)) {
+  if (SUCCEEDED(swap_chain_.CopyTo(swap_chain_media.GetAddressOf()))) {
     DCHECK(swap_chain_media);
     DXGI_FRAME_STATISTICS_MEDIA stats = {};
-    // GetFrameStatisticsMedia fails with DXGI_ERROR_FRAME_STATISTICS_DISJOINT
-    // sometimes, which means an event (such as power cycle) interrupted the
-    // gathering of presentation statistics. In this situation, calling the
-    // function again succeeds but returns with CompositionMode = NONE.
-    // Waiting for the DXGI adapter to finish presenting before calling the
-    // function doesn't get rid of the failure.
-    HRESULT hr = swap_chain_media->GetFrameStatisticsMedia(&stats);
-    int mode = -1;
-    if (SUCCEEDED(hr)) {
+    if (SUCCEEDED(swap_chain_media->GetFrameStatisticsMedia(&stats))) {
       base::UmaHistogramSparse("GPU.DirectComposition.CompositionMode",
                                stats.CompositionMode);
       presentation_history_.AddSample(stats.CompositionMode);
-      mode = stats.CompositionMode;
     }
-    // Record CompositionMode as -1 if GetFrameStatisticsMedia() fails.
-    TRACE_EVENT_INSTANT1(TRACE_DISABLED_BY_DEFAULT("gpu.service"),
-                         "GetFrameStatisticsMedia", TRACE_EVENT_SCOPE_THREAD,
-                         "CompositionMode", mode);
   }
+  return true;
 }
 
 bool DCLayerTree::SwapChainPresenter::VideoProcessorBlt(
@@ -1656,8 +1589,6 @@
     bool video_needs_commit = false;
     if (!video_swap_chain->PresentToSwapChain(*pending_overlays_[i],
                                               &video_needs_commit)) {
-      DLOG(ERROR) << "PresentToSwapChain failed";
-      DCHECK(false);
       return false;
     }
     needs_commit = needs_commit || video_needs_commit;
@@ -1693,7 +1624,6 @@
     HRESULT hr = dcomp_device_->Commit();
     if (FAILED(hr)) {
       DLOG(ERROR) << "Commit failed with error 0x" << std::hex << hr;
-      DCHECK(false);
       return false;
     }
   }
@@ -1943,9 +1873,9 @@
 }
 
 gfx::SwapResult DirectCompositionSurfaceWin::SwapBuffers(
-    PresentationCallback callback) {
+    const PresentationCallback& callback) {
   gl::GLSurfacePresentationHelper::ScopedSwapBuffers scoped_swap_buffers(
-      presentation_helper_.get(), std::move(callback));
+      presentation_helper_.get(), callback);
 
   bool succeeded = true;
   if (root_surface_->SwapBuffers(PresentationCallback()) ==
@@ -1953,8 +1883,7 @@
     succeeded = false;
 
   DCLayerTree::BackbufferInfo backbuffer_info = {
-      root_surface_->swap_chain().Get(),
-      root_surface_->dcomp_surface().Get(),
+      root_surface_->swap_chain().Get(), root_surface_->dcomp_surface().Get(),
       root_surface_->dcomp_surface_serial(),
   };
   if (!layer_tree_->CommitAndClearPendingOverlays(std::move(backbuffer_info)))
@@ -1973,10 +1902,10 @@
     int y,
     int width,
     int height,
-    PresentationCallback callback) {
+    const PresentationCallback& callback) {
   // The arguments are ignored because SetDrawRectangle specified the area to
   // be swapped.
-  return SwapBuffers(std::move(callback));
+  return SwapBuffers(callback);
 }
 
 gfx::VSyncProvider* DirectCompositionSurfaceWin::GetVSyncProvider() {
--- a/gpu/ipc/service/direct_composition_surface_win.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/service/direct_composition_surface_win.h	2019-05-17 18:53:33.076000000 +0300
@@ -70,12 +70,12 @@
               float scale_factor,
               ColorSpace color_space,
               bool has_alpha) override;
-  gfx::SwapResult SwapBuffers(PresentationCallback callback) override;
+  gfx::SwapResult SwapBuffers(const PresentationCallback& callback) override;
   gfx::SwapResult PostSubBuffer(int x,
                                 int y,
                                 int width,
                                 int height,
-                                PresentationCallback callback) override;
+                                const PresentationCallback& callback) override;
   gfx::VSyncProvider* GetVSyncProvider() override;
   void SetVSyncEnabled(bool enabled) override;
   bool SetEnableDCLayers(bool enable) override;
--- a/gpu/ipc/service/gles2_command_buffer_stub.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/service/gles2_command_buffer_stub.cc	2019-05-17 18:53:33.080000000 +0300
@@ -26,7 +26,6 @@
 #include "gpu/command_buffer/common/swap_buffers_flags.h"
 #include "gpu/command_buffer/service/gl_context_virtual.h"
 #include "gpu/command_buffer/service/gl_state_restorer_impl.h"
-#include "gpu/command_buffer/service/gpu_fence_manager.h"
 #include "gpu/command_buffer/service/image_manager.h"
 #include "gpu/command_buffer/service/logger.h"
 #include "gpu/command_buffer/service/mailbox_manager.h"
@@ -42,8 +41,6 @@
 #include "gpu/ipc/service/gpu_memory_buffer_factory.h"
 #include "gpu/ipc/service/gpu_watchdog_thread.h"
 #include "gpu/ipc/service/image_transport_surface.h"
-#include "ui/gfx/gpu_fence.h"
-#include "ui/gfx/gpu_fence_handle.h"
 #include "ui/gl/gl_bindings.h"
 #include "ui/gl/gl_context.h"
 #include "ui/gl/gl_image.h"
@@ -91,19 +88,9 @@
   DCHECK(manager);
 
   if (share_command_buffer_stub) {
-    context_group_ =
-        share_command_buffer_stub->decoder_context()->GetContextGroup();
-    if (!context_group_) {
-      LOG(ERROR) << "ContextResult::kFatalFailure: attempt to create a GLES2 "
-                    "context sharing with a non-GLES2 context";
-      return gpu::ContextResult::kFatalFailure;
-    }
-    if (context_group_->bind_generates_resource() !=
-        init_params.attribs.bind_generates_resource) {
-      LOG(ERROR) << "ContextResult::kFatalFailure: attempt to create a shared "
-                    "GLES2 context with inconsistent bind_generates_resource";
-      return gpu::ContextResult::kFatalFailure;
-    }
+    context_group_ = share_command_buffer_stub->context_group();
+    DCHECK(context_group_->bind_generates_resource() ==
+           init_params.attribs.bind_generates_resource);
   } else {
     scoped_refptr<gles2::FeatureInfo> feature_info = new gles2::FeatureInfo(
         manager->gpu_driver_bug_workarounds(), manager->gpu_feature_info());
@@ -170,7 +157,7 @@
 #endif
 
   command_buffer_ = std::make_unique<CommandBufferService>(
-      this, context_group_->memory_tracker());
+      this, context_group_->transfer_buffer_manager());
   gles2_decoder_ = gles2::GLES2Decoder::Create(
       this, command_buffer_.get(), manager->outputter(), context_group_.get());
   set_decoder_context(std::unique_ptr<DecoderContext>(gles2_decoder_));
@@ -428,32 +415,13 @@
   return route_id_;
 }
 
-MemoryTracker* GLES2CommandBufferStub::GetMemoryTracker() const {
-  return context_group_->memory_tracker();
-}
-
-bool GLES2CommandBufferStub::HandleMessage(const IPC::Message& message) {
-  bool handled = true;
-  IPC_BEGIN_MESSAGE_MAP(GLES2CommandBufferStub, message)
-    IPC_MESSAGE_HANDLER(GpuCommandBufferMsg_TakeFrontBuffer, OnTakeFrontBuffer);
-    IPC_MESSAGE_HANDLER(GpuCommandBufferMsg_ReturnFrontBuffer,
-                        OnReturnFrontBuffer);
-    IPC_MESSAGE_HANDLER(GpuCommandBufferMsg_CreateImage, OnCreateImage);
-    IPC_MESSAGE_HANDLER(GpuCommandBufferMsg_DestroyImage, OnDestroyImage);
-    IPC_MESSAGE_HANDLER(GpuCommandBufferMsg_CreateStreamTexture,
-                        OnCreateStreamTexture)
-    IPC_MESSAGE_HANDLER(GpuCommandBufferMsg_CreateGpuFenceFromHandle,
-                        OnCreateGpuFenceFromHandle)
-    IPC_MESSAGE_HANDLER(GpuCommandBufferMsg_GetGpuFenceHandle,
-                        OnGetGpuFenceHandle)
-    IPC_MESSAGE_UNHANDLED(handled = false)
-  IPC_END_MESSAGE_MAP()
-  return handled;
-}
-
 void GLES2CommandBufferStub::OnTakeFrontBuffer(const Mailbox& mailbox) {
   TRACE_EVENT0("gpu", "CommandBufferStub::OnTakeFrontBuffer");
-  DCHECK(gles2_decoder_);
+  if (!gles2_decoder_) {
+    LOG(ERROR) << "Can't take front buffer before initialization.";
+    return;
+  }
+
   gles2_decoder_->TakeFrontBuffer(mailbox);
 }
 
@@ -464,108 +432,6 @@
   gles2_decoder_->ReturnFrontBuffer(mailbox, is_lost);
 }
 
-void GLES2CommandBufferStub::OnCreateGpuFenceFromHandle(
-    uint32_t gpu_fence_id,
-    const gfx::GpuFenceHandle& handle) {
-  if (!context_group_->feature_info()->feature_flags().chromium_gpu_fence) {
-    DLOG(ERROR) << "CHROMIUM_gpu_fence unavailable";
-    command_buffer_->SetParseError(error::kLostContext);
-    return;
-  }
-
-  if (gles2_decoder_->GetGpuFenceManager()->CreateGpuFenceFromHandle(
-          gpu_fence_id, handle))
-    return;
-
-  // The insertion failed. This shouldn't happen, force context loss to avoid
-  // inconsistent state.
-  command_buffer_->SetParseError(error::kLostContext);
-  CheckContextLost();
-}
-
-void GLES2CommandBufferStub::OnGetGpuFenceHandle(uint32_t gpu_fence_id) {
-  if (!context_group_->feature_info()->feature_flags().chromium_gpu_fence) {
-    DLOG(ERROR) << "CHROMIUM_gpu_fence unavailable";
-    command_buffer_->SetParseError(error::kLostContext);
-    return;
-  }
-
-  auto* manager = gles2_decoder_->GetGpuFenceManager();
-  gfx::GpuFenceHandle handle;
-  if (manager->IsValidGpuFence(gpu_fence_id)) {
-    std::unique_ptr<gfx::GpuFence> gpu_fence =
-        manager->GetGpuFence(gpu_fence_id);
-    handle = gfx::CloneHandleForIPC(gpu_fence->GetGpuFenceHandle());
-  } else {
-    // Retrieval failed. This shouldn't happen, force context loss to avoid
-    // inconsistent state.
-    DLOG(ERROR) << "GpuFence not found";
-    command_buffer_->SetParseError(error::kLostContext);
-    CheckContextLost();
-  }
-  Send(new GpuCommandBufferMsg_GetGpuFenceHandleComplete(route_id_,
-                                                         gpu_fence_id, handle));
-}
-
-void GLES2CommandBufferStub::OnCreateImage(
-    GpuCommandBufferMsg_CreateImage_Params params) {
-  TRACE_EVENT0("gpu", "GLES2CommandBufferStub::OnCreateImage");
-  const int32_t id = params.id;
-  const gfx::Size& size = params.size;
-  const gfx::BufferFormat& format = params.format;
-  const uint64_t image_release_count = params.image_release_count;
-
-  gles2::ImageManager* image_manager = channel_->image_manager();
-  DCHECK(image_manager);
-  if (image_manager->LookupImage(id)) {
-    LOG(ERROR) << "Image already exists with same ID.";
-    return;
-  }
-
-  if (!gpu::IsImageFromGpuMemoryBufferFormatSupported(
-          format, gles2_decoder_->GetCapabilities())) {
-    LOG(ERROR) << "Format is not supported.";
-    return;
-  }
-
-  if (!gpu::IsImageSizeValidForGpuMemoryBufferFormat(size, format)) {
-    LOG(ERROR) << "Invalid image size for format.";
-    return;
-  }
-
-  scoped_refptr<gl::GLImage> image = channel()->CreateImageForGpuMemoryBuffer(
-      std::move(params.gpu_memory_buffer), size, format, surface_handle_);
-  if (!image.get())
-    return;
-
-  image_manager->AddImage(image.get(), id);
-  if (image_release_count)
-    sync_point_client_state_->ReleaseFenceSync(image_release_count);
-}
-
-void GLES2CommandBufferStub::OnDestroyImage(int32_t id) {
-  TRACE_EVENT0("gpu", "GLES2CommandBufferStub::OnDestroyImage");
-
-  gles2::ImageManager* image_manager = channel_->image_manager();
-  DCHECK(image_manager);
-  if (!image_manager->LookupImage(id)) {
-    LOG(ERROR) << "Image with ID doesn't exist.";
-    return;
-  }
-
-  image_manager->RemoveImage(id);
-}
-
-void GLES2CommandBufferStub::OnCreateStreamTexture(uint32_t texture_id,
-                                                   int32_t stream_id,
-                                                   bool* succeeded) {
-#if defined(OS_ANDROID)
-  *succeeded = StreamTexture::Create(this, texture_id, stream_id);
-#else
-  *succeeded = false;
-#endif
-}
-
 void GLES2CommandBufferStub::OnSwapBuffers(uint64_t swap_id, uint32_t flags) {
   pending_swap_completed_params_.push_back({swap_id, flags});
   pending_presented_params_.push_back({swap_id, flags});
--- a/gpu/ipc/service/gles2_command_buffer_stub.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/service/gles2_command_buffer_stub.h	2019-05-17 18:53:33.080000000 +0300
@@ -10,11 +10,8 @@
 #include "build/build_config.h"
 #include "gpu/ipc/service/command_buffer_stub.h"
 #include "gpu/ipc/service/image_transport_surface_delegate.h"
-#include "ui/gfx/gpu_fence_handle.h"
 
-struct GpuCommandBufferMsg_CreateImage_Params;
 namespace gpu {
-struct Mailbox;
 
 class GPU_IPC_SERVICE_EXPORT GLES2CommandBufferStub
     : public CommandBufferStub,
@@ -37,7 +34,6 @@
       CommandBufferStub* share_group,
       const GPUCreateCommandBufferConfig& init_params,
       base::UnsafeSharedMemoryRegion shared_state_shm) override;
-  MemoryTracker* GetMemoryTracker() const override;
 
 // ImageTransportSurfaceDelegate implementation:
 #if defined(OS_WIN)
@@ -54,23 +50,10 @@
   int32_t GetRouteID() const override;
 
  private:
-  bool HandleMessage(const IPC::Message& message) override;
-  void OnTakeFrontBuffer(const Mailbox& mailbox);
-  void OnReturnFrontBuffer(const Mailbox& mailbox, bool is_lost);
-  void OnCreateGpuFenceFromHandle(uint32_t gpu_fence_id,
-                                  const gfx::GpuFenceHandle& handle);
-  void OnGetGpuFenceHandle(uint32_t gpu_fence_id);
-  void OnCreateImage(GpuCommandBufferMsg_CreateImage_Params params);
-  void OnDestroyImage(int32_t id);
-  void OnCreateStreamTexture(uint32_t texture_id,
-                             int32_t stream_id,
-                             bool* succeeded);
-
+  void OnTakeFrontBuffer(const Mailbox& mailbox) override;
+  void OnReturnFrontBuffer(const Mailbox& mailbox, bool is_lost) override;
   void OnSwapBuffers(uint64_t swap_id, uint32_t flags) override;
 
-  // The group of contexts that share namespaces with this context.
-  scoped_refptr<gles2::ContextGroup> context_group_;
-
   // Keep a more specifically typed reference to the decoder to avoid
   // unnecessary casts. Owned by parent class.
   gles2::GLES2Decoder* gles2_decoder_;
--- a/gpu/ipc/service/gpu_channel.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/service/gpu_channel.cc	2019-05-17 18:53:33.080000000 +0300
@@ -127,8 +127,6 @@
   scoped_refptr<ImageDecodeAcceleratorStub> image_decode_accelerator_stub_;
   base::ThreadChecker io_thread_checker_;
 
-  bool allow_crash_for_testing_ = false;
-
   DISALLOW_COPY_AND_ASSIGN(GpuChannelMessageFilter);
 };
 
@@ -147,9 +145,6 @@
               static_cast<int32_t>(
                   GpuChannelReservedRoutes::kImageDecodeAccelerator))) {
   io_thread_checker_.DetachFromThread();
-  allow_crash_for_testing_ = gpu_channel->gpu_channel_manager()
-                                 ->gpu_preferences()
-                                 .enable_gpu_benchmarking_extension;
 }
 
 GpuChannelMessageFilter::~GpuChannelMessageFilter() {
@@ -242,22 +237,9 @@
     case GpuCommandBufferMsg_AsyncFlush::ID:
     case GpuCommandBufferMsg_DestroyTransferBuffer::ID:
     case GpuCommandBufferMsg_ReturnFrontBuffer::ID:
-    case GpuCommandBufferMsg_TakeFrontBuffer::ID:
     case GpuChannelMsg_CreateSharedImage::ID:
     case GpuChannelMsg_DestroySharedImage::ID:
       return MessageErrorHandler(message, "Invalid message");
-    case GpuChannelMsg_CrashForTesting::ID:
-      // Handle this message early, on the IO thread, in case the main
-      // thread is hung. This is the purpose of this message: generating
-      // minidumps on the bots, which are symbolized later by the test
-      // harness. Only pay attention to this message if Telemetry's GPU
-      // benchmarking extension was enabled via the command line, which
-      // exposes privileged APIs to JavaScript.
-      if (allow_crash_for_testing_) {
-        gl::Crash();
-      }
-      // Won't be reached if the extension is enabled.
-      return MessageErrorHandler(message, "Crashes for testing are disabled");
     default:
       break;
   }
@@ -285,7 +267,6 @@
       static_cast<int32_t>(GpuChannelReservedRoutes::kImageDecodeAccelerator)) {
     if (!image_decode_accelerator_stub_->OnMessageReceived(message))
       return MessageErrorHandler(message, "Invalid image decode request");
-    return true;
   }
 
   bool handle_out_of_order =
@@ -492,7 +473,8 @@
 
 bool GpuChannel::HasActiveWebGLContext() const {
   for (auto& kv : stubs_) {
-    ContextType context_type = kv.second->context_type();
+    ContextType context_type =
+        kv.second->context_group()->feature_info()->context_type();
     if (context_type == CONTEXT_TYPE_WEBGL1 ||
         context_type == CONTEXT_TYPE_WEBGL2) {
       return true;
@@ -527,6 +509,7 @@
                         OnCreateCommandBuffer)
     IPC_MESSAGE_HANDLER(GpuChannelMsg_DestroyCommandBuffer,
                         OnDestroyCommandBuffer)
+    IPC_MESSAGE_HANDLER(GpuChannelMsg_CrashForTesting, OnCrashForTesting)
     IPC_MESSAGE_UNHANDLED(handled = false)
   IPC_END_MESSAGE_MAP()
   return handled;
@@ -725,6 +708,16 @@
   RemoveRoute(route_id);
 }
 
+void GpuChannel::OnCrashForTesting() {
+  // Only pay attention to this message if Telemetry's GPU
+  // benchmarking extension was enabled via the command line, which
+  // exposes privileged APIs to JavaScript.
+  if (!gpu_channel_manager_->gpu_preferences()
+           .enable_gpu_benchmarking_extension)
+    return;
+  gl::Crash();
+}
+
 void GpuChannel::CacheShader(const std::string& key,
                              const std::string& shader) {
   gpu_channel_manager_->delegate()->StoreShaderToDisk(client_id_, key, shader);
--- a/gpu/ipc/service/gpu_channel.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/service/gpu_channel.h	2019-05-17 18:53:33.080000000 +0300
@@ -169,6 +169,7 @@
                              gpu::ContextResult* result,
                              gpu::Capabilities* capabilities);
   void OnDestroyCommandBuffer(int32_t route_id);
+  void OnCrashForTesting();
 
   std::unique_ptr<IPC::SyncChannel> sync_channel_;  // nullptr in tests.
   IPC::Sender* channel_;  // Same as sync_channel_.get() except in tests.
--- a/gpu/ipc/service/gpu_channel_manager.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/service/gpu_channel_manager.cc	2019-05-17 18:53:33.080000000 +0300
@@ -60,7 +60,6 @@
     scoped_refptr<base::SingleThreadTaskRunner> io_task_runner,
     Scheduler* scheduler,
     SyncPointManager* sync_point_manager,
-    SharedImageManager* shared_image_manager,
     GpuMemoryBufferFactory* gpu_memory_buffer_factory,
     const GpuFeatureInfo& gpu_feature_info,
     GpuProcessActivityFlags activity_flags,
@@ -78,7 +77,6 @@
       mailbox_manager_(gles2::CreateMailboxManager(gpu_preferences)),
       scheduler_(scheduler),
       sync_point_manager_(sync_point_manager),
-      shared_image_manager_(shared_image_manager),
       shader_translator_cache_(gpu_preferences_),
       default_offscreen_surface_(std::move(default_offscreen_surface)),
       gpu_memory_buffer_factory_(gpu_memory_buffer_factory),
@@ -99,7 +97,8 @@
        gpu::kGpuFeatureStatusEnabled) ||
       features::IsUsingSkiaRenderer();
   const bool disable_disk_cache =
-      gpu_preferences_.disable_gpu_shader_disk_cache;
+      gpu_preferences_.disable_gpu_shader_disk_cache ||
+      gpu_driver_bug_workarounds_.disable_program_disk_cache;
   if (enable_gr_shader_cache && !disable_disk_cache)
     gr_shader_cache_.emplace(gpu_preferences.gpu_program_cache_size, this);
 }
--- a/gpu/ipc/service/gpu_channel_manager.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/service/gpu_channel_manager.h	2019-05-17 18:53:33.080000000 +0300
@@ -27,6 +27,7 @@
 #include "gpu/command_buffer/service/service_discardable_manager.h"
 #include "gpu/command_buffer/service/shader_translator_cache.h"
 #include "gpu/command_buffer/service/shared_context_state.h"
+#include "gpu/command_buffer/service/shared_image_manager.h"
 #include "gpu/config/gpu_driver_bug_workarounds.h"
 #include "gpu/config/gpu_feature_info.h"
 #include "gpu/config/gpu_preferences.h"
@@ -74,7 +75,6 @@
       scoped_refptr<base::SingleThreadTaskRunner> io_task_runner,
       Scheduler* scheduler,
       SyncPointManager* sync_point_manager,
-      SharedImageManager* shared_image_manager,
       GpuMemoryBufferFactory* gpu_memory_buffer_factory,
       const GpuFeatureInfo& gpu_feature_info,
       GpuProcessActivityFlags activity_flags,
@@ -150,7 +150,7 @@
 
   SyncPointManager* sync_point_manager() const { return sync_point_manager_; }
 
-  SharedImageManager* shared_image_manager() { return shared_image_manager_; }
+  SharedImageManager* shared_image_manager() { return &shared_image_manager_; }
 
   // Retrieve GPU Resource consumption statistics for the task manager
   void GetVideoMemoryUsageStats(
@@ -203,8 +203,7 @@
   std::unique_ptr<gles2::Outputter> outputter_;
   Scheduler* scheduler_;
   // SyncPointManager guaranteed to outlive running MessageLoop.
-  SyncPointManager* const sync_point_manager_;
-  SharedImageManager* const shared_image_manager_;
+  SyncPointManager* sync_point_manager_;
   std::unique_ptr<gles2::ProgramCache> program_cache_;
   gles2::ShaderTranslatorCache shader_translator_cache_;
   gles2::FramebufferCompletenessCache framebuffer_completeness_cache_;
@@ -213,6 +212,7 @@
   GpuFeatureInfo gpu_feature_info_;
   ServiceDiscardableManager discardable_manager_;
   PassthroughDiscardableManager passthrough_discardable_manager_;
+  SharedImageManager shared_image_manager_;
 #if defined(OS_ANDROID)
   // Last time we know the GPU was powered on. Global for tracking across all
   // transport surfaces.
--- a/gpu/ipc/service/gpu_channel_manager_unittest.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/service/gpu_channel_manager_unittest.cc	2019-05-17 18:53:33.080000000 +0300
@@ -15,8 +15,7 @@
 
 class GpuChannelManagerTest : public GpuChannelTestCommon {
  public:
-  GpuChannelManagerTest()
-      : GpuChannelTestCommon(true /* use_stub_bindings */) {}
+  GpuChannelManagerTest() : GpuChannelTestCommon() {}
   ~GpuChannelManagerTest() override = default;
 
 #if defined(OS_ANDROID)
--- a/gpu/ipc/service/gpu_channel_test_common.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/service/gpu_channel_test_common.cc	2019-05-17 18:53:33.080000000 +0300
@@ -9,7 +9,6 @@
 #include "base/threading/thread_task_runner_handle.h"
 #include "gpu/command_buffer/common/activity_flags.h"
 #include "gpu/command_buffer/service/scheduler.h"
-#include "gpu/command_buffer/service/shared_image_manager.h"
 #include "gpu/command_buffer/service/sync_point_manager.h"
 #include "gpu/ipc/service/gpu_channel.h"
 #include "gpu/ipc/service/gpu_channel_manager.h"
@@ -50,23 +49,18 @@
   DISALLOW_COPY_AND_ASSIGN(TestGpuChannelManagerDelegate);
 };
 
-GpuChannelTestCommon::GpuChannelTestCommon(bool use_stub_bindings)
-    : GpuChannelTestCommon(std::vector<int32_t>(), use_stub_bindings) {}
+GpuChannelTestCommon::GpuChannelTestCommon()
+    : GpuChannelTestCommon(std::vector<int32_t>()) {}
 
 GpuChannelTestCommon::GpuChannelTestCommon(
-    std::vector<int32_t> enabled_workarounds,
-    bool use_stub_bindings)
+    std::vector<int32_t> enabled_workarounds)
     : task_runner_(new base::TestSimpleTaskRunner),
       io_task_runner_(new base::TestSimpleTaskRunner),
       sync_point_manager_(new SyncPointManager()),
-      shared_image_manager_(new SharedImageManager(false /* thread_safe */)),
       scheduler_(new Scheduler(task_runner_, sync_point_manager_.get())),
       channel_manager_delegate_(new TestGpuChannelManagerDelegate()) {
   // We need GL bindings to actually initialize command buffers.
-  if (use_stub_bindings)
     gl::GLSurfaceTestSupport::InitializeOneOffWithStubBindings();
-  else
-    gl::GLSurfaceTestSupport::InitializeOneOff();
 
   GpuFeatureInfo feature_info;
   feature_info.enabled_gpu_driver_bug_workarounds =
@@ -75,8 +69,7 @@
   channel_manager_.reset(new GpuChannelManager(
       GpuPreferences(), channel_manager_delegate_.get(), nullptr, /* watchdog */
       task_runner_.get(), io_task_runner_.get(), scheduler_.get(),
-      sync_point_manager_.get(), shared_image_manager_.get(),
-      nullptr, /* gpu_memory_buffer_factory */
+      sync_point_manager_.get(), nullptr, /* gpu_memory_buffer_factory */
       std::move(feature_info), GpuProcessActivityFlags(),
       gl::init::CreateOffscreenGLSurface(gfx::Size()),
       nullptr /* image_decode_accelerator_worker */));
--- a/gpu/ipc/service/gpu_channel_test_common.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/service/gpu_channel_test_common.h	2019-05-17 18:53:33.080000000 +0300
@@ -6,7 +6,6 @@
 #define GPU_IPC_SERVICE_GPU_CHANNEL_TEST_COMMON_H_
 
 #include <memory>
-#include <vector>
 
 #include "base/memory/ref_counted.h"
 #include "base/memory/unsafe_shared_memory_region.h"
@@ -26,19 +25,16 @@
 class GpuChannelManager;
 class Scheduler;
 class SyncPointManager;
-class SharedImageManager;
 class TestGpuChannelManagerDelegate;
 
 class GpuChannelTestCommon : public testing::Test {
  public:
-  explicit GpuChannelTestCommon(bool use_stub_bindings);
+  GpuChannelTestCommon();
   // Constructor which allows a custom set of GPU driver bug workarounds.
-  GpuChannelTestCommon(std::vector<int32_t> enabled_workarounds,
-                       bool use_stub_bindings);
+  explicit GpuChannelTestCommon(std::vector<int32_t> enabled_workarounds);
   ~GpuChannelTestCommon() override;
 
  protected:
-  Scheduler* scheduler() const { return scheduler_.get(); }
   GpuChannelManager* channel_manager() const { return channel_manager_.get(); }
   base::TestSimpleTaskRunner* task_runner() const { return task_runner_.get(); }
   base::TestSimpleTaskRunner* io_task_runner() const {
@@ -56,7 +52,6 @@
   scoped_refptr<base::TestSimpleTaskRunner> task_runner_;
   scoped_refptr<base::TestSimpleTaskRunner> io_task_runner_;
   std::unique_ptr<SyncPointManager> sync_point_manager_;
-  std::unique_ptr<SharedImageManager> shared_image_manager_;
   std::unique_ptr<Scheduler> scheduler_;
   std::unique_ptr<TestGpuChannelManagerDelegate> channel_manager_delegate_;
   std::unique_ptr<GpuChannelManager> channel_manager_;
--- a/gpu/ipc/service/gpu_channel_unittest.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/service/gpu_channel_unittest.cc	2019-05-17 18:53:33.080000000 +0300
@@ -12,11 +12,7 @@
 
 namespace gpu {
 
-class GpuChannelTest : public GpuChannelTestCommon {
- public:
-  GpuChannelTest() : GpuChannelTestCommon(true /* use_stub_bindings */) {}
-  ~GpuChannelTest() override = default;
-};
+class GpuChannelTest : public GpuChannelTestCommon {};
 
 #if defined(OS_WIN)
 const SurfaceHandle kFakeSurfaceHandle = reinterpret_cast<SurfaceHandle>(1);
@@ -238,8 +234,7 @@
 class GpuChannelExitForContextLostTest : public GpuChannelTestCommon {
  public:
   GpuChannelExitForContextLostTest()
-      : GpuChannelTestCommon({EXIT_ON_CONTEXT_LOST} /* enabled_workarounds */,
-                             true /* use_stub_bindings */) {}
+      : GpuChannelTestCommon({EXIT_ON_CONTEXT_LOST}) {}
 };
 
 TEST_F(GpuChannelExitForContextLostTest, CreateFailsDuringLostContextShutdown) {
--- a/gpu/ipc/service/gpu_init.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/service/gpu_init.cc	2019-05-17 18:53:33.080000000 +0300
@@ -12,7 +12,6 @@
 #include "base/threading/scoped_blocking_call.h"
 #include "base/trace_event/trace_event.h"
 #include "build/build_config.h"
-#include "components/viz/common/features.h"
 #include "gpu/command_buffer/service/gpu_switches.h"
 #include "gpu/command_buffer/service/service_utils.h"
 #include "gpu/config/gpu_driver_bug_list.h"
@@ -91,8 +90,7 @@
 #if defined(OS_LINUX) && !defined(OS_CHROMEOS) && !defined(IS_CHROMECAST)
 bool CanAccessNvidiaDeviceFile() {
   bool res = true;
-  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
-                                                base::BlockingType::WILL_BLOCK);
+  base::ScopedBlockingCall scoped_blocking_call(base::BlockingType::WILL_BLOCK);
   if (access("/dev/nvidiactl", R_OK) != 0) {
     DVLOG(1) << "NVIDIA device file /dev/nvidiactl access denied";
     res = false;
@@ -223,7 +221,6 @@
       features::IsOzoneDrmMojo() || ui::OzonePlatform::EnsureInstance()
                                         ->GetPlatformProperties()
                                         .requires_mojo;
-  params.viz_display_compositor = features::IsVizDisplayCompositorEnabled();
   ui::OzonePlatform::InitializeForGPU(params);
 #endif
 
@@ -421,7 +418,6 @@
       features::IsOzoneDrmMojo() || ui::OzonePlatform::EnsureInstance()
                                         ->GetPlatformProperties()
                                         .requires_mojo;
-  params.viz_display_compositor = features::IsVizDisplayCompositorEnabled();
   ui::OzonePlatform::InitializeForGPU(params);
   ui::OzonePlatform::GetInstance()->AfterSandboxEntry();
 #endif
--- a/gpu/ipc/service/gpu_memory_buffer_factory_dxgi_unittest.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/service/gpu_memory_buffer_factory_dxgi_unittest.cc	2019-05-17 18:53:33.080000000 +0300
@@ -9,7 +9,7 @@
 namespace {
 
 // Disabled by default as it requires DX11.
-INSTANTIATE_TYPED_TEST_SUITE_P(DISABLED_GpuMemoryBufferFactoryDXGI,
+INSTANTIATE_TYPED_TEST_CASE_P(DISABLED_GpuMemoryBufferFactoryDXGI,
                                GpuMemoryBufferFactoryTest,
                                GpuMemoryBufferFactoryDXGI);
 
--- a/gpu/ipc/service/gpu_memory_buffer_factory_io_surface_unittest.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/service/gpu_memory_buffer_factory_io_surface_unittest.cc	2019-05-17 18:53:33.080000000 +0300
@@ -8,7 +8,7 @@
 namespace gpu {
 namespace {
 
-INSTANTIATE_TYPED_TEST_SUITE_P(GpuMemoryBufferFactoryIOSurface,
+INSTANTIATE_TYPED_TEST_CASE_P(GpuMemoryBufferFactoryIOSurface,
                                GpuMemoryBufferFactoryTest,
                                GpuMemoryBufferFactoryIOSurface);
 
--- a/gpu/ipc/service/gpu_memory_buffer_factory_native_pixmap.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/service/gpu_memory_buffer_factory_native_pixmap.cc	2019-05-17 18:53:33.084000000 +0300
@@ -125,7 +125,7 @@
   }
 
   auto image = base::MakeRefCounted<gl::GLImageNativePixmap>(size, format);
-  if (!image->Initialize(std::move(pixmap))) {
+  if (!image->Initialize(pixmap.get())) {
     LOG(ERROR) << "Failed to create GLImage " << size.ToString() << ", "
                << gfx::BufferFormatToString(format);
     return nullptr;
@@ -162,7 +162,7 @@
     return nullptr;
   }
   auto image = base::MakeRefCounted<gl::GLImageNativePixmap>(size, format);
-  if (!image->Initialize(std::move(pixmap))) {
+  if (!image->Initialize(pixmap.get())) {
     LOG(ERROR) << "Failed to create GLImage " << size.ToString() << ", "
                << gfx::BufferFormatToString(format);
     return nullptr;
--- a/gpu/ipc/service/gpu_memory_buffer_factory_native_pixmap_unittest.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/service/gpu_memory_buffer_factory_native_pixmap_unittest.cc	2019-05-17 18:53:33.084000000 +0300
@@ -8,7 +8,7 @@
 namespace gpu {
 namespace {
 
-INSTANTIATE_TYPED_TEST_SUITE_P(GpuMemoryBufferFactoryNativePixmap,
+INSTANTIATE_TYPED_TEST_CASE_P(GpuMemoryBufferFactoryNativePixmap,
                                GpuMemoryBufferFactoryTest,
                                GpuMemoryBufferFactoryNativePixmap);
 
--- a/gpu/ipc/service/gpu_memory_buffer_factory_test_template.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/service/gpu_memory_buffer_factory_test_template.h	2019-05-17 18:53:33.084000000 +0300
@@ -41,7 +41,7 @@
   GpuMemoryBufferFactoryType factory_;
 };
 
-TYPED_TEST_SUITE_P(GpuMemoryBufferFactoryTest);
+TYPED_TEST_CASE_P(GpuMemoryBufferFactoryTest);
 
 TYPED_TEST_P(GpuMemoryBufferFactoryTest, CreateGpuMemoryBuffer) {
   const gfx::GpuMemoryBufferId kBufferId(1);
@@ -76,7 +76,7 @@
 
 // The GpuMemoryBufferFactoryTest test case verifies behavior that is expected
 // from a GpuMemoryBuffer factory in order to be conformant.
-REGISTER_TYPED_TEST_SUITE_P(GpuMemoryBufferFactoryTest, CreateGpuMemoryBuffer);
+REGISTER_TYPED_TEST_CASE_P(GpuMemoryBufferFactoryTest, CreateGpuMemoryBuffer);
 
 }  // namespace gpu
 
--- a/gpu/ipc/service/image_decode_accelerator_stub.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/service/image_decode_accelerator_stub.cc	2019-05-17 18:53:33.084000000 +0300
@@ -4,37 +4,24 @@
 
 #include "gpu/ipc/service/image_decode_accelerator_stub.h"
 
-#include <utility>
-
 #include "base/bind.h"
-#include "base/containers/span.h"
 #include "base/feature_list.h"
 #include "base/location.h"
 #include "base/logging.h"
 #include "base/single_thread_task_runner.h"
 #include "gpu/command_buffer/common/constants.h"
-#include "gpu/command_buffer/common/context_result.h"
-#include "gpu/command_buffer/common/discardable_handle.h"
 #include "gpu/command_buffer/common/scheduling_priority.h"
 #include "gpu/command_buffer/common/sync_token.h"
-#include "gpu/command_buffer/service/context_group.h"
-#include "gpu/command_buffer/service/decoder_context.h"
 #include "gpu/command_buffer/service/scheduler.h"
-#include "gpu/command_buffer/service/service_transfer_cache.h"
-#include "gpu/command_buffer/service/shared_context_state.h"
 #include "gpu/command_buffer/service/sync_point_manager.h"
 #include "gpu/config/gpu_finch_features.h"
 #include "gpu/ipc/common/command_buffer_id.h"
-#include "gpu/ipc/service/command_buffer_stub.h"
 #include "gpu/ipc/service/gpu_channel.h"
-#include "gpu/ipc/service/gpu_channel_manager.h"
 #include "gpu/ipc/service/image_decode_accelerator_worker.h"
 #include "ipc/ipc_message.h"
 #include "ipc/ipc_message_macros.h"
-#include "ui/gfx/color_space.h"
 
 namespace gpu {
-class Buffer;
 
 ImageDecodeAcceleratorStub::ImageDecodeAcceleratorStub(
     ImageDecodeAcceleratorWorker* worker,
@@ -90,8 +77,8 @@
     uint64_t release_count) {
   DCHECK(io_task_runner_->BelongsToCurrentThread());
   base::AutoLock lock(lock_);
-  if (!channel_ || destroying_channel_) {
-    // The channel is no longer available, so don't do anything.
+  if (!channel_) {
+    // The channel is no longer available, so don't schedule a decode.
     return;
   }
 
@@ -112,24 +99,19 @@
   }
 
   // Start the actual decode.
-  worker_->Decode(
-      std::move(decode_params.encoded_data), decode_params.output_size,
+  worker_->Decode(std::move(decode_params.encoded_data),
+                  decode_params.output_size,
       base::BindOnce(&ImageDecodeAcceleratorStub::OnDecodeCompleted,
-                     base::WrapRefCounted(this), decode_params.output_size));
+                                 base::WrapRefCounted(this)));
 
   // Schedule a task to eventually release the decode sync token. Note that this
   // task won't run until the sequence is re-enabled when a decode completes.
-  const SyncToken discardable_handle_sync_token = SyncToken(
-      CommandBufferNamespace::GPU_IO,
-      CommandBufferIdFromChannelAndRoute(channel_->client_id(),
-                                         decode_params.raster_decoder_route_id),
-      decode_params.discardable_handle_release_count);
   channel_->scheduler()->ScheduleTask(Scheduler::Task(
       sequence_,
       base::BindOnce(&ImageDecodeAcceleratorStub::ProcessCompletedDecode,
                      base::WrapRefCounted(this), std::move(decode_params),
                      release_count),
-      {discardable_handle_sync_token} /* sync_token_fences */));
+      std::vector<SyncToken>()));
 }
 
 void ImageDecodeAcceleratorStub::ProcessCompletedDecode(
@@ -137,82 +119,14 @@
     uint64_t decode_release_count) {
   DCHECK(main_task_runner_->BelongsToCurrentThread());
   base::AutoLock lock(lock_);
-  if (!channel_ || destroying_channel_) {
+  if (!channel_) {
     // The channel is no longer available, so don't do anything.
     return;
   }
 
-  DCHECK(!pending_completed_decodes_.empty());
-  std::unique_ptr<CompletedDecode> completed_decode =
-      std::move(pending_completed_decodes_.front());
-
-  // Gain access to the transfer cache through the GpuChannelManager's
-  // SharedContextState. We will also use that to get a GrContext that will be
-  // used for uploading the image.
-  ContextResult context_result;
-  scoped_refptr<SharedContextState> shared_context_state =
-      channel_->gpu_channel_manager()->GetSharedContextState(&context_result);
-  if (context_result != ContextResult::kSuccess) {
-    DLOG(ERROR) << "Unable to obtain the SharedContextState";
-    OnError();
-    return;
-  }
-  DCHECK(shared_context_state);
-  if (!shared_context_state->gr_context()) {
-    DLOG(ERROR) << "Could not get the GrContext";
-    OnError();
-    return;
-  }
-  if (!shared_context_state->MakeCurrent(nullptr /* surface */)) {
-    DLOG(ERROR) << "Could not MakeCurrent the shared context";
-    OnError();
-    return;
-  }
-
-  // Insert the cache entry in the transfer cache. Note that this section
-  // validates several of the IPC parameters: |params.raster_decoder_route_id|,
-  // |params.transfer_cache_entry_id|, |params.discardable_handle_shm_id|, and
-  // |params.discardable_handle_shm_offset|.
-  CommandBufferStub* command_buffer =
-      channel_->LookupCommandBuffer(params.raster_decoder_route_id);
-  if (!command_buffer) {
-    DLOG(ERROR) << "Could not find the command buffer";
-    OnError();
-    return;
-  }
-  scoped_refptr<Buffer> handle_buffer =
-      command_buffer->GetTransferBuffer(params.discardable_handle_shm_id);
-  if (!DiscardableHandleBase::ValidateParameters(
-          handle_buffer.get(), params.discardable_handle_shm_offset)) {
-    DLOG(ERROR) << "Could not validate the discardable handle parameters";
-    OnError();
-    return;
-  }
-  DCHECK(command_buffer->decoder_context());
-  if (command_buffer->decoder_context()->GetRasterDecoderId() < 0) {
-    DLOG(ERROR) << "Could not get the raster decoder ID";
-    OnError();
-    return;
-  }
-  DCHECK(shared_context_state->transfer_cache());
-  if (!shared_context_state->transfer_cache()->CreateLockedImageEntry(
-          command_buffer->decoder_context()->GetRasterDecoderId(),
-          params.transfer_cache_entry_id,
-          ServiceDiscardableHandle(std::move(handle_buffer),
-                                   params.discardable_handle_shm_offset,
-                                   params.discardable_handle_shm_id),
-          shared_context_state->gr_context(),
-          base::make_span(completed_decode->output),
-          completed_decode->row_bytes, completed_decode->image_info,
-          params.needs_mips, params.target_color_space.ToSkColorSpace())) {
-    DLOG(ERROR) << "Could not create and insert the transfer cache entry";
-    OnError();
-    return;
-  }
-  shared_context_state->set_need_context_state_reset(true);
+  // TODO(andrescj): create the transfer cache entry. Doing so will also upload
+  // the decoded image to a GPU texture.
 
-  // All done! The decoded image can now be used for rasterization, so we can
-  // release the decode sync token.
   sync_point_client_state_->ReleaseFenceSync(decode_release_count);
 
   // If there are no more completed decodes to be processed, we can disable the
@@ -223,42 +137,27 @@
     channel_->scheduler()->DisableSequence(sequence_);
 }
 
-ImageDecodeAcceleratorStub::CompletedDecode::CompletedDecode(
-    std::vector<uint8_t> output,
-    size_t row_bytes,
-    SkImageInfo image_info)
-    : output(std::move(output)), row_bytes(row_bytes), image_info(image_info) {}
-
-ImageDecodeAcceleratorStub::CompletedDecode::~CompletedDecode() = default;
-
 void ImageDecodeAcceleratorStub::OnDecodeCompleted(
-    gfx::Size expected_output_size,
-    std::vector<uint8_t> output,
-    size_t row_bytes,
-    SkImageInfo image_info) {
+    std::vector<uint8_t> rgba_output) {
   base::AutoLock lock(lock_);
-  if (!channel_ || destroying_channel_) {
+  if (!channel_) {
     // The channel is no longer available, so don't do anything.
     return;
   }
 
-  if (output.empty()) {
+  if (!accepting_completed_decodes_) {
+    // We're still waiting for the channel to be destroyed because of an earlier
+    // failure, so don't do anything.
+    return;
+  }
+
+  if (rgba_output.empty()) {
     DLOG(ERROR) << "The decode failed";
     OnError();
     return;
   }
 
-  // Some sanity checks on the output of the decoder.
-  DCHECK_EQ(expected_output_size.width(), image_info.width());
-  DCHECK_EQ(expected_output_size.height(), image_info.height());
-  DCHECK_NE(0u, image_info.minRowBytes());
-  DCHECK_GE(row_bytes, image_info.minRowBytes());
-  DCHECK_EQ(output.size(), image_info.computeByteSize(row_bytes));
-
-  // The decode is ready to be processed: add it to |pending_completed_decodes_|
-  // so that ProcessCompletedDecode() can pick it up.
-  pending_completed_decodes_.push(std::make_unique<CompletedDecode>(
-      std::move(output), row_bytes, image_info));
+  pending_completed_decodes_.push(std::move(rgba_output));
 
   // We only need to enable the sequence when the number of pending completed
   // decodes is 1. If there are more, the sequence should already be enabled.
@@ -267,7 +166,6 @@
 }
 
 void ImageDecodeAcceleratorStub::OnError() {
-  lock_.AssertAcquired();
   DCHECK(channel_);
 
   // Trigger the destruction of the channel and stop processing further
@@ -275,7 +173,7 @@
   // GpuChannel::OnChannelError() directly because that will end up calling
   // ImageDecodeAcceleratorStub::Shutdown() while |lock_| is still acquired. So,
   // we post a task to the main thread instead.
-  destroying_channel_ = true;
+  accepting_completed_decodes_ = false;
   channel_->task_runner()->PostTask(
       FROM_HERE,
       base::BindOnce(&GpuChannel::OnChannelError, channel_->AsWeakPtr()));
--- a/gpu/ipc/service/image_decode_accelerator_stub.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/service/image_decode_accelerator_stub.h	2019-05-17 18:53:33.084000000 +0300
@@ -5,10 +5,6 @@
 #ifndef GPU_IPC_SERVICE_IMAGE_DECODE_ACCELERATOR_STUB_H_
 #define GPU_IPC_SERVICE_IMAGE_DECODE_ACCELERATOR_STUB_H_
 
-#include <stddef.h>
-#include <stdint.h>
-
-#include <memory>
 #include <vector>
 
 #include "base/containers/queue.h"
@@ -19,8 +15,6 @@
 #include "base/thread_annotations.h"
 #include "gpu/command_buffer/service/sequence_id.h"
 #include "gpu/ipc/common/gpu_messages.h"
-#include "third_party/skia/include/core/SkImageInfo.h"
-#include "ui/gfx/geometry/size.h"
 
 namespace base {
 class SingleThreadTaskRunner;
@@ -80,13 +74,10 @@
                               uint64_t decode_release_count);
 
   // The |worker_| calls this when a decode is completed. If the decode is
-  // successful (i.e., |output| is not empty), |sequence_| will be enabled so
-  // that ProcessCompletedDecode() is called. If the decode is not successful,
-  // we destroy the channel (see OnError()).
-  void OnDecodeCompleted(gfx::Size expected_output_size,
-                         std::vector<uint8_t> output,
-                         size_t row_bytes,
-                         SkImageInfo image_info);
+  // successful (i.e., |rgba_output| is not empty), |sequence_| will be enabled
+  // so that ProcessCompletedDecode() is called. If the decode is not
+  // successful, we destroy the channel (see OnError()).
+  void OnDecodeCompleted(std::vector<uint8_t> rgba_output);
 
   // Triggers the destruction of the channel asynchronously and makes it so that
   // we stop accepting completed decodes. On entry, |channel_| must not be
@@ -96,27 +87,14 @@
   // The object to which the actual decoding can be delegated.
   ImageDecodeAcceleratorWorker* worker_ = nullptr;
 
-  struct CompletedDecode {
-    CompletedDecode(std::vector<uint8_t> output,
-                    size_t row_bytes,
-                    SkImageInfo image_info);
-    ~CompletedDecode();
-
-    std::vector<uint8_t> output;
-    size_t row_bytes;
-    SkImageInfo image_info;
-
-    DISALLOW_COPY_AND_ASSIGN(CompletedDecode);
-  };
-
   base::Lock lock_;
   GpuChannel* channel_ GUARDED_BY(lock_) = nullptr;
   SequenceId sequence_ GUARDED_BY(lock_);
   scoped_refptr<SyncPointClientState> sync_point_client_state_
       GUARDED_BY(lock_);
-  base::queue<std::unique_ptr<CompletedDecode>> pending_completed_decodes_
+  base::queue<std::vector<uint8_t>> pending_completed_decodes_
       GUARDED_BY(lock_);
-  bool destroying_channel_ GUARDED_BY(lock_) = false;
+  bool accepting_completed_decodes_ GUARDED_BY(lock_) = true;
   uint64_t last_release_count_ GUARDED_BY(lock_) = 0;
 
   scoped_refptr<base::SingleThreadTaskRunner> main_task_runner_;
--- a/gpu/ipc/service/image_decode_accelerator_stub_unittest.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/service/image_decode_accelerator_stub_unittest.cc	2019-05-17 18:53:33.084000000 +0300
@@ -2,78 +2,29 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include <stddef.h>
-#include <stdint.h>
-
-#include <utility>
-#include <vector>
-
-#include "base/atomicops.h"
-#include "base/bind.h"
 #include "base/containers/queue.h"
-#include "base/logging.h"
 #include "base/macros.h"
-#include "base/memory/scoped_refptr.h"
-#include "base/memory/weak_ptr.h"
 #include "base/numerics/checked_math.h"
 #include "base/test/scoped_feature_list.h"
 #include "base/test/test_simple_task_runner.h"
-#include "cc/paint/image_transfer_cache_entry.h"
-#include "cc/paint/transfer_cache_entry.h"
-#include "gpu/command_buffer/common/buffer.h"
-#include "gpu/command_buffer/common/capabilities.h"
 #include "gpu/command_buffer/common/constants.h"
-#include "gpu/command_buffer/common/context_creation_attribs.h"
-#include "gpu/command_buffer/common/context_result.h"
-#include "gpu/command_buffer/common/discardable_handle.h"
-#include "gpu/command_buffer/common/scheduling_priority.h"
 #include "gpu/command_buffer/common/sync_token.h"
-#include "gpu/command_buffer/service/context_group.h"
-#include "gpu/command_buffer/service/decoder_context.h"
-#include "gpu/command_buffer/service/mocks.h"
-#include "gpu/command_buffer/service/scheduler.h"
-#include "gpu/command_buffer/service/sequence_id.h"
-#include "gpu/command_buffer/service/service_transfer_cache.h"
-#include "gpu/command_buffer/service/shared_context_state.h"
 #include "gpu/command_buffer/service/sync_point_manager.h"
-#include "gpu/command_buffer/service/transfer_buffer_manager.h"
-#include "gpu/config/gpu_driver_bug_workarounds.h"
 #include "gpu/config/gpu_finch_features.h"
 #include "gpu/ipc/common/command_buffer_id.h"
 #include "gpu/ipc/common/gpu_messages.h"
-#include "gpu/ipc/common/surface_handle.h"
-#include "gpu/ipc/service/command_buffer_stub.h"
-#include "gpu/ipc/service/gpu_channel.h"
 #include "gpu/ipc/service/gpu_channel_manager.h"
 #include "gpu/ipc/service/gpu_channel_test_common.h"
 #include "gpu/ipc/service/image_decode_accelerator_worker.h"
-#include "ipc/ipc_message.h"
 #include "testing/gmock/include/gmock/gmock.h"
-#include "third_party/skia/include/core/SkImage.h"
-#include "third_party/skia/include/core/SkImageInfo.h"
-#include "third_party/skia/include/core/SkSize.h"
 #include "ui/gfx/color_space.h"
 #include "ui/gfx/geometry/size.h"
-#include "url/gurl.h"
 
 using testing::InSequence;
 using testing::StrictMock;
 
 namespace gpu {
-class MemoryTracker;
-
-namespace {
-
-std::unique_ptr<MemoryTracker> CreateMockMemoryTracker(
-    const GPUCreateCommandBufferConfig& init_params) {
-  return std::make_unique<gles2::MockMemoryTracker>();
-}
-
-scoped_refptr<Buffer> MakeBufferForTesting() {
-  return MakeMemoryBuffer(sizeof(base::subtle::Atomic32));
-}
-
-}  // namespace
+class GpuChannel;
 
 // This mock allows individual tests to decide asynchronously when to finish a
 // decode by using the FinishOneDecode() method.
@@ -83,7 +34,7 @@
 
   void Decode(std::vector<uint8_t> encoded_data,
               const gfx::Size& output_size,
-              CompletedDecodeCB decode_cb) {
+              base::OnceCallback<void(std::vector<uint8_t>)> decode_cb) {
     pending_decodes_.push(PendingDecode{output_size, std::move(decode_cb)});
     DoDecode(output_size);
   }
@@ -94,19 +45,13 @@
     PendingDecode next_decode = std::move(pending_decodes_.front());
     pending_decodes_.pop();
     if (success) {
-      base::CheckedNumeric<size_t> row_bytes = 4u;
-      row_bytes *= next_decode.output_size.width();
-      base::CheckedNumeric<size_t> rgba_bytes = row_bytes;
+      base::CheckedNumeric<size_t> rgba_bytes = 4u;
+      rgba_bytes *= next_decode.output_size.width();
       rgba_bytes *= next_decode.output_size.height();
       std::vector<uint8_t> rgba_output(rgba_bytes.ValueOrDie(), 0u);
-      std::move(next_decode.decode_cb)
-          .Run(std::move(rgba_output), row_bytes.ValueOrDie(),
-               SkImageInfo::Make(next_decode.output_size.width(),
-                                 next_decode.output_size.height(),
-                                 kRGBA_8888_SkColorType, kOpaque_SkAlphaType));
+      std::move(next_decode.decode_cb).Run(std::move(rgba_output));
     } else {
-      std::move(next_decode.decode_cb)
-          .Run(std::vector<uint8_t>(), 0u, SkImageInfo());
+      std::move(next_decode.decode_cb).Run(std::vector<uint8_t>());
     }
   }
 
@@ -115,7 +60,7 @@
  private:
   struct PendingDecode {
     gfx::Size output_size;
-    CompletedDecodeCB decode_cb;
+    base::OnceCallback<void(std::vector<uint8_t>)> decode_cb;
   };
 
   base::queue<PendingDecode> pending_decodes_;
@@ -125,46 +70,19 @@
 
 const int kChannelId = 1;
 
-const int32_t kCommandBufferRouteId =
-    static_cast<int32_t>(GpuChannelReservedRoutes::kMaxValue) + 1;
-
 // Test fixture: the general strategy for testing is to have a GPU channel test
 // infrastructure (provided by GpuChannelTestCommon), ask the channel to handle
-// decode requests, and expect sync token releases, invocations to the
-// ImageDecodeAcceleratorWorker functionality, and transfer cache entry
-// creation.
+// decode requests, and expect sync token releases and invokations to the
+// ImageDecodeAcceleratorWorker functionality.
 class ImageDecodeAcceleratorStubTest : public GpuChannelTestCommon {
  public:
-  ImageDecodeAcceleratorStubTest()
-      : GpuChannelTestCommon(false /* use_stub_bindings */),
-        weak_ptr_factory_(this) {}
+  ImageDecodeAcceleratorStubTest() : GpuChannelTestCommon() {}
   ~ImageDecodeAcceleratorStubTest() override = default;
 
   SyncPointManager* sync_point_manager() const {
     return channel_manager()->sync_point_manager();
   }
 
-  ServiceTransferCache* GetServiceTransferCache() {
-    ContextResult context_result;
-    scoped_refptr<SharedContextState> shared_context_state =
-        channel_manager()->GetSharedContextState(&context_result);
-    if (context_result != ContextResult::kSuccess || !shared_context_state) {
-      return nullptr;
-    }
-    return shared_context_state->transfer_cache();
-  }
-
-  int GetRasterDecoderId() {
-    GpuChannel* channel = channel_manager()->LookupChannel(kChannelId);
-    if (!channel)
-      return -1;
-    CommandBufferStub* command_buffer =
-        channel->LookupCommandBuffer(kCommandBufferRouteId);
-    if (!command_buffer || !command_buffer->decoder_context())
-      return -1;
-    return command_buffer->decoder_context()->GetRasterDecoderId();
-  }
-
   void SetUp() override {
     GpuChannelTestCommon::SetUp();
     // TODO(andrescj): get rid of the |feature_list_| when the feature is
@@ -173,49 +91,7 @@
         features::kVaapiJpegImageDecodeAcceleration);
     channel_manager()->SetImageDecodeAcceleratorWorkerForTesting(
         &image_decode_accelerator_worker_);
-
-    // Initialize the GrContext so that texture uploading works.
-    ContextResult context_result;
-    scoped_refptr<SharedContextState> shared_context_state =
-        channel_manager()->GetSharedContextState(&context_result);
-    ASSERT_EQ(ContextResult::kSuccess, context_result);
-    ASSERT_TRUE(shared_context_state);
-    shared_context_state->InitializeGrContext(GpuDriverBugWorkarounds(),
-                                              nullptr);
-
-    GpuChannel* channel = CreateChannel(kChannelId, false /* is_gpu_host */);
-    ASSERT_TRUE(channel);
-
-    // Create a raster command buffer so that the ImageDecodeAcceleratorStub can
-    // have access to a TransferBufferManager. Note that we mock the
-    // MemoryTracker because GpuCommandBufferMemoryTracker uses a timer that
-    // would make RunTasksUntilIdle() run forever.
-    CommandBufferStub::SetMemoryTrackerFactoryForTesting(
-        base::BindRepeating(&CreateMockMemoryTracker));
-    GPUCreateCommandBufferConfig init_params;
-    init_params.surface_handle = kNullSurfaceHandle;
-    init_params.share_group_id = MSG_ROUTING_NONE;
-    init_params.stream_id = 0;
-    init_params.stream_priority = SchedulingPriority::kNormal;
-    init_params.attribs = ContextCreationAttribs();
-    init_params.attribs.enable_gles2_interface = false;
-    init_params.attribs.enable_raster_interface = true;
-    init_params.attribs.bind_generates_resource = false;
-    init_params.active_url = GURL();
-    ContextResult result = ContextResult::kTransientFailure;
-    Capabilities capabilities;
-    HandleMessage(channel,
-                  new GpuChannelMsg_CreateCommandBuffer(
-                      init_params, kCommandBufferRouteId,
-                      GetSharedMemoryRegion(), &result, &capabilities));
-    ASSERT_EQ(ContextResult::kSuccess, result);
-    CommandBufferStub* command_buffer =
-        channel->LookupCommandBuffer(kCommandBufferRouteId);
-    ASSERT_TRUE(command_buffer);
-
-    // Make sure there are no pending tasks before starting the test.
-    ASSERT_EQ(0u, task_runner()->NumPendingTasks());
-    ASSERT_EQ(0u, io_task_runner()->NumPendingTasks());
+    ASSERT_TRUE(CreateChannel(kChannelId, false /* is_gpu_host */));
   }
 
   void TearDown() override {
@@ -224,60 +100,8 @@
     channel_manager()->DestroyAllChannels();
   }
 
-  // Intended to run as a task in the GPU scheduler (in the raster sequence):
-  // registers |buffer| in the TransferBufferManager and releases the sync token
-  // corresponding to |handle_release_count|.
-  void RegisterDiscardableHandleBuffer(int32_t shm_id,
-                                       scoped_refptr<Buffer> buffer,
-                                       uint64_t handle_release_count) {
-    GpuChannel* channel = channel_manager()->LookupChannel(kChannelId);
-    CHECK(channel);
-    CommandBufferStub* command_buffer =
-        channel->LookupCommandBuffer(kCommandBufferRouteId);
-    CHECK(command_buffer);
-    command_buffer->RegisterTransferBufferForTest(shm_id, std::move(buffer));
-    command_buffer->OnFenceSyncRelease(handle_release_count);
-  }
-
-  // Creates a discardable handle and schedules a task in the GPU scheduler (in
-  // the raster sequence) to register the handle's buffer and release the sync
-  // token corresponding to |handle_release_count| (see the
-  // RegisterDiscardableHandleBuffer() method). Returns an invalid handle if the
-  // GPU channel or the command buffer doesn't exist.
-  ClientDiscardableHandle CreateDiscardableHandle(
-      uint64_t handle_release_count) {
-    GpuChannel* channel = channel_manager()->LookupChannel(kChannelId);
-    if (!channel)
-      return ClientDiscardableHandle();
-    CommandBufferStub* command_buffer =
-        channel->LookupCommandBuffer(kCommandBufferRouteId);
-    if (!command_buffer)
-      return ClientDiscardableHandle();
-    ClientDiscardableHandle handle(MakeBufferForTesting() /* buffer */,
-                                   0u /* byte_offset */,
-                                   GetNextBufferId() /* shm_id */);
-    scheduler()->ScheduleTask(Scheduler::Task(
-        command_buffer->sequence_id(),
-        base::BindOnce(
-            &ImageDecodeAcceleratorStubTest::RegisterDiscardableHandleBuffer,
-            weak_ptr_factory_.GetWeakPtr(), handle.shm_id(),
-            handle.BufferForTesting(), handle_release_count) /* closure */,
-        std::vector<SyncToken>() /* sync_token_fences */));
-    return handle;
-  }
-
-  // Sends a decode request IPC and returns a sync token that is expected to be
-  // released upon the completion of the decode. The caller is responsible for
-  // keeping track of the release count for the decode sync token
-  // (|decode_release_count|), the transfer cache entry ID
-  // (|transfer_cache_entry_id|), and the release count of the sync token that
-  // is signaled after the discardable handle's buffer has been registered in
-  // the TransferBufferManager. If the channel does not exist or the discardable
-  // handle can't be created, this function returns an empty sync token.
   SyncToken SendDecodeRequest(const gfx::Size& output_size,
-                              uint64_t decode_release_count,
-                              uint32_t transfer_cache_entry_id,
-                              uint64_t handle_release_count) {
+                              uint64_t release_count) {
     GpuChannel* channel = channel_manager()->LookupChannel(kChannelId);
     if (!channel) {
       // It's possible that the channel was destroyed as part of an earlier
@@ -287,30 +111,19 @@
       return SyncToken();
     }
 
-    // Create the decode sync token for the decode request so that we can test
-    // that it's actually released.
     SyncToken decode_sync_token(
         CommandBufferNamespace::GPU_IO,
         CommandBufferIdFromChannelAndRoute(
             kChannelId, static_cast<int32_t>(
                             GpuChannelReservedRoutes::kImageDecodeAccelerator)),
-        decode_release_count);
-
-    // Create a discardable handle and schedule its buffer's registration.
-    ClientDiscardableHandle handle =
-        CreateDiscardableHandle(handle_release_count);
-    if (!handle.IsValid())
-      return SyncToken();
-
-    // Send the IPC decode request.
+        release_count);
     GpuChannelMsg_ScheduleImageDecode_Params decode_params;
     decode_params.encoded_data = std::vector<uint8_t>();
     decode_params.output_size = output_size;
-    decode_params.raster_decoder_route_id = kCommandBufferRouteId;
-    decode_params.transfer_cache_entry_id = transfer_cache_entry_id;
-    decode_params.discardable_handle_shm_id = handle.shm_id();
-    decode_params.discardable_handle_shm_offset = handle.byte_offset();
-    decode_params.discardable_handle_release_count = handle_release_count;
+    decode_params.raster_decoder_route_id = 1;
+    decode_params.transfer_cache_entry_id = 1u;
+    decode_params.discardable_handle_shm_id = 0;
+    decode_params.discardable_handle_shm_offset = 0u;
     decode_params.target_color_space = gfx::ColorSpace();
     decode_params.needs_mips = false;
 
@@ -331,41 +144,11 @@
     }
   }
 
-  void CheckTransferCacheEntries(std::vector<SkISize> expected_sizes) {
-    ServiceTransferCache* transfer_cache = GetServiceTransferCache();
-    ASSERT_TRUE(transfer_cache);
-
-    // First, check the number of entries and early out if 0 entries are
-    // expected.
-    const size_t num_actual_cache_entries =
-        transfer_cache->entries_count_for_testing();
-    ASSERT_EQ(expected_sizes.size(), num_actual_cache_entries);
-    if (expected_sizes.empty())
-      return;
-
-    // Then, check the dimensions of the entries to make sure they are as
-    // expected.
-    int raster_decoder_id = GetRasterDecoderId();
-    ASSERT_GE(raster_decoder_id, 0);
-    for (size_t i = 0; i < num_actual_cache_entries; i++) {
-      auto* decode_entry = static_cast<cc::ServiceImageTransferCacheEntry*>(
-          transfer_cache->GetEntry(ServiceTransferCache::EntryKey(
-              raster_decoder_id, cc::TransferCacheEntryType::kImage, i + 1)));
-      ASSERT_TRUE(decode_entry);
-      ASSERT_TRUE(decode_entry->image());
-      EXPECT_EQ(expected_sizes[i].width(),
-                decode_entry->image()->dimensions().width());
-      EXPECT_EQ(expected_sizes[i].height(),
-                decode_entry->image()->dimensions().height());
-    }
-  }
-
  protected:
   StrictMock<MockImageDecodeAcceleratorWorker> image_decode_accelerator_worker_;
 
  private:
   base::test::ScopedFeatureList feature_list_;
-  base::WeakPtrFactory<ImageDecodeAcceleratorStubTest> weak_ptr_factory_;
 
   DISALLOW_COPY_AND_ASSIGN(ImageDecodeAcceleratorStubTest);
 };
@@ -384,13 +167,9 @@
         .Times(1);
   }
   const SyncToken decode1_sync_token = SendDecodeRequest(
-      gfx::Size(100, 100) /* output_size */, 1u /* decode_release_count */,
-      1u /* transfer_cache_entry_id */, 1u /* handle_release_count */);
-  ASSERT_TRUE(decode1_sync_token.HasData());
+      gfx::Size(100, 100) /* output_size */, 1u /* release_count */);
   const SyncToken decode2_sync_token = SendDecodeRequest(
-      gfx::Size(200, 200) /* output_size */, 2u /* decode_release_count */,
-      2u /* transfer_cache_entry_id */, 2u /* handle_release_count */);
-  ASSERT_TRUE(decode2_sync_token.HasData());
+      gfx::Size(200, 200) /* output_size */, 2u /* release_count */);
 
   // A decode sync token should not be released before a decode is finished.
   RunTasksUntilIdle();
@@ -413,9 +192,6 @@
 
   // The channel should still exist at the end.
   EXPECT_TRUE(channel_manager()->LookupChannel(kChannelId));
-
-  // Check that the decoded images are in the transfer cache.
-  CheckTransferCacheEntries({SkISize::Make(100, 100), SkISize::Make(200, 200)});
 }
 
 // Tests the following flow: three decode requests are sent. The first decode
@@ -434,17 +210,11 @@
         .Times(1);
   }
   const SyncToken decode1_sync_token = SendDecodeRequest(
-      gfx::Size(100, 100) /* output_size */, 1u /* decode_release_count */,
-      1u /* transfer_cache_entry_id */, 1u /* handle_release_count */);
-  ASSERT_TRUE(decode1_sync_token.HasData());
+      gfx::Size(100, 100) /* output_size */, 1u /* release_count */);
   const SyncToken decode2_sync_token = SendDecodeRequest(
-      gfx::Size(200, 200) /* output_size */, 2u /* decode_release_count */,
-      2u /* transfer_cache_entry_id */, 2u /* handle_release_count */);
-  ASSERT_TRUE(decode2_sync_token.HasData());
+      gfx::Size(200, 200) /* output_size */, 2u /* release_count */);
   const SyncToken decode3_sync_token = SendDecodeRequest(
-      gfx::Size(300, 300) /* output_size */, 3u /* decode_release_count */,
-      3u /* transfer_cache_entry_id */, 3u /* handle_release_count */);
-  ASSERT_TRUE(decode3_sync_token.HasData());
+      gfx::Size(300, 300) /* output_size */, 3u /* release_count */);
 
   // A decode sync token should not be released before a decode is finished.
   RunTasksUntilIdle();
@@ -463,10 +233,6 @@
 
   // The channel should still exist at the end.
   EXPECT_TRUE(channel_manager()->LookupChannel(kChannelId));
-
-  // Check that the decoded images are in the transfer cache.
-  CheckTransferCacheEntries({SkISize::Make(100, 100), SkISize::Make(200, 200),
-                             SkISize::Make(300, 300)});
 }
 
 // Tests the following flow: three decode requests are sent. The first decode
@@ -484,17 +250,11 @@
         .Times(1);
   }
   const SyncToken decode1_sync_token = SendDecodeRequest(
-      gfx::Size(100, 100) /* output_size */, 1u /* decode_release_count */,
-      1u /* transfer_cache_entry_id */, 1u /* handle_release_count */);
-  ASSERT_TRUE(decode1_sync_token.HasData());
+      gfx::Size(100, 100) /* output_size */, 1u /* release_count */);
   const SyncToken decode2_sync_token = SendDecodeRequest(
-      gfx::Size(200, 200) /* output_size */, 2u /* decode_release_count */,
-      2u /* transfer_cache_entry_id */, 2u /* handle_release_count */);
-  ASSERT_TRUE(decode2_sync_token.HasData());
+      gfx::Size(200, 200) /* output_size */, 2u /* release_count */);
   const SyncToken decode3_sync_token = SendDecodeRequest(
-      gfx::Size(300, 300) /* output_size */, 3u /* decode_release_count */,
-      3u /* transfer_cache_entry_id */, 3u /* handle_release_count */);
-  ASSERT_TRUE(decode3_sync_token.HasData());
+      gfx::Size(300, 300) /* output_size */, 3u /* release_count */);
 
   // A decode sync token should not be released before a decode is finished.
   RunTasksUntilIdle();
@@ -512,23 +272,15 @@
   EXPECT_TRUE(sync_point_manager()->IsSyncTokenReleased(decode1_sync_token));
   EXPECT_TRUE(sync_point_manager()->IsSyncTokenReleased(decode2_sync_token));
   EXPECT_TRUE(sync_point_manager()->IsSyncTokenReleased(decode3_sync_token));
-
-  // We expect no entries in the transfer cache.
-  CheckTransferCacheEntries({});
 }
 
-TEST_F(ImageDecodeAcceleratorStubTest, OutOfOrderDecodeSyncTokens) {
+TEST_F(ImageDecodeAcceleratorStubTest, OutOfOrderSyncTokens) {
   EXPECT_CALL(image_decode_accelerator_worker_, DoDecode(gfx::Size(100, 100)))
       .Times(1);
   const SyncToken decode1_sync_token = SendDecodeRequest(
-      gfx::Size(100, 100) /* output_size */, 2u /* decode_release_count */,
-      1u /* transfer_cache_entry_id */, 1u /* handle_release_count */);
-  ASSERT_TRUE(decode1_sync_token.HasData());
-
+      gfx::Size(100, 100) /* output_size */, 2u /* release_count */);
   const SyncToken decode2_sync_token = SendDecodeRequest(
-      gfx::Size(200, 200) /* output_size */, 1u /* decode_release_count */,
-      2u /* transfer_cache_entry_id */, 2u /* handle_release_count */);
-  ASSERT_TRUE(decode2_sync_token.HasData());
+      gfx::Size(200, 200) /* output_size */, 1u /* release_count */);
 
   // We expect the destruction of the ImageDecodeAcceleratorStub, which also
   // implies that all decode sync tokens should be released.
@@ -536,113 +288,39 @@
   EXPECT_FALSE(channel_manager()->LookupChannel(kChannelId));
   EXPECT_TRUE(sync_point_manager()->IsSyncTokenReleased(decode1_sync_token));
   EXPECT_TRUE(sync_point_manager()->IsSyncTokenReleased(decode2_sync_token));
-
-  // We expect no entries in the transfer cache.
-  CheckTransferCacheEntries({});
 }
 
-TEST_F(ImageDecodeAcceleratorStubTest, ZeroReleaseCountDecodeSyncToken) {
+TEST_F(ImageDecodeAcceleratorStubTest, ZeroReleaseCountSyncToken) {
   const SyncToken decode_sync_token = SendDecodeRequest(
-      gfx::Size(100, 100) /* output_size */, 0u /* decode_release_count */,
-      1u /* transfer_cache_entry_id */, 1u /* handle_release_count */);
-  ASSERT_TRUE(decode_sync_token.HasData());
+      gfx::Size(100, 100) /* output_size */, 0u /* release_count */);
 
   // We expect the destruction of the ImageDecodeAcceleratorStub, which also
   // implies that all decode sync tokens should be released.
   RunTasksUntilIdle();
   EXPECT_FALSE(channel_manager()->LookupChannel(kChannelId));
   EXPECT_TRUE(sync_point_manager()->IsSyncTokenReleased(decode_sync_token));
-
-  // We expect no entries in the transfer cache.
-  CheckTransferCacheEntries({});
 }
 
 TEST_F(ImageDecodeAcceleratorStubTest, ZeroWidthOutputSize) {
   const SyncToken decode_sync_token = SendDecodeRequest(
-      gfx::Size(0, 100) /* output_size */, 1u /* decode_release_count */,
-      1u /* transfer_cache_entry_id */, 1u /* handle_release_count */);
-  ASSERT_TRUE(decode_sync_token.HasData());
+      gfx::Size(0, 100) /* output_size */, 1u /* release_count */);
 
   // We expect the destruction of the ImageDecodeAcceleratorStub, which also
   // implies that all decode sync tokens should be released.
   RunTasksUntilIdle();
   EXPECT_FALSE(channel_manager()->LookupChannel(kChannelId));
   EXPECT_TRUE(sync_point_manager()->IsSyncTokenReleased(decode_sync_token));
-
-  // We expect no entries in the transfer cache.
-  CheckTransferCacheEntries({});
 }
 
 TEST_F(ImageDecodeAcceleratorStubTest, ZeroHeightOutputSize) {
   const SyncToken decode_sync_token = SendDecodeRequest(
-      gfx::Size(100, 0) /* output_size */, 1u /* decode_release_count */,
-      1u /* transfer_cache_entry_id */, 1u /* handle_release_count */);
-  ASSERT_TRUE(decode_sync_token.HasData());
+      gfx::Size(100, 0) /* output_size */, 1u /* release_count */);
 
   // We expect the destruction of the ImageDecodeAcceleratorStub, which also
   // implies that all decode sync tokens should be released.
   RunTasksUntilIdle();
   EXPECT_FALSE(channel_manager()->LookupChannel(kChannelId));
   EXPECT_TRUE(sync_point_manager()->IsSyncTokenReleased(decode_sync_token));
-
-  // We expect no entries in the transfer cache.
-  CheckTransferCacheEntries({});
-}
-
-// Tests that we wait for a discardable handle's buffer to be registered before
-// we attempt to process the corresponding completed decode.
-TEST_F(ImageDecodeAcceleratorStubTest, WaitForDiscardableHandleRegistration) {
-  EXPECT_CALL(image_decode_accelerator_worker_, DoDecode(gfx::Size(100, 100)))
-      .Times(1);
-
-  // First, we disable the raster sequence so that we can control when to
-  // register the discardable handle's buffer by re-enabling the sequence.
-  GpuChannel* channel = channel_manager()->LookupChannel(kChannelId);
-  ASSERT_TRUE(channel);
-  const CommandBufferStub* command_buffer =
-      channel->LookupCommandBuffer(kCommandBufferRouteId);
-  ASSERT_TRUE(command_buffer);
-  const SequenceId raster_sequence_id = command_buffer->sequence_id();
-  scheduler()->DisableSequence(raster_sequence_id);
-
-  // Now we can send the decode request. This schedules the registration of the
-  // discardable handle, but it won't actually be registered until we re-enable
-  // the raster sequence later on.
-  const SyncToken decode_sync_token = SendDecodeRequest(
-      gfx::Size(100, 100) /* output_size */, 1u /* decode_release_count */,
-      1u /* transfer_cache_entry_id */, 1u /* handle_release_count */);
-  ASSERT_TRUE(decode_sync_token.HasData());
-
-  // A decode sync token should not be released before a decode is finished.
-  RunTasksUntilIdle();
-  EXPECT_FALSE(sync_point_manager()->IsSyncTokenReleased(decode_sync_token));
-
-  // Even when a decode is finished, the decode sync token shouldn't be released
-  // before the discardable handle's buffer is registered.
-  image_decode_accelerator_worker_.FinishOneDecode(true);
-  RunTasksUntilIdle();
-  EXPECT_FALSE(sync_point_manager()->IsSyncTokenReleased(decode_sync_token));
-
-  // Let's make sure that the channel and the command buffer are still alive
-  // because if we didn't wait for the discardable handle's buffer to be
-  // registered, we could have caused a channel teardown.
-  ASSERT_TRUE(channel_manager()->LookupChannel(kChannelId));
-  ASSERT_TRUE(channel_manager()
-                  ->LookupChannel(kChannelId)
-                  ->LookupCommandBuffer(kCommandBufferRouteId));
-
-  // Now let's register the discardable handle's buffer by re-enabling the
-  // raster sequence. This should trigger the processing of the completed decode
-  // and the subsequent release of the decode sync token.
-  scheduler()->EnableSequence(raster_sequence_id);
-  RunTasksUntilIdle();
-  EXPECT_TRUE(sync_point_manager()->IsSyncTokenReleased(decode_sync_token));
-
-  // The channel should still exist at the end.
-  EXPECT_TRUE(channel_manager()->LookupChannel(kChannelId));
-
-  // Check that the decoded images are in the transfer cache.
-  CheckTransferCacheEntries({SkISize::Make(100, 100)});
 }
 
 }  // namespace gpu
--- a/gpu/ipc/service/image_decode_accelerator_worker.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/service/image_decode_accelerator_worker.h	2019-05-17 18:53:33.084000000 +0300
@@ -5,13 +5,9 @@
 #ifndef GPU_IPC_SERVICE_IMAGE_DECODE_ACCELERATOR_WORKER_H_
 #define GPU_IPC_SERVICE_IMAGE_DECODE_ACCELERATOR_WORKER_H_
 
-#include <stddef.h>
-#include <stdint.h>
-
 #include <vector>
 
 #include "base/callback.h"
-#include "third_party/skia/include/core/SkImageInfo.h"
 
 namespace gfx {
 class Size;
@@ -25,27 +21,16 @@
  public:
   virtual ~ImageDecodeAcceleratorWorker() {}
 
-  using CompletedDecodeCB =
-      base::OnceCallback<void(std::vector<uint8_t> /* output */,
-                              size_t /* row_bytes */,
-                              SkImageInfo /* image_info */)>;
-
   // Enqueue a decode of |encoded_data|. The |decode_cb| is called
-  // asynchronously when the decode completes passing as parameters a vector
-  // containing the decoded image (|output|), the stride (|row_bytes|), and a
-  // SkImageInfo (|image_info|) with information about the decoded output.
-  // For a successful decode, implementations must guarantee that:
-  //
-  // 1) |image_info|.width() == |output_size|.width().
-  // 2) |image_info|.height() == |output_size|.height().
-  // 3) |row_bytes| >= |image_info|.minRowBytes().
-  // 4) |output|.size() == |image_info|.computeByteSize(|row_bytes|).
-  //
-  // If the decode fails, |decode_cb| is called asynchronously with an empty
-  // vector. Callbacks should be called in the order that this method is called.
-  virtual void Decode(std::vector<uint8_t> encoded_data,
+  // asynchronously when the decode completes passing as a parameter a vector
+  // containing the decoded image in RGBA format (the stride of the output is
+  // |output_size|.width() * 4). If the decode fails, |decode_cb| is called
+  // asynchronously with an empty vector. Callbacks should be called in the
+  // order that this method is called.
+  virtual void Decode(
+      std::vector<uint8_t> encoded_data,
                       const gfx::Size& output_size,
-                      CompletedDecodeCB decode_cb) = 0;
+      base::OnceCallback<void(std::vector<uint8_t>)> decode_cb) = 0;
 };
 
 }  // namespace gpu
--- a/gpu/ipc/service/image_transport_surface_overlay_mac.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/service/image_transport_surface_overlay_mac.h	2019-05-17 18:53:33.084000000 +0300
@@ -45,12 +45,12 @@
               ColorSpace color_space,
               bool has_alpha) override;
   bool IsOffscreen() override;
-  gfx::SwapResult SwapBuffers(PresentationCallback callback) override;
+  gfx::SwapResult SwapBuffers(const PresentationCallback& callback) override;
   gfx::SwapResult PostSubBuffer(int x,
                                 int y,
                                 int width,
                                 int height,
-                                PresentationCallback callback) override;
+                                const PresentationCallback& callback) override;
   bool SupportsPostSubBuffer() override;
   gfx::Size GetSize() override;
   void* GetHandle() override;
@@ -76,9 +76,9 @@
   ~ImageTransportSurfaceOverlayMac() override;
 
   gfx::SwapResult SwapBuffersInternal(const gfx::Rect& pixel_damage_rect,
-                                      PresentationCallback callback);
+                                      const PresentationCallback& callback);
   void ApplyBackpressure();
-  void BufferPresented(PresentationCallback callback,
+  void BufferPresented(const PresentationCallback& callback,
                        const gfx::PresentationFeedback& feedback);
 
   base::WeakPtr<ImageTransportSurfaceDelegate> delegate_;
--- a/gpu/ipc/service/image_transport_surface_overlay_mac.mm	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/service/image_transport_surface_overlay_mac.mm	2019-05-17 18:53:33.084000000 +0300
@@ -7,7 +7,6 @@
 #include <sstream>
 
 #include "base/bind.h"
-#include "base/bind_helpers.h"
 #include "base/command_line.h"
 #include "base/metrics/histogram_macros.h"
 #include "base/threading/thread_task_runner_handle.h"
@@ -90,17 +89,17 @@
 }
 
 void ImageTransportSurfaceOverlayMac::BufferPresented(
-    PresentationCallback callback,
+    const PresentationCallback& callback,
     const gfx::PresentationFeedback& feedback) {
   DCHECK(!callback.is_null());
-  std::move(callback).Run(feedback);
+  callback.Run(feedback);
   if (delegate_)
     delegate_->BufferPresented(feedback);
 }
 
 gfx::SwapResult ImageTransportSurfaceOverlayMac::SwapBuffersInternal(
     const gfx::Rect& pixel_damage_rect,
-    PresentationCallback callback) {
+    const PresentationCallback& callback) {
   TRACE_EVENT0("gpu", "ImageTransportSurfaceOverlayMac::SwapBuffersInternal");
 
   // Do a GL fence for flush to apply back-pressure before drawing.
@@ -167,16 +166,14 @@
   base::ThreadTaskRunnerHandle::Get()->PostTask(
       FROM_HERE,
       base::BindOnce(&ImageTransportSurfaceOverlayMac::BufferPresented,
-                     weak_ptr_factory_.GetWeakPtr(), std::move(callback),
-                     feedback));
+                     weak_ptr_factory_.GetWeakPtr(), callback, feedback));
   return gfx::SwapResult::SWAP_ACK;
 }
 
 gfx::SwapResult ImageTransportSurfaceOverlayMac::SwapBuffers(
-    PresentationCallback callback) {
+    const PresentationCallback& callback) {
   return SwapBuffersInternal(
-      gfx::Rect(0, 0, pixel_size_.width(), pixel_size_.height()),
-      std::move(callback));
+      gfx::Rect(0, 0, pixel_size_.width(), pixel_size_.height()), callback);
 }
 
 gfx::SwapResult ImageTransportSurfaceOverlayMac::PostSubBuffer(
@@ -184,9 +181,8 @@
     int y,
     int width,
     int height,
-    PresentationCallback callback) {
-  return SwapBuffersInternal(gfx::Rect(x, y, width, height),
-                             std::move(callback));
+    const PresentationCallback& callback) {
+  return SwapBuffersInternal(gfx::Rect(x, y, width, height), callback);
 }
 
 bool ImageTransportSurfaceOverlayMac::SupportsPostSubBuffer() {
--- a/gpu/ipc/service/pass_through_image_transport_surface.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/service/pass_through_image_transport_surface.cc	2019-05-17 18:53:33.084000000 +0300
@@ -4,8 +4,6 @@
 
 #include "gpu/ipc/service/pass_through_image_transport_surface.h"
 
-#include <utility>
-
 #include "base/bind.h"
 #include "base/bind_helpers.h"
 #include "base/command_line.h"
@@ -53,20 +51,20 @@
 }
 
 gfx::SwapResult PassThroughImageTransportSurface::SwapBuffers(
-    PresentationCallback callback) {
+    const PresentationCallback& callback) {
   gfx::SwapResponse response;
   StartSwapBuffers(&response);
   gfx::SwapResult result = gl::GLSurfaceAdapter::SwapBuffers(
-      base::BindOnce(&PassThroughImageTransportSurface::BufferPresented,
-                     weak_ptr_factory_.GetWeakPtr(), std::move(callback)));
+      base::Bind(&PassThroughImageTransportSurface::BufferPresented,
+                 weak_ptr_factory_.GetWeakPtr(), callback));
   response.result = result;
   FinishSwapBuffers(std::move(response));
   return result;
 }
 
 void PassThroughImageTransportSurface::SwapBuffersAsync(
-    SwapCompletionCallback completion_callback,
-    PresentationCallback presentation_callback) {
+    const SwapCompletionCallback& completion_callback,
+    const PresentationCallback& presentation_callback) {
   gfx::SwapResponse response;
   StartSwapBuffers(&response);
 
@@ -75,23 +73,21 @@
   // is destroyed. However, this also means that the callback can be run on
   // the calling thread only.
   gl::GLSurfaceAdapter::SwapBuffersAsync(
-      base::BindOnce(&PassThroughImageTransportSurface::FinishSwapBuffersAsync,
-                     weak_ptr_factory_.GetWeakPtr(),
-                     std::move(completion_callback), std::move(response)),
-      base::BindOnce(&PassThroughImageTransportSurface::BufferPresented,
-                     weak_ptr_factory_.GetWeakPtr(),
-                     std::move(presentation_callback)));
+      base::Bind(&PassThroughImageTransportSurface::FinishSwapBuffersAsync,
+                 weak_ptr_factory_.GetWeakPtr(), completion_callback,
+                 base::Passed(&response)),
+      base::Bind(&PassThroughImageTransportSurface::BufferPresented,
+                 weak_ptr_factory_.GetWeakPtr(), presentation_callback));
 }
 
 gfx::SwapResult PassThroughImageTransportSurface::SwapBuffersWithBounds(
     const std::vector<gfx::Rect>& rects,
-    PresentationCallback callback) {
+    const PresentationCallback& callback) {
   gfx::SwapResponse response;
   StartSwapBuffers(&response);
   gfx::SwapResult result = gl::GLSurfaceAdapter::SwapBuffersWithBounds(
-      rects,
-      base::BindOnce(&PassThroughImageTransportSurface::BufferPresented,
-                     weak_ptr_factory_.GetWeakPtr(), std::move(callback)));
+      rects, base::Bind(&PassThroughImageTransportSurface::BufferPresented,
+                        weak_ptr_factory_.GetWeakPtr(), callback));
   response.result = result;
   FinishSwapBuffers(std::move(response));
   return result;
@@ -102,13 +98,13 @@
     int y,
     int width,
     int height,
-    PresentationCallback callback) {
+    const PresentationCallback& callback) {
   gfx::SwapResponse response;
   StartSwapBuffers(&response);
   gfx::SwapResult result = gl::GLSurfaceAdapter::PostSubBuffer(
       x, y, width, height,
-      base::BindOnce(&PassThroughImageTransportSurface::BufferPresented,
-                     weak_ptr_factory_.GetWeakPtr(), std::move(callback)));
+      base::Bind(&PassThroughImageTransportSurface::BufferPresented,
+                 weak_ptr_factory_.GetWeakPtr(), callback));
   response.result = result;
   FinishSwapBuffers(std::move(response));
 
@@ -120,44 +116,42 @@
     int y,
     int width,
     int height,
-    SwapCompletionCallback completion_callback,
-    PresentationCallback presentation_callback) {
+    const GLSurface::SwapCompletionCallback& completion_callback,
+    const PresentationCallback& presentation_callback) {
   gfx::SwapResponse response;
   StartSwapBuffers(&response);
   gl::GLSurfaceAdapter::PostSubBufferAsync(
       x, y, width, height,
-      base::BindOnce(&PassThroughImageTransportSurface::FinishSwapBuffersAsync,
-                     weak_ptr_factory_.GetWeakPtr(),
-                     std::move(completion_callback), std::move(response)),
-      base::BindOnce(&PassThroughImageTransportSurface::BufferPresented,
-                     weak_ptr_factory_.GetWeakPtr(),
-                     std::move(presentation_callback)));
+      base::Bind(&PassThroughImageTransportSurface::FinishSwapBuffersAsync,
+                 weak_ptr_factory_.GetWeakPtr(), completion_callback,
+                 base::Passed(&response)),
+      base::Bind(&PassThroughImageTransportSurface::BufferPresented,
+                 weak_ptr_factory_.GetWeakPtr(), presentation_callback));
 }
 
 gfx::SwapResult PassThroughImageTransportSurface::CommitOverlayPlanes(
-    PresentationCallback callback) {
+    const PresentationCallback& callback) {
   gfx::SwapResponse response;
   StartSwapBuffers(&response);
   gfx::SwapResult result = gl::GLSurfaceAdapter::CommitOverlayPlanes(
-      base::BindOnce(&PassThroughImageTransportSurface::BufferPresented,
-                     weak_ptr_factory_.GetWeakPtr(), std::move(callback)));
+      base::Bind(&PassThroughImageTransportSurface::BufferPresented,
+                 weak_ptr_factory_.GetWeakPtr(), callback));
   response.result = result;
   FinishSwapBuffers(std::move(response));
   return result;
 }
 
 void PassThroughImageTransportSurface::CommitOverlayPlanesAsync(
-    SwapCompletionCallback callback,
-    PresentationCallback presentation_callback) {
+    const GLSurface::SwapCompletionCallback& callback,
+    const PresentationCallback& presentation_callback) {
   gfx::SwapResponse response;
   StartSwapBuffers(&response);
   gl::GLSurfaceAdapter::CommitOverlayPlanesAsync(
-      base::BindOnce(&PassThroughImageTransportSurface::FinishSwapBuffersAsync,
-                     weak_ptr_factory_.GetWeakPtr(), std::move(callback),
-                     std::move(response)),
-      base::BindOnce(&PassThroughImageTransportSurface::BufferPresented,
-                     weak_ptr_factory_.GetWeakPtr(),
-                     std::move(presentation_callback)));
+      base::Bind(&PassThroughImageTransportSurface::FinishSwapBuffersAsync,
+                 weak_ptr_factory_.GetWeakPtr(), callback,
+                 base::Passed(&response)),
+      base::Bind(&PassThroughImageTransportSurface::BufferPresented,
+                 weak_ptr_factory_.GetWeakPtr(), presentation_callback));
 }
 
 void PassThroughImageTransportSurface::SetVSyncEnabled(bool enabled) {
@@ -224,7 +218,7 @@
 }
 
 void PassThroughImageTransportSurface::FinishSwapBuffersAsync(
-    SwapCompletionCallback callback,
+    GLSurface::SwapCompletionCallback callback,
     gfx::SwapResponse response,
     gfx::SwapResult result,
     std::unique_ptr<gfx::GpuFence> gpu_fence) {
@@ -236,14 +230,14 @@
     gpu_fence->Wait();
   response.result = result;
   FinishSwapBuffers(std::move(response));
-  std::move(callback).Run(result, nullptr);
+  callback.Run(result, nullptr);
 }
 
 void PassThroughImageTransportSurface::BufferPresented(
-    GLSurface::PresentationCallback callback,
+    const GLSurface::PresentationCallback& callback,
     const gfx::PresentationFeedback& feedback) {
   DCHECK(allow_running_presentation_callback_);
-  std::move(callback).Run(feedback);
+  callback.Run(feedback);
   if (delegate_)
     delegate_->BufferPresented(feedback);
 }
--- a/gpu/ipc/service/pass_through_image_transport_surface.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/service/pass_through_image_transport_surface.h	2019-05-17 18:53:33.084000000 +0300
@@ -29,26 +29,30 @@
 
   // GLSurface implementation.
   bool Initialize(gl::GLSurfaceFormat format) override;
-  gfx::SwapResult SwapBuffers(PresentationCallback callback) override;
-  void SwapBuffersAsync(SwapCompletionCallback completion_callback,
-                        PresentationCallback presentation_callback) override;
-  gfx::SwapResult SwapBuffersWithBounds(const std::vector<gfx::Rect>& rects,
-                                        PresentationCallback callback) override;
+  gfx::SwapResult SwapBuffers(const PresentationCallback& callback) override;
+  void SwapBuffersAsync(
+      const SwapCompletionCallback& completion_callback,
+      const PresentationCallback& presentation_callback) override;
+  gfx::SwapResult SwapBuffersWithBounds(
+      const std::vector<gfx::Rect>& rects,
+      const PresentationCallback& callback) override;
   gfx::SwapResult PostSubBuffer(int x,
                                 int y,
                                 int width,
                                 int height,
-                                PresentationCallback callback) override;
-  void PostSubBufferAsync(int x,
+                                const PresentationCallback& callback) override;
+  void PostSubBufferAsync(
+      int x,
                           int y,
                           int width,
                           int height,
-                          SwapCompletionCallback completion_callback,
-                          PresentationCallback presentation_callback) override;
-  gfx::SwapResult CommitOverlayPlanes(PresentationCallback callback) override;
+      const SwapCompletionCallback& completion_callback,
+      const PresentationCallback& presentation_callback) override;
+  gfx::SwapResult CommitOverlayPlanes(
+      const PresentationCallback& callback) override;
   void CommitOverlayPlanesAsync(
-      SwapCompletionCallback completion_callback,
-      PresentationCallback presentation_callback) override;
+      const SwapCompletionCallback& completion_callback,
+      const PresentationCallback& presentation_callback) override;
   void SetVSyncEnabled(bool enabled) override;
 
  private:
@@ -58,12 +62,12 @@
 
   void StartSwapBuffers(gfx::SwapResponse* response);
   void FinishSwapBuffers(gfx::SwapResponse response);
-  void FinishSwapBuffersAsync(SwapCompletionCallback callback,
+  void FinishSwapBuffersAsync(GLSurface::SwapCompletionCallback callback,
                               gfx::SwapResponse response,
                               gfx::SwapResult result,
                               std::unique_ptr<gfx::GpuFence> gpu_fence);
 
-  void BufferPresented(PresentationCallback callback,
+  void BufferPresented(const GLSurface::PresentationCallback& callback,
                        const gfx::PresentationFeedback& feedback);
 
   const bool is_gpu_vsync_disabled_;
--- a/gpu/ipc/service/raster_command_buffer_stub.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/service/raster_command_buffer_stub.cc	2019-05-17 18:53:33.084000000 +0300
@@ -114,19 +114,30 @@
     }
   }
 
+  gpu::GpuMemoryBufferFactory* gmb_factory =
+      manager->gpu_memory_buffer_factory();
+  context_group_ = base::MakeRefCounted<gles2::ContextGroup>(
+      manager->gpu_preferences(), gles2::PassthroughCommandDecoderSupported(),
+      manager->mailbox_manager(), CreateMemoryTracker(init_params),
+      manager->shader_translator_cache(),
+      manager->framebuffer_completeness_cache(),
+      shared_context_state->feature_info(),
+      init_params.attribs.bind_generates_resource, channel_->image_manager(),
+      gmb_factory ? gmb_factory->AsImageFactory() : nullptr,
+      /*progress_reporter=*/manager->watchdog(), manager->gpu_feature_info(),
+      manager->discardable_manager(),
+      manager->passthrough_discardable_manager(),
+      manager->shared_image_manager());
+
   surface_ = shared_context_state->surface();
   share_group_ = shared_context_state->share_group();
   use_virtualized_gl_context_ =
       shared_context_state->use_virtualized_gl_contexts();
 
-  memory_tracker_ = CreateMemoryTracker(init_params);
-
-  command_buffer_ =
-      std::make_unique<CommandBufferService>(this, memory_tracker_.get());
+  command_buffer_ = std::make_unique<CommandBufferService>(
+      this, context_group_->transfer_buffer_manager());
   std::unique_ptr<raster::RasterDecoder> decoder(raster::RasterDecoder::Create(
-      this, command_buffer_.get(), manager->outputter(),
-      manager->gpu_feature_info(), manager->gpu_preferences(),
-      memory_tracker_.get(), manager->shared_image_manager(),
+      this, command_buffer_.get(), manager->outputter(), context_group_.get(),
       shared_context_state));
 
   sync_point_client_state_ =
@@ -144,6 +155,11 @@
     return gpu::ContextResult::kTransientFailure;
   }
 
+  if (!context_group_->has_program_cache() &&
+      !context_group_->feature_info()->workarounds().disable_program_cache) {
+    context_group_->set_program_cache(manager->program_cache());
+  }
+
   // Initialize the decoder with either the view or pbuffer GLContext.
   result = decoder->Initialize(surface_, context, true /* offscreen */,
                                gpu::gles2::DisallowedFeatures(),
@@ -177,12 +193,13 @@
   return gpu::ContextResult::kSuccess;
 }
 
-MemoryTracker* RasterCommandBufferStub::GetMemoryTracker() const {
-  return memory_tracker_.get();
+// RasterInterface clients should not manipulate the front buffer.
+void RasterCommandBufferStub::OnTakeFrontBuffer(const Mailbox& mailbox) {
+  NOTREACHED();
 }
-
-bool RasterCommandBufferStub::HandleMessage(const IPC::Message& message) {
-  return false;
+void RasterCommandBufferStub::OnReturnFrontBuffer(const Mailbox& mailbox,
+                                                  bool is_lost) {
+  NOTREACHED();
 }
 
 void RasterCommandBufferStub::OnSwapBuffers(uint64_t swap_id, uint32_t flags) {}
--- a/gpu/ipc/service/raster_command_buffer_stub.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/service/raster_command_buffer_stub.h	2019-05-17 18:53:33.084000000 +0300
@@ -27,15 +27,13 @@
       CommandBufferStub* share_group,
       const GPUCreateCommandBufferConfig& init_params,
       base::UnsafeSharedMemoryRegion shared_state_shm) override;
-  MemoryTracker* GetMemoryTracker() const override;
 
  private:
-  bool HandleMessage(const IPC::Message& message) override;
+  void OnTakeFrontBuffer(const Mailbox& mailbox) override;
+  void OnReturnFrontBuffer(const Mailbox& mailbox, bool is_lost) override;
   void OnSwapBuffers(uint64_t swap_id, uint32_t flags) override;
   void SetActiveURL(GURL url) override;
 
-  std::unique_ptr<MemoryTracker> memory_tracker_;
-
   DISALLOW_COPY_AND_ASSIGN(RasterCommandBufferStub);
 };
 
--- a/gpu/ipc/service/shared_image_stub.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/service/shared_image_stub.cc	2019-05-17 18:53:33.084000000 +0300
@@ -151,7 +151,7 @@
 
 void SharedImageStub::OnCreateGMBSharedImage(
     GpuChannelMsg_CreateGMBSharedImage_Params params) {
-  TRACE_EVENT2("gpu", "SharedImageStub::OnCreateGMBSharedImage", "width",
+  TRACE_EVENT2("gpu", "SharedImageStub::OnCreateSharedImage", "width",
                params.size.width(), "height", params.size.height());
   if (!params.mailbox.IsSharedImage()) {
     LOG(ERROR) << "SharedImageStub: Trying to create a SharedImage with a "
@@ -186,7 +186,7 @@
 
 void SharedImageStub::OnUpdateSharedImage(const Mailbox& mailbox,
                                           uint32_t release_id) {
-  TRACE_EVENT0("gpu", "SharedImageStub::OnUpdateSharedImage");
+  TRACE_EVENT0("gpu", "SharedImageStub::OnDestroySharedImage");
   if (!mailbox.IsSharedImage()) {
     LOG(ERROR) << "SharedImageStub: Trying to access a SharedImage with a "
                   "non-SharedImage mailbox.";
--- a/gpu/ipc/service/stream_texture_android.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/service/stream_texture_android.cc	2019-05-17 18:53:33.084000000 +0300
@@ -28,10 +28,8 @@
 bool StreamTexture::Create(CommandBufferStub* owner_stub,
                            uint32_t client_texture_id,
                            int stream_id) {
-  gles2::ContextGroup* context_group =
-      owner_stub->decoder_context()->GetContextGroup();
-  DCHECK(context_group);
-  TextureManager* texture_manager = context_group->texture_manager();
+  TextureManager* texture_manager =
+      owner_stub->context_group()->texture_manager();
   TextureRef* texture = texture_manager->GetTexture(client_texture_id);
 
   if (texture && (!texture->texture()->target() ||
@@ -161,10 +159,8 @@
 
   UpdateTexImage();
 
-  gles2::ContextGroup* context_group =
-      owner_stub_->decoder_context()->GetContextGroup();
-  DCHECK(context_group);
-  TextureManager* texture_manager = context_group->texture_manager();
+  TextureManager* texture_manager =
+      owner_stub_->context_group()->texture_manager();
   gles2::Texture* texture =
       texture_manager->GetTextureForServiceId(texture_id_);
   if (texture) {
@@ -223,12 +219,7 @@
                                              surface_owner_.get());
 }
 
-StreamTexture::BindOrCopy StreamTexture::ShouldBindOrCopy() {
-  return COPY;
-}
-
 bool StreamTexture::BindTexImage(unsigned target) {
-  NOTREACHED();
   return false;
 }
 
--- a/gpu/ipc/service/stream_texture_android.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/service/stream_texture_android.h	2019-05-17 18:53:33.084000000 +0300
@@ -46,7 +46,6 @@
   // gl::GLImage implementation:
   gfx::Size GetSize() override;
   unsigned GetInternalFormat() override;
-  BindOrCopy ShouldBindOrCopy() override;
   bool BindTexImage(unsigned target) override;
   void ReleaseTexImage(unsigned target) override;
   bool CopyTexImage(unsigned target) override;
--- a/gpu/ipc/service/webgpu_command_buffer_stub.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/service/webgpu_command_buffer_stub.cc	2019-05-17 18:53:33.084000000 +0300
@@ -101,10 +101,31 @@
   share_group_ = manager->share_group();
   use_virtualized_gl_context_ = false;
 
-  memory_tracker_ = CreateMemoryTracker(init_params);
+  TransferBufferManager* transfer_buffer_manager;
+  // TODO: all of this is necessary to get a transfer buffer manager - we would
+  // prefer to create a standalone one instead.
+  {
+    scoped_refptr<gles2::FeatureInfo> feature_info = new gles2::FeatureInfo(
+        manager->gpu_driver_bug_workarounds(), manager->gpu_feature_info());
+    gpu::GpuMemoryBufferFactory* gmb_factory =
+        manager->gpu_memory_buffer_factory();
+    context_group_ = new gles2::ContextGroup(
+        manager->gpu_preferences(), gles2::PassthroughCommandDecoderSupported(),
+        manager->mailbox_manager(), CreateMemoryTracker(init_params),
+        manager->shader_translator_cache(),
+        manager->framebuffer_completeness_cache(), feature_info,
+        init_params.attribs.bind_generates_resource, channel_->image_manager(),
+        gmb_factory ? gmb_factory->AsImageFactory() : nullptr,
+        manager->watchdog() /* progress_reporter */,
+        manager->gpu_feature_info(), manager->discardable_manager(),
+        manager->passthrough_discardable_manager(),
+        manager->shared_image_manager());
+
+    transfer_buffer_manager = context_group_->transfer_buffer_manager();
+  }
 
   command_buffer_ =
-      std::make_unique<CommandBufferService>(this, memory_tracker_.get());
+      std::make_unique<CommandBufferService>(this, transfer_buffer_manager);
   std::unique_ptr<webgpu::WebGPUDecoder> decoder(webgpu::WebGPUDecoder::Create(
       this, command_buffer_.get(), manager->outputter()));
 
@@ -146,12 +167,13 @@
 #endif  // defined(OS_FUCHSIA)
 }
 
-MemoryTracker* WebGPUCommandBufferStub::GetMemoryTracker() const {
-  return memory_tracker_.get();
+// WebGPUInterface clients should not manipulate the front buffer.
+void WebGPUCommandBufferStub::OnTakeFrontBuffer(const Mailbox& mailbox) {
+  LOG(ERROR) << "Called WebGPUCommandBufferStub::OnTakeFrontBuffer";
 }
-
-bool WebGPUCommandBufferStub::HandleMessage(const IPC::Message& message) {
-  return false;
+void WebGPUCommandBufferStub::OnReturnFrontBuffer(const Mailbox& mailbox,
+                                                  bool is_lost) {
+  LOG(ERROR) << "Called WebGPUCommandBufferStub::OnReturnFrontBuffer";
 }
 
 void WebGPUCommandBufferStub::OnSwapBuffers(uint64_t swap_id, uint32_t flags) {}
--- a/gpu/ipc/service/webgpu_command_buffer_stub.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/service/webgpu_command_buffer_stub.h	2019-05-17 18:53:33.084000000 +0300
@@ -27,14 +27,12 @@
       CommandBufferStub* share_group,
       const GPUCreateCommandBufferConfig& init_params,
       base::UnsafeSharedMemoryRegion shared_state_shm) override;
-  MemoryTracker* GetMemoryTracker() const override;
 
  private:
-  bool HandleMessage(const IPC::Message& message) override;
+  void OnTakeFrontBuffer(const Mailbox& mailbox) override;
+  void OnReturnFrontBuffer(const Mailbox& mailbox, bool is_lost) override;
   void OnSwapBuffers(uint64_t swap_id, uint32_t flags) override;
 
-  std::unique_ptr<MemoryTracker> memory_tracker_;
-
   DISALLOW_COPY_AND_ASSIGN(WebGPUCommandBufferStub);
 };
 
--- a/gpu/ipc/webgpu_in_process_context.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/ipc/webgpu_in_process_context.cc	2019-05-17 18:53:33.088000000 +0300
@@ -81,10 +81,9 @@
   }
   transfer_buffer_ = std::make_unique<TransferBuffer>(webgpu_helper.get());
 
-  webgpu_implementation_ = std::make_unique<webgpu::WebGPUImplementation>(
-      webgpu_helper.get(), transfer_buffer_.get(), command_buffer_.get());
+  webgpu_implementation_ =
+      std::make_unique<webgpu::WebGPUImplementation>(webgpu_helper.get());
   helper_ = std::move(webgpu_helper);
-  webgpu_implementation_->Initialize(memory_limits);
   return result;
 }
 
--- a/gpu/perftests/texture_upload_perftest.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/perftests/texture_upload_perftest.cc	2019-05-17 18:53:33.088000000 +0300
@@ -64,9 +64,7 @@
 // clang-format on
 
 void CheckNoGlError(const std::string& msg) {
-  const GLenum error = glGetError();
-  CHECK_EQ(static_cast<GLenum>(GL_NO_ERROR), error)
-      << msg << " " << gl::GLEnums::GetStringError(error);
+  CHECK_EQ(static_cast<GLenum>(GL_NO_ERROR), glGetError()) << " " << msg;
 }
 
 // Utility function to compile a shader from a string.
--- a/gpu/PRESUBMIT.py	2019-05-17 17:45:41.004000000 +0300
+++ b/gpu/PRESUBMIT.py	2019-05-17 18:53:32.940000000 +0300
@@ -4,7 +4,7 @@
 
 """Top-level presubmit script for gpu.
 
-See http://dev.ch40m1um.qjz9zk/developers/how-tos/depottools/presubmit-scripts
+See http://dev.chromium.org/developers/how-tos/depottools/presubmit-scripts
 for more details about the presubmit API built into depot_tools.
 """
 
--- a/gpu/tools/check_gpu_bots.py	2019-05-17 17:45:41.024000000 +0300
+++ b/gpu/tools/check_gpu_bots.py	2019-05-17 18:53:33.088000000 +0300
@@ -17,7 +17,7 @@
 
 class Emailer:
   DEFAULT_EMAIL_PASSWORD_FILE = '.email_password'
-  GMAIL_SMTP_SERVER = 'smtp.9ma1l.qjz9zk:587'
+  GMAIL_SMTP_SERVER = 'smtp.gmail.com:587'
   SUBJECT = 'Chrome GPU Bots Notification'
 
   def __init__(self, email_from, email_to, email_password_file):
@@ -129,7 +129,7 @@
   print 'No most recent build available: %s::%s' % (waterfall_name, bot_name)
 
 class Waterfall:
-  BASE_URL = 'http://build.ch40m1um.qjz9zk/p/'
+  BASE_URL = 'http://build.chromium.org/p/'
   BASE_BUILD_URL = BASE_URL + '%s/builders/%s'
   SPECIFIC_BUILD_URL = BASE_URL + '%s/builders/%s/builds/%s'
   BASE_JSON_BUILDERS_URL = BASE_URL + '%s/json/builders'
--- a/gpu/tools/compositor_model_bench/render_tree.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/tools/compositor_model_bench/render_tree.cc	2019-05-17 18:53:33.096000000 +0300
@@ -456,10 +456,9 @@
 
   int error_code = 0;
   std::string error_message;
-  std::unique_ptr<base::DictionaryValue> root =
-      base::DictionaryValue::From(JSONReader::ReadAndReturnErrorDeprecated(
-          contents, base::JSON_ALLOW_TRAILING_COMMAS, &error_code,
-          &error_message));
+  std::unique_ptr<base::DictionaryValue> root = base::DictionaryValue::From(
+      JSONReader::ReadAndReturnError(contents, base::JSON_ALLOW_TRAILING_COMMAS,
+                                     &error_code, &error_message));
   if (!root) {
     if (error_code) {
       LOG(ERROR) << "Failed to parse JSON file " << path.LossyDisplayName()
--- a/gpu/vulkan/android/vulkan_android_unittests.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/vulkan/android/vulkan_android_unittests.cc	2019-05-17 18:53:33.096000000 +0300
@@ -82,8 +82,15 @@
   // signal operation pending execution before the export.
   // Semaphores can be signaled by including them in a batch as part of a queue
   // submission command, defining a queue operation to signal that semaphore.
-  EXPECT_TRUE(vk_implementation_->SubmitSignalSemaphore(
-      vk_context_provider_->GetDeviceQueue()->GetVulkanQueue(), semaphore1));
+  unsigned int submit_count = 1;
+  VkFence fence = VK_NULL_HANDLE;
+  VkSubmitInfo submit_info = {VK_STRUCTURE_TYPE_SUBMIT_INFO};
+  submit_info.signalSemaphoreCount = 1;
+  submit_info.pSignalSemaphores = &semaphore1;
+  result =
+      vkQueueSubmit(vk_context_provider_->GetDeviceQueue()->GetVulkanQueue(),
+                    submit_count, &submit_info, fence);
+  EXPECT_EQ(result, VK_SUCCESS);
 
   // Export a sync fd from the semaphore.
   base::ScopedFD sync_fd;
--- a/gpu/vulkan/android/vulkan_implementation_android.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/vulkan/android/vulkan_implementation_android.cc	2019-05-17 18:53:33.096000000 +0300
@@ -48,8 +48,8 @@
   return true;
 }
 
-VulkanInstance* VulkanImplementationAndroid::GetVulkanInstance() {
-  return &vulkan_instance_;
+VkInstance VulkanImplementationAndroid::GetVulkanInstance() {
+  return vulkan_instance_.vk_instance();
 }
 
 std::unique_ptr<VulkanSurface> VulkanImplementationAndroid::CreateViewSurface(
@@ -59,14 +59,13 @@
   surface_create_info.sType = VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR;
   surface_create_info.window = window;
   VkResult result = vkCreateAndroidSurfaceKHR_(
-      vulkan_instance_.vk_instance(), &surface_create_info, nullptr, &surface);
+      GetVulkanInstance(), &surface_create_info, nullptr, &surface);
   if (VK_SUCCESS != result) {
     DLOG(ERROR) << "vkCreateAndroidSurfaceKHR() failed: " << result;
     return nullptr;
   }
 
-  return std::make_unique<VulkanSurface>(vulkan_instance_.vk_instance(),
-                                         surface);
+  return std::make_unique<VulkanSurface>(GetVulkanInstance(), surface);
 }
 
 bool VulkanImplementationAndroid::GetPhysicalDevicePresentationSupport(
--- a/gpu/vulkan/android/vulkan_implementation_android.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/vulkan/android/vulkan_implementation_android.h	2019-05-17 18:53:33.096000000 +0300
@@ -23,7 +23,7 @@
 
   // VulkanImplementation:
   bool InitializeVulkanInstance() override;
-  VulkanInstance* GetVulkanInstance() override;
+  VkInstance GetVulkanInstance() override;
   std::unique_ptr<VulkanSurface> CreateViewSurface(
       gfx::AcceleratedWidget window) override;
   bool GetPhysicalDevicePresentationSupport(
--- a/gpu/vulkan/generate_bindings.py	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/vulkan/generate_bindings.py	2019-05-17 18:53:33.096000000 +0300
@@ -14,7 +14,6 @@
 
 VULKAN_UNASSOCIATED_FUNCTIONS = [
 # vkGetInstanceProcAddr belongs here but is handled specially.
-# vkEnumerateInstanceVersion belongs here but is handled specially.
 { 'name': 'vkCreateInstance' },
 { 'name': 'vkEnumerateInstanceExtensionProperties' },
 { 'name': 'vkEnumerateInstanceLayerProperties' },
@@ -71,25 +70,17 @@
 { 'name': 'vkFreeMemory' },
 { 'name': 'vkGetDeviceQueue' },
 { 'name': 'vkGetFenceStatus' },
-{ 'name': 'vkGetImageMemoryRequirements' },
 { 'name': 'vkResetFences' },
 { 'name': 'vkUpdateDescriptorSets' },
 { 'name': 'vkWaitForFences' },
 ]
 
 VULKAN_DEVICE_FUNCTIONS_ANDROID = [
-{ 'name': 'vkGetAndroidHardwareBufferPropertiesANDROID' },
 { 'name': 'vkImportSemaphoreFdKHR' },
-]
-
-VULKAN_DEVICE_FUNCTIONS_LINUX_OR_ANDROID = [
+{ 'name': 'vkGetAndroidHardwareBufferPropertiesANDROID' },
 { 'name': 'vkGetSemaphoreFdKHR' },
 ]
 
-VULKAN_DEVICE_FUNCTIONS_LINUX = [
-{ 'name': 'vkGetMemoryFdKHR'},
-]
-
 VULKAN_QUEUE_FUNCTIONS = [
 { 'name': 'vkQueueSubmit' },
 { 'name': 'vkQueueWaitIdle' },
@@ -142,9 +133,7 @@
 
 def GenerateHeaderFile(file, unassociated_functions, instance_functions,
                        physical_device_functions, device_functions,
-                       device_functions_android,
-                       device_functions_linux_or_android,
-                       device_functions_linux, queue_functions,
+                       device_functions_android, queue_functions,
                        command_buffer_functions, swapchain_functions):
   """Generates gpu/vulkan/vulkan_function_pointers.h"""
 
@@ -183,7 +172,6 @@
   base::NativeLibrary vulkan_loader_library_ = nullptr;
 
   // Unassociated functions
-  PFN_vkEnumerateInstanceVersion vkEnumerateInstanceVersionFn = nullptr;
   PFN_vkGetInstanceProcAddr vkGetInstanceProcAddrFn = nullptr;
 """)
 
@@ -231,30 +219,6 @@
 
   file.write("""\
 
-  // Device functions shared between Linux and Android.
-#if defined(OS_LINUX) || defined(OS_ANDROID)
-""")
-
-  WriteFunctionDeclarations(file, device_functions_linux_or_android)
-
-  file.write("""\
-#endif
-""")
-
-  file.write("""\
-
-  // Linux-only device functions.
-#if defined(OS_LINUX)
-""")
-
-  WriteFunctionDeclarations(file, device_functions_linux)
-
-  file.write("""\
-#endif
-""")
-
-  file.write("""\
-
   // Queue functions
 """)
 
@@ -325,28 +289,6 @@
 
   file.write("""\
 
-#if defined(OS_LINUX) || defined(OS_ANDROID)
-""")
-
-  WriteMacros(file, device_functions_linux_or_android)
-
-  file.write("""\
-#endif
-""")
-
-  file.write("""\
-
-#if defined(OS_LINUX)
-""")
-
-  WriteMacros(file, device_functions_linux)
-
-  file.write("""\
-#endif
-""")
-
-  file.write("""\
-
 // Queue functions
 """)
 
@@ -397,9 +339,7 @@
 
 def GenerateSourceFile(file, unassociated_functions, instance_functions,
                        physical_device_functions, device_functions,
-                       device_functions_android,
-                       device_functions_linux_or_android,
-                       device_functions_linux, queue_functions,
+                       device_functions_android, queue_functions,
                        command_buffer_functions, swapchain_functions):
   """Generates gpu/vulkan/vulkan_function_pointers.cc"""
 
@@ -430,11 +370,6 @@
   if (!vkGetInstanceProcAddrFn)
     return false;
 
-  vkEnumerateInstanceVersionFn =
-      reinterpret_cast<PFN_vkEnumerateInstanceVersion>(
-          vkGetInstanceProcAddrFn(nullptr, "vkEnumerateInstanceVersion"));
-  // vkEnumerateInstanceVersion didn't exist in Vulkan 1.0, so we should
-  // proceed even if we fail to get vkEnumerateInstanceVersion pointer.
 """)
 
   WriteUnassociatedFunctionPointerInitialization(file, unassociated_functions)
@@ -485,32 +420,6 @@
 
   file.write("""\
 
-#if defined(OS_LINUX) || defined(OS_ANDROID)
-
-""")
-
-  WriteDeviceFunctionPointerInitialization(file,
-                                           device_functions_linux_or_android)
-
-  file.write("""\
-#endif
-""")
-
-  file.write("""\
-
-#if defined(OS_LINUX)
-
-""")
-
-  WriteDeviceFunctionPointerInitialization(file,
-                                           device_functions_linux)
-
-  file.write("""\
-#endif
-""")
-
-  file.write("""\
-
   // Queue functions
 """)
   WriteDeviceFunctionPointerInitialization(file, queue_functions)
@@ -563,8 +472,6 @@
                      VULKAN_INSTANCE_FUNCTIONS,
                      VULKAN_PHYSICAL_DEVICE_FUNCTIONS, VULKAN_DEVICE_FUNCTIONS,
                      VULKAN_DEVICE_FUNCTIONS_ANDROID,
-                     VULKAN_DEVICE_FUNCTIONS_LINUX_OR_ANDROID,
-                     VULKAN_DEVICE_FUNCTIONS_LINUX,
                      VULKAN_QUEUE_FUNCTIONS, VULKAN_COMMAND_BUFFER_FUNCTIONS,
                      VULKAN_SWAPCHAIN_FUNCTIONS)
   header_file.close()
@@ -576,8 +483,6 @@
                      VULKAN_INSTANCE_FUNCTIONS,
                      VULKAN_PHYSICAL_DEVICE_FUNCTIONS, VULKAN_DEVICE_FUNCTIONS,
                      VULKAN_DEVICE_FUNCTIONS_ANDROID,
-                     VULKAN_DEVICE_FUNCTIONS_LINUX_OR_ANDROID,
-                     VULKAN_DEVICE_FUNCTIONS_LINUX,
                      VULKAN_QUEUE_FUNCTIONS, VULKAN_COMMAND_BUFFER_FUNCTIONS,
                      VULKAN_SWAPCHAIN_FUNCTIONS)
   source_file.close()
--- a/gpu/vulkan/tests/vulkan_tests_main.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/vulkan/tests/vulkan_tests_main.cc	2019-05-17 18:53:33.100000000 +0300
@@ -2,7 +2,6 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "base/bind.h"
 #include "base/command_line.h"
 #include "base/test/launcher/unit_test_launcher.h"
 #include "base/test/test_suite.h"
--- a/gpu/vulkan/vulkan_command_buffer.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/vulkan/vulkan_command_buffer.cc	2019-05-17 18:53:33.100000000 +0300
@@ -167,7 +167,7 @@
   if (VK_SUCCESS != result) {
     DLOG(ERROR) << "vkEndCommandBuffer() failed: " << result;
   }
-}
+};
 
 ScopedMultiUseCommandBufferRecorder::ScopedMultiUseCommandBufferRecorder(
     VulkanCommandBuffer& command_buffer)
--- a/gpu/vulkan/vulkan_function_pointers.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/vulkan/vulkan_function_pointers.cc	2019-05-17 18:53:33.100000000 +0300
@@ -32,11 +32,6 @@
   if (!vkGetInstanceProcAddrFn)
     return false;
 
-  vkEnumerateInstanceVersionFn =
-      reinterpret_cast<PFN_vkEnumerateInstanceVersion>(
-          vkGetInstanceProcAddrFn(nullptr, "vkEnumerateInstanceVersion"));
-  // vkEnumerateInstanceVersion didn't exist in Vulkan 1.0, so we should
-  // proceed even if we fail to get vkEnumerateInstanceVersion pointer.
   vkCreateInstanceFn = reinterpret_cast<PFN_vkCreateInstance>(
       vkGetInstanceProcAddrFn(nullptr, "vkCreateInstance"));
   if (!vkCreateInstanceFn)
@@ -273,12 +268,6 @@
   if (!vkGetFenceStatusFn)
     return false;
 
-  vkGetImageMemoryRequirementsFn =
-      reinterpret_cast<PFN_vkGetImageMemoryRequirements>(
-          vkGetDeviceProcAddrFn(vk_device, "vkGetImageMemoryRequirements"));
-  if (!vkGetImageMemoryRequirementsFn)
-    return false;
-
   vkResetFencesFn = reinterpret_cast<PFN_vkResetFences>(
       vkGetDeviceProcAddrFn(vk_device, "vkResetFences"));
   if (!vkResetFencesFn)
@@ -296,6 +285,11 @@
 
 #if defined(OS_ANDROID)
 
+  vkImportSemaphoreFdKHRFn = reinterpret_cast<PFN_vkImportSemaphoreFdKHR>(
+      vkGetDeviceProcAddrFn(vk_device, "vkImportSemaphoreFdKHR"));
+  if (!vkImportSemaphoreFdKHRFn)
+    return false;
+
   vkGetAndroidHardwareBufferPropertiesANDROIDFn =
       reinterpret_cast<PFN_vkGetAndroidHardwareBufferPropertiesANDROID>(
           vkGetDeviceProcAddrFn(vk_device,
@@ -303,30 +297,12 @@
   if (!vkGetAndroidHardwareBufferPropertiesANDROIDFn)
     return false;
 
-  vkImportSemaphoreFdKHRFn = reinterpret_cast<PFN_vkImportSemaphoreFdKHR>(
-      vkGetDeviceProcAddrFn(vk_device, "vkImportSemaphoreFdKHR"));
-  if (!vkImportSemaphoreFdKHRFn)
-    return false;
-
-#endif
-
-#if defined(OS_LINUX) || defined(OS_ANDROID)
-
   vkGetSemaphoreFdKHRFn = reinterpret_cast<PFN_vkGetSemaphoreFdKHR>(
       vkGetDeviceProcAddrFn(vk_device, "vkGetSemaphoreFdKHR"));
   if (!vkGetSemaphoreFdKHRFn)
     return false;
 
 #endif
-
-#if defined(OS_LINUX)
-
-  vkGetMemoryFdKHRFn = reinterpret_cast<PFN_vkGetMemoryFdKHR>(
-      vkGetDeviceProcAddrFn(vk_device, "vkGetMemoryFdKHR"));
-  if (!vkGetMemoryFdKHRFn)
-    return false;
-
-#endif
 
   // Queue functions
   vkQueueSubmitFn = reinterpret_cast<PFN_vkQueueSubmit>(
--- a/gpu/vulkan/vulkan_function_pointers.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/vulkan/vulkan_function_pointers.h	2019-05-17 18:53:33.100000000 +0300
@@ -40,7 +40,6 @@
   base::NativeLibrary vulkan_loader_library_ = nullptr;
 
   // Unassociated functions
-  PFN_vkEnumerateInstanceVersion vkEnumerateInstanceVersionFn = nullptr;
   PFN_vkGetInstanceProcAddr vkGetInstanceProcAddrFn = nullptr;
   PFN_vkCreateInstance vkCreateInstanceFn = nullptr;
   PFN_vkEnumerateInstanceExtensionProperties
@@ -101,28 +100,18 @@
   PFN_vkFreeMemory vkFreeMemoryFn = nullptr;
   PFN_vkGetDeviceQueue vkGetDeviceQueueFn = nullptr;
   PFN_vkGetFenceStatus vkGetFenceStatusFn = nullptr;
-  PFN_vkGetImageMemoryRequirements vkGetImageMemoryRequirementsFn = nullptr;
   PFN_vkResetFences vkResetFencesFn = nullptr;
   PFN_vkUpdateDescriptorSets vkUpdateDescriptorSetsFn = nullptr;
   PFN_vkWaitForFences vkWaitForFencesFn = nullptr;
 
   // Android only device functions.
 #if defined(OS_ANDROID)
+  PFN_vkImportSemaphoreFdKHR vkImportSemaphoreFdKHRFn = nullptr;
   PFN_vkGetAndroidHardwareBufferPropertiesANDROID
       vkGetAndroidHardwareBufferPropertiesANDROIDFn = nullptr;
-  PFN_vkImportSemaphoreFdKHR vkImportSemaphoreFdKHRFn = nullptr;
-#endif
-
-  // Device functions shared between Linux and Android.
-#if defined(OS_LINUX) || defined(OS_ANDROID)
   PFN_vkGetSemaphoreFdKHR vkGetSemaphoreFdKHRFn = nullptr;
 #endif
 
-  // Linux-only device functions.
-#if defined(OS_LINUX)
-  PFN_vkGetMemoryFdKHR vkGetMemoryFdKHRFn = nullptr;
-#endif
-
   // Queue functions
   PFN_vkQueueSubmit vkQueueSubmitFn = nullptr;
   PFN_vkQueueWaitIdle vkQueueWaitIdleFn = nullptr;
@@ -230,30 +219,21 @@
 #define vkFreeMemory gpu::GetVulkanFunctionPointers()->vkFreeMemoryFn
 #define vkGetDeviceQueue gpu::GetVulkanFunctionPointers()->vkGetDeviceQueueFn
 #define vkGetFenceStatus gpu::GetVulkanFunctionPointers()->vkGetFenceStatusFn
-#define vkGetImageMemoryRequirements \
-  gpu::GetVulkanFunctionPointers()->vkGetImageMemoryRequirementsFn
 #define vkResetFences gpu::GetVulkanFunctionPointers()->vkResetFencesFn
 #define vkUpdateDescriptorSets \
   gpu::GetVulkanFunctionPointers()->vkUpdateDescriptorSetsFn
 #define vkWaitForFences gpu::GetVulkanFunctionPointers()->vkWaitForFencesFn
 
 #if defined(OS_ANDROID)
+#define vkImportSemaphoreFdKHR \
+  gpu::GetVulkanFunctionPointers()->vkImportSemaphoreFdKHRFn
 #define vkGetAndroidHardwareBufferPropertiesANDROID \
   gpu::GetVulkanFunctionPointers()                  \
       ->vkGetAndroidHardwareBufferPropertiesANDROIDFn
-#define vkImportSemaphoreFdKHR \
-  gpu::GetVulkanFunctionPointers()->vkImportSemaphoreFdKHRFn
-#endif
-
-#if defined(OS_LINUX) || defined(OS_ANDROID)
 #define vkGetSemaphoreFdKHR \
   gpu::GetVulkanFunctionPointers()->vkGetSemaphoreFdKHRFn
 #endif
 
-#if defined(OS_LINUX)
-#define vkGetMemoryFdKHR gpu::GetVulkanFunctionPointers()->vkGetMemoryFdKHRFn
-#endif
-
 // Queue functions
 #define vkQueueSubmit gpu::GetVulkanFunctionPointers()->vkQueueSubmitFn
 #define vkQueueWaitIdle gpu::GetVulkanFunctionPointers()->vkQueueWaitIdleFn
--- a/gpu/vulkan/vulkan_implementation.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/vulkan/vulkan_implementation.cc	2019-05-17 18:53:33.100000000 +0300
@@ -6,8 +6,6 @@
 
 #include "base/bind.h"
 #include "gpu/vulkan/vulkan_device_queue.h"
-#include "gpu/vulkan/vulkan_function_pointers.h"
-#include "gpu/vulkan/vulkan_instance.h"
 
 namespace gpu {
 
@@ -19,7 +17,7 @@
     VulkanImplementation* vulkan_implementation,
     uint32_t option) {
   auto device_queue = std::make_unique<VulkanDeviceQueue>(
-      vulkan_implementation->GetVulkanInstance()->vk_instance());
+      vulkan_implementation->GetVulkanInstance());
   auto callback = base::BindRepeating(
       &VulkanImplementation::GetPhysicalDevicePresentationSupport,
       base::Unretained(vulkan_implementation));
@@ -34,34 +32,4 @@
   return device_queue;
 }
 
-bool VulkanImplementation::SubmitSignalSemaphore(VkQueue vk_queue,
-                                                 VkSemaphore vk_semaphore,
-                                                 VkFence vk_fence) {
-  // Structure specifying a queue submit operation.
-  VkSubmitInfo submit_info = {VK_STRUCTURE_TYPE_SUBMIT_INFO};
-  submit_info.signalSemaphoreCount = 1;
-  submit_info.pSignalSemaphores = &vk_semaphore;
-  const unsigned int submit_count = 1;
-  if (vkQueueSubmit(vk_queue, submit_count, &submit_info, vk_fence) !=
-      VK_SUCCESS) {
-    return false;
-  }
-  return true;
-}
-
-bool VulkanImplementation::SubmitWaitSemaphore(VkQueue vk_queue,
-                                               VkSemaphore vk_semaphore,
-                                               VkFence vk_fence) {
-  // Structure specifying a queue submit operation.
-  VkSubmitInfo submit_info = {VK_STRUCTURE_TYPE_SUBMIT_INFO};
-  submit_info.waitSemaphoreCount = 1;
-  submit_info.pWaitSemaphores = &vk_semaphore;
-  const unsigned int submit_count = 1;
-  if (vkQueueSubmit(vk_queue, submit_count, &submit_info, vk_fence) !=
-      VK_SUCCESS) {
-    return false;
-  }
-  return true;
-}
-
 }  // namespace gpu
--- a/gpu/vulkan/vulkan_implementation.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/vulkan/vulkan_implementation.h	2019-05-17 18:53:33.100000000 +0300
@@ -8,6 +8,7 @@
 #include <vulkan/vulkan.h>
 #include <memory>
 
+#include "base/files/scoped_file.h"
 #include "base/macros.h"
 #include "build/build_config.h"
 #include "gpu/vulkan/vulkan_export.h"
@@ -27,11 +28,9 @@
 
 class VulkanDeviceQueue;
 class VulkanSurface;
-class VulkanInstance;
 
-// Base class which provides functions for creating vulkan objects for different
-// platforms that use platform-specific extensions (e.g. for creation of
-// VkSurfaceKHR objects). It also provides helper/utility functions.
+// This object provides factory functions for creating vulkan objects that use
+// platform-specific extensions (e.g. for creation of VkSurfaceKHR objects).
 class VULKAN_EXPORT VulkanImplementation {
  public:
   VulkanImplementation();
@@ -40,7 +39,7 @@
 
   virtual bool InitializeVulkanInstance() = 0;
 
-  virtual VulkanInstance* GetVulkanInstance() = 0;
+  virtual VkInstance GetVulkanInstance() = 0;
 
   virtual std::unique_ptr<VulkanSurface> CreateViewSurface(
       gfx::AcceleratedWidget window) = 0;
@@ -62,20 +61,6 @@
       VkDevice vk_device,
       VkFence vk_fence) = 0;
 
-  // Submits a semaphore to be signalled to the vulkan queue. Semaphore is
-  // signalled once this submission is executed. vk_fence is an optional handle
-  // to fence to be signaled once this submission completes execution.
-  bool SubmitSignalSemaphore(VkQueue vk_queue,
-                             VkSemaphore vk_semaphore,
-                             VkFence vk_fence = VK_NULL_HANDLE);
-
-  // Submits a semaphore to be waited upon to the vulkan queue. Semaphore is
-  // waited on before this submission is executed. vk_fence is an optional
-  // handle to fence to be signaled once this submission completes execution.
-  bool SubmitWaitSemaphore(VkQueue vk_queue,
-                           VkSemaphore vk_semaphore,
-                           VkFence vk_fence = VK_NULL_HANDLE);
-
 #if defined(OS_ANDROID)
   // Import a VkSemaphore from a POSIX sync file descriptor. Importing a
   // semaphore payload from a file descriptor transfers ownership of the file
--- a/gpu/vulkan/vulkan_instance.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/vulkan/vulkan_instance.cc	2019-05-17 18:53:33.100000000 +0300
@@ -56,23 +56,12 @@
   if (!vulkan_function_pointers->BindUnassociatedFunctionPointers())
     return false;
 
-  uint32_t supported_api_version = VK_MAKE_VERSION(1, 0, 0);
-  if (vulkan_function_pointers->vkEnumerateInstanceVersionFn) {
-    vulkan_function_pointers->vkEnumerateInstanceVersionFn(
-        &supported_api_version);
-  }
-
-  // Use Vulkan 1.1 if it's available.
-  api_version_ = (supported_api_version >= VK_MAKE_VERSION(1, 1, 0))
-                     ? VK_MAKE_VERSION(1, 1, 0)
-                     : VK_MAKE_VERSION(1, 0, 0);
-
   VkResult result = VK_SUCCESS;
 
   VkApplicationInfo app_info = {};
   app_info.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;
   app_info.pApplicationName = "Chromium";
-  app_info.apiVersion = api_version_;
+  app_info.apiVersion = VK_MAKE_VERSION(1, 1, 0);
 
   std::vector<const char*> enabled_extensions;
   enabled_extensions.insert(std::end(enabled_extensions),
--- a/gpu/vulkan/vulkan_instance.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/vulkan/vulkan_instance.h	2019-05-17 18:53:33.100000000 +0300
@@ -29,9 +29,6 @@
   bool Initialize(const std::vector<const char*>& required_extensions,
                   const std::vector<const char*>& required_layers);
 
-  // VkApplicationInfo.apiVersion value used to initialize the instance.
-  uint32_t api_version() const { return api_version_; }
-
   const gfx::ExtensionSet& enabled_extensions() const {
     return enabled_extensions_;
   }
@@ -41,8 +38,6 @@
  private:
   void Destroy();
 
-  uint32_t api_version_;
-
   VkInstance vk_instance_ = VK_NULL_HANDLE;
   gfx::ExtensionSet enabled_extensions_;
   bool debug_report_enabled_ = false;
--- a/gpu/vulkan/vulkan_surface.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/vulkan/vulkan_surface.cc	2019-05-17 18:53:33.100000000 +0300
@@ -85,7 +85,7 @@
 
   if (formats.size() == 1 && VK_FORMAT_UNDEFINED == formats[0].format) {
     surface_format_.format = preferred_formats[0];
-    surface_format_.colorSpace = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR;
+    surface_format_.colorSpace = VK_COLORSPACE_SRGB_NONLINEAR_KHR;
   } else {
     bool format_set = false;
     for (VkSurfaceFormatKHR supported_format : formats) {
@@ -93,7 +93,7 @@
       while (counter < size && format_set == false) {
         if (supported_format.format == preferred_formats[counter]) {
           surface_format_ = supported_format;
-          surface_format_.colorSpace = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR;
+          surface_format_.colorSpace = VK_COLORSPACE_SRGB_NONLINEAR_KHR;
           format_set = true;
         }
         counter++;
--- a/gpu/vulkan/win32/vulkan_implementation_win32.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/vulkan/win32/vulkan_implementation_win32.cc	2019-05-17 18:53:33.100000000 +0300
@@ -55,8 +55,8 @@
   return true;
 }
 
-VulkanInstance* VulkanImplementationWin32::GetVulkanInstance() {
-  return &vulkan_instance_;
+VkInstance VulkanImplementationWin32::GetVulkanInstance() {
+  return vulkan_instance_.vk_instance();
 }
 
 std::unique_ptr<VulkanSurface> VulkanImplementationWin32::CreateViewSurface(
@@ -68,14 +68,13 @@
       reinterpret_cast<HINSTANCE>(GetWindowLongPtr(window, GWLP_HINSTANCE));
   surface_create_info.hwnd = window;
   VkResult result = vkCreateWin32SurfaceKHR_(
-      vulkan_instance_.vk_instance(), &surface_create_info, nullptr, &surface);
+      GetVulkanInstance(), &surface_create_info, nullptr, &surface);
   if (VK_SUCCESS != result) {
     DLOG(ERROR) << "vkCreatWin32SurfaceKHR() failed: " << result;
     return nullptr;
   }
 
-  return std::make_unique<VulkanSurface>(vulkan_instance_.vk_instance(),
-                                         surface);
+  return std::make_unique<VulkanSurface>(GetVulkanInstance(), surface);
 }
 
 bool VulkanImplementationWin32::GetPhysicalDevicePresentationSupport(
--- a/gpu/vulkan/win32/vulkan_implementation_win32.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/vulkan/win32/vulkan_implementation_win32.h	2019-05-17 18:53:33.100000000 +0300
@@ -21,7 +21,7 @@
 
   // VulkanImplementation:
   bool InitializeVulkanInstance() override;
-  VulkanInstance* GetVulkanInstance() override;
+  VkInstance GetVulkanInstance() override;
   std::unique_ptr<VulkanSurface> CreateViewSurface(
       gfx::AcceleratedWidget window) override;
   bool GetPhysicalDevicePresentationSupport(
--- a/gpu/vulkan/x/vulkan_implementation_x11.cc	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/vulkan/x/vulkan_implementation_x11.cc	2019-05-17 18:53:33.100000000 +0300
@@ -61,8 +61,8 @@
   return true;
 }
 
-VulkanInstance* VulkanImplementationX11::GetVulkanInstance() {
-  return &vulkan_instance_;
+VkInstance VulkanImplementationX11::GetVulkanInstance() {
+  return vulkan_instance_.vk_instance();
 }
 
 std::unique_ptr<VulkanSurface> VulkanImplementationX11::CreateViewSurface(
@@ -73,14 +73,13 @@
   surface_create_info.dpy = x_display_;
   surface_create_info.window = window;
   VkResult result = vkCreateXlibSurfaceKHR_(
-      vulkan_instance_.vk_instance(), &surface_create_info, nullptr, &surface);
+      GetVulkanInstance(), &surface_create_info, nullptr, &surface);
   if (VK_SUCCESS != result) {
     DLOG(ERROR) << "vkCreateXlibSurfaceKHR() failed: " << result;
     return nullptr;
   }
 
-  return std::make_unique<VulkanSurface>(vulkan_instance_.vk_instance(),
-                                         surface);
+  return std::make_unique<VulkanSurface>(GetVulkanInstance(), surface);
 }
 
 bool VulkanImplementationX11::GetPhysicalDevicePresentationSupport(
@@ -95,9 +94,7 @@
 
 std::vector<const char*>
 VulkanImplementationX11::GetRequiredDeviceExtensions() {
-  return {VK_KHR_SWAPCHAIN_EXTENSION_NAME,
-          VK_KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME,
-          VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME};
+  return {VK_KHR_SWAPCHAIN_EXTENSION_NAME};
 }
 
 VkFence VulkanImplementationX11::CreateVkFenceForGpuFence(VkDevice vk_device) {
--- a/gpu/vulkan/x/vulkan_implementation_x11.h	2019-05-01 01:22:49.000000000 +0300
+++ b/gpu/vulkan/x/vulkan_implementation_x11.h	2019-05-17 18:53:33.100000000 +0300
@@ -23,7 +23,7 @@
 
   // VulkanImplementation:
   bool InitializeVulkanInstance() override;
-  VulkanInstance* GetVulkanInstance() override;
+  VkInstance GetVulkanInstance() override;
   std::unique_ptr<VulkanSurface> CreateViewSurface(
       gfx::AcceleratedWidget window) override;
   bool GetPhysicalDevicePresentationSupport(
--- a/gpu/command_buffer/service/raster_decoder_mock.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/gpu/command_buffer/service/raster_decoder_mock.cc	2019-05-17 18:53:33.028000000 +0300
@@ -0,0 +1,26 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "gpu/command_buffer/service/raster_decoder_mock.h"
+
+#include "gpu/command_buffer/service/gles2_cmd_decoder.h"
+
+namespace gpu {
+namespace raster {
+
+MockRasterDecoder::MockRasterDecoder(
+    CommandBufferServiceBase* command_buffer_service)
+    : RasterDecoder(command_buffer_service, /*outputter=*/nullptr),
+      weak_ptr_factory_(this) {
+  ON_CALL(*this, MakeCurrent()).WillByDefault(testing::Return(true));
+}
+
+MockRasterDecoder::~MockRasterDecoder() = default;
+
+base::WeakPtr<DecoderContext> MockRasterDecoder::AsWeakPtr() {
+  return weak_ptr_factory_.GetWeakPtr();
+}
+
+}  // namespace raster
+}  // namespace gpu
--- a/gpu/command_buffer/service/raster_decoder_mock.h	1970-01-01 03:00:00.000000000 +0300
+++ b/gpu/command_buffer/service/raster_decoder_mock.h	2019-05-17 18:53:33.028000000 +0300
@@ -0,0 +1,173 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+// This file contains the mock RasterDecoder class.
+
+#ifndef GPU_COMMAND_BUFFER_SERVICE_RASTER_DECODER_MOCK_H_
+#define GPU_COMMAND_BUFFER_SERVICE_RASTER_DECODER_MOCK_H_
+
+#include <stdint.h>
+
+#include <vector>
+
+#include "base/callback.h"
+#include "base/macros.h"
+#include "gpu/command_buffer/common/context_creation_attribs.h"
+#include "gpu/command_buffer/common/mailbox.h"
+#include "gpu/command_buffer/service/raster_decoder.h"
+#include "gpu/command_buffer/service/shader_translator.h"
+#include "testing/gmock/include/gmock/gmock.h"
+#include "ui/gfx/geometry/size.h"
+
+namespace gl {
+class GLContext;
+class GLSurface;
+}  // namespace gl
+
+namespace gpu {
+class QueryManager;
+
+namespace gles2 {
+class ContextGroup;
+class ErrorState;
+class FeatureInfo;
+class GpuFenceManager;
+class GLES2Util;
+class ImageManager;
+class Logger;
+class Texture;
+struct ContextState;
+}  // namespace gles2
+
+namespace raster {
+
+class MockRasterDecoder : public RasterDecoder {
+ public:
+  explicit MockRasterDecoder(CommandBufferServiceBase* command_buffer_service);
+  ~MockRasterDecoder() override;
+
+  base::WeakPtr<DecoderContext> AsWeakPtr() override;
+
+  MOCK_METHOD5(
+      Initialize,
+      gpu::ContextResult(const scoped_refptr<gl::GLSurface>& surface,
+                         const scoped_refptr<gl::GLContext>& context,
+                         bool offscreen,
+                         const gles2::DisallowedFeatures& disallowed_features,
+                         const ContextCreationAttribs& attrib_helper));
+  MOCK_METHOD1(Destroy, void(bool have_context));
+  MOCK_METHOD0(MakeCurrent, bool());
+  MOCK_METHOD1(GetServiceIdForTesting, uint32_t(uint32_t client_id));
+  MOCK_METHOD0(GetGLES2Util, gles2::GLES2Util*());
+  MOCK_METHOD0(GetGLSurface, gl::GLSurface*());
+  MOCK_METHOD0(GetGLContext, gl::GLContext*());
+  MOCK_METHOD0(GetContextGroup, gles2::ContextGroup*());
+  MOCK_CONST_METHOD0(GetFeatureInfo, const gles2::FeatureInfo*());
+  MOCK_METHOD0(GetContextState, const gles2::ContextState*());
+  MOCK_METHOD0(GetCapabilities, Capabilities());
+  MOCK_CONST_METHOD0(HasPendingQueries, bool());
+  MOCK_METHOD1(ProcessPendingQueries, void(bool));
+  MOCK_CONST_METHOD0(HasMoreIdleWork, bool());
+  MOCK_METHOD0(PerformIdleWork, void());
+  MOCK_CONST_METHOD0(HasPollingWork, bool());
+  MOCK_METHOD0(PerformPollingWork, void());
+  MOCK_CONST_METHOD0(RestoreGlobalState, void());
+  MOCK_CONST_METHOD0(ClearAllAttributes, void());
+  MOCK_CONST_METHOD0(RestoreAllAttributes, void());
+  MOCK_METHOD1(RestoreState, void(const gles2::ContextState* prev_state));
+  MOCK_CONST_METHOD0(RestoreActiveTexture, void());
+  MOCK_CONST_METHOD1(RestoreAllTextureUnitAndSamplerBindings,
+                     void(const gles2::ContextState* state));
+  MOCK_CONST_METHOD1(RestoreActiveTextureUnitBinding,
+                     void(unsigned int target));
+  MOCK_METHOD0(RestoreAllExternalTextureBindingsIfNeeded, void());
+  MOCK_METHOD1(RestoreBufferBinding, void(unsigned int target));
+  MOCK_CONST_METHOD0(RestoreBufferBindings, void());
+  MOCK_CONST_METHOD0(RestoreFramebufferBindings, void());
+  MOCK_CONST_METHOD0(RestoreProgramBindings, void());
+  MOCK_METHOD0(RestoreRenderbufferBindings, void());
+  MOCK_METHOD1(RestoreTextureState, void(unsigned service_id));
+  MOCK_CONST_METHOD1(RestoreTextureUnitBindings, void(unsigned unit));
+  MOCK_METHOD1(RestoreVertexAttribArray, void(unsigned index));
+
+  MOCK_METHOD0(GetQueryManager, QueryManager*());
+  MOCK_METHOD2(SetQueryCallback, void(unsigned int, base::OnceClosure));
+  MOCK_METHOD0(GetGpuFenceManager, gpu::gles2::GpuFenceManager*());
+  MOCK_METHOD1(SetIgnoreCachedStateForTest, void(bool ignore));
+  MOCK_METHOD0(GetImageManagerForTest, gles2::ImageManager*());
+  MOCK_METHOD0(GetTransferCacheForTest, ServiceTransferCache*());
+  MOCK_METHOD0(DecoderIdForTest, int());
+  MOCK_METHOD0(SetUpForRasterCHROMIUMForTest, void());
+  MOCK_METHOD0(SetOOMErrorForTest, void());
+  MOCK_METHOD0(DisableFlushWorkaroundForTest, void());
+  MOCK_METHOD4(DoCommands,
+               error::Error(unsigned int num_commands,
+                            const volatile void* buffer,
+                            int num_entries,
+                            int* entries_processed));
+  MOCK_METHOD2(GetServiceTextureId,
+               bool(uint32_t client_texture_id, uint32_t* service_texture_id));
+  MOCK_METHOD0(GetErrorState, gles2::ErrorState*());
+  MOCK_METHOD8(CreateAbstractTexture,
+               std::unique_ptr<gpu::gles2::AbstractTexture>(
+                   unsigned /* GLenum */ target,
+                   unsigned /* GLenum */ internal_format,
+                   int /* GLsizei */ width,
+                   int /* GLsizei */ height,
+                   int /* GLsizei */ depth,
+                   int /* GLint */ border,
+                   unsigned /* GLenum */ format,
+                   unsigned /* GLenum */ type));
+
+  MOCK_METHOD0(GetLogger, gles2::Logger*());
+  MOCK_CONST_METHOD0(WasContextLost, bool());
+  MOCK_CONST_METHOD0(WasContextLostByRobustnessExtension, bool());
+  MOCK_METHOD1(MarkContextLost, void(gpu::error::ContextLostReason reason));
+  MOCK_METHOD0(CheckResetStatus, bool());
+  MOCK_METHOD4(BindImage,
+               void(uint32_t client_texture_id,
+                    uint32_t texture_target,
+                    gl::GLImage* image,
+                    bool can_bind_to_sampler));
+  MOCK_METHOD1(IsCompressedTextureFormat, bool(unsigned format));
+  MOCK_METHOD9(ClearLevel,
+               bool(gles2::Texture* texture,
+                    unsigned target,
+                    int level,
+                    unsigned format,
+                    unsigned type,
+                    int xoffset,
+                    int yoffset,
+                    int width,
+                    int height));
+  MOCK_METHOD6(ClearCompressedTextureLevel,
+               bool(gles2::Texture* texture,
+                    unsigned target,
+                    int level,
+                    unsigned format,
+                    int width,
+                    int height));
+  MOCK_METHOD8(ClearLevel3D,
+               bool(gles2::Texture* texture,
+                    unsigned target,
+                    int level,
+                    unsigned format,
+                    unsigned type,
+                    int width,
+                    int height,
+                    int depth));
+  MOCK_METHOD1(SetCopyTextureResourceManagerForTest,
+               void(gles2::CopyTextureCHROMIUMResourceManager*
+                        copy_texture_resource_manager));
+
+ private:
+  base::WeakPtrFactory<MockRasterDecoder> weak_ptr_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(MockRasterDecoder);
+};
+
+}  // namespace raster
+}  // namespace gpu
+
+#endif  // GPU_COMMAND_BUFFER_SERVICE_RASTER_DECODER_MOCK_H_
